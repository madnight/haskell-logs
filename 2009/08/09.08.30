00:01:31 <copumpkin> dmwit: yay, the identity matrix function worked!
00:01:37 <dmwit> Awesome!
00:01:45 * copumpkin writes his pointless Num instance
00:02:37 <dmwit> copumpkin: http://tinyurl.com/ohqrqc
00:02:47 <copumpkin> lol
00:11:09 <copumpkin> *Vec> (3 - (5 * 5))^2 :: Mat (SheTyS (SheTyS SheTyZ)) (SheTyS (SheTyS SheTyZ)) Double
00:11:09 <copumpkin> {484.0, 0.0}
00:11:09 <copumpkin> {0.0, 484.0}
00:11:30 <copumpkin> just working with identity matrices is kinda boring though :/
00:11:37 <dmwit> haha
00:11:53 <copumpkin> it'd be nice if I could run my ghci input through she too
00:12:02 <copumpkin> so I didn't have to go typing SheTy* in
00:12:07 <PetRat> How do you get a module to export all its constructors without naming the types explicitly  e.g. Constructor(..)
00:12:29 <dmwit> You can't.
00:12:37 <dmwit> You can export *everything* by having no export list.
00:12:51 <dmwit> But if you want to hide some functions, you'll have to explicitly list all the types you want to export.
00:13:03 <PetRat> dmwit: does that export the constructors too? I had a problem... thought that was my problem, but maybe not.
00:13:08 <copumpkin> we need hpath! like xpath, but for selecting symbols to export
00:13:21 <int-e> PetRat: the (..) exports the constructors.
00:13:22 <dmwit> PetRat: if you have data Foo = Bar | Baz, then
00:13:30 <dmwit> Foo(..) -- will export Foo, Bar, and Baz
00:14:02 * int-e holds his breath while dmwit explains that this is a list of constructors to export.
00:14:07 <PetRat> dmwit: I mean omitting the export list should export everything? I was having a problem with a constructor in an imported module, and thought I had omitted the export list in that module.
00:14:20 <PetRat> But I guess not.
00:14:51 <dmwit> Yes, if you omit the export list, all type, constructors, classes, instances, and functions that are defined are also exported.
00:15:23 <PetRat> dmwit: thanks, I'll take a second look at this.
00:42:33 <ksf> PetRat, you can write a wrapper module and do an import Foo hiding (bar, baz), and then a module re-export.
00:43:22 <ksf> @faq can haskell give me a cake that I can eat, too, if I abuse it in the right way?
00:43:28 <ksf> @bot
00:43:28 <lunabot>  :o
00:43:38 <ksf> she's on vacation, again.
00:58:04 <kowey> haskell hackathon is on!
01:09:33 <greap> I'm trying to solve problem 14 in project euler, and my solution seems to be sticking at 10^6
01:09:45 <greap> anyone want to look at some probably awful code?
01:09:47 <greap> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8840#a8840
01:10:28 <int-e> greap: I doubt that's the whole code ;)
01:10:54 <int-e> uhm
01:11:01 <greap> int-e: ?
01:11:26 <greap> The concurrency stuff is purely to see where the code was getting up to
01:11:28 <int-e> no it is, but why does hpaste put it into a box 49 characters wide for me? *wonders*
01:12:05 <greap> it seems to work for values less than 10^6, and 10^6 on its own, but when I run it over the whole sequence...
01:15:44 <Saizan> greap: f in numeric has a "strictness bug"
01:15:54 <int-e> greap: what I saw was this: http://int-e.home.tlink.de/tmp/narrow-hpaste.png
01:16:03 <Saizan> greap: you're using acc as an accumulator, but you are not strict in it
01:16:03 * int-e wonders whether to blame hpaste or the browser.
01:16:39 <Saizan> int-e: not sure, it works fine on firefox 3.5 though
01:17:02 <greap> Saizan: Could you explain a little?
01:17:13 <Cale> greap: by the way, there are tab characters in that source. You should avoid allowing tab characters into your Haskell source files. Most editors have a setting for converting them to spaces automatically.
01:17:23 <greap> int-e: Hmm, how strange.
01:18:01 <greap> Cale, yes, I'll change it in my editor. I love tabs though.
01:18:12 <int-e> Saizan: I don't have that problem with other pastes. Hmm.
01:18:17 <Saizan> greap: since in f recursion you never pattern match or otherwise inspect the value of acc it never gets evaluated
01:18:36 <Saizan> greap: until f returns it at the end
01:18:44 <greap> Saizan: right
01:18:55 <Cale> The reason is that Haskell's whitespace sensitivity isn't really indentation sensitivity, but alignment sensitivity: it matters exactly which column things start in.
01:19:17 <Saizan> greap: but by that time acc looks like 1+1+1+1+1+1+1+...+1, all the additions are suspended
01:19:50 <Cale> Also, the compiler will always treat tabs as aligning to the next column which is a multiple of 8.
01:19:53 <Saizan> greap: and since (+) for Int is strict in both argument that can cause a stack overflow, because of the deep nesting
01:20:14 <greap> Cale: Yep, I understand. I've made sure that the code I write works with tabs by always adding a newline before using them, but this clearly won't work for the general case.
01:20:32 <Saizan> where "that" evaluating that suspended computation to a Int value
01:21:04 <greap> Saizan: How would you modify it?
01:21:47 <Saizan> with {-# LANGUAGE BangPatterns #-} you can use f !acc 1 = acc; f !acc n ..
01:22:05 <Saizan> or you can use seq
01:22:17 <Cale> Is the solution using length really so bad?
01:23:16 <greap> Cale, I wasn't sure weather lazyness would actually work to remove in memory representations of the list or not, so I was just being careful.
01:23:30 <Cale> Well, garbage collection will.
01:23:45 <greap> Cale: although, this was mainly becase I thought my program needed the hell optimized out of it because it was running for so long
01:24:01 <Cale> As length traverses the list (causing the list to be constructed as it goes), each cell in the list will become garbage.
01:24:17 <Saizan> you need an algorithmic optimization here
01:24:21 <greap> Cale: That's what I hoped.
01:24:26 <Saizan> you've to memoize f calls
01:24:53 <Saizan> iirc
01:24:57 <Cale> yeah
01:25:22 <greap> Saizan: I was looking at trying that, but became confused by some of the memoization techniques commonly used, so I thought I'd leave them to later.
01:26:21 <int-e> Saizan: Ok, it's the browser - the code uses tabs, and if I replace all tabs by single characters it's indeed 49 characters wide.
01:26:45 <Cale> The memocombinators package is a nice way to do it.
01:27:34 <int-e> Saizan: it's firefox 3.0.13 btw
01:27:42 <Saizan> i wonder how MemoTrie would perform here
01:28:02 <Saizan> int-e: yeah, i had similar symptoms in the past
01:29:49 <brian6> please take a look at a TH data constructor problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8841#a8841
01:31:15 <greap> Saizan: Hmm, even with the bangpatterns, it still seems to have the same problem
01:31:32 <greap> There is definately some serious unwinding happening when it reaches the last result
01:33:05 <Saizan> well, it won't perform well without memoization
01:33:07 <Cale> greap: Well, it will take bloody ages in any case if you don't memoise.
01:33:44 <Saizan> which was the number of this problem, btw?
01:34:26 <Cale> mmm... also, why the concurrency?
01:34:47 <Cale> If you're just trying to parallelise things, you don't need concurrency.
01:37:34 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8842#a8842
01:37:45 <Cale> There's a fast, but not parallel version
01:39:34 <greap> Cale: I was using cincurrency to inspect the progress of the algorithm
01:39:38 <Cale> ah
01:39:47 <greap> which is why I know that it was sticking at 10^6
01:39:59 <greap> rather than just taking ages
01:40:35 <Cale> er...
01:40:52 <Cale> Actually, I think the way you're doing it is broken.
01:41:05 <greap> Cale: Could be :)
01:41:44 <Cale> let me look at it more carefully...
01:41:54 <Cale> Oh, are you printing the intermediate results?
01:42:18 <greap> I'm printing the number that it is trying to calculate the length of the sequence for
01:42:39 <Cale> Ah, yeah, nothing is actually forcing it to compute the length of the sequence there.
01:42:43 <Cale> So it's not doing it.
01:43:12 <Cale> It's just counting to 10^6 in a funny concurrent way, and then starting to do real work once it's finished that, when you try to print the final result.
01:43:38 <Cale> You can use Control.Exception.evaluate to force some evaluation to occur in sequence with other IO actions.
01:43:46 <Cale> :t Control.Exception.evaluate
01:44:05 <Cale> Oh, is lambdabot not here?
01:44:15 <elbar> vacation ;)
01:44:20 <tefaj> http://www.dangermouse.net/esoteric/whenever.html
01:44:33 <greap> Cale: Ah, lazyness strikes again...
01:44:36 <tefaj> I read that webpage some years ago, before I knew of haskell
01:45:08 <etpace_> Things implemented with {--}, are they going to be in the next 'version' of haskell?
01:46:01 <Cale> greap: executing (return foo) doesn't have to do any calculation with foo, it just returns whatever expression you put there, unevaluated.
01:46:17 <Cale> etpace_: ?
01:46:26 <Cale> etpace_: {- this is a comment -}
01:46:51 <etpace_> sorry {-##-},
01:47:02 <etpace_> like bangpatterns and arrows
01:47:21 <Cale> etpace_: Ah, those are compiler pragmas. There is some consensus on which ones we'd like all the implementations to have
01:47:42 <Cale> LANGUAGE pragmas, or something equivalent will probably be part of the standard, I should hope.
01:48:04 <etpace_> What does LANGUAGE do?
01:48:14 <Cale> Switch on language extensions.
01:48:26 <Cale> (like bang patterns and arrows)
01:48:31 <etpace_> aha
01:49:29 <Cale> Bang patterns themselves might make it into the standard... they have some ugly corner cases though.
01:49:50 <Cale> I liked the way that GHC originally translated them... things have gotten more complicated.
01:50:13 <Cale> let !x = ... in ...  will be translated into a case expression, for instance.
01:50:37 <Cale> (or something involving seq)
01:50:46 <Cale> (and not a let)
01:51:39 <etpace_> Who decided the standard? I take it mostly people who are involved with GHC?
01:51:48 <Saizan> ?hoogle (a -> m Bool) -> [a] -> m (Maybe a)
01:51:49 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
01:51:49 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
01:51:49 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
01:51:51 <Cale> You mean Haskell 98?
01:52:18 <Cale> There's a list of who was on the committee...
01:52:35 <etpace_> And Haskell'?
01:52:40 <Cale> Some of them are involved with GHC, notably Simon Peyton Jones
01:52:44 <ksf> there's even a paper about haskells history
01:52:49 <ksf> ...which is a fun read.
01:52:56 <ksf> h' isn't done yet.
01:53:00 <Cale> Haskell' is a different group, but it has some of the people from the previous committee.
01:53:44 <ksf> ...and people from the community messing with the h' trac.
01:53:58 <Cale> I kind of find the Haskell' process boring, and don't really care for standardisation that much. I'd prefer to see people working on interesting new ideas. ;)
01:54:59 <gwern> Cale: dead standaridzation processes give you common lisp
01:55:07 <Cale> eh?
01:55:46 <brian6> anyone have any idea about this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8841  i'm doing runQ [| ... |] >>= print and modifying the code a little, and getting an error.
01:55:59 <Cale> Doesn't common lisp have a huge specification document?
01:56:00 <gwern> decent language, but dying because half the stuff you need for a language is spread over dozens of unofficial libraries
01:56:22 <gwern> Cale: yeah, but most of the spec is about defining 6 equal operators and things like that
01:56:46 <gwern> not about networking and file IO, the stuff we handle with base packages and the platform
01:57:48 <EnglishGent_afk> Cale - common lisp has a fairly large specification : http://www.lispworks.com/documentation/common-lisp.html
01:57:54 <Cale> I think it's sad to pin everything down in the standard, and have people not be able to improve things.
01:58:02 <Cale> EnglishGent: Right.
01:58:02 <EnglishGent> morning folks :)
01:58:09 * EnglishGent stumbles in with coffee :)
01:58:44 <EnglishGent> btw... what's the monomorphism restriction?
01:58:46 <gwern> Cale: my hope is that haskell' will bless the base and HP - 'we're too slow and bureaucratic to handle that stuff ourselves, but we'll endorse as Official their work'
01:58:51 <gwern> @quote monomorphism
01:58:52 <lambdabot> koeien says: Let's register it [monomorphismrestriction.com] to prevent it from being used ;)
01:58:55 * EnglishGent got a wierd error from GHC about it last night
01:59:06 <jethr0> @paste
01:59:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:59:42 <gwern> @quote Karaoke
01:59:43 <lambdabot> JohnMeacham says: There will also be a karaoke competition to determine the fate of the monomorphism restriction.
01:59:51 <Cale> EnglishGent: Unless you switch the thing off (as I usually end up doing), it says that pattern bindings that don't have explicit type signatures can't be typeclass polymorphic.
02:00:00 <jethr0> hi, i am trying to get hssdl running under mingw...
02:00:08 <jethr0> having some problems though... ;(
02:00:13 <jethr0> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8843#a8843
02:00:31 <Cale> EnglishGent: Pattern bindings are things like foo = ... or (x:xs) = ... rather than things which explicitly take parameters on the left hand side of the = sign.
02:00:35 <EnglishGent> is there a reason for it? becuase it stopped me doing 'assoc = lookup' - though it allows 'assoc x y = lookup x y'
02:00:42 <Cale> Right.
02:00:51 <Cale> This is why it's a stupid rule.
02:00:55 <EnglishGent> which seems distinctlu odd to me
02:01:03 * EnglishGent is still very much a Haskell newbie
02:01:05 <EnglishGent> :)
02:01:07 <Cale> and it's why everyone turns it off using {-# LANGUAGE NoMonomorphismRestriction #-}
02:01:34 <Cale> (there ought to be a short form for that...)
02:01:50 <Cale> At least that's a reasonably mild case of it biting you.
02:01:58 <Cale> It can do much more subtle things too.
02:02:03 <tefaj> {-# Sane #-}
02:02:16 <jethr0> supposedly the order of library bindings is important. does anyone know how cabal determines the order of "-lSDL -lming32" or similar? it is not in config.mk
02:02:28 <EnglishGent> also - is there a sensible reason why overlapping instances are banned? I dont get why they are a problem either (I turn them off)
02:02:56 <EnglishGent> as long as theirs a unique most specific choice for every possible input - why is there a problem?
02:03:07 <Saizan> EnglishGent: the rationale is that when you write let x = <expensive computation> in (x,x) you expect <expensive computation> to be run only once, but if 'x' is typeclass polymorphic it'll probably get evaluated twice
02:03:21 <Cale> EnglishGent: Anyway, the rationale for it is that typically things which look like pattern bindings we expect to be computed once and never again. But if there are typeclasses involved, those things which look like definitions of constants are really definitions of functions.
02:03:28 <Cale> hehe
02:03:50 <Saizan> EnglishGent: OverlappingInstances allow different instances to be picked for the same type in different modules
02:04:38 <Saizan> heh, there's a big echo today :)
02:05:23 <ksf> then there are people who use {-# LANGUAGE ThereIsAProofButTheMarginIsToNarrowToContainItDisableTypechecker #-}, like Oleg, for example.
02:06:21 <ksf> jethr0, that's linker-dependent.
02:06:21 <Saizan> EnglishGent: even when you don't explicitly avoid importing them with the module system
02:06:47 <Cale> Oleg doesn't even need to disable the typechecker. He's clever enough to find a way to do anything in Haskell 98. ;)
02:06:56 <jethr0> hmm, somehow the cabal seems broken. it puts "/Users/hercules" in my config.mk, even though there's definitely no such thing on my computer...
02:07:43 <Saizan> jethr0: is it a package with a configure script?
02:08:04 <jethr0> yes, this is AFTER configure
02:08:10 * Cale patiently awaits the mailing list post where Oleg announces that Haskell 98 was really a dependently typed language and we were all just too thick to see it.
02:08:27 <jethr0> yes, I've used "runghc Setup.hs configure" because the configure somehow didn't work. let me look into that
02:08:42 <Saizan> jethr0: which package is it?
02:08:52 <jethr0> hssdl
02:09:53 <etpace_> Can anybody explain what | means in typeclass declerations?
02:10:35 <Cale> etpace_: It introduces a functional dependency
02:11:14 <ksf> and fundeps are evil, as I just discovered, for they mislead you to UndecidableInstances.
02:11:23 <Cale> etpace_: If you have something like  class C a b | a -> b  it means that the type b is uniquely determined by the type a
02:11:51 <Cale> So for any given type a, there will be at most one instance C a b
02:12:15 <ksf> ...whereas the same thing, expressed in type families, happily typechecks in guaranteed finite time.
02:12:22 <etpace_> hmm..
02:12:30 <jethr0> Saizan: never mind, it's just an error message telling me the name of the original source of a .a file.
02:12:32 <Cale> This information is used by type inference
02:12:56 <jethr0> i get this error "multiple definitions of main", "undefined reference to SDL_main"
02:13:22 <dmwit> Are you using --make?
02:13:35 <jethr0> it is while building General_hsc_make.exe
02:13:36 <Cale> So for example, if applying something of type  (C a b) => a -> b  to a value of type t, then the result type will be determined by looking at what type b corresponds when a = t
02:13:42 <jethr0> i'm using "runghc Setup.hs build"
02:13:50 <dmwit> Oh, okay, you're using cabal.
02:14:03 <dmwit> Have you got the SDL libraries installed...?
02:14:32 <etpace_> ok, that makes sense
02:14:46 <etpace_> thanks
02:14:47 <ksf> http://mokehehe.blogspot.com/2009/04/hssdl-cant-work-on-ghc-6102.html
02:15:53 <ksf> ...dunno why he's filing a bug report to his own blog, though.
02:17:23 <ksf> that main-defined but winmain-not looks like the target is misdetected.
02:18:47 <jethr0> dmwit: yes
02:19:02 <jethr0> configure is working, it's just the linking that giving me trouble
02:19:04 <jethr0> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8843#a8843
02:20:02 <Saizan> have you tried the SDL package on hackage?
02:21:20 <jethr0> this is the SDL package on haskell
02:21:45 <jethr0> i did "cabal install SDL" and since it wasn't working automatically i am finagling with the packages cabal
02:22:27 <Saizan> i guess it needs an expert of SDL on windows to fix it
02:30:48 <etpace_> :t mapAccumL
02:30:49 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:31:50 <jethr0> hmm
02:33:07 <etpace_> > mapAccumL (\acc x -> (acc*2, x*acc)) 1 [1..10]
02:33:09 <lambdabot>   (1024,[1,4,12,32,80,192,448,1024,2304,5120])
02:33:20 <etpace_> hmm.
02:34:13 <harblcat> :q
02:34:29 <etpace_> hmm, I thought that would build a list of 2^1 to 2^10, what's it doing instead?
02:34:34 <dmwit> > zipWith (*) (map (2^) [1..]) [1..10]
02:34:36 <lambdabot>   [2,8,24,64,160,384,896,2048,4608,10240]
02:34:42 <dmwit> > zipWith (*) (map (2^) [0..]) [1..10]
02:34:43 <lambdabot>   [1,4,12,32,80,192,448,1024,2304,5120]
02:34:56 <dmwit> etpace_: Now do you know what it's doing?
02:35:03 <Deewiant> > mapAccumL (\acc x -> (acc*2, x*acc)) 1 [1..10] :: (Expr, [Expr])
02:35:05 <lambdabot>   (1 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2,[1 * 1,2 * (1 * 2),3 * (1 * 2 * ...
02:45:42 <etpace_> > mapAccumL (\acc x -> (acc*2, x*acc)) 1 (replicate 10 [1])
02:45:44 <lambdabot>   No instance for (GHC.Num.Num [t])
02:45:44 <lambdabot>    arising from the literal `2' at <inter...
02:45:53 <etpace_> :t replicate
02:45:54 <lambdabot> forall a. Int -> a -> [a]
02:46:02 <etpace_> > mapAccumL (\acc x -> (acc*2, x*acc)) 1 (replicate 10 1)
02:46:03 <lambdabot>   (1024,[1,2,4,8,16,32,64,128,256,512])
02:46:31 <etpace_> ah so mapAccumL works how I thought it would, I just got my logic incorrect
02:46:31 <Phyx-> etpace_: do you sleep? :P
02:46:43 <etpace_> sure
02:46:57 <Phyx-> lol, you must be in the same timezone as me then
02:47:09 <etpace_> gmt
02:47:31 <Phyx-> i'm UTC+1
02:48:24 <etpace_> summer holidays in the middle of nowhere leaves a lot of time for haskelling!
02:49:30 <Phyx-> lol
02:49:37 <EnglishGent> @hoogle [a] -> (a -> IO b) -> IO [b]
02:49:38 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
02:49:38 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:49:38 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:49:43 <Phyx-> i didn't haskell all that much in the holidays
02:50:04 <EnglishGent> what's the difference between those 3?
02:50:07 <Phyx-> too much partying, in fact, i'm willing to wager i forgot some haskell :|
02:50:29 <Phyx-> EnglishGent: forM is flip mapM
02:50:33 <pr> EnglishGent: forM = flip mapM
02:50:36 <pr> @type flip mapM
02:50:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
02:50:44 <EnglishGent> ah - ty :)
02:50:55 <Phyx-> other than that, the mapM're the same, just one is in the prelude for convenience
02:51:09 <Phyx-> @src forM
02:51:09 <lambdabot> forM = flip mapM
02:51:10 <Phyx-> :)
02:52:46 <EnglishGent> hello augustss :)
03:13:18 <pr> > (maxBound :: Int) + 1
03:13:19 <lambdabot>   -9223372036854775808
03:13:55 <pr> > (maxBound :: Int) * 2
03:13:56 <lambdabot>   -2
03:14:17 <dmwit> > minBound :: Int == maxBound + 1
03:14:18 <lambdabot>   Could not deduce (GHC.Enum.Bounded
03:14:18 <lambdabot>                      ((+) ((==) GHC.Type...
03:14:34 <dmwit> um
03:14:36 <dmwit> > minBound :: Int
03:14:38 <lambdabot>   -9223372036854775808
03:14:51 <dmwit> > minBound :: Int == (maxBound + 1)
03:14:52 <lambdabot>   Could not deduce (GHC.Enum.Bounded
03:14:52 <lambdabot>                      ((==) GHC.Types.Int...
03:15:42 <dmwit> > (minBound :: Int) == maxBound + !
03:15:43 <lambdabot>   <no location info>: parse error on input `!'
03:15:50 <pr> heh
03:16:06 <dmwit> I give up. =P
03:16:09 <pr> > (minBound :: Int) == maxBound + 1
03:16:10 <lambdabot>   True
03:16:34 <dmwit> Anyway, yeah, I really don't understand the error message.
03:17:20 <dmwit> oh
03:17:26 <dmwit> :k (==) -- ?
03:17:27 <lambdabot> Not in scope: type variable `=='
03:18:13 <dmwit> Yeah, that's definitely it.
03:18:32 <dmwit> > minBound :: eq Int (plus maxBound one)
03:18:34 <lambdabot>   Could not deduce (GHC.Enum.Bounded
03:18:34 <lambdabot>                      (eq GHC.Types.Int (...
03:18:49 <dmwit> Odd that 1 could be a type, though.
03:18:53 <dmwit> :t undefined :: 1
03:18:54 <lambdabot> Unit
03:18:59 <dmwit> O_o
03:19:11 <dmwit> > minBound :: 1
03:19:12 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Generics.Unit)
03:19:12 <lambdabot>    arising from a use ...
03:20:11 <dmwit> > Unit :: 1
03:20:12 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
03:20:12 <lambdabot>    arising from a use of ...
03:20:13 <pr> what the hell is that
03:20:18 <dmwit> haha
03:20:23 <dmwit> pr: What the hell is what?
03:20:31 <pr> :t undefined :: 1
03:20:32 <lambdabot> Unit
03:20:33 <pr> that.
03:20:39 <dmwit> It's a type!
03:20:46 <dmwit> type 1 = Unit
03:20:49 <pr> i see
03:20:49 <dmwit> data Unit = Unit
03:21:00 <pr> worth noting for some obfuscated haskell contest
03:21:16 <dmwit> I expect there needs to be some extensions enabled.
03:21:50 <dmwit> (Until about three minutes ago, I didn't even know that such an extension existed.)
03:31:32 <benmachine> Unit seems a bit like () except without any instances
03:31:53 <dmwit> bingo
03:32:56 <dmwit> ?src (\\)
03:32:57 <lambdabot> (\\) = foldl (flip delete)
03:36:34 <Phyx-> huh
03:36:49 <Phyx-> :t delete
03:36:50 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
03:37:01 <Phyx-> oh right
03:37:13 <dmwit> > delete 3 [3,3]
03:37:14 <lambdabot>   [3]
03:37:35 <dmwit> Is there one that deletes all the equal elements?
03:37:38 <dmwit> filter, I guess
03:38:55 <yitz> ouch, yet another function that uses foldl instead of foldl'.
03:39:32 <dmwit> ...in -O2 we trust, amen.
03:39:39 <yitz> sigh
03:39:40 <Phyx-> hahaha
03:40:42 <Saizan> not that foldl' makes a lot of difference with lists
03:40:44 <Lemmih> Does it make sense to use foldl' for (\\)? The accumulator would still be lazy.
03:41:19 <yitz> Lemmih: true, but what good is building up a whole list of thunks?
03:41:26 <MyCatVerbs> Does it make sense to use (\\) on lists at all? Data.Set, please!
03:41:38 * Lemmih is in psychic sync with Saizan.
03:41:41 <EvilTerran> yitz, it'd do that anyway
03:41:43 <dmwit> MyCatVerbs: Bags!
03:42:00 <Lemmih> yitz: You can't really avoid that without making the entire list strict.
03:42:03 <EvilTerran> dmwit, Map a Int!
03:42:15 <dmwit> EvilTerran: Suddenly (\\) isn't defined as nicely!
03:42:17 <yitz> MyCatVerbs: lists are fine - and faster, and simpler - for fairly small numbers of elements.
03:42:19 <EvilTerran> true.
03:43:22 <dmwit> Also, that would add an Ord constraint, which almost certainly isn't a problem.
03:43:22 <dmwit> =P
03:43:52 <yitz> > length $ [1..1000000] \\ [2,4..1000000]
03:43:53 <lambdabot>   * Exception: stack overflow
03:44:25 <yitz> > length $ foldl' (flip delete) [1..1000000] [2,4..1000000]
03:44:27 <lambdabot>   * Exception: stack overflow
03:44:31 <yitz> darn
03:44:48 <yitz> @src delete
03:44:49 <lambdabot> delete = deleteBy (==)
03:44:59 <yitz> @src deleteBy
03:44:59 <lambdabot> deleteBy eq x []        = []
03:45:00 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
03:46:13 <MyCatVerbs> > Data.Set.size $ Data.Set.(\\) (Data.Set.fromAscList [1..1000000]) (Data.Set.fromAscList [2,4..1000000])
03:46:15 <lambdabot>   Not in scope: `Data.Set.size'Not in scope: data constructor `Data.Set'Not i...
03:46:36 <yitz> MyCatVerbs: no parens on \\
03:46:41 <Lemmih> > S.singleton ()
03:46:43 <lambdabot>   fromList [()]
03:46:47 <MyCatVerbs> Oh, oops.
03:47:13 <dmwit> > S.singleton (\x -> ())
03:47:14 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> ())
03:47:14 <lambdabot>    arising from a use of ...
03:47:19 <MyCatVerbs> > S.size $ (S.\\) (S.fromAscList [1..1000000]) (S.fromAscList [2,4..1000000])
03:47:21 <dmwit> > S.singleton (\x -> x :: Int)
03:47:23 <lambdabot>   Overlapping instances for GHC.Show.Show
03:47:23 <lambdabot>                              (GHC.T...
03:47:23 <lambdabot>   500000
03:47:32 <MyCatVerbs> Thanks Lemmih.
03:47:54 <MyCatVerbs> (Uh, that seems like an odd result)
03:48:05 <dmwit> No, it's even.
03:48:35 * Lemmih giggles.
03:48:46 <MyCatVerbs> Okay. Strange. I was expecting the answer 2. :P
03:49:11 <Saizan> > [2,4..1000000]
03:49:12 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
03:49:13 <dmwit> > [2,4..10] -- enumFromThenTo
03:49:14 <lambdabot>   [2,4,6,8,10]
03:49:26 <MyCatVerbs> Oh! Oh, my bad.
03:49:45 <MyCatVerbs> I was thinking 2:[4..1000000] for some reason.
03:49:47 <dmwit> > [2] ++ [4..10] -- probably what you were thinking =)
03:49:48 <lambdabot>   [2,4,5,6,7,8,9,10]
03:49:48 <mmorrow> , time (length dict)
03:49:49 <dmwit> yeah
03:49:51 <lunabot>  (0.118982,479830)
03:50:03 <mmorrow> , [$ty| time |]
03:50:06 <lunabot>  forall a . a -> (Double, a)
03:50:14 <EvilTerran> uhh
03:50:17 <mmorrow> `time' give the time in seconds to seq it
03:50:24 <dmwit> unsafePerformIO, lol
03:50:29 <mmorrow> (uses http://hackage.haskell.org/package/timeit)
03:50:36 <EvilTerran> that's about as referentially nontransparent as they come
03:50:50 <dmwit> , time (cycle "aaaaaa!")
03:50:52 <lunabot>  (0.0,"aaaaaa!aaaaaa!aaaaaa!aaaaaa!aaaaaa!aaaaaa!aaaaaa!aaaaaa!aaaaaa!aaaa...
03:50:57 <dmwit> =)
03:51:01 <mmorrow> whnf
03:51:02 <dmwit> seq is boring on lists
03:51:10 <mmorrow> dmwit: you need to rnf it yourself
03:51:14 <mmorrow> if that's what you want
03:51:14 <dmwit> I know.
03:51:34 <EvilTerran> , time (foldr seq () [1..1000])
03:51:36 <lunabot>  (0.0,())
03:51:45 <dmwit> I've tried to point this out to the xmonad folks (they have bangs on Strings in some of their records), but they seem uninterested.
03:51:49 <mmorrow> , time (foldl' (flip (:))
03:51:50 <lunabot>  luna: parse error (possibly incorrect indentation)
03:52:05 <mmorrow> , time (foldl' (flip (:)) [] [0..100000])
03:52:07 <lunabot>  (1.4998e-2,[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,...
03:52:08 <c_wraith> Hmm.  You're all the same names I'm used to seeing at more reasonable (local) times of day.  This amuses me. :)
03:52:10 <Berengal> Bangs on Strings and Maybes is always such fun
03:52:12 <MyCatVerbs> , fst . time . rnf $ [1..1000000]
03:52:15 <lunabot>  5.4992e-2
03:52:16 <mmorrow> , time (length (foldl' (flip (:)) [] [0..100000000]))
03:52:21 <lunabot>  Killed.
03:52:21 <Lemmih> dmwit: Reason doesn't matter much to the -O11 people.
03:52:23 <mmorrow> , time (length (foldl' (flip (:)) [] [0..1000000]))
03:52:25 <lunabot>  (0.183972,1000001)
03:52:28 <mmorrow> , time (length (foldl (flip (:)) [] [0..1000000]))
03:52:30 <dmwit> Their argument: all the other entries in the record have a bang, and it almost certainly doesn't hurt to put a bang, so who cares?
03:52:30 <lunabot>  (0.556916,1000001)
03:52:40 <mmorrow> foldl' ftw
03:52:47 <dmwit> Lemmih: Nah, they see reason, it's just a style thing, I think.
03:52:50 <yitz> c_wraith: *yawn* what are trying to imply?
03:53:06 <MyCatVerbs> c_wraith: It's only midday here. :)
03:53:22 <c_wraith> I think I'm implying I'm in the wrong time zone :)
03:53:37 <c_wraith> (about to reach 4 am here)
03:53:39 <yitz> @localtime c_wraith
03:53:40 <lambdabot> Local time for c_wraith is Sun Aug 30 03:53:39
03:53:45 <yitz> oh my
03:53:54 <dmwit> c_wraith: I get to see people from all the usual timezones, as an artifact of my wonky sleep schedule. =)
03:53:56 <pr> @localtime pr
03:53:59 <lambdabot> Local time for pr is Sun Aug 30 12:53:56 2009
03:54:09 <dmwit> ?localtime
03:54:13 <lambdabot> Local time for dmwit is Sun Aug 30 06:54:09 2009
03:54:35 <pr> good morning dmwit
03:54:52 <dmwit> Nearly evening on my schedule! =)
03:55:01 <dmwit> Good morning.
03:55:01 <Lemmih> dmwit: I still think it's partly because of their superstition. Like, throwing salt over your shoulder doesn't hurt so why not do it.
03:55:20 <dmwit> heh
03:55:24 <pr> oh, so you're more of like an late setter than some early riser
03:55:26 <pr> ;)
03:55:33 <dmwit> yep =)
03:55:36 <mmorrow> Lemmih: unless you throw it on some dood named SeaBass
03:56:09 <dmwit> And then it's DELICIOUS.
03:56:49 <yitz> Lemmih: foldl.delete only makes sense for a left-biases \\. In that case, it should be defined with a super-strict delete. I'll bet even -O2 doesn't help here. (sorry dmwit)
03:56:55 <yitz> biased
03:56:56 <Saizan> the bangs are there to catch when an user forgets to fill a field early
03:57:42 <mmorrow> if you're putting a reversed list in there however, the data dependency of the head on the rest causes the entire spine to be forced
03:57:52 <mmorrow> , time (length (foldl (flip (:)) [] [0..1000000]))
03:57:55 <lunabot>  (0.573912,1000001)
03:57:55 <mmorrow> , time (length (foldl' (flip (:)) [] [0..1000000]))
03:57:57 <lunabot>  (0.178972,1000001)
03:58:46 <Ferdirand> ~.
03:58:54 <Ferdirand> oops
03:59:50 <yitz> ops - please close Ferdirand's telnet session
04:00:56 <mmorrow> hmmm, actually that's not true i guess
04:01:08 <Lemmih> yitz: A strict delete would be very inefficient.
04:01:14 <mmorrow> the data dep causes the list to be traversed entirely immediately
04:01:48 <mmorrow> oh right, so whether the spine is forced would depend on how reverse is implem
04:01:54 <mmorrow> with foldl or foldl'
04:02:05 <yitz> Lemmih: true. any foldl.delete will be very inefficient though - unless we are assuming that the left list is very short. And in that case, strict delete is what we need.
04:04:03 <yitz> Lemmih: ah. so you'll claim that the current definition is for when the right list is very short *and* the element to delete is always near the beginning of the left list?
04:04:05 <Saizan> i think a totally different and lazier algorithm makes more sense
04:04:28 <yitz> Saizan: iow, a right-biased one?
04:04:39 <Lemmih> I agree with Saizan.
04:05:15 <mmorrow> hmm, i think whether you want lazy or strict' depends on whether the structure's strict in its structure
04:05:26 <mmorrow> like with Data.(Int)Map, you want foldl'
04:05:48 <yitz> a lazier algorithm would be good for right biases. a stricter one would be good for left biased. the current one is not good for much of anything.
04:06:19 <mmorrow> but lists you have the option of accumulating all the deletes and then walking them down the list one elem at a time
04:07:42 <mmorrow> hrm, i dunno
04:08:19 <Lemmih> yitz: I'm not sure you're allowed to be that strict.
04:08:22 <yitz> right bias doesn't seem all that useful either. how often do you need to delete a huge list from a tiny one? happens, but seems that left-bias makes the most sense here.
04:08:34 <yitz> so i think it should be stricter
04:08:55 <yitz> Lemmih: i do get a bit authoritarian sometimes
04:09:07 <Lemmih> > head ([1,undefined] \\ [2])
04:09:08 <lambdabot>   1
04:09:35 <Lemmih> > head ((1:undefined) \\ [2])
04:09:36 <lambdabot>   1
04:10:18 <yitz> yeah, true. but that property has the side-effect of making the function almost useless.
04:10:30 <Lemmih> How so?
04:10:31 <dmwit> I would like to point out that anyone interested in efficiency in any way will not be using lists for this operation.
04:10:45 <yitz> dmwit: right
04:10:55 <yitz> dmwit: well, not completely
04:11:06 <Lemmih> yitz: Why can't a lazy version be efficient?
04:11:08 <yaxu1> anyone got code completion working in ghci within emacs (Inf-Haskell)?
04:11:10 <yitz> dmwit: if you know the lists will all be reasonably short, it's efficient.
04:11:17 <yitz> in which case Lemmih is right.
04:13:37 <mmorrow> , time (length $ foldl' (flip delete) (take 10000000 (cycle ['\0'..'\255'])) (take 100000 . cycle . reverse $ ['\0'..'\255']))
04:13:40 <lunabot>  (0.582912,9900000)
04:13:42 <mmorrow> , time (length $ foldl (flip delete) (take 10000000 (cycle ['\0'..'\255'])) (take 100000 . cycle . reverse $ ['\0'..'\255']))
04:13:47 <lunabot>  (3.334493,9900000)
04:13:48 <yitz> Lemmih: not useless because of efficiency. useless because it only works if both lists are very short
04:14:36 <Lemmih> yitz: Why would it only work if both lists are very short? Why how short are we talking about?
04:14:41 <gwern> short lists need love too!
04:14:50 <yitz> short enough not to blow the stack with thunks
04:15:06 <yitz> gwern true
04:15:12 <Lemmih> yitz: A lazy version doesn't have to buildup thunks.
04:15:37 <yitz> Lemmih: what do you have in mind?
04:15:47 <Saizan> > let [] \\ _ = []; xs \\ [] = xs; (x:xs) \\ ys = case findRest ys of Nothing -> x : (xs \\ ys); Just rest -> xs \\ rest; findRest x [] = Nothing; findRest x (y:ys) | x == y = Just ys | otherwise = fmap (y:) (findRest x ys) in length $ [1..1000000] \\ [2,4..1000000]
04:15:48 <lambdabot>   <no location info>: Parse error in pattern
04:15:52 <inaeternum> -----is it possible to compile .hc files by directly calling gcc?
04:16:47 <Lemmih> yitz: Something similar to filter. It would just have to remove elements from the filtering list when it finds a match.
04:16:51 <mmorrow> inaeternum: you'd need to get all the options/flags/includepaths/libpaths/defines/smell/etc correct, but yes
04:17:50 <Lemmih> yitz: del [1,2,3] [2] => 1:del [2,3] [2] => 1:del [3] [] => 1:3:del [] [] => 1:3:[]
04:17:50 <inaeternum> how can i find out with what flags/paths etc ghc would call gcc?
04:18:22 <mmorrow> inaeternum: ghc -v
04:18:34 <yitz> Lemmih: yeah, but how does it work if both lists are very long?
04:18:55 <inaeternum> mmorrow: thx
04:19:03 <mmorrow> inaeternum: no problem
04:19:08 <Lemmih> yitz: Why wouldn't it work on long lists?
04:20:35 <yitz> Lemmih: e.g., in your example, the first "1:" is perhaps a thunk for searching all through the right-hand list. Or is your algo something else?
04:21:24 <Lemmih> yitz: "1:" can't be a thunk. It either returns ':' or '[]'.
04:22:10 <Lemmih> yitz: If '1' is not in the filtering list, '1' is yielded. Otherwise '1' is discarded and 'del' recurses.
04:22:13 <yitz> Lemmih: how can it do that without first comparing "1" to every element of the right-hand list?
04:22:24 <mmorrow> , (\xs gone -> foldr (.) id (fmap(\o->filter(/=o))gone) xs) ['a'..'z'] "qwertyasdf"
04:22:25 <lunabot>  "bcghijklmnopuvxz"
04:22:48 <Lemmih> yitz: Looking through the entire filtering list doesn't blow the stack.
04:22:51 <mmorrow> oops
04:22:55 <mmorrow> oh no
04:23:00 <mmorrow> s/oops//
04:24:30 <mmorrow> , time ((\xs gone -> foldr (.) id (fmap(\o->filter(/=o))(nub gone)) xs) ((take 4000 . cycle) ['a'..'z']) ((take 100000 . cycle) "qwertyasdf"))
04:24:32 <lunabot>  (1.1998e-2,"bcghijklmnopuvxzbcghijklmnopuvxzbcghijklmnopuvxzbcghijklmnopu...
04:24:36 <Lemmih> yitz: It won't be fast but it shouldn't blow the stack. Being strict in the filtering list is completely fine.
04:24:51 <yitz> ah strict in the RHS.
04:24:52 <mmorrow> , time (length ((\xs gone -> foldr (.) id (fmap(\o->filter(/=o))(nub gone)) xs) ((take 4000 . cycle) ['a'..'z']) ((take 100000 . cycle) "qwertyasdf")))
04:24:54 <lunabot>  (1.6996999999999998e-2,2462)
04:25:23 <yitz> mmorrow: now i've lost you
04:25:23 <Lemmih> yitz: There's no way to be non-strict in the RHS.
04:25:54 <yitz> Lemmih: well. ok. that's what i suggested to begin with.
04:26:14 <yitz> i.e. use a super-strict delete
04:26:15 <mmorrow>  \xs todel -> foldr (.) id (fmap (\o->filter(/=o)) (nub todel)) xs
04:26:33 <Lemmih> yitz: That wouldn't be anymore strict that it is now.
04:26:38 <pr>  time (length ((\xs gone -> foldr (.) id (fmap(\o->filter(/=o))(nub gone)) xs) ((take 4000 . cycle) ['a'..'z']) ((take 100000 . cycle)
04:26:41 <pr> mrh
04:26:45 <pr> meh. paste fail.
04:26:53 <Lemmih> > head ([1] \\ [2,undefined])
04:26:55 <lambdabot>   * Exception: Prelude.undefined
04:27:25 <mmorrow> , head $ (\xs todel -> foldr (.) id (fmap (\o->filter(/=o)) (nub todel)) xs) [1] [2,undefined]
04:27:26 <lunabot>  luna: Prelude.undefined
04:27:31 <Lemmih> yitz: You can't be any less or any more strict than it is now.
04:28:03 <pr> , time (length ((\xs gone -> foldr (fmap) id (fmap (\o->filter(/=o))(nub gone)) xs) ((take 4000 `fmap` cycle) ['a'..'z'] ((take 100000 `fmap` cycle) "qwertyasdf")))
04:28:03 <mmorrow> , [2] \\ [1,2]
04:28:04 <lunabot>  luna: parse error (possibly incorrect indentation)
04:28:05 <lunabot>  []
04:28:07 <pr> meh
04:28:56 <mmorrow> , time (length ((\xs gone -> foldr fmap id (fmap(\o->filter(/=o))(nub gone)) xs) ((take 4000 `fmap` cycle) ['a'..'z']) ((take 100000 `fmap` cycle) "qwertyasdf")))
04:28:58 <lunabot>  (1.7998e-2,2462)
04:29:13 <mmorrow> , time (length ((\xs gone -> foldr (.) id (fmap(\o->filter(/=o))(nub gone)) xs) ((take 4000 . cycle) ['a'..'z']) ((take 100000 . cycle) "qwertyasdf")))
04:29:15 <lunabot>  (1.7997e-2,2462)
04:29:26 <pr> of course it's the same :)
04:29:51 <Lemmih> yitz: The current problem is that (x \\ [1,2,3]) turns into (delete 3 (delete 2 (delete 1 x))).
04:29:53 <mmorrow> good thing it resolve fmap to (.) at compile time
04:31:55 <pr> > fmap (.) (.) id (++) "abc" "def"
04:31:57 <lambdabot>   "abcdef"
04:32:27 <mmorrow> > (++) "abc" "def"
04:32:28 <lambdabot>   "abcdef"
04:32:35 <pr> > fmap fmap fmap fmap fmap fmap fmap fmap fmap id id id id id id (++) "abc" "def"
04:32:36 <lambdabot>   "abcdef"
04:32:48 <pr> @pl fmap fmap fmap fmap fmap fmap fmap fmap fmap id id id id id id (++) "abc" "def"
04:32:48 <lambdabot> "abcdef"
04:33:05 <pr> @pl \x y -> fmap fmap fmap fmap fmap fmap fmap fmap fmap id id id id id id (++) x y
04:33:05 <lambdabot> (++)
04:33:07 <mmorrow> , $(fmaps 17) (*2) (nesty $(nat 16) (:[]) 42)
04:33:08 <pr> heh
04:33:09 <lunabot>  [[[[[[[[[[[[[[[[[84]]]]]]]]]]]]]]]]]
04:33:45 <mmorrow> , ppDoc <$> fmaps 8
04:33:47 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap))))))
04:33:50 <gwern> fmap them all. the GC will know his own
04:34:39 <gwern> true fact: I have a cat named GC
04:35:12 <gwern> we call him that because we were babysitting him, kept in our garage, and then the babysitting became permanent. so his name became 'Garage Cat', or GC for short
04:35:30 <gwern> WHAT A CRAZY WORLD I LIVE IN
04:35:41 <mmorrow> heh
04:35:42 <mlesniak> I'd be glad if someone experienced with unboxed IO arrays could take a look at this: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3456#a3456
04:38:25 <Lemmih> mlesniak: You could use an IORef to avoid keeping all the intermediary elements in memory.
04:38:51 <dmwit> :t foldM
04:38:52 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:39:01 <Lemmih> mlesniak: Do you really need an IO array?
04:39:21 <Lemmih> Yeah, I guess foldM would do better.
04:39:47 <mlesniak> Lemmih, unfortunately, yes
04:40:06 <int-e> hmm. right, if you want to use a list of indices, use unsafeFreeze on the array and use the pure indexing functions.
04:40:11 <hackagebot> encoding 0.6.2 - A library for various character encodings (HenningGuenther)
04:40:20 <mlesniak> Lemmih, I'm not sure how to to apply foldM here
04:40:37 <dmwit> mlesniak: "bounds" seems to be free in this definition.
04:40:51 <mlesniak> dmwit, corrected it already
04:40:56 <mlesniak> copy&paste error
04:41:16 <Lemmih> mlesniak: With foldM you can compute the maximum while looping through the array instead of afterwards.
04:41:38 <mlesniak> Lemmih, Hmmm, right, would it make such a difference in performance?
04:41:50 <jkff> mlesniak: You would avoid creating the intermediate list
04:41:54 <Lemmih> mlesniak: It would use less memory which means less GC time.
04:42:06 <mlesniak> Lemmih, good point
04:42:06 <int-e> i.e. unsafeFreeze m >>= \m' -> evaluate (maximum [m' ! (0,x,y,3)| x <- [0..w], y <- [0..h]])
04:42:18 <jkff> I think the foldM would compile to code similar to a C loop
04:42:30 <int-e> (use unsafeAt instead of ! to avoid the range checks.)
04:42:32 <Lemmih> I'd be very careful with unsafeFreeze.
04:42:33 <jkff> Whereas the code with lists compiles to horrors
04:43:01 <mlesniak> Lemmih, int-e, jkff Thanks for the hints, I'll try the mentioned approaches!
04:43:05 <int-e> the 'evaluate' should make it safe, unless several threads access the array.
04:43:12 <Berengal> with unsafeFreeze you need to force all computations depending on the frozen array before returning
04:43:37 <int-e> yes, but I'm doing that.
04:43:48 <dmwit> You know, it might even be faster to use mapAccum and ixmap.
04:43:57 <Lemmih> int-e: Computing the indexes manually isn't that easy in this case.
04:44:44 <int-e> Lemmih: right. But you can still save the range checks if you use unsafeIndex as in the paste.
04:44:52 <dmwit> Hmm, I seem to have misplaced mapAccum.  Was I just imagining it?
04:45:25 <int-e> @type Data.Array.Base.unsafeFreeze
04:45:26 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *) (b :: * -> * -> *). (Ix i, Data.Array.Base.MArray a e m, Data.Array.Base.IArray b e) => a i e -> m (b i e)
04:45:31 <dmwit> Oh, accumArray goes the wrong direction, never mind me.
04:45:39 <int-e> (will need a type signature to fix the array type 'b', too.
04:45:46 <int-e> )
04:47:14 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8844#a8844 <- not stack-oveflowing (\\), btw
04:48:29 <EnglishGent> @hoogle Monad m => (x -> m y) -> m [x] -> m [y]
04:48:29 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:48:29 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:48:29 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
04:48:48 * EnglishGent doesnt think mapM is right here - I _cant_ feed IO [a] into something expecting [a] :|
04:48:50 <int-e> Lemmih: actually, how about [3,8..(w+1)*(h+1)*5]?
04:49:02 * EnglishGent has a function FilePath -> IO Foo & another function FilePath -> IO [Filepath] - I want to get back IO [Foo]
04:49:08 <EnglishGent> help? :)
04:49:54 <Berengal> EnglishGent, mapM fp2foo =<< fp2fpList
04:50:11 <int-e> Lemmih: although that's bordering on being too clever for one's own good.
04:50:22 <Lemmih> int-e: Right.
04:50:42 <dmwit> EnglishGent: Do you want it to be recursive?
04:51:04 <dmwit> EnglishGent: i.e. how should the FilePath -> IO [FilePath] function be used?
04:51:14 <Berengal> Ooo, ListT IO
04:51:18 <EnglishGent> yes - I want it to take each of the Filepath in the list & convert it to a Foo - both lists should be of the same length
04:51:46 <EnglishGent> that's just generating the list I want to somehow 'map' FilePath -> IO Foo over to get back a list of Foo
04:51:50 <Lemmih> int-e: Not creating the list of indexes might be just as good. 'unsafeIndex bounds (0,x,y,3)' might compile into something very decent.
04:52:10 <Berengal> @type mapM ?f <=< ?g
04:52:11 <lambdabot> forall a (m :: * -> *) b a1. (?f::a -> m b, Monad m, ?g::a1 -> m [a]) => a1 -> m [b]
04:53:05 <Saizan> EnglishGent: (>>=) is exactly what you need if a function expects 'a' and you have 'Monad m => m a'
04:53:25 <EnglishGent> ty :)
04:53:37 <EnglishGent> thanks all :)
04:53:47 * EnglishGent finds this channel very helpful :D
04:55:01 <Saizan> also, do-notation
04:55:34 <Saizan> do paths <- makePaths path; mapM f paths
05:01:52 <EnglishGent> um.. another complication (sorry) - getDirectoryContents says there's a file '.#play6.hs' -- there is, ls confirms it
05:02:11 <EnglishGent> but getFileStatus ".#play6.hs" gives me an error saying "no such file or directory"
05:02:47 <EnglishGent> it's a symbolic link if that helps
05:02:54 <Lemmih> EnglishGent: getDirectoryContents "." ?
05:03:15 <byorgey> dons: ping
05:03:16 <EnglishGent> yes Lemmih - it's a symbolic link pointing to nowhere btw
05:03:40 <EnglishGent> ah! so do I want getFileStatus? I want the status of the *link* - not it's target
05:04:20 <dmwit> Nope, getFileStatus follows links.
05:04:49 <Lemmih> EnglishGent: You'll probably have to enter POSIX land to get the status of the link.
05:05:00 <dmwit> You want getSymbolicLinkStatus from System.Posix.Files.
05:07:05 <EnglishGent> I dont mind entering Posix land at all Lemmih - I've never liked the unix shell script language - and in a move that my more traditional unixy friends have declared nuts - I've decided to switch to Haskell as my scripting language
05:07:23 * EnglishGent figured the lazy evaluation would be a major plus a'la shell pipelines, etc :)
05:07:28 <yitz> @google haskell shell
05:07:28 <lambdabot> No Result Found.
05:07:36 <JHVH> Are there any haskell shells for linux?
05:07:42 <JHVH> Oh, too slow, looks like not
05:08:00 <dmwit> Yes, there are, it's just that ?google is broken.
05:08:20 <dmwit> hashell, hash, hsh, I think, at least
05:10:15 * Heffalump has used HSH and found it somewhat usable
05:10:43 <yitz> haskall
05:13:27 <EnglishGent> thanks :)
05:18:20 <augustss> howdy!
05:18:47 <EnglishGent> hi augustss :)
05:19:00 <EnglishGent> @hoogle (x -> y) -> (x -> IO z) -> (x -> IO (z,y))
05:19:00 <lambdabot> No results found
05:19:15 <augustss> EnglishGent: are we in the same room?
05:19:31 <EnglishGent> um - #Haskell I think :)
05:19:52 <augustss> I was thinking of hac7 :)
05:20:24 <Heffalump> would a proper English gentleman deign to visit Scotland?
05:20:40 <EnglishGent> I would have no problem with visiting Scotland
05:20:58 <EnglishGent> you may draw whatever conclusions about my claims to my title that you wish :)
05:28:41 <etpace_> :t (&&&)
05:28:42 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:29:53 <etpace_> :t (>>>)
05:29:54 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
05:31:18 <etpace_> > uncurry (/) $ (10. 2)
05:31:20 <lambdabot>   Couldn't match expected type `(a, a)'
05:31:34 <etpace_> > uncurry (/) $ (10, 2)
05:31:35 <lambdabot>   5.0
05:38:00 <dmwit> etpace_: Playing with Circuits?
05:39:14 <etpace_> sure am
05:39:32 <etpace_> the mean function is really quite cool
05:47:48 <etpace_> @hoogle (Arrow a) => (a b c) -> (a b c') -> (a b c'') -> a b (c, c', c'')
05:47:48 <lambdabot> No results found
05:50:38 <pr> @djinn (b -> c) -> (b -> d) -> (b -> e) -> b -> (c, d, e)
05:50:39 <lambdabot> f a b c d = (a d, b d, c d)
05:54:30 <hackagebot> formlets 0.6.1 - Formlets implemented in Haskell (ChrisEidhof)
05:54:36 * Phyx- feels like his brain is gonna fold
05:54:42 <Phyx-> using an r and not an l
06:00:28 <Twey> The Japanese must have a hard time with Haskell folds.
06:02:35 <purplepenguins> why would that be
06:03:02 <tefaj> Not if they stick to commutative operations.
06:04:05 <gwern> Twey: :) they can't *pronounce* rs and ls, I think they can read'em. visually distinct
06:04:25 <mauke> they regularly confuse r and l when writing english
06:04:49 <mauke> (eric crapton, anyone?)
06:04:51 <gwern> hm, they do?
06:06:14 <Twey> Some do, aye.
06:07:59 <tefaj> I bet they can fold well on paper, though.
06:08:36 <mauke> origarchy
06:11:07 <medfly> hehehe
06:12:07 <Twey> Hehe
06:23:36 <etpace_> > (\() -> 1) 5
06:23:37 <lambdabot>   No instance for (GHC.Num.Num ())
06:23:37 <lambdabot>    arising from the literal `5' at <intera...
06:23:49 <etpace_> What does \() mean?
06:23:55 <Axman6> > (\~() -> 1) 5
06:23:57 <lambdabot>   <no location info>: parse error on input `->'
06:24:02 <Axman6> :(
06:24:10 <Axman6> > (\(~()) -> 1) 5
06:24:12 <lambdabot>   No instance for (GHC.Num.Num ())
06:24:12 <lambdabot>    arising from the literal `5' at <intera...
06:24:37 <etpace_> This example uses it, my intuitive thought is for pattern matching, but why not use _?
06:25:21 <Shaikepedia> l;l
06:25:24 <Shaikepedia> l;l;ll
06:25:28 <Shaikepedia> 05dc05da05dc05da
06:26:33 <Axman6> mew
06:26:43 <Axman6>    ^^^^ kitteh attakeh
06:27:53 <Guest10792> フオルデル -- foldl
06:28:00 <Guest10792> フオルダル -- foldlr
06:28:05 <endojelly> etpace_, you can only pass () to it
06:28:59 <endojelly> the pattern () infers to the type () and () is the only expression of type ()
06:29:14 <tefaj> What is foldlr?
06:29:27 <endojelly> > (\() -> 1) ()
06:29:28 <lambdabot>   1
06:29:37 <endojelly> it's really pretty useless in that way 8)
06:29:45 <medfly> what is with this channel and Japanese?
06:29:52 <endojelly> with a strict language you could use it to defer computation
06:29:57 <Alpounet> Hi.
06:30:08 <etpace_> hmm ok
06:30:25 <endojelly> but with a non-strict language you don't need to do that.
06:30:26 <etpace_> thanks
06:30:32 <endojelly> np
06:32:55 <endojelly> or does anyone know any clever use of \() -> in haskell?
06:34:15 <endojelly> well: > let x = \() -> unsafePerformIO $ putStrLn "foo"
06:36:13 <etpace_> well its used for this circuit example
06:36:30 <etpace_> http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
06:38:42 <EnglishGent_afk> @hoogle (Monad t1) => (t -> t1 t2) -> t -> t1 (t, t2)
06:38:43 <lambdabot> No results found
06:39:36 <EnglishGent_afk> @hoogle (Monad t1) => (t -> t1 t2) -> (t -> t3) -> t1 (t, t3)
06:39:36 <lambdabot> No results found
06:39:42 <Phyx-> :t (~>)
06:39:44 <lambdabot> Not in scope: `~>'
06:39:52 <Phyx-> :k (~>)
06:39:54 <lambdabot> Not in scope: type variable `~>'
06:40:16 <Makoryu> tefaj: Did you say foldlr? That's fold + l + r?
06:40:36 <tefaj> A bidirectional fold?
06:40:53 <etpace_> :t foldlr
06:40:54 <lambdabot> Not in scope: `foldlr'
06:41:04 <Makoryu> tefaj: I've never heard of it! No idea.
06:41:07 <Phyx-> :t foldr
06:41:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:42:32 <Phyx-> :t foldr foldl
06:42:33 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b1] -> b
06:42:33 <lambdabot>     Probable cause: `foldl' is applied to too few arguments
06:42:33 <lambdabot>     In the first argument of `foldr', namely `foldl'
06:42:36 <Phyx-> :P
06:43:10 <Phyx-> :t foldr(<$>)
06:43:12 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> [b -> b] -> f b
06:43:51 <Phyx-> :t foldr (<$>) Nothing
06:43:52 <lambdabot> forall b. [b -> b] -> Maybe b
06:44:15 <Phyx-> :t foldr (<$>) Nothing [id,(+1),join (*)]
06:44:17 <lambdabot> forall b. (Num b) => Maybe b
06:44:24 <Phyx-> foldr (<$>) Nothing [id,(+1),join (*)]
06:44:29 <Phyx-> > foldr (<$>) Nothing [id,(+1),join (*)]
06:44:31 <lambdabot>   Nothing
06:44:39 <Phyx-> > foldr (<$>) (Just 5) [id,(+1),join (*)]
06:44:41 <lambdabot>   Just 26
06:45:42 <EnglishGent_afk> @hoogle FileStatus -> x
06:45:43 <lambdabot> Warning: Unknown type FileStatus
06:45:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:45:43 <lambdabot> Prelude id :: a -> a
06:47:57 <Phyx-> @pl foldr (<$>)
06:47:57 <lambdabot> foldr (<$>)
06:48:12 <Phyx-> :t foldr ap
06:48:13 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [m (b -> b)] -> m b
06:48:51 <Phyx-> > foldr (<$>) (Just 5) [Just id,Just (+1),Just $ join (*),Nothing]
06:48:52 <lambdabot>   Couldn't match expected type `b -> b'
06:48:56 <Phyx-> hm?
06:49:05 <Phyx-> > foldr ap (Just 5) [Just id,Just (+1),Just $ join (*),Nothing]
06:49:06 <lambdabot>   Nothing
06:49:13 <Phyx-> > foldr ap (Just 5) [Just id,Just (+1),Just $ join (*)]
06:49:14 <lambdabot>   Just 26
06:49:29 <Phyx-> @srrc ap
06:49:30 <lambdabot> ap = liftM2 id
06:49:35 <Phyx-> @src ap
06:49:35 <lambdabot> ap = liftM2 id
06:49:43 <pr> > foldr (<*>) (pure 5) [Just id, Just (+1), Just $ join (*)]
06:49:44 <lambdabot>   Just 26
06:49:48 <Phyx-> :t return (<$>)
06:49:49 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m ((a -> b) -> f a -> f b)
06:50:08 <Phyx-> @src (<$>)
06:50:09 <lambdabot> f <$> a = fmap f a
06:50:13 <pr> :)
06:50:13 <Phyx-> right
06:50:23 <pr> @type (<*>)
06:50:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:50:28 <Phyx-> @src liftM2
06:50:29 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:50:47 <Phyx-> ah
06:51:33 <pr> (Just f)<*>(Just x) = Just (f x)
06:53:58 <jjh> Could anyone suggest some cool open source projects which use Haskell that I could hack on to improve my Haskell?
06:54:19 <pr> yi, xmonad, ... :
06:54:20 <pr> :)
06:54:23 <Phyx-> look at hackage
06:54:26 <Phyx-> @where hackage
06:54:26 <lambdabot> http://hackage.haskell.org/
06:54:34 <Lemmih> jjh: lhc.
06:56:05 <jjh> thanks
06:57:21 <Axman6> jjh: i hear Xmonad's code is quite well written
06:58:10 <jjh> i'm a mac user though so I don't use X11 very much
06:59:43 <pr> jjh: what about yi?
06:59:55 <pr> works on os x
07:00:00 <jjh> having a look at that at the moment
07:03:28 <endojelly> is yi really useful yet?
07:04:02 <Makoryu> endojelly: I get the impression it's struggling to keep up with some software that's changing around it
07:04:13 <endojelly> mhm
07:04:17 <Lemmih> endojelly: I wrote all of lhc with it.
07:04:24 <endojelly> Lemmih, sounds good
07:04:29 <Lemmih> endojelly: But it /is/ annoying to use at times.
07:04:52 <endojelly> emacs can be, too. so the question is: is it more annoying than emacs? 8)
07:04:57 <Lemmih> endojelly: It's written really naively and it quite slow.
07:05:03 <pr> ?
07:05:11 <pr> Lemmih: it's slow?
07:05:32 <pr> yi has improved very, very much in terms of speed.
07:05:49 <Lemmih> pr: The vty backend is still dog slow.
07:06:07 <pr> Lemmih: would you mean running Cmcq.hs?
07:06:09 <ManateeLazyCat> I wonder how to write: "instance Binary TextView where" ?
07:06:10 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
07:06:16 <ManateeLazyCat> Lemmih: gtk2hs is not slow.
07:06:27 <Lemmih> pr: Cmcq.hs?
07:06:51 <pr> Lemmih: it's a simple benchmark
07:06:58 <pr> located in Yi/Users
07:07:08 <pr> oh, it's broken, heh
07:07:43 <Lemmih> pr: It's slow to use. In pathological cases it can take more than a second to insert a single character.
07:07:47 <endojelly> I guess I'll just try it out, cabal install yi is running now.
07:07:52 <endojelly> is it somewhat intuitive to use?
07:07:54 <pr> Lemmih: that's not true for me.
07:08:01 <pr> Lemmih: which mode are you using?
07:08:04 <hackagebot> fclabels 0.3.0 - First class accessor labels. (SebastiaanVisser)
07:08:15 <pr> endojelly: better fetch the darcs version
07:08:34 <pr> much improvements have been incorporated there
07:08:41 <pr> s/much/many
07:08:43 <Lemmih> pr: Emacs mode. The problem is in Yi.UI.Vty.
07:08:58 <pr> Lemmih: yeah, using emacs mode myself
07:09:47 <MyCatVerbs> LHC?
07:10:17 <pr> Lemmih: yi --type  1.01s user 0.04s system 94% cpu 1.105 total
07:10:18 <Lemmih> pr: I tried to fixed the performance bug at the last hackathon. Gave up because it was slightly too non-trivial.
07:10:33 <Makoryu> MyCatVerbs: http://lhc.seize.it/
07:10:40 <pr> Lemmih: so yi just got much faster the last one or two weeks
07:10:51 <pr> Lemmih: hehe okay, never experienced it
07:11:02 <pr> two weeks ago the benchmark was running at ~3.8 seconds for me
07:11:04 * Lemmih will check if it has been fixed.
07:11:59 <MyCatVerbs> Strange that it isn't in Arch Linux' repos.
07:12:02 <pr> well, pango frontend takes still 3 seconds for me, but that's acceptable
07:13:02 <MyCatVerbs> Lemmih: is that LHC, your packaging of JHC, or Luxurious LHC?
07:14:02 <Lemmih> MyCatVerbs: My fork of JHC has been replaced by the new LHC. All of the old code was retired.
07:14:33 <MyCatVerbs> Oh cool.
07:15:50 <MyCatVerbs> Lemmih: is this meant to eventually replace GHC's backend or something?
07:16:11 <Lemmih> MyCatVerbs: It's an alternative to GHC.
07:16:20 <MyCatVerbs> Ah, cool.
07:19:01 <Makoryu> Oh god
07:20:32 <MyCatVerbs> Makoryu: ?
07:20:55 <defun> anyone notice that liskell.org is down? Where can I get the liskell source?
07:21:10 <Makoryu> Somehow yi linked itself with my old GMP install in /opt/local when it should be linking to /usr/local (from the Haskell Platform)
07:21:34 <MyCatVerbs> defun: probably there's a source tarball on hackage?
07:21:45 <MyCatVerbs> Oh, bad guess, nope.
07:22:07 <MyCatVerbs> darcs get http://code.haskell.org/liskell/ # dah!
07:22:30 <defun> ah, but I can't install darcs (yet).
07:22:39 <MyCatVerbs> http://blog.clemens.endorphin.org/2009/01/liskell-standalone.html <- "Thanks to community.haskell.org for darcs hosting!"
07:22:53 <defun> thanks.
07:23:04 <MyCatVerbs> Can't you? Oh well. I'll just pull a copy now and make you a tarball if you're really stuck.
07:23:14 <defun> Really? THanks!
07:23:31 <defun> How will you transfer it?
07:24:48 <MyCatVerbs> defun: http://www.cs.bris.ac.uk/home/rb6822/liskell-1251642219.tar.gz
07:24:56 <defun> thanks.
07:25:18 <MyCatVerbs> I have a little webspace. :)
07:25:45 <MyCatVerbs> Don't rely on that being up for any length of time, though. No idea how long it'll be before they delete my account there. (I'm surprised they haven't already, come to think of it.)
07:25:48 <Lemmih> pr: Are you a yi developer?
07:25:51 <djahandarie> I imagine comparing two arrays will always need to be O(n)? (not just Haskell, just general compsci)
07:26:05 <MyCatVerbs> djahandarie: yeah, unless you can take a shortcut.
07:26:19 <tefaj> What is an array, what is comparing, and what is O(n)?
07:26:41 <djahandarie> tefaj, huh...?
07:27:00 <djahandarie> I think you got a bit too abstract with me
07:27:02 <djahandarie> -_-
07:27:14 <MyCatVerbs> djahandarie: like if you're sorting, and they're likely to differ within a constant number of elements, then the comparisons will be constant time.
07:27:15 <tefaj> Clueless puppy dog look will not save you
07:28:02 <MyCatVerbs> djahandarie: on the other hand, if you're (for example) taking two arrays of integers and producing a new array of bools, where each bool says whether the greater element was in the left or the right array, then it'd always be O(n).
07:29:00 <MyCatVerbs> In the former case I'm talking about taking two arrays and producing a single Bool. You can stop looking at array elements in that case as soon as you spot a single difference.
07:29:26 <djahandarie> Right, but it would technically still have a worse-case scenerio of O(n)?
07:29:34 <MyCatVerbs> Yup.
07:29:38 <tefaj> I can french kiss IO monads in O(n).
07:30:02 <djahandarie> Okay, thanks
07:30:11 <luis> tefaj: what's french kissing, what are IO monads, and what is O(n)? :)
07:30:25 <MyCatVerbs> tefaj: unsafePerformIO . liftM snog -- O(1) and I you can do it anywhere.
07:30:27 <koala_man> rule 34 on io monads. what a great internet.
07:30:52 <MyCatVerbs> I bet rule 35 is "It probably isn't very good porn, too."
07:30:56 <djahandarie> MyCatVerbs, lmfao
07:31:13 <tefaj> French kissing is relatively safe compared to other forms of IO you can do
07:31:47 <tefaj> Its inefficiency derives from the necessity of constant locking
07:31:53 <MyCatVerbs> Oh wait, 35's already taken by "And if there isn't, someone will soon make some."
07:34:25 <EvilTerran> MyCatVerbs, perhaps "34a: but it's usually terrible" and "35a: but it's usually even worse"?
07:35:42 <MyCatVerbs> EvilTerran: ah, yes, thank you.
07:35:59 <MyCatVerbs> You're right, naturally they would be corollaries.
07:41:36 <nominolo> wow, train wifi is slow
07:55:22 <ray> rule 34 is really more of a lemma, isn't it
07:55:48 <purplepenguins> a lemma for what?
07:56:12 <skorpan> it's a conjecture
07:57:47 <ray> well it's really more in the empirical than mathematical realm sadly
07:57:57 <mauke> http://rule34.paheal.net/post/list
07:58:12 <ray> a constructivist proof of rule 34 would be interesting
07:58:20 <Phyx-> hmmm
07:58:39 <Phyx-> I need to make SrcLoc from GHC.Lexers an instance of Storable, but it's an abstract type.. any ideas?
07:58:58 <purplepenguins> well, you have to have a witness for an arbitrary entity
07:59:27 <Phyx-> hm, how so?
07:59:30 <purplepenguins> as in, given a an object that exists, one can find A, a porn containing a
08:00:19 <Phyx-> heh
08:00:37 <Baughn> purplepenguins: It's unfortunately disprovable
08:00:55 <purplepenguins> yes, you can disprove rule 34 by providing a counterexample
08:01:00 <Baughn> Rule 34 does not apply to the lint on my carpet, or any number of other highly specific objects
08:01:20 <skorpan> i'm not sure it is disprovable
08:01:32 <skorpan> there is a lot of porn to go through to make sure there is no porn of the lint in your carpet
08:01:37 <ray> such a counterexample requires you search the whole universe
08:01:41 <purplepenguins> though, in constructive mathematics, i don't think you can prove that things do not exist
08:01:42 <Baughn> Sure it is. It's a devil's proof, but you just have to scan the entire universe for porn.
08:01:51 <ray> phyx-: is this a different SrcLoc from the String Int Int one i see?
08:01:52 * Phyx- thinks he has a different definition of porn than you lot
08:01:55 <purplepenguins> unless you have a finite space to search
08:02:00 <Baughn> The universe is finite
08:02:10 <Phyx-> ray: it's supposed to be Int Int Int Int
08:02:16 <Baughn> ..assuming you don't count what's outside the horizon
08:02:24 <purplepenguins> heh
08:02:32 <Phyx-> ray: or rather, SrcSpan
08:02:36 <purplepenguins> don't look at the universe behind the curtain
08:02:47 <EvilTerran> Baughn, but porn of something can be smaller than the thing itself
08:02:55 <ray> ah
08:02:55 <EnglishGent_afk> how do I constrain an instance specification? so as to say instance Foo [(a,b)] only where a is a member of Eq? :)
08:03:06 <ray> instance Eq a => ...
08:03:08 <Baughn> EvilTerran: Nevertheless, if you search the entire universe without finding porn of it, you've disproven rule 34.
08:03:21 <EvilTerran> Baughn, ... would a rule 34 of the universe cover all other cases?
08:03:23 <Baughn> There is no instance Porn a.
08:03:28 <ray> rule 35 states that it doesn't have to exist *now*
08:03:28 <purplepenguins> huh
08:03:32 <Baughn> EvilTerran: I don't think so
08:03:34 <EnglishGent> sure there is! instance Porn Playboy
08:03:35 <EnglishGent> :)
08:03:46 <Baughn> That's not the same at all. -_-
08:04:01 <purplepenguins> using curry howard, we could say that x having a porn of it, means that x : Porn a
08:04:03 <EvilTerran> Baughn, i think we're getting in to overanalysis of the semantics of rule 34, here :P
08:04:06 * Phyx- notices that it's weekend... wow...
08:04:10 <Baughn> EnglishGent: instance Eq a => Foo [(a,b)]
08:04:14 <tefaj> Nonconstructive porn? You people are truly weird
08:04:26 <tefaj> But then again, this is haskell
08:04:28 <Phyx-> since when do porn have rules?
08:04:36 <EvilTerran> o hai arsenm
08:04:41 <Baughn> Phyx-: Come on. You can't tell me you don't know about rule34.
08:04:41 <EnglishGent> do you mean 'instance Eq a => instance Foo [(a,b)]' ray? :)
08:04:50 <purplepenguins> using type theory we almost made the discussion relevant to haskell
08:04:51 <Baughn> EnglishGent: No. That's wrong.
08:04:52 <EvilTerran> (that must be an odd line to arrive to)
08:04:54 <mauke> preflex_: remember <tefaj> [in #haskell] Nonconstructive porn? You people are truly weird
08:04:56 <Phyx-> Baughn: actually... i don't
08:05:00 * EnglishGent has no idea what rule 34 is :|
08:05:05 <Baughn> Phyx-: Rule 34: forall a. Porn a
08:05:18 <Phyx-> Baughn: rofl
08:05:36 <EnglishGent> it didnt look right Baughn
08:05:39 <ray> rule 35 clarifies that rule 34 doesn't imply "right now", just "at some arbitrary time"
08:05:46 * EnglishGent isnt sure what is meant though
08:06:06 <ray> <Baughn> EnglishGent: instance Eq a => Foo [(a,b)]
08:06:08 <ray> that
08:06:08 <Baughn> EnglishGent: "instance Eq a => Foo [(a,b)] where ..." is in fact the correct form.
08:06:10 <tefaj> Ah, so rule 35 is an implementation of rule 34.
08:06:17 <EvilTerran> EnglishGent, "Rule 34 of the internet: There is porn of it. No exceptions."
08:06:19 <tefaj> Higher-order rules. Who knew.
08:06:36 <Phyx-> tefaj: wouldn't you need to implement the Woman type class first?
08:06:37 <ray> well, it just disallows an invalid implicit constraint that is often put on rule 34
08:06:40 <EvilTerran> (for all "it")
08:07:10 <tefaj> Phyx-, woman is primitive.
08:07:27 <EnglishGent> ah - ty ray :)
08:07:31 <Phyx-> tefaj: and probably abstract :P
08:07:38 <Phyx-> as no one seems to see how it works
08:07:50 <tefaj> It does have a consistent interface.
08:08:09 <Phyx-> there's just an interface areYouFeelingLucky:: Command -> Either Mad Response
08:08:19 <ray> so if i assert as a corollary of rule 34 that there is porn of captain jean-luc picard, i'm not necessarily asserting that there is porn RIGHT NOW of captain jean-luc picard
08:08:23 <ray> although it turns out there is
08:08:50 <skorpan> CP?
08:09:00 <Baughn> ..any kind imaginable.
08:09:15 <Baughn> And quite a few I'd never imagined, I'm sure
08:09:23 <purplepenguins> this channel is offtopic most of the time i hang around it
08:09:37 <Phyx-> if you think picard didn't get some on enterprise... you are surely mistaken
08:09:43 <tefaj> Rule 35 is more properly seen as a higher-order function that takes a specialization of the rule 34 type class and lazily instantiates it.
08:10:12 <Baughn> Phyx-: There's also the PPP of the holodeck.. oh dear...
08:10:20 <Phyx-> hahahah
08:10:46 * Phyx- nows sees why the us CIO wants a holodeck...
08:11:47 <purplepenguins> holodecks are high-level shit though
08:12:04 <purplepenguins> though essentially isomorphic with the teleporter
08:12:29 <ray> but as far as we know, not equivalent to the axiom of choice
08:13:07 <Baughn> Which is good, since the axiom of choice is false in this universe
08:13:18 <Baughn> ..probably...
08:13:35 <tefaj> I choose it to be true
08:14:40 <purplepenguins> i choose to not have to choose
08:14:51 <purplepenguins> arbitrarily many times
08:14:58 <EvilTerran> Baughn, given that (IIRC) it's only useful when dealing with uncountable sets, it may be a moot point in this universe
08:15:24 <purplepenguins> but if we don't have AoC we don't have Zorn's lemma
08:15:31 <Baughn> EvilTerran: If we don't have uncountable sets, then it's not so much "false" as "incoherent", I suppose
08:15:31 <purplepenguins> and i liked that lemma
08:15:53 <Baughn> purplepenguins: You can still use it, so long as you recall that any system implementing it doesn't correspond exactly to reality. :P
08:15:53 <EvilTerran> Baughn, yeah, that's my take on the matter
08:15:59 <purplepenguins> yes well
08:16:04 <purplepenguins> i'm a constructivist
08:16:23 <purplepenguins> the law of the excluded middle is too optimistic
08:16:38 <ray> a pro-choice constructivist? =o
08:16:39 <Baughn> Hm. I'm an axiomist? :P
08:16:45 * Baughn has no idea what the correct name is
08:16:52 <purplepenguins> i'm a nihilist constructivist
08:16:52 <Phyx-> anyway, i'm going out to dinner, have a good day everyone!
08:16:56 <Baughn> The law of the excluded middle is just another axiom, though
08:17:10 <ray> is that a constructivist who can't construct anythinhg?
08:17:14 <Baughn> You can choose to assume that it's false, in which case you get a different mathematical system
08:17:28 <Baughn> ..but it seems to be true in the laws of physics
08:17:39 <Baughn> (Which matters not a whit for mathematics, granted)
08:18:50 * EvilTerran doesn't believe in uncountable sets. it makes so many things simpler. :P
08:18:55 <purplepenguins> a nihilist constructivist thinks everything is meaningless, and the only meaning is the things we construct from first principles
08:18:57 <eu-prleu-peupeu> hellooo
08:19:05 <Baughn> Phyx-: Oh, there we go.
08:19:08 <Baughn> I'm a formalist.
08:19:33 <purplepenguins> there is way too many schools of mathematical thought
08:19:45 <purplepenguins> god forbid we sound like philosophers
08:19:50 <Baughn> There are. Why can't you all just accept the obvious truth of formalism? :3
08:20:10 <EvilTerran> purplepenguins, i can see how that could work. if I can prove Q assuming only P, then I'm willing to accept that "P => Q" is big-T-true.
08:20:39 <Baughn> EvilTerran: You can't do that
08:20:40 <purplepenguins> i was entirely jesting being a constructivist
08:20:43 <EvilTerran> modulo Wittgenstein poking holes in my notation
08:20:47 <ray> yeah, why can't you all just accept the obvious truth/non-truth of dialethism
08:20:48 <purplepenguins> i'm total noncommittal about it
08:20:58 <purplepenguins> i do like Zorn's lemma though
08:21:01 <Baughn> EvilTerran: You have to assume at least that modus ponens is true for that to work
08:21:04 <Baughn> EvilTerran: ..which is another axiom.
08:21:24 <ray> isn't that backwards modus ponens?
08:21:29 <purplepenguins> modus tollens?
08:21:52 <maxote> many mathematicians used the intuitionistic logic instead of the classical logic.
08:22:03 <EvilTerran> it's "(P |- Q) |- (P => Q)", rather than "P, (P => Q) |- Q"
08:22:39 <EvilTerran> Baughn, when i said "assuming only P", i'm including the axioms of my logic in there
08:22:45 <purplepenguins> some mathematicians don't care much what logic system they use...
08:22:47 <EvilTerran> Baughn, otherwise i'd be assuming things other than P
08:22:58 <purplepenguins> naive set theories good enough for me
08:23:10 <Baughn> EvilTerran: I see. I hold that that is misleading, then; you're assuming P /and the axioms of logic/.
08:23:14 <EvilTerran> but maybe i should've said "P |- Q" rather than "P => Q" in my original statement. details, details.
08:23:56 <maxote> e.g. ZF uses intuitionistic logic
08:23:59 <Baughn> EvilTerran: It may seem to you that considering the axioms of logic to be false would be an additional assumption on top of P, but that's a consequence of your brainware; you're hardcoded to assume they're true
08:24:00 <maxote> ZFC too
08:24:48 <EvilTerran> Baughn, would "if I can prove Q from only P in logic L, then i'll accept "L |- (P => Q)" as big-T-true" be any better?
08:25:01 <EvilTerran> Baughn, i fear we may be bordering on turtles all the way down, here
08:25:03 <Baughn> EvilTerran: It would certainly be more accurate. :P
08:25:33 <ray> i think you're safe from turtles until you've hit meta-meta-metalogic
08:25:43 <ray> that's when i'd start wondering
08:25:54 <Baughn> I don't see there being any big tower of turtles. You're assuming (a) a statement about P, and (b) a set of rules to manipulate such statements, namely L: this allows you to (c) construct Q from P.
08:26:04 <Baughn> ..that's formalism, yep. Nice to have a name for it.
08:26:10 <maxote> each somebody uses its own logic, i've my own logic.
08:26:16 <purplepenguins> i tried to learn about ordinals once
08:26:19 <purplepenguins> it broke my brain a bit
08:26:21 <ray> deterministic string manipulation
08:26:22 <purplepenguins> i should try again
08:26:48 <maxote>  /logic/logic inference bioengine/
08:27:31 <ray> so if your logic has modus ponens, that just means you can get a string of the form Q from a string of the form P and a string of the form P => Q
08:27:41 <EvilTerran> Baughn, ah, okay. i'll have to remember to include "formalist" in my list of adjectives the next time someone asks me what my philosophical standpoint is :)
08:27:57 <maxote> each somebody pick its own axiomatic base, i've my own axiomatic base.
08:27:59 <ray> if i had to choose, i'd say i like that
08:28:12 <ray> but, i'm too incompetent to commit to some position like that
08:28:16 <Baughn> ray: That's formalism. ;)
08:28:29 * ManateeLazyCat pasted "file permissions" at http://paste2.org/get/406717
08:28:32 <ManateeLazyCat> Above is constant for file permissions, what's 2049 ?
08:28:37 <Baughn> ray: There's a very good introduction to it in Goedel, Escher, Bach
08:28:39 <ray> for all i know, there could be some really compelling argument against formalism that i've never seen
08:28:48 <Baughn> I've never seen one
08:28:56 <maxote> there are many known axiomatic bases in internet (see wikipedia).
08:29:04 <EvilTerran> ManateeLazyCat, er, PermSUID + PermOtherExec
08:29:10 <EvilTerran> whatever that means
08:29:14 <Baughn> ray: The only argument ever given is "but how do you know which formal system to study?", which can be simply answered as "whichever seems useful".
08:29:28 <ray> yeah like ZFC
08:29:47 <ray> i'm kinda pro-choice
08:29:49 <Baughn> ray: Many systems hold that some formalisms are more valid than others. Formalism doesn't. That means you're left with just usefulness, which is easily quantifiable.
08:29:54 <ManateeLazyCat> EvilTerran: I catch 2049 exception when i run gtk2hs program with Gnome.VFS.FileInfo
08:30:11 <ray> choice is equivalent to or implies many useful things
08:30:21 <EvilTerran> ManateeLazyCat, i'm afraid i've never used gtk2hs, so i probably can't help you with that =/
08:30:50 <ManateeLazyCat> EvilTerran: Yep, looks like that. PermSUID + PermOtherExec, but i can't see any type that define in C code.
08:31:27 <ManateeLazyCat> EvilTerran: If have this constant for 2049, i can binding Haskell code with this type to fix this bug.
08:32:32 <sshc> what's the best way to alias putStrNl as putStrLn?
08:32:42 <mauke> putStrNl = putStrLn
08:32:53 <sshc> that seems to cause the type signatures to differ
08:33:09 <mauke> how?
08:33:10 <Jedai> Baughn: and minimalism too, if you just consider usefulness it wouldn't be very interesting
08:33:15 <EvilTerran> mauke, dreaded monomorphism restriction?
08:33:25 <mauke> EvilTerran: putStrLn isn't polymorphic
08:33:26 <int-e> but putStrLn is monomorphic
08:33:32 <maxote> Zermelo-Fraenkel's ZF, ZFC (with Choice Axiom), IZF (Intuitionistic ZF), CZF (Peter Acztel's Constructive ZF), etc
08:33:37 <EvilTerran> ah, true
08:33:38 <Baughn> Jedai: Minimalism follows from the usefulness requirement, IMO
08:33:59 <ray> baughn: well, formalists can say some systems are more interesting or more boring, which is just missing the implication of real-world relevance
08:34:16 <Raevel> @type let p = putStrLn in (putStrLn,p)
08:34:18 <lambdabot> (String -> IO (), String -> IO ())
08:34:18 <maxote> every of them are impredicative
08:34:33 <Baughn> ray: Being more interesting or more boring /is/ a real-world relevance. The mathematicians' brains exist.
08:34:38 <ray> the thing is, interestingness or boringness is a fuzzy subjective thing
08:35:07 <Baughn> Certainly
08:35:23 <EvilTerran> ray, what isn't, though - aside from formally proven statements?
08:35:25 <ray> instead of a universal statement
08:35:42 <maxote> it means that the set of formulas during the computation is initially finite and static.
08:35:46 <Baughn> ray: If you're looking for universal truth, I'm guessing you'll be sorely disappointed by the universe
08:35:47 <ray> however, if you worry about that stuff, you risk becoming a physicist
08:35:58 <ray> and that's a fate worse than death
08:36:25 <maxote> it's, the set doesn't growth during the verification.
08:38:02 <maxote> and i wanted some more dynamic
08:41:00 <Twey> :t let putStrNl = putStrLn in putStrNl
08:41:02 <lambdabot> String -> IO ()
08:41:05 <Twey> WFM.
08:41:21 <Saizan_> WFM?
08:41:47 <skorpan> @google wfm
08:41:48 <lambdabot> http://www.wholefoodsmarket.com/
08:41:49 <lambdabot> Title: Whole Foods Market: Natural and Organic Grocery
08:42:07 <purplepenguins> obviously
08:42:13 <sshc> Twey: you have a good taste of food!
08:42:21 <purplepenguins> actually whole foods is pretty meh
08:42:24 <Twey> Hahaha
08:42:36 <purplepenguins> they're kind of the walmart of organic produce
08:47:42 <osfameron> where are they?
08:48:22 <osfameron> there's a wholefoods in edinburgh (scotland) that used to be quite nice iirc
08:52:23 <purplepenguins> whole foods is better than regular groceries, and a good bit worse than a farmer's market
08:52:39 <jethr0> hello #haskell
08:53:06 <jethr0> are there any ghc windows users around?
08:53:38 <sshc> how do I call '/' if the argument passed is a fractional, or '`div`' if the argument is an integral?  How would I write "divNumber :: (Num a) => a -> a"?
08:53:59 <mauke> sshc: no.
08:54:01 <jethr0> :t fromIntegral
08:54:02 <lambdabot> forall a b. (Integral a, Num b) => a -> b
08:54:07 <jethr0> :t realToFrac
08:54:08 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
08:54:28 <jethr0> sshc: sorry, misunderstood your question
08:54:48 <jethr0> sshc: maybe using a type class...
08:56:01 <jethr0> class Divide where; divNumber :: (Num a) => a -> a -> a; instance Divide Float where divNumber a b = a/b
08:56:48 <jethr0> is there a way to find out (under windows) which libraries ghc actually binds to?
08:57:06 <jethr0> under linux i'd use strace as a rough solution, but under windows/mingw i don't have a clue
08:57:15 <sshc> thanks, jethr0
08:57:24 <jethr0> hope it works
09:02:12 <notsonerdysunny> Hello everybody .. if somebody can tell me what phantom types are and what they are usefull for .. I have tried to understand what they are .. but unable to ..
09:02:49 <Athas> How do I export a data constructor when there is an identically named type?
09:03:06 <mauke> a phantom type is when a parameterized type doesn't use some of its parameters
09:03:17 <mauke> data T a = C
09:03:27 <Athas> I want to export the data constructor in 'data PlainString = String', but not the PlainString type itself.  I currently export 'PlainString(String)', but will that bring the type along too?
09:03:44 <Asztal> jethr0: Dependency Walker will tell you what DLLs an executable image references, but it can't find things that are loaded via LoadLibrary
09:04:26 <jethr0> Asztal: thx. i have this issue with fltk under windows/ming. it complains about missing symbols even though the libraries are all there.
09:05:09 <jethr0> either it's loading the wrong libs or it's a matter of order of library inclusion. any ideas how I could change the order of "-l"ed libraries under "--make"?
09:06:04 <Asztal> oh, I misunderstood you, I think
09:06:24 <notsonerdysunny> mauke .. how is it usefull?
09:06:40 <Asztal> ghc -v5 will tell you what exactly it is doing
09:07:30 <jethr0> Asztal: thx anyway for the dependency walker tip. unfortunately "ghc -v5" does not tell me which library files are actually linked against...
09:08:26 <sshc> if I'm declaring a class by "class (Num a) => Divide a where", what's wrong with the instance declaration of "instance (Fractional a) => Divide a where"?
09:09:23 <zzaz> i wonder if i can compile .hs to .exe without generating the .hi and .o files?
09:09:38 <EvilTerran> sshc, well, it'll overlap all other instances
09:10:10 <sshc> EvilTerran: what do you mean?
09:10:15 <Asztal> jethr0: with just -v, I get this near the end: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3458#a3458
09:10:22 <jethr0> sshc: you kinda changed my example ;)
09:10:39 <EvilTerran> sshc, if you define some other "instance Divide Foo where ...", the compiler won't know which instance to pick
09:11:07 <EvilTerran> sshc, as, even if Foo isn't an instance of Fractional *now*, someone might define an "instance Fractional Foo" later.
09:11:19 <EvilTerran> or in another module, compiled seperately
09:11:40 <sshc> EvilTerran: how do I fix that, then?
09:11:43 <jethr0> Asztal: thx. have you ever linked against DLLs with ghc?
09:11:45 <EvilTerran> sshc, also, that instance will be considered undecidable
09:12:00 <sshc> jethr0: your example didn't compile
09:12:18 <jethr0> i just saw. let me try to figure out an example that actually work ;)
09:12:23 <EvilTerran> as there might be an "instance Divide Foo => Fractional Foo" hiding somewhere else
09:12:24 <sshc> jethr0: and I want it to work with all Integrals and Fractionals
09:12:35 <mauke> sshc: impossible
09:12:41 <Lemmih> Athas: You can't do that.
09:12:53 <zzaz> can i make ghc compile .hs to .exe without leaving behind all the .hi and .o files?
09:13:02 <EvilTerran> sshc, as mauke says, typeclasses don't work that way
09:13:09 <jethr0> sshc: wouldn't it be enough for Double, Float, Int, Integer, etc.?
09:13:13 <Athas> Lemmih: accursed!
09:13:16 <EvilTerran> zzaz, "ghc ... && rm *.hi *.o"
09:13:22 <jethr0> hehe
09:13:57 <sshc> jethr0: ok I guess, but how *would* I declare all Fractionals for the same instance?
09:14:07 <sshc> jethr0: or can I not?
09:14:28 <jethr0> huh? not sure, maybe my idea doesn't work. give me minute to try it out
09:14:51 <sshc> EvilTerran: how would I declare all Integrals as an instance of the Divide class?
09:14:59 <EvilTerran> sshc, in haskell98, you can't
09:15:39 <EvilTerran> sshc, as a haskell98 instance decleration has the form "instance (<context>) => Class (TypeConstructor typeVariable typeVariable2 ...)"
09:15:48 <EvilTerran> (there can be no type variables there)
09:16:26 <sshc> EvilTerran: ok, thanks
09:16:27 <Lemmih> Athas: Why are you interested in only exporting the data constructor?
09:16:40 <EvilTerran> sshc, if you use the FlexibleInstances extension (which is, admittedly, popular), you get closer to it working, but you'd still have trouble with undecidability and overlaps
09:16:54 <Athas> Lemmih: It's the only part that's useful.
09:17:01 <EvilTerran> sshc, defining an instance for each type you want to use may be the way to do it
09:17:16 <jethr0> class Divide a where
09:17:18 <jethr0>   divide :: a -> a -> a
09:17:19 <jethr0> instance Divide Int where
09:17:21 <jethr0>   divide a b = a `div` b
09:17:22 <jethr0> instance Divide Float where
09:17:24 <jethr0>   divide a b = a / b
09:17:26 <jethr0> sshc: this works
09:17:33 <Lemmih> Athas: You could use a smart constructor. http://www.haskell.org/haskellwiki/Smart_constructors
09:17:46 <jethr0> even though you can't apply it to other type classes like Integral and Fractional, but only to concrete types
09:18:24 <EvilTerran> sshc, or you could have "newtype WrappedIntegral a = WI a; newtype WrappedFractional a = WF a; instance Integral a => Divide (WrappedIntegral a) where {...}; instance Fractional a => Divide (WrappedFractional a) where { ... }"
09:19:01 <EvilTerran> sshc, with the GeneralizedNewtypeDeriving extension, that wouldn't even be that annoying, as you could make both the wrappers derive most useful classes
09:19:15 <jethr0> EvilTerran: yes, but how would you transparently get the Integral/Fractional into the smart types?
09:19:37 <EvilTerran> jethr0, you don't.
09:19:40 <jethr0> higher order type classes that can act on other type classes might be cool (or just a horrible mess in type land)
09:20:00 <Athas> Lemmih: well, but those are not uppercase!
09:20:08 <EvilTerran> jethr0, you'd end up making an instance for each concrete type for some typeclass or another, whatever you did
09:20:12 <jethr0> since the type system is turing complete, couldn't you write a type-level "isFractional"?
09:20:30 <Athas> Unless I decide to use type arithmetic, but I'm not quite that crazy yet.
09:20:42 <EvilTerran> jethr0, no. bear in mind typeclasses are open.
09:21:05 <EvilTerran> jethr0, so it's impossible for the system to infer that some type is not an instance of some typeclass.
09:21:32 <EvilTerran> jethr0, anyway, "turing complete" doesn't tell you anything about how contrived your encoding of problems would have to be to take advantage of the TCness.
09:21:34 <jethr0> ah, so there can't be a function "TypeClass -> [Types]", because it's an opt-in relationship?
09:21:42 <EvilTerran> pretty much
09:22:05 <EvilTerran> well, it's because you can always add another type to a typeclass later
09:22:15 <jethr0> EvilTerran: hehe, well, it means many things would be theoretically possible. personally, type-level hackery makes my head hurt
09:22:29 <EvilTerran> it's kinda related to intuitionistic logic, i guess
09:22:39 <EvilTerran> you can say "this type is definitely in this class"
09:22:57 <EvilTerran> but you can't say "this type is definitely not in this class", you can only say "i can't prove this type is in this class"
09:23:04 <jethr0> so, the type system can check whether a given type is part of a type class, but cannot derive all types that are instances, right?
09:23:06 <periodic> Just use links.  It's better than lynx and it works fine. :D
09:23:13 <jethr0> ah, k
09:23:24 <MyCatVerbs> EvilTerran: welcome to Prolog. :)
09:23:24 <periodic> oops, wrong channel
09:23:27 <jethr0> does anyone know how to link against dlls with ghc under windows/mingw?
09:23:37 <jethr0> periodic: indeed ^_^
09:24:24 <periodic> Oh hey, I wanted to write something to do some network monitoring with pings and stuff, but there seems to be very bad support for ICMP in the Haskell libraries.  Anyone know any different?
09:24:40 <EvilTerran> jethr0, i don't think ghc does dynamic linking
09:24:48 <Heffalump> it will do in 6.12 AIUI
09:24:55 <jethr0> oh bother!
09:25:29 <EvilTerran> jethr0, you might be able to abuse the FFI to dynamically load in the DLL that you want
09:25:47 <EvilTerran> jethr0, but i personally would rather stab myself in the eye with a fork than try to pull that off
09:26:06 <jethr0> periodic: have you looked in http://hackage.haskell.org/packages/archive/pkg-list.html#cat:network ?
09:26:35 <jethr0> EvilTerran: yes, i've read about that somewhere last year. didn't seem like a very pleasant exercise
09:27:44 <jethr0> it's really annoying. i've build hs-fltk with cabal and everything went fine. but when i compile a helloworld example, i get linker errors from the libHShs-fltk.a. And i don't understand why
09:28:08 <jethr0> this is under windows/mingw BTW.
09:28:22 <EvilTerran> (stab myself in the IO with a fork?)
09:28:31 <EvilTerran> (stab myself with a forkIO?)
09:29:18 <EvilTerran> (/etc/fstab... yeah, i'll stop now.
09:30:44 <jethr0> stab id `using` forkIO
09:32:55 <periodic> jethr0: Yup, wasn't finding any mention of pings or ICMP other than one program that uses pings incidentally.
09:32:55 <dons> byorgey: pong?
09:33:27 <gwern> periodic: you know what's even better than links? elinks
09:33:54 <periodic> jethr0: I was thinking about using FFI, but I don't know what C library usually hands ICMP.  Was having some trouble getting useful info with searches.
09:33:58 <byorgey> dons: I'm working on adding a 'cabal init' command, I wanted to ask if it would be OK to take the mkcabal code as a starting point.
09:34:01 <Vanadium> You need to have superuser privileges to do ICMP, no?
09:34:17 <byorgey> dons: since technically mkcabal is GPL and cabal-install is BSD3.
09:34:17 <periodic> Vanadium: Don't think so.  I don't think my ping program is setuid.
09:34:28 <Vanadium> Mine appears to be :(
09:34:57 <dons> byorgey: yes, please go for it. and I hearby bless relicensing the code as BSD
09:35:09 <canvon> periodic: -rwsr-xr-x 1 root root 30736 2007-01-31 00:10 /bin/ping
09:35:22 <Vanadium> linux appears to have a manpage for icmp, as far as C access goes
09:35:28 <periodic> canvon: huh.  I never knew. :D
09:35:29 <byorgey> dons: OK, thanks.  it's quite possible none of the original mkcabal code will survive rewriting anyway =)
09:35:34 <canvon> periodic: ;)
09:35:48 <Vanadium> I suspect I would try to get away with executing the ping binary instead of reading it
09:35:59 <dons> byorgey: right. you should use more of the Cabal modules and types
09:36:01 <dons> for example
09:36:06 <byorgey> dons: right.
09:36:09 <byorgey> dons: are you in Edinburgh?
09:36:17 <dons> byorgey: not yet, on the way to the airport.
09:36:26 <periodic> I saw a man page for the ICMP kernel module.  Maybe I'll just dig deeper.
09:36:27 <dons> btw, what's the best way to get from edinburgh airport into the city?
09:36:33 <byorgey> ok, cool.  have a good flight, see you soon!
09:36:50 <byorgey> dons: into the city, I'm not sure.
09:37:08 <dons> ok.
09:37:16 <byorgey> dons: Dougal Stanton says there is a bus
09:37:38 <dons> ok.
09:37:43 <byorgey> that goes straight from the airport to downtown.  route 100, I think.
09:38:54 <dons> done.
09:39:08 * dons -> to the airport. bbl
09:47:31 <sshc> if handler is defined correctly, then should "line <- getLine `catch` handler" compile fine?
09:47:53 <sshc> or am I misunderstanding how '<-' works?
09:50:18 <Makoryu> sshc: You could be a bit more specific about "defined correctly." To begin with, though, note that "x <- y `foo` z" is always "x <- (y `foo` z)" and never "(x <- y) `foo` z"
09:51:20 <Makoryu> :t catch
09:51:21 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
09:52:04 <canvon> sshc: handler's result has to be of the same type as getLine's, so handler could catch some IO error(s) and substitute a default result, or something on that lines. if you want to not run the code following the "<-" line in that do block in case an IO error occurs, you should use catch on the whole do block, instead.
09:52:06 <Makoryu> So, as long as you have "handler :: IOError -> IO ()" you should be okay
09:52:22 <sshc> Makoryu: where handler error | isEOFError error = return () | otherwise  = ioError error
09:53:09 <sshc> Makoryu: should I replace return () with ""?
09:53:13 <Makoryu> ...Oh shit, getLine is IO String
09:53:15 <Makoryu> Yeah.
09:53:24 * Makoryu headdesks
09:53:29 <Makoryu> My mistake :p
09:53:42 <sshc> (return "" or just ""?)
09:53:47 <Makoryu> sshc: return ""
09:53:58 <sshc> ok, thanks
09:54:00 <canvon> shapr: that would compile, but it would run the code following the "<-" line, with the name "line" bound to the empty string
09:54:06 <Makoryu> sshc: That way, line will be assigned to ""
09:54:10 <canvon> *sshc:
09:54:24 * Makoryu is not wording things clearly today
09:55:28 <sshc> canvon: how would I terminate the program nicely when EOF error is generated?
09:55:49 <jethr0> exitWith ExitFailure?
09:56:17 <canvon> sshc: you could apply "catch" to the whole resulting IO action that your "do" block composes
09:56:32 <sshc> canvon: ok
09:56:42 <sshc> jethr0: that would work too, but I'd want ExitSuccess
09:56:47 <Makoryu> sshc: main = foo `catch` handler where foo = do ...
09:56:56 <jethr0> k
09:56:59 <canvon> sshc: i.e., handleLine = do { line <- getLine; doSomethingWith line; ... }; main = handleLine `catch` handler
09:57:09 <canvon> ..ok, as Makoryu said ;)
09:57:30 <Makoryu> sshc: It really depends on how you want your program to be structured.
09:58:30 <sshc> canvon: I've never seen {}'s used outside of type constructers (record syntax, I think)
09:59:13 <canvon> sshc: usually you don't need them, because of layout. I just used them to put everything on a single line on IRC
09:59:41 <canvon> sshc: layout is implicit {}s to the compiler
09:59:49 <canvon> sshc: {}s and ;s
09:59:51 <Makoryu> sshc: The whitespace-sensitive "layout" notation (in do-blocks, etc.) is syntactic sugar for {foo;bar;etc.}
10:00:18 <sshc> I see
10:00:42 <sshc> then can I use braces to make haskell more flexible with whitespace?
10:00:57 <Makoryu> Yep
10:01:01 <sshc> sometimes I find that the indentation rules obscure my code and make it less readable
10:01:11 <sshc> Makoryu: wow, really?
10:01:15 <sshc> Makoryu: how would I use them?
10:01:54 <Makoryu> sshc: Put an opening brace after any use of the keywords let/where/do/of
10:02:33 <sshc> Makoryu: do I need semicolons?
10:02:47 <path[l]_> anyone know when dons comes in?
10:02:54 <Makoryu> sshc: Yes. Any time you insert braces manually, you also have to insert semicolons
10:03:05 <Makoryu> path[l]_: You missed him. He went to the airport
10:03:09 <sshc> Makoryu: that's good :)
10:03:10 <path[l]_> ah
10:03:16 <path[l]_> thanks
10:03:22 <canvon> sshc: usually, the layout rules help you in rethinking the structure of your program, and write it down more readably. at least in my experience
10:03:23 <sshc> Makoryu: I never knew about that.  That makes this a lot easier, thanks
10:03:51 <sshc> Makoryu: what does the 'of' keyword do?
10:04:02 <Makoryu> sshc: In "case ... of ..."
10:04:06 <canvon> sshc: it needs a little exercise / playing around with the layout / trying layout possibilities out and thinking about them, though
10:04:07 <sshc> ah, right
10:04:27 <path[l]_> what does 'on' do?
10:04:34 <Makoryu> :t on
10:04:35 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:05:35 <path[l]_> hmm I guess Ill need to see an example of that. Specifically when would you have b->b->c very often
10:05:38 <canvon> sshc: normally, you should never need to use braces or semicolons (except, as you say, with record constructors/updates). it's really just another option, most useful for putting everything on one line in ghci or on IRC
10:06:25 <canvon> path[l]_: comparison functions / equality tests. it's used with sorting.
10:06:47 <path[l]_> ah
10:06:53 <Makoryu> canvon: The layout rule is really confusing for people new to Haskell, even though it makes a lot of sense once you're used to it
10:06:56 <path[l]_> ok I see
10:07:00 <pr> @type id `on` id
10:07:01 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> c
10:07:01 <lambdabot>     Probable cause: `id' is applied to too many arguments
10:07:01 <lambdabot>     In the first argument of `on', namely `id'
10:07:16 <canvon> path[l]_: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Function.html#v%3Aon says: Typical usage: Data.List.sortBy (compare `on` fst).
10:07:32 <path[l]_> aha ok I see.
10:07:39 <pr> @type const `on` id
10:07:40 <lambdabot> forall a. a -> a -> a
10:08:02 <path[l]_> id 5
10:08:06 <path[l]_> >id 5
10:08:11 <path[l]_> :t id
10:08:13 <lambdabot> forall a. a -> a
10:08:19 <canvon> path[l]_: so, "on" combines the general "compare" function with something that extracts what should actually be compared. (the first entry of a tuple/pair, in this case.)
10:08:26 <path[l]_> yeah
10:08:33 <path[l]_> I get it now :)
10:08:36 <Makoryu> sshc: http://en.wikibooks.org/wiki/Haskell/Indentation <- Look at the examples near the bottom (sweet/unsweet)
10:08:43 <canvon> path[l]_: sorry :)
10:08:49 <path[l]_> haha nah
10:10:22 <EnglishGent> hello again :)
10:16:01 <sshc> if I have rx declared as "let rx = (reads x :: [(Double, String)])", why is ghc inferring 'rx' as a double in "fst . head $ rx"?
10:16:21 <skorpan> :t head
10:16:22 <lambdabot> forall a. [a] -> a
10:16:22 <sshc> Makoryu: thank you for the link
10:16:50 <skorpan> :t reads
10:16:51 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:17:37 <skorpan> sshc: ghc does not infer Double on "rx", but on "fst . head $ rx", but anyways, i can't see why you would expect something else
10:18:15 <Makoryu> :t fst . head
10:18:17 <lambdabot> forall a b. [(a, b)] -> a
10:18:55 <Makoryu> :t let foo :: [(Double,String)]; foo = [(9,"")] in fst . head $ foo
10:18:56 <lambdabot> Double
10:19:05 <Makoryu> > let foo :: [(Double,String)]; foo = [(9,"")] in fst . head $ foo -- sshc
10:19:06 <lambdabot>   9.0
10:19:12 <sshc> oh, I misread the reror
10:19:14 <sshc> the error
10:25:07 <sshc> skorpan: map (:(fst . head $ rx)) acc
10:25:26 <skorpan> that doesn't make any sense
10:25:35 <sshc> skorpan: I think it expects (fst . head $ rx) to be [a]
10:25:42 <skorpan> yes,
10:25:45 <skorpan> :t (:)
10:25:46 <lambdabot> forall a. a -> [a] -> [a]
10:26:29 <sshc> acc is the list, and (fst . head $ rx) is the double that should be prepended to the list
10:27:15 <skorpan> you want to append an element to a list?
10:27:25 <sshc> skorpan: no, I want to prepend
10:27:35 <skorpan> (fst . head $ rx):acc
10:27:49 <sshc> I don't know why I did map
10:44:49 <Makoryu> > zipWith (!!) [5..10] "The spirits of the computer"
10:44:50 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:45:25 <Lemmih> Makoryu: Wrong way around.
10:46:07 <Makoryu> > let slice = zipWith (!!) in "The spirits of the computer" `slice` [5..10]
10:46:08 <lambdabot>   Couldn't match expected type `[a]'
10:46:23 <mornfall> :)
10:46:41 <Makoryu> Ah, whoops
10:46:49 <pikhq> Char /= String ;)
10:47:05 <Makoryu> > let slice = map . (!!) in "The spirits of the computer" `slice` [5..10]
10:47:06 <lambdabot>   "pirits"
10:47:21 * Makoryu is really not on a roll today....
10:48:20 <medfly> the spirits of the computer are angry
10:55:00 * EnglishGent sacrifices some C code
10:55:01 <EnglishGent> :)
10:56:09 <Makoryu> No, sacrifice C's first born
10:56:13 <ibid> on which altar?
10:57:44 <arw_> cobol or intercal
10:58:15 <arw_> depending on wether you are lawful evil or chaotic good.
10:58:52 <EnglishGent> which is which?
10:58:54 <EnglishGent> :)
10:59:08 <arw_> same order as above.
10:59:29 <ShaMun> Why haskell not Ada/C ?
10:59:32 <arw_> except on tuesdays
11:00:08 <dm`> I find the error handling really hard to deal with in Haskell, and am wondering if I'm missing something.
11:00:26 <dm`> For example, say I want to catch the error where I call readSymbolic link on a non-symbolic link.
11:00:35 <dm`> ghci says:  *** Exception: README: readSymbolicLink: invalid argument (Invalid argument)
11:00:50 <dm`> Digging through docs, I find an InvalidArgument type, but it's not clear what module I need to import to get this type.
11:01:05 <dm`> Nor is it clear which "isWhateverError" function would give me the right predicate.
11:01:09 <Makoryu> ShaMun: In general?
11:01:13 <dm`> Is there an easier way of doing this?
11:01:21 <kmc> dm`, call isSymbolicLink first?
11:01:32 <dm`> Unfortunately, that causes a race condition.
11:01:41 <arw_> .oO( i hate exceptions, Maybe is so much nicer... )
11:01:58 <dm`> There is potentially untrustworthy code concurrently manipulating the file system.  I can't allow it to kill my program.
11:02:13 <ShaMun> Makoryu, in both sir.
11:03:06 <Makoryu> ShaMun: Haskell is actually safer than Ada, but also much nicer to use and better supported, with the ability to get a lot done in much less code.
11:03:23 <kmc> yeah, it'd be nice to get a Maybe result from readSymbolicLink, but also IO is supposedly a MonadPlus itself
11:04:07 <dm`> I mean I can obviously catch a generric IOException.  But in cases like permission denied, I would actually like the exception to escape my function.
11:04:10 <gwern> ada has some nice features, I think; at least, it's hard in haskell to declare an int type from just 1 to 100, which i understand ada can do
11:04:31 <Makoryu> ShaMun: As for C... Well, there are still plenty of reasons to write kernels and device drivers in C (though good luck catching all the bugs) but it's really a terrible language for general usage.
11:05:01 <Makoryu> gwern: Yeah, inherited from Pascal. That's the one thing I was disappointed to see that Haskell lacked
11:05:21 <Makoryu> @where she
11:05:21 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
11:05:33 <gwern> Makoryu: although I don't know how that works - is it compiletime checking that it will always be 1-100 or just runtime checks?
11:05:43 <gwern> which wouldn't be *too* difficult in haskell with smart constructors throwing error
11:05:56 <Makoryu> gwern: I always wondered about that. Naturally it can compile-time check any constants you use
11:06:41 <Makoryu> gwern: I never got around to trying it out to see what would break it at runtime
11:06:44 <dm`> @src InvalidArgument
11:06:45 <lambdabot> Source not found. That's something I cannot allow to happen.
11:06:56 <ShaMun> Makoryu, is there any OS written on haskell ? whats about the performance of haskell compared to c/ada ?
11:07:13 <kmc> languages don't have performance
11:07:43 <ShaMun> kmc, yes it has, i used pascal, c, c++, java, vb6, vb.net, php, ruby.
11:07:49 <Makoryu> ShaMun: There are a couple of experimental OSes written in Haskell, but obviously those don't include Linux, Windows, or OS X
11:08:02 <ShaMun> ic
11:08:13 <dm`> I'd like to write an OS in Haskell, but I'm not yet sure it's feasible.  I've done 3 OSes, all in C, so I have a fair amount of experience here.
11:08:32 <dm`> Do you have links to the Haskell OSes?
11:08:36 <kmc> ShaMun, i'm a fan of the "strongly typed OS" concept but it's still a far-out research project
11:08:43 <kmc> @where House
11:08:43 <lambdabot> http://programatica.cs.pdx.edu/House/
11:08:50 <gwern> dm`: house and sl4 are probably your best haskell bets
11:09:01 <arw_> gwern: depends on the compiler and runtime-system wether those types are checked at compile-time, runtime or both.
11:09:06 <kmc> certainly, using Haskell to implement UNIX where every type is [Byte] would be a waste
11:09:12 <ShaMun> kmc, i am trying to figure out differcens and top who is? ADa or Haskell or C ?
11:09:22 <Makoryu> ShaMun: GHC is the most mature Haskell compiler. It's very good at optimizing code, and getting better. Parallel programs using GHC can easily outperform parallel C programs
11:09:42 <Botje> ShaMun: learn all three and make up your own mind :)
11:09:56 <arw_> gwern: some compilers do evil magic to prove that a loop counter cant exceed its upper bound because its not modified anywhere and optimize away the runtime check, for example.
11:10:04 <gwern> cool
11:10:11 <kmc> ShaMun, when i say "languages don't have performance" i mean that performance is a characteristic of an implementation
11:10:11 <ShaMun> Botje, i would then say hla? but again the test of performance of layer near to cpu.
11:10:19 <arw_> gwern: but thats not the rule afaik
11:10:20 <ShaMun> ok Makoryu
11:10:23 <dm`> The big appeal of Haskell for an OS kernel is that much of the kernel could could be not security critical.
11:10:30 <kmc> some languages are easier or harder to implement efficiently, it's true
11:10:42 <gwern> even malbolge could be fast?
11:11:00 <dm`> The big drawback is that, at least with C, when I look at source, I have a fairly good idea what the machine code is doing.  With Haskell, not so much.  I should probably try to read up on how Haskell compilers work, if there are good references.
11:11:11 <arw_> kmc: languages do have performance. there are limiting factors in language design.
11:11:41 <kmc> dm`, http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
11:11:56 * copumpkin yawns
11:12:29 * EnglishGent hands copumpkin a coffee
11:12:30 <Makoryu> arw_: Still, it's more meaningful to speak of the performance of implementations, especially if a language has more than one implementation. (Haskell is one such language... Try running your Project Euler code in Hugs)
11:12:33 <EnglishGent> hi copumpkin :)
11:12:34 <copumpkin> EnglishGent: thanks!
11:12:37 <dm`> Also, another advantage of C is that there are lots of compilers, some of them very small.  Since ultimately the compiler is part of the trusted computing base, it's nice to have those multiple, especially small, options, though in practice everyone uses gcc which is a pig.
11:12:39 <gwern> @quote co.*coffee
11:12:39 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
11:12:43 <gwern> bah
11:12:55 <gwern> @quote coffee
11:12:55 <lambdabot> liyang says: My coffee machine isn't l33t enough. I'm planning to make it l33t.
11:12:59 <EnglishGent> I think there's at least one formally verified compiler out there now
11:13:10 <kmc> dm`, what's the smallest haskell compiler
11:13:18 * EnglishGent cant remember details off hand - but is sure he saw one on lamdba the ultimate a while back
11:13:24 <gwern> kmc: one of the ehcs
11:13:28 <dm`> kmc: Thanks for the references.  Looks like good reading.
11:13:41 <gwern> although those run the gamut from not haskell at all to kind of sort of haskell to haskell 98
11:13:44 <Makoryu> C is a horrible, horrible language from an optimization point of view. I'd much rather have the option of high-level array programming (another nicety of Ada)
11:13:45 <arw_> Makoryu: yes. but for example c++ is often slower than c because c++ does some runtime binding and typechecking which is a slowdown by design.
11:14:10 <kmc> arw_, all of that is made explicit in C++
11:14:17 <ShaMun> HLA was good, but again its using the layer of c.
11:14:21 <dm`> I would imagine that until haskell' comes out, it may be hard to use the smallest compiler.  I find it hard to use haskell without enabling at least some language extensions.
11:14:49 <dm`> C is possibly harrible from the point of view of the compiler optimising, but it's good if the human wants to optimise.
11:14:56 <ShaMun> its impossible still now there is no real research results compared to Ada/C/Haskell technically who is staying which level.
11:14:59 <arw_> dm`: there will always be the magic extension which makes it hard to resist turning it on..
11:15:14 <Botje> arw_: C++ does it damned best to avoid such situations, though :)
11:15:47 <kmc> you can write C++ without any runtime types or dynamic binding and it's still much nicer and safer than C
11:16:17 <arw_> Botje: yes, of course. there are languages which are worse in that aspect. but c and c++ are nice as an example there because there are comparable compilers and implementations.
11:16:49 <Botje> yeah
11:16:57 <Makoryu> arw_: Again, it's more meaningful to talk about implementations than the language itself
11:17:06 <Botje> ShaMun: pick a language, stick with it, and performance will have increased by the team you master it.
11:17:59 <dm`> C++ is a huge stinking heap of garbage.  By lines of code, I've written far more C++ than any other language, but there are vast portions of the language that I've never used, because either it's not possible to implement them correctly (e.g., the export keyword), or they just totally suck (like many parts of the STL, which don't allow intrusive containers).
11:18:59 <dm`> But because there's so much garbage in C++, you can kind of carve out of it what you want.  The thing that hooked my on C++ was function currying, and reference-counted garbage collection, both of which can be implemented using templates.
11:19:13 <arw_> there are usable subsets of c++, but somewhere in the project somebody is lurking who drags up something which only uses the ugly subset, and then you are stuck with it.
11:19:15 <Makoryu> ShaMun: Ada is about as lively as COBOL at the moment (though it might make a comeback). C and Haskell compilers are actively being worked on and improved on a daily basis. In other words, C and Haskell are getting faster all the time
11:19:27 <dm`> Anyone who uses the STL is asking for performance trouble, though.  O(n) to remove something from a linked list?  Come on!
11:20:06 <Botje> Makoryu: Guessing by the ada presentations on FOSDEM, i'd say it still has an active community :)
11:20:18 <ShaMun> Makoryu, i understand c/haskell/java, regular in updates.
11:20:28 <dm`> I constantly have data structures which are, say, in a lookup table and a timeout tailq, and paying O(n) to remove it from the timeout queue would be ridiculous, when it should be O(1).
11:20:37 <arw_> dm`: thats not really correct. thats just an upper bound for what is allowed for conforming implementations. it is perfectly ok to be faster than O(n)
11:20:37 <Makoryu> Botje: Then I guess it's already making a comeback and I didn't know about it :p
11:20:57 <Makoryu> Botje: It's actually good to hear, because Ada would be a really great systems language if it wasn't so damn verbose
11:21:02 <Botje> Makoryu: then again, half the audience there was over fourty ;)
11:21:18 <Makoryu> Botje: Heh >_>
11:21:21 <dm`> But the interface won't let you be O(1).  In order to make your list removal O(1), you need to ensure that the object itself contains the next and prev pointers.
11:21:36 <dm`> That requires an interface incompatible with STL's.
11:22:02 <kmc> imo C++ is a pretty reasonable language given their totally unreasonable set of design goals
11:22:28 <vegai> haskell evades this problem neatly by not having an interface to sequences in the first place
11:22:31 <vegai> :P
11:22:49 <kmc> vegai, yes despite it being the canonical use case for MPTC
11:22:51 <MyCatVerbs> dm`: "The future of the export keyword is unknown. Without taking sides in the debate, I will simply report that some compiler vendors are indicating they might never implement it, and that the C++ standards committee has decided to leave it in." <- export's a C++09 feature, right?
11:22:59 <dm`> I'll say it's quite possible to implement high-quality software in C++, but you definitely have to have discipline.  Unlike Haskell, don't look to the language to help you in that department.
11:23:00 <arw_> dm`: not really. you can always implement them as private members.
11:23:32 <Makoryu> ShaMun: Anyway, most of the people in here are here because Haskell is really great. You should learn both C and Haskell
11:23:50 <ShaMun> Makoryu, i am trying openCV library to have robotics staffs. My question is   this is [cpu/ram < compiler layers < who is the closer to reach faster in hardware layer] ?
11:23:51 <Luke> i'm trying to generalize an instance of a class I made since the code for two types of the instance are exactly the same: http://bitbucket.org/LukeHoersten/rubix/src/tip/Cube.hs#cl-34
11:23:58 <Luke> can anyone help me out there?
11:24:30 <Makoryu> ShaMun: Okay, if you're interfacing with the hardware, you're probably stuck with C one way or another
11:25:04 <MyCatVerbs> Makoryu: not necessarily. Even Haskell has Foreign.*.
11:25:23 <kmc> also it should be noted that nearly any language can foreign-call C code
11:25:29 <ShaMun> Makoryu, why nasa shuttle used Ada then?
11:25:39 <kmc> so while you may need some interface layer in C it needn't constrain your high-level processing
11:25:52 <dm`> Ah, found my exception stuff in GHC.IOBase.
11:26:01 <dm`> But presumably I shouldn't import that module.
11:26:15 <kmc> ShaMun, the space shuttle is not exactly the most successful space vehicle  :)
11:26:19 <dm`> InvalidArgument has a comment saying GHC only.
11:26:24 <kmc> though i hear the software is a lot better than the hardware
11:26:27 <arw_> ShaMun: because us govt and military require ada as a language?
11:27:38 <ShaMun> arw_, kmc: i understand we dont have transparent answer approve in details. we will be in blind layers and keep on selecting.
11:27:40 <kmc> fact: no aerospace vehicle running Haskell code has ever crashed
11:27:44 <ShaMun> anyway thanks for the suggestions.
11:27:59 <ksf> zomfg.
11:28:00 <MyCatVerbs> EvilTerran: was it you who mentioned a verified compiler earlier? On the offchance, I found the LTU article, http://lambda-the-ultimate.org/node/3554
11:28:27 <ksf> using parametrised monads and a few other goodies, we can code up usage semantics of ffi libraries
11:28:36 <ksf> (amogst doing other fun stuff)
11:35:15 <kmc> is there a name for: maybe mzero return
11:35:21 <Lemmih> MyCatVerbs: It's a shame Adam Chlipala was banned from #haskell. That guy is smart.
11:35:21 <kmc> :t maybe mzero return
11:35:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
11:35:37 <kmc> Lemmih, what do you have to do to get banned from #haskell
11:35:58 <MyCatVerbs> Lemmih: ...really? ô_Ô
11:36:01 <Lemmih> kmc: Be overly pedantic.
11:36:08 <Vanadium> dm`: I do not understand why removal of an item in a std::list given an iterator is not a constant time operation as it is labeled in the standard.
11:36:17 <MyCatVerbs> It's pretty pedantic in here already.
11:36:23 <kmc> imo, people here are nicer than any other freenode language channel by far
11:36:24 <MyCatVerbs> Uh, just how pedantic does one have to get?
11:36:30 <kmc> possibly because haskell is scary to beginners
11:36:45 <kmc> whereas python has such a glut of clueless beginners that they assume you're an idiot right from the start
11:36:50 <EnglishGentv2> edwinb: I constructed a monster using SHE!
11:36:57 <copumpkin> whoops
11:36:58 <inimino> Lemmih: if that were all, the population would be halved
11:37:37 <kmc> also functional programming is inherently stress-relieving
11:37:42 <ezyang> :-)
11:37:53 <kmc> whereas C++ programming causes dementia and an early death
11:38:21 <ezyang> What's the idiom for taking an untrusted list and tuplifying it (raising an error or something if it's too short or too long)?
11:38:47 <copumpkin> ezyang: there isn't one, people don't use n-tuples for n > 2
11:38:51 <copumpkin> :P
11:38:52 <ezyang> I can think of ways to do this myself, but they aren't very useful
11:39:03 <copumpkin> ezyang: you could use my new sized vectors in SHE ;)
11:39:06 <copumpkin> :o
11:39:10 <ezyang> oh, actually, what I meant was assigning the values of the list to named variables
11:39:18 <thetallguy> ezyang: depends on how many elements
11:39:24 <ezyang> sorta like foo = args[0], bar = args[1], baz = args[2]
11:39:25 <copumpkin> f [a,b,c,d] = a + b + c + d
11:39:30 <Vanadium> case list of [a, b, c] ->?
11:39:39 <kmc> > let [a,b,c] = "foo" in a
11:39:40 <lambdabot>   'f'
11:39:41 <thetallguy> ezyang: I have seen people use that technique for processing program arguments
11:39:42 <copumpkin> ezyang: but that loses type safety
11:39:44 <kmc> > let [a,b,c] = "foobar" in a
11:39:45 <lambdabot>   * Exception: <interactive>:1:137-154: Irrefutable pattern failed for patter...
11:39:50 <thetallguy> ezyang: not great error messages
11:40:05 <ezyang> Right: I want decent error messages
11:40:23 <ezyang> I mean, I could do a quick length check before doing this
11:40:34 <thetallguy> ezyang: check the length and throw and return a Left
11:40:45 <copumpkin> ezyang: then write case args of [a,b,c,d] -> myStuff; _ -> error "dayum gimme the right number of arguments man"
11:40:46 <ezyang> ok.
11:41:09 <copumpkin> or use sized vectors!
11:41:09 <copumpkin> :D
11:41:46 <ezyang> hmm, that increases indent. I guess I'm ok with that
11:42:57 <Luke> anyone have any thoughts on the code I posted earlier?
11:44:13 <ezyang> wat; return undefined didn't result in an error
11:44:30 <pr> > return undefined
11:44:31 <lambdabot>   No instance for (GHC.Show.Show (m a))
11:44:32 <lambdabot>    arising from a use of `M2669018841...
11:44:36 <pr> @type return undefined
11:44:38 <lambdabot> forall a (m :: * -> *). (Monad m) => m a
11:44:38 <copumpkin> ezyang: yeah...
11:45:00 <copumpkin> ezyang: unless someone does something with your return value, it's just boxed up in whatever monad you're using
11:45:03 <pr> > return undefined :: Reader Int Int
11:45:05 <lambdabot>   No instance for (GHC.Show.Show
11:45:05 <lambdabot>                     (Control.Monad.Reader.Re...
11:45:28 <kmc> ezyang, "undefined" doesn't cause an error until it's evaluated
11:45:28 <copumpkin> return undefined is const undefined for functions, so unless you apply the function you're not going to get an error
11:45:30 <pr> @type runReader $ return undefined :: Reader Int Int
11:45:31 <lambdabot>     Couldn't match expected type `Reader Int Int'
11:45:31 <lambdabot>            against inferred type `r -> a'
11:45:31 <lambdabot>     In the expression: runReader $ return undefined :: Reader Int Int
11:45:49 <pr> @type runReader (return undefined :: Reader Int Int)
11:45:51 <lambdabot> Int -> Int
11:46:05 <ezyang> ok.
11:46:11 <pr> > runReader (return undefined :: Reader Int Int) 5 -- ohai
11:46:12 <lambdabot>   * Exception: Prelude.undefined
11:46:47 <copumpkin> > (return undefined) 5
11:46:48 <lambdabot>   * Exception: Prelude.undefined
11:46:58 * copumpkin doesn't really understand why Reader exists
11:47:16 <copumpkin> ReaderT I can see
11:47:33 <ezyang> For the sake of monadic completeness?
11:47:49 <copumpkin> well, (->) is exactly Reader
11:48:08 <copumpkin> I guess it doesn't have a data constructor
11:48:13 * copumpkin shrugs
11:48:26 * copumpkin has never used Reader
11:48:48 <ezyang> Hmm... should I import Network.CGI.Protocol to get maybeRead...
11:49:25 <ezyang> @source maybeRead
11:49:25 <lambdabot> maybeRead not available
11:49:35 <ezyang> @source Network.CGI.Protocol.maybeRead
11:49:36 <lambdabot> Network.CGI.Protocol.maybeRead not available
11:49:39 <ezyang> :-(
11:51:06 <ezyang> huh, maybe read returning bottom will do what I want, given appropriate type signature
11:51:27 <copumpkin> :o
11:51:57 <etpace_> Is there a two parameter const?
11:52:12 <ksf> @hoolge String -> Maybe a
11:52:13 <lambdabot> Distribution.Text simpleParse :: Text a => String -> Maybe a
11:52:13 <lambdabot> Prelude fail :: Monad m => String -> m a
11:52:13 <lambdabot> Control.Monad fail :: Monad m => String -> m a
11:52:15 <ezyang> etpace_: As type of
11:52:21 <etpace_> > const (const ("foo")) $ 1 2
11:52:22 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
11:52:22 <lambdabot>    arising from the literal `1' at <...
11:52:27 <ksf> :t safeRead
11:52:29 <lambdabot> Not in scope: `safeRead'
11:52:34 <ksf> @hoogle safeRead
11:52:35 <lambdabot> Data.Array.Base unsafeRead :: (MArray a e m, Ix i) => a i e -> Int -> m e
11:52:45 <etpace_> :t const
11:52:46 <lambdabot> forall a b. a -> b -> a
11:52:52 <ezyang> :t asTypeOf
11:52:53 <lambdabot> forall a. a -> a -> a
11:53:17 <ezyang> oh, two parameter const
11:53:18 <ezyang> hmm
11:53:28 <copumpkin> asTypeOf is exactly const, with a more restricted type
11:53:40 <etpace_> > const "foo" $ 1
11:53:42 <lambdabot>   "foo"
11:53:45 <ezyang> :simpleParse "123"
11:53:50 <ezyang> > simpleParse "123"
11:53:51 <lambdabot>   Not in scope: `simpleParse'
11:53:56 <copumpkin> @pl (\x _ _ -> x)
11:53:56 <lambdabot> const . const
11:54:06 <ezyang> > Distribution.Text.simpleParse "123"
11:54:07 <lambdabot>   Not in scope: `Distribution.Text.simpleParse'
11:54:09 <etpace_> fair enough
11:54:29 <copumpkin> @let twice = join (.)
11:54:30 <lambdabot>  Defined.
11:54:35 <copumpkin> :t twice const
11:54:36 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> b
11:54:36 <lambdabot>     Probable cause: `const' is applied to too few arguments
11:54:36 <lambdabot>     In the first argument of `twice', namely `const'
11:54:38 <copumpkin> aw
11:54:40 <copumpkin> :P
11:54:43 <copumpkin> :t twice
11:54:44 <lambdabot> forall b. (b -> b) -> b -> b
11:54:45 <ezyang> :o
11:54:53 <copumpkin> > twice (+4) 5
11:54:56 <lambdabot>   13
11:55:11 <copumpkin> > (twice twice twice) (+4) 5
11:55:12 <lambdabot>   69
11:55:22 <Petrosian> @let twice' = (.)
11:55:23 <lambdabot>  Defined.
11:55:28 <Petrosian> @ty twice' const
11:55:30 <lambdabot> forall b b1 a. (a -> b) -> a -> b1 -> b
11:55:33 <etpace_> Is >>> the same as Categories ., or are the arguments swapped?
11:55:35 <Petrosian> Hmm.
11:55:37 <copumpkin> @let thrice f = f . f . f
11:55:38 <lambdabot>  Defined.
11:55:49 <copumpkin> > (thrice twice thrice) (+3) 5
11:55:51 <lambdabot>   19688
11:56:10 <copumpkin> > (thrice thrice thrice thrice) (*3) 4
11:56:15 <lambdabot>   mueval-core: Prelude.read: no parse
11:56:15 <lambdabot>  mueval: ExitFailure 1
11:56:20 <copumpkin> > (thrice thrice thrice) (*3) 4
11:56:22 <lambdabot>   * Exception: stack overflow
11:56:25 <copumpkin> :)
11:56:46 <copumpkin> > (thrice thrice) (*3) 4
11:56:48 <lambdabot>   30502389939948
11:57:36 <copumpkin> @let n `times` f = foldr (.) id (replicate n f)
11:57:38 <lambdabot>  Defined.
11:57:50 <copumpkin> > (5 `times` twice) (*3) 4
11:57:52 <lambdabot>   7412080755407364
11:57:54 <ezyang> Since read returns bottom if it can't read the string, is there any way to make this into a Maybe?
11:58:00 <ezyang> or do I have to use reads?
11:58:08 <copumpkin> there is, but it's impure
11:58:08 <Botje> yes, reads
11:58:18 <ezyang> kk
11:58:26 <Botje> listToMaybe . reads :)
11:58:43 <ezyang> yeah yeah :-)
11:58:50 <copumpkin> :t (3 `times` read)
11:58:51 <lambdabot> String -> String
11:59:04 <copumpkin> > (3 `times` read) "\"\"\"ohai\"\"\""
11:59:06 <lambdabot>   "* Exception: Prelude.read: no parse
12:00:07 <copumpkin> > read "\"\\"ohai\\"\"" :: String -- hmm
12:00:08 <lambdabot>   Not in scope: `ohai'
12:00:18 <copumpkin> > read "\"\\\"ohai\\\"\"" :: String -- hmm
12:00:19 <lambdabot>   "\"ohai\""
12:00:25 <copumpkin> there we go
12:00:35 <ezyang> I have kitty on lap
12:00:36 <copumpkin> > (5 `times` show) "ohai"
12:00:38 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"ohai\\\\\\\\...
12:00:41 <copumpkin> lol
12:00:48 <copumpkin> ezyang: meow!
12:01:05 <etpace_> http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial Can anyone tell me what the difference between his getWord and getword rng = pickWord rng >>> arr id
12:01:37 <ezyang> this means less Haskell hacking for now
12:01:51 <SamB> what's the point of the >>> arr id ?
12:02:10 <etpace_> oh, indeed, I mean
12:02:41 <etpace_> pickWord rng >>> Circuit (\word -> (accum' word (const . const $ word), word))
12:02:45 <copumpkin> why put arr in at all?
12:02:52 <copumpkin> oh I guess if you're not in the function arrow
12:03:07 * copumpkin shakes his fist at arr
12:03:29 <etpace_> although Im sure that can be tidied up as well, I don't understand that definition of and how it works. so I'm not sure if it does something different to the above
12:04:05 <copumpkin> etpace_: try asking blackh
12:04:25 <Petrosian> > (4 `times` (drop 1)) [1..10]
12:04:26 <lambdabot>   [5,6,7,8,9,10]
12:04:29 <Petrosian> Neat.
12:04:38 <skorpan> :t times
12:04:39 <lambdabot> forall a. Int -> (a -> a) -> a -> a
12:04:53 <copumpkin> > (4 `times` init) [1..10]
12:04:54 <lambdabot>   [1,2,3,4,5,6]
12:05:06 <etpace_> ok copumpkin
12:05:46 <ezyang> huh?
12:05:57 <ezyang> oh, i see.
12:06:11 <Petrosian> > (4 `times` (++"!")) "Foo"
12:06:12 <lambdabot>   "Foo!!!!"
12:06:23 <ezyang> kittie goes byebye
12:06:27 <copumpkin> meow
12:06:28 <ezyang> and now is on my bed
12:06:54 <ezyang> Ok, back to Haskell hacking ^_^
12:09:40 <copumpkin> > scanl1 (+) [1,0,1,0,0,2]
12:09:41 <lambdabot>   [1,1,2,2,2,4]
12:10:03 <ezyang> whoa, nice
12:12:58 <Vanadium> Is there a function to get all values of a type deriving from enum and/or bounded?
12:13:39 <EvilTerran> Vanadium, [minBound .. maxBound] ?
12:13:41 <copumpkin> Vanadium: enumerateFromTo minBound maxBound
12:13:50 <EvilTerran> > [minBound .. maxBound] :: Bool
12:13:51 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
12:13:52 <copumpkin> Vanadium: or my enumerable package *whistle*
12:13:59 <EvilTerran> > [minBound .. maxBound] :: [Bool] -- even
12:13:59 <copumpkin> [Bool]
12:14:00 <lambdabot>   [False,True]
12:14:06 <EvilTerran> > [minBound .. maxBound] :: [Ordering]
12:14:07 <lambdabot>   [LT,EQ,GT]
12:14:21 <EvilTerran> > [minBound .. maxBound] :: [()]
12:14:22 <lambdabot>   [()]
12:14:23 <EvilTerran> :P
12:14:25 <copumpkin> hawt
12:14:32 <ezyang> hmm, does Haskell have a prettier multiline syntax?
12:14:35 <copumpkin> > [minBound..maxBound] :: [Int8]
12:14:36 <lambdabot>   [-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114...
12:14:38 <ezyang> *multiline string syntax
12:14:43 <copumpkin> ezyang: doubt it
12:14:48 <skorpan> ezyang: no
12:14:48 <dons> ezyang: other than string gaps?
12:14:58 <ezyang> other than \  ... \
12:15:04 <ski> > [minBound .. maxBound] :: [Void]
12:15:04 <dons> not built in.
12:15:05 <lambdabot>   Not in scope: type constructor or class `Void'
12:15:09 <kmc> you could cook it up with quasiquoting
12:15:13 <dons> there are preprocessors, templates, etc
12:15:36 <ezyang> I have a chunk of help text that I want to embed in my program.  Give me the lowest resistance way!
12:15:50 <copumpkin> FFI!
12:15:51 <copumpkin> :P
12:15:56 <ezyang> maybe I'll do intercalate "\n" ["foo", "bar", "baz"]
12:16:00 <copumpkin> then stick a large constant in a c file
12:16:06 <dons> ezyang: unlines ["foo", ...]
12:16:08 <ezyang> oh boy oh boy
12:16:14 <ezyang> dons: ok
12:16:24 <copumpkin> how big is the data?
12:16:31 <copumpkin> ghc isn't a fan of big static data
12:17:43 <ezyang> copumpkin: A paragraph or two
12:17:54 <dons> oh, just use a string literal or  unlines
12:18:46 <ezyang> ok, I want to temporarily have this list have zero indentation
12:18:52 <ezyang> can I bracket it cleverly to make it work?
12:18:56 <sanders> question: I have a function "makeConfig" which returns a function which takes a function to be applied to the config object. Now for testing purposes I create a funtion call cget which takes a string (of a key to lookup in the config) and returns a function that can be used by the function returned by makeConfig...  This all works fine and well if I specifically give makeConfig a type signature (saying the function provided
12:18:58 <sanders> should take a string) but I was hoping to make it be able to use functions that return things other then Strings too
12:19:00 <ezyang> I guess I should just put it in a function
12:19:47 <sanders> hmm wow that was a confusing question
12:20:14 <kmc> sanders, can you pastebin some code
12:20:24 <copumpkin> @hpaste
12:20:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:21:48 <sanders> kmc: indeed http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8847#a8847
12:22:03 <ezyang> What is the equivalent of str_replace in Haskell?
12:22:17 <copumpkin> ezyang: none! :D
12:22:28 <ezyang> nerp
12:22:38 <EvilTerran> ezyang, what does string_replace do exactly?
12:22:55 <sanders> an example usage of the above would be: conf <- makeConf' "config.conf" ; conf (cget "application" "name
12:22:56 <ezyang> str_replace "foo" "bar" "foobarbaz" == "barbarbaz"
12:22:59 <lpjhjdh> has anyone read some literature on modular compilers by combined algebras?
12:23:00 <sanders> ")
12:24:10 <Makoryu> ezyang: There are a couple of regex packages that ought to do that
12:24:18 <ezyang> regex seems overkill for this case
12:25:38 <copumpkin> ezyang: http://hackage.haskell.org/packages/archive/text/0.4/doc/html/Data-Text.html#v%3Areplace
12:25:59 <EvilTerran> ezyang, you could probably put it together with split, tails, and so on
12:26:02 <ezyang> danke
12:26:20 <EvilTerran> er, span, not split
12:26:21 <ezyang> huh, it operates on Text, not String. Curious
12:26:39 <copumpkin> ezyang: Text is cool!
12:27:39 <Makoryu> > subRegex (mkRegex "zz") "pizza" "foo"
12:27:40 <lambdabot>   Not in scope: `subRegex'Not in scope: `mkRegex'
12:27:43 <Makoryu> Bah
12:30:20 <sanders> in my pasted code above if I give makeConfig' the type signature: makeConfig' :: FilePath -> IO ((CF.ConfigParser -> a) -> a) ,I get an error: Couldn't match expected type `GHC.Prim.Any'
12:30:42 <sanders> when I use the function resulting from makeConfig with cget
12:41:39 <bos> i don't suppose there's any way to get runtime info from the GC from within a running process?
12:42:25 <Cale> bos: You mean in a program compiled for profiling?
12:42:50 <bos> Cale: either for profiling or under normal circumstances.
12:43:23 <copumpkin> bos: I think there's some very basic info a FFI symbol away
12:43:26 <ezyang> Making a data type model is so much fun!
12:43:27 <bos> all i see is System.performGC, which isn't get useful.
12:43:30 <Cale> It would be awfully nice if there were more IO actions which provided information about the state of the RTS, but I don't think there are...
12:43:30 <copumpkin> for total bytes allocated
12:43:59 <bos> it's hard to write a good benchmarking library if you've no idea what might be perturbing your performance.
12:44:19 <copumpkin> you can get the number that ghci displays with :set +s basically
12:44:30 <copumpkin> I vaguely remember there being another counter you could attach to, like that
12:44:48 <ski> ezyang> str_replace "mama" "papa" "mamama"
12:45:25 <copumpkin> ski: did you see my vector-space intances for those sized vectors? :D
12:45:36 <ski> i don't think so
12:45:42 <ezyang> ski: str_replace would be greedy, so "papama"
12:46:03 <copumpkin> ski: http://gist.github.com/177854
12:46:03 * ski would expect every solution
12:46:16 <copumpkin> ah, that isn't my latest version
12:47:28 <ski> ezyang> str_replace "x" "y" "xx"
12:48:00 <ski> ezyang> str_replace "ab" "ba" "abb"
12:48:01 <ezyang> ski: "yy"
12:48:09 <ski> ezyang> str_replace "" "x" "yy"
12:48:30 <ezyang> ski: "bab"
12:48:48 <copumpkin> not bba?
12:48:49 <copumpkin> :P
12:49:02 * ski wondered about exactly that
12:49:05 <ezyang> ski: "xyxyx"
12:49:21 <ezyang> I'm using Python as the reference implementation
12:49:33 <erikc> wooop woop, http://blog.fac9.com/index.php/2009/08/30/building-a-64-bit-emacs-on-snow-leopard/
12:49:38 <copumpkin> I'm sure coming up with precise semantics is unpythonic :P
12:49:39 <erikc> got it working last night
12:49:43 <ezyang> snerk :-)
12:49:44 <ski> is Python's ABI there fully specified
12:49:45 <ski> ?
12:50:18 <erikc> hrm...now is it worth trying 64-bit ghc bootstrap...
12:51:28 <ezyang> Is there an idiom for having multiple ways of producing a result, and taking the first one if it works, and the second one if it didn't, etc?
12:51:51 <Lemmih> ezyang: msum ?
12:52:15 <ezyang> I dunno. Is that a MonadPlus thing?
12:52:18 <copumpkin> erikc: YES!
12:52:26 <ski> ezyang : yes
12:52:31 <copumpkin> erikc: but you might want to read my ghc ticket before starting :P
12:52:40 <erikc> what was the link again?
12:52:41 <ezyang> > msum [Nothing, Just 2, Just 3]
12:52:42 <lambdabot>   Just 2
12:52:48 <ezyang> Excellent, exactly what I need
12:53:08 <erikc> i dont know why i find the spelunking of software porting enjoyable
12:53:22 <Stinger> because you are a sick sick man
12:53:29 <copumpkin> erikc: I normally don't, but I really want a 64-bit ghc :P
12:55:01 <copumpkin> erikc: http://hackage.haskell.org/trac/ghc/ticket/3472
12:57:48 * ksf has a 64-bit ghc
13:03:03 <ezyang> Is maybeRead x `mplus` parseAbbr x clearer than msum $ [maybeRead x, parseAbbr x]? Should I write it in a different way?
13:04:31 * ski thinks the former is clearer
13:05:15 <ezyang> cool
13:05:22 <ksf> @src msum
13:05:22 <lambdabot> msum =  foldr mplus mzero
13:05:26 <GrendelBeowulf> Hello, whenever I use filter testFib [n | n <- [0..100]], I get a non-terminating list.
13:05:36 <GrendelBeowulf> (definition for testFib): http://pastebin.com/d20286f7a
13:05:47 <GrendelBeowulf> What is wrong with the function definition?
13:05:55 <ksf> it's awfully similar to mconcat, btw.
13:05:59 <ksf> @src mconcat
13:06:00 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:06:09 <shachaf> What do you mean, non-terminating?
13:06:17 <ksf> ... mconcat = foldr mappend mempty
13:06:22 <GrendelBeowulf> This is the result: [0,1,2,3,5,8,13,21
13:06:31 <GrendelBeowulf> And it doesn't advance...
13:06:38 <shachaf> GrendelBeowulf: Ah.
13:06:50 <shachaf> GrendelBeowulf: It's probably because that's written horribly inefficiently.
13:06:51 <Lemmih> GrendelBeowulf: Just wait a few years.
13:07:00 <ksf> let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
13:07:03 <Lemmih> GrendelBeowulf: It'll get there eventually.
13:07:03 <ksf> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
13:07:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:07:15 <ski>       | otherwise = if (n == fib m) then True else testFib' n (m + 1)
13:07:19 <ski> can be written as
13:07:33 <ski>       | otherwise = n == fib m || testFib' n (m + 1)
13:08:01 <ezyang> I'm pretty sure I can write this better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8848#a8848
13:08:05 <ksf> GrendelBeowulf, you're suffering from http://en.wikipedia.org/wiki/Dynamic_programming#Fibonacci_sequence
13:08:09 <ezyang> not sure how, though
13:08:26 <RayNbow> hmm... first loli, then maid... and now there's a moe package on hackage...
13:08:29 <shachaf> > fix((1:).scanl(+)1)
13:08:31 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
13:08:31 * RayNbow wonders what's next...
13:08:44 <Botje> ezyang: lookup?
13:08:46 <etpace_> i still don't understand that one shachaf
13:08:48 <GrendelBeowulf> I didn't know it was O(2^n)
13:09:05 <mauke> RayNbow: futa
13:09:19 <ezyang> Botje: possibly... I don't think there are enough matches to necessitate that yet?
13:09:51 <Botje> why not?
13:09:53 <ksf> etpace_, that might be because fix is ungrokkable in finite time.
13:09:59 <Botje> Data.List.lookup with a short list
13:10:04 <ezyang> Botje: only four...
13:10:08 <shachaf> ksf: No need for fix.
13:10:09 <shachaf> > let fibs = 1 : scanl (+) 1 fibs in fibs
13:10:09 <RayNbow> mauke: hmm, that's possibility
13:10:10 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
13:10:12 <shachaf> @src scanl
13:10:13 <lambdabot> scanl f q ls = q : case ls of
13:10:13 <lambdabot>     []   -> []
13:10:13 <lambdabot>     x:xs -> scanl f (f q x) xs
13:10:21 <glguy> Awesome, the email address listed on hackage for the tensor package doesn't accept emails from people not registered to it (it is a mailing list)
13:10:23 <Botje> and if it returns Nothing, you can do the other bit
13:10:32 <glguy> This is a great way to avoid bug reports
13:10:43 <ezyang> Hmmm
13:10:49 <ezyang> Oh yeah, that does help a bit
13:10:58 <Botje> ezyang: although i doubt the last case will ever be triggered
13:11:01 <ksf> scanl is rather execotic by comparison to zipWith, too.
13:11:20 <Botje> because if the maybeRead succeeds there, it should've succeeded in the call to `mplus` as well
13:11:22 <shachaf> > scanl f z [a,b,c]
13:11:24 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
13:11:59 <ezyang> Botje: oh ho ho, there's the clever bit: the first maybeRead is done for type Affiliation; the second maybeRead is done for Integer :-)
13:12:00 <ksf> scanl f xs = zipWith f xs (tail xs)
13:12:06 <glguy> In the spirit of ever more restrictive checks performed by hackage, testing that the maintainer email address is alive should be included :)
13:12:17 <Botje> ezyang: ah. okay :)
13:12:18 <GrendelBeowulf> Sorry for being a naive imperative programmer. :P
13:12:21 <ksf> wait.
13:12:29 <shachaf> ksf: Um, it is?
13:12:49 <ezyang> Botje: Hopefully not too clever for my own good :-)
13:12:49 <ksf> no, I shouldn't try to do that, now, I'd have to swap my state.
13:13:08 <Botje> couldn't have guessed that without a definition for Affiliation :p
13:14:46 <ezyang> I want a function with signature a -> [a -> b] -> b
13:15:06 <ksf> :t <*>
13:15:07 <lambdabot> parse error on input `<*>'
13:15:08 <ezyang> but I can't find it on Hoogle
13:15:13 <ksf> :t (<*>)
13:15:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:15:14 <mauke> ezyang: that type doesn't make sense
13:15:15 <Botje> why a list of functions?
13:15:23 <ezyang> oh... it doesn't
13:15:37 <ezyang> I actually want a -> [a -> b] -> [b]
13:15:47 <RayNbow> flip sequence?
13:15:47 <mauke> sequence
13:15:51 <ezyang> :t sequence
13:15:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:16:01 <ksf> :t flip (<*>) :: a -> [a -> b] -> [b]
13:16:03 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
13:16:03 <lambdabot>     In the expression: flip (<*>) :: a -> [a -> b] -> [b]
13:16:05 <RayNbow> > sequence [(*4), (+2)] 3
13:16:07 <lambdabot>   [12,5]
13:16:08 <mauke> :t flip sequence
13:16:09 <lambdabot> forall b a. b -> [b -> a] -> [a]
13:16:11 <ksf> :t (flip (<*>)) :: a -> [a -> b] -> [b]
13:16:13 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
13:16:13 <lambdabot>     In the expression: (flip (<*>)) :: a -> [a -> b] -> [b]
13:16:13 <RayNbow> > flip sequence 3 [(*4), (+2)]
13:16:14 <lambdabot>   [12,5]
13:16:30 <dschoepe> > map ($3) [(+1),(+3)]
13:16:32 <lambdabot>   [4,6]
13:16:40 <ezyang> Oh, clever clever, we're using the reader monad
13:16:46 <RayNbow> yes
13:16:57 <ksf> :t (flip (<*>) . pure) :: a -> [a -> b] -> [b]
13:16:58 <lambdabot> forall a b. a -> [a -> b] -> [b]
13:17:10 <copumpkin> erikc: did that bug report change your mind about porting it?
13:17:16 * copumpkin hopes not :P
13:17:40 <ezyang> What's the difference between mconcat and msum?
13:17:42 <erikc> hehe
13:17:50 <Taejo> :t let aplist x = map ($ x) in aplist
13:17:51 <lambdabot> forall a b. a -> [a -> b] -> [b]
13:17:53 <ksf> ezyang, the typeclass.
13:17:54 <erikc> it reminded me what a nightmare porting ghc is :)
13:18:14 <ksf> one uses mplus and mzero, the other mappend and mempty.
13:18:17 <ezyang> Suppose I have a type that implements both Monoid and MonadPlus. Should I prefer one over the other?
13:18:26 <copumpkin> > mconcat [Just (Sum 5), Just (Sum 7)]
13:18:27 <lambdabot>   Just (Sum {getSum = 12})
13:18:31 <copumpkin> > msum [Just (Sum 5), Just (Sum 7)]
13:18:32 <lambdabot>   Just (Sum {getSum = 5})
13:18:34 <copumpkin> :)
13:18:42 <erikc> and why if i was implementing a language i'd implement it in C :)
13:18:46 <ksf> @src MonadPlus
13:18:46 <ezyang> whoa
13:18:46 <lambdabot> Source not found. :(
13:18:56 <dschoepe> ezyang: the typeclasses would require different kinds.
13:19:01 <copumpkin> ezyang: Monoid is "deeper" than MonadPlus
13:19:14 <ezyang> ok...
13:19:20 <copumpkin> > mconcat [Just (Sum 5), Just (Sum 7), Nothing]
13:19:21 <lambdabot>   Just (Sum {getSum = 12})
13:19:27 <copumpkin> > msum [Just (Sum 5), Just (Sum 7), Nothing]
13:19:28 <lambdabot>   Just (Sum {getSum = 5})
13:19:33 <ezyang> I guess I want to know what the kinds of Monoid and MonadPlus are
13:19:33 <ksf> you should use mconcat, as that's a class method and thus could be specialized.
13:19:45 <dschoepe> :k Maybe
13:19:47 <lambdabot> * -> *
13:19:47 <dschoepe> :k Endo
13:19:49 <lambdabot> * -> *
13:19:49 <copumpkin> MonadPlus is like Monad, so it wants a * -> *
13:19:53 <copumpkin> Monoid wants a *
13:20:06 <ezyang> ksf: Really?
13:20:30 <copumpkin> well, they often don't do the same thing
13:20:36 <ezyang> ksf: This is still in the context of "I have multiple ways of computing a result, and want to grab the first one"
13:20:38 <copumpkin> > msum [Just 6, Just 5, Nothing]
13:20:39 <lambdabot>   Just 6
13:20:43 <copumpkin> > mconcat [Just 6, Just 5, Nothing]
13:20:45 <lambdabot>   Add a type signature
13:21:12 <copumpkin> the MonadPlus instance doesn't even bother (it actually _can't_) look inside the Maybe
13:21:17 <ksf> ...well if they don't do the same thing, you don't have the burden of choice.
13:21:21 <copumpkin> the Monoid does, and requires it to be a Monoid instance too
13:21:57 <copumpkin> of course this isn't only true of Maybe
13:21:59 <ezyang> Ok.
13:22:14 <ezyang> Btw, (->) doesn't seem to have a Monad instance associated with it by default
13:22:25 <copumpkin> Control.Monad.Instances
13:22:29 <copumpkin> and it's ((->) a)
13:22:30 <ezyang> Excellent, thank you
13:22:36 <ezyang> copumpkin: Righto :-)
13:22:45 <copumpkin> (but I agree, it's a pain to type that out :P)
13:22:55 <ksf> haskell is failing to avoid success, there.
13:23:19 <ksf> not providing excessive ((->) a) instances is too easy on newbies.
13:23:27 <copumpkin> lol
13:23:45 <Berengal> Same for monad compositions
13:23:54 <Berengal> comprehensions*
13:24:20 <Berengal> And where's the compulsory unicode?
13:24:36 <ksf> what about making ghc spew out "Trivial type error at line foo. I can't be bothered, figure it out by yourself"?
13:24:37 <ezyang> Berengal: Agreed. Lack of compulsory unicode is just bleagh
13:24:47 <copumpkin> erikc: I'll be happy to help you out, as I've tried (and failed) many times :P but then again, due to said failure, you may be better off without me
13:24:48 <ezyang> ksf: hahahaha
13:25:05 <Berengal> ksf, you want line numbers?! Module, at most...
13:25:12 <copumpkin> the most awesome compulsory unicode candidate doesn't even work in GHC :(
13:25:27 <mauke> (→) a
13:25:48 <copumpkin> that one's cute, but I want a damn lambda instead of the ugly \
13:26:04 <copumpkin> and UnicodeSyntax doesn't enable that because lambda's a letter
13:26:14 <ray> lambda should be special-cased
13:26:21 <copumpkin> it should!
13:26:25 <mauke> copumpkin: ew, lambda is ugl
13:26:26 <ray> let the greeks whine
13:26:32 <copumpkin> mauke: :(
13:26:34 <Berengal> Indeed, lambda /is/ a letter so why \ ?
13:26:36 <ksf> aren't there more than one lambdas in unicode?
13:26:36 <copumpkin> mauke: but \ is ugly!
13:26:37 <ray> well, unicode should really have a MATHEMATICAL SYMBOL LAMBDA
13:26:40 <mauke> copumpkin: no
13:26:44 <copumpkin> ksf: nope :/
13:26:48 <copumpkin> mauke: :(
13:26:51 <matsuura> ray: it does
13:26:53 <matsuura> o_o
13:26:59 <copumpkin> matsuura: not that I know of
13:27:02 <ray> what code point is it at then
13:27:09 <ray> private use doesn't count
13:27:18 <ray> even though i don't think there's any there either
13:27:29 <copumpkin> well there could be if we defined there to be :P
13:27:33 <copumpkin> (kinda by definition)
13:27:39 <mauke> U+1038D (f0 90 8e 8d): UGARITIC LETTER LAMDA [𐎍]; U+039B (ce 9b): GREEK CAPITAL LETTER LAMDA [Λ]; U+03BB (ce bb): GREEK SMALL LETTER LAMDA [λ]; U+1D6B2 (f0 9d 9a b2): MATHEMATICAL BOLD CAPITAL LAMDA [𝚲]; U+1D6CC (f0 9d 9b 8c): MATHEMATICAL BOLD SMALL LAMDA [𝛌]; U+1D6EC (f0 9d 9b ac): MATHEMATICAL ITALIC CAPITAL LAMDA [𝛬]; U+1D706 (f0 9d 9c 86): MATHEMATICAL ITALIC SMALL LAMDA [𝜆]; U+1D27 (e1 b4 a7): GREEK LETTER SMALL CAPITAL
13:27:46 <mauke>  LAMDA [ᴧ]; U+1D726 (f0 9d 9c a6): MATHEMATICAL BOLD ITALIC CAPITAL LAMDA [𝜦]; U+1D740 (f0 9d 9d 80): MATHEMATICAL BOLD ITALIC SMALL LAMDA [𝝀]; U+1D760 (f0 9d 9d a0): MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA [𝝠]; U+1D77A (f0 9d 9d ba): MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA [𝝺]; U+1D79A (f0 9d 9e 9a): MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA [𝞚]; U+1D7B4 (f0 9d 9e b4): MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL
13:27:46 <ksf> \ read as "escape" works, too.
13:27:52 <mauke>  LAMDA [𝞴]
13:27:52 <dschoepe> What about having your editor pretty print \ as lambda in the appropriate cases?
13:28:02 <copumpkin> mauke: :o
13:28:04 <ray> editor pretty printing sucks
13:28:08 <ray> LAMDA, nice
13:28:12 <Knight_Lord> Hi. Can anyone please tell me why my code is wrong? http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3459#a3459
13:28:22 <Knight_Lord> The error is Couldn't match expected type `()' against inferred type `IO ()'
13:28:37 <copumpkin> nice, pity none of my fonts support it though :(
13:28:44 <mauke> Knight_Lord: what's the type of playMove?
13:28:46 <Knight_Lord> I also tries using return (case ...) but i couldn't manage to get it to work also
13:28:48 <matsuura> λλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλλ
13:28:50 <idnar> MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA --- seriously?!
13:28:56 <shachaf> mauke: 019B LATIN SMALL LETTER LAMBDA WITH STROKE [ƛ]
13:28:58 <Knight_Lord> mauke: playMove::Board -> IO ()
13:28:58 <iago> Knight_Lord, what is the type of playMove
13:29:02 <copumpkin> idnar: sometimes you gotta be specific ;)
13:29:04 <ksf> ...I bet winner is Board -> IO (Something)
13:29:09 <ray> so are there any that unicode doesn't define as a letter?
13:29:17 <ray> that's the big thing for the grammar here
13:29:26 <matsuura> ?
13:29:37 <ksf> you have to use <- or >>= to get the something out of there.
13:29:49 <Knight_Lord> playMove also prints some stuff that's why i thought it should be Board -> IO()
13:30:10 <iago> Knight_Lord, maybe the problem is in playMove
13:30:15 <mauke> Knight_Lord: what's the complete error message?
13:30:51 <Knight_Lord> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3459#a3460
13:30:52 <ray> matsuura: unicode has character properties like "this is a letter" or "this is punctuation" or "this is upper case"
13:31:22 <mauke> Knight_Lord: the error message doesn't match the code you pasted
13:31:38 <Knight_Lord> mauke: why not?
13:31:40 <ray> to make the grammar happy, we want a lambda that isn't a letter
13:31:44 <ksf> the "return" doesn't fit there.
13:31:48 <mauke> Knight_Lord: because 'return $'
13:31:49 <copumpkin> http://www-users.math.umd.edu/~joepi/hosting/ruppages/rings.html
13:31:51 <matsuura> ray: oh, gotcha
13:31:53 <ksf> :t return
13:31:55 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:32:07 <matsuura> ray: I believe unicode carries them all
13:32:09 <Knight_Lord> you are absolutely right
13:32:09 <matsuura> o_o
13:32:10 <ksf> you don't want to nest your IO action.
13:32:28 <Knight_Lord> It now compiles
13:32:35 <matsuura> ray: thought you were somehow talking about grammar rules, which wouldnt make snese
13:32:36 <Knight_Lord> I don't know what i did though
13:32:36 <ksf> (note that "return" is just a badly-named function, not a keyword)
13:33:05 <Knight_Lord> Thanks for the help, i'll try to be more careful next time
13:33:24 <Knight_Lord> ksf: why not to nest IO?
13:33:38 <copumpkin> matsuura: he's talking about the lexer deciding what to do based on whether the current unicode char is a letter or not
13:33:46 <Knight_Lord> ksf: I did it because my playGame function was getting really large
13:33:46 <ksf> ...because main has type IO ().
13:33:54 <copumpkin> matsuura: so if there are lambdas that are not letters, it'll be easier to use them as syntax elements
13:33:55 <ray> yes, i suppose it's technically lexing
13:34:00 <ksf> that's why the types didn't match.
13:34:46 <ray> and yeah, if you produce a lambda in unicode that isn't a letter, i'll submit a ghc bug or whatever
13:35:08 <ksf> you want to do things like "return 4 >>= print" to print a 4, but not "return (getLine) >>= print", that won't work.
13:35:17 <ray> you can also get them to add one, if you have any pull
13:35:33 <ksf> :t return 4
13:35:34 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
13:35:43 <ksf> :t return 4 :: IO Int
13:35:44 <lambdabot> IO Int
13:35:45 <matsuura> copumpkin: ?
13:35:46 <BMeph> Knight_Lord: "> ksf: why not to nest IO?" Because it 1) Makes things more complicated than you need; 2) Because it likely makes things more complicated than you can handle 3) Because it gives you no benefits.
13:35:55 <ksf> :t return getLine
13:35:55 <matsuura> copumpkin: I wouldn't really call them letters >_>
13:35:56 <lambdabot> forall (m :: * -> *). (Monad m) => m (IO String)
13:35:57 <matsuura> more characters
13:36:03 <ksf> :t return getLine :: IO (IO ())
13:36:04 <lambdabot>     Couldn't match expected type `()' against inferred type `[Char]'
13:36:04 <lambdabot>       Expected type: IO ()
13:36:04 <lambdabot>       Inferred type: IO String
13:36:10 <ksf> :t return getLine :: IO (IO Char)
13:36:12 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
13:36:12 <lambdabot>       Expected type: IO Char
13:36:12 <lambdabot>       Inferred type: IO String
13:36:13 <copumpkin> matsuura: then complain to the unicode consortium ;)
13:36:13 <Knight_Lord> BMeph: but if i don't i get a huge if else function
13:36:15 <ksf> :t return getLine :: IO (IO String)
13:36:17 <lambdabot> IO (IO String)
13:36:17 <ksf> ...
13:36:38 <Knight_Lord> BMeph: doing all the IO in just one function seem a bit limiting
13:36:50 <ksf> :t join $ return getLine :: IO String
13:36:51 <lambdabot> IO String
13:37:02 <matsuura> copumpkin: what?... who's complaining? O_o
13:37:16 <ksf> Knight_Lord, that's not what I meant by "no nesting"
13:37:30 <matsuura> copumpkin: you wouldn't call a kanji a letter, so why call lambda one? >_>
13:37:33 <Knight_Lord> ksf: what do you mean by nesting then?
13:37:44 <copumpkin> :t isLetter
13:37:45 <lambdabot> Char -> Bool
13:37:47 <ksf> ...you just want to have your other function have type IO Something, not IO (IO Something)
13:37:57 <copumpkin> > isLetter('肛')
13:37:58 <lambdabot>   True
13:38:06 <Knight_Lord> ksf: Ah yes of course
13:38:07 <ksf> ...nesting an IO inside an IO.
13:38:20 <Knight_Lord> ksf: ok i understand what you mean now
13:38:25 <BMeph> Knight_Lord: If you "get a huge if else function", then I dare say "UR DOIN IT RONG". :)
13:38:37 <ray> > isLetter '零'
13:38:39 <lambdabot>   True
13:38:41 * ray ahems at copumpkin
13:38:42 <ksf> :t join . return
13:38:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
13:38:51 <copumpkin> Letter. (1) An element of an alphabet. In a broad sense, it includes elements of syllabaries and ideographs. (2) Informative property of characters that are used to write words.
13:38:54 <copumpkin> http://www.unicode.org/glossary/#L
13:39:04 <ksf> ...in other words join . return == id
13:39:10 <copumpkin> I don't necessarily agree with it, but that's what they define it as
13:39:12 <matsuura> > isLetter '4'
13:39:13 <lambdabot>   False
13:39:20 <matsuura> bull....
13:39:29 <ray> copumpkin has forgotten his haskell syntax
13:39:38 <copumpkin> > isLetter '四'
13:39:39 <lambdabot>   True
13:39:42 <copumpkin> yeah, not sure why I wrote that
13:39:52 <ray> i don't see you flagellating yourself
13:40:08 * copumpkin pulls out his cat o' nine tails
13:40:08 <matsuura> h4v3n'7 y0u s3e|\| 7h3s# 7yp3z 0f l37t312z?
13:40:11 <matsuura> :(
13:40:11 <mauke> > isLetter 'ᴀ'
13:40:13 <lambdabot>   True
13:40:24 <ray> > all isLetter "四つ巴"
13:40:25 <lambdabot>   True
13:40:32 <matsuura> it's clear that those are not letters :(
13:40:36 <copumpkin> > map isLetter "ぁぃぅぇぉ"
13:40:37 <ezyang> Ok, I'm about to write a simple read/show persistence mechanism. Is there a less braindead way to do this than writing/reading imperatively from IO?
13:40:37 <lambdabot>   [True,True,True,True,True]
13:40:48 <ezyang> matsuura: Depends on who you ask
13:40:48 <copumpkin> matsuura: then complain to unicode :)
13:41:01 <ezyang> (see Unicode character classes)
13:41:02 <copumpkin> matsuura: unicode specifies classes for every code point
13:41:03 <matsuura> copumpkin: why would I want to waste my time doing that?
13:41:06 <mauke> #Hᴀsᴋᴇʟʟ
13:41:23 <matsuura> copumpkin: what is a character in unicode then? >_>
13:41:32 <ray> > map toLowerCase "#Hᴀsᴋᴇʟʟ"
13:41:33 <lambdabot>   Not in scope: `toLowerCase'
13:41:39 <copumpkin> http://www.unicode.org/versions/Unicode5.0.0/ch04.pdf
13:41:51 <ksf> ezyang, macid?
13:41:51 <ezyang> like, would I able to do some sort of scoped thing where my final value gets automatically written to the file?
13:41:53 <mauke> s/Case//
13:41:55 <ray> matsuura: i would like to respectfully suggest you read unicode.org instead of being confused with cute emoticons
13:41:57 <ksf> ezyang, binary?
13:42:01 <copumpkin> Character. (1) The smallest component of written language that has semantic value; refers to the abstract meaning and/or shape, rather than a specific shape (see also glyph), though in code tables some form of visual representation is essential for the reader’s understanding. (2) Synonym for abstract character. (3) The basic unit of encoding for the Unicode character encoding. (4) The English name for the ideographic written elements of Chinese origi
13:42:03 <ray> > map toLower "#Hᴀsᴋᴇʟʟ"
13:42:04 <matsuura> copumpkin: not interested in reading of it all... just want you to show me something that isn't a letter :p
13:42:04 <lambdabot>   "#h\7424s\7435\7431\671\671"
13:42:06 <ezyang> ksf: I decided that was overkill for now
13:42:09 <ksf> what kind of braindeadness are you worried about?
13:42:14 <ray> > show $ map toLower "#Hᴀsᴋᴇʟʟ"
13:42:16 <lambdabot>   "\"#h\\7424s\\7435\\7431\\671\\671\""
13:42:26 <ezyang> ksf: Like, forgetting to save the data after I'm done with it
13:42:28 <ray> i meant text
13:42:33 <ray> my head is spinning so fast
13:42:44 <ray> > isLetter '%'
13:42:44 <matsuura> ray: na, I know of unicode... the specifications just don't make sense from llanguage to language
13:42:45 <copumpkin> matsuura: lots of things aren't letters, you did something earlier
13:42:45 <lambdabot>   False
13:43:03 <copumpkin> > length . filter isLetter $ [minBound..maxBound]
13:43:04 <lambdabot>   93455
13:43:06 <ksf> ezyang, that sounds like macid, but then I'm not completely sure as I never used it.
13:43:11 <ksf> ...have a look at happstack.
13:43:12 <copumpkin> > length . filter (not . isLetter) $ [minBound..maxBound]
13:43:13 <lambdabot>   1020657
13:43:18 <matsuura> copumpkin: anything I type can be a character though, as well as a letter, apparently.. so whatisn't a letter?
13:43:24 <copumpkin> of course, most of those are undefined :P
13:43:31 <matsuura> :(
13:43:35 <ezyang> ksf: happstack was too complicated for the simple experiment I'm doing now
13:43:42 <copumpkin> > isLetter ' '
13:43:43 <lambdabot>   False
13:43:46 <copumpkin> > isLetter '6'
13:43:47 <lambdabot>   False
13:43:50 <ksf> it would ensure that every write to state is duplicated on disk.
13:43:52 <copumpkin> > isLetter '^'
13:43:53 <lambdabot>   False
13:43:57 <bos> oh my god, statistical programming in haskell is so much fun.
13:44:03 <copumpkin> bos: !
13:44:04 <matsuura> copumpkin: how about h31l0 ?
13:44:04 <ksf> well, macid isn't trivial.
13:44:07 <copumpkin> bos: whatcha doing?
13:44:10 <ray> > isLetter '⑨'
13:44:11 <lambdabot>   False
13:44:13 <ksf> ...and you don't need the rest of happstack to use it.
13:44:19 <ezyang> ok
13:44:35 <ezyang> Also, macid is impossible to google for
13:44:36 <bos> copumpkin: estimating the bandwidth of a sample so that i can compute its kernel density function
13:44:40 <copumpkin> :o
13:44:45 <matsuura> anyhow.. going to mountains.. bbl :D
13:44:56 <ray> > isLetter '山'
13:44:57 <lambdabot>   True
13:45:00 <copumpkin> matsuura: are you japanese?
13:45:21 <ksf> http://tutorial.happstack.com/tutorial/introductiontomacid
13:45:24 <ray> > text $ map toLower "#Hᴀsᴋᴇʟʟ"
13:45:25 <lambdabot>   #hᴀsᴋᴇʟʟ
13:45:28 <matsuura> copumpkin: japanese-american
13:45:36 <copumpkin> matsuura: aha :)
13:45:37 <Berengal> @hackage happstack-state
13:45:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happstack-state
13:45:38 <ray> hASKELL
13:45:43 <matsuura> copumpkin: why do you ask?
13:45:54 <brad_larsen> engineering question:  what's the best way to package tests with a module?
13:46:00 <copumpkin> matsuura sounds japanese, umeii, kinjirareta :P
13:46:02 <brad_larsen> (quickcheck tests, in particular)
13:46:18 <ezyang> Does lambdabot use Happstack.State?
13:46:21 <copumpkin> but you didn't react to my odd choice of kanji earlier, either
13:46:24 <pr> hajimemashite@
13:46:25 <pr> !
13:46:31 <pr> watashi wa pr desu
13:46:35 <pr> or something like that 8)
13:46:49 <matsuura> lol
13:46:54 <matsuura> copumpkin: >_>
13:46:58 <copumpkin> <_<
13:46:59 <mauke> ww
13:47:02 <ray> > toUpper 'ß'
13:47:04 <lambdabot>   '\223'
13:47:05 <brad_larsen> putting them in-line with the code clutters the module, some, but often the tests require access to a module's internals
13:47:06 <matsuura> copumpkin: are you japanese?
13:47:11 <copumpkin> matsuura: nope!
13:47:13 <ray> > show $ toUpper 'ß'
13:47:14 <lambdabot>   "'\\223'"
13:47:15 <pr> > chr 223
13:47:16 <lambdabot>   '\223'
13:47:17 <matsuura> copumpkin: oh, okay..
13:47:19 <ray> there i go again
13:47:23 <ray> > text $ toUpper 'ß'
13:47:24 <lambdabot>   Couldn't match expected type `GHC.Base.String'
13:47:27 <bos> this is the bandwidth estimation code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8849#a8849
13:47:27 <copumpkin> aw
13:47:31 <brad_larsen> so putting tests in a separate module gets awkward
13:47:32 <desu> D:?
13:47:36 <ksf> especiall http://tutorial.happstack.com/src/FirstMacid.hs
13:47:38 <pr> > text [toUpper 'ß']
13:47:38 <ray> :t toUpper
13:47:40 <lambdabot>   ß
13:47:40 <lambdabot> Char -> Char
13:47:42 <copumpkin> desu: nee!
13:47:48 <ksf> lambdabot doesn't use macid.
13:47:56 <copumpkin> matsuura: enjoy the mountains!
13:47:57 <ray> toUpper ß is supposed to be SS
13:47:58 <brad_larsen> doctest-like tools for haskell, anyone?
13:47:59 <desu> inai.
13:48:03 <ezyang> ok
13:48:06 <ksf> otherwise, it wouldn't forget to forget that it already delivered @args
13:48:08 <copumpkin> desu: naze?
13:48:14 <ksf> erm @ask
13:48:23 <ezyang> @help ask
13:48:24 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
13:48:29 <ezyang> nice
13:48:32 <ray> Char -> Char is obviously the most useful type
13:48:33 <bos> ray: to get a capital eszett, you have to use the Data.Text library (text package)
13:48:43 <pr> HASKELL UBER ALLES
13:48:48 <ray> i don't want a capital eszett, i want SS
13:48:53 <ksf> fuck firefox is blocking xmonad, and I managed to get it out of focus.
13:48:55 <mauke> NAZI
13:48:55 <ezyang> Ok. I'll waddle around the docs to see if I can cook something up
13:48:57 <bos> ray: text does the right thing
13:48:57 <ray> unless that's what you mean
13:49:00 <copumpkin> mauke: !
13:49:08 <Makoryu> @hoogle Char -> Char
13:49:08 <lambdabot> Data.Char toLower :: Char -> Char
13:49:09 <lambdabot> Data.Char toTitle :: Char -> Char
13:49:09 <lambdabot> Data.Char toUpper :: Char -> Char
13:49:09 <pr> the capital eszett is not part of the german language
13:49:09 <ray> there's this capital ß character floating around
13:49:15 <bos> i.e. length of a capitalized string may be longer
13:49:16 <mauke> pr: it is now!
13:49:21 <pr> it's not mauke
13:49:25 <ezyang> cyall
13:49:26 <bos> pr: there is now a capital eszett, just nobody uses it.
13:49:30 <ray> i wasn't sure if you meant that or not
13:49:35 <pr> there is, and still it's not part of the german language
13:49:49 <bos> ray: text follows the unicode rules, which do not yet use capital eszett.
13:49:50 * copumpkin petitions Cale and mmorrow to add Data.Text to their bots
13:50:01 <bos> copumpkin: it's not fully cooked yet!
13:50:08 * copumpkin likes his libraries rare
13:50:12 <ray> bos: and never should
13:50:21 <tibbe> bos: how's the Int -> Text redesign going?
13:50:23 <ray> the germans would explode if it ever did
13:50:28 <bos> tibbe: going well.
13:50:36 <tibbe> bos: any new ideas?
13:51:23 <bos> tibbe: not just yet. i'm writing a benchmarking library to be sure the code performs well.
13:51:31 <tibbe> bos: great
13:51:38 <bos> which means i'm writing a statistical library to be sure the benchmarking library performs well.
13:51:41 <bos> lots of yak shaving.
13:51:46 <copumpkin> bos: :o
13:51:54 <bos> hence my sudden obsession with statistics.
13:52:03 * tibbe doesn't yet know how to do micro benchmarks in Haskell properly
13:52:10 * bos is working on that.
13:52:16 <copumpkin> bos: call it quickbench and structure it like quickcheck :P like the library I wrote most of and then lost interest in :P
13:52:35 <copumpkin> seems like it'd be neat to have such a thing
13:52:41 <copumpkin> but I didn't want to shave all that yak
13:52:46 <bos> yes, it would. that's more or less what i'm doing.
13:52:47 <tibbe> bos: I wrote benchpress but it only works on monadic (read: IO) actions with a longer running time
13:52:58 <ksf> HOW CAN A MUCH-USED PROGRAM LIKE FIREFOX POSSIBLY MESS UP X THAT BADLY?
13:53:06 <ben> re: System.Console.ANSI, how do I achieve the 'gray' text color as in xterm -fg gray?
13:53:07 <tibbe> bos: but for pure, fast functions I don't know how to do it
13:53:09 * bos computes the needed runtime to get good measurements experimentally.
13:53:11 <ksf> I FEEL THE URGE TO SHOUT AT SOMEONE
13:53:21 <copumpkin> tibbe: my idea was to do something like quickcheck and (with some strategy) sample the input space and run a bunch of tests, to get a feel for its behavior over multiple inputs
13:53:26 <Jedai> tibbe: I wrote something to make benchpress work (more or less) with pure function
13:53:27 <tibbe> bos: There's a Python library that does that
13:53:31 <bos> copumpkin: precisely.
13:53:32 <copumpkin> bos: cool, yeah, that's what I was doing
13:53:46 * copumpkin rubs his hands in glee
13:53:49 <tibbe> Jedai: using NFData or something?
13:53:51 <copumpkin> I can't wait to see what you come up with :)
13:53:57 <bos> tibbe: for instance, i can tell you that "\() -> 1" takes about 900 picoseconds to run.
13:53:58 <ray> bos: hmm, unicode normalization forms would be cool
13:54:12 <Jedai> tibbe: Yes, among other thing (evaluate, -O0...)
13:54:15 <bos> ray: patches welcome. unicode normalization is a total nightmare.
13:54:17 <ray> ksf: it's open soucre
13:54:42 <tibbe> bos: how do you repeatedly evaluate a pure expression and 1) avoid sharing and hence force recomputation and 2) make sure everything that needs to get evaluated is?
13:54:43 <ray> source
13:55:05 <bos> tibbe: pure expressions have to be of the type \() -> a
13:55:16 <Jedai> tibbe: it's nowhere close to an universal and reliable solution but it seems to give quite reasonable results
13:55:20 <bos> that avoids the thunking problem.
13:55:22 <tibbe> bos: ok, and that adds 900 picoseconds?
13:55:30 <bos> tibbe: yeah.
13:55:30 <tibbe> Jedai: cool
13:55:56 <bos> > trace "foo" 1
13:55:57 <lambdabot>   Not in scope: `trace'
13:56:00 <bos> bah.
13:56:03 <copumpkin> bos: I remember doing existentials also prevented the compiler from caching the result, I think
13:56:10 <tibbe> bos: so anything under 1 ns is not measurable?
13:56:13 <copumpkin> or something like that
13:56:14 * tibbe wonders if that matters
13:56:48 <ksf> you don't want to rely on 1ns-granularity, anyway.
13:56:54 <bos> tibbe: if it doesn't run for long, i just run it a lot in a loop and divide the time by the number of loops.
13:57:01 <ksf> ...you're going to measure OS jitter, that way.
13:57:07 <Makoryu> :t (&)
13:57:08 <lambdabot> Not in scope: `&'
13:57:16 <tibbe> bos: but each time you apply () to the thunk right?
13:57:23 <ksf> if you can't produce a repeatable difference of 10ms, consider two times to be equal.
13:57:24 <copumpkin> > let (&) = (*) in 1 & 1
13:57:25 <lambdabot>   1
13:57:33 <Jedai> Makoryu: what are you searching for ?
13:57:50 <bos> so e.g. \() -> 1 is run 50377992 times
13:57:52 <Makoryu> Jedai: Unused operators
13:57:55 <Jedai> Makoryu: (&&) is the boolean and and (.&.) is bit to bit one
13:58:01 <Makoryu> Jedai: Yup
13:58:13 <bos> tibbe: yeah, there's no easy way to avoid that.
13:58:27 <tibbe> bos: I was thinking that if e.g. measuring lookup in an array each lookup is quite fast
13:58:49 <Jedai> Makoryu: Well (&) doesn't seem to be used anywhere I can think of
13:58:49 <bos> tibbe: right, so you just do it a lot and divide. you won't get a perfectly accurate answer.
13:58:52 <tibbe> bos: right, so you have the overhead of applying () and the overhead of the getTime calls
13:59:01 <tibbe> bos: good enough I guess :)
13:59:12 <tibbe> bos: although the getTime call gets lost when looping
13:59:14 <ksf> Makoryu, heresy! there are no unused operators in haskell with a length shorter than 16 characters!
13:59:27 <bos> so you can't really benchmark anything faster than \() -> 1 for obvious reasons.
13:59:35 <tibbe> bos: can't Haskell share the result of f () ?
13:59:40 <Makoryu> ksf: NO $^&#**$^#*$#&@<>@# U
13:59:45 <bos> tibbe: only if you bind it to a name.
13:59:57 <tibbe> bos: just like it could share 1 + 1?
14:00:07 <mauke> it doesn't share 1 + 1
14:00:18 <bos> right. it'll share x in (let x = 1 + 1 in (x,x))
14:00:20 <tibbe> mauke: but is it allowed too?
14:00:22 <tibbe> to
14:00:23 <ray> bos: yeah, i bet it is
14:00:24 <bos> but it won't share (1+1,1+1)
14:00:25 <mauke> yes
14:00:42 <bos> ghc aggressively doesn't do CSE.
14:00:49 <tibbe> mauke: so it's not guaranteed
14:01:04 <tibbe> bos: right, but I want to know when it does and screws up my benchmarks :)
14:01:39 <bos> tibbe: it doesn't as a matter of policy, though.
14:02:00 <copumpkin> @hoogle (IO a, IO b) -> IO (a, b)
14:02:00 <lambdabot> No results found
14:02:02 <tibbe> bos: ok, I guess that's the best we can do
14:02:03 <bos> tibbe: i'd be more worried about things like garbage collection and CPU powersaving and firefox and flashplayer screwing with benchmark timings :-)
14:02:11 <tibbe> bos: short of getting a NOCSE pragma
14:02:24 <bos> since those are much more predictably likely to mess things up.
14:02:26 <tibbe> bos: well true :) but I can turn those off
14:02:37 <mauke> :t uncurry (liftM2 (,))
14:02:38 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
14:02:43 <tibbe> bos: if I really needed
14:02:53 <copumpkin> :)
14:02:58 <tibbe> bos: I can't change haskell's semantics as easily
14:03:20 <bos> tibbe: you have to know they're affecting your runs before you can turn them off...
14:03:38 <tibbe> bos: true
14:03:42 <ksf> there's no cse. there's only let-floating.
14:03:59 <int-e> there's "opportunistic cse"
14:04:11 <tibbe> ksf: but there could be in theory, right?
14:04:25 <ksf> I'm no good at theory.
14:04:36 <ksf> It tends to diverge from practice if I do it.
14:04:41 <int-e> i.e. if there's f = <foo> and g = <foo> on the same level, ghc will combine them and treat f = g.
14:04:58 <mauke> tibbe: in theory longer programs could be faster
14:05:19 <mauke> but in general we assume a non-malicious compiler
14:05:23 <ksf> in practice, factoring cse's out by hand is good style.
14:05:27 <tibbe> mauke: perhaps I should have said: other compilers than GHC might do things differently
14:05:39 <tibbe> ksf: sure
14:06:07 <int-e> ksf: I agree fully. In fact there are cases where even that little bit of CSE is too much (luckily there's the -fno-cse option)
14:06:09 <ksf> which, due to laziness, is far less painfull than in other languages.
14:06:44 * tibbe should go to bed
14:06:55 * copumpkin sends tibbe off to bed with no supper
14:07:01 <tibbe> hah
14:07:07 <tibbe> I had supper before I got on the plane
14:07:23 <copumpkin> aw
14:07:29 * tibbe goes to bed
14:09:44 * ray sends copumpkin off to bed with supper
14:09:50 <ray> and you have to eat it all there
14:09:51 <copumpkin> :o
14:10:01 <ray> enjoy your bleaching
14:10:26 <Lycurgus> what is CSE?
14:10:46 <Lycurgus> continuation or closure something I presume
14:10:52 <copumpkin> common subexpression elimination
14:11:01 <Lycurgus> ah
14:11:46 <ski> computer science & engineering
14:11:47 <Lycurgus> which haskell would do if it did at a lexical level?
14:12:35 <Lycurgus> ski, yes that's what google indicates it is.
14:12:59 <ski> copumpkin's expansion is what was meant here, though
14:13:23 <Lycurgus> that and a bunch of other things that clearly had no relation to compiler optimization
14:13:55 <Knight_Lord> Can anyone explain me this error please? http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3461#a3461
14:14:23 <copumpkin> Knight_Lord: you wrote [x:xs] instead of (x:xs)
14:14:29 <ski> (Lycurgus : any of those being "Crinkly Stell Electrochemical" ?)
14:14:31 <copumpkin> that implies [[a]]
14:14:49 <Knight_Lord> copumpkin: ah, many thanks
14:14:52 <tromp> [x:xs] is a list whose single element is also a list
14:14:53 <Twey> (:) :: a -> [a] -> [a]
14:15:16 <pr> @djinn a -> [a] -> [a[]
14:15:16 <lambdabot> Cannot parse command
14:15:17 <pr> @djinn a -> [a] -> [a]
14:15:17 <lambdabot> Error: Undefined type []
14:15:20 <Makoryu> :t map (head . words) . filter ((> 0) . length) . lines <$> readFile ".deps"
14:15:21 <lambdabot> IO [String]
14:16:10 <copumpkin> :)
14:16:10 <copumpkin> :t \x xs -> [x:xs]
14:16:11 <lambdabot> forall a. a -> [a] -> [[a]]
14:16:18 <copumpkin> lol
14:16:19 <copumpkin> that was slow
14:20:15 <Knight_Lord> Are there any haskell debuggers?
14:21:00 <copumpkin> there's a debugger in ghci
14:21:05 <copumpkin> but it might take some getting used to :)
14:21:17 <Knight_Lord> that doesn't sound good
14:21:43 <copumpkin> Knight_Lord: haskell's model is very different from most languages you're probably used to debugging
14:22:03 <Knight_Lord> copumpkin: that's true
14:24:18 <Lycurgus> ski, no didn
14:24:24 <Lycurgus> 't see that
14:24:31 <lispy> Knight_Lord: Debug.Trace is a module you can import that provides functions to help debug
14:24:47 <lispy> Knight_Lord: but, they can be tricky to use because in some cases the change the behavior of your problem
14:24:51 <lispy> er program
14:25:18 <copumpkin> http://en.wikipedia.org/wiki/Observer_effect :P
14:25:36 <Lycurgus> langs with a radically different model of computation tend to introduced new models of debugging
14:26:02 <Lycurgus> introduce
14:26:14 <Lycurgus> models
14:26:31 <lispy> Knight_Lord: most importantly, we just get everything right on the first try so we never need to debug ;)
14:26:47 <Lycurgus> yes that is what I would presume for haskel
14:26:53 <Lycurgus> *haskell
14:27:21 <Lycurgus> all debugging is a matter of understanding the used packages/constructs
14:27:46 <lispy> Lycurgus: I'm teasing of course
14:27:52 <copumpkin> or just make sure your types encode all your semantics
14:27:57 <Lycurgus> (excluding syntax errors, typos, and the like)
14:28:00 <copumpkin> so the program won't compile unless it's correct
14:28:29 <copumpkin> @let graph f = id &&& f
14:28:30 <lambdabot>  Defined.
14:28:32 <copumpkin> @let cograph f = f ||| id
14:28:32 <lambdabot>  <local>:10:0:
14:28:32 <lambdabot>      Multiple declarations of `L.cograph'
14:28:32 <lambdabot>      Declared at: <l...
14:28:39 <copumpkin> :t cograph
14:28:39 <ski> buddha is bit-rotten, yes ?
14:28:40 <lambdabot> forall (ar :: * -> * -> *) a b. (ArrowChoice ar) => ar a b -> ar (Either a b) b
14:28:49 <copumpkin> buddha?
14:28:59 <ski> copumpkin : s/id/arr id/
14:29:29 <copumpkin> :t graph
14:29:30 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
14:29:48 <copumpkin> o.O
14:29:48 <copumpkin> :t graph
14:29:49 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
14:30:12 <copumpkin> damn :) good point
14:30:12 <copumpkin> @undef
14:30:12 <copumpkin> @let cograph f = f ||| arr id
14:30:12 <copumpkin> @let graph f = arr id &&& f
14:30:13 <lambdabot>  Defined.
14:30:13 <lambdabot>  Defined.
14:30:18 <copumpkin> :t graph
14:30:19 <lambdabot> forall (a :: * -> * -> *) b c'. (Arrow a) => a b c' -> a b (b, c')
14:31:18 <ski> copumpkin : a declarative debugger
14:31:43 <ski> @type graph
14:31:44 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
14:31:59 <Knight_Lord> My tictactoe with minimax for AI works! My first haskell program :)
14:32:40 <copumpkin> ski: ?
14:32:47 <copumpkin> Knight_Lord: yay!
14:32:53 <ski> buddha is a declarative debugger
14:32:56 <copumpkin> Knight_Lord: now add the zygohistormophic prepromorphism
14:32:59 <copumpkin> ski: oh I see
14:32:59 <BMeph> Buddha home: http://www.cs.mu.oz.au/~bjpop/buddha/
14:33:04 <ski> @where buddha
14:33:04 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
14:33:13 <copumpkin> who needs lambdabot when we have BMeph
14:33:19 * BMeph WIIIIIIIIIINS! ;)
14:33:28 <ski> BMeph> fix id
14:33:42 <copumpkin> BMeph: @pl (\x -> x x) (\x -> x x)
14:33:51 <Knight_Lord> copumpkin: i have no idea what a zygohistormophic prepromorphism is
14:33:53 <BMeph> copumpkin: Well, I need lambdabot
14:34:11 <copumpkin> BMeph: what for?
14:34:23 <BMeph> copumpkin: Thread killed
14:34:31 <BMeph> ski: You,  too. ;p
14:34:46 <copumpkin> BMeph: did you run it in a pm with lambdabot? :o
14:35:11 <BMeph> copumpkin: No; I have "omega" in cache. ;p
14:35:25 <copumpkin> BMeph: phew! cause she dies on that on
14:35:26 <copumpkin> e
14:35:28 <copumpkin> after much suffering
14:35:45 * ski wonders whether "pm" is the same as "tete-a-tete"
14:35:46 <BMeph> copumpkin: @more lines...
14:36:03 <copumpkin> ?
14:37:41 <BMeph> copumpkin: many lines, or just a silent rejection? :|
14:38:05 <copumpkin> BMeph: it'll give you an answer, say optimization suspended (and keep giving you the same result if you ask it to resume)
14:38:11 <copumpkin> and then eventually she will die
14:38:13 <copumpkin> the whole bot
14:38:23 <copumpkin> it's rather amusing, but a bit of a DOS too
14:38:35 <lispy> copumpkin: for which command?
14:38:39 <lispy> ?version
14:38:40 <lambdabot> lambdabot 4.2.2
14:38:40 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:38:48 <copumpkin> the one I asked BMeph to evaluate above
14:38:51 <Knight_Lord> My program is rather slow though. It takes about 30 second for the computer to make the first move
14:38:56 <copumpkin> :t join id
14:39:06 <Botje> Knight_Lord: start by compiling your code instead of running it in ghci :)
14:41:44 <Knight_Lord> Botje: good point :)
14:41:52 <copumpkin> with -O2
14:42:22 <BMeph> copumpkin: Another good point! :)
14:42:32 <Botje> ghc will secretly make all your algorithms an order of magnitude faster by replacing them with better ones, but shh.
14:43:34 * BMeph (in a hushed voice-over tone): We've secretly replaced these Haskell programmers' algorithms with Folger's (R) Crystals. Let's see if anyone notices... ;p
14:43:43 <ksf> you should generalize your tic tac toe. first to three dimensions, then to arbitrary (square) board size, then to n dimensions.
14:44:01 <Knight_Lord> copumpkin: ghc --make tictactoe -O2 ?
14:44:39 <lispy|web> When you DoS lambdabot, you also DoS me :)
14:44:42 <Twey> What are Folger's® Crystals?
14:44:57 <BMeph> Isn't 3-D t-t-t an auto-win for the first player? :\
14:44:59 <Botje> a brand of instant coffee
14:45:03 <copumpkin> lispy|web: onoes! did someone run that command in a pm?
14:45:07 <lispy|web> Knight_Lord: http://book.realworldhaskell.org/read/profiling-and-optimization.html
14:45:20 <lispy|web> copumpkin: looks like, yeah
14:45:20 * copumpkin has to run, ciao!
14:45:21 <sm> which function rounds a real number to n decimal digits, like python's round ?
14:45:33 * ksf thinks you have to have a board size of at least 4 to get a game.
14:45:39 <BMeph> @hoogle round
14:45:44 <BMeph> D'Oh!
14:45:51 <ksf> ...no matter how many dimensions, but I'm not sure.
14:46:07 <lispy|web> Well, she disconnected, but I still can't get my connection back
14:46:15 <sm> the prelude's round just returns the nearest integer
14:46:27 <Knight_Lord> lispy|web: thanks
14:46:28 <ksf> :t round
14:46:30 <BMeph> lispy|web: Can she hear you now? ;)
14:46:40 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:46:53 <Knight_Lord> compiling with -O2 takes a really long time
14:46:59 <lispy> oh hey
14:47:03 <lispy> the connection came back
14:47:22 <ksf> sm, showFFloat...
14:47:26 <lispy> I kinda wonder if it's my fault for reenabling swap
14:47:36 <ksf> more seriously, have a look at the numeric module.
14:47:41 <Knight_Lord> Is it normal that ghc takes more than 1GB of memory to compile my 150 lines program?
14:47:43 <lispy> At least one drive in this server has really bad reads (I think it's a hardware problem)
14:48:07 <lispy> Knight_Lord: the linker takes too much memory sometimes
14:48:24 <Knight_Lord> It;s still compiling, not linking
14:48:36 <Knight_Lord> it's at 1.63GB memory and going up
14:48:38 * ksf is curious what that program looks like
14:49:00 <Lycurgus> "cabal: cannot configure haskell-src-exts-0.3.12. It requires base >=4 "
14:49:10 <Lycurgus> which "base" is that?
14:49:13 <ksf> (did you by any chance enable XUndecidableInstances?)
14:49:19 <int-e> Lycurgus: it comes with ghc 6.10.x
14:49:24 <Lycurgus> ah
14:49:26 <int-e> Lycurgus: it's the base library
14:49:37 <sm> ksf: thanks. Was that not a serious answer ? I missed that one on first look through Numeric
14:49:44 <Lycurgus> and not in 6.8 at all
14:49:46 <ksf> uh, well...
14:49:53 <ksf> it returns a string.
14:49:58 <sm> but for some reason my showFFloat has an extra argument :: (RealFloat a) => Maybe Int -> a -> String -> String
14:50:06 <ksf> take the empty sting.
14:50:14 <lispy> I should get going.  Good luck ya'll.
14:50:21 <ksf> it's a string to append, to fit into the show pretty-printer.
14:50:22 <EvilTerran> sm, that's a string to prepend the result onto
14:50:25 <lispy> (and please don't DoS lambdabot to much)
14:50:27 <EvilTerran> sm, it's an efficiency thing
14:51:06 <EvilTerran> you can compose prepending functions any-old-how, and then pass them [], and the appending operations will be O(n) overall
14:51:09 <sm> I see, thanks. printf is probably what I want most times
14:51:22 <EvilTerran> but just ++ing strings together can give you O(n^2) for allthe appends
14:51:28 <BMeph> "In the call showFFloat digs val, if digs is Nothing, the value is shown to full precision; if digs is Just d, then at most d digits after the decimal point are shown."
14:51:30 <Jedai> sm: If you keep appending list on the left, the complexity is quadratic
14:51:32 <sm> and if I need numeric rounding, I guess multiply, round, divide
14:52:16 <Knight_Lord> ksf: to satisfy your curiousity http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3462#a3462
14:52:35 <Knight_Lord> I can't finish compiling, I run out of memory (2GB)
14:52:54 <Knight_Lord> compiles fine without -O2 though
14:52:55 <Jedai> sm: but if you append only on the right, your complexity is linear (and this String argument allows to implement a pattern that force all append to happens on the right of an initial list
14:53:48 <Knight_Lord> With ghc 6.8.2 (the last for MacOSX Tiger)
14:53:50 <sm> thanks, got it. I don't really care about efficiency right now, but about an easy api I can use for interactive calculations instead of python
14:54:09 <ksf> compiles with -02 here.
14:54:14 <ksf> ghc 6.10.4
14:54:32 <ksf> tictactoe: Prelude.(!!): index too large
14:54:51 <ksf> ... with input 1\n2\n
14:55:08 <Knight_Lord> ksf: well i didn't say it was a robust program :)
14:55:27 <Knight_Lord> The idea is to input like A1 for lower left C3 for upper right
14:55:44 <ksf> oh.
14:55:58 <ksf> ...well it _did_ put a x into the c3
14:56:02 <Knight_Lord> C1 for lower right
14:56:22 <Knight_Lord> how long did it take?
14:56:54 <ksf> -O2? less than half a second.
14:57:02 <Knight_Lord> that's nice
14:57:49 <Knight_Lord> I'll try to compile a newer version of ghc
14:59:15 <BMeph> sm: How much easier of an API do you need than String -> String? It's the sig wanted by 'interact'! ;)
14:59:58 <ksf> genMoves and winner shout for lists instead of tuples.
15:00:12 <ksf> ...so you can abstract all the duplication away.
15:00:29 <BMeph> Tuple Duples? ;p
15:00:34 <Twey> main = interact $ print . (* 2) . read
15:00:50 <Twey> Hmm
15:01:00 <Twey> It would be nice to have String be an instance of Applicative.
15:01:27 <Knight_Lord> ksf: what do you mean with shout?
15:01:29 <Jedai> Knight_Lord: I strongly suggest you don't bother with compiling GHC
15:01:30 <sm> BMeph: I wanted something easy to type that would show me 122.12 * 0.4 to two decimal digits
15:01:40 <ksf> ... and (.) == fmap, so you can do "toUpper . "foo""?
15:01:40 <Twey> fmap :: (Read a, Show b) => (a -> b) -> String -> String
15:01:43 <Knight_Lord> Jedai: why not?
15:01:52 <Jedai> Knight_Lord: use a binary (or an installer) depending on your platform
15:02:04 <Knight_Lord> Jedai: there is no binary for my platform (MacOSX Tiger)
15:02:06 <ksf> Knight_Lord, well, they beg for it, in a very verbose way. that's why they take up so many lines...
15:02:07 <Jedai> Knight_Lord: because it's too damn long !!
15:02:09 <Twey> ksf: Sure, why not :þ
15:02:12 <sm> in python it's round(122.12 * 0.4, 2) but I still see the floating point rounding error, I thought haskell might work better
15:02:29 <Twey> sm: Tell you what
15:02:32 <Knight_Lord> Ok I didn't get the metaphour :)
15:02:50 <Twey> sm: You give us a computer with infinite memory, and we'll give you a compiler that can represent all numbers precisely ;)
15:02:51 <Knight_Lord> I started with tuples to make it more strict
15:02:53 <ksf> Twey, tell you what, there _is_ an applicative instance for string.
15:03:00 <ksf> it's called [a]
15:03:13 <Knight_Lord> (because a tictactoe board can have 9 places and no more)
15:03:20 <Twey> If it also has infinite processing speed, it can even do it in finite time!
15:03:26 <Twey> ksf: ☹
15:03:30 <Knight_Lord> But that made the coding more difficult
15:03:32 <Jedai> Knight_Lord: Well in this case do your thing :( and good luck
15:03:39 <Twey> ksf: But we can override that.  They did it for show, after all.
15:04:11 <Jedai> sm: You can use CReal if accuracy of floating point  is a problem for you
15:04:16 <Twey> Then we can have a meaningful distinction between map and fmap!
15:04:38 <CalJohn> @src foldr
15:04:38 <lambdabot> foldr f z []     = z
15:04:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:04:59 <Makoryu> Twey: Hey, I *like* being able to use <$> for both liftM and map
15:04:59 <Jedai> sm: or you could learn how to use floating point value and operation if you need efficiency
15:05:17 <Jedai> > 122.12 * 0.4 ::CReal
15:05:20 <lambdabot>   48.848
15:05:28 <ksf> well, the actual constraint on the [[a]] would be that the inner and outer lists have the same length, i.e. that it's a square.
15:05:35 <CalJohn> is it fair to say that in a strict language, the distinction between right and left folds wouldn't be important
15:05:42 <Jedai> CalJohn: no
15:05:46 <bos> @seen dons
15:05:46 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
15:05:52 <ksf> you could do that with vectors, but type level programming seems to be overkill here.
15:05:56 <CalJohn> except that foldl is less space effcient
15:05:58 <BMeph> Knight_Lord: Yeah, if you had Leopard, you could use the HP. Pity... :\
15:06:01 <CalJohn> Jedai: why not?
15:06:11 <Jedai> CalJohn: In fact in a strict language you tend to favor foldl (because it's tail recursive)
15:06:12 <Makoryu> CalJohn: You noticed that they have different types, didn't you?
15:06:28 <Makoryu> Not that that matters as much anyway
15:06:41 <Knight_Lord> BMeph: pity indeed
15:06:57 <Makoryu> Knight_Lord: Why exactly are you on 10.4?
15:07:14 <CalJohn> Jedai: oh, yes, of course.  that was a silly mistake
15:07:16 <Jedai> CalJohn: they're dual sure, but they don't perform their operation in the same direction, so except for commutative operators, you really can't use one for the other
15:07:26 <Knight_Lord> Makoryu: because I don't buy OSs every other year
15:07:39 <Phyx-> > hello
15:07:41 <lambdabot>   Not in scope: `hello'
15:07:46 <Phyx-> > food
15:07:47 <lambdabot>   Not in scope: `food'
15:07:48 <CalJohn> Jedai: that is also true, I didn't thought of non-commutative operators
15:07:51 <Phyx-> > eat
15:07:52 <lambdabot>   Not in scope: `eat'
15:07:55 <Phyx-> hmm
15:07:59 <Phyx-> > sudo
15:08:00 <CalJohn> *hadn't
15:08:00 <lambdabot>   Not in scope: `sudo'
15:08:12 <CalJohn> I am the worst native english speaker ever
15:08:26 <Makoryu> Knight_Lord: Are you instead waiting until you have to get a new computer altogether to run x86 stuff?
15:08:33 <ksf> Phyx-, type mismatch: inferred type: #Haskell a, expected type: Kitchen a
15:08:54 <BMeph> CalJohn: *think  is a good way to say it, too. :)
15:09:06 <Knight_Lord> Makoryu: my computer is barely 2 years old. My others OSs with 2 years old run perfectly fine
15:09:21 <Jedai> CalJohn: Don't worry, you can find far worse in this IRC world...
15:09:28 <Axman6> @let sudo = unsafePerformIO
15:09:29 <Jedai> ^^
15:09:29 <lambdabot>  <local>:3:7: Not in scope: `unsafePerformIO'
15:09:32 <Axman6> :(
15:09:50 <BMeph> :)
15:10:03 <CalJohn> Jedai: at least I am good at not mixing up "their" and "there" and "they're".  i still have my dignity.
15:10:23 <Jedai> Axman6: I wouldn't like lambdabot to have unsafePerformIO :)
15:18:24 * byorgey sings the type error song
15:19:09 <dancor> that's not good, hacker, that's not gooood
15:19:22 <skorpan> wrong song
15:19:31 <dancor> it's wrong alright
15:19:47 <byorgey> "type errors / they get in my hairs / but in the end / I'm glad they're theres"
15:20:05 <Cale> byorgey: haha, awesome
15:20:30 <byorgey> sung to the tune of Mahler's fifth symphony
15:20:48 * byorgey should go to bed
15:23:36 <mauke> preflex: seen lambdabot
15:23:51 <preflex>  lambdabot was last seen on #haskell 36 minutes and 59 seconds ago, saying: forall a b. (RealFrac a, Integral b) => a -> b
15:23:57 <mmorrow> @bot
15:23:57 <lunabot>  :o
15:23:57 <lambdabot> :)
15:24:09 <mauke> good, brain is intact
15:24:50 <mmorrow> preflex: are you a bot sent from the future to kill John Conor?
15:25:11 <mauke> @vixen are you a bot sent from the future to kill John Conor?
15:25:11 <lambdabot> why does everyone ask i'f on a bot?
15:25:33 <mmorrow> @vixen are you the governator of california?
15:25:34 <lambdabot> yes, i am
15:25:38 <mmorrow> i knew it!
15:30:43 <mmorrow> mauke: did i ever show you this C repl that uses tcc to dynamically compile/link/load/call-into C code (w/ a readline interface) that i've got?
15:31:00 <mmorrow> mauke: it was really simple to hack together
15:31:14 <mmorrow> mauke: http://moonpatio.com/repos/tcci/
15:31:18 <mauke> I remember something like that
15:31:46 <mmorrow> mauke: it's kind of annoying how it's currently set to call a function "go" as entry-point, but i'm not sure a better solution
15:32:18 <mmorrow> also, the state (of the linker, etc) isn't retained across evals, but it could be
15:32:39 <mmorrow> the only thing is then you'd need to know the intended entrypoint, and it couldn't be the same
15:32:58 <mmorrow> since then you'd have a duplicate symbol in the linker symtab
15:33:42 <mmorrow> mauke: also, there's no reason why it needs to exit upon a SIGSEGV
15:35:01 <glguy> I was trying some of the examples in the opengl tutorial on haskellwiki, but in all of them so far the drawing has been unrelated to the window
15:35:04 <glguy> 's location
15:35:14 <glguy> and it just writes to the top-left corner of my monitor
15:35:18 <mmorrow> mauke: i want to fix/figure out the above annoyances, and maybe add some sort of ptrace haxery to it
15:35:23 <glguy> is this the expected behavior withot some additional callback?
15:35:57 <mmorrow> glguy: you mean, it's drawing outside of the window?
15:35:59 <glguy> yes
15:36:02 <mmorrow> :o
15:36:24 <glguy> The Gears.hs example works fine
15:37:21 <mmorrow> glguy: there's a ghc ticket related to the "state hack", that has a sample opengl prog attached (which works fine with -fno-state-hack or whatever) that's a nice opengl example i thought
15:37:41 <mmorrow> it's a mesh viewer
15:39:01 <mmorrow> glguy: found it http://hackage.haskell.org/trac/ghc/ticket/2284
15:40:30 <glguy> switching to a double-buffered window seems to have fixed the issue
15:40:52 <daz__> does anyone know how to get this equasion to stop executing after the numbers get too high? [a^3 | a <- [1..], a^3 < 2000] or do i have to add an upper limit on this [1..] so it will be [1..n]
15:41:12 <sm> how do I work around cabal haddock saying: "cabal: Haddock's internal GHC version must match the configured GHC version"
15:41:14 <sm> ?
15:41:14 <mmorrow> daz__: you take "take n"
15:41:22 <mmorrow> *you _can_ "take n"
15:41:30 <benmachine> daz__: I'd do takeWhile (< 3000) $ map (^3) [1..]
15:41:46 <mmorrow> ah, better idea
15:42:07 <daz__> can you do it with just take?
15:42:42 <mmorrow> daz__: you can take a certain number of items with "take", or use "takeWhile" to base the decision of the values
15:42:48 <benmachine> take n means you have to decide how many you're taking beforehand
15:42:50 <mmorrow> s/of/on/
15:43:21 <sm> ah:  --with-haddock=/Users/simon/.cabal/bin/haddock <- 2.5
15:43:25 <mmorrow> , takeWhile (< 100) [a^3 | a <- [1..], a^3 < 2000]
15:43:26 <lunabot>  [1,8,27,64]
15:43:33 <mmorrow> , take 20 [a^3 | a <- [1..], a^3 < 2000]
15:43:40 <lunabot>  Killed.
15:43:45 <mmorrow> , take 8 [a^3 | a <- [1..], a^3 < 2000]
15:43:46 <lunabot>  [1,8,27,64,125,216,343,512]
15:44:00 <benmachine> , take 20 [a^3 | a <- [1..]]
15:44:02 <lunabot>  [1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,58...
15:44:14 * benmachine hmms
15:44:19 <benmachine> oh
15:44:23 <benmachine> I see
15:44:38 <mmorrow> ah, i just noticed the "a^3 < 2000"
15:44:39 <daz__>  take 8 [a^3 | a <- [1..], a^3 < 2000] still doesnt stop executing.
15:44:48 <benmachine> the one with the a^3 < 2000 doesn't terminate because it looks for the next element below 2000 and
15:44:52 <benmachine> there isn't one.
15:44:56 <benmachine> er
15:44:58 <benmachine> yes
15:45:04 <mmorrow> , take 8 [a^3 | a <- [1..], a^3 < 2000]
15:45:05 <lunabot>  [1,8,27,64,125,216,343,512]
15:45:16 <mmorrow> daz__: are you using ghci?
15:46:11 <mmorrow> daz__: the bots are (using ghci)
15:46:24 <mmorrow> (well, ghci-equivalent)
15:46:35 <daz__>        bash: ghci: command not found
15:46:36 <daz__> .. how do you start that interpreter
15:46:51 <mmorrow> daz__: ah, ok. you need to install ghc first
15:47:00 <mmorrow> (i'm guessing you were using hugs then?)
15:47:02 <benmachine> mmorrow: it won't terminate however much you compile it
15:47:15 <mmorrow> benmachine: it terminates in the bots
15:47:17 <benmachine> oh
15:47:18 <mmorrow> , take 8 [a^3 | a <- [1..], a^3 < 2000]
15:47:19 <benmachine> yeah
15:47:19 <lunabot>  [1,8,27,64,125,216,343,512]
15:47:22 <benmachine> hm.
15:47:38 <daz__> yea i was using hugs, but i am sure i install ghc on my linux machine.
15:47:50 <benmachine> > length (takeWhile (<2000) $ map (^3) [1..])
15:47:51 <lambdabot>   12
15:48:04 <daz__> yeh takewhile is fine,
15:48:05 <benmachine> if you take more than 12 of that list then it won't terminate
15:48:25 <benmachine> I mean, the one with a^3 < 2000 in the listcomp
15:50:58 <Luke> is there a way to make one class instance for two types?
15:51:42 <ksf> what do you mean?
15:52:02 <Luke> i have two instances with the same implementation aside from the type
15:52:04 <ksf> sharing implementation between two instances?
15:52:07 <Luke> yeah
15:52:44 <ksf> you can define one newtype, declare one instance for it, and then derive that instance for your other two types.
15:52:58 <Luke> ah good idea
15:52:59 <Luke> thanks
15:53:19 <ksf> GeneralizedNewtypeDeriving ftw.
15:53:23 <pragma_> Mike screamed for help, kicked with his legs to remain above surface and catch some air, until he disappeared down into the water and was never seen again.
15:53:36 <Luke> language extension?
15:53:40 <ksf> yep.
15:53:46 <Luke> awesome
15:53:53 <BMeph> GHC isn't "smart" enough to know that even though your predicate has failed for the past 1,000,000 numbers, that it may succeed again, if you take a few million more. :\
15:54:05 <ksf> it lets you derive instances for any class that the contained type instanciates.
15:54:06 <mauke> hi, pragma_
15:54:08 <Luke> is there a place where language extensions are officially defined somewhere?
15:54:30 <daz__> thats cool BMeph, yeh it makes sense that it keeps going..
15:54:36 <ksf> the ghc manual.
15:54:46 <pragma_> mauke: hello there, good fellow.
15:54:56 <ksf> it would have told you if you tried to derive such an instance, too.
15:55:33 <ksf> BMeph, that's a feature called "optimism"
15:55:38 <Luke> i dont know how the syntax looks
15:55:46 <BMeph> daz__: Yeah, that's the nice thing about takeWhile: It tels the compiler to stop looking once the predicate fails. :)
15:55:51 <daz__> are there many differences from an expressional point of view between hugs and GHC? Its seems GHC is a superior interpreter...
15:56:09 <ksf> newtype Foo = Foo Int deriving (EverythingThatIntSupports)
15:56:21 <shapr> geez
15:56:22 <BMeph> ksf: Funny, my wife calls it "damned stubbornness"... ;)
15:57:04 <kmc> Luke, http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
15:57:08 <Luke> thanks much!
15:57:15 <kmc> i read that document on each ghc release and it always makes me happy
15:57:21 <BMeph> shapr: Aitches? :)
15:57:24 * ksf can't think of a reason to use hugs over ghc
15:58:38 <kmc> there's also: http://hackage.haskell.org/trac/haskell-prime/ which has proposed features, alternatives and discussion, and talk about what will make it into the next standard
15:59:31 * ksf is currently trying to get a feeling for the design possibilities that type families offer
15:59:41 <daz__> ksf but from an expressional POV if you send hugs the same expressions you send ghc, then the results will be the same?
15:59:43 <blackdog_> ksf: think hugs handled large literals better, didn't it?
15:59:50 <mmorrow> daz__: yes
16:00:23 <shapr> BMeph: eh?
16:00:27 <shapr> BMeph: oh, hah
16:00:39 <A1kmm> Hi, I have code which uses the state monad with both mutable unboxed arrays and an Int to collect statistics over a long ByteString, and hpc is showing that the Int is being lazily updated rather than strictly.
16:01:01 <A1kmm> Any suggestions on the best way to do this? I don't want to use Int# since I don't want to use anything too GHC specific.
16:01:01 <mmorrow> A1kmm: what's the type of your State?
16:01:16 <kmc> A1kmm, a strict field !Int ?
16:01:17 <mmorrow> (err, the "s" in (State s a)
16:01:17 <A1kmm> Sorry, I meant it is actually ST
16:01:36 <mmorrow> A1kmm: ah, there's Control.Monad.ST.Strict
16:01:40 <A1kmm>    69 countBackground :: [(String, B.ByteString)] -> forall s . S.ST s (A.UArray Word8 Int, Int, A.UArray (Word8, Word8) Int, Int)
16:01:49 <A1kmm> Ah, that is probably what I want, thanks.
16:02:07 <mmorrow> A1kmm: although you may just need to force the Int yourself
16:02:11 <Luke> kmc: this is what i'm looking at btw: http://bitbucket.org/LukeHoersten/rubix/src/6e41bd8e05d6/Cube.hs
16:02:26 <mmorrow> because in that case, it'll just be forcing the (,,,) and not the contents in it
16:02:31 <Luke> kmc: see how the instance of slab and slice are the same save the type?
16:02:32 <A1kmm> mmorrow: I could, but it would look messy since I wouldn't be able to use modifySTRef
16:03:00 <mmorrow> , (\(a,!b,c) -> (a,b,c)) (1,2,3)
16:03:01 <lunabot>  (1,2,3)
16:03:05 <kmc> Luke, but the types are not isomorphic
16:03:16 <Luke> oh?
16:03:20 <mmorrow> A1kmm: bang patterns are really handy for stuff like this
16:03:27 <kmc> you can't write Slab and Slice both as newtypes of some common type
16:03:31 <kmc> unless i'm missing something
16:03:57 <mmorrow> , time (foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..10000000])
16:04:03 <lunabot>  Killed.
16:04:06 <mmorrow> , time (foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..1000000])
16:04:09 <lunabot>  (1.4507809999999999,(500000500000,500000500000))
16:04:16 <mmorrow> , time (foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [0..1000000])
16:04:19 <lunabot>  Stack space overflow: current size 8388608 bytes.
16:04:19 <lunabot>  Use `+RTS -Ksize' to increase it.
16:04:54 <kmc> Luke, I think you can make a parametrized type
16:05:08 <kmc> the types Slab and Slice have the same "pattern" of fields
16:05:30 <mmorrow> A1kmm: so if the Int's in a tuple, the Strict ST won't help
16:05:45 <kmc> data Thing c e m = Thing c e c e m e c e c
16:05:47 <BMeph> BBL; still tweaking the ol' Ween-Doze to work... :\
16:06:00 <kmc> newtype Slab = Slab (Thing Corner Edge Middle)
16:06:07 <Luke> kmc: so even tho the instance implementations are the same, because they aren't isomorphic?
16:06:10 <kmc> newtype Slice = Slice (Thing Edge Middle Core)
16:06:16 <daz__> why did it overflow when you used lambda
16:06:19 <Luke> oh i see
16:06:21 <A1kmm> mmorrow: it isn't in the STRef though.
16:06:27 <Luke> wrap it in that internal "thing" type?
16:06:35 <kmc> the implementations aren't really the same.  the types of various variables in there aren't the same
16:06:41 <kmc> you only don't notice because there is type inference
16:06:50 <mmorrow> A1kmm: foldl' (\(a,b) -> ...)   v.s.   foldl' (\(!a,!b) -> ...)
16:06:53 <Luke> yeah i noticed actually
16:06:59 <A1kmm> mmorrow: countBackground probes =
16:07:01 <A1kmm>     do
16:07:01 <Luke> so best case i can just have them doubled?
16:07:02 <A1kmm>       basecount <- S.newSTRef 0
16:07:04 <A1kmm>       transcount <- S.newSTRef 0
16:07:05 <A1kmm>       bases <- (S.newArray (0, 3) 0) ::S.ST s (S.STUArray s Word8 Int)
16:07:07 <A1kmm>       transitions <- (S.newArray ((0, 0), (3, 3)) 0)::S.ST s (S.STUArray s (Word8, Word8) Int)
16:07:26 <kmc> well, i would create this parametrized type, where Corner/Edge/Middle/Core are replaced by type variables, as above
16:07:39 <kmc> write one instance
16:07:44 <A1kmm> Well I have                   S.modifySTRef basecount (+1) but I could write an increment strict in the first arg.
16:07:45 <Luke> gotcha
16:07:52 <Luke> good suggestion. thanks kmc
16:07:58 <kmc> hope it works out
16:08:03 <Luke> thanks man
16:08:19 <kmc> honestly i might not bother with the newtype, just use a type alias because they'll be distinct anyway
16:08:22 <mmorrow> A1kmm: ah, right. ST.Strict should help with that (i believe)
16:09:03 <mmorrow> daz__: the stack overflow was because foldl' uses `seq' which only forces "one level" of the data
16:09:31 <mmorrow> daz__: and since the accumulator is (Int,Int), foldl' only forces the tuple, and doesn't reach the two Ints
16:09:59 <mmorrow> daz__: so wrt the Ints, it has the same behavior as plain foldl
16:10:30 <mmorrow> daz__: and the bang patterns make sure that the Ints too get kept one-level-deep-wrt-thunk-buildup
16:12:07 <mmorrow> A1kmm: oh, actually wait. you need Data.STRef.Strict
16:12:37 <mmorrow> A1kmm: (you may also want Control.Monad.ST.Strict too, but that's independent of this modifySTRef issue (i think))
16:12:59 <A1kmm> mmorrow: I've got that as well in the version I'm testing... just Data.STRef.Strict didn't work. Trying both together now.
16:13:08 <mmorrow> A1kmm: ah nice
16:13:46 <A1kmm> mmorrow: The (+1) in HPC is still has the 1 highlighted.
16:13:51 <A1kmm> So I guess it didn't work.
16:14:48 <mmorrow> A1kmm: and this is regarding "S.modifySTRef basecount (+1)" ?
16:15:31 <A1kmm> Yes... I can send you the HTML output from HPC if you want to have a look at it in context.
16:16:16 <mmorrow> A1kmm: oh, in HPC? are you sure that highlight isn't just saying that that part of the code was touched (or something?)?
16:16:29 <A1kmm> The highlight means it wasn't touched.
16:16:45 <A1kmm> So it never touched the constant 1, even though it is run over lots of long strings, and all the other context is touched.
16:17:13 <mmorrow> A1kmm: oh, right. ok, but are you ever demanding the eventual value of this Int?
16:17:32 <mmorrow> A1kmm: (are you stack overflowing?)
16:17:39 <A1kmm> Yes... and I get a stack overflow at that point.
16:17:43 <Phyx-> @stack
16:17:43 * lambdabot activates her slap-o-matic...
16:17:45 <mmorrow> ah, ok.
16:17:54 <Phyx-> @stack
16:17:54 * lambdabot moulds  into a delicous cookie, and places it in her oven
16:18:01 <Phyx-> @stack
16:18:02 <lambdabot> *SMACK*, *SLAM*, take that !
16:18:04 <mmorrow> A1kmm: could you paste the code containing the modifySTRef?
16:18:06 <mmorrow> @paste
16:18:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:18:09 <benmachine> @help stack
16:18:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:18:12 <Phyx-> since when is lambdabot a she?
16:18:20 <mmorrow> Phyx-: since always
16:18:36 <Phyx-> mmorrow: :O
16:18:41 <Phyx-> but it's got a vile mouth!
16:18:47 <mmorrow> heh
16:18:55 <A1kmm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8850#a8850
16:20:49 <A1kmm> Actually, I pasted the version I just changed, the \!x -> x + 1 is new hasn't been tested yet.
16:22:08 <A1kmm> and in fact doesn't compile it seems.
16:22:50 <wagle_home> trying to install haskell-platform-2009.2.0.2 on debian x86_64..  anyone know anything about this:
16:22:54 <wagle_home> The mtl-1.1.0.2/Setup script does not exist or cannot be run
16:22:58 <wagle_home> ?
16:23:08 <ksf> a couple of years later after I did it, I now know for sure that I invented coroutines.
16:23:27 <kmc> did anyone ever actually write a Haskell compiler named THC?
16:25:32 <mmorrow> A1kmm: what input should countBackground be run with?
16:26:03 <mmorrow> A1kmm: (take 100000000 (repeat "qwertyutr") causes a bad array index)
16:26:09 <A1kmm> A ByteString made up of Word8 values between 0 and 3.
16:26:15 <mmorrow> ah, ok
16:26:47 <dyaso> um hello, i'm trying to use the School Of Expression book but can't get the example code to compile
16:26:51 <dyaso> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8851#a8851
16:27:22 <mmorrow> A1kmm: what's average length would you say these ByteStrings have?
16:27:26 <mmorrow> *what
16:28:17 <mmorrow> A1kmm: if it's anywhere near 10, i think you've fixed it with the addition of (\ !x -> x+1)
16:28:37 <A1kmm> Just checking my data file... but it is going to be hundreds or thousands for my data, and more for other data sets.
16:28:50 <mmorrow> ah, i see
16:29:35 <A1kmm> Taking the second entry - which is the longest of the first 4, it is 1287 bases long.
16:30:57 <mmorrow> A1kmm: this is running in constant space for me:
16:30:59 <mmorrow> ghci> let xs = replicate 1000 (concat (take 10000 (repeat "\0\0\1\1\2\3\2\2\2\1")))
16:31:00 <mmorrow> ghci> let ys = zip xs (fmap (B.pack . fmap (fromIntegral . ord)) xs)
16:31:00 <mmorrow> ghci> runST (countBackground ys)
16:32:10 * ksf realizes that it's kind of pointless to implement co-routines in haskell, as forkIO uses coroutines.
16:32:16 <mmorrow> A1kmm: these are the imports i added to get it loaded in ghci http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8850#a8852
16:32:27 <ksf> but then, a threaded rts makes this very, very interesting indeed.
16:32:40 <mmorrow> A1kmm: are you using the same? (or is that test not representative?)
16:32:58 <ksf> the idea is to encode coroutines on top of stm.
16:33:02 <A1kmm> Similar I think... I don't have the unqualified imports, but that shouldn't matter.
16:33:32 <mmorrow> A1kmm: yeah, just added those to match the qualified names already present in the code
16:33:49 <hydo> If I want to get a job writing haskell code, ie. become a really good haskell programmer, how important is it that I shun the use of do notation?  I don't mind doing it... I just figured that if it's important that I learn to live without it, I start as early as possible.
16:33:50 <ksf> ...as stm gives you the proper "block until I get called"-behaviour, for free, and without run-time cost
16:33:59 <ksf> (exactly because haskell threads are coroutines)
16:34:11 <mmorrow> A1kmm: err, are you actually overflowing in the byteString*ForM functions?
16:34:59 <kmc> hydo, to be a good haskell programmer you should be comfortable with or without do notation
16:35:02 <A1kmm> Hmm, it is hard to tell, I could put some Debug.Trace.trace calls around them.
16:35:04 <mmorrow> A1kmm: it may possibly be the interaction of (>>) with B.foldl, but not sure
16:35:36 <mmorrow> A1kmm: maybe try using foldM there
16:35:44 <A1kmm> But actually that wouldn't make sense, because I only get the stack overflow later.
16:35:51 <mmorrow> hmm
16:35:53 <ksf> hydo, the key to becoming a good haskell programmer is to take enjoying getting your mind blown seriously.
16:35:56 <benmachine> drat it, I lost the paste containing the proof that (return a >>) == id
16:36:03 <kmc> hydo, in particular you should understand how do notation translates into lambdas, (>>=) and (>>)
16:36:11 <A1kmm> I'll show you the whole program, which already has some traces and `seq` in there to try to catch problems.
16:36:31 <hydo> kmc: oh, i'm definitely loving that part :)
16:37:00 <hydo> ack... kid needs attention... brb
16:37:25 <mmorrow> A1kmm: heh, i forgot that that was running in ghci and just started swapping.. :)
16:37:34 <kmc> in practice when writing monadic code you'll use a whole mix of those operators, do notation, liftM / liftM2 / etc, Control.Applicative, other stuff you write, etc
16:37:38 <mmorrow> (but no stack overflow:)
16:39:06 <A1kmm> mmorrow: I haven't ruled out it could be something else causing the problem I guess...
16:39:23 <mmorrow> A1kmm: stack overflows like this are tricky to find for sure
16:39:44 <Luke> kmc: that worked!!!!
16:39:46 <Luke> thanks!
16:40:00 <A1kmm> Yeah, unfortunately laziness does make them hard to find because they show up when things are evaluated.
16:42:36 <benmachine> okay I feel silly asking this because I know I have before but I lost the papers - is this http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=3463#a3463 sensible?
16:42:52 <benmachine> (i.e. is each line necessarily equivalent to the last)
16:42:56 <kmc> Luke: :)
16:43:17 <wy> hello~
16:44:02 <blackh> Hello!
16:44:34 <wy> I'm still choosing courses. Any ideas of a math area closely related with the essence of computation? I'm considering topology, but not very sure
16:45:16 <Luke> kmc: http://bitbucket.org/LukeHoersten/rubix/src/tip/Cube.hs
16:45:37 <kmc> wy, choosing from any subject in math?
16:46:21 <Phyx-> test
16:46:45 <wy> kmc: yes
16:46:58 <kmc> wy, so the theory of what is computable is itself a subject in math
16:47:35 <Phyx-> > fmap (liftM (*)) (Just [1])
16:47:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a1 -> a1)
16:47:37 <lambdabot>    arising from a use of...
16:47:55 <wy> kmc: right... so what is the subject?
16:48:01 <kmc> computability theory
16:48:12 <kmc> there's also complexity theory
16:48:19 <kmc> which studies what's computable efficiently
16:48:24 <kmc> logic is another one
16:48:30 <blackh> benmachine: That looks correct (but it makes my head hurt).
16:48:31 <Phyx-> :t fmap (liftM (*)) (Just [1]) >>= flip fmap undefined
16:48:32 <lambdabot>     Couldn't match expected type `[a1 -> a1]'
16:48:32 <lambdabot>            against inferred type `a -> a1 -> a1'
16:48:32 <lambdabot>     In the first argument of `flip', namely `fmap'
16:48:58 <kmc> particularly if you're interested in languages like Haskell, because type systems correspond with logics in a very general and deep way, the Curry-Howard isomorphism
16:49:04 <benmachine> blackh: if you have any way to make it less head-hurty that would be cool
16:49:09 <copumpkin> moo
16:49:09 <wy> complexity theory is kind of shallow
16:49:33 <wy> I want to find those areas that could germinate those ideas
16:49:36 <blackh> benmachine: Leave out every line except for the last one? :)
16:49:40 <kmc> complexity theory is largely 40 years of people trying and failing to prove P != NP in various strange ways
16:49:51 <benmachine> blackh: heh, that could work
16:49:56 <copumpkin> kmc: not sure I'd say that :P
16:50:03 <benmachine> proof left as exercise etc.
16:50:06 <copumpkin> kmc: that's like saying Haskell = Monads
16:50:19 <wy> kmc: yes. That's why I don't like it ;)
16:50:21 <kmc> wy, mathematicians sometimes call computability theory "recursion theory"
16:50:42 <kmc> it also relates to descriptive set theory, and logic
16:52:08 <mmorrow> A1kmm: yeah it's tricky at first, but in the end it's the same old problem, just from the opposite direction (stack overflow in a lazy language)
16:52:10 <kmc> haskellers also talk a lot about categories so you might study category theory
16:52:25 <kmc> what little category theory i know does not give me much intuition about haskell
16:52:33 <kmc> but perhaps there's a level at which the light turns on
16:52:45 <wy> Isn't there a connection from topology? I heard that it is the parent of some theories I learnt, but I forgot the relationship
16:54:16 <Phyx-> > foldr ($) 20  (fromMaybe [id] ((fmap (liftM (*)) (Just [1]))))
16:54:17 <kmc> category theory is important in topology
16:54:18 <lambdabot>   20
16:54:22 <Phyx-> hm
16:54:23 <Phyx-> odd
16:54:25 <kmc> how or why i couldn't tell you
16:54:40 <Phyx-> @pl foldr ($) 20  (fromMaybe [id] ((fmap (liftM (*)) (Just [1]))))
16:54:41 <lambdabot> foldr id 20 (fromMaybe [id] (fmap (fmap (*)) (Just [1])))
16:54:49 <mmorrow> A1kmm: and also in (ghc) haskell, there are a bunch of tiny stacks rather than a single massive stack (like in C), so overflowing one of these little ones is even easier than overflowing the C stack, which makes stack use a lot more noticeable
16:54:55 <Phyx-> > foldr ($) 20  (fromMaybe [id] ((fmap (liftM (*)) (Nothing))))
16:54:56 <lambdabot>   20
16:55:14 <Phyx-> not what i'm expecting
16:55:15 <Phyx-> lol
16:55:27 <Phyx-> :t liftM (*)
16:55:29 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m (a1 -> a1)
16:55:33 <wy> kmc: Is there a relationship between category theory and topology?
16:55:43 <Phyx-> :t liftM (*) [1..10]
16:55:45 <copumpkin> category theory is related to everything! :P
16:55:45 <lambdabot> forall a1. (Num a1, Enum a1) => [a1 -> a1]
16:55:46 <mmorrow> wy: yes
16:56:13 <Phyx-> :t foldr (.) id (liftM (*) [1..10])
16:56:14 <lambdabot> forall a. (Num a, Enum a) => a -> a
16:56:16 <A1kmm> mmorrow: Although that is probably a good thing... big stacks mean you just wait for a long time to find it will fail instead of finding the problem earlier.
16:56:23 <Phyx-> :t foldr (.) id (liftM (*) [1..10]) 0
16:56:24 <lambdabot> forall a. (Num a, Enum a) => a
16:56:25 <mmorrow> wy: category theory is to mathematics what mathematics is to ideas
16:56:30 <Phyx-> > foldr (.) id (liftM (*) [1..10]) 0
16:56:31 <lambdabot>   0
16:56:38 <Phyx-> > foldr (.) id (liftM (*) [1..10]) 8
16:56:39 <lambdabot>   29030400
16:56:47 <wy> mmorrow: so you think category theory is deeper than topology?
16:56:56 <mmorrow> A1kmm: yeah definitely
16:56:56 <kmc> category theory is more general
16:57:07 <kmc> the main criticism of category theory is that it's general to the point of uselessness
16:57:15 <kmc> wy, if you want to study computation in maths i'd find courses in logic or computability/recursion theory
16:57:24 <kmc> especially logic, if you care about type systems, which are logics
16:58:45 <kmc> also at my school it was fairly reliable to just look for classes cross-listed in math and CS
16:59:11 <copumpkin> :t times
16:59:12 <lambdabot> Not in scope: `times'
16:59:14 <copumpkin> aw
16:59:38 <Phyx-> wtf, I've just found some blueprints from some electronic device on the desktop of my server...
16:59:55 <wy> kmc: Is category theory offered as a class in your school?
17:00:14 <kmc> it was covered in the advanced algebra class
17:01:10 <kmc> the 3rd or 4th year undergrad or grad level algebra course
17:01:37 <kmc> ymmv, my school had a lot of undergrad/grad overlap
17:02:34 <wy> kmc: the same here. some of them have strange names
17:02:53 <wy> I found something called "survey of algebra"
17:03:36 <kmc> you may also find a math or cs or ee class in "information theory", which is also interesting and different from the rest
17:03:51 <wy> Are other parts of algebra of interest? I hope category theory has a good proportion in it
17:04:03 <kmc> wy, do you like maths generally?
17:04:40 <wy> kmc: I like some kind of math. But I don't like numbers that much ;)
17:05:07 <copumpkin> a lot of people don't
17:05:45 <kmc> including many mathematicians
17:06:42 <wy> really. I can imagine it. It feels not rewarding to derive lower-bounds or advance them here and there
17:07:30 <kmc> there are lots of structures to study besides data Nat = Zero | Succ Nat
17:07:43 <benmachine> is there anyone here who has version 3.x of parsec installed? cabal won't install it on my system but I just want to test a one-liner
17:09:18 <wy> kmc: right. realizing that revived my interest in math :)
17:10:27 <mmorrow> wy: if you take any pure math classes, make sure to take abstract algebra
17:10:49 <Cale> Though, the natural numbers are pretty surprisingly interesting. You have addition, whose structure is absolutely trivial on its own, and multiplication, which is also really simple when taken on its own. Put them together and all of a sudden you have this tremendously mysterious interaction.
17:11:00 <mmorrow> wy: that's the first real departure
17:11:34 <wy> mmorrow: You mean abstract algebra
17:11:36 <copumpkin> Cale: yeah, the naturals are fun
17:11:37 <mmorrow> yes
17:13:29 <wy> mmorrow: departure from what?
17:14:18 <mmorrow> wy: departure from the way you saw math before you took it
17:14:25 <copumpkin> "take abstract algebra"
17:14:30 <copumpkin> "you mean abstract algebra"
17:14:31 <copumpkin> o.O
17:14:40 * copumpkin is confused
17:15:22 <mmorrow> copumpkin: he was clarifying whether "<mmorrow> wy: that's the first real departure" was referring to abstract algebra
17:15:22 <benmachine> the latest version of HTTP has a major version number of 4000
17:15:25 * benmachine o_Os
17:15:34 <copumpkin> mmorrow: oh I see :)
17:16:23 <wy> mmorrow: can you relate it to lambda calculus?
17:18:41 <ksf> ...and from addition, you get substraction and thus negative numbers, which are quite easy, and from multiplication division, which is... undecidable.
17:19:29 <copumpkin> -s
17:20:21 <sohum> wait, division is undecidable?
17:20:24 <sohum> since when?
17:20:35 <ksf> > 1/3
17:20:37 <lambdabot>   0.3333333333333333
17:20:47 <ksf> that's a wrong answer.
17:20:56 <sohum> that's just an artifact of the base 10 representation
17:21:02 <A1kmm> mmorrow: BTW this is what my output from hpc looks like: http://www.amxl.com/static/Main.hs.html
17:21:04 <leithaus> \x -> x x
17:21:08 <ksf> > pi
17:21:09 <lambdabot>   3.141592653589793
17:21:15 <sohum> 1/3 is a well-defined value, which has well defined semantics
17:21:17 <mmorrow> wy: so say structures that have <insert the essential things that "lambda calculus does" here>. then consider maps between these structures that preserve the essential parts, and the structures that you can then build with these maps and and maps between *those* structures of maps and what any of these constructions might tell you about the original structures they're mapping between.
17:21:25 <leithaus> > \x -> x x
17:21:26 <sohum> pi, I will grant you, but it's not an artifact of division
17:21:27 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:21:46 <ksf> ...yep, I noticed a split second after writing it.
17:22:42 <wy> mmorrow: seems like model theory to me
17:23:02 <leithaus> > (\x -> x x)(\x -> x x)
17:23:04 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:23:13 <mmorrow> wy: model theory is an application
17:23:23 <ksf> sohum, but 1/3 is not a concrete value.
17:23:30 <EvilTerran> ?type In . Endo $ \x -> out x `appEndo` x
17:23:30 <ksf> it's a sum type.
17:23:31 <lambdabot> Mu Endo
17:23:34 <benmachine> 0.333333 is a right answer
17:23:35 <benmachine> er
17:23:42 <benmachine> if you have infinte threes
17:23:55 <leithaus> > \y -> (\x -> x y)(\x -> x y)
17:23:56 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
17:24:01 <sshc> Hi, I wrote a simple RPN calculator at "http://dpaste.com/87518/", but Haskell is inferring type [Double]
17:24:01 <wy> mmorrow: That's interesting. Is abstract algebra usually an undergraduate math course?
17:24:11 <mmorrow> A1kmm: hmm, cool. i just realized i need to use HPC more :)
17:24:11 <ksf> > "0." ++ cycle '3'
17:24:12 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:24:13 <sshc> The full error message is included in a comment in that code
17:24:23 <sohum> ksf: does that matter? it's still a well-defined value.
17:24:27 <ksf> > "0." ++ cycle "3"
17:24:28 <flippo> I can provide infinite threes at a very negligible cost per three.   Name your price.
17:24:29 <lambdabot>   "0.333333333333333333333333333333333333333333333333333333333333333333333333...
17:24:31 <copumpkin> is it possible to get all distances between n points in less than (n^2)/2 time?
17:24:38 <mmorrow> wy: yeah, it's a requirement usually taken sophomore yeah
17:24:58 <sohum> ksf: wait, what do you mean by "sum type"?
17:24:58 <mmorrow> wy: (in US universities at least)
17:25:18 <copumpkin> product?
17:25:28 <ksf> sohum, yep, it's an homogenous product type.
17:25:31 <benmachine> @type toLeft
17:25:32 <lambdabot> Not in scope: `toLeft'
17:25:40 <benmachine> oh right
17:25:43 * benmachine silly
17:25:47 <ezyang> hello all! time to figure what's going on with Happstack.State :-D
17:26:04 <sshc> benmachine, thanks for taking the time to look at my code.
17:26:08 <kmc> at my school, intro abstract algebra was taken mostly by s'mores, some by freshman who were particularly hardcore
17:26:15 <wy> mmorrow: I guess I have to learn it by myself then...
17:26:20 <sohum> ksf: that's just a distinction made by a particular representation. in base three, 1/3 = 0.1
17:26:28 <kmc> (we also had a lot of required freshman classes so it was considered a bit mad to take that on top)
17:26:31 <ksf> sohum, following that train of thought, "(\x -> x x) (\x -> x x)" is a perfectly reasonable value.
17:26:40 <ksf> sure, constructing it terminates.
17:26:45 * ezyang thinks that looks suspiciously like the Y combinator 
17:27:04 <mmorrow> ezyang: it's (y id)
17:27:10 * copumpkin is wondering where this is going...
17:27:18 <wy> mmorrow: I just hope the model theory course can give me some clue into the more general thing
17:27:19 * ezyang nods 
17:27:26 <ksf> but the point of computation is to arrive at canonical values.
17:27:39 <sohum> ksf: well, maths and computation have different standards for what's a canonical value
17:27:43 <ksf> which, with neither the example above or 1/3, will ever happen.
17:28:16 <mmorrow> wy: definitely. also, you could definitely learn it yourself if you want to.
17:28:30 <ksf> I bet there are some areas of math where you have to canocalize your 1/3 to actually use it.
17:28:31 <mmorrow> wy: the key phrase there being "if you want to"
17:29:19 <copumpkin> O.o
17:29:25 <sohum> ksf: I'd be very interested in seeing one. afaik, 1/3 /is/ a canonical value in maths, as is 0.3333... and 0.1 (base 3).
17:29:26 <benmachine> sshc: I'm not entirely confident of what your problem is, but I think some of your if statements would be clearer as case statements
17:29:47 <pikhq> ksf: Why wouldn't that be a perfectly reasonable value? Looks like a quite reasonable value of some type a which has a thunk that does not halt. :)
17:29:52 <benmachine> so you can do something like case acc of Left x -> <stuff with x>
17:30:07 <ksf> meh.
17:30:11 <mmorrow> wy: although i see now reason why you couldn't still take a course in abstract algebra if you're in school..
17:30:17 <mmorrow> s/now/no/
17:30:26 <ksf> so use your words, and replace my "undecidable" with "uncanocialisable"
17:30:32 <wy> mmorrow: because I'm a graduate student ;)
17:30:53 <mmorrow> wy: my opinion is unchanged :)
17:31:11 <sohum> ksf: sorry?
17:31:13 * ksf in generally does't care about non-terminating programs, even if they compile...
17:31:22 <copumpkin> ksf: httpd?
17:31:30 <Cale> At the university I went to, there are separate group theory, ring theory and field/Galois theory courses.
17:31:38 <ksf> copumpkin, go recurse on some codata.
17:31:47 <Cale> (rather than bunching them together into "abstract algebra")
17:31:48 <idnar> corecurse, you mean?
17:31:58 <sohum> and wouldn't some sort of graph-rewriting calculator decide that (y id) is the canonical form of (y id) ?
17:32:01 <sohum> *evaluator
17:32:09 <princezuda> Hey :)
17:32:35 <Cale> hello
17:32:38 <ksf> sohum, but you'd have to insert that as special knowledge, and even then won't ever catch every single non-terminating case.
17:32:46 <ksf> it's also known as the halting problem.
17:32:58 <ezyang> I'm reading through a Happstack.State sample source file... and I love how they say "This is a bit of lovely Template Haskell hackery that you really shouldn't think too hard about.  Suffice to say, you need to call this."  Do I /actually/ want to use Macid ^_^
17:33:25 <wy> mmorrow: I know undergrad course will be slow :) the model theory course is a graduate course
17:33:25 <benmachine> sshc: the fmap (:(fst . head $ rx)) acc
17:33:44 <benmachine> sshc: that is commented out, I think it'd work if it was ((fst . head $ rx):)
17:33:45 <mmorrow> Cale: i had two semesters of "abstract algebra", the first doing groups and some rings, the second doing more rings, then fields, and finally galois theory
17:33:51 <Cale> Model theory for us was crosslisted undergrad/graduate
17:34:21 <princezuda> Quick question I think this may be a simple solution to mysql escapes but I want to pass it by others. When I call the mysql data I use a variable. Now since the mysql data is connected to a variable couldn't you just use my_real_escape_string on that one variable instead of all the individuals and get the same result?
17:34:22 <sohum> ksf: no, as in, if you evaluate an expression, and you see an expression you've seen before, just rewrite the tail of the node containing the expression to the node containing what you've see before. I believe that's the theoretical basis behind lazy evaluation. and then you just have to detect cycles, which is P, and you're done
17:34:53 <mmorrow> wy: unfortunately all grad math classes will assume full knowledge of the equivalent of two semesters of abstract algebra, although possibly there's an accelerated abstract algebra course for grad students
17:34:57 <kmc> sohum, that's like common subexpression elimination
17:34:59 <sohum> ksf: it doesn't catch (\x. x x x) (\x. x x x), but it's entirely arguable that that expression doesn't /have/ a canonical form
17:35:20 <kmc> lazy evaluation is common subexpression non-generation
17:35:22 <ksf> yep. and there are infinitely many of those.
17:35:26 <sohum> kmc: possibly, I'm not too sure about the actual terminology.
17:35:27 <princezuda> Hello?
17:35:29 <Cale> princezuda: I'm not sure I understand your question. Which mysql binding are you using?
17:35:31 <erikc> copumpkin: im gonna throw in the towel early on osx64, the ghc build story is too much of a time sink for me
17:35:39 <copumpkin> erikc: :(
17:35:45 <kmc> the idea is that "let x = e in (x, x)" produces a tuple record which has two pointers to the same thunk for x
17:35:45 <Cale> princezuda: (This is presumably a Haskell question too? :)
17:35:51 <kmc> which then gets updated when x is forced
17:35:56 <copumpkin> erikc: did you have any trouble with .hc porting? it'd be nice to get some more evidence on that ticket of mine
17:36:33 <kmc> however if you write "(f 3, f 3)" instead of "let x = f 3 in (x, x)", a lazy language is not required to notice that you've duplicated work and un-duplicate it
17:36:47 <erikc> i didnt get there cause i couldnt build the host compiler to generate the .hc's cause i need to squeeze in -m32's in all sorts of places to get stuff working on snow leopard with the current ghc build
17:37:01 <ksf> ...haskell isn't lazy, it's non-strict.
17:37:17 <copumpkin> erikc: ah, you'd have to do the same thing I'm doing on leopard
17:37:39 <mmorrow> ksf: although not being lazy would be suicidal for an implementation's performance
17:37:42 <erikc> and ghc-cabal is doing a configure and spitting error: CPU you selected does not support x86-64 instruction set somewhere inside it
17:38:02 <sohum> ksf: right, but you were arguing by contradiction that my reasoning says that (y id) is a reasonable value because constructing it terminates.
17:38:03 <erikc> copumpkin: by selecting a gcc version right?
17:38:14 <ezyang> merf. Happstack.State is really complicated
17:38:23 <ezyang> I think I'm not going to use it (for now)
17:38:30 <copumpkin> erikc: I replaced my gcc with a script that calls a true gcc with -arch x86_64 ... you'll have to do the same thing with i386
17:38:42 <erikc> ah
17:38:53 <ksf> ...no I was arguing by analogy of (y id) and 1/3 that division is undecidable.
17:39:04 <copumpkin> it isn't a decision problem...
17:39:10 <sohum> ksf: then I have no idea where the analogy is meant to be.
17:39:21 <sohum> ksf: be a tad more explicit, please?
17:39:33 * ksf thinks he's abusing terminology again.
17:39:53 <ksf> the point is that you can't decide when to terminate.
17:40:12 <sohum> ksf: that matters for computation
17:40:20 <mmorrow> , "1/3"
17:40:21 <lunabot>  "1/3"
17:40:22 <EvilTerran> ksf, where does Rational fit into this?
17:40:46 <mmorrow> , vacuum (fix (0:))
17:40:48 <lunabot>  [(0,[1,0]),(1,[])]
17:40:50 <ksf> EvilTerran, on the same level as (y id) :: Expression
17:40:51 <copumpkin> is map undecidable then?
17:40:56 <copumpkin> :t map
17:40:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:41:24 <sohum> ksf: in maths, as long as it's a regular pattern, it's fine. and even some expressions which we define in ways other than their expansion are perfectly valid values, even though their expansions never seem to terminate
17:41:37 <wy> mmorrow: Do you know any good books about abstract algebra?
17:42:33 <mmorrow> wy: sure. what book are you using for the model theory course (so i can gauge what to recommend)?
17:42:59 <mmorrow> wy: or what's any other math book that you've used?
17:44:28 <ksf> let _|_ = 1/3 in...
17:45:04 <sohum> ksf: what's the argument you're trying to advance by that?
17:45:16 <wy> mmorrow: Model Theory: An Introduction by David Marker
17:45:49 <ksf> nothing, it's just that I'm failing to see the point of formalistic math, but that might well be a perspective thing.
17:46:32 <sohum> ksf: I mean, like I've put forward multiple times
17:46:53 <sohum> ksf: your 1/3 example has a finite representation in its ternary expansion
17:47:25 <ksf> but then you get other infinities.
17:47:28 <copumpkin> and further, you can compute with 1/3 in finite time easily
17:47:46 <copumpkin> 1/3 * 3 = 1 and I can figure that out in finite time
17:47:49 <Cale> ksf: Personally, I see formalism as kind of the "skeleton" of mathematics -- useful for ensuring that what you're saying actually makes any real kind of sense.
17:47:52 <mun> hi
17:47:57 <ksf> ...after all, 1/_3_ already hints at the suitable base to use.
17:48:04 <copumpkin> o.O
17:48:11 <copumpkin> base 9?
17:48:12 <ezyang> mun: hello!
17:48:14 <mun> can multiple patterns be matched in a case..of.. branch?
17:48:25 <ezyang> Yes?
17:48:25 <mun> e.g., by using some kind of or?
17:48:29 <ezyang> oh, I see
17:48:34 <Cale> mun: No, there's no 'or' for patterns.
17:48:42 <sohum> ksf: sure! but we know that each base is well-defined, and we know how to convert between one to the other and how to do maths in each base, so we can treat each instance of division as resulting in a finite number in its "home base"
17:49:03 <ksf> ...which is what rational numbers are about.
17:49:07 <sohum> ksf: precisely!
17:49:11 <mun> Cale, so does that mean i'd need to duplicate the RHS for each pattern?
17:49:19 <ezyang> These functions are /such/ a good idea :o) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8853#a8853
17:49:37 <Cale> mun: Yeah. If it's something complicated, you might use let or where to define it.
17:49:47 <mun> Cale, ok thanks
17:50:20 <ksf> (which will blow your stack quickly if you add up 1/1, 1/2, 1/3, 1/5, 1/7, 1/13)...
17:50:38 <sohum> ksf: there is no stack in mathematics
17:50:39 <benmachine> ksf: what's the problem with infinities anyway? you can represent any rational number finitely in base 10 if you also do the little dot notation
17:50:56 <mmorrow> wy: ok cool. this is good for "learning" http://www.amazon.com/Algebra-Michael-Artin/dp/0130047635/ref=sr_1_41?ie=UTF8&s=books&qid=1251679464&sr=8-41 , and these are good for "reference"  http://www.amazon.com/Algebra-Serge-Lang/dp/038795385X/ref=sr_1_25?ie=UTF8&s=books&qid=1251679443&sr=8-25    http://www.amazon.com/Algebra-Graduate-Texts-Mathematics-v/dp/0387905189/ref=sr_1_26?ie=UTF8&s=books&qid=1251679443&sr=8-26
17:51:14 <benmachine> (by finitely I mean using a finite amount of paper/ink)
17:52:34 <sohum> mmorrow: I'm supposed to be in a class learning from that first textbook /right/ /now/ ;)
17:52:43 <mmorrow> sohum: :)
17:53:21 <ezyang> aww, IO isn't an instance of MonadPlus
17:53:28 <SamB_XP> sohum: so ... which part isn't true?
17:53:36 <SamB_XP> you aren't in class, or you aren't learning from that book?
17:53:36 <wy> mmorrow: good books. Thanks.
17:53:58 <sohum> SamB_XP: the former. and that's just my personal laziness, don't read too much into it
17:54:24 <SamB_XP> wasn't planning on it!
17:54:29 <sohum> :}
17:54:50 <mmorrow> wy: no problem :)
17:55:19 <ski> `IO' shouldn't be in `MonadPlus' ..
17:55:20 <wy> mmorrow: Does the first one cover all of algebra, or just abstract algebra?
17:56:15 <davidL> mmorrow: what do you think about the dummit and foote book?
17:56:29 <mmorrow> wy: "algebra" usually means "groups, rings, fields, and galois theory", and then most other "algebraic _" fields build from there
17:56:47 <mmorrow> wy: so i guess it depends what you mean by "all of"
17:57:33 <mmorrow> wy: but i'd say they do (in the sense that they cover the "basics" (not to say it's basic, far from it))
17:58:03 <mmorrow> davidL: i've never seen/read that book actually, but i've heard people say they like it
17:59:38 <Cale> I haven't read it myself, but I've seen it and on an initial scan it looks quite good.
18:00:04 <Cale> (Dummit and Foote)
18:00:14 <Cale> another one to look at is Artin's Algebra
18:02:21 <sshc> benmachine: http://dpaste.com/87531/
18:02:35 <ezyang> How do I find out what the name of  "openFile: does not exist (No such file or directory)" exception is?
18:03:09 <sshc> benmachine: I've tried four ways of using ':'
18:03:27 <sshc> I have no clue why ghc is complaining
18:03:27 <ezyang> oh huh. According to Control.Exception they are all IOExceptions
18:03:52 <ezyang> have you tried parentheses?
18:04:01 <Cale> For some reason, our groups course used Gallian's book, which is nothing to write home about, and not so great about the non-groups material. Our rings course used Papantonopoulou which has sub-par typesetting... aside from that it's not terrible, but also nothing special.
18:05:35 <Cale> Dummit & Foote and Artin both look a lot nicer.
18:05:58 <ezyang> Oh sweet, System.IO.Error has classification mechanisms
18:06:10 <mmorrow> ah right, i forgot about Artin
18:06:57 <sshc> I pasted one of the errors wrongly
18:07:01 <mmorrow> wy: looking at the TOC of that model theory book, some "commutative algebra" stuff also looks relevant
18:07:02 <sshc> http://dpaste.com/87532/
18:07:09 <sshc> benmachine: http://dpaste.com/87532/
18:07:24 <mmorrow> wy: and commutative algebra is what algebraic geometry builds on
18:07:45 <ezyang> Why is one of the arguments for catchJust (e -> Maybe b) and not (e -> Bool)?
18:08:02 <mmorrow> (and commutative algebra builds on the base "algebra" stuff)
18:08:16 <kmc> :t catchJust
18:08:17 <lambdabot> Not in scope: `catchJust'
18:08:34 <wy> mmorrow: It seems that there is a lot...
18:09:00 <ezyang> :t Control.Exception.catchJust
18:09:01 <lambdabot> forall e b a. (GHC.Exception.Exception e) => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
18:09:14 <wy> mmorrow: Do all the "prerequisites" worth a semester's course?
18:09:23 <Cale> And well, a fair amount of commutative algebra is also built on algebraic geometry :)
18:09:38 <mmorrow> Cale: feedback loops ftw
18:09:41 <davidL> Cale: have you by any chance seen a solutions manual for dummit and foote?
18:09:50 <mmorrow> wy: basically, yeah
18:10:01 <Cale> I actually think it would be really nice to see a rings course which did a really good job of integrating an algebraic geometry perspective right from the start.
18:10:17 <mmorrow> Cale: me too
18:10:21 <kmc> ezyang, the IO action with which you continue after a successful catch might want some info from the exception
18:11:00 <kmc> the first function selects which exceptions to catch, and at the same time extracts that information
18:11:04 <kmc> that's my guess from the type anyway
18:11:15 <Cale> davidL: I can look for one...
18:11:23 <ezyang> kmc: hmmm, ok
18:11:29 <davidL> Cale: where would you look?
18:11:39 <ezyang> Since I don't care about what's in the exception, I guess I can use guard
18:12:13 <Cale> davidL: various places on the web, specifically for torrents :)
18:12:26 <wy> mmorrow: gosh. I guess this model theory course can push me really hard
18:12:33 <ezyang> so, now I have:
18:12:45 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8854#a8854
18:13:26 <ezyang> There's such a seductive allure to stay in the IO monad for too long :-/
18:14:36 <mmorrow> wy: heh
18:15:08 <kmc> how do i export everything in my module and additionally all of some module i imported?
18:17:56 <EvilTerran> kmc, "module Foo (module Foo, module Bar) where ...; import Bar; ...", i believe
18:18:05 <mmorrow> module Foo (module Foo, module Bar) where import Bar; ...
18:18:08 <mmorrow> heh
18:18:26 <mmorrow> EvilTerran: nice choice of identifiers
18:20:11 <EvilTerran> you too :P
18:20:43 <kmc> ah, tricky
18:20:43 <wy> mmorrow: but who I knows. I have met professors who teach everything from first principles ;)
18:20:47 <kmc> thanks
18:22:49 <mmorrow> wy: it looks like the model theory book'll motivate some of the algebra and vice-versa, which is nice
18:27:51 <Lycurgus> > version
18:27:52 <lambdabot>   Not in scope: `version'
18:30:27 <EvilTerran> @version
18:30:27 <lambdabot> lambdabot 4.2.2
18:30:27 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:32:11 <Lycurgus> the bare word works in the installed 4.2.2.1.
18:32:30 <ezyang> I've got some code that I need to get into the Either applicative, and I'm wondering if I should use "Right" or "pure"
18:32:34 <daz__> why would i be getting this..? Syntax error in import declaration (unexpected declaration ("unexpected symbol "Ddata.hs")
18:33:20 <kmc> ezyang, i'd use pure, so you don't have to change if you use another representation later
18:33:44 <kmc> (i assume the Either applicative instance acts the same as the Either monad)
18:34:18 <ezyang> Ok
18:36:34 <ezyang> :-( 'No instance for (Applicative (Either String))'
18:36:55 <ezyang> I wonder where this instance lives...
18:37:10 <copumpkin> Control.Monad.Error maybe (sadly)
18:37:45 <ezyang> no dice
18:38:21 <ezyang> http://hackage.haskell.org/trac/ghc/ticket/2316 seems relevant
18:39:00 <ezyang> looks like the patch hasn't landed yet
18:39:07 <ezyang> This makes me sad :-(
18:39:13 <ezyang> Ok, time to use the monadic equivalents
18:39:46 <ezyang> Or I guess I could define the applicative instance myself...
18:42:08 <ezyang> Went with defining it myself
18:49:22 <Cale> http://www.adequacy.org/stories/2001.10.14.163749.94.html -- ahahaha
18:50:50 <codolio> He's reading a book on abstract algebra to help with his kids' elementary school homework?
18:50:55 <ezyang> ho ho ho
18:51:34 <daz__> elementary school..... algebra ... nice..
18:51:46 <copumpkin> "In high school, I placed near the top of my Algebra II class, and aced the Math portion of the SAT with a 590."
18:51:55 <codolio> Durn New Mathists.
18:52:02 <mauke> did you see the poll?
18:52:47 <ezyang> I am amused by how many people bit
18:54:22 <codolio> That was pretty good.
18:54:27 <impl> "Personally I have extreme distrust of any book with a "Chapter 0." Any time you see that you know it is written by someone completely out of touch with reality. You know, like a geek, but not just an ordinary geek, but a geek who watches stuff like Japanese Cartoon Porn and Xena Warrior Princess. Of the few books I own which do have a Chapter 0, they are all of inferior quality and content. I suggest avoiding "zeroism" at all costs."
18:54:49 <impl> that entire thread is full of awesome.
18:56:10 <steiger_> impl: i disagree
18:56:26 <codolio> '"The pioneers in the field are heavy-hitters like Lagrange, Abel, Galois and Hilbert." Oh, really? If they're such "heavy-hitters," then why haven't I heard of ANY of them.'
18:56:50 <mauke> because he hasn't read the bible
18:57:07 <mauke> Abel was killed by Galois
18:57:23 <dolio> Was he?
18:57:27 <copumpkin> it was a coverup!
18:57:30 <copumpkin> that's what they want you to believe!
18:57:36 <dolio> Wasn't Galois killed in a duel?
18:57:41 * copumpkin posts to reddit.com/r/conspiracy
18:58:26 <kmc> over a woman no less
18:59:03 <dolio> Wikipedia says Abel died of tuberculosis.
18:59:35 <benmachine> sshc: if you're still there, discard the whole case acc and replace it with fmap ((fst . head $ rx):) acc
19:00:00 <benmachine> sshc: you should be fmapping over acc, not stack
19:00:18 <ezyang> I have a bad case of marching indents
19:00:53 <pastorn> is there a way to implement higher order functions on records?
19:01:07 <dmwit> pastorn: Not in the way most people want, no.
19:01:07 <pastorn> data Lol = Lol {counter :: Int}
19:01:10 <dmwit> However, check out funrefs.
19:01:18 <dmwit> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
19:01:30 <dmwit> ezyang: Time for a monad and/or HOF.
19:01:38 <pastorn> inc :: Lol -> Lol; inc l = l {countr <magicalOperator> (+1) }
19:01:49 <ezyang> dmwit: HOF?
19:02:14 <dmwit> higher-order function
19:02:19 <pastorn> dmwit: isn't there any language extensions?
19:02:21 <ezyang> mmm
19:02:36 <dmwit> Not that I know of.
19:02:43 <ezyang> aha, I want the Either monad
19:02:45 <dmwit> But FunRefs are usable in H98, so...?
19:02:58 <pastorn> it seems that the shear amount of annoyance would have caused one to be formed out of the constantly growing pool of frustration
19:03:15 <ezyang> hmm, but I need to be able to do IO actions
19:03:25 <dmwit> Unfortunately, only one person gets annoyed at a time.
19:03:33 <dmwit> And the problem isn't theoretically interesting. =P
19:03:38 <mmorrow> pastorn: i use this to generate lenses for me: http://moonpatio.com/repos/MkLenses.hs
19:03:52 <dmwit> ezyang: Either return them, or use EitherT IO.
19:04:26 <mmorrow> pastorn: (the comment at the bottom show example use in ghci)
19:04:29 <ezyang> I guess I really hsould try to avoid being in IO...
19:04:39 <mmorrow> pastorn: i then just paste it into my modules
19:04:42 <dmwit> ezyang: Whatcha doin?
19:05:00 <ezyang> dmwit: I'm writing a simple due collection application
19:05:09 <ezyang> dmwit: Mild persistence, some parsing, simple logic
19:06:12 <mmorrow> ezyang: does it find and dispatch a leg-breaker thug to the residence or place-of-work of those past due in a timely manner?
19:06:22 <ezyang> mmorrow: That is on the TODO docket
19:06:31 <mmorrow> ezyang: ah, good.
19:06:31 <Saizan_> mmorrow: is there a repo for hstidy?
19:06:45 <ezyang> Interestingly enough, it /is/ for a live-action roleplaying group
19:06:51 <mmorrow> Saizan_: its current most-recent form is included in derive-gadt
19:06:54 <ezyang> So it definitely could be arranged :-D
19:07:18 <Saizan> mmorrow: is there a repo for that?:)
19:07:20 <mmorrow> Saizan: although i really should update the hackage version (which i'd forgotten about and it surely bitrotted at this point)
19:07:35 <mmorrow> Saizan: why yes :) one sec
19:07:58 <mmorrow> Saizan: http://moonpatio.com/repos/derive-gadt/
19:08:13 <Saizan> mmorrow: heh, you never put a version range on haskell-src-exts, bad mmorrow!
19:08:14 <mmorrow> Saizan: direct link: http://moonpatio.com/repos/derive-gadt/tools/hstidy.hs
19:08:36 <mmorrow> Saizan: heh, that was before it was being actively updated
19:09:00 <gwern> hstidy?
19:09:25 <mmorrow> gah! i need to update derive-gadt's .cabal too since haskell-src-exts has a new version now
19:09:27 <mmorrow> sigh
19:09:36 <Saizan> mmorrow: thanks
19:10:12 <mmorrow> gwern: basically it just parses a module/type/expression/decls/pat with haskell-src-exts, and prettyprints it to stdout
19:10:21 <mmorrow> (takes input from stdin)
19:10:31 <gwern> hm. so it will get rid of wacky indenting and excess parens, basically?
19:10:35 <mmorrow> it's handy for viewing computer-generated haskell code
19:10:51 <ezyang> woot it works!
19:10:53 <mmorrow> gwern: it'll do that, yes
19:10:59 <pastorn> mmorrow: i don't understand, why is it :: Record -> (a, a -> Record) ?
19:11:32 <mmorrow> pastorn: it gives you the current value along with a function that'll take the updated value and give you back the updated record
19:12:28 <mmorrow> id = (\(a,k) -> k a) . fooL
19:12:38 <ezyang> Aight, here's my current iteration of my doCommand. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8855#a8855
19:12:44 <pastorn> hmm... this seems a bit backwards...
19:12:48 <ezyang> I'm kind of interested in stylistic tips/refactorings
19:13:08 <ezyang> (erm, remove kind of)
19:13:15 <pastorn> there should really be a record equivalient of modify
19:13:43 <ezyang> ooh, I don't need that "return undefined" anymore
19:13:51 <mmorrow> @type focus lens f x = let (a,k) = lens x in (k . f) a in focus
19:13:52 <lambdabot> parse error on input `='
19:13:55 <pastorn> so higher order functions could be passed and be applied to the correct part of the record
19:13:57 <mmorrow> @type let focus lens f x = let (a,k) = lens x in (k . f) a in focus
19:13:58 <lambdabot> forall t a b c. (t -> (a, b -> c)) -> (a -> b) -> t -> c
19:14:03 <gwern> ezyang: you've looked at hlint?
19:14:11 <ezyang> nope. Looking now
19:14:44 * ezyang crosses finger for cabal install 
19:14:49 <ezyang> failcakes
19:15:08 <Makoryu> ezyang: Hmm, is cabal install not working?
19:15:12 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8857#a8857
19:15:26 <mmorrow> @type let focus lens f x = let (a,k) = lens x in (k . f) a in focus :: (rec -> (a, a -> rec)) -> (a -> a) -> (rec -> rec)
19:15:27 <lambdabot> forall rec a. (rec -> (a, a -> rec)) -> (a -> a) -> rec -> rec
19:15:57 <ezyang> That's annoying.
19:16:20 <mmorrow> pastorn: perhaps auto-generating this next-level of functions would be a handy next-logical-step
19:16:26 <Saizan> ezyang: run cabal update first
19:16:32 <pastorn> mmorrow: yeah, i get that
19:16:36 <Saizan> ezyang: there's a new release that fixes that
19:16:43 <ezyang> ok, trying
19:16:53 <pastorn> but i don't like it
19:16:54 * mmorrow adds adding that to MkLenses to his TODO list
19:16:57 <Makoryu> ezyang: Always run cabal update before cabal install
19:17:19 * ezyang nods 
19:17:21 <pastorn> it means more code, it would be way better to just have a better record syntax
19:17:24 <mmorrow> pastorn: what don't you like about it?
19:17:38 <mmorrow> pastorn: right, but we don't :(
19:17:47 <pastorn> mmorrow: the length it consumes:
19:18:19 <pastorn> f rec = rec { field = coolModifyingFunction (field rec) }
19:18:21 <mmorrow> pastorn: but it's auto-generated, which is what the compiler would be doing for any such better record syntax anyways
19:19:06 <ezyang> whoo, it installed
19:19:08 <mmorrow> pastorn: um, right that's the horror that MkLenses tries to get past :)
19:19:20 <Saizan> dmwit: the problem of how to fit a good record syntax in haskell is quite theoretical interesting, there's many papers about it :)
19:19:37 <dmwit> =)
19:20:33 <mmorrow> omdify f rec = rec {myReallyUnnecessarilyLongName = (myReallyUnnecessarilyLongName rec){omfgThisOnesLongToo = f (omfgThisOnesLongToo (myReallyUnnecessarilyLongName rec))}}
19:20:53 <Saizan> s/syntax/system/
19:21:12 <Saizan> (they are type system extensions)
19:21:37 <mmorrow> vs.   focus fooL (focus barL f)
19:21:45 <mmorrow> (focus fooL . focus barL)
19:22:36 <pastorn> mmorrow: i'm looking at the example, but i can't see it!
19:22:45 <mmorrow> pastorn: can't see what?
19:22:45 <pastorn> gimme linen numbers, pl0x
19:22:52 <pastorn> usage; http://moonpatio.com/repos/MkLenses.hs
19:22:58 <pastorn> *line*
19:22:59 <mmorrow> @type let focus lens f x = let (a,k) = lens x in (k . f) a in focus :: (rec -> (a, a -> rec)) -> (a -> a) -> (rec -> rec)
19:23:00 <lambdabot> forall rec a. (rec -> (a, a -> rec)) -> (a -> a) -> rec -> rec
19:23:27 <pastorn> hmm...
19:23:28 <ezyang> ok, fixed all hlint errors
19:23:41 <ezyang> the doCommand still looks like it could be improved though
19:24:04 <pastorn> mmorrow: AHA!
19:24:08 <mmorrow> pastorn: :)
19:24:12 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8855#a8859 (bottom)
19:24:36 <pastorn> rec { fld = f (fld rec) } --> focus fldL f
19:24:42 <mmorrow> exactly
19:24:42 <pastorn> rec { fld = f (fld rec) } --> focus fldL f rec
19:24:44 <pastorn> i mean
19:25:10 <pastorn> still, a bit confusing
19:25:21 <pastorn> well, obfuscating might be the word i'm looking for
19:25:41 <pastorn> or maybe it's my sleep depravation that's talking now
19:26:03 <mmorrow> pastorn: yeah true, but i think lenses are elegant once the wtf blows over
19:26:39 <pastorn> but still, a record extension that allows applying of HOFs to arbitrary fields would be totally sweet
19:26:40 <defun_> what languages, besides C and C++, can garbage collectors be written in?
19:26:48 <mmorrow> pastorn: definitely
19:26:49 <copumpkin> defun_: any language
19:27:05 <pastorn> defun_: what do you want to collect?
19:27:30 <kmc> defun_, SICP has a compiler in Scheme from Scheme to a VM implemented in Scheme with a GC written in Scheme
19:27:43 <kmc> because that's just the way they roll
19:27:43 <defun_> copumpkin: wait. I thought that GCs had to be written in unmanaged languages?
19:27:59 <mmorrow> defun_: but if you're implementing a language/interpreter that you want total control over, you can't write it in a GC'ed language
19:28:18 <mmorrow> defun_: only if you want control over all memory use
19:28:18 <defun_> That's what I'm talking about.
19:28:53 <defun_> What other non-gc'd langs are there?
19:29:02 <mmorrow> defn: here's a Cheney gc in haskell http://moonpatio.com/repos/Cheney.hs
19:29:05 <Makoryu> defun_: Um. Plenty.
19:29:06 <copumpkin> assembly, fortran, D, etc.
19:29:13 <Makoryu> defun_: The entire Pascal family
19:29:26 <Makoryu> GC can be disabled in D and Ada
19:29:49 <Makoryu> Oh, and Cobol, I think
19:29:54 <kmc> jhc compiles haskell without gc
19:30:06 <luis> Forth
19:30:06 <defun_> That is news to me...
19:30:38 <mmorrow> kmc: it uses boehm, and even so 50% of the time you consume all GB of your mem
19:30:43 <defun_> Can GC be disabled in GHC?
19:30:50 <Saizan> no
19:31:07 <Saizan> there are flags to control it
19:31:09 <Makoryu> defun_: Don't see what would be the point of that.
19:31:17 <Saizan> but you can't disable it completely
19:31:24 <Makoryu> defun_: Haskell programs won't run for very long without a GC
19:31:24 <kmc> so the concepts of "no explicit deallocate" and "garbage collected" should be distinguished
19:31:25 <defun_> Makoryu: just wondering.
19:31:33 <kmc> the former is a language feature, the latter is one way of implementing it
19:31:46 <kmc> another way is to pause the program, buy more memory, install it, and resume :)
19:31:57 * ezyang snerks 
19:32:23 <ezyang> "and if you were running 32-bit, you might have to Ksplice your kernel into 64-bit mode"
19:32:29 <kmc> sounds easy
19:32:56 <defun_> Can C garbage collect itself from within itself?
19:33:05 <copumpkin> defun_: ??
19:33:10 <copumpkin> "itself"?
19:33:21 <kmc> libgc is implemented in C in'nit?
19:33:21 <copumpkin> its own code?
19:33:21 <defun_> one sec
19:33:52 <defun_> ok.
19:33:52 <defun_> C can be used to make garbage collectors
19:33:52 <defun_> here is my logic
19:34:09 <defun_> C is not garbage collected
19:34:10 <ezyang> bootstrapping folks!
19:34:54 <dmwit> defun_: Just crawl through all of memory, consider any word-aligned data to be a pointer, and GC what's left.
19:34:54 <defun_> I think my mind is looping... hold on.
19:35:09 <dmwit> old hat =)
19:35:22 <mmorrow> defun_: there's also a big distinction between "accurate" and "conservative" GC
19:35:36 <copumpkin> defun_: where are you going? :)
19:35:42 <kmc> so you have a freestore, and code which manipulates it
19:35:48 <kmc> said code can be written in C, always
19:35:48 <defun_> what?
19:35:51 <ksf> what happens with writes to TVars that can never be read?
19:35:52 <mmorrow> defun_: in any language where you can arbitrarily manipulate and or squirrel away ptrs, you can't have "accurate" GC
19:36:23 <defun_> I see.
19:36:26 <kmc> allocation is one kind of manipulating, and garbage collection is another
19:36:28 <ksf> ...I'm not worried that they fail, but that they might be more heavy-weight than I wish.
19:36:47 <kmc> if your garbage-collecting code also has to do some allocation, you have to think carefully about it
19:36:48 <defun_> I see.
19:36:48 <defun_> oh it makes sense.
19:37:48 <ksf> writing a simple gc is quite easy and a fun exercise.
19:37:51 <mmorrow> defun_: and additionally with (e.g.) C, since you can do *((int*)42), the entire memory space is "live" at all times
19:38:07 <mmorrow> which is the real root of the problem wrt "accurate" GC
19:38:07 <defun_> live?
19:38:15 <kmc> "can we write a GC in C" and "can we write an accurate GC *for* C" are totally different questions
19:38:16 <mmorrow> defun_: reachable/live/not-dead
19:38:25 <kmc> the answers are "yes" and "not a chance" :)
19:38:25 <defun_> ok
19:38:28 <dolio> Makoryu: Certain Haskell programs could run without GC. If you take a lot of care to write such that everything can live in registers/on a stack, and maybe use some mutable arrays, you can write programs that never do enough allocation to need GC.
19:38:41 <chessguy> :t lift id
19:38:42 <lambdabot> forall a (t :: (* -> *) -> * -> *). (MonadTrans t) => t ((->) a) a
19:38:51 <chessguy> :t liftM id
19:38:52 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
19:39:03 <ksf> someone here claimed that jhc doesn't have a gc, at all, but uses a region-based scheme
19:39:39 <pastorn> mmorrow: so will just {-# LANGUAGE TemplateHaskell #-} give me the possibility of using the function 'focus', just like that, no questions asked, for all my record datatypes?
19:39:39 <defun_> So I can write a language/compiler (theoretically speaking), in haskell /and/ write the runtime and gc of that hypothetical language?
19:39:52 <dolio> That's true, but the region inference doesn't do well enough, so in practice, you need to link it with the boehm C garbage collector.
19:40:06 <dolio> Last I heard, at least.
19:40:22 <kmc> defun_, the runtime would have to be written in a way to link to the compiled code
19:40:22 <defun_> *by haskell I mean GHC haskell
19:40:26 <ksf> if you implement your runtime in haskell, you don't need to write a gc, as you already got one.
19:40:34 <kmc> so it depends much more on what you compile to, than what your compiler is written in
19:41:31 <ksf> (assuming that your language asks haskell for memory and doesn't do any nasty things with the cpu, by itself)
19:41:31 <defun_> so I write a compiler for LangX in haskell. And then I want to write and compiler for LangX in LangX... then what?
19:41:31 <defun_> The runtime is LangX instead of haskell?
19:41:32 <mmorrow> pastorn: well you have two options. the first is to simply prettyprint the code out in ghci, then paste (which is my preferred method, since then you don't need a TH dep in your code), OR you can use {-# LANGUAGE TemplateHaskell #-} + do at the top-level  $(mkLensesQ ''MyType) in which case those top-level functions will be spliced in (and re-generated *every* time you compile
19:42:03 <ksf> defun_, in the end, every runtime is written in cpu opcodes.
19:42:13 <ksf> ...even libc is.
19:42:27 <kmc> in the end everything is written in quantum field theory
19:42:31 <kmc> including you :O
19:42:32 <defun_> Ah! So runtimes are cpu specific
19:42:47 <ezyang> defun_: parts of them are
19:42:52 <kmc> defun_, no, GHC can produce portable C code from haskell, including the runtime
19:42:54 <ezyang> You try to stay out of asm as much as possible
19:43:24 <dolio> And the LHC guys will tell you that pure region inference will never be good enough on its own, and needs to be at least suplemented by a GC, which is why they were planning on making one when they were still hacking on a jhc fork.
19:43:24 <defun_> but at some point asm is inevitable?
19:43:30 <ksf> well, C is a cross-platform assembler.
19:43:38 <pastorn> mmorrow: when is haskell' coming out?
19:43:40 <pastorn> PLZ!
19:43:51 <ezyang> defun_: Yes.
19:43:58 <kmc> is there an exhaustive list of Haskell compilers somewhere
19:43:58 <mmorrow> pastorn: hehe
19:44:29 <defun_> How does C-- compare to C? Can a runtime be written in that? I mean partially?
19:44:46 <Makoryu> defun_: Either your program gets compiled to ASM, or it gets run by an interpreter which itself has been compiled to ASM
19:44:54 <ksf> http://www.haskell.org/haskellwiki/Implementations
19:45:00 <copumpkin> defun_: GHC's is :P
19:45:06 <copumpkin> (partially)
19:45:18 * ksf wonders why lhc isn't listed.
19:45:19 <defun_> Ah ha.
19:45:36 <kmc> ksf, thanks
19:45:44 * dmwit votes ksf fixes it
19:45:47 <kmc> "[Hugs] is certainly the best system for newcomers to learn Haskell. "
19:45:48 <ksf> probably because no one of the lhc devs registered a wiki account before it was too late.
19:45:49 <kmc> NPOV!
19:45:51 <Saizan> (from the outside it seems like you've organized a complicated scheme to maximally confuse defun_'s ideas about compilers)
19:46:07 <copumpkin> Saizan: lol
19:46:18 <ksf> most implementations are quite experimental and research-oriented, though.
19:46:22 <copumpkin> defun_: did you have a particular question that we can answer directly?
19:46:36 <defun_> I'm not sure anymore...
19:46:40 <copumpkin> oh no
19:46:43 <copumpkin> :)
19:47:07 <kmc> anyone know which of the compilers is the smallest in codebase?
19:47:33 <Makoryu> kmc: PFHC, the Purely Fictional Haskell Compiler
19:48:11 <Berengal> Makoryu, IPHC is smaller. It uses 6-point sized fonts
19:48:21 <Berengal> (Invisible pink haskell compiler)
19:48:28 <copumpkin> omg, like, totally
19:48:33 <Makoryu> Berengal: Well played, sir
19:48:38 * Makoryu sips brandy
19:48:59 <bd_> The haskell report is much shorter than any other implementation I know. Only problem is we don't have an interpreter for the language the Report is written in... :)
19:49:25 <Berengal> bd_, yes we do, but they're rather unreliable
19:49:40 <Makoryu> bd_: ..... You could probably translate it to Perl 6....
19:51:08 <ksf> what about "LHC initially started off as a fork of JHC, but changed toward being an alternative GHC backend, performing aggressive whole-program analysis on GHC's Core."?
19:51:40 <copumpkin> GHC's external core  maybe?
19:51:59 <ksf> ...external core language.
19:52:28 <ksf> http://www.haskell.org/haskellwiki/Implementations#LHC
19:54:47 <defun_> Does anyone here have any knowledge of how BitC is implemented? I haven't looked at it, but is seems that it is trying to merge concepts from C and (Haskell/ML/etc). To what point is this feasible or practical?
19:55:18 <defun_> * in other words, who'd want to use it?
19:56:11 * ksf thought it was a zombie project.
19:56:11 <mmorrow> defun_: it's a whole-program compiler, which transforms its input lang into C, and additionally uses dynamic-gen of (fixed) short stub machine code+data snippets to implement first-class "procedure objects"
19:56:12 <Makoryu> defun_: Anyone who wanted to do systems programming in something nicer than C.
19:57:00 <mmorrow> defun_: since it's a whole-program compiler (the current implem), it takes reaaaaally long to compile. i like the idea though.
19:57:01 <kmc> C++1x has lambda
19:57:37 <defun_> mmorrow: procedure object?
19:57:37 <defun_> mmorrow: why do you like it?
19:58:23 <ksf> in the end, you don't really need a project that encodes assembly, because a) there already is c, which is just fine for bootstrapping+portability, b) supporting x86 + arm (+ ppc) gives you all what people are going to demand, ever.
19:58:36 <mmorrow> defun_: the "procedure objects" use the basically use the idea that this code uses http://moonpatio.com/repos/cclos/ (which is the same basic idea as any code that constructs C function ptrs at runtime which assoc a C function to some private data)
19:58:55 <Cale> kmc: Hooray! Welcome to the 1970's C++ ;)
19:58:56 <chessguy> umm...silly question, is there a better name for "modify id"?
19:59:12 <mmorrow> defun_: the bitc runtime doxygen docs are handay http://www.bitc-lang.org/browse/libbitc/index.html
19:59:15 <chessguy> :t modify id
19:59:16 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m ()
19:59:21 <Cale> chessguy: return () ?
19:59:24 <pastorn> mmorrow: http://hackage.haskell.org/trac/haskell-prime/wiki/ExistingRecords
19:59:27 <mmorrow> defun_: e.g. http://www.bitc-lang.org/browse/libbitc/x86__64_2make__procedure__object_8c-source.html
19:59:32 <kmc> Cale, they also have this magical way to figure out the types of things without writing them!
19:59:41 <pastorn> mmorrow: one page down, "foo { x \ }
19:59:46 <Cale> hehehe
19:59:52 <pastorn> mmorrow: which would be
19:59:54 <chessguy> that probably is cleearer, Cale
20:00:16 <dolio> chessguy: Probably more efficient, too. :)
20:00:21 <pastorn> myRecord { myField \ funThatIsApplied }
20:00:28 <leimy> hmm
20:00:41 <mmorrow> pastorn: hmmmm, interesting
20:00:47 <ManateeLazyCat> If a type is use binding to C struct in low-level C library. Can i instance Binary for this type? IMO, i think we can't, because Haskell binding to C struct just make Haskell access address of C struct, example, we can just get/set some attribute of this struct, so we can't instance Binary for C struct, my point is right?
20:00:47 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
20:00:57 <leimy> I wonder if Galois hires remote employees :-)
20:00:58 <defun_> thanks.
20:01:03 <pastorn> mmorrow: wouldn't that be t3h awsumz?
20:01:28 <mmorrow> pastorn: that would be nice for sure
20:01:45 <Makoryu> ManateeLazyCat: Has anyone really been far even as decided to use even go want to do look more like?
20:01:52 * chessguy is really liking the way this looks
20:02:09 <Saizan> yeah, having \ would totally change the way i look at haskell code ;)
20:02:36 <ManateeLazyCat> I try to keep Gtk+ states even main program recompile/reboot.
20:02:56 * ksf wonders whether inotify is properly thread-safe
20:03:00 <ManateeLazyCat> But i found i can't instance Binary for gtk2hs instance for keep state.
20:03:15 <chessguy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8862#a8862
20:04:02 <ManateeLazyCat> If i can instance Binary for gtk2hs type, i can use `dyre` keep this state. That's, your GUI program won't lost it state even it recompile again.
20:04:58 <ManateeLazyCat> This is very useful that use dynamic reconfigure for big project development.
20:06:19 <ManateeLazyCat> Example, you write new module, just dynamic plus this module to project for recompile, and then reboot new entry, you can test new module after reboot, and important is states in others module haven't lost.
20:06:24 <Saizan> ManateeLazyCat: is there a Storable instance for this C struct?
20:07:01 <Saizan> "for the haskell type corresponding to this C struct"
20:07:30 <Saizan> also, that struct may have pointers to gtk's internals, that might not be valid on the next run
20:08:11 <ManateeLazyCat> Saizan: gtk2hs is use c2hs to binding Haskell to C, it use Ptr point to struct address if c2hs found C struct.
20:08:30 <Saizan> ManateeLazyCat: right, i know
20:08:39 <ManateeLazyCat> Saizan: So if i keep Pointer address, that will not valid value before reboot.
20:09:04 <ManateeLazyCat> Saizan: So i think use Haskell build low-level struct, just use gtk2hs for UI rendering.
20:09:09 <kmc> @pl \m g -> m >>= return . g
20:09:09 <lambdabot> (. (return .)) . (>>=)
20:09:10 <Saizan> ManateeLazyCat: what i meant is that through the pointer you could copy the values of the C struct
20:09:25 <ksf> heh. there's actually _two_ inotify bindings, one with a blocking poll interface, the other one comes with a poll thread and a dispatch thread.
20:09:38 <Saizan> ManateeLazyCat: i'd rather have a pure model of the state of your application in haskell
20:10:03 <Saizan> ManateeLazyCat: and render that with gtk2hs, without messing with gtk's low-level structs
20:10:10 <kmc> @pl \g m -> m >>= return . g
20:10:10 <lambdabot> fmap
20:10:13 <copumpkin> kmc: fmap
20:10:14 <kmc> haha
20:10:19 <kmc> :t fmap
20:10:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:10:24 <copumpkin> :)
20:10:28 <copumpkin> or liftM, more precisely
20:11:05 <kmc> oh right
20:11:06 <kmc> thanks
20:12:13 <ksf> how come http://hackage.haskell.org/cgi-bin/hackage-scripts/package/system-inotify doesn't show up in the package list?
20:13:08 <ManateeLazyCat> Saizan: Yep, i can use Pointer to get value from gtk C struct, but it's big problem, if low-level C struct change content (example, update C library), i need change Haskell code, even i don't use this update.
20:13:39 <ManateeLazyCat> Saizan: And i read Yi source code, i found it use Haskell keep pure state model, just use gtk render result.
20:14:19 <Cromulent> ksf: maybe because it is deprecated?
20:14:44 <ksf> oh.
20:15:01 <ksf> should be in red and bold and flashy and stuff.
20:15:09 <Cromulent> hehe :)
20:16:11 <daz__> why wont haskell let me import a .hs file. It starts with a capital letter, and it is in the same folder as my script.
20:16:48 <dibblego> Haskell imports modules, not files
20:17:06 <Saizan> daz__: do you have "module <FileNameWithout".hs"> where" at the top of it?
20:17:20 <ezyang> Is it possible to have System.Console.GetOpt accept interspersed flags?
20:17:26 <ezyang> As in "foobar bar baz --verbose"
20:17:29 <daz__> it is a module. first line of it is module Filename.hs where (contents)
20:17:46 <Saizan> daz__: you need to remove the ".hs"
20:17:59 <daz__> does it think its a directory?
20:18:02 <ezyang> Aha: Permute!
20:18:08 <ManateeLazyCat> Saizan: Thanks for your help. I think i need redesign to make Haskell keep pure state, and just use gtk rendering state.
20:18:20 <Saizan> or maybe paste the complete error so we can stop guessing :)
20:19:20 <Saizan> ManateeLazyCat: i didn't help much :) that's what xmonad does
20:20:01 <ManateeLazyCat> Saizan: XMonad use Haskell keep pure state then use X11 binding to render state ?
20:20:11 <daz__> sweet. Yea it doesn't want the .hs extension. This stupid book says otherwise.
20:20:32 <Cromulent> daz__: which book?
20:20:40 <Saizan> ManateeLazyCat: yes
20:21:45 <daz__> its a crappy book a lecturer gave to me, It was written like in 98-99 so its probably something that has changed with the updates of hugs versions.
20:21:57 <dibblego> title and author?
20:23:45 <ManateeLazyCat> Saizan: I really need to research Yi or XMonad deeply before design, now i need rebuild all project for dynamic reconfigure. :( Current, i use gtk low-level struct to keep state, and that's a big problem to keep state through reboot.
20:23:46 <SamB_XP> daz__: well, I've never heard of a version of hugs like that, then again I haven't used a hugs that wasn't called "hugs98", so ...
20:24:47 <ManateeLazyCat> Saizan: Have you use c2hs deeply?
20:24:48 <daz__> its not a book its a study guide they have written..
20:25:08 <SamB_XP> daz__: give it back!
20:25:18 <daz__> I have found heaps of tiny mistakes in it,
20:25:21 <SamB_XP> tell them to study some more
20:25:53 <Saizan> ManateeLazyCat: no, not much
20:26:59 <Saizan> many professors like when students send erratas, just like open source projects like patches :)
20:27:26 <ManateeLazyCat> Saizan: Do you know anyone expert c2hs, I have problem with c2hs, i know dccout, but dccout is really busy people that haven't time to handle those little problem.
20:28:26 <Saizan> ManateeLazyCat: no, sorry, if it's gtk related you could try asking on the gtk2hs mailing list
20:28:39 <daz__> yeh im not going to aye, because my lecturer has just taken this old lecturers notes and told us to learn them. I have corrected the mistakes in the notes as i gone along. I may give it back to her at the end of the semester and say heres your mistakes, you can tidy them up.
20:29:26 <ezyang> Am I doing it wrong if 40% of my Main.hs is devoted to option parsing and other command line boilerplate?
20:29:30 <Zao> Why defer it all to the end?
20:29:46 <ManateeLazyCat> Saizan: Yep, i have ask it, but haven't response. Maybe just minority people expert c2hs.
20:30:29 <SamB_XP> ManateeLazyCat: if it's just a c2hs question you could ask on -cafe ?
20:30:44 <ezyang> night all
20:31:43 <ManateeLazyCat> SamB_XP: Yep, i will, -cafe is the last ditch for ask Haskell question. :)
20:42:52 <hackagebot> colour 2.3.1 - A model for human colour/color perception (RussellOConnor)
20:47:27 <Saizan> colour/color ?
20:47:57 <dancor> also is it really a model of perception
20:48:08 <dancor> it makes it sound different than what it is imho
20:48:13 <dancor> imho/imo
20:48:19 <copumpkin> ?
20:48:39 <dancor> @vixen ?
20:48:40 <lambdabot> ?
20:50:53 <Cale> dancor: it really does appear to be, yes
20:51:14 <vav> hehe, re. errata, dropped off several pages worth for algebra text to instructor (her advisor was author.) She sighed, put them on a pile of ~100 pages from other students who'd done the same and asked if I was any good with latex.
20:51:27 <Cale> dancor: It supports the CIE colour spaces, which are perceptual models.
20:55:33 <defun_> What are some good books/papers/articles about Type Systems? (in general, not specific to Haskell).
20:56:16 <Saizan> defun_: TAPL and ATTAPL
20:56:23 <Cale> The standard suggestion to start with are the books by Pierce...
20:56:24 <Cale> yes
20:56:53 <SamB_XP> what does TAPL run these days?
20:56:54 <defun_> thanks.
20:56:57 <SamB_XP> $50? $100?
20:57:27 <Cale> Mine was a gift, so I'm not sure.
20:57:38 <SamB_XP> awesome
20:57:41 <Saizan> i got mine at ~40€
20:57:55 <nvoorhies> closer to $50 I think, at least mine was a couple years ago
20:58:01 <Adamant> get the international paperback version if it exists
20:58:02 <sjanssen> I bought a decent used copy for relatively cheap, I don't remember how much
20:58:13 <copumpkin> I got mine free from my library
20:58:26 <Saizan> the hardcover ones are quite pretty
20:58:38 <daz__> gotta scoot thnx for your help today.. I like this one for HS myself... found it easiest to understand.. http://book.realworldhaskell.org/read/getting-started.html
20:59:21 <Cale> I have a lovely PDF file of ATTaPL... I wish I could find the same for TaPL despite owning the hardcopy.
20:59:58 <copumpkin> Cale: interesting that they'd only make a pdf of one of them
21:00:36 <SamB_XP> copumpkin: I think they want people to buy TaPL or somethng ;-)
21:00:41 <copumpkin> dayum
21:00:51 <SamB_XP> ATTaPL doesn't really make much sense without it, I think
21:01:22 <copumpkin> ATTaPL is just a collection of articles
21:01:23 <Saizan> has anyone a nicer prettyprinter than haskell-src-exts' default?
21:01:50 <SamB_XP> yeah, you really need a foundation in the subject before you can understand those articles, though, I think ;-)
21:01:52 <bos> @seen dons
21:01:52 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
21:01:57 <bos> grump.
21:02:00 <copumpkin> SamB_XP: fair enough :)
21:02:12 <copumpkin> preflex: seen dons
21:02:12 <preflex>  dons was last seen on #haskell 8 hours, 44 minutes and 17 seconds ago, saying: oh, just use a string literal or  unlines
21:02:17 <SamB_XP> which, presumably, is what TaPL provides
21:02:25 <SamB_XP> or else people would not keep recommending it to others!
21:02:29 <copumpkin> preflex: seen Haji03
21:02:29 <preflex>  Haji03 was last seen on #haskell 1 day, 2 hours, 36 minutes and 35 seconds ago, saying: fuck all u niggers
21:02:31 <copumpkin> lol
21:02:38 <SamB_XP> I really need to get one sometime
21:02:44 <SamB_XP> but first, I need some money
21:03:52 <Saizan> well, you'll probably find quite a bit of TaPL redundant information at this point, though it's nice to have all of that together in a consistent exposition
21:03:55 <copumpkin> SamB_XP: your school library doesn't have it?
21:04:20 <SamB_XP> copumpkin: they don't have the current editions of TAOCP, afaict
21:04:33 <dibblego> @hoogle hex
21:04:34 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
21:04:34 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
21:04:34 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
21:04:51 <SamB_XP> they seem to have the pred-current editions
21:05:03 <dibblego> hex :: Int -> String -- f 15 = "F" ?
21:05:28 <Saizan> dibblego: try in the Numeric module
21:05:31 <dibblego> ta
21:06:12 <kmc> @pl \f x -> f x x
21:06:12 <lambdabot> join
21:06:17 <kmc> :t join
21:06:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:07:25 <Cale> Apparently there is an e-book version of TaPL, but it's a CHM file.
21:07:51 <ksf> forkIO $ forever $ (atomically (readTChan fifo >>= id) >>= id)
21:08:35 <ksf> try to do that in c!
21:08:40 <copumpkin> Cale: eww
21:09:08 <sshc> Hi, why is haskell inferring the wrong type in "http://dpaste.com/87560/"?  Errors are pasted in http://dpaste.com/87559/
21:09:15 <dibblego> ksf, (>>=) id = join
21:09:28 <ksf> haskell doesn't infer wrong types.
21:09:39 <ksf> :t (>>=) id
21:09:40 <lambdabot> forall a b. (a -> a -> b) -> a -> b
21:09:43 <sshc> ksf: I'm not sure what's wrong then
21:09:52 <copumpkin> ksf: backwards
21:09:58 <copumpkin> :t (>>= id)
21:10:00 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
21:10:15 <ksf> yeah, but those are different monads.
21:10:22 <ksf> uhm.
21:10:25 <ksf> err.
21:10:33 <ksf> ...the first thing I tried _was_ join.
21:10:37 <ksf> let me try again.
21:10:40 <copumpkin> (>>= id) is join for all monads
21:11:18 <copumpkin> damn, I've started being assertive on #haskell
21:11:18 <erikc> it's a shame sites like Safari usually dont have the right books
21:11:21 <dibblego> sorry, flip (>>=) id aka (=<<) id aka join
21:11:22 <kmc> ksf, it can infer less-general types sometimes, yes?
21:11:22 <copumpkin> does that mean I'm an intermediate haskeller now?
21:11:27 <Cale> sshc: What's the type of acc?
21:11:35 <kmc> if by "haskell" you mean ghc with all its extensions
21:11:59 * copumpkin proclaims himself a haskell sophomore
21:12:10 <Cale> sshc: It's Either String [a], right?
21:12:36 <Cale> sshc: and operator :: (...) => String -> [a] -> Either String [a]
21:12:45 <copumpkin> sophomore in the not-entirely-positive sense
21:12:58 <ksf> with type families, you sometimes don't get all strictly valid programs accepted, as loopy thingies can't get tested for type equality as they're thrown out to ensure termination.
21:13:06 <Cale> Supposing that x :: String, this means that operator x :: (...) => [a] -> Either String [a]
21:13:18 <ksf> ...but barring that, haskell prides itself in always inferring the most general type.
21:13:31 <Cale> and then fmap (operator x) :: (...) => Either String [a] -> Either String (Either String [a])
21:13:49 <sshc> Cale: yes, acc is of type Either String [a]
21:13:53 <Cale> (given that we're going to apply it to acc, I'm fixing the functor type ahead of time
21:14:08 <Cale> So, fmap (operator x) acc :: Either String (Either String [a])
21:14:33 <Cale> However, what's the type of Right $ (fst . head $ rx) : stack ?
21:14:47 <Cale> Well, it's Either t [s] for some t and s
21:14:56 <Cale> which doesn't match Either String (Either String [a])
21:15:04 <aavogt> @type join (undefined :: Either String (Either String [a]))
21:15:06 <lambdabot> forall a. Either String [a]
21:15:14 <dibblego> besides what is in Data.Char, there are no hex conversion functions?
21:15:22 <ksf> then forkIO $ forever $ join $ atomically $ join $ readTChan fifo it is.
21:15:32 <ksf> dunno what I tried, must have been wrong.
21:15:39 <Cale> join (fmap f x) = x >>= f
21:15:49 <ksf> the nasty bit is that it also typechecks without joins, but doesn't do anything.
21:15:52 <dibblego> ksf, forkIO . forever . join . atomically . join $ readTChan fifo -- is better form
21:15:57 <Cale> dibblego: Numeric
21:16:03 <centrinia> How do you have let-bindings inside a do-expression if you want to use the curly-brace and semicolon syntax?
21:16:03 <sshc> Cale: why should it be Either String (Either String [a])?
21:16:12 <sshc> why should it match that type?
21:16:14 <dibblego> Cale, is that on hackage?
21:16:16 * ksf doesn't like mixed . and $
21:16:29 <copumpkin> sshc: if you have a bunch of nested Eithers, why not just write your own ADT?
21:16:33 <Cale> sshc: Because that's the type which I painstakingly inferred for fmap (operator x) acc
21:16:37 <dibblego> Cale, sorry got it
21:16:43 <aavogt> > read "0xf" :: Int
21:16:44 <lambdabot>   15
21:17:04 <dibblego> > show 15 :: String -- :)
21:17:05 <lambdabot>   "15"
21:17:05 <Cale> copumpkin: It maybe be that he actually doesn't mean to have them though...
21:17:06 <roconnor> ksf: use `id` instead of $, that's what I do
21:17:15 <aavogt> > showHex 15 ""
21:17:16 <lambdabot>   "f"
21:17:19 <copumpkin> Cale: oh, I haven't been following :)
21:17:30 <Cale> er, "may be"
21:17:31 <ksf> ...but that might be a left-over from the times where I was still struggling with syntax.
21:17:34 <centrinia> Why does this have a parse error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8866#a8866
21:17:46 <centrinia> roconnor: I agree.
21:17:47 <copumpkin> centrinia: why would it be?
21:17:58 <dibblego> @type showHex
21:17:59 <lambdabot> forall a. (Integral a) => a -> String -> String
21:18:11 <dibblego> @info showHex
21:18:11 <lambdabot> showHex
21:18:15 <dibblego> @hoogle showHex
21:18:15 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
21:18:20 <centrinia> copumpkin: I don't know why it has a parse error. :(
21:18:43 <aavogt> centrinia: let { x = 42 };
21:18:45 <centrinia> It doesn't have a pars error if I remove the curly-braces. :p
21:18:50 <Cale> centrinia: Apart from the spurious empty statement at the end of the do-block (which I think is acceptable anyway), possibly it thinks the let is not being closed.
21:18:52 <centrinia> Oh. :p
21:19:25 <centrinia> Thanks.
21:19:40 <Cale> If you're going to use explicit braces, it's best to go all the way... :)
21:20:59 * ksf still wants variable bindings inside record constructors
21:21:20 <ksf> that is, { foo n = n } instead of { foo = \n -> n }
21:21:30 <Saizan> me too!
21:22:22 <ksf> ideally, the whole pattern matching thing.
21:22:26 <ksf> just like in a where.
21:22:47 <ksf> or just get rid of all that {,} stuff and use proper {;}-layout.
21:23:08 <Saizan> yeah, it should just use the same grammar as in let .. in
21:23:11 <A1kmm> hmm, it seems that Data.STRef.Strict.modifySTRef is actually lazy.
21:24:13 <Saizan> ksf: would you edit GHC's parser for me?
21:25:06 <ksf> Saizan, no. But I would point you to the h' trac and mailing list.
21:25:35 <Saizan> A1kmm: Data.STRef.Strict is the same as Data.STRef
21:25:40 * Cale thinks that h' is the wrong place to make changes like that
21:25:51 <Saizan> ksf: h' trac is useless until you've implemented the extension
21:25:57 <Cale> implement first, ask questions later
21:26:05 <A1kmm> Saizan: So is there a cleaner way to make it strict rather than to write my own version?
21:26:13 <SamB_XP> that does reduce the bikeshedding a bit
21:26:16 <A1kmm> modifySTRef' r f =
21:26:18 <A1kmm>     do
21:26:19 <A1kmm>       lastv <- S.readSTRef r
21:26:20 <A1kmm>       let
21:26:22 <A1kmm>           nextv = f lastv
21:26:23 <A1kmm>         in
21:26:25 <A1kmm>           nextv `seq` S.writeSTRef r nextv
21:26:28 <A1kmm> That does what I want, but it is ugly to have to do that.
21:26:37 <copumpkin> @hpaste please A1kmm in future :P
21:26:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:26:52 <Saizan> A1kmm: mail the libraries mailing list to add that to Data.STRef :)
21:26:53 <SamB_XP> and especially constrains the bikeshedding to bikeshedding which actually serves a purpose ...
21:27:08 <Cale> SamB_XP: Indeed, but(!) you have to be careful not to resist implementation changes just because they conflict with old standards. (though you'd want to ensure that a mode is always available for the last standard...)
21:28:47 <ksf> you could write the nextv ... on the same line as let and in, respectively.
21:33:54 * ksf discovers a whole new problem space: concurrent data structures.
21:34:22 <ksf> like just not being able to give indices because you don't know if the element you want to change still has that index.
21:36:32 <mikem`> isn't that what immutability solves?
21:37:18 <Cale> and/or transactions :)
21:37:26 <ksf> well, I've got a bunch of values in a list, which contain a thingie that if you call it triggers computation of more stuff, inside a separate worker thread.
21:37:34 <Asztal> A1kmm: if you want it less ugly, how about http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8867#a8867 ?
21:38:34 <ksf> e.g. imagine a gui view of 10000 files containing 1000000000 integers each, and you want to show the filelist fast and incrementally, and calculate sums-of-files that are able to be displayed first.
21:39:53 * ksf just can't resist maximally-zippy user interfaces
21:41:34 <ksf> ...thinking of it, I even want to unpriorize computations that have not yet been completed and who's display space has been scrolled off-screen.
21:41:58 <ksf> ...so I can't just trigger the computation fire-and-forget.
21:43:04 <ksf> Cale, still, even with transactions... passing mutation capabilities through other transactions tends to get quite mind-bending quite fast.
21:46:02 <Saizan> ksf: it looks like you need a runtime system sir
21:46:36 <ksf> ...so append :: DataStructure -> ((Element -> Element) -> Element) -> STM ()
21:47:00 <ksf> ...which means that an injection function passes you the capability to change the element, which makes sense.
21:47:50 <ksf> wait no there's a STM missing.
21:48:39 <ksf> append :: Structure -> (((Element -> Element -> STM ()) -> Element) -> STM ()
21:49:11 <ksf> ...something like that.
21:49:36 <ksf> typesig-based design doesn't always work.
21:54:34 <kmc> any style guidelines for using h98 versus GADT-style decls, in cases where either is possible?
21:59:07 <sohum> does haskell automatically memoize recursive functions?
21:59:23 <ksf> sohum, nope.
21:59:35 <ksf> it's undecidable in general whether it's a good idea to do that
21:59:46 <ksf> there's packages that do the memoisation automatically, though.
21:59:55 <c_wraith> The memocombinator package makes it trivial to do it yourself, though
22:00:02 <sohum> ksf: makes sense. then what's the idiomatic way to memoise?
22:00:13 <ksf> otoh, a bit of dynamic programming might help wonders.
22:00:18 <c_wraith> @hackage memocombinator
22:00:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/memocombinator
22:00:28 <c_wraith> heh.  I think that link is wrong
22:00:33 <sohum> ksf, c_wraith: I suppose I could just look at how the packages do it ;)
22:00:43 <ksf> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
22:00:44 <lambdabot>   Ambiguous occurrence `+'
22:00:44 <lambdabot>  It could refer to either `GHC.Num.+', imported fr...
22:00:52 <ksf> wtf
22:00:54 <sohum> ksf: what do you mean, re: dynamic programming?
22:00:54 <ksf> , let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
22:00:56 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
22:01:07 <ksf> ...reducing complexity.
22:01:24 <c_wraith> http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/Data-MemoCombinators.html
22:01:26 <ksf> there's a quite good wikipedia article about it, which also mentions fibonaccis
22:01:29 <c_wraith> there.  that's the real package :)
22:01:36 <ksf> (I bet you've seen the naive implementation)
22:01:48 <sohum> ksf: well, yea, that's kinda the point of memoisation
22:01:49 <kmc> @kind Bool#
22:01:50 <lambdabot> Not in scope: type constructor or class `Bool#'
22:01:55 <sohum> ksf: well, part of the point
22:01:57 <ksf> instead of throwing heavy type machinery at it to memoize, you could just use the fibs definition above.
22:02:17 <ksf> ...which does not memoize.
22:02:29 <c_wraith> > fix $ (0:) . scanl (+) 1
22:02:30 <lambdabot>   Ambiguous occurrence `+'
22:02:30 <lambdabot>  It could refer to either `GHC.Num.+', imported fr...
22:02:38 <Saizan> the purest form of dynamic programming is an optimization of memoization, by reordering the computations so that you don't need a memotable at all
22:02:38 <c_wraith> why is lambdabot broken?
22:02:41 <ksf> @undef
22:02:48 <ksf> > fix $ (0:) . scanl (+) 1
22:02:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:02:59 <c_wraith> did someone @let (+) ?
22:03:45 <Makoryu> @undefine
22:03:53 <Makoryu> @undef
22:03:57 <Makoryu> Oh right
22:03:59 <Makoryu> @unlet
22:04:00 <lambdabot>  Defined.
22:04:09 <copumpkin> o.O
22:04:16 <sohum> @unles (+)
22:04:16 <lambdabot> Unknown command, try @list
22:04:19 <sohum> @unlet (+)
22:04:19 <lambdabot>   Parse error
22:04:24 <mmorrow> , time (fix ((0:) . scanl (+1) 1) !! 1000000)
22:04:25 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = b -> a
22:04:33 <mmorrow> , time ((fix ((0:) . scanl (+1) 1)) !! 1000000)
22:04:34 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = b -> a
22:04:45 <mmorrow> , time (fix ((0:) . scanl (+) 1) !! 1000000)
22:04:47 <lunabot>  Stack space overflow: current size 8388608 bytes.
22:04:47 <lunabot>  Use `+RTS -Ksize' to increase it.
22:04:59 <c_wraith> that's amazing.  >_>
22:05:03 <mmorrow> , yeah
22:05:04 <lunabot>  luna: Not in scope: `yeah'
22:05:34 <Saizan> "don't index into an iterated list, ever."
22:05:57 <mmorrow> , let scanl' f !z (x:xs) = let !a = f z x in a : scanl' f a xs in time (fix ((0:) . scanl' (+) 1) !! 1000000)
22:06:03 <lunabot>  Killed.
22:06:05 <mmorrow> , let scanl' f !z (x:xs) = let !a = f z x in a : scanl' f a xs in time (fix ((0:) . scanl' (+) 1) !! 100000)
22:06:08 <lunabot>  (0.671897,499501046507192253972016382165016795490214569527090845885764636...
22:06:14 <copumpkin> zomg
22:06:49 <mmorrow> , time ((let go !m n = m : go n (m+n) in go 0 1) !! 100000)
22:06:52 <lunabot>  (0.491926,259740693472217241661550340212759154148804853865176965847247707...
22:07:04 <ksf> , let fibs = 0:1:zipWith (+) fibs (tail fibs) in length $ show (fibs !! 100000)
22:07:06 <lunabot>  20899
22:07:16 <copumpkin> I prefer the fix version
22:07:17 <mmorrow> , time ((    let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs ) !! 100000)
22:07:20 <lunabot>  (1.276807,259740693472217241661550340212759154148804853865176965847247707...
22:07:34 <mmorrow> looks like `go' takes the cake
22:07:41 <copumpkin> go ftw
22:07:41 <mmorrow> (speed-wise)
22:07:49 <mmorrow> i like the fix one too
22:08:06 <mmorrow> although `go' is pretty since it's so simple
22:08:32 <ksf> zipWith is going to have the pretties vacuum output
22:08:40 <aavogt> , [$ty|time|]
22:08:43 <lunabot>  forall a . a -> (Double, a)
22:08:55 <copumpkin> mmorrow: how about unfold?
22:08:56 <ksf> are those milliseconds, btw?
22:09:01 <mmorrow> ksf: not with (+) though
22:09:10 <mmorrow> ksf: seconds
22:10:59 <kmc> why are there both lambdabot and lunabot?
22:11:08 <kmc> lambdabot: explain yourself
22:11:13 <kmc> lunabot: explain yourself
22:11:27 <SamB_XP> kmc: well, they do different stuff, and lambdabot falls over a lot
22:11:48 <mmorrow> , let timeTo n a = time (a !! n) in timeTo 100000 (unfoldr (\(!m,!n) -> Just (m,(n,m+n))) (0,1))
22:11:50 <lunabot>  (0.543918,259740693472217241661550340212759154148804853865176965847247707...
22:11:54 <aavogt> , fix time
22:11:56 <lunabot>  luna: Occurs check: cannot construct the infinite type:
22:12:14 <mmorrow> , let timeTo n a = time (a !! n) in timeTo 100000 (let go !m n = m : go n (m+n) in go 0 1)
22:12:17 <lunabot>  (0.489925,259740693472217241661550340212759154148804853865176965847247707...
22:12:36 <copumpkin> > (fix succ :: Natural) > 3
22:12:37 <lambdabot>   True
22:13:13 <mmorrow> , let timeTo n a = time (a !! n) in timeTo 100000 (let scanl' f !z (x:xs) = let !a = f z x in a : scanl' f a xs in fix ((0:) . scanl' (+) 1)
22:13:14 <lunabot>  luna: parse error (possibly incorrect indentation)
22:13:17 <mmorrow> , let timeTo n a = time (a !! n) in timeTo 100000 (let scanl' f !z (x:xs) = let !a = f z x in a : scanl' f a xs in fix ((0:) . scanl' (+) 1))
22:13:19 <lunabot>  (0.683896,499501046507192253972016382165016795490214569527090845885764636...
22:13:55 <mmorrow> hmm, maybe there should be a function that does n runs and gives the (mean,stddev,variance,?)
22:14:11 <mmorrow> gah, lunabot need @let bad
22:15:20 <mmorrow> kmc: lunabot has template-haskell stuff, and some other things that lambdabot doesn't
22:15:28 <mmorrow> kmc: most notably, eval
22:15:41 <mmorrow> , eval "eval \"eval \\\"42\\\"\""
22:15:44 <lunabot>  <<Dynamic>>
22:15:54 <c_wraith> that's useful. :)
22:16:03 <kmc> shiny
22:16:40 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"eval \\\"42\\\"\"") :: Integer {- unfortunately unwrapping the Dynamics is a totaly PITA -}
22:16:43 <lunabot>  42
22:16:48 <Saizan> the question is, what does lunabot lacks? and, does it have a sane design so that it doesn't become a mess like lambdabot if we add it?:)
22:17:24 <mmorrow> in order of usefulness, lunabot needs/would-be-nice-to-have:
22:18:24 <mmorrow>  @let equivalent (defined as a regular haskell function of course, keeping with lunabot's philosophy), @let-but-for-data/class/instance/? (maybe even per-user too)
22:18:51 <mmorrow> i couldn't really think of anything off the top of my head, so the second one was kind of off-the-cuff
22:18:55 <mmorrow> :)
22:19:45 <mmorrow> i got @let for data/class/instance/function working actually, and per-user at that, but it's massively slow due to all the overhead it introduced
22:20:04 <mmorrow> i should clean that up and at least try it
22:20:15 <mmorrow> (be warned, it's a MASSIVE hack.. :)
22:20:45 <mmorrow> (MASSIVE in extent-o-hackery, not code)
22:21:52 <mmorrow> what else would be useful or cool (not necessarily in that order ;) for lunabot to have?
22:25:57 <Saizan> a working @google / @hackage / @wiki / @hoogle
22:26:06 <path[l]> whoa Im till connected
22:26:22 <path[l]> Is dons here?
22:26:28 <mmorrow> that'd be pretty slick if lunabot used an sqlite db to hold per-user modules full of their private @lets
22:26:32 <ManateeLazyCat> @seen dons
22:26:32 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
22:26:51 <path[l]> yeah we need a last spoke
22:26:58 <Saizan> preflex: seen dons
22:26:59 <preflex>  dons was last seen on #haskell 10 hours, 9 minutes and 4 seconds ago, saying: oh, just use a string literal or  unlines
22:27:11 <path[l]> I need performance help =p. But I keep missing him
22:27:26 <path[l]> He suggested one idea last time, but it didnt help
22:27:41 <mmorrow> [$ty| hoogle |] :: [(String,{-package-},String{-ident-},String{-Type-})]
22:27:51 <mmorrow> err
22:27:54 <jbauman> was his idea to just use a string literal or unlines?
22:27:57 <mmorrow> hoogle :: QuasiQuoter
22:28:04 <mmorrow> gah
22:28:17 <mmorrow> hoogle :: TypeQ -> [(String,{-package-},String{-ident-},String{-Type-})]
22:28:26 <mmorrow> hoogle [t| a -> Int |]
22:28:30 <mmorrow> would be cool
22:28:37 <path[l]> no he asked me to switch from a boxed array to an unboxed array
22:28:53 <path[l]> I was comparing my ruby code against its haskell port
22:29:10 <path[l]> and I got to the point where the haskell code was 30% faster. But thats still very very dissapointing
22:29:29 <path[l]> I think he was saying in general you could expect a 10-1000 times speed up
22:30:10 * ksf just spend half an hour fiddling around with the wrong side of them arrows.
22:30:36 <ksf> it's append :: Element -> STM ((Element -> Element) -> STM)
22:31:16 <ksf> it's so obvious that you can't pass a structure a function to modify one of its elements it's embarrassing.
22:36:33 <copumpkin> path[l]: what did the ruby code do?
22:36:45 <copumpkin> ruby's fast at two things
22:40:29 <path[l]> copumpkin: it was a branch and bound problem. Given a list, it was trying to partition it into 2 nearly equal sized lists where the sum of each part was as close to each other as possible
22:40:40 <path[l]> and rather than a heuristic the idea was to find an exact solution
22:40:45 <ksf> error:  No instance for (Control.Monad.Fix.MonadFix STM)
22:41:10 * Elly is trying and failing to prove a complicated property of Euclid's algorithm
22:41:22 <path[l]> this was the problem -> http://codechef.com/problems/teamsel
22:41:27 <path[l]> this was the ruby code -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3424
22:41:50 <path[l]> this was the haskell code -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3425 (I replaced the boxed arrays with unboxed but timing didnt change)
22:43:58 * ksf is unsure whether he hit a wall in stm or his mind.
22:44:27 <copumpkin> path[l]: codechef needs someone to tell them that java isn't an acronym
22:44:28 <ezyang> What methods are required to fully define Enum?
22:44:41 <copumpkin> ezyang: toEnum and fromEnum are sufficient iirc
22:45:06 <ezyang> ok
22:45:46 <copumpkin> path[l]: my intuition is that you'll need a slight change in approach to get really fast haskell code
22:46:05 <path[l]> hmm
22:46:08 <copumpkin> but -O2 is almost twice as fast isn't it?
22:46:21 <path[l]> well 2.36 to 1.6
22:46:21 <aavogt> you'll get warnings if you have left class methods undefined
22:47:11 <kmc> what is the easiest way to discover the cause of an infinite loop?
22:47:17 <kmc> ghci
22:47:21 <kmc> debugger seems useful
22:47:29 <kmc> but only if i can find a breakpoint inside the loop
22:47:31 <copumpkin> kmc: swear at it many times, usually helps for me
22:47:53 <aavogt> but you could still run into a case where the class defines default methods for everything in terms of the other methods
22:48:00 <copumpkin> brb
22:48:01 <Berengal> kmc, is it caught?
22:48:10 <kmc> um what do you mean
22:48:16 <path[l]> copumpkin: well part of the question was how Id solve the same problem in haskell. But Im surprised I need such a big change in approach
22:48:25 <path[l]> hey Berengal did you ever try that problem
22:48:28 <Berengal> Does the program stop with a <<loop>> exception?
22:48:37 <kmc> no, it hangs
22:48:41 <path[l]> ah he's back
22:48:41 <Berengal> path[l], I did, but not much. I got busy, and then I got ill :/
22:48:47 <path[l]> copumpkin: well part of the question was how Id solve the same problem in haskell. But Im surprised I need such a big change in approach
22:48:57 <Berengal> kmc, have you tried compiling it?
22:49:00 <path[l]> Berengal:  : ah ok :/, hope you're better now :)
22:49:12 <Berengal> path[l], no, I haven't slept since friday :(
22:49:28 <path[l]> ouch thats bad
22:49:31 <path[l]> flu?
22:50:09 <Berengal> kmc, if you get it to detect the loop and throw an exception, you can run it with +RTS -xc or something to get it to print where it was
22:50:09 <copumpkin> path[l]: also, I see you have no strictness annotations
22:50:11 <copumpkin> which could make a big difference
22:50:13 <copumpkin> path[l]: have you profiled?
22:50:17 <copumpkin> Berengal: !!
22:50:19 <kmc> Berengal, yeah, same behavior with ghci or compiled
22:50:25 <copumpkin> (that was me storming out of the channel in protest btw)
22:50:37 <kmc> hmm, is there some particular way to turn on loop detection
22:50:51 <kmc> ghc -fsolve-halting-problem
22:51:05 <copumpkin> it can in some restricted cases :)
22:51:14 <path[l]> copumpkin: I profiled and found 30% of time spent in gc ... but Im not sure where to go from there
22:51:19 <path[l]> whats a strictness annotation
22:51:46 <aavogt> @src seq
22:51:46 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:51:47 <kmc> like is there a way to print ghci's ":hist" as it evaluates?
22:52:06 <copumpkin> path[l]: just playing with it right now, will get back to you in a few :)
22:52:21 <path[l]> awesome thanks
22:53:55 <hydo> I've got a little problem and I'm curious if I'm approaching the solution correctly.  I'm (trying) to use a SQLite db in a web application and, as you might expect, I'm getting locking issues.  I've been working on converting the source that actually does the writing to use the reader monad to hold the database handle.  Problem is that I don't think that's going to solve the problem.
22:54:08 <hydo> since I have to init the state when I use the handle, thereby creating a new handle.
22:54:56 <hydo> Does anyone have an opinion on how best to solve this?
22:55:16 <Cale> Yeah, I don't see how the reader monad will help at all, over just passing the handle around explicitly.
22:55:28 <copumpkin> path[l]: you been @pling? :P
22:55:32 <Cale> What exactly do you mean by 'locking issues'?
22:55:59 <hydo> Cale: It was my mistaken understanding that the monad was initialized at the start of the program and thus it would hold one handle... obviously, this was flawed.
22:56:37 <Cale> Right, the reader monad is just a thin candy shell around functions and parameter passing.
22:57:00 <hydo> Cale: since it's a web application, I'm getting lost data when two threads try to write a value at the same time.  I'm trying to avoid writing a queue for writes though that might prove to be the best solution.
22:57:02 <path[l]> I dunno what that is. @pl
22:57:22 <Cale> hydo: I would have only one thread which was allowed to write to the database.
22:57:32 <Cale> (in that case)
22:57:52 <hydo> Cale: ok, so it's time for me to learn some haskell IPC, apparently. :)
22:57:54 <path[l]> oh pointless code
22:57:59 <path[l]> I think here and there
22:58:00 <path[l]> lol
22:58:04 <Cale> hydo: Nah, just a new datatype
22:58:05 <Makoryu> @pl map (head . words) . filter (not . null) -- path[l]
22:58:05 <lambdabot> map (head . words) . filter (not . null)
22:58:11 <Cale> hydo: See Control.Concurrent.Chan
22:58:15 <Makoryu> @unpl map (head . words) . filter (not . null)
22:58:16 <lambdabot> (\ c -> map (\ f -> head (words f)) (filter (\ i -> not (null i)) c))
22:58:28 <hydo> Cale: awesome, looking...
22:58:33 <Cale> hydo: But... before that, isn't this exactly the sort of problem that a database normally solves for you?
22:58:48 <Cale> hydo: Perhaps using a different DB driver would help?
22:58:55 <path[l]> copumpkin:  is it harder to read? I thought all the places where I used it was umm tasteful
22:59:03 <ezyang> I'm looking at Data.Time.Calendar... and I can't find a function to get the current date
22:59:12 <copumpkin> path[l]:  snd.minimum.(zip =<< map (abs . (-) total.(2*))) ? :P
22:59:32 <copumpkin> I can figure it out, but the lack of whitespace and odd (-) total thing is a little strange
22:59:35 <path[l]> haha ok maybe not
23:00:39 <path[l]> @unpl snd.minimum.(zip =<< map (abs . (-) total.(2*))
23:00:40 <lambdabot> Unbalanced parentheses
23:00:46 <path[l]> @unpl snd.minimum.(zip =<< map (abs . (-) total.(2*)))
23:00:46 <lambdabot> (\ d -> snd (minimum (((map (\ j -> abs (total - (2 * j)))) >>= zip) d)))
23:00:56 <copumpkin> path[l]: did you try looking at this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8870#a8870
23:01:06 <Cale> hydo: Which exact database library are you using?
23:01:42 <ezyang> aha, UTCTime is an algebraic type that contains Day
23:01:52 <copumpkin> path[l]: the basic point is that solve is where you want to be concentrating your optimization effort at first
23:02:03 <hydo> Cale: dons's sqlite
23:02:08 <aavogt> @hoogle getCurrentTime
23:02:08 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
23:02:08 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
23:02:31 <path[l]> ooh no I didnt. Which option was used to get that?
23:02:42 <path[l]> I just used -s
23:02:51 <copumpkin> path[l]: compile with -prof -auto-all , then run with +RTS -p
23:02:59 <copumpkin> the auto-all adds cost centers to all the top-level bindings
23:02:59 <Cale> hydo: sqlite is apparently supposed to be transactional...
23:03:12 <path[l]> -p just gives me a result
23:03:15 <path[l]> I dont get the graph
23:03:20 <path[l]> is it -pstderr ?
23:03:24 <copumpkin> path[l]: you can also add custom cost centers to other points in the code, if you want to see specifically what's getting called
23:03:26 <hydo> Cale: any idea what the conventional wisdom is between hsql/hdbc/etc.?  which one is the "you should use this" package?
23:03:30 <copumpkin> path[l]: it'll give oyu a file called x.prof
23:03:37 <aarong> anyone familiar with the fbsd ports system have a spare cycle to help me figure out a silly bootstrap build PATH issue?
23:03:42 <copumpkin> path[l]: that will likely contain something less detailed than the one I pasted
23:03:47 <path[l]> ah I see
23:04:08 <path[l]> I see it now though
23:04:11 <copumpkin> path[l]: you can stick cost centers into any spot in your code with {-# SCC "name #-}
23:04:21 <copumpkin> but -auto-all puts one in for each top-level binding for yo
23:04:27 <Cale> hydo: Well, they all have advantages and disadvantages, but if you go with HDBC or haskelldb, it should be easy to switch database backends.
23:04:40 <path[l]> ah I see
23:04:42 <Cale> er, or even hsql
23:04:54 <path[l]> so its in solve, does that mean solve needs more cost centers?
23:04:55 <copumpkin> path[l]: maybe you want to do that filter on the list rather than the map?
23:05:04 <copumpkin> path[l]: if you want to break it down more precisely, sure
23:05:20 <copumpkin> like, try adding one for filteredTeams
23:06:07 <Saizan> HDBC is the most actively maintained i think
23:06:13 <Cale> hydo: So, you're doing writes to the database from multiple threads and seeing some kind of corruption?
23:06:20 <path[l]> copumpkin: no adding the filter on the map really sped things up
23:06:28 <path[l]> earlier I filtered a list and then grouped it
23:06:31 <copumpkin> path[l]: ah, hmm ok
23:06:32 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8870#a8871
23:06:39 <copumpkin> is the new graph
23:06:53 <copumpkin> it still does use a big chunk of time
23:06:54 <path[l]> but grouping first helped me reduce the items to filter, since filter was more exensive
23:07:11 <hydo> Cale: the exact error is "database is locked" which, from what I can see, means that another thread has the db open for writing.  But that's just an educated guess.
23:07:24 <Cale> hydo: ah, yeah.
23:08:06 <path[l]> copumpkin: maybe it makes sense to seperate out the two operations and see if its the filtering or the list -> map thats the worst
23:08:15 <path[l]> probably the filtering huh
23:08:17 <Cale> hydo: another approach would be to put the SQLiteHandle in an MVar, and just use the convention that you take that MVar before using it, and put the handle back when done.
23:09:03 <Cale> hydo: It's a little sad though that it can't handle writes from multiple threads...
23:09:10 <ksf> lesson #1: STM's >>= is strict in its first argument.
23:09:33 <hydo> Cale: oo!  I haven't yet messed with mvars.
23:10:01 <hydo> cale: I've seen this before with other projects as well... but I had pretty orms to protect me from such madness... usually.
23:19:51 <mmorrow> Saizan: gah. it just takes too long for ghc-api to load a module (from source) for it to be useable in the bot (4.5 seconds to eval ", 42")
23:20:31 <mmorrow> well, that + get an HscEnv
23:20:50 <ksf> instance MonadFix STM where
23:20:51 <ksf>     mfix = unsafeCoerce fixIO
23:20:52 <path[l]> copumpkin: one saving I can think of is I can directly create the second map of teams from the first .... but I dont know how Id do it
23:20:57 <ksf> ...I can't believe that works.
23:21:08 <mmorrow> , (4692286000000 - 2776577000000)
23:21:08 <ksf> it seems, though, as far as I can test.
23:21:09 <lunabot>  1915709000000
23:21:14 <mmorrow> , (4692286000000 - 2776577000000) / (10 ^ 12)
23:21:15 <lunabot>  1.915709
23:24:57 <ksf> fixIO's implementation is interesting by itself, though.
23:32:33 <hydo> Erm... Now I feel pretty absurd.  I loved erlang's syntax for concurrency.  I just finished reading the post by dons on multicore concurrency from 2007.  It's a dumb question, I know, but is it really as easy as using forkIO, and watching an mvar?  Suddenly the erlang syntax seems much less elegant.
23:32:37 <mmorrow> , (1990697000000 - 2999000000) / (10 ^ 12)
23:32:38 <lunabot>  1.987698
23:34:16 <ezyang> I feel like I'm abusing fromMaybe to dispatch exceptions >.>
23:34:52 <ezyang> :t times
23:34:53 <lambdabot> Not in scope: `times'
23:34:59 <ezyang> :t time
23:35:00 <lambdabot> Not in scope: `time'
23:35:18 <vegai> hydo: the simplest case, sure, but that doesn't cover everything Erlang's concurrency does
23:36:27 <ksf> strange. that unsafeCoerce fixIO thing works, but re-implementing fixIO inside STM with unsafeIOToSTM $ newIORef ... not.
23:37:15 <hydo> vegai: true, but for my uses at the moment, it's awesome... nay, spectacular!
23:37:25 <hydo> heh... haskell excitement
23:38:09 <vegai> wait until your process crashes and you get no info whatsoever, then you might yearn Erlang again
23:38:12 * vegai hides
23:38:12 <ksf> mvar's don't produce a loop, but don't work, either.
23:38:24 <hydo> vegai: hehe
23:38:27 * aarong prefers erlangs build process
23:38:28 <aarong> (:
23:38:37 <mmorrow> Saizan: during the course of doing ", 42" (and loading a module in the process), it's:
23:39:18 <hydo> aarong: true.  make:all()./Emakefiles were/are pretty nice.
23:39:20 <Saizan> mmorrow: lambdabot loads the L.hs module everytime with mueval and it doesn't seem too slow
23:39:28 <aavogt> @hoogle scanM
23:39:28 <lambdabot> No results found
23:39:39 <aavogt> @hoogle scanlM
23:39:39 <lambdabot> No results found
23:39:45 <mmorrow> doing  661 calls to `stat', reading package.conf twice (it looks like), and reading 148 .hi files
23:39:52 <aarong> indeed. I can't comment on haskell yet because I can't get ghc built haha
23:40:35 <mmorrow> Saizan: hmmm, i'm insisting on having the ability to extend your environment via a regular haskell function like:
23:40:45 <mmorrow> addDecs [d|instance Monad ....|]
23:41:02 <mmorrow> so i have to do everything *inside* one `eval'..
23:41:07 <mmorrow> i think this is what's killing me
23:41:43 <mmorrow> , addDecs [d|data A = A deriving(Show)|]
23:41:44 <lunabot>  luna: Not in scope: `addDecs'
23:41:44 <mmorrow> then
23:41:47 <mmorrow> , A
23:41:48 <lunabot>  luna: Not in scope: data constructor `A'
23:41:50 <mmorrow> would print A
23:42:01 <mmorrow> (only for mmorrow though)
23:42:39 <ezyang> Juggling Integer and Int is kind of annoying
23:43:31 <Axman6> ezyang: how so?
23:43:44 <ezyang> I have code that expects Integer, but Enum internally uses Int
23:43:53 <ezyang> So I have to continually marshal my variables from one to another
23:44:38 <path[l]> what does marshal mean
23:44:54 <ezyang> use various conversions to get one from one form to another
23:45:12 <Axman6> eh?
23:45:32 <ezyang> Oh, I guess in this case I want genericTake, not take
23:48:11 <Cale> hydo: hmm... does your program work okay when run from inside ghci, with respect to threading?
23:48:28 <copumpkin> path[l]: sorry, my cable provider decided to die
23:53:13 <Cale> hydo: I just wrote a quick program using the same sqlite library as you did which uses two Haskell threads to smash a bunch of rows into a new table at the same time, and it worked okay. I don't have an SMP machine though.
