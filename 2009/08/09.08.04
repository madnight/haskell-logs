00:01:25 <Deewiant> copumpkin: Did you redefine +, *, and company or do you just have weird Num instances?
00:01:34 <copumpkin> Deewiant: I redefined them
00:02:13 <Deewiant> What's the type of +, out of curiosity?
00:02:22 <Deewiant> Does it fit on one line? ;-)
00:02:36 <copumpkin> depends on how long your line is :P
00:02:55 <copumpkin> (+) :: (Semiring plus times a) => WrapDimagma plus times a -> WrapDimagma plus times a -> WrapDimagma plus times a
00:03:08 <Deewiant> Not quite 80 columns :-)
00:03:11 <copumpkin> it's pretty ugly
00:03:35 <Deewiant> What's a dimagma
00:03:55 <copumpkin> the suggested name for two magmas on a set :P
00:04:06 <copumpkin> it exists nowhere in the literature :D
00:04:17 <copumpkin> probably for good reason
00:04:34 <Deewiant> What's the type of (-) then
00:04:40 <Deewiant> Does it involve trimagmas? :-P
00:04:51 <copumpkin> nah
00:05:08 <copumpkin> (-) :: (Ring plus times a) => WrapDimagma plus times a -> WrapDimagma plus times a -> WrapDimagma plus times a
00:05:09 <Deewiant> I guess they'd just be rings
00:05:10 <Deewiant> Yeah
00:05:22 <copumpkin> I need to come up with a better name for WrapDimagma
00:05:28 <copumpkin> Element
00:05:29 <copumpkin> :P
00:19:58 <Baconizer> Is there any way to make a list go backwards?
00:20:24 <copumpkin> reverse?
00:20:29 <copumpkin> > reverse [1..5]
00:20:30 <lambdabot>   [5,4,3,2,1]
00:20:54 <Baconizer> copumpkin: thanks
00:21:07 <vav> > take 12 [5,4..]
00:21:09 <lambdabot>   [5,4,3,2,1,0,-1,-2,-3,-4,-5,-6]
00:21:24 <Baconizer> > [1..3]
00:21:25 <lambdabot>   [1,2,3]
00:22:05 <Baconizer> So, lamdabot is essentially an interpreter + documentation system in IRC?
00:22:07 <Baconizer> Neat :D
00:22:19 <Baconizer> > help
00:22:20 <lambdabot>   Not in scope: `help'
00:22:26 <hackagebot> Binpack 0.3 - Common bin packing heuristics (BjoernBrandenburg)
00:22:28 <vav> @list
00:22:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:23:19 <vav> Baconizer: you can also /msg lambdabot to ask her stuff, or even cabal install lambdabot to have your very own copy
00:23:29 <Baconizer> :o
00:24:04 <Baconizer> vav: thanks :D
00:53:32 <WorkyBob> ski: ACK
00:53:44 <copumpkin> :o
01:09:04 <Eridius> when I install the Haskell Platform on my 64-bit OS X machine, a lot of cabal packages are no longer installable because of error: CPU you selected does not support x86-64 instruction set
01:09:10 <Eridius> does anybody know an easy way to fix this?
01:13:50 <copumpkin> Eridius: maybe try #ghc
01:14:12 <Eridius> ghc isn't even installed as x86-64
01:14:12 <paolino> @hoogle cmp
01:14:13 <lambdabot> Data.Array.Base cmpIntUArray :: (IArray UArray e, Ord e) => UArray Int e -> UArray Int e -> Ordering
01:14:13 <lambdabot> Data.Array.Base cmpUArray :: (IArray UArray e, Ix i, Ord e) => UArray i e -> UArray i e -> Ordering
01:14:13 <lambdabot> package funcmp
01:14:24 <Eridius> the configure step is producing that error
01:24:56 <mmorrow> haha
01:25:02 <mmorrow> preflex: zdec ghczmprim_GHCziTuple_zdgtoZLz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUZR_closure
01:25:02 <preflex>  ghc-prim_GHC.Tuple_$gto(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)_closure
01:25:42 <ziman> , length ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"
01:25:45 <lunabot>  33
01:27:35 <copumpkin> :o
01:27:38 <copumpkin> wow
01:27:41 <takayoshi_kyou> Hi, everybody. I am trying to make something like MonadIO but meet a "Kind mis-match"
01:27:42 <takayoshi_kyou> error. Here's what I'm trying to do:
01:27:42 <takayoshi_kyou> -- ECMonadT correspond to the IO monad
01:27:42 <takayoshi_kyou> type ECMonadT m a = ReaderT [(String, String)] m a
01:27:42 <takayoshi_kyou> -- MonadEC correspond to MonadIO, What I wanted is a one-step lift function
01:27:42 <takayoshi_kyou> -- that we can lift to the ECMonadT with only one "liftEC $ do-something"
01:27:44 <takayoshi_kyou> -- no matter how many layer the monad sandwich has
01:27:46 <takayoshi_kyou> class (Monad m) => MonadEC m where
01:27:48 <takayoshi_kyou>     liftEC :: (Monad n) => ECMonadT n a -> m a
01:27:50 <takayoshi_kyou> instance (MonadEC m) => MonadEC (StateT a m) where
01:27:52 <takayoshi_kyou>     liftEC = lift . liftEC
01:27:54 <takayoshi_kyou> instance MonadEC (ECMonadT m a) where  -- ERROR at this line!
01:27:56 <takayoshi_kyou>     liftEC = id
01:27:58 <takayoshi_kyou> GHCi says:
01:28:00 <takayoshi_kyou> cookies_data.hs:20:32:
01:28:02 <takayoshi_kyou>     Kind mis-match
01:28:04 <takayoshi_kyou>     Expected kind `* -> *', but `ECMonadT m a' has kind `*'
01:28:06 <takayoshi_kyou>     In the instance declaration for `MonadEC (ECMonadT m a)'
01:28:08 <takayoshi_kyou> What is "kind mis-match" means? What is "kind `* -> *'" means?
01:28:10 <takayoshi_kyou> Thanks
01:28:34 <Cale> takayoshi_kyou: Just like values have types, Type constructors have kinds
01:28:45 <Cale> @kind Integer
01:28:47 <lambdabot> *
01:28:51 <Cale> @kind Maybe
01:28:52 <lambdabot> * -> *
01:28:55 <Cale> @kind Maybe Integer
01:28:56 <lambdabot> *
01:29:00 <Cale> @kind Either
01:29:01 <lambdabot> * -> * -> *
01:29:05 <Cale> @kind Either Integer
01:29:06 <lambdabot> * -> *
01:29:08 <Cale> @kind Either Integer Bool
01:29:10 <lambdabot> *
01:29:55 <takayoshi_kyou> ... so it means the "parameter number" of my type construtors is incorrent?
01:30:02 <Cale> yeah
01:30:16 <Cale> takayoshi_kyou: What it's saying is that the MonadEC class expects a type constructor of kind * -> * -- specifically, it needs to be a monad
01:30:29 <Cale> But ECMonadT m a has kind *
01:30:43 <Cale> I think ECMonadT m should work on its own
01:30:48 <Cale> (without the a)
01:31:05 <takayoshi_kyou> Ok, I'll try it. Really thanks!
01:31:23 <Cale> No problem :)
01:32:19 <takayoshi_kyou> cookies_data.hs:20:0:
01:32:19 <takayoshi_kyou>     Type synonym `ECMonadT' should have 2 arguments, but has been given 1
01:32:19 <takayoshi_kyou>     In the instance declaration for `MonadEC (ECMonadT m)'
01:32:31 <takayoshi_kyou> shold have 2 argument...
01:32:56 <Cale> ah
01:33:08 <Cale> right, you can't define new instances for type synonyms
01:33:55 <Cale> You could make it a newtype though...
01:34:03 <takayoshi_kyou> i used a type instance extension... maybe i'll try newtype
01:35:05 <Cale> newtype ECMonadT m a = EC (ReaderT [(String,String)] m a) deriving (Functor, Monad, MonadReader [(String,String)])
01:36:07 <takayoshi_kyou> thanks let me try it~
01:40:45 <paolino> takayoshi_kyou: it's not possible to partially apply a type synonym, than you can make an instance of a totally applied type synonym with the right extension , but Functor and company are instances of partially applied types, if I get that right
01:41:22 <copumpkin> *Main> using2 Plus Times (5 + 6) :: Natural `Mod` S (S (S (S Z)))
01:41:22 <copumpkin> Mod 3
01:41:43 <takayoshi_kyou> now my code becomes:
01:41:44 <takayoshi_kyou> newtype ECMonadT m a = EC (ReaderT [(String, String)] m a)
01:41:44 <takayoshi_kyou>     deriving (Functor, Monad, MonadReader [(String,String)])
01:41:44 <takayoshi_kyou> class (Monad m) => MonadEC m where
01:41:44 <takayoshi_kyou>     liftEC :: (Monad n) => ECMonadT n a -> m a
01:41:44 <takayoshi_kyou> instance (MonadEC m) => MonadEC (StateT a m) where
01:41:46 <takayoshi_kyou>     liftEC = lift . liftEC
01:41:48 <takayoshi_kyou> instance (Monad m) => MonadEC (ECMonadT m) where
01:41:50 <takayoshi_kyou>     liftEC = id
01:41:52 <takayoshi_kyou> But GHC give me a new interesting error...
01:44:51 <copumpkin> @src ShowS
01:44:51 <lambdabot> type ShowS = String -> String
01:46:33 <takayoshi_kyou> GHC said that:
01:46:34 <takayoshi_kyou> cookies_data.hs:22:13:
01:46:34 <takayoshi_kyou>     Couldn't match expected type `m' against inferred type `n'
01:46:34 <takayoshi_kyou>       `m' is a rigid type variable bound by
01:46:34 <takayoshi_kyou>           the instance declaration at cookies_data.hs:21:16
01:46:34 <takayoshi_kyou>       `n' is a rigid type variable bound by
01:46:36 <takayoshi_kyou>           the type signature for `liftEC' at cookies_data.hs:16:21
01:46:38 <takayoshi_kyou>       Expected type: ECMonadT m a
01:46:40 <takayoshi_kyou>       Inferred type: ECMonadT n a
01:46:42 <takayoshi_kyou>     In the expression: id
01:46:44 <takayoshi_kyou>     In the definition of `liftEC': liftEC = id
01:48:57 <copumpkin> @where hpaste
01:48:58 <lambdabot> http://hpaste.org/
01:49:33 <copumpkin> > fromIntegral (5 :: Integer) :: Natural
01:49:35 <lambdabot>   5
01:49:43 <takayoshi_kyou> paolino: It's really great if that extension can support partially apply (because type synsops is so handy ) :-)
01:50:55 <matsuura> :D
01:51:06 <copumpkin> > fromIntegral (-5 :: Integer) :: Natural
01:51:07 <lambdabot>   * Exception: Natural: fromInteger
01:52:22 <copumpkin> *Main> using2 Plus Times (5 - 7) :: Natural `Mod` S (S (S (S Z)))
01:52:23 <copumpkin> 2 mod 4
01:52:27 * copumpkin grins :D
01:55:30 <dmwit> takayoshi_kyou: Perhaps the (liftEC :: (Monad n) => ECMonadT n a -> m a) was a double typo...?
01:56:30 <copumpkin> of course what I just wrote doesn't make too much sense, but sort of does
01:56:40 <dmwit> Ah, I see that you really do mean to switch monads.
01:57:06 <Gertm> I'm learning about currying and was wondering: is infix notation the only way you can fix the first parameter of a function instead of always the last one?
01:57:39 <dmwit> takayoshi_kyou: Which is odd, since your second instance doesn't actually switch monad instances, you see?
01:57:41 <takayoshi_kyou>  dmwit: n and m is not the same monad...
01:57:56 <c_wraith> Gertm:  normal currying fixes the first parameter
01:58:05 <dmwit> takayoshi_kyou: i.e. "id" doesn't switch you over from ECMonadT n a to ECMonadT m a, it keeps you at ECMonadT m a.
01:58:28 <Gertm> c_wraith: yes, and with the 'infix' way you can fix the first one, right? Is there another way to do that?
01:58:29 <takayoshi_kyou> dmwit: !! I got it!
01:59:17 <c_wraith> Gertm:  function application in haskell is curried.
01:59:19 <takayoshi_kyou> dmwit: Maybe I should try forall ?
01:59:22 <dmwit> takayoshi_kyou: You'll note that the error message says the exact same thing. ;-)
01:59:45 <c_wraith> Gertm:  if f has three args, "f a" fixes the first parameter
01:59:47 <dmwit> "Expected type ECMonadT m a, Inferred type ECMonadT n a, in the expression id" =)
01:59:59 <c_wraith> Gertm:  and "f a b" fixes the first two parameters
02:00:29 <dmwit> takayoshi_kyou: I see no reason to expect that you can convert an arbitrary monad action from one monad to another.
02:00:44 <dmwit> takayoshi_kyou: So I think this class is just plain doomed to failure.
02:01:02 <dmwit> takayoshi_kyou: (Consider converting from IO to Identity, for example...)
02:01:32 <Gertm> c_wraith: ok thank you :)
02:01:57 <c_wraith> @pl \x y -> f x y z
02:01:58 <lambdabot> flip flip z . f
02:02:01 <takayoshi_kyou> dmwit: but MonadIO class convert any instances of it to IO monad, isn't it?
02:02:27 <dmwit> takayoshi_kyou: Oh, yes, but only for instances of MonadIO!
02:02:48 <dmwit> takayoshi_kyou: Your class has only a (Monad n) => constraint on liftEC.
02:02:57 <dmwit> It has to work for any choice of monad 'n'!
02:04:03 <copumpkin> mmorrow: damn, my failgebra has grown so much hpaste won't accept it anymore!
02:04:50 <dmwit> takayoshi_kyou: I've got to run, but good luck!
02:04:59 <takayoshi_kyou> thank!
02:05:13 <mmorrow> copumpkin: heh
02:05:47 <c_wraith> @pl \a b c -> f a b c d
02:05:47 <lambdabot> flip flip d . (flip .) . f
02:06:06 <c_wraith> agh.  right.  pointless is usually a bad idea.  got it.
02:06:46 <c_wraith> but curiosity compells me
02:06:54 <c_wraith> @pl \a b c d -> f a b c d e
02:06:54 <lambdabot> flip flip e . ((flip . (flip .)) .) . f
02:06:54 <WorkyBob> c_wraith: not sure about the usually there
02:06:56 <WorkyBob> often though
02:07:10 <WorkyBob> very much depends on the argument order, and which one you want to partially apply
02:07:30 <c_wraith> yes.  I'd reorder the args if this was a real function
02:07:46 <c_wraith> @pl \a b c d e -> f a b c d e x
02:07:47 <lambdabot> flip flip x . ((flip . ((flip . (flip .)) .)) .) . f
02:07:54 <WorkyBob> a "real" function?
02:08:02 <c_wraith> Something I was using in code
02:08:04 <WorkyBob> what's not real about it?
02:08:06 <c_wraith> rather than idle curiosity
02:08:11 <WorkyBob> oh, I see
02:08:26 <WorkyBob> it's a hypothetical -- what happens if I try to do point free when partially applying on the right
02:08:32 <c_wraith> yep
02:08:33 <WorkyBob> and the answer is "it looks orrible"
02:25:53 <copumpkin> w00t, I added quaternions too
02:26:07 <copumpkin> this file is getting ridiculous
02:26:53 <opqdonut> hmm
02:27:22 <copumpkin> of course, it's a real pain to use
02:27:32 <copumpkin> but at least I can use it as a somewhat formal definition of various parts of algebra
02:27:34 <opqdonut> WorkyBob's experiment made me think: we need a bunch of operations dupX and swapX
02:27:43 <opqdonut> modeled after the stack primitives in stack languages
02:27:51 <opqdonut> that would shuffle the "argument stack"
02:28:03 <hackagebot> HPlot 0.3 - A minimal monadic PLplot interface for Haskell (YakovZaytsev)
02:28:07 <copumpkin> yeah
02:28:09 <opqdonut> i'll write a proof of concept this evening, methinks
02:28:16 <copumpkin> cool
02:30:45 <stanv> how many times some item encountered in list ?
02:31:10 <copumpkin> ?
02:31:12 <stanv> is there function for this ?
02:31:22 <stanv> [a] -> Int :)
02:31:36 <stanv> a -> [a] -> Int
02:31:41 <copumpkin> :t \x -> length . filter (x==)
02:31:42 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
02:32:02 <stanv> O(2n)
02:32:03 <stanv> :)
02:32:18 <stanv> I want O(n)
02:32:22 <Gracenotes> you're thinking imperatively
02:32:39 <Gracenotes> Haskell is lazy. this gets you lots of help with performance.
02:33:49 <doserj> an imperative algorithm also needs time 2n. n comparisons plus n additions.
02:34:00 <Gracenotes> in JavaScript, for example, filter(function(o) { o == x }, list).length() would be O(2n)
02:34:38 <Gracenotes> (which is actually the same thing as O(n), but we're allowed to abuse asymptotic notation, right? :D)
02:34:44 <doserj> (n+m, to be more precise)
02:35:02 <koala_man> javascript uses linked lists?
02:35:16 <copumpkin> it could if you wrote them :P
02:35:47 <Gracenotes> actually, in dot notation, it would be more like list.filter(function(o) { o == x }).length()
02:37:20 <Gracenotes> so the reason why laziness is different is because the filtered list is essentially generated as the length function needs it.
02:37:33 <stanv> > foldr (\ n total -> if n == 2 then total+1 else total ) 0 [1,2,3,4,2]
02:37:34 <lambdabot>   2
02:37:39 <stanv> how about this ?
02:37:45 <copumpkin> stanv: sure, but it's reinventing the wheel
02:37:50 <stanv> is this also (2n) ?
02:37:50 <copumpkin> for no real benefit
02:38:16 <copumpkin> stanv: it's n (==) calls and m (where m is the number of matching elements) (+) calls
02:38:26 <copumpkin> same as length . filter
02:38:59 <Gracenotes> the compiler could probably automatically transform length . filter (==x) into a single foldr call.
02:39:26 <stanv> hmm
02:39:28 <stanv> :)
02:39:31 <Gracenotes> I'm not entirely sure about this though >_>
02:39:36 <Gracenotes> for this specific case
02:40:00 <mercury^> wtf
02:40:05 <mercury^> O(n) and O(2n) are the same.
02:40:09 <copumpkin> yeah :P
02:40:11 <mercury^> Where is the problem?
02:40:15 <Gracenotes> it is an abuse of notation, as I said
02:40:23 <copumpkin> it's actually anyway O(n + m)
02:40:31 <copumpkin> but since m < n
02:40:44 <stanv> yes o(n + m), sorry :)
02:41:37 <stanv> I don't know about >_> operator
02:41:42 <mercury^> It's not even because m is smaller than n. m just needs to be bounded by a linear function of n.
02:41:53 <Gracenotes> but the point, I guess, is that you don't need to look at a filtered element more than once with lazy semantics
02:41:54 <copumpkin> yeah
02:42:16 <WorkyBob> mercury^: well, being smaller than n means it is bounded by a linear function of n -- specifically n
02:42:36 <mercury^> Thanks, I didn't not that. :/
02:43:08 <copumpkin> by the way, that won't currently fuse
02:43:11 <copumpkin> because http://hackage.haskell.org/trac/ghc/ticket/876
02:43:33 <Gracenotes> where have I seen that before, "because [link to bug ticket with low number]"
02:43:44 <Gracenotes> <_<
02:44:13 <copumpkin> well, they aren't fixing that because it'd be useless given that people plan on changing the fusion system
02:44:40 <Gracenotes> but, at least hand-crafted code could make it work
02:45:30 <Gracenotes> although unless you're dealing with a linked list (!) with a million elements, there shouldn't be any reason to worry. laziness is still there...
02:47:05 <Gracenotes> anyway. sleep? what is sleep?
02:47:16 <copumpkin> http://files.getdropbox.com/u/361503/Algebra.hs :P
02:48:10 <Gracenotes> hm, so now VLC plays nice with sound mixing in ALSA...
02:51:01 <ziman> copumpkin, that looks nice! :)
02:51:14 <copumpkin> ziman: for some values of nice at least :) thanks
02:51:31 <copumpkin> sadly it's almost all boilerplate
02:51:38 <copumpkin> maybe tomorrow I'll add some TH
02:51:46 <copumpkin> and bring it down to the <100 lines it should be
02:51:52 <copumpkin> :P
02:52:09 <stanv> so, lenght . filter (==p) is right decision, right ?
02:52:23 <copumpkin> stanv: you're welcome to benchmark the two against each other
02:52:30 * copumpkin needs to finish his quickbench library
02:52:48 <stanv> i don't how to benchmark ^)
02:53:00 <copumpkin> stanv: length . filter might be marginally slower due to the lack of fusion I mentioned, but it isn't inherently slower
02:53:46 <stanv> ok :)
02:55:26 <yairchu> socket question: how do I get a HostAddress from a domain name like "www.google.com"?
02:57:32 <jfoutz> Network.Socket.getAddrInfo Nothing (Just "google.com") Nothing
02:58:52 <yairchu> jfoutz: thanks!
02:59:06 <jfoutz> sure.
03:03:24 <Deewiant> copumpkin: Use 6.12 and you can shave a few lines by deriving Functor
03:04:09 <copumpkin> how does that work?
03:04:19 <Deewiant> -XDeriveFunctor :-P
03:04:29 <delopart> hey
03:04:42 <delopart> i am using ubuntu
03:04:50 <delopart> and i try to write some haskell program
03:05:02 <copumpkin> Deewiant: I mean implementation wise
03:05:06 <delopart> are there any ide to write haskell program easily
03:05:12 <Deewiant> copumpkin: I know; beats me
03:05:55 <copumpkin> :)
03:05:59 <copumpkin> delopart: check out leksah
03:06:57 <delopart> aptitude search leksah gives no result
03:07:33 <yairchu> delopart: cabal install leksah
03:07:35 <chrisbrown> delopart: http://leksah.org/index.html
03:10:47 <delopart> there are .dmg version
03:13:30 <chrisbrown> delopart: I believe there is a cabal version
03:13:50 <delopart> yes i found something
03:26:38 <delopart> hey
03:26:42 <delopart> http://www.haskell.org/haskellwiki/Leksah_Installation#Installation_of_0.6.1_on_Ubuntu_9.04
03:26:49 <delopart> i fallow this address
03:26:53 <delopart> where is gtk2hs
03:28:02 <doserj> @where gtk2hs
03:28:02 <lambdabot> http://haskell.org/gtk2hs/
03:33:51 <Stalafin> hey! i was wondering - what is string manipulation like in haskell? (have no idea about haskell... was just wondering if somebody could compare it to c++, where it's a b*tch)
03:34:19 <timonator> strings are lists, haskell is reasonably good at those
03:34:43 <timonator> says a big haskell noob who made not a single program yet
03:34:52 <Stalafin> haha :)
03:35:07 <vegai> well, like it was recently blogged, unicode support isn't very good right now
03:35:19 <vegai> and lists of chars waste a lot of space
03:35:35 <Cale> Well, there are libraries you can get to make the unicode support nicer.
03:36:16 <Cale> But 6.12 is going to have it work properly, iirc.
03:42:36 <byorgey> @seen jeffersonheard
03:42:37 <lambdabot> jeffersonheard is in #haskell. I last heard jeffersonheard speak 3d 17h 17m 55s ago.
03:43:34 <quicksilver> lists of chars don't "waste" space, exactly. They use it.
03:43:40 <quicksilver> that space is used for a reason :)
03:43:57 <byorgey> @ask jeffersonheard I wanted to play around with Hieroglyph but it seems buster doesn't build.  I get the same errors shown in the build log on hackage.  Any ideas?
03:43:57 <lambdabot> Consider it noted.
03:45:44 <lvh> Hello :-)
03:50:42 <delopart> hey
03:50:43 <delopart> http://www.pastebin.org/6413
03:50:49 <delopart> how can i solve that error
03:52:09 <doserj> delopart: install ghc-6.10.x
03:52:35 <Cale> delopart: Yeah, you're apparently using a very old version of GHC.
03:53:28 <Cale> There's a generic linux binary package of GHC which tends to work well.
03:54:44 <delopart> i just istalled ghc6 from ubuntu jaunty repos
03:54:57 <Cale> Yeah, Ubuntu has a really old version.
03:55:11 <delopart> yeah
03:55:15 <delopart> it is 6.0.2
03:55:22 <chrisbrown> @where WorkyBob
03:55:23 <lambdabot> I know nothing about workybob.
03:55:31 <doserj> 6.8.2, not 6.0.2, surely
03:59:45 <delopart> how
03:59:55 <delopart> can i install ghc6 for ubuntu
04:00:01 <delopart> are there any repository
04:00:27 <Cale> delopart: I just go with the generic linux binary, it works rather well.
04:01:32 * Beelsebob pokes chrisbrown
04:02:49 <chrisbrown> Beelsebob: have you seen this: http://blog.haskell.cz/pivnik/building-a-shared-library-in-haskell/
04:03:23 <Beelsebob> chrisbrown: oh, interesting
04:03:44 <chrisbrown> Beelsebob: I stumbled accross it while searching for something at work; thought it might have been useful
04:03:56 <Beelsebob> when I asked simon marlowe he said it just wasn't possible until 6.12
04:03:58 <Beelsebob> looks like you do have to jump through quite a few hoops though
04:04:07 <Beelsebob> for the mo, we're making do with a static library, and waiting for 6.12
04:04:08 <chrisbrown> right
04:04:14 <Beelsebob> oh yeh -- I know why it wasn't possible
04:04:18 <Beelsebob> and I don't see this fixing it
04:04:23 <Beelsebob> 6.10 doesn't generate PIC
04:04:27 <Beelsebob> it's all absolute addresses
04:04:39 <chrisbrown> eh, PIC?
04:04:50 <Beelsebob>  so yeh, I'm surprised they succeeded somehow
04:08:15 <lilac> delopart: the Karmic repository has GHC 6.10.4 in it
04:08:36 <chrisbrown> Beelsebob: when is 6.12 out?
04:09:19 <lilac> Beelsebob: perhaps they're using -fvia-c?
04:10:34 --- mode: irc.freenode.net set +o ChanServ
04:10:57 <delopart> i install ghc binary
04:12:52 <Beelsebob> I told you, use your package manager
04:16:02 --- mode: irc.freenode.net set +o ChanServ
04:22:20 <pasc1> anyone here familiar with TreeView (gtk2hs)?
04:24:48 --- mode: irc.freenode.net set +o ChanServ
04:26:36 --- mode: irc.freenode.net set +o ChanServ
04:35:01 <eflister> hi.  i have a function that is supposed to remove items from a heap and do some IO with them, until the heap is empty.  currently it has type drain :: Heap -> IO (), removes one item and recurses until there are no more items.  but i was thinking about replacing the explicit recursion with until.  then the type would be drain :: IO (Heap) -> IO (Heap), and i thought the until call (in the do block of main :: IO () ) would look like (li
04:35:51 <Raevel> your message got truncated
04:35:59 <eflister> thx, at what point?
04:36:12 <Raevel> would look like (li
04:36:34 <eflister> i thought the until call (in the do block of main :: IO () ) would look like (liftM2 $ until isEmpty) drain $ return h.  but this is wrong cuz drain's type is not IO (Heap -> Heap).  what's the right way to do this?
04:36:42 <WorkyBob> eflister: it sounds like you want mapM
04:36:46 <WorkyBob> @type mapM
04:36:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:37:05 <WorkyBob> or possibly mapM_ which ignores the result, and just does the side effects
04:37:28 <WorkyBob> mapM_ doMagicWithItemOnHeap heap
04:39:23 <eflister> WorkyBob: hmm, trying to understand...
04:39:34 <WorkyBob> eflister: mapM takes a list of somethings
04:39:50 <eflister> WorkyBob: do i need to listify my heap then?
04:39:55 <WorkyBob> it runs a function on each of them, in a monad (if that monad is IO, they may produce side-effecting actions)
04:39:57 <WorkyBob> yep
04:40:08 <WorkyBob> and it binds all the side effecting actions together
04:40:15 <WorkyBob> pushing things into a list
04:40:21 <WorkyBob> (or ignoring results in the case of mapM_)
04:40:35 <eflister> WorkyBob: ok the complexity i left out is that this is in a thread and the Heap is in a MVar, and is simultaneously having stuff put into it by another thread
04:40:46 <eflister> WorkyBob: so i'm not sure how to listify it
04:40:58 <WorkyBob> eflister: that sounds like you don't want an MVar then
04:41:00 <WorkyBob> but a Chan instead
04:41:10 <WorkyBob> if you're trying to stream values from one thread to another
04:41:11 <eflister> WorkyBob: it's a priority heap, so not FIFO
04:41:17 <WorkyBob> ah k
04:41:35 <WorkyBob> so you want a kind o Chan, but one that respects priority
04:41:51 <eflister> WorkyBob: yeah :)
04:41:59 <WorkyBob> in the mean time, yes, building a lazy list like that is possible
04:42:04 <igel> you could build that with MVar and Data.Heap
04:42:15 <WorkyBob> i.e. by dragging items out of a data structure and sticking them on the end of the list
04:42:35 <eflister> igel: it currently is a MVar Data.Heap
04:43:08 <WorkyBob> but yeh, until may be better
04:45:04 <eflister> WorkyBob: so how do i lift until into IO, so that it works with my IO (Heap) -> IO (Heap)?
04:45:19 <WorkyBob> that's the type of drain, yeh?
04:45:26 <eflister> WorkyBob: right
04:46:09 <igel> :t Data.Foldable.mapM_
04:46:11 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
04:46:39 <igel> eflister: if you don't need the priorities, heap itself is foldable and you can use D.Foldable.mapM_
04:47:06 <eflister> igel: yeah i need the priorities :)
04:49:28 <eflister> igel: the thread that is putting stuff into the heap wants to put stuff in out of order, and i need drain to prioritize
04:50:14 <mbuf> if I have an array of [FilePath], how can I apply a function, like createDirectory to each element in the list?
04:51:45 <igel> so you have two threads, one putting items on the heap and the other one calling 'view' to treat the elements in oder of priority?
04:51:49 <igel> eflister: ^^
04:52:31 <igel> mbuf: there must be sth like map
04:52:31 <eflister> igel: right
04:53:30 <mbuf> igel, just wondering how I can use with createDirectory which does IO()
04:53:34 <Cale> mbuf: mapM
04:53:38 <igel> ok then you shouldn't use the foldable instance (or convert to a list an then use mapM_), because it whould not work on items that get inserted *while* you work on the first bunch of them
04:53:39 <Cale> :t mapM
04:53:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:54:14 <Cale> mbuf: Wait, you have an array of lists of FilePaths?
04:54:35 <Cale> mbuf: What type of array?
04:54:42 <eflister> three different flavors of mapM have been the answers to the last 5 problems i've had.  :)
04:54:44 <mbuf> Cale, array of FilePaths;
04:55:01 <igel> eflister: consider this scenario:
04:55:14 <Cale> (Note that an array is not the same thing as a list at all)
04:55:16 <igel> 1) you have a heap of items and start working on them in order of priority
04:55:32 <igel> 2) while you handled the first 3 of them, another one gets added (by the other thread)
04:55:32 <mbuf> Cale, allDir :: [FilePath]; allDir = ["/tmp","/bin"]
04:55:40 <Cale> mbuf: Okay, that's a list
04:55:47 <Cale> mbuf: In that case, just use mapM
04:55:55 <mbuf> Cale, ok, it is a list, sorry for the terminology
04:55:57 <igel> do you want the new item to be handled in order or do you want to finish the entire (old) heap heap first?
04:55:59 <Cale> Or mapM_ given that you don't care about the results
04:56:13 <Cale> :t createDirectory
04:56:15 <lambdabot> Not in scope: `createDirectory'
04:56:19 <Cale> :t System.Directory.createDirectory
04:56:20 <lambdabot> FilePath -> IO ()
04:56:27 <Cale> :t mapM System.Directory.createDirectory
04:56:28 <lambdabot> [FilePath] -> IO [()]
04:56:40 <Cale> :t mapM_ System.Directory.createDirectory
04:56:43 <lambdabot> [FilePath] -> IO ()
04:56:45 <igel> eflister: for option 1 mapM_ won't work, for option 2 it will
04:56:49 <eflister> igel: well, drain just does one at a time withMVar, so it takes the highst priority at that time
04:57:40 <igel> well that freezes the heap in the mvar until you're done
04:57:58 <eflister> igel: it releases it as soon as it's got one out
04:58:05 <igel> otherwise you'd need something like "modifyMVar view"
04:58:56 <igel> uhm "modfiyMVar (flip . view)"
04:59:40 <eflister> igel: it does a takeMVar, then cases view(heap) into Nothing and Just (next, rest), and then putMVar's rest back.
05:00:20 <igel> i think that could be a problem if the other thread inserts sth, while your'e "casing"
05:00:37 <igel> eflister: i suggest you use modifyMVar
05:00:38 <eflister> igel: it'll block cuz i haven't putMVar'd yet
05:01:03 <igel> argh
05:01:15 <igel> damn, i always forget they can be empty :D
05:01:23 <igel> ok sorry for the confusion :)
05:01:28 <eflister> igel: np
05:01:50 <igel> anyway, i just got a highlight because of "heap" :P
05:02:06 <eflister> igel: are you the author?
05:02:12 <igel> i am
05:02:20 <eflister> igel: cool :)  i dig it
05:02:33 <eflister> igel: i had an independent question about it actually
05:03:22 <igel> eflister: what is it?
05:04:02 <eflister> igel: i have to override Prio, but would like to use an existing policy.  however, as defined, i have to also make my own policy because the current policies are totally defined for all cases.
05:06:34 <igel> what part of the policy do you want to reuse?
05:07:17 <igel> or less generally speaking: what's your plan? :)
05:08:18 <eflister> igel: in my case, Prio is the derived Ord of (Integer,Integer), and i'd just like to use a MinPolicy on that
05:09:40 <igel> eflister: what's wrong with FstMinPolicy ((Integer,Integer),whateverelse) then?
05:10:12 <eflister> igel: ah, of course.
05:10:13 <igel> or MinHeap (integer,Integer)
05:10:30 <igel> eflister: depending on whether you have sth associated to your keys
05:10:51 <eflister> igel: somehow that hadn't occurred to me
05:11:06 <eflister> igel: 'sth'?
05:11:11 <igel> something
05:11:35 <eflister> igel: right, i must be tired. :b  i was thinking 'dark lord of the'
05:11:55 <igel> minimal editing distance :D
05:12:16 <igel> dist(sth, sith) = 1, dist(sth,something) = 6
05:13:36 <eflister> igel (or WorkyBob): any ideas on that until thing?  it must be a common pattern to want to do something iteratively until a predicate holds, inside a monad.
05:18:40 <igel> eflister: ok,i'm afk now, let me know if you have more questions
05:19:40 <eflister> igel: thx - heap is sweet.  :)
05:19:50 <eflister> anyone have any ideas on how to lift until to work on a f :: m A -> m A?
05:21:41 <byorgey> eflister: unfortunately it won't work to just lift a pure 'until' function to work inside a monad, since you'd have to first run the monad to get an infinite list and then use 'until' on that --- but running a monad to get an infinite list isn't sufficiently lazy.
05:21:55 <lilac> @type until :: Monad m => (m a -> Bool) -> (m a -> m a) -> m a -> m a
05:21:57 * lilac ducks
05:21:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> Bool) -> (m a -> m a) -> m a -> m a
05:22:21 * byorgey throws a nerf lambda at lilac
05:22:32 <dmwit> :t until
05:22:33 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
05:22:38 <dmwit> haha
05:22:41 <lilac> wow, those are some good reflexes i have there. jedi-like, perhaps
05:22:49 <byorgey> eflister: you'll have to write your own untilM function---or find one on the wiki, it's fairly common
05:22:56 <dmwit> Good luck supplying that (m a -> Bool). =D
05:23:09 <dmwit> :t mfix
05:23:10 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
05:23:48 <byorgey> eflister: http://www.haskell.org/pipermail/beginners/2009-January/000690.html
05:23:49 <dmwit> :t \p f -> mfix (\a -> if p a then return a else f a)
05:23:51 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> Bool) -> (a -> m a) -> m a
05:24:15 <dmwit> ?instances MonadFix
05:24:16 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:24:32 <byorgey> argh, code.haskell.org's web server is down again =(
05:25:00 <eflister> byorgey: thx, that's a big help!
05:25:13 <lilac> @type let untilM b f x = do b' <- b; if b' then x else untilM b f (x >>= f) in untilM
05:25:15 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> (b -> m b) -> m b -> m b
05:25:35 <lilac> @type let untilM b f x = do b' <- x >>= b; if b' then x else untilM b f (x >>= f) in untilM
05:25:37 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> (a -> m a) -> m a -> m a
05:26:39 <dmwit> Wait, you want it to work on (f :: m a -> m a)?  That's odd.
05:27:02 <lilac> @@ @pl @undo untilM b f x = do b' <- x >>= b; if b' then x else untilM b f (x >>= f)
05:27:03 <lambdabot>  untilM = fix (ap ((.) . ap . ((>>=) .) . (=<<)) . ((ap (flip . flip if') .) .) . flip flip (=<<) . (liftM2 (.) .))
05:27:09 <lilac> yay
05:27:30 <dmwit> God, it's so much more intuitive now that you've written it as a pipeline of functions.
05:28:32 <lilac> dmwit: i know, right? @pl is great at revealing the underlying truth of a computation
05:29:01 <eflister> dmwit: well, it seems like to replace an explicit recursion with an until, you need an f :: a -> a
05:29:08 <mmorrow> @type ((>>=) .) . (=<<)
05:29:10 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => (a1 -> m a) -> m a1 -> (a -> m b) -> m b
05:29:43 <lilac> @type (\f -> f . return) . (\f -> (>>= f))
05:29:44 <eflister> dmwit: and since drain has to be something -> IO (a) ...
05:29:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> a -> m b
05:29:54 <mmorrow> @type (>>=) . (=<<)
05:29:55 <lambdabot> forall b a (m :: * -> *) b1. (Monad m) => (a -> m b1) -> (m b1 -> m a -> b) -> m a -> b
05:30:07 <lilac> @type (>>= (>>= (>>=)))
05:30:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => ((a -> m b) -> (a -> m b) -> m a) -> (a -> m b) -> m b
05:30:25 <lilac> ah, i thought so.
05:30:31 <dmwit> eflister: I would think you'd want to use your manufactured until on an (f :: a -> IO a).
05:31:01 <mmorrow> @type (>>= (>>= (>>=))) . (. (. (.)))
05:31:02 <lambdabot> forall (m :: * -> *) b b1 c a. (Monad m) => (((b1 -> c) -> m b) -> (((a -> b1) -> a -> c) -> m b) -> m ((a -> b1) -> a -> c)) -> (((a -> b1) -> a -> c) -> m b) -> m b
05:31:07 <mmorrow> hah
05:31:25 <mmorrow> @unpl (>>= (>>= (>>=))) . (. (. (.)))
05:31:25 <lambdabot> (\ j -> (\ m -> j (\ p -> m (\ d e -> p (d e)))) >>= \ a -> a >>= (>>=))
05:31:43 <lilac> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (>>=) (=<<) (>=>) (<=<)
05:31:45 <lambdabot> forall b c a. ((a -> c) -> a -> c) -> ((a -> c) -> (a -> a -> a -> c) -> b) -> (a -> a -> a -> c) -> b
05:31:56 <lilac> @@ @djinn @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (>>=) (=<<) (>=>) (<=<)
05:31:58 <lambdabot>  f a b c =
05:31:58 <lambdabot>     b (\ d -> c d d d) (\ e f g -> a (\ _ -> a (\ _ -> c e e e) g) f)
05:32:05 <eflister> dmwit: yeah i guess untilM won't use IO A -> IO A.  that was when i wanted to use liftM until...
05:32:17 <lilac> @@ @pl @djinn @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (>>=) (=<<) (>=>) (<=<)
05:32:20 <lambdabot>  f = flip (ap . (. (join . join))) . ((const .) .) . flip flip id . ((flip . (ap .)) .) . ap ((.) . (.) . (.)) ((((const .) .) .) . (. ((const .) . join . join)) . (.))
05:33:39 <lilac> @@ @pl @djinn @type let (@pl @djinn @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (>>=) (=<<) (>=>) (<=<)) in f
05:33:43 <lambdabot>  f = flip (ap . (. (join . join))) . ((const .) .) . (. ((const .) . join . join)) . (.)
05:35:08 <lilac> @@ @pl @djinn @type let (@pl @djinn @type let (@pl @djinn @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (>>=) (=<<) (>=>) (<=<)) in f) in f
05:35:14 <lambdabot>  f = flip (ap . (. (join . join))) . ((const .) .) . (. ((const .) . join . join)) . (.)
05:38:28 <yottis> is there a version of <*> that flips everything? i'm looking for something with the same signature as <**>, but not just the arguments swapped
05:39:40 <Philonous1> When a thread tries to read from an empty chan and all the writing threads are killed, a blockedOnDeadMVAR exception is raised, is it not? So forkIO . forever $ readChan chan >>= do something will be killed as soon as chan is dead?
05:40:24 <ManateeLazyCat> How to pick string from result of function `printf` ?
05:44:17 <yottis> specifically, i have a Parsec parser that returns something of type X a, and another that returns X (a -> b), and i'd like to combine them into one that returns X b, but so that the parsing is done in that order
05:45:58 <ManateeLazyCat> Example, expression `printf "%s" "hello"`   print "hello", but how to get string "hello", i want store string "hello"
05:50:51 <doserj> > printf "hello %s" "world" :: String
05:50:51 <lambdabot>   "hello world"
05:50:55 <burp> um, I'm trapped in a monad http://paste.railsbox.eu/show/zM5I208tYVkRmo1DQfuz/ <- I want to put the updateIx result in the Update monad state
05:50:56 <ManateeLazyCat> :t ap
05:50:58 <burp> No instance for (MonadState QuoteDB Maybe) arising from a use of `put'
05:51:06 <burp> I would write this code with if isNothing mquote .. then return Nothing etc., but I want to take advantage of the maybe monad
05:51:15 <dmwit> :t liftM2 (flip ($))
05:51:16 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (a1 -> b) -> m b
05:51:20 <dmwit> :t liftA2 (flip ($))
05:51:20 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f (a -> b) -> f b
05:51:20 <dmwit> (if you prefer applicatives)
05:51:26 <dmwit> ManateeLazyCat: Just use it at the type String.
05:51:27 <dmwit> ManateeLazyCat: It has a polymorphic return type.
05:51:34 <dmwit> > printf "%s" "hello" 3 :: String
05:51:34 <lambdabot>   "hello* Exception: Printf.printf: formatting string ended prematurely
05:51:34 <dmwit> heh
05:51:45 <ManateeLazyCat> dmwit: I see, thanks!
05:51:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:51:59 <ManateeLazyCat> yottis: :t ap
05:52:05 <ManateeLazyCat> :t ap
05:52:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:52:18 <ManateeLazyCat> yottis: Is above?
05:52:38 <dmwit> ManateeLazyCat: He wants the effects to be in the other order.
05:53:13 <ManateeLazyCat> >
05:53:13 <ManateeLazyCat> <lambdabot>   "hello* Exception: Printf.printf: formatting string ended prematurely
05:53:13 <ManateeLazyCat> <dmwit> heh [20:51:36]
05:53:13 <ManateeLazyCat> <ManateeLazyCat> dmwit: I see, thanks! [20:51:44]
05:53:16 <ManateeLazyCat> <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b [20:51:52]
05:53:19 <ManateeLazyCat> <ManateeLazyCat> yottis: :t ap [20:52:00]
05:53:23 <ManateeLazyCat> <ManateeLazyCat> :t ap [20:52:06]
05:53:27 <ManateeLazyCat> <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b [20:52:08]
05:53:30 <ManateeLazyCat> <ManateeLazyCat> yottis: Is above? [20:52:19]
05:53:30 <ManateeLazyCat> <dmwit> ManateeLazyCat: He wants the effects to be in the other order. [20:52:40]
05:53:34 <ManateeLazyCat>  
05:53:40 <ManateeLazyCat> Sorry, IRC bug.
05:53:40 <ManateeLazyCat> My IRC-client has bug.
05:53:43 <ManateeLazyCat> sorry.
05:54:19 <ManateeLazyCat> > printf "%s" "hello" :: String
05:54:21 <lambdabot>   "hello"
05:55:16 <dino-> > printf "%s" "hello" :: IO ()
05:55:18 <lambdabot>   <IO ()>
05:55:54 <dino-> > printf "%s" "To whomever read this log: Thanks for lambdabot! Your pals at #haskell" :: IO ()
05:55:56 <lambdabot>   <IO ()>
05:55:59 <dino-> heh, reads
05:56:18 <yottis> yeah, if one abides all the laws, shouldn't ap equal <*>
05:56:21 <dmwit> Just so you know, your IO actions are not being run.
05:56:34 <dmwit> Yes, ap = <*>
05:56:46 <dmwit> :t (<*>)
05:56:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:56:52 <dmwit> yes
05:57:05 <dmwit> ?src liftA2
05:57:05 <lambdabot> liftA2 f a b = f <$> a <*> b
05:57:06 <FunctorSalad> does it have to?
05:57:22 <dino-> dmwit: I had a sudden irrational thought of all output to stdout and err going to some log file somewhere. :D
05:57:27 <ManateeLazyCat> yottis: I use hoogle search "Control.Monad.ap"
05:57:33 <yottis> now i have "p1 <***> p2 = p1 >>= \v -> p2 <*> return v", but that isn't pretty and goes into monad land
05:57:55 <ManateeLazyCat> yottis: Hoogle is very useful sometimes. :)
05:57:55 <dmwit> > show (return () :: IO ()) -- dino-, it's just using this sneaky Show instance
05:57:57 <lambdabot>   "<IO ()>"
05:58:14 <dino-> ah, hence the < >
05:58:29 <dmwit> > let unsafeTouchTheDisk = undefined :: IO () in unsafeTouchTheDisk
05:58:30 <lambdabot>   <IO ()>
05:59:04 <yottis> ManateeLazyCat, it is, but sometimes one needs to use a combinator which doesn't result in hoogle helping out
05:59:42 <yottis> thought that what i need could be something relatively common and i might just be missing something
05:59:46 <dmwit> yottis: Have you solved your problem?
06:00:57 <yottis> yeah, with that line that uses monads, but as there is so much hype about Applicative and my parsing doesn't need monads otherwise, it'd be neat to use something applicative here too
06:01:04 <dmwit> ?src (<**>)
06:01:05 <lambdabot> (<**>) = liftA2 (flip ($))
06:01:13 <dmwit> What was wrong with (<**>)?
06:01:16 <yottis> especially when it's really just the effects flipped, which <**> does a poor job at
06:01:30 <dmwit> <**> flips the effects
06:02:07 <dmwit> > [1..3] <**> [succ, (*5)]
06:02:08 <lambdabot>   [2,5,3,10,4,15]
06:02:18 <dmwit> > [succ, (*5)] <*> [1..3]
06:02:19 <lambdabot>   [2,3,4,5,10,15]
06:02:33 <dmwit> (Just making sure that what I said is true. =)
06:02:48 * ManateeLazyCat pasted "number" at http://paste2.org/get/359012
06:02:48 <ManateeLazyCat> I wrote above function to handle plural of string, have an exist function that do same thing?
06:03:14 <dmwit> ManateeLazyCat: oh my
06:03:39 <ManateeLazyCat> ??
06:04:07 <dmwit> ManateeLazyCat: Probably not.  That function is probably very buggy, though.
06:04:17 <dmwit> ManateeLazyCat: You might want to look for a stemming library.
06:04:19 <ManateeLazyCat> dmwit: I miss i
06:04:56 <ManateeLazyCat> should be "init xs ++ "ies""
06:05:19 <ManateeLazyCat> stemming library?
06:29:03 --- mode: irc.freenode.net set +o ChanServ
06:29:25 <ManateeLazyCat> dmwit: I collect complete data now, i think i will release this library tomorrow. :)
06:29:50 <dmwit> Awesome!
06:29:50 <dmwit> ManateeLazyCat++
06:30:16 <byorgey> what is ManateeLazyCat doing?
06:30:45 <ManateeLazyCat> byorgey: Handle "the plural number"
06:31:38 <dmwit> I wonder if it's enough to have bindings to WordNet or something like that.
06:32:57 <dmwit> Nope, WordNet doesn't seem to have plurals.
06:33:44 <ManateeLazyCat> dmwit: Collect data is enough, and don't need any external program, but i think speical words is HUGE.
06:35:10 <quicksilver> there are open source plural things. try this for inspiration: http://search.cpan.org/dist/Lingua-EN-Inflect/lib/Lingua/EN/Inflect.pm
06:36:36 <ManateeLazyCat> quicksilver: Thanks, taking a look.
06:37:36 * therp dares to repeat a question due to the netsplit 
06:37:39 <therp> does anyone know what happend to the SHIM project (superior haskell interaction mode for emacs) ?
06:38:15 <therp> the most recent version on c.h.o. seems to require ghc-6.6.
06:38:31 <ski> Parameters and tables <http://www.cs.chalmers.se/~aarne/GF/doc/gf-tutorial.html#toc49>; number : singular and plural
06:41:21 <ManateeLazyCat> Above is too complicate, need analysis syntax environment, I just want do a table filter, input singular and output plural.
06:43:44 <eflister> igel: hey you around?  i remembered why my (Integer, Integer) priority is hard to use with a predefined policy
06:43:50 <seydar> greetings
06:44:15 <anthonym10> New to Haskell, trying to do something and can't find information on whether or not it is possible...
06:44:18 <igel> eflister: why?
06:44:28 <ski> anthonym10 : ask your question
06:44:44 <anthonym10> Trying to make my own implementation of lcm, wanting to pass two parameters to determine the lcm of each
06:45:13 <anthonym10> if they do not facter, want to increment a multiplier for the larger of the two and pass the function to itself
06:45:18 <ski> if you have any code with problems, you could paste it at e.g.
06:45:19 <eflister> igel: my priority is derived from the guts of my objects, so i want to use split and merge, but i want to instance HeapItem so that insert/view will call these for me rather than me having to do it.
06:45:21 <ski> @paste
06:45:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:46:22 <eflister> igel: but then i have to make my own associated Prio and Val types, which will then conflict with yours if i want to reuse your policies
06:46:43 <igel> uhm i'm not sure if i understand
06:46:44 <eflister> igel: why do i have to make my own Prio and Val?
06:47:02 <ManateeLazyCat> anthonym10: lcm?
06:47:02 <eflister> igel: which part? :)
06:47:06 <seydar> can you use a tree to do LRU?
06:47:10 <igel> so the two Intergers are part of a larger type?
06:47:15 <ski> ManateeLazyCat : "least common multiple"
06:47:28 <ski> @type lcm
06:47:29 <lambdabot> forall a. (Integral a) => a -> a -> a
06:47:33 <igel> eflister: it would help, if you could provide a little example
06:47:36 <ManateeLazyCat> I see
06:47:56 <eflister> igel: the priority is a function of the value
06:47:57 <eflister> igel: ok i'll make a pastebin
06:48:10 <anthonym10> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7867#a7867
06:48:28 <anthonym10> Want to pass different number of parameters to the same function, something I can do?
06:49:24 <ski> no, you need name (at least) one of those two functions differently
06:49:25 <anthonym10> What I have is my two values to find the LCM and a multiplier which increments on each call to the function.
06:49:34 <ski> (since it can't be the same function)
06:49:50 <anthonym10> OK, I was able to get it that way but wasn't sure how they're doing it in the built in LCM function.
06:49:56 <ski> e.g. you could name the latter one  lcm'_aux  (if you can't think of any better name)
06:50:28 <ski> @src lcm
06:50:28 <lambdabot> lcm _ 0     =  0
06:50:28 <lambdabot> lcm 0 _     =  0
06:50:28 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
06:50:29 <blbrown_win> newb question: what is the default GUI framework that comes with ghc 6.10.4, what is the most common gui framework third party library for ghc.  I need it for basic drawing routines
06:50:33 <anthonym10> I'm not used to functional programming, with most imperative languages I can make a method private--any way to make that function private so only the lcm will call it
06:50:42 <ski> anthonym10 : yes
06:50:54 <ski>   lcm' x y = ...lcm'_aux...
06:50:55 <ski>     where
06:51:04 <ski>     lcm'_aux x y z = ...
06:51:19 <ski> then only  lcm'  knows about  lcm'_aux
06:51:36 <anthonym10> Thanks ski!
06:51:48 <ski> also, you should not use `do', here
06:52:40 <anthonym10> Not necessary?
06:52:43 <ski> (`do' is for monadic stuff, like e.g. `IO' .. you don't need such here, so you shouldn't be using `do')
06:52:46 <PeakerWork> anthonym10: product [x,y]  == x*y
06:53:12 <ski> anthonym10 : in your case i think using `do' like that will be a type error
06:54:14 <PeakerWork> > let x = do 5 in x
06:54:17 <lambdabot>   5
06:54:21 <PeakerWork> @type let x = do 5 in x
06:54:23 <lambdabot> forall t. (Num t) => t
06:54:24 <PeakerWork> "do" doesn't care that its used like that..
06:54:35 <ski> hm .. maybe that has changed in GHC, then
06:55:02 <igel> eflister: still there? :)
06:55:07 <ski> (iirc, it used to be that using `do' at least forced the type into form `m a' for some `m' and `a' .. maybe even added the constraint `Monad m')
06:55:40 <eflister> igel: almost ready
06:56:18 <ski> (yes, that's what GHC used to do .. just checked on an old version)
06:56:31 <blbrown_win> ghc + gtk+ hmm?
06:59:33 <eflister> igel: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7869
07:02:30 * seydar fades temporarily
07:03:58 <igel> eflister: the code you commented out is from an old incompatible version of heap
07:04:06 <igel> from the 0.x.y versions
07:05:44 <igel> and you should define a phantom type for the policy instead of using instance HeapItem *a* ...
07:06:17 <igel> wait a sec
07:07:12 <akiel> hi
07:07:25 <anthonym10> @src quot
07:07:25 <eflister> igel: ha ha, whoops, i thought it didn't look familiar (that's what google turned up).  but the conflict still occurs -- i'll find the new code reference.
07:07:26 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:07:37 <anthonym10> @src gcd
07:07:38 <akiel> I have the same problem as in http://hackage.haskell.org/trac/ghc-test/ticket/3374 anyone else?
07:07:38 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
07:07:38 <lambdabot> gcd x y = gcd' (abs x) (abs y)
07:07:38 <lambdabot>    where gcd' a 0  =  a
07:07:38 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
07:08:49 <igel> eflister: is your problem, that MinPolicy defines 'Val' as ()?
07:08:50 <eflister> igel: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7869#a7870
07:09:07 <igel> look at the revision i posted
07:09:22 <igel> does it make sense for you?
07:09:31 <igel> i'm still not sure if i get the problem right
07:12:53 <ski> anthonym10 : `quot' is integral division (usually the one that corresponds to the hardware instruction closer)
07:14:06 <akiel> can someone help me with GHC 6.11 building? or where can I get help? - Thanks
07:15:51 <eflister> igel: yeah -- that's what i had originally, and was sad that i couldn't reuse 'MinPolicy' -- because it still is MinPolicy, just with a different ordering.  but MinPolicy is already defined for all value types a and doesn't let you specify a different ordering.
07:16:41 <igel> so the problem with using MinPolicy is a conflicting, existing Ord instance of your PMEvent type=
07:16:42 <igel> ?
07:18:10 <eflister> igel: so, for instance, i'd like to use my HeapItem instance with the split/merge as defined, and be able to flip the ordering just by picking MaxPolicy.
07:18:26 <igel> ah i see
07:18:26 <eflister> igel: PMPolicy is a bit misleading, right?
07:18:40 <igel> PMinPolicy
07:18:43 <igel> :)
07:19:03 <igel> uhm i'm afraid you have to write two instances for HeapItem
07:20:08 <igel> along with two phantom types for identifiing them
07:20:20 <igel> PMEMinPolicy and PMEMaxPolicy for instance
07:20:43 <igel> the entire type-family hackery in the heap package is because tehre's no simple way to do such things :(
07:23:32 <edwardk> so the whole policy wrapper thing is to avoid wrapping your values in a newtype that indicates the appropriate valuation?
07:24:01 <igel> that's one reason
07:24:14 <igel> because tehre is no InverseOrd newtype or sth comparable
07:24:44 <edwardk> sure
07:24:48 <igel> the other job it does, is to say which part of a value acutally influences the ordering
07:24:58 <igel> e.g. you could have a heap of (Int, IO ())
07:25:07 <eflister> igel: no - it's that i'm not allowed to instance HeapItem MinPolicy PMEvent, cuz you've already defined HeapItem MinPolicy a, for all a.
07:25:07 <eflister> :b
07:25:58 <igel> yeah that's impossible... but using a different policy type shouldn't be too much code ;)
07:26:01 <edwardk> yeah but that could be done with data Priority a b = Priority (a,b) with the same reasoning
07:26:42 <edwardk> er data Priority a b = Priority a b
07:26:54 <igel> yep
07:27:09 <igel> but you would have to manually wrap it up before inserting
07:27:20 <igel> the HeapItem class does that for you
07:27:40 * ManateeLazyCat pasted "number" at http://paste2.org/get/359050
07:27:40 <ManateeLazyCat> dmwit: Above is basis algorithm for "the plural number", now just need fill data.
07:27:43 <edwardk> i'll buy it. they are just two points in the design space, so i'm poking at this to see which i like better ;)
07:28:29 <igel> the underlying type (data HeapT p v) is a simple min-priority-heap
07:28:44 <igel> everything else is just wrapping it up
07:28:52 <edwardk> the wrapping/unwrapping could be accomplished by using a suitable class for embedding/projecting
07:29:05 <igel> so that the same implementation can be used for min- max- minprio- and maxprio heaps
07:29:09 <edwardk> yeah
07:29:21 <igel> yep, and the 'suitable class' is HeapItem :)
07:29:50 <yottis> that code just cries out for mplus
07:29:56 <edwardk> i have a bunch of min priority/max priority types for dealing with various monoids involving min/max or dioid operations in my monoid lib, so i thought i'd poke and see what you do differently and why ;)
07:29:58 <igel> it's better than it's predecessor, HeapPolicy, believe me
07:30:09 <edwardk> *nods*
07:30:43 <igel> i know that it's not exactly standard design what i did
07:31:09 <edwardk> the policy is purely phantom?
07:31:20 <igel> but if you don't want to let the user do the wrapping/unwrapping, there is no nicer way...
07:31:25 <igel> yep^^
07:31:40 <edwardk> i.e. to permit easy heap unions without worrying about merging concrete policy objects?
07:31:47 <edwardk> *nods*
07:32:02 <igel> otherwise you couldn't define both, min- and max-prio heaps for all Ord a => a
07:32:22 <igel> yeah, *plus* typesafe merges!
07:32:28 <ski> > map getDual . sort . map Dual $ [1,4,2,8,5,7]
07:32:29 <lambdabot>   [1,2,4,5,7,8]
07:32:33 <igel> i didn't want it to be possible to merge a minheap and a maxheap
07:32:34 <ski> mhm
07:32:49 <edwardk> sure, btw- you can abuse reflection to get phantom policies that can use variables from scope ;)
07:33:17 <eflister> igel: well yeah -- i'm wondering if there is a way to be a bit more elegant -- some way to define your policies that was abstract wrt split/merge, but still concrete about what it does with the ordering?
07:33:18 <igel> i only resort to template haskell if there's no other way ;)
07:33:40 <edwardk> the reflection mechanism isn't template haskell its typing voodoo
07:34:03 <igel> i'm not 100% sure what was the reason, but the Prio type had to be "data" not "type"
07:34:38 <igel> i'm doing typelevel-hacks as well... the information of how to sor the heap has to be part of the type
07:34:44 <igel> sort
07:35:16 <igel> union (foo::MinHeap Int) (bar::MaxHeap Int) is a type error
07:35:34 <ManateeLazyCat> Where i can find complete list for heteroclite?
07:36:21 <eflister> igel: i'm new to haskell and expect it to be capable of maximum conceivable elegance.  :)
07:36:46 <ski> @type let inDual :: (Functor f,Functor g) => (f (Dual a) -> g (Dual b)) -> (f a -> g b); inDual f = fmap getDual . f . fmap Dual in ()
07:36:47 <lambdabot> ()
07:37:45 <edwardk> make up a data UserPolicy s a prio= UserPolicy -- instance (s `Reflects` (a -> prio)) => HeapPolicy (UserPolicy s a prio) a where newtype Prio (UserPolicy s a prio) a = UserPrio a deriving (Eq); type Val (UserPolicy s a prio) a = a; .... or something similar
07:38:25 <edwardk> and then you can use a user specified field selection to extract a priority from an item, or what have you
07:38:50 <eflister> igel: so you can't leave split and merge abstract, huh?
07:39:05 <edwardk> by saying something like reify getMyCustomPriority (big complicated heap calculation)
07:39:05 <eflister> yottis: which code?
07:39:27 <edwardk> still a phantom type parameter, but it can make reference to the particular concrete calculation you want it to use
07:39:50 <igel> edwardk: but two (a -> prio) functions can't be distinguished in the type level, right?
07:40:15 <edwardk> igel: they can, the trick is how reify uses universal quantification to ensure that you can't try to unify two that differ =)
07:40:31 <igel> oh dear
07:40:34 <edwardk> igel: hah
07:40:49 <igel> is this simpler to use than what i have? :P
07:40:53 <edwardk> that is the usual reaction, but its actually fairly slick. kind of like how ST s works
07:41:14 <edwardk> i was saying you could _add_ this to what you have, not replace it - its just another policy type
07:41:29 <igel> hmm ok
07:41:48 <igel> what do i have to look at?
07:41:58 <edwardk> one sec, lemme dig up an example
07:42:05 <edwardk> reflection on hackage for one
07:42:24 <edwardk> monoids before 0.2 had a ModularArithmetic Ring you could look at that used it
07:42:57 <edwardk> http://www.mail-archive.com/haskell-cafe@haskell.org/msg57747.html -- i used the reflection library to make a Monoid instance out of a user supplied function and unit
07:43:21 <edwardk> see the 'withMonoid' examples near the end of that post to get a feel for it
07:44:05 <igel> ok i'll do that, but not now ;)
07:44:15 <igel> may i bother you with questions later on? :)
07:44:15 <edwardk> heh
07:44:15 <eflister> igel and edwardk: sorry if i'm being obtuse, just want to understand -- why couldn't MinPolicy be a class that requires instances to define split and merge?
07:44:51 <igel> because there would be need for more than one of those classes
07:44:59 <igel> e.g. for MaxPolicy
07:45:09 <igel> as it is now, i can say:
07:45:22 <edwardk> eflister: you _could_ probably just make a class out of the policy type, but it'd probably need the argument type to be supplied to it as well
07:45:22 <igel> insert :: (HeapItem pol item) => ...
07:45:41 <edwardk> not sold one way or the other on which one makes a cleaner api
07:46:41 <igel> edwardk: i remember another restraint was that i wanted a instance Functor (HeapT prio)
07:46:48 <edwardk> regarding why you needed to make Prio into a data type, you probably have a method in there somewhere that needs type inference to flow backward from Prio item to item
07:46:52 <igel> so (Value p v) has to be a type
07:47:17 <edwardk> igel: ah. although that is a bit of a pleasant fiction, no?
07:47:33 <igel> why?
07:47:34 <edwardk> since you need your mapped operation to preserve the priority relationship
07:47:42 <igel> no! :)
07:47:45 <edwardk> ?
07:47:56 <igel> it only works on the /value/ not on the /priority/ :)
07:48:07 <edwardk> ah, i misparsed your statement
07:48:25 <igel> that's the advantage of storing prio and val separately :)
07:48:29 <edwardk> sure
07:48:41 <igel> with the <1 version type class that was impossible
07:49:03 <edwardk> at the cost that if there is a cheap operation to extract value, then you are probably losing the bet on storage and speed
07:49:32 <edwardk> <- is not nearly as negative as I probably sound
07:49:43 <igel> :)
07:50:09 <igel> well, you usually use one of the four existing policies
07:50:24 <edwardk> yeah
07:50:27 <igel> and all they do is pack/unpack (,)
07:51:01 <igel> i didn't notice a considerable slowdown compared to the <1 version
07:51:23 <igel> but i have to admit that i didn't do much testing
07:52:03 <edwardk> well, it does force a layer of indirection even if you don't need it, everything has to go through a pair rather than be accessed directly
07:52:30 <edwardk> a perfectly valid engineering decision, just one to think about
07:52:31 <igel> i don't know how got ghc is at optimizing it away :)
07:52:46 <edwardk> it can't really because that is what you are storing in the structure, no?
07:52:53 <igel> and what i did to reduce the effect were rewrite rules a la
07:52:58 <igel> (split (merge x)) = x
07:53:14 <edwardk> or are you not storing the pairs and are actually storing the raw heap?
07:53:22 <edwardk> and i'm just conflating the issue in my head
07:53:29 <edwardk> er raw heap item
07:53:44 <igel> the raw heap stores value and prio in separate fields
07:53:51 <jmcarthur_work> edwardk, has the ring stuff made it into another library yet?
07:54:09 <igel> so if you for instance use a MinHeap, teh following wrapping happens:
07:54:34 <igel> a ~> (a, ()) ~> Node ... a ... () ... ~> (a, ()) ~> a
07:54:47 <edwardk> jmcarthur_work: not yet =/ i've been sluggish in moving the rest of monoids into monoid-extras because i wanted to focus on making sure the fragment i had was usable and i was changing the api around to avoid re-exporting everything all over the place so i can -Wall without a screenful of noise.
07:54:47 <igel> where the "a"s are strict
07:55:05 <igel> and the ()s are never evaluated
07:55:06 <jmcarthur_work> edwardk, ah. that's fine. i was just curious
07:55:09 <edwardk> jmcarthur_work: by your inquiry i assume you are actually using it?
07:55:25 <jmcarthur_work> edwardk, not at the moment, although it's possible in the foreseeable future
07:55:39 <jmcarthur_work> i'm mostly just exploring things
07:56:10 <edwardk> k, for now  you can explicitly import monoids < 0.2 if you need it, and i'll build a monoid-extras lib after i get kata to a releasable point
07:56:23 <jmcarthur_work> right, so definitely no big deal
07:56:32 <edwardk> (or package up the ring stuff as 'rings') or something
07:56:48 <edwardk> or even ringoids since i start down there
07:56:50 <jmcarthur_work> i can wait
07:56:52 <edwardk> k
07:56:59 <jmcarthur_work> thanks
07:57:03 <yottis> eflister: 17:27  * ManateeLazyCat pasted "number" at http://paste2.org/get/359050
07:57:11 <edwardk> igel: then thats fine, it should all fuse away and become invisible
07:57:22 <edwardk> igel: for some reason i thought you were storing the pair in the heap
07:57:38 <igel> no :)
07:57:39 <edwardk> nice little library
07:57:43 <igel> thanks :)
07:58:33 <igel> of course it won't work that well for really complicated HeapItem instances... but that can't really be prevented
07:59:42 <edwardk> well you can always make something that explicitly holds the priority unpacked if its expensive to calculate and add a reflection based selector if you want weird stuff
08:03:44 <eflister> igel: does mine count as complicated :)  i was just running across fusion and haven't grokked it
08:03:57 <igel> yeah... and you must be sure that nothing influencing the priority is part of the "Value" projection
08:04:18 <igel> eflister: not really
08:04:31 <igel> all you do is you have a type and split it in two halves:
08:04:41 <igel> one determining the prio and one that doesn't
08:06:38 <igel> look at the documentation of HeapItem, it's a bit complicated but there are some examples and 'laws' about split/merge
08:07:16 <igel> or you use (prio, val) tuples with Fst{Min,Max}Policy all along
08:07:19 <igel> your choice :)
08:10:27 <eflister> igel: i think i have to understand fusion to know that isn't bad... :)
08:11:02 <igel> eflister: by fusion, do you mean 'merge'?
08:12:34 <eflister> igel: i couldn't find any good place to start trying to understand fusion -- any recs?
08:13:03 <igel> what do you mean by fusion??
08:13:08 <igel> the 'merge' function?
08:14:45 <msteele__> eflister: There's a few good blog entries by Don Stewart demonstrating stream fusion.  Here's one: http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/
08:15:01 <Rotaerk> oh you're not talking about cold fusion?
08:15:05 <Rotaerk> *cough*
08:26:33 <ManateeLazyCat> dmwit: I found a better and fast way that don't use huge table to filter, i will finish algorithm soon. I will send your source code after i complete.
08:36:07 <eflister> igel: sorry, stepped away.  yeah stream fusion, not merge.  ;)
08:36:28 <stanv> @index (>.>)
08:36:29 <lambdabot> bzzt
08:36:32 <stanv> :(
08:36:32 <eflister> igel: isn't that what you were referring to about the compiler being able to "fuse away" certain operations?
08:36:55 <stanv> where is `>.>' defined ?
08:36:55 <igel> yeah well
08:37:11 <igel> uhm you really don't have to worry about that
08:37:21 <Saizan> @hoogle >.>
08:37:21 <lambdabot> No results found
08:37:29 <Saizan> stanv: try hayoo
08:37:47 <igel> eflister: it's an internal optimization technique of ghc
08:38:50 <stanv> Nothing found yet.
08:39:06 <byorgey> stanv: >.> ?  I've never seen that.  where did you find this operator?
08:39:26 <ski>   (>.>) = flip (.)  -- presumably
08:40:01 * ski has used that often .. not sure about others
08:40:40 <byorgey> perhaps, but it depends on the code stanv is looking at.
08:41:25 <stanv> >.> operator used in craftFP.djvu
08:41:41 <byorgey> stanv: do you have a link?
08:41:51 <ski> (that's probably where i've got it from, then ..)
08:42:12 <stanv> so, >.> must i define this operator byself ?
08:42:35 <byorgey> it's not part of the standard libraries.
08:42:44 <pikhq> @hoogle (>.>)
08:42:45 <lambdabot> No results found
08:42:50 <stanv> byorgey: http://pv.bstu.ru/flp/craftFP.djvu
08:42:56 <pikhq> That ain't encouraging.
08:44:49 <byorgey> stanv: if you saw above, ski thinks that (>.>) = flip (.)
08:44:57 <byorgey> stanv: is the operator used to chain functions together?
08:45:05 <byorgey> flip (.) would be function composition, but backwards
08:45:05 <stanv> yes, it is
08:45:15 <byorgey> so f >.> g  would mean  to do first f, then g
08:45:43 <byorgey> so you can easily define it yourself if you like by just writing (>.>) = flip (.)
08:46:26 <pikhq> That is a silly operator.
08:46:32 <ski> hehe, why ?
08:46:33 <Ferdirand> isn't there already (>>>) ?
08:46:44 <ski> Ferdirand : there wasn't when the book was written
08:46:47 <stanv> I thought it comming from Prelude
08:46:50 <pikhq> @src (->) (>>>)
08:46:50 <lambdabot> f >>> g = g . f
08:46:59 <pikhq> I say yes.
08:47:42 <burp> happstack migrations are sick
08:47:56 <ski> ("yes" to what ?)
08:48:36 <eflister> igel: yeah, i'd like to know more (if only to know how to write code that takes advantage of it) -- i think msteele__'s link looks good.  is this what you were referring to by "fuse away"?
08:48:49 <pikhq> ski: Yes, there is already (>>>).
08:49:03 <Ferdirand> ah, sorry, i missed some context then :o
08:49:07 <ski> right
08:49:13 <pikhq> stanv: So, import Control.Arrow, and there you go.
08:49:18 <ski> (but there wasn't when `(>.>)' was invented)
08:49:33 * ski has no problem with using `(>>>)' instead
08:49:44 <stanv> so can I use >>> instead >.> ?
08:49:50 <pikhq> Yeah.
08:50:18 <ski> (there a small chance for more confusion or needlessly much polymorphism because of greater generality .. but i don't think that very problematic, here)
08:50:26 <igel> eflister: yep
08:50:32 <ski> @index >>>
08:50:32 <lambdabot> Control.Arrow
08:50:39 <igel> but i got to go, bye ;)
08:50:57 <pikhq> ski: Eh, so it is also defined on other arrows. So what? ;)
08:51:25 <ski> pikhq : well .. i'm often using `map' when i could use `fmap', et.c.
08:51:49 <ski> (and `concat' instead of `join')
08:51:57 <pikhq> ski: Y'know, we should totally get rid of map.
08:51:58 <pikhq> :P
08:52:00 <ski> sometimes it helps readability to use the more specific operation, instead of the overloaded one
08:52:31 <pikhq> Bah, humbug.
08:52:40 <pikhq> Readability? Who needs it?
08:52:41 <ski> (but it only helps readability a little bit, so i wouldn't feel that uncomfortable merging `map',`fmap', et.c.)
08:52:51 <pikhq> I just do everything with lambdas.
08:52:53 <pikhq> :P
09:01:53 <deech> Hi all, I've been trying to understand continuations. I have some non-working code that http://pastebin.com/d1c2dfa01 attempts to construct a simple command-line listener that takes a string and tries to store a continuation into an IORef. It currently dies with a "cannot construct infinite type" error. Can anyone take a look at it for me?
09:09:46 <defun> hey, anybody have any idea when GHC will be cabalized? Also, would using LLVM instead C-- as a backend offer any substantial performance improvements? Btw, are there any plans to port GHC to plan9?
09:10:29 <quicksilver> defun: Never. No. Not as far as I know.
09:10:42 <quicksilver> is my best guess :)
09:10:50 <quicksilver> I'm not authoritative though.
09:11:00 <quicksilver> There are definitely people doing LLVM experiments.
09:11:04 <defun> thanks.
09:11:27 <hackagebot> hack-handler-evhttp 2009.8.4 - Hack EvHTTP (libevent) Handler (BrandonBickford)
09:12:13 <defun> what is the main factor that prevents the cabalization of GHC? Is it a GHC related issue, or is it a cabal related issue? As far as I understand Cabal's build system is more advanced than gnu make, but I'm not certain...
09:14:36 <quicksilver> I don't think that's really true.
09:14:57 <quicksilver> there are plenty of things you can do with gnu make which have no analogy in cabal.
09:17:15 <defun> thanks again. As you can probably tell I've never actually /written/ a make file.
09:17:28 <pastah> @type ord . head
09:17:29 <lambdabot> [Char] -> Int
09:17:44 <pastah> why does it give [Char] and not String
09:18:00 <dmwit> type String = [Char]
09:18:14 <pastah> why aren't all the 'type' declarations in scope checked+
09:18:15 <pastah> ?
09:18:37 <pastah> i know there might be doble instances, but still
09:18:39 <ski> Beelsebob : ok ?
09:20:08 <ziman> i'm not sure whether that would be even decidable
09:20:30 <ziman> it would.
09:22:09 * pastah goes type spelunking
09:22:29 <pastah> or is that "spelunkying"?
09:26:35 <ski> deech :  k $ test'' conts  is ill-typed
09:26:39 <ski> what do you want to do ?
09:30:58 <ski> (ziman : at the very least there could be an infinite number of ways to express the type ..)
09:35:43 <ziman> at first i thought you couldn't algorithmically find other ways to express the type than the inferred one but as long as type equivalence is decidable, you can generate all possible types and check each
09:37:13 <ski>   type Foo a = a
09:37:14 <deech> ski, what I want to do is to append the continuation ' k test ' to the IORef store.
09:37:37 <ski>   test''  is of the wrong type
09:37:57 <ski> maybe you want the `runContT' outside of it ?
09:38:22 <ski> (also, even then you probably want `=<<' rather than `$')
09:38:56 <deech> what I really want is to end up with a list of continuations like [(k test), (k test) ...].
09:39:15 <ski> what do you want the type of `conts' to be `
09:39:19 <ski> s/`/?/
09:39:30 <ski>   conts :: IORef [?]
09:39:46 <ski>   conts :: IORef [IO ?]  -- ?
09:39:52 <ski>   conts :: IORef [ContT ? IO ?]  -- ?
09:40:13 <deech> umm .... conts :: IORef [IO ()]?
09:40:47 <ski> what do you want to do with the elements of the list, later ?
09:40:55 <deech> ski, run them.
09:41:04 <ski> invoke them inside 'ContT ? IO ?' ?
09:41:26 <ski> or run them just inside the `IO'-monad ?
09:41:37 <seydar> Hail the IO Monad
09:41:38 <deech> So I could do the whole thing by storing the list [test '' , test '' ...]. But I am trying to learn continuations.
09:41:51 <deech> ski, just run them in the IO Monad.
09:42:16 <deech> ski, the motivation behind this is to try and simulate the 'retry' operator from STM using continuations.
09:42:21 <ski> so then you're just storing arbitrary `IO'-actions for later execution
09:42:31 <deech> ski, yes
09:42:32 <seydar> deech: I found this article to be helpful with understanding continuations: http://gnuu.org/2009/03/21/demystifying-continuations-in-ruby/
09:42:40 <ski> where it just so happens that those `IO'-actions have originally come from "continuations"
09:42:49 <deech> ski, yes.
09:43:38 <deech> ski, so basically I am trying to implement 'retry' using something like 'k atomicaction'.
09:43:44 * ski tries to recall how `retry' worked
09:44:58 <seydar> ski: it goes back to the top of the loop with the same args and runs the block again
09:45:01 <deech> In the STM monad 'retry' causes the thread to go to sleep until one of the variables it was trying to access has changed.
09:45:19 <bhan> are there any good open source haskell games?
09:45:54 <ski> maybe Frag
09:45:58 * ski hasn't tried it
09:46:10 <deech> So I thought I could capture the whole function as a continuation, add that continuation to a list and invoke that list when a value has changed.
09:46:36 <ski> i'm not sure why you want to store a list of continuations
09:46:41 <Baughn> bhan: Not really.. well, there's a roguelike somewhere on hackage, but I haven't seen anyhting I'd call "good".
09:47:20 <Deewiant> Of course, there aren't that many good open source games, period.
09:47:32 <bhan> Deewiant: why is that?
09:47:38 <pikhq> There aren't that many good games, really.
09:48:03 <deech> ski, it is my understanding that invoking that continuation will invoke it in thread that created it.
09:48:07 <seydar> deech: ski: well i was WAY off... that's what i get for jumping in the convo
09:48:12 <Deewiant> I guess because people who make games feel that they deserve some money for the effort they put into it? :-P (And they can't figure out how to commercialize open source)
09:48:56 <gwern> Baughn: hey, I like monadius
09:48:58 <ski> deech : invoking a continuation will resume execution from where the continuation was captured .. this hasn't really got anything to do with (`IO'-) threads
09:49:01 <benmachine> there isn't really that much good
09:49:01 <gwern> that's a pretty good haskell game
09:49:21 <Ke> there are quite some good enough fps engines for example
09:49:33 <Baughn> gwern: Monadius is fun, but it's not exactly /good/, is it? :P
09:49:33 <gwern> super nario bros is pretty impressive, albeit incomplete and a copyvio
09:49:34 <Ke> someone could sell some proper content
09:49:37 <bhan> what about GUI applications.. i'm just tired of printing to the terminal
09:49:43 <gwern> Baughn: something can be fun but not good?
09:49:46 <Ke> that way the game itself was opensource
09:49:47 <Baughn> gwern: Sure
09:49:54 <Baughn> gwern: I don't think I can name more than ten good games, period.
09:50:05 * Baughn has high standards.
09:50:10 <gwern> I've never tried mazes of monads, which looks like the most complete rogue-like
09:50:14 <ski> deech : in any case, i'm suspecting you don't want to call `runContT' inside  test''
09:50:24 <gwern> oh, I see, in Baughenese, good means perfect
09:50:25 <ski> deech : are you sure you want to ?
09:50:39 <Baughn> gwern: Oh, but I'm going to try rewriting Monadius in FRP style once I get Reactant working properly. :3
09:50:49 <gwern> sure you will
09:50:51 <deech> ski, just experimenting.
09:51:17 <Baughn> Sure I will. It's the obvious thing to do.
09:51:30 <gwern> if you say so
09:51:34 <Baughn> ...
09:51:35 <deech> I'm thinking of a continuation as storing the environment is was captured in.
09:51:39 <ski> deech : maybe what you're trying to do is set up an adaptive/incremental computation framework ?
09:51:42 <bhan> can you easily do GUI programming in haskell?
09:51:53 * gwern thinks Baughn and most haskellers are all thunk, no evaluation
09:52:02 <deech> ski, never heard of that.
09:52:04 <gwern> *eval
09:52:16 <gwern> bhan: 'snot much worse than most other languages
09:52:41 <ski> deech : basically a network of "modifiable" nodes .. there is a value in each node which is computed from values from parent nodes
09:53:12 <ski> deech : whenever the value in a node changes, the children of that node needs to recompute to see whether their value has also changed
09:53:38 <pikhq> bhan: It's no worse than most high-level languages. I've not seen anything truly *exceptional* about GUI code in Haskell, though.
09:53:40 <ski> deech : the initial node changes start from a "fringe" of nodes that are "inputs" (no parents inside the network)
09:53:43 <deech> Oh, something like the lisp cells project http://common-lisp.net/project/cells/.
09:54:14 <ski> (this is like a spreadsheet, i should have said)
09:54:49 <gwern> I was about to say...
09:55:06 <deech> ski, I'll have to look into that! I have to get going but thanks a bunch for getting back to me!
09:55:12 <idnar> sounds like Cells or Trellis or whatever
09:55:51 <ski> Adaptive Functional Programming <http://citeseer.ist.psu.edu/old/752721.html> Umut A. Acar, Guy E. Blelloch, Robert Harper
09:56:02 <Baughn> Well, how am I supposed to compare the usefulness of FRP to non-FRP without having something to compare /to/?
09:56:09 <ski> either that's the one with the Haskell implementation, or that's the SML implementation
09:56:16 <ski> deech : see that paper
09:56:16 <Saizan_> ?hackage Adaptive
09:56:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Adaptive
09:56:56 <Saizan_> that's the haskell implementation ^^
09:57:14 <ski> *nod*
09:57:37 * Baughn wonders about its exact relation to FRP.. it sounds pretty similar to reactive values
09:57:57 * ski wonders if there's some relation to RETE
09:59:11 <Baughn> ski: http://en.wikipedia.org/wiki/Rete_algorithm <- This?
09:59:15 <ski> yes
09:59:42 <ski> (i've not really studied RETE, but iirc, a description of it sounded a bit similar)
09:59:44 <Baughn> ski: You think there's a connection? Interesting.
10:00:16 <opqdonut> copumpkin: looking good, i just wrote "cycle3 = dup3 . pop"
10:00:17 <Baughn> Hm. I think I see what you mean.
10:00:27 <copumpkin> opqdonut: cool!
10:00:36 <copumpkin> opqdonut: how did you know I just woke up?
10:00:43 <copumpkin> like, this minute
10:00:43 <Beelsebob> ski: sorry, we seem to have slid past each other repeatedly today
10:00:45 <opqdonut> i didn't, i just wrote that
10:00:46 <opqdonut> :P
10:00:48 <copumpkin> lol
10:00:57 <opqdonut> push and pop correspond to "flip id" and "const", respectively
10:01:03 <opqdonut> swap = flip, dup = join
10:01:06 <ski> Beelsebob : hehe, np
10:01:07 <opqdonut> nice
10:01:46 <opqdonut> i'll explore this a bit further and then publish a short blog post
10:01:49 <ski> opqdonut : that's for a concatenative-DSL ?
10:02:35 <opqdonut> ski: yeah, almost. basically a set of argument-shuffling combinators based on what stack languages usually have
10:02:40 <Baughn> @rememeber gwern I think most haskellers are all thunk, no evaluation
10:02:41 <lambdabot> I will remember.
10:02:43 * ski played a little with making a concatenative DSL where `dup c a = c a a' i.e. `dup = join' some years ago
10:03:22 <mmorrow> , src ''CompF
10:03:25 <lunabot>  newtype CompF f g a = CompF {runCompF :: (f (g a))}
10:03:32 <mmorrow> ski: this one?
10:03:33 <ski> opqdonut : if you want, i could try to dig it up
10:03:40 <tkr> ok. Im not doing this right now, but asking for background information. I want to print a 2d grid on a flat surface. I want to print it on riemann sphere. I want to try differenet transformations on the it. what are my easiest chocies of packages (try to google for a day or so)?
10:03:43 <ski> mmorrow : ah, ty
10:03:53 <ski> mmorrow : any `Lens' or `FRef' or similar ?
10:03:56 <opqdonut> ski: sure, go ahead
10:04:03 <mreh> what is it like using Haskell libraries? I bet you dont have to go spelunking inside the source code like I've just been doing with Java
10:04:18 <tkr> .. as in graphics (if not obvious).
10:04:34 <Baughn> mreh: You'd be surprised, but.. not usually, no. For IO code, quite often.
10:04:54 <mmorrow> ski: hmm, just what's in (the parts of that didn't have name conflicts) category-extras
10:04:59 <Baughn> mreh: At least hackage has convenient function-source-code links.
10:05:18 <mreh> Baughn: itunsafe code
10:05:24 <mreh> what else do you expect
10:05:31 <mmorrow> ski: although if you have some code (for this or whatever) i'd be happy to put it in-scope in lunabot
10:05:39 <Baughn> mreh: Explanations of how it works would be nice. ;_;
10:06:15 <mreh> I'm not into monads yet, I wanna learrrrrrn.
10:06:37 <Baughn> mreh: Reading the typeclassopedia is a good start. :
10:06:39 <Baughn> :)
10:06:46 <Botje> mreh: careful, it's not easy getting out of monads :)
10:07:52 <pastah> Botje: slayMonster :: m a -> a
10:07:54 <mreh> http://arcanux.org/lambdacats/io-monad.jpg
10:08:10 <Botje> :)
10:08:25 <tkr> ok. Let's put this it in a different way. if I can draw a transparent grid, pixel on pixel in memory. can I then do complex transformations on each pixels and will end up having merry pics of transformations I always wanted to program?
10:08:50 <Baughn> pastah: Beware, for those who use slayMonster will most /definitely/ become monsters themselves. -_-;
10:09:08 <lament> i always suspected the IO monad had something to do with naked men
10:09:12 <Baughn> pastah: ..also, I wonder how slayMonster works for the IO monad.
10:09:18 <pikhq> pastah: I'd call that unsafePerformMonad
10:09:35 <pikhq> (as if unsafePerformIO wasn't insane enough)
10:09:38 <pastah> http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
10:10:22 <pastah> pikhq: i suspect you haven't read that
10:11:13 <pikhq> Alas, I have not
10:11:42 <hackagebot> yices 0.0.0.3 - Haskell programming interface to Yices SMT solver (KiYungAhn)
10:13:13 <ski> mmorrow : i just had some code i wanted to play with a little .. possibly using `Lens'es
10:13:52 <c_wraith> pastah, that's awesome
10:13:53 <pikhq> pastah: :D
10:16:34 <pastah> hehe
10:16:45 <Veinor> pastah: I finally get Monads now :D
10:19:01 <Veinor>  Like poisoned candy and release dates, this is of course a myth.
10:19:44 * pikhq slays the monad -- I mean, monster
10:21:11 <Asztal> The "regurgitation law" is going to stick in my head now
10:23:59 <pastah> Veinor: wut?
10:24:30 <Veinor> Reading the monster thing.
10:24:51 <pastah> you like it?
10:25:22 <pastah> .paste
10:25:27 <pastah> @paste
10:25:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:25:38 <pastah> yeeeeeeeeeees
10:25:53 <pastah> it's down
10:25:53 <Veinor> 500 Internal Server Error
10:25:53 <Veinor> 58030 5: database is locked
10:25:55 <Veinor> oh no :(
10:26:19 <pastah> Veinor: have you programmed with any monad except the io monad before?
10:26:33 <skorpan> maybe Maybe
10:26:41 <skorpan> and the list monad
10:26:44 <pastah> skorpan: U FANNI GAI
10:26:49 <skorpan> i'm so funniez ;-)
10:26:59 <skorpan> fanny gay?
10:27:12 <pikhq> skorpan: I'm sure he's used the ((->) a) monad. Just... Not as a monad. ;)
10:27:26 <ski> opqdonut : try <http://www.mdstud.chalmers.se/~md9slj/code/CurriedForth.hs> (this appears to be about eight years old)
10:27:39 <Veinor> I'm still learning.
10:27:41 <skorpan> data Probably a = Yes | Maybe a
10:27:45 <Veinor> But i've done some stuff with Maybe
10:28:19 <pikhq> skorpan: Obvious monad instance. :)
10:28:19 <pastah> Veinor: i learned how most of it works by implementing monad for stack operations
10:28:46 <Veinor> So we have Probably and Maybe. Now we need Possibly, Potentially, and Perhaps.
10:28:47 <skorpan> Maybe x >>= Yes = Yes.. hm no wait
10:29:15 <ski> opqdonut : istr i also tried some with setting labels (continuations) for jumping .. but i can't seem to find that atm
10:29:19 <skorpan> i realised i forgot the monad rules
10:30:20 <pasc1> is there a way to use multi-line textboxes with gtk2hs?
10:30:32 <opqdonut> ski: hmm
10:30:38 <Cale> The simplest form in which to remember the monad laws is in terms of <=<
10:31:12 <Cale> return <=< f = f,  f <=< return = f,  (f <=< g) <=< h = f <=< (g <=< h)
10:31:50 <badsheepy> i prefered regurgi tate :o
10:31:54 <badsheepy> -space
10:32:42 <pikhq> Cale: Arrows make everything so much better.
10:32:45 <pikhq> :)
10:32:48 <pastah> Veinor: pm
10:32:51 <Deewiant> ?ty flip (<=< id)
10:32:51 <ski> opqdonut : any comment ?
10:32:53 <lambdabot> forall b (m :: * -> *) c. (Monad m) => m b -> (b -> m c) -> m c
10:33:49 <c_wraith> :t (>=>)
10:33:50 <opqdonut> ski: nice, nice. in a different direction than I was going, but I can see the power
10:33:50 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:33:56 <opqdonut> trying to figure out fun2 atm :P
10:34:23 <opqdonut> ah, i think i got it
10:34:28 <ski> opqdonut : `fun2' is just lifting a (curried) haskell function of two arguments into a "word"
10:34:34 <c_wraith> :t (>=<>)
10:34:36 <lambdabot> Not in scope: `>=<>'
10:34:43 <c_wraith> aw.  I was hoping for more fish
10:34:55 <ski> opqdonut : just a convenience for defining primitive words like `plus' et.c.
10:35:05 <opqdonut> ski: yeah, something just bugged me about the definition
10:35:19 <opqdonut> re-read it and it made sense
10:35:53 <ManateeLazyCat> dmwit: Are you there?
10:36:14 <opqdonut> yes, I think I'll include something like that, handy for higher-level composition
10:36:23 <opqdonut> or higher-rank or whatever it should be called
10:36:45 <ski> opqdonut : basically a type `(b0 -> b1 -> ... o) -> (a0 -> a1 -> ... o)' should be read as a "word" eating arguments `a0',`a1',... as inputs from the stack and pushing results `b0',`b1',... as outputs on the stack .. `o' is the "final answer type" as in `Cont o'
10:36:49 <hackagebot> musicxml 0.1.2 - MusicXML format encoded as Haskell type and functions of reading (SamuelSilva)
10:36:49 <hackagebot> Binpack 0.3.1 - Common bin packing heuristics (BjoernBrandenburg)
10:37:06 <ManateeLazyCat> dmwit: I'm success with plural library.
10:37:06 <Chimpbama> If you recognize that Negroes carry mostly Homo Erectus traits ( http://www.erectuswalksamongst.us ) while all other races evolved fully into humans, you will love Chimpout.com!  WE ARE NOT WHITE SUPREMACISTS, rather NEGRO INFERIORISTS!  We at Chimpout.com love the rainbow diversity of humanity and welcome Asians, non-Negroid Hispanics, Semites, Indians, Gays, Whites, Turkics, etc.  After all, I am Mexican.  Join in the epic battle of hu
10:37:06 <Chimpbama> man vs NIIIIGGGGER at Chimpout Forums!  http://www.chimpout.com/forum
10:37:18 <ski> opqdonut : it seems maybe what you were after were not exactly a concatenative DSL .. but it appears to me this would be relevant at least
10:37:40 <ski> @where ops
10:37:41 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
10:37:41 <lambdabot> mauke
10:37:55 <Chimpbama> If you recognize that Negroes carry mostly Homo Erectus traits ( http://www.erectuswalksamongst.us ) while all other races evolved fully into humans, you will love Chimpout.com!  WE ARE NOT WHITE SUPREMACISTS, rather NEGRO INFERIORISTS!  We at Chimpout.com love the rainbow diversity of humanity and welcome Asians, non-Negroid Hispanics, Semites, Indians, Gays, Whites, Turkics, etc.  After all, I am Mexican.  Join in the epic battle of hu
10:37:55 <Chimpbama> man vs NIIIIGGGGER at Chimpout Forums!  http://www.chimpout.com/forum
10:38:00 * ManateeLazyCat pasted "Plural.hs" at http://paste2.org/get/359185
10:38:18 <ManateeLazyCat> Above library is for plural word.
10:38:51 <pikhq> Chimpbama: Your implementation of the "racist" monad is of much interest to me.
10:38:55 <pikhq> :P
10:39:12 <opqdonut> ski: i think there is significant overlap, the differences are mostly in perspective
10:39:20 <ski> yes
10:39:41 <opqdonut> my starting point was somebody trying to do @pl \a b c d -> f b c d a or somesuch
10:39:59 <Baughn> @pl \a b c d -> f b c d a
10:40:00 <lambdabot> flip (flip . (flip .) . f)
10:40:23 <c_wraith> I was doing stuff like @pl \a b c d e -> f a b c d e x last night
10:40:35 <opqdonut> which is clearly just rot4
10:40:35 <c_wraith> And yes, it was as ugly as you'd imagine.
10:40:46 <opqdonut> c_wraith: ah
10:40:46 <Deewiant> I imagine it involves "flip flip x"
10:40:47 <c_wraith> Ah, so that's different.  ok.
10:41:06 <Baughn> @type flip flip
10:41:08 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
10:41:09 <opqdonut> c_wraith: yours would be "push x . dup 5 . pop"
10:41:12 <opqdonut> or something like that
10:41:19 <opqdonut> er, dup5
10:41:43 <opqdonut> i'm trying to figure out a nice alternative to having tons of different dups
10:42:01 <ski> (opqdonut : btw, beware my `rot' and `rot_' .. i may easily have mixed those two up)
10:42:16 <opqdonut> ski: i already implemented my own :)
10:42:33 <c_wraith> @pl \a b c d e -> f a b c d e x
10:42:33 <lambdabot> flip flip x . ((flip . ((flip . (flip .)) .)) .) . f
10:42:44 <c_wraith> just for you, Deewiant
10:42:51 <ski> (if we're going to use the names `rot',`rot_', then we should just as well have the traditional concatenative meanings)
10:42:56 <Deewiant> Yeah, I was just looking at those
10:43:05 <pikhq> opqdonut: Use a State [] monad?
10:43:07 <Deewiant> flip f x, flip flip x . f, flip flip x . (flip .) . f
10:45:06 <ManateeLazyCat> @usr
10:45:07 <lambdabot> Maybe you meant: arr ask msg src url users
10:45:11 <ManateeLazyCat> @users
10:45:12 <lambdabot> Maximum users seen in #haskell: 661, currently: 590 (89.3%), active: 23 (3.9%)
10:45:35 <opqdonut> pikhq: kinda defeats the point :)
10:46:48 <pikhq> opqdonut: :)
10:47:26 <tkr> Cale: got a momemnt? I dont need to solve thsi right now. but would like to plot a 2d grid on a flat surface. and then the grid on a sphere surface. and do different transformations, what should I take look at?
10:47:50 <tkr> Cale: Id like to draw toruses on complex plane etc, just to understand analytical index a little better.
10:48:07 <Baughn> tkr: It's not haskell, but.. povray?
10:48:19 <tkr> Baughn: I would love to do it with Haskell
10:48:27 <tkr> the math part
10:48:41 <tkr> Raytracing can be whatever that is good with Haskell.
10:49:21 <tkr> Just learning the basics. yesterday got back from holidays and switched to xmonad. :)
10:50:53 <hackagebot> hamusic 0.1.2.1 - Library to handle abstract music (SamuelSilva)
10:53:50 <ksf> is there some special term for a set that knows of cardinality? basically, an unordered list containing not duplicates but cardinality counters instead.
10:54:35 <lament> bag or multiset
10:55:12 <c_wraith> ksf:  really, that's just an implementation detail
10:55:54 <ksf> so it is, but implementation detail is what i'm caring about right now, as the current implementation using lists is just mindboggingly kludgy.
10:56:25 <ksf> basically, it looks like an executable braindump
10:56:26 <_Philippa_> Map Item Cardinality, w/removals that set Cardinality to 0 removing it instead?
10:56:36 <ksf> yep.
10:56:44 <ksf> in fact, parser choices.
11:00:55 <lament> ksf: maybe try http://hackage.haskell.org/package/multiset
11:01:22 <ksf> argh, I want to use it with bytestring tries.
11:01:31 <ksf> we definitely need a proper common map interface.
11:02:34 <ksf> but now mathematician won't laugh at me when they see my code, as I know the proper term...
11:02:38 <ski> ksf : see also the "Boom hierarchy" ("Bohm"/"Boehm"/"Bhm" ?)
11:03:39 <ksf> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.49.3252
11:04:18 <ski> ksf : was just about to link to that, yes
11:04:29 <ski> (that appears to use "Boom")
11:05:32 <arjanb> boom is tree in dutch
11:06:17 <ksf> ...with a "oo" kind of like in "over"
11:06:41 <ksf> it's an open vowel though, not closed.
11:07:12 <ksf> so you need to be british or something.
11:09:28 <Twey> Dutch oo is just a long o
11:30:32 <Apocalisp> How would you encode fundeps if Haskell didn't have fundeps?
11:31:34 <burp> > foldl (\acc x -> let sum = acc!!0+x in [sum, max (acc!!1) sum, min (acc!!2) sum]) [0,0,0] [1,1,1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1]
11:31:34 <lambdabot>   [0,9,-4]
11:31:50 <burp> anyone has a nicer idea to collect minimum and maximum when adding numbers from left to right?
11:32:10 <burp> something sleek ;)
11:36:27 <ski> > foldl (\(currentSum,currentMax,currentMin) x -> let nextSum = currentSum + x in (nextSum,currentMax `max` nextSum,currentMin `min` nextSum)) (0,-999,999) [1,1,1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1]
11:36:29 <lambdabot>   (0,9,-4)
11:36:40 <ski> (only slightly better)
11:36:45 <burp> lol
11:36:48 <c_wraith> That's the approach I would have used.
11:37:04 <Raevel> @type foldl (\acc x -> max . fst acc &&& min . snd acc) (0,0)
11:37:06 <lambdabot>     Couldn't match expected type `(b1 -> b, b1 -> b2)'
11:37:06 <lambdabot>            against inferred type `b1 -> (b -> b, b2 -> b2)'
11:37:06 <lambdabot>     In the expression: max . fst acc &&& min . snd acc
11:37:15 <Raevel> bah
11:38:20 <Philonous1> > (minimum &&& maximum) $ scanl (+) 0 [1,1,1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1]
11:38:21 <lambdabot>   (-4,9)
11:38:31 <PeakerWork> Apocalisp: I think you'd have to use compile-time scripts (Or the newer type families, of course)
11:38:38 <burp> uh yes
11:38:42 <burp> thats a sleek one
11:38:53 <PeakerWork> Apocalisp: I mean, fundeps/type families add compile-time power, not convenience..
11:39:09 <c_wraith> Where's the sum, though? >_>
11:39:10 <Raevel> @type foldl (\acc -> max (fst acc) &&& min (snd acc)) (0,0)
11:39:12 <lambdabot> forall b. (Ord b, Num b) => [b] -> (b, b)
11:39:22 <Philonous1> burp: but utterly inefficient, since it traverses the list three times
11:40:05 <leimy> Circular data structures in haskell.... or one that behaves like a circular data structure.  Can one use a zipper for this?
11:40:33 <c_wraith> > cycle [1..5]
11:40:34 <lambdabot>   [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,...
11:40:43 <burp> hm, yes true
11:40:48 <mkaemmer> leimy: not sure what sense of the word "circular" you mean
11:40:59 <leimy> I mean I want to implement something a lot like a ring buffer
11:40:59 <mkaemmer> leimy: as in a circular queue?
11:41:06 <burp> I like the triple variant from ski instead of using a list
11:41:06 <ski> leimy : it's not that easy
11:41:09 <mkaemmer> leimy: or self-referential (i.e. codata)
11:41:20 <leimy> I want what I get with pointers :-)
11:41:26 <leimy> when I make a circular linked list.
11:41:30 <leimy> but functionally :-)
11:41:45 <mkaemmer> leimy: maybe a double-stack queue
11:41:46 <ski> leimy : do you want persistent ? or is ephemeral ok ?
11:42:01 <leimy> no persistence needed afaik so far.
11:42:13 <leimy> and in fact it'd possibly be a requirement that it not be persistent
11:42:31 <leimy> ahhh..  I just found http://www.haskell.org/haskellwiki/Tying_the_Knot
11:43:49 <PeakerWork> leimy: Well, a simple list with a circular interpretation of it could do (e.g: What xmonad does in SPJ's taste of Haskell talk)
11:43:56 <ski> if you don't need persistence, would `STRef s' suffice ?
11:44:22 <leimy> posisbly
11:44:26 <leimy> er possibly
11:44:31 <ski> or if you don't need to change or even detect cycles, you can tie the knot
11:45:28 <leimy> Yeah I don't really need to detect the cycles.  I just need to keep writing to a current "spot" and that current spot or cursor seems like it could be anywhere in the structure, as long as it chases it's tail forever.
11:45:37 <leimy> er s/it's/its/
11:46:05 <ksf> don't you need to check for overruns?
11:46:10 <ski> "writing" meaning ?
11:46:13 <leimy> And I'll need to be able to track about 180 of these.
11:46:15 <PeakerWork> leimy: just cons stuff to "write" stuff
11:46:31 <leimy> ksf: no the overrun is the defined behavior.
11:46:43 <PeakerWork> leimy: did you watch the Taste of Haskell talk?
11:46:50 <leimy> PeakerWork: no...
11:46:55 <leimy> didn't know it existed.
11:47:02 <PeakerWork> leimy: I think he explains something very similar to what you want there
11:47:07 <mkaemmer> PeakerWork: link?
11:47:08 <PeakerWork> leimy: SPJ's talk
11:47:18 <PeakerWork> http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-tutorial/
11:47:29 <leimy> in fact a Monad with Writer like semantics would be absolutely perfect for this.
11:47:36 <leimy> as long as the log was a rotating log :-)
11:47:38 <PeakerWork> @where+ Taste http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-tutorial/
11:47:39 <lambdabot> I will never forget.
11:47:40 <ksf> I might getting slapped for it, but I'd use an old-fashioned c-style array.
11:47:56 <leimy> ksf: Yeah, then make an interface for it?
11:48:04 <ksf> if you want to overwrite elements, working with lists and traversing them all the time isn't a good idea.
11:48:04 <PeakerWork> leimy: you want it to start overwriting after a while? If not, use a Writer [] ?
11:48:26 <leimy> PeakerWork: yeah it's a ring buffer.  It will only ever hold the last N bytes
11:48:43 <leimy> if you wanted something before that, it's literally "tough shit" but that's a design constraint :-)
11:48:45 <ksf> ...you just need to pair up the array with a mod-length index.
11:48:54 <leimy> and exactly the semantics I'm looking for.
11:49:37 <mkaemmer> ksf: erm, I suppose so... if you know the length of the array ahead of time
11:49:37 <leimy> I suspect I'm going to want really cheap access times to get to the Nth element
11:49:46 <leimy> And I do know the length up front
11:49:57 <leimy> it's not set in stone yet, but will be around 15k
11:50:01 <PeakerWork> leimy: Well, I speculate that Data.Sequence is good for a FIFO ring like you want, but I am not sure
11:50:03 <leimy> bytes
11:50:21 <leimy> I'm trying to decide if this thing is a Monoid also :-)
11:50:25 <ksf> that's bleeding 4 pages of memory.
11:50:38 <leimy> actually it is :-)
11:50:51 <leimy> ksf:  and multiply that by about 180
11:50:56 <PeakerWork> leimy: Being a Monoid is pretty easy :)
11:50:57 <leimy> I need about 180 buffers :-)
11:51:06 <leimy> PeakerWork: yeah monoids have low requirements
11:51:14 <leimy> associative binary op, and identity.
11:52:26 <leimy> anyway, I'm in the design phase of this stuff right now.  If I can get the memory usage under control, I might be able to write and ship some stuff in haskell in some work stuff.
11:52:32 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-MArray.html
11:52:58 <leimy> I'm still curious about a Zipper for the position in another data structure.
11:53:33 <PeakerWork> A mutable array in ST/IO lets you have a nice O(1) fifo..
11:54:42 <leimy> PeakerWork: that may be what I do.
11:58:38 <opqdonut> ski: i assume i can link to your CurriedForth.hs in my blog article
11:59:47 <Twey> CurriedForth.hs?  What's this?
12:00:29 <opqdonut> http://www.mdstud.chalmers.se/~md9slj/code/CurriedForth.hs
12:01:09 <opqdonut> i'm writing about stackesque argument shuffling combinators
12:03:49 <ski> opqdonut : sure (i have a few other variants of that lying around .. and i at least had one with label support as well)
12:05:16 <ski> but note that this is mostly an old idea exploration .. not really "complete" code in any sense
12:05:31 <ski> (i'm not even sure i've actually run the code)
12:06:28 * ski str someone else was doing something similar some time ago .. but can't recall who
12:07:22 <opqdonut> http://pseudo.fixme.fi/~opqdonut/blog/Stack_oriented_argument_shuffling.html
12:09:25 <ski> nice
12:09:46 <opqdonut> i'm pretty proud of the "deep" examples
12:10:08 <opqdonut> of course, the lambda expressions are shorter :P
12:10:19 <copumpkin> shorter schmorter
12:10:27 <copumpkin> who needs shorter when you have pointfree
12:10:30 <opqdonut> :)
12:11:14 <ksf> I want a map typeclass.
12:12:22 <ksf> ideally, using that cool type-dependent data structure thing dons (iirc) did
12:13:28 <ski> (istr i had your `deep' as well somewhere)
12:13:45 <Milo-> uuh, 79% of my 3Gb memory is in use  by ghc
12:13:48 <ksf> and, in fact, I don't want to write wrappers around data.trie just because I happen to newtype my bytestrings.
12:13:48 <Milo-> update, 85 :D
12:15:51 <Milo-> after 92%, the thrill was gone :(
12:15:56 <ksf> why, oh why am I being punished for type discipline?
12:32:40 <ski> opqdonut : forgot to say, `deep' has been called `result' by conal
12:33:04 <ski>   argument :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b))
12:33:21 <ski>   result   :: (b0 -> b1) -> ((a -> b0) -> (a -> b1))
12:33:31 <dmwit_> So, uh, "cabal build" works, but "cabal install" and "cabal register" each fail.
12:33:37 <dmwit_> Output here: http://pastebin.com/m5005c6a7
12:33:47 <ski>   first   :: (a0 -> a1) -> ((a0,b) -> (a1,b))
12:33:54 <dmwit_> Can I convince cabal to actually install this library?
12:34:00 <ski>   second  :: (b0 -> b1) -> ((a,b0) -> (a,b1))
12:34:03 <ski> et.c.
12:41:10 <PeakerWork> ski: "deep" is a sucky name for "result" :)
12:41:13 <dmwit_> Ah, never mind, I ran Setup.lhs by hand.  I almost forgot about how the system worked before cabal. =P
12:45:57 <Phyx-> @hoogle Constr -> ConstrRep
12:45:57 <lambdabot> Data.Generics.Basics constrRep :: Constr -> ConstrRep
12:45:57 <lambdabot> Data.Generics.Basics fromConstr :: Data a => Constr -> a
12:45:57 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:47:00 <mxc> how unsafe are overlapping instances?
12:47:53 <mxc> specifically, I want to have a general instance Monad (Either a b) in some module which also imports Control.Monad.Reader.Class (asks)
12:48:31 <mxc> but, Control.Monad.Error (imported by Control.Monad.Reader.Class) has an instance Monad (Either String b) declaration
12:49:00 <monochrom> I guess one problem is you don't know which instance is chosen.
12:49:15 <copumpkin> mxc: is that still there in 6.10? I thought they'd changed it
12:50:04 <mxc> i actually can live with the ambiguity for Either String a, but it doesn't type check for any type besides String in Left side
12:50:11 <mxc> copumpkin - it seems like it
12:50:20 <mxc> i remember reading some chatter that they wanted to
12:52:30 <mxc> unless they changed it in 6.10.4
12:52:36 <copumpkin> probably not
12:54:50 <dmwit_> In a library I'm writing, I have "newtype IHateGHC a b = IHateGHC (Either a b)" for exactly this reason.
12:55:04 <copumpkin> lol
12:55:15 <monochrom> Hahaha
12:55:34 <opqdonut> ski: yes, i know
12:55:39 <opqdonut> should probably have mentioned it
12:57:08 <mxc> haha
12:57:31 <mxc> is that getting fixed for 6.12?
12:57:37 <dmwit_> (The "encoding" library defines its own instance for Monad (Either a), so if you use Control.Monad.Error *anywhere in your entire program*, not even in the same module as you use the encoding library, you get an unfixable error.)
12:59:48 <dmwit_> I doubt it will get fixed, unless there's a radical change that takes "fail" out of the Monad class.
13:00:21 <mxc> but wouldn't the ability to hide instances in your import fix it?
13:00:25 * copumpkin crosses his fingers
13:00:30 <wgsilkie> Can someone explain this error to me: <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3142#a3142>
13:00:30 <mkaemmer> I'd be down with that.  It always seemed weird to me to have fail in the Monad class
13:00:36 <dmwit_> mxc: That sounds dangerous.
13:00:37 <mxc> or would that open up a whole set of problems 'm not anticipating
13:00:54 <dmwit_> mxc: I think so, yes.
13:00:59 <mxc> probably
13:01:29 <dmwit_> wgsilkie: Read the error. ;-)
13:01:30 <Phyx-> hmmm hpaste.org went boom?
13:01:32 <mxc> for this specific problem, changing the type constraint from Either String b to (Show a) => Either a b would help
13:01:41 <dmwit_> "Probable cause: `max' is applied to too few arguments"
13:01:52 * wgsilkie disappears.  Never mind.
13:01:59 <copumpkin> wgsilkie: ?
13:02:02 <mxc> thats funny, i'm actually quite argumentative (my first name is max)
13:02:23 <copumpkin> wgsilkie: where do you want the result of that max to go?
13:02:29 <dmwit_> Clue one of three!
13:02:31 <mkaemmer> mxc: I'll remember to apply you to more arguments then
13:02:37 <mxc> excellent
13:02:37 <dmwit_> Now we just have to figure out what 'x' and 'c' stand for...
13:02:39 * wgsilkie disappears.  Never mind.
13:02:42 <Phyx-> does anyone know hoe i can solve this ambiguous type error? http://phyx.pastebin.com/d3e9bac09
13:02:47 <wgsilkie> Be back later.
13:02:47 <mxc> x is the x in max
13:02:53 <mxc> and c is my last name, cantor
13:03:01 <dmwit_> aw, you take all the fun out of it
13:03:04 <copumpkin> ooh, very diagonal
13:03:18 <mxc> as in sets and diagonalization and bond brokers
13:03:23 <dmwit_> :t dataTypeOf
13:03:25 <lambdabot> forall a. (Data a) => a -> DataType
13:03:45 <dmwit_> Phyx-: 'b' is a type variable...
13:03:52 <dmwit_> Phyx-: It has to choose a particular Data instance.
13:03:56 <jorick> :t threadDelay
13:03:58 <lambdabot> Not in scope: `threadDelay'
13:04:02 <jorick> :t Control.Concurrent.threadDelay
13:04:04 <lambdabot> Int -> IO ()
13:04:11 <dmwit_> (undefined :: b) === undefined
13:04:14 <Phyx-> dmwit_: yes, but i don't want to choose at compile time, how do i get around that
13:04:20 <jorick> is there a way to sleep for 0.1 seconds?
13:04:40 <benmachine> threadDelay 10000
13:04:41 <dmwit_> Phyx-: Put something less polymorphic there, is all.
13:04:43 <benmachine> er
13:04:45 <benmachine> 100000
13:05:37 <jorick> whoops i forgot they where microseconds instead of regular seconds :-)
13:07:31 <Phyx-> dmwit_: doing that would not allow me to do what i'm trying to do, which is get the constructor of the type i'm producing
13:07:53 <dmwit_> Phyx-: Oh!
13:08:15 <dmwit_> Phyx-: You want the "b" in (undefined :: b) to match the "b" in (test :: a -> b)?
13:08:23 <Phyx-> yes
13:08:26 <dmwit_> Try ScopedTypeVariables or whatever that language extension is.
13:08:54 <dmwit_> Or you could tie the knot.
13:08:56 <Phyx-> same error
13:09:20 <dmwit_> Yep, you need to add foralls in the "test" type annotation to indicate that they should be scoped.
13:10:00 <Phyx-> ah ok, i'll give that a go
13:10:00 <dmwit_> test a = answer where conDest i = indexConstr (dataTypeOf answer) i; ... -- another approach, supply a value with the actual output type
13:11:36 <dmwit_> I like this tie-the-knot approach a lot, actually.  More than the ScopedTypeVariables way.
13:11:41 <dmwit_> But it's a matter of taste, I guess.
13:11:57 <Phyx-> dmwit_: ah, that's a good one, i'll try it first, thanks :)
13:18:38 <byorgey> @seen dcoutts
13:18:38 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow, #haskell-soc and #haskell-iphone. I last heard dcoutts speak 1d 6h 2m 36s ago.
13:18:57 <dmwit_> ?slap byorgey
13:18:57 * lambdabot places her fist firmly on byorgey's jaw
13:19:12 <byorgey> !!
13:19:15 <dmwit_> Gappa-POW!
13:19:28 <byorgey> oh good, my spelling correction made it into lambdabot
13:19:36 <byorgey> it used to say 'firmely' IIRC
13:19:54 <dmwit_> Olde Engelish
13:20:17 <Phyx-> you got slapped that much to notice? :P
13:20:30 <pikhq> dmwit_: ou failet, meinks.
13:21:04 <byorgey> Ye Olde Robotic-Lambda placeth her Fiste firmely upon thy Mandible
13:22:52 <dubhrosa> newb question: any suggestions for generate_all_bitflips :: [Bit] -> [[Bit]] - i.e. generates all possible bit vectors that are a single bit flip (0->1, not including 1->0) from the input...I'm struggling to see how this should be done using the usual list processing tools, thanks
13:23:19 <pikhq> byorgey: ou mean't, e olde robotic Lambda place her Fite firmly upon y Mandible.
13:23:50 <pikhq> ;)
13:23:58 <dmwit_> dubhrosa: Sounds vaguely comonadic!
13:24:07 <ski> dubhrosa : `generate_all_bitflips [0,1,0] = [[1,1,0],[0,1,0]]' ?
13:24:08 <byorgey> I suppose I do, but this computer doesn't have those glyphs =(
13:24:42 <dmwit_> dubhrosa: You may also be interested in this:
13:24:57 <dmwit_> > liftM2 zip inits tails [1..4]
13:24:58 <lambdabot>   [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
13:25:25 <dubhrosa> ski [0,1,0] -> [ [1,1,0], [0,1,1]]
13:25:45 <ski> sorry, that's what i meant
13:27:20 <dmwit_> > let flip xs (0:ys) = [xs ++ 1 : ys]; flip _ _ = [] in concat . liftM2 (zipWith flip) inits tails $ [0,1,0]
13:27:21 <lambdabot>   [[1,1,0],[0,1,1]]
13:27:37 <dmwit_> What do I win?
13:27:55 <monochrom> More lambdabot source code. :)
13:28:08 <mxc> hpaste is dead?
13:28:14 <dmwit_> hpaste seems dead
13:28:26 <monochrom> how about moonpatio.com ?
13:28:32 <Berengal> It's not dead, it's just resting
13:28:40 <skorpan> hpaste is dead?
13:28:43 <dmwit_> moonpatio.com seems okay
13:29:07 <copumpkin> mmorrow: onoes
13:30:09 <Phyx-> hmm why is ghc saying ForeignPtr isn't a valid ffi type.. if i'm reading the haddock correctly, it should be..
13:30:58 <copumpkin> Ptr is
13:31:20 <Phyx-> yes, but unfortunately, that seems to be a managed pointer
13:31:31 <copumpkin> it's the other way around
13:31:33 <ski> > modifyK element (\x -> if x == 0 then [1] else []) [0,1,0]  -- dubhrosa
13:31:35 <lambdabot>   [[1,1,0],[0,1,1]]
13:31:53 <dmwit_> Neat!
13:31:55 <dmwit_> :t modifyK
13:31:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m (b, b -> a)) -> (b -> m b) -> a -> m a
13:32:08 <dmwit_> *blink*
13:32:14 <copumpkin> Phyx-: Ptr is "raw" and ForeignPtr has finalizers
13:32:17 <dmwit_> ?index modifyK
13:32:17 <lambdabot> bzzt
13:32:36 <ski>   modifyK :: Monad m => FRefK m a b -> (b -> m b) -> (a -> m a)
13:32:50 <Phyx-> copumpkin: but i'm having a strange problem where when i try to read the pointer i get from the haskell lib it's no longer valid
13:32:53 <dmwit_> More readable, thanks. =)
13:32:58 <dubhrosa> both very impressive.... learning Haskell is wonderful as long as you don't mind being humbled
13:33:03 <copumpkin> Phyx-: hmm? how do you mean?
13:33:18 <ski>   modifyK (FRefK lens) mod a = lens a >>= \(b,ba) -> liftM ba (mod b)
13:33:54 <Phyx-> copumpkin: i'm compiling haskell -> win dll and using it from c#, so far all my examples worked but the last one, where reading the pointer somehow corrupts the managed heap
13:33:56 <purplepenguins> one must be willing to forget what is learned and learn again, differently
13:33:58 <ski>   element :: FRefK [] [a] a
13:34:08 <copumpkin> Phyx-: how are you giving a pointer?
13:34:12 <ski>   element = FRefK element'
13:34:22 <ski>   element' [] = []
13:34:31 <ski>   element' (a:as) = (a,\a -> a:as) : map (\(a',f) -> (a',(a:) . f)) (element' as)
13:34:34 <mkaemmer> dubhrosa: IMO, learning Haskell is great, if you don't mind becoming disappointed by 99% of other languages you use
13:34:57 <dmwit_> ski: yowch
13:35:02 <dmwit_> ski: Got a library somewhere?
13:35:05 <FunctorSalad> you reached for the secret too soon....
13:35:13 <ski> nope .. just invented that on the spot
13:35:30 <ski> (well, not `FRefK' .. but the other stuff)
13:35:31 <Phyx-> copumpkin: new
13:35:50 <copumpkin> Phyx-: I'm going to need a little more than that ;)
13:35:56 <Phyx-> sure, one sec
13:36:35 <ski> dmwit_ : it's basically a variant of lenses / functional references / accessors
13:36:48 * dmwit_ nods
13:37:18 <dubhrosa> mkaemmer: yes, I'm only a week in and I can see that beginning to happen to me already...fortunately I've got enough leeway that I can use whatever language I like at work.
13:37:30 <Phyx-> copumpkin: http://phyx.pastebin.com/d7acea40f
13:37:47 <ski> (and `FRefK' is possibly not a very good name .. and better suggestion ?)
13:38:01 <dmwit_> What's the K for?
13:38:02 <ski> (s/and/any/)
13:38:09 <ski> kontinuation
13:38:19 <dmwit_> ...
13:38:20 <dmwit_> hahaha
13:38:25 <ski> other possible keywords are "context"
13:38:32 <mkaemmer> dubhrosa: I'm jealous... I'm quite used to haskell, but have to program in Java :(
13:38:38 <FunctorSalad> the "k" for kontinuation seems to be standard
13:38:39 <FunctorSalad> :)
13:39:10 <FunctorSalad> what do the other letters stand for?
13:39:19 <ski> which ?
13:39:24 <FunctorSalad> in FRefK
13:39:27 <dubhrosa> mkaemmer: yikes, that must be frustrating.
13:39:47 * Cale guesses Functional Reference
13:39:53 <ski>   newtype FRef a b = MkFRef (a -> (b,b -> a))  -- plain functional reference / lens
13:39:56 <FunctorSalad> (at the point where any short descriptive name becomes so cryptic, it's sometimes better to call it "bacon" or something)
13:40:05 <ski> compare `IORef',`STRef s'
13:40:24 <ski> the idea being comparing
13:40:43 <ski>   readIORef :: IORef a -> IO a
13:40:46 <Cale> FunctorSalad: Set theory is full of ridiculous names, because everything eventually is so ridiculously technical and abstract that there are no reasonable names.
13:40:47 <copumpkin> Phyx-: I'm not sure what's going on... do you have foreign exports that return a Ptr? is the C# code trying to get at that? how do you get a Ptr from your data? are you making sure your data is "pinned"?
13:41:03 <ski>   readFRef :: FRef e a -> e -> a
13:41:12 <ski>   readFRefK :: FRef k e a -> e -> k a
13:41:12 <mkaemmer> dubhrosa: it's... interesting.  I find myself programming Java as if it were a functional language most of the time.
13:41:22 <FunctorSalad> Cale: Set-theory uses all these awe-inspiring words
13:41:31 <FunctorSalad> ;)
13:41:40 <Phyx-> copumpkin: well, my foreign export is foreign export stdcall typeTest2 :: SelectorTypePtr -> TwoCasesTypePtr
13:41:40 <FunctorSalad> like for the large cardinals
13:42:01 <Cale> FunctorSalad: Like zero hand-grenade
13:42:05 <Phyx-> copumpkin: but i'm not sure how to pin the data, that's why I thought ForeignPtr was the way to go, as i thought that was unmanaged
13:42:13 <FunctorSalad> "cofinality" also sounds epic
13:42:17 <ski> Cale : yes, often it's better with a (previously) meaningless name, rather than a misleading one
13:42:20 <FunctorSalad> Cale: is that actually from set theory?
13:42:24 <Cale> yes
13:42:44 <dmwit_> I want to a math lecture on infinities, and they kept throwing around words like "hyperuniverse" and "ultra-finitary" and stuff like that.
13:42:48 <dmwit_> I got so lost...
13:43:27 <Phyx-> copumpkin: and my c# code just gets a pointer and converts them to the same structures i defined in the c header file in order to compile the haskell file. this wasn't the first test that used this, lemme paste the header
13:43:42 <Cale> http://arxiv.org/pdf/math.LO/0002089
13:43:45 <FunctorSalad> inaccessible cardinals... hovering unreachably over the world of mere mortal iterated powersets of N
13:44:05 <Phyx-> copumpkin: http://phyx.pastebin.com/d310f22fc
13:44:12 <FunctorSalad> (does the limit of that exist in ZF?)
13:44:15 * copumpkin has a cardinal on his deck
13:45:13 <copumpkin> Phyx-: you might want to malloc some memory and use your storable instance to write it there
13:45:30 <Phyx-> copumpkin: isn't that what new does implicitly?
13:45:42 <Phyx-> @type new
13:45:44 <lambdabot> Not in scope: `new'
13:45:50 <Phyx-> @hoogle new --info
13:45:51 <lambdabot> Data.HashTable new :: key -> key -> Bool -> key -> Int32 -> IO (HashTable key val)
13:45:51 <lambdabot>  
13:45:51 <lambdabot> Creates a new hash table. The following property should hold for the eq and hash functions passed to new:
13:45:54 <Phyx-> wrong new
13:45:57 <copumpkin> lol
13:45:58 <dubhrosa> mkaemmer: yeah, I do c++ mainly and I find the same thing - even simple changes like passing everything into a func as a parameter rather than using member vars, cleans things up so much
13:45:58 <Phyx-> @hoogle foreign new --info
13:45:59 <lambdabot> Foreign.Concurrent newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
13:45:59 <lambdabot>  
13:45:59 <lambdabot> Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The finalizer will be executed after the last reference to the
13:45:59 <lambdabot> foreign object is dropped. Note that there is no guarantee on how soon the finalizer is executed after the last reference was dropped; this depends on the details of the Haskell storage manager. The
13:45:59 <lambdabot> only guarantee is that the finalizer runs before the program terminates.
13:46:04 <Phyx-> o.O
13:46:08 <Phyx-> wrong new again
13:46:10 <Phyx-> lol
13:46:16 <FunctorSalad> Cale: nice
13:46:19 <Cale> FunctorSalad: Oh, they also seem to like naming things after animals
13:46:28 <Phyx-> the correct type is something like Storable a => a -> Ptr a
13:46:37 <Cale> FunctorSalad: "Let us now discuss iterations of premice."
13:46:50 <FunctorSalad> LOL
13:46:53 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Utils.html#v%3Anew
13:47:17 <Cale> There's something called a mouse, and then of course, a premouse is a mouse without some condition or something :)
13:47:19 <Phyx-> copumpkin: a function with the type "typeTest1 :: CInt -> CString -> SimpleTypePtr" does work fine
13:47:22 <Phyx-> so i know i can read them
13:47:27 * FunctorSalad also like how "weak head normal form" literally translates to something meaning "dumbass normal form" in german
13:47:37 <copumpkin> lol
13:47:42 <Cale> and I recall hearing something about beavers and... I'm not sure
13:47:55 <skorpan> heh, you said beaver
13:48:08 <dmwit_> skorpan has an alert on the word "beaver", apparently
13:48:16 <skorpan> dmwit_: i'm a bot
13:48:27 <dmwit_> You pass. Next!
13:48:48 <luite> hm, they also have universal weasels
13:49:31 <Phyx-> copumpkin: i'm currently trying to read it in c, to see if it's the c# interop code that's messed up, but i can't get the c file to compile because i can't find where ghc compiled some closures to... the stub file it makes declares them extern, but the .a file it made doesn't have them
13:49:36 <Phyx-> *shrug*
13:49:47 <copumpkin> hmm, weird
13:51:27 <Cale> "Definition 2.9 Let M be a premouse. Then M is called domestic iff there is no   M  OR such that..."
13:51:34 <luite> hehe
13:51:38 <Cale> domestic premice
13:51:52 <Cale> Later... "Corollary 2.11 If there is no non-domestic premouse, then the certified K c exists and is a mouse."
13:52:12 <Cale> K^c
13:54:00 <leimy> Anyone have an example of using MArray laying around somewhere?
13:54:10 <leimy> I have never tried to use it or ST before so... :-{
13:55:07 <Cale> leimy: Hmm, running into problems?
13:55:24 <leimy> No I just don't know how to even start using things like newArray based on the type signature.
13:56:09 <Saizan> ?type newArray
13:56:11 <lambdabot> Not in scope: `newArray'
13:56:16 <Saizan> ?hoogle newArray
13:56:17 <lambdabot> Data.Array.Base newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
13:56:18 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
13:56:18 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
13:56:23 <Cale> You give newArray a pair of bounds, and an element to initialise the array with, and it gives an action which when run will construct you an array.
13:56:44 <leimy> right... but when I start trying to play with it in GHCI
13:56:49 <leimy> it wants me to specify a type
13:56:54 <leimy> and I'm not sure what that type is.
13:57:35 <Cale> leimy: right, it's easy in ghci to have the type be ambiguous
13:57:41 <leimy> yep
13:58:38 <Cale> runST (do a <- newArray (1,10) 0 :: ST s (STArray s Int Int); readArray a 5)
13:58:59 <Cale> That ought to work
13:59:18 <mauke> > replicateM 5 (['a' .. 'z'] ++ ['0' .. '9'])
13:59:20 <lambdabot>   ["aaaaa","aaaab","aaaac","aaaad","aaaae","aaaaf","aaaag","aaaah","aaaai","a...
13:59:59 <Cale> > length (['a' .. 'z'] ++ ['0' .. '9']) ^ 5
14:00:01 <lambdabot>   60466176
14:00:34 <leimy> Cale: cool thanks!
14:01:03 <leimy> Cale: for some reason I felt like I needed to tell ghci the "s" part of "ST s (STArray s Int Int)"
14:01:16 <Cale> leimy: The important thing about that s parameter is that it remain always polymorphic, and that all the STRefs/STArrays you use have the same s parameter as the ST actions in which they're used.
14:01:20 <leimy> But I suppose leaving s out of it makes it's kind * -> *
14:01:29 <leimy> er its
14:01:50 <Cale> The s needs to be polymorphic, if you specify it, the computation becomes unusable
14:01:59 <Cale> this is because:
14:02:01 <leimy> that's what I was getting hung up on.
14:02:02 <Cale> :t runST
14:02:04 <lambdabot> forall a. (forall s. ST s a) -> a
14:02:20 <Cale> runST requires the computation that it's given to be polymorphic in s
14:02:51 <Cale> This is the mechanism which prevents state variables from escaping and getting into some other call to runST.
14:03:06 <Cale> (which would break referential transparency and be generally unsafe)
14:03:10 <leimy> I see
14:03:38 <ski> @hoogle (i,i) -> (i -> e) -> m (a i e)
14:03:38 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
14:03:38 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
14:03:38 <lambdabot> Data.Array.Base mapIndices :: (MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)
14:03:46 <ski> @hoogle (i,i) -> (i -> e) -> a i e
14:03:47 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
14:03:47 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
14:03:47 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
14:06:07 <benmachine> if I have an ordered sequence of characters from which I will be inserting and deleting at any position, is there a better data structure for that than String?
14:06:26 <benmachine> I will probably be usually inserting/deleting at the end
14:06:39 <ski> reverse the string ?
14:07:01 <benmachine> yeah I can do that I suppose
14:07:37 <benmachine> any doubly-linked lists in the standard library?
14:07:37 <sebaseba> Data.Sequence is an option
14:07:48 <Phyx-> i must be going crazy... i could swear i saw some haskell code i needed and now it's gone...
14:08:09 <sebaseba> that's because it was a phantom type!
14:08:39 <_Philippa_> don't worry, it'll keep on haunting you
14:08:41 <PeakerWork> benmachine: Doubly-linked lists are only useful mutable structures, not as functional ones..
14:08:46 <Phyx-> hmm what trickery is this..
14:09:37 <Vulpyne> Is there a length limit?
14:09:39 <ski> (s/functional/persistent/ .. maybe s/mutable/ephemeral/ too)
14:09:53 <PeakerWork> @type length
14:09:55 <lambdabot> forall a. [a] -> Int
14:09:57 <PeakerWork> > maxBound :: Int
14:09:58 <lambdabot>   9223372036854775807
14:10:04 <PeakerWork> Vulpyne: That's a length limit :)
14:10:10 <ski> > maxBound `asTypeOf` length undefined
14:10:12 <lambdabot>   9223372036854775807
14:10:16 <benmachine> PeakerWork: basically I'm interested in a structure like a list that works in both directions
14:10:17 <Vulpyne> Not quite what I meant, but thanks. :)
14:10:21 <PeakerWork> but lower limits will probably be hit first
14:10:33 <PeakerWork> benmachine: Data.Sequence might be that
14:10:39 <Vulpyne> I was asking regarding benmachine's question.
14:10:48 <benmachine> oh right
14:11:01 <benmachine> Vulpyne: I'd prefer to avoid one, but it's not out of the question
14:11:09 <benmachine> there's a *typical* line length which is pretty sure
14:11:11 <benmachine> er
14:11:13 <benmachine> pretty short
14:11:25 <benmachine> PeakerWork: okay I'll have a look; where do I find it?
14:11:38 <Vulpyne> Well, if you knew you were inserting/deleting at the end, you could just use some sort of array and copy stuff in at the end to insert, and set the length to remove stuff from the end.
14:11:43 <benmachine> wait this is what google is for
14:12:05 <mercury^> benmachine: zipper?
14:12:08 <benmachine> Vulpyne: trouble with arrays is that it's expensive to insert/delete in the middle
14:12:43 <benmachine> hmm, Data.Sequence is allegedly in base, but I don't seem to have the docs for it
14:12:44 <PeakerWork> benmachine: http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Sequence.html
14:12:50 <benmachine> mercury^: what's zipper
14:12:56 <benmachine> PeakerWork: ah right, thanks
14:13:04 <copumpkin> , permutations [1..]
14:13:06 <lunabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
14:13:07 <Vulpyne> Vulpyne: Yeah.
14:13:10 <Vulpyne> Er... benmachine.
14:13:10 <mercury^> benmachine: http://en.wikibooks.org/wiki/Haskell/Zippers
14:13:14 <copumpkin> , permutations [1..] !! 5
14:13:15 <lunabot>  [1,3,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:13:22 <mercury^> beautiful wikibook section
14:13:25 <Vulpyne> Talking to myself is the first sign of insanity.
14:13:25 <ski> > let tick = State (\x -> (x,x+1)) in last (liftM2 (:) tick (replicateM (maxBound `asTypeOf` length undefined) tick) `evalState` 0)
14:13:31 <lambdabot>   mueval-core: Prelude.read: no parse
14:13:31 <lambdabot>  mueval: ExitFailure 1
14:13:40 <mercury^> benmachine: there's also the original paper by huet somewhere
14:13:53 <mercury^> and very nice papers doing awesome stuff with zippers
14:15:49 <benmachine> mercury^: okay thanks
14:16:24 <leimy> Cale: thanks that helped a ton.
14:17:06 * sm notes a really good answer at http://stackoverflow.com/questions/1012573/how-to-learn-haskell 
14:17:09 <mercury^> benmachine: it's a bit more general, but the data structure you want is a special kind of zipper (the zipper of a list) and it's good to know about them anyway.
14:21:29 * benmachine tries to work out where his docs went
14:27:21 <hackagebot> pop3-client 0.1.3 - POP3 Client Library (PeterVanDenBrand)
14:27:31 <Cale> leimy: no problem.
14:28:14 <ski> sm : nice
14:35:27 <Phyx-> dmwit: that tying the knot trick worked btw, thanks
14:37:59 <dmwit> Oh, great!
15:01:21 <Vulpyne> Huh. In case pattern matching on an Either why wouldn't "Right x -> Right x" be the same as "x@(Right _) -> x"? I have a feeling it's something stupid...
15:01:30 <mauke> types
15:01:52 <Vulpyne> Well, yes, it does produce a type error. :)
15:01:53 <mauke> Either a b -> Either a b; Either a b -> Either c b
15:01:56 <Vulpyne> But I don't completely understand why.
15:02:25 <mauke> > () : (case "" of [] -> [])
15:02:27 <lambdabot>   [()]
15:02:31 <mauke> > () : (case "" of x@[] -> x)
15:02:33 <lambdabot>   Couldn't match expected type `()'
15:02:34 <monochrom> Ah. Like Either Bool Int vs Either Char Int. Both look like Right 10.
15:03:05 <Vulpyne> Interesting.
15:03:29 <Vulpyne> Thanks.
15:06:52 <Rotaerk> bleh, haskell's an evil temptation
15:07:07 <Rotaerk> I was going to use XNA to build my game, but I think haskell might convince me to just use OGL
15:08:41 <_Philippa_> heh. My gf and I're contemplating using XNA, I should find out how hard it is to use F# with it
15:09:47 <Rotaerk> _Philippa_, using XNA from F# is easy, but to get access to the content pipeline and other stuff, I believe the app project must be an XNA project which only comes in C# atm
15:10:03 <Rotaerk> so you can put most of the code in F# and then use it from that barebones C# one
15:10:20 <_Philippa_> *nod*
15:25:29 <sclv> I worked with a ruby programmer once, but no matter what he did, he made a hash out of it.
15:25:32 <sclv> *rimshot*
15:26:37 * Phyx- hands sclv  his pills
15:26:45 <mike-burns> That's totally a Perl joke.
15:27:38 <Rad0x> ?DCC SEND "ff???f?" 0 0 0\
15:27:39 <lambdabot> Unknown command, try @list
15:27:59 <benmachine> @where ops
15:27:59 <idnar> man, people still haven't fixed that stupid bug yet?
15:27:59 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
15:27:59 <lambdabot> mauke
15:28:13 <benmachine> evidently not
15:28:14 <sjanssen> benmachine: whatup?
15:28:17 <idnar> benmachine: he already parted
15:28:27 <benmachine> yeah, sorry
15:28:28 <benmachine> I am slow
15:28:35 <Badger> doesn't matter
15:28:42 <sjanssen> oh, Rad0x.  Is that still the Linksys router glitch?
15:28:44 <Badger> can be banned now
15:28:54 <goomba> i keep forgetting to connect to port 8000
15:28:54 <sjanssen> (was it Linksys, or some other vendor?)
15:29:13 <sjanssen> goomba: isn't there a firmware fix or something?
15:29:38 <goomba> i dont think so....
15:29:58 <Badger> sjanssen: n=rad0x@d594efd3.static.dsl.concepts.nl might be a good ban
15:30:02 <Badger> well
15:30:06 <Badger> less specific
15:30:10 <goomba> my firmware is pretty up to date for this router
15:30:11 <Badger> and all that
15:34:12 <Phyx-> goomba: try dd-wrt
15:34:20 <Phyx-> if your router is supported
15:37:41 <goomba> i have the first router version that had less memory and wouldnt support dd-wrt last time i checked, but that was a year or two ago...
15:40:04 <altmattr> literate code is great, but it is not quite enough in a lot of cases
15:40:04 <Phyx-> if it just me, or has dd-wrt developement completely stalled..
15:40:21 <altmattr> When you want to include code in a paper for example, you can't include it all
15:40:40 <altmattr> In the past I hacked together my own pre-processor, but we are surely all doing this over and over
15:40:51 <altmattr> are there any commonly used tools to do this???
15:40:59 <Phyx-> for latex, lhs2tex
15:41:08 <goomba> oooh, i do see support for my version now, maybe i will have a go at it :)
15:41:20 <Phyx-> and then \begin{code} and \begin{example}
15:42:22 <altmattr> oooo, nice
15:42:31 <altmattr> Phyx-: you legend
15:43:37 <Phyx-> altmattr: it does a couple of other things aswell, http://people.cs.uu.nl/andres/lhs2tex/ has a manual with examples etc
15:44:23 <altmattr> I am reading it right now.  Even if it does not do exactly what I want (and that looks unlikely), it is exactly what I was asking about
15:48:09 <Phyx-> @hoogle ConstrRep -> DataType
15:48:10 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:48:10 <lambdabot> Data.Generics.Basics dataTypeOf :: Data a => a -> DataType
15:48:10 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:48:18 <Phyx-> @hoogle ConstrRep -> Constr
15:48:18 <lambdabot> Data.Generics.Basics repConstr :: DataType -> ConstrRep -> Constr
15:48:18 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:48:18 <lambdabot> Data.Generics.Basics toConstr :: Data a => a -> Constr
16:10:04 <altmattr> having strange problems with cabal
16:10:04 <altmattr> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3143#a3143
16:10:14 <altmattr> any ideas?
16:14:14 <altmattr> bugger - looks like a known 6.10.3 bug
16:14:25 <altmattr> I guess I am off to get 6.10.4
16:15:13 <Raevel> altmattr: i dunno about this, but utf8-string seems to be installed on the user mattr, while you try to intall lhs2tex on root
16:16:33 <altmattr> Raevel: interesting point, but notice I get he missing package error when I do configure as mattr?  strange
16:17:01 <Raevel> i just tried building lhs2tex myself (osx also), and it worked :-o
16:17:27 <altmattr> Raevel: are you using 6.10.4?
16:17:41 <Raevel> nope, .3
16:17:52 <altmattr> that is strange
16:18:02 <Raevel> i'm not using the haskell platform though
16:18:21 <altmattr> well, there is a cafe mailing list thread where updating to 10.4 fixed this exact problem, so I will try that first
16:18:42 <altmattr> Raevel: did you get ghc from the haskell platform?
16:19:14 <Raevel> no, macports
16:19:33 <altmattr> sorry, I just saw you already said that!
16:19:42 <altmattr> that must be the problem there
16:19:48 <altmattr> I should have stuck with my old frient macport
16:20:00 <altmattr> but platform is so shiny and new!
16:20:05 <altmattr> and standardised!
16:20:18 <Raevel> :-/
16:22:58 <Twey> Can I override the function GHCi applies to print values?
16:23:26 <Twey> It's currently System.IO.print, and I'd like to use UTFPrelude.print instead
16:23:26 <dobblego> instance Show ?
16:23:30 <dobblego> oh
16:23:41 <Twey> All values, not just specific ones
16:38:15 <Philonous> Why does "logToFile file chan = forkIO $ withFile file AppendMode $\handle -> forever $ readChan chan >>= BS.hPut handle" give me "hClose: illegal operation (handle is finalized)" ?
16:38:44 <Philonous> BS = ByteString
16:41:25 <Saizan> are you sure the exception comes from that handle?
16:41:50 <Philonous> Yes, I'm fairly sure
16:45:05 <Philonous> The withFile should catch BlockedOnDeadMVar and close the handle gracefully, shouldn't it?
16:45:46 <Philonous> Actually, on second thought It might not be the best idea to rely on BlockedOnDeadMVar to close my handles, after all
16:51:23 <altmattr> just letting you all know the update to the latest haskell platform fixed the problem :)
17:02:01 <Baconizer> What would be the equivalent of a pipe in Haskell?
17:02:14 <Baconizer> For instance, in the first problem of H-99
17:02:31 <Baconizer> If it was like a shell, I might put reverse list | head
17:02:58 <pikhq> Baconizer: "It depends".
17:03:18 <Baconizer> pikhq: that explains everything, thanks :P
17:03:24 <Twey> Often, head $ reverse list
17:03:32 <Baconizer> Twey: I'll try that
17:03:33 <pikhq> In this case, you could do: head $ reverse list
17:03:36 <Twey> >>= with monads, &c.
17:03:40 <Twey> >>> for arrows
17:03:45 <Twey> . for functions in general
17:04:00 <pikhq> fmap for functors in general.
17:04:14 <pikhq> <$> for applicative functors.
17:04:17 <pikhq> Etc.
17:04:20 <Baconizer> Okay, head $ reverse list worked
17:04:20 <Twey> (if you had more functions to apply to the above, the idiom is foo . bar . baz . arthur $ list
17:04:24 <Twey> )
17:04:30 <c_wraith> :t (<$>)
17:04:31 <shachaf> pikhq: (<$>) works for Functors in general.
17:04:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:04:35 <Baconizer> So it's like a reverse pipe, sort of?
17:04:39 <pikhq> shachaf: Oh. Right.
17:04:44 <c_wraith> Only <*> requires applicative
17:04:47 <pikhq> It just happens to be in Control.Applicative.
17:04:51 <Twey> Baconizer: Close enough.
17:04:57 <pikhq> XD
17:05:15 <Raevel> @src (.)
17:05:16 <lambdabot> (f . g) x = f (g x)
17:05:26 <Baconizer> Thanks :D
17:05:27 <pikhq> Baconizer: Though you've not seen this yet (I bet), you could do: reverse list >>> head
17:05:29 <Twey> Functions are also arrows, so you can also write that as: reverse >>> head $ list
17:05:32 <pikhq> Arrows. :)
17:05:35 <Twey> Heh
17:05:47 <Twey> I don't think you can do reverse list >>> head.
17:05:50 <pikhq> Erm. What Twey said.
17:05:54 <pikhq> Twey: Thinko.
17:05:55 <Twey> reverse list is not a function, and therefore not an arrow.
17:05:57 <Twey> 'kay.  :)
17:06:13 <Peaker> @type evalStateT
17:06:15 <dibblego> Baconizer, reverse >>> head
17:06:15 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
17:06:21 <Peaker> I wish the arg order was flipped
17:06:23 <dibblego> @type reverse >>> head
17:06:25 <lambdabot> forall a. [a] -> a
17:06:26 <Peaker> evalStateT initialState $ do ...
17:06:35 <shachaf> How about "last list"? :-)
17:06:36 <Peaker> (`evalStateT` initialState) . forever $ do -- a bit ugly
17:06:46 <c_wraith> Why do I always read evalState as evilState?
17:06:47 * shachaf is sure he is missing context.
17:06:59 <shachaf> c_wraith: Because state is evil. Why else?
17:07:23 <pikhq> Peaker: flip evalStateT initialState $ do ... -- ?
17:07:25 <Baconizer> shachaf: ye, I could do that, but in H-99 it says head . reverse as well
17:07:40 <Baconizer> head . reverse was not working, and I figured there had to be some kind of a pipe-type thingy
17:07:44 <Peaker> pikhq: Not nice
17:07:44 <pikhq> shachaf: Because Baconizer was asking what the equivalent of a pipe in Haskell is.
17:07:52 <pikhq> Peaker: Truth.
17:07:56 <Peaker> pikhq: I don't see when you want to give the state action first, ever
17:08:00 <shachaf> Oh. >>=, isn't it?
17:08:18 <pikhq> shachaf: For the monads, sure.
17:08:28 <pikhq> Not for the arrows. ;)
17:08:47 <c_wraith> Lots of stuff is monads.  grammatically.
17:09:00 <dons> Hackage Download Rankings August 2009 http://www.galois.com/~dons/hackage/august-2009/popularity-august-2009.html
17:09:06 <shachaf> pikhq: I was thinking of http://okmij.org/ftp/Computation/monadic-shell.html . :-)
17:09:12 <Baconizer> >>> is for arrows, >>= is for monads, $ and . are for functions, correct?
17:09:13 <pikhq> shachaf: Oh, right.
17:09:28 <shachaf> dons: Are these all the Hackage downloads ever?
17:09:34 <pikhq> That's more saying that the UNIX pipe is a monad, though. :P
17:09:39 <pikhq> Baconizer: Basically, yeah.
17:09:39 <dons> shachaf: yes, cumulative
17:09:41 <FunctorSalad> Baconizer: (.) is for arrows if you import Control.Category
17:09:47 <FunctorSalad> otherwise functions, yes
17:09:49 * Twey made a really awesome pun on Haskell and the Ilak MONADIC perspective once, but doesn't think anybody got it. :(
17:09:55 <Baconizer> ok, thanks
17:09:55 <dons> shachaf: see http://www.galois.com/~dons/hackage/august-2009/ for month-by-month
17:10:35 <Twey> Baconizer: In reverse order of likelihood of utility, yes.  :)
17:10:46 <Twey> (for a newbie)
17:19:13 --- mode: irc.freenode.net set +o ChanServ
17:19:13 <Gracenotes> :: Expr
17:19:13 <dmwit> > ap f (g :: Expr -> Expr) x :: Expr
17:19:13 <lambdabot>   f x (g x)
17:19:13 <Gracenotes> success
17:19:13 <ManateeLazyCat> inimino: Text.Plural.En or Text.Plural.English ?
17:19:13 <pikhq> There.
17:19:13 <Gracenotes> > (=<<) f (g :: Expr -> Expr) x :: Expr
17:19:13 <Gracenotes> >:[
17:19:13 <Peaker> hmm.. SDL draw is missing bindings
17:19:13 <shachaf> ManateeLazyCat: I don't think you handle "bigfoot", by the way.
17:19:21 <lambdabot>   f (g x) x
17:19:25 <inimino> I'm not sure it really belongs under 'Text'
17:19:35 <dmwit> shachaf: ...what *should* the plural of that be?
17:19:39 <ManateeLazyCat> inimino: So belong to ?
17:19:42 * dmwit quite likes "bigfeet" as an answer
17:20:01 <Gracenotes> clearly the answer is bigsfoot
17:20:02 <pikhq> @src ap
17:20:03 <lambdabot> ap = liftM2 id
17:20:07 <pikhq> ^ Screwy stuff. :)
17:20:10 <idnar> bigsfeet?
17:20:12 <dmwit> shachaf: (My policy would be: if you try to pluralize a proper noun, you get to keep all the pieces.)
17:20:20 <copumpkin> bigsfootses
17:20:21 <shachaf> Ooh, and you don't handle "mongoose"!
17:20:27 <copumpkin> or moose
17:20:28 <idnar> "bigfoots" would be the correct answer, though
17:20:45 <shachaf> The first result on Google says "bigfoot" is the correct plural.
17:20:46 <copumpkin> the plural of mongoose is clearly mongeese, and meese is moose
17:21:02 <shachaf> copumpkin: "moose" seems to be handled, no?
17:21:13 <copumpkin> oh maybe
17:21:19 <dmwit> shachaf: Wait until he gets it on Hackage, then submit a patch. ;-)
17:21:44 <Gracenotes> but, for example, people don't seem to realize that the plural of "attorney at lol" is "attorneys at lol"
17:21:53 <Gracenotes> and not "attorney at lols", which is different
17:21:57 * shachaf wonders whether Text.English.Plural might make more sense.
17:22:02 <edwardk2> Has anyone tried using Parsec with oleg's Iteratee stuff?
17:22:06 <shachaf> (Since some languages treat plurals very differently.)
17:22:22 <edwardk2> I can't seem to figure out a good way to get uncons put together that would admit 'try' to function correctly
17:22:22 <dmwit> Now that is truly bikeshedding.
17:22:42 <Saizan> Language. maybe?
17:22:43 <ManateeLazyCat> Text.English.Plural have any different idea?
17:22:54 <copumpkin> Language.English.Plurals
17:23:30 <ManateeLazyCat> Language.English.Plurals looks good.
17:23:43 <copumpkin> Language.Human.Germanic.English.Plurals
17:23:43 <inimino> sounds good
17:23:45 * shachaf would suggest "Plural" instead of "Plurals".
17:23:55 <shachaf> Isn't Language.* for programming languages?
17:24:07 <copumpkin> a non-plural plurals word would be a contradiction!
17:24:22 <shachaf> Unless you were to have "Language.Lojban", perhaps. :-)
17:24:42 <Saizan> Language.Natural
17:24:58 <shachaf> ManateeLazyCat: You don't need to handle "life"->"lives" if you handle "ife"->"ives", do you?
17:25:01 <edwardk2> copumpkin: unless it is being used as an adjective =)
17:25:09 <copumpkin> nah, even then
17:25:28 <Saizan> edwardk2: what do you have as stream and monad there?
17:25:29 <pikhq> copumpkin: Language.Human.IndoEuropean.Germanic.AngloFrisian.English.Plurals
17:25:29 <dmwit> shachaf: Seriously.  Collect these suggestions in a patch.
17:25:37 <ManateeLazyCat> shachaf: Yep, "life" -> "lives".
17:26:02 <edwardk2> saizan: i'm still kicking it around but the naive answer is that the stream is some unit like type and the monad is Iteratee
17:26:23 <edwardk2> Saizan: where my iteratee is only slightly modified because it works with bytestrings
17:26:30 <shachaf> ManateeLazyCat: But you don't need the special case for it, since you have "ife"->"ives" anyway, right?
17:26:36 <dmwit> I know I'll be sending in a patch deleting the redundant "ndum$" and "um$" patterns, and generalizing the "nucleus$", "hippopotamus$", and a few others to a "us$" pattern. =)
17:26:37 <ManateeLazyCat> Now Plural.hs is buggy, first discuss Path Name. Then fix bug.
17:26:43 <shachaf> Also, you don't handle "biscotto" -> "biscotti".
17:27:26 <shachaf> dmwit: Make sure you handle "virus". :-)
17:27:48 <edwardk2> Saizan: lemme get it to compile and i'll hpaste
17:27:54 <copumpkin> "panino" -> "panini"
17:28:01 <copumpkin> unlike what most people think, "panini" is not a singular
17:28:07 <Saizan> edwardk2: it seems like the stream needs to be some sort of index and you have to modify Iteratee to tell this index to the enumerator
17:28:08 <shachaf> "matrices" is also redundant.
17:28:15 <dmwit> copumpkin: it's in there
17:28:15 <copumpkin> dominatrices?
17:28:24 <copumpkin> aha
17:28:57 <ManateeLazyCat> Language.Human.English.Plural okay?
17:29:08 <copumpkin> hah, I was just kidding about the Language.Human
17:29:14 <dmwit> Language.English.Plural is enough
17:29:23 <ManateeLazyCat> dmwit: Okay.
17:29:31 <edwardk2> Saizan: yeah i've been trying to figure out a good way to do that. i can add an integer position, and i can perhaps modify iteratee to hold onto bytestring chunks for so many chars so i can get bounded backtracking
17:29:41 <edwardk2> i only really need to be able to backtrack as long as my longest keyword
17:29:43 <dmwit> ManateeLazyCat: P.S. Your English is improving a lot. =)
17:29:56 <ManateeLazyCat> dmwit: Hehe.
17:30:07 <edwardk2> i might even be able to get it down to 2 chars or so
17:30:09 <ManateeLazyCat> dmwit: But really bad sometimes.
17:30:15 <edwardk2> as the longest backtrack that i actually need
17:30:20 <Peaker> Lemmih: you here? Do you have a repo for SDL? I think I found another bug
17:30:32 <dons> _roconnor: thanks for spotting the double count :)
17:30:44 <shachaf> ManateeLazyCat: I would suggest making "criterion"->"criteria" more specific -- I don't think it's true in the general case.
17:31:09 <ManateeLazyCat> shachaf: Okay, wait me upload, then send me patch?
17:31:25 <shachaf> I suppose...
17:32:13 <edwardk2> @hpaste
17:32:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:32:14 <shachaf> Does "emacsen" honestly belong *anywhere*?
17:32:34 <ManateeLazyCat> Someone suggestion me how to write introduction to Language.English.Plural? I write it in cabal file.
17:32:40 <edwardk2> hpaste.org is dead =/ other site recommendation?
17:32:42 <Peaker> anyone knows if SDL has a repo somewhere?
17:33:00 <Saizan> edwardk2: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:33:16 <copumpkin> "internet" -> "intarwebz"
17:33:21 <Saizan> @tell mmorrow hpaste.org is broken
17:33:22 <lambdabot> Consider it noted.
17:33:33 <edwardk2> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3144#a3144
17:33:36 <ManateeLazyCat> edwardk2: paste2.org
17:33:53 <ManateeLazyCat> edwardk2: If you use Emacs, please use my elisp library paste2.el
17:33:54 <dmwit> ManateeLazyCat: "synopsis: Pluralize English words."
17:34:11 <ManateeLazyCat> dmwit: Okay, thanks!
17:34:22 <edwardk2> ManateeLazyCat: nah, i'm one of those evil vim users ;)
17:34:37 <ManateeLazyCat> edwardk2: http://www.emacswiki.org/emacs/download/paste2.el
17:34:53 <ManateeLazyCat> edwardk2: Never mind, paste2.org in firefox.
17:35:02 <ManateeLazyCat> edwardk2: I think you like firefox. :)
17:35:09 <edwardk> nah, i defected to chrome ;)
17:35:12 <edwardk> muahaha
17:35:17 <shachaf> edwardk: Wait, are all vim users evil?
17:35:23 <ManateeLazyCat> paste2.org support 250kb limit.
17:35:40 <ManateeLazyCat> shachaf: No, just some emacser said.
17:35:41 <edwardk> shachaf: from the perspective of emacs users, i believe that is the party line
17:35:53 <ManateeLazyCat> shachaf: Vim user not evil even then don't like Emacs.
17:36:10 <edwardk> Saizan: ideas on how to tweak it?
17:36:53 <Peaker> damn the SDL guys do silly things.  They define a bunch of flag bit indices starting from ONE and then -1 before shiting. Geez.
17:37:00 <Peaker> (The SDL bindings forget to subtract 1)
17:37:24 <Peaker> Bindings of macros are problematic, if the library changes, C code won't break, but the bindings will. What should be done to use macros properly?
17:37:28 <Phyx-> shiting?
17:37:34 <idnar> shifting, I hope
17:37:37 <Peaker> shifting, yeah
17:37:48 <Saizan> edwardk: mmh, maybe just add a StateT to keep a buffer?
17:38:02 <idnar> Peaker: bundle a C compiler!
17:38:09 <edwardk> probably something like that
17:38:28 <dmwit> Peaker: We have no way to use macros correctly. =(
17:39:49 <Saizan> my first thought was something like Cont (Index,(Supply  Iteratee a)), actually
17:40:28 <edwardk> hrmm
17:40:54 <Peaker> does enumFromTo have a default implementation?
17:41:01 <Peaker> @src Enum
17:41:02 <lambdabot> class  Enum a   where
17:41:02 <lambdabot>     succ                     :: a -> a
17:41:02 <lambdabot>     pred                     :: a -> a
17:41:02 <lambdabot>     toEnum                   :: Int -> a
17:41:02 <lambdabot>     fromEnum                 :: a -> Int
17:41:04 <lambdabot> [3 @more lines]
17:41:09 <Peaker> @more
17:41:10 <lambdabot>     enumFrom                 :: a -> [a]
17:41:10 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
17:41:10 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
17:41:18 <Peaker> doesn't seem so :-(
17:41:21 <edwardk> iteratee/parsec3 is like my 15th variation on the problem, so i'm still suffering from the whole metal scaffold shearing it took to arrive at this sub problem ;)
17:41:21 <edwardk> er mental
17:41:26 <Saizan> but that's only if you want the enumerator to deal with buffering i guess
17:41:37 <Peaker> I guess there can only be a default if you have Ord
17:41:55 <Saizan> in that case, I = Index, and Chunk should carry one too
17:42:41 <edwardk> i suppose one way to do it is to supply a release method where release specifies that it is safe to backtrack
17:42:54 <edwardk> er no longer safe to backtrack
17:43:22 <ManateeLazyCat> ERROR: ./Plural.tar.gz: 401 Authorization Required ?
17:43:41 <Saizan> adding that to parsec you mean?
17:44:14 <edwardk> so lets think about the scenario i'm using it in, it might inform the buffering decision. i'm currently using this in a monoidal lexer. i have a monoid that takes small bytestrings and checks to see if it could restart the parser at an error production in the bytestring. currently that is any newline not preceded by a backslash.
17:44:45 <edwardk> if it finds one in the bytestring it is given it cuts the bytestring there, and starts parsing with the parsec parser until it runs out of bytestring
17:45:40 <edwardk> and feed it more bytestring when it is joined on the right with another parser which has a trailing unparsed left half. (or in the case of no error production present in the chunk, feeds it the whole block)
17:45:50 <ManateeLazyCat> When i upload Plural.tar.gz, i got ERROR: ./Plural.tar.gz: 401 Authorization Required ? Any idea? I miss something?
17:46:15 <ManateeLazyCat> Need register username first?
17:46:21 <Saizan> ManateeLazyCat: yes
17:46:25 <edwardk> that way i can chunk the input up, and each chunk only gets traversed at most twice, once to find the error production, and once to glue it together into the lazy bytestring that i feed into the parser
17:46:28 <ManateeLazyCat> Oh, i see.
17:47:04 <edwardk> since its a programming language a newline every 30-80 characters should happen, so 1k bytestrings will be mostly parsed with only a little left over
17:48:07 <edwardk> leaving about 3% to cleanup. and then the parser takes the token stream and parses that monoidally right across the boundaries involved here
17:48:21 <edwardk> and does layout, paren matching etc.
17:48:39 <edwardk> so i suppose i could hold onto the entire history of bytestrings
17:49:21 <edwardk> since i'll likely only have 2 chunks being fed into any real world chunk, one to start the parse and one to handle the end cleanup.
17:50:24 <edwardk> and i'm not too concerned with over-retention, because i'm keeping all of these little bytestrings around anyways because i'm planning to try very carefully to divvy up tokens right out of the original bytestring so i can retain their original backing storage
17:51:15 <edwardk> the parser only deals with how to recognize string literals, char literals, identifiers, symbols, whitespace, line directives, etc.
17:51:22 <uzytkownik_> @pl \a -> (a:) <$> unfoldM Core.next
17:51:22 <lambdabot> (<$> unfoldM Core.next) . (:)
17:51:28 <edwardk> and hands them off
17:51:36 <uzytkownik_> @pl \a -> fmap (a:) unfoldM Core.next
17:51:36 <lambdabot> flip (flip fmap unfoldM . (:)) Core.next
17:52:01 <Saizan> ah, then at worst you're wasting the space of a pointer a length and an offset
17:52:06 <Saizan> it shouldn't matter
17:52:07 <edwardk> yeah
17:52:25 * ManateeLazyCat Wait magnus@therning.org give me new account.
17:52:36 <edwardk> since in most scenarios i'll likely be retaining the whole input in a fingertree anyways
17:52:44 <edwardk> except when i'm actually compiling
17:52:52 <codebliss> Do you guys Shonfinkelisize?
17:53:10 <edwardk> shoenfinkeling is important
17:53:20 <codebliss> http://en.wikipedia.org/wiki/Currying has "The name "currying", coined by Christopher Strachey in 1967, is a reference to logician Haskell Curry. An alternative name, Schnfinkelisation, has been proposed.[2]"
17:53:27 <codebliss> LMFAO
17:53:28 <Peaker> @tell Lemmih I've got an SDL bugfix for you. Events.hsc has a partial listing of mouse buttons and mousePressed is wrong.
17:53:28 <edwardk> @let shoenfinkel f a b = f (a,b)
17:53:29 <lambdabot> Consider it noted.
17:53:31 <lambdabot>  Defined.
17:53:34 <Saizan> ManateeLazyCat: isn't ross the one that gives hackage accounts?
17:53:44 <Twey> Haha.
17:53:53 <codebliss> edwardk: lmao
17:54:01 <dmwit> ?let schoenfinkel = shoenfinkel -- bad spellars
17:54:02 <lambdabot>  Defined.
17:54:18 <Twey> @let schnfinkel = shoenfinkel
17:54:20 <lambdabot>  Defined.
17:54:21 <edwardk> fair nuff
17:54:22 <codebliss> oh shit
17:54:24 <Twey> For Real Men.
17:54:30 <codebliss> @t ( )
17:54:31 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:54:36 <codebliss> Space is an operator, tell me the type!
17:54:46 <Twey> Heh
17:54:46 <dmwit> :t ( )
17:54:48 <lambdabot> ()
17:54:52 <dmwit> done!
17:54:55 <codebliss> lmao
17:54:57 <codebliss> But no!
17:54:58 <Twey> :-P
17:55:03 <Peaker> can someone demangle SDLzm0zi5zi5_GraphicsziUIziSDLziEvents_NoEvent_closure  for me?
17:55:04 <codebliss> ( ) :: (a -> b) -> a -> b!
17:55:05 <ManateeLazyCat> Saizan: http://www.haskell.org/haskellwiki/HaskellWiki:New_accounts
17:55:07 <codebliss> it's id!
17:55:10 <ManateeLazyCat> Saizan: Is that?
17:55:18 <dmwit> preflex: zdec SDLzm0zi5zi5_GraphicsziUIziSDLziEvents_NoEvent_closure
17:55:19 <preflex>  SDL-0.5.5_Graphics.UI.SDL.Events_NoEvent_closure
17:55:23 <ManateeLazyCat> Saizan: Or other account?
17:55:30 <Peaker> dmwit: thanks
17:55:38 <Saizan> ManateeLazyCat: you were trying to upload a package to hackage.haskell.org ?
17:55:52 <ManateeLazyCat> Saizan: I use cabal update command
17:55:57 <Peaker> what does a segfault in that mean probably?
17:55:58 <ManateeLazyCat> upload
17:56:03 <ManateeLazyCat> cabal upload
17:56:09 <dmwit> Peaker: You fucked up a pointer.
17:56:11 <Saizan> ManateeLazyCat: you need this one then http://hackage.haskell.org/packages/accounts.html
17:56:21 <dmwit> (...like every segfault. ;-)
17:56:31 <ManateeLazyCat> Saizan: Thanks!
17:56:45 <codebliss> How many times have you shonfinkelised today?  Take a moment and reflect your cunning programming skills.
17:56:47 <tessier__> What was the name of that hardware/fpga implementation of a graph reduction machine?
17:56:48 <Peaker> dmwit: well, I made a minor change in the SDL bindings, that doesn't involve any pointers
17:57:01 <Saizan> tessier__: reduceron?
17:57:15 <abuiles> Hi, could someone please tell me,  which is the name of this style of using question marks in type signatures, like here, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3145#a3145       Is the first time when I see such thing, but I can find any inforamtion about it, and when I tried to compile it doesm
17:57:20 <tessier__> Saizan: That's it! Thanks
17:57:24 <abuiles> compile
17:57:34 <edwardk> i actually unschoenfinkelized a couple of thinks today, but alas, i haven't consciously schoenfinkeled ;)
17:57:50 <ManateeLazyCat> Saizan: ross@soi.city.ac.uk
17:57:51 <ManateeLazyCat> ?
17:57:58 <Saizan> ManateeLazyCat: yeah
17:58:05 <codebliss> edwardk: hahahaah XD
17:58:08 <ManateeLazyCat> Saizan: Oh, thanks, i send mail.
17:58:15 <Saizan> abuiles: those look like Implicit Parameters
17:58:16 <dmwit> abuiles: Check the list of extensions on the GHC manual, look for one called ImplicitParameters or something like that.
17:58:40 <codebliss> Forgive me father for I have sinned.  I have the python interpreter open atm.
17:59:06 <Peaker> what are Blah_closure disassemblies supposed to yield?  I get a "cwtl" instruction, whatever that is
17:59:33 <melangeau> hey all, newbie q - could someone explain why the (monad?) resulting from 'return (x /= y)' is assigned to True in the second example here: http://www.haskell.org/tutorial/monads.html#sect9.2 ?
17:59:42 <SamB> Peaker: is it possible that that's actually data, not instructions?
17:59:51 <Peaker> SamB: maybe, but $rip points there
17:59:57 <SamB> Peaker: ah.
17:59:58 <Peaker> SamB: it seems to be bad instructions
18:00:08 <edwardk> Saizan: now the question is should the history be stored as a FingerTree (SomeNewType ByteString) with a measure equal to the length for efficient backtracking? ;)
18:00:14 <SamB> are you debugging a newish port of GHC?
18:00:45 <Peaker> SamB: 6.10.3
18:00:50 <codebliss> a' <- a    =    a >>= \a' ->
18:01:10 <Saizan> edwardk: instead of .Lazy.ByteString ? obviously :)
18:01:16 <Peaker> anyone remembers how to dump some memory bytes in gdb?
18:01:19 <SamB> Peaker: anyway ... GHC usually doesn't output the pseudo-instruction that tells objdump to start/stop treating the bytes as data
18:01:22 <SamB> Peaker: x
18:01:32 <Peaker> SamB: not objdump, gdb disass
18:01:34 <edwardk> Saizan: well the lazy bytestring has the disadvantage that i have to seek to the end of it to get to my input over and over
18:01:35 <Saizan> melangeau: it'll be True when x and y are picked to be different
18:01:45 <edwardk> and i'll be snoc'ing new chunks not consing them
18:01:51 <SamB> Peaker: I dunno if GDB even *uses* such information
18:02:07 <Peaker> SamB: well, why would anyone jump to that data?
18:02:20 <codebliss> melangeau: It's pattern matching in do notation
18:02:24 <SamB> Peaker: I was hoping you were debugging a WIP port
18:02:26 <Peaker> SamB: its a JMP, not a call, based on the lack of return address on the stack
18:02:26 <SamB> :-(
18:02:29 <codebliss> melangeau: If it fails, then it calls fail
18:02:30 <Peaker> WIP?
18:02:37 <codebliss> melangeau: It's required in monad definitions
18:02:37 <SamB> Work-In-Progress
18:02:45 <codebliss> melangeau: But has a default
18:02:51 <Saizan> edwardk: by what you said ealier i thought you'd only have one or two chunks of history, though
18:02:57 <SamB> i.e., was hoping it came from efforts on your part to port GHC to a new arch/OS combination
18:03:04 <edwardk> yeah for the most part, but it is potentially unbounded
18:03:12 <codebliss> melangeau: It's like lambda pattern matching.  As that translates to ... >>= \True -> It's like primative pattern matching
18:03:12 <Peaker> SamB: Use of SDL. Maybe its an SDL bug though
18:03:18 <SamB> Peaker: is there not a .4 yet?
18:03:27 <melangeau> ah
18:03:33 <SamB> yeah, anything that causes UB could cause that kind of thing to happen, you know ;-)
18:03:35 <codebliss> melangeau: This is why that paragraph of code and below are equivalent  =P
18:03:39 <abuiles> Saizan: Thanks
18:03:42 <melangeau> :-D
18:03:44 <edwardk> [(Int,ByteString)] -- given a starting position and bytestring, sorted backwards seems to do the right thing
18:03:51 <Peaker> SamB: there is
18:03:52 <codebliss> melangeau: See the case of?  It translates to that, calling fail if no match
18:03:54 <abuiles> dmwit: Thanks
18:03:55 <edwardk> so i can just cons chunks as i'm given them
18:04:10 <melangeau> ok
18:04:22 <melangeau> that is a bit more intuitive
18:04:23 <codebliss> melangeau: If you really want to, you can look on the official site for the formal translation of do-notation.
18:04:32 <codebliss> melangeau: Another example is the Maybe type.  Have you used it?
18:04:44 <melangeau> maybe? lol
18:05:01 <codebliss> melangeau: In the definition of Monad Maybe, fail = Nothing.  So if you did Just a <- ..., and it fails, then it returns Nothing there
18:05:09 <melangeau> my understanding is that maybe is...
18:05:14 <melangeau> yup
18:05:22 <codebliss> Pretty useful concept
18:05:37 <codebliss> This is the only time when pattern matching compiles and (should) possibly "fail"
18:05:41 <Saizan> you don't have to use Just there
18:05:43 <codebliss> It's intentional
18:05:50 <codebliss> Ya, fail code, didn't think long enough
18:05:55 <codebliss> I meant to do a
18:05:56 <Saizan> unless the ... :: Maybe (Maybe something)
18:06:23 <melangeau> like Option?
18:06:34 <codebliss> my be, apply the second member of the monad endofunctor to that expression  =P
18:06:42 <codebliss> melangeau: Hm?
18:06:53 <melangeau> http://ocaml-lib.sourceforge.net/doc/Option.html
18:06:54 <Saizan> ?src Maybe
18:06:55 <lambdabot> data Maybe a = Nothing | Just a
18:06:58 <codebliss> I can't type today.  I meant my b lol
18:07:05 <codebliss> @k Nothing
18:07:06 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
18:07:07 <codebliss> @k Just
18:07:07 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
18:07:10 <codebliss> No kind?
18:07:13 <codebliss> :k Nothing
18:07:14 <codebliss> :k Just
18:07:14 <lambdabot>     Not in scope: type constructor or class `Nothing'
18:07:16 <lambdabot> Not in scope: type constructor or class `Just'
18:07:20 <codebliss> What?..
18:07:25 <Saizan> ?type Nothing
18:07:27 <pikhq> @kind Just
18:07:27 <aavogt> :k Maybe
18:07:27 <lambdabot> forall a. Maybe a
18:07:28 <lambdabot> Not in scope: type constructor or class `Just'
18:07:29 <lambdabot> * -> *
18:07:31 <Saizan> ?type Just
18:07:31 <codebliss> I wanted the kind  XD
18:07:33 <lambdabot> forall a. a -> Maybe a
18:07:43 <codebliss> Nevermind it
18:07:43 <Saizan> data-constructors don't have kinds.
18:07:48 <codebliss> Really?
18:07:56 <Saizan> kinds are only for types
18:08:00 <codebliss> Touche.  Checked
18:08:02 <pikhq> Just the type.
18:08:13 <codebliss> Makes sense
18:08:44 <codebliss> melangeau: Ah.  Never used ocaml
18:09:54 <melangeau> codebliss: my small amount of experience with it from a prog. lang and compliers course makes it a type of launching-pad
18:10:34 <Saizan> http://www.haskell.org/all_about_monads/html/index.html <- this will probably give more details on the specific monads than the gentle introduction
18:10:49 <melangeau> Saizan: ty
18:10:51 <SamB> "gentle" introduction
18:11:26 <codebliss> Honestly, when you get into more of the theory, it gets confusing how in CT a monad is return and join, and in haskell its return and bind
18:11:36 <codebliss> That's what tripped me at first
18:12:03 <Saizan> have you met Kleisli triples?
18:12:31 <codebliss> I have done very little CT, I get tripped past the basics.  I understand some stuff, but need a book or a good source
18:12:52 <codebliss> I always understand random things.  I got the definitions for phi and mu (i think it is), the two parts of a monad
18:12:59 <pikhq> codebliss: Not as confusing as you think; the definitions are functionally equivalent.
18:12:59 <codebliss> But I don't get functors, which is way below that lol
18:13:02 <codebliss> Just doesn't click
18:13:04 <pikhq> @src join
18:13:04 <lambdabot> join x =  x >>= id
18:13:07 <melangeau> Saizan: any good math texts to recommend?
18:13:10 <codebliss> I know it NOW
18:13:26 <codebliss> I get the ideas, just didnt recognize the inconsistancies
18:13:42 <codebliss> Read CT and am like what, F(F(a) -> F(a)?
18:14:06 <SamB> @elite stuff
18:14:06 <lambdabot> S7UfF
18:14:10 <SamB> @elite stuff
18:14:10 <lambdabot> $7UphF
18:14:16 <codebliss> I meant T, not F
18:15:04 <SamB> mmorrow: why is hpaste down?
18:15:13 <codebliss> melangeau: I haven't taken a programming class in my life, so I kind of have a weird background
18:15:15 <codebliss> melangeau: =/
18:15:46 <pikhq> codebliss: I took my first formal class last year. Note: most good programmers learned how to program *before* getting formal education.
18:15:48 <pikhq> ;)
18:15:56 <Saizan> melangeau: on CT? i got most of the little i know from sigfpe's and edwardk's blogs and some papers, i've also got Basic Category for Computer Scientists which is a nice read but there are probably better ones :)
18:16:00 <codebliss> pikhq: I'm too humble.  I'll think I suck forever
18:16:16 <melangeau> Saizan: ok
18:16:17 <codebliss> pikhq: I don't make anything useful.  Nothing more than little desktop helpers on my linux box to make life easy.
18:16:28 <pikhq> Lies.
18:16:44 <codebliss> pikhq: I LOVE theory, and suck at anything to do with business and getting work done.  I'm frankly worried lol
18:16:44 <edwardk> melangeau: what are you looking for?
18:16:52 <SamB> most programming classes aren't that great
18:17:06 <codebliss> The biggest real app I made was a C# app to search a folder for .lua files and put the function definitions on a TreeView.  Ya.
18:17:07 <melangeau> codebliss: the class was useful in that it made me aware of the non procedural realm
18:17:22 <pikhq> The main thing that programming classes give you is that it forces you to write something.
18:17:26 <codebliss> melangeau: Ya, I'm worried except maybe some senior exploration I'll get ANY functional
18:17:31 <melangeau> edwardk: not sure, category theory perhaps?  something useful for learning haskell
18:17:52 <pikhq> Beyond that, most courses don't suffice to actually teach you anything.
18:18:17 <edwardk> melangeau: tricky. i have a bunch of blog posts on category theoretic concepts applied in haskell, but they kind of assume deep knowledge of one or the other most of the time I'll admit ;)
18:18:23 <codebliss> pikhq: Ya.  I just am also worried because my college is notorious for kids who just are going to get a degree and dont give a fuck
18:18:27 <SamB> if you're lucky, the prof will let you mess around with something other than what the rest of the class is doing ;-)
18:18:35 <edwardk> melangeau: there is of course the source code to category-extras =)
18:18:37 <pikhq> codebliss, see, that's a bit of a problem.
18:18:43 <codebliss> I have really high standards, and just want to get a challange, and am worried I'm going to the wrong placed
18:19:12 <melangeau> pikhq: formal education is useful in that it exposes you to new ideas, hopefully
18:19:24 <codebliss> This reputation is for the REST of the college though
18:19:31 <melangeau> pikhq: I don't think it's meant to turn out 'developers' - that's software engineering
18:19:33 <codebliss> The CS department isn't what it's known for
18:19:38 <edwardk> melangeau: book wise, categories for the working mathematician, and basic category theory for computer scientists are both decent, but the former is scarily dense and hard to apply to comp sci without some seriously fuzzy lenses
18:19:39 <codebliss> www.uakron.edu
18:19:49 <pikhq> melangeau: That's the theory. I am discussing how most CS education that I've seen goes, not what the purpose is. ;)
18:20:04 <melangeau> edwardk: cool, thanks - I'll have to look those up
18:20:13 <melangeau> edwardk: have a link to those blog posts?
18:20:22 <edwardk> melangeau: comonad.com
18:20:31 <pikhq> And that it tends to focus on 'turning out "developers"', I find, is a sad thing.
18:20:43 <copumpkin> eww, developers
18:20:47 <edwardk> I pretty much spend the whole blog rambling on about category theory
18:20:53 <SamB> I'm doing EE, and I'm usually either bored or stalled writing a paper
18:20:59 <SamB> or both!
18:21:03 <melangeau> pikhq: heh.  well, we have a choice of math/cs or engineering/cs
18:21:12 <codebliss> I'm not sure what I should do.  Go masters, do white papers for a while?  Do a startup (go paul graham!)?  Get another .net C# job?
18:21:20 <SamB> that's when I'm not distracted by programming instead ;-)
18:21:48 <edwardk> dan piponi has one which is really good as well, and covers a wider array of material than i do. If you haven't seen it: http://blog.sigfpe.com/
18:22:04 <edwardk> melangeau: i'm rather fond of the math/cs path personally
18:22:20 <copumpkin> :o
18:22:28 <copumpkin> (I'm fond of the odd smilies)
18:22:30 <codebliss> edwardk: He has great illustrations from what I see
18:22:31 <pikhq> codebliss: Learn something new and write something using it.
18:22:41 <melangeau> SamB: agh... it certainly takes willpower to work with all of those architecture diagrams
18:22:44 <pikhq> Say, learn how to write a basic compiler and do that.
18:22:45 <codebliss> pikhq: Haskell is new to me...about 5mo in I guess
18:22:49 <jmcarthur> melangeau: math/cs is an endless journey! i find that mainstream programming tends to dead end whenever i think i found anything interesting :\
18:22:51 <codebliss> pikhq: Low-level?
18:23:07 <SamB> melangeau: the what now?
18:23:47 <codebliss> I just emailed my honors peer about what he thinks about the college and the CS department.  1 year of college isn't THAT much a loss if I dislike it
18:24:21 <codebliss> pikhq: I was actually thinking about making a command-line IM.  always wanted to do cat *.koan | im someone
18:24:26 <codebliss> libpurple works
18:26:09 <Saizan> for haskell i think some basics on type systems are probably more useful than a lot of CT, if you want to really understand some of the GHC extensions at least
18:26:31 <Saizan> though those probably have also a CT formalization?:)
18:26:57 <monochrom> knowledge of type systems is more direct.
18:26:59 <melangeau> SamB: our exposure to CE consists of simple logic (decoders, multiplexers, circuit analysis/design, ...) thru datapaths, pipelines, caching, etc
18:27:04 <melangeau> lots of fun
18:27:21 <codebliss> CE?
18:27:22 <melangeau> SamB: not my thing
18:27:28 <melangeau> computer engineering
18:27:31 <monochrom> computer education
18:27:31 <codebliss> oh
18:27:36 <codebliss> That's why I went for CS
18:28:18 <monochrom> computer strike
18:28:37 <codebliss> lol
18:29:04 <melangeau> no, that's what happens when you try to get MySQLdb working with Python 2.6 on windows
18:29:47 <codebliss> I'm just...ugh my college is like java/database based
18:29:52 <codebliss> The anti-me
18:31:30 <monochrom> Most of them are java/database based.
18:32:12 <pstickne_> Teaching Ants.
18:33:04 <Peaker> is there an mconcat that parallelizes?
18:33:09 <sjanssen> I'm a bit tired of "oh noes, Java in the curriculum" snobbery
18:33:30 <sjanssen> Java is one of the most notable programming languages in many respects
18:34:05 <sjanssen> popularity, industry adoption, etc.
18:34:34 <codebliss> I'm a terrible programmer.  I don't care about most of those aspects lol.  If it's tough to pass a func to a func, I got a headache
18:34:37 <Phyx-> and crappy
18:35:33 <Phyx-> java is layer upon layer of hacks and bad design
18:35:49 <sjanssen> I don't think so
18:35:56 <melangeau> Phyx-: hotspot has found many friends
18:36:14 <sjanssen> I think Java has a pretty good idea of what it wants to be, and does a pretty good job at being it
18:36:18 <dobblego> it's well justified lament, not snobbery
18:36:26 <codebliss> sjanssen: I don't like what it is.
18:36:38 <codebliss> sjanssen: Blub programming is not my thing.  See:  paulgraham
18:36:41 <Baughn> Is there a generalized takeWhile  or ! in a typeclass somewhere?
18:36:53 <sjanssen> dobblego: I think the argument only has merit if Java is the only language taught
18:37:09 <dobblego> sjanssen, I think Java and "taught" in the same sentence is dishonest
18:37:12 <sjanssen> codebliss: Paul Graham is full of himself.  For him, Lisp is blub
18:37:19 <Saizan> sjanssen: sadly that happens
18:37:22 <Phyx-> i don't agree, java's biggest problem is in what it wants to be. they generics "hack" is a prime example of something they shoulda thought of before hand. not to mention the vm is extremely buggy at times
18:37:34 <copumpkin> Peaker: maybe in edwardk
18:37:36 <edwardk> codebliss: it exists and a good chunk of code you will have to deal with will be written in it, so if nothing else it is important to know how to code Java and to code it well, so that you can be trusted enough to be given your head to use strange functional languages
18:37:37 <copumpkin> 's monoids lib
18:37:50 <Phyx-> we found ourself using beta VMs just cauze that one had some working implementation of things we needed
18:37:56 <sjanssen> Saizan: but it's pretty rare in actual universities, right?  It is more endemic in trade schools and the like
18:38:04 <codebliss> edwardk: sjanssen: I hope f# get's popular in my time
18:38:21 <edwardk> peaker: yeah i have one in category extras, look at Data.Generator, it automatically chunks lazy bytestrings and reduces them monoidally
18:38:37 <edwardk> codebliss: i hope not, f# would be a terrible language to introduce the world to the power of functional programming with.
18:38:41 <edwardk> er
18:38:45 <Peaker> edwardk: parallelizes sub-groups and mconcats them separately?
18:38:46 <edwardk> not category extras  'monoids' =)
18:38:46 <codebliss> edwardk: I know C# quite well though, I probably will not put myself into a java ob
18:38:50 <edwardk> peaker: yeah
18:38:55 <copumpkin> codebliss: beats python claiming it's "functional", at least
18:39:00 <Peaker> edwardk: cool.. Why is f# terrible?
18:39:11 <codebliss> edwardk: f# has inc = (+1).  Seems to be quite functional
18:39:17 <codebliss> edwardk: Bias much?
18:39:25 <Phyx-> codebliss: i'd take c# over java anyday
18:39:26 <codebliss> edwardk: I don't see python with currying
18:39:33 <codebliss> Phyx-: Me too
18:39:49 <Saizan> sjanssen: i guess mine is odd then, even if i've found a non-obligatory course on prolog
18:39:59 <melangeau> sjanssen: Java? the intro cs courses use it.
18:39:59 <melangeau> sjanssen: although I heard they were considering using Python instead
18:40:00 <edwardk> peaker: because it has no module system and no mechanism for any sort of decent parametric polymorphism. i can't write any of my libraries in it because i have no mechanism by which the ideas can be expressed in the language.
18:40:14 <edwardk> codebliss: currying is not all there is to functional programming. yes, i bias much
18:40:38 <codebliss> edwardk: Why hate f#?  One of my collegues is obsessed, j/c
18:40:52 <Baughn> @hoogle takeWhile
18:40:53 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
18:40:53 <lambdabot> Data.ByteString takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
18:40:53 <lambdabot> Data.List takeWhile :: (a -> Bool) -> [a] -> [a]
18:40:55 <Peaker> edwardk: ah
18:40:57 <dobblego> codebliss, calling F# functional is quite a stretch
18:41:03 <melangeau> sjanssen: APCS uses it too, actually
18:41:06 <codebliss> PS:  I'm a grammar nazi, and I just totally failed at spelling
18:41:18 <codebliss> dobblego: Considering the F stands for functional, bad design on their part?  =P
18:41:21 <edwardk> codebliss: no module system, fine we can fall back on OOP for some of that, no rank-2 or better types, ok sure we can round trip through object, woopps there goes all that vaunted safety and speed...
18:41:34 <edwardk> f# is c# with some pattern matching bolted on sideways
18:41:36 <codebliss> edwardk: Rumored typeclasses
18:41:48 <dobblego> codebliss, Java claims to be a useful programming language too -- marketing does not always depict reality
18:41:54 <edwardk> codebliss: tits on a pig at this point. ;)
18:42:00 <codebliss> edwardk: LOL
18:42:14 <Phyx-> LOL
18:42:29 <sjanssen> Saizan: maybe I'm wrong about how widespread it is, I don't actually have any data
18:42:37 <codebliss> Well, has algebraic datatypes, currying, lambdas, pattern matching.  This is about most of what you can get and still load any .net func
18:42:49 <edwardk> codebliss: btw- don't get me wrong. c# is my favorite imperative programming language these days.
18:43:12 <codebliss> edwardk: I'd do python over c#, but c# is the best "industry real" language I would prefer
18:43:24 <edwardk> codebliss: its just f# has all of the worst features of that mixed in with a sprinkling of all of the weaker parts of ML. had they a mechanism by which they could express ML functors I would love f#.
18:43:57 <codebliss> edwardk: I'm too new to completely appreciate the types, although I see where you're coming from
18:44:04 <pikhq> edwardk: And a poor syntax.
18:44:17 <edwardk> pikhq: heh definitely one of the 'weaker parts' of ML ;)
18:44:19 <Phyx-> yes, i hate the F# syntax
18:44:28 <edwardk> unfortunately strictness generally forces a pretty terrible syntax on you
18:44:45 <melangeau> hmm, looks like my connection dropped
18:44:46 <codebliss> Phyx-: Although I'd love f :: Int -> Int = (+1) like f# allows
18:44:59 <pikhq> edwardk: Yeah, but there's pitiful, and then there's terrible.
18:45:00 <Phyx-> maybe someone can explain this too me, why do you need to explicitly annotate recursive functions with "rec" in ML?
18:45:01 <codebliss> Kinda ugly to do f = (...) :: Int -> Int
18:45:10 <codebliss> Phyx-: He has a reason, I'll ask
18:45:43 <pikhq> F# is terrible.
18:45:44 <Phyx-> i always found that annoying, why can't the compiler figure out the function is recursive
18:46:21 <edwardk> Phyx-: tradition for one thing, ML compilers traditionally did less of the deep thinking haskell ones do, but in part is has to do with the fact that you generally want non-recursive let bindings because of strict evaluation on values. let x = x in haskell is fine. but when you go to do it in ML...
18:46:29 <pikhq> Phyx-: ... You have to do that?
18:46:31 <codebliss> let add a b = a + b let add a b = add a 1  thats valid  and add is "rebound" - shadowed
18:46:31 <pikhq> That's terrible.
18:46:44 <codebliss> and the add in the second def refers to the original one  not the current one
18:46:51 <codebliss> afaik, you cant do that in haskell
18:46:56 <edwardk> so ml in general tries to keep you from shooting yourself in the foot unless you explicitly ask to do so
18:47:35 <codebliss> http://stackoverflow.com/questions/900585/why-are-functions-in-ocaml-f-not-recursive-by-default
18:48:03 <edwardk> codebliss: sure, but that is alpha equivalent to a program that doesn't use that feature. haskell went the other way on the let/let rec debate specifically because it can use recursive bindings everywhere and not care ;)
18:48:31 <Phyx-> edwardk: but aren't there strict functional languages without this restriction? isn't lisp one?
18:49:16 <edwardk> Phyx-: sure
18:49:25 <pikhq> Phyx-: Lisp is not a functional language. It is a multiparadigm language. :P
18:49:32 <codebliss> He has to go.
18:49:33 <codebliss> =(
18:49:45 <Phyx-> are you refering to yourself in the third person?
18:49:52 <Phyx-> pikhq: lol
18:49:54 <codebliss> No, those posts were from my colleague lol
18:50:10 <Phyx-> oh, lol, ok
18:50:11 <codebliss> I know little F#, although it's what got me into fprogramming, so I will never hate
18:50:38 <codebliss> let add a b = a + b; let inc = add 1;  This got me to understand currying and go fuck ya, fuck imperative
18:50:40 <Phyx-> i tried to do some F#, hated the syntax, went back to haskell, and i'm now using haskell from c#
18:50:42 <codebliss> I said that out loud, lol
18:50:43 <Phyx-> lol
18:50:43 <Phyx-> or trying to anyway
18:51:03 <edwardk> Phyx-: i tried to port a solid chunk of code into f#, failed due to type system limitations and returned to haskell ;)
18:51:33 <codebliss> Well I wouldn't ever go back to f# unless I REALLY needed .net to do something useful (I never do anything useful, so this pattern will never occur  =P)
18:51:51 <codebliss> Points in haskell, bitches!  =P
18:52:00 <Phyx-> edwardk: well, at the time, i knew nothing about ML, so.. i just jumped right in, almost cauzed myself to get an anuerism by trying to figure out how to explicitly add types... lol
18:52:00 <codebliss> ; is an operator in c++ and you know it!
18:52:25 <codebliss> Phyx-: My first 6 expressions in ghci didnt parse.  Hands in ftw!
18:52:31 <Phyx-> lol
18:52:42 <codebliss> It's like a saw trap, except ignoring the video tape!
18:52:43 <codebliss> LMFAO
18:52:47 <codebliss> That was a good one, lol
18:52:53 <Phyx-> the one thing, that nearly made me jump ship with haskell, was making a gui with wxHaskell
18:52:58 <codebliss> SO where's this key, in my bladder?  Hm...
18:53:15 <codebliss> I haven't even done anything more useful than system command line stuff
18:53:19 <codebliss> I dunno, I just never do
18:53:25 <codebliss> I'm always theorywhoring
18:53:42 <edwardk> I probably spent three weeks reading Haskell code and mining through all the old Wadler papers on monads in haskell before i tried writing anything in it.
18:53:59 <codebliss> Lately I HAVE been doing some useful stuff though, but not much.  Too annoyed with computers (fixing a windows atm)
18:54:28 <Phyx-> well, i got haskell in my bachelor.. it was basically forced fed into our throats at a high speed
18:54:31 <codebliss> edwardk: I type before I think, then get annoyed, and don't get anything done (with stuff I haven't learned yet, lol)
18:54:41 <codebliss> Phyx-: I'd kill for FP in my curriculum
18:54:48 <codebliss> Even if I learn like 3 things
18:55:09 <Phyx-> we get java and haskell in the first 2 periods of your first year
18:55:09 <edwardk> shapr gives me crap about the fact that i'll spew haskell code for 2-3 days nonstop before i get around to trying to actually get it to compile
18:55:13 <codebliss> Example:  State monad.  Always thought type State a b = (a,b) essentially
18:55:23 <codebliss> Not a wrapper on a function
18:55:24 <codebliss> FAIL
18:55:36 <Phyx-> edwardk: and after those 3 days, does it actually compile? :P
18:55:40 <codebliss> I still think the state monad is designed for advanced users, very confusing words
18:55:47 <edwardk> Phyx-: usually modulo the first 6-7 typos
18:55:53 <Phyx-> lol
18:56:01 <edwardk> Phyx-: that i think is the part that annoys him ;)
18:56:18 <Phyx-> hehehe
18:56:42 <codebliss> Who compiles?  That just goes against our motto!
18:56:47 <Phyx-> haskell + couple of extensions + ghc == nice type errors sometimes
18:56:57 <Phyx-> i just love getting "maybe you should add an instance of"
18:57:00 <Phyx-> and a page long instance
18:57:06 <codebliss> lmao
18:57:50 <codebliss> Somebody code a wii emulator in haskell so I can play SSBB on my pc, GO!  =P
18:58:24 <Rotaerk> or you could buy a wii solely for SSBB
18:58:27 <Rotaerk> it's awesome enough
18:58:34 <codebliss> I did
18:58:36 <Phyx-> only with 4 friends...
18:58:40 <codebliss> 300 bucks, and I'm buying no other games
18:58:43 <Rotaerk> heh me too
18:58:51 <codebliss> Just hit 1000 matches and I've played 100 with my bro, rest alone with cpu
18:58:54 <codebliss> Still not near bored
18:59:00 <Rotaerk> yea
18:59:02 <codebliss> Played with friends...maybe 200 games.  THey're busy
18:59:04 <Phyx-> i have a wii just for wii tennis :P
18:59:10 <Rotaerk> I just wish I had friends who played it
18:59:14 <Rotaerk> network play kind of sucks
18:59:16 <codebliss> Meteor smashing accounts for like 80% of my inspiration
18:59:24 <pikhq> Phyx-: I get C++ my first year. And my second year. After that, I am free to use anything the professor can manage to get running.
18:59:27 <codebliss> I do, they're old buds.  Just never free same day
18:59:35 <codebliss> Phyx-: Awesome
18:59:39 <codebliss> whgoops
18:59:44 <codebliss> pikhq: awesome, lol
18:59:54 <pikhq> codebliss: I may write something in Brainfuck.
18:59:58 <codebliss> pikhq: LOL
19:00:06 <Phyx-> pikhq: for the most part, our choices are java or haskell, but some professors also allow anything you can get compiling
19:00:08 <codebliss> pikhq: Use the haskell brainfuck interpreter, just for lawls
19:00:11 <codebliss> LOL USE LOLCODE
19:00:14 <hzap> lol
19:00:16 <Baughn> @ask conal Given that I'm not implementing a monad instance for Event, is there still any point in the applicative instance either?
19:00:16 <lambdabot> Consider it noted.
19:00:17 <codebliss> btw for comments, LMAO
19:00:21 <codebliss> I love lolcode!
19:00:23 <Phyx-> pikhq: just for the fun of it, handed in an assignment in brainfuck ones
19:00:29 <Phyx-> was awesome :D
19:00:31 <codebliss> LOL
19:00:33 <codebliss> HAND IN WHITESPACE
19:00:41 <codebliss> Or shakespheare
19:00:42 <codebliss> lmfao!
19:00:51 <codebliss> he's like wtf is this!
19:01:02 <Phyx-> pikhq: i did hand in an equivalent java file though
19:01:10 <codebliss> It's whitespace code, look carefully!  I printed with lemon juice ink
19:01:43 <Rotaerk> codebliss, any particular best characters?
19:02:10 <codebliss> Rotaerk: Hm?
19:02:13 <Phyx-> pikhq: but for the most part, i oppose the teaching of "java" and "haskell", and I applaud them for teaching the courses as "Imperative programming" and "Functional programming" with java and haskell just being the two languages used to try out the concepts
19:02:21 <Rotaerk> in SSBB
19:03:02 <codebliss> I love metaknight for his priority, I love mario for canceling his air moves and attacking fast, and roy for flying around, pit for arrows, wolf for sucking and having fun
19:03:25 <Rotaerk> roy?
19:03:26 <Phyx-> I'm a fox guy myself
19:03:32 <codebliss> not roy, I definately meant ROB
19:03:36 <Rotaerk> hehe
19:03:46 <codebliss> Fox is...meh.  Too fast and all his abilities are papercut
19:03:57 <Phyx-> i like him because he's fast
19:03:59 <codebliss> metaknight quick jumping, and just totally slicing them.  Funnn
19:04:04 <Phyx-> i can dodge and return attacks quickly
19:04:12 <Saizan> isn't that material for #haskell-blah ?
19:04:12 <codebliss> You know you can do a running attack with forward -> cstick down?
19:04:15 <Rotaerk> I'm best with captain falcon
19:04:17 <codebliss> Touche.
19:04:41 <Rotaerk> learning to use falco
19:04:48 <Rotaerk> (who's pretty weird)
19:04:50 <codebliss> to #haskell-blah !
19:04:57 <Rotaerk> oh
19:18:32 <DannoHung> Hello.  I'm going through RWH, and I was wondering if it was possible to do something like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3146#a3146
19:20:02 <mike-burns> As you've probably tried, that doesn't work. Not sure what you're trying to do there though. Can you explain a bit?
19:21:19 <DannoHung> Actually, now that I think about it doesn't really make sense, does it?
19:21:32 <mike-burns> Nah. :)
19:21:44 <DannoHung> D'oh!
19:22:18 <aavogt> so you can't add additional cases to the functions generated by that record notation?
19:23:09 <mike-burns> You can write a custom accessor function that uses the generated functions, though.
19:23:29 <DannoHung> Not that I am the authority to speak on it, but it's not very useful in this case, particularly because you wouldn't really want to get a value of type a out of leftTree or rightTree
19:23:46 <DannoHung> Which means I defined the Tree type wrong.
19:24:14 <mike-burns> (Speaking of being the authority to speak on it, it's totally possible that I'm wrong and someone will call me out on it.)
19:31:47 <Saizan> right, you want Tree a there
19:32:23 <Saizan> and you can't add cases to leftTree/rightTree like that
19:35:49 <codebliss> Night y'all geeks!  <3
19:37:16 <copumpkin> wow, is that serious?
19:37:36 <copumpkin> selling advertising space in quit messages seems questionable
19:37:52 <pikhq> copumpkin: ?
19:37:53 <rovar> that's a great idea
19:37:57 <DannoHung> I guess there's really no logical way of having something return either the one half of the tree or the value at the node.  Well, not any way of doing anything useful with it anyhow.
19:38:02 <pikhq> Ah.
19:38:20 <rovar> speaking of which. I could sure go for an ice cold, refreshing Miller Light (tm) right about now.
19:38:38 <copumpkin> DannoHung: you could write such a function, but I'm not sure what purpose it would serve
19:38:56 <aavogt> @src Either
19:38:56 <lambdabot> Source not found. :(
19:39:50 <c_wraith> @src Either (>>=)
19:39:51 <lambdabot> Left  l >>= _ = Left l
19:39:51 <lambdabot> Right r >>= k = k r
19:40:22 <c_wraith> @src Either (>>)
19:40:23 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:41:13 <Twey> DannoHung: I think you want a leftTree :: Tree a and rightTree :: Tree a
19:41:26 <c_wraith> @src Left
19:41:27 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:41:33 <Twey> That done, it does make sense to do something like this; you can use the Either datatype
19:42:10 <c_wraith> Now, for boringness...
19:42:19 <c_wraith> @src Either return
19:42:20 <lambdabot> return        = Right
19:42:34 <Twey> DannoHung: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3146#a3147
19:43:31 <c_wraith> @src Either fmap
19:43:31 <lambdabot> fmap _ (Left x) = Left x
19:43:31 <lambdabot> fmap f (Right y) = Right (f y)
19:43:54 <c_wraith> @src Either (<*>)
19:43:55 <lambdabot> Source not found. I feel much better now.
19:44:21 <c_wraith> Either isn't applicative?  Or is <*> defined in terms of something else by default?
19:44:52 <pikhq> @instances Applicative
19:44:55 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
19:45:05 <pikhq> c_wraith: @src is fed by hand, IIRC
19:45:24 <c_wraith> @src Maybe (<*>)
19:45:24 <lambdabot> (<*>) = ap
19:45:41 <Twey> I don't think Either is applicative, no
19:45:48 <c_wraith> hah.  that implmentation would work for Applicative
19:45:55 <c_wraith> or, for Either
19:45:58 <Twey> It has two possible values of different types
19:46:03 <pikhq> :t (Right 1 <*>)
19:46:04 <lambdabot> forall a b a1. (Num (a -> b), Applicative (Either a1)) => Either a1 a -> Either a1 b
19:46:13 <Twey> You could only make an Applicative value by ignoring one, but that would be kind of arbitrary
19:46:16 <Twey> Oh
19:46:28 <c_wraith> @src Either ap
19:46:28 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:46:31 <DannoHung> I can, quite literally, feel my mind being blown.
19:46:38 <c_wraith> @src Maybe ap
19:46:38 <lambdabot> Source not found. Are you on drugs?
19:46:45 <Twey> > Right (+ 1) <*> Right 3
19:46:47 <lambdabot>   No instance for (Control.Applicative.Applicative
19:46:47 <lambdabot>                     (Data....
19:46:51 <pikhq> c_wraith: ap is not instance-specific
19:46:53 <Twey> Oh, there we go
19:47:14 <pikhq> Twey: I'd call Either not being an applicative a bug.
19:47:19 <pikhq> (Either is a monad)
19:47:44 <c_wraith> > Right (+ 1) `ap` Right 3
19:47:45 <lambdabot>   Add a type signature
19:47:47 <Peaker> hmm.. what's a nice way to check for collision between a circle and a rect?
19:47:58 <c_wraith> > Right (+ 1) `ap` Right 3::Int
19:48:00 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:48:06 <Peaker> collide (Rect x y w h) (Circle x y radius) = ??
19:48:12 <Peaker> oops, cx cy I guess
19:48:14 <c_wraith> > (Right (+ 1) `ap` Right 3)::Int
19:48:16 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
19:48:25 <c_wraith> > (Right (+ 1) `ap` Right 3)::Maybe Int
19:48:27 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
19:48:28 <Twey> pikhq: Error e => Either e is a monad
19:48:32 <Gracenotes> even Either isn't a Monad
19:48:36 <Twey> And even then, not in the Prelude
19:48:37 <Gracenotes> that bastards :(
19:48:40 <c_wraith> > (Right (+ 1) `ap` Right 3)::Either String Int
19:48:42 <lambdabot>   Right 4
19:48:46 <c_wraith> haha.
19:48:47 <c_wraith> There
19:49:17 <c_wraith> > (Right (+ 1) `ap` Right 3)::Either Unit Int
19:49:19 <lambdabot>   No instance for (Control.Monad.Error.Class.Error GHC.Generics.Unit)
19:49:19 <lambdabot>    aris...
19:49:41 <c_wraith> So you need Either Error a for it to be a monad? >_>
19:50:01 <Twey> Yeah.
19:50:04 <c_wraith> > (Right (+ 1) <*> Right 3)::Either String Int
19:50:06 <Twey> It's kind of stupid.
19:50:06 <lambdabot>   No instance for (Control.Applicative.Applicative
19:50:06 <lambdabot>                     (Data....
19:50:17 <Twey> It's an MTL thing, AIUI
19:50:22 <nego> No time for masturbate, need learn Haskell!
19:50:31 <Gracenotes> that's the spirit
19:50:43 <Gracenotes> but then agian, why not do both at the same time
19:50:49 <DannoHung> could get messy
19:50:52 <Gracenotes> Peaker: ..hm.. your problem is harder than I had initially thought... although I'm sure it has an "obvious" solution :/
19:51:43 <Peaker> Gracenotes: I was a bit surprised too
19:51:51 <Peaker> Gracenotes: seems like you have to combine 2 methods, which is ugly
19:52:08 <Gracenotes> do you have to check the individual sides of the square?
19:52:13 <RenatoSilva> what is haskell most used for?
19:52:18 <Peaker> Gracenotes: I think so
19:52:37 <c_wraith> haskell is most used for mind-bending
19:52:49 <mike-burns> Haskell is most used for arguing about what Haskell is most used for.
19:52:55 <c_wraith> :t join (,)
19:52:57 <lambdabot> forall a. a -> (a, a)
19:53:04 <nego> Haskell use for not masterbate!
19:53:05 <c_wraith> Just think about that one, for instance. :)
19:53:09 <Gracenotes> Haskell is a general purpose programming language. for simulations, regex, ray tracing, GUIs, networking, web apps, it can do these
19:53:18 <jfoutz> Peaker: or $ map  (\(cx, cy) (Circle x y r) -> if ((cx - x) + (cy - y))^2 < r^2 then True else False) $ corners rect
19:53:26 <DannoHung> no one can be told what the haskell is, you must experience it for yourself
19:53:30 <jfoutz> (i think)
19:53:36 <jfoutz> something like that.
19:53:46 <nego> You be Haskell, not told Haskell!
19:53:52 <Gracenotes> jfoutz: does that detect when a circle intersects the side of a square without touching a corner?
19:54:10 <RenatoSilva> c_wraith: what is mind bending
19:54:17 <jfoutz> oh.
19:54:19 <jfoutz> no.
19:54:43 <c_wraith> I'm having issues with the (-> a) monad, really. :)
19:54:53 <Cale> Not (-> a)
19:54:58 <Peaker> jfoutz: that checks if the corners of the rect are inside the circle, what if the circle is inside the rect?
19:55:01 <Cale> (->) a
19:55:01 <Gracenotes> c_wraith: it may be more palatable as a Reader monad
19:55:03 <Cale> Or (a ->)
19:55:14 <c_wraith> Or even remembering what monad I'm using :)
19:55:16 <Peaker> jfoutz: that's what I meant above by "have to combine 2 methods"
19:55:27 <RenatoSilva> the haskell.org lang description is ridiculous
19:55:28 <jfoutz> Peaker: yeah... it's busted in a lot of ways.
19:55:30 <Gracenotes> the (-> a) comonad >_>
19:55:41 <Gracenotes> with monoid requirement though
19:55:54 * Gracenotes spouts off abstract nonsense
19:56:00 <RenatoSilva> just like any other lang description, it is good, safe, wonderful, the best, etc t
19:57:04 <fooltron> hi haskell channel, haskell hypernoob here ...
19:57:23 <Cale> fooltron: Feel free to ask any questions you might have! :)
19:58:24 <Cale> c_wraith: The main idea behind the (->) e monad is that computations are functions from a fixed type e, and 'running' a computation means applying it to the same value that the entire computation has been applied to.
19:58:44 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
19:58:45 <lambdabot>   ("hello","olleh","HELLO")
19:58:52 <c_wraith> So it's nearly the same as the reader monad?
19:59:00 <Cale> Yes.
19:59:11 <copumpkin> @src Reader
19:59:11 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:59:18 <Cale> It is the same as the Reader monad if you ignore the newtype wrapping/unwrapping.
19:59:34 <c_wraith> @src Reader (>>=)
19:59:35 <lambdabot> Source not found. That's something I cannot allow to happen.
20:00:08 <fooltron> Thanks! I'm trying to define a list that contains ... "The number of iterations of the Collatz function it takes to reach 1 for all positive integers"
20:00:40 <c_wraith> Is the collatz function the 3n+1 thing?
20:00:44 <copumpkin> yup
20:00:49 <fooltron> yep
20:01:03 <Veinor> Then we don't know if that list is defined.
20:01:14 <c_wraith> We'll pretend it is, Veinor. :)
20:01:22 <Gracenotes> collatz can be done with a lazily generated list
20:01:30 <Gracenotes> in a dynamic-programming-esque way
20:01:41 <copumpkin> you can do it really nice with a self-referential array
20:01:46 <copumpkin> *nicely
20:01:49 <fooltron> I've come up with something, but it's not efficient because it calculates the collatz length of each integer indepentantly
20:01:51 <Gracenotes> array, if you want it faster :)
20:02:04 <Veinor> so for the sake of this thing, let's replace 'collatz' with something we know terminates like 'division by two'
20:02:14 <Gracenotes> you refer to a list/array element even if you're not sure it's been calculated already, because if it hasn't, it will be calculated, and will be in the future
20:02:15 <fooltron> ok
20:02:34 <copumpkin> we do know it terminates for all values we could reasonably compute in the memory that you can fit your list into
20:02:36 <Cale> Veinor: There's no need to know if it will terminate. For all small-enough inputs it certainly does.
20:02:45 <Veinor> true vOv
20:03:01 <Gracenotes> quick, collatz haskell golf, on the double!
20:03:10 <Gracenotes> >_>
20:03:15 <Cale> (and Haskell has no problem with possible nontermination :)
20:03:23 <fooltron> Gracenotes: I think I've tried that ... but the problem is this, I think... The length of 3 is defined in terms of the length of 10
20:03:43 <fooltron> so before you know the length of 3, you need to know the length of 10
20:03:52 <c_wraith> That's ok, in haskell
20:04:00 <Gracenotes> fooltron: as far as we know, collatz calculation is a DAG
20:04:11 <fooltron> but before you know 10, you need to know [1..9], right
20:04:17 <Gracenotes> so.. those cycles shouldn't exist if you've implemented it correctly
20:04:28 <c_wraith> Gracenotes:  it has a cycle at 4, 2, 1  :)
20:04:33 <Gracenotes> (at least it's a DAG until you've reached 1)
20:04:36 <Gracenotes> indeedy.
20:04:52 <Gracenotes> The Great Sink!
20:04:55 <c_wraith> But as far as we know, it has no other cycles
20:04:59 <c_wraith> that's true
20:05:05 <Veinor> No cycles with length less than about 34000.
20:05:45 <fooltron> well anyway, I'll see if I can dig up my previous attempt at doing it ... :)
20:06:07 <Gracenotes> fooltron: so, to get the length of 10, you 5 -> 16 -> 8 -> 4 -> 2 -> 1, right?
20:06:38 <Gracenotes> of course, you do need a base case, getting to 1 from 1 = 0 steps
20:07:17 <Gracenotes> it's all pretty neat actually :X *fanboi squee*
20:09:10 <Gracenotes> you could probably do it imperatively if you had a Just/Nothing construct, where Nothing means not-calculated-yet.
20:10:17 <Gracenotes> also, awwww. http://sisinmaru.blog17.fc2.com/blog-category-2.html
20:14:12 <ManateeLazyCat> Chromium is really cool and fast.
20:15:16 <Cale> Prelude Data.MemoCombinators> let col n = if even n then n`div`2 else 3*n+1; collatz = integral collatz' where collatz' 1 = 0; collatz' n = 1 + collatz (col n) in map collatz [1..]
20:15:17 <Cale> [0,1,7,2,5,8,16,3,19,6,14,9,9,17,17,4,12,20,20,7,...
20:15:31 <c_wraith> :t (!!)
20:15:33 <lambdabot> forall a. [a] -> Int -> a
20:15:39 <c_wraith> Int.  seriously.  Why?
20:15:48 <Cale> c_wraith: I hate it too.
20:15:49 <copumpkin> I'm not a fan
20:15:50 <c_wraith> What if I want element 2 ^ 35
20:16:02 <Gracenotes> then you'll wait a long time
20:16:08 <Cale> Though, it can be argued that you shouldn't even use !!
20:16:08 <copumpkin> and also, why allow negative indices?
20:16:20 <jfoutz> :t drop
20:16:22 <lambdabot> forall a. Int -> [a] -> [a]
20:16:23 <copumpkin> so many places where Int is used that it shouldn't be
20:16:23 <Gracenotes> Int is pretty fast though
20:16:30 <copumpkin> Word is no slower
20:16:37 <Cale> I don't even think the Int type should be in the Prelude.
20:16:48 <Gracenotes> Integer is just as fast for low values, but there is still overhead
20:17:02 <Cale> Almost as fast, basically.
20:17:08 <copumpkin> well Integer also allows negative numbers
20:17:11 <Gracenotes> it is the integer-type-franca of Haskell
20:17:22 <Gracenotes> Int is. Integer too.
20:17:30 <solrize> is there a module somewhere to encode/decode hex strings?  i can write one but it's likely to already exist
20:17:37 <c_wraith> :t take
20:17:39 <lambdabot> forall a. Int -> [a] -> [a]
20:17:39 <Gracenotes> Word is a foreign tongue >_>
20:18:00 <Gracenotes> @index readHex
20:18:00 <lambdabot> Numeric
20:18:05 <Gracenotes> @index showHex
20:18:05 <lambdabot> Numeric
20:19:12 <jfoutz> Peaker: that circle square intersection sucks. however, i think if you convert to polar, centered on the circle, you can just check the r of each corner.
20:19:40 <jfoutz> it would be slow but pretty.
20:19:49 <solrize> gracenotes, i'm looking to convert strings, not numbers
20:20:00 <randomwords> When I profile using -prof is there anyway to also profile functions not explicit to my program (e.g. Data.List.sort)
20:20:12 <c_wraith> jfoutz:  that still doesn't help if the circle intersects the side but doesn't contain any corner
20:20:12 <Peaker> jfoutz: actually the intersection thing was wrong, but I have to go to sleep, can explain what its for tomorrow
20:20:24 <Gracenotes> solrize: that is what they do :)
20:20:28 <Peaker> jfoutz: I need to know how it intersects, so I know how to deflect a hitting ball, basically breakout
20:20:46 <Gracenotes> solrize: with some bells and whistles, though, to integrate with Haskell's general Read/Show facilities
20:20:54 <solrize> > readHex "616161"
20:20:55 <jfoutz> Peaker: g'night :)
20:20:56 <lambdabot>   [(6381921,"")]
20:21:02 <solrize> wanted "aaa"
20:21:08 <copumpkin> is seminearring a common term? it doesn't appear to be as all I could find was a haskell blog post on it, but it seems useful
20:21:34 <jfoutz> c_wraith: man... the exact same problem. *blush*
20:21:41 <Gracenotes> > showHex 616161
20:21:43 <lambdabot>   Overlapping instances for GHC.Show.Show
20:21:43 <lambdabot>                              (GHC.B...
20:21:45 <mike-burns> copumpkin: I've only heard it from Haskell people. Not sure if that proves anything.
20:21:49 <Gracenotes> > showHex 616161 ""
20:21:50 <lambdabot>   "966e1"
20:22:14 <Peaker> jfoutz: thanks :)
20:22:16 <Cale> Prelude Data.MemoCombinators Data.List> let col n = if even n then n`div`2 else 3*n+1; collatz = arrayRange (1,1000000) collatz' where collatz' 1 = 0; collatz' n = 1 + collatz (col n) in foldl1' max . take 1000000 . map (\n -> (collatz n, n)) $ [1..]
20:22:16 <Cale> (524,837799)
20:22:16 <Cale> (15.69 secs, 659789520 bytes)
20:22:34 <Gracenotes> hm, I'm not too sure what you want
20:22:40 <Cale> MemoCombinators is a cool module to have around :)
20:23:08 <solrize> gracenotes, 61 is the hex code for the character 'a'
20:23:28 <solrize> so i'm looking for a function (f "61616161616161" == "aaaaa")
20:23:48 <c_wraith> reads "616161" :: [(String, String)]
20:23:54 <c_wraith> > reads "616161" :: [(String, String)]
20:23:56 <lambdabot>   []
20:24:10 <Gracenotes> > "\x61"
20:24:12 <lambdabot>   "a"
20:24:38 <Cale> (compiled with -O2 it takes less than 1/3 that time)
20:24:39 <copumpkin> :t intercalate
20:24:41 <lambdabot> forall a. [a] -> [[a]] -> [a]
20:25:00 <Gracenotes> afaik that's not a common function to have, since Haskell does have escape sequences, and otherwise the escaping would be ambiguous
20:25:45 <solrize> i want to encode binary strings as hex and decode them
20:25:57 <solrize> like base64 encoding, but stupider
20:26:03 <dufflebunk> randomwords: when I have to do that I just make some function that just calls the real one
20:26:13 <Cale> > map (chr . read . take 2) . takeWhile (not . null) . iterate (drop 2) $ "61616161616161"
20:26:14 <c_wraith> One thing to note is that String is not directly compatible with this scheme
20:26:14 <lambdabot>   "======="
20:26:16 <Gracenotes> solrize: so basically doubling the size of the string?
20:26:23 <solrize> gracenot, yes
20:26:29 <Cale> > map (chr . (+4) . read . take 2) . takeWhile (not . null) . iterate (drop 2) $ "61616161616161"
20:26:29 <SamB> solrize: so Data.ByteString.Word8 ?
20:26:30 <lambdabot>   "AAAAAAA"
20:26:40 <randomwords> dufflebunk: That makes sense - It seems like a shame that it can't be enabled automatically
20:26:41 <Gracenotes> hmm. okay then, something like what cale did would work, except with readHex instead of read
20:26:46 <c_wraith> Since String is unicode
20:26:47 <Cale> ah, you want hex
20:26:50 <solrize> samb, hmm, checking
20:27:18 <Cale> > map (chr . fst . head . readHex . take 2) . takeWhile (not . null) . iterate (drop 2) $ "61616161616161"
20:27:20 <lambdabot>   "aaaaaaa"
20:27:39 <Gracenotes> I don't think there is any practical reason at all for storing "aa" as "6161" >_>
20:27:44 <SamB> solrize: I mean, that's the sort of string you mean?
20:27:47 <dufflebunk> randomwords: I have a similar but different problem. When I run this program with profiling all I get in the .prof file is MAIN and CAF lines. None of the functions are in there.
20:28:03 <Cale> dufflebunk: did you compile with -prof -auto-all ?
20:28:04 <solrize> samb, well, regular strings not bytestrings
20:28:14 <Gracenotes> the chars in "aa" would just take up 2 bytes, after all...
20:28:15 <SamB> solrize: with regular ones, wouldn't you need, oh ...
20:28:34 <SamB> > showHex (ord (maxBound :: Char)) ""
20:28:35 <lambdabot>   "10ffff"
20:28:37 <solrize> in python i'd say "616161".decode('hex')
20:28:40 <pikhq> solrize: The problem is, storing "aa" as "6161" is ambiguous.
20:28:57 <SamB> solrize: yeah, you'd need *6* characters per character!
20:29:08 <solrize> ints or bytestrings is fine, i can use "map chr"
20:29:24 <dufflebunk> Cale: I built it with runhaskell Setup.lhs configure -O2 --enable-executable-profiling --user
20:29:27 <pikhq> Note that Unicode is 32-bit.
20:29:35 <SamB> pikhq: is it?
20:29:35 <Gracenotes> although if you're dealing strictly with ASCII, it is a relatively unambiguous (but silly) decoding system
20:29:38 <dufflebunk> Cale: that does add -prof, but doesn't add -auto-all
20:29:45 <SamB> pikhq: then why is (maxBound :: Char) so low?
20:29:51 <copumpkin> it's just under 21 bit
20:29:59 <copumpkin> > logBase 2 0x10ffff
20:30:00 <pikhq> > (maxBound :: Char)
20:30:04 <lambdabot>   20.087461546321563
20:30:04 <lambdabot>   '\1114111'
20:30:07 <Gracenotes> Unicode's bit count depends entirely on the encoding
20:30:17 <solrize> brb, i have to close this xchat it's started beeping at me and is driving me nuts.\
20:30:22 <copumpkin> Gracenotes: the number of code points is fixed
20:30:33 <pikhq> SamB: ... Well, rather, that's the nearest order of magnitude. XD
20:30:48 <Gracenotes> time for random unicode facts!
20:30:50 <SamB> pikhq: depends where you draw your orders of magnitude
20:30:54 <copumpkin> Gracenotes: bring it on!
20:30:58 <SamB> I was drawing them at the nybble
20:31:00 <fooltron> Cale; I think I've wrapped my head around your code now, except that ...
20:31:10 <copumpkin> I draw my orders of magnitude at multiples of 20.087461546321563
20:31:12 <pikhq> SamB: The sensible way: at byte.
20:31:18 <solrize> re
20:31:26 <SamB> pikhq: the result is the same!
20:31:28 <solrize> i dunno what was up with that.  stupid xchat started beeping on every key i typed.
20:31:31 <Cale> fooltron: That Data.MemoCombinators package just saves me from explicitly constructing an array.
20:31:35 <pikhq> Anything else is a hard drive manufacturer's GB. :P
20:31:36 <SamB> pikhq: 3 bytes!
20:31:44 <SamB> 6 nybbles!
20:31:55 <fooltron> as far as I can tell, the length of the collatz is recalculated for each integer
20:32:13 <fooltron> is that right?
20:32:16 <Cale> fooltron: no
20:32:20 <fooltron> oh
20:32:35 <Cale> fooltron: That's what the arrayRange / integral part is about
20:32:44 <fooltron> ah, ok
20:32:52 <Cale> fooltron: Those are functions from the MemoCombinators library which do memoisation.
20:32:52 <pikhq> SamB: Thou shalt die.
20:32:56 <Gracenotes> copumpkin: I apologize, the game has been called off due to an encoding emerg 
20:32:57 <fooltron> i'll check it out
20:33:01 <fooltron> cheers
20:33:04 <copumpkin> Gracenotes: onoes!
20:33:05 <solrize> @whereis readHex
20:33:06 <lambdabot> Maybe you meant: where where+
20:33:08 <Cale> cabal install data-memocombinators
20:33:09 <solrize> @where readHex
20:33:10 <lambdabot> I know nothing about readhex.
20:33:15 <solrize> > readHex "23"
20:33:17 <lambdabot>   [(35,"")]
20:33:17 <copumpkin> pikhq: that is most probably a true statement
20:33:20 <solrize> huh?
20:33:22 <Gracenotes> from Numeric
20:33:24 <Cale> should get it installed, and then you can import Data.MemoCombinators to use it
20:33:25 <solrize> oh
20:33:33 <solrize> @hoogle readHex
20:33:33 <lambdabot> Numeric readHex :: Num a => ReadS a
20:33:34 <solrize> thanks
20:33:35 <Gracenotes> where just brings up a URL for a fact lambdabot's memorized
20:33:40 <Cale> What's happened to hpaste.org?
20:33:54 <copumpkin> even mmorrow is gone!
20:34:06 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=3148#a3148
20:34:12 <ManateeLazyCat> Use paste2.org replace hpaste.org
20:34:18 <Cale> fooltron: ^^ there is a prettier version to look at :)
20:34:23 <Gracenotes> preflex: seen mmorrow
20:34:24 <preflex>  mmorrow was last seen on #haskell 4 days, 17 hours, 9 minutes and 52 seconds ago, saying: looks like CReal truncates
20:34:40 <fooltron> thanks :)
20:35:17 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/Data-MemoCombinators.html -- this might also be interesting to read
20:35:18 <ManateeLazyCat> If you use Emacs, you can use the library paste2.el (www.emacswiki.org/emacs/paste2.el") upload or download to paste2.org in Emacs.
20:35:26 <Gracenotes> Cale: ..where is the MemoCombinators API involved in that code snippet?
20:35:50 <Gracenotes> does it do its work sekritly?
20:36:07 <Cale> Gracenotes: data-memocombinators
20:36:16 <Cale> Gracenotes: oh, arrayRange
20:36:30 <Gracenotes> okay then
20:36:36 <Cale> arrayRange :: Ix a => RangeMemo a
20:36:36 <Cale> Build a memo table for a range using a flat array. If items are given outside the range, don't memoize.
20:37:15 <solrize> http://www.haskell.org/haskellwiki/Library/Data_encoding#Base16  aha, this is what i want
20:37:20 <keir> Is there an explanation of what the notation used on page 24 of the pdf of http://cs.anu.edu.au/~Ben.Lippmeier/project/disciple/disciple-anu-2008-06.pdf mean somewhere?
20:37:33 <keir> I am not sure how to google for it because there is no name.
20:37:50 <dufflebunk> Cale: if I run configure sith -ghi-opts=-auto-all, then I get all the functions in there. I wonder if that's a bug in cabals profiling stuff
20:37:56 <Cale> keir: That's all standard type theory/logic notation.
20:37:59 <Gracenotes> solrize: :X it seems so
20:38:04 <keir> Cale: ok. url?
20:38:21 <Cale> keir: If you read something like "Types and Programming Languages", you'll get a good handle on it.
20:38:27 <keir> Cale: I don't know much about type theory besides HM basics.
20:39:42 <keir> Cale: I probably won't get that unless there is something I can start with online. Do you know if the bar notation has a name that I can search for?
20:39:51 <Cale> keir: Basically, the things with the horizontal lines are rules: the stuff above the line is what has to be true in order for the rule to apply, and the stuff below the line is the consequence.
20:40:11 <keir> Cale: I figured that was what it meant. Thanks.
20:40:19 <Gracenotes> the |- is a turnstile
20:40:28 <ManateeLazyCat> If anyone emacser interested paste2.org for fasssst share in IRC, see http://www.emacswiki.org/cgi-bin/emacs/Paste2
20:40:35 <Gracenotes> :: means "has a type of"
20:40:37 <Saizan> they are called inference rules, afaik
20:40:49 <keir> Cale: The stuff in a box is usually 'axiomatic'? I.e. true by definition?
20:40:52 <Cale> That's just the name of the typographical symbol. |- is usually read as "proves"
20:41:14 <Cale> The boxed things are just headings, I think
20:41:19 <Gracenotes>  means "under the given environment/set of type assumptions", iirc
20:41:28 <Cale> The things with no bar are axioms
20:41:59 <Cale> Yeah, Gamma is any set of other statements
20:42:27 <Saizan> the box just contain the relation the following rules are defining
20:42:35 <Cale> Gamma, x1 :: T1 |- t2 :: T2 ; E
20:42:48 <keir> I started writing a simple functional language backed by LLVM for fun... ended up with type inference by accident. Figure I should learn more about type theory.
20:42:50 <Gracenotes> the rectangular subset/superset symbols are subtype/supertype, no?
20:43:38 <Cale> reads as  "From Gamma and the fact that x1 has type T1, it is possible to infer that t2 has type T2 ; E"
20:44:17 <SamB> Cale: why do we need Gamma there ?
20:44:36 <SamB>  there seems kinda useless ...
20:45:10 <Cale> This is in the precondition of a rule, it's just saying that it doesn't hurt to have a larger context of facts.
20:46:09 <Cale> (or that this rule applies in any type context)
20:46:42 <keir> So basically these type rules are fed into a constraint solver that infers the types?
20:47:01 <Cale> They're a formal specification of what the constraint solver is going to do.
20:47:07 <keir> Ok.
20:48:08 <keir> Seems like a large number of rules.
20:48:17 <Cale> You could build a typechecker directly from these rules if you had a programming language which accepted this syntax :)
20:48:40 <keir> :)
20:49:23 <Cale> Well...
20:49:52 <keir> Could you express a type checker for C with this notataion?
20:49:58 <keir> *notation
20:50:12 <Cale> Yeah, probably reasonably well
20:51:29 <Cale> I think the top left corner is mostly just specifying the types of primitive values. The bottom left corner is defining properties of this subset relation (I'm betting without reading too carefully you probably wouldn't use those directly in a real implementation, but actually use a proper set datastructure).
20:51:54 <Cale> The right hand side goes over the typing rules for each piece of syntax in the language.
20:52:16 <Cale> So, variables, abstractions, applications, let, etc.
20:52:40 <keir> What I implemented for my toy language is something like the right side (i.e. types of branches of an if must match).
20:53:33 <Cale> ah, actually, looking more carefully, those are actually subtyping rules, including the appropriate rule for function types
20:56:49 <Cale> hmm, the effect typing rule for if/then/else there seems a bit off
20:57:06 <Cale> E_3 isn't even mentioned in the result
20:57:14 <keir> hehe
20:57:27 <keir> Find the thesis bugs!
21:05:29 <Saizan> you generally need to mangle the rules to avoid backtracking to get a reasonable implementation
21:05:41 <keir> For C?
21:07:50 <Saizan> by generally i meant "for these kinds of rules you find in papers etc.." unless they specifically give what is called the "algorithmic" or "syntax directed" presentation
21:08:05 <keir> Ah, I see.
21:21:00 <fooltron> Cale: just got your collatz code running - thanks for the help. Now I just need to understand List and Memocombinators :)
21:27:11 <solrize> so i got a real basic question about gadt's.  how do programs actually construct values that live in them?  i.e. parse "123" into Term Int, and parse "True" into Term Bool, or otherwise introduce values into gadt-based pattern matching
21:31:27 <dufflebunk> You mean like: Term (read somestring)
21:32:20 <solrize> dufflebunk, something like that, yeah
21:33:22 <holmak__> gadt == generic abstract data type ?
21:33:43 <Cale> holmak__: Generalised algebraic data type
21:33:49 <holmak__> aha, thanks
21:34:08 <holmak__> ADT is a tricky acronym
21:34:32 <Cale> yeah, in Haskell contexts, the A usually stands for algebraic :)
21:35:06 <holmak__> see, I'm reading Real World Haskell and they just said the opposite :)
21:35:20 <bos> no we didn't
21:38:18 <jfoutz> solrize: don't you still need distinct constructor names? like... data Exp where Add :: Exp Int -> Exp Int -> Exp Int
21:39:10 <Saizan> solrize: if you're parsing a String and don't know which type to expect, you have to parse it into exists a. Term a
21:39:27 <Saizan> solrize: and later pattern match on the gadt constructors to see which type it was
21:40:06 <solrize> saizan aha, you can do that?  hmm.
21:40:08 <Saizan> (exists a. Term a is pseudo haskell, you need an existential wrapper)
21:40:26 <Saizan> solrize: yup
21:40:27 <solrize> forall a. Term a   ?
21:40:31 <Saizan> no
21:41:08 <Saizan> data AnyTerm where AnyTerm :: Term a -> AnyTerm
21:41:22 <solrize> hmm
21:41:42 <Saizan> that 'a' gets existentially quantified
21:44:16 <Saizan> which means that it stands for some fixed but unknown type
21:44:33 <solrize> foo = Anyterm (Term 123)
21:45:03 <Saizan> but by pattern matching on the Term constructors you might recover its identify if the constructors contain enough information
21:45:29 <Saizan> what's your definition for the Term type?
21:45:34 <solrize> do any of the usual articles have an example of this?  i surfed around a little
21:45:59 <Saizan> the wikibook should have something on existentials
21:46:06 <solrize> saizan i'm just thinking  data Term where  Num :: Int -> Term Int;  Flag :: Bool -> Term Bool
21:46:18 <Saizan> ok
21:46:37 <dmwit> ?instances Monoid
21:46:38 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:46:48 <dmwit> Isn't there an instance for Bool somewhere?
21:46:55 <Saizan> so if foo = AnyTerm (Num 123), by pattern matching on it you can recover the fact that it contains an Int
21:46:55 <dmwit> ?src All
21:46:55 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:47:08 <dmwit> probably that, huh
21:47:14 <Saizan> yeah, and Any
21:47:24 <dmwit> Right, thanks.
21:49:24 <Saizan> the point is that if you're e.g. constructing the term from parsing you don't know statically which type it's going to be, so you hide it inside AnyTerm, the caller then has to cope with the fact that it could be any of the possible types
21:51:23 <solrize> saizan, thanks, something just came up over here that i gotta take care of, i'll experiment with that stuff later
21:52:29 <jfoutz> but that's still not going to parse... you'll have to pick the string apart somewhere to decide what type to construct.
22:34:57 <dmwit> I have a pure function which calls error in a library.
22:35:08 <dmwit> I'd like to turn it into a pure function which returns a Maybe type.
22:35:24 <dmwit> Is it possible?
22:35:39 <dmwit> I've tried mucking about with unsafePerformIO, catch, and seq, but haven't managed to get it quite right yet.
22:35:45 <ajdhs> does anyone have a GHC tree handy?
22:36:20 <Saizan> dmwit: which is the type?
22:37:00 <ajdhs> my autoconf is screwing up the configure scripts
22:37:11 <dmwit> Saizan: encodingFromString :: String -> DynEncoding
22:37:42 <dmwit> data DynEncoding = DynEncoding (forall a. Data a, Encoding a => a) -- roughly
22:38:04 <Saizan> `seq` on that won't help, you need rnf
22:38:26 <dmwit> ...even if he calls error?
22:38:44 <Saizan> it depends on how deep the call to error is hidden
22:38:57 <dmwit> http://hackage.haskell.org/packages/archive/encoding/0.5.1/doc/html/src/Data-Encoding.html#encodingFromString
22:39:24 <dmwit> (I sent him a patch to make the Maybe version available, but I'm not sure he's seen it / intends to apply it, so I want to work around for now.)
22:39:51 <Saizan> ah, it should be enough then
22:40:24 <Saizan> there's also a library called something like chasing bottoms to check bottoms in pure code
22:40:50 <dmwit> Marvelous, thanks!
22:42:53 <PetRat> I'm looking at the Typeclassopedia, and looking at the exercise to define Applicative on Maybe. My question is what should Nothing <*> x work out to? x, or Nothing? The applicative law doesn't seem to dictate the answer. Maybe it can be either one, consistently?
22:43:21 <dmwit> I don't think both choices type-check.
22:43:31 <Deewiant> ?ty (Nothing <*>)
22:43:33 <lambdabot> forall a b. Maybe a -> Maybe b
22:43:48 <Deewiant> You don't have much choice, with that type signature :-)
22:43:54 <dmwit> Yeah. =)
22:45:21 <Saizan> ?djinn Maybe (a -> b) -> Maybe a -> Maybe b
22:45:22 <lambdabot> f a b =
22:45:22 <lambdabot>     case a of
22:45:22 <lambdabot>     Nothing -> Nothing
22:45:22 <lambdabot>     Just c -> case b of
22:45:24 <lambdabot>               Nothing -> Nothing
22:45:26 <lambdabot>               Just d -> Just (c d)
22:45:44 <Saizan> even djinn gets it right :O
22:46:03 <dmwit> f a b = Nothing
22:46:15 <Saizan> you don't!
22:46:42 <PetRat> I'm trying to follow this.
22:47:41 <PetRat> So Nothing <*> x = Nothing?
22:47:45 <Saizan> PetRat: the idea is that you've to return a "Maybe b" but x is a "Maybe a" so you can't use it
22:47:56 <Saizan> so yeah, the only option is Nothing there
22:48:32 <PetRat> Okay, I get it.
23:15:20 <ski> @. read run showTree (showTree showsPrec) 0 (modifyTree elementTree (\x -> Node (10+x) []) (Node 0 [Node 1 [],Node 2 []])) ""
23:15:21 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
23:15:30 <ski> bah
23:15:34 <ski> > showTree (showTree showsPrec) 0 (modifyTree elementTree (\x -> Node (10+x) []) (Node 0 [Node 1 [],Node 2 []])) ""
23:15:35 <lambdabot>   "Node (Node 10 [Node 1 [],Node 2 []]) [Node (Node 0 [Node 11 [],Node 2 []])...
23:15:45 <ski> > showTree (showTree showsPrec) 0 (modifyTree elementTree (\x -> Node (10+x) []) (Node 0 [Node 1 []])) ""
23:15:47 <lambdabot>   "Node (Node 10 [Node 1 []]) [Node (Node 0 [Node 11 []]) []]"
23:18:57 <hackagebot> yices 0.0.0.4 - Haskell programming interface to Yices SMT solver (KiYungAhn)
