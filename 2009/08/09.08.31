00:09:17 <cloud_> hi
00:11:26 <Axman6> 'lo
00:15:34 <ezyang> Help needed: let's suppose I have two values with signatures Int and Maybe Int. If the latter variable is Nothing, I want the former; otherwise I want the max. How, do I encode this nicely?
00:15:55 <c_wraith> :t max
00:15:57 <lambdabot> forall a. (Ord a) => a -> a -> a
00:15:58 <copumpkin> there are some strange people on haskell-cafe
00:16:23 <c_wraith> max a <$> b
00:16:34 <c_wraith> err.  that doesn't do what you want
00:16:37 <c_wraith> but it's close
00:16:40 <ezyang> yeah, really close
00:17:00 <ezyang> I suppose a way to cheese it would be fromMaybe a $ max a <$> b
00:17:01 <c_wraith> hmm
00:17:01 <mmorrow> haha, this function is horrifying http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3464#a3464
00:17:29 <copumpkin> > liftA2 max (pure 1) (Just 5)
00:17:30 <ezyang> mmorrow: Yay marching indents!
00:17:30 <lambdabot>   Just 5
00:17:47 <ezyang> > liftA2 max (pure 1) (Nothing)
00:17:47 <dibblego> mmorrow, from where was it born?
00:17:48 <lambdabot>   Nothing
00:17:53 <copumpkin> ah
00:18:27 <doserj> > let f a b = fromJust (Just a `max` b) in f 3 Nothing
00:18:28 <lambdabot>   3
00:18:31 <mmorrow> dibblego: that's part of the code from trying to hack user-local @let state into lunabot
00:18:35 <copumpkin> ezyang: you could define a Max "Monoid" (even though it's just a semigroup)
00:19:19 <Axman6> :t max
00:19:19 <ezyang> doserj: Huh, what happened there?
00:19:20 <lambdabot> forall a. (Ord a) => a -> a -> a
00:19:43 <doserj> ezyang: what do you mean?
00:19:44 <copumpkin> > max (Just 5) (Just 6)
00:19:45 <lambdabot>   Just 6
00:19:47 <Saizan> Ord a => Ord (Maybe a) instance
00:19:48 <c_wraith> @instances Ord
00:19:48 <ezyang> (Just 2) `max` (Nothing)
00:19:49 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
00:19:52 <Deewiant> > max (Just 2) Nothing
00:19:53 <copumpkin> > max (Just 5) Nothing
00:19:54 <lambdabot>   Just 2
00:19:54 <lambdabot>   Just 5
00:19:57 <ezyang> lol
00:20:02 <cloud_> lol
00:20:04 <copumpkin> that's simple enough :)
00:20:28 <c_wraith> How did I forget Maybe had an Ord instance?
00:20:44 <copumpkin> cause it's an odd instance for it to have, imo :P
00:20:49 <c_wraith> I now remember checking, just a couple days ago, and discovering that Nothing is the universal minimum. :)
00:22:19 <c_wraith> > Nothing < Just (minbound::Int)
00:22:20 <lambdabot>   Not in scope: `minbound'
00:22:24 <c_wraith> > Nothing < Just (minBound::Int)
00:22:26 <lambdabot>   True
00:22:50 <dibblego> > maximum (8 : maybeToList (Just 9))
00:22:51 <lambdabot>   9
00:23:05 <Stinger> > Nothing < Nothing
00:23:06 <lambdabot>   False
00:24:39 <ezyang> grah nested structures suck
00:24:53 <mmorrow> Saizan: check out this (grepped for (stat|open|close|read|write|mmap|munmap|mprotect)) dump of stracing the eval prog for ", 42"
00:25:00 <mmorrow> Saizan: file:///home/m/codez/LUNABOT/lunabot/src/lunaeval.ghc.strace.txt
00:25:13 <mmorrow> Saizan: this is definitely a losing battle, it's doing everything twice
00:25:17 <Nereid_> mmorrow: better check your url :-)
00:25:22 <mmorrow> lol
00:25:31 <cloud_> lol
00:25:33 <c_wraith> works for him
00:25:35 <c_wraith> *shrug*
00:25:36 <c_wraith> :)
00:25:38 <Nereid_> and only him :)
00:25:49 <mmorrow> http://moonpatio.com/repos/lunaeval.ghc.strace.txt
00:33:40 * mmorrow clocks out from lunabot for today
00:50:31 <ezyang> What's the correct way to read from a file, and then write to it later?
00:50:39 <ezyang> readFile/writeFile won't work due to laziness
00:51:52 <doserj> openFile and read/write on the handle
00:52:12 <DrSyzygy> Oy. I'm damned glad I've figured out how to deal with online discussions without actually getting upset at what people write about me!
00:52:32 * DrSyzygy has read through the discussions in the reddit links dons posted of my latest post.
00:53:19 <mikem`> DrSyzygy: link, please?
00:53:30 <DrSyzygy> http://www.reddit.com/r/programming/comments/9feo1/new_course_stanford_math_198_category_theory_and/
00:53:33 <mikem`> thank you
00:53:42 <DrSyzygy> Also: http://www.reddit.com/r/math/comments/9febp/new_course_stanford_math_198_category_theory_and/
00:54:22 <DrSyzygy> Apparently I suck because I pompous in a way typical to Stanford, and I don't already have video lectures even though the course hasn't started yet. :-P
00:54:28 <DrSyzygy> :-)
00:54:57 <ksf> I've discovered another reason not to use gtk.
00:55:36 <ksf> ...treeView is not lazy in the contents of undisplayed cells.
00:56:06 <ezyang> hmm, I think what I actually want to do is make readFile not lazy
00:56:20 <copumpkin> ezyang: seq it then
00:56:37 <ezyang> I wish I understood seq
00:56:46 <copumpkin> or rather
00:56:48 <copumpkin> rnf :)
00:56:58 <copumpkin> since seq will grab the first character only :P
00:57:03 <copumpkin> or not even, actually
00:57:09 <copumpkin> well, sorta :P
00:57:22 <c_wraith> seq the length of it.
00:57:37 <copumpkin> or just rnf it
00:58:05 * copumpkin goes to sleep
01:00:54 <Warrigal> @hoogle rnf
01:00:55 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
01:01:18 <Warrigal> Strategies?
01:01:21 <Warrigal> Huh.
01:01:36 <ezyang> length didn't work
01:01:41 <ezyang> I don't know how to make rnf work
01:02:38 <codolio> case rnf whatever of () -> whatever_is_fully_evaluated_here
01:03:26 <cloud_> hi
01:03:32 <ezyang> codolio: what is whatever?
01:03:49 <Cale> rnf foo `seq` (...foo is fully evaluated here...)
01:04:11 <ezyang> ah, I see
01:04:47 <codolio> It's whatever you want to fully evaluate.
01:05:07 <Dora> å—¨~
01:05:33 <cloud_> å“ˆå“ˆå•Šå“ˆå“ˆ
01:05:40 <cloud_> - -
01:06:28 <ezyang> Didn't work
01:06:29 <ezyang> (read <$> (rnf <$> contents `seq` contents))
01:06:41 <ezyang> I'm starting to suspect that fully evaluating the string isn't closing the handle
01:06:47 <ezyang> where contents = readFile "statefile"
01:08:12 <ksf> what do you guys think of
01:08:14 <ksf> instance MonadFix STM where
01:08:15 <ksf>     mfix = unsafeCoerce fixIO
01:08:27 <ksf> should I consider it a wart or a clever hack?
01:08:45 <codolio> Does that actually work?
01:08:50 <ksf> it does.
01:09:14 <ksf> both are ST monads
01:09:26 <codolio> Oh, you mean ST, not STM.
01:09:34 <codolio> Or do you mean STM?
01:09:43 <ksf> I _do_ mean STM
01:10:04 <codolio> Huh.
01:10:37 <ksf> fixIO spawns an newIORef (throw NonTermination), then reads a value, passes it to the computation, writes the result of the computation into the ioref and finally returns the result.
01:11:58 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
01:12:20 <ksf> (i forgot the unsafeInterleaveIO)
01:12:27 <codolio> What package is it in? parallel?
01:12:40 <codolio> Evidently my ghc source doesn't have that.
01:12:46 <ksf> STM should be parallel, yes.
01:12:50 <codolio> Oh no, stm of course.
01:12:56 <codolio> Which I don't have either.
01:14:49 <codolio> Maybe it is parallel... stm seems to just be the exposed modules.
01:15:08 <ksf> the primitives are in GHC.Conc
01:15:33 <codolio> Ah, there we are.
01:16:23 <codolio> Huh, it is exactly the same as IO. How boring. :)
01:16:40 <ezyang> agh, this is annoying
01:17:41 <ksf> I don't know whether it works on multiprocessors, too, but I guess it should be fine as fixIO doesn't try to break out of atomically's guarantees.
01:18:05 <ksf> ...and spawning a couple of IORefs doesn't have any observable side-effects.
01:18:18 <ksf> but I'm crystal-balling ghc internals here.
01:22:08 * ezyang is frustrated 
01:22:17 <ezyang> dang it, I can't make it do strict evaluation
01:22:30 <Axman6> ?
01:23:07 <ezyang> (withFile "statefile" ReadMode         (\h -> let c = hGetContents h in ((length <$> c) `seq` (read <$> c))))
01:23:15 <ezyang> refuses to read out the entirety of the file
01:23:21 <path[l]> seen copumpkin
01:23:29 <Berengal> ezyang, openFile, or last contents `seq` foo
01:24:04 <ksf> why are you using getContents if you want to read everything?
01:24:22 <ezyang> ksf: Is there a better function?
01:24:45 <ketil> readFile?
01:25:08 <ezyang> Isn't that also lazily?
01:25:15 <ksf> nope.
01:25:21 <ketil> yes!
01:25:26 <Berengal> readFile is lazy
01:25:33 <ketil> (Except Data.ByteString.readFile)
01:25:47 <ketil> That is the quick and dirty approach, I suppose.  And fast.
01:26:28 <ezyang> Sure...
01:28:15 <ksf> ...if in doubt, use bytestring-mmap
01:28:23 <ksf> which is lazy, too, but in a different way.
01:28:31 <Baughn> A *better* way
01:28:32 <Berengal> withFile "foo" ReadMode (\h -> let readAll = hIsEOF h >>= \eof -> if eof then return [] else liftM2 (:) (hGetChar h) readAll in readAll
01:29:09 <ksf> well, it's lazier in a way that changes pure values under your fingertips.
01:29:29 <ksf> ...but that's why there's inotify.
01:29:31 <Baughn> Surely it read-locks the file on open?
01:29:47 <ksf> it doesn't.
01:29:58 <Baughn> Surely it does.
01:30:10 <ksf> surely it doesn't.
01:30:10 * Baughn jams fingers in his ears and whistles loudly.
01:30:30 <ksf> it clams to break referential transparency, in its own docs.
01:30:46 <Baughn> ..so...scary
01:30:47 <ksf> and unix locking is more or less non-existant, anyway.
01:30:57 <ksf> as locking is a bad idea in general.
01:31:01 <mux> it surely isn't.
01:31:25 <Baughn> It surely is
01:31:31 <Baughn> What you want is atomicity, not locking
01:31:33 <ksf> last time I looked, there was no portable, secure unix locking scheme
01:31:46 <Berengal> Locking has caused me lots of grief
01:32:08 <ksf> dunno if you could tell linux to duplicate your stuff, that is, provide atomicity.
01:32:44 <Baughn> Can't.
01:32:47 <ksf> should become standard some time, with all these journalling or even versioning filesystems around.
01:32:48 <Berengal> I think linux does duplicate your stuff, but not when mmapping
01:32:51 * ezyang sighs relieved 
01:32:55 <ezyang> Ok, now it worked
01:33:06 <ezyang> looking up bytestring-mmap
01:33:08 <Baughn> ksf: Well, you can with btrfs, but it's highly non-standard and hard to use. Also, it just means locking the entire filesystem
01:33:15 * ksf vaguely remembers a copy-on-write mmap flag, but that's only for your writes, iirc.
01:33:27 <Baughn> Right
01:33:48 <ezyang> is that actually a good idea?
01:34:04 <Baughn> Copy-on-write mmap? Of course.
01:34:23 <ezyang> oh, no, bytestring-mmap
01:34:26 <Baughn> A filesystem with transactions would be /better/, but it's /something/
01:34:31 <Baughn> Oh, that. Yes, that's a good idea too.
01:34:39 <Baughn> You just need to know what you're doing
01:34:47 <ezyang> but it's got unsafe written all over it
01:34:56 <mux> I don't know where you've seen this copy-on-writes mmap() flag, what's sure is that it's non-standard
01:35:02 <Baughn> ezyang: You're talking to someone who chews unsafePerformIO for breakfast.
01:35:09 <path[l]> seen copumpkin
01:35:16 <ezyang> :-P
01:35:22 <ksf>        MAP_PRIVATE
01:35:23 <ksf>                   Create a private copy-on-write mapping.  Updates to the mapping are not visible to other processes mapping the same file, and
01:35:23 <ksf>                   are not carried through to the underlying file.  It is unspecified whether changes made to the file after the mmap() call are
01:35:23 <ksf>                   visible in the mapped region.
01:35:30 <ezyang> @seen copumpkin
01:35:30 <lambdabot> I saw copumpkin leaving ##logic, #haskell-iphone, #haskell, #haskell.it, #darcs, #ghc, #haskell-in-depth and #haskell-blah 16m 3s ago, and .
01:35:39 <path[l]> ah it does work
01:35:58 <mux> ksf: there's no file copy involved here (and you can use a pastebin site for that...)
01:36:14 <ksf> I never claimed that files are copied.
01:36:16 <ksf> pages are.
01:39:09 <ksf> the comment at "MAP_DENYWRITE" says it all.
01:39:28 <mux> MAP_DENYWRITE is non-standard :-)
01:39:58 <ksf> the only standard I know is what I see when I type man mmap.
01:40:11 <Baughn> That is the wrong standard >_>
01:40:17 <mux> you're doing it wrong
01:40:25 <ksf> well, nowadays every unix emulates linux.
01:40:28 <mux> no
01:40:33 <ksf> so it's arguably standard.
01:40:45 <mux> this is so wrong I'm having a hard time answering something else than just "no"
01:40:53 <ksf> tell me a unix without linux compability layer that i'd care to use.
01:40:58 <Baughn> OS X
01:41:06 <ksf> Q.E.D.
01:41:13 <Baughn> BSD. Any BSD.
01:41:19 <mux> the linux compatibility layers don't necessary involve supporting things such as MAP_DENYWRITE
01:41:23 <mux> and yes, I was about to say BSD
01:41:25 <ksf> freebsd, at least, runs linux binaries just fine.
01:41:32 <ksf> likewise, solaris.
01:41:35 <mux> I'm a FreeBSD developer.
01:41:35 <Baughn> ksf: Yes. Approximately.
01:41:40 <mux> I know about this
01:41:51 <Baughn> Just because it runs linux binaries doesn't mean they act quite the same way as on linux
01:42:00 <ksf> linux doesn't support DENYWRITE, either.
01:42:05 <Baughn> Also, MAP_DENYWRITE is /not/ in my linux manpage
01:42:14 <ksf>               This flag is ignored.  (Long ago, it signaled that attempts to write to the underlying file should fail with ETXTBUSY.  But  this
01:42:14 <ksf>               was a source of denial-of-service attacks.)
01:42:31 <Baughn> (Which should have been immediately obvious)
01:42:40 <Baughn> What they should implement is MAP_COPYONWRITE
01:43:00 <ksf> ...mine is dated 2008-12-01, release 3.20
01:43:34 <ksf> actually, MAP_PRIVATE is just fine for that.
01:44:33 <Baughn> No, MAP_PRIVATE doesn't help if someone /else/ writes to the file
01:44:45 <ksf> It is unspecified whether changes made to the file after the mmap() call are
01:44:45 <ksf>                   visible in the mapped region.
01:44:58 <mux> ksf: meaning, this is unusable
01:45:20 <ksf> ...well, you get no additional guarantees, currently.
01:45:36 <mux> not having them now amounts to not having them, ever
01:45:40 <ksf> they could change it to both-sided copy on write without breaking semantics.
01:45:44 <mux> in any case POSIX APIs are ill-suited for that kind of things
01:46:17 <ksf> who, but the os, should manage paging, then?
01:46:36 <mux> I don't think I said it wasn't the OS business
01:46:59 <ksf> ...well, and POSIX or POSIX extensions is what OSs use.
01:47:15 <mux> so...?
01:47:25 <ksf> it won't make much sense to think of another name for mmap just to add a flag.
01:47:41 <mux> if it indeeds fits in an additional flag for mmap()
01:47:55 <mux> I'm just saying POSIX doesn't provide the tools for this now
01:48:14 <mux> whether they will in the future, in the form of new mmap() flags, or new system calls, or what not, is an open question :-P
01:55:47 <poe> what is the work-around to compile with GHC 6.10.4 on OS X 10.6?
01:56:18 <Axman6> why not use one of the binaries?
02:00:23 <mjrosenb> has 10.6 been released?
02:00:26 <Axman6> yes
02:00:32 <Axman6> got released on the 28th
02:00:51 <Axman6> (a month early)
02:01:04 <vegai> and almost every mac user seems to have it already
02:01:14 <vegai> should buy some apple stock... those people are crazy :P
02:01:38 <Axman6> vegai: at $29, why not?
02:02:04 <vegai> my updates are free, and I don't do them every time I can :)
02:02:19 <Axman6> yeah, but where's your OpenCL?
02:02:28 <vegai> a colleague's macbook pro just went to maintenance because it refused to boot after a snow leopard upgrade...
02:02:49 <Axman6> something totally unknown to linux users? :P
02:02:51 <vegai> might be a coincidence, though
02:03:13 <vegai> perhaps I block the memories, but I don't have any such :P
02:03:38 <vegai> oh, except just now, when my root btrfs failed to boot because btrfs-utils and kernel btrfs conflicted
02:03:50 <vegai> but that's alpha software
02:03:56 <Axman6> heh
02:04:06 <vegai> and even Linus suffered from it
02:04:07 <Axman6> i was reading about btrfs today, seems fairly uninteresting
02:04:13 <vegai> no, it's not
02:09:22 <path[l]> finitemap has a method called addtoFm. but finitemap says its deprecated and data.map should be used ... which doesnt have an add function
02:09:39 <doserj> @type Data.Map.insert
02:09:41 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
02:10:03 <path[l]> ah thanks, missed that
02:10:35 <Axman6> path[l]: a Map would be pretty useless if you couldn't add things to it ;)
02:10:52 <path[l]> how does inser work though. Given haskell strucutres are meant to be immutable
02:11:14 <dschoepe> path[l]: you get a new Map that also contains the inserted element
02:11:18 <path[l]> I always assumed it meant adding stuff to a map would give you a new map
02:11:19 <dschoepe> @type Data.Map.insert
02:11:19 <path[l]> ah
02:11:20 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
02:11:40 <Axman6> path[l]: well yeah, that's how it works :)
02:11:48 <path[l]> so if I ignore the return value Ill have the old map?
02:11:59 <Axman6> yes
02:12:00 <EnglishGent> hi all - just pasted a little bit of code on hpaste - "simple typeclass experiment"
02:12:15 <EnglishGent> it doesnt work - can someone explain to a poor newbie why not? :)
02:12:22 <dschoepe> > let x = Data.Map.empty in (x,Data.Map.insert 2 5 x)
02:12:23 <lambdabot>   Not in scope: `Data.Map.empty'Not in scope: `Data.Map.insert'
02:12:31 <Saizan> EnglishGent: link?
02:12:34 <dschoepe> > let x = empty in (x,insert 2 5 x)
02:12:35 <lambdabot>   Ambiguous occurrence `empty'
02:12:35 <lambdabot>  It could refer to either `Text.PrettyPrint.Hu...
02:12:36 <path[l]> ah ... then changing from my approach of creating a list then making a map out of it, to creating a map and inserting elements into it will not give me any performance gains
02:13:03 <Axman6> it certainly could
02:13:11 <dschoepe> path[l]: depends on how you create it. Inserting into a map is cheaper
02:13:13 <EnglishGent> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8875#a8875
02:14:03 <path[l]> ah ok
02:14:09 <path[l]> let me try it then :)
02:15:21 <jethr0> can someone help me with preprocessor usage in haskell?
02:15:42 <Saizan> EnglishGent: your signature for massoc requires the implementation to able to create a value of any type 'y' provided a value of any type 'a' (with an Eq context) both chosen by the caller
02:15:51 <jethr0> if I do "ghc a.hs b.hs", will "#defines" from "a.hs" be visible in "b.hs"?
02:15:54 <blackdog_> jethr0: if you ask your question, we'll know if we can help :)
02:15:58 <jethr0> hehe
02:16:08 <EnglishGent> ah!
02:16:19 <Saizan> EnglishGent: but assoc can't do that, the types are constrained by the type of the list
02:16:40 <jethr0> or if i do "ghc --make a.hs", where "a.hs" imports "b.hs", will defines before the import be visible in b.hs?
02:16:42 <EnglishGent> no - that makes sense to me
02:17:21 <EnglishGent> what I want to do is have a single function that does what assoc does both on lists & IO List - so if the 2nd argument is an IO List the output will be an IO List
02:17:23 <blackdog_> jethr0: wouldn't think so. what happens when you try?
02:17:42 <Saizan> EnglishGent: you can use a multi parameter typeclass if you want
02:17:49 <Saizan> EnglishGent: or type families
02:17:51 <jethr0> haven't tried, will do so shortly. i'm just trying to understand how thsi stuff is supposed to work across modules
02:18:21 <EnglishGent> I dont know about type families - I've read stuff on multi-parameter type classes, but I havent tried writing one yet
02:18:48 <jpcooper> hello
02:18:59 <EnglishGent> hi jpcooper :)
02:19:17 <EnglishGent> would you mind explaining a little more Saizan? :)
02:20:03 <Saizan> EnglishGent: something like class Massoc dict key result where massoc :: dict -> key -> result
02:20:20 <jpcooper> I've been writing a chat server, and one of the parts of it is a Fastcgi interface. I would like both to run separately, and the FCGI interface to be its own executable so that FCGI can run it on its own. The problem is that the FCGI interface needs access to certain data in the core server. Is there any way other than sockets in which these two Haskell processes would be able to communicate with each other?
02:20:33 <Saizan> EnglishGent: instance Eq a => Massoc [(a,b)] a [b] where massoc = assoc
02:20:38 <EnglishGent> maybe it's just my inexperience with doing IO in Haskell  - but I'm finding I want to do this (overload functions to work on both normal & IO types) quite a lot
02:20:45 <path[l]> if I know a list is finite, I should always choose foldl' right?
02:21:01 <EnglishGent> thanks Saizan :)
02:21:44 <jethr0> jpcooper: you mean a way other than sockets for two separate programs to interact under unix?
02:21:50 <Saizan> EnglishGent: we tend to not overload too much, actually, and you should just use combinators like fmap or >>= or do-notation to inject your pure functions through IO
02:22:14 <jpcooper> jethr0, With my wishful thinking, I thought that there might be a way in which the processes could share memory
02:22:34 <Saizan> path[l]: it depends on the combining function
02:22:37 <blackdog> jpcooper: like mmap?
02:23:13 <jpcooper> mmap?
02:23:21 <blackdog> jpcooper: if you want to use it for communication, you're probably on a hiding to nothing...
02:23:22 <path[l]> hmm in general thougj
02:23:42 <blackdog> what would be the benefit of sharing the memory?
02:23:44 <path[l]> if f a b = f b a
02:23:59 <gio1234> does somebody is from portugal?
02:24:02 <jpcooper> blackdog, the FCGI part needs the current state of the server
02:24:25 <Saizan> path[l]: not that, i mean the strictness properties
02:25:00 <Saizan> path[l]: if it's strict on the accumulator/recursive call then it's best to use foldl'
02:26:00 <blackdog> jpcooper: is it a lot of state, though? in general message passing is more robust
02:26:12 <jpcooper> it could be a lot of state in the end
02:26:24 <blackdog> there's a mmap library on hackage, so you _could_ share it if you wanted to
02:26:48 <blackdog> but it seems like premature optimisation
02:27:08 <jpcooper> I wrote the whole thing in the StateT monad, and now I suppose I'll have to convert it to generate a certain type of request to be sent to the server
02:27:12 <jpcooper> which is a shame
02:27:14 <EnglishGent> um - is there a way to ask hoogle what the superclasses of some class is? e.g. have it tell me that everything defining Ord is also defining Eq
02:27:18 * blackdog needs either a faster computer or a smaller compiler
02:27:22 <Saizan> i didn't know you could share memory between processes with mmap, how do you pass a reference to the mapped region from one to the other?
02:27:25 <jpcooper> passing the state back and forth won't be practical
02:27:45 <blackdog> you map the same file in both processes
02:27:55 <blackdog> you don't get complex data, just a big chunk of memory
02:28:01 <EnglishGent> blackdog - a definition... 'supercomputer n. A computer only one generation behind the user's requirements' :)
02:28:37 <blackdog> EnglishGent: heh. i'd use shapr's machine, but it's too hot for him to leave it on except in winter :)
02:29:23 <path[l]> ok
02:29:27 <mux> Saizan: IIRC, you cannot - you call mmap() first, and then you fork()
02:29:41 <EnglishGent> @hoogle Functor
02:29:41 <lambdabot> Prelude class Functor f
02:29:41 <lambdabot> Control.Monad class Functor f
02:29:41 <lambdabot> Control.Monad.Instances class Functor f
02:30:32 <blackdog> mux: i don't think that's true in C at least - if two separate processes map the same file, and you pass MAP_SHARED, the modifications should be shared.
02:30:46 <blackdog> *mmap the same file
02:30:56 <mux> blackdog: I'm talking about the case where you just want shared memory, thus memory that doesn't come from any file (MAP_ANON)
02:31:22 <mux> ie, using mmap() as some limited replacement for sysV SHM
02:31:37 <mux> (there's also the "new" shm_open() shm_unlink() POSIX API)
02:31:39 <blackdog> ah, fair enough. yeah, if you don't name it you can't get it :)
02:31:40 <etpace_> :t fmap . fmap . fmap
02:31:41 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
02:32:42 <mux> POSIX is trying to slowly take over sysV IPC (and I'm grateful)
02:34:12 <mux> they offer "new" APIs for message queues (mq_open() and friends) and semaphores (sem_open(), sem_close(), etc)
02:34:28 <mux> those don't get much use for now, unfortunately :-(
02:40:55 <artagnon> Hi. What should the type signature of this function be? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3465#a3465 (I've written what I think should be the correct one, but apparently, it isn't right)
02:42:30 <doserj> artagnon: you can just ask ghci for the type-signature (by commenting out yours)
02:43:04 <doserj> artagnon: in this case, the signature needs an Eq a constraint
02:43:07 <etpace_> It seems fine to me, perhaps a (Eq a)?
02:43:50 <artagnon> doserj: Fantastic! Thanks for that tip! :D
02:44:17 <artagnon> but isn't that an additional constraint on a?
02:44:24 <artagnon> ie. a belongs to the Eq class.
02:44:31 <etpace_> a needed one though
02:44:41 <etpace_> you cant use == if a isnt part of the Eq class
02:44:49 <artagnon> Ah, I see.
02:45:09 <artagnon> An example of an unnecessary constaint: Integral a.
02:45:29 <artagnon> It doesn't need to be Integral. It could be just about anything. Even a list of chars.
02:45:36 <artagnon> ie. a string replace function
02:45:56 <etpace_> yep
02:46:17 <artagnon> fantastic! Thanks again :)
02:46:55 <artagnon> btw, can it be written more elegantly or have I done a good job of writing it?
02:47:23 <etpace_> you can write it using a higher-order function
02:47:59 <etpace_> > map (+1) [1..5]
02:47:59 <lambdabot>   [2,3,4,5,6]
02:48:00 <pejo> What is the current recommendation for people using Snow Leopard?
02:48:12 <artagnon> etpace_: Ah, I could just map()
02:55:03 <greap> Is there an evironment variable that haskell uses to searc for libraries? It can't find opengl on my windows installation.
02:55:33 <dschoepe> artagnon: Also, if you use explicit recursion, its better to use [] as the base case, since you don't need to duplicate the comparison code.
02:56:19 <dschoepe> (plus, it'd make it a total function, which is also important)
02:56:52 <juhp> hmm
02:57:02 <juhp> isn't HUnit in ghc-6.10.x?
02:57:23 <juhp> despite what haskell-platform.cabal says?
02:59:39 <juhp> ah extras
02:59:44 <juhp> doh
03:25:03 <jaffa8> hi
03:25:12 <EnglishGent> hello :)
03:25:20 <jaffa8> I have doubt about haskell
03:25:27 <jaffa8> how useful it is.
03:25:58 <jaffa8> Are you a fan?
03:27:05 <path[l]> moving from Data.Map.fromList to foldl' of Map.insetWith gained me 10 milliseconds
03:27:11 <path[l]> but still not enough
03:29:33 <pozic> Is there a way to prove that a certain value is non-bottom at compile time?
03:33:15 <EvilTerran> sadly not; haskell's compile-time checks are all done with types, and all types have the bottom element
03:33:42 <EvilTerran> in haskell, that is. some other languages have total types (agda, coq, etc)
03:34:04 <EvilTerran> pozic, although, if you're using haskell98, you could pass it through Catch
03:34:06 <EvilTerran> ?where catch
03:34:06 <lambdabot> http://community.haskell.org/~ndm/catch/
03:34:36 <Deewiant> Also if you can get Catch to compile and work
03:35:00 <Deewiant> Which is a bit of a bigger 'if', in my experience :-P
03:39:29 <frok_> do u have some link about imperative vs functional programming? cases and proofs that the code is bugless? and correctness in general
03:39:43 <maxote> hi guys, is interesting to define the symbol _|_  as false and ^|^ as true in the side of the 0 .. 9 digit numbers? UTF-8 is a requirement for me :)
03:40:44 <maxote> instead of writing the long word FALSE & TRUE, instead of writing the letter F & T that can be used as identifiers, etc.
03:41:52 <Axman6> dons: you around? frok_ would like to know about comparisons between FP and imperative programming, and proving correctness, and i thought you might have some useful links and info...
03:42:03 <maxote> does it _|_ mean as undefined too?
03:42:39 <maxote> it's a semantic conflict of _|_, is it false or undefined?
03:44:03 <Axman6> maxote: _|_ is undefined
03:44:10 <maxote> what are the alternative symbols that can represent "undefined"?
03:44:50 <maxote> so |_| of |_|ndefined ?
03:45:07 <Axman6> i don't know of any alternatives
03:46:10 <maxote> i need _|_ (false), ^|^ (true), |_| (undefined), '--' (indiferent or don't care)
03:48:46 <maxote> '->' (implication), '<->' (equivalent, it's nxor), '¬' (negation), '<-//->' (antiequivalent, it's xor), '^' (and), 'v' (or), etc.
03:49:19 <sohum> ok, so (->) is an instance of the Arrow typeclass, right?
03:49:29 <maxote> another semantic conflict :p
03:49:43 <ski> `_|_' is supposed to look like an upside-down `T'
03:50:00 <maxote> triple _ (equivalent and not part of the formula)
03:50:06 <sohum> then why can't I go :t (->) in ghci?
03:50:28 <Axman6> sohum: it's a type
03:50:55 <ziman> not even a type, it's a type contructor
03:51:16 <Peaker> sohum: instances are types, not values, and types don't have types, so :t won't work.  But types have kinds so :k will work
03:51:23 <ziman> it has a kind, though
03:51:24 <ski> sohum : `:k (->)'
03:51:32 <Peaker> @kind (->)
03:51:33 <lambdabot> ?? -> ? -> *
03:51:40 <sohum> ...shiny
03:51:53 <sohum> that output doesn't give any information, though
03:52:04 <ski> why not ?
03:52:29 <Axman6> sohum: sure it does, it tells you everything it can about _>
03:52:31 <Axman6> ->*
03:52:37 <sohum> Axman6: how's that?
03:52:38 <hackagebot> lui 0.0.6 - Purely FunctionaL User Interface (EyalLotem)
03:52:53 <Axman6> sohum: what more information is there about ->?
03:52:53 <maxote> i want to call to ANSI committee to add 2 keys '_|_' (false) and 'T' (true) to the right of the digit numbers in the keyboard.
03:53:04 <maxote> err. to the left.
03:53:23 <sohum> Axman6: I'd expect something that tells me it's a chaining type, or such
03:53:33 <sohum> I might just not be understand kinds at all
03:53:35 <Axman6> well it's not
03:53:38 <ski> maxote : wouldn't "indifferent" be a demand rather than a value ?
03:54:13 <Peaker> never noticed that _|_ was an upside-down T :-)
03:54:32 <maxote> ski, "what demand?"
03:54:42 * Lycurgus calls that "perp" instead of bottom.
03:55:20 <etpace_> what's a ? Axman6
03:55:27 <ski> maxote : you can use "demands" to analyze strictness
03:56:07 <Axman6> etpace_: i believe it's a kind... but i'm no expert
03:56:15 <ski> maxote : if you don't use a value, that's a "demand" (and i thought that was what you wanted "indifferent" to be)
03:56:41 <maxote> ohh, it's another conflict,  _|_ (false vs undefined),  '--' (indifferent or don't care vs demand (to analyze strictness))
03:56:54 <ski> if you use a list, either it is empty, or it is non-empty, in which case the demand contains two-subdemands (one for the head, and one for the tail)
03:57:10 <maxote>  '-->' (implication vs arrow)
03:57:44 <ski> maxote : i was just guessing you meant "indifferent" as in "i don't care what the value is (because i won't use it)"
03:57:55 <ski> maybe that guess was not correct
03:58:03 <path[l]> ok I have managed to get my code to speed up 60% ... at the cost of having a function with 3 nested wheres
03:58:05 <path[l]> lol;
03:58:31 <maxote> ski, oh, yes indifferent is not same that don't care, sorry.
03:58:45 <Axman6> path[l]: yeah... that's not good ;)
03:59:31 <ski> but if you want a fourth value added to "undefined","false","true", i'd try adding "overdefined" (i.e. "both true and false")
03:59:40 <maxote> i hate drawing same symbols representing different concepts
04:02:08 <pozic> maxote: is 1.0 + 2.0 != 1 + 2?
04:02:49 <mjrosenb> pozic: well the types may be different
04:03:06 <maxote> pozic, in math, it's true. In computer, it maybe either true or false.
04:03:20 <pozic> mjrosenb: I was merely pointing out that what constitutes a concept is a personal thing.
04:03:24 <iabal> pozic: is 1.0 + 2.0 != 1.0 + 2.0 ?
04:04:32 <maxote> unless that you specify (1.0+-epsilon) + (2.0+-epsilon) != 1+2
04:04:33 <ski> maxote : i'd say it's either true, or a meaningless question
04:04:46 <ski> (ignoring any floating-point errors)
04:05:00 <iabal> 1 -> fromInteger 1, 2 -> fromInteger 2 ...
04:05:36 <iabal> s/!=//= :P
04:06:13 * mjrosenb thinks that == and != should not be defined on floating point values
04:06:45 <iabal> mjrosenb: why not
04:06:59 <iabal> the meaning of == is opened
04:07:07 <iabal> just an equivalence relation
04:08:04 <ski> the aritmetical operations doesn't respect the equivalence relation, i think
04:08:12 <mjrosenb> correct
04:08:28 <mjrosenb> so things that you want to be true are not
04:08:32 <mjrosenb> like associativity
04:08:47 <mjrosenb> i think that associativity should have a higher precedence than equality
04:08:49 <mmorrow> (==) is an equivalence relation nonetheless
04:09:38 <ski> i was thinking of properties like `forall a0 a1 b0 b1. a0 == a1 /\ b0 == b1 -> a0 + b0 = a1 + b1'
04:09:39 <dolio> They don't jive very well with (<) and such, either.
04:10:16 <ski> mjrosenb : not precedence in the syntactic operator sense, right ?
04:10:17 <mmorrow> @check \x -> x == (x+pi)-(pi::Double)
04:10:18 <lambdabot>   "Falsifiable, after 4 tests:\n0.33333333333333337\n"
04:10:49 <iabal> ski: uhmm well, you could define == to consider epsilon
04:10:51 <mjrosenb> ski: like (a+b)+c /= a+(b+c) will sometimes return true
04:11:07 <dolio> > let x = 1e-40 ; y = 1e-50 in (y < x, 1 + y < 1 + x)
04:11:08 <lambdabot>   (True,False)
04:11:39 <mjrosenb> > let x = 1e-40 ; y = 1e-50 in (y <= x, 1 + y <= 1 + x)
04:11:40 <lambdabot>   (True,True)
04:11:50 <ski> mjrosenb : i just don't see what "associativity" (the property) has to do with "precedence" (like the `5' in `infixl 5 +')
04:12:02 <ski> iabal : consider, how ?
04:12:30 <mjrosenb> ski: when i said precedence, i meant where precedence should be put in deciding which operations should be defined on floating point numbers
04:12:55 <idnar> why does (==) need to be associative?
04:13:03 <mjrosenb> iabal: that sounds horribly painful and will actually break the equivalence relationship
04:13:04 <idnar> er wait
04:13:07 <idnar> that's not even what I mean
04:13:16 <ski> mjrosenb : i still don't understand what you mean ..
04:13:19 <mjrosenb> iabal: (==) does not need to be, (+) should be
04:13:26 <ski> ("where precedence should be put" means ?)
04:13:38 <idnar> why does (+) need to be associative?
04:14:17 <ski> idnar : because that's what we want in rings ?
04:14:19 <mjrosenb> ski: i would preffer that (+) be somewhat associative over (==) being defined on floating point values
04:14:51 <pejo> idnar, because the optimizer assumes that property of +.
04:14:54 <ski> .. oh, you were expressing a preference
04:15:09 <idnar> ski: (+) isn't in the Ring type class, though :P
04:15:23 <ski> idnar : granted
04:15:25 <iabal> ski: a == b = abs (a-b) < eps
04:15:49 <ski> iabal : but then `(==)' need not be transitive
04:16:14 <ski> (and hence it need not form an equivalence relation)
04:16:14 <iabal> ski: Num definition saids that the type is a Ring ?
04:17:03 <ski> iabal : i'm not sure if there's any laws expressed in the report for `Num', but yes, i'd expect ring structure
04:18:33 * mjrosenb is willing to argue "because it is what people expect"
04:19:03 <iabal> In Prelude doc I only see the following law for Num: abs x * signum x == x
04:20:33 <iabal> I would like to see a good number hierarchy... but perhaps will be a mess for most people to do a Num instance
04:20:36 <ski> mjrosenb : you want to allow quaternions and octonions as instances of `Num' ?
04:20:58 <mmorrow> (==) on floating point w/ eps is more like seeing if two open sets have non-empty intersection than it's like (==) for some members of a set
04:21:55 <mmorrow> i.e. you don't care if their equal, you only care if the eps-neighborhoods about each point intersect
04:22:01 <mmorrow> s/their/they're/
04:22:03 <EvilTerran> i think most people want a better number heirarchy, it's just we can't agree on what exactly
04:22:46 <iabal> "It is needed" some mechanism like class aliases so... for common cases
04:23:18 <iabal> if you generalize a lot you will need to replace a Num instance with many other instances
04:24:42 <dolio> Num has some obvious flaws that could be fixed without redoing the entire hierarchy, at least.
04:24:49 <dolio> Like removing Eq and Show as prerequisites.
04:25:34 <dolio> But that can't happen until a new standard is released, at least.
04:26:11 <dolio> Or until Cale gets around to forking base.
04:29:02 <mmorrow> dolio: ooh. base forks are a good idea.
04:30:58 <dolio> I don't know about that.
04:31:58 <dolio> At least, with the current module/package/whatever system, it'd be a potential headache.
04:35:42 <mmorrow> dolio: given how haskell looks upon global vars, i find it odd that the module/package/whatever is essentially just a big global variable at the moment ;)
04:36:48 <dolio> It's a conundrum.
04:37:17 <mmorrow> conundrum is a great word
04:37:48 <EvilTerran> mmorrow, instances, likewise
04:40:26 <mmorrow> global vars!
04:40:37 <EnglishGent> does Haskell have a bidirectional map type? i.e. one where both keys & values have to implement Eq, so that you can do lookup in both directions?
04:40:53 <mmorrow> EnglishGent: you can make one easy enough
04:41:29 <EnglishGent> I can see how to do it mmorrow - I just dont want to reinvent the wheel if it's already there :)
04:42:04 <dolio> I think there's something on hackage that does it, but it's not particularly fancy.
04:42:09 <mmorrow> EnglishGent: well, the language Haskell doesn't have even Maps, but hackage actually does have a bimap pkg now i think about it (iirc)
04:42:18 <dolio> Just two maps wrapped up into one type.
04:42:21 <EnglishGent> there's Data.Map
04:42:30 <mmorrow> EnglishGent: that's not part of Haskell
04:42:39 <EnglishGent> oh - I thought it was a standard library
04:43:04 * EnglishGent imported it without any problems :)
04:43:22 <mmorrow> the only "standard" modules are Prelude,List,Char,some others
04:43:49 <dolio> The officially standard library is so old that most people don't use it anymore.
04:44:01 <dolio> Except Prelude.
04:44:06 <dolio> And Numeric.
04:44:10 <benmachine> are the contents of List equivalent to Data.List?
04:44:12 <mmorrow> ah, Numeric
04:44:18 <dolio> Although, Numeric isn't very common, really.
04:44:28 <EvilTerran> benmachine, Data.List has the contents of List, plus some other useful stuff
04:44:48 <etpace_> People were discussing yesterday about prettyprinting \x -> as lambda x ->, is there a way to have vim to display lambda as opposed to \, while leaving the source intact?
04:45:01 <mmorrow> :o
04:45:03 <benmachine> etpace_: presume you mean Î»?
04:45:25 <benmachine> rather than actually the word lambda like python does it
04:45:34 <etpace_> yeah
04:45:49 <EvilTerran> that's... probably possible
04:45:51 <burp> uh, nice idea
04:46:00 <EvilTerran> i believe someone's done it for emacs
04:46:02 <dolio> Replacing one character with a six letter word obviously wouldn't be "pretty". :)
04:46:10 * mmorrow thought you meant the word "lambda" and almost had a stroke
04:46:11 <mmorrow> :)
04:46:40 <etpace_> heh
04:47:09 <benmachine> I've heard of it being done for emacs yes, I presume it could be done for vim but I lack the expertise necessary
04:49:17 <EnglishGent> how do I tell GHCi that I dont want to use a module any longer? (imported one - want to throw it away without restarting GHCi & importing the rest from scratch)
04:49:21 <yitz> I've dreamed of prettyprinting haskell in a proportional font - indents lined up, guards a continuous vertical bar, etc.
04:49:36 <yitz> EnglishGent: :m -Module
04:49:41 * EnglishGent tried :m- Data.Map & :-m Data.Map -- but jiust got errors :|
04:49:45 <earthy> benmachine: the only way to do it currently is to run a filter over the source when reading and writing that translates from \ to Î»
04:49:50 <EnglishGent> ty yitz :)
04:50:11 <Twey> yitz: It just involves lots of tabs, doesn't it?
04:50:29 <burp> cpp preprocessor
04:50:45 <burp> and you type Î» instead
04:50:46 <yitz> Twey: I was thinking actualy formatting
04:50:48 <EvilTerran> #define Î» \
04:50:48 <EnglishGent> hi Twey :)
04:50:49 <EvilTerran> :P
04:50:55 <Twey> Hi there, EnglishGent
04:51:02 <burp> EvilTerran: yup :D
04:51:02 <benmachine> EvilTerran: in Î»x I don't think Î» is a token
04:51:11 <EvilTerran> benmachine, i know, it's not =/
04:51:14 <Twey> yitz: How would you do that?
04:51:49 * EnglishGent thinks he's actually beginning to get to grips with this language - there's still a lot I dont understand .. but I now have version 2 of a program do something *useful* working :)
04:51:56 <benmachine> Twey: in a dream, evidently
04:52:02 <yitz> Twey: 1. choose a rendering engine. 2. prettyprint haskell to its markup
04:52:04 <EvilTerran> Twey, i'm guessing by doing something cunning/evil with vim syntax/highlighting files
04:52:10 <sohum> etpace_: displaying something as other than what it is on the file is not possible in vim - it's actually this issue that got me to move to emacs ;)
04:52:25 * EnglishGent wishes emacs was written in Haskell
04:52:34 <ziman> etpace_, i have a vim syntax file, derived from edwardk's
04:52:34 <vegai> EnglishGent: check out yi
04:52:35 <EnglishGent> it's my editor of choice -- but elisp is .. kinda old
04:52:53 * EvilTerran read that as "kinda odd" the first time :P
04:53:04 <vegai> http://www.haskell.org/haskellwiki/Yi
04:53:13 <vegai> it's rather neat... sadly not very complete yet
04:53:14 <ziman> etpace_, it replaces most fancy characters (â†’, â‡’, âˆ˜, Î», ...) while displaying but saves them in ASCII
04:53:14 <EnglishGent> oh - interesting! ty vegai :)
04:53:26 <pejo> vegai, there's still a couple of things missing from Yi.
04:54:45 <etpace_> do you have a link ziman?
04:55:36 <altmattr> i noticed yi was high on the hackage popularity list
04:55:47 <altmattr> are people using it for programming?
04:56:04 <CalJohn> EnglishGent: I'm kind of glad it's not, emac's benefits quite a lot from being written in a dynamic language, though I agree that the particular dynamic language is not that good
04:56:15 <CalJohn> s/emac's/emacs
04:56:30 <pejo> CalJohn, what is a dynamic language?
04:56:32 <altmattr> and haskell-src-exts was high as well!? I use it and l love it but how many prople need a haskell parser?
04:57:04 <int-e> it's used by derive
04:57:10 <EvilTerran> everyone writing preprocessors and other such funky things
04:57:16 <int-e> which is fairly popular
04:57:25 <EvilTerran> (or using)
04:57:26 <CalJohn> pejo: I suppose I mean "runtime typing"
04:57:28 <ziman> etpace_, http://ziman.functor.sk/files/haskell.vim
04:57:30 <pejo> altmattr, and used by HLint
04:57:50 <EvilTerran> CalJohn, Data.Dynamic? :P
04:58:00 <altmattr> is that why it is getting so many downloads?
04:58:12 <CalJohn> but what I really mean is that emacs benefits from being able to load code while it is running, which AFAIK haskell is unable to do
04:58:16 <ziman> etpace_, actually, i made just minor modifications to it (more fancy chars, don't replace \n with Î»n etc.)
04:58:26 <EnglishGent> can someone please look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8876#a8876 & explain?
04:58:30 <etpace_> thanks
04:58:40 <vegai> CalJohn: xmonad already does something that's quite close to that
04:58:48 <vegai> CalJohn: I think yi uses the same reloading technique
04:58:53 <EnglishGent> that's some code I thought should _fail_ to type check - but it passes! (took me a while to notice the bug!)
04:58:55 <int-e> and then there's the question of how many of those downloads were updates of the package.
04:59:00 <EvilTerran> CalJohn, you can do that with ghc-api
04:59:14 <EvilTerran> CalJohn, unfortunately, i think it involves statically linking your program with large chunks of ghc
04:59:38 <CalJohn> that is interesting, EvilTerran, vegai
04:59:41 <EnglishGent> why do you think that CalJohn? (serious question)
04:59:48 * EnglishGent interested in your view :)
04:59:49 <benmachine> EnglishGent: lists are monads
04:59:54 <hackagebot> hlint 1.6.7 - Source code suggestions (NeilMitchell)
04:59:57 <ziman> etpace_, it's not perfect but works okay most of the time
05:00:30 <CalJohn> the one of the biggest advantages of emacs is that you are able to change it while it is running (ie: without a recompile)
05:00:31 <etpace_> better than the ugly \!
05:00:41 <EvilTerran> ndm++ lots of useful stuff on hackage
05:00:53 <CalJohn> loading more elisp into the repl is one of the #1 selling points of emacs
05:00:53 <vegai> xmonad gets rebuilt and restarted in a couple of seconds
05:00:56 <altmattr> EnglishGent: lists can be monads
05:00:59 <vegai> which admittedly is a bit worse than 0 seconds
05:01:13 <vegai> emacs is cool, no question
05:01:32 <CalJohn> though, actually, adding static typing would be nice, so long as you could change the typing without stopping, which sort of defeats the point
05:01:34 <altmattr> EnglishGent: so there is no clash between using it as a list and a mondad
05:01:39 <EnglishGent> then why does (map reverse (getDirectoryContents ".")) fail to type check? (given that lists are monads?)
05:02:00 <int-e> EnglishGent: because IO and lists are different monads
05:02:19 * EnglishGent just wanted a function (a -> b) -> IO [a] -> IO [b]
05:02:20 <EnglishGent> :)
05:02:32 <benmachine> @type ap
05:02:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:02:37 <benmachine> er
05:02:41 <benmachine> that's not quite it
05:02:42 <int-e> @type fmap . map
05:02:44 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> b) -> f [a] -> f [b]
05:02:51 <benmachine> oh
05:02:52 <int-e> @type liftM . map
05:02:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
05:03:09 <altmattr> @type mapM
05:03:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:03:52 <EnglishGent> no - fmap doesnt do what you want there... I tried it
05:04:19 <EnglishGent> fmap reverse (getDirectoryContents ".") - reverses the list of directory contents, not the values inside it
05:04:32 <benmachine> fmap (map reverse)
05:04:34 <Saizan> fmap (map reverse)
05:04:37 <int-e> EnglishGent: fmap (map reverse) (getDirectoryContents ".")
05:04:40 <EnglishGent> whereas map reverse <cut & paste the result of (getDirectoryContents ".") does
05:04:49 <Saizan> you've to use both!
05:04:52 <int-e> @quote fugue
05:04:52 <ski> EnglishGent : `liftM . map' as int-e said
05:04:53 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
05:05:12 <Saizan> fmap to get through the IO layer, map for the [] one
05:05:15 <EnglishGent> that's why I wrote iomap - which does what I expected :)
05:05:17 <int-e> fmap . fmap, if you want to be as generic as possible.
05:05:20 <Saizan> you can actually use fmap for both
05:05:28 <EnglishGent> though - given what people have said I can now write it more elegantly :D
05:05:39 <Saizan> (fmap . fmap) reverse (getDirectoryContents ".")
05:06:13 <int-e> or ... as some people would have it ... fmap fmap fmap
05:06:25 <EnglishGent> fmap^n :)
05:07:02 <int-e> @type fmap fmap fmap reverse
05:07:04 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a. (Functor f, Functor f1) => f (f1 [a]) -> f (f1 [a])
05:12:18 <EnglishGent> ah! I think what I've been looking for is liftM & liftM2
05:13:03 <benmachine> liftM is like fmap except for monads instead of functors
05:13:23 <benmachine> which is odd because all the monads I know are functors anyway
05:13:29 <EnglishGent> I've learn enough I can write code using the IO monad now - but it still looks clumsy, I have to name far too many intermediate variables & I was sure there was a better way :)
05:14:43 <pejo> EnglishGent, hlint is quite good at giving suggestions on how to make code more readable
05:16:18 <chessguy_work> so i've been playing with something kind of interesting for tree search algorithms: type TreeTraversal a = State (TreeLoc a)
05:16:34 <chessguy_work> where TreeLoc is a zipper over a rose tree
05:16:51 <EnglishGent> oh - I didnt know there was a hlint
05:16:54 <EnglishGent> ty :)
05:18:59 <hackagebot> serialport 0.1.0 - Cross platform serial port library. (JorisPutcuyps)
05:20:50 <jethr0> is there a cross-platform way of 'sleep'ing for n seconds/milliseconds?
05:21:41 <Saizan> jethr0: threadDelay
05:22:19 <jethr0> does that work even when i'm not using threads?
05:22:33 <jethr0> explicitely, that is
05:23:36 <Lemmih> There's always a main thread.
05:24:02 <benmachine> in other words, yes
05:24:04 <jethr0> k, thx. how about getting the current time?
05:24:49 <pragma_> The time is 9:24
05:25:10 <Lemmih> No no, it's 14:24.
05:25:22 <EnglishGent> how do I restrict a data definiton? something like data BiMap = BiMap [(a,b)] -- I want to restrict a & b to being instances of Eq
05:25:56 <Deewiant> Typically, you don't; just restrict the functions that use BiMap as needed
05:26:06 <Lemmih> EnglishGent: someFunction :: (Eq a, Eq b) => BiMap a b -> ...
05:26:15 <jethr0> no, it's 8:26pm ;)
05:26:25 <Deewiant> You can't restrict BiMap directly, what you can do is make a mkBiMap function and restrict that (and not export the constructor, forcing everyone to use mkBiMap)
05:26:36 <jethr0> i'll try Sytem.Time.getClockTime
05:26:37 <EnglishGent> ah ok :)
05:26:48 <EnglishGent> ty again :)
05:28:01 <Ytinasni> data (Eq a, Eq b) => BiMap a b = BiMap [(a,b)]
05:28:39 <jethr0> grr, can't seem to get milliseconds out of Data.System.ClockTime
05:29:51 <chessguy_work> EnglishGent, what is a BiMap ?
05:29:51 <Lemmih> jethr0: It can give you pico seconds, can't it?
05:30:26 <EnglishGent> chessguy_work - a map that allows lookup in both directions - so you can give a key & get a value, or give a value & get a key
05:30:40 <chessguy_work> EnglishGent, you know that's been done right?
05:30:46 <jethr0> yes, in System.CPUTime. rather a bit more precise than I need, but oh well.
05:31:02 <EnglishGent> where chessguy_work?
05:31:05 <Lemmih> jethr0: System.Time can as well.
05:31:19 <jethr0> huh? let me look again
05:31:22 <chessguy_work> http://hackage.haskell.org/package/bimap
05:31:26 <chessguy_work> EnglishGent, ^^
05:32:01 <EnglishGent> ah! ty! :)
05:32:14 <jethr0> it say "In Haskell 98 ClockTime is abstract". does that imply that in GHC it is not, and thus I can extract the seconds?
05:32:32 <Lemmih> jethr0: fmap (ctPicosec . toUTCTime) getClockTime
05:33:05 <jethr0> thx
05:33:23 <Lemmih> jethr0: Yes.
05:33:50 <Lemmih> jethr0: TOD secs picosecs <- getClockTime.
05:34:55 <jethr0> seems a bit cludgy still, but i sincerely thank you ^_^
05:36:01 <Lemmih> jethr0: Data.Time tends to be prettier.
05:36:48 <jethr0> would you think that windows and MacOS would count as posix? or rather MinGW and MacOS?
05:52:52 <Adamant> jethr0: POSIX for Windows exists (UFW), and MacOSX is UNIX-certified so it's definitely POSIX
05:55:04 <pejo> jethr0, Windows without additions is surprisingly posix compliant.
06:02:36 <jethr0> i was wondering wrt time. i.e. whether i can use the haskell posix time functions under MinGW and MacOS...
06:03:24 <Axman6> jethr0: OS X is a unix operating system, it is _fully_ POSIX complient
06:03:42 <jethr0> k
06:14:22 <pozic> pejo: is there a list which states exactly how compliant Windows is?
06:14:39 <chessguy_work> ok, so i feel like i'm missing a higher-level abstraction in this library that i'm writing. maybe Traversable or something
06:14:40 <dibblego> yes, []
06:14:42 <dibblego> :)
06:14:55 * chessguy_work giggles at dibblego 
06:15:39 <fasta> How long did it take you to see that passing types in functions might be nice?
06:15:42 <chessguy_work> i've got a type, TreeTraversal a b, which represents a traversal over a "Tree a", resulting in something of type b
06:16:26 <chessguy_work> and there are all kinds of fun things you can do, like write an identity traversal that doesn't do anything
06:16:43 <chessguy_work> write a traversal which simply returns the rootLabel of the current node
06:16:58 <chessguy_work> write a function which takes a traversal and a tree and returns the resulting path
06:17:10 <chessguy_work> write a function that combines 2 traversals, etc.
06:17:30 <chessguy_work> but i feel like i'm re-writing stuff that i should be getting for free somehow
06:19:46 <chessguy_work> maybe i just need to be writing/looking-at type instances
06:19:51 <chessguy_work> *typeclass
06:20:48 <fasta> chessguy_work: Haskell/GHC has a broken meta-programming system and generics also are not as easy to do as in a Lisp like language. You just don't get lots of stuff for free, which, I agree, is simple in principle.
06:21:35 <chessguy_work> so you're saying i should do my project in a lisp? :)
06:22:29 <fasta> chessguy_work: I don't know. There are advantages to Haskell and there are disadvantages. I haven't done a very big project in Scheme, so I don't know how to compare.
06:23:00 <fasta> chessguy_work: It is certainly possible to build fairly large systems in Haskell, but I think Texas Instruments also built big stuff in Scheme.
06:23:38 <Woof> Twey!~
06:23:49 <Twey> Woof!~
06:24:02 <pejo> pozic, I'm not sure, but the salesmaterial for NT 3.51 bragged about improved POSIX compliance iirc.
06:24:33 <Woof> Twey: Why have you abandoned the other channel? : (
06:24:40 <Twey> Which?
06:24:54 <pozic> pejo: I would be fairly sure that, since it doesn't have a lot of users, it probably doesn't work.
06:25:13 <Woof> Twey: The one where you can learn any computer language
06:25:19 <pozic> pejo: people that want POSIX don't use Windows, and people that don't want POSIX, use Windows.
06:25:40 <chessguy_work> #rosettacode?
06:25:40 <pozic> pejo: and sales material always brags.
06:26:03 <Woof> Lol chessguy_work. No, #learnanycomputerlanguage : P
06:26:18 <chessguy_work> oh. aptly-naped
06:26:20 <Twey> Oh, that one â€” I never got around to doing woot4moo's whatever it was, and therefore stopped posting on CodeGreen, and therefore stopped attending #codegreen and #learnanycomputerlanguage :Ã¾
06:26:22 <chessguy_work> *named
06:26:24 <Twey> Haha.
06:27:05 <Woof> Well CodeGreen is sorta going through a dead phase, but #learnanycomputerlanguage is alive and well. Except we miss you there
06:27:33 <chessguy_work> spending a year dead for tax purposes?
06:28:02 <pejo> pozic, apparently Windows NT-based operating systems up to Windows 2000 had a posix  layer built into the system. For XP you need Windows SErvices for Unix to get the posix compliance apparently.
06:28:10 <Woof> Perhaps. It died when nebopolis went missing, I think
06:28:45 <Woof> Thankfully the other channel didn't die when I went missing. But maybe it made Twey and chturne leave : (
06:29:53 <Twey> chessguy_work: Hahaha
06:30:36 <chessguy_work> i was hoping someone would get the reference...
06:31:04 <Woof> Like that, eh? What's the reference then?
06:31:21 <benmachine> restauraunt at the end of the universe?
06:31:25 <chessguy_work> bingo
06:31:35 <Woof> Ah
06:32:23 <benmachine> it always puzzled me why people called it h2g2, a saving of exactly zero characters over hhgg
06:32:40 <chessguy_work> lol
06:32:46 <chessguy_work> i never heard that
06:33:29 <Woof> Maybe they think it sounds better?
06:33:33 <benmachine> possibly
06:33:42 <chessguy_work> of course they'd be wrong...
06:33:47 <Woof> Like when you say "five double-two four" instead of "five two two four"
06:34:14 <Twey> benmachine: But â€˜hhggâ€™ looks silly
06:34:19 <Deewiant> hhgttg
06:34:20 <Twey> Like someone choking
06:34:34 <benmachine> Twey: and is thus entirely wrong for such a serious publication
06:34:52 <benmachine> ...okay I suppose you have a point
06:34:53 <Twey> Quite.
06:34:55 <Twey> :Ã¾
06:35:52 <Twey> â€˜Hello John, what are you doing today?â€™ â€˜Hhgg!â€™ [Translation note: â€˜There is a boa constrictor wrapped around my neck!  Please render aid!â€™]
06:36:28 * benmachine giggles
06:36:53 <ray> haskell
06:37:01 <Twey> Haskell haskell.
06:37:16 <benmachine> haaaas
06:37:18 <benmachine> kell.
06:37:33 <Axman6> kell hÃ¤s!
06:37:50 <ray> i accidentally the whole terminal object
06:37:58 <PeakerWork> > cycle "haskell "
06:37:59 <lambdabot>   "haskell haskell haskell haskell haskell haskell haskell haskell haskell ha...
06:38:04 <ray> is this dangerous?
06:40:13 <Woof> Mushroom mushroom!
06:42:51 <ray> type, it's a type, oooooooh, it's a type
06:43:04 <PeakerWork> @let chant = cycle . (' ':)
06:43:05 <lambdabot>  Defined.
06:43:09 <PeakerWork> > chant "Haskell"
06:43:10 <lambdabot>   " Haskell Haskell Haskell Haskell Haskell Haskell Haskell Haskell Haskell H...
06:45:22 <ray> drop 1 .
06:46:10 <int-e> unwords . repeat
06:46:54 <int-e> the cycle version is more memory efficient though.
06:48:34 <hackagebot> serialport 0.1.0.1 - Cross platform serial port library. (JorisPutcuyps)
06:55:02 <yitz> > fix chant
06:55:03 <lambdabot>   "                                                                          ...
06:55:17 <yitz> really need that drop 1 .
06:55:33 <yitz> > fix $ drop 1 . chant
06:55:38 <lambdabot>   mueval-core: Prelude.read: no parse
06:55:38 <lambdabot>  mueval: ExitFailure 1
06:56:12 <yitz> @type drop 1 . chant
06:56:14 <lambdabot> [Char] -> [Char]
06:56:45 <yitz> > drop 1 . chant $ "Yay, Peaker!"
06:56:46 <lambdabot>   "Yay, Peaker! Yay, Peaker! Yay, Peaker! Yay, Peaker! Yay, Peaker! Yay, Peak...
06:57:02 <yitz> > fix $ drop 1 . chant
06:57:08 <lambdabot>   mueval-core: Prelude.read: no parse
06:57:08 <lambdabot>  mueval: ExitFailure 1
06:57:31 <Lemmih> > fix id
06:57:37 <lambdabot>   mueval-core: Prelude.read: no parse
06:57:37 <lambdabot>  mueval: ExitFailure 1
06:57:48 <yitz> oh, that's \bot choking, I see.
06:58:13 <benmachine> it's mueval being too slow I think
06:58:16 <benmachine> or
06:58:17 <benmachine> something.
06:58:32 <yitz> or getting a headache
07:01:50 <rsalmin> Hi
07:02:05 <benmachine> hi
07:03:28 <rsalmin> I see a strange behavior in ghci 6.10.3 which I don't understand could it be a bug? see below
07:03:53 <Botje> floor?
07:04:20 <rsalmin> 1Main> a <- newEmptyVar 2Main> querryMVar a
07:05:01 <Botje> rsalmin: can you put your problem into a pastebin instead?
07:05:01 <rsalmin> it returns nothing  - literally, instead of Nothing
07:05:04 <Botje> lambdabot: paste
07:05:07 <Botje> argh :)
07:05:12 <benmachine> @where paste
07:05:13 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
07:05:19 <Botje> ah, that was it. benmachine++
07:06:32 <rsalmin> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3466#a3466
07:06:44 <benmachine> what's querryMVar
07:07:02 <benmachine> (apart from badly spelt :P)
07:07:26 <fasta> rsalmin: when people ask for a paste, they mean something which can be run with zero work.
07:08:36 <rsalmin> querryMVar is just tryTakeMVar, sorry
07:09:09 <benmachine> rsalmin: hm, that is odd
07:09:20 <rsalmin> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3466#a3467
07:09:27 <rsalmin> here is corrected version
07:09:30 <int-e> no, it's not; there is no Show instance for MVar Any.
07:09:44 <benmachine> int-e: so why doesn't it whine that there is no Show instance?
07:09:50 <int-e> a <- newEmptyMVar :: IO (MVar ())
07:09:55 <benmachine> (itym Maybe Any)
07:10:00 <int-e> tryTakeMVar a ===> prints Nothing
07:10:12 <int-e> benmachine: yes I did, thanks
07:10:48 <int-e> (but why doesn't ghci default that to () as it usually does?)
07:10:53 <fasta> Which version of 6.10 is used on Hackage?
07:10:59 <lvh> Does anyone know of any good distributed computing packages for Haskell, similar to Erlang's remote processes?
07:11:07 <rsalmin> I use 6.10.3
07:11:38 <benmachine> MVars behave a little strangely in ghci
07:12:15 <benmachine> probably best to explicitly type-annotate them
07:12:31 <benmachine> rsalmin: ghci suppresses printing of boring results
07:12:48 <benmachine> which is why putStrLn, for example, doesn't print the () that it returns
07:12:58 <Deewiant> I think it only suppresses IO ()
07:13:45 <rsalmin> print () -- prints ()
07:14:10 <Botje> instead of () ()
07:14:11 <Botje> :)
07:14:14 <benmachine> yeah
07:14:14 <EnglishGent> hello again :)
07:14:22 <EnglishGent> @hoogle StdGen
07:14:22 <lambdabot> System.Random data StdGen
07:14:22 <lambdabot> System.Random getStdGen :: IO StdGen
07:14:22 <lambdabot> System.Random mkStdGen :: Int -> StdGen
07:14:25 <rsalmin> so it is feature ?
07:14:34 <benmachine> rsalmin: I'm not quite sure what is happening
07:14:55 <benmachine> it's difficult because I can't fill an MVar Any
07:15:13 <Botje> fill it with _|_ !
07:15:17 <benmachine> ah yes
07:15:21 <benmachine> that works
07:15:48 <benmachine> tryTakeMVar still doesn't print anything
07:15:53 <rsalmin> yes
07:16:04 <benmachine> nor does takeMVar, indeed
07:16:26 <sohum> haskell's duplicate instance detection is kinda weird. Does it mean that I can't have three typeclasses such that A a => B a and C a => B a?
07:16:54 <benmachine> rsalmin: I recommend forcing the type of the MVar, either with newMVar value or with :: MVar Type
07:17:28 <benmachine> sohum: I think so, because you don't know what to do if something is an instance of A and C
07:18:21 <sohum> benmachine: isn't that just the old multiple inheritance problem, which was "solved" for some definition of solved in things like CLOS?
07:18:43 <benmachine> sohum: sounds like you know more about it than I do
07:19:46 <rsalmin> benmachine: Thank you. So the explanation is that it is how show Any works?
07:20:34 <benmachine> rsalmin: I don't have a complete explanation, but that would be my guess
07:20:44 <benmachine> well
07:20:49 <benmachine> more that it's how ghci handles Anys
07:20:56 <benmachine> which can't be shown
07:20:57 <EnglishGent> @hoogle State
07:20:57 <lambdabot> module Control.Monad.State
07:20:57 <lambdabot> Test.HUnit.Base data State
07:20:57 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
07:21:16 <sohum> benmachine: what I'd expect, is that if I was using a B function in a context that constrains on A, then it'd use the A a => B a definition, and symmetrically.
07:21:33 <sohum> benmachine: if there's a context that constrains both, then force the coder to specify
07:22:12 <amgarching> hi, where is cabal in debian lenny? How do I install it?
07:23:12 <rsalmin> thank you again
07:23:53 <fasta> amgarching: I don't think it is packaged.
07:24:14 <sohum> amgarching: I believe there was a cabal-debian package, which has been removed until they figure out how to properly deal with it. in the meantime, you can just install it from source - it won't muck up anything if you have it install locally
07:24:20 <fasta> amgarching: I don't know what the current optimal way to install it, but a way is to install ghc and install the dependencies by hand.
07:24:40 <fasta> amgarching: where "hand" can also be to use some bootstrap script, which might or might not work.
07:25:14 <sohum> amgarching: http://www.haskell.org/haskellwiki/Cabal-Install#Unix
07:25:23 <sohum> amgarching: with specific package names for debian systems
07:25:35 <sw17ch> any one know why the StdLib docs on haskell.org seem broken?
07:25:44 <sw17ch> missing Network and STM, among other things
07:26:13 <amgarching> fasta, sohum: thanks, I'll try from the sources
07:26:52 <sw17ch> did the stm and network packages get moved out of the stdlibs?
07:27:27 <path[l]_> hi
07:29:41 <EnglishGent> hello path[l]
07:31:19 <rsalmin> benmachine: No. It is all wrong.
07:32:19 <rsalmin> benmachine: I create Empty MVar by newEmptyMVar, then independently of it type tryTakeMVar must return Nothing
07:33:21 <rsalmin> benmachine: Is'n it?
07:34:33 --- mode: ChanServ set +b *!*@*.prtelecom.hu
07:34:33 --- kick: xoclipse was kicked by ChanServ (Banned: spammer)
07:35:36 <benmachine> rsalmin: it returns Nothing :: Maybe Any though I think, and I don't think that can be shown
07:35:57 <benmachine> (because Maybe a only has a show if a does)
07:38:06 <benmachine> rsalmin: I'm kind of guessing though
07:42:34 <rsalmin> benmachine: Ok. But Indeed why then not to report error? if I type a I will have No intance for (Show (MVar GHC.Prim.Any)) then for Maybe Any I expect the similar report
07:43:57 <EnglishGent> okay... now I'm more confused (though hopefully greater depth of understanding will follow)
07:44:03 <Saizan> rsalmin: if you see an "Any" you're most likely doing something wrong or found a ghc bug
07:44:03 * EnglishGent reading about monads
07:44:23 <EnglishGent> I'd figured out the IO monad ... but until I now I'd been assuming that *all* monads were one way monads
07:44:37 <blueonyx> hi, is it possible to instance some type with no type variables into a type class with 2 type variables (like Graph from fgl)?
07:44:46 * EnglishGent trying to figure out the state monad :)
07:45:02 <jfoutz> EnglishGent: have you read the typeclassopedia?
07:45:24 <Saizan> blueonyx: no
07:45:36 <jfoutz> @where typeclassopedia
07:45:36 <lambdabot> Byorgey's Typeclassopedia in <http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf>
07:45:52 <Saizan> blueonyx: but you can create a type like newtype Wrapper a b = Wrapper YourType
07:45:52 <fasta> blueonyx: "instance some type"?
07:45:57 <EnglishGent> jfoutz - no
07:46:00 <EnglishGent> ty :)
07:46:33 <jfoutz> EnglishGent: it's a bit of a tangent from the state monad. I think it's a way better place to start though.
07:46:40 * EnglishGent has come across it - but not read it properly (I was a *total* haskell newbie when it was first mentioned)
07:46:51 <EnglishGent> at least now I can write small utilities in it :)
07:46:55 <jfoutz> :)
07:47:33 <blueonyx> fasta: i got a type S which contains a (Graph SomeType SomeOtherType), now i want to "instance Graph S"
07:47:49 <fasta> EnglishGent: if you say something is just a monad, then that's the case. If you have more information, then you can so so (like with Maybe)
07:48:00 <jfoutz> EnglishGent: monad makes far more sense when given that context. It's just a thing, that has some properties that follow some rules. More rules than some things, less rules than others.
07:48:42 <blueonyx> Saizan: where is a and b on the right? O.o
07:48:43 <fasta> blueonyx: you have to define method by method what needs to happen in the type class. There is no derive Graph, AFAIK.
07:48:58 <rsalmin> well, where do you recommend to ask about this problem?
07:49:29 <rsalmin> some can try it on ghc 6.10.4 if it bug may be it's fixed?
07:49:47 <blueonyx> fasta: yea, but my problem is the kind mismatch: Expected kind `* -> * -> *', but `S' has kind `*'
07:49:50 <rsalmin> s/some/someone/
07:50:06 <Saizan> blueonyx: nowhere, but i don't think you'll be able to make the implementation of the methods typecheck, even with that Wrapper
07:50:08 <fasta> rsalmin: anything related to the Any type is AFAIK, a work in progress.
07:50:27 <fasta> rsalmin: there is a redesign going on, IIRC, which will make these things a thing of the past.
07:50:47 <fasta> blueonyx: Try S a b
07:50:59 <fasta> blueonyx: with ().
07:51:51 * EnglishGent makes notes :)
07:52:29 <edwardk> @seen DrSyzygy
07:52:29 <lambdabot> DrSyzygy is in #haskell. I last heard DrSyzygy speak 6h 58m 1s ago.
07:53:07 <rsalmin> ok. czfg
07:53:19 <rsalmin> s/szfg//
07:56:21 <rsalmin> thnx. by.
08:02:12 <wolverian> "we ask a yes/no question: Dot or dash?" -- monad reader :)
08:19:33 <fasta> What should the semantics of assert False (error "Oh, my") be?
08:20:03 <jethr0> does someone know what einar karttunen's nick is on #haskell?
08:22:30 <roconnor> @hoogle assert
08:22:31 <lambdabot> Control.Exception assert :: Bool -> a -> a
08:22:31 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
08:22:31 <lambdabot> Test.HUnit.Base class Assertable t
08:23:13 <roconnor> fasta: I'd say it should be the same as the semantics of (error "assert failed on line X")
08:23:59 <Saizan> does it throw "Oh, my" instead?
08:23:59 <fasta> roconnor: me too. In that simple example that's also the case, but in a larger program, it isn't. I am figuring out why that is the case now.
08:24:09 <fasta> Saizan: yes, in the larger program it does.
08:25:00 <Saizan> well they are "imprecise exceptions" afterall :)
08:25:32 <roconnor> Question: should modules reexport the types that occur in the functions that are exported?
08:25:58 <Saizan> i'd think so
08:26:24 <fasta> roconnor: I don't always do it, but it is better,
08:27:38 <fasta> Saizan, roconnor: The issue was a non-issue.
08:27:45 <roconnor> ok
08:28:34 <aavogt> is there a portable equivalent of "cp -r" from the directory package?
08:28:41 <fasta> At least, I thought it was: ghc -O2 -fno-ignore-asserts should also be possible, no?
08:30:43 <Saizan> it should
08:30:46 <fasta> GHC seems to act a bit randomly.
08:31:14 <Saizan> -fforce-recomp ?
08:31:26 <fasta> Saizan: that must be it.
08:31:50 <fasta> An impure compiler for a pure programming language. Oh, the the irony.
08:32:08 <Saizan> heh
08:33:04 <Kaidelong> Hmm, someone have time to answer a question?
08:33:14 <benmachine> depends on the question
08:33:29 <benmachine> best to ask it and see
08:33:45 <Kaidelong> well, I'm coming in from F# and Microsoft's developer tools but I don't feel .NET is a good tool for writing cross platform applications so I want to learn Haskell
08:33:47 <Kaidelong> here is the problem
08:34:04 <Kaidelong> it looks like concurrency and generics in haskell are implementation specific
08:34:16 <Kaidelong> I want to know what most people are using
08:34:24 <aavogt> ghc
08:35:46 <roconnor> > (0*0)/0
08:35:48 <lambdabot>   NaN
08:35:54 <roconnor> > 0*(0/0)
08:35:55 <lambdabot>   NaN
08:35:58 <Kaidelong> do you know where I can find documentation on the GHC implementations of those features?
08:36:12 <jfoutz> @where control.concurrent
08:36:12 <lambdabot> I know nothing about control.concurrent.
08:36:26 <Saizan> @docs Control.Concurrent
08:36:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
08:36:32 <jfoutz> or that :)
08:36:35 <Saizan> @docs Data.Generics
08:36:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
08:36:50 <jfoutz> someday, i will learn to use my shift key. apparently not today.
08:36:54 * benmachine didn't know about @docs and now loves Saizan
08:37:00 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/index.html <- well, here :)
08:37:25 <Kaidelong> handy, new bookmark
08:37:36 <Saizan> benmachine: it doesn't actually work very well
08:37:46 <benmachine> oh
08:37:54 <Twey> Kaidelong: You should have a local copy with your installation of GHC
08:37:59 <benmachine> @docs Text.ParserCombinators.Parsec
08:38:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
08:38:04 <benmachine> good enough for me
08:38:18 <jfoutz> @docs Parsec
08:38:18 <lambdabot> Parsec not available
08:38:31 <jfoutz> looks like you need to know the package.
08:38:50 <benmachine> you need to know the module name, not the package
08:38:55 <benmachine> @hoogle Parsec
08:38:55 <lambdabot> module Text.Parsec
08:38:55 <lambdabot> module Text.ParserCombinators.Parsec
08:38:55 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
08:39:02 * benmachine blinks
08:39:09 <benmachine> @docs Text.Parsec
08:39:09 <lambdabot> Text.Parsec not available
08:39:14 <benmachine> oh :(
08:39:17 <Kaidelong> okay, I have another question
08:39:24 <Kaidelong> How does blocking work in a non-strict language?
08:39:37 <benmachine> the same way as ever?
08:39:45 <jfoutz> benmachine: er... sorry. java background. i keep internaly translating module into package
08:40:59 <jfoutz> Kaidelong: when you finally get around to saying, i need the next byte from the socket, the thread will block until a byte is available. (lazy may help you avoid asking for that byte)
08:41:18 <jfoutz> and you can do nonblocking reads.
08:42:45 <Kaidelong> well, thanks for the help
08:42:54 <Kaidelong> having the library documentation bookmarked will go a long way
08:43:24 <jfoutz> :)
08:43:59 <McManiaC> > let foo = "foo" in return (foo ++ "bar") >>= putStrLn
08:44:00 <lambdabot>   <IO ()>
08:44:05 <McManiaC> why doesnt lambdabot like this? ^^
08:44:06 <jfoutz> there are a bunch of resources on the wiki if you get stuck. articles and links to books and blog posts.
08:44:41 <jfoutz> McManiaC: stdout isn't the irc socket?
08:44:50 <fasta> McManiaC: let own_lambdabot = local_exploit in get_root_access
08:45:07 <McManiaC> huh
08:45:35 <fasta> McManiaC: people cannot execute IO stuff on lambdabot by design.
08:45:40 <McManiaC> okay
08:45:58 <McManiaC> i see
08:45:59 <aavogt> > System.Directory.removeDirectoryRecursive "/"
08:46:01 <lambdabot>   Not in scope: `System.Directory.removeDirectoryRecursive'
08:46:16 <jfoutz> but even if they did, there's no reason to think output would go to the socket.
08:54:59 <benmachine> does anyone know how to use cvs.haskell.org? I am trying to only get as much of it as I need but it seems there are build tools all over the place
08:55:18 <benmachine> also does anyone know why cvs.haskell.org still exists :<
08:56:03 <etpace_> :t let swap ~(x, y) = (y, x) in swap
08:56:04 <lambdabot> forall t t1. (t, t1) -> (t1, t)
08:56:15 <etpace_> what does ~ do then?
08:56:24 <benmachine> irrefutable pattern
08:56:29 <benmachine> err I think
08:56:35 <benmachine> a.k.a. lazy pattern
08:56:46 <benmachine> it is basically a pattern which always matches
08:56:52 <benmachine> or wait
08:57:01 <benmachine> you know that, but you are wondering what is the point in this case?
08:57:25 <benmachine> since the type ensures the pattern will match anyway
08:57:32 <benmachine> if that is what you mean then I dunno
08:57:52 <mjrosenb> benmachine: you can still bass in undefined
08:57:54 <etpace_> I never knew what ~ means, nor do I know the point in this case ;P
08:58:33 <benmachine> mjrosenb: but how will ~ help in that case?
08:58:47 <benmachine> etpace_: well,
08:59:01 <benmachine> > let f ~(x:xs) = 4 in f []
08:59:02 <lambdabot>   4
08:59:06 <benmachine> > let f (x:xs) = 4 in f []
08:59:07 <lambdabot>   * Exception: <interactive>:1:141-152: Non-exhaustive patterns in function f
08:59:18 <etpace_> hmm
08:59:27 <benmachine> > let f ~(x:xs) = xs in f []
08:59:29 <lambdabot>   * Exception: <interactive>:1:137-150: Irrefutable pattern failed for patter...
08:59:49 <etpace_> > let f ~(x:xs) = x in f []
08:59:51 <lambdabot>   * Exception: <interactive>:1:137-149: Irrefutable pattern failed for patter...
09:00:05 <etpace_> I guess there are times when its a good idea to use ~? :P
09:00:06 <int-e> > fix (\ ~(a, b) = (b + 1, 1) )
09:00:08 <lambdabot>   <no location info>: parse error on input `='
09:00:13 <int-e> > fix (\ ~(a, b) -> (b + 1, 1) )
09:00:15 <lambdabot>   (2,1)
09:00:19 <int-e> > fix (\ (a, b) -> (b + 1, 1) )
09:00:25 <lambdabot>   mueval-core: Prelude.read: no parse
09:00:25 <lambdabot>  mueval: ExitFailure 1
09:00:28 <int-e> that's a case where ~ helps
09:00:53 <pikhq> Without the ~, f's argument is evaluated until it can get (x:xs). With the ~, f's argument is not evaluated at all. Instead, x and xs are thunks.
09:01:17 <benmachine> also I once defined a safeTail as (\l@(~(x:xs)) -> if null l then [] else xs)
09:01:22 <etpace_> fix f = f (fix f) right?
09:02:00 <benmachine> right
09:02:02 <benmachine> @src fix
09:02:02 <lambdabot> fix f = let x = f x in x
09:02:07 <pikhq> If you never actually use (x:xs) in f, then no evaluation happens at all, and everything works like magic.
09:02:30 <Saizan> benmachine: drop 1
09:02:33 <etpace_> int-e's example is pretty magic
09:02:48 <benmachine> Saizan: that's cheating :P
09:02:49 <jfoutz> there is a MonadFix example that appears magical on the wiki
09:03:41 <jfoutz> makes use of ~, http://www.haskell.org/haskellwiki/MonadFix
09:03:57 <etpace_> is the trick that a is not needed, so it fetches the b which is always 1?
09:05:14 <jfoutz> etpace_: if a is needed, it will be evaluated, you could arrange for a to be used very late.
09:06:11 <etpace_> well a and b are thunks, and they're being tried to match against a function, so how does it fetch a value for b?
09:06:34 <jfoutz> that monadfix example from the wiki builds a tree, each node of the tree has a number that is the sum of all the nodes of the tree. *magic* as near as i can tell.
09:07:47 <int-e> etpace_: that's one half of the trick, but the irrefutable pattern is the other one; it allows let x = (\ ~(a, b) -> (b + 1, 1) ) x to evaluate to let x = let (a, b) = x in (b + 1, 1)
09:08:36 <int-e> etpace_: while without the irrefutable pattern, the patter (a, b) can not match x (which nothing is known about at that point).
09:08:42 <int-e> *pattern
09:09:13 <etpace_> crafty
09:34:59 <skorpan> can all ADTs with a single type parameter be Functors?
09:35:14 <skorpan> hm, no
09:35:21 <skorpan> X (a -> a) can't i guess
10:00:18 <lispy> ?users
10:00:19 <lambdabot> Maximum users seen in #haskell: 658, currently: 592 (90.0%), active: 7 (1.2%)
10:00:34 <lispy> wow, nearly 600
10:00:40 <lispy> This channel has really grown.
10:07:20 <CalJohn> I'm reading "Functional programming with bananas..." and I don't really understand the concept of a functor.  Can someone give me an example of a functor?
10:07:41 <Twey> CalJohn: Maybe
10:07:47 <Twey> (ho, ho, ho)
10:07:59 <c_wraith> that's a horrible pun
10:08:00 <c_wraith> :)
10:08:02 <Twey> > (+1) `fmap` Just 2
10:08:03 <lambdabot>   Just 3
10:08:09 <Twey> > (+1) `fmap` Nothing
10:08:10 <lambdabot>   Nothing
10:08:24 <CalJohn> Twey: yes, I get that concept of a functor, but the definition in this paper seems more general
10:08:54 <Twey> CalJohn: That's all a functor is: something that presents an interface of something in a box
10:09:09 <aavogt> > fmap (+1) (subtract 1) $ 0
10:09:11 <lambdabot>   0
10:09:16 <Twey> Maybe is a particularly concrete example in it basically is something in a box
10:09:24 <Twey> s/in it/in that it/
10:09:55 <Twey> But you can also do, say, (++ "\n") `fmap` getLine
10:10:05 <CalJohn> "A bifunctor is a binary op taking types into type and functions into fuctions such that if f : A -> B and g : B -> C then f `functor` g: A`functor`B -> B `functor` C"
10:10:32 <CalJohn> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.41.125&rep=rep1&type=pdf <- I'm on page 6
10:10:39 <ray> > fmap toUpper "hi there"
10:10:40 <lambdabot>   "HI THERE"
10:11:02 <CalJohn> yes, I get the haskell typeclass, but I have trouble understanding this definition
10:11:07 * Twey too
10:11:11 <monochrom> Oh, The Monad Reader has a new issue?
10:11:15 <ray> well, that's a bifunctor
10:11:23 <Twey> Ah, not just a functor?
10:11:26 <jfoutz> > ((+1) `fmap` (*2)) 3
10:11:27 <lambdabot>   7
10:12:02 <ray> regular functors are unary
10:12:31 <aavogt> is (,) a bifunctor?
10:12:33 <CalJohn> unary in that "fmap (+1)" is one?
10:12:47 <ray> er, unary in that the type constructor takes one argument
10:13:08 <skorpan> Nothing is not a unary type constructor
10:13:14 <c_wraith> @src ((,) a) (<*>)
10:13:14 <lambdabot> Source not found. Take a stress pill and think things over.
10:13:16 <ray> nothing is not a type constructor
10:13:19 <c_wraith> @src ((,) a) (ap)
10:13:19 <lambdabot> Source not found. You untyped fool!
10:13:19 <ray> er, Nothing
10:13:23 <monochrom> (,) is part of a bifunctor, the type part. you can write the function part: given f::A->B, g::X->Y, write f `yourophere` g :: (A,X) -> (B,Y)
10:13:25 <skorpan> i see
10:13:34 <skorpan> is Nothing a "value" constructor?
10:13:37 <ray> yes
10:14:33 <aavogt> monochrom: I see
10:14:36 <ray> caljohn: maybe if you translate `functor` out of infix notation it'll look clearer to you
10:14:39 <Twey> Nothing is a nullary value constructor
10:14:44 <aavogt> @hoogle Functor2
10:14:44 <lambdabot> No results found
10:14:45 <CalJohn> the same way that Just is a value construction?
10:14:51 <CalJohn> *er
10:14:53 <ray> functor f g: functor A B -> functor B C
10:15:11 <Twey> Oh, a bifunctor is a functor with *two* things in the box?
10:15:20 <ray> a functor in two arguments
10:15:30 <ray> you can generalize it even more
10:15:34 <SamB> of course, there doesn't have to be a box
10:15:35 <ray> trifunctors
10:15:37 <ray> =o
10:15:42 <ray> multifunctors
10:15:55 <Twey> Could one specify an arbitrary multifunctor in Haskell?
10:15:58 <c_wraith> :t (<+>)
10:15:59 <lambdabot>     Ambiguous occurrence `<+>'
10:15:59 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:4:0-19
10:15:59 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:54:0-46
10:16:03 <ray> i don't think so
10:16:06 <ray> like tuples, you'
10:16:09 <Twey> Yeah
10:16:12 <ray> d need to do each one seperately
10:16:16 <SamB> Twey: you mean, with just a fixed number of classes?
10:16:19 <Twey> What's the advantage of a bifunctor over a functor on a tuple?
10:16:27 <Twey> SamB: I meant with one class :Ã¾
10:16:35 <SamB> certainly not with just one class
10:16:41 <c_wraith> @instances Functor
10:16:42 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:16:44 <SamB> you need more than one class for hackery like that
10:17:04 <Twey> I guess this is Oleg territory
10:17:07 * Twey treads carefully
10:17:34 <c_wraith> Twey:  You can't have a functor on a tuple, since you only have one free type variable in the definition of Functor, and at least two free type variables in tuples.
10:17:49 <SamB> what I took you to mean is "is it possible to write several typeclasses and instances that, when combined, give you arbitr-ary multifunctors somehow?"
10:17:52 * Twey ponders.
10:17:55 <c_wraith> Hence the Functor instance is for ((,) a) instead of (a, b)
10:18:11 <ksf> bar :: Foo a -> IO (STM a -> STM ((a -> a) -> STM ())))
10:18:16 <Twey> c_wraith: Damn, you're right :-\
10:18:34 <Twey> ksf: Eek
10:18:55 <SamB> honestly, as Twey said before, this is deep Oleg territory
10:19:02 <SamB> so I'm not going to claim it's possible or not
10:19:21 <stanv> is any way convert Int to strint except using show function?
10:19:25 <SamB> ... just that it would almost certainly be quite evil!
10:19:31 <c_wraith> Eh.  This is the same thing I ran into a few days ago asking why there was no Applicative instance for (a, b). :)
10:19:31 <SamB> stanv: sure!
10:19:33 <ray> 1.5 olegs of evil
10:19:34 <SamB> stanv: why?
10:19:36 <Twey> Muhahahaha!
10:19:37 <stanv> String
10:19:48 <CalJohn> "oleg territory" in what way?
10:19:52 <Twey> (Âµhahahaâ€¦)
10:19:55 <SamB> stanv: what do you want it to come out like?
10:20:05 <c_wraith> Twey's gone unicode!
10:20:10 <SamB> have you seen the picture ?
10:20:17 <ray> ãµãµãµãµãµãµãµãµãµãµãµãµãµãµãµ
10:20:23 <Twey> Hehehe
10:20:34 <c_wraith> It's kind of like going plaid
10:20:34 <stanv> SamB: it must have signature : foo :: Int -> String
10:20:44 <Twey> c_wraith: But far more tasteful.
10:20:45 <SamB> stanv: is this homework?
10:20:52 <stanv> SamB: yes :)
10:20:57 <Twey> foo = const "HI THERE"
10:21:18 <SamB> stanv: I figured it out because you didn't say anything about how show didn't give the output you wanted
10:21:29 <SamB> stanv: well, do you know how to do it in any programming language at all?
10:21:39 <SamB> I mean, without using a library function?
10:21:43 <aavogt> :t foo = unsafeCoerce :: Int -> String
10:21:45 <lambdabot> parse error on input `='
10:21:45 <ray> i think implementing a multifunctor typeclass probably reduces to implementing n-tuples
10:21:55 <SamB> ray: oh, well, that's not that hard
10:21:55 <aavogt> :t let foo = unsafeCoerce :: Int -> String in foo
10:21:57 <lambdabot> Not in scope: `unsafeCoerce'
10:22:02 <Twey> :t let foo = const "HI THERE" in foo
10:22:03 <lambdabot> forall b. b -> [Char]
10:22:03 <SamB> it's just that it would be bad for performance ;-)
10:22:08 <SamB> afaict
10:22:13 <Twey> Drat!
10:22:15 <aavogt> :t let foo = Unsafe.Coerce.unsafeCoerce :: Int -> String in foo
10:22:16 <lambdabot> Int -> String
10:22:22 <CalJohn> right, so, a bifunctor would take two functions and apply both to one argument?
10:22:23 * Twey laughs.
10:22:25 <Twey> Oh, that's even better.
10:22:29 <SamB> CalJohn: http://arcanux.org/lambdacats_3.html#entry4
10:22:30 <ray> a list of Typeable Anys?
10:22:32 * ray cackles
10:22:53 * ksf tries to write the equivalent of $ for types and gets kind errors
10:23:05 <Twey> ray: Bahahaha
10:23:14 <CalJohn> so many fmap2 f g (x:xs = (f . g) x : fmap2 f g xs -- except generalised
10:23:24 <SamB> ray: I was thinking more like the half-strict tuple ...
10:23:28 <CalJohn> s/many/maybe
10:23:28 <ray> a list of them paired with their type representations even
10:23:29 <ksf> anway, Twey, you shouldn't be put off, what you're seeing is a capability system.
10:23:56 <Twey> ksf: I don't know how you'd even begin to do that
10:24:07 <Twey> Haskell doesn't have primitives for defining arbitrary type functions :-\
10:24:15 <SamB> CalJohn: take a look at that picture to get an idea of why we call it "oleg territory"
10:24:32 <Twey> CalJohn: Then have a butcher's at http://okmij.org/ftp/Haskell/
10:24:39 <Twey> But have someone standing by
10:24:41 <stanv> > (const "hi" 123) :: String
10:24:42 <lambdabot>   "hi"
10:24:43 <Twey> It's pretty intense stuff
10:24:44 <ksf> you get back a store, which you may clear (multiple times), which gives you an append function which you can call (multiple times) which gives you a function to change the entry of the appended element
10:25:57 <CalJohn> @type fmap2
10:25:58 <lambdabot> Not in scope: `fmap2'
10:26:16 <CalJohn> hm, apparently lambdabot doesn't have Control.Functor
10:26:31 <Twey> > fmap2
10:26:32 <lambdabot>   Not in scope: `fmap2'
10:26:34 <Twey> Huh.
10:26:46 <CalJohn> but that fmap2 is not the same as mine, i don't think
10:27:27 <Twey> Could not find module `Control.Functor':
10:27:29 <CalJohn> i've already seen oleg's site, but i didn't understand enough of it to think anything of it
10:27:43 <Twey> Haha
10:27:46 <Twey> That's kind of the point
10:27:49 <Twey> Very few people do :Ã¾
10:28:32 <aavogt> CalJohn: so your fmap2 f g = fmap (f . g) ?
10:28:36 <SamB> CalJohn: anyway, did the picture maybe give you a clue?
10:28:41 <SamB> he actually does that!
10:29:48 <stanv> > let t=1 in ('\t'::Char)
10:29:49 <lambdabot>   '\t'
10:29:52 <stanv> :(
10:29:58 <CalJohn> SamB: yes, it did
10:30:31 <CalJohn> aavogt: yes, i've just realised that my fmap2 is stupid
10:30:55 <CalJohn> bifunctors take a box with two things it it, and two functions, and apply one function to each thing
10:31:15 <stanv> ((fromInteger 1) :: Char) - doesn't work :(
10:31:26 <CalJohn> fmap2 :: (a -> b) -> (c -> d) -> f a c -> f b d
10:31:43 <jfoutz> > (fromInteger 65) :: Char
10:31:44 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
10:31:44 <lambdabot>    arising from a use of `GHC....
10:31:51 <ksf> @djinn (a -> b) -> (c -> d) -> f a c -> f b d
10:31:52 <lambdabot> -- f cannot be realized.
10:31:58 <aavogt> > ord 65
10:32:00 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
10:32:00 <lambdabot>    arising from the literal `6...
10:32:02 <ksf> @djinn (a -> b) -> (c -> d) -> (a, c) -> (b, d)
10:32:03 <lambdabot> f a b (c, d) = (a c, b d)
10:32:03 <SamB> CalJohn: bet you never thought lolcats were actually useful before, did you!
10:32:04 <aavogt> > chr 65
10:32:05 <lambdabot>   'A'
10:32:32 <CalJohn> SamB: well, actually, as a matter of fact I have made some lolcats on the topic of english common law, so yes, I did know :)
10:32:34 <stanv> aavogt: is this only one way ?
10:32:45 <ksf> you can probably fake it quite easy with TH.
10:32:46 <jfoutz> > ord 'A'
10:32:47 <lambdabot>   65
10:32:49 <SamB> CalJohn: hehe
10:33:14 <aavogt> > (48+) $ ord '1'
10:33:15 <lambdabot>   97
10:33:25 <aavogt> > subtract 48 $ ord '1'
10:33:26 <lambdabot>   1
10:33:30 <CalJohn> ksf: that's a good point, (,) is an example of a box on which a bifunctor would operate
10:33:40 <EnglishGent> hi again :)
10:33:40 <aavogt> stanv: no, use read
10:33:49 <CalJohn> EnglishGent: hello
10:33:55 <EnglishGent> hi CalJohn :)
10:33:57 <ksf> actually,
10:34:06 <ksf> @djinn ((a -> b), (c -> d)) -> (a, c) -> (b, d)
10:34:06 <lambdabot> f (a, b) (c, d) = (a c, b d)
10:34:13 <EnglishGent> @hoogle (a -> Bool) -> [a] -> ([a],[a])
10:34:14 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
10:34:14 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
10:34:14 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
10:34:26 <ksf> ...which smells like an applicative functor, to me.
10:34:42 <EnglishGent> @hoogle break
10:34:43 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
10:34:43 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
10:34:43 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
10:34:46 <ksf> (modulo types)
10:36:19 <CalJohn> @type <*>
10:36:20 <ksf> in practice, though, you see people quickly making up a custom name for fmap if they want to map over another thing as the default fmap
10:36:20 <lambdabot> parse error on input `<*>'
10:36:25 <CalJohn> @type (<*>)
10:36:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:37:57 <etpace_> @hoogle [a] -> [a] -> [a]
10:37:58 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
10:37:58 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
10:37:58 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:38:00 <ksf> that said, category theory is just overkill if all you need is HASK.
10:38:38 <etpace_> Anyone know of a function that returns the intersection of two lists?
10:38:48 <Deewiant> ?ty intersect
10:38:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:38:54 <CalJohn> > bifmap (+1) (+2) (5,6)
10:38:55 <lambdabot>   (6,8)
10:39:13 <etpace_> heh
10:39:25 <CalJohn> @type bifmap
10:39:26 <lambdabot> forall t t2 t1 t3. (t -> t2) -> (t1 -> t3) -> (t, t1) -> (t2, t3)
10:39:58 <CalJohn> ksf: what is HASK?
10:40:13 <etpace_> > intersect [1..5] (map fst [(3,'a'), (2, 'b')])
10:40:14 <Deewiant> ?ty (S.toList .) . S.intersection `on` S.fromList -- probably faster
10:40:14 <lambdabot>   [2,3]
10:40:15 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
10:40:32 <jfoutz> @hoogle bifmap
10:40:32 <lambdabot> No results found
10:40:45 <CalJohn> jfoutz: yeah, i just @let bound it in a private message
10:40:51 <ksf> what about a class Functor2 with exactly the same types as Functor, but operating on the element left to the rightmost?
10:40:53 <jfoutz> oh. heheh. :)
10:41:17 <CalJohn> @google HASK
10:41:18 <lambdabot> http://www.hask.org/
10:41:18 <lambdabot> Title: Houston Association of Sea Kayakers
10:41:24 <CalJohn> :(
10:41:29 <ksf> the problem isn't composition, but that types commonly don't come with a possibility to map over other thing than the rightmost type.
10:41:38 <ksf> it's the category of haskell functions and types
10:42:08 <ksf> ...that is, haskell.
10:42:39 <EnglishGent> I have a function [a] -> (a -> Bool) -> ([a],[a]) -- I want a function [a] -> (a -> IO Bool) -> IO ([a], [a]) -- I assume there's some higher order function to convert it for me? :)
10:42:57 <ksf> EnglishGent, hell no
10:43:17 <aavogt> @type partitionM
10:43:18 <Twey> Trulyâ€¦ hell no
10:43:18 <lambdabot> Not in scope: `partitionM'
10:43:27 <ksf> why would you toss a perfectly pure function into the abyss of IO?
10:44:18 <EnglishGent> becuase my [a] is a list of files - and my a -> IO Bool is something returning something about the file... and I want to get back a list of all those files satisfying the predicate & all those that dont
10:44:41 <benmachine> hmm
10:44:42 * EnglishGent is being peverse & trying to write shell scripts in Haskell :)
10:44:50 <Twey> EnglishGent: 1) See HSH
10:45:00 <stanv> howto transform from 123::Int to [1::Int,2,3] ?
10:45:02 <Deewiant> partitionM is fairly easy to define
10:45:03 <Twey> 2) Perform the IO on them *first* to get the info, then pass the list to your function
10:45:30 <c_wraith> stanv:  division and remainder
10:45:32 <Twey> stanv: map read . show
10:45:41 <c_wraith> Twey, he's still doing homework
10:45:42 <Lemmih> > map digitToInt (show 123)
10:45:44 <lambdabot>   [1,2,3]
10:45:48 <Twey> c_wraith: Thus my non-useful answer
10:46:11 <stanv> i can't use show :))
10:46:20 <ksf> :t divMod
10:46:22 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
10:46:33 <stanv> ksf: thanks
10:46:52 <jfoutz> :t unfoldr
10:46:53 <benmachine> map read . (`shows` "")
10:46:53 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:46:55 <benmachine> >_>
10:47:19 <aavogt> @type fmap (partition snd) . mapM (\x -> (,) x <$> return False)
10:47:21 <lambdabot> forall (f :: * -> *) a. (Functor f, Monad f) => [a] -> f ([(a, Bool)], [(a, Bool)])
10:47:43 <aavogt> @type fmap ((map fst *** map fst) . partition snd) . mapM (\x -> (,) x <$> return False)
10:47:45 <lambdabot> forall (f :: * -> *) a. (Functor f, Monad f) => [a] -> f ([a], [a])
10:49:42 <jfoutz> EnglishGent: it's nice to have IO on the outside. It's hard to describe... in your main function, interact with the file system, call a pure function that tells IO what to do next, then call a pure function. you want to build a thin shell of IO around a pretty pure core.
10:50:14 <c_wraith> :t replicateM
10:50:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:50:23 <jfoutz> well, do whatever you want, but if you can get in the thin IO shell way of thinking, live is easier.
10:50:32 <jfoutz> s/live/life/
10:50:34 <jfoutz> ugh.
10:50:38 <c_wraith> > replicateM 5 $ Just 3
10:50:39 <lambdabot>   Just [3,3,3,3,3]
10:50:43 <aavogt> @type fmap ((map fst *** map fst) . partition snd) . mapM (\x -> (,) x <$> System.Directory.doesFileExist x)
10:50:44 <lambdabot> [FilePath] -> IO ([FilePath], [FilePath])
10:51:24 <c_wraith> > replicateM 5 (Nothing:: Maybe Int)
10:51:25 <lambdabot>   Nothing
10:51:26 <aavogt> ... which is following Twey's 2) option
10:51:39 <jfoutz> yeah.
10:51:56 <Twey> @type fmap ((map fst *** map fst) . partition snd) . mapM (\x -> (,) x <$> (System.Directory.doesFileExist &&& System.Directory.doesDirectoryExist) x)
10:51:57 <lambdabot>     Couldn't match expected type `Bool' against inferred type `IO Bool'
10:51:57 <lambdabot>       Expected type: (IO Bool, Bool)
10:51:57 <lambdabot>       Inferred type: (IO Bool, IO Bool)
10:52:02 <Twey> :<
10:52:04 <Twey> Oh, yeah
10:52:06 <Twey> Duh.
10:52:15 * Twey finds something to eat, instead.
10:52:41 <Deewiant> ?ty liftM2 (&&&)
10:52:42 <lambdabot> forall (a :: * -> * -> *) b c c' (m :: * -> *). (Arrow a, Monad m) => m (a b c) -> m (a b c') -> m (a b (c, c'))
10:53:13 <aavogt> @type return :: b -> (a,b)
10:53:14 <lambdabot>     Could not deduce (Monad ((,) a)) from the context ()
10:53:14 <lambdabot>       arising from a use of `return' at <interactive>:1:0-5
10:53:14 <lambdabot>     Possible fix:
10:53:16 <ksf> can you write a type-level fmap and bind?
10:53:20 <ksf> I'm just curious
10:53:30 <EnglishGent> I'm trying to do thyat jfoutz - I'm just learning Haskell though... I've started with I/O heavy stuff quite deliberately (I come from a Lisp background & have no problem with the purely functional parts) - it's I/O & Type classes that are the strange areas of Haskell for me :)
10:53:30 <ksf> (and put of by the syntax of my types)
10:53:48 * EnglishGent has some ML experience too
10:54:15 <ksf> EnglishGent, when you come from either lisp or ML, you're still in for learning the basics of functional programming.
10:54:43 * Twey concurs.
10:54:54 <CalJohn> ksf: why would do you say that?
10:54:57 <Deewiant> Even ML?
10:55:04 <CalJohn> s/would//
10:55:24 <c_wraith> CalJohn, you left an extra space with that substitution!
10:55:27 <ksf> ...because I came from C/scheme/java and thought I knew functional programming
10:55:45 <EnglishGent> I make no claims to expertise ksf - just that I dont need to learn what lambdas / higher order functions / algebraic datatypes are - I freely admit I dont grok Monads or type classes yet - though I am trying!
10:56:00 <c_wraith> Don't worry about Monads  too much.
10:56:04 <CalJohn> c_wraith: sorry, that should have been s/would/^H/ , my sincere apologies
10:56:05 <c_wraith> They're just another typeclass
10:56:09 <jfoutz> EnglishGent, the biggest difference for me, wrt designing a program, was pushing IO out. the easiest way to do it is to make a data Action = ReadFile String | TestFile [Props] kind of thing. make an interpreter that runs in IO for that data type, and call a bunch of pure helpers.
10:56:35 <Twey> That'sâ€¦ reimplementing IO :Ã¾
10:56:54 <EnglishGent> Deewiant - ML is strictly evaluated & allows impure code .. it's still a stretch jumping to Haskell (in my experience anyway)
10:57:04 <jfoutz> Twey: is it?
10:57:17 <monochrom> In Haskell you learn the implications of "Int -> Bool" forbidden any I/O.
10:57:17 <Twey> jfoutz: Yes.  That's exactly what the IO monad does.
10:57:18 <Deewiant> Certainly, but I thought it was much more heavily functional than Lisps, for instance
10:57:28 <ksf> you know, you can return io actions from pure code and join them in.
10:57:29 <Twey> Except it handles the actions by compiler magic, of course.
10:57:42 <etpace_> @hoogle (a -> b) -> (a, a) -> (b, b)
10:57:43 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
10:57:43 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
10:57:43 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
10:57:44 <Twey> (interpreting them)
10:57:49 <Twey> Deewiant: Depends on the Lisp
10:58:19 <jfoutz> Twey: the big difference (in my mind) is the control flow comes from the pure functions. I'm by no means an expert in haskell though.
10:58:21 <Deewiant> True
10:58:27 <EnglishGent> it depends on one's style Deewiant - you certainly can write Lisp in a very functional style - most implementations have tail-recursion elimination (even though it's not in the standard) etc
10:58:46 <Twey> jfoutz: IO in Haskell is in fact pure.
10:58:48 <c_wraith> Haskell doesn't precisely have tail-recursion elimination. :)
10:58:51 <mauke> if you have to recurse manually, it's not very functional :-)
10:59:16 <Twey> jfoutz: The monad is just a clever way of building up a long list of instructions just as you just described.
10:59:20 <etpace_> @hoogle Bool -> Int
10:59:21 <lambdabot> Data.Time.Calendar.MonthDay monthLength :: Bool -> Int -> Int
10:59:21 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
10:59:21 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
10:59:33 <etpace_> > fromBool True
10:59:35 <lambdabot>   Not in scope: `fromBool'
10:59:37 <Twey> The interpreter is the only impure bit (unsafe* aside)
10:59:41 <EnglishGent> I'm trying to get rid of that too ... I began developing a personal style a while back of replacing explicit recursion with combinators (after reading about Joy) :)
11:00:23 * ksf can't stand fix but uses mfix
11:00:44 <copumpkin> why?
11:00:46 <jfoutz> Twey: how do you deal with building part of your list in response to some IO state?
11:00:55 <ksf> ...though it's not often that you want to use mdo, anyway, for syntactic sanity.
11:02:00 <ksf> fix is true recursion, I like it when I can follow the variables to direct my mind. mfix is just value recursion, it doesn't actually do anything to your stuff.
11:02:17 <etpace_> > foldl (\(as, bs) (a, b) -> if (a == 'y') && (b == 'y') then (as + 1, bs + 1) else if (a == 'y') then (as + 1, bs) else (as, bs + 1)) (0,0) (zip "nyyyn" "ynnny")
11:02:18 <lambdabot>   (3,2)
11:02:39 <etpace_> anything better than something that ghastly, but still walks the list simultaneousl?
11:03:43 <aavogt> > length . filter id $ zipWith (\a b -> a == 'y' && b == 'y') "nyyyn" "ynnny"
11:03:44 <lambdabot>   0
11:04:59 <ksf> etpace_, why do you want ot walk them simultaneously?
11:05:34 <ksf> you can just filter (=='n) and filter (=='y') and then count both length.
11:05:47 <jfoutz> Twey: this is an overly long example... http://metavar.blogspot.com/2008/01/opengl-programming-with-haskell.html but follows that model. glut imposes some impure stuff, those impure things call pure actions to figure out the next state, and pass back a datastructure for gl to render.
11:05:55 <etpace_> oh its just a coincidence they are inverted
11:05:57 <EnglishGent> I confess I'd like to know that too jfoutz's question
11:06:03 <etpace_> i guess ill coe first, optimise later
11:06:07 <aavogt> > [(x,y) | x <- "abc" | y <- "def"]
11:06:09 <lambdabot>   [('a','d'),('b','e'),('c','f')]
11:06:27 <EnglishGent> my first attempt to do this program produced a list of actions & then executed them all - only I realised that had quite a serious bug
11:06:47 <EnglishGent> becuase the program both a) checks to see if filenames are in use
11:06:51 <EnglishGent> and b) generates files
11:07:10 <ksf> ...well, what I meant was do filter (=='y') on both lists, then get their length.
11:07:18 <Twey> jfoutz: Yes, that's basically it.
11:07:32 <EnglishGent> and the problem is if you do it in 'batch mode' (for want of a better term) - it's possible to generate a file, that the program doesnt know exists - becuase it wont untill all the I/O actions are finally evaluated
11:07:37 <jfoutz> but how would i do that without reimplementing io?
11:08:27 <ksf> jfoutz, you could return IO actions to be executed instead of those data structures.
11:08:36 <ksf> it's a matter of taste and case.
11:08:38 <Twey> Right.
11:09:14 <Twey> Reimplementing (a specialised subset of) IO makes sense in some cases where what you're doing really is semantically different
11:09:20 <ksf> sometimes you want to have a clear semantic model that you can reuse (e.g. "a circle"), sometimes you want to have the freedom of messing as you please.
11:09:25 <Twey> Or else needs some extra guarantees (e.g. STM)
11:09:30 <jfoutz> aaaahhhh
11:09:57 <ksf> STM is great fun, as I discovered.
11:10:02 <Twey> *nod*
11:10:07 <ksf> ...just native data structures are sparse.
11:10:29 <ksf> I'd like to have a concurrent map, for example.
11:11:01 <EnglishGent> concurrent map?
11:11:13 <ksf> ...or, actually, IxSet, but I haven't had a closer look
11:11:34 <ksf> EnglishGent, well, if I save my Data.Map in a TVar, only one thread can update it at a time.
11:11:37 <EnglishGent> do you mean apply the operation to all members of the list/set/whatever in parallel?
11:11:47 <aavogt> > flip execState (0,0) $ zipWithM_ (\x y -> case (x,y) of ('y','y') -> modify (succ *** succ); ('y',_) -> modify (first succ); (_,'y') -> modify (second succ); _ -> return ()) "nyyyn" "ynnny"
11:11:48 <lambdabot>   (3,2)
11:11:50 <ksf> ...even if 10000 threads want to modify 10000 different elements, I can't do that.
11:12:13 <ksf> EnglishGent, data parallel haskell does that.
11:12:26 <ksf> it'll be ghc-standard with the release of 6.12
11:12:53 <EnglishGent> I would have thought that a fairly simple optimisation (the beauty of knowing the function must be pure!) :)
11:14:11 <ksf> it's a bit more involved because it involves scheduling, and strictness.
11:14:55 <ksf> also, it's not automatic, as that could wreck havoc on many a program.
11:15:06 <ksf> haskell threads are cheap, but not free.
11:15:44 <ksf> the paper about it is one of spj's ones that even mortals can read.
11:20:54 <jfoutz> Twey, ksf: returning io is neat. i've got a long list of things that bug me about it, but it is pretty neat.
11:21:25 <Twey> jfoutz: It's not just neat, it's what everything does.
11:21:39 <Twey> There is no distinction between that and standard IO-usage.  That's how IO works.
11:21:51 * jfoutz ponders
11:25:20 <ksf> as I already mentioned... bar :: Foo a -> IO (STM a -> STM ((a -> a) -> STM ())))
11:25:36 <kmc> @hoogle (Monad m) => m ()
11:25:36 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
11:25:36 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
11:25:36 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
11:25:47 <kmc> @pl return ()
11:25:47 <lambdabot> return ()
11:25:52 <ksf> (the Foo a is unimportant)
11:26:46 <ksf> actually, it's bar :: IO (STM (a -> STM ((a -> a) -> STM ())))
11:27:25 <jfoutz> Twey: ok, here are two things i find upsetting. 1) i may not have the whole answer. if i drag state around, instead of IO, i'm free to do another pass over the data, like constant folding or something. delete a whole directory if i'm planning to delete every file, rather than deleting every file, then the directory.
11:27:39 <ksf> "return an stm action that clears the structure, which returns an stm action that you can use to append stuff to the (cleared) structure, which returns an action you can call to modify the (appended) element
11:28:36 <ksf> ...the code that does the appending then goes on to pass modification functions all back and forth through the rest of the program.
11:28:50 <jfoutz> Twey: 2) threading m args through functions that aren't monadic, so i can return a monad. (i realize this is less valid, as i'm putting an odd type on them anyway.
11:29:28 <ksf> ...as I don't particularily trust lookup keys in a concurrent setting.
11:32:00 <ksf> forkIO . forever . join . atomically . join $ readTChan fifo    beats in clarity any adt evaluator that you could write.
11:33:25 <monochrom> I wonder why there is one fewer . and the $ is so early
11:34:04 <ksf> "readTChan fifo" is STM a
11:34:16 <ksf> ...where a, in this case, is STM b
11:34:17 <mauke> . readTChan $ fifo
11:34:59 <ksf> hey does it make a diffenrence?
11:35:42 <aavogt> @type ((+1) .) $ 1
11:35:44 <lambdabot> forall b a. (Num b, Num (a -> b)) => a -> b
11:35:58 <aavogt> @type ((+1) .) ($ ($ 1))
11:35:59 <lambdabot> forall b a b1. (Num b, Num a) => (((a -> b1) -> b1) -> b) -> b
11:36:32 <monochrom> Since clarity is brought up, I think being uniform about using . is clearer than switching from . to $ prematurely.
11:37:37 <ksf> ...if you expect a value after $, yes.
11:38:43 <ksf> I'm going to switch to that style because of exendability, not because it means wasting a keystroke.
11:49:57 <EnglishGent> hi! would anyone care to critique a newbies first Haskell program? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8879#a8879
11:50:06 <EnglishGent> any feedback greatfully recieved :)
11:51:09 <Lemmih> EnglishGent: What's with the explicit layout?
11:51:16 <skorpan> EnglishGent: don't do everything in the IO monad
11:51:17 <ksf> IxSet is a true eierlegende Wollmilchsau
11:51:47 <EnglishGent> skorpan - I'm trying not to ... how should I go about cutting down on it's use? I'm doing something fairly I/O heavy
11:52:10 <ksf> makes me wonder how much corn I need to feed that beast.
11:52:32 <Botje> EnglishGent: the expand -- mvFile business on lines 36-37 is a bit superfluous
11:52:45 <Botje> mapM (moveFile sourceDir targetDir) files
11:52:49 <Botje> does the same :)
11:52:57 <EnglishGent> I'd _like_ to write in a more functional fashion - but you cant go generating a bunch of move commands & _then_ execute them all (that's was my first approach) - it's more functional .. but it's also bugged :|
11:53:10 <skorpan> sure you can
11:53:15 <skorpan> you can have [IO ()]
11:53:31 <Botje> EnglishGent: also, mapM_ returns an IO () instead of IO [()], which is a bit nicer
11:53:45 <EnglishGent> yes - but that doesnt work... becuase you might rename a file A to A1 (as A already exists) - and also have a file called A1 in the source directory
11:54:00 <aavogt> EnglishGent: line 30,31 are unnecessarily in a monad
11:54:24 <EnglishGent> and then - becuase you havent gone & created A1 in the target yet - the program decides it's safe to move it --- only it wont be - becuase when you actually execute all the IO operations there will be an A1 there
11:54:27 <ksf> you can cut out most of the IO by first reading both directory contents into lists.
11:54:50 <ksf> ...then constructing a list of moves based on that info, finally executing them.
11:55:00 <EnglishGent> it was that complication that forced this approach on me ... it looks rather more like Java than I wanted it to
11:55:04 <aavogt> you could write "let x_inode = fileID x_status; y_inode = fileID y_status"
11:55:27 <ksf> e.g. have a look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3886 .
11:55:28 <aavogt> you could write "let { x_inode = fileID x_status; y_inode = fileID y_status; }"
11:55:34 <EnglishGent> ksf - I can only do that if I also pass around state on what renames I'm going to generate - else .. see above problem :|
11:55:36 <ksf> everything but main is pure there.
11:56:13 * EnglishGent hasnt figured out the state monad yet - I only just about get IO
11:56:27 <skorpan> there's no need for the state monad here
11:56:34 <skorpan> (afaict)
11:56:37 <ksf> IO is just a state monad from realWorld to realWorld.
11:56:54 <ksf> in fact, ghc implements it as a ST
11:57:26 <roconnor> ksf: that implemenation of IO is GHC specific.
11:57:49 <Botje> EnglishGent: look into liftM2 as well
11:57:57 <ksf> ...the model still holds generarally, even if you can't get hold of realWorld.
11:58:06 <Botje> that avoids the pattern you have at lines 57-60 and 69-71
11:58:17 <ksf> it wouldn't make much sense, anyway, as there _can_ only be one realWorld.
11:58:24 <ksf> ...at least in theory.
11:58:28 <EnglishGent> ksf - then how would you pass around the list of files your about to generate? passing it as an argument to everything & having everything return it feels clumsy
11:59:00 <EnglishGent> ksf - wait till the physics people finish with the Everett interpretation :)
11:59:12 <roconnor> ksf: I think the model doesn't provide very little insight into how getChar works
11:59:15 <roconnor> er
11:59:19 <EnglishGent> btw.. I do appreciate this - thanks everyone :)
11:59:19 <roconnor> ksf: I think the model provides very little insight into how getChar works
11:59:42 <ksf> ...well, he was complaining about not getting State, not about not getting IO.
11:59:48 <Botje> EnglishGent: liftM2 would surely clear up the nameInUse function :)
12:00:09 <ksf> EnglishGent, you don't pass them around, you map over them.
12:00:18 <Botje> nameInUse = liftM2 (||) doesFileExist doesDirectoryExist
12:00:43 <ksf> ...there's no main, btw.
12:00:56 <roconnor> heh okay.  The tricky thing about the State Monad is to note that it used to be called the State Transformer Monad (and rightly so).
12:01:18 <ksf> which might explain why you're using so many io functions.
12:02:05 <ksf> EnglishGent, did you have a look at that code I posted?
12:03:09 <EnglishGent> looking ksf
12:06:12 <EnglishGent> I dont know Parsec yet :|
12:06:35 * EnglishGent trying to make sense of it
12:07:04 <ksf> it just parses "prefix-<numbers>-rest) into File numbers rest whole
12:07:25 <ksf> I had to shuffle around episodes in my b5 collection.
12:07:38 <EnglishGent> :)
12:08:20 <ksf> ...and it gets quite annoying to rename b5-030-2e07-Soul Mates.avi through say b5-112-5e21-Objects at Rest.avi manually.
12:08:56 <EnglishGent> I agree with you that Perl is dead btw... it seemed a good learning exercise to try & write this in Haskell (normally I would have ran it of in Python or something)
12:09:14 <EnglishGent> as even SPJ says sooner or later any real program has to do I/O
12:09:17 <EnglishGent> :)
12:11:02 <ksf> total runtime of b5 is about 100 hours, btw.
12:14:48 <EnglishGent> hi copumpkin :)
12:14:51 <etpace_> > compare 1 1
12:14:53 <lambdabot>   EQ
12:15:01 <kmc> EnglishGent, imo it's best to learn the IO monad *after* a few others
12:15:06 <copumpkin> hey :)
12:15:07 <kmc> IO is a really strange monad as they come
12:15:20 <copumpkin> why?
12:15:43 <roconnor> copumpkin: because of its abstract nature.
12:15:51 <copumpkin> hrm
12:16:00 <etpace_> > let maxs (x:xs) = foldl
12:16:01 <lambdabot>   not an expression: `let maxs (x:xs) = foldl'
12:16:02 <etpace_> oops
12:16:06 <burp> perl is dead? o0
12:16:08 <kmc> if you want to understand monads in general, it's helpful to study one that can be implemented in 2 lines of haskell, like Maybe or []
12:16:08 <roconnor> IO arguably cannot be written in pure haskell.
12:16:27 <roconnor> while most of the other monads are pure haskell.
12:16:46 <copumpkin> that doesn't mean it's conceptually difficult though
12:17:17 <roconnor> many people have a hard time grasping abstract ideas, at first.
12:17:44 <skorpan> learning monads by seeing examples of them and then doing it myself did the trick for me... learning some "fundamental truth" about monads as a newbie really isn't that easy.
12:17:46 <etpace_> :t mapAccumL
12:17:47 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:17:53 <ksf> monands are about as easy to understand as ; and lambda calculus, combined.
12:17:53 <kmc> i think people who learn IO first tend to associate "monad" with some combination of "strict", "impure", "no extracting values", and "magical primitive"
12:19:07 <ski_> etpace_ : that's basically `mapM' in `State acc'
12:20:09 <ksf> I guess I finally grokked the IO monad after grokking http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
12:21:39 <ksf> ...reading an ioRef before you write it is certainly creative.
12:22:15 <kmc> i get the basic idea but i can't justify why it shouldn't break horribly
12:22:58 <etpace_> > let maxs (y:ys) = (\(x:xs) x' -> case (compare x x') of { (LT) -> ([x'],x'); (EQ) -> (x':x:xs,x'); (GT) -> (x:xs, x') } [y] ys in maxs [3,2,5,5,5,8,9,9,2,5,5,9]
12:22:59 <lambdabot>   <no location info>: parse error on input `['
12:23:28 <etpace_> > let maxs (y:ys) = (\(x:xs) x' -> case (compare x x') of { (LT) -> (x':[],x'); (EQ) -> (x':x:xs,x'); (GT) -> (x:xs, x') } [y] ys in maxs [3,2,5,5,5,8,9,9,2,5,5,9]
12:23:29 <ksf> because unsafeInterleaveIO makes the a in IO a lazy, and if k isn't strict in its first argument, then no NonTermination is thrown, as it's going to read the updated ioref value.
12:23:29 <lambdabot>   <no location info>: parse error on input `['
12:23:33 <etpace_> hmm?
12:24:01 <etpace_> > let maxs (y:ys) = (\(x:xs) x' -> case (compare x x') of { (LT) -> (x':[],x'); (EQ) -> (x':x:xs,x'); (GT) -> (x:xs, x') }) [y] ys in maxs [3,2,5,5,5,8,9,9,2,5,5,9]
12:24:02 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
12:24:08 <etpace_> gah
12:24:09 <edwardk> @seen shapr
12:24:09 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 15s ago.
12:24:53 <ksf> kmc, in fact, unsafeCoerce fixIO works as mfix for STM.
12:24:55 <shapr> edwardk: You screamt?
12:25:18 <etpace_> > let maxs (y:ys) = mapAccumL (\(x:xs) x' -> case (compare x x') of { (LT) -> (x':[],x'); (EQ) -> (x':x:xs,x'); (GT) -> (x:xs, x') }) [y] ys in maxs [3,2,5,5,5,8,9,9,2,5,5,9]
12:25:19 <lambdabot>   ([9,9,9],[2,5,5,5,8,9,9,2,5,5,9])
12:25:47 <etpace_> > let maxs (y:ys) = fst $ mapAccumL (\(x:xs) x' -> case (compare x x') of { (LT) -> (x':[],x'); (EQ) -> (x':x:xs,x'); (GT) -> (x:xs, x') }) [y] ys in maxs [3,2,5,5,5,8,9,9,2,5,5,9] -- is there a much nicer version of this? :P
12:25:49 <lambdabot>   [9,9,9]
12:25:55 <benmachine> does screamt rhyme with dreamt
12:26:10 <c_wraith> in my accent, yes
12:26:30 <shapr> benmachine: I think so.
12:27:00 <aavogt> etpace_: you have excess parentheses
12:27:32 <etpace_> around the case matching?
12:27:56 <aavogt>  > let maxs (y:ys) = fst $ mapAccumL (\(x:xs) x' -> case compare x x' of (LT) -> ([x'],x'); EQ -> (x':x:xs,x'); GT -> (x:xs, x')) [y] ys in maxs [3,2,5,5,5,8,9,9,2,5,5,9]
12:27:56 <benmachine> and around the LT etc
12:28:06 <aavogt> > let maxs (y:ys) = fst $ mapAccumL (\(x:xs) x' -> case compare x x' of (LT) -> ([x'],x'); EQ -> (x':x:xs,x'); GT -> (x:xs, x')) [y] ys in maxs [3,2,5,5,5,8,9,9,2,5,5,9]
12:28:08 <lambdabot>   [9,9,9]
12:28:18 <aavogt> hmm, I missed some
12:29:57 <poe> what's the specification of maxs?
12:30:51 <etpace_> if there are multiple maximums of the list, return each one as opposed to just one
12:30:54 <aavogt> > foldr (uncurry $ M.insertWith (const succ)) M.empty [3,2,5,5,5,8,9,9,2,5,5,9]
12:30:56 <lambdabot>   No instance for (GHC.Num.Num (a, a1))
12:30:56 <lambdabot>    arising from the literal `3' at <i...
12:31:38 <aavogt> > foldr (flip (M.insertWith (const succ)) 0) M.empty [3,2,5,5,5,8,9,9,2,5,5,9]
12:31:40 <lambdabot>   fromList [(2,1),(3,0),(5,4),(8,0),(9,2)]
12:32:36 <etpace_> itll work on say a list of either Neutrals, Winners, or Losers, and I want to gather all the winners, or all the neutrals, or in the worst case scenario all the losers
12:32:53 <aavogt> > uncurry (flip replicate) $ M.findMax $ foldr (flip (M.insertWith (const succ)) 0) M.empty [3,2,5,5,5,8,9,9,2,5,5,9]
12:32:55 <lambdabot>   [9,9]
12:33:01 <aavogt> > uncurry (flip replicate) $ M.findMax $ foldr (flip (M.insertWith (const succ)) 1) M.empty [3,2,5,5,5,8,9,9,2,5,5,9]
12:33:02 <lambdabot>   [9,9,9]
12:33:05 <ski> > let maxs (y:ys) = mapM (\x0 -> State $ \(x:xs) -> case x `compare` x0 of LT -> (x0,x0:[]); EQ -> (x0,x0:x:xs); GT -> (x0,x:xs)) ys `execState` [y] in maxs [3,2,5,5,5,8,9,9,2,5,5,9]
12:33:06 <lambdabot>   [9,9,9]
12:33:18 <ski> > let maxs (y:ys) = mapM_ (\x0 -> State $ \(x:xs) -> case x `compare` x0 of LT -> ((),x0:[]); EQ -> ((),x0:x:xs); GT -> ((),x:xs)) ys `execState` [y] in maxs [3,2,5,5,5,8,9,9,2,5,5,9]
12:33:19 <lambdabot>   [9,9,9]
12:34:07 <roconnor> ksf: IO *is* lazy:  Try (return undefined >> print "I didn't crash!")
12:34:42 <roconnor> s/print/putStrLn/
12:35:05 <etpace_> :t mapM_ State
12:35:06 <lambdabot> forall s b. [s -> (b, s)] -> State s ()
12:35:25 <poe> > join (filter . (==) . maximum) (10:[1..10])
12:35:26 <lambdabot>   [10,10]
12:35:39 <ski> the `IO'-effects are not lazy (unless you use `unsafeInterleaveIO')
12:36:11 <copumpkin> return undefined >> x should never fail should it?
12:36:27 <copumpkin> for any monad
12:36:28 <roconnor> copumpkin: Hmm, I guess you are right.
12:36:44 <roconnor> but it is an important property to be aware of.
12:36:49 <copumpkin> yeah
12:36:56 <copumpkin> and I think someone was reporting that for parsec, it does fail
12:37:01 <copumpkin> or maybe not
12:37:01 <benmachine> .o/
12:37:15 <benmachine> that email is actually still a draft
12:37:22 <benmachine> I'm not sure why
12:37:24 * benmachine rereads it
12:37:27 <aavogt> , let maxs (y:ys) = mapM (\x0 -> State $ \(x:xs) -> case x `compare` x0 of LT -> (x0,x0:[]); EQ -> (x0,x0:x:xs); GT -> (x0,x:xs)) ys `execState` [y] in time $ maxs [3,2,5,5,5,8,9,9,2,5,5,9]
12:37:29 <lunabot>  luna: Not in scope: data constructor `State'
12:38:26 <rntz> Can someone explain to me why http://sprunge.us/XhQi results in the error http://sprunge.us/ePMO ?
12:39:41 <trofi> Hey haskell world! latest darcs.cabal contains global -threaded option. Is it utilized implicitely in darcs application?
12:39:58 <brad_larsen> Can someone help me understand (& fix) the space leak in this code?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8884#a8884
12:40:14 <mauke> rntz: because you're trying to make every type an instance of Functor
12:40:19 <benmachine> oh, I never reported that parsec bug because apparently there is a parsec 3.0.0, but cabal won't install it
12:40:37 <benmachine> I tried getting the source from cvs.haskell.org but ran into a problem, viz. cvs
12:41:04 <rntz> mauke: er, no, only those types which fulfill Expr, I hope...
12:41:07 <mauke> rntz: nope
12:41:15 <mauke> that's not how it works
12:41:29 <asdfafddsfas> > let maxs (x:xs) = foldl (\(x:xs) x' -> case x' `compare` x of LT -> (x:xs); EQ -> (x':x:xs); GT -> (x':[])) [x] xs in maxs [3,2,5,5,5,8,9,9,2,5,5,9]
12:41:30 <lambdabot>   [9,9,9]
12:41:38 <benmachine> so if anyone has parsec 3.0.0 installed then I would appreciate a moment of their ghci's time
12:41:50 <mauke> I think of instance declarations as function definitions
12:41:54 <earthy> brad_larsen: the monads are lazy, thus the Sum monoid is built up as a thunk (think foldl)
12:42:21 <mauke> 'instance Expr e => Functor e' ---> 'Functor e = Expr e'
12:42:45 <mauke> i.e. the 'Functor' function accepts any argument, then calls the 'Expr' function
12:42:46 <brad_larsen> earthy, by "monads are lazy", you are referring to the Identity / WriterT?
12:42:50 <earthy> yup
12:43:01 <earthy> their implementations are not strict
12:43:05 <earthy> which is a ... trap of sorts.
12:43:09 <brad_larsen> hmm, I'll say
12:43:20 <defun> Hey, does C-- have it's own standalone compiler, or is it only integrated into GHC? If it has a standalone, how fast is the compilation of C-- code into native code, compared to GCC's C compilers?
12:43:37 <brad_larsen> so, I need a WriterT that is strict in the log type
12:43:46 <brad_larsen> and a strict Identity?
12:43:49 <earthy> yup. check hackage. istr there is one.
12:43:57 <rntz> mauke: this... doesn't help me understand why my code would cause every type to be a member of Functor.
12:43:59 <trofi> there was ocaml compiler for cmm
12:44:17 <edwardk> brad_larsen: note the strictness monad isn't technically a monad, it violates associativity under some conditions
12:44:21 <trofi> @go site:cminusminus.org compiler
12:44:22 <lambdabot> http://www.cminusminus.org/qc--.html
12:44:22 <lambdabot> Title: Quick C--
12:44:29 <mauke> rntz: because the argument has the form e, which accepts anything
12:44:34 <mauke> because it's a type variable
12:44:40 <defun> trofi: looking for it now.
12:44:43 <defun> thanks.
12:44:46 <edwardk> brad_larsen: a strict writert we can do, there is a Control.Monad.Writer.Strict
12:45:05 <edwardk> brad_larsen: the default is Control.Monad.Writer.Lazy
12:45:08 <path[l]__> hi is dons around
12:45:26 <trofi> defun: albeit, i didn't bothered to look at it. it might be horribly outdated
12:45:31 <brad_larsen> edwardk, I tried Control.Monad.Writer.Strict.  Same memory leaks.
12:45:40 <defun> no prob.
12:45:58 <edwardk> brad_larsen: rewinding until i see your original problem statement
12:46:14 <defun> btw, what is the difference between a batch compiler and a dynamic compiler? Is GHC a batch compiler?
12:46:17 <earthy> there's also the building up of the monoid
12:46:28 <earthy> don't know if that is strict or not
12:46:37 <edwardk> yeah neither will be strict enough for you
12:46:39 <brad_larsen> yeah, the def. of Sum in Data.Monoid is lazy
12:46:41 <earthy> it doesn't get forced early
12:47:02 <path[l]__> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3470#a3470 <--- anyone know how I can make this code less ... ugly. And still keep or improve performance?
12:47:30 <edwardk> heh you could use my buggy writer monad in Control.Monad.Ran from monad-ran which is currently _too_ strict ;)
12:47:32 <path[l]__> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3425 <-- it used to be this, but I changed some operations to improve performance
12:47:59 <brad_larsen> hmm
12:48:12 <benmachine> path[l]__: put a line break or two in that list >_>
12:48:29 <edwardk> but perhaps a better option is just to write a SeqWriterT or something that forces the monoid to whnf
12:48:29 <path[l]__> lol ok
12:49:10 <path[l]__> the biggest issue is 3 nested wheres
12:52:50 <brad_larsen> edwardk, experimenting with that now
12:53:13 * trofi asks again: latest darcs.cabal contains global -threaded option. Is it needed at all there?
12:53:39 <aavogt> trofi: ask in #darcs?
12:53:40 <Lemmih> trofi: You might ask in #darcs.
12:53:48 <trofi> ugh
12:53:56 <trofi> thanks, i'll do
12:59:04 <benmachine> okay so I download the cabal sources of a library, I don't want to install it but I want to test it
12:59:18 <benmachine> I built it and have a .o and a .a, how do I tell ghci to link them?
12:59:21 <benmachine> link against them
13:00:06 <benmachine> -lHSparsec-3.0.0 looks for libHSparsec-3.0.0.so while I have libHSparsec-3.0.0.a and HSparsec-3.0.0.o
13:04:43 <etpace_> Whats the {-##-} for the monomorphism restriction
13:05:24 <Cale> etpace_: {-# LANGUAGE NoMonomorphismRestriction #-}
13:05:36 <etpace_> thanks
13:16:24 * gbacon frowns frowns frowns
13:16:33 * copumpkin ponders making a binding to GMP's arbitrary precision floats using type-level numbers
13:19:50 <brad_larsen> I messed around with different placements of strictness annotations and seq, but can't figure out the space leak.
13:19:53 <brad_larsen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8884#a8888
13:19:55 <brad_larsen> any hints?
13:19:59 <brad_larsen> For now, I simply copied the defs. of Control.Monad.Identity, Data.Monoid.Sum, and Control.Monad.Writer.Strict into the sample
13:22:14 <lispy> brad_larsen: you probably want to ask in #haskell
13:22:23 <lispy> brad_larsen: this channel is more for ghc development discussion
13:22:30 <Twey> lispy: Er?
13:22:31 <etpace_> or is it
13:22:32 * Makoryu raises an eyebrow at lispy
13:22:36 <lispy> oh duh
13:22:38 <lispy> Sorry
13:22:38 <Twey> :Ã¾
13:22:42 <lispy> I thought I was in #ghc
13:22:47 * lispy can't read
13:22:50 <Makoryu> brad_larsen: Ignore everything lispy said :p
13:22:56 <lispy> brad_larsen: sorry!
13:22:57 <brad_larsen> lispy:  haha, you had me confused for a second
13:23:01 <brad_larsen> no problem
13:23:14 * lispy goes off to make other n00b mistakes
13:23:18 <lispy> :)
13:26:15 <ehamberg> is there a nice way of sorting a list of Maybe values? (long, naÃ¯ve solution: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8889)
13:28:03 <brad_larsen> > sort [Just 3, Just 5, Just 2, Nothing]
13:28:04 <lambdabot>   [Nothing,Just 2,Just 3,Just 5]
13:28:10 <burp> :D
13:28:34 <burp> > sort $ catMaybes [Just 3, Just 5, Just 2, Nothing]
13:28:35 <lambdabot>   [2,3,5]
13:28:39 <burp> whatever you want
13:28:43 <etpace_> :t catMaybes
13:28:44 <lambdabot> forall a. [Maybe a] -> [a]
13:29:34 <ehamberg> zomg. my brain has died. :(
13:29:55 <brad_larsen> it happens ;-)
13:30:19 <copumpkin> :t graph
13:30:20 <lambdabot> Not in scope: `graph'
13:30:28 <copumpkin> damn people keep getting rid of bindings :P
13:33:02 <Berengal> O_o http://pastebin.com/m33869495
13:34:03 <sw17ch> for any one who's interested: http://www.reddit.com/r/haskell/comments/9fz68/just_for_fun_a_point_to_point_chat_client_in/
13:36:20 <burp> what about netcat? ;)
13:36:26 <copumpkin> meow
13:36:35 * copumpkin does all his IRC in netcat
13:37:18 <mapreduce> Is that legal?
13:37:19 <burp> all these pong's would make me sick :p
13:37:53 <copumpkin> SubStack: you don't believe me?
13:38:03 * copumpkin just replied to SubStack's ctcp in netcat too
13:38:09 <SubStack> that reply was awful fast
13:38:14 <benmachine> a chat client with UDP? o_O
13:38:28 <copumpkin> nobody believes me, not even BCoppens :(
13:38:54 <BCoppens> copumpkin: I just wanted to share your netcat joy!
13:38:56 <benmachine> why on earth would anyone use UDP for chatting
13:38:59 * SubStack suspects that copumpkin is just a fast typer
13:39:21 <copumpkin> :D
13:40:13 <kmc> is there a way to ask the GHC runtime for the total in-memory size of data reachable from a given value?
13:40:34 <Lemmih> kmc: No built-in way.
13:41:06 <mle> kmc: you mean without forcing anything?
13:41:14 <kmc> yeah preferably
13:41:16 <copumpkin> kmc: I expect you could leverage the vacuum inner workings to do that
13:41:36 <Berengal> vacuum forces things, doesn't it?
13:41:45 <copumpkin> well, there's nothing to measure if you don't force it
13:41:52 <mle> Sure there is.
13:42:04 <copumpkin> well, you won't necessarily get an accurate picture if you don't
13:42:06 <mle> But you'd have to measure forced and unforced thunks differently
13:42:14 <mle> Depends on what sort of picture you want
13:42:17 <kmc> i'm implementing a VM with a garbage-collected heap, and want some ad-hoc way to decide when to run the gc
13:42:22 <copumpkin> well say you have an unforced thunk that allocates an infinite list and keeps it all around
13:42:34 <copumpkin> you don't know without running it that it's going to do that
13:42:35 <trofi> There is yet cool utility to gather counters and apply simple functions to them and export as images - rrdtool (mrtg sucessor). Is there haskell bindings or packages with analoguous functionality?
13:42:58 <Berengal> The ghci debugger allows you to not force stuff
13:42:58 <Berengal> Perhaps a combination of those
13:43:00 <mle> copumpkin: sure, but infinite lists are a prime example of why you should have a space measurer that /doesn't/ force
13:43:20 <copumpkin> mle: definitely :P but you sort of need a precise definition of what the measurement represents if you don't
13:43:31 <copumpkin> most people probably don't care about the size of an unevaluated thunk
13:43:35 <copumpkin> but maybe some do
13:43:37 <mle> I do!
13:43:52 <mle> Imagine having some large partially evaluated structure
13:44:14 <mle> It would be useful to know the size of the evaluated bits and unevaluated thunks without making any changes.
13:44:19 <copumpkin> yeah
13:44:26 <mle> sort of side-effect-free heap state analysis
13:44:31 <jix> that would have saved me a lot of thinking today
13:44:36 <copumpkin> I dunno, I think mmorrow made vacuum optionally not force anything
13:44:45 <copumpkin> but then you get almost nothing of interest until you force some stuff
13:44:57 <SamB> copumpkin: it can't chase through unforced things?
13:45:49 <Berengal> Thunks need references visible from the outside, or they could be gced
13:45:56 <copumpkin> SamB: how would that work?
13:45:57 <ski> @type graph
13:45:59 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
13:46:04 <copumpkin> yay, graph is back!
13:46:09 <ski> @type cograph
13:46:10 <lambdabot> forall (ar :: * -> * -> *) a b. (ArrowChoice ar) => ar a b -> ar (Either a b) b
13:46:14 <SamB> copumpkin: the garbage collector can do it!
13:46:23 <copumpkin> SamB: hrm
13:46:31 <kmc> aren't there hooks for heap profiling anyway
13:49:28 <etpace_> What do I need to define for an instance of Ord, compare?
13:49:54 <Cale> Yeah, compare is typically the best thing to define
13:50:29 <Cale> You can also get away with just defining (<=)
13:51:51 <mapreduce> In Typed Scheme, you can type \f x -> f f x, via an inline recursive type declaration.  Do you suppose there's any reason Haskell doesn't support such infinite types?
13:52:10 <copumpkin> ski: :O
13:52:22 <mapreduce> I know there's another way via a newtype or data declaration.
13:52:47 <Cale> mapreduce: Because they're usually mistakes.
13:53:12 <Cale> mapreduce: and if you really want recursive types, you can use newtype and not incur any additional runtime costs.
13:53:50 <SamB> Cale: I thought it was because it would lead to "the type error that never ends"!
13:53:58 <copumpkin> :t ?f ?f x
13:53:59 <lambdabot> on the commandline:
13:53:59 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
13:53:59 <lambdabot> Top level:
13:54:02 <Cale> mapreduce: Inferring infinite types is apparently no trouble, people have written typecheckers which work with them okay.
13:54:05 <copumpkin> :o
13:54:12 <copumpkin> :t \x -> ?f ?f x
13:54:13 <lambdabot> on the commandline:
13:54:13 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
13:54:13 <lambdabot> Top level:
13:54:13 <SamB> gwern: !!!
13:54:20 <copumpkin> that's an odd error
13:54:30 <mapreduce> Cale: What is the extra runtime cost of recursive types?
13:54:45 <mapreduce> Badly worded question; I'm not asking for a number.
13:54:46 <Cale> But there are a lot of simple mistakes which lead to infinite types, and very few actual useful applications of infinite types which wouldn't be just as well off using a newtype.
13:54:53 <Cale> mapreduce: Nothing?
13:54:57 <SamB> mapreduce: there isn't any
13:55:06 <SamB> mapreduce: Cale just meant newtype didn't add any
13:55:16 <mapreduce> I see.
13:55:17 <olsner> hmm, I think I might not know what I'm doing :/
13:55:32 <SamB> Cale: do infinite types actually cause any problems with the HM algorithm?
13:56:47 <Cale> SamB: I'm not 100% sure, but I've heard of people writing typecheckers which work fine with them... I can imagine that you might need to do something a little different with respect to unification.
13:58:09 <olsner> hmm, I think I might not know what I'm doing :/
13:58:33 <olsner> indeed, I'm just sending random text to #haskell (this time up+enter in the wrong window :P)
14:00:51 <etpace_> :t interact
14:00:53 <lambdabot> (String -> String) -> IO ()
14:02:10 <etpace_> How does interact work?
14:02:24 <ski> @src interact
14:02:24 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:02:36 <c_wraith> stdin -> f -> stdout
14:03:00 <c_wraith> to drive yourself quickly mad, try "interact id" in ghci
14:03:40 * roconnor tries
14:03:43 <EvilTerran> interact $ unlines . map reverse . lines -- can be interesting
14:03:46 <clanehin> > fix (\x -> min 0 x)
14:03:51 <lambdabot>   mueval-core: Prelude.read: no parse
14:03:51 <lambdabot>  mueval: ExitFailure 1
14:03:55 <EvilTerran> (for getting a feel for interact, i mean)
14:04:06 <monochrom> min is rather strict on both arguments.
14:04:16 <roconnor> @hoogle interact
14:04:17 <lambdabot> Prelude interact :: (String -> String) -> IO ()
14:04:17 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
14:04:17 <lambdabot> System.IO interact :: (String -> String) -> IO ()
14:04:21 <monochrom> && is much better.
14:04:33 <EvilTerran> > fix (\x -> min 0 x) :: Natural
14:04:34 <lambdabot>   0
14:04:36 <monochrom> > fix (\x -> False && x)
14:04:37 <lambdabot>   False
14:04:51 <clanehin> > fix (\x -> min 0 x) :: Integer
14:04:54 <roconnor> c_wraith: that isn't as maddening as fix error
14:04:57 <lambdabot>   mueval-core: Prelude.read: no parse
14:04:57 <lambdabot>  mueval: ExitFailure 1
14:04:57 <ski> EvilTerran : bah, you was faster :)
14:05:17 <etpace_> Hmm, i'm going to need state with interact
14:05:35 * clanehin thinks more.
14:05:59 <monochrom> min for Integer really needs to examine both parameters before deciding on the answer.
14:06:30 <monochrom> min for Natural probably has and can afford a short circuit.
14:06:55 <clanehin> the Natural impls I've seen are like [()], basically.
14:08:02 * EvilTerran isn't sure how exactly lambdabot's Natural is implemented, but i think it's peano numerals
14:08:12 <ski> @type \f -> do s0 <- getContents; let {(a,s1) = f `runState` s0}; putStr s1; return a
14:08:13 <lambdabot> forall b. State String b -> IO b
14:08:14 <monochrom> Yes.
14:08:25 * ski wonders whether that is useful
14:08:33 <clanehin> I haven't played with lambdabot in a few months I didn't realize she knew Naturals.
14:08:48 * EvilTerran tends to write Mu Maybe instead of [()], but i guess that's just a matter of preference, seeing as they're isomorphic
14:09:03 <olsner> wonderful: (unsafeCoerce :: Word -> a) <$> peek ...
14:09:23 <monochrom> ski: Eh, so the state is the input stream, rather than your own stuff?
14:10:11 <ski> apparently
14:10:29 <clanehin> Mu a = a (Mu a)    ?
14:10:38 <monochrom> Yes clanehin
14:11:33 <monochrom> Îœ a = a (Îœ a) !
14:13:13 <monochrom> Recursion for cats: Meow a = a (Meow a)
14:13:46 <EnglishGent> surely it should involve a cat-a-morphism somewhere? :)
14:13:58 <monochrom> Recursion for cats with infinite co-inductive supply of milk: Meow milk = milk (Meow milk)
14:18:24 <thaldyron> What does it mean when my program outputs "<<loop>>"?
14:18:46 <roconnor> thaldyron: it means your program when into an infinite loop, so GHC stopped it.
14:19:03 <roconnor> GHC can solve the halting problem.
14:19:08 <roconnor> ... sometimes ...
14:19:18 <thaldyron> roconnor: ah, thanks! :-)
14:19:51 <benmachine> I believe there is an exception that it throws in that case
14:19:53 <mauke> blockholed
14:19:58 <roconnor> thaldyron: I ususally get this when I do data-recursion and I ask for a value that end up needing itself to evaluate.
14:19:59 <benmachine> and printing <<loop>> is the default handler
14:20:25 <monochrom> There is a simple case of infinite loop it can detect, usually as simple as "x = x".
14:20:36 <roconnor> ya
14:20:39 <roconnor> > let x = x inx
14:20:41 <lambdabot>   not an expression: `let x = x inx'
14:20:41 <roconnor> > let x = x in x
14:20:47 <lambdabot>   mueval-core: Prelude.read: no parse
14:20:47 <lambdabot>  mueval: ExitFailure 1
14:20:52 <mauke> only in compiled code
14:20:55 <roconnor> :)
14:20:57 <benmachine> I think ghci doesn't detec yeah that
14:21:08 <ray> mueval doesn't either
14:21:52 <monochrom> ghci just blocks. no cpu usage though.
14:22:13 <thaldyron> mhm, well my "loop" isn't that simple: I'm running some tests where a few 1000 threads access the same TVar, so the only loop I have is when a transaction retries
14:22:16 <monochrom> mueval probably just uses wall-clock and aborts.
14:23:18 <clanehin> thaldyron, probably a goof somewhere in your let-statements, you don't usually see <<loop>> from monadic code.
14:24:08 <clanehin> I mean like mapM won't do it ever that I know of.
14:24:44 <monochrom> I should offer to examine it for CDN$1000. :)
14:25:45 <stanv> > map (10^) [0..]
14:25:47 <lambdabot>   [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,100000000...
14:25:57 <mauke> > iterate (10 *) 1
14:25:58 <lambdabot>   [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,100000000...
14:26:26 <stanv> mauke: I want more  shorter
14:26:38 <c_wraith> why are we playing golf?
14:27:03 <aavogt> >map(10^)[0..]
14:27:03 <thaldyron> clanehin: yeah, could also be that there's a bug somewhere in stm-io-hooks which uses unsafeIOTOSTM to implement the retry
14:27:10 <aavogt> > map(10^)[0..]
14:27:12 <lambdabot>   [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,100000000...
14:27:39 <aavogt> but iterate should be faster
14:28:04 <stanv> ok
14:28:53 <clanehin> thaldyron, very much doubt it, but you get points for a small test case.
14:29:03 <stanv> now horror: without `show' convert from Int to String:
14:29:21 <stanv> > let t=1101440312 in map chr $ map (+48) $ reverse $ take (length ( takeWhile (t>=) (map (10^) [0..]))) $ map (uncurry (div.mod t)) (zip (map (10^) [1..]) (map (10^) [0..]))
14:29:22 <lambdabot>   "1101440312"
14:29:42 <etpace_> whats with the +48?
14:29:58 <Makoryu> @pl \t -> map chr $ map (+48) $ reverse $ take (length ( takeWhile (t>=) (map (10^) [0..]))) $ map (uncurry (div.mod t)) (zip (map (10^) [1..]) (map (10^) [0..]))
14:29:58 <lambdabot> map chr . map (48 +) . reverse . ap (take . length . flip takeWhile (map (10 ^) [0..]) . (>=)) (flip map (zip (map (10 ^) [1..]) (map (10 ^) [0..])) . uncurry . (div .) . mod)
14:30:07 <stanv> etpace_: http://www.cs.utk.edu/~pham/ascii_table.jpg
14:30:35 <benmachine> @pl (+1)
14:30:35 <lambdabot> (1 +)
14:30:41 <benmachine> interesting
14:31:08 <Makoryu> stanv: You could also do "map (chr . (+48))" or "map ((+ '0') . chr)"
14:31:18 <Makoryu> The former is fewer characters Â¯\O_o/Â¯
14:31:28 <ray> @pl (/1)
14:31:29 <lambdabot> (/ 1)
14:31:47 <stanv> Makoryu: :))
14:32:07 <tromp> or map ("0123456789"!!)
14:32:33 <mauke> > let f n=let(q,r)=n`quotRem`10in(if q/=0then f q else"")++[r+48] in f 1101440312
14:32:34 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
14:32:34 <lambdabot>    arising from a use of...
14:32:38 <Makoryu> Or map (['0'..'9']!!)
14:32:38 <copumpkin> benmachine: that's a bug, arguably
14:32:42 <mauke> > let f n=let(q,r)=n`quotRem`10in(if q/=0then f q else"")++[chr$r+48] in f 1101440312
14:32:44 <lambdabot>   "1101440312"
14:33:09 <SamB> copumpkin: pretty sure it's intentional though ...
14:33:10 <stanv> @pl zip (map (10^) [1..]) (map (10^) [0..])
14:33:10 <lambdabot> zip (map (10 ^) [1..]) (map (10 ^) [0..])
14:33:34 <benmachine> copumpkin: only if you expect pl to work with pathological Nums, I guess
14:33:47 <copumpkin> SamB: it'd be nice to have a @pl-strict and a @pl-rearrange where you could annotate things for commutativity and have it rearrange things to shorten the expression
14:35:49 <c_wraith> @src reverse
14:35:49 <lambdabot> reverse = foldl (flip (:)) []
14:36:15 <poe> @type ((join zip .) . map) -- stanv
14:36:16 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> [(a, a)]
14:37:07 <stanv> poe: ?
14:37:22 <thaldyron> clanehin: well, my (nondeterministic wrt <<loop>>) test program is at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3472#a3472
14:37:26 <c_wraith> Man, my code to do stanv's assignment really makes me annoyed we got the arabic numeral system backwards
14:37:29 <poe> stanv: sorry you ant two lists
14:37:45 <c_wraith> It has a reverse in it that wouldn't be there if we hadn't managed to screw it up. :)
14:38:21 <copumpkin> edwinb: you around? :)
14:39:03 <mauke> > let f n=let(q,r)=n`divMod`10in(if q/=0then f q else"")++[chr$r+48]in f 1101440312
14:39:05 <lambdabot>   "1101440312"
14:39:20 <ray> my god, that reminds me of some obfuscated c i once saw
14:40:32 <mauke> void f(unsigned n) { if (n / 10) f(n / 10); putchar(n % 10 + '0'); }
14:41:03 <stanv> mauke: I wrote my solution in hour you in few minutes :))
14:41:17 <sbahra> Solution to what?
14:41:18 <benmachine> mauke: wow, I don't think I've ever seen head recursion before
14:41:24 <benmachine> wait I must have done
14:41:28 <copumpkin> lol
14:41:35 <benmachine> well, not like that
14:41:38 <stanv> sbahra: without how' convert from Int to String
14:41:49 <sbahra> stanv, ah. :-)
14:42:05 <mauke> div/mod in a loop is a pretty standard approach
14:42:12 <benmachine> const "" >_>
14:42:33 * aavogt would have used smartAssShow = flip shows ""
14:42:49 <sbahra> benmachine, http://carte.repnop.org/etc/triangle.c
14:43:13 <c_wraith> This is how I'd do it:  let p = (map $ chr . (48+)) . digits ; digits = reverse . digits' ; digits' 0 = [] ; digits' i = let (q, r) = i `divMod` 10 in (r:digits' q)
14:43:14 <clanehin> thaldyron, I'm looking
14:43:22 <c_wraith> note that horrible reverse?  Eww.
14:43:29 <ksf> benmachine, that's how you do it naturally in assembly.
14:43:29 <c_wraith> Why'd we have to get that wrong?
14:43:34 <ksf> ...just push them buggers.
14:43:40 <thaldyron> clanehin: ok, thanks
14:44:02 * benmachine wishes he had a runc analogous to runhaskell
14:44:06 <Peaker> c_wraith: that literal 48 there is ugly
14:44:17 <benmachine> probably wouldn't be too hard to make
14:44:24 <c_wraith> True.
14:44:31 <clanehin> you're using a different STM library.
14:44:36 <mauke> > intToDigit 2
14:44:38 <lambdabot>   '2'
14:44:41 <ksf> benmachine, http://github.com/martine/c-repl/tree/master
14:44:58 <Peaker> is there a foldr-like catamorphism for naturals that works on any Integral instance?
14:45:00 <thaldyron> clanehin: stm-io-hooks which uses the standard library stm to add retryWith and onCommit
14:45:11 <c_wraith> Yes, intToDigit is cleaner
14:45:13 <copumpkin> I wonder if there's an elegant way to invert a matrix in the list-of-lists representation
14:45:27 <SamB> copumpkin: oh, hmm, invert?
14:45:36 <SamB> how do you usually do that?
14:45:37 <c_wraith> let p = (map intToDigit) . digits ; digits = reverse . digits' ; digits' 0 = [] ; digits' i = let (q, r) = i `divMod` 10 in (r:digits' q)
14:45:41 <copumpkin> SamB: multiplicative inverse, or even better, a pseudoinverse :P
14:45:50 <SamB> pseudoinverse?
14:45:50 <olsner> wonderful: (unsafeCoerce :: Word -> a) <$> peek ...
14:45:57 <c_wraith> > let p = (map intToDigit) . digits ; digits = reverse . digits' ; digits' 0 = [] ; digits' i = let (q, r) = i `divMod` 10 in (r:digits' q) in p 2837
14:45:58 <lambdabot>   "2837"
14:46:01 <olsner> damn! again :(
14:46:01 <mauke> c_wraith: don't need those parens
14:46:02 <copumpkin> SamB: well the normal inverse of a matrix is only defined on square matrices
14:46:11 <sbahra> benmachine, I also saw a project called "igcc" on Freshmeat some minutes ago.
14:46:13 <SamB> copumpkin: oh. why's that?
14:46:16 <copumpkin> SamB: or invertible square matrices, that is
14:46:18 <Peaker> copumpkin: what's a pseudo-inverse?
14:46:20 <c_wraith> Eh.  I'm developing by copy & paste on the command line.  Easier to leave them in. :)
14:46:32 <Peaker> copumpkin: also called "normal matrices", no?
14:46:38 * benmachine wows a bit
14:46:42 <copumpkin> Peaker: maybe, not sure
14:46:47 <sbahra> copumpkin, how is your thesis research going?
14:46:49 <mauke> in contrast, here's the shortest perl solution:
14:46:55 <SamB> Peaker: no
14:47:01 <copumpkin> sbahra: not nearly there yet :)
14:47:04 <c_wraith> but the whole "digits = reverse . digits' " bit...
14:47:11 <Peaker> copumpkin: You want Guassian reduction (or the slightly faster algorithms) elegantly defined for list-of-lists?
14:47:12 <clanehin> thaldyron, why do you use retryWith just to do another STM transaction?  Can't you just use orElse?
14:47:13 <c_wraith> Just makes me cry that we can't steal a good idea properly. :)
14:47:14 <olsner> ski: :)
14:47:15 <SamB> normal matrices are m*n
14:47:16 <sbahra> I'm back at square 0 with my graduation project, doubtful of continuing with spinlocks. :-)
14:47:18 <sbahra> copumpkin, heh
14:47:28 <copumpkin> Peaker: yeah, whatever's most elegant, not necessarily fast :)
14:47:33 <ksf> ...ken thompson should have already written a c repl.
14:47:42 <copumpkin> sbahra: just finished my first year, plenty of time still to get going :P
14:47:48 <Peaker> copumpkin: I think guassian reduction on list of lists is unlikely to be very elegant...
14:48:01 <Peaker> c_wraith: what idea?
14:48:10 <ksf> ...it's not like dlopen() is an exotic technique
14:48:14 <Peaker> SamB: what does "normality" mean? I thought it meant the same as invertible
14:48:46 <copumpkin> http://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse
14:48:48 <Peaker> ksf: you can say Python+ctypes is already a C REPL, sort of
14:48:53 <SamB> Peaker: oh, I thought it was meant in the plain-english way
14:49:05 <SamB> meaning "the usual kind"
14:49:10 <Peaker> SamB: oh
14:49:13 <c_wraith> Peaker: Arabic numerals.  They were originally little-endian.  But when we stole the representation, we didn't flip them, even though arabic is written right-to-left.  Hence we made them big-endian
14:49:27 <SamB> stupid mathematicians taking nearly every damn word ...
14:49:35 <c_wraith> And that has complicated algorithms to work with them in text form, ever since.
14:49:38 <sbahra> c_wraith, they were little endian?
14:49:48 <sbahra> c_wraith, you mean in the English language Arabic numerals were still written RTL?
14:49:50 <thaldyron> clanehin: in this simple test case yes, but the point of calling retryWith is to read some data from file and write it in the TVar, and then retry the transaction
14:49:50 <jix> > reverse$unfoldr(\x->do{guard(x>1);let(a,b)=(divMod x 10)in Just(chr(48+b),a)}) 31337
14:49:52 <lambdabot>   "31337"
14:49:53 <Peaker> c_wraith: ah. I am not sure that they actually were intended to be little endian. The wordy numbers in Arabic are big endian, I'm pretty sure (at least starting from 100)
14:50:05 <sbahra> c_wraith, at one point in history, that is.
14:50:36 <ksf> ...anyway, reading through a lisp runtime that made fun use of longjmp blew my mind way more than this boring parse->dlopen repl.
14:50:37 <Peaker> c_wraith: I agree if the world had no big endian anywhere it would be a slightly better place
14:50:41 <sbahra> Peaker, how are you determing endianness?
14:50:43 <jix> uhm got something wrong there
14:50:49 * sbahra doesn't understand
14:50:57 <Peaker> sbahra: more significant appearing earlier is big endian
14:51:11 <sbahra> Peaker, sure, but that is meaningless without more context.
14:51:19 <copumpkin> I wanted an elegant matrix inversion because my sized matrices library needs one, and it's really hard to write complicated algorithms using sized matrices :P
14:51:20 <sbahra> Peaker, in Arabic, everything is RTL.
14:51:25 <SamB> sbahra: yeah
14:51:29 <SamB> so earlier is on the right
14:51:34 <poe> > showInt 31337 ""
14:51:35 <lambdabot>   "31337"
14:51:39 <poe> :P
14:51:40 <Peaker> sbahra: "earlier in the sentence" is pretty clear.  Earlier in RTL text is pretty clear too. So numbers in RTL text are really little endian, but in the sentences they are big endian
14:51:42 <ksf> it said in the faq "why don't you have a compiler?" "our usage of lisp makes compiling senseless, as there's virtually no code that's executed more than once"
14:52:03 <sbahra> Peaker, yes.
14:52:10 <Peaker> copumpkin: just normal guassian reduction?
14:52:13 <c_wraith> I believe the little-endian text representation was al-khorizma's contribution
14:52:29 <c_wraith> You know, the guy we eventually named "algorithms" after.
14:52:32 <copumpkin> Peaker: yeah, that'd be fine, I guess :P
14:52:41 <ski> (sbahra :"RTL" ?)
14:52:44 <SamB> ksf: what usage were they referring to?
14:52:46 <clanehin> thaldyron, does it hang up at linking prog . . . for you?  Weird.
14:52:46 <sbahra> ski, right-to-left
14:53:01 <Peaker> copumpkin: you mean its not based on "Al Gore"?
14:53:08 <copumpkin> ?
14:53:10 <c_wraith> tab fail! :)
14:53:12 <ksf> SamB, highly dynamic web servers.
14:53:14 <Peaker> copumpkin: Al Gore ithm
14:53:16 <thaldyron> clanehin: no, linking works fine here.
14:53:20 <sbahra> haha
14:53:23 <ksf> they actually generated java applets on the fly.
14:53:24 <copumpkin> Peaker: oh!
14:53:28 <c_wraith> Peaker: I think you mean c_wraith, not copumpkin. :)
14:53:30 <SamB> â€®like this
14:53:34 <Peaker> oops :-)
14:54:09 <sbahra> Peaker, I never thought about why they are little endian, really. :-)
14:54:13 <Peaker> Al "Arpanet" Gore
14:54:15 <SamB> ksf: that sounds inefficient for both client *and* server!
14:54:24 <SamB> nevermind likely to not work!
14:54:39 <SamB> (Who has a JVM installed in their browser anymore?)
14:54:40 <sbahra> Peaker, and now after of English, my Arabic is tainted. Left-to-right seems very natural.
14:54:41 <c_wraith> http://en.wikipedia.org/wiki/Muhammad_ibn_M%C5%ABs%C4%81_al-Khw%C4%81rizm%C4%AB that guy.  :)
14:54:45 <Peaker> sbahra: if stuff is indexed with growing indices, little endian is more appealing. I guess in sentences you want to have more significant information earlier, so big endian makes sense there
14:54:56 <copumpkin> anyone want to play with my she code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8890#a8890
14:55:23 <sbahra> Peaker, it makes sense for numbers < 100.
14:55:26 <clanehin> thaldyron, oh nevermind, weird illusion, it just hangs for me, no <<loop>>, which might be right for 15000 threads.
14:55:38 <sbahra> Peaker, (at least considering the phonetic aspects)
14:56:09 <sbahra> 25 is read as "5 and 20", for example.
14:56:18 <clanehin> thaldyron, works fine for me with 15 threads.
14:56:27 <ezyang> Is there any convention for naming pure functions that may throw exceptions?
14:56:33 <c_wraith> 4 and 20 blackbirds, something or other?
14:56:35 <SamB> â€®observe how I must type 001 to get a hundred
14:56:40 <c_wraith> I can't remember my nursery rhymes
14:56:43 <mauke> partial
14:56:55 <Peaker> sbahra: nah, "twenty five" makes more sense in that you might start to operate knowing the first order of magnitude ("twenty") and later adjust for the least digit
14:57:09 * ksf can't find a link in his bookmarks and can't remember the name, either.
14:57:09 <thaldyron> clanehin: yeah, the problem occurs for me only with large # of threads
14:57:09 <Peaker> sbahra: ancient tribes were optimizing latency :-)
14:57:16 <SamB> huh, this RTL/LTR stuff really throws x-chat for a loop
14:57:23 <ksf> but it was in pure, beatifully mind-bending c.
14:57:51 <clanehin> thaldyron, I don't know, all those threads lagged my whole box so I had to terminate.
14:57:52 <ezyang> mauke: so, like partialMemberLookup?
14:58:00 <SamB> it displays fine until you try to select something, then it goes crazy
14:58:53 <jix> ezyang: i think you would call such functions partial... but i wouldn't include it in the name (base libs don't do that either) unless it is very unexpected for such a function to throw exceptions
14:58:53 <ksf> other uses of longjmp include a garbage collector: just allocate to the c stack, and if you hit the top, longjmp to your collector, save all new, reachable, pointers to the heap, and then continue executing, re-using the same stack.
14:59:27 <sbahra> Peaker, :-)
14:59:32 * copumpkin will bbl
14:59:41 <sbahra> Seems reasonable.
15:00:03 <ezyang> jix: I'm asking because (and I've mentioned this before) I feel very dirty putting exceptions in "pure" code
15:00:27 <olsner> btw, if I use mallocArray excessively in ghci, I'll be leaking memory, right?
15:00:28 <bd_> ksf: it's important to run the collector /before/ longjmping... :)
15:00:29 <ksf> SamB, well, continuation-base web apps are never truly light-weight. but then they seemed to need the system primarily for heavily state dependent stuff.
15:01:03 <ksf> ...well I assume that the collector runs in constant stack space.
15:01:12 <ksf> anyway, that's implementation detail.
15:01:24 <mauke> ksf: longjmp destroys the stack
15:01:28 <thaldyron> clanehin: I've changed the code to use the standard STM http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3472#a3474
15:01:33 <Trollinator> elem will tell me if a value is contained in a list. Is there a version that will work efficiently on a sorted list?
15:01:37 <jix> ezyang: ah... still the base libs are full of such functions... but if you really want to mark them i wouldn't prefix them with partial since that could be read as indicating the function only partially does something... as in preparing a lookup or whatever
15:01:39 <Peaker> longjmp sucks. A friend of mine wrote a gcc/x86_64 coroutine scheduler that just swaps out the to-preserve registers/stack, in about 10 minutes.  It can probably be extended for other architectures with similar short times. Why use longjmp? :P
15:01:48 <mauke> Trollinator: dropWhile
15:01:50 <thaldyron> clanehin: retryWith is just a fancy way saying "unsafeIOToSTM forkIO"
15:01:58 <mauke> Trollinator: but you can't get better than O(n) with lists
15:02:08 <Trollinator> i know.
15:02:15 <ezyang> jix: Yes. In which case, I wonder what I should prefix them with
15:02:30 <sbahra> Peaker, huh? How is that an argument against longjmp?
15:02:31 <Peaker> Trollinator: you can buy yourself a slight speed up on a sorted list
15:02:33 <clanehin> thaldyron, I'm not replicating the original problem, do you <<loop>> on the pure STM code?
15:02:44 <Peaker> sbahra: the fact it destroys the stack is, the fact its easily replaceable is another
15:02:48 <Trollinator> it's not about the speed, it's that the said list is infinite.
15:02:51 <jix> ezyang: if you provide another interface that doesn't throw and checks preconditions or uses Maybe s return type you could postfix them with unsafe which is a clear indicator to look up the documentation
15:03:23 <mauke> Trollinator: x == head (dropWhile (< x) xs)
15:03:36 <Trollinator> thanks.
15:03:50 <ezyang> jix: unsafe seems a bit strong
15:04:00 <Peaker> if the list is actually infinite there
15:04:29 <SamB> ksf: of course the stack collector has to run in constant stack -- how else would they know whether or not there was enough space left to run the GC?
15:04:58 <Cale> > let elemOrd x xs = x == head (dropWhile (< x) xs) in elemOrd 25 [1..10]
15:05:00 <lambdabot>   * Exception: Prelude.head: empty list
15:05:04 <Cale> ^^ bad ;)
15:05:16 <mauke> he said infinite list
15:05:20 <Cale> ah
15:05:21 <ski> imo, `unsafe' should only be applied to things which may corrupt the type system, run-time system or destroy purity
15:05:35 <mauke> Cale: [x] == take 1 (dropWhile (< x) xs)
15:05:35 <jix> ezyang: hmm then maybe postfix with partial... but as a prefix for me it doesn't look like an attribute of that function but like a part of the name
15:05:41 <Cale> > let elemOrd x = not . null . takeWhile (==x) . dropWhile (< x) in elemOrd 25 [1..10]
15:05:42 <lambdabot>   False
15:05:49 <Cale> > let elemOrd x = not . null . takeWhile (==x) . dropWhile (< x) in elemOrd 7 [1..10]
15:05:50 <lambdabot>   True
15:06:03 <jix> ski: yeah that's a point
15:06:30 <ski> (and making an operation partial does not count as destroying purity, since you can't detect in (except from `IO', which doesn't count))
15:07:01 <ski> (s/in/it/)
15:07:11 <ezyang> ski: does not or does?
15:07:35 <ksf> partial functions are just a funny way of returning Maybe a.
15:07:38 <jfoutz> head throws an exception. seems like the alternative is a Maybe?
15:07:46 <ski> ksf : no
15:07:52 <thaldyron> clanehin: sort of: I've just added one "print" (see pasted code) and suddenly it seems to hang and use 3.4G memory.
15:07:57 <ksf> ...up to loops, that is.
15:08:07 <ski> ezyang : ".. does not count .."
15:08:20 <thaldyron> clanehin: using the standard STM
15:08:58 <ezyang> To contextualize a little, I'm writing a simple command line program, and there are of course a bunch of error conditions that would necessitate the program terminating with some sort of an error message.
15:09:00 <olsner> what's a "unit numeric type pattern"?
15:09:10 <olsner> @ty undefined :: (1,2)
15:09:11 <lambdabot> Only unit numeric type pattern is valid
15:09:22 <ski> @type undefined :: 1
15:09:24 <lambdabot> Unit
15:09:29 * ksf is worried about the lifetime of the capabilities he returns from his STM actions
15:09:40 <clanehin> thaldyron, yeah that's what I get.  Not only do you have 15000 threads, but they all *fork* and then retry the forking operation.  So boom.
15:09:41 <olsner> O.O
15:09:45 <ski> > Unit
15:09:46 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
15:09:46 <lambdabot>    arising from a use of ...
15:09:48 <ezyang> Using Maybe as the return type means that the function is complete, and it's nice for composition; using exceptions is much more convenient from a systems perspective
15:09:53 <ski> @type Unit
15:09:54 <lambdabot> Unit
15:10:25 <ksf> ...and whether or not holders of a capability should be able to observe whether it's still valid or not, or just make it into a nop.
15:11:14 <SamB> ksf: capability to do what?
15:11:26 <ksf> like changing an element of a structure.
15:11:38 <SamB> do they have a capability to observe the element as well?
15:11:48 <jfoutz> ezyang: how about Either? encounter the error, skip the rest and report?
15:11:48 <ksf> append :: a -> STM ((a->a) -> STM ())
15:12:13 <ksf> SamB, in general, yes.
15:12:18 <endojelly> jfoutz, Error Monad?
15:12:27 <ksf> though you can only read the whole structure, atomically.
15:12:36 <thaldyron> clanehin: hmm, but why does it work without the "print" line then?
15:12:38 <ezyang> jfoutz: It's better, yes
15:12:54 <ezyang> jfoutz: I think I'll try restructuring code to do that and see how much it reduces my Nothing -> throw boilerplate
15:12:58 <clanehin> thaldyron, ok fair question
15:13:22 <ksf> changes to the structure are done through STM continuations inside the structure, to request additional (expensive to calculate) data
15:13:43 <olsner> ski: so, ehm, '1' is an alias for GHC.Generics.Unit, and all other numbers are invalid as types?
15:13:58 <ezyang> one not-so-nice thing is lack of Applicative support for Either by default in mtl
15:14:14 <ksf> regarding soundness it should be safe to make every capability that can't block non-observable.
15:14:22 <jfoutz> ezyang: you can put a type other than string on the left as well, if there are some cases that warrent recovery.
15:14:38 <thaldyron> clanehin: I think each lookup-thread can only fork *one* other retry thread, because if the fork succeeds the if-test doesn't pass for that thread anymore
15:14:41 <ski> olsner : afaik, yes
15:14:49 <ezyang> jfoutz: I think the cleanest way is to put an Exception in the left
15:15:27 <ezyang> What's a good name for a function with signature: Exception e => Either e a -> a?
15:15:49 <jfoutz> ezyang: some people have lamented the ... richness of haskells error handling. http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
15:16:00 <ksf> ezyang, throwLeft?
15:16:01 <iago> fromRight ?
15:16:04 <iago> :P
15:16:12 <ezyang> jfoutz: I know: This is how I got started on this sorry path :-)
15:16:25 <olsner> this is cool, it seems that if I put undefined' in an existential datatype wrapper, I can still use that undefined value to call type-class functions and get the correct instance based on the *type* of the undefined value
15:16:31 <ezyang> iago: Cool, I like that
15:16:32 <endojelly> ezyang, assertRight?
15:16:48 <ski> jfoutz : `Error e' in `instance Error e => Monad (Either e)' should be removed
15:16:51 <iago> well, for Maybe Data.Maybe defines fromJust
15:16:53 <clanehin> thaldyron, I agree that's seems the likely outcome, but I don't think it's guaranteed.
15:17:00 <Saizan> olsner: why would you expect otherwise?:)
15:17:34 <Berengal> olsner, well it'd have to work. Haskell doesn't preserve type information at runtime, so that problem had to be fixed some other way than looking at the values
15:18:03 <hackagebot> moe 2009.9.1 - html with style (JinjingWang)
15:18:06 <olsner> Berengal: good point there
15:19:02 <olsner> I suppose that my 'undefined' is really stored as a tuple (dictionary,reallyUndefined)
15:19:04 <hackagebot> moe 2009.9.1.1 - html with style (JinjingWang)
15:19:14 <ski> (Ceterum autem censeo, `Error'inem esse delendam)
15:19:28 <clanehin> thaldyron, what are you printing?
15:19:53 <ksf> olsner, but if you don't have a way to access you undefined, it won't be there.
15:19:55 <thaldyron> clanehin: print "retrying" (i've updated the pasted code)
15:20:13 <ksf> at least with the appropriate optimisation turned on.
15:20:48 <ksf> ...and dicts can be specialized away, too.
15:20:59 <ksf> if in doubt, look at the core.
15:21:16 <Berengal> How is undefined implemented anyway?
15:21:19 <olsner> this also has the nice effect of allowing me to put phantom types in data structures and access their type-class instances
15:21:27 <ksf> @src undefined
15:21:27 <lambdabot> undefined =  error "Prelude.undefined"
15:21:44 <Berengal> What I really meant was: how is error implemented anyway?
15:21:49 <thaldyron> clanehin: the only thing I can think of is that the stdout handle acquired by print isn't released anymore, but that still doesn't explain the memory leak
15:21:50 <ksf> @src error
15:21:51 <lambdabot> error s = throw (ErrorCall s)
15:22:01 <ksf> @src throw
15:22:02 <lambdabot> throw exception = raise# exception
15:22:44 <ezyang> Doesn't error have different semantics depending on the monad you're in?
15:22:55 <Berengal> It has to be a value that's compatible with all other values, because I haven't been able to segfault it with unsafeCoerce
15:22:56 <ksf> that's fail.
15:22:57 <ezyang> @src Either.error
15:22:57 <lambdabot> Source not found. Are you on drugs?
15:23:02 <ezyang> ah, I see
15:23:05 <ezyang> @src fail
15:23:05 <lambdabot> fail s      = error s
15:23:05 <ksf> ...which usually calls error.
15:23:09 <centrinia> :t error
15:23:10 <lambdabot> forall a. [Char] -> a
15:23:19 <centrinia> :t fail
15:23:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
15:23:28 <ezyang> @src fail :: Either e a
15:23:29 <lambdabot> Source not found. I am sorry.
15:23:34 <olsner> anyway, I would not have been surprised if my undefined-in-wrapper would give me the exception rather than successfully evaluating the type-class function
15:24:19 <olsner> and can I really count on this working as long as the type-class function doesn't evaluate the value it's given?
15:24:34 <ksf> yep, that's what non-strictness is all about.
15:25:02 <Berengal> As long as you can count on the right instances being used for values in existential wrappers, and lazyness
15:25:11 <ksf> you could pass an empty newtype, though, too.
15:25:55 <ksf> there's even XEmptyDataDecls or such, that allow you to write newtype Foo and have a constructor Foo :: * defined.
15:26:29 <ksf> err Foo :: Foo
15:26:35 <ski> no, `EmptyDataDecls' allow `data Foo' with no constructor at all
15:28:18 <ksf> hmmm newtype Foo a = Foo ()
15:28:31 <ksf> then you can do data Bar
15:28:52 <ksf> ...and thus f (Foo :: Foo Bar)
15:29:06 <ksf> ...which is way too verbose.
15:30:29 <clanehin> thaldyron, do you agree it should print "retrying" at least once for each thread?
15:30:58 <thaldyron> clanehin: yes, in fact I believe it should print it exactly once per thread
15:31:52 <clanehin> ok, when I set to 15 threads, it printed "retrying" once during ten different executions.
15:32:28 <ski> (ksf : rather `f (Foo () :: Foo Bar)', then ..)
15:33:08 <ksf> ski, right
15:33:33 <ski> ksf : with `data Foo a = Foo' you'd get `f (Foo :: Foo Bar)'
15:33:33 <ksf> just saynig f (Foo Bar) would be cool, though.
15:35:15 <clanehin> thaldyron, oh, when the main function exits, so goes the entire executable.
15:35:41 <thaldyron> clanehin: ah! that one had me puzzled...
15:36:24 * ksf thinks EmptyDataDecls should work like he described.
15:36:27 <thaldyron> clanehin: maybe it's better to move the print after that atomic block because then it is guaranteed to be printed exactly once.
15:37:14 <genivf> +
15:37:16 <thaldyron> clanehin: because by the time print is run, the Map was already updated, so the if condition can never be satisfied again in that thread
15:39:30 <clanehin> thaldyron, no . . . b/c you fork, you're in a different thread.  I think that you should move this table outside of STM.  Maintain in both places if you need to.
15:39:42 <jethr0> hi, is there an easier way of forcing evalution within IO Monad than using 'seq'?
15:39:57 <clanehin> jethr0, evaluate is in Control.Exception.
15:40:42 <jethr0> thx
15:40:45 <clanehin> thaldyron,  . . . if the goal is never to read the same file twice.
15:41:16 <ezyang> Ok... I think I should bust out a state monad yeah!
15:42:01 <thaldyron> clanehin: what "table"?
15:42:08 <clanehin> thaldyron, the map
15:42:15 <Ryan52> so I want to learn haskell, and I figure that learning from a really good book is gonna be the best way. I currently know C, Ruby, Perl, and a bit of other languages like that..what book should I get?
15:42:25 <ksf> @where rwh
15:42:26 <lambdabot> http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
15:42:30 <ksf> @where lyah
15:42:30 <Saizan> @where LYAH
15:42:30 <lambdabot> www.learnyouahaskell.com
15:42:31 <lambdabot> www.learnyouahaskell.com
15:42:34 <ksf> those two.
15:42:37 <ksf> ...and then
15:42:42 <ksf> @where typeclassopedia
15:42:42 <lambdabot> Byorgey's Typeclassopedia in <http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf>
15:43:25 <clanehin> you can still unsafeIOtoSTM forkIO if you want to, but check the outside table before you fork, or something.
15:43:41 <byorgey> Ryan52: ask lots of questions here, too =)
15:44:02 <SamB> clanehin: that sounds like a REALLY REALLY bad idea
15:44:22 <ezyang> What's a common name for application-wide state (such as the current date, etc.)
15:44:23 <clanehin> SamB, thaldyron is the one already trying to do it
15:44:40 <c_wraith> ezyang: global.  :)
15:44:47 <Ryan52> ok, thanks.
15:45:03 <SamB> clanehin: I think that's meant to be used for temporary evils like printing things
15:45:16 <SamB> that you'll take out after you get a clue what's going on
15:45:21 <ezyang> c_wraith: So... GlobalState?
15:45:45 <c_wraith> ezyang: It would be a clear name...  But it might make some people shudder. :)
15:45:55 <clanehin> SamB: what do you think of stm-io-hooks, then?
15:46:01 <ezyang> Hm...
15:46:20 <ezyang> Maybe I want to instead break this up into bits, and use StateT?
15:46:22 <SamB> @hackage stm-io-hooks
15:46:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stm-io-hooks
15:46:23 <clanehin> clanehin, you could even use the unsafe stuff to just update an MVar, that a value is wanted, and have a single worker thread get the data, instead of forking a lot.
15:46:53 <thaldyron> clanehin: true, I'll take a look at that
15:46:57 <ksf> clanehin, I'd recommend forking off more sibling worker threads that signal each other commands via fifo
15:47:28 <benmachine> so I'm trying to build a lazy list of SDL events - will sequence . repeat $ SDL.pollEvent be lazy?
15:48:04 <Lemmih> benmachine: No.
15:48:18 <ksf> clanehin, have a look at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3477#a3477 for inspiration
15:48:19 <benmachine> aw
15:48:27 <benmachine> is that what unsafeInterleaveIO is for
15:48:37 <Lemmih> benmachine: It's probably easiest to use a Chan.
15:49:22 <clanehin> thaldyron, look at what ksf said to me
15:49:39 <ksf> (could use some annotation here and there)
15:49:54 <ksf> ...in fact, I should make the returned methods newtypes.
15:50:10 <thaldyron> clanehin: thanks, I will
15:50:38 * benmachine wonders if repeat (unsafeInterleaveIO m) is the same as map unsafeInterleaveIO (repeat m)
15:51:22 <aavogt> @type repeat (unsafeInterleaveIO "x)
15:51:23 <lambdabot>     lexical error in string/character literal at end of input
15:51:28 <aavogt> @type repeat (unsafeInterleaveIO ?x)
15:51:29 <lambdabot> Not in scope: `unsafeInterleaveIO'
15:51:40 <ksf> in the latter case, you're guaranteed an oredering of your m's
15:52:09 <ksf> unsafeInterleaveIO is IO a -> IO a
15:52:13 <aavogt> ah
15:52:41 <benmachine> ksf: why is that?
15:53:00 <EvilTerran> because otherwise it'd be unsafePerformIO. or something else entirely.
15:53:01 <ksf> ...it just makes the a lazy. nothing more.
15:53:32 <ksf> ...that is, you break out of the usual sequencing constraint of the IO monad
15:53:52 <benmachine> ksf: what if I did let (a:b:bs) = blah in b `seq` a `seq` ()
15:53:58 <ksf> ...you get your IO a before unsafeInterleaveIO gets its argument.
15:54:28 <ksf> have a look at http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO to get a feel for it
15:54:31 <Lemmih> benmachine: How about using a Chan?
15:54:52 <benmachine> Lemmih: I might do, but I'm curious about how this situation works
15:55:21 <ksf> benmachine, you force the a and b thunks, then return ()
15:55:25 <ksf> ...to whnf.
15:55:59 <Lemmih> benmachine: You are likely to shoot yourself in the foot if you deal with lazy IO haphazardly.
15:56:13 * benmachine is likely to be eaten by a grue
15:56:36 <benmachine> okay, I'll play with things a bit more and then do it the 'proper' way
15:56:51 <benmachine> thanks for your help
15:59:13 <SubStack> wow, happstack types are hard
15:59:20 <SubStack> but finally figured them out for this
15:59:22 <ray> let's go shopping
15:59:30 <SubStack> ray: agree
15:59:50 <SubStack> the magic was lift I guess
15:59:58 <SubStack> still not entirely certain what that does
16:00:04 <ksf> heh. I'm considering changing my code that I just posted to an IxSet, but I don't have the guts.
16:00:11 <c_wraith> lift is actually pretty clear
16:00:14 <c_wraith> :t lift
16:00:15 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
16:00:50 <SubStack> perhaps by itself
16:00:52 <c_wraith> Basically, it's used with transformed monads, to convert a value from the inner monad to the outer one.
16:01:20 <SubStack> that makes some sense
16:02:25 <ray> shopping is hard, let's do algebraic topology
16:02:35 <olsner> if you e.g. wrap IO, you then "lift" "lower-level" IO operations up into your own monad
16:02:55 <olsner> presumably, you're combining low-level monads into your higher-level monads
16:03:13 <ray> you lift me up so i can operate on mountains (of nested type constructors)
16:05:39 <c_wraith> There's a special case for liftIO, though.  I'm not clear on why that was created
16:05:53 <olsner> liftIO is able to lift through any number of transformers
16:06:13 <glguy> liftIO is a sort of "express train"
16:06:14 <glguy> :)
16:06:15 <olsner> while 'lift' only lifts one step
16:06:20 <glguy> monadlib has inBase
16:06:32 <glguy> so that you can express anything to the base monad, instead of only IO
16:06:41 <c_wraith> Ok, then.  That makes more sense
16:06:57 <olsner> ISTR someone produced a type hack called 'elevate' that was an express train from anything to anything
16:08:15 <c_wraith> did it do something convenient like operate in terms of lift?
16:08:32 <kmc> @src MonadIO
16:08:32 <lambdabot> Source not found. Sorry.
16:08:59 <Lemmih> olsner: aka unsafeCoerce?
16:09:14 <kmc> class (Monad m) => MonadIO m where liftIO :: IO a -> m a
16:09:23 <olsner> Lemmih: that's only the express train to fail :)
16:09:36 <c_wraith> Lemmih:  let's assume it's in the context of nested monad transformers. :)
16:10:08 <olsner> I replaced my own unsafeCoerce's with a type family just now :) quite nice
16:17:30 * ksf thinks his code is going to fail badly when stale modification capabilities get run with a stale idea about the state of the model.
16:17:41 <ksf> i.e. it might have been cleared in the meantime.
16:18:39 <erikc> what are you making ksf
16:19:06 <ksf> just a sec
16:21:23 <ksf> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3477#a3478
16:21:27 <ksf> that one should be safe.
16:22:27 <ksf> ...the type is actually sparkAModel :: ListStorea -> IO (Store a)
16:22:57 <ksf> er and the newver == oldver conditions are the wrong way round.
16:23:55 * copumpkin wonders whether his vectors and matrices make sense
16:24:26 <copumpkin> should I allow vectors and matrices of zero-dimension?
16:25:02 <arw_> you mean scalars? yes.
16:25:11 <arw_> quite handy sometimes.
16:25:18 <copumpkin> a scalar would be dimension 1 wouldn't it?
16:25:49 <ksf> ...but... well... I fear that's going to leak capabilities. or at least offer the possibility of them leaking.
16:25:53 <copumpkin> I mean 0 x 0 matrices, m x 0, 0 x n, or vectors of zero elements
16:25:55 <arw_> i was on tensors, sorry.
16:26:19 <copumpkin> my current code allows them, but some results are a little unexpected
16:26:25 <arw_> 0 x n matrices are useless, as well as 0 element vectors.
16:26:58 <copumpkin> for example, a (2x0) matrix times a zero-element row vector gives me a 2-element vector of zeros
16:27:04 <arw_> (the vectors more than the matrices, but still, it just collapses your calculation...)
16:27:14 <copumpkin> really, useless? it's like an empty list, really
16:27:42 <arw_> ehm. that behaviour would be wrong.
16:27:48 <copumpkin> why?
16:28:01 <copumpkin> 2x0 * 0x1 :P
16:28:07 <copumpkin> result should be 2x1
16:28:13 <arw_> something times a zero-element-vector should give you a zero-element vector.
16:28:26 <copumpkin> is thata special case?
16:28:31 <ksf> what would happen to writes to a tchan that can't ever be read from?
16:28:36 <arw_> and a matrix times a row vector is not possible.
16:29:00 <arw_> only matrix times column.
16:29:02 <copumpkin> o.O
16:29:09 <FunctorSalad> zero rows/columns correspond to the zero vector space as codomain/domain (random comment without knowing the context)
16:29:17 <copumpkin> left multiplication vs right multiplication
16:29:33 <arw_> yes, but the ordering matters :)
16:29:33 <FunctorSalad> the mult should only be defined if the dimensions match
16:29:34 <DarthArachides> arw_: unless the matrix is a column vector :)
16:29:45 <copumpkin> arw_: I know, and that's the order I expressed above
16:29:59 <roconnor> > transpose [[],[]]
16:30:00 <lambdabot>   []
16:30:06 <roconnor> > transpose []
16:30:07 <lambdabot>   []
16:30:26 <roconnor> ah, not square
16:30:38 <roconnor> still
16:30:40 <copumpkin> I currently have (^**) :: Vec m a -> Mat m n a -> Vec n a
16:30:50 <copumpkin> (**^) :: Mat m n a -> Vec n a -> Vec m a
16:31:02 <FunctorSalad> copumpkin: it shouldn't need any special casing at first glance
16:31:02 <ksf> > transpose [  [ [],[] ],   [ [],[],[] ]  ]
16:31:04 <lambdabot>   [[[],[]],[[],[]],[[]]]
16:31:12 <copumpkin> and (^**^) :: Mat x y a -> Mat y z a -> Mat x z a
16:31:16 <copumpkin> FunctorSalad: I didn't think so
16:31:42 <ksf> > join . transpose $ [  [ [],[] ],   [ [],[],[] ]  ]
16:31:43 <lambdabot>   [[],[],[],[],[]]
16:31:44 <copumpkin> I'm trying to come up with better names for those operators by the way, if anyone has any ideas
16:31:50 <ksf> > join .join . transpose $ [  [ [],[] ],   [ [],[],[] ]  ]
16:31:52 <lambdabot>   []
16:32:01 <ksf> > join .join .join . transpose $ [  [ [],[] ],   [ [],[],[] ]  ]
16:32:02 <lambdabot>   []
16:32:09 <ksf> > join.join.join.join .join .join . transpose $ [  [ [],[] ],   [ [],[],[] ]  ]
16:32:10 <lambdabot>   []
16:32:13 <ksf> heh.
16:32:16 <FunctorSalad> copumpkin: maybe use the same ones as hmatrix just for consistency?
16:32:33 <FunctorSalad> (if you don't have any strong preference anyway)
16:32:37 <copumpkin> hmm, true
16:32:41 <copumpkin> let me see which it uses
16:33:14 <copumpkin> multiply :: Field t => Matrix t -> Matrix t -> Matrix t
16:33:15 <copumpkin> :(
16:33:52 <FunctorSalad> http://hackage.haskell.org/packages/archive/hmatrix/0.5.2.2/doc/html/Numeric-LinearAlgebra-Interface.html
16:34:03 <copumpkin> ah ok
16:34:17 <copumpkin> I could also go with http://hackage.haskell.org/packages/archive/hmatrix-static/0.1/doc/html/doc-index.html
16:34:37 <copumpkin> those type-level numbers are annoying though
16:34:58 <copumpkin> should just make a simple quasiquoter that constructs them
16:35:43 * FunctorSalad once briefly thought about generating fixed-size packed vectors themselves with TH :)
16:35:51 <FunctorSalad> not sure if it'd be useful
16:35:56 <arw_> hm. on second thought, your behaviour might be correct to get something which is not zero-element from your multiplication example.
16:36:04 <copumpkin> mmorrow did something like that for static FFTs in TH
16:36:10 <copumpkin> arw_: ?
16:36:11 <FunctorSalad> nice
16:36:48 <arw_> copumpkin: some matrix m x n times a zero-element-vector may result in a n-element vector of zeroes.
16:36:55 <copumpkin> that's what I thought
16:37:05 <copumpkin> I didn't put any special behavior for those cases, they just arose out of my other definition
16:37:10 <arw_> copumpkin: but only if every n-element-vector of zeroes is equal to a zero-element-vector.
16:37:23 <FunctorSalad> arw_: it should only be defined if n=0
16:37:32 <FunctorSalad> and then yield the mx0 matrix
16:37:36 <copumpkin> x ^**^ y = Mat . transpose $ map (\col -> map (\row -> foldr (^+^) zeroV $ zipWith (*^) row col) (unMat x)) (transpose (unMat y)) is my matrix multiplication
16:37:38 <kmc> so, the sum of no things is 0
16:37:55 <Makoryu> :t (?!)
16:37:56 <lambdabot> Not in scope: `?!'
16:38:03 <kmc> so the product of an (m x 0) and an (0 x n) matrix is an (m x n) matrix of zeroes
16:38:07 <daz> I want to take each item in a tuple (String, String, String, Integer). I can take the tuple from a list of tuples, but cant take the data types from the tuples.? Is there a polymorphic function for this?
16:38:08 <arw_> FunctorSalad: you can always pad matrices with zeroes, as well as vectors, that doesn't violate anything.
16:38:33 <copumpkin> @let dot = (sum .) . zipWith (*)
16:38:34 <lambdabot>  Defined.
16:38:37 <kmc> daz, the main way to get stuff out of a tuple is to pattern match
16:38:46 <SubStack> aw yiss, I have some operators wrapping around setAttribute now
16:38:53 <SubStack> since I'll be doing a lot of that with this thing I expect
16:39:02 <daz> (x,_,_,_) = x?
16:39:18 <kmc> yeah, within a "let" or a function equation or similar
16:39:20 <copumpkin> :t mul
16:39:21 <lambdabot> forall a. (Num a) => [[a]] -> [[a]] -> [[a]]
16:39:32 <FunctorSalad> arw_: not sure if it wouldn't be better to throw an error on dimension mismatch
16:39:44 <kmc> > let (x,_,_,_) = (3, "foo", 'c', ()) in x + 2
16:39:45 <lambdabot>   5
16:39:49 <copumpkin> arw_: except all my matrices are statically sized
16:39:56 <FunctorSalad> padding can be explicitly (as a matrix, too)
16:40:02 <FunctorSalad> *can be done
16:40:09 <arw_> yes, i would prefer explicit padding, too
16:40:24 <arw_> usually mismatched sizes are some kind of 'type error' in mathematics.
16:40:33 <copumpkin> that's what my code generates too
16:41:00 <copumpkin> but a 2x0 * 0x1 multiplication isn't a type error
16:41:12 <copumpkin> at least not in my current implementation
16:41:23 <copumpkin> I could easily force it to have nonzero sizes, but am not sure if I want to
16:41:25 <FunctorSalad> it's the zero 2x1 matrix, as kmc said
16:41:32 <arw_> should be, actually. because for any multiplication to happen at all, you need to 'resize' implicitly
16:41:35 <copumpkin> yup, that's what I generate
16:41:44 <FunctorSalad> (a map that goes through the zero vector space is zero)
16:41:44 <kmc> > sum []
16:41:45 <lambdabot>   0
16:41:52 <copumpkin> FunctorSalad: yeah
16:42:03 <copumpkin> okay, so I don't need to change this at a all
16:42:21 <roconnor> copumpkin: is this matrix code of yours template haskell driven?
16:42:32 <copumpkin> roconnor: nope, but it's using SHE
16:42:42 <roconnor> oh nice, what does that imply?
16:43:01 <kmc> do you support negative dimensions too? :)
16:43:02 <copumpkin> it's just a preprocessor that conor mcbride wrote to make epigram 2 coding easier, I think
16:43:05 <copumpkin> kmc: nope!
16:43:09 <copumpkin> strictly natural
16:43:11 <roconnor> ok
16:43:21 <copumpkin> roconnor: this is it, if you're interested: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8890
16:43:28 <FunctorSalad> interesting that he wrote it for epigram 2 coding...
16:43:30 <roconnor> copumpkin: what is your selling point?
16:43:43 <copumpkin> roconnor: nothing in particular, it was to experiment with she mostly :)
16:43:51 <FunctorSalad> I already thought he decided to do type theory as haskell addons instead..
16:43:54 <copumpkin> I also incorporated conal's vector-space instances
16:44:04 <copumpkin> FunctorSalad: well, it expands on haskell's syntax
16:44:21 <copumpkin> roconnor: I guess technically, I offer statically dimension-safe vector and matrix operations though
16:44:25 <FunctorSalad> SHE or epigram 2?
16:44:27 <roconnor> I could use a nice matrix library if I am to write my gemetric algebra library I fantasize about writing.
16:44:34 <FunctorSalad> (SHE I'm aware)
16:45:09 <copumpkin> roconnor: hmatrix-static is way faster and just as typesafe, but I didn't really like its approach to it, and wanted to explore the design space a bit
16:45:15 <roconnor> ok
16:45:37 <copumpkin> hmatrix-static is a big load of phantom types piled on top of hmatrix, which is a lapack binding
16:45:48 <roconnor> lapack?
16:46:03 <arw_> ages old fortran linea algebra package.
16:46:03 <roconnor> you mean FFI?
16:46:06 <copumpkin> yeah
16:46:08 <FunctorSalad> highly optimized linear algebra code
16:46:09 <roconnor> ugh
16:46:13 * roconnor likes his haskell pure
16:46:16 <copumpkin> :)
16:46:26 <burp> beat lapack in speed
16:46:32 <copumpkin> you're welcome to use my ugly matrix code if you want, but it's effectively treating matrices as vectors of vectors
16:46:35 <roconnor> it'd be awesome if you manage to have (almost) compatible interfaces.
16:46:51 <arw_> many people have tried replacing lapack and stuff for the last 20 years, nobody succeeded yet.
16:46:53 <copumpkin> that would be cool actually, maybe I'll strive for it
16:46:55 <roconnor> matrices are like vectors of vectors.
16:47:34 <roconnor> granted I'm more into linear operators than matrices myself.
16:47:37 <copumpkin> roconnor: yeah, but my vectors are inductive and I can't index into them in constant time
16:47:53 <copumpkin> so my matrix multiplication code involves a transpose
16:48:05 <copumpkin> it's effectively mul a b = transpose $ [[x `dot` y | x <- a] | y <- transpose b]
16:48:07 <roconnor> copumpkin: that's okay.  I only need like 5x5 matrices at most for 3d geometric algebra.
16:48:15 <roconnor> er
16:48:22 <copumpkin> ah fair enough, maybe I'll try to polish it up a bit then
16:48:25 <roconnor> or was that 2^5 x 2^5
16:48:28 <copumpkin> lol
16:48:30 <roconnor> anyhow
16:48:44 <roconnor> > 2^5*2^5
16:48:45 <lambdabot>   1024
16:48:54 <daz> when pattern matching will it match against multiple patterns? or will it just return after it hits the first pattern that it matches.
16:49:11 <CalJohn> daz: the latter
16:49:24 <benmachine> daz: er, what do you mean?
16:49:47 <CalJohn> daz: pattern matching is attempted from top to bottom of equations
16:49:58 <arw_> otherwise otherwise wouldn't work.
16:50:06 <benmachine> you can match multiple patterns in a single expression
16:50:10 <benmachine> er, equation
16:50:14 <FunctorSalad> roconnor: even 3d polyhedra can need arbitrarily many rows already ;)
16:50:25 <CalJohn> benmachine: you can?
16:50:31 <FunctorSalad> (not sure what exactly you're up to of course)
16:50:37 <Axman6> daz: how would matcvhing multiple times work?
16:50:40 <benmachine> CalJohn: I mean like zip (x:xs) (y:ys)
16:50:53 <CalJohn> oh right, was going to say :)
16:52:44 <daz> Im not matching against more than 1 pattern, I just need to have another function to match another pattern after i get my returned value.
16:53:16 <ksf> nargh I hate it when yield changes semantics
16:53:33 <Axman6> daz: ... how could that possibly work?
16:53:36 <roconnor> FunctorSalad: I was thinking of sticking to planes points spheres and circles and the like for this layer
16:53:41 <CalJohn> daz: best to paste, i think, you are being a bit ambigious
16:53:57 <CalJohn> daz: (to a pastebin)
16:54:01 * copumpkin goes back to writing a beautiful algebra library to tie his matrices into
16:54:06 <Axman6> @where hpaste
16:54:06 <lambdabot> http://hpaste.org/
16:54:12 <Axman6> daz: ^^^^^^^^^^^^^
16:58:23 <sshc_> Is "Haskell" pronounced with emphasis on the first or second syllable?
16:58:38 <lament> a-HAskell!
16:59:30 <FunctorSalad> haskle ;)
16:59:42 <FunctorSalad> but seriously, I think first
17:02:55 <c_wraith> Rhymes with rascal
17:03:06 <kmc> does *not* rhyme with Pascal
17:03:16 <kmc> :)
17:03:20 <CalJohn> that depends how you pronounce rascal
17:03:30 <CalJohn> "hass-kell"
17:03:42 <CalJohn> "rahs-kell"
17:04:01 <c_wraith> In both cases, I weaken the latter vowel to a schwa
17:04:07 * ksf obviously yet didn't find the right design primitives for STM, or he wouldn't drown in races
17:04:09 <Ryan52> then how do you say Pascal?
17:04:10 <sohum> are there any functions of the form "Num a => a -> Int"
17:04:12 <sohum> ?
17:04:27 <CalJohn> "pass-cal"
17:04:42 <kmc> @hoogle Num a => a -> Int
17:04:42 <c_wraith> accent on the second syllable in Pascal
17:04:43 <lambdabot> Prelude abs :: Num a => a -> a
17:04:43 <lambdabot> Prelude negate :: Num a => a -> a
17:04:43 <lambdabot> Prelude signum :: Num a => a -> a
17:04:51 <kmc> :t fromIntegral
17:04:52 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:04:53 <Ryan52> CalJohn: ah. thanks.
17:04:59 <kmc> :t floor
17:05:00 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:05:24 <sohum> hoogle, shiny
17:05:30 <arw_> so the 'kell' would be like in 'kelly' and 'cal' like 'california'?
17:05:50 <ksf> ...the important point is that pascal was french, and his name's not paiscelle.
17:05:55 <arw_> .oO( phonetic foo is complicated in english... )
17:06:22 <CalJohn> arw_: roughly, I think, you are picking American states, which makes me think you have an American accent - I don't so maybe different
17:06:23 <ksf> unlike english, french has a sound and sane, albeit a bit verbose, spelling.
17:06:25 <c_wraith> arw_:  I'd weaken the vowel sound in the second syllable of haskell even more.  To about the level of...  not being pronounced.  A schwa, as linguists call it.
17:07:05 <CalJohn> ksf: english has a semi sane spelling if you have the right accent
17:07:17 <arw_> CalJohn: i'm german, so i guess my accent would sound accordingly :)
17:07:26 <ksf> ...which americans don't, but they think it's the only one.
17:07:47 <c_wraith> At least we recognize that "r" has a sound. :)
17:07:51 <chessguy> :r
17:07:54 <chessguy> gah
17:08:10 <ksf> "r" is defined to "a" in northern germany.
17:08:19 <CalJohn> heh, recently I was asked by a californian girl when in the netherlands "Nice accent!  Are you dutch?"  I sound _very_ english.
17:08:34 <jix> ksf: not in all cases
17:08:38 <c_wraith> Yes well.  all non-american accents are the same.  :)
17:08:50 <nvoorhies> they're all legacy english
17:08:53 <ksf> yeah well sometimes it's a umlaut.
17:08:57 <nvoorhies> deprecated
17:09:00 <arw_> ksf: only on the end of words. in the beginning and in most middle positions its always rolled. like in 'rollen'
17:09:00 <ksf> ...especially "er"
17:09:08 <centrinia> Conversely, all American accents are the same. :)
17:09:13 <chessguy> ok, so i've got an interesting new little DSL idea, and there are a billion things i could do with it, now i've just gotta figure out where to start :)
17:09:23 * ksf does gluttoral r's.
17:09:33 <ksf> ...and everyone I know.
17:09:33 <c_wraith> No, centrinia, there are two.  "american" and "southern".  ;)
17:09:35 <jix> ksf: well try to pronounce arithmetik without a r
17:09:45 <jix> or r as a or whetever... that just doesn't work
17:09:48 <arw_> ksf: but yes, in '-er' the r is weakened, as is the 'e' in '-en'.
17:09:52 <CalJohn> chessguy: :p  Actually, I am starting to be able to tell quite a few of the states apart
17:10:01 <ksf> "ahidmedig"
17:10:02 <CalJohn> *centrinia:
17:10:16 <jix> ksf: well i never heard anyone pronouncing it that way
17:10:20 <ksf> oder eher "ahimeddik"
17:10:22 <centrinia> CalJohn: :p
17:10:54 <jix> and the r for example in begriff ... you can't replace that either
17:10:55 <ksf> that's because only prententious math professors use the word :)
17:10:57 <arw_> arithmetik would always have a rolling r.
17:11:09 <ksf> jix, that's right.
17:11:14 <arw_> everything else is the sure sign of some english native speaker :)
17:11:40 <jix> ksf: also words starting with an r ;)
17:12:09 <jix> but i guess you are right with all 'r's that are followed by another consonant
17:13:55 <jix> ksf: yeah just tested it by reading stuff aloud... omitted/replaced all 'r's in fornt of consonants
17:15:24 <ksf> ...so it's "spieka" for "speaker". or "speakurr" when you want to sound american.
17:16:05 <ksf> "spiekae"
17:16:36 <FunctorSalad> ksf: "arithmetik" is pretentious?
17:17:29 <ksf> Wääänääää! Egaaaaahd!
17:18:02 <ksf> FunctorSalad, at least as much as using the word "pretentious"
17:18:09 <arw_> thats dialect. thats not even real german according to some :)
17:18:25 <sohum> ok, why is http://haskell.pastebin.com/d46204627 undecidable?
17:19:26 <Berengal> sohum, I don't think that's a valid instance
17:19:57 <ksf> FunctorSalad, you'd normally use "rechnen", to calculate, in german.
17:20:16 <ksf> it's like using "konversation" instead of "unterhaltung"
17:20:51 <ksf> "we congruated at the intersection and conversed"
17:21:01 <kmc> sohum, you could have instance (S a) => (T a) and instance (T a) => (S a)
17:21:05 <kmc> and it would go round in a loop
17:21:06 <FunctorSalad> ksf: I thought it's standard in logic though
17:21:17 <sohum> kmc: you could, but you don't
17:21:20 <kmc> for this reason Haskell 98 restricts the context for an instance to look like C a b c d
17:21:28 <kmc> well, this is what is meant by "undecidable"
17:21:46 <arw_> FunctorSalad: as part of scientific language, yes. but not what you would use on the street.
17:21:49 <kmc> it's not doing the whole-program analysis to find out if that is the case
17:21:52 <kmc> which is in the general case impossible
17:22:02 <arw_> FunctorSalad: and also not always what you would use at university.
17:22:04 <kmc> because you can encode arbitrary computations as relations at the typeclass level
17:22:31 <kmc> the H98 restriction forces the things under consideration for typeclass membership to shrink at every step, which makes it decidable
17:22:38 <FunctorSalad> arw_: not for "rechnen", but e.g. peano-arithmetik ;)
17:22:46 <arw_> FunctorSalad: correct.
17:22:46 <ksf> "eklatant unrezeptabel"
17:22:51 <sohum> kmc: what do you mean, "shrink"?
17:22:52 <kmc> otherwise, run ghc with -XUndecidableInstances and see if it hits the set recursion simit
17:22:54 <kmc> limit*
17:23:55 * FunctorSalad remembers a costudent going on at greath length about someone's use of the word "perpendikular" (in german)
17:24:01 <FunctorSalad> ;)
17:24:07 <kmc> sohum, see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules
17:24:15 <kmc> sorry, i stated it wrong above
17:24:16 <FunctorSalad> or maybe not great length, but enthusiastically
17:24:45 <arw_> FunctorSalad: ugh. yeah, that would bother me too, because thats a false translation from english.
17:24:57 <kmc> the head (the thing after the context, that the declaration is for) has to be of the form (C (T a b c ...)) where C is your class and T is a type constructor, and a,b,c are only type vars
17:25:09 <kmc> and your constraints are only allowed to be on those vars
17:25:50 <arw_> FunctorSalad: and even if it wasn't wrong, it should be 'perpendikulÃ¤r'
17:26:15 <FunctorSalad> :)
17:26:36 <ksf> sohum, associated data type?
17:26:53 <ksf> ...before you're going the dark road of undecidable instances.
17:27:14 <sohum> kmc: that's really interesting
17:27:22 <sohum> ksf: sorry? how would that help here?
17:27:28 <jix> is there something like a combined map and zip?
17:27:42 <Berengal> sohum, also, 'id' isn't a correct implementation of smerf for integrals
17:28:05 <jix> (a->b) -> [a] -> [(a,b)] that is
17:28:12 <kmc> suppose you have "instance (D a) => C (T a b)".  if the compiler wants to find an instance for "C (T a b)" it may recursively look for an instance for "D a".  but the type "a" is structurally smaller than "T a b" so this process will always terminate
17:28:25 <sohum> Berengal: yea, I figured that out, sorry
17:28:28 <ksf> class Smerfable a where data NoSmerf a ; smerf :: NoSmerf a -> a
17:29:13 <ksf> ...and a couple of newtypes etc. pp.
17:29:25 <sohum> ksf: I'm not sure I follow
17:29:43 <ksf> the trick is to express the same, but not in instances but data types.
17:30:00 <ksf> sohum, that's because I can't figure out what you want to do from that limited example.
17:30:02 <Colours> hello! I am trying to use a recursive function with a return type of IO (), is there some kind of function that returns IO () but doesn't actually do anything?
17:30:15 <ksf> sohum, http://www.haskell.org/haskellwiki/GHC/Type_families
17:30:18 <kmc> :t return ()
17:30:19 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
17:30:27 <Berengal> ksf, more like data SmerfInt where SmerfInt :: (Integral a) => a -> SmerfInt; instance Smerfable SmerfInt where smerf si = case si of SmerfInt i -> fromIntegral i
17:30:43 <Colours> oh oops that was silly of me thank you :3~
17:32:01 <kmc> is there a way for my program to ask the GHC runtime how much heap space is used
17:32:12 <Berengal> Speaking of existentials, what do people think of existentials without wrappers?
17:32:56 <ksf> ...or class Smerfable a where data Smerf a ; smerf :: a -> Smerf a
17:33:13 <ksf> ...which was what I though and what I should have written.
17:33:40 <Lemmih> kmc: Run your program with +RTS -s -RTS.
17:34:39 <kmc> i mean within the program, perhaps as a value of type IO Integer or so
17:35:22 <kmc> i'm implementing a VM with a garbage-collected heap, and want some ad-hoc way to decide when to run the gc
17:35:34 <kmc> (this came up earlier from a somewhat different angle)
17:36:50 <jix> how would you name a function foobar f a = (a, f a) ?
17:37:08 <kmc> @pl \f a -> (a, f a)
17:37:08 <lambdabot> ap (,)
17:38:23 <jix> uh ok
17:38:30 <jix> now i have to figure out why that works
17:38:37 <kmc> :t ap (,)
17:38:38 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
17:38:42 <kmc> :t ap
17:38:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:38:51 <jix> where is the monad here?
17:38:55 <kmc> jix, (->) a
17:40:05 <Makoryu> jix: The instance for that is in Control.Applicative, IIRC
17:40:14 <Makoryu> (Or Control.Monad)
17:40:20 <Makoryu> (Doesn't make much of a difference)
17:42:21 <jix> hmmm i can't finde the source for that instance
17:42:31 <kmc> check Control.Applicative
17:42:34 <jix> ah just found it
17:42:36 <Makoryu> @instances (->) a
17:42:36 <lambdabot> Couldn't find class `(->) a'. Try @instances-importing
17:42:44 <jix> in Control.Monad.Instances
17:42:51 <kmc> it's like a read-only state monad
17:42:59 <kmc> or like the Reader monad (isomorphic to, iirc)
17:43:34 <sshc_> how would I write "main = do { getLine; putStrLn "foobars"; }" without using do? (using >>='s)
17:43:48 <kmc> @undo do { getLine; putStrLn "foobars"; }
17:43:49 <lambdabot> getLine >> putStrLn "foobars"
17:44:02 <ksf> hey priority-sync looks nice
17:44:09 <Makoryu> sshc_: getLine >>= putStrLn
17:44:22 <jix> sshc_: or getLine >>= const (putStrLn "foobars") if you want to use >>= ... but you should use >>
17:44:32 <Makoryu> sshc_: Er...... yeah
17:44:40 <mmorrow> kmc: was just reading the logs.. this is a (no guarantees) way to ask GHC about heap use (from w/in haskell) http://moonpatio.com/repos/MemStats.hs
17:45:08 <kmc> sshc_, translate "do { a ; b; ... }" to "a >> do { b; ... }"
17:45:12 <mmorrow> no guarantees, because it seems to behave really oddly on osx (dunno why)
17:45:26 <kmc> sshc_, translate "do { x <- a ; b; ... }" to "a >>= \x -> do { b; ... }"
17:45:38 <mmorrow> it seems to work fine for me though (x86_64 linux)
17:45:42 <Makoryu> mmorrow: Because Apple made up anticompetitive binary formats!1!1111!1!1!cos(0)!1!!
17:45:50 <kmc> mmorrow, thanks
17:46:04 * Makoryu hides under a tinfoil hat
17:46:53 <mmorrow> kmc: np
17:47:17 <mmorrow> Makoryu: "cos(0)" :)
17:47:20 <jix> ok but using ap (,) will make my code pretty unreadble i'd say
17:47:33 <kmc> you can just foreign call ghc internals like that?
17:47:40 <kmc> do i have to link anything special?
17:47:53 <jix> so i still need a name describing what it does
17:48:10 <mmorrow> kmc: nope, since conveniently the haskell code can assume teh rts
17:48:36 <mmorrow> ghc -O2 --make MemStats.hs
17:48:40 <mmorrow> works for me
17:49:12 <kmc> jix, how about "pairApp"
17:49:18 <kmc> or actually i'd call it "pairMap id"
17:49:29 <kmc> @pl \f g (x,y) -> (f x, g y)
17:49:30 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
17:49:42 <kmc> yeah uh that's pairMap
17:50:14 <kmc> @hoogle (a -> b) -> (c -> d) -> (a, c) -> (b, d)
17:50:14 <lambdabot> No results found
17:50:45 <kmc> :t (***) id
17:50:46 <lambdabot> forall b b' c'. (b' -> c') -> (b, b') -> (b, c')
17:50:56 <kmc> there we
17:50:57 <kmc> go
17:51:23 <kmc> wait that's not right either
17:51:42 <kmc> :t (&&&) id
17:51:43 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
17:52:04 <kmc> :t (id &&&)
17:52:05 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
17:52:56 <kmc> i'd say (id &&&) is a fine name for it
17:53:18 <jix> yeah i agree :)
17:53:38 <jix> because from the documentation of &&& one can deduce what it does easily
17:53:47 <jix> which isn't that case with ap (,)
17:54:23 <endojelly> how would you go about tracing each modification a more complex operation does on a rich structure like some special trees? I was thinking a Zipper for the tree and a Writer monad, what do you think?
17:56:12 * copumpkin struggles with random type system woes
17:56:14 <endojelly> each small operation would change the loc part of the zipper and append the whole resulting tree to the writer monad
17:56:53 <ezyang> I'm having difficulty seeing the maintainability benefits from the reader monad :-(
17:57:26 <endojelly> ezyang, imagine passing two, three or even more arguments to almost every function of a module
17:57:57 <ezyang> I would still have to "ask" it all out again, no?
17:58:05 <endojelly> ezyang, instead you will quickly come to realize that putting it as state into a State monad will be easier
17:58:13 <chessguy> @pl r t = e t . f
17:58:13 <lambdabot> r = (. f) . e
17:58:17 <endojelly> ezyang, but then it can be modified, maybe you don't want that!
17:58:25 <endojelly> ezyang, well, yes, you have to ask, but only if you really need it
17:58:33 <jix> ezyang: but all the cases where you just pass the parameter along
17:58:37 <jix> ezyang: without using it
17:59:26 <ezyang> endojelly: Actually, that's exactly how I got here: I figured I should use the state monad for something, realized the state wasn't mutable, figured I should use the reader monad, and then failed to see how it made my code better.
17:59:40 <endojelly> ezyang, imagine you're writing an interpreter that evaluates functions with arguments. when evaluating the expressions, you need to always have the arguments which were passed to the function ready in case they get accessed in any expression. a lot of time, you will just pass them around
18:00:21 <ezyang> I suppose I don't have those layers of nesting in my example
18:00:36 <endojelly> ezyang, if almost every function branch uses that something, then the reader monad may not be better
18:01:03 <endojelly> ezyang, but if it's something that you just need sometimes but still has to be passed along all the time... definitely Reader
18:01:17 <ezyang> endojelly: ohh, that's interesting
18:02:23 <endojelly> ezyang, I'm pretty sure you'll come across a scenario where the Reader monad will be beneficial, eventually 8)
18:02:29 <endojelly> it's a really common pattern
18:03:00 <ezyang> Maybe I should just force myself to write it monadically, even if it's not optimal
18:03:10 <ezyang> Since this is a toy program
18:03:46 <endojelly> in fact, when I started I didn't really know about it and instead decided wether to pass the arguments along, which I thought made ugly long types to include stuff I seldom need, or use the State monad and grind my teeth because the State could be changed.
18:04:04 <endojelly> it was very nice when I discovered the Reader monad 8)
18:04:12 <ezyang> :-)
18:04:21 <endojelly> and THEN I often combined the two
18:04:24 <ezyang> Also, I wonder if I want to use (->) or Control.Monad.Reader
18:04:29 <endojelly> until I finally realized that there is an RWS monad
18:04:39 <endojelly> which combines Reader, Writer and State
18:04:44 <ezyang> whoa, neat
18:04:44 <endojelly> most useful monad ever :D
18:05:25 <ezyang> Hmm... should I preemptively create an algebraic data type for my reader?
18:05:38 <endojelly> for interpreters it's great. arguments are often immutable, while local variables are mutable. the Writer part can be used for tracking errors and warnings or similar stuff, or just as ()
18:06:02 <endojelly> ezyang, records can be beneficial
18:06:07 <ezyang> ok
18:06:21 <ezyang> I only have one, but it could increase (maybe... well, actually, not really_
18:06:25 <ezyang> *one value
18:06:52 <endojelly> well if it really *can't* increase, use the type directly 8)
18:07:05 <endojelly> refactoring is not hard in that case
18:07:16 <endojelly> and you'll spare yourself the record stuff
18:07:21 <ezyang> savvy
18:07:38 <endojelly> oh wait
18:07:39 <endojelly> Reader
18:07:52 <endojelly> let me check something
18:08:35 <endojelly> @hoogle Reader a m => (a -> b) -> m b
18:08:36 <lambdabot> Warning: Unknown class Reader
18:08:36 <lambdabot> Data.Generics.Aliases GQ :: GenericQ r -> GenericQ' r
18:08:36 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
18:09:11 <endojelly> :t asks
18:09:12 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
18:09:12 <ray> :t Reader
18:09:13 <lambdabot> forall r a. (r -> a) -> Reader r a
18:09:14 <endojelly> yep, nice
18:09:24 <ray> like an inverse of that?
18:09:34 <ray> or, never mind
18:09:43 <endojelly> ezyang, it's okay, use the record. since you can't mutate it anyway, the difference in usage will be just typing "asks foo" (where foo is your record) instead of "ask"
18:10:44 <endojelly> ezyang, it's more of a hassle with the State monad, when modifying the value
18:11:57 <endojelly> ray, I just forgot that the class was named MonadReader, not Reader, which is a type :P
18:12:01 <ezyang> Right. Records are hasslesome
18:12:07 <endojelly> @hoogle MonadReader a m => (a -> b) -> m b
18:12:07 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
18:12:07 <lambdabot> Data.Generics.Aliases GQ :: GenericQ r -> GenericQ' r
18:12:07 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
18:12:42 <ray> endojelly: yeah, i'm just jumping in without reading things
18:13:16 <endojelly> ray, yeah I do that too :P
18:15:26 <endojelly> ... unless you *do* modify the5C5C value in your Reader monad. just like simply passing the value as an argument you can modify it before passing it along
18:15:41 <endojelly> in MonadReader, you do that with "local"
18:16:17 <endojelly> you just can't get a modified value back, like you would in State.
18:18:18 <chessguy> @pl i p = p . r
18:18:19 <lambdabot> i = (. r)
18:19:00 <Makoryu> :t liftA2 (/) sum length
18:19:01 <lambdabot>     No instance for (Fractional Int)
18:19:01 <lambdabot>       arising from a use of `/' at <interactive>:1:7-9
18:19:01 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
18:19:06 <Makoryu> >:|
18:21:19 <Makoryu> :t liftA2 div sum length
18:21:21 <lambdabot> [Int] -> Int
18:28:10 <centrinia> > (liftA2 div sum length) [1..5]
18:28:11 <lambdabot>   3
18:28:45 <centrinia> :t liftA2 (/) sum length
18:28:46 <lambdabot>     No instance for (Fractional Int)
18:28:46 <lambdabot>       arising from a use of `/' at <interactive>:1:7-9
18:28:46 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
18:28:53 <Makoryu> :t genericLength
18:28:54 <lambdabot> forall b i. (Num i) => [b] -> i
18:29:03 <centrinia> :t liftA2 (/) sum genericLength
18:29:04 <lambdabot> forall a. (Fractional a) => [a] -> a
18:29:12 <centrinia> @let average = liftA2 (/) sum genericLength
18:29:13 <lambdabot>  Defined.
18:29:23 <Makoryu> > average [1..20]
18:29:24 <lambdabot>   10.5
18:30:12 <centrinia> > average [85,20,0,58,92,0,35]
18:30:14 <lambdabot>   41.42857142857143
18:31:13 <vav> > average [0,0,10]
18:31:15 <lambdabot>   3.3333333333333335
18:31:27 <vav> > average [0,0,10] :: CReal
18:31:28 <lambdabot>   3.3333333333333333333333333333333333333333
18:34:15 <Makoryu> Now to come up with some Num instances that will let us write "1 2 3" for "[1, 2, 3]"...
18:34:32 <centrinia> That would be hardcore.
18:35:50 <Athas> Is anyone doing anything with XHB at the moment?
18:36:26 <Makoryu> "instance Num a => Num ([a] -> [a]) where..." <- Let's start with that
18:39:19 <chessguy> Makoryu, are you expecting to also be able to do things like 'x + y' where x and y are instances of Num?
18:39:25 <Makoryu> chessguy: Yes
18:40:34 <Makoryu> chessguy: I also realize this is total madness on my part to try and abuse the type system like this...
18:41:03 <Athas> Is it possible to combine C and Haskell in the same program with Cabal?
18:41:24 <Athas> It's almost exclusively Haskell, but I fear I'll need a little amount of C glue that can't be done just by FFI'ing.
18:42:31 <Draconx> Athas, you can list c source files somewhere in the .cabal file, I forget what field.
18:42:49 <Draconx> Athas, this works as long as you don't mind cabal running the C compiler.
18:42:50 <path[l]__> would anyone be able to help me beautify a peice of haskell code without losing performance? (or with an improvement in)
18:43:00 <path[l]__> de-uglify would be more right
18:43:30 <path[l]__> I have 3 nested wheres in a function
18:43:52 <Athas> Draconx: I could probably live with that.  I don't need very complex C.
18:44:27 <kmc> @src msum
18:44:27 <lambdabot> msum =  foldr mplus mzero
18:44:49 <Draconx> Athas, ah, "C-Sources: foo.c bar.c" in the Executable section.
18:45:07 <kmc> @src MonadPlus (Either a)
18:45:07 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:45:14 <kmc> @src MonadPlus Maybe
18:45:14 <lambdabot> Source not found. There are some things that I just don't know.
18:45:31 <kmc> @instances MonadPlus
18:45:31 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
18:46:31 <sohum> path[l]__: have a look at hslint
18:46:36 <Athas> Draconx: thanks.
18:49:25 <Makoryu> @src foldl
18:49:25 <lambdabot> foldl f z []     = z
18:49:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:49:28 <aavogt> wow, -XPatternGuards looks interesting in case expressions...
18:49:37 <aavogt>               | Just (MkKeyPressEvent {}) <- fromEvent ev -> exitSuccess
18:50:13 <path[l]__> ok
18:50:15 <path[l]__> thanks
18:50:50 <kmc> :t foldr1
18:50:51 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:50:56 <path[l]__> heh it keeps asking me if I want jslint
18:50:58 <aavogt> sohum: hlint?
18:51:23 <path[l]__> ah yes hlint works
18:51:23 <kmc> :t msum
18:51:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
18:51:24 <sohum> path[l]__, aavogt: ah, yes, hlint, sorry
18:51:24 <path[l]__> thanks
18:52:13 <Makoryu> > foldr1 (/) [5]
18:52:15 <lambdabot>   5.0
18:52:27 <ksf> remind me to never again read STM actions via a TChan.
18:52:30 <ksf> it's pure madness.
18:52:48 <ezyang> Hmm... I can't get seq to work at all
18:52:50 <ksf> or, rather, inherently racy madness.
18:53:02 <ksf> ezyang, what are you seqing?
18:53:16 <Makoryu> @src foldr1
18:53:16 <lambdabot> foldr1 _ [x]    = x
18:53:16 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
18:53:16 <lambdabot> foldr1 _ []     = undefined
18:53:16 <ezyang> (show member') `seq` when (optVerbose opts) $ hPutStrLn stderr $ "Updating: " ++ show member'
18:53:35 <ezyang> I'm trying to force any errors before I write to stderr
18:53:54 <Warrigal> > (0xc0,0x58,0x63,0x01)
18:53:55 <lambdabot>   (192,88,99,1)
18:53:55 <ksf> you're in the IO monad. you don't need seq.
18:54:08 <ezyang> member' is from a let
18:54:18 <ezyang> it's computed entirely purely
18:54:41 <ezyang> I could do a return to get sequencing, I guess...
18:54:46 <ksf> if then, you want to seq member', not show member.
18:55:00 <ksf> ...as that only forces show to accept member' as an argument.
18:55:07 <ksf> curries it in, so to speak.
18:55:16 <ezyang> ksf: Still not working
18:55:22 <ezyang> seq member' $ when (optVerbose opts) $ hPutStrLn stderr $ "Updating: " ++ show member'
18:55:29 <Makoryu> ksf: And "member' `seq` whatever" still won't work
18:55:40 <Makoryu> ezyang: Try rnf member `seq` stuff
18:55:45 <ezyang> nooooo
18:55:46 <ezyang> :-)
18:55:48 <Makoryu> No?
18:55:58 <Makoryu> But that's.... what it's for
18:56:00 <path[l]__> damn cant open the hlint site
18:56:01 * copumpkin is having a weird class issue
18:56:11 <ezyang> This is feeling the same as when I couldn't get the contents of a file strictly
18:56:17 <Makoryu> ezyang: You could also do length member'
18:56:56 <ezyang> I get: No instance for (Control.Parallel.Strategies.NFData Member)       arising from a use of `rnf' at Main.hs:142:4-14
18:57:12 <ezyang> can't do length since member' is not a list
18:57:15 <ksf> still, wth do you want to force member' before you output it?
18:57:17 <Makoryu> ezyang: Ah, well then
18:57:35 <ezyang> ksf: Because it'll be in the middle of outputting it and then suddenly realize, "oh hey, there was an exception"
18:57:58 <ksf> ...then don't put bottoms into your data.
18:58:06 <ezyang> Sort of like "Here is the data structure: {foo = 2, bar = Main.hs ParseFailed"
18:58:21 <ezyang> ksf: aww... but I wanted to use exceptions...
18:58:28 <ksf> exceptions are evil.
18:58:39 <ezyang> :-(
18:58:49 <copumpkin> neva!
18:58:52 <path[l]__> looks like I need cabal first
18:59:09 <ksf> it should be called yeahIReallyWantToHaveMessyErrorPropagationThrow
18:59:34 <ezyang> So... what gives me a semantic most like "raise" in Python?
18:59:46 <ksf> what does that do?
19:00:27 <ksf> exceptions in haskell will always occur when you force them, never when you "define" them (ugh)
19:00:31 <ezyang> If I raise an exception, synchronous execution stops and we try to find atry..catch block
19:00:38 <ezyang> ksf: Sure, I get that
19:00:47 <ezyang> Which means I want to figure out how to force them
19:00:57 <ezyang> Which means I was trying to use `seq`
19:00:59 <ksf> ...you can catch errors, but it still would print the beginning of your data.
19:01:10 * pastorn is cheating again
19:01:13 <ksf> ...you don't want to use seq, you want to use Maybe and Either.
19:01:15 <pastorn> friggin maybe monad
19:01:33 <ksf> ...or write parsers that don't fail.
19:01:40 <ezyang> Ok. I'll convert this to be EitherT IO
19:01:59 <ezyang> ksf: unpossible!
19:01:59 <ksf> or fail as soon as the user inputs data (that's IO, after all), not as you output it.
19:01:59 * arw_ wishes for maybe in every language he uses since he knows haskell
19:02:26 <ksf> parsers that don't fail are actually the same thing as parsers that use Maybe and Either.
19:02:28 <ezyang> ksf: I guess I'm used to figuring out errors as I'm processing, and not as a separate validation check
19:02:29 <pastorn> <3 <3 <3 fallthrough failing <3 <3 <3
19:02:36 <ksf> ...for ever subparser that can fail.
19:04:01 <ksf> you should'n intermingle parsing with processing.
19:04:03 <ezyang> Huh.
19:04:06 <ezyang> @hoogle EitherT
19:04:07 <lambdabot> No results found
19:04:17 <ksf> there's ErrorT
19:04:36 <ezyang> ksf: I'm not quite sure I agree
19:04:51 <ksf> ...if you've got data that parses, you can pipe it through a pure function that can't fail, and then be sure that you have something to output.
19:05:38 <ezyang> How do I put record update syntax into the ErrorT monad?
19:06:17 <ezyang> If it was a function I'd just liftM it
19:06:22 <ksf> learn a lesson from compiler design: parser -> ast -> intermediate language -> backend language -> output
19:06:38 <ksf> record update syntax is just that: syntax.
19:06:45 <ksf> it's a pure function.
19:07:00 <ksf> no actually it's a value.
19:07:54 <ezyang> Right. So is there an elegant way of saying parent { value = (a :: Either e a) } where a :: a
19:07:55 <ksf> last, but not least, that pipeline above has 5 stages, so it must be right.
19:08:26 <aavogt> ezyang: like this:  liftM (\x -> x { field = value })
19:08:27 <ezyang> ksf: So, actually, all of my parsers return Either e result
19:08:34 <ezyang> aavogt: cool
19:09:29 <ezyang> I then have code in the IO monad that throws exceptions
19:09:35 <ezyang> if it receives an Either result
19:09:38 <ezyang> can I make that work?
19:10:37 <ksf> ...just replace the code with return () if you got a Left
19:11:14 <ezyang> I need to short circuit execution
19:11:17 <ksf> do case foo of Left err -> print "bad, bad" ; Right v -> print v
19:11:19 <ezyang> (as in, abort early)
19:11:30 <ksf> ErrorT does that
19:11:34 <ezyang> ok
19:11:35 <ksf> (iirc)
19:11:39 <ezyang> Setting up ErrorT whee
19:15:32 <ezyang> so, this means I want throwError, now?
19:15:44 <ksf> yep
19:16:00 <ksf> which won't, ever, propagate beyond runErrorT
19:16:17 <ksf> ...it's fused into an Either, there.
19:17:14 <ezyang> ksf: Do you recommend never ever using bottom for error handling?
19:17:50 <ksf> pure should stay pure, and functions total.
19:18:40 <ksf> it's especially bad as one usually doesn't expect pure computations to fail in any way.
19:18:48 <ezyang> ok
19:19:17 <ezyang> When do I want to use an Error monad, as opposed to returning Either?
19:19:31 <Cale> Use partial functions when you are absolutely certain that they will succeed.
19:19:49 <Cale> (or when their failure means that you would rather have your program just end than anything else)
19:20:09 <jix_> ezyang: if you have a lot of functions calling each other where one or more of them might fail
19:20:11 <ezyang> Cale: Well, that /is/ what I want
19:20:25 <ezyang> jix_: Right. I can operate in the Either monad, in that case
19:20:46 * ksf can't locate a Monad Either instance
19:21:08 <ezyang> Oh, maybe I'm using it as an applicative
19:21:24 <ezyang> But that implies I should use the error monad
19:21:34 <ezyang> (that = not being able to locat a Monad either instance)
19:21:54 <jix_> i have only used ErrorT which uses Either
19:22:22 <jix_> so i guess the Error monad is the Either monad
19:22:40 <ksf> but then writing an instance with the maybe instance as template should be straight forward.
19:22:48 <ksf> jix_, yes, but it doesn't have the same type...
19:24:05 <lispy> is there a monad for transactional file system stuff?
19:24:14 <ezyang> Ok... my source code is pretty borked right now (thank god for scm)
19:24:21 <lispy> actually, I'm guessing it's a transformer and does MonadIO instances
19:25:24 <ksf> http://hackage.haskell.org/package/chp
19:25:32 <ksf> why has noone told me about that?
19:25:34 <SubStack> rolling my own compose with lower precedence feels dirty
19:25:35 <ezyang> I think the way forward will be to convert type signatures that are "a -> Either MyError Dues" to "a -> Error Dues" and "a -> IO ()" to "a -> ErrorT MyError IO ()"
19:25:48 <SubStack> people should disuade me from these bad ideas
19:26:21 <ksf> ezyang, use a type synonym for the latter.
19:26:29 <ezyang> ksf: Ok.
19:26:30 <Makoryu> ksf: There's also a package that allows Haskell processes to work as Erlang nodes
19:26:59 <ksf> ...but I don't want to interface with erlang.
19:27:00 <ezyang> oh, I suck
19:27:15 <ezyang> I actually should convert "a -> Either MyError Dues" to "a -> MonadError MyError Dues"
19:27:21 <ezyang> huh... is there any difference...
19:27:30 <ksf> I want to synchronize a single-threaded shared object, inotify, and gui.
19:27:35 <ksf> ...and probably more.
19:27:57 <SubStack> I hate parens so much
19:28:30 <jix_> what lib would you use for parsing html?
19:28:36 <gwern> SamB: :t doesn't go through mueval, so it's notm y  fault!
19:28:43 <gwern> jix_: tagsoup because I'm lazy
19:28:45 <SamB_XP_> gwern: no excuses!
19:28:56 <SamB_XP_> (why not ?)
19:29:15 <ezyang> ohhh... it's a typeclass
19:29:21 * gwern makes more excuses: the moon is full; my dog died; I haven't had any tea yet; it's late out; I'm suffering from radiation poisoning; my pet leech is depressed
19:29:40 <ezyang> Ok, so I want Data.Either MyError, and define a MonadError instance for that
19:29:50 * ksf didn't have any tee lately, too, and will fix that in a jiffy.
19:29:53 <gwern> SamB_XP_: and :t doesn't go through mueval because there's nothing bad you can do with :t. I think
19:29:58 <ezyang> Does htis make sense?
19:30:23 <ksf> heh. there's also nothing bad you can do with @pl ...oO
19:30:31 <ezyang> *this
19:30:39 <gwern> ksf: well, you can dos it
19:30:44 <gwern> but that's it
19:32:08 <ksf> maybe I should send her some random data. every deterministic being likes some entropy...
19:32:08 <gwern> SamB_XP_: but I suppose I can fix it
19:33:54 <ezyang> oh... I don't want to use Either; I want to use Monad m => m and use fail
19:33:58 <ezyang> then it's generic ho ho ho
19:34:12 <gwern> your mom is a generic ho
19:34:35 <lispy> gwern: yeah, I reenabled swap on the machine lambdabot is on and I'm pretty sure that's lead to long timeouts from her when she gets requests that use lots of memory
19:34:55 <lispy> I really just need to buy a new server
19:35:16 <gwern> lispy: well, I suppose all requests should run in some kind of resource jail or timeout; but it's just mueval which does that right now
19:35:23 <gwern> another thing that needs fixing in lambdabot
19:36:22 <ezyang> Huh "In the IO monad, this is usually a bad idea (though, again, I've seen it)" w.r.t. ErrorT on IO
19:37:29 <ezyang> mm, will think more about this tomorrow
19:37:30 <ezyang> cyall
19:37:46 <pastorn> well this is a weird error;
19:38:06 <pastorn> inside a case statement, i have a do-construct for the maybe monad
19:38:15 <pastorn> so my code structure is this:
19:38:38 <pastorn> f x old = case x of
19:38:52 <pastorn>  _ -> let new = do
19:39:01 <pastorn>   (maybeDoNotation)
19:39:10 <BMeph> pastorn: If you don't hpaste, I'm stabbing a lambda in your eye! ;p
19:39:15 <pastorn> in new `mplus` Just old
19:39:25 <pastorn> BMeph: done
19:39:26 <lispy> gwern: ahem.  It used to be that way :)
19:40:07 <lispy> gwern: I was thinking about upgrading that server, but if it's not going to help...
19:40:52 <pastorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8904#a8904
19:42:31 <jfoutz> the in and let don't line up. i think they need to.
19:43:03 <ksf> _how_, _possibly_ can one have the gall of having a function called "spaghettiFork" in an haskell dining philosophers example?
19:43:34 <pastorn> jfoutz: cool, thanks
19:43:35 * copumpkin wrote type-level sets :o
19:43:37 <ksf> haskell philosophers eat curry chicken.
19:43:41 <pastorn> annotated with workin copy
19:43:45 <aavogt> pastorn: (fromMaybe gs gs') looks safer than your that fromJust
19:43:53 <lament> the philosophers obviously use chopsticks, not forks
19:44:05 <pastorn> aavogt: didn't know it existed :0
19:44:05 <lament> otherwise, the explanation for why they need two of them is rather contrived
19:44:19 <pastorn> aavogt: oh, i should just use 'maybe', now that i think about it
19:44:45 <lispy> copumpkin: really?
19:45:23 <lispy> copumpkin: we couldn't come up with a way to do type level sets when I started my darcs work for my thesis, so we went with the type threaded lists
19:45:39 <lispy> copumpkin: so it would be interesting to see what you came up with.  What extensions do you need?
19:45:41 <aavogt> pastorn: or also:   FWD -> fromMaybe gs $ do ...
19:45:46 <lispy> copumpkin: and is the type checking decidabel?
19:45:54 <copumpkin> lispy: yes, but ghc doesn't know that ;)
19:46:03 <copumpkin> lispy: I pretty much use all extensions :P
19:46:04 <pastorn> aavogt: yeah, true
19:46:37 <pastorn> i've said it before, the maybe monad is like cheating
19:46:37 <copumpkin> lispy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8906#a8906
19:47:00 <copumpkin> lispy: I haz subtyping! :P
19:47:44 <Makoryu> copumpkin: .... Y'know, it never occurred to me to use backticks in type notation!
19:47:56 <BMeph> Whoa...what's up with the 'net log? =8*O
19:48:02 <copumpkin> Makoryu: you start using that stuff when you do crazy type shit :P or you go crazy!
19:48:14 * Makoryu explodes
19:48:17 <pastorn> aavogt: thanks a million :D
19:48:21 <ksf> "CHP programs are usually terminated using poison."
19:48:22 <jfoutz> oh, that is sick.
19:48:24 <copumpkin> lispy: I can paste it all if you want
19:48:25 <Jafet> Undecidable type checking?
19:48:46 <ksf> "The concept of poison is to set channels into a poisoned state, and any further attempt to use them causes a poison exception to be thrown."
19:48:46 <copumpkin> Jafet: it's still decidable, it's just that GHC's termination checker isn't aware of it so I need to turn if off :/
19:48:51 <Jafet> That's C++, dear.
19:49:35 <ksf> you can use backticks in types?
19:50:00 <jfoutz> apparently.
19:50:17 <c_wraith> like a `Either` b ?
19:50:32 <copumpkin> sure
19:50:35 <Jafet> Oh, hm
19:50:40 <copumpkin> you might need -XTypeOperators
19:50:45 <ksf> that's a very good reason to rename Either to Or
19:50:51 <ksf> a `Or` b
19:50:53 <copumpkin> Xor
19:50:57 <ksf> yeah.
19:51:06 <copumpkin> or `Plus`
19:51:17 <kmc> or :+:
19:51:19 <copumpkin> a lot of people use :+ and :*
19:51:46 <Jafet> :^_^:
19:51:51 <ksf> a `Î£` b
19:51:57 <copumpkin> lol
19:52:00 <kmc> haskell should re-steal Agda's syntax
19:52:13 <aavogt> re-steal?
19:52:15 <kmc> i want mixfix operators and arbitrary unicode
19:52:23 <copumpkin> agda stole haskell's syntax
19:52:27 <copumpkin> and then improved on it :P
19:52:29 <Makoryu> @instances Either
19:52:30 <copumpkin> well "improved"
19:52:30 <lambdabot> Couldn't find class `Either'. Try @instances-importing
19:52:36 <Makoryu> Er whoos
19:52:36 <ksf> that mixfix stuff still needs work.
19:52:39 <Makoryu> *whoops
19:52:42 <Makoryu> @instances a Either
19:52:42 <lambdabot> Couldn't find class `a Either'. Try @instances-importing
19:52:57 <jfoutz> but function_declarations_like_this_frighten_me_
19:53:03 <ksf> like in [_+_], so that you don't have to put spaces between your stuff and the brackets.
19:53:07 <copumpkin> but if_then_else_ is so cute
19:53:08 <aavogt> haskell has arbitrary unicode, no?
19:53:08 <pastorn> ksf: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8907#a8907
19:53:13 <copumpkin> aavogt: yeah
19:53:13 <ksf> any kind of parens should be special.
19:53:45 <kmc> well also in agda there is no lexical distinction between types, values, operators, and prefix functions
19:54:03 <ksf> pastorn, that type is, properly, called "->"
19:54:24 * BMeph likes using ':=' in comments, instead of '::'
19:54:43 <Makoryu> BMeph: Now why would you do tha
19:54:43 <Makoryu> t
19:55:19 <BMeph> Makoryu: Oh, just b
19:55:20 <copumpkin> convert :: ((Properties b `Subset` Properties a) ~ True) => b -> a
19:55:23 <BMeph> ecause. ;)
19:55:24 * copumpkin feels dirty
19:55:40 <Jafet> Heh, all these languages market themselves as "proof assisting languages"
19:55:56 <ksf> I'm all for unicode, but only if we also get to define custom trigraphs.
19:57:01 <ksf> Jafet, it's a more successfull way to avoid success than haskell's "let's look more infantile than ruby and python combined as well as more scary than quantum mechanics"
19:57:11 <Jafet> //Trigraphs????/
19:57:14 <bd_> ksf: You can use UTF-7 :)
19:57:21 <bd_> that's _kinda_ like trigraphs
19:57:33 <Makoryu> ksf: Where'd the "infantile" part come from? O_o
19:57:36 <Jafet> ksf, that feels to me like marketing refrigerators as "jumbo beer coolers"
19:57:50 <ksf> ever seen gcc being called with wtrigraphs? or wnotrigraphs or whatever.
19:58:10 <ksf> they're three-character equivalents for things like {
19:58:13 <Jafet> Actually I think people would actually buy jumbo beer coolers compared to Coq, etc
19:58:13 <SamB_XP_> Jafet: which?
19:58:33 <ksf> ...as defined in the c standard, and shunned by everyone.
19:58:42 <SamB_XP_> and marketing refrigerators as "jumbo beer coolers" sounds like something that might just work ;-)
19:58:43 <Jafet> samb, Agda, mentioned above
19:58:50 <bd_> they're a hack for machines that don't have { in their character set
19:59:00 <bd_> such machines, of course, no longer exist.
19:59:04 <Jafet> Which fortunately are only continued to be used by IBM
19:59:06 <ksf> THERE ARE NO NONASCII MACHINES
19:59:16 <SamB_XP_> Jafet: oh. you could market that as a gÃ¶del-proof language!
19:59:18 <ksf> <-----------LOOK THAT WAY
19:59:20 <Jafet> (I believe IBM pushed for continued use of trigraphs in the new C++ standard.)
19:59:24 <SamB_XP_> I think
19:59:37 <bd_> EBCDIC is just a scary story programmers tell their children so they'll eat their vegetables
19:59:46 <Makoryu> Jafet: IBM can shampoo my balls.
19:59:56 <Jafet> I thought EBCDIC had braces
20:00:01 <ksf> 0..9 are specced to be successive in C.
20:00:08 * copumpkin wonders what other ridiculous kinds of type functions he'll add
20:00:20 <SamB_XP_> bd_: but it actually appeared in the Fuun genome!
20:00:22 <ksf> a..z and A..Z, too, afair.
20:00:36 <arw_> Jafet: google ebcdic and read up on the mess it is :)
20:00:40 <Makoryu> bd_: You're confusing EBCDIC with the various 6-bit encodings that predate it
20:00:50 <kmc> it's
20:00:52 <arw_> Jafet: but yes, it has {}
20:00:52 <SamB_XP_> hey ... why was the Fuun genome self-documenting in *english*, anyway?
20:01:07 <SamB_XP_> how about ISO 646?
20:01:09 <kmc> also impossible to program haskell on machines without lowercase
20:01:09 <bd_> Makoryu: This was in response to "THERE ARE NO NONASCII MACHINES" :)
20:01:20 <SamB_XP_> is that just a scary story people tell first-year students to scare them?
20:02:17 <ksf> you hear those story from sysadmins, while warming your hands over exhaust fans and watching blinkenlights in _very_ cold server rooms.
20:02:24 <bd_> kmc: Nah, we just need to add digraphs to haskell ;)
20:02:39 <SamB_XP_> bd_: we have those already
20:02:44 <bd_> oh :|
20:02:55 <SamB_XP_> you just need to give up z and Z
20:02:56 <SamB_XP_> ;-P
20:03:15 <Jafet> -> is just to compensate for the lack of a real APL keyboard.
20:03:19 <SamB_XP_> well, that is, you spell them zz/Zz and zZ/ZZ
20:03:21 <daz> how do you take stuff from a list, I want to take each list item to process. in [( "09987652", "Something New  ", "YES", 0), ( "19987653", "Reno 911       ", "YES", 0), ( "29987654", "Celtic Woman   ", "NO", 3)] e.g how would i take just ( "19987653", "Reno 911       ", "YES", 0)?
20:03:22 <kmc> http://en.wikipedia.org/wiki/Criticism_of_APL I'm glad this has its own, long article
20:03:54 <ksf> daz, you want to use a custom data structure.
20:03:55 <kmc> so does Java
20:03:57 * copumpkin tries to extract a subset of the properties of my type
20:04:10 <ksf> ...and the answer is !!, or just plain map.
20:04:13 <ksf> :t map
20:04:13 <jfoutz> at my first job one of the sysadmins saved thousands by replacing EBCDIC conversion software with perl pack and unpack
20:04:14 <kmc> but not PHP ??
20:04:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:04:19 <daz> the data structure is type DVD = (String, String, String, Integer)
20:04:22 <SamB_XP_> bd_: of course, if you want to be able to use arbitrary unicode characters, you'll need considerably longer -graphs ;-)
20:04:43 <ksf> that's a type synonym, not a data structure.
20:04:53 <daz> is there no polymorphic function to take the second tuple?
20:04:54 <SamB_XP_> jfoutz: dd can't do that as well?
20:04:59 <Makoryu> \M\A\P (+) \LBR\RBR = \LBR\RBR; \M\A\P (+) ((*):(**)) = (+) (*) : \M\A\P (+) (**)
20:05:14 <kmc> dvd dvd dvd dvd $5 !!
20:05:27 <ksf> data DVD = DVD { id :: String, title :: String, whatever :: Bool, whatever :: Int}
20:05:38 <jfoutz> SamB_XP_: conv, wow that's awesome.
20:05:53 <SamB_XP_> jfoutz: now, it might not support as many dialects as perl ...
20:06:35 <bd_> SamB_XP_: hence utf7 :)
20:06:39 <daz> i can go......... take 1 list
20:06:46 <daz> and it takes the first one,
20:06:51 <daz> but cant take the second one.
20:06:58 <arw_> list !! 2
20:07:41 <arw_> :t (!!)
20:07:42 <lambdabot> forall a. [a] -> Int -> a
20:08:19 <jfoutz> SamB_XP_: it was some random AIX box, might have had a broken dd... to encourage buying expensive conversion software. there was also a bunch of nonsense about some special ibm "transfer windows" that were different from sockets in ways no one could ever explain.
20:08:48 <SamB_XP_> jfoutz: ah
20:08:54 <kmc> daz, tuples are not sequences
20:09:19 <jfoutz> but EBCDIC to ASCII in one line was pretty awesome.
20:09:48 <kmc> daz, what would the type be?
20:09:58 <kmc> (a,b,c,d) -> Int -> ... what?
20:10:27 <daz> [(String, String, String, Integer)] ?
20:10:50 <kmc> i thought you're trying to extract the second field of the tuple?
20:10:53 <kmc> is that not the case?
20:11:27 <daz> no i want to pull the whole tuple. so then i can run this on it..
20:11:29 <kmc> oh if you just want the second element of a list (of tuples or anything else) use list !! 2
20:11:36 <kmc> as mentioned
20:11:40 <arw_> > [( "09987652", "Something New  ", "YES", 0), ( "19987653", "Reno 911       ", "YES", 0), ( "29987654", "Celtic Woman   ", "NO", 3)] !! 2
20:11:42 <lambdabot>   ("29987654","Celtic Woman   ","NO",3)
20:11:49 <kmc> sorry for misunderstanding
20:12:05 <arw_> aehm. !! 1
20:12:12 <kmc> err yes
20:12:12 <arw_> indices start at 0 :)
20:12:13 <daz> > listDVD = [( "09987652", "Something New  ", "YES", 0), ( "19987653", "Reno 911       ", "YES", 0), ( "29987654", "Celtic Woman   ", "NO", 3)]
20:12:14 <lambdabot>   <no location info>: parse error on input `='
20:12:20 <arw_> too much fortran :)
20:13:11 <daz> yea my function wont run on it if i select it with !! x
20:13:20 <daz> it only seems to work with the take.
20:13:30 <kmc> daz, take returns a list
20:13:35 <BMeph> daz: Thank you!
20:13:42 <kmc> (take n xs) returns the list of the first n elements of xs
20:14:02 <kmc> if you only want a single element, make your function take a single element rather than a list of one element
20:14:39 <BMeph> > (take 1 . drop 1) [( "09987652", "Something New  ", "YES", 0), ( "19987653", "Reno 911       ", "YES", 0), ( "29987654", "Celtic Woman   ", "NO", 3)]
20:14:41 <lambdabot>   [("19987653","Reno 911       ","YES",0)]
20:15:27 <daz> > (take 1 . drop 2) = [( "09987652", "Something New  ", "YES", 0), ( "19987653", "Reno 911       ", "YES", 0), ( "29987654", "Celtic Woman   ", "NO", 3)]
20:15:28 <lambdabot>   <no location info>: parse error on input `='
20:15:36 <daz> > (take 1 . drop 2) [( "09987652", "Something New  ", "YES", 0), ( "19987653", "Reno 911       ", "YES", 0), ( "29987654", "Celtic Woman   ", "NO", 3)]
20:15:37 <lambdabot>   [("29987654","Celtic Woman   ","NO",3)]
20:16:22 <jfoutz> > (take 1 . drop 2) [( "09987652", "Something New  ", "YES", 0), (  "19987653", "Reno 911       ", "YES", 0), ( "29987654", "Celtic  Woman   ", "NO", 3)]
20:16:24 <lambdabot>   [("29987654","Celtic  Woman   ","NO",3)]
20:16:36 <jfoutz> > (head . drop 2) [( "09987652", "Something New  ", "YES", 0), (  "19987653", "Reno 911       ", "YES", 0), ( "29987654", "Celtic  Woman   ", "NO", 3)]
20:16:37 <lambdabot>   ("29987654","Celtic  Woman   ","NO",3)
20:20:24 <daz> [ take 1 . drop x [( "09987652", "Something New  ", "YES", 0), (  "19987653", "Reno 911       ", "YES", 0), ( "29987654", "Celtic  Woman   ", "NO", 3)] | x <- [0..(length [( "09987652", "Something New  ", "YES", 0), (  "19987653", "Reno 911       ", "YES", 0), ( "29987654", "Celtic  Woman   ", "NO", 3)]]
20:27:59 <Makoryu> > let (/) = foldr1 in (+) / [1..10]
20:28:00 <lambdabot>   55
20:37:02 <log0ut> In a haskeline config file, to try to get a decent vi mode, does anyone know if you can bind k and j to up and down, but only in command mode?
20:37:30 <log0ut> It seems to bind it correctly, but also in insert mode, so you can't type j or k.
20:39:23 <jfoutz> is there a good way to get an alternating type? like... Even (Odd (Even a)) ?
20:39:37 <Makoryu> log0ut: http://trac.haskell.org/haskeline/ticket/90 <- There's a bug report for this
20:39:46 <kmc> jfoutz, two mutually-recursive type defns?
20:40:16 <kmc> i guess i'm not sure what you're asking
20:40:44 <jfoutz> kind of, i want to ensure Even can't have an immediate child that is even.
20:41:47 <kmc> what is the data being stored?
20:42:04 <Makoryu> jfoutz: data Even a = Zero a | Even (Odd a); data Odd = One a | Odd (Even a)
20:42:24 <jfoutz> hrm.
20:42:48 <jfoutz> oh! thank you. :)
20:43:03 * Makoryu bows
20:43:15 <log0ut> Makoryu:  Oh, I, no solution yet.  Thanks though.
20:43:20 <log0ut> *I see
20:43:27 * copumpkin is trying to figure out how to do a type- and value-level subset simultaneously
20:43:35 <Makoryu> log0ut: Unfortunately, no
20:43:46 <Makoryu> jfoutz: Mind you, that one isn't terribly useful
20:44:12 <jfoutz> well, two nulls i think... is good enough.
21:02:19 * ksf would like to have links inside haddock html sources
21:07:13 <mmorrow> data Mut f g a b = Mut (f a (Mut g f b a))
21:23:43 <BMeph> mmorrow: You and your wacky mutually-recursive type constructors... :)
21:25:28 <mmorrow> BMeph: that one edwardk's ;)
21:25:34 <mmorrow> *one's
21:25:37 <mmorrow> , ''Mutual
21:25:38 <lunabot>  Control.Functor.Internal.Ideal.Mutual
21:25:41 <mmorrow> , src ''Mutual
21:25:43 <lunabot>  newtype Mutual p m n a = Mutual {runMutual :: (m (p a
21:25:43 <lunabot>                                                      (Mutual p n m a)))}
21:25:48 <mmorrow> err, almost
21:25:56 <mmorrow> oh no
21:25:58 <mmorrow> exactly
21:26:21 <mmorrow> err, module tyvar ordering i guess
21:27:02 <bos> @seen dons
21:27:03 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
21:39:38 <copumpkin> woot
21:39:39 <copumpkin> *Algebra> subset (magmaProperties m) :: Properties (SemigroupC Integer)
21:39:39 <copumpkin> AssociativeC :> Nil
21:39:50 <copumpkin> I haz pseudo subtyping :P
21:42:10 <ksf> copumpkin, is that one of those libraries that require you to have a PhD to boil an egg?
21:42:26 <copumpkin> ksf: indeed! I can eventually add 2 + 2 if I really try! :D
21:43:23 <ksf> ...you first have to parametrize it enough to tell it that you don't want 5 as output?
21:43:34 <SamB_XP> ksf: where do you get a library to boil an egg at *all*?
21:43:49 <ksf> thinkgeek.
21:43:50 <SamB_XP> you might get a PhD for writing one of those!
21:44:05 <ksf> I bet they have automated egg boilers.
21:44:19 <ksf> ...with usb power supply and linux drivers.
21:44:25 <aavogt> @hoogle egg
21:44:25 <lambdabot> Distribution.Simple.Setup regGenPkgConf :: RegisterFlags -> Flag (Maybe FilePath)
21:44:25 <lambdabot> Distribution.Simple.Setup regGenScript :: RegisterFlags -> Flag Bool
21:44:35 <copumpkin> ksf: indeed! you need to tell it which algebraic structure you want to use to do the "addition" first
21:45:34 <ksf> so I can use (2+2) :: NineTeenEightyFour ?
21:46:43 <copumpkin> not quite :)
21:47:34 <ksf> (2+2) :: NineTeenEightyFour Goldstein?
21:48:23 <copumpkin> if you really wanted to, maybe :P
21:48:37 <copumpkin> I'm doing all sorts of sneaky tricks from edwark's book
21:49:01 <aavogt> figurative book?
21:50:16 <copumpkin> yeah
21:50:20 * copumpkin feels really l33t
21:51:26 <copumpkin> of course, the type errors you get from this stuff are utterly meaningless
21:51:33 <copumpkin> *Algebra> withCommutativeSemigroup m (E 5 â‹… E 6)
21:51:39 <copumpkin> where m is a monoid
21:51:46 <copumpkin> gives me the error:
21:51:46 <copumpkin>     Couldn't match expected type `GT'
21:51:46 <copumpkin>            against inferred type `Compare
21:51:46 <copumpkin>                                     (CommutativeC Integer) (UnitalC Integer)'
21:51:50 <copumpkin> :P
21:52:06 <copumpkin> it's wonderful
21:52:58 <copumpkin> but at least it allows me to define something as a monoid once
21:53:10 <copumpkin> and then use it as anything else that requires the same properties
21:53:17 <copumpkin> or a subset of those properties
21:54:02 <aavogt> using the original Monoid class from base and undecidable instances?
21:54:06 <aavogt> or something else?
21:54:36 <copumpkin> nah, I dithced the original Monoid class
21:54:43 <copumpkin> this uses Monoid values!
21:54:47 <copumpkin> :P
21:54:57 <copumpkin> but I also have a Monoid class that uses those values
21:55:36 <copumpkin> it's pretty extreme
21:56:16 <copumpkin> I have so many type functions
21:57:14 <copumpkin> now come two-operation structures
22:01:09 * copumpkin needs to figure out how to do these elegantly too
22:04:26 <copumpkin> withMonoid :: forall p a. (Properties (MonoidC a) `Subset` p) => MagmaC p a -> (forall s. Monoid (E s a) => E s a) -> a
22:04:26 <copumpkin> withMonoid m e = reify (convert m :: MonoidC a) (tag e)
22:05:02 <jfoutz> @pl concatMap (\f -> map (\l -> f <*> l) ls) fs
22:05:02 <lambdabot> flip map ls . (<*>) =<< fs
22:14:59 <SubStack> time to see what all this MACID business is all about
22:15:05 <copumpkin> MACID?
22:15:10 <hydo> I'm a little confused about the state monad.  Can you jump in and out of it without it losing the data inside of it?  I'm trying to come up with a way to hold an mvar with which to communicate with a thread.
22:15:31 <Cale> There is no magic in the state monad.
22:15:55 <Cale> (State s a) is internally the same thing as  s -> (s,a)
22:16:19 <Cale> That is, a computation of type State s a is simply a function from an initial state to a pair consisting of a final state and result.
22:16:36 <aavogt> since the value of the mvar shouldn't change (though what the mvar points to does change), perhaps Reader (MVar x) makes more sense?
22:17:12 <Cale> I wouldn't use anything but the IO monad and functions here, most likely.
22:17:41 <SubStack> copumpkin: from happstack
22:17:44 <Cale> At least, from the description, it sounds like you just want to create an MVar and pass it as a parameter to some other functions.
22:18:00 <jfoutz> > (\x state -> (\y state -> (\z state -> z + state) y (state +1)) x (state +1) ) 1 1
22:18:01 <lambdabot>   4
22:18:46 <hydo> cale/aavogt: well, ideally, I would like to create the mvar, pass it to the function that I forkIO off, and then, when I need it, somehow pull the mvar out and use it... without having to explicitly pass it wherever I go.
22:19:39 <Cale> hydo: I suppose I have a higher tolerance for passing things around explicitly than that. I tend to like it because it makes the dependencies between things more explicit...
22:19:42 <hydo> I'm coming to the conclusion that I need to rethink the problem though.  Maybe I'm trying to make the language do something it's not generally supposed to do.
22:20:21 <Cale> You could use something like the  ReaderT (MVar Foo) IO  monad, but... I don't think it really makes anything any nicer.
22:20:23 <jfoutz> it's a lot less painfull with currying too.
22:21:00 <Cale> Another thing you can do if the computations you're going in the other thread inside of a 'let' inside the do-block that you constructed the MVar in.
22:21:08 <Cale> Then you can just refer to the MVar directly from there.
22:21:27 <hydo> Cale: ok, I guess I just assumed that passing things around explicitly would be seen as bad style.  Maybe the best thing to do is make a new data type and pass that around so then, if I decided I wanted to, I could easily add stuff to it.
22:21:34 <Cale> er... dropped some words on the floor there...
22:22:18 <Cale> "if the computations you're going to forkIO are small, is put them inside of a 'let'..."
22:23:14 <Cale> hydo: I tend to think of it as good style. Of course, the IO monad muddies the waters a little bit, but generally if a function depends on something, that something should be a parameter to it.
22:24:00 <hydo> can't wait for the pdx hackathon.  I love getting other, smarter eyes on my code telling me "wtf are you doing it like this for?  You should do ....." It's like an IV drip of smart mailined into my head.
22:27:19 * ksf likes chp a lot.
22:28:38 <ksf> I'm infected by the idea to use concurrency for stuff that previously I wanted to do using FRP (but failed because the libraries failed) for at least a week now, and chp does exactly what I want.
22:34:28 * hydo raises a single eyebrow and searches google for 'chp'...
22:34:45 <hydo> ah, ha!  California Highway Patrol.
22:34:56 <arw_> Cumhuriyet Halk Partisi
22:35:21 <ksf> http://hackage.haskell.org/package/chp-1.2.0
22:35:35 <ski> Counterwitness Haustellate Photoelectron
22:35:41 <ksf> have a look at those chans: http://hackage.haskell.org/packages/archive/chp/1.2.0/doc/html/Control-Concurrent-CHP-Common.html
22:36:28 <ksf> conal will wave this away as IO-based madness, but I like it.
22:40:41 * copumpkin is confusing himself
22:41:26 <ksf> do you really confuse yourself, or is your dual nfusing you?
22:41:37 <ksf> (when will I get tired of that pun?)
22:44:12 <copumpkin> :P
22:48:33 * copumpkin is really really abusing the type system
22:49:45 <arw_> better than the typesystem abusing you :)
22:50:20 <altmattr> programming haskell is all about the type system abusing you
22:50:20 <altmattr> "its a Pair of Mondas you idiot!!!"
22:50:31 <altmattr> "what the hell makes you think an IO () can go there"
22:50:41 <altmattr> "return you moron"
22:50:56 <altmattr> "polymorphic?  there?  as if..."
22:51:04 <arw_> thats not really the kind of abuse you get from c++ :)
22:51:37 <arw_> c++ is really abuse. where haskell tells you whats wrong, c++ tells you about 5 pages of obscure unreadable stuff.
22:51:47 <arw_> and somewhere in between, there is a missing 'const'
22:52:05 <arw_> a const that shouldn't be part of a type in the first place.
22:52:08 <arw_> _thats_ abuse.
22:53:11 <altmattr> adding insult to injury?
22:54:07 <arw_> well, the adding insult to injury part is c++ writers who don't even bother to try if their example code compiles...
22:54:50 <arw_> like http://pbot.rmdir.de/bac1c9dfe45401a16f9621438025a6cf from c++ cookbook.
22:54:56 <clanehin> c++ and haskell both demand the same time consuming search for errors, in c++, memory errors, in haskell, type errors.  The difference is, type errors happen at compile time, but memory errors at demo-the-program-to-your-boss time.
22:55:26 <arw_> clanehin: nack. memory errors come on top of the c++ type madness.
22:55:40 <dsdeiz> what does <+> means? :-?
22:56:42 <arw_> clanehin: but thats in fact easy to fix. never use exceptions, always use smartpointers, never fail in constructors, use initializers for that.
23:17:36 <altmattr> dsdeiz: if you are using a pretty printing library it means put next to with a space
23:17:59 <altmattr> otherwise.... ?
23:24:39 * copumpkin feels like he's doing this wrong somehow
23:24:48 <liyang> good morning Edinburgh!
23:30:47 <byorgey> morning liyang!
23:31:33 <byorgey> dsdeiz: where did you see this <+>?
23:32:01 <byorgey> in xmonad it means mappend
23:32:20 <Baughn> Oh, is that what it is?
23:32:50 * Baughn wonders if it shouldn't be >+<
23:33:07 <byorgey> Personally I think it should be <+<
23:33:14 <byorgey> in xmonad, not generally
23:33:34 <byorgey> because the underlying Monoid is Endo, and things end up getting done right-to-left
23:34:03 <Raevel> :D-<+<
23:34:28 <byorgey> @quote Cale's.lemma
23:34:29 <lambdabot> No quotes match. There are some things that I just don't know.
23:34:34 <byorgey> @quote fish
23:34:35 <lambdabot> Cale's says: Lemma: Any sufficiently long string of operator symbols looks like a fish.
23:35:15 <byorgey> @forget Cale's Lemma: Any sufficiently long string of operator symbols looks like a fish.
23:35:15 <lambdabot> Done.
23:35:24 <byorgey> @remember Cale Cale's Lemma: Any sufficiently long string of operator symbols looks like a fish.
23:35:24 <lambdabot> Good to know.
23:37:40 <FunctorSalad> I've seen <+> for something else, but I don't remember
23:37:52 <FunctorSalad> @hoogle (<+>)
23:37:52 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
23:37:52 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
23:37:52 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
23:38:09 <FunctorSalad> think it was the prettyprinter
23:40:16 <blackdog> oh, jeez. in ruby, True and False are actually different types, as well as different values...
23:40:35 <copumpkin> yeah
23:40:49 <Raevel> what was it, TrueClass and FalseClass?
23:40:53 <blackdog> no wonder i was getting bus errors
23:40:55 <copumpkin> there's also NilClass
23:40:57 <FunctorSalad> they have types?
23:41:06 <Raevel> and Class
23:41:08 <blackdog> actually defined as C preprocessor macros
23:41:44 <copumpkin> >> nil.class => NilClass
23:41:44 <copumpkin> >> false.class => FalseClass
23:41:44 <copumpkin> >> true.class => TrueClass
23:43:59 <blackdog> i think i have a false sense of confidence as to what types mean to non-FPers. I know the definition is just sets of values, so the ruby formulation is as valid as any other, but what's the point in splitting them up if you're not going to use the distinction in some sensible way?
23:45:26 <Baughn> blackdog: From what I can tell, "type" means "that arbitrary keyword you have to add to make the computer store your values right".
23:45:40 <Baughn> blackdog: ..which is probably why they're fine with storing pointers in longs.
23:45:49 <copumpkin> well, they're tagged
23:48:49 <FunctorSalad> hmm types aren't *really* sets *nitpick*
23:49:48 <FunctorSalad> totally besides the point
23:51:07 <Heffalump> FunctorSalad: what makes them not sets?
23:51:13 <olsner> bah, nitpicking is never besides the point!
23:51:22 <copumpkin> pitnicking
23:51:25 <copumpkin> picnicking!
23:52:21 <olsner> pitnicking is hard, let's go have a picnic?
23:53:22 <olsner> hmm, who was that yesterday? "shopping is hard, let's talk about algebraic topology!"
23:53:43 <blackdog> no, wait, i want to hear why they're not sets...
23:55:19 <Baughn> Me too! Me too!
23:56:15 <FunctorSalad> Heffalump: I was thinking of "there's just one empty set, but many empty types (and they aren't even empty in haskell :o)" aka extensionality
23:56:37 <FunctorSalad> (as an informal arguments. formally types are just whatever the logic says, of course)
23:56:53 <stanv> i can't undestand where is difference between 'div' and 'quot'
23:57:09 <olsner> they do different things for negative numbers, iirc
23:57:11 <copumpkin> stanv: try negative values
23:57:19 <dibblego> @check \x y -> div x y == quot x y
23:57:20 <lambdabot>   "* Exception: divide by zero
23:57:29 <dibblego> @check \x y -> y /= 0 ==> div x y == quot x y
23:57:29 <lambdabot>   Not in scope: `==>'Precedence parsing error
23:57:30 <lambdabot>      cannot mix `GHC.Classes./=...
23:57:31 <FunctorSalad> Heffalump: perhaps a better argument, types don't have the global untyped "element" operator of set theory
23:57:48 <dibblego> @check \x y -> y /= 0 ==> (div x y == quot x y)
23:57:49 <lambdabot>   Not in scope: `==>'
23:57:51 <dibblego> boo
23:57:58 <Heffalump> FunctorSalad: I see
23:59:02 <FunctorSalad> (and I suppose haskell types would be interpreted as certain partial orders/domains, but there isn't a rigorous denotational semantics of haskell, or is there?)
23:59:15 <olsner> @check \x y -> y == 0 || div x y == quot x y
23:59:16 <lambdabot>   "Falsifiable, after 5 tests:\n3\n-2\n"
23:59:35 <arw_> > div 3 -2
23:59:36 <lambdabot>   No instance for (GHC.Num.Num (t -> t))
23:59:36 <lambdabot>    arising from the literal `2' at <...
23:59:49 <arw_> > div 3 (-2)
23:59:50 <lambdabot>   -2
