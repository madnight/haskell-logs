00:00:00 <dmwit> Poor ?pl doesn't do list comprehensions, I'm afraid.
00:00:09 <Trinithis> @pl \xs -> sum [x | (x, True) <- zip xs (cycle [True, False])]
00:00:09 <lambdabot> ((x | (x, True)) <-) . flip zip (cycle [True, False])
00:00:15 <dmwit> ?pl \x -> [y | x]
00:00:15 <lambdabot> return . (y |)
00:00:19 <dmwit> riiiight
00:00:36 <Trinithis> @ty (|)
00:00:38 <lambdabot> parse error on input `|'
00:00:55 <dmwit> Trinithis: ...It's from [y | x].  As I said, ?pl doesn't do list comprehensions.
00:01:04 <Cale> | is special syntax, and @pl doesn't know that
00:01:04 <Trinithis> ok
00:01:55 <ChthonLaptop> Orclev: Are you on Newnet#Bay12games?
00:02:21 <Orclev> no
00:02:27 <ChthonLaptop> if so I'll be talking more about the system there later.  Don't want to hijack the channel too much off topic.
00:04:32 <Trinithis> @pl sum $ (\xs -> zip xs (cycle [True, False]) >>= \(x, bool) -> guard bool >> [x])
00:04:33 <lambdabot> sum ((uncurry (flip ((>>) . guard) . return) =<<) . flip zip (cycle [True, False]))
00:05:56 <olsner> @pl \(x,bool) -> if' bool [x] []
00:05:57 <lambdabot> uncurry (flip flip [] . flip if' . return)
00:06:34 <Trinithis> @pl \(x, bool) -> guard bool >> [x]
00:06:34 <lambdabot> uncurry (flip ((>>) . guard) . return)
00:12:17 <path[w]> sum.map snd.filter fst $ zip (cycle [True, False]) <--- how would I get rid of the last $? sum.map snd.filter
00:13:18 <dmwit> change it to .
00:13:19 <Orclev> does anyone know why I get "Module `GHC.Conc' does not export `Signal'" when I try to do cabal install unix?
00:13:44 <dmwit> > let f = sum . map snd . filter fst . zip (cycle [True, False]) in f [5,7,9,11]
00:13:46 <lambdabot>   14
00:13:46 <path[w]> hmm wont map think its has 3 parameters
00:13:50 <path[w]> oh it wont
00:14:02 <alinp> hi
00:14:04 <Saizan_> Orclev: you need base-4.1.* for that version of unix
00:14:14 <path[w]> thanks
00:14:15 <alinp> I'm having a [0..99] ... range I think is it called
00:14:23 <alinp> how can I make it a list ?
00:14:23 <Orclev> how do I check which version of base I have installed?
00:14:31 <dmwit> alinp: That is a list.
00:14:31 <Saizan_> Orclev: you'd have got a nicer error message if unix's cabal file wasn't broken
00:14:35 <dmwit> > [0..99]
00:14:36 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:14:39 <Saizan_> Orclev: ghc-pkg list base
00:14:53 <alinp> dmwit: ok ...
00:15:05 <alinp> > :t [0..99]
00:15:06 <Orclev> ah, 3.0.1 it seems... is it possible to do cabal install base?
00:15:07 <lambdabot>   <no location info>: parse error on input `:'
00:15:27 <dmwit> :t [0..99]
00:15:28 <lambdabot> forall t. (Num t, Enum t) => [t]
00:15:29 <Saizan_> Orclev: no
00:16:19 <Saizan_> Orclev: you need to upgrade your ghc to upgrade the base package
00:16:27 <copumpkin> w00t, my algorithm finally works
00:16:35 <copumpkin> well, not mine
00:16:42 <copumpkin> but my haskell implementation does
00:16:45 <Orclev> bah, figure gentoo would have an outdated copy of ghc
00:16:58 <copumpkin> Orclev: what version?
00:17:07 <Saizan_> Orclev: i think there's an haskell overlay with more recent versions
00:17:22 <Orclev> 6.8.2-r1 apparently
00:17:36 <copumpkin> ew
00:17:43 <elbar> Orclev: are you using the haskell overlay?
00:17:55 <Orclev> no, I'm not sure exactly how to go about doing that
00:17:57 <vav> Orclev: it's just masked I think, you just need to unmask it. but there's lots of good stuff in the overlay, worth it.
00:18:03 <Orclev> I just installed gentoo on here a couple days ago
00:18:09 <elbar> ah i c
00:18:15 <olsner> if there is a haskell overlay, couldn't you just get them to remove all the out-of-date haskell packages from the other distribution?
00:18:39 <Orclev> where would I go to find out about this overlay?
00:18:50 <elbar> Orclev: #gentoo-haskell
00:27:29 <vav> Orclev: did you get link posted in #gentoo-haskell? was just going to paste another, but you'd left.
00:28:15 <Orclev> vav: no, but I found a guide that told me about layman and that worked fine
00:29:36 <vav> ok, well you should also read about unmasking and keywording if you don't know about them yet.
00:29:37 <elbar> overlays are gentoo's spice =)
00:29:51 <alinp> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3395#a3395
00:29:58 <alinp> what I'm doing wrong here ?
00:30:03 <alinp> I can't figure it out
00:30:18 <copumpkin> alinp: stack overflow?
00:30:23 <alinp> no :)
00:30:33 <alinp> replace 99999 with 99 if you want
00:30:41 <copumpkin> I don't feel like copying and pasting it :P
00:30:45 <copumpkin> can't you just tell me what the error is ?
00:30:46 <copumpkin> :P
00:31:01 <alinp> sure
00:31:03 <alinp> [1 of 1] Compiling Main             ( Sum.hs, Sum.o )
00:31:03 <alinp> Sum.hs:12:22:
00:31:03 <alinp>     Ambiguous type variable `t' in the constraints:
00:31:03 <alinp>       `Num t' arising from the literal `0' at Sum.hs:12:22
00:31:03 <alinp>       `Enum t'
00:31:10 <copumpkin> oh
00:31:36 <copumpkin> :t rnf
00:31:38 <lambdabot> forall a. (NFData a) => a -> Done
00:31:52 <dmwit> alinp: evaluate(rnf(x))?
00:31:55 <copumpkin> alinp: basically, you haven't specified what type you want it to be
00:32:06 <copumpkin> so it doesn't know what instance of NFData to use for rnf
00:32:06 <dmwit> alinp: Why not just main = print x instead...?
00:32:19 <alinp> I don't want to print it :)
00:32:26 <Cale> Numeric defaulting doesn't apply when non-prelude typeclasses constrain the type variable in question.
00:32:29 <dmwit> hokay
00:32:32 <dmwit> :t evaluate
00:32:33 <lambdabot> Not in scope: `evaluate'
00:32:39 <copumpkin> alinp: just write :: Double or whatever you want it to be
00:32:41 <alinp> that's why I did the evaluate thing and rnf
00:32:42 <Cale> (I haven't looked at the paste, just a guess)
00:33:01 <copumpkin> Cale: that's it
00:33:52 <copumpkin> @hoogle evaluate
00:33:53 <lambdabot> Control.Exception evaluate :: a -> IO a
00:33:53 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
00:33:56 <copumpkin> :o
00:34:24 <dmwit> evaluate and rnf together seems like overkill for a number
00:34:59 <copumpkin> rnf == seq on most numbers too
00:35:12 <copumpkin> well, has equivalent behavior, if not the same type
00:35:13 <alinp> hmmm
00:35:18 <alinp> I will print it then
00:35:29 <copumpkin> or just annotate its type
00:35:46 <alinp> how exactly I'm doing that ? :)
00:35:48 <alinp> annotation
00:35:58 <copumpkin> there are 6 places you can put it as far as I can see :)
00:36:02 <copumpkin> evaluate(rnf (mysum [0..99999] (0 :: Double())
00:36:04 <alinp> (I can't figure it out where you sugest to do that)
00:36:05 <copumpkin> that's one of them
00:36:06 <alinp> oh
00:36:12 <copumpkin> (0 :: Double), sorry
00:36:50 <copumpkin> yeah, 6
00:37:42 <alinp> thanks guys
00:45:16 <lars9> hi, can haskell support auto-multi-threading? since methods has no side effect, the compiler should be able to determine what can be done parallel
00:45:47 <Cale> lars9: In practice, determining what's worth creating a new parallel process for is too hard for that.
00:45:48 <Saizan_> lars9: there's something similar but not completely automated
00:46:52 <koala_man> is there something that integrates with the profiler to try to determine that?
00:46:59 <lars9> so in practice ppl use forkIO explicitly?
00:47:13 <Cale> lars9: No, for parallelising pure computations, use par
00:47:45 <Saizan_> http://www.haskell.org/haskellwiki/Haskell_in_5_steps#Write_your_first_parallel_Haskell_program <- a trivial example
00:47:47 <Cale> lars9: x `par` y evaluates to y, but puts x on a queue of things to be evaluated if there's time available
00:49:21 <lars9> Saizan_: thanks, good example
00:49:34 <Cale> lars9: So it's like a hint to the compiler/runtime that x is a good chunk of work to do in parallel.
00:50:58 <lars9> yeah. it is. what's the difference between concurrency and parallel?
00:52:06 <Cale> lars9: Concurrency is about doing more than one thing at once. Parallelism is about computing a deterministic result faster because you have more than one processor.
00:52:31 <Cale> You can have concurrency on a single processor machine by switching between threads every once in a while.
00:54:24 <lars9> i see, emphasizing different aspects. I have these questions because I learnt a little erlang and thought haskell should be able to do better than it in concurrency because haskell is a purer fp
00:58:17 <vav> lars9: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html has some more examples and discussion
00:59:15 <lars9> vav: great, thanks:)
00:59:19 <mercury^> -prof does not influence strictness and other optimisations, does it?
00:59:28 <Cale> lars9: I think GHC's support for concurrency and parallelism for SMP machines is nicer than Erlang's, but we don't really have a coherent answer for distributed computation, and the stuff which Erlang does with restarting components is something we don't have an equivalent of.
01:03:56 <lars9> Cale: yeah erlang is more dedicated to concurrency & distributed computation.
01:04:15 <copumpkin> it'd be nice to try to break into that as well
01:04:29 <copumpkin> but it'd take a fairly large effort from multiple GHC hax0rz I'd expect :P
01:05:10 <eevar2> going distributed would also involve a whole bunch of trade offs, no?
01:05:13 <solidsnack> The Concurrent Haskell paper looks very promising.
01:05:34 <solidsnack> http://www.cs.umd.edu/~avik/projects/cmllch/
01:07:08 <ManateeLazyCat> What's hint of GHC error "Vte.chs:376:8: parse error on input `import'", and strange is Vte.chs just have 375 lines, haven't 376 line.
01:07:21 <chr1s_> hi all.
01:07:28 <ManateeLazyCat> I think it's hint another problem, and not import, any idea?
01:07:39 <chr1s_> all of a sudden I get these "Unknown fields: exposed-modules" warnings when building my package.
01:07:52 <chr1s_> is that deprecated?
01:08:25 <solidsnack> chr1s: Interesting. What version of Cabal do you have?
01:09:00 <chr1s> solidsnack: cabal-install version 0.6.0
01:09:00 <chr1s> using version 1.6.0.1 of the Cabal library
01:09:01 <ManateeLazyCat> And my Vte.chs is write for c2hs.
01:09:42 <ManateeLazyCat> @seen dcoutts
01:09:42 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow, #haskell-soc and #haskell-iphone. I last heard dcoutts speak 7h 2m 3s ago.
01:13:32 <Saizan_> chr1s: maybe it isn't under a Library section?
01:24:27 <quicksilver> mercury^: in general it does, yes
01:24:38 <quicksilver> mercury^: well not strictness. But other optimisations.
01:28:41 <lars9> hi, a general question about irc, when someone replies to my question by using 'lars9: xxxx', how should i answer, '/msg' or just 'Tom: xxxx'?
01:29:00 <quicksilver> Tom: xxxx typically.
01:29:47 <lars9> thanks quicksilver, if more than one persons said 'lars9: xxxx', how should i reply?
01:30:06 <quicksilver> it's not that important ;) YOu can just reply.
01:30:19 <chr1s> Saizan_: could be the case.
01:30:24 <quicksilver> you can do "Cale, quicksilver :" if you particular want to attract both their attentions
01:30:43 <chr1s> Saizan_: what's a library section?
01:30:52 <lars9> thanks, i'm learning manner in irc
01:31:22 <koala_man> lars9: and of course you know that you can tab complete nicks
01:31:33 <mercury^> quicksilver: My problem is that I have two functions that should do no allocation at all, yet amount for almost all allocations done by the program according to profiling.
01:31:47 <lars9> koala_man: yeah i do know that:)
01:31:51 <mercury^> So I was wondering if that is accurate or whether profiling caused it in the first place.
01:32:10 <quicksilver> mercury^: I imagine it's accurate but the reason you're surprised is that somethign got inlined
01:32:24 <quicksilver> mercury^: so the allocation really belongs to one of the functions called by those functions.
01:32:52 <c_wraith> mercury^: can you hpaste one of the functions in question?
01:32:58 <mercury^> Sure.
01:33:27 <chr1s> Saizan_: nm, thanks.
01:33:40 <mercury^> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8506#a8506
01:34:47 <quicksilver> pretty sure you want to force those "+1" thunks
01:34:53 <quicksilver> that looks like a space leak waiting to happen.
01:35:08 <c_wraith> I was just going to mention that.
01:35:19 <c_wraith> addition does allocate in functional languages. :)
01:35:40 <quicksilver> if you're trying to code a "tight loop" recursive function, which is what gen looks like
01:35:49 <quicksilver> you want to make it strict in all the accumulator-style parameters
01:36:08 <quicksilver> looks like you want that strict in r,n,m at least
01:36:14 <copumpkin> mercury^: easiest way to make it strict is to enable bangpatterns and ! your accumulators
01:36:19 <hackagebot> formlets 0.6 - Formlets implemented in Haskell (ChrisEidhof)
01:36:31 <mercury^> Hmm, I thought it would be recognised as strict. (In the case of the + it's much easier to do just do the addition than to allocate a thunk after all)
01:36:54 <quicksilver> mercury^: easier, sure, but different semantics.
01:37:16 <copumpkin> quicksilver: it should already be strict in r, I'd think? because of the guard depending on it?
01:37:21 <quicksilver> it's not a transformation the compiler can make unless it can see that they're always used strictly.
01:37:25 <quicksilver> copumpkin: yes.
01:37:35 <quicksilver> copumpkin: but mercury^ might refactor it later :)
01:37:40 <copumpkin> true :)
01:37:45 <quicksilver> copumpkin: once you're annotating strictness you might as well annotate them all
01:37:53 <copumpkin> fair enough
01:38:13 <mercury^> quicksilver: Hmm. But it already knows that none of the parameters is bottom when it makes the recursive call, so how is the semantic different?
01:39:02 <quicksilver> how does it know that?
01:39:04 <fasta> I have a complicated loop, in which a certain Bool exists, which is either true or false in this loop, but when I run the loop again. this Bool will always be false, but otherwise the same. So, essentially, I want to partially evaluate the loop. Is there a way to communicate this to the compiler? I mean, I would guess that simply passing another Bool to compare it to as the initial value of the loop (e.g. False) would do the trick, but I don't know whether GHC
01:39:04 <fasta> does partial-evaluation in this way, since I thought it didn't.
01:39:21 <quicksilver> mercury^: for example, I see no reason the compiler would know that m is not bottom
01:39:37 <mercury^> quicksilver: after "n == m" evaluated?
01:39:39 <copumpkin> fasta: pejo is working on making it do that, but it doesn't currently
01:39:52 <quicksilver> mercury^: but that's not necessarily evaluated.
01:39:58 <quicksilver> mercury^: the first case branch might be taken every time
01:40:03 <quicksilver> (as far as the compiler can see)
01:40:09 <quicksilver> first guard branch, I mean
01:40:14 <copumpkin> fasta: unless I misunderstood your question
01:40:15 <fasta> copumpkin: and that is expected to go into GHC when?
01:40:27 <quicksilver> maybe (r==ll) is always true
01:40:41 <fasta> copumpkin: I heard you talking about supercompilation the other day, so probably you understood correctly.
01:40:44 <copumpkin> fasta: http://community.haskell.org/~ndm/supero/ is what I'm talking about, and not sure when it's going in :) it's a lot of work
01:40:50 <mercury^> Ok, do I need to annotate anything for pick too?
01:40:54 <copumpkin> fasta: ah yes, that's it then
01:41:20 <quicksilver> mercury^: pick looks ok, since unsafeAt forces i each time anyway
01:41:50 <quicksilver> mercury^: although I would prefer to just annotate the top-level type of pick than annotate the fromIntegral
01:41:51 <copumpkin> fasta: pejo hangs out in #ghc, you could see if he has anything you can play with, but I'm not sure what state his work is in at this point :)
01:42:16 <mercury^> btw, is unsafeAt as fast as C array access, or does it involve another addition, because the indices may be offset for the array?
01:42:28 <fasta> Partial-evaluation in editors would be nice too. I mean, I can write terribly abstract loops, but sometimes you just want to analyze the case when some variable has some concrete value.
01:42:39 <fasta> This would be about the same as macro-expanding in Common Lisp.
01:42:41 <copumpkin> yeah, I've wanted that too
01:42:49 <quicksilver> mercury^: the indices can't be offset, IIRC
01:43:03 <quicksilver> mercury^: unsafeAt uses underlying (true) offset, not array index.
01:43:09 <mercury^> Ok.
01:43:35 <fasta> I wonder why all those tools don't exist.
01:43:50 <quicksilver> fasta: Yes. It's more common to type-specialise, which is why there is a pragma for that, but sometimes value-specialise is useful.
01:43:50 <fasta> Is it just that nobody can write them, or is nobody willing to pay for them?
01:44:32 <quicksilver> I think there isn't, or wasn't until recently, a convenient haskell source model which preserves whitespace and comments
01:44:34 <copumpkin> fasta: probably lack of enough people in community to work on such tools yet
01:44:39 <quicksilver> (which you need if you want an editor tool)
01:44:49 <quicksilver> I think nominolo's scion might be a framework which has that, though
01:44:55 <quicksilver> that's pretty new/experiemntal.
01:45:04 <fasta> Isn't scion dead already?
01:45:08 <quicksilver> no
01:45:12 <fasta> Oh, cool.
01:45:13 <quicksilver> nominolo is definitely still working on it
01:45:21 <quicksilver> and he had a GSoC student working on something related
01:45:34 <copumpkin> fasta: its github page is quite active
01:46:30 <fasta> I think it wouldn't be a bad idea to pool resources and pay someone to implement some tool, like they do in the NetBSD community.
01:47:06 <fasta> A clear contract with clear deliverables, at least that's how I perceived the NetBSD way of working.
01:47:37 <copumpkin> I'd be willing to contribute some amount
01:47:40 <doserj> there is http://industry.haskell.org/
01:47:44 <copumpkin> if you could get such a movement started
01:49:10 <mercury^> quicksilver: Ok, adding bang patterns didn't help the allocation but increased the program runtime. I'm confused.
01:49:24 <fasta> Yes, it would be best to first see how much everyone would be wanting to contribute.
01:49:28 <copumpkin> how many bangs did you add?
01:49:37 <mercury^> r, n and m
01:49:50 <quicksilver> compiling with -O?
01:50:11 <mercury^> Yep.
01:50:13 <copumpkin> fasta: set up a poll somewhere? there'd also be the issue of who to pay to do the work, but I'm sure we have plenty of smart freelancers who would have time :P
01:50:14 <mercury^> -O2
01:50:53 <quicksilver> well there is ahaskell consultancy who would do the work, but they might be expensive
01:51:04 <copumpkin> quicksilver: well-typed?
01:51:19 <fasta> copumpkin: quicksilver didn't want to advertise, I think.
01:51:23 <copumpkin> ah
01:51:44 <osfameron> doesn't mean somebody else can't ;-)
01:51:56 <osfameron> and it's always good to know the names of companies in the field
01:52:16 <fasta> @go haskell in industry
01:52:18 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
01:52:18 <lambdabot> Title: Haskell in industry - HaskellWiki
01:52:25 <quicksilver> no, I just couldn't remember their name :P
01:52:42 <copumpkin> fasta: anyway, getting a IHG counterpart for the community at large, maybe the CHG, would be cool :)
01:52:54 <copumpkin> with some pool of money for getting stuff done
01:53:09 <mercury^> And even making it strict in all arguments doesn't get rid of the allocation.
01:54:05 <osfameron> like the enlightened perl organization, but for haskell?
01:54:40 <fasta> osfameron: yes, there are quite a lot of those organizations. I only know of a few.
01:58:39 <Orclev> I'm about ready to beat emerge with a stick... it keeps trying to install the libraries in the wrong order... it tried to install regex-posix before regex-base
01:59:19 <mercury^> Oh, looking at the core, it seems gen was already strict in all visible arguments, but carried (and carries) 6 Int arguments, 3 for each array it seems.
01:59:25 <mercury^> Does anyone know what they are for?
01:59:26 <c_wraith> You might prefer haskell platform and cabal for managing haskell package versions, Orclev
02:03:49 <vav> Orclev: once you get it up and running correctly overlay's been very smooth for me. Please report any weirdness you're running into on #gentoo-haskell.
02:05:16 <path[w]> hey I have a question. When I have a function team guess list = (x, total - x)  (followed by a where clause etc)
02:05:20 <path[w]> the error I get is
02:06:32 <path[w]> cannot construct infinite type because - is applied to too few arguments
02:06:58 <c_wraith> what is the specific infinite type?
02:07:03 <fasta> path[w]: the error is in a location you have not shown.
02:07:32 <path[w]> hmm oh ok, it pointed out that line number, so I assumed it was that
02:07:56 <path[w]> there wasnt much else to the code its where folowed by 3 lines
02:08:00 <path[w]> total = sum list
02:08:07 <path[w]> teamValue = guess list
02:08:22 <path[w]> and x = min [teamValue, total  - teamValue]
02:08:46 <fasta> path[w]: min -> minimum
02:08:54 <fasta> path[w]: or remove [] and,
02:09:09 <path[w]> ah lol ok that was a strange error
02:09:12 <path[w]> ah
02:09:17 <c_wraith> :t min
02:09:22 <fasta> path[w]: you still have to think in Haskell.
02:09:23 <lambdabot> forall a. (Ord a) => a -> a -> a
02:09:29 <mercury^> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8506#a8507 -- I added the core for pick (gen is very long in comparison). Profiling says that a lot of allocation happens there. I don't see what causes it, do you?
02:09:43 <path[w]> yeah lol
02:10:00 <path[w]> one more question. Can that be made more succint. It seems too long for what it does
02:10:06 <path[w]> should I pastie it?
02:10:15 <fasta> mercury^: core output is great isn't it? /sarcasm
02:11:09 <fasta> mercury^: the only allocation you seem to be doing are tuples.
02:11:35 <mercury^> Where?
02:11:45 <fasta> mercury^: return (s, if r == 0 then m else m+1)
02:11:53 <mercury^> In the core I mean.
02:12:21 <fasta> mercury^: oh, never mind, that's only one allocation.
02:13:11 <path[w]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3398#a3398
02:13:13 <fasta> mercury^: I would love to see the profile output for that one. I don't see any issue with that code.
02:13:35 <mercury^> gen                            Main                  64.9   84.8
02:13:36 <mercury^> pick                           Main                  31.0   14.3
02:13:55 <c_wraith> path[w]: you've changed the semantics of the code
02:13:58 <doserj> path[w]: I guess you want paranthese in the last line there
02:14:08 <c_wraith> yeah.  parens are needed
02:14:15 <fasta> mercury^: you might want to seq the i+1
02:14:36 <fasta> mercury^: although, the optimizer should be able to fix that.
02:14:54 <mercury^> fasta: if you look at the core, you see i being an Int#
02:15:12 <fasta> mercury^: also, those numbers don't mean anything by themselves.
02:15:31 <fasta> mercury^: how long is the loop and how much is allocated?
02:15:45 <mercury^> If two things that shouldn't do any allocation allocate almost 67,042,837,032 bytes, that is quite something.
02:15:46 <path[w]> ok fair enough. But given that I fix the paranthesis
02:15:52 <path[w]> can I make it much shorter?
02:15:56 <path[w]> its 3 lines of where
02:16:11 <c_wraith> Maybe, but it would probably suffer in clarity
02:16:44 <path[w]> ah :/
02:17:15 <doserj> path[w]: teams guess list = sort [guess list, sum list - guess list]
02:17:32 <path[w]> is it alright to repeat the call to guess list?
02:17:38 <fasta> mercury^: I don't know, but I would first try to find the problem by looking at one loop at a time.
02:17:49 <path[w]> can I trust that ghc will make it a single call?
02:17:56 <doserj> path[w]: no
02:17:58 <mercury^> fasta: which is what I am trying to do here.
02:18:01 <c_wraith> ghc will not make it a single call, in general
02:18:12 <mercury^> But nobody has said what is wrong with the core for pick yet.
02:18:20 <path[w]> aw, what happened to referential transperity
02:18:45 <c_wraith> It's mostly an issue of not knowing which temporary values it calculates should be cached
02:18:51 <c_wraith> there's no good way to solve that in general
02:18:59 <path[w]> ah
02:19:02 <path[w]> so my guess function might be long, I wouldnt want to run it twice
02:19:02 <doserj> path[w]: referential transparency doesn't apply to evaluation order
02:19:36 <path[w]> the guess function is going to be the meat of this thing
02:19:43 <fasta> mercury^: maybe some of the functions you depend on allocates stuff?
02:20:11 <mercury^> Why would indexWord32Array# do allocation?
02:20:30 <path[w]> so in that case am I forced to use a where clause?
02:20:31 <fasta> mercury^: I don't know, but GHC is not a perfect system.
02:20:44 <etpace_> :t (***)
02:20:49 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:21:22 <fasta> mercury^: you appear not to be constructing any data structure, so the only level where it can happen is in one of the primitives you use.
02:21:48 <c_wraith> > (+1) *** (*2) $ 5
02:21:52 <lambdabot>   No instance for (GHC.Num.Num (b, b'))
02:21:52 <lambdabot>    arising from the literal `5' at <i...
02:22:01 <doserj> path[w]: either a let, or a where clause, yes.
02:22:02 <c_wraith> hmm.  Am I thinking &&&?
02:22:09 <c_wraith> > (+1) &&& (*2) $ 5
02:22:14 <lambdabot>   (6,10)
02:22:18 <c_wraith> So I am.
02:22:22 <mercury^> Is any GHC developer who might know around?
02:22:24 <fasta> mercury^: you should send it to the mailing list.
02:22:39 <fasta> mercury^: or open a bug report.
02:25:17 <c_wraith> > (+1) *** (*2) $ (3, 5)
02:25:20 <lambdabot>   (4,10)
02:26:39 <c_wraith> > ((+1), (*2)) <*> (3, 5)
02:26:41 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
02:26:41 <lambdabot>    arising from the literal `3' at <...
02:27:07 <c_wraith> @instances Applicative
02:27:09 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
02:27:25 <c_wraith> :t (<*>)
02:27:28 <quicksilver> the applicative instance for pairs isn't the one you want.
02:27:28 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:27:34 <quicksilver> which is not surprising, acutally
02:27:38 <quicksilver> because (a,a) has the wrong kind
02:27:52 <quicksilver> you'd need newtype Pair a = MkPair (a,a)
02:28:00 <quicksilver> to make the Applicative instance you wanted there.
02:28:08 <c_wraith> Hm
02:28:18 <quicksilver> > ("hi",(*2)) <*> ("there",5)
02:28:20 <lambdabot>   ("hithere",10)
02:28:34 <quicksilver> that's the instance for (a,b) in the standard lib.
02:28:40 <mercury^> fasta: how would you rate the severity?
02:29:27 <c_wraith> I'm a bit confused by that instance
02:29:38 <quicksilver> c_wraith: why?
02:30:11 <c_wraith> unless...
02:30:13 <fasta> mercury^: I forgot which one, but IIRC, the importance should be left alone so that GHC devs can set it.
02:30:25 <c_wraith> "hi" <*> "there"
02:30:31 <c_wraith> > "hi" <*> "there"
02:30:32 <lambdabot>   Couldn't match expected type `a -> b'
02:30:38 <c_wraith> Then, yeah.
02:30:54 <c_wraith> It treats the first and second elements of the pair differently
02:30:58 <c_wraith> That's not what I'd expect
02:31:01 <doserj> c_wraith: it uses a monoid structure in the first element
02:31:06 <quicksilver> c_wraith: it must.
02:31:08 <fasta> mercury^: otherwise the severity can be set to how severe it is for you. If GHC is completely useless to you in this state, I would consider it to be quite severe ;)
02:31:17 <quicksilver> c_wraith: Applicative (and Monad) apply to types of kind :: * -> *
02:31:26 <quicksilver> c_wraith: the only way to consider (a,b) as kind * -> *
02:31:33 <quicksilver> c_wraith: is to fix a.
02:31:48 <quicksilver> > [ord] <*> "there"
02:31:51 <lambdabot>   [116,104,101,114,101]
02:32:45 <c_wraith> So, since this is purely curiosity-driven anyway...  Where did the motivation for defining the *** operator come from?
02:33:24 <c_wraith> Is the combination of &&& and *** some sort of analog to <$> and <*> ?
02:33:40 <c_wraith> No, it can't be
02:33:42 <c_wraith> hmm
02:33:45 <quicksilver> not in a way which is obvious to me, no
02:34:11 <Axman6> > [(- ord 'a')] <*> [ord] <*> "hello"
02:34:13 <lambdabot>   Couldn't match expected type `a -> a1 -> b'
02:34:16 <Axman6> :(
02:34:30 <c_wraith> axman, you just want . there
02:34:40 <Axman6> good point
02:34:41 <etpace_> > [toUpper, toLower] <*> "hElLo"
02:34:43 <lambdabot>   "HELLOhello"
02:34:51 <Axman6> > [(- ord 'a') . ord] <*> "hello"
02:34:53 <lambdabot>   Couldn't match expected type `b -> c'
02:34:57 <Axman6> -_-
02:35:05 <doserj> f *** g is the categorical product of f and g (more or less).
02:35:13 <Axman6> > [(subtract (ord 'a')) . ord] <*> "hello" -- duh
02:35:15 <lambdabot>   [7,4,11,11,14]
02:35:37 <u_quark> how can I make cabal use a particular set of dependences ?
02:35:48 <c_wraith> unary minus strikes again
02:36:04 <Axman6> yeah, should have remembered that straight away
02:36:40 <c_wraith> @src subtract
02:36:40 <lambdabot> subtract x y = y - x
02:37:04 <c_wraith> :t (-)
02:37:06 <lambdabot> forall a. (Num a) => a -> a -> a
02:37:21 <c_wraith> I was really hoping it'd say "subtract = flip (-)"
02:38:20 <mercury^> Damn, trac completely broke the formatting.
02:38:41 <fasta> mercury^: {{{ code }}}
02:38:44 <ray> I AM UNARY MINUS
02:38:46 <fasta> mercury^: what's the bug nr?
02:38:51 <ray> LOOK UPON MY WORKS, YE MIGHTY, AND DESPAIR
02:39:00 <Axman6> you bastard :'(
02:39:14 <mercury^> 3458
02:39:17 * osfameron hopes ' will fix haskell's crufty minus
02:39:41 <c_wraith> Isn't the line "Look on my works, ye mighty, and despair."?
02:39:45 <ray> haskell' will come out in 2020 and be h98 with hierarchical modules
02:39:55 <ray> WELL LOOK WHO'S A POETRY PEDANT
02:40:05 <c_wraith> blame wikipedia
02:40:12 <ray> BUT YOU'RE WRONG EVEN
02:40:17 <int-e> ray: hehe. not funny! hahaha!
02:40:32 * osfameron lets loose the dogs of war, just to annoy c_wraith 
02:40:32 <ray> i need to stop with this shift key
02:40:37 <c_wraith> also blame wikipedia!  Or my faulty memory.
02:40:41 <c_wraith> One of the two
02:40:45 <int-e> @remember ray haskell' will come out in 2020 and be h98 with hierarchical modules
02:40:46 <lambdabot> Done.
02:41:01 <c_wraith> osfameron: at least you didn't let lose the dogs of war :)
02:41:14 <int-e> ... back to thinking positive ...
02:41:20 <osfameron> c_wraith: to lose one dogs of war is unfortunate, to lose two seems careless
02:41:33 <c_wraith> undoubtedly so
02:41:39 <ray> oops, the dogs of war have slipped off in the confusion
02:41:45 <osfameron> ray++
02:42:30 <c_wraith> would have been better if you'd said "in the havoc"
02:42:42 <c_wraith> :)
02:43:05 <fasta> mercury^: you should also try with a newer ghc release.
02:43:43 <mercury^> Compiling always takes so long. :(
02:43:45 <magthe> I'm starting to wonder if it's even possible to have a "quick look" at iteratee in order to grasp anything of it :(
02:43:55 <nose> http://es.beruby.com/promocode/u0NwGQ
02:44:14 <c_wraith> @ops
02:44:14 <lambdabot> Maybe you meant: docs oeis pl
02:44:29 <c_wraith> no, none of those.
02:44:39 <quicksilver> not much you can do about those fire and forget spammers
02:44:42 <ray> you mean @where ops
02:44:46 <quicksilver> no point me banning him now, he's gone
02:45:15 <magthe> can someone explain what is happening here?
02:45:15 <magthe> > fileDriver readLines "file.txt"
02:45:15 <magthe> Left []"
02:45:19 <lambdabot>   Not in scope: `fileDriver'Not in scope: `readLines'
02:45:22 <ray> whining to freenode might accomplish something, but it hardly seems worth the effort
02:45:51 <c_wraith> given the timing involved, that doesn't seem to have been automated spam, though.  That seems strange
02:45:53 <ray> the only solution is to strike at the root by destroying those promotional code websites
02:46:15 <quicksilver> not likely. affiliate marketing is big business.
02:46:22 <harblcat> are there any examples of how to use the Writer monad, by any chance?
02:46:41 <ray> fighter jets are bigger business, and in a fight, fighter jets win
02:48:14 <ray> the simplest example of Writer is probably keeping a String log
02:48:19 <magthe> harblcat: Chapter 15 of Real World Haskell has some examples
02:49:48 <harblcat> Alright. Thanks.
02:49:55 <ray> i used to think the writer monad was pretty confusing
02:50:09 <harblcat> I really ought to buy Real World Haskell, as much as I visit that site...
02:50:19 <ray> then i discovered the continuation monad
02:50:23 <path[w]> if I have a list of numbers and I want to find the number where some transformation is minimum. Is it more common to do minimumBy and compare 2 of them? Or do a map, zip with the original and then just do a minimum?
02:52:20 <ray> the second sounds like what i'd do but i don't know what is common
02:53:32 <Ferdirand> @src minimumBy
02:53:32 <lambdabot> Source not found. Where did you learn to type?
02:53:50 <path[w]> ok thanks
02:55:02 <ray> minimumBy takes an a -> a -> Ordering
02:55:34 <magthe> does anyone know if there are some _simple_ examples of using iteratee out there?
02:56:25 <path[w]> oh hmm even if I zip it, Ill still need a minimumBy
02:56:32 <path[w]> I cant do it with a just a minimum
02:56:45 <c_wraith> @instances Ord
02:56:50 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:56:57 <c_wraith> Looks like you can, to me
02:57:08 <c_wraith> > (1, 4) < (2, 1)
02:57:12 <lambdabot>   True
02:57:15 <path[w]> oh
02:57:34 <path[w]> (1,10000000000000) < (2,2)
02:57:43 <path[w]> > (1,10000000000000) < (2,2)
02:57:45 <lambdabot>   True
02:57:52 <path[w]> thanks
02:58:19 <c_wraith> > compare Nothing (Just 0)
02:58:21 <lambdabot>   LT
02:58:38 <c_wraith> > compare (Just 0) Nothing
02:58:40 <lambdabot>   GT
02:58:51 <c_wraith> Hm.  Nothing.  The universal minimum
02:59:09 <Orclev> is it possible to browse the source of something on hackage?
02:59:32 <c_wraith> yes.  the doc pages have "show source" links
03:01:27 <mreh> @src foldr
03:01:27 <lambdabot> foldr f z []     = z
03:01:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:05:13 <mreh> I want to replace all the threes in a list with two zeros
03:05:26 <mreh> cant work out how to do it with fold
03:05:59 <Saizan_> it's easy with a map
03:06:16 <Saizan_> and then you can implement map with foldr
03:06:23 <quicksilver> if you want to replace each 3 with two zeros
03:06:27 <quicksilver> then it's impossible with a map
03:06:30 <mreh> i dont think it's possible with fold, because it takes a function (a -> b -> b)
03:06:38 <quicksilver> length (map f xs) == length xs
03:06:40 <Saizan_> oh, sorry, misread
03:06:49 <quicksilver> that's why you need a fold
03:06:53 <mreh> and i'm replacing type Int with type [Int]
03:07:05 <quicksilver> fold can make an arbitrary list alteration
03:07:13 <Saizan_> so, it's easy with concatMap :)
03:07:46 <mreh> @src concatMap
03:07:46 <lambdabot> concatMap f = foldr ((++) . f) []
03:08:15 <quicksilver> > foldr (\x xs -> if x == 3 then 0:0:xs else x:xs) [] [1,2,3,4,5,4,3,2,1]
03:08:16 <lambdabot>   [1,2,0,0,4,5,4,0,0,2,1]
03:08:27 <quicksilver> all these speak of map and concatMap is just confusing the issue
03:08:33 <quicksilver> this is a trivial exercise in using foldr :P
03:08:58 <mreh> I'm destroying asteroids you see, replacing them with two smaller chunks
03:09:04 <mreh> this solution is satisfactory
03:09:59 <mreh> foldr (\x -> if x == 3 then (0:0:) else (x:)) [] [1,2,3,4,5,4,3,2,1]
03:10:09 <mreh> > foldr (\x -> if x == 3 then (0:0:) else (x:)) [] [1,2,3,4,5,4,3,2,1]
03:10:11 <lambdabot>   The operator `:' [infixr 5] of a section
03:10:11 <lambdabot>      must have lower precedence th...
03:10:20 <mreh> oops
03:10:26 <lilac> @pl \x -> if x == 3 then (0:).(0:) else (x:)
03:10:26 <lambdabot> ap (flip if' ([0, 0] ++) . (3 ==)) (:)
03:11:18 <mreh> mmmm brane asplode
03:11:34 <mreh> :t ap
03:11:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:11:48 <quicksilver> sometimes pointfree is not nicer.
03:12:01 <mux> > foldr (\x xs -> if x == 3 then (0:0:xs) else (x:xs)) [] [1,2,3,4,5,4,3,2,1]
03:12:03 <lambdabot>   [1,2,0,0,4,5,4,0,0,2,1]
03:12:14 <mreh> i hear some people call it "pointless"
03:12:14 <int-e> quicksilver: surely you must be talking in jest
03:12:19 <doserj> niceness of pointfree code depends on what combinators are available
03:12:24 <quicksilver> ;)
03:12:44 <quicksilver> SKI was enough combinators for barendregt, it's enough for me.
03:13:16 <int-e> Hmm. I haven't said this in a while. The thing that bugs me about point-free code is that it tends to be full of dots.
03:13:28 <mreh> so how might i replace 3 with an arbitary number of zeros?
03:13:58 <mreh> how can i apply (.) to (0:) lots of times
03:14:01 <int-e> @pl \a b c d e -> a (b (c (d e)))
03:14:01 <lambdabot> (. ((. (.)) . (.) . (.))) . (.) . (.) . (.)
03:14:01 <path[w]> @pl chooseBest xs ys = snd.minimum $ zip (map (\x -> abs (total - 2*x)) ys ) ys
03:14:02 <lambdabot> chooseBest = const (snd . minimum . (zip =<< map (abs . (-) total . (2 *))))
03:14:15 <int-e> (case in point - no pun intended)
03:14:16 <Saizan_> mreh: replicate n 0 ++ xs ?
03:14:22 * Yoric[DT] is scared by all this dotful pointless coding.
03:14:27 * Yoric[DT] will return to #ocaml .
03:14:34 <quicksilver> to be honest, mref, for problems like the evolution of a particle system I generally do use concatMap
03:14:50 <quicksilver> each asteroid can return a list of any length = zero items mean the asteroid has died
03:14:53 <quicksilver> 1 item means it continues
03:14:54 <mreh> who's mref?
03:15:02 <quicksilver> multiple items means it splits
03:15:05 <quicksilver> typo.
03:15:11 <mreh> ;)
03:15:18 <path[w]> @pl chooseBest total ys = snd.minimum $ zip (map (\x -> abs (total - 2*x)) ys ) ys
03:15:18 <lambdabot> chooseBest = ((snd . minimum) .) . join . (zip .) . map . (abs .) . (. (2 *)) . (-)
03:15:45 <int-e> slices of . is where you should draw the line, imho.
03:15:50 <mreh> quicksilver: that's a neat solution, dying asteroids leave a problem
03:15:54 <int-e> or sections?
03:15:55 <path[w]> hehe
03:16:10 <path[w]> whats =<<
03:16:16 <path[w]> :t =<<
03:16:19 <lambdabot> parse error on input `=<<'
03:16:22 <quicksilver> :t (=<<)
03:16:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
03:16:24 <int-e> (=<<) = flip (>>=)
03:16:32 <mreh> haha
03:16:46 <int-e> @src (=<<)
03:16:47 <lambdabot> f =<< x = x >>= f
03:16:55 <int-e> ok, so they spell it out.
03:17:09 <int-e> how unecessarily pointful.
03:17:52 <int-e> @pl \f a b -> f b a
03:17:53 <lambdabot> flip
03:17:57 <quicksilver> don't forget @src is a work of fiction, int-e
03:18:06 <quicksilver> it is just some nominal source someone put in a text file
03:18:10 <quicksilver> it's not the *actual* source
03:18:16 <Beelsebob> int-e: I actually quite like that definition
03:18:23 <mux> > let addZeroes n = (!! n) . iterate (0:) in addZeroes 3 [1]
03:18:23 <Beelsebob> I know it's not as efficient as the other
03:18:26 <lambdabot>   [0,0,0,1]
03:18:27 <int-e> quicksilver: I know. But it agrees with Control.Monad
03:18:28 <Beelsebob> but it looks nice
03:18:40 <mux> mreh: what about this?
03:19:16 <int-e> quicksilver: well, modulo whitespace.
03:19:19 <mreh> it's nice, but there are cases when I want to add no zeros
03:19:36 <mreh> so concatMap seems like the easiest, if not a little uglier
03:19:41 <mux> > let addZeroes n = (!! n) . iterate (0:) in addZeroes 0 [1]
03:19:43 <lambdabot>   [1]
03:19:51 <mux> mreh: works nice for the 0 case as well :)
03:20:05 <mreh> :t iterate
03:20:06 <lambdabot> forall a. (a -> a) -> a -> [a]
03:20:43 <dmwit> > let addZeroes n = (replicate n 0 ++) in addZeroes 3 [1] -- ?
03:20:44 <mreh> :t (0:)
03:20:47 <lambdabot>   [0,0,0,1]
03:20:47 <lambdabot> forall t. (Num t) => [t] -> [t]
03:21:38 <int-e> addZeros n = (!! n) . iterate (0:)
03:22:26 <int-e> (too cute. the replicate n 0 ++ version is lazier)
03:23:41 <dmwit> > [1,3,5,4,4,3,2,1,4,3] >>= \x -> if x == 3 then replicate 4 0 else [x] -- mreh, like this?
03:23:44 <lambdabot>   [1,0,0,0,0,5,4,4,0,0,0,0,2,1,4,0,0,0,0]
03:23:48 <dmwit> (Just scrolled up to read your actual question.)
03:24:27 <doserj> > let f x = replicate (x-1) (x-1) in [1..10] >>= f
03:24:29 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
03:24:45 <dmwit> > [0..] >>= join replicate
03:24:47 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
03:25:10 <path[w]> so (zip =<< map f)  means zip (map f x) x ?
03:25:32 <dmwit> Sounds right.
03:25:40 <quicksilver> yes, but only because that happens to be the (->) monad
03:25:49 <quicksilver> that is not a good way to get an intuition of what =<< does in general
03:25:55 <dmwit> Actually, it means \x -> zip (map f x) x
03:26:00 <quicksilver> the (->) monad shares arguments
03:26:03 <quicksilver> (x in this case)
03:26:11 <path[w]> ah
03:26:30 <path[w]> what makes it the -> monad?
03:26:46 <path[w]> s in how do I tell
03:26:47 <quicksilver> the types
03:27:06 <quicksilver> map f is a function, so that must be the (->) monad
03:27:16 <dmwit> You tell by working out the types slowly and laboriously in your head, or by asking ghci, or by experience. =)
03:27:24 <quicksilver> putStrLn =<< getLine
03:27:32 <quicksilver> ^^ getLine is IO, so that must be the IO monad
03:27:41 <path[w]> hmm ok
03:27:54 <quicksilver> put =<< get -- get is MonadState, so that must be a state monad
03:27:55 <quicksilver> and so on.
03:28:03 <quicksilver> class overloading is type-directed.
03:28:24 <path[w]> map f is a function from [a] -> [b] and zip is from [a] [b] -> [(a,b)]
03:28:45 <quicksilver> right.
03:31:02 <Baughn> ChthonLaptop: "What's a map"? Um..
03:31:09 <Baughn> > map (+3) [1..10] -- This is a map.
03:31:12 <path[w]> but if I declare let f = (* 2) and then  let b = zip =<< map f
03:31:13 <lambdabot>   [4,5,6,7,8,9,10,11,12,13]
03:31:17 <path[w]> ghci gives me an error
03:31:38 <lilac> @type (flip zip <*> map ?f, zip =<< map ?f)
03:31:40 <lambdabot> forall a b. (?f::b -> a) => ([b] -> [(a, b)], [b] -> [(a, b)])
03:31:40 <path[w]> no instance for monad ((->) [Integer]))
03:31:45 <dmwit> path[w]: import Control.Monad.Instances
03:33:57 <path[w]> ok that worked, but yeah Im still missing something. So when zip is fed a function, how did that make it the -> monad?
03:34:16 <dmwit> zip wasn't fed a function.
03:34:17 <fasta> It appears that Oleg's "generic zippers" are not really zippers. I can move down in a tree, but when I replace a certain node in the tree by another, then move up and move down again, it doesn't work, because it is a ZipDone term, as opposed to a Zipper term.
03:34:33 <dmwit> path[w]: zip =<< map f === (=<<) (zip) (map f)
03:35:31 <path[w]> oh ok
03:36:33 <fasta> According to my understanding of a zipper one should be able to move up and down, replace nodes where one wants, arbitrarily.
03:36:46 <mmorrow> fasta: i messed around with those a while back. yeah, i had to hack it a little to make it actually be (my idea of) zipper-like
03:37:09 <fasta> mmorrow: do you still have that code somewhere?
03:37:12 <mmorrow> fasta: i'll paste the complete jumbled mess of a module i was using as scratch to experiment
03:37:16 <mmorrow> yeah just found it
03:37:37 <fasta> mmorrow: I had to make his Zipper files compile with the newer del-cont package first too.
03:37:54 <fasta> mmorrow: thank you
03:37:59 <Baughn> > foldr (+) 3 [1,4,5] -- ChthonLaptop: Further adventures in implicit recursion
03:38:00 <lambdabot>   13
03:38:02 <mmorrow> fasta: ah, i'm using the original one (i think)
03:38:04 <mmorrow> np
03:38:15 <ChthonLaptop> > map (*2) [1..10]
03:38:17 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
03:38:31 <Baughn> @src map
03:38:31 <lambdabot> map _ []     = []
03:38:31 <lambdabot> map f (x:xs) = f x : map f xs
03:38:53 <ChthonLaptop> Lambdabot is a little laggy for me LOL
03:39:13 <fasta> ChthonLaptop: it is written in Haskell, what else do you expect?
03:39:27 <ChthonLaptop> Baughn afk a minute, please hold off, getting lunch.
03:40:01 <yitz> fasta: pls don't confuse network latency with GC
03:40:24 <path[w]> ok that leaves me with const
03:40:32 <path[w]> :t const
03:40:34 <lambdabot> forall a b. a -> b -> a
03:40:50 <fasta> yitz: hint: llort
03:40:50 <path[w]> > const 1 2
03:40:52 <lambdabot>   1
03:40:57 <path[w]> > const 2 1
03:40:59 <lambdabot>   2
03:41:01 <path[w]> heh
03:41:50 <yitz> fasta: i give up
03:41:59 <fasta> > reverse "troll"
03:42:01 <lambdabot>   "llort"
03:42:09 <fasta> yitz: I was not being serious.
03:42:11 <yitz> oh. heh
03:42:31 <fasta> mmorrow: can you find it?
03:42:35 <Baughn> fasta: Unfortunately, someone new to haskell would not understand that.
03:42:59 <MarcWeber> Saizan_: Thanks for talking to me yesterday. I have a different idea now. I still have to see whether it'll work out.
03:43:00 <lambdabot> MarcWeber: You have 1 new message. '/msg lambdabot @messages' to read it.
03:43:14 <u_quark> Axman6: may I ask for a configuration file for gitit ?
03:43:33 <u_quark> gwern: the same ^
03:43:38 <mmorrow> fasta: just got it to compile (was using module i no longer had) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3399#a3399
03:43:39 <fasta> mmorrow: hmm, I think I understand what needs to be changed already, but I am still interested in your version.
03:44:02 <mmorrow> fasta: it's not a version so much as a hack-a-long ghci session making incremental changes
03:44:17 <mmorrow> but fwiw
03:44:39 <fasta> mmorrow: my solution would be to remove the ZipDone term from the zip'traverse function.
03:44:56 * mmorrow looks at it to remember what's going on
03:45:51 <mercury^> fasta: Problem is still there with 6.10.4
03:45:57 <fasta> mmorrow: scuttle?! heh
03:46:06 <mmorrow> heh, i was running out of names
03:46:30 <mmorrow> tbh i can't even remember what the original code was
03:46:39 <mercury^> Interestingly, if I replace the UArrays with Foreign.Marshal.Arrays and unsafePerformIO, it gets considerably worse.
03:46:52 <path[w]> whats the nicest way to write [10,9,8,7,6,5,4,3,2,1] is it reverse [1..10]
03:47:07 <mercury^> > [10,9..1]
03:47:10 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
03:47:19 <path[w]> ah ok
03:47:47 <path[w]>  tried [10..1] and it gave me an empty list lol
03:48:41 <fasta> mercury^: In general, bug reports with more information are fixed earlier, so unless you want to become a compiler developer this is how far you can go.
03:50:27 <mmorrow> fasta: ah, ok. replZ1, then  Down,Next,Next,cut,Up,Up
03:50:40 <mmorrow> walks down, modifies the tree, then walks up
03:51:50 <fasta> mmorrow: and can you walk down again, after walking up?
03:51:55 <mmorrow> right
03:52:02 <fasta> mmorrow:  What is CC_FrameT?
03:52:15 <mmorrow> fasta: i'll just tarball this whole directoy
03:52:24 <mmorrow> (it's oleg's delimcont stuff)
03:53:11 <mmorrow> fasta: hrm, actually it's acting strabgely
03:53:14 <mmorrow> *strangely
03:53:34 <dmwit> It's rearranging my keyboard!
03:53:41 <dmwit> hmm, maybe I should get some sleep
03:53:43 <mmorrow> i don't think i really ever got it straightened out
03:56:17 <mmorrow> fasta: http://moonpatio.com/repos/MISC/zipper-oleg/
03:56:27 <mmorrow> is everything that that module depends on
03:57:05 <mmorrow> fasta: what's the type of his original zipper function (zip'through was it?)
03:57:07 <mmorrow> ?
03:57:42 <fasta> mmorrow: zip'through :: (Show t2, MonadIO t1) =>
03:57:42 <fasta>                Zipper t t1 t2 Direction -> CCT t t1 ()
03:57:50 <fasta> mmorrow: with CCT replaced by CC.
03:57:51 <ray> > [(),()..()}
03:57:54 <lambdabot>   <no location info>: parse error on input `}'
03:57:55 <ray> > [(),()..()]
03:57:57 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
03:57:58 <mmorrow> ah and what's the def of Zipper?
03:58:08 <fasta> > data Zipper r m term dir =
03:58:08 <fasta> >     Zipper term
03:58:08 <fasta> >          ((CCT r m (Maybe term, dir)) ->
03:58:08 <fasta> >             CCT r m (Zipper r m term dir))
03:58:08 <fasta> >   | ZipDone term
03:58:13 <lambdabot>   mueval-core: Prelude.read: no parse
03:58:13 <lambdabot>  mueval: ExitFailure 1
03:58:13 <lambdabot>   mueval-core: Prelude.read: no parse
03:58:13 <lambdabot>  mueval: ExitFailure 1
03:58:13 <lambdabot>   mueval-core: Prelude.read: no parse
03:58:15 <lambdabot>  mueval: ExitFailure 1
03:58:17 <lambdabot>   mueval-core: Prelude.read: no parse
03:58:19 <lambdabot>   mueval-core: Prelude.read: no parse
03:58:21 <lambdabot>  mueval: ExitFailure 1
03:58:35 <EvilTerran> err
03:58:36 <mmorrow> ah ok, i wasn't sure if i'd changed that datatype
03:58:45 <lilac> > [1,1..1]
03:58:48 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:59:02 <ray> something tells me that's wrong, but i'm not sure how to back that up
03:59:16 <lilac> ray: i would have expected [1] myself :-/
03:59:27 <ray> i suppose in a way it's right
03:59:38 <ray> > [True,True..True]
03:59:44 <lambdabot>   A section must be enclosed in parentheses thus: (`True..` True)Not in scope...
03:59:49 <lilac> > ([1,1..0], [1,1..2])
03:59:51 <lambdabot>   ([],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:59:55 <lilac> ^^ that's weird
03:59:57 <vav> > [1..1]
03:59:57 <ray> oh, right, stupid module thingy
03:59:58 <RayNbow> > [True, True .. True]
03:59:59 <lambdabot>   [1]
04:00:00 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
04:00:20 <ray> . is a really overloaded character in haskell
04:00:26 <quicksilver> the .. notation is just mess, really
04:00:31 <quicksilver> it looks convenient at first glance
04:00:31 <mmorrow> fasta: ohh, ok. i kind of remember what i was going for at least. that `zipper' function just parameterizes oleg's one by the "walk" (/gogo/scuttle/etc) function
04:00:38 <quicksilver> (and it certainly is convenient for the simple [1..9] case
04:00:39 <mmorrow> fasta: zipper :: (Monad (CC r m), Monad m) => ((a -> CC r m (Maybe a, dir)) -> a -> CC r m a) -> a -> CC r m (Zip r m dir a)
04:00:49 <quicksilver> but the other cases are a mess
04:01:03 * EvilTerran concurs with quicksilver 
04:01:23 <fasta> mmorrow: ok, but how do you avoid getting this ZipDone term?
04:01:28 <ray> quicksilver: i can see the logic by which those cases are correct, but i don't agree with it
04:01:54 <mmorrow> fasta: ah right, and i had to layer
04:02:00 <mmorrow> data Cxt r m a  = TopC r  | LocC a (a -> m (Cxt r m a))
04:02:23 <mmorrow> *on top* of all of (actually inside i guess) all of oleg's zipper stuff
04:02:35 <mmorrow> to get what i thought was going to happen initially
04:02:46 <fasta> mmorrow: you could publish a paper on this.
04:03:01 <fasta> mmorrow: "Actually working zippers", by mmorrow.
04:03:02 <mmorrow> (which makes me think either I'm Doing It Wrong, or that oleg's thing was different than what i thought it was)
04:03:09 <mmorrow> fasta: haha
04:04:13 <ray> Real World Zippers
04:04:25 <fasta> mmorrow: we should start counting in pico mmorrow's now ;)
04:05:13 <mmorrow> fasta: replZ2 works i think http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3399#a3400
04:05:46 <fasta> mmorrow: did you change any code there?
04:05:49 <mmorrow> no
04:06:01 <mmorrow> (i was trying replZ1 before, which is borked)
04:06:10 <fasta> mmorrow: I need some time to figure out exactly what you did and why it works (if it does)
04:06:36 <mmorrow> fasta: cool. let me know what you figure out, because i have to do the same
04:08:25 <fasta> mmorrow: does Mod have any use?
04:08:59 <mmorrow> iirc that's to be able to mess with the subtree, but not "commit" the changes
04:09:16 <mmorrow> it's nonessential to anything
04:09:52 <fasta> Are these two Bars shared btw? f (Bar a b c) = Bar a b 1
04:10:40 <mmorrow> unfortunately not
04:10:59 <fasta> mmorrow: right, so, you can add some extra sharing in your implementation. Kind of a detail.
04:11:36 <mmorrow> definitely
04:21:35 <ChthonLaptop> Is it possible to define a data type with named fields outside a function and use it later or do I have to define it every time?
04:21:50 <quicksilver> you can only definite data types outside functions
04:21:57 <quicksilver> so I'm not sure I understand your question
04:22:04 <quicksilver> haskell doesn't support local data types
04:22:08 <quicksilver> although it would occasoinally be handy
04:23:15 <ChthonLaptop> Ok, how do I make an object of a specific data type again?  foo :: type?
04:23:44 <quicksilver> no.
04:23:50 <quicksilver> :: is just an annotation
04:23:53 <quicksilver> it doesn't make anything.
04:24:02 <quicksilver> typically you make values of a specific type using the constructor of that type.
04:24:07 <quicksilver> data Fruit = Apple Int
04:24:13 <quicksilver> Apple 0 -- value of type fruit
04:25:34 <dschoepe> data Fruit = Apple { worms :: Int }, automatically creates a function worms to extract the Int from an Apple.
04:27:02 <ChthonLaptop> data Player = Player { str :: Int, agi :: Int, int :: Int , will :: Int, con :: Int, wounds :: [Wound], inventory :: [Item] }
04:27:25 <path[w]> Im sorry I keep forgetting which is the more optimal (albeit smaller range) datatype. Int vs Integer
04:27:28 <path[w]> it';s Int right
04:27:32 <ChthonLaptop> Say that was my data type, how would I make a individual records of that data type?
04:27:32 <Vanadium> yes
04:27:37 <Vanadium> Smaller range, shorter name~
04:27:43 <path[w]> hehe nice
04:27:49 <ray> ints aren't really integers, so they're not called "integers"
04:27:50 <quicksilver> ChthonLaptop: Player 0 0 0 0 0 [] []
04:28:12 <ChthonLaptop> Int is smaller than Integer
04:28:21 <quicksilver> ChthonLaptop: or, if you prefer record syntax Player {str=0,int=0,agi=0,int=0,wil=0,con=0,wounds=[],inventory=[]}
04:28:58 <ChthonLaptop> I mean what if I wanted to make a character of that data type named bob?
04:29:06 <ChthonLaptop> And another called fred?
04:30:36 <elbar> bob = Player ....
04:30:39 <elbar> fred = Player ..
04:30:40 <elbar> ?
04:30:45 <quicksilver> right, as elbar says
04:30:55 <ChthonLaptop> Would I type bob Player 0 0 0 0 0 [] []?
04:31:01 <quicksilver> bob = Player ...
04:31:06 <HugoDaniel> hi
04:31:15 <ChthonLaptop> Ahh, ok
04:31:28 <ChthonLaptop> That's what I was wondering
04:31:44 <ChthonLaptop> And to access the named fields then I'd just type str bob?
04:31:58 <quicksilver> right.
04:33:01 <ray> keep in mind that record syntax is only shorthand because it's more convenient than writing a bunch of functions like str (Player x _ _ _ _ _ _ _ _) = x
04:33:37 <Baughn> (And also, it allows you to add elements without altering your code
04:34:23 <quicksilver> ray: don't forget update syntax: bob { str = 12 }
04:34:30 <ray> yes
04:34:56 <ray> also more convenient than the alternative
04:35:00 <ChthonLaptop> Hrm.. I see, or I could make one mega function called stragiintwillconwoundsinventory (Player a,b,c,d,e,f,g) = (a,b,c,d,e,f,g)
04:35:04 <hackagebot> hoauth 0.0.1 - A Haskell implementation of OAuth 1.0 protocol. (DiegoSouza)
04:35:23 <ray> well, it would be pointless to turn it into a tuple
04:35:24 <Baughn> ChthonLaptop: You could do that, but that'd be /silly/
04:35:26 <ray> it's already a product of types
04:35:37 <Baughn> You'd need more functions to de-tuple the tuple, too. :P
04:35:43 <ChthonLaptop> Honestly I like the first one best :)
04:35:52 <ChthonLaptop> The second is a bit of a handful
04:36:32 <ChthonLaptop> The absurdity was part of the point :)
04:36:34 <ray> i'm just trying to point out that it's syntactic sugar, not magic, in case you've ever used another programming language
04:37:09 <ChthonLaptop> Do I have to declare data types in any particular order or does it read the whole file before it tries defining the types?
04:37:20 <ray> order doesn't matter
04:37:48 <ray> order only matters within the definition of a single function because it'll try the higher pattern matches or guards first
04:37:51 <Baughn> Mutual recursion is fine
04:37:58 <ray> a mutual recursion is fine too
04:38:01 <mercury^> Hmm, ghc-core fails to install with `Language.Haskell.HsColour.Options' does not export `Literate(..)'
04:38:34 <malcolmw> I removed the Literate type from hscolour only on Friday
04:39:16 <malcolmw> Sounds like ghc-core needs to be updated
04:39:52 <malcolmw> actually, I'm making some more API-breaking changes in HsColour right now, so maybe the ghc-core people should wait for a couple more hours
04:40:02 <path[w]> umm sorry, is there a div operator?
04:40:09 <quicksilver> > 5 `div` 2
04:40:11 <path[w]> 7 div 2 = 3
04:40:15 <lambdabot>   mueval-core: Prelude.read: no parse
04:40:15 <lambdabot>  mueval: ExitFailure 1
04:40:18 <mercury^> What does __DISCARD__ do?
04:40:19 <quicksilver> > 5 `div` 2
04:40:19 <path[w]> ah
04:40:21 <lambdabot>   2
04:40:34 <mercury^> Pop a cost centre?
04:40:40 <path[w]> oh ok so its a binary function that can be infixed?
04:40:52 <stanv> hello
04:41:03 <mercury^> Every binary function can be infixed.
04:41:17 <path[w]> I meant that is being =p
04:41:23 <path[w]> but hehe anyway thanks guys
04:43:18 * Zharf thinks Text.Regex.PCRE.String.regexec return value is weird
04:43:23 <ray> path[w]: there's also `quot`
04:43:27 <quicksilver> @hoogle regexec
04:43:27 <lambdabot> No results found
04:43:30 <ray> if you prefer truncating toward zero for some reason
04:43:33 <mux> do you guys know of a mathematical notation for the set of the prime factors of a number n?
04:43:43 <ChthonLaptop> Can you have an if statement in a data type declaration?
04:44:04 <ray> what do you want to do?
04:44:37 <stanv> I have one question about classes and instances. Consider: class A and class B say that their instances must have function foo. But in first case class A say that foo have type foo :: a -> [a], and in second case instances of class B must have function foo :: a -> a -> a. Is it possible same instance can be in class A and B in same time ?
04:45:19 <Toxaris_> stanv: yes, but then you have to use the module system to distinguish the two functions both named foo
04:45:47 <Toxaris_> @hoogle pure
04:45:47 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
04:45:47 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
04:45:47 <lambdabot> package pureMD5
04:46:11 <ray> :o
04:46:39 <Baughn> ChthonLaptop: What are you trying to do?
04:46:46 <stanv> Toxaris_: thanks
04:47:17 <ChthonLaptop> For example Equipment, if it's Type is armor then it has (type :: Type, PV :: Int, ArmorType, features :: ArmorFeatures), but if it's Type is (type :: Type, damage :: DamageType, kind :: WeaponKind, features :: ArmorFeatures)
04:47:21 <Baughn> ChthonLaptop: You can't have a normal if statement there, but since data definitions are all global anyway, I don't see what it'd be conditional /on/
04:47:26 <ChthonLaptop> err, second Type is weapon
04:48:03 <ray> haskell data types are tagged unions
04:48:08 <ChthonLaptop> This way I can have a separate set of stats for armor and weapons yet keep them in the same list
04:48:23 <ChthonLaptop> Or should I just list a weapon separately from armors?
04:48:27 <EvilTerran> ChthonLaptop, "data Equipment = Armor ArmorFeatures | Weapon WeaponKind WeaponFeatures"?
04:48:38 <ray> you want data Equipment = Armor Value ArmorType Stuff | Weapon Delicious Types Here
04:48:50 <EvilTerran> mmm... delicious weapon...
04:48:55 <EvilTerran> <.<  >.>
04:49:22 <ray> mmm, delicious tagged onions
04:49:29 <ChthonLaptop> LOL
04:50:05 <ray> are you familiar with Maybe or Either? it's like that
04:54:40 <EvilTerran> Cthulhon, anyway, with a single data type (say, "data Equipment"), you can have multiple constructors (Armor, Weapon, Potion, SillyHat, ...), and each constructor can have its own selection of parameters (the "Value ArmorType Stuff" bit in "= Armor Value ArmorType Stuff |")
04:55:31 <EvilTerran> so you could create a single data type for equipment, with a constructor for each equipment variety, and appropriate parameters for each constructor to describe the relevant properties of the equipment
04:55:36 <ray> it's a union because it can take on any one of these types, and it's tagged because you can pattern match on constructors
04:55:46 <ray> and it's delicious in soup
04:55:55 <EvilTerran> tag soup?
04:56:47 <ray> chop up and caramelize your tagged onion, then boil in beef broth with one bay leaf
04:57:01 <ray> broil and serve
04:57:36 <ChthonLaptop> I got it, but I realized after that if I allowed a list for weapons and armor, I'd have to do work to check if someone was equipping weapons to the exclusion of armor or vice versa.  Instead I'm going to separate those fields to simplify the back checking on what one has equipped.
04:58:09 <MarcWeber> vav: *g* Thanks. HAve you seen :WriteSampleConfigFileScion ?
04:59:57 <vav> MarcWeber: yes, although commented out all but the two from the README for now. Still plenty of new bits to learn from *Scion^D
05:13:40 <gwern> u_quark: a config file for gitit? just copy the default one, and remove any field you don't modify
05:15:58 <u_quark> yes gwern got it!
05:16:08 <gwern> u_quark: unless you had some need beyobnd just a copy to look at?
05:16:09 <u_quark> I was trying with the new format...
05:17:13 <u_quark> no no... is the git version stable enough - because there are many new features that I like :P
05:18:20 <gwern> u_quark: john and I and the darcs wiki run off HEAD; it's stable in the sense that it's usable, although we've gone through a number of configuration & HTML & etc changes, so it hasn't been stable in that sense
05:18:48 <gwern> u_quark: although with the academic year starting, john will be distracted and coding far less, so I suppose it'll soon be stable in that sense too...
05:20:52 <u_quark> ic....
05:21:12 <gwern> u_quark: anyway, we've hopefully gotten the config and resources straightened out; now is as good a time as any
05:21:36 <u_quark> yes tnx
05:22:09 <MarcWeber> vav: There isn't much to learn: All what works is :w! (Background type checking) and :ThingAtCursor.  Setup is done by :WriteSampleConfig and you load a config by :LoadComponent <tab> ..
05:22:45 <MarcWeber> vav: The next thing I'd like to implement is addimg / tidying up imports automatically. That's what takes much time when doing manually.
05:34:21 <hackagebot> hoauth 0.0.3 - A Haskell implementation of OAuth 1.0 protocol. (DiegoSouza)
05:34:56 <vav> MarcWeber: ah, like -ddump-minimal-imports via scion? yeah that would be very useful, esp. if doesn't break qualified Foo as F plus Foo (f,g) imports.
05:36:02 <quicksilver> -ddump-minimal-imports doesn't work
05:36:06 <quicksilver> otherwise it would indeed be useful.
05:37:45 <gwern> vav: unfortunately, it will
05:37:50 <gwern> I filed a bug about that
05:37:53 <gwern> a long time ago
05:38:09 <mercury^> Hmm, the bug with the overly large memory use might be that GHC incorrectly attributes profiling overhead to the program.
05:38:30 <mercury^> When I run a non-profiling version of the program with +RTS, it displays far less allocations.
05:38:32 * gwern thinks it's kind of eery how half my emails and conversations seem to be '(yes, that would be nice/no that doesn't work) and I filed a bug about that a while ago'
05:44:41 <linopolus> Hi
05:45:02 <Woof> Hullo!
05:45:49 <linopolus> I found 2 bindings for .*curses for haskell: hscurses and nanocurses. which one should i use? maybe it plays a role that i have no exp with curses
05:47:50 <gwern> they're both equally bad
05:48:07 <linopolus> what would you recommend to develop cli apps?
05:48:39 <ray> gwern: the inevitable fate of curses bindings :)
05:48:44 <gwern> indeed
05:48:55 <gwern> linopolus: vty maybe? it's at least actively developed for yi
05:49:14 <linopolus> i'll search what it is :)
05:49:32 <ManateeLazyCat> How to downcase string? Example: HASKELL => haskell
05:49:48 <u_quark> in gitit in the hackage version does jsMath work ?
05:49:49 <gwern> map toLower
05:49:53 <gwern> u_quark: no
05:49:56 <gwern> er, I mean yes
05:50:01 <gwern> but it doesn't come with jsmath
05:50:03 <ManateeLazyCat> :t lowercase
05:50:07 <gwern> you have to install the js yourself
05:50:11 <lambdabot> Not in scope: `lowercase'
05:50:12 <gwern> @hoogle toLower
05:50:13 <lambdabot> Data.Char toLower :: Char -> Char
05:50:20 <gwern> > map toLower "FOO"
05:50:24 <lambdabot>   "foo"
05:50:25 <u_quark> ok... but do i have to edit the template ?
05:50:35 * ManateeLazyCat hoogle found it just now :)
05:51:31 <gwern> u_quark: iirc you just drop the unpacked jsmath directory into static/js
05:53:08 <linopolus> are there any screenshots of vty?
05:53:18 <u_quark> but there is no js included anywhere as far as i can see...
05:54:19 <gwern> as I said, jsmath is a separate package
05:54:30 <gwern> part of the reason for the texmath stuff in HEAD
05:56:30 <u_quark> yes I understood that... but there is not link to the jsMath js fiels form the pages generated from gitit
05:57:12 <vav> linopolus: afaik looks just like curses. google for yi editor screenshots using vty frontend
05:57:46 <gwern> u_quark: are you using the right gitit version? there should be a message on startup
05:58:26 <MarcWeber> vav Now, like reading "unkown identifier xy" from the error messages and adding an import Data.Foo (xy) automatically
05:58:29 <Woof> Twey!
05:58:29 <u_quark> gwern: I am using the latest hackage version
05:58:30 <MarcWeber> s/Now/no
06:01:13 <vav> MarcWeber: ah, right. Well the bits you mentioned so far are working great, unlike many months ago when first gave it a try.
06:01:45 <gwern> u_quark: again, wiout more details I can't really say
06:03:22 <gwern> it's been a while since I setup jsmath on my wiki
06:05:30 <u_quark> well I could edit the template and include jsMath js but I was wondering if gitit does this by it's self...
06:06:04 <u_quark> because anyway jsMath is client side...
06:10:27 <Orclev> anyone know anything about the Text.Regex.Posix module?
06:10:30 * gwern thinks u_quark should just use HEAD/the RC
06:10:59 <u_quark> ok :)
06:12:19 <quicksilver> Orclev: well I know how to use it, and I know what posix regexp are.
06:12:24 <quicksilver> Orclev: what is your question?
06:12:24 <Orclev> I'm trying to follow something I saw in a tutorial and it's not working... =~ is supposed to have a return type for [String], but when I try that it complains that it can't find and instance declaration for (RegexContext Regex [Char] [String])
06:12:41 <Orclev> this is in ghci btw if that makes a difference
06:13:19 <quicksilver> Orclev: "foo" =~ "foo" :: [String]
06:13:23 <quicksilver> Orclev: works fine for me
06:13:27 <quicksilver> (and the result is ["foo"
06:13:35 <Makoryu> > ("pizza" =~ "zz") :: [String]
06:13:40 <lambdabot>   mueval-core: Prelude.read: no parse
06:13:40 <lambdabot>  mueval: ExitFailure 1
06:13:44 <Makoryu> WAT
06:13:45 <Orclev> fails for me
06:13:59 <quicksilver> Orclev: what modules do you have loaded?
06:14:15 <Makoryu> That exact "pizza" line works for me in ghci with only Text.Regex.Posix loaded
06:14:21 <Makoryu> So uh
06:14:25 <Makoryu> \O_o/
06:14:28 <Orclev> currently Text.Regex.Posix
06:14:33 <quicksilver> lambdabot doesn't have the regex modules loaded I guess.
06:14:40 <quicksilver> Orclev: hpaste part of your ghci session
06:15:13 <EvilTerran> ?type (=~)
06:15:19 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
06:16:19 <EvilTerran> ... that looks needlessly complicated
06:16:45 <ray> :t printf
06:16:47 <lambdabot> forall r. (PrintfType r) => String -> r
06:16:55 <ray> it should look more like that, you say?
06:17:09 <quicksilver> EvilTerran: Yes, you're not the only person to have misgivings about regex's incredibly overloaded operators.
06:17:15 <Orclev> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8514#a8514
06:17:19 <quicksilver> I tend to think of it as an experiment in massive overloading.
06:17:25 <quicksilver> I don't think I personally like the result.
06:17:27 <EvilTerran> printf is kinda complicated as well, it's just not readily apparent from the type sig
06:17:42 <ray> it's all hidden inside PrintfType
06:17:44 <EvilTerran> (and it lacks type safety. i guess there's a trade-off between complexity and type-safety for this kinda thing)
06:17:47 <gwern> http://www.reddit.com/r/programming/comments/9ddj7/ask_proggit_can_someone_explain_to_me_why_on/c0ccsds <-- do we relaly not have static checked printf?
06:17:54 <ray> oleg made it typesafe somehow
06:18:18 <quicksilver> Orclev: Hmm. Different version perhaps.
06:18:26 <quicksilver> which version of regex-posix are you uising?
06:18:28 <wjt> you replace the format string with a structured format DSL
06:18:30 <Orclev> give me a sec and I'll find out
06:18:44 <EvilTerran> gwern, we do, but it's not the one in the bundled libs
06:18:46 <ray> cool, i managed to say that to evilterran and gwern simultaneously without realising it
06:18:54 <wjt> and then you can be typesafe. for bonus points, you write some TH to turn printf-esque format strings into a structured format thingy
06:19:05 <Makoryu> EvilTerran: Hrm, is the typesafe one in hackage?
06:19:09 <EvilTerran> wjt, quasiquotes, even
06:19:30 <ray> @huckage liboleg
06:19:31 <wjt> EvilTerran: them're the badgers
06:19:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/liboleg
06:19:31 <Orclev> regex-posix-0.94.1
06:19:44 <EvilTerran> Makoryu, well, there's more than one, i think; there's probably at least one on hackage
06:19:50 * EvilTerran was going to rummage around okimj.org
06:20:10 <EvilTerran> *okmij.org
06:20:17 <quicksilver> Orclev: I'm on 0.72
06:20:30 <quicksilver> Orclev: the API must have changed, and the example your reading must be out of date
06:20:40 <quicksilver> (although it works on the version I'm using!)
06:20:42 <Orclev> using =~~ works, although the result is not useful
06:20:58 <blackdog1> urgh, fun bug: gcc compiles my ruby glue fine until i add another c file to the line, which includes a file which was already happily included. This now causes it to find syntax errors in the .h
06:20:59 <EvilTerran> heh, liboleg alone seems to have several implementations of printf :)
06:21:18 <ray> oleg made several printfs
06:21:24 <etpace_> > fmap (+1) (1,1)
06:21:26 * blackdog1 ponders crawling through jhc C output and shudders
06:21:28 <EvilTerran> blackdog1, so the .h isn't repeated-inclusion-proofed, then?
06:21:29 <lambdabot>   (1,2)
06:21:42 <ray> one is kinda boring and just extends printf to format any instance of Show
06:21:49 <ray> the others are type hackery
06:21:56 <blackdog1> EvilTerran: no, it seems to be.
06:22:00 <EvilTerran> that's weird
06:22:46 <Orclev> so uh... how do I get it to do what [String] used to do?
06:24:26 <quicksilver> Orclev: try (String,String,String,[String])
06:24:33 <quicksilver> or MatchResult String
06:25:00 <Orclev> hmm, I already tried the first one but it was so ugly I was hoping to find some other way of doing it... I'll take a look at the second one
06:25:29 <quicksilver> browse here for more options : http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-RegexLike.html#t%3ARegexContext
06:25:53 <quicksilver> [[String]] perhaps
06:27:09 <Orclev> [[String]] works
06:27:30 <Orclev> I wonder why it changed and if that's on purpose
06:32:11 <Orclev> oh well, at least all I need to do is pass the result of that to head to get the output you used to get out of [String]
06:33:16 * ChthonLaptop has lost all feeling in his tongue.
06:33:43 <Orclev> ... wtf?
06:33:44 <Phillemann> Doesn't the haskell wiki have a "printable version" of an article?
06:34:24 <ray> gwern, that's not cool, springing oleg on that guy like that
06:34:39 <ChthonLaptop> I took a sip of a really hot hot chocolate.
06:34:45 <ray> you need to soften the blow somehow
06:34:57 <Orclev> you know ChthonLaptop you seem to be very good at inspiring wtf reactions from me when I glance over at this window
06:35:38 <ChthonLaptop> :)
06:35:43 <ChthonLaptop> Thanks
06:36:06 <gwern> ray: it makes it all the funnier
06:36:21 <gwern> Phillemann: if the sidebar doesn't have a print link, then I guess hawiki's mediawiki is too old
06:36:39 <gwern> (although I didn't realize it was*that* old - print versions have been around for a long time)
06:36:49 <ChthonLaptop> The only downside to this is that it makes me unable to enjoy my hot chocolate :(
06:36:59 <Phillemann> There is a side bar? o_O
06:37:51 <fasta> mmorrow: are you sure that your version works? I have an example here, which seems to indicate that it doesn't. I will paste it shortly.
06:38:45 <gwern> Phillemann: yes. that rectangle on the left.
06:38:50 <gwern> you know, *that* thing
06:39:00 <Phillemann> http://www.haskell.org/haskellwiki/HXT
06:39:09 <elbar> ?pl \a b l -> lookup a l `mplus` lookup b l
06:39:09 <lambdabot> (. lookup) . ap . (mplus .) . lookup
06:39:12 <fasta> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8517#a8517
06:39:15 <roconnor> @seen monoidal
06:39:16 <lambdabot> monoidal is in #haskell. I don't know when monoidal last spoke.
06:39:17 <elbar> ?type  (. lookup) . ap . (mplus .) . lookup
06:39:23 <lambdabot> forall a a1. (Eq a1) => a1 -> a1 -> [(a1, a)] -> Maybe a
06:39:28 <monoidal> yes
06:39:42 <elbar> but ghci gives me :  () -> () -> [((), b)] -> Maybe b
06:40:09 <elbar> looks weird, doen't it?
06:40:13 <roconnor> monoidal: I think, but am not sure that the foldr (.) id is kinda like a left fold, while foldr ($) x is the "real" right fold.
06:40:18 <roconnor> monoidal: but I forget the details
06:40:28 <roconnor> and could be wrong
06:40:52 <monoidal> Both work on something like compose (repeat (const True)) True
06:41:02 <roconnor> ah
06:41:17 <EvilTerran> elbar, ghci's defaulting a1 to () for some reason
06:41:21 <monoidal> I was just curious if there are other differences, like memory usage etc
06:41:29 <monoidal> will add your version
06:41:40 <roconnor> monoidal: I think there are differences, but I forget what they are
06:41:44 <roconnor> if they even exist
06:41:45 <monoidal> ok
06:42:15 <vav> Phillemann: oh wow, with the default skin it doesn't have the 'printable version' link! try another skin in preferences. o_0
06:42:53 <roconnor> monoidal: um, which way do these folds fold?
06:43:04 <roconnor> > foldr (.) id [f,g] x
06:43:09 <lambdabot>   mueval-core: Prelude.read: no parse
06:43:09 <lambdabot>  mueval: ExitFailure 1
06:43:17 <roconnor> > foldr (.) id [f,g] x
06:43:20 <lambdabot>   f (g x)
06:43:26 <Phillemann> vav: I don't have an account. Isn't the printable version just a URL parameter?
06:43:27 <roconnor> > foldr ($) x [f,g]
06:43:29 <lambdabot>   f (g x)
06:43:30 <monoidal> roconnor: the same
06:43:34 <roconnor> ah good
06:43:51 <vav> Phillemann: append &printable=yes
06:44:12 <Phillemann> vav: Ah, great, thanks. :)
06:44:26 <vav> meh... http://www.haskell.org/haskellwiki/?title=HXT&printable=yes -- Phillemann not quite right
06:47:34 <ChthonLaptop> I see why I should use type in certain places and data in others.
06:48:25 <roconnor> monoidal: I'd be interested if they are in fact the same
06:48:30 <tibbe> nominolo: can we have scion install its emacs files somewhere rather than having to keep the source tree around?
06:48:55 <nominolo> tibbe: yes, I was planning to do it the way agda does
06:49:15 <nominolo> tibbe: they have a special program that finds out the path of the files
06:49:44 <nominolo> which lives somewhere in .cabal/share/blah
06:50:22 <tibbe> nominolo: great
06:50:39 <tibbe> nominolo: that got me stuck this morning before heading off to work
06:50:52 <tibbe> nominolo: can they be installed as extra data files?
06:50:58 <tibbe> nominolo: using that cabal feature
06:51:05 <nominolo> tibbe: I'd think so
06:51:26 <tibbe> nominolo: also, it'd be great if there was a Hackage release
06:51:34 <tibbe> nominolo: for the lazy among us
06:51:39 <gwern> nominolo: why not just use the Paths_ feature instead of shelling out to some special agda-like prog?
06:51:56 <nominolo> gwern: I think that's exactly what the prog does
06:52:10 <nominolo> gwern: it's not the agda prog it's some tiny helper perg
06:52:17 <gwern> silly agda people
06:52:24 <tibbe> nominolo: I can modify my .emacs to point into ~/.cabal/share whatever once it's installed
06:52:40 <edwardk> heya tibbe
06:52:46 <blackdog1> apologies for slight off-topic-ness, but it's for a haskell program - is this a valid C prototype?
06:52:46 <tibbe> edwardk: yo :)
06:52:50 <blackdog1> void rb_define_virtual_variable(const char*, VALUE(*)(ANYARGS),void(*)(ANYARGS));
06:52:58 <edwardk> did you get a chance to look at the iteratee slides?
06:53:09 <tibbe> edwardk: yup, I read em all, pretty interesting stuff
06:53:26 <nominolo> gwern: (load-file (let ((coding-system-for-read 'utf-8))
06:53:27 <nominolo>                 (shell-command-to-string "~/.cabal/bin/agda-mode locate")))
06:53:39 <gwern> lisp? in my #haskell?
06:53:42 <fasta> Has anyone here ever seen Oleg's generic zippers work?
06:53:49 <lilac> blackdog1: that looks valid to me, (a function which takes a string and two function pointers)
06:53:50 <tibbe> edwardk: I was wondering, among other things, if there's a nice mathematical concept behind Reducer just like there is for Monoid
06:53:53 <edwardk> fasta: yeah
06:54:13 <gwern> tibbe: aren't reduces all folds?
06:54:14 <fasta> edwardk: also for the case of going down, updating, going up and going down again?
06:54:48 <tibbe> gwern: I guess Reducer here is the function 'f' in 'fold f z xs'
06:55:09 <fasta> edwardk: or in other words: did you play with it yourself?
06:55:11 <edwardk> gwern: well, the unit operation for my reducers is analogous to the operation of the map of a functor on objects.
06:55:22 <blackdog> lilac: hm, ok. for some reason when i add another c file to the gcc line, it complains about it heartily, even though it's been previously included by the first c file
06:55:31 <edwardk> fasta: yeah i went and used zippers quite a bit, both ala oleg, and traditionally
06:55:44 <lilac> blackdog: can you paste the files and the errors?
06:55:50 <tibbe> edwardk: so I've been looking into using folds to process large amount of data, larger than fits in memory. I'm thinking about limiting the framework to only monoidal reductions
06:56:07 <tibbe> edwardk: so they can be parallelized arbitrarily.
06:56:33 <tibbe> edwardk: however, I ran into the snag that mappend isn't always efficient, in particular when mappening one element onto a collection
06:56:42 <edwardk> tibbe: yeah, thats why i started using monoidal parsing. i had a bunch of distributed 1 meg chunks that i needed to extract global results from ala map-reduce
06:56:46 <tibbe> edwardk: which is a natural thing to do in many data analysis
06:56:57 <edwardk> tibbe: thats why i have cons and snoc ;)
06:57:05 <tibbe> edwardk: as I mentioned I'm working on a Google Sawzall look-a-like
06:57:18 <tibbe> edwardk: isn't one of them enough?
06:57:18 <fasta> edwardk:  Can you then explain why tz_unexpected ends with a pattern match failure?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8518#a8518
06:57:27 <edwardk> tibbe: i was engaged in a similar exercise at the time
06:57:32 <edwardk> tibbe: only if your monoid is commutative
06:57:39 <tibbe> edwardk: and is there a mathematical structure that could be used as basis for Reducer?
06:58:04 <tibbe> edwardk: I'm only folding from left to right
06:58:07 <edwardk> fasta: i'll see what i can do. i have no compiler with me at the moment. (i'm at a symposium)
06:58:12 <tibbe> edwardk: and when assembling results I can keep the order
06:58:21 <tibbe> edwardk: of the chunks
06:58:37 <tibbe> edwardk: I will also need to have efficient merging of the results of each chunk, on disk
06:59:06 <tibbe> edwardk: the typical output would be one big Map that doesn't fit in memory. The idea would be to fold over a chunk, write the result to disk and finally merge the on-disk results
06:59:19 <tibbe> edwardk: similar to external sort I guess
06:59:52 <edwardk> tibbe: well, there is of course the notionof a monoid homomorphism from the free monoid
06:59:58 <blackdog> lilac: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3401#a3401
07:00:07 <tibbe> edwardk: this is all specifics though. I find any new insights into Iteratees interesting as I've spent quite some time discussing them with Oleg
07:00:16 <roconnor> > fromGregorian 1970 1 1
07:00:20 <lambdabot>   Not in scope: `fromGregorian'
07:01:04 <yrlnry> The paste at moonpatio.com has a "preview" button, but no option to edit the text after previewing!
07:01:29 <mun> hi
07:01:55 <roconnor> does Data.Time come with GHC?
07:02:08 <tibbe> edwardk: so the free monoid doesn't seem to require commutativity
07:02:14 <edwardk> tibbe: my usual map-reduce solution is to figure out what classes of operations i have available to me. monoids, commutative monoids, groups, working w/ multiplication on a ringoid w/ cancellative zero, etc.
07:02:43 <yrlnry> I have primes' () = EXPR   which has type (Integral a) => () -> [a], but when I do primes = EXPR, it has type [Integral].  Where did the polymorphism go?   Code at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3402#a3403
07:02:45 <mun> for the code at http://haskell.pastebin.com/m579a1761 how is the parser on line 9 implemented? is library lgraph { currentLogic = defLogic opts } supposed to return the implementation of the parser? if so, how is the behaviour defined?
07:02:51 <edwardk> when i have a monoid i can glue things together left to right, when its commutative i can reassemble chunks in any order as soon as answers come available
07:03:16 <yrlnry> What is a ringoid?
07:03:21 <edwardk> when i have a group i can actually update the result of a query post hoc based on just asking for the delta from every node in my distributed structure since the snapshot when the original result was calculated.
07:04:07 <edwardk> yrlnry: the short answer would be, a pair of monoids, where the lower monoid provides you with a 0 that is cancellative for the other. so (+,0) (*,1) where 0*x = x*0 = 0
07:04:25 <roconnor> cabal install time failed for me using GHC 6.8 :(
07:04:26 <yrlnry> Thanks.
07:04:48 <edwardk> yrlnry: add more structure to get to seminearrings, semirings, rings, etc. by adding distributive laws and enriching the (+,0) to be a group
07:05:13 <tibbe> edwardk: very interesting. I've been thinking about similar things lately. Which mathematical structures give you what opportunities for parallelization.
07:05:31 <mun> EvilTerran, hi are you there?
07:05:35 <roconnor> Linking /tmp/TMPtime-1.1.2.4/time-1.1.2.4/dist/setup/setup ...
07:05:35 <edwardk> tibbe: when i have a ringoid, i can short circuit the calculation when i'm using the multiplicative monoid, becuase the 0 provides you with early termination
07:05:36 <roconnor> /usr/lib/ghc-6.8.2/lib/process-1.0.0.0/libHSprocess-1.0.0.0.a(runProcess.o): In function `waitForProcess':
07:05:38 <roconnor> (.text+0x0): multiple definition of `waitForProcess'
07:05:46 <tibbe> edwardk: but for iteratees my problem has been to come up with a good definition which is in some sense minimal and easy to understand
07:05:53 <edwardk> tibbe: yeah
07:06:06 <tibbe> edwardk: we've been through a few
07:06:27 <edwardk> tibbe: iteratees are often hard for folks because they are inherently an inversion of control
07:06:31 <tibbe> edwardk: the current one seems quite workable (it lacks some of the horrible >>== operators previous definitions needed)
07:06:49 <tibbe> edwardk: but I still find some of the operations hard to define
07:07:18 <tibbe> edwardk: those related to shift/control in delimited continuations. quite possibly because I still don't understand delimited continuations well enough
07:07:25 * roconnor installs the ubuntu package instead
07:07:54 <Fairweather> can someone explain to me how `ap` is defined as liftM2?
07:08:00 <edwardk> tibbe: i have a monad of delimited continuations in category-extras
07:08:02 <Fairweather> I mean liftM2 id?
07:08:16 <monoidal> ylnry, due to monomorphism restriction
07:08:16 <fasta> edwardk: isn't reification of control a better name for inversion of control?
07:08:25 <monoidal> add a type signature and it will be ok
07:08:41 <edwardk> fasta: not sure, since reification is a pretty heavily overloaded term
07:08:49 <tibbe> edwardk: I think I need a good explanation of shift and control
07:08:51 <edwardk> afk, olin shivers is starting to give a talk ;)
07:09:17 <endojelly> > concat $ (++) <$> ["La","Le","Lu"] <*> ["Da", "Di", "Du"]
07:09:21 <lambdabot>   "LaDaLaDiLaDuLeDaLeDiLeDuLuDaLuDiLuDu"
07:09:42 <edwardk> delimited continuations often make sense to me in terms of ripping off a chunk of the stack and turning it into a pachinko machine
07:09:58 <tibbe> edwardk: for the iteratee stuff the naming is not the best either. "iteratee" is hard to pronounce and it's hard to interpret what it means by just hearing the name
07:10:13 <tibbe> edwardk: pachinko machine? :)
07:10:15 <monoidal> ylnry, you can also add {-# LANGUAGE NoMonomorphismRestriction #-}
07:10:32 <endojelly> filterM (const Nothing) [1,2,3]
07:10:33 <endojelly> > filterM (const Nothing) [1,2,3]
07:10:35 <lambdabot>   Nothing
07:10:42 <endojelly> > filterM (const Just False) [1,2,3]
07:10:43 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
07:10:43 <lambdabot>    arising from the literal `1'...
07:10:50 <endojelly> > filterM (const $ Just False) [1,2,3]
07:10:51 <lambdabot>   Just []
07:10:56 <endojelly> > filterM (const $ Just True) [1,2,3]
07:10:57 <lambdabot>   Just [1,2,3]
07:11:10 <edwardk> basically you grab onto a point on the stack and call a function, then you call into a magical function that rips off the stack all the way down to where you delimited it, and turns it into a function which takes the value you want the 'magic function' to appear to have returned, and gives you the answer that falls out of the bottom of the pachinko machine
07:11:19 <edwardk> so you drop in a ball, and it comes out of the bottom of the delimited stack
07:11:27 <monoidal> yrlnry: ^ sorry I mistyped your nick
07:12:17 <endojelly> > (++) <$> Nothing <$> Just "Foo"
07:12:19 <lambdabot>   Couldn't match expected type `a -> [a1]'
07:12:34 <endojelly> > (++) <$> Nothing <*> Just "Foo"
07:12:35 <lambdabot>   Nothing
07:12:44 <endojelly> > (++) <$> Just "Foo" <*> Nothing
07:12:46 <lambdabot>   Nothing
07:12:50 <endojelly> that is all so very awesome.
07:12:53 <Orclev> hmm... so I'm looking at the source of xmobar because I'm thinking about writing another monitor plugin for it, and I notice a function being used that looks to be part of the System.IO module, but I can't find it documented anywhere
07:12:58 <yrlnry> monoidal:  sorry, I should have been paying more attention.  We were having a really intense discussion about syntactic unification algorithms over in #britney.
07:13:02 <endojelly> gone are they days of awkwardly handling Maybe!
07:13:05 <yrlnry> monoidal:  thanks.
07:13:17 <endojelly> I just fmap and liftM and happy.
07:13:37 <endojelly> :t sequence
07:13:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:13:59 <endojelly> > sequence [Just 1, Nothing, Just 3]
07:14:01 <lambdabot>   Nothing
07:14:03 <Orclev> anyone ever heard of hGetLineSafe?
07:14:10 <endojelly> :t catMaybes
07:14:11 <lambdabot> forall a. [Maybe a] -> [a]
07:14:17 <endojelly> > catMaybes [Just 1, Nothing, Just 3]
07:14:18 <lambdabot>   [1,3]
07:14:22 <endojelly> :t some
07:14:24 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
07:14:29 <endojelly> @info Alternative
07:14:29 <lambdabot> Alternative
07:14:38 <endojelly> @src Alternative
07:14:38 <lambdabot> class Applicative f => Alternative f where
07:14:38 <lambdabot>     empty :: f a
07:14:38 <lambdabot>     (<|>) :: f a -> f a -> f a
07:14:46 <Axman6> @info ImBroken
07:14:46 <lambdabot> ImBroken
07:14:53 <edwardk> :t Data.Foldable.concat
07:14:55 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t [a] -> [a]
07:15:03 <Axman6> @info , map (*2) [1..10]
07:15:04 <lambdabot>  Parse error at "map" (column 3)
07:15:06 <edwardk> aw, shucks
07:15:10 <Axman6> lame
07:15:19 <endojelly> > some (Just "Foo")
07:15:24 <lambdabot>   mueval-core: Prelude.read: no parse
07:15:24 <lambdabot>  mueval: ExitFailure 1
07:15:27 <endojelly> > some (Just "Foo")
07:15:32 <lambdabot>   mueval-core: Prelude.read: no parse
07:15:32 <lambdabot>  mueval: ExitFailure 1
07:15:33 <edwardk> :t concatMap Data.Foldable.toList
07:15:35 <lambdabot> forall (t :: * -> *) b. (Data.Foldable.Foldable t) => [t b] -> [b]
07:15:38 <endojelly> , some (Just "Foo")
07:15:39 <edwardk> better =)
07:15:41 <lunabot>  luna: out of memory (requested 2097152 bytes)
07:15:46 <edwardk> generalized catMaybes
07:15:56 <endojelly> what the hell is "some" doing
07:16:02 <endojelly> edwardk, nice
07:16:03 <edwardk> > concatMap Data.Foldable.toList [Just 1, Nothing, Just 3]
07:16:05 <lambdabot>   [1,3]
07:16:33 <endojelly> @doc some
07:16:34 <lambdabot> some not available
07:17:11 <endojelly> does anybody know what Alternative, some and many is?
07:17:33 <edwardk> :t Data.Foldable.concatMap Data.Foldable.toList
07:17:35 <lambdabot> forall (t :: * -> *) b (t1 :: * -> *). (Data.Foldable.Foldable t, Data.Foldable.Foldable t1) => t1 (t b) -> [b]
07:17:41 <edwardk> even worse
07:18:00 <endojelly> when passing a non-empty list or a Maybe which isn't nothing both some and many don't seem to terminate.
07:18:28 <edwardk> endojelly: some is more useful for applicatives that describe things like grammars, etc.
07:18:40 <endojelly> edwardk, what does it do?
07:18:52 <edwardk> so when you use it over say, parsec, you get .. some (char '-') -- and it will generate a parser for a string of -'s
07:19:02 <idnar> @type some
07:19:03 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
07:19:16 <idnar> @src some
07:19:17 <lambdabot> some v = some_v
07:19:17 <lambdabot>   where many_v = some_v <|> pure []
07:19:17 <lambdabot>         some_v = (:) <$> v <*> many_v
07:19:17 <endojelly> edwardk, ooh.
07:19:23 <endojelly> > head (some [1])
07:19:28 <lambdabot>   mueval-core: Prelude.read: no parse
07:19:28 <lambdabot>  mueval: ExitFailure 1
07:19:30 <edwardk> some p = (:) <$> p <*> ps where ps = some p <|> empty
07:19:39 <idnar> @src many
07:19:40 <lambdabot> Source not found. My mind is going. I can feel it.
07:19:44 <idnar> @type many
07:19:47 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
07:19:57 <endojelly> idnar, doesn't tell you much, does it? 8)
07:21:29 * RayNbow had too much time on his hands... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8519
07:21:35 <idnar> endojelly: nope
07:23:01 <Orclev> what are <$> and <*> used for?
07:23:34 <edwardk> orclev: <$> is fmap <*> is analogous to 'ap' from a monad
07:23:43 <etpace_> > fmap (+1) . pure $ 1 :: [Int]
07:23:45 <lambdabot>   [2]
07:24:17 <yrlnry> I'm trying to define my first fromInteger function.  I want (Num a) => Num (PFInteger a).  So fromInteger should have type Integer -> PFInteger a.  But I only know how to define an function of type Integer -> PFInteger Integer.  How does anyone ever define fromInteger so that it is sufficiently general?
07:24:22 <int-e> f <$> a <*> b <*> c   is   f a b c   but with a, b and c evaluated within some instance of Applicative.
07:25:02 <Orclev> monads are still a bit of a hazy concept to me, I'll probably get the hang of them one of these days
07:25:30 <Axman6> > (+) <$> [1..3] <*> [7..9]
07:25:32 <lambdabot>   [8,9,10,9,10,11,10,11,12]
07:25:35 <Deewiant> yrlnry: You can use fromInteger on the Integer to get a Num a?
07:25:43 <yrlnry> Oh, that's it.  Thanks!
07:25:50 <edwardk> > (+) <$> Just (+1) <*> Just 2
07:25:51 <etpace_> > fmap (++"a") . pure $ "foo"
07:25:52 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
07:25:53 <lambdabot>    arising from a use of `GHC.Num.+'...
07:25:54 <lambdabot>   No instance for (GHC.Show.Show (f [GHC.Types.Char]))
07:25:54 <lambdabot>    arising from a use ...
07:25:58 <etpace_> how does fmap g . pure = pure . g for lists?
07:26:13 <edwardk> > (+) <$> Just 1 <*> Just 2
07:26:15 <lambdabot>   Just 3
07:26:21 <edwardk> > Just (+1) <*> Just 2
07:26:23 <lambdabot>   Just 3
07:26:52 <quicksilver> etpace_: map g . return builds a single element list and then applies to the (one) item in it
07:27:03 <quicksilver> etpace_: return . g applies g and then builds a single element list
07:27:08 <quicksilver> ...which is the same)
07:29:42 <yrlnry> Wow, <$> and <*> are great.
07:29:46 <mun> is the function at http://haskell.pastebin.com/m1d62d669 supposed to terminate? on line 9, it seems to call itself again for the same argument. how is it going to terminate?
07:30:15 <linopolus> How can i get a list of installed packages with cabal?
07:30:22 <linopolus> *cabal-install
07:30:36 <endojelly> yrlnry, I learned about them yesterday and, yes, they're great
07:30:41 <edwardk> mun: the first thing it does is (eof >> return ()) <|> ...
07:30:57 <dcoutts> linopolus: see cabal list --help
07:30:57 <Deewiant> linopolus: cabal list --installed
07:31:02 <edwardk> mun: so if it is at the end of file, it returns a unit. otherwise it goes off and does all the other stuff
07:31:42 <mun> edwardk, but on line 9, it just calls libItems l again where l is the original argument. so if l isn't eof, it'll just recurse forever, right?
07:31:47 <Orclev> ok, so <$> takes a function and applies it inside a monad, and <*> takes a function from inside a monad and applies it inside another monad... so what does <|> do?
07:32:20 <edwardk> mun: no, because in the meantime it called libItem, which should have eaten some of your input
07:32:32 <edwardk> the input is carried around implicitly because this is using some kind of parsing monad
07:32:49 <endojelly> mun, it's in a monad, think of it in terms of an implicit argument in that case
07:32:54 <edwardk> now, if libItem didn't consume any input, i.e. items could consist of no text, THEN you could spin forever
07:33:12 <Fairweather> a question: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8520#a8520
07:33:13 <edwardk> (or if you ran it on an infinitely long input, etc)
07:33:53 <mun> edwardk, i've pasted libItem as well http://haskell.pastebin.com/m1e133695 how does libItem consume any input?
07:34:32 <dino-> That's the group you add people to whom you'd like to be able to sudo and be root.
07:34:39 <dino-> bah, mischannel
07:35:00 <edwardk> mun: you'd need to recurse deeper, what does asKey do?
07:35:30 <linopolus> How can i remove a package with cabal-install?
07:35:36 <linopolus> didn't ind it in --help
07:35:37 <quicksilver> you can't
07:35:46 <quicksilver> if your hard disk fills up, buy a new computer
07:35:51 <linopolus> o_O
07:35:59 <blackdog> use ghc-pkg
07:36:10 <linopolus> /dev/mapper/linopolus-home
07:36:13 <linopolus>                       331G   13G  302G   4% /home
07:36:17 <linopolus> enough space :)
07:36:21 <linopolus> *puh..*
07:36:24 <blackdog> quicksilver: i've had situations where removing a package made it possible to install another one.
07:36:30 <quicksilver> yup.
07:36:30 <endojelly> things I haven't found any use for yet: Arrows
07:36:44 <endojelly> apart from very little things with pair
07:36:46 <endojelly> s
07:37:05 <mun> edwardk, i've pasted a bit more here: http://haskell.pastebin.com/m2bbaab56
07:37:37 <dino-> It's not completely hopeless, though. You can ghc-pkg unregister and blow away the files yourself.
07:37:45 <edwardk> so asKey calls pToken, and pToken consumes input
07:38:10 <dino-> They go into predictable places like /usr/local/share I believe
07:38:23 <quicksilver> endojelly: if you've used monads, you've probably used Kleisli arrows
07:38:32 <quicksilver> endojelly: but probably without actually using the Arrow typeclass.
07:38:39 <mun> edwardk, how do you tell pToken consumes input?
07:38:42 <endojelly> quicksilver, how so?
07:38:49 <quicksilver> endojelly: HaXml uses arrow types quite a lot, but without using the Arrow typeclass.
07:38:56 <quicksilver> possibly the typeclas is not that useful, in itself.
07:38:59 <edwardk> pToken: my general knowledge of how parser combinators work ;)
07:39:05 <endojelly> quicksilver, ah, okay
07:39:09 <quicksilver> endojelly: monadic functions a -> m b form an Arrow
07:39:17 <malcolmw> quicksilver: HXT makes the arrow thing explicit
07:39:18 <quicksilver> endojelly: and they're pretty common
07:39:21 <quicksilver> malcolmw: yup.
07:39:25 <endojelly> i see
07:39:26 <mun> edwardk, hmmm ok
07:39:27 <quicksilver> malcolmw: I'm not sure it gains much from that :)
07:39:34 <quicksilver> malcolmw: but then I haven't used HXT.
07:39:35 <edwardk> mun: look for the definition of string s
07:39:44 <edwardk> it is used in toKey
07:39:49 <edwardk> which is what is passed to ptoken
07:39:57 <malcolmw> quicksilver: standardised syntax I suppose, although I admit I have never used it either
07:40:23 <endojelly> Traverseable looks nifty.
07:40:26 <quicksilver> malcolmw: there don't seem to be so many uesful arrow combinators.
07:40:30 <fasta> edwardk: I suppose you haven't taken a look?
07:40:39 <edwardk> fasta: sorry man
07:40:44 <quicksilver> malcolmw: a Monad instance is useful, because you get to use 'mapM' and suchlike.
07:40:47 <edwardk> fasta: olin was more interesting than your problem ;)
07:40:55 <fasta> edwardk: what did he talk about?
07:40:57 <quicksilver> malcolmw: I don't find obvious similar things which make an Arrow instance useful.
07:41:07 <edwardk> fasta: adapting some work of one of his students to CFA
07:41:20 <mun> edwardk, yes, it's just a normal string though. i'm trying to see how it consumes the input. so you're saying pToken should consume it, right?
07:42:00 <malcolmw> quicksilver: HaXml's CFilter is very nearly a monad
07:42:13 <Orclev> I haven't had enough CS to understand arrows... or math theory for that matter
07:42:15 <mun> edwardk, but do you see that in the code?
07:42:59 <Fairweather> can someone please explain to me how can I take a  (a1 -> a2 -> r) -> m a1 -> m a2 -> m r  function, curry it with an (a -> a) function  and get a  m (a -> b) -> m a -> m b?
07:43:40 <Milo-> openGL bindings for haskell, worth learning?
07:43:41 <etpace_> How can I see the sources of instances?
07:43:58 <etpace_> @src Applicative.Maybe
07:43:58 <lambdabot> Source not found. I am sorry.
07:44:17 <ray> fairweather: in other words, you want to get ap from liftM2?
07:44:21 <Fairweather> I've been trying to wrap my head around this for hours now
07:44:30 <ray> usually it's done the other way around
07:44:30 <Fairweather> ray: yes, precisely
07:44:32 <tibbe> edwardk: sorry, dropped out for a second (had to talk to an intern)
07:44:50 <monoidal> @djinn  ((a1 -> a2 -> r) -> m a1 -> m a2 -> m r) -> (a -> a) -> (m (a -> b) -> m a -> m b)
07:44:51 <lambdabot> -- f cannot be realized.
07:45:06 <tibbe> edwardk: here's the other thing I've been thinking about, how do we generalize Foldable et el to "collections" that have side effects (e.g. folding over the bytes in a file)
07:45:10 <ray> fairweather: but it's easy to do it that way too - ap = liftM2 id
07:45:25 <etpace_> How is <*> defined for maybe? Just g <*> x = fmap g x?
07:45:55 <Deewiant> ?src Maybe (<*>)
07:45:56 <lambdabot> (<*>) = ap
07:46:01 <ray> lol
07:46:09 <tibbe> ?src Maybe ap
07:46:11 <ray> fairweather: does that make sense?
07:46:11 <lambdabot> Source not found. :(
07:46:13 <tibbe> doh
07:46:16 <tibbe> @src ap
07:46:16 <lambdabot> ap = liftM2 id
07:46:19 <Fairweather> ray: i've seen the definition, I don't get the meaning - how can you pass a one-argument function where a two-argument function is expected
07:46:29 <ray> all functions are one argument, remember
07:46:49 <ray> so id's type is a -> a, but that 'a' can be a function type
07:46:52 <Deewiant> Fairweather: Consider id applied to a function
07:46:54 <etpace_> @src liftM2
07:46:55 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:46:58 <lilac> Fairweather: id :: a -> a. if (a1 -> a2 -> r) ~ (a -> a), then a1 ~ a, a2 -> r ~ a
07:47:00 <Deewiant> What is the type of id in that case?
07:47:13 <lilac> Fairweather: where ~ means "is the same type as"
07:47:30 <Fairweather> (a2 -> r) -> a2 -> r?
07:47:39 <blackdog> hey, any recommendations for regex libs in haskell? trying to revamp some of my crappy old code a bit, it seems a bit off that i have to catch exceptions in the process of building a regex...
07:47:39 <etpace_> > fmap (+1) (Just 5)
07:47:40 <ray> yes
07:47:44 <lambdabot>   Just 6
07:47:48 <ray> so in this case that's the type of id
07:48:07 <Fairweather> this is awesome
07:48:13 <ray> since a1 is equal to (a2 -> r), the m a1 becomes m (a2 -> r)
07:48:36 <ray> if you want it to be even more awesome, consider that the "m" there can also be ((->) e) if you want
07:49:01 <Orclev> so far my favorite is Text.RegexPR, although I've had to use Text.Regex.Posix a few times
07:49:25 <Fairweather> what does ((-> e) mean? no class at all?
07:49:33 <lilac> Fairweather: another viewpoint: liftM2 takes a 'combining function' and two monadic values, and applies the 'combining function' within the monad. you have a monadic function and a monadic value, so the combining function you want is function application, or ($).
07:49:47 <ray> fairweather: (->) a b is the same as a -> b
07:49:50 <ray> just in prefix form
07:49:55 <lilac> Fairweather: so the way to do it is liftM2 ($). but ($) is a special case of id, so that's the same as liftM2 id
07:50:12 <endojelly> :t undefined :: (->) a b
07:50:15 <lambdabot> forall a b. a -> b
07:50:15 <blackdog> RegexPR? What package is that in?
07:50:22 <endojelly> :t undefined :: (->) a (->) a b
07:50:24 <lambdabot>     Kind error: `(->)' is applied to too many type arguments
07:50:24 <lambdabot>     In the type `(->) a (->) a b'
07:50:24 <lambdabot>     In an expression type signature:
07:50:25 <Axman6> :t undefined :: (->) Int Bool
07:50:26 <Fairweather> oh
07:50:27 <lambdabot> Int -> Bool
07:50:33 <endojelly> :t undefined :: (->) a ((->) a b)
07:50:34 <lambdabot> forall a b. a -> a -> b
07:50:41 <ray> it's just like putting parentheses around a value-level operator
07:51:06 <ray> however, ((->) e) is an instance of Monad
07:51:11 <Orclev> blackdog: one second I'll check
07:51:23 <ray> :t ap
07:51:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:51:45 <ray> so you can replace those "m"s with "e ->"
07:51:49 * Fairweather is writing it down
07:52:35 <ray> incidentally, ap and liftMn actually have their own typeclass called Applicative
07:52:45 <Orclev> blackdog: regex-compat I think, but I wouldn't swear to it
07:53:06 <ray> it's a subset of Monad, so Monad provides that stuff, but it's somewhat conceptually seperate
07:53:38 <Fairweather> is it a category theory thing?
07:54:02 <Orclev> blackdog: nope, that's not it
07:54:15 <ray> well, they're applicative functors
07:54:31 <blackdog> Orclev: ok, never mind. having a hack at pcre-light.
07:54:38 <ray> all this stuff can be considered category theory in a way
07:55:00 <jmcarthur_work> many things can be classified according to category theory
07:55:10 <jmcarthur_work> very unrelated things
07:55:15 <ray> @quote endofunctor
07:55:16 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
07:55:42 <Fairweather> thank you ray, I just got my dose of enlightment for today
07:55:56 <jmcarthur_work> @quote haiku
07:55:57 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
07:56:01 <jmcarthur_work> @quote haiku
07:56:02 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
07:56:02 <lambdabot> read
07:56:03 <ray> see, haskell types and functions between them form a category
07:56:20 <ray> how come one of those uses backslashes?
07:56:21 <endojelly> I really should read into category theory
07:56:32 <endojelly> although, thanks to Haskell, I think I have a pretty good idea of it by now 8)
07:56:50 <endojelly> what with monad, monoids, functors, endofunctors, covariance and contravariance and all that sutff
07:56:56 <ray> well, just generalize some stuff, because in haskell you're usually only working with the Hask category
07:56:59 * tibbe just ordered Pierce's intro to category theory for computer scientists
07:57:26 <ray> and learn some obtuse notation that should really be replaced by haskell notation
07:57:49 <ray> edwardk: where's that book i hear about? :)
07:58:06 <jmcarthur_work> book?
07:58:21 <ray> rumoured book
07:58:44 <yrlnry> I was very underwhelmed by Pierce's intro.
08:00:00 <Orclev> blackdog: http://hackage.haskell.org/package/regexpr
08:00:27 <Orclev> blackdog: it's not as powerful as some of the others, but it's a lot simpler to use
08:01:41 <Fairweather> ray++ for the good explanation.
08:03:44 <edwardk> ray: book? =)
08:03:45 <Orclev> yrlnry: you at a conference?
08:04:04 <edwardk> ray: i have yet to agree to actually write any book ;)
08:04:14 <yrlnry> Orclev:  no.   why?
08:04:23 <edwardk> depends on how things go with getting tufts to let me teach that course, etc.
08:04:30 <yrlnry> orclev:  * tibbe just ordered Pierce's intro to category theory for computer scientists
08:04:44 <ray> edwardk: so when is it being published? :)
08:05:28 <Orclev> yrlnry: ah... I thought I remembered someone saying something like "... is giving his introduction now" earlyer... with that and your mentioning about an intro I thought maybe there was a conference going on
08:06:56 <blackdog> so it feels like this could have some applicative goodness spread on it - any tips?
08:06:59 <blackdog>                         forever $ do s <- getLine
08:07:01 <blackdog>                                      response <- responder s
08:07:04 <blackdog>                                      putStrLn response
08:07:25 <jmcarthur_work> nah, not applicative
08:07:33 <jmcarthur_work> but there is some fun to be had
08:07:46 <quicksilver> getLine >= responder >=> putStrLn
08:07:47 <jmcarthur_work> putStrLn =<< responder =<< getLine
08:07:53 <blackdog> so that'd only be if you passed the results of each to putStrLn?
08:08:08 <jmcarthur_work> oh i don't know how the associativity of <=< relates to =<<
08:08:14 <jmcarthur_work> right
08:08:16 <quicksilver> me neither
08:08:21 <quicksilver> conceptually they're like $ and .
08:08:29 <quicksilver> but I'm not sure how their fixity compares in practice
08:08:33 <jmcarthur_work> yeah, it would be nice the their precedences played that way too
08:08:39 <blackdog> where are >= and >=> defined?
08:08:46 <quicksilver> >= was a typo ;)
08:08:53 <blackdog> >>=, then?
08:08:54 <jmcarthur_work> s/>=/>>=/
08:08:55 <quicksilver> @index (>=>)
08:08:55 <lambdabot> bzzt
08:08:56 <jmcarthur_work> yeah
08:09:01 <jmcarthur_work> Control.Monad
08:09:01 <ray> control.monad
08:09:02 <quicksilver> Control.Monad I think
08:09:18 <ray> rocketship is at least, >>= is prelude
08:09:26 <quicksilver> I think I'd probably write getLine >>= responder >>= putStrLn
08:10:07 <endojelly> what's the difference to using >=> before putStrLn?
08:10:18 <endojelly> I know what >>= does, not >=> though
08:10:23 <endojelly> :t (>>=)
08:10:26 <endojelly> :t (>=>)
08:10:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:10:34 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:10:34 <yrlnry> @type (>=>)
08:10:36 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:10:39 <jmcarthur_work> endojelly, (=<<) is like ($), (<=<) is like (.)
08:10:41 <endojelly> ah.
08:10:41 <quicksilver> (responder >=> putStrLn) will typecheck
08:10:47 <quicksilver> it composes two 'monadic functions'
08:10:50 <endojelly> thanks
08:10:52 <quicksilver> kleisli functions.
08:10:54 <jmcarthur_work> kleisli arrows
08:11:19 <endojelly> so the result of the previous action will be fed to a composition of both. got it.
08:11:52 <endojelly> (a >>= b) >>= c  ==  a >>= (b >=> c)
08:11:54 <endojelly> does that hold?
08:12:24 <jmcarthur_work> think so
08:12:34 <ray> >=> is the same as the Arrow combinator >>> but you don't have to deal with wrapping stuff in Kleisli
08:12:47 <jmcarthur_work> the third monad law is sometimes expressed as (a >=> b) >=> c  ==  a >=> (b >=> c)
08:13:04 <ray> omg it's almost like it forms some sort of monoid
08:13:06 <jmcarthur_work> and the first two are identities with return
08:13:12 <tibbe> >=> is rendered as a big red devil head in Colloquy
08:13:12 <jmcarthur_work> a category
08:13:25 <ray> lol
08:13:30 <ray> it's a rocketship
08:13:35 <Deewiant> ?. pl undo do s <- getLine; response <- responder s; putStrLn response
08:13:36 <lambdabot> putStrLn =<< responder =<< getLine
08:13:47 <jmcarthur_work> the documentation for Control.Category says id and (.) form a monoid, which i think is stretching it. a monoid is a category with one object
08:14:10 <jmcarthur_work> but i am not an expert in category theory
08:14:35 <ray> "monoid" just means "has associative and identity laws"
08:14:39 <quicksilver> jmcarthur_work: they do form a monoid.
08:14:49 <endojelly> yeah, so I think they do form one
08:14:50 <quicksilver> jmcarthur_work: because, if you wish to apply the monoid laws to them
08:14:59 <ray> (.) is associative, and id is an identity for composition
08:15:00 <quicksilver> jmcarthur_work: you inevitably restrict to a single object (because of the types)
08:15:02 <ray> therefore monoid
08:15:33 <quicksilver> so, you're right; but I would also say the docs make an unwise choice of words.
08:15:33 <lilac> jmcarthur_work: id and (.) :: (a -> a) -> (a -> a) -> (a -> a) form a monoid, for sure
08:15:42 <jmcarthur_work> quicksilver, that's convincing
08:15:53 <jmcarthur_work> lilac, sure. Endo
08:16:43 <lilac> jmcarthur_work: right. in the more general case, id and (.) form a monoid in the same way that return and (<=<) do (that is, it's not /quite/ a monoid, but close enough)
08:17:22 <ray> something of an intuitive monoid
08:17:28 <jmcarthur_work> lilac, i still think it's stretching it to actually call that a monoid
08:17:41 <jmcarthur_work> it does follow the laws
08:17:44 <Philonous1> Isn't a monoid supposed to be associative? How is (a,(b,c)) the same as ((a,b),c) ?
08:17:47 <jmcarthur_work> if you squint
08:17:58 <quicksilver> jmcarthur_work: well more precisely
08:18:08 <quicksilver> jmcarthur_work: it follows the laws if you forbid forbidden compositions.
08:18:16 <quicksilver> jmcarthur_work: but, that's out of character for a monoid
08:18:19 <jmcarthur_work> Philonous1, who said that?
08:18:22 <quicksilver> in a monoid all compositions are permitted.
08:18:31 <jmcarthur_work> quicksilver, exactly!
08:18:31 <quicksilver> so it's not a monoid if it has forbidded compositions
08:18:37 <quicksilver> (actually, it's a category. duh.)
08:19:25 <MyCatVerbs> quicksilver: Forbidden compositions - like Erich Zann's music?
08:19:25 <lambdabot> MyCatVerbs: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:19:34 <jmcarthur_work> Philonous1, there could exist a language in which (a,(b,c)) == ((a,b),c)
08:19:43 <Philonous1> jmcarthur_work: I'm sorry, I missread (.) for (,). So scratch that.
08:19:43 <ray> haskell's not it, though
08:19:46 <jmcarthur_work> cartesian product style tuples
08:19:48 <ray> oh, ok
08:19:51 <jmcarthur_work> Philonous1, ah, okay
08:20:20 <ray> there's Monoid instances for tuples of Monoids though :)
08:20:44 <jmcarthur_work> i at first thought that was where the confusion was
08:20:53 <fasta> Does anyone know where the code for http://www.cs.indiana.edu/~adamsmd/papers/scrap_your_zippers/ is?
08:22:10 <blackdog> can you import just <$> from Control.Applicative?
08:22:30 <quicksilver> of course.
08:22:32 <ManateeLazyCat> Hi, folks. This have any other IRC parser library that except `hircules` and `Network.IRC` ?
08:22:45 <blackdog> import Control.Applicative ( <$> ) doesn't seem to do the right thing
08:22:48 <ManateeLazyCat> I ready to develop an IRC-client.
08:22:58 <yrlnry> blackdog:  import Control.Applicative ((<$>)) maybe?
08:22:58 <blackdog> is there different syntax for importing operators?
08:23:13 <jmcarthur_work> you have to use prefix notation for imports, not infix
08:23:33 <jmcarthur_work> so operators need parens
08:23:47 <ray> manateelazycat: i haven't heard of any, but irc isn't very grammatically complicated
08:23:57 <blackdog> ah, that'd do it.
08:23:59 <ray> so if you are dissatisfied with those, making your own might not be a bad use of time
08:24:23 <etpace_> > [1,2,3] >>= (+1)
08:24:29 <lambdabot>   mueval-core: Prelude.read: no parse
08:24:29 <lambdabot>  mueval: ExitFailure 1
08:24:34 <pikhq> blackdog: Of course, you could just do: (<$>) = fmap
08:24:37 <pikhq> (it does!)
08:24:46 <blackdog> not as pretty :)
08:24:50 <ziman> > map return [1,2,3] >>= (+1)
08:24:54 <lambdabot>   No instance for (GHC.Num.Num [a])
08:24:54 <lambdabot>    arising from the literal `1' at <inter...
08:25:01 <blackdog> hm, so i've got randomWTreeElt (Node ls) = do elt <- stdGetRandItem ls randomWTreeElt elt
08:25:05 <ManateeLazyCat> ray: I'm not develop an single IRC-client, i just want embedded IRC-client in my gtk2hs framework.
08:25:11 <ziman> ah.
08:25:11 <pikhq> > (+1) <$> [1,2,3]
08:25:13 <lambdabot>   [2,3,4]
08:25:17 <lpsmith> How do you prevent memoization of CAFs?
08:25:19 <ManateeLazyCat> ray: So i'm not waste time.
08:25:21 <pikhq> (which is equivalent to:)
08:25:31 <pikhq> > [1,2,3] >>= return . (+1)
08:25:34 <lambdabot>   [2,3,4]
08:25:37 <blackdog> shouldn't that translate to randomWTreeElt <$> stdGetRandItem ls
08:25:46 <yrlnry> What's a CAF
08:25:47 <yrlnry> ?
08:25:47 <quicksilver> lpsmith: give them an argument ? I'm not sure it will work though
08:25:53 <blackdog> constant applicative form
08:26:00 <blackdog> top level constant, basically
08:26:21 <lpsmith> e.g.   fibs () = fibs' where fibs' = zipWith (+) fibs' (tail fibs')       used to work, but it doesn't any more
08:26:36 <etpace_> so is xs >>= f = concatMap f xs for lists?
08:26:37 <Berengal_> lpsmith, it doesn't?
08:26:46 <lpsmith> (Work in the sense of preventing memoization, that is)
08:26:47 <lpsmith> nope
08:27:10 <Berengal_> lpsmith, sure you're not hanging on to the resulting list somewhere else?
08:27:21 <etpace_> :t concatMap
08:27:27 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:27:28 <lpsmith> yes
08:27:47 <etpace_> :t flip . concatMap
08:27:49 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[b1]'
08:27:49 <lambdabot>     In the second argument of `(.)', namely `concatMap'
08:27:49 <lambdabot>     In the expression: flip . concatMap
08:27:54 <Berengal_> ghc should never memoize functions. If it does, you should file a bug report
08:27:54 <etpace_> gah
08:27:55 <Makoryu> :t flip concatMap
08:27:57 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
08:28:02 <Makoryu> :t concatMap
08:28:03 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:28:13 <etpace_> :t [] (>>=)
08:28:13 <quicksilver> Berengal_: but it will memoize values
08:28:15 <lambdabot>     Couldn't match expected type `(m a -> (a -> m b) -> m b) -> t'
08:28:15 <lambdabot>            against inferred type `[a1]'
08:28:15 <lambdabot>     In the expression: [] (>>=)
08:28:18 <quicksilver> Berengal_: and fibs' is just a value.
08:28:29 <etpace_> isn't that the right type?
08:28:32 <Berengal_> quicksilver, fibs () = ... isn't a value
08:28:38 <quicksilver> Berengal_: no, but fib's is.
08:28:41 <quicksilver> fibs'
08:28:46 <lpsmith> Well,  I vaguely seem to remember mention of the memoization of stuff in a "where" clause mentioned in a changelist at some point in time
08:28:49 <quicksilver> and it's fibs' that gets memoized for lpsmith.
08:28:50 <lpsmith> it was a while ago
08:29:02 <Berengal_> quicksilver, but it shouldn't be memoized. ghc doesn't lift lets past lambdas
08:29:08 <ray> :t =<< :: (a -> [b]) -> [a] -> [b]
08:29:10 <lambdabot> parse error on input `=<<'
08:29:19 <ray> :t (=<<) :: (a -> [b]) -> [a] -> [b]
08:29:20 <quicksilver> Berengal_: I don't believe there is any such guarantee
08:29:21 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:29:27 <Berengal_> quicksilver, I believe there is
08:29:37 <ray> etpace_: is that what you want?
08:29:38 <etpace_> > concatMap (return . (+1)) [1,2,3]
08:29:39 <Berengal_> We must now fight to the death
08:29:40 <quicksilver> Berengal_: well I've been told personally by GHC developers that there isn't ;)
08:29:42 <lambdabot>   [2,3,4]
08:29:46 <quicksilver> Berengal_: so I'm going to believe them over you.
08:29:53 <lpsmith> Beregal:  check out the full laziness transform :-)
08:30:08 <quicksilver> it doesn't happen all that often, though, and I don't understand why that is.
08:30:09 <lpsmith> err,  Berengal_ ^^^
08:30:15 <etpace_> the pdf says to define >>= yourself for lists, and ive defined it as flip concatMap, but thats wrong?
08:30:23 <jmcarthur_work> Berengal_ has rewritten GHC to conform to his beliefs about it. What do you say to that?
08:30:27 <ray> that's right
08:30:43 <ray> but it might be considered cheating to use concatMap
08:31:01 <ray> if it's not, then you're good
08:31:11 <etpace_> better to do it recursively with ++?
08:31:30 <ray> i don't know what this exercise is about :)
08:31:43 <Taejo> @src concatMap
08:31:43 <lambdabot> concatMap f = foldr ((++) . f) []
08:32:01 <etpace_> is from the typeclopedia, and it just leaves defining >>= for [] to the reader
08:32:19 <ray> you're correct anyway
08:32:39 <etpace_> its certainly helping my intuition with types
08:32:48 <Gilly> is there a function for the least strictly greater integer than x? (strict ceiling)
08:32:52 <ray> yeah
08:33:01 <lpsmith> Berengal:   Andre Santos'  thesis discusses moving lets around,  and GHC does do some of that
08:33:06 <ray> you just generalize from concat and map to join and fmap, and from concatMap to =<<
08:33:12 <ray> and suddenly monads
08:33:20 <lpsmith> Are you thinking about evaluating lets under a lambda,  maybe?
08:33:53 <Taejo> Gilly: isn't strictCeil x == floor x + 1 ?
08:34:04 <ray> i consider >>= to just be =<< flipped for convenience
08:34:13 <ray> it's a lot easier to think about =<<
08:34:13 <Berengal> lpsmith, some of it, like moving lets out of inner loops. I can't find anywhere that says exactly what it's doing...
08:34:26 <Taejo> in which case there is such a function: (+1) . floor
08:34:36 <lpsmith> full laziness is best described in Santos' thesis
08:34:39 <Gilly> Taejo: stupid me :) that's true
08:34:50 <lpsmith> lemme find a link quick...
08:34:53 <Berengal> lpsmith, I'm not looking for full laziness, I'm looking for ghc laziness
08:35:41 <Gilly> Taejo: thanks
08:36:00 <lpsmith> http://research.microsoft.com/%7Esimonpj/Papers/santos-thesis.ps.gz
08:37:03 <lpsmith> http://haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html#options-f
08:37:19 <lpsmith> -fno-full-laziness,     it doesn't quite mean what you might think :-)
08:38:24 <Berengal> lpsmith, I read that, but it also says ghc doesn't do full laziness. I'm looking to see what it does and doesn't do
08:38:29 <mxc> hi..  anyone happen to test ghc on osx snow leopard?
08:40:10 <lpsmith> Well, it does do some let floating,   I know because I've had to turn that optimization off in order to make some rather silly unsafePerformIO code do what it has to do :-P
08:43:47 <etpace_> :t \x -> g (h x) x
08:43:51 <lambdabot> forall t t1 t2. (SimpleReflect.FromExpr (t -> t1), SimpleReflect.FromExpr (t1 -> t -> t2)) => t -> t2
08:44:17 <endojelly> ...  what?
08:44:31 <endojelly> :t g
08:44:33 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
08:44:39 <etpace_> For >>= over the ((->) e) monad, is g >>= h = \x -> h (g x) x correct? that seems sort of like the <*> for ((->) e) right? for am I mistaken
08:44:42 <endojelly> oh. ok. whatever.
08:44:43 <Taejo> :t \g h x -> g (h x) x
08:44:44 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> (t -> t1) -> t -> t2
08:44:53 <Lanjiao> >3+4
08:46:21 <Lanjiao> hi, sorry, how can i run code here?
08:46:26 <Lanjiao> 3+4
08:46:32 <quicksilver> space after the >
08:46:38 <Lanjiao> thnaks
08:46:44 <Lanjiao> > 3+4
08:46:49 <lambdabot>   7
08:47:33 <Lanjiao> > :t swap
08:47:35 <lambdabot>   <no location info>: parse error on input `:'
08:47:45 <Lanjiao> >:t swap
08:47:58 <Lanjiao> :t swap
08:47:58 <endojelly> :t swap
08:48:02 <lambdabot> Not in scope: `swap'
08:48:02 <lambdabot> Not in scope: `swap'
08:48:03 <etpace_> > (+5) >>= (*) $ 2
08:48:06 <lambdabot>   14
08:48:11 <endojelly> lambdabot, did you mean flip?
08:48:12 <endojelly> :t flip
08:48:14 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
08:48:19 <etpace_> seems right I guess
08:48:35 <endojelly> Lanjiao, did you mean flip?
08:48:37 <endojelly> damn tab completion
08:49:08 <Lanjiao> don't know
08:49:30 <Lanjiao> runSF (loop (arr swap)) [1,2,3]
08:49:48 <Lanjiao> do you know the result?
08:49:59 * EvilTerran has encountered "swap ~(x,y) = (y,x)"
08:50:02 <endojelly> nope...
08:50:21 <endojelly> EvilTerran, with or without ~?
08:50:48 <EvilTerran> uh... with. as written.
08:50:57 <endojelly> EvilTerran, what does that mean?
08:50:59 <quicksilver> yes, that's the swap wanted there.
08:51:04 <EvilTerran> > let swap (x,y) = (y,x) in swap undefined
08:51:05 <poe> :t loop (arr (\(x,y) -> (y,x)))
08:51:06 <EvilTerran> > let swap ~(x,y) = (y,x) in swap undefined
08:51:10 <lambdabot>   mueval-core: Prelude.read: no parse
08:51:10 <lambdabot>  mueval: ExitFailure 1
08:51:10 <lambdabot> forall b (a :: * -> * -> *). (ArrowLoop a) => a b b
08:51:11 <lambdabot>   (* Exception: Prelude.undefined
08:51:14 <quicksilver> and SF is the [a] -> [b] arrow, apparently
08:51:25 <quicksilver> (I judge from a google search on Lanjiao's question)
08:51:30 <EvilTerran> endojelly, it makes the pattern-match lazier
08:51:40 <endojelly> EvilTerran, ahah? how so?
08:51:49 <EvilTerran> endojelly, without the ~, swap _|_ = _|_; with it, swap _|_ = (_|_, _|_)
08:52:05 <Lanjiao> it's from Section 2.3 of programming with arrow, http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf
08:52:19 <EvilTerran> endojelly, "swap ~(x,y) = ..." is like "swap xy = let (x,y) = xy in ..."
08:52:35 <endojelly> okay...
08:53:46 <EvilTerran> endojelly, it's described in http://haskell.org/onlinereport/exps.html#sect3.17.2
08:54:01 <lars9> it's so hard to think in the way of pure FP and lazy eval :$
08:54:42 <endojelly> EvilTerran, thanks
08:55:06 <lars9> need to forget all C data structures and algorithms first
08:55:31 <dhun> I wrote a parser for mediawiki that generates latex, now I am considering to rewrite it as a pandoc input plugin, any ideas, any warnings?
08:57:50 <blackdog1> is there an idiomatic way to convert from Either to Maybe?
08:57:55 <luite> does anyone know a haskell package or a paper describing a nice declarative way to specify interactive animation that is not directly executed in haskell (for example generate an interactive svg with javascript)?
08:59:49 <poe> > let { loop f as = let (bs,cs) = unzip (f (zip as cs)) in bs; swap (x,y) = (y,x) } in loop (map swap) [1,2,3]
08:59:55 <lambdabot>   mueval-core: Prelude.read: no parse
08:59:55 <lambdabot>  mueval: ExitFailure 1
09:00:22 <luite> blackdog1: probably using the either function, something like either (const Nothing) Just
09:00:28 <dschoepe> blackdog1: either (const Nothing) Just
09:00:32 <dschoepe> too late
09:00:41 <blackdog1> ah, that's a bit nicer. cheers.
09:02:07 <poe> > let loop f as = let (bs,cs) = unzip (f (zip as (stream cs))); stream ~(x:xs) = x : stream xs in bs; swap (x,y) = (y,x) in loop (map swap) [1,2,3]
09:02:09 <lambdabot>   [1,2,3]
09:03:26 <jpcooper> @hoogle (Monad m, Monad n) => m (n a) -> (a -> m (n b)) -> m (n b)
09:03:27 <lambdabot> No results found
09:03:31 <jpcooper> @type (>>=)
09:03:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:03:58 <jpcooper> @hoogle m (n a) -> (a -> m (n b)) -> m (n b)
09:03:59 <lambdabot> No results found
09:04:37 <jpcooper> @type liftM2 . (>>=)
09:04:39 <lambdabot> forall a2 r (m :: * -> *) a. (Monad m) => (a2 -> a) -> m (a -> a2 -> r) -> m a2 -> m r
09:05:42 <Lanjiao> poe, thanks a lot!
09:06:16 <etpace_> is join for ((->) e): join = id >>= ?
09:06:35 <dschoepe> @src ((->) e) join
09:06:35 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:07:11 <ray> join for everything is (>>= id)
09:07:12 <Taejo> @src join
09:07:12 <lambdabot> join x =  x >>= id
09:07:34 <etpace_> hmm
09:08:01 <ray> or (id =<<) as i prefer
09:08:45 <||Zero||> import System.Exit ( exitWith, ExitCode(..) )
09:08:54 <Lanjiao> @hoogle swap
09:08:54 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
09:08:54 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
09:08:59 <||Zero||> this line makes close the windown when i press esc
09:09:39 <blackdog1> i like applicative
09:09:41 <||Zero||> ???
09:09:52 <blackdog1> finally, programming in monads doesn't feel like stone tools
09:10:04 <etpace_> I want join :: (e -> e -> b) -> (e -> b) right?, >>= :: (e -> a) -> (a -> e -> b) -> (e -> b), but isnt id (a -> a)?
09:10:15 <ray> etpace_: that 'a' can be anything
09:10:20 <||Zero||> import System.Exit ( exitWith, ExitCode(..) )
09:10:24 <ray> that 'anything' includes function types
09:10:30 <Lanjiao> oh, this is really a wonderful place! can hoogle, can run code. everything else surprising?
09:10:32 <etpace_> but shouldnt id be on the lhs?
09:10:42 <||Zero||> this line close the windown when i press esc ???
09:10:50 <ray> etpace_: depends on which bind you use
09:10:58 <etpace_> well >>=
09:11:01 <ray> ok
09:11:09 <ray> that one takes the function on the rhs
09:11:44 <ray> you can do it without extra lambdas if you use =<< so i'm going to explain it with that
09:12:01 <etpace_> :t =<<
09:12:03 <lambdabot> parse error on input `=<<'
09:12:03 <ray> so (=<<) :: (a -> m b) -> m a -> m b
09:12:36 <ray> so if you apply it to id, that (a -> m b) has to match id's type, which is (a -> a)
09:12:51 <ray> so id's type here is m b -> m b
09:13:05 <ray> you just set a to be m b
09:13:15 <poe> Lanjiao: you're welcome!
09:13:35 <ray> which means the m a in the type becomes m (m b0
09:13:38 <etpace_> i see
09:13:39 <ray> m (m b) even
09:13:48 <ray> that's for any monad
09:13:50 <etpace_> then it does take a m m b to b
09:13:53 <etpace_> m b*
09:13:55 <ray> yes
09:14:02 <ray> :t join
09:14:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:14:12 <ray> :t (=<<) id
09:14:14 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
09:14:29 <etpace_> reasoning via types is quite new to me
09:14:44 <ray> if you use >>= you need an extra lambda
09:14:59 <ray> it has to be join x = id >>= x
09:15:18 <ray> reasoning via types is very haskell
09:15:41 <Taejo> etpace_: just because two things have the same type, doesn't mean they're the same unless there is only one thing of that type (which happens more often than you'd imagine)
09:18:30 <etpace_> How would I write >>= in terms of join? (for (-> e))
09:18:40 <etpace_> i cant get my head around that one
09:18:55 <ray> you just do the same thing backwards, sorta
09:19:19 <ray> again it makes more sense using =<<
09:19:25 <||Zero||> what is the projeccion matrix
09:19:29 <ray> (=<<) :: (a -> m b) -> m a -> m b
09:19:37 <||Zero||> i was reading but i dont understand it well
09:19:38 <ray> you may notice how similar that type is to the type of fmap
09:19:47 <||Zero||> ?????
09:19:49 <ray> there's just an extra m inside there
09:19:58 <Taejo> :t fmap
09:20:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:20:18 <Taejo> (where f = m)
09:20:22 <ray> so say you have f :: a -> m b
09:20:29 <ray> and you want to get m a -> m b
09:20:35 <ray> first, you fmap f
09:20:48 <ray> now you have (fmap f) :: m a -> m (m b)
09:21:12 <ray> and you can probably see where this is going
09:21:19 <||Zero||> can someone tell me what is exactly matrix projeccion
09:21:22 <ray> after you apply (fmap f) to some m a, you have an m (m b)
09:21:27 <ray> which you can join
09:21:34 <ray> annoyingly, you need a lambda
09:22:35 <etpace_> if I have (a -> a), can that also be (m b -> m b)
09:22:41 <ray> it can
09:23:03 <ray> anyway, join in terms of fmap and fmap in terms of join work for all monads
09:23:16 <ray> the only thing that's specialized for a certain instance is your first definition
09:23:35 <ray> er, not fmap, bind
09:23:52 <ray> the difference, however, is that to get bind from join you need to use fmap
09:24:38 <||Zero||> matrixMode $= Projection
09:24:42 <||Zero||> what is that
09:26:46 <etpace_> this pretty mindexpanding ray
09:27:10 <ray> it's good fun
09:27:31 <etpace_> very
09:28:12 <ray> @remember thermoplyae <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
09:28:13 <lambdabot> It is forever etched in my memory.
09:28:25 <Justin__> Hello.  I was wondering if somebody could help me with a monad problem?  I'm fairly new to haskell, and I can't seem to figure this problem out.
09:28:54 <c_wraith> ask away
09:28:56 <ziman> Justin__, sure, go ahead
09:29:01 <Taejo> ||Zero||: it sets matrixMode to projection. I've never used opengl in haskell, but it seems there are some global variables that are set with $=
09:29:38 <||Zero||> matrixmode is a function
09:30:09 <Taejo> then I don't know
09:30:28 <||Zero||> what does it exactly do
09:30:38 <||Zero||> eexample put the window black
09:30:57 <Justin__> Okay, thanks.  So I have a function simulation that looks like this: sim :: (a -> a) -> a -> [a] , and implemented sim f x = x:sim f (f x)
09:31:32 <Taejo> Justin__: looks like sim f = iterate (f . f)
09:31:41 <Cale> Er,  sim = iterate
09:32:05 <Justin__> Oh, maybe.  As I say, I'm a bit new to haskell.  I'll try that.
09:32:17 <Cale> Justin__: But what was the rest of the question? :)
09:32:27 <Taejo> if you meant what you said, Cale is mistaken
09:32:41 <Cale> Taejo: really?
09:32:49 <Taejo> sim f x = x:sim f (f x)
09:32:53 <Taejo> oh, no
09:32:54 <Cale> iterate f x = x : iterate f (f x)
09:32:57 <Taejo> yeah
09:33:00 <Justin__> But what I wanted to do was thread StdGen through it, so the step function has access to random numbers.  Like so:
09:33:04 <Justin__> (a -> State StdGen a) -> a -> State StdGen [a]
09:33:06 <Taejo> Cale's right, I'm wrong, sorry
09:33:16 <Cale> Justin__: ah
09:33:36 <Taejo> Cale: I saw three f's on the right :(
09:34:05 <Cale> Justin__: If the function you passed was ((a, StdGen) -> (a, StdGen)), then it would work okay
09:35:18 <Justin__> Cale: would that mean I shouldn't bother with the state monad, and just manipulate the pair myself?
09:35:29 <Cale> Well, in that approach, yeah
09:35:55 <Cale> I suppose there's a way to make this work with the state monad, but that's what I'd probably do initially.
09:36:26 <jfoutz> :t unfoldr
09:36:32 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:37:33 <c_wraith> @djinn (b -> Maybe (a, b)) -> b -> [a]
09:37:34 <lambdabot> Error: Undefined type []
09:37:38 <c_wraith> aww.
09:37:59 <Taejo> djinn doesn't generate recursive functions, does it?
09:38:11 <Cale> It doesn't. It has no concept of recursive types.
09:38:14 <c_wraith> no, but that signature doesn't require it be recursive
09:38:28 <Justin__> Cale: Okay, thanks for that.  I'll give it a shot.  It seems like (a -> State StdGen a) is almost the same, though?
09:38:39 <Cale> It is essentially the same thing
09:38:45 <Taejo> c_wraith: true, but [] is pretty useless without recursion.
09:38:56 <c_wraith> Taejo: also true :)
09:39:16 <Cale> a -> State StdGen a  ~=  a -> (StdGen -> (a, StdGen))  ~=  (a, StdGen) -> (a, StdGen)
09:40:12 <Cale> So if your program is already written in the state monad, it's not so hard to wire something up.
09:41:02 <Justin__> Cale: It isn't at the moment, I'm just starting out, but I thought it might make things easier in the long run.  What would the sim (or iterate) function look like with the state monad then?
09:41:21 <Cale> You'll likely need to use split on the initial StdGen state to make it work with the type signature you gave before... let's see.
09:43:31 <Justin__> Cale: I don't absolutely need that type signature, it was just how I thought I should solve it, to get an infinite list from a step function and a starting type.
09:45:44 <Cale> Well, if each step needs, say, exactly one random number, then there's another approach which might be nicer
09:46:09 <||Zero||> the fromintegral function what does it do
09:46:12 <||Zero||> ?????
09:46:32 <Cale> You can use randoms/randomRs to get an infinite list of random numbers from a StdGen and then use zip/zipWith
09:46:46 <Cale> ||Zero||: It converts any integer-like number into any type of number at all.
09:47:16 <Cale> :t fromIntegral
09:47:18 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:47:33 <Cale> > fromIntegral (5 :: Word32) :: Double
09:47:38 <lambdabot>   5.0
09:47:41 <Justin__> Cale: That could work, but I can't really guarantee each step only needs one.
09:48:46 <jpcooper> @pl fmap and . sequence . repeat
09:48:46 <lambdabot> fmap and . sequence . repeat
09:49:00 <jpcooper> @hoogle m Bool -> m Bool
09:49:01 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
09:49:01 <lambdabot> Data.Foldable or :: Foldable t => t Bool -> Bool
09:49:01 <lambdabot> Control.Exception block :: IO a -> IO a
09:49:18 <Cale> Justin__: okay, then I think the nicest thing would be just this plain way... the state monad can be somewhat awkward at generating infinite lists in this way because there's never a final state which it can capture (it never finishes generating the infinite list after all)
09:50:48 <Cale> :t let iterateS f x = do g <- get; let { (g',g'') = split g }; put g'; return . map fst . iterate (\(v,s) -> runState (f v) s) $ (x,g'') in iterateS
09:50:52 <lambdabot> forall a s (m :: * -> *). (MonadState s m, RandomGen s) => (a -> State s a) -> a -> m [a]
09:51:07 <Cale> It can be done, it's just more work.
09:51:34 <||Zero||> perspective 45 (fromIntegral width/fromIntegral height) 0.1 100
09:51:38 <||Zero||> in this line
09:51:47 <||Zero||> what is happening
09:51:48 <||Zero||> ???
09:51:52 <Justin__> Cale: With the step function as ((a, StdGen) -> (a, StdGen)) do you mean?  Which would make my sim: ((a, StdGen) -> (a, StdGen)) -> a -> [a]
09:53:02 <Cale> Justin__: That's the easier way... well, you'd get ((a,StdGen) -> (a,StdGen)) -> (a,StdGen) -> [(a,StdGen)]  just from iterate. Then by composing with map fst you'd get [a]
09:53:29 <Cale> ||Zero||: fromIntegral is being used to convert width and height to fractional numbers so that they can be divided.
09:53:39 <Cale> > (5 :: Integer) / 2
09:53:44 <lambdabot>   mueval-core: Prelude.read: no parse
09:53:45 <lambdabot>  mueval: ExitFailure 1
09:53:50 <Cale> blah
09:53:54 <Cale> Should be a type error.
09:54:09 <Cale> I guess the machine lambdabot's on is being slow today.
09:54:27 * Cale ssh's in to see if there's something wrong
09:54:29 <Deewiant> > (5 :: Integer) / 2
09:54:31 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
09:54:31 <lambdabot>    aris...
09:54:53 <Cale> lambdabot's gotten fat. I'm going to restart it.
09:55:08 <||Zero||> fractional numbers ??
09:55:16 <||Zero||> or float
09:55:31 <Woof> Twey!!!
09:55:42 <Woof> lambdabot! D :
09:55:58 <Woof> Oh, you're restarting her
09:56:01 <Woof> HER, not it >: O
09:56:21 <Cale> Twey has nothing to do with lambdabot afaik, btw.
09:56:33 <Woof> I know
09:56:41 <jpcooper> has anyone ever thought of making a state monad that includes the modification of MVars?
09:56:47 <Woof> I just called him for something else
09:56:49 <Justin__> Cale: Oh yeah, that looks good.  I assume it would be okay then to use "map fst sim" if sim is infinit?  I'm not 100% sure of how far lazy evaluation goes.
09:56:51 <Woof> Then I noticed lambdabot
09:56:52 <jpcooper> where the state is kept in the mvar
09:56:53 <lilac> jpcooper: sounds a lot like ST
09:57:07 <lilac> jpcooper: ah, i see what you mean now
09:57:27 <Cale> Justin__: that would be fine
09:57:49 <Cale> Justin__: It will just apply fst to the values in the list as you demand them.
09:57:52 <lilac> jpcooper: i'm not sure i see the point, to be honest
09:57:57 <dschoepe> jpcooper: perhaps STM might offer what you want.
09:58:04 <Cale> ||Zero||: Probably Double
09:58:23 <Justin__> Cale: Brilliant.  I'm off to try it out then.  Thanks for your help!
09:58:24 <Cale> ||Zero||: But it depends on the type of perspective, which I have no idea about.
09:58:25 <Woof> head, you mean, not fst
09:58:39 <lilac> data Probably a = YeahIts a | forall a. Typeable a => RandomSurprise a
09:58:42 <Cale> Woof: No, I mean fst.
09:58:45 <jpcooper> dschoepe, I thought it might be nice to have one operation to request the state rather than having to pass around tvars
09:58:48 <Woof> Unless it's something like ([1, 2, 3], [1..]) ?
09:58:54 <Cale> Woof: It's an infinite list of pairs, he's mapping fst over it.
09:59:05 <Woof> Oh, mapping, okay
10:03:26 <jpcooper> lilac, actually I could just use StateT with IO
10:04:37 <quicksilver> I could see virtues in using MonadState for your operations but then gluing them together with MVars or TVars
10:04:44 <quicksilver> so that you get "pure code which can run concurrently"
10:04:52 <leithaus_> about a year back i asked about structure that was both monadic and comonadic
10:05:11 <leithaus_> i found the coherence conditions that make this work
10:05:14 <jmcarthur_work> like streams?
10:05:24 <leithaus_> yes, like streams
10:05:32 <yrlnry> Thanks again to everyone here for everything.
10:05:48 <jmcarthur_work> interest piqued
10:06:05 <leimy> Just got really excited that there's an Erlang binding for Haskell, then I saw the license and realized I couldn't use it :-)
10:06:15 <leimy> I'll have to do something else.
10:06:34 <leithaus_> you want to acknowledge that gozintas and gozoutas have to match a certain discipline
10:07:26 <leithaus_> you want a framework that supports "classical" structure as well as "intuitionistic" structure
10:07:51 <leithaus_> List, Maybe, etc have intuitionistic structure
10:08:20 <leithaus_> in that if you put a value into a Maybe, you know you can take it out
10:08:45 <leithaus_> but if someone hands you a maybe, you don't know if it's got stuff in it unless you investigate
10:09:26 <leithaus_> for the classical case you need the following structure
10:09:48 <leithaus_> T -- an endofunctor (in Haskell known as the type ctor)
10:11:19 <leithaus_> you need a unit : a -> T a, mult : TT a -> T a, a counit : T a -> a, comult : T a -> TTa and you need a kind of distributive law
10:12:05 <leithaus_> d : TT a -> TT a that satisfies the following conditions
10:12:40 <saml> T.T so sad
10:12:44 <jmcarthur_work> hmm... i feel that this is very familiar to me
10:13:08 <jmcarthur_work> dang, work computer doesn't have the project that i wrote this in
10:13:15 <jmcarthur_work> *that i think i wrote this in
10:13:40 <jmcarthur_work> i do recall writing a dist function of this sort
10:13:48 <jmcarthur_work> for something that is both a monad and comonad
10:14:06 <leithaus_> comult . mult =T( comult) . d(T) . T( mult )
10:14:33 <jmcarthur_work> huh
10:14:53 <leithaus_> sorry, i'm mixing categorical and Haskell notation
10:15:05 <jmcarthur_work> it's fine. i follow. makes sense so far
10:15:23 <jmcarthur_work> i should be taking some notes
10:15:31 <leithaus_> http://arxiv.org/abs/0710.1163
10:15:34 <leithaus_> that's you notes
10:15:41 <leithaus_> someone else found it first
10:15:49 <jmcarthur_work> you rock for finding it
10:16:13 <leithaus_> they don't have the intuitionistic side of the story
10:16:35 <leithaus_> they're mathematicians, after all, so they don't have the same sort of orientation regarding computation
10:17:46 <leithaus_> i'm pretty sure that this way of telling the story is an alternate formulation of the work of Pavlovic, et al, on Frobenius objects in axiomatic Quantum Mechanics
10:17:50 <jmcarthur_work> i love adapting papers by mathematicians into cs, personally. it seems like i find a lot of revelations that way that may yet be undiscovered independently in cs
10:19:04 <jmcarthur_work> of course, i'm just subjecting my uneducated mind to torture that way sometimes
10:19:05 <leithaus_> one of the critically interesting questions is how to get from this "linear" world where every gozinta is matched by a "gozouta" to an intuitionistic regime
10:19:38 <leithaus_> think about it like this: quantum information is neither duplicable nor eradicable
10:20:06 <jmcarthur_work> quantum information has linear type, heh heh
10:20:18 <leithaus_> biological phenomena on the other hand is distinguished by these two characteristics: life begets life and all flesh is grass
10:20:35 <leithaus_> the quantum info/linear type connection is well established
10:20:50 <jmcarthur_work> this is not an area i am very familiar with
10:21:03 <leithaus_> but how do you get from the linear regime to the observably biological regime
10:21:29 <leithaus_> that's incredibly intriguing to me
10:21:37 <leithaus_> here's another way to look at it
10:21:48 <jmcarthur_work> i haven't put much thought into that, but i could see it keeping me up at night, for sure
10:21:54 <leithaus_> Haghverdi's linear combinators punt on !
10:22:08 <leithaus_> ! is not a combinator, it's *outside* the framework
10:22:51 <leithaus_> so, this is a real watershed, crossing from linear to intuitionistic
10:23:22 <leithaus_> in the meantime, i've got a nice little framework for combining monads and comonads
10:23:39 <leithaus_> i'm pretty sure this gives you a very nice framework for concurrency
10:24:06 <jmcarthur_work> curiosity piqued again
10:25:28 <cadabra> I'm using Text.Regex.Posix and trying to match against "(^[ \t]*//.*$)+". I want to extract blocks of "// ..." comments from a source file.
10:25:47 <leithaus_> https://docs.google.com/Doc?docid=0AZI9qM5f_1cfZGc5NnM5d25fMzE2YzY3OGY5Zjk&hl=en
10:26:09 <leithaus_> these are my notes for now
10:26:30 <jmcarthur_work> right-ended co-comprehensions..... awesome
10:26:49 <cadabra> But the match stops after the first line. :/
10:27:04 <leithaus_> if this works out the way i think it does, you also get the Conway construction as a freebie
10:27:22 <leithaus_> sort of a categorification of Conway games
10:27:27 * SamB recently discovered that the ssh flags -N, -D, and -f are really useful for setting up a SOCKS proxy at an IP address authorized to download ACM papers ...
10:28:37 * Zharf sighs
10:29:14 <ksf> do we have mIf :: Monad m => m Bool -> m a -> m a -> m a in the libs?
10:29:14 <lambdabot> ksf: You have 1 new message. '/msg lambdabot @messages' to read it.
10:29:21 <arw> SamB: which would be a proxy, which, according to the usual contract most paper-distributing organizations have with universities, is not allowed.
10:29:45 <arw> SamB: but I don't know anybody who cares, we use openvpn for that :)
10:29:51 <ksf> lambdabot is forgetting to forget, again.
10:30:09 <SamB> arw: lots of university libraries have proxies!
10:30:14 <SamB> mine might, even
10:31:01 <arw> SamB: yes, but the usual contracts state, that proxies which are externally reachable and vpn endpoints are not allowed to access the papers.
10:31:04 <SamB> but it's too much bother to figure out how to work it every time I want to download one
10:31:09 <Ferdirand> it's only a private one anyway. What is wrong with that ?
10:31:17 <SamB> arw: hey, I'm a student!
10:31:22 <arw> SamB: usually the require exemptions from the ip range they enter (which nobody does really) :)
10:31:37 <Ferdirand> it is not externally reachable by default
10:31:41 <lilac> @type (\a b c -> ([c,b]!!).fromEnum=<<a) :: Monad m => m Bool -> m a -> m a -> m a
10:31:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m Bool -> m a -> m a -> m a
10:31:50 <SamB> arw: who does?
10:32:10 <jmcarthur_work> leithaus_, huh. it will take some time for me to absorb this that i shouldn't spend at work, but it looks really neat. i'll read it more thoroughly later
10:32:17 <arw> SamB: nobody. i just had a nice long talk with our library techs about that topic...
10:32:35 <SamB> arw: are you saying I should have to go to the school to download the papers, or that I shouldn't be able to download them even there?
10:32:50 <ksf> I've got mIf p c a = p >>= \p' -> if p' then c else a . Am I lame now?
10:33:06 <arw> SamB: officially, you would have to be at the school at a school-owned computer
10:35:01 <arw> SamB: with 'beeing at' meaning physical location of your body, not "logged in at"
10:35:30 <arw> SamB: some even require that the terminal is physically located inside a library room
10:38:20 <||Zero||> hey someone knows a c++ channel but in spanish??
10:38:43 <SamB> arw: well, this is a bit tricky to determine for *nix machines!
10:39:03 <SamB> but anyway that takes too much time and bus fare!
10:40:19 <c_wraith> many schools have a VPN their students/staff can use to access those resources from home.  But it depends on your school and their contract with the provider
10:40:27 <arw> SamB: its impossible even for windows boxes. the solution of our library guys was to not give the outgoing proxy ip a 'proxyXY' name in dns and to not send proxy headers to the complaining sites :)
10:41:21 <arw> SamB: if you use rdesktop, ssh, vnc or whatever its not possible to filter anyways.
10:43:02 <ksf> we had ftp and sometimes svn access.
10:43:29 <ksf> if you wanted to see whether your program actually runs on the machines you have to demo it on, you had to go there.
10:43:36 <ksf> ...which, after all, makes sense.
10:43:51 <ksf> you wouldn't log into a desktop machine via ssh, anyway, but into a server.
10:44:22 <purplepenguins> depends on what you use your desktop for
10:44:59 <ksf> well, I certainly would'nt want to sit at a machine at school and have someone log in and forkbomb it.
10:46:02 <EvilTerran> ksf, we can ssh into the lab desktops at my uni
10:46:10 <EvilTerran> i think, if you forkbombed one, the techies would probably track you down
10:47:08 <ksf> well, ours were being deliberately and prinipially paranoid.
10:47:54 <ksf> like having two completely isolated network infrastructures (including cables) for administration vs. the rest
10:48:27 <badsheepy> thatsnot paranoid, its (un)common sense
10:48:31 <ksf> ...so you had no chance of finding out the telephone number of that cute blonde in the assembly lecture without actually asking.
10:49:04 <arw> EvilTerran: we have a shellskript for tracking forkbombs and other resource-eating uses which sends nice warning emails and kills the respective processes.
10:49:13 <Elench> Or "borrowing" her phone and calling yourself
10:50:56 <smarmy> you're a born stalker
10:50:58 <arw> separate cabling is paranoia. all modern switches know about vlans :)
10:51:19 <ksf> well, they started in vampire tag times.
10:51:25 <Elench> Nah, it's just how i exchange phone numbers, one party manually types in the other's number and then pranks
10:52:07 <ksf> and if you did stuff properly, you still use the same cabeling as in hub times.
10:52:57 <ksf> ...and, maybe most importantly, if it weren't for seperate networks, the admin machines would have internet connection, at least potentially.
10:53:44 <ksf> you don't want to have your students rice their marks instead of learning for exams...
10:55:03 <sshc> > let lastBut n = head . foldl (\acc x -> if length acc < n + 1 then acc ++ [x] else tail acc ++ [x]) [] in lastBut 2 [1, 2, 3, 4, 5]
10:55:04 <lambdabot>   3
10:55:18 <sshc> dmwit: ^ (how's dvorak been for you?)
10:56:23 <sshc> copumpkin: is that possible with "fold" and without "if"?
10:56:29 <copumpkin> ?
10:56:39 <copumpkin> :t times
10:56:40 <lambdabot> forall a. Int -> (a -> a) -> a -> a
10:56:44 <copumpkin> aha, it's still there
10:56:50 <copumpkin> sshc: try using that :)
11:00:21 <ksf> @hoogle CFloat -> Float
11:00:21 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
11:00:22 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:00:22 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
11:02:33 <path[l]> hi guys, I have a question about performance and referential transperentiality (sp?)
11:02:40 <path[l]> I have an example here -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3404#a3404
11:03:58 <path[l]> I have a function f which takes a long time. And a function g which operates on f and various indices passed to it. Now my question is in the example given, will the function f be evaluated multiple times?
11:04:28 <path[l]> if so, how should I in general make sure some computations are only performed once
11:05:28 <Berengal> I want a set monad :(
11:06:04 <hackagebot> hscolour 1.15 - Colourise Haskell code. (MalcolmWallace)
11:06:14 <jfoutz> path[l]: i think f will be computed every time you call g.
11:06:35 <path[l]> ah
11:06:49 <sjanssen> path[l]: generally, if you want data to be shared you must give it a name
11:06:50 <jmcarthur_work> @where memoization
11:06:50 <lambdabot> I know nothing about memoization.
11:06:58 <ManateeLazyCat> @package hscolour
11:06:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hscolour
11:07:00 <jmcarthur_work> eh, look up memoization on the wiki
11:07:06 <path[l]> ah thats what I was worried up
11:07:11 <path[l]> jmcarthur: is that to me?
11:07:14 <jmcarthur_work> yes
11:07:23 <path[l]> oh ok, thanks
11:07:29 <sjanssen> g list = let x = f list in \i -> x * i
11:07:32 <dolio> path[l]: You'd have to test to be sure. But GHC might be smart enough to make g into something like "g list = let x = f list in \i -> x * i" which explicitly has the sharing you want.
11:07:37 <ksf> @hoogle Ptr a -> Bool
11:07:37 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
11:07:37 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
11:07:37 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
11:07:41 <Berengal> path[l], you can do 'g list = let f_list = f list in \i -> f_list * i'
11:07:48 <ksf> @more
11:07:51 <ksf> grrr.
11:07:53 <Berengal> I'm slow :(
11:07:55 <ksf> isNullPtr?
11:08:07 <ManateeLazyCat> ksf:  c2hs ?
11:08:15 <ksf> ah, eq instance.
11:08:18 <sjanssen> path[l]: this transformation should ensure that 'f list' is only called once for each partial application of g
11:08:25 <lilac> path[l]: haskell makes no guarantees. but ghc generally won't increase or decrease sharing
11:08:49 <path[l]> hmm ok, so using a let which does not contain the uncurried variables works though?
11:09:16 <lilac> path[l]: can you paste the code? it'd be easier to explain with an example, i think
11:09:42 <path[l]> ok, give me a sec, Ill paste as much of the real code as I can (it's not complete =p)
11:10:06 <ksf> yeah, nothingIfNull is exactly what I want to do.
11:10:21 <dolio> This transformation is called "full laziness" by the way.
11:10:26 <dolio> And GHC should do some of that on its own.
11:10:28 <ManateeLazyCat> :t nothingIfNull
11:10:30 <lambdabot> Not in scope: `nothingIfNull'
11:10:41 <ManateeLazyCat> @hoogle nothingIfNull
11:10:42 <lambdabot> No results found
11:10:43 <ksf> no damnit it isn't monadic.
11:12:09 <dmwit> ?tell ManateeLazyCat You probably meant listToMaybe instead of nothingIfNull
11:12:09 <lambdabot> Consider it noted.
11:13:11 <jfoutz> path[l]: you can either remember computations you did before, or you can do less work. remembering the value of a computation is scoped to the variable you store it in. so... (\x -> (\y-> let cache = stuff in whatever ) {- forgot about cache here, because it's out of scope -} )
11:13:48 <byorgey> greetings from Edinburgh!
11:14:06 <dmwit> What!
11:14:11 <dmwit> I thought you were going to Edinborough.
11:14:13 <dmwit> ;-)
11:14:47 <byorgey> I thought so too!
11:14:53 <byorgey> there must have been a mixup.
11:14:59 <byorgey> but Edinburgh seems like a nice place.
11:15:05 <path[l]> hmm
11:15:17 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3405#a3405 <--- here is the best I can do atm
11:16:07 <dmwit> That type doesn't match that function.
11:16:15 <path[l]> so if I can do this g list = let x = f list in \i -> x * i, can I also do this g list = x*i where x = f list Will that also calculate f list once?
11:16:23 <path[l]> oops
11:16:24 <path[l]> sorry
11:16:27 <path[l]> drop an int =p
11:16:42 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3405#a3406
11:18:16 <dmwit> path[l]: Both of your proposed things will recalculate f list every time g is called.
11:18:31 <dmwit> path[l]: However, consider
11:18:34 <path[l]> oh I see
11:18:36 <dolio> http://www.haskell.org/haskellwiki/GHC:FAQ#When_can_I_rely_on_full_laziness.3F
11:18:49 <dmwit> g list = let x = f list in \i -> x * i
11:19:13 <dmwit> path[l]: Then, if you compute (g list), you can pass it several different values of "i", and "x" will not be recomputed.
11:19:29 <path[l]> oh I missed the \
11:19:42 <dmwit> oh
11:19:48 <path[l]> what does it mean?
11:19:49 <dmwit> Yes, and also I misread your question. =P
11:19:59 <path[l]> \i -> x*i
11:20:12 <dmwit> Sorry, your first solution would work okay. =P
11:20:30 <dmwit> (as it's identical to the one I suggested, hehe)
11:20:35 <path[l]> ah
11:20:37 <path[l]> hehe
11:20:45 <dmwit> \ is "lambda" from the lambda calculus.
11:20:51 <dmwit> It introduces an anonymous function.
11:21:11 <path[l]> ah ok, so we're returning a lambda on the first run. Why does the lambda get cached
11:21:12 <dmwit> i.e. you could equally well write (\x -> x + y) or (let f x = x + y in f).
11:21:51 <dmwit> Errr, the lambda isn't cached, it's the "x" that's cached, and that is because we have an explicit "let"-binding caching it.
11:22:14 <path[l]> hmm
11:22:20 <path[l]> ok
11:23:13 <path[l]> why does let cache x, but not a where?
11:23:53 <dmwit> where also caches
11:24:01 <dmwit> It was the missing lambda that I was complaining about.
11:24:04 <dmwit> e.g.
11:24:17 <dmwit> f list i = x + i where x = f list
11:24:18 <dmwit> vs.
11:24:28 <dmwit> f list = (\i -> x + i) where x = f list
11:24:43 <dmwit> The former is inefficient, the latter is efficient.
11:25:20 <path[l]> so I understand that this is the answer, but I dont think I quite understand why it works once we have a lambda there
11:25:22 <ChthonLaptop> Woot!  Coms blackout is over!
11:25:36 <dmwit> (Actually, GHC can probably catch the former for you during -O2, but it's better not to rely on that, if only for the purpose of self-documenting code.)
11:25:52 <dmwit> path[l]: Well, write it this way instead:
11:26:05 <dmwit> f = \list -> \i -> (x + i where x = f list)
11:26:06 <dmwit> vs
11:26:22 <dmwit> f = \list -> ((\i -> x + i) where x = f list)
11:26:43 <dmwit> path[l]: In the former, no computation is available until both arguments are passed.
11:26:46 <path[l]> ah
11:26:54 <dmwit> path[l]: In the latter, as soon as list is passed, there is computation available.
11:26:55 <dolio> dmwit: That FAQ I posted on full laziness seems to suggest that it won't ever perform the transformation on something like that.
11:27:13 <dolio> Because it won't float a let in between two consecutive lambdas.
11:27:19 <dmwit> dolio: Perhaps I should read that FAQ. =)
11:27:21 <ChthonLaptop> Question:  My Weapon data type and My armor data type share a durability value.  However GHC complains that they share the same name.  Why? (This question is about understanding the issue, not fixing it.)
11:27:44 <opqdonut> ChthonLaptop: because the field names automatically generate accessor functions
11:27:44 <path[l]> so when we have a lambda that contains the uncurried variables, we have something to actually return with just the passed variables?
11:27:47 <path[l]> ok
11:27:52 <path[l]> I think I see :)
11:28:05 <opqdonut> you can't have both "durability :: Armor -> Int" and "durability :: Weapon -> Int"
11:28:07 <lilac> dmwit: the latter construction isn't legal is it?
11:28:17 <path[l]> is that the solution you'd recommend for this -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3405#a3406
11:28:20 <opqdonut> unless you make a "class Durable a where durability :: a -> Int" type class or something
11:28:23 <opqdonut> ChthonLaptop: get it?
11:28:24 <ChthonLaptop> opqdonut: What if I joined them into one data type with a |?  Could I then use the same name for both?
11:28:32 <ChthonLaptop> Yes actually
11:28:35 <lilac> dmwit: i mean, i didn't think you could put a 'where' in that position
11:28:38 <dmwit> > (\list -> ((\i -> x + i) where x = sum list)) [1,2,43] 9
11:28:39 <lambdabot>   <no location info>: parse error on input `where'
11:28:41 <opqdonut> ChthonLaptop: yeah, with |it would work
11:28:44 <dmwit> lilac: You are correct.
11:28:48 <opqdonut> ChthonLaptop: if not straight away then with some extension
11:29:08 <dolio> dmwit: I should say, if it gets inlined, it'd be fine. But since it's used more than once, that might not be guaranteed.
11:29:11 <dino-> One way to deal with this is to prefix the field names with something like weapDur and armDur
11:29:13 <lilac> > (\list -> let x = sum list in \i -> i + x) [1,2,43] 9
11:29:14 <lambdabot>   55
11:29:31 <dino-> Sometimes I end up reevaluating whether I really need to use record-style at all. And often the answer is: no
11:29:36 <dmwit> path[l], lilac: So, to fix the examples, we have to use let instead of where,  but the fundamental idea is the same.
11:29:36 <ChthonLaptop> Ahh, ok.  I was irritated that I couldn't use similar names for the equipment stats, I had differentiated them with m for melee, r for ranged, a for armor and s for shield, but it would have been simpler if I could just use the same names.
11:29:51 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3405#a3407 <--- like this?
11:30:02 <lilac> > let f list = i + x where x = sum list in f [1,2,43] 9
11:30:03 <lambdabot>   Couldn't match expected type `t1 -> t'
11:30:04 <ChthonLaptop> dino-: Like I said, I just needed to understand.  I had the issue fixed.
11:30:14 <dmwit> path[l]: Try compiling it. ;-)
11:30:21 <lilac> > let f list = \i -> i + x where x = sum list in f [1,2,43] 9 --oops
11:30:23 <lambdabot>   55
11:30:25 <path[l]> hmm
11:30:32 <dmwit> path[l]: (No, you haven't quite got the syntax right.)
11:30:51 <dmwit> path[l]: For an anonymous function, you have to specify the names of the parameters and the function body, separated by ->.
11:30:55 <ChthonLaptop> I was hoping to build equpment with similar functions, but if I build it all with one data type I bet I can make one function for all :)
11:30:59 <dmwit> (\x -> 3 + x), for example
11:31:09 <path[l]> oh
11:31:10 <path[l]> ok
11:31:11 <path[l]> I see
11:31:12 <ChthonLaptop> Even though they have different fields.  Right?
11:31:32 <monochrom> Any news on Haskell Weekly News? :)  <duck>
11:31:43 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3405#a3408 <--- like this (though the type may still be wrong)
11:32:03 <dmwit> ChthonLaptop: Yes, different constructors for the same data type may share field names, if they also share a type.
11:32:18 <dmwit> path[l]: Closer, but still no -> in there. =P
11:32:28 <lilac> path[l]: more like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3405#a3409
11:33:04 <path[l]> ah right
11:33:05 <path[l]> silly me
11:33:06 <path[l]> thanks
11:33:53 <path[l]> does the type signature change to return (Int -> Int) instead of Int -> Int
11:34:22 <dmwit> (Int -> Int) = Int -> Int
11:34:28 <ChthonLaptop> What I mean is if I do data Equipment = Equipment Weapons {durability :: Int, type :: WeaponType} | Armors {durability :: Int, pv :: Int}  I could use the same constructor functions to set durability for both weapons and armor.
11:34:37 <dmwit> Int -> (Int -> Int) = Int -> Int -> Int -- this equality holds, too
11:34:56 <dmwit> This was one of the insights that got me hooked on functional programming, actually.
11:35:23 <dmwit> ChthonLaptop: correct
11:35:41 <path[l]> oh ok
11:35:45 <path[l]> thanks
11:35:58 <ChthonLaptop> Would I be able to make a mass constructor though for all weapons and armor that sets both values for either after reviewing the values given?
11:36:03 <path[l]> thanks a lot guys
11:36:16 <dino-> I didn't know you could do that. What happens when you call type above on an (Armors 42 ...) piece of data?
11:36:48 <dmwit> dino-: When you call what?
11:36:51 <ichor> You get undefined.
11:36:58 <dino-> type :: WeaponType
11:36:59 <dmwit> oh type
11:37:04 <dmwit> Yeah, it's an error.
11:37:04 <dino-> huh
11:37:08 <ChthonLaptop> dino-: Actually it's an equipment type.  First value is either Weapon or Armor type which determines the kind of fields it uses.
11:37:28 <ChthonLaptop> WeaponType is defined elsewhere.  Hold on
11:37:56 <EvilTerran> ChthonLaptop, btw, "type" is a keyword
11:38:03 <ChthonLaptop> data WeaponType = WeaponType {damage :: [DamageType], bonus :: [DamageType], effects :: Effects, weapondurability :: Int, mtype :: WeaponSkillType}
11:38:28 <ChthonLaptop> EvilTerran: I know, but when I use it as the second part of a data type it doesn't parse it as type
11:38:43 <ChthonLaptop> And lowercase type is not a keyword
11:38:51 <EvilTerran> > type
11:38:52 <lambdabot>   <no location info>: parse error on input `type'
11:39:00 <Baughn> Lowercase type is a keyword
11:39:05 <Baughn> type as /part of another word/ isn't
11:39:17 <EvilTerran> all haskell keywords are lowercase, afaik
11:39:20 <ChthonLaptop> Hrm... It let me use it before I changed it to mtype....  It compiled and everything
11:39:21 <Baughn> Uppercase type.. is... hm, it /shouldn't/ be a keyword
11:39:39 <dmwit> ChthonLaptop: Doesn't compile here.
11:39:42 <Baughn> ChthonLaptop: Well, it's a keyword that only makes sense in a few contexts
11:39:50 <dmwit> data Foo = Foo { type :: Int } -- is an error
11:39:57 <ChthonLaptop> Very strange.  I'll try using lowercase type again with GHC 6.10.4
11:39:59 * Berengal wonders if he can finish a project faster in haskell working one hour a day than he can finish it at work working in a team of two in java
11:40:28 <dino-> @faq Can haskell do that thing Berengal just said?
11:40:28 <lambdabot> The answer is: Yes! Haskell can do that.
11:40:36 <Baughn> Probably not. Haskell is good, but that sounds a bit excessive. :P
11:40:42 <ChthonLaptop> Hrm... maybe it was a fluke, or more likely I was more interested in something else at the moment
11:40:58 <Baughn> There are no flukes. ^^;
11:41:24 <ichor> Well, I know it is true when compared to J2me. It really is that much faster to do it in haskell.
11:41:24 <ChthonLaptop> Like I said, more likley I was more interested in something else at the moment, like another bug.
11:42:56 <mun> hi
11:43:07 <Twey> Baughn: I don't see why not
11:43:17 <mun> if i have a function like http://haskell.pastebin.com/m4c4ffe9a is there a way to display the values of its argument 'alibItems'?
11:43:19 <Twey> Java code is mostly boilerplate
11:43:33 <mun> i want to see what value it takes
11:43:35 <Baughn> ChthonLaptop: Once soupcan shows up, I'll have recruited three DF'ers to haskell. Only two more, and I get the tie. :3
11:43:37 <Twey> 6x compression of code and thought isn't unreasonable
11:43:57 <ChthonLaptop> How do you comment something in haskell?
11:44:03 <Twey> Baughn: DF?
11:44:08 <trofi> > {- hello -} 1
11:44:09 <lambdabot>   1
11:44:12 <Twey> ChthonLaptop: -- for line comments, or {- foo -} for block comments
11:44:14 <trofi> > 2 -- world
11:44:15 <Baughn> Twey: I agree on that, but I think the difference would have to be more like 10-15x for Berengal's quest to succeed
11:44:16 <lambdabot>   2
11:44:22 <ChthonLaptop> Thanks
11:44:35 <Baughn> Twey: Dwarf Fortress. People seem to keep asking me what language I recommend there. ;)
11:44:42 <Twey> Oh right.
11:44:44 <Twey> How odd.
11:44:56 <Berengal> Baughn, 8x, assuming I work 8 hours a day ;)
11:45:06 <Twey> Baughn: that's assuming that the partner is actually an asset.  ;)
11:45:34 <Berengal> I need to write a webservice library though...
11:45:42 <Baughn> Twey: Well, yeah.
11:45:46 <dmwit> mun: Can you be a bit more specific about what you want?
11:46:02 <mun> dmwit, i just want to take a look at the value alibItems on line 3 takes
11:46:21 <Berengal> Twey, he's a newbie.. we both are. The good kind though. We learned eight TLAs in two months
11:46:25 <dmwit> mun: What's wrong with, e.g., liftIO (print alibItems)?
11:46:47 <Twey> Berengal: Heh, nice
11:47:03 <Berengal> Twey, well, not really... I hate TLAs
11:47:05 <Twey> mun: See Debug.Trace, in the more general case
11:47:11 <Berengal> (Well, I do now)
11:47:27 <ChthonLaptop> data Equipment = Equipment WeaponType  {  -- Generated a parse error on input '{' at this point.  Why?
11:47:50 <monochrom> There is only one TLA. http://research.microsoft.com/en-us/um/people/lamport/tla/tla.html
11:48:00 <Twey> ChthonLaptop: Because you can only have all record syntax or all non-record syntax, not both.
11:48:02 <Berengal> ChthonLaptop, it's either a record or it's not. You can't mix them
11:48:08 <mun> ok thanks
11:48:26 <ChthonLaptop> Ok, how would I fix that?  Put the WeaponType inside the brackets?
11:48:34 <Baughn> Yes
11:48:52 <Baughn> data Equipment = Equipment { wtype :: WeaponType, ... }
11:49:12 <ChthonLaptop> Ok, and when I create an equipment I can let a = Equipment WeaponType ?
11:50:01 <ChthonLaptop> Because remember I have different records for WeaponType, RWeaponType, ArmorType, ShieldType, and AccesorryType
11:50:46 <Baughn> ChthonLaptop: Um.. yes? I'm not sure. Depends on exactly how WeaponType is defined.
11:51:12 <Baughn> Of course, that code wouldn't work per se. It'd be "a = Equipment somethingThatIsAWeapoNType"
11:51:29 <ichor> ChthonLaptop, Equipment is not a data constructor according to your definition.
11:51:33 <ChthonLaptop> Actually I would define it as data EqupType = Weapon | RWeapon | Armor | Shield | Accessory
11:51:54 <Baughn> Okay..
11:52:41 <ChthonLaptop> Ok, lets start over, I'm trying to have one record type data constructor with different fields based on if the piece of equipment is a weapon, armor etc.
11:53:08 <Baughn> ChthonLaptop: By the way, do you have any tutorials up in your browser?
11:53:08 <Baughn> I pointed you at learn you a haskell for great good some time ago
11:53:33 <mreh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3410#a3410
11:53:35 <ChthonLaptop> yes, I have that up now, it doesn't go into detail on that actually, it just shows the general one
11:53:39 <mreh> this is causing an infinite loop
11:53:44 <ChthonLaptop> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
11:53:47 <mreh> or something else that never returns from exectuion
11:53:52 <Baughn> So, "data Thing = Weapon [weaponfields] | Armor [armorfields] | etc."
11:54:01 <Baughn> Well, actually..
11:54:05 <monochrom> data Multitude = Firstly { i :: Int } | Secondly { i :: Int, j :: Bool } | Thirdly { j :: Bool } | Finally { n :: String }
11:54:33 <Baughn> ..like that, yes.
11:54:50 <ChthonLaptop> Ahh, ok, thanks :)
11:54:57 <Baughn> ChthonLaptop: Although, I suppose there are some fields that all the types have in common
11:55:00 <Baughn> Like weight, etc.
11:55:26 <jfoutz> monochrom: the i accessor names won't collide?
11:55:27 <Berengal> Do records behave properly when you have several fields (in different constructors) with the same name?
11:55:29 <ChthonLaptop> Yes, there are some that are common, I put the most common ones first, etc.
11:55:33 <Baughn> Berengal: ..no.
11:55:56 <monochrom> i won't collide. that's the feature showcased.
11:55:59 <Berengal> Baughn, not even with some magic extention?
11:56:12 <ichor> ChthonLaptop, And you could define EqupType as you did, and then make a function eqType :: Equipment -> EqupType
11:56:32 <monochrom> To a large extent, the two i's are the same i.
11:56:35 <Baughn> Berengal: Oh, like that
11:56:37 <jfoutz> monochrom: just typed it in. that's neat!
11:56:44 <ChthonLaptop> Well, I like monochrom's method better, looks easier to read
11:57:02 <Baughn> Berengal: I haven't tried.
11:57:04 <monochrom> My example is Haskell98.
11:57:20 * Berengal tries
11:57:25 <ChthonLaptop> But that's Ichor for that.  My problem was It hought I'd have to use equipment as the record type for equipment.  Instead I use weapon armor, etc for the record type for equipment.
11:57:26 <monochrom> The Fathers of Haskell foresaw your question!
11:57:37 <jfoutz> oh, but they need to be the same type. that is somewhat less magic than i thought.
11:57:45 <monochrom> heheheh
11:57:46 <jfoutz> still, cool syntax.
11:57:49 <ChthonLaptop> This exact example was not provided for in the learn you a haskell, but sure as hell I needed it so thanks :)
11:58:35 <dino-> I guess I kind of felt like my OO lizard brain wanted to latch onto record style initially. Like, oo shiny, class methods! But it's not always so great to try to use them everywhere.
11:58:47 <ChthonLaptop> And it compiled!
11:59:04 <mreh> and so it is written
11:59:12 <Berengal> Baughn, it works, even without any magic
11:59:27 <Baughn> Berengal: Arguably, Haskell98 is magic in itself.
11:59:30 <ChthonLaptop> I just find records useful to use when working with a large amount of information that describes an npc or character.
12:00:29 <Berengal> Baughn, only for technologically challenged imperative programmers. Hail functionalia!
12:02:08 <Baughn> All hail Curry!
12:02:33 <monochrom> When I read the record sections in the Haskell98 report, it was an eye opener and mouth opener.
12:03:31 <Berengal> Praise be to Backus!
12:03:53 <monochrom> I wonder if lambdabot takes data declarations.
12:04:06 <Berengal> > data Foo = Foo Int -- wonder no more
12:04:07 <lambdabot>   <no location info>: parse error on input `data'
12:05:03 <monochrom> @let data Multitude = Firstly { i :: Int } | Secondly { i :: Int, j :: Bool } | Thirdly { j :: Bool } | Finally { n :: String }
12:05:04 <lambdabot>  Invalid declaration
12:05:33 <ChthonLaptop> Very nice.  I'm able to slim down my code a lot with this :))
12:06:24 <ChthonLaptop> Ok, how would I check what kind of equipment I have.  Ex if it used the weapon constructor or the armor constructor?
12:07:04 <ichor>  isWeapon (Weapon _ _ ) = true; isWeapon _ = False
12:07:05 <SamB> ChthonLaptop: well, you could use Derive's "Is" derivation ...
12:07:14 <SamB> or you could do it by hand as ichor suggests ;-)
12:07:38 <monochrom> isWeapon Weapon{} = True; isWeapon _ = False
12:08:02 <monochrom> But it ought to be seldom used.
12:09:04 <Berengal> I might've used a class instead...
12:09:14 <SamB> Berengal: you think that's wise?
12:09:22 <Berengal> class Equipment a where weight :: a -> Weight {...}
12:09:23 <SamB> Haskell is not Smalltalk ...
12:09:31 <Berengal> SamB: I'm not sure...
12:09:45 <Berengal> But that way you don't have to dispatch on constructors
12:09:45 <SamB> ... or Python, or CL, or ...
12:09:54 <ChthonLaptop> isWeapon sword{} == True returned <interactive>:1:14: Empty record update
12:10:10 <SamB> ... Self, JavaScript, Ruby, Perl ...
12:10:40 <ichor> Berengal, you would have problems putting different equipments in a list without a lot of existential quantifier stuff.
12:10:45 <SamB> ChthonLaptop: that looks like a parse-ish error
12:11:01 <ChthonLaptop> Not sure what it means though
12:11:11 <SamB> ChthonLaptop: take out the {}
12:11:20 <Berengal> ichor, yes, but not with existential quantifier stuff, and with typeable you can get them out easily as well
12:11:22 <ChthonLaptop> if I put isWeapon sword == True it gives me not in scope 'isWeapon'
12:11:27 <monochrom> "Weapon{}" is pattern-matching in function definition. Not at call site.
12:11:37 <Berengal> ichor, and I'm not sure it's worse than pattern-matching on constructors
12:12:09 <SamB> Berengal: what you propose always ends up a mess
12:12:29 <SamB> it almost only ever works even slightly nicely with C library bindings ...
12:12:36 <Berengal> SamB, it does, but everything ends up this way...
12:12:39 <SamB> ... and they always cheat!
12:13:17 <Berengal> Partial patterns are smelly though. Classes give you a certain totality
12:14:09 <ichor> Berengal, one could make a separate EquipmentType data, and a function Equipment -> EqupmentType, that would be total.
12:14:17 <Berengal> Although returning Maybe is acceptable...
12:14:33 <jmcarthur_work> Map
12:14:42 <ChthonLaptop> Any other clues as to why isWeapon isn't working?
12:15:11 <Berengal> ChthonLaptop, isWeapon Weapon{} = True; isWeapon _ = False
12:15:50 <ChthonLaptop> Berengal: Those get a response of Empty record update.
12:16:03 <ChthonLaptop> If I remove the {} it says isWeapon is not in scope.
12:16:19 <Berengal> ChthonLaptop, you've got an equals too many
12:16:52 <ChthonLaptop> STill gives me an empty record update
12:17:22 <Berengal> Show me the code
12:17:23 <Berengal> @paste
12:17:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:17:38 <ChthonLaptop> Which code?
12:17:47 <ChthonLaptop> For the record?
12:17:54 <Berengal> For whatever doesn't work
12:18:57 <monochrom> ChthonLaptop: "isWeapon Weapon{} = True; isWeapon _ = False" is function definition, to be entered into a file and loaded.
12:20:02 <monochrom> If you enter it straight at the prompt, computer thinks you're calling the function, not implementing the function.
12:20:26 <ChthonLaptop> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8527#a8527
12:20:49 <Berengal> ChthonLaptop, sword isn't a constructor
12:20:53 <Berengal> You need to use Weapon
12:21:08 <ChthonLaptop> How do I tell if sword is a weapon though
12:21:15 <ChthonLaptop> err Weapon
12:21:28 <dmwit> isWeapon (Weapon {}) = True; isWeapon _ = False -- this should work just fine
12:21:37 <dmwit> Then you can call (isWeapon sword) to get back True.
12:21:43 <Berengal> ChthonLaptop, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8527#a8528
12:22:48 <ChthonLaptop> So I need to create isWeapon in my file before I can use it then.  I thought it might have been created automatically like so many other functions when you make a constructor.
12:23:06 <Berengal> Haskell is magic, but it's also lazy
12:23:19 <monochrom> isXXX is not all that useful.
12:24:03 <ichor> ChthonLaptop, also when you let sword = Weapon, you make sword into a function (look at it's type).
12:24:06 <monochrom> would be useful in an imperative language
12:24:26 <sm> would anyone know why cabal sdist is failing this file operation ? http://gist.github.com/174086
12:24:33 <etpace_> I'm going through the `Monad Readers' typeclopedia and have understood everything so far until monad transformations where theres not much said, does anyone have reccomendations on the topic
12:24:38 <monochrom> Yeah, let sword = Weapon{durability :: 5, ... you fill it in ... }
12:24:59 <dmwit> etpace_: Perhaps "all about monads"?
12:25:05 <dmwit> ?where all about monads
12:25:05 <lambdabot> I know nothing about all.
12:25:09 <dmwit> ?go all about monads
12:25:11 <lambdabot> http://www.haskell.org/all_about_monads/
12:25:11 <lambdabot> Title: All About Monads
12:25:18 <ChthonLaptop> I took the liberty of creating one for each of the other types.
12:25:21 <etpace_> cheers
12:25:53 <dmwit> You don't have to take any liberties when it's your own code. ;-)
12:26:01 <ChthonLaptop> And I understand how it works after seeing it in paste bin.  It's obvious once you see it like how to make functions to get values in tuples.
12:26:14 <Berengal> I sometimes take liberties with others code even...
12:26:22 * sm does it on the mac
12:26:24 <ChthonLaptop> They're my liberties, and I'll take them if I want.
12:26:46 <Berengal> ChthonLaptop, I took them already when I added that function. You can't have them back
12:26:59 <dino-> etpace_: I also really liked this for learning about transformers: http://user.cs.tu-berlin.de/~magr/pub/Transformers.en.html
12:27:38 <etpace_> looks good
12:28:19 <ChthonLaptop> Ichor: Actually I had been wondering about that.  I have been playing with the :t command on all my new data types actually
12:28:26 <hackagebot> rss2irc 0.3 - Watch an RSS/Atom feed and write it to an IRC channel (SimonMichael)
12:28:42 <laynor_> hi, how do I catch errors resulting from failed pattern matching?
12:28:51 <ChthonLaptop> isWeapon sword does not return true, it dumps a couldn't match expected type 'Equipment'
12:29:15 <monochrom> sword = Weapon{durability :: 5, ... you fill it in ... }
12:29:18 <dmwit> Did you read the comments above re: sword being a function?
12:30:31 <ChthonLaptop> dmwit: Which comments do you mean?
12:31:56 <dmwit> 15:24 < ichor> ChthonLaptop, also when you let sword = Weapon, you make sword into a function  (look at it's type).
12:32:03 <dmwit> 15:24 < monochrom> Yeah, let sword = Weapon{durability :: 5, ... you fill it in ... }
12:32:39 <ChthonLaptop> Ahh, ok, so I actually have to fill in the blanks first before I can check to see if it is a weapon.
12:32:50 <ChthonLaptop> Kinda wierd but ok.
12:33:09 <Berengal> It's definitely not a weapon before you've filled them in
12:33:12 <ChthonLaptop> No offense, but when one finishes the other's explanation I often take them as separate comments.
12:33:23 <monochrom> Would not need to fill it in if you were using a theorem prover.
12:33:23 <Berengal> You only need a typechecker to tell you that
12:34:03 <ksf> does newAlignedPinnedByteArray# , that is, alloca, alloc on the heap or stack?
12:34:21 <ChthonLaptop> And I didn't need to actually put values in, just {} was fine even with the warning (good enough for a test)
12:34:23 <ksf> ...the actual question is whether or not it's faster as malloc.
12:47:35 <mercury^> How does one prove that fmap g . pure = pure . g?
12:48:24 <EvilTerran> i think you can do that with parametricity
12:48:32 <mercury^> What does that mean?
12:48:36 <monoidal> isn't that a free theorem?
12:48:58 <mercury^> I suppose that you need to use that the category is Hask, as I think I found counterexamples for other categories.
12:49:19 <EvilTerran> ?type fmap g . pure
12:49:20 <lambdabot> forall a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, Applicative f) => a -> f b
12:49:24 <EvilTerran> ?type pure . g
12:49:25 <lambdabot> forall b (f :: * -> *) a. (Applicative f, Show a, SimpleReflect.FromExpr b) => a -> f b
12:49:42 <EvilTerran> ... grr, simple-reflect
12:49:45 <path[l]> is there a simpler formulation for take n (drop m list) ?
12:49:56 <monoidal> mercury^, typeclassopedia p 24
12:50:06 <EvilTerran> ?type \g -> fmap g . pure
12:50:06 <mercury^> monoidal: that's no proof.
12:50:07 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> a -> f b
12:50:12 <EvilTerran> ?type \g -> pure . g
12:50:13 <lambdabot> forall b (f :: * -> *) a. (Applicative f) => (a -> b) -> a -> f b
12:52:02 <mercury^> EvilTerran: How does that prove it?
12:52:21 <dschoepe> mercury^: isn't that a law that is required to hold for every Applicative instance? So I don't think you can prove it "in general", since it depends on the fmap and pure implementations. Or did I misunderstand the question?
12:52:36 <EvilTerran> mercury^, it doesn't, on its own... i'm looking up Theorems For Free now to remind myself how proof-by-parametricity works
12:53:08 <mercury^> dschoepe: any instance of pointed satisfies that law.
12:53:21 <mercury^> And not because it is defined that way.
12:53:30 <jfoutz> path[l]: not that i can see, you could make sublist from to = take (from - to) . (drop from)
12:53:30 <ChthonLaptop> Ok, now I have a type conflict for some reason.  :t mSKb gives me mSKb :: (Num a) => a -> a -> a -> a, while :t getDRP gives me getDRP :: (Fractional a, Ord a) => a -> a.  I tried to put mSKb as the parameter for getDRP and it says no instances for fractional int for getDRP when I pull inputs from my Character bob.
12:53:39 <jfoutz> path[l]: or something like that.
12:53:41 <ksf> @quickcheck (fmap toUpper . pure) == (pure . toUpper)
12:53:42 <lambdabot> Unknown command, try @list
12:53:47 <ksf> @qc (fmap toUpper . pure) == (pure . toUpper)
12:53:48 <lambdabot> Not enough privileges
12:53:53 <ksf> bad girl.
12:54:08 <jmcarthur_work> use @check
12:54:14 <path[l]> oh ok, just wanted to make sure i wasnt missing an obvious trick
12:54:15 <ksf> @check (fmap toUpper . pure) == (pure . toUpper)
12:54:16 <lambdabot>   No instance for (GHC.Classes.Eq
12:54:16 <lambdabot>                     (GHC.Types.Char -> f GH...
12:54:25 <ksf> see? doesn't hold.
12:54:29 <ksf> don't bother proving it.
12:54:47 <dschoepe> mercury^: ah, okay. I think I don't know enough CT to help in these discussions.
12:54:48 <tommd1> @check \c -> (fmap toUpper . pure) c == (pure . toUpper) c
12:54:49 <lambdabot>   No instance for (GHC.Classes.Eq (f GHC.Types.Char))
12:54:49 <lambdabot>    arising from a use o...
12:54:55 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8530#a8530 is that the current definition for >>= on trees?
12:55:17 <hikingpete> I'm trying to write a function which uses getDirectoryContents to build a directory tree, but am struggling with how to make my function properly interact with the IO Monad. I think my approach is flawed, how does an experienced haskeller attack this problem?
12:55:21 <jmcarthur_work> @check \x -> (fmap toUpper . pure) x == ((pure :: Char -> String) . toUpper) x
12:55:23 <lambdabot>   "OK, passed 500 tests."
12:55:30 <tommd1> Thats better
12:55:47 <tommd1> what is pure, btw?
12:55:48 <tommd1> @type pure
12:55:50 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
12:56:02 <etpace_> @src Tree (>>=)
12:56:02 <lambdabot> Source not found. :(
12:56:03 <roconnor> pure is return
12:56:04 <mercury^> tommd1: return in a more general setting
12:56:14 <jmcarthur_work> point in a less general setting
12:56:37 <roconnor> right, pure is return and pure is point, and point is return too
12:57:02 <etpace_> @src (>>=) Tree
12:57:03 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:57:33 <mercury^> EvilTerran: so, how does it work?
12:57:44 <monochrom> hikingpete: I would just do the usual imperative algorithm. IO doesn't do strange things.
12:58:45 <smarmy> if pure is a natural transformation, wouldn't fmap g . pure = pure . g follow from naturality?
12:58:46 <ChthonLaptop> Why does mSKb (str bob) (fst (head (skill bob))) 20 work, getDRP (mSKb 4 40 20) work, but not getDRP (mSKb (str bob) (fst (head (skill bob))) 20)?
12:59:08 <ChthonLaptop> mSKb (str bob) (fst (head (skill bob))) 20 == mSKb 4 40 20
12:59:33 <mercury^> smarmy: it is the same as pure being a natural transformation from id to fmap.
12:59:37 <ksf> 'cos you're using way too cryptic fun names and access patterns.
12:59:40 <ksf> ghc detects that.
12:59:43 <mercury^> So in other words, we are trying to prove that.
13:00:43 <ksf> and, 'cos your'e calling getDRP with different numbers of arguments.
13:00:50 <smarmy> hmmm
13:00:54 <ChthonLaptop> ksf no seriously, mSKb (str bob) (fst (head (skill bob))) 20 has type int for some reason, while mSKb 4 40 20 has type :: (Num t) => t still
13:00:57 <ksf> ...no, my paren parser fails.
13:01:19 <monochrom> We need a Haskell-themed RPG D&D game. At some point it should say "you have found Oleg's lost scrolls!"
13:01:34 <monochrom> err perhaps Oleg's lost usb memory stick.
13:01:47 <ChthonLaptop> scrolls sounds cooler
13:01:50 <mauke> tapes
13:01:59 <ChthonLaptop> Punch cards
13:02:02 <ksf> dissertation printouts
13:02:08 <mercury^> EvilTerran: well, umm, highlight me or sth once you have remembered the proof.
13:02:34 <ksf> you can then climb the dungeon back to top, defeating all monsters automagically with the solution to the halting problem.
13:03:32 <dschoepe> ksf: but you'd need intelligence and wisdom > 1000 to use them.
13:04:00 <ksf> all magic spells should end with "Q.E.D."
13:04:26 <monochrom> ChthonLaptop: What is the type of getDRP?
13:04:55 <Ferdirand> ksf: will we be able to shoot arrows ?
13:05:17 <ChthonLaptop> monochrom: getDRP :: (Fractional a, Ord a) => a -> a
13:05:31 <monochrom> So Int won't cut it.
13:05:42 <smarmy> mercury^: pure . g =[def .] \x -> pure (g x) =[app func homomorphism law] \x -> pure g <*> pure x =[def <*>] \x -> fmap g (pure x) =[eta] fmap g . pure
13:05:52 <etpace_> How do I use First and Last with Maybe? doesnt really give examples
13:06:20 <etpace_> typeclopedia*
13:06:57 <etpace_> > mempty Nothing :: First
13:06:58 <lambdabot>   `Data.Monoid.First' is not applied to enough type arguments
13:06:58 <lambdabot>  Expected kind ...
13:07:04 <ksf> Ferdirand, they're the only way to kill warm, fuzzy things.
13:07:31 <etpace_> > First Just 5 `mappend` Just 8
13:07:33 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
13:07:39 <etpace_> bah
13:07:45 <dschoepe> > mempty :: First
13:07:46 <lambdabot>   `Data.Monoid.First' is not applied to enough type arguments
13:07:46 <lambdabot>  Expected kind ...
13:07:51 <dschoepe> > mempty :: First Int
13:07:53 <lambdabot>   First {getFirst = Nothing}
13:08:10 <dschoepe> > First (Just 4) `mappend` First (Just 5) -- etpace_
13:08:12 <lambdabot>   First {getFirst = Just 4}
13:08:40 <etpace_> hmm, i dont quite follo whow that works
13:08:59 <dschoepe> etpace_: mappending two firsts keeps the first value that isn't nothing.
13:09:04 <ChthonLaptop> For some reason my mSKb function is getting type set as an Int when I filter through my Character values.
13:09:04 <ChthonLaptop> Int does not belong to Fractional so it fails
13:09:04 <ChthonLaptop> However if it had remained (Num a) -> a then it would work fine.
13:09:08 <ChthonLaptop> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8531#a8531 <-- Here are the 3 functions in question.  Is it because the inputs are Int that it forces all outputs to become Int?
13:09:33 <ChthonLaptop> Wow, lag spike
13:09:35 <etpace_> Is ther any use for it dschoepe?
13:10:56 <mercury^> smarmy: it should hold for pointed, not applicative.
13:11:16 <smarmy> good point
13:11:59 <ichor> etpace_, I guess you would use it with Writer to get only the first telling.
13:13:02 <dschoepe> etpace_: yes, for example you might have a bunch of Maybes and want to take the first that isn't Nothing.
13:13:35 <dschoepe> etpace_: besides, you can write your code to work with arbitrary monoids.
13:15:23 <etpace_> > Any True `mappend` Any False
13:15:24 <lambdabot>   Any {getAny = True}
13:18:10 <smarmy> mercury^: i suppose then you just need to prove naturality, which seems obvious.  pure is universally quantified in a.  once naturality holds, homomorphism holds and thus the law holds
13:21:16 <path[l]> could someone help me understand this type error? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3411#a3412
13:22:53 <jmcarthur_work> :t and
13:22:55 <lambdabot> [Bool] -> Bool
13:23:01 <etpace_> > Endo (+1) `mappend` Endo (*2)
13:23:02 <lambdabot>   No instance for (GHC.Show.Show (Data.Monoid.Endo a))
13:23:02 <lambdabot>    arising from a use ...
13:23:15 <Lemmih> path[l]: You want '&&'.
13:23:19 <etpace_> > Endo (+1) `mappend` Endo (*2) $ 3
13:23:21 <lambdabot>   Couldn't match expected type `a -> b'
13:23:26 <path[l]> huh oh, I thought it was and
13:23:28 <path[l]> thanks
13:23:40 <etpace_> > Endo (+1) `mappend` Endo (*2) $ 3
13:23:41 <lambdabot>   Couldn't match expected type `a -> b'
13:23:43 <ray> > appEndo (Endo (+1) `mappend` Endo (*2)) 3
13:23:44 <lambdabot>   7
13:23:48 <etpace_> hmm
13:23:52 <ray> you need to get it out of the Endo wrapper
13:23:59 <dschoepe> > (Endo (+1) `mappend` Endo (*2)) `appEndo` 3
13:24:00 <lambdabot>   7
13:24:15 <ray> it's newtype Endo a = Endo { appEndo :: a -> a }, so you can get it out with appEndo
13:24:19 <c_wraith> path[l]: why did you write keep as "keep arg1 = \arg2 arg3 arg4 -> blah"?
13:24:39 <etpace_> I guess i'm going to find out why this is useful right? it seems a bit useless
13:24:54 <etpace_> as in, why not just use .?
13:25:06 <path[l]> c_wraith: I want to evaluate the heuristic thing only once. So I can pass arg2, arg3, arg4 multiple times
13:25:24 <c_wraith> path[l]: haskell does that automatically
13:25:35 <ray> path[l]: keep arg1 arg2 arg3 arg4 = blah is exactly equivalent
13:25:38 <jmcarthur_work> > foldMap Endo [(+1), (*2), (/2)] `appEndo` 5
13:25:39 <lambdabot>   Not in scope: `foldMap'
13:25:45 <jmcarthur_work> @hoogle foldMap
13:25:45 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
13:25:45 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
13:25:56 <jmcarthur_work> > Data.Foldable.foldMap Endo [(+1), (*2), (/2)] `appEndo` 5
13:25:58 <lambdabot>   6.0
13:26:07 <ray> etpace_: it makes functions a Monoid, albeit in a limited way
13:26:27 <path[l]> well there was a discussion here earlier that while haskell automatically curries, it does not prevent the where values from being calculated multiple times. And returning a lambda tells it to make that optimisation
13:26:38 <dschoepe> etpace_: once you make some structure instance of Monoid, you get some operations for free and your code is more general.
13:26:39 <jmcarthur_work> Endo would be interesting with Writer
13:26:59 <ray> yes, you could build up a function
13:27:02 <ray> drool
13:27:11 <dschoepe> > mconcat [(+1),(*2)] `appEndo` 5
13:27:12 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo a'
13:27:20 <dschoepe> > mconcat [Endo (+1),Endo (*2)] `appEndo` 5
13:27:21 <lambdabot>   11
13:27:50 <dschoepe> etpace_: without Endo you'd have to write that manually using a fold
13:28:53 <dschoepe> etpace_: and, as mentioned, you can use it with other functions that are generalized for arbitrary monoids, like the Writer monad
13:28:54 <jmcarthur_work> Endo would be epic cool as the measure of a finger tree
13:29:00 <jmcarthur_work> a modifiable function
13:29:25 <etpace_> > (First Nothing, [1]) `mappend` (First 5, [3])
13:29:27 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
13:29:27 <lambdabot>    arising from the lite...
13:29:56 <etpace_> > (First Nothing, [1]) `mappend` (First Just 5, [3])
13:29:57 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
13:30:33 <dschoepe> etpace_: ..First (Just 5),..
13:30:36 <jmcarthur_work> Monoid is one of my favorite type classes
13:30:37 <etpace_> I didn't really understand the paragraph detailing how if a and b are monoids, so are (a,b) and (e -> a)
13:31:03 <etpace_> > (First Nothing, [1]) `mappend` (First (Just 5), [3])
13:31:05 <lambdabot>   (First {getFirst = Just 5},[1,3])
13:31:17 <jmcarthur_work> etpace_, (a, b) `mappend` (c, d) = (a `mappend` c, b `mappend` d)
13:31:44 <ray> mempty = (mempty, mempty)
13:31:50 <c_wraith> @quote monad endofunctor monoid
13:31:51 <lambdabot> No quotes for this person. Take a stress pill and think things over.
13:32:00 <c_wraith> blah.  who was that by?
13:32:04 <dschoepe> @quote wadler monad
13:32:05 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
13:32:06 <dschoepe> that?
13:32:08 <dino-> data Foolean = True | False | Silly
13:32:10 <c_wraith> yes, thanks :)
13:32:20 <jmcarthur_work> etpace_, f `mappend` g = \x -> f x `mappend` g x
13:32:21 <ray> @quote endofunctor
13:32:22 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
13:32:42 <jmcarthur_work> pure = const
13:32:48 <jmcarthur_work> pure wtf
13:32:54 <jmcarthur_work> mempty = const
13:32:58 <ray> lol
13:33:03 <jmcarthur_work> same thing, really
13:33:20 <ray> it happens to be
13:33:30 <etpace_> is mappend like f >> g for functions then?
13:33:31 <jmcarthur_work> it's no coincidence
13:33:46 <dschoepe> I found this article really enlightening about the relation of monads and monoids: http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html
13:34:03 <jmcarthur_work> etpace_, in what way?
13:34:25 <ray> @quote thermoplyae
13:34:25 <lambdabot> No quotes match.
13:34:28 <ray> :(
13:34:51 <mauke> @quote mopy
13:34:52 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
13:34:55 <etpace_> isn't that what >> does? I thought f >> g = f
13:35:22 <dschoepe> etpace_: but Endo f `mappend` Endo g = Endo (f . g)
13:35:30 <etpace_> isn't that what >> does? I thought f >> g = f >>= (\_ -> g)
13:35:45 <endojelly> etpace_, I thought that, too
13:35:49 <jmcarthur_work> and f `mappend` g = \x -> f x `mappend` g x
13:36:32 <sshc> if I list has more elements in it than the upper bound of int (calling length list would return negative), would genericLength return the proper result?
13:37:04 <sshc> or does genericLength just return a generic integral after getting the bounded Int length?
13:37:06 <jmcarthur_work> sshc, if the result type can handle it
13:37:09 <etpace_> hmm, so while they both share the argument, mapped mappend's the result while >> throwd away the lhs result?
13:37:18 <jmcarthur_work> sshc, no, it does it generically
13:38:04 <jmcarthur_work> > (+5) >> (-4) $ 4
13:38:05 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
13:38:05 <lambdabot>    arising from a use of syntactic n...
13:38:15 <etpace_> > (+1) >> (+2) $ 5
13:38:17 <lambdabot>   7
13:38:36 <sshc> jmcarthur_work: so if I had a giant list of bools where "length bools" returns negative, genericLength would return the correct (positive) length?
13:38:51 <jmcarthur_work> sshc, as long as the result type can handle it
13:38:53 <etpace_> > (+1) `mappend` (+2)
13:38:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:38:54 <lambdabot>    arising from a use of `...
13:39:17 <etpace_> > (+1) `mappend` (+2) $ 5
13:39:19 <lambdabot>   Add a type signature
13:39:26 <etpace_> > (+1) `mappend` (+2) $ 5 :: Int
13:39:28 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
13:39:28 <lambdabot>    arising from a use of...
13:39:32 <jmcarthur_work> sshc, if the result is an Int, it will fail of course, but if it's an Integer it should be okay
13:39:42 <etpace_> I thought ints were a monoid?
13:39:42 <jmcarthur_work> sshc, there is one complication though...
13:39:51 <monoidal> > Endo (+1) `mappend` (+2) $ 5 :: Int
13:39:53 <lambdabot>   The section `GHC.Num.+ 2' takes one argument,
13:39:53 <lambdabot>  but its type `Data.Monoid.En...
13:39:58 <monoidal> > Endo (+1) `mappend` Endo (+2) $ 5 :: Int
13:39:59 <lambdabot>   Couldn't match expected type `a -> b'
13:40:08 <dschoepe> etpace_: ints are two monoids, one under multiplication and one under addition
13:40:11 <jmcarthur_work> sshc, if you have a list whoe length is greater than the maxBound of Int, you are using up all your addressable memory ;)
13:40:14 <etpace_> aha
13:40:19 <dschoepe> Product and Sum respectively.
13:40:20 <jmcarthur_work> *whose
13:40:32 <monoidal> yuk forgot about + sections
13:40:36 <jmcarthur_work> sshc, (with GHC, anyway)
13:40:44 <sshc> jmcarthur_work, ok, thanks :)[3~[3~[3~[3~
13:40:59 <jmcarthur_work> actually, maybe not
13:41:09 <jmcarthur_work> the entire list might not be in memory at once
13:41:15 <jmcarthur_work> so i guess that scenario is perfectly feasible
13:41:16 <c_wraith> indeed. :)
13:41:18 <sshc> jmcarthur_work: true, and
13:41:23 <etpace_> but theres two mappends for functions as well, endo and just the functions?
13:41:25 <sshc> jmcarthur_work: Int is signed
13:41:29 <etpace_> two monoids*
13:41:37 <jmcarthur_work> ah, right, that was silly on my part
13:41:52 <etpace_> > (+1) `mappend` (+2) $ 5 :: Sum
13:41:54 <lambdabot>   `Data.Monoid.Sum' is not applied to enough type arguments
13:41:54 <lambdabot>  Expected kind `?...
13:41:56 <jmcarthur_work> but lists have a fair bit of memory overhead
13:42:04 <jmcarthur_work> so signed or unsigned shouldn't matter maybe
13:42:14 <monoidal> > Sum 1 `mappend` Sum 2
13:42:15 <lambdabot>   Sum {getSum = 3}
13:42:27 <etpace_> > (Sum
13:42:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:42:56 <etpace_> > (Sum . (+1)) `mappend` (Sum . (+2)) $ 5
13:42:58 <lambdabot>   Sum {getSum = 13}
13:42:58 <jmcarthur_work> etpace_, the two function instances are different though
13:43:28 <jmcarthur_work> etpace_, one is Monoid (a -> a), the other is Monoid b => Monoid (a -> b)
13:43:51 <etpace_> hmm
13:44:07 <jmcarthur_work> the former being wrapped by Endo, of course
13:44:16 <monoidal> first is function composition, second is pointwise
13:45:58 <etpace_> ok, thanks
13:46:07 <monoidal> > (appEndo $ (Endo (+1)) `mappend` (Endo (+2))) $ 5
13:46:09 <lambdabot>   8
13:46:46 <wolverian> if I have .lhs modules, can the resulting .tex file be unpacked into separate files with ghc or something else?
13:49:37 <etpace_> > mconcat (zipWith compare "hello" "there")
13:49:39 <lambdabot>   LT
13:50:08 <wolverian> cute
13:51:12 <ksf> an .lhs file should be a valid tex file, anyway.
13:51:20 <ksf> that's the point of literate programming
13:51:27 <etpace_> theres supposedly some cool things that can be done with Ordering and the function instance of monoid
13:51:37 <jmcarthur_work> ksf, maybe wolverian is using lhs2tex?
13:53:24 * ksf doesn't quite see the point of lhs2tex, except coding stuff in haskell, not tex.
13:54:35 <ksf> ...well, as coding in tex is a bugger (so I've heard), that's most likely the point.
13:54:57 <ksf> even if tex is scriptable in lua nowadays.
13:57:04 <jmcarthur_work> tex isn't so hard
13:57:04 <path[l]> is fmap the same as flip map?
13:57:07 <path[l]> :t mp
13:57:08 <lambdabot> Not in scope: `mp'
13:57:11 <jmcarthur_work> well, tex maybe, but not latex
13:57:13 <path[l]> :t map
13:57:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:57:20 <path[l]> > flip map
13:57:21 <jmcarthur_work> path[l], no
13:57:22 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> (a -> b) -> [b])
13:57:22 <lambdabot>    arising...
13:57:29 <jmcarthur_work> path[l], for lists, though, fmap = map
13:57:33 <path[l]> ah
13:57:37 <path[l]> ok
13:57:46 <jmcarthur_work> > fmap (+1) [1..5]
13:57:47 <path[l]> that must be why I got that idea
13:57:47 <lambdabot>   [2,3,4,5,6]
13:57:55 <jmcarthur_work> > fmap (+1) (Just 5)
13:57:55 <path[l]> thanks
13:57:56 <lambdabot>   Just 6
13:57:58 <jmcarthur_work> np
13:58:41 <path[l]> there's a flipped version of fmap isnt there
13:58:43 <path[l]> forM
13:58:44 <ksf> in fact, for functions, fmap = (.)
13:58:57 <path[l]> oh ... thats interesting
13:59:01 <ksf> no that's flip mapM
13:59:55 <jmcarthur_work> @src forM
13:59:56 <lambdabot> forM = flip mapM
14:00:05 <jmcarthur_work> there is no for, afaik
14:00:06 <path[l]> ah
14:00:08 <path[l]> ok
14:00:32 <ksf> well non-monadic for == map
14:00:45 <jmcarthur_work> right
14:00:46 <c_wraith> :t flip (.)
14:00:47 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
14:00:54 <c_wraith> :t (>>>)
14:00:56 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
14:02:25 <monochrom> I don't recall a name for flip fmap
14:03:15 <ray> oh, >>> is on Categories now? that's nice
14:03:15 <ksf> I don't even recall wanting to partially apply fmap
14:03:50 <ksf> well ok (fmap.fmap), but that works, anyway.
14:06:21 * ksf registers a trademark on "Concurrent Continuations"
14:06:37 <ksf> I love it. It's going to make people whince as soon as they hear it.
14:06:48 <ksf> but then, it's mindboggingly simple.
14:06:50 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8533#a8533
14:08:14 <monochrom> The editors at the patent office will rename your stuff to "A system and method for concurrently continuing a process".
14:08:49 <dcoutts> sm: did you work out the sdist problem?
14:09:12 <sm> hi dcoutts .. no, I switched to my mac where it works
14:09:41 <dcoutts> sm: looking at the sources, it's to do with pre-processing
14:09:42 <sm> was in a hurry. Permissions look fine, I'm not sure what's up
14:10:00 <dcoutts> the comment says: -- look for existing pre-processed source file in the dest dir to  see if we really have to re-run the preprocessor.
14:11:53 <ksf> maybe I should use act :: Int -> STM ()
14:12:01 <ksf> ...to priorize stuff.
14:12:35 <ksf> in general, STM is amazing. the first time I'm doing concurrency and it's actually fun.
14:13:34 <dcoutts> sm: if you don't mind, could you post an "ls" of the source dir on the box where it failed?
14:13:45 <sm> sure..
14:13:54 <dcoutts> sm: I suspect there's some extra file that is confusing cabal in this case
14:14:50 <sm> http://gist.github.com/174194
14:15:24 <dcoutts> sm: and does cabal sdist still fail in the same way?
14:15:43 <sm> yes, I just ran that
14:15:47 <dcoutts> ok thanks
14:22:02 <path[l]> can anyone see something wrong with this small expression. newTeams :: [(Int, Int)]  and then filter (\team -> keep (n-1) (fst team) (snd team)) newTeams I get ouldn't match expected type `(a, b)' against inferred type `Int'
14:22:02 <path[l]>     In the first argument of `fst', namely `team'
14:22:03 <path[l]>     In the second argument of `keep', namely `(fst team)' keep is (Int -> Int -> Int -> Bool)
14:22:31 <sm> thanks dcoutts
14:23:09 <mauke> path[l]: apparently newTeams :: [Int]
14:23:37 <path[l]> hmm ok, thats wierd, let me see if thats happening
14:26:29 <monochrom> What is keep?
14:30:05 <dcoutts> sm: could you also post the ls -lR of the dist/ directory?
14:31:04 <path[l]> keep is (Int -> Int -> Int -> Bool)
14:31:26 <path[l]> ugh I thought I would finally finish something without help but its 3 am and this is eluding me
14:31:36 <Tobsan> Am I the only person who keeps thinking of GHC when irssi reports activity in windows 6 and 10?
14:31:44 <sm> since then I did cabal clean, but I think that doesn't matter
14:31:45 <sm> http://gist.github.com/174227
14:31:50 <sm> (dcoutts )
14:32:10 <dcoutts> sm: oh you did cabal clean and it still fails the same way?
14:32:15 <sm> yes
14:32:26 <dcoutts> sm: I presume you're using Cabal-1.6.0.{2 or 3}
14:32:34 <sm> oh wait.. run configure first
14:32:38 <path[l]> ok this is the ugliest code I ever wrote and I intend to clean it up ... but could someone help me with this type error? -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3413#a3413
14:33:02 <sm> yes if I clean, configure, sdist I get same error
14:33:14 <sm> 1.6.0.3 yes
14:33:21 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3413#a3414 <--- with error message
14:33:29 <sm> I was testing an unreleased version once, how would I check that ?
14:33:32 <dcoutts> sm: hmm. I can't reproduce it, using the same dir entries (though obviously not content)
14:33:36 <dcoutts> sm: --version
14:33:51 <sm> ok, --version just says 0.6.2/1.6.0.3
14:34:20 <dcoutts> sm: if you want to help debug, we could annotate the Cabal sources to give us some more debug info
14:34:25 <sm> and I'm on a 64 bit ubuntu vps. Can't see how that would matter though
14:34:36 <sm> sure
14:34:54 <mauke> path[l]: missing argument in recursive call to solve?
14:35:00 <dcoutts> sm: ok, cd to some temp dir and cabal unpack Cabal-1.6.0.3
14:35:09 <path[l]> oh shit
14:35:11 <path[l]> ofcourse
14:35:14 <ksf> writing ugly code is a symptom of tending to refactor heavily, which is a good thing. except if you don't, of course.
14:35:30 <dcoutts> sm: then edit Distribution/Simple/PreProcess.hs, look for preprocessModule and the uses of getModificationTime
14:36:01 <path[l]> thank you. Now if this thing does what I expect, I can wake up tomorrow fresh and clean this up
14:36:01 <path[l]> lol
14:36:21 <sm> dcoutts:  ok
14:36:28 <dcoutts> sm: it'd be useful to add print statements for: psrcFiles, psrcLoc, psrcRelFile, ppsrcFiles and ppsrcFile
14:36:35 <sm> ok, doing that
14:37:28 <dcoutts> sm: probably best to do something like: print ("psrcFiles:", psrcFiles) so it's easy to identify in the output trace
14:37:34 <dcoutts> for each var
14:39:43 <sm> dcoutts: and then cabal install this ?
14:40:00 <sm> or build and run the binary I guess
14:40:19 <dcoutts> sm: yes, you might want to change the version number just so we can be sure we're using the right version
14:40:33 <dcoutts> sm: eg to 1.6.0.4 or something
14:40:43 <hackagebot> named-lock 0.1 - A named lock that is created on demand. (ThomasSchilling)
14:40:50 <dcoutts> sm: then in the rss2irc dir we can ghc --make Setup -package Cabal-1.6.0.4
14:41:07 <dcoutts> sm: and play with the resulting ./Setup
14:41:38 <tim___> hey haskell people
14:41:46 <tim___> got a bit of a noob question
14:41:56 <mauke> I have plenty of noob answers
14:42:12 <tim___> but how can i specify the order in which functions can be applied, like with parenthesis in imperative languages
14:42:20 <mauke> with parentheses
14:42:24 <monochrom> Parentheses.
14:42:27 <tim___> like for instance (5 mod 2) == 0
14:42:29 <tim___> ok
14:42:36 <tim___> so in the case of that
14:42:36 <monochrom> (f (g x) y)
14:42:37 <mauke> useless use of parens
14:42:42 <mauke> > 5 `mod` 2 == 0
14:42:44 <lambdabot>   False
14:42:49 <tim___> yeah, that's what i thought
14:42:50 <monochrom> Err, ((f (g x)) y)
14:42:51 <sm> in  the Cabal package, cabal configure seems to build as much as cabal build
14:42:54 <tim___> but if i run it in GHCI
14:42:55 <tim___> i get
14:43:05 <tim___> o instance for (Num ((a -> a -> a) -> t1 -> t))
14:43:05 <tim___>       arising from the literal `5' at <interactive>:1:5-11
14:43:12 <sm> almost
14:43:15 <mauke> tim___: that's because you're trying to call 5 with two arguments
14:43:18 <monochrom> mod is not `mod`
14:43:20 <ksf> you forgot the backticks
14:43:22 <tim___> aaah
14:43:24 <tim___> :-)
14:43:31 <dschoepe> or, alternatively: mod 5 2
14:43:34 <tim___> yep, taht makes perfect sense now
14:43:37 <tim___> thanks all
14:46:24 <dcoutts> sm: it bootstraps the Setup using it's own sources
14:46:30 <dcoutts> sm: so you see it build twice
14:46:35 <sm> I see
14:46:42 <sm> ok I've built Setup in rss2irc
14:46:59 <sm> ./Setup sdist says to remove dist/src .. shall I ?
14:47:35 <tim___> hmm - one more
14:47:36 <tim___> :-)
14:47:42 <dcoutts> sm: oh, hmm, if this doesn't fail we may have to rebuild cabal-install against your modified Cabal lib
14:47:53 <sm> didn't fail :)
14:47:58 <tim___> can i pass a lambda term as an argument to a function without first binding it to a variable?
14:48:03 <dcoutts> sm: ok, next step...
14:48:11 <tim___> can't seem to work out the syntax :-)
14:48:13 <CalJohn> tim___: yes
14:48:13 <mauke> tim___: sure
14:48:18 <ksf> there are no variables.
14:48:23 <dschoepe> tim___: map (\x -> x + 1) [1..10]
14:48:25 <mauke> > id (\x -> x + 1) 41
14:48:26 <lambdabot>   42
14:48:28 <tim___> aha
14:48:32 <tim___> parens again:-)
14:48:41 <tim___> hahahah - thanks!
14:48:52 <CalJohn> tim___: and it's better to call them "names" instead of variables, because they never vary
14:48:59 <CalJohn> :)
14:49:00 <tim___> oh yep, good point
14:49:03 <dcoutts> sm: build cabal-install against this modified Cabal lib, cabal-install does the sdist ever so slightly differently
14:49:05 <mauke> I disagree
14:49:05 * ksf calls them bindings
14:49:31 <CalJohn> mauke: how so?
14:49:35 <sm> ok I have a not-too-old cabal-install src here
14:49:44 <mauke> I don't see how "names" is better than "variables"
14:50:04 <sm> uh.. cabal configure --constraint "Cabal == 1.6.0.4" ?
14:50:05 <CalJohn> i suppose there is an implicit assumption that variables will vary
14:50:08 <Toxaris_> > map (\x -> x) [1, 2, 3] -- x varies between 1, 2 and 3
14:50:10 <lambdabot>   [1,2,3]
14:50:16 <mauke> what Toxaris_ said
14:50:20 <dcoutts> sm: should work
14:50:38 <ksf> ...there's a sligtly less strong assumption that names may be rebound.
14:50:44 <sm> oh dear, this wants >=1.7.2
14:50:47 <mauke> rebinding is illegal
14:51:00 <ksf> that's why I'm calling them bindings.
14:51:01 <CalJohn> I suppose Toxaris_ has a point, but the meaning of the name does not change inside a scope, the scope changes
14:51:04 <sm> guess I need to get the stable branch
14:51:15 <ksf> ...as does ghc.
14:51:30 <monochrom> "change" is illegal in pure functional programming.
14:51:32 <CalJohn> this is not a big deal for me
14:51:49 <Toxaris_> > let x = 42 in let x = 27 in x -- how many names, how many variables in this code?
14:51:51 <lambdabot>   27
14:52:08 <ksf> I'd say two bindings
14:52:19 <mauke> hmm, one name, two variables?
14:52:40 <monochrom> Two variables after deBruijn'ing.
14:53:00 <Toxaris_> :)
14:53:02 <monochrom> One world, one dream.
14:53:03 <ksf> none after compiling.
14:53:03 <sm> dcoutts: sorry, I'm stalled
14:53:15 <mauke> two girls, one cup
14:53:38 <Baconizer> mauke: die
14:53:42 <monochrom> two girls need four cups!  <duck>
14:53:54 <Baconizer> :<
14:53:58 <sm> oh I know.. get the 0.6.2 tag
14:55:21 <sm> huh.. darcs: unable to read patch:  Mon Sep 12 22:03:55 PDT 2005  ijones@syntaxpolice.org
14:55:35 <Toxaris_> CalJohn: I would say that in map (\x -> x) [1, 2, 3], the meaning of the name "x" does not change, it always means the lambda-bound variable in the first argument of map. However, the value of that variable changes for each call of that function.
14:55:36 <dcoutts> sm: or cabal unpack cabal-install
14:55:53 <dcoutts> sm: or just cabal install cabal-install --constraint "Cabal == 1.6.0.4"
14:55:57 <sm> thanks
14:56:51 <hackagebot> file-embed 0.0.1 - Use Template Haskell to embed file contents directly. (MichaelSnoyman)
14:57:55 <monochrom> In some implementations of functional languages, in map f [1,2,3], f is cloned three times for the three calls, and then they're all garbage-collected. It seems more like write-once-then-discard three times rather than three substitutions into the same placeholder.
14:59:29 <ksf> calling a function multiple times doesn't make a binding variable.
14:59:33 <sm> dcoutts: I tried that last, but the new cabal executable in ~/.cabal/bin still says Cabal 1.6.0.3 and doesn't print :/
14:59:52 <monochrom> Like in fast food places you get a new styroform plate for a new burger. The content of the styrofoam plate never changes, it gets tossed. Not like a fine china dish in a classy restaurant, the content of the dish changes many times a day.
14:59:52 <ksf> (\x -> x) doesn't know anything about its surroundings.
15:00:46 <ksf> as soon as x is bound to _anything_, it stays that way.
15:01:03 <dcoutts> sm: I'm not sure exactly what's going on there, if it's picking the wrong Cabal lib version, or not installing in the right place
15:01:18 <copumpkin> > let x = 5 in (\y -> y + x) 5
15:01:19 <lambdabot>   10
15:01:22 <ksf> ...after all, there are gazillions of (\x -> x) functions: each for every type, and then each for every possible member of all those types.
15:01:23 <dcoutts> sm: we can force things though, do the cabal unpack one, and cabal configure -v --constraint "Cabal == 1.6.0.4"
15:01:38 <dcoutts> sm: with -v it'll report exactly which versions of deps its picking
15:01:51 <dcoutts> sm: then build, but there's no need to install, we can run it from dist/
15:01:53 <monochrom> (End of attempt to hijack the thread to make classy restaurants sound yucky!)
15:02:06 <ksf> polymorphism is syntactic sugar.
15:02:55 <c_wraith> programming languages are syntactic sugar
15:03:29 <ksf> knifes and forks are syntactic sugar.
15:03:34 <monochrom> compilation is desugarisation
15:04:02 <arw> real men key their programs with unlabeled switches on the front panel of their computers into the main memory.
15:04:26 <monochrom> real men compute with their own brains.
15:04:35 <badsheepy> real men just point at things and grunt
15:04:41 <sm> dcoutts: see what it's doing there ? http://gist.github.com/174254
15:04:43 <arw> real women used to use unlabelled cables, until the real men sent them back to their cooking :>
15:06:09 <dcoutts> sm: ohhh, yes. ok
15:06:18 <monochrom> real men eat directly from the fridge, no styrofoam plate or fine china dish.
15:06:21 <dcoutts> sm: my bad, it'll still report itself as 1.6.0.3
15:06:35 <arw> real men also eat their fridge
15:06:52 <dcoutts> sm: since cabal has to bootstrap itself, it cannot rely on the normal mechanism to pass the version from the .cabal file to the code, which uses a generated module
15:06:55 <monochrom> hahahahaha tasmanian monster
15:07:21 <dcoutts> sm: anyway, that version you've got there should still have the debug print statements, so lets go try it
15:07:38 <sm> unfortunately it prints nothing.. sigh
15:07:50 <sm> I'll put in an error to make absolutely sure
15:08:42 <sm> there just that one location with two calls to getModificationTime.. we figure it must go through there, riht
15:10:25 <dcoutts> sm: ah, there's also one in cabal-install in Distribution/Client/Tar.hs
15:12:01 * sm instruments that one
15:12:33 <dcoutts> sm: it still fails right? with our new cabal-install
15:12:48 <sm> dcoutts: that one prints. But it didn't fail
15:13:07 <dcoutts> ah hmm
15:13:10 <sm> http://gist.github.com/174261
15:13:27 <sm> hmm
15:13:39 <dcoutts> sm: can we still reproduce the failure at all?
15:13:40 <sm> and the system cabal still fails
15:13:45 <dcoutts> ok
15:13:55 <sm> maybe I just blow away the system cabal
15:13:59 <dcoutts> sm: system as in not the one in ~/cabal/bin
15:14:03 <sm> it's probably a dev build
15:14:12 <sm> eh, no it's that one I guess
15:14:48 <sm> no, it's a separate binary in /usr/local/bin
15:15:03 <sm> but I thought those are the same for me.. once sec
15:15:19 <tim___> hmm - quick q about currying and partial function application:
15:15:23 <tim___> given this code
15:15:24 <tim___> http://gist.github.com/174266
15:15:36 <tim___> i'm partially applying my bothPredicates function
15:15:46 <tim___> which seems a lot like magic to me
15:15:46 <dcoutts> sm: if we can't reproduce it with a version we build from source I don't think there's a lot we can do unfortunately
15:16:02 <tim___> so i was wondering what that partially applied function would actually look like
15:16:02 <sm> it's different. --version says 1.6.0.3 but I bet that's the dev build I built to test
15:16:18 <dcoutts> sm: one odd thing is that the file name appears to be "", it should report the file name in the error message
15:16:51 <tim___> aah
15:17:00 <pr> @pl \f1 f2 x -> f1 x && f2 x
15:17:01 <lambdabot> liftM2 (&&)
15:17:02 <tim___> actually ignore that, i think i've worked it out :-)
15:17:04 <sm> you mean, filename is missing in "cabal: rss2irc-0.3: getModificationTime: does not exist (No such file or directory)" ?
15:17:11 <dcoutts> sm: right
15:17:35 <sm> ok.. I say nuke this binary, if there's a real bug it will reappear in latest versino
15:17:50 <dcoutts> sm: oh, maybe I'm wrong about it showing the file name actually
15:18:11 <Gracenotes> tim___: if you're asking about th making the mod part pointless, that's filter' (bothPredicates ((/= 0) . flip mod 2) ((== 0) . flip mod 3))... if that's what you'r asking about
15:18:22 <dcoutts> sm: oh actually, "rss2irc-0.3" is the file name
15:18:29 <sm> that's what I thought
15:18:29 <Gracenotes> instead of flip mod blah, you could also do (`mod` blah)
15:18:37 <dcoutts> sm: if I compare in ghci doing getModificationTime "foo"
15:19:35 <Toxaris_> tim___: it looks like (\x -> ((\ x -> (mod x 2) /= 0) x) && ((\ x -> (mod x 2) /= 0) x))
15:19:39 <fxr> ~.
15:19:49 <fxr> ups
15:20:01 <Gracenotes> tim___: uh, if you're asking about the bothPredicates itself is partially applied... uh.. what Toxaris_ said >_>
15:20:12 <tim___> aah thanks chaps
15:20:26 <tim___> i don't think i phrased the question very wekk
15:20:27 <tim___> well
15:20:45 <Toxaris_> well, what I said, modulo copy&paste errors
15:20:52 <dcoutts> sm: so are we stuck then?
15:20:55 <tim___> :-)
15:21:25 <sm> dcoutts: we have a binary that shows the issue, but the ones we've built don't
15:21:33 <dcoutts> sm: ho hum :-(
15:21:34 <sm> and I need to stop.. so perhaps we should table it
15:21:39 <dcoutts> sm: yep
15:21:40 <mmorrow> Gracenotes: the dominator tree rooted at each kanji, for each kanji, using your kanji.dot as starting point: http://moonpatio.com/images/KANJI_DOM.png
15:21:42 <ksf> why do I have to use lambdas in record definitions?
15:21:47 <dcoutts> sm: thanks for you persistence
15:21:49 <dcoutts> you/your
15:21:57 <sm> thank you! I'll shout if I learn more
15:22:00 <dcoutts> ok
15:22:01 <ksf> you can't just say Foo { bar x = x }
15:22:03 <Gracenotes> tim___: in general, (\x -> func a b c x) can be phrased as simply (func a b c). (eta conversion)
15:22:07 <mmorrow> Gracenotes: all the files/data pre-montage are at http://moonpatio.com/kanji/
15:22:49 <monochrom> Oh haha. Let's see what if it were allowed.
15:23:06 <monochrom> data Foo a = Foo { bar :: [a] -> [a] }
15:23:40 <mmorrow> @go define graph dominator
15:23:43 <lambdabot> http://chicken.wiki.br/eggref/4/graph-dominators
15:23:43 <lambdabot> Title: Eggs Unlimited - graph-dominators
15:23:47 <Gracenotes> mmorrow: ah... very neat. So that outlines, for each kanji, what kanji that also appear in
15:23:59 <Gracenotes> they
15:24:19 <monochrom> myfoo = Foo { bar [] = []; bar (x:xs) | f x = x : bar xs | otherwise = bar xs }
15:24:35 <mmorrow> Gracenotes: given a tree rooted at A, if B is a parent of C, then every path from A to C has to pass through B.
15:25:01 <mmorrow> s/has to pass through/passes through/
15:26:23 <Toxaris_> monochrom, ksf: looks nice to me. something like   <expression> ::= <constructor> "{" <binding_group> "}"
15:26:29 <mmorrow> s/is a parent/is an ancestor/
15:26:45 <ksf> there could be layout problems.
15:26:53 <Toxaris_> with the additional condition that the names bound in the binding group must belong to the constructor
15:27:03 <ksf> but then, one could just separate multiple definitions by ',' .
15:27:14 <Toxaris_> and the next step would be to add all defined constructors as layout-starting keywords :)
15:27:17 <Gracenotes> I've been developing that myself, graphs for each character as a source or a sink. The image nicely communicates that most characters are stand-alone.. at least the ones I've encountered so far
15:27:37 <mmorrow> Gracenotes: yeah, dominators is a nice fit for this
15:28:23 <ksf> just get rid of the { , } syntax and use plain old layout- { ; }
15:28:46 <Toxaris_> ksf: yes, just a standard binding group
15:28:48 <mmorrow> Gracenotes: there's a dominator implem in fgl, my version is essentially the same as that one (neither use the super leet dominators algo, but that looks semi-epic to implement)
15:28:58 <monochrom> Meanwhile, "let {bie [] = []; bie (x:xs) = []} in Foo{bar = bie}" is a tolerable workaround.
15:29:42 <ksf> but then, one might want to define an auxilary function that's used by the member function.
15:29:52 <mmorrow> well, semi-epic in part because you have to translate the pseudo-code from imperative to functional, as well as figure out wtf is going on in the pseudocode/algo to begin with
15:30:21 <monochrom> You have "where" for auxiliary functions.
15:30:32 <ksf> ...but not for shared ones.
15:30:35 <Toxaris_> ksf: so you have to wrap the thing in a let-expression?
15:30:43 <ksf> well yes.
15:30:49 <monochrom> Oh! shared.
15:31:06 <ksf> I'm just questioning the "only names belonging to the constructor" rule.
15:31:30 <ksf> after all, you can define functions that aren't exported in a module, too.
15:32:00 <ksf> actually, records and modules have a lot in common.
15:32:05 <monochrom> This is where I like SML more. "let x=0 in y=x and z=x end" defines y,z using auxiliary x.
15:32:33 <Toxaris_> ksf: but you are not writing many modules with the same set of exported functions (in Haskell)
15:32:42 <monochrom> You can even write that at the top level. Then y,z are toplevel names!
15:32:49 <Toxaris_> ksf: but you may want to write many record creations with names, and get static typechecking for misspelled names
15:33:03 <ksf> but I might want to parametrise a module.
15:33:19 <ksf> therefore, importing a record _does_ make sense.
15:33:38 <Toxaris_> so you want ML-style modules encoded in haskell records?
15:33:53 <ksf> well the plumbing is there, why don't we use it?
15:34:16 <Toxaris_> its not convenient to use on the client side
15:34:22 <Toxaris_> because you can't to destructuring bind on the top-level
15:34:30 <Toxaris_> or open
15:35:57 <ksf> well, right now, I've got a module with a single exported function that makes a TVar, spawns a thread and returns a record.
15:36:06 <monochrom> Teach a man SML, and you feed him for a day. Show him Haskell, and you occupy him for life.
15:36:30 <Toxaris_> (ok I tried it, and it seems you *can* do destructuring binds on the toplevel)
15:36:45 <ksf> It'd be pure caller-side convinience to parametrize all the selectors automatically.
15:37:00 <monochrom> I do destructuring binds on the toplevel all the time.
15:37:38 <endojelly> I just read an overview paper about SCALA
15:37:49 <endojelly> that's really different
15:38:15 <ksf> ...in fact, I should just TH that as soon as I find the time.
15:38:18 <monochrom> I did it in http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
15:39:11 <monochrom> http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements#Make_token_parser  to get closer to the place where I did it.
15:39:51 <Toxaris_> monochrom: that looks pretty nice. I always wondered how makeTokenParser is supposed to be used
15:40:09 <Toxaris_> (syntactically, not semantically)
15:48:55 <deech_> Hi all, I have a design question. I have a small server that takes and emits JSON messages. Each incoming message has service attribute , eg. 'query' and a payload object like eg. {'lastname' : 'Smith' ...}. I currently have a monolithic dispatcher that parses the incoming message and , but I stumped on how to seperate functionality and have different modules for different services. Is there an existing idiom for this?
15:50:04 <endojelly> deech_, a map of "action" names to functions, for example
15:50:48 * ksf is missing "clearChan" from STM.
15:51:15 <endojelly> ksf, clearChan? what should that do, reset the transaction?
15:51:41 <ksf> empty a TChan.
15:52:15 <deech_> endojelly : yes, but how do I combine them? So if module A has code for "query" and module B has "authenticate" etc. how do I have an incoming messages go through each one until it finds the right one?
15:52:37 <Axman6> ksf: is there a function to check if the chan's empty
15:52:38 <Axman6> ?
15:52:53 <ksf> yep.
15:53:05 <endojelly> deech_, make them "register" into your dispatcher
15:53:06 <ksf> still, looping over the remaining elements isn't the most effective thing.
15:53:22 <endojelly> deech_, "hello, I provide the following: authenticate, logout and foo."
15:54:03 <deech_> endojelly: oh so have each module maintain a Data.Map.Map of services to functions and merge all the maps in the main function?
15:55:27 <endojelly> deech_, for example, yes!
15:55:52 <deech_> endojelly: hmmm ... I must ponder that more. Thanks for the suggestion!
15:55:53 <endojelly> deech_, it doesn't even mattr what each module does, whether it uses a Map or something else. the relevant thing is the map in the main dispatcher function
15:56:47 <ksf> code encapsulation is a cool thing.
15:57:18 <ksf> so you can pass that IO () that launches the missiles to some untrusted code and don't give it access to the passkeys.
15:58:24 <Axman6> Security.NSC.Nuclear
16:12:43 * jfoutz loves that the nuclear football passkey was 00000
16:25:49 <dumael> jfoutz: the british didn't even have codes. All you'd need was a screwdriver to arm the weapon.
16:35:48 <tingi>  A linear combinations of vectors (s2[i] - s1[i], s3[i] - s1[i]) is zero if and only if the same linear combination of vectors (s1[i], s2[i], s3[i]) is a vector with three equal components, namely, all equal to this linear combination of s1[i]'s , why is this true ?
16:36:30 <copumpkin> tingi: I don't understand your notation
16:41:34 <ksf> hmmm I'm a bit worried by the fact that I'm coding up objects here
16:41:48 <copumpkin> how so?
16:41:50 <ksf> ...though it's "one thread, one object"
16:41:52 <tingi> copumpkin, i've 3 vectors (p11,p12,p13) , (p21,p22,p23),p(31,p32,p33), now i've to check whether there is exists some X,Y,Z such that X*p11 + Y*p21+Z*p31=k, X*p12+Y*p22+Z*p32=k,X*p13+Y*p23 +Z*p33 =k, X+Y+Z>0, k>0 , all are +ve integers
16:42:02 <jfoutz> copumpkin: i think tingi means  (b-a) + (c-a) = 0 iff a = b+c
16:42:06 <copumpkin> oh
16:42:10 <jfoutz> d'oh. too slow.
16:43:35 <dolio> (2 == 1 + 1, (1 - 2) + (1 - 2))
16:43:39 <dolio> > (2 == 1 + 1, (1 - 2) + (1 - 2))
16:43:41 <lambdabot>   (True,-2)
16:45:22 <tingi> copumpkin, is that useful ?
16:54:33 <dafra> hi, the ST paper is tough for me. What book should I read first to understand it. I need something about ype theory...
16:54:48 <dafra> type
16:55:02 <SamB_XP> ... those things aren't cheap!
16:55:08 <Axman6> ST as in State Transformer monad?
16:55:11 <copumpkin> dafra: I can try to explain it if you want
16:55:13 <dafra> yes
16:55:19 <copumpkin> state thread?
16:55:27 <dafra> i dont get the unification thing
16:55:51 <copumpkin> I haven't actually read the paper so I'm not sure what unification thing you're talking about :)
16:55:57 <Axman6> me either
16:56:04 <Axman6> but ST is quite easy to use
16:56:26 <copumpkin> dafra: say you have a function a -> (), what definition must that function have?
16:56:40 <Makoryu> Is there a command line (man-style) Haskell documentation tool that I don't know about?
16:57:01 <dafra> copumpkin: ??
16:57:01 <Axman6> dafra: check out http://www.haskell.org/haskellwiki/Monad/ST for some examples on how to use ST
16:57:04 <dafra> const () ?
16:57:08 <copumpkin> dafra: yup
16:57:20 <dafra> yeah !
16:57:20 <Axman6> copumpkin: how's that related? o.O
16:57:22 <copumpkin> dafra: that's the basis of why ST works the way it does
16:57:40 <dafra> wha i dont get :
16:57:52 <copumpkin> you have the forall s. condition on your rank-2 function because it ensures that you can't rely on its value
16:58:06 <copumpkin> just like you can't do anything about the a in a -> Int
16:58:22 <dafra> \s, a. St s a -> a is different than \a. (\s. ST s a) -> a
16:58:39 <dafra> i dont know rank-2 actually
16:58:44 <dolio> They aren't lambda expressions.
16:58:56 <copumpkin> so you have something like runST :: (forall s. ST s a) -> a
16:59:36 <dafra> copumpkin: yes
16:59:48 <copumpkin> you also have
16:59:48 <copumpkin> newtype ST s a = ST (STRep s a)
16:59:48 <copumpkin> type STRep s a = State# s -> (# State# s, a #)
16:59:51 <Draconxx> dafra, think of it as runST /requires/ that its argument be polymorphic.
16:59:56 <copumpkin> @src State
16:59:56 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:59:59 <copumpkin> dammit :)
17:00:17 <copumpkin> but you see that the STRep is quite similar to your regular State
17:00:51 <copumpkin> dammit, I have a meeting now :/
17:01:02 <copumpkin> sorry to start an explanation and not finish it :P
17:01:06 <copumpkin> unless you'll be here later
17:01:07 <dafra> copumpkin: thx, good meeting
17:01:25 <dafra> i need to read about this rank-2 thing
17:02:13 <copumpkin> it's not complicated (meeting still hasn't started)
17:02:16 <copumpkin> it's just that if you say
17:02:43 <copumpkin> f :: (a -> b) -> ...
17:02:58 <copumpkin> that means you want a function for two specific types
17:03:04 <copumpkin> if you instead did
17:03:11 <copumpkin> f :: (forall a b. a -> b)
17:03:16 <copumpkin> -> ...
17:03:27 <copumpkin> you'd want a polymorphic function that works for _all_ as and bs
17:03:36 <copumpkin> which means you could only use unsafeCoerce :P
17:03:41 <dafra> ok
17:04:10 <ray> any function satisfies the (a -> b) but only unsafeCoerce satisfies the other one
17:04:23 <SamB_XP> copumpkin: or const undefined!
17:04:23 <dolio> copumpkin: _|_
17:04:30 <copumpkin> :P
17:05:55 <dafra> so, runST's parameter has to work for any s and a ?
17:06:05 <copumpkin> has to work for any s
17:06:23 <dafra> ur right, (forall s. ...)
17:06:39 <copumpkin> which is basically saying "you can't rely on s being anything under your control"
17:07:01 <copumpkin> (s being the world state being passed around)
17:07:16 <dafra> ok
17:07:19 <SamB_XP> so, for instance, you can't pass in any STRefs from outside ...
17:07:36 <SamB_XP> and you can't use ioToST
17:07:39 <SamB_XP> @hoogle iotost
17:07:40 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
17:07:40 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
17:07:47 <SamB_XP> not THAT!
17:07:52 <jfoutz> hehehe
17:08:03 <dafra> yerk
17:08:03 <SamB_XP> @hoogle IO a -> ST RealWorld a
17:08:04 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
17:08:04 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
17:08:04 <lambdabot> Data.STRef writeSTRef :: STRef s a -> a -> ST s ()
17:08:14 <SamB_XP> where's the safe one ?
17:08:50 <Asztal> I see only stToIO
17:08:57 <MyCatVerbs> @hoogle ST RealWorld a -> IO a
17:08:58 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
17:08:58 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
17:08:58 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
17:08:59 <pr> @hoogle a -> b
17:09:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:09:00 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:09:00 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:09:01 <dolio> IOToST will never be safe.
17:09:08 <SamB_XP> dolio: sure it can be!
17:09:15 <dolio> No.
17:09:18 <SamB_XP> as long as it returns ST RealWorld a
17:09:23 <MyCatVerbs> dolio: of course that's safe, it's only a type constructor. ;)
17:09:30 <dafra> thank you all, very helpful
17:09:49 <MyCatVerbs> (Ignore my bullshit, I'm just nitpicking your capitalisation. ^~)
17:09:56 <dolio> :)
17:11:42 <dolio> SamB_XP: I suppose that's safe. But kind of boring.
17:11:55 <dolio> I guess you could use it instead of stToIO to do ST stuff and IO stuff together.
17:12:27 <SamB_XP> dolio: could be useful if you're using a generic ST-based HOF for something that's actually in IO
17:13:04 <dolio> Yeah.
17:16:42 <SamB_XP> stToIO        :: ST RealWorld a -> IO a
17:16:42 <SamB_XP> stToIO (ST m) = IO m
17:16:42 <SamB_XP> ioToST        :: IO a -> ST RealWorld a
17:16:42 <SamB_XP> ioToST (IO m) = (ST m)
17:17:00 <SamB_XP> from http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html#stToIO
17:17:28 <dolio> I don't know why they don't export it.
17:17:54 <SamB_XP> they don't?
17:17:55 <SamB_XP> bug?
17:18:07 <dolio> I'm pretty sure they don't.
17:18:36 <SamB_XP> woah!
17:18:38 <SamB_XP> they don't!
17:18:46 <dolio> Wow, they even have unsafeInterleaveST.
17:19:11 <olsner_> unsafeInterleaveIO . stToIO ?
17:19:29 <dolio> No. It has type ST s a -> ST s a.
17:19:53 <SamB_XP> pretty sure that actually is unsafe ;-)
17:20:04 <Draconx> unsafeIOToST . unsafeInterleaveIO . unsafeSTToIO ?
17:20:10 <dolio> Yeah. I'm sure it can break referential transparency.
17:20:10 <olsner> ah, of course... let's say I add (ioToST .) on that?
17:20:24 <SamB_XP> olsner: nope!
17:20:26 <Draconx> Three times as unsafe!
17:20:41 <SamB_XP> that would mess it up with a superfluous RealWorld
17:22:11 <olsner> really? I don't understand... (well, I probably could, but am not currently in the proper state of mind to do so)
17:23:42 <SamB> :t ioToST . unsafeInterleaveIO . stToIO
17:23:43 <lambdabot> Not in scope: `ioToST'
17:23:43 <lambdabot> Not in scope: `unsafeInterleaveIO'
17:23:43 <lambdabot> Not in scope: `stToIO'
17:23:53 <SamB> ,t ioToST . unsafeInterleaveIO . stToIO
17:23:56 <lunabot>  luna: Not in scope: `ioToST'
17:25:06 <Cale> http://www.youtube.com/watch?v=SYGT450yifM&feature=channel :)
17:26:34 <monochrom> Cale: That's horrible, and you know it, so why are you inflicting it on us?
17:26:54 <Cale> I think it's great :)
17:27:00 * monochrom continues his experiment on blindly saying that to everyone who posts a random url.
17:27:29 <olsner> monochrom: strangely appropriate :)
17:27:57 <dons> monochrom: hehehe
17:28:17 <MyCatVerbs> http://www.haskell.org/
17:28:38 <Asztal> http://www.random.org/
17:29:00 <monochrom> That is not random, MyCatVerbs. I'm after spontaneous and unexplained ones.
17:29:20 <dolio> @yow! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8540#a8541
17:29:20 <lambdabot> Now my EMOTIONAL RESOURCES are heavily committed to 23% of the SMELTING
17:29:20 <lambdabot> and REFINING industry of the state of NEVADA!!
17:30:17 <dolio> Where is your referential transparency now?!
17:31:04 <monochrom> I ate it in a classy restaurant.
17:32:54 <olsner> dolio: omg, unsafe constructs introduce unsafety! this is an outrage!
17:33:30 <dolio> unsafeInterleaveST is more unsafe than unsafeInterleaveIO.
17:34:12 <olsner> really? I'd have thought STRefs and unsafeFooST would be just as un/safe as unsafeFooIO on IORefs
17:34:16 <mc__> maybe unsafe should be replaced with deadly
17:34:21 <mc__> to scare the hell out of people
17:34:48 <olsner> maybeLaunchMissilesAndInterleaveIO
17:34:50 <dolio> olsner: There's a perfectly safe runST, though. That combines poorly with unsafeInterleave.
17:34:50 <Trinithis> ... or to entice them
17:35:39 <dolio> olsner: So you can construct pure values that depend on evaluation order elsewhere in the program.
17:36:26 <Trinithis> maybeCheneyForPresidentInterleaveIO
17:36:38 <dolio> And you can't hide it with "IO is nondeterministic."
17:37:38 <olsner> sounds like it's time for some safePerformBedtime
17:38:05 <MyCatVerbs> olsner: I think that's const ().
17:38:14 <SamB> dolio: I don't see how it's more unsafe
17:38:22 <SamB> it just has less dumb excuses
17:38:24 <MyCatVerbs> As in, "oh, don't worry about that dear. Have a unit and relax."
17:38:27 <dolio> SamB: I pasted an example.
17:38:33 <dolio> You can't write my example with unsafeInterleaveIO.
17:38:51 <SamB> oh?
17:38:56 <olsner> MyCatVerbs: yeah, or callCC goToBed
17:39:01 <Trinithis> even when using unsafePerformIO to help you?
17:39:16 <dolio> Well, of course you can write it then.
17:39:43 <SamB> dolio: how about using >>= in main ?
17:39:46 <roconnor> jeffheard_home: why do some of your blue-orange curves look aliased, or however you want to call it?
17:40:04 <MyCatVerbs> olsner: callCC's type still bewilders me. ((a -> m b) -> m a) -> m a? What? :)
17:40:14 <Trinithis> @ty unsafeDontFryComputer
17:40:15 <lambdabot> Not in scope: `unsafeDontFryComputer'
17:40:55 <jeffheard_home> roconnor: because I used imprecise math in putting down the points and I used arcs instead of rectangles.  the aliased points are illustrator changing SVG to PNG for me.  If I'd used rectangles there wouldn't be aliasing
17:41:01 <dolio> SamB: That doesn't violate referential transparency, in case that didn't get sent before my IRC client decided to log out for a few seconds.
17:41:13 <roconnor> jeffheard_home: ah, SVG to PNG
17:41:39 <Draconx> dolio, doesn't http://dpaste.com/84867/ have the same problem?
17:41:57 <dolio> Draconx: No.
17:41:59 <jeffheard_home> that and the circles instead of rectangles thing
17:42:00 <olsner> MyCatVerbs: I'm sure there's an explanation :)
17:42:09 <jeffheard_home> I originally thought to space them out, but that was too much visual noise
17:42:16 <jeffheard_home> you shoulda seen it when I used polar coords, though
17:42:23 <jeffheard_home> it was really pretty if entirely nonfunctional
17:42:31 <jeffheard_home> that is, it wsa functional, but not useful :P
17:42:32 <Trinithis> what about using fork in that example?
17:42:35 <MyCatVerbs> olsner: Oh sure, it's just one of those things that takes looking up the definition and then working through the types to work out. :)
17:42:41 <dolio> Draconx: If it had the same problem, then so would randomIO.
17:43:04 <roconnor> jeffheard_home: aw, you don't have the SVG file up
17:43:04 <dolio> Strictly speaking.
17:43:21 <jeffheard_home> oh...  if you want it, I can give it to you
17:43:30 <roconnor> I'd like to see it
17:43:39 <jeffheard_home> sure.  send it to your email?
17:43:48 * EvilTerran can't work out what jeffheard and roconnor are talking about
17:44:07 <roconnor> jeffheard_home: If you don't want to put it on the web
17:44:13 <olsner> MyCatVerbs: the continuation == "computation that happens "after" callCC foo" takes 'a' (the result of foo) - the 'foo' here is a function that takes one of those continuations and returns an action producing 'a'
17:44:20 <jeffheard_home> suppose I could
17:44:24 <dolio> Draconx: I mean, they have similar problems with acting spooky when you actually know what's going on. But only unsafeInterleaveST lets you break referential transparency in combination with the otherwise normal functioning of the monad.
17:44:32 <olsner> MyCatVerbs: and something-something the something-something and it all works out
17:44:46 <roconnor> jeffheard_home: I'd be inclined to make the PNG link to the SVG myself
17:44:57 <jeffheard_home> that's what I'm working on now
17:45:01 <olsner> I'm a bit sketchy on the latter part :)
17:45:11 <roconnor> EvilTerran: http://vis.renci.org/jeff/2009/08/24/plotting-timeseries-in-space-filling-curves/
17:45:12 <dolio> You could argue that the spooky action part is also bad, and I'd have nothing much to retort with.
17:46:15 <Draconx> dolio, oh I see -- you're saying that b1 and b2 could legitimately be different here.
17:47:02 <jeffheard_home> roconnor: done
17:47:36 <jeffheard_home> Just one of the SVGs, though.  I used illustrator to line them up and put them next to each other.  Was really just a sketch
17:47:40 <jeffheard_home> wasn't sure if they'd work out or not
17:47:51 <SamB> dolio: cop-out, I say, on IO's part
17:48:06 <dolio> Draconx: Yes. After all, one of the points of couching IO in terms of monads is that in "do a <- fooM ; b <- fooM", 'a' and 'b' are allowed to be different.
17:48:57 <SamB> okay, so *maybe* unsafeInterleaveST is a bit more scarily evil
17:48:58 <dolio> SamB: It's not a cop-out that unsafeInterleaveIO doesn't violate referential transparency (as far as I know, at least; maybe there's an example waiting to be discovered).
17:49:08 <dolio> Referential transparency has a precise definition.
17:49:11 <SamB> slightly
17:49:43 <dolio> You can argue about what other notions of purity are important and whether each monad fails.
17:49:47 <SamB> but, you know, I still think calling all things in IO nondeterministic just because of their type is an oversimplifications
17:49:58 <SamB> er. whoops, extra s
17:49:59 <dolio> Which, unsafeInterleaveST will fail in the same ways for most other purity tests, I imagine.
17:50:28 <roconnor> jeffheard_home: heh, that is actuallly much worse.  You should put it back the way it was :)
17:50:31 <dolio> Well, I don't think you have to call all things in IO nondeterministic. Just the results of unsafeInterleaveIO.
17:50:35 <roconnor> jeffheard_home: sorry
17:50:42 <jeffheard_home> lol.  no worries
17:50:49 <SamB> dolio: anyway, you can make just as evil things with unsafe
17:50:52 <jeffheard_home> firefox + SVG still has the occasional bit of hate.
17:50:53 <SamB> InterleaveIO
17:50:57 <SamB> in practice
17:50:59 <dolio> That's actually the problem. unsafeInterleaveST introduces the same non-determinism, and ST lets you get it into pure values.
17:51:08 <SamB> it's just that you have to do so in the IO monad
17:51:30 <SamB> but the values, once created, are supposedly pure either way!
17:51:38 <dolio> IO has all kinds of other non-determinism already.
17:51:49 <dolio> Like concurrency.
17:52:16 <jeffheard_home> roconnor: what was the problem?  I only ever opened the file in illustrator
17:52:24 <dolio> And the catchable exceptions.
17:52:29 <SamB> it's not *that* much worse, anyway
17:52:44 <Trinithis> NO!!! It's not nondeterministic! IO's internal state allows it to see the future and then decide!
17:52:44 <roconnor> jeffheard_home: it looks small, ugly, and the aliasing is even worse
17:53:03 <SamB> sure, the IO monad has all kinds of other nasty sharp things ...
17:53:13 <SamB> but it's unsafePerformIO is still just as sharp
17:53:18 <jeffheard_home> ah.  well, brilliant.  I'm sure there's a way to fix that by using the proper coordinate system and using rectangles to fill the space rather than arcs
17:53:19 <roconnor> jeffheard_home: if I zoom it sort of gets a little better
17:53:24 <SamB> er. s/it's//
17:53:30 <roconnor> jeffheard_home: yes, likely
17:53:42 <dolio> Well, it breaks potential optimizations, at least. You can't turn my "let (a1, b1) = runST bad ; (a2, b2) = runST bad" into one call of runST bad anymore, as you normally could.
17:54:09 <monochrom> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8540#a8543
17:54:29 <mmorrow> @type Control.Monad.ST.unsafeIOToST . System.IO.Unsafe.unsafeInterleaveIO . Control.Monad.ST.stToIO
17:54:30 <lambdabot> forall s a. ST GHC.Prim.RealWorld a -> ST s a
17:54:38 <SamB> dolio: I'm talking about practical danger here
17:54:50 <mmorrow> @type Control.Monad.ST.unsafeIOToST . System.IO.Unsafe.unsafeInterleaveIO . Unsafe.Coerce.unsafeCoerce . Control.Monad.ST.stToIO
17:54:50 <roconnor> jeffheard_home: there is one zoom level that works perfectly
17:54:51 <lambdabot> forall s a a1. ST GHC.Prim.RealWorld a1 -> ST s a
17:54:59 <mmorrow> @type Control.Monad.ST.unsafeIOToST . System.IO.Unsafe.unsafeInterleaveIO . Unsafe.Coerce.unsafeCoerce . Control.Monad.ST.stToIO :: ST s a -> ST s a
17:55:00 <lambdabot>     Couldn't match expected type `s'
17:55:00 <lambdabot>            against inferred type `GHC.Prim.RealWorld'
17:55:00 <lambdabot>       `s' is a rigid type variable bound by
17:55:28 <roconnor> jeffheard_home: but as it stands, what you originally had is still better IMHO
17:55:30 <mmorrow> @type Control.Monad.ST.unsafeIOToST . System.IO.Unsafe.unsafeInterleaveIO . Control.Monad.ST.stToIO . Unsafe.Coerce.unsafeCoerce :: ST s a -> ST s a
17:55:31 <jeffheard_home> maybe tomorrow.  I've been given the go-ahead by the bosses to open source The Big Board before I give my talk on it at CUFP, and so I'm working on a user's manual quickly before I actually release it
17:55:31 <lambdabot> forall s a. ST s a -> ST s a
17:55:40 <jeffheard_home> roconnor: I put it back the way it was
17:56:33 <roconnor> jeffheard_home: as for you PNG, there is probably a way to align the images before rasterizing to remove the alaising
17:56:44 <roconnor> I wouldn't worry too much about it though
17:57:15 <mmorrow> @type let y f = let z x = f (Unsafe.Coerce.unsafeCoerce x x); {-# NOINLINE x #-} in z z in y
17:57:16 <lambdabot> forall t t1. (t -> t1) -> t1
17:57:16 <jeffheard_home> yeah, most likely.  I'll write a better version when I've finished the open-sourcing and such.
17:57:23 <roconnor> :)
17:57:25 <mmorrow> oops
17:57:28 <mmorrow> @type let y f = let z x = f (Unsafe.Coerce.unsafeCoerce x x); {-# NOINLINE z #-} in z z in y
17:57:29 <lambdabot> forall t t1. (t -> t1) -> t1
17:57:48 <dolio> Is that pragma really necessary?
17:57:58 <mmorrow> yeah, or else the simplifier loops
17:57:59 <mmorrow> :)
17:58:11 <dolio> Even when just asking the type?
17:58:18 <mmorrow> dolio: hehe
17:58:28 <SamB> @type let y f = let z x = f (Unsafe.Coerce.unsafeCoerce x x) in z z in y
17:58:29 <lambdabot> forall t t1. (t -> t1) -> t1
17:58:33 <SamB> no
17:58:38 <mmorrow> i felt compelled to give the code that would actually work
17:58:40 <dolio> Well, that's good at least.
17:59:27 <monochrom> You people are devious!
17:59:56 <aCiD2> hi! I've started learning haskell, and I wouldn't mind sticking my teeth in by reading the source code of a small, yet functional application - does anyone have any suggestions?
18:00:21 <aCiD2> I considered XMonad, but it's a bit too much at the moment - a simple command line tool that does something would be good :)
18:00:53 <mmorrow> as it turns out (as i found out from that "secrets of the ghc inliner" paper), that case is exactly one of the ones that ghc's inliner depends on hindler-milner to make impossible, so it doesn't have to take that possibility into account (which e.g. a scheme inliner would)
18:01:23 <mmorrow> so it immediately falls into an infinite loop without the NOINLINE
18:01:38 <monochrom> aCiD2: In fact http://www.haskell.org/haskellwiki/Simple_Unix_tools is like that.
18:01:52 <aCiD2> oh nice :) thanks monochrom
18:02:02 <dolio> Aren't types nice?
18:02:56 * mmorrow (unsafeCoerce dolio) dolio
18:03:18 <pr> @djinn a -> b
18:03:19 <lambdabot> -- f cannot be realized.
18:03:21 <pr> :'-(
18:05:01 <dolio> Of course, then folks like mmorrow come along and ruin your carefully laid plans.
18:07:26 <mmorrow> @lambdabot slap dolio
18:07:27 <lambdabot> Unknown command, try @list
18:07:32 <mmorrow> @slap dolio
18:07:32 * lambdabot will count to five...
18:07:35 <dolio> Hah!
18:07:36 <SamB> @slap mmorrow
18:07:36 * lambdabot pushes mmorrow from his chair
18:07:41 <SamB> hooray!
18:07:49 <SamB> now I can get a look at that problem
18:07:58 <SamB> ... the one between the keyboard and the chair
18:08:01 <mmorrow> i was hoping for the one where lambdabot splits you into a million pieces, then reassembles you into two copies of dolio
18:08:12 <dolio> Heh.
18:08:26 <SamB> mmorrow: I think you're getting confused with the Axiom of Choice
18:08:30 <c_wraith> you can't do that without the AoC
18:08:31 <dolio> Is a million enough?
18:08:37 <dolio> You don't need uncountably many pieces?
18:08:38 <c_wraith> Which I still refuse to believe in. :)
18:08:41 <Makoryu> Hmm, anyone care to implement ed, sed, awk, and grep in Haskell?
18:08:47 <absz> dolio: I think you need 7
18:09:00 <SamB> also, last I heard that trick only worked on spheres!
18:09:03 <SamB> c_wraith: me either
18:09:45 <monochrom> @slab monochrom
18:09:45 * lambdabot decomposes monochrom into several parts using the Banach-Tarski theorem and reassembles them to get two copies of monochrom!
18:09:49 <monochrom> That one.
18:09:58 <c_wraith> slab?
18:10:08 <monochrom> See how I can get exactly what I want. :)
18:10:40 <SamB> c_wraith: misspelling of slap
18:11:10 <monochrom> Worship my pinpointing accuracy!
18:11:17 <SamB> lambdabot found slap to be within a sufficiently-small edit distance of slap, and not equilly close to something else, so went ahead and did it anyway
18:11:30 <SamB> huh
18:11:34 <pr> @slap lunabot
18:11:35 * lambdabot activates her slap-o-matic...
18:11:38 <SamB> I misspelled slab and equally
18:11:45 <SamB> @slam me
18:11:46 * lambdabot smashes a lamp on SamB's head
18:11:52 <SamB> wow
18:11:56 <monochrom> Hehehe you do get slammed.
18:12:08 <SamB> in retrospect, I'm surprised it didn't hit someone called "me"
18:12:18 <SamB> s/it/she/
18:12:22 <SamB> @slam me
18:12:22 * lambdabot places her fist firmly on SamB's jaw
18:12:25 <SamB> @slam me
18:12:25 * lambdabot will count to five...
18:12:26 <SamB> @slam me
18:12:27 * lambdabot smashes a lamp on SamB's head
18:12:28 <SamB> @slam me
18:12:28 * lambdabot submits SamB's email address to a dozen spam lists
18:12:30 <SamB> @slam me
18:12:30 * lambdabot jabs SamB with a C pointer
18:12:32 <SamB> @slam me
18:12:32 * lambdabot activates her slap-o-matic...
18:12:34 <SamB> @slam me
18:12:34 * lambdabot loves SamB, so no slapping
18:12:36 <SamB> @slam me
18:12:36 * lambdabot hits SamB with an assortment of kitchen utensils
18:12:37 <monochrom> Hahaha spam lists
18:12:39 <SamB> @slam me
18:12:39 * lambdabot smacks SamB about with a large trout
18:12:41 <SamB> @slam me
18:12:41 <lambdabot> *SMACK*, *SLAM*, take that SamB!
18:12:43 <Makoryu> _
18:12:44 <Makoryu> _
18:12:45 <Makoryu> _
18:12:45 <SamB> @slam me
18:12:45 * lambdabot hits SamB with a hammer, so they breaks into a thousand pieces
18:12:49 <SamB> @slam me
18:12:49 <lambdabot> I don't perform such side effects on command!
18:12:51 <SamB> @slam me
18:12:52 <lambdabot> I'd rather not; SamB looks rather dangerous.
18:12:54 <SamB> @slam me
18:12:54 * lambdabot smacks SamB about with a large trout
18:12:57 <SamB> @slam me
18:12:58 * lambdabot slaps SamB
18:12:59 <monochrom> OK you can play with it in pm.
18:13:08 <monochrom> Err I mean she!
18:13:09 <SamB> @localtime SamB
18:13:10 <lambdabot> Local time for SamB is Mon Aug 24 21:13:10
18:13:21 <SamB> what is this "PM" thing?
18:13:30 <monochrom> Hahahaha
18:13:39 <monochrom> Go play her private!
18:13:41 <monochrom> ly!
18:13:49 <EvilTerran> @spam #haskell
18:13:50 * lambdabot locks up #haskell in a Monad
18:16:26 <hackagebot> LslPlus 0.4.3 - An execution and testing framework for the Linden Scripting Language (LSL) (RobertGreayer)
18:17:19 <monochrom> Oh, Second Life thingy.
18:18:47 <monochrom> You can attach a script to a chair. The script can do http and email. So you can make a chair send emails or surf the web.
18:29:00 <duryodhan> hi .. I am a noob to haskell , read the learnyouahaskell guide, and can't see why data Server= Good | Bad  deriving (Show,Eq)
18:29:03 <duryodhan> fails
18:29:35 <jmcarthur> duryodhan: if you are trying that in ghci, it will fail
18:29:39 <jmcarthur> it must be in a source file
18:29:56 <jmcarthur> data declarations must
18:30:13 <duryodhan> yeah .. its in a ba.hs file
18:31:25 <duryodhan> uggh sorry my bad -- it was some line following that was causing problems
18:34:01 <enriq> hello... I remember I used something to download and install packages from hackage... but don't find it now...
18:34:12 <c_wraith> cabal?
18:34:46 <enriq> yes but... cabal instructions state to download by hand
18:35:21 <c_wraith> Well, it has to be installed before you can use it
18:35:48 <enriq> ghc-pkg has nothing to do with it?
18:35:58 <c_wraith> it doesn't download stuff
18:36:19 <c_wraith> It just manages what packages are registered with GHC
18:36:28 <enriq> ok so I install cabal by hand and then cabal the rest
18:36:34 <c_wraith> yes
18:36:35 <enriq> thanks
18:36:37 <copumpkin> damn, dafra's gone :P
18:36:41 <copumpkin> so much for my epic explanation
18:42:43 <duryodhan> Hi .. http://haskell.pastebin.com/d6dd01d3c , the last line (the map) is clearly wrong, but how should I write it ? again, noob to haskell , writing stuff based on all sorts of tutorials
18:43:43 <mmorrow> monochrom: omg, either the luckiest @slab evar or trickery
18:43:52 <monochrom> hehehe
18:46:24 <monochrom> duryodhan: mapM_ instead of map
18:46:42 <duryodhan> ohh ok
18:46:52 <arw> http://haskell.pastebin.com/m671dc16e
18:47:20 <duryodhan> monochrom: awesome! thanks
18:47:40 <ksf> can I pause a thread without looping over a lock?
18:47:58 <ksf> that is, tell the scheduler to stop giving it cycles, like ^Z ?
18:48:06 <shapr> @yow !
18:48:06 <lambdabot> Make me look like LINDA RONSTADT again!!
18:48:18 <monochrom> What is a lock?
18:48:27 <monochrom> Oh, I guess it's irrelevant.
18:48:30 <duryodhan> whats the difference between what arw said and what monochrom said ? which one's correct ?
18:48:35 <ksf> some thing you code up using TVars.
18:48:40 <monochrom> Both are correct.
18:49:09 <arw> duryodhan: just try to figure out the types of all the functions.
18:49:28 <arw> duryodhan: for example with :t in ghci or something like that.
18:49:57 <monochrom> Do a takeMVar to pause. To unpause, have some other thread do a putMVar.
18:50:11 <ksf> ...but that's exactly not what I want.
18:50:22 <arw> duryodhan: roughly speaking, using "print" makes a function impure and changes the type to something in the IO monad.
18:50:22 <monochrom> It won't spend CPU cycles.
18:50:49 <ksf> well yes but I can't just interrupt it anywhere.
18:50:55 <monochrom> If you know you want to pause for 1 second, Control.Concurrent.threadDelay 1000000
18:50:57 <ksf> ...or rather after the next yield.
18:51:00 <smarmy> duryodhan: mapping fetchResource over the list of resources produces a list of strings.  but that's all.  one would assume you want to do something with them, hence arw's modification to print them
18:51:25 <ksf> no the threads don't know whether or not the user would like to stop them.
18:52:02 <arw> duryodhan: using another 'show' (which is redundant btw) in fetchResource makes this function pure, meaning nothing is printed immediately when calling fetchResource (which would be an impure side-effect) but only when calling the print in 'startSession'.
18:52:26 <duryodhan> arw: ok .. so you are saying I should limit my use of print to the lowermost function , as I don't really use it in the upper one ?
18:52:54 <arw> duryodhan: yes. or you can use a 'monad aware map function' which is mapM.
18:52:56 <monochrom> Damn English.
18:53:06 <ksf> if you really, really want to output something inside a pure expression, use Debug.Trace
18:53:20 <monochrom> Do you want this? The user says "pause" through a UI, then you pause the thread.
18:53:28 <duryodhan> arw: ok!
18:53:47 <arw> duryodhan: the usual style preferred in haskell is to limit side-effects to the outermost function(s) if possible, yes.
18:53:53 <ksf> yes, but ideally stopping the missiles in mid-flight, having them haning in the air.
18:55:20 <arw> hm. haskell definitely needs an ACME.Missiles module.
18:55:22 <duryodhan> ohh ok
18:55:42 <ksf> ...that's why I'm asking. I'm very well aware of how to block on a lock.
18:56:23 <monochrom> The thread will have to be coded to peek an MVar regularly for instruction to pause. If there is no instruction, continue work; this has minimal runtime overhead. If there is instruction, do a takeMVar to pause; this has no runtime overhead.
18:56:55 <ksf> yes sure but I didn't implement launchMissiles.
18:57:08 <ksf> ...or the thing that makes them fly.
18:57:08 <enriq> ghc-pkg list shows Cabal-x.x.x installed, but where is the cabal executable?
18:57:16 <ksf> still I want to interrupt it, if possible.
18:57:39 <duryodhan> I'm also interested in looking at tools that help you formally verfiy haskell code, is there any thing other than p-logic ?
18:57:51 <dcoutts> enriq: The Cabal package provides a library. The cabal-install package provides the 'cabal' command line tool.
18:58:24 <monochrom> I think it is impossible.
18:58:34 <enriq> ah! thanks....
18:58:37 <ksf> well the os can do it.
18:58:56 <ksf> ...just ceasing to allocate cycles to a process.
19:00:11 <monochrom> GHC RTS is not the os yet.
19:00:30 <arw> well, if the thread had its own pid you could just do kill(pid, SIGSTOP);
19:00:37 <ksf> it's multitasking cooperatively, isn't it?
19:01:39 <arw> damn. 0400... n8 everyone.
19:01:40 <ksf> but then, as another thread is going to send the signal, it should be possible.
19:02:48 <monochrom> Perhaps I should not have said impossible. I should have said unimplemented.
19:03:28 <monochrom> I don't really want to invite a debate on what is possible if one were to rewrite GHC from scratch.
19:03:48 <ksf> so I can have a recipe and dream of cake, too.
19:05:29 <SamB_XP> that reminds me ... I really want to play Portal some time ...
19:05:50 <SamB_XP> but I don't have anything to play it on :-(
19:06:16 <monochrom> What is Portal? What is it played on?
19:06:32 <SamB_XP> @google Portal game
19:06:34 <lambdabot> http://en.wikipedia.org/wiki/Portal_(video_game)
19:06:34 <lambdabot> Title: Portal (video game) - Wikipedia, the free encyclopedia
19:07:51 <SamB_XP> a beefier PC than I've got, an Xbox 360, or a PS3
19:14:44 <zeno>     Could not find module `Control.Monad.Reader':
19:14:45 <zeno>       it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
19:14:48 <SamB_XP> what the heck ... SimCity is GPL3'd ?
19:17:03 <SamB_XP> ... and will ship with the OLPC!
19:17:04 <SamB_XP> cool!
19:17:18 <mike-burns> Wow, that's insanely awesome.
19:17:33 <monochrom> Is it SimCity classic?
19:17:35 <zeno> how do i uinstatll someing installed with cabal
19:17:36 <SamB_XP> http://en.wikipedia.org/wiki/Micropolis_%28video_game%29
19:17:52 <SamB_XP> monochrom: well, it's sure not the SNES version!
19:18:26 <SamB_XP> monochrom: that is to say ... have you heard of any *other* game for computers called just SimCity?
19:18:45 <ksf> well, transport tycoon is gpl, too.
19:18:45 <monochrom> No.
19:18:55 <ksf> in some sense, anyway.
19:19:18 <ksf> someone translated the assembly to c and gpl'ed the c.
19:21:36 <monochrom> What I have not heard of is usually irrelevant.
19:21:55 <ksf> zeno, better solution: a) use -package flags with ghc, or even better, b) use cabal
19:22:20 <ksf> ...which sets the flags automatically according to the dependencies you give.
19:22:42 <monochrom> Damn English. What I have not heard of is little indication of what is non-existent.
19:22:47 <ksf> to answer your question: you can't uninstall packages with cabal. but you can unregister or hide them with ghc-pkg
19:23:23 <ksf> monochrom, your absence of knowledge fills volumes?
19:23:36 <SamB_XP> monochrom: anyway, I just call that game SimCity
19:23:39 <Makoryu> You can always just nuke your ~/.cabal
19:23:42 <SamB_XP> usually
19:24:12 <SamB_XP> if I want to refer to the SNES game of the same name, I'll be explicit ;-)
19:24:16 <ksf> Makoryu, that won't stop ghc from trying to locate those packages, you have to nuke ~/.ghc, too.
19:24:26 <Makoryu> ksf: Hrm, okay
19:24:26 <monochrom> What I know is co-infinite. What I don't know is co-finite. These are easily proved and noticed.
19:27:08 <zeno> im starting from scratch, how do i rm everything cabal installed?
19:28:00 <Makoryu> zeno: rm -rf ~/.cabal ~/.ghc # Assuming you're on Unix of some sort and you didn't set these up in weird places
19:28:11 <zeno> Makoryu: thanks
19:28:25 <SamB_XP> also assuming your shell honours comments interactively
19:28:33 <SamB_XP> otherwise, take off the # and following ;-P
19:28:39 <mike-burns> And assuming rm is in your path.
19:28:48 <SamB_XP> mike-burns: mine doesn't!
19:28:57 <mike-burns> Sure, mine neither.
19:28:59 <SamB_XP> honour comments interactively, I mean
19:29:08 <SamB_XP> rm is generally in-PATH
19:29:11 <Makoryu> Yeah, zsh....
19:29:14 <ksf> and assuming your shell is smart enough to expand ~ to $HOME
19:30:02 <monochrom> Windows is smart enough to expand \ to /
19:30:16 <SamB_XP> I thought it was the other way 'round
19:30:42 <ksf> well, at some point it just had to, as there's no http:\\\
19:30:59 <SamB_XP> ksf: true!
19:32:21 <ksf> the fun thing is that you can actually create files having names forbidden on windows in ntfs.
19:32:46 <SamB_XP> !
19:32:54 <ksf> ...there's a POSIX name mode.
19:32:54 <SamB_XP> how?
19:32:58 <ksf> ntfs-3g uses it.
19:33:01 <SamB_XP> oh, right
19:33:06 <Makoryu> There have been some combinations of Unix and AFS (IIRC) that allowed names containing '/' to be created
19:33:16 <SamB_XP> for their evil Linux compat mode ;-P
19:33:37 <SamB_XP> Makoryu: what ... the ... heck?
19:34:38 <ksf> fopen and stuff don't take escaped paths, do they?
19:34:49 <Makoryu> SamB_XP: IIRC the only way it was possible was if you logged in from a Mac
19:35:11 <SamB_XP> okay ... and how does AFS store files ?
19:35:27 <ksf> distributed.
19:36:20 <Makoryu> SamB_XP: Sorry, I meant AFP, not AFS. AppleTalk file something
19:36:47 <Makoryu> It was once a viable alternative to stuff like NFS
19:38:08 <ksf> back in the times, there were people trying to convince me that netware was a viable alternative.
19:40:41 <SamB_XP> ksf: I tell you it isn't!
19:41:19 <ksf> it might be useful if all you have is DOS.
19:41:57 <ksf> but then, I'd rather smash my head repeatedly into a brick wall than suffering the agony of using more that dosbox.
19:42:32 <SamB_XP> my school uses netware for something, apparantly
19:42:50 <SamB_XP> but ... as far as I can tell, they just do it to annoy me!
19:43:31 <ksf> mmmh dosbox. reimplementing syndicate (with a pathfinder that deserves the name) would be a cool thing.
19:51:53 <enriq> hi. I did  cabal install --global X11 but ghc-pkg list does not show it... any idea?
19:56:27 <Woof> Twey!!!
19:59:10 <Saizan_> enriq: did the install end successfully?
20:03:00 <zeno> when trying to install ghc ./configure : checking for path to top of build tree... ./configure: line 1932: utils/pwd/pwd: cannot execute binary file
20:03:21 <zeno> configure: error: cannot determine current directory
20:06:33 <enriq> Saizan_, yes
20:06:58 <enriq> I guess there is something to do with su -c
20:07:18 <enriq> it ignored my ~/.cabal/config
20:08:43 <Twey> Woof?
20:09:00 <Woof> Aha, you're alive
20:09:01 <Woof> : D
20:09:47 <Woof> Komm dahin, Twey >: O
20:10:02 <Saizan_> enriq: ah, yeah, you want to use cabal install --root-cmd=sudo --global, instead
20:10:33 <enriq> ahhhh I see
20:10:34 <enriq> thanks
20:11:27 <Saizan_> zeno: there's something in ghc bug tracker about that, your kernel or glibc is too old, iirc
20:15:11 <Makoryu> Extraordinarily Bad Idea of the Week: Rewrite the GHC bug tracker in Happstack
20:16:39 <BMeph> Makoryu: Write it in Wagn, instead! ;p
20:17:15 <Saizan_> that's a judgement on happstack or just on wasted wheel reinvention?
20:17:30 <Makoryu> BMeph: Rewriting it at all is the "extraordinarily bad idea" part
20:17:49 <SamB_XP> yeah, you don't want to take on the goal "rewrite trac"
20:17:50 <SamB_XP> ever
20:18:30 <Trinithis> what to do...
20:18:56 <thetallguy> So, once a system becomes large and complex we should always stick with it and never start afresh with a new attempt?
20:19:24 <jfoutz> depends on the system.
20:19:38 <SamB_XP> thedonvaughn: well, it's better to start with a smaller goal than "rewrite trac", mostly
20:19:44 <SamB_XP> er. thetallguy
20:19:54 <SamB_XP> I've got to remember I can't do that here anymore ...
20:19:56 <thetallguy> jfoutz: really?  You believe there are some systems that should never be rewritten?
20:20:02 <SamB_XP> > 26^3
20:20:04 <lambdabot>   17576
20:20:14 <SamB_XP> thetallguy: it's not "never"
20:20:26 <SamB_XP> it's "would take too long to get anwhere on that goal"
20:20:30 <mike-burns> In a practical sense, there are some systems for which the re-write will be discarded due to intertia.
20:20:55 <mike-burns> Bug-compatibility is quite difficult.
20:20:56 <thetallguy> SamB_XP: Wanna bet someone said that to the trac developers about Bugzilla?
20:20:57 <Trinithis> Just write a haskell program to do all the rewrite work for you!
20:20:58 <SamB_XP> far, far more likely is that you'll get bored 1% of the way through
20:21:04 <shapr> mike-burns: hah
20:21:15 <SamB_XP> thetallguy: I really doubt they were trying to rewrite bugzilla
20:22:27 <thetallguy> SamB_XP: how about launchpad?
20:22:54 <SamB_XP> thetallguy: launchpad has many pieces
20:23:07 <thetallguy> SamB_XP: So?
20:23:09 <SamB_XP> they are not all a part of the same code base, as far as I know...
20:23:11 <jfoutz> thetallguy: so, if you're building something for money, total rewrites seem to be a really bad idea.
20:23:37 <jfoutz> thetallguy: if it's for fun, go nuts. if you're trying to put somebody out of business, go nuts.
20:24:20 <SamB_XP> thetallguy: especially if you're trying to put your gullible employer out of bussiness by being unproductive ;-p
20:24:25 <thetallguy> jfoutz: I'll let Bill Gates know.
20:24:38 <jfoutz> thetallguy: yeah. vista went well.
20:25:06 <thetallguy> jfoutz: you should look at the entire history
20:25:10 <jfoutz> thetallguy: got the new file system done. whole new rendering engine. really exeeded expectations. let him know for me.
20:25:26 <jfoutz> sorry. *snark* is uncalled for.
20:25:35 <SamB_XP> jfoutz: dude, that filesystem is NEVER done
20:25:35 <jfoutz> that was excessive.
20:25:53 <mike-burns> The fact that you can come up with an example of success doesn't mean that it's always a good idea.
20:25:55 <SamB_XP> it's like duke nukem never, or something
20:25:56 <thetallguy> jfoutz: hehe, I this snark is surely called for
20:26:37 <zeno> @hoogle join
20:26:38 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
20:26:38 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
20:26:38 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
20:26:46 <thetallguy> I just find that such simple statements are extremely imprecise and misleading.
20:27:47 <jfoutz> also, there are lots of systems that are highly optimized for their context. electronic vs. paper hospital records. it's not imposible to build an electronic system that's better in a lot of ways, but really suck in emergencies. i put an / in a box with a magic marker, vs. i wake the computer from suspend blah blah.
20:28:56 <thetallguy> Much more useful would be something like, ``Engineers who do not like to use a piece of software often under-estimate the effort it would take to replace on it by many orders of magnitude, and over-estimate their ability to improve upon it by the same amount.''
20:29:19 <mike-burns> Sure, but that's less of a conversation starter.
20:31:34 <thetallguy> mike-burns: I'm all for silence in the absence of content.
20:32:12 <jfoutz> thetallguy: well... more like i hate software X, but i'm not really the person who benifits from X. my suffering from using X is a side effect of a really big efficency for someone else.
20:33:07 <SamB_XP> thetallguy: so, we should feed the data to the computer at some more convenient time, somehow?
20:33:14 <jfoutz> thetallguy: or, more likely, X isn't perfect for me, or for you. but if it was perfect for me, it would be totally unusable for you, and the other way around.
20:34:02 <SamB_XP> jfoutz: yeah, that's because all we use X for is to give eachother mountains of work
20:34:27 <SamB_XP> so, if it was perfect for me, it would only allow me to give you work ;-)
20:34:27 <thetallguy> jfoutz: those seem like reasons to examine the usage specifications and come up with a new design
20:34:51 <thetallguy> SamB_XP: ;-)
20:35:21 <SamB_XP> or, more accurately speaking, X is nearly unusable for everyone
20:35:33 <SamB_XP> it really needs a standard widget toolkit!
20:35:41 <SamB_XP> which ... does ... not ... suck!
20:35:53 <thetallguy> jfoutz: another field where people have trouble convincing clients of the real cost of things
20:35:56 <SamB_XP> also, it needs another protocol rewrite ;-)
20:36:18 <thetallguy> SamB_XP: ;-)
20:36:18 <dolio> Like Motif. Motif rules.
20:36:31 <thetallguy> And has ruled for twenty years
20:36:40 <SamB_XP> dolio: is that free yet?
20:36:45 <dolio> No idea.
20:36:54 <thetallguy> taking up space in a small corner of millions of machines
20:36:54 <dolio> I don't really know much about it, other than that it's ugly.
20:38:09 <thetallguy> Has anyone tried the graphtype app released to hackage today?
20:38:26 <thetallguy> All my examples made it choke.
20:50:23 <zeno> is there an easy way to get a ranom ascii string (not number)
20:51:02 <dolio> @instances-importing System.Random Random
20:51:02 <lambdabot> Bool, Char, Double, Float, Int, Integer
20:51:24 <dolio> @type randomRs ('\0','\127')
20:51:25 <lambdabot> forall g. (RandomGen g) => g -> [Char]
20:52:07 <zeno> dolio: thanks
20:52:21 <dolio> That gets you an infinite list, so you'll need to trim it, probably.
20:53:07 <zeno> @hoogle randomRs
20:53:08 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
20:53:10 <SamB_XP> and ... er ... well, it will contain a bunch of really odd control characters ...
20:59:21 <Stinger> so yeah RWH seemed to be down the past day or so. Then I ordered it from amazon and it suddenly reappeared
20:59:25 <zeno> how should i go about getting my current ip address in haskell? parse it out of whatismyip.org?
20:59:33 <Stinger> coincidence? I think not
20:59:40 <SamB_XP> Stinger: I think yes
20:59:57 <SamB_XP> well, not a coincidence that you bought it after the site went down ;-P
21:00:29 <Stinger> heh no I've been meaning to get it for a while
21:00:51 <Stinger> still it's obviously a conspiracy
21:01:11 <copumpkin> zeno: depends how you define your ip address :P
21:02:29 <zeno> copumpkin: well how whatismyip.org defines it.  what library is good for simply grabbing that?
21:03:01 <SamB_XP> zeno: you want (a) world-visible IP address, or an OS-level address, or ...
21:03:16 <zeno> world visible
21:03:40 <SamB_XP> what for do you want it?
21:04:50 <zeno> so the app can add abusive ip addresses to a list, blocking them from connecting
21:05:16 <copumpkin> hmm
21:05:17 <erikc> you would get it from the socket library when you accept the connection
21:05:21 * copumpkin doesn't see it
21:05:47 * dolio has SamB's back.
21:06:11 <sjanssen> zeno: in that case you don't want your IP address, you want somebody else's, right?
21:06:30 <sjanssen> zeno: you can't really trust an abusive client to tell the truth about itself, can you?
21:07:23 <SamB_XP> besides, it's easier to just get the IP address of the cleint than to ask the client for it ;-P
21:07:33 <zeno> true i guess they could decompile and alter that
21:07:41 <copumpkin> zeno: not even tht
21:07:48 <copumpkin> just figure out your protocol and make a different client
21:07:56 <zeno> its encrypted
21:08:02 <copumpkin> that won't stop anyone
21:08:03 <copumpkin> well
21:08:12 <copumpkin> it might stop most people
21:08:18 <copumpkin> but anyone determined could easily get around it
21:08:28 <erikc> but that dude in the basement with the techno music and the trenchcoat has it in for you!
21:08:35 <copumpkin> that'd be me
21:08:38 <copumpkin> :(
21:08:45 <zeno> lol
21:08:45 <SamB_XP> that's a bit harder to get around, yes
21:08:50 <SamB_XP> he might TURN OFF THE MUSIC!
21:08:53 <copumpkin> zeno: what kind of encryption?
21:09:22 <sjanssen> zeno: it's especially easy to get around if you use an external service like whatismyip.org
21:14:45 <monochrom> If you plan to have client-side code find out and report client-side IP, the most likely scenerio is that the client will report something like 192.168.1.43. Not because someone at the client side hacks and lies. Just because "I hired the geek next door to set up wifi for me!"
21:15:15 <zeno> copumpkin: rsa.  ya ill just alter it so that the server logs it when they connect better that way
21:15:32 <copumpkin> zeno: just out of curiosity, are you using openssl for ssl?
21:15:38 <copumpkin> or doing homebrew crypto?
21:17:09 <zeno> ls
21:17:28 <zeno> oops lol.  homebrew
21:19:16 <hackagebot> maid 2009.8.25 - A simple static web server (JinjingWang)
21:20:46 <copumpkin> zeno: remember what people say about homebrew crypto ;)
21:21:22 <monochrom> They say "you should do it because no one can imagine it"
21:21:29 <copumpkin> lol
21:21:43 <SamB_XP> or, worse, WEP!
21:21:45 <SamB_XP> right?
21:22:08 <copumpkin> well in this case, he's a little harder to sniff because he is using homebrew crypto (because I have a cute dtrace script that will dump any ssl a given program reads or writes)
21:22:33 <copumpkin> but in general, don't do homebrew crypto is the idea :P
21:22:50 <SamB_XP> copumpkin: well, is it worse than using crpyto that ... doesn't?
21:23:06 <copumpkin> doesn't what?
21:23:19 <erikc> doesnt cryptify
21:23:21 <SamB_XP> well, doesn't actually protect anything
21:23:26 <monochrom> Don't do crypto. Information wants to be free.
21:23:31 <copumpkin> :)
21:23:39 <SamB_XP> monochrom: it's useful for signing things!
21:23:46 <copumpkin> SamB_XP: depends if said crypto makes people feel safer than they should and do things they otherwise might not do
21:24:39 <SamB_XP> I mean, using non-homebrew crypto that has more holes than swiss cheese ... is it worse than using some homebrew crypto?
21:25:11 <copumpkin> oh well the assumption is generally that you'd use a well-known crypto library that isn't full of holes
21:25:34 <idnar> SamB_XP: there's only a handful of people who are capable of constructing homebrew crypto that doesn't have more holes than swiss cheese, though
21:25:57 <SamB_XP> how about we use a 3-ROT13?
21:26:01 <idnar> or rather, there are only a handful of people who can construct crypto that isn't full of holes, and odds are that you're not one of them
21:26:34 <idnar> the crypto situation is a bit dismal; most of the libraries are either too low, or poorly-constructed
21:26:41 <idnar> er, too low level
21:26:42 <monochrom> I use homebrew crypto that has less hole than alcohol in homebrew wine.
21:26:45 <SamB_XP> yeah, I dunno if I'm even qualified to design a protocol using crypto
21:26:51 <monochrom> err more hole
21:26:57 <copumpkin> idnar: yeah :/
21:27:17 <copumpkin> or have crap documentation, like openssl/libcrypto
21:28:18 <jfoutz> i always think of this when i think of cryptography http://xkcd.com/538/
21:28:52 <lpsmith> anybody have an idea about how to avoid memoizing constant applicative forms?
21:29:11 <monochrom> hehe
21:29:52 <monochrom> I make them functions of 1 parameter.
21:29:56 <lpsmith> fibs () = fibs'  where fibs' = zipWith (+) fibs' (tail fibs')     <-- used to work,  but no longer
21:30:12 <monochrom> darts
21:30:21 <lpsmith> the fibs' gets memo-ed across function calls
21:32:40 <aavogt> lpsmith: is it the same when you use fix?
21:32:49 <zeno> why shouldnt you use homebrew crypto?
21:33:40 <lpsmith> probably,  lemme try though
21:34:00 <Pseudonym> zeno: The second biggest security hole in any cryptosystem is the protocol.
21:34:13 <Pseudonym> So don't design one yourself if there's already one out there.
21:34:28 <Pseudonym> That's been designed by people who know what they're doing, that is.
21:34:50 <idnar> the biggest hole is the combination of side-channel attacks that the implementation is vulnerable to
21:34:59 <Pseudonym> The biggest hole is the people.
21:35:14 <monochrom> The biggest void is the people, too.
21:35:25 * aavogt wonders why people don't apply the same arguments to any technical activity
21:35:45 <SamB_XP> aavogt: hmm?
21:35:45 <aavogt> more frequently that is
21:36:07 <monochrom> I do. The biggest problem is the people, always.
21:36:34 <SamB_XP> bigger than the halting problem?
21:36:45 <aavogt> SamB_XP: ex. you shouldn't program xyz since its been done in a similar form over there, by some real experts
21:36:47 <Pseudonym> The halting problem is almost never a problem.
21:37:08 <SamB_XP> Pseudonym: but not quite never!
21:37:31 <copumpkin> zeno: implementing crypto can be an interesting exercise, but there are so many things to keep in mind that you almost never want to use something you wrote yourself in production systems
21:37:39 <monochrom> The halting problem is shadowed by user requests of solving the halting problem.
21:37:49 <copumpkin> use TLS as a transport if at all possible, for example
21:38:15 <SamB_XP> copumpkin: or ssh
21:38:31 <Pseudonym> SamB_XP: Right, not quite never.
21:38:55 <monochrom> Problems in error messages, error handling, etc. are largely due to people who create errors and then want your program to be "graceful".
21:39:23 <lpsmith> aavogt:  no it doesn't.   Good suggestion! :-)
21:40:00 <monochrom> I guess "let" is still different from "where".
21:40:18 <lpsmith> hmm... I'm not sure that's it
21:40:21 <lpsmith> lemme try
21:40:32 <monochrom> since "fix" is based on "let".
21:45:18 <lpsmith> arg
21:45:22 <lpsmith> I was completely wrong
21:45:31 <lpsmith> that example I gave with fib works
21:45:35 <lpsmith> I just assumed it didn't
21:45:42 <monochrom> haha ok
21:45:48 <lpsmith> because I'm getting something memoized that looks like it
21:50:23 <hackagebot> cabal2doap 0.2 - Cabal to Description-of-a-Project (DOAP) (GregHeartsfield)
22:00:53 <zeno> on cabal install i keep getting ec: 14: /usr/local/lib/ghc-6.10.1/hsc2hs: not found, buti  have 6.10.2
22:06:54 <lpsmith> sigh... I was right
22:07:12 <lpsmith> Except that it's not the () that was preventing memoization with the fib example
22:08:00 <lpsmith> it was the polymorphic type.  Duh.
22:08:14 <monochrom> Oh! :)
22:08:57 <lpsmith> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3415
22:09:15 <lpsmith> That's a part of what I'm currently playing with, if anybody is interested.  :-)
22:10:01 <monochrom> oleg :)
22:10:58 <Saizan_> zeno: cabal install defaults to the ghc it finds in $PATH
22:11:34 <Saizan_> zeno: you can use --with-ghc=ghc-6.10.2 to make it looks for the ghc-6.10.2 executable
22:32:31 <guy_> hi, i have a newbie question: i'm trying to write a "let" expression where the body of the let is on the next line. like "let foo x =<newline><indent>x + 10<newline>in foo 5", but i get a parse error. what's the right syntax to do this?
22:37:06 <mxc> you could try let foo x = \n\tx+10 in\nfoo 5
22:37:28 <mxc> or you could try let foo x = \n\tx+10\n\tin\nfoo 5
22:37:43 <mxc> (too lazy to write the markup how you did)
22:37:45 <aavogt> guy_: <indent> should bring the 'x+10' at least as far right as the '=' above it
22:39:01 <aavogt> any less, and it seems to be interpreted as a second name being bound in the let
22:39:10 <lpsmith> yup, sounds like a whitespace bug :-)
22:39:12 <tingi> To check that you can make a zero vector, you basically need to check that your collection of vectors spans an angle of 180 degrees or more ? why is this fact true.
22:39:20 <guy_> aavogt: what if the '=' is really far right? i'd like to indent as little as possible
22:39:56 <guy_> mxc: neither works for me
22:40:11 <lpsmith> tingi:   Not sure about the context,   are you talking about deciding whether or not a set of vectors is linearly dependent or independent?
22:40:34 <mxc> guy_ could be explicit and use braces
22:40:48 <mxc> actually, no, i take that back
22:40:50 <aavogt> guy_: you can put a newline and a bit of space before the 'let'
22:40:51 <tingi> lpsmith, yes to make a vector 0 in 2D plane
22:41:23 <aavogt> ... unless the surrounding expression also depends on layout
22:41:47 <lpsmith> well,  three vectors are going to be linearly dependent unless all three of them are parallel to each other
22:41:54 <guy_> aavogt: i didn't follow that. so "<spaces>let foo x =<newline>..." ?
22:42:06 <lpsmith> err
22:42:15 <lpsmith> nix that,  3 vectors are always linear dependent
22:42:23 <aavogt> @paste the larger context?
22:42:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:42:29 <lpsmith> 2 vectors are linearly *independent* unless they are parallel to each other
22:42:52 <tingi> lpsmith, but why do they have to span 180 ?
22:42:57 <tingi> or more
22:43:00 <lpsmith> I'm not sure what you mean?
22:43:41 <lpsmith> like,   <1,2>  and <2,4> are dependent
22:43:48 <aavogt> guy_: I meant like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8548#a8548
22:43:59 <lpsmith> because -2 * <1,2> + <2,4>  == <0,0>
22:44:19 <lpsmith> specifically, what does "span 180" mean?   I'm not familiar with that term
22:45:10 <guy_> aavogt: what i actually have is more like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8548#a8549
22:45:37 <guy_> aavogt: so the '=' in the let is very far to the right
22:45:51 <guy_> aavogt: it would be a pain to have to indent the whole let body that much
22:46:19 <tingi> lpsmith, i've X1*c1 + X2*c2 + ...Xn*cn = 0 , X1*d1 + X2+d2+..Xn*dn=0, where ci,di are integers, now how do i see if i can make atleast one rational in {X1,X2..Xn (not all zero) } such that equation is satisfied
22:47:16 <lpsmith> and X1 and X2 are two dimensional vectors?   Or are they arbitrary dimensional?
22:47:41 <lpsmith> and shouldn't ci and di be at least rationals, not integers?
22:48:10 <lpsmith> tingi:  check out gaussian elimination
22:48:17 <aavogt> guy_: ghc likes this version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8548#a8550
22:48:37 <tingi> lpsmith, ok
22:48:53 <tingi> lpsmith, To check that you can make a zero vector, you basically need to check that your collection of vectors spans an angle of 180 degrees or more, i.e. there doesn't exist a hyperplane w*x=0 through the origin ("*" is the dot product of vectors here), such that all the given vectors lie strictly to one side of it. I didn't understand this statement
22:49:01 <guy_> aavogt: ah.. so i guess it has to be indented more than 'f'
22:50:35 <lpsmith> tingi:  where is that from?
22:51:11 <aavogt> yeah, the layout rule(s) give you quite a bit of freedom when arranging code
22:51:24 <tingi> lpsmith, http://online-judge.uva.es/board/viewtopic.php?f=9&t=2295&sid=2f9d3405adcc02cf05d189a8c80b5833&start=30
22:51:26 <lpsmith> I really don't think that's true unless you aren't allowed to multiply vectors by negative numbers
22:51:34 <smarmy> tingi: that statement seems suspect as a condition for independence
22:51:51 <smarmy> unless i'm misinterpreting it
22:52:32 <lpsmith> tingi:  do you have a link to the original problem?
22:52:57 <tingi> lpsmith, http://online-judge.uva.es/p/v100/10089.html
22:53:22 <tingi> lpsmith, i know it could be approached by simplex algo but want to understand the geometric version
22:54:39 <hydo> Do any of you happen to know of any documentation or projects that release haskell programs that don't require a ghc runtime?  As in, they don't assume that anything is installed?  I'm using the leksah windows binary as a template for windows, but I'm not sure how to do it for *nix installs.
22:55:47 <hydo> I'm assuming it's a shell script that sets the correct env variables for lib paths, and then executes the real binary, but I figured I'd ask here first.  Sadly, I can't seem to coerce a static binary out of ghc/gcc.
22:57:50 <mauke> er, is there a way to get a separate ghc runtime?
22:57:59 <mauke> I thought it was always built into the program
22:58:18 <hydo> mauke: Yea, bad wording on my part.  I'm almost certain you are correct.
22:59:28 <lpsmith> tingi:  are you familiar with the identity   |a| * |b| * cos (theta) =  a `dot` b
22:59:38 <tingi> lpsmith, yes
23:00:24 <lpsmith> Ok,  well,  honestly I'm not seeing the reduction to 2-D space,  and I should go to bed now.  Sorry!
23:00:37 <lpsmith> tingi:  best of luck with the problem.  :-)
23:00:44 <quicksilver> hydo: on all the platforms I've played with, the most you get a dynamic link to is gmp
23:00:55 <quicksilver> hydo: everything else (in particular, the whole GHC runtime) is static
23:01:06 <quicksilver> hydo: (of course if you depend on other cabal packages which are dya
23:01:19 <quicksilver> nmically linked to C libraries like opengl, you get that too)
23:15:06 <Trinithis> tingi:what exactly is your problem? Seeing if vectors in R2 are lin indep?
23:15:55 <tingi> Trinithis, "To check that you can make a zero vector, you basically need to check that your collection of vectors spans an angle of 180 degrees or more, i.e. there doesn't exist a hyperplane w*x=0 through the origin ("*" is the dot product of vectors here), such that all the given vectors lie strictly to one side of it". I didn't understand this statement
23:16:28 <mlesniak> How do I get ghc HEAD (pre-6.12)? Is this the same as version 6.11.20090824?
23:16:58 <Trinithis> are you just working with the real plane?
23:17:05 <tingi> Trinithis, yes
23:18:14 <Trinithis> I disagree with that statement
23:18:35 <tingi> Trinithis, there is an algorithm proof here, i'm trying to understand it http://online-judge.uva.es/board/viewtopic.php?f=9&t=2295&sid=09e2254675c10968cfba0de7d661209a&start=15#p102997
23:18:36 <Trinithis> 180+ could be anything, even 360 == 0 degrees
23:19:01 <Trinithis> also, given the 0 vector, i dont know if an angle makes sense
23:21:34 <Trinithis> I would just use a matrix to solve this problem (but I might be missing the point)
23:22:01 <tingi> Trinithis, i was understanding the geometric version. i know simplex can be used to solve this problem
23:22:31 <copumpkin> mlesniak: 6.12 doesn't exist yet
23:22:40 <tingi> Trinithis, how will you use an matrix ?
23:23:02 <tingi> other than simplex/LP algorithm
23:23:06 <copumpkin> mlesniak: but yeah, just grab the latest from darcs
23:23:10 <opqdonut> tingi: if you have a bunch of vectors that (in the plane to keep it simple) span an angle of under 180deg, then the vectors have one "common" component
23:23:15 <Trinithis> rows = system of equations and do reduced row echelon
23:23:21 <opqdonut> which you cannot eliminate solely by adding them together
23:23:48 <Trinithis> dang, I left my linear algebra book at home :(
23:24:18 <opqdonut> tingi: what was the original problem btw?
23:24:40 <tingi> Trinithis, something like gaussian elimination ?
23:24:51 <tingi> Trinithis, won't that be O(n^3)
23:25:30 <opqdonut> gah
23:25:40 <opqdonut> if we just wanted to know whether the vectors are non-independent
23:25:53 <tingi> opqdonut, i'm trying to understand what you wrote
23:25:57 <opqdonut> (i.e. sum[i] c_i*v_i = 0 for some real c_i)
23:26:06 <opqdonut> then we just need to take the determinant of the matrix
23:26:19 <opqdonut> it'll be non-0 exactly when the vectors are independent
23:26:32 <opqdonut> but it seems the guys on that board are discussing something else
23:26:42 <opqdonut> i'm still trying to find the original problem
23:26:46 <opqdonut> http://icpcres.ecs.baylor.edu/onlinejudge/ is not responding
23:26:46 <tingi> opqdonut, it needs to be rational
23:26:52 <tingi> http://online-judge.uva.es/p/v100/10089.html
23:26:55 <Trinithis> heh, forgot about its complexity
23:28:03 <tingi> opqdonut, just replace http://icpcres.ecs.baylor.edu/onlinejudge/ with http://uva.onlinejudge.org/ exactly and it will work
23:28:04 <opqdonut> but yeah, simple linear algebra won't work for the rational case
23:28:15 <opqdonut> yeah, got it
23:29:10 <opqdonut> and yeah
23:29:21 <opqdonut> now that i think about it that angle explanation doesn't make sense
23:29:30 <tingi> opqdonut,  why is that ?
23:29:58 <opqdonut> think (5,4,6) (4,5,6)
23:30:04 <opqdonut> those span a very tiny angle
23:30:20 <opqdonut> er sorry, (4,6,5) (6,4,5)
23:30:28 <opqdonut> but sum them and get 10*(1,1,1)
23:30:46 <tingi> so we reduce them to  (-1,1) and (1,-1) , we have a linear combination X,Y=1,1
23:31:20 <opqdonut> hmm, after reducing they do span a greater angle tho
23:31:35 <tingi> opqdonut, can you tell me that 180 part ?
23:31:36 <opqdonut> well anyway, i would approach this program as a diophantine equation
23:32:40 <opqdonut> oh okay, i just understood the reduction
23:32:45 <mlesniak> copumpkin, Ok, Thanks
23:33:10 <opqdonut> but yeah
23:33:12 <opqdonut> ok
23:33:40 <opqdonut> so, if we have vectors in the plane that span under 180deg, they have a "common direction", all of them point a bit into some (same direction)
23:33:55 <opqdonut> so no matter how you add them together, that component will increase
23:34:01 <opqdonut> you can't get back to 0
23:34:18 <tingi> opqdonut, yes that makes sense
23:35:08 <tingi> ie either x component or y component increases
23:35:10 <tingi> or both
23:35:25 <opqdonut> yeah kinda
23:35:33 <opqdonut> yeah, i guess that works too
23:35:46 <opqdonut> no
23:36:00 <opqdonut> but that will be the case if you apply a coordinate transformation first
23:36:16 <opqdonut> ... and the guy you linked to omits the proof that 0 is always possible when the span is >180deg...
23:36:44 <opqdonut> but it's pretty believable as all the vectors have integer components
23:37:08 <tingi> opqdonut, it needn't be ? 2 vectors can cancel each other and 3rd might just be result
23:37:29 <opqdonut> huh?
23:38:55 <tingi> opqdonut, if the angle between 1 and 2 is 180 degrees and 3 and 1 is 90 degrees
23:39:37 <opqdonut> but k*v_1+j*v_2=0 is a valid solution
23:39:55 <tingi> oh yeah
23:41:33 <tingi> opqdonut, if we can find a closed polygon , then we have an answer right ?
23:41:43 <opqdonut> tingi: sure
23:42:36 <tingi> opqdonut, so it says that atleast one of the pair should have more than 180 degrees right ?
23:42:40 <opqdonut> ah, i think i got it.
23:43:02 <opqdonut> once you have vectors with positive and negative x coordinates and positive and negative y coordinates
23:43:11 <opqdonut> it's easy to produce (0,k) and (j,0)
23:43:22 <opqdonut> which can be used to produce (jk,jk)
23:44:29 <fffej> I'm trying to use Graphics.Pgm (from Hackage) and struggling with the basics - can anyone give me an example of how to convert a list of pixel values into an IArray?
23:44:38 <tingi> opqdonut, but it needn't lie on x axis or y-axis
23:45:02 <opqdonut> what?
23:45:23 <tingi> opqdonut, you said, once you have vectors with +ve and -nve x , y co-ordinates
23:45:35 <opqdonut> gah
23:46:00 <opqdonut> let's say (a,b) (-c,d) (e,-f) with a,b,c,d,e>0
23:46:18 <tingi> ok ,
23:46:34 <opqdonut> then c*(a,b) + a*(-c,d) = (0,something)
23:46:51 <opqdonut> a similar sum for the last two vectors gives us (somethingelse,0)
23:46:52 <tingi> Yes
23:47:14 <opqdonut> somethingelse*(0,something) + something*(somethingelse,0) = (same,same)
23:47:31 <opqdonut> ah, sorry, not 0
23:47:43 <opqdonut> gah, nevermind
23:48:19 <tingi> opqdonut, how do we know such (a,b) (-c,d) (e,f) exists ?
23:48:44 <zeno> on cabal install i keep getting ec: 14: /usr/local/lib/ghc-6.10.1/hsc2hs: not found, buti  have 6.10.2
23:51:59 <hydo> quicksilver: Heh, yep!  Now that I'm back from messing with it I see your message and can confirm what you said.  It was effortless to make an almost static bin for linux.  The last how-am-i-gonna-do-this is down.  Now time to sweat and nitpick the hell out of the code before release.
23:53:11 <tingi> opqdonut,  you there
23:53:41 <opqdonut> tingi: yeah
23:53:54 <tingi> opqdonut, how can we know such points exist ?
23:54:03 <opqdonut> because the angle is over 180
23:54:12 <opqdonut> think about it for a while
23:56:22 <tingi> opqdonut, but it could 2 points in 1st -cordinate (ie angle 10' , 20' from axis and 3rd point 250 degrees )
23:57:43 <copumpkin> all this talk of degrees makes me feel that you're going about this wrong
23:58:06 <copumpkin> although I can't remember what you're trying to do :)
