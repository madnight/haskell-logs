00:02:40 <path[l]> one more question.Nested types are shown with brackets? so is this a valid type signature -> M.Map Char (S.Set Char)
00:02:54 <Saizan_> yes
00:03:28 <Saizan_> the parentheses work like in expressions
00:04:18 <path[l]> aha
00:04:47 <ski> "A pattern-matcher for miniKanren -or- How to get into trouble with CPS macros" sounds fun
00:07:53 <zong_sharo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8419#a8419 <- GADTs help needed
00:08:27 <zong_sharo> i got '''Could not deduce (Show a1) from the context (a ~ (a1, b))''', but cannot understand why
00:09:04 <zong_sharo> can anybody explain why this happens or give a link to some good explanation?
00:09:31 <path[l]> is there a shortcut qualified name for Prelude? to deal with ambuguous references?
00:09:33 <ski> zong_sharo : from an `Show (a,b)' instance, how do you extract `Show a' and `Show b' instances ?
00:09:36 <path[l]> like P or something
00:09:39 <ski> that's the problem
00:10:04 <Saizan_> path[l]: you can "import Prelude as P"
00:10:06 <zong_sharo> ski: instance (Show a, Show b) => Show (a, b)
00:10:11 <path[l]> ah ok
00:10:22 <zong_sharo> ski: this is not enough?
00:10:30 <path[l]> would you know if Prelude.map is the same as List.map?
00:10:40 <Saizan_> zong_sharo: that only says you how to get Show (a,b) from Show a and Show b, you'd need the inverse here
00:10:41 <ski> zong_sharo : yes, you can go from `(Show a,Show b)' to `Show (a,b)' .. it was the other direction that was needed here, though
00:10:57 <Saizan_> path[l]: it is
00:11:06 <path[l]> cool :)
00:11:41 <zong_sharo> i dont wanna add Show to the context of B
00:11:49 <ski> zong_sharo : simplifying somewhat, an `Show (a,b)' instance is a function of type `(a,b) -> String' .. how do you extract functions `a -> String' and `b -> String' from this ?
00:13:01 <ski> (actually, it'd be enough to add a `Show' constraint to `A')
00:13:49 <zong_sharo> mm
00:13:51 <zong_sharo> other ways?
00:14:09 <ski> hm, i remember seeing a similar issue to this earlier. but i don't recall if there was any solution or work-around suggested
00:14:17 <zong_sharo> i don't wanna restrict F's constructors in any way
00:15:09 <Saizan_> mh, you could write two instances maybe
00:16:14 <zong_sharo> still not shure i got it
00:16:33 <zong_sharo> show gives me Show a requirement, B's gives forall a b. (a1 ~ (a, b))
00:17:03 <zong_sharo> so, if Show a1, then it must be Show a, Show b => (a1 ~ (a, b))
00:17:06 <zong_sharo> why not?
00:17:13 <ski> zong_sharo : no, you have a `Show a1', i.e. a `Show (a,b)' constraint there
00:17:18 <ski> no `Show a' constraint
00:17:46 <zong_sharo> huh
00:18:08 <zong_sharo> looks little weird
00:18:17 <ski>   show :: forall a. Show a => F a -> String
00:18:23 <ski>   show (B a b) = "B (" ++ show a ++ ") (" ++ show b ++ ")"
00:18:53 <ski> if the input matches `B a b', then we know the `a' in the type is really `(a,b)' (for a fresh `a' and `b')
00:18:55 <zong_sharo> can you recommend any good paper about gadts, without digging in system f?
00:18:57 <ski> so the type then is
00:19:07 <ski>   show :: forall a b. Show (a,b) => F (a,b) -> String
00:19:31 <ski> so you've got a `Show (a,b)' instance, but what you need is `Show a' and `Show b' instances
00:19:35 <path[l]> am I right in understanding that concatMap is foldr (++) ?
00:19:47 <Saizan_> no
00:19:52 <ski> @type foldr (++)
00:19:55 <lambdabot> forall a. [a] -> [[a]] -> [a]
00:19:56 <path[l]> errr no I mean accumlR (++)
00:20:06 <ski> @type accumlR (++)
00:20:08 <lambdabot> Not in scope: `accumlR'
00:20:10 <path[l]> mapAccumlR
00:20:23 <path[l]> @type mapAccumlR (++)
00:20:24 <lambdabot> Not in scope: `mapAccumlR'
00:20:37 <Saizan_>  @type mapAccumR (++)
00:20:40 <Saizan_> @type mapAccumR (++)
00:20:41 <lambdabot>     Couldn't match expected type `([a], y)' against inferred type `[a]'
00:20:41 <lambdabot>     In the first argument of `mapAccumR', namely `(++)'
00:20:41 <lambdabot>     In the expression: mapAccumR (++)
00:20:45 <path[l]> ah damn
00:21:03 <Saizan_> concatMap f = concat . map f
00:21:21 <Saizan_> concat = foldr (++) []
00:21:21 <ski> @type \f -> foldr ((++) . f) []
00:21:23 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
00:21:57 <path[l]> hmm
00:22:09 <ski> .. the obvious counter-example to a solution is assuming there is an `instance Show (Int,Bool) where show = const "foo"' .. but that's overlapping-instances
00:22:30 <zong_sharo> Saizan_: two instances works
00:22:38 <ski> two instances, how ?
00:22:46 <zong_sharo> FlexibleInstances, IncoherentInstances
00:23:03 <path[l]> I wanna do a map f, but the result of each mapping is a set. So instead of concatMap I need like a unionMap. Is mapAccumR the best option? or should I be trying union.map ?
00:23:09 <ski> oh
00:23:24 <ski> of course
00:23:27 <zong_sharo> ski: updated paste
00:23:48 <zong_sharo> slightly evil, but works
00:24:02 <ski> zong_sharo : yes, i was just thinking that
00:24:06 <ski> it's evil
00:24:38 <ski> (the `A' constructor does the job of overlapping instances)
00:25:14 <dibblego> path[l], fmap perhaps
00:25:23 <ski> path[l] : i suspect you don't want `mapAccumR' at all
00:25:29 <zong_sharo> ski: so, can you reccomend some papers, in some cases (like this one) i have no idea why typechecker blames me
00:25:43 * ski has read zero papers about GADTs
00:26:02 <zong_sharo> okay, maybe not gadts papers
00:26:05 <ski> the problem is evident, though
00:26:08 <path[l]> hmm ok, let me read up fmap. I thought mapAccumR just maps every element and allows me to merge them as I go, but ok
00:26:36 <ski> path[l] : do you want `(a -> Set b) -> (Set a -> Set b)' ?
00:26:42 <zong_sharo> it was evident to you, but not to me
00:27:01 <path[l]> one sec
00:27:08 <zong_sharo> obviously, i need to read something
00:27:13 <ski> zong_sharo : but you understand it, now ?
00:27:24 <zong_sharo> but, i'm not shure what exactly
00:27:53 <copumpkin> zong_sharo: or just think deeper about the problem :)
00:27:56 <zong_sharo> ski: seems like this
00:28:05 <ski> (and yes, sorry, i should have said "evident to me")
00:29:01 <Twey> IncoherentInstances sounds rather dangerous :Ã¾
00:29:02 <zong_sharo> copumpkin: maybe i'm lacking some knowlege for more deeper thinking about this kinds of problems
00:30:14 <copumpkin> zong_sharo: well just realizing that just because you have instance (Show a, Show b) => Show (a, b) doesn't imply that if you have Show (a, b) you have Show a, Show b
00:30:23 <zong_sharo> but, i'm not shure what should i read to fill this kind of gap
00:30:53 <Saizan_> zong_sharo: see mine here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8419#a8421 it doesn't need IncoherentInstances if you use it on monomorphic terms
00:31:01 <copumpkin> http://en.wikipedia.org/wiki/Affirming_the_consequent
00:31:17 <copumpkin> not sure if that's technically correct
00:32:22 <ski> copumpkin : i think it is
00:32:48 <zong_sharo> Saizan_: thx
00:33:16 <copumpkin> zong_sharo: do you see how the wikipedia page is relevant?
00:33:45 <path[l]> I cant find fmap, is it a part of List?
00:33:51 <copumpkin> path[l]: Functor
00:33:52 <ski> it might be nice if one could say `instance (Show a,Show b) <=> Show (a,b) where ...'
00:33:59 <ski> @index fmap
00:34:00 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
00:34:21 <path[l]> huh ok... I havent understood those yet
00:34:24 <path[l]> :t fmap
00:34:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:34:37 <ski> it's in `Prelude'
00:34:43 <path[l]> ah
00:35:07 <zong_sharo> copumpkin: yeah, but i mostly mean lack of some formal knowlege of haskell's type infference mechanics
00:36:08 <copumpkin> you could read TAPL
00:36:08 <ski> @type union . strength
00:36:09 <lambdabot> forall a b. (Eq a, Eq b) => (a, [b]) -> [(a, b)] -> [(a, b)]
00:36:36 <ski> hm
00:36:51 <zong_sharo> copumpkin: tapl or tapl-haskell?
00:37:04 <ski> it appears `Eq (a,b)' was simplified to `(Eq a,Eq b)', there
00:37:31 <ski> doesn't that assume non-overlap ?
00:39:26 <ski> zong_sharo : presumably the dead tree book
00:39:54 <zong_sharo> ski: ?
00:40:12 <ski> "Types and Programming Languages", by Benjamin Pierce and someone
00:40:17 <path[l]> how do I understand the relative priority of different operators? like $ vs ===
00:40:19 <path[l]> err
00:40:20 <path[l]> ==
00:40:33 <copumpkin> path[l]: :i ($) in ghci
00:41:01 <Saizan_> ski: but Eq (a,b) is not a valid h98 constraint
00:41:11 <ski> i know
00:41:23 <zong_sharo> amazon reviews looks promising
00:41:33 <Saizan_> or is it?
00:41:34 <path[l]> ah $ is ranked 0 and == is ranked 4
00:41:36 <ski> but assume there's an `instance Eq (Int,Bool) where _ == _ = True'
00:42:16 <path[l]> damn I was hoping to get rid of the brackets in this expression
00:42:18 <ski> and say i want to use `union :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]'
00:42:54 <ski> then shouldn't the `Eq' instance used there be the direct `Eq (Int,Bool)' one, rather than the one synthesized from `Eq Int' and `Eq Bool' ?
00:43:00 <Saizan_> i guess that's one of the reasons OverlappingInstances are bad for you
00:43:27 <ski> (it would be another thing if `union' didn't require `Eq a' directly at all)
00:43:37 <path[l]> feh the RWH site is misbehaving. I wanted to read the quickcheck chapter
00:43:39 * copumpkin is writing a type-level union for type-level lists of ordered types :o
00:44:02 <ski> path[l] : which expression ?
00:44:04 <copumpkin> somehow it feels rather silly
00:44:22 <path[l]> complete xs = (size.unions) (L.map (\key -> hash ! key) xs) == M.size hash <-- this one
00:44:36 <path[l]> its part of a where expression
00:44:39 <path[l]> so hash is defined
00:44:46 <ski> s/(\key -> hash ! key)/(hash !)/
00:45:09 <path[l]> huh? oh
00:45:12 <path[l]> right
00:45:24 <ski> is `size' the same as `M.size', here ?
00:45:47 <path[l]> no  thats S.size
00:45:55 <path[l]> those are setd
00:45:57 <path[l]> sets
00:46:54 <copumpkin> hmm, no typecase eh :P
00:46:58 <ski>   complete xs = (S.size . unions . L.map (hash !) $ xs) == M.size hash  -- maybe
00:47:28 <Saizan_> copumpkin: you have an Ord kindclass?
00:47:30 <path[l]> hmm let me try that :)
00:47:46 <path[l]> copumpkin: if that's addressed at me, what do you mean by typecase
00:47:46 <zong_sharo> Saizan_: thank you
00:47:48 <copumpkin> Saizan_: nope, I just went and wrote a crapload of Compare type family instances :P
00:48:07 <ski> @type M.unions
00:48:08 <copumpkin> Saizan_: along with data GT; data EQ; data LT
00:48:09 <lambdabot> forall k a. (Ord k) => [M.Map k a] -> M.Map k a
00:48:47 <path[l]> ok real world haskell is down, anyone know a good tutorial for quickcheck ?
00:48:57 <Saizan_> copumpkin: heh :)
00:49:08 <ski> @type \f -> S.unions . map f
00:49:10 <lambdabot> forall a a1. (Ord a) => (a1 -> S.Set a) -> [a1] -> S.Set a
00:50:47 <ski> @type Data.Foldable.foldMap
00:50:49 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
00:51:01 <ski> path[l] : didn't someone suggest using that ^ yesterday ?
00:51:16 <path[l]> do you mean foldMap?
00:51:32 <ski> yes, that's what i just asked lambdabot about
00:51:50 <path[l]> I dont think I understood it if someone had suggested that :x
00:51:56 <path[l]> lol
00:52:25 <ski>   complete xs = (S.size . foldMap (hash !) $ xs) == M.size hash  -- assuming `Monoid (Set a)'
00:52:59 <copumpkin> Saizan_: lol, I wrote it, but it needs undecidable instances :(
00:53:01 <copumpkin> sigh sigh
00:54:30 <path[l]> I dont understand what foldMap does there. I assume it understands that sets should be folded by unioning .... but which map does it fold?
00:54:36 <path[l]> since xs is a list
00:54:53 * ski is reminded of `Equal (a0,b0) (a1,b1) -> (Equal a0 a1,Equal b0 b1)'
00:55:33 <Saizan_> copumpkin: it's not like GHC's termination checker is very smart
00:55:42 <copumpkin> yeah :)
00:55:45 <ski> path[l] : it's "Map" is in the function `map' (or `fmap') not as in the data-structure `Map'
00:55:46 <copumpkin> well I'm sure that this terminates
00:55:49 <copumpkin> so I guess I'm safe
00:56:15 * ski tried twice writing `map' there, writing `fmap' instead, before succeeding ..
01:04:23 <path[l]> ok but Im still lost. So foldMap is like a map followed by a fold is it?
01:04:50 <copumpkin> :t foldMap
01:04:52 <lambdabot> Not in scope: `foldMap'
01:04:57 <copumpkin> @hoogle foldMap
01:04:57 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
01:04:57 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
01:05:27 <ski> @type Data.Foldable.fold
01:05:29 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
01:05:50 <ski> path[l] : yes
01:08:26 * copumpkin feels the power of the undecidable instances
01:09:14 * ski undecides a power object
01:09:23 <copumpkin> :o
01:09:27 <mercury^> Wohoo, netsplit is over.
01:09:40 * ski raises eyebrow
01:09:47 <ski> which netsplit ?
01:09:49 <Boney> \whois mercury^
01:09:52 <Boney> err.
01:09:57 <mercury^> There was a netsplit for 2 days for me.
01:10:17 <Boney> mercury^: I'm curious who you are since I work on Mercury.
01:10:18 <Stinger> didnt try changing servers? :)
01:10:37 <mercury^> Tried it twice, but rotation always gave me the same one so I stopped bothering.
01:10:43 <Stinger> Boney, sheesh, hell of a commute
01:10:58 <mercury^> Wasn't *that* important for me to be on irc.
01:11:02 <mercury^> Still nice to be back though.
01:11:09 <Boney> Stinger: eh?
01:11:30 <ski> *grin*
01:11:59 <mercury^> Anyway, -keep-tmp-files not working with ghc 6.10.1?
01:14:03 <path[l]> ski how is that different from mapAccumR ?
01:15:45 <ski> @type mapAccumR
01:15:47 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
01:15:59 <ski> the types, they do not match
01:16:00 * BMeph hands Boney a copy of "Men are from Mars, Women are from Venus, Politicians are from Uranus, and Boney is from Earth, but works on Mercury"
01:16:31 <path[l]> well the only difference seems to me the output no? it returns the list which I guess is useless
01:16:44 <path[l]> but it too maps each element and folds them given an accumulator
01:16:56 <ski> `mapAccumL' is `mapM' on `State'
01:16:57 <path[l]> but I guess foldMap is smarter since it guesses how to fold?
01:18:47 <path[l]> hmmm can import Data.Foldable and ask it to override prelude?
01:18:56 <ski> `mapAccumR' produces a result `[b]', while `foldMap' produces an `m' (which was `Set b' in your case)
01:19:01 <path[l]> ah
01:19:13 <path[l]> I thought mapAccumR produces m and [b]?
01:19:23 <path[l]> the acc is the m right?
01:19:43 <ski> no `acc' there is not assumed to be in `Monoid'
01:20:05 <path[l]> hmm ok
01:20:11 <ski> (probably one could use it that way, but i don't know why you'd want the `[b]' result as well, then)
01:20:16 <path[l]> yeah true
01:20:17 <ski> import qualified Prelude as P
01:20:20 <path[l]> ah
01:20:47 <path[l]> whoa that killed everything else lol. I guess I need prelude unqualified
01:20:53 <ski> (:
01:21:14 <ski>   import Prelude hiding (blah,bleh)
01:22:20 <ray> the prelude is for losers, write your own
01:23:15 <path[l]> lol
01:25:22 <path[l]> ok got it working, now back to quickcheck
01:26:02 <ski> @check True
01:26:03 <lambdabot>   "OK, passed 500 tests."
01:29:52 <copumpkin> ooh, I can make the same argument appear multiple times in a type instance?
01:30:11 <copumpkin> to imply equality?
01:30:18 <path[l]> ok I feel dumb. Could someone help me out writing the first test. I dont even know how to start from the quickcheck website
01:30:36 <path[l]> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8422#a8422 <-- there
01:30:42 <copumpkin> oh, maybe not
01:30:58 <path[l]> oh also, Id love to know how to get rid of that nested where condition
01:30:59 <ski> copumpkin : ?
01:31:26 <copumpkin> nah, nevermind :P I thought you could write f x x for types and have it only match when you passed the same argument twice
01:31:46 <ski> where ?
01:31:54 <copumpkin> for type families
01:32:37 <path[l]> oooh question. Will the haskell compiler optimize away the section where I go M.size hash and make sure it only happens once? Since data structures are immutable anyway
01:33:02 <ski> path[l] : in `subseqs' ?
01:33:14 <path[l]> the nested where is in subseqs
01:33:20 <path[l]> but I mean in minSize
01:34:12 <path[l]> I assume subSeqs and allSubSeqs are going to be produced lazily? So minSize should be whats really driving my running time
01:34:19 <ski> you could lift `M.size hash' out if you're unsure
01:35:01 <ski> what is `subseqs' supposed to be doing ? (and why is it not polymorphic ?)
01:35:34 <path[l]> well subseqs is supposed to take a list and a number n and give me all subsequences of length n (without worrying about relative ordering)
01:35:42 <path[l]> its like all combinations of length n
01:35:58 <ski> (the `last' looks possibly inefficient, too)
01:36:15 <path[l]> the last foo?
01:36:21 <path[l]> hmm
01:36:22 <ski> yes
01:36:29 <ski>   subseqs 3 [a,b,c,d] = ?
01:36:54 <path[l]> [[a,b,c],[a,b,d],[a,c,d],[b,c,d]]
01:37:02 <ski> ok
01:37:53 <path[l]> how do you suggest I deal with the last ?
01:38:17 <BMeph> > replicateM 3 [a,b,c,d]
01:38:19 <lambdabot>   [[a,a,a],[a,a,b],[a,a,c],[a,a,d],[a,b,a],[a,b,b],[a,b,c],[a,b,d],[a,c,a],[a...
01:38:24 <ski> not quite
01:38:43 <BMeph> Yeah - duplicates are bad, m'kay? ;)
01:39:08 <path[l]> heh
01:39:42 <BMeph> > filter ((==3).length) . subsequences $ [a,b,c,d]
01:39:44 <lambdabot>   [[a,b,c],[a,b,d],[a,c,d],[b,c,d]]
01:39:59 <BMeph> Heh-heh. ;)
01:40:02 <path[l]> what I really want (which is why I use allSubSeqs is given [a,b,c,d] => [[],[a],[b],[c],[d],[a,b] ...
01:40:03 <path[l]> etc
01:40:09 <path[l]> so I do want subsequences
01:40:13 <path[l]> but i want them ordered
01:40:27 <path[l]> and I was thinking that the existing implementation of subsequences wouldnt be lazy
01:40:29 <path[l]> if I sort it
01:40:45 <path[l]> what I did looks like it should be lazy ... or so I thought
01:40:55 <copumpkin> :
01:40:56 <copumpkin> *Main> undefined :: Properties (Semilattice Int) `HasProperty` Unital Int
01:40:56 <copumpkin> False
01:40:58 <copumpkin> :P
01:41:16 <BMeph> Boo, Faugh!
01:41:27 <path[l]> if I give it a 100 element list and if a subsequence of size 3 solves my problem, I dont wanna see subsequences of size 4,5 etc
01:42:14 <path[l]> and subsequences of size 50 should be a large number, which I could avoid potentially
01:46:42 <path[l]> so umm any suggestions guys ? :)
01:53:59 <ski> > replicateM 3 pick `evalStateT` "abcd"
01:54:02 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
01:54:02 <lambdabot>    arising from a use ...
01:54:25 <ski> > replicateM 3 pick `evalStateT` "abcd" :: [String]
01:54:27 <lambdabot>   ["abc","abd","acd","bcd"]
01:55:14 <ski> path[l] : probably one can do better, but that appears to work
01:55:23 <path[l]> hmm ok
01:55:28 <path[l]> whats evalState ?
01:55:36 <ski> @index evalStateT
01:55:36 <lambdabot> Control.Monad.State, Control.Monad.RWS
01:55:56 <ski> (however, i defined `pick' here myself)
01:56:47 <path[l]> I guess I dont quite understand that
01:58:26 <BMeph> path[l]: Do you need the subsequences, or do you just need to know how many there are? Those are two different questions, BTW. ;)
01:59:05 <path[l]> I actually need the subsequences. But I need to make sure longer subsequences are calculated only if short subsequences dont satisfy my criteria
01:59:28 <path[l]> so I created a function make all subsequences in the order of increasing length. And later I use a "find" on this list
01:59:39 <path[l]> my assumption was that my first function would be called lazily
02:00:11 <Taejo> :t partition
02:00:13 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:01:03 <path[l]> Im trying to find the shorted subsequence of a list that satisfies a given criterion
02:01:29 <Taejo> > partition ((||) `on` even) [(1,2), (4,4), (3, 3)]
02:01:31 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
02:01:34 <path[l]> (i.e that the union of the values of those elements in a given map completely describes some space)
02:01:39 <Taejo> :t (||) `on` even
02:01:41 <lambdabot> forall a. (Integral a) => a -> a -> Bool
02:01:58 <Taejo> > partition (uncurry $ (||) `on` even) [(1,2), (4,4), (3, 3)]
02:02:00 <lambdabot>   Precedence parsing error
02:02:00 <lambdabot>      cannot mix `GHC.Base.$' [infixr 0] and `Data....
02:02:16 <mercury^> RWH is down?
02:02:19 <Taejo> > partition (uncurry ((||) `on` even)) [(1,2), (4,4), (3, 3)]
02:02:21 <lambdabot>   ([(1,2),(4,4)],[(3,3)])
02:04:25 <ski> > msum [replicateM i pick | (i,_) <- zip [0..] (undefined:"abcd")] `evalStateT` "abcd" :: [String]
02:04:28 <lambdabot>   ["","a","b","c","d","ab","ac","ad","bc","bd","cd","abc","abd","acd","bcd","...
02:05:07 <path[l]> whoa
02:05:30 <Taejo> :t Data.Set.contains
02:05:31 <path[l]> thats about right.
02:05:32 <lambdabot> Not in scope: `Data.Set.contains'
02:05:33 <ski> a bit ugly, yes
02:05:38 <Baconizer> Is there a way to use Haskell with a LEGO Mindstorms set? "HASKELL-NXT" doesn't seem active anymore
02:05:47 <path[l]> but its a lot less code than I wrote
02:05:50 <path[l]> is it lazy ski?
02:06:12 <ski> > msum [replicateM i pick | (i,_) <- zip [0..] (undefined:[0..])] `evalStateT` [0..] :: [[Integer]]
02:06:14 <lambdabot>   [[],[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[...
02:06:19 <ski> looks like that
02:06:30 <path[l]> ah
02:06:33 <ski> hrm
02:06:46 <ski> actually, it doesn't work correctly for infinite lists
02:06:53 <ski> but maybe that doesn't bother you
02:07:38 <path[l]> well sure I guess. Since for infinite lists you'll be talking about subsequence size 1 case for ever
02:07:50 <ski> unless you diagonalize, yes
02:07:57 <path[l]> its just a lot of times Ill have a list of 100 elements and subsequence size 4 or 5 should be sufficient
02:08:14 <path[l]> so it was important for me to do size  1 then 2 then 3 et
02:08:30 <path[l]> ok let me read up on replicatM, evalStateT and pick
02:08:32 <path[l]> and msum
02:08:33 <path[l]> lol
02:08:51 <ski>   pick :: MonadPlus m => StateT [a] m a
02:08:53 <ski>   pick = StateT (liftM (\ ~(_,a,as) -> (a,as)) . select)
02:09:10 <ski>   select :: MonadPlus m => [a] -> m ([a],a,[a])
02:09:15 <ski>   select = loop []
02:09:17 <ski>     where
02:09:29 <ski>     loop acc [    ] = mzero
02:09:34 <ski>     loop acc (a:as) = return (acc,a,as) `mplus` loop (a:acc) as
02:10:13 <ski> you can avoid collecting the prefix in `select' since `pick' doesn't need it
02:10:13 <ray> @hackage control-monad-omega
02:10:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-monad-omega
02:10:23 <path[l]> hmm actually ski, for now I think I wanna finish my problem. So Im gonna skip that. (I dont wanna make changes I dont understand). But could you tell me anything thats just bad in what Ive done that I should change
02:10:25 <path[l]> right away
02:10:31 <ray> ^^ diagonalization
02:11:26 <ski> path[l] : i'm not sure, but i'd try to avoid calling `length' and `last' .. possibly `splitAt', too
02:11:37 <path[l]> hmm ok
02:11:50 <ski> there ought to be a direct list version, i think
02:12:30 <path[l]> length looks minor to me, since my original list has atmost 100 elements. But Im not sure how Id get rid of last and splitAt
02:12:44 <path[l]> I want to break a list as items, item, moreitems
02:12:48 <path[l]> and I need item and moreitems
02:12:56 <ski>   foo [b,c,d] = [[],[b],[c],[d],[b,c],[b,d],[c,d],[b,c,d]]
02:13:07 <Baconizer> :(
02:13:34 <ski>   foo [a,b,c,d] = [[],[a],[b],[c],[d],[a,b],[a,c],[a,d],[b,c],[b,d],[c,d],[a,b,c],[a,b,d],[a,c,d],[b,c,d],[a,b,c,d]]
02:13:49 <ski> how to go from `foo [b,c,d]' to `foo [a,b,c,d]' ?
02:15:00 <path[l]> hmm, I think its foo of a,b,c + foo a,b,d + foo b,c,d  + [a,b,c,d]
02:15:11 <path[l]> and the empty list must exist only once, so probably a union
02:15:32 <path[l]> I cant think of a nice recursive way =p
02:15:53 <path[l]> I had looked at the code of the built in subsequences, to see if it would help
02:16:36 <path[l]> but that does a foldr so it gives me [[],[a],[b],[a,b],[c] <--- which isnt good if I have a 100 element list
02:16:48 <path[l]> since Ill have [a,b,c...y] before [z]
02:18:07 <ski> > let foo = concat . bar; bar [] = [[[]]]; bar (a:as) = zipWith (\as0 as1 -> map (a:) as0 ++ as1) ([] : ass) (ass ++ [[]]) where ass = bar as in foo [a,b,c]
02:18:09 <lambdabot>   [[],[a],[b],[c],[a,b],[a,c],[b,c],[a,b,c]]
02:19:11 <ski> maybe it's better to write the `zipWith' loop manually ..
02:19:31 <path[l]> hmmm. I kinda want to finish this.
02:19:41 <path[l]> Is there no way to go from where I am
02:19:50 <path[l]> and take out the inefficient bits
02:19:57 <path[l]> instead of redoing that completely ?
02:22:01 <ski> instead of `(foo, bar) = splitAt i xs' you could do `x:bar = drop (i-1) xs' and replace the `last foo' with `x'
02:22:56 <path[l]> ah
02:23:15 <path[l]> yeah thats easy to understand. Thanks :)
02:23:27 <ski> hrm
02:24:20 <ski> `concatMap (\item -> [x:item])' is the same as `map (x:)'
02:24:48 <path[l]> ah yeah
02:25:08 <ski> (if you `concatMap', converting every element into a singleton, it's the same as just mapping into the element of that singleton)
02:30:06 <path[l]> huh wait. Is it?
02:30:37 <path[l]> wouldnt map(x:) simply give me each element of the list with x prepended before it?
02:30:40 <ski> > map ((:[]) . (^2)) [0..4]
02:30:42 <lambdabot>   [[0],[1],[4],[9],[16]]
02:30:47 <ski> > concatMap ((:[]) . (^2)) [0..4]
02:30:49 <lambdabot>   [0,1,4,9,16]
02:30:55 <ski> > map (^2) [0..4]
02:30:57 <lambdabot>   [0,1,4,9,16]
02:31:31 <ski> > map ((:[]) . ('x':)) ["foo","bar"]
02:31:33 <lambdabot>   [["xfoo"],["xbar"]]
02:31:35 <ski> > concatMap ((:[]) . ('x':)) ["foo","bar"]
02:31:36 <lambdabot>   ["xfoo","xbar"]
02:31:44 <ski> > map ('x':) ["foo","bar"]
02:31:46 <lambdabot>   ["xfoo","xbar"]
02:31:53 <ski> that's closer to your case
02:32:18 <path[l]> hmm
02:32:23 <ski> the `\item -> [x:item]' corresponds to the `(:[]) . ('x':)', here
02:32:24 <path[l]> I see
02:32:32 <path[l]> yeah ok
02:32:44 <ski>   subseqs 0 _ = do return []
02:32:50 <path[l]> so concatMap makes each item itself a list and then concats those
02:32:53 <ski>   subseqs n xs = do
02:33:06 <ski>     i <- [0 .. length xs - n]
02:33:17 <ski>     let x:bar = drop i xs
02:33:45 <ski>     item <- subseqs (n-1) bar
02:33:52 <ski>     return (x:item)
02:34:03 <ski> that's your code, written in another style
02:34:26 <ski> path[l] : yes, it maps every item into a list with the given argument function
02:34:32 <path[l]> ah. Whats with the returns?
02:34:43 <path[l]> like subseqs 0 _ = do return []
02:34:44 <ski> you can write
02:34:53 <ski>     map (x:) (subseqs (n-1) bar)
02:34:59 <ski> instead of the two last lines, if you like
02:35:07 <ski> here
02:35:13 <ski> @src [] return
02:35:13 <lambdabot> return x    = [x]
02:35:39 <path[l]> hmmm. So it just makes an array of something?
02:35:50 <ski> also, this suggests that you can write this using a list comprehension, if you prefer that
02:35:54 <ski> s/array/list/
02:36:00 <path[l]> yes list
02:36:06 <path[l]> I keep saying array :/
02:36:30 <ski> subseqs n xs = [ x:item | i <- [0 .. length xs - n] , let x:bar = drop i xs , item <- subseqs (n-1) bar ]
02:36:53 <ski> better or worse ?
02:37:02 <path[l]> better, but reading slowly to understand
02:37:03 <path[l]> lol
02:37:56 <path[l]> hmm ok so | can be read as a where is it?
02:38:12 <ski> a bit similar
02:38:19 <path[l]> ah
02:38:23 <ski> > [x^2 | x <- [0..9]]
02:38:25 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
02:38:30 <path[l]> right
02:38:35 <ski> > [y | x <- [0..9] , let y = x^2]
02:38:37 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
02:38:52 <ski> > [c*y | x <- [0..3] , let y = x^2 , c <- [10,100]]
02:38:54 <lambdabot>   [0,0,10,100,40,400,90,900]
02:39:17 <ski> you can think of it as "nested `for'-loops", if that means anything to you
02:39:56 <path[l]> yeah it does. hmm, but its easier for me to read it as "return this for every element of the list where (then read what the pipe says)
02:40:15 <sm> @seen dons
02:40:16 <lambdabot> dons is in #haskell-in-depth, #yi, #xmonad, #ghc, #haskell, #arch-haskell, #concatenative and #darcs. I last heard dons speak 10h 44m 32s ago.
02:40:19 <ski> "collect the list of all `c*y' where `x' is taken from `[0..3]', `y' is `x^2' and `c' is taken from `[10,100]'"
02:40:22 <path[l]> so return x:item for where x is defined as this and item is defined as this for each element of the list
02:40:35 <path[l]> ah
02:40:46 <path[l]> ok
02:40:50 <path[l]> now I see
02:41:08 <Jedai> path[l]: originally this syntax was created to look like set comprehension in mathematics
02:41:15 <path[l]> ah
02:41:18 <ski> > [(10^c)*y | x <- [0..3] , let y = x^2 , c <- [1..x]]
02:41:20 <lambdabot>   [10,40,400,90,900,9000]
02:42:04 <Jedai> [x | x <- [0..9], x > 5] read as "set of xs such that x is in [0..9] and x > 5"
02:42:41 <Jedai> path[l]: Of course since list aren't sets, there is an order consideration too
02:42:47 <path[l]> yeah
02:42:51 <ski> > concatMap (\x -> let y = x^2 in concatMap (\c -> (10^c)*y) [1..x]) [0..3]
02:42:54 <lambdabot>   No instance for (GHC.Real.Integral [b])
02:42:54 <lambdabot>    arising from a use of `GHC.Real....
02:43:07 <ski> > concatMap (\x -> let y = x^2 in concatMap (\c -> [(10^c)*y]) [1..x]) [0..3]  - right
02:43:09 <lambdabot>   Couldn't match expected type `[a]'
02:43:10 <ski> > concatMap (\x -> let y = x^2 in concatMap (\c -> [(10^c)*y]) [1..x]) [0..3]
02:43:13 <lambdabot>   [10,40,400,90,900,9000]
02:43:34 * ski is not fully awake, yet ..
02:44:21 <path[l]> one more small thing. Could someone explain how Id write a reall simple quickcheck for the problem? Im not even sure how to start
02:44:25 <mercury^> Is there a way to query the number of OS threads the runtime system is using?
02:46:49 * ski is not sure what the problem is
02:47:44 <path[l]> Ive put that in comments below. Example test cases too (I come from an OO world where my tests go, take this ... make sure I get this other thing)
02:47:56 <ski> it looks like there could be several minimal solutions
02:48:22 <ski> presumably you only want to check that the computed solution is minimal ?
02:49:00 <path[l]> yeah
02:49:15 <path[l]> I want to make sure Ive found the smallest set such that my condition is satisfied
02:49:50 <ski> i suppose one way to do that would be to first write something that checks that a proposed solution covers the problem
02:50:26 <ski> then given a proposed minimal solution, check that it covers the problem, and that all proposed sub-solutions you get by omitting one node doesn't cover the problem
02:50:30 <ski> would that work ?
02:50:55 <path[l]> well Im fine with even giving it a problem and checking that the size of the answer is some value x
02:50:57 <path[l]> ?
02:51:36 <ski> that's unit tests
02:51:51 <ski> i assumed you wanted a QC property
02:52:36 <path[l]> well Im used to unit testing. I guess I dont know any other way :o, but I guess I should just listen to the suggestion then
02:52:37 <path[l]> lol
02:53:45 <path[l]> hmm the QC property sounds like a lot more repeated code though. Cause writing something that checks that a proposed solution covers the problem is half of my solution already isnt it?
02:54:01 <ski>   prop_doStuff_minimalSolution :: [(Char,Char)] -> Property
02:54:08 <ski> something like that, i suppose
02:55:32 <ski> you could use part of your program to write that property (and then check that part of the program separatedly)
02:55:46 <path[l]> ah
02:56:34 <path[l]> maybe a unit test makes more sense here then? it's less code and tests the whole thing anyway?
02:56:49 <path[l]> are unit tests written in haskell?
02:56:58 <ski> i dunno, you could do both here, i guess
02:57:27 <ski> (but if an assignment asks for properties, then only unit tests will not do)
02:57:45 <ski> unit tests are used sometimes
02:58:24 <path[l]> hmmm by assignment you mean like ... assigning a value to something?
02:58:37 <path[l]> sorry Im confused by that statement
02:58:54 <ski> sorry, no. i was assuming you were doing assignments for a course
02:59:13 <ski> (s/assignments/excercises/, if you prefer)
02:59:20 <path[l]> oh no, Im just learning this for fun :). Im trying to solve a problem on some site that allows solutions in multiple languages
02:59:24 <path[l]> and haskell was one
02:59:26 <path[l]> lol
02:59:34 <path[l]> so I thought Id use it to learn
02:59:36 <ski> ic
02:59:39 <path[l]> and submit haskell solutions
03:00:06 <path[l]> they run it against a bunch of test cases and tell you you win if you pass the cases in a fixed amount of time
03:00:06 <ski> you may do either or both (or none) of unit tests and QC properties
03:00:10 <path[l]> and give the correct answers
03:00:15 <path[l]> ah
03:00:41 <ski> but if it's not too much work (or too similar to the code itself), a QC property can give reasonably good assurance
03:00:54 <path[l]> well Im familiar with unit tests, so I guess for this first step Ill just try unit testing. Ill learn QC properties on the next one I guess :)
03:01:06 <ski> as you wish
03:01:17 <path[l]> now I need to learn how to do IO lol
03:01:24 <path[l]> to make the compiled binary pass their test
03:01:31 <path[l]> take inputs and return outputs
03:01:41 <path[l]> thanks a lot ski
03:01:45 <ski> np
03:11:39 <path[l]> which is smaller? Int or Integer? things like drop all take Int right?
03:12:12 <ray> Ints are machine ints, and suck, but things take them that should really be taking Naturals or Integers
03:12:17 <ski> > maxBound :: Int
03:12:21 <lambdabot>   9223372036854775807
03:13:04 <ray> fancy 64-bit lambdabot
03:13:17 <path[l]> heh ok
03:13:35 <endojelly> Integers are unbounded
03:13:37 <roconnor> > take 5 $ drop 9223372036854775807 [0..]
03:13:42 <lambdabot>   mueval-core: Prelude.read: no parse
03:13:42 <lambdabot>  mueval: ExitFailure 1
03:13:45 <roconnor> :(
03:13:45 <endojelly> at the cost of time and memory.
03:14:02 <path[l]> heh ok
03:14:09 <endojelly> > take 5 $ drop (maxBound :: Int) [0..]
03:14:14 <lambdabot>   mueval-core: Prelude.read: no parse
03:14:14 <lambdabot>  mueval: ExitFailure 1
03:14:23 <roconnor> > take 5 $ drop maxBound [0..]
03:14:25 <path[l]> meh I copied this code to make an integer read from the console.
03:14:28 <lambdabot>   mueval-core: Prelude.read: no parse
03:14:28 <lambdabot>  mueval: ExitFailure 1
03:14:31 <path[l]>   where readNum :: IO Integer
03:14:31 <path[l]> 	    readNum = readLn
03:14:32 <ski> out of time
03:14:33 <roconnor> , take 5 $ drop maxBound [0..]
03:14:39 <path[l]> but tests <- readNum gives me an error
03:14:41 <lunabot>  Killed.
03:14:46 <endojelly> just... where does it want to read anything?
03:14:59 <ski>   tests <- readLn :: IO Integer
03:15:22 <Saizan_> endojelly: if you find out let me know
03:15:22 <ski> , maxBound :: Integer
03:15:23 <lunabot>  luna: No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
03:15:25 <ski> , maxBound :: Int  -- er
03:15:26 <lunabot>  luna: parse error (possibly incorrect indentation)
03:15:41 <endojelly> > take 5 $ drop 10 [0..]
03:15:42 <ski> @slap lunabot
03:15:42 * lambdabot pokes lunabot in the eye
03:15:43 <lambdabot>   [10,11,12,13,14]
03:15:51 <path[l]> hmm was there a difference between that ski and what I did ... cause your suggestion worked
03:16:02 <path[l]> but readNum was defined as readLn :: IO Integer
03:16:09 <path[l]> dunno why it failed
03:16:18 <ski> it should have worked, too
03:16:22 <jorick> hey how do you do it so that lamba bot can evaluate haskell code, is there an eval:: String -> IO String?
03:16:23 <path[l]> it said
03:16:23 <endojelly> Saizan_, will do... but right now I'm at a loss
03:16:23 <ski> maybe you had indentation error ?
03:16:24 <roconnor> fromInteger <$> readLn
03:16:30 <path[l]> Illegal signature in pattern: IO Integer readNum
03:16:31 <path[l]>         Use -XPatternSignatures to permit it
03:17:14 <ski> path[l] : i'd guess bad indentation
03:17:45 <ski> the `readNum :: IO Integer' and the `readNum = readLn' must line up
03:17:54 <path[l]> hehe ok
03:18:09 <path[l]> they do ... wierd
03:18:17 <ski> maybe you're mixing tabs and spaces ?
03:18:32 <path[l]> aha
03:18:33 <path[l]> right
03:18:54 <path[l]> god Im sick of that issue
03:18:54 <path[l]> lol
03:19:05 <ski> yes .. it looks like your editor displays tabs as four spaces, while ghc interpreted it as eight spaces
03:19:13 <path[l]> hehe
03:19:21 <ray> looks like yet another editor failure
03:19:26 <ray> who writes these things
03:19:44 <ski> /ctcp path[l] editor
03:19:53 <ray> you'd think unixbeards write them
03:20:00 <path[l]> lol
03:20:00 <ray> but unixbeards would use the standard unix tab stop
03:20:06 <ray> so who the hell writes them
03:20:16 <ski> martians !
03:20:25 <ski> (or little green men)
03:20:30 <ray> is there some new generation of unixbeards using 80x12 terminals?
03:20:35 <path[l]> this is textmate ... so hehe
03:20:44 <ray> er, it'd be 40x14
03:20:49 <ray> half width :(
03:21:01 <ray> oh, ok, mac
03:21:03 <ski> ray : why ?
03:21:09 <ray> yeah mac programmers wax their beards off
03:21:10 <path[l]> yeah
03:21:30 <ray> why what?
03:21:42 <path[l]> hmm now given that haskell seperates pure and impure functional code. Can I create a range and map it to a function that does a readLn ?
03:21:49 <path[l]> thats legal right?
03:21:52 <path[l]> just non lazy
03:22:14 <endojelly> path[l], you can not map it, but you can mapM or mapM_ it.
03:22:17 <ski> why you wondering about 80x12^W40x14 terminals ?
03:22:29 <path[l]> hmm oh
03:22:33 <endojelly> path[l], and it has not much to do with lazy
03:22:40 <path[l]> mapM is map with a monad?
03:22:42 <mercury^> dons: is unfoldrN more efficient than doing it manually using cons/snoc?
03:22:42 <ray> i'm conjecturing that the people who write editors that display tabs with smaller than normal sizes have really narrow terminals
03:22:50 <ski> (you *can* `map' it .. but you probably won't get the answer you expect)
03:22:50 <endojelly> path[l], yap
03:22:52 <endojelly> :t mapM
03:22:55 <ray> even narrower than the classic unix 80 characters
03:22:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:23:01 <ray> like, 40 characters
03:23:07 <path[l]> ah
03:23:10 <roconnor> @type mapM fromInteger readLn
03:23:12 <lambdabot>     Couldn't match expected type `[Integer]'
03:23:12 <lambdabot>            against inferred type `IO a'
03:23:12 <lambdabot>     In the second argument of `mapM', namely `readLn'
03:23:23 <roconnor> oh
03:23:31 <ray> |--------------------------------------| <-- that wide
03:23:34 <roconnor> duh
03:23:35 <ski> .. the C64 used 40x25, maybe that's it ?
03:23:56 <ray> ah, so they must be writing these editors for their commodores
03:24:12 * ski started on one, once
03:24:14 <endojelly> path[l], if you want to do "monadic stuff" (like IO actions) you have to stay in the monad. look closely at the type signature of mapM: it takes a function inside a monad (a -> m b), a list ([a]) and returns a list inside of the monad (m [b])
03:24:42 <endojelly> ski, yes, but that sounds confusing at first. I think when you start it's quite nice to think of "staying in the monad"
03:25:22 <ski> (just refuting you for your pleasure :)
03:25:26 <endojelly> .D
03:25:27 <endojelly> :D
03:26:01 <endojelly> ski, although, well, you *can* use map if you use sequence afterwards 8)
03:26:14 <endojelly> :t \f l -> sequence (map f l)
03:26:15 <path[l]> hmm
03:26:16 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> [a] -> m [a1]
03:26:20 <ski> or `head'
03:27:29 <endojelly> in fact, I don't know why, but I remember using sequence . map instead of mapM a lot at first.
03:28:18 <path[l]> I think I need to know how to make a monad of my own. Since I have to do some complex IO
03:28:34 <endojelly> :t map
03:28:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:28:40 <endojelly> :t mapM
03:28:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:28:50 <ski> path[l] : you do *not* need to know how to make a monad, just to be able to use `IO' (even complex such)
03:28:53 <endojelly> my ghci doesn't display the kind? :(
03:28:57 <endojelly> (m :: * -> *)
03:29:27 <endojelly> path[l], yeah, ski is right. at first it's really easier to not care. just remember to stay in the monad.
03:30:03 <endojelly> *using* preexisting monads is really not hard.
03:30:50 <path[l]> hmm
03:30:55 <path[l]> ok
03:30:56 <endojelly> well, you can do horrible things by just using Cont that *will* make you cry, but you really don't need to ;)
03:32:01 <HugoDaniel> hi
03:32:19 <endojelly> I remember practicing by building my own Cont monad and implementing coroutines with nasty twists in it.
03:32:27 <path[l]> well its like this. Like I get a number. from 0 to that number I then need to take a variable number of inputs. So I was thinking 0..something mapM and the function I pass will have to read a number, and again internally mapM to read a bunch of lines
03:32:31 <ski> `Cont o' is a nice,nice monad, don't demean it !
03:32:34 <path[l]> I dont know if Im making sense
03:33:02 <endojelly> when it finally did exactly what I wanted it to do, I realized that it made no sense and was probably never supposed to exist in our world.
03:33:10 <path[l]> basically to read a list of lists where the inner and outer lists all have variable sizes
03:33:44 <endojelly> path[l], I'm not totally sure what you're trying to do, but that sounds okay
03:34:07 <path[l]> well for my outerlist instead of passing a monad, what do I pass it?
03:34:11 <path[l]> can I pass a function
03:35:12 <endojelly> to mapM? that would really need to be a function in a monad. so, it's return type must be "m something" (in your case proibably IO something)
03:35:19 <endojelly> but, yeah, it always takes a function
03:35:21 <ski> are you wanting to `do' something `n' times in the `IO' monad ?
03:35:27 <roconnor> do size <- read; items <- replicateM size read; return items
03:35:30 <endojelly> and you don't have to define your function beforehand, you can use lambda
03:35:46 <endojelly> path[l], wait, I'm about to make a little example.
03:35:57 <path[l]> ok that would be awesome
03:37:24 <endojelly> ski, that's what I gathered. which can be done with mapM .. [1..n], but also with replicateM
03:38:03 <ski> yes
03:38:36 <ski> (as in [roconnor])
03:40:42 <path[l]> I dont actually know how to do lambdas
03:41:09 <ski> > concatMap (\x -> [x,-x]) [1,2,3,4]
03:41:13 <lambdabot>   [1,-1,2,-2,3,-3,4,-4]
03:41:43 <ski> the `\x -> [x,-x]' there is the function mapping any `x' to `[x,-x]'
03:42:01 <ski> > let foo x = [x,-x] in concatMap foo [1,2,3,4]  -- the same
03:42:03 <lambdabot>   [1,-1,2,-2,3,-3,4,-4]
03:46:04 <endojelly> path[l], http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8424#a8424
03:46:15 <endojelly> path[l], to try it out, enter 9 numbers (on 9 lines) upon running
03:46:21 <endojelly> note that I made it intentionally verbose
03:46:22 <path[l]> hehe ok
03:46:33 <endojelly> a lot of the do keywords I used are entirely unnecessary
03:46:35 <endojelly> as is the return
03:47:01 <endojelly> but maybe it gives you an idea how to do more complex things, buy inserting additional actions into the do blocks
03:47:09 <path[l]> ah I see
03:47:18 <path[l]> so do can take a series of actions is it
03:47:29 <endojelly> and instead of mapM you could use replicateM, which is the same as mapM f [1..n], but that would be another new thing 8)
03:47:40 <endojelly> path[l], yes, that's what do does!
03:47:49 <path[l]> hmm
03:47:54 <path[l]> lol
03:47:56 <path[l]> thanks
03:48:00 <path[l]> let me play around with tha
03:48:03 <endojelly> (in reality, it's just syntactic sugar for lambdas and bind operators, but we don't care.)
03:48:19 <endojelly> path[l], good idea, that's the best way to learn that stuff.
03:48:59 <roconnor> @djinn J r a -> J r b -> J r (a,b)
03:49:00 <lambdabot> f a b c =
03:49:00 <lambdabot>     (a (\ d -> c (d, b (\ e -> c (a (\ f -> c (f, e)), e)))),
03:49:00 <lambdabot>      b (\ g -> c (a (\ h -> c (h, g)), g)))
03:49:41 <roconnor> oh wait, all monads in Haskell are strong
03:51:35 <endojelly> path[l], another thing: that type signature by readLn is just to specify that we want to readLn an Int, because readLn can read a lot of stuff. normally, you don't have to specify that type here, but in this little example we do nothing with that list of list oft Ints except printing it with print, and "unfortunately", print can also print a lot of things that readLn can read. so we need to be explicit.
03:51:48 <path[l]> ah
03:51:53 <endojelly> path[l], most of the time, you would omit that type, so don't worry too much about it.
03:52:36 <endojelly> path[l], for example, if after gathering the list of lists content, we added 1 to each element, then the type should be alread clear enough.
03:52:57 <path[l]> got it
03:53:12 * ski annotated "." with "use `forM'" at <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8424#a8425>
03:53:15 <ski> path[l] : ^
03:53:29 <path[l]> ah
03:53:33 <path[l]> interesting
03:53:50 <endojelly> yeah, forM ist just mapM with the arguments reversed
03:53:55 <roconnor> @djinn J r Either a b -> Either (J r a) (J r b)
03:53:55 <ski> @src forM
03:53:55 <lambdabot> Error: kind error: (KArrow KStar (KArrow KStar KStar),KStar)
03:53:56 <lambdabot> forM = flip mapM
03:53:58 <endojelly> it often makes for more readable code in monads
03:54:03 <roconnor> @djinn J r (Either a b) -> Either (J r a) (J r b)
03:54:03 <lambdabot> -- f cannot be realized.
03:55:46 <ski> @djinn J r a -> J r a -> J r a
03:55:46 <lambdabot> f a b c = a (\ _ -> c (b c))
03:56:21 <endojelly> ski, somehow I would have guessed "id" ?!
03:56:37 <endojelly> ski, er, bullshit 8)
03:56:39 <ski> rather `const id' or `flip const id', no ?
03:56:46 <endojelly> ski, yeah, const id.
03:57:06 <endojelly> brb
03:57:33 <ski> @type flip const id
03:57:35 <lambdabot> forall a. a -> a
03:57:49 <ski> @type flip (const id)
03:57:50 <lambdabot> forall a a1. a -> a1 -> a
04:08:24 <endojelly> ro
04:08:45 <endojelly> :t flip undefined
04:08:47 <lambdabot> forall a b c. b -> a -> c
04:09:05 <endojelly> :t (flip . flip . flip) undefined
04:09:06 <lambdabot> forall a b c. a -> b -> c
04:09:32 <endojelly> :t undefined undefined undefined
04:09:33 <lambdabot> forall t. t
04:10:21 <pr> :t id
04:10:22 <lambdabot> forall a. a -> a
04:10:46 <pr> @type id undefined
04:10:47 <lambdabot> forall a. a
04:13:15 <ray> :t id :: ((a -> b -> c) -> d -> e) -> (a -> b -> c) -> d -> e
04:13:17 <lambdabot> forall a b c d e. ((a -> b -> c) -> d -> e) -> (a -> b -> c) -> d -> e
04:28:38 <vashism608> ey if you guys are bored check out facebook zombies - http://apps.facebook.com/zombies/links.php?r=719927515&nref=st
04:29:46 <EvilTerran> ... according to my firefox history, that's been spammed here with the same referrer id before
04:30:13 --- mode: ChanServ set +o Igloo
04:30:29 --- mode: Igloo set +b *!*@203-219-131-38.static.tpgi.com.au
04:30:52 --- mode: Igloo set -o Igloo
04:31:10 <EvilTerran> meanwhile, the zombies app TOS page is broken
04:31:32 <Berengal> Zombies are fun, but not when people spam them
04:31:39 <Berengal> And I mean zombies in general, not facebook zombies
04:31:48 <gwern> hm. I need a replacement for amarok
04:31:51 <EvilTerran> facebook zombies are inane and pointless.
04:31:52 <gwern> any suggestions?
04:32:14 <Berengal> I should make a zombie game in haskell...
04:32:16 <gwern> EvilTerran: yes, but it's against the law to murder facebook users
04:32:16 <gwern> so...
04:32:18 <p_l> gwern: MPlayer?
04:32:33 <gwern> p_l: oh, I am using it; but no ratings or lastfm integration or suchlike
04:32:43 <ray> haskell zombies
04:32:44 <EvilTerran> gwern, surely it's not murder if they're undead? :P
04:33:09 <gwern> EvilTerran: at the very least, it's criminal endangerment - can't be sure that they weren't cosplaying
04:33:36 <ray> it would be different if there were a zombie apocalypse going on
04:33:36 <Berengal> EvilTerran, vivicist! Discriminating against the vitality of other human beings!
04:34:19 <gwern> Berengal: don't zombies by definition not have vitality?
04:34:24 <Berengal> "zombie haspocalypse"
04:34:25 <gwern> or are they differently-vitalized?
04:34:35 <gwern> Berengal: CAN HAS BRAINS?
04:34:48 <Berengal> gwern, better title
04:35:43 <Berengal> curry brains?
04:35:55 <Berengal> meh
04:36:15 <gwern> delicious
04:36:32 <gwern> hm. Songbird looks good, but not in ubuntu
04:36:37 <Berengal> I now want to make this game...
04:36:39 <p_l> EvilTerran: definition of what is a living being is getting ... wider
04:36:58 <Berengal> And look, it 13:37
04:37:13 <Berengal> The best time to start writing a game
04:37:34 <p_l> Sat Aug 22 11:37:34 UTC 2009
04:37:38 <p_l> not so fast ;-)
04:37:42 <Berengal> @time
04:37:43 <lambdabot> Local time for Berengal is Sat Aug 22 13:37:55
04:38:16 <p_l> UTC is the only valid timezone! :P
04:38:24 <ray> @time
04:38:27 <lambdabot> Local time for ray is Sat Aug 22 11:38:24 2009
04:38:37 <ray> look at me, i have a 2009
04:38:41 * EvilTerran knows someone who tried to set up his IRC client to, when CTCP TIME'd, CTCP TIME in kind, and give the response to that as its response
04:38:49 <EvilTerran> i think he accidentally flooded himself off while testing it
04:38:53 <Berengal> p_l, your logic is flawed. You admitt there are timezones, but claim there's one one valid one? Surely if there's one there shouldn't be any
04:39:18 <EvilTerran> 1TT?
04:39:24 <ray> i think timezones will die in our lifetime
04:39:24 <EvilTerran> (One True Timezone :P)
04:39:37 <EvilTerran> ray, hopefully 12-hour time will die with them
04:39:39 <ray> global communication is too common
04:39:51 <Berengal> Indeed, timezones are just messing stuff u
04:39:52 <Berengal> p
04:39:54 <EvilTerran> and daylight savings
04:40:09 <Berengal> Who needs midday to be 12:00 anyway?
04:40:23 <ray> if daylight savings continues to exist, it'll be in the form of people's hours switching in certain times of the year
04:40:30 <Berengal> As long as it's at the same time every day I'm okay with whatever
04:40:32 <ray> it'll just be an employment thing
04:41:04 <ray> we already have utc to standardise on, unless the chinese become the undisputed overlords of the planet and decide they'd prefer their solar noon
04:41:08 <EvilTerran> Berengal, indeed, the choice of when 12:00 (either) occurs is pretty arbitrary
04:41:59 <p_l> UTC is just standard synchronisation timezone :P
04:42:18 * EvilTerran had to stop and think there - i nearly wrote something like "00:00 (am/pm)"
04:42:54 <EvilTerran> it'd make more sense to call it 0 o'clock than 12 o'clock anyway :P
04:43:07 <ray> with global communication being so cheap and easy these days, time zones are a relic
04:43:09 <p_l> and I wish am/pm system died
04:43:32 <EvilTerran> ray, ie, from when it wasn't practical to synchronise to anything other than the sun?
04:43:51 <ray> well, originally, a city or whatever would keep its own time
04:44:12 <ray> time zones came about when people could travel and communicate faster
04:44:23 <ray> i just predict that the same thing will happen to the planet
04:44:39 * p_l is used to local/utc system. UTC for comms and synchronisation, local for "normal" living
04:45:36 * EvilTerran is britain-based, so they're the same half the year
04:45:42 <ray> what with intercontinental communication being too cheap to meter, it'll be streamlined out of existence
04:45:50 <ray> daylight savings is a relic too, nobody lives by the sun
04:46:10 <EvilTerran> (and i'd much rather local and UTC were the same all year round, british time moving off UTC seems to confuse everyone)
04:46:57 <p_l> ray: having two clocks, one showing local, one showing UTC, is fairly common in places that involve rapid change of timezones, and is quite easy to use :)
04:47:04 <gwern> I understand daylight savings no longer saves energy as well
04:47:17 <ray> that's just because most people still use local time, so you need to convert to it sometimes
04:47:24 <EvilTerran> gwern, what with the effort of handling this arbitrary special case, i'm not surprised
04:48:01 <EvilTerran> (thinking from a programming perspective, to try to keep this convo on-topic ;))
04:48:27 <Saizan_> oh, i assumed i was reading #haskell-blah
04:48:32 <EvilTerran> heh
04:48:59 <path[l]> hey what does module Main where mean? why do I need it
04:49:01 <p_l> ray: it's more like "local time is for syncing your biological clock" and "utc is for communication and operations that don't are not dependant on localtime" :)
04:49:08 <EvilTerran> i've not been worrying too much about wandering off-topic, it was pretty quiet otherwise
04:49:10 <ray> well, no
04:49:17 <ray> your biological clock doesn't have any numbers in it
04:49:26 <EvilTerran> path[l], it means the rest of the file is describing the contents of a module called Main
04:49:31 <path[l]> hmm
04:49:42 <path[l]> so any file must have it?
04:49:45 <EvilTerran> path[l], the value Main.main :: IO () is usually used as the program entry point in compiled code
04:49:53 <path[l]> ah ok
04:49:55 <EvilTerran> path[l], it's implicit if you don't specify it
04:50:00 <path[l]> ah
04:50:07 <gwern> wow. starting up songbird takes 3 sh invocations
04:50:08 <EvilTerran> but you need it if you want to work in a module other than Main
04:50:14 <gwern> songbird just lost some points for me
04:50:18 <ray> your biological clock cannot know whether the time that it is now is referred to as "13:00" or "21:00"
04:50:30 <ray> it just knows "hey, you are feeling sleepy in X hours"
04:50:33 <p_l> ray: the biological clock however tends to respond to amount of light around you
04:50:46 <ray> the amount of light has nothing to do with the number on the clock
04:50:50 <gwern> and how much melatonin you've consumed (go melatonin!)
04:50:50 <ray> the number on the clock is an arbitrary name
04:51:14 <ray> there's no need for two arbitrary names just so "twelve" is close to solar noon in one of them
04:51:14 <gwern> but it is nice to have a connection between daylight and hours
04:51:26 <p_l> ray: yes, but your brain would require extensive schema rebuilding in order to drop associations between time of the day and hours
04:51:30 <gwern> so we don't have to look up whether this meal we've been invited to is in the morning, afternoon, or dnner
04:51:31 <ray> there's certainly no biological basis for "twelve"
04:51:34 <gwern> *or is
04:52:03 <EvilTerran> path[l], http://haskell.org/onlinereport/modules.html has the details
04:52:11 <ray> fortunately i'm saying "i predict this will come about naturally", not "i demand this be imposed by governmental fiat on you now"
04:52:14 <path[l]> ah thanks
04:52:30 <ray> i'm not disputing what people's comfort zone is
04:52:30 <gwern> fun. songbird is segfaulting
04:53:04 <EvilTerran> i find it's well worth trying to read the report periodically; I usually spot something fundamental that i didn't already know
04:53:37 <ray> people don't sleep on solar time either, they sleep on social time
04:53:54 * EvilTerran sleeps on his own time, social norms be damned ;)
04:54:14 * Saizan_ sleeps on a different time each day
04:54:17 <EvilTerran> (in terms of time zone, i think i'm in the middle of the atlantic most days)
04:54:40 <Saizan_> but i don't think programmers are representative :)
04:55:02 <ray> "i'm edgy and antisocial" is a social category too, you know
04:55:20 <artagnon> I'm attempting to write a function stemDivisors which, given the prime factors and the number of times each of them occur in a number, will return all the possible divisors of the number. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3384#a3384
04:55:28 <EvilTerran> ray, er... who's edgy and antisocial?
04:55:32 <ray> it doesn't have to synchronise its sleep with other people
04:55:37 <artagnon> I don't get a compile time error
04:55:41 <artagnon> that's a run-time error
04:55:54 <ray> evilterran: free variable
04:56:09 <EvilTerran> i was thinking mid-atlantic-time is a good comprimise between the americas and europe, so good for chatting with english speakers online
04:56:13 <Saizan_> artagnon: that's a compile-time error
04:56:14 <artagnon> and besides, I doubt my code will do what I want. I think I've muddled up quite a lot in my double-recursion attempt.
04:56:30 <ray> what about australians?!
04:56:47 <Saizan_> artagnon: that happens when typechecking the expression "stemDivisors [2, 5, 11] [2, 1, 1]"
04:56:59 <artagnon> Saizan_: ah, right.
04:57:12 <EvilTerran> ray, they're completely opposed to my local time, so aren't practical to try to synch with, i'm afraid
04:57:19 <artagnon> Saizan_: so what's the problem?
04:57:23 <Saizan_> artagnon: you should give a type to your stemDivisors it'll probably won't match with what you have
04:57:27 <artagnon> Saizan_: I've defined it to accept two lists.
04:57:42 <artagnon> Saizan_: ok, I'll try that.
04:57:52 <EvilTerran> artagnon, it's returning a number at "iter 0 = 1"
04:58:05 <EvilTerran> but a list at "(x^n) : stemDivisors xs ys"
04:58:15 <EvilTerran> ?type (:) -- second parameter must be a list
04:58:20 <lambdabot> forall a. a -> [a] -> [a]
04:58:33 <EvilTerran> artagnon, hence, the compiler is complaining that lists aren't numbers
04:58:42 <EvilTerran> "No instance for (Num [t])"
04:59:02 <artagnon> EvilTerran: ah, right. My foolishness :p thanks for pointing that out
04:59:45 <artagnon> New revision: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3384#a3385
05:00:01 <artagnon> ofcourse the code doesn't do what I want, but let me think a bit about that first.
05:02:13 <notsonerdysunny> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3386#a3386 .. hello everybody .. i am a newbie to haskell.. I am trying to read the pasted code and understand it .. can anybody help?
05:02:29 <notsonerdysunny> I particularly want to know what the last line means
05:02:46 <notsonerdysunny> ie char c = [ char c ]
05:03:35 <artagnon> Thanks for everything, everyone. I'll return when I have some better code.
05:04:42 <ray> it's making a singleton list
05:04:52 <ray> > let x = 125 in [x]
05:04:58 <lambdabot>   mueval-core: Prelude.read: no parse
05:04:58 <lambdabot>  mueval: ExitFailure 1
05:05:28 <ray> > let f = id in [f 125]
05:05:31 <lambdabot>   [125]
05:05:49 <ray> i'd probably use (:[]) instead :)
05:06:22 <notsonerdysunny> ray are you answering my question?
05:06:45 <ray> yes
05:07:13 <notsonerdysunny> thanks ..
05:08:14 <ray> > let char c = [char c] in char 'n'
05:08:17 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
05:09:21 <Saizan_> the char on the RHS in the paste is not the same as the LHS
05:09:29 <ray> > let char' = id in let char c = [char' c] in char 'n'
05:09:30 <Saizan_> it's using a different instance
05:09:32 <lambdabot>   "n"
05:09:47 <ray> i don't think i can define a class in lambdabot
05:20:10 <Taejo> > let alternates = map snd . filter fst . zip (cycle [True, False]) in let pairs xs = alternates $ zip xs (tail xs) in pairs [0..]
05:20:12 <lambdabot>   [(0,1),(2,3),(4,5),(6,7),(8,9),(10,11),(12,13),(14,15),(16,17),(18,19),(20,...
05:21:57 <notsonerdysunny> ah .. you are telling me that " char c = [ char c ] " is equivalent to  " char = (:[]) . char "
05:22:12 <Saizan_> notsonerdysunny: yeah
05:24:18 <notsonerdysunny> oh thx ..
05:25:10 <notsonerdysunny> :)
05:30:01 <Philonous> > let true = const; false = const id; if' x = if x then true else false in if ' (2==2) "True" "False"
05:30:03 <lambdabot>   <no location info>:
05:30:03 <lambdabot>      lexical error in string/character literal at chara...
05:30:35 <Philonous> > let true = const in let false = const id in let if' x = if x then true else false in if ' (2==2) "True" "False"
05:30:37 <lambdabot>   <no location info>:
05:30:37 <lambdabot>      lexical error in string/character literal at chara...
05:30:45 <benmachine> stray space
05:30:53 <benmachine> if ' -> if'
05:31:00 <Philonous> > let true = const in let false = const id in let if' x = if x then true else false in if' (2==2) "True" "False"
05:31:04 <lambdabot>   "True"
05:31:07 <Philonous> Thanks
05:32:29 <Berengal> I love the fact that programs are first-class in haskell...
05:33:17 <Berengal> Instead of having STM actions return Eithers or other marker values, I can just have them return the IO action to be run
05:42:28 <Philonous> @let eq :: (forall a. a->a->a) -> (forall a. a->a->a) ->(forall a. a->a->a); eq a b = a b (b false true)
05:42:29 <lambdabot>  <local>:3:15:
05:42:29 <lambdabot>      Illegal operator `.' in type `forall a . (a -> a -> a)'
05:42:29 <lambdabot>  ...
05:47:02 <fbru02> mornin guys !
05:47:21 <fbru02> i have OT question, do u guys recommend to switch from bash to ksh or zsh?
05:47:31 <gwern> not really
05:47:54 <gwern> there are network effects for bash, and most of the features which aren't more trouble to learn & use than they save are already in bash
05:48:03 <gwern> (I used to use zsh until I switched back to bash)
05:48:12 <endojelly> I switched to zsh a few years ago and never looked back
05:48:21 <Berengal> unless you're a heavy scripter you shouldn't care
05:48:28 <dibblego> > let pairs = ap zip tail in pairs [0..]
05:48:30 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,1...
05:48:32 <gwern> indeed. zsh has a few features I miss, but not many
05:49:01 <endojelly> Berengal, I don't know, I especially like zshs interactive features
05:49:17 <Berengal> Heh, even bash has more interactive features than I need
05:49:20 <endojelly> :t in
05:49:21 <lambdabot> parse error on input `in'
05:49:37 <gwern> endojelly: let...in is syntax, not functions
05:49:42 <Berengal> All I need is some job control and the ability to run simple 5-line scripts
05:49:55 <Taejo> > replicateM 5 [True, False]
05:49:56 <lambdabot>   [[True,True,True,True,True],[True,True,True,True,False],[True,True,True,Fal...
05:49:58 <endojelly> gwern, yeah. I forgot that for a moment
05:50:35 <Berengal> @quote zip`ap`tail
05:50:36 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
05:51:13 <fbru02> thanks gwern endojelly Berengal
05:51:41 <gwern> endojelly: although I suppose let..in desugars to lambda expressions, so it's both syntax and functions
05:52:00 <det> What kind of zsh features do people find usefull that bash lacks?
05:52:12 <gwern> det: well, I really liked its url quoter
05:52:30 <gwern> you paste a URL in, and it will recognize the text as a URL and escape characters like '?'
05:52:43 <gwern> very useful for firing up a text browser or downloader
05:52:49 <det> oic
05:52:56 <det> I always use actual quotes
05:53:10 <det> "<paste>"
05:53:26 <malosh> Hi. Does someone know of a library for dealing with units of measure in haskell ?
05:53:30 <det> but sometimes I forget, which is annoying when the shell interprets the "&" incorrectly
05:53:31 <gwern> I don't think quotes protect enough; but it's tedious to have to remember it
05:53:36 <gwern> malosh: yes
05:53:44 <gwern> dimension iirc
05:54:00 <gwern> or there're one or two finance libraries which are units of measure I suppose
05:56:26 <malosh> "dimensional" looks great, thanks
05:56:53 <orclev> ok, so I've got a function I'm going to be passing a data structure consisting of a bunch of Maybe Bool, and I'm trying to figure out a quick way to check for a particular combination of them all being equal
05:57:12 <orclev> I tried something like | b1 == b2 && b2 == b3, but I think the Maybe monad is screwing it up
05:58:09 <Philonous> > Just False  == Just True
05:58:12 <lambdabot>   False
05:58:15 <orclev> hmm
05:58:17 <Philonous> > Just False  == Nothing
05:58:18 <lambdabot>   False
05:58:23 <Philonous> > Just False  == Just False
05:58:24 <lambdabot>   True
05:58:28 <Philonous> Seems to work
05:58:50 <orclev> ok, then my problem is something else
06:01:00 <Taejo> :t when
06:01:02 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:03:57 <Philonous> Is there a fundamental reason why I can't have "instance Foo (forall a. a -> a -> a->)" ?
06:04:20 <Philonous> minus -> *
06:13:54 <Taejo> > groupBy (<=) [1,2,3,1]
06:13:56 <lambdabot>   [[1,2,3,1]]
06:18:50 <endojelly> can someone explain Monad ((->) r) to me?
06:19:56 <Taejo> endojelly: a computation in ((->) r) can be thought of as a computation which has access to some constant value of type r
06:20:08 <Taejo> it's isomorphic to Reader
06:20:15 <endojelly> Taejo, problem is, I don't know what ((->) r) is
06:20:28 <Taejo> endojelly: oh, so it's nothing to do with monads
06:20:35 <endojelly> not yet, no
06:20:52 <Taejo> ((->) r) is a type function, which gives (r -> a) when applied to a
06:21:15 <Taejo> do you understand what I mean by type function?
06:21:23 <endojelly> seems higher order to me
06:21:41 <endojelly> types aren't values in haskell, so i don't really understand
06:22:02 <Taejo> as a more "everyday" example, Maybe is a type-function, that sends a to (Maybe a)
06:22:42 <Taejo> Either is a type-function of two arguments, Either Bool is that function partially applied, and Either Bool Int is that function fully applied
06:24:03 <Taejo> until you get into multi-parameter typeclasses and GADTs, all type-level functions are type constructors like (->), Either and Maybe, and so aren't "interesting" functions
06:24:22 <endojelly> hmm. I begin to understand.
06:24:38 <endojelly> but it's... still hard 8)
06:24:42 <Taejo> yep
06:25:29 <Taejo> I'm not sure I can do much of a better job
06:38:19 <path[l]> how do do blocks work? I just indent and all the lines are in the block?
06:39:08 <endojelly> path[l], yup
06:39:14 <path[l]> ah
06:39:30 <endojelly> path[l], specifically, all lines have to be on the same column as the first token after the do statement
06:39:36 <path[l]> oh ok
06:39:38 <endojelly> if you prefer
06:39:40 <endojelly> do foo
06:39:41 <endojelly>    bar
06:39:42 <endojelly>    baz
06:39:43 <dschoepe> path[l]: yes, if you don't want that you can also use { and ; to structure them manually, by the way.
06:39:44 <endojelly> or
06:39:47 <endojelly> do
06:39:49 <endojelly>   foo
06:39:52 <endojelly>   bar
06:39:54 <endojelly> ...
06:39:56 <path[l]> ah
06:39:57 <endojelly> it's up to you.
06:40:01 <path[l]> ok :)
06:42:20 <smorg> Do any of you use kate and know how to make it indent properly? Or, at least force things to align if it is mistaken about the proper indentation level. Space seems to be a synonym for tab under certain conditions and there is no way to override that behavior for the haskell indentation mode as far as I can tell.
06:42:51 <smorg> yes... I promise to get around to learning vim one of these days.
06:42:58 * smorg is lazy.
06:43:35 <path[l]> oh also what does return do? I think I didnt understand that
06:44:10 <endojelly> path[l], ah. hmm. well, remember that functions inside of a monad have a type that looks like -> m ...
06:44:13 <dschoepe> path[l]: It "lifts" a value into the monad
06:44:28 <endojelly> path[l], for example, mapM is (a -> m b) -> [a] -> m [b]
06:44:34 <path[l]> ok
06:44:36 <endojelly> path[l], they all have to look like that.
06:44:42 <endojelly> path[l], but if you want to just specify a value
06:44:46 <dschoepe> path[l]: so it has nothing to do with the return you know from C or Java.
06:44:48 <endojelly> path[l], you have to "put it into the monad"
06:44:55 <path[l]> I see
06:44:55 <endojelly> path[l], and return does exactly that.
06:45:11 <path[l]> so what am I putting
06:45:13 <path[l]> in mapM
06:45:18 <path[l]> the m?
06:45:19 <endojelly> path[l], so in IO, a "return 5" basically changes the type from Int to IO Int.
06:45:26 <Philonous> path[l]: No, return is really unaptly named
06:45:39 <dschoepe> > return 5 :: Maybe Int
06:45:45 <lambdabot>   mueval-core: Prelude.read: no parse
06:45:45 <lambdabot>  mueval: ExitFailure 1
06:45:53 <roconnor> ??
06:45:57 <dschoepe> > 1
06:45:59 <lambdabot>   1
06:46:03 <roconnor> Just 5
06:46:04 <Philonous> path[l]: I meant to say, no, it has nothing to do with C/Java return
06:46:09 <path[l]> oh ok
06:47:03 <endojelly> > print 5
06:47:07 <lambdabot>   <IO ()>
06:47:14 <endojelly> so lambdabot is in IO
06:47:27 <endojelly> er, bullshit
06:47:57 <elbar> @type return 5 :: Maybe Int
06:47:59 <lambdabot> Maybe Int
06:48:11 <elbar> why does that work and the thing before not?
06:48:23 <dschoepe> > pure 5 :: Maybe Int
06:48:25 <lambdabot>   Just 5
06:48:34 <dschoepe> strange
06:49:07 <Jedai> endojelly: Well it has an IO type and a Monad instance for it but it's not the real one (IIRC)
06:49:45 <endojelly> Jedai, I guess its type doesn't really do anything
06:50:34 <Jedai> endojelly: Not much no, it's not SpecIO (or whatever the name of this controlled IO version
06:50:35 <endojelly> something like data IO a = IO
06:51:38 <endojelly> and bind is just _ >>= _ = IO
06:52:44 <roconnor> > return 5 :: Maybe Int
06:52:46 <lambdabot>   Just 5
06:53:03 <path[l]> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8428#a8428 <--- ok how do I make this do what I expect it to?
06:53:25 <Jedai> endojelly: Something like that yes, look at mueval code if you want to be sure. An interesting alternative would have been to use something like http://hackage.haskell.org/package/IOSpec
06:54:00 <roconnor> [1.. tests] not [1 .. length tests]
06:54:02 <path[l]> I wanna read the number of tests, for each test I want to read the number of connections, for each connection read 2 chars of a tuple. And so get a list of lists of tuples
06:54:06 <path[l]> oh oops
06:54:21 <Jedai> path[l]: first thing, you lack some -> after the \x and \y
06:54:23 <endojelly> Jedai, nifty!
06:54:34 <path[l]> ah
06:54:36 <path[l]> right
06:55:10 <roconnor> remove the "return <-" from "return <- mapM"
06:55:22 <path[l]> oh?
06:55:25 <path[l]> hmm
06:55:32 <roconnor> \x ->
06:55:34 <roconnor> \y ->
06:55:42 <roconnor> you need arrows after the binding name
06:55:51 <path[l]> ok, got them :)
06:55:55 <roconnor> > (\x -> x) 1
06:55:57 <lambdabot>   1
06:56:01 <Jedai> path[l]: also your indentation is in the nested mapM is bad
06:56:41 <Jedai> path[l]: conn, a, b and return should be at the same level
06:56:43 <path[l]> ah spaces vs tabs
06:56:54 <path[l]> I fixed that here now thanks
06:56:55 <roconnor> oh and remove length from length connections too
06:57:00 <roconnor> :)
06:57:02 <Phyx-> path[l]: set your editor to replace tabs by 4 spaces
06:57:03 <roconnor> remove all tabs
06:57:09 <path[l]> The last statement in a 'do' construct must be an expression <--- thats the error I get
06:57:16 <Jedai> path[l]: Just don't use tabs, it's a really bad idea in a language where indentation is significant
06:57:23 <path[l]> yeah makes sense
06:57:23 <roconnor> we need a GHC flag to turn tabs into errors :)
06:57:29 <path[l]> haha
06:57:45 <Jedai> roconnor: you can : fwarn-on-tabs -Werror
06:57:53 <roconnor> oh
06:57:55 <roconnor> awesome
06:57:56 <Jedai> roconnor: or something like that :)
06:57:56 <orclev> hmm... anyone know if vim has a switch to convert tabs to spaces?
06:58:31 <path[l]> still doesnt work :/
06:58:49 <path[l]> but now its a parse error
06:58:49 <mike-burns> It does, but I find it easier to just do: :%s/^I/  /g
06:58:54 <path[l]> on input connections
06:59:03 <Jedai> orclev: a switch I don't know, but it sure can be configured to do that (though I'm not vimist)
06:59:05 <axzs> orclev, http://blog.alanhaggai.org/2008/09/convert-tabs-to-spaces-in-vim.html
06:59:08 <mike-burns> (Where ^I is whatever it takes to get a tab in there. Sometimes ^vTAB .
06:59:18 <mike-burns> )
07:01:23 <path[l]> ok I changed it to use spaces instead of tabs
07:01:28 <mercury^> foldl' and replicate aren't fused?
07:01:58 <orclev> Jedai, axzs, thanks
07:02:31 <orclev> path[l], I took a crack at fixing it up a bit, probably still a lot wrong as I'm a bit of a newbie myself, but I saved a modification to your original
07:02:37 <Jedai> mercury^: No foldl or derivative is fused under the current system
07:02:39 <path[l]> ah
07:02:41 <path[l]> thanks
07:02:56 <mercury^> Jedai: :'(
07:03:02 <Jedai> mercury^: stream fusion should fuse those though, so you can give it a try
07:03:16 <mercury^> Well, I just had a look and it is not fused indeed.
07:03:21 <mercury^> Which sucks hard imo.
07:03:29 <mercury^> Didn't it fuse in the past?
07:03:36 <Jedai> mercury^: Never
07:04:03 <mercury^> So, what is fused if folds aren't?
07:04:21 <Jedai> mercury^: It may fuse in the future if we ever get to integrate stream fusion in the standard library
07:04:45 <Jedai> mercury^: foldr are, as well as a good number of other generating and consuming list functions
07:05:00 <path[l]> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8428#a8431 <--- modified but I now have a type error :/
07:05:37 <Jedai> mercury^: but foldl aren't (they just can't be with the current fusion rules system
07:05:49 <path[l]> hmm wait
07:05:55 <path[l]> its a mistake
07:06:20 <Jedai> path[l]: return mapM secondArgument ?
07:06:32 <Jedai> path[l]: return only takes one argument
07:06:35 * Phyx- still sees tabs in that source
07:06:46 <path[l]> it says it can't match expected type `IO Char' against type `String -> a'
07:07:03 <path[l]> Im only returning (a,b)
07:07:03 <mercury^> Jedai: hmm, seems a bit weird. Intuitively I'd say that foldl is the one that is easy to fuse.
07:07:10 <Phyx-> yeah, i had to remove your tabs first
07:07:17 <Jedai> path[l]: Oh, this one is due to the read for a, you want readLn probably
07:07:28 <Phyx-> path[l]: read isn't IO
07:07:30 <path[l]> a is a char, I just wanted to read one char
07:07:32 <path[l]> oh
07:07:39 <path[l]> readLn reads a whole line right?
07:07:45 <Jedai> path[l]: right
07:07:51 <path[l]> I wanna read a line A B into 2 char variables
07:07:59 <path[l]> a = A, b = B
07:08:01 <Phyx-> @hoogle readChar
07:08:01 <lambdabot> No results found
07:08:04 <Phyx-> @hoogle read
07:08:05 <lambdabot> Prelude read :: Read a => String -> a
07:08:05 <lambdabot> Text.Read read :: Read a => String -> a
07:08:05 <lambdabot> module Text.Read
07:08:17 <Jedai> path[l]: then use getLine words and map read
07:08:23 <path[l]> should I be reading and splitting maybe
07:08:26 <path[l]> hmm
07:08:33 <Jedai> path[l]: right, split with words
07:09:00 <Jedai> [a,b] <- liftM (map read . words) getLine
07:09:03 <Phyx-> or
07:09:05 <Phyx-> just do
07:09:09 <Phyx-> fmap head readLn
07:09:32 <Jedai> Phyx-: That won't work Phyx
07:09:33 <Taejo> :t guard
07:09:34 <Phyx-> since you're only interested in the first char no?
07:09:35 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:09:41 <Taejo> :t filter
07:09:42 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:09:45 <path[l]> Im interested in the first char and 3rd char
07:09:48 <Jedai> Phyx-: you're thinking of getLine, not readLn
07:09:50 <path[l]> not the space inbetween
07:10:01 <Jedai> path[l]: did you see my proposition ?
07:10:05 <Phyx-> @hoogle readLn --info
07:10:05 <lambdabot> Prelude readLn :: Read a => IO a
07:10:06 <lambdabot>  
07:10:06 <lambdabot> The readLn function combines getLine and readIO.
07:10:09 <path[l]> Im trying to understand it =p
07:10:18 <path[l]> I have to look up words
07:10:43 <path[l]> ok words gives me a list of strings
07:10:52 <path[l]> so now I need the head of the first 2
07:10:56 <path[l]> right
07:10:58 <Jedai> path[l]: words just take a string and split it into a list of words (without space into them)
07:10:59 <path[l]> so I can map it
07:11:28 <Jedai> path[l]: Wait a second, you want Chars ?
07:11:30 <path[l]> what does read do there. in read.words
07:11:31 <path[l]> yeah
07:11:36 <path[l]> I want a tuple of 2 chars
07:11:40 <Jedai> Jedai: in this case you don't need read
07:11:47 <Phyx-> lol
07:11:53 <Jedai> path[l]: String is already just a list of Char
07:11:58 <path[l]> yeah
07:12:01 <orclev> path[l], String == [Char]
07:12:22 <orclev> path[l], just use head to get the first char in the list
07:12:30 <mercury^> Anyone with Quad Core wants to test a submission for the programming language shootout?
07:12:43 <Jedai> (a : _ : b : _ ) <- getLine
07:12:50 <orclev> mercury^, why does it need to be a quad core?
07:12:54 <Axman6> mercury^: what's the program?
07:12:57 <mercury^> Because the target is.
07:13:00 <mercury^> An improved fasta.
07:13:25 <path[l]> ooh
07:13:25 <path[l]> thats nice
07:13:27 <mercury^> It already is more than twice as fast as the current program on my dual core, but I'd like to see how it scales.
07:13:44 <orclev> mercury^, ah... what kind of timeframe are you looking at? I've got a quad core but I'd need to reboot my desktop into gentoo
07:13:49 <mercury^> It could probably beat every other program.
07:13:59 <mercury^> orclev: I have time.
07:14:41 <mercury^> Oh and: is there a way to query the number of OS threads the runtime uses? would make it a bit nicer not to have that fixed in the code.
07:15:01 <Phyx-> path[l]: also, your putStrLn length testcase needs to be putStrLn (show (length testcases)) or print (length testcases)
07:15:08 <orclev> mercury^, will a 3.1ghz OCed Core 2 Quad cut it for you? :P
07:15:15 <mercury^> Sure.
07:15:17 <Phyx-> not much, coding
07:15:19 <path[l]> ah I had just changed it to     putStrLn $ show $ length testcases
07:15:29 <Phyx-> yeah, that's possible
07:15:31 <Phyx-> but that's almost print
07:15:34 <Phyx-> @src print
07:15:34 <lambdabot> print x = putStrLn (show x)
07:15:35 <path[l]> ah
07:15:38 <path[l]> ok
07:16:25 <Phyx-> path[l]: also, what's the purpose of the trailing readLn on the top? line 4
07:16:37 <path[l]> I get a blank line of input
07:16:41 <path[l]> between every test case
07:16:46 <path[l]> was trying to eat it up
07:16:52 <Phyx-> ah
07:17:01 <path[l]> it didnt compile so I changed it to dc <- readLn :: IO String
07:17:05 <path[l]> but now I get a user error
07:17:11 <path[l]> that it doesnt parse
07:17:19 <Phyx-> but it needs a type
07:17:25 <Phyx-> yup
07:17:33 <Phyx-> you chould just make that getLine
07:17:41 <path[l]> just getLine?
07:17:45 <path[l]> or dc <- getLine
07:17:55 <Phyx-> since readLn combines getLine and read, but the result of getLine is already a string
07:18:01 <Phyx-> so there's no need for read to be called
07:18:14 <path[l]> ah
07:18:23 <Phyx-> just getLine will do
07:18:25 <path[l]> ok this worked awesome
07:18:32 <Phyx-> and not bindging it to anything if you're not using it
07:18:47 <path[l]> now I have to combine it with the previous code and make sure the whole thing works
07:18:48 <path[l]> lol
07:18:53 <orclev> mercury^, ok, I'm rebooted into gentoo, how do you want to do this?
07:18:57 <path[l]> then make sure it compiles under ghc 6.6.1 >.<
07:19:12 <mercury^> orclev: http://rohanlean.de/pub/fasta.hs
07:19:18 <mercury^> Just test run it against the C program
07:19:29 <mercury^> ghc --make fasta.hs, then run with +RTS -N4
07:19:36 <mercury^> oh, and edit the 2 to a 4
07:19:43 <mercury^> for threadNum
07:20:14 <mercury^> time ./fasta 25000000 +RTS -N4 > /dev/null
07:20:42 <Taejo> what's a good way to get every second element of a list?
07:21:49 <Taejo> anything more elegant than map fst . filter snd . zip (cycle [True, False])
07:22:25 <orclev> where do I change a 2 to a 4?
07:22:26 <path[l]> lol
07:22:32 <mercury^> orclev: threadNum
07:22:32 <orclev> ah, found it
07:22:59 <Phyx-> @pl map fst . filter snd . zip (cycle [True, False])
07:23:00 <lambdabot> map fst . filter snd . zip (cycle [True, False])
07:23:05 <Phyx-> @unpl map fst . filter snd . zip (cycle [True, False])
07:23:06 <lambdabot> (\ c -> map fst (filter snd (zip (cycle [True, False]) c)))
07:23:11 <Phyx-> i suppose not
07:23:12 <Phyx-> :P
07:23:46 <orclev> mercury^, unknown option -N4
07:24:06 <mercury^> Oh, you need to compile with -threaded too
07:24:08 <path[l]> inside a do block, why do I always use <- instead of = ?
07:24:11 <mercury^> --make -threaded
07:24:21 <Taejo> > [('a':), ('b':)] <*> ["foo", "bar", "Baz"
07:24:23 <Taejo> > [('a':), ('b':)] <*> ["foo", "bar", "Baz"]
07:24:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:24:26 <lambdabot>   ["afoo","abar","aBaz","bfoo","bbar","bBaz"]
07:24:33 <mercury^> path[l]: only if the result is monadic
07:24:39 <Phyx-> path[l]: not always, but if the result is an IO monad, you need to bind it, not assign it to something
07:24:40 <Axman6> path[l]: because = means equality.
07:24:49 <path[l]> ah
07:24:50 <mercury^> otherwise you can use let foo = bar (no in)
07:25:11 <Axman6> path[l]: in haskell, whatever is on the left of a = can be replaces with what's on the right
07:25:17 <Phyx-> path[l]: this for instance is valid in a do, let x = 1 + 1
07:25:25 <path[l]> ah
07:25:26 <path[l]> ok
07:25:27 <path[l]> I see
07:25:34 <mike-burns> path[l]: `do x <- foo; bar x' is re-written as `foo >>= \x -> bar x' (which is re-written as `foo >>= bar').
07:25:35 <path[l]> so inside my main block, after doing a series of inputs I can do answer = function question
07:25:42 <path[l]> and then later do putStrLn answer?
07:25:50 <Axman6> path[l]: obviously, x = getLine, y = getLine, the results will almost certainly not be the same
07:25:51 <benmachine> let answer = function question
07:26:03 <orclev> mercury^, where do I find the C implementation to compare against?
07:26:03 <benmachine> you need the let
07:26:09 <path[l]> oh I do?
07:26:11 <path[l]> ok
07:26:31 <mercury^> orclev: http://shootout.alioth.debian.org/u64q/benchmark.php?test=fasta&lang=gcc&id=4
07:26:32 <orclev> mercury^, real 0m16.651s user 0m43.590s sys 0m0.720s
07:26:51 <mercury^> orclev: weird, it runs faster even here
07:27:24 <Taejo> > filterM [False, True] "abcd"
07:27:25 <lambdabot>   Couldn't match expected type `a -> m GHC.Bool.Bool'
07:27:41 <Taejo> > filterM [const False, const True] "abcd"
07:27:42 <lambdabot>   Couldn't match expected type `a -> m GHC.Bool.Bool'
07:27:50 <Taejo> :t filterM
07:27:51 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:27:56 <axzs> that wouldn't be powerset?
07:27:58 <mercury^> orclev: oh, found the culprit
07:28:12 <Taejo> axzs: that's what I'm aiming for
07:28:13 <mercury^> orclev: new version will be up soon, in the meantime you can try the C version
07:28:32 <Taejo> > filterM (const [False, True]) "abcd"
07:28:33 <lambdabot>   ["","d","c","cd","b","bd","bc","bcd","a","ad","ac","acd","ab","abd","abc","...
07:28:33 <axzs> >  filterM (const [True, False]) "Abcd"
07:28:35 <lambdabot>   ["Abcd","Abc","Abd","Ab","Acd","Ac","Ad","A","bcd","bc","bd","b","cd","c","...
07:28:52 <Taejo> > filterM (const [False, True]) "abc"
07:28:54 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
07:28:59 <orclev> yeah, give me a min, trying to figure out the easiest way to get that url you pasted from my laptop to my desktop
07:29:10 <Taejo> not the order I expected, but no matter
07:29:12 <benmachine> > let thing [] = []; thing [x] = [x]; thing (x:y:ys) = x:thing ys in thing [1,2,3,4,5]
07:29:14 <lambdabot>   [1,3,5]
07:29:45 <Taejo> > let thing = map fst . filter snd . zip (cycle [True, False]) in thing [1..5]
07:29:52 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
07:29:52 <lambdabot>    arising from the literal `1'...
07:30:02 <Taejo> > let thing = map snd . filter fst . zip (cycle [True, False]) in thing [1..5]
07:30:04 <lambdabot>   [1,3,5]
07:30:25 <benmachine> up to you which you prefer I suppose
07:31:36 <Taejo> :t mapM
07:31:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:33:04 <path[l]> ok this might be a stupid question, but how do I print the length of a maybe [a]
07:33:12 <orclev> mercury^, c version, real 0m7.960s user 0m7.940s sys 0m0.020s
07:33:17 <Taejo> path[l]: a Maybe [a] doesn't have a length
07:33:33 <mike-burns> :t maybe
07:33:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:33:45 <Taejo> what type does the function you're looking for have?
07:33:49 <mercury^> orclev: new version is up, use the old link.
07:33:58 <path[l]> well Im doing a find on a list of lists
07:34:05 <path[l]> it returns a maybe [a]
07:34:12 <axzs> Taejo, splitEvery in Data.List.Split?
07:34:16 <path[l]> I need to find the length of the return function
07:34:26 <mike-burns> :t fromJust
07:34:28 <lambdabot> forall a. Maybe a -> a
07:34:32 <path[l]> ah
07:34:33 <path[l]> ok
07:34:55 <mercury^> orclev: and don't forget to edit threadNum again.
07:34:55 <path[l]> hmm I have to import fromJust
07:34:56 <Taejo> if you want (Maybe [a] -> Maybe Int), you're looking for fmap length; if you want (Maybe [a] -> Int), (maybe defaultValue length) might be what you want
07:35:02 <Axman6> path[l]: you mean a Maybe [a] right?
07:35:02 <path[l]> which module is it in
07:35:10 <mercury^> orclev: maybe I should fix that before uploading next time. =)
07:35:10 <path[l]> yeah Maybe [a]
07:35:14 <Taejo> path[l]: Data.Maybe
07:35:17 <Axman6> (there is a difference between upper and lower cases)
07:35:35 <path[l]> hmm maybe defaultValue length sounds good too
07:35:50 <path[l]> how would I do that
07:36:05 <Axman6> > maybe 0 length (Just [1..10])
07:36:07 <lambdabot>   10
07:36:08 <EvilTerran> > maybe 0 length Nothing
07:36:10 <lambdabot>   0
07:36:21 <Taejo> > maybe 9000 length Nothing
07:36:22 * Axman6 highfives EvilTerran for teamwork
07:36:23 <lambdabot>   9000
07:36:46 <path[l]> ah
07:36:54 <orclev> mercury^, real 0m7.633s user 0m21.970s sys 0m0.480s
07:37:14 <mercury^> orclev: had hoped it would be a bit more clear, but at least we beat it. :P
07:38:01 <mercury^> If anyone has ideas how to speed it up a bit, please make suggestions.
07:40:38 <Axman6> mercury^: link?
07:40:41 <path[l]> ok I think Im almost done. But I have list and I wanna print each element on a line
07:40:59 <path[l]> mapM (\x ->  do return (print x)) answers'
07:41:00 <mercury^> Axman6: http://rohanlean.de/pub/fasta.hs
07:41:01 <path[l]> doesnt work
07:41:20 <Axman6> path[l]: lose the return
07:41:32 <path[l]> but then its an empty do block?
07:41:37 <Axman6> infact, all you want is mapM_ print answers
07:42:04 <path[l]> oh heh
07:42:11 <path[l]> whats mapM_ ?
07:42:18 <path[l]> as opposed to mapM
07:42:29 <mercury^> just discards the result
07:42:30 <Axman6> it forgets about all the return values
07:42:35 <Axman6> :t mapM_
07:42:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:42:38 <EvilTerran> as such, it can be more efficient
07:42:39 <Axman6> :t mapM
07:42:40 <EvilTerran> ?src mapM_
07:42:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:42:41 <lambdabot> mapM_ f as = sequence_ (map f as)
07:42:43 <path[l]> ah
07:42:46 <EvilTerran> ?src sequence_
07:42:47 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:42:55 <orclev> mercury^, one second, was using the bash builtin time I think, running the real time program seems to give slightly different results, one second while I figure out how to clean up it's output though
07:43:04 <path[l]> got it
07:43:08 <Axman6> path[l]: in IO, it means everything gets run, but you can ignore the useless return values of IO ()
07:43:25 <path[l]> cool
07:44:15 <Berengal> there's also forM, which is mapM with flipped arguments
07:44:18 <Berengal> I tend to use it more...
07:44:28 <Berengal> but mapM is better for currying
07:44:49 <Axman6> yeah, forM is often used like a for loop: forM [1..10] (\x -> do ...)
07:45:06 <path[l]> ah that fixed my other problem. I was getting extra data
07:45:10 <path[l]> oh forM looks nice
07:45:16 <path[l]> let me change my inputs to that
07:45:58 <path[l]> ooops not in scope forM
07:46:08 <Taejo> @pl (\a -> [a, swap a])
07:46:08 <lambdabot> ap (:) (return . swap)
07:46:13 * Twey has never actually used forM
07:46:43 * Taejo uses forM more often, but just used mapM
07:46:51 <orclev> mercury^, if I'm reading this right it looks like the c version is single threaded so it's not exactly an apples vs. apples test... plus it means a straight comparison of the user time value isn't really meaningful
07:46:56 <path[l]> what do I import for forM?
07:47:06 <Twey> Control.Monad, I imagine
07:47:16 <Berengal> or Data.Foldable
07:47:23 <path[l]> ooh hmm ap (:) (return. swap) looks useful to me. But  I cant figure out what it does
07:47:33 <Twey> :t ap
07:47:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:47:43 <jeffwheeler> @type ap (:) (return.swap)
07:47:45 <lambdabot> Not in scope: `swap'
07:47:53 <path[l]> Data.Foldable does not include forM :/
07:48:11 <Phyx-> @index forM
07:48:11 <Twey> :t ap (:) $ return . (undefined :: a -> a)
07:48:11 <lambdabot> bzzt
07:48:12 <mercury^> orclev: Yes, the singlethreaded version of the program runs 1.5 times as long as the C version.
07:48:13 <lambdabot> forall a. a -> [a]
07:48:14 <jeffwheeler> @hoogle forM
07:48:15 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
07:48:15 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
07:48:15 <lambdabot> Text.XHtml.Frameset form :: Html -> Html
07:48:20 <axzs> is foldM a right or left fold?
07:48:24 <orclev> > 21.49 / 4
07:48:25 <path[l]> ah
07:48:26 <lambdabot>   5.3725
07:48:38 <mercury^> orclev: the benchmark allows multithreaded programs, so it's ok to submit that though.
07:48:42 <Axman6> @src foldM
07:48:42 <lambdabot> foldM _ a []     = return a
07:48:42 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
07:48:46 <Berengal> Are there any decent Qt bindings for haskell?
07:49:08 <Twey> Trolltech maintain(s|ed) one themselves, actually
07:49:15 <Berengal> They do? :O
07:49:24 <Twey> http://qthaskell.berlios.de/
07:49:37 <Twey> Last released 2008 â¹
07:49:58 <Twey> I guess Nokia didn't continue supporting it?
07:50:07 <Berengal> Sadly so
07:50:09 <Taejo> path[l]: you might find (\a -> [a, swap a]) easier to read than ap (:) (return . swap). IMO, it's not a very interesting function, but mapM (\a -> [a, swap a]) is (where swap (x, y) = (y, x))
07:50:12 <axzs> Hm, is that left or right fold? Looks right since it's not tail cail, but it seems to join a x from the left.
07:50:47 <path[l]> Taejo: yeah I had that bit, but you're right. I find the older form easier to read
07:51:01 <orclev> mercury^, I wonder how it would perform on an i7, the memory architecture on those is nicer than on my old core 2
07:51:05 <Berengal> The Nokia N900 is looking to become my next phone, and I might want to develop apps for it...
07:51:31 <mercury^> The threads don't communicate a lot.
07:54:41 <path[l]> now to see if I can install ghc 6.6.1 side by side with what I have
07:54:43 <path[l]> ugh
07:55:21 <path[l]> any comments on my complete solution? -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8435#a8435
07:55:32 <path[l]> too many imports, terrible convention, something like that?
07:56:02 <Taejo> @pl \an -> ss ++ ((<>) <$> ss <*> an)
07:56:02 <lambdabot> (ss ++) . ((<>) <$>) . (ss <*>)
07:56:48 <Phyx-> path[l]: why do you need ghc 6.6 anyway? it's very old
07:56:50 <Berengal> Sometimes I have more imports than I do lines of code in a module :/
07:56:56 <skorpan> path[l]: concatMap (flip subseqs xs) [0..(length xs)] !!!!!
07:57:09 <skorpan> perfect example of "flip" being useful
07:57:12 <path[l]> Im working on a problem Im submitting to a site, so umm they only use ghc 6.6.1 lol
07:57:27 <path[l]> skorpan: huh sorry, trying to follow that
07:57:45 <path[l]> ah
07:57:46 <path[l]> I see
07:57:51 <path[l]> damn I missed that trick
07:57:54 <skorpan> flip takes a function and flips its arguments
07:57:58 <skorpan> :t flip
07:58:01 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:58:24 <Berengal> :t flip flip flip
07:58:25 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
07:58:35 <path[l]> heh I submitted and passed \o/
07:58:41 <skorpan> @pl \a b c d e f g -> g f e d c b a
07:58:43 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))))
07:58:47 <axzs> @pl \f m a -> m >>= (\x -> f x a)
07:58:48 <lambdabot> flip ((.) . (>>=)) . flip
07:59:29 <path[l]> I didnt have to install 6.6.1 hurrah
07:59:33 <path[l]> I just put it in and it worked
07:59:54 <path[l]> oh short celebration break and then onto problem 2
08:01:20 <path[l]> aw no congrats huh? oh well
08:01:41 <Phyx-> Berengal: sometimes i have more {-# LANGUAGE 's then lines of code :(
08:01:58 <Berengal> Phyx-, that has happened to me too...
08:02:23 * Phyx- votes that some of these things be merged into the next haskell standard
08:03:03 <Berengal> What we need is a tool that can automatically create import lists
08:03:24 <Phyx-> would be troublesome
08:03:42 <Phyx-> with things like module rexportation etc
08:03:51 <dschoepe> at least for unambiguous cases it would work
08:04:03 <Berengal> There's nothing as annoying as looking for where something's defined
08:04:03 <dschoepe> it could just notify the user of the problematic cases
08:04:27 <Berengal> Anyway, the import list would only contain things that are used in the module
08:04:34 <path[l]> hmm, maybe I should see if I make textmate do it for me.
08:04:39 <path[l]> there's a bundle already
08:05:03 <ray> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> h i t h e r e h a s k e l l e r s
08:05:07 <lambdabot> const . const . const . (const .) . (const .) . (((const .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .)
08:05:07 <lambdabot>  .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .
08:05:07 <lambdabot> ) .) .) . ((((((((const .) .) .) .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((ap .) .) .) .) .) .) . (((((((
08:05:07 <lambdabot> flip .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) .
08:05:10 <lambdabot>  flip (ap . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . flip (flip . (flip .) . ((
08:05:13 <lambdabot> [4 @more lines]
08:05:15 <lambdabot> optimization suspended, use @pl-resume to continue.
08:05:19 <ski> ty
08:05:22 <dschoepe> By the way, can I get cabal to generate a hoogle database for all installed packages?
08:05:23 <ray> good god
08:05:29 <ray> what happened to @pl-resume
08:05:35 <Phyx-> Berengal: i know, but it would also need to do conflic resolutions, or always do specific importing only. eg import foo (bar)
08:05:39 <burp> lol
08:06:16 <Berengal> Phyx-, which conflics would these be? If there were conflicting names, things wouldn't compile anyway
08:06:24 <mreh_> can i make this expression any more concise ? :| isSpaceBar k && down     = s{bullets = (bullets s) ++ newBullet}
08:07:10 <ski> mreh_ : define a functional reference `bullets'
08:07:15 <dcoutts> dschoepe: not yet, nominolo is working on it
08:07:30 <mreh_> ski: it's a field name
08:07:44 <ski> yes, i know
08:07:47 <dschoepe> dcoutts: Ah, nice. Thanks
08:07:55 <burp> @pl-resume
08:08:02 <lambdabot> const . const . const . (const .) . (const .) . (((const .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .)
08:08:02 <lambdabot>  .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .
08:08:02 <lambdabot> ) .) .) . ((((((((const .) .) .) .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((ap .) .) .) .) .) .) . (((((((
08:08:02 <lambdabot> flip .) .) .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .)
08:08:04 <lambdabot>  . flip (ap . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . flip (flip . (flip .) .
08:08:07 <lambdabot> [4 @more lines]
08:08:09 <lambdabot> optimization suspended, use @pl-resume to continue.
08:08:11 <dcoutts> dschoepe: if you want it done quicker then give nominolo a hand
08:08:12 <burp> still not shorter
08:08:13 <ray> @pl \x -> x
08:08:13 <lambdabot> id
08:08:15 <mreh_> who broke lamdabot?
08:08:29 <mreh_> ski: well, that doesn't make it shorter
08:08:35 <mreh_> but cheers for the suggestion
08:08:44 <dschoepe> dcoutts: If I had the skill to do that, I certainly would :)
08:08:55 <mreh_> or more readable eve
08:08:59 <mreh_> even*
08:09:25 <ski>   isSpaceBar k && down     = modifyFRef bullets (++ newBullet) s
08:09:43 <dcoutts> dschoepe: anyone can help with testing, if it's got to that stage yet
08:09:57 <Phyx-> Berengal: yup, that's what i mean, if it imports two modules that export the same function, it should hide one of them, or always just do implicit importing.
08:10:34 <dschoepe> dcoutts: yes, I can certainly help with that, but the cabal code/module structure looked quite daunting to me when I tried to add a feature a while a ago.
08:11:02 <dcoutts> dschoepe: did you read the developer intro guide?
08:11:29 <Berengal> Phyx-, oh like that. Just put it in the first import list. Don't import things twice
08:11:35 <dcoutts> dschoepe: http://hackage.haskell.org/trac/hackage/#StartingpointsfornewCabalhackers
08:11:52 <mreh_> ski: oh, like that
08:12:15 <dschoepe> dcoutts: no, I guess that would've helped. Perhaps after reading that I could implement my rather simple feature instead of my current solution(simply hardcoding the behavior I want).
08:12:17 <Taejo> > [id, (+1)] <*> [1..]
08:12:21 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:12:31 <dcoutts> dschoepe: which is?
08:12:31 <ski>   modifyFRef :: FRef a b -> (b -> b) -> (a -> a)
08:12:54 <Taejo> > map (flip ($)) [1..] <*> [id, (+1)]
08:12:56 <ski>   newtype FRef a b = MkFRef {unFRef :: a -> (b,b -> a)}
08:12:56 <lambdabot>   [1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,1...
08:13:05 <dschoepe> dcoutts: Support for other haddock flags when running cabal install with documentation enabled. (name hyperlinkSource)
08:13:10 <dschoepe> s/name/namely/
08:13:35 <dcoutts> dschoepe: ah yes, the problem there is what the right design is, from a UI perspective. Once we work that out the code is easy.
08:14:04 <dcoutts> dschoepe: so if you can work out a coherent UI for that stuff (command line flags, config file, intended behaviour) then that's the biggest step
08:14:18 <ski> > [1..] <**> [id, (+1)]
08:14:19 <lambdabot>   [1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,1...
08:14:40 <dschoepe> dcoutts: Okay, I'll give it a try, but I can't promise anything.
08:15:44 <dcoutts> dschoepe: great
08:15:55 <ray> @pl \x n -> mod <$> (pure x) <*> [1..n]
08:15:56 <lambdabot> ((mod <$>) .) . (. enumFromTo 1) . (<*>) . pure
08:17:22 <EvilTerran> mod <$> pure x = pure (mod x)
08:17:54 <EvilTerran> and pure a <*> b = a <$> b
08:18:04 <EvilTerran> @pl \x n -> mod x <$> [1..n]
08:18:05 <lambdabot> (. enumFromTo 1) . (<$>) . mod
08:18:21 <pikhq> Aren't those the defining properties of applicative functors?
08:18:37 <ray> > let f = (. enumFromTo 1) . fmap . mod in f 150 10
08:18:39 <lambdabot>   [0,0,0,2,0,0,3,6,6,0]
08:18:47 <EvilTerran> pikhq, either that or they're derivable from 'em; i was trying to simplify the expression with them
08:19:51 <ray> sometimes i say @pl but i mean @simplify and @pl is just the closest thing the bot has
08:20:12 <orclev> mercury^, LOL, just looked up the statistics on that game you're entering, ruby is like half as fast as every other language out there on the median
08:20:54 <mercury^> Yeah, ruby has a very bad implementation.
08:20:57 <pikhq> EvilTerran: Fair enough.
08:21:33 <ray> > let f x n = mod x <$> [1..n] in f 150 10 -- this is probably most readable
08:21:35 <lambdabot>   [0,0,0,2,0,0,3,6,6,0]
08:21:44 <EvilTerran> much like it seems to me that larry wall has never formally studied language design, it also seems to me that matz has never formally studied language implementation
08:21:47 <ray> i started with liftA2
08:22:15 * EvilTerran would write (x `mod`) over mod x
08:22:17 <orclev> mercury^, I knew it had a bad rep as being piggish, but I had also heard a lot of that was because RAILS is implemented really really badly and that's more or less all anyone uses it for, I didn't realize the actual language implementation was that bad
08:22:36 <halhorn1> And Guido van Rossum has never studied curly braces ;-) [ pythonista here]
08:22:43 <ray> yeah, i started with liftA2 mod, which is why it's not in backticks
08:23:23 <EvilTerran> halhorn, eh, python strikes me as a language devised by someone who knew what they were doing
08:23:38 <halhorn> EvilTerran: Yeah, it's an absolute joy to tinker around with.
08:23:46 <orclev> halhorn, I've been fending off the python cult for years because using whitespace as a block delimiter always put me off, but after seeing Haskell I might reform
08:23:49 <ray> python is designed by someone who knows what he's doing, but whether the thing that he's doing is right is arguable
08:23:53 <EvilTerran> perl, ruby, and (god forbid) php? less so.
08:24:05 <ray> if there's a problem with python, though, indentation is very much not it
08:25:51 <mercury^> I always like perl code when I look at it.
08:26:32 <orclev> I used to write perl... really like CPAN and the doc system, but the language itself was sort of the best of a bad situation
08:28:32 <Taejo> @src permutations
08:28:32 <lambdabot> Source not found.
08:28:58 <skorpan> @src perms
08:28:59 <lambdabot> Source not found. Take a stress pill and think things over.
08:29:26 <orclev> how come it did that?
08:35:07 <path[l]> I heard haskell has some special approach to solving backtracking problems. Is this true?
08:36:32 <Makoryu> path[l]: The List monad, you mean?
08:36:35 <mercury^> path[l]: it's called List monad.
08:36:49 <dschoepe> path[l]: there's also a logic monad that automatically backtracks
08:36:55 <path[l]> heh ok. I guess I should read up about these
08:36:59 <dschoepe> (similar to prolog)
08:37:07 <path[l]> which is better for beginners?
08:37:12 <dschoepe> lists
08:37:26 <path[l]> cool
08:37:49 <path[l]> let me read up :)
08:37:53 <pikhq> Lists by a long shot. You can really easily grasp its use, and slightly less easily grasp its implementation.
08:38:10 <dschoepe> you can, of course, also implement backtracking the "normal" way.
08:38:33 <Phyx-> you mean... lists aren't the normal way :O
08:38:54 <dschoepe> using lists in a monadic way isn't "normal", at least not outside of Haskell
08:42:42 <ski> dschoepe : what's the "normal" way ? using CPS ?
08:44:22 <path[l]> cps?
08:44:48 <ski> Continuation Passing Style
08:45:20 <path[l]> ah
08:46:31 <Phyx-> actaully, using cps is another approach no?
08:47:00 <ski> than what ?
08:47:25 <dschoepe> ski: I thought of explicit recursion. I meant "normal" as "the way you would do it in C", as path[l] comes from an imperative background.
08:47:29 <Phyx-> for backtracking
08:47:36 <path[l]> yeah
08:47:42 <Phyx-> haven't we all?
08:47:56 <Phyx-> very few people start with functional languages right?
08:48:05 * ski is not sure how one "would do it in C", except either using continuations or lazy lists ..
08:48:20 <Makoryu> Phyx-: Arguably an accident of history
08:48:26 <Phyx-> nasty pointer tricks :P
08:48:30 <Phyx-> Makoryu: how so?
08:48:37 <path[l]> well basically just nested loops?
08:48:44 <pikhq> ski: Manual compilation of a functional language, in effect?
08:48:58 <ski> pikhq : if you wish
08:49:05 <path[l]> I wrote a back tracking solver for sudoku in ruby. Wanna try rewriting it in haskell
08:49:19 <path[l]> there in ruby I used recursion and I had a sort of stack like thing
08:49:25 <path[l]> I wanna learn the haskell way
08:50:20 <Phyx-> Makoryu: lol, an accident that most start with imperative?
08:50:36 <Phyx-> lol, I remember when they told me i had to learn haskell
08:50:44 <Phyx-> i was like "hm say what? no for loops?"
08:50:49 <Makoryu> Phyx-: Imperative languages were first on the scene. And then FP only recently started getting footholds in the industry, so there was always pressure to teach "real" languages so students would be ready to serve their PHBs
08:51:01 * ski started with BASIC, then (6502) assembler
08:51:08 <pikhq> Makoryu: *cough* Lisp is the oldest language still in common use. ;)
08:51:11 * Phyx- started with vb
08:51:13 * Phyx- hides
08:51:32 <dschoepe> pikhq: FORTRAN is older and still in use
08:51:33 <Berengal> pikhq, FORTRAN isn't too uncommon either
08:51:46 <burp> pikhq: fortran
08:51:48 <pikhq> dschoepe: I thought Fortran was like a year newer?
08:51:57 <orclev> pikhq, bah, real men do it in assembly :P
08:52:06 <burp> but well, not the original fortran
08:52:09 <Berengal> FORTRAN is a few years older than lisp
08:52:16 <pikhq> Fortran, 1957. Lisp, 1958.
08:52:19 <pikhq> Okay, then.
08:52:23 <araujo> morning
08:52:26 <path[l]> who is they phyx
08:52:32 <dolio> Nobody uses the original lisp, either.
08:52:39 <Berengal> "I don't know what language will be used for numeric computations in the future, but it'll be called FORTRAN" - some guy
08:52:45 <pikhq> Lisp is still freaking old, but that's quite tangential to the conversation.
08:52:49 <Makoryu> pikhq: Lisp and Fortran are the oldest *high level* languages still in use
08:53:01 <pikhq> Makoryu: Ah, right. Darned assemblers and Forth.
08:53:03 <Berengal> Makoryu, are there any low-level languages still in use?
08:53:13 <pikhq> Berengal: Assembly, Forth.
08:53:21 <Berengal> How old is forth?
08:53:24 <Makoryu> Berengal: I don't think the assemblers of the 1950s are much use today
08:53:25 <pikhq> 70s.
08:53:31 <Makoryu> And, no, Forth is not *that* old
08:53:43 <Phyx-> path[l]: hm?
08:53:46 <Phyx-> they?
08:53:50 <Berengal> Every assembly language is different
08:53:55 <Phyx-> oh
08:53:56 <path[l]> they who told you to learn haskel
08:54:01 <pikhq> I suspect an assembler for IBM mainframes would be quite useful.
08:54:08 <Berengal> and not in an evolutionary way either, unlike high-level languages
08:54:12 <pikhq> Given that the architecture is still in use. ;)
08:54:12 <Phyx-> path[l]: functional languages is part of our CS course
08:54:13 <Makoryu> Berengal: Yeah. My point was just that imperative assembly languages predated the original Lisp
08:55:09 <orclev> closest thing to standard asm is nasm
08:56:26 <path[l]> ah
08:56:30 <orclev> of course, by the same token almost no language still in use is fully compatible with the "original" version, at least not without having to use some compatibility flags
08:56:39 <path[l]> you studying in the UK?
08:57:06 <orclev> path[l], who?
08:57:30 <path[l]> phyx
08:58:14 <pikhq> orclev: K&R C is still quite usable on GCC.
08:58:21 <pikhq> GCC just shouts at you for doing it.
08:58:48 <Berengal> java is fully backwards compatible, I think
08:59:14 <pikhq> Yeah, it is.
08:59:30 <Makoryu> Berengal: Ironic, because the JVM itself is not
08:59:36 <Berengal> not that is has changed much since it's original design...
08:59:56 <Phyx-> path[l]: no, netherlands
09:00:08 <orclev> pikhq, I know it has compatibility flags for K&R C, but I'm not entirely sure if you need to use them or not to be able to compile all of K&R C
09:00:20 <path[l]> ok
09:00:58 <orclev> java is sort of backwards compatible... not that it really matters as none of the standard libraries are even remotely compatible anymore
09:01:22 <pikhq> orclev: It turns off newer features.
09:01:54 <axzs> anyone know good papers on fold?
09:02:15 <Berengal> Not just turns them off, but they can be intermixed with old code somewhat seemlessly
09:02:22 <axzs> tutorial on expressibility, TMR 6, functional programming with bananas, lenses... any other important ones?
09:06:27 <Phyx-> hmmm
09:06:34 <dolio> You should read The Under-Appreciated Unfold.
09:06:34 <dolio> Although I don't really recall how good it is.
09:06:39 <Phyx-> would HappStack work well for a webbased game?
09:08:17 <Phyx-> or rather, HAppS
09:10:23 <Phyx-> and the world goes quiet
09:10:50 <orclev> Phyx-, my guess is the question is too subjective
09:13:15 * Berengal is about to learn happstack now
09:13:45 <Phyx-> orclev: but i was looking for subjective answers, if everyone is of the same opinion i might skip it, lol
09:14:16 <Berengal> happstack is relatively low-level, no?
09:14:34 <dcoutts> axzs: I find the bananas is a very hard read, and I know what it's going on about
09:14:37 <Berengal> In some ways that can be useful
09:15:14 <Phyx-> Berengal: dunno, never used it
09:15:24 <dcoutts> axzs: "A tutorial on the universality and expressiveness of fold" http://www.cs.nott.ac.uk/~gmh/fold.pdf
09:15:57 <Berengal> Phyx-, at the top level it's just a list of paths to programs (which may themselves be a list of paths to programs)
09:16:39 <dcoutts> axzs: and for the unfold, "Proof methods for structured corecursive programs" http://www.cs.nott.ac.uk/~gmh/methods.pdf
09:16:52 <axzs> thanks
09:17:03 <axzs> I'm writing a blog post about folds
09:17:49 <Cale> axzs: Have you seen my diagrams?
09:17:58 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
09:18:01 <axzs> on haskell.org?
09:18:16 <axzs> Oh, yes. I'll link to them too.
09:19:00 <dcoutts> axzs: from what kind of perspective? the universal properties of fold and unfold are rather nice once you see the significance and where they come from
09:19:14 <Phyx-> Berengal: a list of paths to programs? as in a lookup directory?
09:19:30 <Phyx-> makes sense, takes a url -> page
09:19:39 <Berengal> Phyx-, basically. This is what http is all about, really
09:19:55 <dcoutts> Cale: nice diagrams, I'd not seen those before
09:20:37 <Phyx-> Berengal: http yes, but i'm assuming HAppStack allows me to do server side scripting in haskell?
09:20:50 <Berengal> Phyx-, that's the program part
09:21:18 <orclev> ye old CGI revisited
09:22:02 <Berengal> Phyx-, actually, the top level is just a list of programs producing pages, but most of the time the programs are wrapped in small programs returning 404 unless the path is right. They're all monoids, so these are placed in an mconcat'ed list
09:22:23 <Phyx-> hmmm
09:22:50 <Berengal> Obviously returning the first non-404 program...
09:24:01 * Phyx- has a nasty habbit of stopping to work on a project once the interesting/hard part is done
09:24:06 <Phyx-> need to fix that...
09:24:25 <Berengal> You saying you don't like boring things?
09:24:30 <Berengal> And it needs to be fixed?
09:24:55 <Phyx-> Berengal: yeah, since most things are boring!
09:25:09 <Berengal> Phyx-, or most things need to be made more interesting
09:25:21 <Berengal> I don't know, but I've heard LCD helps
09:25:30 <Berengal> LSD*
09:25:35 <Gracenotes> whoo. I've just translated my kanji components graph to HTML/Canvasi! Only problem is I didn't do node ordering or position, so it looks .. uh .. unreadable
09:25:41 <Phyx-> hehehe,
09:25:44 <Gracenotes> uh, canvas.
09:25:52 <Phyx-> Berengal: i was thinking what a liquid crystal display could do
09:26:26 <Berengal> Phyx-, well, fancy graphics. Can be made both hard AND interesting
09:26:39 <Phyx-> hmm
09:26:47 <axzs> any ideas for a name of a haskell blog? :)
09:27:00 <Phyx-> is there any library for haskell, to enter full screen exclusive mode? prolly some OGL bindings..
09:27:16 <mercury^> Hmm, turns out I was trying to be too smart. The program is 1.5 times as fast with a linear search compared to a binary search tree.
09:27:46 <ski> even on large enough inputs ?
09:28:02 <mercury^> the lists are known in advance and rather small
09:28:10 <mercury^> But I thought even then it should be faster.
09:28:17 * ski notes that he has no idea what mercury^ is doing
09:28:27 <mercury^> ski: http://rohanlean.de/pub/fasta.hs
09:28:30 <Gracenotes> small.. like 10-20 elements?
09:28:34 <mercury^> that's an old version still using the binary trees.
09:29:27 <Harsenic> Hi, I'm reading the 'Learn you a haskell' guide, and I'm a little confused by curried functions
09:29:45 <Berengal> mercury^, make the tree strict help any?
09:30:02 <mercury^> I tried that many revisions back, didn't help then.
09:30:07 <mercury^> So I doubt it helps now.
09:30:23 <Phyx-> Berengal: this was my first gtk2hs program, lol http://www.cs.uu.nl/wiki/pub/Afp/UnstableAPI/unstab2.png
09:30:24 <Harsenic> http://codepad.org/NDuAWhvp # Could someone help me understand exactly what is happening here?
09:31:05 <Berengal> Harsenic, you need to realize, young grasshopper, that there are no curried functions. Only functions from tuples to values, and function from a single value to function from a single value to a value
09:31:24 <Gracenotes> Harsenic: if it helps a bit, the way the second line is interpreted is: addThree = (\x -> (\y -> (\z -> x + y + z)))
09:31:44 <Gracenotes> Berengal: the compiler laughs at you
09:32:06 <Berengal> Phyx-, heh. Looks more fancy than anything I've written. I must be even lazier than you
09:32:06 <Harsenic> Hmm, wait so. How exactly does x and y get into z?
09:32:11 <ski> `addThree' is a function, that when given a number returns a function, that when given a number returns a function, that when given a number returns a number
09:32:17 <Harsenic> Oh
09:32:38 <ski>   addThree :: Num a => (a -> (a -> (a -> a)))
09:32:50 <Phyx-> Berengal: well, it was being graded, that kinda forces you to finish it, though i didn't finish the animations though, only a handfull got done
09:32:58 <ksf> that's unsuspected winnitude.
09:32:59 <lambdabot> ksf: You have 1 new message. '/msg lambdabot @messages' to read it.
09:33:03 <Berengal> Gracenotes, I 'splode it's brain from time to time as well to get back at it, but in general our relationship works out just fine
09:33:21 <ksf> you can actually use the same record selector for two different kinds of the same data type.
09:33:31 <Harsenic> So like, addThree 3 4 5 becomes \3 -> \4 -> \5 -> 3 + 4 + 5 ?
09:33:33 <axzs> Harsenic, remember x -> y -> z means x -> (y -> z). This is a function that takes x, and returns another function that takes y and gives z.
09:33:39 <Phyx-> Berengal: the actual project descriptiion is here http://www.cs.uu.nl/wiki/bin/view/Afp/UnstableAPI
09:33:59 <Gracenotes> Harsenic: well, once you substitute x with 3, you don't need the \x anymore
09:34:01 <axzs> Harsenic, those \x -> are removed. It simply becomes 3+4+5
09:34:17 <Berengal> Phyx-, ah, yes, the external motivator. I just finished a two-month java project thanks to it :/
09:34:25 <mercury^> Oh, I guess having a binary search tree caused many branch mispredictions.
09:34:27 <mercury^> That explains it.
09:34:31 <ski> Harsenic :  addThree 3 4 5  =  (\x -> \y -> \z -> x + y + z) 3 4 5  =  (\y -> \z -> 3 + y + z) 4 5  =  (\z -> 3 + 4 + z) 5  =  3 + 4 + 5
09:35:26 <Phyx-> Berengal: hehehe, those are great aren't they :P everything should have one
09:35:41 <Phyx-> preferably... monetary
09:35:43 <Harsenic> Oh, so it's kindof like. When \z returns a function to take 4, it returns a function which already knows about 3 that returns another function which waits for 5 which knows about 3 and 4, then adds them? Kindof?
09:36:16 <Berengal> Phyx-, monetary works well in my case. I now have a steady job thanks to that
09:36:43 <Phyx-> :)
09:36:48 <ski> Harsenic : first the function `\x -> \y -> \z -> x + y + z' is "fed" with `3', and returns `\y -> \z -> 3 + y + z'
09:37:01 <Harsenic> Ahhhh, yeah that makes sense
09:37:02 <Harsenic> Thank you
09:37:10 <ski> Harsenic : `addThree 3 4 5' means `((addThree 3) 4) 5'
09:37:27 <Harsenic> Ok
09:37:38 <Gracenotes> the function "addThree 3 4" is equivalent to \z -> 3 + 4 + z..
09:39:03 <mmorrow> @djinn DJ (DJ a o) a -> DJ (DJ o a) (DJ (DJ o a) a)
09:39:18 <lambdabot> No output from Djinn; installed?
09:39:29 <mmorrow> looped! (?)
09:39:58 <Gracenotes> it's entered an endless recursion of time
09:40:23 <Harsenic> Ok so, just one last question then, (3+) = \x -> 3 + x
09:40:30 <Harsenic> ?
09:40:35 <Berengal> Yup
09:40:35 <mmorrow> right
09:40:36 <Phyx-> yes
09:40:42 <Harsenic> Fuck yes, I feel like a king right now
09:40:43 <Harsenic> Thanks
09:40:48 <mmorrow> @unpl (3+)
09:40:48 <lambdabot> (\ a -> 3 + a)
09:40:58 <mmorrow> @pl \x -> 3 + x
09:40:59 <lambdabot> (3 +)
09:41:02 <EvilTerran> Harsenic, operator sections are awesome, aren't they?
09:41:28 <mmorrow> @pl \a b c -> a + b + c
09:41:28 <lambdabot> ((+) .) . (+)
09:41:44 <mmorrow> @unpl ((+) .) . (+)
09:41:44 <lambdabot> (\ d g -> (+) (d + g))
09:41:46 <Harsenic> Aye, I feel awesome. I'm going to go around beating the life out of some innocent person so they know how much better than them I am
09:41:50 <EvilTerran> > map ($ x) [(+1), (*2), (^2)]
09:41:57 <lambdabot>   mueval-core: Prelude.read: no parse
09:41:57 <lambdabot>  mueval: ExitFailure 1
09:42:00 <EvilTerran> ...
09:42:14 <mmorrow> @type x
09:42:15 <Harsenic> Rofl
09:42:15 <Berengal> > 5 + 7
09:42:21 <lambdabot> Expr
09:42:21 <lambdabot>   mueval-core: Prelude.read: no parse
09:42:21 <lambdabot>  mueval: ExitFailure 1
09:42:27 <Harsenic> Somethings broken
09:42:28 <Berengal> I think lambdabot needs a reboot
09:42:29 <EvilTerran> , map ($ 3) [(+1), (*2), (^2)]
09:42:31 <lunabot>  [4,6,9]
09:42:33 <benmachine> sounds like it
09:42:41 <mmorrow> maybe that djinn query is still spinning
09:42:42 <EvilTerran> Cale?
09:42:48 <benmachine> @undefine
09:42:52 <benmachine> or
09:42:57 <benmachine> something.
09:43:01 <EvilTerran> @bot
09:43:01 <lunabot>  :)
09:43:01 <lambdabot> :)
09:43:07 <Berengal> mmorrow, possible, "no output" doesn't mean it's killed
09:43:14 <benmachine> > x
09:43:22 <EvilTerran> Berengal, i'd expect "Terminated." if it were killed
09:43:23 <lambdabot>   mueval-core: Prelude.read: no parse
09:43:27 <lambdabot>  mueval: ExitFailure 1
09:43:27 <benmachine> > 1
09:43:38 <lambdabot>   mueval-core: Prelude.read: no parse
09:43:41 <lambdabot>  mueval: ExitFailure 1
09:43:44 <EvilTerran> @vixen are you okay?
09:43:45 <lambdabot> i truely am
09:43:46 <Berengal> > 'a'
09:43:47 <Harsenic> Ok, thanks guys. I'll be back later I guess, going to continue reading but I don't like being in a java IRC client.
09:43:51 <EvilTerran> @vixen really?
09:43:51 <lambdabot> really!
09:43:53 <lambdabot>   mueval-core: Prelude.read: no parse
09:43:53 <lambdabot>  mueval: ExitFailure 1
09:44:05 <EvilTerran> hm. i guess she's in denial.
09:44:06 <Phyx-> > toDec undefined
09:44:12 <lambdabot>   mueval-core: Prelude.read: no parse
09:44:12 <lambdabot>  mueval: ExitFailure 1
09:44:14 <mmorrow> > fix error
09:44:15 <Berengal> @vixen are you in denial?
09:44:15 <lambdabot> yes, i am
09:44:20 <EvilTerran> hehe
09:44:20 <lambdabot>   mueval-core: Prelude.read: no parse
09:44:21 <lambdabot>  mueval: ExitFailure 1
09:44:59 * EvilTerran notes the paradox inherent in that reply
09:45:03 <jfoutz> @djinn a -> a
09:45:03 <lambdabot> f a = a
09:45:13 <jfoutz> @pl id . id
09:45:13 <lambdabot> id
09:45:16 <jfoutz> > 1
09:45:22 <lambdabot>   mueval-core: Prelude.read: no parse
09:45:22 <lambdabot>  mueval: ExitFailure 1
09:45:23 <ski> @djinn ()
09:45:23 <lambdabot> f = ()
09:45:30 <mmorrow> @djinn DJ (DJ a o) a -> DJ (DJ o a) (DJ (DJ o a) a)
09:45:45 <lambdabot> No output from Djinn; installed?
09:45:52 * mmorrow pours salt in the wound :)
09:45:55 <Phyx-> > seq undefined 1
09:45:59 <jfoutz> > )
09:46:02 <lambdabot>   mueval-core: Prelude.read: no parse
09:46:02 <lambdabot>  mueval: ExitFailure 1
09:46:05 <lambdabot>   mueval-core: Prelude.read: no parse
09:46:05 <lambdabot>  mueval: ExitFailure 1
09:46:08 <Phyx-> hmm lambdabot sure is slow
09:46:11 <Phyx-> today
09:48:14 <benmachine> slow, and nonfunctional
09:51:30 <Phyx-> omg, who killed lambdabt!
09:51:30 <therp> code.h.o. down?
09:51:35 <Gracenotes> it is imperative that it responds faster
09:51:52 <Phyx-> the world depends on it!
09:55:35 <EvilTerran> Gracenotes, it's imperative that lambdabot become more functional? :P
09:56:14 * SamB_XP_ wonders what template you use to mark a statement in wikipedia as needing an example ...
09:58:33 <axzs> http://monoidal.blogspot.com/ Here's my first Haskell blog post. Comments welcome.
10:05:50 <mercury^> orclev: mind taking the latest version for a spin?
10:05:52 * copumpkin is doing too much type-level crap
10:08:15 <Gracenotes> copumpkin: time for your JavaScript break! -.-
10:08:36 <Phyx-> did you just say javascript?
10:08:37 <copumpkin> noez, I must write this typeclass for great justice!
10:09:06 <arw> axzs: nice.
10:09:14 <Phyx-> for great justice? but who would watch the watchers?
10:09:14 <arw> axzs: good article.
10:10:27 <EvilTerran> Phyx-, javascript's pretty good, imo
10:11:48 <EvilTerran> it's formally pretty simple, and has lambdas
10:12:04 <Gracenotes> right now I'm using JavaScript to draw on a 30000x2000 pixel <canvas>
10:12:07 <pikhq> It's just much-abused.
10:12:12 <Gracenotes> and it's still too cluttered :(
10:12:15 <pikhq> And the DOM isn't great.
10:12:46 <EvilTerran> yeah, not so fond of the libraries, just the language
10:12:57 <EvilTerran> i guess i should be saying "ECMAScript", in that case
10:13:05 <copumpkin> dammit these instances should overlap but they appear to
10:13:35 <copumpkin> shouldn't
10:13:35 <ski> s/appear to/appear not to/ ?
10:13:49 <Gracenotes> I am working on a node-ordering algorithm to reduce the number of crossings :D In Haskel, which JS will use
10:14:54 <Gracenotes> god, it's 1 PM already
10:16:21 <Gracenotes> what have I been doing with my day..
10:16:57 <arw> i wish it was 1pm over here. swap?
10:18:40 <copumpkin> aha, there we go
10:19:15 <Phyx-> EvilTerran: i just don't like any dynamically typed language
10:19:24 <Gracenotes> indeed.. why not
10:20:30 <Phyx->  /set timestamp_format %H:%M:%S
10:20:33 <Phyx-> oops
10:20:46 <benmachine> %H:%M:%S == %T :P
10:21:00 <Phyx-> really?
10:21:04 <Gracenotes> *high-five, fellow %H:%M:%S user*
10:21:10 <Phyx-> lol
10:21:14 <Phyx-> *high-five
10:22:02 <benmachine> I seem to recall on windows that %T didn't work
10:22:05 <benmachine> or something odd like that
10:22:15 <Phyx-> nah it works
10:22:15 <benmachine> but yeah man date says %T is %H:%M:%S
10:22:32 <Phyx-> 19:21:53 timestamp_format = %T
10:22:33 <Phyx-> 19:22:00 -!- Irssi: Saved configuration to file /cygdrive/c/irssi/./config
10:23:53 <Phyx-> hasn't been an irssi update in ages
10:24:04 <Phyx-> heh, i say that and see that .14 is out
10:25:00 <benmachine> I have python installed in wine, and strftime('%T') gives an empty string there
10:25:04 * benmachine shrugs
10:25:11 <benmachine> just One Of Those Things, I suppose
10:25:16 <Phyx-> lol
10:25:25 <Phyx-> maybe it's wine?
10:25:29 <benmachine> maybe
10:26:13 <Phyx-> erm... how the heck do these http://irssi.org/news/ChangeLog merrit a new release?
10:28:09 <benmachine> well if you have a slow development process then you should do small releases, otherwise minor annoyances build up unnecessarily
10:28:58 <BMeph> Haskell is dynamically typed. ;)
10:29:09 <Phyx-> according to the dev page, there are atleast 6 developers
10:29:18 <Phyx-> all they do is fix aliases?
10:29:41 <Phyx-> BMeph: huh?
10:29:54 * benmachine works on a project with about 8 developers of whom no more than 2 ever seem to actually work at the same time
10:30:19 <benmachine> (it was my turn this morning, now I'm slacking for another four days or so)
10:30:27 <Phyx-> rofl
10:30:42 <Phyx-> i need to get me a job like that
10:30:53 <benmachine> it's not a job :P just an OSS project
10:31:43 <BMeph> Phyx-: Look up the definition - Haskell is dynamically typed. It's very strongly typed, but by "the rules", it's dynamically typed, too. :)
10:32:18 <jungehexe> lambdabot: > map (+1) [1..10]
10:32:34 <benmachine> "A programming language is said to be dynamically typed, or just 'dynamic', when the majority of its type checking is performed at run-time as opposed to at compile-time."
10:32:37 <c_wraith> Haskell isn't dynamically typed by my defintion:  The type of all variables is known at compile time
10:32:39 <benmachine> that doesn't sound like haskell
10:32:59 <EvilTerran> c_wraith, well, not *all* variables
10:33:00 <benmachine> jungehexe: I think lambdabot has a headache
10:33:15 <BMeph> benmachine: Where'd you get that def?
10:33:16 <Phyx-> BMeph: afaik, tyep checking is done at compile time in haskell
10:33:36 <jungehexe> benmachine: hi, i just was trying to learn how to communicate with it
10:33:37 <pikhq> EvilTerran: The type of all variables is known if you count type classes. :P
10:33:44 <benmachine> BMeph: google opinted me to wikipedia
10:33:48 <EvilTerran> existential quantification / higher-rank types / GADTs / Data.Dynamic can muddy the waters
10:34:08 <benmachine> jungehexe: well, the usual way is just > expr, but I think it's broken in some way
10:34:11 <benmachine> > 2 + 3
10:34:13 <lambdabot>   5
10:34:15 <benmachine> oh
10:34:16 <benmachine> it isn't.
10:34:27 <benmachine> it was earlier!
10:35:03 <c_wraith> :t read . show
10:35:07 * copumpkin is doing type voodoo
10:35:08 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
10:35:13 <BMeph> Funny, the one is use is the second line: "In dynamic typing, types are associated with values not variables."
10:35:41 <pikhq> BMeph: ... There's a difference between the two?
10:35:44 <pikhq> :P
10:36:05 <Phyx-> BMeph: i wouldn't say that's the biggest classification point of a dynamic language
10:36:11 <jungehexe> benmachine: thanks, i found out only private chat with  lambdabot
10:36:54 <BMeph> pikhq: Haskell determines types at compile time. But the types go with the values, not the variables. So, depending on which characteristic is "THE" definition, Haskell could qualify as being dynamically typed! ;)
10:37:33 * jungehexe a total newbie in irc :(
10:37:42 <pikhq> BMeph: But a variable is nothing more than a name assigned to a value!
10:37:43 <BMeph> Phyx-: But a dynamic language is more than just a dynamically typed language. They're two different animals. :)
10:37:45 <pikhq> ;)
10:37:48 <benmachine> BMeph: it doesn't really count because haskell doesn't have variables
10:38:22 <benmachine> or, it has variables but they aren't variable
10:38:24 <michaelfeathers> People use 'dynamic language' as a shorthand for 'dynamicaly-typed language' though
10:38:32 <benmachine> unless you look at IORefs and MVars, which are statically typed
10:38:55 <BMeph> copumpkin: "You do that voodoo that you do so well!" :)
10:39:18 <Phyx-> lol
10:39:28 <mee> I've also heard that term (mis-)used to refer to languages which support reflection, so don't worry if you're confused by how you see it used on the web
10:39:38 <copumpkin> I'm trying to encode all the algebraic class properties at the type level
10:40:35 <BMeph> This could be helped along, if we just had a PL that was both dynamic, and strongly-typed. I've only heard rumors of such a beast, though. :)
10:41:14 <michaelfeathers> > let waypoints pos contents = takeWhile (<= pos) . scanl1 (+) . map ((+1).length) . lines $ contents
10:41:18 <lambdabot>   not an expression: `let waypoints pos contents = takeWhile (<= pos) . scanl...
10:41:23 <dschoepe> BMeph: Isn't python strongly typed?
10:41:34 <BMeph> copumpkin: You mean "at the type FAMILY level", right?
10:42:01 <copumpkin> BMeph: not sure what the difference is, but I definitely use lots of type families to make stuff happen
10:42:04 <mee> dschoepe: nope
10:42:24 <dschoepe> mee: this says otherwise: http://wiki.python.org/moin/PythonVsHaskell
10:42:32 <Gracenotes> dschoepe: def blah(x): x.foo()... any type can be passed x, and it'll work without a hitch if it has foo() in it
10:42:32 <dschoepe> "Both Haskell and Python have strong (not weak) typing, meaning instances of a type cannot be cast into another type."
10:42:53 <benmachine> dschoepe: that's kind of odd
10:42:55 * BMeph has been poking around oleg's "We could implement typeclass behaviour, if we just had one class, that all types were in" post
10:43:01 <Adamant> BMeph: most modern dynamic languages are strongly typed
10:43:03 <dschoepe> Gracenotes: isn't that rather static vs. dynamic typing, not weak vs. strong?
10:43:06 <Gracenotes> I suppose that's more on the dynamic end of things.
10:43:34 <mee> dschoepe: oh, I was wrong then, sorry about that
10:43:38 <benmachine> python doesn't really have typing
10:43:40 <Phyx-> @ 2 + 2.0
10:43:44 <Phyx-> > 2 + 2.0
10:43:45 <benmachine> and whatever typing it has, it does at runtime
10:43:46 <lambdabot>   4.0
10:43:51 <copumpkin> :t 2
10:43:52 <copumpkin> :t 2.0
10:43:52 <lambdabot> forall t. (Num t) => t
10:43:54 <lambdabot> forall t. (Fractional t) => t
10:43:57 <Gracenotes> types are really no more than tags in Python, effectively. You can't change a value's tag, and I suppose that makes it strong.
10:43:58 <Phyx-> > 2 + 2.4
10:43:59 <lambdabot>   4.4
10:44:05 <Phyx-> > 2f + 2.4
10:44:06 <Adamant> benmachine: yes it does, unless you are one of the "tagging != typing" folks
10:44:06 <lambdabot>   Add a type signature
10:44:17 <Phyx-> > 2f + 2.4f
10:44:18 <lambdabot>   Add a type signature
10:44:21 <benmachine> Gracenotes: but one type can behave like another
10:44:26 <Phyx-> > 2f + 2.4f :: Float
10:44:28 <lambdabot>   No instance for (GHC.Real.Fractional (a1 -> GHC.Types.Float))
10:44:28 <lambdabot>    arising fr...
10:44:38 <Phyx-> does that work in haskell?
10:44:41 <Phyx-> :t 2f
10:44:43 <lambdabot>     Ambiguous type variable `a' in the constraint:
10:44:43 <lambdabot>       `SimpleReflect.FromExpr a'
10:44:43 <lambdabot>         arising from a use of `f' at <interactive>:1:1
10:44:49 <Phyx-> o.O
10:44:52 <benmachine> :t f
10:44:53 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
10:45:01 <copumpkin> :t 2 f
10:45:03 <lambdabot>     Ambiguous type variable `a' in the constraint:
10:45:03 <lambdabot>       `SimpleReflect.FromExpr a'
10:45:03 <lambdabot>         arising from a use of `f' at <interactive>:1:2
10:45:06 <benmachine> f is defined in lambdabot's memory
10:45:10 <benmachine> > f x
10:45:11 <Gracenotes> benmachine: I suppose you could say that functions are not strongly typed, but values are
10:45:11 <lambdabot>   Add a type signature
10:45:17 <benmachine> > f x :: Expr
10:45:17 <Gracenotes> in Python
10:45:19 <lambdabot>   f x
10:45:43 <Gracenotes> BMeph: anyway, for your original query, C# is adding support for dynamic variables
10:45:53 <BMeph> Strengely, I like how Lua's typing and implementation work. I get a perverse thrill with seeing integers done in floating-point... >;)
10:46:04 <Gracenotes> like JavaScript's var, but the values are strongly typed in the C# fashion
10:46:07 <benmachine> Gracenotes: it depends what a type is... eg. if a function says it wants a tuple and I give it a class with a __getitem__ defined, and it works, what does that mean for the typesystem?
10:46:10 <Gracenotes> it's not default, though
10:46:33 <benmachine> a class instance, I mean
10:47:58 <Gracenotes> maybe it would be fair to say that all values have a set-in-stone type, even if that type is just a tag, and functions effectively don't
10:48:18 <benmachine> I suppose so
10:49:29 <Phyx-> Gracenotes: i'm actually strongly oppose to the new dynamic typing support in c# 4.0
10:49:40 <Phyx-> it's something that would surely be abused
10:49:57 <Gracenotes> still doesn't answer the question :P
10:49:58 <Phyx-> and you'd end up with large parts with nothing to do with com using dynamic typing
10:50:17 <BMeph> Phyx-: ...and that's a bad thing? ;)
10:50:35 <Phyx-> well yes, i would consider that extremely bad
10:50:55 <Phyx-> dynamic typing always introduces more problems than their worth in my experience
10:51:24 <Phyx-> benmachine: ah, that's why
10:51:37 <dschoepe> Gracenotes: otoh, you can also pass around functions as values in python, so they probably also have a fixed type "function". (Just guessing)
10:52:33 <benmachine> dschoepe: class instances can behave like functions if they have a __call__ method
10:53:38 <dschoepe> benmachine: so, those instances and functions still have types(/tags), just less descriptive ones than in Haskell.
10:54:16 <benmachine> dschoepe: mm, but from the perspective of the programmer I think that python should be treated like it doesn't have types
10:54:21 <Berengal> Python's functions have a type defined by what arguments they take
10:54:33 <Berengal> Well, how many
10:55:00 <benmachine> Berengal: only as much as they have a type defined by what code they contain
10:55:05 <dschoepe> benmachine: practically yes, but technically it still is a strongly-typed language.
10:55:21 <mmorrow> haskell functions/data don't have any types at runtime other than CONSTR_2_1, FUN, PAP, etc to tell the gc where the pointers are (among other things)
10:55:23 <dschoepe> (at least for my definition of "typed")
10:55:26 <dcoutts> dschoepe: right, so it tells you when you're wrong
10:55:32 <dcoutts> just not at compile time
10:56:32 <benmachine> Berengal: I bet it's possible to write a python function that makes it virtually impossible to determine the number of arguments it takes by raising randomly-generated TypeErrors
10:56:43 <benmachine> (that actually sounds like a lot of fun)
10:56:46 <dschoepe> benmachine: Actually, I think it still makes sense to think in types when writing a python program, even when you don't see them at compile time.
10:56:49 <Berengal> benmachine, no, you can always use reflection to ask it
10:56:50 <benmachine> oh no it wouldn't work
10:57:12 <c_wraith> Python functions can be written to take any number of args using *args anyway
10:57:29 <c_wraith> it's always fun to write something foo(*args, **kwargs)
10:57:47 <Berengal> c_wraith, I use that all the time in python
10:58:00 <c_wraith> you use it all the time for wrapper functions
10:58:11 <Berengal> Not just wrappers
10:58:14 <c_wraith> true
10:58:31 <c_wraith> But it's almost impossible to write a wrapper function that's any good without doing it
10:58:37 <Berengal> things like map and zip also benefit from it
10:59:45 <luite> hm, can someone please restart the book.realwordlhaskell.org server? :p
11:00:06 <c_wraith> @seen dons
11:00:07 <lambdabot> dons is in #haskell-in-depth, #yi, #xmonad, #ghc, #haskell, #arch-haskell, #concatenative and #darcs. I last heard dons speak 19h 4m 23s ago.
11:00:41 <c_wraith> He's one of the authors, though that doesn't mean he has any administrative access to the server
11:03:11 <uninverted> Is there any standard function that takes a list of functions and a list of values and applies the functions to them ([a -> b] -> [a] -> [b])? It would be trivial to write, but it seems generally useful.
11:03:27 <dschoepe> zipWith ($)
11:03:40 <dschoepe> > zipWith ($) [(+1),(+2)] [1,2]
11:03:44 <lambdabot>   [2,4]
11:04:08 <uninverted> dschoep: That's char for char how I did it earlier :-)
11:04:29 <mmorrow> > zipWith id [(+1),(+2)] [1,2]
11:04:30 <lambdabot>   [2,4]
11:05:03 <dschoepe> uninverted: ah, so you want that to have a special name?
11:05:31 <uninverted> dschoep: Pretty much, I was just wondering if it was in the library.
11:05:33 <axzs_> it is ap if you regard lists as applicatives
11:05:36 <gwern> c_wraith: iirc, the server is run by bos
11:05:40 <axzs_> not in the normal way
11:05:50 <c_wraith> gwern: that's handy to know.  thanks
11:05:50 <benmachine> > ap [(+1), (+2)] [1,2]
11:05:52 <lambdabot>   [2,3,3,4]
11:06:01 <ski> > getZipList (ZipList [(+1),(+2)] <*> ZipList [1,2])
11:06:03 <lambdabot>   [2,4]
11:06:14 <mmorrow> @quote aztec
11:06:15 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
11:06:50 <mmorrow> , (zip`ap`tail) [0..]
11:06:51 <lunabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11...
11:07:00 <uninverted> > :t ap
11:07:02 <lambdabot>   <no location info>: parse error on input `:'
11:07:08 <Elly> :t ap
11:07:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:07:35 <uninverted> Heh, I usually just keep another prompt open.
11:09:29 <mmorrow> , , ap(++)show"ap(++)show"
11:09:30 <lunabot>  luna: parse error on input `ap'
11:09:32 <mmorrow> , ap(++)show"ap(++)show"
11:09:33 <lunabot>  "ap(++)show\"ap(++)show\""
11:09:55 <Philonous> Is there something fundamental preventing instance declarations like "instance Foo (forall a. a -> a -> a)" ?
11:10:18 <axzs_> uninverted, check those two links: http://www.brics.dk/RS/01/10/BRICS-RS-01-10.pdf and http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
11:10:28 <benmachine> so I hear there's this BlockedOnDeadMVar excpetion but newEmptyMVar >>= takeMVar doesn't trigger it
11:11:02 <uninverted> axzs_: Thanks, these look interesting.
11:12:08 <mmorrow> benmachine: it will if that's the only thing happening in your program (i.e. no other threads active)
11:12:37 <mmorrow> benmachine: e.g. main = newEmptyMVar >>= takeMVar
11:13:18 <mmorrow> well, that may not be a "BlockedOnDeadMVar" exception
11:13:20 <mmorrow> not sure
11:13:41 <mmorrow> "a: thread blocked indefinitely"
11:14:02 <benmachine> mmorrow: I did that exact main and it just blocked forever
11:14:11 <benmachine> I waited for eternity to elapse to be sure
11:14:15 <mmorrow> benmachine: compiled code?
11:14:16 <benmachine> but it still didn't do anything
11:14:19 <mmorrow> which ghc version?
11:14:21 <benmachine> mmorrow: runhaskell stdin
11:14:22 <ManateeLazyCat> dcoutts: What's GTk/Glib/Pango version that binding in gtk2hs-0.10.1 ? I binding vte.h, it said "can't find glib.h gtk.h pango.h", I mean which version i need download? Speical version that gtk2hs-0.10.1 use or version that current system use?
11:14:29 <mmorrow> benmachine: ah, yeah that's not compiled code
11:14:33 <benmachine> oh ok
11:15:13 <dcoutts> ManateeLazyCat: gtk2hs can bind pretty much any version of gtk+
11:15:16 <mmorrow> benmachine: http://darcs.haskell.org/ghc/utils/runghc/runghc.hs
11:15:46 <dcoutts> ManateeLazyCat: so it will build against whatever version of gtk+ your system uses
11:15:52 <orclev>  #xmonad
11:15:54 <orclev> doh
11:16:42 <ManateeLazyCat> dcoutts: I see, i need copy missing header file to current directory for c2hs pre-process?
11:17:12 <orclev> ok, dumb newbie question time... I've got a string, and I want to filter a substring out of it, what's the simplest/best way to do that?
11:17:22 <dcoutts> ManateeLazyCat: I don't know what header files you are talking about
11:17:40 <benmachine> mmorrow: so it basically runs it in ghci?
11:17:51 <mmorrow> benmachine: heh, right. a hack if you ask me.. :)
11:18:14 <benmachine> fair enough
11:18:23 <dcoutts> ManateeLazyCat: "gtk.h" is ambiguous. Are you referring to the system gtk/gtk.h (usually installed in /usr/include/gtk-2.0) ?)
11:18:28 <c_wraith> orclev: just based on indices into the string?
11:18:45 <ManateeLazyCat> dcoutts: I'm binding vte.h, and in vte.h it need glib.h gtk.h pango.h, so i need copy those header in directory contain vte.h ?
11:18:55 <mmorrow> that's pretty inefficient to do with a String (== singly linked list)
11:18:59 <mmorrow> @orclev
11:18:59 <lambdabot> Unknown command, try @list
11:19:05 <orclev> c_wraith, no, like I've got a string "foo" and I want to remove all instances of it from a string "some stuff foo, blah whatever foo"
11:19:24 <benmachine> mmorrow: success
11:20:02 <orclev> mmorrow, if necessary I can convert the strings into some other structure, but at the end of the day I need to return a string
11:20:18 <dcoutts> ManateeLazyCat: are you referring to the fact that /usr/include/vte/vte.h does #include <glib.h>; #include <gtk/gtk.h>; #include <pango/pango.h>; but when you use the /usr/include/vte/vte.h those other headers cannot be found?
11:21:14 <ManateeLazyCat> dcoutts: Oh, i copy vte.h to another directory.
11:21:32 <dcoutts> ManateeLazyCat: I don't recommend doing that
11:21:38 <mmorrow> orclev: ah, ok. i know there're some algorithms to do that efficiently then, not sure what they are though off the top of my head
11:22:00 <orclev> mmorrow, I'm not so worried about efficient as I am quick and simple to implement
11:22:02 <jfoutz> @hoogle Applicative f => (a -> f b) -> (b -> f c) -> a -> f c
11:22:03 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
11:22:03 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
11:22:03 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
11:22:06 <mmorrow> orclev: i'd guess propbably the same/similar to what regular expressions use
11:22:19 <ManateeLazyCat> dcoutts: So you create Vte.chs in directory /usr/include/vte/ ?
11:22:26 <mmorrow> orclev: oh, then something like
11:22:34 <ManateeLazyCat> dcoutts: I mean when you binding, you always create file under /usr ?
11:22:42 <ManateeLazyCat> /us/include/ ?
11:23:03 <dcoutts> ManateeLazyCat: no, the system header files exist already
11:23:13 <mmorrow> orclev: err, well you'd just run over the String, and for each Char check if the rest of the String starts with the to-filter-out word
11:23:18 <dcoutts> ManateeLazyCat: /usr/include/vte/vte.h exists
11:23:38 <mmorrow> O(length-of-input * length-of-to-filter-out-string)
11:23:46 <ManateeLazyCat> dcoutts: I know, "c2hs /usr/include/vte/vte.h /mydirectory/Vte.chs".
11:24:40 <dcoutts> ManateeLazyCat: so the problem is that you're not using the right -I dirs
11:24:55 <dcoutts> ManateeLazyCat: vte.h needs to find other stuff
11:24:56 <mmorrow> @let dropPrefix [] xs = xs; dropPrefix _ [] = []; dropPrefix (x:xs) (y:ys) | x==y = dropPrefix xs ys | otherwise = y:ys
11:25:01 <lambdabot>  Defined.
11:25:19 <dcoutts> ManateeLazyCat: check pkg-config --cflags vte
11:25:23 <orclev> mmorrow, I was thinking I could avoid regular expressions, but now that I'm looking at it I'm probably going to need them after all because it's not a simple word all the time
11:25:55 <benmachine> > dropPrefix "foo" "blah fo blee foo bar"
11:25:59 <lambdabot>   "blah fo blee foo bar"
11:26:04 <mmorrow> orclev: you could alternatively just use whatever algorithm they'd use for that if you wanted, but not sure if that'd be easier in the end
11:26:04 * benmachine blinks
11:26:21 <mmorrow> > dropPrefix "asdf" "asdfghjk"
11:26:23 <lambdabot>   "ghjk"
11:26:38 <mmorrow> so you'd need to do that more than once..
11:27:10 <burp> > map toLower "ABCD"
11:27:12 <lambdabot>   "abcd"
11:27:19 <burp> is there any map toLower defined somewhere?
11:27:34 <orclev> > dropPrefix "asdf" "asdghjk"
11:27:36 <lambdabot>   "ghjk"
11:27:41 <burp> before I define lower myself ;)
11:27:45 <orclev> thought so
11:28:06 <c_wraith> hehe.  that implementation is mildly broken, yes
11:28:15 <c_wraith> You might just be best off using regular expressions
11:28:19 <mmorrow> orclev: dropPrefix is the first step, then you'd need to repeatedly dropPrefix over the entire length of the String, removing the first character when dropPrefix returns the same String
11:28:31 <c_wraith> In terms of amount of work you need to do
11:28:36 <mmorrow> right, it
11:28:37 <mmorrow> s
11:28:39 <mmorrow> O(length-of-input * length-of-to-filter-out-string)
11:28:56 <mmorrow> which is why singly-linked lists are bad for this :)
11:29:04 <orclev> yeah, I'm going for regex... although looking through everything on the haskell implementation of it gives me a major headache
11:29:44 <sm> the regexpr lib is simpler
11:32:23 <mmorrow> oh right, and that dropPrefix is borked too :)
11:33:21 <orclev> sm, looking at regexpr lib I think it will do what I need with a minimum of me beating my head against something hard
11:34:35 <sm> works well for me
11:35:16 <sm> it seems to be locked in (?m) mode, if I understand correctly
11:38:28 <orclev> lol, I don't think english is the native language of whoever wrote that library though, it just complained my regex is "uncorrect"
11:38:54 <copumpkin> maybe he intended uncorrect to be a self-descriptive word
11:38:59 <sm> I think it's a good word :)
11:39:23 <copumpkin> a fixpoint of the identity word
11:39:26 <copumpkin> or something like that :P
11:42:17 <monochrom> You are ungood.
11:42:37 <copumpkin> :(
11:42:40 <copumpkin> doubleplus?
11:43:38 <gwern> hm. this is unfortunate GC behavior
11:43:56 <monochrom> I was extending the "uncorrect" theme.
11:44:09 <gwern> when I force gitit to handle the output of multiple 'darcs changes', the memory usage can blow up to 50% or more of wiki.darcs.net's RAM
11:44:10 <monochrom> "Your regex is doubleplusuncorrect"
11:44:13 <ManateeLazyCat> dcoutts: I run "sudo c2hs --include=/usr/include/gtk-2.0/ /usr/include/vte/vte.h Vte.chs", c2hs still report can't "gtk/gtk.h". "gtk/gtk.h" under "/usr/include/gtk-2.0/"
11:44:20 <orclev> nice, Text.RegexPR did it for me, and in a really simple way too... unwords $ filter ((/=) "") $ splitRegexPR "foo" "String to foofilter"
11:44:24 <gwern> is there any +RTS option that will force gitit to not use so much RAM?
11:44:54 <gwern> either by limiting how much it can ever take, or forcing it to return RAM when done with a page request?
11:45:18 <dcoutts> ManateeLazyCat: does /usr/include/gtk-2.0/gtk/gtk.h actually exist? (and why are you using sudo!)
11:45:22 <mmorrow> gwern: that seems like something gitit itself is doing rather than the RTS
11:45:42 <gwern> mmorrow: no, we're pretty sure that each request is independent and that gitit isn't holding onto stuff
11:45:45 <dcoutts> gwern: you can limit the size of the heap
11:45:50 <mmorrow> gwern: :o
11:46:11 <gwern> mmorrow: this may be the whole ghc-never-returns-memory-to-the-OS bug I once saw
11:46:24 <gwern> dcoutts: what happens if gitit reachs the heap limit? does it die?
11:46:47 <benmachine> gwern: but even if ghc wasn't returning memory to the OS, it should surely be returning memory to itself?
11:46:54 <dcoutts> gwern: as it gets close it switches to compacting gc, but yes if eventually it runs out then you get heap overflow
11:47:06 <ManateeLazyCat> dcoutts: Yes, it exist, sudo for give permission to command in Debian-base OS.
11:47:07 <mmorrow> gwern: yeah, ghc doesn't return memory (it mmaps pages on demand, but never munmaps them)
11:47:22 <dcoutts> ManateeLazyCat: the sudo should be completely unnecessary
11:47:37 <ManateeLazyCat> dcoutts: c2hs: permission denied
11:47:46 <gwern> hm. I wonder whether compacting gc would force memory reuse and so we would never hit the limit but just slow down how fast requests are served
11:47:53 <mmorrow> gwern: but if you limit the heap size, instead of using a lot of memory you'll just crash
11:47:54 <benmachine> chmodding c2hs would seem more sensible
11:48:23 <dcoutts> ManateeLazyCat: I think you'd better paste the message that c2hs gives when it complains about gtk/gtk.h
11:48:31 <gwern> mmorrow: no way to know but to try
11:48:44 <ManateeLazyCat> dcoutts: ok
11:48:46 <mmorrow> gwern: to know what?
11:48:50 <Athas> How, if at all, do you handle memory allocation errors in Haskell programs?
11:48:59 <gwern> whether compacting gc will help and not lead to gitit crashes
11:49:13 <mmorrow> gwern: oh, yeah definitely
11:49:18 <orclev> Athas, fix ghc?
11:49:22 <Phyx-> lol
11:49:23 <dcoutts> gwern: I'm not sure whether or not HeapOverflow gets thrown when you run out of heap
11:49:41 <dcoutts> gwern: if it does then you'd be ok, you'd just loose that one client request
11:49:45 <dcoutts> loose/fail
11:50:00 <Athas> orclev: I'm not sure "my computer ran out of free memory" should be considered a GHC bug.  I may have misphrased, I'm interested in handling memory allocation failures.
11:50:07 <mmorrow> dcoutts: yeah iirc you just crash with "out of heap"
11:50:32 <dcoutts> mmorrow: there is an AsyncException for it, but yeah I wasn't sure that it actually gets used
11:50:52 <gwern> let's see, so I want +RT -c -M64000000 -RTS
11:50:56 <gwern> give it 64megs
11:51:06 <dcoutts> gwern: you can use 64m :-)
11:51:08 <orclev> Athas, ah, well, assuming the program is running as intended, you would rewrite the program to not require so much memory... if I remember there was something about foldr I think it was that's incredibly memory intensive on large lists
11:51:11 <veinor> bug report: ghc does not give my computer infinite ram
11:51:16 <gwern> dcoutts: but but the docs say bytes!
11:51:16 <mmorrow> dcoutts: oh maybe if not caught you crash, but even if you caught it i'm not sure that you could do anything useful (?)
11:51:16 <orclev> or maybe it was foldl...
11:51:17 * ManateeLazyCat pasted "sudo c2hs --include=/usr/include/gtk-2.0/ /usr/include/vte/vte.h Vte.chs" at http://paste2.org/get/395792
11:51:21 <ManateeLazyCat> dcoutts: Above
11:52:09 <mreh_> I've stuck an otherwise as the last guard statement, and I'm still getting "non-exhaustive pattern" from the runtime
11:52:11 <Athas> orclev: well, even just requiring a single machine word will be too much if there is no free memory at all.  I'm just looking for alternatives to having my program go down in flames.
11:52:37 <Athas> orclev: in languages with manual memory control, I'd allocate a static buffer I could use for "gracefully" bailing out.
11:52:43 <dcoutts> ManateeLazyCat: you're confused about what --include does, and you're not using all the include dirs that vte needs, check pkg-config --cflags vte
11:53:02 <dcoutts> ManateeLazyCat: see c2hs --help and/or the user manual
11:53:23 <orclev> Athas, something like that is a bit beyond my experience level, I'm very much a haskell newbie myself... maybe you can register some sort of hook to execute on OOM errors?
11:53:28 <benmachine> Athas: there are StackOverflow and HeapOverflow exceptions, but apparently GHC doesn't currently use the latter
11:53:38 <orclev> ah, there you go
11:53:45 <orclev> ghc bug :P
11:53:54 <ManateeLazyCat> -I/usr/include/freetype2 -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include -I/usr/include/gtk-2.0 -I/usr/include/pango-1.0 -I/usr/lib/gtk-2.0/include -I/usr/include/atk-1.0 -I/usr/include/cairo -I/usr/include/pixman-1 -I/usr/include/libpng12
11:53:54 <ManateeLazyCat>  
11:54:00 <c_wraith> orclev:  out of a sense of perversity, the naive implementation of what you first asked for would look like this:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8436#a8436
11:54:04 <mmorrow> benmachine: i think it does, but if you catch it the fact that you're screwed doesn't change :)
11:54:11 <dcoutts> ManateeLazyCat: yes, I know :-)
11:54:13 <benmachine> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#t%3AAsyncException
11:54:18 <c_wraith> It's O(length src * length tgt)
11:54:27 <c_wraith> Which is probably slower than what you ended up with
11:54:28 <c_wraith> :)
11:54:44 <veinor> I wonder if it's possible to express a balanced-parens test function in haskell using foldl/foldr.
11:55:02 <orclev> c_wraith, thanks, and you're right, that's perverse :P
11:55:06 <gwern> > 64 / 512
11:55:09 <lambdabot>   0.125
11:55:22 <gwern> ok, so I shouldn't see more than 13% in top...
11:55:24 <copumpkin> sure
11:55:33 <copumpkin> veinor: just pass a "stack" as your state
11:55:36 <copumpkin> and check that it's empty
11:55:45 <mmorrow> Athas: what's a "memory allocation error"?
11:55:48 <veinor> that's what I'm thinking
11:55:48 <benmachine> copumpkin: how does that handle "flib)" though?
11:55:52 * ManateeLazyCat pasted "c2hs command" at http://paste2.org/get/395795
11:56:01 <ManateeLazyCat> dcoutts: Above command still can't work.
11:56:04 <gwern> 2.9...3....11.3...and it's gone
11:56:07 <ManateeLazyCat> dcoutts: Wrong format?
11:56:09 <gwern> dcoutts: guess it crashes
11:56:21 <benmachine> copumpkin: probably a Maybe stack would be more useful
11:56:27 <copumpkin> benmachine: or just pass an integer around
11:56:30 <gwern> 140.211.1gitit: internal error: scavenge_mark_stack: unimplemented/strange closure type 0 @ 0xa7f9ad64 (GHC version 6.10.3 for i386_unknown_linux) Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
11:56:31 <dcoutts> ManateeLazyCat: see c2hs --help and/or the user manual
11:56:32 <copumpkin> that you increment and decrement
11:56:32 <EvilTerran> veinor, if you're only matching one type of parens, your "stack" need only be a counter with some way of indicating failure
11:56:35 <EvilTerran> Maybe Int, say
11:56:36 <Athas> mmorrow: I meant an allocation failure.  The obvious failure would be running out of memory.
11:56:41 <benmachine> copumpkin: how does *that* handle "flib)"? :P
11:56:42 <veinor> EvilTerran: That's what I was thinking
11:56:44 <orclev> hey, what's the lambdabot command to ask for the link to docs?
11:56:50 <gwern> now to try just -c
11:56:53 <copumpkin> benmachine: well, you could still do Maybe on it
11:56:57 <dcoutts> ManateeLazyCat: --include does not do what you think it does
11:57:01 <benmachine> I suppose so
11:57:09 <benmachine> orclev: which docs?
11:57:17 <mmorrow> Athas: ah, ok. well if you're out of memory there isn't really anything you can do. so the solution is not to run out of memory.
11:57:17 <orclev> module
11:57:31 <benmachine> @where google
11:57:31 <lambdabot> I know nothing about google.
11:57:32 <EvilTerran> veinor, foldM may be in order, incidentally
11:57:32 <benmachine> >>
11:57:33 <benmachine> er
11:57:35 <benmachine> >_>
11:57:40 <skorpan> :t >_>
11:57:42 <lambdabot> parse error on input `>'
11:57:45 <dcoutts> gwern: I've been wondering about this resource issue lately too
11:57:46 <skorpan> :t (>_>)
11:57:47 <copumpkin> EvilTerran: how so?
11:57:49 <lambdabot> parse error on input `)'
11:57:53 <Athas> mmorrow: I'm not convinced that such a thing is really a solution, but I suppose I have no choice.
11:57:58 <EvilTerran> copumpkin, in the Maybe monad
11:58:03 <copumpkin> ah
11:58:04 <mmorrow> Athas: e.g. in C, a stack overflow causes a segfault. if you catch SIGSEGV, what are you to do?
11:58:04 <orclev> I saw someone in the xmonad channel use it, so I know it's possible... something like @go
11:58:21 <benmachine> mmorrow: longjmp, usually
11:58:27 <Phyx-> : (>->"
11:58:33 <Phyx-> :t (>->)
11:58:34 <lambdabot> Not in scope: `>->'
11:58:36 <mmorrow> benmachine: that's assuming you've already set up a fallback for this
11:58:41 <dcoutts> gwern: if I've got some app, eg like a web server, where there's a well defined computation we're running in a thread, I really want to be able to catch it if it ends up using too much memory. It's like I want to run it in a little private heap where I set the heap limit.
11:58:42 <copumpkin> >=> ?
11:58:43 <benmachine> mmorrow: well, yes you have :P
11:58:50 <skorpan> orclev: i'm guessing that @go was short for @google
11:58:54 <Athas> mmorrow: yeah, there are many things to do.  In my specific application, I'd go into a sort of hibernation/freeze and hope the OOM killer fixes whatever's wrong.
11:59:17 <gwern> dcoutts: reasonable. but I think that is basically a process
11:59:32 <benmachine> mmorrow: but the more useful type of memory failure is a NULL return from malloc
11:59:34 <gwern> if the memory is isolated, in what sense is it a 'thread'?
11:59:53 <mmorrow> benmachine: that == perform a GC in haskell
12:00:19 <mmorrow> Athas: right, in haskell though you'd need to perform a GC, but that will have already been tried by the time you get said exception
12:00:19 <benmachine> mmorrow: no, that == raise a HeapOverflow, if I understand correctly
12:00:39 <mmorrow> benmachine: you will only get that if the GC can't reclaim enough space and your heap is full
12:00:52 <mmorrow> i.e. the entire heap is active/reachable
12:00:52 <dcoutts> gwern: ah no, it can read everything, just that new allocations are controled
12:01:05 <mmorrow> so at that point you're screwed
12:01:08 <EvilTerran> ?type let f i '(' = return (i+1); f i ')' = guard (i > 0) >> return (i-1); f i _ = return i in isJust . (guard . (==0) <=< foldM f 0)
12:01:10 <lambdabot> [Char] -> Bool
12:01:13 <gwern> hm, that's interesting! I get the same error with just -c
12:01:16 <Athas> mmorrow: indeed, but the problem isn't that I expect my program to use a lot of memory (on the contrary, in fact).  But it's pretty important that it doesn't crash, so I don't want it to die due to memory shortage just because some other process is leaking.
12:01:23 <gwern> could the compacting GC be buggy?
12:01:29 <benmachine> mmorrow: suppose you had a thread handler that emptied a memory cache or something
12:01:29 <dcoutts> gwern: could be
12:01:34 <benmachine> not a thread handler
12:01:40 <benmachine> an exception handler
12:01:56 <mmorrow> benmachine: sure, to the extent that you can do this in haskell code, that's a solution
12:02:02 <EvilTerran> > let f i '(' = return (i+1); f i ')' = guard (i > 0) >> return (i-1); f i _ = return i; matching = isJust . (guard . (==0) <=< foldM f 0) in filter matching ["", "()", ")(", "()(())", "foo(bar)baz", "())"]
12:02:04 <lambdabot>   ["","()","()(())","foo(bar)baz"]
12:02:31 <benmachine> mmorrow: so the question originally posed is how do you know when to clear such a cache, and the answer is HeapOverflow except it isn't because GHC doesn't send them
12:02:33 <Gracenotes> nooooooos
12:02:36 <benmachine> right?
12:02:40 <mmorrow> benmachine: but if your heap is full, you bettar not allocate in the handler.. ;)
12:03:02 <c_wraith> Just pre-allocate everything the handler needs :)
12:03:04 <EvilTerran> of course, the original question was for a foldr or foldl, and that's a foldM, but still...
12:03:04 <gwern> Gracenotes: alas, it seems that in your rage - you GCed her
12:03:11 <benmachine> well the thing is you don't get the exception when your heap is full, you get it when completing the next operation would make it full and then some
12:03:12 <skorpan> :t guard
12:03:13 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
12:03:22 <mmorrow> benmachine: what do you mean by such a "cache"?
12:03:29 <benmachine> (quite aside from the fact that the docs say, when it's *nearly* full)
12:03:37 <mmorrow> benmachine: the heap?
12:03:51 <benmachine> "The program's heap is reaching its limit"
12:03:52 <Gracenotes> gwern: no shame about it
12:03:53 <skorpan> @src guard
12:03:54 <lambdabot> guard True  =  return ()
12:03:54 <lambdabot> guard False =  mzero
12:04:03 <mmorrow> you need to cut the reachable path to the data you want to discard, then cause a GC
12:04:33 <EvilTerran> skorpan, i note "maybe True (==0) . foldM f 0" would work too
12:04:41 <EvilTerran> er, s/True/False/
12:04:45 <gwern> holy cow, with -c it crashed after just one request
12:04:46 <benmachine> okay so we've established that when your heap is full you're not definitely screwed? :)
12:04:46 <mmorrow> so off the top of my head the only possible way to do that would be to have an IORef or two that hold the only reference to said "cache"
12:04:52 <benmachine> just very very likely >_>
12:04:54 <gwern> that settles it, compacting GC is buggy
12:04:56 <hydo> I'm using SQLite for a desktop app and I'm running into locking problems.  I'm curious if anyone has a recommendation for something else like tokyocabinet or perhaps I should add a try-until-it-succeeds layer to what I already have.  Doing that seems like a bit of a hack though at first glance.
12:05:28 <mmorrow> benmachine: i would consider being screwed less painful than what you'd need to do to not be :)
12:05:36 <benmachine> well ok
12:05:43 <benmachine> but now we're talking about styles and opinions
12:05:47 <benmachine> in which case I agree
12:05:53 <benmachine> but I disagree with the idea that it can't be done
12:06:14 <mmorrow> benmachine: anything can be done
12:06:28 <copumpkin> ORLY?
12:06:35 <mmorrow> copumpkin: OH HAI
12:06:35 <ManateeLazyCat> dcoutts: I have read manual, how to make c2hs use directory that "pkg-config --cflags vte" output?
12:06:59 <dcoutts> ManateeLazyCat: from c2hs --help:
12:07:00 <dcoutts>   -C CPPOPTS   --cppopts=CPPOPTS    pass CPPOPTS to the C preprocessor
12:08:21 <dcoutts> c2hs $(pkg-config --cflags vte | sed 's/-I/-C-I/') vte.h Vte.chs
12:10:05 <mmorrow> benmachine: one solution would be to ffi import the rts C functions you need to detect such a thing, call them regularly/whatever somehow, hook into the GC/something also, and upon overflow manually force the GC to do something it's not designed to do :)
12:10:31 <mmorrow> which would probably be amusing, but not so much if you're not playing around
12:13:07 <mmorrow> hmm, but then if the gc collects stuff you still have references to then you'll segfault, so i guess don't mess with the GC, but still ffi to what you need to detect heap overflow, + keep these caches in IORefs (and make sure you don't hold onto any other references to them, then writeIORef undefined in the handler that was triggered by you detecting heap overflow manually via ffi C functions
12:15:04 <mmorrow> imo overflowing in the first place is a bug
12:15:09 <veinor> @pl fmap (\x->x-1) z
12:15:10 <lambdabot> fmap (subtract 1) z
12:15:18 <mmorrow> (in the application code i mean, not the rts)
12:15:41 <sm> what is the right "blocking queue" type for sending messages to another thread ?
12:15:48 <mmorrow> Chan?
12:15:50 <c_wraith> :t (-1)
12:15:53 <lambdabot> forall a. (Num a) => a
12:15:56 <c_wraith> :t (-1 )
12:15:58 <lambdabot> forall a. (Num a) => a
12:15:58 <sm> is that an mvar ?
12:15:59 <c_wraith> oops
12:16:02 <sm> chan, thank you
12:16:07 <c_wraith> :t (- 1)
12:16:09 <lambdabot> forall a. (Num a) => a
12:16:12 <c_wraith> hmph
12:16:22 <mmorrow> sm: Chan is implemented with a few MVars
12:16:27 <c_wraith> unary negation really does make parsing haskell dumb
12:16:32 <RayNbow> hmm, planet.haskell.org dead?
12:16:39 <veinor> c_wraith: Yeah :/
12:17:30 <benmachine> c_wraith: pred or subtract 1 are the usual methods I think
12:18:06 <mmorrow> Athas: out of curiosity, what is this program that "can't crash" doing?
12:18:27 <mmorrow> Athas: (i think this is definitely a worthwhile goal/ability to have)
12:18:42 <mmorrow> Athas: (to be able to not crash no matter what)
12:19:16 <ManateeLazyCat> dcoutts: I run command "c2hs $(pkg-config --cflags vte | sed 's/-I/-C -I /') /usr/include/vte/vte.h Vte.chs", c2hs warning me "must be exactly one binding file (suffix .chs) and optionall one ore more header files (suffix .h)." I'm sure files "/usr/include/vte/vte.h" and Vte.chs are exist.
12:19:22 <benmachine> mmorrow: well, someone might pull the plug on your machine :P
12:19:23 <mmorrow> although i'm not sure whether you have a low enough level of control in only haskell code to do this
12:19:30 <Athas> mmorrow: oh, it's a window manager.  So if it crashes, it takes a lot of the users stuff down with it.
12:19:39 <benmachine> or your RAM might get knocked out by an incredibly precise meteorite strike
12:20:05 <Athas> So it's not like people will die if it crashes.  But you might lose Emacs state, which is just as bad!
12:20:22 <mmorrow> benmachine: both of those seem to me to be OS-level concerns
12:20:30 <benmachine> true
12:21:14 <mmorrow> Athas: hmm, right. if we had some way to dump the entire heap/program state to a file maybe.
12:21:43 <benmachine> if the WM crashes, won't programs be able to handle that?
12:21:44 <mmorrow> (which would need to be part of the rts, or at least implemented in C)
12:22:08 <Athas> benmachine: most of them are going to be children of the WM process.
12:22:18 <veinor> @hpaste
12:22:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:22:20 <Cale> Hmm, does a windowmanager normally take applications with it if it crashes? I don't think it ought to...
12:22:21 <Athas> benmachine: and the X server will probably restart itself anyway.
12:22:36 <veinor> Cale: Window managers don't; I can switch between Compiz and Metacity fine.
12:22:40 <Cale> Normally it's okay to kill the WM process.
12:22:44 * ManateeLazyCat I'm confusion why my command can't work.
12:22:46 <benmachine> Athas: children don't *have* to die when their parent does, do they?
12:22:58 <benmachine> you just have to ignore SIGwhatever
12:23:01 <Cale> (It'll just leave your windows without borders or any way to control their position)
12:23:01 <veinor> benmachine: they don't *have* to, yeah
12:23:06 <veinor> I think it's SIGHUP
12:23:17 <veinor> no, that's terminals
12:23:19 <benmachine> SIGHUP is your terminal getting chomped
12:23:20 <Athas> benmachine: nope, but X servers have a nasty habit of killing themselves if they were started with a WM, and that WM goes down.
12:23:41 <Athas> It's not a big deal to work around if you have memory to do it properly.
12:23:50 <benmachine> k
12:24:03 <mmorrow> Athas: i guess the question really is, what is your intended course of action if the WM gets into a state where it can't continue?
12:24:20 <mmorrow> Athas: somehow dump the state that you don't want to loose before dying?
12:24:38 <Athas> mmorrow: actually, I'd probably prefer to completely shut down everything, but stay alive.
12:24:54 <Athas> Giving the user time to do controlled shutdowns of his programs.
12:25:19 <mmorrow> Athas: right, that seems sketchy to me though (sketchy to be able to achieve in haskell code, since you're not in complete control of everything)
12:25:43 <veinor> No, it is sighup
12:25:50 <Athas> mmorrow: indeed!  And I admit that the exercise is perhaps quite academic in nature, but I still think it'd be interesting to come up with a solution.
12:26:37 <mmorrow> Athas: for instance, there are a bunch of situations where the RTS will abort() (err, maybe just exit(), but that's just as well)
12:26:39 <copumpkin> what does academic mean in that sense?
12:27:03 <copumpkin> lol "not of practical relevance; of only theoretical interest : the debate has been largely academic."
12:27:11 <mmorrow> Athas: so the only way around those i can see would be to mack the RTS
12:27:12 <SamB_XP_> why not have the WM just restart ?
12:27:22 <veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8437#a8437
12:27:24 <veinor> Look what I wrote :D
12:27:24 <mmorrow> s/mack/hack/
12:27:40 <SamB_XP_> WindowMaker seems to do that whenver it segfaults ...
12:28:01 <SamB_XP_> unfortunately it often gets wedged without segfaulting :-(
12:28:10 <mmorrow> SamB_XP_: does it lose state doing that though?
12:28:15 <mmorrow> (fsvo state)
12:28:36 <SamB_XP_> mmorrow: presumably it loses some state
12:28:37 <mmorrow> SamB_XP_: because that seems to be what Athas is after
12:28:59 <SamB_XP_> but maybe it keeps most of it on the windows themselves somehow?
12:29:00 <EvilTerran> veinor, that looks like it works :)
12:29:04 <veinor> It does, I tested it
12:29:23 <EvilTerran> veinor, have you met "where" clauses?
12:29:38 <veinor> Yeah, I just decided to use a let for this one
12:29:53 <EvilTerran> ?type maybe -- this can also be used instead of that case/of at the bottom
12:29:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:30:01 <mmorrow> Athas: i think any solution to this would involve writing code at the C-level
12:30:20 <EvilTerran> > map (maybe False (==0)) [Nothing, Just 0, Just 1]
12:30:24 <lambdabot>   [False,True,False]
12:30:32 <veinor> Ahh, neat
12:30:37 <EvilTerran> ?src maybe
12:30:38 <lambdabot> maybe n _ Nothing  = n
12:30:38 <lambdabot> maybe _ f (Just x) = f x
12:30:54 <veinor> Is there a guide as to when to use let/in and when to use where?
12:31:02 <SamB_XP_> mmorrow: well, Window Maker does it's restart thingy from a parent process
12:31:15 <EvilTerran> veinor, well, a where can only go on the end of a definition, or the end of a case/of
12:31:25 <veinor> Right.
12:31:36 <EvilTerran> but, apart from that, it's a matter of personal preference, really
12:31:50 <SamB_XP_> mmorrow: the mechanism it uses to detect the child having segfaulted is probably not only available to C code ;-)
12:32:01 <mmorrow> SamB_XP_, Athas: hmm, actually where/what exactly is this "state" that we don't want to lose located? in the WM's haskell heap?
12:32:08 <EvilTerran> i prefer to use "where" when i can, because, in "foo x = ... where ...", you've got the equation "foo x = ..." in one place
12:32:24 <EvilTerran> while, in "foo x = let ... in ...", the "let ... in" is in the middle of the defining equation of foo
12:32:27 <mmorrow> SamB_XP_: definitely not (although the last time i tried to catch SIGSEGV in haskell code bad things happened)
12:32:27 <SamB_XP_> mmorrow: well, I think most of the state we don't want to lose is in the apps?
12:32:31 <veinor> True, true
12:32:54 <monochrom> I use let on a sunny day, where on a windy day
12:33:01 <SamB_XP_> mmorrow: but I think detecting that a child exitted due to SIGSEGV is probably a great deal less problematic
12:33:11 <mmorrow> SamB_XP_: ohh, right
12:33:13 <veinor> And is there a rule as to when I should use let/in or where and when I should just move that stuff into a whole new function definition?
12:33:20 <veinor> monochrom: what if it's raining?
12:33:38 <mmorrow> SamB_XP_: wait, what are we even talking about? i'm confused now.
12:33:40 <monochrom> I sleep
12:33:49 <SamB_XP_> mmorrow: never mind that someone (me, for instance!) might have sent the signal *to* the process ...
12:33:51 <SamB_XP_> mmorrow: not sure!
12:34:05 <orclev> is there something that does the opposite of $? I'm trying to do something like ((foo x y z) +)
12:34:16 <veinor> My processes are so hardcore they ignore sigkill
12:34:17 <EvilTerran> veinor, well, using where and let, it's possible for more things to be in scope
12:34:22 <mmorrow> SamB_XP_: so a child of the WM segfaults, which causes the (haskell) WM to die, which in turn causes all the other children to die?
12:34:30 <monochrom> What is the opposite of $ ?
12:34:30 <EvilTerran> ie, in "foo x = ... where ...", you can use x in the where clause
12:34:36 <orclev> veinor, I've got one like that, it's in zombie state
12:34:37 <EvilTerran> (and likewise for let/in)
12:34:42 <SamB_XP_> mmorrow: er, not what I meant
12:34:54 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8438#a8438 <-- why does this give me Prelude.undefined? why is the value being evaluated?
12:35:03 <mmorrow> SamB_XP_: i'm trying to understand the situation here
12:35:14 <SamB_XP_> mmorrow: what WindowMaker does is keep the original WM invocation as a sort of "watcher" process
12:35:31 <mmorrow> SamB_XP_: ah right ok, lighttpd does something similar
12:35:33 <monochrom> @botsnack
12:35:34 <lunabot>  :)
12:35:34 <lambdabot> :)
12:35:37 <SamB_XP_> and launch itself in a subprocess with a flag like -real added to do the actual window management
12:35:50 <monochrom> > map ((cos 0) +) [3,1,4]
12:35:51 <lambdabot>   [4.0,2.0,5.0]
12:36:07 <SamB_XP_> then if the watcher detects the WM exitted due to SIGSEGV, it restarts the real WM
12:36:11 <monochrom> Seems ((foo x y z) +) works out of the box.
12:36:20 <EvilTerran> monochrom, or without the inner ()s
12:36:23 <benmachine> okay I can ask a smaller question
12:36:37 <mmorrow> SamB_XP_: and by doing so keeps al the other windows alive?
12:36:58 <EvilTerran> benmachine, i suspect the answer to your first question lies in the definition of the parser monad
12:36:58 <mmorrow> Athas: is this a solution?
12:37:30 * benmachine starts lagging heavily
12:38:04 <Athas> mmorrow: perhaps, but I think the X-server will restart itself (most likely killing all applications) if the WM process ever dies.
12:38:51 <mreh_> can someone explain why this code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3387#a3387, causes firing == True every time it is entered?
12:39:07 <mreh_> it's part of the reactive animation in my asteroids game
12:39:12 <EvilTerran> benmachine, looking at http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/src/Text-ParserCombinators-Parsec-Prim.html#GenParser makes me think that the parser monad is strict, so return _|_ = _|_
12:39:19 <mreh_> its mapped to a list of events
12:39:21 <monochrom> I have seen window managers dying but the x server doesn't kill anyone else. I have not seen window managers dying and the x server killing things.
12:39:28 <mreh_> mapped onto a list of events rather
12:39:30 <benmachine> EvilTerran: doesn't that break monad laws?
12:39:46 <EvilTerran> i may be wrong
12:39:49 <benmachine> oh but undefined has a tendency to break things doesn't it
12:39:50 <EvilTerran> still readin'
12:39:55 <SamB_XP_> monochrom: how does your X server start?
12:40:03 <EvilTerran> benmachine, why not just make "void = (>> return ())" ?
12:40:04 <artagnon> I'm attempting to write a function that, given a list, returns all possible permutations of the list. There seems to be some mistake though. Compile-time type error t=[t] | http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3388#a3388
12:40:15 <SamB_XP_> monochrom: and what OS are you on?
12:40:20 <benmachine> EvilTerran: because I want to be sure the return value isn't examined
12:40:23 <monochrom> In fact I used to tell WindowMaker to quit, then in an xterm (already openned before) start twm. And vice versa.
12:40:30 <benmachine> because if it is, we're getting an invalid one
12:40:31 <SamB_XP_> and/or X distribution?
12:40:32 <mmorrow> Athas: but what if the WM process forks a child which does the actual window management, and if *that* ever dies, it restarts it. so the top-level WM doesn't ever die
12:40:54 <Athas> mmorrow: ooh, that is horrible in a good way.
12:41:00 <SamB_XP_> monochrom: or... how do you start the WM?
12:41:04 <SamB_XP_> the first one?
12:41:05 <mmorrow> Athas: (this is what i understood SamB to be describing)
12:41:10 <mmorrow> Athas: heh
12:42:02 <artagnon> my interpost function works fine
12:42:09 <artagnon> s/interpost/interpose
12:42:13 <artagnon> I tested it independently
12:43:09 <EvilTerran> artagnon, i suggest giving permute an explicit type sig, and throwing it at ghc again. it may narrow down the error location enough for it to be readily apparent what it is
12:43:38 <artagnon> EvilTerran: Got it. One sec.
12:44:05 * EvilTerran would be more helpful, but he can't see the error right now himself
12:44:51 <benmachine> http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=3389#a3389 <-- is this all guaranteed by monad law?
12:45:02 <benmachine> oh I've got to go to dinner anyway
12:45:05 <mmorrow> haha unsafecoerce++
12:45:06 <EvilTerran> in general, if i can't track down a type error, i start adding type sigs to things to narrow down where it is
12:45:21 <copumpkin> :o
12:45:31 * mmorrow forgot about that
12:45:34 <benmachine> well, if it is then my program should work unless it is ok for undefined to break things
12:45:46 <EvilTerran> ?karma unsafecoerce
12:45:47 <lambdabot> unsafecoerce has a karma of 1
12:45:48 <benmachine> leave me a highlight if anyone has any thoughts!
12:45:50 <artagnon> New revision: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3388#a3390
12:45:51 * benmachine disappears
12:45:52 <artagnon> damn
12:45:58 <elliottt> does anyone here use zsh?
12:45:58 <artagnon> it gives an error on interpose too now
12:46:09 <Cale> benmachine: the second to the third line looks like a type error
12:46:10 <artagnon> what's wrong with the typesig for interpose?
12:46:16 <EvilTerran> artagnon, permute returns a list of permutations, doesn't it?
12:46:18 <artagnon> it works fine without the type sig.
12:46:23 <EvilTerran> and each permutation is a list of items?
12:46:25 <artagnon> EvilTerran: Yes, that is correct.
12:46:48 <EvilTerran> artagnon, that'd make its return type [[a]], surely?
12:47:30 <monoidal> permute [] = [[]] imho
12:47:32 <monochrom> SamB_XP_, there is much flexibility in X. Briefly, when an X session starts, there is one distinguished process (let's call it P) such that the X software considers it to be the end of the session iff P dies. If P doesn't die, the session doesn't end. But it is up to you to set up which program is run as P. Now some people make their window managers as P, but in the old days we didn't do that. We had a distinguished xterm as
12:47:32 <monochrom> P.
12:47:32 <EvilTerran> the interpose type looks fine to me, although i don't think you need that Integral constraint on either type
12:47:32 <artagnon_> ouch! sorry about that.
12:48:00 <monoidal> there's exactly one permutation of the empty set/list
12:48:02 <SamB_XP_> monochrom: yeah, I know
12:48:03 <artagnon_> EvilTerran: actually, could you tell me how to write it without the integral constraint? (ie. syntax wise)
12:48:15 <EvilTerran> interpose :: a -> [a] -> [a]
12:48:16 <artagnon_> monoidal: Correct. Ok, let me try that.
12:48:27 <SamB_XP_> monochrom: except when there isn't a process P!
12:49:10 <monochrom> I have never seen that.
12:49:13 <artagnon_> EvilTerran: still gives me error on interpose.
12:49:18 <EvilTerran> that's weird
12:49:19 <artagnon_> Occurs check: cannot construct the infinite type: a = [a]
12:49:30 <artagnon_> and same error with permute too
12:49:32 <artagnon_> Occurs check: cannot construct the infinite type: a = [a]
12:49:35 <monoidal> what is the type of interpose?
12:49:35 <EvilTerran> artagnon_, wait, is interpose returning a list of lists too?
12:49:45 <artagnon_> EvilTerran: Yes.
12:50:01 <EvilTerran> in which case, interpose's return type should represent that, and be [[a]]
12:50:19 <monoidal> permute (x:xs) = concat [interpose x list | list <- permute xs]
12:50:24 <monoidal> and it works
12:50:28 <Cale> @tell benmachine http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=3389#a3391
12:50:29 <lambdabot> Consider it noted.
12:50:46 <EvilTerran> you're giving it an (a), and a (list of a), and you're getting back a (list of lists of a); that's the type (a -> [a] -> [[a]])
12:50:56 * ManateeLazyCat pasted "error info" at http://paste2.org/get/395845
12:50:56 <ManateeLazyCat> dcoutts: "c2hs $(pkg-config --cflags vte | sed 's/-I/-C-I/g') /usr/include/vte/vte.h Vte.chs" can run now, but i got above error, i got three files now: " Vte.chs Vte.chs.h Vte.i", Vte.chs is empty, Vte.chs.h just have "#include "/usr/include/vte/vte.h", and Vte.i contain many useful information that c2hs generate.
12:51:05 <monochrom> Well that's a weak statement and here is the stronger statement I intend. In the past 20 years I have been to at least 5 different university labs and also used and saw various unixes and user customizations, and I have never seen that. There is always P.
12:51:09 <artagnon_> monoidal: Yes! It does! How though?
12:51:13 <artagnon_> I mean why?
12:51:27 <monoidal> intersperse was a list of list of a
12:51:32 <hackagebot> boxes 0.1.1 - 2D text pretty-printing library (BrentYorgey)
12:51:41 <monoidal> so, [interpose x list | list <- permute xs] is a list of list of list of a
12:51:46 <monoidal> you have to remove one level of nesting
12:52:12 <artagnon> oh!
12:52:25 <artagnon> monoidal: Awesome! Thanks! :D
12:52:29 <monoidal> :)
12:52:38 * ManateeLazyCat pasted "Manatee.Utils.hs" at http://paste2.org/get/395846
12:52:53 * ManateeLazyCat pasted "Manatee.Gtk.Utils.hs" at http://paste2.org/get/395847
12:53:08 <ManateeLazyCat> Above two files is sub-module in my project.
12:53:34 <ManateeLazyCat> And speical Manatee.Gtk.Utils.hs have many useful gtk2hs functions, enjoy!
12:54:00 <artagnon> EvilTerran: Thanks for the pointer. I'll write type sigs for all my functions to simplify debugging.
12:54:04 <roconnor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8439#a8439
12:54:22 <artagnon> ghc returns WAY more meaningful errors with typesigs.
12:54:28 <artagnon> Otherwise, it's just a random guess.
12:54:31 <SamB_XP_> roconnor: contextify1
12:54:35 <SamB_XP_> er. s/1/!/
12:54:58 <mmorrow> s/!/!!!11/
12:55:15 <SamB_XP_> mmorrow: but I wasn't trying to write in AOLeze!
12:55:18 <roconnor> SamB: Andrej is comparing summing the harmonic series in C Ocaml and Haskell
12:55:32 <roconnor> Haskell "naive" code is 2x slower that C / Ocaml
12:55:36 <mmorrow> SamB_XP_: tell it to the judge!!@2
12:55:42 <SamB_XP_> roconnor: I know that, but not everyone here was in -blah just now ;-P
12:56:00 <artagnon> roconnor: bah, that's just lame.
12:56:04 <EvilTerran> artagnon, indeed; also, if i can't see how to write a function immediately, i find writing the type sig first can often help guide me towards an implementation
12:56:07 <dolio> > 1000000000 :: Int32
12:56:10 <lambdabot>   1000000000
12:56:35 <EvilTerran> a remarkably high proportion of types have obvious implementations
12:56:38 <artagnon> EvilTerran: I see. I'll start off with typesigs from next time then.
12:56:55 <SamB_XP_> roconnor: so ... what CPU does he have?
12:57:00 <artagnon> roconnor: It all depends on how much laziness you're using.
12:57:06 <artagnon> roconnor: etc.
12:57:07 <roconnor> thinkpad x41
12:57:25 <SamB_XP_> roconnor: that's not a model of CPU afaict
12:57:37 <roconnor> would GHC do better with a fold rather than recursion?
12:58:16 <artagnon> Depends. Tail call recursion optimizations etc. You have to study the way GHC works for that.
12:58:32 <copumpkin> roconnor: that fromIntegral at each iteration seems unpleasant
12:58:36 <artagnon> Strict folds save on memory I've noticed. I use foldl1' wherever I can for example.
12:58:56 <Cale> artagnon: foldl' is better than foldl1'
12:59:12 <Cale> artagnon: You should never use foldl1' unless there really is no way to avoid it.
12:59:22 <mmorrow> roconnor: that harmonic function should have !'s on the h's
12:59:29 <mmorrow> 13 seconds for me
12:59:32 <Cale> foldr is actually probably the fold that I use more than any other.
12:59:41 <Cale> But it's closely followed by foldl'
12:59:41 <artagnon> Cale: oh! ~
12:59:48 <roconnor> mmorrow: ya but strictness analysis probably takes care of that?
12:59:56 <roconnor> maybe you are right
13:00:05 <Cale> artagnon: The reason is that foldl1' crashes your program if you apply it to an empty list
13:00:16 <artagnon> Cale: but why give an initial value? I want to use the head of the list as the initial value
13:00:21 <artagnon> Cale: ah, right.
13:00:26 <mmorrow> actually, !'s didn't even change the time
13:00:45 <mmorrow> roconnor: did he compile with -O2 ?
13:00:47 <dolio> Oh my machine, I get 14 seconds for GCC, and 14 seconds for GHC.
13:00:55 * roconnor is kinda concerned Andrej is using an old version of GHC
13:01:17 <roconnor> dolio: -O3 for GCC?
13:01:25 <dolio> Oh, hmm...
13:01:35 <SamB_XP_> don't forget -fno-fast-math or whatever
13:01:35 <artagnon> O3 is dangerous.
13:01:37 <Cale> artagnon: A problem with left folds is that they completely fail to work on infinite lists, as they *always* traverse the whole list before resulting in anything at all.
13:01:49 <roconnor> artagnon: only dangerous for GHC?
13:01:53 <mmorrow> roconnor: where's the C code at?
13:02:01 <mmorrow> -O3 rulz
13:02:05 <Cale> artagnon: Right folds pass control back to the combining function on each step, so you get nice early bailouts when you don't end up needing all the input list.
13:02:13 <dolio> roconnor: Yeah, that didn't change anything.
13:02:22 <SamB_XP_> does GHC even *have* an -O3?
13:02:34 <hackagebot> haskell-src-exts 1.1.3 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
13:02:36 <Cale> SamB_XP_: It doesn't. It clips to -O2 when you give it -O3.
13:02:46 <roconnor> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8439#a8440
13:02:52 <SamB_XP_> Cale: that's what I thought
13:02:53 <Cale> But, I think in the past, -O3 used to just do nothing.
13:03:00 <artagnon> Cale: Ah I see. That's an interesting point. I've hung on a couple of foldls before.... on infinite lists. Now the mystery is solved. Thanks :)
13:03:14 <SamB_XP_> Cale: oops!
13:03:38 <artagnon> Cale: Right, Got it. Does it have a strict foldr' version?
13:03:52 <Cale> artagnon: It's hard to say what that would actually mean.
13:04:05 <Berengal> There is a foldr', but I don't know what it's for
13:04:07 <Berengal> @src foldr'
13:04:08 <lambdabot> Source not found. My pet ferret can type better than you!
13:04:17 <SamB_XP_> Cale: reverse then foldl the flip of the function?
13:04:24 <Cale> Berengal: Is there? It would be new if it was.
13:04:27 <SamB_XP_> er, foldl' ?
13:04:38 <dolio> It's in the Foldable class. It makes a little sense if you're folding over, say, a Seq.
13:04:40 <Berengal> Cale, maybe I dreamt it up...
13:04:55 <roconnor> Berengal: maybe one in foldable?
13:04:57 <monochrom> This avoid-foldl1' advice is on the same level of mediocrity as those 10-rules-for-critical-programs such as "do not use dynamic memory allocation after initialization". http://spinroot.com/p10/
13:05:01 <artagnon> Cale: GC the part that I've already used. I use foldl1' with max. Why not foldr' too?
13:05:04 <orclev> was it foldl' that comes with the big warning about the fact that it eats your heap for breakfast on large lists?
13:05:11 <dolio> With a Seq you can do tail recursion starting at either end.
13:05:13 <Cale> artagnon: Basically, when you can produce part of the output from part of the input, you should use foldr, and when that makes no sense, foldl'
13:05:36 <mmorrow> hah, the haskell beats C on my machine
13:05:46 * mmorrow looks at the asm of each
13:05:53 <Berengal> monochrom, foldl1' is bad?
13:06:00 <Cale> artagnon: It's (usually) impossible to tell anything about the max of a list of elements before you've seen every one of them, so for that, you'll want to use foldl1'
13:06:01 <roconnor> mmorrow: same code I posted?
13:06:07 <mmorrow> roconnor: yup
13:06:10 <monochrom> foldl1' is good.
13:06:11 <ManateeLazyCat> Cale: You have experience about c2hs?
13:06:16 <copumpkin> roconnor: did he mention which version of ghc he was using and what compile flags?
13:06:18 <roconnor> mmorrow: -O3 for GCC and GHC
13:06:23 <artagnon> Cale: Right. Got it. Thanks for the awesome tip.
13:06:23 <Armored_Azrael> monochrom: You in fact _shouldn't_ use dynamic memory after initialization... do you want a jet to fall out of the sky due to an out of memory error? Not cool.
13:06:24 <Cale> ManateeLazyCat: Very very little. I'm probably the wrong person to ask.
13:06:31 <roconnor> copumpkin: I told him to use -O2 for GHC but he used -O3
13:06:31 <mmorrow> gcc -O3 -fomit-frame-pointer -ffast-math c_harmonic.c
13:06:37 <roconnor> oh
13:06:41 <roconnor> -ffast-math?
13:06:41 <mmorrow> i used
13:06:44 <Berengal> monochrom, so who's saying you should avoid it?
13:06:45 <Cale> artagnon: another thing which might be helpful are my diagrams
13:06:52 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
13:06:54 <monochrom> Cale just did.
13:07:00 * artagnon looks
13:07:01 <mmorrow> roconnor: it omits checks for certain overflows/misc
13:07:16 <roconnor> mmorrow: is C getting the same treatment?
13:07:25 <mmorrow> roconnor: that was for the C
13:07:29 <Cale> monochrom: I said avoid foldl1' unless foldl' doesn't make sense.
13:07:29 <mmorrow> ghc -O2
13:07:29 <roconnor> ah
13:07:30 <ManateeLazyCat> Cale: Oh, dcoutts is right people, and he perhaps too busy, i have send my problem to mailing-list.
13:07:31 <roconnor> oops
13:07:32 <mmorrow> i used for the haskell
13:07:36 <roconnor> :D
13:07:39 <Cale> monochrom: Which I think is good advice when qualified like that.
13:07:42 <Berengal> foldl1' and foldl' are two completely different things. They don't overlap
13:08:02 <Berengal> Okay, they're not completely different...
13:08:06 <Berengal> But they still don't overlap
13:08:09 <artagnon> Cale: Nice! What did you draw them in?
13:08:10 <SamB_XP_> mmorrow: on i386, doesn't -ffast-math give you really arbitary FP results?
13:08:15 <Cale> artagnon: Inkscape
13:08:18 <monochrom> Your original qualification was "unless there really is no way to avoid it" which has a different inclination.
13:08:31 <Cale> monochrom: Does it?
13:08:58 <monochrom> There are many things which make sense but can still be avoided.
13:09:00 * ManateeLazyCat I need sleep now. Good night! :)
13:09:01 <Cale> I think in context, it was pretty clear what I meant.
13:09:30 <Berengal> foldl' is for when you have a default start acumulator. foldl1' is for when you don't. You won't maybe have a different accumulator when writing
13:09:37 <Cale> foldl1' will give you an async exception when you accidentally end up with an empty list, which is bad.
13:09:41 <artagnon> monochrom: Don't nitpick! He was pointing out that foldl1' crashes with empty lists.
13:10:17 * SamB_XP_ offers to give monochrom a whole bucket of nits to pick
13:10:23 <monochrom> There are a lot of cases where crashing makes a lot of sense but still "can be avoided" such as returning fake answers.
13:10:32 <Cale> In the case of operations with identity elements, foldl1' and foldl' are somewhat interchangeable, but you should always pick foldl' since it won't fail in the empty case.
13:10:49 <SamB_XP_> monochrom: it's pretty clear that he meant "where there is a unit"
13:11:24 <Cale> If there's no identity element, well, it can't be helped, you may actually need to use foldl1'.
13:11:42 <mmorrow> SamB_XP_: not really
13:11:52 <artagnon> Anyway, I should get going. Need to finish more PE problems :)
13:12:01 <artagnon> Again, thanks for everything, all.
13:12:08 <SamB_XP_> mmorrow: actually, I don't think you CAN use foldl' instead of foldl1' unless you have an identity element
13:12:40 <Berengal> SamB_XP_, doesn't have to be an identity
13:12:41 <mmorrow> SamB_XP_: (i was responding to ffast-math)
13:12:58 <SamB_XP_> mmorrow: oh ...
13:12:59 <EvilTerran> it helps if it's a right-identity
13:13:03 <SamB_XP_> sorry!
13:13:13 <Berengal> foldl' (++) "The result is:" is a perfectly valid piece of code with no identity
13:13:15 <monoidal> you add identity element artifically
13:13:35 <SamB_XP_> mmorrow: I was talking about the sometimes-80-bit, sometimes-64-bit storage I believe it uses?
13:13:37 <hackagebot> HaskellForMaths 0.1.7 -  (DavidAmos)
13:13:41 <dolio> -ffast-math didn't appear to do anything to the performance on my machine.
13:14:24 <SamB_XP_> mmorrow: depending on whether floating point values need ... what was that verb ending in "ing"?
13:14:26 <EvilTerran> (foldl f undefined) would be semantically equivalent to (foldl1 f), so you can replace that undefined with anything to get a refinement of (foldl1 f)
13:14:36 <SamB_XP_> well, anyway, depending on whether they fit in the FP regs
13:14:54 <EvilTerran> and so, in one sense, you can put anything where the identity would go and get something semantically acceptable
13:16:03 <EvilTerran> if you're willing to take bottom to mean "no defined semantics, so anything goes" instead of "'undefined' in the specific sense of the word defined by the semantics"
13:16:31 <SamB_XP_> EvilTerran: but ... that doesn't work on non-empty lists, duh!
13:17:11 <EvilTerran> er... good point. sorry, i got to thinking about semantic refinement, and lost track of what the code was doing ;)
13:18:21 <EvilTerran> yeah, a right-identity would be necessary to preserve the semantics of a foldl1, almost by definition
13:19:11 <EvilTerran> modulo fudging outside the foldl(1)'s parameters, of course
13:19:35 <dolio> Left identity.
13:20:06 <dolio> Or is a right identity an identity when you operate on it with something else on the right?
13:20:11 <stianhj> Is book.realworldhaskell.org down?
13:20:40 <hackagebot> filestore 0.3.2 - Interface for versioning file stores. (JohnMacFarlane)
13:20:42 <monochrom> (foldl (==) undefined [True]) is not semantically equivalent to (foldl1 (==) [True])
13:20:55 <dqd> It looks so.
13:22:39 <roconnor> dolio: It seems J should be called Select or some such thing.
13:23:06 <Philonous> Is there a deeper reason that I can't have instances like "instance Foo (forall a. a->a->a)" ?
13:23:44 <roconnor> Philonous: overlaps with a -> a -> a?
13:24:05 <roconnor> which in turn overlaps with a -> b
13:24:31 <monoidal> instance Foo Endo is ok
13:24:32 <mmorrow> here's the ghc and gcc asm http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8439#a8443
13:25:01 <copumpkin> mmorrow: what are the speeds?
13:25:20 <mmorrow> copumpkin: the haskell one beat the C one on my machine by over a second
13:25:34 <roconnor> mmorrow: ghc doesn't eve use the number 1000000!
13:25:36 <copumpkin> mmorrow: it "looks" slower, but I guess I'm not very good at gauging it :P
13:26:00 <mmorrow> roconnor: yeah, i was too lazy to wade through the rest of the asm and find the entry to that sequence..
13:26:05 <roconnor> :)
13:26:08 <help> hi, can anyone point me to a mirror for code.haskell.org?  It seems to be down
13:26:08 <mmorrow> but those are the inner loops
13:26:09 <mmorrow> :)
13:27:26 <mmorrow> ooh, also i *removed* the "L" prefix on the double literals, since that causes gcc to use x87  fp asm
13:27:35 <mmorrow> dunno why he would have done that..
13:27:50 <mmorrow> oh, i didn't run the C after i did that though
13:27:53 * mmorrow checks now
13:28:08 <Philonous> I don't have instaces for those. But I think (forall a. a->a->a) in this context is not equivalent to (a->a->a). Suppose class Foo x where bar :: x -> x -> x . There is a difference between x being (forall a. a->a->a) and (a->a->a).
13:28:40 <Guest98627> hi, can anyone point me to a mirror for code.haskell.org?  It seems to be down.  Can anyone confirm that it is down for them as well?
13:28:44 <mmorrow> haha, ok. how the C is twice as fast as the haskell :)
13:28:47 <Philonous> I think in the latter case the a's have to be indentical
13:28:58 <mmorrow> who uses "L" on doubles??
13:29:15 <SamB_XP_> mmorrow: maybe that's for long doubles?
13:29:24 <mmorrow> SamB_XP_: he gave the type as "double"
13:29:25 <roconnor> Philonous: there is a difference, but one implies the other.
13:29:38 <copumpkin> mmorrow: have you tried sumU . mapU recip . enumFromToFracU 1 ? :P
13:29:41 <roconnor> Philonous: hence the overlap
13:29:53 <mmorrow> SamB_XP_: i have no idea why the "L" suffix causes gcc to use x87 nastiness though
13:30:03 <mmorrow> copumpkin: no
13:30:38 * benmachine pokes lambdabot 
13:30:39 <lambdabot> benmachine: You have 1 new message. '/msg lambdabot @messages' to read it.
13:30:39 <SamB_XP_> mmorrow: 'cause long double (on i386, at least) is an 80-bit x87 float?
13:30:54 <copumpkin> ew
13:30:57 <mmorrow> SamB_XP_: he didn't specify the type as "long double" though!
13:31:16 <mmorrow> and what about arches that don't have 80-bit double abominations?
13:31:21 <mmorrow> :)
13:31:24 <SamB_XP_> mmorrow: I guess it did long double computations with the long double?
13:31:34 <mmorrow> SamB: i suppose
13:32:05 <SamB_XP_> mmorrow: well, if "long double" isn't defined by the ABI to be an 80-bit x87 float, it isn't
13:32:06 <mmorrow> although isn't a long double 128bits?
13:32:15 <Guest98627> Can anyone confirm that code.haskell.org is down please?
13:32:21 <mmorrow> SamB_XP_: i'm not sure
13:32:22 <SamB_XP_> mmorrow: it's >= as precise as a double
13:32:29 <mmorrow> ah
13:32:36 <benmachine> Cale: thanks for the correction
13:32:44 <SamB_XP_> and rangy
13:32:46 <Philonous> roconnor: But if this is my only instance, than overlapping shouldn't be an issue, or am I misunderstanding what you mean?
13:32:48 <roconnor> Guest98627: I cannot connect.
13:32:51 <copumpkin> http://downforeveryoneorjustme.com/code.haskell.org
13:32:54 <mmorrow> i love how x86_64 has the %ymm regs... 256bits doubles!
13:33:02 <Guest98627> roconnor: thank you
13:33:18 <mmorrow> and %xmm are the low 128bits of the %ymm
13:33:24 <roconnor> Philonous: Haskell 98 doesn't allow potentially overlapping instances (cause you never know when two modules will be loaded together).
13:33:29 <ski> roconnor : if we have a function `bar :: Foo a => a -> ...', then using this instance that becomes `bar :: (forall a. a -> a -> a) -> ...', which seems different from `bar :: forall a. (a -> a -> a) -> ...' ..
13:33:47 <benmachine> so a >> return b >> c is equivalent to a >> c, is this required to be the case even when b is undefined?
13:34:02 <roconnor> ski: what about the other way?
13:34:05 <mmorrow> although i don't think gcc generates code that uses the %ymm regs at this point
13:34:16 <SamB_XP_> benmachine: yeah
13:34:18 <Cale> benmachine: yes
13:34:22 <benmachine> right
13:34:24 <roconnor> ski: or rather
13:34:33 <SamB_XP_> benmachine: you can prove it with the monad laws, after all!
13:34:38 <roconnor> I call "bar asTypeOf"
13:34:41 <benmachine> so Parsec being strict in that manner is a bug?
13:34:44 <roconnor> ski:  which instance do I use?
13:34:52 <SamB_XP_> it's probably even true in quickCheck's monad!
13:34:57 * benmachine looks for his original paste
13:35:11 <SamB_XP_> benmachine: hmm?
13:35:19 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8438
13:35:29 <benmachine> that use of void was getting me an undefined error
13:35:40 <Cale> Yes, that is a bug.
13:35:44 <Philonous> roconnor: But "instance Foo (a->a->a) works"?
13:35:45 <benmachine> woo I found a bug
13:35:53 <Cale> > parseTest (char 'a' >> char 'b') "ab"
13:35:54 <Cale> 'b'
13:35:54 <Cale> > parseTest (char 'a' >> return undefined >> char 'b') "ab"
13:35:54 <Cale> *** Exception: Prelude.undefined
13:35:59 <lambdabot>   mueval-core: Prelude.read: no parse
13:36:00 <lambdabot>  mueval: ExitFailure 1
13:36:00 <lambdabot>   mueval-core: Prelude.read: no parse
13:36:00 <lambdabot>  mueval: ExitFailure 1
13:36:06 <Cale> d'oh :)
13:36:11 <copumpkin> failsec!
13:36:35 <roconnor> Philonous: it works because the forall version is disallowed
13:36:44 <roconnor> so bar asTypeOf must use that instance.
13:36:46 <ski> roconnor : there is possible incoherency, there, yes. but i'm not sure it's because of overlap in the usual sense
13:36:49 <benmachine> cabal info parsec
13:36:49 <benmachine>     Bug reports:   [ Not specified ]
13:37:06 <benmachine> :(
13:37:11 <Cale> benmachine: Who's listed as the maintainer
13:37:12 <Cale> ?
13:37:16 <benmachine> oh dang it I am lagging again
13:37:17 * roconnor is surprised instance Foo (a->a->a) works
13:37:38 <SamB_XP_> I think I've heard of such issues with parsec before maybe?
13:37:41 <Cale> benmachine: Probably if you send email to Derek Elkins, he can do something about it.
13:37:45 <roconnor> I thought all parameters need to be type variables
13:37:54 <Cale> It shouldn't be too hard to fix something of that sort.
13:37:55 <Philonous> roconnor: FlexibleInstances
13:38:00 <SamB_XP_> roconnor: you must be using -fglasgow-exts ;-P
13:38:14 <roconnor> ah
13:38:21 <roconnor> well, then perhaps the forall thing ought to work
13:38:34 * benmachine tries to see if the cvs version has the same bug
13:38:44 * benmachine tries to remember how one uses cvs
13:38:52 * benmachine also tries to remember why one uses cvs
13:38:53 <roconnor> Just wrap it in a newtype like everyone else does :D
13:39:00 <mmorrow> benmachine: rm -f `which cvs` # iirc :)
13:39:04 <benmachine> Cale: okay thanks, I'll have a look
13:39:06 <SamB_XP_> benmachine: mostly because the code is under cvs
13:39:17 <benmachine> mmorrow: heh, sounds about right
13:39:28 <SamB_XP_> mmorrow: I thought it was `aptitude remove cvs' or something
13:39:38 <copumpkin> mmorrow: lol
13:39:40 <Guest98627> so is anyone aware of a mirror for code.haskell.org?
13:39:41 <benmachine> SamB_XP_: pacman -R in this case
13:40:03 <Philonous> roconnor: That works of course, but it defeats the purpose of my class :/
13:40:10 <SamB_XP_> I still think it was a bad idea to name a package manager after a classic videogame ...
13:40:36 <SamB_XP_> (without altering the spelling or something to make it distinctly googleable)
13:40:37 <Cale> I don't really see from the Parsec code why return undefined seems to be the same as undefined...
13:41:01 <roconnor> Philonous: :(
13:43:08 <vyom> http://user.cs.tu-berlin.de/~magr/pub/Transformers.en.html I am trying to work through this Monad Transformers tutorial but the related .lhs file does not compile for me http://user.cs.tu-berlin.de/~magr/pub/Transformers.lhs . First error is Transformers.lhs:251:30 Couldn't match expected type `Identity Value' against inferred type `Maybe Value'
13:45:01 <monoidal> A file with 2 lines: {-# OPTIONS_GHC -fglasgow-exts #-} then {-# LANGUAGE -XFlexibleInstances #-} causes my GHC 6.10.4 to panic
13:45:08 <vyom> is the tutorial wrong.. or am I doing something wrong.. (using GHCi version 6.10.1 btw)
13:46:24 <igel> monoidal: does it also panic with {-# LANGUAGE FlexibleInstances #-}
13:46:28 <igel> ?
13:46:30 <monoidal> yes
13:46:44 <igel> that's ugly...
13:47:40 <igel> same here
13:47:45 <monoidal> um. FlexibleInstances doesn't cause the crash. Adding a dash before it causes
13:47:45 <igel> you should file a bug report
13:48:05 <igel> ghc doesn't crash on empty files
13:48:22 <igel> it shouldn't crash on files containing pragmas/comments only
13:48:27 * benmachine can't work out how to use cvs.haskell.org
13:48:35 <benmachine> or cvs, for that matter
13:49:16 <monoidal> after reading that line it crashes, doesn't matter if that's eof, or there is some code there, legal or not
13:49:19 <igel> there are non-git/darcs repos on  haskell.org? :D
13:49:46 <igel> it's an error in the parser
13:49:52 <benmachine> apparently so
13:50:00 <monoidal> (GHC version 6.10.4 for i386-unknown-linux): getOptions'.parseLanguage(2) went past eof token
13:50:04 <igel> you should really file a bugreport monoidal
13:54:36 <burp> can anyone provide an example for <$?
13:54:49 <burp> :t <$
13:54:51 <lambdabot> parse error on input `<$'
13:54:52 <burp> :t (<$)
13:54:54 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
13:55:22 <roconnor> I'd probably set  b to be ()
13:55:51 <dschoepe> burp: it's useful when you want to do some side-effect-ish stuff in the second argument and lift the first argument.
13:56:15 <roconnor> 42 <$ tell "burp wants an example"
13:56:21 <roconnor> 42 <$ (tell "burp wants an example")
13:56:33 <dschoepe> > 42 <$ (tell "burp wants an example")
13:56:36 <lambdabot>   No instance for (GHC.Show.Show (f t))
13:56:36 <lambdabot>    arising from a use of `M1732012750...
13:56:47 <burp> good one ;)
13:56:54 <roconnor> > runWriter (42 <$ (tell "burp wants an example"))
13:56:56 <lambdabot>   (42,"burp wants an example")
13:57:11 <roconnor> it's a very complex way of writing (,)
13:57:15 <roconnor> :)
13:57:19 <burp> hm I see
13:57:30 <dschoepe> burp: Writer is, not (<$)
13:57:52 <benmachine> (<$) = fmap const?
13:57:59 <monoidal> igel: http://hackage.haskell.org/trac/ghc/ticket/3450
13:58:02 <dschoepe> @src (<$)
13:58:03 <lambdabot> (<$) = (<$>) . const
13:58:11 <benmachine> guess so.
13:58:16 <dschoepe> so, fmap . const
13:58:27 <benmachine> oh
13:58:33 <benmachine> close enough >_>
13:59:33 <igel> monoidal: good :)
14:00:35 <monoidal> even {-# LANGUAGE - #-} causes crash
14:02:17 <monoidal> is it possible to edit a bug report?
14:02:36 <Phyx-> @hoogle toIntegral
14:02:37 <lambdabot> No results found
14:02:46 <Phyx-> @hoogle Int -> Integer
14:02:46 <lambdabot> Prelude toEnum :: Enum a => Int -> a
14:02:46 <lambdabot> Data.Bits bit :: Bits a => Int -> a
14:02:46 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
14:02:53 <copumpkin> fromIntegral ?
14:02:58 <igel> monoidal: i don't know, but you should be able to write an answer
14:03:08 <copumpkin> :t fromIntegral :: Int -> Integer
14:03:10 <lambdabot> Int -> Integer
14:03:19 <skorpan> what's all this magic about the ST monad which lets you do O(1) array updating?
14:03:39 <gwern> read the paper
14:03:40 <Phyx-> copumpkin: i'm playing around wih the wheel method of generating primes on at http://haskell.org/haskellwiki/Prime_numbers
14:03:45 <Phyx-> but it isn't type correct
14:03:45 <Phyx-> lol
14:03:48 <Taejo_> skorpan: it updates in-place, so O(1) is easy
14:04:04 <gwern> yadda yadda hidden type yadda yadda unsafe primitives yadda yadda referentially transparent anyway
14:04:07 <benmachine> cabal is refusing to update my parsec to 3.0.0 due to dependencies
14:04:08 <benmachine> ho hum.
14:04:11 <benmachine> well
14:04:12 <Taejo_> the magic is in *why* it can safely work in-place
14:04:18 <benmachine> it is insisting there is no upgrade
14:04:20 <Taejo_> basically, what gwern said
14:04:22 <benmachine> I presume dependencies are to blame
14:04:25 <roconnor> skorpan: ST is like an IO monad that only does memory access
14:04:51 <roconnor> skorpan: so runST can wrap up the memory access giving a pure interface
14:05:03 <skorpan> so where is this paper?
14:05:15 <orclev> benmachine, better than my luck, I keep getting an error about circular dependency with unix and directory, and neither one will compile cleanly for me
14:05:28 <roconnor> the only tricky bit is to use phantom variables so that different instances of runST don't interact with each other (which would require realWorld to split)
14:05:33 <gwern> skorpan: linked from the module, I should think
14:06:01 <copumpkin> splitRealWorld :: RealWorld -> (RealWorld, RealWorld) -- zomg
14:06:15 <copumpkin> it's like a wormhole between parallel universes!
14:06:20 <SamB_XP_> roconnor: I thought RealWorld was only used in stToIO/ioToST?
14:06:24 <valleypumpkin> like, totally
14:06:25 <Phyx-> gwern: know who i can poke to fix that? the Int's in the Wheel datatypes need to be Integers
14:06:31 <skorpan> oh wait a minute... ST monad -> STM -> state transactional memory (?) ?
14:06:37 <gwern> Phyx-: huh?
14:06:41 <valleypumpkin> skorpan: nope
14:06:44 <SamB_XP_> skorpan: nope!
14:06:49 <skorpan> darn.
14:06:54 <SamB_XP_> STM is Simple Transactional Memory
14:06:59 <SamB_XP_> is it not?
14:07:01 <valleypumpkin> yup
14:07:03 <valleypumpkin> software
14:07:06 <valleypumpkin> transactional memory
14:07:07 <valleypumpkin> not simple
14:07:10 <SamB_XP_> oh!
14:07:14 <valleypumpkin> although simple would be nicer
14:07:16 <Phyx-> gwen http://haskell.org/haskellwiki/Prime_numbers contains a type incorrect implementation
14:07:19 <Phyx-> lol
14:07:19 <SamB_XP_> whatever
14:07:21 <valleypumpkin> as maybe one day we'll get hardware support for it
14:07:22 <skorpan> we are all wrong today
14:07:27 <SamB_XP_> it seemed pretty simple to me regardless ...
14:07:28 <roconnor> skorpan: we?
14:07:36 <skorpan> roconnor: SamB_XP_ and i
14:07:39 <gwern> skorpan: ich ein bin bushes?
14:07:50 <gwern> Phyx-: why not just edit it?
14:07:51 <mle> hardware support for splitRealWorld would be interesting also.
14:07:59 <skorpan> gwern: i don't speak weird
14:08:02 <Phyx-> gwern: oh, i can?
14:08:10 <gwern> Phyx-: well, it is a wiki
14:08:32 <Phyx-> right
14:08:32 <SamB_XP_> mle: yes!
14:08:36 * Phyx- registers
14:08:39 <Phyx-> oh
14:08:45 <Phyx-> have to send mail to someone
14:08:47 <Phyx-> -.-
14:08:48 <SamB_XP_> mle: we have some physicists working on it
14:08:56 <valleypumpkin> mle: funny you should mention that, I've been building a "device" in my basement for 20 years now, and it's almost complete!
14:08:59 <SamB_XP_> for, among other things, the destruction of the earth
14:09:07 * valleypumpkin hides from SamB_XP_
14:09:23 <Phyx-> lol
14:09:23 <SamB_XP_> wait, no ...
14:09:26 * Phyx- mails gwern 
14:09:36 <SamB_XP_> destruction of the earth is used *with* such a device to make NP=P
14:09:45 <copumpkin> P does equal NP
14:09:48 <copumpkin> the reddit alien says so
14:09:54 <SamB_XP_> well, the universe, actually
14:10:04 <copumpkin> http://www.reddit.com/r/compsci/
14:10:13 <skorpan> ugh, the ST monad paper pdf is ugly
14:10:25 <copumpkin> skorpan: typographically?
14:10:35 <SamB_XP_> skorpan: is it a scan, or just uses type 3 fonts?
14:11:11 <skorpan> SamB_XP_: i don't know, it's just pixely and hard on the eyes
14:11:16 <skorpan> copumpkin: pixelally
14:11:26 <SamB_XP_> skorpan: I'm guessing it's a scan?
14:11:27 <monoidal> which paper?
14:11:43 <skorpan> lazy functional state threads
14:11:55 <Philonous> Couldn't I use underscores in guards instead of otherwise?
14:12:06 <skorpan> :t otherwise
14:12:08 <lambdabot> Bool
14:12:15 <skorpan> > otherwise == True
14:12:16 <SamB_XP_> would be sweet if there was a tool to replace ugly CM type3 fonts with nice type1 replacements
14:12:17 <lambdabot>   True
14:12:21 <ski> Philonous : no, `_' is not an expression
14:12:57 <Philonous> Ah ok, thanks. Must have been ocaml or something
14:13:21 <skorpan> how did people write pretty papers back in the days?  [tng]roff?
14:13:34 <gwern> they didn't
14:13:48 <gwern> you ever read old original papers from the 50s and 60s, scans thereof? buttugly
14:14:23 <gwern> the mathematicians had decent typesetting, but the computer scientists either reused the mathematician stuff or went without
14:14:39 <SamB_XP_> gwern: how is the former bad?
14:14:55 <gwern> they seem to've usually gone without...
14:22:26 <monoidal> igel, this bug was already noticed, but won't be merged in to 6.10
14:22:38 <skorpan> what's the tuple for here?  newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
14:22:51 <roconnor> skorpan: range of the array
14:23:01 <roconnor> and by range I mean domain :)
14:23:30 <igel> monoidal: wow that was fast :)
14:23:56 <skorpan> roconnor: what does that mean? :/
14:25:43 <sjanssen> skorpan: arrays in Haskell can have any bound on their indices
14:26:06 <sjanssen> (7, 10) or ('a', 'z') for example
14:26:45 <skorpan> oh, so every element contained in the array must be between the given bounds?
14:27:15 <sjanssen> no, these bounds define the indices
14:27:42 <copumpkin> so you can easily make 2d arrays by indexing by a pair
14:27:53 <skorpan> so if i do newListArray (7, 10) [1,2,3,4], what does that mean?
14:27:55 <copumpkin> it'll secretly get converted behind the scenes to a linear representation
14:28:08 <benmachine> Ix is a bit similar to Enum isn't it
14:28:13 <copumpkin> if you set arr to that
14:28:17 <copumpkin> arr ! 7 = 1
14:28:23 <sjanssen> skorpan: 1 is at index 7, 4 is at index 10
14:28:25 <skorpan> i see then
14:28:31 <benmachine> also what the hell is GHC.Arr.unsafeRangeSize
14:29:13 <sjanssen> benmachine: one can cause segfaults with bad Ix instances, unsafeRangeSize is the workaround for that
14:29:24 <benmachine> oh, fun
14:29:26 <ski> > tabulate ((1,1),(2,3)) (\(i,j) -> i ^ j) ! (2,3)
14:29:28 <lambdabot>   8
14:31:37 <benmachine> why in the heck is () an Enum
14:31:46 <benmachine> > [()..]
14:31:49 <lambdabot>   [()]
14:31:57 <benmachine> > [()..()]
14:31:59 <lambdabot>   [()]
14:32:03 <Deewiant> It's better than Float and Double being Enum
14:32:05 <ski> nice, yes ?
14:32:46 <benmachine> > fromEnum ()
14:32:47 <lambdabot>   0
14:33:02 <path[l]> is >>= the same as concatMap?
14:33:11 <path[l]> :t >>=
14:33:18 <lambdabot> parse error on input `>>='
14:33:20 <benmachine> path[l]: >>= is more general, it operates on Monads
14:33:26 <benmachine> a list is a monad
14:33:34 <sjanssen> path[l]: (>>=) on lists is concatMap with the argument order changed
14:33:39 <Deewiant> ?ty (>>=)
14:33:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:33:44 <path[l]> oh ok
14:33:50 <ski> @type (=<<)
14:33:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:34:04 <benmachine> for lists, it's [a] -> (a -> [b]) -> [b]
14:34:15 <Deewiant> ?ty flip concatMap
14:34:17 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
14:34:34 <path[l]> I guess Im gonna have to go and read the chapter on, what is a monad. :/
14:34:39 <ski> benmachine : "list" is a monad. lists are not
14:34:46 <benmachine> ski: k sry
14:34:55 <benmachine> I like how there is an instance for Bounded (a, b, ..., o) but not for Bounded (a, b, ..., p)
14:35:10 <Deewiant> Well, they had to stop somewhere
14:35:43 <ski> they're ultra-finitists !
14:35:54 <monoidal> haha
14:36:06 <benmachine> it would make sense to me if there were more general ways of working with tuples
14:36:17 <benmachine> some of the instances for them are just plain silly
14:36:42 <Deewiant> You'll rarely use tuples above the size of three or so anyway
14:36:54 <benmachine> yes
14:37:04 <monoidal> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
14:37:06 <benmachine> but that only demonstrates the silliness further
14:37:06 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61. a -
14:37:06 <lambdabot> > b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 ->
14:37:06 <lambdabot> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> (a, b, c, d, e, f, g, h, i, j,
14:37:06 <lambdabot> k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57,
14:37:08 <lambdabot> t58, t59, t60, t61)
14:37:40 <orclev> omgwtfbbq... that's just plain excessive
14:37:59 <benmachine> I believe that , are syntax and not a "real" function, is that right?
14:38:09 <benmachine> or, both perhaps
14:38:12 <path[l]> crap the RWH site is down. no explanation of monads for me :(
14:38:15 <Philonous> @Å§ype (,)
14:38:17 <lambdabot> forall a b. a -> b -> (a, b)
14:38:51 <SamB_XP_> Philonous: that only worked because of the spell-checking ...
14:38:56 <Deewiant> path[l]: Google has a cache
14:39:08 <path[l]> ah, let me look up that
14:39:43 <dschoepe> benmachine: why does not using higher tuples increase the silliness? It makes sense to provide a way to glue some values together without having to define a new data structure and it makes sense that seperate data structures are preferable when one has many components.
14:40:56 <SamB_XP_> oh, btw, that "lazy state threads" pdf is surely a scan... it uses only standard PS fonts (and I suspect they are not used to render anything that shows on the page)
14:41:40 <benmachine> dschoepe: the silliness is only in that we have large amounts of very similar code that most people never use and that stops at an arbitrary point
14:42:47 <path[l]> is a monad always a container type?
14:43:18 <SamB_XP_> http://research.microsoft.com/en-us/um/people/simonpj/papers/lazy-functional-state-threads.ps.Z is probably a good copy ...
14:43:22 <path[l]> when you say forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b ... it feels like you're saying you have a monad of a and this helps you create a monad of b
14:43:22 <dschoepe> benmachine: Ah, ok. I agree with you on that.
14:43:32 <Cale> path[l]: It's always possible to interpret it as a (sometimes very strange) container
14:43:57 <Cale> path[l]: But you often have to stretch your sense of the word "container"
14:44:44 <Cale> path[l]: For example, functions from a fixed domain can be thought of as a type of container indexed by elements of that domain.
14:45:01 <path[l]> hmm ok
14:45:27 <Berengal> Cale, how about reader and writer?
14:45:37 <Cale> reader is the same as functions on a fixed domain
14:45:48 <path[l]> so for >>= to work, doesnt the idea of "concat" and "for each a" need to exist in the doman?
14:45:54 <path[l]> err in the monad
14:45:55 <Cale> Writer is just a single value along with an additional "log"
14:46:14 <Berengal> Cale, sorry, I was thinking of something else...
14:46:25 <Cale> path[l]: yeah, you need "map", "join" and "return"
14:46:35 <path[l]> hmm
14:46:42 <ski> path[l] : a value of type `m a' is not a monad, `m' itself (the type) is a monad
14:46:49 <SamB_XP_> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.3718 even has it in PDF format
14:46:55 <path[l]> oh ok
14:47:04 <Cale> the type constructor
14:47:20 <Cale> A monad is a sort of function on types together with some extra functionality.
14:47:27 <SamB_XP_> skorpan: you wanted that paper?
14:47:27 * ski would not call `Cont Bool' a type constructor ..
14:47:34 <Berengal> imho {,f}map could benefit from being renamed to inside
14:47:37 <Cale> ski: I would...
14:47:37 <path[l]> so map describes how to apply a function on every "contained" element?
14:47:50 <Cale> ski: Well, perhaps type function is better.
14:47:53 <path[l]> join describes how to merge 2 containes
14:47:58 <ski> (`Cont' and `Bool' otoh, though ..)
14:48:02 <path[l]> return I still need to get
14:48:14 <Cale> path[l]: return creates a container with just that one value
14:48:19 <path[l]> ah
14:48:20 <path[l]> right
14:48:32 <path[l]> so fmap can use map and join
14:48:41 <Cale> fmap is map
14:48:41 <Berengal> fmap is map
14:48:44 <Cale> ;)
14:48:52 <path[l]> oh hmm
14:48:56 <ski> @src [] fmap
14:48:57 <lambdabot> fmap = map
14:49:06 <monoidal> and join is concat
14:49:10 <path[l]> >>= is map + join?
14:49:15 <Cale> right.
14:49:15 <Berengal> fmap describes how to apply a function to the value(s) inside the container
14:49:19 <monoidal> yes
14:49:24 <Cale> x >>= f = join (fmap f x)
14:49:34 <path[l]> hmm
14:49:37 <path[l]> ah
14:49:49 <Cale> Note that the container analogy isn't always the best one to apply, but if it helps, go right ahead.
14:49:55 <path[l]> and how about find? is it done using return + fmap? ... Im not sure
14:49:58 <Cale> find?
14:50:00 <Berengal> The "for each" is different for each container
14:50:06 <path[l]> the find operation
14:50:07 <Cale> There's not necessarily anything like find.
14:50:12 <path[l]> oh ok
14:50:30 <path[l]> Im still bound up with the list analogy
14:50:39 <ski> try `Maybe'
14:50:46 <Cale> These operations we've discussed, return, fmap, and join, along with things you can make from them, are all that you're guaranteed to have.
14:50:52 <path[l]> oh ok
14:50:54 <Cale> Any given monad will usually provide more.
14:51:04 <Cale> But they will be things specific to that one monad.
14:51:07 <path[l]> @ty >>
14:51:09 <lambdabot> parse error on input `>>'
14:51:14 <Cale> :t (>>)
14:51:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:51:20 <path[l]> ah
14:51:24 <path[l]> so >> is map?
14:51:30 <ski> @src >>
14:51:31 <lambdabot> m >> k      = m >>= \_ -> k
14:51:42 <ski> @type map
14:51:44 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:51:51 <Cale> x >> y = x >>= (const y) = join (fmap (const y) x)
14:52:13 <Philonous> I like to think of monads as computations with local side effects
14:52:31 <path[l]> hmm
14:52:39 <Cale> I like to think of monads as types of computations. (forget the side effects part)
14:52:47 <Berengal> I like to think of monads as boxes of apples in an ocean full of radioactive spacesuits
14:52:49 <path[l]> I didnt understand m a -> mb ->  mb
14:53:11 <Cale> path[l]: Okay, the (>>) operation makes more sense in the computation view than the container view.
14:53:17 <ski> i like to think of monads as providing effects (no "side")
14:53:20 <SamB_XP_> Berengal: now you're just combining imagary from bad monad tutorials in an arbitrary way!
14:53:27 <path[l]> ok
14:53:29 <Cale> path[l]: Let's look at the computation analogy.
14:53:29 <Berengal> SamB_XP_, it's how it was taught to me!
14:53:30 <Philonous> Cale: Why forget about the side effects? Isn't that exactly what monads are for?
14:53:48 <jmillikin> No, many (most?) monads have no side effects
14:53:57 <Cale> Philonous: computations of various sorts may have something you call effects, but there's no reason they need to be off to the side ;)
14:54:10 <ski> Philonous : monads are for "effects", the "side" is for imperative languages
14:54:15 <Cale> Philonous: and the word "effects" needs to be extremely general if you're going to use it.
14:54:18 <Berengal> "functions in a context" have always made sense to me
14:54:39 <path[l]> so a monad is a computation on some items? .... so fmap describes how to perform the computations on different tiems?
14:54:43 <Cale> To the point that people are more likely to be put off course by the word. You need to consider things like nondeterminism an "effect"
14:54:45 <ski> Philonous : "side" is when the effects are implicit/hidden, instead of explicit in the types, as in haskell
14:54:46 <Berengal> You're not dealing with the context, >>= is. You're just applying functions to values inside it
14:54:51 <path[l]> Im not sure what the computation analogy is
14:54:52 <SamB_XP_> of course, even the purest functions may e.g. make the CPU hot or eat all your RAM ...
14:54:58 <Cale> path[l]: Okay, let me go over it...
14:55:16 <Cale> path[l]: Maybe to prevent things from being too noisy, let's use #haskell-overflow
14:55:21 <path[l]> ok
14:55:25 <monoidal> > [1,2,3] >>= (\x -> ['a','b'] >>= \y -> return (x,y))
14:55:26 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
14:55:32 <monoidal> path[l]: ^
14:56:08 <jmillikin> With the new exception system, is there a way to imitate the old-style ``handle (\_ -> putStrLn "an error occured")``? I'm getting an error trying that example from RWH
14:56:17 <Philonous> ski: That's what I meant with "local".
14:56:34 <Berengal> SamB_XP_, and this is why we can't have nice things... at some point you have to compromise
14:56:39 <ski> Philonous : yes, i guessed that. but it nullifies the "side"
14:57:54 <SamB_XP_> Berengal: yeah ;-)
14:59:10 <Berengal> Ultimately, I just want to write awesome programs with as little effort as possible
15:00:53 <Deewiant> jmillikin: \(_ :: SomeException) -> ...
15:01:22 <jmillikin> Illegal signature in pattern: SomeException
15:01:41 <Deewiant> I guess you'll need ScopedTypeVariables for that
15:01:49 <jmillikin> It's working with (\(SomeException _) -> , is that the correct way?
15:01:53 <Deewiant> So use another way of enforcing its type to be SomeException
15:02:10 <Deewiant> Yes, I guess that's fine
15:04:04 <veinor> Berengal: Don't we all.
15:05:34 <orbitz> is there a pattern for when you are building a record or DT piecemeal?  For example I am turning an input file to a list of these datatypes and the input i sbroken across multiple lines in the file
15:07:16 <yitz> orbitz: break the input into a list of lines, then group the lines into records
15:07:17 <twanvl> orbitz: you can have the parser return a list of update functions, [DT -> DT]
15:07:22 <Berengal> orbitz, parsing works great
15:08:10 <Berengal> (MyDataType <$> parseFirstArg <*> parseSecondArg <*> parseThirdArg) `sepBy` parseSeparator
15:08:31 <Berengal> Unless I'm misunderstanding the layout
15:08:35 <orbitz> Oh i was going with something a bit more homebrewed, as an exercise
15:08:47 <orbitz> Berengal: i think what you wrote is basialy what i'll be writing
15:09:14 <Berengal> orbitz, writing a parser capable of what I did is about 50 lines of code
15:09:35 <Berengal> Using only prelude definitions
15:09:38 <orbitz> Berengal: yeah i dont' think it iwll be much, just getting used to writing FP
15:10:28 <Berengal> Of course, going for a more ad-hoc approach can also work. I've found view-patterns and stripPrefix work nicely
15:10:29 <yitz> Berengal: it doesn't take 50 lines of code to use the "lines" function, then group them, if the syntax of the file is simple enough not to require a serious parser
15:10:49 <orbitz> yitz: it is simple enough
15:10:58 <yitz> 2 or 3 lines ought to do it
15:11:51 <Berengal> yitz, indeed. I was talking about an unserious but proper parser
15:11:56 <yitz> otoh if things start to get too complicated, you are right that there's no reason to re-invent the wheel
15:12:25 <Berengal> newtype Parser a = Parser (String -> (a, String))
15:12:32 <Berengal> Or just use ReadS
15:12:38 <dschoepe> or parsec
15:12:41 <Berengal> or parsec, or whatever
15:13:20 <yitz> personally I find that it's pretty rare that I need the power of parsec.
15:13:47 <yitz> orbitz: is each record the same number of lines in the input file?
15:14:20 <rdeshpande> does anyone know if there is a mirror for the RWH book online? realworldhaskell.org seems down
15:14:22 <Berengal> yitz, I tend to use parsec a bit too much when dealing with strings...
15:15:03 <yitz> Berengal: that's not such a terrible habit
15:15:06 <arw> too much of parsec? what would you rather use, strstr?
15:15:11 <hackagebot> graphtype 0.1 - A simple tool to illustrate dependencies between Haskell types (DmitryAstapov)
15:15:36 <benmachine> > return undefined
15:15:39 <lambdabot>   No instance for (GHC.Show.Show (m a))
15:15:39 <lambdabot>    arising from a use of `M3223494283...
15:15:46 * benmachine hms
15:15:56 <benmachine> when I do return undefined at a ghci prompt, nothing happens
15:16:19 <dschoepe> benmachine: try return undefined :: IO Int
15:16:35 <benmachine> dschoepe: mm, that does what I'd expect
15:16:40 <arw> after reading quite sime perl, c, c++ and fortran string handling, parsec is like reading beautiful lyrics about your beloved...
15:16:47 <burp> rdeshpande: google books has realworldhaskell afaik
15:17:02 <burp> or use google cache ;)
15:17:11 <benmachine> I'm surprised I didn't get ambiguous type variable or something
15:17:25 <benmachine> (for the un-siged version)
15:17:33 <yitz> benmachine: it defaults to (), and ghci doesn't print IO ()
15:17:42 <benmachine> ah
15:17:46 <Berengal> yitz, I've had worse habits, indeed
15:17:52 <yitz> hehe
15:17:57 <benjorino> Hi, does anybody know if it is possible to write half a program in haskell and half in C++?
15:18:07 <benjorino> I want to write a game physics engine in haskell
15:18:16 <benjorino> but use c++ for rendering
15:18:18 <dschoepe> benjorino: it is, there's the FFI
15:18:26 <dschoepe> (foreign function interface)
15:18:26 <benjorino> the FFI ?
15:18:31 <benjorino> okay
15:18:33 <Berengal> benjorino, you would probably have more success using c as the interface language
15:18:46 <benjorino> okay
15:19:36 <benjorino> Will google be sufficient to learn about this sort of stuff, or is there anywhere in particular I should be looking to learn?
15:19:45 <benjorino> and thanks for the replies :)
15:19:58 <dschoepe> benjorino: http://haskell.org/haskellwiki/FFI
15:20:03 <rdeshpande> burp: thanks *burp*
15:20:22 <benjorino> Many thanks :)
15:23:21 <path[l]> :t >>=
15:23:23 <lambdabot> parse error on input `>>='
15:23:35 <byorgey> @type (>>=)
15:23:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:23:38 <byorgey> needs parentheses
15:23:40 <benmachine> infix operators like that work better in parentheses
15:23:45 <benmachine> when on their own
15:23:45 <path[l]> :t (>>=)
15:23:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:23:51 <benmachine> it de-infixes them
15:33:00 <Vanadium> State : StateT :: ST : ???
15:36:06 <byorgey> Vanadium: there's no ST transformer; indeed, there cannot be.
15:36:16 <byorgey> although the reason why escapes me at the moment.
15:36:44 <byorgey> ST, like IO, must always be at the bottom of a stack of monad transformers.
15:36:53 <Vanadium> Okay. :(
15:37:09 <Berengal> I assume there /could/ be one theoretically. Maybe not in code...
15:37:27 <Berengal> As in, maybe you can't support it in the current framework...
15:37:57 <monoidal> :k (->)
15:37:59 <lambdabot> ?? -> ? -> *
15:38:07 <monoidal> what are those ?? and ?
15:38:33 <byorgey> monoidal: they are special kinds internal to GHC that have to do with unboxing.
15:38:50 <byorgey> monoidal: you can safely ignore them unless you care about the internals of GHC.  just think of them as *.
15:39:38 <nlogax> i ported some basic functions from haskell to js, they become so ugly, boohoo..
15:39:41 <monoidal> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes - this that?
15:39:59 <monoidal> *is this that?
15:41:59 <monoidal> it seems it is. thanks
15:45:14 <bos> edwardk1: your slides from last week are great!
16:00:08 <Vanadium> @src unsafeInterleaveIO
16:00:08 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
16:00:15 <Vanadium> @src unsafePerformIO
16:00:15 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
16:00:19 <Vanadium> ... :|
16:00:54 <ray> real world unboxed =o
16:01:15 <Cale> The real world thing there is just a silly token value.
16:01:28 <Cale> (the type only has one value in it anyway)
16:01:29 <Vanadium> @src lazy
16:01:29 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:01:40 <Vanadium> Trying to figure out the difference between Perform and Interleave
16:01:56 <Cale> It's just a hack to make sure that GHC gets the data dependencies right.
16:02:03 <benmachine> @type unsafeInterleaveIO
16:02:06 <lambdabot> Not in scope: `unsafeInterleaveIO'
16:02:10 <benmachine> oh yeah
16:02:19 <Berengal> unsafeInterleaveIO :: IO a -> IO a
16:02:20 <Cale> er, to make sure it gets the effects in the right order by following the data dependencies, rather
16:02:24 <Berengal> unsafePerformIO :: IO a -> a
16:02:51 <benmachine> is unsafeInterleaveIO a bit like return . unsafePerformIO?
16:03:07 <benmachine> wait that makes no sense
16:03:09 <benmachine> or does it
16:03:19 <Berengal> Sort of
16:03:44 <Berengal> I guess it does
16:03:56 <Vanadium> (Is IO a equal to RealWorld -> (# RealWorld, a #)?)
16:04:08 <EvilTerran> ?src IO
16:04:09 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
16:04:17 <EvilTerran> ?src State#
16:04:18 <lambdabot> Source not found. There are some things that I just don't know.
16:04:34 <Cale> State# is another not-so-meaningful thing.
16:04:54 <Vanadium> Oh well.
16:04:54 <Berengal> It's best not to ponder the internals of ghc unless you have business there
16:05:19 <Cale> Actually, I think State# is something like   data State# t = State#
16:05:30 <Cale> Or maybe even empty...
16:05:43 <copumpkin> it's empty
16:05:46 <Cale> right
16:06:41 * benmachine thinks lambdabot could just as well give newtype IO a = {- ... magic ... -}
16:06:59 <Cale> Yeah, it's unfortunate that GHC has such a magical implementation of the IO monad
16:07:16 <Berengal> IO is magic though
16:07:31 <Cale> There's a way to separate the magic part from the monad part.
16:07:48 <Cale> You can have values of type IO t which are completely non-magical.
16:07:54 <Vanadium> http://www.haskell.org/haskellwiki/IO_inside has not-so-magic looking example definitions of a bunch of IO stuff, though.
16:08:11 <copumpkin> it doesn't seem unreasaonbly magical, it claims IO is State where RealWorld is the state being implicitly passed around
16:08:16 <Vanadium> I figure that people who have problems grasping IO are not digging through ghc sources for answers.
16:08:28 <Cale> and put all the magic into the interpreter in the runtime system that carries out the actions described by values of type IO t
16:08:33 <EvilTerran> Vanadium, except when ?src presents those ghc sources to them
16:08:34 <Berengal> Cale, the data IOAction = PutChar Char | GetChar | ... thing?
16:08:49 <Cale> Berengal: Something like that
16:08:56 <Vanadium> EvilTerran: I thought the src comment actually uses its own set of definitons?
16:09:08 <copumpkin> it does
16:09:11 <Cale> Berengal: Probably a GADT of some sort.
16:09:18 <Berengal> Cale, works better as an analogy than an actual implementation I think
16:09:38 <benmachine> the internal workings of @src are basically just a text file that lambdabot looks stuff up in
16:09:48 <benmachine> (where the text file is not the GHC source)
16:09:48 <Cale> Berengal: It would work fine as an implementation, but might be a small bit slower than the existing one unless you went to a lot of trouble in compiling things.
16:09:57 <EvilTerran> Vanadium, yes, ?src works from its own list of definitions; it's just some of them come from the GHC sources, and some of those really shouldn't
16:10:03 <EvilTerran> such as IO
16:10:27 <Berengal> Cale, oh, I'm not worried about the compiled code. The compiler should be smart enough, even if it had to be special cased. I'm more worried about writing and maintaining it
16:11:27 <Cale> Berengal: Oh, it would be fine like that. Much better than the current system as far as maintenance, because there would be less magic.
16:11:55 <Cale> Berengal: unsafePerformIO might be harder to write ;)
16:12:14 <rdeshpande> with the 'read' function, what is the process of execution of 'read "5" + 2'? I'm trying to understand how "5" becomes an int and how haskell knows that the result should be an int?
16:12:15 <Cale> But not really.
16:12:29 <Cale> rdeshpande: First, it's typechecked.
16:12:55 <Cale> rdeshpande: numeric defaulting turns the (Num a) => a type inferred for the expression into Integer
16:13:24 <rdeshpande> ok, so haskell is doing the "5" + 2 first, and knows to return 7 :: Int?
16:13:27 <Cale> rdeshpande: and then the implementation of read for Integer is used (well, the dictionary for the Read class is passed in)
16:13:47 <EvilTerran> rdeshpande, the types are worked out at compile-time
16:13:55 <Cale> It's typechecking statically, which determines the type which needs to be parsed, and passing in an appropriate parser after the type is known.
16:13:58 <Vanadium> rdeshpande: Haskell is looking at the +, notices that the 2 is an Int, so clearly read "5" must be an Int too.
16:14:25 <Cale> The 2 isn't likely inferred to be Int unless you gave an explicit signature.
16:14:31 <Cale> It'll be Integer
16:14:36 <rdeshpande> ah
16:15:09 <Cale> Well, it'll be polymorphic, and then there's a special case for numbers in the type system which causes numeric types to be defaulted to Integer or Double
16:15:37 <Cale> (but that happens at the top of compiling the whole module)
16:15:49 <Cale> Well, it's a detail that probably shouldn't concern you too much
16:16:00 <rdeshpande> interesting
16:16:04 <rdeshpande> okay thanks guys
16:16:08 <Cale> Supposing we know that 2 is an Integer, then it knows which parser to use on the string anyway
16:16:22 <Cale> because (+) :: (Num a) => a -> a -> a
16:16:30 <Cale> So the read "5" must be the same type
16:16:35 <rdeshpande> i see
16:17:29 <rdeshpande> so the type is inferred by the defined type definitions of the functions used?
16:17:57 <EvilTerran> pretty much
16:19:23 <EvilTerran> the exact algorithm is fairly involved
16:19:56 <rdeshpande> awesome
16:20:31 <EvilTerran> but basically, it involves working out what the type of expressions must be either based on the types of their sub-expressions (the "inferred type"), or the type that must go where the expression is based on its context (the "expected type")
16:21:38 <Cale> rdeshpande: And typeclasses are all about deciding on an implementation based on the types.
16:21:46 <suitdetony> cuando nací me dijo la partera: hay mijo cuando estés grande pobre de la chava que te de las nalgas si que va a gritar en la primera noche que se meta contigo ya que pareces burro jajajaja
16:21:53 <EvilTerran> in read "5" + (2 :: Int), say, the type of the expression of a whole can be inferred from the type of the 2 to also be Int, and then the type of the read "5" can be expected to be Int likewise
16:22:01 <EvilTerran> working with the type of (+) in both steps
16:22:58 <EvilTerran> er... "when I was born, the midwife said to me: ..."? that doesn't sound haskell-related
16:24:49 <ray> yeah, the midwife said that to me when i was born too
16:25:30 <ray> i just pointed out that it was #deliveryroom-bla
16:25:32 <ray> h
16:33:29 <monoidal> thought: instances could be first-class objects, and given optionally to polymorphic functions. For example, sort could optionally be given an instance of Ord, which is basically a comparing function.
16:33:56 <Berengal> monoidal, there are implicit parameters for that
16:34:19 <monoidal> Or, mconcat could be given (+,0) monoid, and this wouldn't require wrappers. This would eliminate many functions
16:35:17 <dolio> Instances as first class objects would probably be what you'd usually call "first class modules".
16:35:45 <dolio> Ala ML, although I'm not sure you can precisely "pass modules to a function", but they have similar uses.
16:35:58 <dolio> And yes, they're great.
16:36:17 <monoidal> Berengal, seems this is what I have thought about. Thanks. There's a nice paper, "how to make ad-hoc polymorphism less ad-hoc" that describes that
16:37:46 <Berengal> monoidal, they're not used much at all
16:38:45 <dolio> Also, Agda lets you locally open dependent records as if they were modules, which gives you similar options.
16:40:11 <dolio> Of course, neither of those gets you the nice part of type classes, which is that the type system has a built-in solver of sorts to fill in appropriate modules/records automatically.
16:40:54 <dolio> Coq might.
16:41:15 <Toxaris> afaik you cannot let Coq infer modules
16:41:29 <Toxaris> but Coq has haskell-style typeclasses now
16:41:53 <Toxaris> and you can supply your own tactics for solving typeclass constraints
16:42:01 <augustss> dolio: Agda 1 has type classes, Agda doesn't
16:42:07 <augustss> Agda 2 doesn't
16:42:09 <EvilTerran> Toxaris, oooooh
16:42:36 <EvilTerran> Toxaris, what does it do with overlapping/incoherent instances?
16:42:49 <EvilTerran> can you specify how to resolve those, too?
16:42:58 <dolio> Oh. I don't really know much about agda 1.
16:43:32 <Toxaris> EvilTerran: you provide tactics with priority hints, and they are called in order until one succeeds
16:43:50 <augustss> Is there a Unicode character for 3 vertical dots?
16:43:51 <Toxaris> EvilTerran: but you can specify your type class so exactly, that only correct implementations can succeed
16:43:56 <dolio> Toxaris: Yeah, I meant the type classes. They're sugar for dependent records + a suitable solver, from the paper I read.
16:44:01 * EvilTerran adds "download the latest version of coq" and "learn how to use coq" to his to-do list
16:44:32 <Toxaris> EvilTerran: what does it matter which Functor instance is infered, as long as it keeps the functor laws
16:44:43 <suitdetony> hi my name is tony I am from Guadalajara and I am looking for a beautiful girl my email is: suitdetony@hotmail.com tank you
16:44:55 * mattam lurks
16:44:56 <dolio> â®
16:45:08 <Toxaris> dolio: yes
16:45:09 <EvilTerran> augustss, U+22EE Vertical Ellipsis
16:45:18 <augustss> Great!
16:45:22 <EvilTerran> â®
16:46:25 <Berengal> implicit parameters might be nice for some ad-hoc typeclasses...
16:46:32 <augustss> dolio, EvilTerran: thanks, you saved me a lot of trawling through unicode tables
16:47:25 <EvilTerran> all i did was
16:47:25 <EvilTerran> ?go site:unicode.org vertical ellipsis
16:47:27 <lambdabot> http://unicode.org/charts/PDF/UFE10.pdf
16:47:27 <lambdabot> Title: cache:http://unicode.org/charts/PDF/UFE10.pdf - Google Search
16:47:36 <dolio> I just used agda mode. :)
16:47:45 <dolio> \vdots
16:48:02 <EvilTerran> altho i guess it did require an educated guess to realise that's what the symbol would be called
16:48:18 <augustss> i might have guessed that name
16:49:07 <EvilTerran> my first thought was "colon; comining diacritical dot above" :P
16:49:13 <EvilTerran> *combining
16:49:35 <Cale> A colon is what happens when the dots slide off of Ã¤
16:50:36 <lispy> ?hoogle dropLast
16:50:37 <lambdabot> No results found
16:50:53 <lispy> Is there a prelude or Data.List function to drop only the last element of a list?
16:51:01 <augustss> init
16:51:07 <lispy> ah, thanks
16:51:23 <augustss> not the best name, imo
16:51:37 <lispy> I knew about inits, but I didn't even think to try init
16:53:50 <Berengal> My x-server just restarted itself :/
16:55:36 <Berengal> Looks like a segfault in the nvidia drivers
16:56:20 <p_l> Berengal: better than intel...
16:57:38 <Berengal> Actually, I'm not too sure what caused it...
16:58:19 <Berengal> First Xorg segfaults in nvidia_drv.so, then pidgin segfaults in libX11.so half a second later
16:58:26 <Berengal> Guess the last was caused by the first though
17:01:02 <mjs22> f/quit
17:03:08 <SamB_XP_> Berengal: well, I don't think libX11 really has any excuse for that unless it's actually pidgin's fault ...
17:04:37 <Berengal> SamB_XP_, it's probably the least catastrophic segfaults of the two though. The first one has to be the one that killed X
17:04:52 <SamB_XP_> yeah
17:05:13 <SamB_XP_> I'd blame nvidia and/or MS for that one ;-P
17:05:58 <Berengal> I can live with a program that's going to be killed anyway segfaulting
17:06:05 <Berengal> why MS?
17:06:53 <SamB_XP_> for Windows, which, as the leading OS, encourages closed-source video drivers ...
17:08:27 <Berengal> Ah, like that
17:11:36 <p_l> SamB_XP_: MS itself wouldn't care, I guess, but certain other parties might
17:12:09 <SamB_XP_> well, I mean, they provide fairly stable ABIs and so on ...
17:12:16 <skorpan> DID SOMEONE SAY PARTY
17:12:42 <hydo> Peetha parteeee
17:12:44 <SamB_XP_> skorpan: I gave the citeseerx URL for that paper with the ugly scan ...
17:12:55 <SamB_XP_> but the citeseerx url has a non-scanned version
17:13:05 <skorpan> no, that's the one i had already
17:13:09 <skorpan> looks horrible here
17:13:12 <rdeshpande> can someone explain to me why this fails? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8458#a8458 .. how come somefunc [1,2] doesn't just pattern match on the second line and do the comprehension? why does changing the first line to somefunc [] = [] fix it?
17:13:29 <rdeshpande> oh, wait, nevermind
17:13:54 <skorpan> rdeshpande: you sure like shadowing names
17:14:02 <skorpan> "x" and "all"
17:14:27 <skorpan> there is really no need to pattern match on the head of the list
17:14:39 <skorpan> you can just do somefunc xs = [ x ** x | x <- xs ]
17:15:01 <Berengal> If a list isn't nil then it's not empty
17:15:10 <EvilTerran> also, the first branch is resulting in a number, and the second in a list
17:15:11 <Berengal> No exceptions
17:15:20 <Alejo> ?
17:15:21 <benmachine> or somefunc xs = map (\x -> x ** x) xs, indeed
17:15:21 <skorpan> EvilTerran: details ;P
17:15:37 <Alejo> alguien habla español
17:15:38 <Alejo> ?
17:15:53 <Alejo> hi
17:15:56 <benmachine> @seen lambdabot
17:15:56 <lambdabot> Yes, I'm here. I'm in #kata, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.
17:15:56 <lambdabot> it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-iphone, #haskell-in-depth, #haskell-freebsd, #
17:15:56 <lambdabot> interplanetarylazers, #learnanycomputerlanguage, #uscs2009, #macosx, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #bfpg, #
17:15:56 <lambdabot> novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
17:16:13 <Alejo> does somebody knows somwthing about gwt?
17:16:23 <Alejo> ah????
17:16:26 <benmachine> Alejo: #haskell.es?
17:16:27 <Alejo> gwt?
17:16:36 <Alejo> i need some help
17:16:48 <Berengal> What's gwt?
17:16:58 <tomh-> google web toolkit
17:16:58 <Alejo> google web toolkit
17:17:07 <tomh-> wrong channel man
17:17:13 <Alejo> does somebody knows something about?
17:17:18 <Alejo> mmm... ok
17:17:29 <Alejo> thx
17:17:35 <tomh-> try #gwt or #googlewebtoolkit
17:17:47 <hydo> all I know is that it's java only afaik
17:18:21 <hydo> Ugh.. Phone irc client = slow typing.
17:18:55 <Berengal> Ugh... java
17:19:02 <tomh-> owns
17:19:20 * Berengal is suddenly filled with an overwhelming urge to rant
17:19:34 <tomh-> haha
17:19:36 <hydo> About java?
17:19:40 <Berengal> Yes
17:19:56 <hydo> Don't let me get in your way.
17:19:57 <tomh-> i like java
17:20:06 <hydo> Let it out!
17:20:19 <Berengal> I'll instead just ask; how do I make java not suck?
17:20:35 <tomh-> hehe
17:20:40 <Berengal> Also, how can I mark arguments to java functions @NotNull without waiting for EJB3?
17:20:49 <tomh-> use a nice IDE and it sucks less :)
17:20:57 <hydo> Clojure maybe?  Or that other one?
17:21:00 <Berengal> tomh-, there aren't any nice IDEs
17:21:13 <Berengal> hydo, unfortunately, they're not java :/
17:21:21 <tomh-> i agree, eclipse is meh, but its still the best
17:21:55 <hydo> Well true.. I was thinking running on the jvm would be enough.
17:22:32 <tomh-> the thing I like about java is that it is a small language
17:22:38 <tomh-> there are not 10k concepts
17:22:41 <Berengal> hydo, I was hoping that too, but it's unfortunately not good enough... Not even python will do, it has to be java :(
17:23:38 <kpreid> tomh-: but the standard libraries entirely make up for that :-)
17:24:01 <tomh-> hehe
17:24:32 <tomh-> yeah those standard libs require quite a lot of verbose code
17:24:32 <Berengal> I wish there were more concepts. Maybe there wouldn't be all these "patterns" around with a few good ones
17:25:23 <tomh-> I dunno
17:25:24 <Berengal> Like lambdas, static purity and graph reduction
17:25:35 <Berengal> Perhaps even lazy evaluation
17:25:52 <tomh-> I code haskell for like 3-4 years (not fulltime) but still have no clue how to create a monad
17:26:13 <tomh-> i know the monad rules, but cant think of a use case
17:26:35 <Berengal> Creating monads is overrated.
17:26:48 <EvilTerran> if a non-trivial recurring pattern in people's code in a language can't be abstracted out, i'd call that a deficiency in the language
17:27:06 <benmachine> Network.PortID is horrible to work with
17:27:13 <benmachine> it doesn't have a Read or Show
17:27:20 <benmachine> despite both being trivial
17:27:45 <benmachine> the PortNumber constructor pointlessly invents its own
17:27:52 <benmachine> Num, which doesn't read either
17:28:00 * benmachine grumble grumble grumble
17:37:54 <hackagebot> graphtype 0.1.1 - A simple tool to illustrate dependencies between Haskell types (MaxDesyatov)
17:39:11 <sbahra> benmachine, you could change that easily. :-)
17:39:28 <benmachine> sbahra: I could were I not going on holiday tomorrow!
17:39:30 <sbahra> benmachine, at least in your own project, you could define it as an instance of read/show.
17:39:37 <benmachine> I suppose so
17:39:58 <benmachine> @tell benmachine Network read/show instances!
17:39:59 <lambdabot> You can tell yourself!
17:40:01 <benmachine> aw :P
17:40:08 * benmachine goes to bed
17:40:32 <augustss> EvilTerran: I agree.  I wished some of the Haskell deficiencies will be fixed.
17:40:37 <Badger> @tell benmachine Network read/show instances!
17:40:37 <lambdabot> Consider it noted.
17:41:19 <orclev> java programming is what pays my bills... well, that and C#, although I don't much care for C#
17:41:47 <EvilTerran> augustss, it's a far less frequent problem in haskell than in, well, any language in which "design patterns" find wide-spread use
17:42:24 <augustss> EvilTerran: yes, but it still annoys me when I can't abstract in Haskell
17:43:29 <augustss> EvilTerran: contexts and patterns are my pet peeves
17:43:31 <Berengal> augustss, as a java programmer by trade, "cannot abstract" is the default state of programming...
17:43:44 <orclev> Berengal, lol
17:43:58 <Berengal> Programming in haskell feels like.. I don't know how to describe it properly...
17:43:59 <augustss> Berengal: but I'm a Haskell programmer by trade :)
17:44:10 <syntaxglitch> in the "real world" of programming, you're lucky to find people who don't think "code reuse" means "copy and paste"
17:44:14 <Berengal> It feels really good not to constantly swap your own brain-state
17:44:15 <syntaxglitch> :(
17:44:33 <orclev> syntaxglitch, ewww, don't remind me, I've worked with those people
17:44:43 <lispy> augustss: what do you mean by cannot abstract in Haskell?
17:45:13 <augustss> lispy: If I have a recurring pattern in my Haskell code I can't give it a name and reuse it.
17:45:23 <augustss> lispy: As an example
17:45:24 <orclev> worst one of the bunch was one that I made the mistake of helping once with some CSS... even after I showed him the O'Reilly book I used to answer his question he still kept asking me questions
17:45:58 <EvilTerran> augustss, i was just thinking that i wished i could do more with contexts earlier tonight...
17:45:59 <augustss> lispy: mostly haskell is great at abstraction, but there are some flaws
17:46:04 <lispy> orclev: build a fire for a man and you keep him warm for a day; set a man on fire and you keep him warm for the rest of his life :)
17:46:41 <orclev> lispy, if only I could... and he was the programming lead
17:46:43 <augustss> EvilTerran: you can kinda make context synonyms with a new class and a new instance, but it's klunky
17:47:14 <EvilTerran> indeed
17:48:03 <augustss> But with patterns you have to use CPP to abstract :(
17:48:09 <EvilTerran> TH helps to alleviate some of the abstraction problems
17:48:16 <augustss> I never use TH
17:48:26 <EvilTerran> but it can be very painful to use
17:48:27 <Berengal> first-class patterns would be really nice to have
17:48:34 <copumpkin> Berengal: SHE has them
17:48:43 <Berengal> copumpkin, does she now?
17:48:43 <EvilTerran> you can't do first-class patterns with it, because there's no pattern-quoting construct
17:48:47 <copumpkin> @hackage she
17:48:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/she
17:48:50 <EvilTerran> (also, i don't think you can splice in patterns)
17:48:53 <augustss> I'm not asking for first class patterns, just patterns synonyms would go a long way
17:49:02 <augustss> I know SHE has them
17:49:20 <Berengal> copumpkin, hah, best package description ever
17:49:26 <copumpkin> :)
17:49:27 <orclev> I can't wait till I'm actually good enough with Haskell to be able to contribute meaningfully to this discussion :P
17:49:39 <solrize_> what would first class patterns look like?
17:50:00 <lispy> augustss: I'm a little confused as to what type of pattern you want
17:50:04 <augustss> pattern P a = (a,a,a)
17:50:14 <lispy> augustss: With laziness we can usually create an ADT to represent control flow
17:50:18 <augustss> Sorry, that one is bnad
17:50:20 <augustss> bad
17:50:30 <augustss> pattern P a = (1,2,a)
17:50:31 <copumpkin> pattern NilF = Plus (Left (K ()))
17:50:39 <augustss> foo (P x) = x
17:50:44 <augustss> i.e.
17:50:44 <EvilTerran> solrize_, i'm thinking "pattern Foo x y = (Left x, 0:y:_)" kinda thing as a definition, then ((x,y) where Foo x y = (Left 1, [0,2])) = (1,2)
17:50:50 <augustss> foo (1,2,x) = x
17:51:00 <solrize_> ic
17:51:05 <solrize_> thanks
17:51:06 <Berengal> I sort of think of patterns as functions from a type to a tupple
17:51:09 <EvilTerran> er, some dodgy syntax with that where there, but you get the idea
17:51:12 <copumpkin> http://www.e-pig.org/epilogue/?p=198
17:51:18 <lispy> Oh, you mean pattern matching patterns :) I thought you meant design patterns
17:51:47 <augustss> I never speak of design patterns :)
17:52:14 <lispy> I had to implement double dispatch for something at work on Friday because C# is only single dispatch
17:52:15 <Berengal> Perhaps some hack using catchIO and unsafePerformIO could turn into a combinator combining lambdas...
17:52:57 <Berengal> (\ [] -> []) `patternCombine` (\(x:xs) -> [x])
17:54:16 <Berengal> You could then 'foldr patternCombine (const patternMatchError) [(\0 -> 0), (\1 -> 2), (\x -> x)]'
17:54:51 <dolio> Can you work some unsafeCoerce in there?
17:55:17 <Berengal> Dunno
17:55:17 <EvilTerran> Berengal, i've written a TH that takes (\PAT -> EXP) and makes it (let f PAT = EXP; f _ = fail "some useful message")
17:55:49 <Berengal> patternCombine :: (a -> b) -> (a -> b) -> a -> b
17:55:51 <EvilTerran> $(fails [| \Just x -> x |]) = (let f (Just x) = x; f _ = fail "..." in f)
17:55:54 <fbru02> lsipy how did u do it ? with reflection ?
17:56:01 <fbru02> lispy
17:56:32 <EvilTerran> sadly, i had to construct the syntax tree of the let/in entirely manually, instead of with quotes and splices
17:56:37 <EvilTerran> because you can't splice patterns :(
17:56:37 <smarmy> fbru02: visitor, i'd imagine
17:56:57 <Berengal> EvilTerran, does it compose well?
17:57:19 <lispy> fbru02: I just implemented it in the traditional way
17:57:41 <lispy> I guess in C# 4.0 you have dynamic and you can just do it the multidispatch way
17:57:44 <EvilTerran> Berengal, because it's fail instead of error, you can use mplus to do fallthrough
17:57:56 <lispy> single dispatch always messes with my head
17:58:04 <EvilTerran> (arguably, i should use mzero instead of fail)
17:58:08 <lispy> I've been using multidispatch languages for years now
17:58:14 <lispy> CL and Haskell
17:58:49 <Berengal> EvilTerran, you get a monad in there though... Still, Maybe and friends is prefered for failable things anyway
17:59:04 <EvilTerran> Berengal, so... use the Maybe monad!
17:59:17 <skorpan> haskell has multiple dispatch?
17:59:32 <skorpan> i wasn't even aware stuff like that applied to pure functional languages
17:59:40 <Berengal> EvilTerran, the problem is, can you compose that again?
17:59:51 <EvilTerran> Berengal, how do you mean?
17:59:54 <Berengal> EvilTerran, or even, can you take a list of functions and fold them into one?
18:01:22 <lispy> skorpan: Well, we don't have subtyping here, so it's easy :)
18:01:31 <EvilTerran> ?type \fs x -> msum $ map ($x) fs -- Berengal, this should do the job
18:01:32 <lispy> skorpan: but, type classes have dispatch
18:01:32 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => [a1 -> m a] -> a1 -> m a
18:01:47 <EvilTerran> assuming your fs are all of the $(fails [|...|]) form (or compatible therewith)
18:02:13 <Berengal> EvilTerran, it's the assumption I've got trouble with
18:02:25 <EvilTerran> it's noisier than i'd like
18:02:43 <Berengal> You can't just take a partial function a -> b and lift it into a -> m b and get fail instead of error
18:02:52 <EvilTerran> it was inspired by a proposal on the haskell' trac to make (|PAT -> EXP) be like my $(fails [| \PAT -> EXP |])
18:03:32 <EvilTerran> Berengal, indeed; catching bottoms is bad for semantic integrity, tho
18:03:42 <EvilTerran> (well, doing so outside IO)
18:04:25 <EvilTerran> Berengal, and you wouldn't be able to do that at all in a way that was exactly analogous to pattern fallthrough, anyway
18:04:30 <Berengal> EvilTerran, I don't see the big difference between that and falling through pattern matches
18:04:32 <EvilTerran> you'd either be catching all bottoms, or none of them
18:04:49 <Berengal> isn't there some PatternMatchException?
18:05:00 <EvilTerran> still, might not be a top-level pattern
18:05:13 <Berengal> True
18:06:20 <Berengal> And you can't really restrict it in any way either :/
18:06:27 <EvilTerran> one could argue that catching all exceptions (or all pattern-match exceptions) is a semantic refinement of the fallthrough-like behaviour, and hence acceptable
18:06:29 <Berengal> Not by using lambdas
18:07:07 <EvilTerran> but then, we are mucking around with bottoms here, so i don't think arguments of "everything refines bottom" will fly
18:07:13 <Berengal> EvilTerran, indeed, I for one don't think commiting once you pass the equals is neccessarily a good thing
18:08:24 <Berengal> It does bring a whole new dimension to the language though
18:08:56 <Berengal> Sort of half-deterministic computation-y
18:12:43 <EvilTerran> we seem to be heading towards `lub`
18:13:17 <EvilTerran> http://hackage.haskell.org/package/lub
18:13:36 <lispy> heh, I was seeing if I could write permutations from memory, and I wrote subsets on accident.
18:20:30 <Berengal> lispy, that's a pretty big typo
18:20:51 <lispy> heh yeah
18:21:14 <Berengal> I mean, they only have like three characters in common, even
18:21:16 <lispy> It meant my mental specification, I just swapped the two concepts in my brain really
18:21:23 <lispy> er met*
18:22:10 <skorpan> the characters in "subsets" are a subset of those in "permutations"
18:22:17 <skorpan> *the X files theme song*
18:22:24 <skorpan> hm, that wasn't even true
18:22:26 <skorpan> ignore me
18:22:29 <Berengal> > "permutations" // "subsets"
18:22:34 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
18:22:39 <skorpan> > "permutations" \\ "subsets"
18:22:41 <lambdabot>   "prmation"
18:22:52 <Berengal> > "subsets" \\ "permutations"
18:22:53 <lambdabot>   "bss"
18:22:54 <lispy> sounds like Dubya speak
18:23:06 <lispy> prmatations!
18:23:15 <Berengal> Almost subset
18:23:17 <skorpan> :t (\\)
18:23:20 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
18:28:07 <lispy> is there an easy syntax for [10 .. 1], besides reversing it?
18:28:11 <lispy> > [10 .. 1]
18:28:13 <lambdabot>   []
18:28:17 <lispy> > [10,9 .. 1]
18:28:19 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:28:23 <lispy> ah, n/m
18:40:52 * Berengal has a hsp
18:59:28 <User324> ey if your bored try facebook zombies :D - http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
19:02:41 <Orclev> btw, anyone know if there's a IRC client written in haskell?
19:03:47 <SamB_XP_> Orclev: other than lambdabot, you mean?
19:04:03 <Orclev> SamB_XP_: no, not a bot, a client
19:20:38 <Berengal> \b is an irc client
19:21:04 <Berengal> but not in the usual sense
19:21:14 <Orclev> Berengal: how is that?
19:21:26 <Berengal> Orclev, it connects to an irc server
19:21:36 <Berengal> it's a client in the irc network
19:21:52 <Hunner> Orclev: Hircules?
19:21:57 <dmwit> There is a Haskell IRC client, but it isn't that compelling.
19:22:41 * dmwit prefers to argue over application features rather than source language
19:22:44 <Orclev> ah, so I see... to bad hircules didn't go the curses based approach
19:23:21 <Orclev> dmwit: in this case it's kind of relavent... reason I was wondering is I notice irssi uses perl for scripting, so I figured a haskell based client would probably use haskell
19:23:58 <dmwit> That makes the relevant feature "scriptable in Haskell", not "written in Haskell". ;-)
19:24:12 <Orclev> true enough, but odds are they're the same thing
19:24:20 * dmwit could easily imagine a perl-based client with a language-agnostic scripting feature
19:24:39 * dmwit could also easily imagine a Haskell-based client with no scripting abilities
19:24:53 <vav> Orclev: you could script ii in haskell, it just uses pipes and ignores gui/ncurses altogether, think people mostly use it with multitail or the like.
19:26:06 <Orclev> vav: hmm... well, I'm just getting into irssi and it's scripting so I hadn't looked at how hard it would be to... bypass... the normal scripting system
19:29:53 <blackdog_> Orclev: might be a weird idea, but you could call haskell directly from perl, too.
19:30:08 <blackdog_> i'm working on a ruby-haskell binding, and it's not actually that complex
19:30:34 <blackdog_> the only real problem is that ghc doesn't do dynamic linking that well in 6.10.1
19:30:41 <blackdog_> (or yeah, you could do it with pipes :)
19:34:03 <skaar>  /cra
19:37:37 <blackdog_> Orclev: it's probably totally overkill for a scripting interface, though. perl's not _that_ bad :)
19:38:10 <pikhq> Perl is merely a sin. It is not the manifestation of evil.
19:38:21 <pikhq> (*shudder* BASIC)
19:38:55 <SamB_XP_> pikhq: are you thinking of QVICKBASIC, or?
19:39:32 <blackdog_> pikhq: i was thinking, actually - you know all those perl operations that work on $_ etc? They're not a million miles away from just writing haskell in point-free style.
19:40:03 <SamB_XP_> (don't you just love having to number your lines II, IV, VI, IIX, X ...?
19:40:52 <SamB_XP_> blackdog: indeed
19:41:00 <blackdog_> SamB_XP_: not to mention having to use I-based array notation
19:41:21 <SamB_XP_> blackdog: that aspect was much less annoying!
19:42:05 <SamB_XP_> remember how you had to implement your own 00..99 enumeration because you couldn't just format the number in decimal?
19:43:15 <blackdog_> yeah. they really butchered the reimplementation from HellenicBasic
19:43:50 <||Zero||> hello everybody
19:43:51 <SamB_XP_> blackdog_: what ICFP contetst was that featured in?
19:44:04 <||Zero||> need help
19:44:13 <||Zero||> i need to do 3d grphs
19:44:23 <||Zero||> i dowload a hugs
19:44:36 <||Zero||> but dont recognize the gnu library
19:44:41 <blackdog_> SamB_XP_: i was just riffing. you mean it exists?
19:44:42 <||Zero||> but i has
19:44:52 <SamB_XP_> blackdog_: no idea!
19:45:01 <SamB_XP_> blackdog_: I was kidding myself
19:45:07 <||Zero||> i dont know what happend
19:45:10 <blackdog_> heh
19:45:29 <blackdog_> think it was a team name, now i JFG it..
19:45:40 <||Zero||> Can't find imported module "Graphics.UI.GLUT"
19:45:48 <||Zero||> this is the mistake
19:45:53 <blackdog_> dammit, broke the fourth wall. i was working up to the arabic numbers and a holy war joke...
19:45:58 <||Zero||> what is the problem can someone tell me
19:46:20 <SamB_XP_> do the Haskell GL bindings even support hugs?
19:46:23 <||Zero||> please
19:46:42 <||Zero||> what editor u recomend me
19:46:47 <eronstuc> I need to ask a question is Cabal for Haskell similar to rpm for some systems and deb for Debian based systems in otherwords a repository  and packaging for installing new software
19:46:59 <blackdog_> GHC is more mainstream
19:47:12 <SamB_XP_> eronstuc: in some ways, but it's also rather different in some ways
19:47:30 <blackdog_> once you have GHC, run something like "cabal install GLUT"
19:47:33 <pikhq> Cabal is most like Dsss.
19:47:47 <SamB_XP_> pikhq: what the heck is that?
19:48:00 <blackdog_> eronstuc: more like rubygems or CPAN than RPM/Deb
19:48:06 <smarmy> d shared software system
19:48:46 <SamB_XP_> blackdog_: uh, don't you mean *hackage* is like those things?
19:48:46 <eronstuc> CPAN I believe is a repository fr perl
19:49:01 <||Zero||> GHC
19:49:08 <||Zero||> is a haskell editor
19:49:12 <||Zero||> ???
19:49:14 <blackdog_> SamB_XP_: heh. I might be able to wiggle out of it - the tool in perl is called 'cpan' too
19:49:30 <blackdog_> you going to crucify me over case? i thought we were friends, man :)
19:49:46 <SamB_XP_> blackdog_: not crucify, just dismiss your wiggling
19:49:59 <blackdog_> ||Zero||: no, it's a compiler + interpreter. use whatever editor you like.
19:50:09 <SamB_XP_> CPAN.pm != CPAN
19:50:10 <eronstuc> have just installed GHC and it compiles and interperets when started with ghci
19:50:29 <||Zero||> hugs is a compiler??
19:50:40 <||Zero||> or interpreter
19:50:41 <||Zero||> ??
19:50:42 <blackdog_> hugs is just an interpreter.
19:50:50 <blackdog_> ghc has both.
19:51:01 <||Zero||> okso tell me what interpreter can i use with gnu library
19:51:07 <SamB_XP_> GHC also has a maintainer
19:51:12 <eronstuc> it can be used as an editor if one first esblishes the editor say :set editor emacs
19:51:18 <SamB_XP_> ||Zero||: well, GLUT isn't a "GNU library"
19:51:34 <eronstuc> then to ediit a file :edit Main.hs
19:51:38 <||Zero||> so what is glut
19:52:11 <||Zero||> cause i dont know what does it mean
19:52:12 <||Zero||> Can't find imported module "Graphics.UI.GLUT"
19:52:21 <||Zero||> what can i do to solve that
19:52:22 <SamB_XP_> 'tis an OpenGL utility library
19:52:39 <jmillikin> install GHC, then install Cabal, then install GLUT
19:52:39 <SamB_XP_> that Haskell module is bindings for it
19:52:42 <jmillikin> install GHC, then install Cabal, then install GLUT
19:52:45 <blackdog> ||Zero||: I told you already - go install ghc, then cabal, then run "cabal install GLUT"
19:53:10 <blackdog> oops, there we go with the three-part harmony again
19:53:16 <||Zero||> i thought hugs have all that installed
19:53:24 <||Zero||> cause i found that files
19:53:35 <jmillikin> If you can't import it, then it's not installed
19:53:52 <SamB_XP_> ||Zero||: what file did you find?
19:55:43 <ManateeLazyCat> dcoutts: I think i found a bug of c2hs
19:55:52 <||Zero||> i found cabal file
19:56:04 * ManateeLazyCat pasted "error output" at http://paste2.org/get/396133
19:56:05 <ManateeLazyCat> dcoutts: When i run command "c2hs -d trace $(pkg-config --cflags vte | sed 's/-I/-C-I/g') /usr/include/vte/vte.h /test/Download/VteBinding/Vte.chs", I got above error output.
19:57:35 <ManateeLazyCat> I search google about "Lexical error ! The character '#' does not fit here", i got http://hackage.haskell.org/trac/gtk2hs/ticket/1101
19:57:44 <||Zero||> where can i download cabal library
19:58:23 <ManateeLazyCat> ||Zero||: No, you don't need download cabal library, you just need install three package after you install GHC.
19:58:37 <ManateeLazyCat> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
19:59:06 <ManateeLazyCat> ||Zero||: Install above three package (with my paste sequence), then you can use cabal command.
19:59:21 <||Zero||> so where can i download GHC library
19:59:56 <ManateeLazyCat> http://www.haskell.org/ghc/download_ghc_6_10_1.html
20:01:16 <ManateeLazyCat> dcoutts: So i think it's a bug of c2hs not only expects ASCII characters in file names. My local is "zh_CN.UTF-8"
20:01:23 <ManateeLazyCat> s/local/locale
20:03:44 <||Zero||> downloading
20:03:47 <||Zero||> ......
20:04:13 <ManateeLazyCat> ||Zero||: Which OS are you use?
20:04:31 <||Zero||> windows
20:06:08 * ManateeLazyCat Haven't use windows long time.....
20:06:38 <Orclev> ghc in windows is easy to install... cabal not so much
20:06:50 <Axman6> Orclev: tried the platform?
20:06:54 <blackdog> how about the haskell platform for windows?
20:06:55 <blackdog> http://hackage.haskell.org/platform/
20:07:12 <Orclev> Axman6: not yet, I already got my windows install squared away
20:07:14 <blackdog> surely that'd install cabal
20:07:44 <||Zero||> after i install all that ill continue using hugs right??
20:08:49 <blackdog> ||Zero||: no. you'd use 'ghci' instead.
20:08:52 <blackdog> it's similar.
20:09:32 <||Zero||> and there is no way to use cabal with hugs
20:09:43 <Axman6> there is i think
20:10:11 <Axman6> you ca use cabal install --hugs
20:10:17 <Axman6>     --hugs                         compile with Hugs
20:11:29 <||Zero||> how can i use cabal with hugs
20:12:08 <Axman6> like i just told you...
20:12:19 <||Zero||> i have hugs instaled
20:12:22 <Axman6> 'cabal install --hugs <package>
20:12:35 <Axman6> i don't know how to get cabal installed using hugs though
20:12:40 <Axman6> (or even if you can)
20:13:23 <lowlycoder> there is a really good tutorial on functional reactive programming, on some webpage with lots of animated gifs ... I lost the link and can't find it; anyone have it?
20:13:29 <||Zero||> i installed hugs
20:13:37 <||Zero||> what else i have to do to use cabal
20:14:15 <Berengal> Isn't hugs getting a bit old?
20:14:20 <Axman6> ||Zero||: why can't you just install the haskell platform? GHC does basically everything hugs does, and is basically the standard haskell compiler
20:14:56 <Orclev> Berengal: everything I've seen says hugs is more or less being deprecated in favor of GHC
20:15:08 <rdeshpande> s
20:15:16 <Berengal> Last release: september 2006... that's 3 years ago
20:15:28 <||Zero||> oke ill do that
20:15:31 <blackdog> ||Zero||: yah, what Axman6 said. It's probably _possible_ to get it working with other compilers, but it's certainly more difficult and more painful
20:15:46 <||Zero||> so u think GHC is the best haskell platform
20:15:51 <Axman6> by far
20:15:57 * blackdog sort of wishes that jhc and cabal worked better together, but isn't gonna open that can of enraged worms
20:16:38 <smarmy> "enraged worms" is creepier than i thought it would be
20:16:42 <Berengal> GHC is the de-facto standard compiler, the rest are mostly experimental. Hugs is just old... At least that's the impression I've gotten
20:16:44 <Axman6> ||Zero||: ghc can compile haskell, sometimes faster than the C version of the code. it's a _damn_ good compiler, and is the standard compiler everyone uses for haskell
20:17:01 <Axman6> it's pretty much the gcc of haskell... without the shittiness
20:17:21 <SamB_XP_> blackdog: yeah, there are a lot of actual issues involved, but nevertheless a great deal of gratuitous angst seems present as well ...
20:17:24 <||Zero||> oke im downloading GHC
20:17:41 <Axman6> ghc? or the haskell platform?
20:17:53 <Berengal> Axman6, it has some occational shittiness in the more experimental new features, but I think we can be pretty forgiving in that regard
20:18:06 <Axman6> well yeah
20:18:15 <Axman6> they;'re experimental, what do you expect?
20:18:29 <Berengal> x-rays and shit
20:32:30 <Saizan_> blackdog: if one wanted i don't think it'd be so hard to make it work, without touching jhc
20:36:11 <blackdog> Saizan_: there's a lot of plumbing there to get right, i think
20:37:44 <||Zero||> 89%
20:39:22 <Saizan_> blackdog: yeah, but you've all of hackage to test it :)
20:40:04 <||Zero||> i need to unistall hugs to instal GHC=??????
20:41:12 <Saizan_> no, you shouldn't
20:47:24 <||Zero||> ok download has finished
20:47:30 <||Zero||> now install
20:54:30 <||Zero||> ok ive already installed GHC
20:55:03 <||Zero||> how can i use
20:55:05 <||Zero||> it
20:55:51 <||Zero||> how can i use cabal
20:55:54 <||Zero||> ????
20:56:35 <||Zero||> please can somebody help me
20:56:46 <Cale> ghci will start the interactive ghc environment. You can compile programs with ghc --make MyProgram.hs
20:57:13 <||Zero||> i dont know how to use
20:57:18 <||Zero||> prelude
20:57:23 <||Zero||> similar to hugs
20:57:25 <Cale> By passing the program file you're working on as a parameter to ghci, it'll load the definitions in the file and let you use those.
20:57:31 <||Zero||> but it is on dos
20:57:35 <Cale> Yeah, ghci is similar to hugs.
20:57:39 <Cale> dos?
20:58:03 <||Zero||> black window
20:58:03 <||Zero||> dos
20:58:12 <Cale> Oh, it does run in a terminal window.
20:58:12 <||Zero||> u understand
20:58:16 <SamB_XP_> ||Zero||: that's not actually DOS ;-P
20:58:21 <||Zero||> oke
20:58:29 <SamB_XP_> it's actually this thing called the command line ...
20:58:30 <||Zero||> how can i run a program
20:58:45 <||Zero||> how can i open a prgram here
20:58:59 <Cale> :l MyProgram.hs
20:59:10 <Cale> Will cause it to load that program
20:59:17 <Cale> and then you can use definitions from it
20:59:22 <SamB_XP_> actually, the window itself is called a console window, I think
20:59:33 <SamB_XP_> it's created by something called csrss.exe ...
20:59:42 <Cale> Oh, on Windows?
20:59:43 <M|> that's only if the program is in the current working directory, though.
20:59:49 <||Zero||> failed that program dosn exist
21:00:01 <Cale> ||Zero||: Of course, you have to actually write a program first.
21:00:22 <||Zero||> where i need to safe my programs
21:00:24 <||Zero||> what file
21:00:39 <Cale> Whatever directory you're running ghci from should be fine.
21:00:41 <SamB_XP_> Cale: yes, only on Windows do people think those things are DOS windows
21:00:59 <SamB_XP_> when in actuality the DOS environment is only created on demand!
21:01:15 <M|> Powershell \o/
21:01:49 <||Zero||> what file my programs need to be saved to can open with GHC
21:02:26 <M|> ||Zero||: I believe you can specify a fully qualified path to a haskell program within ghci.
21:02:49 <M|> If that's true, then it doesn't matter where you save the file.
21:02:52 <Cale> ||Zero||: Something ending with .hs
21:03:08 <thedonvaughn> you guys are still helping ||Zero|| ?  He seems to just be trolling
21:03:22 <SamB_XP_> thedonvaughn: no, just n00b
21:03:24 <Cale> M|: you can, but without that, it'll open files from whatever directory you were in when you ran ghci
21:03:25 <SamB_XP_> I can tell
21:03:41 <Cale> It's best to never assume that someone is trolling anyway :)
21:03:45 <thedonvaughn> ||Zero||: http://book.realworldhaskell.org/read/
21:03:58 <SamB_XP_> either that, or doing an extremely good n00b impression ;-)
21:04:09 <Cale> Even if they are trolling, other lurking people can benefit from the explanations.
21:05:05 <Orclev> I've asked enough stupid questions in my day I figure from a karma standpoint even if they're trolling I owe them something
21:05:58 <||Zero||> i can open my programs
21:06:02 <||Zero||> not in scope
21:06:21 <SamB_XP_> ||Zero||: that means you tried to use a name that wasn't in scope ;-)
21:06:45 <||Zero||> so what i need to do
21:06:58 <SamB_XP_> you could give more information ;-)
21:07:19 <||Zero||> the code call prueba1.hs
21:07:37 <||Zero||> but when i put write that in GHC
21:07:47 <||Zero||> appears not in scope
21:08:07 <Orclev> how are you loading it?
21:08:19 <||Zero||> only writing
21:08:42 <SamB_XP_> ||Zero||: oh. you didn't put the :l ?
21:08:49 <Orclev> try doing :load prueba1
21:08:56 <||Zero||> no
21:09:07 <Orclev> ... do you need the .hs on that?
21:09:29 <Orclev> also be aware of you might have to give an absolute path to the file
21:09:44 <Orclev> or do a :cd to the proper directory first
21:09:56 <SamB_XP_> yeah, :pwd might tell you where you are?
21:10:03 <SamB_XP_> (does that come pre-programmed?)
21:10:09 <Orclev> SamB_XP_: no
21:10:13 <Orclev> SamB_XP_: pwd fails
21:10:14 <SamB_XP_> oh.
21:10:17 <SamB_XP_> must be
21:10:20 <SamB_XP_> custom ;-)
21:10:29 <||Zero||> i need to write all the dirrection of the file
21:10:47 <Orclev> does pwd work in windows?
21:10:48 <BMeph> Try :!cd
21:10:59 <Orclev> yeah, that would work
21:11:05 <rdeshpande> is there a way to map out recursive calls to see how a function behaves in each iteration?
21:11:15 <||Zero||> cant find file : prueba1.hs
21:11:33 <Orclev> ||Zero||: you need to change to the right directory first so something like
21:11:37 <SamB_XP_> Orclev: uh, ":def pwd getCurrentDirectory >>= putStrLn", I think ...
21:11:48 <Orclev> :cd C:\haskell\myprogram
21:12:26 <Orclev> also, in that example myprogram is a folder as well
21:13:00 <Orclev> normally you'd probably run ghci from the directory with the file and supply the name... so ghci prueba1.hs
21:13:15 <Orclev> then you could just do :r as you make changes to the file
21:13:54 <||Zero||> then i put only the name of the program
21:14:16 <BMeph> ||Zero||: You can also do ":!dir" to show your directory. Basically, anything you could do "in DOS", you can do in ghci after typing a ":!". :)
21:14:16 <SamB_XP_> Orclev: then we'd have to teach him to use "DOS", as he calls it ;-P
21:14:16 <Orclev> ||Zero||: what specifically are you refering to?
21:14:46 <||Zero||> my program is on the directory
21:14:54 <||Zero||> c:\trabajos haskell
21:15:20 <Orclev> ok, then do this :cd c:\trabajos haskell
21:15:24 <||Zero||> and my ptrogram name is prueba1.hs
21:15:26 <Orclev> not sure if that space will cause problems
21:16:01 <Orclev> assuming it works with the space in there, then do a :l prueba1.hs
21:17:34 <||Zero||> could not find module graphics.UI.GLUT
21:17:45 <Orclev> ||Zero||: yes, progress!
21:17:57 <SamB_XP_> I guess you still need to install that ;-)
21:18:00 <||Zero||> :p
21:18:02 <||Zero||> jeje
21:18:20 <||Zero||> yes i need to install cabal
21:18:36 <Orclev> SamB_XP_: just imagine how much fun it would be to walk him through an install of gentoo :P
21:18:50 <SamB_XP_> Orclev: oh, yes, "fun" is most definately the word!
21:18:54 <SamB_XP_> ... *not*!
21:19:11 * SamB_XP_ doesn't much like gentoo, and definately wouldn't suggest it for beginners
21:19:32 <Draconx> imo, it depends on the beginner.
21:19:36 * Orclev likes gentoo enough that he actually went through the effort of installing it... and that's a lot of effort
21:20:32 <||Zero||> how can i install cabal
21:20:49 <SamB_XP_> Orclev: and THAT is why I don't suggest if for beginners
21:20:54 <SamB_XP_> I know from experience.
21:21:08 * BMeph wonders how much effort is takes to d/l a virtuaBox image of gentoo...
21:21:14 <SamB_XP_> actually, that's about the only experience I have ever had with gentoo -- trying to help a beginner install it
21:21:29 <SamB_XP_> I had told him to buy Debian, but nooo, he went and bought Gentoo!
21:21:32 <Orclev> BMeph: probably not much, but that's hardly "installing" it
21:21:53 <Orclev> SamB_XP_: ... what is this "buy" you speak of?
21:21:54 <||Zero||> i only need to install it
21:21:56 <BMeph> Orclev: Yeah...but it works for me. ;)
21:22:12 <SamB_XP_> Orclev: well, it's usefull if you start out with a dialup connection ...
21:22:32 <SamB_XP_> you mail-order it on CDs
21:22:36 <SamB_XP_> whatever Linux you want
21:22:58 <Orclev> SamB_XP_: fair enough, I used to have copies of RedHat and SuSE I bought... back when I think SuSE was on 3.0
21:23:56 <SamB_XP_> the guy now downloads and burns whatever Linux distros he wants
21:24:34 <SamB_XP_> but I still wouldn't suggest entrusting your computer to him ;-)
21:24:44 <SamB_XP_> he tends to ... change ... things ;-)
21:24:56 <Orclev> SamB_XP_: gentoo isn't so bad so long as you don't have any weird hardware, you've got a decent idea of what's inside your computer, and you've got a day to spend downloading and building packages
21:25:28 <SamB_XP_> Orclev: it also helps if you have a decent idea of what makes a *nix system tick ;-)
21:25:43 <Orclev> in my case the install would have gone very smoothly, but I've got a softraid (nForce chipset) that made getting the kernel to boot a major PITA
21:25:56 <rdeshpande> are any of you guys using haskell professionally?
21:26:06 <Orclev> rdeshpande: I wish
21:26:16 <SamB_XP_> I wish I was ___ professionally
21:26:28 <rdeshpande> i just started learning it this weekend
21:26:33 <rdeshpande> now im trying to think of ways i can use it at work
21:26:46 <Orclev> SamB_XP_: currently me to... used to do Java/C# professionally, but I got laid off recently
21:27:14 <SamB_XP_> heck, even whatever you call doing something for work study ;-P
21:27:18 <||Zero||> can someone tell me how install cabal on GHC
21:27:23 <SamB_XP_> I've school starting in a week or so ...
21:28:35 <Orclev> SamB_XP_: school or college?
21:28:49 <SamB_XP_> both!
21:28:56 <SamB_XP_> college is a kind of school
21:29:03 <Orclev> heh, you know what I mean
21:29:44 <Orclev> I need to finish off my bachelors... I'm something like 12 credits short, I just haven't gotten around to scheduling the classes
21:33:06 <zero6666> who is using my nick ||Zero||
21:33:23 <copumpkin> lol
21:33:26 <copumpkin> you are
21:34:07 <zero6666> maybe a bug
21:34:21 <Draconx> not likely.
21:34:21 <Orclev> think maybe I'll write up a irssi script that when given a source file will upload its contents to hpaste and print the url to the channel
21:34:41 <SamB_XP_> zero6666: it's a thing called "ghosting"
21:35:01 <Orclev> yeah, and both IPs match on the nicks
21:35:02 <SamB_XP_> you lose connectivity somehow, but the IRC server takes ages to time out the connection
21:35:13 <zero6666> oke
21:36:03 <vav> zero6666:  like people said earlier, your best bet is http://hackage.haskell.org/platform -- it will take care of getting all the dependencies for cabal-install so you don't have to.
21:36:17 <zero6666> can someone explain me how to instl cabal
21:36:28 <vav> since you're on Windows that might be harder than it should be
21:36:38 <vav> zero6666: see the link I just posted
21:36:39 <zero6666> in that page will teach me how to instal cabal
21:37:31 <vav> zero6666: once you run the setup.exe you will have ghc and cabal all compatible and ready to cabal install glut
21:38:19 <zero6666> but i already have GHC
21:38:49 <vav> zero6666: don't worry about it, just install the platform. It will save you trouble.
21:38:58 <zero6666> oke
21:39:55 <zero6666> so i have to unistall my GHC
21:40:04 <zero6666> or it is not necesary
21:40:20 <SamB_XP_> zero6666: might make things less messy
21:41:05 <zero6666> sorry but i've nevere use GHC
21:41:13 <zero6666> and neither cabal
21:42:45 <Orclev> zero6666: the platform is a collection of things, so it includes GHC, cabal, and a few common libraries
21:43:01 <zero6666> oke oke
21:43:13 <zero6666> im undestanding
21:51:42 <Woof> Twey!
21:55:16 <zero6666> ......
21:55:33 <Woof> He's sleeping
22:02:01 <zero6666> i have to download the windows installer or the cabal package
22:02:18 <zero6666> or cabal package is include on windows installer
22:02:20 <Axman6> just install the windows platform installer
22:02:20 <zero6666> ???
22:02:32 <Makoryu> zero6666: Google for "Haskell platform"
22:02:32 <Axman6> it includes everything you need, including cabal-install
22:02:38 <Axman6> @where platform
22:02:39 <lambdabot> http://hackage.haskell.org/platform/
22:02:41 <Axman6> ^^^^^^^^^^^^^^^^^^^^^^^^^^^
22:02:52 <zero6666> oke 68%
22:05:08 <path[l]> I have a question. In the computation analogy of monads. Is m a, a computation returning a? or m a, a computation performed on a?
22:05:51 <SamB_XP_> path[l]: returning
22:06:00 <path[l]> ah I see
22:06:20 <SamB_XP_> at least, if it returns anything ;-)
22:07:03 <Makoryu> Say.... The OCaml REPL always shows you the type of the last expression. Could we get that in GHCi for stuff that doesn't have a Show instance?
22:07:05 <path[l]> hehe ok
22:07:48 <SamB_XP_> Makoryu: submit a ticket to the GHC trac?
22:07:50 <SamB_XP_> @feature
22:07:50 <lambdabot> Unknown command, try @list
22:07:53 <SamB_XP_> @bug
22:07:53 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
22:08:07 <SamB_XP_> only change the ticket type to feature or whatever ;-)
22:12:25 <path[l]> does anyone have a link to or something of the list monad and specfically how it is used in backtracking algorithms? Im trying to port a back tracking solver I wrote in ruby to haskell. And specifically my imperative solver had the ability to exit early from branches that were going to be dead ends
22:15:49 <SamB_XP_> path[l]: you could use guard, I guess
22:16:35 <path[l]> yeah ummm Im so noob that I think I need a really basic guide first explaining how it works =p.
22:16:56 <SamB_XP_> Cale: um, help!
22:17:36 <path[l]> actually Cale was really cool with helping me last night with the more basic "what is a monad", that Im wrapping my head around
22:17:51 <path[l]> unfortunately it was like 4 am and I uhhh dozed off in the middle lol
22:17:55 <||Zero||> finally its complete
22:17:58 <||Zero||> oke
22:18:00 <||Zero||> now
22:18:07 <path[l]> it's alive?
22:18:07 <||Zero||> what i have to do
22:18:22 <Axman6> ||Zero||: to do what?
22:18:28 <SamB_XP_> Axman6: he wants GLUT
22:18:40 <Axman6> the platform comes with it doesn't it?
22:18:41 <||Zero||> ive already dowloaded haskell platform
22:18:47 <Axman6> ||Zero||: installed it?
22:19:09 <||Zero||> but first unistall my GHC
22:19:15 <||Zero||> or is not necessary
22:19:29 <||Zero||> ===???
22:19:31 <SamB_XP_> ||Zero||: might as well
22:19:40 <vav> ||Zero||: sure enough, looks like GLUT comes with the platform http://hackage.haskell.org/platform/contents.html
22:20:01 <||Zero||> unistall GHC first ??'
22:20:10 <SamB_XP_> ||Zero||: go ahead
22:20:21 <SamB_XP_> uninstall GHC, then install the platform
22:22:31 <elliottt> dcoutts: i've written a zsh completion script for cabal install, is there some sort of contrib package that i could include that from?
22:22:35 <elliottt> err, in :)
22:22:39 <||Zero||> installing......
22:25:55 <||Zero||> oke its already instlled
22:26:13 <||Zero||> now
22:26:17 <||Zero||> what i have to do
22:26:39 <Axman6> cabal install GLUT
22:26:42 <SamB_XP_> ||Zero||: try loading your script again
22:26:54 <SamB_XP_> Axman6: we just learned that GLUT is already in the HP, didn't we?
22:27:22 <Axman6> oh, yeah i haven't been following along
22:28:06 <||Zero||> :cd
22:28:08 <||Zero||> ???
22:28:40 <SamB_XP_> ||Zero||: sure!
22:28:45 <SamB_XP_> then do that :load thing
22:29:43 <||Zero||> oke main
22:29:51 <||Zero||> :P
22:30:56 <Orclev> hpaste ~/test.hs
22:30:59 <Orclev> doh
22:32:09 <||Zero||> import Graphics.Rendering.OpenGL
22:32:09 <||Zero||> import Graphics.UI.GLUT
22:32:09 <||Zero||> main = do
22:32:09 <||Zero||>   (progname, _) <- getArgsAndInitialize
22:32:09 <||Zero||>   createWindow "Hello World"
22:32:10 <||Zero||>   mainLoop
22:32:30 <||Zero||> it supouse to create a window with a messege hello world????
22:32:30 <SamB_XP_> ||Zero||: note that this /= emacs ;-P
22:32:35 <Makoryu> SamB_XP_: http://hackage.haskell.org/trac/ghc/ticket/3452 <- How's it look?
22:33:10 <Zao> SamB_XP_: Last I checked, it didn't bundle a sane native glut dll.
22:33:13 <Zao> Might've changed since then though.
22:33:27 <SamB_XP_> Zao: oh, point!
22:33:33 <SamB_XP_> ||Zero||: why, what happens?
22:33:41 <SamB_XP_> do you get an error about glut32.dll?
22:34:03 <SamB_XP_> Makoryu: it's a decent start!
22:34:11 <||Zero||> the window doesn appear
22:34:30 <SamB_XP_> oh, type "main"
22:34:37 <SamB_XP_> (without the quotes)
22:36:55 <||Zero||> cant load .so/DLL for glut32 <add DLL could not load DLL>
22:37:28 <||Zero||> now what is the problem
22:37:45 <SamB_XP_> ||Zero||: ah, yeah, it's what Zao said
22:37:52 <SamB_XP_> Zao: do you know the solution?
22:38:18 <Zao> I gave up on glut after missing some freeglut functionality.
22:38:29 <Zao> But it should probably work fetching glut32 from the original Nate page.
22:38:38 <Zao> http://www.xmission.com/~nate/glut.html
22:39:17 <||Zero||> so u dont know the solution???
22:41:15 <Axman6> ||Zero||: do you have GLUT for windows installed? http://www.xmission.com/~nate/glut.html ( think)
22:42:31 <||Zero||> i dont know
22:42:42 <||Zero||> ill try to download
22:43:09 <||Zero||> i have t install the 2 ones
22:43:24 <||Zero||> bin and src
22:43:44 <Zao> You need to take glut32.dll from the bin one and put in the working directory or in your path.
22:43:46 <Axman6> just bin, src will be the source code
22:45:11 <||Zero||> u mean all the file glut bin must be copied
22:45:19 <||Zero||> where my rpograms are
22:45:27 <Zao> Just the glut32.dll
22:46:26 <||Zero||> o yeah it works
22:46:37 <||Zero||> thank so much
22:46:45 <||Zero||> now i need to sleep
22:46:52 <||Zero||> its 1 am
22:47:02 <||Zero||> tomorrow ill be back
22:47:13 <||Zero||> thanks everybody
22:47:54 <Zao> With the current platform, the sample does not work out of the box. The current GLUT apparently requires an displayCallback set.
22:48:30 <||Zero||> i hope u be here tomorrow
22:48:33 <||Zero||> oke bye
22:50:55 <copumpkin> wow
22:52:50 <Saizan_> ?
22:53:04 <Zao> I can't wait.
22:53:15 <copumpkin> :)
22:56:58 <u_quark> anyone knows why am I getting this error while compiling gth2hs with ghc-6.10.4 http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3392#a3392 ?
23:04:26 <sayyestolife> hm. If I say that I think that avoiding explicit recursion as much as possible (since it is often replacable with generalized methods such as map foldr etc) is a good thing to do, am I right?
23:04:57 <Axman6> depends on the task
23:05:05 <Axman6> imo, it depends what is clearest
23:11:33 <sayyestolife> yea, sure but "clear" isn't that a bit subjective? :)
23:11:57 <Saizan_> sayyestolife: the advantage of using combinators is that other readers don't have to reconstruct the pattern of the computation from scratch
23:12:02 <sayyestolife> using more generalized methods, isn't that almost always more clearer?
23:12:23 <Saizan_> that works only if you didn't use the combinators in a twisted/very unusual way
23:12:35 <sayyestolife> hm, what do you mean when you say combinator?
23:12:54 <Saizan_> what you called generalized methods, i guee
23:12:57 <Saizan_> *guess
23:12:59 <sayyestolife> ah okay
23:13:50 <copumpkin> using the general methods also allows fancy optimization that may not occur otherwise
23:14:41 <sayyestolife> The reason why I'm asking is because I had an argument with a guy about these things, although I was more drunk then than I'm now
23:14:54 <sayyestolife> that is also true cods
23:14:57 <sayyestolife> copumpkin
23:15:30 <copumpkin> :)
23:15:47 <u_quark> I always thought it was the other way around... with hand written recursion you can do more tricks .... don't get me wrong I love expressing computations as streams
23:16:48 <Saizan_> u_quark: list fusion is based on GHC's RULE mechanism, which rewrites specific expressions, so if you're not using the combinators you don't get the fusion
23:17:38 <Saizan_> (as an example)
23:17:54 <u_quark> ic...
23:33:49 <arabidopsis> is any Archlinux user here able to build the lastest haskell-pandoc from AUR?
23:36:09 <taruti> How does one express "class C a b | a -> b, b -> a where c :: a -> b" with type families?
23:37:13 <Saizan_> class (a ~ A b, b ~ B a) => C a b where type A b; type B a;
23:37:28 <taruti> does that express the bijectivity?
23:38:14 <taruti> hmm, at least GHC 6.10.3 fails on that code, does it work in head?
23:38:37 <Saizan_> i thought it worked
23:38:52 <copumpkin> how does it fail?
23:39:11 <taruti> "The current implementation of type families does not support equality constraints in superclass contexts."
23:39:18 <copumpkin> ah
23:42:52 <BMeph> taruti: Have you tried 5.10.4? :)
23:43:01 <BMeph> Er, *6.10.4
23:44:57 <taruti> BMeph: the same.
23:53:48 <hackagebot> bytestring-nums 0.1.0 - Parse numeric literals from ByteStrings. (JasonDusek)
23:54:46 <copumpkin> solidsnack: have you seen bytestring-lexing?
23:57:51 <taruti> hmm, tried to use FDs but that failed also.
23:58:49 <hackagebot> bytestring-nums 0.2.0 - Parse numeric literals from ByteStrings. (JasonDusek)
23:59:01 <taruti> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8470 <- any ideas how that is incorrect?
23:59:49 <copumpkin> taruti: that looks very similar to something I was just doing
