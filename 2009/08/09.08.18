00:01:49 <jre2> with the less general function above I can do "foo (+) (\x->x+2) (\x->x+3) 1" (result is 7). It should be possible to state that in terms of liftM2, but I can't figure out how.
00:02:17 <copumpkin> > let foo = liftM2 in foo (+) (\x->x+2) (\x->x+3) 1
00:02:18 <BMeph> Perhaps do: (z :+ S y) :== (y :+ S z) -> (S z :+ S y) :== (S y :+ S z)? :)
00:02:19 <lambdabot>   7
00:02:53 <jre2> ???
00:03:00 <copumpkin> BMeph: I don't even have the left side of that yet
00:03:43 <jre2> copumpkin: my ghci returns "No instance for (Monad ((->) a))"
00:03:58 <copumpkin> import Control.Monad.Instances
00:04:08 <copumpkin> oh
00:04:13 <copumpkin> :m + Control.Monad.Instances
00:04:15 <copumpkin> in ghci
00:06:02 <jre2> didn't know that existed
00:06:10 <jre2> thank you
00:06:58 <copumpkin> Saizan: my plusZeroIsComm feels overcomplicated
00:07:26 <copumpkin> I guess not
00:10:20 <sohum> :type <bla> gives <bla? :: (Monad m) => m (Char, [Char]). why does the monad not get printed when I run the code?
00:10:23 <sohum> alternatively, when <bla> calls fail, ghci just locks up. whether I suffix it with :: Maybe (Char, [Char]) or not. why?
00:10:25 <copumpkin> Saizan: I think I cheated
00:10:29 <copumpkin> Saizan: it was too easy
00:11:04 <copumpkin> oh whoops
00:11:09 <copumpkin> I was compiling wrong file :P
00:13:58 <vav> oh my! :set -XImplicitParams is \o v e l y -> gladWasIdlingHere!
00:14:23 <Saizan> copumpkin: i cheated too! http://pastebin.com/mbb7df71
00:14:44 <copumpkin> lol
00:14:58 <jre2> @pl \x -> f x + g x + h x
00:14:59 <lambdabot> ap ((+) . liftM2 (+) f g) h
00:15:07 <jre2> @pl \x -> f x + g x + h x + i x
00:15:08 <lambdabot> ap ((+) . ap ((+) . liftM2 (+) f g) h) i
00:15:35 <Saizan> looks like that lemma needs induction to be proven
00:16:21 <copumpkin> Saizan: almost!
00:16:22 <copumpkin>     Couldn't match expected type `S (z :+ y)'
00:16:22 <copumpkin>            against inferred type `S z :+ y'
00:16:27 <copumpkin> well
00:16:49 <copumpkin> now my addition order is backwards :P
00:17:53 <copumpkin> oh your lemma is what I need :P
00:18:05 <Saizan> yeah :)
00:19:00 * Saizan ponders defining becauseISaidSo = undefined
00:19:35 <Saizan> unsafeCoerce TEq, actually
00:19:59 <copumpkin> lol
00:25:44 <ray> lemma is a wonderful word
00:26:44 <ray> if i had a theorem, i'd call it a lemma
00:28:21 <tombee> The haskell wiki recommends a textbook for learning haskell, is there a widely recommended one?
00:29:13 <Nafai> tombee: I highly recommend Real World Haskell
00:29:48 <tombee> Great thanks, does it 'start at the beginning'?
00:30:17 <solrize> pretty much
00:30:46 <tombee> Oh I see there's a free online version, I'll check it out.  Hopefully the book isn't too expensive.
00:30:54 <solrize> you could also start with http://learnyouahaskell.com which is maybe a bit more elementary and doesn't cover as much
00:31:00 <solrize> yes the online RWH is good
00:41:08 <copumpkin> dammit :P
00:41:39 <stanv> hello
00:43:59 <stanv> Can anybody explain to what is a st? "if st is identify for f, then: x `f` st = x = st `f` x"
00:44:21 <opqdonut> st is a variable :)
00:44:24 <stanv> I can't undestand what is `identify f'
00:44:35 <copumpkin> the identity element for f
00:44:39 <opqdonut> that sentence defines "identity for f"
00:44:52 <copumpkin> f = (+), st = 0
00:44:52 <opqdonut> as those elements "st" that fulfil "x `f` st = x = st `f` x"
00:44:57 <copumpkin> f = (*), st = 1
00:45:02 <copumpkin> f = (++), st = []
00:45:19 <opqdonut> f = and, st = True
00:45:22 <opqdonut> f = or, st = False
00:45:23 <copumpkin> f = (.), st = id
00:45:42 <opqdonut> there's some examples for you
00:46:15 <opqdonut> a (two-argument) function with an identity is called a "monoid" in standard mathematics terminology
00:46:16 <ray> rad, you spelled fulfil fulfil
00:46:20 <ray> that takes me back
00:46:31 <stanv> copumpkin: thanks
00:46:31 <opqdonut> ?
00:46:35 <stanv> opqdonut: thanks :)
00:46:37 <ray> monoids do have to be associative
00:46:43 <opqdonut> oh, my bad
00:46:44 <copumpkin> unital magma?
00:46:45 <opqdonut> magma?
00:46:49 <opqdonut> unital, ok
00:46:54 <ray> and the identity has to be left and right
00:47:06 <ray> unital magma :)
00:47:07 <copumpkin> that was his original spec though!
00:47:25 <ray> what an obscure term
00:47:25 <opqdonut> stanv: so if f in addition fulfils "f (f x y) z = f x (f y z)" f is a magma
00:47:29 <ray> like everything magma-related
00:47:37 <opqdonut> gAH
00:47:41 <opqdonut> *f is a monoid
00:47:46 <stanv> it's better to say "identify element - it much clear"
00:47:47 <opqdonut> all the examples we gave were actually monoids
00:48:40 <ray> copumpkin: is there a name for structures that have different left and right identities? :)
00:49:35 <copumpkin> beats me :)
00:49:38 <doserj> (^)
00:50:36 <ray> somehow i doubt it
00:51:12 <doserj> if f is associative, then left and right identities are the same
00:51:56 <opqdonut> doserj: it's kinda cool how ^ is the first operation in the +,*,^,arrows... tower that breaks commutativity and associativity
00:57:44 <erikc> writing technical design documents: write the code in haskell as the spec, size it for implementation in c++
00:58:24 <erikc> to laugh or to cry
00:59:50 <mm_freak> is there an efficient implementation of a fast in-place sorting algorithm like quicksort?
00:59:58 <mm_freak> for arrays
01:00:08 <solrize> mm_freak uvector
01:00:14 <solrize> uvector.algorithms
01:00:46 <solrize> http://hackage.haskell.org/package/uvector-algorithms
01:01:20 --- qu O_4_ (n=souchan@ip-118-90-95-126.xdsl.xnet.co.nz) joined #haskell
01:16:33 <copumpkin> Saizan: I'm having type variable scope issues now I think, even though I have scoped typevariables on :(
01:21:52 <copumpkin> hmm, gonna sleep now :P
01:22:27 <Nafai> Seems to me that Leksah can import a project that has a .cabal package.  Is there a cabal command or something that I can issue (for a checked out project with a .cabal file) that will give me all of the files in the project?
01:24:47 <Saizan> what do you mean by checked out?
01:25:33 <Saizan> there's cabal sdist that will make a tarball for you, cabal unpack will instead fetch one from hackage and untar it
01:25:57 <Saizan> there isn't a command to list the files though
01:27:27 <Nafai> Saizan: local working copy.
01:27:39 <Nafai> I'll have to see what Leksah is doing
01:28:18 <quicksilver> parsing the .cabal file I imagine
01:28:25 <quicksilver> it's not too diificult to do so
01:29:26 <Nafai> Right
01:29:28 <Saizan> the Cabal library exposes functions to do so
01:30:20 <mm_freak> indexing in UArr is O(n)
01:30:25 <mm_freak> according to its doc
01:31:19 <mm_freak> ah no, sorry
01:31:31 <mm_freak> there is readMU and writeMU
01:32:14 <quicksilver> in the docs I'm looking at, the complexity of indexU is not given.
01:32:22 <quicksilver> I'm sure it's not O(n) though
01:32:23 <mm_freak> but isn't there some code snippet for sorting haskell arrays, which i could use without needing extra packages?
01:32:48 <mm_freak> quicksilver: http://hackage.haskell.org/packages/archive/uvector/0.1.0.4/doc/html/Data-Array-Vector.html#21
01:34:22 <quicksilver> mm_freak: I think that's just a mistake.
01:35:08 <Saizan> indexU arr n = indexS (streamU arr) n
01:35:13 <mm_freak> anyway…  there has to be a useful sorting algorithm for normal mutable arrays
01:36:55 <quicksilver> mm_freak: quicksort!
01:37:06 <mm_freak> quicksilver: sorry, i mean an implementation
01:37:18 <quicksilver> there are no useful implementations of anything for normal mutable arrays
01:37:23 <quicksilver> because they suck and no one uses them :P
01:37:52 <mm_freak> but they are in the base library and they are fast
01:38:17 <mm_freak> it's almost like a bad joke that 'sort' is implemented for lists, but not for arrays
01:38:38 <mm_freak> IMO it should be removed from Data.List, because it leads people even more into abusing lists
01:39:23 <int-e> @type \a -> listArray (bounds a) (sort (elems a))
01:39:26 <lambdabot> forall i e. (Ix i, Ord e) => Array i e -> Array i e
01:39:42 <int-e> (not quite serious, although it /does/ have the right complexity.)
01:40:33 <mm_freak> int-e: the right time complexity, but only asymptotically
01:40:37 <mm_freak> as you say, not quite serious
01:42:34 <Veinor> o/
01:42:51 <int-e> I like the Data.List sort anyway - it produces the first k elements in O(n + k log n) time.
01:44:48 <mm_freak> int-e: a proper in-place implementation of quicksort for arrays is likely still faster, even if you use only part of the result
01:45:31 <quicksilver> depends how big a part.
01:45:36 <quicksilver> if you use a small part of the result it won't be.
01:46:03 <mm_freak> then finding the least few elements and sorting them independently is faster
01:46:41 <quicksilver> that's more work for the programmer though.
01:47:22 <int-e> right. while we are at it, add an implementation of quickselect.
01:47:25 <mm_freak> if we're talking about performance, we're talking about extra work in most cases anyway =)
01:47:50 <edwardk> mm_freak: but you do gain the benefit of compositionality and separation of concerns given the current approach
01:48:34 <edwardk> take 20 . sort -- just does the right thing
01:48:51 <mm_freak> edwardk: but that's not convincing real world programmers
01:49:29 <edwardk> mm_freak: so? real world programmers do lots of stupid things =)
01:49:47 <mm_freak> edwardk: indeed…  one of them is:  they don't use haskell
01:49:56 <edwardk> it is one of the major benefits of the haskell libs as a whole that they maintain that property
01:49:58 <quicksilver> mm_freak: if real world programmers don't understand the benefit of compositionality then they are bad programmers.
01:50:18 <quicksilver> mm_freak: although some of them may be more familiar with the word 'modularity'
01:50:31 <edwardk> i can manually chunk up my input and scan over it a piece at a time in hand crafted buffers... or i can use lazy bytestrings and let fusion do it for me
01:50:39 <edwardk> sort fits into that same mindset.
01:51:09 <edwardk> should an imperative timsort or something be available for mutable arrays? sure, but it definitely shouldn't be the default, because it is asymptotically slower
01:52:12 <edwardk> the 'free selection algorithm' is one of the examples i use to _sell_ haskell ;)
01:52:12 <mreh> ghci tells me thread blocked indefinitely. what?
01:52:16 <mm_freak> quicksilver: if compositionality makes my code run like a snail, i can happily live without it…  i need a fast in-place sorting algorithm (or numerous other simple features), and the base library doesn't provide it
01:52:59 <quicksilver> mm_freak: you just said "if we're talking about performance, we're talking about extra work in most cases anyway =)"
01:53:06 <quicksilver> mm_freak: so write quicksort and stop whining.
01:53:24 <quicksilver> mm_freak: and, no, compositionality doesn't in general make code run like a snail.
01:53:25 <edwardk> mm_freak: so write a nice imperative timsort and put it on hackage ;)
01:53:28 <mm_freak> other people are better than me at writing low level stuff
01:53:39 <solrize> http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
01:55:08 <mm_freak> solrize: interesting, thanks!
01:55:28 <Veinor> solrize: those wow gold adverts in the comments really speak to me :)
01:55:55 <solrize> veinor you saw today's www.xkcd.com ?
01:56:12 <Veinor> nope
01:56:25 <solrize> well now is your chance
01:56:30 <Veinor> *checks*
01:56:44 <Veinor> I laughed
01:56:48 <solrize> hee
01:58:18 <mreh> is writing debugging code for Haskell a real pain, if you set a command line option debug=1, don't I now have to send that all over the program as a parameter?
01:58:26 <mm_freak> quicksilver: btw, this is really no offense, but haskell _does_ lack a lot of things…  in fact it doesn't really lack them, but either it forces the wrong conditions on them, or it does them in a way useless for real world programs
01:58:47 <mm_freak> example for the former: sorting, example for the latter: reactive-glut
01:59:09 <mreh> uhh, quicksort?
02:00:21 <edwardk> mm_freak: i'm perfectly willing to acknolwedge that there is a place for an in place sort in the libraries, just not as 'sort' ;)
02:00:49 <edwardk> or if it is as sort, that sort should be factored out into a class so it could run over arrays, etc.
02:00:59 <mm_freak> edwardk: true, but at least tutorials and documentation should warn newcomers that 'sort' is probably not what they want
02:01:28 <quicksilver> mm_freak: I'm not haskell, so I won't be offended if you insult it.
02:01:28 <mm_freak> yeah, there should be a Sortable class
02:01:39 <quicksilver> however, I disagree that 'sort' is probably not what they want.
02:01:47 <edwardk> mm_freak: i'll be honest i'm not entirely sure where this hysteria about sort is coming from, its rarely slow enough that you'll even notice a problem
02:01:53 <mm_freak> quicksilver: i didn't insult it…  haskell is great, otherwise i wouldn't use it
02:02:00 <quicksilver> I estimate sort is perfectly acceptable for 95% of the real programs which need to sort stuff.
02:02:16 <quicksilver> it's lightning fast if you want to, e.g., sort a 1000-row table for a web page
02:02:18 <solrize> list.sort really is awfully slow
02:02:24 <quicksilver> or sort 5k emails for an email client
02:02:30 <quicksilver> these are typical, realworld sorting cases.
02:02:49 <edwardk> and given the preponderance of ways of converting other structures to lists, it is pretty effective and slotting into most code
02:02:57 <quicksilver> so, I think it is, in fact, *probably* what you want.
02:02:57 <solrize> i think recent sorting hysteria has come from jdh30's rants about the burrows wheeler transform
02:03:01 <mm_freak> edwardk: its time performance is fine, but its space performance sucks
02:03:12 <quicksilver> but there is a case where it is wrong.
02:03:13 <solrize> which involves sorting a million rotations of a megabyte long vector
02:03:29 <edwardk> solrize: why the fuck would you use a general purpose sort routine for BWT? =)
02:03:34 <mm_freak> edwardk: given its bad space performance, its time performance suffers as well
02:03:58 <solrize> edwark it's the most obvious thing, use uvector and sort a list of poitners into the buffer
02:04:02 <quicksilver> mm_freak: what is the point you're making about  'reactive-glut' and "useless for real world programs"
02:04:19 <mm_freak> quicksilver: why is it based on GLUT?
02:04:22 <quicksilver> reactive-glut is a prototype of an unfinished and buggy library.
02:04:23 <mm_freak> and not, say, SDL?
02:04:26 <edwardk> you can do it asymptotically faster using a special case algorithm, since it can be done in linear time if you want to be pedantic and n log n, which is impressive if you consider that n is also the key length, if you want to be practical
02:04:35 <quicksilver> shoulud you really judge a language by its unfinished buggy libraries?
02:04:44 <quicksilver> I can find plenty of such for any language you would mention.
02:05:10 <mm_freak> quicksilver: i said, haskell is a great language, but it lacks stuff
02:05:14 <solrize> well a fairly straightforward in-place quicksort turns out to be OOM's faster than data.list.sort
02:05:25 <solrize> but uvector sort might not be so bad
02:05:27 <mm_freak> and in fact i didn't even refer to the bugginess of reactive-glut
02:05:37 <mm_freak> but just to the second part of its name:  GLUT
02:05:54 <quicksilver> mm_freak: no, but I question it as something to discuss as the basis of a critique of haskell.
02:06:12 <quicksilver> haskell lacks mature libraries compared to other languages, yes.
02:06:15 <edwardk> solrize: sure it will, but BWT is one of those cases where you absolutely will demand the entire output, and where a general purpose quicksort isn't even the most efficient tool, so you'd be stuck writing your own sort anyways
02:06:16 <quicksilver> is that what you're reffering to?
02:06:19 <quicksilver> no argument there.
02:06:40 <mreh> is he arguing that haskell is functionally incomplete?
02:06:51 <solrize> i think demanding the entire output is the normal case in sorting.  demanding only the first few outputs is "selection" not sorting
02:07:19 <edwardk> solrize: then write a timsort, put it in hackage, and you'll get a ton of users if you're right =)
02:07:49 <edwardk> i'll admit i have had scenarios where i would gladly adopt an imperative sort
02:07:52 <solrize> i hadn't realized uvector wasn't O(1) indexing.  i'd hoped uvector.algorithms had suitable sorting functions
02:07:57 <Beelsebob> solrize: even so, a sort that works as a fast selection when run lazily is rather beneficial
02:07:58 <quicksilver> solrize: it is.
02:08:04 <quicksilver> solrize: that's a documentation bug.
02:08:06 <edwardk> uvector indexes in constant time
02:08:13 <mm_freak> quicksilver: forget that i mentioned haskell…  i restate:  the haskell base library lacks many things and could benefit from some structural changes…  the third party libraries implement very useful things in bad ways, which destroy their usefulness
02:08:40 <edwardk> i'm gonna go get something useful done
02:08:44 <solrize> beelsebob yes, a swiss army sort that also selects is a cool feature if the cost to the general case is no more than a few percent.  if it's a factor of 100 then forget it
02:08:58 * Beelsebob nods
02:09:59 <mm_freak> haskell itself also has some flaws, but i hope that they get fixed in haskell', until then i'll just use my usual GHC extensions
02:10:26 <opqdonut> haskell' isn't fixing that much
02:10:32 <opqdonut> or what flaws were you referring to
02:10:55 <mm_freak> yeah, but at least my LANGUAGE list will get much shorter, i hope
02:11:03 <mm_freak> its tiring to type all the time
02:12:28 <mm_freak> i also hope to see uniqueness types some day, but i'm afraid that will take a long time, if it happens at all
02:13:06 <ray> i would say that haskell' will come out in 2015 and be h98 with hierarchical modules and no monomorphism restriction, but i already said that the other day
02:13:09 <ray> :)
02:13:19 <opqdonut> sounds plausible
02:13:23 <opqdonut> mptcs too
02:13:31 <mm_freak> ray: at least it will have multi-param type classes
02:14:02 <quicksilver> mm_freak: well, your criticism is then so poorly formed as to be totally immune to debate.
02:14:12 <quicksilver> mm_freak: All base libraries lack many things.
02:14:24 <quicksilver> I find haskell's base library to be as capable or more capable than any other language I've ever used.
02:14:27 <quicksilver> it still lacks plenty.
02:14:43 <quicksilver> some third party libraries are very good, some are less good, some are buggy, some are incomplete, etc
02:15:35 <mm_freak> quicksilver: don't get me wrong, the base library is great, especially when it comes to data structures…  it's just that there are some essential things missing, like some fast algorithms found in other languages
02:16:11 <mm_freak> i'm glad to see progress from version to version, but for example the array support is still quite poor
02:16:18 <quicksilver> yes, that's true.
02:16:29 <quicksilver> but so very seldom needed.
02:16:34 <quicksilver> (Which is why people aren't motivated to work on it)
02:16:42 <quicksilver> most programming in the large isn't CPU-bound
02:16:57 <solrize> lots of stuff in the python lib that i use all the time isn't in the haskell lib
02:17:05 <quicksilver> typical problems don't need space and time efficient arrays
02:17:09 <quicksilver> which doesn't mean they're not useful.
02:17:41 <quicksilver> solrize: what kind of thing, for example?
02:18:36 <mm_freak> quicksilver: they are useful and extremely fast compared to arrays in other languages…  they are also clever (for example, a UArray Int Bool really takes only as many _bits_ as needed)
02:18:50 <mm_freak> but there is not a single algorithm implemented for them, which is frustrating sometimes
02:20:08 <solrize> quicksilver, 1) http client and server, 2) fast json parser 3) nntp client 4) imap client [not using this yet but am about to] 5) timsort :) 6) sqlite
02:20:10 <solrize> is a start
02:20:35 <mm_freak> solrize: IMO besides the sorting algorithm, that stuff doesn't belong into a base library
02:20:39 <quicksilver> solrize: you use an nntp client library all the time?
02:20:44 <quicksilver> solrize: you are a weird weird persone :)
02:20:47 <solrize> quicksilver, yes, 24/7
02:20:54 <quicksilver> well you have to accept that's pretty unusual.
02:20:56 <solrize> i have automated nntp clients running all the time
02:22:12 <solrize> also, fast convenient unicode handling
02:22:22 <solrize> i.e. "hello" should not be 5 cons nodes :)
02:22:25 <mm_freak> solrize: haskell has all that stuff, just not in the base library
02:22:44 <solrize> haskell has no fast json parser that i know of
02:22:45 <mm_freak> have a look at happstack for HTTP stuff, and there is also an NNTP library
02:23:00 <solrize> happstack needs a ph.d. to operate, python's is just a couple of function calls
02:23:02 <ray> yes, "hello" should very much be 5 elements
02:23:09 <quicksilver> solrize: '"hello" should not be 5 cons nodes' <- this is not an absolute truth.
02:23:09 <mm_freak> i don't know how fast they are, but there are libraries to do that
02:23:11 <ray> it is 5 code points
02:23:19 <quicksilver> solrize: there are enormous benefits to hello being 5 cons nodes.
02:23:26 <mm_freak> solrize: no, happstack is quite simple…  there is a nice tutorial, which is easy to follow
02:23:30 <solrize> mm_freak yes there are json libraries in hackage, and i know how fast they are
02:23:31 <solrize> :)
02:23:38 <quicksilver> it is certainly convenient to have a more compact representation sometimes.
02:23:42 <mm_freak> happstack is also very elegant, compared to all other approaches i've seen
02:23:49 <quicksilver> but there are also big advantages to the unpacked list.
02:24:21 <ray> assuming we're talking about unicode, code points matter, not encodings
02:24:33 <idnar> happstack isn't really anything like the HTTP server in the Python stdlib
02:24:51 <idnar> on the other hand, the HTTP server (and NNTP client and IMAP client and pretty much all other network stuff) in the Python stdlib is absolutely awful
02:25:06 <ray> happstack is more comparable to ruby on rails or something
02:25:19 <solrize> idnar they are simple and easy to use, though not very complete.  the main thing i really use all the time in python though is urllib
02:25:25 <mm_freak> dunno, but i like the modularity of happstack
02:25:39 <solrize> and afaik hackage doesn't have that
02:25:42 <mm_freak> 'HTTP servers' is a monoid =)
02:25:59 <solrize> i havent' tried data.text yet for unicode
02:26:00 <ray> what is the operation?
02:26:04 <solrize> maybe it takes care of the issue
02:26:18 <ray> solrize: you will have to define what you're referring to by "unicode" before i'll let you off
02:26:19 <solrize> the thing with list-encoding strings is that it's too memory intensive and too slow
02:26:42 <idnar> if you need a packed string encoding, isn't that what ByteString etc. are about?
02:27:02 <solrize> idnar bytestring is as the name implies for bytestrings, it doesn't parse out the unicode chars
02:27:18 <mm_freak> ByteStrings are great, although somewhat inconvenient to use, because of the qualified importing
02:27:22 <solrize> data.text does that but it's very new and i haven't used it yet
02:27:24 <mm_freak> haskell could benefit from some OOP features
02:27:27 <idnar> but what do you need a packed text string representation for?
02:27:35 <solrize> idnar, fast text processing
02:27:43 <idnar> solrize: what sort of processing?
02:27:52 <idnar> all of the text processing I've ever done has been linear
02:28:22 <solrize> idnar, the constant factor matters!!!!
02:28:34 <mm_freak> solrize: a ByteString doesn't care about its actual content…  it's encoding-insensitive
02:28:46 <mm_freak> you'd need to do that by other means
02:29:08 <quicksilver> solrize: "too slow" for what?
02:29:16 <quicksilver> solrize: you can't keep making these vague allegations.
02:29:17 <ray> a bytestring could be binary data
02:29:22 <quicksilver> solrize: [String] is not too slow
02:29:27 <ray> a bytestring often is binary data
02:29:28 <idnar> mm_freak: storing UTF-8 string data (or whatever) in a ByteString isn't going to be much fun to work with, though
02:29:30 <quicksilver> solrize: I mean, String = [Char] ;)
02:29:31 <solrize> mm_freak right, if i want to process unicode strings in python or java, the i/o libraries handle it.  in haskell i either have to use snail-slow string i/o, or bytestrings and handle the encoding/decoding myself
02:29:38 <solrize> quicksilver, it is too slow, trust me :)
02:29:42 <quicksilver> solrize: It isn't.
02:29:48 <quicksilver> solrize: you cannot make a unqualified assertion like that.
02:29:56 <quicksilver> String is perfetly fast enough for all kind of use caess
02:29:59 <solrize> did you see the "wc" example on the haskell wiki?
02:30:02 <quicksilver> and the polymorphism has a payback.
02:30:06 <solrize> it's too slow for MY use cases, ok?
02:30:06 <Saizan> solrize: you've to deal with encodings yoursefl for String i/o too :)
02:30:09 <quicksilver> it is *not* fast enough for certain other cases.
02:30:21 <quicksilver> you can't just say "it's too slow" though.
02:31:14 <solrize> yes, really, i can say it's too slow, something is broken if there are two separate schemes for dealing with strings, one of them complicated to use and the other one slow
02:31:15 <mm_freak> hmm…  i wonder whether it's possible to write special implementations of lists for certain types
02:31:25 <quicksilver> and the point is, there is something you win, along with the things you lose.
02:31:34 <mm_freak> such that String has a more compact internal representation than, for example, [Int]
02:31:40 <solrize> from what i understand, clean has packed strings
02:31:41 <quicksilver> you win the fact that strings are just lists, and can be processed by generic list processing functions.
02:31:51 <quicksilver> mm_freak: not without specialising every single function which works on lists.
02:31:55 <mm_freak> then ByteStrings would become superfluous
02:32:02 <quicksilver> mm_freak: ...in other words, "Yes", but it's a lot of work.
02:32:23 <solrize> i wonder whether the specialization could be done with actual generics of some sort
02:32:29 <mm_freak> quicksilver: it could be possible by making a List class, i think
02:32:33 <Saizan> bytestrings are a single chunk too, so all the complexities change
02:32:47 <quicksilver> mm_freak: that is the same thing, ys.
02:32:54 <quicksilver> mm_freak: that is specialising all list-processing functions.
02:33:00 <hackagebot> backdropper 1.2 - Rotates backdrops for X11 displays using Imagemagic. (YannGolanski)
02:33:02 <quicksilver> (or, rather, enough of them to provide the operations you need)
02:33:09 <mm_freak> yeah, but you wouldn't need to write all list functions yourself, just some base functions to work with
02:33:22 <quicksilver> that kind of approach is how uvector works, using associated types
02:33:32 <quicksilver> also see edwardk's monoids + reducers code.
02:33:35 <mm_freak> and that would also remove the annoyance that you need to import Data.ByteString qualified
02:34:32 <solrize> also i think i can't have Data.Map Data.ByteString
02:34:42 <quicksilver> why not?
02:34:48 <solrize> i think i tried it and it refused
02:34:52 <mm_freak> solrize: you can
02:34:52 <quicksilver> no, it's fine.
02:34:55 <solrize> hmm ok
02:35:03 <mm_freak> Map works with any Ord type
02:35:11 <quicksilver> there is a bytestring-trie out there somewhere which is much faster, though.
02:35:23 <solrize> yeah, i remember something about that, i wanted to try it
02:35:35 <solrize> from what i understand, data.map is sort of a dog
02:35:54 <mm_freak> "dog"?
02:36:07 <solrize> slow and memory hungry
02:36:23 <mm_freak> it's a bit memory-hungry, but not slow
02:36:28 <mm_freak> but you can use IntMap
02:36:38 <quicksilver> solrize: you're in such a FUD-y mood today.
02:36:40 <solrize> not if the keys are strings :)
02:36:44 <solrize> quicksilver i'm sleepy :)
02:36:50 <quicksilver> data.map is not a dog.
02:36:52 <quicksilver> it's perfectly fast.
02:37:07 <quicksilver> it's true that people have pointed out there are faster balancing algorithms than size-balanced.
02:37:09 <Saizan> your Ord instance might be slow though :)
02:37:16 <solrize> i think it is slower than python dictionaries
02:37:39 <mm_freak> i like the 'State Map' and 'StateT Map IO' monads =)
02:37:41 <quicksilver> will depend on your pattern of keys.
02:37:46 <solrize> is there anything like data.map for disk files?
02:37:56 <solrize> i guess that's what happs state is
02:37:57 <mm_freak> write a full database server in a matter of 10 lines
02:38:01 <quicksilver> btu I wouldn't be surprised if it's a little slower for typical short string keys.
02:38:04 <piis3141> Does anyone know how to export an infix function (operator)?
02:38:09 <quicksilver> piis3141: ((+))
02:38:23 <piis3141> quicksilver:  thanks!
02:41:06 <solrize> like, i have a list of a few thousand place names, and a massive pile of utf8 text that i want to grep for these names, doing it with [Char] would be pathetic
02:41:27 <mm_freak> maybe i should write an array tutorial and implement a few algorithms along the way
02:42:14 <quicksilver> solrize: probably much better than you fear.
02:42:23 <quicksilver> solrize: cache effects will dominate and your [Char] will be fast in-cache.
02:42:26 <solrize> i've written stuff with [Char]
02:42:42 <quicksilver> certainly if you have a machine with a slow memory / main bus ratio.
02:43:38 <solrize> oh yes, the input text is gzipped, it would be cool if there is gzip to data.text stream fusion
02:45:06 <mm_freak> is there a fast pixel drawing library?  fast in that i can access the pixel buffer directly
02:45:28 <mm_freak> SDL itself does support it, but its haskell binding doesn't
02:45:35 <quicksilver> accessing the pixel buffer directly is not fast on modern video cards mm_freak :P
02:45:40 <quicksilver> that's so 1980s.
02:46:09 <idnar> it's probably about the slowest thing you can do on a video card
02:46:50 <mm_freak> what is a faster way to fill the screen with random pixels?
02:47:29 <solrize> run a few rounds of some salsa20-like function inside the video buffer?
02:47:45 <solrize> or even some additive prng...
02:47:59 <mm_freak> solrize: i just got told that accessing the pixel buffer directly is the slowest thing i could do
02:48:01 <solrize> using the graphics accelerator
02:48:07 <idnar> mm_freak: create a texture, fill it with random data, and use it to texture a quad the size of the viewport
02:48:11 <quicksilver> mm_freak: one fast way is to fill an in-memory representation of a pixel buffer, and then blit that to the card
02:48:29 <idnar> mm_freak: alternatively, implement a PRNG in a pixel shader
02:48:29 <quicksilver> mm_freak: the other fast way is to upload a GPU program which does the random pixels direct in the GPU
02:49:59 <mm_freak> quicksilver: SDL does just that…  it doesn't access the video buffer directly
02:50:12 <mm_freak> that's why i talked about the _pixel buffer_, which is in system memory
02:50:39 <mm_freak> idnar: that texture approach is slower than blitting a surface
02:50:41 <quicksilver> mm_freak: OK well forgive me but that's not a standard piece of pedantry.
02:50:50 <quicksilver> mm_freak: that texture approach *is* blitting a surface.
02:51:03 <quicksilver> mm_freak: that's exactly how you blit a surface on a modern card.
02:51:11 <idnar> mm_freak: I'm not entirely sure what you mean by "blitting a surface", but it sounds like a 2D operation that'll be emulated
02:51:22 <idnar> (probably by doing exactly what I said)
02:51:26 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8276  passphrase generator i wrote a while ago, i don't see any real obvious optimizations and the python version is quite a bit faster
02:51:45 <mm_freak> well, maybe you have a different notion of texture than me
02:52:02 <mm_freak> 'texture' is commonly heard in an opengl context
02:52:36 <quicksilver> mm_freak: Yes. Modern cards are all designed with the 3D architecture in mind.
02:52:49 <quicksilver> mm_freak: fast 2D graphics is achieved by using the 3D pipeline.
02:52:55 <mm_freak> solrize: your randomnum function is the bottleneck
02:53:13 <mm_freak> solrize: readFile "/dev/urandom" should be called only once
02:53:14 <solrize> mm_freak no i don't think so, i'm only calling it a few times
02:53:33 <mm_freak> your randomnum function then can be pure
02:54:22 <mm_freak> quicksilver: ok, let me restate:  is there a library, with which i can do fast pixel drawing in whatever way is currently the best?
02:54:27 <solrize> yeah maybe it would be nicer that way, but i'm only generating 4 random numbers
02:54:45 <solrize> the bottleneck is reading and parsing /usr/share/dict/words which is a megabyte or so
02:55:12 <mm_freak> solrize: why do you use lazy ByteStrings?
02:55:36 <quicksilver> mm_freak: HOpenGL is your best bet but opengl api takes a little learning.
02:55:42 <solrize> instead of reading the whole file into memory and carving it into words?
02:55:58 <solrize> i'd like to figure out how to use iteratee but the docs i've seen are pretty hard to understand
02:56:05 <mm_freak> quicksilver: i know the opengl API, but i find it too heavyweight for just some simple experiments
02:56:38 <quicksilver> mm_freak: yes, agreed.
02:56:52 <quicksilver> it is nonetheless the fastest way :)
02:57:03 <quicksilver> e.g. all iPhone games use openGL even though 99% of them are 2D
02:57:03 <mm_freak> solrize: well, what you want is likely not a _list_ of words
02:57:10 <mm_freak> solrize: more like an array or an IntMap
02:57:18 <solrize> yes, see line 17
02:57:22 <solrize>       a = array (0,n-1) (zip [0..] ws)
02:58:01 <mm_freak> solrize: there is still that nasty 'length' there
02:58:49 <solrize> yes, you have to know the length to make an array
02:59:07 <solrize> and anyway all the words need to be stored
03:00:11 <mm_freak> Set has O(1) length, but unfortunately it has no indexing
03:00:18 <mm_freak> wouldn't make much sense anyway
03:00:33 <mm_freak> but Seq has O(1) length, too
03:00:46 <solrize> Seq?
03:00:50 <solrize> i don't knwo what that is
03:00:51 <mm_freak> Data.Sequence
03:00:55 <solrize> hmm
03:00:59 <quicksilver> solrize: have you got the python version to hand?
03:01:14 <solrize> i don't seem to have it here
03:01:23 <mm_freak> solrize: it should be in the base library
03:01:43 <solrize> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
03:02:09 <solrize> neat, O(log n) lookup
03:02:43 <quicksilver> solrize: I get a 16% speedup by using strict bytestrings.
03:02:43 <mm_freak> where can i get a wordlist from?  there was a site for that
03:02:52 <solrize> quicksilver, interesting
03:02:56 <quicksilver> solrize: and a further 10% or so by switching to Data.Sequence
03:02:59 <solrize> cool
03:03:22 <mm_freak> with Data.Sequence you can get along without arrays at all
03:03:39 <solrize> yes, data.sequence should be ok for this
03:03:48 <quicksilver> I tried Data.Map instead of the array, also
03:03:55 <quicksilver> it was a little slower but not too much
03:03:59 <quicksilver> hmm what about IntMap
03:04:19 <mm_freak> got it, thanks
03:05:29 <quicksilver> IntMap seems very similar, I think it's something between arrays and sequence
03:05:44 <quicksilver> timing is not conclusive thouguh it varies too much from run to run
03:05:48 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8277  this is also slower than the python version though i didn't attempt to use bytestrings
03:06:59 <quicksilver> solrize: do you remember roughly how much faster the python version was?
03:07:11 <solrize> iirc a couple times faster, i'm rewriting it
03:07:23 * quicksilver nods
03:07:41 <quicksilver> the overhead here is in structure setup time I'm sure
03:09:59 <quicksilver> ah yes, use listArray not array
03:10:08 <quicksilver> that makes arrays as fast as Data.Sequence
03:10:22 <quicksilver> or, within my measurement tolerance at least.
03:10:26 <mm_freak> well, adding a word takes non-constant time in Data.Sequence
03:10:39 <Saizan> ?type listArray
03:10:41 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
03:10:44 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8278
03:10:47 <quicksilver> mm_freak: well, I was using fromList, not adding the words one by one
03:10:53 <mm_freak> arrays should be best, but only if you can get around the list
03:11:21 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8279 oops
03:12:37 <mm_freak> how about just zipping the list with random numbers and then filtering?
03:12:48 <solrize> hmm?
03:13:01 <quicksilver> solrize: FYI, the python and haskell code run at the same speed for me :)
03:13:18 <mm_freak> get five random numbers, then filter the list for that five numbers
03:13:18 <quicksilver> solrize: 220ms, GHC 6.8.3, python 2.5.1
03:13:19 <solrize> well that's encouraging :)
03:13:47 <quicksilver> solrize: on a 2.5M words file, OSX 10.5, core 2 duo.
03:14:06 <mm_freak> filter ((`elem` fiveRandomNumbers) `on` fst) words
03:14:24 <mm_freak> to pick the five numbers, you need the length of the list
03:14:36 <mm_freak> that's two O(n) operations and no additional data structure you need to populate
03:14:37 <solrize> that sounds awful
03:14:39 <quicksilver> solrize: interesting the breakup between user/sys is very different though.
03:14:52 <quicksilver> solrize: haskell is user time 200ms, sys 20ms
03:14:58 <quicksilver> solrize: python is user time 100ms, sys 100ms
03:15:15 <quicksilver> solrize: this suggests that the haskell generates better IO code but worse algorithmic code.
03:15:24 <Saizan> benchmarking python on multicore machines might be unfair :)
03:15:31 <solrize> i get python about 2x as fast
03:15:34 <quicksilver> Saizan: I'm not using the cores in either case though.
03:15:40 <solrize> maybe due to paging in the ghc runtime
03:15:57 <solrize> this is for my original lazy bytestring version
03:16:03 <quicksilver> solrize: python version? ghc version?
03:16:24 <solrize> python 2.5.2, ghc 6.10.3
03:16:36 * quicksilver nods
03:17:15 <quicksilver> I quite like "cigua-typo-swish-panty", by the way
03:17:23 <solrize> hehe
03:17:31 <quicksilver> and "Comid-dirty-wang-manto" has its snigger factor.
03:17:36 <solrize> lol
03:20:32 <vav> hmm, guess I'd best not use "mank-morbid-rubied-brand" for RoR server
03:24:50 <Saizan> > 160 / 450
03:24:52 <lambdabot>   0.35555555555555557
03:25:36 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8280  i rewrote the rng more imperatively to not leak file handles (i think).  let me know how it looks
03:26:15 <solrize> actually that's still not what i wanted
03:26:51 <Saizan> you should hClose h
03:26:54 <Saizan> or use withFile
03:27:15 <solrize> what i actually wanted was to keep h open and read from it on each invocation
03:27:17 <solrize> let me try again
03:27:53 <mm_freak> my approach takes 1.18 seconds for a 15 MiB wordlist
03:28:31 <mm_freak> but i have used System.Random for convenience…  you need to rewrite it to use /dev/urandom
03:29:55 <Saizan> >  450 / 160
03:29:56 <lambdabot>   2.8125
03:30:14 <Saizan> here python is that times faster
03:30:27 <Saizan> on a 9.5M words
03:31:23 <Axman6> Saizan: with what?
03:32:15 <mm_freak> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8281#a8281
03:34:39 <Saizan> Axman6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8280 <- first haskell version vs. last python one
03:34:48 <quicksilver> solrize: your original code didn't leak filehandles anyway
03:35:22 <mm_freak> likely there are also better shuffling algorithms, so my code is anything but optimal, but it's fast
03:35:46 <mm_freak> between 1.17 and 1.18 seconds for 15 MiB words
03:36:47 <mm_freak> about 80 ms for 1.1 MiB
03:37:40 <Saizan> mm_freak: you forgot to filter out long words it seems
03:37:59 <mm_freak> Saizan: huh?
03:38:06 <solrize> omg, it's 0340 here, i gotta go.  later all.
03:38:19 <mm_freak> hf
03:45:18 <mm_freak> actually i just made an Array-based variant
03:45:30 <mm_freak> taking about 30 ms for 1.1 MiB words
03:45:55 <mm_freak> so i think the real bottleneck comes from /dev/urandom, which is a pretty slow generator
03:46:03 <mm_freak> it generates only 5.7 MiB/s on my machine
03:46:23 <mm_freak> (athlon x2 64, 2.7 GHz/core)
03:47:22 <mm_freak> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8281#a8282
03:47:58 <quicksilver> solrize's version only generated 4 random numbers
03:48:06 <quicksilver> so that wasn't the bottleneck on his version unless, hmm
03:48:14 <mm_freak> indeed
03:48:15 <Axman6> mm_freak: i'm getting 7-8MB/s on my machine (Core 2 Duo, Mac OS X 10.5)
03:48:20 <quicksilver> maybe the IO system always reads 8192 bytes because of buffering.
03:48:30 <Axman6> kernel
03:48:33 <quicksilver> stil htat's not much
03:48:40 <mm_freak> mine now generates a 5 digit passphrase from a 30 MiB dictionary in 1.2 seconds
03:48:43 <Axman6> kernel's using plenty of CPU, heh
03:49:30 <Axman6> ha, measuring /dev/zero, i'm getting 4GB/s
03:49:38 <mm_freak> IIRC System.Random uses /dev/urandom for initialization, but it's not secure
03:50:34 <mm_freak> i get 1.9 GiB/s for /dev/zero =)
03:51:32 <pr> good morning
03:52:04 <mm_freak> unfortunately i can't use UArray with my approach
03:52:19 <mm_freak> but i think Array is the fastest you can get anyway
03:53:09 <mm_freak> wait, i get a speedup using lazy ByteStrings
03:53:11 <Axman6> evening pr
03:55:14 <pr> heh :)
03:56:08 <Axman6> mm_freak: is this for something in particular?
03:56:53 <mm_freak> Axman6: an improvement of solrize's random passphrase generator…  you'll need to replace StdGen by /dev/urandom, though
03:57:05 <mm_freak> he had some performance problems
03:57:33 <Axman6> anything wrong with Dons' mersenne-twister random number generator?
03:57:48 <Axman6> or however it's spelt
03:59:31 <Axman6> mm_freak: why the need to use /dev/urandom?
04:12:51 <mm_freak> Axman6: neither StdGen, nor MT are cryptographically strong
04:14:31 <ahf> isn't it silly to use /dev/urandom? are you sure you aren't thinking about /dev/random ?
04:15:17 <idnar> I get 5.7GiB/sec for /dev/zero
04:15:26 <mm_freak> ahf: /dev/random is the information-theoretically secure variant of /dev/urandom…  it never produces pseudo-random numbers (theoretically)
04:15:52 <mm_freak> nevertheless /dev/urandom is a perfectly fine cryptographically secure PRNG
04:16:03 <ahf> urandom repeats it sequences, no?
04:16:29 <mm_freak> not within the estimated lifetime of our universe =)
04:16:54 <mm_freak> also just like /dev/random it takes entropy from the OS environment
04:17:03 <ahf> yes.
04:17:30 <mm_freak> the only difference is that /dev/random stops responding, as soon as the entropy pool is "empty", while /dev/urandom degenerates to a CSPRNG and still produces output
04:42:17 <HugoDaniel> hello
05:02:53 <LeCamarade> Why does HSQL fail to insert binary data into a BYTEA field of the database?
05:03:37 <LeCamarade> I think it is understanding it as a string (for it stops at the first \NUL), but a string it isn't, and I don't know how to educate it any better.
05:03:40 <hackagebot> llvm 0.6.8.0 - Bindings to the LLVM compiler toolkit. (LennartAugustsson)
05:08:42 <quicksilver> LeCamarade: perhaps there is some bug in the underling C binding and something is treating it as a C string
05:08:46 <quicksilver> LeCamarade: i.e. null terminated.
05:08:52 <quicksilver> LeCamarade: certainly sounds like a bug somewhere.
05:09:17 <LeCamarade> quicksilver, I think it is, and I wanted to find if anybody here has run into it.
05:09:45 <LeCamarade> See, I don't know of any way to guide the function on the fact that I'm dealing with a BLOB here.
05:11:41 <sohum> grrrr, newtype's annoying me
05:12:14 <sohum> I don't /want/ to wrap my function inside a constructur, and have to unpack it to apply it to anything
05:12:35 <quicksilver> well you can normally ease the pain with a few instances
05:12:40 <quicksilver> what are you trying to do, exactly?
05:13:04 <sohum> but haskell doesn't want to understand a partially applied type in an instance header, so I have to use a newtype
05:13:58 <sohum> basically? I want type Foo a b = a -> ..., and instance Monad (Foo a) where..., but that breaks. I have to use a newtype and the associated constructor instead
05:14:44 <quicksilver> why not just instance Monad ((->) a) where ...
05:14:50 <sohum> Actually... the full type synonym is Foo m a b = a -> m (b, a). would there be any way to derive an instance of Monad?
05:14:55 <sohum> for that?
05:15:25 <quicksilver> looks like StateT a m ?
05:16:08 <quicksilver> but certainly you're going to need a newtype, yes.
05:16:22 <PGK> pl \x y -> x y
05:16:36 <Deewiant> PGK: id
05:16:40 <shapr> ha
05:16:51 <Deewiant> ?pl \x y -> x y
05:16:51 <lambdabot> id
05:16:52 <sohum> serves a similar purpose I suppose. it's mostly for learning, so yea, I'd prefer not to use the builtins
05:16:57 <benmachine> I was thinking ($) but I guess id works too
05:16:58 <sohum> quicksilver: darn rats.
05:17:08 <Deewiant> benmachine: ($) = id ;-)
05:17:27 <PGK> ?pl \x y -> x y
05:17:28 <lambdabot> id
05:28:04 <sohum> :type <bla> is :: (Monad m) => m (Char, [Char]). why does the monad not get printed when I run the code? and why does, if <bla> calls fail, ghci lock up? even if I suffix :: Maybe (Char, [Char]) to it?
05:50:39 <lilac> sohum: can you show us the code (put it up on hpaste.org)?
05:53:26 <myriad> how's haskell for graphics programming?  i.e. opengl?
05:53:48 <myriad> i'm getting tired of so many function pointers in c  =P
05:53:53 <quicksilver> I find it more pleasant than C or C++, for opengl
05:54:02 <quicksilver> it's not brilliantly documented thou
05:54:16 <myriad> the performance is acceptable?
05:54:47 <myriad> i'm doing realtime stuff
05:54:47 <quicksilver> if your bottleneck is your GPU, then performance will be the same.
05:55:01 <quicksilver> what do you mean by realtime?
05:55:10 <quicksilver> real-time strategy game? fine. realtime missile control? best not.
05:55:31 <myriad> oh, just realtime interactive graphics, lots of math
05:56:38 <kpreid> myriad: worked fine for me for a toy of about 100 colliding spheres in a box. but that may or may not be anything comparable to what you want to do
05:57:32 <quicksilver> well if you were CPU-bound in C, then you will not find it easy to get the same performance from haskell
05:57:44 <quicksilver> naive haskell math generally comes in at 2x - 5x slower than naive C math.
05:57:55 <myriad> =(
05:57:57 <quicksilver> but if that was never your bottleneck, then it's fine.
05:58:08 <quicksilver> and if you care to spend the time optimising you can get much closer.
05:58:30 <mexisme> quicksilver: does the new 6.10 ghc not optimise well enough for math, then?
05:58:50 <myriad> one thing i need to look at is whether it's possible to use my GPU to accelerate my code - i'm woefully ignorant in regards to this...
05:59:01 <quicksilver> mexisme: "well enough" by whose standards?
05:59:17 <quicksilver> it still doesn't reach the performance of typical C floating point, no.
06:00:14 <trez> hi majs :)
06:00:25 <majs> hi trez :)
06:00:43 <majs> > concat [[1,2,3],[4,5,6]]
06:00:45 <lambdabot>   [1,2,3,4,5,6]
06:03:15 <gwern> man. _Explosions in the Sky_ is totally my new favorite programming music
06:03:36 <sohum> lilac: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8285
06:04:29 <sohum> > join [[1,2,3],[4,5,6]]
06:04:31 <lambdabot>   [1,2,3,4,5,6]
06:06:15 <quicksilver> sohum: fail = fail
06:06:18 <quicksilver> sohum: epic fail?
06:06:27 <quicksilver> sohum: that's a recursive definition of course it hangs.
06:06:27 <gwern> @quote fail
06:06:28 <lambdabot> Philippa says: < ihope> data Badger = Badger Badger Badger | Mushroom < Philippa> Pattern match failure: Snake!
06:06:59 <myriad> join [[[1,2,3],[4,5,6]],1,2,[3,[[4,5],6]]]
06:07:13 <jkff> myriad: that won't typecheck
06:07:15 <quicksilver> sohum: I think you meant "fail e = Parser $ \input -> fail e
06:08:24 <myriad> jkff:  why?
06:08:41 <jkff> Because the list you used is not of elements of the same type
06:08:48 <myriad> oh.
06:08:55 <jkff> So, there does not exist a type "a" such that the list has type "[a]"
06:09:34 <jkff> If you need "trees" of elements of the same type, use the so called "rose trees".
06:10:02 <myriad> join [join[[1],[2]], join[[3],[4]]]
06:10:51 <jkff> > join [join[[1],[2]], join[[3],[4]]]
06:10:53 <lambdabot>   [1,2,3,4]
06:11:40 <saml> > join []
06:11:41 <lambdabot>   []
06:12:15 <saml> do you like join better than ++ ?
06:12:35 <saml> > join ["hello", " world"]
06:12:37 <lambdabot>   "hello world"
06:14:35 <sohum> quicksilver: it's not recursive. or ... at least, it ... yea, that's what I meant
06:15:26 <myriad> jkff: how come mine didn't work?
06:15:35 <jkff> You forgot ">"
06:15:37 <quicksilver> sohum: definitions introduce their own name as an identifier
06:15:41 <quicksilver> sohum: so that you can do recursion.
06:15:44 <myriad> oh
06:15:53 <quicksilver> sohum: this shadows any previous meaning of that identifier.
06:16:04 <myriad> > join[[], [1]]
06:16:06 <lambdabot>   [1]
06:16:10 <myriad> =)
06:16:20 <shapr> Huh, sql parser written with parsec
06:16:30 <sohum> quicksilver: huh. yea, it was meant to be in the context of the inner monad
06:16:37 <quicksilver> sohum: *nod*.
06:16:54 <quicksilver> sohum: I knew what you meant, that's how I was able to correct it.
06:16:58 <myriad> is this 'join' business haskell syntax?
06:17:12 <gwern> no, it's a typeclass function
06:17:16 <gwern> :t join
06:17:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:17:21 <gwern> :i join
06:17:24 <tingi> how to kow if [x1 x2 x3.... x1000]*[  [ i1 i2 ........i1000] [j1 j2 ....j1000] [ k1 k2....k1000][ p1 p2...p1000]] = k*[ 1 1 1 ... 1000 times] has a solution or not ? does there exist any set of  non -ve integers  { x1 , x2 .. x1000 } such that k is an positive integer
06:17:27 <gwern> @hoogle join
06:17:28 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
06:17:28 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
06:17:28 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
06:17:28 <endojelly> why are continuations equivalent to negations (using curry-howard isomorphism)?
06:18:00 <gwern> myriad: see? a normal function defined in a module
06:18:11 <quicksilver> endojelly: they aren't.
06:18:23 <endojelly> quicksilver, they aren't=
06:18:23 <endojelly> ?
06:18:30 <quicksilver> endojelly: continuations give rise to types like ((a -> r) -> r)
06:18:46 <quicksilver> which reminds us of the type ((a -> _|_) -> _|_), which is a double negation
06:18:50 <quicksilver> there is a resonance here
06:18:58 <quicksilver> but I wouldn't say 'continuations are equivalent to negation'
06:19:12 <benmachine> join m = m >>= id
06:19:14 <benmachine> I think
06:19:29 <benmachine> @type m >>= id
06:19:31 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
06:19:31 <lambdabot>     In the first argument of `(>>=)', namely `m'
06:19:31 <lambdabot>     In the expression: m >>= id
06:19:36 <endojelly> quicksilver, aah. thank you.
06:19:37 <benmachine> bah
06:19:42 <benmachine> @type thing >>= id
06:19:43 <lambdabot> Not in scope: `thing'
06:19:47 <benmachine> oh I am being silly
06:19:54 <benmachine> @type \m -> m >>= id
06:19:56 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
06:19:59 <benmachine> there we go.
06:20:38 <sohum> the list monad is such an awesome monad
06:20:55 <sohum> quicksilver: danke!
06:21:02 <quicksilver> endojelly: then, in particular, a mechanical translation of a program to its continuation passing version
06:21:12 <quicksilver> endojelly: is like the translation of a proof to its double negation version
06:21:22 <quicksilver> endojelly: which is how you embed classical logic in intuitionistic logic.
06:21:25 <philed> quicksilver: Interesting. It also seems that (a -> r) -> r would also be interpreted as a non-constructive existence claim.
06:22:12 <endojelly> quicksilver, oh
06:22:23 <endojelly> quicksilver, i see where this is getting at
06:22:35 <quicksilver> endojelly: so the things you mentioned are linked in important and interesting ways
06:22:41 <quicksilver> I just wouldn't use the word "equivalent"
06:22:52 <endojelly> quicksilver, ok, that was my misinterpretation then
06:23:36 <endojelly> quicksilver, I read the sentence "IL's type system includes negation (continuations), but not implication (function arrow)." -- and I perfectly understand what implication has to do with the function arrow, so I thought continuations were smilarly close
06:23:52 <quicksilver> philed: forall r . ((a -> r) -> r) isn't non-constructive.
06:24:00 <quicksilver> philed: just pass it "id" and you get the actual 'a' out
06:24:12 <quicksilver> philed: it's just an way to encode an existential.
06:25:01 <philed> quicksilver: You can't pass it id if a cannot be unified with r
06:25:01 <endojelly> i have *a lot* to learn
06:25:03 <quicksilver> endojelly: well, the sentence you read certainly suggests they are equivalent, I agree. It's not something I would say.
06:25:18 <endojelly> quicksilver, ok, thanks, that's reassuring
06:25:22 <quicksilver> philed: a is fixed. r is universal, which means I can choose r.
06:25:28 <quicksilver> philed: so, I choose r to be a
06:25:31 <quicksilver> philed: and then I pass id.
06:26:11 <quicksilver> taking a very operational, computer programming viewpoint, universal means "caller supplies type", and existential means "callee gets to choose type"
06:28:52 <philed> quicksilver: I guess I'm not understanding how it is being used. I thought it looked suspiciously like the way you can define existentials in HOL using the existential elimination rule: (Ax. x -> P) -> P.
06:29:35 <quicksilver> it is suspiciously similar, yes
06:29:43 <quicksilver> :)
06:31:03 <Saizan> the existential is forall r . ((forall a. a -> r) -> r)
06:33:18 <philed> Saizan: Why is the r universally quantified. In (Ax, x -> P)  -> P, we have in mind the particular P such that Ex. P
06:33:23 <philed> ?
06:34:48 <Saizan> philed: i've given the encoding for exists a. a, the 'r' is universally quantified so you can pick the one you need at the elimination site
06:35:59 <Saizan> just like a similar encoding for conjunction is forall r. ((a -> b -> r) -> r)
06:36:38 <Saizan> that's "a /\ b" or "(a,b)" to be more haskelly
06:36:44 <philed> Ack. What am I thinking.
06:37:25 <philed> The encoding I was thinking of is actually: Ex. P(x) := A Q. A x. (P(x) -> Q) -> Q
06:37:37 <philed> Which is exactly what you said.
06:38:13 <Saizan> yup
06:45:10 <endojelly> what is a deepSeq operation? just evaluation of all thunks, depth-first?
06:46:03 * gwern coughs. there's something rotten in GHC HQ. I'm spilling the beans on the whole operation
06:46:10 * quicksilver peers at gwern 
06:46:52 * gwern mutters. come back at 1am, 3rd floor of the garage. bring no one
06:50:59 <endojelly> what is the difference between inductive and coinductive types? i gather that haskell has the latter ones?
06:53:23 <hackagebot> mps 2009.8.18.1 - simply oo (JinjingWang)
06:53:56 <mm_freak> > 0
06:54:00 <lambdabot>   0
06:54:03 <Saizan> endojelly: take a definition like L a = Nil | Cons a (L a), that's an equation you can solve to find the meaning of L
06:55:03 <Saizan> endojelly: you can see it at funding the fixed point of a function over types that goes like \L -> Nil | Cons a L
06:55:51 <Saizan> endojelly: but you can ask for the least or greatest fixed point, the first gives you the inductive type, the latter the coinductive one
06:56:19 <Saizan> s/funding/finding/
06:57:03 <Saizan> the order we're talking about is essentially set inclusion
06:57:08 <endojelly> the least fixed point is Nil?
06:57:21 <Saizan> no, the least fixed point is finite lists
06:57:24 <hackagebot> OpenCLRaw 1.0.1001 - The OpenCL Standard for heterogenous data-parallel computing (JeffersonHeard)
06:57:43 <endojelly> hmm
06:57:55 <Saizan> because if you start with L = {Nil} and apply that function you get {Nil,Cons a Nil}
06:58:24 <hackagebot> hack-contrib 2009.8.18 - Hack contrib (JinjingWang)
06:58:28 <endojelly> oh, okay, i get that
06:58:28 <quicksilver> well, stronger than that, if you start with {}, you get {Nil}...
06:58:42 <endojelly> yes
06:58:54 <endojelly> and the greatest fixed point?
06:59:00 <quicksilver> includes infinite lists
06:59:22 <endojelly> but also finite ones?
06:59:29 <endojelly> how is it constructed?
07:00:25 <hackagebot> loli 2009.8.18 - A minimum web dev DSL in Haskell (JinjingWang)
07:00:25 <hackagebot> maid 2009.8.18 - A simple static web server (JinjingWang)
07:01:06 <quicksilver> well, everthing in it must either be of the form "Nil" or "Cons a <something>"
07:01:22 <quicksilver> and, <something> must itself be of that form.
07:01:29 <hackagebot> nemesis 2009.8.18 - a Rake like task management tool (JinjingWang)
07:01:33 <p_l> ... interesting names (loli and maid)
07:01:54 <endojelly> quicksilver, ah. so that includes Cons a Cons a Cons a Cons a ... that never stops
07:02:24 <endojelly> while the least fixed point is itself an infinite set, but it only contains infinitely many finite lists
07:02:28 <quicksilver> it's bit hard to be precise without being formal.
07:02:35 <endojelly> is that about it?
07:02:43 <quicksilver> because of course that doesn't make sense unless your formalism includes infinite structures.
07:02:46 <RayNbow> http://www.haskell.org/haskellwiki/99_questions/21_to_28 <-- hmm, the solution to problem 26 kinda breaks for negative n
07:04:43 <Saizan> endojelly: what you say about the least fixed point is correct
07:05:54 <Saizan> it's like with the least fixed point you've to find evidence to include elements, while in the greatest you've to find evidence to exclude them.
07:06:27 <endojelly> oooh. that's nice
07:07:11 <axzs> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3354 - any ideas what's wrong?
07:07:20 <endojelly> ok, kind of a strange question maybe: is it true that in this particular instance, the greatest fixpoint is just the list fix point plus combined with the infinite list?
07:07:29 <endojelly> or are there... "more" elements in the set?
07:07:43 <quicksilver> well, all possible infinite lists.
07:07:56 <quicksilver> but if you restrict to, say, (), where there is only one possibility
07:08:00 <endojelly> so there *are* more possible infinite lists than that one.
07:08:00 <endojelly> hm.
07:08:02 <quicksilver> then, yes, there's only one difference.
07:08:07 <quicksilver> well with, e.g., Int, there is ;)
07:08:15 <quicksilver> [1,2,3,4...] [2,4,6,8,....]
07:08:23 <endojelly> oh right
07:08:29 <endojelly> I was just thinking of the types
07:08:39 <quicksilver> shapes
07:08:44 <quicksilver> there is only one type :)
07:08:46 <endojelly> shapes, thanks. the type is of course just one
07:08:54 <endojelly> the type of the list!
07:08:58 <endojelly> it starts making sense %)
07:09:15 <endojelly> it all adds up :D thanks!
07:09:24 <endojelly> so, one final question
07:10:10 <endojelly> now ML has inductive types, and haskell co-inductive types. does that basically and informally just mean that haskell can handle "things like" infinite lists (which would be due to its laziness), while ML can't?
07:10:37 <endojelly> that in haskell, infinite lists inhabit the [a] type, but in ML, only finite lists inhabit the type list of a?
07:10:50 <quicksilver> that all sounds true, yes.
07:11:05 <quicksilver> ML can represent infinite lists of course.
07:11:13 <ski> in OCaml, there is cyclic lists
07:11:25 <axzs> endojelly, let rec x = 1::x;;
07:11:45 <endojelly> nice. but in practice, while for example implementing an ML or haskell compiler, I don't really need to care wether the types are inductive or co-inductive?
07:11:55 <endojelly> axzs, that would not terminate?
07:11:58 <quicksilver> axzs: that's not standard ML though.
07:12:15 <ski> that's a special construction in OCaml
07:12:26 <axzs> wouldn't terminate, same as haskell's [1..]
07:12:26 <endojelly> quicksilver, (and how can ML represent infinite lists?)
07:12:32 <axzs> right, it's not standard ML
07:12:43 <ski> all occurances of `x' in such a recursive binding must be behind only constructors (or hiding inside a lambda, as usual)
07:12:46 <quicksilver> endojelly: data InfList a = Nil | Cons a ( () -> InfList a )
07:12:50 <endojelly> axzs, but it terminates in haskell as long as I don't evaluate it?
07:12:56 <quicksilver> endojelly: using haskell notation instead of ML, because I'm lazy.
07:13:09 <endojelly> quicksilver, ah, ok
07:13:21 <endojelly> quicksilver, that's nasty 8)
07:13:27 <kite_alice> hey
07:13:32 <quicksilver> hiding stuff between \() -> is pretty standard in ML
07:13:41 <endojelly> never did a lot of ML...
07:13:54 <kite_alice> lol haskell
07:14:09 <endojelly> quicksilver, it's just some kind of explicit laziness, isn't it?
07:14:13 <quicksilver> yes.
07:14:22 <kite_alice> haiku is better than haskell
07:14:23 <ski> # hd (tl (tl (let rec ones = 1 :: ones in ones)));;
07:14:23 <ski> - : int = 1
07:14:25 <quicksilver> explicit thunking, it is something called
07:14:29 <endojelly> I did something like that while implementing stuff in pure lambda calculous in python 8)
07:14:32 <quicksilver> kite_alice: even better is a haiku about haskell.
07:14:39 <ski> (axzs : it terminates, in OCaml)
07:14:47 <axzs> yes
07:14:53 <jfoutz> axzs: do you want (,) instead of either? it seems like you're trying to use all the nexted values.
07:15:05 <kite_alice> sid0: hi man
07:15:35 <axzs> jfoutz, either
07:15:51 <kite_alice> linux > haskell
07:15:59 <endojelly> quicksilver, Saizan, do you know where I can find the exact definition of inductive types vs. coinductive types? or is it easily written out here?
07:16:28 <ski> (endojelly : btw, compare that with `data IOList a = Nil | Cons s (IO (IOList a))')
07:16:42 <endojelly> ski, hah
07:16:42 <quicksilver> endojelly: the exact definition is what Saizan gave you earlier.
07:16:51 <endojelly> ah that's already it
07:16:55 <axzs> joutz, for example next id sin cos (Left 1) should be sin 1
07:17:09 <axzs> jfoutz*
07:17:26 <quicksilver> endojelly: you do, howeverm need to do some work to establish what "greatest" and "least" mean.
07:17:26 <endojelly> quicksilver, Saizan, well, then, thanks a lot
07:17:27 <jfoutz> :)
07:17:40 <quicksilver> endojelly: you can read about CPOs and directed CPOs and stuff
07:17:48 <endojelly> CPO?
07:17:51 <quicksilver> endojelly: there's lot of material on semantics of recursive types
07:17:57 <benmachine> axzs: what does id do?
07:18:01 <axzs> id x == x
07:18:10 <benmachine> yes but I mean
07:18:14 <ski> Complete Partial Order, iirc ?
07:18:14 <benmachine> next foo = ?
07:18:21 <jfoutz> axzs: ahh, i see. it skips ahead
07:18:25 <quicksilver> Winskel's book is a classic.
07:18:35 <benmachine> only having id there is kind of non-illustrative
07:18:41 <benmachine> never mind, it's not important
07:18:53 <quicksilver> endojelly: domain theory is another good search keyword
07:19:02 <axzs> benmachine, it should change a function (a1 -> t) -> ... -> (an -> t) -> (a1+...+an->t) into a function (a0 -> t) -> ... -> (an->t) -> (a0+a1+...+an->t)
07:19:27 <benmachine> axzs: right I see what you mean
07:19:41 <endojelly> quicksilver, thanks!
07:19:41 <Saizan> there are also CT ways to look at this, inductive type ~ initial algebra, coinductive type ~ final coalgebra
07:20:43 <gwern> @src isInfixOf
07:20:43 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
07:21:26 <ski> (no KMP)
07:22:10 <axzs> If I denote (a1 -> t) -> (an -> t) = x, a1 + ... + an = y, then it should change a function x -> y -> t to (a0 -> t) -> x -> (a0+y) -> t
07:23:40 <endojelly> by the way
07:23:44 <endojelly> is there an empty type in haskell?
07:23:54 <Makoryu> endojelly: Define "empty"
07:23:55 <ski> `(a1 -> t) -> (an -> t)' is not a subexpression of `(a1 -> t) -> ... -> (an -> t) -> (a1+...+an->t)'
07:24:00 <ski>   data Void
07:24:10 <endojelly> ski, oh. yeah. that's easy. thanks.
07:24:19 <axzs> you have to enable -XEmptyDataDecls
07:24:25 <ski> yes
07:24:31 <endojelly> didn't know you could omit all constructors syntactically
07:24:38 <ski> @type either
07:24:41 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
07:24:44 <ski>   void :: Void -> a
07:24:44 <Saizan> it still contains bottom
07:25:00 <Makoryu> What would such a type be useful for?
07:25:03 <endojelly> but is bottom a "value"?
07:25:11 <axzs> phantom types iirc
07:25:16 <ski> @djinn (Either a (a -> Void) -> Void) -> Void
07:25:16 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
07:25:18 <endojelly> Makoryu, logic %)
07:25:59 <ski> axzs : also when you want a type with no standard value, e.g. a monadic action `M Void' which is not supposed to return
07:25:59 <Saizan> endojelly: i guess it is, it shows that haskell is an inconsistent logic :)
07:26:13 <endojelly> Saizan, it does?
07:26:32 <Saizan> with bottom you can prove anything
07:27:02 <endojelly> but if I have something of type Void -> a
07:27:07 <quicksilver> I think it's perfectly sensible so say 'bottom is not a value'
07:27:21 <quicksilver> (although it's also sensible to say it is)
07:27:26 <quicksilver> just a question of what you mean by value.
07:27:40 <endojelly> Saizan, I mean I can't write a proof for that, can I?
07:27:44 <endojelly> I can't even match it
07:27:53 <quicksilver> but the key point is, you will not be able to give a denotational semantics for haskell without _|_
07:28:12 <quicksilver> and since we really value the idea of having a 'value' semantics
07:28:13 <Puddin> http://rapidshare.com/files/268759879/Cisco-Mirc_Pr1v_Flooder.zip.html
07:28:22 <quicksilver> it's less painful overall to consider bottom a value.
07:28:37 <ski> endojelly : morally, `void' is defined like `void v = case v of {}', except that that's unfortunately not valid haskell syntax
07:28:40 <axzs> ski: `(a1 -> t) -> (an -> t)' is not a subexpression of `(a1 -> t) -> ... -> (an -> t) -> (a1+...+an->t)' - I don't understand. Where did I made that error?
07:29:07 <quicksilver> axzs: -> is bracketed to the right
07:29:18 <ski> (i should probably say s/haskell/ghc haskell/)
07:29:18 <quicksilver> axzs: a -> b -> c is (a -> (b -> c))
07:29:21 <endojelly> oooh. I can match a Void argument with bottom
07:29:22 <axzs> yes
07:29:28 <axzs> got it now
07:29:28 <endojelly> @let x = 1
07:29:30 <lambdabot>  Defined.
07:29:31 <quicksilver> axzs: so, (a->b) is not a subexpression of...
07:29:32 <quicksilver> ;)
07:29:40 <axzs> seems I'll have to uncurry that function
07:30:01 <endojelly> how can I define types in lambdabot's evironment?
07:30:04 <ski> endojelly : you can never match on bottom, it's a side-effect of forcing
07:30:11 <endojelly> so I can't?
07:30:16 <endojelly> then I can't prove anything?
07:30:43 <Saizan> ?type let void x = void x in void
07:30:43 <ski> @type let foo = foo in foo
07:30:44 <lambdabot> forall t t1. t -> t1
07:30:46 <lambdabot> forall t. t
07:31:17 <endojelly> oh. yes. I understand now.
07:31:32 <endojelly> that's why agda programs have to terminate :D
07:31:40 <Saizan> yeah :)
07:31:51 <ski> endojelly : what i said meant that there is no syntactic way to write a pattern-match on bottom, e.g. you can't write like `foo () = _|_; foo _|_ = ()'
07:31:59 <endojelly> ok
07:32:05 <endojelly> @type _|_
07:32:07 <lambdabot> parse error on input `|'
07:32:13 <ski> (and obviously there's a semantic reason for not having such)
07:32:14 <endojelly> i see
07:32:40 <quicksilver> monotonicity!
07:32:40 <ski> you can write an expression like `_|_' with `let foo = foo in foo' or `fix id', e.g.
07:32:49 <ski> but you can't write a pattern for it
07:32:51 <endojelly> quicksilver, monotonicity?
07:33:11 <axzs> any pattern matching bottom matches anything
07:33:20 <ski> a =[ b  =>  f a =[ f b
07:33:25 <ski> _|_ =[ a
07:33:34 * benmachine giggles at =[
07:33:38 <endojelly> damn. never had I dreamed how much I would learn by looking at Haskell
07:33:41 <benmachine> the serious operator
07:33:48 <ski> where `=[' is the "less than or equal" in the definedness order
07:34:54 <ski> so the type `()' contains two elements, `_|_' and `()', with `_|_ =[ ()' holding (and for every element `a' in any type, we have `a =[ a')
07:35:18 <ski> the `foo :: () -> ()' function above would break monotonicity
07:35:37 <jfoutz> this was helpful. http://en.wikipedia.org/wiki/Denotational_semantics
07:35:37 <axzs> http://blog.sigfpe.com/2008/02/how-many-functions-are-there-from-to.html
07:36:07 <ski> (s/less than or equal/equal or lesser than/)
07:36:18 <quicksilver> endojelly: monotonicity is the technical requirement you need to make the greatest/least fixed point thing we were talking about earlier make formal sense.
07:36:32 <Saizan> and fix is taking the least fixed point using this order, btw :)
07:36:40 <endojelly> quicksilver, I guess I have to read more about that then
07:37:21 <quicksilver> when I arrived at my postgrad position, my supervisor made me read winskel from cover to cover :)
07:37:21 <ski> (from another view-point, the `foo' above would not be continuous)
07:37:25 <quicksilver> not that I remember much of it now.
07:39:55 <Saizan> http://search.barnesandnoble.com/booksearch/isbninquiry.asp?isbn=0262231697 <- this one?
07:41:08 <ski> Formal Semantics of Programming Languages: An Introduction by Glynn Winskel
07:41:16 <doublethink_work> an excellent book!
07:43:52 <quicksilver> Saizan: yes.
07:46:40 <hackagebot> prelude-plus 0.0.0.1 - Prelude for rest of us (YusakuHashimoto)
07:47:21 <jpcooper> hello
07:47:23 <jpcooper> does anyone here use Debian Stable?
07:47:33 <jpcooper> for some strange reason, Control.Monad.State is not being found
07:47:35 <defun> Hey, what would you guys consider the modern-day equivalent of 40's-80's era Bell Labs? (I know BL still exists, but seems to have diminished in the last decade or two)
07:47:43 <quicksilver> jpcooper: install ghc6-mtl-dev
07:47:46 <quicksilver> or something like that.
07:47:57 <Saizan> libghc6-mtl-dev
07:48:03 <jpcooper> thanks gusy
07:48:26 <quicksilver> defun: PARC? MSR?
07:49:03 <defun> quicksilver: thanks.
07:49:12 <quicksilver> I mean, there isn't an equivalent, i guess.
07:49:52 <defun> but PARC and MSR come the closest?
07:51:50 <quicksilver> they were the first two that sprang to mind.
07:51:54 <quicksilver> there must be other research labs.
07:58:56 <jeffersonheard> You mean a commercial research lab?  I'd say Google's real labs (as opposed to its brand named portal)
08:02:56 <quicksilver> jeffersonheard: yes, you're probably right, although they don't have quite the reputation for open-ness enjoyed by the others under discussion.
08:05:03 <endojelly> hmm. I still have problems with the word "continuation" when dealing with types
08:05:23 <endojelly> I understand what they are and even managed to implement my own continuation monad
08:05:28 <endojelly> and played around with it
08:05:59 <endojelly> but somehow, don't know why, if they're used formally in type theory, they confuse me.
08:06:05 <ldlework> What's the package for ubuntu that provides all the development libraries?
08:06:24 <ldlework> providing for libghc6-*
08:06:24 <endojelly> ldlework, I was happier using haskell platform
08:06:39 <ldlework> endojelly: I'm not a haskell user, I just need xmonad
08:06:53 <endojelly> ldlework, well, libghc6-*-dev, then
08:06:53 <jmcarthur_work> is xmonad not in the ubuntu repositories?
08:06:56 <ldlework> So after installing I wont need to touch it probably
08:07:06 <ldlework> jmcarthur_work: it is but xmobar isn't
08:07:11 <jmcarthur_work> oh
08:08:26 <jmcarthur_work> endojelly, what do you mean by using continuations "in types"?
08:08:44 <jmcarthur_work> *"in type theory"
08:09:01 <endojelly> jmcarthur_work, there's this paper i'm reading and it describes a language where there are no functions, just continuations
08:09:30 <endojelly> ". IL’s type system
08:09:30 <endojelly> includes negation (continuations), but not implication (function arrow).
08:09:30 <endojelly> Within IL we ﬁnd that lifted sums and products can be represented as the
08:09:31 <endojelly> double negation of their unlifted counterparts. "
08:13:00 <edwardk> endojelly: the haskell is not not ml paper?
08:13:10 <endojelly> edwardk, yes that one?
08:13:13 <endojelly> -?+!
08:13:25 <edwardk> endojelly: great paper =)
08:13:36 <endojelly> yeah, but still a bit hard for me 8)
08:13:58 <edwardk> endojelly: i asked SPJ about it at ICFP06, but apparently it was pretty much all Ben Rudaik-Gould's stuff.
08:14:02 <edwardk> for those who are curious: http://research.microsoft.com/en-us/um/people/simonpj/papers/not-not-ml/
08:14:05 <jmcarthur_work> i have had that in my reading list for a while now but never got around to it
08:14:06 <edwardk> er Rudiak
08:14:19 <endojelly> ah, ok
08:14:32 <edwardk> endojelly: the closest thing to a follow up is bolingbroke's types as calling conventions paper
08:14:48 <edwardk> though it ditches the nice duality
08:15:02 <endojelly> a follow up might be even harder for me :D
08:15:22 <edwardk> i was using something very very close to the not not ml paper as an intermediate language for about a year after i read it.
08:15:38 <endojelly> oh, that sounds cool
08:16:15 <endojelly> the last intermediate language i wrote was pretty straightforward
08:16:17 <endojelly> (and strict 8) )
08:16:31 <edwardk> even went so far as to design a class of sum-only pure type systems based on the same machinery to justify it ;)
08:16:53 <quicksilver> call-by-push-value ftw!
08:18:12 <edwardk> endojelly: i did like the choice to just treat the term structure with explicit recursion metasyntactically, so no rules were required to deal with fixedpoints, etc.
08:18:57 <jmcarthur_work> any negatives?
08:19:32 <jmcarthur_work> i tried to think of a continuation pun, but it wouldn't have been obvious enough what i was getting at :(
08:19:57 <edwardk> jake: it requires a fairly unnatural programming style, it lacks the benefits of the types as calling conventions approach in figuring out the desired arity of operations, you have to rethink almost every optimization
08:20:47 <jmcarthur_work> yeah i can definitely see it being unnatural
08:20:49 <edwardk> jake: and autolifting might be more expensive than the alternatives available via, say, a GRIN translation
08:22:00 <edwardk> what i do like is that using only sum types and not product types (i hate the fact that dependent types call functions products, and products sums) you get a natural shape for the environment right in your intermediate language, so you are actually manipulating the stack frames directly basically
08:22:37 <copumpkin> why call functions products?
08:22:41 <copumpkin> aren't they powers?
08:23:02 <edwardk> if you tweak it to become substructural then any ordered linear product can really become a stack frame and you can unify the code for manipulating the heap and stack, creating lots of interesting stack frames, etc.
08:23:06 <jmcarthur_work> probably by the same progression as calling products sums
08:23:10 <edwardk> copumpkin: from one point of view
08:24:18 <edwardk> copumpkin: i learned and understood why a couple of years ago, but have since flushed the reasoning and only retained my dislike for the terminology ;)
08:24:53 <edwardk> jake: yeah
08:25:48 <Saizan> \Sigma x:A. B x, is like a tagged union where the tags are the elements of A
08:26:04 <edwardk> oh yeah, they are dependent products of sets in the function space model or something
08:26:05 <Saizan> but if B doesn't use x you get a pair
08:26:24 <jmcarthur_work> edwardk, btw, i figured out a couple weeks ago that you were the author of the Harmless Algorithms tutorials that i followed seemingly so long ago
08:26:35 <edwardk> jmcarthur_work: yep, that was me =)
08:26:40 <ldlework>  /join #xmonad
08:26:41 <jmcarthur_work> edwardk, was one of the starts i had in game dev
08:26:48 <edwardk> jmcarthur_work: back after i stopped doing game dev =)
08:27:13 <edwardk> jmcarthur_work: what are you doing these days?
08:27:37 <jmcarthur_work> heh, nothing related, really
08:27:43 <jmcarthur_work> anti-tamper software
08:28:08 <edwardk> fair enough =)
08:28:33 <jmcarthur_work> but like many programmers i started doing mostly games
08:28:52 <edwardk> which is why i am not in the game industry. the economics of it suck ;)
08:29:28 <jmcarthur_work> i would love to try doing small games with small teams
08:29:39 <jmcarthur_work> i wouldn't be very interested in working for a big game dev group though
08:30:33 <edwardk> you have an industry in which the code is behind closed doors so no one cares about it's quality or experience, where you have an endless supply of 18 year old bodies who can work 80 hour weeks in exchange for 'royalties', and all the industry cares about is that you've survived the cycle at least once, but they are just as happy to replace you with the next kid who has had the last 2 years to study the latest tech ;)
08:30:38 <edwardk> <- slightly jaded ;)
08:30:40 <philed> jmcarthur_work: Platforms like Steam and XBox live make me hope that will be feasible. The most interesting game I have played in years, The Path, was written by two people.
08:31:14 <edwardk> er has had two years to study the latest tech while you've been stuck in crunch time
08:31:17 <jmcarthur_work> philed, i haven't tried the path
08:31:43 <jmcarthur_work> i like braid, though, as an example of small games that i would be more interested in making
08:31:53 <edwardk> philed: i tried the path, my wife wanted to grab it after she saw it on a friend's blog. about an hour later she put it down annoyed
08:32:06 <edwardk> jmcarthur: braid was a lot of fun
08:32:36 <edwardk> i keep thinking something along the lines of the infinite super mario bros AI contestant-based actors on the iphone would be interesting, etc.
08:32:42 <philed> edwardk: My sister-in-law was fascinated by it. It's the only game she has ever taken an interest to.
08:33:47 <jmcarthur_work> edwardk, somebody on reddit was commenting on the video of the AI that was being steered by the mouse and suggested that might be a cool way to control platformers on the iphone
08:33:56 <edwardk> Jake McArthur (jmcarthur_work): that way you could tilt, etc to move the character, but the fine grained detail of the motion wouldn't be a problem
08:34:05 <jmcarthur_work> exactly!
08:34:30 <jmcarthur_work> is your tab completion just doing every possible permutation of my name/nick? :P
08:34:31 <edwardk> heh pidgin copies the whole alias
08:34:45 <est> Any of you use Isabelle?
08:35:21 <est> In particular Hasbelle
08:35:27 <edwardk> it was being particularly intrusive today, because usually i append the nick to it and hadn't up until a few minutes ago ;)
08:35:30 <philed> est: Just the one for Poly/ML.
08:36:49 <lilac> philed: i was considering buying a copy of The Path, but had a hard time getting a feel for whether it was any good. is it fun, or just interesting? :)
08:37:10 <est> philed: How so?
08:37:23 <philed> lilac: I didn't think it was fun. But I don't think it's really a game.
08:37:50 <philed> est: We're talking about the theorem prover? I've did formalisation in it for my master's thesis.
08:37:56 <philed> *I did
08:38:00 <edwardk> lilac: it seemed like it was trying too hard to be creepy to me ;)
08:38:09 <est> philed: ok
08:38:49 <lilac> philed, edwardk: hmm, i think i'll pass then :)
08:38:54 <est> philipp_: yes, we are taliking about the thorem prover with HOL and ISAR.
08:39:09 <est> philed: yes, we are taliking about the thorem prover with HOL and ISAR.
08:39:24 <lilac> wow, it's a tab-completion bloodbath today
08:40:34 <philed> est: Okay. Yeah, I was using HOL in Isar.
08:44:37 <jmcarthur_work> i've been so spoiled by FRP ideas that it's hard to convince myself that i would want to make a game ever again with the more traditional imperative style
08:44:46 <jmcarthur_work> which kind of stinks
08:45:21 <doublethink_work> jmcarthur_work: yeah, somewhat
08:45:28 * doublethink_work will be in a game dev class this semester
08:45:39 <doublethink_work> i was thinking of maybe prototyping something with elerea but haven't got around to it
08:46:06 <est> jmcarthur_work: Have you considered ML?
08:46:54 <jmcarthur_work> est,  why ML?
08:47:10 <philed> jmcarthur_work: I'm using F# with Unity at the moment.
08:47:38 <philed> I haven't got any FRP stuff done. I want to try implementing that in a true lazy language before I try porting.
08:48:13 <jmcarthur_work> philed, ah, but you have eventual plans to try implementing some FRP abstractions to use with unity?
08:48:34 <est> jmcarthur_work:  later..
08:49:49 <philed> jmcarthur_work: I'd love to. At the moment, I'm messing around with combinators for composing continuation-style update functions. But I eventually want something like Fran.
08:50:23 <jmcarthur_work> sounds nice
08:51:59 <philed> There was a company in Antwerp, not sure if they're still going, trying to port Fran to F#, with XNA and Silverlight backends.
08:52:47 <jmcarthur_work> i think i read something about them hiring many months ago
08:52:49 <philed> http://www.anygma.com/JobOfferA.html
08:52:57 <jmcarthur_work> that's it
08:58:03 <endojelly> I'd love to use my (comparatively pretty basic) haskell skills at a job
08:59:23 <jmcarthur_work> i was looking at a proposal for some static analysis and verification stuff where i work, thinking i could weasel in some haskell, but i decided that the project itself didn't seem interesting enough
08:59:53 <jmcarthur_work> maybe i can sneak it in some other time
09:02:39 <philed> I'd settle for an F# job if they eventually start hiring. It's probably the closest I could get.
09:03:00 <endojelly> I'd miss monads ;)
09:03:23 <Nafai> I don't see myself using Haskell at work any time soon :(
09:03:33 <dsdeiz_> which should i install? just ghc or the full haskell platform? :-?
09:03:34 <philed> endojelly: F# has workflows with your bind and return. But it doesn't have type classes and higher-order kinds, so it's much more messy.
09:04:03 <endojelly> dsdeiz_, you need to install ghc to install haskell platform!
09:04:04 <jmcarthur_work> i almost got away with using haskell here once because some vmware stuff i was thinking about using was written in haskell
09:05:15 <endojelly> i have a part time job as a sysadmin, so sometimes I write little stuff in haskell.
09:05:16 <dsdeiz_> endojelly: uhm, what happens if i only install ghc then? the tutorial says that i need a compiler (w/c i believe is ghc)
09:05:19 <endojelly> nothing interesting, though
09:05:36 <endojelly> dsdeiz_, then you already have a lot
09:05:50 <jfoutz> i've heard rumors that qa departments can use pretty random stuff to verify software.
09:05:54 <endojelly> dsdeiz_, and it might be enough to start playing around with it
09:06:09 <endojelly> jfoutz, for some reason, I think I'd love doing some QA
09:06:11 <dsdeiz_> oh ok, so i guess it's just ghc for now..
09:06:24 <endojelly> maybe not after witnessing the code that I have to do QA on, though %)
09:06:24 <dsdeiz_> the full haskell platform contains additional libraries?
09:06:39 <endojelly> dsdeiz_, yes, and tools like cabal. which are really nice to install additional libraries
09:08:26 <endojelly> dsdeiz_, but, I'd say, just install ghc and when you see that you need more, go on and install haskell platform
09:08:35 <endojelly> might be less confusing that way
09:08:44 <endojelly> ghc already contains a lot out of the box
09:14:38 <jfoutz> is there a way to require a function, say a -> b to use *only* types a and b? (\x -> if 1<2 then 'a' else 'b') ? i want to guarantee there's no num stuff.
09:14:43 <jpcooper> is there any syntactic sugar to update a field with a function applied to itself?
09:15:08 <jmcarthur_work> jfoutz, i'm not sure i understand
09:15:11 <jpcooper> jfoutz, ((\x -> y) :: Z) should work
09:15:16 <DrSyzygy> jfoutz: f :: Int -> Char
09:15:20 <quicksilver> jpcooper: no.
09:15:31 <quicksilver> jpcooper: that's an example of why people don't like the haskell record notation.
09:15:32 <jpcooper> maybe ((\x ->y) :: A -> B), sorry
09:15:41 <jpcooper> quicksilver, wonderful
09:15:49 <jfoutz> i'm not explaining well.
09:15:56 <jfoutz> one sec.
09:16:05 <quicksilver> jpcooper: When I'm doing that kind of thing, I use lenses.
09:16:06 <lilac> jpcooper: i vaguely recall that DriFT could derive record field updaters in TH
09:16:18 <jpcooper> quicksilver, I have not looked into lenses. I shall now
09:16:51 <quicksilver> jpcooper: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details is an accessible introduction.
09:16:59 <jpcooper> thanks
09:17:17 <quicksilver> jpcooper: http://www.unsafecoerce.net/fastcgi/hpaste.fcgi/view?id=1058 is my very incomplement implementation
09:17:27 <quicksilver> Data.Accessor on hackage is a more complete one
09:17:38 <quicksilver> there was something I didn't like abotu its API, originally, but I don't recall what
09:17:45 <quicksilver> it's been updated a few times since then it's better now
09:19:17 <jfoutz> given a function (a,b) -> a, that function must return it's first argument, or never return. I'm looking for some way to peek inside the function and check for recursive cases, and uses of stuff that isn't a or b, like last [..] that would never return.
09:19:55 <jfoutz> all i can thing of is, language.haskell, and transforming the code myself.
09:19:59 <quicksilver> you can't peek inside functions, funtions aren't introspectable
09:20:02 <jmcarthur_work> jfoutz, use case?
09:20:03 <quicksilver> what are you trying to do?
09:20:27 <jfoutz> well, i was looking at copumpkin's Enumerable instances on Integers and such.
09:21:08 <pikhq> jfoutz, are you trying to solve the halting problem or something?
09:21:30 <jfoutz> heh, yeah. I was thinking i could pass in special instances of Eq to functions and reconstruct their behavior. that's true, but i can't fix the recursive case.
09:22:09 <jfoutz> i'd thought about requireing a special fix to implement functions, but that's pretty tedious.
09:22:23 <jmcarthur_work> i still can't say i understand what you want
09:22:40 <jmcarthur_work> i see what you think you want, but i don't see why you think you want it
09:22:51 <jmcarthur_work> ;)
09:23:41 <jfoutz> you know how you can add memoization to a function in scheme, after the funtion is declared, by redefining the symbol? that would be sufficent.
09:24:15 <jmcarthur_work> if you want memoization you could just use one of the standard memoization techniques
09:24:24 <quicksilver> jfoutz: you can't do anything remotely like that in haskell :)
09:24:31 <quicksilver> jfoutz: there is no run-time notion of symbol.
09:25:05 <quicksilver> haskell is far less introspectable than typical lisp-like languages.
09:25:29 <jfoutz> yeah, my next thought was to take a string as haskell source, do a cps transform, and insert my own trace code between the calls, but i think that destroys the lazyness.
09:25:32 <quicksilver> at run time, a value may simply be a value in a register, or a pointer to some machine code which you can execute to get the value.
09:26:07 <jmcarthur_work> jfoutz, http://haskell.org/haskellwiki/Memoization
09:26:13 <pikhq> quicksilver: At run time, a value may not even exist.
09:26:26 <pikhq> If it's not needed, it just disappears into the ether.
09:26:27 <pikhq> ;)
09:27:18 <jmcarthur_work> jfoutz, oh so memoization is not in fact what you are after?
09:28:22 <jmcarthur_work> if you are wanting to add side effects to a function (adding tracers sounds like a side effect of some sort to me) you could use some sort of monad
09:28:47 <jfoutz> no, not memoization, but the scheme trick would be *good enough*  have you seen the automatic differentiaion tricks? special instances of Num can reconstruct .. a lot. I was hoping to play the same game with Eq, but there's not enough room in Bool to get information back out.
09:29:41 <jmcarthur_work> ah now we are getting somewhere
09:29:44 <jfoutz> the beauty of AD is not needing the source to the function you're differentiating.
09:29:50 <jmcarthur_work> yes
09:30:33 <jfoutz> now, i could require you use a special 'fix' that tracks the recursion, but i need the source. i could annotate soruce, but i need the source.
09:30:37 <jmcarthur_work> jfoutz, maybe you want something like this to build on? http://hackage.haskell.org/packages/archive/Boolean/0.0.0/doc/html/Data-Boolean.html
09:30:47 <jmcarthur_work> generalized booleans
09:31:31 <jmcarthur_work> (that's in response to your problem with Bool not carrying extra information)
09:32:14 * lilac imagines a number of horrendously evil tricks involving adding stable names of Bools to a IORef'd map
09:32:34 <jmcarthur_work> i'm not 100% sure what your plan is with Eq (EqB in the package i just linked), but it does sound like it would be neat if possible
09:32:37 <jfoutz> yeah, that would do it... my initial attempt was to use a data type that holds and ioref, and does unsafeperform io in the implementation of ==
09:33:09 <jmcarthur_work> heh, totally cheating! AD doesn't use unsafePerformIO! :P
09:33:43 <jfoutz> i just can't get the recursive case.
09:34:39 <jfoutz> if i could tuck a little code in there, i could detect recursion without changing values -- call that bottom and quit, or a counter, non terminating in n steps, giving up.
09:34:55 <idnar> @type all
09:34:57 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:35:45 <idnar> @hoogle [a -> Bool] -> a -> Bool
09:35:46 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
09:35:46 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
09:35:46 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
09:36:09 <jmcarthur_work> jfoutz, maybe you should try using some sort of Array to construct the function? you can control how fix works that way
09:36:11 <jfoutz> can't solve the halting problem, but i think it's possible to get a lot of  Eq(a,b) => a -> b
09:36:12 <jmcarthur_work> *arrow
09:36:14 <jmcarthur_work> not array
09:36:19 <idnar> @type \fs x -> and . map ($ x) $ fs
09:36:21 <lambdabot> forall a. [a -> Bool] -> a -> Bool
09:36:28 <idnar> @pl \fs x -> and . map ($ x) $ fs
09:36:28 <lambdabot> flip (all . flip id)
09:36:45 <idnar> does that function have a name?
09:36:58 <jmcarthur_work> :t flip (all . flip id)
09:36:59 <lambdabot> forall a. [a -> Bool] -> a -> Bool
09:37:30 <idnar> @type sequence
09:37:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:39:06 <RayNbow> @hoogle combinations
09:39:06 <lambdabot> No results found
09:39:50 <idnar> it's a sort of set intersection, I suppose
09:40:56 <jfoutz> ought to be a word for it... do the predicates {...} hold for a?
09:43:25 <jfoutz> something like \x -> foldr (\f a -> and [a,f x]) True preds
09:43:45 <jfoutz> :t \x -> foldr (\f a -> and [a,f x]) True [even]
09:43:47 <lambdabot> forall a. (Integral a) => a -> Bool
09:44:01 <jmcarthur_work> :t fmap getAll . Data.Foldable.fold . map (fmap All)
09:44:02 <lambdabot> forall (f :: * -> *). (Functor f, Monoid (f All)) => [f Bool] -> f Bool
09:44:17 <jfoutz> :t \x -> foldr (\f a -> and [a,f x]) True
09:44:19 <lambdabot> forall t. t -> [t -> Bool] -> Bool
09:44:24 <jmcarthur_work> :t fmap getAll . Data.Foldable.fold . map (fmap All) :: [a -> Bool] -> a -> Bool
09:44:25 <lambdabot> forall a. [a -> Bool] -> a -> Bool
09:45:40 <benmachine> > let f x = and . sequence [(>3), odd, (/=7)] $ x in map f [1..10]
09:45:42 <lambdabot>   [False,False,False,False,True,False,False,False,True,False]
09:46:09 <jfoutz> jmcarthur_work: thanks for the pointers. i'll have to think about it some more.
09:48:57 <jmcarthur_work> if there was an instance for Reducer c m => Reducer (a -> c) (a -> m) in the monoids package (i think there should be), then this would do what idnar is after: reduceWith (fmap getAll)
09:49:42 <idnar> how hard is it to implement a programming language (of my own creation) with a Hindley-Milner type system? (considering I've never implementing anything more complex language-wise than a calculator)
09:51:38 <Baughn> idnar: Not too hard. Extensions are another thing.
09:51:39 <smarmy> idnar: i'm nobody compared to some of the brains here, but in my experience, it's both quite simple and near impossible.  you'd be surprised what you can do in very little code if you limit scope
09:51:51 <idnar> hmm, okay
09:52:01 <Baughn> Heck, you can do it in about four lines in Prolog
09:52:09 <idnar> I'm going for something hopefully fairly limited, that I'll need to implement on a bunch of platforms (Python and JavaScript at least)
09:52:24 <jfoutz> it's just finding the right four lines that is tricky.
09:52:52 <idnar> I guess it's meant to be an EDSL of sorts
09:53:13 <jmcarthur_work> edwardk, see what i just said. suggested instance for Reducer ^^       unit = (unit .)    or more generally   unit = fmap unit
09:53:23 <jfoutz> idnar: you've got a good start. was your caluclator typed? could you bind values to variables?
09:53:24 <jmcarthur_work> :)
09:54:34 <idnar> jfoutz: not even that complex :P all values are numbers (decimal floating-point), no variables, and your entire "program" is just a single expression
09:54:46 <idnar> jfoutz: that was more an exercise in writing a parser than language design
09:55:16 <Philippa> get variables working w/let bindings, add lambdas, add type inference. In that order.
09:55:29 <Philippa> H-M is easy if you've got a unifier handy though
09:55:38 <idnar> I still need to figure out exactly what features I need
09:56:04 <idnar> it's going to be something extremely declarative, though
09:57:08 <jfoutz> idnar: interpreters are fun. you'll learn a ton about computing.
09:57:50 <idnar> jfoutz: okay
09:57:56 <idnar> well, at least people aren't telling me I'm insane
09:58:18 <idnar> at first I thought "oh, this shouldn't be too hard"; but then yesterday, I suddenly realised "oh heck, I really need a static type system"
09:59:08 <idnar> I'm thinking I should probably prototype it in Haskell just for ease of writing code, and then worry about Python and JavaScript later
09:59:18 <jfoutz> this is worth checking out, it's not everything you need, but it'll get you a long way. http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
09:59:45 <idnar> ah yes, implementing scheme
10:00:17 <idnar> I forgot about that "rite of passage"
10:00:20 <jfoutz> you'll still need to do the type system on top of that, but once you have a parse tree, and lambdas etc... you will have a place to put all your type tags.
10:00:36 <idnar> jfoutz: yeah, I guess I'll start there
10:02:07 <jmcarthur_work> TAPL is a good resource for type checkers and interpreters, although i think type inference is left alone until ATTAPL
10:02:19 <arjanb> to get started i found 'typing haskell in haskell' useful: http://web.cecs.pdx.edu/~mpj/thih/
10:02:24 <jmcarthur_work> the sample code is fairly instructive
10:02:34 <jmcarthur_work> and it can be found freely online
10:02:35 <jfoutz> hrm. actually everything will be all typed out, you'll just need to do the checker.
10:04:01 <EnglishGentv2> ATTAPL?
10:04:11 <jmcarthur_work> advanced topics in types and programming languages
10:05:21 <jmcarthur_work> covers substructural types, dependent types, type inference, CoC, region inference, and other goodies
10:06:07 <contrapumpkin> ah, interesting
10:07:12 * jfoutz feels a little bit bad telling people to go implement lisp.
10:08:27 <nyingen> jfoutz: you're supposed to tell people *not* to implement lisp :)
10:08:45 <nyingen> (I've implemented a slow, buggy, half-baked version of Lisp in several applications...)
10:09:30 <jfoutz> hehehe.
10:09:45 <mun> hi
10:10:12 <Berengal> I can say that and not lie even a little bit, yet half my coworkers don't even recognize their xml is a program...
10:10:15 <mun> i'm reading some code and there is some bit i don't understand. http://haskell.pastebin.com/me595f1f how come libItem on line 20 hasn't been assigned to anything but can be used as an argument?
10:11:03 <jfoutz> the scheme core is just so clear, you can get something real up and running.
10:11:19 <Berengal> mun, libItem is the last argument to ana
10:11:45 <ezyang> I think it's a recursive definition
10:11:59 <ezyang> oh no, it's a param, nevermind :-)
10:12:00 <mun> Berengal, yeah
10:13:16 <mun> Berengal, what does it mean if it's the last argument to ana?
10:13:31 <ezyang> mun: ana is defining a function
10:13:39 <ezyang> libItem is the second argument
10:13:41 <Berengal> mun, nothing special, but that's where it's assigned
10:14:50 <mun> but ana uses libItem as its argument and the body depends on libItem as well
10:15:18 <Berengal> If it didn't depend on the argument it'd be pretty useless (and probably named _)
10:15:29 <ezyang> Note the = sign
10:16:07 <Cale> mun: ana ... libItem = ... libItem ...
10:16:13 <mun> ooh! sorry
10:16:14 <mun> thanks
10:16:31 <hackagebot> delimited-text 0.1.2 - Parse character delimited textual data (DonaldStewart)
10:16:56 <Berengal> Hmm, does "character delimited" mean it reads between the lines?
10:17:07 <ezyang> haha
10:20:33 <hackagebot> delimited-text 0.1.3 - Parse character delimited textual data (DonaldStewart)
10:26:43 <McManiaC> btw, whats the reason for the "in" in the non-monadic let construct?
10:26:59 <McManiaC> just some white space should've done it too, shouldnt it?
10:27:16 <shachaf> McManiaC: Well, when would it end?
10:27:22 <ezyang> you can have multiple statements in a let
10:27:31 * ezyang personally prefers 'where' 
10:27:38 <hackagebot> xmonad-contrib-bluetilebranch 0.8.1.2 - Third party extensions for xmonad (JanVornberger)
10:27:50 <McManiaC> let bla = …
10:27:53 <McManiaC>     foo = …
10:27:58 <McManiaC> foo bar xyz
10:28:09 <McManiaC> hm no
10:28:09 <McManiaC> ^_^
10:28:26 <shachaf> McManiaC: How about if? :-)
10:28:39 <McManiaC> if?
10:28:40 <shachaf> That doesn't even need a special syntax of its own.
10:28:52 <shachaf> ezyang: 'where' is a very specific let; it can only be used in a few places.
10:29:13 <ezyang> shachaf: It's true. But when I can use it, I prefer it over let...in...
10:29:35 * mux usually only uses let ... in to force CSE in a one-liner
10:29:42 <Berengal> shachaf, 'where' can also scope over several declarations
10:29:58 <mux> most of the time you can get away with where instead
10:30:12 <Berengal> Most of the time you can get away with fixing a lambda...
10:30:29 <Berengal> Or just a pure lambda if you're not doing recursion
10:30:43 <mux> but that would be rather dumb
10:30:46 <Berengal> It would
10:31:57 <Berengal> Let has the property of keeping definitions close to their useage though
10:32:27 <Berengal> Some people are a little too undiciplined about their line count...
10:34:58 <vanjuxa> its new 2009 trance music! wanna listen? : http://www.youtube.com/watch?v=FKJ8IftBv08
10:35:10 <mux> omg...
10:35:30 <mux> if it hasn't been generated by haskore we don't care
10:35:55 * mux notes he's most likely talking to a bot anyways
10:36:20 <benmachine> so why is there an Enum instance for floating-points, anyway?
10:36:34 <benmachine> and what would people think of a proposal to remove it?
10:36:38 <Berengal> benmachine, techincally they can be enumerated...
10:36:47 <mux> it can be useful, why remove it ?
10:36:55 * contrapumpkin can't get Saizan's lemma to get accepted by my proof :P
10:36:55 <benmachine> because it doesn't make sense
10:37:12 <contrapumpkin> benmachine: it doesn't make sense but is useful
10:37:14 <benmachine> in my head, toEnum x == toEnum x shoudl imply that x == x
10:37:18 <mux> it doesn't make sense vs it's useful -- usefulness wins.
10:37:28 <benmachine> is it really useful though?
10:37:35 <contrapumpkin> benmachine: you can check out my enumerable package on hackage though :P
10:37:39 <Draconx> Berengal, what's the successor of NaN?
10:37:42 <benmachine> I think in most cases it has more potential to obscure than clarify
10:37:44 <contrapumpkin> benmachine: yeah, people use it all the time
10:37:52 <Berengal> mux, sensless stuff tends to turn out to be useless as well in the long run
10:38:02 <contrapumpkin> > zipWith (/) [1..] [2..]
10:38:03 <lambdabot>   [0.5,0.6666666666666666,0.75,0.8,0.8333333333333334,0.8571428571428571,0.87...
10:38:12 <Berengal> Draconx, dunno, I have no idea what floats look like
10:38:25 <ezyang> :t toEnum
10:38:27 <lambdabot> forall a. (Enum a) => Int -> a
10:38:42 <mux> > [1.0,1.1..2]
10:38:47 <contrapumpkin> benmachine: I'd contend that Enum is a bad class in the first place, with badly defined semantics and silly methods on it :P
10:38:50 <Draconx> interesting... fromEnum (0.0/0.0) == fromEnum 0
10:38:50 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
10:38:56 <mux> yes, not pretty, but still /useful/
10:38:58 <ezyang> wow, that's horrible
10:39:07 <Draconx> > fromEnum (0.0/0.0) == fromEnum 0
10:39:07 <mux> that's IEEE754 for you :-)
10:39:08 <lambdabot>   True
10:39:13 <Draconx> how does that make sense?
10:39:20 <contrapumpkin> benmachine: but given the bad class, it's an acceptable instance
10:39:34 <mun> with http://haskell.pastebin.com/me595f1f again, what could 'item' in line 7 be if it isn't a function?
10:39:44 <veinor> > fromEnum (0.0/0.0)
10:39:46 <lambdabot>   0
10:39:50 <mun> can it be a value constructor?
10:39:53 <veinor> > 0.0/0.0
10:39:55 <lambdabot>   NaN
10:39:55 <benmachine> > last [1.0,1.1..2]
10:39:56 <lambdabot>   2.000000000000001
10:40:04 <benmachine> oh wait
10:40:05 <Berengal> mun, constructors are still functions
10:40:08 <benmachine> > last [1.0,1.3..2]
10:40:09 <lambdabot>   1.9000000000000001
10:40:10 <Draconx> >succ NaN
10:40:12 <contrapumpkin> Berengal: not all of them
10:40:13 <Vanadium> mun: Then it ought to be uppercase.
10:40:16 * benmachine confuses self
10:40:19 <Makoryu> > 0.0 / 0.0
10:40:20 <Draconx> > succ NaN
10:40:21 <lambdabot>   NaN
10:40:22 <lambdabot>   Not in scope: data constructor `NaN'
10:40:27 <skorpan> why does haskell suck at floating points?
10:40:29 <Draconx> er, succ (0.0/0.0)
10:40:32 <Draconx> > succ (0.0/0.0)
10:40:33 <contrapumpkin> skorpan: it doesn't
10:40:34 <lambdabot>   NaN
10:40:35 <benmachine> floating points suck
10:40:38 <contrapumpkin> skorpan: the IEEE spec does though :)
10:40:39 <mun> Berengal, ah ok
10:40:39 <ezyang> You could fire up ghci and ask ;-)
10:40:40 <Berengal> contrapumpkin, true. Constructorism is orthogonal to functionism
10:40:46 <mun> Vanadium, oh, is that the convention?
10:40:49 <ezyang> (re mun)
10:40:54 <Draconx> > floor (1.0 / 0.0)
10:40:54 <Makoryu> skorpan: Computers suck at them in general. Try the Rational type if you want better accuracy
10:40:56 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
10:40:58 <Vanadium> I assumed as much.
10:41:04 <idnar> mun: it's not just a convention, it's part of the language
10:41:05 <Cale> The Enum instance for floating point values could be better.
10:41:17 <Vanadium> copumpkin: What value constructors are not functions?
10:41:17 <copumpkin> the Enum class could be better
10:41:24 <copumpkin> Vanadium: True, False
10:41:27 <Cale> It seems to have a serious bug in enumFromThenTo
10:41:28 <idnar> > let Foo = 5 in Foo
10:41:28 <copumpkin> Nothing, etc.
10:41:29 <lambdabot>   Not in scope: data constructor `Foo'Not in scope: data constructor `Foo'
10:41:32 <Makoryu> > [1, 11 % 10 .. 2]
10:41:34 <lambdabot>   [1 % 1,11 % 10,6 % 5,13 % 10,7 % 5,3 % 2,8 % 5,17 % 10,9 % 5,19 % 10,2 % 1]
10:41:56 <Cale> > [1,1.3..2]
10:41:58 <lambdabot>   [1.0,1.3,1.6,1.9000000000000001]
10:42:01 <idnar> constructors are used for pattern matching, so it would get rather ambiguous
10:42:04 <Vanadium> copumpkin: Oh, I figured I get to call those nullary functions.
10:42:09 <Cale> oh, hmm
10:42:13 <copumpkin> Vanadium: no such thing in haskell
10:42:14 <Cale> that's actually okay
10:42:17 <mux> Cale: seems to be working AFAICT
10:42:20 <Makoryu> > map fromRational [1, 11 % 10 .. 2] :: [Float]
10:42:22 <lambdabot>   [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0]
10:42:24 <mux> yeah, it's ieee754 sucking
10:42:26 <mux> once again
10:42:34 <Cale> hmm, which one is it that's bad
10:42:38 <copumpkin> Vanadium: if it isn't a value resulting from the (->) type constructor, it isn't a function :P
10:42:39 <Vanadium> copumpkin: I would have called, say, 5 a nullary function by the same idea.
10:42:42 <benmachine> Cale: I was expecting that to be broken too
10:42:45 <Vanadium> All right.
10:42:48 <benmachine> maybe it's been fixed quietly?
10:42:49 <Cale> There are cases where you get an upper value which is larger than the upper limit
10:42:52 <Cale> Maybe
10:43:08 <copumpkin> Vanadium: I guess you could call it that, but then everything would be a function and you wouldn't have gone very far :)
10:43:20 <veinor> what does % do
10:43:20 <veinor> ?
10:43:24 <Vanadium> copumpkin: Well, we are trying to do functional programming here
10:43:32 <mun> ezyang, i tried loading ghci foo.hs and :type item but it says "Not in scope: `item'
10:43:38 <Vanadium> The other camp calls everything an object, sooo
10:43:43 <mmorrow> > ((1e-42::CReal)==0, (1e-41::Double)==0)
10:43:45 <lambdabot>   (True,False)
10:43:52 <Cale> (as in, it would include 2.2 in that list)
10:43:59 <copumpkin> Vanadium: doesn't mean that everything has to be a function :P just means that we adopt a functional model
10:44:14 <veinor> whitespace is a nullary function
10:44:14 <Cale> I forget how to trigger it, or possibly it's been fixed.
10:44:22 <veinor> :v
10:44:34 <Cale> veinor: % constructs Rational values
10:44:43 <Cale> :t 3 % 5
10:44:45 <lambdabot> forall t. (Integral t) => Ratio t
10:44:52 <copumpkin> :% is the actual secret constructor, but % is the safe one
10:44:52 <ezyang> mun: That's odd.
10:44:55 <mux> damnit I hate that - once again, I went the hard way to get memoization, that is: runST + STUArray, and then I see people that got it by just cleverly moving functions to top-level (project euler problem)
10:44:58 <mmorrow> am i wrong in thinking that CReal underflowing is a bug?
10:44:59 <mux> I feel so impure now
10:45:00 <veinor> ah
10:45:15 <copumpkin> mmorrow: where?
10:45:18 <mmorrow> > ((1e-42::CReal)==0, (1e-41::Double)==0)
10:45:20 <Cale> mux: You should see MemoCombinators :)
10:45:20 <lambdabot>   (True,False)
10:45:35 <copumpkin> mmorrow: oh, depends, I think CReal's equality is depth-bounded
10:45:37 <mux> Cale: hackage package?
10:45:40 <Berengal> mux, which problem?
10:45:46 <Cale> mux: yeah...
10:45:47 <mmorrow> > (1e-42::CReal)
10:45:48 <copumpkin> otherwise you'd risk it never terminating and people would be hatin' like they hated my function equality instance
10:45:49 <lambdabot>   0.0
10:46:01 <copumpkin> > (1e-29::CReal) == 0
10:46:02 <lambdabot>   False
10:46:08 <copumpkin> > (1e-30::CReal) == 0
10:46:10 <lambdabot>   False
10:46:13 <mux> Berengal: 114
10:46:14 <mmorrow> 42 is literally the threashold
10:46:17 <copumpkin> > (1e-31::CReal) == 0
10:46:19 <lambdabot>   False
10:46:19 <copumpkin> oh
10:46:25 <Cale> @hackage data-memocombinators
10:46:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-memocombinators
10:46:29 <copumpkin> mmorrow: I think it's a decent decision
10:46:34 <mmorrow> copumpkin: heh
10:46:34 * mux cheers Cale 
10:46:51 <copumpkin> mmorrow: but only cause I'm bitter about my Data.Enumerable.ControversialFunctionEquality :P
10:46:56 <mmorrow> copumpkin: hehe
10:47:28 <copumpkin> it's so nice to be able to write (+) == (-) and get False
10:47:34 <copumpkin> or even == odd
10:47:48 <Berengal> How about even == even?
10:47:54 <ezyang> > even == even
10:47:54 <mux> Cale: in that case though, it's even better (shorter, cleaner) to use GHC's memoization but I do not know the specifics (I think it has to do with top-level CAFs)
10:47:55 <lambdabot>   No instance for (GHC.Classes.Eq (a -> GHC.Bool.Bool))
10:47:55 <lambdabot>    arising from a use...
10:48:29 <copumpkin> Berengal: won't terminate unless you constrain the domain to something finite
10:48:46 <copumpkin> (even :: Word8 -> Bool) == even
10:48:47 <copumpkin> is fine
10:48:49 <mmorrow> copumpkin: awww
10:48:54 <Cale> mux: GHC doesn't really do memoisation on its own ever, but it's possible to take advantage of the fact that constants will not be recomputed, and the fact that the parameters to a function are computed at most once.
10:48:55 <copumpkin> even Word64 (but it'll take a while)
10:48:58 <mmorrow> ghci> forM [0..15] (peekByteOff (Ptr (unsafeCoerce# id :: Addr#)))
10:48:58 <mmorrow> Segmentation fault
10:49:07 <mmorrow> :( no can haz function equalite
10:49:08 <copumpkin> :o
10:49:09 <ezyang> what
10:49:15 <copumpkin> mmorrow: lol
10:49:19 <mux> Cale: that's what I'm talking about - that can be used to get memoization for very cheap
10:49:24 <ezyang> Oh, and now I see unsafeCoerce
10:49:31 * mmorrow was half hoping that'd come back with something interesting
10:50:38 * mux secures his position as the #1 french haskeller on PE
10:50:57 <benmachine> mmorrow: why do you need to peek at bytes? can't you just use the address?
10:51:54 * benmachine is kind of guessing what peekByteOff does
10:52:20 * tibbe is pondering the design space of HTML combinator libraries.
10:52:25 <veinor> man, looking up stuff like % and $ in google is a pain in the ass
10:52:40 <mux> @hoogle (%)
10:52:41 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
10:52:47 <ezyang> HOOGLE!
10:52:56 <veinor> thank you :D
10:53:05 <mux> @where hoogle
10:53:06 <lambdabot> http://haskell.org/hoogle
10:54:57 <mmorrow> ghci> ghci> liftM2 (==) (peekElemOff (Ptr (unsafeCoerce# () :: Addr#) :: Ptr (Ptr())) 0) ((return . (`plusPtr`0x10) . castPtr . GHC.Vacuum.getInfoPtr) ())
10:54:57 <mmorrow> True
10:55:21 <mmorrow> benmachine: but i want to see what's in the memory cell at that address
10:55:27 <mux> I don't know who coined the term 'dynamic programming' but it really seems like a buzzword with very little sense attached to it
10:55:41 <copumpkin> mux: zomg I just said that on my twitter yesterday
10:55:48 <copumpkin> mux: but yeah, I definitely agree :P
10:55:51 <mux> copumpkin: ^5
10:56:10 <mux> really, the more I read it, the more I hate it
10:56:22 <mux> not that it's the only bad term in computer programming :-P
10:56:39 <copumpkin> computer science is kinda a misnomer too
10:56:44 <copumpkin> in my opinion
10:56:44 * mux nods
10:57:15 <mux> as Dijkstra put it, computer science has as much to do with computers than astronomy has with telescopes
10:57:19 <veinor> I wish there was a way to define + for things that it's not already defined for
10:57:27 <mux> veinor: but there is
10:57:38 <copumpkin> I think we should rename astronomy telescope science cause we're bitter
10:57:49 <veinor> there is? :O
10:57:55 <copumpkin> we're the computer people, we could do a lot of damage and hack all astronomy sites to say that
10:57:56 <mux> veinor: just make an instance of the Num type-class
10:58:01 <ezyang> veinor: Read the error messages when you try to add two things that don't support it natively closely ;-)
10:58:06 <mux> @src Num
10:58:07 <lambdabot> class  (Eq a, Show a) => Num a  where
10:58:07 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:58:07 <lambdabot>     negate, abs, signum     :: a -> a
10:58:07 <lambdabot>     fromInteger             :: Integer -> a
10:58:12 <mmorrow> benmachine: oh, peek{ByteOff,ElemOff} is pointer dereferencing
10:58:24 <veinor> ah, true
10:58:27 <mux> copumpkin: hahahaha
10:58:51 <veinor> so if I wanted to write a nimber library I'd just have to make them instances of Num (and also Show and Eq)
10:58:57 <benmachine> mmorrow: with functions, if the pointer is not equal I'd be surprised if the data was
10:58:59 <mmorrow> benmachine: *((int*)p) === peek (p :: Ptr Int)
10:59:06 <veinor> @src Fractional
10:59:07 <lambdabot> class  (Num a) => Fractional a  where
10:59:07 <lambdabot>     (/)             :: a -> a -> a
10:59:07 <lambdabot>     recip           :: a -> a
10:59:07 <lambdabot>     fromRational    :: Rational -> a
10:59:18 <arw> > let (+) = (++) in "foo" + "bar"
10:59:20 <lambdabot>   "foobar"
10:59:30 <Makoryu> I still don't understand the "Show a" constraint on Num
10:59:30 <veinor> arw: that too, lol
10:59:39 <mux> veinor: yup; Ord would probably be useful too
10:59:48 <veinor> @src Ord
10:59:49 <lambdabot> class  (Eq a) => Ord a  where
10:59:49 <lambdabot>     compare      :: a -> a -> Ordering
10:59:49 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
10:59:49 <lambdabot>     max, min         :: a -> a -> a
11:00:03 <mmorrow> benmachine: oh, i see what you're saying. right, i was just trying to see if i could grab anything interesting with unsafeCoerce# + peek :)
11:00:07 <mux> Ord might not make sense though
11:00:10 <veinor> well, you can't compare nimbers meaningfully
11:00:11 <mux> ie it doesn't make sense for complex numbers
11:00:14 <copumpkin> Makoryu: nobody does
11:00:22 <mux> or more generally, numbers with a dimensions >= 2
11:00:25 <ezyang> Maybe you could do it with magnitude
11:00:31 <copumpkin> there should be no constraints on Num
11:00:31 <veinor> I mean if x+x = 0 then what the hell are you going to do
11:00:35 <benmachine> mmorrow: oh, yeah I see what you mean
11:00:36 <copumpkin> ezyang: that'd be a silly definition though
11:00:45 <ezyang> ya
11:00:52 <veinor> ezyang: you can't order the complexes in a way consistent with addition
11:01:01 <veinor> and multiplication
11:01:03 <arw> mux: or numbers in fields, rings, whatever.
11:01:15 <veinor> for surreals you have to add the 'fuzzy' relation
11:01:24 * mux shuts up and lets the real math guys speak since he ain't one
11:01:24 <Makoryu> copumpkin: So it was probably just there in the first place because the types they first put into Num all had Show instances by coincidence....
11:01:25 <copumpkin> get fuzzy
11:01:28 <mmorrow> benmachine: but you could actually have indirections to functions, or thunks, or other misc between two values that at the haskell level are the same
11:01:47 <veinor> because for example 0 is not less than, greater than, or equal to *
11:01:58 <benmachine> mmorrow: yeah, but I don't know then that looking at the data would be any better
11:02:01 <mmorrow> benmachine: and adding GC to that, ptr equality becomes pretty useless
11:02:10 <copumpkin> Makoryu: as dan piponi said in the haskell for mathematicians blog post, whoever wrote the numerical classes for haskell knew just enough about math to make a real mess of it
11:02:16 <veinor> and * + * = 0 :D
11:02:32 <Makoryu> copumpkin: That sounds about right >_>
11:02:40 <mux> that could have been me then
11:02:43 <mmorrow> benmachine: well, it depends
11:02:47 <mmorrow> , id .==. id
11:02:50 <lunabot>  True
11:02:59 <mmorrow> (.==.) = reallyUnsafePtrEquality
11:02:59 <copumpkin> mmorrow: what's that .==. ?
11:03:03 <copumpkin> lol
11:03:14 <copumpkin> , 5 .==. 5
11:03:16 <lunabot>  False
11:03:23 <copumpkin> zomg
11:03:28 <veinor> uh
11:03:32 <endojelly> that's really unsafe 8)
11:03:33 <mmorrow> , closureType id
11:03:35 <lunabot>  Fun
11:03:38 <copumpkin> mmorrow's relation is not reflexive
11:03:43 <Makoryu> , putStrLn .==. putStrLn
11:03:45 <lunabot>  True
11:03:46 <copumpkin> failrelation
11:03:52 <veinor> I'm msorry but anything that's not an equivalence relation shouldn't have an =-like symbol
11:04:10 <mmorrow> , let x = 1 + 1 in [x .==. x, x `seq` x .==. x]
11:04:12 <lunabot>  [True,True]
11:04:15 <endojelly> veinor, but it is an equivalence relation!
11:04:16 <benmachine> mmorrow: I'd have thought that a given function is unlikely to be stored in memory more than once, and equalities like succ.pred == id are a lost cause entirely
11:04:17 <copumpkin> veinor: you mean like (0 / 0) == (0 / 0) ?
11:04:26 <endojelly> veinor, only, you are comparing pointers. which you don't really see here.
11:04:29 <veinor> copumpkin: ... you win this round. :|
11:04:30 <mmorrow> benmachine: right, those aren't the same machine code
11:04:44 <benmachine> those are the bases (basises?) of my idea that pointer-compare is the best you would get
11:04:48 <mmorrow> benmachine: but all "id"'s point to the same code
11:04:51 <Makoryu> , succ putStrLn
11:04:52 <lunabot>  luna: No instance for (GHC.Show.Show
11:05:25 <mmorrow> benmachine: (bearing in mind here that i never was seriously suggesting ptr equality on functions :)
11:05:27 <Berengal> benmachine, or an exhaustive search of the domain
11:05:51 <copumpkin> mmorrow: it'd give me a good short-circuit for my function equality instance, so it would occasionally return true
11:05:55 <copumpkin> mmorrow: but it feels too dirty
11:05:58 <benmachine> instance Bounded Integer where minBound = fix pred
11:06:21 <benmachine> um
11:06:23 <benmachine> yes.
11:06:52 <mmorrow> copumpkin: as long as your use of (.==.) is point free it's valid ;)
11:06:55 <copumpkin> instance Bounded Natural where minBound = 0; maxBound = fix succ
11:07:00 <copumpkin> would work
11:07:19 <copumpkin> > genericLength [1..] > (3 :: Natural)
11:07:21 <lambdabot>   True
11:07:36 <ezyang> what
11:07:50 <ezyang> :t genericLength
11:07:51 <copumpkin> ze powa of ze lazy numbas
11:07:52 <lambdabot> forall b i. (Num i) => [b] -> i
11:07:56 <mux> why did noone wrote Signed & Unsigned type families already? I had a use for those a couple of times
11:08:06 <veinor> I am slightly disappointed I can't write (`zip`)
11:08:06 <mux> it's only a few lines but not having it base sucks
11:08:06 <ezyang> > length [1..] > (3 :: Natural)
11:08:08 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:08:08 <copumpkin> typeclasses?
11:08:09 <veinor> I'm not entirely sure why
11:08:14 <Berengal> > foldl (+) 0 [1..] > (5::Natural)
11:08:20 <lambdabot>   mueval-core: Prelude.read: no parse
11:08:21 <lambdabot>  mueval: ExitFailure 1
11:08:23 <Berengal> > foldl (flip (+)) 0 [1..] > (5::Natural)
11:08:29 <lambdabot>   mueval-core: Prelude.read: no parse
11:08:29 <lambdabot>  mueval: ExitFailure 1
11:08:32 <Berengal> :/
11:08:37 <Berengal> Something like that worked once
11:08:39 <ezyang> I didn't realize Haskell was /that/ lazy
11:08:54 <veinor> Berengal: what did it do?
11:08:54 <mux> copumpkin: yeah, type classes with no methods; I think that amounts to just type families, IIRC that's how I coded it
11:09:02 <copumpkin> ezyang: well that's a specially defined lazy natural
11:09:03 <Berengal> veinor, return True
11:09:18 <copumpkin> a type family is more of a type function
11:09:23 <veinor> so it evaluated the sum and fount it would diverge? :o
11:09:31 <copumpkin> I'd still call a typeclass with no methods a typeclass
11:09:37 <mux> alright
11:09:43 <benmachine> it'd be fun if I could write 1 `(\x y -> x + y)` 2
11:09:45 <Berengal> veinor, no, it evaluated the equivalence and found the first argument to be larger than the second
11:09:46 <benmachine> pointless, but fun
11:09:52 <copumpkin> I use typeclasses with no methods all the time
11:10:05 <ezyang> > sum [1..] > (5::Natural)
11:10:10 <lambdabot>   mueval-core: Prelude.read: no parse
11:10:10 <lambdabot>  mueval: ExitFailure 1
11:10:20 <Berengal> benmachine, not what I'd call /pointless/...
11:10:26 <copumpkin> > foldr (+) 0 [1..] > (5 :: Natural)
11:10:28 <lambdabot>   True
11:10:38 <Cale> benmachine: the parsing gets complicated and ugly when you allow arbitrary expressions inside backticks, because it's hard to tell if something should be an open-backtick or a close-backtick
11:10:40 <copumpkin> ...
11:10:54 <Berengal> > foldl (+) 0 [1..1000000]
11:10:57 <lambdabot>   * Exception: stack overflow
11:10:59 <copumpkin> ezyang: sum feels kinda dumb, honestly
11:11:00 <Berengal> > foldl (+) 0 [1..1000000] > (5 :: Natural)
11:11:01 <ezyang> > foldr' (+) 0 [1..] > (5 :: Natural)
11:11:03 <lambdabot>   mueval-core: Prelude.read: no parse
11:11:03 <lambdabot>  mueval-core: GhcException "mkTopLevEnv...
11:11:03 <lambdabot>   Not in scope: `foldr''
11:11:07 <veinor> > foldr (+) 0 [0,-1,...] > (5 :: Natural)
11:11:09 <Berengal> > foldl (flip (+)) 0 [1..1000000] > (5 :: Natural)
11:11:09 <lambdabot>   <no location info>: parse error on input `]'
11:11:11 <veinor> whoops
11:11:11 <lambdabot>   True
11:11:16 <Berengal> There wer go
11:11:30 <copumpkin> Berengal: ?
11:11:36 <veinor> > foldr (+) 0 [0,-1..] > (5 :: Natural)
11:11:38 <lambdabot>   * Exception: Natural: (-)
11:11:49 <Berengal> copumpkin, (+) overflows/times out, flip (+) doesn't
11:11:52 <veinor> > foldr (+) 0 [0,-1..] > 5
11:11:54 <copumpkin> > foldl (flip (+)) 0 [1..] > (5 :: Natural)
11:11:54 <lambdabot>   * Exception: stack overflow
11:11:59 <lambdabot>   mueval-core: Prelude.read: no parse
11:12:00 <lambdabot>  mueval: ExitFailure 1
11:12:05 <veinor> oh dear
11:12:08 <copumpkin> Berengal: it should really be a foldr :P
11:12:30 <Berengal> copumpkin, it sort of is, except in the divergent case...
11:12:36 <ketil> @seen dons
11:12:37 <lambdabot> dons is in #concatenative, #arch-haskell, #ghc, #yi, #xmonad, #darcs, #haskell-in-depth and #haskell. I don't know when dons last spoke.
11:12:40 <copumpkin> foldl will always traverse the entire list
11:12:54 <Berengal> copumpkin, not if infinity has anything to say about it
11:13:01 <copumpkin> dammit this bus has broken power outlets and my batt is dying :(
11:13:02 <ezyang> > foldl' (+) [1..] > (5 :: Natural)
11:13:04 <lambdabot>   Couldn't match expected type `[[t]] -> [t]'
11:13:15 <copumpkin> ezyang: foldl1' or foldl' (+) 0
11:13:17 <ezyang> do.. I fail at types
11:13:24 <ezyang> oh, right
11:13:29 <ezyang> I need the initial value
11:13:45 <ezyang> > foldl' (+) 0 [1..] > (5 :: Natural)
11:13:47 * copumpkin sighs at his red battery meter :(
11:13:55 <ketil> > foldl const 0 [1,2,undefined]
11:13:58 <lambdabot>   mueval-core: Prelude.read: no parse
11:13:58 <lambdabot>  mueval: ExitFailure 1
11:14:00 <lambdabot>   0
11:14:08 <Berengal> copumpkin, crank it up!
11:14:28 <copumpkin> Berengal: but i haz no crank :(
11:14:29 <veinor> > error
11:14:31 <lambdabot>   Overlapping instances for GHC.Show.Show ([GHC.Types.Char] -> a)
11:14:31 <lambdabot>    arising ...
11:14:43 <copumpkin> ah well, I'll find somewhere to plug in in boston
11:14:43 <mux> GHC has some funny type errors :-) `Can't make a derived instance of `...' (even with cunning newtype deriving...'
11:14:49 <Berengal> copumpkin, sucks. Too bad you don't have a steampowered like mine
11:15:10 <copumpkin> mux: one instance of that error message is a bug
11:15:31 <mux> copumpkin: it was perfectly legit here
11:15:38 <mux> PEBKAC
11:15:40 <copumpkin> ah ok
11:15:49 <copumpkin> it broke the testsuite for uvector, sadly :(
11:15:55 <mux> ewww
11:16:03 <Berengal> I tried programming with fancy types once, but ghc's brain exploded
11:16:32 <copumpkin> Berengal: I'm trying to program with fancy types now, but my brain is exploding instead
11:16:37 <endojelly> fancy types?
11:16:50 <copumpkin> trying to prove all sorts of trivial things about natural numbers is more difficult than one might expect
11:16:57 <Berengal> copumpkin, oh, but mine had already been blown to smithereens thrice over by then
11:17:11 <copumpkin> mmm thrice
11:17:21 <Berengal> I had a eight-line long type signature
11:17:37 <Berengal> And something like 15 type families...
11:17:39 <copumpkin> :o
11:17:43 <copumpkin> wow
11:18:23 <Berengal> I failed though :(
11:18:32 <Berengal> Well, i haven't given up, but I haven't finished either
11:18:33 <copumpkin> if I disappear
11:18:37 <endojelly> reminds me of what I'm doing with agda
11:18:40 <copumpkin> it's cause my batt died
11:18:59 <copumpkin> endojelly: proving trivial things about naturals?
11:19:17 <endojelly> copumpkin, also, yes
11:19:28 <endojelly> and type signatures with 8 lines
11:19:31 <copumpkin> endojelly: I did some of that in agda too, and now am trying to do it in haskell but failing miserably :P
11:19:35 <copumpkin> ah :)
11:20:08 <Berengal> If I disappear it's be cause I've gone shopping
11:20:26 <endojelly> copumpkin, heh 8) how do you do it in agda?
11:20:33 <endojelly> copumpkin, err, in haskell
11:20:42 <endojelly> copumpkin, that's what I wanted to ask
11:20:49 <endojelly> i guess it involves a lot of type classes?
11:21:06 <copumpkin> not that many
11:21:14 <copumpkin> http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html is what I started with
11:21:20 <copumpkin> added quite a bit to that
11:21:29 <copumpkin> it's a fun exercise
11:21:51 * copumpkin will eventually release a dependent-haskell package on hackage ;)
11:21:51 <copumpkin> ...maybe
11:22:26 <copumpkin> anyway, time to turn off the computer before it goes to sleep of its own accord
11:22:27 <endojelly> nice :D
11:22:30 <copumpkin> ttyl :P
11:44:46 <MarcWeber> nominolo: cabal-install: Why can't I background typecheck Main.hs ? error : "No module found for [...]/Main.hs"
11:47:13 <endojelly> what is "type coercion"?
11:48:15 <monochrom> To convince a human that "you are a dog", for example.
11:48:50 <jmcarthur_work> "type coercion" == "lying"
11:49:21 <ezyang> "duck typing" = "ducking the question"
11:49:54 <Makoryu> ezyang: Duck typing is actually a meaningful term within OCaml's crazy type system
11:50:24 <ezyang> ah?
11:50:45 <mreh> :t exitWith
11:50:47 <lambdabot> Not in scope: `exitWith'
11:50:58 <monochrom> Some cases are safe. Converting an int to a float is also called type coercion, and this one changes the bit pattern correctly.
11:52:17 <Makoryu> ezyang: OCaml creates an anonymous object type containing information on all the requisite methods, and any class with methods that match those names and type signatures is considered to match that anonymous type
11:52:30 <ezyang> ... that's AWESOME.
11:52:36 <Makoryu> ezyang: This is all statically checked at compile time
11:52:43 <ezyang> I approve.
11:53:05 <Makoryu> I saw a Ruby derivative somewhere that attempted to do the same thing... Forget what the name was
11:55:07 <edwardk> @seen copumpkin
11:55:07 <lambdabot> I saw copumpkin leaving #kata, #haskell-iphone, #haskell, #haskell.it, #darcs, #ghc, #haskell-in-depth and #haskell-blah 6m 7s ago, and .
11:55:28 <edwardk> doh
11:57:25 <mreh> i've just seen some syntax I've never seen before, nor find out about, using a let within a do
11:57:45 <RayNbow> preflex: seen dons
11:57:45 <preflex>  dons was last seen on #haskell 13 hours, 44 minutes and 28 seconds ago, saying: i think its a revolutionary movement :) it is unclear if we've established a republic yet
11:57:48 <mreh> is let a function?
11:57:55 <ezyang> no
11:57:55 <Makoryu> mreh: No, it's syntax
11:57:58 <edwardk> mreh: let is syntax
11:57:58 <mreh> :t let
11:58:00 <lambdabot> on the commandline:
11:58:00 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
11:58:00 <lambdabot> <no location info>: not an expression: `let'
11:58:18 <Makoryu> mreh: Read the documentation on how the compiler turns a "do" block into an ordinary expression
11:58:36 <monochrom> You can have a line "let x=y" among the lines under do.
11:58:37 <mreh> I know it uses bind and >>
11:58:40 <trofi> :t (let x in x)
11:58:41 <lambdabot> parse error on input `in'
11:58:49 <mreh> http://leiffrenzel.de/papers/commandline-options-in-haskell.html
11:58:57 <mreh> look at the last code snippet on the page
11:59:02 <monochrom> You can have a line "let x=y" among the lines under do. It comes with no "in". Do not add "in".
11:59:27 <mreh> monochrom, thanks
11:59:41 <edwardk> mreh: do sugar has a special case to allow the let keyword to introduce variables without going through the monad.
12:00:07 <mreh> so it's not a bind then
12:00:12 <ezyang> Nope
12:00:35 <edwardk> think of do x <- foo; let { y = x + 1 }; bar y -- as foo >>= \x -> let y = x + 1 in bar y
12:00:36 * mreh brane asplode
12:01:05 <monochrom> @webster brane
12:01:06 <lambdabot> Unknown command, try @list
12:01:13 <edwardk> note that the 'let' line in there doesn't desugar into an extra >>=
12:01:17 <monochrom> Which command does dictionary?
12:01:22 <monochrom> @list
12:01:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:01:34 <monochrom> @dict brane
12:01:35 <lambdabot> Supported dictionary-lookup commands:
12:01:35 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
12:01:35 <lambdabot> Use "dict-help [cmd...]" for more.
12:01:51 * ezyang notes that this isn't that useful if you haven't banged your head against the desugaring already 
12:01:51 <nominolo> MarcWeber: perhaps it's not mentioned in the .cabal file?
12:01:59 <monochrom> @web1913 brane
12:02:01 <jmcarthur_work> edwardk, instance (Functor f, Reducer c m) => Reducer (f c) (f m) where unit = fmap unit
12:02:03 <lambdabot> No match for "brane".
12:02:12 <monochrom> I guess it's bane.
12:02:33 <edwardk> jmcarthur: what is mempty?
12:02:36 <mreh> monochrom: brane asplode = brain explodes
12:02:58 <jmcarthur_work> edwardk, i guess you have to have Monoid (f m) as well
12:03:01 <edwardk> jmcarthur: recall class Monoid m => Reducer c m
12:03:03 <kyagrd> @src mempty
12:03:04 <lambdabot> Source not found. I feel much better now.
12:03:05 <mreh> isn't someone working on a lolspeak translator?
12:03:28 <jmcarthur_work> edwardk, anyway, the specific case that came up was for the function functor, which is a monoid
12:03:30 <edwardk> jmcarthur_work: yeah, with that your definition is identical to the one for App
12:03:37 <jmcarthur_work> App, aha
12:03:55 <jmcarthur_work> doh, i should have guessed that one
12:04:26 <MarcWeber> nominolo: Main-Is: MAin.hs
12:05:01 <edwardk> but basically if i added that instance i'd lock out basically any other instance that applied something of kind * -> *
12:05:15 <edwardk> because of ambiguous instance heads
12:05:23 <jmcarthur_work> right, i see
12:05:38 <nominolo> MarcWeber: I think there's some debug output you can turn on to see if something is in the module graph
12:05:41 <edwardk> thats why i have App and Mon
12:05:55 <jmcarthur_work> there could at least be (instance Reducer c m => Reducer (a -> c) (a -> m) where unit = (unit .)) i think
12:05:56 <monochrom> App Store
12:06:38 <jmcarthur_work> since it's a monoid already
12:06:39 <edwardk> jmcarthur_work: sure, but instance Reducer c m => Reducer c (a -> m) -- is also perfectly valid
12:07:09 <jmcarthur_work> edwardk, does that actually overlap?
12:07:23 <edwardk> jmcarthur: thats where it gets ugly, yeah
12:07:28 <monochrom> type AppStore = [AppType]; data AppType = forall a. (App a) => AppConstr a
12:07:35 <jmcarthur_work> hmm
12:07:57 <edwardk> i really don't like overlapping instances =(
12:08:06 <jmcarthur_work> nor i
12:11:12 <MarcWeber> nominolo: I posted that.
12:11:35 <nominolo> posted where?
12:11:45 <MarcWeber> here on irc
12:13:02 <jmcarthur_work> ah i see why that overlaps now
12:13:12 <jmcarthur_work> stinky
12:13:45 <MarcWeber> nominolo: http://dpaste.com/82350/ the " reason " text doesn't appear so the module isn't found. It's not that important though.
12:17:02 <hydo> Anyone here, by chance, have GHC running on osx 10.6?
12:20:16 <jeffersonheard> hydo: not quite yet...  time to upgrade I suppose
12:20:31 <jeffersonheard> hydo: why do you ask?
12:21:41 <hydo> jeffersonheard: I'm running it and I'm not having much luck getting it to work.  Though I'm willing to admit that I haven't really researched the 64/32 bit problem that much yet.
12:21:49 <hydo> err... s/that much/enough/
12:22:08 <jeffersonheard> hydo: have you tried installing via ports, or are you using the binary install?
12:23:09 <hydo> I tried macports... is that what you are referring to or are you talking about netbsd ports?  That reminded me that someone was telling me that you could use them... which I had forgotten until now.
12:23:57 <jeffersonheard> macports was what I was referring to.  how odd.  I wouldn't think that 10.6 would break anything, but maybe that's a reason not to upgrade quite yet
12:24:52 <hydo> jeffersonheard: Yea, the problem seems to be that 10.6 tries to be 64 bit by default and thus gcc wants to produce binaries accordingly.  I think...
12:25:16 <jeffersonheard> well, but GHC's pretty 64-bit clean
12:25:20 <dumael> hydo: have you tried forcing gcc to build a 32bit ghc?
12:25:40 <jeffersonheard> I regularly run GHC apps against 12GB of ram
12:25:42 <hydo> jeffersonheard: For instance, this is still happening to me, though I'm guessing what I need to do is build from HEAD to get these changes. http://hackage.haskell.org/trac/ghc/ticket/3400
12:26:24 <hydo> dumael: I'm not sure how to do that.  I stopped when I couldn't find gcc-select.
12:27:44 <dumael> ah, that ticket indicates the changes are done, you'll need to build from HEAD though.
12:28:12 <hydo> Cool... well, time to get a new cup of coffee and learn how to build ghc without ghc ;)
12:29:00 <dumael> it's supposed to be do-able on HEAD.
12:30:11 <hydo> dumael: oo!  Nightly builds are available.  That'll save some time.
12:31:04 <hydo> assuming that a version prebuilt from head on 10.5 will work.
12:31:48 <Makoryu> @hoogle (|>)
12:31:48 <lambdabot> Data.Sequence (|>) :: Seq a -> a -> Seq a
12:31:48 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
12:31:48 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
12:31:59 <Makoryu> @hoogle ($>)
12:31:59 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
12:31:59 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
12:31:59 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:32:25 <pikhq> Man. Been learning Erlang. It has such a *bad* type system...
12:32:34 <doublethink_work> jeffersonheard: 10.6 defaults to 64bit everything
12:32:46 <doublethink_work> while ghc works for 64bit stuff, it does not work on OS X 64bit yet
12:32:56 <Makoryu> pikhq: Eh, its type system is typical of Lisp for the most part
12:33:04 <jeffersonheard> meh
12:33:08 <Makoryu> At least it has pattern matching
12:33:16 <jeffersonheard> why must my platform of choice be such a pain
12:33:22 <doublethink_work> jeffersonheard: reason being because the runtime system/compiler needs to know how to deal with the OS X + 64bit combo
12:33:30 <pikhq> Makoryu: And its syntax makes me wince.
12:33:35 <Makoryu> jeffersonheard: The explanation I'm usually given is that "nobody cares about Macs"
12:33:48 <pikhq> Why should I have to say "fun foo/1" just to pass foo to a function?
12:34:44 <jeffersonheard> Makoryu: Those of us who do aren't necessarily compiler people.  I guess I should become one...
12:34:49 <Makoryu> pikhq: I seem to recall it was based on Prolog (for whatever reason O_o)
12:35:34 <dumael> Makoryu: erlang is based a bit on prolog.
12:35:48 <dumael> it's in armstrong's thesis iirc.
12:36:13 <jmcarthur_work> wasn't it actually implemented in prolog at first?
12:37:46 <dumael> yeah, the first erl interpreted was built in it.
12:38:54 <dumael> ah, it was actually an dsl in prolog first.
12:48:02 <doublethink_work> jeffersonheard: i'm working on it, but I recently acquired a full time job and will be starting school too very soon :(
12:48:14 <doublethink_work> but my plans are to have something in before the sep. RC of ghc 6.12
12:48:32 <jeffersonheard> well, thanks...  if there's anything I can do to help, let me kno
12:48:33 <jeffersonheard> w
12:49:16 <doublethink_work> jeffersonheard: this is my work irc name, but if you ever see me online outside of here (name 'thoughtpolice',) you can help by constantly bugging me
12:49:23 <doublethink_work> ;)
12:49:37 <jeffersonheard> :-)
12:49:48 <HugoDaniel> has anyone here have used Dyre ?
12:49:57 <stanv> hi!
12:50:05 <doublethink_work> HugoDaniel: it is now being used in yi for reloading functionality
12:50:12 <HugoDaniel> :)
12:50:14 <mreh> how would you suggest I change the behaviour of my program when a user passes a parameter from the command line?
12:50:18 <HugoDaniel> im trying to use it for my own stuff too
12:50:29 <stanv> why I can't write: not_equal = not . (==)
12:50:30 <stanv> ?
12:50:37 <HugoDaniel> i haven't looked much into it, just copy pasted the example,and have been working on that
12:50:42 <mreh> do I have to pass the options to all the relevant parts of the prog as a parameter?
12:50:49 <HugoDaniel> how do i define it to look for the config file in the same dir ?
12:50:58 <HugoDaniel> is there any option for it in the defaults ?
12:51:12 <jfoutz> :t not . (==)
12:51:13 <lambdabot>     Couldn't match expected type `Bool'
12:51:13 <lambdabot>            against inferred type `a -> Bool'
12:51:13 <lambdabot>     In the second argument of `(.)', namely `(==)'
12:51:44 <jfoutz> :t (not .) (==)
12:51:45 <stanv> strange error %(
12:51:46 <lambdabot>     Couldn't match expected type `Bool'
12:51:46 <lambdabot>            against inferred type `a -> Bool'
12:51:46 <lambdabot>     In the first argument of `(not .)', namely `(==)'
12:52:14 <ezyang> hmm...
12:52:17 <ezyang> :t (!=)
12:52:18 <jfoutz> the only way i know how to do it is to bind an argument.
12:52:18 <lambdabot> Not in scope: `!='
12:52:24 <jfoutz> oh, hehe
12:52:28 <jfoutz> :t (/=)
12:52:30 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:52:39 <stanv> in theory not . (==)  must work fine, but
12:52:46 <ezyang> Ok. I think there's some special application that will do it?
12:53:45 <stanv> no. there is exercise: How would you define 'not equal' operation /= from equality ==
12:54:32 <trofi> @src Eq
12:54:32 <lambdabot> class  Eq a  where
12:54:32 <lambdabot>     (==), (/=)   :: a -> a -> Bool
12:54:33 <kpreid> stanv: the reason not . (==) doesn't work is that . is for one-argument functions
12:54:37 <Saizan> stanv:  not . (==) doesn't work because (==) takes 2 arguments
12:54:46 <Saizan> ?type (not .) . (==)
12:54:47 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:54:52 <Saizan> that works
12:55:06 <kpreid> Or write \x y -> not (x == y)
12:55:07 <jfoutz> 2 dots! i was so close.
12:55:08 <ezyang> is there a .2?
12:55:24 <stanv> hmmm
12:55:24 <ezyang> (sort of like liftM2, and friends)
12:55:25 <trofi> @pl \x y -> not (x == y)
12:55:25 <lambdabot> (/=)
12:55:28 <kpreid> ezyang: no, but you can define it
12:55:32 <trofi> argh
12:55:36 <kpreid> trofi: heh heh
12:55:41 <ezyang> Ok, just wondering
12:55:42 <kpreid> @pl \x y -> not (x `foo` y)
12:55:42 <lambdabot> (not .) . foo
12:55:49 <stanv> why two dots ?
12:55:50 <trofi> -ETOOSMART
12:55:58 <ezyang> stanv: Think about partial application
12:56:04 * kpreid thinks partially applied (.) is a horror
12:56:12 <jfoutz> hehehe
12:56:13 <trofi> :t (.)
12:56:14 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:56:41 <jfoutz> hrm.
12:56:44 <jfoutz> :t (.) (.)
12:56:45 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
12:56:51 <stanv> :))))
12:57:01 <Saizan> stanv: not . (==) = \x -> not ((==) x) but you want \x y -> not ((==) x y)
12:57:08 <Saizan> the extra dot gets you that
12:58:07 <stanv> Saizan: now clear, thanks :)
13:00:14 <Fairweather> what is good music for haskelling ?
13:00:30 <ezyang> mu
13:00:45 <Cale> http://www.reddit.com/r/programming/comments/9b7gm/first_there_was_twitter_then_flutter_and_shttr/c0c613m
13:00:48 <stanv> quiet
13:02:43 <stanv> so, does I must put three dots if first function takes three arguments ?
13:03:01 <ezyang> :t . . .
13:03:03 <lambdabot> parse error on input `.'
13:03:25 <ezyang> :t (.) (.) (.)
13:03:27 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:03:55 <ezyang> hmm, maybe
13:04:00 <ezyang> :t (.) ((.) (.))
13:04:01 <lambdabot> forall b c a a1 a2. (a2 -> a1 -> b -> c) -> a2 -> a1 -> (a -> b) -> a -> c
13:04:31 <stanv> horror
13:04:37 <ezyang> boobies
13:04:41 <jmcarthur_work> :t let result = (.) in result.result.result
13:04:43 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
13:04:50 <mbrown4> hey
13:05:38 <jmcarthur_work> hey
13:06:06 <mbrown4> can anyone tell me if its better to use public static variables and access them directly from other classes, or to pass variables between classes using functions?
13:06:26 <mbrown4> which is better practice?
13:06:30 <mauke> mbrown4: ECONTEXT
13:06:30 <ezyang> classes?
13:06:30 <benmachine> that doesn't sound like a haskell question
13:07:10 <arw> and anyway, the answer would start with "it depends..."
13:07:59 <ezyang> :t let result = (.) in result.result
13:08:01 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:08:06 <ezyang> hm
13:08:11 <ezyang> :t (.) . (.)
13:08:13 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:08:19 <mauke> fmap fmap fmap
13:08:26 <Fairweather> public variables are bad
13:08:45 <mbrown4> why?
13:08:46 <jmcarthur_work> public variables are bad if they are an abstraction leak
13:08:56 <jmcarthur_work> they are not bad if they fit the intended abstraction
13:08:59 <ezyang> aiyee, I don't understand (.) partial compositoin
13:09:05 <ezyang> (composition)
13:09:16 <Fairweather> how could revealing implementation details fit any abstraction whatsoever?
13:09:28 <mauke> how are public variables an implementation detail?
13:09:40 <Fairweather> well
13:09:52 <jmcarthur_work> Fairweather, what if it just so happens that the variable in question is the intended abstraction *and* happens to be how the class works?
13:09:57 <c_wraith> Fairweather:  the set of 10 properties describing your email server and how to authenticate to it *are* the abstraction.
13:09:58 <Fairweather> "int m_height" is an impl detail
13:10:07 <mauke> no
13:10:09 <Laney> What does other-modules do in a .cabal file? Modules in the source tree that are required for building an executable?
13:10:12 <Fairweather> Get_Height is an abstraction
13:10:23 <jmcarthur_work> Fairweather, in haskell we expose the constructors of data types very often. is this also an abstraction leak?
13:10:25 <Deewiant> Laney: And non-public library modules, IIRC
13:10:34 <Laney> Deewiant: alright
13:10:34 <jmcarthur_work> huh?
13:10:41 <Fairweather> I'm not sure the same logic applies here
13:10:54 <jmcarthur_work> how is a getter any better than a public variable?
13:10:57 <Fairweather> in an imperative language properties are much more useful
13:11:00 <Fairweather> well
13:11:04 <mauke> getter<int> m_height;
13:11:12 <Fairweather> first of all you can add logic
13:11:13 <mauke> except no m_ because it looks stupid
13:11:24 <jmcarthur_work> Fairweather, we are considering the case that you don't need to add logic
13:11:33 <Fairweather> which is wrong
13:11:37 <jmcarthur_work> why?
13:11:38 <c_wraith> There are many cases where logic really doesn't make sense.
13:11:47 <Fairweather> b/c you just don't know what will happen in the future
13:11:48 <c_wraith> The object in question is just a bag of properties
13:12:00 <Fairweather> changing a field to a property is a breaking change
13:12:11 <jmcarthur_work> Fairweather, that depends on how bad your language is
13:12:13 <Fairweather> binary breaking
13:12:13 <arw> Fairweather: there are cases, when adding logic changes semantics, locks for example.
13:12:18 <mauke> Fairweather: what binary?
13:12:39 <monochrom> Is it a troll? Music? Then public fields?
13:12:45 <mauke> note: use of C++ disqualifies you for design discussions
13:12:53 <jmcarthur_work> arguably, there should be no difference, in an OO language, between a getter/setter and a public variable
13:13:19 <jmcarthur_work> on the interface level, that is
13:13:20 <Fairweather> I don't think so
13:13:20 <mkfort> c++ straight warps minds
13:13:40 <arw> jmcarthur_work: yes, but also arguably there is a difference in every much used oo language.
13:13:56 <kyagrd> public variables are good only if they are immutable
13:13:56 <Fairweather> access control is one reason
13:13:57 <jmcarthur_work> arw, i wasn't aware that we were talking about any particular language, though
13:14:10 <Fairweather> ok, let's look at it another way
13:14:16 <jmcarthur_work> Fairweather, access control is another issue
13:14:21 <mauke> is this going to involve werecows?
13:14:32 <mkfort> moo
13:14:53 <arw> jmcarthur_work: correct. but many of those discussions are only sensible, when you talk about the workings of a certain language. often the choice depends on the particular behaviour your language exhibits.
13:15:08 <jmcarthur_work> arw, sure, but still, nobody mentioned a language
13:15:18 <jmcarthur_work> so i'm defaulting to raw OO
13:15:18 <Fairweather> so which one is it then?
13:15:32 <jmcarthur_work> which in my opinion doesn't care about this distinction between properties and functions
13:15:38 <mauke> raw OO is lambda calculus
13:15:54 <jmcarthur_work> great, i started a "what is OO" debate again
13:16:10 <Berengal> Everything is lambda calculus
13:16:14 <Berengal> Even lambda calculus
13:16:20 <monochrom> I want to start a "does OO exist" debate. :)
13:16:21 <jfoutz> no, it's an infinite tape, can be read and written.
13:16:36 <Elly> no, it's a watermelon with a space suit on
13:16:51 <ezyang> fmap fmap fmap is not fmap . fmap . fmap
13:16:52 <monochrom> O_o programming is O_o
13:17:14 <Berengal> monochrom, OO exists, but I'm not certain it's programming
13:17:15 <Fairweather> jmcarthur: no, I thought you asked a very concrete question
13:17:18 <jmcarthur_work> :t fmap fmap fmap `asTypeOf` (fmap . fmap)
13:17:19 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:17:29 <jmcarthur_work> ezyang, ^^ :)
13:17:40 <jmcarthur_work> oh i did it wrong
13:17:48 <jmcarthur_work> ezyang, you are right, not i
13:18:09 <glguy> > (+1) `asTypeOf` (*2)
13:18:11 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:18:11 <lambdabot>    arising from a use of `...
13:18:14 <ezyang> What did asTypeOf do?
13:18:22 <Deewiant> ?src asTypeOf
13:18:22 <lambdabot> asTypeOf = const
13:18:41 <ezyang> ah
13:18:42 <jmcarthur_work> :t asTypeOf
13:18:44 <lambdabot> forall a. a -> a -> a
13:19:11 <jmcarthur_work> ezyang, all it does is return the first argument, attempting to unify its type with that of the second argument
13:19:12 <mauke> :t fmap fmap fmap `asTypeOf` ((.) . (.))
13:19:14 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:19:23 <ezyang> Ok.
13:19:32 <ezyang> Oh duh, fmap on functions is .
13:19:35 <monochrom> If x has a very polymorphic type and y has a very specific type, "x `asTypeOf` y" helps you nail x to the specific type.
13:19:58 <ezyang> Nice
13:20:03 <ezyang> That sounds like it would be very useful
13:20:17 <Berengal> Is it neccessary in the face of ScopedTypeVariables though?
13:20:22 <jmcarthur_work> i don't really use it much besides little lambdabot demos
13:20:22 <c_wraith> @ssrc asTypeOf
13:20:22 <lambdabot> asTypeOf = const
13:20:26 <c_wraith> haha
13:20:43 <monochrom> It is shorter to write.
13:20:48 <glguy> :t const `asTypeOf` asTypeOf
13:20:50 <lambdabot> forall a. a -> a -> a
13:21:00 <c_wraith> :t asTypeOf
13:21:02 <lambdabot> forall a. a -> a -> a
13:21:04 <ezyang> :t const
13:21:05 <lambdabot> forall a b. a -> b -> a
13:21:10 <ezyang> mhmm
13:21:12 <c_wraith> that's what I figured :)
13:21:20 <jmcarthur_work> :t asTypeOf `asTypeOf` asTypeOf `asTypeOf` asTypeOf `asTypeOf` asTypeOf `asTypeOf` asTypeOf `asTypeOf` asTypeOf `asTypeOf` asTypeOf `asTypeOf` asTypeOf `asTypeOf` asTypeOf `asTypeOf` asTypeOf
13:21:22 <lambdabot> forall a. a -> a -> a
13:21:24 <c_wraith> It really just is a type constraint
13:21:32 <mauke> asTypeOf a b = head [a, b]
13:21:45 <monochrom> Its real work is in its type signature. :)
13:21:51 <hackagebot> word24 0.1.0 - 24-bit word and int types for GHC (JohnLato)
13:21:55 <jmcarthur_work> @pl asTypeOf a b = head [a, b]
13:21:56 <lambdabot> asTypeOf = (head .) . (. return) . (:)
13:22:35 <jmcarthur_work> (head .) . (. return) seems like it could have an elegant name
13:22:49 <monochrom> "serve your head on a silver platter"
13:23:23 <monochrom> "If you don't succeed, return with your head on a silver platter"
13:24:06 <benmachine> if you don't succeed you run the risk of failure
13:24:25 <Berengal> It at first you don't succeed, you fail.
13:25:21 <Fairweather> could someone tell me why this doesn't parse: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8290#a8290
13:25:27 <monochrom> do {killDragon; (<3) `mplus` (head .) . (. return)} = If you kill the dragon, the princess will marry you; if not, return with your head on a silver platter.
13:25:40 <ezyang> more indentation on both?
13:25:55 <ezyang> are you syntax error'ing or type error'ing
13:25:58 <Fairweather> it dies onaha
13:26:04 <Fairweather> ...
13:26:06 <Fairweather> sry
13:26:17 <Berengal> Fairweather, indentation. Indent line 3
13:26:31 <Fairweather> ok, now it dies on =
13:26:48 <monochrom> There are three ='s.
13:26:50 <ezyang> Line up count and both
13:27:04 <mauke> define "dies"
13:27:08 <Berengal> Also, Nothing, not nothing
13:27:11 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8290#a8291
13:27:14 <Berengal> (unless you've defined nothing)
13:27:22 <Fairweather> ok, thanks
13:27:28 <ezyang> There are numerous other errors, but syntax wise...
13:27:38 <Fairweather> ezyang, i'm all ears
13:27:59 <ezyang> ==Berengal
13:28:32 <ezyang> oh, I don't have your imports
13:28:57 <Fairweather> :) thanks anyhow
13:29:04 <jfoutz> L is lazy byte string. that should be fine. the nothing to Nothing change looks like it :)
13:29:18 <ezyang> yep
13:29:42 <jfoutz> you might line up the if then and else. you don't have too, but lots of code like that does.
13:30:05 <jmcarthur_work> technically the current if-then-else indentation is more correct, i think
13:30:23 <jfoutz> oh, then i do if then else wrong often. :)
13:30:40 <jmcarthur_work> emacs does it wrong :(
13:31:02 <jmcarthur_work> i think the main reason is if you have an if in do notation
13:31:24 <Berengal> Didn't they change that?
13:31:30 <jmcarthur_work> i dunno
13:31:34 <jfoutz> oh, that makes sense.
13:32:08 <Berengal> I thought that was what non-decreasing indentation was mainly about
13:32:21 <Berengal> But I can't say I've encountered it...
13:32:27 <Cale> if foo
13:32:27 * Berengal doesn't use if that much
13:32:29 <Cale>    then bar
13:32:31 <Cale>    else quux
13:32:47 <Berengal> if foo then bar else quux
13:33:00 <Berengal> Or: if' foo bar quux
13:33:52 <jfoutz> what does the O(n\c) mean in the lazy bytestring docs? n under a constant?
13:35:17 <jmcarthur_work> jfoutz, i think c is the number of chunks
13:35:30 <c_wraith> but what operator is "\"?
13:35:43 <jmcarthur_work> not a clue
13:35:56 <jmcarthur_work> ah i see
13:36:00 <jmcarthur_work> the source has /O(n\/c)/
13:36:04 <c_wraith> oh
13:36:09 <jmcarthur_work> the \ was an attempt to escape a /
13:36:12 <jmcarthur_work> and it failed
13:36:19 <c_wraith> oops
13:36:39 <Philonous> jfoutz: I've written some code that allows you to differentiate functions of type (Num a,b,c,... => a -> b -> c -> ...) without explicitly having to introduce tagged Variables: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3359#a3359 I think it is even possible to write functions like jacobian and hessian that automatically creates those matrices in the right dimension according to the arity of your function.
13:36:55 <jmcarthur_work> not sure if that is a haddock bug or not
13:38:01 <jmcarthur_work> oh
13:38:07 <jmcarthur_work> maybe it was an escape for /
13:38:14 <jmcarthur_work> maybe that was supposed to be "or"
13:38:23 <jmcarthur_work> O(n \/ c)
13:38:33 <Philonous> jfoutz: Example code: "d 1 $ diff (\x y -> x^^2 + y^^2 ) 2 3" gets evaluated to 6
13:38:40 <jfoutz> Philonous: that's really great stuff. reading my old post is embarrasing. you should put in on hackage :)
13:38:43 * jmcarthur_work looks at what the function actually *does* now
13:39:13 <Philonous> jfoutz: It's still basically your idea.
13:39:54 <jfoutz> it was Karczmarczuk's idea, i just fleshed it out.
13:42:52 <jfoutz> getting rid of the extra variables is slick.
13:42:57 <jmcarthur_work> okay, i see now
13:50:36 <jfoutz> empty intmaps for constants is cool. i was right at my limits with the first cut.
14:13:55 <mux> Cale: Data.MemoCombinators is very nice indeed :-)
14:15:48 <ezyang> Can I golf this any further?
14:15:50 <ezyang> > let f (a, b) = (a - b - 2) ** 2 in sum $ map f $ zip [3,4,5] [1,1,1]
14:15:52 <lambdabot>   5.0
14:16:03 <ezyang> (the -2, [3,4,5] and [1,1,1] are inputs)
14:16:39 <mux> Cale: without all those STArray's, the code is maybe 1/4 the size and it's actually very slightly faster it seems :-P
14:16:41 <jmcarthur_work> @pl sum . map (\(a, b) -> (a - b - 2) ** 2) . zip
14:16:42 <lambdabot> sum . map (uncurry (flip flip 2 . ((**) .) . flip flip 2 . ((-) .) . (-))) . zip
14:16:47 <jmcarthur_work> not like that
14:16:52 <ezyang> muf
14:17:03 <jmcarthur_work> :t sum . map (\(a, b) -> (a - b - 2) ** 2) . zip
14:17:05 <lambdabot>     Couldn't match expected type `[(t, t)]'
14:17:05 <lambdabot>            against inferred type `[b] -> [(a, b)]'
14:17:05 <lambdabot>     In the second argument of `(.)', namely `zip'
14:17:13 <jmcarthur_work> oh i done it wrong
14:17:20 <mauke> zipWith
14:17:38 <ezyang> ooh, excellent
14:17:43 <gOcOOl> hi, I'm an Haskell newbie and was wondering why functional languages like haskell choses not to implement loops the traditional way that a procedural language does, in other words what functional programming paradigm does the for loop violate?
14:17:46 <jmcarthur_work> ha yeah
14:17:56 <mauke> gOcOOl: no mutable variables
14:18:08 <jmcarthur_work> gOcOOl, a loop would be meaningless because we can't change anything
14:18:16 <ezyang> > sum . zipWith (\a,b -> (a - b - 2) ** 2) [1,2,3] [4,5,6]
14:18:17 <mauke> actually, we have foreach loops
14:18:17 <lambdabot>   <no location info>: parse error on input `,'
14:18:18 <benmachine> gOcOOl: it's an odd question to ask; why would you need a loop structure?
14:18:33 <jmcarthur_work> gOcOOl, and anyway, recursion is not the ultimate goal. we actually prefer to use higher level combinators like maps and folds
14:19:09 <benmachine> functional programming languages have little need for loop structures
14:19:30 <ezyang> sum $ zipWith (\a b -> (a - b - 2) ** 2) [1,2,3] [4,5,6]
14:19:33 <ezyang> > sum $ zipWith (\a b -> (a - b - 2) ** 2) [1,2,3] [4,5,6]
14:19:34 <lambdabot>   75.0
14:19:37 <ezyang> whoo
14:20:02 <jmcarthur_work> @pl \a b -> (a - b - 2) ** 2
14:20:02 <lambdabot> flip flip 2 . ((**) .) . flip flip 2 . ((-) .) . (-)
14:20:09 <mauke> ezyang: ^ 2 is shorter than ** 2
14:20:09 <jmcarthur_work> that is so gross
14:20:31 <ezyang> oh, and it's better precision too
14:21:47 <Deewiant> ?pl \a b -> join (*) (a - b - 2)
14:21:48 <lambdabot> (join (*) .) . flip flip 2 . ((-) .) . (-)
14:22:13 <ezyang> What does ?pl do?
14:22:32 <MyCatVerbs> ezyang: transforms an expression into "point free" form.
14:22:39 <ezyang> ahh
14:22:57 <MyCatVerbs> ezyang: That is where it doesn't have any named parameters in it - it's all just function composition.
14:23:10 <ezyang> Yup. It also looks kinda gross :-)
14:23:15 <Philonous> I wish there was a class of all types that are not functions. That would make type-recursive programming that much easier.
14:23:19 <Warrigal_> Is there a cute little program or something that tries to disprove hypotheses written in Haskell?
14:23:35 <MyCatVerbs> ezyang: Well, yes. *Some* functions become much prettier when you put them into pointfree form, though.
14:23:35 <ezyang> Warrigal_: Quickcheck?
14:23:49 <Warrigal_> @check \x -> x /= 3.14159
14:23:51 <lambdabot>   "OK, passed 500 tests."
14:24:01 <MyCatVerbs> ezyang: the fact that the process of making them pointfree is automated means that you can just try it and see whether it turns out to be a good idea or not in your case. :)
14:24:04 <Warrigal_> Like Quickcheck, but not stupid.
14:24:11 <ezyang> MyCatVerbs: Hehe
14:24:40 <Warrigal_> Not a genius, of course, but it doesn't take much intelligence to look at that and see that 3.14159 will not match.
14:25:11 <ezyang> Mm, that's missing the point of QuickCheck
14:25:28 <MyCatVerbs> Warrigal_: QuickCheck won't do that, no. In general, what you're asking is a really really hard problem.
14:26:18 <MyCatVerbs> Warrigal_: IIRC people have written programs to do roughly that kind of thing to C programs, but I don't know of anything like that for Haskell. There might be, though, just because it's such an interesting problem. :)
14:26:19 <jmcarthur_work> > sum $ zipWith (((.).(.)) ((^2) . subtract 2) (-)) [1,2,3] [4,5,6]
14:26:20 <lambdabot>   75
14:26:45 <ezyang> There should really be a combinator for (.).(.)
14:26:50 <jmcarthur_work> where (.).(.) could be made more readable with result = (.), turning it into (result.result)
14:26:53 <Warrigal_> @type (.).(.)
14:26:55 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:27:11 <jmcarthur_work> ezyang, you should read conal's stuff on semantic editor combinators
14:27:18 <MyCatVerbs> Warrigal_: I think I remember reading a paper about a (Haskell|ML, can't remember which) program a team wrote that generated inputs to exercise all the code paths in a given body of C code. They were using it to find crash bugs in filesystem code (and they did find a reasonable quantity).
14:27:38 <Warrigal_> Perhaps I could fiddle up a little Haskell algebra thingy that tries to disprove stuff.
14:27:47 <jmcarthur_work> ezyang, http://conal.net/blog/posts/semantic-editor-combinators/
14:28:16 <pcc1> I have a 3.3MB (generated!) .hs file which takes ~15 minutes to compile using ghc.  would splitting the file up improve the compilation time?
14:28:23 <copumpkin> Warrigal_: you could use my enumerable library to exhaustively search the domain :P
14:28:34 <jeffersonheard> Is there a remotely attachable debugger for GHC?
14:28:41 <jmcarthur_work> pcc1, dang!
14:28:48 <Warrigal_> copumpkin: I'll do that once someone comes up with an instance Enumerable String. :-)
14:28:57 <copumpkin> Warrigal_: I already have one
14:29:03 <copumpkin> :P
14:29:16 <Warrigal_> How does it do on the hypothesis \x -> length x /= 1000000000?
14:29:30 <copumpkin> it'd take a while to decide ;)
14:29:58 <idnar> @type (.)(.)(.)
14:30:00 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:30:19 <idnar> the Eccentrica Gallumbits operator?
14:30:35 <pikhq> Hey, it does something useful.
14:30:37 * MyCatVerbs thwaps idnar upside the head.
14:30:51 <Makoryu> pcc1: Probably. Moving functions across module boundaries will mean the type checker doesn't have to do nearly as much work
14:31:48 <MyCatVerbs> Yes, but the functions you pass it don't actually get applied until four miles from the actual expression.
14:32:02 <pcc1> Makoryu: yes, that is what I suspected.  but all of the functions have type signatures.  would it still help?
14:32:08 <MyCatVerbs> Well. Prefect disputes that, claming five.
14:32:24 <fbru02> hey i missed the boat , what does (.).(.) do ?
14:32:36 <jmcarthur_work> fbru02, (.).(.) f g x y = f (g x y)
14:32:43 <pikhq> fbru02: The type signature should make it obvious.
14:32:44 <Makoryu> pcc1: There's the question I didn't ask... Honestly, without knowing what's in the file, it's hard to sya.
14:32:46 <Makoryu> *say
14:33:10 <idnar> MyCatVerbs: haha
14:33:17 <Philonous> Why can't I "instance PipeAll (Diff a) r where type FunType (Diff a) = r" ? ghc says "Not in scope: type variable `r'", but why is that?
14:33:19 <Warrigal_> I was going to come up with a fancy nifty doodad that would use scientific methods to explore mathematical stuff.
14:33:25 <Makoryu> :t (unlines .) . (. lines)
14:33:26 <lambdabot> ([String] -> [String]) -> String -> String
14:33:45 <jmcarthur_work> Makoryu, i call that one withLines
14:33:52 <Makoryu> jmcarthur_work: Me too
14:34:01 <Saizan> Philonous: only the variables that appear in the arguments are in scope
14:34:22 <Philonous> Ah, snap. Thanks.
14:34:26 <pcc1> Makoryu: hm, guess I'll try to see if it helps. thanks
14:34:50 <Makoryu> pcc1: All I can say is good luck x_x
14:35:40 <ezyang> pcc1: What are you doing?
14:35:48 <kscaldef_> So, I know that ghci can accept file names to load on the command line.  Is there someway to tell it to load _and_ run the file, all in one go?  Or is there some other util that does that?
14:36:01 <Makoryu> pcc1: I'm curious to know what this monster file is generated from, by the way
14:36:39 <Berengal> kscaldef, runhaskell
14:36:47 <Berengal> kscaldef, but you won't get interactivity
14:37:21 <Makoryu> kscaldef_: You can always just type "main" at the ghci prompt....
14:37:25 <pcc1> the file is essentially a wrapper around a bunch of C functions (which themselves wrap a compiler library in C++).  it contains marshaling and demarshaling code, as well as the function imports
14:37:32 <kscaldef_> I don't want interactivity
14:37:40 <kscaldef_> Berengal: thanks, that's what I was missing
14:37:47 <pcc1> the file is generated from the library's C++ headers
14:37:48 <MyCatVerbs> kscaldef_: then runhaskell is exactly what you want. :)
14:38:14 <MyCatVerbs> kscaldef_: oh, and just in case you want to use a specific Haskell interpreter - GHC installs runghc, Hugs installs runhugs, etc.
14:38:19 <idnar> @src foldl1
14:38:20 <lambdabot> foldl1 f (x:xs) = foldl f x xs
14:38:20 <lambdabot> foldl1 _ []     = undefined
14:38:32 <Makoryu> pcc1: That sounds like madness :|
14:38:40 <ezyang> It sounds fairly common
14:38:49 <jmcarthur_work> pcc1, what did you use to generate this? something home grown?
14:38:49 <ezyang> I always get annoyed by autogenerated wrappers, though
14:39:50 <jmcarthur_work> pcc1, oh neverming
14:39:51 <pcc1> jmacarthur_work: yes, something home grown, based on the compiler library I am wrapping, called ROSE http://rose-compiler.org
14:39:53 <Makoryu> jmcarthur_work: Once you've got plain C headers, it should be trivial to run c2hs on them
14:39:53 <jmcarthur_work> *nevermind
14:40:03 <jmcarthur_work> i thought you were doing it straight from c++
14:40:04 <jmcarthur_work> i misread
14:40:36 <Makoryu> pcc1: Curiously, I can't access that site
14:40:56 <jeffersonheard> is there a tool out there for comparing two heap profiles?
14:41:06 <pcc1> sorry http://rosecompiler.org
14:41:41 <jmcarthur_work> ha, BONUS will find this fun (he probably already knows about it) http://learnyousomeerlang.com/
14:41:55 <Philonous> Type level programming is fun, but sometimes it makes my head explode.
14:42:08 <monochrom> Hahaha
14:42:12 <pikhq> jmcarthur_work: Eeeew.
14:42:31 <Makoryu> jmcarthur_work: Did BONUS write LYAH? (I'm not a regular here and don't know who's who for the most part)
14:42:42 <jmcarthur_work> Makoryu, yes
14:42:42 <monochrom> Fun intellectual activities make your head explode. That is why they are fun.
14:42:43 <pikhq> Makoryu: Yes
14:43:12 <monochrom> (Watching TV on weekends is not fun and does not make your head explode, for example.)
14:43:38 <Philonous> Oh, watching TV makes my head explode all right, but for entirely different reasons.
14:43:55 <Philonous> (Or maybe implode, in this case)
14:43:57 <monochrom> Your head is just a bomb.
14:44:14 <Warrigal_> My favorite way of exploding my head is trying to figure out how to explode-proof my head.
14:44:41 <fbru02> Makoryu : how can i test (unlines .) . (. lines) ?
14:46:08 <Makoryu> fbru02: let withLines = (unlines .) . (. lines) in withLines (map reverse) "sihT\ndluohs\nod\nti\n"
14:46:14 <Makoryu> > let withLines = (unlines .) . (. lines) in withLines (map reverse) "sihT\ndluohs\nod\nti\n"
14:46:16 <lambdabot>   "This\nshould\ndo\nit\n"
14:46:25 <Warrigal_> > ((unlines .) . (. lines)) tail "There once was a man from Nantucket\nWho kept all his wealth in a bucket\nUnfortunately\nI myself cannot see\nA good way to end this limerick."
14:46:27 <jmcarthur_work> @check \str -> ((unlines .) . (. lines)) str == str
14:46:27 <lambdabot>   "Who kept all his wealth in a bucket\nUnfortunately\nI myself cannot see\nA...
14:46:29 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:47:05 <jmcarthur_work> i actually don't know if that is supposed to hold anyway
14:47:13 <Makoryu> jmcarthur_work: It isn't.
14:47:20 <Makoryu> jmcarthur_work: It takes a function. Try id
14:47:22 <monochrom> (unlines .) . (. lines) expects a function and a string. Not just a string.
14:47:37 <Makoryu> @let withLines = (unlines .) . (. lines)
14:47:39 <lambdabot>  Defined.
14:47:40 <fbru02> Makoryu: thanks  ! :)
14:47:57 <monochrom> Example.  ((unlines .) . (. lines)) f xs = (unlines . f . lines) xs
14:48:04 <Makoryu> @check \str -> withLines (map id) str == str
14:48:06 <lambdabot>   Not in scope: `withLines'
14:48:09 <Makoryu> >:|
14:48:15 <monochrom> Try L.withLines
14:48:47 <monochrom> @unpl ((unlines .) . (. lines)) f
14:48:47 <lambdabot> (\ i -> unlines (f (lines i)))
14:49:30 <Makoryu> @check \str -> L.withLines (map id) str == str
14:49:31 <lambdabot>   Not in scope: `L.withLines'
14:49:43 <monochrom> Then that's unfortunate.
14:50:24 <Makoryu> > putStr $ map chr [175,92,79,95,111,47,175]
14:50:26 <lambdabot>   <IO ()>
14:50:59 <pikhq> Makoryu: What, you think it's actually going to *perform* that action?
14:51:07 <pikhq> ;)
14:51:16 <monochrom> > map chr [175,92,79,95,111,47,175]
14:51:17 <lambdabot>   "\175\\O_o/\175"
14:51:21 <Makoryu> pikhq: Hey, you never know....
14:51:29 <monochrom> > text (map chr [175,92,79,95,111,47,175])
14:51:31 <lambdabot>   ¯\O_o/¯
14:51:45 <pikhq> :t text
14:51:47 <lambdabot> String -> Doc
14:51:53 <leithaus> does anyone know if there's a Haskell implementation of Haghverdi's linear combinators lying around?
14:51:59 <pikhq> @src Doc
14:52:00 <lambdabot> Source not found. Take a stress pill and think things over.
14:52:09 <monochrom> Pretend it's a substitute for putStr!
14:52:18 <pikhq> @faq Can Haskell do Haghverdi's linear combinators?
14:52:19 <lambdabot> The answer is: Yes! Haskell can do that.
14:52:27 <Makoryu> monochrom: Hah, I'll keep that in mind
14:52:51 <leithaus> is there a faq on that?
14:53:02 <monochrom> Doc is probably some nice abstract type whose Show instance does the right thing as opposed to giving you escape sequences. (Show for String gives you escape sequences.)
14:53:12 <Makoryu> @faq
14:53:13 <lambdabot> The answer is: Yes! Haskell can do that.
14:53:25 <Makoryu> leithaus: It's not a very helpful FAQ.
14:54:17 <monochrom> Doc is also probably also Text.PrettyPrint.HughesPJ.Doc
14:54:18 <Stinger> @faq can Haskell steal your soul
14:54:19 <lambdabot> The answer is: Yes! Haskell can do that.
14:55:14 <leithaus> where does one look for the faq?
14:55:15 <pikhq> @faq Can Haskell solve the halting problem?
14:55:16 <lambdabot> The answer is: Yes! Haskell can do that.
14:55:51 <monochrom> There is no FAQ.
14:55:57 <Stinger> @faq can haskell prove P=NP
14:55:57 <leithaus> @faq Can Haskell faq you?
14:55:57 <lambdabot> The answer is: Yes! Haskell can do that.
14:55:58 <lambdabot> The answer is: Yes! Haskell can do that.
14:56:10 <leithaus> got it
14:56:18 <pikhq> @. faq faq
14:56:19 <lambdabot> The answer is: Yes! Haskell can do that.
14:56:37 <idnar> fix faq
14:56:44 * osfameron notes that the livecoding music guy is now doing it in Haskell instead of Perl
14:56:51 <pikhq> Clearly, it can compose faq and faq.
14:57:24 <cwraith> faq is just (const "Yes! Haskell can do that.").  as such, fix of it isn't very interesting
14:57:27 <leithaus> self faq-ulation is not advisable -- it makes you drop the soap in the shower
14:58:03 <Cale> osfameron: mm... while I know who you're probably talking about, there are a fair number of people who do livecoding of music ;)
14:58:26 <osfameron> well, specifically http://www.londonhug.net/2009/08/18/next-meeting-alex-mclean-live-coding-music-with-haskell/
14:58:37 <osfameron> I remember he did an article on perl.com back in the day about it
14:58:43 <Cale> Yeah, that's who I was thinking of too :)
14:59:08 <Cale> I've only seen his Haskell stuff.
14:59:26 <osfameron> it sounded crazy at the time.  It feels like haskell would be a better fit for what I remember about it
14:59:50 <jmcarthur_work> Makoryu, oh of course you're right. i'm just being dumb
15:00:56 <Cale> I wonder if that meeting was recorded.
15:01:08 <Cale> er, will be recorded rather :)
15:03:27 <osfameron> @faq can Cale travel forward in time to hear the livecoding talk recording?
15:03:27 <lambdabot> The answer is: Yes! Haskell can do that.
15:03:29 <osfameron> yay!
15:03:41 <monochrom> We can all travel forward in time.
15:03:55 <MyCatVerbs> At a rate of ONE SECOND per SECOND, approximately.
15:04:11 <monochrom> We just won't live to come back and tell the story.
15:04:33 <jmcarthur_work> 1s/s = 1
15:05:23 <benmachine> we don't travel in time, we merely perceive such a journey as a consequence of the function of memory!!
15:05:49 <Makoryu> Y'know, every so often I hear of this wonderful language called Clean that solves world hunger and comes with a set of steak knives
15:07:09 <jmcarthur_work> i've not really heard any negatives about it, although i'm sure a few here could give some
15:07:56 <Cale> Makoryu: Clean is very similar to Haskell. The only differences are that it has support for uniqueness typing, a different way of handling IO, and lack of most of the new features in Haskell since the rather early versions of it. If I recall correctly, the support for typeclasses is also severely limited.
15:08:13 <Cale> (no contstructor classes maybe?)
15:08:16 <Makoryu> It seems to have its fans, but a quick glance over the mailing list makes it obvious that the authors are very dedicated to Haskell's own "avoid success at all costs" motto
15:08:16 <Cale> constructor*
15:08:36 <pikhq> Makoryu: Perhaps more so than Haskell.
15:08:46 <pikhq> (Haskell seems to actually be successful. ;))
15:08:54 <kyagrd> Cale: I remember that Clean also support specifying sharing by graph rewriting
15:08:58 <Makoryu> Cale: Yeah, it doesn't seem to have developed at all since the 1990s
15:09:58 <Makoryu> pikhq: The Haskell community is clearly not all that dedicated to the motto, yes :p
15:10:33 <Cale> Which is sad. We need to be more dedicated to not advertising. Teach the beginners, yes, but don't get the word out. Trade secret. ;)
15:10:55 <pikhq> Screw advertising. Let's just take over the world.
15:11:02 * pikhq rewrites Linux in Haskell
15:11:05 <jmcarthur_work> our success has already stifled out innovation, IMO
15:11:19 <copumpkin> how so?
15:11:30 <jmcarthur_work> we are too afraid to make backward incompatible changes to the spec, now
15:11:47 <copumpkin> I really hope haskell' makes big sweeping changes even though I know it won't
15:12:14 <pikhq> copumpkin: Like... Sexp syntax? :P
15:12:20 <copumpkin> lol
15:12:26 <syntaxglitch> Haskell is too successful because there are too many blog posts explaining monads now
15:12:30 <copumpkin> I want dem dam typeclasses fixed
15:12:31 <syntaxglitch> it needs something else to scare everyone away
15:12:32 <copumpkin> :P
15:12:45 <pikhq> syntaxglitch: Arrows.
15:13:00 <pikhq> Can we use arrows as an abstraction for IO instead?
15:13:09 <pikhq> >:D
15:13:17 <jmcarthur_work> i'm looking to some of the new dependently typed languages for the "avoid success at all costs" philosophy now
15:13:25 <copumpkin> jmcarthur_work: agda seems nice
15:13:48 <jmcarthur_work> copumpkin, i actually disagree, so far, but it's what i'm mostly looking at because i think it has a lot of potential
15:14:02 <copumpkin> you don't think it's nice?
15:14:04 <jmcarthur_work> it's just unpolished, so far, is all
15:14:15 <copumpkin> ah yes
15:14:28 <copumpkin> lol someone just set off the alarm
15:14:29 <jmcarthur_work> and it seems that there is still a lot of debate over some core calculus issues and everything, too
15:14:45 <Philippa> yeah, that's the tradeoff: you only get so much polish before you've got too big a userbase
15:14:50 <jmcarthur_work> but i guess that's just one of the constant improvement things
15:15:24 <copumpkin> I'm gonna move upstairs and see if anyone's here yet
15:15:26 <copumpkin> bbl
15:17:43 <Philonous> jfoutz: it works! : *Main> hessian (\x y -> x^^3*y+y*x) 2 3 \\ [[36.0,13.0],[13.0,0.0]]
15:18:05 <jfoutz> congradulations! that's really cool.
15:19:10 <nyingen> syntaxglitch: Haskellers should adopt more of the C++ philosophy. Snobbery over ridiculously complicated language features, weird unsafe code that we refuse to explain to the non-elite, etc :)
15:19:34 <jmcarthur_work> yes, we are clearly too friendly here
15:19:46 <ahf> haha
15:19:55 <syntaxglitch> I prefer weird safe code that people do explain, but the non-elites can't understand :P
15:19:58 <monochrom> copumpkin is constantly improving his position by one stair up. :)
15:20:57 <monochrom> We can do snobbery over ridiculously mathematical-logical expositions and habits.
15:21:40 <monochrom> "Hi how do I write a function for ___ ?"  "Start with this formali specification ____. Now we calculate: ___"
15:22:53 <pikhq> Clearly we should do all our monad coding with return and join.
15:23:16 <nyingen> Yeah, but we still don't have anything like the "what are you, a Pascal programmer? Obviously you need to declare that destructor 'protected abstract virtual base pure virtual private'"
15:23:17 <monochrom> "Hi I'm learning map f xs."  "You can prove it using bisimulation."
15:23:55 <pikhq> nyingen: That's because we don't do type declaration.
15:23:59 <Makoryu> :t join . return
15:24:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
15:24:19 <pikhq> It's monadic ID!
15:24:25 <pikhq> Erm. id.
15:24:37 <shachaf> @ty fix . return
15:24:39 <lambdabot> forall a. a -> a
15:24:56 <jmcarthur_work> :t (return <=<)
15:24:58 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> a -> m b
15:25:06 <jmcarthur_work> :D
15:25:18 <pikhq> Yes, yes, you can do <<= with <=<
15:25:24 <nyingen> I did like 'liftM8 Foo get get get get get get get get' (with Data.Binary)
15:25:35 <nyingen> made me do a double-take first time I saw such code
15:25:39 <monochrom> Try "what are you, an English major? Obviously you need to write specifications like ∀x∃y..."
15:25:40 <jmcarthur_work> that's beautiful!
15:25:51 <pikhq> nyingen: Gorgeous.
15:26:04 <jmcarthur_work> yes, we should start writing our code in raw System F notation
15:26:05 * benmachine blinks
15:26:39 <jmcarthur_work> well, our explanations of the code
15:26:42 <jmcarthur_work> it's clearer that way
15:26:44 <Phillemann> I've got an action "IO String" and an action "IO [String]". I want to lift the (:) function into IO. Just doing liftM (:) foo bar doesn't work here. :/
15:27:00 <benmachine> @type ap
15:27:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:27:07 <jmcarthur_work> Phillemann, liftM2
15:27:09 <benmachine> wait no
15:27:15 <benmachine> yeah
15:27:18 <Phillemann> benmachine: I tried that, actually...
15:27:24 <jmcarthur_work> ap can work as well
15:27:28 <Phillemann> Ah yes, liftM2 makes sense...
15:27:38 <jmcarthur_work> in a different way
15:27:51 <jmcarthur_work> liftM (:) `ap` foo `ap` bar
15:27:58 <jmcarthur_work> err
15:28:08 <Makoryu> > liftM (:) `ap` foo `ap` bar
15:28:10 <lambdabot>   Not in scope: `foo'Not in scope: `bar'
15:28:10 <Phillemann> Hmmm, what's the correct word for lifting something. Do you lift "onto", "into", ...?
15:28:11 <pikhq> jmcarthur_work: That looks a lot like liftM2. :)
15:28:16 <jmcarthur_work> pikhq, right
15:28:19 <monochrom> return (:) `ap` foo `ap` bar
15:28:22 <jmcarthur_work> i was just showing both ways
15:28:32 <jmcarthur_work> monochrom, that
15:28:35 <Makoryu> Phillemann: Into.
15:28:35 <monochrom> Also known as (:) <$> foo <*> bar
15:28:42 <jmcarthur_work> yay Applicative
15:29:42 <jmcarthur_work> and with conor's she preprocessor:  (| foo:bar |)
15:29:43 <jmcarthur_work> :)
15:29:45 <twanvl> or for people who are into emoticons: foo <^(:)^> bar
15:29:45 <monochrom> When in doubt, just say "lift to".
15:30:17 <monochrom> hahaha
15:30:23 <benmachine> if you say liftM to though that could fo wrong
15:31:56 <monochrom> Natural language sucks anyway.
15:33:38 <pr> @type ap
15:33:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:33:45 <pr> @type (<*>)
15:33:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:34:03 <monochrom> ap and <*> are very similar.
15:34:22 <monochrom> A monad has ap and <*> being the same.
15:34:52 <Makoryu> dons: By the way, how does your sonic screwdriver work?
15:35:17 <monochrom> (Perhaps you sing and the screwdriver dances.)
15:35:56 <monochrom> (Perhaps do it the stereotypical Indian way: you play a flute and the screwdriver does tricks!)
15:37:38 <monochrom> (The Sonic Screwdriver Platform: Flute included)
15:49:03 <aavogt> @where she
15:49:03 <lambdabot> I know nothing about she.
15:49:38 <enolan> http://personal.cis.strath.ac.uk/~conor/pub/she/
15:49:41 <enolan> @help where
15:49:42 <lambdabot> where <key>. Return element associated with key
15:49:51 <enolan> how do I add to it?
15:49:53 <enolan> @help where+
15:49:54 <lambdabot> where+ <key> <elem>. Define an association
15:50:03 <enolan> @where+ she http://personal.cis.strath.ac.uk/~conor/pub/she/
15:50:03 <lambdabot> Done.
15:51:31 <olsner_> "You should make sure, because she won't." ... makes you wonder if such constructs wasn't the whole reason for chosing that name :P
15:52:01 <aavogt> @where she
15:52:02 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
15:52:10 <aavogt> good
15:52:54 <m3ga> darcs question: how do i convert a repo using HashedPristine to PlainPristine?
15:54:23 <olsner_> hehe, "Once she's installed, you should find that she's executable."
15:54:49 <olsner_> hilarious! she is something I must try
15:55:02 <fbru02> does the learning in haskell never end ? :(
15:55:58 <jmcarthur_work> fbru02, no
15:56:06 <olsner_> fbru02: hopefully not :D
15:56:40 <fbru02> so what if you are perfectionist , you go mad ? there's always a better way to do what you just wrot
15:56:41 <fbru02> e
15:57:41 <syntaxglitch> perfection cannot be attained, only approached asymptotically
15:57:57 <enolan> All of #haskell is mad :)
15:58:27 <Makoryu> fbru02: You don't go mad... You merely reach satori
15:59:03 <syntaxglitch> the Haskell that is understood is not the true Haskell.
15:59:06 <jmcarthur_work> fbru02, it's true. there is always a better way
15:59:33 <fbru02> Makoryu: :)
16:02:09 <fbru02> the only thing i read from combinatory calculus is how to mock a mockingbird, that is clearly not enough here right?
16:03:49 <natural_one> is parsec suitable for parsing whitespace-sensitive grammars (e.g., python)?
16:04:05 <jmcarthur_work> should be
16:04:11 <jmcarthur_work> i've not done it though
16:04:36 <kulakowski> One would sort of hope, since haskell has layout
16:04:42 <natural_one> hints?  gotchas?  examples?  i'm lost.
16:05:07 <Cale> I think that in order to parse whitespace-sensitive grammars, you probably want to do the whitespace as a separate pass
16:05:25 <arw> well, haskell also has curly braces for easier parsing...
16:05:36 <Cale> Insert tokens indicating the start and end of blocks according to the layout, and then parse what's left normally.
16:05:50 <Makoryu> The whitespace pass in Haskell comes before the actual parse
16:05:51 <inimino> natural_one: indeed, typically a lexer will translate the whitespace into 'indent' and 'dedent' tokens or something of that nature
16:05:58 <Makoryu> IIRC
16:06:28 <arw> btw, is there a way to ask a haskell compiler for the non-layout form of some code?
16:06:42 <natural_one> i think i need to read some more.  thanks, folks.
16:07:10 <jmcarthur_work> @undo do x <- [1..3] ; y <- [4..6] ; return (x+y)
16:07:10 <lambdabot> [1 .. 3] >>= \ x -> [4 .. 6] >>= \ y -> return (x + y)
16:07:13 <Cale> natural_one: If you want to do it the way Haskell does it, the Haskell report has a fairly detailed description of the algorithm.
16:07:17 <jmcarthur_work> only for do, but...
16:07:32 <mmorrow> natural_one: the haskell rules are explicitly given in the haskell98 report
16:07:55 <Cale> natural_one: Essentially, there are certain keywords (let, do, of, where) for which the next non-whitespace character following them sets the indentation for a block.
16:07:57 <Makoryu> @undo atomically $ do stuff; x <- moreStuff; foo
16:07:57 <lambdabot> atomically $ stuff >> moreStuff >>= \ x -> foo
16:08:09 <natural_one> i'm interested in parsing a language that's similar to python but without keywords.
16:08:22 <mmorrow> (personally the method of inserting tokens/etc given in their horrified me)
16:08:23 <mmorrow> :)
16:08:29 <mmorrow> *there
16:08:35 <skorpan> couldn't that be written better as: atomically $ stuff >> moreStuff >> foo
16:09:03 <Makoryu> skorpan: I was just writing asemic garbage
16:09:16 <skorpan> Makoryu: yes, but i'm talking about lambdabot's "simplification"
16:09:22 <skorpan> it could have been smarter i think
16:09:26 <Makoryu> skorpan: True
16:09:59 <skorpan> :t mystery
16:10:01 <lambdabot> Not in scope: `mystery'
16:10:09 <skorpan> what happened to the mystery function?  was that a temporary thing?
16:10:11 <mmorrow> natural_one: i'm not sure what python's layout rules are, but how haskell lexers usually handle it is to have a stack of contexts they carry around, and they push one when they enter/pop on exit
16:10:36 <Cale> skorpan: what did it do?
16:11:00 <Cale> skorpan: Chances are that someone defined it with @let and later someone did an @undefine which cleared everything out
16:11:55 <mmorrow> @. pl undo atomically $ do stuff; x <- moreStuff; foo
16:11:55 <lambdabot> atomically (stuff >> moreStuff >>= const foo)
16:12:07 <Makoryu> mmorrow: Python only keeps track of the amount of indentation for each block. A line indented more than the current block starts a new block; a line indented less has to match a recorded indentation level, or that's an error
16:12:27 <Makoryu> mmorrow: And there's no layout-less version of any Python code.
16:12:31 <skorpan> Cale: that was the trick, we were to figure out what it did... no one seemed to know.
16:12:59 <Cale> skorpan: Did it have a sensible type?
16:13:55 <skorpan> Cale: iirc the type made me think it used unsafePerformIO, i.e. something along the lines of IO a -> a, but i can't remember for sure
16:14:16 <skorpan> the others seemed inclined to believe it was *not* using unsafePerformIO, since lambdabot normally doesn't do IO
16:14:16 <vav> skorpan: iirc mauke got it. could spider the logs, don't remember who wrote it but think it was simply math
16:14:19 <olsner_> @ty (\x y -> x >>= const y)
16:14:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
16:14:27 <Cale> Oh, in that case, it probably was const undefined, or undefined
16:14:32 <mmorrow> Makoryu: ah, ok. the haskell rules ones are that any one of ["do","let","where",icantremember] start a new layout context, and the whatever column the next token happens to be started in gets fixed as the indent for that cxt
16:14:54 <mmorrow> *..and whatever column..
16:15:05 <Cale> "of"
16:15:06 <Makoryu> mmorrow: Yeah, a lot of new Haskell users are confused at how it's not the same as Python
16:15:13 <mmorrow> ah right "of"
16:16:47 <cwraith> Hence why I like having a newline after each of those except "let"
16:19:07 <mmorrow> hmm, right and you also have to have each context nested (wrt to the right/within) all enclosing contexts
16:20:11 <mmorrow> but i guess that follows from the other rule
16:20:58 <Cale> I don't like putting a newline after 'do', and usually not after 'where' either.
16:21:08 <Philippa> mmorrow: I think explicit {} messes with that
16:21:08 <Cale> I'll put a newline *before* do, though.
16:21:21 <mmorrow> Philippa: yeah, those are a pita
16:21:26 <Cale> (and essentially always before 'where')
16:21:46 <Makoryu> I always put a newline after "do," but I always start "where" on a new line so it feels redundant to put a newline afterwards
16:21:49 <Philippa> except on IRC?
16:21:55 <olsner_> I often start with "foo $ do" (where foo is potentially long) on one line, then have the lines in the do-block indented below that
16:21:55 <pikhq> mmorrow: Do, let, where, and anything syntactically incomplete.
16:22:12 * Philippa doesn't put newlines after do, but aligns with the first statement
16:22:19 <benmachine> forkIO $ do things
16:22:21 <MyCatVerbs> But hey, at least we're arguing over where to put the newlines, rather than the braces. :3
16:22:29 <benmachine> ^ in those cases I will not put a newline before or after
16:22:43 <olsner_> MyCatVerbs: still arguing though...
16:22:46 <arw> MyCatVerbs: the braces are put where k&r command :)
16:22:53 <benmachine> but that you have to be careful with else you're squeezing against the right edge
16:23:07 <MyCatVerbs> arw: K&R had sweet bugger all to say about H98. :)
16:23:08 <Philippa> olsner_: not sure we are. Not seen anyone claim someone else's style is evil yet
16:23:10 * arw must admit, that he likes using braces.
16:23:21 <mmorrow> i write this while following along with the haskell report to learn to algo/whatnot, but it doesn't deal with explicit layout (and uses a different method than the report gave, but i think with the same result) http://moonpatio.com/repos/Layout.hs
16:23:22 <Cale> I'll put  foo $ <newline>  and then start the do-block indented on the next line
16:23:22 <MyCatVerbs> arw: and aye, I'm down with the One True Brace Style. \o/
16:23:22 <endojelly> I'n not sure if I like "do foo<newline>  ..." more or "do<newline>  foo<newline>   .." or whatever
16:23:32 <endojelly> however, I know that I often do not like what emacs likes :D
16:23:33 <pikhq> Using K&R style in Haskell is quite likely evil.
16:23:38 <olsner_> Philippa: hmm, true that
16:23:43 <MyCatVerbs> pikhq: I sure hope so!
16:26:28 <olsner> hmm, with comments - does the comment count as 0 columns, or as many columns as the comment is long?
16:27:24 <mmorrow> olsner: iirc it assumes comments have been stripped
16:27:39 <mmorrow> (it := the report)
16:28:36 <mmorrow> so i guess that means they count as 0 cols
16:29:23 <vav> hehe, 50.2 % 'do ' vs. 'do\n' in local repos
16:30:41 <endojelly> vav, wow 8)
16:33:06 <olsner> I'm at 21.5% 'do ' vs 'do\n'
16:33:17 <McManiaC> @pl \a i = i + 1
16:33:17 <lambdabot> (line 1, column 6):
16:33:18 <lambdabot> unexpected "="
16:33:18 <lambdabot> expecting pattern or "->"
16:33:24 <McManiaC> @pl \a i -> i + 1
16:33:24 <lambdabot> const (1 +)
16:33:33 <olsner> I just really don't like lining up the second line to a part of the first line
16:35:20 <olsner> just thinking about doing that makes me feel queasy
16:35:25 <EvilTerran> olsner, likewise
16:35:34 <EvilTerran> but then, i'm used to using tabs
16:35:40 <olsner> heh, me too
16:35:51 <EvilTerran> altho i don't in haskell, i still prefer all my indentation to be multiples of 4
16:37:52 <skorpan> my html always has 2 spaces indentation
16:38:03 <Twey> Is there an up-to-date, usable DBus binding?  All I can find is HDBus, and it looks to be less than complete (it doesn't seem to include any functions, and according to the homepage, it hasn't been updated since 2006)
16:49:34 <ski> i use "do foo\n   bar\n" as well as "blah.. do\n  foo\n  bar\n", depending on circumstances
16:50:11 * ski waits for cries of "lunatic !"
16:50:42 <mmorrow> yeah, i usually switch it up too depending on what's less cluttered given the surrounding code
16:51:02 <mmorrow> s/cluttered/whatever/
16:51:09 <ski> *nod*
16:51:40 <Twey> Likewise, especially if the block ends up being particularly wide
16:52:42 <mmorrow> heh, yeah sometimes you have to "reassociated" the 4 nested do/case/case/do's
16:53:15 <ski> (also, i happen to prefer "blah\n  where\n  ..." (even for modules), though i'm not sure how common that is)
16:54:11 <ski> mmorrow : commute them ? or just change the indentation style of each of them ?
16:55:13 <ski> i could be nice if the editor could change between indentation-styles of a whole block at a time
16:55:30 <Twey> I concur
16:56:06 <mmorrow> like "do asdf\n\ncase ... of\n  -> do\n qwer" ==> do\n asdf\ncase .. of\n _ -> do qwer"
16:56:16 <mmorrow> gah, hard to get across in a line
16:56:22 <skorpan> this is just getting more and more legible
16:56:27 <Twey> Haha
16:56:29 <ski> (i.e., of the "outermost" block of a marked part, not the relative styles of the subblocks)
16:57:46 <ski> mmorrow : ok, commute the styles, not the constructs
16:57:54 <mmorrow> ski: ah, right
16:57:57 <pikhq> mmorrow: Why not use {}?
16:58:03 <pikhq> >:D
16:58:18 <mmorrow> yeah, swap \n's around at different levels
16:58:44 <mmorrow> [no \n, \n, \n, no \n] ==> [\n, no \n, \n, no \n]
16:58:46 <ski> (pikhq : that would not communicate the different styles of using indentation and newlines)
16:59:11 <mmorrow> pikhq: ugh! :)
16:59:48 <monochrom> do { not; use; newlines }
17:00:03 <mmorrow> , prettyPrintWithMode
17:00:06 <lunabot>  luna: Not in scope: `prettyPrintWithMode'
17:00:07 <arw> it would if you combine {} with the usual tools like indent(1) (well, with some extensions for haskell...)
17:00:08 <mmorrow> aww
17:00:11 * ski grins
17:01:21 <ski> > (do not) otherwise
17:01:22 <lambdabot>   False
17:01:33 <centrinia> :t otherwise
17:01:35 <lambdabot> Bool
17:01:45 <ski> @src otherwise
17:01:45 <centrinia> > otherwise
17:01:45 <lambdabot> otherwise = True
17:01:47 <lambdabot>   True
17:01:50 <monochrom> An extension for haskell would provide a million parameters so you could tune indentation styles.
17:02:27 <monochrom> Then someone would come up with "iDent" which would claim to simplify all that.
17:02:41 <arw> indent already has a million styles available. you just need to keep it from messing up things like guards.
17:02:57 <olsner> and then someone builds an extension for the extension so that it behaves like Haskell did from the start?
17:03:29 <monochrom> Someone would jailbreak iDent "so you could write plugins in Haskell"
17:08:27 <Colesaur> is there a simple way to say "there's at least 1 eleemnt in this, that equals at least 1 element in that?"
17:08:37 <Colesaur> for two lists or sets or tuples or w/e?
17:08:50 <dibblego> @type (\\)
17:08:52 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
17:09:52 <benmachine> [1,2,3,1,2,1]
17:09:53 <benmachine> er
17:09:59 <benmachine> > [1,2,3,1,2,1] \\ [1,1,2]
17:10:00 <lambdabot>   [3,2,1]
17:10:01 <jfoutz> > [1..3] \\ [3..5]
17:10:02 <lambdabot>   [1,2]
17:10:18 <benmachine> @src (\\)
17:10:18 <lambdabot> (\\) = foldl (flip delete)
17:10:26 <benmachine> hah
17:10:51 <ski> > any (\p -> any (p ==) [0,2,4,6,8]) [2,3,5,7]
17:10:53 <lambdabot>   True
17:11:13 <jfoutz> > [1..3] `intersect` [3..5]
17:11:14 <lambdabot>   [3]
17:11:19 <dibblego> @type ((not . null) .) . intersect
17:11:21 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
17:11:35 <Colesaur> "ham" `intersect` "cheese"
17:11:38 <Colesaur> > "ham" `intersect` "cheese"
17:11:40 <lambdabot>   "h"
17:11:41 <kyagrd> Have you guys seen *** Exception: Internal Happy error  message from GHC?
17:11:45 <kyagrd> grrr
17:11:51 <Colesaur> > "ham" `intersect` "zebras"
17:11:53 <lambdabot>   "a"
17:12:04 <Colesaur> > "ham" `intersect` "sun"
17:12:07 <lambdabot>   ""
17:12:10 <jfoutz> sounds unhappy. parser bug?
17:12:12 <ski> > (`any` [2,3,5,7]) $ \p -> (`any` [0,2,4,6,8]) $ \e -> p == e
17:12:14 <lambdabot>   True
17:12:16 <kyagrd> I'm chewing too much template haskell and GHC is complaying :(
17:12:36 <Colesaur> so intersect is good right
17:12:55 <jfoutz> yeah. i think it'll do what you need.
17:12:57 <ski> Colesaur : `intersect' or `any', i'd suggest
17:12:58 <Colesaur> or intersect ==e, i, a, t, n, s, r, o
17:13:08 <Colesaur> lol whtf
17:13:12 <Colesaur> that was still on my clipboard
17:13:17 <Colesaur> woa
17:14:11 <jfoutz> @src intersectBy
17:14:11 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
17:14:21 <jfoutz> @sec intersect
17:14:21 <lambdabot> intersect = intersectBy (==)
17:14:41 <jfoutz> any is teh cool way.
17:15:43 <ski> if you need to get the (or at least a) common element, then `intersect'
17:16:20 <dibblego> > let (<^^>) = ((not . null) .) . intersect in "ham" <^^> "pizzle"
17:16:22 <lambdabot>   False
17:16:28 <ski> if you only need to know whether there is one, then either `intersect' and `null', or `any'
17:16:29 <dibblego> > let (<^^>) = ((not . null) .) . intersect in "ham" <^^> "pizza"
17:16:31 <lambdabot>   True
17:16:57 <jfoutz> i think any is lazier
17:17:25 <Colesaur> i am just trying to reduce a series of similar guards
17:17:33 <dibblego> > let (<^^>) = ((not . null) .) . intersect in ['b'..] <^^> ['a'..]
17:17:35 <lambdabot>   True
17:17:42 <Colesaur> instead of making every possible combination
17:17:44 <ski> jfoutz : could well be
17:17:47 <dibblego> > let (<^^>) = ((not . null) .) . intersect in ['m'..] <^^> ['a'..'f']
17:17:49 <lambdabot>   False
17:17:52 <benmachine> surely establishing a null intersection would be strict in both arguments
17:18:03 <benmachine> erm
17:18:04 <jfoutz> > `any` [2,3,5,7, undefined]) $ \p -> (`any` [0,2,4,6,8]) $ \e -> p == e
17:18:06 <lambdabot>   <no location info>: parse error on input ``'
17:18:09 <benmachine> ish.
17:18:11 <Cale> Using Set.intersection may be much faster if the number of elements in both lists is large.
17:18:15 <jfoutz> > (`any` [2,3,5,7, undefined]) $ \p -> (`any` [0,2,4,6,8]) $ \e -> p == e
17:18:17 <lambdabot>   True
17:18:29 <ski> > head $ intersect (0:2:undefined) (2:undefined)
17:18:30 <lambdabot>   * Exception: Prelude.undefined
17:18:30 <ski> > head $ intersect (2:undefined) (0:2:undefined)
17:18:32 <lambdabot>   2
17:18:33 <Cale> (Since it's O(n+m) time)
17:18:51 <ski> > (`any` (2:undefined)) $ \p -> (`any` (0:2:undefined)) $ \e -> p == e
17:18:52 <lambdabot>   True
17:18:56 <ski> > (`any` (0:2:undefined)) $ \p -> (`any` (2:undefined)) $ \e -> p == e
17:18:57 <lambdabot>   * Exception: Prelude.undefined
17:18:58 <jfoutz> hrm.
17:19:03 <Cale> (though, creating the sets in the first place will make that O(n log n + m log m) time)
17:19:26 <monochrom> Still beats n^2+m^2
17:19:53 <monochrom> Err, n*m
17:20:22 <monochrom> The product is bigger than the total.
17:21:14 <jfoutz> > length ((nub "random stuff") \\ (nub "other stuff")) < length (nub "random stuff")
17:21:15 <lambdabot>   True
17:21:32 <jfoutz> that's pretty horrible :)
17:24:15 <philed> Are you there quicksilver?
17:26:07 <uman> Is there a "K&R" of Haskell?
17:26:26 <pikhq> What, like... The H98 Report?
17:26:54 <uman> by which I mean, a book such that if an intelligent person reads it thoughtfully,, practices, and does the exercises, that person will become an expert in Haskell
17:26:54 <Raynes> uman: Real World Haskell is pretty much the creme De la creme of tutorial-style-books, if that's what you mean.
17:27:15 <uman> well, depending on your definition of "expert"
17:27:16 <Raynes> Well, I don't know about that...
17:27:25 <uman> Raynes: thanks
17:28:10 <jfoutz> no, like the definitive guide to haskell. RWH is good. Hudak's haskell school of expression is pretty good too.
17:28:42 <uman> jfoutz: thanks
17:28:45 <skorpan> lyah
17:29:14 <philed> Hudak's is the best programming book I have ever read.
17:29:32 <philed> I'm into gamedev though, so I particularly loved the FRP stuff.
17:29:51 <uman> Hudak?
17:29:54 <uman> oh
17:30:34 <uman> Definitely going to go with RWH since it's available as an ebook
17:31:41 <uman> Go O'Reilly
17:32:27 <Cale> The definitive guide to Haskell is to read the Report and then a large collection of papers written by a handful of authors. ;)
17:32:50 <uman> Cale: I thought it was to come in here and say "I'm not sure if I want to learn Haskell..."
17:32:53 <uman> Cale: ;)
17:33:19 <ski> (not quite what you're asking for, but it might be a good idea to take a look at SICP at some point, if you haven't (even though it's not any Haskell))
17:33:29 <jfoutz> cale: yeah. i think that's true. read so many papers since i started playing with haskell.
17:34:03 <skorpan> people always talk about SICP.. i haven't once read it. do i really need to?
17:34:31 <jfoutz> you can decide for yourself. http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start
17:34:34 <Makoryu> skorpan: Every day ;)
17:34:50 <skorpan> jfoutz: i can decide if i need to read it by reading it. true!
17:35:05 <jfoutz> hehehe. it's like recursion. ;)
17:35:40 <ski> it's like finding out whether a program terminates by running it and waiting ;)
17:35:57 <skorpan> (inb4 halting problem)
17:36:04 <Makoryu> I've read bits of SICP, but never seen the lectures, which I'm told are the real point of the thing
17:36:07 <kyagrd> SICP is a jolly good book.
17:36:21 <jfoutz> there's some good stuff in there. build an object system, implement prolog, build a compiler.
17:36:51 <uman> SICP: the K&R of Scheme?
17:37:03 <kyagrd> uman: no, it's not about scheme
17:37:12 <fbru02> i also liked the mock a mockingbird one, is that book enough to understand GADTs ?
17:37:20 <kyagrd> it covers wide range of computer science.
17:37:27 <uman> kyagrd: SICP: the K&R of life?
17:37:39 <jfoutz> K&R of scheme is probably this http://www.scheme.com/tspl3/
17:37:41 <ski> fbru02 : i thought it was about combinators ?
17:37:45 <pikhq> TAoCP: The SICP of K&R?
17:37:48 <monochrom> I propose Bird's book.
17:38:08 <ski> hehe
17:38:31 <ski> (Bird and Meertens, i presume)
17:38:35 <kyagrd> The purpose of SICP is to illustrate that solving problems in computer science is about comming up with an appropriate language desciption of that problem (in other words DSL).
17:38:42 <lpsmith> jfoutz:  http://www.scheme.com/tspl4/  :-)
17:38:50 <ski> (.. or was it de Moor ?)
17:38:54 <fbru02> ski it is it is about combinators !
17:38:55 <monochrom> No, Bird's "introduction to functional programming using Haskell" 2nd edition.
17:39:20 <ski> ah, that one
17:39:25 <monochrom> But the algebra one is with de Moor.
17:39:36 <pikhq> kyagrd: Isn't it?
17:39:45 <ski> fbru02 : so how is the combinators related to GADTs ?
17:39:54 <pikhq> (I tend to write in languages that encourage that. So. :))
17:40:00 <kyagrd> pikhq: indeed.
17:40:01 <ski> (maybe Bird and Meertens was some paper, then ..)
17:40:03 <monochrom> If someone asked for "the K&R of programming in general" I might propose the algebra one.
17:40:08 <kyagrd> Quote from SICP "The technology for coping with large-scale computer systems merges with the technology for building new computer languages, and computer science itself becomes no more (and no less) than the discipline of constructing appropriate descriptive languages."
17:40:13 <jfoutz> lpsmith, bah. hygenic macros are for suckers.
17:40:22 <Colesaur> how do you nest guards?
17:40:32 <kyagrd> Anyone teaching or sudying SICP shouldn't miss this point.
17:40:54 <fbru02> ski: i thought GADT was about constructing data types using combinators
17:41:17 <pikhq> kyagrd: I haven't read SICP (nor do I know Scheme), but... I thought that was obvious.
17:41:28 <Makoryu> Colesaur: What would a nested guard look like?
17:41:35 <Makoryu> Colesaur: Or at least, what would it mean
17:41:37 <Makoryu> ?
17:41:45 <pikhq> But maybe that's just my Tcl experience showing.
17:41:49 <kyagrd> pikhq: Oh, well there are some CS majors who never gets it.
17:42:01 <jfoutz> kyagrd: i think they gave up on that though. now mit is all python, because it's better to be an archaeologist that glues modules together, than write code yourself.
17:42:07 <fbru02> pikhq SICP isnt about scheme , it is about lots of topics in CS i guess
17:42:08 <Colesaur> Makoryu:  like, | isRed
17:42:18 <Colesaur> and then intended underneath | isPurple = blah
17:42:19 <ski> jfoutz : (at least defaulty) unhygienic macros is a bug ;)
17:42:20 <Makoryu> pikhq: A lot of programmers go through life on a diet of codependent relationships with design patterns
17:42:24 <Colesaur> | isGren = Blah
17:42:46 <Colesaur> instead of each line being isRed && is Purple = blah
17:42:52 <Makoryu> Colesaur: You could write "| isRed && isGreen"... Okay then
17:43:02 <pikhq> (Tcl is quite silly with its use of domain-specific languages. I blame the fact that there's only 12 things in the language set in stone, and those are parser rules.)
17:43:26 <kyagrd> jfoutz: It wasn't me that mentioned MIT is now teaching with SICP (if anyone said that at all before I join the conversation)
17:43:28 <Colesaur> i am tryinmg to avoid having multiple copies of the isRed part because it's long and complicated
17:43:36 <Makoryu> Colesaur: You can instead write "| isRed = case stuff of {- more guards -}"
17:43:38 <philed> kyagrd: I was sold on Lisp and SICP for a while with the idea of deeply embedded DSLs through macro languages and metacircular evalutors. But I think combinator languages are the way to experiment with DSLs, and I don't think Lisp is that useful here. Once I start mucking around with ever higher-order functions, I want a static type-system to help me out.
17:43:47 <Cale> Colesaur: You should note that 'where' clauses scope over all guards
17:43:47 <Makoryu> Colesaur: So make it a function
17:44:14 <kyagrd> philed: SICP's emphasis is not about LISP or scheme
17:44:18 <pikhq> philed: Lisp's at least got the right idea, they just don't do it right. ;)
17:44:23 <Cale> Colesaur: That is, any values you define in a where clause will be available in all of the guards
17:44:30 <Colesaur> ive already made it a function, now i want to have several guards for the case that the function is true
17:44:38 <philed> kyagrd: I would say the stuff on metalinguistic abstraction certainly is.
17:44:47 <Colesaur> a function in the where block, actually
17:45:02 <Makoryu> Colesaur: How about you put your code on moonpatio.com and point out the part you want to change?
17:45:09 <Cale> Colesaur: I mean, you can just define a single Bool value and reuse that in each of the guards
17:45:20 <philed> kyagrd: Non-existent syntax makes Lisp particularly suited to deeply embedded DSLs.
17:45:32 <Colesaur> i think ive described what i need pretty well already
17:45:42 <monochrom> @quote monochrom syntax rule
17:45:42 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
17:45:43 <Colesaur> i think i can use case
17:45:45 <Colesaur> i guess
17:45:59 <Cale> hmm
17:46:09 <jfoutz> kyagrd: ah sorry for the confusion, it was written by mit guys for mit students. the authors don't teach in scheme anymore, i think that's kind of sad - and kind of runs contrary to your quote from sicp.
17:46:59 <Cale> hmm... they still do teach in Scheme at MIT, from what I understand. It's just the introductory course was changed.
17:47:05 <Makoryu> jfoutz: To be perfectly accurate, it's worth pointing out that the SICP-based course is no longer the *intro* course to CS
17:47:43 <jfoutz> oh, that's great. id seen random articles a few years ago, and must have misunderstood.
17:48:25 <ski> fbru02 : i'm not sure i see how GADTs, anymore than algebraic data types, is about constructing data types with combinators
17:50:07 <ski> fbru02 : GADTs do allow more interesting ways to combine constructors, due to the type indices (HOAS, et.c.), but ordinary algebraic data type constructors are still combinators
17:50:34 <monochrom> They say they switch because the SICP goals were relevant before but not any more. The relevant goals are now "engineers have to work with libs with 300-page partial and wrong docs", and python is used just because such an example lib is a python binding for a robot-driving lib. The humorous side of me sees that python itself fits that description too. :)
17:51:16 <pikhq> monochrom: Buh... Do they want to make code monkeys, or do they want computer scientists?
17:51:41 <monochrom> They want to make engineers. They really use the exact word "engineers".
17:51:45 <Cale> "The real world sucks, so let's stop teaching people the right way to do things."
17:51:57 <pikhq> monochrom: ... Graaaw.
17:52:04 <syntaxglitch> the course in question is also a programming intro for non-CS students, isn't it?
17:52:16 <syntaxglitch> like, electrical engineering folks and whatnot
17:52:19 <ski> i believe so
17:52:26 <Cale> (but I jest -- the SICP course is still there)
17:53:39 <syntaxglitch> it makes fair sense to me to give the non-CS folks an exposure to the more "code monkey" type experience
17:53:45 <fbru02> ski: u are right , GADT is just a way that you can easily put combinator in an ADT , in normal ADTs you can still archive this
17:53:51 <kyagrd> MIT is not a school of theory centric atmosphere.  They tend to value more non-traditinoal or multidiciplined approach.  Prime example is the media lab.
17:54:09 <syntaxglitch> in an ideal world everyone would spend hours meditating on the elegance of the lambda calculus but I don't think that's especially helpful for a hardware person
17:54:46 <Cale> syntaxglitch: hmm, or *is* it? :)
17:55:23 <dsdeiz> hello, how do i define a function in the ghci prompt?
17:55:24 <vyom> what is the best way to parse a binary file format (like MP3 for ID3 tags) with Haskell. Is Parsec suitable? I cannot seem to find any examples out there
17:55:41 <monochrom> let f x = "hello" ++ x
17:55:41 <Cale> dsdeiz: you can prefix the entire definition with let and squeeze it onto one line
17:55:45 <ski> uman : on the topic of interesting CS books, i found CTM (paradigms) and TaPL (types) nice
17:55:48 <dsdeiz> thanks
17:55:54 <fbru02> what would the goal of the average person in #haskell?
17:55:55 <dsdeiz> so it's the same as variables?
17:55:56 <Cale> dsdeiz: But you're expected to put definitions in a file.
17:56:02 <erikc> vyom: Data.Binary package
17:56:04 <ski> List of popular programming book acronyms <http://mbishop.esoteriq.org/stuff/books.txt>
17:56:07 <Cale> dsdeiz: yeah, functions are values like any other
17:56:41 <syntaxglitch> what kind of silly language would treat functions and other variables differently? :)
17:56:57 <fbru02> dsdeiz long story short, u cant, u have to load them with :l
17:56:57 <dsdeiz> Cale: cool, thanks
17:56:58 <Cale> *cough* Common Lisp *cough*
17:57:04 <pikhq> syntaxglitch: Even C doesn't do that.
17:57:09 <jfoutz> fbru02: i suspect the goal is look  busy typing when advisors walk past.
17:57:21 <pikhq> Well. ISO C99 doesn't.
17:57:25 <tommd> Common?  COMMON?  Its so arrogant that it refers to itself as common?  Was it common when it was named?
17:57:30 <pikhq> It just treats functions poorly.
17:57:33 <monochrom> The Structure and Interpretation of Programming Book Titles: http://www.vex.net/~trebla/humour/programming_books.html
17:57:42 <pikhq> But it's the same as its treatment of variables, so.
17:57:42 <vyom> erikc:  ok.. thanks. I saw an example of a tar file parser. But is it possible to use Parsec, since it seems to be more elegant?
17:57:52 <Philippa> tommd: It was designed to be the most common form of lisp, is that good enough?
17:58:01 <Makoryu> dsdeiz: Stuff you can't define at the prompt: Module headers, types, typeclasses, and instances.
17:58:03 <tommd> Yes, I'm just being silly.
17:58:04 <whoppix> tommd, I think lisp was pretty common back then :)
17:58:11 <dsdeiz> fbru02: hmm, i think i'll settle with 'let' first, it seems to fit with the tutorial
17:58:21 <syntaxglitch> pikhq, that is one nice part about C, it is very consistent about many things
17:58:29 <Makoryu> tommd: "Common" in the sense of "mutually intelligible with lots of dialects."
17:58:30 <ski> fbru02 : learn as much as possible about CS ?
17:58:33 <dsdeiz> Makoryu: haven't gone on that stage yet :D but i'll keep that in mind, thanks ;)
17:58:58 <Cale> Exceptional Lisp
17:59:24 <pikhq> syntaxglitch: It at least makes a few design decisions and runs with it, yeah.
17:59:34 <fbru02> ski: im an engineer , im sorry sometimes i dont see the use of "knowing" becuase of knowing
17:59:35 <Makoryu> tommd: Actually, CL is to Lisp dialects as Haskell is to lazy functional languages
18:00:31 <pikhq> fbru02: ...
18:00:51 <Cale> fbru02: I'm a mathie. Knowledge is an end rather than a means ;)
18:01:01 <erikc> vyom: i dont think Parsec is designed for binary parsing
18:01:06 <pikhq> I'm sorry, you're in the wrong field. Put down the computer and do something that doesn't require learning, like farming.
18:01:33 <Makoryu> pikhq: In order to actually understand what fbru02 was trying to say, please look at what Cale said and invert it.
18:01:38 <monochrom> Farming requires learning.
18:01:50 <pikhq> monochrom: Then he's screwed.
18:01:56 <tommd> Farming, these days, can make good use of embedded processing.
18:02:05 <monochrom> Only one thing is born to know. Drinking milk.
18:02:27 <ski> monochrom : ty for that link :)
18:02:31 <fbru02> pikhq : u don't think there is a separation between engineers and scietists ?
18:02:32 <monochrom> Consider it bootloader :)
18:02:42 <Axman6> fbru02: the use of knowing because of knowing is that one day you might not just need to know something, but use the knowledge
18:02:45 <Gracenotes> English is not born to know, however third most born to know language
18:03:10 <pikhq> fbru02: Computer science is not a science, BTW.
18:03:12 <pikhq> ;)
18:03:24 <lpsmith> jfoutz: well,  I've only seen a few cases when I thought macros were particularly compelling...
18:03:49 <lpsmith> but if I'm going to use a macro system, I would definitely prefer a hygenic macro system :-)
18:04:18 <Axman6> pikhq: some would argue otherwise. i wouldn't though :P
18:04:19 <fbru02> pikhq: i mean imho advances in engineer come from engineers looking into what scientists are doing
18:05:09 <Makoryu> Haskell programmers are kind of spoiled as to the usefulness of macros
18:05:21 <Makoryu> I mean this in a good way
18:05:30 <Axman6> we have macros?
18:05:39 <Makoryu> Axman6: We don't really need them.
18:05:46 <Makoryu> I mean, we have TH
18:05:46 <Axman6> good point
18:06:06 <Makoryu> But you can get by fine without TH
18:06:48 <monochrom> Hrm, Psychology of Programming is not on the list of acronyms!
18:06:49 <Makoryu> All the stuff Haskell does with currying and typeclasses and laziness would be accomplished in CL with an entire fleet of macros
18:07:28 * ski one of these days ought to look at TH, even though it appears ugly from a distance
18:07:32 <philed> I remember being told that in Lisp, one of the big successful DSLs is CLOS. But CLOS is mostly made out of higher-order functions. The only real macros are in defclass and defmethod. That's not a significant win for macros as far as I'm concerned. The important stuff is in HOFs.
18:07:50 <Adamant> macros would be nice
18:08:07 <Adamant> I don't buy the "Haskell programs don't need macros" line
18:08:16 <ski> monochrom : ask mbishop_ to add it ?
18:08:31 <Adamant> and TH is very ugly, which is why macros would be nice
18:08:37 <Makoryu> Adamant: There's also she
18:08:46 <Adamant> que?
18:08:55 <NEEDMOAR> ¿Qué de qué?
18:08:55 <Makoryu> http://personal.cis.strath.ac.uk/~conor/pub/she/examples/
18:08:57 <ski> Adamant : i'm inclined to believe that, too
18:09:34 <Saizan> TH _is_ macros, it just happens that haskell syntax is not only made of s-exprs
18:10:09 <Saizan> altough i'd like quotations to work as patterns too
18:10:10 <Adamant> Saizan: TH is ugly and complicated like most templating systems are
18:10:19 <Adamant> at least from my perspective
18:10:29 <Adamant> then again I learned the Lisps before Haskell
18:10:37 <Adamant> and I hate templates in C++
18:10:55 <philed> Templates in C++ are a macro system by accident.
18:11:08 <pikhq> Templates in C++ are lambda calculus by accident.
18:11:15 <Saizan> Adamant: i guess i wonder how you can make a simpler macro system for haskell, considering that haskell is not lisp
18:11:31 <Adamant> Saizan: just write it as Lisp with Liskell :P
18:11:42 <Adamant> a Lisp, rather
18:11:47 <Makoryu> Here's a thought. What if we had a macro system that went in after the parse phase, converted everything to prefix notation, and pretended to be Lisp?
18:12:04 <Saizan> Adamant: no thanks :)
18:12:20 <philed> Have you looked at expression objects in F# and C#?
18:12:21 <Adamant> Makoryu: Liskell lets you write code immediately translated to Haskell as a Lisp
18:12:36 <Adamant> basically a Haskelly Lisp
18:12:45 <Makoryu> Adamant: Yes. Yes it does.
18:13:00 <Saizan> Adamant: how does liskell copes with all different kinds of declarations? data/class/instance/..
18:13:01 <Makoryu> Adamant: And those macros aren't usable from somewhere in the middle of a .hs file, are they?
18:13:24 <Adamant> Makoryu: not sure, if I'm doing Liskell I just write it all in Liskell
18:13:38 <Adamant> Saizan: def keywords
18:13:41 <Adamant> IIRC
18:14:26 <Adamant> in reality I end up writing most stuff that I'm not noodling around with only personal use in standard Haskell
18:14:41 <Adamant> just because It's The Standard For Haskell
18:16:35 <monochrom> GHC releases are now more and more like movie releases!
18:16:45 <Adamant> indeed, lots of fun toys
18:16:55 <monochrom> They now tell you dates!
18:17:02 <Adamant> oh
18:17:12 <Saizan> uoh, when is the next?
18:17:14 <monochrom> "On September 14, expect 6.12.1 RC1"
18:17:21 <Axman6> whoot
18:17:25 <Adamant> there seems to be more cool stuff packed into each new major release
18:18:54 <Saizan> so now we're going to generate a big hype bubble and feel deluded after the release?
18:18:59 <lpsmith>  Adamant:  what would you use macros for?
18:19:15 <Adamant> lpsmith: defining my own syntax
18:19:40 <Makoryu> ON! SEPTEMBER! 14TH! GHC 6.12 WILL MAKE YOU ITS BITCH!
18:19:41 <ski> define new binders
18:19:59 <Badger> www.ghc612themovie.com
18:20:07 <BMeph> GHC 6.12: Fury of the Lambda, coming September 14th
18:20:08 <lpsmith> lambda is the ultimate binding construct :-)
18:20:23 <lpsmith> foo >>= \var -> exp   :-)
18:20:53 <vav> "Simon's back! And he'll be up for a Nobel with this one. Don't miss it. 14th September worldwide."
18:21:25 <Adamant> I was thinking more Field Medal, unless he gets the Peace Prize
18:21:28 <ski> > [ (x,y) | x <- [0,1,2] | y <- "abc" ]  -- how do i simulate this kind of scope-crossing with lambda ?
18:21:30 <lambdabot>   [(0,'a'),(1,'b'),(2,'c')]
18:21:30 <Adamant> *Fields
18:21:37 <vav> point
18:21:39 <ski> lpsmith : ^
18:22:19 <Axman6> Adamant: i think he should get the peace prize, just because his talks are so entertaining, anyone would forget they hated other people
18:22:48 <Adamant> increase the peace, yo
18:23:03 <lpsmith> ski: You could avoid the use of ghc extensions
18:23:26 <lpsmith> > [ (x,y) | (x,y) <- zip [0,1,2] "abc" ]
18:23:27 <lambdabot>   [(0,'a'),(1,'b'),(2,'c')]
18:23:32 <ski> lpsmith : the use of a GHC extension was just a handy way of showing the kind of binders i want, sometimes
18:25:44 <lpsmith> yeah,  I know you weren't asking about that specific case,  I guess I just don't quite have a feel for the general question yet
18:26:49 <ski>   let if ... then f x = ..f.g.x..; g y = ..f.g.y.. else f x = ..f.g.x..; g y = ..f.g.y.. in ..f..g..  -- and this ?
18:27:29 <pikhq> ski: Non-trivially.
18:27:42 <ski> sorry ?
18:27:44 <pikhq> But with lambda, you can do that.
18:27:50 <ski> yes
18:27:57 <ski> but you need to repeat names
18:28:04 <pikhq> With lambda and pattern matching, you can do that and maybe make it readable.
18:29:23 <ski>   let (f,g) = if ... then let f x = ..f.g.x..; g y = ..f.g.y.. in (f,g) else let f x = ..f.g.x..; g y = ..f.g.y.. in (f,g) in ..f..g..
18:29:27 <ski> is one way
18:29:58 <lpsmith> ski:  isn't that case necessarily either non-terminating or corecursive?
18:30:31 <lpsmith> because you can't use anything in x or y in the conditional branch...
18:30:47 <ski> it defines `f' and `g' with mutual recursion, in one of two possible ways, depending on the condition
18:31:17 <lpsmith> oh, ok,  I wasn't quite clear with your notation
18:31:22 <lpsmith> makes more sense now
18:31:32 <ski> i can indent it for you, if you prefer ..
18:32:12 <lpsmith> well, I was kind of reading that as  let f = f . g;  g = f . g in ...
18:32:57 <ski> oh .. no the `..f.g.x..' was just meant to signify any expression that possibly uses `f',`g',`x'
18:33:09 <lpsmith> right,  I caught that by now :-)
18:40:58 <lpsmith> ski:  what about something like this:   let  f' x = ..f'.g'.x..;  g' y = ..f'.g'.y..; f'' x = ..f''.g''.x''..; g'' y = ..f''.g''.y''..; f x = if ... then f' x else f''; g y = if ... then g' y else g'' y; in ...
18:41:14 <ski> (btw, that above is a bit similar to `let f x = ..f.g.x..; g y = ..f.g.y.. in h a = ..h.i.a..; i b = ..h.i.b..', aka `local' in SML)
18:43:00 <ski> lpsmith : yes, you could lift the inner `let's out and rename
18:43:31 <ski> but the condition should not be duplicated (which is trivial to fix)
18:44:38 <ski> (and probably it's better to do like `f = if ... then f0 else f1' (or `(f,g) = if ... then (f0,g0) else (f1,g1)', if merging)
18:48:20 <lpsmith> hmm... well,  erlang supports defining a variable in either branch of an if...
18:48:22 <ski> lpsmith : btw, note that i'm not sure how simple it would be to add these later constructions with macros (given that it's harder to modify existing constructions than add new ones), so i'm more like woeing the lack of them in haskell, atm
18:48:39 <lpsmith> It's kind of nice that way, really.
18:48:46 <ski> lpsmith : exactly ! .. that comes from its Prolog heritage
18:50:00 <mmorrow> template-haskell is about being able to write haskell code with haskell, which is wonderful when you'd rather not bang out a few thousand lines of mind-numbingly tedious repetitive code
18:50:00 <ski> dreaming on `do {...; foo $ do {x <- ...; y <- ...}; ..x.y..}', would also be handy, at times
18:53:04 <mmorrow> e.g. a few thousand lines of fully unrolled fft's, haskell http://moonpatio.com/repos/hsfft/fft_upto_128.hs generated (and re-generatable with different params) with less than 100 lines of haskell (w/TH, but only because that's more convenient than using String/Doc/re-writing TH ast+prettyprinter http://moonpatio.com/repos/hsfft/GenFFT.hs
18:53:19 <mmorrow> this is in my mind the killer app of TH
18:53:26 <Saizan> would it make sense to extend hscolour so that identifiers link to their definition in other modules?
18:53:39 <mmorrow> Saizan: that would be awesome
18:53:51 <mmorrow> (although you'd have to actually parse it then)
18:54:09 <ski> mmorrow : that's a bit similar to MetaML, yes ?
18:54:40 <Saizan> mmorrow: hscolour doesn't parse the haskell source?
18:54:49 <mmorrow> ski: i'm not entirely sure since i just know the very little i've read about metaML
18:55:17 <mmorrow> Saizan: it just does a half-thorough lex-ish pass
18:55:33 <mmorrow> (which is nice when you use it to highlight non-haskell code..)
18:55:40 <mmorrow> cat /dev/urandom | HsColour -tty
18:56:37 <Saizan> mmorrow: shiny
18:56:45 <mmorrow> heh
18:57:06 <ski> MetaML (and MetaOCaml, i suppose. presumably it's basically the same thing) adds syntactic constructions and a type system for analyzing and generating (well-typed by construction) expressions, for possibly later evaluation
18:57:18 <mmorrow> Saizan: oops, i meant to say
18:57:25 <mmorrow> cat /dev/urandom | od | HsColour -tty
18:57:40 <mmorrow> but s/od// is amusing :)
18:58:04 * mmorrow resets his hopelessly borked terminal now
18:58:07 <Saizan> ski: yeah, the fact that quotations are typed is quite appealing
18:58:12 <chessguy> @seen edwardk
18:58:12 <lambdabot> edwardk is in #haskell and #kata. I last heard edwardk speak 6h 50m 15s ago.
18:58:14 <chessguy> @bot
18:58:14 <lambdabot> :)
18:58:14 <lunabot>  :)
18:58:48 <mmorrow> ski: the major different from what i understand though in MetaML it's like:
18:58:53 <Saizan> ski: though sometimes i'd like to disable the scoping and typechecking in TH quotations to let me abuse syntax
18:58:56 <mmorrow> Exp a ===splices to a===> a
18:59:11 <mmorrow> whereas with TH, you don't have the `a'
18:59:33 <mmorrow> so you can do things with TH that you can't with MetaML, since you're still w/in the typesystem
18:59:40 <ski> canonical example : `fun flip_pow (n : int) (e : <int>) : <int> = if n = 0 then <1> else <~e * ~(flip_pow n e)>'
19:01:58 <mmorrow> , ppDoc <$> let flip_pow n e = [|if $n==0 then 1 else negate $e * negate $(flip_pow [|$n-1|] e)|] in flip_pow [|2|] [|42|]
19:02:01 <lunabot>  luna: out of memory (requested 1048576 bytes)
19:02:10 <ski> mmorrow : you mean that quotation values aren't typed with the type of the resulting value, should it be evaluated ?
19:02:22 <mmorrow> ski: no, they're just ExpQ
19:02:34 <mmorrow> , [[|()|],[|42|]]
19:02:36 <lunabot>  [ConE (),LitE (IntegerL 42)]
19:02:55 <mmorrow> , [$([|()|]),$([|42|])]
19:02:56 <lunabot>  luna: No instance for (GHC.Num.Num ())
19:03:28 <ski> mmorrow : right, there's a `dyn' type for that in MetaML, which may throw a type-error exception at run-time when evaluating
19:04:22 <mmorrow> so it's more that you seen an ExpQ a chunk of haskell AST than you see it as some value that it could potentially become should you splice it
19:04:42 <mmorrow> ski: by run-time, do you mean at compile-time?
19:05:27 <mmorrow> because that's the nice thing about TH too, if compilation succeeds you have the same guarantee as you would had you written the result of the TH by hand
19:05:52 <mmorrow> , $(tupE (fmap lift [0..14::Int]))
19:05:53 <lunabot>  (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14)
19:07:16 <ski> mmorrow : there's a `dyn_eval' construct that takes an expression of type `dyn', and at run-time matches the actual type of the expression with the (static) expected type of the whole construct
19:07:21 <ski> (iirc)
19:07:48 <mmorrow> ski: is the MetaML runtime := compile-time, or literally at program run-time?
19:08:23 <ski> but you could easily imagine an unquote (i.e. `~...') not inside any quote to mean that something should be evaluated at compile-time, and spliced into the top-level program
19:08:25 <mmorrow> err, i guess it's just a matter of perspective until the final level of splicing
19:08:47 <mmorrow> ski: oh yeah, isn't MetaML staged too (iirc)
19:09:07 <ski> yes, staging is the point of it
19:09:44 <mmorrow> cool, yeah one (imo) huge thing that TH currently lacks is the ability to represent itself
19:10:05 <ski> i don't think it would be hard to support running one (or more) of those stages at "compile-time", instead of at "run-time"
19:10:25 <mmorrow> well, you can do that by just treating the AST datatypes as regular datatypes, but i mean a rep for splices themselves in the AST
19:11:02 <mmorrow> ski: yeah, i see what you mean now.. so  the whole point of the MetaML prog is to move from stage to stage
19:11:20 <mmorrow> so the MetaML *is* the program
19:11:24 <ski> (i.e. i don't think it would be hard to support that in MetaML .. in the sense of not requiring more theory .. just more coding)
19:11:30 <Rotaerk> hmm... how can I handle the exception returned by read? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8298#a8298  gives me:  6:4:Ambiguous type variable `e' in the constraint `GHC.Exception.Exception e' arising from a use of 'handle'
19:11:46 <mmorrow> not *making the code that will become* the/a program
19:12:17 <mmorrow> ski: interesting, i'll have to take a look at MetaML
19:13:40 <Saizan> Rotaerk: you've to pick the type of exceptions you want to catch
19:13:48 <ski> mmorrow : there was a paper about "MacroML", too, which was a modest macro system built on top of the MetaML system. (though never implemented, afaik)
19:13:59 <Saizan> Rotaerk: if you use SomeException you'll catch all of them
19:14:09 <Rotaerk> ah
19:14:50 <Saizan> ski: what would MacroML add? the ability to extend the syntax?
19:14:51 <Rotaerk> the read documentation doesn't specify the kind of exception it throws, so I guess I'll have to use that
19:15:23 <Saizan> ah, if it's for read you could write your own readMaybe using reads
19:15:30 <Saizan> instead of using exceptions
19:15:44 <lpsmith> mmorrow:  what's the impact of using lists in your FFT implementation?
19:16:08 <Rotaerk> ah hmm
19:16:52 <Saizan> Rotaerk: http://hackage.haskell.org/packages/archive/safe/0.2/doc/html/Safe.html#v%3AreadMay
19:17:01 <Saizan> readMay
19:17:08 <lpsmith> and is unrolling that much really going to be benefitial?   I suppose L2 cache is pretty hefty these days...
19:17:12 <Rotaerk> ahh cool
19:17:56 <ski> Saizan : MacroML added the ability to say `macro_let flip_pow ~n e = ~(if n = 0 then <1> else <~e * flip_pow ~(n-1) e>)' and then use `flip_pow ~5 ...' instead of `~(flip_pow 5 <...>)
19:18:17 <ski> Saizan : also, it added support for adding a simple kind of new binders
19:18:30 <mmorrow> lpsmith: i've been meaning to swap the lists out for the Vec datatype in http://moonpatio.com/repos/hsfft/Vec.hs , but have  yet to do so
19:19:32 <mmorrow> lpsmith: but the amazing part is, the original non-unrolled (pure-fft pkg on hackage) take 4.5 seconds to fft 10,000 length 64 vectors, whereas the unrolled version take 0.8 seconds!
19:20:23 <mmorrow> the really nice thing is that you can with a single pattern match, bind 64/128/however-many vars, then use them immediately
19:20:47 <mmorrow> and the compiler gets to generate at the asm-level an optimal sequence of reads
19:21:17 <mmorrow> (the asm for http://moonpatio.com/repos/hsfft/fft_upto_128.hs is pretty nice looking)
19:21:20 <lpsmith> sweet
19:25:17 <Rotaerk> hmm, I'm going to keep using the exception handling approach for now, just to figure out how to get it to work; now I'm getting a syntax issue I don't understand
19:25:21 <Rotaerk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8299#a8299
19:25:43 <Rotaerk> there's a parse error for the do in the second argument to handle
19:28:02 <ski> (Rotaerk : next time, annotate the original paste)
19:28:18 <Rotaerk> ah
19:28:28 <Rotaerk> huh, didn't notice that feature
19:28:52 <ski> i think in the `... :: ... $ do ...', the `$ do ...' is interpreted as a part of the type (ascription)
19:29:14 <Rotaerk> hmm
19:29:23 <ski> you could do `handle ((\_ -> ...) :: ...) $ do ...'
19:29:32 <ski> but it might be nicer with
19:29:49 <ski>  handle (\(_ :: SomeException) -> ...) $ do ...'
19:30:23 <ski> you probably need to add `{-# LANGUAGE PatternSignatures #-}' (iirc the correct name), then
19:31:08 <Rotaerk> hmm yea it gives me: Use -XScopedTypeVariables to permit it
19:31:22 <Rotaerk> {-# LANGUAGE ScopedTypeVariables #-} ?
19:32:28 <Rotaerk> ah cool, that worked
19:34:43 <Rotaerk> hmm seems odd that that'd have to be a language extension
19:35:08 <pikhq> Blame H98.
19:35:10 <ski> Rotaerk : yes, that's the one
19:35:36 <Rotaerk> thanks
19:35:45 <ski> (i was thinking it was a separate extension, but it wasn't .. mayhaps it has been before, though)
19:35:50 <Rotaerk> heh
19:36:08 <ski> Pattern type signatures <http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#pattern-type-sigs>
19:38:24 <Saizan> you can keep it h98 with "\(SomeException _) -> .."
19:39:20 * ski wasn't sure how `SomeException' was defined ..
19:39:38 <Rotaerk> ah
19:41:09 <Rotaerk> hmm... says the data constructor SomeException isn't in scope
19:41:33 <Rotaerk> it's imported from Control.Exception though
19:41:39 <Saizan> you've to import it like SomeException(..)
19:41:44 <lpsmith> hmm:  mmorrow:  does GHC do strength reductions when multiplying by a constant complex number with one component 0?
19:41:48 <Rotaerk> and worked using the scoped type variable instead
19:41:50 <Rotaerk> oh
19:41:55 <Saizan> if you use SomeException you're importing only the type
19:44:16 <lpsmith> I dunno how much it would help,  but I definitely notice some opportunities for tweaking the generated code...
20:19:51 <nyingen> uh-oh, ghc panic
20:19:54 <nyingen> :(
20:20:14 <moonpatrol> don't panic!
20:20:20 <moonpatrol> just stay calm!
20:20:48 <moonpatrol> oh, by the way, i like you guys.
20:21:04 <moonpatrol> i like you too DougSouth.
20:22:40 * ski carefully takes a step backwards
20:28:37 <BMeph> I like babies...
20:28:49 <nyingen> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3360#a3360
20:28:49 <gwern> i like pie
20:28:59 <BMeph> ...but I could never eat a whole one. ;p
20:30:26 <gwern> they have less meat than you might eat
20:30:43 <gwern> you can eat a bunch of chicken babies at one sitting, after all
20:30:43 <BMeph> "<interactive>:1:43: A section must be enclosed in parentheses thus: (3 *)" ...damn you and your cryptic error messages, GHC!
20:31:21 <moonpatrol> <3 hugs
20:40:27 <tingi> why do we get virtual timer expired in ghc ?
20:47:43 <tommd> tingi: ghc needs to schedule the light weight threads - I suspect that would be why the timer is needed.
20:49:41 <reppie> how do you install a hackage package?
20:51:04 <reppie> well, maybe i should ask the real question
20:51:19 <reppie> when i try to configure xmobar i get this:
20:51:30 <reppie> % runhaskell Setup.lhs configure
20:51:32 <reppie> Setup.lhs:3:29: Not in scope: `simpleUserHooks'
20:51:42 <tommd> reppie: cabal install xmobar is how I do it.
20:51:53 <reppie> hm, i don't have cabal :(
20:51:54 <tommd> reppie: It sounds like your version of the 'Cabal' library is old.
20:51:59 <reppie> ah
20:52:09 <reppie> that's probably it
20:52:12 <tommd> reppie: There is a bootstrap.sh you can use.
20:52:33 <tommd> reppie: So you shouldn't need to type any lines beyond 'bootstrap.sh' if that is still working (and you trust it)
20:52:34 <reppie> i haven't updated this computer in a long time, so i guess i should do that first
20:52:57 <tommd> It will get the zlib, http, and two others I don't recall.
20:53:06 <tommd> And build xmonad... no, wait - my bad
20:53:22 <tommd> I'm thinking of cabal-install - that has a bootstrap if you want to install that first.
20:53:54 <tommd> Also, many distros package xmonad in binary form for your enjoyment.
20:56:07 <reppie> this channel has grown a lot since the last time i was here.
20:56:42 <tommd> When were you last here?  Its been growing a lot - I think I first got here when it was topping 300 (around mid 2006 at any rate)
20:56:56 <reppie> i'm not sure
20:57:04 <reppie> but i used to hang out here in 2005
20:57:19 * dons remembers 110 in here. quiet days.
20:57:32 * ski str the nick `reppie'
20:57:55 <tommd> So by now your a highly paid functional Haskell programmer, right.
20:57:55 <tommd> Yes dons, we all know you predate us folks who came here *after* Haskells coolness became obvious ;-)
20:58:03 <reppie> tommd not really
20:58:15 <dons> hehe. old school :)
20:58:19 <reppie> i haven't really done much with haskell in a while, to be honest :(
20:58:20 <ski> (~20 was more quiet :)
20:58:32 <dons> ski and shapr and the gang.
20:58:53 <reppie> hah, shapr is still around?
20:59:07 <dons> 06.12.21:22:26:21 <reppie> is yi still alive?
20:59:08 <ski> @get-shapr
20:59:08 <lambdabot> shapr!!
20:59:09 <dons> sure.
20:59:22 <reppie> is 06 the oldest you have from me?
20:59:26 <tommd> Sure he is - I recall a graph of who talked to who back in... 2007?   shapr was the center of conversation at the time.
20:59:40 <reppie> that's weird, i'm pretty sure i was here in 2005 too
20:59:48 <dons> i don't think many people from 2001 are here, other than shapr
20:59:52 <reppie> in fact, probabyl 2004 too
21:00:18 <tommd> dons: Lets hope they are all productively writing papers instead of talking on IRC then.
21:01:12 <dons> 04.05.22:02:37:41 <shapr> dons: g'day!
21:01:20 <tommd> ha - yeah, and I was here before that learning Haskell under... hhummm... "el-hask" I think.  Any quotes there are going to be embarassing
21:01:27 <dons> oh, el-hask!
21:01:35 <tommd> Yeah - you were a big help.
21:01:51 <Nafai> I've only been on #haskell since the end of '06
21:01:55 <dons> hmm. can't find any quotes
21:02:00 <tommd> Got me reasonably up to speed before I first met Gill and Moran.
21:02:05 <dons> 02.11.08:08:08:11 <shapr> hi SyntaxPolice
21:02:18 <dons> isaac was old school (working at aetion at the time)
21:02:35 <dons> 02.11.08:08:10:26 <SyntaxPolice> shapr: I've been using haskell pretty heavily for about a month now, had some exposure to ML before that
21:02:45 <reppie> i thought he worked at ARM or similar
21:02:50 <reppie> or maybe i'm thinking of someone else
21:03:10 <dons> 03.06.20:10:03:00 <SyntaxPolice> http://www.aetion.com  I work for a little AI company developing Haskell software (and some java
21:03:33 <ski> (.. where did Isaac disappear to ?)
21:03:48 <dons> he doesn't do irc much now. too busy at galois
21:03:54 <ski> i see
21:04:04 <dons> 03.04.01:06:30:32 <shapr> have you guys seen the "Galois Homework" service sent to haskell@haskell.org ?
21:04:09 <reppie> does xerox/paolo still come here?
21:04:13 <tommd> Yeah, that foos-ball table is a time sink!
21:04:13 <dons> sometimes
21:04:18 <dons> tommd: hehe
21:04:39 <dons> 03.08.07:21:16:08 <Heffalump> Galois seem to divide their time behind designing random DSLs for clients and hacking on cool stuff for the fun of it
21:04:53 <tommd> dons: how about "ell-hask"  with two l's.
21:05:00 <ski> xerox is on freenode atm
21:05:23 <reppie> o
21:05:27 <dons> 06.05.20:10:43:04 <ell-hask> I'm trying to learn monads but obviously have a misunderstanding
21:05:30 <dons> :)
21:05:31 <moonpatrol> ha
21:05:42 <ski> (:
21:05:46 <moonpatrol> i just googled galois homework, and the last thing i saw was a pun at VB.
21:06:11 <dons> 06.06.12:18:33:18 <dons> @tell ell-hask lambdabot rocks
21:06:24 <tommd> ha!
21:06:39 <dons> 06.08.10:18:29:12 <ell-hask> dons: You're hilarious.  Yes, I agree, lamdabot rocks.
21:06:41 <tommd> I actually remember getting that
21:07:04 <dons> 06.08.10:18:59:12 <ell-hask> dons: are you working for Galois?
21:07:04 <dons> 06.08.10:18:59:33 <dons> ell-hask: nope
21:07:05 <dons> :)
21:07:15 <dons> wasn't even on the radar in 06 hehe.
21:07:30 <tommd> 3 years and 8 days
21:07:56 <tommd> I should get to building more calling conventions into GHC now.
21:08:56 * dons needs to investigate this quasiquoting business more
21:10:11 <ski> what about it ?
21:45:19 <Axman6> :( why is natural deduction not at all natural to me? (or seemingly anyone in my course)
21:46:22 <sbahra> :-(
21:46:29 <sbahra> Axman6, what are you having problems with?
21:47:10 <sbahra> Axman6, additionally, there is ##logic.
21:47:23 <Axman6> because it makes absolutely no sense to me
21:47:31 <Axman6> nothing in it is at all obvious
21:47:45 <sbahra> Axman6, nothing?
21:47:53 <Axman6> nothing
21:48:07 <sbahra> Axman6, A, B |- A /\ B
21:48:11 <sbahra> Axman6, not obvious?
21:48:37 <Axman6> i have no idea what that means
21:49:00 <Axman6> so, i'm going to miss a lecture for another course to see if i can learn more in the drop in lab
21:49:05 <Axman6> later all o/
21:49:17 <sbahra> Axman6, ##logic can help you out.
21:49:21 <sbahra> Axman6, enjoy.
21:49:40 <kscaldef> is there a merge function on lists that I'm missing?
21:49:44 <kscaldef> Ord a => [a] -> [a] -> [a]
21:49:52 <kscaldef> assumes input lists are sorted already
21:51:51 <pikhq> @src merge
21:51:51 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:51:56 <pikhq> Hrm.
21:52:08 <pikhq> @hoogle Ord a => [a] -> [a] -> [a]
21:52:09 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
21:52:09 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
21:52:09 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
21:56:02 <Makoryu> @hoogle merge
21:56:02 <lambdabot> Distribution.Simple.PackageIndex merge :: Package pkg => PackageIndex pkg -> PackageIndex pkg -> PackageIndex pkg
21:56:03 <lambdabot> Text.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
21:56:03 <lambdabot> Text.ParserCombinators.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
21:56:07 <Warrigal_> > map (gcd 64) [84,104..]
21:56:09 <lambdabot>   [4,8,4,16,4,8,4,32,4,8,4,16,4,8,4,64,4,8,4,16,4,8,4,32,4,8,4,16,4,8,4,64,4,...
21:56:09 <Makoryu> Dang
21:56:21 <Warrigal_> I can tell that 4 is as good as it's going to get.
22:06:15 <jfoutz> > unionBy (<) [3..5] [2..4]
22:06:16 <lambdabot>   [3,4,5,2,3]
22:07:10 <kscaldef> union is the closest thing, but it's not as efficient as merge would be
22:07:40 <kscaldef> it also doesn't preserve the ordering, although I happen to not actually care about that
22:07:56 <jfoutz> union has a lot of problems.
22:08:22 <jfoutz> *sigh*
22:09:15 <kscaldef> I suppose I'll just write the 3 lines of code
22:09:17 <kscaldef> *sigh*
22:09:19 <kscaldef> so sad
22:09:36 <jfoutz> yeah, sucks you have to do the match :)
22:10:34 <jfoutz> maybe something with takewhile. and fold.
22:11:50 <Saizan_> ?type union
22:11:52 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
22:12:02 <Makoryu> > seq [1..] $ text "Oh no"
22:12:04 <lambdabot>   Oh no
22:12:09 <tingi> how do we know if an underdetermined system has a solution or not ?how to kow if [  [ i1 i2 ........i1000] [j1 j2 ....j1000] [ k1 k2....k1000][ p1 p2...p1000]]*[x1 x2 x3.... x1000] = [ k k k k ... 1000 times] has a solution or not ? does there exist any set of  non -ve integers  { x1 , x2 .. x1000 } such that k is an positive integer and atleast one of x is +ve?
22:12:27 <edwardk> chessguy: back
22:12:36 <edwardk> @seen chessguy
22:12:36 <lambdabot> I saw chessguy leaving #haskell-in-depth, #darcs, #haskell-overflow, ##logic, #novalang, #haskell and #haskell-blah 2h 9m 19s ago, and .
22:12:40 <edwardk> doh
22:13:49 * edwardk was bummed. the boston haskell user group ran long so i didn't get to give the second half of my talk.
22:15:03 <Berengal> edwardk, there wouldn't happen to be a video this time around, would there?
22:16:00 <edwardk> Berengal: fraid not. i'll see if we can set up something for when we do the next one though
22:18:01 <Berengal> edwardk, yes, please do
22:20:13 <Makoryu> If I pattern match (x:xs) and later pass (x:xs) to a function, will it reuse the same cons or allocate a new one?
22:20:55 <shachaf> Makoryu: You can use @. As in f list@(x:xs) = ...
22:21:58 <Makoryu> shachaf: Eh, I knew that, but all right
22:22:31 <shachaf> Makoryu: I'm not sure of the answer to your question in practice. Probably depends on the optimizer.
22:22:34 <jfoutz> ghc is pretty smart about common sub expressions, but i don't think you get a guarantee without the @
22:22:47 <mauke> <jfoutz> ghc is pretty smart about common sub expressions  <- what
22:23:17 <edwardk> Makoryu: in general you ned to use an as-pattern (@) to get any decent sharing
22:24:32 <jfoutz> i thought the difference between lazy evaluation of, say (x -> x +x) (2+2) was that the 2+2 was recognized as the same thing, but in regular beta reduction, it would be calculated twice.
22:25:09 <mauke> it's the same thing because it's x
22:25:31 * jfoutz ponders mauke
22:25:41 <mauke> (\x y -> x + y) (2+2) (2+2)
22:26:00 <jfoutz> (x:xs -> x:xs) is different that (y -> y) :: [a] ?
22:26:18 <mauke> I don't know
22:26:23 <mauke> depends on the optimizer
22:26:24 <Makoryu> jfoutz: What...?
22:26:30 <Makoryu> Oh
22:26:39 <pikhq> jfoutz: Yeah; (y -> y) is a total function. (x:xs -> x:xs) will fail on a null list.
22:27:21 <Makoryu> jfoutz: Anyway, the (\x -> x + x) thing is a concern with call-by-name semantics, IIRC
22:27:32 <jfoutz> ok, ((a,b) -> (a,b)) vs (y -> y) :: (a,b) then.
22:28:40 <pikhq> jfoutz: Not quite the same. (a,b) will be at least evaluated enough to have a thunk for a and b, because of the pattern match.
22:29:06 <ray> edwardk: so when's the next one? :)
22:30:22 <jfoutz> so, is ghc required to construct a new (a,b), or .. not construct a (a,b) or is it dependant on the optimizer? cause, it sure looks like a common sub expression. i'd expect the parse tree to be a diamond.
22:30:58 <jfoutz> but maybe the @ is the only way to force it?
22:31:20 <jfoutz> meh. bedtime.
22:31:24 <jfoutz> g'night :)
22:31:36 <pikhq> jfoutz: As written, it is constructing a new tuple.
22:32:07 <pikhq> GHC *might* be smart enough to compile that into a properly-strict "id". But, then, it may not.
22:32:30 <pikhq> Don't care about the optimiser's behavior in most cases; it's not worth it.
22:32:32 <edwardk> ray: either september or october. as i understand it we already had two talks booked for september, so depending on how things work out i may slot either in there and bump something or slot into october.
22:32:53 <ray> cool
22:33:49 <edwardk> I may just see when the next conference is that is fairly local and just see if i can get something accepted there. can anyone thing of something relatively new england-ish that would welcome a talk on monoids/monoidal parsing?
22:33:54 <edwardk> er think of
22:38:26 <edwardk> I did have a good time and Norman Ramsey asked if I'd like to teach a category theory for computer scientists like course over at Tufts as a way to motivate getting a book on Haskell-based category theory written. Now to just see if that is viable.
22:40:55 <ray> i'd like that, category theory is a lot easier when it's in haskell notation (which i know)
22:41:18 <BMeph> edwardk: I don't get it; if you're busy teaching the class, then where are you going to find the time to write the book? ;)
22:41:34 <edwardk> BMeph: if you have to deliver a chapter a week to waiting students... ;)
22:42:09 <BMeph> edwardk: You must know, that whether you write it or not, you're going to be high on the list of people who'll get asked about it. :)
22:42:18 <edwardk> hehe
22:44:54 <ray> speaking of category theory, how do you pronounce "kan" of "kan extension"?
22:45:27 <edwardk> i've heard it as both khaaaan and  'can' ;)
22:45:28 <BMeph> Oh, edwardk: "something relatively new england-ish that would welcome a talk on monoids/monoidal parsing" -> CHUG, perhaps? :)
22:45:36 <edwardk> CHUG?
22:45:58 <edwardk> C = Chicago?
22:46:01 <BMeph> I believe shapr  says the 'C' is for Cambridge. :)
22:46:17 <edwardk> oh, yeah thats the boston one that i presented at this time ;)
22:46:18 <ray> no connecticut hug :(
22:46:25 <BMeph> Probably because BHUG didn't sound as sexy... ;)
22:46:35 <edwardk> "BHUG" or "BAHUG" depending on who is talking about it nowadays ;)
22:46:36 <ray> this place is trapped in limbo between boston and new york
22:46:48 <edwardk> we couldn't make the "CHUG" acronym stick ;)
22:46:58 <ray> i think it's good, very pronouncable
22:47:11 <edwardk> I ever worked out a nice recursive beer stein design for it
22:47:13 <edwardk> er even
22:47:36 <edwardk> the problem we had is people from that other Cambridge kept wanting to show up ;)
22:47:45 * BMeph is a big fan of stein kitsch, though strangely, not a big fan of beer-drinking...
22:47:55 <edwardk> That and Ravi keeps trying to drag it out west to Waltham
22:48:21 <edwardk> So "Boston area" is about as close as we can actually get"
22:48:56 <BMeph> Hmm... Connecticut's group could be a "Co-HUG". ;)
22:49:26 <ray> yeah, because it's a haskell user of groups instead of a group of haskell users
22:49:48 <edwardk> BMeph: given the presence of a certain pumpkin that seens fairly appropriate ;)
22:49:49 * BMeph snickers and twixes
22:50:29 <edwardk> CoHUG sounds like the town from Family Guy.
22:50:33 <BMeph> edwardk: That was impressive, putting "pumpkin" and "appropriate" in the same sentence. ;)
22:50:52 <ray> and not talking about the orange vegetable
23:09:39 <solrize> what's it mean when it says "hGetChar hdl reads a character from the file or channel managed by hdl..." ?
23:09:41 <solrize> does that mean a byte?
23:11:49 <Cale> solrize: It *should* mean a unicode code point in whatever the current encoding is (that is, a Char), but I believe it currently means a byte.
23:12:16 <Cale> > maxBound :: Char
23:12:18 <lambdabot>   '\1114111'
23:12:33 <solrize> thanks
23:12:51 <Cale> That ought to change soon though.
23:16:02 <solrize> yeah, seems to just read a byte, at least right now
23:16:03 <Cale> (In GHC 6.12, the IO library is going to start handling text encoding properly, apparently :)
23:16:12 <solrize> man it will sure break a lot of stuff if it starts reading multiple bytes :)
23:16:54 <solrize> there's no way in System.IO to read a byte?
23:17:01 <solrize> i mean "officially" read a byte
23:17:12 <solrize> i guess i can use data.binary but jeez...
23:17:13 <Cale> You ought to use ByteStrings if you want binary data. Also, there's hSetBinaryMode which will probably end up forcing it to read one byte at a time in any case.
23:17:29 <Cale> It's what Data.ByteString is for, after all :)
23:17:34 <solrize> ok
23:18:29 <Cale> It already can read more than one byte in that it converts newlines on different platforms so that they always appear to the program as '\n'
23:22:17 * shepheb is getting so frustrated with Network.CGI
23:23:11 <shepheb> when I try to redirect, no Location: header gets output, and instead it seems to repeat the request.
23:58:48 <ray> some nice damage control by haskellers on http://www.reddit.com/r/programming/comments/9bnnp/ask_proggit_this_has_always_mystified_me_how_do/
