00:00:01 <kniu> @pl chunk m n l = take m l ++ drop n l
00:00:02 <lambdabot> chunk = (. drop) . ap . ((++) .) . take
00:00:10 <kniu> :t ap
00:00:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:01:28 <ksf> > mconcat $ fmap Sum [1..10]
00:01:31 <lambdabot>   Sum {getSum = 55}
00:02:06 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3239#a3239
00:02:19 <ceal> is there a simpler way to take a list of numbers as input?
00:02:58 <ksf> > read "[1,2]" :: [Int]
00:03:00 <lambdabot>   [1,2]
00:03:16 <mmorrow> @let readM s = case reads s of (n,_):_ -> Just n; _ -> Nothing
00:03:18 <lambdabot>  Defined.
00:03:30 <ksf> if you want do parse anything else than that, I'd recommend parsec or polyparse.
00:03:37 <mmorrow> @type fmap readM <$> replicateM 10 getLine
00:03:39 <lambdabot> forall a. (Read a) => IO [Maybe a]
00:04:02 <mmorrow> @type replicateM 10 getLine
00:04:04 <lambdabot> IO [String]
00:04:38 <mmorrow> or if this is a one-shot thing, just getContents, and then do lines
00:05:09 <mmorrow> @type print . fmap readM . lines =<< getContents
00:05:10 <lambdabot> IO ()
00:05:37 <mmorrow> heh, i guess the readM there is defaulting to ()
00:06:16 <ksf> nah, print is.
00:06:23 <ksf> :t  fmap readM . lines =<< getContents
00:06:24 <lambdabot>     Couldn't match expected type `[String]'
00:06:24 <lambdabot>            against inferred type `IO String'
00:06:24 <lambdabot>     In the second argument of `(=<<)', namely `getContents'
00:06:33 <mmorrow> @type read . show
00:06:35 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
00:06:39 <mmorrow> @type show . read
00:06:40 <lambdabot> String -> String
00:06:51 <mmorrow> i meant
00:07:08 <ksf> :t  fmap readM $ lines =<< getContents
00:07:10 <lambdabot>     Couldn't match expected type `[String]'
00:07:10 <lambdabot>            against inferred type `IO String'
00:07:10 <lambdabot>     In the second argument of `(=<<)', namely `getContents'
00:07:14 <mmorrow> so it's probably defaulting to () in the hidden type between the Strings
00:07:37 <mmorrow> , (show . read) "42"
00:07:39 <ksf> I'm struck by type blindness.
00:07:39 <lunabot>  luna: Prelude.read: no parse
00:07:42 <mmorrow> , (show . read) "()"
00:07:43 <lunabot>  "()"
00:07:49 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3239#a3239
00:07:57 <mmorrow> , (show . read) "((()))"
00:07:58 <lunabot>  "()"
00:08:35 <ceal> any simpler way to get a list of numbers as input?
00:08:55 <mike-burns> ceal: That's what mmorrow and ksf are working on.
00:08:58 <mmorrow> ceal: we've been taling about this for the last 5 minutes
00:09:06 <ceal> :O
00:09:06 <Axman6> nums <- fmap (map read . words) getLine?
00:09:08 <ksf> I'm still in favour of read "[1,2]" :: [Int]
00:09:24 <ceal> i have nothing coming up about this for the past 5 mins!!
00:09:29 <Axman6> :t fmap (map read . words) getLine
00:09:31 <lambdabot> forall a. (Read a) => IO [a]
00:09:43 <mmorrow> @type fmap read <$> replicateM 10 getLine
00:09:45 <lambdabot> forall a. (Read a) => IO [a]
00:09:51 <mmorrow> @type fmap read <$> replicateM 4 getLine
00:09:53 <lambdabot> forall a. (Read a) => IO [a]
00:10:00 <mike-burns> ceal: "Simpler" is such a subjective word. :)
00:10:01 <mmorrow> @type (fmap read . lines) <$> getContents
00:10:03 <lambdabot> forall a. (Read a) => IO [a]
00:10:33 <ceal> mike-burns: i meant a way without forM
00:10:42 <mmorrow> @type (fmap read . lines) <$> getContents :: IO [Integer]
00:10:44 <lambdabot> IO [Integer]
00:10:48 <dobblego> ceal, do number <- readLn; return number -- is the same as: readLn
00:11:25 <ksf> and you can switch forM with forM_ and leave out the lambda.
00:11:35 <ceal> dobblego: ok
00:11:47 <ceal> ksf:ok
00:11:48 <ksf> then you've got list <- forM_ [1..m] readLn
00:11:50 <mmorrow> @type \n -> replicateM n readLn
00:11:51 <lambdabot> forall a. (Read a) => Int -> IO [a]
00:12:11 <mmorrow> ceal: replicateM is what you want
00:13:03 <ceal> mmorrow:but how do i specify the terminating condition?
00:13:08 <ksf> hmmm yes although it shouldn't even have a runtime difference to a list.
00:13:24 <ksf> replicateM m readLn
00:13:34 <mmorrow> ceal: so the terminating condition depends on the most recently read value?
00:13:36 <ksf> ...gives you m readLines.
00:13:40 <ceal> yes
00:14:12 <ceal> i'm preparing for coding contest and my base lang is haskell
00:14:38 <ceal> so one set of inputs depends on the preceding one
00:14:41 <ksf> :t mapM
00:14:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:14:58 <mmorrow> so you'll need to accumulate a list, then reverse
00:15:08 <mmorrow> well, not true
00:15:28 <ksf> hmmm foldr something replicateM readLn
00:15:49 <ksf> nah, not replicateM, the infinite one.
00:15:56 <mmorrow> getStuff p = do l <- readLn; if p l then return [l] else (l:) <$> getStuff p
00:16:01 <mmorrow> @type let getStuff p = do l <- readLn; if p l then return [l] else (l:) <$> getStuff p in getStuff
00:16:03 <lambdabot> forall a. (Read a) => (a -> Bool) -> IO [a]
00:16:15 <mmorrow> that uses the stack to accum the list
00:16:29 <mmorrow> @type let getStuff p = do l <- readLn; if p l then return [l] else (l:) <$> unsafeInterleaveIO (getStuff p) in getStuff
00:16:29 <ksf> that is, replace your end-of-input number with a [], in the same function that takes the String to Int
00:16:31 <lambdabot> Not in scope: `unsafeInterleaveIO'
00:16:33 <mmorrow> gets it lazily
00:17:57 <mmorrow> readUntilM p = = do l <- readLn; if p l then return [l] else (l:) <$> readUntil p
00:18:55 <mmorrow> if m is a Monad, (f <$> m === return . f =<< m === f `fmap` m === f `liftM` m)
00:19:29 <mmorrow> (assuming someone wrote the trivial Functor and Applicative instances for that monad)
00:20:08 <mmorrow> *if the type of `m' is a monad i should have said
00:21:09 <mmorrow> readUntilM (< (4::Int)) :: IO [Int] -- e.g.
01:28:39 <ksf> what's up with haskell.org?
01:29:11 <ksf> http://downforeveryoneorjustme.com/haskell.org
01:29:12 <mmorrow> do you mean down?
01:29:26 <ksf> connection timeout, yes.
01:29:57 * mmorrow notes that a bad joke is even worse when it's ambiguous that it's a joke to begin with
01:30:20 <mmorrow> yeah, down for me
01:31:10 * ksf kindly asks the universe to stop conspiring against him.
01:39:43 <Tobsan> good morning!
01:39:55 <matsuura> hi
01:39:58 <matsuura> http://www.galois.com/files/Cryptol/Cryptol_Programming_Guide.pdf
01:48:22 <Axman6> matsuura: how goes the haskell learning?
01:48:30 <matsuura> hmm
01:49:07 <matsuura> slow.. I hate this tutorial.. it's very boring.. not much voice. However, I have finals this week so i've been studying
01:49:12 <matsuura> plan to get back on it soon :)
01:49:15 <matsuura> Wednesday
01:52:19 <PeakerWork> matsuura: have you tried BONUS's Learn you a Haskell?
01:52:42 <matsuura> PeakerWork: probably not
01:52:52 <gwern> @quote i.*heard
01:52:52 <lambdabot> ddarius says: [re: a40a15cb.0304160038.585f3e8@posting.google.com ] The best thing to get out of this, I guess,is that Haskell IS becoming more mainstream and even morons have heard of it.
01:52:56 <gwern> @quote i.*heard
01:52:56 <Axman6> prbably not?
01:52:57 <lambdabot> NeilBrown says: I heard that if you chant "I don't think this can be done in Haskell" three times in front of a text editor, Don Stewart appears and implements it in one line...
01:53:06 <gwern> @quote i.heard
01:53:07 <lambdabot> mauke says: YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
01:53:07 <matsuura> as in, no
01:53:16 <gwern> @quote i.heard.there.were
01:53:16 <lambdabot> dons says: i heard there were webservers written in languages other than haskell
01:53:29 <gwern> @quote most.functional.channel
01:53:29 <lambdabot> yrlnry2 says: #haskell is the most functional channel I've ever seen.
01:53:42 <gwern> @quote Bolivia
01:53:43 <lambdabot> JonFairbairn says: And one of the tests failed because Bolivia is now the Plurinational State of Bolivia, so I've add a patch for that. I've seen politics get in the way of programming, but I've
01:53:43 <lambdabot> never had a bug caused by /international/ politics before.
01:53:53 <Axman6> matsuura: what have you been following? (i did tell you to use lyah at least twice i think;))
01:53:56 <gwern> @quote asinorum
01:53:57 <lambdabot> Adamant says: ah, monads. the pons asinorum of Haskell.
01:54:06 <gwern> @quote two.thunk
01:54:07 <lambdabot> QP says: i drink i'm two thunk for this... i'm seeing (Double, Double)
01:54:15 <matsuura> Axman6: lyah
01:54:23 <Axman6> @where lyah
01:54:23 <lambdabot> www.learnyouahaskell.com
01:54:25 <gwern> @quote bad.I.left
01:54:26 <lambdabot> jfredett says: <shapr> @yow ! <jfredett> YOW! I seem to SEE a SHAPR asking for FUNNY ZIPPY QUOTES    TOO bad I left them in my OTHER PANTS
01:54:37 <matsuura> Axman6: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
01:54:39 <gwern> @quote vacuum
01:54:39 <lambdabot> Berengal says: Anyone doubting the immutable value philosophy needs to try vacuum
01:54:47 <matsuura> Axman6: right there atm
01:54:52 <Axman6> ok, good
01:54:53 <gwern> @quote medicate
01:54:54 <lambdabot> badsheepy says: my word, i feel immediately compelled to medicate myself.
01:54:58 <matsuura> Axman6: just boring
01:55:01 <gwern> hm.
01:55:02 <matsuura> so slow
01:55:02 <gwern> @quote medicate
01:55:03 <lambdabot> badsheepy says: my word, i feel immediately compelled to medicate myself.
01:55:06 <gwern> @quote medicate
01:55:06 <lambdabot> badsheepy says: my word, i feel immediately compelled to medicate myself.
01:55:14 <Axman6> so the correct answer to PeakerWork's question would be 'yes' then ;)
01:55:22 <rage-chan> i love haskell
01:55:25 <Axman6> gwern: having fun there?
01:55:26 <gwern> @forget badsheepy my word, i feel immediately compelled to medicate myself.
01:55:26 <lambdabot> Done.
01:55:38 <gwern> @remember badsheepy [in response to a spammer] my word, i feel immediately compelled to medicate myself.
01:55:38 <lambdabot> Done.
01:55:43 <PeakerWork> matsuura: you can skim the parts that are too slow?
01:55:50 <gwern> Axman6: epsilon fun, yes
01:55:55 <matsuura> PeakerWork: idk
01:55:58 <matsuura> maybe
01:55:59 <gwern> @quote meta.topics
01:56:00 <lambdabot> monochrom says: Haskell has solved programming. All that can be said programming is already said in tutorials and the haskell wiki. That is why we drift to meta topics.
01:56:14 <gwern> @quote 20
01:56:14 <lambdabot> ari says: The problem I have with grues is that although I know that currently, if it is very dark I am likely to be eaten by one... but how can I tell if grue suddenly became benign at, say, the
01:56:14 <lambdabot> year 2010? The evidence I've gathered so far can't support the idea that that *wouldn't* happen.~
01:56:22 <gwern> hahaha
01:56:28 * gwern wonders how many people get that one
01:56:51 <gwern> @quote 10.*20
01:56:52 <lambdabot> < says: yottis> i thought there were like 10 haskell jobs in the world, all in the "let's replace excel sheets with something else" industry < kalven> there are at least 20
01:57:05 <gwern> @quote four.horsemen
01:57:05 <lambdabot> BMeph says: okmij.net, conal.net, comonad.reader, and sigfpe.blogspot.com; the four horsemen of the Haskell Apocalypse.
01:57:18 <gwern> @quote but.i.need.to
01:57:18 <lambdabot> jaredj says: [on parsec] i thought i got it but i need to 'try' again
01:57:26 <gwern> @quote nerdcore
01:57:27 <lambdabot> gwern says: *ponders Haskell nerdcore: 'I'm all about exact math, yo; I eat CReal for breakfast'*
01:57:40 <gwern> @quote comments.*space
01:57:41 <lambdabot> Baughn says: remember that comments take up space in compiled Haskell programs, and furthermore they take up processing time if execution passes through them. For these reasons, keep comments to a
01:57:41 <lambdabot> minimum, and never put comments inside of optimized Haskell code. Ideally all of your comments will lie outside of the path of execution.
01:57:57 <gwern> @quote Assimilation
01:57:58 <lambdabot> No quotes match. Where did you learn to type?
01:58:04 <gwern> @quote Monday
01:58:05 <lambdabot> No quotes match. My pet ferret can type better than you!
01:58:11 <mgsloan> @. quote elite gwern
01:58:11 <lambdabot> No quotes match. My mind is going. I can feel it.
01:58:16 <Axman6> bleh, this week's concurrent systems lab is going to be no fun :( http://cs.anu.edu.au/student/comp2310/labwork/Lab-2.php
01:58:17 <gwern> @remember gbacon okay, I just tried to type Monday, but it came out Monady. Assimilation complete.
01:58:17 <lambdabot> Okay.
01:58:28 <mgsloan> @. quote elite bacon
01:58:28 <lambdabot> gwern says: drat. what *do* all you people talk about? only one bacon and one zombie quote
01:58:35 <gwern> @quote Velvet.Underground
01:58:36 <lambdabot> BenLippmeier says: Are Haskell and O’Caml destined to be The Velvet Underground of programming languages, where hardly anyone has heard them, but everyone who does forms a band?
01:58:41 <gwern> @flush
01:58:50 <gwern> only one missing quote. lambdabot's uptime is improving
01:59:08 <Axman6> heh
02:03:55 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3240#a3240
02:04:55 <ceal> what does this error mean?
02:05:04 <ceal> wait is it an error?
02:05:08 <Axman6> well, you've only got 23 numbers
02:05:15 <ceal> ?
02:05:18 <Axman6> it's trying to read a 24th, but there's nothing there
02:05:31 <ceal> oh!!
02:05:32 <Axman6> first line says how many lines are to follow right?
02:05:36 <ceal> yeah
02:06:08 <ceal> got it :)
02:06:25 <ceal> anyway what does that error mean Axman6?
02:06:31 <ceal> is it EOF?
02:06:36 <Axman6> i guess
02:06:51 <ceal> any idea wat is hgetline?
02:07:15 <Axman6> @src getLine
02:07:16 <lambdabot> getLine = hGetLine stdin
02:08:00 <ceal> Axman6:how do you do that?
02:08:09 <ceal> the search thing?
02:08:13 <ceal> at lambdabot?
02:08:20 <Axman6> i've seen it before
02:08:30 <ceal> any others you know?
02:08:34 <ceal> commands?
02:08:41 <ceal> "commands"?
02:08:53 <Axman6> @hoogle (a -> b) -> [a] -> [b]
02:08:53 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
02:08:53 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
02:08:53 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
02:09:07 <Axman6> @hoogle maybe
02:09:07 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
02:09:07 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
02:09:07 <lambdabot> module Data.Maybe
02:09:29 <ceal> what is it that comes after @?
02:09:39 <ceal> i know hoogle is a search engine
02:09:40 <Axman6> @list
02:09:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:09:54 <Axman6> ceal: go to that address and find out what you can do
02:09:57 <ceal> thanks
02:11:46 <ceal> @hoogle mapM
02:11:47 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:11:47 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:11:47 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:11:53 <Axman6> :t let x = x + 1 in x
02:11:54 <lambdabot> forall a. (Num a) => a
02:12:03 <Axman6> > let x = x + 1 in x
02:12:08 <lambdabot>   mueval-core: Prelude.read: no parse
02:12:08 <lambdabot>  mueval: ExitFailure 1
02:12:30 <Axman6> > let x = (+) 1 $! x in x
02:12:35 <lambdabot>   mueval-core: Prelude.read: no parse
02:12:35 <lambdabot>  mueval: ExitFailure 1
02:13:32 <ceal> suppose i have taken a list how can i print the 2nd element?
02:13:42 <ceal> i tried list !! 2; did't work...
02:13:53 <ceal> print list !! 2 that's the code
02:14:02 <ceal> verbatim
02:14:12 <ziman> it's parenthesizing, function application binds stronger than !!
02:14:15 <Axman6> print (list !! 2)
02:14:25 <ceal> that didn't work either...
02:14:26 <ziman> so tha code you've written parses as: (print list) !! 2
02:15:05 <ceal> ziman: ok
02:15:11 <ceal> :t print
02:15:12 <lambdabot> forall a. (Show a) => a -> IO ()
02:15:20 <ceal> :t show
02:15:21 <lambdabot> forall a. (Show a) => a -> String
02:15:27 <ziman> ceal, what's the error message? note that it's a monadic action
02:15:47 <ceal> let me try it again i think i made a typo
02:16:18 <ceal> yup typo: i mixed $ and paranthesizing
02:16:25 <ceal> accidently
02:16:44 <Axman6> well, $ does paranthesising
02:16:57 <Axman6> if you had print $ list !! 2, that would work
02:22:14 <Heavensrevenge> hello
02:22:27 <matsuura> Hello
02:23:25 <Heavensrevenge> ive been wondering, has there ever been a type system which has been combined with a permission system to which would control an underlying program execution??
02:23:45 <Heavensrevenge> so a dual type + permission system in the compiler to create the binary?
02:24:07 <Elly> a permission system on the variables in the program?
02:24:23 <Heavensrevenge> declared with each type declaration
02:24:25 <ceal> is there an sdk for haskell?
02:24:51 <Heavensrevenge> like say inputs of type + permission, and has outputs of type + a different permissino level
02:25:02 * Axman6 doesn't think that languages come with SDK's, but are used in them
02:25:12 <lament> languages with single digit kyus?
02:26:14 <Heavensrevenge> so maybe... somthing like:
02:26:18 <Heavensrevenge> length :: [a] -> Int
02:26:26 <lament> Axman6: it's fair to say that C# comes with an SDK, for example
02:26:32 <Heavensrevenge> length :: [rrr] -> rw-
02:26:36 <ceal> :( i meant any sdk that supports haskell'
02:26:45 <Heavensrevenge> a permission system declared directly with the types
02:26:45 <lament> Axman6: and Objective C
02:26:59 <ceal> i found one online site that has contests where you can write the code in haskell
02:27:13 <ceal> maybe you guys could try it out: no one codes in haskell there i think
02:27:20 <ceal> codechef.com
02:27:57 <ceal> so any sdk supports haskell?
02:28:23 <Heavensrevenge> or say a unix permission system 124 based together with the type system to allow a way to control some interesting programatic properties of the resulting object code
02:29:01 <Heavensrevenge> and yes im just throwing this idea out there since i think it would go perfect with a type system like haskells :P
02:29:25 <PeakerWork> wouldn't it be cool if ghc -Wall only warned about missing type signatures of *exported* top-level names, rather than all top-level names?
02:29:47 <PeakerWork> Heavensrevenge: Do you know "object capabilities"?
02:30:42 <PeakerWork> Heavensrevenge: Unix-like permissions, also called "Access Control Lists" (even if Unix's ACLs are in a separate /etc/group file, and not attached to each object), are a really bad idea, and you can use argument passing for much better security
02:30:48 <Heavensrevenge> "object capabilities" nobut it seems like it may be along the lines of what im thinking
02:31:06 <PeakerWork> (If you don't have something in scope, you can't access it, unless you're given it as an argument)
02:31:29 <PeakerWork> The global namespace of modules breaks this model, making everything in scope
02:31:43 <Heavensrevenge> what if the permission levels are so finely scoped its put into the binary as a permission bitmask of sorts
02:32:14 <Heavensrevenge> not file specific granularity, but FAR FINER grained security models in the actual C-- output
02:32:58 <Heavensrevenge> accessible to only some cave inside ghc which i havent even dreamt in nightmares lol
02:33:37 <Heavensrevenge> im just postulating that pairing a type system with a security model in some form by that granularity, might be the only way at which security can be closer to a true solution
02:35:37 <ksf> ceal, there's leksah, and also an eclipse mode. most people just use vim or yi, though, or, heaven forbid, emacs.
02:35:41 <Heavensrevenge> instead of only thinking of a type system by itself as a separate entity, maybe the preprocessed system is still an incomplete beast which were ignoring, and not only need a type system but a "next step" of types plus access controlls on code executing in the core machine level??
02:36:05 <ceal> ksf: thanks
02:36:40 <ksf> ...just try "cabal install leksah"
02:37:29 <ksf> haskell's openGL bindings are sufficiently different from the C api to make me completely lost.
02:37:55 <ksf> basically, I'm grepping for c function names in the binding source to figure out what to call.
02:38:59 <Heavensrevenge> i am of course just postulating, but i see some light if i think about ghc in a way which couples almost a tuple of (types, permissions) as the a real type definition for a function :)
02:39:17 <ksf> ...and am _very_ anxious about texSubImage2D not appearing to support float textures.
02:39:24 <Heavensrevenge> glad to hear what some of you thought, i had to get it off of my mind at this late hour :P
02:39:58 <ksf> uhm... don't permissions change, from time to time?
02:42:40 <ksf> are devs of the opengl bindings known to hang out here?
02:44:21 <alc> rwh example codes ch11 -- cat compile: Run.hs:23:14: Not in scope: `prop_puncutate'
02:44:23 <alc> a typo
02:44:39 <alc> should be prop_punctuate
02:44:54 <alc> s/cat/cant/
02:45:15 <Axman6> s/cant/can't/?
02:45:42 <alc> also in Run2.hs
02:45:48 <alc> Axman6: ok.. =)
02:48:26 <jeffz`> ksf, hopengl mailing list is the best place to get a response
02:51:34 <alc> so who/where should i report this? dons?  is there a updated version of rwh examples? preferably a git/hg/darcs repo?
02:53:22 <alc> dons: http://examples.oreilly.com/9780596514983/rwh-examples2.zip  is where i got the code -- ch11/Run.hs and ch11/Run2.hs contain that typo which causes the compile error
02:55:05 <PeakerWork> Heavensrevenge: Permissions should be united with authority, which should be united with accessibility, so that if you can request something, you're allowed to.  There should be not "security checks" or such
02:56:00 * ksf thinks hiding everything has too great a usability impact.
02:56:02 <PeakerWork> Heavensrevenge: That's the "object capability" model, which gets rid of all extra "permission information" in the underlying system (it allows you to create object proxies that restrict access in some ways). As opposed to the "ambient authority" model
02:56:15 <PeakerWork> ksf: Only things that you are *not allowed* to use will be hidden
02:56:29 <PeakerWork> ksf: so instead of getting a "permission denied", they'll simply be out of your reach
02:56:48 <ksf> well, but I might search for stuff as a user, and then get root permissions to actually access it.
02:57:12 <PeakerWork> ksf: Well, the "root" user is another thing to get rid of :)
02:57:19 <PeakerWork> ksf: its about replacing the whole unix model
02:57:24 <PeakerWork> (of security)
02:58:56 <PeakerWork> In today's systems, we have a graph of accessibility of objects that includes global namespaces (the file system root) and everyone can see everyone, and then we mask this with a complex permission scheme to limit the parts of the graph we can touch, and then we have to: A) Tell each program what objects to use (via UI file selection, or configuration files) B) Permit each program to access the files we had just configured.      With ob
02:58:56 <PeakerWork> jcaps, A and B are united into one
02:59:47 <ksf> so I won't be able to do du -sch /* as root, anymore?
03:02:58 <PeakerWork> ksf: if you have the reference to the disk storage manager, you can ask him. You can probably not see the files and sizes of *everything* in the system, no
03:03:39 <PeakerWork> ksf: Actually, if you have this (extremely strong) capability/reference to the storage implementation, you can do that, but you probably wouldn't want to expose that capability too much
03:03:55 <ksf> ...so I can't delete someone's pr0n collection to make room for a system update?
03:05:04 <PeakerWork> ksf: An administrator can have some of root's god-like powers, by having caps into low-level implementation components -- but that is not a root "user", its a set of capabilities that can be put in a single container for multiple programs representing users to see, or spread in any way you'd like
03:05:12 <PeakerWork> ksf: there's no "sudo"
03:05:44 <PeakerWork> Either you have access to the capability somehow, or you don't - if you do, you use it directly, you don't use it as some authentication into a super-powered API that checks that you actually have it
03:06:02 <ksf> but there's "get me this keyring and pass it to that app"
03:06:46 <ksf> well, _I_ certainly don't want to have all my rights all the time.
03:06:52 <PeakerWork> ksf: Why would you pass a keyring, and not individual caps to do individual things?
03:07:27 <ksf> because I don't want to have different passwords for accessing /var/log and /dev/kmem?
03:07:32 <PeakerWork> ksf: If you run Solitaire, you pass it a capability to open a window and draw in it, and to read the mouse position, and a cap to a pipe reading keyboard input when its in focus
03:07:59 <PeakerWork> ksf: why different passwords?  Its just a cap you have stored somewhere accessible to you through the secure GUI shell, not accessible to any program that you don't explicitly give it o
03:08:15 <rabideejit> Greetings.  I wonder if anyone can help I've written a small object/functional language with a bytecode compiler and a virtual machine, but I'm experiencing some garbage collection problems.
03:08:17 <PeakerWork> ksf: e.g: One UI could be: Drag & Drop cap to a program to give it to it, otherwise it cannot access it
03:08:22 <ksf> "secure GUI shell" makes me whince.
03:08:30 <PeakerWork> ksf: It can also have a textual interface :-)
03:08:40 <PeakerWork> rabideejit: what's an "object/functional language"?
03:08:58 <PeakerWork> ksf: the idea is that capabilities are not "asked for" or "pulled" from some global namespace, they are pushed/given to whoever needs them
03:09:03 <ksf> ...and then people are going to shout for a monadic interface, and that's where su comes into the picture, again.
03:09:23 <ksf> you don't ask for permission under unix.
03:09:28 <ksf> you just do, and might fail.
03:09:36 <alc> @tell dons http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3241
03:09:36 <lambdabot> Consider it noted.
03:09:51 <PeakerWork> ksf: shout for a monadic interface of what?
03:10:01 <PeakerWork> ksf: a monadic interface does not mean you magically get capabilities given to you
03:10:01 <ksf> passing capabilities.
03:10:25 <ksf> "switch me to a mode that gives programs I run these and these capabilities"
03:10:28 <PeakerWork> ksf: A monadic interface can be used to make passing capabilities less work, but you're still explicitly passing them
03:10:49 <rabideejit> peakerwork: I would call it such, it uses s-expressions for syntax, but objects rather than lists for data ( essentially, atm these are maps which can store code or data) - methods work upon the scope of the object currently loaded into memory, but closures work upon the object which was loaded in to memory at the moment they were defined.  It's one of these impure languages.  I want to write a type checker like haskells, because t
03:10:51 <PeakerWork> ksf: Why monadically? Just partially apply those programs to the caps you want them to use
03:10:57 <ksf> well, that's what your're doing in unix by being logged in as a user.
03:11:21 <PeakerWork> ksf: But the problem is that everything runs as a user - and gets the same permissions.  When I run solitaire it can delete my files
03:11:40 <PeakerWork> ksf: Solitaire already specifies what it can do, but I have to RE-specify it in authority lists if I want to limit solitaire not to delete my files
03:11:42 <ksf> yep, but that's a question of granularity, not concept.
03:11:56 <PeakerWork> ksf: Its a question of concept too, because ACL's+users are not equivalent to capabilities
03:12:13 <PeakerWork> http://srl.cs.jhu.edu/pubs/SRL2003-02.pdf
03:12:43 <PeakerWork> ksf: And, in the Unix concept, how can I run solitaire while giving it exactly the caps to do what it needs to do?
03:13:25 <ksf> you switch to the "solitaire" user, which has its rights restricted to what solitaire needs.
03:13:28 <rabideejit> The problem I have is this: I piggy back upon the GHC runtime garbage collector which picks up objects as they drop out of scope.  This works fine for tail recursion, while manipulation the vms various nobs and brackets, by assigning variables, calling functions in between, without an increase in memory use.  However when I start loading and saving continuations, the system begins to leak.
03:13:34 <PeakerWork> ksf: and how do I create this user?
03:13:50 <ksf> whether you specify these rights additively or subtractively doesn't matter.
03:14:04 <PeakerWork> ksf: how can I, as a non-root user, limit permissions of programs I run?
03:14:29 <ksf> now we're talking.
03:14:30 <rabideejit> This is puzzling, because I can dump the whole contents of the virtual machine at any point, and I can see the continuation in memory -- the system is finite, I can see graphically it does not grow.
03:14:51 <rabideejit> Biographical profiling says the memory is all in "use" however.
03:14:54 <rabideejit> I am puzzled!
03:14:55 <ksf> but /home/Peaker/passwd isn't unimaginable, is it?
03:17:38 <PeakerWork> ksf: Move to -blah ?
03:20:19 <rabideejit> Am I right in thinking GHC does not collect unevaluated thunks?
03:23:08 <rabideejit> I was thinking, somehow if GHC thinks the continuation is unevaluated somewhere, perhaps I could recurse through the continuation associated state, and strictly evaluate the whole thing.  Then GHC could GC.  Has anyone done anything like this before?  Would it work?
03:23:54 <rabideejit> Also, if the old continuations drop out of scope, like I can graphically verify, then why does biographical profiling suggest the memory is "in use"?  Do unevaluated thunks count as "in use" even if they are long gone?
03:26:25 <rabideejit> Ah, I'm sorry, so many questions.  It is a testament to my poor skills :p  However, I'd like to keep the VM in haskell, because it's already kinda speedy, rather than write it in a lower level language -- even though then I could precisely manage my own memory.
03:28:24 <Berengal> rabideejit: It should collect thunks. Perhaps you're unwittingly leaving references to them?
03:28:34 <rabideejit> It is my fear.
03:28:50 <leo_> Monad.RWS - is it the combined reader/writer/state?
03:29:37 <Berengal> leo_: Yes
03:30:02 <Berengal> Often confused with Real World SNOBOL, a pretty decent book on SNOBOL
03:30:29 <leo_> SNOBOL?
03:30:33 <rabideejit> There's a language in which I have never programmed.
03:31:09 <Berengal> Wow... Wikipedia: "The source code for MACRO SPITBOL was released under the GNU General Public License.[2] on April 17, 2009."
03:31:19 <Berengal> (SPITBOL being an implementation of SNOBOL)
03:33:19 <rabideejit> Reading the wikipedia, it sort of reminds me of thue
03:34:44 <rabideejit> I mean that in a completely harmless sense.  I'm not saying it looks impractical!  Just the patterns remind of the the thue grammar.
03:38:16 <ksf> ...SNOBish Organisation Language.
03:42:52 <rabideejit> ... or there'SNO language like Business Oriented Language
03:43:37 <rabideejit> Apparantly says the article, they struggled at first for backronyms.
03:58:53 <ksf> shouldn't every data type come with a typeclass that implements toTypeFoo?
03:59:31 <ksf> I'm staring at Data.Trie and would love "Bytestring k => Trie k v"
04:02:25 <ksf> as another thought, one could parametrize the whole module... specifying a bijection to take some type from and to KeyString, changing every exported type.
04:03:15 <ksf> ...so you could just take Monads to WarmFuzzyThings.
04:08:50 <rabideejit> Really what haskell needs is a graphical pretty printer like FORTRESS, but one with pictures, so people can actually see the conveyor belt/astronaut/robot metaphor.
04:11:45 <rabideejit> yay!  I found my leak
04:12:35 <Axman6> plug it!
04:12:37 <rabideejit> I'm always rather proud when this happens, despite the fact that I designed and implemented the leak.
04:14:04 <rabideejit> Gotta love visualizations, the other cool thing is that the VM dump resembles the syntax of the source language, since it is quite simple, so I can view it with the same syntax highlighter which makes me happy.
04:14:47 <rabideejit> Now where are my plugs?
05:00:18 <lpsmith> w00t!   I finally coded up my asymptotically efficient lucky number sieve.
05:00:25 <lpsmith> It appears to work
05:00:41 <lpsmith> and it is quite fast
05:01:04 <Axman6> what are my lucky numbers? :o
05:01:29 <lpsmith> uhh,  3,  7, 8, 13, and 15
05:03:08 <lpsmith> Well, I wrote the first version in C anyway,  maybe I'll code it up later again in Haskell :-P
05:03:48 <leo_> lpsmith, what criteria do you use to determine whether the number is lucky or not?
05:04:07 <leo_> personally I don't think that 8 is a lucky number
05:04:16 <lpsmith> http://en.wikipedia.org/wiki/Lucky_number
05:04:24 <lpsmith> err,  sorry,  that should've been a 9 :-)
05:06:56 * abbe points everyone to his new web server code (inspired from rephttpd) at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3242#a3242
05:15:21 <abbe> @fortune
05:15:21 <lambdabot> Alcohol, hashish, prussic acid, strychnine are weak dilutions. The surest
05:15:21 <lambdabot> poison is time.
05:15:21 <lambdabot> 		-- Emerson, "Society and Solitude"
05:17:18 <skorpan> Emerson, is a former Brazilian footballer, who played as a defensive midfielder.
05:17:23 <skorpan> i did not know he was sod eep
05:17:25 <skorpan> so deep
05:18:11 <mauke> didn't he also play in a band?
05:21:07 <gwern> mauke: no, this emerson is the one who became an actor
05:27:32 <ceal> what is the equality operator?
05:27:41 <ceal> is it '==' or '='
05:27:45 <ceal> ?
05:27:46 <mauke> > 1 = 2
05:27:48 <lambdabot>   <no location info>: parse error on input `='
05:27:49 <mauke> > 1 == 2
05:27:51 <lambdabot>   False
05:28:01 <mauke> that wasn't so hard
05:28:22 <ceal> thanks mauke; well i somehow keep getting an error; so i thought i'd just confirm
05:29:04 <ceal> mauke: so if i give a statement after >, lambdabot returns the result?
05:29:17 <mauke> an expression, not a statement, but yes
05:29:21 <elbar> > True
05:29:22 <lambdabot>   True
05:29:26 <ceal> sorry typo :D
05:29:37 <mauke> but you can do the same thing in hugs/ghci
05:30:28 <ceal> of course you can; but it's something new to me as to what i can do in IRC channel
05:31:33 <mauke> @list
05:31:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:31:45 <Raevel> magirc
05:31:50 <mauke> @quote
05:31:50 <lambdabot> nocotigo says: if you can't tell what encoding the code is in, I'd say you've gone too far
05:35:07 <ceal> @exit
05:35:07 <lambdabot> Maybe you meant: elite quit
05:35:12 <ceal> @quit
05:35:13 <lambdabot> Not enough privileges
05:35:23 <ceal> @hoogle exit
05:35:24 <lambdabot> module System.Exit
05:35:24 <lambdabot> System.Exit data ExitCode
05:35:24 <lambdabot> Control.Exception ExitException :: ExitCode -> Exception
05:35:32 <ceal> @hoogle quit
05:35:32 <lambdabot> No results found
05:35:40 <ceal> @hoogle return
05:35:40 <lambdabot> Prelude return :: Monad m => a -> m a
05:35:40 <lambdabot> Control.Monad return :: Monad m => a -> m a
05:35:40 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
05:36:20 <ceal> @hoogle return()
05:36:21 <lambdabot> Distribution.Make defaultMain :: IO ()
05:36:21 <lambdabot> Distribution.Simple defaultMain :: IO ()
05:36:21 <lambdabot> System.Mem performGC :: IO ()
05:37:23 <ceal> how do i exit from a program if a particular condition is satisfied?
05:37:38 <ceal> i tried return() but it simply skips that condition and goes on to the next one
05:37:43 <ceal> and i get EOF error
05:38:01 <ceal> i want to exit if (num == 30)
05:38:06 <ceal> what
05:38:25 <ceal> what's the function/statement/command for that?
05:38:47 <Botje> can you show code?
05:39:21 <ceal> Botje:sure thing hold on
05:39:32 <mauke> :t exitWith
05:39:34 <lambdabot> Not in scope: `exitWith'
05:39:43 <mauke> @hoogle exitWith
05:39:44 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
05:39:58 <mauke> return is just a constructor, it doesn't go anywhere
05:41:12 <ceal> botje:http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3243#a3243
05:41:41 <mauke> well, that works
05:41:49 <mauke> you forgot a 'do' after 'else'
05:42:07 <fbru02> for what i understand return takes a not monadic value and lifts it up to the monad, you commonly use it for mixing pure code with code that have a side effect.
05:42:29 <ceal> mauke: a do is necessary?
05:42:37 <Botje> yes
05:42:40 <ksf> ...return should've been called pure, to prevent confusion.
05:42:41 <mauke> well, if you want to use that syntax
05:42:51 <mauke> you could also write '... else print n >> main'
05:43:07 <mauke> btw, are you solving http://www.spoj.pl/problems/TEST/ ?
05:43:39 <ceal> no; i
05:43:46 <ceal> i'm doing code chef
05:43:56 <ceal> codechef.com
05:44:10 <Axman6> fbru02: monads aren't about side effects
05:44:16 <ceal> mauke: what does >> do?
05:44:23 <Axman6> @src (>>)
05:44:23 <lambdabot> m >> k      = m >>= \_ -> k
05:44:23 <mauke> ceal: combines two actions into one
05:44:24 <ksf> :t (>>)
05:44:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
05:44:40 <mauke> ceal: see also http://mauke.ath.cx/stuff/haskell/how-to-io.html
05:45:56 <ceal> mauke: thanks
05:47:52 <Axman6> (or http://random.axman6.com/blog/?page_id=70 >_>)
05:47:53 <fbru02> Axman6 : what do u mean ? i know monads are type constructors
05:47:59 <ksf> isn't it puts = mapM_ putc?
05:48:18 <ksf> nah, monad's aren't type constructors.
05:48:27 <ksf> they're monoids in the category of endofunctors.
05:48:48 <Axman6> fbru02: you said "...use it for mixing pure code with code that have a side effect"
05:50:20 <ksf> ...and return is a typeclass member not a constructor, to continue nitpicking.
05:50:47 <fbru02> Axman6: im a noob, but from my POV return does just that , you get a value coming from a pure function and with return you can mix it in a do block for example which has type IO () something for example
05:51:13 <Axman6> fbru02: do lists have side effects? or Maybe?
05:51:23 <Axman6> they're both monads
05:51:34 <ksf> > return 1 :: [Int]
05:51:35 <lambdabot>   [1]
05:51:42 <ksf> did that have a side effect?
05:51:52 <Axman6> people often confuse monads with side effects because the first time they find out about monads and do notation is with the IO monad
05:51:59 <Axman6> ksf: it got printed >_>
05:52:02 <ziman> :t (>=>)
05:52:04 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:52:17 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3243#a3243
05:52:30 <ceal> i added a do; no use: still same output
05:52:40 <ziman> are monads monoids with respect to return and kleisli compose?
05:52:44 <Botje> uh, where did you add the do?
05:52:47 <Axman6> ceal: you need else do ...
05:53:27 <ksf> shouldn't that give a parse error?
05:53:36 <ceal> yeah i just updated it: do is there in it
05:53:36 <ksf> or does it see "main" as an argument to "print"?
05:53:45 <ceal> i still get same error
05:54:00 <ceal> it encounters 42, skips it and goes on to the next case
05:54:30 <Botje> ceal: are you sure your indentation is correct?
05:54:39 <Botje> i annotated your paste
05:54:49 <ksf> works fine, here.
05:54:52 <ksf> (with do)
05:54:52 <mauke> Botje: your "fixed" version contains a tab
05:54:53 <ceal> i shall copy the exact code
05:54:57 <Botje> it does?
05:54:58 <fbru02> Axman6, ksf : sorry  im still working on my intuition on this , i visualize it as monoadic code can produce a "side-efefect" as a value displayed on screen for example when you do a computation go from a -> b , non-monadic code  doesnt have this property it goes from a->b without doing much else
05:54:59 <Botje> argh
05:55:03 <Botje> :(
05:55:26 <mauke> ceal: the second version in that paste works
05:55:48 <ksf> fbru02, nah, monadic code goes a -> m a .
05:56:03 <Axman6> :t [] return
05:56:04 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3243#a3246
05:56:05 <lambdabot>     Couldn't match expected type `(a -> m a) -> t'
05:56:05 <lambdabot>            against inferred type `[a1]'
05:56:05 <lambdabot>     In the expression: [] return
05:56:08 <Axman6> dang
05:56:11 <ceal> is the code i gave
05:56:17 <ceal> i shall try the second one...
05:56:19 <Axman6> :t (:[])
05:56:21 <lambdabot> forall a. a -> [a]
05:56:31 <Axman6> :t return :: a -> [a]
05:56:33 <lambdabot> forall a. a -> [a]
05:56:41 <ski> Axman6 : monads are about *effects*, though
05:56:45 <ceal> nope i get same error
05:56:46 * Axman6 is impressed that that ligned up perfectly
05:56:56 <Axman6> lined even
05:57:00 <matsuura> haha
05:57:03 <ksf> ceal, try http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3243#a3247
05:57:14 <ksf> ...it's the style you're bound to see most often.
05:57:24 <fbru02> ksf : i dont know what you meant, i mean i understand it , but dont know how that helps my intuition
05:57:27 <ksf> ...just with an indent less.
05:57:30 <mmmulani>  how would I construct a list of (+),(-),(*),(%)?
05:57:46 <Axman6> :t [(+),(-),(*),(%)]
05:57:47 <lambdabot>     Occurs check: cannot construct the infinite type: a = Ratio a
05:57:47 <lambdabot>       Expected type: a
05:57:47 <lambdabot>       Inferred type: Ratio a
05:57:48 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3248#a3248
05:57:52 <ksf> fbru02, you're going to have to write your first, own, monad.
05:57:52 <Axman6> :t [(+),(-),(*)]
05:57:53 <lambdabot> forall a. (Num a) => [a -> a -> a]
05:57:54 <ceal> exact output
05:58:43 <fbru02> ksf : what should I write ? re-write Maybe perhaps ?
05:58:53 <ksf> anything.
05:58:58 <Axman6> @src Maybe (>>=)
05:58:59 <lambdabot> (Just x) >>= k      = k x
05:58:59 <lambdabot> Nothing  >>= _      = Nothing
05:59:09 <ski> fbru02 : if `putStrLn' had type `String -> ()', then it would have a *side*-effect indeed (because the `IO'-effect isn't displayed in the return type, it happens "on the side", i.e. hidden / not declared in the interface/type); however, it has type `String -> IO ()', hence it's not a *side*-effect, but merely an (`IO'-)effect
05:59:33 <ksf> the trick is to see the pattern, and then implement it.
05:59:54 <fbru02> :t putStrLn
05:59:56 <lambdabot> String -> IO ()
06:00:48 <ksf> ...putStrLn "Hello" is a value of type IO (), which, when seen by the run time system, is interpreted as a kind request to do black magic to print "Hello" to stdout.
06:00:49 <fbru02> ski, ksf : thanks , now i get what you mean
06:00:50 <ski> flux : similarly the list monad, and `Maybe' is about certain kind of effects .. if one wanted, one could imagine imperative languages where those effects would be side-effects
06:00:53 <Axman6> :k return
06:00:55 <lambdabot> Not in scope: type variable `return'
06:00:58 <Axman6> bleh
06:01:42 <ceal> @hoogle quit
06:01:43 <lambdabot> No results found
06:01:47 <ceal> @hoogle exit
06:01:47 <lambdabot> module System.Exit
06:01:48 <lambdabot> System.Exit data ExitCode
06:01:48 <lambdabot> Control.Exception ExitException :: ExitCode -> Exception
06:01:51 <ski> fbru02 : in `putStrLn "foo"', the `IO'-effect is contained in the return value of type `IO ()' .. so, no side-effect
06:01:55 <Axman6> @more
06:02:06 <Axman6> @hoogle+
06:02:06 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
06:02:06 <ksf> > System.exitWith System.ExitSuccess
06:02:06 <lambdabot> System.Exit exitFailure :: IO a
06:02:06 <lambdabot> System.Exit ExitSuccess :: ExitCode
06:02:07 <lambdabot>   Not in scope: `System.exitWith'Not in scope: data constructor `System.ExitS...
06:02:20 <ksf> nargh.
06:02:23 <ksf> bad lambdabot.
06:02:27 <ksf> won't kill itself.
06:02:43 <ksf> :t System.exitWith System.ExitSuccess
06:02:45 <lambdabot> forall a. IO a
06:05:06 <ksf> hmmm.... IO could have a monadPlus instance, couldn't it?
06:05:15 <mmmulani> how can I check the type of a parameter?
06:05:21 <ceal> what exactly is wrong : http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3249#a3249?
06:05:26 <ksf> using guards as assertions.
06:05:29 <PeakerWork> ksf: there is one in control.Monad.Error
06:05:36 <ceal> the program should exit when input is 42
06:05:40 <ceal> but it doesn't
06:05:43 <fbru02_> ski : I understand what u mean, it is like you have a side-effect but really it is not because it is explicit in the type definition, but what i meant when i previously stated side-effect is how should i say it a non-deterministic computation in the sense that input from the external world would be accepted
06:06:34 <ceal> @hoogle exit
06:06:35 <lambdabot> module System.Exit
06:06:35 <lambdabot> System.Exit data ExitCode
06:06:35 <lambdabot> Control.Exception ExitException :: ExitCode -> Exception
06:06:51 <ksf> that's cool: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3243#a3250
06:07:02 <PeakerWork> ski: I'd say "described by" and not "contained by"
06:07:34 <ksf> ceal, it _does_ exit.
06:07:50 <ceal> i don't: that's the exact output from the CLI
06:07:57 <ski> PeakerWork : what's the difference ? :)
06:08:37 <ksf> mmmulani, what kind of parameter?
06:08:56 <ksf> arguments to functions always have the type you see in the signature.
06:09:12 <ksf> ...and parameters to the program, as in getArgs, always have type string.
06:09:13 <ski> fbru02_ : non-deterministic computation doesn't really have much to do with accepting external input, afaics
06:09:19 <mauke> ceal: how are you running it?
06:09:21 <PeakerWork> ski: "Containing" it might imply that its done when the value is used/evaluated, rather than when it is executed by the magical rts
06:09:30 <ceal> runhaskell <filename>
06:09:37 <ceal> isn't it correct?
06:09:38 <mmmulani> ksf: hmm, I'm trying to make a function that takes two ratios and returns a ratio
06:09:49 <mmmulani> but also is able to take two integrals and return a ratio
06:09:56 <mauke> ceal: works here
06:09:58 <ksf> % runhaskell test.hs
06:09:58 <ksf> 54
06:09:58 <ksf> 54
06:09:58 <ksf> 42
06:09:58 <ksf> ksf@solaris haskell %
06:10:03 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3243#a3250 didn't work either
06:10:13 <mauke> ... if I use 'return ()' instead of 'exit'
06:10:40 <ksf> ceal, try ghc --make <yourfile> and run the thing.
06:10:51 <ceal> ok
06:11:24 <mauke> ceal: how are you entering the input?
06:11:28 <ski> PeakerWork : i'd say then the effect is not contained, but only the result value from performing the effect ..
06:11:54 <ceal> ksf:same error
06:12:19 <ceal> ./try < inp.txt
06:12:37 <ceal> ksf: i had no luck with ghc --make
06:12:46 <fbru02_> ski : thanks for the tips , this learning Haskell is complicated for me :( but finally i think im getting a sense of it
06:13:03 <mauke> ceal: what happened?
06:13:15 <mauke> oh, but it compiled?
06:13:23 <ski> fbru02_ : there's two kinds of non-deterministic computation i know of : (a) demonic / committed-choice, this is what you get from undefined evaluation order as in concurrency, e.g.; (b) angelic / all-solutions, this is like the list monad, where you execute all possible ways
06:13:50 <ceal> mauke: it goes thru all i/p, skips 42 and continues until EOF is encountered
06:14:37 <mauke> gremlins
06:15:01 <ksf> it works here, even with shell indirection.
06:15:06 <mauke> ceal: start ghci, type 'read "42" == 42'
06:15:42 <ceal> mauke: hold on
06:15:52 <ceal> shouldn't it return false?
06:16:00 <mauke> no, it should be True
06:16:14 <ceal> yeah i get true
06:16:15 <ceal> why?
06:16:43 <ski> `42' is the same value as `42'
06:16:46 <ksf> because 42 equals 42?
06:16:53 <mauke> so the world is not completely insane
06:16:56 <ceal> but shouldn't the datatype matter?
06:17:02 <Axman6> > 42 == 42
06:17:03 <lambdabot>   True
06:17:05 <ceal> string and num?
06:17:07 <mauke> the type is Integer
06:17:12 <ksf> > "42" == 42
06:17:13 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
06:17:14 <lambdabot>    arising from the literal ...
06:17:16 <Axman6> you're using readLine right?
06:17:18 <ski> `read "42"' will here return the value `42' of the correct type
06:17:23 <mauke> Axman6: what
06:17:32 <ceal> Axman6:readLn
06:17:33 <CalJohn> ceal: read is polymorphic, so it will read the input into whatever type the type inferrer has worked out that you want
06:17:39 <Axman6> yeah, readLn
06:17:48 <Axman6> well readLn will return an integer in this case
06:17:49 <ksf> :t readLn
06:17:50 <lambdabot> forall a. (Read a) => IO a
06:17:55 <fbru02_> ski : great info, should i consider making myself memeber of the acm  ? or is it wasted money ?
06:17:59 <ksf> :t readLn :: IO Integer
06:18:01 <lambdabot> IO Integer
06:18:01 <ceal> :t readLn :: IO Integer
06:18:03 <lambdabot> IO Integer
06:18:03 <Axman6> > read "42" == 42
06:18:04 <lambdabot>   True
06:18:35 <mauke> ceal: add 'print (show n)' immediately after the readLn statement
06:18:44 <ceal> what is the command to exit from a program?
06:18:49 <ceal> there's return()
06:18:52 <ceal> any others?
06:18:57 <mauke> irrelevant
06:18:57 <ski> fbru02_ : if you had an `IO'-action with nondeterministic effects, that's how i would say it .. but in your case maybe you only had "external input"-effects ?
06:19:02 <ksf> nope return() doesn't exit.
06:19:05 <CalJohn> that is not quite what return does, ceal
06:19:23 <fbru02_> ski: point taken
06:19:24 <ski> @type System.exitWith
06:19:25 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
06:19:27 <ceal> CalJohn:ok
06:19:38 <ksf> > return 1 >> return 2 >> return 3 :: [Int]
06:19:38 <ceal> so what all exist that i can use to quit a program?
06:19:39 <lambdabot>   [3]
06:19:50 <noteventime> ceal: Check out System.Exit
06:20:42 <ksf> ceal, main = return () terminates, as does main = putStrnLn "Hello Wordl"
06:20:57 <ceal> @hoogle System.Exit
06:20:58 <lambdabot> module System.Exit
06:20:58 <lambdabot> System.Exit data ExitCode
06:20:58 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
06:21:02 <ksf> ...so the answer is "you can use that statement which doesn't exist after your program"
06:21:25 <ceal> ksf:?
06:21:48 <fbru02_> ski : should i consider suscribing to acm ?
06:21:49 <noteventime> ceal: Or you can use "fail" :)
06:21:52 <ksf> simply put: your program terminates if it runs out of source to execute.
06:22:23 <ksf> ...which it does in your example, after return ().
06:22:25 <noteventime> ksf: I'm guessing what ceal is looking for is an IO action to break computation :)
06:22:36 <ksf> there's got to be something else wrong with your setup.
06:22:39 <ksf> the code is fine.
06:22:58 <ceal> noteventime: when the variable input is 42, then it should exit
06:23:12 <ski> fbru02_ : so `return' takes any value at all (monadic actions or other values), and puts it into a monadic action, that will return that value after doing actually no effects at all
06:23:14 <ceal> ksf: let me try submitting it to the online judge
06:23:18 <CalJohn> fbru02_: it is probably a waste of money, at least if you are only interested in haskell/fp papers.  most of them are available freely
06:23:20 <noteventime> ceal: Isn't input per definition variable? O_o
06:23:26 <ksf> ceal, it does so, on everybody's box except yours...
06:23:34 <mauke> ceal: did you really paste your complete program?
06:23:40 <mauke> ceal: are you looking at the right file?
06:23:57 <mauke> did you save your changes?
06:24:02 <ceal> noteventime:?
06:24:05 <ceal> yeah
06:24:10 <ceal> i did save it
06:24:14 <noteventime> ceal: "The variable input" :)
06:24:23 <ski> fbru02_ : e.g. `return 42 :: IO Integer' is an `IO'-action that actually does no `IO'-effects at all; it only gives back the value `42', when run
06:24:29 <ksf> variables don't exist in haskell, except if you count stRef's.
06:24:38 <ksf> those things you are talking about are bindings.
06:24:52 <PeakerWork> or if you count State/StateT, or if you count IORefs, or MVars, or ...
06:25:09 <ceal> so are you saying the code i am compiling is wrong?
06:25:30 <mauke> what?
06:25:42 <mauke> I'm saing <mauke> ceal: add 'print (show n)' immediately after the readLn statement
06:26:13 <ski> fbru02_ : and `return (putStrLn "foo") :: IO (IO ())' is an `IO'-action that actually does no `IO'-effect at all; it only, when performed, gives back the *value* `putStrLn "foo"' (and *that* value is another `IO'-action that when performed will print the string `"foo"' as a line on standard output and give back the trivial/uninteresting value `()')
06:26:28 <PeakerWork> mauke: why double show n? (print does too)
06:26:54 <ksf> :t join
06:26:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:27:00 <mornfall> @src alignPtr
06:27:00 <lambdabot> Source not found. My mind is going. I can feel it.
06:27:10 <ski> @src print
06:27:11 <lambdabot> print x = putStrLn (show x)
06:27:23 <ksf> :t join $ return (putStrLn "foo"))
06:27:25 <lambdabot> parse error on input `)'
06:27:26 <mauke> PeakerWork: so I get different output
06:27:28 <ksf> :t join $ return (putStrLn "foo")
06:27:29 <lambdabot> IO ()
06:27:31 <ski> fbru02_ : does that clear it up somewhat ?
06:27:43 <ceal> mauke: i added the print n after the readLn and kept the rest of the code just like that
06:27:57 <ceal> and i got the same output: WITHOUT THE 42
06:28:05 <mauke> ceal: no, print (show n)
06:28:36 <ceal> yeah even with print (show n)
06:28:59 <mauke> what's the complete output?
06:29:05 <ceal> hold on
06:29:14 <ksf> ...and if you insert 'putStrLn "Did I really compile the right file?"' before readLn?
06:30:09 <noteventime> ceal: Not sure if someone already suggested it, you could do things more compactly using "when", which kinda shows the run-out-of-code way of exiting
06:30:50 * ksf likes guard, as it throws an error which you can see on the console
06:31:38 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3251#a3251
06:31:45 <fbru02_> ski : yes, thank so much, so last part you said it goes to say that basically even that we are stating that for example one function has the type String -> IO String it can output a string or not . e.i. if i do return "foo" no string will be displayed
06:31:47 <ceal> that's the code and the output
06:31:52 <mauke> ceal: yeah, you're running the wrong code
06:32:00 <mauke> because that's not what your program does
06:32:09 <ceal> what does it do?
06:32:23 <Axman6> you're also not ever giving it a 42 to test it with
06:32:29 <mauke> Axman6: wrong
06:32:37 <ceal> Axman6:actually that's the output
06:32:42 <fbru02_> ski : if i do : putStrLn "foo" now yes the string will be displayed
06:32:44 <ceal> the 42 is there before the 99
06:33:09 <ksf> still, if it were the same code, you'd see "1" 1 "2" 2 and so on.
06:33:20 <Axman6> ceal: i assume you've recompiled the code right?
06:33:45 <mauke> ceal: the code you pasted generates this output: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3251#a3252
06:33:56 <ski> fbru02_ : yes .. but in both cases, a string will need to be returned to the caller of the function
06:34:12 <fbru02_> ski : perfect :)
06:34:16 <ski> (since you have `String -> IO String', not `String -> IO ()' or something else)
06:34:19 <ceal> yeah i have
06:34:26 <benmachine> ceal: just a thought, are you using tabs to indent your code at all?
06:34:37 <mauke> benmachine: irrelevant
06:34:40 <ksf> ceal, use ghc --make .
06:34:41 <ceal> benmachine:yeah i am using tabs
06:34:44 <benmachine> mauke: yeah seems so
06:34:44 <ceal> ok
06:34:47 <ksf> ghc doesn't produce a.out.
06:34:56 <ceal> yeah it does
06:35:02 <mauke> ceal: you probably want to stop using tabs
06:35:06 <benmachine> I thought that maybe main was indented wrongly, such that it was not in the else-block
06:35:17 <ceal> mauke:?
06:35:21 <benmachine> but although he is using tabs he is also using them correctly so whatever
06:35:32 <ceal> mauke:and use what instead?
06:35:36 <Axman6> ceal: if you're ysing ghc try.hs, the program will be called ./try
06:35:37 <benmachine> spaces
06:35:39 <mauke> benmachine: good thinking, but the print (show n) demonstrates that he's running completely different code
06:35:52 <mauke> Axman6: wrong
06:35:52 <benmachine> mauke: fair enough
06:35:53 <ceal> mauke: ?
06:35:57 <mauke> ceal: yes?
06:36:03 <ksf> ...if you're using ghc try.hs, your'e bound to get linker errors.
06:36:31 <ceal> mauke: what's wrong?
06:36:36 <ceal> with the code?
06:36:42 <mauke> ceal: nothing, you're simply not running it
06:36:47 <ceal> ?
06:36:47 <Axman6> mauke: that's not very constructive criticism
06:36:48 <ski> fbru02_ : so if you do `frob str = do putStrLn (reverse str); return "foo"', then a string will be displayed
06:36:49 <ksf> ...if you're doing ghc --make try.hs , _then_ the resulting program will be called "try"
06:36:55 <ceal> i am compiling the wrong one?
06:36:57 <mauke> Axman6: ghc try.hs will generate a.out
06:37:01 <mauke> ceal: I don't know
06:37:07 <ceal> oh!!
06:37:08 <mauke> ceal: but you're definitely running the wrong program
06:37:09 <ksf> mauke, it doesn't, at least here.
06:37:18 <ceal> hold on
06:37:22 <ksf> The Glorious Glasgow Haskell Compilation System, version 6.10.1
06:37:28 <mauke> ksf: what doesn't what?
06:37:45 <benmachine> generates a.out for me too
06:37:46 <ksf> ghc try.hs generate an a.out
06:37:58 <benmachine> 6.10.4
06:38:20 <ksf> aaaah.
06:38:30 <ksf> it does, but only if you got "module Main where"
06:38:40 <mauke> module Main is implicit
06:39:42 <ksf> wtf?
06:40:20 <fbru02_> ski : cool thanks
06:41:11 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3254#a3254
06:41:15 <ksf> ok, I correct myself: ghc <file> works, _iff_ you don't have any imports.
06:41:19 <ceal> i re-wrote the code in a new file
06:41:25 <mauke> ksf: import Prelude
06:41:26 <ceal> and recompiled it and got an error
06:41:52 <mauke> ceal: the 'else' must be indented more
06:41:53 <ksf> there's a "then" missing.
06:42:01 <ski> (ceal : next time, annotate the original paste instead)
06:42:02 <ksf> that, too.
06:42:20 <benmachine> I've had elses indented less than their if before
06:42:21 <mauke> ceal: why didn't you just use one of the hundred working programs?
06:42:59 <ski> mauke : possibly ceal wanted to write a program from scratch ?
06:43:02 <benmachine> the then is the important bit
06:43:04 <ceal> i was trying to make it work myself
06:43:38 <ksf> benmachine, there's a gotcha with if's in do blocks.
06:43:45 <mauke> well, it should look more like http://moonpatio.com/fastcgi/hpaste.fcgi/raw?id=3247  :-)
06:43:46 <cdsmithus> benmachine: You can only indent 'else' less than 'if' when you aren't using layout.
06:43:47 <ceal> is it enough if i give a space before else?
06:44:04 <ksf> if you've got then and else on the same indent level as the if, the do -block thinks they're new statements.
06:44:08 <ski> ceal : yes
06:44:24 <benmachine> cdsmithus: I think it depends on context
06:44:38 <benmachine> well
06:44:45 <benmachine> I think that largely because ksf just told me
06:45:09 <ceal> mauke: your code worked
06:45:16 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/raw?id=3247
06:45:35 <ceal> it stopped at 984
06:45:46 <cdsmithus> benmachine: it depends on if you are using layout, like I said.  The 'do' keyword uses layout (unless you put braces after it)
06:45:47 <ksf> layout is really, really lax when it comes to expressions.
06:46:07 <benmachine> cdsmithus: I always use layout, I think it still depends
06:46:11 <ceal> let me try writing my own now...
06:46:13 <ksf> the only thing that matters is the "=" in front of it and the "where" after.
06:48:20 <ski> ksf : what do you mean ?
06:48:20 <benmachine> is it possible to declare more than one module in a single source file? every time I try I get parse errors on the second `module'
06:48:34 <cdsmithus> benmachine: not sure what you mean by "it depends".  Anywhere you've got layout, if you put a "then" or "else" starting in or before the layout column, it will be interpreted as a new statement, and it will be an error.
06:49:07 <mauke> ceal: the codechef practice problems look like they were taken from spoj.pl
06:49:23 <ksf> benmachine, http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
06:50:02 <ksf> ski, you can indent "then" and "else" less if you don't have a do block around that messes things up, in the same way that you can indent a ] less than ,1,2
06:51:16 <ski> ksf : yes. i just wasn't sure what you meant by the `=' and `where' comment
06:51:26 <voker57_> how to set instances in declaration of instance? Like instance Eq (Eq a) => MyType a where...
06:51:28 <ksf> "This has been recently added to jhc, GHC and Hugs" ... what's the compiler flag?
06:51:58 <ski> (ksf : "this" being ?)
06:52:03 <ksf> or is it on by default and my ghc too old?
06:52:07 <ksf> http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
06:53:09 <mauke> voker57_: instance (Eq a) => Eq (MyType a)
06:53:22 <benmachine> cdsmithus: http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=3255#a3255 this is what I was talking about, and works fine
06:53:36 <voker57_> mauke: thx
06:53:40 <benmachine> it might be that I misunderstood you
06:53:48 <cdsmithus> benmachine: right, because there is no layout there
06:54:12 <benmachine> oh, yeah I guess so
06:54:23 <cdsmithus> benmachine: Layout is when you have a 'do', 'where', 'of', or 'let' that doesn't have braces after it.
06:54:54 <ksf> or at toplevel?
06:54:59 <benmachine> cdsmithus: ah, with you now
06:55:19 <cdsmithus> ksf: layout at the top level is actually due to the "where" in "module Blah where", I believe.
06:55:25 <ksf> it's hard to have negative indents, though, so I guess stuff doesn't show up...
06:58:50 <Plouj> hola!
06:59:06 <Axman6> G'day
06:59:20 <Tordmor> Guten Tag!
06:59:22 <Plouj> does anyone know how the full code for the Parse/PNM example is supposed to look like? I think Parse.hs should import PNM, but it's not shown
06:59:32 <Plouj> http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html
07:00:10 <ksf> does anyone have pointers on how to use floats as ints?
07:00:28 <ksf> If I only use the mantissa, I'm wasting bytes.
07:00:42 <Axman6> o.O
07:00:49 <Plouj> do you mean using ints as floats?
07:00:56 <ksf> nah, floats as ints.
07:01:09 <ksf> more specificall, those floats my geforce uses.
07:01:17 <Plouj> oh
07:01:26 <Plouj> you want to store integers inside the geforce's ints?
07:01:30 <Axman6> sure it can't also use ints?
07:01:35 <comrade`phil> Great. Dude sends me to a channel for a programming language I have NEVER EVEN HEARD OF.
07:01:38 <ksf> I'm not sure about that.
07:01:48 <ksf> the arithmetic pipeline should be float only.
07:01:51 <comrade`phil> Is haskell a clever wordplay for a Pascal variant or something?
07:02:03 <Axman6> not at all
07:02:07 <mauke> comrade`phil: haskell is a name
07:02:10 <ski> comrade`phil : no. it's named after a guy called Haskell Brooks Curry
07:02:10 <ksf> it surely can read and store ints, but that's not what I want to do.
07:02:13 <Axman6> Haskell Curry
07:02:15 <Plouj> comrade`phil: check the wikipedia
07:02:16 <comrade`phil> Pity, a great opportunity missed.
07:02:17 <alc> @rwhcode
07:02:17 <lambdabot> Unknown command, try @list
07:02:23 <alc> @where rwhcode
07:02:23 <lambdabot> I know nothing about rwhcode.
07:02:29 <mauke> comrade`phil: haskell doesn't even sound like pascal
07:02:34 <ksf> ...I wanna write shaders, and to my best of knowledge that's float-only.
07:02:41 <comrade`phil> It does to me.
07:02:45 <Plouj> alc: was that for me? :)
07:02:49 <comrade`phil> We yorkshiremen say things properly
07:03:07 <alc> @where+ rwhcode http://examples.oreilly.com/9780596514983/rwh-examples2.zip
07:03:07 <lambdabot> I will never forget.
07:03:15 <mauke> VE GERMANS SAY SINGS PROPERLY
07:03:37 <alc> Plouj: yes. and hopefully others also =)
07:03:43 * comrade`phil reads the wiki
07:03:51 <Plouj> alc: why doesn't it have a number "2" at the end?
07:03:58 * Axman6 doesn't think the wiki does haskell justice
07:04:03 <alc> i think thats version 2
07:04:24 <alc> maybe there will be also *3
07:04:24 <comrade`phil> Right, I think I'll stick to slowly teaching myself python
07:04:44 <ski> comrade`phil : do you know any other language(s) ?
07:04:52 <comrade`phil> Nope.
07:04:54 <byorgey> comrade`phil: Pity, a great opportunity missed.
07:05:11 <Axman6> comrade`phil: learning haskell will make you a better python programmer
07:05:24 <Axman6> (it'll make you a better all 'round programmer too)
07:05:28 <comrade`phil> Axman6: That's what they say about every language
07:05:46 <comrade`phil> And generally it means the language is a bitch to use
07:05:48 <Axman6> yeah but Haskell is the one language it's actually true for ;)
07:05:56 * ski grins
07:06:03 <Axman6> haskell's not a bitch to use
07:06:13 <matsuura> it's easy!
07:06:19 <comrade`phil> Fair enough
07:06:23 <comrade`phil> I'll have a look at it
07:06:24 <ceal> @hoogle interact
07:06:25 <lambdabot> Prelude interact :: (String -> String) -> IO ()
07:06:25 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
07:06:25 <lambdabot> System.IO interact :: (String -> String) -> IO ()
07:06:26 <Axman6> it's just a bit different. but there are lots of reasons for why it's different
07:06:27 <mauke> comrade`phil: haskell didn't make me a better python programmer
07:06:27 <matsuura> you better
07:06:37 <comrade`phil> But if I get hooked, it's your fault.
07:06:48 <Axman6> fine
07:06:50 <mauke> that's because I don't use python (it sucks)
07:06:57 <comrade`phil> Python doesn't suck :(
07:07:18 <Axman6> only thing i ever wrote in python was a blog for google app engine, in about half an hour.
07:07:23 <Axman6> i did pretty well i thought
07:07:32 <comrade`phil> in fact, my very first program in python wasn't "Hello world" it was "Python is great"
07:07:42 <matsuura> I need to learn python
07:07:54 <matsuura> jesus how I never stick with it though!
07:07:54 <mauke> comrade`phil: then why does it have stupid scoping rules?
07:08:05 <mauke> and why can't I turn statements into expressions
07:08:11 <comrade`phil> Problem is, I go back to something after not having wanted to do anything with it
07:08:21 <comrade`phil> and then I can't understand what the christ I was doing
07:08:30 <comrade`phil> "WHO WROTE THIS CRAP?"
07:08:41 <Axman6> "what a fucking noob"
07:08:46 <Axman6> "oh... shit"
07:09:35 <Axman6> comrade`phil: when learning haskell, don't make your first program hello world, ok?
07:09:42 <comrade`phil> Lol
07:09:48 <mauke> main = putStr "Hello, world!\n"
07:09:52 <mauke> TOO LATE
07:10:06 <Axman6> haskell's power isn't in doing crap like that. it's in doing very powerful other shit and shit and oh fuck i'm tired
07:10:21 <comrade`phil> Lol. Axman6
07:10:50 <comrade`phil> My first program will be a BSOD generator, then
07:10:52 <comrade`phil> or something
07:10:53 <mauke> you're not supposed to use all of haskell's special powers in a single devastating supercombo if you've just started learning it
07:11:04 <Berengal> "Haskell is faster than C++, more concise than Perl, more regular than Python, more flexible than Ruby, more typeful than C#, more robust than Java, and has absolutely nothing in common with PHP." - Audrey Tang
07:11:18 <comrade`phil> Thank god for the last bit
07:11:42 <mapreduce> Hilarious.
07:11:48 <mornfall> : - ]
07:11:49 <ski> (Berengal : put that into lambdabot ?)
07:12:00 <mauke> @quote php
07:12:01 <lambdabot> stepcut says: I wrote 1 + 1 in php once, and got 11 -- wasn't quite what I was hoping for
07:12:04 <Axman6> mauke: what's wrong with using putStrLn?
07:12:15 <mauke> Axman6: it's not for beginners
07:12:16 <Berengal> @remember AudreyTang Haskell is faster than C++, more concise than Perl, more regular than Python, more flexible than Ruby, more typeful than C#, more robust than Java, and has absolutely nothing in common with PHP.
07:12:16 <lambdabot> It is stored.
07:12:22 <Berengal> @quote AudreyTang
07:12:22 <lambdabot> AudreyTang says: Haskell is faster than C++, more concise than Perl, more regular than Python, more flexible than Ruby, more typeful than C#, more robust than Java, and has absolutely nothing in
07:12:22 <lambdabot> common with PHP.
07:12:27 <Paczesiowa> that's nothing, using oleg's higher order classes you can implement that retarded equality from php:)
07:12:27 <Axman6> how is it not? o.O
07:12:30 <Berengal> It's an old-ish quote though
07:13:08 <mauke> Axman6: it gives the misimpression that newline is special/magical and that you need multiple putStrLns to output multiple lines
07:13:25 <mauke> somewhat similar to endl in c++
07:13:43 <Paczesiowa> mauke: but, isn't it crossplatform?
07:13:45 <Deewiant> Does outputting \n work in Windows?
07:13:48 <mauke> see?
07:13:48 <ksf> what about "99 thunks in the graph?"
07:13:53 <ski> Deewiant : yes
07:14:02 <gwern> aha! I figured out why google and other sites kept blocking me!
07:14:02 <mauke> Paczesiowa: what
07:14:05 <Axman6> comrade`phil: http://www.learnyouahaskell.com/ gogogo! don't be fooled by the some what childish ruby like stylings, haskell is serious biusiness (used in industry, for shit that isn't twitter)
07:14:12 <gwern> I accidentally left my firefox useragent as googlebot
07:14:13 <gwern> duh
07:14:17 <Axman6> gwern: registered sex offender?
07:14:21 <Deewiant> ski: It outputs \r\n?
07:14:23 <Axman6> heh
07:14:26 <gwern> Axman6: those records were sealed
07:14:29 <mapreduce> Worse, an unregistered one.
07:14:31 <Axman6> >_>
07:14:45 <Paczesiowa> :D
07:14:46 <mauke> Deewiant: no
07:14:56 <Deewiant> Hence putStrLn
07:14:59 <ski> Deewiant : yes, for text files, "\n" is converted into "\r\n" (and the other direction)
07:15:01 <mauke> @src putStrLn
07:15:02 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
07:15:05 <mauke> Deewiant: ^
07:15:07 <Deewiant> @src putChar
07:15:08 <lambdabot> putChar c = hPutChar stdout c
07:15:11 <Deewiant> @src hPutChar
07:15:12 <lambdabot> Source not found. You type like i drive.
07:15:22 <mauke> \r\n makes me twitch
07:15:32 <mauke> as far as I know, Haskell follows C output rules
07:15:44 <mauke> s!output!I/O!
07:15:47 <Berengal> Yesterday I found a unix tool that outputted \r\n. I was greatly confused
07:16:14 <Berengal> Although I'm not sure where the blame lies. The terminal could also be confusing it
07:16:33 <Paczesiowa> > unlines $ lines "line1\r\nline2"
07:16:34 <lambdabot>   "line1\r\nline2\n"
07:16:50 <ehamberg> Berengal: was it unix2dos? ;)
07:16:58 <Berengal> ehamberg: No, script
07:22:51 <Axman6> oh fucking hell. trying to reinstall darcs, and i can't find the damn curl libs. i've given it the --extra-{include|lib}-dirs stuff, and it still won't find it
07:25:38 <Axman6> anyone got any thoughts?
07:25:41 <Paczesiowa> @seen irek_j
07:25:41 <lambdabot> I haven't seen irek_j.
07:25:57 <mauke> preflex: seen irek_j
07:25:58 <preflex>  irek_j was last seen on #haskell 54 days, 20 hours, 15 minutes and 51 seconds ago, saying: thank you so much
07:26:15 <Paczesiowa> what's preflex?
07:26:24 <Axman6> cabal install --reinstall curl finds it just fine
07:26:30 <Paczesiowa> lambdabot fork?
07:26:38 <mauke> Paczesiowa: no, a different bot
07:26:42 <Axman6> but darcs can't do it, even with massive hand holding
07:26:57 <Paczesiowa> mauke: haskell one?
07:27:04 <mauke> Paczesiowa: yes
07:27:11 <Paczesiowa> phew!
07:27:23 <comrade`phil> Oh jesus, this is all very strange.
07:27:27 <ksf> % pkg-config libcurl --cflags --libs
07:27:28 <ksf>  -lcurl
07:27:47 <tomh> hey guys, what you guys think about returning a record with only 1 field initialized
07:27:53 <tomh> bad or good?
07:27:57 <ksf> ergo: you don't need any -I flags.
07:28:16 <Axman6> cabal install darcs --reinstall dies
07:28:32 <Paczesiowa> tomh: with rest of them undefined?
07:28:33 <ksf> tomh, be a good boy and make a default record.
07:28:35 <fbru02_> i have a question , some guy in haskell-beg asked how to eliminate parenthesis from fmap (fmap (*2)) xs ... what does this even mean to do two nested fmaps ?
07:28:35 <Axman6> as does cabal install darcs --extra-include-dirs=/opt/local/include/ --extra-lib-dirs=/opt/local/lib/ --reinstall
07:29:01 <tomh> ksf: ah good suggestion ill do that :D
07:29:03 <Paczesiowa> > fmap (fmap (*2)) [Just 2, Nothing]
07:29:04 <Deewiant> > fmap (fmap (*2)) [Just 12, Just 7, Nothing] -- fbru02_
07:29:04 <lambdabot>   [Just 4,Nothing]
07:29:05 <Zao> fmap through two nesting levels?
07:29:05 <lambdabot>   [Just 24,Just 14,Nothing]
07:29:25 <tomh> Paczesiowa: that was my original idea, but now i got something  better yeah
07:29:43 <Paczesiowa> heh, Maybe inside [] seems natural
07:29:50 <olsner> @pl (\f x -> f x x)
07:29:50 <lambdabot> join
07:30:03 <Axman6> :t join fmap
07:30:04 <lambdabot> forall a. (a -> a) -> a -> a
07:30:09 <olsner> @pl (\f g x -> f g x x)
07:30:10 <lambdabot> flip flip id . (ap .)
07:30:13 <Axman6> huh
07:30:38 <roconnor> > join (.) fmap (*2) [Just 12, Just 7, Nothing]
07:30:40 <Axman6> anyway, anyone got any ideas about darcs?
07:30:40 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
07:30:41 <ski> fbru02_ : `(fmap . fmap) (*2)' or `fmap . fmap $ (*2)'
07:30:57 <Paczesiowa> Axman6: are you using cabal build?
07:31:01 <Axman6> yes
07:31:08 <Axman6> well, cabal-install
07:31:09 <Paczesiowa> Axman6: try the other one
07:31:20 <Peaker> > (fmap . first . fmap) (+100) [(Nothing, 5), (Just 7, 1), (Just 9, 3)]
07:31:21 <lambdabot>   [(Nothing,5),(Just 107,1),(Just 109,3)]
07:31:22 <Axman6> 'the other one'?
07:31:33 <Paczesiowa> Axman6: darcs has automake build system also
07:31:38 <Paczesiowa> Axman6: though deprecated
07:31:41 <ski> fbru02_ : what is "haskell-beg", btw ?
07:31:45 <Axman6> hmm
07:31:47 <Paczesiowa> beginners?
07:31:56 <ski> yes, but what is it ?
07:32:01 <Paczesiowa> mailing list?
07:32:12 <fbru02_> ski : it is a mailing list sepparate from haskell-cafe and haskell announcement , it is for beginners
07:32:19 <ski> ic, ty
07:32:32 <ksf> sounds like an irc chan for homework questions...
07:32:32 <Paczesiowa> where they beg for understanding!
07:33:27 <fbru02_> many people learn haskell just to pass course in college and then they quit , right?
07:33:43 <Paczesiowa> probably yes
07:33:47 <Axman6> suckers
07:33:58 <Paczesiowa> we don't need their kind here..
07:34:04 <Axman6> i know most of the people who learnt it in my course hate it.
07:34:18 <Axman6> and that's why i'll end up with a PhD and they won't ;)
07:34:45 <Paczesiowa> they give phds for not hating haskell?
07:34:47 <NEEDMOAR> :-/
07:34:51 <fbru02_> im telecom engineer and cannot see how anyone should hate Haskell , it is beautiful, i hate it because it is mind bending but i admire its beauty
07:35:01 <comrade`phil> Well, this is good.
07:35:09 <ksf> so... you mean it's not natural to read book about type theory because you weren't given any lectures about it?
07:35:13 <comrade`phil> The compiler is downloading at 10kB/s
07:35:21 * comrade`phil twiddles thumbs
07:35:23 <Peaker> Axman6: Why would they hate it? :)
07:35:26 <Axman6> fbru02_: you micht be interested in erlang as well then
07:35:31 <Berengal> Mindbendyness is no reason to hate something. On the contrary, mindbendyness is a good thing
07:35:32 <Axman6> Peaker: because they're stupid
07:35:33 <byorgey> comrade`phil: yikes, that's pretty slow.
07:35:36 <Cale> comrade`phil: where are you downloading which compiler from?
07:35:48 <comrade`phil> o.o
07:35:50 <comrade`phil> WHoops
07:35:54 <comrade`phil> Had my torrents running
07:35:58 <ksf> ...over what kind of line? 56k modem?
07:36:03 <comrade`phil> uploading at 96kB/s
07:36:08 <comrade`phil> No bloody wonder
07:36:12 <Berengal> 56k can't do 10kB/s
07:36:20 <comrade`phil> Won't do my download cap any good..
07:36:24 * Cale downloads ghc at 1.2 MB/sec
07:36:30 <comrade`phil> My line is 15mbps
07:36:31 <fbru02_> Axman6: yeah , but i do most stuff on ruby and decided to learn haskell instead of earlang because erlang has dynamic typing and stuff similar to ruby
07:36:35 * Berengal has ghc downloaded already
07:36:36 <ksf> ...you should have at least 10kbit spare or so.
07:36:37 <Paczesiowa> I don't think "mindbendyness" is a good think. asm is mindbending and so is brainfuck
07:36:41 <Paczesiowa> *thing
07:36:44 <Axman6> god damn it, even the autoconf version of darcs can't fund the frigging thing
07:36:56 <Cale> (from the GHC website)
07:37:06 <comrade`phil> There we go
07:37:10 <comrade`phil> 500kB/s
07:37:19 <comrade`phil> Much more respectable
07:37:25 <Berengal> asm and brainfuck aren't particularly mind bending.
07:37:29 * shapr boings cheerfully.
07:37:32 <ksf> malbolge is.
07:37:32 <fbru02_> is it much better to use darcs than mercurial ?
07:37:47 <Paczesiowa> Berengal: try to write something complicated in bf
07:38:00 <Berengal> Paczesiowa: That's not mind bending, that's just torture
07:38:27 <ski> Unlambda
07:38:38 <ksf> ski, lazy-k.
07:38:41 <ksf> unlambda isn't pure.
07:38:50 <ski> yes
07:38:51 <comrade`phil> I bet it doesn't run on XP 64 pro, so I'll have to reboot..
07:38:59 <Berengal> unlambda and lazy-k aren't particularly mind bending once you know haskell either ;)
07:39:02 <mauke> did someone say http://mauke.ath.cx/stuff/asm/factor.s
07:39:25 <fbru02_> what is Squiggol ? is it a language ?
07:39:28 <Berengal> Actually, I haven't really encountered a properly mind bending language after haskell. They've all had familiar concepts
07:39:32 <comrade`phil> Well, I'm glad haskell is mind-bending
07:39:34 <Paczesiowa> when I first [was supposed to] learned prolog, it was mindbending and I hate prolog. when I learned haskell - it was natural.
07:39:38 <ksf> squiggol is defined by squiggly lines.
07:39:42 <comrade`phil> I can't think straight to start with
07:39:47 <ksf> ...arrows like ~>
07:40:11 <Berengal> mauke: sub-wuh?
07:40:15 <Axman6> jesus, how can darcs be so broken?
07:40:21 <ski> fbru02_ : <http://en.wikipedia.org/wiki/Bird-Meertens_Formalism>
07:40:23 <fbru02_> ksf : still no idea what is squiggly lines
07:40:27 <mauke> subl subl subl
07:40:30 <Nafai> I'd like to look at Prolog someday
07:40:31 <fbru02_> ski : thanks
07:40:47 <Nafai> I read an interview with Joe Armstrong the other day and I was mildly interested in it
07:41:02 <comrade`phil> I am so tempted
07:41:03 <mauke> (factor.s is the result of compiling a brainfuck program to OISC)
07:41:12 <ski> Paczesiowa : Prolog is cool (except the impure parts)
07:41:13 <gwern> Axman6: you know, I don't think you need curl for darcs
07:41:13 <comrade`phil> To go "You mean the trumpet player? or the astronaut?"
07:41:36 <Axman6> gwern: yeah, but if i have it installed, and it's also the default, i should be able to get it working
07:41:39 <gwern> Axman6: you could just use the http package. a bit slower but if it compiles...
07:41:43 <Paczesiowa> ski: I don't think like prolog machine:) it's not natural
07:41:57 <Axman6> all other versions of darcs have installed just fine
07:41:59 * ski wonders what "prolog machine" is
07:42:07 <ski> (the WAM ?)
07:42:16 <Axman6> but this one refuses to find either of my two curl installs
07:42:39 <fbru02_> Paczesiowa: i hated the sicp lectures where the built a prolog like language so i didnt even bother
07:43:59 <Paczesiowa> on the other hand, the only book by Oleg is about scheme and prolog, so probably should take at least a look at it someday
07:44:16 <Axman6> oh ffs! now it can't find quickcheck2
07:44:34 <fbru02_> who is oleg ? the one with the site with all the resources ?
07:44:41 <gwern> @quote oleg
07:44:41 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
07:44:43 <ski> (Paczesiowa : .. and what's not natural about it, if i may ask ? :)
07:44:43 <mauke> @where oleg
07:44:43 <Paczesiowa> fbru02_: yes
07:44:43 <lambdabot> http://okmij.org/ftp/
07:44:47 <gwern> @quote oleg
07:44:47 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
07:44:51 <gwern> hm.
07:44:56 <gwern> @olegfact
07:44:56 <lambdabot> Unknown command, try @list
07:45:13 <Axman6> wtf
07:45:14 <Paczesiowa> ski: well when I think about something, there are no cuts for example
07:45:27 <Paczesiowa> ski: and plenty of functions, not relations
07:45:31 <gwern> Axman6: yeah really, where did our oleg quotes go?
07:45:42 <gwern> @quote .leg
07:45:43 <lambdabot> EvilTerran says: i get quite a lot of odd type errors, actually; probably something to do with my fascination with Olegian type hacks...
07:45:49 <Axman6> i want to know wtf did working darcs go
07:45:50 <gwern> @quote .leg
07:45:51 <lambdabot> jfredett says: I pray to oleg every night, hoping he'll grant me the serenity to accept the type errors I cannot change, the strength to correct the ones I do, and the grace to know the difference.
07:45:56 <Axman6> it seems it's totally fucked
07:46:02 <ski> Paczesiowa : yes, cuts are in the bad part of Prolog (as are assert[az]/1,retract/1, as well as i/o to a lesser extent)
07:46:07 <gwern> Axman6: this darcs darcs?
07:46:11 <gwern> @quote .leg
07:46:12 <lambdabot> ghc says: Illegal overloaded type signature(s)
07:46:19 <mauke> @quote oleg.
07:46:20 <lambdabot> stepcut says: <Saizan> in HList you can have what oleg calls a Type Indexed Coproduct <stepcut> in HList you can have what I call a headache
07:46:28 <gwern> one of these days I'm going to RIP OUT all these bloody ghc quotes
07:46:34 <mauke> @quote OlegFacts
07:46:35 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
07:46:48 <fbru02_> those are funny
07:46:58 <gwern> mauke: well, hlist was a real headache to cabalize and get working. I can't imagine trying to actually understand it
07:47:17 <Axman6> god damnit
07:47:20 <Paczesiowa> gwern: have you read hlist paper?
07:47:23 <Axman6> what a piece of shit
07:47:28 <ski> @ghc
07:47:28 <lambdabot> ghc says: No constructor has all these fields
07:47:28 <Peaker> gwern: I read the HList paper, I don't think it was that difficult
07:47:30 <gwern> Paczesiowa: yes. not that it made a difference
07:47:42 <Paczesiowa> gwern: OOHaskell paper?
07:47:47 <gwern> you're a better haskeller than I, peaker din!
07:47:50 <Axman6> at some point, darcs managed to upgrade to 2.3.0, because darcs --version says it did. but when i try and use it, i get darcs failed:  Codec.Compression.Zlib: incompatible zlib version
07:48:16 <comrade`phil> Ok, lesson learned. Programming is difficult when using an azerty keyboard on an OS which only supports qwerty..
07:48:17 <Peaker> gwern: I may have struggled with that stuff in some other occasion, to grasp fundeps
07:48:21 <gwern> Axman6: hm. that's probably related to the zlib corruption stuff. as I said, are you working off darcs darcs?
07:48:36 <Axman6> i'm working off hackage darcs
07:48:38 * comrade`phil smashes his face into the keyboard repeatedly, then takes an axe to it
07:49:02 <Paczesiowa> gwern: well, read it again:) it's worth it
07:49:13 <ksf> aoeudvorkakhtns
07:49:25 <ksf> s/k//
07:49:27 <comrade`phil> Remind me to KILL ALL BELGIANS.
07:49:31 <gwern> Axman6: dunno if the zlib fixes've made it into hackage darcs. fairly old innit?
07:49:43 <gwern> comrade`phil: but who will make our waffles and chocolates??!
07:49:45 <Axman6> it's 2.3.0
07:49:58 <gwern> speak not to me of version numbers; I care only about time
07:50:48 <comrade`phil> Make your own, you lazy bastards
07:50:51 <Axman6> well, i wouldn't have a clue
07:50:51 <comrade`phil> But yes
07:51:01 <comrade`phil> I'm on the verge of wrecking a third keyboard
07:51:13 <comrade`phil> Someone send me a standard american qwerty keyboard :(
07:51:20 <Peaker> it could be nice if everyone moved to date versioning, but I feel odd releasing an alpha-alpha-alpha thing as 9.8.9.1  or such
07:52:29 <Axman6> see, i can't work on any of my projects using darcs until this is fixed, so i'm pretty pissed off
07:53:04 <comrade`phil> Axman6: I now hate you with unbridled passion
07:53:06 <Paczesiowa> get a binary?
07:53:15 <comrade`phil> I feel like learning haskell now, but it's going to take forever.
07:53:30 <Axman6> comrade`phil: it doesn't take too long to learn the basics
07:53:38 <comrade`phil> That's not the problem
07:53:44 <Axman6> from there, you just pick up more and more be idling in here
07:53:49 <comrade`phil> The problem is the above mentioned azerty keyboard XD
07:54:04 <transiluminescen> well, that's where i'd go WHAT WHAT!!!
07:54:09 <Axman6> i take it you're not in yorkshire anymore?
07:54:17 <comrade`phil> I smashed up my last two with an axe, due to frustrations with XP pro 64...
07:54:18 <comrade`phil> Nope
07:54:22 <comrade`phil> I live in Belgium
07:54:24 <comrade`phil> Sadly
07:54:50 <comrade`phil> and it is quite difficult to get a standard qwerty keyboard here
07:55:06 <ksf> order it.
07:55:07 <transiluminescen> thats interesting...
07:55:16 <ksf> most of the eu use standard keyboards.
07:55:16 <Paczesiowa> configure it
07:55:17 <Paczesiowa> .
07:55:22 <transiluminescen> why is azerty standard there?
07:55:28 <ksf> if you're leet, you can get a model m.
07:55:38 * ski pats his keyboard
07:55:41 <ksf> ...with those cool replaceable keycaps.
07:55:41 <Axman6> comrade`phil: dealextreme.com you'll find plenty, that'll be dirt cheap, and they have free world wide shipping
07:55:42 <comrade`phil> Paczesiowa: THis is the funny thing
07:55:49 <Axman6> (ha, almost wrote whipping)
07:55:52 <mauke> who looks at their keyboard anyway
07:55:53 <comrade`phil> XP x64 only supports qwerty
07:56:06 <ksf> it's also heavy enough to be useful as a weapon and comes with a detachable cord (at the keyboard side).
07:56:15 <Paczesiowa> comrade`phil: well, maybe XP x64 is the problem
07:56:17 <mauke> my keyboard is german (qwertz), but I use a modified en_US layout
07:56:22 <comrade`phil> it's always the problem
07:56:24 <ksf> _very_ useful if a velociraptor happens to walk into the office.
07:56:32 <transiluminescen> ahahaha
07:56:37 <comrade`phil> But whenever I do a clean install, I just can't be arsed to download a new ISO
07:56:51 <comrade`phil> and burn a new windows disc
07:56:53 <Axman6> also, if you've never heard of dealextreme.com you haven't lived yet
07:57:10 <comrade`phil> I actually have a model M
07:57:15 <Axman6> Paczesiowa_: thanks for reminding me about the binaries
07:57:18 <comrade`phil> A 1980's one
07:57:27 <comrade`phil> WHich I stole from someone still using OS/2 warp
07:57:36 <ksf> mine's built in '94.
07:57:38 <comrade`phil> it's what I'm using now
07:58:35 <ksf> you could take the chance and switch to dvorak.
07:58:47 <comrade`phil> And have to learn to type all over again?
07:59:07 <Axman6> comrade`phil: http://www.dealextreme.com/products.dx/category.302
07:59:08 <comrade`phil> It's bad enough switching from azerty to qwerty, let alone to dvorak
07:59:09 <ksf> it only takes a couple of hours to memorize everything if you've got a type trainer.
07:59:30 <comrade`phil> Hmm, a spillproof keyboard?
07:59:31 <Axman6> check out those prices. those prices are the most you'll pay
07:59:36 <comrade`phil> I could do with another spillproof one
07:59:43 <ksf> ...and learning dvorak made me learn proper touchtyping.
07:59:47 <shapr> Yeah, me too
07:59:50 <Axman6> (i.e: free shipping)
08:00:07 <comrade`phil> I used to have a spill proof dell keyboard, I spilled so much coke and stuff in there, even ketchup once
08:00:08 <Axman6> you can even buy keyloggers :o
08:00:16 <shapr> Is there already a tool that automatically downloads and installs cabal packages, and reports back any build failures?
08:00:28 <comrade`phil> then I gave it to a friend, and within a week of leaving my room, it started growing mouldy
08:00:31 <Axman6> http://www.dealextreme.com/details.dx/sku.3731
08:00:37 * shapr waves the #haskell flag
08:00:41 <comrade`phil> This IS cheap
08:00:45 <shapr> C'mon, any auto-cabal build tools?
08:00:54 * shapr throws the keyboard discussion towards #haskell-blah
08:00:56 <comrade`phil> Sweet, hardware keyloggers for that cheap?
08:01:10 * comrade`phil buys a dozen, then goes around to the cybercafes
08:01:35 * shapr counts chimpanzees...
08:01:41 <Axman6> comrade`phil: deal extreme is one of the best websites on the net for buying practically anything cheap and plastic
08:01:59 * comrade`phil bookmarks
08:02:00 <shapr> Perhaps this discussion fits better on #haskell-blah?
08:02:04 <Paczesiowa> that's what she s.. no, this is the wrong place
08:02:33 <Paczesiowa> shapr: why not cabal install pkg1 pkg2 pkg3
08:02:35 <comrade`phil> my IRC window is so huge and full of crap
08:03:23 <shapr> Paczesiowa: Well, I did that once before as a shell script, and yes, many of the packages failed. But I wanted to some way to report build failures, along with my build machine's arch and stats, etc.
08:03:38 <Paczesiowa> shapr: maybe install hackage
08:03:46 <Berengal> shapr: Where would you report to?'
08:03:54 <Paczesiowa> 'them'
08:03:57 <shapr> I don't have a good answer for that.
08:04:06 <Paczesiowa> probably dons:)
08:04:11 <shapr> Every package has a maintainer listed, yeah?
08:04:37 <shapr> It's true that there's not a trac instance for every hackage package.
08:04:41 <Berengal> shapr: I don't think it's mandatory
08:04:52 <Berengal> And it doesn't need to be a mail address
08:05:12 <shapr> I think a separate trac instance for each would be way too much overhead anyway. What I'd like instead is a way to submit failing test cases to the hackage repo.
08:05:36 <ksf> hackage bug trackers are a good idea.
08:05:46 <ksf> ...as is the hackage wiki docs idea.
08:06:29 <transiluminescen> how do i remove a previous version of ghc so i could install the 6.10.4?
08:06:34 <transiluminescen> in os x?
08:06:43 <transiluminescen> if there's any mac programmers
08:06:51 <shapr> Oh hey, I have a running copy of OS X, I should try this.
08:06:54 <benmachine> I used to use mac a while ago
08:06:58 <benmachine> how did you install it?
08:07:20 <transiluminescen> i found a 6.10.1 binary on one of the wikis
08:07:31 <transiluminescen> it'd integrate into xcode
08:07:54 <transiluminescen> but every time i would try to compile simple stuff from tutorials i'd get errors up the wazoo
08:07:55 <shapr> ksf: Who mentioned hackage wiki docs?
08:08:09 <transiluminescen> on it right now
08:08:16 <transiluminescen> that's where i found the new installer
08:08:32 <ksf> shapr, someone in the cafe, some time ago.
08:08:52 <shapr> It'd be fine if HaskellWiki didn't turn off the creation of new accounts.
08:08:55 <benmachine> transiluminescen: I don't know much about that way of doing it, sorry
08:09:04 <transiluminescen> that's alright, i'll find a way
08:09:20 <shapr> transiluminescen: Did you try installing the latest OSX ghc binary and see if that works?
08:09:26 <transiluminescen> i was going to start up a conversation yesterday but the frustration levels were going up
08:09:32 <shapr> I don't think it'll fix the xcode integrated package, but you should have ghc again.
08:09:32 <transiluminescen> downloading it right now shapr
08:09:58 <transiluminescen> ideally, i'd want the old compiler gone before i install the new one
08:10:20 <shapr> right, I can understand that.
08:10:43 <shapr> I wonder if I could extend my shell script to report build errors.
08:10:57 <shapr> Actually, I wonder if I could extend hackage to show build errors in the package listing.
08:11:14 <transiluminescen> maybe. you'd know way more about it than me =p
08:11:39 <shapr> transiluminescen: Heh, I'm thinking out loud :-)
08:11:42 <Nafai> shapr: Did you see my ambious project ideas?
08:11:44 <Berengal> shapr: Like some sort of os/compiler matrix?
08:11:46 <gwern> shapr: new accounts are still on
08:11:49 <shapr> Berengal: Exactly
08:11:56 <shapr> gwern: Oh, I thought it said?
08:11:58 <shapr> Nafai: Tell me about them!
08:12:10 <gwern> shapr: the sitenotice was unfortunately misleading
08:12:15 <shapr> aha
08:12:21 <Berengal> shapr: That could actually be put into cabal-install, possibly... If you're building on a compiler/os not already reported, report
08:12:28 <shapr> ohh, good point!
08:12:47 <shapr> or just "build; report" and then hackage can list the results.
08:13:26 <shapr> I wonder if that would overwhelm the bandwidth of hackage.haskell.org
08:13:50 <shapr> hiya michaelfeathers!
08:14:18 <Berengal> It'd probably have to be an extra flag or something. Firstly, I don't like programs uploading stuff by default, and secondly, bandwith might become a concern
08:14:21 * shapr checks to see if 6.10.4 is in ubuntu
08:14:26 <michaelfeathers> shapr: Hi.
08:14:40 <Nafai> shapr: 1) Cross-platform GUI wrapper around GHCI ala WinHugs using Cario.  2) Webkit-based web browser similar in architecture to Yi or Xmonad, inspired a bit by uzbl.  Basically a build-your-own browser toolkit.
08:14:55 <shapr> michaelfeathers: You ever show up in Boston? Would be fun to sit around and swap anecdotal thoughts on OO vs FP.
08:14:57 <mike-burns> People aren't doing 'cabal install' so frequently that it'll DDoS the server. (Here I assume things about the server.)
08:15:24 <gwern> we might want to default to uploading just because the hardcore devs who would know about and enable the flags are precisely the people whose statistics we don't care about
08:15:50 <mike-burns> Make it configurable in .cabal/config , etc.
08:15:53 <shapr> Nafai: 1) is a really great idea, as for 2) I don't know uzbl, but it sounds nifty. Sort of like anyone can write a web framework with Python, you're thinking anyone can write a web browser with Haskell?
08:15:56 <michaelfeathers> shapr: I'm in Boston about once a year or so but it isn't predictable.
08:16:06 <gwern> mike-burns: disableable, sure, but the default is really important
08:16:27 <shapr> michaelfeathers: Send me a message if you have a few hours to sit and chat in Boston. I'd enjoy it!
08:16:28 <mike-burns> gwern: I agree with your suggestion of defaulting to on.
08:16:35 <Berengal> gwern: But who knows what might pop up in build errors? I'm not completely against it, but by default I don't like programs sending information by default
08:16:50 <mike-burns> Nafai: You made Webkit bindings?
08:16:51 <michaelfeathers> shapr: Sure thing.
08:16:53 <Nafai> shapr: http://uzbl.org Just like you put together pieces from xmonad to have exactly what you want, you can put together the pieces of a browser to have what you want...only include bookmarks if you want them, etc.
08:17:09 <gwern> Berengal: what's better, lots of useful results with hypothetical privacy violations, or fewer, useless & secure results?
08:17:10 <Nafai> mike-burns: No, this is just an idea, I'd have to do so if I wanted to do this
08:18:12 <mike-burns> That's a slippery slope of an argument.
08:18:23 <Berengal> gwern: How do you know they're hypothetical?
08:18:37 <shapr> Berengal: Hackage is in the default "trust" mode right now anyway...
08:18:39 <Berengal> gwern: Anyway, with an option in the config to turn on reporting, I don't think there'd be few of them
08:18:42 <gwern> Berengal: because I don't have an actual example
08:18:45 <shapr> Berengal: I'd say start with trust, and change when you have to.
08:19:01 <shapr> gwern: The best example is that hackage package do not require authentication right now anyway.
08:19:09 <benmachine> is a prompt too much to ask?
08:19:12 <gwern> shapr: certainly it's a good argument
08:19:30 <gwern> 'why care about this small hole when we have all these massive security goatses anyway?
08:19:34 <shapr> hehe
08:20:00 <shapr> grr, ubuntu server version has ghc6.8.2 :-(
08:20:26 <mike-burns> benmachine: Would the prompt default to on or off? 'Do you want to report build failures to the author automaticaly? [Yn]' Or is it [yN] ?
08:20:27 <gwern> Nafai: fwiw, a gui shell around ghci would be much more valuable to the haskell community, I think, especially if it works in windows without a glitch
08:20:40 <Nafai> I agree
08:20:42 <shapr> I think the best approach is "start out trusting, change when required."
08:20:52 <shapr> Otherwise nothing would get written.
08:20:53 <Nafai> I should look at the code to WinGHCI to see what they do
08:21:07 <benmachine> mike-burns: well, if you were really worried about biasing the result you could be a bit more annoying and do [yn]
08:21:11 <mike-burns> Nafai: Oh I skimmed over the GUI shell thing when i saw Webkit. That would be awesome and wondeful to play with.
08:21:13 <benmachine> but I think [yN] would be fine
08:21:24 <ray> i'd like to report build errors automatically and anoymously, because i feel like a jerk doing it on ir
08:21:27 <ray> c
08:21:48 <gwern> I disagree; you should be insecure and easy when you're a growing community, because every little % you lose costs you exponentially more as time goes on; when the community is static or growing slowly, then it's fine to tighten down copyright and security stuff
08:22:11 <mike-burns> Copyright is hard to tighten down after the fact.
08:22:24 <ray> i assume he means "kick out those gpl losers" :P
08:22:36 <shapr> mike-burns: As I learned when I ran the HaWiki, before the HaskellWiki, and shut it down because it had no clear copyright.
08:22:48 <mike-burns> Ouch.
08:23:37 <gwern> mike-burns: when you have a large community, then it doesn't matter if you have to scrap code wholesale - you now have people to replace that code
08:23:37 <shapr> But, there wouldn't have been a HaskellWiki if HaWiki had not been so successful, so I think there are good points to both approaches.
08:24:19 <gwern> in a small community, you can't afford to get rid of code - that code may well represent that person's sum contribution to the community since they moved on to a different/larger community
08:25:05 <mike-burns> Well either way I will use whatever modification is made to cabal to report build errors and will turn on the reporting functionality as needed.
08:25:21 <ksf> gwern, I think that's a feature leksah should have.
08:25:33 <gwern> what?
08:25:39 <ksf> a ghci shell.
08:25:53 <gwern> it doesn't let you do that? even emacs-mode lets you bring up ghci
08:26:24 <mike-burns> Whoa. That'd be awesome. I would consider using leksah if it had a ghci shell that let me build a GUI.
08:26:38 <gwern> consider youtube; if they scrapped all their copyrighted content, would they still be successful? of course. they're a huge community now, too big to fail. but suppose they had banned copyrighted sutff from the beginning? ...then the story of youtube might be a little more dismal
08:27:40 <ksf> leksah should have a ghci-tab by default, always having the current file loaded.
08:27:51 <ksf> it already compiles in the background, anyway.
08:28:27 <ksf> but I think the author is avoiding messing with the ghc api.
08:28:56 <gwern> don't blame him. api brings a 20MB heavier binary, locks you into particular ghc version, and leads to many linker errors
08:29:15 <ksf> ...and ghc doesn't do incremental compiling, although haskell is actually the optimal implementation language choice to do it.
08:29:16 <gwern> not to mention it's an incredibly painful lowlevel interface unless you go through hint
08:29:29 <Lemmih> ksf: How so?
08:29:36 <ksf> laziness.
08:29:38 <Cale> gwern: Linker errors?
08:29:44 <gwern> Cale: the diamond dep issue
08:29:52 <ksf> well, actually, frp fits the concept better.
08:29:57 <gwern> ghc links against one bytestring, everything links against something else
08:30:08 <gwern> that's why yi disable ghc api by default - too damn many link errors
08:30:18 <Lemmih> ksf: What has that got to do with compilation?
08:30:20 <Cale> Oh, I wouldn't call those linker errors...
08:30:40 <ksf> Lemmih, not recalculating stuff that hasn't changed.
08:30:42 <Cale> It's caught well before the linking stage, I would hope.
08:30:45 <Lemmih> ksf: It may help with JIT execution but it shouldn't help with compilation.
08:31:55 <ksf> afair, the eclipse java compiler takes source deltas from the editor and is able to compile single functions and replace them inside an already compiled .class file.
08:32:17 <ksf> compiling java is trivial, though.
08:32:25 <ksf> no inlining, no nothing.
08:33:18 <Berengal> Incrementally compiling haskell is no good when you want binaries. It'd be incredibly awesome to have if the editor included ghci though
08:33:31 <Lemmih> ksf: I still don't see how laziness would help.
08:33:34 <gwern> not sure I'd want that. how could you trust it?
08:33:36 <Berengal> It'd also give you access to the things in the file that still compile
08:33:47 <ksf> Lemmih, that's why I corrected myself to frp.
08:34:24 <Lemmih> ksf: As in Functional Reactive Programming?
08:34:29 <ksf> yep.
08:34:32 <gwern> Berengal: so the interpreter would have a bunch of stubs and only compile things necessary to interpret expressions sent to the repl? yes, I could see how that'd let you use the non-broken functions
08:34:51 <Lemmih> ksf: How would that help with doing incremental compilation?
08:34:52 <Berengal> Having to undo changes so I can reload the file in ghci to check a type or import only to redo the changes afterwards is incredibly annoying
08:35:07 <ksf> gwern is describing it right now.
08:35:38 <ksf> ...every function is its own behaviour, if they don't change, they won't be recompiled. as soon as they change, they get recompiled.
08:35:42 <Berengal> At the very least ghci should have an "undo last reload" function...
08:35:54 <Lemmih> gwern: What has that to do with laziness or frp?
08:36:05 <gwern> frp? no idea
08:36:34 <gwern> Berengal: what really annoys me is losing access to defined variables when reloading a file
08:36:55 <Lemmih> ksf: Even in strict non-functional languages you can skip recompiling functions that haven't changed.
08:37:13 <gwern> especially when working with string processing - I do file <- stuff, and I want to test out incrementally the output of 'foo file', but a reload costs me 'file'
08:37:31 <ksf> Lemmih, sure you can, and if (foo() && bar()) {...} is lazy in bar().
08:37:37 <Berengal> gwern: Yes, that too is annoying, although I don't think it's too bad to do so by default. It'd be nice to have an *Interactive* module you could import/unimport though
08:37:52 <Berengal> And perhaps :dump
08:38:30 <gwern> my theory is that <- is lazy in ghci, so it has to dump all the variables just in case readFile or whatever has changed
08:38:39 <ksf> I'm just saying that frp caputures the "part of the world changes" aspect well.
08:39:32 <ray> by incremental compiling, do you mean the cool stuff that lisp has but nobody cares about because lisp is useless?
08:39:56 <ksf> incremental compiling means not re-compiling everything.
08:40:10 <ksf> ...just stuff that changes and things that depend on it.
08:40:23 <ksf> ghc currently only does it on a per-file basis, not finer grained.
08:40:28 <gwern> (when the only tool you have is frp, everything looks like a set of relations to be expressed declaratively)
08:40:36 <ksf> (I guess mostly due to the fact that it gets its data file-wise)
08:40:38 <ray> yeah, ghc is practically a c compiler =o
08:41:00 <gwern> ray: have you ever noticed that ghc ~= gcc ???
08:41:10 <ray> yes
08:41:42 <ksf> we need Language.C.Eval, then we have ghc == gcc
08:41:45 <ray> it has ghci though
08:42:06 <wmealing> can someone tell me what this kind of linker error means: http://dpaste.com/77313/
08:42:07 <Berengal> ghci could be better.
08:42:15 <Berengal> It's pretty simple as far as a repl goes
08:42:18 <ray> yes
08:42:26 <Berengal> But any repl is way better than no repl
08:42:30 <Lemmih> ksf: Type-checking would make that very difficult.
08:42:34 <ksf> wmealing, use ghc --make
08:42:45 <wmealing> ok
08:42:49 <ksf> ...and don't use -o.
08:42:53 <Lemmih> ksf: (re-incremental compilation of single files)
08:43:07 <wmealing> righto
08:43:34 <wmealing> ksf: did it.. thanks
08:44:45 <ksf> Lemmih, yep, compiling java is certainly easier than compiling haskell
08:45:04 <ksf> ...and I've got all my compiler experience from hacking a preprocessor into eclipse.
08:46:15 <transiluminescen> okay time for some dumb questions to take my mind of doc searching
08:46:29 <transiluminescen> what's the difference between installing just the compiler versus the platform
08:46:29 <transiluminescen> ?
08:46:47 <pikhq> transiluminescen: The platform includes some tools and libraries.
08:47:00 <transiluminescen> so that would be the more prudent choice
08:47:13 <pikhq> It's like a "batteries included" distribution.
08:47:15 * shapr boings cheerfully
08:47:22 <transiluminescen> ahahah
08:47:27 <transiluminescen> okay
08:47:33 <transiluminescen> next question
08:47:39 * ksf recommends doing "emerge cabal-install" and then cabal installing whatever you want as a user.
08:47:49 <transiluminescen> should i really care too much about removing the old compiler?
08:47:57 <pikhq> ksf: I just install it all through Portage, m'self.
08:48:05 <transiluminescen> ksf i'm on os x. not using any port system
08:48:07 <shapr> What's the best ghc 6.10.4 package for ubuntu 9.04?
08:48:18 <shapr> Or should I just install debian/unstable over this box?
08:48:31 <ksf> transiluminescen, not too much, as long as you get your paths straight.
08:49:05 <ksf> I've always got a ghc installed system-wide, but occasionally also use a HEAD version that I install in my $HOME
08:49:11 <transiluminescen> well the binary package does all the work
08:49:31 <ksf> shapr, you should get yourself a proper distribution.
08:49:35 <ksf> like gentoo, or gentoo.
08:49:43 <shapr> :-P
08:49:49 <transiluminescen> AHAHAHHA
08:49:50 <transiluminescen> oh man
08:49:55 <transiluminescen> that's a good one
08:49:56 <shapr> I like debian, I've been trying ubuntu server on my bladecenter.
08:50:11 <Botje> shapr: ubuntu 8.10 has 6.10.4 packages, you could steal those?
08:50:18 <Botje> uh, 9.10
08:50:30 <shapr> Can I dist-upgrade to 9.10?
08:50:54 <benmachine> gentoo or gentoo or arch
08:50:57 <benmachine> tip: arch
08:51:28 <ksf> lfs comes to mind, too.
08:51:49 <ksf> http://www.linuxfromscratch.org/
08:52:07 <shapr> Botje: Can I just change jaunty to something else in /etc/apt/sources.list and then dist-upgrade? If so, what do I change it to?
08:52:24 <shapr> Perhaps I should put BSD on my quad core blade.
08:52:29 <mike-burns> If you have the time, figure out what's needed to get the latest ghc running on Ubuntu and submit a patch. (I've no idea if someone has done this already, which brings you back to your first question.)
08:52:39 <shapr> heh
08:52:49 <shapr> So much for a clear cut goal for today :-)
08:52:56 <ksf> monolithic distribution releases are hell.
08:53:10 <benmachine> I wouldn't describe them as hell
08:53:19 <benmachine> like, my wireless card still works on ubuntu
08:53:23 <mike-burns> shapr: We have ghc 6.10.4 running on FreeBSD as a patch. It's not in the ports tree yet. Join #haskell-freebsd if you're serious and want help.
08:53:26 <benmachine> I consider that handy
08:53:54 <ksf> I think the portage profile I use is from beginning of 2008, It's still the current one.
08:54:20 <mike-burns> Amusingly I've been reading http://funroll-loops.info/ since before this conversation started.
08:54:40 <ray> that website is almost as stupid as gentoo
08:55:05 <mike-burns> That Web site is quotes from Gentoo users; it's exactly as stupid/smart as Gentoo.
08:56:01 <pikhq> ksf: Please, don't be as stupid as funroll-loops.info.
08:56:11 <shapr> pikhq: Hey, be nice.
08:56:54 <ksf> CFLAGS="-march=k8 -pipe -O2"
08:56:55 <ksf> CHOST="x86_64-pc-linux-gnu"
08:57:06 <ray> GHCFLAGS=
08:57:12 <ksf> nope, I tend to know what I'm doing while compiling C.
08:58:02 <Ke> distro flamewar is on \o/
08:58:12 <mike-burns> Meh.
08:58:13 <Zao> I run the best distro ever. Windows.
08:59:06 <pikhq> Zao: Gentoo GNU/Windows *is* rather nice.
08:59:13 <pikhq> (... Yes, it exists.)
08:59:16 <wmealing> Zao: that comment may be truer than you think soon enough.
08:59:24 <mike-burns> Which distros have great Haskell support? Gentoo and Arch?
08:59:37 <transiluminescen> slackware!!!!!!
08:59:37 <Zao> I wouldn't say no to a proper decent GNU subsystem on Windows.
08:59:46 <Zao> With a nice accelerated X server and all.
08:59:46 <ray> that would be ridiculous
08:59:50 <transiluminescen> oh god have i missed slack
08:59:51 <Ke> GeNToo
09:00:05 <roconnor> Gentoo is a source distribution right?  How does building GHC work with Gentoo, since GHC needs GHC to build?
09:00:21 <wmealing> it does ?
09:00:22 <Cale> roconnor: They also have a binary of GHC
09:00:26 <Cale> wmealing: Of course.
09:00:27 <Ke> roconnor: it has ghc binary to bootstrap
09:00:31 <mike-burns> roconnor: On FreeBSD we use a bootstrap.
09:00:34 <ray> the subway is great, i just wish it was a bus line, right?
09:00:38 <ksf> it can either use the installed ghc, or download a binary to do it.
09:00:40 <Cale> wmealing: GHC is written in GHC Haskell :)
09:00:53 <wmealing> that could become a problem when porting to new platforms.. no ?
09:01:00 <ray> generalized haskell concordance
09:01:02 <mike-burns> wmealing: It's tricky.
09:01:07 <ksf> gentoo isn't a source distribution, btw, it's a meta-distribution.
09:01:17 <wmealing> i havn't looked into it.. just was thinking about the problem
09:01:19 <ksf> you can complie your own sets of binary packages.
09:01:22 <ray> i thought people stopped saying that in 2006
09:01:26 <mapreduce> Most compilers have that issue.
09:01:29 <wmealing> yeah
09:01:47 <Zao> mike-burns: On select platforms with FreeBSD you use a bootstrap.
09:01:48 <mike-burns> wmealing: There are out-of-date docs online for porting to new archs that will get you close. You need a lot of dedication.
09:01:53 <Zao> For us poor suckers with sparc64, nothing :P
09:01:55 * wmealing nods
09:02:04 <ray> self-hosting is a solved problem btw, it just takes work
09:02:07 <mike-burns> Zao: This is true.
09:02:17 <mapreduce> The only one I can think of that doesn't, MS's C# compiler (written in C++) isn't gonna appear on gentoo anyway. :)
09:04:00 <Berengal> > let flipfix = flip flip in flipfix [1,2,3,4,5] elem 3
09:04:02 <lambdabot>   True
09:04:10 <Berengal> > let flipfix = flip flip in flipfix [1,2,3,4,5] elem 6
09:04:12 <lambdabot>   False
09:04:24 <ray> =o
09:05:07 * Berengal considers renaming it to "backticks"
09:05:09 <roconnor> @type flip flip flip
09:05:11 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
09:05:15 <Berengal> or withBackticks
09:05:15 <ksf> great. ghc 6.10.4 is masked and it doesn't say why.
09:05:35 <Infamous_Cow> i cant figure out how to convert Char to Integer, i looked on hoogle, nothing
09:05:43 * mike-burns strikes Gentoo off the list of distros great for Haskell
09:05:44 <mapreduce> > ord 'c'
09:05:46 <lambdabot>   99
09:05:50 <roconnor> Infamous_Cow: fromEnum or Char.ord
09:05:51 <pikhq> :t ord
09:05:52 <lambdabot> Char -> Int
09:06:05 <Infamous_Cow> I need Integer, not Int
09:06:06 <roconnor> ... composed with a fromIntegral
09:06:12 <Infamous_Cow> oh
09:06:14 <ksf> mike-burns, autounmask dev-lang/ghc-6.10.4 and you're done.
09:06:18 <pikhq> mike-burns: It's masked because Gentoo's become a tiny bit of a stickler for stability in recent years. ;)
09:06:44 * roconnor isn't very happy with fromEnum returning Int
09:06:47 <ksf> well, they should just ~ it.
09:07:13 <ksf> maybe they're concerned about backwards compability of other stuff in portage.
09:07:16 <pikhq> I think it is in the Haskell overlay.
09:07:21 <ksf> like that exception nightmare.
09:07:44 <ksf> the overlay doesn't come wih 6.10.4
09:08:15 <dmwit> roconnor: Yes, what will we ever do with our enumerations that have more than 2^29 values...
09:08:17 <dmwit> ;-)
09:08:52 <pikhq> mike-burns: Keep in mind: In Gentoo, the latest stable of KDE is KDE 3.5.10. ;)
09:09:16 <ManateeLazyCat> :t zipMap
09:09:17 <lambdabot> Not in scope: `zipMap'
09:09:22 <ManateeLazyCat> :t unzipMap
09:09:24 <lambdabot> Not in scope: `unzipMap'
09:09:25 <ManateeLazyCat> @let zipMap (g, h) s = (g s, h s)
09:09:27 <lambdabot>  Defined.
09:09:32 <ManateeLazyCat> @let unzipMap h = (fst . h, snd . h)
09:09:34 <lambdabot>  Defined.
09:09:35 <pikhq> They've really become more of a "make sure everything works right" distro than a "bleeding edge" distro.
09:09:39 <mike-burns> pikhq: So Gentoo is the new Debian with regards to up-to-date packages?
09:09:48 <dmwit> ManateeLazyCat:
09:09:54 <dmwit> :t \f g -> map (f &&& g)
09:09:56 <lambdabot> forall a c c'. (a -> c) -> (a -> c') -> [a] -> [(c, c')]
09:10:02 <roconnor> dmwit: we will take short intervals of objects with codes greater than 2^29.
09:10:06 <pikhq> mike-burns: Except that it's trivial to use the testing version of certain packages.
09:10:17 <mike-burns> pikhq: Well I'm glad they got that right.
09:10:34 <dmwit> roconnor: Yeah, that's the other use case.  I'm truly sorry for your lots.
09:10:37 <pikhq> And if you *want* to be on the bleeding edge, it's not that hard either.
09:10:55 <pikhq> They tend to have packages in the tree (unstable) upon release.
09:10:56 <ksf> debian doesn't come with git/darcs packages, either.
09:11:16 <ksf> ...and my mirror is down.
09:11:23 <dmwit> :t unzipMap
09:11:24 <lambdabot> forall a1 a b. (a1 -> (a, b)) -> (a1 -> a, a1 -> b)
09:11:38 <dmwit> hm
09:12:32 <dmwit> That's an interesting one.
09:15:59 <Botje> shapr: sorry, had something else to do for a while. I think you can use so-called apt pinning to grab the karmic ersions of ghc packages
09:16:15 <shapr> I discovered #ubuntu+1 and am now upgrading to karmic
09:16:20 <Botje> h
09:16:29 <Botje> oops
09:16:32 <shapr> Thanks though :-)
09:16:38 <Botje> i've been running karmic for a while now
09:16:42 <Botje> it's mostly stable
09:18:12 <dmwit> 99.99% indestructible
09:19:08 <ray> so it gets destroyed one out of every ten thousand times
09:19:19 <wmealing> heh
09:19:20 <mike-burns> On average.
09:19:37 <Baughn> So it won't happen to you.
09:19:39 <Botje> which, in practice, happens seven times out of ten :)
09:19:51 <ray> unless you run it for ten thousand seconds
09:19:56 <ray> then, statistically, it will
09:20:13 <EvilTerran> wouldn't it be 10k time quanta?
09:20:15 <wmealing> is simulation the right word to use, when attempting to simulate game mechanics to optimize for a solution ?
09:20:24 <wmealing> or is it called something else
09:20:30 <ray> well, based on my data, it's not planck times
09:20:42 <EvilTerran> maybe you're just lucky :D
09:20:46 <ray> possibly
09:20:53 <Baughn> That level of luck doesn't happen
09:21:17 <EvilTerran> wmealing, as in, an AI opponent "looking ahead" to try to pick a good move?
09:21:20 <ray> well i've never experienced quantum tunneling, so gambler's fallacy says it has to
09:21:44 * Baughn sees a hole in that theory
09:21:49 <ray> it's flawwless
09:21:54 <Baughn> @quote fallacy
09:21:54 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
09:21:56 <ray> just like my spelling there
09:22:10 <wmealing> EvilTerran: not really.... more along the lines of what the player should do with all the tools at their disposal for the enemies scripted moves.
09:22:12 --- mode: ChanServ set +o mauke
09:22:12 --- mode: mauke set +b *!*@87.110.231.77
09:22:23 <Baughn> I'm not sure what a flaww is, but I can admit that your argument probably has none.
09:22:55 <ray> flaws freed of every flaw
09:22:59 <wmealing> mauke: did someone here do something wrong  ?
09:23:05 <ManateeLazyCat> > (fst $ unzipMap (\x -> (succ x, pred x))) 1
09:23:07 <lambdabot>   2
09:23:07 <ksf> "Binary packaging does encourage sloppy coding/design, contrast with the stochastic API unit testing which occurs naturally with all the building with different configurations."
09:23:09 <ksf> so true.
09:23:11 <Botje> just a stupid spammer kid.
09:23:12 --- mode: mauke set -o mauke
09:23:13 <ManateeLazyCat> > (snd $ unzipMap (\x -> (succ x, pred x))) 1
09:23:14 <lambdabot>   0
09:23:19 <wmealing> ok
09:23:21 <ksf> ...or what other reason do we have for hackage?
09:23:42 <ray> i thought hackage was a convenient repository of packages for the working haskeller
09:24:14 <ksf> well, but it could be binary packages.
09:24:34 <ray> no
09:24:47 <ManateeLazyCat> :t \x -> unzipMap (\x -> (succ x, pred x))
09:24:48 <lambdabot> forall t a1. (Enum a1) => t -> (a1 -> a1, a1 -> a1)
09:25:03 <ksf> shoure it could, all you need is the .a and the interface file.
09:25:08 <ManateeLazyCat> :t \x -> unzipMap (succ, pred)
09:25:10 <lambdabot>     Couldn't match expected type `a1 -> (a, b)'
09:25:10 <lambdabot>            against inferred type `(a11 -> a11, a2 -> a2)'
09:25:10 <lambdabot>     In the first argument of `unzipMap', namely `(succ, pred)'
09:25:13 <wmealing> EvilTerran: no ideas ?
09:25:31 <ray> that's a flawwed idea
09:25:33 <ManateeLazyCat> :t \x -> unzipMap (succ x, pred x)
09:25:34 <lambdabot>     Couldn't match expected type `a1 -> (a, b)'
09:25:34 <lambdabot>            against inferred type `(a11, a11)'
09:25:34 <lambdabot>     In the first argument of `unzipMap', namely `(succ x, pred x)'
09:25:50 <ksf> ray, and that's why debian is inherently flawed, too.
09:25:52 <EvilTerran> wmealing, as long as you define your terms, you can use any word you like - "simulation" should be fine :)
09:28:21 <wmealing> EvilTerran: i guess so ;)
09:32:20 * shapr cabal installs hackage
09:40:13 <jmcarthur> hmm... it would be nice if max and min on Natural were lazy
09:42:09 <ksf> use [()]?
09:42:50 <ksf> a num instance for lists would be a nice thing to confuse people...
09:42:57 <jmcarthur> oh gosh
09:43:01 * mauke has one
09:43:04 <jmcarthur> sounds like a lisp
09:44:03 <dmwit> > let (+) = (++); (*) = (>>) in length $ ([(), ()] + [()]) * [(), (), (), ()]
09:44:04 <lambdabot>   12
09:44:08 <dmwit> whee
09:44:50 <jmcarthur> would be a trivial newtype at least
09:45:24 <mauke> *> ([(), ()] + [()]) * [(), (), (), ()]
09:45:24 <mauke> [(),(),(),(),(),(),(),()]
09:45:50 <jmcarthur> something is wrong with that
09:46:36 <ksf> there's also a good chance [()]s get optimized into Integers.
09:46:38 <mauke> I don't think so
09:47:13 <jmcarthur> (2+1)*4  ==>  3*4  ==>  12
09:47:16 <jmcarthur> but that says 8
09:47:43 <jmcarthur> or am i missing something?
09:47:45 <pikhq> @src Num
09:47:46 <lambdabot> class  (Eq a, Show a) => Num a  where
09:47:46 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:47:46 <lambdabot>     negate, abs, signum     :: a -> a
09:47:46 <lambdabot>     fromInteger             :: Integer -> a
09:47:54 <pikhq> @src Integral
09:47:55 <lambdabot> class  (Real a, Enum a) => Integral a  where
09:47:55 <lambdabot>     quot, rem, div, mod :: a -> a -> a
09:47:55 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
09:47:55 <lambdabot>     toInteger           :: a -> Integer
09:48:22 <jmcarthur> ksf: you really think [()] might be optimized to integers?
09:48:41 <mauke> jmcarthur: you can give me more expressions to evaluate; see if you can figure out what it's doing :-)
09:49:00 <jmcarthur> mauke: sounds intentional, so i'm happy with that at least :P
09:49:11 <pikhq> Hmm. Looks to me like it'd be pretty easy to make a Num instance. Just one from 0 to oo. ;)
09:49:18 <mauke> more like accidental
09:50:26 <dmwit> mauke: Oh, I remember this.
09:50:32 <dmwit> mauke: "happy" + 1, please
09:51:04 <mauke> "ibqqz"
09:51:11 <dmwit> =)
09:51:47 <jmcarthur> oh
09:52:42 <artagnon> I want to find the first triangle number that has more than 50 factors. In my attempt, I've driven myself crazy with list comprehension. There *has* to be an easier way, yes? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8039#a8039
09:53:05 <dmwit> ack
09:53:22 <artagnon> def. triangleNumber x = sum $ take x [1..]
09:53:27 <Hunner> artagnon: project euler?
09:53:34 <artagnon> Yes.
09:53:45 <dmwit> > scanl1 (+) [1..]
09:53:46 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
09:53:47 <artagnon> I'm just learning Haskell. I thought Project Euler would be a good starting point.
09:53:53 <mauke> [ x | x <- y ] better written as y
09:53:58 <artagnon> darn
09:54:10 <ksf> jmcarthur, dunno.
09:54:14 * artagnon makes some quick changes
09:54:37 <dmwit> :t \factors -> filter ((>500) . length . factors)
09:54:40 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a1]
09:54:42 <jmcarthur> i'm a bit doubtful about that optimization
09:54:54 <ksf> but then, writing your own Natural on top of Integers truly emulating church encoding isn't that much work, either.
09:55:00 <mauke> > scanl1 (+) [1 ..]  -- artagnon
09:55:02 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
09:55:10 <dmwit> mauke: too slow =)
09:55:14 <mauke> oh, oops
09:55:16 <artagnon> mauke: yeah, dmwit pointed that out
09:55:35 <mauke> yeah, I was looking at my own (3 line) solution
09:55:36 <pikhq> Hmm...
09:55:36 <dmwit> > let factors n = [1..n] in filter ((>500) . length . factors) $ scanl1 (+) [1..]
09:55:38 <lambdabot>   [528,561,595,630,666,703,741,780,820,861,903,946,990,1035,1081,1128,1176,12...
09:55:39 <pikhq> @src Natural
09:55:40 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:56:00 <jmcarthur> ksf: how would one represent the output of genericLength [1..] using a representation with Integers?
09:56:05 <dmwit> Now just substitute a correct implementation for factors. =)
09:57:02 <ksf> jmcarthur, in the same way as with church numerals: not at all.
09:57:11 <ksf> infinity is just too big for all of them.
09:57:17 <jmcarthur> i mean lazily
09:57:24 <jmcarthur> as that is the purpose
09:57:41 <mauke> divisors n = [k | k <- [1 .. n - 1], n `mod` k == 0]
09:57:47 <artagnon> ok, refactored: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8039#a8040
09:57:52 <ksf> (;) is +1, uncons -1, (==0) is []
09:58:04 <ksf> it's only a space optimisation, not in time.
09:58:10 <dmwit> artagnon: That's looking better. =)
09:58:31 <dmwit> artagnon: Note that the outer parentheses in triangleSeries are unnecessary, but otherwise that looks quite clean indeed.
09:58:54 <jmcarthur> ksf: 10 `min` infinity ... how would this evaluate with a strict representation like that?
09:59:25 <artagnon> dmwit: Thanks for your help! :0
09:59:58 <ksf> it would decrement the lhs ten times, notice a zero, and return the original lhs.
10:00:05 <dmwit> artagnon: You can also use list comprehensions if you really want...
10:00:16 <jmcarthur> ksf: what about the rhs?
10:00:25 <dmwit> euler12 = head [x | x <- scanl1 (+) [1..], length (factors x) > 500]
10:00:26 <ksf> ...it also gets decremented 10 times.
10:00:28 <Plouj> mah, ch10 of RWH is convoluted
10:00:31 <jmcarthur> ksf: from what?
10:00:31 <ksf> staying infinity.
10:00:31 <artagnon> ofcourse. I have used function composition and filters before
10:00:32 <artagnon> it just didn't strike me :|
10:00:40 <jmcarthur> Integer doesn't have a representation for Infinity
10:00:46 <ksf> uhm some special value thot isn't in Integer.
10:01:00 <jmcarthur> how does it even know that it's infinity?
10:01:09 <roconnor> @type infinity
10:01:10 <jmcarthur> 10 `min` genericLength [1..]
10:01:11 <lambdabot> Natural
10:01:13 <Plouj> it needs to explain more what the newtype Parse is used to avoid
10:01:18 <artagnon> Final revision: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8039#a8041
10:01:32 <artagnon> to see how long it takes to finish
10:01:32 <artagnon> going to compile it and run it
10:01:51 <roconnor> > 10 `min` infinity
10:01:53 <lambdabot>   10
10:01:56 <ksf> because you told it so, or something else is generating bigger and bigger numbers that you can decrement, again.
10:02:03 <jmcarthur> roconnor: we are talking about an Integer representation for Natural
10:02:12 <ksf> it's hard because one can't actually construct true infinity.
10:02:32 <dmwit> Specifically: ksf claims an Integer representation for Natural is possible, jmcarthur claims it is not possible. =)
10:02:39 <artagnon> hm.. it's taking a lot more than a few seconds
10:02:44 <jmcarthur> ksf: to continue decrementing a gradually increasing number that like you have to have a lazy representation
10:02:45 <ksf> ...no matter how often you succ, you will _never_ reach infinity.
10:02:45 * artagnon hopes it finishes under a minute
10:02:56 <jmcarthur> *like that
10:02:58 <dmwit> artagnon: If you think a bit more, you can make it go quite a lot faster indeed.
10:03:09 <artagnon> otherwise, I'll have to write a better algorithm for divisors
10:03:10 <roconnor> dmwit: ah
10:03:11 <Zao> "You succ so hard, you reached \infty."
10:03:19 <ksf> jmcarthur, yeah i'm puzzled about that aspect right now.
10:03:27 <artagnon> dmwit: Give me a hint. Which part should I improve? the divisor checking, right?
10:03:28 <ski> > 7 `min` (fix succ :: Natural)
10:03:30 <lambdabot>   7
10:03:35 <dmwit> artagnon: Nope. =)
10:03:42 <artagnon> hm.
10:03:46 <dmwit> artagnon: Here's my hint: what's the closed-form solution for the nth triangle number?
10:04:14 <jmcarthur> wait... how did min suddenly become lazy for Natural? i could have sworn i just tried it and it wasn't lazy!
10:04:25 <dmwit> eh?
10:04:32 <dmwit> Of course min is lazy for Natural.
10:04:34 <roconnor> dmwit: like a lazy integer.  For example represented by (Natural,Natural) such that either the first or second pair is 0?
10:04:37 <dmwit> That's the whole point.
10:04:45 <artagnon> dmwit: n(n+1)/2 ? Would that make a difference?
10:04:58 <dmwit> artagnon: It's a start.  Can you see why?
10:04:58 <shachaf> jmcarthur: You tried with genericLength, but didn't specify the type.
10:05:10 <jmcarthur> shachaf: no, private lb session
10:05:23 <jmcarthur> okay, max isn't lazy
10:05:38 <dmwit> Sure it is.
10:05:41 <jmcarthur> > 100 < (genericLength [1..] `max` (genericLength [1..] :: Natural))
10:05:45 <artagnon> dmwit: Folding a lazy list with (+) can take a long time?
10:05:46 <lambdabot>   mueval-core: Prelude.read: no parse
10:05:46 <lambdabot>  mueval: ExitFailure 1
10:05:48 <dmwit> > (10 `max` infinity) > 30
10:05:50 <lambdabot>   True
10:05:52 <ski> > 7 `min` (undefined :: Natural)
10:05:53 <jmcarthur> > 1 < (genericLength [1..] `max` (genericLength [1..] :: Natural))
10:05:54 <lambdabot>   * Exception: Prelude.undefined
10:05:54 <dmwit> jmcarthur: see?
10:05:58 <lambdabot>   mueval-core: Prelude.read: no parse
10:05:58 <lambdabot>  mueval: ExitFailure 1
10:06:04 <artagnon> shit, I hit the 1 min toof
10:06:05 <artagnon> roof*
10:06:06 <ski> jmcarthur : ^ ?
10:06:09 <artagnon> program failed :|
10:06:38 <jmcarthur> > 1 `min` (infinity `max` infinity)
10:06:43 <lambdabot>   mueval-core: Prelude.read: no parse
10:06:43 <lambdabot>  mueval: ExitFailure 1
10:07:02 <jmcarthur> i would expect infinity `max` infinity to give me infinity, not _|_
10:07:11 <dmwit> Yes, me too.
10:07:16 <ksf> jmcarthur, could it be that what you actually want to do is to write an algebraic reduction machine?
10:07:24 <idnar> @src infinity
10:07:25 <lambdabot> Source not found.
10:07:29 <dmwit> What do I have to import to play with this in ghci?
10:07:34 <idnar> > infinity
10:07:36 <lambdabot>   * Exception: stack overflow
10:07:44 <roconnor> > (infinity `max` infinity) > 30
10:07:47 <idnar> is that fix (+1) or something?
10:07:49 <lambdabot>   mueval-core: Prelude.read: no parse
10:07:49 <lambdabot>  mueval: ExitFailure 1
10:07:52 <roconnor> :^)
10:07:59 <ksf> it's infinity = Succ infinity
10:08:02 <jmcarthur> :t infinity
10:08:04 <lambdabot> Natural
10:08:05 <idnar> ah, close enough
10:08:06 <dmwit> idnar: yes, fix Succ
10:08:22 <jmcarthur> @hoogle Natural
10:08:22 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
10:08:22 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
10:08:22 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
10:08:25 <jmcarthur> ugh
10:08:34 <ksf> which is cheating, as it doesn't include Zero and thus just plain doesn't exist.
10:08:42 <jmcarthur> dmwit: Data.Number.Natural
10:08:46 <jmcarthur> in the numbers package
10:08:55 <jmcarthur> (not to be confused with the Numbers package)
10:09:00 <idnar> so I don't think max can return anything in that case
10:09:11 <dmwit> No, it definitely should be able to.
10:09:11 <jmcarthur> idnar: Natural is supposed to be lazy
10:09:15 <dmwit> ah
10:09:22 <dmwit> I bet "max" is defined *outside* the Ord class.
10:09:27 <jmcarthur> nope
10:09:28 <artagnon> New revision: Using closed form triangle series. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8039#a8042
10:09:33 <jmcarthur> it just has a default
10:09:34 <dmwit> No, it is in the Ord class.
10:09:34 <dmwit> odd
10:09:35 <idnar> jmcarthur: yeah, but so what?
10:09:40 <ksf> if you want to deal with infinities like that, you're going to have to leave the warm, fuzzy feeling of constuctive semantics and wander out into the evil domains of formalism.
10:09:45 <jmcarthur> dmwit: the instance allows it to default
10:10:06 <idnar> jmcarthur: a lazy max will help if only one arg is infinity, but if they're both infinity it'll still diverge
10:10:08 <jmcarthur> idnar: i would expect it to be like    Succ a `max` Succ b = Succ (a `max` b)
10:10:21 <jmcarthur> idnar: it should not be _|_
10:10:32 <jmcarthur> i should get a lazy representation of infinity
10:10:49 <artagnon> nope, still doesn't execute in under a minute :'(
10:11:05 <jmcarthur> ksf: it's just codata
10:11:06 <artagnon> I guess I have to write a better algorithm for factors
10:11:18 <idnar> jmcarthur: hmm
10:11:22 <dmwit> Huh, 1 < (infinity `max` infinity) really doesn't return.
10:11:24 <dmwit> Very strange.
10:11:38 <dmwit> artagnon: No thoughts on why n*(n+1)/2 would help?
10:11:46 <shachaf> Where are the implementations of these Naturals?
10:11:56 <dmwit> shachaf: numbers package, in Data.Number.Natural
10:11:58 <jmcarthur> shachaf: lazy peanos
10:12:04 <dmwit> ?hackage numbers
10:12:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
10:12:07 * idnar goes to check the implementation
10:12:15 <dmwit> http://hackage.haskell.org/packages/archive/numbers/2009.8.6.1/doc/html/src/Data-Number-Natural.html#Natural
10:12:21 <jmcarthur> data Natural = N | S Natural, i think (without double-checking)
10:12:28 <dmwit> Data.Number.Natural doesn't define max.
10:12:31 <dmwit> So it's not lazy.
10:12:35 <dmwit> I'll write a patch. =)
10:12:35 <roconnor> idnar: ack, there is no max or min implementation!
10:12:43 <jmcarthur> ah, s/N/Z/
10:12:50 <jmcarthur> dmwit: yay! :D
10:13:14 <idnar> roconnor: aha
10:13:34 <shachaf> > max (succ undefined) 0 > (0::Natural)
10:13:35 <lambdabot>   True
10:13:46 <artagnon> dmwit: Hmm.. no, not really. I don't see any significant improvement in speed. Addition of all the list elements (folding with (+)) should be just as fast.
10:13:47 <Tobsan> artagnon: you don't have to check all the way until n for factors; sqrt n would be enough
10:14:14 <artagnon> Tobsan: Right. I'll fix that.
10:15:10 <idnar> Tobsan, artagnon: except write the check as i * i <= n rather than i <= sqrt n (or something like that)
10:15:27 <shachaf> Why doesn't Data.Number.Natural export the constructors?
10:15:34 <jmcarthur> shachaf: i wondered that too
10:15:36 <Tobsan> idnar: oh yes, good point!
10:15:42 <dmwit> Does it need a definition for min?
10:15:55 <idnar> > 1 `min` infinity :: Natural
10:15:57 <lambdabot>   1
10:16:01 <artagnon> idnar: Sure. sqrt can be expensive
10:16:02 <ksf> hmmm iirc I read something about agda's native Nat type being implemented via machine integers.
10:16:04 <jmcarthur> > infinity `min` 1
10:16:04 <idnar> I guess there's no negative infinity
10:16:05 <lambdabot>   1
10:16:06 <dmwit> artagnon: Do you know how to calculate the number of factors from the prime factorization?
10:16:10 <ski> @src min
10:16:10 <lambdabot> min x y = if x <= y then x else y
10:16:13 <idnar> so it doesn't matter
10:16:17 <jmcarthur> > 1 < (infinity `min` infinity)
10:16:20 <idnar> oh
10:16:22 <lambdabot>   mueval-core: Prelude.read: no parse
10:16:22 <lambdabot>  mueval: ExitFailure 1
10:16:22 <idnar> except, duh
10:16:24 <dmwit> artagnon: If so, being able to factor one step helps a lot with the remainder of the factorization. =)
10:16:25 <jmcarthur> > 0 < (infinity `min` infinity)
10:16:30 <jmcarthur> yeah, it needs one
10:16:30 <lambdabot>   mueval-core: Prelude.read: no parse
10:16:30 <lambdabot>  mueval: ExitFailure 1
10:16:53 <dmwit> Okay, will write min, too.
10:16:59 <artagnon> dmwit: Well, I'll have to think of an algorithm for that.
10:17:01 <roconnor> BTW, the natural package has more efficient natural numbers IIRC
10:17:16 <dmwit> Should min be left-biased or right-biased?
10:17:41 <roconnor> unamb!
10:17:42 <ski> why not left-biased, like `(+)' and `(*)' ?
10:17:44 <roconnor> :P
10:17:52 <ski> (unbiased would of course be better, yes)
10:18:00 <dmwit> Never mind, it doesn't matter.
10:18:04 <mauke> dmwit: no
10:18:06 <dmwit> It can be unbiased.
10:18:09 <mauke> :-)
10:18:12 <dmwit> mauke: right =)
10:18:20 <roconnor> > undefined || True
10:18:22 <lambdabot>   * Exception: Prelude.undefined
10:18:27 <roconnor> > True || undefined
10:18:29 <lambdabot>   True
10:18:36 <roconnor> that way
10:18:47 <dmwit> unbiased is cleaner
10:18:53 <jmcarthur> i think it needn't be biased, as dmwit says
10:19:16 <jmcarthur> Succ a `min` Succ b = Succ (a `min` b)
10:19:18 <roconnor> dmwit: how can it be unbiased?
10:19:58 <ksf> how can it be biased? if both are the same, it doesn't matter which is returned.
10:19:59 <ski> dmwit : by "unbiased" do you mean that both  0 `min` undefined  and  undefined `min` 0  are  undefined  , or that both are zero ?
10:20:11 <ksf> in all other cases you can find the minimum in linear time.
10:20:17 <ray> > let _ || True = True; True || _ = True; _ || _ = False in (undefined || True,True || undefined)
10:20:18 <dmwit> roconnor: S x `min` S y = S (x `min` y), _ `min` _ = Z
10:20:19 <lambdabot>   (True,* Exception: Prelude.undefined
10:20:25 * ray sobs
10:20:37 <jmcarthur> eh, yeah, undefined could make a bias i guess
10:21:00 <jmcarthur> oh i like that
10:21:06 <artagnon> with better factorization
10:21:06 <artagnon> New revision: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8039#a8043
10:21:11 <artagnon> but something's wrong
10:21:17 <dmwit> Z `min` undefined, and undefined `min` Z, are both undefined, but meh, that's okay
10:21:18 <artagnon> it isn't compiling again :|
10:21:27 <shachaf> > (undefined `myOr` True, True `myOr` undefined)
10:21:28 <lambdabot>   (True,True)
10:21:42 <ray> > let ~_ || True = True; True || ~_ = True; _ || _ = False in (undefined || True,True || undefined)
10:21:43 <roconnor> undefined is stupid anyways
10:21:44 <lambdabot>   (True,* Exception: Prelude.undefined
10:21:55 <dmwit> shachaf: um
10:22:03 <dmwit> shachaf: Instruct me in your devil-worshipping ways.
10:22:08 <roconnor> @quote anal
10:22:09 <lambdabot> ddarius says: "pumpkin: Known for StrictAnal"
10:22:10 <shachaf> @let myOr _ _ = True
10:22:11 <lambdabot>  <local>:17:0:
10:22:11 <lambdabot>      Warning: Pattern match(es) are overlapped
10:22:11 <lambdabot>               I...
10:22:12 --- mode: ChanServ set +o mauke
10:22:12 --- mode: mauke set -b *!*@87.110.231.77
10:22:13 <roconnor> @quote anal
10:22:14 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
10:22:14 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
10:22:17 <dmwit> shachaf: hahaha
10:22:21 <roconnor> bah
10:22:24 <dmwit> > False `myOr` False
10:22:26 <lambdabot>   True
10:22:26 <jmcarthur> lol
10:22:30 <dmwit> awesome!
10:22:32 <ksf> it's especially strange as we're dealing with the One True Bottom correctly.
10:22:41 <jmcarthur> myOr could also be written correctly with unamb
10:22:43 <artagnon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8039#a8043
10:22:43 <artagnon> idnar && Tobsan: Is there a better way to write what I've written to limit checking until sqrt?
10:22:48 <dmwit> Hmmm, no contact information or darcs repository for the numbers package...
10:22:48 <ray> oh, unamb
10:23:01 <ray> i despaired for a second there
10:23:12 --- mode: mauke set -o mauke
10:23:14 <roconnor> dmwit: it is traditional to upload numbers packages ourselves
10:23:26 <dmwit> Wait, I can just overwrite the old one?
10:23:41 <roconnor> dmwit: if you have hackage access you can overwrite any hackage package
10:23:46 <dmwit> !!
10:23:48 <jmcarthur> i'm not sure i like that
10:23:51 <shachaf> unamb++
10:23:55 <dmwit> Is anybody planning to change that?
10:24:01 <roconnor> dmwit: nope
10:24:15 <dmwit> wow
10:24:26 <jmcarthur> so there isn't even anything to stop you from *accidentally* overwriting one?
10:24:38 <roconnor> dmwit: I fixed a bug in numbers, and RichardSmith fixed the enum instance for Natural IIRC
10:25:07 <roconnor> jmcarthur: I believe that is correct.  I'm not entirely sure
10:25:26 <jmcarthur> 0_o
10:26:00 <ray> it's fine until malicious hackage users appear
10:26:16 <Saizan> jmcarthur: well, the older version will always be there
10:27:43 <roconnor> dmwit: now tell Cale to get the latest numbers for lambdabot
10:27:50 <dmwit> phew, hackage is slow
10:27:53 <roconnor> dmwit: and maybe email augustss
10:28:18 <dmwit> ?tell Cale I'm uploading a new version of the "numbers" package to Hackage as we speak.  Could you grab it for lambdabot?
10:28:18 <lambdabot> Consider it noted.
10:28:20 <roconnor> oh right no email
10:28:26 <roconnor> I guess you can tell augustss
10:28:29 <ski> @quote genders
10:28:30 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders.
10:28:33 <ski> roconnor : that one ?
10:28:53 <roconnor> ski: nope
10:29:13 <roconnor> ``roconnor: all sorts of wonderful things could be done if we are less anal about bottoms. No pun intended.''
10:29:21 <dmwit> ?tell augustss I added definitions for "min" and "max" to the "numbers" package, because we discovered on IRC that they are not lazy enough.  I hope there's no objections... I was told it was traditional to just update the hackage package myself. =)
10:29:21 <lambdabot> Consider it noted.
10:29:53 <mauke> preflex: seen augustss
10:29:54 <preflex>  augustss was last seen on #haskell 10 days, 20 hours, 19 minutes and 25 seconds ago, saying: lpsmith: you could craft such examples, but for normal programs I would not be surprised if they shrink
10:30:17 <dmwit> It's been a while, huh?
10:30:18 <shachaf> dmwit: Why 2009.8.6?
10:30:20 <ksf> yay rain!
10:30:35 <dmwit> shachaf: 2009.8.9 is what I meant to write.
10:30:40 <dmwit> shachaf: (It's still uploading.)
10:30:46 <roconnor> 2009.8.9 is what he wrote
10:31:00 <dmwit> Phew, just finished!
10:31:07 <ski> @remember roconnor all sorts of wonderful things could be done if we are less anal about bottoms. No pun intended.
10:31:08 <lambdabot> Okay.
10:31:10 <ski> @flush
10:31:11 <lambdabot> Not enough privileges
10:31:15 <ski> heh
10:31:24 <roconnor> @flush
10:31:24 <lambdabot> Not enough privileges
10:31:26 <ksf> finally, I can take my chair, monitor and keyboard out of the fridge...
10:31:38 <hackagebot> numbers 2009.8.9 - Various number types (DanielWagner)
10:31:44 <roconnor> :D
10:31:48 <dmwit> =)
10:32:15 <TheHunter> @flush
10:32:34 * ski raises eyebrow
10:32:43 <idnar> drive-by flushing
10:32:49 <dmwit> lambdabot doesn't have very good security. =)
10:32:58 <dmwit> nick-based only
10:33:15 <ray> should clearly be public key based
10:33:16 <ski> dmwit : you're TheHunter ?
10:33:22 <dmwit> That works well when all the admins are logged on and identified (so you can't take one of their nicks).
10:33:26 <dmwit> ski: I'm not.
10:33:30 <jmcarthur> !!
10:33:37 <dmwit> ski: Nor was I just then.
10:33:59 <mike-burns> @faq Can Haskell programs be filled with security exploits?
10:33:59 <lambdabot> The answer is: Yes! Haskell can do that.
10:34:38 <dmwit> It looks like I ended a silly tradition of adding ".1" to the date-version-number, too. =P
10:34:47 <dmwit> whoops
10:34:49 * ski thought TheHunter was disappeared ..
10:35:01 <jmcarthur> so that's two things i would consider major security flaws that i learned about in the last 5-10 minutes
10:35:10 <jmcarthur> in common haskell tools
10:35:13 <dmwit> jmcarthur: yep
10:35:19 <dmwit> Go small communities!
10:35:20 <jmcarthur> :(
10:35:25 <dmwit> jmcarthur: I commission you to fix them. ;-)
10:35:28 <ksf> without security flaws we wouldn't have words like "luser".
10:35:39 <ksf> ergo: security flaws are a Good Thing.
10:36:08 <jmcarthur> i work in software security and i think it's amazing how insecure most software really is
10:36:21 <dmwit> jmcarthur: But not until somebody else uploads an update to "numbers", or else I'll be stuck as the maintainer forever after. =P
10:36:39 <jmcarthur> heh
10:37:08 <mike-burns> Sure, most software is insecure. No one exploits that because no one cares about most software.
10:37:55 <jmcarthur> true
10:37:56 <mauke> there's at least one bug in preflex
10:38:02 <mike-burns> We should leave Hackage insecure until someone exploits it; that way we'll know when Haskell has hit the big time.
10:38:07 <mauke> well, one unknown bug
10:38:09 <jmcarthur> heh
10:38:19 <ray> i think hackage accounts are manually created though
10:38:21 <mauke> I think there's also a known bug that lets you crash it from irc
10:38:28 <jmcarthur> ray: they are
10:38:33 <roconnor> dmwit: you are not listed as maintainer
10:38:36 <jmcarthur> but there really isn't any screening that i know of
10:38:41 <roconnor> dmwit: only as uploader
10:39:37 <roconnor> It should be too hard to get the sources to hackage and add a crypto layer
10:39:55 <mike-burns> Please do it.
10:40:18 <roconnor> mike-burns: but then I couldn't fix bugs in various hackage packages
10:40:19 <ray> please don't, i hate having to generate and then forgetting where i put various crypto keys
10:40:34 <mauke> oh, hmm. it just crashes a subthread
10:40:40 <roconnor> mike-burns: and ray couldn't fix his own bugs
10:40:45 <ray> :(
10:40:48 <mike-burns> Heh.
10:42:42 <mike-burns> If it used my public SSH key that'd be nice. Otherwise I have ray's complaint.
10:43:33 <badsheepy> those who choose liberty over security..wait, no.
10:43:39 <artagnon> dmwit: Wait, should I write a generalized prime factorization routine? B'cos I already know that in a triangle number is divisible by either (n && (n+1)/2) || (n/2 && n+1)
10:44:08 <artagnon> From the division, I'll get more factors.
10:45:08 <artagnon> Tobsan && idnar: In retrospect, I didn't get that. 50 is a factor of 100, and it's certainly > sqrt(100) = 10
10:46:26 <idnar> artagnon: oh, but 2 is <= 10
10:46:29 <Tobsan> artagnon: Yes, but the 2*50 = 100
10:46:37 <Tobsan> -the*
10:46:42 <idnar> artagnon: I guess I should have mentioned that, though
10:47:08 <Tobsan> artagnon: so when you find 2, you will also find 50.
10:47:29 <ksf> but 50 isn't prime.
10:47:42 <ksf> 5 is, and is also below 10.
10:47:52 <ksf> so you've got 2*2*5*5 or something.
10:48:22 <artagnon> Tobsan && idnar: Ah I see.
10:48:26 <ski> > 2*53
10:48:27 <lambdabot>   106
10:49:02 <artagnon> to get the complete series, right?
10:49:03 <artagnon> Tobsan && idnar: Then I have to add to the series 100 / <each element of the series>
10:49:04 <idnar> well, you could have 2*13 or something; 13 > sqrt(26)
10:49:17 <jmcarthur> it would be nice to at least have a way to sign packages on hackage
10:49:29 <idnar> but if you find 2, you get 13 "for free" anyway
10:49:30 <jmcarthur> wouldn't be too hard to do
10:49:35 * artagnon nods
10:49:49 <jmcarthur> (not knowing the architecture behind hackage, that is)
10:49:53 <idnar> because you can get it at the same time you test for divisibility (although I'm not sure how optimal the implementation of divMod is)
10:50:13 <artagnon> ksf: Prime factorization will drive me crazy I think
10:51:00 * artagnon uses divMod
10:51:15 <kapil> artagnon: since n and n+1 do not have common factors you need to factorise those individually.
10:51:36 <artagnon> kapil: Right.
10:51:54 <artagnon> kapil: But it makes my job twice as easy, no?
10:52:40 <ksf> primes are arcane numericology to me, too.
10:52:53 <kapil> depends on the problem! :-)
10:53:06 <idnar> is numericology similar to pharmacology?
10:54:14 <ksf> nah, it's just a term to empasize that numerics _is_ in fact numerology.
10:54:15 <sanders> how do I re-export modules ?
10:54:21 <kapil> idnar: good idea! mix different numbers in different ways to get a number with a desirably property!
10:54:30 <Botje> perhaps it's like astrology?
10:58:37 <artagnon> Revision: Ugly factorization trick -- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8039#a8044
10:59:03 <artagnon> I just have to avoid diving by the last element so that I don't get two square root elements
10:59:22 <artagnon> it looks ugly
10:59:27 <nimbler> artagnon:  Instead of running through all numbers and counting factors, why don't you start by picking N to have alot of factors, and then see if N+1 gets you the rest
10:59:32 <artagnon> there are two calls to subfactor n
11:00:00 <malosh> Hi. If I have a huge data structures with, say, 1,000,000 fields (they're booleans :-), and I want to fill it while I read a file linearly, but the fields in the file are unordered, do I have another solution than filling an array then copying it into the structure ?
11:00:24 <ksf> use Data.Map?
11:00:43 <malosh> in other words, is there a kind of "unsafely" mutable data ?
11:00:48 <artagnon> nimbler: I didn't quite get that. You want me to use the fact that a triangle number can be decomposed into n * (n+1) / 2?
11:00:52 <malosh> ksf : same performance issue, maybe even worse
11:00:58 <nimbler> artagnon: yes
11:01:04 <ksf> yes, there is' but I don't think you want to use it.
11:01:28 <artagnon> nimbler: hm. The issue then is: How do I know when I've found all the factors?
11:01:30 <jmcarthur> ugh, i didn't realize that System.Random.random doesn't return the same thing as System.Random.next for Int
11:01:37 <jmcarthur> i've been using this wrong
11:01:45 <malosh> ksf : maybe. what do you think ?
11:02:10 <artagnon> I know that n && (n+1)/2 || n/2 && (n+1) are factors
11:02:10 <artagnon> what next?
11:02:16 <artagnon> I'll have to decompose each one.
11:03:01 <nimbler> artagnon:  How would you find the smallest number with 500 divisors?
11:03:04 <ksf> adding an element to a map is something like log(size), accessing too... so you can construct a structure with O(1) access in O(n log n)
11:03:04 <kapil> artagnon: you are finding factors of all numbers instead of writing numbers with many factors.
11:03:13 <ksf> that doesn't sound too bad for me.
11:03:33 <nimbler> artagnon: Hint: You can do it on paper
11:03:49 <ksf> > log 1000000 * 1000000
11:03:50 <lambdabot>   1.3815510557964273e7
11:03:59 <ksf> hmmm
11:04:19 <kapil> if a number looks like p^a q^b r^c s^d it has (a+1)(b+1)(c+1)(d+1)-1 factors or something like that
11:04:31 <ksf> still, as you have to sort stuff to get down to O(1) access, it shouldn't be possible to get any faster.
11:04:33 <malosh> ksf : what sounds bad is that I have to write twice the code : once for parsing, and then for copying.
11:04:46 <artagnon> nimbler: product [1..500]
11:04:59 <nimbler> artagnon:  No :)
11:05:03 <benmachine> artagnon: way more than 500 divisors
11:05:09 <ksf> yep but both aren't huge amounts.
11:05:11 <artagnon> oh right :P
11:05:15 <artagnon> damn
11:05:18 * artagnon thinks
11:05:23 <benmachine> I remember thinking about this
11:05:39 <ksf> doing it in one pass won't be faster, and is going to be more involved.
11:05:56 <artagnon> damn, I must be really dumb. I'm still stuck on the first page of Project Euler :|
11:05:58 <ksf> ...at least not faster in terms of big-O, that is.
11:06:51 <Berengal> Getting past the first page is a big accomplishment, really
11:07:14 <ksf> ...or do you actually have the possibility to do O(1) writes, without searching for a position?
11:07:26 <ksf> if that's the case, MArrays are what you want.
11:08:02 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-MArray.html
11:08:15 * artagnon thinks harder
11:09:14 <nimbler> artagnon:  actually, 500 divisors is a really small number - you should just do this with dynamic programming
11:10:47 <hackagebot> HTTP 4000.0.8 - A library for client-side HTTP (SigbjornFinne)
11:11:05 <benmachine> 2**499 has 500 divisors and so does um 2**249 * 3
11:11:28 <artagnon> er, 500 unique divisors.
11:11:39 <benmachine> what is a non=unique divisor
11:11:43 <benmachine> -
11:12:10 <artagnon> [2, 2, 2] versus [2, 4, 6]
11:12:13 <ksf> one that you need more than once to get your number?
11:12:23 * artagnon nods
11:12:36 <nimbler> did I do this wrong?  Doesn't 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 have 512 divisors?
11:13:01 <benmachine> I think so
11:13:08 <opqdonut> mhmm
11:13:20 <artagnon> nimbler: Exactly the solution in my head: Do the prime factorization and keep cross-multiplying until we have 500+ unique numbers
11:13:23 <artagnon> but I can't code that.
11:13:32 <artagnon> not prime factorization... just take a list of primes
11:13:37 <nimbler> I guess that's 223 million...
11:13:40 <artagnon> and start off
11:13:48 <artagnon> shit.
11:13:53 <nimbler> What's the memory available for this?
11:14:07 <artagnon> my approach is terrible.
11:14:09 <artagnon> it's useless.
11:14:16 <artagnon> I *have* to factorize.
11:14:33 <benmachine> artagnon: which problem is this btw I haven't really been following
11:14:40 <dmwit> euler 12
11:14:41 <nimbler> 12
11:14:43 <artagnon> benmachine: euler 12
11:14:56 <artagnon> The nonsense I've written here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8039#a8044
11:14:58 <benmachine> oh I haven't done that in haskell
11:15:05 * benmachine has a look at his C solution
11:15:31 <nimbler> How much RAM do you have access to for project Euler problems?
11:15:37 <artagnon> L.O.L - The reason I'm finding it so hard is b'cos I'm forcing myself to do it in Haskell.
11:15:42 <benmachine> nimbler: the amount on your system
11:15:48 <artagnon> nimbler: As much as an "average" computer permits
11:16:14 <artagnon> nimbler: Wow! And this is supposed to be an easy problem :/
11:16:17 <ksf> if they want to see good algorithms, the data size is so immense that you won't be able to compute it before the sun burns out.
11:16:38 <badsheepy> to be fair, i gave up on that one, but i have done like 15 after that one..
11:16:47 <artagnon> !
11:16:48 <badsheepy> i presumed i was missing something really obvious
11:16:55 <artagnon> not very encouraging
11:17:10 <artagnon> :|
11:17:10 <artagnon> I'm thinking the exact same thing now
11:18:24 <Plouj> is a new edition of RWH being worked on?
11:18:36 <Vanadium> Plouj: Newer than what?
11:18:49 <byorgey_> artagnon: that's not a very efficient way to count the number of factors
11:19:03 <Vanadium> I think the print version is newer, better, stronger and faster than the web version, but I know nothing more~
11:19:22 <artagnon> byorgey_: I noticed. Any suggestions?
11:19:42 <byorgey_> artagnon: here's a hint: if you factor a number into its prime factorization, like  2^a1 * 3^a2 * 5^a3 * ..., you can compute the number of divisors just from knowing the exponents a1, a2, a3...
11:20:56 <artagnon> byorgey: Well, I've been thinking on those lines for some time now. Could you give me another hint?
11:21:22 <badsheepy> cant you just try all combinations of exponents :o
11:21:39 <nimbler> oh ya, that is a bad implementation of factors
11:22:03 <byorgey> artagnon: sure.  suppose N is divisible by 2^3.  Then what can you say about ever divisor of N?
11:22:09 <byorgey> *every divisor
11:22:11 <artagnon> byorgey: besides, I have no idea how to do the prime factorization effectively
11:22:37 <byorgey> artagnon: well, just a naive prime factorization will be much faster than iterating through every number less than N
11:22:43 <Plouj> Vanadium: newer than what's currently available.
11:22:54 <byorgey> as soon as you find a prime divisor p you can divide by p and continue finding the factorization of N/p
11:22:56 <Plouj> the current edition of RWH has a lot of glaring errors and problems.
11:23:12 <Plouj> and on my gosh, how do I even begin to understand this:
11:23:15 <Plouj> -- file: ch10/Parse.hs
11:23:15 <Plouj> getState :: Parse ParseState
11:23:15 <Plouj> getState = Parse (\s -> Right (s, s))
11:23:19 <artagnon> byorgey: That every divisor is divisible by 2 obviously. 2, 4, 8 are the factors. Number of factors = 3.
11:23:31 <Plouj> the use of currying here is super confusing
11:23:37 <byorgey> artagnon: well, 1 is also a divisor.
11:23:55 <artagnon> wait, I think I got it.
11:23:55 <artagnon> byorgey: ofcourse. Add that.
11:24:01 <byorgey> artagnon: but I meant N is *divisible* by 2^3, not that N = 2^3
11:24:02 <dmwit> byorgey: I've suggested that being able to factor the number initially into n*(n+1)/2, and being interested in the *first* one with a certain number of factors, also helps quite a lot.
11:24:07 --- mode: ChanServ set +o mauke
11:24:08 --- mode: mauke set +b *!n=plinka@*
11:24:15 <byorgey> dmwit: also true.
11:24:48 <byorgey> artagnon: what I mean is that if 2^3 is a divisor of N, then *every* divisor of N must be divisible by either 2^0, 2^1, 2^2, or 2^3.
11:24:55 <artagnon> dmwit: the problem is that I'll have to do the iteration to decompose each of n/2 and n+1
11:25:05 <byorgey> and you can pick the power of 2 independently of all the other powers.
11:25:08 --- mode: mauke set -o mauke
11:25:12 <artagnon> byorgey: ah!
11:25:17 <mauke> every number is divisible by 2^0
11:25:37 <byorgey> artagnon: so how about  N = 2^3 * 3^2 ?  how many divisors does it have?
11:26:13 <artagnon> byorgey: I get it now. 2^3 * 3^2 ~> 3*2 = 6 divisors, correct?
11:26:22 <byorgey> almost.
11:26:23 <mauke> logic says 12
11:26:23 <dmwit> artagnon: I'm not sure that's true.  The fact that they're related by succ tells you quite a lot indeed.
11:26:39 <byorgey> artagnon: remember, 2^3 gives you *four* choices:  2^0, 2^1, 2^2, or 2^3
11:26:49 <dmwit> mauke: try 11 instead
11:26:50 <hackagebot> feed 0.3.7 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds. (SigbjornFinne)
11:26:51 <byorgey> artagnon: and 3^2 gives you *three* choices: 3^0, 3^1, and 3^2
11:26:55 <artagnon> ah, then it's 4*3
11:26:59 <byorgey> exactly!
11:27:04 <artagnon> ie, each exponent + 1
11:27:05 <artagnon> product
11:27:08 <artagnon> :D
11:27:09 <byorgey> that's right.
11:27:09 <mauke> and 4*3 is 11
11:27:14 <dmwit> Ah, well, I guess it depends on whether you count the last one.
11:27:20 <dmwit> Yeah, no reason not to.
11:27:21 <nimbler> mauke:  almost!
11:27:22 <artagnon> mauke: you didn't count 1.
11:27:31 <mauke> artagnon: you forgot about dre
11:27:38 <artagnon> byorgey: Thanks for making me understand that :)
11:27:43 <dmwit> No, mauke counted it, dmwit was the idiot.
11:27:45 <artagnon> now I have to do the prime factorization itself.
11:27:45 <byorgey> dmwit: right, the usual approach is to count 1 and N as divisors of N.
11:28:10 <artagnon> First, I'll build a list of primes and find out which ones are divisors.
11:28:20 <byorgey> artagnon: right.  first get a list of prime numbers (implement it yourself or use the primes package on Hackage)
11:28:38 <artagnon> byorgey: implemented already.
11:28:38 <artagnon> then I have to divide N by each prime
11:28:48 <byorgey> artagnon: great!  then you're almost done =)
11:28:54 <artagnon> and in each case, whatever is leftover has to be recursively prime factorized again
11:28:59 <byorgey> exactly.
11:29:06 <artagnon> :)
11:29:06 <artagnon> the way I did I checked it the first time.
11:29:18 <artagnon> awesome. Let me try it then.
11:29:35 <artagnon> to write this
11:29:35 <artagnon> Just wait for some time. I suck at Haskell, so it's going to take me a while
11:29:35 <artagnon> I'll show you when I'm done.
11:29:54 <nimbler> artagnon:  You don't need to necessarily prime factorize - it sounds easier to just find the biggest power of each prime to divide your number
11:30:36 <artagnon> nimbler: and how do I do that? I can't divide by [...0]
11:30:43 <artagnon> I need some upper limit
11:30:48 <artagnon> ah
11:30:59 <byorgey> nimbler: but that's equivalent to finding the prime factorization.
11:31:04 <artagnon> the upper limit is N itself
11:31:19 <nimbler> byorgey:  pretty much, but you never actually represent the prime factorization
11:31:20 <byorgey> starting from small primes and working up is bound to be more efficient.
11:31:37 * artagnon nods
11:31:41 <nimbler> artagnon:  you can stop when the remaining factor is 1
11:31:43 <byorgey> well, sure.  but that sounds like premature optimization to me.  wouldn't make much difference.
11:32:11 <nimbler> byorgey:  it's not a speed optimization, it's a less code optimization
11:32:26 <artagnon> nimbler: got it. But I think I'm going to try implementing a full-fledged prime factorizer as byorgey suggessted, just as an exercise.
11:32:47 <byorgey> nimbler: fair enough, but I don't think it would result in much less code either. =)
11:33:15 <nimbler> byorgey: probably right - do you have in mind returning the prime factorization as a list of powers of respective primes?
11:33:24 <nimbler> byorgey:  If so, I agree :)
11:33:35 <byorgey> nimbler: sure, or even a list of (prime, power) pairs
11:33:43 <nimbler> sure ok
11:33:50 <nimbler> Either way, we're not talking about much code I suppose
11:33:59 <byorgey> right, just a few lines =)
11:34:33 <Berengal> Once you've got the prime factors, finding all divisors is just a bit of mapping, filtering and nondeterministic computation away
11:34:49 <nimbler> Another optimization would be to early out if neither N nor N+1 had half (250) divisors
11:35:19 <nimbler> but that probably won't be needed for this problem size
11:39:11 <artagnon> Ok, before you say anything: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8047
11:39:17 <artagnon> I just wrote it in one pass
11:39:37 <artagnon> I didn't even check if it compiles
11:39:42 * artagnon goes back to check
11:40:13 <artagnon> what a surprise; it doesn't :|
11:46:51 <artagnon> Slightly more sane revision: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8048
11:47:37 <Plouj> again, can someone help me understand getState from readl world haskell chapter 10?
11:50:25 <sanders> how does one deal with mutually recursive modules?
11:50:27 <ksf> the first thing to understand is that there is no state.
11:50:39 <Plouj> ksf: me?
11:50:42 <ksf> sanders, create a third one.
11:50:46 <ksf> Plouj, yes.
11:51:17 <ksf> it's all just a chain of functions  ParseState -> Either String (a, ParseState)
11:51:25 <Plouj> I'm confused by the levels of abstraction;
11:51:35 <artagnon> byorgey: Some help...?
11:51:59 <Plouj> Parse data constructor takes any value and returns a function (ParseState -> Either String (a, ParseState))
11:52:22 <Plouj> in getState Parse is passed ParseState (wtf?)
11:52:24 <byorgey> artagnon: sure, let me take a look
11:52:25 <ksf> Plouj, just read on a bit, and don't be scared, they're trying to inject monads into your head without you noticing it.
11:52:38 <artagnon> Occurs check: cannot construct the infinite type: a = [a] ... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8048
11:52:44 <ksf> the "Parse" data constructor doesn't take any value.
11:52:46 <byorgey> artagnon: well, factors 1 = 1  doesn't make sense, it is supposed to return a list =)
11:53:06 * artagnon slaps his forehead
11:53:07 <ksf> its _type_ takes any type to parametrise the right side of the either.
11:53:13 <Plouj> ksf: ah, I just realized that getSTate takes no argument
11:53:21 <byorgey> artagnon: assertPrime a = a  isn't quite right either
11:53:40 <ksf> Plouj, jeah, it's the function _inside_ the Parse taht takes it.
11:54:14 <Plouj> my mind must be rejecting Monads!
11:54:17 <artagnon> byorgey: new revision: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8050
11:54:27 <byorgey> artagnon: hm, your otherwise clause is problematic too, since factors returns a list, but then you are putting that list inside a list (with the comprehension)
11:54:44 <artagnon> byorgey: yeah, I thought so
11:54:50 <byorgey> artagnon: ok, that's better, although I would just put factors 1 = [], since strictly speaking 1 has no prime factors
11:55:01 <artagnon> byorgey: ok
11:55:27 <artagnon> but the otherwise clause produces list in list in list in list... so on and so fourth until all primes are exhausted
11:56:02 <ksf> Plouj, stufff should get clearer as soon as you reach (==>)
11:56:03 <artagnon> byorgey: Yeah, changed [1] to [] ... I don't want tons of 1s polluting my factors list
11:56:13 <byorgey> artagnon: if I were you, I would make factors take an extra argument, which is the list of prime factors to try
11:56:23 <byorgey> artagnon: then all you have to do is test whether the first prime in the list divides the number
11:56:34 <byorgey> if it does, you can divide by it and call recursively
11:56:52 <byorgey> if it doesn't, you can discard that prime and call recursively with the same number and the smaller list of primes to try
11:57:06 <artagnon> byorgey: Got it. I'll change it.
11:58:16 <Plouj> ksf: yeah, thanks. I find that if I need to be not scared to skip a head a lot while reading RWH
11:58:21 <Plouj> -if
11:58:46 <kowey> anybody have a library on Hackage that wraps around some C library? if so, do you use pkg-config?
11:59:38 <kowey> (and if so, what the heck do you do about Windows? http://sourceforge.net/mailarchive/message.php?msg_id=op.ur50y0kmg8rhh0%40shelarcywin )
11:59:58 --- mode: ChanServ set +o mauke
11:59:58 --- mode: mauke set +b *!*@201.171.93.226
12:00:10 <artagnon> byorgey: New revision: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8051 -- I've deviated from your idea though
12:00:29 <byorgey> how dare you!  ;)
12:00:30 <artagnon> it should be xs or something
12:00:30 <artagnon> er, something's wrong with [_] :p
12:00:57 <byorgey> artagnon: what are you trying to do?
12:00:58 --- mode: mauke set -o mauke
12:01:12 <byorgey> [_] is a pattern which matches a list containing exactly one element (but you don't care what the element is)
12:01:21 <byorgey> it doesn't make any sense to put [_] on the right hand side of an =
12:01:21 <artagnon> byorgey: right, sorry
12:01:31 <artagnon> I'll revise that
12:01:38 <ksf> kowey, small c libs tend to come with source, and big ones...
12:01:52 <ksf> ...well ask the gtk2hs developers, they know all the pain.
12:02:21 <ksf> otoh, newer opengl versions just seem to ship .h files.
12:03:21 <kowey> ksf: funnily enough, this question is motivated by trying to make wxHaskell easier to install :-)
12:03:43 <artagnon> byorgey: How do I represent a list containing any number of values I don't care about? [a] should do, right? then replace [_] with [a]
12:03:53 <kowey> we've got a sham Cabal file that just uses the Make build method and the shaminess of it all means that people have to sudo cabal install wxcore :-(
12:03:59 <byorgey> artagnon: no, [a] only matches a list with exactly one element
12:04:11 <byorgey> artagnon: if you don't care about the list at all, just put _
12:04:40 <ksf> compiling c under windows is and always will be problematic, just because of autoconf.
12:04:44 <artagnon> byorgey: ok, s/[_]/_/
12:04:49 <byorgey> yup
12:05:00 <byorgey> but if you need to pass the list to a recursive call then you have to give it a name
12:05:08 <ksf> seriously, /me personally couldn't care less about people having to install cygwin.
12:05:21 <byorgey> you can't just write  _  as a parameter to the recursive call
12:05:43 <kowey> hmm, so one helpful thing is that it's 'just' our C (C wrapper around wxWidgets), although perhaps a wrinkle is that it's not actually C but C++ providing a C interface to wxWidgets
12:05:49 <artagnon> oh, then I'll name it l or something
12:06:27 <ksf> we could really use a generic haskell make.
12:06:37 <ksf> ocaml has a nice one, why don't we?
12:06:44 <kowey> hmm, maybe "if you want effortless wxHaskell on Windows, use our nice binary installers, if not, go install cygwin"
12:06:56 <kowey> s/if not/if you want to build from source/
12:07:19 <ksf> people on windows that want to build from source are used to the pain.
12:07:24 <kowey> ksf: ahh if only you were at AngloHaskell
12:08:01 <roconnor> my /usr/local/lib is becoming a mess
12:08:05 <kowey> http://www.haskell.org/haskellwiki/AngloHaskell/2009 (ndm's "Make Considered Harmful")
12:08:10 <artagnon> byorgey: New revision http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8053
12:08:13 <roconnor> damn you cabal!
12:08:58 <artagnon> byorgey: My idea is simple. I'll start with an empty list and start pushing all the prime factors. Then count the number of each prime factor + 1 and take the product of that number
12:09:30 <byorgey> artagnon: so the list parameter is supposed to be the list of prime factors you have found so far?
12:09:32 <artagnon> bloody hell. I haven't defined primeFactor now
12:09:39 <artagnon> byorgey: correct.
12:10:04 <byorgey> artagnon: that isn't actually a very Haskelly way to do things. =)
12:10:24 <artagnon> It isn't? Why not btw?
12:10:32 <artagnon> I want to learn The Haskell Way. Which is why I'm struggling in the first place.
12:10:33 <byorgey> artagnon: just return the list of prime factors.  and then combine the results of any recursive calls with any additional factors to make the complete list.
12:10:47 <byorgey> no need to pass along the results so far as an additional parameter
12:11:02 <byorgey> I don't know if that made sense.  let me give an example.
12:11:08 <artagnon> byorgey: That was my original idea!
12:11:12 <artagnon> no second parameter
12:11:32 <byorgey> artagnon: what I was suggesting for the second parameter is that it is the *list of prime factors you haven't tried yet*
12:11:41 <byorgey> not the list of prime factors you've found so far
12:11:57 <artagnon> byorgey: yeah, I understood that.
12:12:02 <artagnon> but I want to try this way.
12:12:05 <artagnon> On parameter
12:12:10 <artagnon> s/On/One
12:12:16 <byorgey> ok, fine =)
12:13:06 <artagnon> Back to http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8050 then
12:13:36 <artagnon> the otherwise clause needs some thought
12:14:51 <roconnor> oh there is a cabal upgrade
12:18:06 <artagnon> byorgey: but it'll recompute primeFactors on every call no, unlike your implementation idea?
12:18:28 <artagnon> hm. That sucks. Why find a list of prime factors for each factor?
12:18:38 <artagnon> when I've found it for the original number already.
12:18:42 * artagnon sighs
12:18:53 <artagnon> and I have no idea how to complete this function
12:19:18 <byorgey> artagnon: right, you don't want to recompute the list of prime factors each time
12:19:28 <artagnon> factors needs to be applied to each member of [div a primeFactor | primeFactor <- primeFactors]
12:19:51 <byorgey> no, that would give you way too many factors!
12:20:09 * ksf instinctively read | as "forall", for the first time, and finally gets to terms with comprehensions
12:20:16 <artagnon> hm, isn't that what I'm doing?
12:20:24 <byorgey> if you are factoring 24, you don't want to factor 12 AND 8
12:20:36 <byorgey> you just want to factor 12, and then add a 2 to whatever you get
12:21:02 <artagnon> add a 2?
12:21:06 <ksf> until now, I read | as "where", which is actually more correct, but doesn't have the "looping" in it.
12:21:33 <ksf> ...it could work if you read <- as "comes from"
12:21:39 <byorgey> I mean, the call to factor 12 will give you a list, and you want to insert an extra factor of 2 in that list
12:21:48 <ksf> or, rather, "is every element of"
12:21:50 <byorgey> which finally gives you the factorization of 24
12:22:16 <artagnon> byorgey: Right, got it.
12:22:33 <artagnon> ok, let's go your way
12:22:43 <byorgey> artagnon: this is why you shouldn't actually need any list comprehension or map or anything, the recursion should take care of that
12:22:44 * artagnon refactors again
12:22:44 <artagnon> with the last parameter
12:22:47 <ksf> [ (+1) x forall x from xs ]
12:23:07 <ksf> [ x + 1 where x comes from xs ]
12:23:25 <artagnon> byorgey: ok, got it
12:23:29 <ziman> that looks almost as list comprehensions from python
12:23:41 <ksf> I prefer the former.
12:23:54 <ksf> uhm... python stole comprehensions from haskell.
12:24:07 --- mode: ChanServ set +o mauke
12:24:08 --- mode: mauke set -b *!n=plinka@*
12:24:23 <ksf> ...and haskell stole them from set theory if i'm not mistaken.
12:25:07 --- mode: mauke set -o mauke
12:25:36 <gnuvince> @seen LeCamarade
12:25:37 <lambdabot> LeCamarade has changed nick to lecamarade|away.
12:25:37 <lambdabot> lecamarade|away is in #ghc, ##freebsd, #haskell-blah and #haskell. I don't know when lecamarade|away last spoke.
12:25:40 <artagnon> byorgey: I'll try writing line-by-line this time. My first line is factors a l = filter (\x -> x `mod` (head l) == 0) l
12:25:50 <artagnon> ouch
12:25:50 <artagnon> sorry
12:25:54 * artagnon retries
12:32:26 <ManateeLazyCat> @let ifA x f g h = if arr f x then g else h
12:32:27 <lambdabot>  <local>:18:0:
12:32:27 <lambdabot>      Multiple declarations of `L.ifA'
12:32:27 <lambdabot>      Declared at: <local...
12:32:39 <ManateeLazyCat> :t ifA
12:32:40 <lambdabot> forall b t. b -> (b -> Bool) -> t -> t -> t
12:32:57 <ManateeLazyCat> Above is ifA for one argument with if and Arrow.
12:33:02 <Deewiant> ?ty let ifA x f g h = if arr f x then g else h in ifA
12:33:03 <lambdabot> forall b t. b -> (b -> Bool) -> t -> t -> t
12:33:18 <ManateeLazyCat> I want write some if function with Arrow that accept multiple argument.
12:33:37 <Deewiant> ?ty let ifA x y f g h = if arr f x y then g else h in ifA
12:33:38 <lambdabot> forall b t t1. b -> t -> (b -> t -> Bool) -> t1 -> t1 -> t1
12:33:50 <artagnon> byorgey: New revision! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8054
12:33:56 <artagnon> And it compiles this time :)
12:34:11 <artagnon> it's probably broken ofcourse :p
12:34:18 <artagnon> I just translated your English to Haskell literally
12:35:25 <hackagebot> pubsub 0.10 - A library for Google/SixApart pubsub hub interaction (SigbjornFinne)
12:35:44 <ManateeLazyCat> Example it accept (x -> Bool), (x -> y -> Bool), (x -> y -> z -> Bool)
12:37:25 <dolio> @type \f x -> arr f x
12:37:26 <lambdabot> forall b c. (b -> c) -> b -> c
12:37:39 <dolio> That 'arr' is doing nothing.
12:38:22 <gwern> @seen tehgeekmeister
12:38:23 <lambdabot> I saw tehgeekmeister leaving #haskell 7m 26d 14h 23m 57s ago, and .
12:38:52 <gwern> @ask tehgeekmeister out of curiosity is there any reason your wikimediaparser couldn't be part of sigbjorn's mediawiki package?
12:38:53 <lambdabot> Consider it noted.
12:45:31 <byorgey> artagnon: ok, getting closer
12:45:55 <byorgey> artagnon: first of all, in the second case you can pattern match on l, by writing factors a (p:ps)
12:46:00 <byorgey> then you don't have to use 'head'
12:46:16 <byorgey> artagnon: also, factors 1 l = l  isn't right
12:46:29 <byorgey> 1 doesn't have any prime factors, so factors 1 l = []
12:47:07 * ManateeLazyCat Avoid use `head` or `tail` if you can use pattern match
12:47:19 <artagnon> byorgey: ok, I'm correcting the code. One sec.
12:47:23 <RayNbow> @users
12:47:24 <lambdabot> Maximum users seen in #haskell: 658, currently: 594 (90.3%), active: 15 (2.5%)
12:48:18 <ManateeLazyCat> @hoogle Arrow a => a b (b -> Bool) -> a t t -> t
12:48:19 <lambdabot> No results found
12:48:23 <byorgey> artagnon: your code in the other cases seems a bit confused too
12:48:48 <byorgey> but getting close =)
12:49:24 <artagnon> byorgey: New revision! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8055
12:50:00 <byorgey> artagnon: better!
12:50:07 <byorgey> artagnon: that case for 1 still isn't right, though
12:50:14 <artagnon> darn
12:50:14 * artagnon smiles
12:50:14 * artagnon thinks
12:50:24 <byorgey> artagnon: you don't want to pattern match [] on the list of primes
12:50:34 <byorgey> who cares what the list of primes is if you are factoring 1?
12:50:46 <artagnon> Right
12:50:59 <artagnon> so I should be matching a _
12:51:14 <artagnon> sorry, 1 _
12:51:17 <artagnon> er
12:51:19 <byorgey> right
12:51:26 <byorgey> factors 1 _ = ?
12:51:33 <ManateeLazyCat> @hoogle a b c -> a b d -> a b d -> a b d
12:51:33 <lambdabot> No results found
12:51:51 <byorgey> oh, and I see you fixed the a `mod` x /= 0 case, good
12:51:53 <artagnon> factors 1 _ = []
12:52:02 * artagnon nods
12:52:05 <byorgey> right
12:52:08 <byorgey> almost there!
12:52:21 <byorgey> the otherwise case is ALMOST right but has a teensy problem.
12:52:49 <dolio> @type (+++)
12:52:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
12:52:55 <artagnon> hm.
12:53:00 <byorgey> artagnon: suppose you are computing factors 24 (2:...)
12:53:11 <byorgey> you note that 24 `mod` 2 == 0 so we are in the second case
12:53:20 <artagnon> ok
12:53:23 <artagnon> then 12
12:53:23 <byorgey> now you say that factors 24 (2:...) = factors 12 (2:...)
12:53:30 <dolio> @type (|||)
12:53:31 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
12:53:33 <byorgey> yes, but 24 does not have the same factors as 12 =)
12:53:50 <artagnon> 2 is an additional factor
12:53:52 <byorgey> right.
12:54:09 <byorgey> so how to include the 2?
12:54:12 <artagnon> and I'm leaving it in the list, am I not?
12:54:22 <byorgey> you're leaving it in the list of primes to try, which is correct
12:54:29 <byorgey> but that is not the same thing as the *output* list
12:54:34 * artagnon nods
12:54:42 <artagnon> hm.
12:54:51 <byorgey> factors 12 (2:...) will return a list of factors
12:54:58 <byorgey> and you want to add an extra 2 to that list
12:55:03 <artagnon> got it
12:55:11 <alip> what does the operator /= do?
12:55:15 <byorgey> alip: not equal
12:55:16 <dolio> @type \f g -> (f >>> arr Left) ||| (g >>> arr Right)
12:55:17 <lambdabot> forall (a :: * -> * -> *) b b1 b2 c. (ArrowChoice a) => a b b1 -> a c b2 -> a (Either b c) (Either b1 b2)
12:55:22 <alip> byorgey: thanks
12:55:34 <dolio> @type \f g -> f +++ g >>> arr (either id id)
12:55:35 <lambdabot> forall (cat :: * -> * -> *) b b' c'. (ArrowChoice cat) => cat b c' -> cat b' c' -> cat (Either b b') c'
12:55:36 <byorgey> alip: imagine an equals sign with a slash through it =)
12:56:08 <mauke> ≠
12:56:25 <RayNbow> <byorgey> alip: imagine an equals sign with a slash through it =) <-- it took me quite some time till this occurred to me :p
12:56:26 <mauke> ≠⃥
12:56:31 <byorgey> hehe
12:56:34 <gwern> arggh why is it so hard to figure out how to get the wikitext of a page with mediawiki
12:56:48 <gwern> sigbjorn's libraries are great but the documentation is EPIC FAIL
12:56:56 <RayNbow> the first few weeks (months?) I always forgot whether it was /= or \= :p
12:57:09 <artagnon> byorgey: New revision! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8057
12:57:10 <gwern> I don't know why he even bothers to give his types and constructors meaningful names
12:57:13 <dolio> mauke: not-not-equal?
12:57:15 <gwern> it's not like it helps
12:57:26 <jmcarthur> who?
12:57:40 <jmcarthur> oleg? :P
12:57:51 <byorgey> artagnon: ah, right idea, but not quite.  in our example, (a `div` x) would be 12, right?
12:57:56 <byorgey> you want to add 2 to the list, not 12
12:58:01 <gwern> 'MediaWiki.API.Query.AllLinks' 'data AllLinksRequest' 'Representing alllinks requests.' <-- oh, THANKS A LOT
12:58:01 <artagnon> ouch :P
12:58:04 <artagnon> sorry about that
12:58:04 <gwern> that's so helpful!
12:58:06 <artagnon> silly mistake
12:58:12 <byorgey> yep, no problem =)
12:58:17 <jmcarthur> oh
12:58:18 <gwern> jmcarthur: hm? no, oleg's docs are great
12:58:28 <gwern> as great as they can be, I suppose
12:58:38 <gwern> not as good as the xmonad docs, but who meets that high standard
12:58:40 <artagnon> byorgey: so x : ...
12:58:44 <byorgey> artagnon: exactly
12:58:44 <jmcarthur> they're okay
12:58:49 <jmcarthur> better than my documentation
12:58:55 <ksf> his library organisation is ... unconventional, though.
12:59:26 <gwern> I've edited wikipedia for something like 6 years now and I did some work on the pywikipediabot - and I still have no freaking idea what an 'alllinks' is
12:59:32 <artagnon> byorgey: Final revision? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8047#a8058
12:59:32 <byorgey> artagnon: I think that ought to do it, give it a try!
12:59:40 <artagnon> Ok, let me try
12:59:49 <artagnon> factors 100 [5,4,2]
12:59:58 --- mode: ChanServ set +o mauke
12:59:58 --- mode: mauke set -b *!*@201.171.93.226
13:00:04 <nimbler> artagnon:  That's not how you compute factors, though
13:00:13 <ManateeLazyCat> @hoogle Arrow a => a b Bool -> a b d -> a b d -> a b d
13:00:14 <lambdabot> No results found
13:00:16 <nimbler> is it?
13:00:21 <byorgey> nimbler: why not?
13:00:28 <byorgey> nimbler: what do you mean by 'factors'?
13:00:33 <artagnon> nimbler: hmm...? what's the problem?
13:00:34 <artagnon> it's cool and efficient
13:00:37 <nimbler> nm
13:00:46 <byorgey> nimbler: it's computing prime factors, not all divisors
13:00:47 <nimbler> I thought you were trying to enumerate divisors :)
13:00:53 <nimbler> sorry, I've been AFK
13:00:58 --- mode: mauke set -o mauke
13:01:04 <nimbler> ya , looks good
13:01:41 <artagnon> hm, something must be wrong: factors 100 [5,4,2] returns [5,5,4] ... where are all the other factors? :'(
13:01:52 <ManateeLazyCat> Anyone help me implement "Arrow a => a b Bool -> a b d -> a b d -> a b d" ?
13:02:00 <nimbler> 4 isn't prime
13:02:10 <artagnon> lol
13:02:10 <artagnon> no wonder
13:02:12 <byorgey> artagnon: 5*5*4 = 100, it works!
13:02:26 <dolio> ManateeLazyCat: My asking for the type of (|||) earlier was a hint.
13:02:38 <gwern> byorgey: 4 ain't prime tho
13:02:43 <byorgey> gwern: I know =)
13:03:01 <byorgey> but if it WERE, then 5*5*4 would be (a) correct prime factorization of 100
13:03:11 <artagnon> byorgey: yep! :) factors [5,2] = [5,5,2,2]
13:03:17 <byorgey> great!
13:03:31 <byorgey> artagnon: now, in order to count divisors, you may be interested in the 'group' function
13:03:36 <artagnon> =9
13:03:36 <artagnon> now THAT is fantastic. Number of factors = (2+1)(2+1)
13:03:42 <byorgey> > group [2,2,2,3,3,5,5,7,7,7,7]
13:03:43 <lambdabot>   [[2,2,2],[3,3],[5,5],[7,7,7,7]]
13:03:44 <gwern> byorgey: so if a contradiction were true, that some proposition would be true?
13:03:51 <gwern> well, that is logical, I'll admit
13:03:53 <dolio> ManateeLazyCat: Also note that "Either b b" is roughly isomorphic to "(Bool, b)".
13:03:57 <byorgey> > map length $ group [2,2,2,3,3,5,5,7,7,7,7]
13:03:58 <lambdabot>   [3,2,2,4]
13:04:04 <artagnon> excellent!
13:04:36 <artagnon> > product $ map (length+1) $ group [2,2,2,3,3,5,5,7,7,7,7]
13:04:37 <soupdragon> > let (.) = fmap in    length . group [2,2,2,3,3,5,5,7,7,7,7]
13:04:37 <lambdabot>   No instance for (GHC.Num.Num ([a] -> GHC.Types.Int))
13:04:37 <lambdabot>    arising from the li...
13:04:39 <lambdabot>   [3,2,2,4]
13:05:27 <byorgey> artagnon: length + 1 doesn't work, unfortunately =)
13:05:44 <byorgey> map ((+1) . length)
13:06:03 <byorgey> i.e. compute the length, then add 1 to the result
13:06:05 <soupdragon> liftA2 (+) length 1
13:06:06 <mauke> it's possible to make it work :-)
13:06:18 <byorgey> well, yes, but let's not go there =)
13:06:25 <artagnon> > product . map ((+1) . length) . group $ [2,2,2,3,3,5,5,7,7,7,7]
13:06:27 <lambdabot>   180
13:06:31 <mauke> map (succ . length)
13:06:31 <artagnon> sorry, my stupidity the last time
13:06:50 <artagnon> ofcourse length+1 doesn't work :p
13:07:04 <byorgey> > product [2,2,2,3,3,5,5,7,7,7,7]
13:07:05 <lambdabot>   4321800
13:07:33 <byorgey> > length . filter ((==0) . (4321800 `mod`)) $ [1..4321800]
13:07:34 <artagnon> cool
13:07:34 <artagnon> 180 factors
13:07:38 <lambdabot>   mueval-core: Prelude.read: no parse
13:07:39 <lambdabot>  mueval: ExitFailure 1
13:07:47 <byorgey> yup
13:07:59 <ManateeLazyCat> dolio: Can you help me implement it, and not just hint.
13:08:22 <ManateeLazyCat> dolio: I'm not understand Arrow completely.
13:08:23 <artagnon> byorgey: Thank you SO much for making me learn instead of giving away the solution. I learnt a LOT today :)
13:08:37 <byorgey> artagnon: you're welcome!  anytime =)
13:09:01 <ManateeLazyCat> dolio: Arrow is a bit confusion sometimes.
13:09:04 <byorgey> ok, off to pack for vacation =)
13:09:16 <dolio> ManateeLazyCat: arr lets you inject functions into the arrow type, so we can get the isomorphism in one direction in there...
13:09:25 <artagnon> byorgey: You should be a teacher. Or atleast do it part time. You're amazingly patient :)
13:09:37 <dolio> @type arr (\(b, e) -> if b then Left e else Right e)
13:09:38 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a (Bool, b) (Either b b)
13:09:51 <gwern> artagnon: I think he does
13:10:00 <byorgey> artagnon: thanks.  I used to teach high school, and hope to teach at a university once I finish my PhD.  I love teaching. =)
13:10:14 <dolio> ManateeLazyCat: Then you can compose it with the arrow choice operator on the two functions.
13:10:18 <dolio> @type \f g -> f ||| g
13:10:20 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
13:10:20 <artagnon> Wow! That's amazing :)
13:10:30 <artagnon> byorgey: PhD in what btw?
13:10:42 <gwern> hurrah. I finally found a useful function in mediawiki: webGetXml ∷  (String →  Either (String,[String]) a)^M →  URLString^M →  Request^M →  IO (Maybe a)^M
13:10:46 <byorgey> artagnon: CS, programming languages in particular
13:10:50 <dolio> @type \f g -> arr (\(b, e) -> if b then Left e else Right e) >>> f ||| g
13:10:51 <lambdabot> forall b (cat :: * -> * -> *) c. (ArrowChoice cat) => cat b c -> cat b c -> cat (Bool, b) c
13:10:52 <byorgey> somewhat surprisingly =)
13:10:55 <artagnon> :)
13:11:32 <byorgey> gwern: too bad it's infected with carriage returns.
13:11:36 <dolio> ManateeLazyCat: Then you just need to get the (Bool, e) from an a e Bool, for which you can use (&&&).
13:11:52 <dolio> @type \f -> f &&& arr id
13:11:54 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, b)
13:11:56 <artagnon> I wonder when I'll be able to write such code myself. Whipping myself with Project Euler exercises should do, no?
13:12:05 <gwern> byorgey: yes, it's quite annoying. sigbjorn must be a windows-user
13:12:06 <byorgey> artagnon: that will get you a long way, yes =)
13:12:36 <gwern> ah sod this. I'll muck with sigbjorn's library another day
13:12:50 * artagnon has whipped himself with various things, including Common Lisp (for a whole 6 months until he *got* it)
13:12:53 <Berengal> Project Euler taught me Java, Python and Haskell, plus a bunch of stuff about efficient prime generation
13:13:04 <gwern> sad thing is, it might be faster to write a simpler & better documented mediawiki library than to use sigbjorn's stuff, but I can't bring myself to do it
13:13:10 <artagnon> ok, awesome.
13:13:19 <artagnon> Berengal: Finished all 252?
13:13:30 <artagnon> I don't even understand the English in the harder ones :p
13:13:37 <Berengal> artagnon: Nope, only about 70
13:13:43 <artagnon> :|
13:13:45 <Berengal> But that includes some of the later ones as well
13:14:24 <Berengal> 204 is particularly nifty if you're still in a learning phase
13:14:32 <artagnon> One of my ex-classmates in school has finished 148
13:14:40 <ManateeLazyCat> dolio: Can you concat those steps together?
13:14:48 <artagnon> s/in/from
13:15:04 <dolio> ManateeLazyCat: What do you mean?
13:15:50 <ManateeLazyCat> dolio: You give me detail steps to implement it, can you give me final work version?
13:16:08 <ManateeLazyCat> s/to/that how to
13:16:30 <dolio> @type \p f g -> p &&& arr id >>> arr (\(b, e) -> if b then Left e else Right e) >>> f ||| g
13:16:31 <lambdabot> forall (cat :: * -> * -> *) a c. (ArrowChoice cat) => cat a Bool -> cat a c -> cat a c -> cat a c
13:18:32 <byorgey> artagnon: I've done 174 =)
13:18:45 <byorgey> I'm quite behind, there was a time at which I had done 100% of the existing problems
13:18:51 <dolio> ManateeLazyCat: Also note that you could use arrow notation for this, I think.
13:18:55 <byorgey> but then they kept adding more faster than I can do them =(
13:19:34 <dolio> @type \p f g -> proc x -> do b <- p -< x ; if b then f -< x else g -< x
13:19:35 <lambdabot> parse error on input `->'
13:20:57 <Berengal> To be honest, there comes a point in PE where the CS involved is gone and only number theory is left
13:21:06 <dolio> ManateeLazyCat: lambdabot doesn't have it enabled, but what I typed works if you have -XArrows enabled.
13:21:23 <ManateeL`> dolio: Ok, i try, thanks a lot! :)
13:23:40 <ManateeL`> dolio: Works, thanks! :)
13:23:47 <dolio> You're welcome.
13:24:05 <artagnon> byorgey: Oh, awesome! :)
13:24:25 <artagnon> byorgey: You should be able to solve 200+ I guess
13:24:58 <artagnon> Berengal: True. Some problems can be frustratingly difficult
13:25:16 <shapr> @yow !
13:25:16 <lambdabot> Let's all show human CONCERN for REVERAND MOON's legal difficulties!!
13:27:37 <shapr> @quote
13:27:38 <lambdabot> l33t_h4x0r says: maybe if uve had some professor teach u bullshit in uni yea \n i learned on my own.. k.. i dun give a shit bout terms :p i just code
13:28:15 <badsheepy> lol:p
13:28:30 <shapr> @quote l33t
13:28:30 <lambdabot> liyang says: My coffee machine isn't l33t enough. I'm planning to make it l33t.
13:28:36 <shapr> @quote h4x0r
13:28:36 <lambdabot> ValarQ says: l33t_h4x0r: could you help me port GHC to the AVR architecture? <-- l33t_h4x0r has left #haskell
13:28:44 <shapr> That's the second part of the quote.
13:28:44 <badsheepy> one of the best things this channel ever did for me was make me scroll through the quotes from the bot :)
13:29:25 <shapr> There's a lot of cute stuff in the quotes db.
13:30:39 <aconbere> I'm reading an article on Moniods and finger trees http://apfelmus.nfshost.com/monoid-fingertree.html
13:30:44 <aconbere> and I'm confused by a part of it
13:30:59 <aconbere> he creates a class like this
13:31:00 <aconbere> class Monoid v => Measured a v where measure :: a -> v
13:31:18 <aconbere> and I'm not entirely sure what's going on there
13:31:23 <aconbere> (and GHC complains about it)
13:31:38 <Deewiant> {-# LANGUAGE MultiParamTypeClasses #-}
13:34:23 <aconbere> Deewiant: so is that just like a type annotation on a function
13:34:35 <aconbere> where v is being set to the type class Monoid?
13:34:56 <aconbere> so Measured is a new class that takes type a and Monoid?
13:35:04 <Deewiant> You might want to read some kind of type class tutorial
13:35:13 <Deewiant> I'm too tired to explain it right now, sorry :-P
13:35:33 <aconbere> Deewiant: no problem I've got the Type class tutorial open already
13:35:43 <aconbere> it just wasn't providing a particularly direct answer :)
13:35:51 <aconbere> I'll read through it
13:36:10 <Berengal> aconbere, it's a class of two types, one of which is a Monoid, and it contains a single method, taking the non-monoid type to the monoid type
13:36:52 <Berengal> aconbere, An instance might look something like 'instance Measured Integer String where measure x = show x'
13:37:02 <Berengal> (How much that instance makes sense I don't know)
13:37:43 <Berengal> Actually, I'm not sure you could put String there without some more extensions... but the point should be clear
13:38:29 <aconbere> hmmm I'm think the part that more confusing to me is the bit about a class of two types. But really I've just recently started reading into the class / instance system in haskell so maybe I just need to understand that better.
13:39:12 <Berengal> Multiparameter type classes aren't standard. You'll probably have to look them up in their own tutorial
13:39:32 * aconbere nods
13:48:59 <seanmcl> Could someone help me make sense of this?  I'm trying to use Data.Generics with
13:48:59 <seanmcl> a Data.Set.  I kept getting errors, so I looked at the source.  Does this mean there
13:48:59 <seanmcl> is no way to use Sets with, e.g., quotations?
13:48:59 <seanmcl>  
13:49:02 <seanmcl> -- This instance preserves data abstraction at the cost of inefficiency.
13:49:06 <seanmcl> -- We omit reflection services for the sake of data abstraction.
13:49:09 <seanmcl>  
13:49:12 <seanmcl> instance (Data a, Ord a) => Data (Set a) where
13:49:16 <seanmcl>   ...
13:49:19 <seanmcl>   toConstr _     = error "toConstr"
13:49:22 <seanmcl>   gunfold _ _    = error "gunfold"
13:49:25 <seanmcl>   ...
13:49:28 <seanmcl>  
13:50:30 <Saizan> what's quotations?
13:51:34 <seanmcl> Template Haskell quotations
13:52:15 <seanmcl> Language.Haskell.TH.Quote
13:52:19 <webnox> hello
13:52:36 <Saizan> template haskell isn't directly connected with Data.Generics
13:52:49 <Berengal> If you had to select three skills any programmer should have, what would they be?
13:53:11 <seanmcl> right, but it depends on Data.Generics instances
13:53:25 <Saizan> for what?
13:53:46 <Saizan> ah, i see
13:53:50 <mike-burns> Berengal: Understanding what I say, the ability to get text into a computer, and the ability to write a computer program ?
13:54:33 <Saizan> seanmcl: those are mostly convenience functions, you can avoid them
13:54:33 <benmachine> Berengal: kicking ass, taking names, and making games
13:54:58 <dmwit> ...and were all out of ass and names?
13:55:06 <benmachine> heh
13:55:27 <seanmcl> saizan: thanks, I didn't think about expanding it out by hand.
13:55:38 <webnox> How does Haskell compare to Scala? Like, what are the reasons that should lead a programmer to favor Haskell over Scala?
13:56:11 <dons> so: parallelism, maturity, more sophisticated type system, cleaner language
13:56:11 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
13:56:20 <Berengal> I'm reading some Dijkstra now and he says 1) separation of concerns and effective use of abstraction 2) the design and use of notations, tailored to one's manipulative needs 3) avoiding case analyses, in particular combinatorially exploding ones.
13:56:37 <dons> webnox: dibblego is very comfortable in both languages. he might be able to give an overview
13:57:19 <dons> oh, haskell emphasies persitant data structures and purity, which is far less clear in scala (as is typical in hybrid languages on .NET/JVM, the compromises show)
13:57:49 <mike-burns> Berengal: Those are another set of three good skills. We could probably construct an infinite set of triples of programmer skills if we spent all day on it.
13:58:51 <webnox> dons: would you say that this purity makes learning Haskell harder? I'm not a PhD student, just a real world programmer.
13:58:54 <Berengal> mike-burns, well, getting text into a computer isn't exactly something I consider important for a programmer. It takes about a day to learn
13:59:12 <dons> webnox: hmm. it makes things simpler. no need to worry about effects and mutating memory introducing bugs.
13:59:23 <mike-burns> Berengal: It's easy, but I ain't hiring them unless they can do it.
13:59:34 <dons> webnox: its just a programming language. we have thousands of users, thousands of libs and apps. i wouldn't worry too much.
14:00:15 <gwern> webnox: my personal experience with purity is that it makes the very simple stuff much easier to understand, the simple/medium stuff not so easy to understand, and the large complex stuff easier to understand
14:00:24 <gwern> this is from the beginner's perspective; I
14:00:33 <Berengal> mike-burns, not even if they turned out to be the most productive and skilled programmers given that day of training?
14:00:35 <gwern> 'm not really sure why there's an uncomfortable middle for purity
14:00:58 <webnox> dons: I like the built-in referential transparency. I need a language to tackle hard, complex problems and mutability gets in the way of hard to trace bugs.
14:01:04 <mike-burns> Berengal: Not sure how to measure that really.
14:01:27 <webnox> gwern: that's an interesting point, duly noted.
14:02:47 <webnox> one criticism I often hear is that Haskell is an academic language, is this slowly changing?
14:02:56 <mike-burns> webnox: This is rapidly changing.
14:03:08 <gwern> it is slowly rapidly changing
14:03:12 <mauke> how is that a criticism?
14:03:13 <Berengal> mike-burns, take a skilled programmer and give him a stroke. Does his lack of finger-control remove his usefulness? How does he compare to someone who knows how to use a keyboard but doesn't know anything about programming?
14:03:26 <Gracenotes> well, regardless of how others use it, I at least use Haskell for non-academic things all the time
14:03:31 <gwern> mauke: academia = impractical & bad
14:03:48 <gwern> since if it were practical, it'd be commercial and Big Business
14:03:51 <Gracenotes> (and, yes, some academic things, often to complement my school studies.. except I'm not in school atm...)
14:03:57 <gwern> the invisible hand guarantees it!
14:03:57 <mauke> don't make me charge my lazer
14:03:59 <Berengal> @quote ivory.tower
14:04:00 <lambdabot> monochrom says: The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
14:04:01 <mike-burns> Berengal: I know a programmer who "types" via voice. He's faster than I am. He can get the text into the computer, and therefore I had no problem working with him.
14:04:02 <SamB_XP> gwern: hehehe
14:04:19 <SamB_XP> gwern: but the wheels of big business turn slowly
14:04:24 <gwern> lies!
14:04:31 <gwern> big business is perfect!
14:04:41 <SamB_XP> mostly because big business is massive
14:04:45 <dons> it was a language designed by programming language designers, that has since been transitioned into a general purpose (advanced) programming language, with a large open source, and growing industrial, user base
14:04:46 <SamB_XP> and therefore has high inertia
14:04:49 <mike-burns> The issue with "academia", whatever that is, is that it leads to unmaintained libraries once the PhD is completed.
14:04:59 <Gracenotes> gwern: we must organize a bailout for academia
14:05:05 <SamB_XP> mike-burns: agreed
14:05:07 <dons> yes, it is key that research work is transitioned into usable systems
14:05:16 <gwern> Gracenotes: not a bad idea. grad students are cheap
14:05:27 <SamB_XP> mike-burns: that is an issue
14:05:38 <SamB_XP> though it is not a hard-and-fast rule
14:06:01 <webnox> dons: I also heard that support for editors/ides is very poor. Is that true any longer?
14:06:04 <dons> webnox: interesting. galois (where I work) uses haskell almost exclusively, for the ability to design solutions to hard problems
14:06:14 <gwern> if only some eccentric billionaire would chuck us a few million to set up a rolling summer of code to hire grad students to transition acamdeic work -> usable systems
14:06:28 <mike-burns> webnox: vim and emacs have great Haskell support. There's also leksah, an IDE for Haskell written in Haskell.
14:06:28 <dons> no, not really. there are IDEs emerging (leksah and EclipseFP), both active. vim and emacs have extensive support
14:06:35 <gwern> webnox: well, leksah is a relatively new haskell ide, which I hear is very nice
14:06:47 <dons> EclipseFP is a google summer project this year
14:06:50 <Berengal> webnox, It's poor compared to java. It's not poor in that I don't feel like it hampers me the least
14:06:58 <webnox> dons: I was going to tell you that my dream is to create a "reasearch" company that solves hard problems with a language that can be a competitive advantage. I was going to give you the example of Galois as the company I'd like to create one day.
14:07:09 <Berengal> leksah is pretty awesome
14:07:23 <SamB_XP> webframp: hint. it's too late!
14:07:30 <SamB_XP> er.
14:07:32 <SamB_XP> webnox:
14:07:38 <Gracenotes> gwern: or not so much proactively making usable systems, but having a better system to cull research from the cacophonous masses when it is required for usability in a given system
14:07:39 <SamB_XP> damn this channel and all it's members!
14:07:46 <dons> webnox: its our business model
14:08:07 <michaelfeathers> dons: I think I saw a presentation from Galois on the web where someone (maybe you) said in the slides that they roll new monads all the time.  As a newb, I wonder how that squares with preferring pure code in a more functional style.
14:08:10 <webnox> Berengal: can leksah run simple "scripts"?
14:08:38 <gwern> Gracenotes: no, I think the community has a good enough idea of what's useful that we just need manpower
14:08:43 <Berengal> webnox, What exactly do you mean by "scripts"? And no, it can't
14:08:43 <gwern> michaelfeathers: monads are pure!
14:08:47 <Eelis> can anybody tell me why      subRegex (mkRegex "\x3") "\8707" ""    evaluates to   "" ? how on earth does "\8707" match "\x3" ?
14:09:20 <dons> michaelfeathers: they're not necessarily for doing IO
14:09:21 <gwern> Berengal: maybe he means editor macros
14:09:21 <Gracenotes> like snowflakes, no one could ever stain
14:09:33 <michaelfeathers> gwern: yes, but you can hide state.. and end up with something which looks like good old imperative code.
14:09:35 <dons> the monadic abstraction is for encapsulating a computational environment
14:09:42 <BMeph> If you --reinstall a package, is there another option to add if you want to also reinstall all of its dependencies?
14:09:47 <dons> which we do all the time, to hide unneccessary detail
14:09:56 <Gracenotes> gwern: oh, an interesting assertion.......
14:10:25 <Berengal> I don't think leksah can do macros yet... To be honest, I tend to stick with yi
14:10:35 <gwern> BMeph: there's an open bug report for that, iirc, filed by darcs
14:10:38 <dufflebunk> Are there any guidelines on when you should make something an instance of MonadIO?
14:10:40 <jmcarthur> michaelfeathers: monads are not any different from any other type classes :)
14:10:45 <gwern> BMeph: turns out that's useful for buildbots or something
14:10:57 <gwern> Berengal: well, yi can't do macros either
14:11:02 <mauke> > 8707 `mod` 256
14:11:03 <lambdabot>   3
14:11:15 <mike-burns> Ha. Nice.
14:11:17 <mauke> Eelis: do not trust any regex library that's not built into the language
14:11:20 <jmcarthur> dufflebunk: do it if a) the monad can perform IO, and b) you want to expose the layer so that client code can perform arbitrary IO
14:11:21 <Gracenotes> dufflebunk: generally if it uses the IO monad in some way.
14:11:32 <Berengal> gwern, no, but i can make my own commands. Yesterday I made the :browse command available, with syntax highlighting and angelic music
14:11:32 <michaelfeathers> dons: yes, but IO, State, Reader.. the ones I know about seem to move away from FP a bit.. borrowing things which feel a little less functional.
14:11:36 <Gracenotes> monad transformer stacks that have IO somewhere at the bottom
14:11:41 <michaelfeathers> dons: pardon my ignorance, btw.
14:11:43 <Eelis> mauke: so this is an instance of Char's being silently truncated?
14:11:53 <mauke> Eelis: I think so
14:11:57 <jmcarthur> dufflebunk: if you want to the IO to be limited, don't implement MonadIO
14:12:06 <Eelis> mauke: so, should change to a different regex library?
14:12:16 <Eelis> *i
14:12:17 <Peaker> michaelfeathers: They provide ways to "escape" the functional paradigm into imperative ones. But its not the only thing they do
14:12:25 <Gracenotes> yes, often instead of MonadIO, you can just provide functions for the IO actions you want to specifically implement
14:12:36 <mauke> Eelis: I don't know if there are any good regex libraries for haskell
14:12:39 <Berengal> michaelfeathers, How is Reader imperative? It's the function monad!
14:12:41 <jmcarthur> michaelfeathers: the Reader monad is just (r -> a). a function is definitely functional! ;)
14:12:42 <Eelis> mauke: i see. ok, thank you
14:12:52 <jmcarthur> michaelfeathers: the other monads follow in the same way, though
14:13:13 <michaelfeathers> Peaker
14:13:16 <michaelfeathers> Peaker
14:13:19 <webnox> so in Leksah I created hello.hs, now how do I run it?
14:13:20 <Peaker> michaelfeathers: ?
14:13:20 <michaelfeathers> ack
14:13:37 <michaelfeathers> Peaker: thanks.. I guess I have to look for examples of more esoteric monads.
14:13:40 <jmcarthur> michaelfeathers: imperative programming is a subset of functional programming :P
14:13:47 <dons> pcre-light is a fine regex lib, imo.
14:13:48 <Peaker> michaelfeathers: The list monad, for example
14:14:05 <dufflebunk> jmcarthur: so a monad that is used for a module that does a lot of DB-like IO actions would be a good candidate for MonadIO
14:14:08 <Berengal> webnox, leksah is based around packages (sort of like projects in other IDEs, except these are genuine cabal packages). Have you made one of those?
14:14:37 <webnox> Berengal: no, how do I do that?
14:14:38 <Berengal> webnox, If you have, just configure, build and run (the buttons should be in the taskbar)
14:15:02 <michaelfeathers> Peaker: yes, List and Maybe.  They do seem to fall out of the "lets do imperative in FP" thing.
14:15:12 <webnox> Berengal: Is there a tutorial?
14:15:12 <Gracenotes> dufflebunk: if you expect the user to do things interspersed with DB actions, probably...
14:15:24 <Gracenotes> like, open files, write to the screen, etc.
14:15:25 <Berengal> webnox, leksah has a user manual somewhere...
14:15:33 <roconnor> ``Vectors also have a dot product:'' NOOOOOOOOOOOOOOOOO!!! ('splode)
14:15:34 <roconnor> :P
14:15:42 <dufflebunk> Gracenotes: I expect they would, get data, output it, get input from the user, etc...
14:15:42 <webnox> Berengal: searching for it
14:15:43 <mauke> dons: does it support unicode? and '\0' in target strings? what about '\0' in regexes?
14:15:53 <Berengal> webnox, http://www.leksah.org/leksah_manual.pdf
14:16:11 <dons> mauke: whatever pcre supports. pcre.h supports unicode
14:16:17 <dons> so if your bytestring is in that form
14:16:25 <mauke> bytestring?
14:16:29 <dons> \0 in regexes is fine, iirc
14:16:29 <mauke> I want real strings
14:16:41 <dons> convert a Data.Text to a bytestring
14:16:56 <dons> then you'll have a unicode-ready regex lib for Data.Text
14:17:00 <Gracenotes> dufflebunk: although even if the monad allows arbitrary IO, it should cleanly encapsulate the DB access. The specific environmental details are kept within the monad.
14:17:12 <Gracenotes> Cale has a nice article on that... er...
14:17:21 <mauke> too complicated
14:17:38 <dons> i'm suggesting you turn that into a library
14:17:51 <BMeph> gwern: Thanks for the heads-up. It encourages me to think that I'm learning things. :)
14:18:04 <Gracenotes> dufflebunk: http://cale.yi.org/index.php/How_To_Use_Monad_Transformers about conventions in layering them, which is usually where MonadIO gets involved
14:18:35 <mauke> looking at the C API it seems embedded '\0's are not supported
14:18:43 <dons> i don't think that's right.
14:19:22 <mauke> pcre *pcre_compile(const char *pattern, int options, const char **errptr, int *erroffset, const unsigned char *tableptr);
14:19:26 <dons> c_pcre_exec "subject not required to be null terminated."
14:19:32 <mauke> I mean the pattern
14:19:37 <Eelis> mauke: should i file a bug report for Text.Regex, by the way? would it even be considered a bug?
14:19:40 <dons> "The pattern is a C string terminated by a binary zero"
14:19:42 <dufflebunk> Gracenotes: Thanks. I guess I probably have to figure out monad transformers soon.
14:19:48 <mauke> Eelis: I don't know
14:19:54 <mike-burns> Eelis: In the least it's a documentation bug.
14:20:44 <Eelis> mike-burns: yeah, there should be a huge banner saying "WARNING, Text.Regex WILL FUCK UP YOUR UNICODE" in the documentation
14:21:15 <Gracenotes> dufflebunk: yeah, although to actually use MonadIO, you just have to do something like result <- liftIO (getLine), though, not too complicated :)
14:21:19 <Berengal> String fucks up your unicode :(
14:21:35 <Saizan> regex-tdfa is pure haskell, so it probably doesn't have these problems?
14:21:44 <Eelis> Berengal: i don't see how you can blame String here
14:22:01 <Saizan> Berengal: functions that interpret String incorrectly do
14:22:08 <mauke> Saizan: I wouldn't bet on it
14:22:11 <dufflebunk> Gracenotes: yeah, but since it's a read only sort of DB, I think there's an existing monad that I could use, but I've avoided it because I haven't figured out monad transformers yet
14:22:19 <dons> doesn't it depend on the backend you're using.
14:22:51 <mauke> right now I wouldn't trust anything but perl with unicode regexes, unless extensive tests have been done first
14:23:20 <Berengal> Right now I wouldn't trust anything with unicode. I've spent the last week fighting various character encodings
14:23:24 <dons> i use unicode tests from perl in the pcre-light testsuite
14:23:59 <dons> http://code.haskell.org/~dons/code/pcre-light/tests/Unit.hs
14:24:12 <dons> note overloaded strings for regexen :)
14:25:33 <shapr> So my current script is: cabal update && cabal list|grep -e '^\*'|cut -d '*' -f 2 > /tmp/cabs && for x in `cat /tmp/cabs`; do cabal install $x > /tmp/$x.cabal.log; done;
14:25:34 <dons> i'd love someone to bind to Data.Text
14:25:48 <mauke> meh, only one regex with \p
14:25:56 <mauke> where are the unicode tests?
14:26:44 <benmachine> shapr: wouldn't &> be a good idea?
14:26:50 <shapr> er, yes actually
14:26:53 <shapr> Thanks :-)
14:28:24 <Berengal> shapr, I just now noticed there's something the .cabal/config file called "remote-build-reporting"
14:28:26 <shapr> And now to wander off for six or seven hours while that runs.
14:28:29 <shapr> oh really??
14:28:37 <shapr> I wish cabal could take advantage of all eight cores on this blade :-)
14:28:44 <Berengal> Yeah, I was just going through it now for some unrelated reason
14:28:51 <Berengal> I have no idea what it's for
14:28:56 <shapr> Berengal: I'll check that out later, after the cow party.
14:29:06 <shapr> Berengal: Thanks!
14:29:29 <timmcd> Hello!
14:29:33 <Berengal> shapr, I'm as surprised and intrigued as you are
14:29:33 <shapr> GREETINGS!
14:29:58 * shapr boings off maniacally
14:30:22 <SamB_XP> Berengal: I think it's for sending your build failure/success logs to a hackage server ...
14:32:59 <Saizan> right, the new hackage-server accepts them, though it needs hackers to make it "production-ready"
14:33:20 <Berengal> Saizan, What does that mean?
14:33:58 <Saizan> that being?
14:34:26 <Berengal> Saizan, 'it needs hackers to make it "production-ready"'
14:35:06 <Saizan> that there's a TODO list of missing features before it'll substitute the current implementation :)
14:35:26 <Saizan> code.haskell.org/hackage-server
14:35:26 * Berengal goes looking for such a list
14:38:58 <hackagebot> pubsub 0.11 - A library for Google/SixApart pubsub hub interaction (SigbjornFinne)
14:39:21 <defun> Hi. I am wondering: for every distinct haskell-program I execute on my machine, it there a distinct GHC runtime assigned/attached to the program, or is only one runtime utilized to manage multiple running apps?
14:39:50 <SamB_XP> defun: one runtime per process
14:40:25 <SamB_XP> ... just like you get one libc instance per process!
14:40:45 <ray> the code segment's probably shared though
14:41:08 <SamB_XP> ray: if the RTS is linked dynamically, sure
14:41:24 <SamB_XP> but that hasn't been well supported in the past, which is where I currently am
14:41:35 <ray> haskell platform is great
14:41:43 <SamB_XP> by which I mean, hasn't been supported at all
14:41:58 <ray> libc is certainly linked dynamically
14:42:01 <Berengal> Isn't that functionality coming in 6.12?
14:42:12 <ray> maybe not in rms-approved systems
14:42:25 <SamB_XP> Berengal: could be!
14:42:37 <SamB_XP> being in the past, I wouldn't know!
14:42:59 <timmcd> Woot, I'm learning about types fo-real now! (http://learnyouahaskell.com/types-and-typeclasses)
14:42:59 <timmcd> I was having tons of fun with list comprehensions and learning about currying to get very far in the document. :)
14:43:09 <Berengal> SamB_XP, You should come to the future. We have flying cars :)
14:43:24 <timmcd> SamB_XP, You should come to the future, It's like the past, but today!
14:43:36 <SamB_XP> timmcd: your story is more believable!
14:43:53 <timmcd> ;)
14:44:03 <timmcd> SamB_XP: Doesn't make it true. *snicker(
14:44:07 <timmcd> *snicker*, even.
14:44:12 <Berengal> SamB_XP, http://en.wikipedia.org/wiki/Flying_car_(aircraft)
14:45:31 <benmachine> http://www.topatoco.com/graphics/00000001/won-futurism-big.gif
14:49:27 <defun> Hey, has anybody tried to make GHC bootable? As in to run stand-alone without any underlying OS present? Is this even possible?
14:50:13 <SamB_XP> defun: been done, yes
14:50:20 <SamB_XP> House, I believe they call it
14:50:34 <SamB_XP> well, that's just the RTS, though, I believe ...
14:51:29 <defun> SamB_XP: Cool. So no compiler, just RTS?
14:52:02 <SamB_XP> well, okay, I've heard of other bare metal ports...
14:52:19 <SamB_XP> dons might know something?
14:52:48 <defun> SamB_XP: dons? The RWH guy?
14:53:08 <SamB_XP> yeah, he works at Galois
14:53:33 <SamB_XP> he hasn't been "the RHS guy" forever, either ...
14:53:44 <SamB_XP> er.
14:53:47 <SamB_XP> RWHs?
14:53:47 <ray> there's 3 RWH guys
14:53:56 <SamB_XP> that's also true
14:54:22 <SamB_XP> strangely, one of them also wrote a book about mercurial
14:54:32 <SamB_XP> ... he might be a little crazy?
14:54:42 <mike-burns> Hah.
14:54:46 <defun> SamB_XP: I found some links and looking into house. Thanks.
14:57:31 <Berengal> Dijkstra is probably the most highly regarded troll of all times: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html
14:58:24 <master_of_master> A
14:59:08 <soupdragon> B
14:59:21 <Berengal> > succ 'C'
14:59:22 <lambdabot>   'D'
14:59:54 <mike-burns> > ['E'..]
14:59:55 <lambdabot>   "EFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\13...
15:00:23 <Berengal> Fail for repeating a letter...
15:00:35 <ray> ['\NUL'..]
15:00:39 <ray> > ['\NUL'..]
15:00:41 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
15:00:44 <Berengal> (tail ['E' ..]) would work
15:05:12 <galdor> hi, I got some problem with parsec
15:05:19 <galdor> parse ((many (space >> letter)) >> string "\r\n") "" " a b c\r\n"
15:05:32 <galdor> why does this one doesn't works ?
15:05:41 <galdor> > parse ((many (space >> letter)) >> string "\r\n") "" " a b c\r\n"
15:05:43 <lambdabot>   Not in scope: `parse'Not in scope: `letter'Not in scope: `string'
15:06:16 <Saizan> you get a parse failure?
15:06:36 <galdor> I get exactly:
15:06:37 <galdor> Left (line 1, column 8):
15:06:37 <galdor> unexpected "\n"
15:06:37 <galdor> expecting letter
15:06:49 <Saizan> oh
15:06:55 <Saizan> space probably matches \r
15:06:56 <galdor> since letter isn't supposed to match \r, I can't see why it doesn't work
15:07:12 <galdor> you mean like isspace() in C ?
15:07:18 <galdor> that'd be infortunate
15:07:28 <Saizan> you can use char ' '
15:07:54 <galdor> you're right, works now
15:07:56 <galdor> thank you!
15:08:02 <Saizan> np :)
15:08:08 <galdor> space  :: CharParser st Char
15:08:09 <galdor> Parses a white space character (any character in " \v\f\t\r\n"). Returns the parsed character.
15:08:23 <galdor> totally my fault, I should have read the doc
15:10:45 <nimbler> What are \v and \f?
15:10:53 <Berengal> \v is a vertical tab
15:11:00 <nimbler> ah
15:11:42 <galdor> \f is form feed
15:11:48 <galdor> http://book.realworldhaskell.org/read/characters-strings-and-escaping-rules.html
15:12:01 <skorpan> does vertical tab have any use today?
15:12:43 <Berengal> skorpan, It's a newline in some terminals, line-noise in others. Pretty much useless as far as I can gather
15:14:46 <dafra> hi, -XDisambiguateRecordFields doesn't work for me : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8062
15:14:51 <dafra> what's wrong ?
15:18:37 <skorpan> dafra: possibly worth reading: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
15:19:15 <skorpan> still don't see what's wrong, but ... :P
15:20:22 <dafra> skorpan: I have checked the doc twice, this seems correct
15:20:59 <Berengal> Beat it with a stick until it submits
15:21:05 <dafra> the example of the doc has 2 records in 2 separatre modules, maybe that matters ??
15:21:18 <skorpan> yeah, that's possibly it...
15:21:26 <Saizan> yes, it does matter
15:21:36 <skorpan> maybe that's because in "S", x is really "M.x"
15:21:46 <skorpan> and in T, x is really "Foo.x"
15:21:58 <skorpan> i don't know, just guessing here
15:23:01 <dafra> Haskell records are sooo weak :(
15:23:43 <skorpan> they sure suck sometimes
15:24:15 <skorpan> but i suppose it's no stranger than not being able to define two functions with the same name
15:25:40 <dafra> skorpan: bye
15:25:51 <skorpan> godspeed
15:32:00 <maxote> hello guys, what's the major improvement of 6.12.x against 6.10.x ?
15:32:36 <Saizan> 6.12 isn't out yet, i believe?
15:32:55 <maxote> 6.12 is in current as snapshot
15:33:44 <dons> maxote: parallelism performnce
15:33:54 <BMeph> maxote: Have you read http://hackage.haskell.org/trac/ghc/wiki/Status/May09 already? :)
15:34:06 <maxote> BMeph, i will read it now
15:34:44 <BMeph> maxote: IANAGD, I just figured it may answer some basic ideas. :)
15:36:23 <maxote> lol, i can take advantage of it for my genetic algorithms, a kind of local optimization :)
15:36:50 <cheddar> is there a way to define and use constants on the left side of pattern matching? what i mean is, supposed I have a constants for different message types, like tickmsg = 3, and I want to write a function e.g.  processmsg tickmsg = do etc.
15:37:04 <mauke> processmsg x | x == tickmsg
15:37:05 <cheddar> where tickmsg represents 3, not a parameter
15:37:36 <cheddar> thanks
15:38:03 <cheddar> it's more typing, but i guess it's reasonably elegant
15:39:15 <Saizan> you could use an enumeration type like data Message = Tick | .. and convert from numbers to those constructors
15:44:41 <Plouj> what are Chunk and Empty in:
15:44:42 <Plouj> L8.uncons (L8.pack "foo")
15:44:42 <Plouj> Just ('f',Chunk "oo" Empty)
15:45:00 <koeien> internally defined by ByteString
15:45:34 <Plouj> I can't seem to :i them with ByteString module loaded
15:45:40 <koeien> (another ByteString)
15:45:52 <Igloo> They aren't exported by the official interface
15:46:02 <Plouj> oh
15:46:20 <Plouj> but I can still seem them throw the show function like this?
15:46:27 <koeien> ya
15:46:31 <Plouj> I see
16:07:04 <chaosape> howdy! i was wondering if someone could tell me if what i am trying to do is possible?
16:07:32 <Saizan> only if you tell us what you're trying to do
16:07:37 <dobblego> @faq Can haskell do what chaosape wants to do?
16:07:37 <lambdabot> The answer is: Yes! Haskell can do that.
16:07:57 <chaosape> you have to geuss ;^) ... i will paste it to hpaste ... yes?
16:08:03 <mauke> http://dagobah.biz/flash/V_Moot.swf
16:10:07 <chaosape> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=8064
16:10:50 <chaosape> i am trying to figure out a way in that code to make case3 result in a response of true without causing infinite recusion.
16:11:04 <chaosape> i am new to haskell so maybe that is not possible ... although i suspect it is
16:11:14 <skorpan> oh snap...
16:12:16 <Saizan> ?type randomRIOs
16:12:17 <lambdabot> Not in scope: `randomRIOs'
16:12:20 <Saizan> ?type randomRs
16:12:22 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
16:13:03 <Saizan> chaosape: to do that one way it to use unsafeInterleaveIO on the constantmonadcomprehension recursive call
16:13:42 <Saizan> chaosape: however you get the same effect with "do g <- newStdGen; return (randoms g)"
16:14:02 <Saizan> and wihtout going through unsafe* primitives
16:15:14 <Saizan> chaosape: also, you've the terminology a bit wrong, what you call monad is not a monad, it's a "monadic value" or "monadic action" or simply "action", the monad is IO, the type constructor
16:15:30 <chaosape> Saizon : ACK!
16:16:50 <Saizan> ?type randoms -- checking if i got the name right
16:16:51 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
16:17:16 <chaosape> @saizon this is an experiment for a different IO ( x ) type ... is there a general scheme for doing something like this on IO ( x ) types? BTW thanks for correcting my terminology
16:17:16 <lambdabot> Unknown command, try @list
16:17:18 <kpreid> fmap randoms newStdGen -- :)
16:17:28 <ray> =o
16:17:41 <kpreid> chaosape: pet peeve: don't use @, that's a convention Twitter invented. say "saizan: "
16:17:52 <kpreid> or "saizan, " if you like
16:18:11 <Saizan> especially because @ triggers the bot :)
16:18:28 <chaosape> kpreid: ack! thanks ... sorry about that.
16:18:38 <Saizan> chaosape: in general you can use unsafeInterleaveIO
16:19:04 <Saizan> chaosape: it delays the side effects until the value associated is forced
16:19:39 <Saizan> chaosape: it's the primitive used to make readFile lazily read the contents of the file on demand for example
16:20:05 <chaosape> Saizan: yeah, i think that is what I want ;^)  ... why is it unsafe though ?
16:20:49 <Saizan> chaosape: you can break referential transparency with it, or come very close
16:20:53 <MyCatVerbs> chaosape: because you can't predict *when* the IO action will be run.
16:21:35 <MyCatVerbs> Also, it turns out that there's this problem with polymorphic references. You can use unsafePerformIO with IORefs to write coerce :: a -> b, which is just not kosher.
16:22:04 <Saizan> yeah, but i don't think that applies to unsafeInterleaveIO
16:22:55 <chaosape> alrighty! is what i am trying to do bad form?  should i be able to do this without performing unsafe  operations ... i suppose i dont need to use list comprehension ..
16:23:10 <pikhq> MyCatVerbs: So... You can implement unsafeCoerce in pure Haskell.
16:23:31 <kpreid> pikhq: well, unsafePerformIO is not part of H98 :-)
16:23:42 <kpreid> (it was introduced by the FFI spec)
16:23:44 <MyCatVerbs> pikhq: only if you... *waves at kpreid*
16:24:02 * kpreid is unsafe?
16:24:03 <pikhq> kpreid: And how many people do H98?
16:24:04 <MyCatVerbs> kpreid: oh cool, I didn't know that. Thank you. :)
16:24:24 <Saizan> chaosape: well, you should just be a bit careful, sometimes this extra laziness makes the code much nicer
16:24:50 <Saizan> chaosape: you need to decide if you care about the order/timing of the effects or not
16:24:59 <MyCatVerbs> pikhq: But anyways, it has 'unsafe' right htere in the name.
16:25:16 <MyCatVerbs> Only a loony schmuck would really need more warning than that.
16:25:18 <MyCatVerbs> *there
16:26:13 <chaosape> Saizan: okay! thank you very much for your help!
16:26:18 <pikhq> MyCatVerbs: unsafePerformIOIfYouUseThisWrongTheCompilerWillSteriliseYouAndYourChildrenUnto7Generations
16:27:34 <kpreid> that would be crying wolf
16:27:36 <idnar> MyCatVerbs: IO a -> IO b isn't really any less awful, though
16:28:01 <idnar> or whatever the type would be
16:28:27 <pikhq> kpreid: True. Of course, there's nothing to stop GHC devs from making that a feature.
16:29:59 <idnar> pikhq: unsafePerformIO isn't exactly "pure" :P
16:30:33 <pikhq> idnar: It's "pure Haskell" in the sense that you don't need to do anything outside of Haskell.
16:30:41 <pikhq> ... Not that it's purely functional.
16:30:42 <pikhq> Or even sane.
16:30:58 <idnar> pikhq: ah okay, so you mean like "no C code" or whatever
16:31:08 <pikhq> Right.
16:40:06 <harlekin> @pl (\r -> f *> r <* f)
16:40:07 <lambdabot> (<* f) . (f *>)
16:41:07 <harlekin> @pl (\f -> (<* f) . (f *>))
16:41:07 <lambdabot> ap ((.) . flip (<*)) (*>)
16:41:24 <harlekin> @src Monad (->)
16:41:25 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:41:36 <harlekin> @src Monad Maybe
16:41:36 <lambdabot> Source not found.
16:42:14 <dobblego> @src (>>=) Maybe
16:42:14 <lambdabot> Source not found. Maybe you made a typo?
16:42:19 <dobblego> @src Maybe (>>=)
16:42:19 <lambdabot> (Just x) >>= k      = k x
16:42:19 <lambdabot> Nothing  >>= _      = Nothing
16:42:24 <harlekin> @src (->) (>>=)
16:42:24 <lambdabot> f >>= k = \ r -> k (f r) r
16:42:30 <harlekin> @src (->) return
16:42:30 <lambdabot> return = const
16:42:30 <dobblego> (->) is not a monad
16:42:35 <harlekin> dobblego, thanks.
16:42:41 <dobblego> ha, didn't think that would work
16:42:49 <dobblego> @src ((->) t) return
16:42:49 <lambdabot> Source not found.
16:43:21 <benmachine> I think you need import Control.Monad.Instances for the ((->) t) instance
16:43:45 <dobblego> yes -- I was surprised that lambdabot gave an answer to (->) since it is not a monad
16:44:04 <benmachine> well @src isn't really rigorous
16:44:38 <benmachine> it's just a text file basically
16:44:45 <benmachine> of keywords and their definitions
16:44:58 <benmachine> so the key is going to be whatever's convenient
16:48:33 <moonpatrol> does it take some time to calculate the 98th number in the fibonacci sequence?
16:48:51 <soupdragon> yes
16:48:52 <nimbler> very little
16:49:00 <skorpan> "some time", sure!
16:49:07 <benmachine> it takes nonzero time :P
16:49:11 <moonpatrol> hmm, i must have broke hugs.
16:49:14 <benmachine> but I could do it by hand in a few minutes
16:49:28 <moonpatrol> well by *some* time, no more than say, a second, using a computer?
16:49:36 <nimbler> then no
16:49:39 <benmachine> much less than a second
16:49:43 <olsner> it takes no time at all if you don't do it
16:49:44 <ray> dobblego: if it stored it under ((->) e) say, what if someone looked it up under ((->) a)
16:50:11 <moonpatrol> so strange...
16:50:30 <moonpatrol> i would have thought if the recursive definition blew the stack then it would have stopped running
16:50:35 <moonpatrol> but it just seems to be stuck in limbo
16:50:42 <nimbler> oh, you using the naive version?
16:50:46 <Saizan> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 98
16:50:48 <lambdabot>   218922995834555169026
16:50:55 <nimbler> It only needs a stack O(98) deep, but will run for a long long time
16:51:13 <moonpatrol> hah, no i wrote one myself, just using the definition of it
16:51:23 <nimbler> then that's expected behavior
16:51:26 <moonpatrol> ah okay
16:51:30 <nimbler> runs for a long time without blowing the stack
16:51:34 <moonpatrol> i had no idea
16:52:59 <nimbler> I think this should be the official forum of the fibonacci sequence
16:57:05 <EvilTerran> moonpatrol, as in "fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)" kinda thing? yeah, that's exponential complexity while using linear stack
16:57:23 <EvilTerran> so it'll run for ages without overflowing
16:57:57 <ray> the infinite list one is constant stack and linear time, right?
16:58:09 <EvilTerran> i believe so
16:58:17 <Saizan> constant stack if you consume them in order
16:58:22 <EvilTerran> linear stack if you !! it
17:00:19 <moonpatrol> haha
17:00:26 <moonpatrol> EvilTerran: that's it right there...
17:17:43 <hackagebot> dyre 0.7.1 - Dynamic reconfiguration in Haskell (WillDonnelly)
17:20:51 <maxote> in shootout, ghc 6.10.3 is avg 2 times faster than Clean but uses avg double memory, lol.
17:22:10 <Botje> memory is cheap? ;)
17:23:05 <maxote> ghc 6.10.3 surprisily is faster than ocaml :)
17:23:47 <maxote> how is possible that this lazy evaluator is faster than the eager evaluator?
17:24:03 <pikhq> maxote: Good implementation.
17:25:02 <jeffwheeler> hackagebot: I wonder what's new in that release …
17:25:25 <jeffwheeler> Should I upgrade?
17:26:28 <BMeph> I'd love an interim conference of sorts on where Haskell is going, so that we could have multiple compilers more advanced than H98, that were still able to compile the same programs. :\
17:27:15 <soupdragon> where Haskell is going,   nowhere
17:27:22 <soupdragon> it's already here
17:27:32 <badsheepy> in bits that you assemble yourself :p
17:28:18 <BMeph> Lazy evaluation should always be faster, if only because it doesn't evaluate unused data. It shouldn't necessarily be as memory-conservative, although there may be times when it could be.
17:29:59 <nimbler> BMeph: "should" always be faster?  What does that mean?
17:30:03 <Saizan> that really depends on what you're performing the computation
17:31:33 <BMeph> Saizan: True.
17:32:17 <maxote> i will drop the ocaml programming forever
17:33:26 <maxote> ghc is now OK for me with very good speed and not much abuse in memory.
17:35:44 <nimbler> Has anyone looked at doing a high end computer game in Haskell?
17:37:03 <blackh> nimbler: Yes, someone has.
17:37:31 <blackh> nimbler: I'm working on just such a thing with Ryan Trinkle.
17:37:33 <BMeph> Hmm, maybe "faster" isn't the right characteristic. I more-or-less mean that lazy evaluation shouldn't evaluate things that don't need to be done in order to "get the answer". Kind of the "some values can be found by lazy eval that would bottom out when done eagerly.", but with more criteria than just "does it evaluate at all, or not?". :)
17:37:51 <nimbler> blackh: cool!  What kind of game?
17:38:19 <stianhj> Just the kind of game you were thinking of probably.
17:38:21 <maxote> ghc 6.10.3 is a lot faster than either cpython or python psyco! i'll use ghc for numerical computation instead of pyton!
17:38:49 <blackh> nimbler: An action/role playing game.
17:39:03 <blackh> nimbler: ...for the iPhone
17:39:41 <nimbler> blackh: ah, iPhone cool
17:42:52 <chaosape> whether or not performing Lazy evaluation of IO is actually safe or not is dependent on the implementation details of the backing library right?
17:44:46 <Saizan> BMeph: http://portal.acm.org/citation.cfm?id=969871 ?
17:45:04 <dino-> blackh: for iPhone with Haskell? You can compile for that, is it arm?
17:46:32 <blackh> dino-: Yes, here's all the information you need: http://projects.haskell.org/ghc-iphone/  You can ask me technical questions on #haskell-iphone IRC channel.
17:47:10 <maxote> i believe that the next ghc 6.12 will be more than 4 times faster than ocaml in quadcore automatically
17:54:05 <dino-> blackh: Thank you, very interesting. I see, seems very specific to the Apple stuff.
17:54:48 <blackh> dino-: It is, but it wouldn't be much work to adapt it to ARM linux, for example.
17:58:36 <Axman6> is John Goerzen someone who hands around on here?
17:58:43 <ray> yes
17:58:55 <ray> @seen cosmicray
17:58:55 <lambdabot> I saw cosmicray leaving #haskell-blah, #haskell-overflow and #haskell 6m 27d 2h 10m 44s ago, and .
17:58:59 <ray> i think that's his nick?
17:59:08 <ray> i remember it because it has ray in it
17:59:13 <Axman6> ta
17:59:15 <Axman6> heh
17:59:17 <dino-> ray: yes
17:59:34 <ray> almost 7 months though =o
17:59:41 <Axman6> i just thought that http://changelog.complete.org/archives/1136-the-thrilling-conclusion-of-goerzen-vs-dell-sweet-sweet-victory was awesome
18:00:29 <ray> ah yeah, just saw that on twitter
18:03:24 <moonpatrol> wow
18:05:12 <moonpatrol> that's pretty awesome
18:08:31 <mpacula> hey all
18:08:45 <Axman6> o/
18:09:03 <mpacula> i have a question about record syntax
18:09:12 <mpacula> probably dumb, but i'm new to haskell
18:09:54 <mpacula> say a define a type:
18:10:00 <Axman6> fire away, there are no dumb questions
18:10:09 <ray> yes there are!
18:10:14 <ray> but we'll answer those too
18:10:16 <Axman6> are there?
18:10:31 * Axman6 thinks that may have been too subtle
18:10:32 <mpacula> data Type = SimpleType String | DerivedType String Type | AnyType
18:11:27 <mpacula> then in my functions i can use pattern matching to determine which constructor of Type was used to create the argument
18:11:30 <mpacula> e.g.:
18:11:57 <mpacula> supertypes AnyType = [AnyType]
18:12:20 <mpacula> supertypes t@(SimpleType _) = [t, AnyType]
18:12:27 <mpacula> and so on for other constructors
18:12:49 <mpacula> the obvious problem is, whenever i change the def of SImpleType i need to update the patterns
18:13:02 <mpacula> so I though maybe record syntax would help
18:13:08 <mpacula> *thought
18:14:17 <mpacula> but even with record syntax, I still need to use pattern syntax to determine which constructor was used to create the argument, correct?
18:14:58 <Axman6> i believe so
18:15:12 <Axman6> is it really all that much hassle updating those other functions?
18:15:39 <ray> record syntax would just have different syntax, but you'd be doing the same thing
18:15:43 <mpacula> it's fine, i just thought maybe there was a better way
18:15:55 <ray> it's basically just a way to easily update data types that are huge cartesian products
18:16:27 <ray> and get free accessors
18:16:43 <ray> it's probably not what you want for your type
18:17:05 <mpacula> seems weird though... If I have a type with many constructors, i cannot really hide the internals of those constructors from their users
18:17:09 <ray> if you were doing some kind of data Something = Constructor String String String String String String String String
18:17:27 <ray> that's the kind of thing record syntax helps you out with
18:17:59 <mpacula> i understand the motivation for record syntax, i just thought i was using the wrong tool for the job so i asked
18:20:16 <mpacula> so there's really no way to get abstraction in this case? Any function that needs to do a different thing depending on the constructor of Type will need to know everything about that constructor?
18:21:34 <ray> if it bothers you, you can create some intermediate type synonyms or newtypes
18:21:50 <mike-burns> I feel like I've heard of some more advanced part of Haskell that helps you, mpacula, but if no one else has mentioned it then I guess not.
18:22:05 <Jedai> I missed most of the discussion but couldn't you write a fold for your datatype instead of exposing it ?
18:22:09 <mike-burns> You could implement a dispatch table if you were very concerned.
18:23:03 <mpacula> Jedai, can you clarify?
18:23:12 <Jedai> mpacula: like maybe for the Maybe type, or either for Either
18:23:18 <Jedai> @type maybe
18:23:19 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:23:23 <Jedai> @type either
18:23:24 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:24:13 <ray> either f g x applies f if it's a Left and g if it's a Right
18:24:28 <mpacula> that looks interesting, never heard of it before. I'll take a look
18:24:47 <ray> maybe z f x returns z if x is Nothing, and applies f if it's Just something
18:25:01 <Plouj> yo, homeboys
18:25:20 <ray> you can just pass in stuff with impunity as long as you pass in a function to handle each constructor too
18:25:35 <mpacula> ha, that's brilliant ray
18:25:41 <ray> you can even, if you desire, sing a cheerful tune while you do it
18:25:46 <mpacula> you learn something new every day
18:26:01 <Plouj> does anyone know of good examples for how I can use ==>, getState and putState interactively in ghci from RWH chapter 10: http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html#id625932
18:28:03 <mpacula> haha, the haskell community needs to come up with its equivalent of "god wrote in lisp" by julia ecklar
18:29:03 <Axman6> "God wrote his lisp interpreter in haskell"
18:29:19 <soupdragon> I think not
18:29:26 <ray> god wrote in lisp, but was written in haskell
18:29:32 <Axman6> heh
18:32:05 <mpacula> written by who ray? i think this creates recursion without a base case...
18:32:28 <Axman6> so?
18:32:34 <ray> god is a fixed point
18:32:44 <Axman6> that's perfectly acceptable in haskell
18:33:10 <ray> > fix (1:)
18:33:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:33:23 <moonpatrol> whoa
18:34:05 <ray> theology: another field solved by haskell
18:34:13 <mpacula> nice, i bet david hume never heard of that
18:35:21 <ray> well, haskell is only like 20 years old
18:35:39 <maxote> is there any good preprocessor for haskell ?
18:36:04 <ray> people use CPP for simple things
18:36:15 <ray> if you want fancy macros, look into template haskell
18:36:22 <Saizan> i don't follow, god, who writes in lisp, has been written by himself in haskell?
18:37:00 <maxote> common lisp to trash, ocaml to trash, .. they're in the trash because they are more inefficient than now's GHC
18:37:23 <gwern> Saizan: it's an alien idea, but then haskell is alien technology
18:37:51 <ray> saizan: he's not written by himself, he's a fixed point of something
18:40:05 <maxote> has ghc namescapes?
18:40:14 <maxote> err
18:40:20 <maxote> has ghc namespaces?
18:40:23 <ray> yes, modules
18:55:29 <shapr> So my script to install every package from hackage alphabetically is into L
18:55:42 <ray> =o
18:55:50 <soupdragon> lol shapr
18:55:52 <shapr> 4.5 hours so far.
18:55:52 <ray> it's smooth sailing from there, so i hear
18:56:06 <soupdragon> stop hogging the software
18:56:20 <shapr> hheh
18:56:40 <ray> you might crash twitter if you keep that up
18:56:50 <shapr> heh, I'm not tweeting each build failure :-)
18:57:02 <ray> you don't have to, hackage is on the same internet as twitter
18:57:08 <MoonPatrol> why are people attracted to twitter?
18:57:10 <ray> that's enough
19:07:28 <maxote> has GHC autovectorization?
19:07:45 <copumpkin> no
19:08:30 * Axman6 wonders how hard it would be to add
19:08:48 <copumpkin> I think it's already being worked towards in DPH
19:09:00 <copumpkin> there's plenty of mention of it in the source
19:09:49 <maxote> yes, it's exploting the capabilities, XD
19:10:31 <Axman6> i would have liked it for the n-bodies code i was writing ages ago
19:14:09 <necroforest> autovectorization?
19:14:14 <necroforest> like SSE?
19:14:21 <maxote> yes necroforest
19:16:14 <maxote> SSE is very good if there are many matricial operations
19:16:41 <necroforest> yeah
19:19:31 <maxote> haskell maybe a good algebraic language
19:19:40 <shapr> 1025 packages attempted so far
19:20:21 <ray> how many to go?
19:20:42 <maxote> i can recognize it as "GHC is the next generation of Matlab", xD
19:22:39 <Gracenotes> !!
19:25:43 <olsner> @pl \x -> f . g (h x)
19:25:43 <lambdabot> (f .) . g . h
19:27:46 <defun> Hey, I've never used xmonad. I understand that it recompiles itself, when changes are detected in the source code or something. Does the user (of xmonad) 'see' xmonad recompile and restart or is it 'behind the scenes'.
19:28:45 <Saizan> defun: behind
19:28:51 <ray> generally you do it by pressing a keybinding, but it's transparent to the user
19:29:21 <defun> Thanks. I would use xmonad myself, but I'm in a bit of trouble with a non-standard version of X11.
19:29:30 <ray> SPOILER WARNING!!!!!!!!!!!!!!!!!!!! the state is passed on the command line
19:29:34 <matsuura> STOP
19:29:38 <matsuura> STOP!!!!!!!!!!!!!!!!!!!!!!!
19:30:01 <Gracenotes> -- END SPOILERS --
19:30:52 <olsner> hmm, is using ((f <*> g) x) as (f (g x) x) excessively abstruse?
19:31:27 <ray> no
19:31:32 <badsheepy> its substantially more unreadable imo :o
19:31:46 <Saizan> the S combinator is nice
19:31:52 <Gracenotes> olsner: it's a common higher-level idiom, methinks
19:32:06 <Saizan> i prefer ap though
19:32:13 <Gracenotes> but preferably if you don't have an explicit 'x'
19:32:24 <Gracenotes> then there's =<< and join, likewise
19:32:34 <olsner> <*> = ap = S = join and =<<
19:32:48 <Saizan> join is different
19:32:54 <Saizan> =<< is also different
19:33:01 <Saizan> though quite similar to ap
19:33:01 <olsner> but yes, it's more like (\x -> f (g x) x) vs (f <*> g)
19:33:09 <olsner> @src ap
19:33:10 <lambdabot> ap = liftM2 id
19:33:29 <Saizan> @src join
19:33:29 <lambdabot> join x =  x >>= id
19:33:39 <olsner> istr there was a definition of ap using join and =<<
19:33:52 <aavogt> does anybody know template Haskell here? I have a list of Name, and I want to apply the functions that they name to a single argument, and collect the results in a list.
19:34:01 <Saizan> aaah i misparsed what you wrote
19:34:11 <Gracenotes> you can define function-ap using function-=<< and flip
19:34:58 <Gracenotes> and vice versa
19:35:24 <aavogt>  basically I want to run:  mapM (\name -> $name) names $ thatValue
19:35:27 <Saizan> ?hoogle listE
19:35:28 <lambdabot> Language.Haskell.TH listE :: [ExpQ] -> ExpQ
19:35:28 <lambdabot> Language.Haskell.TH.Lib listE :: [ExpQ] -> ExpQ
19:35:28 <lambdabot> Language.Haskell.TH ListE :: [Exp] -> Exp
19:35:45 <michaelfeathers> {}{}{}
19:36:14 <aavogt> but that is an illegal top-level splice, or something like that
19:36:27 <Saizan> aavogt: ListE (map (\f -> VarE f `AppE` arg) names)
19:36:34 <Saizan> aavogt: assuming arg :: Exp there
19:36:40 <Saizan> ?hoogle AppE
19:36:40 <lambdabot> Language.Haskell.TH AppE :: Exp -> Exp -> Exp
19:36:40 <lambdabot> Language.Haskell.TH.Syntax AppE :: Exp -> Exp -> Exp
19:36:40 <lambdabot> Language.Haskell.TH appE :: ExpQ -> ExpQ -> ExpQ
19:36:56 <olsner> I might give it a try to rewrite this with do-notation (still in the function monad) for extra cleverness
19:37:02 <aavogt> Saizan: shouldn't there be a way to write it with quasi-quotes?
19:37:49 <aavogt> thanks though
19:37:55 <Saizan> aavogt: have you tried mapM (\name -> [| $name thatValue |]) names?
19:38:20 <Saizan> you'll still need a ListE in the end
19:38:54 <aavogt> I tried something similar to that, but I was missing the ListE
19:38:59 * aavogt tries it
19:39:21 <Saizan> ListE `fmap` mapM (\name -> [| $name thatValue |]) names
19:39:31 <copumpkin> why `fmap` instead of <$> ?
19:39:46 <copumpkin> the pain of import Control.Applicative?
19:40:01 <Saizan> when i grew up we had only fmap!
19:40:12 <Saizan> and it was enough for everyone!
19:40:16 <copumpkin> lol
19:40:16 <BMeph> Isn't (f <*> g) == f x (g x), though? :)
19:40:34 <copumpkin> yup
19:40:39 <BMeph> I meant, *(f <*> g) x
19:40:48 <Saizan> ah, right
19:41:02 <olsner> @ty (?f <*> ?g) ?x
19:41:03 <lambdabot> forall a b t. (?f::t -> a -> b, ?g::t -> a, Applicative ((->) t), ?x::t) => b
19:41:13 <Saizan> so olsner really wanted =<<
19:41:41 <BMeph> The Kleisli star. :)
19:42:36 <olsner> hmm, lucky me that my 'f' happened to be commutative
19:44:40 <pikhq> So, I wrote a simple sexp parser, just to see how good Parsec is...
19:44:51 <pikhq> That... Is stunning.
19:45:13 <pikhq> 36 line parser.
19:48:30 <Axman6> paste?
19:48:48 <pikhq> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3263#a3263
19:49:12 <pikhq> Perhaps not the best way to write it, but it works and it's pretty clear what it's doing.
19:49:24 <pikhq> And... It's a 36 line parser without any golfing.
19:49:24 <olsner> Saizan: this is what I came up with... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8068
19:49:33 <olsner> I wonder if I'd like to go for the applicative or monady version though...
19:49:54 <Axman6> pikhq: got an example of what it parses?
19:50:11 <pikhq> Axman6: (lambda x (x x)) (lambda x (x x))
19:50:12 <aavogt> Saizan:     [| \x -> $(ListE <$> mapM (\n -> [| show $ $(return n) x |]) names) |]
19:50:17 <aavogt> ^^ that worked
19:50:18 <pikhq> It parses S expressions.
19:50:32 * Axman6 doesn't know what they are
19:50:51 <pikhq> Fine, fine. It parses a simple Lisp.
19:51:10 <copumpkin> pikhq: you should parse rivest's sexp spec and put it on hackage
19:51:20 <copumpkin> I quite like it
19:51:24 <Axman6> ah, i see
19:51:38 <pikhq> copumpkin: I may.
19:51:51 <pikhq> Sexp parsing is not hard, but very useful, after all.
19:52:07 <copumpkin> generate sexps too!
19:52:08 <copumpkin> :D
19:52:21 <pikhq> Even more trivial. :)
19:52:22 <copumpkin> class ShowSexp; class ReadSexp ;)
19:52:29 <copumpkin> and figure out some TH to autoderive it
19:53:36 <aavogt> TH++
19:53:45 <olsner> pikhq: needs more applicative :) e.g. toplevel = sepEndBy expr space <* eof
19:53:55 <pikhq> olsner: Hush.
19:54:04 <pikhq> ... But a good point.
19:54:10 <olsner> and those ">>= return ."
19:54:20 <olsner> <$> ftw :)
19:56:47 <pikhq> Anyways, I already have enough of a parser to write a simple Lisp.
19:57:01 <pikhq> In 36 lines of plain Haskell. That is quite impressive.
19:57:20 <olsner> it'd been shorter in lisp
19:57:38 <pikhq> olsner: Yes, that's because it's a function in Lisp.
19:57:42 <pikhq> (read).
19:57:47 <olsner> :P
19:58:10 <pikhq> I basically just *wrote* read is the thing. ;)
20:04:04 <maxote> what's the next? Quantum Haskell? hehehe
20:05:08 <roconnor> @go quantum io monad
20:05:11 <lambdabot> http://www.cs.nott.ac.uk/~txa/publ/qio.pdf
20:05:11 <lambdabot> Title: Shor in Haskell The Quantum IO Monad
20:06:38 <harblcat> so I'm sure that this is more of a maths question than a haskell one, but how would I get a list of all permutations of a given list?
20:06:49 <roconnor> > permutations [1,2,3]
20:06:50 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
20:07:01 <Trinithis> in Data.List
20:07:17 <harblcat> that was way easier than I thought it would be :)
20:07:21 <harblcat> thanks
20:07:24 <Ytinasni> harblcat: we love easy questions. :D
20:08:06 <djahanda1ie> roconnor, lol
20:08:45 <maxote> > permutations ['p','u','t','i','n']
20:08:46 <lambdabot>   ["putin","uptin","tupin","utpin","tpuin","ptuin","itupn","tiupn","tuipn","i...
20:10:14 * Axman6 wonders if there exists a word which all its permutations are also dictionary words (beyond the non trivial 1 and 2 character words)
20:10:35 <Axman6> hmm, this sounds like a a job for my TernaryTrees package :o
20:10:59 * Axman6 whips something up
20:12:51 <Axman6> :t when
20:12:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
20:13:08 <Trinithis> > 24^3
20:13:09 <lambdabot>   13824
20:13:16 <aavogt> > permutations "and"
20:13:18 <lambdabot>   ["and","nad","dna","nda","dan","adn"]
20:13:31 <copumpkin> zomg my name
20:13:40 <Axman6> :t all
20:13:41 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:14:01 <jmcarthur> > permutations "jmcarthur"
20:14:03 <lambdabot>   ["jmcarthur","mjcarthur","cmjarthur","mcjarthur","cjmarthur","jcmarthur","a...
20:14:14 <jmcarthur> zomg my name
20:14:22 <aavogt> they're all sort of dictionary words (permutations "and") that is
20:15:19 <Trinithis> > permutations "woe"
20:15:20 <lambdabot>   ["woe","owe","eow","oew","ewo","weo"]
20:16:00 <MoonPatrol> > permutations holycrapimawesome
20:16:01 <lambdabot>   Not in scope: `holycrapimawesome'
20:16:16 <MoonPatrol> > permutations "holycrapimawesome"
20:16:17 <lambdabot>   ["holycrapimawesome","ohlycrapimawesome","lohycrapimawesome","olhycrapimawe...
20:16:21 <maxote> > permutations "dog"
20:16:22 <lambdabot>   ["dog","odg","god","ogd","gdo","dgo"]
20:16:26 <MoonPatrol> ha, so it only outputs the first line.
20:16:43 <MoonPatrol> what library is that?
20:17:05 <maxote> > permutations "nba"
20:17:06 <lambdabot>   ["nba","bna","abn","ban","anb","nab"]
20:17:31 <aavogt> > permutations "www" -- zomg
20:17:32 <lambdabot>   ["www","www","www","www","www","www"]
20:18:01 <maxote> > permutations "666"
20:18:02 <lambdabot>   ["666","666","666","666","666","666"]
20:18:12 <Trinithis> lol
20:18:13 <copumpkin> zomg the devil lies within
20:18:26 <MoonPatrol> HA
20:19:18 <pikhq> > permutations "permutations"
20:19:19 <lambdabot>   ["permutations","eprmutations","repmutations","erpmutations","rpemutations"...
20:19:39 <gwern> erp mutations? sounds scary
20:20:16 <MoonPatrol> > permutations "lambdabot"
20:20:18 <lambdabot>   ["lambdabot","almbdabot","malbdabot","amlbdabot","mlabdabot","lmabdabot","b...
20:20:41 <maxote> > permutations "this"
20:20:42 <lambdabot>   ["this","htis","ihts","hits","iths","tihs","siht","isht","ihst","shit","hsi...
20:21:23 <roconnor> > nub . permutations $ "666"
20:21:25 <lambdabot>   ["666"]
20:21:35 <kulakowski> > take 10 ((permutations [1..]) !! 5004658)
20:21:37 <lambdabot>   [4,2,8,3,5,6,7,10,11,9]
20:22:19 <roconnor> mmm, lazy permutations
20:22:22 <Axman6> according to my program, ere is the only word that satisfies my criteria
20:22:37 <Trinithis> > permutations "ego"
20:22:37 <kulakowski> ree?
20:22:40 <lambdabot>   ["ego","geo","oge","goe","oeg","eog"]
20:23:25 <Axman6> ree indeed
20:23:34 <Axman6> > permutations "ere"
20:23:35 <lambdabot>   ["ere","ree","ere","ree","eer","eer"]
20:23:36 <MoonPatrol> > permutations "CEEFHKMORRTU"
20:23:38 <lambdabot>   ["CEEFHKMORRTU","ECEFHKMORRTU","EECFHKMORRTU","EECFHKMORRTU","ECEFHKMORRTU"...
20:24:10 <MoonPatrol> ah enough fun for one night.
20:25:35 * Axman6 is disappointed :(
20:25:38 <Asztal> pikhq: one nice combinator is: topLevel = (expr `sepBy` space) <* eof
20:25:53 <Asztal> hmm, I appear to have been scrolled upwards one hour
20:26:05 <Axman6> > permutations "hello"
20:26:06 <lambdabot>   ["hello","ehllo","lehlo","elhlo","lhelo","hlelo","lleho","lleho","lelho","l...
20:26:11 <pikhq> Asztal: And someone already said that.
20:26:17 <maxote> > permutations "now"
20:26:19 <lambdabot>   ["now","onw","won","own","wno","nwo"]
20:26:24 <pikhq> We've already had the "needs more applicative" discussion. ;)
20:26:39 <maxote> nwo = new world order
20:28:31 <Asztal> pikhq: yes, it just hadn't scrolled into my vision yet :(
20:29:37 <dm`> For arrows that are members of the ArrowApply class, Hughes says it is easy to implement first in terms of app, but I can't figure out how to do it.  Does anyone here know the answer?
20:34:33 <maxote> is there any web framework written in haskell?
20:35:39 <aavogt> many
20:35:46 <maxote> python->django, scala->liftweb, java->tomcat, haskell-> ????
20:36:17 <ray> happstack?
20:36:21 <maxote> yes!
20:36:34 <dm`> myfirst a = arr (\(b, c) -> ((a >>> arr (\x -> (x, c))), b)) >>> app
20:36:34 <dm`>  ???
20:37:29 <Cale> dm`: That seems to work
20:37:30 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
20:37:57 <Trinithis> :t app
20:37:58 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
20:38:18 <jmcarthur> i wrote a program to test for that word permutations question and ran it on a variety of word lists
20:38:23 <jmcarthur> didn't find anything all that interesting
20:38:31 <ray> @arr
20:38:32 <lambdabot> I'll keel haul ya fer that!
20:39:25 <leo__> @yarr
20:39:25 <lambdabot> What be a priate's favourite cheese?
20:39:25 <lambdabot> Yarrlsburg!
20:40:59 <pikhq> @@ arr yarr
20:41:00 <lambdabot>  arr yarr
20:41:13 <pikhq> @. arr yarr
20:41:13 <lambdabot> Shiver me timbers!
20:42:07 <ray> @. arr type arr
20:42:09 <lambdabot> Yeh scurvy dog...
20:46:48 <shapr> Now up to 1362 of 1480
20:47:04 <Axman6> doing well
20:47:17 <Axman6> @. leet arr
20:47:17 <lambdabot> Plugin `compose' failed with: Unknown command: "leet"
20:47:34 <ray> @. elite vixen
20:47:35 <lambdabot> ox
20:47:49 <Axman6> @. eleet arr
20:47:49 <lambdabot> Plugin `compose' failed with: Unknown command: "eleet"
20:48:04 <Apocalisp> @. elite yarr
20:48:05 <lambdabot> 4HOy /\/\4tEY$
20:48:25 <shapr> grep for 'failure' matches 359 package build logs.
20:48:25 <Apocalisp> awesome
20:48:50 <ray> but which ones =o
20:49:01 <ray> mass hackage-fixing time
20:49:06 <shapr> ray: So far it looks like ones where I didn't install the -dev packages yet :-/
20:49:16 <shapr> but yeah, after I've culled out those, mass hackage-fixing time!
20:49:16 <ray> oh, pff
20:49:19 <aavogt> @users
20:49:19 <lambdabot> Maximum users seen in #haskell: 658, currently: 549 (83.4%), active: 26 (4.7%)
21:45:31 <babusrini> How to represent numbers in base 2 like we do for hex as 0xab12
21:49:00 <kniu> babusrini, you mean as a haskell literal?
21:49:04 <kniu> I don't think that's possible.
21:49:25 <kniu> I've seen people just use [Bool], though that seems grossly inefficient to me.
21:49:50 <kniu> MEANWHILE
21:50:13 <aavogt> @index IsString
21:50:13 <lambdabot> bzzt
21:50:17 <kniu> I'm halfway done implementing that crazy general PTS where the types of abstractions are themselves abstractions.
21:50:38 <kniu> I got parsing and evaluation.
21:50:42 <kniu> Only thing left is typechecking.
21:51:00 <kniu> Crazy thing is, I've never written a typechecker before.
21:51:19 <kniu> Help?
21:51:33 <aavogt> babusrini: there's an extension: -XOverloadedStrings (only for ghc, afaict), that should let you write "01010111", and have that interpreted as a binary number
21:58:51 <Nafai> I'm looking at the code for WinGHCI.  Is there any reason something like this would need to be written in C?  Could I just as well write this in Haskell?
21:59:10 <Nafai> (If I were using a GUI toolkit that had Haskell bindings, that is)
22:11:42 <Saizan> kniu: have you seen augustss's simpler easier blog post?
22:11:55 <kniu> no, I have not.
22:13:35 <Saizan> http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
22:13:38 <erikc> ugh, trying to follow conversation threads on twitter is a mess
22:15:01 <Saizan> unification is the big part
22:35:23 <Nafai> Is there an API to call out to GHCI from another program?
22:39:09 <Saizan> Nafai: yes, the ghc-api
22:39:24 <Saizan> Nafai: also the hint package provides a nice wrapping of that api
22:40:26 * Nafai looks on Hackage
22:41:54 <Nafai> If I wanted to write my own GHCI repl, would this be the way to do it?
22:46:12 <Saizan> Nafai: yeah
22:47:24 <Yuki> Hi
22:47:31 <Yuki> Is anybody here?
22:47:47 <Yuki> Hello?
22:47:50 <Saizan> hi
22:47:59 <Yuki> do you know Java?
22:48:12 <Saizan> no, this channel is about programming in Haskell
22:48:16 <Yuki> oh...
22:48:18 <Yuki> ugg
22:48:40 <c_wraith> color me baffled
22:48:46 <Twey> Gogloom.
22:49:28 <Saizan> that's actually a faq.
22:49:44 <Twey> Aye.
23:16:21 <tommd> Since when did quickcheck save 'arbitrary' thunks and replay them for more than one argument to a function?
23:17:06 <tommd> That is really cool, and it must be what is happening.  I'm not going to believe it randomly generated a 16 Word8 values the exact same twice in a row.
23:34:24 <dons> tommd: hmm. might be a QC2 thing
23:35:01 <Nafai> dons: So is GHC-API or hint the way to go vs the WinGHCI method of wrapping a GHCI process?
23:35:49 <dons> mm.
23:35:51 <dons> ghc-api
23:36:07 <dons> though are you trying to replicate ghci exactly?
23:36:12 <dons> if so, the process model might be easier.
23:37:00 <Nafai> Probably, ghci + drop downs for completion, etc
23:37:34 <dons> long term, ghc-api will be more flexible
23:37:41 <dons> since you'll end up writing your own version of GHCI.hs
23:38:01 <dons> i'd probably go with ghc-api if i was writing a new ghci
23:38:13 * Nafai nods
23:38:42 <Nafai> I wonder if I have the skills to pull this off :)
23:39:16 <dons> don't underestimate yourself! and ask for help. everyone wants a ghci that's pretty :)
23:39:28 <Saizan> yup
23:39:35 <tommd> And ponies!
23:39:48 <dufflebunk> What? If it was hard to make it had better be ugle and hard to use.
23:40:23 * dufflebunk runs off
23:40:56 <Nafai> Yay ponies!
23:41:30 <c_wraith> ponies are great.  'til you need to feed them.  or clean up after them
23:42:24 <Nafai> Heh
23:43:20 <mornfall> Is there a way to tell cabal to compile a single module with -fvia-C but not others?
23:43:59 <dons> add -fvia-C to the module source as a pragma
23:44:07 <mornfall> Ah.
23:44:07 <dons> {-# OPTIONS_GHC -fvia-C #-}
23:44:09 <mornfall> Great, thanks.
23:44:20 <dons> prob. want -optc-O3 too, imo :)
23:44:46 * dons -> bed
23:44:48 <mornfall> Yes, (I have -O2 there). But it doesn't seem to make that much difference. Hm.
23:44:51 <mornfall> dons: Goodnight.
23:45:00 <Nafai> Night dons
23:50:48 <Axman6> mornfall: what do you want to use -fvis-C for btw?
23:52:50 <mornfall> Axman6: Squeezing last bits of performance.
23:53:09 <Axman6> i've found that the NCG usually is faster when using -O2
23:54:39 <mornfall> Yeah, it doesn't seem to make much difference.
23:54:54 <Axman6> what's the code?
23:55:23 <mornfall> Darcs binary index.
23:55:52 <Axman6> righto
23:56:09 <Axman6> maybe you could explain why darcs is so broken for me >_>
23:56:19 <mornfall> Not sure I could.
23:56:38 <mornfall> But I get a whatsnew on 100k files in .35 seconds, only .1 second slower than git. So I'm content.
23:56:56 <Axman6> well, i can't get it to compile
23:57:06 <mornfall> Axman6: What does it say?
23:57:12 <Axman6> everything before 2.3.0 compiled through cabal-install just fine
23:57:41 <mornfall> That's funny, I don't think I changed anything between last beta and final.
23:57:53 <mornfall> Can you paste the error somewhere?
23:57:54 <Axman6> says it can't find the curl libs, even when given the correct paths, thrn i... wtf, it's decided to start working agai
23:58:03 <Axman6> i tried about 15 times last night, without any luck
23:58:14 <Axman6> wtf
23:58:17 <Axman6> -_-
23:58:35 <mornfall> : - )
23:58:52 <Axman6> ok, that's even worse than having it broken
23:59:09 <Axman6> i hate it when things break, then fix themserlves without reason
23:59:45 <mornfall> Happens to me too, especially when I'm sleepy. ;)
23:59:50 <Axman6> yah
23:59:54 <Axman6> it was pretty late
