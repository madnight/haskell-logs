00:04:07 <solrize> is it impossible to add revisions to an old hpaste?
00:04:17 <solrize> it's not signalling any errors but my paste doesn't show up
00:05:34 <Saizan_> refresh the page
00:06:04 <Saizan_> ray: lots of misconceptions though
00:06:29 <Saizan_> from some comments it looks like every monad needs a magic runtime system to work
00:06:39 <ray> yeah, that's why it needs damage control
00:07:00 <Saizan_> ah, you asked for it
00:07:25 <ray> no, i'm saying what there is by dons etc is pretty good
00:07:58 <ray> there should be a siren that goes off when a reddit thread like that appears, though
00:08:36 <ray> and yeah, too much "monads are magic" when at most one type which happens to be an instance of monad is magic
00:08:52 <ray> and if you listen to conal et al, that's too much magic
00:09:53 <solrize> saizan, thanks, that works and shows that i added my revision about 3 times trying to figure out what was wrong :(
00:10:15 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8303  does this code look ok?  the IO (IO Integer) signature looks like a code smell and i'm not sure it does what i want anyway
00:10:44 <ray> :t join
00:10:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
00:10:53 <ray> try that
00:11:03 <solrize> i'm not even sure what happens if i join
00:11:24 <ray> or just don't use return at the end, actually
00:11:33 <solrize> hmm
00:12:16 <ray> join would flatten two IOs into one
00:13:11 <Saizan_> solrize: that works and it's fine
00:13:21 <solrize> well then i get an action which opens /dev/urandom and makes another action that reads some bytes
00:13:30 <solrize> saizan_ what i can't tell is whether it's re-opening the file each time i invoke it
00:13:47 <Saizan_> solrize: it reopens everytime you rerun rng
00:14:00 <Saizan_> solrize: but not when you run the action rng has returned
00:14:17 <Saizan_> solrize: in that case it only reads
00:14:26 <solrize> cool, that's what i wanted
00:15:00 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8304  i got rid of the return
00:15:18 <Saizan_> you needed the return
00:15:21 <solrize> which means instead of binding it inside main, i just invoke it
00:15:22 <solrize> hmm
00:15:33 * ray only uses comonad-random
00:15:35 <solrize> so without the return, it re-opsn the file?
00:15:39 <solrize> re-opens
00:15:39 <Saizan_> yes
00:15:51 <Saizan_> because you're calling rng everytime
00:15:59 <Saizan_> let       randomnum = rng
00:16:06 <solrize> yeah
00:16:15 <BMeph> Ooh, I hate people that claim to like C because it "works just like the underlying hardware". It's not 1969 anymore. I should know - I was born in '69. ;\
00:16:18 <Saizan_> that line doesn't cause any sideeffect to execute
00:16:40 <ray> bmeph: and you're programmed in C!
00:16:44 <solrize> what happens if i put back the return, and use "randomnum = join rng" ?
00:17:00 <Saizan_> solrize: it's the same as now
00:17:06 <solrize> join is synthesized from bind somehow
00:17:16 <Saizan_> ?src join
00:17:17 <lambdabot> join x =  x >>= id
00:17:46 <reppie> BMeph you mean it doesn't?
00:17:53 <ray> bmeph: but it doesn't work like your underlying hardware, so you have to make many trips to the doctor
00:17:55 <solrize> right, >>= only cares that the result is in the same monad as the input
00:19:53 <solrize> what if i put the join outside of the main action?
00:19:54 <ray> i think it should be defined as join = (id =<<)
00:20:18 <ray> partly because i like pointless, and partly because i think =<< is more natural
00:20:20 <Saizan_> solrize: that doesn't make much sense
00:20:23 <BMeph> It's more like bind is synthesized from join, but that's a purist arguement, and IANAP. :)
00:20:28 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8305  like that
00:20:44 <ray> bmeph: i am! but mutually recursive definitions is best
00:21:04 <ray> but either way i prefer =<< to >>= (because of the type being almost-fmap)
00:21:10 <Saizan_> solrize: that's still the same as without the return
00:21:15 <solrize> hmm
00:21:27 <BMeph> Also: =<< is a "more natural" operator - it's the Kleisli operator,
00:22:15 <Saizan_> solrize: if you have something of type IO A it's going to be a single action, so everytime it executes in full
00:22:52 <BMeph> It is useful that bind has so much in it that you only need it and id to define join, whereas you need join and fmap to get back =<<. :)
00:23:00 <Saizan_> if you want to do some inizialization and return a kind of "next()" action you need a type like IO (IO A)
00:23:26 <ray> yeah, bind is powerful
00:23:34 <solrize> right, so randomnum is going to do all the stuff there.  is there no way to make something outside of main, that has that file handle cached?
00:23:37 <BMeph> ...or an e -> IO A. :)
00:24:20 <ray> or a ReaderT e IO a
00:24:31 <ray> or however that goes
00:24:45 <solrize> yeah, IO (IO Integer) is what i have
00:25:11 <Saizan_> how lagged am i?
00:25:14 <solrize> i previously had "Handle -> IO Integer" but decided that was bad because it could take an arbitrary handle and i wanted it to be to a specific device
00:25:36 <ray> saizan_: one time zone?
00:25:54 <solrize> i have never understood Reader or Writer, and should probably try to figure them out
00:26:02 <ray> reader is just functions
00:26:10 <ray> writer is a little fancier
00:26:23 <Saizan_> you'll still have to open the Handle from main
00:26:29 <Saizan_> in some way or another
00:26:33 <ski> BMeph|out : `P' ?
00:26:38 <solrize> yeah
00:26:58 <ski> (hm .. probably "purist", now that i think of it)
00:27:05 <solrize> in this case, by calling something that opens it and returns a new action
00:27:55 <solrize> *Main> main
00:27:55 <solrize> Bambi-leaky-muscat-turd
00:28:02 <solrize> heh
00:28:38 <ski> reader is just environment
00:28:54 <ski> (writer is output)
00:29:38 <ray> actually i treat reader and (->) e as conceptually different even though they're the same thing
00:30:31 <ski> for what reason ?
00:31:40 <ray> because you can do cool function tricks, or you can do the environment thing
00:32:23 <solrize> saizan_ is the program basically sane?  i ask that because it's 2x the size (loc and char count) of the .py version, and a lot more obscure
00:37:14 <lpsmith> @seen mmorrow
00:37:15 <lambdabot> mmorrow is in #yi, #haskell-blah, #haskell-in-depth, #ghc and #haskell. I last heard mmorrow speak 5h 15m 57s ago.
00:40:21 <ray> solrize: you should look into the random libraries, to start
00:40:54 <solrize> yeah, there should be a way to feed /dev/urandom into the random monad
00:41:12 <stulli> > const words "foo bar" "bla blubb"
00:41:13 <lambdabot>   ["bla","blubb"]
00:41:50 <ray> well, not really
00:41:58 <ray> that's way too platform dependent
00:42:05 <stulli> can somebody explain why this happens? i thought it would be the same as const (words "foo bar") "bla blubb"
00:42:17 <stulli> > const (words "foo bar") "bla blubb"
00:42:17 <ray> you should just grab the standard random number generator
00:42:19 <lambdabot>   ["foo","bar"]
00:42:27 <solrize> stulli, it's (const words) "foo bar" "bla blubb"
00:43:02 <solrize> ray, afaik the standard rng doesn't use /dev/urandom
00:43:16 <solrize> it's just some numerical gizmo
00:43:37 <solrize> /dev/urandom is a cryptographic rng connected to a supposedly real entropy source
00:43:48 <ray> "It is initialised automatically in some system-dependent fashion, for example, by using the time of day, or Linux's kernel random number generator."
00:43:57 <solrize> yeah, that's pretty vague
00:44:01 <ray> well, i wouldn't trust urandom that much
00:44:15 <Deewiant> stulli: It's (const words) "foo bar" "bla blubb"
00:44:22 <solrize> urandom's seeding is a bit suspicious
00:44:30 <Deewiant> I.e. (const words "foo bar") "bla blubb"
00:44:36 <Deewiant> I.e. words "bla blubb"
00:44:59 <solrize> but the algorithm is probably more serious than the ghc random lib's
00:46:58 <ray> possibly, but you should still be looking into the random libraries
00:47:17 <ray> at least to make a randomgen out of your thing
00:47:39 <stulli> Deewiant: Thanks. Still looks strange to me, but i will investigate further
00:48:26 <Deewiant> Function application associates to the left: it can't know that you wanted the brackets in the middle
00:49:13 <stulli> aah, now i got it. const only takes its left argument (words) and throws away the right one ("foo bar")
00:49:29 <Deewiant> Yep
00:50:14 <ray> solrize: but i still wouldn't trust /dev/urandom or tie myself to a particular platform like that
00:50:44 <solrize> /dev/urandom is a better bet than something whose documentation doesn't claim it even attempts to be secure
00:50:56 <solrize> it would be good if the haskell platform had a portable interface to it
00:50:57 <ray> i mean i'd seed something myself
00:51:00 <solrize> like os.urandom in python
00:51:08 <solrize> where would you get the seed from?
00:51:11 <Saizan_> solrize: i'd use less variables in your code
00:51:24 <solrize> saizan_, hmm
00:51:25 <ray> Acme.Time.Now? :)
00:52:16 <solrize> yeah i could get rid of a few temporaries by making some expressions more complicated
00:55:12 <Saizan_> solrize: why IO (IO Integer) instead of IO (IO Int) btw? you truncate it anywhow with fromIntegral in the end
00:55:51 <solrize> only after reducing it mod n
00:55:59 <solrize> where n fits in an int
00:56:11 <solrize> anyway int is evil
00:56:35 <mercury^> Just perform a (`mod` n) at every stage.
00:57:06 <solrize> mod n where?
00:57:31 <solrize> oh you mean pass that array size into the fold in rng?
00:57:35 <ray> what are you doing? picking four words under 7 characters and without apostrophes from the word list?
00:57:41 <solrize> ray, yes
00:57:43 <mercury^> I haven't read your code.
00:58:08 <solrize> it's a passphrase generator
00:58:53 <solrize> mercury^ http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8302  and there is a python version a few revisions up
01:00:40 <Saizan_> solrize: i'd probably write it like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8276#a8307
01:01:17 <solrize> that's re-opening /dev/urandom on each invocation of randomnum
01:01:32 <solrize> i had originally written something like that but then tried to figure out how to avoid it, mainly as an exercise
01:01:40 <Saizan_> no
01:01:42 <solrize> for this purpose the re-opening doesn't actually matter
01:01:47 <Saizan_> that's still opening it only once
01:02:06 <solrize> hmm
01:02:10 <Saizan_> the action is returned, not performed
01:02:22 <Saizan_> though i forgot to s/h/f/
01:02:28 <fasta> Can the uuagc system also work with records?
01:02:46 <solrize> i <- randomnum   doesn't perform the action?
01:02:47 <fasta> It seems to be that it cannot, which makes it useless.
01:03:13 <Saizan_> solrize: that reads from the handle, but doesn't reopen it
01:03:15 <fasta> solrize: you can better start with the desugared version.
01:03:19 <solrize> oh wait, i was looking at wrong version
01:04:27 <solrize> ic, yeah, that version of rng is more concise
01:06:40 <solrize> i didn't know about listArray
01:07:38 <solrize> why   f . g . h $ x   instead of f $ g $ h $ x   ?
01:09:07 <ray> ask cale :)
01:09:22 <solrize> ok :)
01:09:25 <doserj> because f . g, g . h, and f . g . h are valid (well-typed) subexpressions, f $ g, g $ h, and f $ g $ g are not
01:09:38 <solrize> hmm
01:09:46 <doserj> (that's what cale would say :)
01:10:01 <Saizan_> and because $ looks ugly.
01:10:39 <ray> consider that you can define func = f . g . h
01:10:47 <solrize> i find $ fits the intuition of taking a value and running it thru a pipeline of one function after another
01:10:58 <ray> no, that's .
01:11:24 <Saizan_> in a functional language the intuition should be creating a pipeline by composing function and apply it to a value
01:11:25 <ray> or rather, . is about making a single function out of a pipeline of functions
01:11:53 <Saizan_> "functions", even
01:11:55 <solrize> yeah, $ keeps them conceptually separate
01:11:57 <ray> $ is just a parenthesis eliminator, not a deep concept like composition
01:12:04 <solrize> does the compiler make the same code for both?
01:12:35 <solrize> right, the intuition is f(g(h(x))) rather than (single complicated function)(x)
01:14:16 <ray> (f . g . h) x versus f (g (h x))
01:14:21 <ray> to use haskell syntax
01:14:23 <solrize> right
01:14:45 <ray> but the thing is, (f . g . h) is an actual *thing*
01:14:57 <solrize> yeah i guess this makes sense
01:15:04 <fasta> solrize: (h >>> g >>> f) is (f.g.h)
01:15:31 <fasta> solrize: In Forth, it is h g f
01:16:24 <fasta> In Lisp (compose f g h), pick whatever you want.
01:17:00 <solrize> i didn't realize forth had >>>
01:17:15 <ray> f (g (h x)) depends on the x for its very existence
01:17:53 <ray> consider also map (f . g . h)
01:17:56 <ray> or fmap (f . g . h)
01:18:08 <mmorrow> (grep "asdf" | sed 's|9|8|' | cut -d, -f1,3 | column -tx) < x.txt
01:18:22 <fasta> solrize: Forth has everything, since it is programmable.
01:18:30 <solrize> ok
01:18:37 <fasta> solrize: if you want to embed some Haskell in Forth, you can do so.
01:19:01 <shachaf> Cale would also say that $ should be infixl.
01:19:10 <ray> that's the thing about functional programming
01:19:17 <fasta> What would Simon say? ;)
01:19:19 <ray> functions are just some value you throw around like anything else
01:19:29 <mmorrow> and (.) is itself a function
01:19:52 <ray> you can compose functions just like you can add ints
01:20:03 <ray> by the time you apply your function, you're in boring land already
01:21:35 <solrize> yeah, sort of like pointfree style though, it can be done to excess
01:21:45 <jkff> *philosophical mood* There are no functions: there are values that have certain types. "Function" is a synonym for "A value of type (->) X Y for some X and Y". Also, Haskell happens to have a built-in syntax for obtaining a 'b' from a '(->) a b' and 'a'.
01:22:26 <Saizan_> all correct except for "there are no functions" :)
01:22:56 <ray> cale would say $ should be infixl, giving f $ g $ h $ x the distinct meaning of ((f g) h) x
01:22:58 <jkff> Well, 'There is no very special thing called a function', because functions are not very special :)
01:23:12 <idnar> jkff: they are pretty special in some ways, though
01:23:28 <idnar> but the type of functions isn't particularly special
01:23:37 <Saizan_> functions are values with types like X -> Y, that's all the special i need for them :)
01:23:51 <jkff> They are special in the sense that the '->' type itself is not implementable in Haskell from scratch.
01:24:02 <jkff> And that it is not an algebraic datatype and has no constructors.
01:24:14 <idnar> also, function application is a kind of infix operator that you can't define yourself
01:24:20 <jkff> Yep
01:24:24 <ray> it'd be like implementing modus ponens
01:24:40 <jkff> Also, there's no pattern matching on functions, but that's just because they are not an algebraic datatype.
01:24:51 <doserj> the same basically holds for product types, and for sum types
01:24:51 <ray> function application is a lot like modus ponens really
01:25:15 <Saizan_> it's the same thing
01:25:32 <jkff> Thanks to Curry-Howard isomorphism
01:25:45 <Saizan_> doserj: with functions you can implement those
01:25:51 <ray> i guess it is, but i'm thinking specifically of the fact that you can't "implement" it
01:26:08 <jkff> Yes, it is a constructive axiom
01:26:56 <doserj> Saizan_: right
01:33:33 <hackagebot> explore 0.0.5 - Experimental Plot data Reconstructor (CetinSert)
01:34:26 <shachaf> ray: fmap (f . g . h) = fmap (fmap fmap fmap fmap fmap f g h) , yes?
01:34:31 * shachaf should stop doing that.
01:37:34 <solrize> anyway, thanks
01:37:58 <solrize> @pl fmap (f . g . h)
01:37:58 <lambdabot> fmap (f . g . h)
01:38:01 <solrize> bah
01:38:48 <idnar> fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap mushroom mushroom
01:38:51 <shachaf> There should @unparen
01:39:03 <shachaf> What combinators are needed for that? Is it possible in general?
01:39:28 <solrize> shachaf S K I ?
01:39:38 <shachaf> solrize: That still uses parentheses.
01:39:42 <solrize> hmm
01:39:53 <ray> shachaf: lol
01:40:10 <idnar> shachaf: the easy way is to just have a bunch of function application operators of varying precedences :P
01:40:13 <mmorrow> , [$ski|SKI|]
01:40:15 <lunabot>  (S :$ K) :$ I
01:40:23 <solrize> i guess since system F has cut elimination you should be able to get rid of all parentheses and variables ?
01:40:52 <shachaf> idnar: Blah. I mean in the fewest symbols.
01:41:04 <shachaf> idnar: It would be neat if you could replace ` in Unlambda, for instance.
01:41:39 <solrize> @pl let {f 0 = 1; f n = n * f (n-1)} in f 5
01:41:40 <lambdabot> (line 1, column 5):
01:41:40 <lambdabot> unexpected "{"
01:41:40 <lambdabot> expecting "()", natural, identifier or "in"
01:42:11 <solrize> @pl let f x = x*x in f 5
01:42:11 <lambdabot> 25
01:42:16 <solrize> @pl let f x = x*x in f n
01:42:16 <lambdabot> n * n
01:42:38 <solrize> @pl let f n = if n==0 then 1 else n*f(n-1) in f k
01:42:38 <lambdabot> fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)) k
01:42:56 <solrize> :t if'
01:42:57 <lambdabot> Not in scope: `if''
01:43:23 <ray> fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap return return
01:43:32 <ray> join, it's a join, aaaahhhh it's a join
01:44:45 <shachaf> @ty let map = (.) in map (map map) (map map) map map map map map map map map map map map map map map map map map map map map map map map map map ?f map ?g ?h
01:44:47 <lambdabot> forall b c a b1. (?h::a -> b1, ?g::b1 -> b, ?f::b -> c) => a -> c
01:45:09 <purplepenguins> i'm not sure what that does but that is pretty epic shachaf
01:45:37 <shachaf> purplepenguins: It's just (f . g . h).
01:45:49 <ray> it's epic cogolfing, maybe
01:46:02 <purplepenguins> cogolfing...the dual of golfing?
01:46:14 <ray> you try to make something simple as long as possible
01:46:46 <shachaf> ray: Unforunately cogolfing is not nearly as interesting, in itself.
01:46:58 <ray> yeah, there's no absolute upper limit, so cogolfing is boring
01:47:06 <ray> you can always add a bunch of fmaps
01:47:17 <Gertm> k
01:47:32 <Gertm> (typo, ignore)
01:47:38 <ray> the related concept of obfuscation is more interesting
01:48:15 <shachaf> ray: But not measurable.
01:48:25 <fasta> ray: someone showed in some paper that a lot of obfuscations can be undone, IIRC. Certainly, those used in commercial systems.
01:48:55 <shachaf> (An interesting obfuscated program is usually novel in some way. For golfing, you have an obvious simple metric.)
01:49:05 <shachaf> Oh, you don't mean IOCCC-style obfuscation?
01:50:31 <ray> i do
01:51:24 <shachaf> Hmm, an IOCCC program that deobfuscated itself (and the other entries :-) ) would be interesting.
01:52:33 <ray> a program that when passed its own obfuscated source generates its own clear source, and vice versa
01:52:43 <ray> they have to both compile to the exact same thing
01:54:24 <pr> good morning
02:02:04 <stulli> Is it possible to import only one function from a module qualified and the rest unqualified?
02:02:18 <mmorrow> import Data.Map(Map,fromList)
02:02:23 <mmorrow> import qualified Data.Map as M
02:02:34 <stulli> ah, thanks!
02:02:40 <mmorrow> np
02:03:01 <stulli> you even knew which module i want to use :)
02:03:05 <mmorrow> heh
02:03:41 <dixie> Guys, Does somebody have here ghc-6.10.x compiled for FreeBSD (x86) ?
02:05:20 <lpsmith> mmorrow:   http://www.cs.nott.ac.uk/~mjj/monatron/
02:06:00 <lpsmith> The codensity transformer has an mfix operator mighty similar to yours
02:06:24 <mmorrow> lpsmith: cool, i'll check that out
02:06:34 <lpsmith> On the other hand,  looking at the source it doesn't appear the author has probed it's deeper meaning yet though :-)
02:06:34 <mmorrow> heh "monatron"
02:06:42 <mmorrow> hehe
02:07:54 <lpsmith> and,  very interestingly, the author doesn't appear to cite Erkok's thesis in any of his papers
02:08:36 <lpsmith> on the other hand,  the source code comments suggest he might have read the thesis
02:10:46 <quicksilver> mmorrow: you forgot to import ! unqualified though :)
02:11:22 <mmorrow> quicksilver: i've been desensitized to the horror of M.! i guess :/
02:13:00 <lpsmith> heh, I've never tried to get used to qualified infix operators.  Maybe they aren't so bad ;-)
02:14:17 <mmorrow> once you're importing multiple modules that each have a (!), necessity sets it
02:14:19 <mmorrow> s/it/in/
02:14:50 <mmorrow> (Map and IntMap being the example i'm thinking of)
02:17:28 <quicksilver> mmorrow: if I was doing that, I'd probably invent a class for (!)
02:17:43 <quicksilver> just for the benefit of that file.
02:18:39 <mmorrow> quicksilver: but what about Data.Array.! ?
02:19:21 <quicksilver> class Bangable c k v | c -> v where (!) :: c -> k -> v ?
02:19:52 <mmorrow> i couldn't bring myself to do it, although in principle it's a solution :)
02:20:03 <quicksilver> it's only a couple of lines.
02:20:23 <mmorrow> well, then you need one for each of !@#$%^&* as well..
02:20:32 <quicksilver> true
02:20:59 <mmorrow> maybe now's the time to start using unicode
02:21:07 <solidsnack> I'm having some surprising trouble with AttoParsec.
02:21:07 <solidsnack> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8309#a8309
02:21:21 <solidsnack> Maybe some Laziness has leaked?
02:22:55 <mmorrow> i've gotta map some nice unicode syms to <something>-shift-[0..9], then make little stickers or something i think before i'd actually start thinking of them as not a pita
02:24:19 <Fairweather> how can I do string interpolation in haskell?
02:24:45 <Fairweather> (++) just doesn't seem very expressive
02:25:06 <Beelsebob> I use concat for that
02:25:11 <quicksilver> mmorrow: but I'm not sure that there are three different symbols to use for M.!, IM.! and A.!
02:25:33 <quicksilver> mmorrow: they're close enough to the 'same' operation that you'd end up choosing three very similar symbols - why not just overload one?
02:25:55 <ray> http://learnyousomeerlang.com/ lol
02:26:19 <ray> erlang is an octopus with facial hair i guess
02:26:33 <Beelsebob> > concat ["build up ", show "large strings", " with other values ", show 5, " in them, like this Fairweather"]
02:26:34 <ziman> :D
02:26:34 <lambdabot>   "build up \"large strings\" with other values 5 in them, like this Fairweat...
02:26:49 <jkff> This is worse http://learnyousomeerlang.com/static/img/worm.png
02:26:50 <quicksilver> mmorrow: you know what would look really nice? An editor which formatted "IM.!" to appear on screen like "!_{IM}", perhaps with the IM part in a different colour.
02:27:02 <mmorrow> quicksilver: i dunno, i guess Foo.! seems less painful to me than class Bangable
02:27:47 <ray> fairweather: or, if you're willing to use extensions, there are some quasiquoters on hackage
02:27:53 <Fairweather> Beeksebob: that's better, thanks
02:28:28 <ray> or oleg's extension of printf to use Show
02:28:32 <Fairweather> *Beelsebob
02:28:39 <mmorrow> quicksilver: hmm, yeah that'd be neat.. further it could color class methods different colors depending on the instance being chosen for them (if any)
02:28:58 <Fairweather> ray: what extension?
02:29:02 <ray> fairweather: template haskell
02:29:14 <mmorrow> Fairweather: yeah, QuasiQuoters are definitely a solution, but not entirely lightweight
02:29:29 <ray> i tend to like using quasiquoters for that
02:29:36 <mmorrow> , let x = [0..3] in [$here| [0..3] is $([0..3]) and $(x) |]
02:29:38 <lunabot>  " [0..3] is [0,1,2,3] and [0,1,2,3] "
02:30:14 <Fairweather> I'll check it out when I have time
02:30:27 <ray> the quasiquotation syntax is a liiiiiiitle ugly, but i think the benefits outweigh that
02:30:30 <mmorrow> , [$bf|.+[.+]|]
02:30:31 <lunabot>  luna: No instance for (GHC.Show.Show
02:30:31 <mmorrow> , [$bf|.+[.+]|] ""
02:30:32 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
02:30:47 <quicksilver> mmorrow: combined with string gaps that might be quite nice for multiline here docs, except string gaps are ugly.
02:32:27 <mmorrow> quicksilver: you could always define your own string-gap-equivalent thingy in the QQ
02:33:12 <mmorrow> and then take care of the translation in the parser
02:34:13 <quicksilver> mmorrow: yes although I think I might find anything I chose ugly.
02:37:29 <mmorrow> , (vcat . fmap (\(cols,tab) -> let xs = hcat . punctuate comma . fmap text $ cols; t = text tab in text [$here|SELECT $(xs) from $(t);|]))) [(["name","offense"],"shit_list"),(["stuff","things"],"chairs")]
02:37:30 <lunabot>  luna: parse error on input `)'
02:37:35 <mmorrow> , (vcat . fmap (\(cols,tab) -> let xs = hcat . punctuate comma . fmap text $ cols; t = text tab in text [$here|SELECT $(xs) from $(t);|])) [(["name","offense"],"shit_list"),(["stuff","things"],"chairs")]
02:37:37 <lunabot>  SELECT name,offense from shit_list;
02:37:37 <lunabot>  SELECT stuff,things from chairs;
02:37:47 <mmorrow> FROM
02:38:33 <mmorrow> an SQL QQ would be a total killer app
02:39:34 <ray> wow, it probably would
02:39:56 <mmorrow> and you could even do type/validity/etc checking in the parser/QQ at compile-time
02:40:20 <easy4> is it possible to label only some of the fields of a constructor?  i tried 'data X = X {_ :: Int, y :: Int}' but it raised an error.
02:41:03 <mmorrow> easy4: data X = X Int Int; y (X _ a) = a
02:41:07 <mmorrow> is equivalent
02:41:30 <quicksilver> mmorrow: except for pattern match + update syntax
02:41:34 <mmorrow> right
02:41:35 <ray> you do not get convenient updating of y, however
02:41:52 <mmorrow> hmm
02:42:11 <ray> record syntax is like syntactic sugar in the raw
02:42:12 <quicksilver> I woudl do X { _dontusethisitsreallylongandinconvenient :: Int, y :: Int }
02:42:21 <quicksilver> although I'm not sure what you're trying to do
02:42:26 <mmorrow> quicksilver: the Show output would be lovely :)
02:42:33 <quicksilver> yup
02:43:26 <ray> if it's only one field, an update_y :: X -> Int -> X (or possibly i'd prefer Int -> X -> X) isn't too cumbersome
02:43:33 <ray> if it's more.. it is
02:43:36 <ray> cumbersome
02:43:50 <easy4> i've got a syntax tree and the only label i want is position info for each constructor.  i'll probably just use a case statement because i don't need record update.
02:44:16 <quicksilver> I don't like record update syntax anyway.
02:44:28 <ray> in the ugliness sense, you mean?
02:44:37 <quicksilver> bit more subtle than that
02:44:43 <ray> i believe it's useful but ugly
02:44:52 <ray> like quasiquoters
02:45:10 <quicksilver> I think it's ugly that the same name is used in some contexts as if it was a field name (like in a C struct) and in other contexts like a selector function (which is what :t will tell you it is)
02:45:16 <mmorrow> modify(\e->e{foo = f (foo e)}) -- gets annoying
02:45:41 <ray> ugly meaning something like "the syntax does not scan well"
02:45:47 <quicksilver> so when I'm doing much of this kind of thing, I use lenses
02:46:01 <quicksilver> modify (foo ~= f)
02:46:03 <quicksilver> or something like that
02:46:09 <quicksilver> where foo is now a lense, not a field name
02:46:32 <ray> hmm
02:47:11 <mux> I wish Data.Accessor was in base and wouldn't require TH
02:47:57 <mmorrow> quicksilver: it's like the worst of both worlds.. data A = A{a::Int}; data B = B{a::[Double]} clash on `a', and the function `a' you get selects
02:48:18 <quicksilver> mux: it odesn't need to require TH
02:48:25 <quicksilver> that's just a convenient way to autogenerate your lenses.
02:49:13 <mmorrow> mux: i usually prettyprint TH-generated code and then include it in stuff statically
02:49:17 <mmorrow> mux: http://moonpatio.com/repos/MkLenses.hs
02:49:29 <mmorrow> mux: e.g. the comment at the bottom of that
02:49:36 <mux> that's a good idea
02:49:53 <quicksilver> I don't like Henning's habit of calling all types T
02:49:55 <mmorrow> (writeFile "AsdfModule.hs" . render . ppDoc) $(lift =<< mkLensesQ ''HscEnv)
02:49:58 <mmorrow> in ghci
02:50:08 <quicksilver> mostly because it interacts poorly with haddock, I guess.
02:51:55 <mmorrow> mux: the benefits being, you only have to compute it once (unless something changes of course), you can actually look at it, and you don't have to depend on TH imports or syntax extensions in the final-product code
02:52:06 <mux> yeah *nods*
02:53:19 <mmorrow> oh crap, i think that MkLenses.hs has a bug
02:53:27 <mmorrow> hsc_FCL x_7 = (hsc_FC x_7, \x_7 -> x_7{hsc_FC = x_7})
02:53:31 <mmorrow> (all x_7)
02:53:33 <mmorrow> oops
02:53:34 <quicksilver> mmorrow: do you use Data.Accessor, or your own version?
02:54:10 <mmorrow> quicksilver: i haven't used Data.Accessor myself, just my own version on occasion
02:54:49 <mmorrow> although i really should get more disciplined about generating lenses for all my datatypes, because i'm really glad i did when i do
02:55:04 * quicksilver nods
02:55:15 <quicksilver> I can't put my fingers on what I don't like about data.accessor
02:55:23 <quicksilver> except "I didn't write it"
02:55:36 <quicksilver> something about it bugs me though.
02:58:04 <mmorrow> mux: ok, bug fixed http://moonpatio.com/repos/MkLenses.hs
03:03:27 <mmorrow> quicksilver: it's a little too heavy-weight for my tastes
03:04:30 <mmorrow> (but again, i haven't really used it so this is just based on looking at code that uses it)
03:04:37 * quicksilver nods
03:42:32 <aleator> Hi, if I've got code that has lots of big foreign objects, which is the easiest way to profile where they get held up?
03:49:36 <lilac> > let waysToFindWhoIsHoldingAPointerToMyObject = [] in minimumBy (comparing easiness) waysToFindWhoIsHoldingAPointerToMyObject -- aleator
03:49:38 <lambdabot>   * Exception: List.minimumBy: empty list
03:51:14 <aleator> So it
03:51:18 <aleator> is that bad then?
03:54:09 <maltem> aleator, does retainer profiling help you? (I'm not sure what retainer profiling actually is)
03:55:22 <mmorrow> aleator: what do you mean by "has" them, and what are they?
03:55:43 <mmorrow> (and what does "held up" mean? :)
03:57:17 <aleator> maltem: My problem is a piece of code that loads a pair of big bitmaps via ffi, matches them (ffi) and returns offset between them. This is repeated many times and it consumes several gigs of memory without reason
03:57:56 <lilac> aleator: how is the memory for these bitmaps supposed to be freed?
03:58:16 <lilac> do you have a finalizer attached to them somehow, or are you freeing them explicitly?
03:59:37 <aleator> lilac: I've got a finalizer in foreignptr.
04:00:07 <aleator> Which seems to work in simple cases if I attach some printf debugging there
04:00:13 <maltem> aleator, anyways, retainer profiling is described here, http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#retainer-prof
04:00:35 <aleator> maltem: That might help. When I understand it :)
04:00:54 <maltem> heh
04:01:17 <quicksilver> it seems likely you are accidentally keeping a reference to the pointer
04:01:26 <quicksilver> so it's not getting GCed and your finalizer isn't getting called
04:01:29 <quicksilver> can you check?
04:02:56 <lilac> unsafePerformIO (modifyIORef (unsafeCoerce waysToFindWhoIsHoldingAPointerToMyObject) ((ask #haskell):))
04:03:21 <skorpan> looks like lisp
04:03:43 <mmorrow> aleator: personally with FFI stuff i like explicit (in haskell) malloc/free instead of ForeignPtr
04:04:01 <mmorrow> aleator: since then you never have to wonder
04:04:06 <aleator> quicksilver: http://haskell.pastebin.com/d5c36f4eb This is what I do for every pic
04:04:33 <aleator> mmorrow: Yep. But that get really really awkward soon.
04:04:39 <aleator> +s
04:05:08 <quicksilver> mmorrow: the automatically bracketed version is even nicer, when it applies
04:05:14 <mmorrow> aleator: possibly, are the original ForeignPtrs surviving for a long time in haskell-land?
04:05:34 <mmorrow> quicksilver: totally, i love "bracket malloc free (\p -> ....)"
04:05:54 <aleator> mmorrow: They shouldn't, but maybe they are. How should I check?
04:06:13 <mmorrow> aleator: if they aren't, then wouldn't malloc/free be simple?
04:06:55 <mmorrow> aleator: (if this were me) how i'd "check" would be by not using ForeignPtr at all, but that's just me :)
04:07:45 <aleator> mmorrow: If I understand properly, no, since I then wouldn't be able to write expressions with images. (Which is debatable if I should even try but)
04:08:20 <mmorrow> aleator: but if you *really* want ForeignPtr, i guess how to check would be to read through all the code that touches said ForeignPtr(s) and try to determine what's holding onto a reference to them
04:08:45 <quicksilver> mmorrow: isn't that what alloca and allocaBytes do? :)
04:09:13 <aleator> mmorrow: Yep.. I was just hoping there'd be something when I just can't see it..
04:09:24 <aleator> Like there is with heap allocated stuff.
04:09:34 <mmorrow> quicksilver: true, although iirc alloca* uses a ByteArray# or something (not that that matters, but for some reason i'm attached to malloc :)
04:10:37 <mmorrow> aleator: hmm, not sure if this might be useful to you, but i had to deal with images gotten from C in haskell code with http://moonpatio.com/repos/vacuum-gl/
04:11:28 <mmorrow> this (disorganized :) module does the ffi'ery http://moonpatio.com/repos/vacuum-gl/System/Vacuum/OpenGL/MMGV.hs
04:11:56 <quicksilver> mmorrow: in GHC it does, yes. I don't know why but I bet there is a reason :)
04:12:04 <mmorrow> and this (disorganized :) .c does the allocation of said images http://moonpatio.com/repos/vacuum-gl/c/mm-img.c
04:12:20 <mmorrow> quicksilver: i guess since there's no C stack to speak of
04:12:47 <quicksilver> mmorrow: well yes, but I mean as opposed to literally being malloc `finally` free
04:12:57 <aleator> mmorrow: I'll check that.
04:13:00 <mmorrow> quicksilver: but yeah, alloca is probably definitely master than malloc/free
04:13:09 <mmorrow> quicksilver: oh, right
04:13:21 <mmorrow> s/master/faster/
04:15:13 <aleator> The reason I'm not liking bracketing or explicit malloc/free is that I can't figure out where to allocate temporary space, what happens when function returns several images and all those manual mm hassles. Matlab people don't worry about that stuff, so neither should haskell people
04:15:53 <mmorrow> aleator: so basically the haskell code acts as the puppeteer getting an Img from C (gotten via graphviz), and then feeds that to more C that parses it as a BMP, then hands that to OpenGL to copy into video memory
04:17:18 <mmorrow> aleator: true, although someone has to worry about it somewhere along the pipeline (and if the pipeline is only "C -> you", it may have to be you)
04:18:27 <aleator> mmorrow: True. But I don't see a reason why dealing with foreignPtrs should be any more difficult than with heap objects.
04:19:29 <mmorrow> aleator: oh, right. it definitely shouldn't, assuming no haskell code is holding onto the ForeignPtr when it shouldn't be .. :)
04:20:24 <mmorrow> aleator: so i suppose ForeignPtr+finalizer just moves the "explicit free" to "explicitly discard all references to the ForeignPtr"
04:20:46 <aleator> mmorrow: Yeah, but if it was a heap object, I'd see the when profiling. It can't be impossible see how many of them are still kept alive.
04:21:06 <mmorrow> aleator: is the memory allocated in the C heap?
04:21:16 <aleator> mmorrow: Yes
04:21:17 <mmorrow> or with mallocForeignPtr?
04:21:34 <mmorrow> aleator: ah, if it's in the C heap then the haskell tools may not be able to help
04:21:43 <aleator> C lib does it's own allocations so..
04:22:13 <aleator> But, then again, the ptrs are wrapped inside a specific constructor. So just seeing how many of those are still live would be good.
04:22:47 <aleator> Hmm.. Does ghc GC even figure out that it should collect if stuff is kept in c heap?
04:22:51 <mmorrow> aleator: you could possibly use System.Mem.Weak to and get WeakPtrs to them all (as a debug thing)
04:23:20 <mmorrow> aleator: if it finds to live refs to a ForeignPtr, it'll run the attached finalizer
04:23:25 <mmorrow> s/to/no/
04:25:47 <mmorrow> aleator: (i assume you're explicitly attaching a finalizer (IO ()) action to the ForeignPtr that you've converted from a Ptr that you got from C?)
04:25:51 <mmorrow> *i'm
04:27:09 <aleator> mmorrow: Yeah. http://haskell.pastebin.com/d5c36f4eb <- this is the thing that happens to all images. Sometimes with some unsafeperforming.
04:27:49 <aleator> 'fun' is a call to c thing that happens to allocate an image and returns it
04:28:48 <mmorrow> aleator: oh, hmm. i'm not sure that importing a function ptr that way is valid (does the code work?). maybe this is causing (part of) the problem
04:29:44 <aleator> mmorrow: It seems to work. You mean the releaseImage, or the bit of c2hs before it?
04:30:22 <mmorrow> using the "&" to import a function as a FunPtr
04:30:27 <mmorrow> in foreign import ccall "& wrapReleaseImage" releaseImage :: FinalizerPtr Image
04:30:34 <mmorrow> (i didn't know you could do that)
04:30:47 <mmorrow> what i've done is to
04:31:08 <aleator> Hmm.. I did that rather long time ago, so I've got no clue where I got that.
04:32:59 <mmorrow> err, wait i'm starting to mix up what we're doing here
04:33:28 <mmorrow> so the finalizer needs a FunPtr to a C function
04:33:45 <stanv> please remeber the function that takes foo :: a->b-> ... and produce boo:: ->(a,b)->...
04:34:47 <mmorrow> maybe as a debug thing you could wrap a haskell IO() and foreign export that as a C function, then pass this disguised haskell IO() as the FinalizerPtr, and the IO() would do (print "i'm running now!") or whatever
04:35:56 <mmorrow> aleator: yeah, now that i think about it importing a symbol that happens to be a function as a funptr like that would have to be valid
04:36:41 <stanv> curry and uncurry
04:36:42 <stanv> ...
04:51:10 <noteventime> Wow, I did not know about GeneralizedNewtypeDeriving, that's wonderful!
04:53:42 <EvilTerran> noteventime, it's not without its theoretical difficulties, but yeah, it's pretty clever
04:54:15 <mmorrow_> aleator: hmm, it doesn't seem like finalizers to foreignptrs built in ghci get called
04:54:22 <mmorrow_> aleator: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3361#a3361
04:54:37 <mmorrow_> aleator: (even if you additionally do System.Mem.performGC)
04:55:16 <mmorrow_> aleator: maybe ghci/bytecode-repl-machinery is somehow holding onto them and preventing the finalizers from being run or something
04:55:19 <stanv> @pl \(a,b)->(b,a)
04:55:19 <lambdabot> uncurry (flip (,))
04:55:24 <noteventime> EvilTerran: I can imagine it has its difficulties, but if nothing else, it seems very good to have when prototyping
05:00:42 <EvilTerran> noteventime, indeed
05:06:42 <bastl> hi how can i catch the stdout of a command I call with System.system "ls" ?
05:07:19 <ray> > [LT..]
05:07:21 <lambdabot>   <no location info>: parse error on input `]'
05:07:39 <quicksilver> > [LT ..]
05:07:40 <lambdabot>   [LT,EQ,GT]
05:07:50 <quicksilver> ray: congratulations, you found another edge case ;)
05:07:58 <ray> yep, just found it
05:08:14 <ray> it's parsing it as a module name, right?
05:08:17 <quicksilver> LT.. is parsed as operator . in module LT
05:08:37 <quicksilver> > (+1) Prelude.. (+2) $ 4
05:08:37 <ray> fun city
05:08:38 <lambdabot>   7
05:08:45 <Philonous1> bastl: (_, Just hout, _, _) <- createProcess (proc "ls" []){ cwd = Just "\home\bob",std_out = CreatePipe }
05:09:12 <Philonous1> bastl: You can then read the handle with hGetContents
05:09:55 <bastl> System.process shows "experimental" so i thought, I shouldnt use it. Your example will do it . Thanks.
05:12:09 <Philonous1> bastl: Note that there is a library dedicated to directory manipulation: http://hackage.haskell.org/packages/archive/directory/1.0.0.3/doc/html/System-Directory.html
05:12:26 <bastl> ls was just an example
05:12:34 <Philonous1> ok.
05:13:48 <Philonous1> bastl: Oh, btw. hGetContents is lazy, so you need to force the resulting string before you close the handle, or otherwise it will be truncated.
05:14:20 <bastl> how do i "force the string" ?
05:14:27 <bastl> evaluate it once you mean?
05:14:42 <Philonous1> "return $! length ,myString" for example
05:15:00 <Philonous1> (without the comma)
05:15:34 <bastl> hmm, ugly. I think I can fetch the infos i want out of it, and then close the handle?
05:16:32 <quicksilver> Philonous1: s/lazy/broken interleaved IO/
05:18:23 <Philonous1> bastl: Yes, if you fetch your data eagerly.
05:20:53 <xuei> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8317  This program never returns control. What's wrong with untilM?
05:22:30 <quicksilver> xuei: you execute *all* the effects in your infinite list, with sequence.
05:22:49 <quicksilver> xuei: only after you've executed all the effects, do you run dropWhile/head on the result.
05:22:57 <quicksilver> (unfortunately it takes forever, so you never get there)
05:23:42 <purplepenguins> probably should drop befores sequencing then
05:24:10 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8317#a8318  try this
05:24:49 <solrize> hmm different signature,  but you can probably see how to fix it up
05:26:34 <xuei> thanks all, i'll try it now.
05:27:00 <quicksilver> although as we established yesterday, sequence isn't entirely useless with infinite lists.
05:27:14 <quicksilver> it works OK for exception-type monads, as long as an exception is eventually thrown
05:27:38 <quicksilver> > sequence (Nothing : map Just [0..])
05:27:40 <lambdabot>   Nothing
05:27:54 <purplepenguins> is it a different signature?
05:28:02 <purplepenguins> @t dropWhile . sequence
05:28:03 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:28:03 <quicksilver> that is, your monad has to have a short-circuit effect
05:28:10 <purplepenguins> :t dropWhile . sequence
05:28:12 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
05:28:12 <lambdabot>     In the second argument of `(.)', namely `sequence'
05:28:12 <lambdabot>     In the expression: dropWhile . sequence
05:28:34 <purplepenguins> lambdabot is different than last i used it
05:28:57 <purplepenguins> :t dropWhile (True) . sequence
05:28:59 <lambdabot>     Couldn't match expected type `a -> Bool'
05:28:59 <lambdabot>            against inferred type `Bool'
05:28:59 <lambdabot>     In the first argument of `dropWhile', namely `(True)'
05:29:23 <purplepenguins> :t dropWhile (\_ ->True) . sequence
05:29:24 <lambdabot> forall a. [[a]] -> [[a]]
05:29:45 <purplepenguins> :t sequence
05:29:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:29:57 <Philonous1> :t dropWhile (==True) . sequence
05:29:58 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
05:29:58 <lambdabot>       Expected type: [Bool]
05:29:58 <lambdabot>       Inferred type: [[a]]
05:30:30 <purplepenguins> :t sequence . dropWhile (\_ -> True)
05:30:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:30:50 <purplepenguins> yeah, it should be fine to switch them
05:31:44 <purplepenguins> no wait, that m moved out of the [], that's not the same
05:34:10 <quicksilver> :t (fmap (dropWhile (\_ -> True)) . sequence
05:34:11 <lambdabot> parse error (possibly incorrect indentation)
05:34:16 <quicksilver> :t (fmap (dropWhile (\_ -> True))) . sequence
05:34:17 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => [f a] -> f [a]
05:34:26 <quicksilver> purplepenguins: that's what we're actually talking about
05:37:04 <purplepenguins> ah
05:37:08 <RayNbow> @pl (\_ -> True)
05:37:09 <lambdabot> const True
05:37:10 <purplepenguins> that would be more sensible
05:45:10 <bastl> @hoogle lines
05:45:10 <lambdabot> Prelude lines :: String -> [String]
05:45:10 <lambdabot> Data.List lines :: String -> [String]
05:45:10 <lambdabot> Data.ByteString.Char8 lines :: ByteString -> [ByteString]
05:45:58 <ike_> hey, 'www.haskell.org' seems down right now
05:47:46 <hackagebot> feed2lj 0.0.2 - Cross-post any RSS/Atom feed to LiveJournal (SergeyAstanin)
05:53:15 <quicksilver> http://www.downforeveryoneorjustme.com/www.haskell.org
05:53:20 <ike_> oops, the HaskellWiki stands up again, thanks
05:53:29 <quicksilver> :)
05:54:15 <xuei> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8317#a8319  this explicit recursion version looks working correctly... how dificult compositional style is...
05:54:36 <fasta> I have a datatype in which every constructor has a field named "index". I was under the impression that everywhere index would return at least _something_, but all it gives is a type error message. I already derived Typable.
05:55:02 <fasta> everywhere is a function from Data.Generics.Schemes
05:57:08 <fasta> Hmm, it seems that the type of everywhere is completely not what I expected it to be. Is there some generic function which applies index everywhere and simply collects the results in a list?
05:57:31 <quicksilver> yes, you need to use mkQ or mkQT or some incomprehensible short function
05:57:55 <quicksilver> everywhere (mkT index) -- perhaps this?
05:57:58 <lilac> fasta: everywhere doesn't collect the results
05:58:26 <fasta> lilac: yes, that's what I said with my last remark.
06:02:05 <jeffwheeler> @pl \a -> a { a = b }
06:02:05 <lambdabot> (line 1, column 9):
06:02:05 <lambdabot> unexpected "{"
06:02:05 <lambdabot> expecting variable, "(", operator or end of input
06:02:24 <jeffwheeler> @pl \a -> a { b = c } -- better, but still won't work
06:02:24 <lambdabot> (line 1, column 9):
06:02:25 <lambdabot> unexpected "{"
06:02:25 <lambdabot> expecting variable, "(", operator or end of input
06:04:01 <EvilTerran> fasta, what about Data.Generics.Schemes.listify?
06:04:08 <fasta> EvilTerran: already using it
06:04:23 <fasta> EvilTerran: I was just about to say that listify (const True) appears to work.
06:05:17 * quicksilver wonders if people who care about generics would like to explain to ashley yakeley why his proposed Data instance for Data.Fixed is totally broken.
06:06:14 <quicksilver> http://www.haskell.org/pipermail/libraries/2009-July/012137.html
06:06:19 <quicksilver> he didn't appear to see my point *at all*
06:08:38 <fasta> quicksilver: a generic traversal should be generic in the children of the same type, that's it, AFAIK. Breaking abstractions seems like a bad idea, yes.
06:09:41 <quicksilver> fasta: right. It's not part of the public interface of "Fixed" that it contains an Integer component
06:09:53 <mmorrow> fasta: you can hide stuff by making a limited/crippled Data instance
06:09:54 <quicksilver> so its Data instance should believe it is opaque, like any other basic type
06:10:04 <quicksilver> mmorrow: which is what ashley should do.
06:10:08 <quicksilver> but he doesn't see my point, at all.
06:10:14 <quicksilver> (see link posted above)
06:10:23 <fasta> Is Ashley a he?
06:11:06 <quicksilver> I believed so but I don't think I can substantiate that belief
06:11:37 <fasta> quicksilver: yes, he is.
06:11:44 <fasta> http://ashley.yakeley.org/
06:12:19 <Baughn> Isn't the correct unknown-gender singular pronoun "they"?
06:12:34 <mmorrow> they is plural
06:12:54 <Baughn> Sure, just like "you"
06:13:13 <mmorrow> you can be either both
06:13:17 <mmorrow> s/both//
06:13:33 <Baughn> http://en.wikipedia.org/wiki/They <-- Ah. Confirmed.
06:13:48 <mmorrow> (just a coincidence that 2nd plural and 2nd singular are the same word)
06:14:02 <fasta> "you" is quite a smart word in the English language, since it's both formal and informal.
06:14:24 <mmorrow> Baughn: i'm pretty sure that they being singular is a point of contention
06:14:32 * Baughn believed for a while that the formal second-person singular was "sir"
06:14:56 <fasta> In three other languages I know you have special words to designate "Oh, watch people, now I am going to say something very formal".
06:15:01 <Baughn> mmorrow: The article agrees. Still, that just means it's singular if enough people agree it is.
06:15:07 <mmorrow> Baughn: i know that it's considered incorrect to use "they" as 3rd person singular in writing (or so i was told)
06:15:18 <mun> i got a somewhat irrelevant question: how come some theorem provers only work for untyped first-order logic?
06:15:35 <fasta> mun: it's the most developed field of ATP.
06:15:40 <benmachine> mmorrow: people tell other people all sorts of things :P
06:15:47 <benmachine> I think they/them is fine
06:15:53 <mmorrow> english has no 3rd person singular neuter pronoun
06:15:55 <fasta> mun: and higher-order logics are undecidable.
06:16:00 <mun> fasta, why can't they work with typed FOL?
06:16:08 <mun> fasta, is typed FOL undecidable?
06:16:20 <benmachine> mmorrow: english has what english people say it has, and a significant number of them say they is ok
06:16:31 * benmachine is ok
06:16:44 <mmorrow> benmachine: that it's ok doesn't mean that it has it :)
06:17:23 <benmachine> I do not follow this logic
06:17:52 <benmachine> but you may well be right
06:17:55 <fasta> mun: I don't know by heart.
06:18:04 <mmorrow> "it's ok to use \"they\" as if it were the 3rd person neuter pronoun" vs "\"they\" is the third person neuter pronoun"
06:18:13 <Pthing> um
06:18:25 <Pthing> if you use it as a 3rd person neuter pronoun it's a 3rd person neuter pronoun
06:18:29 <mmorrow> benmachine: anyways, i don't particularly care one way or another of course :)
06:18:29 <Pthing> that's how grammar works
06:18:35 <dolio> Escaping quotation marks?
06:18:44 <arw> mmorrow: there is not a very large difference between those two in natural languages.
06:18:46 <dolio> You're supposed to use ' inside "s. :)
06:18:52 <mun> fasta, but isn't FOL undecidable?
06:19:02 <fasta> mun: mo, semi-decidable.
06:19:09 <fasta> mun: no*
06:19:13 <mmorrow> Pthing: sure, i meant personal pronoun
06:19:25 <Pthing> yes, it's still a personal pronoun
06:19:26 <mmorrow> arw: true
06:19:41 <fasta> mun: why are you asking btw?
06:19:42 <arw> often its just a matter of "the dictionary xy says so"
06:19:43 <mmorrow> Pthing: "I" is _the_ first person singular pronoun
06:19:51 <Pthing> it sure is
06:20:06 <mun> fasta, i'm just curious why a lot of the theorem provers out there tend to focus on untyped FOL
06:20:14 <mmorrow> Pthing: there is no other (?)
06:20:17 <benmachine> I used to think the OED agreed with me but I can't find it now so maybe I made it up
06:20:35 <fasta> mun: can you say in a few words what typed first order logic is?
06:20:51 <Pthing> certainly not, but "he", "she", "it" and "they" are all third person singular personal pronouns in any version of english worth writing
06:21:11 <fasta> mun: there are interactive theorem provers that work on higher-order logics.
06:21:14 <yaxu> > (pure "hello" :: Int -> String) 4
06:21:16 <lambdabot>   "hello"
06:21:31 <fasta> mun: and they are interactive, because the heuristics are not as good as human.
06:21:31 <yaxu> I'm having problems with this...  So '->' is a functor?
06:21:49 <mun> fasta, in which variables belong to domains.. x:N or something.
06:21:53 <mmorrow> Pthing: write^Wright, all i'm saying is that i don't think it's formally defined as such
06:22:06 <Pthing> there is no formal definition of english grammar
06:22:09 <mmorrow> Pthing: i use it all the time though
06:22:17 <fasta> mun: you can still express that in untyped first order logic.
06:22:18 <benmachine> Pthing: there are plenty but they're all inaccurate :P
06:22:29 <mmorrow> Pthing: :o
06:22:32 <Pthing> benmachine, hardly definitive then!
06:22:32 <yaxu> > (pure "hello" :: Int -> String) undefined
06:22:33 <lambdabot>   "hello"
06:22:36 <fasta> mun: I never used the qualifier untyped for first order logic, though.
06:22:38 <mun> fasta, right, then why is it called 'untyped'?
06:22:53 <fasta> mun: as I said, I have never seen this qualifier used before.
06:23:14 <fasta> mun: you are the one that introduced 'untyped' ;)
06:23:21 <benmachine> yaxu: there is an instance Functor ((->) t) in Control.Monad.Instances
06:23:33 <benmachine> (but pure is not a Functor method?)
06:23:45 <yaxu> I guess I meant applicative functor
06:24:01 <yaxu> I'm looking at the source for Control.Applicative now, illuminating thanks
06:24:10 <mun> fasta, i don't hear it very often too, but if you google "untyped first order" you'll get 400 or so returns. not very common, but still there.
06:24:46 <benmachine> yaxu: fwiw, ghci can tell you what instances are defined for a typeclass and where, with :info Applicative
06:24:53 <mun> fasta, or even http://eprints.ecs.soton.ac.uk/549/1/bbook.html one third way down
06:25:09 <yaxu> benmachine: ! thanks, didn't know that one, really handy
06:25:50 <fasta> Can SYB also do UUAGC like things? That is I want to have a chained attribute going from the left of the tree to the right of the tree.
06:26:29 <yaxu> so (-> a) is a class, mind boggling
06:27:00 <benmachine> I don't think it is
06:27:10 <mun> fasta, i suspect using untyped FOL is convenient because you won't need to define operators for each different type, since there's no polymorphism.
06:27:24 <yaxu> so what is it?
06:27:28 <mreh> how do import that accessor functions when I import a record data type?
06:27:43 <mreh> s/that/the/
06:28:19 <benmachine> well, I think (-> a) is different from ((->) a) for a start
06:28:46 <benmachine> as for what it actually is, a single-parameter type constructor I *think* but I'm not an expert
06:29:44 <yaxu> Ok, a datatype maybe
06:29:46 <fasta> Is an IntMap faster than a DiffArray?
06:30:11 <fasta> It should not be, but I don't know whether it actually isn't.
06:30:34 <Deewiant> DiffArrays are reputedly even slower than Arrays in practice
06:30:45 <Deewiant> So IntMaps should be noticeably faster, yes
06:31:24 <ray> benmachine: if (-> a) were legal, it'd be the opposite of ((->) a)
06:31:35 <ray> ((->) a) is like (a ->)
06:31:39 <mmorrow> fasta: IntMap is amazingly fast
06:31:47 <ray> (if type operator sections were legal, which they are not, but should be)
06:32:08 <benmachine> ray: so I thought
06:33:00 <dolio> DiffArray actually isn't that great.
06:33:06 <mmorrow> fasta: and for union i think it beats pretty much any data structure (iirc from the paper)
06:33:09 <mreh> When I import this data type "Options = Options { debug :: DebugLvl }"  into another module, I don't have the accessor method "debug" in scope
06:33:30 <mreh> using import Amodule (Options(Options))
06:33:39 <fasta> mmorrow: I am only interested in the read and write functions.
06:34:01 <dolio> The boxed DiffArray would be especially bad, due to garbage collection being O(n) in the array size after mutable array updates.
06:34:02 <benmachine> mreh: import Amodule (Options (Options, debug)) iirc
06:34:12 <ray> benmachine: with the TypeOperators extension on, you can define type operators besides ->, and use backticks on type constructors, but still no sections :(
06:34:13 <mreh> cheers, benmachine
06:34:45 <ray> if sections were allowed, maybe newbies would be less confused by those instances
06:34:46 <dolio> But even DiffUArray isn't that speedy, as I recall.
06:34:47 <mreh> benmachine, doesn't appear to work
06:35:01 <ray> it'd be a rare case where newbie coddling and making haskell better intersect
06:35:03 <ray> :)
06:35:19 <benmachine> ray: neat
06:35:35 <mmorrow> fasta: personally i'd use either IntMap or a mutable array
06:35:39 <benmachine> mreh: is it in Amodule's export list? what error are you getting?
06:35:57 <ray> usually newbie coddlers want to do evil things like make stuff monomorphic (cf. map)
06:36:15 <mreh> benmachine, sorted it now :)
06:36:15 <fasta> mmorrow: since this is not for a theoretical application where everything has to be optimal the first time, I will go for an IntMap.
06:36:57 <dino-> debug isn't really a function here.
06:37:19 <mmorrow> fasta: if IntMap was too slow/whatever for a particular task, i'd probably just write it in C to begin with
06:37:59 <fasta> mmorrow: by that logic one could just as well write everything in C to begin with. No need for FFIs either.
06:38:23 <mmorrow> fasta: http://moonpatio.com/repos/intmap-c/ ;)
06:39:04 <mmorrow> fasta: no just when haskell IntMap doesn't cut it (for whatever reason)
06:39:19 <fasta> mmorrow: do you already have a Haskell binding for it too?
06:39:23 <mmorrow> because i'd rather use C than haskell arrays
06:39:43 <fasta> mmorrow: even better would be an interface which can be used safely in a single-threaded way.
06:39:43 <mmorrow> fasta: no, although that's a good idea. it'd be interesting to compare to IntMap
06:40:09 <fasta> mmorrow: if it crashes when used in any other way, that would be fine, for me.
06:42:32 <yaxu> somehow Reader is implicated in this ((->) a) business
06:43:23 <quicksilver> Reader is just a name for ((->) a)
06:45:28 <user412> hey guys if your bored try facebook zombies :D - http://apps.facebook.com/zombies/links.php?r=719927515&nref=st
06:45:51 <skorpan> L-o-L
06:47:40 <flippeh_> Say I have a String "293898023", it being a unix timestamp, how do I make a ClockTime out of it?
06:49:31 <mmorrow> @type flip TOD 0 . read
06:49:34 <lambdabot> Not in scope: data constructor `TOD'
06:53:30 <yaxu> I'm having huge problems understanding the definition of (<*>) for patterns here http://ryani.livejournal.com/19471.html
06:56:14 <yaxu> I think what might help me is being able to find out the type of a particular part of an expression
07:10:14 <gwern> this is nice. with this new gitit plugin, I no longer need jsmath installed
07:10:17 <gwern> which frees like 80mb
07:10:21 <MarcWeber> nominolo: I found the cause. See my last commits.
07:10:34 <gwern> and makes my wiki more portable since I certainly wasn't going to commit 80mb of images
07:11:08 <wolverian> gwern: which plugin is that?
07:11:15 <gwern> texmath.hs
07:11:30 <nominolo> MarcWeber: "j"?
07:11:36 <wolverian> ahh, mathml
07:12:03 <MarcWeber> nominolo: j = joke ?
07:12:27 <nominolo> MarcWeber: that's your commit message
07:12:38 <MarcWeber> No!
07:13:12 <MarcWeber> nominolo: sorry. that belongs to the last one.
07:13:49 <nominolo> MarcWeber: you can use rebase and then push with -f, that'll override the old version
07:14:00 <MarcWeber> nominolo: I did so.
07:14:14 <gwern> wolverian: before if you wanted your tex rendered, you had to install jsmath and its 80mb of image files, which would render as images the tex client-side. this uses a little haskell library john wrote to compile tex to mathml
07:15:03 <wolverian> gwern: yar.
07:16:19 <nominolo> MarcWeber: ok, will pull
07:17:59 <MarcWeber> nominolo: Have you tried using scion from vim once now?
07:18:28 <nominolo> Not since the missing subprocess module error
07:22:19 <kw317> hello
07:22:20 <lambdabot> kw317: You have 1 new message. '/msg lambdabot @messages' to read it.
07:22:36 <saml> hi kw317
07:22:59 <kw317> I've been trying to use data-parallel haskell with ghc 6.10.4 and dph-seq and dph-par packages seem to be missing, any ideas why?
07:28:12 <Gracenotes> !botsnack
07:39:39 <Twey> Can anyone explain to me why this simple example causes a linker error?  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=3363#a3363
07:40:05 <Twey> (FFI with C)
07:42:42 <Makoryu> Twey: Did you actually put the whole function in the header file, with no corresponding .c file that gets compiled separately?
07:42:50 <Twey> Yeah
07:43:11 <Twey> The paste covers everything.  I don't have any other files or anything.
07:44:07 <Makoryu> I'm not familiar with Haskell's FFI (haven't needed to use it yet) but if I had to guess, this is a result of GHC trying to link the twice.hs object file to an object file that doesn't exist
07:44:35 <Twey> Well, I've got a twice.o after compiling
07:44:49 <Makoryu> Is that from twice.h, or twice.hs?
07:44:53 <chrisbrown> Twey: you need to put the implementation of twice into a C file and compile that into a library and then link against it
07:45:23 <Makoryu> chrisbrown: Hmm, it needs to be in a library already? It can't just link into the same binary?
07:45:27 <chrisbrown> a C library will be a .so (shared) or a .a (static)
07:45:45 <Twey> Ah, hmn.
07:46:24 <lilac> Twey: does it work with -fvia-c?
07:46:50 <Twey> I was working off of this, which doesn't seem to compile into a separate library or anything: http://www.haskell.org/haskellwiki/FFI_Introduction#Short_version
07:46:57 <chrisbrown> Twey:  check out http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
07:47:00 <lilac> Twey: also, i thought you could say c_twice :: CInt -> CInt and avoid the unsafePerformIO
07:47:17 <chrisbrown> oh - you want the opposite, sorry!
07:47:23 <Twey> lilac: Mm… no
07:47:49 <Twey> lilac: (about -fvia-c — I'll give the auto-IO a try, thanks!)
07:48:00 <jfoutz> yaxu: try just liftA2 (<*>) (const []) (const [])
07:48:33 <ray> snazzy
07:49:44 <jfoutz> I've been picking it apart the code for 20 min, but that seems to be the really tricky part.
07:50:06 <chrisbrown> Twey: try putting the implementation in a .c file, and compiling with the -fffi flag
07:50:10 <mmorrow> Twey: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=3363#a3364
07:50:18 <mmorrow> Twey: easy as pie :)
07:50:21 <Makoryu> :t liftA2 (<*>) (const []) (const [])
07:50:23 <lambdabot> forall b b1. b1 -> [b]
07:50:29 <Twey> chrisbrown: I'm using {-# LANGUAGE ForeignFunctionInterface #-}, which I believe is equivalent
07:50:55 <chrisbrown> I think the problem is not having a .c file
07:50:56 <mmorrow> Twey: you don't even have to give a foreign import a return type of IO, or use CInt/etc
07:51:03 <Twey> mmorrow: Wow, that's possible?  Sweet.  :-D
07:51:18 <ray> it's much easier that way
07:51:33 <mmorrow> Twey: and you need to pass the .c to ghc or to link to a .o you got with e.g. gcc foo.c
07:51:48 <mmorrow> *gcc -c foo.c
07:52:14 <mmorrow> and you can link/load arbitrary .o files into ghci with
07:52:20 <mmorrow> ghci -fobject-code foo.o
07:52:30 <ray> oh, that sounds good
07:52:35 <mmorrow> (then :load Foo.hs)
07:52:41 <mmorrow> which imports from foo.o
07:52:43 <ray> arbitrary .o files, drool
07:53:30 <mmorrow> yeah ghci's linker is handay
07:53:47 <Makoryu> That's incredibly slick
07:53:50 <Twey> mmorrow: So what exactly was causing the linker to get all shirty in my original example?
07:53:58 <ezyang> jfoutz: I missed the original question.  What does liftA2 (<*>) (const []) (const []) do?
07:54:34 <jfoutz> oh, almost an hour ago somebody was asking about this http://ryani.livejournal.com/19471.html
07:55:36 <mmorrow> Twey: ghc just ignored the .h and then ld couldn't find twice in any of the .o's ghc gave it
07:55:50 <jfoutz> the liftA2 ... takes 2 (Integer -> [a]) 's and glues them together
07:55:56 <ray> i'm guessing it got mad it wasn't in a .c file
07:55:56 <pao> > show "è"
07:55:59 <lambdabot>   "\"\\232\""
07:56:17 <Makoryu> > text "è"
07:56:19 <lambdabot>   è
07:56:42 <pao> Makoryu: text is from PrettyPrint, right?
07:56:42 <ezyang> jfoutz: The type signature seems terribly unuseful :-/
07:56:52 <ray> > text "⑨"
07:56:53 <Makoryu> pao: I actually don't know.
07:56:54 <lambdabot>   ⑨
07:57:03 <pao> @info text
07:57:03 <lambdabot> text
07:57:09 <pao> @where text
07:57:09 <lambdabot> I know nothing about text.
07:57:19 <ray> @hoogle text
07:57:20 <lambdabot> Text.PrettyPrint.HughesPJ text :: String -> Doc
07:57:20 <lambdabot> Text.XHtml.Transitional text :: String -> HtmlAttr
07:57:20 <lambdabot> Language.Haskell.TH.PprLib text :: String -> Doc
07:57:45 <pao> but text doesn't provide escaping features of show...
07:58:01 <ray> text isn't supposed to be show
07:58:12 <pao> ray:  yep...
07:58:16 <Makoryu> text $ cycle "\xe2\x80\xae"
07:58:18 <Twey> mmorrow: Ahh.  GHC only compiles .c's?
07:58:20 <Makoryu> Whoops
07:58:23 <jfoutz> ezyang: well, i wouldn't argue with that. I've been puzzling over "Pattern fs pf <*> Pattern xs px = Pattern (liftA2 (<*>) fs xs) (lcm pf px)" for a while
07:58:33 <mreh> @faq Can Haskell make me very happy in life?
07:58:33 <lambdabot> The answer is: Yes! Haskell can do that.
07:58:34 <ray> > text $ cycle "\xe2\x80\xae"
07:58:40 <lambdabot>   mueval-core: Prelude.read: no parse
07:58:40 <lambdabot>  mueval: ExitFailure 1
07:58:44 <ray> there, i crashed lambdabot
07:58:44 <jfoutz> ezyang: but simplifying down to that other version was enough for me to get it.
07:58:47 <pao> but how do I _show_ unicode chars?
07:58:55 <ray> pao: show?
07:59:03 <pao> > show 'è'
07:59:04 <lilac> Twey: looks like INCLUDE ... doesn't actually add a #include to the generated .hc file :(
07:59:04 <lambdabot>   "'\\232'"
07:59:10 <pao> > show "è"
07:59:10 <Axman6> > text "\xe2"
07:59:11 <lambdabot>   "\"\\232\""
07:59:12 <lambdabot>   â
07:59:22 <Twey> lilac: Aye
07:59:39 <alp2> hi. I'd like to evaluate a monad multiple times, accumulating its results with mplus. I also want to stop the accumulation when the (last) result satisfies a predicate. I've written a function doing that, but I suspect there is some library already providing the thing. Am I right?
08:00:04 <Twey> > text "ệ"
08:00:06 <lambdabot>   ệ
08:00:42 <EvilTerran> alp2, while it's commonly requested, i don't think such a thing exists
08:00:51 <Twey> pao: ‘show’ converts all non-ASCII chars into their escaped counterparts
08:00:56 <EvilTerran> ?type until
08:00:57 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
08:01:09 <lilac> liftA2 (<*>) is such an evil thing to do :-)
08:01:10 <pao> Twey: that is exactly what I would like to "disable"...
08:01:11 <Twey> pao: It's meant for debugging
08:01:28 <EvilTerran> alp2, i guess you're thinking of something like "untilM :: (a -> Bool) -> (a -> m a) -> a -> m [a]" ?
08:01:33 <ray> show isn't meant for pretty output
08:01:33 <Twey> I don't think you can disable it, and I don't think you'd want to
08:01:37 <alp2> EvilTerran: yes, exactly
08:01:37 <Twey> Right
08:01:54 <EvilTerran> yeah, there's no such thing that i know of. it's pretty easy to implement, tho.
08:01:57 <ray> show is meant for showing haskell values in a form that you could stick into a source file if you wanted
08:02:07 <Twey> Well
08:02:07 <pao> Twey: ray: ok
08:02:10 <alp2> EvilTerran: k, thx
08:02:15 <Twey> Haskell source files can do Unicode
08:02:29 <ray> yes, but maybe this particular source file is 7 bit ascii
08:02:31 <ray> :)
08:02:33 * ezyang kind of wishes that the default show instance for functions was their type signature. 
08:02:33 <Twey> It does the escaping because a lot of Unicode characters look alike, or can't be seen at all
08:02:44 <Twey> Which makes it really hard to debug
08:02:48 <ray> ezyang: you'd need a Typeable constraint or something
08:03:06 <Makoryu> Is there a special escape syntax for arbitrary Unicode characters?
08:03:12 <ray> yes
08:03:15 <ray> i forget it, but yes
08:03:19 <ezyang> ray: Typeable?
08:03:22 <jfoutz> ezyang: you know, i think it's not concatinating, it is just throwing away the second fuction list.
08:03:22 <EvilTerran> pao, where are you trying to show these unicode characters?
08:03:26 <alp2> EvilTerran: found something in monad-loops
08:03:26 <Makoryu> I thought there was but I can't seem to find it
08:03:31 <pao> Twey: thank you for the insight
08:03:43 <jfoutz> > (liftA2 (<*>) (const [const 1, const 2]) (const [const 3])) 4
08:03:44 <lambdabot>   [1,2]
08:03:48 <sioraiocht> Makoryu: '
08:03:50 <ray> ezyang: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
08:03:52 <ezyang> huh
08:04:04 <sioraiocht> Makoryu: '\xxx'
08:04:20 <pao> EvilTerran: prettyExp (UnquotedChunk s) = text . show $ s            .... that is obviously "wrong"...
08:04:20 <ezyang> ray: huh.
08:04:21 <Makoryu> sioraiocht: Isn't that limited to two hex digits?
08:04:23 <sioraiocht> > print '\60'
08:04:24 <lambdabot>   <IO ()>
08:04:29 <ezyang> jfoutz: Hmmmmm
08:04:32 <Makoryu> > text "\xffff"
08:04:33 <sioraiocht> Makoryu: no
08:04:34 <lambdabot>   �
08:04:39 <Makoryu> Oh, go figure
08:05:07 <ezyang> > (liftA2 (<*>) ([]) (const [const 3])) 4
08:05:08 <lambdabot>   Couldn't match expected type `[f a]'
08:05:11 <ray> > text "\fffe" -- :)
08:05:13 <lambdabot>   ffe
08:05:24 <ray> forgot my x, but whatever
08:05:27 <Makoryu> > text "\xfffe"
08:05:28 <lambdabot>   �
08:05:46 <ezyang> > (liftA2 (<*> (\x -> [const x]) (const [const 3])) 4
08:05:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:05:54 <sioraiocht> ray: you also treated it as a string instead of a character
08:05:54 <Makoryu> @let kryptonite = text $ cycle "\x489"
08:05:57 <lambdabot>  Defined.
08:06:01 <ray> :t text
08:06:03 <lambdabot> String -> Doc
08:06:05 <ezyang> (liftA2 (<*>) (\x -> [const x]) (const [const 3])) 4
08:06:06 <ray> that is why
08:06:14 <sioraiocht> ah
08:06:19 <ezyang> > (liftA2 (<*>) (\x -> [const x]) (const [const 3])) 4
08:06:23 <lambdabot>   [4]
08:06:28 <ezyang> Way
08:06:28 <ray> the other mistake i made was that it's actually feff :(
08:06:30 <jfoutz> > (liftA2 (<*>) (const []) (const [const 3])) 4
08:06:32 <lambdabot>   []
08:06:37 <mercury^> What's operators does one need to write every function pointsfree?
08:06:40 <ray> clearly i live in fail city
08:06:40 <Makoryu> > text "\xfeff"
08:06:42 <lambdabot>   ﻿
08:06:42 <lilac> > liftA2 (<*>) (pure.(+)) (enumFromTo 1) 7
08:06:44 <lambdabot>   [8,9,10,11,12,13,14]
08:06:50 <Makoryu> ¯\O_o/¯
08:06:55 <ezyang> O.o
08:06:58 <badsheepy> writing every function pointsfree would be kindof painful?
08:07:11 <ezyang> Back to the drawing board
08:07:11 <mercury^> It's not for practical purposes.
08:07:18 <mercury^> I just want a complete set.
08:07:22 <badsheepy> oh:)
08:07:23 <dolio> Tell that to the concatenative people.
08:07:48 <Makoryu> mercury^: You can't write *every* function point-free, but it sure helps to know your way around (.), (<$>), ap, and flip
08:08:20 <mercury^> So those 4 are enough?
08:08:28 <Makoryu> @pl \x -> not . any (\n -> f n x) primes
08:08:28 <dolio> You can write every function point free given a sufficient set of primitives.
08:08:28 <lambdabot> (not .) . flip any primes . flip f
08:08:33 <ezyang> "define enough"
08:08:35 <mercury^> Well, duh.
08:08:40 <dolio> Which, in the case of Haskell tuples, for instance, must be infinite.
08:08:43 <mercury^> I'm asking for a complete set of primitives.
08:08:51 <EvilTerran> mercury^, S, K, fix?
08:08:57 <absentia> good mornig guys/gals.  I'm still stuck trying to get my nodes to delete... I've even tried my best to make a copy ctor ... but i'm still getting a double free or corruption... and I have no clue what's going on in order to even start to fix it... I've worked for about an hour and a half making a test case for you guys and gals -- it's a bit large, but a sharp eye should be able to jump right to the critical issue -- I just don't know what it is.
08:08:57 <ezyang> heehee
08:09:04 <absentia> the code is here:  http://www.spy.org/tmp/dt.cpp    ....
08:09:06 <mercury^> EvilTerran: yes, that would work for example.
08:09:10 <absentia> er, sorry, wrong channel
08:09:15 <Makoryu> dolio: Nah, just curry the sectioned (,) operator
08:09:22 <mercury^> Other sets?
08:09:26 <Makoryu> Oh, and use lots of arrows
08:09:27 <EvilTerran> (plus constructors for any types you're using)
08:09:30 <Makoryu> mercury^: Learn arrows.
08:09:44 <mercury^> Makoryu: I think you're missing the point here.
08:10:14 <dolio> Makoryu: Well, if you use (a, (b, c)) instead of (a, b, c), you can do with fst, snd and (,). But once you have (a, b, c), you need fst3, snd3, thd3 and (,,). And so on.
08:11:23 <Makoryu> dolio: Yeah, it's a bit more inconvenient than SML's #2, #12, etc.
08:11:36 * ezyang likes how all intro literature to Haskell types very cleverly sidestep arrows by not talking about them outside of a function context 
08:13:29 <dolio> So, you need a list of primitive combinators based on what datatypes you allow, in addition to S, K and fix.
08:13:33 <Twey> I thought that was just because nobody ever used arrows except as shortcuts for composition and pair operations
08:13:57 <ray> arrows are cool
08:14:17 <Twey> Yet I have never yet found a situation where I thought, ‘oh, this makes an excellent arrow!’
08:14:20 <ray> i don't know why people talk about them as a generalizaion of monads when they are clearly a generalization of functions
08:14:28 <ray> that just happen to include kleisli arrows
08:14:35 <ray> happens
08:14:39 * ray fail city
08:15:32 <dolio> Because through Kleisli arrows, there is an arrow corresponding to every monad, but not vice versa.
08:15:49 <dolio> Although the connection is certainly less tight than with monads and applicatives.
08:15:54 <ray> but there is arr
08:16:46 <ray> anyway, kleisli arrows are just an instance of Arrow, which is like functions generalized to a typeclass
08:16:52 <ray> that's the view from here in fail city
08:17:23 <ray> speaking of fail city
08:17:29 <dolio> Arrows are morphisms in a particular class of categories (I think), just like functions. :)
08:17:47 * ezyang mumbles something about input/output 
08:18:46 <dolio> Which leads to the objection that Arrow is a bad name.
08:18:58 <dolio> Since "arrow" is another word for "morphism" in category theory.
08:19:18 <dolio> So you could say "Arrows are a particular subset of arrows."
08:19:27 <mercury^> EvilTerran: The downside of SK is that they have rather low entropy on practical problems. I was hoping someone here would suggest another set without that problem.
08:19:41 <ezyang> I kind of wish I knew where all these names came from.
08:19:59 <Makoryu> ezyang: Like "morphism" and "monad?"
08:20:09 <ray> category theory is where
08:20:11 <ezyang> Well, they're from Category Theory
08:20:13 <Makoryu> ezyang: I'm told they're fairly intuitive in category theory
08:20:18 <ezyang> But from inside there, where did they come from :-)
08:20:26 <ray> you could call a monad a kleisli triple if you like
08:20:33 <ray> that's got an obvious etymology
08:20:52 <ray> monad is i guess related to how it's a monoid object on the category of endofunctors? not sure
08:20:58 <dolio> mercury^: Well, once you have S and K, you sort of have everything. So anything you add is just for convenience, which is probably the factor you should look for.
08:21:08 <dolio> mercury^: Like, (.) is widely useful.
08:22:01 <mercury^> But surely S and K are redundant after enough useful combinators are added.
08:22:27 <mercury^> Since nobody here seems to know when I'll have to figure it out myself I guess.
08:22:35 <copumpkin> :o
08:22:35 <dolio> Only if you can write S or K in terms of the other combinators.
08:22:45 <mercury^> Of course.
08:22:49 <sjanssen> mercury^: const is pretty frequently useful
08:22:50 <dolio> lambdabot uses ap a lot, which is S.
08:23:05 <ray> const is K though
08:23:24 <fasta> Is there some library which derives a zipper for a given data type with all the expected operations?
08:23:32 <dolio> It could use 'liftM2 id' instead, and it often uses 'liftM2 f' for some f, so you could get rid of ap.
08:23:41 <ezyang> I feel like the question is barking up the wrong tree, but can't put my finger on it.
08:24:08 <ray> fasta: you know, i think there might be
08:24:59 <fasta> There is zipper on HackageDB, but does not give a good example of how it should be used.
08:30:09 <RayNbow> dolio, how is ap S?
08:31:11 <jfoutz> > ap(+) (+1) 2
08:31:13 <lambdabot>   5
08:31:33 <copumpkin> I wonder if simplereflect is smart enough
08:31:36 <copumpkin> > ap f g x
08:31:39 <lambdabot>   Ambiguous occurrence `x'
08:31:39 <lambdabot>  It could refer to either `L.x', defined at <local...
08:31:40 <ezyang> :t ap(+)
08:31:42 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
08:31:49 <copumpkin> > ap f g y :: Expr
08:31:50 <lambdabot>   Add a type signature
08:31:56 <pikhq> > ap const const 1
08:31:57 <lambdabot>   1
08:32:10 <ezyang> :t ap
08:32:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:32:22 <Asztal> :t (ap id id) (ap id id)
08:32:23 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
08:32:24 <lambdabot>     Probable cause: `id' is applied to too few arguments
08:32:24 <lambdabot>     In the second argument of `ap', namely `id'
08:32:29 <pikhq> :t ap const const -- Equivalent to SKK (equal to I)
08:32:31 <lambdabot> forall b. b -> b
08:32:37 <copumpkin> :t ap :: (a -> b -> c) -> (a -> b) -> a -> c
08:32:39 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
08:33:17 <EvilTerran> i think, as the haskell type system has a vague resemblance to simple types, you'd need fix as well as ap and const
08:33:45 <EvilTerran> RayNbow, it's specifically ap in the (e ->) Monad that's the S combinator
08:33:52 <RayNbow> yeah, I noticed
08:34:09 <RayNbow> after seeing a screen full of examples in this channel :p
08:34:12 <pikhq> EvilTerran: I prefer saying that ap is the S combinator generalised to the monads. :P
08:34:24 <EvilTerran> or that
08:35:00 * EvilTerran suspects there's some nice theoretical reason why S and K are <*> and pure for (e ->)
08:35:50 <EvilTerran> it strikes me as being somehow tied to the standard mapping from lambda-calc to SK-calc
08:38:41 <EvilTerran> [| (F X) |] = ([|F|] [|X|]); [| (\x. E) |] = (\\x. [|E|]) where (\\x. x) = I; (\\x. y) = y; (\\x. F X) = S (\\x.F) (\\x.X)
08:38:44 <EvilTerran> or whatever it is
08:39:06 <EvilTerran> (where [| EXP |] and (\\ VAR . EXP) are meta-syntax)
08:42:00 <fasta> What is the difference between "type family" and "data family"? (both syntax)
08:42:57 <copumpkin> same difference between type and data
08:45:34 <copumpkin> which also leads to the type functions defined by them being injective in the data family case and not with type families
08:45:48 <copumpkin> does newtype family work? :P
08:47:50 <lilac> copumpkin: no. for some reason you must write 'data family'
08:48:01 <copumpkin> :(
08:49:34 <lilac> fasta: rephrasing of what copumpkin said: if F x :: * is a data family, F x ~ F y => x ~ y, but not if it's a type family
08:51:59 <EvilTerran> copumpkin, although you can make a "newtype instance" for a "data family", iirc
08:52:02 <ray> kind family
08:52:08 <ray> dare i dream?
08:52:18 <copumpkin> ray: DON'T YOU DARE
08:52:24 * copumpkin whips ray and insists drong is a cat
08:52:54 <ray> i think we need kind, newkind, and metadata keywords
08:53:21 <copumpkin> then we need kindclasses, and sorts, as the type of kinds
08:53:26 <copumpkin> ;)
08:53:41 <copumpkin> or we could just go with Set, Set_1, Set_2, etc.
08:53:51 <mercury^> Hmm, my ghci fails with "    cannot parse LANGUAGE pragma: comma-separated list expected" on programs that used to compile before.
08:53:51 <idnar> oh dear
08:53:56 <ray> i think coming up with names is more fun
08:54:03 <copumpkin> mercury^: what's your LANGUAGE pragma?
08:54:34 <mercury^> PArr, MultiParamTypeClasses, FlexibleInstances in one case, ExistentialQuantification in the other
08:54:54 <copumpkin> mercury^: what's the actual line?
08:55:09 <mercury^>     LANGUAGE ExistentialQuantification
08:55:35 <copumpkin> that's odd
08:56:41 <lilac> mercury^: are the {-#. #-} on the same line?
08:56:50 <mercury^> No.
08:57:00 <mercury^> Do they now have to be?
08:57:09 <copumpkin> it accepts them on separate lines for other pragmas
08:57:17 <copumpkin> but maybe they do
08:57:19 <lilac> i have no idea, but that's the only obvious difference between what you have and what works for me in 6.10.4
08:57:53 <mercury^> Well, ok, that worked.
08:58:06 <mercury^> Seems like an odd thing to change though.
08:58:18 <mercury^> Old behaviour let you format it nicely.
08:58:26 <lilac> wow
08:58:52 <copumpkin> mercury^: maybe file a bug or ask in #ghc?
08:58:55 <lilac> i get a 'ghc: panic!' from not putting the {-# and #-} on the same line on 6.10.3
08:58:55 <quicksilver> ray: SPJ is planning datakinds.
08:59:03 <quicksilver> ray: not quite kind families though
08:59:21 <ray> well, anything to help our impoverished kind system
08:59:42 <lilac> like so: "{-#\n  LANGUAGE ExistentialQuantification\n#-}\n\nmain = undefined"
09:00:07 <quicksilver> lilac: sounds like one for a trac report
09:01:19 <lilac> just as soon as firefox stops dying :)
09:02:37 * EvilTerran vaguely recalls it working if every line after the first is indented more than it
09:02:52 <EvilTerran> {-#\n    LANGUAGE ...\n    #-}
09:03:54 <ray> lilac: use a command line tool to download a better browser, you don't need to even start firefox for that
09:03:58 <ray> :)
09:05:00 <benmachine> what do you use?
09:05:09 <benmachine> I used to use midori
09:05:12 <ray> opera
09:05:16 <benmachine> but I got bored of it not working
09:05:25 <benmachine> so I tend to start firefox nowadays
09:05:32 <lilac> ray: or use a command-line tool which /is/ a better browser? :)
09:05:37 <ray> or that!
09:05:38 <benmachine> I tried opera a bit but never got the hang of it
09:05:45 <benmachine> habit has momentum I suppose
09:05:47 <ray> command line browsing kinda sucks though
09:05:54 <lilac> EvilTerran: yeah, that fixes it too
09:06:10 <ray> but i am distinguishing between command line and terminal based here
09:06:16 <ray> it is an important distinction
09:07:09 <jfoutz> yeah, it's ed vs vi
09:07:50 <arw> command line based would also work over a line printer, terminal based wouldn't.
09:08:18 <arw> so if you could imagine using a line printer any time soon, the choice is clear :)
09:08:22 <ray> well,it would, sorta
09:08:33 <ray> you would get tons of garbageon your printer
09:13:50 * copumpkin loves writing his programs with undefined . f . g
09:15:45 <benmachine> how does that work
09:15:54 <ray> > undefined "help me"
09:15:56 <lambdabot>   * Exception: Prelude.undefined
09:15:56 <jmcarthur_work> it doesn't
09:16:08 <ray> undefined :: a, so it works just fine
09:16:30 <benmachine> ray: you mean, it breaks just fine :P
09:16:40 <ray> nothing broken there
09:16:41 <endojelly> it's a good placeholder
09:16:42 <copumpkin> benmachine: I use it to write the programs iteratively and make sure everything compiles up to a point
09:16:47 <ray> it does exactly what it should
09:16:49 <benmachine> ah I see
09:16:57 <ray> it typechecks and behaves as expected
09:16:58 <endojelly> I didn't know Haskell has a undefined. thanks, copumpkin
09:17:01 <copumpkin> or rather, everything typechecks up to a point
09:17:03 <ray> where is the broken part?!
09:17:15 <jmcarthur_work> ray, i only meant that undefined . f . g doesn't do anything more useful than just undefined
09:17:26 <benmachine> ray: depends what you mean by broken, naturally
09:17:28 <copumpkin> except allow you to typecheck f . g in its context
09:17:32 <jmcarthur_work> besides allowing the type checker to check f . g (which is the point)
09:18:04 <ray> benmachine: undefined is supposed to error out, and it does
09:18:05 <benmachine> when something designed with builtin obsolescence breaks, it isn't working correctly
09:18:11 <benmachine> or at least, that's what I'd argue
09:18:18 <copumpkin> ?
09:18:27 <ray> it's much better than my destroyUniverse in that regard
09:18:38 <ray> which is supposed to destroy the universe, but errors out
09:18:49 <copumpkin> onoes
09:19:02 <endojelly> ray, oh that sucks :(
09:19:03 <ray> equivalent in terms of program semantics, but not the same
09:19:03 <jmcarthur_work> _|_ is not really an error unless an IO action tries to use it
09:19:57 <Gracenotes> GHC, in its gloriousness, examined your sinister IO action and decided not to execute it
09:20:23 <ray> no, i implemented it like that because i don't have a large hadron collider
09:20:24 <jmcarthur_work> glorious!
09:20:33 <endojelly> Gracenotes, sinister? dude! it's better to destroy the universe than to bail out. that may cause problems!
09:20:53 <ray> nope, semantically they're both _|_
09:20:56 <jmcarthur_work> yeah, better to start with a fresh universe
09:21:15 <Gracenotes> next time, turn off the evil bit
09:21:28 <endojelly> I mean, seriously, some other software components may rely on the universe being invariantly destroye
09:21:29 <ray> maybe i'll write cern
09:21:32 <endojelly> d
09:22:29 * jfoutz wonders how many universes ray destroyed debugging his method.
09:22:48 <benmachine> probably the same number of IRC clients that I wrote while debugging mine
09:23:02 <lilac> jfoutz: i'm guessing precisely one. once it's successfully destroyed a single universe, it's finised :)
09:24:09 <ray> well, i don't have the hardware yet
09:24:12 <ray> so zero
09:24:25 <ray> annoying how something so conceptually simple requires specialized hardware
09:24:28 <endojelly> I want universe polymorphism
09:24:36 <ray> the only other thing i know of is random generation
09:24:46 <jmcarthur_work> lilac, nah. all ray has to do is reconstruct an identical copy of the universe to try again
09:24:52 <ray> and you can fake that much more convincingly than i faked universe destruction :(
09:25:06 <jfoutz> well, with many worlds, you'd have the hardware already in *some* of them.
09:25:18 <Gracenotes> There is a theory which states that if ever anybody discovers exactly what the Universe is for and why it is here, it will instantly disappear and be replaced by something even more bizarre and inexplicable. There is another theory which states that this has already happened.
09:25:19 <endojelly> jfoutz, or rather... had.
09:25:20 <jeffersonheard> anyone have any tips on how to reduce garbage collection?  My program, awesome as it is, is doing exactly as I expected.  117% of the time spent in the program is spent in garbage collection
09:25:24 <jeffersonheard> unacceptable
09:25:24 <Gracenotes> (/adams)
09:25:31 <jfoutz> endojelly: both.
09:25:38 <jmcarthur_work> jeffersonheard, what is the program?
09:25:53 <endojelly> jfoutz, with many worlds, in some universes he just found it. here. while talking to us.
09:26:00 <Gracenotes> 117 ... ... %?
09:26:07 <quicksilver> jeffersonheard: increase the size of the default whatsit.
09:26:11 <quicksilver> allocation area, or somethign
09:26:14 <quicksilver> I forget the right term.
09:26:29 <jeffersonheard> The Big Board.  Finally given the go ahead to open-source it, too
09:26:31 <quicksilver> +RTS -A10M or some such.
09:26:33 <jeffersonheard> working on documenting the source
09:26:44 <quicksilver> (and see if that changes the time spent in GC)
09:26:50 <jeffersonheard> quicksilver: thanks
09:26:58 <quicksilver> try different numbers, obvoiusl
09:27:12 <mercury^> Is a 4 line paste ok here?
09:27:32 <jmcarthur_work> i'd say it's an upper bound
09:28:19 <mercury^> Ok, I'll go ahead then. This fails to compile for me:
09:28:32 <mercury^> data SourceTree t = Already t | forall s. Apply (SourceTree (s -> t)) (SourceTree s)
09:28:36 <mercury^> compile (Already a) = a
09:28:37 <mercury^> compile (Apply f b) = (compile f) (compile b)
09:29:42 <jmcarthur_work> what's the error?
09:29:46 <jfoutz> can't construct infinite type?
09:29:48 <jeffersonheard> ideally, though, I'd like to generate less garbage
09:29:51 <mercury^> The quantifier seems to confuse GHC here. One can change the RHS of the last line to compile b and it still fails.
09:30:12 <mercury^> Yes, infinite type. But when one changes the last line a bit one also gets other errors.
09:30:18 * jmcarthur_work tries it locally
09:30:27 <Makoryu> @pl \n -> takeWhile (< n) p
09:30:28 <lambdabot> flip takeWhile p . flip (<)
09:30:29 <mercury^>     Inferred type is less polymorphic than expected
09:32:34 <jmcarthur_work> mercury^, give compile an explicit type signature and it works
09:32:43 <jmcarthur_work> monomorphism restriction
09:33:03 <mercury^> Hmm, weird.
09:33:05 <mercury^> Thanks.
09:34:22 <ray> i first realised something was amiss when all my programs failed to compile with the error "Doesn't occur check: cannot construct finite type".
09:34:22 <Cale> ehehe, if I'm gone long enough, people have conversations about what I would say ;)
09:34:27 <jmcarthur_work> oh weird, with NoMonomorphismRestriction it gives infinite type
09:34:39 <jmcarthur_work> well, if you also remove the type signature
09:34:40 <ray> if cale didn't exist, we would have to invent him
09:35:15 <mercury^> ray: :>
09:38:17 <lilac> mercury^: looks like a possible GHC bug. it might be worth reporting.
09:38:34 <mercury^> I sure uncover a lot of bugs today. :)
09:38:46 <mercury^> Well, not sure if it's a bug in this case.
09:38:59 <mercury^> Someone with a deeper understanding might be able to comment?
09:43:40 <mercury^> Are there any introspection capabilities in GHC?
09:44:20 <dolio> It's probably not a bug, per se, but the fact that existential quantification doesn't allow for type inference that's as good as you'd normally expect.
09:44:41 <dolio> Oh, wait, no.
09:44:45 <jfoutz> what prevents (compile b) from returning an apply?
09:44:48 <jmcarthur_work> seems a bug to me
09:44:50 <dolio> It's just the usual problems with polymorphic recursion.
09:45:04 <dolio> Polymorphic recursion requires a type signature.
09:45:05 <jmcarthur_work> really?
09:46:09 <mercury^> Umm, I can define length without a signature at least.
09:47:07 <dolio> You may be able to construct examples where you get a reasonable type, but in general, type signatures are required.
09:47:55 <dolio> @type let foo l = foo (map (const ()) l) in foo
09:47:57 <lambdabot> forall t. [()] -> t
09:48:03 <ManateeLazyCat> dcoutts: How to move cursor to special cell that given Y coordination? I use "treeViewGetPathAtPos treeView (0, y)" got TreePath, then use use "treeViewSetCursor treeView path Nothing" to place cursor to special TreePath, but looks not correct effect i want.
09:48:13 <dolio> That is not as polymorphic as possible, for instance.
09:48:22 <jfoutz> i think this is an example of a problemantic case: Apply (Int -> Char) (Apply (Char -> [Char]))
09:48:58 <dolio> @type let foo :: [a] -> t ; foo l = foo (map (const ()) l) in foo
09:49:00 <lambdabot> forall a t. [a] -> t
09:49:16 <mercury^> jfoutz: the second apply is missing one type.
09:49:58 <mercury^> And even then it couldn't be right at all.
09:50:13 <lilac> dolio: is the problem that there aren't principle types, or just that GHC can't find them, in these cases?
09:50:25 <ManateeLazyCat> I want make scroll TreeView, and i try to keep cursor at first line of TreeView view area when cursor is less top Y coordination of TreeView view area.
09:50:33 <dolio> So, when you write compile without a type signature, it tries to unify the types of "compile (Apply f b)" "compile f" and "compile b", and fails.
09:52:12 <dolio> lilac: "forall a t. [a] -> t" is a principle type for that function, I think. But infering types for polymorphic recursion is tricky business, at least.
09:52:35 <dolio> ML doesn't allow polymorphic recursion at all, for instance.
09:52:40 <dolio> I think, that is.
09:52:47 <endojelly> so.. anyone here speaking vietnamese?
09:53:43 <dolio> Principal type, even.
09:54:02 <Cale> endojelly: Any particular reason?
09:54:48 <endojelly> Cale, a vietnamese friend wrote me a short message in vietnamese. i want to read it... and also answer 8)
09:55:11 <ManateeLazyCat> endojelly: Google transformer?
09:55:44 <endojelly> ManateeLazyCat, that doesn't translate it very well into english... and must be horrible into the other direction
09:56:39 <Cale> endojelly: I know someone on IRC who speaks viet, but she's not online at the moment.
09:56:50 <ManateeLazyCat> endojelly: Can't understand vietnamese. :)
09:57:58 <endojelly> Cale, ooh. can you tell me when she's online, so that you can relay the message to her? it's pretty short, and it's okay if she doesn't want to, but I guess it's worth a try
09:58:07 <mercury^> I always used to be an advocate of static typing, but recently I find myself in situations where dynamic typing would make things so much easier.
09:58:09 <Cale> endojelly: I'll try to remember
09:58:29 <endojelly> Cale, thanks!
09:58:40 <endojelly> mercury^, for example?
09:58:50 <endojelly> (but, yes, static typing has downsides)
09:59:12 <mercury^> For example right now I want to randomly replace functions with other functions of the same type.
09:59:31 <mercury^> Without knowing the type of the selected function in advance.
09:59:51 <endojelly> I think it's incredibly obvious when working with proof-driven development using dependent types. that takes ages and can be exhausting. BUT your programs are really, really correct
09:59:59 <endojelly> so it's a tradeoff, it depends on what you want
10:00:06 <endojelly> but that's really nothing new 89
10:00:07 <endojelly> 8)
10:00:10 <endojelly> -89
10:00:43 <ManateeLazyCat> mercury^: I use Typeable with class interface for dynamic typing check
10:01:01 <ManateeLazyCat> mercury^: Class for generic methods, Typeable for speical methods.
10:02:11 <mercury^> ManateeLazyCat: thanks, I'll have a look at those.
10:02:37 * ManateeLazyCat pasted "PageBuffer.hs" at http://paste2.org/get/387412
10:02:40 <ManateeLazyCat> mercury^: Look above.
10:02:53 <ManateeLazyCat> mercury^: That's my example code,
10:03:17 <ManateeLazyCat> mercury^: All type that use PageBuffer class can implement those generic methods.
10:03:34 <dbpatterson> is anyone here familiar with UrlDisp? It's a url dispatching library for CGI, and I'm trying to do something with it that seems possible, but I can't manage to get working
10:04:23 <ManateeLazyCat> mercury^: When you want implement speical methods for speical type that PageBuffer not support, you just need implement those methods, then use `cast` function to dynamic type check.
10:05:07 <ManateeLazyCat> mercury^: And you just need write "deriving Typeable" after data declare.
10:05:52 * ManateeLazyCat pasted "Speical methods for special type of PageBuffer class." at http://paste2.org/get/387418
10:06:06 <ManateeLazyCat> mercury^: Above is speical method apply functions.
10:06:15 <ManateeLazyCat> `diredBufferApplyFocus`
10:06:57 <dbpatterson> or, alternatively, are people willing to try to understand code using a library they have never seen? (it mainly has to do with Applicative/Alternative stuff)
10:07:19 * ManateeLazyCat Some damnit TreeView problem block me, but nevermind, i will fix it!
10:08:23 <Berengal> dbpatterson, just paste the code. If anyone can help, they'll answer
10:10:05 <dbpatterson> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8333#a8333 - the intention is to somehow be able to discard the rest of the parse tree and return a result instantly. among other things it is relevant for authentication, where a redirect to login page is useful, but otherwise parsing should continue
10:13:14 <nathanic> what does 'import {-# source #-} Modulename' do?
10:13:38 <Berengal> nathanic, it's a boot module, used to break cyclic module dependencies
10:16:14 <nathanic> ok, thanks.  had no idea there was a provision for breaking cycles.
10:16:37 <Berengal> dbpatterson, I'm completely unfamiliar with hack. What's output?
10:16:40 <Berengal> The type, I mean
10:16:43 <mercury^> ManateeLazyCat: argh, that all doesn't seem to work with polymorphic types.
10:17:20 <dbpatterson> output returns a CGIResult
10:17:35 <Berengal> dbpatterson, just 'CGIResult'?
10:17:36 <dbpatterson> basically output (s::String) is just a hello world cgi result
10:17:48 <Berengal> It has to be in a monad, doesn't it?
10:18:00 <dbpatterson> yeah, in the cgi monad
10:18:00 <Berengal> or you couldn't 'o <- output s'?
10:18:07 <dbpatterson> sorry
10:18:26 <Berengal> Ah, so (MonadCGI m) => String -> m CGIResult?
10:18:53 <dbpatterson> yes; though it may be a typeclass of which String is an instance
10:19:04 <Berengal> Ah, okay
10:19:27 <Berengal> how about 'redir s m = do {o <- output s; m; return o}'?
10:19:31 <Berengal> Does that do what you want?
10:20:00 <Berengal> (At least it should match the type signature for redir)
10:20:09 <dbpatterson> would that prevent it from continuing on the parse tree?
10:20:31 <dbpatterson> (Unfortunately I'm not on my main machine, so I'll have to test it later)
10:20:45 <Berengal> it'll still perform m...
10:21:38 <dbpatterson> is there any way for it to not perform the rest? that's why I was trying to use <* (which I'm under the impression discards the second argument, which in theory could be the rest, right?)
10:21:53 <Berengal> <* still performs the rest, but discards the result..
10:22:08 <Berengal> > [()] <* [1..10]
10:22:10 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
10:22:31 <Berengal> you could do 'redir = const' :P
10:22:41 <Berengal> Well, almost
10:22:48 <mercury^> Where is <* defined?
10:22:48 <lilac> dbpatterson: the nature of Applicative is that the value(s) contained are dynamic, but the effects are static
10:22:53 <jmcarthur_work> Control.Applicative
10:22:56 <Berengal> redir = output . const
10:24:03 <Berengal> I use <* alot when I need to do something like 'do {line <- getLine; putStrLn "Thanks for the input"; return line}'
10:24:07 <lilac> dbpatterson: <* combines the 'effects' of two applicatives, but uses the values from the LHS one
10:24:13 <mercury^> Does anyone know if there's a way to make Typeable and Dynamic work with polymorphic types?
10:24:20 <Berengal> That could be rewritten 'getLine <* putStrLn "Thanks for the input"'
10:24:46 <dbpatterson> lilac: that is (I think) what I want to be doing
10:25:23 <jmcarthur_work> perhaps confusingly, <* performs the effects in left to right order
10:25:31 <jmcarthur_work> the notation always throws me off
10:25:37 <dbpatterson> it isn't important that the second applicative is not run, just that the result is unused. because (If I understand the library correctly) when the results are 'empty' it backtracks on the parse tree
10:26:11 <Berengal> dbpatterson, well if there's no difference, why run it in the first place?
10:27:36 <dbpatterson> Berengal: the example is a little simplified, but I would like it to have the auth section be connected to the redirect - so if you are already authenticated, it just just a return (), if you are NOT, redirect to the login page (which may be able to be return (output something) - I dont know)
10:28:14 <Berengal> dbpatterson, I assume |/ is some sort of alternative?
10:28:35 <dbpatterson> it means match the next string as a part of the path
10:28:48 <dbpatterson> so there is a path wrapped up in State
10:29:00 <dbpatterson> if it matched, it returns (), if it doesnt match, it returns empty
10:29:03 <dbpatterson> matches*
10:29:27 <dbpatterson> sorry, doesnt return, just empty's
10:29:30 <mmorrow> , runST (do x <- newSTRef 0; writeSTRef x 1 <* writeSTRef x 2; readSTRef x)
10:29:32 <lunabot>  2
10:29:46 <Berengal> Ah, so 'h |/ "hello" |/ "World"' would match 'example.com/hello/World'?
10:30:02 <dbpatterson> yes
10:30:15 <Berengal> And if it matches, run auth?
10:30:16 <dbpatterson> and should it match, it will run what's after *>
10:30:23 <dbpatterson> yeah
10:30:25 <Berengal> And if auth fails, goto login, else goto app
10:30:35 <dbpatterson> yes, but thats the part that I dont know how to do
10:30:47 <dbpatterson> so I was trying to do the simple case - redirect every time
10:31:14 <dbpatterson> I can actually simplify that a lot; it's unnecessarily complicate
10:31:17 <dbpatterson> d
10:31:23 <edwardk_> , runST (do x <- newSTRef 0; writeSTRef x 1 *> writeSTRef x 2 *> readSTRef x)
10:31:25 <edwardk_> ;)
10:31:25 <lunabot>  2
10:31:58 <jmcarthur_work> @pl \x -> writeSTRef x 1 *> writeSTRef x 2 *> readSTRef x
10:31:58 <Berengal> how about something like 'h |/ "hello" |/ "World" >> ((auth ("user", "password") >> app) <|> login)'
10:31:58 <lambdabot> ap ((*>) . ap ((*>) . flip writeSTRef 1) (flip writeSTRef 2)) readSTRef
10:32:14 <Berengal> And have auth return empty
10:32:17 <edwardk_> *> is basically >> for applicative
10:32:34 <mmorrow> , runST (do x <- ref 0; (x.=1) <* (x.=2); (x!))
10:32:36 <lunabot>  luna: Ambiguous occurrence `!'
10:32:41 <mmorrow> sigh
10:33:27 <mreh_> :t if
10:33:28 <lambdabot> parse error (possibly incorrect indentation)
10:34:02 <mmorrow> , runST (do x <- ref 0; (x.=1) <* (x.=2); val x)
10:34:03 <lunabot>  luna: Ambiguous occurrence `val'
10:34:08 <mmorrow> gah!!!
10:34:21 <jmcarthur_work> am i the only one weirded out by the fact that a <* b looks like a is being "applied" to b somehow (somewhat like =<< or <=<) and yet its effect is performed first?
10:34:23 <dbpatterson> Berengal: hmm... for some reason I thought I had considered that and found a case where it wouldnt work, but I can't remember how, and it IS a much simpler solution.
10:34:23 <mmorrow> what the frig is val from?
10:34:33 <edwardk_> , runST (mdo x <- newSTRef 0; writeSTRef x 1 <* writeSTRef x 2; readSTRef x)
10:34:35 <lunabot>  2
10:34:40 <edwardk_> , runST (mdo x <- newSTRef 0 <* writeSTRef x 1 <* writeSTRef x 2; readSTRef x)
10:34:42 <mmorrow> , deref
10:34:43 <lunabot>  luna: out of memory (requested 2097152 bytes)
10:34:43 <lunabot>  luna: Not in scope: `deref'
10:34:46 <edwardk_> aw
10:34:56 <dbpatterson> Berengal: thanks.
10:35:09 <Nigbjort> Read Chimp Out's Official Appology to the Feral Negro Beast!  http://chimpout.com/forum/showthread.php?t=31766    We appologize here for all the bad we have done them!  At Chimpout.com we are not White Supremacist, rather we are Negro Inferiorists!   We welcome all non-negroid races.  Critera for joining: non-negroid, and hates niiggggggers!
10:35:26 <jmcarthur_work> @where ops
10:35:26 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
10:35:33 <Berengal> dbpatterson, heh, I'm just guessing here. I haven't used hack so I don't know its semantics
10:35:35 <mmorrow> , runST (do x <- ref 0; (x.=1) <* (x.=2); deref x)
10:35:37 <lunabot>  2
10:35:56 --- mode: ChanServ set +o glguy
10:36:02 --- mode: glguy set +b %Nigbjort!*@*
10:36:05 <edwardk_> mmorrow: what is ref/deref in?
10:36:08 * mmorrow couldn't take writeAShortNovelWithThisIdentifierST x anymore
10:36:15 <edwardk_> heh
10:36:22 <mmorrow> edwardk_: just defined them as
10:36:27 --- mode: glguy set +b *!*@201.171.100.192
10:36:37 <edwardk_> mmorrow: was curious if you had some kind of MonadRef floating around.
10:36:39 <glguy> oh, ok
10:36:54 <mmorrow> ref=newSTRef; (.=)=writeSTRef; (!)=readSTRef
10:36:56 --- mode: glguy set -bb *!*@201.171.100.192 %Nigbjort!*@*
10:36:59 --- mode: glguy set -o glguy
10:37:03 <mmorrow> (although i had to use deref instead of (!))
10:37:12 <mmorrow> the (!) is nice in postfix
10:37:40 <edwardk_> mmorrow: ref and deref are pretty good
10:37:41 <EvilTerran> mmorrow, i tend to use (?) as the postfix read<...>Ref
10:37:44 <mmorrow> x <- ref; (x .=) . (+1) =<< (x!); (x!)
10:37:46 <Berengal> jmcarthur_work, rather, I'm somewhat weirded out by =<< applying it's /right/ effects first.
10:38:00 <Berengal> But anything else would be sort of impossible
10:38:05 <edwardk_> Berengal: yeah
10:38:08 <mmorrow> edwardk: yeah, deref is not bad on second though
10:38:09 <mmorrow> t
10:38:09 <jmcarthur_work> Berengal, i find it natural because it passes the result of those effects to the left
10:38:29 <mmorrow> EvilTerran: i like (!) since it's like the sml
10:38:53 <jmcarthur_work> anyway, i would like <* better if it didn't point as though it had something to do with right-to-left control flow
10:38:56 <mmorrow> x = ref 0; x := 1; !x
10:39:05 <EvilTerran> mmorrow, ah, i see; i chose ? because "(x?)" looks like you're asking about x
10:39:09 <Berengal> jmcarthur_work, in a way, but effects aren't values. Values flow freely in all directions, effects are one-directional
10:39:19 <jmcarthur_work> Berengal, exactly
10:39:30 <jmcarthur_work> Berengal, <* points to the left but the effects don't go in that direction
10:40:18 <Berengal> And since the .*. operators are effectfull, and effects by default (in my version of the universe) go from left to right, only the direction of values is neccessary
10:40:35 <jmcarthur_work> i think we are both contradicting ourselves
10:41:36 <jmcarthur_work> your contradiction is saying that values have direction right after saying they do not, and mine is... i guess more of an ambiguity than a contradiction... that effects have direction at all
10:42:04 <jmcarthur_work> i suppose neither have direction
10:42:05 <jmcarthur_work> but effects do have an ordering
10:42:05 <jmcarthur_work> while values do not
10:42:15 <jmcarthur_work> i would prefer that the operators indicate the ordering of effects better
10:42:36 <Berengal> jmcarthur_work, order is a better term. Anyway, I said "results of effects", by which I meant values...
10:42:43 <jmcarthur_work> right
10:43:30 <Berengal> So I see no contradiction there. Anyway, values have a sort of ordering as well in their dependencies (which may be circular)
10:43:59 <jmcarthur_work> okay, dependency ordering vs. effect ordering. good terms to standardize on for this
10:44:24 <Berengal> And that is what the arrow indicates. Effects can only have one ordering, which is left-to-right (on a timeline, not neccessarily on text)
10:44:32 <Berengal> ((but it should be on text as well))
10:45:36 * jmcarthur_work mulls
10:46:38 <jmcarthur_work> i don't like data dependencies and effects going in opposite directions
10:46:39 <Berengal> It's sort of the same reasoning behind why mdo doesn't rearrange effects order just to make sure all variables are bound before they are used
10:46:56 <mmorrow> , let for (i,p,inc) f = let go i = do f i; let o = inc i; when (p o) (go o) in runST (do acc <- ref 0; for(0,(<9),(+1)) (\i-> do{x <- deref acc; acc.=(x+1)}); deref acc)
10:46:57 <lunabot>  luna: parse error on input `in'
10:47:04 <jmcarthur_work> ugh, i used "going" in "directions" again
10:47:05 <Berengal> jmcarthur_work, unfortunately, you can't do anything about that. You can't write a version of <* that doesn't have that property
10:47:07 <c_wraith> Berengal, did you just claim time can only move forward?  You're ruining my time travel dreams, again.
10:47:16 <mmorrow> , let for (i,p,inc) f = let go i = do f i; let o = inc i; when (p o) (go o) in go i in runST (do acc <- ref 0; for(0,(<9),(+1)) (\i-> do{x <- deref acc; acc.=(x+1)}); deref acc)
10:47:17 <lunabot>  luna: parse error on input `in'
10:47:31 <jmcarthur_work> Berengal, sure you can.  flip (>>)
10:47:40 <Berengal> c_wraith, fortunately, values can go backwards in time. Time, the effect, can only go forward though
10:47:48 <Berengal> jmcarthur_work, that's not the same
10:47:55 <jmcarthur_work> Berengal, that's the point
10:48:02 <Berengal> > [()] <* [1..10]
10:48:05 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
10:48:22 <jmcarthur_work> Berengal, it gives you the value of the left side, but the effects are performed right to left
10:48:32 <c_wraith> > [()] *> [1..10]
10:48:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:48:55 <Berengal> jmcarthur_work, yes, <*'s effect are performed left to right
10:49:09 <Berengal> @type getLine <* putStrLn "hello"
10:49:11 <lambdabot> IO String
10:49:26 <Berengal> @type flip (>>) (putStrLn "Hello") getLine
10:49:29 <lambdabot> IO ()
10:49:49 <jmcarthur_work> i see that the point of <*, of course, is precisely to have two effects and keeping the value of the first performed, though
10:50:01 <jmcarthur_work> i just don't like that it points
10:50:23 <mmorrow> , let for (i,p,inc) f = let go i = do {f i; let {o = inc i}; when (p o) (go o)} in go i in runST (do acc <- ref 0; for(0,(<1000),(+9)) (\i-> do{x <- deref acc; acc.=(x+1)}); deref acc)
10:50:25 <lunabot>  112
10:50:25 <Berengal> jmcarthur_work, and I don't like that the bikeshed is green
10:51:03 <endojelly> Berengal, what? you don't know anything about bikesheds, do you?
10:51:11 <dolio> Applicative stuff is always left-to-right.
10:51:20 <jmcarthur_work> my argument is entirely about intuition
10:51:26 <Berengal> jmcarthur_work, the logic, to me anyway, is that effects have only one ordering, at least in applicative, but which value is returned is not given
10:51:34 <mreh_> :t (:) . []
10:51:36 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
10:51:36 <lambdabot>     In the second argument of `(.)', namely `[]'
10:51:36 <lambdabot>     In the expression: (:) . []
10:52:02 <dolio> There's some Dual wrapper that reverses the effects, or something.
10:52:05 <jmcarthur_work> i wish the operators across Functor, Applicative, and Monad followed a unified system
10:52:12 <Berengal> Pointing in the direction of the effect would mean all operators would look like <*>> or something
10:52:45 <mreh_> what
10:52:49 <dolio> Or maybe there isn't, and I'm imagining things...
10:53:04 <jmcarthur_work> we have a lot of possible operators though, so maybe my hopes are unrealistic
10:53:21 <RayNbow> @hoogle m t -> (t -> m u) -> (t -> u -> v) -> m v
10:53:22 <lambdabot> No results found
10:53:23 <mmorrow> dolio: called flip?
10:53:41 <mreh_> what's a nice idiomatic way of applying several functions to one function without alot of brackets?
10:53:42 <Berengal> dolio, I hope not, or you could easily have effects depending on the result of effects that were supposed to happen first
10:54:07 <dolio> mmorrow: Well, I'm looking now and I'm not seeing it. Maybe it's just Monoid that has such a wrapper.
10:54:10 <Berengal> mreh_, like map?
10:54:34 <jmcarthur_work> each side can be have a type of the form (a), (a -> b), f (a -> b), or (a -> f b), and the effect can be left-then-right or right-then-left for many of those combinations
10:54:37 <opqdonut> :t liftM2 join
10:54:38 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> a2 -> r) -> m a2 -> m r
10:54:44 <opqdonut> hrmm
10:54:46 <mreh_> Berengal: no, I'd like to pass the result of several functions to one function
10:54:49 <jmcarthur_work> i guess i am being unrealistic :\
10:54:54 <mreh_> I suppose a "let"
10:55:05 <pikhq> mreh_: Several functions to one value? Like, do {x <- f; y <- g; z <- h; (x,y,z)} $ a
10:55:09 <pikhq> ?
10:55:16 <Berengal> mreh_, like f (a x) (b x) (c x)?
10:55:22 <Gracenotes> mreh_: (.) and ($)..? Maybe if you had a left-associative $
10:55:25 <mreh_> Berengal: yeah
10:55:36 <mreh_> f takes more than one argument
10:55:37 <Berengal> mreh_, oh, 'f <$> a <*> b <*> c'
10:55:40 <mmorrow> @let f <!> a = join (f <*> a)
10:55:42 <lambdabot>  Defined.
10:55:43 <Gracenotes> with left-associative $, Berengal's example becomes f $ ax $ b x $ c x
10:55:44 <jmcarthur_work> liftA3 f a b c $ x
10:56:05 <mreh_> Berengal: Angle brackets?!
10:56:05 <mmorrow> @type \f a b c -> f <$> a <*> b <!> c
10:56:06 <lambdabot> forall a a1 b (f :: * -> *) a2. (Applicative f, Monad f) => (a -> a1 -> b) -> f a -> f (a2 -> f a1) -> f a2 -> f b
10:56:20 <mmorrow> @type \f a b -> f <$> a <!> b
10:56:20 <Gracenotes> however, $ is right-associative by default, so you'd have to define a separate operator. and there is function lifting if that applies in your particular case
10:56:21 <lambdabot> forall a b (f :: * -> *) a1. (Applicative f, Monad f) => (a -> b) -> f (a1 -> f a) -> f a1 -> f b
10:56:26 <mmorrow> @type \f a b -> f <$> a <*> b
10:56:28 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
10:56:30 <pikhq> mreh_: What Berengal said, or do {x <- a; y <- b; z <- c; f x y z} $ x
10:56:39 <Gracenotes> nvm ;_;
10:56:45 <jmcarthur_work> mreh: liftA3 f a b c $ x
10:57:05 <Berengal> > let if' p t f = if p then t else f in (if' <$> (<3).length <*> head <*> head . drop 2) [1,2,3]
10:57:07 <pikhq> ... Actually, yeah, liftA3 is nicest.
10:57:07 <lambdabot>   3
10:57:07 <mmorrow> (<!>) lets you do bindN
10:57:10 <Berengal> > let if' p t f = if p then t else f in (if' <$> (<3).length <*> head <*> head . drop 2) [1,2]
10:57:12 <lambdabot>   1
10:57:25 <dolio> Berengal: Well, you can certainly make such an applicative. "newtype Op f a = Op (f a) ; instance Applicative f => Applicative (Op f) where pure a = Op (pure a) ; Op f <*> Op a = Op (a <**> f)"
10:57:34 <jmcarthur_work> <!> ?!   never seen that one.
10:57:42 <jmcarthur_work> but i like it
10:57:45 <mmorrow> jmcarthur_work: because i made it up :)
10:57:55 <mmorrow> jmcarthur_work: yeah, it's handy actually
10:58:29 <Berengal> dolio, you could, but it's not nice to do
10:58:31 <mmorrow> the the "f" in f <$> a <*> b <*> .... <*> s is of type (a -> ... -> s -> m z)
10:58:36 <mmorrow> s/the the/when the/
10:58:37 <dolio> Why not?
11:01:37 <pr> !type (<!>)
11:01:39 <pr> @type (<!>)
11:01:41 <lambdabot> forall (m :: * -> *) a a1. (Applicative m, Monad m) => m (a -> m a1) -> m a -> m a1
11:02:08 <mreh_> what's the main use of Applicative?
11:02:27 <mmorrow> do {x1 <- m1; ....; xn <- mn; f x1 .. xn} ==== f <$> m1 <*> .. <!> mn
11:02:46 <pr> i think  you use applicatives if moands are too heavy weight, provide too much interface
11:02:48 <jmcarthur_work> applying effects that give functions to effects than give values
11:02:49 <pr> something like that
11:03:00 <jmcarthur_work> *that
11:03:11 <SubStack> parlor tricks
11:03:21 * mreh_ brane asplode
11:03:22 <edwardk_> mreh_: parsers that aren't quite monadic, etc.
11:03:29 <mmorrow> instance (Monad m) => Applicative m where pure = return; (<*>) = ap
11:03:31 <Berengal> Applicatives can't compute new effects
11:03:31 <mreh_> that still doesn
11:03:34 <mreh_> 't help :)
11:03:42 <mreh_> i'll get there soon
11:03:46 <Berengal> You can't for example read a line and echo it back out
11:03:53 <jmcarthur_work> > Nothing <*> Nothing
11:03:55 <lambdabot>   Nothing
11:03:56 <jmcarthur_work> > Nothing <*> Just 5
11:03:57 <edwardk_> mmorrow:  kinda rough when you go to define other Applicatives that way ;)
11:03:57 <lambdabot>   Nothing
11:04:00 <SubStack> > [(+1),(+2)] <*> [5,10,15]
11:04:02 <lambdabot>   [6,11,16,7,12,17]
11:04:04 <jmcarthur_work> > Just (+1) <*> Nothing
11:04:05 <lambdabot>   Nothing
11:04:07 <jmcarthur_work> > Just (+1) <*> Just 5
11:04:08 <lambdabot>   Just 6
11:04:11 <hackagebot> explore 0.0.5.1 - Experimental Plot data Reconstructor (CetinSert)
11:04:18 <mmorrow> edwardk_: are your instances are belong to me!
11:04:58 <c_wraith> > (+) <$> Nothing <*> Just 3
11:04:58 <mreh_> please, i can't afford any more branes today
11:04:59 <lambdabot>   Nothing
11:05:05 <c_wraith> > (+) <$> Just 2 <*> Just 3
11:05:06 <lambdabot>   Just 5
11:05:24 <mreh_> i'm sure it'll be mentioned in the lectures soon
11:07:44 <jmcarthur_work> lectures? like in a class? i'm not sure if applicative would be covered in such an environment, although it's only a guess
11:08:11 <SubStack> if I were a professor I would totally cover it
11:08:13 <mreh_> jmcarthur_work, video lectures
11:08:20 <jmcarthur_work> so would i
11:08:20 <mreh_> from LtU
11:08:21 <SubStack> even if the class wasn't about haskell or programming
11:08:27 <jmcarthur_work> but most professors i know wouldn't
11:08:30 <SubStack> even if it was about comparative ethics
11:08:31 <edwardk_> mreh_: applicative is relatively new
11:08:34 <jmcarthur_work> ha
11:08:52 <SubStack> I would completely misinterpret the "comparative" part
11:09:24 <SubStack> as deriving Ord
11:09:41 <idnar> applicative ethics?
11:10:07 <SubStack> highly applicable ethics!
11:10:13 <edwardk_> idnar: alternative ethics permit failure.
11:10:21 <idnar> hee hee
11:10:25 <mreh> morrow's definition doesn't cover SubStack's example, [(+1),(+2)] isn't a function
11:10:33 <idnar> let's write an ethics monad
11:10:43 <mreh> no one would use it
11:12:24 <pheaver> in the past i believe i have seen haskell programs print a module name and line of code, for example when throwing an error they identify where the error occurred.  but i can't seem to find any examples of this.  what is this feature called and where can i find documentation?
11:13:24 <endojelly> pheaver, I read a paper about how that's implemented
11:13:26 <endojelly> by SPJ
11:13:34 <ziman> what's the dual of Applicative? How does co-<*> look like?
11:13:40 <pheaver> endojelly: oh yeah?
11:14:05 <endojelly> pheaver, wait, maybe I can find it
11:14:27 <pheaver> endojelly: cool.  we've been searching for it and can't seem to find it :)
11:14:48 <endojelly> pheaver, yap!
11:14:49 <endojelly> http://research.microsoft.com/~simonpj/papers/stack-trace/DebugTraces.pdf
11:14:55 <endojelly> [May 2009] Finding the needle: stack traces for GHC (with Tristan Allwood and Sue Eisenbach).  Lightweight debugging support for lazy functional programs.  Haskell Symposium 2009.
11:15:05 <endojelly> pheaver, assuming that's what you're looking for 8)
11:15:15 <pheaver> endojelly: i think it may be
11:19:21 <lilac> ziman: maybe (CoApplicative f) => f (a -> b) -> f b -> f a?
11:19:35 <endojelly> pheaver, it's interesting and useful in any case, and I wonder when it's going into mainstream GHC
11:19:44 <endojelly> or maybe it already is and I just didn't notice
11:20:01 <SubStack> wish it were easier to chain a bunch of <*> expressions together though
11:20:01 <endojelly> (because you do have to recompile your modules for it to work. not all, though)
11:20:17 <pheaver> endojelly:  well right now it says "Unrecognized pragma" when i try to use it
11:20:29 <SubStack> because nothing/just makes an excellent conditional pipeline mechanism
11:20:44 <lilac> ziman: actually, presumably a CoApplicative is just a less dynamic CoMonad (CoMonad minus cojoin), which I think gives co<*> the same type as <*>
11:21:13 <arjanb> ziman: Conor calls it's Decisive in a blog post: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=69
11:21:40 <dolio> There's actually another formulation of applicative where (<*>) corresponds to "pair :: m a -> m b -> m (a, b)".
11:21:56 <jmcarthur_work> a lot of people call that Zip
11:22:13 <endojelly> pheaver, well it is pretty new, the paper is from May 2009
11:22:17 <pheaver> yeah i see :)
11:22:20 <dolio> Which might suggest copair :: m (Either a b) -> Either (m a) (m b).
11:22:21 <endojelly> but I'd argue that it's a necessary extension
11:22:27 <endojelly> debugging is a pain without it
11:22:34 <pheaver> endojelly: yeah very useful
11:22:48 <endojelly> but I really like the first sentence.
11:22:58 <ziman> thanks guys; conor seems to have an interesting approach to Functors (unit, mult) instead of pure/ap
11:22:59 <endojelly> "Even Haskell programs can occasionally go wrong."
11:23:11 <ziman> s/Functors/Applicatives/
11:23:14 <pheaver> endojelly: i'm actually interested in printing the caller function
11:23:23 <pheaver> lol
11:23:23 * absentia is often wrong...
11:23:24 <absentia> hell
11:23:29 <dolio> ziman: That's actually in the original paper, as I recall.
11:23:30 * absentia is more often wrong.
11:23:36 <dolio> But he wrote it, so...
11:23:46 <NegBlaNi> Learn about Uganda and other negro "Coontries" at Chimp Out's Niggger World Atlas!  Here is our entry for Uganda, encyclopedia style.  http://chimpout.com/forum/showthread.php?t=27071   All non-negroid races, gays, straights, jews, etc are welcome to Chimpout Forum!  We are all human races united against the feral negro beast!
11:23:51 --- mode: ChanServ set +o mauke
11:23:52 --- mode: mauke set +b *!*@201.171.69.94.dsl.dyn.telnor.net
11:24:41 <SubStack> >_<
11:24:52 --- mode: mauke set -o mauke
11:25:26 <harlekin> Is documentation on haskell.org broken? http://www.haskell.org/ghc/docs/latest/html/libraries/stm/Control-Monad-STM.html
11:26:10 <Lemmih> harlekin: Broken?
11:26:43 <harlekin> The functions there don't have any description. Same here: http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98/Array.html
11:26:58 <harlekin> I would expect at least Array to be more detailed / helpful. Other pages have description as usual.
11:27:07 <Berengal> harlekin, if you check the source of that module you'll see it's just not documented
11:27:13 <Lemmih> harlekin: Look at Data.Array
11:27:31 <Lemmih> harlekin: Or click on any of the links.
11:27:53 <enolan> Click on one of them
11:27:58 <harlekin> Okay. Thanks to you all.
11:28:02 <RayNbow> mauke, have you tried golfing this one? http://golf.shinh.org/p.rb?Expression+for+appreciation
11:29:23 <mauke> RayNbow: yeah, 52 bytes of perl
11:30:09 <SubStack> wow, perl is beating j
11:30:28 * RayNbow notes to self... use Ctrl+F, mauke[enter] next time...
11:31:23 <endojelly> by the way, if someone speaks vietnamese and is willing to translate a very short message (one or two lines) for me, drop a note 8)
11:32:37 <mauke> perl also beats j at http://golf.shinh.org/p.rb?find+minimum+cyclic+parts
11:33:51 <RayNbow> at 'find minimum cyclic parts', Haskell beats me :p
11:34:27 * RayNbow is really interested in notogawa's solution
11:38:18 <burp> http://golf.shinh.org/p.rb?Short+Pi
11:38:21 <burp> what sense does this make?
11:38:31 <burp> you could just do print pi .. ;)
11:38:46 <burp> or hardcode the value instead of calculating it
11:39:50 <Gracenotes> that is a relatively high number of decimal places, for a pi calculation
11:40:04 <jkff> There's a 5-byte entry in forth there
11:40:50 <jkff> Probably something like "14 pi"
11:41:25 <burp> statistics seem to be wrong anyway
11:44:12 <jkff> Anyone know of applications of some serious abstract algebra to "pure computer science" problems, except for cryptography, computer algebra and combinatorics? The only application that I know of are the fingertrees built on monoids, but they use very few math.
11:45:06 <jkff> I wonder if the group/ring/module theory that I am excitedly reading may actually turn out to be useful :)
11:45:16 <mauke> wtf, short pi has a 24 byte perl solution
11:45:41 <mauke> that's pretty incompetent considering the obvious naive program is only 22 bytes
11:45:53 <jkff> mauke: submit your entry :)
11:46:07 <mauke> why?
11:46:09 <jkff> ...And also sigfpe's "An approach to algorithm parallelization".
11:46:34 <jkff> To record your name among the Great Printers of Pi, of course!
11:46:55 <mauke> jkff: that would be http://www.spoj.pl/ranks/PIVAL/
11:47:42 <jkff> Hehe, Alexey rocks here again
11:48:03 <jkff> ..And hey, it's in Haskell!
11:48:51 <copumpkin> is lambdabot down?
11:49:03 <jkff> > "it isn't"
11:49:05 <lambdabot>   "it isn't"
11:53:07 <mauke> jkff: I'm #1 in short pi/perl now
11:54:26 <hackagebot> hSimpleDB 0.1 - Interface to Amazon's SimpleDB service. (DavidHimmelstrup)
11:54:52 <burp> mauke: how? ;)
11:54:59 <mauke> magic!
11:55:03 <burp> :D
11:55:16 <mauke> well, arithmetic
11:55:54 <jkff> Something like 'acos(-1)'?
11:55:58 <jkff> Oh
11:56:02 <jkff> I need to get some sleep :)
11:56:20 <mauke> perl has no built-in acos
11:56:32 <HugoDaniel> eheh
11:56:33 <jkff> Does it at least have a built-in pi?
11:56:38 <HugoDaniel> pearl has built-in caos :)
11:56:42 <mauke> jkff: no
11:56:50 <HugoDaniel> but it has no built-in acos
11:56:51 <erikc> intel buys rapidmind, what a coup for rapidmind
11:57:01 <jkff> Hm, that changes things. Does it have any built-in trigonometry at all?
11:57:08 <mauke> HugoDaniel: http://www.irt.uni-hannover.de/pearl/pearl-gb.html
11:57:17 <mauke> jkff: yes :-)
11:57:24 <jkff> Ah, I see atan2
11:57:30 <HugoDaniel> ah, sorry :)
11:57:32 <HugoDaniel> i meant perlk
11:57:33 <HugoDaniel> perl
11:58:17 <jkff> mauke: Did you use atan2?
11:58:27 <c_wraith> atan2 is like the best thing ever
11:58:31 <mauke> it is a mystery
11:58:36 <jkff> Oh
11:58:46 <c_wraith> ...  at least compared to attempting to implement its functionality from just atan
11:59:39 <edwardk_> @seen tibbe
11:59:40 <lambdabot> I saw tibbe leaving #haskell-in-depth, #ghc, #haskell and #xmonad 2h 59m 14s ago, and .
12:00:32 <edwardk_> bah, its usually just a sign you should be using linear algebra rather than computing with ugly angles ;)
12:00:38 <jkff> Well, I got 16 chars too
12:01:22 <mauke> submit! :-)
12:02:09 <mauke> huhu
12:02:09 <jkff> Oh noes, I've got 17! But I counted them!
12:02:13 <Philonous1> @seen conal
12:02:13 <lambdabot> I saw conal leaving #ghc, #haskell-in-depth, #haskell-iphone and #haskell-blah 1m 22s ago, and .
12:02:38 <burp> maybe you submitted a newline? ;)
12:02:54 <jkff> Indeed. Vim didn't show it but xxd did
12:03:12 <mauke> :set binary
12:03:14 <mauke> :set noeol
12:03:30 <jkff> Wow, thanks
12:03:45 <jkff> Bingo
12:03:59 <jkff> Mine works faster :-P
12:04:20 <mauke> hah
12:04:53 <jkff> The entry in LAZY-K is 460 chars
12:05:23 <Plouj> what kind of industries am I looking at if I want to write haskell now and/or in the future?
12:05:30 <jkff> I wonder what it looks like, I wouldn't expect that even from COBOL
12:05:31 <Plouj> I guess finance is one of them.
12:08:04 <SubStack> is academia an industry?
12:08:12 <SubStack> this could be argued I think
12:08:27 <Plouj> ahah
12:08:43 <Plouj> probably not if I want to have a chance on making good money.
12:08:58 <Plouj> a higher*
12:09:00 <Plouj> chance
12:09:06 <arjanb> i think in a few years haskell can be found in any industry
12:09:16 <jkff> (Turns out Lazy K is an esoteric language)
12:09:46 <SubStack> Plouj: research departments in big orgs perhaps
12:10:22 <jkff> Like Microsoft Research :)
12:11:49 <_-jn> Hi, can anyone help me with this? After a readFile is preformed (using Data.ByteString.Lazy), can I close the handle of the file manually (without reaching EOF), to avoid filelocks when writing to the file later? (readFile doesn't return a filehandle, so I can't reference it directly...)
12:12:17 <SubStack> _-jn: System.IO
12:13:28 <SubStack> maybe don't use ByteString's builtin readfile if you need a handle on it
12:13:28 <Cale> _-jn: No. The file will be closed automatically at some future point (either when the string is garbage collected, or once you've finished demanding all the characters)
12:13:35 <jmcarthur_work> @src readFile
12:13:37 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
12:13:48 <SubStack> although explicit locking isn't a very functional way to do it
12:13:48 <Cale> _-jn: If you need to close the filehandle in a timely fashion, it's best not to use lazy IO.
12:14:16 <Cale> _-jn: Instead, use a strict ByteString and slurp the whole file at once, so that you can close it after.
12:15:02 <Cale> (The strict-ByteString readFile will read the whole file at once and close the handle for you, I believe)
12:15:17 <Baughn> _-jn: Alternately, if laziness is important to you, you must evaluate.rnf the bytestring once done with the file. This may be complicated by there not being an NFData instance for lazy bytestrings.
12:15:53 <jkff> _-jn: You might also try using iteratees
12:15:57 <Baughn> _-jn: (for this particular case, evaluate . BS.length will do)
12:15:57 <edwardk_> @seen mmorrow
12:15:58 <lambdabot> I saw mmorrow leaving #yi, #haskell-blah, #haskell-in-depth, #ghc and #haskell 31m 33s ago, and .
12:18:54 <_-jn> ok, thank you! I'll try evaluate . BS.length, and if that won't do it I have to resort to a strict reading
12:20:55 <jmcarthur_work> i have a love/hate thing going on with iteratee
12:21:09 <jmcarthur_work> it seems to be a nice abstraction, but it also seems to be a horrible abstraction...
12:21:12 <Cale> If you're just forcing the entire string immediately, there's not much point in using lazy bytestrings.
12:21:29 <jkff> Why is it horrible?
12:21:53 <jmcarthur_work> in my experiences so far it has been very complicated and difficult to create abstractions on top of
12:21:56 <edwardk_> jmcarthur_work: hahaha
12:22:00 <Baughn> Definitely true. Strict I/O is simpler to reason about, it's just that implicit lazy I/O can be nicer than explicit lazy I/O
12:22:17 <Baughn> jmcarthur_work: Clearly the future is in FRP. :P
12:22:20 <edwardk_> jmcarthur_work: i actually prefer to view an iteratee as a Moore machine that takes big steps
12:22:22 <Cale> I think Iteratee is a solution which is only appropriate less than 1% of the time, and usually gets dominated by something else.
12:22:23 <jmcarthur_work> Baughn, ;)
12:22:40 <jkramer> Ahoy
12:22:52 <jmcarthur_work> Yoha
12:22:54 <SubStack> avast
12:23:14 <jkramer> I'm trying to build my first cabal package but I'm failing at finding all dependencies
12:23:20 <Cale> I can't rule out the possibility that there are actually use-cases where it's the right thing, but I haven't run into them myself, and the thing is so damn complicated that it would *really* have to be the only way forward.
12:23:23 <edwardk_> jmcarthur_work: i keep wondering if a Mealy/Moore interpretation of iteratee would be more palatable and safer
12:23:30 <Baughn> jkramer: It's better to leave cabal-install to do the hard lifting.
12:23:31 <edwardk_> Cale: iteratees?
12:23:33 <jkramer> I'm using Data.List in the module and cabal claims that it's not part of base
12:23:35 <Cale> edwardk_: yeah
12:23:40 <edwardk_> cale: i just needed them the other dya
12:23:52 --- mode: ChanServ set +o mauke
12:23:52 --- mode: mauke set -b *!*@201.171.69.94.dsl.dyn.telnor.net
12:24:00 <jmcarthur_work> edwardk, i would have to look into what exactly this Mealy/Moore interpretation is supposed to mean :)
12:24:01 <edwardk_> cale: i build a modified iteratee to back parsec so i could wrap it in a monoid and feed it new input as it became available.
12:24:09 <Baughn> jkramer: ..okay. What version of GHC are you running?
12:24:22 <jkramer> Baughn: 6.10.3
12:24:23 <Baughn> jkramer: What's the /exact/ error message, and what does your .cabal file look like? (hpaste, please)
12:24:52 --- mode: mauke set -o mauke
12:24:52 <jmcarthur_work> oh i see
12:25:00 <edwardk_> cale: slides from the second talk from the other day that I didn't have : http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf
12:25:08 <Cale> edwardk_: Is it not possible to use Parsec's existing stream thing?
12:25:24 <edwardk_> cale: it is, you just need the Iteratee as the monad for the Stream instance =)
12:25:40 <edwardk_> and to change the way iteratees handle buffering, because it needs to be able to backtrack
12:25:46 <jkramer> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8342#a8342
12:25:56 <Cale> edwardk_: ah, hmm
12:26:07 <edwardk_> instance Stream Cursor Iteratee Char where ...
12:26:29 <Cale> edwardk_: At least you end up with what is hopefully an interface where you don't have to think about the Iteratee insanity behind it.
12:26:32 <edwardk_> the trick was noting that the 'Input' that parsec uses to backtrack should be a cursor position in the buffer
12:26:44 <edwardk_> cale: yeah, you can just write a parsec parser and forget basically
12:27:00 <edwardk_> the monoid stuff complicates it again, but you don't need that to use the basic iteratee-based parsec parser
12:27:02 <jkramer> The module itself when built with ghc --make builds fine, btw
12:27:29 <edwardk_> you only need it if you want to chunk your input up at error production locations to feed a monoidal parser the token stream
12:27:40 <jmcarthur_work> edwardk, wait, how does the monoid stuff interact with parsec, exactly? what kind of interface is it?
12:28:04 <jmcarthur_work> does parsec wrap it or does it wrap parsec?
12:28:16 <jmcarthur_work> or something else?
12:28:18 <Baughn> jkramer: Ah. You need to specify build-depends in the library section, global dependencies apparently do not work. IIRC.
12:28:19 <edwardk_> jmcarthur_work: kind of more of a sandwich
12:28:49 <jmcarthur_work> parsec -> monoids -> parsec?
12:29:21 <Baughn> jkramer: No, wait... "There is no installed version of base"? o_O
12:29:25 <Baughn> jkramer: ..I'm stumped.
12:29:26 <jkramer> Baughn: Thanks, at least that fixed the Data.List error
12:29:31 <jmcarthur_work> where each step tokenizes in some way for the next?
12:29:34 <edwardk_> i use two monoids to make a better iteratee (a cursor monoid, and a fingertree of bytestrings), that i can make a stream interface for parsec from. then i run parsec to generate a monoidal value wrapped in an iteratee, where the monoid in question is some Token `Reducer`... in other words, it runs an upstream parser
12:29:55 <jmcarthur_work> i see
12:29:56 <raimo_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3365#a3365 how could I create this kind of recursive drain function for arbitrary Handles?
12:29:59 <sm> I would appreciate any comments on why this seems to leak memory: http://gist.github.com/170603 . It grows past several hundred M, at a rate proportional to the number of feed items fetched. It holds steady at 80M if I print the items (the workaround shown doesn't seem to help.) I'm not sure where I'm leaking. Is it my recursion ?
12:30:00 <edwardk_> That is run on fragments of the input starting at one error production and running to the next one in a subsequent chunk.
12:30:20 <raimo_> I can't figure out what to return when I don't want recurse again
12:30:23 <edwardk_> so the chunks form ANOTHER monoid, which is responsible for parallelizing/incrementalizing parsing using local context.
12:30:47 <jmcarthur_work> edwardk, so this isn't even a modification to iteratee that you have, it's a new one?
12:30:50 <jkramer> Baughn: Thanks, everything works now, I just had to add another dependency
12:31:07 <jmcarthur_work> i understand the parsec layer now, thanks
12:31:13 <edwardk_> jmcarthur_work: yeah, basically you swap out the definition for 'Stream' ala Oleg for a new one
12:31:23 <jmcarthur_work> ah, nice
12:31:35 <edwardk_> Stream ala oleg is very much engineered towards non-backtracking
12:31:59 <edwardk_> I replace it with a backtrackable stream that works on a fingertree of bytestrings (because you index into it by a cursor, which is tracked by parsec)
12:32:13 <edwardk_> when parsec needs something past the current end-of-buffer it blocks waiting for more input
12:32:27 <jmcarthur_work> right
12:32:31 <jmcarthur_work> that's sounds very nice
12:33:06 <edwardk_> the fingertree gives me O(1) appends of new bytestring chunks onto the fingertree'd buffer
12:33:07 <jmcarthur_work> i need to modify xchat to ask me if what i just typed is grammatically correct and not stupid
12:33:14 <edwardk_> and most backtracks will be near the end anyways
12:33:37 <edwardk_> so most cursor indexes will be O(1) also
12:33:46 <jmcarthur_work> are you sure the fingertree is necessary? seems like a list would be as convenient if most backtracks are short
12:33:53 <edwardk_> but they are at worst O(log (min(n,m-n)))
12:34:07 <edwardk_> jmcarthur_work: pathological behavior. unfortunately, we always snoc.
12:34:14 <jmcarthur_work> oh
12:34:25 <edwardk_> so snocing buffers with lazy bytestrings would have bad asymptotics
12:34:30 * EvilTerran blinks... that "data Iteratee" definition looks an awful lot like something i came up with when playing with SML as a more structured way of dealing with input than I felt general side-effects were
12:34:37 <edwardk_> plus, we typically access near the end of the list
12:34:46 <jmcarthur_work> i just mean have the list in reverse
12:35:00 <jmcarthur_work> like a stack of chunks
12:35:04 <edwardk_> jmcarthur_work: but then i am bothering to load a big bytestring and flip it
12:35:18 <harlekin> Can I use TArray operations in a StateT s STM a monad?
12:35:22 <edwardk_> since i plan to use bytestring-mmap to load it...
12:35:28 <jmcarthur_work> you wouldn't really have to flip it would you?
12:35:44 <jmcarthur_work> it would just be something to abstract into the cursoring stuff
12:35:57 <edwardk_> well, the other case is that i may have to append a whole bunch of bytestrings to my buffer at once.
12:36:07 <jkff> sm: Have you tried memory profiling?
12:36:08 <edwardk_> i resume at error productions, say non-backslashed carriage returns...
12:36:21 <edwardk_> if one doesn't occur in a chunk i call that a 'raw chunk'
12:36:28 <edwardk_> i might have several raw chunks in a row
12:36:33 <Saizan> harlekin: yes, use lift to get past the StateT layer
12:36:34 <jmcarthur_work> oh, i see
12:36:37 <edwardk_> that would all be appended to a cooked chunk at once
12:36:49 <jmcarthur_work> yeah i guess the fingertree would at least be the least problematic in portential
12:36:57 <jmcarthur_work> *potential
12:36:58 <harlekin> Saizan, thanks. :)
12:37:02 <edwardk_> the fingertree was a nice 4 line solution ;)
12:37:33 <edwardk_> index is basically the only operation that cares about the fingertree.
12:37:37 <edwardk_> that and slicing
12:37:44 <edwardk_> which i think works out really nicely
12:37:58 <edwardk_> since i have the buffer as a fingertree of bytestrings and use cursors that index into it
12:38:18 <sm> jkff: yes
12:38:33 <edwardk_> i can take two cursors and 'slice' the buffer to obtain a bytestring where if they bytestring doesn't straddle a chunk boundary it can share with the original bytestring
12:38:39 <jkff> sm: And what leaks? :)
12:38:56 <sm> it's all used in fetchItems (my profiling doesn't go deeper, but I feel it's lazy xml structures)
12:38:57 <pr> > 9000!
12:38:59 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:39:03 <pr> heh
12:39:05 <edwardk_> so now most of my parsers are like: ident = Ident <$> sliced (lower >> skipMany isIdent)
12:39:13 <EvilTerran> > product [1..9000]
12:39:15 <lambdabot>   809958998668719085829131208009794964758281463929464089222191306909090154073...
12:39:21 <EvilTerran> pr, there you go :)
12:39:27 <pr> EvilTerran: nah, read it like "over 9000!"
12:39:33 <copumpkin> lol
12:39:35 <EvilTerran> ohhh :P
12:39:39 <pr> :>
12:39:45 <edwardk_> where sliced parse = do mark <- getInput; parse; release <- getInput; slice mark release
12:39:51 <sinelaw> > product [1..0]
12:39:53 <lambdabot>   1
12:40:03 <copumpkin> I hereby declare > product [1..9000] to be #haskell's inside "over 9000!1!!11!" joke
12:40:10 <EvilTerran> > [1..0] == []
12:40:11 <lambdabot>   True
12:40:22 <jmcarthur_work> huh nice
12:40:30 <copumpkin> ?
12:40:31 <sm> (I did break it down into download, xml parsing, feed conversion to see when it grew)
12:40:57 <edwardk_> jmcarthur_work: since my cursors actually advance in UTF8 that works out very nicely for extracting UTF8 encoded identifiers, etc.
12:41:19 <jmcarthur_work> sexy
12:41:32 <conal> Philonous1: hey
12:41:34 <sm> my intuition was that regardless of how big one set of items is, they are thrown away on each iteration. My go fn is tail-recursive (?). So why should it keep growing ? Obviously I'm missing something
12:42:18 <edwardk_> jmcarthur_work: that was the piece of the kata parser that i was probably happiest with in terms of elegance
12:42:47 <sm> also, printing the items to stdout prevents the growth. So I'm wondering why my seq (...) doesn't have the same effect.
12:43:01 <Saizan> sm: are you strict on the accumulators of the go function?
12:43:06 <edwardk_> jmcarthur_work: the same iteratee-based parsec mechanism can be used one level up as well for recognizing bitonic sequences of layout/matching parens, etc.
12:43:35 <jkff> sm: Are you sure that your 'seq' is actually a deep 'seq'?
12:43:51 <sm> Saizan: it's just as I pasted, except for the snipped setup. So I'm guessing not ?
12:44:10 <sm> jkff: I thought so, because calling show on all items evaluates them fully imho
12:44:40 <sm> I also tried strict (at bottom) as a deep seq, but that seemed to have no effect
12:45:59 <Philonous1> conal: A, hi. I just wanted to tell you that I took some of your code from "beautiful differentiation", jfoutz code on multivariate differentiation and added some type magic to hide the actual representation. So now you can write stuff like (hessian (\x y -> x^^2*y+y^^3*x^^2)) 1 2 and it gives you [[20.0,26.0],[26.0,12.0]]
12:46:18 <jkff> Have you looked at what thunks occupy the memory?
12:46:35 <Saizan> yeah, you should profile with -hd
12:46:50 <Saizan> it'll tell you the names of the closures that fill the heap
12:46:52 <raimo_> is there a way to make this more elegant http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3366#a3366
12:46:52 <copumpkin> Philonous: ooh nice
12:46:55 <Philonous> conal: Here's the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8344#a8344
12:46:56 <Saizan> -hT is also useful
12:47:03 <raimo_> like getting rid of if-then-else
12:47:07 <sm> thanks, trying
12:48:05 <vyom> what is the meaning of ServerConf(..) in something like <code>module Hack.Handler.Happstack (run, runWithConfig, ServerConf(..)) where</code>  on top of a source file
12:48:17 <Saizan> go has many iterations you should sprinkle some bangs on its arguments, the Integer accumulators are completely lazy
12:48:45 <ttfh> hello everybody
12:48:46 <mauke> vyom: it means the type ServerConf and all its constructors
12:48:50 <sm> Saizan: that sounds good, I did try that but must have had wrong syntax
12:48:50 <Saizan> vyom: that it exports the ServerConf type with all its constructors
12:48:58 <vyom> thanks
12:49:07 <Saizan> s/go/if go/
12:49:09 <ttfh> I just wrote a 2000-line haskell program, what will happen now?
12:49:16 <jmcarthur_work> raimo_, here's a (untested) start http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3366#a3367
12:49:37 <Saizan> go !seen !toannounce !iterationsleft !numannounced !polls !failedpolls = do
12:50:20 <raimo_> jmcarthur_work: looks a lot better, thank you!
12:50:21 <bob0> What's wrong with the indentation on line 6 of http://dpaste.com/82878/ ?
12:50:57 <nathanic> bob0: i think 'then' must be more indented than 'if'
12:50:59 <sm> ah, I needed BangPatterns
12:51:45 <bob0> nathanic: same error
12:51:51 <sm> -ht and -hT must be a ghc 6.12 thing I guess, I don't see them
12:52:20 <Saizan> bob0: what's the error?
12:52:22 <bob0> nathanic: it's complaining on line 6, not 7, anyway
12:52:30 <Saizan> oh, i see
12:52:44 <Saizan> then and else must be indented more than if only in do-blocks
12:52:59 <conal> Philonous: neat!
12:53:00 <c_wraith> Why so many parenthesis? Haskell isn't an algol-derived language
12:53:15 <bob0> Saizan: reverse.hs:6:8: parse error (possibly incorrect indentation)
12:53:21 <bob0> Saizan: it's in the comment on line 6
12:54:03 <Saizan> bob0: try indenting if more than the "f x acc" above
12:54:17 <Saizan> and the rest accordingly
12:54:36 <bob0> Saizan: that fixed the indentation error
12:54:43 <bob0> Saizan: thanks :)
12:55:20 <Berengal> definitions in a where clause must all be equally indented. Decreasing indentation ends the while block
12:55:21 <endojelly> "< Saizan> then and else must be indented more than if only in do-blocks" - that's a funny sentence when you read "then", "if", "else" and the other tokens not as tokens but as normal words as part of the sentence
12:55:31 <Saizan> Char.isSpace x || ((length $ head acc > 0) && (Char.isSpace . head . head $ acc))
12:56:01 <Berengal> The indentation in a where clause is decided by the first non-whitespace character after 'where'
12:56:15 <purplepenguins> :t and
12:56:17 <lambdabot> [Bool] -> Bool
12:56:40 <jmcarthur_work> :t or
12:56:41 <lambdabot> [Bool] -> Bool
12:57:13 <jmcarthur_work> @check \xs -> all xs == and xs
12:57:15 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
12:57:48 <edwardk_> i kind of wish the way layout is relaxed for if...else was just applied uniformly to all matched bracketing pairs
12:57:58 <jmcarthur_work> oh
12:58:02 <jmcarthur_work> :t all
12:58:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:58:06 <jmcarthur_work> duh
12:58:06 <bob0> endojelly: yeah, that'd probably have been clearer if it had "'s
12:58:11 <edwardk_> { .. } [ .. ] ( .. ) case .. of, if ... else
12:58:36 <edwardk_> then people coming from c wouldn't flip out when they outdented a ) all the way to the current layout rule
12:59:22 <edwardk_> basically then the rule just becomes suppress virtual semicolon emission while inside a matching-pair context.
12:59:41 <sm> Saizan: ! annotations fixed it. And prepending seq (length $ show ...) to feedItems f reduced the footprint another 15-20%
13:00:19 <Baughn> @pl case a of Just b -> b; Nothing -> return ()
13:00:20 <lambdabot> (line 1, column 18):
13:00:20 <lambdabot> unexpected ">" or "-"
13:00:20 <lambdabot> expecting variable, "(", operator or end of input
13:00:47 <Baughn> @pl \a -> if isJust a then fromJust a else return ()
13:00:47 <lambdabot> flip (liftM2 if' isJust fromJust) (return ())
13:00:52 <mmorrow_> how would i find out details of the graphics card on a laptop running linux?
13:00:54 <sm> so about 70M now to poll a hundred-item feed
13:00:54 <Baughn> ..thanks, \bot.
13:00:58 <sm> good enough for now, thanks very much all
13:01:03 <Baughn> mmorrow_: lspci?
13:01:53 <mmorrow_> Baughn: hmm that says something about the "Display controller"
13:02:19 <Baughn> mmorrow_: That's your ticket to freedom. Run update-pciids if it doesn't name it.
13:02:52 <mmorrow_> what i'm really trying to find out is the slim chance that it's possible to compile programs to run on the gpu of my graphics card (on this laptop)
13:03:16 <mmorrow_> is this even possible without getting some super-particular graphics card?
13:03:31 <Baughn> Which card is it?
13:03:37 <mmorrow_> i don't know! :)
13:03:42 <Baughn> What does lspci say?
13:03:56 <mmorrow_> i'll paste (i don't see anything about the graphics card)
13:04:03 <Baughn> "Display controller", usually
13:04:11 <Baughn> Or "VGA compatible controller"
13:04:25 <mmorrow_> aww, i was hoping that wasn't it..
13:04:27 <mmorrow_> 00:02.1 Display controller: Intel Corporation Mobile 4 Series Chipset Integrated Graphics Controller (rev 07)
13:04:34 * mmorrow_ thinks he's probably SOL
13:04:42 <Baughn> ..yeah, I'd say that's likely.
13:04:50 <mmorrow_> blast!
13:04:55 <Baughn> OpenCL will probably work on it.. eventually...
13:04:59 <Baughn> In software emulation mode. :P
13:05:12 <mmorrow_> :(
13:05:17 <Berengal> Mmm, software emulation
13:05:18 <Baughn> Oh, wait. Intel doesn't support OpenCL. Forgot.
13:05:18 <mmorrow_> well at least i have something to gogle
13:05:23 <mmorrow_> heh
13:05:42 <copumpkin> :o
13:05:47 <Berengal> Are anyone working on a slightly-higher-level openCL api for haskell yet?
13:05:51 <p_l> Baughn: or in "compile to GLSL" mode
13:05:56 <Baughn> mmorrow: It pretty much has to be an 8600-level geforce or better, or a 4850-level radeon or better
13:06:08 <mmorrow> Baughn: ah, cool
13:06:11 <copumpkin> Berengal: I thought jeffersonheard was working on something on top of his initial pass
13:06:20 <Baughn> mmorrow: The card-specific versions work on more cards, but are a dead end
13:06:48 <Baughn> p_l: That GPU won't support GLSL to the required level either
13:07:20 <p_l> Baughn: 4 series? they even do hw h264 afaik
13:07:23 <Baughn> mmorrow: Oh, and be warned: 9000=8000 in the nvidia world
13:07:38 <Baughn> p_l: So? That doesn't depend on particular shaders; the h.264 hw is separate
13:07:47 <mmorrow> Baughn: noted
13:07:50 * Berengal only has a 280
13:08:05 * Baughn only has a 260, even. I'm dooomed.
13:08:21 <edwardk_> Berengal: i started trying to see if i could figure something nicer out when i got home the other night, but i don't have anything solid yet
13:08:42 <Berengal> I don't even really know what to do with it :/
13:08:59 <Berengal> Multiply some matrices I guess, but I don't really need to...
13:09:17 * Berengal wonders if making it do taxes would be overkill
13:09:23 <mmorrow> so i'm confused, what exactly is CUDA (just a particular C api to a particular manufacturer's particular chip(s)?), and do the gpu's of different manufacturer's understand the same instruction set/encoding(s)?
13:09:50 <Berengal> mmorrow, CUDA was nvidia's platform, no?
13:09:52 <copumpkin> yes, and no
13:09:54 <Berengal> is* even
13:09:55 <copumpkin> in that order :P
13:10:06 <Baughn> mmorrow: Different GPUs from the /same manufacturer/ have different instruction sets, even
13:10:21 <arw> there is (now) a more general language that should be supported by all manufacturers...
13:10:22 <copumpkin> CUDA abstracted you away from those details for a particular manufacturer
13:10:27 <mmorrow> also, how do you run a prog on a gpu? some tedious process of moving the code over to the card? and can a prog running on the gpu access main memory?
13:10:31 <Berengal> open*L is just an API. Implementations are vendor specific
13:10:32 <Baughn> mmorrow: CUDA is an nVidia-specific language. CTM is AMD's version. OpenCL is a higher-level one that is generally better than both, and is supported by both.
13:10:43 <doublethink_work> mmorrow: CUDA is just a language and compiler for C, but with the extension that it runs stuff on the GPU (so there are a few syntax deviations)
13:11:00 <doublethink_work> mmorrow: but it will only work for nvidia cards
13:11:09 <mmorrow> ah, ok
13:11:14 <Baughn> mmorrow: GPU programs can't access main memory (directly); you write code to explicitly move data between main memory, the AGP aperture, and the GPU's local memory
13:11:52 <mmorrow> hmm, i see
13:12:34 <Berengal> I wonder what this'll look like in ten years...
13:12:38 <Baughn> mmorrow: Oh, and modern GPUs have hardware support for threading. You write code for upwards of 64 cores, which will run.. some number (16?) threads per core. This extreme threading is to deal with poorer branch prediction, mainly.
13:12:55 <Berengal> Perhaps there won't be GPUs anymore, and CPUs will be replaced by processing arrays
13:13:41 <mmorrow> FPGAs!
13:14:17 <Baughn> Implicit hardware generated by interfering magnetic fields! ^_^
13:14:32 <edwardk_> mmorrow: cuda was nvidia's entry into this space. openmetal or something like that was ATIs.
13:14:34 <Berengal> I predict the PC as we know it won't be here at all in 30 years
13:14:43 <edwardk_> ah, missed baughn's reply
13:14:56 <Baughn> Berengal: 30 years? You might as well bet the human species as we know it won't be here. You'd have a good chance of being right.
13:15:13 <Baughn> edwardk_: It's "Close To Metal"
13:15:21 <edwardk_> Baughn: thats what it was
13:15:27 <Baughn> They meant it, too.
13:15:44 <Berengal> Baughn, okay, I'll bet a billion $ on the human race being gone in 30 years, pay me know and I'll pay you back if I'm wrong
13:15:49 <mmorrow> so i take it then that the only compilers/assemblers for gpu targets are the ones their manufacturer's provide, that take some pseudo-C language as input?
13:16:00 <Baughn> Yes
13:16:04 <edwardk_> mmorrow: unfortunately. there are some workarounds
13:16:28 <edwardk_> mmorrow: there was a python project that reverse engineered the cuda bin format, which can be used to hand compile for nvidia cards
13:16:33 <Baughn> mmorrow: Getting good performance from GPU hardware is a highly arcane art
13:16:36 <edwardk_> cudasm or something
13:16:49 <copumpkin> Baughn: which is why we need a DPH backend for it :P
13:16:59 * copumpkin looks hopefully toward ChilliX
13:17:07 <Baughn> While you might say the lack of specs is unfortunate, a lack of manufacturer-supplied compilers would be far more unfortunate
13:17:20 <mmorrow> :o that was my next question.. so it's not even publicly available what binary instruction format/or even the instruction set itself that the gpu's take
13:17:25 <mmorrow> ? :(
13:17:31 <edwardk_> mmorrow: i at one point started adapting that to see if i wanted to build a compiler that could try to generate gpgpu fragments for code runs that had nice coherent output access patterns
13:17:41 <edwardk_> mmorrow: fraid not
13:17:51 <burp> http://graphics.cs.williams.edu/archive/SweeneyHPG2009/TimHPG2009.pdf
13:17:52 <mmorrow> sounds grim
13:17:52 <Baughn> mmorrow: The knowledge you need to write good code is available. There's little point in going below that; the next month, the next GPU release would invalidate your work.
13:17:56 <burp> end of the gpu roadmap ^^
13:18:09 <Berengal> afaik, gpu's change instruction every other year. I'd rather not program in assembly for them anyway
13:18:13 <edwardk_> mmorrow: the other consideration is this, in general gpgpu fragments can only write to memory locally you have no 'random access writes'
13:18:28 <Baughn> mmorrow: Well, except morbid curiosity. The nVidia OpenGL driver, for example, makes wide use of self-modifying code.
13:18:34 <Baughn> mmorrow: ..that's probably LLVM, so it's not /that/ bad
13:18:54 <edwardk_> Baughn: as does the apple one, since they hired the guy behing llvm
13:19:04 <mmorrow> nice, /me googles for the nvidia opengl driver code
13:19:19 <Baughn> mmorrow: You won't find source. I gleaned that from the README.
13:19:22 <edwardk_> mmorrow: you expect something open? ;)
13:19:28 <mmorrow> hah
13:19:32 <Baughn> mmorrow: "Precautions to take when valgrinding opengl programs"
13:20:03 <mmorrow> ah right, so the linux driver's distributed as a binary
13:20:06 <copumpkin> edwardk_: by the way, that graph algorithm I mentioned a while back, I'm pretty sure I can squeeze moar monoidz out of it
13:20:18 <edwardk_> copumpkin: haha
13:20:29 <p_l> Baughn: often said self-modifying code works through copying code fragments into a buffer to be executed to minimize jumps
13:20:38 <copumpkin> edwardk_: when I'm finished making something that "just works" I'll build it on top of your classes and see if I can parallelize it easily
13:20:47 <edwardk_> spiffy keen
13:20:57 <edwardk_> i look forward to your results =)
13:20:58 <p_l> Baughn: Windows 1.0 encoded bit-fiddling instructions in options passed to drawing instructions :D
13:23:00 <mmorrow> sounds to me like this whole GPU thing is just the graphics card companies seeing a business opportunity and jumping on it with mass marketing assaults, rather than any coherent or principled effort to make something that's actually usable
13:24:26 <copumpkin> mmorrow: get back with the groupthink kthx
13:24:31 <copumpkin> or the thoughtpolice will be after you
13:24:40 <mmorrow> hehe
13:25:28 <Berengal> Not drooling over 1024 concurrent threads is the definition of not geek
13:25:57 <copumpkin> pfff
13:26:17 <copumpkin> with my haskill I can spew out millions of threads in the blink of an eye!
13:26:48 <Berengal> copumpkin, concurrent? Or secretly serialized behind your back by the dastardly runtime and/or kernel?
13:26:49 <Baughn> Berengal: Hm. Mine has.. 216 cores... of 16 threads each
13:27:01 <copumpkin> Berengal: I have an infinite-core cpu
13:27:09 <mmorrow> fix (\o -> mapM_ forkIO [o,o])
13:27:10 <jfoutz> zeta haskell on a graphics card, rather than zeta lisp on a connection machine?
13:27:33 <Baughn> Berengal: That's more concurrency than I thought. *blink*
13:27:37 <arjanb> just have patience for a few years, they will end up competing on making things accessible when get to the point of being lots of general purpose heavily threaded data parallel cores
13:27:53 <Baughn> arjanb: That's what OpenCL basically is
13:28:00 <Baughn> Intel is betting on a more x86-like GPU architecture
13:28:06 * mmorrow killall -9's ghc
13:28:09 <Berengal> 240:80:32 vertex/geometry/pixel
13:28:29 <Baughn> Berengal: Not unified?
13:28:46 <copumpkin> strength + Data.(Int)Map = very handy
13:28:55 <ni|> i want ghc on plan9
13:28:59 <ni|> :D
13:29:01 <arjanb> Baughn: opencl will keep compilers and lower level stuff closed
13:29:09 <Elly> you will probably need to port gcc first, ni|
13:29:19 <Berengal> Baughn, oh, no, 240 shaders total, then texture mapping units and output units
13:29:26 <Baughn> Berengal: No.. you mentioned having a 280. That's 240 vertex/geometry/pixel, 80 texture-mapping and 32 "render output", whatever that is
13:29:28 <Berengal> Baughn, I failed at reading comprehension for a second
13:29:38 <Berengal> > 240 * 16
13:29:40 <lambdabot>   3840
13:29:43 <Astrobe> why doesn't haskell (and erlang) perform better on quadcores in the shootout benchmarks?
13:29:45 <mmorrow> it seems like until they specify the instruction set and encoding for a given gpu, the only assemblers/etc that can exist are the manufacturer's ones though
13:29:46 * Berengal gasps
13:30:05 <Baughn> Berengal: Well, it's still only 240 simultaneous threads, though. :P
13:30:14 <Berengal> mmorrow, please make them not do that. We don't want another x86
13:30:47 <copumpkin> there should be an iterate'
13:30:56 <erikc> i prefer the IL approach nvidia is taking with PTX
13:31:11 <Berengal> Baughn, but still, 16x virtual threads per core is much better than 16x threads per core organized purely by the kernel
13:31:15 <mmorrow> gah, accidental ^Q
13:31:31 <Baughn> Certainly.
13:32:05 <mmorrow> Berengal: imagine x86, only more convoluted and without a spec for the instruction set or encoding of it! oh wait! :)
13:32:38 <Berengal> mmorrow, at least it'll be replaced in 6 months
13:32:43 <mmorrow> hehe
13:32:48 <Astrobe> why doesn't haskell (and erlang BTW) perform better on quadcores in the shootout benchmarks?
13:32:49 <Berengal> We won't have to wait 30+ years
13:33:50 <erikc> a low level IL for an abstract machine is the right way to go
13:33:52 <Saizan> Astrobe: istr most benchmarks are not easily parallelizable
13:33:57 <erikc> let them compete on making it run fast on their hardware
13:34:31 <erikc> otherwise, the ISA you standardize turns into a low level IL for an abstract machine (x86 :)
13:34:46 <erikc> and you gotta implement the translator in hardware
13:35:04 <mmorrow> erikc: as long as you can go from String -> [Word8]
13:35:10 <erikc> right
13:35:12 <erikc> agreed
13:35:20 <mmorrow> -> IO () without needing any other software
13:35:23 <erikc> but you can do that with nvidia today using the PTX spec
13:35:25 <mmorrow> i'm hesitant
13:35:27 <erikc> and CUDA
13:35:42 <erikc> (nvidia only of course)
13:36:04 <copumpkin> dammit, I painted myself into a corner
13:36:07 <erikc> i wish they'd standardize on something like PTX instead of a language
13:36:11 <_-jn> Quick question: when you use map, is there an easy way of traversing the list from right to left in the mapping?
13:36:13 <erikc> for OpenCL
13:36:26 <copumpkin> _-jn: why does it matter?
13:36:27 <erikc> but they can also build that into the OpenCL spec i suppose
13:36:29 <Astrobe> Saizan:  ok...
13:36:37 <mmorrow> erikc: so you can encode a program in the actual binary encoding the gpu(s) expect, then execute it (without needing manufacturer-provided software/etc)?
13:36:51 <mmorrow> (with CUDA)
13:37:07 <copumpkin> _-jn: mapping doesn't have any context, so in theory for all you care, it could be done from the middle outwards, alternatinv even and odd elements, and you wouldn't care
13:37:14 <copumpkin> _-jn: or did you mean mapM?
13:37:33 <Astrobe> then why are these guys trying to scratch more threads in the GPU?
13:37:34 <_-jn> yes, I mean mapM_
13:37:40 <mmorrow> a better way to put it i guess is that unless it's possible for e.g. gas to target it, it sounds sketchy to me
13:37:41 <erikc> mmorrow: i'd have to check the details, you can generate a PTX binary object and use the nvidia C 'driver api' to execute it
13:37:44 <jfoutz> _-jn: the easiest way is to reverse the list.
13:38:05 <erikc> they have a PTX assembler for String -> [Word8], or you can write your own cause the object format is standardized
13:38:12 <mmorrow> erikc: ah, hmm ok.
13:38:17 <copumpkin> @let pamM f = mapM f . reverse
13:38:19 <lambdabot>  Defined.
13:38:35 <_-jn> ok, thanks !
13:39:04 <benmachine> @ty pamM
13:39:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:39:12 <luite> I wonder if these specialized language will still be necessary if future gpu's are more like larrabee
13:39:45 <erikc> mmorrow: sorry, looking ath the ptx isa now, i think i talked out of my ass, it doesnt looke like they standardized the object code rep
13:39:58 <erikc> they supply the assembler to get there
13:40:03 <erikc> and the asm is standardized
13:40:18 <erikc> (naturally, ppl have written disassemblers already)
13:41:19 <deech`> Hi all, I have a TVar Int variable that should be empty until a user populates it. The only options I can see for setting the initial value is something like 'newTVar -1' or 'newTVar undefined' followed by a lot of boilerplate error-checking in functions that use that TVar. Are there any other options?
13:41:52 <mauke> TVar (Maybe Int)
13:42:38 <deech`> mauke: Yeah, but still a lot of 'case x of Just a -> ...' type code, right?
13:42:51 <mmorrow> burp: nice, just opened that pdf link, looks informative
13:42:56 <erikc> nvidia is hiring compiler ppl like crazy these days
13:42:59 <Saizan> deech`: TMVar
13:43:17 <erikc> mmorrow: the ptx isa?
13:43:45 <deech`> Saizan: cool :) thanks!
13:45:12 <copumpkin> @let _ = 5 in _
13:45:12 <lambdabot>   Parse error
13:45:30 <mmorrow> erikc: http://graphics.cs.williams.edu/archive/SweeneyHPG2009/TimHPG2009.pdf
13:45:38 <erikc> o, rite
13:46:02 <mmorrow> it took me a while to find where the firefox "what do you want to do with this file" window came from..
13:46:09 <erikc> haha
13:46:59 * mmorrow googles for PTX too
13:51:05 <erikc> http://www.nvidia.com/content/CUDA-ptx_isa_1.4.pdf
13:54:42 <mmorrow> erikc: PTX seems like a nice step
14:04:58 <Phyx-> hmm is there a way to "extend" ghc to support custom derivations?
14:05:10 <mmorrow> burp, erikc: that pdf is really nice
14:05:16 <mreh> :t ($)
14:05:18 <lambdabot> forall a b. (a -> b) -> a -> b
14:05:32 <mmorrow> (TimHPG2009.pdf)
14:06:21 <mreh> :t (`$`1)
14:06:22 <lambdabot> parse error on input `$'
14:06:59 <mreh> how can I apply a single argument to a list of functions?
14:08:20 <monochrom> > map ($ a) [f,g,h] :: [Expr]
14:08:22 <lambdabot>   [f a,g a,h a]
14:08:26 <monochrom> Like that?
14:09:01 <monochrom> (Don't you love uncastrated higher-order functions? :) )
14:10:12 <mreh> > $ a f
14:10:13 <lambdabot>   <no location info>: parse error on input `$'
14:10:24 <mreh> :(
14:10:28 <monochrom> Do you know how to read ($ a)?
14:10:31 <arjanb> mmorrow: see also LtU thread about that: http://lambda-the-ultimate.org/node/3560
14:10:33 <mreh> > `$` a f
14:10:35 <lambdabot>   <no location info>: parse error on input ``'
14:10:38 <mreh> yeah
14:10:44 <edwardk_> mreh ($) is an operator, ($ a) is a right section
14:10:46 <mreh> $ is the lowest precedence
14:10:50 <edwardk_> ($ a) f = f $ a
14:10:59 <edwardk_> just like (+ 2) 3 = 3 + 2
14:11:04 <mreh> i know sections
14:11:04 <monochrom> Like (* 5) 4 = 4*5
14:11:14 <mreh> so $ is infix then
14:11:18 <edwardk_> yeah
14:11:42 <mreh> ($) f a
14:11:43 <mreh> > ($) f a
14:11:44 <edwardk_> ($) = id is just camped out in the prelude somewhere
14:11:50 <lambdabot>   Add a type signature
14:11:52 <hackagebot> magic 1.0.8 - Interface to C file/magic library (JohnGoerzen)
14:12:01 <monochrom> Add the ":: Expr" type signature
14:12:06 <mauke> > sequence [f,g,h] x :: [Expr]
14:12:08 <lambdabot>   Ambiguous occurrence `x'
14:12:08 <lambdabot>  It could refer to either `L.x', defined at <local...
14:12:11 <mauke> @define
14:12:14 <mauke> > sequence [f,g,h] x :: [Expr]
14:12:15 <lambdabot>   [f x,g x,h x]
14:12:27 <edwardk_> > ($) f a :: Expr
14:12:28 <mreh> @src sequence
14:12:29 <lambdabot> sequence []     = return []
14:12:29 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:12:29 <lambdabot> --OR
14:12:29 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:12:29 <lambdabot>   f a
14:12:59 <mreh> righty ho
14:13:09 <Phyx-> @hoogle typeInfo
14:13:09 <lambdabot> No results found
14:13:21 <mreh> i've got a list of functions to apply!
14:13:33 <endojelly> mreh, that's nice!
14:13:38 <endojelly> :t ($)
14:13:39 <lambdabot> forall a b. (a -> b) -> a -> b
14:13:58 <endojelly> :t map ($)
14:13:59 <lambdabot> forall a b. [a -> b] -> [a -> b]
14:14:20 * mreh brane asplode
14:14:34 <mreh> it'll be a while before I can read these intuitively
14:14:48 <endojelly> I did it wrong
14:14:53 <endojelly> :t map (flip ($))
14:14:55 <lambdabot> forall a b. [a] -> [(a -> b) -> b]
14:15:08 <endojelly> sheesh.
14:15:14 <monochrom> You can calculate the code from the desired result.
14:15:31 <mauke> well, since ($) = id, map ($) is just map id, which is just id
14:16:10 <monochrom> Want [f a, g a, h a]. [f a, g a, h a] = [f$a, g$a, h$a] = [($a)f, ($a)g, ($a)h] = map ($a) [f,g,h].
14:16:11 <endojelly> hahah, i'm so stupid
14:16:19 <endojelly> :t map ($ a)
14:16:20 <lambdabot> forall b. [Expr -> b] -> [b]
14:16:27 <endojelly> THAT'S what I want.
14:16:46 <endojelly> :t \x -> map ($ x)
14:16:47 <lambdabot> forall a b. a -> [a -> b] -> [b]
14:16:51 <endojelly> right!
14:16:56 <monochrom> If you did not know of $, you could still calculate: f a = (\k -> k a) f. Then you get map (\k -> k a) [f,g,h].
14:16:57 <mreh> we just did that
14:17:02 <endojelly> forgot what to apply the function to
14:17:06 <monochrom> All you need is refactoring skill.
14:17:26 <endojelly> monochrom, yeah, I thought of the lambda, but thought it must be possible without
14:17:37 <endojelly> just forgot to section the $
14:17:44 <monochrom> I almost never intuit any more. I just calculate. The above is exactly my thought process.
14:17:47 <mreh> ill section you
14:20:18 <purplepenguins> anything a function can do, a lambda can do, but usually messier
14:21:43 <Phyx-> hmm is there a way to "extend" ghc to support custom derivations without using TH?
14:21:46 <Cale> Not necessarily, of course. There's no reason to give a name to many functions.
14:22:11 <Cale> Phyx-: not without modifying GHC itself
14:22:52 <Phyx-> Cale: that sucks.. guess i'll do it in the preprocessor, thanks
14:23:15 <monochrom> Haskell2046 will feature the module Prelude.Twitter for giving names to all functions implemented in 140 tokens or less.
14:23:56 <monochrom> Because every newbie comes in and say "why isn't this little function in the prelude?"
14:24:19 <purplepenguins> so that the prelude isn't huge and bloated
14:24:28 <mauke> I've solved the problem of function naming, btw
14:24:39 <jkramer> Hello again
14:24:41 <mauke> just use the SHA-1 hash of the function body
14:24:49 <jkramer> Is there something like a lazy repeat for monads?
14:24:57 <Phyx-> monochrom: LOL
14:25:04 <purplepenguins> :t repeat
14:25:04 <monochrom> I like the ACM solution much more. "ACM Algorithm #483".
14:25:06 <jkramer> I'm looking for (IO a) -> IO [a]
14:25:06 <lambdabot> forall a. a -> [a]
14:25:09 <Saizan_> jkramer: what would the type be?
14:25:16 <endojelly> why is unsafeConnectRemoteTerminalServerAndGrabKeyboard not in the prelude?
14:25:22 <luite> monochrom: with 140 characters and some clever encoding, you could probably encode most of those functions directly
14:25:23 <jkramer> hoogle only finds replicateM
14:25:28 <purplepenguins> is that just "make an infinite list of a"
14:25:31 <luite> most function bodies
14:25:32 <mauke> jkramer: that looks unsafe
14:25:43 <jkramer> I want an infinite list of random numbers
14:25:51 <mauke> jkramer: you don't need IO for that
14:25:55 <sbahra> mauke, SHA-1 is being phased out.
14:25:56 <Saizan_> ?type randoms
14:25:58 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
14:26:04 <monochrom> Don't use IO for infinite list of random numbers.
14:26:07 <Cale> :t newStdGen
14:26:08 <lambdabot> IO StdGen
14:26:10 <purplepenguins> :t lift
14:26:12 <endojelly> why is unsafePhaseOutSHA1Globally not in the Prelude?
14:26:12 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
14:26:14 <Saizan_> > rnadoms (mkStdGen 42)
14:26:16 <lambdabot>   Not in scope: `rnadoms'
14:26:19 <Saizan_> > randoms (mkStdGen 42)
14:26:21 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
14:26:23 <Cale> You probably want to use IO to get the StdGen to begin with though
14:26:29 <endojelly> why is rnadoms not in the Prelude?
14:26:33 <endojelly> ok, I'll stop now 8)
14:26:33 <Philonous> The type checker is a weird gal. g f :: Fractional t => (t->t) typechecks, f has type Fracional t => t-> t, but g :: Fractional t (t->t) -> t -> t doesn't type check.
14:26:33 <Cale> mkStdGen will give you the same infinite sequence every time.
14:26:36 <purplepenguins> hmm, existential qualifiers make some type signatures more confusing to read
14:26:42 <Cale> endojelly: because it's in System.Random
14:27:00 <monochrom> At most use newStdGen to get a generator from IO. But do it pure beyond that.
14:27:25 <jkramer> So randoms gives me an infinite list?
14:27:33 <Saizan_> yes
14:27:37 <endojelly> Cale, no, that was a joke because of "23:26 < lambdabot>   Not in scope: `rnadoms'"
14:27:44 <endojelly> Cale, nevermind
14:27:46 <jkramer> Nice, thanks
14:27:46 <Cale> ah
14:28:21 <monochrom> A joke on the previous context of "why is ___ not in the prelude?"
14:29:16 <c_wraith> why is fix not in the prelude? :)
14:29:46 <harlekin> Is Haskell capable of handling 10 000 or even more simple IO Threads simultaneously or is such a number just too big?
14:29:56 <mauke> harlekin: 10000 is nothing
14:30:13 <monochrom> I wonder if there is unfix :: a->(a->a), from a value re-invent a function whose fixed point is that value, fix (unfix x) = x.
14:30:27 <monochrom> Oh haha but const may already do it.
14:30:30 <Cale> unfix = const
14:30:31 <Cale> right
14:30:34 <mauke> harlekin: last time I tried it had no problems with 450000 threads
14:30:47 <harlekin> mauke, I am using STM in the threads and TArrays. Having 10.000 threads my CPU usage goes to 100%. What would be the problem then? STM or TArray?
14:30:52 <mauke> fix = unconst :-)
14:30:59 <monochrom> OK, unfix (fix f) = f is the hard one. :)
14:31:04 <mauke> harlekin: no idea
14:31:04 <harlekin> Every thread is atomically changing a value in the array.
14:31:17 <harlekin> mauke, ok. Think I'll have to investigate this further tomorrow. :)
14:31:17 <jmcarthur_work> your cpu usage better get really high if you are using 10,000 threads ;)
14:31:26 <Cale> harlekin: It's only natural that your CPU usage would go to 100%. If it was only being used 50%, something would be wrong.
14:31:32 <benmachine> monochrom: don't you lose information about f by fixing it?
14:31:36 <mauke> I used http://mauke.ath.cx/stuff/haskell/stress.hs
14:31:48 <harlekin> They should be sleeping most of the sime (using threadDelay).
14:32:02 <monochrom> I guess it's hopeless.
14:32:09 <harlekin> mauke, thanks. Maybe I can use this as a start and then add my functionality.
14:32:09 <Cale> harlekin: Some are probably awake all the time.
14:32:23 <Cale> How long are the delays?
14:32:25 <harlekin> Cale, that'd then probably due to STM, right?
14:32:37 <harlekin> 1 second.
14:33:03 <Cale> harlekin: and do you know how long the threads wake up for?
14:33:32 <harlekin> Cale, they are just changing one value in TArray. That shouldn't take too long. But I don't know exactly.
14:33:59 <harlekin> If they are awake more than 1/10.000s I have a problem, I guess.
14:34:01 <Cale> harlekin: hmm
14:34:50 <Plouj> yo, homies
14:34:54 <Plouj> what's the use of fromIntegral?
14:35:05 <mauke> converting from integral types
14:35:13 <Cale> Plouj: to convert any integer-like number to any numeric type at all
14:35:16 <c_wraith> It converts any Integral type to any Num type.  >_>
14:35:23 <Plouj> specifically, why is it used in parseBytes http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html#id627853
14:35:23 <c_wraith> There really isn't much else to say about it.
14:35:24 <Cale> > fromIntegral (5 :: Word8) :: Float
14:35:26 <lambdabot>   5.0
14:35:34 <Plouj> what's the point of this any to any conversion?
14:35:42 <Plouj> why doesn't it specify what the resulting type is?
14:36:01 <mauke> because it doesn't have to
14:36:02 <Cale> Plouj: The resulting type is determined by context, or explicitly if you give a type signature.
14:36:11 <Plouj> Cale: ok, I just realized that when I asked it :)
14:36:30 <mauke> what's the type of L.splitAt?
14:36:37 <Cale> :t splitAt
14:36:38 <lambdabot> forall a. Int -> [a] -> ([a], [a])
14:36:51 <mauke> ...
14:37:00 <hackagebot> MissingH 1.1.0.1 - Large utility library (JohnGoerzen)
14:37:05 <Cale> oh, perhaps that's Data.ByteString.Lazy or something?
14:37:07 <c_wraith> Anyway, you use fromIntegral when some library gives you an integral type, and you need a different numeric type for the processing you intend to do
14:37:21 <Cale> import qualified Data.ByteString.Lazy as L
14:37:29 <Cale> :t Data.ByteString.Lazy.splitAt
14:37:30 <lambdabot> Int64 -> BSLC.ByteString -> (BSLC.ByteString, BSLC.ByteString)
14:37:38 <mauke> Plouj: L.splitAt takes an Int64, not an Int
14:37:42 <Cale> aha, Int64
14:37:50 <Plouj> so, it's basically a general "cast"
14:38:00 <Plouj> so that I don't have to worry about the different integer types in my code?
14:38:13 <c_wraith> It's a conversion function between the two integer types.
14:38:15 <Plouj> whether I use L.splitAt or another splitAt
14:38:17 <c_wraith> Best to think of it that way
14:38:23 <mauke> if you think casts exist so you don't have to worry about types, you're doing it wrong
14:38:26 <c_wraith> "casting" has other connotations in many contexts
14:38:48 <Plouj> I mean in that parseByte example
14:38:56 <c_wraith> Generally, "casting" implies telling the type system you're smarter than it is.  (Which is often true in C++ or Java)
14:39:28 <c_wraith> fromIntegral, on the other hand, is about saying "convert this to the type you need.  I don't care how you do it, just do it correctly"
14:39:34 <Plouj> I guess fromIntegral is used so that I don't have to explicitly change the type of the first argument based on what splitAt function I end up using
14:40:19 <purplepenguins> in C and Java the type system is less smart than you, in Haskell the type system has a Ph.D
14:40:35 <copumpkin> having a PhD doesn't make you smart ;)
14:40:39 <copumpkin> ...sadly
14:40:47 <purplepenguins> no, it doesn't, but it's certainly more arrogant
14:41:07 <copumpkin> haskell has a casting function too ;)
14:41:11 <purplepenguins> Haskell will gladly point out the error of your mismatched types
14:41:31 <c_wraith> yes.  haskell's casting function is a good way to corrupt memory. :)
14:41:43 <mauke> :t cast
14:41:45 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
14:41:49 <copumpkin> or that
14:41:52 <sbahra> Interesting.
14:42:00 <copumpkin> but I wasn't thinking of cast :P
14:42:07 <Valodim> casting is dead. coercing is where it's at
14:42:15 <endojelly> :t unsafeCoerce
14:42:16 <lambdabot> Not in scope: `unsafeCoerce'
14:42:16 <mauke> cörcing
14:42:22 <copumpkin> @let safeCoerce = cast
14:42:24 <lambdabot>  Defined.
14:42:27 <Plouj> mauke: so, my question is, why doesn't parseByte accept an Int64 right away?
14:42:28 <sbahra> heh
14:42:29 <endojelly> was that not how it's called?
14:42:39 <mauke> Plouj: don't ask me, I don't think
14:42:40 <endojelly> just not imported I guess?
14:42:41 <copumpkin> @hoogle unsafecoerce
14:42:42 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:42:44 <copumpkin> yeah :)
14:43:07 <Plouj> is mauke a bot?
14:43:14 <endojelly> :t undefined
14:43:15 <lambdabot> forall a. a
14:43:20 <mauke> preflex: 8ball am I a bot?
14:43:20 <Phyx-> Plouj: in some ways yes
14:43:21 <preflex>  yes - definitely
14:43:27 <endojelly> :t \x -> undefined
14:43:28 <lambdabot> forall t a. t -> a
14:43:38 <Plouj> does anyone have other suggestions?
14:43:39 <mauke> :t undefined :: a -> b
14:43:40 <sbahra> preflex: 8ball is mauke a bot?
14:43:40 <preflex>  very doubtful
14:43:41 <lambdabot> forall a b. a -> b
14:44:06 <endojelly> :t undefined :: IO String -> String
14:44:08 <lambdabot> IO String -> String
14:44:21 <mauke> @let a === b = cast a == Just b
14:44:22 <lambdabot>  Defined.
14:44:26 <mauke> > () === 'x'
14:44:29 <lambdabot>   False
14:44:35 <endojelly> :t Unsafe.Coerce.unsafeCoerce :: IO String -> String
14:44:37 <lambdabot> IO String -> String
14:44:39 <endojelly> so much fun.
14:44:48 <mauke> > () === ()
14:44:50 <lambdabot>   True
14:44:52 <Phyx-> wth is ===
14:44:52 <purplepenguins> :t (===)
14:44:54 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
14:44:55 <sbahra> endojelly, heh
14:45:05 <mauke> Phyx-: open eyes, apply to channel
14:45:09 <purplepenguins> hmm, what is Typeable...
14:45:16 <sbahra> > 1 === 'b'
14:45:16 <Phyx-> mauke: eh?
14:45:18 <lambdabot>   False
14:45:21 <sbahra> > 1 === 1
14:45:21 <mauke> Phyx-: I just defined it
14:45:23 <lambdabot>   True
14:45:33 <endojelly> I only know Typeable in the context of Scrap Your Boilerplate
14:45:34 <endojelly> which is awesome
14:45:35 <Phyx-> mauke: oh, i'm jumping in and out of here, sorry
14:45:35 <sbahra> > 'a' === 'a'
14:45:36 <Phyx-> odd instance
14:45:42 <Phyx-> so only b has to be an Eq
14:45:47 <lambdabot>   True
14:45:48 <sbahra> That is pretty insane.
14:45:50 <copumpkin> Phyx-: well
14:46:03 * sbahra hasn't written a Haskell program in around 2 months now
14:46:07 <Phyx-> is that even needed? if you have Typeable shouldn't you be able to without the Eq b at all?
14:46:07 <benmachine> > 1 === 1.0
14:46:08 <sbahra> @src (===)
14:46:08 <copumpkin> Phyx-: it'll return False if they're different types, and if they're the same type, then if b is Eq, so is a
14:46:08 <lambdabot> Source not found. Are you on drugs?
14:46:09 <lambdabot>   False
14:46:15 <sbahra> @hoogle (===)
14:46:16 <lambdabot> No results found
14:46:25 <sbahra> Oh, mauke defined it.
14:46:27 <endojelly> > id === ()
14:46:27 <sbahra> haha
14:46:29 <lambdabot>   Add a type signature
14:46:32 <copumpkin> Phyx-: make sense?
14:46:34 <reppie> finding ways to say nothing
14:46:36 <Phyx-> copumpkin: yup
14:46:43 <sbahra> Hi reppie
14:46:43 <endojelly> > (id :: a -> a) === ()
14:46:44 <lambdabot>   Add a type signature
14:46:50 <reppie> Hi.
14:46:53 <copumpkin> you can't have a polymorphic instance
14:46:57 <endojelly> > (id :: Int -> Int) === ()
14:46:58 <copumpkin> at least not in that sense
14:46:59 <lambdabot>   False
14:47:05 <endojelly> > (id :: Int -> Int) === (id :: Int -> Int)
14:47:06 <lambdabot>   No instance for (GHC.Classes.Eq (GHC.Types.Int -> GHC.Types.Int))
14:47:07 <lambdabot>    arisin...
14:47:19 <endojelly> hm, makes sense
14:47:20 <copumpkin> endojelly: you need my module ;)
14:47:38 <endojelly> copumpkin, your module implements an Eq instance for functions? oO
14:47:41 <copumpkin> @hackage enumerable
14:47:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/enumerable
14:48:23 <copumpkin> just import Data.Enumerable.FunctionEquality (or the controversial one if you're feeling controversial) and run that code again
14:48:28 <copumpkin> :P
14:48:31 <endojelly> ooh
14:48:44 <sbahra> copumpkin, cool
14:48:57 <copumpkin> :)
14:49:04 <copumpkin> I don't make any claims about efficiency though ;)
14:49:09 <philed> What are your semantics for function equality?
14:49:22 * Phyx- would like to know those too
14:49:23 <copumpkin> in fact, many of those instances don't terminate or have exponential time
14:49:26 <endojelly> copumpkin, fun
14:49:45 <mauke> f == g <=> f x == g x ∀x
14:49:46 <endojelly> :t liftA2
14:49:48 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
14:49:53 <sbahra> philed, could only guess. :-)
14:50:03 <copumpkin> what mauke said :)
14:50:47 * Phyx- scratches head
14:51:03 <copumpkin> Phyx-: it basically walks over the entire domain and checks if the output is the same
14:51:08 <copumpkin> if so, the functions are equal
14:51:10 <copumpkin> otherwise, they aren't
14:51:22 <copumpkin> if the domain is infinite, then it tries anyway (assuming the controversial version)
14:51:24 <Phyx-> copumpkin: that sounds insane.
14:51:27 <purplepenguins> that sounds a bit...tedious
14:51:32 <copumpkin> that allows you to do (+) == (-) and get False
14:51:36 <copumpkin> or even == odd
14:51:49 <copumpkin> but even == even won't terminate unless you constrain it to something other than Integer
14:52:07 <Phyx-> how does it generate values to pass to the functions from the domain?
14:52:15 <copumpkin> the Enumerable class that's in that package
14:52:23 <Phyx-> ah ok
14:52:34 <copumpkin> gotta run, bbl :)
14:52:39 <Phyx-> do you have to specify how it has to generate them like quickcheck?
14:52:42 <Phyx-> ok :)
14:52:44 <philed> copumkin: You should be running a proof for eta-beta equivalence.
14:53:06 <endojelly> philed, I guess that's where Enumerable comes into play
14:53:29 <endojelly> the instance specify how to enumerate them
14:53:31 <sbahra> @hoogle cast
14:53:32 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
14:53:32 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
14:53:32 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
14:54:10 <Phyx-> ah
14:54:16 <Phyx-> CChar.. i missed one
14:55:40 <sbahra> philed, how would you do that in Haskell?
14:56:15 <mauke> > x ^ 5
14:56:17 <lambdabot>   x * x * (x * x) * x
14:56:29 <philed> sbahra: Tongue in cheek. You'd need to have the expressions defining the function.
14:56:36 <Phyx-> why the (x * x)
14:56:48 <Phyx-> all the operators have the same precidence don't they
14:56:54 <mauke> because it's actually let y = x * x in y * y * x
14:57:48 <sbahra> > x ^ 4
14:57:49 <lambdabot>   x * x * (x * x)
14:58:44 <Phyx-> mauke: i'm still missing something then, shouldn't the first two have braces around then then? instead of just one?
14:58:47 <jkramer> Is there something like take, but from the end of the list?
14:59:01 <benmachine> Phyx-: those two are done first anyway
14:59:08 <Berengal> jkramer, foldr
14:59:14 <Berengal> -ish
14:59:18 <benmachine> because * is infixl
14:59:55 <jkramer> Berengal: foldr? I just want the last x elements of a list
15:00:01 <Berengal> > x ^ 16
15:00:03 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))
15:00:03 <jkramer> Like take, but from the end
15:00:12 <Philonous> I'd like to define a function inductively over the arity of it's argument. Can I have a class instance that applies to all non-function types?
15:00:15 <jkramer> Hmm, stupid
15:00:26 <Berengal> jkramer, takeWhile foo . reverse if you want the simple version
15:00:27 <jkramer> reverse + take should do it :)
15:00:31 <Heffalump> Philonous: not without overlapping instances
15:00:57 <Phyx-> benmachine: i'm just refering to how it outputed it
15:01:12 <Phyx-> in the case it wouldn't matter, since the operations are all the same precidence and infix
15:01:13 <Philonous> Heffalump: How bad would it be to use overlapping instances for this?
15:01:17 <benmachine> Phyx-: presumably it brackets things as little as possible to still be correct
15:01:29 <Phyx-> i'm just saying i expected it to be (x * x) * (x * x) * x
15:01:47 <mauke> Phyx-: the first parens are redundant
15:01:50 <sbahra> ?
15:01:53 <benmachine> yeah but that's calculated in the same way as x * x * (x * x) * x
15:01:59 <benmachine> in terms of the order of the multiplications
15:02:07 <Heffalump> Philonous: depends on what you're trying to achieve. In my experience overlapping instances work ok, but often require apparently meaningless class contexts on polymorphic functions just so that the appropriate dictionary gets chosen by the calling context.
15:02:11 <Wavewash> This room is booming, had no idea so many people would be here.
15:02:56 <tommd> Wavewash: Welcome.  Once you are assimilated you will grow accustom to the voices.
15:03:11 <Wavewash> Ha.
15:03:13 <Phyx-> benmachine: which is calculated the same way as just x * x * x * x * x, so why drop 1 paren and noth both
15:03:17 <Phyx-> that is my question
15:03:18 <Phyx-> lol
15:03:41 <mauke> Phyx-: no, that one is calculated differently
15:03:47 <purplepenguins> i would totally join the haskell collective
15:03:48 <Wavewash> Anyone here know Shae? I'm not sure what his handle is.
15:03:54 <Heffalump> Wavewash: shapr
15:03:56 <mauke> preflex: seen shapr
15:03:57 <preflex>  shapr was last seen on #haskell-blah 1 day, 7 hours, 38 minutes and 43 seconds ago, saying: AXÉ!
15:04:08 <Wavewash> Awesome, thank you.
15:04:24 <benmachine> Phyx-: suppose x is 5
15:04:24 <mauke> Phyx-: yours is equivalent to (((x * x) * x) * x) * x
15:04:31 <sbahra> Phyx-, step through x^5.
15:04:38 <benmachine> the bracketing says, multiply 25 * 25 * 5
15:04:40 <mauke> lambdabot's version is equivalent to ((x * x) * (x * x)) * x
15:04:47 <benmachine> whereas your way is 125 * 5 * 5
15:05:01 <benmachine> ish
15:05:28 <sbahra> mauke, x * x * (x * x) * x, so (x * x) is evaluated.
15:05:29 <sbahra> err
15:05:36 <sbahra> Phyx-, to you.
15:05:43 <jmcarthur_work> lambdabot can't tell that * is associative, i guess
15:06:03 <jmcarthur_work> and yeah, they do evaluate differently
15:06:48 <Phyx-> only in order, the answer should be the same, but my question is, is y was x - x, would labmda bot still drop both brackets, in which case the answer wouldn't be the same, since multiplication has higher precidence
15:07:03 <benmachine> Phyx-: it would do it right :P
15:07:17 <benmachine> Phyx-: the brackets are generated by the definition of (^)
15:07:34 <jmcarthur_work> Phyx-, performance will be different, as well
15:07:34 <mauke> @src (^)
15:07:35 <lambdabot> x ^ 0            =  1
15:07:35 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
15:07:35 <lambdabot>   where f _ 0 y = y
15:07:36 <lambdabot>         f x n y = g x n
15:07:38 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
15:07:40 <lambdabot>                       | otherwise = f x (n-1) (x*y)
15:07:42 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
15:07:55 <Plouj> well
15:08:36 <jmcarthur_work> product (replicate 999999 5)    will probably take longer than   5^999999
15:08:44 <Plouj> is anyone gonna tell me why parseBytes uses fromIntegral instead of just switching the first argument type to match splitAt in http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html#id627853
15:08:57 <jmcarthur_work> Plouj, genericity?
15:09:07 <Phyx-> jmcarthur_work: right, i know that, multiplying smaller numbers, i suppose my question was coming down to what (^) did
15:09:11 <Phyx-> and mauke jus showed me :)
15:09:24 <Plouj> jmcarthur_work: is it? I don't know. That would be my guess, but I'm just a beginner.
15:09:58 <sbahra> @src (**)
15:09:58 <lambdabot> Source not found. That's something I cannot allow to happen.
15:10:14 <sbahra> > 2 ** (-2)
15:10:17 <lambdabot>   0.25
15:10:52 <jmcarthur_work> :t splitAt
15:10:54 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:11:11 <Philonous> Heffalump: I'm sorry, but I asked the wrong question. The real question was: can I have a class, whose only instances are all the non-function types
15:11:12 <c_wraith> :t (**)
15:11:14 <lambdabot> forall a. (Floating a) => a -> a -> a
15:11:42 <dons> i wish there was "haskell certification"
15:11:48 <dons> that would make hiring interviews so much easier
15:12:01 <dons> dcoutts: Well-Typed should offer it :)
15:12:01 <jmcarthur_work> Plouj, if the authors had left the type signature off, then parseBytes could have type Num a => a -> Parse L.ByteString, rather than being stuck with Int
15:12:02 <c_wraith> haha.  part 12: write a monad tutorial.
15:12:17 <dons> well, picking an appropriate monadic abstraction would be part of it.
15:12:19 <dcoutts> dons: heh heh
15:12:26 <dcoutts> dons: well we do Haskell training
15:12:26 <jmcarthur_work> Plouj, they probably had the fromIntegral in the definition from before they restricted the type
15:12:27 <dons> you'd need to recognise, say, State, StateT, Reader.
15:12:43 * dcoutts has taught Haskell to Python hackers
15:12:45 <c_wraith> anyway, dons.  You hired a guy from my company.
15:12:46 <jfoutz> dons: ask for a portfolio. coming up with 100 lines of nice thought out code is not an unreasonable thing to ask for.
15:12:48 <c_wraith> :)
15:12:53 * Phyx- thinks most certifications these days are a fraud, more an excersice in studying than actually knowing
15:13:05 <dons> know how to use Hackage, appropriate types, performance tools, networking, smart constructors...
15:13:06 <Plouj> jmcarthur_work: you mean they could just used Integral in parseByte's type?
15:13:08 <dons> c_wraith: oh?
15:13:13 <dons> ah
15:13:14 <c_wraith> I work for JanRain
15:13:20 <dons> yes, I see :)
15:13:33 <jmcarthur_work> Plouj, err, yes
15:13:49 <sbahra> dons, "smart constructors"?
15:13:50 <jmcarthur_work> not Num like i just said. my bad, there
15:13:51 <MarcWeber> dcoutts: You've written much of cabal, correct? Can you help me with this piece? I'd like to make cabal export an install plan to nix. I've patched it this way:  http://dpaste.com/82957/  (line 86ff). However the graph only contains one vertex, why?
15:14:02 <mreh> Is this too hard to understand?: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3368#a3368
15:14:07 <Plouj> dons: what kind of industry do you work in?
15:14:22 <dons> comp. sci. research.
15:14:36 <Plouj> c_wraith: JanRain the one behind openid?
15:14:37 <dons> c_wraith: will the haskell live on at JanRain?
15:14:46 <c_wraith> Plouj: yes
15:14:53 <sbahra> So what do you mean by "smart constructors", dons?
15:15:04 * cygnus is also a JanRainer.
15:15:04 <c_wraith> dons: uncertain.  I can't make a stronger statement than that, I suppose.
15:15:21 <dons> fair enough.
15:15:30 <dons> hey cygnus
15:15:39 * cygnus waves
15:15:55 <jmcarthur_work> dons, is it really that hard to interview candidates for haskell knowledge? i'd imagine it should be pretty easy to trip up somebody who doesn't know that much
15:15:56 <sbahra> http://www.haskell.org/haskellwiki/Smart_constructors
15:15:56 <dons> you guys going to make it to HacPDX next month?
15:16:03 <sbahra> Thanks for ignoring me. :-)
15:16:04 <cygnus> I'm more than likely going to come.
15:16:10 <dons> jmcarthur_work: i'm sure it is easy to trip them up
15:16:14 <dons> sbahra: sorry
15:16:17 <Philonous> sbahra: smart ocnstructors are functions that create Values of a type, like constructors, but do some extra wortk (check dynamic properties etc. )
15:16:17 <sbahra> I didn't know it was referring to a specific concept.
15:16:17 <dons> yes, that's what i mean.
15:16:24 <Philonous> Oh, never mind
15:16:30 <jmcarthur_work> oh you just don't want to waste the time on a pointless interview?
15:16:32 <sbahra> Philonous, thanks.
15:16:42 <Heffalump> dons: /me is not at all convinced by certifications
15:16:47 <dons> jmcarthur_work: i just have to duplicate the 'haskell certification' process for each interview.
15:16:57 <Heffalump> Philonous: well, you can't prevent people creating new instances very easily, but you could
15:16:58 <jmcarthur_work> i see
15:16:59 <dons> a hackage upload or two would also suffice
15:17:41 <jmcarthur_work> sbahra, yeah, typically when you make a smart constructor the point is to not export the real constructor
15:18:12 <jmcarthur_work> that way you can only construct valid structures
15:18:22 <dcoutts> MarcWeber: I see you're not using the public API
15:18:43 <dcoutts> MarcWeber: do you get the full set if you use InstallPlan.toList ?
15:19:30 <MarcWeber> dcoutts: I'm still a bit lost in that code.. So probably I've been abusing it to some degree.. Let me try
15:19:39 <Philonous> Heffalump: What I meant was, I need a base case for iterating over the arguments of a function. I can do it for specific return types, but it would be convenient to have a way of saying case "x is a function " (that's already possible), case "x is a non-function value" (that only works for specific values you write an instance declaration for)
15:19:48 <sbahra> jmcarthur_work, nod
15:19:56 <sbahra> jmcarthur_work, I've used them before.
15:19:56 <dcoutts> MarcWeber: the simplest place to start is to use it's documented API ;-)
15:20:02 <sbahra> jmcarthur_work, I just didn't know they had a name.
15:20:07 <jmcarthur_work> ah :)
15:21:14 <dons> c_wraith, cygnus: btw, we're still hiring. need more haskellers! ... :)
15:21:47 <jmcarthur_work> dons continues to tempt me
15:22:07 * gwern thinks if galois can't get enough haskellers, maybe they need to have a lower bar than 'as studly as dons'
15:23:10 <MarcWeber> dcoutts: no, length of that list is "1" when trying to install transformers depending on "special-functors".
15:23:35 <Heffalump> Philonous: sure. You can do that with an overlapping instance for any type.
15:23:37 <dcoutts> MarcWeber: and which one does it contain?
15:23:45 <Heffalump> And the function type instances will then take precedence.
15:23:57 <MarcWeber> dcoutts: The last target package only.
15:24:05 <MarcWeber> Same for any other package I've tried
15:25:31 <Philonous> Heffalump: Ah, I understand. Well, that doesn't work in my case because I need type families/FunDeps and those don't work with overlapping instances. Thanks anyway.
15:25:50 <dcoutts> MarcWeber: that's hard to understand, one of the validity requirements on install plans is that they include all deps, installed or not, all the way down to base, ghc-prim etc
15:25:57 <Heffalump> Philonous: they don't?
15:26:03 <Heffalump> well, I expect that type families don't
15:26:08 <Heffalump> but I don't see why fundeps don't, per se
15:26:23 <Heffalump> oh, yes, ok, you can't have a useful fundep as well as an overlapping instance
15:26:24 <Philonous> Heffalump: Because then they wouldn't be functional anymore
15:26:38 <Heffalump> yeah
15:28:05 <MarcWeber> dcoutts: Yes: I saw that a vertex can be one of installed, configured or failed pcakage.
15:28:08 <dcoutts> MarcWeber: oh, hmm, you're passing an empty set of installed packages.
15:28:27 <MarcWeber> dcoutts: So all packages should be included, shouldn't they?
15:28:43 <MarcWeber> I tried Nothing (bogous planner, correct) ? Same result
15:29:43 <pcc1> is it possible to get external links in my haddock documentation to point to www.haskell.org?
15:30:19 <dcoutts> MarcWeber: ah, you're passing Nothing
15:30:26 <dcoutts> MarcWeber: not an empty set of packages
15:30:41 <dcoutts> MarcWeber: that's what hugs does because it doesn't know the set of installed packages
15:30:56 <dcoutts> MarcWeber: and for that unfortunate situation we must use the "bogusResolver"
15:31:04 <dcoutts> which is what gives the results you see
15:31:10 <dcoutts> it pretends the package has no deps
15:31:12 <Saizan_> pcc1: yes, use the --html-location= option, if you're using cabal
15:31:33 <dcoutts> MarcWeber: so that it can construct a valid install plan (since install plans require all deps to be taken into account)
15:31:38 <MarcWeber> dcoutts: I should try (Just mempty) ? ..
15:31:43 <dcoutts> MarcWeber: yes
15:32:09 <dcoutts> MarcWeber: though of course you never really have empty, you've always got the packages that come with ghc
15:32:16 <Saizan_> pcc1: like --html-location="http://haskell.org/ghc/docs/latest/html/libraries/\$pkg/"
15:32:24 <dcoutts> MarcWeber: cabal-install cannot resolve the package deps for base, ghc-prim, integer etc.
15:32:24 <MarcWeber> dcoutts: That's why I'm getting an internal error now..
15:32:45 <dcoutts> MarcWeber: is it really an internal error, or a properly reported error?
15:32:53 <pcc1> Saizan_: thanks
15:32:58 <MarcWeber> cabal: internal error: impossible
15:33:06 <dcoutts> ah, that's unfortunate
15:33:10 <MarcWeber> dcoutts: But I'll recheck after adding the ghc internal packages.
15:33:13 <dcoutts> it'll be the problem of base depending on base
15:42:39 <MarcWeber> dcoutts: many thanks. Output looks like this now:  http://dpaste.com/82975/
15:43:37 * Heffalump just made a fresh Debian install and has got darcs unstable, gitit and the platform working nicely on it (with GHC 6.10.4) within a couple of hours. Yay for all the people who've done the work to make it this good.
15:43:39 <MarcWeber> dcoutts: Anyway. You've done a awesome job on these tools!
15:43:59 <Nafai> Heffalump: Awesome
15:44:21 <Nafai> Heffalump: Can't wait until that's all available in a Debian repo somewhere
15:44:28 <Heffalump> it's very close
15:44:40 <Heffalump> well, not gitit
15:44:48 <Nafai> But the platform is the important part
15:44:51 <Heffalump> but darcs is in Debian, and the platform is very nearly there.
15:44:56 <Heffalump> http://wiki.debian.org/Haskell/Platform
15:45:14 <shapr> Wavewash: Hiya!
15:45:38 <Heffalump> right now I have quite a few versions of different packages including some duplication in the user and global pkg dbs
15:45:55 <dcoutts> MarcWeber: looks better
15:45:56 <Heffalump> I think GHC 6.12 and the next platform release (and Debian finishing up their work) will clean that up massively
15:46:04 <dcoutts> MarcWeber: thanks :-)
15:46:12 <dcoutts> MarcWeber: I should make a dot format output
16:02:26 <vashism394> if you guys are bored check out facebook zombies :D - http://apps.facebook.com/zombies/links.php?r=719927515&nref=st
16:04:50 * copumpkin reports the app as spam, see how he feels about that
16:05:28 <copumpkin> wow, "this is a verified facebook app"
16:12:43 <sanders> is there a good guide on Template Haskell that one my reccomend to me.
16:26:56 * lpsmith just read the wiki page for side effects. Ugh. I'll have to think about refining it later.
16:27:24 <lpsmith> http://en.wikipedia.org/wiki/Side_effect_(computer_science)
16:47:49 <tessier> endojelly: You still need a vietnamese translator?
16:48:09 <tessier> endojelly: I speak a little and my wife is fluent.
17:12:55 <kynky> at bottom of http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html , it has line "main = later waitForChildren $" , what module does function later come from?
17:13:42 <jfoutz> i think waitForChilderen is defined in the example.
17:14:00 <skorpan> i thought waitForChildren was a made up function name, like "foo"
17:14:16 <purplepenguins> somebody think of the children!
17:14:27 <jfoutz> yeah, it's 2 functions above the main = ... line.
17:14:38 <shapr> @yow !
17:14:38 <lambdabot> Excuse me, but didn't I tell you there's NO HOPE for the survival of
17:14:38 <lambdabot> OFFSET PRINTING?
17:14:58 <shapr> I think he's right.
17:16:15 <jfoutz> oh. later. /me reads more closely "later" is just made up.
17:16:16 <skorpan> what's offset printing?
17:16:47 <shapr> http://en.wikipedia.org/wiki/Offset_printing
17:17:28 <drdr> Hello
17:17:45 <drdr> is it worth it for me to lern haskell?
17:17:49 <skorpan> no
17:17:52 <jfoutz> yes
17:17:56 <skorpan> NO
17:18:00 <shapr> I think so.
17:18:03 <purplepenguins> yes
17:18:05 <skorpan> ok maybe
17:18:06 <drdr> ide kinda like whys
17:18:08 <drdr> just because i know a lot of outher languaes
17:18:12 <drdr> and i like some of them
17:18:18 <shapr> drdr: Which languages do you know?
17:18:21 <jfoutz> one of us always lies, one of us always tells the truth, one of us stabs people who ask complicated questions.
17:18:23 <drdr> but i still havent found my swiss amry chansaw
17:18:25 <purplepenguins> how many functional languages are on that list drdr
17:18:35 <shapr> jfoutz: oooh
17:18:52 <drdr> @sharp ruby python javascipt html php java c/c++
17:19:00 <skorpan> there are no silver bullets in computer science and even if there was, haskell would so not be it
17:19:02 <Nafai> Hi shapr!
17:19:04 * lambdabot throws some pointy lambdas at ruby python javascipt html php java c/c++
17:19:09 <shapr> hiya Nafai
17:19:12 <drdr> well then i want a near silver bullit\
17:19:18 <drdr> bullet
17:19:20 <shapr> drdr: I don't think there is such a thing.
17:19:26 <shapr> drdr: What languages do you know?
17:19:31 <drdr> @sharp ruby python javascipt html php java c/c++]
17:19:32 * lambdabot would never hurt ruby python javascipt html php java c/c++]!
17:19:32 <Nafai> shapr: How's things?
17:19:53 <shapr> Nafai: Life is never boring, how's your elisp binge?
17:20:02 <drdr> im really trying to find one that will simplfy the prosceess of writing oop code
17:20:10 <drdr> for desktop and cmd line apps
17:20:14 <skorpan> drdr: if you want OOP, haskell is not for you
17:20:16 <shapr> Ah, Haskell doesn't really do Object Oriented Programming.
17:20:23 <drdr> ah
17:20:26 <shapr> Mostly because it doesn't need OOP.
17:20:27 <skorpan> haskell is purely functional, nothing like oop
17:20:36 <drdr> ok
17:20:47 <drdr> so can it speed up my codeing?
17:20:47 <erikc> if you are doing desktop apps, you're best off with whatever your platform owner suggests
17:20:50 <shapr> Object oriented programming is an abstraction where you break the state up into separate chunks, and there are other valid and efficient abstractions.
17:20:53 <skorpan> (but seeing as you know only impure languages maybe haskell would be worth a shot)
17:20:54 <shapr> drdr: Yes.
17:21:06 <ajcc> drdr: check out common lisp, it got a quite unique way of doing object oriented programming.
17:21:15 * drdr shutters at lisp
17:21:21 <shapr> Haskell can speed up your coding so much that you'll end up spending most of your time thinking, and very little of your time coding.
17:21:21 <EvilTerran> drdr, i find i write a lot less haskell than i do any other language to achieve the same things
17:21:21 <purplepenguins> why?
17:21:31 <purplepenguins> learn to love lisp
17:21:31 <p_l> drdr: why?
17:21:33 <drdr> lisp === devil
17:21:41 <drdr> i can never get anything to work
17:21:44 <shapr> drdr: Lisp has really awesome points.
17:21:48 <Cale> You can do object oriented programming in Haskell, but it's not your only option, and the language doesn't really push you into it. Basically, you use it where it's appropriate, and don't when it's not.
17:21:49 <ajcc> why does everyone hate lisp? I don't get it...
17:21:54 <p_l> drdr: maybe you're doing it wrong?
17:21:58 <purplepenguins> parentheses are annoying
17:21:58 <drdr> no no
17:22:02 <p_l> drdr: what kind of problems did you have?
17:22:04 <shapr> I don't hate lisp, it's a powerful language with lots of good points. I just like Haskell more.
17:22:09 <p_l> purplepenguins: only in the beginning
17:22:16 <purplepenguins> haskell has a much nicer syntax than lisp
17:22:16 <Nafai> shapr: Doing good!  Though I've been taking too long to get back to the point of usefulness of my library :)
17:22:20 <drdr> oh float points exceptions segfalts etc
17:22:23 <purplepenguins> at least to read
17:22:39 * p_l usually programs in Common Lisp, but I like Haskell as well, just concentrating one-at-a-time
17:22:47 <jfoutz> segfaults in lisp? hmm.
17:22:52 <ajcc> drdr: segmentation faults have nothing to do with floating points...
17:22:55 <drdr> but i used it on a older pc
17:23:02 <p_l> drdr: that's a problem with implementation you use, not language
17:23:03 <drdr> so ill go check it out
17:23:11 <shapr> drdr: Do you have any of your ruby code online?
17:23:22 <drdr> me? none yet
17:23:28 <drdr> im workin on some l33t things
17:23:41 <drdr> you know buildin websites and games
17:23:45 <shapr> Right, I understand.
17:23:47 <p_l> drdr: if you're on Linux, try SBCL, if on OSX or Windows, ClozureCL. And of course GHC for Haskell
17:23:51 <Nafai> I'm liking Lisp a lot more lately, but I still feel like I would prefer a statically-typed pure language :)
17:23:55 <ajcc> Isn't Ruby purley object oriented?
17:24:02 <purplepenguins> it is
17:24:08 <Nafai> But Yi isn't quite Emacs, so Emacs Lisp it is
17:24:14 * ajcc is quite confused
17:24:17 <purplepenguins> it follows the smalltalk ideal in some ways
17:24:26 <drdr> no ruby aint oop
17:24:33 <shapr> drdr: I think it is.
17:24:37 <purplepenguins> everything is an object
17:24:37 <drdr> but its bult so it can quickly
17:24:44 <purplepenguins> therefore, it's object oriented programming
17:24:46 <drdr> *CAN BE
17:25:06 <drdr> RIGHT
17:25:09 <drdr> i like taht
17:25:11 <skorpan> drdr: ruby is multi-paradigm, just about as much OOP as c++
17:25:12 <ajcc> purplepenguins: oh, yes. I remember now. Everything except the print function:)
17:25:13 <shapr> I think your caps lock is stuck.
17:25:21 <drdr> sorry
17:25:23 <purplepenguins> well
17:25:24 <copumpkin> ajcc: that's python
17:25:29 <purplepenguins> most everything is an object
17:25:29 <drdr> its called small keybord syndrome
17:25:43 <drdr> well im gonna go check about earlang now
17:25:45 <purplepenguins> yeah, and even now, python 3 has print()
17:25:45 <copumpkin> and most things are expressions
17:25:49 <shapr> drdr: Ok, have fun!
17:25:51 <drdr> just because i need someting to do
17:25:56 <drdr> for the next few weeks
17:25:57 <shapr> drdr: Feel free to come back if you want to learn more about Haskell.
17:25:59 <purplepenguins> erlang is purely functional...isn't it...
17:26:07 <dolio> It doesn't take it quite as far as smalltalk, since there is still syntax for, like, loops and if expressions.
17:26:09 <p_l> in Ruby afaik everything is an object, though you can use Modules which are like incomplete classes
17:26:11 <Cale> purplepenguins: Or impurely functional ;)
17:26:18 <skorpan> drdr: you won't have fun with erlang, try haskell instead
17:26:29 <dolio> But it's pretty far in that direction.
17:26:40 <purplepenguins> if you want to pick a purely functional language, haskell is my vote for the best choice
17:26:48 <drdr> ok
17:26:52 <drdr> but can haskell do 3d
17:26:54 <skorpan> haskell is the only purely functional language i know
17:26:59 <ajcc> drdr: why do you need an object oriented language?
17:27:03 <drdr> if it can im gonna lern me some haskell
17:27:04 <copumpkin> drdr: sure]
17:27:06 <Cale> purplepenguins: Erlang took the evil approach to I/O. (It's strictly evaluated, so they can just mix effects in.)
17:27:08 <purplepenguins> can haskell do 3d what?
17:27:11 <drdr> ajcc because i write games
17:27:14 <jfoutz> 20:27 < purplepenguins> can haskell do 3d what?
17:27:15 <drdr> and outher thigs
17:27:18 <drdr> 3d stuff
17:27:21 <purplepenguins> they have opengl libraries
17:27:23 <shapr> drdr: Haskell does have OpenGL bindings.
17:27:23 <drdr> like rendering anaimation
17:27:33 <ajcc> drdr: most games are written in the impure C++ languge, maybe you should do too?
17:27:40 <drdr> @shapr are the biding complete
17:27:41 * lambdabot slaps are the biding complete
17:27:52 <drdr> ajcc i never use c++
17:28:03 <purplepenguins> just so you kno drdr, if you start with @something you send lambdabot a command
17:28:04 <drdr> i find it like ripping out your spleen
17:28:08 <ray> @shaper
17:28:09 <lambdabot> Unknown command, try @list
17:28:09 <drdr> ah
17:28:18 <ray> woeful edit distance!@
17:28:36 <Nafai> drdr: You don't need to prefix people's names with @ to reply to them in IRC.  Just use their nick and a colon.  Most IRC clients will highlight those lines for them :)
17:28:43 <drdr> ok
17:28:45 <Nafai> The Twitter generation! :)
17:28:46 <purplepenguins> it's the twitter effect...
17:28:48 <drdr> no
17:28:58 <drdr> its the i wrote a IM system effect
17:28:59 <ray> RM <drdr> no
17:29:02 <purplepenguins> actually it's pretty reasonable
17:29:11 <drdr> ok
17:29:15 <drdr> so how do i lern haskell
17:29:17 <purplepenguins> lambdabot is kinda silly for using @commands
17:29:25 <drdr> @@die
17:29:28 <purplepenguins> drdr: check out haskell.org
17:29:29 <aavogt> @bot
17:29:29 <lambdabot> :)
17:29:29 <lunabot>  :)
17:29:33 <ajcc> drdr: haskell.org
17:29:34 <drdr> ok
17:30:02 <purplepenguins> there are many numerous tutorials online
17:30:10 <skorpan> @lyah
17:30:10 <lambdabot> Unknown command, try @list
17:30:17 <skorpan> god damn it lambdabot can't you do *anything*
17:30:17 <jfoutz> @where learnyouahaskell
17:30:18 <lambdabot> I know nothing about learnyouahaskell.
17:30:20 <purplepenguins> and the book Real World Haskell is a good place
17:30:28 <skorpan> http://learnyouahaskell.com/
17:30:28 <purplepenguins> to find real examples
17:30:43 <Nafai> Yeah, I say lyah and rwh are a great combination
17:30:48 <Nafai> And then #haskell for specific questions
17:30:53 <purplepenguins> there is a series of wikibooks too
17:30:58 <Nafai> We're newbie friendly
17:31:18 <skorpan> the wikibooks are pretty hard to grasp imo
17:31:19 <drdr> thats great
17:31:27 <purplepenguins> i started haskell with the wrong tutorial though
17:31:30 <drdr> because the ruby channle is like dead or stooned
17:31:35 <skorpan> i tried reading about the zipper on wikibooks several times without it clicking
17:31:35 <drdr> *stoned
17:31:40 <purplepenguins> a gentle introduction or something
17:31:50 <drdr> oh one more queston
17:31:51 <purplepenguins> don't read that one
17:32:04 <ajcc> purplepenguins: a gentle introduction to haskell?
17:32:04 <drdr> is they a way to make functions
17:32:09 <skorpan> purplepenguins: you mean the super ugly one with sheep?
17:32:18 <purplepenguins> yeah, that's the one ajcc
17:32:20 <drdr> like if im gonna resue something
17:32:23 <purplepenguins> I don't remember there being sheep in it
17:32:27 <endojelly> tessier, yes! still there?
17:32:38 <skorpan> Maybe Sheep >>= Nothing, something along those lines
17:32:41 <ajcc> drdr: the whole thing about a functional language is building functions
17:32:41 <purplepenguins> drdr: in Haskell it's hard to not define a lot of functions
17:32:51 <skorpan> they explained the behavior of (>>=) in Maybe using sheep
17:32:55 <drdr> thats great
17:32:58 <purplepenguins> and Haskell has an exception handling system
17:33:00 <drdr> ill lern tommow
17:33:09 <purplepenguins> skorpan: now i rmeember
17:33:10 <purplepenguins> yeah
17:33:15 <skorpan> *so* ugly
17:33:18 <drdr> tonight i must go hunting pandas
17:33:20 <purplepenguins> that was by far the worst way to explain monads
17:33:24 <skorpan> haha
17:33:37 <drdr> serouly
17:33:45 <ray> and a sheep can eat another sheep and then be shorn into the second sheep
17:33:48 <ajcc> drdr: computer games?
17:33:50 <drdr> no
17:33:50 <purplepenguins> aren't pandas endangered
17:33:53 <drdr> real life
17:34:03 <ray> i think >>= is easy, it's just flip (=<<)
17:34:03 <drdr> and thats why i have a tranqulers gun
17:34:11 <drdr> there is a crazy dude on the loose
17:34:16 <drdr> in a panda suit
17:34:27 <purplepenguins> your day job sounds interesting drdr
17:34:32 <ajcc> drdr: maybe you should learn Visual Basic?
17:34:47 <drdr> more like my mental issues
17:34:50 <drdr> no no
17:34:52 <skorpan> i knew it was a troll
17:34:56 <drdr> nope
17:35:12 <drdr> just a mind that wont run the normall way
17:35:16 <ajcc> skorpan: since when did these "trolls" start popping up everywhere?
17:35:29 <drdr> when people started  looking
17:35:33 <skorpan> ajcc: what do you mean? i see them almost on a daily basis.
17:35:56 <drdr> most people take some mental issues that cuase socal issues as trolling
17:36:16 <ajcc> skorpan: that's sad...
17:36:23 <skorpan> you're going to chase a guy in a panda suit with a tranquilizer gun.  that has nothing to do with your "mental issues".
17:36:33 <skorpan> or maybe it does, when i think about it.
17:36:37 <drdr> yep
17:36:48 <drdr> but tahts beause its a paintball gun
17:36:58 <drdr> and i work at a paintball park part time
17:37:24 <drdr> but tahts beside the fact
17:37:51 <drdr> just understant that i say odd things
17:37:58 <drdr> and people who can unserstand them
17:38:06 <drdr> see the world in a better way
17:39:11 <ajcc> sometimes I which that the Internet was purley academic once again
17:39:43 <skorpan> i'm stalking him in #ruby now
17:40:08 <skorpan> he asked a question to which the solution was str.split("<") so i don't know if i believe that he "knows ruby"
17:40:20 <jfoutz> ajcc: almost 2 billion online. 4 billion more, and september will end.
17:40:29 <skorpan> jfoutz: september will never end
17:40:41 <ajcc> skorpan: I don't think he know any computer language at all
17:41:16 <skorpan> but he does 3d games?
17:41:24 <Nafai> jfoutz: Gives unintended meaning to the Green Day song "Wake me up when September ends"
17:41:31 <ajcc> skorpan: maybe he's just playing them?
17:41:47 <skorpan> maybe
17:41:50 <EvilTerran> skorpan, september will end when the academics rise up with their army of machines and phd students
17:42:01 <skorpan> EvilTerran: and do what?
17:42:08 <ajcc> how many of you are "trolls"?
17:42:12 <jfoutz> ask for grant money.
17:42:25 <copumpkin> ajcc: I definitely am
17:42:32 <skorpan> i troll this channel on occasion
17:42:33 <Nafai> ajcc: In the right place, definitely I am :)
17:42:34 <jfoutz> i'm pretty sure i'm a troll.
17:42:40 <Nafai> It happens so easily sometimes
17:42:45 * copumpkin crawls back under his bridge
17:42:51 <EvilTerran> er... write papers about how the world should be run?
17:42:56 <copumpkin> (anyone want to walk over my bridge?)
17:43:03 * EvilTerran hasn't thought his cunning plan all the way through
17:43:03 <skorpan> EvilTerran: ah the power of academia!
17:43:15 * ajcc misses the comfort of the haskell list
17:43:21 <copumpkin> EvilTerran: actually, I have some thoughts on that :P I'll let you know when I publish them
17:43:40 <copumpkin> ajcc: wait, #haskell is actually a lot friendlier than the mailing list in my experience
17:44:02 <ajcc> copumpkin: maybe you weren't friendly to the mailing-list?
17:44:15 <copumpkin> ajcc: I mostly just lurk and watch other people get into rather heated discussions
17:44:25 <EvilTerran> copumpkin, as i see it, the problem is we need the world domination thing before we can write the papers, so we can put together a meaningful test case
17:44:36 <copumpkin> EvilTerran: I prefer to call it a "user study"
17:44:41 <seanmcl> Hi. I'd like to use Haddock documentation in my (Bird) Literate Haskell file.  Something like
17:44:43 <seanmcl> > some code
17:44:44 <lambdabot>   Not in scope: `code'
17:44:48 <seanmcl> | some comments
17:44:51 <seanmcl> > more code
17:44:53 <lambdabot>   Not in scope: `more'Not in scope: `code'
17:44:53 <EvilTerran> ?type some -- ?
17:44:55 <seanmcl> Is this possible?
17:44:55 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
17:45:03 <copumpkin> seanmcl: rename your file to .lhs
17:45:04 <copumpkin> instead of .hs
17:45:26 <seanmcl> It has this name.  Haddock is not adding any of my literate comments.
17:45:51 <seanmcl> I can get them to work with > -- | Comment
17:45:58 <seanmcl> but this kind of defeats the purpose of LHS
17:46:51 <gwern> man, Safari doesn't support MathML?
17:46:59 <gwern> I don't know how people can like apple so much
17:47:14 <gwern> when they talk like a fag and their shit's all retarded
17:47:25 <gwern> even IE has mathml support! *IE*
17:47:43 <copumpkin> o.O
17:47:52 * inimino blinks
17:48:04 <gwern> (as a plugin, yes, but that's like being so out of shape that a guy in a wheelchair can outrace you - yes, he needs a tool, but you should still be ashamed of yourself)
17:48:08 * copumpkin resists the temptation to @remember what gwern just said
17:48:25 <Raevel> mathml for safari was a gsoc proposition 3 years ago
17:48:56 <skorpan> @remember gwern as a plugin, yes, but that's like being so out of shape that a guy in a wheelchair can outrace you - yes, he needs a tool, but you should still be ashamed of yourself
17:48:57 <lambdabot> It is forever etched in my memory.
17:49:11 <jfoutz> seanmcl: http://www.haskell.org/haddock/haddock-html-0.8/invoking.html#cpp (seems like it's working as designed, but double check)
17:49:17 <copumpkin> @remember gwern when they talk like a fag and their shit's all retarded
17:49:17 <lambdabot> Okay.
17:49:24 <gwern> one day my comments here will haunt me :(
17:49:25 <purplepenguins> actually wheelchairs can be kinda fast
17:49:28 <copumpkin> damn, I gave in
17:49:33 <gwern> no doubt when I'm being confirmed for a cabinet position
17:49:36 <purplepenguins> haven't you seen wheelchair racing?
17:49:49 <gwern> copumpkin: you know, that doesn't make sense out of context - it's funny only if you know it's about apple
17:49:54 <gwern> purplepenguins: no
17:50:09 <copumpkin> gwern: I know, out of context it just sounds offensive
17:50:21 <copumpkin> @forget gwern when they talk like a fag and their shit's all retarded
17:50:21 <lambdabot> Done.
17:50:26 <gwern> well, _Idiocracy_ was supposed to be offensive
17:51:08 <seanmcl> jfoutz:  thanks.  This seems to be old documentation.  It's suppose to work now: http://www.haskell.org/haddock/doc/html/invoking.html#cpp
17:51:54 <jfoutz> seanmcl: hmm, sure enough.
18:03:44 <tessier> endojelly: I'm still here. Private message me what you want translated. Or if it is too long email it to treed@tracyreed.org
18:04:26 <Phyx-> 02:49 < gwern> no doubt when I'm being confirmed for a cabinet position <-- no.. that's when the sex scandals come to light
18:05:28 <Vanadium> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8348#a8348 -- can someone convey some intuition as to what the whole rank2types business is necessary for here?
18:08:02 <Vanadium> Did I stumble into the channel after closing hours or something :|
18:09:41 <ray> yes
18:10:30 <Cale> Vanadium: It's because the function applies its parameter to a statically unknown number of arguments
18:11:24 <Vanadium> From what I can see it applies it parameter to just one argument :(
18:11:25 <Cale> That is, pf must be polymorphic because it's going to be applied like pf e e e ... e where there are n copies of e, and n isn't known until runtime
18:12:25 <Cale> It's a very roundabout and complicated way to do what it's trying to do, but interesting anyway.
18:12:31 <Vanadium> Why can aux not be :: (PrintfType t, PrintfType t') => t -> Int -> t'?
18:12:39 <Vanadium> Is that not... polymorphic enough?
18:12:58 <Cale> Right, it's not.
18:13:38 <freedrull> can you use yi in a terminal? or is it gui only?
18:13:51 <Cale> freedrull: I think it's mostly for use in a terminal.
18:14:16 <freedrull> Cale: ok cool
18:14:19 <Cale> At least, I haven't bothered to take whatever steps are necessary for the gui to work.
18:14:45 <freedrull> i dont want to use the gui so....
18:15:29 <Saizan_> Cale: how'd you it in a simpler way? except for not using printf at all
18:15:46 <Saizan_> s/you/you do/
18:16:08 <Cale> Saizan_: By printf-ing once and then replicating the resulting string.
18:16:39 <Saizan_> ah, sure :)
18:17:14 <Phyx-> @type ask
18:17:15 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
18:17:37 <Cale> If it helps, for (->) e, ask = id
18:18:22 <Vanadium> Cale: The problem statement was to call a function with a number of arguments that was to be determined at runtime, though.
18:19:13 <Phyx-> oh ok, never though bout that one
18:22:12 <EvilTerran> Vanadium, then the forall is necessary, so the parameter function can be sufficiently polymorphic
18:23:13 * lispy installs haskell platform 2009.2.0.2
18:23:30 <lispy> hmm
18:23:49 <lispy> interesting, it's not in my path
18:24:00 <Vanadium> I suspect I still have the wrong idea of parametric polymorphism in general.
18:24:21 <luite> lispy: have you opened a new shell?
18:24:21 <lispy> Vanadium: how so?
18:24:28 <lispy> luite: yes
18:24:44 <lispy> luite: I have a symlink in ~/bin to ghc and so I think that's being found
18:24:54 <luite> don't know if it adds it to the path on linux, it does in windows :)
18:25:00 <lispy> osx here
18:25:05 <Vanadium> lispy: I kind of assumed that making aux polymorphic would make the whole thing flexible enough to Just Work :/
18:25:24 <Cale> Vanadium: Normally, parameters to functions are monomorphic, even if the function itself is polymorphic, in HΜ typing, parameters to a function can only be used at one type in the body of that function.
18:25:39 <lispy> Vanadium: guess I'd have to see the code
18:26:03 <Cale> > (\l -> (l [1,2,3,4,5], l "hello") length
18:26:04 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:26:07 <Cale> > (\l -> (l [1,2,3,4,5], l "hello")) length
18:26:08 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
18:26:08 <lambdabot>    arising from the literal `1...
18:26:34 <lispy> ah there we go, removed the symlink now I get 6.10.4
18:26:59 <Cale> > let f :: (forall a. [a] -> Int) -> (Int, Int); f l = (l [1,2,3,4,5], l "hello") in f length
18:27:01 <lambdabot>   (5,5)
18:27:41 * dolio has gained notoriety as "some dude."
18:27:59 <Cale> dolio: oh?
18:28:09 <Vanadium> dolio: It is your code? :)
18:28:12 <dolio> It is.
18:29:00 <Vanadium> Sorry for not giving you credit properly, I had the code saved to a file and only got around to looking at it later on.
18:29:03 <lispy> man, it's so nice that darcs can be cabal-installed now
18:29:08 <Cale> dolio: ah, I see what you're referring to now :)
18:29:22 <dolio> Vanadium: I'm not actually offended. :)
18:30:06 <luite> lispy: it sure is, but it took me a while to find the -f-curl option (which probably most windows people need)
18:30:41 <lispy> luite: yes, most windows users will need that, but IRC that cripples darcs in some corner cases
18:30:49 <lispy> IIRC*
18:31:07 <lispy> But, maybe those bugs in HTTP have been fixed
18:31:46 <luite> oh I haven't noticed anything yet, but I have only used it a few times since I installed it
18:33:06 <lispy> luite: well if you have any problems fetching patches or repositories over http then look into getting a curl enabled build
18:33:13 <Vanadium> So t being polymorphic in aux is basically saying that t needs to be flexible enough to, at runtime, become either t' (and thus IO () I suppose) in the case of a second argument of 0, or a function type?
18:33:44 <Vanadium> I feel really dense because I have been trying to wrap my head around rank 2 types (and I suppose how ST works) for a couple of days now and yet enlightenment is eluding me
18:34:24 <Cale> Vanadium: Well, yeah, pf needs to be something genuinely polymorphic, and not just some specific PrintfType which would have to be statically resolved at some point then.
18:34:35 <lispy> Vanadium: it is quite perplexing at times because it's pure logic and our brain sometimes don't do well with that
18:35:10 <dolio> Well, the problem with "forall t t'. (PrintfType t, PrintfType t') => t -> Int -> t'" is that the caller gets to determine what t is.
18:35:35 <dolio> When actually, the aux function needs to decide what t needs to be based on the Int.
18:35:47 <Cale> and any fixed t is not good enough, since the Int value could be anything at runtime
18:36:00 <dolio> So aux needs to accept something that can become any PrintfType t.
18:36:59 <Cale> For instance, let's suppose that magically the typechecker accepts  aux ::  (PrintfType t, PrintfType t') => t -> Int -> t'
18:37:39 <Cale> Then, since String is an instance of PrintfType, I could call it as
18:37:56 <Cale> aux "hello" 1 :: String
18:38:12 <Cale> This won't match the first pattern, so we get:
18:38:34 <Cale> aux "hello" 1 = aux ("hello" e) (1 - 1)
18:38:35 <lispy> what the url?
18:38:57 <Cale> and look at that, we're applying a string as if it were a function
18:39:14 <Cale> which is obviously not very good of the typechecker to let us do.
18:40:00 <Cale> Vanadium: does that help?
18:40:39 <Vanadium> Yeah, it does.
18:40:49 <lispy> may I please see the code?
18:41:04 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8348#a8348
18:41:07 <lispy> thanks
18:41:29 <dolio> I am the walrus?
18:41:48 <lispy> Cale: is that the fixed version?  based on your description that's what I thought the type should be
18:41:51 <Cale> (It was pasted just a few lines before you joined the discussion)
18:41:58 <lispy> ah, sorry
18:42:07 <lispy> Sometimes it can be a pain to search back in the history
18:42:12 <Cale> lispy: I messed up the type on purpose to show what goes wrong when you don't use a rank 2 type.
18:42:33 <Cale> (and imagined that the typechecker was to erroneously accept that type)
18:42:59 <lispy> Right, so I followed that part, but is this the right type? PrintfType t' => (forall t. PrintfType t => t) -> Int -> t'
18:43:04 <Cale> The parameter to aux really must be polymorphic, because its eventual type depends on the value of the Int.
18:43:11 <Cale> yes
18:43:22 <Cale> The program in the paste actually does work.
18:43:30 <Vanadium> So I get why we need a polymorphic type, but how do we actually build a polymorphic value? Or rather, how does printf build one?
18:43:35 <Phyx-> hhmm Cale what client are you using? or rather which charset? i finally figured out what you mean when you sometimes say random things like  H\u039c
18:43:38 <Phyx-> lol
18:43:44 <dolio> @type printf
18:43:45 <lispy> Vanadium: type class magic
18:43:45 <lambdabot> forall r. (PrintfType r) => String -> r
18:43:55 <lispy> Vanadium: not even that magical, just clever
18:43:56 <Cale> Phyx-: huh?
18:43:59 <dolio> @type printf "abcde %d"
18:44:00 <lambdabot> forall r. (PrintfType r) => r
18:44:04 <Cale> Phyx-: I'm using UTF-8 encoding.
18:44:13 <Phyx-> odd, i should be able to display that fine...
18:44:36 <Cale> What *do* I mean when I say H\u039c ?
18:44:49 <Cale> (I don't remember saying that myself ;)
18:44:58 <lispy> aux is a crazy function
18:45:32 <Phyx-> Cale: i'm assuming an accented char or something, "if the function itself is polymorphic, in H\u039c typing,"
18:45:39 <lispy> ?instances PrintfType
18:45:40 <Cale> ...
18:45:40 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
18:45:43 <Cale> whaaaaat
18:45:50 <Cale> I wrote HM typing
18:45:54 <Phyx-> heh
18:45:57 <dolio> ?instances-importing Text.Printf PrintfType
18:45:57 <lambdabot> (a -> r), IO a, [c]
18:46:05 <Phyx-> i really do get such sentences from you randomly in irssi
18:46:22 <Cale> Wait, I have an idea...
18:46:22 <dolio> [c], huh.
18:46:25 <lispy> Phyx-: hmm..I'm on irssi here and I see what cale says just fine :)
18:46:26 <Cale> HΜ
18:46:31 <Cale> does that do it?
18:46:33 <Phyx-> odd..
18:46:36 <Phyx-> nope, same thing
18:46:39 * Phyx- checks his config
18:46:49 <lispy> could have been a bad packet
18:46:50 <Cale> I mean, did you get H\u039c there?
18:47:01 <Phyx-> yeah, i got  H\u039c again
18:47:08 <Cale> ah, okay, then I know what it is
18:47:19 <Cale> That M was actually a capital mu
18:47:26 <lispy> heh
18:47:27 <dolio> "class IsChar c ... instances: IsChar Char"
18:47:28 <Phyx-> heh
18:48:08 <lispy> I'm really confused by the second line of aux
18:48:22 <lispy> how is it that we can apply t to e
18:48:26 <lispy> something of type t imean
18:48:26 <dolio> Is that just to not piss off the overly anal instance restrictions?
18:48:32 <Cale> lispy: The goal is to apply pf like  pf e e e ... e where there are n copies of e
18:48:52 <Cale> lispy: Function types are instances of PrintfType
18:49:05 <Vanadium> Hmm, clever.
18:49:07 <dolio> I guess it probably is.
18:49:25 <lispy> Cale: hmm, yeah I saw (a -> r) was an instance
18:49:38 <Cale> dolio: Yeah, it's to not incur a FlexibleInstances requirement
18:49:51 <Vanadium> @src printf
18:49:51 <lambdabot> Source not found. Wrong!  You cheating scum!
18:50:22 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Text-Printf.html#printf
18:50:36 <Vanadium> Yeah, I am looking at it right now, I just wanted to dump it in the channel to talk about it.
18:50:58 <Vanadium> This whole thing looks very backwards and clever.
18:51:06 <Cale> That's because it is.
18:51:21 <Cale> It's doing something which you're really not meant to do :)
18:51:25 <dolio> One would expect no less from Lennart Augustsson. :)
18:51:35 <lispy> heh yeah
18:52:51 <Vanadium> The existence of spr was confusing me because I was thinking in terms of C++-ish user-defined implicit conversions, which is of course not quite how this works.
18:53:26 <purplepenguins> thinking in terms of C++ when doing Haskell often isn't how it works
18:53:27 <aavogt> you can't write Data instances for types like  'data T = forall a. Data a => T a'?
18:53:42 <Vanadium> Am I getting it right that the printf call itself just evaluates to a function that keeps collecting arguments and evaluating to yet another such function until someone expects it to be an IO or a string instead?
18:54:25 <Vanadium> purplepenguins: "Type variables? Oooh, just like template parameters in C++! Easy!"
18:54:30 <Vanadium> :(
18:54:31 <lispy> aavogt: what are you trying to do?
18:54:42 <lispy> aavogt: data instance?
18:54:56 <lispy> oh, there is a type class called data?
18:54:59 <lispy> ?instances Data
18:55:00 <lambdabot> Couldn't find class `Data'. Try @instances-importing
18:55:39 <Saizan_> yes, there is
18:55:42 <aavogt> lispy: I'm trying to use an existentially quantified data type for something that will be serialized with happstack-data / happstack-state
18:55:56 <lispy> aavogt: ah
18:56:05 <aavogt> I could just use a plain ADT, but where's the fun in that?
18:56:10 <lispy> aavogt: and Data is the class that happstack uses for that?
18:56:24 <Saizan_> no, Data is a class to SYB
18:56:32 <lispy> aavogt: you can put class instances in the heads of data types
18:56:51 <Saizan_> it's either from Data.Data in base or from syb-with-class
18:57:26 <lispy> aavogt: I always forget the syntax for ADTs because it's easier with GADTs
18:57:47 <Saizan_> data T = forall a. Data a => T a <- this type does have the Data context inside it for 'a'
18:58:28 <lispy> hmm yeah, that looks legal
18:58:53 <Saizan_> aavogt: i'm not sure you're required to derive Data just to serialize, i think you can write an instance of Serialize directly
18:59:05 <gwern> I'm really starting to appreciate command-line and keyboard shortcuts over a slow ssh connection; it'd drive me mad to have to do this over a gui
18:59:22 <lispy> gwern: agreed
18:59:42 <lispy> gwern: how have you been?
18:59:46 <gwern> I mean, the latency makes typing bad enough; mouse and dialog... suicide material
19:00:00 <gwern> lispy: today? sweaty and getting a little weary of gitit and darcs probelms
19:00:28 <lispy> are you helping kowey with something?
19:00:41 <gwern> yeah, darcs.net keeps OOMing, and gitit seems to be the issue
19:00:52 <lispy> wow, still huh?
19:01:25 <lispy> I've been keeping a low profile lately
19:01:37 <gwern> indeed. we keep stomping issues, but the OOms keep happening
19:01:54 <aavogt> wouldn't it be ironic to use the git gitit backend for the darcs wiki...
19:02:08 <gwern> it's very frustrating - I keep thinking, surely removign this changes call will fix it, or surely max-count will fix the memory issue, or surely this robots.txt will stop the ram blowup
19:02:36 <lispy> gwern: is it gitit or darcs that runs out of memory?  do you know?
19:02:46 <aavogt> gwern: do you have it setup to restart when it dies? or would that be bad for DoS purposes?
19:02:50 <gwern> no; we don't have good logging on process usage
19:03:19 <lispy> I would guess that'd be the first thing I'd want to improve
19:04:25 <gwern> I know that gitit keeps improving - we now have aplugin to replace the jsmath dep, we now have rss feeds for pages, a revamped caching framework (on-disk instead of ram), more secure logins, and so on
19:04:42 <gwern> but it's very wearisome
19:05:06 <gwern> (also, massively easier to edit and update templates for the html)
19:05:27 <gwern> lispy: yeah, so that's basically all I've been doing haskell-wise for this summer
19:05:43 <aavogt> gwern: did these changes happen in the last 2 months?
19:05:49 <gwern> aavogt: more or less
19:05:53 <lispy> gwern: wow, well you've been busy
19:06:27 <gwern> this week was the tex plugin; rss, caching were the last week; auth and templates were 2-4 weeks ago
19:06:33 <lispy> I think I'm starting to feel rested post MS-haul.  Time to get back to hacking on darcs.
19:07:15 <lispy> Sadly I can't use darcs at work unless I fix some performance issues.  Oh, maybe that's incentive.  They use perforce :(
19:07:22 <gwern> lispy: it's more john's work than mine. I prototyped the rss support, but he did the tex all by himself, and my role in the other things is more along the lines of bring them up and laying out my ideas and provoking john to do them
19:07:34 <Cale> Hey, does anyone know how often that incorrect merging problem with non-darcs VCSes occurs in practice? It seems rather scary, especially in its capacity to produce compiling code which is incorrect.
19:07:35 <lispy> heh
19:07:54 <gwern> reminds me of my stumpwm days - I'd demand stuff and sabetts would wearily implement them, and that's how stumpwm went from a useless non-tiling piece of shit to a ratpoison replacement
19:08:09 <lispy> Cale: in practice, with svn, merges are avoided unless you don't have much choice
19:08:34 <lispy> gwern: quite the instegator
19:08:47 * gwern is, gwern is
19:08:53 <gwern> *instigator
19:08:54 <lispy> Cale: and then you carefully merge forward all the time and in one direction.
19:08:58 <Phyx-> just out of curiosity, does anyone know, when specifying a replacement preprocessor for GHC, does it always give the main file last or are the orders arbitrary.. is there anyway to discover which files are actually apart of the project before hand? or a way to tell ghc to "discover" which files are part of the project?
19:09:45 <lispy> Phyx-: like asking GHC for the deps?
19:10:08 <lispy> it does have a way to make deps and output the file, but I forgot the switch.  Check the manual
19:10:17 <Cale> (http://zooko.com/badmerge/concrete-good-semantics.html)
19:10:48 <Phyx-> lispy: yup
19:10:49 <Cale> lispy: Okay, so they avoid the problem by just never merging things done independently and being super careful.
19:11:05 <Phyx-> lispy: ok, will do thanks, i just wanted to know if it's possible before i wrote it myself
19:11:08 <Phyx-> heh
19:11:32 <lispy> Cale: which is actually similar to how David et al avoided bad merges in the darcs code base :)
19:12:00 <Cale> lispy: What's the story there?
19:12:42 <lispy> Cale: well, david has his own branch now and the official branch tries to merge in his changes from time to time.  But in the last few weeks we may have hit a merge bug
19:13:15 <lispy> Cale: you know that darcs the project has always been more or less centralized
19:13:27 <lispy> At times there have been experimental and unstable official branches though
19:13:32 <lispy> which patches flowing between as needed
19:14:08 <lispy> And to be fair, as nice as patches are, sometimes you just want to transfer a diff
19:14:40 <lispy> as far as I know, just transfering the diff without context is what svn does
19:15:05 <lispy> So for it, the merge is simple.  If the diff can be applied it is, otherwise you get conflicts, done.
19:15:30 <lispy> For darcs, you search (using commute to rearrange context) for a combination that allows you to merege
19:15:34 <lispy> merge*
19:15:53 <Cale> right...
19:15:54 <lispy> and sometimes that search seems to take ages
19:16:29 <lispy> mornfall has propose a new patch format that lets you do the commute on the patch meta data and leave the patch contents on the disk
19:16:39 <lispy> Which is pretty clever
19:16:50 <lispy> I haven't checked it out completely, but the idea sounds promising
19:17:02 * Phyx- wonders why he even bothers with yahoo answers sometimes
19:17:15 <copumpkin> how is babby formed?
19:17:18 <lispy> Phyx-: stackoverflow is much better if it's programming related, better yet, use haskell-cafe
19:17:18 <copumpkin> how girl get pragnent
19:17:34 <Cale> That's odd. Why (the lucky stiff), has dropped off the face of the Internet along with all his projects.
19:17:48 <lispy> Cale: come again?
19:17:51 <Phyx-> copumpkin: lol
19:17:57 <Phyx-> lispy: ah ok, will do
19:17:59 <copumpkin> Cale: yeah, everyone is wondering! someone outed his real name last month so maybe that had something to do with it
19:18:08 <dolio> @keal
19:18:08 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
19:18:38 <Phyx-> copumpkin: i just randomly pick questions and answer and usually provide sources for reference. but they always seem to pick the "sucked out of my thumb" answers as the "correct" one
19:18:48 <Phyx-> i suppose my answers are too technical..
19:18:53 <Cale> lispy: http://news.ycombinator.com/item?id=773108
19:19:35 <copumpkin> Phyx-: the right answer is always "you need to do way instain mother, who kill thier babbys because these babby can't frigth back? it was in the news this mroing, a mother in ar who had kill her three kids! they are taking the babby back to new york, to lady to rest. my pary are with the father, who lost his chrilden. i am truley sorry for your lots"
19:19:42 <copumpkin> or something along those lines
19:19:54 <Phyx-> hahaah
19:20:24 * copumpkin 's official department website is the .swf of that :P
19:20:30 <copumpkin> *webpage
19:20:32 <copumpkin> *homepage
19:20:39 <Phyx-> o.O
19:21:11 <copumpkin> http://www.somethingawful.com/flash/shmorky/babby.swf is mirrored on my personal homepage :)
19:22:24 <Cale> http://whoiswhytheluckystiff.wordpress.com/ -- some people are thinking that his disappearance has something to do with this
19:22:25 * Phyx- is probably gonna lose some "coolness" points for doing this in a preprocessor instead of using typesystem+Data.Data+Data.Typeabe
19:22:59 <Cale> But that seems strange.
19:23:33 <Phyx-> rofl @ flash
19:23:56 <Phyx-> hahaha @ cale link
19:23:57 <purplepenguins> copumpkin: is that the babby video
19:24:11 <copumpkin> purplepenguins: indeed
19:24:16 <purplepenguins> dammit
19:25:50 <copumpkin> bbl :)
19:35:54 <gwern> lispy: and now I'm wrangling with john about how his plugin can't handle '10\times2' even though all the oter tex renderers will handle it fine
19:35:57 <gwern> ARRGH
19:36:38 <gwern> times like this that make me want to go read some hair-splitting philosophy of mind or nonsense metaphysics or something
19:37:47 <gwern> incidentally, the other day I showed that the universe must be at least a little larger than the planck volume, since that's the smallest possible computer simulating my mind
19:39:37 <gwern> you know what will cheer me up?
19:39:43 <gwern> a BLT for dinner
19:39:59 <gwern> yes, that's thhe ticket. take the last 6 or so strips and make myself 2 BLTs
19:40:09 <gwern> any day with bacon is a good day
19:42:34 <purplepenguins> yes indeed
19:43:52 <blackdog> gwern: chunky bacon?
19:44:19 <Phyx-> is the peano number representation/static constraint on classes actually used in actual projects? or are they just a nice theoretical thing? they always seemed kinda unconvenient to me
19:44:33 <lispy> gwern: hmmm
19:53:02 <Phyx-> hmm did everyone go to sleep?
19:55:19 * absentia is reading himself some real world haskell for a great good.
19:56:56 <pikhq> Thanks be to BONUS
20:00:15 <sbahra> absentia, are you new to functional programming by any chance?
20:00:26 <sbahra> absentia, "Haskell: The Craft of Functional Programming" is really good, too.
20:03:43 <lispy> GHC: The Compiler, is pretty sweet too ;)
20:04:42 <ray> haskell as she is wrote
20:08:24 <Cale> Haskell as http://personal.cis.strath.ac.uk/~conor/pub/she/ is wrote
20:08:37 <monochrom> ha
20:09:55 <Phyx-> there's.... a book called GHC: The Compiler?
20:11:07 <aavogt> there is a complier called GHC, with documentation included...
20:11:26 <Cale> "At this stage in its life cycle, it's unlikely to be particularly robust. You'll find that its error support is fantastic, if you need help making errors."
20:11:26 <aavogt> lispy: did you mention a book though?
20:11:49 <aavogt> @quote errors
20:11:49 <lambdabot> gwern says: I made so many compilation errors because I can't spell lambdab right
20:11:59 <Phyx-> aavogt: with "some" documentation :P
20:12:28 <monochrom> Haha, "if you need help making errors"
20:12:57 <BMeph> Phyx: Clean uses it in a way similar to how imperative language compilers use SSA. (BIG "modulo" caveats here)
20:13:03 <Cale> brb
20:14:34 <Phyx-> BMeph: ah ok, cool
20:14:56 <BMeph> GHC 6.12: When Lambdas Attack   Opens, September 14th ;)
20:15:22 <monochrom> Actually that is just release candidate #1
20:15:41 <absentia> ghci ... 7 ^ 9999  .. weeee.
20:15:53 <BMeph> Phyx: If you like, I could dig up the paper that talks about it...if someone else here doesn't beat me to the punch. ;)
20:16:50 <Phyx-> BMeph: well, i have read/done some things with the approach, but i always found the way to use it in haskell so cumbersome
20:18:14 <Phyx-> hahahah, the pidgin logo looks like the pidgin is high
20:20:06 <absentia> with the standard ghci .. why doesn't ^p o to previouus in my history...   (like I would expect it to) .. I'm forced to use the up arow (yuk)
20:22:00 <dolio> It's not bound by default for some reason.
20:22:08 <dolio> You can bind it yourself in .haskeline
20:22:14 <ray> it's not using readline is why
20:22:14 <dolio> "bind: ctrl-P up"
20:22:26 <dolio> "bind: ctrl-N down"
20:24:10 <absentia> oh, I thought it was readline. sorry.
20:25:22 <absentia> ya, that binding worked -- thank you!
20:26:25 <monochrom> "don't play with your haskeline, you will go bind"?
20:27:25 <monochrom> wouldn't it be funny if "ctrn-N >>= down" is also accepted? :)
20:31:12 <gwern> @quote play
20:31:12 <lambdabot> edwinb says: I've just walked past a poster advertising a gig by a band called "The Awkward Squad". I assume this means they output [music], play concurrently, and people take exception to them.
20:31:46 <Makoryu> Hmm, does haskeline support vi keys for that matter?
20:35:15 <gwern> dammit firegpg stop locking firefox
20:35:44 <gwern> also, _why's 'this book is made of rabbits and lemonade' is one weird song
20:36:31 <monochrom> wait til they use barbed wires and bananas too
20:37:29 <gwern> it does mention bananas
20:37:36 <gwern> at least, I think that's what he's saying
20:37:57 <Phyx-> lol
20:37:59 <Phyx-> i remember that paper
20:45:21 <twobitsprite> good evenning/etc
20:45:56 <Phyx-> morning
20:45:56 <twobitsprite> does anyone have any hints on setting up a Windows development environment for Haskell?
20:46:17 <twobitsprite> heh... its almost morning here :P
20:46:25 <Phyx-> for now, i use powershell + notepad++ myself
20:46:37 <d4> :t (\f -> if (f True) then (f 1) else (f 0))
20:46:39 <lambdabot>     No instance for (Num Bool)
20:46:39 <lambdabot>       arising from the literal `1' at <interactive>:1:27
20:46:39 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
20:46:44 * twobitsprite googles powershell
20:47:12 <twobitsprite> ahh... it's a MS product... what does it offer over cmd.exe?
20:47:15 <d4> :t (\f -> if (f True) then (f 1) else (f 0)) :: (Num n) => (forall a. a -> a) -> n
20:47:17 <lambdabot> forall n. (Num n) => (forall a. a -> a) -> n
20:47:28 <twobitsprite> (the MS site seems to talk mostly about its scripting language)
20:47:30 <d4> sweet
20:47:43 <Phyx-> twobitsprite: for one thing, much better scripting support, and most unix commands are implemented
20:47:55 <twobitsprite> grep, etc?
20:48:16 <Phyx-> grep is select-string
20:48:18 <Phyx-> but yes
20:48:19 <Phyx-> lol
20:48:33 <Phyx-> the names are slightly different but most are aliased
20:48:33 <twobitsprite> ohh... unix tools disguised as something else...
20:48:58 <Phyx-> i use it inside console.exe
20:49:03 <Phyx-> which gives me tabs etc
20:49:15 <Phyx-> and free resizing of a cmd window, yay
20:49:17 <twobitsprite> so... one thing that I'm trying to figure out about developing in windows... is how do I "cd" within ghci? i.e., I want to ":load" files...
20:49:26 <Phyx-> :cd
20:49:31 <twobitsprite> ahh
20:49:35 <Phyx-> but i'd do it outside
20:49:36 <twobitsprite> I don't have a console.exe
20:49:42 <Phyx-> or i always do it like that
20:49:55 <twobitsprite> you mean... from powershell... cd, then runh ghci?
20:50:09 <Phyx-> yeah
20:50:14 <Phyx-> ghci <module>
20:50:22 <twobitsprite> right
20:50:26 <Phyx-> and console is at http://sourceforge.net/projects/console/
20:50:55 <Phyx-> if you prefer something like emacs where ghci is inside the editor, or available
20:51:01 <Phyx-> notepad++ allows that
20:51:24 <ray> i just use powershell and notepad
20:51:40 <Saizan_> you can also use emacs on windows
20:52:04 <Phyx-> i use notepad++ for the synta highlighting, split view and different encoding and lineending supports
20:52:10 <Phyx-> since i work with people using macs alot
20:52:43 <Phyx-> albeit the syntax highlighting isn't perfect, as it's done via regexp, but it's close enough
20:54:29 <aavogt> do any editors do correct syntax highlighting? (yi?)
20:55:30 <twobitsprite> vim has always been pretty spot on afaict
20:55:58 <twobitsprite> Phyx-: btw... console is awesome...
20:56:19 <twobitsprite> almost as good as xterm in cygwin
20:56:39 <Makoryu> It would be nice if someone could implement syntax highlighting that correctly recognized type signatures
20:56:43 <Phyx-> twobitsprite: yeah, it removes most of the annoyances of windows commandlines
20:56:59 <Phyx-> i stopped using it because it launched slow in the past, but console2 is really fast
20:57:16 <twobitsprite> now if only I could find a desktop switch that worked as well as the various Linux ones
20:57:24 <aavogt> nah, vim messes up sometimes, ex. with {- comments spanning multiple lines, you have to refresh sometimes for it to work properly -}, and commenting imports doesn't change the color
20:57:28 <Phyx-> I got it setup in a quake style dropdown, pressing win+` toggles a drop down console windows with powershell as backend
20:57:46 <twobitsprite> aavogt: you can customize how far it will search for matches
20:57:47 <Phyx-> twobitsprite: there are multiple, depending on your needs
20:58:30 <aavogt> twobitsprite: could you tell me how to do that, or is it a generic vim thing?
20:58:51 * monochrom harps his "just use a virtual machine and run linux inside" again
20:59:17 <Nafai> monochrom: Uh, don't you have that backwards?
20:59:38 <monochrom> Not for all users and constraints.
20:59:42 * Phyx- sharpens his axe and heads for monochrom 
21:00:29 <Phyx-> twobitsprite: multiple desktop support is build into the os btw, they just don't have a frontend for it
21:00:46 <Phyx-> have you tried http://virtuawin.sourceforge.net/ ?
21:01:01 <monochrom> One may use Windows physically because of device driver issues, work requirements, "this computer isn't mine"... If you have to use Windows and go to great length to make it mimic linux, may as well use a virtual machine.
21:01:39 * Phyx- never mimics linux
21:01:59 * ray never misses linux, so he never mimics it
21:02:20 * Phyx- doesn't see what there is to mimic...
21:02:28 <ray> i was tempted to do the virtal machine thing recently, but that's just because i got pissed off at another sh dependency on hackage
21:02:36 <ray> i cooled off soon enough
21:03:04 <Phyx-> i was tempted when ghc 6.10.3's readline fiasko broke pasting on POSIX systems
21:03:10 <Phyx-> but then i downgrated
21:03:12 <Nafai> monochrom: I suppose that is right
21:03:25 <ray> monochrom is always often right
21:03:25 <Nafai> But for me, I never *ever* run Windows on physical hardware if I can help it
21:03:38 <ray> because you'd have to go to confession?
21:03:44 <Nafai> I haven't on a machine in my control for 10 years
21:04:01 <ray> or worse, confess to yout 12 step program?
21:04:04 <Phyx-> your choice i suppose
21:04:29 <Nafai> Phyx-: The right one :)
21:04:30 <Phyx-> anyway, twobitsprite those are what i use, minus the multiple desktops, i just don't find it usefull
21:05:05 <Phyx-> Nafai: whether a choice is right or wrong, it's all relative. Everyone uses what works for them, and for me, windows works
21:06:16 <Nafai> I know, sorry I tend to turn into troll mode to easily.  Forgive me.  #haskell should be more cordial.
21:06:30 * copumpkin orders Nafai back under the bridge
21:06:36 <ray> don't use that word
21:06:39 * Nafai huffs and slinks away
21:06:39 <ray> even if it's to describe yourself
21:06:54 <Phyx-> rofl
21:07:03 <ray> it should only be used for mythical creatures and those things you stick on the end of pencils
21:07:26 <ray> actually, i'm skirting danger by saying "mythical creatures", because i think the creature people use the t-word to denote is largely mythical
21:07:31 <ray> listen to what i mean, not what i say!
21:07:31 <Phyx-> or, i always thought os copumpkin , etc and all you haskell gurus as mythical creatures
21:07:40 <ray> copumpkin is a mythical creature
21:07:43 <copumpkin> :o
21:07:49 <copumpkin> definitely not a cat
21:07:52 <monochrom> I have one of those! It's an owl with a square hat, the academic square hat. "Dr. Owl".
21:08:16 <Nafai> regardless, thank goodness for virtual machines
21:08:37 <Nafai> They help us use and test on platforms other than our {preferred, required} ones
21:08:39 <copumpkin> Dr. Ong the Owl?
21:08:48 <ray> (not cat)
21:08:49 <Phyx-> while on the subject, does virtual box support 64bit oses yet?
21:08:54 <Phyx-> last time i tried. it locked up
21:09:10 <monochrom> If you have VT-x it does.
21:09:17 <d4> :t (\x -> x x) :: (forall a. a -> t) -> t
21:09:19 <lambdabot> forall t. (forall a. a -> t) -> t
21:09:26 <Phyx-> i have VT
21:11:16 * copumpkin just changed ken shan's signature
21:11:19 <copumpkin> strange concept
21:12:01 * Phyx- gets some orange juice
21:28:27 <hellowe> Do you care? http://www.anontalk.com/ICARE !
21:29:30 <Phyx-> hellow no i don't!
21:30:05 <vyom> how do i desugar a do block inside the GHC interpreter?
21:30:07 <monochrom> left.
21:30:43 <monochrom> It can't.
21:32:53 <Makoryu> vyom: You can always do it here
21:33:55 <vyom> Makoryu: I have a big example file which i loaded into ghci.. just trying to examine parts of it
21:33:57 <Makoryu> @undo do caffeine <- drink latte; sneakAround; return caffeine
21:33:58 <lambdabot> drink latte >>= \ caffeine -> sneakAround >> return caffeine
21:34:44 <pr> > product [1..9000]
21:34:49 <lambdabot>   mueval-core: Prelude.read: no parse
21:34:49 <lambdabot>  mueval: ExitFailure 1
21:35:29 <monochrom> @pl \x y -> x >>= \f -> y >> return f
21:35:29 <lambdabot> (. ((. return) . (>>))) . (>>=)
21:35:38 <pr> > foldl' (*) 1 [1..9000]
21:35:48 <Cale> pr: It's an unfortunate problem, but that's the message that lambdabot currently gives when the result takes too long to compute.
21:35:51 <lambdabot>   809958998668719085829131208009794964758281463929464089222191306909090154073...
21:35:58 <pr> Cale: okay :)
21:36:30 <pr> Cale: product [1..9000] and it's siblings are #haskells own "over 9000!!!111111" joke
21:36:36 <pr> at least i was told so yesterday ;)
21:36:56 <Cale> hmm...
21:37:00 <Cale> > product [1..9000]
21:37:03 <lambdabot>   809958998668719085829131208009794964758281463929464089222191306909090154073...
21:37:22 <Cale> yeah, just a hiccup. It doesn't actually take very long or very much memory to compute
21:38:13 <monochrom> > product [1.. product [1..9000]]
21:38:18 <lambdabot>   mueval-core: Prelude.read: no parse
21:38:18 <lambdabot>  mueval: ExitFailure 1
21:38:23 <Cale> That, however, certainly will ;)
21:38:44 <pr> hehe
21:38:57 <Cale> > product [9000,8998..1]
21:38:59 <lambdabot>   981359533650220922950343612884145681197950945880134704184249155106306354966...
21:39:37 <Cale> 9000!!
21:40:30 <ray> > product [1..9000] + 1 -- over 9000!
21:40:32 <lambdabot>   809958998668719085829131208009794964758281463929464089222191306909090154073...
21:40:52 <copumpkin> Cale: why is that !! ?
21:41:15 <BMeph> @go double factorial
21:41:16 <lambdabot> http://mathworld.wolfram.com/DoubleFactorial.html
21:41:16 <lambdabot> Title: Double Factorial -- from Wolfram MathWorld
21:41:22 <jmcarthur> :t \x y -> x >>= \f -> y >> return f
21:41:24 <Cale> http://en.wikipedia.org/wiki/Factorial#Double_factorial
21:41:24 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> m a1 -> m a
21:41:42 <jmcarthur> :t \x y -> x <* y
21:41:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
21:41:57 <BMeph> Cale: You know it's just gonna reference the Wolfram article anyway... ;)
21:42:05 <copumpkin> oh, I always thought double factorial was just applying the factorial to the factorial
21:42:13 <ray> no, that would make sense
21:42:41 <copumpkin> oh whoops
21:42:53 <copumpkin> silly me :)
21:43:07 <monochrom> !!! means multiply up the multiples of 3. Generally, if you see n !'s, mutiply up the multiples of n.
21:43:16 <monochrom> Example. 5!!!!! = 5.
21:44:17 <Cale> Well...
21:44:21 <copumpkin> that's annoying
21:44:36 <monochrom> I'm just making it up. No one cares about !!! or !!!!!.
21:45:30 <copumpkin> people care about !! ?
21:45:44 <Cale> !! shows up in various places
21:45:52 <aavogt> > repeat '!'
21:45:53 <lambdabot>   "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
21:46:15 <Cale> (more often than (n!)! does, seemingly)
21:46:38 <jfoutz> 1,2,720 ...
21:46:41 <Phyx-> !! is handy :P
21:47:02 <copumpkin> jfoutz: that's what it isn't, apparently :P
21:47:06 <Phyx-> @type (!!!)
21:47:07 <lambdabot> Not in scope: `!!!'
21:47:17 <jfoutz> 1!, 2!!, 3!!! ...
21:47:18 <monochrom> The number of people who care about !! is over 9000!!
21:47:40 <monochrom> 5!!!!!, 8!!!!!!!!, 13!!!!!!!!!!!!! ...
21:47:42 <Phyx-> @type (!!)
21:47:44 <lambdabot> forall a. [a] -> Int -> a
21:48:03 <Phyx-> > [undefined]!!0
21:48:04 <lambdabot>   * Exception: Prelude.undefined
21:48:53 <Phyx-> > let foo = ([undefined]!!0)::Int in dataTypeOf foo
21:48:55 <lambdabot>   DataType {tycon = "Prelude.Int", datarep = IntRep}
21:49:32 <jfoutz> monochrom: hahaha.
21:49:45 <jfoutz> fibactorial
21:50:44 <monochrom> I love extrapolating people's "1, 2, 3" with fibonacci. It fits and it is maximum surprise --- good humour.
21:51:37 <monochrom> "1 little, 2 little, 3 little indians. 5 little, 8 little 13 little indians". Or replace "indians" with "rabbits", "children"...
21:51:50 <Cale> 1, 2, 4, 8, 16, 31, 57, 99, 163, 256
21:52:08 <purplepenguins> rabbits are appropriate with the fibonnacci sequence
21:52:22 <monochrom> Yeah!
21:52:38 <Makoryu> > text . map chr $ [65288,12288,180,95,12445,96,65289]
21:52:39 <lambdabot>   （　´_ゝ`）
21:53:22 <jfoutz> Cale: wow. that one is cool.
21:53:49 <edwardk> > describe $ maybe undefined id $ lookupSequence [1, 2, 4, 8, 16, 31, 57, 99, 163, 256]
21:53:51 <lambdabot>   Not in scope: `describe'
21:53:59 * jfoutz cheated by using http://www.research.att.com/~njas/sequences/index.html
21:54:04 <edwardk> Math.OEIS.lookupSequence [1, 2, 4, 8, 16, 31, 57, 99, 163, 256]
21:54:17 <edwardk> > Math.OEIS.lookupSequence [1, 2, 4, 8, 16, 31, 57, 99, 163, 256]
21:54:20 <lambdabot>   Just (OEIS {catalogNums = ["A000127","M1119","N0427"], sequenceData = [1,2,...
21:54:22 <BMeph> monochrom: Next time, try spanning trees - now THERE's some "maximum surprise for you! >;)
21:54:35 <monochrom> haha
21:54:37 <mauke> @oeis  1, 2, 4, 8, 16, 31, 57, 99
21:54:38 <lambdabot>  Maximal number of regions obtained by joining n points around a circle by st...
21:54:38 <lambdabot>  [1,2,4,8,16,31,57,99,163,256,386,562,794,1093,1471,1941,2517,3214,4048,5036,...
21:54:42 * Phyx- puts on his hard hat and goes to work installing exchange server
21:54:45 <BMeph> Er, s/surprise /surprise" /
21:54:47 <edwardk> mauke: ah =)
21:55:06 <Phyx-> and maybe... a haskell build service for my svn... rejecting none compiling commits
21:55:09 <Phyx-> on the main trunk
21:55:55 <BMeph> @oeis 1, 2, 3, 6, 11
21:55:55 <lambdabot>  Number of trees with n unlabeled nodes.
21:55:55 <lambdabot>  [1,1,1,1,2,3,6,11,23,47,106,235,551,1301,3159,7741,19320,48629,123867,317955...
21:57:03 <Phyx-> @type oeis
21:57:04 <lambdabot> Not in scope: `oeis'
21:57:20 <edwardk> I wish Math.OEIS could return all sequences that included the subsequence rather than just the first.. maybe a lookupSequenceM or something so it could return in integer, etc.
21:57:22 <edwardk> er
21:57:28 <edwardk> in [Integer] etc
21:57:37 <edwardk> er [[Integer]] even ;)
21:58:36 <aavogt> @oeis 1, 2, 3, 4, 5, 6
21:58:37 <lambdabot>  The natural numbers. Also called the whole numbers, the counting numbers or ...
21:58:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:58:54 <Makoryu> @oeis 1, 2, 4
21:58:55 <lambdabot>  Powers of 2: a(n) = 2^n.
21:58:55 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
21:59:00 <jmcarthur> @oeis 0, 1, 2, 3, 4, 5
21:59:01 <jfoutz> @oeis 0,1,2,3,4,5
21:59:01 <lambdabot>  Digital sum (i.e. sum of digits) of n.
21:59:01 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,...
21:59:01 <lambdabot>  Digital sum (i.e. sum of digits) of n.
21:59:01 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,...
21:59:06 <jmcarthur> :P
21:59:11 <jfoutz> jinx
21:59:12 <BMeph> edwardk: 'lookupSequences', maybe? :)
21:59:39 <monochrom> @oeis 3,1,3,3,7
21:59:39 <lambdabot>  2^A000120(n)-1.
21:59:40 <lambdabot>  [0,1,1,3,1,3,3,7,1,3,3,7,3,7,7,15,1,3,3,7,3,7,7,15,3,7,7,15,7,15,15,31,1,3,3...
22:00:03 <jmcarthur> @oeis 1,3,3,7
22:00:04 <lambdabot>  a(0) = 0; for n > 0, a(n) = number of proper divisors of n.
22:00:04 <lambdabot>  [0,0,1,1,2,1,3,1,3,2,3,1,5,1,3,3,4,1,5,1,5,3,3,1,7,2,3,3,5,1,7,1,5,3,3,3,8,1...
22:00:18 <BMeph> @oeis 1, 2, 2, 1, 1
22:00:18 <lambdabot>  Number of distinct primes dividing n (also called omega(n)).
22:00:18 <lambdabot>  [0,1,1,1,1,2,1,1,1,2,1,2,1,2,2,1,1,2,1,2,2,2,1,2,1,2,1,2,1,3,1,1,2,2,2,2,1,2...
22:00:32 <Cale> @oeis 0, 1, 2, 3, 4, 6, 5, 7, 8, 9
22:00:33 <lambdabot>  Self-inverse permutation of natural numbers induced by reflections of the ro...
22:00:33 <lambdabot>  [0,1,2,3,4,6,5,7,8,9,14,11,16,19,10,15,12,17,20,13,18,21,22,23,37,28,42,51,2...
22:00:33 <purplepenguins> divisor function!
22:00:55 <sohum> what's that thing that if you give it a type signature it gives you the function?
22:01:02 <jmcarthur> djinn
22:01:08 <BMeph> @oeis 1, 2, 2, 1, 1, 2, 1
22:01:09 <lambdabot>  Number of distinct primes dividing n (also called omega(n)).
22:01:09 <lambdabot>  [0,1,1,1,1,2,1,1,1,2,1,2,1,2,2,1,1,2,1,2,2,2,1,2,1,2,1,2,1,3,1,1,2,2,2,2,1,2...
22:01:29 <Cale> @djinn (a -> Either b c) -> (b -> d) -> (c -> d) -> a -> d
22:01:30 <lambdabot> f a b c d =
22:01:31 <lambdabot>     case a d of
22:01:31 <lambdabot>     Left e -> b e
22:01:31 <lambdabot>     Right f -> c f
22:01:43 <sohum> jmcarthur: aha, danke
22:01:59 <sohum> @djinn Monad m => m a -> m a -> m a
22:02:00 <lambdabot> Error: Class not found: Monad
22:02:07 <sohum> @djinn m a -> m a -> m a
22:02:08 <lambdabot> f _ a = a
22:02:13 <sohum> heh
22:02:19 <BMeph> @oeis 1, 2, 2, 1, 1, 2, 1, 2, 2, 1
22:02:19 <lambdabot>  Kolakoski sequence: a(n) is length of n-th run; a(1) = 1; sequence consists ...
22:02:19 <lambdabot>  [1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,2,1,1,2,1,2,2,1,2...
22:02:22 <ski> > (`map` [0..]) (+: \i -> succ i +: \j -> succ j)
22:02:26 <lambdabot>   [0,1,4,10,20,35,56,84,120,165,220,286,364,455,560,680,816,969,1140,1330,154...
22:02:50 <jfoutz> @djinn (a -> b -> c) -> (a -> b) -> c
22:02:50 <lambdabot> -- f cannot be realized.
22:03:17 <vyom> I do not understand the usage of (do mapM_ collect list) here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3369#a3369 Imperatively speaking every time collect is called it will generate a new state..What am I missing? How does the state pass from one call of collect to another
22:03:57 <jmcarthur> @src mapM_
22:03:57 <lambdabot> mapM_ f as = sequence_ (map f as)
22:04:02 <jmcarthur> @src sequence_
22:04:03 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
22:04:06 <shachaf> vyom: Why does it?
22:04:21 <shachaf> vyom: runState (...) is outside the mapM_ collect.
22:04:27 <edwardk> BMeph: that would work nicely
22:04:50 * Phyx- wonders why he's up at 7 am again looking at you bunch typing haskell code
22:04:57 <ski> vyom : s/state where (_, state) = runState/execState/
22:05:01 <monochrom> >>= passes state. mapM_ boils down to lots of >>=
22:05:29 * copumpkin used (strength <=<) today
22:05:36 * copumpkin beams
22:05:46 <ski> @type (strength <=<)
22:05:48 <lambdabot> Not in scope: `strength'
22:05:50 <jfoutz> :t strength
22:05:52 <lambdabot> Not in scope: `strength'
22:05:52 <copumpkin> where strength was the tuple version
22:05:58 <shachaf> monochrom: (In this case a lot of (>>).)
22:06:01 <vyom> shachaf:  aargh.. got it! that was a pretty stupid question
22:06:30 <BMeph> strength :: (a, f b) -> f (a, b) -- This one? :)
22:06:31 <ski> @let strength :: Functor f => (a,f b) -> f (a,b); strength (a,fb) = fmap ((,) a) fb
22:06:32 <lambdabot>  Defined.
22:06:37 <copumpkin> BMeph: yup
22:06:38 <ski> @type (strength <=<)
22:06:40 <lambdabot> forall a (m :: * -> *) b a1. (Functor m, Monad m) => (a1 -> m (a, m b)) -> a1 -> m (a, b)
22:06:59 <copumpkin> :t strength
22:07:01 <lambdabot> forall a (f :: * -> *) b. (Functor f) => (a, f b) -> f (a, b)
22:07:06 <vyom> shachaf:  I think i missed out on the fact that it is all lazily evaluated
22:07:24 <jmcarthur> :t sequence
22:07:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
22:07:48 <monochrom> (Is it? Try Control.Monad.State.Strict)
22:07:49 <jmcarthur> oh it's not quite Data.Traversable.sequence
22:07:57 <jmcarthur> it's the other direction
22:08:02 <shachaf> monochrom: Would that make any difference in this case?
22:08:04 <ski> vyom : it would work the same in a strict language
22:08:14 <jmcarthur> and works on different types, of course
22:08:28 <jmcarthur> copumpkin: where does the name strength come from?
22:08:30 <shachaf> vyom: You can think of State functions like IO functions (as "actions").
22:08:31 <monochrom> No. And so laziness is beside the point.
22:08:41 <sohum> hm, seems I'm looking for mplus
22:08:49 <ski> jmcarthur : the category terrorists
22:08:58 <copumpkin> jmcarthur: strong functors/monads (haven't read that far though yet, so I don't actually know what the CT interpretation is, just that it's useful when working with key-value pairs)
22:08:59 <jmcarthur> ski: well.... more specifically! :P
22:09:12 <jmcarthur> copumpkin: ah, okay
22:09:23 <jmcarthur> i accept a mystery for now
22:09:26 <monochrom> Cute, category terrorists is CT too.
22:10:36 <monochrom> That is ambiguous. Someone may see "terrorists who are cute and category".
22:10:50 <copumpkin> jmcarthur: for example, if I have a graph structure where I have a (simplified) Map NodeId [NodeId] for my adjacency, I can ask for assocs and get a (NodeId, [NodeId]), but if I want a list of edges, I can call strength on it and get all the edges as (NodeId, NodeId), and if I concatMap (=<<) it across all assocs I get all edge pairs
22:12:21 <BMeph> monochrom: "Cutegory terrorists"? ;)
22:12:31 <jfoutz> @djinn (a,[a]) -> [(a,a)]
22:12:31 <lambdabot> Error: Undefined type []
22:12:59 <ski> @djinn (a,Maybe b) -> Maybe (a,b)
22:12:59 <lambdabot> f (a, b) =
22:12:59 <lambdabot>     case b of
22:12:59 <lambdabot>     Nothing -> Nothing
22:12:59 <lambdabot>     Just c -> Just (a, c)
22:13:34 <Armored_Azrael> Do we have a function (IArray a e, IArray a i, Ix i, Ix e) => a e i -> a i e
22:13:38 <monochrom> djinn doesn't know about []. Recursively defined type.
22:13:45 <jfoutz> ahhh.
22:14:17 <Armored_Azrael> Essentially, given that the result of array lookups are able to be an index, flip the indexing scheme?
22:14:39 <monochrom> Not in the libraries.
22:14:47 <Armored_Azrael> :(
22:14:50 <purplepenguins> @djinn a -> Bool
22:14:50 <Armored_Azrael> OK
22:14:50 <lambdabot> f _ = False
22:15:17 <ski> @djinn Void -> Bool
22:15:18 <lambdabot> f = void
22:15:40 <jfoutz> > void
22:15:42 <lambdabot>   Not in scope: `void'
22:15:43 <copumpkin> @djinn Bool -> Void
22:15:43 <lambdabot> -- f cannot be realized.
22:15:47 <copumpkin> :(
22:16:16 <ski>   void :: Void -> a
22:16:21 <Phyx-> wth is a djinn
22:16:22 <ski>   void v = case v of {}
22:16:31 <Phyx-> golden sun ?
22:16:40 <monochrom> @web1913 djinn
22:16:42 <lambdabot> No match for "djinn".
22:16:48 <copumpkin> Phyx-: a spirit
22:16:53 <copumpkin> (in Arabian and Muslim mythology) an intelligent spirit of lower rank than the angels, able to appear in human and animal forms and to possess humans. Compare with genie .
22:17:04 <copumpkin> djinni = genie
22:17:07 <Phyx-> copumpkin: lol
22:17:26 <Phyx-> copumpkin: well... they make for great summons
22:17:27 * jfoutz thinks kids today didn't play enough dnd
22:17:57 <monochrom> I make up for it by playing enough Munchkin.
22:17:57 <Phyx-> jfoutz: never played it infact
22:17:59 <Phyx-> nor seen it
22:18:01 <ski> @die 3d6
22:18:01 <lambdabot> 3d6 => 16
22:18:14 <Phyx-> copumpkin: i was referint to http://goldensun.wikia.com/wiki/Djinn btw
22:18:24 <copumpkin> lol
22:19:32 <jfoutz> well, that's fine then. sorry i was a grumpy old man.
22:19:40 <copumpkin> :)
22:20:00 <ski> don't be sorry. being a grumpy old man is fine
22:20:09 <Phyx-> lol
22:20:27 <Phyx-> well... i never played it cauze i never had anyone to play it with...
22:20:42 <Phyx-> the grumpy old mens said i was too young...
22:23:54 <copumpkin> back in my day, nobody ever reminisced about how it was back in their day
22:24:27 <monochrom> Poor you. Lack history.
22:25:09 <Phyx-> and/or motivation...
22:25:26 <jfoutz> hmm instance Applicative BackInTheDay ?
22:35:00 <BMeph> Back in my day, old folks had amnesia, and they liked it! If they didn't like it, we forgot about 'em until they did! ;p
22:36:59 <sohum> haskell's list comprehension syntax - does it work for arbitrary monads?
22:37:10 <copumpkin> it used to
22:37:14 <copumpkin> now you have to write do again
22:37:25 <blackdog> copumpkin: back in the day? :)
22:37:31 <copumpkin> back in my day
22:37:31 <copumpkin> oh wait
22:37:42 <sohum> copumpkin: why'd they remove it?
22:37:55 <copumpkin> there was some big movement against polymorphism for being too confusing
22:38:05 <copumpkin> so they made a whole bunch of stuff monomorphic
22:38:28 <copumpkin> not really sure about the details
22:38:55 <dibblego> sounds like someone needed a dose of Chopper Reid
22:41:51 <sohum> booooo
22:41:54 <Phyx-> hmmm polymorphism being too confusing? some would say it still is...
22:42:11 <sohum> similarly, (++) should be an alias to mplus dammit
22:42:27 <copumpkin> sohum: I think it was also syntactic thing about [ ] around a comprehension
22:42:41 <dibblego> s/mplus/mappend
22:42:50 <sohum> yea, that does imply it's a list, doesn't it
22:43:16 <sohum> dibblego: what's the difference?
22:43:25 <dibblego> @type (mappend, mplus)
22:43:27 <lambdabot> forall a (m :: * -> *) a1. (Monoid a, MonadPlus m) => (a -> a -> a, m a1 -> m a1 -> m a1)
22:44:51 <sohum> ah
22:46:27 <Cale> sohum: Personally, I think (++) = mappend is nicer :)
22:47:06 <sohum> woo for higher levels of abstraction :}
22:47:10 <dibblego> that's what I meant too :)
22:51:21 <roconnor> how many syllables in Boolean?
22:51:36 <copumpkin> 3?
22:52:12 <roconnor> I need to learn to stop pronouncing it with 2.
22:52:20 <copumpkin> although now that you ask, I can see how you could see that as Boole-an
22:52:24 <copumpkin> but that'd be really weird to hear
22:52:37 <Phyx-> kinda french sounding
22:52:40 <roconnor> I say Bool-lean
22:52:46 <copumpkin> oh ok :)
22:52:52 <copumpkin> well his name was Boole, so Boole-an might make sense
22:53:05 <roconnor> true
22:53:20 <roconnor> false
22:53:24 <roconnor> one of the two
22:53:26 <roconnor> :D
22:53:27 <Phyx-> undefined
22:53:48 <Berengal> Meh, Bool
22:54:02 <copumpkin> ?
22:54:11 <Berengal> One sylable, bool
22:54:18 <Phyx-> @type (===)
22:54:19 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
22:54:23 <Phyx-> yay, still there
22:54:28 <copumpkin> :)
22:54:34 <copumpkin> you could write it yourself if it wasn't :P
22:55:23 <Phyx-> well it's an interesting idea, though does it have any real benefit over the standard definition?
22:57:03 <Phyx-> @quickscheck \a b -> (a === b) == (a == b)
22:57:03 <lambdabot> Unknown command, try @list
22:57:09 <Phyx-> @quickcheck \a b -> (a === b) == (a == b)
22:57:09 <lambdabot> Unknown command, try @list
22:57:12 <copumpkin> @check
22:57:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:57:15 <Phyx-> @check \a b -> (a === b) == (a == b)
22:57:16 <lambdabot>   Not in scope: `==='
22:57:24 <copumpkin> aw
22:57:28 <copumpkin> they don't share their state
22:57:35 <Phyx-> seems not :(
22:58:10 <Phyx-> @share
22:58:10 <lambdabot>  @where <key>, return element associated with key
22:58:12 <Phyx-> :p
22:58:28 <Phyx-> hm? wth is that command
23:01:35 <copumpkin> @where lyah
23:01:35 <lambdabot> www.learnyouahaskell.com
23:02:03 <copumpkin> @where+ Phyx he's right here! (well, he might not be when you ask @where, but he was here when I wrote @where+)
23:02:03 <lambdabot> It is stored.
23:02:12 <copumpkin> @where Phyx
23:02:12 <lambdabot> he's right here! (well, he might not be when you ask @where, but he was here when I wrote @where+)
23:02:34 * Phyx- wonders why so many people recommend lisp over haskell.. or rather as "the" functional language
23:02:56 <Phyx-> @share Phyx
23:02:57 <lambdabot> he's right here! (well, he might not be when you ask @where, but he was here when I wrote @where+)
23:02:57 <lispy> Phyx-: many people prefer dynamic languages
23:03:05 <lispy> ?quote Phyx-
23:03:05 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
23:03:08 <lispy> ?quote Phyx
23:03:09 <lambdabot> No quotes match. I feel much better now.
23:03:12 <lispy> ?quote
23:03:12 <lambdabot> Riastradh says: that's bullcrap, stop speaking nonsense!
23:03:25 <Phyx-> i'm too controversial to quote :P
23:03:29 <mauke> preflex: quote
23:03:29 <copumpkin> @quote Riastradh
23:03:29 <lambdabot> Riastradh says: that's bullcrap, stop speaking nonsense!
23:03:31 <preflex>  <*> mauke bows to icke's dic
23:04:18 <mauke> preflex: quote
23:04:20 <preflex>  <uninverted> Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
23:05:04 <lpsmith> heh
23:05:09 <Phyx-> @list
23:05:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:05:47 <Phyx-> @. id id
23:06:01 <Phyx-> @compose id id
23:06:08 <Phyx-> ok...
23:06:12 <copumpkin> @@ @id @id moo
23:06:12 <lambdabot>   moo
23:06:12 <lpsmith> you can write partial application macros :-P
23:06:36 <Phyx-> @dummy
23:06:37 <lambdabot> dummy
23:06:51 <Phyx-> @map (+1) [0]
23:06:51 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:06:58 <Phyx-> eh?
23:07:14 <Phyx-> @elite
23:07:14 <lambdabot> Say again?
23:07:16 <lpsmith> > map (+1) [0]
23:07:17 <lambdabot>   [1]
23:07:20 <mauke> @shapr Phyx-
23:07:20 * lambdabot places her fist firmly on Phyx-'s jaw
23:07:25 <Phyx-> @elite Phyx
23:07:26 <lambdabot> PHyX
23:07:30 <Phyx-> lol!
23:07:42 <Phyx-> lambdabot: i thought you were a he!
23:07:45 <lpsmith> shouldn't that be @1337
23:07:54 <lpsmith> @elite elite
23:07:54 <lambdabot> ElI+3
23:08:00 <mauke> @vixen are you a he?
23:08:02 <lambdabot> yes, i am
23:08:04 <mauke> !
23:08:17 <Phyx-> hahah
23:08:23 <vav> @vixen are you a guy?
23:08:24 <lambdabot> no, i'm a woman
23:08:40 <Phyx-> @free let x = x + y
23:08:41 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
23:08:46 <Phyx-> @free let x = x + x
23:08:47 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
23:08:55 <mauke> @free id
23:08:57 <lambdabot> f . id = id . f
23:08:58 <Phyx-> @free \x -> x + x
23:08:58 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
23:09:37 <Phyx-> @karma
23:09:37 <Berengal> Did \b just solve the halting problem?
23:09:37 <lambdabot> You have a karma of 0
23:09:40 <mauke> @free isJust :: Maybe a -> Bool
23:09:41 <lambdabot> isJust = isJust . $map_Maybe f
23:09:54 <Phyx-> i don't get it
23:10:01 <Phyx-> @karma mauke
23:10:01 <lambdabot> mauke has a karma of 14
23:10:04 <Phyx-> :O
23:10:10 <mauke> preflex: karma
23:10:10 <preflex>  mauke: 96
23:10:57 <Phyx-> no karma for me
23:11:05 <Phyx-> @time
23:11:09 <lambdabot> Local time for Phyx- is Thu Aug 20 08:10:52 2009
23:11:21 <Phyx-> heh
23:11:27 <mauke> @time
23:11:31 <lambdabot> Local time for mauke is just silly. I mean, has anyone really been far even as decided to use even go want to do look more like?
23:11:49 <Phyx-> -.-
23:11:58 <Phyx-> @more
23:12:03 <Phyx-> @more [1..]
23:12:22 <mauke> @time
23:12:26 <lambdabot> Local time for mauke is none of your concern
23:12:33 <Phyx-> @poll-list
23:12:33 <lambdabot> ["ParallelCobind","logoVotingMethod"]
23:12:47 <Phyx-> @poll-result
23:12:47 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
23:12:57 <Phyx-> @poll-result logoVotingMethod
23:12:57 <lambdabot> Poll results for logoVotingMethod (Open): Schulze=1
23:13:13 <Phyx-> not used i see
23:13:21 <Phyx-> @pretty
23:13:26 <Phyx-> @pretty id
23:13:26 <lambdabot>  id
23:13:30 <Phyx-> aha
23:13:39 <copumpkin> @vixen
23:13:39 <lambdabot> Why is magenta on blues clues a boy while blue is a girl? what has this world come to and what is wrong with the government, blues clues should be stopped while its ahead!!
23:13:47 <Phyx-> @pretty @vixen
23:13:48 <lambdabot> "Parse error" at column 1
23:13:58 <mauke> @yow
23:13:59 <lambdabot> Let's send the Russians defective lifestyle accessories!
23:14:06 <copumpkin> @seen soupdragon
23:14:06 <lambdabot> I saw soupdragon leaving ##logic 2h 41m 45s ago, and .
23:14:16 <Phyx-> @slap
23:14:16 * lambdabot will count to five...
23:14:17 <blackdog> Phyx-: you trying to confuse my girl? :)
23:14:23 <Phyx-> eh?
23:14:46 * Phyx- has no proof that it's a she
23:14:47 <Phyx-> lol
23:14:58 <Phyx-> @ghc --help
23:14:58 <lambdabot> ghc says: For basic information, try the `--help' option.
23:15:06 <Phyx-> -.-
23:15:11 <Phyx-> @ghc --version
23:15:12 <lambdabot> No quotes match. Maybe you made a typo?
23:15:19 * blackdog suspects she is a facsimile, built from regular expressions, a random number generator, and rubber bands
23:15:33 <mauke> @ghc
23:15:33 <lambdabot> ghc says: try_stub.o: unknown symbol `Safe_zdffibonaccizuhszuaM1_closure'
23:15:41 <Phyx-> @yarr
23:15:42 <lambdabot> Aye
23:15:46 <mauke> preflex: zdec Safe_zdffibonaccizuhszuaM1_closure
23:15:47 <preflex>  Safe_$ffibonacci_hs_aM1_closure
23:16:08 <Phyx-> @yhjulwwiefzojcbxybbruweejw
23:16:08 <lambdabot> "\"#$%&'()*+,\""
23:16:19 <Phyx-> @protontorpedo
23:16:19 <lambdabot> waht is this D&D
23:16:49 <Phyx-> @uptime
23:16:50 <lambdabot> uptime: 14d 3h 16m 44s, longest uptime: 1m 10d 23h 44m 29s
23:17:03 <Phyx-> only?
23:17:11 <Phyx-> haskell bot dies? say it aint soo
23:17:18 <mauke> happens all the time
23:17:24 <copumpkin> you can kill it if you know the secret word
23:17:35 <mauke> @quit?
23:17:35 <lambdabot> Not enough privileges
23:17:38 <copumpkin> but /me has used it too much and will probably get banned if he uses it anymore
23:17:40 <Phyx-> copumpkin: "please" ?
23:17:55 <Phyx-> @die
23:17:56 <lambdabot> unexpected end of input: expecting number
23:18:01 <Berengal> rumplestiltskin ?
23:18:04 <Phyx-> @die 0
23:18:04 <lambdabot> 0 => 0
23:18:04 <mauke> @die 1d6
23:18:05 <lambdabot> 1d6 => 5
23:18:14 <Phyx-> @die a
23:18:14 <lambdabot> unexpected "a": expecting number
23:18:21 <Phyx-> @die l4d
23:18:21 <lambdabot> unexpected "l": expecting number
23:18:38 <Phyx-> @unlambda \x->x*x
23:18:38 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
23:18:46 <Phyx-> wah...
23:18:56 <mauke> I think all interpreters are broken
23:18:59 <Phyx-> @unlambda stdin
23:19:00 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
23:19:08 <Phyx-> aha
23:19:13 <mauke> also, those aren't valid unlambda programs
23:19:20 <Phyx-> @messages?
23:19:20 <lambdabot> Sorry, no messages today.
23:19:22 <copumpkin> Phyx-: there's one command you can run that'll lock lambdabot up for several minutes until it quits and rejoins
23:19:59 <Phyx-> mauke: well, i didn't know what they do, i thought unlambda would take a lambda expression
23:20:04 <Phyx-> copumpkin: hmm
23:20:11 <mauke> no, that's @pl
23:20:27 <copumpkin> unlambda takes unlambda code
23:20:29 <copumpkin> but I think it's broken
23:20:36 <Phyx-> -.-
23:20:41 <mauke> @pl \x -> x*x
23:20:42 <lambdabot> join (*)
23:20:42 <Phyx-> @girl19
23:20:42 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
23:21:12 <Phyx-> @fact-update *
23:21:12 <lambdabot> Fact recorded.
23:21:16 <Phyx-> eh?
23:21:17 <mauke> wtf
23:21:26 * Phyx- hides
23:21:28 <Armored_Azrael> Do we have any existing quadratic programming bindings, and if we don't, does anyone have any favorite C QP packages? (I need QP for something, and if we don't have bindings I'll write some and put them on hackage)
23:21:29 <copumpkin> Phyx-: it's along the lines of what mauke did, but a little more involved
23:22:07 * Phyx- doesn't even know what QP is sorry
23:22:30 <Phyx-> copumpkin: oh.. never got my local pointless to crash...
23:22:52 <copumpkin> Armored_Azrael: I don't know of any * programming / optimization bindings in haskell sadly, although they'd be handy
23:23:11 <Phyx-> @fact
23:23:12 <lambdabot> I can not handle empty facts.
23:23:17 <Phyx-> oh uh
23:23:28 <Armored_Azrael> copumpkin: Any preferred C packages? In the past I've been told to use matlab, which I really don't like, and is not something that I want to bind to haskell.
23:24:43 <copumpkin> Armored_Azrael: haven't actually needed QP, but have wanted LP for various reasons, and other kinds of optimization (TAO/PETSc for example)
23:26:03 <copumpkin> Armored_Azrael: I think haskell tends to attract different kinds of mathematicians than those who would do large optimization problems, but maybe you can change that :D
23:37:27 <copumpkin> anyone know what the graphviz parameter is to let me lay out a bipartite graph vertically?
23:37:38 <copumpkin> so that I get one vertex set on the left and one on the right?
23:38:09 <copumpkin> ah, rankdir seems to do it
23:41:32 <maxote> is Maybe related to value or _|_ ?
23:42:45 <ski> "value" ?
23:42:47 <maxote> does GHC support exceptions to avoid writing more Maybe's code?
23:44:30 <copumpkin> maxote: not sure I understand the question
23:44:44 <copumpkin> Maybe "works at the value level"
23:45:10 <ski> > map fromJust [Just (),Nothing]
23:45:11 <maxote> e.g. Int * Int -> Int
23:45:11 <lambdabot>   [(),* Exception: Maybe.fromJust: Nothing
23:45:28 <maxote> e.g. Int / Int -> Just(Int) or Nothing
23:46:16 <copumpkin> (Int, Int) -> Int ?
23:46:31 <vav> > (1/0,0/0)
23:46:33 <lambdabot>   (Infinity,NaN)
23:47:56 <maxote> > sin(1/0)
23:47:58 <lambdabot>   NaN
23:48:11 <ski> > map (6 /|) [6,5..0]
23:48:13 <lambdabot>   [Just 1,Just 1,Just 1,Just 2,Just 3,Just 6,Nothing]
23:48:20 <maxote> why is not raised the exception Infinity?
23:48:36 <maxote> > sin(1/0) + sin(0/0)
23:48:37 <ski> `Infinity' is not an exception
23:48:37 <lambdabot>   NaN
23:48:43 <copumpkin> > 1 `div` 0
23:48:44 <lambdabot>   * Exception: divide by zero
23:48:49 <maxote> > sin(0/0) + sin(1/0)
23:48:51 <lambdabot>   NaN
23:48:55 <ski> > 1 / 0
23:48:56 <lambdabot>   Infinity
23:48:59 <copumpkin> that's just the IEEE spec
23:49:18 <maxote> > sin(0/0) + (1 'div' 0)
23:49:20 <lambdabot>   <no location info>:
23:49:20 <lambdabot>      lexical error in string/character literal at chara...
23:49:31 <maxote> > sin(0/0) + (1 `div` 0)
23:49:33 <lambdabot>   Add a type signature
23:49:58 <maxote> what wrong is it?
23:50:12 <ski> i can't recally any `a' such that `(Integral a,Fractional a)'
23:50:27 <ski> @type div
23:50:29 <lambdabot> forall a. (Integral a) => a -> a -> a
23:50:29 <ski> @type (/)
23:50:31 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:51:45 <ski> > 17 / 7
23:51:46 <lambdabot>   2.4285714285714284
23:51:49 <ski> > 17 `div` 7
23:51:49 <maxote> > sin(0/0) + (1 `div` 0)::Integral
23:51:51 <lambdabot>   mueval-core: Prelude.read: no parse
23:51:51 <lambdabot>  mueval-core: GhcException "mkTopLevEnv...
23:51:52 <lambdabot>   Class `GHC.Real.Integral' used as a type
23:52:12 <ski> > 17 `div` 7
23:52:13 <lambdabot>   2
23:52:16 <ski> ty
23:52:49 <ski> `div' is for truncating (aka integral) division
23:53:47 <maxote> GHC's something is not perfect
23:54:12 <ski> sorry ?
23:54:51 <maxote> > sin(0/0) + (1 `div` 0)::Fractional
23:54:52 <lambdabot>   Class `GHC.Real.Fractional' used as a type
23:55:14 <dmwit> Fractional and Integral are classes, not types.
23:55:43 <dmwit> You can think of a class as a set of types, if you like.
23:55:48 <ski> > sin (0/0) + fromIntegral (1 `div` 0)
23:55:50 <lambdabot>   * Exception: divide by zero
23:55:56 <ski> > sin (0/1) + fromIntegral (1 `div` 0)
23:55:57 <lambdabot>   * Exception: divide by zero
23:56:03 <ski> > sin (0/0) + fromIntegral (1 `div` 1)
23:56:03 <maxote> why not NaN?
23:56:05 <lambdabot>   NaN
23:56:24 <maxote> > sin (0/0) + fromIntegral (1 `div` 0
23:56:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:56:29 <maxote> > sin (0/0) + fromIntegral (1 `div` 0)
23:56:29 <dmwit> > let myDivide x y = guard (y /= 0) >> return (x / y) in 3 `myDivide` 0
23:56:31 <lambdabot>   mueval-core: Prelude.read: no parse
23:56:31 <lambdabot>  mueval-core: GhcException "mkTopLevEnv...
23:56:32 <lambdabot>   No instance for (GHC.Show.Show (m t))
23:56:32 <lambdabot>    arising from a use of `M3173107737...
23:56:50 <dmwit> > let myDivide x y = guard (y /= 0) >> return (x / y) in 3 `myDivide` 0 :: Maybe Double
23:56:52 <lambdabot>   Nothing
23:56:56 <dmwit> > let myDivide x y = guard (y /= 0) >> return (x / y) in 3 `myDivide` 2 :: Maybe Double
23:56:58 <lambdabot>   Just 1.5
23:57:00 <ski> > 3 /| 0
23:57:02 <lambdabot>   Nothing
23:57:07 <Stinger> ieee has +0/-0 doesnt it?
23:57:29 <dmwit> Stinger: I don't think so, but there's +/-Infinity.
23:57:31 <ski> > negate 0 :: Double
23:57:32 <lambdabot>   -0.0
23:57:35 <dmwit> ack
23:57:43 <dmwit> That's horrible.
23:57:49 <dmwit> > negate (negate 0)
23:57:51 <lambdabot>   0
23:57:58 <ski> > negate 0 == (0 :: Double)
23:57:59 <lambdabot>   True
23:58:07 <dmwit> > negate 0 + 1 - 1
23:58:09 <lambdabot>   0
23:58:12 <dmwit> =(
23:58:18 <dmwit> > negate 0 + 1 - 1 :: Double
23:58:19 <lambdabot>   0.0
23:58:26 <dmwit> still =(
23:58:28 <Stinger> > 1+ (negate 0 :: Double) - 1
23:58:29 <lambdabot>   0.0
23:58:33 <Stinger> hmmm :/
23:58:54 <dmwit> Addition isn't associative or commutative for Double. =P
