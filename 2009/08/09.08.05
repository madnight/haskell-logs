00:11:20 <blackdog> trying to build GHC HEAD, and getting this error:
00:11:20 <blackdog> Couldn't match expected type `old-time-1.0.0.1:System.Time.ClockTime' against inferred type `ClockTime'
00:11:32 <blackdog> does that ring any bells for anyone? am i doing something dumb?
00:24:48 <ksf> hmmm. I'd like to replace one type of a class instance with another one, reusing that instance... i've got a bijection that can manage it, but is there a way to use some typemagic to do it insteal of wrapping all the functions manually?
00:31:21 <PetRat> In the typeclassopedia, it is an excise to define pure on Ziplist. Is it pure g = repeat g?
00:31:41 <ski> why ?
00:32:04 <ksf> tail . pure == []
00:32:22 <ski> PetRat : check the laws ?
00:32:25 <ksf> ...at least that's what i'd expect pure to obey
00:32:27 <ski> ksf : ?
00:33:17 <PetRat> Well, my reasoning is I have to satisfy fmap g xs = pure g <*> xs. In ZipList, <*> is zipping with $.
00:33:27 <ski> yes
00:33:40 <ski> so would `pure = repeat' satisfy that ?
00:35:00 <PetRat> My reasoning is that I need to define pure so that pure g <*> xs is that same as applying g to every element in xs. So I need to create a list of gs.
00:35:11 <ski> yes
00:35:40 <ski> and since you don't know how long `xs' is, you have to take an infinite list of `g's
00:35:50 <PetRat> That was my reasoning, yes.
00:36:10 <ski> and it's right
00:36:14 <PetRat> ski: are you saying that is correct and you just wanted to know my thought process?
00:36:19 <ski> (you need to check the other laws as well, of course)
00:36:19 <PetRat> ski: got it.
00:36:40 <ski> (yes, i wanted to check your argumentation)
00:37:26 <PetRat> ski: in typeclassopedia Brent glosses over the other Applicative laws. He says they are related to our understanding of pure.
00:37:36 <PetRat> But doesn't say any more.
00:38:15 <ski>   pure f <*> as = fmap f as
00:38:27 <ski>   fs <*> pure a = fmap ($ a) fs
00:39:05 <PetRat> Are those the Applicative laws related to pure?
00:39:28 <ski>   fs <*> as <*> bs = fmap uncurry fs <*> (fmap (,) as <*> bs)
00:39:32 <ski> that's the laws
00:40:03 <PetRat> Okay, thanks.
00:40:44 <ski> you can think of them as; left identity, right identity and associativity laws
00:42:13 <ski> the right identity law should hopefully be obvious what it means ..
00:43:04 <ski> .. the associativity says that it doesn't matter if you bracket `(.. <*> ..) <*> ..' or `.. <*> (.. <*> ..)' .. modulo the required fudging to makes the types match
00:55:03 <Saizan> monoids everywhere :)
00:55:37 <opqdonut> monoids to the left of me, functors to the right
00:58:31 <augustss_> I really hate whole ByteString mess. :(
00:58:58 <dancor> which part
00:59:10 <dancor> i don't like how binary uses ByteString Internals
00:59:15 <augustss_> I always seem to have a lazy byte string when I need a strict one and v.v.
00:59:19 <dancor> right
00:59:36 <augustss_> I'm using binary, and then I need useAsCStringLen
00:59:55 <augustss_> but the latter is for strict byte strings, and binary uses lazy
01:00:20 <dancor> laziness in general certainly brings a lot of issues to the table
01:01:27 <augustss_> I don't mind there being strict and lazy ones, but then the interface to them need to be via overloaded function so code using byte strings works with both
01:02:09 <augustss_> As it is, it totally goes against the spirit of Haskell, I think
01:02:19 <blackdog> augustss_: why is that a problem?
01:02:57 <dancor> i sometimes wonder if there should be a Stringy typeclass
01:03:07 <augustss_> Why is what a problem?  The current situation?  Or making a type class?
01:03:24 <blackdog> having to use a type class
01:03:50 <augustss_> There's no problem making a Stringy type class, but that's not the current situation
01:04:37 <blackdog> augustss_: oh, right. misread you, sorry. Yeah, a Stringy typeclass would have been nice... might have saved the pain of switching from [Char] too
01:04:44 <dancor> well i think i could make a Stringy typeclass
01:05:05 <dancor> and put it on hackage
01:05:13 <blackdog> dancor: sure. but everything is expecting a concrete type, y'know? it's a social thing.
01:05:14 <augustss_> The names in the type class will class with prelude names.
01:05:25 <augustss_> Exactly!
01:05:36 <augustss_> It's in some ways too late already.
01:05:52 <dancor> hm
01:06:01 <blackdog> augustss_: damn success. soon we won't be able to make anything incompatible at all :)
01:06:24 <dancor> import qualified Text.Stringy as Str
01:07:08 <augustss_> dancor: If you make a Stringty type class, you also need to rewrite all packages that use ByteString into using that type class.
01:07:17 <augustss_> Otherwise the problem persists.
01:07:21 <mmorrow> that'd be nice too if you could also use pattern matching on bytestrings like they were strings
01:07:21 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
01:07:29 <augustss_> mmorrow: you can
01:07:32 <mmorrow> overload the syntax as well
01:07:33 <mmorrow> :o
01:07:46 <augustss_> {-# LANGUAGE OverloadedStrings #-}
01:07:56 <augustss_> I fixed that years ago
01:07:58 <mmorrow> ah, but you can't overload pattern match
01:08:04 <augustss_> yes you can
01:08:07 <blackdog> augustss_: you were around in the early days, right? what was the rationale for punting so thoroughly on the issue of strings?
01:08:08 <mmorrow> omg
01:08:55 <augustss_> blackdog: Using String=[Char] saved a lot of work.
01:09:25 <blackdog> augustss_: sure, but why not wrap it in a typeclass then? no extra work, you don't have to do anything clever...
01:10:27 <augustss_> blackdog: as I remember, that idea never even came up.  it would have required putting many list functions in a class.  I don't think we were that bold and imaginative.
01:12:26 <mmorrow> augustss_: ohh, right i see what you mean. i mean doing something like: "foo ('a':s) = ('a',s)" ===> foo s | (not . null) s = case unsafeHead s of 'a' -> ('s',unsafeTail s); _ -> .."
01:12:59 <mmorrow> being able to pretend that the bytestring's a [Char], and pattern match like it was
01:13:08 * mmorrow thinks that would be neat
01:14:45 <mmorrow> foo (_:'q':_:_:'r':s) = ...
01:14:48 <mmorrow> or whatever
01:15:53 <ToRA> mmorrow: you could always use ViewPatterns and do foo (bsToString -> (_:'q':_:s))
01:16:03 <augustss_> mmorrow: Oh, ok.  No, you can only do 'foo "bar" = 5' etc
01:16:17 <augustss_> ARGH!
01:16:44 <augustss_> Adding insult to injury, the strict and lazy byte strings don't even have the same API.
01:16:49 <mmorrow> heh
01:18:01 <JaffaCake1> code.haskell.org down?
01:18:48 <ToRA> JaffaCake: down for me
01:18:54 <solrize> hey jaffacake
01:19:03 <solrize> i was wondering something and someone suggested i ask you
01:19:20 <solrize> suppose i have some long running evaluation like sum [1..100000000]
01:19:44 <solrize> which has been optimized/fused into a loop with no list allocation
01:19:52 <solrize> can ghc still switch between io threads?
01:20:07 <augustss_> ouch, a sore spot :)
01:20:14 <opqdonut> solrize: afaik not
01:20:17 <solrize> oh, heh :)
01:20:18 <JaffaCake> solrize: if you have a spare CPU, yes :)
01:20:39 <opqdonut> there was some proof-of-concept fiddling here a while ago with non-allocating diverging computations
01:20:44 <solrize> hmm, thanks
01:21:02 <solrize> for some reason i had thought there was a periodic SIGIO that kicked the thread switcher
01:21:12 <augustss_> It's a tedious to get to do the right thing
01:21:51 <JaffaCake> augustss_: right, I don't know of a good way to do it
01:21:56 <augustss_> You need compiler support that inserts a heap check in each non-allocating control flow loop
01:22:19 <augustss_> Which is also somewhat expensive
01:22:22 <JaffaCake> split the loop into nested loops, do a heap check every N iterations?
01:22:25 <solrize> not a timer interrupt?  that's the obvious thing
01:22:44 <augustss_> solrize: you only want to interrupt at safe spots
01:22:45 <JaffaCake> solrize: we can only context switch at a safe point
01:22:51 <solrize> hmm ok
01:23:11 <blackdog> solrize: does anyone not have millions of cores now?
01:23:12 <JaffaCake> not having safe points make GC much more complicated/expensive
01:23:26 <augustss_> you could make a safe point in each non-allocating loop.  and at timer interrupt you start single stepping until you reach a safe point
01:23:37 <augustss_> but that's also hard
01:23:49 <solrize> ok, have the timer tick set a breakpoint at the next safe point and then continue to there
01:24:00 <solrize> oh i see, same idea
01:24:28 <augustss_> there are solutions, but none of them are appealing
01:24:35 <solrize> what makes a safe point safe?
01:24:50 <JaffaCake> solrize: all the live data is reachable by the GC
01:25:11 <solrize> hmm
01:25:51 <solrize> that means, like, at a given unsafe point, there might be a few registers loose but not much more than that?
01:26:27 <mmorrow> solrize: in between safe points you can (possibly) have heap nodes with garbage/NULL in a ptr slot waiting for a value and stuff like that
01:26:28 <augustss_> solrize: it could be more complicated than that
01:26:30 <JaffaCake> solrize: the loop could be manipulating mutable data
01:26:40 <ksf> is there a parser framework that supports using maps to choose between alternatives?
01:27:38 <augustss_> solrize: e.g., on many RISC machine you can't load a register with an immediate value atomically, so you might have half a pointer in a register when you're interrupted
01:27:51 <JaffaCake> live data could be in registers or spilled to the stack
01:28:02 <JaffaCake> oh yes, and the half-a-pointer problem
01:29:27 <solrize> i see.  but interrupt handlers in os's of yore used to inspect the code in the user context to see what it was doing, e.g. to be able to restart partly-finished instructions
01:30:09 <solrize> maybe the compiler could make enough stuff to back out of the unsafe operations
01:30:45 <augustss_> solrize: you can
01:31:32 <augustss_> solrize: well, you don't back out, you go forward, I think
01:32:54 <solrize> yeah i guess you'd have to cramp the code gen pretty bad to make sure it was possible to go back
01:34:35 <augustss_> if the register contents (I mean pointer vs. non-pointer) at each location is not control flow sensitive there is a correct action to take for each location where you can be interrupted.
01:36:23 <solrize> yeah, sounds messy
01:38:28 <ski> (PCLSRing ?)
01:38:34 <solrize> ski :)
01:39:05 <solrize> http://en.wikipedia.org/wiki/PCLSRing
01:39:58 <ski> @type map . cograph
01:40:00 <lambdabot> forall b a. (a -> b) -> [Either a b] -> [b]
01:40:04 <ski> @type \f -> ((cograph f . fmap return) =<<)
01:40:05 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> m a1) -> m (Either a a1) -> m a1
01:40:06 <ski> @type \f -> ((cograph f . fmap return) =<<) . liftM mirror . runErrorT
01:40:07 <lambdabot> forall a b (m :: * -> *). (Monad m) => (b -> m a) -> ErrorT a m b -> m a
01:40:23 <Gracenotes> @type cograph
01:40:25 <lambdabot> forall (ar :: * -> * -> *) a b. (ArrowChoice ar) => ar a b -> ar (Either a b) b
01:40:46 <ski>   cograph :: (a -> b) -> (Either a b -> b)  -- for `Arrow (->)'
01:41:22 <ski> maybe one could call the first one `catEither'
01:41:30 <ski> @type catMaybes
01:41:31 <lambdabot> forall a. [Maybe a] -> [a]
01:41:39 <ski> (s/catEither/catEithers/)
01:41:52 <Gracenotes> = \f -> either f id
01:42:04 <solrize> turning a big loop into nested loops probably burns a register
01:42:04 <Gracenotes> ne?
01:42:11 <ski>   \f -> f ||| arr id  -- yes
01:42:28 <Gracenotes> nice.
01:42:33 <ski> @type graph
01:42:34 <bastl> hi where can i find reference docs for gtk2hs? hoogle has nothing it seems.
01:42:34 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
01:43:13 <Gracenotes> = \f -> f &&& arr id, I'm guessing
01:43:27 <solrize> reboot, bbl
01:44:33 <Saizan> bastl: http://www.haskell.org/gtk2hs/documentation/ù
01:44:34 <quicksilver> bastl: http://www.haskell.org/gtk2hs/documentation/
01:44:51 <ski> Gracenotes : `\f -> arr id &&& f'
01:45:00 <Gracenotes> D:
01:45:19 <Gracenotes> hm. otherwise (a, b) would be (b, a) then
01:45:20 <bastl> ah, thanks
01:45:32 <Gracenotes> ..not like that's a huge difference
01:46:21 <mmorrow> grr, hpaste.org is working again now
01:46:23 <Gracenotes> provably equivalent etc... hm
01:47:00 <ski> *nod*
01:48:17 <jekor> I'm getting the error "Missing header file: openssl/md5.h" while trying to: cabal install nano-md5, but /usr/include/openssl/md5.h exists. Do I need to give some help to cabal? Is there a way to log how it's checking for the file?
01:48:26 <mmorrow> (in case anyone is hacking around with takusen+sqlite, i think there's some sqlite-specific thing it needs to be doing in the case that the db is locked (and the query fails with that msg) (iirc the sqlite docs say what to do))
01:49:29 <mmorrow> either way, it has a bug in some part of its sqlite driver where it can get into a borked state wrt the db file
01:50:49 <ski> @type \f -> ((cograph f . fmap return) =<<) . runErrorT
01:50:51 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> m a1) -> ErrorT a m a1 -> m a1
01:51:00 <ski> better
01:51:13 <Saizan> jekor: try with --extra-include-dirs=/usr/include/openssl/
01:51:48 <jekor> same error
01:53:08 <Saizan> mh, maybe it's something more subtle, with -v3 it should give you the full details
01:53:42 <jekor> That's the switch I was looking for.
01:53:58 <jekor> Apparently the header file has errors or gcc doesn't like it.
01:54:40 <Saizan> or maybe you need other headers to make it work
01:54:50 <jekor> Maybe.
02:06:47 <jekor> I upgraded to a new minor/patch-level? release and it went away.
02:08:25 <Saizan> of openssl?
02:10:19 * ksf just decided on the One Truely Right Way To Manage Errors: Writer [String] (Maybe a)
02:11:52 <ksf> ...or, actually, a transformed Maybe Monad.
02:14:11 <Daimonic> hey
02:14:48 <Daimonic> the (.)-Operator is only applied to one argument, I want to use it on two arguments, sth. like (.).(.) but this didnt worked out yet  for me
02:14:54 <Daimonic> > (pred . succ) 5
02:14:56 <lambdabot>   5
02:15:14 <ksf> :t (.)
02:15:15 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:15:30 <ksf> if you apply it to one argument, you've still got to feed it two others.
02:15:42 <ksf> but I see what you mean.
02:15:56 <Daimonic> yeah
02:16:13 <Daimonic> :t (.).(.)
02:16:15 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
02:16:54 <paolino> :t (.) >>> (.)
02:16:55 <Daimonic> ( (+) (.).(.) (-) ) 5 3
02:16:56 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
02:17:00 <Deewiant> > ((.).(.)) (+1) (*) 4 6
02:17:02 <lambdabot>   25
02:17:02 <Daimonic> > ( (+) (.).(.) (-) ) 5 3
02:17:04 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> a -> b)
02:17:04 <lambdabot>    arising fro...
02:17:19 <Deewiant> @let (.:) = (.).(.)
02:17:21 <lambdabot>  Defined.
02:17:34 <Deewiant> > ((+1) .: (*)) 4 6
02:17:36 <lambdabot>   25
02:18:29 <Daimonic> oh I missunderstood the signature of (.).(.)
02:18:53 <Daimonic> I thought it can handle two, two-argument functionsm but is only 1 two-argument function and 1 one-argument funtion
02:19:07 <Deewiant> > ((+1) . (*) 4) 6
02:19:09 <lambdabot>   25
02:19:40 <yottis> that would make hard to chain them
02:22:00 <ksf> pointless style is overrated, anyway.
02:22:13 <ksf> > ((+1) .) (*2) 3
02:22:15 <lambdabot>   7
02:22:27 <ksf> that's kind of the utmost extend to which I use it.
02:23:56 <Deewiant> > ((*) =<< (+1)) 4
02:23:58 <lambdabot>   20
02:24:54 <Daimonic> > interact $ lines . (\xs -> show $ reverse xs == xs) . unlines
02:24:56 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
02:25:19 <Daimonic> > interact $ lines . map (\xs -> show $ reverse xs == xs) . unlines
02:25:20 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
02:25:53 <Deewiant> ?ty \f -> lines . f . unlines
02:25:55 <lambdabot> (String -> String) -> [String] -> [String]
02:25:56 <Deewiant> ?ty interact
02:25:57 <lambdabot> (String -> String) -> IO ()
02:26:21 <Deewiant> ?ty \f -> unlines . map f . lines
02:26:22 <lambdabot> (String -> String) -> String -> String
02:26:32 <Daimonic> > interact $ unlines . map (\xs -> show $ reverse xs == xs) . lines
02:26:34 <lambdabot>   <IO ()>
02:26:38 <Daimonic> ^^
02:27:21 <Daimonic> :t wait
02:27:22 <lambdabot> Not in scope: `wait'
02:27:25 <tibbe> "Everything else in this tutorial will be based on bytestrings. Normal Haskell String types are linked lists of 32-bit characters. This has a number of useful properties like coverage of the Unicode space and laziness, however when it comes to dealing with bytewise data, String involves a space-inflation of about 24x and a large reduction in speed. "
02:27:46 <tibbe> why is the difference between Unicode and its encodings so difficult to grasp?
02:28:39 <tibbe> programmers perfectly understand the difference between the string "5" and the internal memory representation of the integer 5 but when it comes to unicode and encodings something goes wrong
02:28:41 <tibbe> I blame C
02:29:24 <quicksilver> tibbe: In general I agree but what about the pasted sentences do you take issue with?
02:29:49 <Daimonic> > (.).(.) succ (*) 5 20
02:29:50 <MyCatVerbs> tibbe: Hrmn? String is [Char] and Char is UCS-4. The reason for 24x overhead (rather than 4x overhead) is that Haskell makes the list spine and so on really heavy.
02:29:51 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> (a1 -> b) -> a1 -> c)
02:29:51 <lambdabot>    aris...
02:30:06 <quicksilver> MyCatVerbs: char is not UCS-4
02:30:17 <Deewiant> tibbe: Windows calls UTF-16LE "Unicode" :-)
02:30:36 <MyCatVerbs> quicksilver: each Char represents on code point. What trivial distinction am I missing now?
02:30:48 <sioraiocht> MyCatVerbs: Char uses a unicode code point represented as a 32-bit int
02:30:57 <ksf> char is something that can transport unicode chars you read and write from/to handles.
02:31:00 <quicksilver> MyCatVerbs: Char is abastract.
02:31:06 <Deewiant> sioraiocht: Which is exactly UCS-4?
02:31:07 <Daimonic> > ((.).(.)) succ (*) 3 4
02:31:09 <lambdabot>   13
02:31:11 <sioraiocht> UTF-32 is a bit stream where each 32-bits represents a single unicode code point
02:31:12 <quicksilver> MyCatVerbs: it *might* be faithfully represented as ucs-4.
02:31:22 <Daimonic> > succ (.).(.) (*) 3 4
02:31:24 <lambdabot>   Add a type signature
02:31:30 <Daimonic> > (succ (.).(.) (*)) 3 4
02:31:32 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b1 -> b1)
02:31:32 <lambdabot>    arising from a u...
02:31:51 <sioraiocht> Deewiant: quicksilver's point is that char is an abstraction that represents all unicode code points, but isn't an unicode encoding scheme
02:32:01 <tibbe> MyCatVerbs: well no, [Char] is not UCS-4. It happens to be encoded as such internally but that distinct from the semantic type [Char] i.e. you could pick another encoding
02:32:18 <centrinia> :t succ (.).(.) (*)
02:32:19 <lambdabot> forall b a b1. (Enum ((b -> b1 -> b1) -> (a -> b) -> a -> b1 -> b1), Num b1) => (b -> b1) -> (a -> b) -> a -> b1 -> b1
02:33:03 <tibbe> quicksilver: I think my problem is " however when it comes to dealing with bytewise data" -- bytewise data makes no more sense in relation to Strings that in relation to some other abstract data type like sets
02:33:14 <centrinia> Daimonic: You might want to implement ((b -> b1 -> b1) -> (a -> b) -> a -> b1 -> b1) as an instance of Enum. :p
02:33:17 <tibbe> MyCatVerbs: he's of course correct when it comes to the overhead
02:33:21 <Deewiant> Okay, fine; an abstraction it is, but the bijection between it and UCS-4 is still "id" :-P
02:33:32 <ksf> well, you can represent bytewise data as [Integer], too.
02:33:46 <ManateeLazyCat> When i do command "cabal upload Plural.tar.gz", i got "ERROR: Plural.tar.gz: 400 Error in upload" ?
02:33:50 <sioraiocht> Deewiant: well, no, it's an inclusion function
02:34:03 <quicksilver> tibbe: sure, it's a bit of a non-sequitur.
02:34:09 <ksf> [Word8] would make sense, but [Char] is just space overkill.
02:34:13 <tibbe> you can only talk about binary data and strings together if you mention an encoding
02:34:30 <ksf> ...not to mention the wrong overflow semantics.
02:34:31 <quicksilver> tibbe: he probably means US-ASCII :)
02:34:51 <sioraiocht> ugh
02:35:05 <sioraiocht> People still using ascii for anything should be stabbed
02:35:14 <ksf> we should just typedef char byte and replace every single byte-interpreted char * with byte *
02:35:19 <MyCatVerbs> ksf: [Word8] has the same space overhead as [Char] or [Int] with the way GHC currently lays out structures.
02:35:21 <tibbe> here's my battle cry: ByteString is not a faster String
02:35:28 <tibbe> Text is a faster String
02:35:44 <MyCatVerbs> tibbe: I'll drink to that.
02:35:47 <quicksilver> agree.
02:35:49 <sioraiocht> tibbe: yes, it is =p
02:35:50 <Deewiant> ByteString is a faster [Word8]
02:35:53 <ksf> there's both a Char and a Word8-bytestring.
02:36:01 <Deewiant> The Char bytestring should be shot
02:36:03 <quicksilver> ksf: but the Char-bytestring lies.
02:36:15 <tibbe> Deewiant: exactly
02:36:19 <quicksilver> ksf: it is an ASCII-only-Char-bytestring
02:36:25 <sioraiocht> the main problem with String is not Char, but []
02:36:26 <quicksilver> which is considerably less useful than a Char bytestring.
02:36:26 <Deewiant> Well, 8-bit-only
02:36:39 <quicksilver> (or, to be slightly more charitable, 8859-10 or whatever)
02:36:42 <Deewiant> sioraiocht: Which is also its main attraction, at least IMO :-)
02:36:53 <MyCatVerbs> Eh. You can still do useful work with Char8 bytestring.
02:37:00 <sioraiocht> Deewiant: oh, agreed, else it wouldn't persist so well as a built in type
02:37:07 <tibbe> the Char ByteString is an unsafe cast
02:37:42 <tibbe> MyCatVerbs: the main use is to implement ASCII network protocols
02:37:47 <MyCatVerbs> It's 8-bit-clean, so provided that your delimiters are always in the ASCII range you can still split up UTF8 fields with [Word8]. :)
02:38:02 <tibbe> MyCatVerbs: but I spend most of my time implementing HTTP and found very little use for it
02:38:28 <ksf> well... if you use UTF8, indexing becomes nontrivial, and if you use UTF16, space explodes.
02:38:40 <sioraiocht> ksf: why?
02:38:51 <tibbe> ksf: actually you can't index into UTF16 either
02:39:02 <MyCatVerbs> ksf: Honestly, don't index. And indexing is nontrivial in UTF16 too if you want to handle surrogate pairs correctly.
02:39:16 <tibbe> ksf: in O(1) I mean
02:39:26 <Deewiant> Who wants to index anyway
02:39:30 * tibbe is happy to see bos work on Data.Text
02:39:44 <ksf> well, my point is that we'd need some custom internal encoding to make unicode-bytestrings useful.
02:39:56 <tibbe> Deewiant: Indeed you don't need to very often. A few string search algorithms do need indexing I believe
02:40:02 <sioraiocht> indexing UTF-* is usually a pointless way to handle unicode streams
02:40:04 <ksf> like chunking into 16- and 8-bit parts.
02:41:04 <quicksilver> ksf: "useful" is a strong claim
02:41:13 <ksf> ...fast and small.
02:41:27 <quicksilver> ksf: there are literally millions of computer programs which find it "useful" to do work over UTF8 or UTF16 encoded strings
02:41:33 <Deewiant> String is useful
02:41:35 <quicksilver> so it's obviously not only possible but quite common.
02:41:43 <quicksilver> that doesn't mean there aren't challenges, sure.
02:42:10 <sioraiocht> ksf: what do you want a proprietary encoding to provide?
02:42:12 <tibbe> Deewiant: sure, the problem lies more in the I/O layer
02:42:28 <Deewiant> Which, thankfully, has been fixed for GHC 6.12
02:42:39 <tibbe> Deewiant: for example, Network.Socket returns Strings which makes no sense
02:42:51 <Deewiant> Quite
02:43:04 <Deewiant> A lot of stuff works on Char when it should work on Word8
02:43:12 <sioraiocht> Deewiant: such as
02:43:27 <Deewiant> Such as Network.Socket, as just mentioned? :-P
02:43:33 <ksf> sioraiocht, nothing in peculiar, just preparing information so that stuff that is O(1) in byte arrays isn't suddenly O(n) in bytestrings.
02:43:36 <tibbe> For example, if someone sends you UTF-8 encoded strings over the network you receive them as String but then have to call something like decodeUtf8 :: String -> String !
02:43:44 <Deewiant> I/O in the Prelude as currently (GHC <= 6.10) implemented, as well
02:43:46 <sioraiocht> ksf: that requires fixed width encoding
02:43:52 <Deewiant> (And System.IO)
02:44:02 <sioraiocht> ksf: you should not be treating a unicode stream as an array
02:44:16 <ksf> well, but I might want to index into it.
02:44:24 <sioraiocht> why?
02:44:40 <ksf> or split off 20 points from the beginning.
02:44:41 <sioraiocht> why do you need to take the nth character, directly
02:44:54 <sioraiocht> ksf: drop is O(1) in both bytestring and text
02:45:00 <tibbe> I think while most text processing can be done using a stream model there are algorithms that do require indexing
02:45:18 <tibbe> ksf: can't be O(1) in text!
02:45:24 <tibbe> ksf: as it uses utf-16
02:45:36 <tibbe> ksf: sorry that was for sioraiocht
02:45:52 <sioraiocht> tibbe|meeting: It can be in certain instances now
02:45:57 <ksf> kmp search comes to mind.
02:45:59 <sioraiocht> and tibbe, I wrote Text
02:46:19 <sioraiocht> tibbe|meeting: ^
02:47:25 <sioraiocht> and even so, drop m is O(min{m,n}) in Text at worst
02:48:01 <sioraiocht> ksf: if you want a fixed width unicode array, nothing is more efficient than UTF-32, anyway
02:48:25 <sioraiocht> ksf: unless you make a representation that uses exactly 21 bits for each code point, but that's pointless nayway
02:48:29 <ksf> sioraiocht, one doesn't need a fixed width over the whole text, but just inside chunks: you can splice out the 16-byte characters and make the indexing complexity O(log(number-of-width-changes))
02:49:50 <ksf> ...or without the log, if you want to have fast drops.
02:50:07 <sioraiocht> ksf: an approach like that doesn't require a change in encoding, necessarily
02:50:24 <ManateeLazyCat> I got "could not extract Plural-0.0.1/Plural.cabal from Plural-0.0.1.tar.gz" error. I use "runhaskell Setup sdist" package it, I miss something?
02:50:36 <ksf> well, then say "representation"
02:50:40 <ksf> ...which is what I meant.
02:50:44 <sioraiocht> ksf: oh okay
02:50:55 <sioraiocht> sorry, I misunderstood you, I wasn't trying to be pedantic =)
02:51:07 <sioraiocht> ksf: I'm working on something that will give some of that, actually
02:52:11 <ManateeLazyCat> can't upload package with GPL3?
02:52:11 <ksf> right now, the only unicode-related problem I'll be having is constructing a proper [Char] out of a Word8 bytestring, spliced out at some offset with known length.
02:52:40 <ksf> so far, I didn't encounter any data that uses more than 7bit ascii, so I don't really care.
02:52:42 <sioraiocht> why are you using bytestring for unicode streams?
02:53:07 <ksf> because I don't want to handle gigabytes of .mkv-data as [char]
02:53:16 <sioraiocht> ksf: use Data.Text
02:54:17 <ksf> yeah, that seems to do the trick, thanks.
02:54:28 <eflister> i need help using ReaderT w/recursion -- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7873
02:55:05 <ksf> ...and yet another interface that looks exacty like []
02:55:22 <ksf> things are really getting out of control, we need typeclasses for collections.
02:56:10 <ksf> (and elemIndex should use Integer, btw)
02:56:12 <joel___> how do i change the Compare function in priority_queue to less tha
02:56:13 <joel___> ?
02:56:17 <joel___> *less than
02:56:18 <sioraiocht> ksf: no it shouldn't
02:56:35 <sioraiocht> ksf: that's what "generic" functions are for
02:57:01 <sioraiocht> ksf: otherwise optimising most uses of elemIndex is not possible
02:57:04 <sioraiocht> Int's can be unboxed
02:57:11 <sioraiocht> Integer's can't
02:57:53 <ksf> well, ok, then there should be elemIndex' which uses Integer.
02:58:04 <ksf> or, actually, Num a.
02:58:17 <sioraiocht> ksf: umm, no?
02:58:22 <sioraiocht> ksf: It should be Integral
02:58:28 <sioraiocht> you can't have a Fractional index
02:58:41 <sioraiocht> also, if you want something, talk to bos
02:58:59 <ksf> ...I would have caught that error as soon as ghc would have asked me to implement (/)...
02:59:53 <ksf> there's already been some discussion relating to Data.Map and lookalikes, but somehow nothing came out of it.
03:00:13 <hackagebot> Plural 0.0.1 - Pluralize English words (AndyStewart)
03:02:29 <ksf> another thing that I noticed with maps is that not only mapping over them is useful, but also having them support  bijections that to convert from/to their respective key type.
03:02:47 <ksf> the most trivial example being an Int or ByteString newtype.
03:02:53 <ManateeLazyCat> Why cabal show i haven't install Plural after i do command "cabal install Plural" ?
03:03:04 <ksf> cabal update?
03:03:11 <ManateeLazyCat> ksf: Yep.
03:03:36 <lilac> eflister: nesting a 'do' block directly inside another 'do' block is pointless
03:03:39 <ManateeLazyCat> ksf: I do wrong thing with cabal setup?
03:03:53 <ksf> I've no idea what you did.
03:03:59 <lilac> eflister: the problem is you're applying liftIO to a 'if' whose 'else' returns ReaderT Context IO (), not IO ()
03:04:12 <Saizan> ManateeLazyCat: what do you mean byt "cabal shows i haven't installed Plural"?
03:04:55 <ManateeLazyCat> Saizan: After "cabal install Plural", i do "cabal list Plural", it show [ Not installed ]
03:05:10 <ksf> is it just an exectutable, perhaps?
03:05:15 <lilac> eflister: this might work a bit better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7873#a7875
03:05:35 <ManateeLazyCat> ksf: No, it not execututable, it just library.
03:05:56 * ManateeLazyCat pasted "Plural.hs" at http://paste2.org/get/359717
03:05:57 <ManateeLazyCat> ksf: Above.
03:06:26 <ManateeLazyCat> I think must be something wrong with my cabal file.
03:06:37 <Saizan> ManateeLazyCat: from http://hackage.haskell.org/packages/archive/Plural/0.0.1/Plural.cabal it's an executable
03:06:47 <Saizan> ManateeLazyCat: and cabal doesn't keep track of executables
03:06:51 <ksf> sox -> soxen is missing.
03:07:18 <eflister> lilac: hm, ok, i thought i had to have separate do's for each monad i was in -- and my messing around suggested i needed the 2nd do.  but i'll try without.  but yeah, how do i get the recursive call to type correctly?  yours seems to have the same trouble...
03:07:22 <ManateeLazyCat> Saizan: But when i in ghci, i can't load Language.English.Plural
03:07:24 <ksf> ...and I can't try because containers-0.2.0.1 fails to compile.
03:08:09 <Saizan> ManateeLazyCat: the package Plural that's on hackage doesn't export any module, it only contains an executable
03:09:42 <ManateeLazyCat> Saizan: I forget change Plural.hs source code.
03:09:56 <eflister> lilac: yours works all except for the recursive line
03:09:58 <ManateeLazyCat> Should be Language.English.Plural not Manatee.Data.Plural.
03:10:24 <Saizan> ManateeLazyCat: you've also to change the .cabal file
03:10:41 <Saizan> ManateeLazyCat: it must contain a library section where you expose that module
03:10:56 <ManateeLazyCat> Saizan: Add Language.English.Plural under "other-modules"?
03:11:11 <Saizan> ManateeLazyCat: exposed-modules
03:12:28 <Saizan> ManateeLazyCat: e.g. like here http://hackage.haskell.org/packages/archive/vector/0.2/vector.cabal
03:15:44 <eflister> lilac: oh, ha ha, just missing $.  i added it -- now it compiles, but hangs after the first print of "hi"
03:18:00 <eflister> lilac: oh damn, that's just the MVar blocking.  my bad.  thanks for your help!
03:19:46 <eflister> lilac: i can't find a good explanation of liftIO anywhere, got any pointers?  i'd like to not have to sprinkle them all over the place...
03:20:17 <hackagebot> Plural 0.0.2 - Pluralize English words (AndyStewart)
03:20:20 <ManateeLazyCat> Saizan: Thanks, i success now.
03:24:43 <ManateeLazyCat> Saizan: I got "module `Language.English.Plural' is not loaded" when i ":m Language.English.Plural"
03:27:51 <m3ga> i'm having trouble reaching trac.haskell.org and planet.haskell.org. are these down atm?
03:30:23 <Saizan> ManateeLazyCat: restart ghci oustide of the source tree
03:30:57 <ManateeLazyCat> Saizan: Works, heh.
03:31:16 <ManateeLazyCat> Saizan: Thanks. :)
03:33:24 <ManateeLazyCat> Saizan: Why ghci can't load when i in source tree?
03:34:50 <Saizan> ManateeLazyCat: you've to use :load there, because ghci finds the source and wants to use that instead of the installed library
03:45:29 <ManateeLazyCat> I see, thanks.
04:06:35 <pipingcats> Hi guys. I want to learn haskell, but I'm not sure what book I should start out with
04:07:51 <vegai> pipingcats: http://learnyouahaskell.com/ & realworldhaskell
04:08:21 <pipingcats> Thanks vegai
04:08:52 <McManiaC> jup
04:09:15 <ski> pipingcats : also, feel free to ask questions here
04:09:19 <dschoepe> pipingcats: A gentle introduction to Haskell is also nice for the basics in my opinion
04:10:00 * ski suspects that might depend on the background
04:10:02 <pipingcats> cool, thanks
04:10:37 <pipingcats> Is there a definitive book about haskell? Kind of like K&R C, but for haskell :)
04:11:09 <pipingcats> Tutorials are good, but after I read those I like to read the big books
04:11:29 <MyCatVerbs> pipingcats: Only really the H98 standard and the Gentle Introduction, I suppose.
04:11:30 <bremner> realworld haskell might be such a thing, although it is not really like K&R at all
04:11:41 <MyCatVerbs> pipingcats: modern Haskell is a fair bit bigger than just Haskell98, though.
04:11:52 <bremner> if definitive is defined as "popular"
04:12:09 <bremner> which I guess makes C# definitive.
04:12:14 <pipingcats> Ah. Which should I learn first?
04:12:15 <pipingcats> Haha
04:12:44 <quicksilver> I'm pretty sure definitive is not defined as "popular".
04:12:51 <quicksilver> No, there is no definitive haskell book.
04:12:59 <quicksilver> If an annotated haskell report was published, that would be definitive.
04:13:01 <xter> learnyouahaskell.com caught me dirty handed: "Alright, let's get started! If you're the sort of horrible person who doesn't read introductions to things and you skipped it..."
04:13:04 <quicksilver> but it hasn't been AFAIK.
04:13:37 <quicksilver> pipingcats: LYAH is a bit more than a web tutorial, it's more like a (short) online book.
04:14:13 <pipingcats> Cool. I guess I'll finish reading it first before looking at other things, then
04:14:43 <ski> @type flip (scanM (flip ($)))
04:14:44 <lambdabot> forall a (m :: * -> *). (Monad m) => [a -> m a] -> a -> m [a]
04:14:46 <ski> name ?
04:17:06 * ski was thinking of `scanComposeM'
04:19:59 <quicksilver> :t scanl (>=>)
04:20:01 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m c) -> [c -> m c] -> [a -> m c]
04:20:03 <quicksilver> interesting.
04:20:12 <ski> @type scanM
04:20:14 <lambdabot> forall r a (m :: * -> *). (Monad m) => (r -> a -> m r) -> r -> [a] -> m [r]
04:20:26 <Deewiant> ?ty scanM (>=>)
04:20:28 <lambdabot> forall a b. (a -> a -> b) -> [b -> a -> a -> b] -> a -> [a -> a -> b]
04:20:34 <Deewiant> Sweet
04:21:02 <Deewiant> ?djinn (a -> a -> b) -> (b -> a -> a -> b) -> a -> (a -> a -> b)
04:21:02 <lambdabot> f a b c = b (a c c)
04:27:50 <Daimonic> @src ($)
04:27:50 <lambdabot> f $ x = f x
04:28:00 <Daimonic> :t ($)
04:28:02 <lambdabot> forall a b. (a -> b) -> a -> b
04:31:49 <Daimonic> @src (.)
04:31:50 <lambdabot> (f . g) x = f (g x)
04:59:52 <xian> Is there any way to make GHC dump interface and object files in a directory different from the one containing the source code?
05:02:30 <Saizan> xian: -odir -hidir
05:03:47 <xian> Saizan: Thanks. I must admit I was too lazy to read the man page.
05:17:18 <mxc> hi
05:18:53 <mxc> what would be the simplest way to, given a Type t in template haskell code, determine if that type is an instance of some class?
05:44:45 <uzytkownik> How to hide imported modules in ghci? 3 of them is enought to hide everything.
05:47:31 <aavogt> uzytkownik: as in set the prompt to something shorter?
05:47:42 <uzytkownik> aavogt: Exactly
05:48:01 <aavogt> that's  :set prompt whatyouwanttosee
05:48:20 <uzytkownik> aavogt: Thanks
05:48:36 <mmorrow> hrm, is the only (direct) way to convert (Float -> Double) really to use GHC.Prim.float2Double# and unboxing/reboxing the Float/Double?
05:48:55 <mmorrow> (as far as i can see it is (?))
05:48:58 <mauke> realToFrac?
05:49:08 <mmorrow> direct though
05:49:13 <mmorrow> oh
05:49:17 <mmorrow> @type realToFrac
05:49:19 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
05:49:24 <mmorrow> @type realToFrac :: Float -> Double
05:49:26 <lambdabot> Float -> Double
05:49:31 <mmorrow> mauke: beautiful :)
05:52:16 <mmorrow> mauke: argh. realToFrac appears to go via Rational (and there doesn't seem to be any RULES to prevent this)
05:53:00 <mmorrow> hmm, ok well this is actually what i'm trying to do
05:53:42 <mmorrow> err, actually forget it, because the only reason i'm trying to do what i am is because i coded myself into a corner and don't want to spend the time to get out
05:54:07 * mmorrow gets out
06:08:31 <lilac> > realToFrac (1.0000001 :: Float) :: Double
06:08:33 <lambdabot>   1.0000001192092896
06:08:37 <lilac> > realToFrac (1.0000001 :: Float) :: Float
06:08:39 <lambdabot>   1.0000001
06:08:45 <lilac> umm
06:08:48 <lilac> that's not good
06:09:04 <lilac> > realToFrac (realToFrac (1.0000001 :: Float) :: Double) :: Float
06:09:06 <lambdabot>   1.0000001
06:09:25 <lilac> > 1.0000001 :: Double
06:09:27 <lambdabot>   1.0000001
06:09:43 <lilac> ugh, "read . show" would be better than that...
06:11:24 <mmorrow> :o
06:14:28 <mmorrow> ooh, actually there are RULES that eliminate the Rational
06:14:55 <mmorrow> (so realToFrac does exactly what i was looking for)
06:15:03 <mmorrow> but i've already come to my senses..
06:15:50 <mmorrow> lilac: if that works in C, i'd call it a bug (that realToFrac doesn't)
06:16:55 <ksf> > 1.0000001192092896 :: Float
06:16:56 <lambdabot>   1.0000001
06:19:58 <mmorrow> oh
06:20:04 <harlekin> @pl (\(fn -> fn /= "." && fn /= ".."))
06:20:05 <lambdabot> (line 1, column 7):
06:20:05 <lambdabot> unexpected "-"
06:20:05 <lambdabot> expecting operator or ")"
06:20:16 <harlekin> @pl (\fn -> fn /= "." && fn /= "..")
06:20:16 <lambdabot> liftM2 (&&) ("." /=) (".." /=)
06:20:24 <mmorrow> > (realToFrac (1.0000001 :: Float) :: Double) == 1.0000001
06:20:26 <lambdabot>   False
06:20:33 * mmorrow checks C
06:21:09 <harlekin> :t filter (liftM2 (&&) ("." /=) (".." /=))
06:21:10 <lambdabot> [[Char]] -> [[Char]]
06:21:21 <harlekin> :t filter (liftM2 (&&) ("." /=) (".." /=)) (undefined::[FilePath])
06:21:22 <lambdabot> [[Char]]
06:21:47 <mmorrow> err, actually that was a bad test
06:21:48 <harlekin> > filter (liftM2 (&&) ("." /=) (".." /=)) ["/", ".."] :: [FilePath]
06:21:49 <lambdabot>   ["/"]
06:22:00 <copumpkin> FilePath === String
06:22:03 <mmorrow> > (realToFrac (realToFrac (1.0000001 :: Float) :: Double) :: Float) == 1.0000001
06:22:04 <copumpkin> currently, at least
06:22:05 <lambdabot>   True
06:22:10 <mmorrow> yay
06:22:21 <ski> @type filter (`notElem` [".",".."])
06:22:22 <lambdabot> [[Char]] -> [[Char]]
06:22:29 <harlekin> ski, thanks. That's in fact nicer.
06:22:36 <mmorrow> > (realToFrac (realToFrac (1.0000001 :: Double) :: Float) :: Double) == 1.0000001
06:22:38 <lambdabot>   False
06:22:53 <mmorrow> > realToFrac (realToFrac (1.0000001 :: Double) :: Float
06:22:54 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:22:56 <mauke> preflex: calc '2 1.0000001
06:22:57 <preflex>  1.0000000000000000000000011010110101111111001010011
06:22:59 <mmorrow> > realToFrac (realToFrac (1.0000001 :: Double) :: Float)
06:23:01 <lambdabot>   1.0000001192092896
06:23:11 <mauke> preflex: calc '2 1.0000001192092896
06:23:12 <preflex>  1.00000000000000000000001
06:23:20 <mmorrow> > (1^-42 :: CReal) == 0
06:23:22 <lambdabot>   Not in scope: `^-'
06:23:27 <mmorrow> > (1^(-42) :: CReal) == 0
06:23:29 <lambdabot>   * Exception: Negative exponent
06:23:33 <mmorrow> > (1**(-42) :: CReal) == 0
06:23:35 <lambdabot>   False
06:23:41 <mmorrow> > (10**(-42) :: CReal) == 0
06:23:43 <lambdabot>   True
06:23:51 <mmorrow> > (10**(-42) :: Double) == 0
06:23:53 <lambdabot>   False
06:23:58 <mmorrow> CReal fail
06:24:39 <mmorrow> mauke: what does "preflex: calc '2 1.0000001192092896" mean?
06:25:15 <mmorrow> (as in does that imply something about realToFrac?)
06:25:35 <mauke> it means: calculate 1.0000001192092896 and format the result in base 2
06:25:41 <mauke> and it's done with C doubles
06:25:46 <mmorrow> ah, ok
06:28:15 <MyCatVerbs> > sizeOf (unknown :: CReal)
06:28:16 <lambdabot>   Not in scope: `sizeOf'Not in scope: `unknown'
06:29:11 <quicksilver> there isn't a Storable instance for CReal anyway
06:29:17 <MyCatVerbs> :i CReal
06:29:50 <MyCatVerbs> Oh, I forgot. CReal isn't part of the FFI. Can't remember what it *is* though.
06:30:41 <quicksilver> Constructi{v,bl}e reals by roconnor
06:31:03 <quicksilver> arbitrary precision fractional arithmetic.
06:31:12 <MyCatVerbs> Oh durr. Hahaha.
06:31:14 <Philonous1> Why does "logToFile file chan = forkIO $ withFile file AppendMode $ \handle -> forever $ readChan chan >>= BS.hPut handle" give me "hClose: illegal operation (handle is finalized)" ?
06:32:07 <kpreid> What's a good data structure in the standard (well, GHC) library which is pure but 'array-like' (O(1) random access read and update)?
06:32:32 <MyCatVerbs> kpreid: IntMap.
06:32:34 <quicksilver> kpreid: not really sure what 'pure' is supposed to mean in that context.
06:32:45 <mauke> DiffArray?
06:32:57 <quicksilver> but, if you mean, the API doesn't involve a monad, then you can't do update in O(1) afaik.
06:33:14 <kpreid> I mean that it has Integer -> a -> Arr a -> Arr a, not -> m (Arr a)
06:33:20 <kpreid> well, log-n would be fine too.
06:33:31 <quicksilver> then IntMap or simply Map.
06:33:42 <quicksilver> also possible Sequence
06:34:06 <quicksilver> sequence gives you faster access when you're close to (either) end which is a slightly unusual but occasionally useful thing.
06:34:20 <kpreid> DiffArray sounds like just what I want...
06:34:27 <quicksilver> it doesn't work though.
06:34:29 <quicksilver> don't use it.
06:34:30 <kpreid> ok.
06:34:38 <quicksilver> it's around 64 millions times slower than Data.Map.
06:34:41 <kpreid> heh.
06:35:04 <mauke> he didn't say fast, only O(1)
06:35:15 <quicksilver> true.
06:35:24 <quicksilver> but is DiffArray even really amortised O(1) ?
06:35:34 <kpreid> weeeellll...:-)
06:35:36 <quicksilver> perhaps the GC cost of using MArrays breaks that.
06:35:44 <kpreid> let's put it this way: 'which one would you like to publish as an example of haskell's goodness?'
06:36:04 <quicksilver> IntMap, Sequence, or Map
06:36:06 <kpreid> by that point and your descriptions IntMap wins
06:36:14 <quicksilver> depending which fits your usage pattern best.
06:36:31 <quicksilver> patricia trie, fingertree, or just plain tree :)
06:49:20 <djahandarie> How would I get Haskell to treat an Int as an array of Ints? i.e. 9009 -> [9,0,0,9] ?
06:49:50 <djahandarie> list*
06:50:11 <mauke> > map digitToInt . show $ 9009
06:50:14 <lambdabot>   [9,0,0,9]
06:50:28 <djahandarie> Ah, okay, thank you
06:51:41 <quicksilver> although there is somethign a little perverse about going via Char just because the Show instance is handy.
06:52:16 <djahandarie> Yeah, it converts to char in the middle of that?
06:52:18 <djahandarie> Feels wrong
06:52:19 <djahandarie> ;p;
06:52:21 <djahandarie> lol*
06:52:55 <djahandarie> Also feels like it could slow things down
06:53:54 <quicksilver> > unfoldr (\x -> let (a,b) = x `quotRem` 10 in Just (b,a)) 9009
06:53:56 <lambdabot>   [9,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
06:54:03 <badsheepy> premature optimisation :p
06:54:09 <quicksilver> is the beginning of a sketch of a way which doesn't use Char
06:54:56 <mux> > unfoldr (\x -> let (a,b) = x `quotRem` 10 in guard (b /= 0) >> Just (b,a)) 9009
06:54:58 <lambdabot>   [9]
06:55:01 <mux> d'oh.
06:55:06 <mux> > unfoldr (\x -> let (a,b) = x `quotRem` 10 in guard (a /= 0) >> Just (b,a)) 9009
06:55:08 <lambdabot>   [9,0,0]
06:55:17 <mux> damn. anyways, you get the point.
06:55:25 <djahandarie> Not really, I suck at this stuff.
06:55:26 <djahandarie> :P
06:55:52 <mux> ah. well it involves the maybe monad and guards
06:56:24 <mux> in the Maybe monad, if the condition of a guard isn't met, your monadic computation will return Nothing
06:56:29 <djahandarie> I know what the Maybe monad is, but it always just makes me feel uneasy and I try to avoid it
06:57:13 <djahandarie> Where is a case where you HAVE to use it?
06:57:44 <mux> you never _have_ to use it
06:57:59 <mux> that only monad that you are forced to use no matter what is the IO monad
06:58:24 <mauke> what about (->) e?
06:58:33 <mux> all the other monads are just here for convenience, you can always rewrite code with the specific version of >>= and return inlined
06:59:15 <mux> mauke: I guess if you consider that to be some magical internal monad that is being used when doing function application, then you are forced to use this one too :-)
06:59:57 <djahandarie> D:
07:00:05 <djahandarie> God, this stuff is confusing. -_-
07:00:19 <quicksilver> you don't use the maybe monad because you *have* to
07:00:26 <quicksilver> you use it because it's convenient
07:00:27 <mauke> well, it's not used for function application, but then you don't have to use the monadic structure of IO either
07:01:00 <quicksilver> "guard p >> return x" is a bit more composable than "if p then Just x else Nothing"
07:01:37 <ski> > unfoldr (\x -> let (a,b) = x `quotRem` 10 in guard (x /= 0) >> Just (b,a)) 1234
07:01:39 <lambdabot>   [4,3,2,1]
07:02:02 <mauke> > unfoldr (\x -> let (a,b) = x `quotRem` 10 in guard (x /= 0) >> Just (b,a)) 9009
07:02:03 <jfoutz> djahandarie: do it how you would do it in C. it's more important to get stuff working. as you get more comfortable with the syntax, and get sick of writing the same stuff over and over, and in more fancy haskell bits.
07:02:04 <lambdabot>   [9,0,0,9]
07:02:06 <mauke> > unfoldr (\x -> let (a,b) = x `quotRem` 10 in guard (x /= 0) >> Just (b,a)) 0
07:02:08 <lambdabot>   []
07:02:09 <mauke> fail
07:02:23 <quicksilver> well I think that's an edge case.
07:02:41 <quicksilver> I think it's fair to consider the empty string to represent 0, if you're formalising decimal notation.
07:02:56 <ski> aye
07:03:40 <djahandarie> jfoutz, not entirely sure how I'd do this at all though in Haskell
07:03:42 <quicksilver> being a mathematiciain I would definitely rather redefine the problem than fix an ugly edge case.
07:04:12 <ski> `0' should get mapped to the empty string
07:04:20 <ski> if you want something else, you know how to get it
07:04:35 <djahandarie> Could someone translate that thing into English?
07:05:09 <Botje> which one? :)
07:05:43 <quicksilver> djahandarie: unfoldr keeps calling a function over and over on a "seed" value
07:05:51 <quicksilver> it stops when the function returns Nothing.
07:05:57 <mauke> void f(unsigned n) { if (n / 10) f(n / 10); putchar(n % 10 + '0'); }
07:06:15 <quicksilver> Assuming the function returns Just(a,b) one component is the "answeR" and the other component is the "new seed"
07:06:27 <ski> > let toDigits 0 = []; toDigits n = r : toDigits q where (q,r) = n `quotRem` 10 in toDigits 1234
07:06:29 <lambdabot>   [4,3,2,1]
07:06:33 <ski> djahandarie : ^ better ?
07:06:49 <jfoutz> djahandarie: how about something more like this, digits 0 = []; digits n = (digits (n `div` 10)) : (rem n 10)
07:07:02 <djahandarie> Ahhh
07:07:12 <djahandarie> There is a light shining through the fog. :P
07:07:13 <kpreid> is there a way to have a bunch of forkIO'd threads (running loops) such that if I ^C the foreground activity in ghci the threads also notice and die?
07:07:22 <ski> (jfoutz : don't mix `div' and `rem' :)
07:08:19 <therp> can somebody give me an insight on that? Am I conceptually on the wrong path? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7880#a7880
07:08:22 <quicksilver> kpreid: yes. Write a handler which catches the ^C and kills the other threads.
07:09:23 <ski> therp : perhaps you want `getSession :: GhcMonad n => m a -> n a' ?
07:09:34 <quicksilver> well you don't have to catch it, of course. Just `finally` it.
07:11:06 <therp> ski: that works.. but I don't get why I need that. why do I need to apply m to a?
07:11:26 <quicksilver> kpreid: if you don't find that answer terribly satisfactory, why not add your voice to http://hackage.haskell.org/trac/ghc/ticket/1399
07:11:32 <therp> ah .. because it's a monad.. but hmm..
07:11:44 <kpreid> quicksilver: I'll just not bother for this demonstration purpose then
07:12:37 <ski> therp : bec^W .. yes
07:12:43 <lilac> mmorrow: i had a bad case of brain fail earlier. of course realToFrac is doing the right thing :)
07:12:53 <ski> `m' is not a concrete type, it has kind `* -> *'
07:13:29 <therp> ski: but where does this a and a' "come from".
07:14:36 <therp> names that are not references twice in a local scope are by intuition useless to me
07:15:12 <iago> increases readability
07:15:34 <ski> therp : if you want to be explicit
07:15:36 <ski>   getSession :: forall a. GhcMonad n => m a -> n a
07:15:57 <therp> ski: but that's different from a and a'
07:16:03 <ski> `a' comes from whoever invokes `getSession'
07:16:21 <ski> that just above is the same as i suggested earlier, only more explicit
07:16:50 <ski> (i had no  a'  in the type, only  a  )
07:17:07 <therp> ski: ah that's the end quote..
07:17:28 <therp> though it was a-prime
07:18:05 <ski> another way to think of where it comes from is that a natural transformation from `m' to `n' here is a (parametrically) polymorphic function `forall a. m a -> n a'
07:19:05 <copumpkin> does forall m n a. (Copointed n, Pointed m) => m a -> n a count?
07:19:19 <ski> count for what ?
07:19:24 <copumpkin> as a natural transformation?
07:19:40 <copumpkin> I wrote the obvious function for that but it felt kinda cheatish
07:19:41 <ski> natural transformation between plain functors ?
07:19:55 <ski> (which was what i had in mind)
07:20:17 <ski> (also, note that in my version, `m' and `n' were free variables)
07:20:29 <quicksilver> yes, it does count, because "a" is left parametric.
07:20:40 <quicksilver> that's where the naturality is.
07:20:44 <copumpkin> ah
07:20:55 <copumpkin> of course, there aren't very many interesting things that are both copointed and pointed?
07:21:05 <copumpkin> in fact, I can only think of one thing and it's utterly boring
07:21:16 <copumpkin> maybe not though?
07:21:41 <ski> why both ? (you had `m' and `n' which need not be the same)
07:21:48 <copumpkin> oh true
07:22:00 <copumpkin> yeah, I need to wake up :P
07:22:45 <copumpkin> I felt kinda fancy writing (Copointed n, Pointed m) => m :~> n
07:22:49 <copumpkin> but it wore off quickly
07:24:07 <copumpkin> :t maybeToList
07:24:09 <lambdabot> forall a. Maybe a -> [a]
07:24:16 <copumpkin> is that a NT?
07:25:02 <ski> yes, it must be
07:25:18 <copumpkin> is listToMaybe too? it's lossy
07:25:42 <copumpkin> or are the actual values not relevant
07:26:25 <ski> every polymorphic function in Haskell is parametrically polymorphic, thus natural transformation .. well, GADTs and type families might change things, i don't know
07:27:04 <quicksilver> ski: pretty sure GADTs change things, yes. They give you a restricted form of type-case.
07:27:28 <ski> i'm not sure whether they remove parametricity
07:27:52 <ski>   eta . fmap f = fmap f . eta  -- the natural transformation law
07:28:33 <copumpkin> ski: you mean the polymorphic functions that don't involve functors explicitly could be rewritten in terms of Identity so that they're more obviously NT?
07:29:04 <ski> not necessarily `Identity', but yes
07:29:15 <copumpkin> ah
07:29:39 <ski>   length :: [] a -> Const Int a  -- e.g.
07:30:59 <ski> `maybeToList' is even a monad morphism
07:33:17 <ski> .. but `listToMaybe' isn't
07:33:30 <ski> it's a `Pointed'-morphism, though
07:33:50 <copumpkin> hmm
07:34:41 <ski>   maybeToList . return  =  return
07:35:03 <ski>   maybeToList . join  =  join . fmap maybeToList . maybeToList
07:35:18 <ski>   listToMaybe . return  =  return
07:35:43 <ski>   listToMaybe . join =/= join . fmap listToMaybe . listToMaybe
07:35:50 <kbp> Please help me. I'm new. I use hugs on Ubuntu to do 2 si,[;ecalculations: product [221..224] = 2450745024; product [1..24] = 620448401733239439360000. How could Product [1..24] > Product [221..224] ?
07:36:23 <ski> > ((listToMaybe . join) &&& (join . fmap listToMaybe . listToMaybe)) [[],[()]]
07:36:24 <lilac> off-by-1 fixer says "simple calculations"
07:36:24 <lambdabot>   (Just (),Nothing)
07:36:39 <byorgey> kbp: very easily.
07:36:48 <byorgey> kbp: note that [221..224] only contains 4 numbers.
07:37:05 <lilac> kbp: did you mean product [201..224] ?
07:37:05 <kbp> byorgey: ok I get it, overflow
07:37:13 <byorgey> kbp: no, there's no overflow involved.
07:37:15 <lilac> kbp: no. no overflow, that's just the answer
07:37:35 <byorgey> > 221 * 222
07:37:37 <lambdabot>   49062
07:37:42 <byorgey> > 49062 * 223
07:37:44 <lambdabot>   10940826
07:37:52 <byorgey> > 10940826 * 224
07:37:52 <lilac> product [221..224] = 221 * 222 * 223 * 224. product [1..24] = 1 * 2 * 3 * 4 * 5 * 6 * ... * 23 * 24
07:37:54 <lambdabot>   2450745024
07:38:07 <Deewiant> > scanl1 (*) [221..224]
07:38:18 <Deewiant> > scanl1 (*) [1..24]
07:38:30 <ski> > scanl1 (*) [221..224]
07:38:31 <lambdabot>   [221,49062,10940826,2450745024]
07:38:34 <ski> > scanl1 (*) [1..24]
07:38:36 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
07:38:55 <ski> > 6227020800 > 2450745024
07:38:57 <lambdabot>   True
07:39:28 <byorgey> so  product [1..13] is even bigger than product [221..224]  =)
07:39:38 <lilac> > (product [1..6], product [7..9], product [10..12], product [13..15], product [16..24])
07:39:40 <lambdabot>   (720,504,1320,2730,474467051520)
07:39:44 <kbp> oh I get it. So basically nothing wrong and I just got tricked by those big numbers
07:39:52 <lilac> ^^ it's more than 474467051520 times bigger :)
07:39:54 <Deewiant> > length . takeWhile (< product [221..224]) $ scanl1 (*) [1..24]
07:39:55 <byorgey> kbp: right =)
07:39:55 <lambdabot>   12
07:40:09 <lilac> on the other hand...
07:40:20 <lilac> > product [201..224] -- obviously bigger than product [1..24]
07:40:23 <lambdabot>   70970690655201853737464195642961120071960510972559360000
07:40:35 <Deewiant> > product [1..224]
07:40:37 <lambdabot>   559715935375377604046045731013645931764994048925791597683771525493951492453...
07:40:57 <kbp> :S
07:41:01 <byorgey> > length . show . product $ [1..224]
07:41:03 <lambdabot>   431
07:41:31 <lilac> > iterate (length . show . product . enumFromTo 1) 10
07:41:33 <lambdabot>   [10,7,4,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:41:40 <byorgey> kbp: anyway, welcome =)
07:41:48 <byorgey> kbp: are you going through a particular book or tutorial?
07:41:53 <kbp> thank you very much :)
07:42:04 <HugoDaniel> hi
07:42:10 <HugoDaniel> i have some questions about ghc :/
07:42:12 <kbp> I'm reading the tutorial on the website
07:42:14 <HugoDaniel> does it use gcc ?
07:42:20 <HugoDaniel> where can i read more about its options ?
07:42:24 <mauke> HugoDaniel: it can use gcc
07:42:36 <mauke> http://haskell.org/ghc/docs/latest/html/users_guide/index.html
07:42:37 <HugoDaniel> mauke: so it comes with gcc bundled with it ?
07:42:38 <byorgey> kbp: which one is that?
07:42:42 <mauke> HugoDaniel: depends
07:42:52 <kbp> http://www.haskell.org/tutorial/goodies.html
07:43:13 <HugoDaniel> in windows how does it work ? what version of gcc ?
07:44:43 <byorgey> kbp: ah, the Gentle Introduction
07:45:00 <kbp> byorgey: and I just notice that the whole tutorial doesn't mention how to use comments inside a Haskell file (i.e. use the "--" thing)
07:45:00 <byorgey> kbp: well, feel free to ask more questions in here
07:45:12 <byorgey> hehe
07:45:26 <byorgey> kbp: note that the "Gentle" Introduction is not actually very gentle
07:45:34 <byorgey> so if you get confused or frustrated there is nothing wrong with you =)
07:46:09 <kbp> lol ^^
07:47:08 <byorgey> kbp: if you want some other tutorials for cross-reference I also recommend Learn You a Haskell and Real World Haskell:
07:47:11 <byorgey> @where lyah
07:47:12 <lambdabot> www.learnyouahaskell.com
07:47:15 <byorgey> @where rwh
07:47:15 <lambdabot> http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
07:47:31 <ski> kbp : `--'-comments end at end-of-line, `{-'-comments end at `-}' (and they nest)
07:47:45 <lilac> > iterate (genericLength . show . product . enumFromTo 1) 25 :: [Integer]
07:47:50 <lambdabot>   mueval-core: Prelude.read: no parse
07:47:50 <lambdabot>  mueval: ExitFailure 1
07:49:39 <kbp> byorgey: I've just bookmarked them. Thank you (the home page of lyah looks funny). ski: thank you! I didn't know how to make multiple line comments
07:50:35 <benmachine> > show . product . enumFromTo 1 $ 25
07:50:37 <lambdabot>   "15511210043330985984000000"
07:51:18 <benmachine> oic
07:51:26 <benmachine> length 26 :o
07:55:00 <byorgey> > length . show . product . enumFromTo 1 $ 25
07:55:02 <lambdabot>   26
07:55:05 <byorgey> > length . show . product . enumFromTo 1 $ 24
07:55:07 <lambdabot>   24
07:55:14 <byorgey> aha, a fixed point! =)
07:55:25 <byorgey> > length . show . product . enumFromTo 1 $ 23
07:55:27 <lambdabot>   23
08:04:30 <RayNbow> > mystery 1
08:04:32 <lambdabot>   1
08:04:33 <RayNbow> > mystery 2
08:04:36 <lambdabot>   2
08:04:36 <RayNbow> > mystery 145
08:04:38 <lambdabot>   145
08:04:39 <RayNbow> ^ byorgey
08:04:50 <RayNbow> can you figure out the definition of mystery? :)
08:05:05 * Beelsebob makes the claim that mystery has a 3/infinity chance of being id
08:05:09 <mauke> > mystery x
08:05:11 <lambdabot>   0
08:05:11 <Beelsebob> >.>
08:05:12 <copumpkin> > map mystery [1..]
08:05:14 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,2,2,3,7,25,121,721,5041,40321,362881,3,...
08:05:25 <mauke> :t mystery
08:05:27 <lambdabot> forall a. (Show a) => a -> Int
08:05:30 <burp> @src mystery
08:05:30 <lambdabot> Source not found. Just try something else.
08:05:38 <mauke> > mystery ()
08:05:40 <lambdabot>   0
08:05:43 <Beelsebob> > map mystery ['a'..]
08:05:43 <copumpkin> it's the factorial of the sum of digits?
08:05:44 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40323,362883...
08:05:51 <copumpkin> actually no
08:05:58 <mauke> > map mystery [1.0 ..]
08:06:00 <lambdabot>   [2,3,7,25,121,721,5041,40321,362881,3,3,4,8,26,122,722,5042,40322,362882,4,...
08:06:13 <Beelsebob> > mystery "your mum in bed"
08:06:15 <lambdabot>   0
08:06:24 <copumpkin> > mystery "111"
08:06:26 <lambdabot>   3
08:06:29 <copumpkin> > mystery "1111"
08:06:29 <ziman> > fix mystery
08:06:32 <lambdabot>   4
08:06:35 <lambdabot>   mueval-core: Prelude.read: no parse
08:06:35 <lambdabot>  mueval: ExitFailure 1
08:06:36 <RayNbow> copumpkin: well, factorial, digits and sum are the ingredients :p
08:06:49 <copumpkin> RayNbow: it sure looks like it :P
08:07:00 <Beelsebob> > mystery "1234"
08:07:02 <lambdabot>   33
08:07:04 * RayNbow used show to write a quick and dirty digits function
08:07:17 <RayNbow> I was too lazy to use quotRem :p
08:08:28 <burp> > mystery $ replicate 10 1
08:08:30 <lambdabot>   10
08:08:33 <burp> > mystery $ replicate 100 1
08:08:35 <lambdabot>   100
08:08:39 <burp> > mystery $ replicate 100 2
08:08:41 <lambdabot>   200
08:09:55 <ToRA> > mystery Nothing
08:09:56 * RayNbow can't remember the other integer for which mystery x = x
08:09:57 <lambdabot>   0
08:10:18 <Beelsebob> > mystery (Just Nothing)
08:10:20 <lambdabot>   0
08:10:22 <mauke> sum . map (factorial . digitToInt) . filter isDigit . show
08:10:34 <Beelsebob> > mystery (Just (Just (Just (Just Nothing)))
08:10:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:10:40 <Beelsebob> > mystery (Just (Just (Just (Just Nothing))))
08:10:42 <lambdabot>   0
08:10:47 <Beelsebob> > mystery (Just (Just (Just (Just 1))))
08:10:50 <lambdabot>   1
08:10:56 <copumpkin> I think mauke got it
08:10:56 <skorpan> :t mystery
08:10:59 <lambdabot> forall a. (Show a) => a -> Int
08:11:03 <skorpan> @src mystery
08:11:03 <lambdabot> Source not found. I feel much better now.
08:11:11 <RayNbow> mauke: that's right
08:11:21 <benmachine> > mystery 123
08:11:23 <lambdabot>   9
08:11:26 <burp> > mystery undefined
08:11:27 <skorpan> i'm sure there's some unsafePerformIO in the source
08:11:27 <lambdabot>   * Exception: Prelude.undefined
08:11:39 <RayNbow> digits = map digitToInt . filter isDigit . show ; fac = product . enumFromTo 1; mystery = sum . map fac . digits
08:11:42 <benmachine> lambdabot doesn't unsafePerformIO
08:11:48 <benmachine> or safePerformIO
08:11:58 <benmachine> @let safePerformIO = id
08:12:00 <lambdabot>  Defined.
08:12:25 <skorpan> scaredy cat lambdabot
08:12:33 <benmachine> > putStr ""
08:12:35 <lambdabot>   <IO ()>
08:13:23 <mauke> > safePerformIO putStr ""
08:13:25 <lambdabot>   Not in scope: `safePerformIO'
08:14:22 <burp> > mystery 1000
08:14:23 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
08:14:24 <lambdabot>    arising from a use of `L.mystery'...
08:14:35 <skorpan> what?
08:14:45 <skorpan> > mystery 100
08:14:47 <lambdabot>   Not in scope: `mystery'
08:14:50 <skorpan> ...
08:14:57 <mauke> it is a mystery
08:14:59 <burp> > mystery 100
08:15:01 <lambdabot>   1
08:15:09 <skorpan> i'm telling you, unsafePerformIO
08:16:58 <benmachine> unsafePerformMagic
08:16:59 <RayNbow> :t mystery
08:17:00 <lambdabot> Integer -> Integer
08:17:15 <benmachine> it changed :o
08:17:20 * RayNbow made it monomorphic :p
08:17:35 <copumpkin> zomg
08:17:39 <burp> I guess it's not just you changing it ;-)
08:17:41 <copumpkin> we should add it to the standard library
08:17:48 <benmachine> haha
08:17:53 <burp> *duck*
08:17:58 <RayNbow> :t comystery
08:18:00 <lambdabot> Not in scope: `comystery'
08:18:30 <jeffwheeler> Is there a timeline for GHC 6.12?
08:18:38 <jeffwheeler> I'm curious when it'll be released.
08:20:07 <jacobian_> I kind of wish that (a,b,c) and ((a,b),c)) were punned.
08:20:26 <jeffwheeler> Oh, it looks like "September-ish"
08:20:32 <jmcarthur_work> jeffwheeler, i think all major ghc versions come out each year around septemberish
08:21:17 <jmcarthur_work> i don't even know what is planned for ghc 6.12 yet, actually
08:21:22 * jmcarthur_work looks it up
08:21:25 <quicksilver> jacobian_: unfortunately they're not isomoprhic.
08:22:05 <jeffwheeler> jmcarthur_work: looks that way; thanks
08:22:51 <jacobian_> well, they aren't isomorphic by construction no?  For purposes of efficiency I'd guess.
08:23:55 <quicksilver> jacobian_: (_|_,c) and ((_|_,_|_),c) are observable different
08:24:04 <jacobian_> oh duh :) sorry
08:24:23 <quicksilver> but they (presumably) map to the same element in (a,b,c)
08:24:32 <quicksilver> well it is kinda annoying.
08:25:08 <ski> would if be bad if `_|_' and `(_|_,_|_)' was the same ?
08:25:23 <jacobian_> It would force you to be strict no?
08:25:39 <ski> not really
08:26:00 <ski> well, maybe in presence of `seq'
08:26:01 <mmorrow> data a:::b = !a ::: !b
08:26:43 <ski> the idea would be that matching on `(<p0>,<p1>)' would do nothing, unless `<p0>' or `<p1>' themselves needed to force
08:27:03 <quicksilver> make (,) always irrefutabel.
08:27:05 <jmcarthur_work> > let foo ~(x, y) = (x, y) in undefined
08:27:07 <lambdabot>   * Exception: Prelude.undefined
08:27:32 <jmcarthur_work> wait, no left paren?
08:27:51 <jmcarthur_work> oh
08:27:53 <jmcarthur_work> > let foo ~(x, y) = (x, y) in foo undefined
08:27:55 <lambdabot>   (* Exception: Prelude.undefined
08:28:49 <jmcarthur_work> ski, lazy pattern matching is your friend :)
08:29:10 <ski> jmcarthur_work : that's not quite the same (but one can translate into that, yes)
08:29:27 <jmcarthur_work> ski, what's different?
08:29:42 <jmcarthur_work> notation, is all i can think of
08:29:44 <ski> you can refrain from using lazy patterns on tuples
08:29:57 <jmcarthur_work> oh you want something that you can't refrain from?
08:30:16 <ski> i was considering a tuple type where matching would always be lazy, *wrt* the tuple construction .. *not* wrt possible sub-patterns
08:30:46 <jmcarthur_work> you can make a tuple newtype that has an associated view type
08:30:58 <jmcarthur_work> translation to the view would involve a lazy pattern match
08:31:47 <ski> so `f (x,y) = g x y' would translate to ordinary `f p = g x y where (x,y) = p' aka `f ~(x,y) = g x y', while `f (x,Nothing) = g x' would translate into `f (x,Nothing) = g x'
08:32:37 <lilac> newtype (a,b) = (a,b) ?
08:32:38 <lilac> :)
08:33:19 <ski> i can eludicate with different syntax for the two kinds of tuples, if you wish
08:33:34 * lilac ponders multi-argument newtype constructors
08:33:59 <ski> lilac : coinductive types are probably what you're after ..
08:34:27 <jmcarthur_work> newtype Pair a b = Pair (a, b); view (Pair ~(x, y)) = (x, y)
08:34:28 <lilac> apart from implementation problems with thunk sharing, i can't see a problem with multi-argument newtype constructors
08:35:01 <jmcarthur_work> f (view -> (x, y)) = g x y  -- with ViewPatterns
08:35:03 <ski> jmcarthur_work : that's not what i want
08:35:32 <ski> `f (x,Nothing) = g x' should still eagerly match on the `Nothing'
08:35:42 <jmcarthur_work> ski, if you don't export the implementation of Pair then the only way to match is with the view function, which means that all pattern matches must be lazy
08:35:54 <lilac> ski: f (view -> (x, Nothing)) should do that, no?
08:35:55 <jmcarthur_work> f (view -> (x, Nothing)) = g x
08:36:00 <jmcarthur_work> :)
08:36:08 <ski> hm
08:36:32 <ski> i stand corrected
08:36:34 <lilac> whereas f (view -> (x, y)) would not bottom out if the argument was _|_
08:36:35 <ski> you are right
08:36:49 <ski> nice :)
08:36:54 <jmcarthur_work> view patterns rock
08:37:03 <jmcarthur_work> i wish the extension was a bit more polished though
08:37:03 <ski> (except the syntax)
08:37:24 <mux> I've been wondering if GHC optimises the call to the function used in view patterns if you use the same one in every case
08:37:28 <lilac> i read somewhere about a more implicit form of view patterns
08:37:42 <lilac> mux: the docs say that it tries to but sometimes fails on seemingly obvious cases
08:37:43 <jmcarthur_work> mux, yeah that worries me a little
08:37:55 * ski doesn't necessarily want more implicit .. but wants something that doesn't clash as much with expression syntax
08:38:24 <lilac> ski: it was something like allowing adding more 'constructors' which were actually views
08:39:04 <mmorrow> , src ''FRef
08:39:06 <ski> that would be nice .. but is not quite the same
08:39:08 <lunabot>  newtype FRef a b = MkFRef {unFRef :: (a -> (b, b -> a))}
08:39:09 <mmorrow> , src ''FRefK
08:39:12 <lunabot>  newtype FRefK k a b = MkFRefK {unFRefK :: (a -> k ((b, b -> a)))}
08:39:16 <mmorrow> , src ''ContT2
08:39:19 <lunabot>  newtype ContT2 o p m a = MkContT2 {unContT2 :: ((a -> m o) -> m p)}
08:39:21 <ski> mmorrow : ty
08:39:26 <mmorrow> ski: np
08:39:29 <mmorrow> and
08:39:39 <mmorrow> , [$ty| modifyFRef |]
08:39:41 <lunabot>  forall a b . FRef b a -> (a -> a) -> b -> b
08:39:44 <lilac> so you could have data Complex a = RealImag a a and then say something like data view RealImag a b = Polar (...) (...)
08:39:53 * ski now only needs to figure out how to "@let" things with lunabot
08:40:03 <lilac> and then pattern match on RealImag, Polar or both for a Complex a argument
08:40:39 <mmorrow> ski: yeah totally. i really need to add that
08:40:47 <jmcarthur_work> lilac, i like that
08:40:55 <mmorrow> ski: i should also try to hack in a way to @let data decls too
08:41:06 <mmorrow> (and classes, etc)
08:41:09 <ski> lilac : yes .. here `(Rect re im) @ (Polar r phi)' patterns might be nice
08:41:36 <ski> mmorrow : ok, so lunabot doesn't have such yet .. i didn't think of that
08:42:20 <mmorrow> ski: no not currently, but i think it wouldn't be that hard to add
08:42:51 <mmorrow> i'll think about the best way to do that
08:45:36 <lilac> jmcarthur_work: the relevant discussion seems to start here: http://www.haskell.org/pipermail/haskell-prime/2007-January/002047.html
08:45:40 <copumpkin> therp: did you figure out your http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7880 issue?
08:46:02 <therp> copumpkin: yes, thanks to ski
08:46:08 <copumpkin> :)
08:46:32 <therp> copumpkin: but frankly speaking I haven't yet though about it from all perspectives
08:47:02 <copumpkin> therp: well the thing is, any Monad instance is necessarily * -> *
08:47:10 <copumpkin> and you're treating it like *
08:47:23 * lilac wonders whether the type (m :: * -> *) -> (n :: * -> *) is meaningful
08:47:24 <therp> copumpkin: yes, the error is clear to me
08:47:53 <copumpkin> ah
08:48:19 <lilac> it makes my head hurt to think about at least, which means it's either something very deep or meaningless ;-)
08:48:36 <ski>   forall a b b c . (Monad b, Monad b) => ((c -> b c) -> b ()) -> ...
08:48:37 <therp> copumpkin: but I have not yet grasped what "a" could be in that case, as in "getSession :: GhcMonad n => m a -> n a"
08:48:38 <copumpkin> lilac: you mean somehow changing the kind of (->) so it would allow that?
08:48:38 <ski> strange ..
08:48:53 <ski> lilac : not in haskell
08:48:54 <lilac> copumpkin: yeah. i'm not sure what kind the result would be.
08:49:16 <lilac> nor what the instances would look like for that matter
08:49:20 <copumpkin> :P
08:49:26 <ski>   (->) :: (* -> *) -> (* -> *) -> ...   -- this is *not* correct
08:49:50 <lilac> ski: sure, not for the (->) we know and love :)
08:50:14 <ski> (there could be another `(->)'-like thing, of course .. or even overloading)
08:50:28 <lilac> is there any natural meaning for such a thing, though?
08:50:30 <pikhq> :k (->)
08:50:32 <lambdabot> ?? -> ? -> *
08:50:39 <nainaide> To generate html, Is there any other way than text.Html ? Thanks
08:50:56 <jmcarthur_work> lilac, (forall a . m a) -> (forall a . n a) -- perhaps this is clearer and more meaningful?
08:50:59 <ski> lilac : natural transformations, possibly
08:51:37 <ski> (jmcarthur_work : rather `forall a. m a -> n a', in case of NT ..)
08:52:09 <ski> another possibility would be a `Reader' thing on the type-level
08:52:18 <jmcarthur_work> ski, ah yeah you're right, probably
08:52:28 <jmcarthur_work> depends how you interpret the original type i guess
08:52:28 <ski> (i.e. more or less `\a -> (m a -> n a)'
08:52:29 <ski> )
08:52:44 <quicksilver> lilac: well you can have things of kind (* -> *) -> (* -> *). like MaybeT, for example.
08:52:48 <quicksilver> lilac: is that what you mean?
08:53:00 <ski> @kind RWST
08:53:01 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
08:53:35 <jmcarthur_work> quicksilver, isn't that the kind of *any* monad transformer?
08:53:39 <lilac> quicksilver: no, not really. i'm wondering if there's some natural extension of haskell's type system with a function-like type between types with kind * -> *
08:53:50 <lilac> i think there probably isn't, though
08:54:07 <jmcarthur_work> lilac, type composition, maybe?
08:54:08 * ski thinks there might be
08:54:11 <jmcarthur_work> for example
08:54:26 <jmcarthur_work> (f :. g) a = O (f (g a))
08:54:34 <lilac> jmcarthur_work: that's not particularly function-like
08:54:46 <jmcarthur_work> :. could be seen as a type function
08:55:15 <quicksilver> yes, but lilacs point is precisely about values, not types.
08:55:21 <quicksilver> he wants a value function, not a type functin.
08:55:29 <quicksilver> lilac: but what is a value of kind * -> * ?
08:55:30 <jmcarthur_work> oh, values of things with kind (* -> *)?
08:55:38 <lilac> quicksilver: well, quite :)
08:55:46 <quicksilver> (if you like, what is a value of a type of kind * -> * ?)
08:55:52 <therp> what are the questions marks supposed to mean in the kind of (->) ?
08:56:21 <quicksilver> they stand for OMGWTFBBQ
08:56:30 <therp> isn't (->) :: * -> * -> * ?
08:56:48 <quicksilver> yes.
08:56:55 <quicksilver> the GHC stuff is about boxed and unboxed and stuff.
08:57:01 <jmcarthur_work> my understanding is that the kind of -> is more complex for unboxed thingies
08:57:07 <quicksilver> GHC extends the kind system to differentiate.
08:57:10 <ToRA> therp: about half way down there's a little ascii diagram explaining the ??'s http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
08:57:24 <therp> tora: thanks!
08:57:45 <ToRA> therp: then start searching around for boxed, unboxed, lifted and unlifted etc
08:58:00 <benmachine> wouldn't it be nice if record syntax data Foo = Foo { bar :: Int } in addition to generating bar :: Foo -> Int also generated setBar :: Int -> Foo -> Foo
08:58:28 <jmcarthur_work> benmachine, data-accessor
08:58:35 <lilac> weird, ?? seems to be a subset of ?, yet (#,#) is allowed in function arguments but not in results (so is in ?? not ?)
08:58:35 * benmachine looks
08:58:55 <jmcarthur_work> benmachine, and there are also other packages following the same naming scheme that offer things like templates, state monad helpers, etc.
08:58:57 <lilac> or have i got that backwards?
08:59:09 <quicksilver> benmachine: yes, or better still if it generated something more general instead of either.
08:59:49 <jmcarthur_work> benmachine, the template package is particularly helpful :)
09:00:17 <benmachine> jmcarthur_work: I'm having a look, thanks
09:00:19 <ski> lilac : no, the other way around : unboxed tuples is allowed in results, but not in arguments
09:19:41 <Paczesiowa> what's the relation between gadts and refinement types?
09:20:09 <RyanT50001> where is the global config file for cabal-install?
09:20:37 <saml> they got married
09:21:09 <ski> Paczesiowa : is there any ?
09:21:35 <Paczesiowa> ski: googling refinement types haskell leads to ghc docs about gadts
09:22:15 <ski> maybe there is, in the sense that fixing indices of a GADT can reduce the possible constructors ..
09:22:30 <Paczesiowa> but from what understand, refinement types are great to define non-empty list type and still be able to use regular list functions
09:22:46 <Paczesiowa> but to do that with gadts, you have to start up front with gadt datatype
09:23:39 <Paczesiowa> does it make sense?
09:24:51 <ski> it possibly doesn't make sense for general-purpose types like lists
09:25:23 <ski> (since you'd have to take the refinement-indices into account all the time)
09:26:09 <Paczesiowa> ski: please explain:) what indices?
09:26:45 <Peaker> Hey, why isn't IO () a Monoid?
09:27:25 <ski> Paczesiowa : the GADT arguments
09:27:30 <benmachine> Peaker: why/how would it be?
09:27:37 <Peaker> return ()  and  (>>)
09:27:52 <benmachine> oh
09:27:54 <benmachine> like that
09:28:15 <ski> Paczesiowa : there's many possible different useful refinement types for lists .. non-empty, even-lengthed, et.c.
09:28:33 <EvilTerran> Peaker, i guess that'd generalize to (Monad m, Monoid a) => m a
09:28:34 <ski> as a GADT, you have to pick the "refinement" you want, up-start
09:28:55 <Peaker> EvilTerran: oh, right
09:29:23 <Paczesiowa> ski: so refinement types are more powerful, or something entirely different?
09:29:39 <ski> they are different, though maybe comparable in some ways
09:30:02 <ski> i'm not sure whether they are more powerful, but i think they can be more convenient / maybe more modular, too
09:30:11 <Paczesiowa> why there is no ghc extension for them? they sound really useful
09:30:21 <ski> ask the implementors
09:30:56 <Paczesiowa> there must be some undecidable catch, there always is...
09:32:40 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7881#a7881 <-- could someone explain exactly what I can float out as a let?
09:32:44 <gwern> it's not at all obvious to me
09:33:38 * benmachine is trying to find the monoid laws and not having much luck
09:36:03 <quicksilver> benmachine: mempty is a left and right unit for mappened, mappend is associative.
09:36:07 <ski> gwern : is `1 `fidiv` Set.size wrds' the "rank value" ?
09:36:14 <gwern> ski: believe so
09:36:18 <benmachine> quicksilver: okay cool
09:36:31 <benmachine> is mappend for () just id
09:36:36 <gwern> but wrds is generated on each item in the list, so I'm not sure how aything depending on it can be floated out
09:36:41 <ski>     [(word, 1 `fidiv` Set.size wrds) | (_sentenceId, wrds) <- Map.toList s , word <- Set.toList wrds]
09:36:42 <benmachine> I guess it must be
09:36:45 <ski>   = [(word, rank) | let {rank = 1 `fidiv` Set.size wrds} , (_sentenceId, wrds) <- Map.toList s , word <- Set.toList wrds]
09:36:54 <benmachine> or const () I suppose
09:37:04 <ski> well, no, flip the `let' and the first generator
09:37:05 <byorgey> benmachine: well, const (const ()) actually
09:37:06 <gwern> 'let {rank = 1 `fidiv` Set.size wrds}' ???
09:37:21 <benmachine> byorgey: oh yeah, good point
09:37:25 <ski>   = [(word, rank) | (_sentenceId, wrds) <- Map.toList s , let {rank = 1 `fidiv` Set.size wrds} , word <- Set.toList wrds]  -- corrected
09:37:46 <gwern> but, but where the 'in'? why the brackets?
09:37:49 * gwern is confuzzled
09:37:55 <jmcarthur_work> Peaker, http://hackage.haskell.org/packages/archive/monoids/0.2.0.1/doc/html/Data-Monoid-Monad.html
09:37:59 <lilac> Peaker: someone (i think maybe conal) had a Monoid instance for IO () in some package somewhere
09:38:04 <ski> gwern : the point is that `rank' doesn't depend on `word', only `wrds', so should be put before the generation of `word' (but after the generation of `wrds')
09:38:33 <ski> > [z | x <- [0..3] , let {y = x*x} , z <- [0..y]]
09:38:35 <lambdabot>   [0,0,1,0,1,2,3,4,0,1,2,3,4,5,6,7,8,9]
09:38:42 <gwern> ...it compiles but I have no idea how brackets or let decls like that are legal
09:38:52 <jmcarthur_work> lilac, i think you're right. maybe it's in TypeCompose
09:38:53 <ziman> gwern, i think it's useful to think of the list comprehension as a do-block, there's no `in' there as well
09:38:57 <Deewiant> > [z | x <- [0..3] , let y = x*x, z <- [0..y]]
09:38:59 <lambdabot>   [0,0,1,0,1,2,3,4,0,1,2,3,4,5,6,7,8,9]
09:39:02 <Peaker> lilac: Yeah, I found it in TypeCompose. Its called Control.Instances which contains only that instance :-)
09:39:10 <Peaker> lilac: kind of a name hijack :)
09:39:14 <pikhq> ski: Wouldn't that be clearer with do notation?
09:39:20 <ski> gwern : it's like a normal `let {...} in ...' expression (but without the `in ...' part) (or like a `let {...}' command inside a `do'-block)
09:39:30 <jmcarthur_work> yup http://hackage.haskell.org/packages/archive/TypeCompose/0.6.4/doc/html/src/Control-Instances.html
09:39:46 <pikhq> > do x <- [0..3]; let y = x*x; z <- [0..y]; return z
09:39:47 <ski> pikhq : maybe .. gwern only asked about how to "float" the rank to the proper place, though
09:39:47 <lambdabot>   <no location info>: parse error on input `<-'
09:39:50 <gwern> but, it's a list comp. sugar over some maps and filters and stuff. what does it have to do with do-notation?
09:39:52 <pikhq> ski: Ah.
09:40:00 <ziman> do { (_sentenceId, wrds) <- Map.toList s; let {rank = 1 `fidiv` Set.size wrds}; word <- Set.toList wrds; return (word,rank); } in the list monad
09:40:00 <ski> > [z | x <- [0..3] , let y = x*x , z <- [0..y]]
09:40:02 <lambdabot>   [0,0,1,0,1,2,3,4,0,1,2,3,4,5,6,7,8,9]
09:40:17 <jmcarthur_work> Peaker, also relevant is the Kliesli instance for Category
09:40:25 <ski> pikhq : the brackets were just for completeness .. i realize they aren't needed even on a single line, now
09:40:32 <jmcarthur_work> err Kleisli
09:40:49 <jmcarthur_work> slightly different i guess, nevermind
09:40:56 <jmcarthur_work> mind association
09:41:45 <pikhq> gwern: Monad comprehensions?
09:42:06 <gwern> pikhq: thought those were scary titans of haskell 1.5 and not in haskell '98
09:42:24 <Peaker> jmcarthur_work: thanks
09:42:51 <gwern> @remember JonFairbairn And one of the tests failed because Bolivia is now the Plurinational State of Bolivia, so I've add a patch for that. I've seen politics get in the way of programming, but I've never had a bug caused by /international/ politics before.
09:42:52 <lambdabot> Done.
09:42:56 <gwern> @flush
09:43:06 <pikhq> gwern: What I mean to say is that list comprehensions can be generalised to the monads, thereby getting you a vaguely similar syntactic sugar to do notation.
09:43:50 <lvh> Hi!
09:44:09 <lvh> Does haskell have anything like erlang to parallelize across multiple computers, and not just multiple CPUs?
09:44:37 <lvh> I tried googling, but I'm not sure what to google for. Obviously haskel parallelism got me a bunch of stuff I don't want.
09:44:39 <gwern> there were research projects covering that, but is there anything you could install or consider production-ready? not that I know of
09:44:50 <jmcarthur_work> as common as this question is you would think the answer would be yes, but it's not really the case
09:45:34 <gwern> hm. floating the let out doesn't seem to affect the runtime
09:46:16 <pikhq> lvh: Aside from libraries that imitate the Erlang protocol (poorly), not really. Not because Haskell *can't* do that (really, it wouldn't be *that* hard to do something similar to Erlang with it), but because nobody's bothered to.
09:46:43 <lvh> pikhq: Dang. Oh well, thanks :-)
09:46:47 <pikhq> I imagine in large part because Erlang does it just fine, so the people who want that just use Erlang.
09:47:11 <lvh> pikhq: I'm doing number crunching -- Erlang does it just fine for me now, but even HiPE's number crunching is slow.
09:47:37 <gwern> @hoogle maximumBy
09:47:37 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
09:47:37 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
09:47:40 <gwern> @src maximumBy
09:47:41 <lambdabot> Source not found. :(
09:47:43 <gwern> @src maximum
09:47:44 <lambdabot> maximum [] = undefined
09:47:44 <lambdabot> maximum xs = foldl1 max xs
09:47:49 <gwern> @src max
09:47:50 <lambdabot> max x y = if x <= y then y else x
09:48:15 <jmcarthur_work> well if it's parallelism you're after, haskell will not disappoint, but for distributed computing we don't really have a nice shrink-wrapped solution
09:48:41 <gwern> @check \x -> sortBy (flip compare) x == maximum x
09:48:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:48:51 <gwern> :t maximum
09:48:52 <lambdabot> forall a. (Ord a) => [a] -> a
09:48:56 <gwern> :t sortBy (flip compare)
09:48:58 <lambdabot> forall a. (Ord a) => [a] -> [a]
09:49:08 <gwern> @check \x -> head $ sortBy (flip compare) x == maximum x
09:49:10 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:49:38 <gwern> @check \x -> head ( sortBy (flip compare) x) == maximum x
09:49:40 <lambdabot>   "* Exception: Prelude.head: empty list
09:49:44 <gwern> bleh
09:49:49 <lvh> jmcarthur_work: Well, I've got large datasets of trivially parallelizable stuff, and I'm kind of liking my Erlang setup right now in the sense that I can *almost* transparently plug in an extra blade, and erl starts using it.
09:49:58 <gwern> @check \x -> if (null x) then True else (head ( sortBy (flip compare) x) == maximum x)
09:50:00 <lambdabot>   "OK, passed 500 tests."
09:50:24 <lvh> jmcarthur_work: although I suppose I could serialize the data, and fire up haskell processes on the workers.
09:50:47 <gwern> ok, correct me if I'm wrong, but is the difference between the 2 that sortBy flip compare is O(n*log n), while maximum is just O(n)?
09:51:04 <gwern> lvh: that would work. or maybe you could FFI to haskell
09:51:24 <gwern> (or I guess it'd be n+log(n), actually_
09:51:56 <benmachine> well, the sortBy will only sort as much as it needs to in order to determine the head of the list
09:51:56 <Deewiant> sort is lazy so head . sortBy f should be O(n)
09:52:26 <gwern> benmachine: but how can one determine the maximum of a list without looking at the whole thing?
09:52:33 <gwern> so it has to be at least n
09:52:42 <benmachine> true
09:52:55 <benmachine> so you may as well use maximum either way I suppose
09:53:33 <gwern> > maximum []
09:53:35 <lambdabot>   * Exception: Prelude.maximum: empty list
09:53:53 <gwern> > sortBy (flip compare) p[
09:53:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:53:56 <gwern> > sortBy (flip compare) []
09:53:57 <lambdabot>   []
09:55:14 <benmachine> okay so I just wrote this and the code is fine (ish) but the indentation is horrible: http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=3154#a3154
09:55:26 <ziman> @check \x -> length . nub . sort $ x <= 1
09:55:27 <lambdabot>   Couldn't match expected type `[a]'
09:55:31 <benmachine> can anyone offer advice on how they'd format that neatly?
09:55:45 <benmachine> in fewer than 80 columns
09:55:45 <jmcarthur_work> benmachine, guards?
09:55:55 <gwern> yeah, was about to say
09:55:58 * benmachine fiddles
09:56:00 <gwern> multiple if-thens scream for guards
09:56:14 <benmachine> you are right of course
09:56:21 <benmachine> I'd forgotten about them >_>
09:56:26 <ziman> @check \x -> (length . nub . sort $ x) <= 1
09:56:28 <lambdabot>   "OK, passed 500 tests."
09:57:14 <EvilTerran> @check \x -> (length . nub . sort $ (x :: [Int])) <= 1
09:57:15 <lambdabot>   "Falsifiable, after 2 tests:\n[1,-1,-1]\n"
09:57:17 <gwern> oh wow. switching to maximum from sort bought me 2s out of 18
09:57:54 <gwern> > (2/18)*100
09:57:56 <lambdabot>   11.11111111111111
09:58:35 <benmachine> hmm using guards requires me to check a condition twice
09:58:48 <benmachine> or
09:58:49 <benmachine> does it
09:58:51 <benmachine> no it doesn't
09:59:00 <benmachine> I just have to be cleverer and invert some conditions
09:59:17 <Deewiant> benmachine: http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=3154#a3155
09:59:47 <benmachine> Deewiant: hmm not bad, not bad at all
10:01:06 <lilac> gwern: what're you optimizing?
10:04:56 <gwern> lilac: a text processing tool
10:05:07 <gwern> (that's interesting/ it doesn't compile without type sigs)
10:05:22 <lilac> @type fidiv
10:05:25 <lambdabot> Not in scope: `fidiv'
10:05:52 <Deewiant> In all likelihood fidiv :: (Integral a, Floating b) => a -> a -> b
10:06:29 <gwern> fidiv ∷  (Integral a, Fractional b) ⇒  a →  a →  b
10:06:32 <gwern> fidiv = (/) `on` fromIntegral
10:06:37 <Deewiant> ?ty (/)
10:06:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:06:44 <Deewiant> Right, Fractional, not Floating
10:07:16 <gwern> :i Floating
10:07:26 <gwern> :i Float
10:07:58 <MyCatVerbs> RealFloat or RealFrac.
10:08:19 <MyCatVerbs> Oh and Real, too.
10:09:23 <lilac> gwern: random thought: is using length on the result of Set.toList wrds (which you work out anyway) any faster than using Set.size on wrds?
10:09:45 <gwern> bleh. now that I think about it, I can't scrap the Rationals before I run maximum, because those're what maximum is comparing
10:10:13 <gwern> lilac: well, I'd imagine set.size is probably near-constant
10:10:18 <gwern> though I'd have to look
10:10:55 <gwern> 'O(1). The number of elements in the set. '
10:11:02 <lilac> ah ok :)
10:11:28 <lilac> i guess pmap = map . curry?
10:11:38 <lilac> s/curry/uncurry/
10:11:44 <gwern> no, think parmap
10:11:47 <gwern> strategies
10:11:58 <lilac> ah ok
10:12:15 <lilac> do you have lots of sentences?
10:12:48 <lilac> you might want to distribute the Map.fromListWith (+)
10:13:14 <lilac> @instances Monoid
10:13:16 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:13:34 <gwern> lilac: yeah, this is aimed at books etc
10:13:46 <gwern> lots of sentences, each relatively short (<100 words)
10:14:31 <lilac> well, you can split your wordlist into chunks and run Map.fromListWith on the chunks in parallel, then join them
10:14:54 <gwern> lilac: you mean run mapfromListWith on sublists n long, and then union them?
10:15:05 <gwern> I guess that'd be unionWith
10:15:07 <lilac> yep
10:15:31 <gwern> unionsWith, even better
10:15:41 <lilac> except instead of sublists n long, i'd take every n'th element
10:15:54 <lilac> that way the second job can start before the first job has got all its input
10:16:06 <gwern> hm. what function would take every nth element?
10:16:10 <gwern> not one I've run into before
10:18:59 <gwern> lilac: is this what you're thinking of?
10:19:00 <gwern> parFromListWith xs = Map.unionsWith (+) $ pmap (Map.fromListWith (+)) [ones, twos, threes, fours]
10:19:03 <gwern>     where ones = takeEvery 1 xs
10:19:06 <gwern>           twos = takeEvery 2 xs
10:19:09 <gwern>           threes = takeEvery 3 xs
10:19:12 <gwern>           fours =  takeEvery 4 xs
10:19:35 <gwern> er, I guess that's not quite right
10:20:11 <lilac> gwern: [ones, twos, threes, fours] = take 4 . map (takeEvery 4) $ tails xs
10:22:17 <burp> @hoogle trigram
10:22:17 <lambdabot> No results found
10:24:25 <lilac> gwern: or: transpose (chunksOf 4 xs)
10:24:34 <gwern> heh. 100% cpu usage tells me I fail at haskell coding
10:24:39 <gwern> parFromListWith xs = Map.unionsWith (+) $ pmap (Map.fromListWith (+)) $ take 4 · map (takeEvery 4) $ tails xs                                  where takeEvery n zs = if length zs < n then [] else (xs !! n) : (takeEvery n $ drop n zs)
10:24:55 <hackagebot> combinat 0.2.3 - Generation of various combinatorial objects. (BalazsKomuves)
10:26:06 <lilac> takeEvery n [] = []; takeEvery n (z:zs) = z:takeEvery n (drop (n-1) zs)
10:27:05 <benmachine> @pl cursorEnd r = editCursor (const . length $ line r) r
10:27:05 <lambdabot> cursorEnd = editCursor =<< const . length . line
10:27:12 <RyanT5000> how do i invoke haddock on an entire module?
10:27:16 <gwern> maybe I should just go to bed already. I'm obviously reaching diminishing returns when someone else is doing most of my programming
10:27:16 <benmachine> ^ am I supposed to be able to recognise that
10:27:29 <gwern> benmachine: @pl is sometimes just humorous
10:27:35 <RyanT5000> *on an entire package
10:27:50 <benmachine> gwern: sometimes
10:28:01 <lilac> gwern: you /really/ don't want to be running length on zs. especially not O(length zs) times :)
10:28:29 <gwern> yeah. if I was thinking straight that'd be obvious
10:28:37 <lilac> benmachine: if you see it as a join on the (->) a monad it's not so bad
10:28:43 <jmcarthur_work> i don't think that @pl output is so bad
10:28:49 <benmachine> RyanT5000: I think there's a cabal command for it? runhaskell Setup.hs haddock
10:28:58 <RyanT5000> benmachine: just found that; thanks
10:29:05 <RyanT5000> (i was looking at haddock options before)
10:29:06 <gwern> hm. parMapWith costs me three seconds in single-threaded mode
10:29:11 <benmachine> lilac: mm I suspected so, I just don't have any experience with the function monad I guess
10:29:12 <lilac> ouch
10:29:39 <lilac> benmachine: the elements are 'functions from a'. so the RHS is a function from a, and the left hand side takes a value and produces a function from a
10:29:51 <gwern> ...and with -N4 it costs me 11 seconds
10:30:01 <gwern> lilac: I think parMapWith is not a good idea :)
10:30:12 <jmcarthur_work> benmachine, it's the reader monad
10:30:14 <lilac> those numbers do not sound promising :)
10:30:22 <lilac> gwern: is it maxing out 4 cpus?
10:30:27 <pikhq> benmachine: The function monad is not all that hard to get.
10:30:31 <leimy> hmmm something is/was wrong with my client
10:31:04 <gwern> lilac: not even. top gives me a peak of 157%
10:31:04 <pikhq> > do {x <- (+1); y <- (*2); z <- (**3); return (x,y,z)} $ 10
10:31:06 <lambdabot>   (11.0,20.0,1000.0)
10:31:24 <pikhq> That's about all there is to it.
10:31:52 <lilac> gwern: have you replaced the sortBy with maximum?
10:31:56 <gwern> yes
10:32:09 <lilac> (and presumably removed the pmap swap too)
10:32:10 <jmcarthur_work> > liftA3 (,,) (+1) (*2) (**3) 10
10:32:11 <lambdabot>   (11.0,20.0,1000.0)
10:32:22 <benmachine> isn't that more or less than same as s/do/let/ and s/return/in/
10:32:22 <Beelsebob> (,,) <$> (+1) <*> (*2) <*> (**3) -- this fwiw
10:32:29 <gwern> no, the pmap swap is still there
10:32:36 <pikhq> benmachine: Not quite.
10:32:42 <lilac> @type maximumBy (comparing snd)
10:32:44 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
10:32:51 <lilac> gwern: ^^ use that and ditch the swap
10:33:04 <gwern> but I have to have the swap
10:33:11 <gwern> you mean don't parallelize the swap?
10:33:17 <lilac> why do you need the swap?
10:33:37 <pikhq> > let {foo a = let x = a+1;y = a*2; z = a**3 in (x,y,z)} in foo 10
10:33:39 <lambdabot>   (11.0,20.0,1000.0)
10:33:40 <lilac> listToMaybe . maximum . map swap == swap . listToMaybe . maximumBy (comparing snd)
10:33:45 <jmcarthur_work> gwern, my curiosity is peaked. what are you doing?
10:33:47 <gwern> lilac: well, I need the strings to be the keys for fromListWith +, but then I need the numbers to be the keys for maximum
10:33:59 <gwern> jmcarthur_work: did you see my -cafe email this morning?
10:34:07 <gwern> jmcarthur_work: see http://jtauber.com/blog/2008/02/10/a_new_kind_of_graded_reader/ for the idea
10:34:19 <pikhq> benmachine: The argument is implicitly applied to all the functions whose results are bound to a name, with the function monad.
10:34:19 <lilac> gwern: use "maximumBy (comparing snd)" to compare the Rational
10:34:37 <pikhq> Nothing you can't do *without* the monad instance, mind, but sumtimes it's nice. ;)
10:34:40 * jmcarthur_work checks -cafe
10:34:41 <gwern> current code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7881#a7883
10:34:44 <lilac> gwern: or "maximumBy (compare `on` swap)" if you want to compare the string too
10:34:44 <byorgey> @seen dons
10:34:45 <lambdabot> dons is in #haskell-hacphi, #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 1h 29m 44s ago.
10:35:25 <benmachine> pikhq: ok thanks
10:35:28 * benmachine appears to be lagging
10:35:29 <gwern> @hoogle comparing
10:35:30 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:35:30 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:35:53 <byorgey> @ask dons there's a 'validate' utility used in the HWN 'publish' script; do you know if 'validate' is available in some arch package?
10:35:53 <lambdabot> Consider it noted.
10:36:02 <erikc> http://macton.posterous.com/roundup-recent-sketches-on-concurrency-data-d
10:36:37 <jmcarthur_work> weird i can't read the email
10:36:40 <gwern> ok, looks like scrapping the swap bought me .3s
10:36:45 <lilac> yay
10:37:41 <lilac> i'm surprised the parallelism on fromListWith isn't helping at all :(
10:37:58 <jmcarthur_work> i'm at work so i can't really watch that video
10:39:57 <gwern> lilac: alas, even with pmap swap removed, parListWith uses only 159% and runs in 28s
10:40:02 <gwern> I'm gonna try removing the other pmap calls
10:40:10 <jmcarthur_work> i would love to waste some time on this, but i'm supposed to be working :\
10:40:51 <lilac> jmcarthur_work: likewise, but my code is building / testing right now :)
10:41:07 <gwern> nope. even with the only pmap inside parListWith, still 28s
10:41:15 * lilac asks people to imagine i posted the relevant xkcd
10:41:29 * jmcarthur_work sword fights with lilac 
10:41:35 * c_wraith imagines looking at the relevant xkcd
10:42:12 * lilac has a cardboard tube by his desk for just such an eventuality
10:42:12 * gwern visualizes sighing wearily
10:42:35 <gwern> for when you meet the carboard tube samurai?
10:43:02 <lilac> gwern: one more thought then. you could try partitioning the words alphabetically into four groups, then distributiong the Map.fromListWith, and not using Map.unionsWith at all
10:43:42 <jmcarthur_work> is there a textual description of the algorithm anywhere?
10:44:19 <jmcarthur_work> or even just what it's supposed to do?
10:45:27 <gwern> jmcarthur_work: not really. 'break up a text into a list of sentences, themsleves a list of words; take a list of known words, and find the sentences 'most nearly filled' by the known words; now figure out what unknown word will bring the most sentences to filled status, where filled means if I know "foo" and "bar", then I know the sentence ["bar", "bar", "foo", "foo", "bar"]'
10:46:16 <jmcarthur_work> gwern, i think i understand
10:46:27 <gwern> really? I wouldn't based on my crappy description
10:46:56 <gwern> lilac: yes, I guess that would work. I wonder if the cost of sorting and partitioning the list isn't more than the parallelism is worth tho
10:47:57 <jmcarthur_work> gwern, find the sentences that contain the highest ratio of known:unknown words, then find the word that would achieve the greatest number of sentences completed by learning that word?
10:48:35 <gwern> well, I think my algorithm works just with teh second clause - find the word that completes the most sentences
10:48:51 <jmcarthur_work> gwern, i assume the goal being to find the "most helpful" word to learn next?
10:48:58 <gwern> I don't think there's any step to find the most nearly-known sentence, although I wouldn't be surprised if that were equivalent
10:49:35 <dons> byorgey: validate is provided by w3c
10:49:35 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
10:49:40 <dons> on the http validation site
10:50:34 <jmcarthur_work> gwern, okay i am pretty sure i understand now
10:50:55 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7881#a7884 <-- freshest code
10:51:59 <byorgey> dons: I don't see anything I can download there.  on Ubuntu I could just install the 'wdg-html-validator' package which provided a utility called 'validate'; I was just wondering if you knew of a similar package for arch
10:52:06 <byorgey> since I just installed arch on my new laptop
10:52:37 <dons> let me see.
10:52:59 <MyCatVerbs> byorgey: pacman -Ss :)
10:53:31 <byorgey> MyCatVerbs: I tried that, didn't turn up anything likely
10:53:35 <dons> http://validator.w3.org/docs/install.html i think
10:53:53 <byorgey> aha, thanks dons
10:55:47 <lysgaard> I have a function of type "StateT NodeState IO ()" How can i do a forkIO inside it's do block?
10:56:35 <byorgey> @type forkIO
10:56:37 <lambdabot> Not in scope: `forkIO'
10:56:37 <gwern> ok, so that leaves one suggestion from gale: 'approximation rescans the entire corpus after discarding each  word. Try to think of a way to recompute only those sentences  that contained the word.' but I guess I can work on that after I go to bed
10:56:55 <gwern> er, after I go to sleep & wake up, obviously, not work on it - in bed
10:57:10 <gwern> hm. 'would you like to forkIO with me - in bed?'
10:57:13 <byorgey> lysgaard: have you tried using liftIO?
10:57:24 <gwern> 'I'd liftIO her - in bed'
10:57:54 <gwern> 'I wish I could quit you - in bed'
10:58:32 <gwern> 'let's join our functions - in bed'
10:59:19 <c_wraith> @check \a -> join (+) a == 2 * a
10:59:21 <lambdabot>   "OK, passed 500 tests."
11:00:04 <athos> hm
11:00:49 <c_wraith> What's the range on the Arbitrary instance for Integer?
11:04:20 <c_wraith> I really think it should have an infinite guassian distribution centered on zero with a stddev of maxint
11:04:30 <c_wraith> But that seems difficult to implement
11:04:55 <lysgaard> byorgey: How, I've tried, but something says me i did it worng
11:05:50 <byorgey> lysgaard: liftIO $ forkIO m
11:06:04 <byorgey> where m is the IO () action you want to run in a new thread
11:06:10 <edwardk> @seen saizan
11:06:11 <lambdabot> saizan is in #kata, #haskell-in-depth, #ghc, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard saizan speak 6h 3m 40s ago.
11:06:26 <byorgey> so:  do { threadId <- liftIO $ forkIO m;  ... do something with the threadId ... }
11:07:10 <edwardk> @tell saizan I solved my "How to make an Iteratee-based Stream instance for Parsec" problem.
11:07:11 <lambdabot> Consider it noted.
11:09:24 <jmcarthur_work> c_wraith, i think the range is that of Int. i do think a guassian distribution would have been cool
11:10:18 <lysgaard> byorgey: I actually did that already. I think I've found the problem. The function i want tu do it on has the type: "(MonadIO m) => UdpHandle -> (UdpHandle -> String -> m a) -> m b" How do i do forkIO that?
11:14:12 <lysgaard> byorgey: Here's a hpaste of the problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7890#a7890
11:16:56 <byorgey> lysgaard: what problem are you having exactly?  udpListen (udpHandle st) handleUdpMessage  should be able to have type  IO (), since IO is an instance of MonadIO.
11:17:27 <byorgey> assuming that udpHandle st :: UdpHandle  and  handleUdpMesage :: UdpHandle -> String -> IO a
11:18:17 <byorgey> so  liftIO $ forkIO $ udpListen ...  should have type  IO ThreadId
11:18:34 <byorgey> er, sorry, I mean
11:18:49 <byorgey> StateT NodeState IO ThreadId
11:19:51 <lysgaard> byorgey: I guess you're right, I updated with the error message and a more explaining example
11:20:48 <byorgey> lambdabot: oh, what type is handleUdpMessage?
11:21:37 <byorgey> er, lysgaard*
11:22:11 <lysgaard> byorgey: handleUdpMessage is the blocker, it has the type :: (MonadState NodeState m, MonadIO m) => UdpHandle -> [Char] -> m ()
11:22:23 <byorgey> ah, well there's your problem
11:22:52 <lysgaard> byorgey: I'm not very comfortable with monad transformers yet as you probably see :S
11:23:33 <byorgey> the forkIO call is forcing the 'm' to be IO
11:23:54 <byorgey> but handleUdpMessage wants m to be an instance of  MonadState NodeState
11:23:59 <byorgey> which IO definitely is not
11:24:12 <lysgaard> byorgey: And IO's not?
11:24:41 <byorgey> lysgaard: no, you cannot call 'get' in the IO monad and get a NodeState =)
11:25:06 <lysgaard> byorgey: Heh, you're fast. So is my program ill written, or is this solveable?
11:25:12 <lilac> you also cannot fork off a computation which reads and writes a NodeState which other pure code uses!
11:25:32 <byorgey> right, intuitively it is ill-written because you cannot fork a stateful computation.
11:26:06 <lilac> if you're only 'get'ing the NodeState, how about handleUdpMessage :: NodeState -> UdpHandle -> String -> IO () ?
11:26:15 <lilac> get it outside and pass it in
11:26:27 <byorgey> although there may be a way around it by somehow duplicating the current state, but it would require some manual plumbing.
11:26:32 <lilac> and as a bonus handleUdpMessage becomes more general
11:27:26 <mxc> byorgey - on a totally unrelated note, know if there be anything interesting going on wrt haskell at penn CIS (like hac \phi was) in september?  I'll be in philly for that month
11:27:29 <lysgaard> lilac: No cant' handleUdpMessage is the core function. It reads, sets everything with the State
11:27:50 * lilac looks at the paste :
11:28:19 <byorgey> lysgaard: when you fork off this computation, do you expect it to make changes to the state which you want access to later?  (this is not possible)  or does it just need to know what the current state was? (this can be done)
11:29:21 <byorgey> lysgaard: in the latter case, you can wrap handleUdpMessage in a call to 'evalState' passing it the current state.
11:29:43 <byorgey> (which will throw away any changes that the forked thread makes to the state).
11:29:47 <lilac> lysgaard: the problem is essentially that you're trying to do something nondeterministic -- having multiple readers and writers of the same monadic state running in parallel -- and the type system is stoppign you
11:30:15 <lilac> lysgaard: so you have to either make it deterministic (by either splitting the state or sequencing the operations)...
11:30:19 <lysgaard> byorgey: I need the changes to presist
11:30:22 <lilac> ... or use something explicitly nondeterministic
11:30:39 <lilac> in the latter case you could use an IORef or an MVar instead of StateT
11:31:18 <lysgaard> If you guys wan't you can darcs pull the whole project, then you'll get a bette view. It's just 5 files. And you guys would probably see my disign fault
11:32:06 <lysgaard> the address would be: darcs get http://patch-tag.com/r/lysgaard/pullrepo lysgaard
11:32:24 <lysgaard> s/address/command/
11:33:29 <burp> http://paste.railsbox.eu/show/ctfaUS81A8yP6RBY1zmb/ <- my trigram creator, any recommendations for improvement, or other implementation ideas?
11:33:39 <burp> prints ["ver","ery","ry ","y c"," co","coo","ool","ol ","l e"," ex","exa","xam","amp","mpl","ple"]
11:33:51 <byorgey> mxc: nothing specific, but you'd be welcome to come and visit =)
11:34:21 <byorgey> mxc: maybe we could have a mini-hackathon
11:35:10 <mxc> well, i'm definitely goingt o stop by to visit some of my professors
11:35:35 <Berengal> > filter ((>=3).length) . map (take 3) . tails $ "very cool example"
11:35:37 <lambdabot>   ["ver","ery","ry ","y c"," co","coo","ool","ol ","l e"," ex","exa","xam","a...
11:35:49 <lysgaard> burp: Instead of (trgs ++ [(take 3 str)]), why not (take 3 str : trgs)
11:36:13 <burp> hm yes, why not :>
11:36:27 <burp> thats why I asked for improvments and other ideas ;)
11:36:37 <lysgaard> burp: Should improve performance if I'm remembering right
11:38:09 <burp> Berengal: nice solution
11:53:33 <byorgey> mxc: let me know when you're going to stop by, I'd love to meet you
11:53:48 <mxc> i'll give you a shout for sure
11:54:01 <mxc> i'll actually be in rittenhouse from sep 5 - oct 5
11:54:06 <mxc> not sure when i'll be on campus though
11:54:18 <byorgey> rittenhouse, that's not very far away!
11:54:57 <lilac> > transpose . take 3 . iterate tail $ "very cool example"
11:54:58 <lambdabot>   ["ver","ery","ry ","y c"," co","coo","ool","ol ","l e"," ex","exa","xam","a...
11:55:17 <lilac> > zipWith3 (\a b c -> [a,b,c]) . take 3 . iterate tail $ "very cool example"
11:55:19 <lambdabot>   Overlapping instances for GHC.Show.Show
11:55:20 <lambdabot>                              ([[GHC...
11:55:30 <byorgey> lilac: hah, nice
11:55:38 <c_wraith> :t iterate
11:55:40 <lambdabot> forall a. (a -> a) -> a -> [a]
11:55:47 <byorgey> > transpose . take 3 . iterate tail $ "abc"
11:55:48 <lambdabot>   ["abc","bc","c"]
11:55:49 <trofi> @src transpose
11:55:50 <lambdabot> transpose []             = []
11:55:50 <lambdabot> transpose ([]   : xss)   = transpose xss
11:55:50 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
11:55:52 <Plouj> hi
11:56:13 <byorgey> lilac: so is it equivalent to  map (take 3) . iterate tail ?
11:56:30 <lilac> looks like :)
11:56:31 <byorgey> oh!  no, it isn't
11:56:42 <byorgey> > map (take 3) . iterate tail $ "abc"
11:56:44 <lambdabot>   ["abc","bc","c","","* Exception: Prelude.tail: empty list
11:56:46 <byorgey> BOOM
11:56:58 <lilac> it's almost map (take 3) . tails
11:57:05 <byorgey> yeah, except for the empty list
11:57:09 <lilac> yeah
11:57:23 <Geheimdienst> hi guys. i upgraded to ghc 6.10 recently, and now i've trouble recompiling my xmonad (= reloading the config file)
11:57:27 <lilac> and input lists less than 3 elems long
11:57:33 <Geheimdienst> the compiler error i get is this:
11:57:36 <lilac> but that's fixable by using drop 1 instead of tail
11:57:40 <Geheimdienst> http://pastebin.com/m472a5742
11:59:07 <byorgey> Geheimdienst: hmm.  did you try doing a clean rebuild?  i.e.  'runhaskell Setup.hs clean' first?
11:59:50 <byorgey> oh, wait, sorry, I thought you were having trouble building xmonad itself
11:59:50 <Geheimdienst> no, but i did cabal install --reinstall xmonad xmonad-contrib
12:00:03 <lilac> > chr 1114112
12:00:05 <lambdabot>   * Exception: Prelude.chr: bad argument
12:00:26 <lilac> Geheimdienst: are you using chr from TH somewhere in your xmonad config? :)
12:00:33 <byorgey> Geheimdienst: can you paste your xmonad.hs?
12:00:36 <Philonous> @hoogle Read a => String -> Maybe a
12:00:37 <lambdabot> Prelude read :: Read a => String -> a
12:00:38 <lambdabot> Text.Read read :: Read a => String -> a
12:00:38 <lambdabot> Distribution.Text simpleParse :: Text a => String -> Maybe a
12:00:38 <Geheimdienst> what is Prelude.chr anyway? (i'm kind of a newbie)
12:00:48 <byorgey> > chr 93
12:00:49 <Geheimdienst> ok hang on
12:00:50 <lambdabot>   ']'
12:01:01 <byorgey> it just converts Int ASCII codes to Char
12:02:23 <Philonous> Is there something like a graceful read? I.e. read that doesn't slap an exception in my face when it couldn't parse the input?
12:02:33 <burp> reads
12:03:01 <burp> > reads "93ab" :: Int
12:03:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:03:15 <burp> um, sure
12:03:18 <Geheimdienst> lilac: what do you mean by TH ?
12:03:26 <Geheimdienst> ok here's my xmonad.hs http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7895#a7895
12:03:31 <Zao> Template Haskell?
12:03:33 <burp> > reads "93ab" :: [(Int,String)]
12:03:34 <saml> Philonous, what is expected behavior for read "2uweaofis" :: XML
12:03:35 <lambdabot>   [(93,"ab")]
12:03:39 <Geheimdienst> it's not very messy right now ;-)
12:03:47 <Philonous> saml: Nothing
12:03:49 <burp> :t reads
12:03:51 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:03:59 <Philonous> burp: Thank you
12:05:06 <ski> > (reads :: ReadS Int) "93ab"
12:05:08 <lambdabot>   [(93,"ab")]
12:05:17 <Geheimdienst> btw, note that i have one workspace named with a unicode char (205d). but i commented out all references to that and it didn't affect the compiler error
12:05:34 <ski> Philonous,burp : ^
12:06:00 <burp> ski: yup, seems better :>
12:06:35 <ski> @let readMaybe :: Read a => String -> Maybe a; readMaybe s = case reads s of [(a,"")] -> Just a; _ -> Nothing
12:06:36 <lambdabot>  Defined.
12:06:55 <burp> :t listToMaybe [y | (y,z) <- reads x, null z]
12:06:57 <lambdabot>     Couldn't match expected type `String' against inferred type `Expr'
12:06:57 <lambdabot>     In the first argument of `reads', namely `x'
12:06:57 <lambdabot>     In the expression: reads x
12:07:06 <burp> I stole this one from the haskell wiki once
12:07:30 <ski> that one will give an answer even if there's multiple solutions
12:07:50 <ski> (which may or may not be what you want)
12:07:55 <lilac> are there any common Read instances which produce more than one possible parse?
12:08:11 <byorgey> Geheimdienst: try deleting any .hi or .o files in ~/.xmonad/ and then rebuild
12:08:12 <ski> not that i know
12:08:37 <byorgey> Geheimdienst: I just did a Google search for part of the error message
12:09:21 <Geheimdienst> yay, it works
12:09:31 <Geheimdienst> killing the hi and o did it
12:09:36 <Geheimdienst> thanks guys
12:09:37 <lilac> @type let readMaybe s = do [(a,"")] <- return s; return a in readMaybe
12:09:38 <lambdabot> forall b (m :: * -> *). (Monad m) => [(b, [Char])] -> m b
12:09:47 <lilac> @type let readMaybe s = do [(a,"")] <- return (reads s); return a in readMaybe
12:09:49 <lambdabot> forall (m :: * -> *) a. (Monad m, Read a) => String -> m a
12:09:56 <byorgey> Geheimdienst: great!  The problem was that the .hi and .o files were generated by the old version of ghc, I think
12:10:13 <byorgey> Geheimdienst: but the new ghc didn't know that and thought it didn't have to rebiuld them, but there was some sort of incompatibility
12:10:29 <lilac> @type let readMaybe :: (MonadPlus m, Read a) => String -> m a; readMaybe s = do [(a,"")] <- return (reads s); return a in readMaybe
12:10:31 <lambdabot> forall (m :: * -> *) a. (Read a, MonadPlus m) => String -> m a
12:11:18 <Geheimdienst> yeah, i had the same feeling, that's why i did a cabal install reinstall. but i missed those two files, cabal couldn't have known about them
12:11:25 <LeCamarade> Hey, on FreeBSD 7.2,  Network.connectTo doesn't work. Anybody seen this happen too? (Even under withSocketsDo.)
12:12:46 <harlekin> @hoogle (a -> Bool) -> [a] -> Maybe a
12:12:47 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
12:12:47 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
12:12:47 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
12:13:04 <harlekin> @hoogle (a -> m Bool) -> [a] -> m (Maybe a)
12:13:04 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
12:13:05 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
12:13:05 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
12:14:07 <ski> @let readM :: (MonadPlus m,Read a) => String -> m a; readM = msum . map (\(a,s) -> guard (null s) >> return a) . reads
12:14:09 <lambdabot>  Defined.
12:14:35 <ski> (lilac : opinion ?)
12:14:45 <lilac> better :)
12:14:55 <LeCamarade> Who runs FreeBSD in here?
12:15:09 <lilac> (that is, better semantics)
12:15:15 <jmcarthur_work> LeCamarade, i've thought about it
12:15:22 <jmcarthur_work> but i don't yet
12:16:04 <LeCamarade> jmcarthur_work, It's great, but suffers a bit from being uncommon.
12:16:05 <lilac> @pl \a s -> guard (null s) >> return a
12:16:06 <lambdabot> flip ((>>) . guard . null) . return
12:16:07 <LeCamarade> :o)
12:16:11 <lilac> yuk
12:16:14 <Philonous> LeCamarade: There's #haskell-freebsd
12:16:27 <jmcarthur_work> LeCamarade, i've been looking at dragonfly even more strongly, but it suffers from that same problem even more :\
12:16:32 <LeCamarade> Philonous, thanks.
12:17:13 <Philonous> jmcarthur_work: Dragonfly suffers from it's message passing kernel. It's horribly slow. Or at least it was when I last looked at it.
12:17:27 <jmcarthur_work> Philonous, when was that?
12:17:35 <jmcarthur_work> was it 2.0 or higher?
12:17:44 <Philonous> No
12:17:53 <jmcarthur_work> okay
12:18:02 <jmcarthur_work> well, i haven't put it through much stress yet
12:18:10 <jmcarthur_work> it hasn't seemed slow in my vm, though
12:19:08 <lilac> @type msum . map (uncurry (<<) . (return *** guard . null)) . reads
12:19:10 <lambdabot> forall b (m :: * -> *). (MonadPlus m, Read b) => String -> m b
12:20:04 <ManateeLazyCat> How to transform Int to Double?
12:20:14 <c_wraith> :t fromIntegral
12:20:16 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:20:17 <therp> my I annoy the channel with another monad question? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7896#a7896
12:20:21 <ManateeLazyCat> @hoogle Int -> Double
12:20:22 <lambdabot> Prelude toEnum :: Enum a => Int -> a
12:20:22 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
12:20:22 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
12:20:34 <c_wraith> ManateeLazyCat:  fromIntegral
12:21:06 <therp> s/my/may/
12:21:08 <ManateeLazyCat> c_wraith: Thanks
12:21:44 <lilac> therp: the instance MonadIO m => MonadIO (GhcT m) is not in scope
12:22:02 <therp> lilac: I though those things are automatically imported?
12:22:11 <lilac> you need to import whichever module contains that instance
12:23:11 <harlekin> @hoogle (a -> m (b, Bool)) -> Maybe b
12:23:11 <lambdabot> No results found
12:23:22 <therp> lilac: I imported HscTypes (GhcT(..)). that module contains the instance..
12:23:35 <therp> lilac: thanks
12:23:37 <lilac> yeah, i'd have expected it to be in the module which defined GhcT
12:23:44 <copumpkin> harlekin: how would that work? :o
12:23:54 <harlekin> copumpkin, it wouldn't. :D
12:23:58 <copumpkin> lol
12:23:59 <RyanT5000> how do i add a post-commit hook to a darcs repo?
12:24:03 <pikhq> copumpkin: unsafePerformMonad
12:24:05 <RyanT5000> er, i should ask in #darcs; nvm
12:24:05 <harlekin> @hoogle [a] -> (a -> m (b, Bool)) -> Maybe b
12:24:05 <lambdabot> No results found
12:24:07 <harlekin> That should.
12:24:11 <ManateeLazyCat> > intToDouble a = fromIntegral a :: Double
12:24:12 <ManateeLazyCat>  
12:24:12 <copumpkin> like, I can't imagine anything that could make that work
12:24:13 <lambdabot>   <no location info>: parse error on input `='
12:24:20 <ManateeLazyCat> > let intToDouble a = fromIntegral a :: Double
12:24:21 <ManateeLazyCat>  
12:24:21 <copumpkin> harlekin: oh
12:24:22 <lambdabot>   not an expression: `let intToDouble a = fromIntegral a :: Double'
12:24:24 <lilac> therp: try just 'lift a' instead of 'lift (liftIO a)'
12:24:26 <therp> lilac: yes, it's in that module. however, when I remove the limitation of the import of GhcT(..) in the import statement I get a ambiguity warning
12:24:28 <copumpkin> you missed the [a] -> bit :P
12:24:33 <lilac> therp: sorry, just 'liftIO a'
12:24:54 <lilac> therp: that's fine. you don't need to import any names from a module to get all its instances
12:24:56 <ManateeLazyCat> let intToDouble a = fromIntegral a :: Double
12:25:22 <c_wraith> > (fromIntegral 5) :: Double
12:25:24 <lambdabot>   5.0
12:26:45 <c_wraith> :t reads
12:26:47 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:27:06 <mxc> i've got what might be a bit of a basic question about laziness, efficiency etc
12:27:12 <therp> huch, that's really strange. HscTypes exports liftIO. If I "io a = lift (HscTypes.liftIO a)" it works. But why does HscTypes export it's own "variant" of liftIO?
12:27:31 <c_wraith> > (reads "5") :: [(Double, String)]
12:27:33 <lambdabot>   [(5.0,"")]
12:27:36 <therp> s/it's/its/. excuse my bad grammar.
12:27:53 <Saizan> therp: is it in the ghc-api?
12:27:53 <lambdabot> Saizan: You have 1 new message. '/msg lambdabot @messages' to read it.
12:28:11 <therp> saizan: sorry, what do you mean by that?
12:28:43 <mxc> specifically, will:  let l = length myLongList in (putStrLn $ show l) >> (putStrLn $ show l) run in half the time of (putStrLn $ show  length myLongList) >> (putStrLn $ show  length myLongList) or will they both essentially only iterate the spine of the list once or twice?
12:28:44 <Saizan> therp: from which package HscTypes comes from?
12:28:52 <Saizan> @messages
12:28:52 <lambdabot> edwardk said 1h 21m 41s ago: I solved my "How to make an Iteratee-based Stream instance for Parsec" problem.
12:28:53 <therp> saizan: ghc
12:29:07 <lilac> therp: have you imported Control.Monad.Trans ?
12:29:37 <therp> lilac: no, but Control.Monad.State which has liftIO too
12:29:38 <lilac> therp: i suspect you've got conflicting definitions of MonadIO (mtl versus transformers?)
12:29:57 <Saizan> therp: ok, that package is also referred as the GHC API, and being a part of ghc they probably didn't want it to depend on the mtl library
12:30:08 <therp> lilac: ah that might be the case. yes. SHM is using mtl
12:30:25 <pikhq> mxc: It depends on how smart the optimisation pass is being.
12:30:34 <therp> so liftIO != liftIO. and the MonadIO that's in the GHC package is different from the MonadIO that's in the mtl package
12:30:37 <lilac> it's not even the tarnsformers one. as Saizan says, it's using MonadIO from MonadUtils
12:30:42 <therp> the error message was just confusing me
12:30:52 <pikhq> mxc: Without optimisation, the first one will be faster than the second. With optimisation, it depends.
12:30:56 <lilac> yeah, that error message is really terrible :)
12:31:01 <therp> as I clearly have seen that GhcT IO is an instance of MonadIO
12:31:17 <lilac> i'm a little surprised that it's not an error to have multiple classes called MonadIO in scope :-/
12:31:41 <lilac> or maybe it is? you did a very restrictive import iirc
12:31:48 <Saizan> well it's never an error to have multiple identifiers with the same name in scope
12:31:58 <mxc> pikhq : so, without optimization, at least, anything in a let or where with no free variables is only executed once?  and with optimization there might be some sort of memoization in the background?
12:32:03 <Saizan> it's an error only if you use them ambiguously
12:32:06 <therp> lilac: if I go for "import HscTypes" I get an error wrt liftIO. that made it somewhat more clear
12:32:09 <lilac> as soon as you use MonadIO in a type signature i'd hope for an error
12:32:17 <leimy> Is there any reason why something of class Enum can't cycle?
12:32:18 <pikhq> mxc: Is executed at most once.
12:32:40 <pikhq> If the value is not needed, then the expression resulting in the value will not be executed.
12:32:48 <therp> lilac: thank you one more time
12:32:58 <leimy> The text I'm reading says if something is both Bounded and Enum that it should have a runtime error if you say succ maxBound
12:33:03 <lilac> therp: well, i think it was Saizan who figured it out, but no problem :)
12:33:08 <leimy> but I want it to cycle.
12:33:12 <therp> saizan: thanks!
12:33:23 <pikhq> mxc: But, basically, yeah.
12:33:27 <lilac> leimy: what should [maxBound .. minBound] do?
12:33:35 <jmcarthur_work> leimy, then is it really bounded?
12:34:01 <mxc> pikhq: thats what I meant :)  followup question - what if you have something like let a :: Reader t..  even though a has no free variables, it sort of does if the environemnt its executed under does
12:34:03 <leimy> jmcarthur_work: In a sense yes.  It has a max and min value, but in a sense no in that it cycles :-)
12:34:14 <Saizan> therp: np :)
12:34:23 <leimy> can something be both Enum and Cyclic? :-)
12:34:28 <lilac> leimy: presumably it's not an instance of Ord?
12:34:44 <leimy> lilac: I wouldn't derive Ord, no :-)
12:34:45 <mxc> say let a :: Reader Int ; a = asks length
12:35:11 <lilac> Bounded-but-not-Ord is pretty weird by itself :)
12:35:20 <leimy> lilac: yes! :-)
12:35:32 <leimy> I'm wondering if Enum + Cyclic is possible or a contradiction somehow.
12:35:38 <yrlnry> I have data Expr a = Id | Inv (Expr a) | Var a, and I want to instance Monad Expr where return = Var.   So far so good.  Also I want >>= in the obvious way, with Id >>= f  = Id, and (Inv p) >>= f = Inv (p >>= f).   But when I try to  (Var a) >>= f = Var (f a), I get a circular type error.
12:35:43 <yrlnry> What dumbass thing am I doing?
12:35:45 <c_wraith> leimy, can you make do with just cycle [(minBound::Type)..(maxBound::Type)] ?
12:36:02 <jmcarthur_work> leimy, i think Bounded and Cyclic sounds wrong
12:36:04 <c_wraith> Or is it more that you don't know where you'll be starting, and want to cycle if you exceed the max?
12:36:18 <leimy> jmcarthur_work: yes Bounded Cyclic can be wrong, but I want Enum and Cyclic
12:36:51 <leimy> c_wraith: I'm trying to implement something like a ring buffer
12:37:13 <c_wraith> @instances Ix
12:37:14 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
12:37:37 <mauke> yrlnry: the Var looks wrong. f already returns an Expr b
12:37:43 <Saizan> yrlnry: you don't want the Var constructor on the rhs
12:37:54 <yrlnry> Oh, that's it, of course.  Thanks!
12:38:13 <leimy> Ix pretty much won't work as far as I can tell
12:38:18 <yrlnry> Geez, Var (f a) doesn't even make sense.
12:38:23 <leimy> I'd need something like a CyclicIx :-)
12:39:06 <leimy> Ix has this thing called rangeSize
12:39:17 <leimy> where rangeSize(1,u) == length (range (1,u))
12:39:22 <ski> yrlnry : `Var a >>= f = f a'
12:39:26 <leimy> well for me length (range (1,u)) does not terminate :-)
12:39:43 <leimy> so I file myself under the category of "el-screwed" for "doing this correctly"
12:40:11 <ski> yrlnry : this is standard for an expression-monad (and for tree-monads with elements in leaves)
12:40:15 <leimy> It appears I'm going to have to wrap up a mutable array, and make my own interfaces.
12:40:23 <leimy> that or farm it all off to C and use FFI :-)
12:40:39 <leimy> or finally, not use haskell for this problem
12:41:02 <mauke> data Wrapped a = Plain a | Wrap (Wrapped a); type Expr a = Wrapped (Maybe a) ?
12:41:04 <kyagrd> I am learning that untyped langauges are headache for automated testing.
12:41:22 <yrlnry> ski: Yes, I knew it was going to be something foolish that would be obvious once it was pointed out.  And it is!
12:41:25 <ski> yrlnry : for `data Tree a = Leaf a | ...' it would be `Leaf a >>= f = f a' or `join (Leaf ta) = ta'
12:41:43 <kyagrd> I've never seen Erlang QuickCheck and wondering how they work.
12:41:52 <harlekin> @hoogle isNothing
12:41:52 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
12:42:14 <mauke> @. djinn type isNothing
12:42:15 <ski> yrlnry : i.e. the `Var'/`Leaf' constructor disappears on substitution (i.e. `(>>=)')
12:42:16 <lambdabot> f a =
12:42:16 <lambdabot>     case a of
12:42:16 <lambdabot>     Nothing -> False
12:42:16 <lambdabot>     Just _ -> True
12:42:46 <ski> (`(>>=)' is subtituting once)
12:46:29 <Cale> kyagrd: They end up just specifying all the type information manually, from what I understand
12:46:44 <ski> @type fix . (>=>)
12:46:46 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
12:46:53 <ski> @type let subst :: Monad m => (a -> m a) -> (m a -> m b); subst f = fix $ \loop -> ((loop . f) =<<) in subst
12:46:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m a) -> m a -> m b
12:47:25 <ski> (those are substituting away all variables, repeating)
12:48:12 <shawn--> Hi there, is there anyone know how to import the module entities automatically?
12:50:39 <shawn--> I have so many file to change, most of the modules did not point out the entities imported. How can I point out the entities explicitly automatically?
12:57:57 <yrlnry> I now have unify (Prod p q) (Prod p' q') = \v -> (unify p p' v) >>= (unify q q'), which I think is what I want, but I don't like it because of the asymmetry between the two calls to unify.  It seems to me that there is a better equivalent way to write this, but I can't quite figure out what it is.
12:58:00 <yrlnry> Any suggestions?
12:58:24 <yrlnry> Hmm, I ought to be able to figure out the expression from the type.
12:59:34 <ManateeLazyCat> How to pick integer part from Double ?
12:59:42 <mauke> hmm, unify (Prod p q) (Prod p' q') v = return v >>= unify p p' >>= unify q q'
13:00:00 <mauke> :t truncate
13:00:03 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:00:07 <mauke> ManateeLazyCat: ^
13:00:16 <ManateeLazyCat> mauke: Thanks
13:00:24 <yrlnry> Oh, okay.  I was almost there; I tried return >>= unify p q >>= unify p' q', but of course that's a type error.
13:00:25 <yrlnry> Thanks.
13:00:50 <yrlnry> But then I thought that since return is supposed to be a unit for the monad, it should be eliminable.
13:01:13 <mauke> (unify q q' =<<) . (unify p p' =<<) . return
13:01:33 <jmcarthur_work> yrlnry, unify p' q' <=< unify p q <=< return
13:01:46 <mauke> :t (>=>)
13:01:48 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:01:51 <jmcarthur_work> or >=> for left to right if that's what you want
13:01:51 <yrlnry> Where's (<=<)?
13:01:56 <jmcarthur_work> Control.Monad
13:01:57 <mauke> @index (>=>)
13:01:58 <lambdabot> bzzt
13:02:01 <yrlnry> heh.
13:03:04 <jmcarthur_work> actually... is the return even necessary?
13:03:04 <tingi>  in 2D array (NXN) (N<1000) , i'm given non-negative integers ,  if we enumerate all paths from start to end, for each path cost is the minimum of all edges in that path. Which path has the maximum cost ? i've an O(NxN * logN) solution any thing like O(NxN)
13:03:43 <shawn--> I have so many file to change, most of the modules did not point out the entities imported. How can I point out the entities explicitly automatically?
13:03:58 <mauke> yeah, that type looks like (>=>) return should be the identity
13:04:00 <jmcarthur_work> yrlnry, unify p' q' <=< unify p q   -- i think should work fine
13:04:36 <yrlnry> Thanks.
13:05:25 <jmcarthur_work> oh, besides mixing up all the arguments to unify
13:06:36 <yrlnry> Sure.
13:07:19 <yrlnry> @djinn type Maybe
13:07:19 <lambdabot> -- f cannot be realized.
13:10:33 <pikhq> mauke: That would be because of the monad laws. ;)
13:11:04 <jmcarthur_work> return <=< m == m <=< return == m
13:11:22 <jmcarthur_work> (m <=< n) <=< p == m <=< (n <=< p)
13:11:26 <jmcarthur_work> yay! :D
13:12:03 <pikhq> The monad laws are really easy to remember when put like that. :)
13:12:19 <saml> :t (<=<)
13:12:20 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:12:42 <jmcarthur_work> :t (.) -- compare <=< to
13:12:44 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:13:20 <pikhq> It's the obvious monad composition. Yay!
13:13:35 <saml> > putStrLn <=< readLine
13:13:36 <lambdabot>   Not in scope: `readLine'
13:13:54 <jmcarthur_work> that won't work
13:14:05 <jmcarthur_work> doesn't take an argument
13:14:38 <pikhq> Use the handle variant or some sort.
13:14:44 <jmcarthur_work> :t putStrLn <=< readFile
13:14:46 <lambdabot> FilePath -> IO ()
13:18:59 <jmcarthur_work> i think the monad laws are even easier to just say that (<=<,return) forms a Monoid
13:19:00 <jmcarthur_work> :)
13:19:21 <esdee> how am I supposed to indent a long list I am defining?
13:19:26 <pikhq> jmcarthur_work: Well, sure, if you know what a Monoid is.
13:19:57 <jmcarthur_work> pikhq, arguably the monoid laws are easier to memorize
13:20:05 <jmcarthur_work> and more useful since Monoid is very general
13:31:55 <ski>   [foo
13:31:57 <ski>   ,bar
13:32:00 <ski>   ..
13:32:06 <ski>   ,baz]
13:32:12 <ski> esdee : that's one way
13:32:19 <mauke> foo :
13:32:21 <mauke> bar :
13:32:23 <mauke> []
13:32:33 <ski> that's also good
13:34:54 <Berengal> [..,..] gives you free grouping, (:) might need extra parens
13:40:36 <ski> with the former, either the first or the last element has different syntax ..
13:40:37 <ski> .. thus making it not as simple to insert at beginning or end
13:40:55 <ski> s/insert/insert or remove/
13:41:24 <jmcarthur_work> mauke, ooh i haven't seen that one before
13:41:30 <jmcarthur_work> yay for not using syntax sugar
13:42:16 <dino-> Huh, I just found out that if you have a record-style data that derives Read, you can't read or reads from a non-record-style string. Interesting, I did not know that.
13:42:22 <esdee> eww, it was because the closing brace needs to be indented to the same level as the items in the list :(
13:42:55 <dino-> I had assumed since you can construct in your code either way, that the derived Read instance would work the same.
13:43:16 <Berengal> dino-: File a bug report?
13:43:16 <ski> > read "Node () []" :: Tree ()
13:43:17 <ski> > read "Node {rootLabel = (),subForest = []}" :: Tree ()
13:43:19 <lambdabot>   * Exception: Prelude.read: no parse
13:43:19 <lambdabot>   Node {rootLabel = (), subForest = []}
13:44:53 <dino-> Berengal: Sure. I can come up with a super tiny example.
13:47:40 <dino-> Can lambdabot handle data declarations?
13:48:45 <al23> Hi! What's the point of rewriting fold and map in CPS in YAHT? I'm well aware of CPS, but these examples look not so useful or pedagogical.
13:49:16 <ski> dino- : one can't add data types to lambdabot, no (except non-recursive for djinn)
13:50:01 <ski> al23 : not sure .. maybe the exercise with writing in CPS ?
13:50:17 <ski> you could ask dons or the other authors
13:51:00 <ski> (al23 : btw, would you have a link to the section in question ?)
13:51:42 <al23> http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics#Continuation_Passing_Style
13:54:44 <ski> @type let cfold' f z [] = z; cfold' f z (x:xs) = f x z (\y -> cfold' f y xs) in cfold'
13:54:45 <lambdabot> forall t t1. (t -> t1 -> (t1 -> t1) -> t1) -> t1 -> [t] -> t1
13:55:27 <ski> @type let cfold' f z [] = z; cfold' f z (x:xs) = f x z `runCont` \y -> cfold' f y xs in cfold'
13:55:28 <lambdabot> forall t a. (t -> a -> Cont a a) -> a -> [t] -> a
13:56:33 <Modius> Thoughts:  I'm more a haskell reader than writer; but "Expert F#" is the best introduction to some of the concepts (well, those shared), for someone from my perspective.  Consider it a possible "gateway language" for those making the journey.
13:59:06 <al23> Modius: a book on F# should be spoiled with .NET stuff. N'est-ce pas?
13:59:25 <ski> > let cfold' f z [] = z; cfold' f z (x:xs) = f x z `runCont` \y -> cfold' f y xs in cfold' (\n s -> return (concat ["(",s," + ",show n,")"])) "0" [1,2,3]
13:59:26 <lambdabot>   "(((0 + 1) + 2) + 3)"
14:00:01 <Modius> al23:  Well, I don't speak any French.  Just pointing out a book I found helpful in getting half-way to Haskell.
14:00:29 <Geheimdienst> does anyone have ideas on how to simplify these 3 lines? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7899#a7899
14:00:32 <Modius> al23:  I found the introduction of pattern matching and certain practical realities of good type inference useful.
14:00:37 <Geheimdienst> i cobbled that together by trial and error (i'm kind of a newbie)
14:00:53 <Modius> And no, my initials aren't J.H.
14:00:56 <Geheimdienst> it works, but i'm wondering if there's a simpler way
14:01:04 <ski> > let cfold' f z [] = z; cfold' f z (x:xs) = f x z `runCont` \y -> cfold' f y xs in (\f z l -> cfold' (\x t -> Cont $ \g -> f x (g t)) z l) (\n s -> concat ["(",s," + ",show n,")"]) "0" [1,2,3]
14:01:05 <lambdabot>   "(((0 + 3) + 2) + 1)"
14:01:08 <ski> hrm ..
14:02:42 <ski> cfold'  works like `foldl', but `cfold' mimics `foldr' via it
14:03:06 <copumpkin> centerfold :o
14:03:44 <ski> > let cfold' f z [] = z; cfold' f z (x:xs) = f x z `runCont` \y -> cfold' f y xs in (\f z l -> cfold' (\x t -> Cont $ \g -> f x (g t)) z l) (\n s -> concat ["(",show n," + ",s,")"]) "0" [1..]
14:03:45 <lambdabot>   "(1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 +...
14:03:51 <ski> though that apparently works
14:04:56 * ski would do proper CPS translations of `foldr' or `foldl' (possibly with the shortcut taken in YAHT) instead of mixing them .. at least to start with
14:05:17 <ski> (`cfold' uses not CPS but nqCPS)
14:06:15 <c_wraith> Geheimdienst:  I'm not familiar with xmonad at all.  Is that  a pair, the first part used to match some user input, the second part containing the action to take when the user provides that input?
14:07:28 <al23> Modius: I think every good book on an ML-kind language could be useful. Except for strict evaluation-related things, of course. IMHO SML should be much better than F# for a newcomer.
14:07:38 <dino-> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7901#a7901
14:09:12 <Geheimdienst> c_wraith: yes, sorry for not specifying. you can ignore the first tuple, it's just the keyboard shortcut. i meant if it's possible to simplify the monad back and forth: W.view =<< (currenttag >>= (\x -> ...)))
14:09:26 <c_wraith> Geheimdienst:  Is it all in the same monad?
14:09:55 <dschoepe> Geheimdienst: you can also ask in #xmonad, since you appear to be writing xmonad code
14:10:24 <Geheimdienst> dschoepe: yes, that would have been smarter :-/
14:11:03 <c_wraith> At the very least, you can use a do block to bind x with the <- operator instead of using a lambda for it
14:11:21 <leimy> > zipWith (++) (tails "Hello") (inits "Hello")
14:11:23 <c_wraith> If it's all the same monad, you can put the whole thing into a do block
14:11:23 <lambdabot>   ["Hello","elloH","lloHe","loHel","oHell","Hello"]
14:12:23 <leimy> > zipWith (++) (inits "Hello") (tails "Hello")
14:12:24 <lambdabot>   ["Hello","Hello","Hello","Hello","Hello","Hello"]
14:13:23 <leimy> > reverse $ zipWith (++) (tails "Hello") (inits "Hello")
14:13:25 <lambdabot>   ["Hello","oHell","loHel","lloHe","elloH","Hello"]
14:13:42 <dschoepe> Well all of that is actually in the ((->) e) monad so I find the use of =<< in there rather confusing than helpful.
14:13:42 * ski annotated hpaste #7899 with "any improvement ?" at <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7899#a7902>
14:13:47 <leimy> that basically represents all the different ways of writing "Hello" into a fixed size ring buffer :-)
14:13:55 <Geheimdienst> c_wraith: ok it's the same monad *if* i'm reading this correctly: http://xmonad.org/xmonad-docs/xmonad/XMonad-StackSet.html#v%3Aview and http://xmonad.org/xmonad-docs/xmonad/XMonad-StackSet.html#v%3AcurrentTag
14:13:56 <ski> Geheimdienst : ^
14:14:16 <ski> hm
14:14:32 * ski wonders why all appears to be on a single line
14:14:38 <c_wraith> that's... impressive, ski
14:14:52 <c_wraith> I certainly can't tell if it's an improvement. :)
14:15:16 <ski> when i previewed it and saved it, it was on separate lines
14:15:42 <c_wraith> That's basically what my first suggestion was.
14:16:33 <dschoepe> Geheimdienst: Another possibility: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7899#a7903
14:16:34 <Geheimdienst> don't worry, i copy-pasted it in my file and inserted
14:16:38 <Geheimdienst> the linebreaks
14:16:57 <ski>   , ((modm, xK_space)
14:17:01 <ski>     ,windows $ W.view =<< do
14:17:06 <ski>        x <- W.currentTag
14:17:09 <ski>        if x == scratchWorkspace
14:17:15 <ski>           then W.tag . head . W.hidden
14:17:16 <ski>           else return scratchWorkspace)))
14:17:21 <ski> s/)))/)/
14:17:51 <ski> if you want, you could move the `W.view =<<' inside the `do'-block, as well
14:19:08 <dschoepe> Geheimdienst: Oh, You'd have to replace "foo" by scratchWorkspace, I wanted to see whether it'd type checked.
14:19:31 <Geheimdienst> dschoepe: woah cool, it works. thanks. that's clearly simpler than what i had
14:19:45 <Geheimdienst> ok ski, i'm trying that now
14:20:22 <dschoepe> Geheimdienst: Well the code wasn't really in "conventional" monad, so =<< looked awkward there.
14:20:33 <dschoepe> *in a
14:21:08 <esdee> I have a case where I have a list of "things", and each thing has a list of elements associated with it, there's only 8 possible elements and each "thing" can have 1 or more.  Is there a more approriate datatype I should use than an assoc list of string -> [string]?
14:21:55 <ski> Geheimdienst : dschoepe's idea is (possibly) better .. i missed the `(rho ->)' monad
14:22:26 <ski> (if you don't want to write `ws' all the time, then something like my version should be ok)
14:22:56 <dschoepe> @pl \x -> f (g x) x
14:22:57 <lambdabot> f =<< g
14:23:21 <ski> @pl \x -> f x (g x)
14:23:22 <lambdabot> ap f g
14:25:16 <Geheimdienst> dschoepe: i know so little about this weird language, i expect everything i do to be awkward ;-)
14:26:00 <Geheimdienst> ski: how do i do that exactly -- pull the windows $ W.view into the do block?
14:27:54 <ski>     ,windows $ do
14:28:00 <ski>        x <- W.currentTag
14:28:22 <ski>        y <- if x == scratchWorkspace
14:28:22 <ski>                then W.tag . head . W.hidden
14:28:24 <ski>                else return scratchWorkspace
14:28:37 <ski>        W.view y)
14:28:42 <ski> like that
14:28:55 <c_wraith> And probably wise to give them more descriptive names than x and y.  :)
14:29:06 <Geheimdienst> woah!
14:29:10 <ski> yes (but i have no idea what they are, so .. :)
14:29:32 <c_wraith> Yeah, it's amazing how close to imperative haskell can look if you try.  :)
14:29:41 <Geheimdienst> (and you think i have more of an idea what these things are ...?) ;-)
14:30:27 <dschoepe> ski: fwiw, they are workspace names
14:30:52 <Geheimdienst> i named them src and dst, guess that will do
14:30:53 <ski> ic
14:32:02 <ski> (btw, i used a monad law to be able to move `W.view' that way .. if you feel like, you can try to spot which and where/how)
14:36:34 <voker57_> http://codepad.org/C1t4309j
14:37:06 <voker57_> and it complains about No instance for (Stream s m Char) arising from a use of `string'
14:38:31 <Saizan> voker57_: if you use parsec3 you need to either give type signatures to your parsers or use {-# LANGUAGE NoMonomorphismRestriction #-}
14:38:41 <Geheimdienst> ski: hm, i can't tell. what monad law is it?
14:39:14 <ski> Geheimdienst : the associative one
14:39:51 <ski>     W.view =<< do x <- foo; bar x
14:40:09 <ski>   = do y <- (do x <- foo; bar x); W.view y
14:40:16 <voker57_> Saizan: thanks
14:40:36 <ski>   = do x <- foo; y <- bar x; W.view y   -- using associative law
14:42:41 <ski> (that last is (more or less) syntactic sugar for `do {x <- foo; do {y <- bar x; W.view y}}' ..)
14:44:06 <dschoepe> Geheimdienst: Don't worry if you don't understand what ski's saying about monad laws, if you don't really know about monads yet(besides "things that allow you to use do-notation"). It is not needed to be able to merely use monads
14:46:30 <Geheimdienst> well, i'm trying to learn ... what ski is saying sounds logical to me, and the wiki page on the laws is, hm, slightly comprehensible to me
14:48:09 <ski> what the "associative" monad law is saying is basically that these two are the same : (a) first do `foo' and `bar', then do `baz' ; (b) first do `foo', then do `bar' and `baz'
14:48:34 <Geheimdienst> but still, to me, ghc is so bitchy. what you guys are writing just works. i swear, you must be bribing the compiler or something
14:49:04 <monochrom> We kissed up the compiler.
14:49:25 <ski> @ghc
14:49:26 <lambdabot> ghc says: eval_thunk_selector: strange selectee
14:49:27 <mkaemmer> Geheimdienst: try ghc -XPrettyPlease
14:49:39 <mauke> ghc -fignore-errors
14:49:46 <QP> can anyone explain the following error message to me---chat2.hs: <socket: 10>: hGetChar: invalid argument (Bad file descriptor)  ?
14:50:03 <QP> i can't work out which function is producing it
14:50:04 <ski>  -fdynamic-typing
14:50:13 <shachaf> QP: hGetChar, most likely. :-)
14:50:17 <dschoepe> QP: one that calls hGetChar
14:50:22 <blackdog> -fDWIM
14:50:31 <QP> i don't call that
14:50:45 <shachaf> Maybe @paste?
14:50:47 <dschoepe> QP: do you call hGetLine or anything build from hGetChar?
14:50:52 <dschoepe> *built
14:50:54 <shachaf> This is a little vague. :-)
14:50:59 <QP> hGetLine, yess...
14:51:01 <QP> but
14:51:14 <QP> it shouldn't be getting called at that point...
14:51:57 <monochrom> Then it is getting called at that point. Especially since invalid argument, i.e., invalide Handle.
14:52:15 <dschoepe> QP: you might want to ask the ghci debugger for help
14:52:24 <QP> i changed the code so that the thread calling hGetLine is killed before the handle is closed
14:52:31 <QP> i think...
14:52:42 <monochrom> Clearly it is not killed then.
14:53:06 <QP> well killThread sounds pretty unambiguous to me?
14:53:08 <mkaemmer> QP: is there another way to do what you're trying to do?
14:53:31 <mkaemmer> QP: relying on your threads to interleave the right way is not so good
14:53:55 <monochrom> When does killing happens is ambiguous. Whether execution reaches that killThread call is ambiguous.
14:54:08 <QP> well, i'm writing a server program that handle multiple connections
14:54:24 <QP> and i want a way of closing connections
14:54:42 <dschoepe> monochrom: well, shouldn't killThread foo >> hClose handle ensure that it is run _before_ hClose at least?
14:55:10 <QP> so terminate :: Int -> Server () and terminate n should close the nth connection
14:55:24 <QP> dschoepe: that's pretty much what i have
14:56:01 <QP> but terminate needs to kill two threads---the recieving one and the sending one
14:56:43 <dschoepe> QP: mapM_ killThread [sender,receiver]?
14:58:30 <QP> at the moment, Server () doesn't contain the handles for each connection
14:59:01 <QP> so terminate has to send a special 'kill word' through the channel connecting the different threads
15:00:29 <QP> but surely killThread th >> hClose h always means the thread is killed before the handle is closed?
15:01:07 <mkaemmer> QP: Is there anywhere else hClose could be called?
15:02:08 <QP> no, that's the only place it appears in the file
15:02:10 <wgsilkie> @catch
15:02:11 <lambdabot> Unknown command, try @list
15:02:18 <wgsilkie> @error
15:02:18 <lambdabot> Unknown command, try @list
15:02:22 <wgsilkie> @list
15:02:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:02:26 <wgsilkie> @src eror
15:02:27 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:03:03 <QP> mkaemmer: so the error is caused by calling hGetChar on a handle that is closed?
15:03:34 <dschoepe> QP: or otherwise invalid, but closed seems to be the most likely candidate in this case
15:03:41 <QP> ok
15:03:58 <uzytkownik> Hello. Is there any simple way of changing the "\r\n." into "\r\n.." in lazy bytestring?
15:05:27 <dschoepe> uzytkownik: You could build a replace function from the ByteString variants of list functions
15:06:01 <wgsilkie> > do catch (error "Crud!") (\err -> return ("Error: "++(show err))
15:06:03 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:06:23 <wgsilkie> Why doesn't that work?
15:06:37 <mauke> unmatched (
15:06:46 <dschoepe> wgsilkie: you'd have to use errorIO for catch to work
15:06:57 <mauke> wgsilkie: which catch is that?
15:06:57 <dschoepe> ioError that is
15:07:36 <dschoepe> by the way, your example is lacking a parentheses
15:07:48 <wgsilkie> > do catch (ioError "Crud!") (\err -> return ("Error: "++(show err))
15:07:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:08:05 <wgsilkie> Hmmm.....
15:08:07 <dschoepe> > do catch (ioError "Crud!") (\err -> return ("Error: "++(show err)))
15:08:09 <lambdabot>   Couldn't match expected type `GHC.IOBase.IOException'
15:08:17 <dschoepe> @type catch
15:08:21 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
15:09:24 <wgsilkie> So is exception handling something that isn't normally done in Haskell?
15:09:48 <wgsilkie> That is, something that isn't much of an concern?
15:09:57 <dschoepe> wgsilkie: You just need to wrap "Crud" in a IOError constructor
15:10:16 <mike-burns> wgsilkie: I see it a lot less than in, say, Java. But that's because of the existence of Either and Maybe I suspect.
15:10:24 <wgsilkie> Ah.
15:10:26 <mauke> > catch (fail "Crud!") (\err -> return ("Error: "++(show err)))
15:10:29 <lambdabot>   <IO [Char]>
15:10:47 <dschoepe> @src fail
15:10:48 <lambdabot> fail s      = error s
15:11:03 <dschoepe> wgsilkie: you possibly want userError instead
15:11:09 <xenoblitz> > groupBy (\x1 x2 -> x1 == x2 - 1) [1,2,3,6,7]
15:11:11 <lambdabot>   [[1,2],[3],[6,7]]
15:11:16 <wgsilkie> dschoepe: Ah, thanks!
15:11:24 <xenoblitz> is there any way I can group the 3 with [1,2]?
15:11:38 <dschoepe> (in addition, not instead, I should read more carefully before responding)
15:12:06 <dschoepe> but fail in the IO monad is ioError . userError, I believe
15:15:45 <flazz> does Yi have internal documentation? if so how do i access it?
15:15:57 <skorpan> it does not
15:24:09 <doublethink_work> flazz: you can try running haddock over the source code
15:24:26 <flazz> thanks
15:24:34 <labo> @search unsafePtrEq
15:24:35 <lambdabot> Unknown command, try @list
15:24:37 <doublethink_work> i haven't built the yi HEAD repo in a long time, but there've been a lot of fixes/additions w.r.t the haddock documentation
15:24:43 <labo> @list
15:24:43 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:24:49 <doublethink_work> (it's maybe been 3 months?)
15:25:21 <doublethink_work> for yi the darcs repo is the way to go anyway - jpb is constantly pushing tiny tweaks and bug fixes to the code base
15:25:32 <labo> @type unsafePtrEq
15:25:34 <lambdabot> Not in scope: `unsafePtrEq'
15:26:07 <doublethink_work> labo: lambdabot does not keep track of  GHC primops and internal GHC functions etc
15:26:08 <copumpkin> reallyUnsafePtrEq is what it's called
15:26:16 <copumpkin> @hoogle reallyUnsafePtrEq
15:26:16 <lambdabot> No results found
15:26:20 <doublethink_work> at least I don't think it does
15:26:33 <uzytkownik> dschoepe: Thanks. I'll see it.
15:26:52 <labo> doublethink_work: I tried hoogle and it didn't find anything
15:26:56 <copumpkin> someone should make a haskell quiz!
15:27:07 <labo> so I though to give lamdabot a try
15:27:09 <labo> t
15:27:13 <doublethink_work> hi copumpkin!
15:27:17 * doublethink_work = thoughtpolice, but at work
15:27:17 <copumpkin> ohai doublethink_work
15:27:37 <doublethink_work> thoughtpolice_work got truncated because freenode doesn't like long names :(
15:27:43 <copumpkin> lol
15:27:47 <copumpkin> gotta run
15:27:56 <copumpkin> have fun doublethinking at work :D
15:29:16 <ufopp> Have a newbie question
15:30:21 <ufopp> I have a cmd utility that uses getline, what's the fastest way to test for the first two characters? I want to build a dispatch based on the two characters.
15:30:23 <uzytkownik> dschoepe: Well. Bytestring list functions seems to not taking into account multi-byte elements...
15:30:52 <shachaf> ufopp: "fastest"?
15:31:08 <shachaf> Slightly mor context would be helpful. :-)
15:31:12 <ufopp> quickest, as the line could be longer than 255 char
15:31:47 <dschoepe> ufopp: case take 2 foo of "ab" -> foo;  "cd" -> bar;...
15:31:54 <blackdog> ufopp: if it's a lazy bytestring or string, just look at the first two characters - it won't eval more than it needs to.
15:32:20 <ufopp> thx, let me try
15:32:21 <shachaf> blackdog: Are you sure about that? Doesn't getLine "eval" the whole thing?
15:32:50 <blackdog> shachaf: hm. wouldn't have thought so, but data trumps supposition, right?
15:33:10 <dschoepe> uzytkownik: well the simplest way, would be to recursively check with isPrefixOf and replace if it matches. Not very efficient though
15:34:00 <blackdog> ufopp: also, remember knuth's laws of optimisation
15:34:03 <mike-burns> How about pattern matching on the first two elements?
15:34:23 <shachaf> blackdog: Well, it's not like getContents, as far as I know, if that's what you mean.
15:34:32 <uzytkownik> dschoepe: Is there any bug tracker of Haskell features? It's rather basic element present in 99%of moder languages...
15:35:30 <bohdan> hi
15:35:34 <shachaf> uzytkownik: When you say Haskell do you mean GHC?
15:35:45 <dschoepe> uzytkownik: Yes, there's a Data.List.Split package
15:36:03 <bohdan> what's the right way to write (, 1) ?
15:36:11 <shachaf> \x -> (x,1)
15:36:13 <mauke> flip (,) 1
15:36:29 <bohdan> @pl \x -> (x,1)
15:36:29 <lambdabot> flip (,) 1
15:36:30 <uzytkownik> mike-burns: I tried but still I get somehow lost. Now I simplified a problem and I'll try again. Anyway - regex seems a bit too heavy.
15:37:05 <mike-burns> uzytkownik: I didn't mean a regexp pattern match; I meant treating the string like a list and doing a data structure pattern match.
15:37:06 <uzytkownik> shachaf: Should I post a haskell library extention to ghc trac?
15:37:13 <dschoepe> uzytkownik: with that you could split by sublists and use intercalate to replace. it doesn't work for bytestring yet
15:37:19 <bohdan> thanks, shachaf and mauke :)
15:37:20 <dschoepe> s/yet//
15:37:43 <shachaf> uzytkownik: I think I'm missing some context. :-) You said "Haskell features".
15:38:04 <uzytkownik> mike-burns: It's bytestring but I can convert it to list
15:38:25 <mike-burns> uzytkownik: Ah nevermind then; other people will have better ideas for a ByteString.
15:38:42 <Saizan> uzytkownik: if you want unicode support over arrays of bytes use the text library
15:39:06 <dschoepe> shachaf: I believe, his point is that there's no replace function in the standard libraries.
15:39:12 <Saizan> uzytkownik: bytestring uses the simplistic approach to assume latin1 as encoding
15:39:34 <Saizan> ?hackage text
15:39:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text
15:39:58 <Saizan> @hackage utf8-string
15:39:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
15:40:01 <Saizan> also relevant
15:41:34 <uzytkownik> Saizan: Well. Since I threat it as binary data (standard states that I have to escape certain octets) I prefer ByteString as it is wider supported.
15:42:36 <ufopp> blackdog: what's Kunth's law you refer to?
15:42:52 <blackdog> shachaf: you were quite right, my apologies.
15:42:58 <Saizan> uzytkownik: so it's a problem oh having text in something like the haskell-platform?
15:43:01 <blackdog> ufopp: first law is "Don't optimise"
15:43:11 <blackdog> ufopp: second law, for experts only:
15:43:14 <blackdog> "don't optimise yet"
15:43:29 <mike-burns> "premature optimization is the root of all evil."
15:43:58 <blackdog> very few people know that the destruction of Sodom was actually down to an unrolled inner loop
15:44:40 <c_wraith> What'd they do in Gomorrah?
15:44:49 <uzytkownik> Saizan: Don't get me wrong. Encoding support *is* important. It's just not needed in my case. I need to escape certain octets, which 'by accident' are carriage return, new line and dot in ascii/latin/utf-8 etc.
15:44:51 <ufopp> blackdog: can't run the app without getting past the first stage; I need to process about 100 lines every second in this realtime application. I'm trying to mimic my c program to learn Haskell.
15:44:57 <skorpan> c_wraith: goto
15:45:57 <uzytkownik> Saizan: Especially that taking text into platform will get it much wider addoption. I'm looking forward to this point. I'm just having a binary data.
15:46:07 <Saizan> uzytkownik: i'm not sure how you can consider the issue of multibyte "elements" distinct from encoding
15:47:06 <blackdog> ufopp: sure. but performance in haskell is often sort of unintuitive. the easiest way seems to be to get a slow version running first then work out where the hot spots are. unless you're running on an extremely limited machine or are doing an extraordinary amount of computation on each line, 100 lines of input a second should be no problem...
15:47:34 <Saizan> uzytkownik: or maybe i'm totally misunderstanding the problem :)
15:48:02 <uzytkownik> Saizan: Well. Let's say I need to change 0D.0A.2E into 0D.0A.2E.2E (. represents separation of octets)
15:48:58 <uzytkownik> Saizan: 1. It can be in any encoding. It can be even a binary 2. Those octets are invariant weather it is ascii, latin or utf-8
15:50:02 <ufopp> blackdog: 100 lines is not the problem, it's the processing of each line. Some take longer than a second. I want the haskell front to dispatch to various subprograms ASAP so the queues don't get backed up. Anyway, Knuth's law has it's place though. I get the point.
15:50:03 <Saizan> uzytkownik: what's the feature you lack to do that then?
15:53:06 <uzytkownik> uzytkownik: Search/Search&replace in lists (as ByteString follows List API which in some cases does not make much sense as to some extend it is different then Lists).
15:53:13 <uzytkownik> Oops.
15:53:21 <uzytkownik> Saizan: Search/Search&replace in lists (as ByteString follows List API which in some cases does not make much sense as to some extend it is different then Lists).
15:53:56 <uzytkownik> Saizan: I'll play around strstr from C.
15:54:38 <blackdog> ufopp: so you won't have to read the rest of the line in some cases? or you'd like to continue reading the line in another thread in order not to block the main dispatcher?
15:56:45 <ufopp> blackdog: yes; about 10% of the lines I just log and ignore, but the other 90% have to go elsewhere.
16:06:31 <blbrown_win_> to use gtk2hs, I have to have that exact version of ghc.  That seems strange
16:06:34 <blbrown_win_> is this correct?
16:07:05 <Saizan> that's true for the binary distribution of gtk2hs
16:07:42 <Saizan> mostly because that's true for all binary distributions of GHC compiled libraries, currently
16:08:38 <blbrown_win_> Saizan, you think the source will work (gtk2hs, win32)
16:11:16 <Saizan> blbrown_win_: it should if you can setup your environment correctly for the build, which will require msys on windows i think
16:11:34 <Saizan> and the gtk develoment files
16:11:56 <blbrown_win_> darn
16:13:30 <copumpkin> doublethink_work: you're always at work! take some time off!!!
16:13:31 <copumpkin> :P
16:29:42 <hackagebot> xdg-basedir 0.1 - A basic implementation of the XDG Base Directory specification. (WillDonnelly)
16:59:54 <hackagebot> xdg-basedir 0.2 - A basic implementation of the XDG Base Directory specification. (WillDonnelly)
17:04:13 <jmcarthur> @seen gwern
17:04:14 <lambdabot> gwern is in #haskell, #xmonad and #darcs. I last heard gwern speak 6h 5m 41s ago.
17:13:57 <hackagebot> io-storage 0.3 - A key-value store in the IO monad. (WillDonnelly)
17:19:50 <ziman> @hoogle [(a,a)] -> ([a],[a])
17:19:51 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
17:19:51 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
17:19:59 <ziman> oh :)
17:25:02 <Plouj> hola
17:25:19 <Plouj> I have a question about a text in the Real World Haskell book
17:26:02 <Plouj> "For convenience, the bytestring library provides two other modules with limited text I/O capabilities, Data.ByteString.Char8 and Data.ByteString.Lazy.Char8. These expose individual string elements as Char instead of Word8" - What benefit does Word8 have over Char? How do those compare (what are the actual sizes in bits)?
17:26:20 <c_wraith> Char is unicode
17:26:59 <Plouj> ok, previous chapter says Word8 is 8 bits
17:27:08 <Plouj> how big is Char?
17:27:14 <c_wraith> > (fromIntegral maxBound::Char)::Integer
17:27:16 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
17:27:34 <c_wraith> Well, it supports all the unicode codepoints
17:27:40 <c_wraith> which means 32 bits, probably
17:27:47 <c_wraith> But really, don't worry about it.
17:27:51 <c_wraith> Just know that it's unicode
17:27:55 <Plouj> k
17:28:23 <Plouj> the thing is that a huge example in chapter 10 uses Char8
17:28:26 <Plouj> and I was wondering why
17:28:32 <Plouj> I guess because it provides a fixed known size
17:32:33 <dons> Plouj: what's your question?
17:32:47 <xenoblitz> can anyone help me with this little problem here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7909#a7909
17:35:33 <Botje> i'd probably use unfoldr somehow
17:36:48 <Saizan> > break (\(a,b) -> b == a + 1) . ap zip tail $ [1,2,3,6,7,8,11,12]
17:36:50 <lambdabot>   ([],[(1,2),(2,3),(3,6),(6,7),(7,8),(8,11),(11,12)])
17:36:51 <c_wraith> xenoblitz:  While this is totally not related to what you're asking, you have some redundancy in your recursive definition for group
17:36:56 <Saizan> > span (\(a,b) -> b == a + 1) . ap zip tail $ [1,2,3,6,7,8,11,12]
17:36:58 <lambdabot>   ([(1,2),(2,3)],[(3,6),(6,7),(7,8),(8,11),(11,12)])
17:37:19 <Saizan> > first (map fst) . span (\(a,b) -> b == a + 1) . ap zip tail $ [1,2,3,6,7,8,11,12]
17:37:21 <lambdabot>   ([1,2],[(3,6),(6,7),(7,8),(8,11),(11,12)])
17:37:31 <Saizan> uhm no
17:37:49 <xenoblitz> c_wraith: feel free to point out the redundancy :)
17:38:23 <aavogt> @type zip <*> tail
17:38:24 <lambdabot> forall b. [b] -> [(b, b)]
17:38:26 <xenoblitz> Saizan: I honestly don't know how you guys write so many definitions so quickly without thinking for long
17:39:10 <aavogt> do people actually use that 'trick' freuqently in real code?
17:39:32 <Saizan> aavogt: i don't know, but it's become an idiom here on #haskell
17:39:38 <Saizan> @quote aztec
17:39:38 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
17:39:43 <Plouj> dons: chapter 8 introduced Data.ByteString.Lazy.Char8 functions operating on Word8 without explaining why someone would want to use that instead of Char
17:40:17 <dons> sometimes you want to view binary data as bytes, not characters
17:40:28 <dons> sometimes treating it as ascii is right. so we provide both views
17:40:40 <monochrom> zip `ap` tail is now zip <*> tail :)
17:40:40 <Botje> unfoldr (\l -> if null l then Nothing else Just $ span (uncurry (==) $ zip l [head l..]) [1,2,3,6,7,8,10,11,12]
17:40:43 <Botje> > unfoldr (\l -> if null l then Nothing else Just $ span (uncurry (==) $ zip l [head l..]) [1,2,3,6,7,8,10,11,12]
17:40:45 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:40:48 <Botje> phew.
17:40:54 <Botje> if that worked at first try i'd be scary
17:40:57 <Saizan> xenoblitz: heh, it's a matter of getting used to the combinators :)
17:41:55 <Saizan> xenoblitz: your group would probably look much nicer if written with guards instead of if/then/else
17:42:08 <xenoblitz> Saizan: ok let me re-write it
17:42:11 <aavogt> @hoogle Applicative f => (a -> b -> f c) -> [a] -> [b] -> f [c]
17:42:11 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
17:42:11 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
17:42:11 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
17:43:05 <Botje> xenoblitz:
17:43:06 <Botje> unfoldr (\l -> if null l then Nothing else Just $ (map fst *** map fst) $ span (uncurry (==)) $ zip l [head l..]) [1,2,3,6,7,8,10,11,12,19]
17:43:10 <Botje> > unfoldr (\l -> if null l then Nothing else Just $ (map fst *** map fst) $ span (uncurry (==)) $ zip l [head l..]) [1,2,3,6,7,8,10,11,12,19]
17:43:12 <lambdabot>   [[1,2,3],[6,7,8],[10,11,12],[19]]
17:43:25 <Botje> that can probably be improved a bit :P
17:43:58 <Saizan> > unfoldr (\l -> do guard (not . null $ l); (map fst *** map fst) $ span (uncurry (==)) $ zip l [head l..]) [1,2,3,6,7,8,10,11,12,19]
17:44:00 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a1, [a])'
17:44:14 <Saizan> > unfoldr (\l -> do guard (not . null $ l); return $ (map fst *** map fst) $ span (uncurry (==)) $ zip l [head l..]) [1,2,3,6,7,8,10,11,12,19]
17:44:16 <lambdabot>   [[1,2,3],[6,7,8],[10,11,12],[19]]
17:44:39 <xenoblitz> Botje: wow and ... that's greek to me xD
17:45:11 <edwardk2> @seen saizan
17:45:12 <lambdabot> saizan is in #kata, #haskell-in-depth, #ghc, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard saizan speak 57s ago.
17:45:25 <edwardk2> doh
17:45:26 <Saizan> it's a bit wasteful to build up those tuples just to discard them, but hey
17:45:32 <Saizan> edwardk2: pong
17:46:01 <xenoblitz> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7909#a7911
17:46:06 <edwardk2> Saizan: mind taking a look at that iteratee-based stream? it seems to be acting funny, so i obviously wired it up wrong (setting up laptop, one sec)
17:46:13 <xenoblitz> still ... and I thought my exercise was quite a simple one
17:47:17 <Saizan> edwardk2: sure, if i can help
17:48:48 <edwardk2> Saizan: it looks like i wired up the way to pass forward the buffer set wrong somehow because the second monadic action is just seeing EOF
17:48:50 <Saizan> xenoblitz: the main problem is that there isn't a good combinators in Data.List for checking predicates like that
17:48:54 <xenoblitz> Saizan, Botje: I'll save your version but its going to take me awhile to understand it full :) PS if there is really redundancy in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7909#a7911 please let me know where :)
17:49:45 <Botje> x1:[] better written as [x1]
17:50:24 <Botje> your groupRegions can be written as an unfoldr
17:50:45 <xenoblitz> Botje: ok I'll try that :)
17:52:06 <xenoblitz> Botje: and why is [x1] better than x1:[] ? is it performance issues or simply readability?
17:52:47 <Botje> readability
17:55:33 <c_wraith> It's also fewer bytes of source!
17:55:40 <Botje> i guess :p
17:55:52 <xenoblitz> :)
17:56:03 <aavogt> > 1+1:[]
17:56:06 <lambdabot>   [2]
17:56:30 <edwardk2> Saizan: almost there, had to reboot the machine =/
17:57:24 <Saizan> xenoblitz: btw, i think the whole group (x1:x2:[]) case is redundant
17:58:12 <xenoblitz> Saizan: probably I'll check it out
17:58:57 <Saizan> actually it seems wrong, group [1,3] == ([1],[])
18:00:15 <xenoblitz> Saizan: I'll remove it then
18:02:10 <xenoblitz> believe it or not I am still trying to figure out how to use unfoldr, and to be honest I hadn't heard of it before
18:02:28 <Saizan> ?type unfoldr
18:02:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:03:15 <Saizan> unfoldr let you build up a list in an iterator style
18:03:26 <Saizan> 'b' is the seed
18:03:44 <aavogt> > groupBy (const $ (1==) . uncurry subtract) $ ap zip tail $ [1,2,3,6,7,8,10,11,12,19]
18:03:46 <lambdabot>   [[(1,2),(2,3)],[(3,6),(6,7),(7,8)],[(8,10),(10,11),(11,12)],[(12,19)]]
18:03:46 <Saizan> and the function produces an element of the list and a new seed to use for the next iteration
18:04:01 <aavogt> > map fst $ groupBy (const $ (1==) . uncurry subtract) $ ap zip tail $ [1,2,3,6,7,8,10,11,12,19]
18:04:02 <lambdabot>   Couldn't match expected type `(a, b)'
18:04:26 <aavogt> > map (map fst) $ groupBy (const $ (1==) . uncurry subtract) $ ap zip tail $ [1,2,3,6,7,8,10,11,12,19]
18:04:27 <lambdabot>   [[1,2],[3,6,7],[8,10,11],[12]]
18:04:47 <Saizan> so you can e.g. use it to produce the list of natural numbers like these
18:05:10 <Saizan> > unfoldr (\s -> Just (s,s+1)) 0
18:05:12 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:05:26 <aavogt> > iterate succ 0
18:05:27 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:05:39 <xenoblitz> > [0..]
18:05:40 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:05:43 <xenoblitz> :P
18:05:59 <xenoblitz> thanks Saizan :)
18:06:01 <Saizan> the difference with iterate is that you can return Nothing to end the list
18:06:26 <Saizan> in your groupRegions the seed is the input list
18:07:40 <xenoblitz> Saizan: so far I wrote  groupRegions xs = unfoldr (\xs1 -> if xs == [] then Nothing else Just group xs1) xs
18:08:41 <Saizan> xenoblitz: you want "xs1 == []" or better "null xs1" there
18:09:05 <edwardk2> Saizan: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3160
18:09:13 <Saizan> and you need to use parentheses around group xs1
18:10:24 <xenoblitz> Saizan: thanks it worked :)
18:10:32 <edwardk2> Saizan: if you load that with ghci Iteratee, then :m + Text.Parsec, and execute: supply EOF $ supply "AB" runParserT (char 'A' >> char 'B') () "-" (Cursor 0)
18:10:38 <edwardk2> it bombs on the second character
18:10:50 <edwardk2> my apologies for all the trace noise
18:11:04 <edwardk2> er woops
18:11:11 <edwardk2> and the fact that my vim mangled the symbols, one sec
18:11:17 <Saizan> yeah :)
18:12:36 <edwardk2> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3160#a3161
18:13:57 <edwardk2> er supply "AB" $ runParserT ...
18:14:41 <edwardk2> it seems like what i'm doing to feed the buffer forward is making it so that the second action is seeing no buffer
18:15:58 <edwardk2> uncons just uses an integer to index into the buffer set and i try to grow the buffer set when i'm given new ones
18:17:58 <Saizan> reading
18:19:10 <zoheb> Has anyone tried haskell mode with emacs 23.1 on windows? doesn't seem to work for me. emacs 22.3 works fine
18:20:00 <edwardk2> Saizan: the monad from the 18th page of http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3160#a3161 and the implementation of snext on the 16th page might be handy
18:20:57 <edwardk2> er woops wrong link =)
18:21:02 <edwardk2> http://okmij.org/ftp/Haskell/Iteratee/DEFUN08-talk.pdf
18:21:45 <edwardk2> it seems that i am getting the new cursor, back for the second round, but the buffer isn't there to be read
18:23:22 <Saizan> edwardk2: isn't it because you use return in uncons'?
18:23:31 <Saizan> edwardk2: which propagates an empty buffer
18:23:37 <edwardk2> Saizan: smaller test case: supply "A" $ uncons (Cursor 0)
18:23:40 <Saizan> edwardk2: rather than the rest of the current one
18:23:56 <edwardk2> distinctly possible, my brain wigged out on parsing what i wrote =)
18:24:32 <jaredj> @faq htags
18:24:32 <lambdabot> The answer is: Yes! Haskell can do that.
18:24:40 <jaredj> oh good
18:24:45 <edwardk2> ah, trying that
18:25:13 <Saizan> edwardk2: so i guess you should use Done directly
18:25:17 <edwardk2> yeah
18:25:22 <edwardk2> that worked
18:25:54 <edwardk2> Done (do ix ← index n h; return (ix, succ n)) h eof -- works beautifully for the n < measure h case
18:26:35 <edwardk2> and the second case really should return Nothing, because we can't proceed
18:26:43 <edwardk2> and the third is already explicitly constructed
18:26:48 <edwardk2> so it was the n < measure h case
18:27:15 <edwardk2> and now parsec seems to be working
18:27:41 <roconnor> http://www.reddit.com/r/programming/comments/97szq/functional_refactoring_and_you_cant_get_there/
18:27:56 <edwardk2> nice, backtracking, more complicated parsers, etc. all good
18:29:04 <edwardk2> erf, still buggy, but now its just me trying to index something improperly. looks like my takeUntil was malformed
18:29:27 <BMeph> Just curious: is there any kind of tutorial/"helpful hints" for how to use haddock w/ Cabal?
18:29:29 <jaredj> so when i try to cabal install htags, it tries to install haskell-src, which fails to install happy
18:29:34 <jaredj> but i just cabal installed happy
18:30:00 <jaredj> now haskell-src is building. odd
18:30:25 <jaredj> BMeph: the "how to make a hackage project" tut had something on it; i haven't gotten there yet though :)
18:30:27 <Saizan> BMeph: i don't think so, but maybe you could ask here?
18:31:38 <Saizan> jaredj: cabal-install doesn't automatically installs build-tools for you, yet
18:31:50 <Saizan> it needs someone to go and implement that part
18:32:54 <Saizan> BMeph: i've rewritten the .Haddock module in Cabal recently so you've someone to blame if things are buggy :(
18:33:01 <Saizan> *:)
18:33:37 <Saizan> (but that code is only in the 1.7 branch, probably)
18:35:32 <roconnor> "32MB" < "2GB"
18:35:35 <roconnor> > "32MB" < "2GB"
18:35:37 <lambdabot>   False
18:35:43 <BMeph> Saizan: Well, of course it is! ;p
18:36:16 <BMeph> > "32" > "4"
18:36:18 <lambdabot>   False
18:40:22 <Saizan> edwardk2: how do you find Iteratee? it seems like it doesn't have a well defined interface to me, or maybe i've just not built a proper mental model for it
18:40:36 <uzytkownik> @pl \c a p -> f $ g c a p
18:40:37 <lambdabot> ((f .) .) . g
18:45:58 <edwardk2> fixed that part up
18:46:22 <edwardk2> well, what i need for it is that i can take the contents of various monoidal bits and pieces and feed them into the iteratee based parsec parser
18:46:41 <edwardk2> so its the correct inversion of control i need to drive my parsec parser from a monoid
18:46:55 <edwardk2> otherwise i'm somewhat neutral on it.
18:51:39 <shachaf> > fmap fmap fmap fmap fmap fmap fmap fmap Just (\x y z -> (x,y,z)) 1 2 3
18:51:40 <lambdabot>   Just (1,2,3)
18:51:56 <shachaf> uzytkownik: Another point-free version. :-)
18:52:26 <ben> The hell
18:52:29 <ben> err
18:53:42 * shachaf wonders what combinators are necessary to get rid of parentheses generally.
18:53:45 <edwardk2> yay for view patterns: index !i (split (> i) → (l,viewl → S a :< _)) = Strict.index a $ getCursor $ i - measure l
19:08:18 <copumpkin> hmm, IntMap's Traversable instance is lost
19:08:22 <copumpkin> any way I can add it easily to my installation of GHC?
19:08:28 <copumpkin> as in, it was omitted by mistake and a recent patch put it back in, but my GHC doesn't have it, and I can't implement it without the IntMap hidden constructors
19:10:05 <copumpkin> is there some way for me to edit IntMap's source and just replace the one that came with GHC with my version?
19:10:28 <Saizan> grab containers?
19:10:58 <copumpkin> oh it's in there, I forgot
19:10:58 <Saizan> ?hackage containers
19:10:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/containers
19:12:06 <copumpkin> ah yeah :)
19:12:42 <copumpkin> bah, the version on hackage doesn't have it either, and won't build
19:12:51 <BMeph> BRB - configuring Ween-doze...
19:14:15 <mmorrow> i've just pulled out the IntMap source and used a hacked version in whatever project before
19:14:21 <mmorrow> @copumpkin
19:14:22 <lambdabot> Unknown command, try @list
19:14:24 <copumpkin> hmm
19:14:29 <Saizan> copumpkin: sigh, the core packages are the ones with buggier .cabal files :\
19:14:43 <copumpkin>     Could not find module `Data.Data':
19:14:49 <copumpkin> is that >3 or == 3?
19:14:55 <mmorrow> copumpkin: exactly like you, i needed the cons to make instances of stuff that didn't suck
19:15:06 <copumpkin> mmorrow: yeah :/
19:15:20 <copumpkin> I'll fetch it, fix the .cabal file and fix the instance
19:15:34 <copumpkin> but what's up with it? containers was uploaded this april, the patch was applied in january
19:16:09 <Saizan> copumpkin: you want base ==  4.*, or base == 3.*, syb
19:16:25 <mmorrow> copumpkin: i'd probably pull it out, or at least mod containers, then install the hacked version as containers-hax or something (and with a different module path too, or else ghc will asplode)
19:16:38 <copumpkin> hmm
19:16:44 <copumpkin> but this instance should be there
19:16:51 <copumpkin> it's supposedly in their source tree
19:16:57 <mmorrow> copumpkin: ah, i see
19:18:26 <jaredj> bargh!
19:18:33 <jaredj> import IO (IOMode)
19:18:38 <jaredj> ... WriteMode ...
19:18:48 <jaredj> Not in scope: data constructor 'WriteMode'
19:19:10 <jaredj> import IO (WriteMode)
19:19:20 <jaredj> Module 'IO' does not export 'WriteMode'
19:19:30 <Saizan> jaredj: import IO (IOMode(..))
19:19:33 <Vanadium> I think you are supposed to do soefb
19:20:00 <jaredj> cool thx
19:20:15 <copumpkin> zomg it works
19:20:16 <copumpkin> thanks :D
19:20:39 <jaredj> next question: i parsed stuff out of a file. i want to force evaluation. i just made my test hPrint it to /dev/null. i think there is a better way
19:20:52 <roconnor> import IO (IOMode(WriteMode))
19:21:02 <jaredj> seq didn't seem to work for this
19:21:06 <Vanadium> jaredj: Does evaluate work?
19:21:12 <Vanadium> Just guessing, sorry.
19:21:30 <Saizan> jaredj: seq only forces the outermost contructor
19:21:37 <roconnor> jaredj: the easy but slighly wrong way is to do "length foo `seq` blah"
19:21:37 <jaredj> ah.
19:21:58 <jaredj> er, foo is of a record type
19:22:12 <roconnor> ah
19:22:17 <roconnor> hmm
19:22:20 <jaredj> show foo `seq` blah?
19:22:39 <Saizan> that should work, but it's a bit wasting
19:22:40 <roconnor> Is it time to crack out the more sophisticated normalization functions
19:23:02 <roconnor> @hoogle hnf
19:23:03 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
19:23:15 <hzap> @hoogle rnf
19:23:16 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
19:23:33 <jaredj> can i use a bang?
19:23:41 <Saizan> a bang is like seq
19:23:59 <Saizan> jaredj: how is your record type defined?
19:24:00 <roconnor> jaredj: you could also use a stricter version of readFile
19:24:43 <roconnor> jaredj: if I understand your purpose well
19:25:16 <Saizan> a stict version of readFile will evaluate the whole string, but not the whole parsed value
19:25:33 <roconnor> right
19:25:53 <jaredj> saizan: http://patch-tag.com/r/ofx1/snapshot/current/content/pretty/Text/OFX1/Types.hs
19:25:55 <shachaf> Wouldn't show foo `seq` blah also not force the whole thing?
19:25:56 <roconnor> if jaredj just wants the file read so it can safely be modified, that is all that is needed.
19:26:00 <shachaf> (For many Show instances?)
19:26:05 <jaredj> shachaf: i want the whole thing forced
19:26:09 <roconnor> if jaredj needs to save memory space, then a proper seq is needed.
19:26:21 <jaredj> i'm not modifying, just testing whether it parses properly
19:26:41 <Saizan> jaredj: which one? or all of those?
19:27:18 <roconnor> shachaf: show foo `seq` blah only forces enough to decide if the string representation is empty or not.
19:27:19 <QP> hello?
19:27:36 <jaredj> Saizan: sorry OFXFile is at the end - but all of those are contained in it at some level
19:27:49 <jaredj> qp: pong
19:27:55 <Saizan> "rnf (show foo) `seq` blah" will work
19:28:06 <jaredj> :t rnf
19:28:08 <lambdabot> forall a. (NFData a) => a -> Done
19:28:11 <roconnor> doh
19:28:24 <roconnor> firefox updated so now I can't click on links
19:28:26 <Saizan> but it's more proper to write instances of NFData for your types directly
19:28:34 <jaredj> wha?
19:29:02 <jaredj> rather than just deriving Show, you mean?
19:29:20 <Saizan> like instance NFData BankAccount where rnf (BankAccount x y z) = rnf x `seq` rnf y `seq` rnf z `seq` ()
19:29:26 <Saizan> rather than using Show for this
19:29:36 <Saizan> though Show is convenient because you can derive it
19:29:42 <jaredj> ^^
19:29:57 <Saizan> you can derive NFData too with a little of TemplateHaskell and Data.Derive
19:30:19 <jaredj> i've managed to avoid TH
19:30:22 <roconnor> jaredj: why do you need to force this again?
19:30:39 <jaredj> although it is annoying to write a lot of \x s -> s{someField = x}
19:31:08 <jaredj> roconnor: to make it parse the whole file. it's a HUnit test
19:31:30 <roconnor> won't testing it force the parse anyways?
19:31:37 <jaredj> it hasn't.
19:32:34 <roconnor> seems strange to me, but I'll leave it to Saizan to help or anyone else with a working webbrowser.
19:32:54 <jaredj> i went like do { c <- readFile "test.ofx"; let p = parse ofxFile "bla" c; return () } and it didn't get all the way through
19:33:00 <jaredj> roconnor: yeh that's a drag eh
19:33:20 <roconnor> what is the type of p?
19:33:22 <blackdog> jaredj: but you're not actually testing anything there, right?
19:33:38 <jaredj> well i wanted to see if it would cause an error
19:34:01 <jaredj> p is Either (whatever Parsec error types are) (OFXFile)
19:34:08 <roconnor> if parse returns Either Success Failure, then seq is all you need
19:34:10 <jaredj> i did check whether it was Left or Right
19:34:24 <roconnor> there you go
19:34:30 <jaredj> only got me one level deep
19:34:43 <jaredj> well -
19:34:44 <roconnor> one level?
19:34:57 <BMeph> jaredj: Now granted, I'm way more lazy than any computer, but I'd still imagine that GHC could tell that you don't use your input, and may just decline to do the "extra" work. :)
19:35:01 <jaredj> the error that should have been caught was that i was missing an enum, ah, name
19:35:40 <jaredj> so like data M = A | B | C, and the file said "D", so read "D" would fail - but it never got evaluated
19:35:56 <jaredj> BMeph: quite.
19:36:27 <roconnor> you can fail and still return Right?
19:36:31 <Axman6> you never used p
19:36:40 <Axman6> whoops, hmm, scrolled up
19:36:44 <jaredj> Axman6: in fact i never named it *facepalm*
19:36:49 <Axman6> heh
19:36:51 <jaredj> Right _ -> ...
19:37:04 <QP> 1,2... 1,2... can you all hear me?
19:37:12 <Axman6> nope
19:37:12 <roconnor> QP yes
19:37:16 <QP> i'm testing my irc bot...
19:37:19 <Axman6> i can't
19:37:24 <QP> slash client
19:37:27 <roconnor> @botsnack
19:37:27 <lunabot>  :)
19:37:28 <lambdabot> :)
19:38:03 <holmak> How many bots are in here now?
19:38:04 <roconnor> <jaredj> i went like do { c <- readFile "test.ofx"; let p = parse ofxFile "bla" c; return () } and it didn't get all the way through
19:38:06 <jaredj> roconnor: the parsec bits succeeded, ergo Right
19:38:14 <holmak> They are going to overrun the humans...
19:38:15 <roconnor> this doesn't look like it is checking left or right
19:38:26 <Axman6> @users
19:38:26 <roconnor> jaredj: but there are more bits to check?
19:38:26 <lambdabot> Maximum users seen in #haskell: 661, currently: 546 (82.6%), active: 15 (2.7%)
19:38:38 <jaredj> roconnor: my summary was a mistake.
19:38:46 <jaredj> http://patch-tag.com/r/ofx1/snapshot/current/content/pretty/Tests/ParseExamples.hs
19:38:47 <roconnor> jaredj: write a function that checks to see if you succeed or fail
19:38:53 <Axman6> holmak: you got another 544 bots planned?
19:38:56 <roconnor> jaredj: and call that function on the parse.
19:38:56 <jaredj> see first function. that's how it stands
19:39:16 <jaredj> oh wait you haven't got a web browser that works. mybad.
19:39:24 <roconnor> jaredj: ya sorry ;(
19:39:30 <roconnor> I should really stay out of this conversation
19:39:31 <roconnor> :P
19:40:31 <jaredj> heh
19:40:38 <holmak> Axman6: It's only a matter of time before someone makes a plugin for lambdabot to have children
19:40:52 <roconnor> I'm in the middle up upgrading to Ubuntu 9.04
19:40:56 <roconnor> of
19:41:04 <holmak> It already writes Haskell!
19:41:11 <holmak> @djinn [a] -> Int
19:41:15 <Saizan> roconnor: he's using read inside its parser, so the exceptions won't produce a parsec parse failure
19:41:19 <lambdabot> Error: Undefined type []
19:41:21 <Axman6> holmak:  i hope so!
19:41:23 <Axman6> @fork
19:41:28 <Axman6> :(
19:41:39 <holmak> [] is undefined?
19:42:01 <Axman6> djinn can;t cope with recursive types
19:42:39 <holmak> Ah
19:42:58 <holmak> I was hoping to get it to write length
19:43:07 <jaredj> "Smith. Agent Smith."
19:43:12 <Axman6> @djinn Either a b -> Bool
19:43:12 <lambdabot> f a =
19:43:12 <lambdabot>     case a of
19:43:12 <lambdabot>     Left _ -> False
19:43:12 <lambdabot>     Right _ -> True
19:43:27 <roconnor> I think there is a version of djinn somewhere that can do recursive types
19:43:39 <holmak> madness
19:43:44 <jaredj> that's indjinnious
19:43:57 <TheHumanMonad> hehe
19:44:00 <holmak> @indjinnious [a] -> Int
19:44:01 <lambdabot> Unknown command, try @list
19:44:08 <holmak> Not here, apparently
19:44:21 <jaredj> ogh
19:44:27 <jaredj> -_-
19:44:43 <copumpkin> lol
19:44:49 <copumpkin> roconnor: how? :o
19:45:33 <d4> so, does anyone know an annotation that will allow this to type check?
19:45:43 <d4> @type let w x = x x in w w
19:45:45 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
19:45:45 <lambdabot>     Probable cause: `x' is applied to too many arguments
19:45:45 <lambdabot>     In the expression: x x
19:46:30 <Axman6> :t let f x = x x in f
19:46:31 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
19:46:31 <lambdabot>     Probable cause: `x' is applied to too many arguments
19:46:31 <lambdabot>     In the expression: x x
19:46:36 <roconnor> copumpkin: not sure.  Could be hooked directly to Wadler's brain.
19:46:50 <copumpkin> lol
19:46:58 <roconnor> d4: yes
19:47:11 <d4> roconnor: would you be willing to share that information?
19:47:16 <Twey> @src fix
19:47:16 <lambdabot> fix f = let x = f x in x
19:47:18 <d4> ie. could you be induced
19:47:20 <roconnor> @google Y combininator Haskell site:r6.ca
19:47:21 <lambdabot> No Result Found.
19:47:27 <roconnor> @google Y combinator Haskell site:r6.ca
19:47:29 <lambdabot> No Result Found.
19:47:29 <Twey> Ah, not quite the same thing
19:47:42 <Twey> http://r6.ca/blog/20060919T084800Z.html
19:47:45 <copumpkin> @type let w :: (forall a. a -> a) -> a -> a = x x in w id
19:47:47 <lambdabot> Not in scope: type variable `a'
19:47:47 <lambdabot> Not in scope: type variable `a'
19:47:53 <copumpkin> @type let w :: forall a. (forall a. a -> a) -> a -> a = x x in w id
19:47:55 <lambdabot>     Couldn't match expected type `Expr
19:47:55 <lambdabot>                                   -> forall a. (forall a1. a1 -> a1) -> a -> a'
19:47:55 <lambdabot>            against inferred type `Expr'
19:48:00 <copumpkin> @type let w :: forall a. (forall a. a -> a) -> a = x x in w id
19:48:01 <lambdabot>     Couldn't match expected type `Expr
19:48:02 <lambdabot>                                   -> forall a. (forall a1. a1 -> a1) -> a'
19:48:02 <lambdabot>            against inferred type `Expr'
19:48:12 <copumpkin> @type let w :: forall a. (forall a. a -> a) -> a; w = x x in w id
19:48:14 <lambdabot>     Couldn't match expected type `Expr -> (forall a1. a1 -> a1) -> a'
19:48:14 <lambdabot>            against inferred type `Expr'
19:48:14 <lambdabot>     In the expression: x x
19:48:19 <copumpkin> whoops lol
19:48:22 <copumpkin> @type let w :: forall a. (forall a. a -> a) -> a; w x = x x in w id
19:48:23 <roconnor> d4: it's a bit difficult without a working webbrowser
19:48:23 <lambdabot>     Couldn't match expected type `a1' against inferred type `a -> a'
19:48:23 <lambdabot>       `a1' is a rigid type variable bound by
19:48:23 <lambdabot>            the type signature for `w' at <interactive>:1:16
19:48:27 <copumpkin> meh, I give up
19:48:42 <d4> roconnor: mmm
19:48:49 <roconnor> ah Twey gave the link I wanted to give
19:48:55 <copumpkin> @type let w :: forall a. (forall a. a -> a) -> a -> a; w x = x x in w id
19:48:55 <roconnor> or presumably did
19:48:57 <lambdabot> forall a. a -> a
19:48:59 <copumpkin> there we go
19:49:20 <copumpkin> but I can't make it typecheck with w w :)
19:49:34 <roconnor> copumpkin: add more foralls :P
19:49:40 <copumpkin> lol
19:49:59 <copumpkin> @type let w :: forall a. (forall a. a -> a) -> a -> a; w x = x x in w
19:50:00 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
19:53:21 <pikhq> That's... A weird combinator.
19:53:35 <copumpkin> it's loopy
19:53:55 <copumpkin> roconnor: is it even possible?
19:54:00 <d4> it's just a self-application of \x -> x x
19:54:09 <pikhq> d4: Still weird.
19:54:12 <d4> pikhq: yes
19:54:18 <d4> I agree it's weird
19:54:22 <copumpkin> you can also kill lambdabot using that function
19:54:37 <d4> copumpkin: DOS?
19:54:40 <copumpkin> yeah
19:54:40 <copumpkin> :P
19:54:51 <copumpkin> at least it usually seems to work pretty reliably
19:55:02 <copumpkin> it'll just restart and come back
19:55:38 <d4> is that true of any non-terminating recursion?
19:55:45 <roconnor> oh crap
19:55:54 <roconnor> this upgrade isn't working out so good
19:56:00 <copumpkin> @pl (\x -> x x) (\x -> x x)
19:56:01 <copumpkin> not sure
19:56:03 <lambdabot> ap id id (ap id id)
19:56:03 <lambdabot> optimization suspended, use @pl-resume to continue.
19:56:16 <copumpkin> @pl-resume
19:56:22 <lambdabot> ap id id (ap id id)
19:56:22 <lambdabot> optimization suspended, use @pl-resume to continue.
19:56:34 <pikhq> ... Recursive @pl.
19:56:45 <pikhq> Bravo.
19:56:58 <copumpkin> you can get it to behave nastily on various functions of that form
19:57:06 <d4> @pl \x -> x x
19:57:07 <lambdabot> join id
19:57:11 <d4> now that's weird
19:57:16 <roconnor> ;(
19:57:17 <copumpkin> lol
19:57:22 * d4 doesn't know join
19:57:24 <copumpkin> roconnor: what upgrade?
19:57:25 <roconnor> It's bad when linux-image fails to upgrade
19:57:28 <copumpkin> d4: it's a zomg-worthy function
19:57:33 <copumpkin> :t join
19:57:33 <Badger> zomg!
19:57:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:57:51 <Badger> sorry that was badly timed
19:57:56 <copumpkin> d4: its in ur monadz, flattenin ur levelz
19:57:57 <roconnor> hmm
19:58:01 <roconnor> could be a disk space issue
19:58:02 <pikhq> @src join
19:58:03 <lambdabot> join x =  x >>= id
19:58:05 <d4> copumpkin: the type is hardly shedding any light for me
19:58:13 <pikhq> Totally weird.
19:58:16 <copumpkin> > join [[1,2,3],[4,5,6]]
19:58:21 <ray> @src id
19:58:33 <copumpkin> ah, lambdabot may be on strike from my abuse earlier
19:58:37 <copumpkin> it often takes a while
19:58:41 * ManateeLazyCat pasted "Manatee.Gtk.Utils" at http://paste2.org/get/360629
19:58:45 <ManateeLazyCat> Above code is my utility library for GTK in my project, hope it will hope someone. Enjoy! :)
19:58:48 <ManateeLazyCat> Code at http://paste2.org/get/360629
19:58:49 <Saizan> d4: in that case join f x = f x x
19:58:49 <ray> it's like the opposite of a race condition
19:59:05 * Badger hopes someone
19:59:14 <blbrown_win_> http://paste.lisp.org/display/84881  anyone see a problem with this post.  I am trying to use gtk2hs
19:59:19 <Badger> @botsnack
19:59:19 <lunabot>  :)
19:59:28 <Badger> owch
19:59:33 <copumpkin> Badger: it should eventually restart and come back
19:59:36 <ManateeLazyCat> @hoogle [a] -> IO () -> IO ()
19:59:40 <copumpkin> ...if it doesn't I'll feel guilty :P
19:59:47 <d4> Saizan: that makes it clear why join id = \x -> x x
19:59:52 <blbrown_win_> oh yea, that is win32
19:59:52 <ManateeLazyCat> Looks haven't exist.
19:59:53 <copumpkin> there we go
19:59:56 <ray> you are a meanie of the highest order
19:59:56 <Badger> hurray
19:59:56 <ManateeLazyCat> unlessNull = unless . null
19:59:56 <ManateeLazyCat>  
19:59:58 <Saizan> d4: yup
20:00:03 <copumpkin> yay
20:00:06 <copumpkin> a brand new lambdabot
20:00:09 <ray> @botsack
20:00:09 <copumpkin> @uptime
20:00:09 <lunabot>  :)
20:00:15 <Badger> heh
20:00:16 <lambdabot> uptime: 14s, longest uptime: 1m 10d 23h 44m 29s
20:00:21 <d4> we sorry lambdabot
20:00:22 <lambdabot> :)
20:00:22 <Saizan> d4: it's using the (->) r monad instance, which is also called the naked Reader monad
20:00:24 <Badger> > join [1,2,3],[4,5,6
20:00:26 <Badger> > join [1,2,3],[4,5,6]
20:00:28 <Badger> woops
20:00:32 <copumpkin> > join [[1,2,3],[4,5,6]]
20:00:36 <lambdabot>   <no location info>: parse error on input `,'
20:00:36 <Badger> oh
20:00:38 <lambdabot>   <no location info>: parse error on input `,'
20:00:41 <ManateeLazyCat> lambdabot is smart bot
20:00:44 <lambdabot>   [1,2,3,4,5,6]
20:00:47 <copumpkin> > join (+) 7
20:00:54 <lambdabot>   14
20:01:09 <copumpkin> > join (.) (+7) 10
20:01:16 <lambdabot>   24
20:01:58 <d4> odd
20:02:41 <copumpkin> :o
20:02:49 <copumpkin> @botsmack
20:02:49 <lunabot>  :)
20:03:00 <lambdabot> :)
20:03:04 <d4> the only one I don't follow is the first example with the list monad
20:03:09 <copumpkin> > join (<=<) (+) 5 7
20:03:18 <lambdabot>   19
20:03:25 <copumpkin> :P
20:03:28 <d4> :t <=<
20:03:32 <d4> :t (<=<)
20:03:36 <lambdabot> parse error on input `<=<'
20:03:39 <d4> yeah yeah
20:03:42 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
20:03:44 <Badger> @hoogle (<=<)
20:03:50 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
20:03:50 <copumpkin> d4: for lists, (>>=) is concatMap, right?
20:04:00 <d4> copumpkin: yeah
20:04:07 <copumpkin> d4: so concatMap id === concat
20:04:12 <d4> yeah
20:04:25 <d4> but where did id come from...
20:04:30 <copumpkin> @src join
20:04:31 <lambdabot> join x =  x >>= id
20:05:04 <d4> err, oh
20:05:38 <copumpkin> > f >>= x
20:05:40 <lambdabot>   Couldn't match expected type `a -> m b'
20:05:45 <copumpkin> > f >>= g
20:05:46 <lambdabot>   No instance for (SimpleReflect.FromExpr (m b))
20:05:46 <lambdabot>    arising from a use of `Si...
20:06:05 <copumpkin> > f >>= g $ x
20:06:07 <lambdabot>   Add a type signature
20:06:10 <copumpkin> > f >>= g $ x :: Expr
20:06:11 <lambdabot>   Add a type signature
20:06:13 <Badger> heh
20:06:15 <ray> x >>= f = join (fmap f x)
20:06:33 <copumpkin> trying to get lambdabot to write S for me
20:06:46 <ray> >>= is just flipped =<<
20:08:02 <ray> @pl \f x -> join (fmap f x)
20:08:03 <lambdabot> (=<<)
20:08:10 <ray> screw you @pl
20:08:26 <copumpkin> lol
20:08:35 <copumpkin> so I can't get simplereflect to do that for me?
20:08:47 <copumpkin> > join (fmap f x)
20:08:48 <lambdabot>   Couldn't match expected type `m a'
20:09:05 <copumpkin> > join (fmap f g)
20:09:06 <lambdabot>   No instance for (SimpleReflect.FromExpr (m a))
20:09:07 <lambdabot>    arising from a use of `Si...
20:09:10 <copumpkin> > join (fmap f g) x
20:09:11 <lambdabot>   Add a type signature
20:09:14 <Saizan> copumpkin: you've to pay for it!
20:09:18 <copumpkin> > join (fmap f g) x :: Expr -- :(
20:09:19 <lambdabot>   Add a type signature
20:09:26 <copumpkin> > join (fmap f g) (x :: Expr) :: Expr -- :(
20:09:27 <lambdabot>   Add a type signature
20:09:34 <pikhq> copumpkin: Like, add some type signatures for your fmap.
20:09:36 <ray> you're a type signature
20:10:21 <dancor> O(wned)
20:10:31 <ray> @nick \_|_
20:10:32 <lambdabot> Maybe you meant: dice dict
20:13:14 <d4> so in the list monad >>= is concatMap
20:13:26 <d4> but how is it defined in (id >>= id)
20:13:49 <ray> :t id >>= id
20:13:50 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
20:13:51 <lambdabot>     Probable cause: `id' is applied to too many arguments
20:13:51 <lambdabot>     In the second argument of `(>>=)', namely `id'
20:14:06 <d4> ray: ha, yeah, that was the original question
20:14:14 <ray> occurs check is like a big STOP HAVING FUN sign
20:14:31 <Badger> no infinite types for you!
20:14:47 <d4> so forall allows infinite types somehow?
20:14:57 <d4> I haven't seen that before either
20:17:28 <pikhq> :t id >> id
20:17:29 <lambdabot> forall a. a -> a
20:17:30 <pikhq> YAY
20:17:45 <Saizan> the forall breaks the infinite recursion by requiring that the function works for all types, not just the type of itself
20:18:16 <pikhq> (and yes, I'm aware that _ >> x = x in the function monad)
20:25:27 <ray> your head a splode
20:25:31 <ray> i mean mine
20:25:34 <ray> i mean my?
20:26:00 <Badger> mine head is a splode!
20:26:03 <blackdog> hard to tell with an asploded head
20:26:27 <ray> <-- the head of this guy
20:26:32 <Makoryu> Yo dawg, I heard Lisp people can output function definitions to a file while using the console. Can we do that with function definitions (or at least command history) in ghci?
20:27:03 <ray> i was disappointed that you did not follow through on the meme there
20:27:11 <Makoryu> Good. You deserve to be.
20:27:22 <blackdog> yeah, totally. leaving us teetering there, man
20:27:29 * Makoryu stabs that meme in the back and throws it overboard
20:27:36 <Makoryu> But my question
20:27:37 <blackdog> i hear you like s-expressions in your files...
20:27:39 <Makoryu> Does it have an answer?
20:28:21 <ray> i am not aware of such power
20:28:23 <blackdog> i don't think it's a common way of working... you'd have to dig through the ghci docs
20:28:29 <ray> you can't even define functions well in ghci though
20:28:46 <Makoryu> ray: Yeah, my question doesn't make a huge amount of sense.
20:29:05 <ray> if it can do it, it's probably obscure for that reason
20:29:08 <Makoryu> Hence the alternative: You output part of your command history
20:29:30 <ray> i think the history in ghci falls to the line editing library
20:29:31 <d4> so folks, what must one import to get this forall construct
20:29:43 <d4> hoogle doesn't help me here
20:29:45 <ray> forall is part of the language and it's not really special
20:29:57 <ray> unless you're doing existential types which you are not
20:29:59 <d4> hmm, it works on lambdabot but not my ghci
20:30:13 <d4> go ahead, say PEBKAC
20:30:13 <Makoryu> d4: It doesn't work in ghci, no
20:30:24 <Makoryu> Try putting it in a file though, I guess
20:30:31 <Makoryu> With the appropriate extensions enabled
20:30:35 <d4> Makoryu: oh, it has to be compiled?
20:30:45 <d4> something about RankNTypes?
20:30:56 <ray> you don't need explicit foralls if you aren't using fancy types
20:30:57 <Makoryu> d4: Not as such, but I never got extensions working in ghci so big deal
20:31:05 <ray> id doesn't have a fancy type
20:31:09 <blackdog> Makoryu: is there a reason you don't like working in a file with a ghci window open?
20:31:28 <blackdog> or emacs inferior window or whatever
20:31:52 <SamB> blackdog: that's still a ghci window, isn't it?
20:32:24 <d4> is there somewhere I can read about forall and fancy types?
20:32:33 <ray> the haskell wikibook, i think
20:32:57 <ray> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
20:33:27 <d4> funny, it sounds like a universal quantifier
20:33:47 <Makoryu> blackdog: That's how I usually work (ghci + vim in another window). I just realized earlier that I could interactively do some work instead of writing a one-off program for it, and then realized later, "What if I have to do this a second or third or fortieth time?"
20:33:53 <ray> yes
20:34:08 <ray> it is a universal quantifier, but it's used to make existential types
20:34:36 <SamB> Makoryu: well, the second time, after you get it to work, paste it into teh file!
20:34:39 <d4> ghci -XRankNTypes allowed (\x -> x x) :: forall a. (forall a. a -> a) -> a -> a
20:34:53 <Makoryu> SamB: Yeah I guess.
20:36:08 <Makoryu> I just wish there were a more elegant method than opening the history file and applying copy-and-paste
20:36:31 <SamB> Makoryu: oh, I meant from the ghci window
20:36:45 <Makoryu> ~/.ghc/ghci_history
20:37:01 <Makoryu> It's in reverse order for some reason
20:37:18 <Makoryu> Oh crap, I couldn't get GHC working on my server anyway
20:37:26 <Makoryu> Is there an elegant way to translate this into Perl?
20:37:48 <SamB> mauke: your skillz are perhaps needed?
20:38:24 <blackdog> Makoryu: yeah, with you on the temporary program thing. i've got a million one-shot haskell files littering my disk.
20:38:50 <ray> only a million?
20:39:30 <Makoryu> I would try to patch this into ghci.................... But I'm too lazy.
20:39:49 <Makoryu> The file dump thing, I mean, not the Perl thing.
20:40:13 <ray> yeah, the perl mangler is already too much perl for ghc
20:43:36 <blackdog> i reckon perl gets a bad rap
20:44:09 <Makoryu> Perl is nice because it's almost as portable as C
20:44:14 * Twey laughs.
20:44:17 <blackdog> especially since it gets pulled out for all the really dirty jobs people don't want to do in $LANGUAGE_OF_CHOICE
20:44:31 <Makoryu> But then again, $JAVA_BUTTSECKS_JOKE
20:44:52 <pikhq> Makoryu: And almost as readable. And almost as safe.
20:44:54 <blackdog> it's hardly surprising the code is sometimes filthy when it's doing sewer work
20:45:32 <jorizma> Perl keeps the internet together, it deserves at least some respect
20:45:45 <blackdog> pikhq: check perl6 some time. it's pretty common to use the same kind of list combinators you'd use in haskell.
20:45:55 <pikhq> blackdog: THAS NOT PERL!
20:45:56 <pikhq> :P
20:46:01 <blackdog> of course, the lack of a static type system makes it hard
20:46:18 <blackdog> pikhq: orly? in that case, you don't get to use anything that's not in Haskell98 :P
20:46:45 <Makoryu> If only perl6 was already deployed on the distros used by obnoxious sysadmins who don't trust their users
20:46:50 <d4> phew; I think I get it...
20:46:59 <d4> @type (\x -> x x) :: (forall a. a -> a) -> b -> b
20:47:00 <lambdabot> forall b. (forall a. a -> a) -> b -> b
20:47:40 <d4> so it's a function that takes a function and gives a function; that much is clear
20:48:45 <aavogt> @type (\x -> x x) id
20:48:46 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
20:48:46 <lambdabot>     Probable cause: `x' is applied to too many arguments
20:48:46 <lambdabot>     In the expression: x x
20:49:18 <aavogt> @type (\x -> x x) (id :: forall a. a -> a)
20:49:18 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
20:49:19 <lambdabot>     Probable cause: `x' is applied to too many arguments
20:49:19 <lambdabot>     In the expression: x x
20:49:22 <mmorrow> @type id :: forall a. (forall a. a -> a) -> a -> a
20:49:24 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
20:49:37 <d4> @type ((\x -> x x) :: (forall a. a -> a) -> b -> b) id
20:49:38 <lambdabot> forall b. b -> b
20:49:57 <pikhq> blackdog: On a more serious note, I have a dislike for languages whose parsing is undecidable.
20:50:13 <mmorrow> @type [id id, id . id]
20:50:14 <lambdabot> forall a. [a -> a]
20:50:30 <copumpkin> @type (\x -> x x :: (forall a. a -> a) -> (forall a. a -> a)) id
20:50:32 <lambdabot>     Cannot match a monotype with `t
20:50:32 <lambdabot>                                   -> (forall a. a -> a)
20:50:32 <lambdabot>                                   -> forall a. a -> a'
20:50:39 <blackdog> pikhq: i don't think perl's parsing is undecidable, is it? i know it's context-sensitive
20:50:56 <copumpkin> lots of languages have context-sensitive grammars (if only slightly)
20:50:58 <blackdog> pikhq: obviously it's unpleasant :) but it's always a tradeoff
20:51:02 <pikhq> blackdog: Parsing it dynamically or otherwise requires a halting oracle.
20:51:06 <aavogt> surely there must be one general type for all those id?
20:51:42 <kingdj> blackdog: even the perl implementors admit that the only thing that can correctly parse perl is the perl interpreter itself.
20:52:01 <kingdj> and sometimes, I don't think they're sure about that ;)
20:52:01 <pikhq> kingdj: Even perl cannot parse Perl.
20:52:20 <pikhq> It can only parse the subset of Perl that can be parsed.
20:53:13 <blackdog> pikhq: heh, you're right. that's pretty funny.
20:53:44 <blackdog> not something you're likely to see in practice terribly often
20:54:01 <d4> but is it possible to write unparsable perl?
20:54:47 <Vanadium> Seems much more efficient to google unparsable perl than to write it
20:54:56 <pikhq> Yes. I don't have an example available, but it exists.
20:55:22 <QtPlaty[HireMe]> d4: Since Perl is definded as what perl can parse I'd say no.
20:55:30 <Vanadium> http://www.perlmonks.org/?node_id=663393 ?
20:56:20 <aavogt> is that case really much worse than say, -XUndecidableInstances?
20:56:25 <pikhq> That's the one that proves that Perl cannot be *statically* parsed.
20:56:26 <pikhq> There's a proof that it cannot be dynamically parsed floating around somewhere.
20:57:34 <pikhq> aavogt: I have a similar distaste for that.
20:57:49 <pikhq> And for C++ lambda expressions -- I mean, templates.
20:59:04 <mmorrow> main = [|runIO (system "sudo halt")|]
21:00:55 <blackdog> more emphasis on the "problem" and less on the "halting" , i guess
21:02:27 <aavogt> > fix id
21:02:46 <lambdabot>   mueval-core: Prelude.read: no parse
21:02:46 <lambdabot>  mueval: ExitFailure 1
21:03:18 <mmorrow> oops
21:03:36 <mmorrow> main = $([|runIO (system "sudo halt")|] >> [|()|])
21:03:47 <mmorrow> or better
21:03:51 <mmorrow> main = $([|runIO (system "sudo halt")|] >> [|fix id|])
21:04:26 <mmorrow> gah!
21:04:33 <mmorrow> main = $(runIO (system "sudo halt") >> [|fix id|])
21:04:40 <mmorrow> ok, now it works :)
21:05:16 <dmwit> That looks odd.  What's it for?
21:05:46 <mmorrow> dmwit: for making sure that compilation halt, of course
21:05:46 <aavogt> killing your system at compile time?
21:06:15 <mmorrow> *halts
21:06:17 <dmwit> =)
21:06:45 <pikhq> In other words, "Halting is no problem!"
21:07:11 <mmorrow> heh
21:08:31 <aavogt> apparently its a 'good thing' that programs may contain undecidable values...
21:08:58 <aavogt> so why stop there :)
21:09:26 <dmwit> Undecidable values suck, only undecidable inputs are good.
21:09:58 <pikhq> I WANT ALL COMPUTATION TO BE DECIDABLY HALTABLE
21:10:13 * Saizan halts pikhq 
21:10:16 <dmwit> pikhq: There are total languages, you should use one. =)
21:10:24 <pikhq> dmwit: :P
21:15:52 <mmorrow> hehe, this would be a good one too
21:15:56 <mmorrow> main = $((runIO . System.system . ("ghc --make -XTemplateHaskell "++) . loc_filename =<< location) >> [|()|])
21:17:35 <mmorrow> lol
21:18:55 <mmorrow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7913
21:25:24 <Ke> AAAAB3NzaC1yc2EAAAABIwAAAQEA0OmAeuk0y4tqIxZWnnOHylVzw3yRqUV2k+igz/AUe0azFWnPGTdgOnTlD55oEFlP84sfxaMsU1oLJBTSOu0uREl17IgTis4F2nBP6LL8Vlc6WS5UK76tQ7kaJ397WKllnf6PC3yTIOwRNseBXj72rCD0mFZh5hhVUHdNR1YZtTLI4H6QQ3ZwYIIdIsha2kLPabF8saP6Wadpz6d2Fn35y/zxBiMy9icyg5nDRPuBZhqyHEBHWZr1TJoaMXX9noQexLgSJslpYSdOxW9yL2zVOnJU6aCNQOLTlCdZt3AlNc7qUP93RIUOwSyzAloAk1d5Rmn7tleuT+9GgagKAdOZ0Q==
21:25:30 <Ke> AAAAB3NzaC1yc2EAAAABIwAAAQEA0OmAeuk0y4tqIxZWnnOHylVzw3yRqUV2k+igz/AUe0azFWnPGTdgOnTlD55oEFlP84sfxaMsU1oLJBTSOu0uREl17IgTis4F2nBP6LL8Vlc6WS5UK76tQ7kaJ397WKllnf6PC3yTIOwRNseBXj72rCD0mFZh5hhVUHdNR1YZtTLI4H6QQ3ZwYIIdIsha2kLPabF8saP6Wadpz6d2Fn35y/zxBiMy9icyg5nDRPuBZhqyHEBHWZr1TJoaMXX9noQexLgSJslpYSdOxW9yL2zVOnJU6aCNQOLTlCdZt3AlNc7qUP93RIUOwSyzAloAk1d5Rmn7tleuT+9GgagKAdOZ0Q==
21:25:37 * Ke fail
21:25:49 <dmwit> Hahaha!  Now I have your public key...
21:25:50 <dmwit> oh
21:25:59 <Ke> yes you do
21:26:29 <Ke> why the hell did I even have it in my pastebuffer
21:27:05 <dmwit> Making an account on code.haskell.org?
21:27:34 <ray> now i can give you UNLIMITED ACCESS TO MY SERVER, and you can do NOTHING about it
21:27:42 <kadoban> haha
21:27:45 <jeffwheeler> Hm?
21:27:52 <dmwit> jeffwheeler: not you
21:28:03 <jeffwheeler> dmwit: Hmmm
21:28:20 <dmwit> jeffwheeler: Indeed
21:28:22 <SamB> ray: or limited access!
21:28:36 <ray> who wants limited access though
21:28:46 <dufflebunk> who wants unlimited access?
21:28:55 <jeffwheeler> Depends on the server.
21:42:38 <SamB> ray: you were just acting as though he wouldn't want unlimited access ;-P
21:54:47 <tingi>  any tricks for  http://www.cs.hmc.edu/ACM/Problems/Spring01/papers/papers.html ?
22:02:10 <dmwit> tingi: Looks like a pretty straightforward fold to me.
22:02:24 <dmwit> The usual dynamic-programming-expressed-as-a-fold kind, naturally.
22:02:40 <tingi> dmwit, ok lemme try once again
22:03:40 <dmwit> Note that all that really matters about each line is where the first and last subscriber is; the ones in between will get their due automatically if you take care of the boundary guys.
22:07:27 <tingi> dmwit, my thought is if  f(level,left,right) represents after delivering level completely ,starting at left and ending at right. so you have to compute 4 values for each level and then connect (lvl+1)
22:07:35 <tingi> with minimum
22:07:40 <tingi> is that correct ?
22:08:05 <dmwit> The solution I have in mind tracks only two values for each level.
22:08:33 <dmwit> I can't really decipher your English well enough to give you subtle hints, though. =(
22:08:36 <tingi> shouldn't it take arrive at left and leave at right
22:08:46 <tingi> and arrive at left and leave at left
22:08:56 <tingi> 2^2
22:09:42 <dmwit> Think a little harder: what are you going to do with those four values?  Can you do it sooner?
22:09:47 <hackagebot> dyre 0.4 - Dynamic reconfiguration in Haskell (WillDonnelly)
22:09:55 <dmwit> The sooner you do it, the less data you have... and that can make an actual asymptotic difference.
22:10:48 <tingi> dmwit, i'm thinking of greedy ?
22:11:20 <tingi> for a level above at right, i need 2 values , level -1 at ending at right
22:11:50 <dmwit> I have no idea what that means.
22:17:36 <tingi> dmwit, when we are at a higher floor starting at left end, that means, we would have come to the higher floor from left end in the lower floor. Now i could've started at left end in the lower floor or right end in the lower floor
22:20:51 <dmwit> tingi: Yes, but does it matter whether you started at the left end or right end on the lower floor?
22:21:05 <tingi> dmwit, you just store the minimum values at left and right ends
22:21:11 <dmwit> Exactly!
22:21:28 <dmwit> Two values only are needed. =)
22:22:42 <tingi> dmwit, actually there is an interesting problem , what if you could skip floors to return later ie in a  very wide building with low height and top row compleelty with **,  and * just beside stairs, i would take a path of inverted U
22:22:56 <tingi> or skip some houses to return later
22:23:20 <dmwit> Yes, if you can choose which order you do the floors in, the problem is likely a bit harder.
22:24:00 <tingi> you can do it in any order  and houses in any order but only constraint is minimum, isn't that very tough ?
22:25:00 <dmwit> Perhaps exponential. =)
22:25:29 <tingi> dmwit, yes even i thought so something like TSP but not a closed tour
22:29:12 <Optimo> orly
22:29:22 <copumpkin> or this
23:15:36 <Yrogirg> Hello, how do I denote infinity in Haskell (1/0)? Just "Infinity" doesn't work.
23:16:59 <sjanssen> Yrogirg: I don't think there's a direct way
23:17:07 <sjanssen> > read "Infinity" :: Double
23:17:09 <lambdabot>   Infinity
23:17:22 <sjanssen> > 1/0 -- these are the only two ways I'm familiar with
23:17:23 <lambdabot>   Infinity
23:18:07 <dufflebunk> RealFloat has isInfinity
23:18:16 <kyagrd> seeking for some template haskell advice.
23:18:42 * dufflebunk notes that 1/0 isn't infinity. Approaching 0 from -1 gives you -inf
23:19:25 <kyagrd> when I have [| \ x y z -> ... |] and I know that x y z could have either integer, boolean, or array type (some finite possibility)
23:19:48 <kyagrd> is there a way to write a function that says try splicing and see if it is type correct kind of thing?
23:20:45 <kyagrd> plain splicing would just give a type error, but it would be neat if I can get a maybe or either type value
23:22:16 <kyagrd> Would it need GHC API hacks?
23:45:38 <Peaker> Lemmih: you there?
23:50:21 <Peaker> how do record pattern matches look again?
23:50:45 <SubStack> Foo{ bar = 42 }?
23:51:09 <Peaker> ah, so rhs of = takes the value. a bit weird :)
23:51:22 * SubStack double checks
23:52:16 <SubStack> yep
23:52:45 <SubStack> records could be a little nicer I think, but they're not too bad
23:52:50 <Gracenotes> it is true
23:53:53 <Gracenotes> hm. I wonder when the compiler catches that x { y = z} is incorrect if y is not a record part of x
23:54:57 <SubStack> not in scope, it tells me
23:55:02 <Gracenotes> me too
23:55:20 <Gracenotes> I get the feeling it's kind of a hack. but it works
23:56:17 <SubStack> whoa neat, you can do the | guards in case statements
23:56:37 <SubStack> and all pattern matches I suspect, although I've only used them for function defs
23:57:45 <athos> heh :)
23:59:20 <Makoryu> "No language should have an operator for exponentiation" <- I love it when people make silly assumptions about things like operators
23:59:41 <athos> where does that quote come from?
23:59:47 <WorkyBob> also... wow
23:59:54 <WorkyBob> exponentiation is a bloody useful operator
