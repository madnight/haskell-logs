00:14:01 <mornfall> Will catchError in IO catch regular thrown exceptions?
00:14:29 <Peaker> @hoogle catchError --info
00:14:29 <lambdabot> Control.Monad.Error.Class catchError :: MonadError e m => m a -> (e -> m a) -> m a
00:14:29 <lambdabot>  
00:14:29 <lambdabot> From package mtl, version 1.1.0.1
00:14:36 <Peaker> @hoogle catchError
00:14:36 <lambdabot> Control.Monad.Error.Class catchError :: MonadError e m => m a -> (e -> m a) -> m a
00:14:52 <Peaker> mornfall: Not sure, but I doubt it
00:15:06 <mornfall> Well, IOError IO is instance of MonadError.
00:15:20 <mornfall> I mean, MonadError IOError IO is an instance.
00:16:09 <Peaker> Yeah, but does IOError include pure exceptions?
00:16:09 <Saizan> so yeah, it'll catch IOError exceptions
00:16:25 <Peaker> mornfall: by "regular" do you mean pure or IO exceptions?
00:17:34 <mornfall> Peaker: Well, I mean IO I guess.
00:17:40 <mornfall> What's a pure exception, anyway?
00:18:00 <mornfall> Sounds like an oxymoron to me.
00:18:13 <copumpkin> Maybe a
00:18:16 <copumpkin> :P
00:18:46 <Peaker> copumpkin: basically bottoms created with error
00:18:59 <copumpkin> yeah, I was just kidding
00:19:00 <mornfall> copumpkin: Well, there's nothing to catch about Either.
00:19:06 <mornfall> And for error, I don't care.
00:19:14 <mornfall> Error is not an exception, it may be an assertion failure at best.
00:22:35 <Saizan> mornfall: you wish!
00:23:55 <Saizan> i mean, i'd like error to be used only when you're absolutely not supposed to recover from such an error, but that's unfortunately not the case in general
00:25:42 <mornfall> Saizan: Fix the code, then. :)
00:25:50 <mornfall> It's all open source, afterall.
00:27:22 <mornfall> I mean, these days we should all rely on cabal and hackage to sort things out. It may often make sense to fix code, bump the version and depend on that new version for your libraries.
00:27:30 <Saizan> yeah, i'd like to fix binary for example, but i never find the time to benchmark it properly :)
00:28:00 <Saizan> mornfall: you've to coordinate with the maintainers, unless you're willing to fork the package
00:28:22 <copumpkin> well, given hackage, you could reupload it yourself without the maintainer's permission ;)
00:28:26 <copumpkin> but that's not very polite
00:29:05 <mornfall> Saizan: Of course you do, but I wouldn't expect many issues with maintainers refusing to stop error abuse.
00:29:25 <mornfall> There's really no excuse to not fix that, when you get a patch for free.
00:30:39 <Berengal1> People need to not be afraid of microversions
00:32:11 <Peaker> binary is the example that comes to my mind too. I hate their error handling
00:32:16 <dibblego> is there an infix liftA2?
00:32:44 <dibblego> wait no
00:32:51 <copumpkin> @hackage infix-applicative
00:32:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/infix-applicative
00:32:57 <copumpkin> damn
00:33:09 <Saizan> @hackage InfixApplicative
00:33:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/InfixApplicative
00:33:11 <copumpkin> http://hackage.haskell.org/packages/archive/InfixApplicative/1.0.1/doc/html/Control-Applicative-Infix.html
00:33:15 <copumpkin> but it's not liftA2 directly
00:33:27 <copumpkin> it kinda results in it though if you use it symmetrically
00:44:19 <mmorrow_> copumpkin: i think vacuuming to asm is a partial solution to the "huge static data compile time blowup" thing (partial, since i think only constructors can be static closures like this, but not e.g. ByteArray#... but in that case i think you can just go via Addr# literals..)
00:44:42 <mmorrow_> importing values is O(1)
00:44:44 <copumpkin> ah, that's a good idea
00:44:55 <copumpkin> cause they're already laid out correctly in the object file?
00:44:56 <mmorrow_> well, the linker has to do the relocs, but that's fast
00:45:02 <mmorrow_> check out this asm
00:45:09 <mmorrow_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3134#a3134
00:45:27 <mmorrow_> thats for a list of 4 Vec64 cons from the Vec type from hsfft
00:45:39 <mmorrow_> everything unpacked :)
00:45:41 <copumpkin> what's the overhead on it?
00:45:47 <mmorrow_> zero
00:45:48 <copumpkin> ah, so all those big numbers are actually doubles?
00:45:53 <mmorrow_> yeah
00:45:58 <copumpkin> ah nice
00:46:19 <mmorrow_> as assembles a .s with s/4/1000/ of those in seconds
00:46:29 <copumpkin> nice
00:46:33 <mmorrow_> (which is like 100,000+ lines of .s)
00:46:48 <copumpkin> hah
00:46:48 <mmorrow_> then you just link it into your prog
00:46:50 <Saizan> mh, a serialize/deserialize that works for any non-function type would be very handy for me right now..
00:46:52 <copumpkin> how big a .o file does that give?
00:47:00 * mmorrow_ checks
00:47:05 <copumpkin> Saizan: same here
00:47:27 <copumpkin> mmorrow_: how hard would it be for you to separate that from vacuum and make an "unsafeserialize" package? :P
00:47:31 <mmorrow_> -rw-rw-r-- 1 m m 1.2M 2009-08-03 02:44 myvecs.o
00:47:39 <copumpkin> ah nice
00:47:41 <mmorrow_> [m@monire VACUUM]$ wc -l myvecs.s
00:47:41 <mmorrow_> 134006 myvecs.s
00:47:41 <hamishmack> Axman6: Make sure ghc is in your PATH (should be ok if set it in ~/.profile).
00:47:59 <copumpkin> unsafe in the sense that it's only guaranteed to work on the machine it was produced on
00:48:07 <Axman6> hamishmack: someone else?
00:48:34 <mmorrow_> copumpkin: not at all (although you'd still need the `vacuum' function), but all of this is done off-the-cuff in a few hundred lines (mostly for prettyprinting the asm)
00:48:45 <copumpkin> nice
00:48:50 <mmorrow_> Saizan: is to asm ok?
00:48:56 <hamishmack> Axman6: for Leksah on OSX
00:49:12 <Axman6> oh
00:49:20 <Axman6> well, it's in my path
00:49:26 <mmorrow_> copumpkin, Saizan: http://moonpatio.com/repos/GenAsm.hs
00:49:33 <Saizan> mmorrow_: i only care about serialize :: a -> IO ByteString, deserialize :: ByteString -> IO a :)
00:49:44 <hamishmack> Axman6: if it still does not launch try running /Applications/Leksah.app/Contents/MacOS/Leksah from a terminal
00:50:01 <copumpkin> ah, I doubt it could be that simple with this approach
00:50:16 <Axman6> hamishmack: ah, seems to be a problem wiht old prefs
00:50:16 <hamishmack> and log an issue here http://code.google.com/p/leksah/issues/list
00:50:24 <mmorrow_> Saizan: that's on my to-figure-out list, but that should be no problem if you just generate a .hs with a massive Addr#, then do the O(1) addrToByteString function
00:50:31 <hamishmack> cool
00:50:53 <mmorrow_> Saizan: the Addr# literals get compiled to straight bytes and put into .rodata iirc
00:50:58 <Saizan> mmorrow_: the problem is that i need to do both at runtime
00:51:03 * copumpkin would love if the front-end to leksah were replaceable so we could stick some native cocoa on the front of it for mac os :P
00:51:24 <mmorrow_> Saizan: ohh, i didn't see the `a' type there.. :)
00:51:41 <copumpkin> the ghci machinery could probably do it
00:51:44 <copumpkin> but it wouldn't be pretty
00:52:03 <mmorrow_> Saizan: for this to work at runtime, you'd need to use ObjLink (or equiv) to get the addresses of the ".._static_info" tables you need
00:52:44 <mmorrow_> Saizan: ooh, actually you don't, since you can just use unpackClosure# to get the infoptr (although you'd need to find a static closure of the correct type to get that from..)
00:53:23 <mmorrow_> i wonder what a good interface for this would be if it was exposed by ghc
00:53:45 <Axman6> hamishmack: i dislike this, needing to have the sources still around for ghc. i often to a port clean all to stop my macports stuff being 11GB
00:55:03 <mmorrow_> copumpkin, Saizan: if you happen to mess around with that GenAsm module, i've since made one change to the zenc function (it wasn't encoding tuple cons correctly)
00:55:44 <mmorrow_> i just special-case-hacked in the 2-tuple case zenc "(,)" = "Z2T"
00:56:04 <mmorrow_> i guess (,,) would be Z3T and so on?
00:56:22 <copumpkin> I dunno, the z-encoding document in the ghc manual is broken :P
00:56:35 <hamishmack> copumpkin: There is a OS X style GTK theme, but it needs lots of work.  While the main edit control is still GtkSourceVIew it would be hard not to use Gtk.
00:56:38 <mmorrow_> copumpkin: i stole that zenc/zdec from mauke's preflex code :)
00:56:43 * Axman6 thinks mmorrow_ should change his nick because underscores make him uneasy
00:57:03 <Saizan> ___
00:57:14 <copumpkin> hamishmack: yeah, but gtk apps I've used in the past don't get a lot of the free osx perks you get with cocoa
00:57:14 * Saizan sees Axman6 screaming in terror
00:57:27 <Axman6> ._.
00:57:27 <copumpkin> lol
00:57:30 <mmorrow> :)
00:57:36 <Axman6> ;_;
00:58:12 * Saizan wonders if he should use binary-strict
00:58:32 * Axman6 gets binary-strict with Saizan 
00:58:44 <hamishmack> Axman6: I have the same problem.  I will probably try to sort it out next weekend, if I get a chance.
00:58:44 <copumpkin> don't bring the analysis in
00:59:18 <Axman6> hamishmack: can you just download the ghc sources and provide that as a search path?
00:59:48 <hamishmack> I think that is supposed to work, but I have never managed to get it to work
00:59:54 <Axman6> ok
01:00:01 <Axman6> well, i won't bother with it now then :P
01:00:35 <hamishmack> It won't work I presume, for things that use preprocessors (like gtk2hs)
01:00:57 <hamishmack> for those I think the best solution may be just to make a clean tool
01:01:08 <hamishmack> that cleans the stuff we don't need
01:01:12 <mmorrow> Saizan: so i think the only thing that needs figuring out the best way to do is how to get at the ptr to the (static) info table for constructors at runtime. once that's done, i think it would be easy to serialize/reify an arbitrary `a' (the caveat being it has to be completely made up of datacons, none of which are *Array# or (Foreign)Ptr)
01:01:53 <mmorrow> i guess you could special case *Array# and (Foreign)Ptr stuff somehow, but i'm not sure the best way off the top of my head
01:02:32 <copumpkin> associated types!
01:02:33 <copumpkin> :P
01:02:35 <mmorrow> , length (let x = 1+1; y = (x,x); z = (y,y) in vacuum (z,z))
01:02:38 <lunabot>  4
01:02:48 <mmorrow> , length (let x = 1+1; y = (x,x); z = (y,y) in show (z,z))
01:02:49 <lunabot>  29
01:03:05 <mmorrow> , length (let x = 1+1; y = (x,x); z = (y,y); a = (z,z); b = (a,a) in show (b,b))
01:03:06 <lunabot>  125
01:03:14 <mmorrow> , length (let x = 1+1; y = (x,x); z = (y,y); a = (z,z); b = (a,a) in vacuum (b,b))
01:03:16 <lunabot>  6
01:03:33 <mmorrow> it'd be a massive gain in the cases where there's a lot of sharing
01:05:09 <Saizan> can you "darcs get http://community.haskell.org/~ndm/darcs/derive"?
01:07:05 <mmorrow> yeah
01:25:45 <Gertm> I have an error installing Leksah, when doing something with Gtk: mismatched interface file versions (wanted "6104", got "6103"). How do I solve this?
01:27:14 <doserj> Gertm: you installed gtk2hs with ghc-6.10.3, but are using ghc-6.10.4 now?
01:28:44 <Gertm> doserj: possible, I do everything with the package manager of my arch linux. Lemme check.
01:29:46 <Gertm> doserj: ghc is 6.10.4, do I need to rebuild stuff?
01:29:55 <doserj> I guess so
01:30:06 <Gertm> through cabal or something?
01:30:39 <doserj> gtk2hs is not cabalized, so no.
01:31:08 <Gertm> hmm, arch stuff comes precompiled, I'll have to do it myself
01:31:14 <Saizan> maybe leksah wants to be built with the ghc you're using for things?
01:31:32 <Gertm> Yes, and that's version 6.10.4
01:42:52 <dmwit> Gertm: Complain to the package maintainer, if you've just installed the package yourself.
01:43:08 <dmwit> Gertm: Complain to yourself, if you installed the package a while ago, updated GHC, than ran register.sh again.
01:44:17 <ManateeLazyCat> Have an exist function that match "findCommon :: [[a]] -> [a]" ? Example input: ["abc111", "abc222", "abc333"] and output: "abc"
01:44:52 <hackagebot> stm-io-hooks 0.4.2 - An STM monad with IO hooks (PeterRobinson)
01:44:58 <dmwit> > transpose ["abc111", "abc222", "abc333"]
01:45:00 <lambdabot>   ["aaa","bbb","ccc","123","123","123"]
01:45:00 <ManateeLazyCat> I should ask this function before i create it. Avoid duplicate work.
01:45:31 <ManateeLazyCat> not transpose
01:45:57 <Cale> ManateeLazyCat: transpose is clearly part of a solution though
01:47:04 <dmwit> > let foo xss = let n = length xss in (>>= take 1) . takeWhile (\xs -> xs == (take 1 xs >>= replicate n)) . transpose $ xss in foo ["abc111", "abc222", "abc333"]
01:47:06 <lambdabot>   "abc"
01:47:08 <doserj> > foldr1 Data.List.intersect ["abc111", "abc222", "abc333"]
01:47:10 <lambdabot>   "abc"
01:47:14 <dmwit> ooo
01:47:20 <dmwit> doserj++
01:47:26 <Cale> > map head . takeWhile (\(x:xs) -> all (== x) xs) . transpose $ ["abc111", "abc222", "abc333"]
01:47:27 <dmwit> oh wait
01:47:28 <lambdabot>   "abc"
01:47:40 <ManateeLazyCat> Thanks all.
01:47:46 <dmwit> doserj: oh wait
01:47:46 <ManateeLazyCat> :)
01:48:00 <dmwit> > foldr1 Data.List.intersect ["ab111c", "abc222", "abc333"]
01:48:01 <lambdabot>   "abc"
01:48:06 <ManateeLazyCat> intersect can't work
01:48:11 <Cale> I'm pretty sure that transpose never gives an empty list as one of the elements of its result
01:48:17 <dmwit> also, Cale, you should know better than that:
01:48:22 <Cale> But probably a good idea to check that.
01:48:22 <ManateeLazyCat> intersect try to find common at any place.
01:48:26 <ManateeLazyCat> not just front
01:48:28 <dmwit> > > map head . takeWhile (\(x:xs) -> all (== x) xs) . transpose $ ["abc111", "abc222",
01:48:29 <lambdabot>   <no location info>: parse error on input `>'
01:48:34 <dmwit> > > map head . takeWhile (\(x:xs) -> all (== x) xs) . transpose $ ["abc111", "abc222", "ab"]
01:48:35 <lambdabot>   <no location info>: parse error on input `>'
01:48:38 <dmwit> argh
01:48:41 <dmwit> > map head . takeWhile (\(x:xs) -> all (== x) xs) . transpose $ ["abc111", "abc222", "ab"]
01:48:43 <lambdabot>   "abc"
01:49:07 <Cale> aha, good point
01:50:21 <Cale> Maybe best would just be to find the longest common prefix of a pair, and use foldr1
01:50:42 <ManateeLazyCat> Thanks all for help, i code it self.
01:50:45 <dmwit> Probably, yeah.
01:50:54 <ManateeLazyCat> I just don't want do duplicate work
01:51:09 <dmwit> ManateeLazyCat: Right, it doesn't exist.  Mine should work, or write your own.
01:51:24 <dmwit> ("foo" above)
01:52:36 <Cale> hmm, I wonder what the most elegant longestCommonPrefix :: (Eq a) => [a] -> [a] -> [a] we can come up with is.
01:52:59 * ManateeLazyCat pasted "intersectFront" at http://paste2.org/get/357679
01:53:01 <ManateeLazyCat> Cale: Above,
01:53:21 <ManateeLazyCat> Cale: Now i'm coding "intersect' :: Ord a => [[a]] -> [a]"
01:53:29 <inad922> Anyone using gentoo and managed to make leksah 0.6.1 compile from the haskell overlay?
01:53:42 <Cale> ManateeLazyCat: don't use head and tail there. Pattern match at least.
01:54:10 <ManateeLazyCat> Cale: Okay, i improve it.
01:55:54 <dmwit> > let foo xs ys | listToMaybe xs /= listToMaybe ys = [] | null xs || null ys = [] | otherwise = head xs : foo (tail xs) (tail ys) in foo "abc123" "abc321"
01:55:56 <lambdabot>   "abc"
01:56:07 * ManateeLazyCat pasted "intersectFront" at http://paste2.org/get/357684
01:56:14 <ManateeLazyCat> Cale: Above improve version, thanks!
01:56:15 <Cale> @let longestCommonPrefix xs ys = map snd . takeWhile fst $ zipWith (\x y -> (x == y, x)) xs ys
01:56:16 <lambdabot>  Defined.
01:57:01 <Cale> > foldr1 longestCommonPrefix ["abc111", "abc222", "ab"]
01:57:04 <lambdabot>   "ab"
01:57:14 <Cale> > foldr1 longestCommonPrefix ["abc111", "abc222", "abc333"]
01:57:16 <lambdabot>   "abc"
01:57:35 <ManateeLazyCat> Cale: Thanks for longestCommonPrefix
01:58:45 <dmwit> let lcp xs ys = concat $ zipWith (\x y -> guard (x == y) >> return x) xs ys
01:58:48 <dmwit> ?let lcp xs ys = concat $ zipWith (\x y -> guard (x == y) >> return x) xs ys
01:58:50 <lambdabot>  Defined.
01:59:00 <dmwit> > lcp ["abc111", "abc222", "abc333"]
01:59:02 <lambdabot>   Overlapping instances for GHC.Show.Show
01:59:02 <lambdabot>                              ([[GHC...
01:59:05 <dmwit> err
01:59:07 <dmwit> :t lcp
01:59:08 <lambdabot> forall b. (Eq b) => [b] -> [b] -> [b]
01:59:16 <dmwit> right
01:59:22 <dmwit> > lcp "abc111" "abc222"
01:59:24 <lambdabot>   "abc"
01:59:26 <Cale> > foldr1 lcp ["abc111", "abc222", "abc333"]
01:59:29 <lambdabot>   "abc"
02:00:02 <Cale> hmm
02:00:21 <Cale> > lcp "abc111" "abc211"
02:00:23 <lambdabot>   "abc11"
02:00:31 <dmwit> whoops =P
02:00:52 <Cale> Yeah, I thought that looked a little too good to be true :)
02:03:21 <ManateeLazyCat> Cale: I study something, just write function that match `two` element, then use foldr1 can match all element in list.
02:03:33 <Cale> ManateeLazyCat: right
02:04:11 <ManateeLazyCat> Cale: I think this principle can make my code more simpler, thanks!
02:04:52 <Cale> ManateeLazyCat: The reason that it's foldr1 and not foldr is that there's no natural way to handle the empty list. In some sense, any prefix would be in common with all the members of the empty list (because there are none)
02:05:10 <ManateeLazyCat> Cale: Before i read your code, i try to use recursive write function that match all elements in list
02:06:18 <dmwit> newtype LCP a = LCP (Maybe [a]); instance Monoid (LCP a); lcp = msum . map (LCP . Just) -- ;-)
02:06:35 * ManateeLazyCat brb
02:07:44 <dmwit> oh
02:07:51 <dmwit> You can't hide the partiality quite that way.
02:08:09 <dmwit> lcp = fromJust . unLCP . msum . map (LCP . Just) -- looking less and less elegant as time goes on
02:08:30 <dmwit> also, s/msum/mconcat/ maybe
02:10:16 <Cale> > let lcp xs ys = [x | (x,y) <- zip xs ys, then takeWhile by (x == y)] in lcp "abc111" "abc211"
02:10:18 <lambdabot>   Illegal transform or grouping list comprehension: use -XTransformListCompNo...
02:10:27 <Cale> oh well :)
02:10:37 <Cale> Needs TransformListComp
02:10:39 <ray> > n : repeat 'o'
02:10:40 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
02:10:55 <ray> sdjkgahkl
02:12:43 <dmwit> > n : repeat o
02:12:45 <lambdabot>   [n,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,...
02:13:08 <Cale> > 'n' : repeat 'o'
02:13:09 <lambdabot>   "nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
02:14:24 <dmwit> > let lcp xs ys = [x | x <- xs | y <- ys, x == y] in lcp "abc111" "abc222" -- even if this works, it's buggy
02:14:25 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
02:14:45 <dmwit> ...huh?
02:14:53 <Cale> uhh...
02:15:11 <Cale> @undefine
02:15:14 <copumpkin> weird scoping for parallel list comprehensions?
02:15:21 <Cale> > let lcp xs ys = [x | x <- xs | y <- ys, x == y] in lcp "abc111" "abc222"
02:15:23 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
02:15:29 <Cale> whaaaaaaat
02:15:47 <Cale> oh, er...
02:16:11 <Cale> right, that's what it is
02:16:31 <Cale> , binds stronger than | of course
02:16:32 <lunabot>  luna: parse error on input `|'
02:16:37 <Cale> Sorry luna
02:16:54 <dmwit> hum
02:17:12 <dmwit> > let lcp xs ys = [x | x <- xs | y <- ys | x == y] in lcp "abc111" "abc222"
02:17:14 <lambdabot>   ""
02:17:36 <Cale> Well... that's interesting
02:17:38 <dmwit> That's a good puzzle for people who haven't seen this conversation. =)
02:17:48 <dmwit> I think 'x' and 'y' are now *both* SimpleReflects.
02:17:54 <Cale> yeah, probably
02:18:00 <ManateeLazyCat> "test xs ys = [x | (x,y) <- zip xs ys, then takeWhile by (x == y)]" looks so neat
02:18:27 <ManateeLazyCat> neat than my version at http://paste2.org/get/357684
02:19:00 <Cale> If you don't want to use the extension, there's my previous version as well, which I think is more or less the desugaring of that.
02:22:01 <ManateeLazyCat> > let lcp xs ys = [x | x <- xs, y <- ys, x == y]
02:22:02 <lambdabot>   not an expression: `let lcp xs ys = [x | x <- xs, y <- ys, x == y]'
02:22:11 <ManateeLazyCat> @let lcp xs ys = [x | x <- xs, y <- ys, x == y]
02:22:12 <lambdabot>  Defined.
02:22:23 <dmwit> That's definitely not what you want.
02:22:31 <dmwit> > lcp "aa" "aaa"
02:22:33 <lambdabot>   "aaaaaa"
02:23:10 <dmwit> > let lcp xs ys = [x | x == y | x <- xs | y <- ys] in lcp "abc111" "abc222"-- hmmm...
02:23:12 <lambdabot>   ""
02:23:27 <Cale> > lcp "abracadabra" "abracadabra"
02:23:27 <dmwit> I clearly don't understand parallel list comprehensions. =P
02:23:29 <lambdabot>   "aaaaabbrraaaaacaaaaadaaaaabbrraaaaa"
02:23:55 <dmwit> It's a veeery difficult spell. =D
02:27:27 <Cale> I wonder exactly what would be needed to support an analogue of TransformListComp in arbitrary monads.
02:28:14 <Cale> The GHC manual doesn't give a clear translation rule, maybe the paper does
02:32:28 <ManateeLazyCat> "test xs ys = [x | (x,y) <- zip xs ys, then takeWhile by (x == y)]" can simpler?
02:33:35 <Cale> ManateeLazyCat: The only problem with that expression is that it requires a language extension.
02:33:50 <Cale> (and it happens to be a language extension which isn't very widely used)
02:34:16 <ManateeLazyCat> Cale: Yep, i have add TransformListComp option in my source code.
02:35:03 <Cale> I don't think it's otherwise possible to make it any simpler.
02:35:13 <ManateeLazyCat> Cale: List comprehensions is very neat, even it so abstract
02:37:04 <ManateeLazyCat> Cale: What's language extension? It will merge into Language Standard someday?
02:37:31 <Cale> ManateeLazyCat: The way things are going, the standard is going to become a conglomeration of possible extensions anyway.
02:38:22 <Cale> ManateeLazyCat: But basically all the language features since Haskell98 have been separated into extensions which you have to switch on to use.
02:38:44 <ManateeLazyCat> Cale: I see, when time release next Haskell standard report like Haskell98?
02:38:52 <Cale> ManateeLazyCat: {-# LANGUAGE ... #-} pragmas are supported by at least GHC and Hugs, and maybe a couple other compilers.
02:39:29 <Cale> ManateeLazyCat: People have been working on the next release of the standard. It's kind of a boring process, since for the most part, the idea is to standardise existing functionality.
02:39:44 <ManateeLazyCat> Cale: I found i have enable some options with GHC, like ExistentialQuantification, RankNTypes, TransformListComp
02:39:52 <Gracenotes> > let lcp = (=<<) =<< ((fromMaybe "" .) . flip lookup . map (head &&& id) . group . sort) in lcp "abracadabra"
02:39:54 <lambdabot>   "aaaaabbrraaaaacaaaaadaaaaabbrraaaaa"
02:40:07 <Cale> Gracenotes: ...
02:40:08 <Gracenotes> what was that function supposed to do
02:40:08 <Cale> :)
02:41:02 <Gracenotes> :O the main way to get it more efficient would probably be to use Maps
02:41:03 <Cale> ManateeLazyCat: You can see all the supported language options using  ghc --supported-languages  by the way
02:41:04 <ManateeLazyCat> Cale: I don't think that's boring process, i think that's interesting and significant process.
02:41:27 <Cale> ManateeLazyCat: Well, it is somewhat interesting, but I find it way less interesting than papers which describe new ideas :)
02:41:42 <ManateeLazyCat> Cale: Wow, some many options
02:41:50 <ManateeLazyCat> :)
02:42:12 <Gracenotes> and to precompute the Map somehow, instead of doing it on every letter.. hm.. you'd need let for that..
02:42:31 <Cale> Gracenotes: I think that's the first time I've ever seen someone (=<<) =<< ...
02:42:31 <Gracenotes> oh wait, it already is precomputed. nevermind.
02:43:02 <Gracenotes> it's very pointless, isn't it? ^_^
02:43:52 <Gracenotes> of course, you could just say lcp w = concatMap (... $ w) w
02:44:53 <ManateeLazyCat> Gracenotes: Cale's List comprehensive is neat "intersectFront xs ys = [x | (x,y) <- zip xs ys, then takeWhile by (x == y)]"
02:46:00 <Cale> Gracenotes: (That was a messed up version of what we were actually writing)
02:46:48 <Gracenotes> > let lcp = (=<<) =<< ((fromMaybe "" .) . flip Data.Map.lookup . Data.Map.fromAscList . map (head &&& id) . group . sort) in lcp "Well now it's as efficiently messed up as easily possible"
02:46:50 <lambdabot>   Not in scope: `Data.Map.lookup'Not in scope: `Data.Map.fromAscList'
02:47:02 <Gracenotes> ;_; oh, lambdy. *pat* *pat*
02:47:07 <copumpkin> failnotes
02:47:08 <Gracenotes> Cale: what does it actually do?
02:47:16 <copumpkin> longest common prefix?
02:47:29 <Gracenotes> ooooh.
02:47:39 <Gracenotes> neat.
02:48:24 <copumpkin> :t (takeWhile (uncurry (==)) .) . zip
02:48:28 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [(a, a)]
02:48:35 <copumpkin> :t map fst . (takeWhile (uncurry (==)) .) . zip
02:48:37 <lambdabot>     Couldn't match expected type `[(a, b)]'
02:48:37 <lambdabot>            against inferred type `[a1] -> [(a1, a1)]'
02:48:37 <lambdabot>     In the second argument of `(.)', namely
02:48:44 <copumpkin> :t (map fst . takeWhile (uncurry (==)) .) . zip
02:48:46 <lambdabot>     The operator `.' [infixr 9] of a section
02:48:46 <lambdabot>         must have lower precedence than that of the operand,
02:48:46 <lambdabot>           namely `.' [infixr 9]
02:48:48 <copumpkin> meh
02:49:23 <Gracenotes> hm.. so it's really taking 11 hours to download all these packages
02:50:52 <Gracenotes> I wonder how long it will take to install them
03:00:21 <copumpkin> , maxBound
03:00:22 <lunabot>  ()
03:00:25 <copumpkin> , maxBound :: Int
03:00:26 <lunabot>  2147483647
03:01:15 <Peaker> > maxBound :: Word16
03:01:17 <lambdabot>   65535
03:01:25 <Gracenotes> word.
03:01:32 <copumpkin> paragraph.
03:01:32 <Peaker> ;-)
03:06:38 <lysgaard> Anyone else having problems with the missingg "haskell-cabal" package from AUR in Arch?
03:06:52 <vegai> lysgaard: why is it a problem?
03:07:22 <vegai> ghc provides it...
03:07:24 <lysgaard> vegai: I'm trying to install the haskell-platform package, but it depends on haskell-cabal
03:07:47 <vegai> even with ghc providing it? That's odd
03:08:00 <lysgaard> vegai: So haskell-cabal is obsolete, and the reason it's gone is that it's in ghc?
03:08:17 <vegai> yes
03:08:39 <vegai> are you using yaourt?
03:08:52 <lysgaard> vegai: Yes
03:09:51 <lysgaard> vegai: Then maybe all packages in arch is broken now, atleast if they're auto generated. Almost all of the depend on haskell-cabal
03:10:27 <vegai> could be
03:10:35 <vegai> are you on x86_64 or i686?
03:10:52 <lysgaard> vegai: i686
03:11:45 <lysgaard> vegai: Err, i think this is _bad_. I can't install any haskell packages, because all of them have a obsolete dependency for haskell-cabal
03:12:00 <vegai> through yaourt at least
03:12:08 <vegai> you could install cabal-install and use that
03:12:50 <vegai> yaourt has proven to be less than an ideal tool for haskell stuff, imho
03:12:55 <lysgaard> vegai: There's just a handfull of the haskell packages that are in the comunity and extra repo thou? Not nearly enough.
03:13:21 <vegai> yeah, because we essentially have just one developer for them
03:13:29 <vegai> and not much automation yet
03:14:40 <lysgaard> vegai: Yeah, i know. I did that before. But now i deleted everything, and was planning a haskell reinstall, to get some order in my files. (Use AUR when possible etc.) Now it seem's i cant install nearly anything from yoaurt.
03:15:11 <vegai> I could kludgefix this by providing an empty haskell-cabal package in community
03:15:39 <vegai> by the way, we have a dedicated channel for this, #arch-haskell
03:17:19 <vegai> then again, no other discussion is going on...
03:17:32 <vegai> lysgaard: pacman -S haskell-cabal offers to install ghc for you, right?
03:18:35 <lysgaard> vegai: yeah it doespp
03:20:03 <vegai> then it's just yaourt not being smart enough to realize it :-/
03:20:24 <vegai> I'll try it myself...
03:20:34 <vegai> hmm, wait
03:20:36 <vegai> I get
03:20:38 <vegai> ==> haskell-platform dependencies:
03:20:39 <vegai> ..
03:20:42 <vegai>  - haskell-cabal (package that provides haskell-cabal already installed)
03:20:52 <vegai> ah, he left.
03:39:34 <fxr> ~.
03:43:27 <hackagebot> persistent-map 0.3.3 - A thread-safe interface for finite map types with optional persistency support. (PeterRobinson)
03:43:34 <fxr> ~.
03:45:24 <Cale> fxr: ?
03:47:12 <mapreduce> That looks like a failed attempt at closing an ssh connection.
03:48:01 <fxr> sorry, typo.
03:48:17 <fxr> I'm having connection problems in starbucks
03:57:04 <Athas> How come so many modules on Hackage are labelled 'experimental'?  Even Control.Monad.State!
03:57:26 <Peaker> Athas: Well, they did get the order of the result tuple wrong :)
03:58:11 <Athas> Perhaps!  But 'experimental' makes it sound like it does unsafePerformIO all over the place and may segfault at a momens notice.
03:58:36 * ManateeLazyCat pasted "deleteMap" at http://paste2.org/get/357712
03:58:36 <ManateeLazyCat> How to change above code to "List Comprehensive" style?
04:00:07 <Cale> deleteMap xs ys = ys \\ xs
04:00:44 <Cale> I don't think there's a way to do it with list comprehensions, but I could be wrong.
04:00:50 <Athas> What's your opinion on 'where' clauses?  Should they be preceded by a blank line?
04:01:04 <Cale> Athas: I never put a blank line before mine.
04:01:22 <Athas> Do you normally put in type signatures?
04:01:24 <Cale> Athas: Unless you mean starting them on a new line
04:01:41 <sioraiocht> [ y | y <- ys, not (elem xs)]
04:01:42 <sioraiocht> ?
04:01:45 <Cale> I normally put in type signatures for top-level definitions before I release something.
04:01:53 <sioraiocht> [ y | y <- ys, not (elem y xs) ]
04:01:58 <Cale> sioraiocht: Not quite the same thing
04:02:00 <Athas> Well of course, but what about local bindings in where-clauses?
04:02:11 <Cale> Athas: Not if I can avoid it.
04:02:24 <sioraiocht> Cale: why not?
04:02:45 <Cale> sioraiocht: because the deletions are used up
04:02:52 <Cale> (as they remove items)
04:03:07 <Cale> So an element in xs only removes at most one element from ys
04:03:22 <Cale> > "abracadabra" \\ "aa"
04:03:24 <lambdabot>   "brcadabra"
04:03:26 <sioraiocht> Cale: ohhhh
04:03:28 <sioraiocht> okay
04:03:56 <sioraiocht> damn, can't believe I missed that
04:04:36 <ManateeLazyCat> Cale: So my `deleteMap` just a REVERSE action of Data.List.(\\)?
04:05:20 <fxr> c
04:05:23 <fxr> ~.
04:05:35 <Athas> flip (\\)
04:05:53 <Athas> Flip has got to be the simplest function that can make code totally unreadable.
04:06:57 * ManateeLazyCat I think i should use (\\) replace deleteMap.
04:08:30 <benmachine> @index (\\)
04:08:30 <lambdabot> bzzt
04:08:37 <sioraiocht> Athas: yes, it's one of those things that can be very confusing in point-free functions
04:08:39 <benmachine> why am I getting bzzt'd
04:08:59 <sioraiocht> :t (//)
04:09:00 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
04:09:05 <sioraiocht> :t (\\)
04:09:07 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
04:09:17 <sioraiocht> well that's not confusing
04:09:33 <sioraiocht> there really needs to be a "sequence" type class for things like that...
04:10:52 <Cale> / is totally unrelated
04:10:55 <Cale> er //
04:11:14 <Cale> The // operator does an array update
04:16:41 * ManateeLazyCat pasted "different" at http://paste2.org/get/357732
04:16:42 <ManateeLazyCat> How to change above code to "List Comprehensive" style?
04:17:00 <ManateeLazyCat> I don't know how to write List Comprehensive code fast.
04:17:10 <ManateeLazyCat> Even result is simple,
04:18:37 <Botje> you have to use parallel list comprehensions for that
04:18:41 <Botje> and that's a GHC extension
04:18:52 <ManateeLazyCat> Botje: Just give me example.
04:19:11 <ManateeLazyCat> Botje: I'm confusion with PARALLEL list comprehensive
04:19:12 <Botje> i don't know the syntax by heart.
04:19:25 <Botje> but you can squeak by with zip, i think
04:19:40 <Cale> ManateeLazyCat: Not everything is a list comprehension
04:20:08 <ManateeLazyCat> Cale: Yep, i know, but list comprehensive is so neat
04:20:36 * Saizan wonders why hp2any is in a svn repo
04:20:47 <Botje> [ x | (x,y) <- zip xs ys, x /= y ]
04:20:50 <Cale> ManateeLazyCat: That is a really really strange function
04:20:56 <Botje> but that drops the length requirement.
04:21:28 <Cale> You want the elements of the first list which are different from the elements of the second list, but only if the lengths of the lists are the same in which case you want an empty list.
04:22:20 <Cale> Yeah, Botje shows how to write it as a comprehension if you don't mind the length thing.
04:22:50 <Cale> Measuring the lengths of lists is something that I usually think of as a very strange thing to do.
04:23:19 <opqdonut> sum [ 1 | x <- xs]
04:23:20 <opqdonut> ;)
04:23:23 <Cale> Well, particularly in a guard.
04:23:40 <ManateeLazyCat> Cale: I use it in a speical case. :0
04:23:42 <ManateeLazyCat> :)
04:24:54 <RayNbow> opqdonut: getSum . foldMap (const$Sum 1)
04:25:44 <opqdonut> there should be a monoid-generalised concatmap ;)
04:26:08 <RayNbow> :t foldMap
04:26:09 <lambdabot> Not in scope: `foldMap'
04:26:19 <RayNbow> @let foldMap f xs = Data.Foldable.foldMap f xs
04:26:21 <lambdabot>  Defined.
04:26:23 <RayNbow> :t foldMap
04:26:24 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
04:28:31 <ManateeLazyCat> Cale: Example, i have a list that contain filename, such as A, then i do unique action to A list to make every filename unique, then i got B list. Now A and B is list that have same length, then i use `different` function to filter `different element` (the element that filename changed) in two list, last update filename that has changed.
04:28:36 <EvilRanter> > getSum . foldMap Sum $ Node x [Node y [], Node z [Node a []]]
04:28:38 <lambdabot>   x + (y + 0 + (z + (a + 0 + 0) + 0))
04:29:48 <ManateeLazyCat> Cale: I found `zip` is generic method to write parallel list comprehensive.
04:30:08 * EvilRanter ponders a not-so-simple-reflect that algebraically simplifies expressions, so that'd be "x + y + z + a"
04:30:38 <EvilRanter> ManateeLazyCat, well, that's using zip to traverse lists in parallel; the comprehension's still a standard comprehension
04:30:44 <mercury^> EvilRanter: Maybe integrate reflction with docon?
04:31:14 <EvilRanter> ManateeLazyCat, the "parallel list comprehension" extension's new syntax de-sugars to zip anyway, if i remember right
04:31:37 <EvilRanter> ?where docon
04:31:37 <lambdabot> I know nothing about docon.
04:31:44 <EvilRanter> ?where+ docon http://www.haskell.org/docon/
04:31:44 <lambdabot> Good to know.
04:31:56 <EvilRanter> mercury^, that looks shiney :)
04:32:03 * ManateeLazyCat pasted "different" at http://paste2.org/get/357736
04:32:06 <ManateeLazyCat> Now simpler.
04:32:36 <stanv> how to write function, that takes 2 strings, and put between then ' ' ? (++ " " ++) or (++ (" " ++)) - doesn't work
04:33:06 <EvilRanter> ManateeLazyCat, do you really need the "xLen /= yLen = []
04:33:06 <EvilRanter> "? from what you were saying, the lists should always be the same length as you plan to use this function anyway
04:33:07 <lilac> @@ @pl @run getSum . foldMap Sum $ Node x [Node y [], Node z [Node a []]]
04:33:09 <lambdabot>  x + y + z + a
04:33:22 <opqdonut> stanv: why not just \x y -> x ++ " " ++ y
04:33:23 <lilac> EvilRanter: ^^ that'll work a lot of the time
04:33:27 <benmachine> @pl \a b -> a ++ " " ++ b
04:33:27 <opqdonut> of course:
04:33:27 <lambdabot> (. (' ' :)) . (++)
04:33:33 <ManateeLazyCat> EvilRanter: Just for safe.
04:33:34 <opqdonut> ah, somebody did the pl already
04:33:36 <EvilRanter> lilac, nice. albeit hacky :)
04:33:37 <stanv> (++).(" " ++ )
04:33:39 <stanv> :))
04:33:39 <lilac> :)
04:33:58 <forest> can not understand conversion: (lambda x.g (x x)) (lambda x.g (x x)) <==>  g ((lambda x.g (x x)) (lambda x.g (x x))  in fixed point operator
04:34:01 <ManateeLazyCat> EvilRanter: Avoid use `different` function wrong way.
04:34:41 <EvilTerran> ManateeLazyCat, but is it worth traversing the lists an extra time just to check for a precondition?
04:35:38 <benmachine> ManateeLazyCat: if it will never be used like that, maybe error "you're doing it wrong!" would be more appropriate
04:35:47 <EvilTerran> ^ i agree
04:36:06 <opqdonut> forest: it's just a substitution
04:36:07 <doserj> forest: do you understand (lambda x.g (x x)) f ==> g (f f) ?
04:36:11 <EvilTerran> "error" is for branches that should never be evaluated
04:36:36 <forest> doserj: yes, i understand that
04:36:41 <EvilTerran> you could also write it recursively with the Maybe monad to avoid the extra traversal
04:37:57 <doserj> forest: then just put (lambda x.g (x x)) in the place of f
04:38:11 <EvilTerran> ... or even without the Maybe monad, if "error"'s suitable for the exceptional case: diff (x:xs) (y:ys) | (x == y) = diff xs ys | otherwise = x : diff xs ys; diff [] [] = []; diff _ _ = error "diff: lists not the same length!"
04:38:44 <forest> doserj: aha... thanks
04:39:22 * EvilTerran randomly notes that the join of a tree monad is akin to substitution
04:40:38 <stanv> i can't solve problem in my mind, i write programs in haskell by intuition
04:42:03 <EvilTerran> (data Tree a = Leaf a | Tree a :+: Tree a; fmap f (Leaf a) = Leaf (f a); fmap f (l :+: r) = fmap f l :+: fmap f r; return = Leaf; join (Leaf t) = t; join (l :+: r) = join l :+: join r)
04:42:27 <EvilTerran> the type "Tree (Tree a) -> Tree a" makes me think of substitution, anyway
04:44:01 <benmachine> you don't need to define join do you?
04:44:13 <benmachine> I suppose you need to define either join or >>=
04:45:27 <benmachine> oh I am not paying attention
04:45:43 <Saizan> EvilTerran: >>= is more like substitution, as i see it
04:46:10 <Saizan> EvilTerran: but yeah, that's the concept behind the free monad
04:47:42 <EvilTerran> benmachine, yeah, i just defined join instead of >>= because it seemed a lot easier
04:48:34 <ManateeLazyCat> EvilTerran: You're right, i should throw a error for condition never reach.
04:48:51 <EvilTerran> i wasn't sure how >>= would work until i defined join as above and "m >>= f = join (fmap f m)", and played with it a bit to get an intuition
04:48:58 <ManateeLazyCat> EvilTerran: Now i throw error when two list's length is not same.
04:49:14 <ManateeLazyCat> EvilTerran: Then can avoid design error.
04:50:22 <EvilTerran> sounds good :)
04:50:46 <ManateeLazyCat> Thanks for suggestion! :)
04:51:59 <lilac> EvilTerran: >>= has the right type to be list substutituion. list substitution is associative, and return = Leaf is the identity, so that's a monad
04:52:15 <lilac> s/list/leaf
04:52:21 * lilac has brain fail today
04:52:52 * ManateeLazyCat Always use >>= or =<<
04:53:18 <EvilTerran> lilac, yeah, i worked that out after a bit of playing in ghci; join just seemed easier to write to start with
04:54:23 <lilac> yeah, there's something quite obvious about what a "tree of trees -> tree" operation does
04:54:45 <lilac> (or at least what it might do :) )
04:54:55 * lilac wonders if trees form a monad in any other way
04:55:29 <lilac> i guess that, like lists, infinite trees form a ziptree monad, but finite trees don't have any other valid instance
04:58:08 <lilac> presumably mapping toList over any tree monad would give a list monad in some sense, so that restricts the possibilities a lot
05:03:48 <hackagebot> bluetileutils 0.1 - Utilities for Bluetile (JanVornberger)
05:04:52 <hackagebot> xmonad-bluetilebranch 0.8.1 - A tiling window manager (JanVornberger)
05:05:52 <hackagebot> xmonad-contrib-bluetilebranch 0.8.1 - Third party extensions for xmonad (JanVornberger)
05:06:52 <hackagebot> bluetile 0.1 - A modern tiling window manager with a gentle learning curve (JanVornberger)
05:29:01 <hackagebot> HPlot 0.2 - A minimal monadic PLplot interface for Haskell (YakovZaytsev)
05:29:01 <hackagebot> hashed-storage 0.3.7 - Hashed file storage support code. (PetrRockai)
05:41:00 <Raevel> mutable arrays in ST or IO, how do i choose?
05:43:02 <tgbrooks> I'm reading A Gentle Introduction. Section 10.3: says "fromInteger :: (Num a) => Integer -> a". How does that make any sense?
05:43:25 <tgbrooks> Isn't that return type illogical?
05:43:56 <integral> in what way do you think so?
05:44:13 <tgbrooks> It's not based on any input
05:44:16 <tgbrooks> and yet it's polymorphic
05:44:33 <integral> that doesn't matter,  haskell's type inference still works
05:44:53 <tgbrooks> how? If I do fromInteger 5, how does it know what type to make it?
05:45:04 <lilac> tgbrooks: it doesn't know until you use the result somewhere
05:45:08 <athos> @type fromInteger 5
05:45:08 <idnar> tgbrooks: on its own, that value would be polymorphic
05:45:10 <lambdabot> forall a. (Num a) => a
05:45:28 <athos> @type fromInteger 5 :: Complex Int
05:45:30 <lambdabot>     No instance for (RealFloat Int)
05:45:30 <lambdabot>       arising from a use of `fromInteger' at <interactive>:1:0-12
05:45:30 <lambdabot>     Possible fix: add an instance declaration for (RealFloat Int)
05:45:38 <lilac> tgbrooks: given f :: Int -> Int; g :: Double :: Double, you can say 'f (fromInteger 5)' and 'g (fromInteger 5)'
05:45:41 <athos> heh
05:45:46 <athos> @instances Num
05:45:48 <lambdabot> Double, Float, Int, Integer
05:45:50 <lilac> tgbrooks: in the first case it's an Int, and in the second case it's a Double
05:46:05 <tgbrooks> okay that's pretty cool
05:46:17 <athos> @type fromInteger 5 :: Double
05:46:18 <lambdabot> Double
05:46:42 <dino-> > :t (fromInteger 5) / (fromInteger 3)
05:46:43 <lambdabot>   <no location info>: parse error on input `:'
05:46:49 <tgbrooks> But it's still weird to me. I thought you can't have something of type a -> b
05:46:53 <dino-> :t (fromInteger 5) / (fromInteger 3)
05:46:55 <lambdabot> forall a. (Fractional a) => a
05:47:03 <dino-> :t (fromInteger 5) `mod` (fromInteger 3)
05:47:04 <lambdabot> forall a. (Integral a) => a
05:47:22 <integral> @type f _ = error "haskell has bottoms"
05:47:23 <lambdabot> parse error on input `='
05:47:28 <Cale> tgbrooks: Aside from something completely undefined, you can't, but this isn't of type a -> b, it's of type (Num a) => Integer -> a
05:47:30 <integral> @type \ _ -> error "haskell has bottoms"
05:47:32 <lambdabot> forall t a. t -> a
05:47:38 <lilac> @type const undefined
05:47:40 <lambdabot> forall a b. b -> a
05:48:10 <Cale> tgbrooks: and the fact that a is a numeric type means that it will have an implementation of fromInteger
05:48:18 <benmachine> !src Num
05:48:19 <benmachine> er
05:48:19 <tgbrooks> Cale: ah okay
05:48:22 <benmachine> @src Num
05:48:22 <lambdabot> class  (Eq a, Show a) => Num a  where
05:48:22 <lambdabot>     (+), (-), (*)           :: a -> a -> a
05:48:22 <lambdabot>     negate, abs, signum     :: a -> a
05:48:22 <lambdabot>     fromInteger             :: Integer -> a
05:48:57 <elvenporn> I'm tempted to bring up 'return' as an example of a virtual constructor
05:49:06 <whoknows> any GADT wonks around?
05:49:15 <opqdonut> i've used them somewhat
05:49:40 <inad922> benmachine, how can I do @src like stuff in ghci?
05:49:52 <inad922> :t?
05:50:00 <tgbrooks> inad922: yeah, that's what I was just wondering
05:50:06 <elvenporn> you can't
05:50:08 <benmachine> inad922: you can't
05:50:12 <tgbrooks> Ohh :(
05:50:14 <benmachine> well
05:50:23 <elvenporn> try @info for something not entirely different
05:50:29 <elvenporn> er, :info
05:50:33 <benmachine> if you do :info Num
05:50:45 <benmachine> then that gives you a similar thing for classes
05:50:46 <whoknows> it seems that a GADT constructor is defined by a type schema and a set of constraints
05:50:49 <inad922> aha thanks elvenporn
05:50:50 <tgbrooks> in GHCi :t works apparnetly
05:50:50 <benmachine> for functions you just have to find the source
05:51:04 <benmachine> yeah :t gives you type
05:51:07 <whoknows> how do you generate the constraints based on the type schema you type into haskell? (for example, Term a -> Term b -> Term (a,b)
05:51:15 <benmachine> :info gives you other stuff
05:51:34 <lilac> whoknows: you mean in 'data Term a where Foo :: Term a -> Term b -> Term (a, b)'?
05:51:43 <opqdonut> whoknows: what do you mean by constraints?
05:52:05 <benmachine> lambdabot's @src is just read from a text file which I can give you if you like
05:52:14 <benmachine> although I don't know if my version is the most up-to-date one
05:52:23 <whoknows> lilac, yeah
05:52:42 <benmachine> (you can also download it yourself by cabal installing lambdabot)
05:52:48 <benmachine> (but that's a bit of a headache tbh)
05:52:50 <whoknows> opqdonut, well, in the case of Term a -> Term b -> Term (a,b) you have Term a -> Term b -> Term c where c = (a,b)
05:53:05 <inad922> aw no thanks Its just my laziness so I dont have to look up on the site or anywhere else but thanks benmachine
05:53:15 <opqdonut> whoknows: ah yes, the type family extension brought equality constraints
05:53:27 <opqdonut> so you can say something like "c ~ (a,b) => Term a -> Term b -> Term c"
05:54:07 <whoknows> right
05:54:27 <whoknows> now how do you go from one form to another?
05:54:41 <lilac> whoknows: that GADT is identical (in 6.10 with type families) to "data Term c = forall a b. (c ~ (a,b)) => Foo (Term a) (Term b)". does that help?
05:55:26 <whoknows> lilac, I was actually wondering about how to generate the constraints/new type variables
05:55:28 <lilac> whoknows: start with a unique name for your type constructor arguments. then use ~ to match that against the returned type of the value constructor
05:55:33 <whoknows> but it's interesting that you can do it with type families
05:55:57 <whoknows> lilac, but if I make all my type constructor arguments I can run into problems
05:55:59 <whoknows> for example
05:56:30 <whoknows> Foo :: * -> * -> * where Bar :: Foo a b -> Foo a c -> Foo a (b,c)
05:57:02 <whoknows> using your algorithm I would get Bar :: Foo a b -> Foo a c -> Foo d e where d = a and e = (b,c)
05:57:09 <lilac> yep
05:57:14 <benmachine> so a MonadPlus is basically any Monad that is also a Monoid am I right
05:57:16 <lilac> that's the right answer, isn't it?
05:58:27 <opqdonut> benmachine: + some laws, yes
05:58:28 <lilac> benmachine: yeah. i believe it's common for the monoid's identity to be the monad's fail, but as i recall there aren't any laws to that effect
05:58:46 <benmachine> k
05:59:10 <whoknows> it works (kinda), but a simpler answer is Bar :: Foo a b -> Foo a c -> Foo a d where d = (b,c)
05:59:25 <whoknows> inference works better in my case too
05:59:31 <whoknows> err, with my solution
05:59:34 <opqdonut> why isn't the simpler answer "Foo a b -> Foo a c -> Foo a (b,c)"
05:59:43 <opqdonut> i mean, why would you want to allow your version but not that
05:59:58 <lilac> whoknows: those two types are equivalent, so i don't see the problem :)
06:00:28 <whoknows> opqdonut, that's the simplest version, but not permitted since the conclusion must be of the form Foo alpha_1 alpha_2 where alpha_1 and alpha_2 are unique type variables
06:00:46 <whoknows> lilac, the type inference engine handles them differently
06:00:55 <whoknows> one introduces an extra constraint
06:01:12 <opqdonut> x=y constraints map to simple substitutions in the constraint resolving phase
06:01:15 <lilac> whoknows: interesting. do you have an example where they're not treated equivalently?
06:01:16 <opqdonut> so i don't see the problem
06:01:21 <opqdonut> you could even eliminate them right away
06:03:27 <whoknows> http://research.microsoft.com/en-us/um/people/simonpj/papers/gadt/implication_constraints.pdf <---doesn't mention this kind of constraint elimination anywhee
06:03:30 <whoknows> anywhere
06:04:56 <lilac> can you think of any way to distinguish the two types?
06:06:12 <whoknows> take \x -> match x with Bar c d -> c + 4
06:06:30 <whoknows> in my version you simply unify the type of c with int and you get Foo int c -> int
06:07:19 <whoknows> whereas in your version I would be inclined to not unify and give a rigid type error
06:11:37 <hackagebot> HsOpenSSL 0.6.5 - (Incomplete) OpenSSL binding for Haskell (MasatakeDaimon)
06:20:15 <pastah> in this line from GHCI "-- Defined at LOL.hs:3:5-8" what's the "-8" part
06:20:28 <pastah> my datatype is only declared from line 3 to 5
06:20:45 <benmachine> isn't that line 3 characters 5-8
06:21:11 <benmachine> yeah looks like it to m
06:21:12 <benmachine> e
06:21:18 <pastah> benmachine: those would be " Tre"
06:21:34 <pastah> so i'm guessing you're wrong
06:21:46 <benmachine> I'm guessing I'm not >_>
06:21:56 <pastah> (it's "data Tree a = ...")
06:22:20 <benmachine> insert arbitrary whitespace and see if it changes
06:22:43 <pastah> it did
06:22:49 <pastah> data    Tree a = Leaf
06:23:08 <pastah>  -- Defined at Functors.hs:3:8-11
06:23:08 <benmachine> looks like the characters are numbered from 0
06:23:10 <benmachine> orsomething
06:23:27 <pastah> but the 'a' doesn't seem to be included
06:24:12 <benmachine> so it seems
06:24:34 <benmachine> I suspect it refers to the creation of the Tree identifier
06:24:39 <benmachine> or
06:24:40 <benmachine> something
06:25:16 <FunctorSal> @type \a b c -> (<*>) a b c
06:25:18 <lambdabot> forall t a b. (Applicative ((->) t)) => (t -> a -> b) -> (t -> a) -> t -> b
06:25:49 * FunctorSal just noticed that makes <*> the s combinator
06:26:03 <FunctorSal> this instance, I mean
06:26:43 <FunctorSal> and less powerful due to the types
06:28:50 <lilac> FunctorSal: also interesting is that 'pure' in that applicative is the K combinator
06:30:26 <FunctorSal> oh, right
06:32:20 <mmorrow> whoknows: if you're interested in playing around with this kind of stuff and GADTs, you might find something interesting in the code to http://hackage.haskell.org/package/derive-gadt
06:33:14 <mmorrow> whoknows: i haven't had any time to work on it since i uploaded, and there's a lot that can be improved... where what exactly that is isn't really cut and dry
06:37:27 <mmorrow> whoknows: (for the strategy that that package is following, it needs to partition the gadt cons into equivalence classes by unification so it can include all the cons it should in each of the (>1) instances it derives for a given type)
06:37:45 <mmorrow> well, Show is the exception
06:43:10 <gbacon> so I got a new follower on Twitter: http://www.haskells.com/
06:43:10 <wolverian> hrm, my cabal update fails with "user error (Codec.Compression.Zlib: premature end of compressed stream)"
06:43:14 <wolverian> any hints?
06:43:20 <gbacon> holy false equivocation, Batman! :-)
06:45:42 <lilac> whoknows: i've tried your suggestion. both types give the exact same result.
06:47:34 <noteventime> Is there some standard function for something which would be "equivalent" to "liftM3 if"
06:48:26 <lilac> @hoogle Monad m => m Bool -> m a -> m a -> m a
06:48:27 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
06:48:27 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
06:48:27 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
06:49:14 <noteventime> I did a search on Hoogle
06:49:46 <dcoutts> wolverian: usually means a truncated or aborted download
06:50:07 <wolverian> dcoutts: it's saying that consistently. server down?*
06:50:18 <Axman6> noteventime: liftM3 if'?
06:50:33 <Axman6> (where if' p t f = if p then t else f
06:50:37 <noteventime> Axman6: Yes, that's what I'm doing
06:50:44 <noteventime> Just wanted to make sure I didn
06:51:31 <noteventime> 't rewrite something in the standard (or almost standard) libraries
06:51:32 <dcoutts> wolverian: or an unhelpful proxy in between, check cabal update -v3 output
06:52:54 <wolverian> dcoutts: ah, yes, privoxy. I don't see errors in the headers output by -v3 thoguh.
06:52:59 <wolverian> though
06:53:27 <lilac> @type ((join .) .) . flip (flip . (liftM .) . flip flip fromEnum . (((.) . (!!)) .) . flip (:) . return) :: Monad m => m Bool -> m a -> m a -> m a
06:53:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m Bool -> m a -> m a -> m a
06:54:28 <pastah> lilac: ifM?
06:54:43 <lilac> yup
06:54:45 <wolverian> dcoutts: okay, the file *is* prematurely ended. hrm.
06:55:12 <lilac> > (((join .) .) . flip (flip . (liftM .) . flip flip fromEnum . (((.) . (!!)) .) . flip (:) . return)) (Just True) Nothing (Just 42)
06:55:14 <lambdabot>   Nothing
06:55:18 <pastah> lilac: what does fromEnum do in there?
06:55:22 <wolverian> can I disable the proxy for cabal?
06:56:00 <lilac> pastah: \b t f -> join ((([f,t]!!).fromEnum) `liftM` b)
06:56:20 <benmachine> hah
06:56:26 <pastah> oh, you sneaky bastard
06:56:30 <lilac> *g*
06:56:53 <hackagebot> pulse-simple 0.1.12 - binding to Simple API of pulseaudio (DaikiHanda)
06:57:54 <wolverian> dcoutts: wget gets the file correctly
06:58:08 <pastah> benmachine: how much of that did you write yourself, or was it @pl?
06:58:30 <pastah> +grammar
06:58:32 <benmachine> what did I write
06:58:38 <benmachine> my backlog is full of netsplit sorry
06:58:42 <benmachine> and I have a bad memory
06:58:47 <lilac> me?
06:58:58 <dcoutts> wolverian: cabal will use the HTTP_PROXY env var, so if you clear that then it'll not use any proxy, however your network may be using a transparent proxy
06:58:58 * benmachine thinks it was probably lilac
06:59:04 <lilac> the \b t f -> ... was what i fed to @pl
07:00:07 <wolverian> dcoutts: yes, but the privoxy is the one that makes cabal fail.
07:00:09 <shapr1> Does haskell-src-exts cabal install on win32?
07:00:22 <dcoutts> wolverian: can you look again at the output for cabal update -v3 and see if it matches the logs in this ticket:
07:00:23 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/562
07:00:26 <lilac> @type flip flip fromEnum
07:00:28 <lambdabot> forall a c a1. (Enum a1) => (a -> (a1 -> Int) -> c) -> a -> c
07:00:33 <lilac> :o
07:00:38 <dcoutts> wolverian: if it does, please append a comment with your example
07:00:38 <wolverian> dcoutts: thanks, taking a look
07:01:00 <benmachine> I wonder where @type gets the names from
07:01:05 <benmachine> why a, c, and a1?
07:01:15 <dcoutts> wolverian: did you work out if it was a transparent proxy or an explicitly specified proxy?
07:01:24 <lilac> i think it tries to use the names from the functions' type annotations.
07:01:42 <wolverian> dcoutts: there is no HTTP_PROXY; I've specified the proxy in gnome's settings
07:02:00 <dcoutts> wolverian: the other env var is lowercase http_proxy
07:02:15 <wolverian> yes, that's set.
07:02:21 <dcoutts> cabal looks at both, since there's no common standard :-(
07:02:22 <wolverian> there are no Proxy-* headers in the log
07:02:26 <lilac> @type flip
07:02:28 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:02:29 <lilac> @type fromEnum
07:02:30 <lambdabot> forall a. (Enum a) => a -> Int
07:02:47 <dcoutts> wolverian: can you post a log eg with hpaste ?
07:02:50 <lilac> @type flip flip
07:02:52 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
07:02:57 <wolverian> dcoutts: yes.
07:03:27 <lilac> benmachine: this knowledge can be used for evil
07:03:37 <lilac> @quote lilac muscles
07:03:38 <lambdabot> lilac says: @type \o-> look at my muscles  <lambdabot> forall t nice muscles. t -> nice -> muscles
07:04:05 <benmachine> haha nice
07:04:10 <wolverian> dcoutts: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3136#a3136
07:05:22 <dcoutts> wolverian: so what is the size of the downloaded file in the end?
07:05:37 <wolverian> dcoutts: 1078 ytes
07:05:41 <wolverian> bytes :)
07:06:12 <dcoutts> wolverian: hmm. and wget is also using the same localhost proxy?
07:06:36 <wolverian> dcoutts: yes.
07:07:01 <dcoutts> wolverian: perhaps you can open a new ticket with that log, and a log of wget or curl (there's some flag to show the log of headers sent and received)
07:07:24 <dcoutts> wolverian: if you happen to know the version of the HTTP lib used then please mention that too
07:07:24 <wolverian> dcoutts: okay, I will. thanks for the help.
07:07:36 <dcoutts> wolverian: did it work when you use no proxy at all?
07:07:51 <benmachine> suppose I have an infixl data constructor, and I want to define a data constructor which is exactly the same but infixr instead
07:07:56 <benmachine> is it possible to do that?
07:07:58 <wolverian> dcoutts: yes.
07:08:11 <dcoutts> wolverian: ok, so you're not completely stuck then, good.
07:08:18 <wolverian> right. :)
07:15:52 <wolverian> dcoutts: done; http://hackage.haskell.org/trac/hackage/ticket/572
07:16:01 <dcoutts> ta
07:19:08 <benmachine> so it seems if I have a data constructor :\/ I can define a function synonym for it but not a constructor synonym for it
07:19:28 <benmachine> (i.e. it's ok to say (\/:) = :\/ but not (:/\) = :\/)
07:19:31 <benmachine> is that right?
07:19:34 <benmachine> or am I missing a trick
07:20:13 <Saizan> you're right
07:20:24 <benmachine> k
07:20:28 <Saizan> though there's the she preprocessor that let you define something like that i think
07:20:31 <Saizan> @hackage she
07:20:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/she
07:22:45 <benmachine> > f
07:22:47 <lambdabot>   Ambiguous occurrence `f'
07:22:47 <lambdabot>  It could refer to either `L.f', defined at <local...
07:39:03 <sioraiocht> is there a function that returns (takeWhile p xs, dropWhile p xs)
07:39:32 <sioraiocht> ah, n/m
07:39:37 <ziman> :t break
07:39:38 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:43:28 <shapr1> Has anyone tried test-framework on Windows?
07:43:43 <shapr1> The basic test runner gives this error: *** Exception: getConsoleCursorInfo: invalid argument (The handle is invalid.)
07:45:27 <sauf_> hi, is possible to cabal install base-4.1.0.0 with ghc 6.8.2 on ubuntu [currently I have base-3.0.1.0] ? Should I --reinstall ?
07:47:29 <vav> sauf_: you need ghc-6.10* for base-4
07:48:12 <sauf_> vav: ok. Is it easy to upgrade ?
07:49:59 <vav> sauf_: Not sure what's best route, will leave to ubuntu/debian users here. You might try the http://hackage.haskell.org/platform
07:50:07 * ManateeLazyCat pasted "functions" at http://paste2.org/get/357850
07:50:10 <ManateeLazyCat> How to merge above three functions ?
07:50:28 <sauf_> vav: ok, thanks
07:50:55 <shapr1> sauf_: Isn't ghc-6.10 available for ubuntu?
07:51:19 <ManateeLazyCat> shapr1: Just install binary package from GHC homepage.
07:51:24 <soupdragon> ManateeLazyCat: to create one that has the power of 3?
07:51:34 <ManateeLazyCat> soupdragon: Yes
07:52:00 <sauf_> shapr1: not yet [kubuntu 9.04]
07:52:15 <whoknows> where are the logs for this channel?
07:52:16 <saml> which xml library should i use?
07:52:37 <sauf_> whoknows: http://tunes.org/~nef/logs/haskell/"]
07:52:40 <ManateeLazyCat> soupdragon: I found `applyMaybeM` can't handle (a -> IO (Maybe b))
07:53:00 <soupdragon> ManateeLazyCat: I think that it can't be doe
07:53:05 <seydar> so i have a program that did some stuff (what it did is irrelevant). the first rendition was strict, and ran pretty quickly. The second rendition was lazy, and ran much slower. Where did my speed go, or where COULD it have gone?
07:53:10 <WorkyBob> excellent, that works rather nicely for making interact a more useful function
07:53:24 <WorkyBob> you for frp inspiration...
07:53:25 <WorkyBob> switch :: (a -> Bool) -> ([a] -> [a]) -> ([a] -> [a]) -> [a] -> [a]
07:53:25 <WorkyBob> switch p a b i = uncurry (++) . (b *** a) $ break p i
07:54:44 <sauf_> whoknows: sorry, http://tunes.org/~nef/logs/haskell/
07:54:58 <whoknows> hrmph, todays logs are not up yet
07:55:35 <whoknows> lilac, how did you try my suggestion?
07:55:47 <sauf_> whoknows: 07:54:58 <whoknows> hrmph, todays logs are not up yet
07:55:48 <ManateeLazyCat> soupdragon: Any ideas?
07:56:23 <WorkyBob> ski: was it you who was asking about how to do that with interact?
07:56:30 <seydar> I still don't grok the speed differences between strict and lazy
07:56:38 <seydar> can someone fix that?
07:56:53 <seydar> any pages i should read? books?
07:56:54 <soupdragon> ManateeLazyCat: no I think it's impossible
07:57:21 <EvilTerran> seydar, laziness can, in some circumstances, cause memory to be held onto longer than it would be otherwise, because it's still needed to work out the value of an expression that hasn't been forced yet
07:57:47 <ManateeLazyCat> soupdragon: I found my code have many "case ... of ...", so i write above functions for lazy.
07:57:50 <WorkyBob> seydar: on the other hand, strictness can cause CPU time to be used that was never needed otherwise
07:57:56 <WorkyBob> as always... standard CPU or memory use trade off
07:57:57 <whoknows> ah, clicked on the wrong file
07:58:05 <ManateeLazyCat> soupdragon: In fact i wrote four functions for handle Maybe case.
07:58:07 <whoknows> mmorrow, playing around with GADTs?
07:58:26 * ManateeLazyCat pasted "functions for handle Maybe case" at http://paste2.org/get/357854
07:58:30 <ManateeLazyCat> soupdragon: Above
07:58:40 <seydar> EvilTerran: would it ever be that the data i'm reading from gets cached around L2 and that's why strict was being faster than lazy? all i'm doing is unpacking strings, so i don't think i'm leaving around any pieces of memory
07:58:46 <soupdragon> ManateeLazyCat,
07:58:49 <soupdragon> :t maybe
07:58:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:59:06 <soupdragon> ManateeLazyCat, why don't you write all four function using  maybe  ?
07:59:12 <EvilTerran> seydar, this is a higher-level thing than such concepts as L2 caches
07:59:48 <seydar> EvilTerran: yargh, i gotcha, but i'm trying to figure out where my cycles went...
08:00:00 <seydar> and i can't think of anything, so i'm trying to bs my way to a solution
08:00:04 <pikhq> seydar: CPU caching does not change functionality, it only changes the speed of memory access.
08:00:06 <EvilTerran> in OS terms, laziness can get things malloc()ed that then don't get free()ed by the GC until later than you expect, because it sees expressions still need it
08:00:22 <EvilTerran> when the GC *does* eventually run, then, it takes up loads of time
08:00:26 <EvilTerran> seydar, have you profiled?
08:00:49 <EvilTerran> you may find that the majority of the running time of the lazy version is the garbage collector running, say
08:00:58 <ManateeLazyCat> soupdragon: You have give a default value `b` to function `maybe`
08:01:07 <shapr1> What happened to 'check' from QuickCheck1 ? What's it called in QC2?
08:01:10 <seydar> EvilTerran: I should look into profiling the GC running time.
08:01:16 <sioraiocht>  
08:01:20 <sioraiocht> @src fail IO
08:01:21 <lambdabot> Source not found. My mind is going. I can feel it.
08:01:31 <sioraiocht> @t fail
08:01:32 <EvilTerran> seydar, well, profiling your whole program, and seeing what's taking up the most time
08:01:32 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:01:35 <EvilTerran> @src IO fail
08:01:36 <lambdabot> fail s  = failIO s
08:01:39 <EvilTerran> @src failIO
08:01:40 <lambdabot> failIO s = ioError (userError s)
08:01:43 <sioraiocht> thanks =)
08:01:43 <seydar> pikhq: yargh, so that's why i'm assuming that the file data i was reading from was getting cached
08:01:45 <sioraiocht> :t failIO
08:01:47 <lambdabot> Not in scope: `failIO'
08:01:57 <sioraiocht> your mom isn't in scope, lambdabot
08:01:57 <ManateeLazyCat> @src maybe
08:01:57 <EvilTerran> ?hoogle failIO
08:01:58 <lambdabot> maybe n _ Nothing  = n
08:01:58 <lambdabot> maybe _ f (Just x) = f x
08:01:58 <lambdabot> No results found
08:02:08 <seydar> EvilTerran: i should say that i'm not using haskell for this (yet), but figured the right brains would be here
08:02:09 <EvilTerran> ?hoogle ioError
08:02:10 <sioraiocht> EvilTerran: are you doing soc?
08:02:10 <lambdabot> Prelude ioError :: IOError -> IO a
08:02:10 <lambdabot> Control.Exception ioError :: IOError -> IO a
08:02:10 <lambdabot> System.IO.Error ioError :: IOError -> IO a
08:02:15 <pikhq> seydar: And the CPU cache can only speed up *repeat* memory access.
08:02:24 <sioraiocht> thanks, EvilTerran =)
08:02:39 <seydar> pikhq: AH! that is important. my theory is now void
08:02:50 <EvilTerran> sioraiocht, no... i thought about it, but then i got distracted by project work and exams :/
08:02:52 <shapr1> Aha, it became Test.QuickCheck.Test.quickCheck
08:03:01 <sioraiocht> fair enough
08:03:11 <pikhq> It's useful to think about, but it isn't some magic "MAKE EVERYTHING FASTER" device.
08:03:13 <pikhq> ;)
08:03:16 <sioraiocht> who are you doing your project with?
08:04:41 <seydar> pikhq: i'd really appreciate it if you could make it a panacea kthx
08:05:06 * pikhq drops seydar's CPU in a vat of liquid nitrogen
08:05:25 <seydar> leet
08:06:18 <seydar> i still don't understand how to make my own monads
08:06:30 <seydar> so as lamezorz as it is to say this
08:06:33 <seydar> help
08:07:11 <jmcarthur_work> seydar, why do you want to make a monad?
08:07:37 <seydar> jmcarthur_work: to understand how the work in better detail, and so that i can use do notation to make things awesomer
08:07:57 <jmcarthur_work> seydar, every monad works different. it's a bad idea to concern yourself with operational details
08:08:11 <seydar> nono, just... monads in general
08:08:13 <pikhq> seydar, you don't think "I need to make a monad to make things awesomer".
08:08:19 <jmcarthur_work> seydar, and it is typical for me to tell people that do notation is bad most of the time
08:08:26 <pikhq> You write something up, and think "Oh, this would be great as a monad".
08:08:46 <jmcarthur_work> seydar, a monad is no more special than any other type class
08:08:52 * seydar cries
08:08:53 <jmcarthur_work> seydar, do you understand Functor?
08:09:02 <seydar> no, what is it?
08:09:02 <pikhq> (examples where that notion has come up is... Parsec. Definitely Parsec.)
08:09:19 <EvilTerran> ?src Functor
08:09:20 <lambdabot> class  Functor f  where
08:09:20 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:09:25 <jmcarthur_work> seydar, every monad is a functor (although in Haskell, not every Monad is a Functor)
08:09:37 <jmcarthur_work> seydar, Functor is more general and simpler than Monad
08:09:42 <SamB> though if you find a Monad that isn't a Functor, report it as a bug
08:09:45 <jmcarthur_work> seydar, i would recommend starting with that
08:09:51 <jav> Hi there! Someone here who feels in the mood for some beta testing? =) I just uploaded my project 'Bluetile - A modern tiling window manager with a gentle learning curve' to Hackage and would appreciate some feedback as to whether it works for others. It's designed to work with the Gnome DE and replace Metacity.
08:11:21 <jmcarthur_work> seydar, just so you understand the relationship between Monad and Functor, liftM = fmap
08:11:35 <jmcarthur_work> seydar, liftM can be defined solely in terms of Monad
08:11:44 <jmcarthur_work> seydar, that's why every Monad is a Functor
08:11:52 <SamB> or should be!
08:11:56 <jmcarthur_work> right, should be
08:12:06 <jmcarthur_work> s/M/m/    s/F/f/
08:12:39 <wjt> jav: interesting! *fires up cabal install*
08:13:03 <seydar> jmcarthur_work: so a functor is just a thingy
08:13:08 <jav> Oh, I forgot to mention, you need two projects... so: cabal update, cabal install bluetileutils, cabal install bluetile
08:13:25 <seydar> that has a function applied to it
08:13:43 <jmcarthur_work> seydar, fmap transforms a function (a -> b) into a function (f a -> f b), where f is a Functor
08:13:49 <jmcarthur_work> yup
08:14:00 <seydar> functor = monad?
08:14:12 <seydar> err, monad = functor?
08:14:14 <seydar> is it two way?
08:14:17 <jmcarthur_work> seydar, no
08:14:19 <seydar> show me a functor that's not a monad
08:14:20 <jmcarthur_work> functor is more general
08:14:21 <jav> wjt: cool, let me know if it works at all =) .... on a second thought, I should have probably done this testing first and then uploaded something to hackage.. but oh well, can always replace it with a newer version later
08:14:31 <jmcarthur_work> @instances Functor
08:14:33 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:14:34 <jmcarthur_work> @instances Monad
08:14:36 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:14:44 <jmcarthur_work> heh, i guess most of those are monads after all
08:14:57 <jmcarthur_work> umm.... ZipList is a Functor, but not a Monad
08:15:03 <wjt> jav: is this just a case of `export WINDOW_MANAGER=bluetile; gnome-session`?
08:15:11 <jmcarthur_work> ZipList is in Control.Applicative
08:15:14 <wjt> jav: (i'm at work, but i'll give it a spin later.)
08:15:47 <seydar> jmcarthur_work: what's the etymology behind "Functor"? Was the task delegated to someone's kid?
08:15:59 <jmcarthur_work> seydar, category theory
08:16:04 <jav> wjt: that might work to, I just run Gnome + Metacity, then open a terminal and start bluetile.. it then just replaces Metacity and you can later switch back ...  ok sure!
08:16:53 <EvilTerran> seydar, blame category theorists
08:17:31 <seydar> i'm going to steal commit access to ghc and change these names to things that make sense
08:17:53 <benmachine> ZipList could probably be a monad
08:17:57 <benmachine> I wonder what that would look like
08:18:31 <pikhq> benmachine: I thought that the List instance of monad was the only possible one?
08:18:55 <Saizan> benmachine: if you restrict it to infinite ZipLists you get the Stream monad
08:19:31 <benmachine> pikhq: um probably, I've not actually thought about it
08:28:11 <wmealing2> wondering if someone could tell me where in RWH, "just" and "maybe" are explained.
08:28:57 <Athas> Page 448.
08:29:04 <Athas> But that's really very late, it's very simple.
08:29:21 <Athas> 'Maybe a' is a data type with two constructors:  'Just a' and 'Nothing'.
08:29:53 <Athas> Kinda like a nullable type in some other languages.
08:29:54 <shachaf> wmealing2: Chapter 3, it looks like.
08:30:04 <Athas> (I went by the index, it may be mentioned earlier.)
08:30:25 <wmealing2> (i'm reading in the dark, wife is asleep, so its web only)
08:30:29 <wmealing2> thanks, both of you
08:30:41 <Cale> > findIndex 'd' "abracadabra"
08:30:43 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
08:30:57 <Cale> > elemIndex 'd' "abracadabra"
08:30:59 <lambdabot>   Just 6
08:31:03 <Cale> > elemIndex 'f' "abracadabra"
08:31:04 <lambdabot>   Nothing
08:31:09 <shachaf> wmealing2: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.paramtypes
08:31:15 <EvilTerran> > findIndex (>'n') "abracadabra"
08:31:16 <lambdabot>   Just 2
08:31:23 <EvilTerran> > findIndex (>'z') "abracadabra"
08:31:24 <lambdabot>   Nothing
08:32:11 <seydar> jmcarthur_work: what's a piece of haskell software that has really good quality code?
08:33:54 <EvilTerran> seydar, xmonad's pretty good, although inevitably quite imperative
08:34:47 <seydar> EvilTerran: xmonad, gotcha. what else?
08:35:11 <MacMagnus> hi, im doing the exercises in "real world haskell", and im stuck at making my own version of the groupBy-function in Data.List... i must use a fold... anyone have a little hint?
08:36:50 <EvilTerran> MacMagnus, repeated decomposition into cases works quite well, i find
08:37:14 <EvilTerran> if you were writing it as a direct recursion, the first obvious decomposition would be "empty list" vs "non-empty list"
08:37:43 <MacMagnus> it easy writing explicit recursion... the challenge is using a fold
08:37:48 <MacMagnus> :)
08:37:59 <MacMagnus> to me, that is.
08:38:03 <EvilTerran> yeah, that was just an example of what i meant by case decomposition
08:38:11 <MacMagnus> ah... ok :)
08:38:18 <EvilTerran> do you know whether you're meant to be using foldl or foldr?
08:38:21 <dschoepe> MacMagnus: Well, you can check whether the head of the last list in the accumulating parameter is equal to the current element. if so add it, otherwise add a new list
08:38:59 <MacMagnus> EvilTerran: no, but i have tried foldr
08:39:13 <EvilTerran> if you don't know which direction of fold to use, it's generally better to try foldr first, as it's generally a nicer function from various perspectives
08:39:13 <bhan> has anyone seen the -1#IND error?
08:39:28 <MacMagnus> evil: yes :)
08:39:55 <MacMagnus> the problem to me is that some element must be added inside [[]], and some just inside []
08:42:01 <glguy> There is a constraint in groupBy's output that you won't be able to express in its type. The output list will have no empty lists in it
08:43:01 <glguy> (alternatively you could make a new non-empty list type and use that internally, and then map it to the standard list type afterwards :) )
08:43:02 <yottis> well, not with a list
08:43:18 <seydar> what would people say is really good haskell code? (I'm looking for project names)
08:43:24 <glguy> yottis: the exercise probably didn't say "Invent your own list type and write groupBy" :-p
08:43:37 <MacMagnus> can i paste 4 lines? :)
08:43:42 <glguy> hpaste.org
08:43:49 <jmcarthur_work> seydar, the names are more or less at the correct level of genericity. making them "clearer" would just be specializing their names to specific instances
08:43:58 <glguy> that way when it scrolls off, people will still be able to refer to it
08:44:02 <jmcarthur_work> woah that was a while ago
08:44:26 <sjanssen_> seydar: xmonad has some good code
08:44:42 <seydar> besides xmonad; i'm already going to look at it
08:44:49 <yottis> i sometimes miss datatypes like "a list with at least 42 elements", but it would be tedious
08:44:52 <EvilTerran> glguy, groupBy :: Eq a => [a] -> [(a,[a])] -- ?
08:44:59 <bhan> why does my code: http://pastebin.com/m3b45e70e print '-1#IND' after a while?
08:45:10 <vav> seydar: are you only interested in "apps" or just any code samples?
08:45:27 <seydar> vav: any code samples
08:45:31 <glguy> EvilTerran: that wouldn't be so bad. you'd have to be careful if you wanted it ot preserve the order when doing it with a foldr
08:45:43 <EvilTerran> true
08:45:59 <EvilTerran> ?type (!!)
08:46:01 <lambdabot> forall a. [a] -> Int -> a
08:46:13 <MacMagnus> http://pastebin.com/d250b1931 <<-- it wont compile, but am i on the tracks? :)
08:47:14 <EvilTerran> MacMagnus, looks like you're going in the right direction, yeah
08:47:36 <EvilTerran> MacMagnus, although i'm not sure what "(head (head acc)) f xs" is meant to be doing
08:48:06 <EvilTerran> MacMagnus, i'd highly recommend using pattern-matching instead of head/tail/etc; those functions are partial, and (i find) less clear
08:48:15 <MacMagnus> well if acc = [[1,2,3],[1,2]], then head (head acc) is 1
08:48:41 <MacMagnus> ok! :)
08:48:43 <EvilTerran> well, sometimes those functions are clearer, but i start with pattern-matching and then switch to those if i can see that they're safe and i think they're clearer
08:48:46 <IndioCabron> Have you ever suspected that Negroes are actually a transitional variant of Homo Erectus? Source: http://www.erectuswalksamongst.us   Sick of niiiggggers and their monkeyshines?  Then join us at Chimpout.com!  At Chimpout we are not White Supremacists, rather we are Negro Inferiorists.  Chimpout.com welcomes the rainbow of diversity that exists amongst humans, welcoming with open arms Asians, Whites, non-Negroid Hispanics, Semit
08:48:47 <IndioCabron> es, Indians, Turkics, Kurds, Persians, etc.   Come join us in the epic humanistic battle and help us defeat the feral negro beast!  Join us today!  http://www.chimpout.com/forum
08:48:58 <benmachine> @where ops
08:48:59 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
08:48:59 <lambdabot> mauke
08:49:26 --- mode: ChanServ set +o glguy
08:49:31 --- mode: glguy set +b %IndioCabron!*@*
08:49:33 --- mode: ChanServ set +o allbery_b
08:49:35 <sdschulze> [n00b question] I'm looking for a way to learn Haskell.  "Yet Another Haskell Tutorial" seems nice, but it's a bit superficial.  On the other hand, the plain spec might be a bit too formal.  Is there anything like "The C Programming Language", the "Camel book" (which is for Perl) or "Practical Lisp Programming" (for CL) for Haskell?
08:50:00 --- mode: glguy set +b *!*@200.79.144.187.dsl.dyn.telnor.net
08:50:01 <shachaf> sdschulze: Real World Haskell?
08:50:03 <MacMagnus> real world haskell, i like it
08:50:05 --- mode: allbery_b set -o allbery_b
08:50:22 <EvilTerran> ?where RWH
08:50:22 <lambdabot> http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
08:50:29 <MacMagnus> evil: i will try pattern matching. thanks everybode :)
08:50:32 --- mode: glguy set -o glguy
08:50:53 <benmachine> @where lyah
08:50:54 <lambdabot> www.learnyouahaskell.com
08:50:58 <benmachine> ^ I started there
08:50:59 <glguy> EvilTerran: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7839#a7839 my rendition of your suggestion
08:52:23 <EvilTerran> glguy, well, the "map g" loses the encoding of the "no empty lists in the result" property in the type
08:52:48 <EvilTerran> but yeah, that's what i was thinking of
08:53:07 <sdschulze> I'm a bit scared that a Haskell "tutorial" is almost as long as "The C Programming Language"...
08:53:58 <bremner> sdschulze: but K&R is no tutorial
08:54:12 <seydar> how does concurrency happen in GHC without the GIL?
08:54:16 <sdschulze> bremner: That's the point.
08:55:00 <bremner> sdschulze: _my_ point is that K&R is not really suitable for beginners to learn C. YMMV
08:55:22 <EvilTerran> seydar, GIL?
08:55:46 <mbz> global interpeter lock
08:55:59 <EvilTerran> i believe GHC primarily uses userland/green threads
08:56:04 <Taejo> is there any way to browse hackage by author or maintainer?
08:56:13 <allbery_b> K&R is very compact
08:56:26 <seydar> EvilTerran: and those are free to do as they please since they're managed by the... OS?
08:57:03 <mbz> is there stdlib/stdio description in K&R?
08:57:04 <allbery_b> seydar: I/O handles are locked. anything else is your problem.
08:57:48 <Berengal> allbery_b: Or isn't, most things being pure and all
08:57:52 <sdschulze> mbz: It describes the relevant parts of the standard library.
08:58:15 <allbery_b> Berengal: true
08:58:39 <sdschulze> Personally, I think K&R is the ideal way of teaching a language, though I can't talk about Haskell, of course.
08:58:44 --- mode: ChanServ set +o glguy
08:58:45 --- mode: glguy set -b %IndioCabron!*@*
08:58:48 --- mode: glguy set -o glguy
08:59:06 <vav> seydar: don't trust me, very unqualified to judge, but... I look at FieldTrip, edison, ghc, cryptol and split for inspiration sometimes, yes and xmonad itself, xm-contrib is from wide range of authors/abilities.
08:59:38 <seydar> vav: what do fieldtrip and edison do?
08:59:40 <bremner> sdschulze: I just went through choosing a text book for a C course, and decided against K&R, so I guess we will have to agree to disagree.
09:00:30 <bremner> sdschulze: maybe you are too l33t for a second year course :)
09:00:38 <jmcarthur_work> seydar, fieldtrip is functional graphics and edison is a bunch of purely functional data structures
09:01:17 <seydar> jmcarthur_work: vav: thank you!
09:01:45 <mbz> sdschulze, the ideal way of learning programming language is writing a compiler for that language imho, so grab C90 spec and do it... ;)
09:01:50 <sdschulze> bremner: In all other books I read before, the others just couldn't explain what pointers were for because they obviously didn't have an idea themselves.  Seems like they were retired Pascal programmers or something...
09:03:37 <sdschulze> There may be better C books I don't know about.
09:04:09 <sdschulze> Today, you wouldn't teach using gets() any more...
09:04:10 <bremner> sdschulze: we'll have to see, I'm trying Modern C programming by King.
09:04:46 <bremner> ok enough off topic chatter by me :)
09:04:57 <sdschulze> but OK, I'm here because I want to learn Haskell, so I will shut up :)
09:08:26 <Beelsebob> sdschulze: the H98 spec is hanging about -- get on with your compiler
09:08:27 <Beelsebob> >.>
09:11:51 <seydar> I'm looking at the doc part of the JSON bit of RWH
09:12:04 <seydar> fold :: (Doc -> Doc -> Doc) -> [Doc] -> Doc;   fold f = foldr f empty
09:12:11 <seydar> why did they use foldr instead of foldl?
09:12:30 <opqdonut> foldl is usually stupid
09:12:45 <opqdonut> foldr (for lazy stuff) and foldl' (for strict stuff) are the usual choices
09:12:48 <Zao> bluetile caught my eye in the recent announcements on hackage. Has anyone given it a try?
09:13:24 <Zao> Seems to be some kind of inituitive fork of xmonad.
09:14:15 <seydar> opqdonut: is it fold TO THE r(ight)? or fold FROM THE r(ight)?
09:14:36 <kpreid> > foldr f [x,y,z]
09:14:39 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
09:14:39 <lambdabot>    arising fr...
09:14:48 <kpreid> > foldr f z [a,b,c]
09:14:50 <lambdabot>   f a (f b (f c z))
09:14:53 <kpreid> > foldl f z [a,b,c]
09:14:55 <lambdabot>   f (f (f z a) b) c
09:15:03 <kpreid> seydar: like that
09:15:13 <opqdonut> seydar: "to the right" i guess
09:15:16 <opqdonut> or from
09:15:21 <opqdonut> depends on your point of view :)
09:15:31 <seydar> so shouldn't foldl be used for lazy things?
09:15:36 <kpreid> it's "from" if you think imperatively
09:15:40 <kpreid> no
09:15:46 <seydar> because foldr needs the last element first
09:15:52 <kpreid> no
09:16:07 <kpreid> foldl needs the last element first
09:16:17 <kpreid> well, it depends on the strictness of f, really
09:16:37 <seydar> oh wait
09:16:41 <seydar> i see what you're saying
09:17:04 <kpreid> foldr gives you a value which can be computed from the beginning of the list using a limited number of applications of f, foldl does not
09:17:24 <kpreid> look at what foldl does:
09:17:26 <kpreid>  f (f (f z a) b) c
09:17:56 <kpreid> to get any information out of that, the outermost f has to look at one of its arguments. those arguments are the LAST element of the list and the nested evaluation of f
09:18:08 <kpreid> s/evaluation/application/
09:18:19 <kpreid> both of those are O(n)
09:18:28 <kpreid> And so if the list is infinite, nonterminating
09:18:52 <seydar> well if it's foldr it will never terminate either, will it
09:19:09 <kpreid> Sure it can
09:19:13 <jmcarthur_work> > head $ foldr (:) [] [1..]
09:19:15 <lambdabot>   1
09:19:19 <jmcarthur_work> terminated
09:19:22 <seydar> wtf
09:19:25 <seydar> not possible
09:19:31 <seydar> you two had this worked out ahead of time
09:19:32 <kpreid> > folder "
09:19:33 <lambdabot>   <no location info>:
09:19:33 <lambdabot>      lexical error in string/character literal at end o...
09:19:34 <badsheepy> hehe
09:19:35 <jmcarthur_work> open your mind
09:19:45 <kpreid> > foldr (\x rest -> show x ++ rest) "" [0..]
09:19:46 <lambdabot>   "01234567891011121314151617181920212223242526272829303132333435363738394041...
09:20:01 <kpreid> see! infinite input, infinite output, successful computation
09:20:48 <kpreid> notice that the function I pass to foldr needs its first argument (= some element of the list) before its second (= the result of the fold of the rest of the list)
09:21:08 <kpreid> if it helps, think of foldr as a generalization of map
09:21:14 <kpreid> @src map
09:21:15 <lambdabot> map _ []     = []
09:21:15 <lambdabot> map f (x:xs) = f x : map f xs
09:21:22 <kpreid> well, not that, but rather:
09:21:32 <seydar> wait... i... i... think i get it
09:21:42 <kpreid> map f xs = foldr (\x ys -> f x : ys) []
09:21:45 <kpreid> map f xs = foldr (\x ys -> f x : ys) [] xs
09:22:31 <kpreid> on the other hand, you use foldl' when you're *accumulating* a value across the list: you *don't* care about partial results, and each step *discards* the previous accumulation
09:22:40 <athos> > foldr f z [a,b,c]
09:22:42 <lambdabot>   f a (f b (f c z))
09:23:00 <kpreid> length xs = foldl (\c _ -> c + 1) 0 xs
09:23:21 <kpreid> you use foldl', not foldl, there because you want to do the arithmetic promptly
09:23:43 <kpreid> because 5 is cheaper to represent than (((((0 + 1) + 1) + 1) + 1) + 1)
09:23:46 <jmcarthur_work> well, assuming a strict result type
09:24:06 <kpreid> true. but if we were counting in Nat we would use foldr
09:24:26 <seydar> kpreid: if i were using foldr/l for summing a list, i could never complete it on an infinite list
09:24:26 <jmcarthur_work> yeah
09:24:27 <kpreid> > genericLength "abc" :: Nat
09:24:29 <lambdabot>   Not in scope: type constructor or class `Nat'
09:24:37 <kpreid> Huh, I thought lambdabot had that?
09:24:42 <jmcarthur_work> seydar, right, that wouldn't work for either type of fold
09:24:43 <kpreid> seydar: true
09:24:55 <seydar> take THAT, math!
09:24:58 <jmcarthur_work> > genericLength "abc" :: Natural
09:25:00 <lambdabot>   3
09:25:00 <kpreid> seydar: it's just useful to think about infinite lists for foldrs
09:25:12 <jmcarthur_work> > (genericLength "abc" :: Natural) < genericLength [1..]
09:25:14 <lambdabot>   True
09:25:14 <kpreid> also, not true, in a way.
09:25:20 <kpreid> As jmcarthur_work just demonstrated
09:26:20 <jmcarthur_work> (Natural is lazy Peano numerals)
09:27:04 <kpreid> > @let len = foldr (\c _ -> succ c) (0::Natural) in len [9] < len [1..]
09:27:05 <lambdabot>   <no location info>: parse error on input `@'
09:27:09 <kpreid> > let len = foldr (\c _ -> succ c) (0::Natural) in len [9] < len [1..]
09:27:10 <lambdabot>   False
09:27:19 <kpreid> Uhm.
09:27:32 <kpreid> > let len = foldr (\c _ -> succ c) (0::Natural) in len [9]
09:27:33 <lambdabot>   10
09:27:45 <jmcarthur_work> ...
09:27:45 <kpreid> > let len = foldr (const succ) (0::Natural) in len [9] < len [1..]
09:27:46 <lambdabot>   True
09:27:48 <kpreid> That's better.
09:28:03 <jmcarthur_work> aha
09:28:32 <jmcarthur_work> @src genericLength
09:28:33 <lambdabot> genericLength []    = 0
09:28:33 <lambdabot> genericLength (_:l) = 1 + genericLength l
09:28:34 <kpreid> @hoogle (a -> b) -> a -> c -> b
09:28:35 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
09:28:35 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
09:28:35 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
09:29:19 <athos> , src 'Data
09:29:21 <lunabot>  luna: Not in scope: data constructor `Data'
09:29:23 <athos> , src ''Data
09:29:27 <lunabot>  class (Typeable a) => Data a where
09:29:27 <lunabot>          gfoldl ::
09:29:27 <lunabot>                 forall c .
09:30:07 <bhan> help.. why does this code: http://pastebin.com/m3b45e70e print '-1#IND' after a while?
09:34:28 <bhan> umm anyone?
09:35:18 <sdschulze> Just for feedback: I'm currently at chapter 2 of "Real World Haskell" and I really like it.
09:37:06 <tkr> Ok. Just quick questions. I want to plot grids (like on 2d, or possibly on spheres) and apply transformations for them. I really love Haskell for the language, what to use with Graphics?
09:37:41 <tkr> I can imagine a torus, coming through a 2d surface and expressing some nice prime counting function. :)
09:38:55 <EvilTerran> tkr, FieldTrip may work nicely for that
09:38:58 <jfoutz> bhan: i think your fromInteger is converting to something smaller than arbitrary precision.
09:39:31 <EvilTerran> tkr, see http://haskell.org/haskellwiki/FieldTrip
09:39:46 <tkr> EvilTerran: thanks, bookmarked :)
09:39:51 <seydar> how do I use pipes to communicate between processes? Can I just use sockets (are they lightweight)?
09:40:49 <EvilTerran> seydar, how are you making these distinct processes? forkIO?
09:41:27 <seydar> EvilTerran: well I was thinking i could have a D/Ruby process that would manage all my IO, and haskell for all the dirty work
09:41:31 <igorgue> hi there, is there a way to get help of a function?, like Python's help(function)
09:41:35 <igorgue> in the ghci
09:41:43 <pikhq> seydar: WRONG WRONG WRONG WRONG AND ALSO WRONG.
09:41:54 <seydar> pikhq: um, april fool's!
09:41:59 * Twey chuckles.
09:42:48 <seydar> what i meant to say was i love the IO Monad
09:43:09 <Twey> You can use sockets or pipes or something more sophisticated like dbus, but as pikhq is subtly hinting, this isn't a good reason to be splitting your code up into separate processes
09:43:12 <pikhq> As you should.
09:43:33 <Twey> You'll find it much easier just to stick with Haskell
09:43:57 <seydar> you're right, i'm probably just not splitting up my code logic properly
09:45:01 <seydar> hail monads
09:45:28 <pikhq> Hail.
09:46:29 * seydar fears for his well-being
09:47:12 <pikhq> Embrace monadic IO.
09:47:30 <pikhq> Or else, we shall give you nothing but applicative IO.
09:47:44 <pikhq> >:D
09:48:05 <seydar> pikhq: i will only embrace your leader if you can point me to five (5) awesome IO/Monad tutorials please
09:48:12 <Berengal> Monads are awesome, but most of the time applicatives will do
09:48:30 <pikhq> seydar: You have no need for them. Sit in quiet complication.
09:48:30 <seydar> Berengal: whoa there mister i-got-a-haskell-dictionary
09:48:43 <seydar> what are applicativeS?
09:48:54 <pikhq> @src Applicative
09:48:54 <lambdabot> class Functor f => Applicative f where
09:48:54 <lambdabot>     pure  :: a -> f a
09:48:54 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
09:49:20 <Berengal> seydar: applicatives are monads without >>=
09:49:21 <Berengal> Just >>
09:49:26 <pikhq> The relation with both monads and functors should be immediately obvious.
09:49:36 <Berengal> and ap
09:50:11 <pikhq> ap is a fun one. :)
09:50:22 <Berengal> @quote monad.*signature.*laws
09:50:22 <lambdabot> jmcarthur says: my "monad tutorial" has shortened to "look at the type signatures and the laws" :\
09:50:24 <seydar> what's ap
09:50:37 <pikhq> @src ap
09:50:37 <lambdabot> ap = liftM2 id
09:50:39 <seydar> and hypothetically if i didn't see the relation, what would you say?
09:50:40 <Berengal> @quote monad.*haiku
09:50:40 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
09:50:40 <lambdabot> read
09:51:02 <EvilTerran> ap = liftM2 ($)
09:51:10 <pikhq> seydar: Though it's not immediately obvious, ap for the functions is the S combinator.
09:51:22 <seydar> oh excellent. the S combinator
09:51:35 <pikhq> It's just generalised to the monads.
09:51:54 <Berengal> I'm a bit too much in love with applicatives, especially the function instance...
09:52:03 <Berengal> isPrime = (==) <*> head.factorize
09:52:14 <seydar> so like
09:52:22 <seydar> i don't understand any of this
09:52:32 <seydar> too many big words i've never heard of
09:52:48 <seydar> maybe i don't know enough math
09:52:59 <pikhq> Nah, you just don't know enough Haskell.
09:53:01 <Berengal> Yeah, they're big words and they have relatively little meaning
09:53:03 <copumpkin> > (+) `fmap` Just 5 `ap` Just 7
09:53:05 <lambdabot>   Just 12
09:53:10 <Berengal> They're horribly general
09:53:11 <copumpkin> > (+) <$> Just 5 <*> Just 7
09:53:13 <lambdabot>   Just 12
09:53:15 <Berengal> Which makes them hard to learn
09:53:22 <pikhq> There's not much to them, and that's the hard part.
09:54:05 <copumpkin> seydar: do you see what that does?
09:54:19 <Berengal> http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf <- read typeclassopedia, get functors first, then applicatives. Monads come naturally after those
09:55:00 <seydar> so what does Just 5 <*> Just 7 do?
09:55:06 <seydar> > Just 5 <*> Just 7
09:55:08 <lambdabot>   Add a type signature
09:55:20 <vav> @type (+) <$> Just 5
09:55:22 <lambdabot> forall a. (Num a) => Maybe (a -> a)
09:55:22 * seydar kicks lambdabot 
09:55:23 <msteele_> I'll second that.  the Typeclassopedia is what it took to finally make fuctors, applicatives, and monads make sense to me.
09:55:24 <soupdragon> :t (<*>)
09:55:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:55:42 <copumpkin> > liftA2 (+) (Just 5) (Just 7)
09:55:44 <lambdabot>   Just 12
09:55:47 <Berengal> > let if' p t f = if p then t else f in map (if' <$> even <*> (`div` 2) <*> (+1).(*3)) [1,2,3]
09:55:48 <lambdabot>   [4,1,10]
09:55:51 <soupdragon> Just 5 <*> Just 7  is an error unless you have a Num instance for a -> b
09:56:04 <copumpkin> > liftA2 (+) (*3) (^2) 5
09:56:06 <lambdabot>   40
09:56:12 <seydar> soupdragon: why's it an error? Just 5 needs to take another arg?
09:56:13 <plediii> is the latest version of haskell-mode really over a year old?
09:56:26 <soupdragon> seydar, because 5 isn't a -> b
09:56:36 <soupdragon> it's Int or Double
09:56:39 <seydar> ahh that much makes sense
09:57:03 <pikhq> soupdragon: Seems to me there's more Num instances than that. :P
09:57:12 <seydar> !!!!!
09:57:14 * SamB wonders how many people feel the need to resort to firebug to edit HTML-input widgets on websites?
09:57:23 <seydar> fmap lifts the veil of the monad
09:57:32 <Berengal> > 5 :: Ratio
09:57:33 <seydar> fmap (+) Just 5
09:57:34 <lambdabot>   `GHC.Real.Ratio' is not applied to enough type arguments
09:57:34 <lambdabot>  Expected kind `?'...
09:57:37 <EvilTerran> SamB, i edit pages in the ffx DOM inspector to make them print more nicely
09:58:01 <seydar> says "hey lil' 5, let's get you a friend. come on in and we'll (+) the shit out of you"
09:58:23 <EvilTerran> SamB, or even hand-write "javascript:" URLs to modify pages for me :P
09:58:35 <Berengal> @type fmap (+) (Just 5)
09:58:36 <lambdabot> forall a. (Num a) => Maybe (a -> a)
09:58:53 <seydar> wait, what's the difference between using <*> and just applying Just 7 directly to the function?
09:59:11 <Berengal> seydar: Maybe (a -> b) isn't a function, it's Maybe a function
09:59:16 <Berengal> But you can't apply Maybes
09:59:45 <Berengal> > (Just (+5)) (Just 7)
09:59:46 <lambdabot>   Couldn't match expected type `t1 -> t'
10:00:00 <mkaemmer> > Just (\x -> x + 5) <*> (Just 7)
10:00:02 <lambdabot>   Just 12
10:00:08 <Berengal> This is why you need the magic "apply" function (<*>)
10:00:15 <SamB> EvilTerran: I'm actually editing a page in google Page Creator right now
10:00:17 <Berengal> It applies a function inside a context (in this case Maybe)
10:00:27 <Berengal> > (Just (+5)) <*> (Just 7)
10:00:28 <copumpkin> > [(+1), (*2), (^3)] <*> [1..3]
10:00:29 <lambdabot>   Just 12
10:00:30 <lambdabot>   [2,3,4,2,4,6,1,8,27]
10:00:32 <seydar> Berengal: oh, so fmap is in this case a Maybe monad?
10:00:40 <Berengal> > (Just (+5)) <*> Nothing
10:00:41 <lambdabot>   Nothing
10:00:47 <pikhq> seydar: No, Maybe functor.
10:00:55 <Berengal> seydar: Well, Maybe is a functor, and fmap belongs to the functor class
10:00:58 <SamB> EvilTerran: and the UI for that doesn't seem to include nearly all the relevant HTML, imo -- for instance, I wanted to write a DL
10:01:20 <SamB> though of course they claim to be phasing that out
10:01:30 <seydar> pikhq: Berengal: do i have the right idea at least, even if i don't know if it's a functor or a monad?
10:01:42 <Berengal> seydar: Yeah, you're on the right track
10:01:47 <seydar> woot!
10:01:48 <michaelfeathers_> So, I want to use a case statement in the IO monad.  I get a char and assign it: ch <- getChar, but ghci freaks out when I do type "case ch of"
10:02:07 <copumpkin> > fmap (+6) (Just 5)
10:02:09 <lambdabot>   Just 11
10:02:40 <lysgaard_> Any way to convert a value that's bound by newtype to the type it originaly is? I want to convert a Network.Socket.PortNumber to a Word8
10:02:58 <edwardk> michaelfeathers_: you probably didn't use IO actions for the branches of your case statement
10:02:59 <idnar> lysgaard_: pattern match against the constructor
10:03:10 <Berengal> lysgaard_: Unless there's a "unPortNumber" function lying around, unsafeCoerce is your only option
10:03:21 <Berengal> Or the constructor is visible...
10:03:25 <edwardk> Berengal: or unless you have the constructor
10:03:26 <edwardk> yeah
10:03:30 <michaelfeathers_> edwardk Ah, thanks.  I guess they have to be in do also.
10:03:58 <dons> The Haskell Platform 2009.2.0.2 has been released http://donsbot.wordpress.com/2009/08/03/the-haskell-platform-2009-2-0-2/
10:04:03 <Berengal> michaelfeathers_: You can do "let foo = case ch of [...]"
10:04:14 <lysgaard_> No there is a const. PortNum Word8 :: PortNumber
10:04:21 <lysgaard_> Then i can do it
10:04:23 <seydar> copumpkin: what do you do all day?
10:04:43 <edwardk> seydar: he sits around and looks like this:    :o
10:05:06 <copumpkin> edwardk :o
10:05:09 <mkaemmer> seydar: presumably, he does the reverse of what a pumpkin does
10:05:10 <michaelfeathers_> Berengal: Thx
10:05:12 <edwardk> see?
10:06:11 <seydar> copumpkin: you know, i'm in your town right now... maybe i'll just drop on by and SURPRISE you
10:06:25 <copumpkin> seydar: you are? I'm not at school right now
10:06:40 <seydar> yargh, you're in leb, right?
10:06:45 <copumpkin> yup
10:06:53 <seydar> copumpkin: go to your front door
10:07:00 <copumpkin> lol
10:07:07 <Berengal> protip: It's not a surprise if you announce it ahead of time
10:07:19 <idnar> haha
10:07:26 <seydar> ah, lemme right that down
10:07:47 <seydar> protip: it's still a surprise if he calls my bluff and i show up to his hizzou
10:09:01 <seydar> copumpkin: you gonna be on for fall term?
10:09:10 <copumpkin> yup
10:09:21 <shapr2> yeah
10:09:52 <edwardk> you new hampshire guys need to make it down to boston for the haskell user group some time
10:10:07 <copumpkin> :o
10:10:16 <copumpkin> (that means yup!)
10:11:04 <seydar> edwardk: how often do yall meet?
10:11:39 <edwardk> about once a month or so
10:11:50 <seydar> is there a siteweb?
10:11:51 <edwardk> seydar: the august date hasn't yet been fixed but it should be around the week of the 17th
10:12:02 <edwardk> its on the haskell wiki somewhere, but there is also a google group
10:12:22 <edwardk> i'm giving a couple of talks at this next one on monoids and monoidal parsing
10:12:39 <Berengal> edwardk: bring a camera
10:12:59 <seydar> dare i ask what a monoid is?
10:13:24 <seydar> yes i do. what's a monoid?
10:13:36 <edwardk> seydar: hah any associative binary operation with a unit
10:13:50 <Berengal> seydar: It's a type, a binary associative operator on that type and a value that's both the left and right unit of that operator
10:13:52 <edwardk> seydar (+ with 0), (* with 1) (max with minBound)
10:14:06 <kpreid> or ++ and []
10:14:07 * seydar explodes
10:14:21 <edwardk> seydar: i use a bunch of more complicated monoids to do interesting things in parallel or incrementally
10:14:23 * Berengal wishes it was (++) with mempty
10:14:23 <seydar> kpreid: that's what i thought! i win!
10:15:00 <edwardk> seydar: yeah in fact that is in some ways the most fundamental monoid since lists are effectively the 'free monoid'
10:15:28 <copumpkin> is it GPL'd?
10:15:33 <Berengal> I have too much fun combining functions, applicatives and monoids...
10:15:35 <idnar> copumpkin: not the Free monoid
10:16:37 <seydar> who came up with all this stuff? is this ever formally taught in schools? and why the fuck not? and is this ever useful outside of #haskell?
10:16:58 <copumpkin> seydar: sure thing
10:17:10 <idnar> seydar: it's mostly category theory stuff
10:17:15 <copumpkin> well, not monoids
10:17:25 <idnar> or abstract algebra
10:17:33 <idnar> (monoids are algebra, right?)
10:17:37 <vav> seydar: http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html -- yet another great haskell blog
10:17:40 <copumpkin> yeah
10:17:43 <idnar> basically everything I know about maths, I learned from GEB and Haskell :P
10:17:52 <copumpkin> GEB?
10:18:07 <c_wraith> Goedel, Escher, Bach
10:18:08 <idnar> Gödel, Escher, Bach: An Eternal Golden Braid
10:18:10 <idnar> Hofstadter's book
10:18:11 <copumpkin> ah :)
10:18:16 <mkaemmer> idnar: good book!
10:18:18 <Berengal> I need to read that...
10:18:24 <BONUS> what a coincidence, im just reading that book
10:18:28 <seydar> vav: i actually read him daily, but i don't understand it so i read the titles of the posts and dream about understanding it
10:18:33 <yitz> idnar: there's a lot of math not covered in that book.
10:18:35 <seydar> BONUS: YOU HAVE WORK TO DO
10:18:43 <BONUS> gah!!! indeed
10:18:48 <vegai> BONUS: isn't everyone here reading that book, always? :P
10:18:50 <idnar> yitz: well, it was enough to get me through high school without learning anything
10:18:52 <BONUS> haha
10:18:57 <copumpkin> seydar: but if you take math 24 you'll get some basics
10:18:58 <edwardk> heya bonus!
10:19:04 <BONUS> heyo edward
10:19:17 <seydar> BONUS: bonjourno! how goes the section on monads?
10:19:34 <idnar> anyhow, I guess I picked up a few other things along the way
10:19:35 <BONUS> proggressing, although i've been a bit busy with typesetting the book :[
10:19:48 <edwardk> bonus: how many thousands of pages is it up to now? =)
10:19:53 <seydar> copumpkin: i'm thinking of taking math 19 in the fall, but then i'd have to take ASTR 1 or CS 44 in the winter. are either of those good?
10:19:57 <idnar> so maybe rather call it 90% instead of "everything"
10:20:16 <BONUS> haha, the page count is lower than i expected, so that's cool!
10:20:22 <edwardk> seydar: just take them all at the same time ;)
10:20:27 <BONUS> i've typeset up to chapter 6 now and it's like a bit over 100 pages i think
10:20:38 <BONUS> so maybe it's gonna be like 300 all together, which is a nice count
10:20:43 <edwardk> bonus: whew, so its small enough you can actually publish it
10:20:49 <BONUS> yeah haha
10:20:53 <opqdonut> BONUS: bookifying lyah? with latex?
10:20:57 <BONUS> but yeah, writing new content is definitely more fun than typesetting existing content
10:21:00 <BONUS> opqdonut: yup
10:21:00 <edwardk> you had me worried when you first mentioned the publishing arrangement
10:21:06 <BONUS> haha
10:21:08 <Berengal> BONUS: nice
10:21:22 <jmcarthur_work> yay bookification
10:21:23 <copumpkin> seydar: I kinda skipped math 19, but the other two are okay
10:21:31 <seydar> edwardk: there are complications that mean i can really only take one course at a time
10:22:31 <edwardk> seydar: ouch
10:23:08 <seydar> edwardk: it's not as bad as you think, i sorta get the best deal at the school
10:23:19 <seydar> copumpkin: you've done astr 1?
10:24:00 <copumpkin> actually I may have done 3
10:24:09 <copumpkin> can't remember :P
10:24:15 <seydar> i'd like to do 3, but it's only offered in the fall
10:24:17 <seydar> WAIT
10:24:18 <seydar> brililant
10:24:31 <copumpkin> it's a joke though
10:24:34 <seydar> astr 3 -> cs 19 -> cs 23
10:24:50 <seydar> do i get to look at stars through awesome telescopes?
10:24:51 <MyCatVerbs> Symbols and numbers, SYMBOLS AND NUMBERS, AAAAAAARGH! x_x
10:24:57 <copumpkin> seydar: basically
10:25:05 <copumpkin> seydar: and basic mechanics for the jocks
10:25:36 <seydar> copumpkin: and, of course, how are the girls in it?
10:25:54 <copumpkin> they tend to be female
10:26:28 <seydar> i can't tell if that speaks poorly of it or says nothing at all
10:26:37 <copumpkin> probably the latter :)
10:27:40 <copumpkin> brb
10:28:13 <shepheb> dons, sjanssen: http://hackage.haskell.org/package/bluetile-0.1
10:28:16 <shepheb> whoops
10:42:08 <copumpkin> :o
10:42:08 <edwardk> shepheb: is there a good site with any info about bluetile?
10:42:45 <QP> @hoogle liftIO
10:42:45 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
10:44:36 <seydar> copumpkin: are you getting your masters or phd?
10:44:43 <copumpkin> phd
10:44:53 <seydar> ohoh, what are you studying?
10:46:19 <vav> edwardk: http://tinyurl.com/kvtygc -- translation of pdf from project presentation -- that's all I've found aside from the misc tar.gz's on hackage.
10:47:12 <centrinia> copumpkin: What are you going to do after you get your Ph.D. ?
10:47:25 <copumpkin> seydar: machine learning stuff mostly so far
10:47:39 <copumpkin> centrinia: beats me :) something fun that will earn a lot more than a stipend, I hope
10:48:02 <seydar> copumpkin: is this starting year two in phdland?
10:48:10 <copumpkin> yeah
10:48:22 <shapr1> I want a PhD too :-(
10:48:32 <seydar> copumpkin: make sure you take 6 years
10:48:36 <copumpkin> lol
10:48:47 <bjorkintosh> shapr1, if you are a good boy your entire life, you might get an honorary doctorate.
10:48:53 <bjorkintosh> you won't need it by then.
10:48:59 <shapr1> bah
10:49:30 * centrinia starts an University called PhD-Mart. :p
10:49:30 <bjorkintosh> it's amazing. the caveman never needed machine learning... just a big stick, good eyes, and fast feet.
10:49:35 <copumpkin> lol
10:50:12 * Berengal wonders if the machines will study human learning in the future
10:50:25 <bjorkintosh> haha
10:50:27 <centrinia> The caveman was machine learning.
10:50:31 <bjorkintosh> they wouldn't stoop that low.
10:51:25 <Berengal> I'm not looking forward to when machines only need a big stick, good eyes and fast feet
10:51:31 <seydar> copumpkin: are you using any particular lingos at the moment?
10:51:37 <seydar> for your research?
10:51:43 <copumpkin> seydar: haskell as much as I can :)
10:51:50 <copumpkin> otherwise, matlab and c++, unfortunately
10:51:56 <bjorkintosh> copumpkin, i thought most of the good libraries were in matlab.
10:51:57 <copumpkin> but I try to keep those to a minimum
10:51:58 <bjorkintosh> ah.
10:52:15 <seydar> copumpkin: did you know the guy wrote the matlab JIT was here for a term?
10:52:34 <copumpkin> seydar: yeah, he's not just here for a term
10:52:39 <copumpkin> seydar: or rather, he works both here and there :P
10:53:02 <seydar> well he's here for a term then he leaves for some time and then comes back and teaches
10:53:05 <QP> I'm still having problems with Monad Transformers... can anyone explain why liftIO won't work in a do construct of a Monad that should be an instance of MonadIO? I'll show you...
10:53:16 <copumpkin> yeah
10:53:29 <seydar> copumpkin: you take a course with him yet/
10:53:30 <QP> first: type A = ReaderT X IO
10:53:42 <copumpkin> seydar: nope
10:53:46 <QP> then: type B = ReaderT Y A
10:54:12 <QP> now, B should be an instance of MonadIO, right?
10:54:22 <centrinia> copumpkin: How old are you?
10:54:28 <sclv__> QP: yep?
10:54:36 <copumpkin> centrinia: just turned 25
10:54:40 <jmcarthur_work> QP, correct
10:54:44 <bjorkintosh> he's probably 10011110110
10:54:46 <QP> so why won't liftIO work on it?
10:54:56 <jmcarthur_work> QP, hpaste how you are using it
10:54:58 <centrinia> copumpkin: Me too. :O
10:55:10 <copumpkin> centrinia: zomg age buddies!
10:55:10 <QP> ok, be one min.
10:55:25 <Berengal> Crap, I've forgotten how old I am
10:55:25 <centrinia> 1984 :O
10:55:33 <bjorkintosh> kids.
10:55:52 <copumpkin> Berengal: shfifty five?
10:56:05 <Berengal> copumpkin: 22 or 23
10:56:30 <Berengal> 22
10:56:45 * centrinia used to forget his age when he was around 22 and 23 as well.
10:56:45 * Berengal actually needed to do some date arithmetic to figure that out
10:56:57 <jmcarthur_work> i did that too, but now i know that i'm 24
10:57:05 <copumpkin> jmcarthur_work: really?
10:57:12 <jmcarthur_work> si
10:57:45 <centrinia> I will turn 26 next month. ;)
10:58:18 <jmcarthur_work> old geezer
10:58:25 <centrinia> I am not old. :(
10:58:43 <centrinia> I just turned 25 less than three months ago. :(
10:58:46 <jmcarthur_work> older than me = old geezer
10:58:51 <benmachine> I'm 18 and I forget my age >_>
10:59:02 <jmcarthur_work> forgetting ones own birthday = old geezer
10:59:05 <QP> jmcarthur_work: done, its on hpaste
10:59:19 <jmcarthur_work> QP, link for the lazy?
10:59:27 <QP> sorry
10:59:36 <jmcarthur_work> traditional to link in the channel ;)
10:59:53 <copumpkin> 'tis the haskell way
11:00:00 <QP> yeah, my cutting and pasting doesn't work well...
11:00:15 <jmcarthur_work> don't worry about it
11:00:20 <jmcarthur_work> got it up
11:00:33 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7842
11:01:10 <jmcarthur_work> without knowing other details, your use of liftIO looks fine
11:01:34 <jmcarthur_work> your use of ask may be ambiguous though, although i am sure it defaults to one or the other reader
11:01:49 <jmcarthur_work> could be a potential point of confusion, though
11:01:59 <benmachine> if it was wrong then the pattern match'd fail
11:02:06 <QP> hmmm...
11:02:17 <Infamous_Cow> I found a broken link in the haskell docs. The System.IO link does not link to a valid page (404).  http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html#9
11:02:23 <jmcarthur_work> benmachine, well, QP hasn't said what his/her error is
11:02:34 <QP> the error is a type error
11:02:48 <QP> expected type: Server ()
11:03:05 <jmcarthur_work> inferred type?
11:03:07 <QP> inferred type: ReaderT Interface IO ()
11:03:15 <jmcarthur_work> aha!
11:03:20 <QP> aha?
11:03:39 <jmcarthur_work> it's inferring Inter, not Server
11:03:50 <jmcarthur_work> probably due to ask
11:04:11 <QP> so, ask is set to the inner ReaderT
11:04:26 <QP> and it's using that to deduce the type?
11:04:29 <jmcarthur_work> if you really want to nest your readers like like you will need to disambiguate ask by wrapping the inner reader with a newtype or something
11:04:45 <benmachine> why do you need to disambiguate ask?
11:04:48 <jmcarthur_work> (ii'm speculating though since i don't really know which reader it's trying to use for sure)
11:04:50 <benmachine> why doesn't it always go to the outer one?
11:05:01 <QP> surely it should go to the outer one?
11:05:04 <jmcarthur_work> benmachine, ask is a member of the MonadReader class
11:05:14 <jmcarthur_work> not just something that operates on Reader
11:05:22 <Saizan> it should go to the other one because of that.
11:05:33 <Saizan> QP: what's the type of SI?
11:05:36 <jmcarthur_work> Saizan, the "other" one is which one?
11:05:38 <benmachine> so I'd expect the ReaderT instance of MonadReader to use the ask to get
11:05:38 <QP> why... ? I don't get it
11:05:49 <benmachine> whatever it reads
11:05:58 <Saizan> jmcarthur_work: err, sorry, outer
11:06:07 <jmcarthur_work> huh
11:06:10 <QP> SI :: Chan InMsg -> Chan OutMsg -> Interface -> ServerInterface
11:06:41 <Saizan> QP: are you sure the error is from that snippet?
11:06:47 <QP> yes
11:06:53 <Saizan> QP: can you annotate the paste with the whole error?
11:07:05 <copumpkin> you accidentally the whole error
11:07:37 <c_wraith> verb?
11:07:46 <jmcarthur_work> ah yeah, it would be the outer reader
11:08:22 <Saizan> you could also omit the type signature and see what ghci infers
11:09:20 <jmcarthur_work> i guess it would be overlapping instances otherwise, so that makes sense
11:10:00 <QP> there it is
11:10:13 <QP> sorry about the typos and abbreviations
11:10:28 <Saizan> Monad m => MonadReader r (ReaderT r m) <- the instance is this one, so it doesn't care about the 'm'
11:10:50 <jmcarthur_work> right
11:10:53 <QP> io = liftIO
11:11:07 <jmcarthur_work> QP, did you give io a type signature?
11:11:13 <QP> no
11:11:18 <jmcarthur_work> hmm
11:11:19 <Saizan> QP: that definition of io is the problem.
11:11:30 <QP> why, surely it is a synonym
11:11:31 <QP> ?
11:11:32 <Saizan> QP: rewrite it as io x = liftIO x
11:11:38 <QP> hmmm?
11:11:39 <jmcarthur_work> gah defaulting
11:11:45 <jmcarthur_work> err
11:11:47 <jmcarthur_work> what?
11:11:50 <yitz> MR
11:11:50 <Saizan> you've got caugth by the monomorphism restriction :)
11:11:54 <jmcarthur_work> oh
11:12:03 <QP> the which?
11:12:14 <Saizan> surely you're using io somewhere else where the monad is Infer
11:12:27 <QP> yeah, i am
11:12:29 <jmcarthur_work> you could either write it like io x = liftIO x, or you could explicitly give it a generic type annotation
11:12:36 <Saizan> and since a binding with no formal parameter can't be typeclass polymorphic because of the MR
11:12:37 <yitz> QP: the *Dreaded* monomorphism restriction
11:12:53 <Saizan> then it expects all the uses of io to belong to the Infer monad
11:13:04 <idnar> yitz: as opposed to the other monomorphism restriction?
11:13:05 <jmcarthur_work> :t liftIO
11:13:06 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:13:16 <QP> so function written in pointfree can only have one type? or something...
11:13:25 <yitz> idnar: MR can *only* be dreaded.
11:13:27 * yitz shudders
11:13:45 <idnar> QP: more or less
11:13:57 <Saizan> QP: functions totally pointfree and with a typeclass context are monomorphic unless you give them an explicit signature
11:13:58 <idnar> QP: the idea is that if you're defining something that looks like a value, it should be monomorphic
11:13:59 <yitz> QP: no, but you have to give it a type signature
11:14:11 <QP> i don't get all these wierd extra rules
11:14:14 <idnar> you can explicitly give it a polymorphic type signature, and that's fine
11:14:17 <Saizan> QP: or you put {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file
11:14:23 <idnar> or... that
11:14:28 <yitz> QP don't worry, it's only one weird extra rule
11:14:35 <idnar> yitz: they all add up :P
11:14:39 <jmcarthur_work> QP, the restriction exists so that if you, say, have an array at the top level for memoization it won't make multiple copies of the array for different types
11:14:45 <QP> no, i learnt a different one yesterday
11:15:06 <QP> so its an efficiency thing?
11:15:11 <Saizan> jmcarthur_work: or for the same type, actually
11:15:24 <sclv__> it was thought that this would conform to expected behavior better
11:15:33 <sclv__> but it turns out that it makes things more confusing
11:15:34 <Saizan> QP: yeah, the point is to not get surprising duplication of work
11:15:39 <jmcarthur_work> QP, it's so that the runtime behavior is what most people would expect
11:15:41 <sclv__> so the next version of haskell plans to scrap it
11:15:52 <QP> so why does io x = liftIO x work?
11:16:00 <QP> surely the same applies?
11:16:03 <sclv__> io is declared as a function, not a value there
11:16:05 <jmcarthur_work> QP, that looks like a function instead of a value
11:16:07 <sclv__> (i.e. it takes arguments)
11:16:15 <sclv__> so nobody would expect it to be monomorphic
11:16:22 <jmcarthur_work> QP, or you could use the point free version and give it an explicit type signature\
11:16:25 <Saizan> QP: because the idea is that if you have an argument you don't expect multiple applications to share the work
11:16:34 <QP> oh, but isn't a function also a value?
11:16:48 <Saizan> it is..
11:16:55 <Saizan> it's quite subtle :)
11:17:05 <Saizan> it's nothing fundamental however
11:17:11 <jmcarthur_work> QP, we just have ever so slightly different semantics for the two things
11:17:21 <Saizan> and they're probably going to remove this restriction
11:17:26 <QP> i thought we were meant to treat functions and 'contants' the same
11:17:45 <Saizan> QP: the function is constant, but the application of it isn't
11:17:59 <QP> they are all just elements of Hask...
11:18:57 <sclv__> it is widely considered a wart for precisely the reasons you give
11:19:33 <QP> ok :-)
11:19:41 <Saizan> if you write something like "let x = <expr> in (x,x)" you'd expect expr to be evaluated only once, but if x has a typeclass context it's actually implemented as a function of that dictionary
11:20:00 <Saizan> so you get <expr> evaluated twice
11:20:01 <seydar> i return!
11:20:09 <Saizan> and that's what the MR wants to avoid
11:20:17 <seydar> Saizan: MR?
11:20:21 <Saizan> forcing you to think about the possible loss of sharing
11:20:27 <Saizan> MonomorphismRestriction
11:20:53 <QP> ok, i think i sort of understand
11:21:17 <QP> i'll go and add xs to my def. of io!
11:22:47 <QP> woo! it works
11:22:55 <QP> thanks guys
11:23:25 <edwardk> i had a strange hack to avoid needing an MR in a toy compiler a while back but retain sharing, but it was totally a hack =)
11:24:17 <Saizan> you memoized polymorphic bindings using the type as key? :)
11:24:23 <edwardk> Saizan: yeah basically =)
11:24:34 <edwardk> saizan: although with only one memo-slot
11:24:57 <edwardk> saizan: and my types were 'views' so i memoized the application of one view to a term
11:25:18 <edwardk> so if you asked for the same view again in order you got the same result.
11:25:37 <edwardk> with some trickery you can do it with only write order visibility guarantees and no locking mechanism
11:25:45 <seydar> Saizan: maybe i drew the wrong lesson, but it sounds like if you always use a type signature you'll never have to worry about MR
11:25:50 <edwardk> thanks to the magic of xor
11:26:10 <edwardk> seydar: well you nede to worry about it if you care about the sharing that is lost
11:26:16 <edwardk> seydar: but otherwise, correct
11:26:34 <QP> ie. I want io to work for any MonadIO
11:26:39 <seydar> what sharing is lost if you're merely adding type sigs?
11:27:14 <QP> then i need to define two io functions---one for Server and one for Inter
11:27:39 <edwardk> seydar: forall a. Num a => a used as an Int and as an Integer will have to replay the same computations through each Num instance.
11:27:49 <edwardk> seydar: so you'll have lost sharing
11:28:11 <Saizan> QP: in your case you don't have sharing to lose
11:28:17 <seydar> i.... guess?
11:28:35 <QP> what do you mean, io is shared between the two monads?
11:28:39 <QP> isn't it
11:28:59 <Saizan> by sharing we mean at runtime
11:29:15 <Saizan> i.e. not recompute the same expression twice or more
11:29:18 <edwardk> seydar: let x :: Num a => a; x = 1 + 1 in (x :: Int, x :: Integer) -- those are two completely separate thunks in memory
11:29:28 <QP> runtime is a thing i prefer not to think about
11:29:42 <seydar> oooooh, so MR is a low level dohickey
11:29:43 <Saizan> then stick with the polymorphic io :)
11:29:47 <benmachine> edwardk: if that was (x, x) :: (Int, Int) then would they be shared?
11:30:03 <benmachine> erm, (x :: Int, x :: Int)
11:30:04 <edwardk> seydar: wherease let x = 1 + 1 in (x,x) -- has one 'x' thunk which both members of the pair refer to
11:30:20 <edwardk> benmachine: depends on how smart the compiler is being that day about common sub-expression recognition
11:30:36 <Saizan> which means probably not
11:30:38 <benmachine> suppose it's a summer's monday morning and the compiler is ghc
11:30:48 <edwardk> benmachine: but the monomorphism restriction means the compiler can 'always be at least that smart'
11:30:54 <lilac> haskell'98 doesn't /require/ sharing, but it's designed to /allow/ it, and that's what the MR was for
11:31:19 <seydar> edwardk: ahhhhhh i gortcha
11:31:23 * benmachine wonders if there will be an -XMonomorphismRestriction some day
11:31:32 <QP> benmachine: i'm in England, it's a summer monday evening here...
11:31:33 <seydar> benmachine: what would it do?
11:31:41 <benmachine> QP: me too
11:31:46 <benmachine> seydar: turn it back on :P
11:32:01 <benmachine> (on the presumption that consensus will have it turned off)
11:32:13 <QP> nice translation to US then!
11:32:13 <lilac> benmachine: well, once ghc grows a -XHaskellPrime, maybe
11:32:17 <seydar> benmachine: what does having it turned on/off mean?
11:32:24 <edwardk> benmachine: there is an -XNoMonomorphismRestriction at least
11:32:38 <lilac> benmachine: but probably only as a side effect of being able to turn off other bits of HaskellPrime, i'd guess
11:32:45 <lilac> (that is, an -XNoFoo for all -XFoo)
11:32:47 <edwardk> benmachine: UHC has no MR by default GHC can disable it
11:32:49 <benmachine> edwardk: yes I was wondering if the situation would one day be reversed
11:33:02 <copumpkin> mongodb's name really pisses me off for some reason
11:33:09 <lilac> magic 8-ball says that for 6 months it'll be called -XNoNoMonomorphismRestriction and no-one will notice or care
11:33:15 <benmachine> heh
11:33:26 <sclv__> :t parrot status
11:33:28 <lambdabot> Not in scope: `parrot'
11:33:28 <lambdabot> Not in scope: `status'
11:33:34 <sclv__> oops
11:33:44 <edwardk> benmachine: not sure i like disabling it. it is a downright useful property for a lot of code, and like everything in haskell these days you can work around it with an explicit type signature to get the more general type
11:33:45 <QP> i drink i'm two thunk for this... i'm seeing (Double, Double)
11:33:53 <shapr1> sclv__: y0, it was cool to meet you!
11:34:09 <sclv__> shapr1, edwardk: ditto!
11:34:22 <benmachine> edwardk: yeah, it annoys me but I think I'd rather it was there
11:34:25 <edwardk> any major base language change that caused a whole chunk of normal haskell code to start running asymptotically slower would be seen by the community as a bug
11:34:52 <lilac> @remember QP i drink i'm two thunk for this... i'm seeing (Double, Double)
11:34:53 <lambdabot> Nice!
11:34:58 <edwardk> sclv__: had an awesome time at hac phi... and your jmacro stuff has been very influential on my thinking
11:35:06 <yitz> MR should definitely by off by default in ghci though
11:35:19 <yitz> *be
11:35:34 <sclv__> edwardk: that's pretty hight praise. :-)
11:35:43 <edwardk> sclv__: (though you could go through and redefine your version of Bjorn's compos to just take an Applicative and get a simpler signature -- you never use composOpFold -- and that can even be recovered with a suitable Applicative
11:36:09 <edwardk> sclv__: i stole your TH via HOAS trick and have been abusing it for great evil
11:36:10 <lilac> edwardk: is there any code which compiles both with and without MR but has different behaviour (inc. sharing) in the two cases?
11:36:12 <shapr1> You should have seen edwardk's compos before he ripped it out.
11:36:33 <sclv__> yr monoids stuff likewise is kicking around in my head. i'm pretty sure its applicable to a really nice columnar database
11:36:53 <edwardk> sclv__: nice. i went and rewrote most of the parsing stuff for kata to be monoidal btw
11:36:55 <jmcarthur_work> i would love to see monoids get a lot more use
11:36:57 <seydar> edwardk: how does code run asymptotically slower?
11:37:01 <edwardk> sclv__: so i'm back where i started.
11:37:09 <jmcarthur_work> they are so simple compared to Applicative/Monad/etc.
11:37:24 <edwardk> seydar: i.e. if you constructed a full binary tree with sharing or without sharing
11:37:31 <sclv__> not sure what you mean about compos though? do you have an example you can paste?
11:37:55 <edwardk> class Compos t where Applicative f => (t -> f t) -> t -> f t
11:38:05 <edwardk> then replace ret and app with pure and <*>
11:38:11 <edwardk> throughout your existing definition
11:38:14 <seydar> edwardk: er, rather, what do you mean by asymptotically?
11:38:43 <edwardk> seydar: if you have some operation that needs to force a big tree of computation like that it may be able to force the left leg then go to force the right and find it already forced because it is shared
11:39:08 <edwardk> seydar: if you have a tree of such computations it can go from n to 2^n without sharing fast
11:41:01 <edwardk> data Tree a = Bin (Tree a) a (Tree a) | Tip; level i = let ip1 = level i + 1 in Bin ip1 i ip1 -- note the extra sharing there. each leg refers to the same source
11:41:34 <lilac> seydar: do you know what asymptotic complexity means, when applied to the runtime of a program?
11:41:52 <edwardk> sclv__: its purely a definitional cleanup
11:43:01 <edwardk> sclv__: composOpFold can be recovered in one of several ways by cps transformation or more sneakily by using the reflection library to make up an ad-hoc Applicative
11:43:02 <seydar> lilac: no, can you explain it please?
11:43:35 <sclv__> ah, gotcha.
11:43:49 <edwardk> but you don't use it anyways
11:43:58 <sclv__> I think I just followed the paper for the compos definition
11:44:17 <lilac> seydar: let's say we have a program operating on an input of size 'n'. we can look at how the runtime of that program behaves as 'n' becomes large
11:44:19 <edwardk> i went and started trying to use compos myself but gave in and just used SYB, by syntax tree is a tidge hairier than yours
11:44:19 <seydar> edwardk: thanks for the example, i now understand sharing
11:44:41 <edwardk> sclv__: so my compos definition started to balloon to 100+ lines
11:44:45 <idnar> how would I parse N of something in parsec?
11:44:46 <sclv__> you need syb anyway eventually for the template haskell...
11:44:50 <copumpkin> fibonacci is an obvious example
11:45:07 <edwardk> sclv__: exactly. so i already had to figure out my scary typeable derivations.
11:45:25 <lilac> seydar: if, for a big enough n, the runtime of our program is at most f(n) (steps, or seconds, or whatever), we say the runtime is O(f(n))
11:45:46 <edwardk> sclv__: the hoas trick is a bit trickier for me to apply too because my lexical scoping rules are less clear
11:45:53 <randomity> idnar: Parsec is a monad, so sequence (replicate n parser) should work
11:45:59 <seydar> lilac: yargh, i follow
11:46:06 <edwardk> i.e. i bring into scope names from superclasses of the class you are in so those should be exposed to haskell as well
11:46:07 <lilac> seydar: (technically, we actually say if there exists k so that for big enough n the runtime is at most k*f(n), then ...)
11:46:08 <Cale> at most c*f(n) for some fixed constant c
11:46:09 <yitz> randomity: replicateM
11:46:16 <edwardk> so i need to bring them into scope hoas style for the duration of the TH translation
11:46:28 <yitz> @src replicateM
11:46:28 <lambdabot> replicateM n x = sequence (replicate n x)
11:46:29 <sclv__> ah, tricky.
11:46:34 <edwardk> which means i need to have done part of my typechecking, at least to the point of recognizing all of my superclasses
11:46:35 <idnar> is there a shorter name for replicateM? :P
11:46:37 <Cale> That's quite important, because it means that O(n) and O(2n) are the same
11:46:47 <idnar> replicateM 32 hexDigit just seems a bit wordy
11:46:49 <randomity> yitz, nice, didn't know about that one
11:47:00 <sclv__> but it also expresses parametricity, so it reveals something about the underlying structure...
11:47:07 <randomity> idnar: rep = replicateM should solve that one
11:47:12 <lilac> seydar: we can show that the asymptotic runtime complexity of 'sort' is O(n * log n), and the worst-case complexity of (!!) is O(n) (where n is the length of the list in both cases)
11:47:31 <edwardk> which also means that 'template kata' antiquotes that extend the names provided by  kata classes will make names that won't be brought into scope for hygienic access from other 'template kata' antiquotes
11:47:33 <idnar> @type replicateM
11:47:34 <yitz> idnar: ah, well. if you have -XNoMonomorphismRestriction, you can easily define a short alias if you'd like. :)
11:47:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
11:47:38 <idnar> yitz: haha
11:47:46 <edwardk> otoh, using them inside of expressions or patterns works fine
11:47:55 <seydar> lilac: i understand that, but why does it call it asymptotic? like it has a limit?
11:48:25 <Cale> seydar: because it only applies to large enough inputs
11:48:26 <lilac> seydar: yeah, that's it. it's describing how the runtime behaves as a function of n, in the limit
11:48:37 <sclv__> right -- staging and typechecking have a weird intersection -- i think there's lots of work to be done there.
11:48:49 <lilac> (for some precise meaning of "in the limit")
11:48:53 <soupdragon> what intersection?
11:48:54 <sclv__> although i saw an interesting paper on lambda on macros in the presence of modules
11:49:19 <soupdragon> of staging and typechecking
11:49:23 <edwardk> seydar: in computer science you are often concerned about the performance of an algorithm as the input gets larger in some sense. You can generally find some function of the size of the input that your program will not exceed in terms of execution time (after being scaled by some arbitrary constant)
11:49:56 <idnar> @hoogle liftA4
11:49:56 <lambdabot> No results found
11:49:56 <edwardk> seydar: you are concerned with the fact that you are bounded, asymptotically by that function in the limit, hence 'asymptotic complexity'
11:49:57 <seydar> ahhh
11:49:59 <idnar> aww
11:50:03 <seydar> i gotcha
11:50:04 <randomity> the precise meaning in question is "f(x) is O(g(x)) iff g(x) >= c * f(x) for all x greater than some initial x0, for some constant c
11:50:25 <seydar> so it really did turn out to be as simple as i thought
11:50:27 <soupdragon> sclv__?
11:50:30 <edwardk> seydar: yeah
11:50:30 <idnar> @type Control.Applicative.many
11:50:31 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
11:50:42 <seydar> thanks for explaining everything anyways
11:50:49 <yitz> the interesting part is how to make sense of this "number of operations" thing in a functional setting
11:50:56 <edwardk> seydar: a good chunk of computer science is all about figuring out the asymptotic complexity of different algorithms or different classes of algorithms
11:51:03 <randomity> number of reductions works pretty well...
11:51:15 <idnar> bleh
11:51:18 <seydar> edwardk: heh, i've avoided the theory classes for as long as i could
11:51:33 <yitz> randomity: it does. but that's dependent upon a particular implementation.
11:51:37 <edwardk> randomity: yeah but in a lazy setting its usually predicated on the amount of the input demanded, etc.
11:51:54 <Cale> Another way to put it is that f(x) is in O(g(x)) if the lim sup as x -> infinity of |f(x)/g(x)| is finite.
11:51:54 <sclv__> soupdragon: if you have an edsl compiled via staging (i.e. template haskell or the like) and you typecheck that edsl, how do you deal with the combination
11:52:07 <soupdragon> I don't know
11:52:22 <randomity> no, in a lazy setting the reductions are done in normal order. no matter what the implementation, there is a minimum number of reductions necessary to reduce a term to head-normal-form (i.e. for a list, to get the first element out)
11:52:22 <sclv__> that's the intersection i'm talking about -- i think it's a set of open questions.
11:52:49 <idnar>     No instance for (Stream s m Char)
11:52:53 <idnar> now what have I done :/
11:53:21 <idnar> oh, MR again
11:53:22 <edwardk> sclv__: i've been trying to figure out if i could allow TH expansions to iteratively add properties until i reach a fixpoint or something
11:53:41 <edwardk> sclv__: that kills the 2-layer TH problem at least, but its tricky to judge
11:54:06 <randomity> Cale: I think that's a bit different than normal big-O
11:54:18 <yitz> randomity: haskell isn't lazy, it's non-strict. it's up to the compiler.
11:54:48 <randomity> consider whether sin(x)-0.5 is O(sin(x))
11:54:48 <seydar> if i were to assume P = NP, would that change anything for me at all
11:55:36 <ppavelV6> seydar: your confidence in asymmetric crypto, probably :)
11:55:45 <yitz> seydar: you might turn into a frog. other than that, no.
11:55:53 <randomity> yitz: there's a well-known evaluation order called normal order which does the minimum number of ereductions and the maximum amount of laziness to come to an answer
11:55:59 <copumpkin> seydar: an obviously exponential algorithm will stay exponential
11:56:17 <sdschulze> Again a n00b question:  Why doesn't http://sdschulze.dnsalias.org/~soeren/fact.hs work?
11:56:37 <sdschulze> (I'm thinking something similar to Common Lisp's letrec)
11:56:45 <seydar> then why do people make such a big deal out of it
11:57:01 <soupdragon> seydar I am not making a big deal of it
11:57:11 <copumpkin> seydar: lots of interesting problems are a special kind of exponential time
11:57:13 <lilac> randomity: number of reductions depends on what is shared
11:57:21 <seydar> soupdragon: wasn't targeting you, i was just wondering in general
11:57:40 <yitz> sdschulze: you need to indent more
11:57:50 <yitz> (the if then else)
11:58:06 <mkaemmer> seydar: if P=NP, then that means there are poly-time algorithms to solve problems people have only been able to do in exponential time thus far
11:58:12 <edwardk> seydar: there are a bunch of EXPSPACE, etc algorithms that are bigger, so we still talk about the asymptotic complexity even if P = NP
11:58:26 <seydar> oh, and what ever happened to that guy who was able to factor any number in near linear time?
11:58:35 <yitz> sdschulze: or was that the problem?
11:58:36 <sdschulze> yitz: works, thanks
11:58:58 <idnar> can anyone improve on http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3137 ?
11:59:01 <mkaemmer> seydar: was he using a quantum computer?
11:59:15 <sdschulze> yitz: Does it also work using "where"?
11:59:21 <yitz> sdschulze: yep
11:59:26 <edwardk> seydar: you mean the Shor' QPP factoring algorithm?
11:59:27 <idnar> that started off as a regex: ^(.{32})(.{8})(.+?)!(.*)$
11:59:37 <idnar> (I know the parsec code isn't exactly identical)
11:59:41 <soupdragon> idnar, I don't think 'rep' improves it
11:59:48 <seydar> mkaemmer: no, he presented it at EuroCrypt recently
11:59:50 <edwardk> seydar: its QPP not linear. (quantum probabalistic polynomial)
12:00:00 <yitz> sdschulze: but in haskell, tail-recursive won't help you. your strategy will blow the stack, in general.
12:00:26 <sdschulze> yitz: ah, OK
12:00:27 <copumpkin> seydar: if it were practical, a lot of crypto would break instantly :P
12:00:27 <yitz> for fact it's ok, because you'll never plug in really big numbers.
12:00:42 <seydar> copumpkin: that's what me and delaney thought
12:00:46 <copumpkin> so there's probably a big BUT somewhere
12:00:46 <edwardk> decoherence will set in before you can use it on anything big
12:01:05 <ppavelV6> copumpkin:  lot of widely used crypto, I'd say. With no replacement around.
12:01:08 <sdschulze> yitz: I was choosing tail recursion because I want to print intermediate results.
12:01:27 <copumpkin> ppavelV6: well you can use lamport signatures
12:01:32 <copumpkin> ppavelV6: but those are kind of impractical
12:01:58 <sdschulze> yitz: Or should I better return a list of intermediate results and print out that list using "map"?
12:02:12 <yitz> sdschulze: ah ok. but then you'll want myfact as a top-level function, so you can access it directly from IO.
12:02:28 <ppavelV6> copumpkin: hmm... home not all key exchange protocols are logged now :)
12:02:36 <seydar> i'm gonna try to find the guy's PDF and link you all to it
12:02:39 <yitz> sdschulze: that would also work. could be nice.
12:02:51 <idnar> @src (*>)
12:02:51 <lambdabot> (*>) = liftA2 (const id)
12:03:25 <edwardk> seydar: sounds like some arxiv crackpot ;)
12:03:31 <copumpkin> lol
12:03:47 <sdschulze> yitz: But printing values for debugging doesn't seem as easy as in imperative languages.
12:03:48 <yitz> sdschulze: this is really a fold. the standard fold functions foldl and foldr have versions that give all the intermediate results, scanl and scanr.
12:03:52 <idnar> @src ap
12:03:52 <lambdabot> ap = liftM2 id
12:04:09 <seydar> copumpkin: take back that lol! i will redeem my name
12:04:15 <yitz> sdschulze: if it's just for debugging, you can use trace
12:04:18 <copumpkin> :P
12:04:19 <yitz> @type trace
12:04:20 <lilac> seydar: if P = NP then the following algorithm solves any NP-complete problem in polynomial time: f input checker = allPrograms >>- (\p -> guard (checker input (p input)) >> return (p input))
12:04:21 <lambdabot> Not in scope: `trace'
12:04:24 <idnar> @src liftM2
12:04:24 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:04:36 <yitz> @hoogle trace
12:04:36 <lambdabot> Debug.Trace trace :: String -> a -> a
12:04:36 <lambdabot> module Debug.Trace
12:04:36 <lambdabot> package traced
12:04:48 <edwardk> seydar: I used to teach Shor's algorithm. its a nice toy, and it shows that QPP is more powerful than people think P is, which is, btw- pretty awesome, and also means you probably have some horrible decoherence tax that you'll have to pay if the universe is at all 'fair', but its not a linear time factorization of  any number by any means =)
12:05:20 <lilac> i have a constant time factorization algorithm
12:05:30 <sdschulze> yitz: I see... I need to flip some things around in my brain for Haskell.
12:05:37 <yitz> sdschulze: being side-effectful, there's no predicting exactly what it will do, so don't use it for live code, but it's useful for debugging.
12:05:39 <copumpkin> I can factor primes of any size in constant time
12:05:39 <lilac> it involves applying brute force to the person who did the multiplication until they tell me the factors
12:05:40 <edwardk> lilac: writing them down before you take their product to give to someone else? =)
12:05:56 <ppavelV6> lilac if the do know them :)
12:05:57 <lilac> edwardk: or that :)
12:06:04 <edwardk> yeah blunt force trauma is a pretty good factoring tool
12:06:39 <lilac> most of the problem of factoring large numbers is making other people /believe/ you did it rather than actually doing it
12:06:41 <mkaemmer> lilac: apply the thunks to their head!
12:06:48 <lilac> there're plenty of solutions for that problem :)
12:06:49 <yitz> sdschulze: but yeah, the real way to do it is to make things you might want to print available as top-level functions, then you can call them from an IO function.
12:06:52 <edwardk> for some reason i read yitz's side-effectful comment as being about lilac's factoring algorithm... and it fit =)
12:07:00 <lilac> mkaemmer: ok, but only if i'm forced
12:07:00 <yitz> heheh
12:08:00 <yitz> @google xkcd crypto
12:08:01 <lambdabot> http://xkcd.com/153/
12:08:01 <lambdabot> Title: xkcd - A Webcomic - Cryptography
12:08:51 <sdschulze> yitz: Speed-optimizing Haskell code probably works the reverse way that optimizing imperative code works.
12:08:52 <yitz> no that's not it
12:09:33 <hackagebot> nemesis 2009.8.4 - a rake like task management tool (JinjingWang)
12:09:41 <yitz> @google xkcd encryption
12:09:42 <lambdabot> http://xkcd.com/538/
12:09:42 <lambdabot> Title: xkcd - A Webcomic - Security
12:09:45 <yitz> there we go
12:10:57 <yitz> sdschulze: not exactly reverse, but some things are quite different, yes.
12:11:49 <seydar> i can't find it now
12:11:52 <seydar> but i promise i will alter
12:11:53 <idnar> @src (*>)
12:11:53 <lambdabot> (*>) = liftA2 (const id)
12:11:54 <seydar> later*
12:12:49 <copumpkin> seydar: epic fail
12:13:12 <seydar> stfu
12:13:16 <copumpkin> lol
12:13:17 <seydar> imma stalk you
12:13:37 <copumpkin> :o
12:13:59 <copumpkin> onoes
12:14:11 <copumpkin> plz2not stalk kthx
12:14:17 <copumpkin> ceiling cat would disapprove
12:14:26 <seydar> trash cat would looooooove
12:15:33 <copumpkin> meow
12:16:06 <edwardk> lilac: your constant time factoring algorithm is technically linear in the # of bits because they have to at some point in time write down the #s to give them to you ;)
12:17:07 <copumpkin> my lazy factoring algorithm for primes of any size in haskell is truly constant time
12:17:35 <edwardk> copumpkin: its easy to factor primes =)
12:17:36 <hackagebot> yaml 0.0.1 - Support for serialising Haskell to and from Yaml. (MichaelSnoyman)
12:17:49 <copumpkin> edwardk: always belitting my achievements :(
12:17:49 <sdschulze> type inference is so cool
12:18:04 <copumpkin> belittling even
12:18:05 <mkaemmer> copumpkin: the question is, what is its behavior for non-primes?
12:18:24 <copumpkin> mkaemmer: it only works for primes
12:18:31 <edwardk> mkaemmer: undefined, its outside of the domain of the function. it can do whatever it wants =)
12:18:44 <idnar> @src sequence
12:18:45 <lambdabot> sequence []     = return []
12:18:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:18:45 <lambdabot> --OR
12:18:45 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:19:28 <edwardk> > let factorPrime x = [1,x] in factorPrime 7
12:19:29 <lambdabot>   [1,7]
12:19:34 <edwardk> see, it works!
12:19:57 <copumpkin> damn, you stole my algorithm :(
12:20:02 <edwardk> muahahaha
12:20:10 <copumpkin> my glory, gone!
12:21:32 * Saizan ponders about memoizing the query function for his memotable
12:21:46 <edwardk> heh, you could use SCC to put a precondition on the argument that it isPrime or something. ;) it'd probably just give you a bunch of warnings about piddly things like that it couldn't prove the precondition, etc.
12:22:04 <Saizan> i use Ord currently, but that can be quite slow for big values i guess
12:22:10 <copumpkin> http://www.scc-fl.edu/
12:22:23 <edwardk> Saizan: stablename?
12:23:02 <Saizan> edwardk: yeah, i guess i'm going to use that
12:23:31 <edwardk> Saizan: seq, stablename it, and sort by the hash of the stablename, given the exact same input thunk it'll have nice performance characteristics
12:24:38 <copumpkin> but that doesn't give you real equality
12:25:09 <edwardk> its a more real equality than the one you are trusting Eq for
12:25:15 <edwardk> I mean, Eq lies all the time.
12:25:50 <copumpkin> how do you mean?
12:26:14 <McManiaC> @pl f sc i = b (x i) sc
12:26:14 <lambdabot> f = flip (b . x)
12:27:19 <edwardk> > let nan = 0/0 in nan == nan
12:27:21 <lambdabot>   False
12:27:28 <edwardk> so much for reflexivity =)
12:27:37 <Saizan> i need the Eq meaning though, i guess i can use (==) `on` stablename || (==)
12:27:40 <copumpkin> that's IEEE's issue
12:27:49 <Saizan> (for an imaginary lifted ||)
12:27:52 <copumpkin> and Eq's fault for not specifying strict laws :P
12:27:53 <edwardk> copumpkin: sure, but Eq lies for other things as well =)
12:28:16 <edwardk> i.e. i can distinguish values that evaluate with (==) returning true, etc.
12:28:43 <edwardk> copumpkin: at least the stablename is some kind of real 'they refer to the exact same flipping thing' equality =)
12:28:47 <copumpkin> instance (Enumerable a, Eq b) => Eq (a -> b)
12:29:07 <copumpkin> well, they refer to the same thing, but if I create a separate thing which is equal by most definitions
12:29:11 <copumpkin> it'll have a different stable name won't it?
12:29:35 <copumpkin> I started writing an Enumerable class a while back
12:29:36 <edwardk> copumpkin: sure, but i can still distinguish them by the effects of their unsafePerformIO'd contents ;)
12:29:39 <copumpkin> not sure where the code went
12:30:05 <Athas> Is there a module for making records a little more pretty?
12:30:28 <Athas> I have a state monad containing a record with a bunch of fields, and the use of 'modify' to change those fields isn't very pretty at all.
12:30:33 <PeakerWork> copumpkin: I guess there should just be an enumerate :: [a]  ?
12:30:43 <copumpkin> PeakerWork: that's how I was writing it, yeah
12:30:45 <yitz> instance Eq Foo where (==) = const (const  False)
12:30:52 <edwardk> athas: there is Data.Accessor
12:30:59 <edwardk> athas: it seems to be popular these days
12:31:13 <Athas> Thank you, I will take a look at it.
12:31:25 <Athas> It's not on Hoogle?  Huh.
12:31:51 <edwardk> copumpkin: check hackage for the accessor package
12:31:58 * copumpkin coughs
12:32:04 <copumpkin> yessir! http://hackage.haskell.org/package/data-accessor
12:32:16 <copumpkin> :P
12:32:17 <edwardk> lol
12:32:34 <edwardk> wow, that worked. i should try that more often
12:32:47 <copumpkin> Athas: my master edwardk commanded me to find that for you, I hope that helps
12:32:52 <edwardk> best bot ever
12:32:58 <edwardk> well, its a little lippy
12:33:05 <copumpkin> :o
12:33:08 <copumpkin> ;)
12:33:16 <edwardk> but it knows a little more category theory than lambdabot at least
12:33:23 <Athas> How useful!
12:33:24 <copumpkin> not much more :P
12:33:35 <copumpkin> trying to fix that though
12:33:52 <edwardk> i need to install a faster processor, figure out how to get it to run the garbage collector more often...
12:33:59 * copumpkin thinks of his todo list as a list of bug reports that must be fixed
12:34:31 <edwardk> that and the colocation arrangement is a little inconvenient being all the way up north like that
12:34:37 <copumpkin> lol
12:34:50 <seydar> edwardk: do you live in bahstahn?
12:34:53 <copumpkin> one day that will change I hope
12:35:05 <copumpkin> this area is pretty but I don't really enjoy being in the middle of nowhere
12:35:07 <Milo-> My C-like brain can't interpret Monads
12:35:07 <edwardk> seydar: somerville, but yeah, the general area.
12:35:10 <seydar> what copumpkin means to say is that he will live here for 5 more years
12:35:23 <copumpkin> lol, I hope not
12:35:36 <seydar> copumpkin: dude, it's a fucking party here all the time
12:35:45 <seydar> we live in the most ballin town evah
12:35:55 <benmachine> perpetuparty
12:35:55 <seydar> super exciting
12:35:57 <edwardk> copumpkin: well, i tried to lure you down to the city for gainful employment and vast riches...
12:36:00 <seydar> oh gods who am i kidding
12:36:09 <edwardk> copumpkin: silly goose deciding to get a phd
12:36:11 <copumpkin> I've been here for over 5 years already, it's getting old :P
12:36:28 <copumpkin> edwardk: yeah, pity I only discovered haskell and this channel after starting my program :(
12:36:55 <edwardk> copumpkin: economics has this wonderful concept... 'sunk cost' ;)
12:37:01 <copumpkin> lol
12:37:47 <copumpkin> edwardk is the little red guy hanging out on my shoulder whispering in my ear
12:38:26 <edwardk> heh, the biggest problem with getting a phd is the long line of people willing to give you so much more money to quit. ;)
12:38:47 <shepheb> seems like edwardk is a fan of the autodidact.
12:38:52 <seydar> then shouldn't i go for a phd just to quit halfway?
12:39:41 <seydar> s/i/he
12:39:45 <edwardk> shepheb: yes and no. i love structured education. i also like learning stuff on my own. i also like money. if i could get all three at the same time, I would be all set.
12:39:50 <shepheb> I feel dirty for considering it, but my path may be to get a job as a programmer at a mediocre company so I can put in little effort and "slack off", by which I mean hack on Haskell projects and learn things.
12:39:53 <copumpkin> seydar: I think you need to get a high school degree first, usually
12:40:08 <dschoepe> How do I build the haddock documentation for a cabal package without haddock linking to the module documentation for the modules installed locally?
12:40:24 <shepheb> of course I'd love a job that let me do interesting things, but in the meantime...
12:40:33 <SubStack> I want to save up enough money so that I can go a few years between jobs, wandering about
12:40:33 <lilac> Milo-: i think the very first thing to unlearn when learning about monads is the notion that they're hard
12:40:40 <seydar> copumpkin: we actually like to keep that on the DL
12:40:49 <copumpkin> aha
12:41:05 <PeakerWork> copumpkin: isn't it better to get a part-time job?
12:41:22 <Saizan> dschoepe: you can pass it --html-location to make it link to somewhere else
12:41:22 <PeakerWork> copumpkin: (I personally can't do it, in the rest of my week I just can't do non-work, too exhausted, but most people can)
12:41:35 <copumpkin> PeakerWork: better than what?
12:41:43 <copumpkin> PeakerWork: oh, better than being a poor phd student?
12:41:45 <dschoepe> Saizan: Can I also tell it not to link to any other packages?
12:41:53 <dschoepe> Since that still leaves broken links
12:42:34 <Saizan> dschoepe: no, there isn't an option for that
12:42:39 <edwardk> shepheb: to be fair, i've been thinking about going back for a ph.d, i just can't justify the opportunity cost.
12:43:20 <lilac> edwardk: i feel much the same. no-one will pay me enough to do a phd :)
12:43:37 <dschoepe> Saizan: hmm, I could temporarily rename my .cabal/share/doc folder
12:43:42 <PeakerWork> copumpkin: oops, I was misreading it as your comment, rather than shepheb.  shepheb: The above copumpkin: ... comment was to you
12:43:55 <copumpkin> ah :)
12:44:08 <PeakerWork> shepheb: its the curse of Haskell. Once you know it, its hard to derive fun from other languages, which most workplaces use
12:44:11 <Saizan> dschoepe: i'm not sure if that'd work
12:44:27 <lilac> well, if anyone is in Cambridge and likes Java (fat chance, I know), my company is hiring
12:44:27 <copumpkin> my main regret about my computing history is not being exposed to this stuff earlier
12:44:29 <burp> how true
12:44:33 <shepheb> PeakerWork: I know the feeling
12:44:45 <dschoepe> Saizan: hmm it still links to my local ghc documentation, but nothing else
12:44:45 <shepheb> I'm nearly done my undergrad, but I've been doing internships
12:45:06 <edwardk> lilac: all i'd do is spent a few years earning nothing, doing what i'm already doing, in order to earn a piece of paper that in most circles entitles me to earn less, when i'm usually seen as overeducated already ;)
12:45:08 <dschoepe> Saizan: Is there perhaps a better way to provide documentation for a darcs repo(hosted on code.haskell.org)
12:45:08 <shepheb> I've found that at a serious company I'm often too tired to hack in the evenings and weekends
12:45:18 <shepheb> which is why I say I want somewhere terrible
12:45:23 <shepheb> but then my resume is tainted
12:45:47 <abuiles> Hi All, has someone before read a bitmap with hopengl and render it to the buffer  ? I have been trying to do that, But I can't get a clear image when calling drawPixels . here is what I
12:45:52 <abuiles> ve done so far http://gist.github.com/160787
12:46:02 <shepheb> maybe I should go to Amazon in a group one of my friends interned with. fairly slack, no resume stigma.
12:46:13 <Saizan> dschoepe: you should be able to link to hackage.haskell.org documentation i think
12:46:38 <lilac> edwardk: right! at least half the stuff i do here is research which could have counted towards a PhD. this way i get more money but fewer letters after my name. i think that's the better option.
12:47:10 <copumpkin> edwardk: well, if you put it _that_ way!! :P
12:47:42 <edwardk> copumpkin: heh, to be fair i might go back for another masters at some point. small investment and no stigma ;)
12:47:53 <seydar> edwardk: what in?
12:48:06 <edwardk> and generally i like masters degrees as they tend to cover breadth not depth
12:48:13 <dschoepe> Saizan: How do I tell haddock to do that? --html-location seems to assume that the module documentation is directly in the given directory
12:48:27 <copumpkin> edwardk: afraid a PhD will make you grow long disorderly white hair, a white beard, and a permanent cloud fixed around your head (along with people's perception of that kind of person)?
12:48:29 <idnar> uhm, so
12:48:35 <idnar> Functor has fmap
12:48:41 <idnar> Applicative adds pure and (<*>)
12:48:43 <seydar> Functor!
12:48:46 <seydar> Applicative!
12:48:48 <idnar> what's the minimal operation you need to add to that to get (>>=)?
12:48:49 <hoknamahn> hey guys do you know how to fix this issue? http://www.moonpatio.net/fastcgi/hpaste.fcgi/view?id=3088
12:48:55 <copumpkin> idnar: join?
12:48:56 <byorgey> idnar: join
12:49:08 <copumpkin> I think pure should technically come from Pointed
12:49:10 <byorgey> idnar: see the Typeclassopedia secion on Monad for details =)
12:49:11 <lilac> idnar: well, (>>=), or join, or anything else which is equivalent in power given that set of operations.
12:49:15 <byorgey> *section
12:49:18 <jmcarthur_work> m >>= k = join (fmap k m)
12:49:19 <idnar> lilac: well, what I mean is
12:49:24 <idnar> lilac: (>>=) does "more" than you need
12:49:39 <edwardk> seydar: i did one for comp sci and one for mathematics, and a grad cert in artificial intelligence on the way, finished most of the requirements for a masters in bioinformatics and thought about doing one in linguistics when I was working at the linguist list, so either finish up the bioinformatics one or strike off and take an mba
12:49:40 <lilac> idnar: (>>=) doesn't give you more than a Monad
12:49:55 <lilac> idnar: i guess, what i mean is, minimal in what sense?
12:49:58 <idnar> lilac: no, but if you have (>>=) and pure, you don't need <*>
12:50:03 <copumpkin> edwardk: remember us when you're rich and famous!
12:50:03 <edwardk> copumpkin: yeah
12:50:06 <seydar> edwardk: so you're like old man time, right?
12:50:12 <PeakerWork> idnar: You can define join in terms of (>>=) and vice versa
12:50:18 <byorgey> idnar: I know exactly what you mean, and the answer is join =)
12:50:21 <lilac> idnar: if you have fmap, join and pure, you don't need <*> either
12:50:23 <byorgey> PeakerWork: you have to use fmap though.
12:50:28 <idnar> lilac: yeah...
12:50:29 <edwardk> copumpkin: unlikely to become rich and famous ;)
12:50:31 <seydar> edwardk: go for linguistics and an MBA
12:50:36 <PeakerWork> byorgey: yeah
12:50:41 <Saizan> dschoepe: you can give an url to that, and it accepts vars like $pkg $version ..
12:50:43 <PeakerWork> idnar: It does seem nicer to set join as the fundamental operation, though
12:50:43 <idnar> is there some operation that doesn't overlap with any of pure, <*>, and fmap, but still gives you a monad?
12:50:43 <edwardk> seydar: 33. i hope that doesn't qualify me as ancient =P
12:50:43 <copumpkin> I dunno, bioinformatics is pretty cool
12:50:47 <byorgey> lilac: oh, well, good point
12:50:48 <seydar> edwardk: apparently people find MBAs to be useful
12:50:53 <idnar> I can't really imagine what it might be
12:50:54 <copumpkin> ZOMG he's ancient
12:51:01 <jmcarthur_work> i think overlap is just a part of the game
12:51:02 <seydar> edwardk: course not! copumpkin is borderline 40
12:51:06 <edwardk> hahaha
12:51:08 <seydar> well, minus a shitload
12:51:08 <copumpkin> lol
12:51:10 <dschoepe> Saizan: Ah, okay. Thanks
12:51:17 <copumpkin> seydar: only 39
12:51:23 <lilac> idnar: so you want to know, does there exist a set of function containing fmap, ap and pure which characterizes a Monad, where removing any functions means it's not a Monad any more?
12:51:26 <byorgey> idnar: actually, pure and <*> already overlap with fmap
12:51:35 <byorgey> idnar: since  pure f <*> x === fmap f x
12:51:38 <seydar> copumpkin: in that case i'm calling the cops because if you're 39 you shouldn't be dating an undergrad
12:51:44 <idnar> byorgey: oh, good point
12:51:50 <edwardk> seydar: that said i didn't bother actually collecting anything in terms of formal education until a few years ago
12:51:55 <copumpkin> seydar: she's not an undergrad anymore :P and there's no law against it :P
12:52:00 <lilac> byorgey stole my thunder :(
12:52:02 <idnar> so is there a "lesser" operation than <*> that you could get an applicative from?
12:52:09 * copumpkin gives lilac some replacement thunder
12:52:14 <lilac> yay!
12:52:16 <jmcarthur_work> i think if there is such a set of operations, it doesn't include a couple of those other functions either.
12:52:31 <idnar> lilac: something like that
12:52:32 <jmcarthur_work> such a set of operations that have no overlap would have to have no laws which relate them
12:52:36 <seydar> copumpkin: really? she was a '09?
12:52:40 <copumpkin> yup
12:52:41 <jmcarthur_work> i think
12:52:42 <lilac> idnar: that's an interesting challenge. i assume you want that set of functions to be finite too? :)
12:52:49 <idnar> lilac: hopefully, yes :P
12:52:54 <Saizan> dschoepe:  cabal haddock --html-location="http://hackage.haskell.org/packages/archive/\$pkg/\$version/doc/html/"
12:52:55 <seydar> copumpkin: what's she doing now?
12:53:01 <copumpkin> seydar: hanging out :P
12:53:01 <idnar> lilac: I was just busy describing functor/applicative/monad to someone
12:53:06 <lilac> i suspect it's not possible to make such a basis for Applicative containing 'fmap', but i'd be interested to find out
12:53:12 <seydar> copumpkin: and come fall?
12:53:13 <idnar> lilac: and I was explaining it in terms of progressively adding operations
12:53:19 <copumpkin> seydar: moving to baltimore
12:53:20 <PeakerWork> idnar: What did you mean by "overlap" there?
12:53:21 <dschoepe> Saizan: Yeah, I figured it out, I just didn't know about $pkg and such
12:53:22 <edwardk> idnar: yes. look at the original paper there was a presentation in terms of the underlying strong lax monoidal functor
12:53:50 <Saizan> dschoepe: yeah, the --help is not clear on that
12:53:50 <byorgey> idnar: I think explaining it in terms of progressively adding operations is a great way to present it.
12:54:02 <idnar> PeakerWork: well, if you have fmap, pure, <*>, and join, you can throw away <*> or fmap and still have a monad
12:54:11 <seydar> copumpkin: what about the pumpkin&gf dynasty? what will happen to it, if you don't mind me asking?
12:54:12 <dschoepe> Saizan: I noticed =)
12:54:14 <copumpkin> byorgey: it'd be nice if we got a Pointed class in the stdlib to fill it out
12:54:16 <byorgey> idnar: it doesn't particularly matter that some of the operations can be implemented in terms of the others; that's just one of the things you have to explain along the way.
12:54:20 <byorgey> copumpkin: I agree.
12:54:21 <idnar> PeakerWork: if you have fmap, pure, <*>, and >>=, you can throw away both fmap and <*> and still have a monad
12:54:23 <copumpkin> seydar: it'll keep going probably
12:54:26 <edwardk> idnar: which is more applicable in other categories. In Hask the Applicative definition works because it is a CCC so you have exponentials available for everything. the strong lax monoidal functor definition works for weaker categories
12:54:31 <seydar> copumpkin: skilled lad ;-)
12:54:32 <idnar> byorgey: sure, it wasn't a big deal; I was just wondering about it
12:54:34 <copumpkin> lol
12:55:14 <seydar> edwardk: what's required to go and get a masters?
12:55:24 <copumpkin> you need a fancy hat
12:55:42 <idnar> I must say, join is way easier to explain than (>>=)
12:55:47 <PeakerWork> idnar: well, the "overlap" here is really much like linear algebra's linear dependency
12:55:48 <edwardk> seydar: usually a bachelor's and then crud ton of graduate credit and a thesis of some kind
12:55:48 <idnar> although the jump to do-notation is a bit tricky then
12:56:02 <idnar> PeakerWork: it's just that if you're talking about adding operations
12:56:05 <idnar> PeakerWork: it kinda goes like
12:56:07 <lilac> idnar: applicativeUberOperator :: Applicative f => Bool -> a -> f (a -> b) -> f a -> f b
12:56:14 <mkaemmer> idnar: well, nicely enough, category theorists define monads in terms of join instead of >>=
12:56:16 <seydar> edwardk: so you have to have a BA/BS before trying to get your masters?
12:56:28 <lilac> applicativeUberOperator False a _ _ = pure a; applicativeUberOperator True _ f x = f <*> x
12:56:35 <lilac> idnar: is that good enough? ;-)
12:56:41 <copumpkin> @let applicativeUberOperator = undefined
12:56:43 <lambdabot>  Defined.
12:56:47 <idnar> lilac: heh
12:56:48 <copumpkin> onoes, I ruined it
12:56:59 * lilac makes copumpkin pie
12:57:05 <copumpkin> ouch
12:57:07 <lilac> copumpkin: have some pie, it's delicious
12:57:09 <idnar> PeakerWork: start with fmap, add pure and <*>, oh by the way you can throw fmap away now
12:57:15 <opqdonut> is that kinda like pumpkin copie?
12:57:16 <copumpkin> lilac: I lost my family that way!
12:57:21 * mkaemmer makes copumpkin copie
12:57:22 * copumpkin cries
12:57:29 <copumpkin> lilac: you insensitive clod!
12:57:30 <edwardk> seydar: in general. there are a few masters in public accounting programs that try to merge the tail end of the accounting undergrad with the beginning of the masters so that you get through the whole thing in 5 years, or something but they are special things here and there
12:57:39 <lilac> copumpkin: i know! they were very tasty
12:57:57 <jmcarthur_work> http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html
12:58:00 <edwardk> seydar: of course thats all limited to just here in the states. abroad, definitions vary greatly
12:58:11 <edwardk> monoid = applicative with the argument cut off.
12:58:27 <edwardk> right seminearring = alternative with the argument cut off
12:58:59 <seydar> edwardk: say i graduate from collegeness majoring in CS. I want to get a masters in linguistics. do i have to go through 2 years of getting a BA, and then i go for 2 years of the master?
12:59:08 <PeakerWork> idnar: yeah, Applicative redefines fmap, and join (given fmap) redefines <*>
12:59:29 <edwardk> seydar: nah a lot of graduate programs will let you in with a bachelors in anything... but this has ranged pretty far afield and should probably move to #haskell-blah
12:59:42 <sdschulze> this is fun... http://sdschulze.dnsalias.org/~soeren/calcpi.hs
13:01:13 <lilac> edwardk: semen earring? eww?
13:01:28 <seydar> lilac: ex....cuse me?
13:01:59 <copumpkin> oh, I just realized
13:02:05 <copumpkin> (***) === bimap ?
13:02:12 <Deewiant> Yep
13:02:15 <copumpkin> except that *** is on any arrow
13:02:25 <Deewiant> And only on (,)
13:02:27 <seydar> adios children
13:02:30 <idnar> :t (***)
13:02:31 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:02:36 <seydar> look both ways before crossing the street!
13:02:37 <jmcarthur_work> (+++) is also a bimap
13:02:43 <PeakerWork> idnar: Functor: [fmap]  Applicative: [pure, <*>]  Monad: [pure, fmap, join], [pure, (>>=)]      <-- the alternate ways to define these. Note that if it defines an Applicative/Monad, it obviously defines a Functor too
13:02:45 <idnar> :t (+++)
13:02:47 <edwardk> lilac: came  up with it after watching "Something About Mary" ... er.. wait, ew.
13:02:47 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
13:02:53 <idnar> PeakerWork: yeah
13:03:14 <PeakerWork> idnar: I guess an interesting way to define Applicative could be liftA2, too
13:04:11 <idnar> PeakerWork: I find liftAn easier to understand than f <$> a <*> b <*> c <*> ...
13:04:14 <edwardk> yeah i hope patterson's libraries@ proposal to move the various methods defined off of Applicative into Applicative goes through
13:04:24 <lilac> PeakerWork: how do you define pure then?
13:04:39 <lilac> PeakerWork: "liftA2 (const (const x)) undefined undefined" doesn't seem to work
13:05:07 <edwardk> explicit support for liftA2, (*>) (<*) (<$), etc makes code like some of my parsers way more efficient
13:05:25 <PeakerWork> lilac: Yeah, I meant pure, liftA2  rather than  pure, <*>,  not instead of the whole thing.  Given that liftA2 "looks" at the effect around the value, undefined can't work there
13:05:38 <lilac> PeakerWork: I guess "pureUndefined :: Applicative f => f a" plus liftA2 is enough
13:06:10 <PeakerWork> lilac: I'd love to have   unit = pure ()       and that could be ok too :)
13:06:33 <lilac> in fact, pureUndefined + fmap + <*> might be a basis in the way idnar was wanting
13:06:52 <PeakerWork> lilac: why not pure ()  rather than pure undefined?
13:07:31 <idnar> pure x = fmap (const x) pureUndefined ?
13:07:36 <lilac> PeakerWork: it seems cleaner to me to have a 'pure structure' than a 'trivial structure'
13:07:41 <edwardk> well, unit = pure (), pair :: f a -> f b -> f (a,b) and fmap give a nice lax monoidal functor definition, and strength comes for free
13:08:23 <edwardk> but they are hideous to use
13:08:40 <PeakerWork> lilac: I dislike the potential for exposing a pure exception, though
13:08:59 <lilac> PeakerWork: right. it'd be nice if the typesystem could check. how about f Void?
13:09:37 <PeakerWork> lilac: I guess that guarantees you won't use the value
13:10:14 <edwardk> lilac: i'm somewhat in favor of the spirit of the argument that one shouldn't hand around a Void unless it can never even try to instantiate it -- so in that sense f () seems mildly safer, even if the type is too large
13:11:48 <edwardk> now, if you wanted to give two definitions one for Unit and one for Void that looked the same and played the role of 1 and 0 respectively, I'd be all for it. ;)
13:11:57 <lilac> edwardk: hmm, i guess you're only one 'fmap void' away from catastrophic failure
13:12:14 <edwardk> yeah
13:12:43 <Cale> > map (4*) . scanl (+) 0 $ [(-1)**n / (2*n+1) | n <- [0..]]
13:12:46 <lambdabot>   [0.0,4.0,2.666666666666667,3.466666666666667,2.8952380952380956,3.339682539...
13:12:52 <edwardk> so making Unit that holds a single indistinguishable bottom separate from Void is, to me at least, a good idea.
13:13:14 <edwardk> and will serve you in good stead should your language ever become total ;)
13:13:46 <lilac> i guess i don't like that there are two law-abiding implementations of 'unit' for any Applicative (pure () and pure undefined)
13:14:19 <lilac> unless you have a law that: seq <$> unit <*> x == x
13:14:21 <yitz> > drop 100 . map (4*) . scanl (+) 0 $ [(-1)**n / (2*n+1) | n <- [0..]]
13:14:23 <lambdabot>   [3.1315929035585537,3.1514934010709914,3.1317889675734545,3.151301162695405...
13:14:25 <lilac> but that seems overly cumbersome
13:15:29 <Cale> That series has terrible convergence compared to many others
13:15:32 <edwardk> lilac: hence why iw as advocating for the separate 1 type =)
13:15:55 <lilac> edwardk: would this 1 be an unlifted type?
13:16:11 <lilac> if so, i see what you mean and i'm completely on board :)
13:16:46 <pikhq> > drop 1000 . map (4*) . scanl (+) 0 $ [(-1)**n / (2*n+1) | n <- [0..]]
13:16:47 <lambdabot>   [3.140592653839794,3.1425916543395442,3.140594649846284,3.1425896623151117,...
13:16:57 <edwardk> lilac: no, just data Unit -- unit :: Unit; unit = undefined
13:17:03 <pikhq> "Terrible convergence" is not an exaggeration.
13:17:17 <edwardk> lilac: but without 'void :: Void -> a'
13:17:27 <lilac> edwardk: right, ok, you have my support on that too :)
13:17:48 <lilac> edwardk: newtype Unit = Unit Unit; unit = undefined -- = fix Unit ?
13:17:58 <edwardk> Unit is the identity for (,) as it adds no information. Void is the identity for Either, as it (should not) ever be inhabited.
13:18:01 <yitz> > repeat pi
13:18:03 <lambdabot>   [3.141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,3....
13:18:16 <lilac> Unit is surely only the identity for (# , #) ?
13:18:37 <edwardk> lilac: correct, the (,) is a pleasant fiction
13:18:43 <edwardk> since its a lifted product
13:19:20 <edwardk> but there is no unlifted sum type
13:19:40 <edwardk> so we are stuck talking about at least the sum case in lifted form
13:19:46 <lilac> i'm imagining one anyway, if that helps :)
13:21:25 <edwardk> in a total language you can have Void as a unit for Either, because then Either Void a can be isomorphic to a. the Left branch can never be inhabited
13:21:33 <lilac> *nod*
13:21:35 <edwardk> (for an unlifted Either)
13:24:13 <yitz> edwardk: what about Left !a | Right !a
13:24:40 <yitz> it
13:24:49 <yitz> 's not unlifted, but could it do here?
13:26:44 <edwardk> yitz: its been a while but as i recall that still breaks because you still have a possible bottom for the Either itself
13:27:05 <yitz> hmm
13:28:54 <lilac> edwardk: that sounds like Either Void a would be 1 + a
13:29:00 <lilac> s/edwardk/yitz/
13:29:29 <edwardk> an idealized 0 + a = a
13:29:45 * yitz nods
13:31:02 <lilac> this is all making me want to go play with epigram again
13:31:58 <lilac> how do total languages deal with functions as arguments to functions (how do they prove totality in such cases)?
13:33:46 <lilac> suppose i have f g x = g (x+1), g f h = f h; h f = g f f. f, g and h all look total, but h 1 diverges.
13:33:55 <edwardk> lilac: functions as arguments is generally fine, you typically need to worry about some kind of strict positivity condition on inductive families though.
13:35:45 <edwardk> lilac: you typically have to have some sort of notion of well-foundedness of productivity for recursion or corecursion.
13:35:53 <edwardk> er well-foundedness or productivity
13:36:17 <lilac> edwardk: what is considered to be 'recursion' in this sense?
13:36:34 <edwardk> i.e. each recursion must consume at least one constructor (for data) or produce at least one constructor on the outermost layer of the output for corecursion
13:37:12 <lilac> edwardk: right. however, in my example above, an analysis of each function by itself would tend to indicate that it is not (obviously) recursive
13:37:35 <lilac> do you need whole-program analysis, or is there some local method which can be used here?
13:37:59 * lilac is imagining tagging the parameter to 'f' with a 'cannot call f' qualifier of some sort
13:38:13 <Saizan> lilac: you've mutual recursion between g and h
13:38:21 <Saizan> lilac: you need fix to desugar that
13:38:55 <lilac> Saizan: really? g = id
13:39:04 <monochrom> No weekly news again! :)
13:39:09 <michaelfeathers_> Hm... anyone know how to read keystroke combinations through Haskell's IO system?
13:39:13 <Saizan> gah, the names confused me
13:39:26 <copumpkin> lol
13:39:27 <lilac> yeah, sorry about that :-/
13:40:11 <benmachine> michaelfeathers_: you mean like, meta-4?
13:40:23 <Saizan> lilac: uhm that gives an infinite type
13:40:27 <Saizan> lilac: no?
13:40:31 <Deewiant> h = join id
13:40:45 <Deewiant> f is completely unused there
13:40:46 <edwardk> lilac: what are the types involved though? =)
13:40:53 <copumpkin> :t join id
13:40:55 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
13:40:55 <lambdabot>     Probable cause: `id' is applied to too few arguments
13:40:55 <lambdabot>     In the first argument of `join', namely `id'
13:41:11 <edwardk> yes but g calls f with itself as an argument
13:41:34 <Saizan> ?type  let f g x = g (x+1); g f h = f h; h f = g f f in (f,g,h)
13:41:36 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:41:36 <lambdabot>     Probable cause: `f' is applied to too few arguments
13:41:36 <lambdabot>     In the second argument of `g', namely `f'
13:41:40 <edwardk> so when you go to typecheck this thing it blows up in your face
13:41:47 <Deewiant> g f h = f h -> g = id
13:41:54 <Deewiant> So h f = f f
13:42:02 <Saizan> yup
13:42:03 <lilac> are you saying that this will always be caught by an occurs check?
13:42:26 <edwardk> lilac: yes, and anything else would have needed a mutual recursion / fix
13:42:47 <copumpkin> > let f g x = g (x+1), g f h = f h; h f = g f f in h 1
13:42:49 <lambdabot>   <no location info>: parse error on input `,'
13:42:52 <edwardk> fix is 'fixed' by using a predicate about recursion or corecursion which checks well-foundedness or productivity
13:42:56 <copumpkin> > let f g x = g (x+1); g f h = f h; h f = g f f in h 1
13:42:57 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:43:01 <Saizan> that's the reason you can't define fix using System F
13:43:39 <michaelfeathers_> benmachine: yes.  I'd be happy just to trap escape to start with.
13:43:42 <copumpkin> http://en.wikipedia.org/wiki/Ferry_Corsten
13:44:18 <lilac> data G = G (G -> a -> b); f :: G -> a -> b; f (G g) a = g a; g (G f) h = f h; h = g (G f) (G f)
13:44:26 <benmachine> michaelfeathers_: hmm
13:44:35 <benmachine> trap escape?
13:44:36 <Saizan> lilac: that's not a strictly positive type :)
13:44:47 <edwardk> lilac: that is why the positivity condition exists ;)
13:44:49 <michaelfeathers_> benmachine: the escape key.
13:44:55 <lilac> aha, they catch you whichever way you squirm :)
13:44:55 <edwardk> G occurs in negative position in your data type
13:44:59 <edwardk> =)
13:45:05 <lilac> that makes total sense :)
13:45:07 <benmachine> michaelfeathers_: what do you mean by trap it though?
13:45:22 <benmachine> if I do getChar in ghci and press escape, I get '\ESC'
13:45:27 <michaelfeathers_> benmachine: I'd just like to read it.
13:45:40 <yitz> michaelfeathers_: for a console app you could just use getChar
13:45:41 <lilac> of course, given data G = G (G -> a) we can just say 'f g@(G h) = h g'
13:45:43 <benmachine> is that not what you want?
13:46:16 <edwardk> lilac: yep
13:46:18 <lilac> edwardk: i assume some smart people have proven that all this works out. my concerns are assuaged now at least :)
13:46:18 <michaelfeathers_> benmachine: I haven't done much looking.. apologies.
13:46:26 <edwardk> lilac: =)
13:46:39 <edwardk> lilac: there is a nice book on coq called coq'art which goes into a lot of this stuff
13:46:54 <edwardk> http://www.labri.fr/perso/casteran/CoqArt/index.html
13:47:21 <yitz> michaelfeathers_: if you need full access to keyboard events, it has to be within some ui framework, ncurses, gtk, etc.
13:47:46 <michaelfeathers_> yitz: thanks
13:47:47 <lilac> edwardk: thanks! this has been most enlightening :)
13:48:08 <lilac> Saizan: thank you too :)
13:49:24 <mjw1gglml> testing
13:49:30 <Saizan> lilac: np :)
13:49:38 <edwardk> lilac: another source i found useful was Zhaohui Luo's Computation and Reasoning, which builds up an extended calculus of constructions and talks about its properties in depth
13:49:44 <HugoDaniel> hi
13:50:00 <HugoDaniel> i was wondering today, why is haskell named after haskell ?
13:50:06 <edwardk> i found it enlightening because it actively discussed a lot of trade-offs
13:50:45 <edwardk> HugoDaniel: Haskell Brooks Curry came up with one of the modern formulations of the lambda calculus (the one without all the superfluous arguments) and a ton of little things that make functional programming possible
13:50:46 <Saizan> mh, i wonder if it's feasible to allow equi-recursive types only when they are positive
13:51:25 <edwardk> Saizan: you should be able to, equi vs. iso usually just becomes complicated as you enrich the calculus.
13:51:26 <HugoDaniel> yes, but isn't it a bit lame ?
13:51:27 <idnar> uhm, is there a common abbreviation for "happstack"?
13:51:47 <idnar> my fingers keep tripping over the full spelling
13:51:47 <HugoDaniel> idnar: happs
13:51:54 <edwardk> HugoDaniel: how so? there was a nice paper on the history of Haskell by SPJ and others that talked about the birth of the name
13:52:09 <HugoDaniel> ah
13:52:11 <edwardk> i used it as a nice crib sheet to steal alternative functional programming language names from for a while =)
13:52:35 <copumpkin> why lame?
13:53:00 <edwardk> HugoDaniel: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm
13:53:05 <HugoDaniel> thanks
13:53:43 <yitz> HugoDaniel: "haskell" means "enlightenment" in Hebrew. Does that help?
13:53:44 <edwardk> bottom right of page 4 covers the naming
13:54:07 <copumpkin> yitz: really??
13:54:13 <yitz> yep
13:54:23 <copumpkin> that's cool
13:54:29 <HugoDaniel> yeh :)
13:54:34 <HugoDaniel> now thats something
13:54:50 <HugoDaniel> i bet it shows up in the bible quite often
13:54:54 <Saizan> but it seems that Haskell himself always hated his name :)
13:55:02 <edwardk> yeah
13:55:07 <benmachine> well now the name need not feel unloved
13:55:10 <copumpkin> yitz: can you write it for us?
13:55:17 <yitz> Saizan: he didn't know Hebrew, apparently
13:55:28 <yitz> השכל
13:57:07 <mjw1gglml> good day gentlemen :-)
13:57:40 <yitz> HugoDaniel: that particular word occurs 3 times. There are lots of other words with various shades of meaning in that semantic category. :)
13:58:03 <yitz> oops 4 times
13:58:20 <copumpkin> thanks!
13:58:42 <yitz> it also occurs once as an inflected verb
13:58:56 <yitz> so five, sort of
13:59:19 <HugoDaniel> yitz: can you point out where ?
14:00:48 <yitz> Daniel 1:17, Prov 1:3 21:16, Jer. 9:23. As a verb in Ps. 119:29
14:01:27 <yitz> Can't vouch for exactly how it's translated in various translations, though.
14:04:23 <idnar> uhm
14:04:34 <idnar> the <title> element on, for example, http://tutorial.happstack.com/src/FirstMacid.hs, contains the entire file
14:04:38 <idnar> that seems like a bad idea
14:06:14 <Saizan> idnar: odd
14:19:22 <idnar> also, http://tutorial.happstack.com/projectroot/src/migrationexample/README describes something completely different to the actual code in the examples
14:19:55 <burp> you need help writing migrations?
14:19:56 <idnar> should I be in #happs or something?
14:20:00 <Milo-> http://codepad.org/0JX7mAw8 what in the line four makes it the wrong type? :/
14:20:18 <idnar> burp: I'm just skimming the docs, really, trying to get a feel for HAppStack
14:20:23 <burp> no, I just want to point to http://nhlab.blogspot.com/2008/12/data-migration-with-happs-data.html and http://www.kuliniewicz.org/blog/archives/2009/04/18/data-migration-in-happstackstate/
14:20:29 <burp> which helped me do it ;)
14:20:44 <burp> especially the first one
14:20:52 <idnar> I still get the general idea, it's just not great to have examples / docs that lie :P
14:21:01 <idnar> I'll check those links out, thanks
14:21:04 <yitz> Milo-: quick needs a function as its first arg
14:21:21 <Milo-> it gets that
14:21:37 <Milo-> ohhhhhh
14:21:38 <yitz> Milo-: quick [..
14:21:38 <Milo-> yeh :P
14:21:43 <Milo-> yup yup :)
14:21:49 <Milo-> got it :P
14:23:03 <Milo-> thanks:)
14:23:24 <Milo-> error message kept forwarding me to completely different place at all times
14:24:33 <yitz> Milo-: that error messages seems pretty clear to me.
14:25:04 <yitz> Milo-: that's the strength of hugs. with ghc, it takes a bit longer to get used to reading the error msgs.
14:25:22 <yitz> s/s//
14:26:10 <Milo-> I've been reading haskell for 2 days now, still can't figure out all the error messages I keep getting :P
14:26:51 <Milo-> and coming from C and Java -worlds, it's a little bit different
14:27:09 <Milo-> but now I have courage to carry on, thanks again :)
14:27:20 <yitz> Milo-: yeah don't worry, you'll get used to it. the concepts are different.
14:27:25 <kpreid> Milo-: in that error message the "Term" has the type "Type", but the context inferred from elsewhere requires it to have the "Does not match" type
14:27:31 <hackagebot> yst 0.2.2 - Builds a static website from templates and data in YAML or (JohnMacFarlane)
14:27:52 <kpreid> Milo-: [ u | u<-xs, not (comp u x) ] has type (at least) [b], since a list comprehension always produces a list.
14:27:56 <Milo-> yitz which is why I decided to study a little bit haskell :)=
14:28:02 <yitz> kpreid: I think your comment gets "cannot construct infinite type..."
14:29:31 <kpreid> Milo-: Type errors in Haskell are almost always like this: the expression has some type, and the context it is in has some type, and they do not fit (are not unifiable)
14:29:59 <kpreid> The occasionally tricky bit is that since not everything is explicitly typed with a signature in your program, *type inference* fills in the gaps, but it's not determined *where in the gap* the error occurs
14:30:00 <Milo-> now that I know where the error was (and fixed it), the error message seems way clearer to me than it did before
14:30:30 <yitz> heh, hindsight is 20-20
14:31:09 <yitz> but now you'll get a better idea of what to look for next time.
14:31:37 <Milo-> the error messages aren't supposed to be clear! (for example, look at the carbage what C++ gives you when you make an error!)
14:32:26 <pikhq> God, C++ errors.
14:32:39 <pikhq> I'm not entirely sure they even have a *correlation* with what's wrong.
14:32:45 <yitz> Milo-: well, they *are* supposed to be clear. but that's easier said than done. and it depends on your definition of "clear.
14:33:13 <yitz> pikhq: they're not all that bad, as long as you stay away from templates
14:33:23 <yitz> hence STL
14:33:26 <Milo-> I come from world of ambiguous error messages, hard to understand something that is written in crystal clear english
14:33:27 <pikhq> yitz: Which is to say, you ignore the STL.
14:33:39 <pikhq> The STL can give really weird error messages. ;)
14:33:52 <yitz> pikhq: you don't ignore the STL. just the error messages it generates. :)
14:33:54 <pikhq> Boost, too, for that matter.
14:34:03 <pikhq> Touché.
14:34:37 <vorner> just have to know which parts of the error messages to skip and ignore, the rest is OK ;-)
14:35:12 <yitz> vorner: you can boil down four screenfuls to just: "oops"
14:35:39 <vorner> true, I need 2 monitors when I code C++, one for code, other for errors ;-)
14:51:15 <gav> so if I want to manipulate files and directories, can ghc get the job done? or is it just better to use ksh or bash?
14:51:31 <soupdragon> zsh
14:51:39 <yitz> gav: System.Directory
14:51:39 <soupdragon> why would anyone use ksh :p
14:51:54 <gav> cuz its the best shell, or so says at nt
14:52:05 <soupdragon> nah it's not the best
14:52:09 <soupdragon> maybe they just know it bet
14:52:12 <gav> I am thinking of learning tcl as my shell
14:52:13 <soupdragon> best*
14:52:23 <gav> tcl seems cool
14:52:28 <soupdragon> yeah dunno
14:52:39 <soupdragon> you can do crazy stuff with tclu
14:52:48 <gav> wazat
14:52:54 <skorpan> you should move this discussion to #haskell-in-depth
14:52:57 <soupdragon> like implement lambda
14:53:11 <gav> if haskell could replace bash
14:53:16 <gav> it would become ubiquitous
14:53:19 <copumpkin> hash
14:53:20 <copumpkin> !!
14:53:29 <skorpan> haskell can replace bash just as much as python
14:53:33 <skorpan> or any other language
14:53:44 <gav> without major pain?
14:53:47 <soupdragon> skorpan: go to #haskell-in-depth
14:53:48 <gav> with style?
14:53:52 <Vanadium> yeah, after you embed bash or python whatever as a DSL
14:53:55 <skorpan> gav: what are you looking for?
14:54:16 <MattJW> evening from England
14:54:25 <skorpan> haskell isn't exactly well-known for its bash-replacement abilities
14:55:21 <MattJW> Any FP theorists among you?
14:55:27 <soupdragon> hi Matt
14:55:38 <pikhq> Seems to me that the only language well-known for that is Perl. And we all know how awful that is.
14:55:40 <MattJW> greetings
14:55:53 <gav> well I am trying to do some shell stuff, and am considering learning tcl to take care of all this stuff because ksh is kinda pissing me off
14:56:05 <soupdragon> gav use zsh instead of ksh man
14:56:08 <gav> perl I heard is yukki
14:56:09 <skorpan> bash is pretty much only IO and haskell is not the first language that comes to mind when i hear IO
14:56:14 <opqdonut> why on earth are you using ksh
14:56:14 <gav> zsh ok why
14:56:19 <opqdonut> use bash or posix sh
14:56:23 <soupdragon> because it is better :p
14:56:27 <opqdonut> zsh has cool features tho
14:56:36 <gav> nah
14:56:39 <gav> Im guna do tcl
14:56:41 <skorpan> i hear "fish" has nice scripting
14:56:41 <gav> late all
14:56:44 <MattJW> I'm wondering if I should pose my quesiton
14:56:45 <opqdonut> but for portability, one of the two i mentioned earlier
14:56:57 <benmachine> MattJW: pose it, and then wonder if you should have posed it
14:57:00 <skorpan> fish isn't bourne-compatible though
14:57:01 <soupdragon> Matt, what is it?
14:57:23 <MattJW> Well, simply put, what are the properties of a closure?
14:57:28 <MattJW> the semantics, if you like
14:57:41 <Nafai> fish looked interesting, but I'm so used to bash
14:57:41 <soupdragon> do you define closure? or asking what it is?
14:58:02 <byorgey> MattJW: a closure is some code, together with the environment (i.e. bindings of names to values) in which it was defined.
14:58:16 <skorpan> var x = 3; var y = function () { return x; }
14:58:22 <skorpan> y() will always return "3"
14:58:38 <skorpan> (at least that's what i think closure means)
14:58:54 <copumpkin> I wonder why clojure just decided to rename mutable to transient and immutable to persistent
14:58:56 <byorgey> and in that code, 'y' is a closure with a function definition along with the environment { x = 3 }
14:59:17 <skorpan> copumpkin: sounds like better names to me
14:59:25 <skorpan> copumpkin: for years i thought "mutable" meant "mute-able"
14:59:31 <copumpkin> skorpan: lol
14:59:33 <bhan> what's the equivalent of Control.Concurrent.threadDelay for HUGS?
15:01:02 <Cale> bhan: is it not the very same thing?
15:01:13 <bhan> no it doesn't work
15:01:49 <MattJW> but what's special about it?
15:01:55 <bhan> GHC only
15:02:29 <bhan> Control.Concurrent> :t threadDelay \ Error: Undefined variable threadDelay
15:02:42 <pikhq> bhan: Stop using Hugs? :P
15:03:08 <bhan> isn't there an equivalent?
15:06:37 <Twey> bhan: No
15:07:09 <Cale> Yeah, I don't see anything, myself. Perhaps there's something in the posix library...
15:08:12 <Cale> Hugs also has essentially no operations on threads. Its ThreadId is a synonym for ()
15:09:54 <bhan> um do i have to switch to GHC then?
15:10:05 <pikhq> It is highly recommended.
15:11:19 <Cale> Basically, if you want to do anything of even a moderate amount of seriousness.
15:11:28 <Twey> bhan: As I understand it, Hugs is mostly used for teaching.  GHC is where the serious stuff happens.
15:11:29 <yitz> Cale: can you get rid of the "/cgi-bin/hackage-script" in the output of @hackage?
15:11:30 <pikhq> Note that Hugs is no longer maintained, and its author recommends switching to GHC.
15:11:37 <yitz> @hackage whateer
15:11:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/whateer
15:11:49 <Vulpyne> If you realllly wanted to, you could probably implement a threaddelay by calling yield until enough time had passed.
15:12:11 <bhan> why is hugs used for teaching?
15:12:20 <copumpkin> bhan: not at my school it isn't
15:12:47 <badsheepy> its error messages arent incomprehensible which is nice :o
15:12:47 <pikhq> Wait, you mean universities actually teach Haskell?
15:12:55 <opqdonut> ours does
15:12:58 <copumpkin> mine does
15:13:03 <nvoorhies> a buch do now
15:13:05 <pikhq> I'm learning for the sake of learning, while being forced to deal with C++ at my university.
15:13:06 <nvoorhies> bunch
15:13:06 <copumpkin> I didn't actually take it, but it does teach it
15:13:09 <skorpan> <- chalmers bitches
15:13:12 <opqdonut> (one course, and we had to organiser it ourselves this year)
15:13:19 <opqdonut> -r
15:13:24 <pikhq> (damned US schools; you have a choice between C++ and Java, with a few switching to Python)
15:13:27 <copumpkin> over here it's the second prerequisitve for the CS major
15:13:37 <copumpkin> -v
15:13:41 <opqdonut> sweet
15:13:45 <skorpan> at chalmers haskell is the first course of the computer science program
15:14:08 <skorpan> then there is "advanced functional programming" and a few years back there was "advanced advanced functional programming" which was basically category theory
15:14:19 <msteele_> bhan: I hear that Hugs has more friendly compiler error messages."
15:14:21 <yitz> it's common now for the prog. langs. course to include a unit a haskell.
15:14:38 <pikhq> skorpan: What country are you in, and why does yours actually teach computer science?
15:14:55 <skorpan> pikhq: http://www.cs.chalmers.se/~koen/Aafp/
15:14:59 <skorpan> pikhq: sweden, gothenburg, chalmers
15:15:11 <pikhq> Europe has all the nice things. :(
15:15:16 <copumpkin> I'm in the US
15:15:19 <skorpan> because we have lots and lots of haskell/fp people here, john hughes and koen claessen-lindström among others
15:15:23 <Philonous> We have some good CS classes here. That is, if you're studying math.
15:15:25 <skorpan> i don't know *why* though
15:15:38 <copumpkin> the haskell course replaced our SICP-based scheme course
15:15:51 <pikhq> Philonous: I'm dual-majoring in CS and math largely for that reason...
15:16:44 <bhan> can i implement delay by consuming CPU cycles?
15:18:06 <yitz> bhan: one usually uses threadDelay
15:18:07 <opqdonut> :t threadDelay
15:18:09 <lambdabot> Not in scope: `threadDelay'
15:18:13 <pikhq> bhan: Switch to GHC. ;)
15:18:15 <opqdonut> gah
15:18:24 <bhan> gah
15:18:45 <copumpkin> bhan: it's pretty easy to get started with GHC
15:18:52 <copumpkin> it's faster and gives you nicer error messages too
15:18:54 <Philonous> bhan: Why do you want to stick to hugs anyway, when it clearly doesn't support the operations you require?
15:19:28 <yitz> @hoogle threadDelay
15:19:28 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
15:19:38 <bhan> because it's been good for weeks and i just want to accomplish something
15:20:07 <pikhq> Use. GHC. Hugs is no longer supported.
15:20:15 <bhan> ok
15:21:33 <MyCatVerbs> pikhq: It hasn't had a release since 2006, sure, but it still *works* just fine.
15:21:55 <pikhq> MyCatVerbs: Except when you want to do something it doesn't support.
15:21:57 <pikhq> Like threading.
15:21:59 <pikhq> ;)
15:22:41 <MyCatVerbs> It does threading just fine! Just... cooperatively.
15:23:04 <MyCatVerbs> I think? Hang on, where's my Control.Concurrent?
15:23:22 <yitz> MyCatVerbs: does it have threadDelay?
15:24:28 <MyCatVerbs> I believe it does, but then I also believed that it had forkIO. ;P
15:26:05 <MyCatVerbs> I'm reasonably certain that the papers on Concurrent Haskell say that it was originally implemented in Hugs as well as in GHC. I just can't find it in my Hugs install. >>
15:27:38 <erisco> how would I define a string type that cannot exceed a max length?
15:28:19 <erisco> I am imagining that I would create a module and implement the restriction using functions that work with the data type?
15:28:25 <copumpkin> erisco: yeah
15:28:31 <copumpkin> you could do it in the type system but it'd be a real pain
15:28:35 <MyCatVerbs> erisco: You'd need a phantom type parameter that gives the length of the string.
15:29:16 <MyCatVerbs> There's at least one library on Hackage for type-level numerals.
15:29:39 <pikhq> It's probably be easiest to newtype string and only expose functions that work with the data type within the max length...
15:29:58 <pikhq> Fancier ways of doing it, like ^ type-level numerals, but.
15:30:38 <badsheepy> there seems tobea lot of people who want type-checkable ranges of numbers
15:30:41 <MyCatVerbs> yitz: No, it doesn't. Oh, bother.
15:30:47 <badsheepy> but it seems rather awkward to actually do
15:34:00 <erisco> hm, perhaps I will just take a difference approach for now then other than trying to integrate it with the type system
15:34:45 * erisco is still new to Haskell, keep in mind :)
15:35:04 <erisco> what I was trying to do is play around with ideas listed here: http://www.defmacro.org/ramblings/haskell-web.html
15:35:33 <erisco> an underlying rdbms, such as MySQL, will have restrictions on the amount of data you can stuff into a varchar, and so on
15:36:19 <erisco> so this restriction needs to somehow be represented and it somewhat seemed natural to try and emulate the varchar(30), for example, notation that sql would use
15:37:53 <erisco> http://pastebin.ca/1517270
15:38:15 <erisco> so, that essentially represents what I was envisioning, but that does not seem to make any sense in terms of Haskell
15:38:34 <erisco> LString being a "limited string"
15:40:50 <erisco> is there any way to define LString so that it would make sense?
15:40:50 <erisco> http://pastebin.ca/1517271
15:41:29 <Philonous> erisco: You can have something similar for a fixed lengths
15:42:04 <erikc> erisco: you'd have to model the constant integer as a type (e.g. peano numbers modeled as types)
15:42:30 <erikc> it sorta gets ugly :)
15:43:09 <erisco> I am not familiar with the limitations of parametrized types, I am guessing
15:43:29 <erikc> you can only use types as arguments to parameterized types (type functions)
15:44:07 <copumpkin> it's pretty awesome actually
15:44:13 <copumpkin> but yeah, rather ugly at the same time
15:44:32 <erisco> so, again, my best implementation would be to abstract the usage of the User data type in a separate module
15:45:46 <erisco> would that be true?
15:46:58 <erikc> hmm, i dunno, i'm off the ORM train of insanity
15:47:28 <erikc> i'd build a relational algebra library in haskell and then works in sets
15:47:31 <erisco> heh, well, I will try it without bringing the type system into things and see how it looks
15:47:49 <bhan> how do you divide two Ints?
15:48:00 <soupdragon> div
15:48:15 <bhan> Int, not Integral
15:48:56 <Petrosian_> > (1 :: Int) `div` (2 :: Int)
15:48:57 <lambdabot>   0
15:49:00 <yitz> bhan: Int is an instance of Integral, so it has div
15:50:24 <bhan> > :t (/)
15:50:25 <lambdabot>   <no location info>: parse error on input `:'
15:51:07 <yitz> :t (/)
15:51:08 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:51:42 <bhan> :t div
15:51:43 <lambdabot> forall a. (Integral a) => a -> a -> a
15:51:59 <bhan> i thought div and / were the same
15:52:03 <djahandarie> What's the fastest way to see if a Num is an Int?
15:52:25 <Petrosian_> div is integer division, / is real number division
15:52:26 <msteele__> :t fromIntegral
15:52:28 <lambdabot> forall a b. (Integral a, Num b) => a -> b
15:52:37 <djahandarie> Err, that is, so it goes to a Bool
15:52:58 <Petrosian_> > 5 `div` 2
15:52:59 <lambdabot>   2
15:53:01 <Petrosian_> > 5 / 2
15:53:03 <lambdabot>   2.5
15:53:12 <djahandarie> Just compare the two?
15:53:17 <djahandarie> Isn't there a faster way?
15:53:46 <bhan> can you convert Int to Real?
15:53:58 <copumpkin> > fromIntegral 5 :: CReal
15:54:00 <lambdabot>   5.0
15:54:03 <copumpkin> of course that isn't necessary
15:54:08 <copumpkin> cause 5 is already polymorphic
15:54:14 <copumpkin> > fromIntegral (5 :: Int) :: CReal
15:54:15 <lambdabot>   5.0
15:55:07 <yitz> djahandarie: you don't need to check that - the compiler will catch it at compile time if you make a mistake
15:55:25 <djahandarie> yitz, it's not for error checking, it's for list comprehension
15:57:02 <djahandarie> i.e., [a | a <- [1,100], a/12 :: Int]
15:57:05 <djahandarie> Something like that
15:57:06 <djahandarie> haha
15:57:11 <djahandarie> Obivously that doesn't work
15:57:44 <yitz> > [a | a <- [1..100], a `mod` 12 == 0]
15:57:45 <lambdabot>   [12,24,36,48,60,72,84,96]
15:58:00 <djahandarie> What about more complicated things..?
15:58:16 <jfoutz> are you interested in the bits? would word32 be better?
15:58:28 <Infamous_Cow> I found a broken link in the haskell docs. The link `System.IO' doesn't point to the right page, I get a 404.  Fix this page: http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html#9
15:58:44 <yitz> djahandarie: more complicated things are fine too - but if it's an Int, it's always an Int, verifiable at compile time
15:59:50 <jfoutz> Infamous_Cow: it came up for me. maybe you got cought in the middle of a refresh.
16:00:22 <yitz> > [a | a <- [1..100], let b = a / 12, fromIntegral (floor b) == b] -- but this is silly
16:00:24 <lambdabot>   [12.0,24.0,36.0,48.0,60.0,72.0,84.0,96.0]
16:00:36 <Nereid_> hmm
16:00:40 <Nereid_> :t (,,,,,,,,,,,,,,,)
16:00:41 <lambdabot> forall a b c d e f g h i j k l m n o p. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
16:00:44 <Nereid_> lol
16:02:58 <Vulpyne> :t let x = (,,,) in x.x.x.x.x
16:03:00 <lambdabot> forall b c d b1 c1 d1 b2 c2 d2 b3 c3 d3 a b4 c4 d4. a -> b -> c -> d -> (b1 -> c1 -> d1 -> (b2 -> c2 -> d2 -> (b3 -> c3 -> d3 -> (b4 -> c4 -> d4 -> (a, b4, c4, d4), b3, c3, d3), b2, c2, d2), b1, c1,
16:03:00 <lambdabot> d1), b, c, d)
16:03:22 <Vulpyne> That could get scary, fast.
16:12:49 <deech> Funny story : Just now I had an issue I needed help with and posted the bad code on hpaste. I kept plugging away and posting my progress. I eventually fixed it and then realized I was disconnected from IRC.
16:17:17 <mmorrow> <whoknows> mmorrow, playing around with GADTs?
16:18:49 <mmorrow> whoknows: yeah, as in trying to design a strategy for deriving instances for them that's applicable to a useful subset of GADTs and that works (fsvo works) for that (those) classes of GADTs (in this context)
16:19:42 <mmorrow> whoknows: so then to derive the instances you transform/walk/generate code and manipulate types
16:21:59 <mmorrow> whoknows: like e.g. the strategy that pkg uses for Read is (1) discard all constructors with existential typevars, (2) group the remaining constructors into bins where the cons in each (possibly overlapping) bin all mutually unify, (3) derive an instance of Read *for each* bin
16:26:35 <Veinor> o/
16:26:46 <Saizan> hi
16:32:43 <Veinor> sure is active
16:34:55 <shapr> Veinor: shh, we're sleeping.
16:34:59 <shapr> Veinor: But really, what's up?
16:35:25 <Veinor> Not much
16:35:33 <Veinor> just learning Haskell via real world haskell
16:35:53 <shapr> Ah, good choice.
16:36:20 <deech> Can someone help me with continuations b
16:36:57 <martint> anyone familiar with xhb?  MkSendEvent asks for a [CChar] as its event argument, while i'm not sure if there's a specific way i'm supposed to turn a ClientMessageEvent into [CChar]
16:37:56 <Saizan> deech: don't ask if someone can help, just explain your problem :)
16:40:15 <deech> Great! I have some working code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7851#a7854 that I made to learn about continuations. Is there a way to save the continuation for later? Say in an IORef?
16:41:19 <Saizan> sure
16:41:25 <Saizan> just do it :)
16:41:33 <Saizan> ?type callCC
16:41:35 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
16:42:26 <Saizan> "k" is just a function like any other, so you can pass it around, store in a datastructure, etc..
16:42:48 <deech> I tried by creating a newIORef in test, but the recursive call captures all of test including newIORef.
16:44:11 <Saizan> yeah, if you want to create only one IORef you've to do it outside of test
16:44:21 <Saizan> and pass the IORef as an argument to it
16:45:09 <deech> let me try that!
16:49:55 <Philonous> @type liftCallCC
16:49:57 <lambdabot> Not in scope: `liftCallCC'
16:56:43 <Peaker> @type lift . callCC
16:56:45 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) b. (MonadTrans t, MonadCont m) => ((a -> m b) -> m a) -> t m a
17:10:09 <defun> hi. is anyone here familiar with the clean language? I hear that it is similar to haskell. What would be the pros/cons of clean vs haskell? I know that to expect an unbiased answer on this channel may be expecting too much, but I figure it's worth a shot :)
17:12:11 <shepheb> the most obvious difference is that Clean uses uniqueness types instead of monads to embed side effects in a pure language.
17:12:46 <mike-burns> defun: http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg05840.html
17:12:51 <mike-burns> defun: http://www-users.cs.york.ac.uk/~mfn/hacle/
17:12:56 <shepheb> which makes it less scary, perhaps, but misses out on all the other, far more interesting monads.
17:13:39 <karan> mike-burns: you know mike tomasello?
17:13:44 <mike-burns> Nope.
17:13:46 <karan> ok
17:16:35 <defun> thanks. seems like an insignificant haskell fork...
17:16:52 <copumpkin> I wouldn't say that
17:19:35 <jfoutz> uniqueness types seem clever.
17:20:05 <Saizan> shepheb: i think clean has typeclasses, so it can support arbitrary monads just as well, but maybe it lacks do-notation
17:20:21 <shepheb> true, I suppose.
17:20:28 <Peaker> Clean requires passing world manually everywhere doesn't it?
17:22:04 <Saizan> maybe you can have something like the State monad
17:22:24 <shepheb> then it starts sounding a lot like, er, ST RealWorld a
17:22:30 <Saizan> yeah
17:22:33 <Peaker> well, if you have a uniqueness type to pass the world, and then automate its passing in a monad, then you don't really need the uniqueness type?
17:23:23 <shepheb> Peaker: Haskell proves this, by not having such a uniqueness type at all
17:23:29 <shepheb> Monads are sufficient
17:24:31 <Saizan> well, in GHC IO is implemented almost in the same way, though it must be abstract, otherwise you'd be able to do weird things
17:25:02 <Saizan> and the optimizer needs some hacks to deal with this
17:39:19 <copumpkin> is there a general name for an algebraic structure with two operations (like field, ring, and so on?)
17:41:44 <_Philippa_> two magmas over the same carrier?...
17:42:22 <copumpkin> anything more succinct? :P
17:44:01 <ski> Beelsebob,WorkyBob : SYN
17:44:02 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
17:44:04 <Baughn> copumpkin: Is there any more structure to it than "two operations"?
17:44:13 <ski> @messages
17:44:13 <lambdabot> ppavelV6 said 1d 4h 28m 30s ago: thanks for the link
17:44:39 <copumpkin> Baughn: nope, was just looking for a general name for two operations over the same set, probably with some relationship between them (but an unspecified one)
17:44:47 <Baughn> copumpkin: ..also, I've always wondered. If you compose a copumpkin and a pumpkin, is the result nothingness?
17:45:06 * copumpkin is a category
17:45:19 <_Philippa_> copumpkin: it's probably a bimagma or a dimagma or something along those lines?
17:45:50 <Baughn> copumpkin: It can't be anything but a magam
17:45:52 <Baughn> *magma
17:46:14 <copumpkin> _Philippa_: that sounds about right, but the only references to that I can find are in french literature :o
17:46:25 <copumpkin> Baughn: ?
17:46:37 <_Philippa_> you'll probably have to define it as you use it, then
17:46:49 <copumpkin> ah well
17:46:52 <Baughn> copumpkin: Well, you're not imposing /any/ structure on the operations
17:46:53 <copumpkin> I'll live I guess
17:47:01 <copumpkin> Baughn: beyond being a magma
17:47:14 <Baughn> copumpkin: Right, but that's about nothing.
17:47:17 <copumpkin> yeah :)
17:47:32 <Baughn> copumpkin: In practice, you can consider them as two separate magmas
17:47:39 <ski> (beyond being a magma in two ways, surely ?)
17:47:46 <Baughn> Now, you know it's the same underlying set, so at least the cardinality of the sets is the same
17:47:55 <Baughn> ..but that could easily be infinite anyway
17:48:17 <Baughn> If you impose /no/ structure, the names of the set members becomes fairly uninteresting
17:48:38 <seydar> attention smart people: http://eurocrypt2009rump.cr.yp.to/e074d37e10ad1ad227200ea7ba36cf73.pdf
17:48:41 <seydar> this is what i was talking about earlier
17:48:49 <Baughn> copumpkin: I'd go for "two magmas over the same set". There's really no need for a specialized name.
17:48:59 * ski raises eyebrow ..
17:49:07 <Veinor> what's the best way to go out doing OOP stuff in haskell?
17:49:11 <copumpkin> Baughn: well I was trying to write some code for it, so was hoping for something more succinct, but I'll work around it
17:49:13 <Veinor> not doing it in the first place?
17:49:16 <copumpkin> Veinor: to avoid it altogether
17:49:16 <copumpkin> yeah
17:49:17 <Baughn> Veinor: Quite.
17:49:21 <ski> Veinor : define OO ?
17:49:30 <Baughn> copumpkin: Well, call it a dimagma. The name isn't taken.
17:49:47 <copumpkin> Baughn: sounds reasonable
17:49:49 <Baughn> copumpkin: Or if you want to be cute, call it a lava
17:49:49 <copumpkin> thanks :)
17:49:54 <copumpkin> Baughn: lool
17:50:45 <ski> (Veinor : maybe <http://community.schemewiki.org/?object-oriented-programming> could be of interest for that)
17:50:45 <Baughn> Veinor: Perhaps it would help if you explained what particular problem you are trying to solve, which you'd use OO for in another language.
17:50:53 <kscaldef> hey, is there a shorter / simpler / more elegant way to write [12] ++ [1..11]?
17:50:57 <Baughn> Veinor: Haskell does have some OO-ish abilities, but they're almost always the wrong thing.
17:51:03 <Baughn> kscaldef: 12 :: [1..11]
17:51:06 <ski> Baughn : why `dimagma' rather than `bimagma' ?
17:51:11 <Baughn> kscaldef: Er. 12 : [1..11]
17:51:22 <Peaker> Veinor: Haskell has the OO advantages, and more, with alternative approaches
17:51:31 <ski> > 12 : [1..11]
17:51:32 <lambdabot>   [12,1,2,3,4,5,6,7,8,9,10,11]
17:51:38 <kscaldef> yeah, just realized that is shorter... not clearly simpler or more elegant
17:52:05 <Baughn> ski: Language bias. Mine isn't derived from greek in any way, shape or form.
17:52:17 <Veinor> kscaldef: well, what other way would you do it? :/
17:52:19 <Baughn> ski: I hear "di" much more often than "bi".
17:52:19 <copumpkin> dammit, decision decisions
17:52:23 <copumpkin> dimagma or bigmagma
17:52:30 <copumpkin> we have dioids
17:52:31 <Veinor> Baughn: Just a general question.
17:52:33 <copumpkin> but bifunctors
17:52:45 <Veinor> how about bimagma instead of bigmagma? :P
17:52:48 <Baughn> Veinor: Unfortunately it doesn't have an answer, as such.
17:52:52 <copumpkin> lol
17:52:57 <copumpkin> yeah, that's what I meant :P
17:53:03 <copumpkin> damn muscle memory
17:53:08 <ski> Baughn : ok .. i associate `di' with `di'-functor and `di'-natural transformation .. which is related to something that is partly covariant and partly contravariant
17:53:08 <Veinor> also I swear I've seen your name before copumpkin
17:53:19 <copumpkin> Veinor: in what context?
17:53:22 <kscaldef> Veinor: dunno.... in other languages [12,1..11] does it, but Haskell has other ideas about that construction (which are probably more generally useful / cool)
17:53:23 <copumpkin> or ntext?
17:53:32 <Veinor> I don't know
17:53:40 <Veinor> OH
17:53:46 <Veinor> on twitter as one of the dev team guys :D
17:53:48 <copumpkin> lol
17:53:51 <copumpkin> yeah, that's me
17:53:54 <Baughn> Veinor: "How do I do OO" in haskell can only be answered by "Don't".
17:54:02 <Veinor> That was my guess too.
17:54:08 <Veinor> "How do I do functional programming in C?"
17:54:16 <Baughn> Veinor: "How do I do everything I might conceivably use OO for in other languages" would have to be answered by a complete core dump of all my haskell knowledge
17:54:29 <erikc`> copumpkin: how bout the yonoid
17:54:32 <erikc`> http://savvygeek.com/wp-content/uploads/2007/05/yo_noid_nes_screenshot1jpg.gif
17:54:40 <Baughn> Veinor: Sadly, irc doesn't support the Neural Interconnection Protocol.
17:54:44 <Veinor> bah
17:54:48 <copumpkin> erikc`: lol
17:54:57 * ski would still like Veinor to specify more clearly what s/he wants with `OO'
17:55:01 <Veinor> I always think savvy is misspelled.
17:55:18 <Baughn> Veinor: Basically - don't worry about it. Go ahead and use haskell, and ask us again when you have a concrete problem.
17:55:19 <Veinor> ski: eh, I don't know. I think I'm asking the wrong question, and I'm not really sure what I meant to ask.
17:55:36 <Baughn> Or at least a slightly less abstract one
17:55:51 <Veinor> Fair enough. :D
17:55:54 <ski> Veinor : have you eyed through that link, yet ?
17:56:09 <Veinor> Looking at it.
17:56:13 <seydar> coolio
17:56:32 <Baughn> Veinor: And.. FYI, looking at how to do OO in haskell /first/ is somewhat like trying to use functions in java
17:56:41 <Veinor> Yes, I know.
17:56:45 <Baughn> Veinor: It's not the right way, 95% of the time, and will only lead to headache
17:57:20 <ski> (Veinor : i'm not saying some of the things which have been lumped under `OO' wouldn't be useful in Haskell .. but it's good to be aware that different people mean different things by the term)
17:57:26 <Veinor> Yeah, I get that.
17:59:43 <karan> erikc: .jpg.gif
17:59:44 <karan> lol
18:00:29 <mmorrow> Veinor: i guess the dual of "every object contains only a single function" would be "every function is a single object" or something
18:00:30 <wgsilkie> I have read several tutorials explanation of monads, and I *still* don't get it.  I'm really sick of the Maybe example; it's very unclear.
18:00:47 <rovar> the random monad is a more compelling example
18:01:07 <kscaldef> I don't thing you can understand monads by reading about them, only by doing things with them
18:01:32 <wgsilkie> OK, I'll try asking questions:
18:01:50 <rovar> build a random number generator in haskell
18:02:35 <wgsilkie> If I say main = do putStrLn "Hi!" \n f x \n putStrLn "Bye!"
18:02:55 <wgsilkie> Does the function f still run as a pure function with the "no side effects" rule?
18:03:12 <Baughn> wgsilkie: Yes. For that matter, so does putStrLn.
18:03:29 <wgsilkie> Ah.
18:03:32 <Baughn> wgsilkie: putStrLn is a pure function that, when you pass a String to it, returns an IO action
18:03:44 <Baughn> wgsilkie: f may be the same, but you didn't specify.
18:03:49 <Veinor> It's the 'do' bit that's impure, as I understand it.
18:03:50 <wgsilkie> Baughn: What?
18:04:03 <wgsilkie> OK, do I need to care?
18:04:06 <Baughn> Yes
18:04:15 <kscaldef> sort of...
18:04:24 <Baughn> Veinor: Well, not really. It's actually only IO that's impure, and do is common for all monads.
18:04:32 <kscaldef> If you care less, it might be easier...
18:04:44 <Baughn> wgsilkie: You need to care, but you also need to realize that it isn't actually very complex.
18:04:54 <wgsilkie> Um, OK.
18:05:02 <kscaldef> yeah, maybe that's what I'm trying to say...
18:05:05 <Veinor> Hm.
18:05:12 <mike-burns> I suspect that the `do' notation is the complex bit.
18:05:16 <ski> (Veinor : nothing impure)
18:05:17 <Baughn> wgsilkie: Most of all, you need to realize that most of the "magic" in monads exists in /individual monads/, not in the Monad class as such
18:05:17 <wgsilkie> I still don't quite get it.
18:05:28 <kscaldef> there's a million monad tutorials, which seems to have the result of making it seem more complex / important than it needs to be
18:05:29 <Baughn> wgsilkie: The Monad class puts very few restrictions on what you can make..
18:05:31 <Veinor> Hm. I think I'll let people who know what they're talking about explain it.
18:05:32 <Veinor> :D
18:05:36 <mike-burns> wgsilkie: Can you re-write your main = ... using non-do notation?
18:05:42 <ski> (neither `do' in general nor `IO' in particular is impure)
18:06:11 <Baughn> wgsilkie: 'main = do print "foo"; f x; print "bar"' <-- Equivalent to your code
18:06:31 <_Philippa_> ski: well, there's two points of view on IO, but that's rather the /point/
18:06:36 <Baughn> wgsilkie: The compiler cooks that down to 'main = print "foo" >> f x >> print "bar"'
18:06:36 <mike-burns> Er I had meant without `do'-notation.
18:06:53 <ski> _Philippa_ : yes, the point is that it is really about POV :)
18:06:56 <Adamant> ah, monads. the pons asorium of Haskell.
18:07:24 <soupdragon> ??
18:07:30 <mike-burns> Those aren't real words!
18:07:31 <soupdragon> interesting
18:07:37 <ski> (but from the perspective from Haskell, it's pure)
18:07:37 <soupdragon> yeah it means asses bridge
18:07:40 <Adamant> soupdragon: Latin for "bridge of asses"
18:07:44 <Baughn> wgsilkie: ..you with me this far?
18:07:55 <wgsilkie> Baughn: I think so.
18:08:01 <Baughn> wgsilkie: >> is a standard function
18:08:06 <Adamant> soupdragon: it refers to a problem from Euclid that shut down most people in the era
18:08:19 <soupdragon> I know it, just wondering how you are relating it. do you mean it's like an acid test?
18:08:23 <wgsilkie> Baughn: OK, which does what?
18:08:27 <Baughn> wgsilkie: What it does is combine two monad values. Exactly what combine /means/ depends on the particular monad; there is no general action.
18:08:30 <Adamant> soupdragon: an intellectual one, yeah
18:08:47 <Baughn> wgsilkie: In the IO monad, it means "run one, then the other". Other monads can and do have very different meanings.
18:08:48 <Adamant> you had to get it to do further study of Euclid back in the day
18:08:49 <soupdragon> @remember Adamant ah, monads. the pons asorium of Haskell.
18:08:50 <lambdabot> I will never forget.
18:08:54 <ski>   ma >> mb = do ma; mb
18:08:56 <wgsilkie> Oh, OK, that's *one* reason the Maybe monad example is unclear.
18:09:21 <Baughn> wgsilkie: However, there is at least one rule. Monads have /some/ sort of contents, which is why they're often viewed as "containers"; this is actually because they're a subclass of Functor, the main container class.
18:09:40 <byorgey> shouldn't that be "pons asinorum"?
18:09:46 <_Philippa_> wgsilkie: do you understand typeclasses?
18:09:47 <Baughn> wgsilkie: >> discards the contents returned by the first monad value, keeping the second's around for its own return value.
18:09:55 <Veinor> byorgey: yes it should.
18:10:00 <wgsilkie> _Philippa_: Mostly.
18:10:07 <wgsilkie> Just not with monads.
18:10:18 * ski . o O ( "ego asinus sum" )
18:10:18 <byorgey> @forget Adamant ah, monads. the pons asorium of Haskell.
18:10:19 <lambdabot> Done.
18:10:19 <_Philippa_> *nod*. The fact that Monad itself is a type class like any other is pretty important
18:10:21 <Baughn> wgsilkie: The other feature of monads is that you can extract that contents, and use it in a pure function
18:10:27 <byorgey> @remember Adamant ah, monads. the pons asinorum of Haskell.
18:10:28 <lambdabot> It is stored.
18:10:32 <Baughn> wgsilkie: Eg. "do a <- foo; bar a"
18:10:33 <wgsilkie> Baughn: What do you mean by value/contents?
18:10:40 <byorgey> we'll just pretend Adamant said it right in the first place =)
18:10:47 <ski> @type getLine
18:10:49 <lambdabot> IO String
18:11:01 <Baughn> wgsilkie: It depends on the monad. ;)
18:11:12 <wgsilkie> Baughn: Ahhhh.
18:11:13 <Baughn> wgsilkie: For IO, it's some pure value produced by running the impure function
18:11:27 <Baughn> wgsilkie: But IO is magic, and special in many ways. Let's use a simpler, but not /too/ simple example: THe list monad.
18:11:43 <soupdragon> I am magic
18:11:46 <ski> the "contents" of the `IO'-action `getLine' is the line that is read by that action, whenever run .. in the analogy Baughn was using
18:11:47 <_Philippa_> wgsilkie: think "return value". A value of type IO a is a 'program' that returns an a
18:11:55 <mike-burns> (One issue I have with answering "what is a monad" is that it's more of a design pattern than a concrete thing. "What is a list monad" makes more sense to answer.)
18:12:04 <Baughn> wgsilkie: For the list monad, the type "m a" in the various type signatures of the monad functions is reified to "[a]".
18:12:16 <Baughn> wgsilkie: Eg. a monad value for a list is simply a list
18:12:23 <_Philippa_> mike-burns: concrete, abstract, same difference...
18:12:24 <SamB> mike-burns: yeah, the hardest step for me in learning monads was to abandon that question
18:12:28 <Baughn> wgsilkie: In this case, the "contents" bit is pretty easy to get, right? :)
18:12:40 <wgsilkie> Baughn: Uh, yes.
18:12:49 <SamB> mike-burns: I had already learned the rest well enough
18:12:57 <kscaldef> wgsilkie: that's where it gets specific to a particular monad
18:13:14 <wgsilkie> Ah, OK.
18:13:18 <kscaldef> oops... replying to a page up...
18:13:31 <wgsilkie> I think I get it (well enough) now.
18:13:40 <Baughn> wgsilkie: Right. Now, it's easier to understand monads if you first understand that they're a subclass of functor.
18:13:45 <wgsilkie> Thanks, Baughn and everyone else!
18:13:45 <Baughn> wgsilkie: So let me finish me lecture. ;)
18:13:54 <wgsilkie> Baughn: Oh, OK.  Goodie!
18:14:21 <Baughn> wgsilkie: The Functor type-class has a single method, fmap, whose type is "(a -> b) -> f a -> f b"
18:14:33 <Baughn> wgsilkie: In other words, it's basically map, except it works on other things than lists.
18:14:39 <wgsilkie> Hang on!
18:14:50 <wgsilkie> Baughn: What's a method in functional programming?
18:15:03 <mike-burns> Ha oh busted.
18:15:08 <mike-burns> He meant function.
18:15:14 <Baughn> ..no, I meant method.
18:15:25 <wgsilkie> That's a function that can work with a particular type class, correct?
18:15:27 <Baughn> wgsilkie: It's a bit complicated, but.. for now, are you familiar with java interfaces?
18:15:36 <_Philippa_> wgsilkie: yep
18:15:39 <wgsilkie> Baughn: Sort of.
18:16:05 <ski> a method is an operation defined in a type class
18:16:06 <Baughn> wgsilkie: An interface is basically a limit case of a type-class, and work well enough for these simple cases. A method's a particular function that interface has to support.
18:16:12 <wgsilkie> I think I know what it is well enough for the purpose of this lecture.
18:16:36 <Baughn> wgsilkie: So, to make a particular type (constructor) an instance of the Functor type-class, that means it has to implement fmap.
18:16:50 <wgsilkie> Ah.
18:16:58 <wgsilkie> So what's type f a?
18:17:04 <ski> @type fmap
18:17:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:17:29 <Baughn> wgsilkie: The Functor type-class requires each instance to be for a type /constructor/ of one argument
18:17:38 <ski> `f' is the type which is an instance of `Functor', e.g. `Maybe' or `[]' or `IO'
18:17:41 <Baughn> wgsilkie: The a represents the argument, here, the f the constructor
18:17:52 <wgsilkie> OK.
18:17:55 <Baughn> wgsilkie: ..besides that, either can be absolutely anything.
18:18:03 <Badger> f :: Expr
18:18:06 <Badger> er
18:18:10 <Badger> > f :: Expr
18:18:11 <ski>   fmap :: (a -> b) -> IO a -> IO b  -- in the `IO' case
18:18:11 <lambdabot>   f
18:18:20 <Baughn> wgsilkie: SOme typical functors are [] (the list), functions of one argument, IO, Maybe and of course traditional containers such as Data.Map
18:18:46 <wgsilkie> Baughn: Let's stick with the list.
18:18:49 <wgsilkie> :)
18:18:57 <Baughn> wgsilkie: Right. In this case, fmap = map, so you know how it works. :)
18:19:18 <ski> @src [] fmap
18:19:18 <lambdabot> fmap = map
18:19:22 * wgsilkie tries to process this for a moment.
18:19:33 <Baughn> wgsilkie: Functor's basically very simple, but you'll use it a lot later.
18:19:44 <wgsilkie> How does fmap = map?
18:19:52 <Baughn> wgsilkie: What's the type of map?
18:20:02 <ski>   instance Functor [] where fmap = map
18:20:04 <wgsilkie> Isn't that like saying 2 = 1?
18:20:26 <Baughn> wgsilkie: No.. see
18:20:34 <ski> there are different `fmap' functions depending on what the `f' is
18:20:40 <wgsilkie> Oh.
18:20:41 <Baughn> wgsilkie: We have 'map :: (a -> b) -> [a] -> [b]'
18:20:43 <wgsilkie> Right.
18:20:47 <ski> in the case `f' is `[]', then `fmap' is just `map'
18:20:59 <wgsilkie> Oh. I see.
18:21:02 <Baughn> wgsilkie: That could also be written as 'map :: (a -> b) -> ([] a) -> ([] b)', using prefix type syntax
18:21:07 <Badger> @ty fmap
18:21:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:21:13 <wgsilkie> The '[]' bit confused me.
18:21:23 <Badger> ah
18:21:31 <ski> @kind [] Int
18:21:32 <lambdabot> *
18:21:33 <ski> @kind []
18:21:34 <lambdabot> * -> *
18:22:00 <Baughn> wgsilkie: When instancing a type-class, what you do is provide a type (constructor, for functor) to be substituted in all the type signatures for the methods in that type-class
18:22:11 <Baughn> wgsilkie: So when fmap has signature (a -> b) -> f a -> f b..
18:22:23 <Baughn> wgsilkie: When you instance Functor for [], you just replace every occurence of f with []
18:22:32 <Baughn> wgsilkie: Make any sense?
18:22:41 <wgsilkie> Baughn: Yes.
18:22:44 <wgsilkie> Now it does.
18:22:58 <Baughn> wgsilkie: It's the same for IO, Maybe, etc.
18:23:11 <Baughn> wgsilkie: But for the list, now. If we've got Functor down.. next type-class!
18:23:13 <ski> @src Maybe fmap
18:23:14 <lambdabot> fmap _ Nothing       = Nothing
18:23:14 <lambdabot> fmap f (Just a)      = Just (f a)
18:23:18 <ski> @src IO fmap
18:23:18 <lambdabot> fmap f x = x >>= (return . f)
18:23:23 <Baughn> wgsilkie: Applicative.
18:23:32 <Baughn> ..oh, this'll be fun.
18:23:38 <Baughn> @src Applicative
18:23:38 <lambdabot> class Functor f => Applicative f where
18:23:38 <lambdabot>     pure  :: a -> f a
18:23:38 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
18:23:56 <wgsilkie> Wha...?
18:24:15 * ski wonders whether it would be better to teach `Monad', first ..
18:24:19 <wgsilkie> Baughn: I'm not sure I can handle any more now.
18:24:27 <Baughn> wgsilkie: The applicative type-class, as you can see, builds on Functor. It has two methods; one that lets you stick one value inside the container, and another that lets you take a container whose values are functions, and apply to it another container whose values are inputs to those functions
18:24:43 <Baughn> wgsilkie: But I promise, after Applicative, Monad is really, really simple.
18:24:47 * wgsilkie doesn't *fully* understand type classes.
18:25:13 <wgsilkie> Baughn: Can we go over type classes briefly, first?
18:25:20 <Baughn> wgsilkie: Sure..
18:26:01 <Baughn> wgsilkie: Want to go over that class definition?
18:26:09 <wgsilkie> Which one?
18:26:14 <Baughn> The one for Applicative
18:26:23 <Baughn> Or you could take Functor again if you like..
18:26:24 <wgsilkie> OK.
18:26:30 <wgsilkie> Applicative.
18:26:33 <Baughn> @src Applicative
18:26:33 <lambdabot> class Functor f => Applicative f where
18:26:34 <lambdabot>     pure  :: a -> f a
18:26:34 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
18:27:31 <Baughn> wgsilkie: Do you understand the difference between a concrete type and a type constructor?
18:27:54 <wgsilkie> I think I *did*, but have forgotten the distinction.
18:28:29 <Baughn> To put it simply, then..
18:28:41 <Baughn> A concrete type is something that can actually exist in your program, at run-time.
18:28:51 <Baughn> Every actual /value/ has a concrete type.
18:28:56 <wgsilkie> OK.
18:29:20 <Baughn> A type constructor is a type-level function, which you can pass another type to (concrete or not, depends on the constructor) to get a new type.
18:29:26 <Baughn> The new type may or may not be concrete.
18:29:54 <Baughn> (That depends just on how many parameters the constructor has. No magic.)
18:30:17 <Baughn> wgsilkie: So, [] is a type constructor of one parameter. Int is a concrete type. And [Int] is also a concrete type.
18:30:36 <Baughn> wgsilkie: Accordingly, there are no "[]s" in your program at runtime, but there may well be [Int]s, see?
18:30:44 <wgsilkie> So, a type constructor means the type isn't set in stone?
18:30:53 <Baughn> It means the type is incomplete, yes
18:30:55 <wgsilkie> I think I get it now.
18:31:27 <Baughn> wgsilkie: For.. well, Functor is handy. Let's see.
18:31:29 <Baughn> @src Functor
18:31:29 <lambdabot> class  Functor f  where
18:31:29 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:31:48 <Baughn> wgsilkie: In this class definition. First line, "class Functor f where"
18:32:14 <wgsilkie> Ah, I see.
18:32:14 <Baughn> wgsilkie: Functor is just the name of the class. f is what it's parametrized over, but it's a type; it does not need to be concrete, since there's no kind signature there.
18:32:23 <Baughn> wgsilkie: In the second line, in fmap..
18:32:36 <Baughn> wgsilkie: fmap is an actual function, so it can only take actual values that actually exist at runtime
18:32:48 <Baughn> wgsilkie: In other words, "f a" has to be a concrete type
18:32:56 <wgsilkie> Let's do Monad.
18:33:00 <Baughn> wgsilkie: ..which means that f has to be a type constructor of one type
18:33:13 <wgsilkie> Got it!
18:33:41 <Baughn> wgsilkie: The problem with Monad is that it's actually a combination of Applicative with one other, pretty simple function. I'd rather take Applicative, if you don't mind; that lets me decompose them more easily.
18:33:46 <Baughn> @src Applicative
18:33:47 <lambdabot> class Functor f => Applicative f where
18:33:47 <lambdabot>     pure  :: a -> f a
18:33:47 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
18:33:55 <wgsilkie> OK, then.
18:34:11 <Baughn> So here, we have two methods in the class
18:34:28 <Baughn> Oh, and the first line states that there has to be a Functor instance before there can be an Applicative instance, by the way.
18:34:52 <hackagebot> Lastik 0.3 - A library for compiling programs in a variety of languages (TonyMorris)
18:34:54 <Baughn> wgsilkie: f is a type constructor of one parameter; that parameter is here named a.
18:35:26 <Baughn> wgsilkie: pure, here, is just a function that lets you take a value of that parameter's type, and put it inside the f container - whatever f is.
18:35:39 <Baughn> wgsilkie: Now, pure also has another name, return, in the Monad class, but they're the same thing.
18:35:43 <Baughn> wgsilkie: So, for the list monad..
18:35:47 <Baughn> > return 2 :: [Int]
18:35:48 <lambdabot>   [2]
18:36:11 * wgsilkie is with Baughn, so far.
18:36:28 <Baughn> wgsilkie: Well, you see. pure/return let you wrap the type in the container, and that's all it does. *How* it does it is entirely up to the particular instance.
18:36:43 <Baughn> wgsilkie: <*>, called ap for Monad, is a little different
18:37:05 <Baughn> wgsilkie: It takes a container whose contents are functions, and lets you apply another container to it, returning a third
18:37:31 <Baughn> wgsilkie: Again, how it does this is /entirely/ up to the particular instance, but the common way of arriving at this in the first place is to use fmap on a function of more than one parameter
18:37:37 <Baughn> For example..
18:37:52 <Baughn> > fmap (+) [1,2,3]
18:37:53 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:37:53 <lambdabot>    arising from a use of `...
18:38:01 <Baughn> ..that used to work. Fine.
18:38:03 <Baughn> @type fmap (+) [1,2,3]
18:38:05 <lambdabot> forall a. (Num a) => [a -> a]
18:38:32 <Baughn> wgsilkie: There you have it, a container with functions in it. A list, in this case.
18:38:45 <wgsilkie> Ah ha!
18:39:03 <Baughn> wgsilkie: *How* <*>/ap applies a second list to it depends /entirely on the applicative instance/
18:39:06 <ski>   [(1 +),(2 +),(3 +)]  -- basically
18:39:18 <Baughn> For List, it pretends to indeterminacy
18:39:25 <Baughn> That is, it applies them in every possible combination.
18:39:43 <Baughn> Another possible choice would be to zip them, aka. zipWith, but that's not what they picked. There's a newtype'd list that does, though.
18:40:06 <Baughn> The Maybe version has pretty much only one thing it /can/ do, so that's what it does, but let's not get into that.
18:40:10 <Baughn> So..
18:40:27 <Baughn> > (fmap (+) [1,2,3]) <*> [10,20,30]
18:40:29 <lambdabot>   [11,21,31,12,22,32,13,23,33]
18:40:31 <Baughn> See?
18:40:53 <shachaf> The thing about ZipList is that you can't extend it to Monad -- you can't write join in a sensible way.
18:40:54 <Baughn> wgsilkie: Which brings us to the last type-class.
18:41:10 <ski> > pure (+) <*> [1,2,3] <*> [10,20,30]
18:41:12 <lambdabot>   [11,21,31,12,22,32,13,23,33]
18:41:33 <Baughn> wgsilkie: If you pretend Monad is a sub-class of Applicative (it isn't, but that's a historical accident), then the only method Monad adds on top of Applicative is called "join".
18:41:43 <shachaf> > (+) <$> [1,2,3] <*> [10,20,30] -- More standard way of writing that?
18:41:45 <lambdabot>   [11,21,31,12,22,32,13,23,33]
18:41:49 <Baughn> wgsilkie: What that does is.. well, its type signature is "m (m a) -> m a".
18:41:58 <Baughn> wgsilkie: In other words, it takes a nested container, and removes the nesting.
18:42:05 <ski> (shachaf : `liftA2' ?)
18:42:19 <Baughn> wgsilkie: For list, it's just concat. But keep in mind the type signature; that's all it needs to do.
18:42:29 <pikhq> > liftA2 (+) [1,2,3] [10,20,30]
18:42:30 <shachaf> ski: Fair enough. :-) Occasionally <$>/<*> is clearer.
18:42:30 <lambdabot>   [11,21,31,12,22,32,13,23,33]
18:42:50 * ski prefers `ap'
18:42:59 <shachaf> ski: ...You do? Infix?
18:43:04 <ski> yes
18:43:04 <Baughn> wgsilkie: And when you look at the type signatures of all three classes in combination.. well, there are some extra rules you're supposed to follow, but it's all basically very simple; there may be complexity in particular instances, but /not/ in the type-classes themselves.
18:43:20 <Baughn> wgsilkie: Which is where so many tutorials go wrong, mixing up the implementations with the interface.
18:43:23 <Baughn> wgsilkie: How's that? :)
18:43:42 <shachaf> wgsilkie: Sometimes concrete examples are the simplest way to understand an abstract thing.
18:43:49 <shachaf> s/wgsilkie/Baughn/
18:43:49 * wgsilkie re-reads the last few things.
18:44:37 * wgsilkie thinks he's reached saturation point.
18:44:43 <wgsilkie> Thanks, Baughn!
18:44:47 <shachaf> (By the way, if Monad was a subclass of Applicative, would you need to define (<*>) redundantly?)
18:44:49 <wgsilkie> This really helps.
18:44:50 <Baughn> wgsilkie: What I've noticed is that many people try to invent analogies that are supposed to work for /all/ monads, when they don't, and can't exist. Pretty much everything you can learn works for only a particular monad.
18:45:02 <Baughn> wgsilkie: Though the utility functions are still very handy. ;)
18:45:18 <wgsilkie> Baughn: What're the utility functions?
18:45:20 <ski> shachaf : how do you mean ?
18:45:34 <Baughn> wgsilkie: Things like sequence, mapM and such
18:45:41 <Baughn> wgsilkie: The stuff in Control.Applicative and Control.Monad
18:45:49 <shachaf> ski: (<*>) is not needed if you have join/fmap/return, but you'd have to define it anyway, yes?
18:45:51 <wgsilkie> Ah.
18:45:54 <ski> Data.Traversable
18:45:56 <shachaf> Baughn: Well, even "container" is an analogy that doesn't really make sense in every case (e.g., IO).
18:45:57 <pikhq> wgsilkie: All the various functions that are defined for monads, like sequence, mapM, forM, ap, liftM, etc.
18:46:03 <wgsilkie> Thanks again!
18:46:22 <Baughn> shachaf: IO's weird, though. It pretty much works for everything else.
18:46:33 <ski> shachaf : you could always do `instance Applicative Foo where (<*>) = ap' ..
18:47:14 <ski> shachaf : however, it *would* be nice if one could give that default implementation in the declaration of the subclass `Monad' of `Applicative'
18:47:39 <shachaf> ski: Hum, I guess that could work. But yes, that was what I meant.
18:47:52 <ski> (possibly with the definition of `ap' in terms of `(>>=)' and `return' unfolded)
18:47:58 <shachaf> Baughn: Well, "container" doesn't make too much sense for, e.g., Reader, either.
18:48:18 <shachaf> (+1) doesn't "contain" an Int.
18:48:28 <Baughn> Not /an/ int, no.
18:48:32 <Baughn> It contains all of them. :3
18:49:00 <Baughn> But I know, the "container" analogy doesn't always quite fit.
18:49:07 <shachaf> In a similar sense to getLine containing all Strings. :-)
18:49:12 <ski> > fmap not [False,True]  -- the container of type `Bool -> Bool'
18:49:14 <lambdabot>   [True,False]
18:49:14 <Baughn> Still.
18:49:26 <Baughn> The "value" analogy doesn't really fit haskell "values" either, you know..
18:49:59 <Baughn> Oh, and I see no particular difference between Reader and Data.Map
18:50:08 <ski> > fmap (2^) [0..]  -- the container of type `Integer -> Integer' .. at least the natural ones
18:50:10 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:50:19 * vav looks vainly on cable television for a Typeclassopedia channel for more of such lectures running 24/7 -- thanks Baughn.
18:50:32 <_Philippa_> well yes, you can implement functions using (possibly-infinite) maps, what else is new?
18:51:04 <ski> (or vice versa)
18:51:18 <shachaf> Baughn: And I see no particular difference between IO and State World. But sometimes the analogy just makes things more complicated. :-)
18:51:23 <_Philippa_> the value/computation analogy is specifically running with the idea that the monad's 'language' can have very different properties to haskell
18:51:30 <_Philippa_> but then, that's kinda what we use 'em for
18:51:48 <Baughn> shachaf: IO String contains a string. We just don't know which one until we look. :P
18:52:07 <ski> reasoning in the kleisli category of a particular monad ..
18:53:15 <shachaf> Baughn: OK -- but that's not how you honestly think of it when you use it.
18:53:19 <pikhq> I have half a mind to just write "instance Monad m => Applicative m where ..." :P
18:53:54 <shachaf> pikhq: You can't do that in normal Haskell, can you?
18:53:55 <Baughn> shachaf: If I did, I couldn't possibly use unsafePerformIO as much. :P
18:54:33 <shachaf> Of course "monads as computations" is the same thing as "monads as containers", because a value is a computation in Haskell.
18:54:47 <Baughn> Gah
18:54:48 <pikhq> shachaf: Well, no.
18:54:52 <pikhq> I sure wish you could.
18:55:06 <Baughn> pikhq: You can. I do it all the time.
18:55:14 <pikhq> Oh.
18:55:16 <pikhq> woots.
18:55:20 <ski>   class Applicative m => Monad m where {..; instance Applicative m where {(<*>) = liftM2 id}}
18:55:27 <Saizan> Baughn: instance Monad m => Applicative m where ... ?
18:55:36 <Baughn> pikhq: ..oh, thought you were responding to his /latest/ line.
18:55:38 <pikhq> That totally needs to be in the Prelude.
18:55:48 <Baughn> Saizan: Sorry, misunderstanding.
18:55:53 <pikhq> No, I was responding to his response. :)
18:55:55 <Baughn> THough I'm pretty sure it should be doable
18:55:59 <Baughn> Um
18:56:09 <Saizan> that instance kind of works only with OverlappingInstances
18:56:53 <_Philippa_> shachaf: eh. If anything, I suspect one's more algebraic and one's more coalgebraic
18:56:53 <ski> (shachaf : i think that's confusing two different senses of `computation')
18:57:04 <_Philippa_> (
18:57:15 <Saizan> because it ovelaps with any other Applicative instance, the context doesn't matter
18:57:16 <ski> )
18:57:17 <shachaf> ski, _Philippa_: ?
18:57:23 <_Philippa_> ski: hell, of 'function' if you want to look at it that way
18:57:29 <shachaf> Saizan: Sorry, you got parenthesized.
18:57:53 <_Philippa_> ski: at least, assuming the unimplementable Id monad doesn't count
18:57:59 <ski> shachaf : a value in haskell is a computation in the sense that it may be an unevaluated thunk
18:58:05 <_Philippa_> (the one where Id a and a are the same type)
18:58:29 <ski> shachaf : while the "monadic computation" sense is not about this, but about expressing effects
18:59:10 <ski> (_Philippa_ : `newtype' ?)
18:59:11 <_Philippa_> ski: which is to say, a value in haskell /isn't/ a thunk - the thunk is a potential implementation of one
18:59:18 <ski> yes
18:59:39 <_Philippa_> ski: newtype's not good enough, you'd need to have the isomorphism applied for you automagically
19:00:03 <ski> _Philippa_ : for what end ?
19:00:36 <_Philippa_> being able to label arbitrary values 'computations' by auto-applying the isomorphism to the Id monad
19:00:42 <ski> ok
19:01:09 <ski> (being able to do that without changing the expressions .. not even wrapping them)
19:01:25 <_Philippa_> exactly
19:01:58 <ski> (i'm not sure why that was part of your point .. but i can leave it at this)
19:02:21 <soupdragon> what other implementation is there?
19:02:47 <soupdragon> you could say it's a value in a lazy language but that's like the xenobiogenesis story
19:02:54 <_Philippa_> soupdragon: graph reduction. Or even just plain call-by-name.
19:03:36 <_Philippa_> same mistake as calling first-class functions 'closures' just because they didn't come from top-level
19:04:04 <soupdragon> oh yeah, I don't relate graph reduction to thunks
19:26:37 * shepheb curses and swears
19:26:55 <drbean> Baughn++ for the lecture.
19:27:18 <shepheb> does anyone know a compelling reason why the FastCGI module uses CGI (== CGIT IO) instead of (MonadIO m) => CGIT m a
19:27:39 <shepheb> now I can't use a custom Reader monad, for example, to carry around the DB connection
19:27:40 <Saizan> shachaf: because of catch
19:27:47 <Saizan> ?type catch
19:27:50 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
19:28:09 <shepheb> so is this why the new exception system? or is this no better with the new system?
19:28:17 <Saizan> no better
19:28:39 <Saizan> it's a general problem with monadic callbacks
19:28:46 <shepheb> sigh
19:29:04 <Saizan> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html <- this explains it and proposes a solution
19:29:18 * shepheb will have to just keep repeating: "It could always be worse, you could be writing this in PHP."
19:29:30 <SamB> or C!
19:29:44 <bremner> or stabbing your self in the eye with a spoon
19:29:48 <pikhq> Or MIX!
19:30:00 <SamB> pikhq: or MMIX!
19:30:10 <pikhq> ... Without The Art of Computer Programming handy!
19:30:19 <SamB> MIX is just archaic toy-sized
19:30:23 <Saizan> however the simple solution is to use an IORef, and maybe using a ReaderT carry the IORef around
19:30:26 <hiredman> *dun* *dun* *duuuun*
19:30:32 <SamB> MMIX is needlessly complicated pure toy
19:30:44 <shepheb> Saizan: if I could use a Reader, the issue would already be solved.
19:30:47 <pikhq> SamB: It's pure?
19:30:49 <pikhq> :P
19:30:53 <Saizan> well, actually, you can use reader..
19:30:54 * ski associates the name "MIX" with partial evaluators ..
19:31:04 <SamB> pikhq: meaning it doesn't have what it takes to be a real computer architecture
19:31:07 <SamB> while MIX does
19:31:11 <Saizan> shepheb: what's the problem with using ReaderT r CGI ?
19:31:22 <SamB> disks, for example!
19:31:22 <shepheb> well, I suppose I could use RunReaderT
19:31:33 <Saizan> ?type runReaderT
19:31:34 <SamB> and tape drives
19:31:35 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
19:31:46 <shepheb> yeah, okay, I just need to turn it inside out. not ideal, but it will work just fine
19:31:51 <pikhq> SamB, I suspect that's a large part of what's taking future portions of TAoCP so long. :P
19:32:08 <Saizan> i'm not sure why it's less ideal
19:32:12 <SamB> I mean, it's kind of hard to write NNIX without any peripherals
19:32:29 <SamB> also, the MMU for MMIX is too complicated ...
19:32:53 <shepheb> forces me to manhandle the Connection more often. oh well, it's still a lot better than manual passing
19:32:56 <shepheb> thanks
19:33:46 <SamB> and there is no mechanism for changing the memory-mapping table format ...
19:34:11 <SamB> also, it doesn't have any support for semi-sparse mappings
19:36:06 <SamB> I guess what I'm saying is that two people could make MMIX computers and the *same* progams would run on both of them, with no emulation for the system calls of an operating system that can't be written
19:41:24 * copumpkin laughs at his absolutely disgusting algebra library
19:49:37 * Gracenotes joins in awkwardly
20:15:23 <copumpkin> > (+) <$> Just 5 <*> Just 7
20:15:24 <lambdabot>   Just 12
20:15:28 <copumpkin> > (+) <$> (Just 5 <*> Just 7)
20:15:29 <lambdabot>   Add a type signature
20:15:47 <copumpkin> > ((+) <$> Just 5) <*> Just 7
20:15:49 <lambdabot>   Just 12
20:30:16 <copumpkin> need moar algebra
20:30:52 <vav> copumpkin: can 'Just 5' be a f (a -> b)?
20:31:04 <copumpkin> sure
20:31:16 <copumpkin> if you want to define a Num instance for (a -> b) :P
20:32:15 <vav> hmm, won't put that too high on my todo's
20:37:32 <Jack_> Bender: Call me old fashioned but I like a dump to be as memorable as it is devastating.
20:37:50 <copumpkin> heh
20:39:26 <copumpkin> zomg
20:39:32 <copumpkin> edwardk: I just wrote my first :~>!!!
20:39:36 <copumpkin> lol
20:48:47 * copumpkin tries to figure out how to represent vector spaces and modules effectively
20:50:21 <dino-> ls
20:52:12 <djahandarie> :t find
20:52:13 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
20:55:46 <djahandarie> Is there a better way to test if x is in List y than find?
20:56:14 <aavogt> @type elem
20:56:15 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
20:56:50 <djahandarie> Ah
20:57:18 <aavogt> @hoogle a -> [a] -> Bool
20:57:19 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
20:57:19 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
20:57:19 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
20:58:00 <aavogt> @hoogle [a] -> a -> Bool
20:58:01 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
20:58:01 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
20:58:01 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
21:00:38 <djahandarie> Man, I must be missing something for the Project Euler 3 question...
21:01:04 <djahandarie> Only way I can think of checking primes that high is a primality test like Miller-Rabin which is a bit of a pain
21:01:09 <djahandarie> And it seems way too complicated. -_-
21:02:24 * copumpkin sighs
21:02:25 <copumpkin> *Main> using2 Plus Times (5 + 7 * 2) :: Integer
21:02:25 <copumpkin> 19
21:02:33 <copumpkin> you'd never guess how painful that was
21:04:54 <gaze__> alright I'm still pretty overwhelmed by the practical uses of monads... so say I'm writing something that converts machine code to an intermediate format... that'd end up using bytestream... and maybe I'd want to create some kind of nice way to string together IR using some sorta language... what's the best way to shove 'em together, since bytestream uses the get monad
21:05:29 <copumpkin> ByteString
21:05:37 <copumpkin> IR?
21:05:57 <gaze__> oops sorry. IR == intermediate representation
21:06:28 <gaze__> just a simple generic language with loads/stores/basic ALU stuff/conditionals, etc.
21:06:29 <SamB> well, usually we keep our IRs in ADTs
21:09:09 <gaze__> which makes sense... but I'd like to have a convenient way to chunk it out with a language of some sort
21:10:58 <gaze__> especially when you're decoding an operation like... [load|store] [pre|post][increment|decrement] [word|halfword|byte]... etc.... and if you're trying to support multiple instruction sets it makes it super comfortable to add new ops
21:12:18 <BMeph> gaze__: Maybe I'm just hopelessly n00bish, but this sounds more like a parsing issue. :)
21:12:48 <gaze__> well... it's more of an implementation/organizational issue
21:12:57 <copumpkin> using Plus (5 `op` 7) :: Integer
21:13:10 <BMeph> > using Plus (5 `op` 7) :: Integer
21:13:11 <lambdabot>   Not in scope: data constructor `Plus'Not in scope: `op'
21:13:11 * copumpkin needs to figure out defaulting
21:13:32 <copumpkin> couldn't find any docs on it
21:14:04 <aavogt> @where onlinereport
21:14:04 <lambdabot> I know nothing about onlinereport.
21:14:58 <copumpkin> oh wow, defaults are per module?
21:16:01 <copumpkin> wow, the defaulting rules are kinda lame
21:19:57 <web_sohum> echo $LANG => "en_AU.UTF-8", ghci >> putStrLn "→" => �
21:21:06 <web_sohum> how do I get putStr and sibling show to output utf8?
21:24:23 <Veinor> In the definition of Maybe, why does it have to be Just a | Nothing?
21:24:27 <Veinor> Why can't it be defined as a | Nothing?
21:25:10 <web_sohum> Veinor: because the ADTs have to be discriminated. You can think of the first word in each as a function that takes that type and returns the datatype
21:25:16 <web_sohum> i.e., Just :: a -> Maybe a
21:25:53 <copumpkin> Veinor: if I wrote something like if even x then 5 else Nothing, how would it figure out that it should typecheck?
21:26:56 <Veinor> Aah.
21:27:18 <BMeph> Veinor: The type system is designed deliberately to emulate a clingy girlfriend. ;p
21:28:28 <Veinor> Haha
21:31:14 <Veinor> So then suppose I have an x which is either a Just Int or Nothing. How do I write a function that adds 2 if it's a Just Int?
21:31:38 <Berengal> fmap (+2)
21:32:52 <jfoutz> > fmap (+2) $ Just 2
21:32:53 <lambdabot>   Just 4
21:33:03 <jfoutz> > fmap (+2) $ [1..3]
21:33:04 <lambdabot>   [3,4,5]
21:33:19 <jfoutz> > fmap (+2) $ Right 2
21:33:20 <lambdabot>   Right 4
21:33:49 <Veinor> Ahh.
21:33:56 <jfoutz> that's really satisfying.
21:33:56 <Veinor> But suppose for some reason I wanted to hand-write it?
21:34:12 <Badger> jfoutz: isn't it just?
21:34:31 <jfoutz> add2 Nothing = Nothing; add2 (Just x) = x + 1
21:34:31 <Berengal> Veinor: Pattern match on it
21:34:40 <Veinor> Ah, kay.
21:35:55 <aavogt> @src Maybe Functor
21:35:55 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:35:59 <copumpkin> I love how add2 adds 1
21:36:14 <aavogt> @src Functor Maybe
21:36:14 <lambdabot> Source not found. :(
21:36:16 * jfoutz blushes
21:36:35 <jfoutz> er... intentional but to make sure everyone's paying attention.
21:36:57 <jfoutz> s/but/bug/
21:37:16 <aavogt> jfoutz: and the missing Just on the second right hand side?
21:37:21 <Badger> @src Maybe Functor
21:37:21 <lambdabot> Source not found. Take a stress pill and think things over.
21:37:24 <Badger> oh
21:37:30 <Badger> what was it that did that
21:37:37 <jfoutz> gah. bedtime. can't even type anymore.
21:58:54 <PetRat> I am experimenting with the ((,) e) form of writing a type that uses the comma constructor. For example, if I had a function declared foo::(Int,String) -> (Int,String), I wanted to see if I could write that as foo :: ((,) Int String) -> ((,) Int String) , but it doesn't work.
21:59:27 <copumpkin> :t undefined :: ((,) Int String) -> ((,) Int String)
21:59:28 <lambdabot> (Int, String) -> (Int, String)
21:59:43 <copumpkin> PetRat: "doesn't work" how?
22:01:25 <PetRat> Well funny that. It works now. I guess I probably had a typo in there somewhere. The error I was getting was 'expected type *, but such-and-such has type *->*'
22:02:14 <PetRat> :t ((,) Int)
22:02:15 <lambdabot> Not in scope: data constructor `Int'
22:02:36 <copumpkin> :k ((,) Int)
22:02:37 <lambdabot> * -> *
22:02:50 <PetRat> Ah, :k gives kind.
22:02:57 <PetRat> :k ,
22:02:59 <lambdabot> parse error on input `,'
22:03:02 <PetRat> :k (,)
22:03:03 <lambdabot> * -> * -> *
22:03:15 <PetRat> :k State
22:03:16 <lambdabot> * -> * -> *
22:04:09 <PetRat> Well I will just carry on. Thanks copumpkin.
22:04:20 <copumpkin> :)
22:04:24 <copumpkin> let me know if you have trouble
22:05:00 <PetRat> :k Maybe
22:05:01 <lambdabot> * -> *
22:05:13 <PetRat> :k Int
22:05:15 <lambdabot> *
22:07:34 <Trinithis> :k undefined
22:07:36 <lambdabot> Not in scope: type variable `undefined'
22:09:20 <dibblego> :k a
22:09:21 <lambdabot> Not in scope: type variable `a'
22:11:10 <mmorrow> this is kinda interesting: (asm) instructions used and counts for IntMap.s http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7861
22:11:45 <mmorrow> i particularly like jmp=2464, call=37
22:11:47 <mmorrow> :)
22:13:36 <mmorrow> haha, and zero "ret" instrs
22:14:00 <copumpkin> *Main> using2 Max Plus (5 + 2 * 6) :: Nonnegative Real
22:14:00 <copumpkin> Nonnegative 8.0
22:14:04 <copumpkin> something wrong there :P
22:14:07 <mmorrow> (which i guess actually makes sense since it's nowhere using the C stack..)
22:14:16 <Veinor> You mean 5 + 12 != 8? :o
22:14:30 <copumpkin> well, it's using the Max/Plus/Nonnegative Real Semiring there :P
22:14:35 <Veinor> :P
22:14:45 <mmorrow> (max 5 2) + 6 -- ?
22:15:06 <mmorrow> (or is the second arg for (*)?)
22:15:14 <mmorrow> err, i meant "or for (+)"?
22:15:19 <copumpkin> oh actually hmm
22:15:31 <Veinor> ... hmm. I can't figure out how to get 8 from any combination of 5, 2, 6, max, and +
22:15:32 <mmorrow> , (max 5 2) + 6
22:15:32 <copumpkin> well (*)'s behavior is affected by the Plus
22:15:36 <lunabot>  11
22:15:41 <mmorrow> well, even then ..
22:15:45 <copumpkin> I think I just typo'd max to min
22:15:49 <copumpkin> ...somewhere
22:15:59 <mmorrow> ah, that makes sense
22:16:08 <copumpkin> this code is ridiculous
22:16:13 <copumpkin> I should really split it up into more than one file
22:16:19 <mmorrow> oo
22:16:24 <mmorrow> :)
22:16:31 <copumpkin> 635 lines of repetitive crap :P
22:16:37 <mmorrow> ah that's not so bad
22:17:04 <copumpkin> most of it is mechanical "context synonyms"
22:17:59 <mmorrow> copumpkin: TH ftw
22:18:08 <copumpkin> yeah, that'll come once I'm convinced it's correct :P
22:18:15 <mmorrow> or just Text.PrettyPrint
22:18:32 <copumpkin> gonna see how pleasant I can make using a full algebra typeclass hierarchy in haskell
22:18:42 * mmorrow is using Text.PrettyPrint to generate 120,000 lines of repetitive C for his interp
22:18:45 <copumpkin> :o
22:19:06 * copumpkin wrote his first explicit natural transformation in haskell today :P
22:19:11 <copumpkin> world's lamest one I think
22:19:14 <mmorrow> apply_PDI, unpack_pap_PPL, pack_ap_DDP, ...
22:19:24 <copumpkin> it probably isn't even valid, but it does what I need it to
22:19:28 <mmorrow> (* a_crapload)
22:19:32 <copumpkin> :o
22:19:57 <mmorrow> (that being the section of (*) in case that was ambiguous)
22:20:29 <mmorrow> copumpkin: whatever, just write the code to generate it, then you only have to make small changes in that
22:21:39 <copumpkin> hmm, this is correct
22:21:40 <copumpkin> *Main> using Max (5 `op` 6) :: Nonnegative Real
22:21:40 <copumpkin> Nonnegative 6.0
22:22:06 <mmorrow> ooh cool, that looks interesting
22:22:09 <copumpkin> *Main> using Plus (5 `op` 6) :: Nonnegative Real
22:22:09 <copumpkin> Nonnegative 11.0
22:22:12 <mmorrow> is Max a gadt con or something?
22:22:20 <mmorrow> err, or hmm
22:22:26 <copumpkin> nah, it's basically Identity
22:22:50 <mmorrow> are Max and Plus two diff types altogether, and you're using classes?
22:23:07 <copumpkin> I just use a bunch of Identity-like newtypes to allow me to parametrize the algebraic structures by the operations on them
22:23:13 <copumpkin> yeah, they're completely separate
22:23:16 <copumpkin> but isomorphic
22:24:09 <Veinor> So wait.
22:24:09 <copumpkin> > max 5 0
22:24:11 <lambdabot>   5
22:24:14 <Veinor> If Maybe is a type constructor, what is Just?
22:24:19 <copumpkin> a data constructor
22:24:23 <mmorrow> ah, so something like (using :: (Foo a, Num b) => a -> b), where instance Foo Max where op = ... -- ?
22:24:26 <Veinor> ah.
22:24:47 <copumpkin> mmorrow: I warn you, I went a bit overboard here :P
22:24:48 <copumpkin> using2 :: Coalgebra f a -> Coalgebra s a -> WrapBimagma f s a -> a
22:24:48 <copumpkin> using2 _ _ = extract
22:25:05 <mmorrow> ah :)
22:25:38 <copumpkin> I feel kinda silly throwing Coalgebra in there for such a simple type signature, but it can't hurt
22:26:35 <mmorrow> can't hurt ;)
22:26:59 <copumpkin> lol
22:29:05 <copumpkin> @check \(Nonnegative x) (Nonnegative y) (Nonnegative z) -> x `max` (y + z) == (x `max` y + x `max` y)
22:29:07 <lambdabot>   Not in scope: data constructor `Nonnegative'Not in scope: data constructor ...
22:29:15 <copumpkin> :(
22:29:51 <copumpkin> @check \x y z -> x >= 0 && y >= 0 && z >= 0 ==> x `max` (y + z) == (x `max` y + x `max` y)
22:29:52 <lambdabot>   Not in scope: `==>'Precedence parsing error
22:29:52 <lambdabot>      cannot mix `GHC.Classes.>=...
22:29:59 <copumpkin> @check \x y z -> (x >= 0 && y >= 0 && z >= 0) ==> x `max` (y + z) == (x `max` y + x `max` y)
22:30:00 <lambdabot>   Not in scope: `==>'
22:30:04 <copumpkin> meh
22:30:09 <Veinor> I don't know what that means but :(
22:30:34 <copumpkin> Veinor: I'm trying to get lambdabot to show me whether it's distritive
22:30:39 <copumpkin> distributive, even
22:30:55 <copumpkin> but lambdabot has an old version of quickcheck
22:30:57 <copumpkin> I think
22:31:09 <Veinor> Ah
22:31:17 <Veinor> (just smile and nod, Veinor)
22:31:29 <copumpkin> mmorrow: ohh
22:31:30 <copumpkin> *Main> using2 Max Plus (5 + (2 * 6)) :: Nonnegative Real
22:31:30 <copumpkin> Nonnegative 8.0
22:31:36 <copumpkin> that makes sense!
22:31:41 <copumpkin> (+) = max
22:31:48 <copumpkin> (*) = Prelude.+
22:31:55 <mmorrow> heh
22:32:18 * copumpkin beams and goes back to writing craploads of instances
22:34:54 <olsner> hmm, what's Max there? something of type Coalgebra f a? is that a fancy type family or something?
22:35:08 <copumpkin> newtype Max a = Max a deriving (Eq, Show)
22:37:28 <olsner> oh, so the type signature of using2 was something more like using2 :: Coalgebra f => Coalgebra s => f a -> s a -> WrapBimagma f s a -> a
22:37:54 <copumpkin> well Coalgebra is just a type synonym in category-extras
22:37:59 <copumpkin> for a -> f a
22:38:31 <olsner> ooh, of course... "Max" is a constructor yes
22:38:36 <copumpkin> yup
22:38:57 <copumpkin> so I'm just using that so I can explicitly say which binary operations I want (I didn't want to make a fundep between the operations and the set)
22:40:14 <copumpkin> so I can easily do
22:40:15 <copumpkin> *Main> using2 Max Times (5 + 2 * 6) :: Nonnegative Real
22:40:15 <copumpkin> Nonnegative 12.0
22:40:53 <c_wraith> I'm still unsure what set you're using, if the result is 12. :)
22:41:11 <copumpkin> well, + in that case is max
22:41:16 <copumpkin> and * is regular multiplication
22:41:18 <c_wraith> Oh
22:41:26 <c_wraith> ok, that makes more sense
22:41:31 <copumpkin> and before * was numeric addition
22:41:38 <copumpkin> so it was 5 `max` (2 + 6)
22:42:23 <c_wraith> So using2 creates a ring from two operations?
22:42:38 <copumpkin> well the ring is already there, as an instance
22:42:41 <copumpkin> a semiring actually in this case
22:42:52 <copumpkin> but because it's a pain, I need using2 to select which instance I want to use
22:42:54 <copumpkin> :P
22:55:41 <copumpkin> *Main> using2 Max Times (5 + 2 * 6 - 5) :: Nonnegative Real
22:55:41 <copumpkin> <interactive>:1:26:
22:55:41 <copumpkin>     No instance for (Ring Max Times (Nonnegative Real))
23:02:30 <olsner> copumpkin: you seem to be doing it wrong there :)
23:02:40 <copumpkin> how so?
23:03:01 <olsner> you got an error message!
23:03:05 <copumpkin> lol
23:03:12 <copumpkin> well there is no such ring
23:03:30 <copumpkin> :D
23:07:50 * copumpkin is still missing vector spaces :/
23:50:21 <cjs> Yeah, that 0.200s startup time for runhaskell sure is annoying.
23:50:29 <cjs> Bourne shell is 0.001s.
23:51:25 <cjs> Is there a library kicking around for writing awk-like scripts in Haskell?
23:52:25 <c_wraith> haskell is a heavy language, no way around it.  It requires a fair bit of runtime support for its memory management and lazy evaluation.
23:52:34 <copumpkin> well, ghc is
23:52:50 <copumpkin> compiled haskell programs aren't slow at starting up
23:52:52 <cjs> Hm. I wonder how long Hugs takes to start up?
23:52:58 <c_wraith> I suppose it's accurate that ghc is heavier than it needs to be...
23:53:10 <copumpkin> but if you want to get the whole compiler started up to run a short script, it's not ideal
23:53:43 <Berengal> ghc is no interpreter
23:54:00 <Berengal> But it can pretend to be, as long as it's not in an inner loop in bash
23:54:10 <vegai> runhaskell compiles the program before running, doesn't it?
23:54:19 <vegai> or is it just an interpreter...
23:54:41 <c_wraith> it's faster at startup than a full ghc compile cycle
23:55:13 <c_wraith> But I'm not aware of the details of its operation
23:55:20 <Berengal>  runhaskell and ghci are about the same, aren't they? The only difference being runhaskell isn't interactive and automatically calls main?
23:55:23 <copumpkin> okay, so my algebra library gets less pleasant to use when we move away from numbers :(
23:55:30 <cjs> I would expect it works like ghci, which doesn't do a full compile.
