00:07:08 <mmorrow> coCocoa: ping
00:07:32 <mmorrow> preflex: seen coCocoa
00:07:33 <preflex>  coCocoa was last seen on #haskell 1 day, 18 minutes and 16 seconds ago, saying: mmorrow: Does it GC with multiple "undisclosed locations"? ;)
00:08:24 * mmorrow wonders what coCocoa meant by that question (a joke?)
00:08:58 <mauke> the ";)" is a good hint, yes
00:09:43 <mmorrow> heh, true. but want to grok exactly what he meant by that (like, was he 50% joking, because he knows of some GC algo that handles some form of this?)
00:09:48 <mmorrow> *but i want ...
00:11:25 <ivanm> wmealing_: you can use vim
00:11:46 <ivanm> there are a couple of IDEs with haskell support (or one specifically for haskell), but AFAIK none of them are fully polished yet
00:11:52 <dainanaki> wmealing_: ghci is your friend
00:11:56 <ivanm> besides, most people here seem to use either vim or emacs
00:12:01 <mmorrow> (in case anyone is curious, that was in response to http://moonpatio.com/repos/Cheney.hs)
00:12:21 <dainanaki> not really an IDE, but Haskell doesn't seem to need one too much
00:12:38 <ivanm> mmorrow: as in the ex USA vice president?
00:12:38 <dainanaki> mmorrow, dead url?
00:12:43 * wmealing_ nods
00:12:45 <dainanaki> ah
00:12:50 <mmorrow> which is a (as a spec, not as one you'd use (although you could)) implems the Cheney GC algo
00:12:50 <dainanaki> misplaced )
00:12:53 <mmorrow> ah
00:12:58 <wmealing_> I think i'll stick to vim
00:13:02 <mmorrow> ivanm: deja vu!
00:13:10 <ivanm> heh
00:13:14 <wmealing_> was hoping to get some local knowledge , if one of the IDE's stood out in compared to the others
00:13:20 <jeffwheeler> wmealing_: I'd love to suggest Yi, but it's probably not very useful for learning
00:13:26 <jeffwheeler> (and it's always in flux)
00:14:21 <mmorrow> (although that module makes a point to make the locations at which Closures are allocated spaced out so that no two Closures would overlap if s/IntMap/real memory/, so it's pretty true to how you'd do it in C)
00:15:17 <mmorrow> (i.e., the only way you have to find the next Closure to scan is by adding the size of the closure you /just/ scanned to the free pointer)
00:15:27 <wmealing_> thanks all for your advice.
00:17:14 <mmorrow> the cheney algo is really elegant imo
00:17:47 <mmorrow> you don't need any stack (or heap) space
00:18:43 <mmorrow> (well, other than the heap(s) of the program that you're collecting for)
00:19:39 <mmorrow> (vacuum basically uses cheney)
00:21:28 <mmorrow> err, sorry not "is by adding the size of the closure you /just/ scanned to the free pointer)"
00:21:36 <mmorrow> "is by adding the size of the closure you /just/ scanned to the SCAN pointer)"
00:22:19 <mmorrow> the algo terminates when free==scan (which is the case when you begin, right before you copy the roots)
00:23:03 <mmorrow> (i dunno if this algo is described decently anywhere online... i had to buy a book to learn about it)
00:25:08 <mmorrow> (being http://www.amazon.com/Garbage-Collection-Algorithms-Automatic-Management/dp/0471941484/ref=sr_1_1?ie=UTF8&s=books&qid=1247037896&sr=8-1)
00:29:52 <Jedai> wmealing_: You could try leksah, apparently it's pretty good by now and is on the way to become even better
00:36:01 <thoughtpolice> mmorrow: cheney is pretty nifty
00:36:08 <thoughtpolice> mmorrow: and that's an excellent book :)
00:36:23 <mmorrow> yesh and yesh :)
00:37:51 <mmorrow> yeah, i think that book is definitely a must-have if you want to write GCs and don't already know about them
00:38:24 <dainanaki> @src liftM2
00:38:25 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:38:25 <Dae> is there a known bug in "Network"? I have programs that can run using run haskell, but I get the weirdest errors trying to compile
00:38:26 <thoughtpolice> pretty much
00:39:02 <Dae> like irc.o:fake:(.text+0x455): undefined reference to `networkzm2zi2zi1zi3_NetworkziS / ocket_zdf13_closure'
00:39:14 <dainanaki> @src ap
00:39:15 <lambdabot> ap = liftM2 id
00:39:21 <opqdonut> dainanaki: are you using --make
00:39:24 <opqdonut> woops
00:39:30 <opqdonut> Dae: that would be you
00:39:31 <Dae> happens on both fedora and windows 7
00:39:58 <mauke> preflex: zdec networkzm2zi2zi1zi3_NetworkziSocket_zdf13_closure
00:39:58 <preflex>  network-2.2.1.3_Network.Socket_$f13_closure
00:41:46 <Dae> took away a lot of them , but not all
00:41:56 <Dae> (Socket.o):fake:(.text+0xb014): undefined reference to `getnameinfo'
00:43:05 <Dae> but that's the only one left now
00:43:29 <mauke> what OS are you on?
00:43:39 <coCocoa> mmorrow: What do you think of the Inferno/9P-inspired VCGC paper? :)
00:43:42 <Dae> windows 7, crosschecking with fedora in a moment
00:44:04 <mmorrow> coCocoa: i haven't seen that one, but i'll check it out :)
00:44:33 <coCocoa> http://doc.cat-v.org/inferno/concurrent_gc/concurrent_gc.ps
00:45:04 <coCocoa> "For Your Consideration" :)
00:45:32 <mmorrow> ooh, concurrent
00:45:52 <Dae> ofcourse.... the new bug only happens on windows
00:46:42 <Cale> Pistahh: just reading over the backlog, it might be worth pointing out that when you install packages via cabal-install, the source code for them ends up in ~/.cabal/packages/hackage.haskell.org/<packagename>/<version>/ as a tarball. You can unpack it from there and then edit it and simply run cabal install from the source code directory to update your installation locally.
00:47:02 <Dae> so, I'll just add that to the "yet another haskell bug on windows" pile, blah
00:49:11 <mmorrow> coCocoa: cool, this looks interesting
00:49:34 <coCocoa> :)
00:50:34 <Peaker> jmcarthur: you there?
00:54:43 <Phillemann> Does anybody know if an ebuild for the darcs version of ghc exists?
00:55:46 <ivanm> Phillemann: there is one in the overlay
00:55:49 <ivanm> I doubt it works though
00:55:54 <ivanm> since we haven't touched it in ages
00:55:58 <kulakowski> What would be the most time efficient way to a) see if an Integer is a power of 2 and b) calculate that power of two?
00:56:05 <ivanm> btw, you should be asking for this in #gentoo-haskell ;-)
00:56:10 <kulakowski> calculate the exponent rather
00:56:29 <dibblego> kulakowski, hint: consider the bit representation of integers
00:56:32 <Phillemann> ivanm: Didn't know there was such a channel :>
00:56:56 <mauke> http://www-graphics.stanford.edu/~seander/bithacks.html
00:56:59 <dainanaki> So I was fiddling around with HLint, which has a nice set of basic rules for cleaning up code. Does anyone have other rules they use to clean things up? (i.e. reducing concat . map to concatMap)
00:57:36 <Pistahh> Cale: thanks
00:57:38 <dibblego> I think you mean  (concat .) . map
00:57:47 <Peaker> kulakowski: One efficient way would be   x /= 0 && (x .&. (x-1)) == 0   to see if it was a power of 2.  Then, you can use iLogBase like mine at: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6018#a6018
00:58:24 <dainanaki> dibbego, indeed i do
00:59:05 <Peaker> kulakowski: if you subtract 1, it basically turns off a single bit, and enables N bits.  so  (x .&. (x-1)) has 0 for all the enabled and disabled bits -- and 1 only for "untouched bits".  If there was more than 1 enabled bit, then bits will remain enabled in the result
00:59:12 <kulakowski> Peaker, dibblego, thanks...I'm mostly asking because I've never really had to fiddle with bits in haskell before
00:59:20 <Peaker> @type (.&.)
00:59:22 <lambdabot>     Ambiguous occurrence `.&.'
00:59:22 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
00:59:22 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
00:59:29 <Peaker> @type (.|.)
00:59:30 <lambdabot> forall a. (Bits a) => a -> a -> a
00:59:39 <Peaker> @type [(.|.), (.&.)]
00:59:40 <lambdabot>     Ambiguous occurrence `.&.'
00:59:40 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
00:59:40 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
00:59:48 <Peaker> oh, whoops, not a type ambiguity :)
01:00:07 <Peaker> dainanaki: I personally don't find "concatMap" any cleaner than concat . map
01:00:13 <mauke> @let (.^.) x = xor x
01:00:14 <lambdabot>  Defined.
01:00:26 <Peaker> mauke: why mention x there?
01:00:39 <mmorrow> @let x .<<. i = x `shiftL` i
01:00:41 <lambdabot>  Defined.
01:00:45 <mauke> Peaker: monomorphism restriction
01:00:46 <mmorrow> @let x .>>. i = x `shiftR` i
01:00:47 <lambdabot>  Defined.
01:00:50 <Peaker> mauke: oh
01:01:33 <hackagebot> texmath 0.1 - Conversion of LaTeX math formulas to MathML. (JohnMacFarlane)
01:01:48 <mmorrow> let pwd = getTheDirectoryThatTheProgramThisIsCurrentlyInIsIn
01:01:50 <mmorrow> ;)
01:02:12 <mmorrow> (and likewise for all of System.Directory :P)
01:02:33 <hackagebot> texmath 0.1.0.1 - Conversion of LaTeX math formulas to MathML. (JohnMacFarlane)
01:02:42 * Dae managed to get network working under windows, by sacrificing 2 goats and a shepherds pie
01:03:48 <coCocoa> mmorrow: Also, there is a pdf of that VCGC paper, in case you want to stash a copy on your moonpatio. ;)
01:05:35 * coCocoa goes to bed
01:05:50 <mmorrow> night
01:06:24 <kulakowski> Peaker and mauke, thanks. I have no idea how GHC represents Integers bigger than a machine int, so I had no idea doing it with bit fiddling would work
01:07:19 <Peaker> kulakowski: surely if the semantics of the bit-wise operations on Integer were defined to be similar to Int's, such fiddling should work.. :)
01:07:20 <mmorrow> kulakowski: it uses gmp by default
01:07:47 <mmorrow> kulakowski: (although gmp has efficient bit-level ops on these, ghc doesn't use those i believe)
01:07:57 <Peaker> not sure how to test which bit is on efficiently, iLogBase is not that efficient for that purpose, I'd guess
01:08:25 * mauke proposes a graphical representation of big integers whose library uses gimp instead of gmp
01:08:31 <Peaker> gmp probably could do it much more efficiently
01:08:38 <mmorrow> mauke: heh
01:09:11 <kulakowski> Peaker: that's not a problem, the Integers that actually are powers of two should be sparse, so it doesn't really matter how efficient it is.
01:09:36 <Peaker> kulakowski: you mean you don't usually have them?
01:10:00 <kulakowski> Peaker: Yes.
01:10:14 <quicksilver> mmorrow: can TH distinguish between a type which happens to have been declared using record syntax and one which doesn't?
01:10:22 <Peaker> ah
01:10:29 <mmorrow> quicksilver: yes, they have diff AST reps
01:10:38 <jeffwheeler> @hoogle getsAndModify
01:10:39 <lambdabot> No results found
01:10:44 <jeffwheeler> @hoogle getAndModify
01:10:45 <lambdabot> No results found
01:10:57 <quicksilver> jeffwheeler: you want lenses, or functional references.
01:11:06 <mmorrow> quicksilver: (you could for instance write a function that changes a rec/non-rec decl into the opposite)
01:11:27 <mmorrow> , src 'DataD
01:11:30 <jeffwheeler> quicksilver: I thought State had something like that builtin
01:11:30 <lunabot>  data Dec = ... | DataD Cxt Name ([Name]) ([Con]) ([Name]) | ...
01:11:30 <lunabot>  infixl 9
01:11:33 <mmorrow> , src 'Con
01:11:34 <lunabot>  luna: Not in scope: data constructor `Con'
01:11:40 <mmorrow> , src ''Con
01:11:41 <quicksilver> jeffwheeler: it can't, really
01:11:43 <lunabot>  data Con = NormalC Name ([StrictType])
01:11:43 <lunabot>           | RecC Name ([VarStrictType])
01:11:43 <lunabot>           | InfixC StrictType Name StrictType
01:11:46 <mmorrow> ..
01:11:46 <quicksilver> jeffwheeler: record fields aren't first class.
01:11:55 <quicksilver> jeffwheeler: check out Data.Accessor on hackage.
01:12:01 <mmorrow>   | ForallC [Name] Cxt Con
01:12:05 <mmorrow> (being the last one)
01:12:10 <jeffwheeler> quicksilver: oh, that might have been where I saw the function, then :)
01:12:57 <quicksilver> mmorrow: *nod*
01:13:48 <jeffwheeler> quicksilver: oh, I just tried writing it myself and see the problem
01:14:57 <quicksilver> jeffwheeler: a field name is only a selector, not a modifier
01:15:08 <quicksilver> jeffwheeler: a selector + a modifier bundled together is called a 'lens' or a 'functional reference'
01:15:16 <jeffwheeler> quicksilver: yeah, that makes sense
01:15:24 <quicksilver> jeffwheeler: it would have been better if field names were lenses than merely selectors :)
01:15:57 <jeffwheeler> ("Lenses" definitely need to be renamed, for searchability sake. ;) )
01:18:57 <quicksilver> jeffwheeler: there was a paper called "Functional programming with bananas, lenses, envelopes and barbed wire"
01:18:57 <Peaker> they're also called Accessors and Functional References?
01:18:57 <quicksilver> I still haven't read it.
01:19:08 <quicksilver> Peaker: I don't think they are really called accessors, are they? THat's just the name of the package on hackage.
01:19:09 <jeffwheeler> quicksilver: wonderful, thank you :)
01:19:15 <quicksilver> Accessor is a really stupid name :)
01:19:18 <Peaker> quicksilver: why?
01:19:30 <quicksilver> because sounds like a synonym for selector
01:19:49 <Peaker> I wonder if it is possible to have accessors whose types are as generalized as SECs
01:20:01 <Peaker> and if not, what is limited by it
01:20:02 <quicksilver> although apparently in C#, accessors are also mutators.
01:20:04 <quicksilver> C#--
01:20:19 <Dae> is there something along the lines of "repeatuntil" for moands? sort of like "forever" only not...well...forever
01:20:26 <Dae> *monads
01:20:51 <Peaker> Dae: I also need it a lot, so I have something like:   runMaybeT . forever $ ...   then you can use  MaybeT Nothing  to exit the computation
01:21:02 <Peaker> Dae: does mean you have to lift everything in your computation though
01:21:15 <Peaker> Can lambdabot please import Control.Monad.Maybe ?
01:21:22 <Peaker> Cale: you still in charge of lambdabot?
01:21:33 <Dae> hmm...doesn't seem very haskellish?
01:21:46 <Dae> but ok, guess it will do
01:22:02 <Dae> Thanks :)
01:22:04 <Peaker> Dae: if you alias runMaybeT . forever and the MaybeT Nothing, then I think it is very Haskellish (though imperative Haskell style)
01:22:05 <Saizan_> or you could write a whileM or so easily
01:22:26 <Peaker> Dae: if you want a while loop, whileM is often written too :)  The MaybeT approach allows breaking anywhere deep inside the computation
01:22:33 <mmorrow> @type let untilM p f a | p a = return a | otherwise = f a >>= untilM p f in untilM
01:22:35 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> Bool) -> (a -> m a) -> a -> m a
01:23:02 <mmorrow> > flip runCont id (callCC (\k -> forever (k 42)))
01:23:04 <lambdabot>   42
01:23:06 <Saizan_> Peaker: SECs?
01:23:07 <Dae> I guess I'm just surprised it's not already in haskell. USusually means I'm doing something I shouldn't be
01:23:16 <Dae> mmorrow: ohh, that looks very useful :)
01:23:17 <quicksilver> Peaker: see also the "Exit" monad
01:23:23 <quicksilver> Peaker: if you need to break with a return value.
01:23:26 <mmorrow> Dae: Cont is nice
01:23:29 <Peaker> @where SEC
01:23:29 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
01:23:35 <Peaker> Saizan_: these
01:23:43 <mmorrow> (or ContT if you're layering)
01:23:43 <Peaker> quicksilver: I'd call that EitherT ?
01:23:50 <quicksilver> Peaker: you could do, yes ;)
01:23:51 <Peaker> mmorrow: Layering?
01:24:07 <Peaker> mmorrow: ContT has too much power here :)
01:24:15 <mmorrow> err, whatever the term is for when you're using monad transformers
01:24:33 <Peaker> mmorrow: oh.  I don't think Cont should be used where Either/EitherT would do..
01:24:42 <mmorrow> Peaker: flies are no match for my sledgehammers!
01:24:58 <Saizan_> newtype ContT and export only abort :P
01:25:00 <kulakowski> Can all the bots talk in messages? I wanna play but not spam the channel.
01:25:12 <mmorrow> kulakowski: yes both
01:25:26 <Peaker> Saizan_: why not newtype EitherT then? :)
01:25:40 <mmorrow> (although you still need to prefix with >/, in msg)
01:25:56 <mmorrow> Peaker: because EitherT is boring :)
01:25:57 <Saizan_> Peaker: 1) you're not using the values in left 2) it's inefficient
01:26:04 <kulakowski> @pl thanks
01:26:05 <lambdabot> thanks
01:26:08 <Peaker> Saizan_: if you're not using Left, then MaybeT
01:26:31 <Peaker> Saizan_: Weird that ContT is more efficient than EitherT, given that the latter is so much more special-purpose
01:26:34 <mmorrow> Cont can return a value though
01:26:48 <Peaker> mmorrow: EitherT can too, what do you mean?
01:26:52 <mmorrow> rather than a (Left fixedType)
01:26:57 <jeffwheeler> @pl orderNext x = do modify $ \s -> s { ordering = (ordering s) ++ [order x] }
01:26:58 <lambdabot> (line 1, column 35):
01:26:58 <lambdabot> unexpected "{"
01:26:58 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
01:27:06 <mmorrow> (i was talking about MaybeT though in that case)
01:27:16 <Peaker> mmorrow: Cont's return type is fixed too, isn't it?
01:27:43 <mmorrow> Peaker: sure, like any type is "fixed", but not fixed by the monad
01:27:55 <mmorrow> fixed by the type of the subexpression
01:27:56 <Saizan_> mmorrow: it is fixed by the monad
01:28:14 <Saizan_> ContT r m, EitherT r m
01:28:21 <mmorrow> .......... callCC(\k -> ........ k 42 .........) .........
01:28:42 <Peaker> ..............              EitherT (Left 42)  ....................
01:28:46 <mmorrow> hmm, ok
01:28:47 <Saizan_> abort :: r -> ContT r m a
01:29:02 <mmorrow> i still say don't bother with EitherT though :)
01:29:12 <Saizan_> throwError :: r -> EitherT r m a
01:29:34 <mmorrow> , [$ty| jump |]
01:29:37 <lunabot>  forall a b c . ContM b => c -> Label b c -> b a
01:29:58 <mmorrow> Label is cool
01:30:04 <Peaker> Can EitherT be implemented in terms of ContT?
01:30:05 <mmorrow> , src ''Label
01:30:08 <lunabot>  newtype Label m a = Lab ((a, Label m a) -> m ())
01:30:11 <mmorrow> Peaker: easily
01:30:13 <Saizan_> Peaker: sure
01:30:18 <Peaker> Saizan_: then why is it less efficient?
01:30:28 <mmorrow> because of the bind implem
01:30:33 <Saizan_> Peaker: because they don't do things in the same way?
01:30:47 <Peaker> Saizan_: If EitherT is a thin layer above ContT - they can, can't they?
01:31:14 <mmorrow> @src Cont (>>=)
01:31:14 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
01:31:23 <Saizan_> Peaker: but EitherT isn't a layer above ContT, i don't get what you're trying to say..
01:31:23 <mmorrow> @src (Either a) (>>=)
01:31:24 <lambdabot> Source not found. There are some things that I just don't know.
01:31:38 <Peaker> Saizan_: EitherT doesn't exist in the stdlib, afaik, you could implement it as such?
01:32:03 <quicksilver> EitherT can be implemented using ContT, yes
01:32:03 <mmorrow> Peaker: Cont doesn't have to check for "Left" in every (>>=)
01:32:08 <quicksilver> it's a restricted case.
01:32:12 <mmorrow> it just calls the continuation
01:32:31 <mmorrow> which may happen to just return a result and abort the rest
01:32:42 <Saizan_> if by EitherT you mean a monad transformer that can throw and catch errors, then yes
01:32:58 <Peaker> mmorrow: I guess that holds true for ContT vs EitherT,  is this also true for Cont vs Either?  I mean:  Left x >>= _ = Left x, so the entire computation in _ doesn't check for more lefts, only "outer" computations this was buried in
01:33:23 <mmorrow> Peaker: but Cont doesn't need to pattern match at all in (>>=)
01:33:24 <Peaker> mmorrow: I guess if the >>= was built up left-associatively, you're screwed with Either, and if it was right-associative then its ok
01:33:43 <Saizan_> and Cont reassociates to the right.
01:34:03 <Saizan_> Cont is like a way to implement fusion for >>=
01:34:26 <Saizan_> which might be good or not, depending on what you're trying to do
01:34:32 <Peaker> cool.. I'll write myself an EitherT over ContT, and MaybeT over EitherT :)
01:34:36 <mmorrow> @djinn-add type Cont o a = (a -> o) -> o
01:34:43 <Peaker> Saizan_: when isn't it good?
01:34:51 <mmorrow> @djinn Cont o a -> (a -> Cont o b) -> Cont o b
01:34:51 <lambdabot> f a b c = a (\ d -> b d c)
01:35:05 <Peaker> @djinn Cont o (Cont o a) -> Cont o a
01:35:05 <lambdabot> f a b = a (\ c -> c b)
01:35:09 <mmorrow> @. pl djinn Cont o a -> (a -> Cont o b) -> Cont o b
01:35:09 <lambdabot> f = (. flip) . (.)
01:35:31 <mmorrow> djinn gets callCC,shift, and reset right too :)
01:35:36 <Peaker> cool :)
01:35:45 <Peaker> what are shift and reset?
01:35:50 <mmorrow> @djinn ((a -> Cont o b) -> Cont o a) -> Cont o a
01:35:51 <lambdabot> f a b = a (\ c _ -> b c) b
01:35:58 <Peaker> @hoogle shift
01:35:59 <lambdabot> Data.Bits shift :: Bits a => a -> Int -> a
01:35:59 <lambdabot> Data.Bits shiftL :: Bits a => a -> Int -> a
01:35:59 <lambdabot> Data.Bits shiftR :: Bits a => a -> Int -> a
01:36:25 <Peaker> @hoogle reset
01:36:26 <lambdabot> Text.ParserCombinators.ReadPrec reset :: ReadPrec a -> ReadPrec a
01:36:26 <lambdabot> Text.XHtml.Frameset reset :: String -> String -> Html
01:36:26 <lambdabot> Text.XHtml.Strict reset :: String -> String -> Html
01:36:37 <mmorrow> @djinn ((a -> Cont x o) -> Cont o o) -> Cont o a
01:36:38 <lambdabot> f a b = a (\ c d -> d (b c)) (\ e -> e)
01:36:41 <Saizan_> Peaker: it mostly applies to ContT, if the base monad is Set, reassociating on the right prevents pruning of duplicates until the end
01:36:53 <mmorrow> @djinn Cont a a -> Cont o a
01:36:54 <lambdabot> f a b = b (a (\ c -> c))
01:37:49 <Peaker> Saizan_: a bit mind boggling for me to think about ContT with list/set, yet :)
01:37:52 <Saizan_> i still don't know if there's something like ContT that reassociates on the left :)
01:38:26 <mmorrow> @let callcc f k = f (\a _ -> k a) k
01:38:27 <lambdabot>  Defined.
01:39:25 <Saizan_> Peaker: i'm not talking about doing anything special with the continuations (no callCC, control, shift, reset..)
01:39:48 <mmorrow> oh noes, did i mess up callcc
01:40:01 <mmorrow> ok n/m
01:40:25 <Saizan_> in fact one uses Codensity m a = Codensity { runCodensity :: forall r. ContT r m a }
01:42:15 <Saizan_> (but to implement Either directly with Cont you do need to play with the continuations)
01:44:29 <Saizan_> actually, can you implement catchError with just Cont r a?
01:49:34 <Peaker> @hoogle RMonad
01:49:35 <lambdabot> package rmonad
01:51:03 <etpace_> > ((-1) . fst) $ (5, 3)
01:51:04 <lambdabot>   No instance for (GHC.Num.Num (a -> c))
01:51:05 <lambdabot>    arising from a use of syntactic n...
01:51:19 <Peaker> Why is Writer not called Appender?
01:51:25 <etpace_> > ((\x -> x - 1) . fst) $ (5, 3)
01:51:26 <lambdabot>   4
01:51:31 <ivanm> Peaker: historical reasons?
01:51:34 <etpace_> is there a way I can do that without lambdas?
01:51:38 <ivanm> because you "write" to a log?
01:51:42 <Peaker> it creates a sense of false symmetry
01:51:46 <ivanm> etpace_: subtract 1 . fst
01:51:49 <ivanm> or pred . fst
01:51:57 <ivanm> Peaker: you mean reader vs writer?
01:52:01 <Peaker> ivanm: yeah
02:00:22 <Saizan_> Peaker: btw, what i was trying to say the other day is that with ContMaybe a = forall o. o -> (a -> o) -> o, you get fmap fusion for free
02:01:02 <Peaker> Saizan_: other day as in a few minutes ago? :)
02:01:31 <Saizan_> Peaker: no, i remember a similar discussion a few days ago :)
02:01:38 <Peaker> oh ;)
02:02:07 <Saizan_> (and by fmap fusion i mean fmap f . fmap g = fmap (f . g))
02:07:30 <portnov> :t first
02:07:31 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
02:08:12 <portnov> > first (subtract 1) (5,3)
02:08:13 <lambdabot>   (4,3)
02:08:14 <Peaker> :t (first, fst)
02:08:16 <lambdabot> forall (a :: * -> * -> *) b c d a1 b1. (Arrow a) => (a b c -> a (b, d) (c, d), (a1, b1) -> a1)
02:08:40 <Peaker> can these two be composed similarly to how first can be composed?
02:09:08 <portnov> > fst $ first (subtract 1) (5,3)
02:09:09 <lambdabot>   4
02:12:08 <eflister> hi -- noob question -- i'd like to make a type that generalizes over lists and scalars.  so that "map f x" would be legal whether x is a list or not.
02:12:45 <mauke> that's sort of a problem because lists are scalars
02:13:12 <eflister> i was trying to copy the Maybe pattern -- "data Vectorizable a = Scalar a | Vector [a]"
02:13:18 <portnov> you can declare instance Num a => Num [a]
02:13:34 <quicksilver> eflister: that is a reasonable start, yes.
02:13:34 <Peaker> eflister: look at fmap
02:18:51 <Peaker> Hmm.. Can't RMonad be considered a Monad transformer, with lift = embed ?
02:19:49 <Peaker> I guess not, because the inner "monad" is not a Monad
02:20:06 <kulakowski> I want to emulate the state of a machine that has n counters. There's some finite ordered list of rules that say to add or subtract values to some of the counters at each step. At each step, it selects the first rule such that it can perform it without having to reduce any counter below zero. What I'm really not sure is what would be the most 'elegant' way to type this
02:21:07 <Peaker> unEmbed $ do { x <- embed $ Data.Set.fromList [1,2,3] ; embed . Data.Set.fromList $ [x,x*3] }   <-- very Monad-transformerish feel
02:21:20 <Peaker> oops, two different forms of . and $ in the same do :)
02:21:54 <Peaker> kulakowski: How does a rule look like?
02:23:00 <Peaker> type MachineState = [Integer] ; RedaerT Rules (StateT MachineState) is one possible way, I think
02:23:14 <kulakowski> I guess a list of just an int saying how much each counter would be changed.
02:23:30 <kulakowski> ok I'll look at that
02:23:35 <Saizan_> i think i'd use StateT [Integer] Maybe
02:24:34 <Saizan_> so that step = msum . map (>> guardNonZero) $ [rule1,rule2,..]
02:24:46 <Saizan_> where each rulei modifies the state
02:25:53 <Saizan_> guardNonZero = do xs <- get; guard (all (>= 0) xs)
02:26:03 <Saizan_> so the name is not right :)
02:27:24 <mxc> is there anyway to have cabal call an external program during building?  say, ant build..
02:28:06 <dcoutts> mxc: with a custom Setup.hs, yes
02:28:16 <mxc> ty
02:28:35 <Saizan_> remember to use build-type: Custom in the .cabal file
02:28:54 <Peaker> guardNoneZero
02:29:04 <Peaker> Saizan_: just a typo :)
02:29:12 <Saizan_> orBelow :)
02:29:29 <Peaker> guardAllPositive
02:29:31 <Peaker> also (>0) then
02:30:12 <Saizan_> the check was right, so it's guardNoneBelowZero, /me feels silly
02:30:20 <kulakowski> naming things is hard
02:30:25 <Peaker> maybe this first:  guardState p = get >>= guard . p
02:30:32 <ivanm> kulakowski: so let's go shopping? :p
02:30:42 <kulakowski> lets
02:30:51 <Peaker> Saizan_: s/BelowZero/Negative ?
02:31:26 <Peaker> @type \p -> guard . p <<= Data.State.get
02:31:28 <lambdabot> Couldn't find qualified module.
02:31:32 <Peaker> @type \p -> guard . p <<= Control.Monad.State.get
02:31:34 <lambdabot> Not in scope: `<<='
02:31:39 <Peaker> @type \p -> guard . p =<< Control.Monad.State.get
02:31:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, MonadState a m) => (a -> Bool) -> m ()
02:31:58 <Peaker> then, guardState (all (>=0))
02:34:59 <maartenm> can I make ghci dynamically load my modules, the way Hugs did?
02:35:09 <maartenm> when I change a module, I have to reload it manually
02:35:33 <Gracenotes> well, there is ':reload' for that... hmm
02:35:49 <maartenm> ok.. if that's the best I can get :)
02:38:58 <Gracenotes> hm. *thinks*
02:40:30 <Gracenotes> a solution might entail editing ~/.ghci to automatically reload (essentially a Haskell script)
02:41:11 <Gracenotes> this might range from simple periodic checks on the file handle's modification time to hooking up with inotify, if you're on Linux; http://en.wikipedia.org/wiki/Inotify
02:41:29 <Gracenotes> (via the FFI)
02:42:13 <maartenm> ok, thanks
02:42:18 <maartenm> I think I'll stick with :r
02:42:21 <Gracenotes> but.. usually :reload works for me. If there are any complicated bugs you know that you triggered them by a particular change
02:42:26 <Gracenotes> okay
02:42:37 <maartenm> it's the only thing I miss from Hugs
02:43:50 <maartenm> I don't understand something
02:44:15 <maartenm> I have a file help.hs, which has: "module EulerHelp where" and then a list of function definitions
02:44:35 <maartenm> in a file euler21.hs that resides in the same directory, I do: "import EulerHelp"
02:44:44 <maartenm> and yet, ghci cannot find the module
02:45:40 <doserj> maartenm: name the file after the module name
02:45:55 <maartenm> but, in A Gentle Introduction to Haksell, it says:
02:46:07 <maartenm> "There is no formal connection between a Haskell module and the file system that would (typically) support it. In particular, there is no connection between module names and file names..."
02:47:43 <doserj> "Of course, a particular implementation will most likely adopt conventions...", and ghc has adopted that it searches for modules in files named after them
02:47:56 <maartenm> ah, ok
02:50:46 <eflister> Peaker: (et al) - thx, i am trying to understand fmap
02:51:05 <eflister> Peaker: (et al)  - so far i have this:
02:51:15 <eflister> data Vectorizable a = Scalar a | Vector [a]
02:51:15 <eflister> 	deriving(Show)
02:51:15 <eflister> instance Functor Vectorizable where
02:51:16 <eflister>   fmap f (Scalar x) = Scalar (f x)
02:51:16 <eflister>   fmap f (Vector x) = Vector (map f x)
02:52:07 <eflister> and that lets me do things like "map signum (Scalar 3)" and "map signum (Vector [3,-1,5])"
02:52:48 <eflister> but i cannot prevent someone from constructing (Scalar [3,-1,5])
02:53:28 <eflister> and "map signum (Scalar [3, -1, 5])" gives an error i don't understand
02:53:55 <Saizan_> you mean fmap signum (Scalar [3,-1,5])?
02:54:25 <eflister> ah yes, sorry
02:54:31 <Peaker> eflister: you shouldn't have "fmap" penetrate an arbitrary amount of types. If you want to penetrate two Functors (Your Vectorizable, and a contained list type), you should use (fmap . fmap) instead of fmap
02:55:06 <Saizan_> Peaker: that's the only possible instance of Functor for Vectorizable, actually
02:55:55 <eflister> Peaker: sorry, i don't get what you mean?
02:56:16 <Peaker> eflister: if you have   Vectorizable [Int]  -- what do you want fmap to do?   apply a function to the [Int], or to each Int?
02:56:53 <eflister> Peaker: each Int
02:56:56 <Peaker> eflister: you can use   fmap (++ [1,2,3])    to do the former.  Or    fmap (map (*2))   to do the latter.  The latter can also be written as   (fmap . map) (*2)
02:57:05 <opqdonut> eflister: Scalar [1,2,3] is of type Vectorizable [Int], so the corresponding Vector constructor would take type [[Int]] as an argument
02:58:27 <Peaker> eflister: applying a function inside a value rather than on the value itself, is called "lifting" or "penetrating" the value with a function.  If you want to "penetrate" a Functor, you use fmap.  If you want to penetrate 2 functors, you use   fmap . fmap
02:58:30 <Peaker> @where SEC
02:58:30 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
02:58:40 <Peaker> eflister: try to read this, it talks about this issue ^^
02:59:10 <kowey> I intend to announce this http://www.haskell.org/haskellwiki/Hac7 on the haskell@ mailing list
02:59:12 <kowey> any last minute tips?
02:59:59 <kowey> (I figure that Hac Phi is really Hac 6, so the Haskell Hack Day should call itself Hac7... just be glad I didn't decide to call it Hacgis)
03:00:11 <doserj> kowey: Edinbrugh is spelled Edinburgh, I think :)
03:00:27 <Ferdirand> would it make sense to have something like instance (Functor f1, Functor f2) => Functor (f1 f2) ?
03:00:30 <kowey> yikes, thanks :-)
03:00:46 <`Zerax`> Don't want to annoy the Scots ;)
03:00:49 <ivanm> doserj: well, usually, anyway ;-)
03:01:02 <Saizan_> Ferdirand: Functor (f1 . f2)
03:01:15 <Peaker> Ferdirand: that can't work, if f1 is Functor, then its (* -> *), and cannot be given (* -> *) as an argument
03:02:09 <Peaker> @hoogle TypeCompose
03:02:10 <lambdabot> package TypeCompose
03:02:54 <idnar> instance (Functor f1, Functor f2) => Functor (f1 (f2 a)) ?
03:03:11 <Peaker> idnar: can't mention the a there
03:03:20 <Saizan_> idnar: (f1 (f2 a)) :: * instead of * -> *
03:03:25 <idnar> oh, doh
03:03:26 <Peaker> conal's TypeCompose has   newtype (:.) g f a = O {unO :: g (f a)}
03:04:22 <eflister> Peaker: (et al) - ok i tried to read that but it was above me.  :)  i think what i'm trying to do is simple -- give myself a way to write any function that expects a list to also accept a non-list in its place (and just realize it should make a one-element list out of it before operating).
03:05:04 <Peaker> eflister: why not distinguish the cases in your API?
03:05:12 <Peaker> eflister: why shouldn't the user wrap his single element in a single-item list?
03:05:26 <eflister> Peaker: i'd like to relieve him of having to care
03:05:38 <Ferdirand> Peaker: thanks, will look at TypeCompose. more cerebral masturbation for me, whee :)
03:06:24 <Peaker> Ferdirand: you can have  instance (Functor f1, Functor f2) => Functor (f1 :. f2)   as Saizan_ mentioned
03:07:04 <Peaker> inO = (O .).(. unO)
03:07:10 <Peaker> fmap = inO (fmap . fmap)   I think
03:08:04 <Peaker> oops: fmap f = inO ((fmap . fmap) f)
03:08:41 <Peaker> Prelude Control.Compose> :t \f -> inO ((fmap . fmap) f)
03:08:41 <Peaker>   :: (Functor f, Functor f1) => (a -> b) -> (:.) f f1 a -> (:.) f f1 b
03:09:06 <Peaker> @pl \f -> inO ((fmap . fmap) f)
03:09:07 <lambdabot> inO . fmap . fmap
03:09:09 <eflister> Peaker: it's a feature in other (dynamically typed) languages that i'm used to, and seemed like a good exercise in learning haskell, since it's all about abstract typing.  are those inO posts related to this conv?
03:09:10 <Peaker> ;-)
03:09:22 <Peaker> eflister: even in dynamically-typed languages like Python it is very discouraged
03:09:30 <maartenm> what's "nop" in haskell?
03:09:30 <Peaker> eflister: no, those are about Ferdirand's question
03:09:51 <maartenm> suppose I want to do map (function) list   where function = if .. then nop else (+)
03:10:02 <Peaker> eflister: You could just use a Data.Tree and flatten it before use, but that's silly
03:10:27 <mmorrow> @type \b f -> if b then id else f
03:10:28 <lambdabot> forall a. Bool -> (a -> a) -> a -> a
03:10:39 <Peaker> eflister: In Python and Haskell both, it is very difficult to know if an element given is supposed to be a "container" or a "scalar".  Those things are not very well defined, who's to say that tomorrow you won't want to re-use your code with some values that happen to be containers?
03:11:37 <mmorrow> maartenm: if the function is (+), you'll need (const id)
03:11:43 <eflister> Peaker: well, i'm (embarrassingly) mainly thinking of matlab, where scalars ARE just 1-element vectors, so you can always do anything to them that you would have done to a vector.
03:12:11 <mmorrow> err, actually that doesn't make sense if the "f" is (+)
03:12:22 <Peaker> eflister: you can reduce this problem to the creation side of the "scalars" by having those that create them simply wrap them in a 1-element list
03:12:35 <mmorrow> maartenm: what context would you use that expression you gave?
03:12:41 <mmorrow> *in what ..
03:12:55 <mmorrow> function = if .. then nop else (+)
03:13:14 <mmorrow> because the only thing that it makes sense for nop to be there is undefined
03:13:21 <mmorrow> i.e. "end my program immediately"
03:13:22 <maartenm> well, in my case I'm calculating the divisors of a number by examinging 1..sqrt(n)
03:13:45 <mmorrow> so the ".." test would be testinggg if you wanted to crash in that case
03:13:52 <mmorrow> s/ggg/g/ :)
03:14:03 <hackagebot> applicative-extras 0.1.5 - Instances for Applicative (ChrisEidhof)
03:14:05 <maartenm> but in the case of a square number, I need to remove one element of that list (the last one)
03:14:05 <ivanm> oh, I thought it was deliberate ;-)
03:14:26 <maartenm> and then do map (div n) (smallDivisors) to get the other divisors
03:14:28 <eflister> Peaker: yeah, but that's not paradigmatic, and moves the burden to clients of my api, where i'd like my api to abstract the difference.  re: the ambiguity you brought up, i just mean "if it's not a list, wrap it in a list" -- no ambiguity.
03:14:35 <maartenm> I wanted to put that operation on smallDivisors in a where clause
03:14:38 <mmorrow> maartenm: what's your test for isSquare ?
03:15:01 <mmorrow> maybe something like
03:15:04 <hackagebot> persistent-map 0.1.1 - A thread-safe interface for finite map types with optional persistency support. (PeterRobinson)
03:15:12 <Peaker> eflister: It is ambiguous, because then how do you distinguish whether your user wanted [a] or [[a]] ?
03:15:15 <maartenm> (div n isqrt(n) == isqrt(n))...
03:15:23 <maartenm> I just wanted to see if it was possible
03:15:28 <maartenm> and got into the 'nop' path
03:15:38 <maartenm> so I wanted to ask you how you do stuff like that
03:15:47 <mmorrow> @type let isqrt = round . sqrt . fromIntegral in \x -> takeWhile (< x) [1..isqrt x]
03:15:49 <lambdabot> forall a. (Integral a) => a -> [a]
03:15:57 <maartenm> you postpone the transformation of the list in a where clause.. but sometimes the transformation doesn't do anything
03:16:05 <eflister> Peaker: the api contract is "you can pass me a list of things, or if you pass me one thing i'll treat it as a list of one thing"
03:16:05 <maartenm> and I was wondering how you would define the 'nop' transformation
03:16:17 <mmorrow> maartenm: ah, that would be `id'
03:16:25 <Peaker> eflister: but again, there can be lists of lists of lists of thing, so a list is both a "list of things" and a "one thing" -- that's where the ambiguity lies
03:16:26 <maartenm> ok
03:16:40 <maartenm> works for anything?
03:16:45 <mmorrow> (but id only operates on one item, so the fact you had (+) as the result of the "else" case confused me)
03:16:46 <maartenm> I mean, not jsut for numbers
03:16:51 <mmorrow> , id id id id
03:16:51 <maartenm> yeah, sorry
03:16:52 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a))
03:16:59 <Peaker> eflister: if you always consider a list of things as the former, and never as a "one thing" then your API becomes limited and cannot apply in various interesting situations
03:17:05 <maartenm> you type everything four times today
03:17:08 <maartenm> that's very odd
03:17:14 <mmorrow> maartenm: heh
03:17:39 <eflister> Peaker: yeah but it's not ambiguous to decide whether something is a list.  the rule is IF you are a list, i will not wrap you, otherwise i will.
03:17:58 <Peaker> eflister: You can have that rule - it will make for a bad/limited API
03:18:24 <Peaker> eflister: you can have a type-class, make an instance for a list, and for everything else (You might need undecideable instances, and you'll probably need overlapping instances)
03:18:53 <quicksilver> that wouldn't be haskell though ;)
03:19:12 <eflister> Peaker: i see what you're saying -- but now i'm just interested in the learning exercise of trying to replicate the matlab behavior in haskell -- surely it must be possible.
03:21:08 <eflister> Peaker: a main application in matlab is indexing.  if X is a vector, then you want to be able to extract elements with X(E) where E can be either a vector of indices or a scalar index.
03:22:08 <eflister> Peaker: actually E can be a multidimensional array, and its shape determines the shape of the result.
03:22:36 <maartenm> morrow: I assume this can be written like, 8 times shorter? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6675#a6675
03:25:36 <eflister> Peaker:  ok i tried this --
03:25:37 <eflister> class Vectorable a where
03:25:37 <eflister> 	vectorize         :: a -> b
03:25:38 <eflister> 	vectorize a@(_:_) = a
03:25:38 <eflister> 	vectorize a       = [a]
03:26:02 <eflister> Peaker: but that gets this error: Occurs check: cannot construct the infinite type: a = [a]
03:26:15 <Peaker> eflister: please use a pastebin..   You probably need a multi-param class here, because you can't have  Vectorizable a => a -> b      -- that type is impossible
03:27:07 <Beelsebob> eflister: that's because your first rule for vectorize says "you should leave any list you get alone"
03:27:13 <Peaker> eflister: class Vectorize a b where vectorize :: a -> b   ;  instance Vectorize [a] [a] where vectorize = id ; instance Vectorize a [a] where vectorize x = [x]
03:27:22 <Beelsebob> and your second rule (which only applies to the empty list) says "you should put the list in a list"
03:27:41 <Beelsebob> so it's trying to match [a] for the first one, against [[a]] for the second one as the result type
03:28:15 <eflister> Beelsebob: the first rule is FOR leaving lists alone, and the second one is for wrapping non-lists
03:28:27 <Beelsebob> Peaker: also, that one's clearer with an asociated type -- class Vectorize a where type Vector a; vectorize :: a -> Vector a
03:28:40 <Peaker> eflister: the default implementation you gave of vectorize there takes a list as an arg, so the type is not a -> b anyway, its [a] -> a  and [a] -> [[a]]   in your two pattern matches
03:28:43 <Beelsebob> eflister: so they have different types
03:28:48 <Beelsebob> and hence should be in different instances
03:28:50 <Peaker> Beelsebob: yeah
03:29:21 <Peaker> Beelsebob: Hey, conal has VectorSpace class which is very much like this :)
03:29:28 <Beelsebob> indeed he does :)
03:29:43 <Beelsebob> VectorSpace is a massively underrated package
03:29:56 <Peaker> except its vector size is allowed to be fixed and not necessarily allow just 1 element
03:31:49 <Peaker> eflister: class Vector v where type Scalar v ; vectorize :: Scalar v -> v         though note that given just a Scalar, ghc won't know which kind of vector you want to form of it
03:32:28 <Peaker> eflister: you can have the reverse,  class Scalar s where type Vector s ; vectorize :: s -> Vector s    but then its fixed for lists
03:32:37 <Peaker> (or whatever you choose for each scalar type)
03:33:47 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6677#a6677   how can I rewrite the euler21 function so the list does not have to be repeated?
03:33:51 <Peaker> eflister: type-class hackery may be a bad place for a beginner to start with, though
03:33:54 <maartenm> I basically want a copy of the list to use in the fitler
03:34:22 <Peaker> maartenm: "copy of" a pure value has little meaning in Haskell -- there's no way to distinguish
03:34:46 <Peaker> @src print
03:34:47 <lambdabot> print x = putStrLn (show x)
03:34:53 <Beelsebob> maartenm: if you mean you want the lists to be shared, at a where clause
03:34:55 <opqdonut> maartenm: why do you even need that list in isAmicable
03:35:05 <opqdonut> the only thing you check is elem sn l
03:35:06 <Peaker> maartenm: your   putStr . show    there should probably be print
03:35:15 <opqdonut> ah, nvm
03:35:31 <maartenm> yeah the sn needs to be in the list, not out of it
03:35:42 <Beelsebob> maartenm: euler21 = sum $ filter (isAmicable l) l where l == [1..10000]
03:35:45 <maartenm> I just wonder how I can do this more elegantly
03:35:47 <Beelsebob> oops, minus an =
03:35:51 <maartenm> ok
03:36:03 <maartenm> of course
03:36:06 <maartenm> sorry, thanks
03:36:11 <eflister> Peaker, Beelsebob: thx -- i'll look into VectorSpace.  what does a type inside a class mean?  i've got a project working that is pretty first-order, and this question was where it naturally led me to next...
03:36:53 <opqdonut> maartenm: you realize that "elem sn l" has horrible performance compared to, say "sn > a && sn < b"
03:36:53 <Beelsebob> eflister: it means "every time you write an instance of this class for a type a, you need to provide another type Vector a which is the type vectorize is going to return"
03:37:10 <opqdonut> maartenm: as l only contains consequent integers
03:37:34 <opqdonut> maartenm: or do you want to recursively refer to the filtered result list?
03:37:40 <Peaker> eflister: for every instance of Vector -- e.g: [Int]  there's exactly one Scalar type, e.g: Int in this case
03:37:44 <Beelsebob> eflister: an instance might look like instance Scalar Int where type Vector = [Int]; vectorize = (:[])
03:39:12 <maartenm> no, you're right
03:39:14 <maartenm> I didn't know that
03:39:23 <maartenm> I thought haskell was clever enough to know it is an ordered list
03:39:38 <maartenm> I mean, that it contains all Ints between the boundaries
03:39:38 <opqdonut> even if it were ordered
03:39:47 <opqdonut> no, haskell is not that smart
03:40:16 * Beelsebob ponders encoding orderedness into the type system
03:40:25 <maartenm> is there a shortcut in prelude for sn > a && sn < b  ?
03:40:48 <maartenm> like, to compare a number to a range of integers and determines its place among (or outside) them?
03:41:10 <quicksilver> no.
03:41:29 <quicksilver> (>a) <^(&&)^> (<b) isn't a shortcut ;)
03:41:35 <quicksilver> (or in the prelude)
03:41:36 <maartenm> groovy
03:41:37 <Saizan_> ?type inRange
03:41:39 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
03:41:45 <quicksilver> it does look like an exotic japanese smiley though
03:41:46 <maartenm> ?index inRange
03:41:46 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
03:41:50 <Beelsebob> quicksilver: lol
03:41:57 <Beelsebob> I wasn't even gonna say it
03:41:58 <Beelsebob> :P
03:42:10 <Beelsebob> but yeh, nice smily
03:43:13 <Cale> Cheerful, got a dish of ra-men in the face smiley, with sideways cat ears
03:43:31 <opqdonut> :D
03:46:00 <lilac> Cale: do you mind me uploading your MonadSupply from the wiki onto hackage?
03:46:15 <p_l> btw, is there any european Haskell-related meetings in summer?
03:47:40 <Cale> lilac: not at all
03:48:41 <Saizan_> p_l: AngloHaskell
03:49:10 <p_l> Saizan_: oh, something in UK? :)
03:49:52 <Saizan_> p_l: yup, it's on the haskellwiki
03:50:41 <lilac> Cale: BSD3 license OK with you?
03:50:47 <Cale> yep
03:51:13 <paper_cc> Can this be written so that it is subject to fusion? adjacent xs = zip xs (tail xs ++ [last xs])
03:51:22 <p_l> Saizan_: I noticed that all events seem to be centered around Edinburgh... just my luck to move to Coventry for the summer ^^;
03:52:32 <Saizan_> p_l: well, that's because of the ICFP, AngloHaskell is earlier in August and near London, afaik
03:53:16 <p_l> I'll have to check
03:54:09 <p_l> ... I find it ironic how the wikipage has Google Maps directions to Microsoft Research
03:55:47 * Dae completely fails using Cont with stuff that isn't IO, and goes on trying to find a new way to do his "while" loop
03:57:45 <idnar> @type (<^)
03:57:47 <lambdabot> Not in scope: `<^'
03:57:57 <idnar> what are <^ ^>?
03:58:23 <lilac> idnar: they're <$> and <*> in disguise
03:58:45 <mbz> @src (<^)
03:58:45 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:58:46 <lilac> x <^ (*) ^> y = (*) <$> x <*> y
03:59:10 <Vanadium> ^^ vv << >> b a
03:59:11 <Vanadium> >:[
03:59:12 <idnar> ah yes
03:59:13 <lilac> so (<^) = flip (<$>) and (^>) = (<*>)
04:02:26 <paper_cc> @hackage InfixApplicative
04:02:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/InfixApplicative
04:13:36 <PeakerWork> is (>>) left or right associative?
04:14:17 <Saizan_> @hoogle (>>)
04:14:18 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
04:14:18 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
04:14:18 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
04:15:17 <fasta> I made some changes to the devIL library, s.t. it is initialized only once now (verified by adding a putStrLn in the code path which does the initialization). However, repeatedly running a function in ghci returns a different result from run to run then just executing it once in ghc.
04:19:59 <quicksilver> sounds like it uses global (C-side) state in some other ways?
04:25:40 <maartenm> why is this so slow? : http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6682#a6682
04:25:59 <maartenm> aside from any analytical shortcuts, is something being calculated redundantly?
04:26:28 <lilac> maartenm: `elem` is probably the problem
04:26:32 <maartenm> really
04:26:56 <maartenm> can I speed up elem if it realizes it has an ordered list?
04:26:58 <lilac> x `elem` xs is O(length xs)
04:27:01 <maartenm> is that the reason it performs badly?
04:27:10 <lilac> you could use Data.Set instead of a list
04:27:12 <maartenm> because it shouldn;t look beyond n > x, when looking for x
04:27:20 <quicksilver> it doesn't know the list is ordered.
04:27:34 <maartenm> is there a more aware elem?
04:27:48 <lilac> you could use Data.Set instead of a list
04:27:51 <maartenm> and Data.Set is binary search, or nto?
04:27:54 <PeakerWork> @info (>>)
04:27:55 <lambdabot> (>>)
04:28:04 <quicksilver> maartenm: yes.
04:28:09 <maartenm> do I really need a set for this simple problem?
04:28:09 <lilac> maartenm: yes, it's a binary search. so it'd be O(log (length xs))
04:28:20 <PeakerWork> infixl 1
04:28:41 <maartenm> ok I'll try Data.Set ..
04:28:50 <PeakerWork> infixl is a pretty poor choice isn't it?  For the Maybe/Either monads, at least
04:29:08 <PeakerWork> for IO too, depending on how exceptions are implemented there
04:29:40 <lilac> maartenm: you might also want 'asTwoAbundants = any (...) (takeWhile (<n) abundants)
04:29:59 <maartenm> and takeWhile is ordered-aware?
04:30:01 <lilac> maartenm: since there's no point scanning the ones where n - x <= 0
04:30:11 <maartenm> or it breaks after the first encoutner
04:30:11 <maartenm> ok
04:30:17 <maartenm> that's what I'd need, yes
04:30:18 <lilac> yes
04:31:35 <maartenm> yeah that performs exponentially faster
04:31:38 <quicksilver> if you want fast 'elem', then you want Data.Set or IntSet
04:31:41 <quicksilver> sinc ethat's the point of them.
04:31:49 <maartenm> ok, I'll look into them
04:32:00 <maartenm> I'm only at my second day with haskell, the API's feel like 'cheating' now
04:32:09 <maartenm> and I'm affraid I'll be too imperative with them
04:36:44 <maartenm> as a matter of exercise, how can I write isAbundant without a parameter? ('uncurried'?)
04:36:51 <maartenm> I've been struggling trying to do that
04:37:56 <Vanadium> @pl \n -> sdivisors n > n
04:37:57 <lambdabot> (>) =<< sdivisors
04:38:26 <maartenm> whoa
04:38:31 <maartenm> the bot knows
04:38:35 <Vanadium> That does not seem too good an idea
04:38:40 <maartenm> no apparently
04:38:43 <maartenm> that uses a monad?
04:38:51 <Vanadium> Yeah.
04:39:03 <Vanadium> ((->) r) is apparently a monad
04:39:03 <PeakerWork> oceans is PM'ing random people the message "sex?"
04:49:13 <jelly12gen> hm i have an strange problem , that i can't solve here http://dpaste.com/64491/ on line 83:1 i get 'the last statement in a 'do' must be an expression
04:49:42 <maartenm> how do I easily get the difference of two lists?
04:50:12 <jelly12gen> maartenm: recursion with elem
04:50:31 <maartenm> huh, really?
04:50:37 <quicksilver> > [1,2,3,4] \\ [4,6]
04:50:38 <lambdabot>   [1,2,3]
04:50:44 <quicksilver> one sense of difference.
04:50:45 <jelly12gen> so liek ooh
04:50:53 <quicksilver> beware multiple occurrences though.
04:50:59 <jelly12gen> use nub then
04:51:03 <jelly12gen> :t \\
04:51:04 <lambdabot> parse error on input `\\'
04:51:09 <jelly12gen> :t '\\'
04:51:11 <lambdabot> Char
04:51:15 <quicksilver> :t (\\)
04:51:16 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
04:51:17 <jelly12gen> focurse
04:52:34 <maartenm> no optimized version for ordered lists?
04:53:45 <quicksilver> maartenm: there are no optimised versions of anything for ordered lists.
04:53:49 <quicksilver> use a Set.
04:56:31 <RayNbow> jelly12gen: http://dpaste.com/64491/ <-- todoTasks and newTodoItems should start in the same column as the definition of str
04:57:18 <RayNbow> jelly12gen, like this: http://dpaste.com/64494/
04:59:07 <jelly12gen> RayNbow: aaah , thanks , new erros :D
04:59:49 <PeakerWork> maartenm: the notion of an ordered set is problematic.  An ordered list which has fast membership lookup/removal/etc could be interesting, but probably not simple
05:01:32 <RayNbow> hmm... I wonder if xmonad would play nicely with Google's OS :p
05:01:41 <Ferdirand> how would an ordered list perform compared to a tree ?
05:01:45 <jelly12gen> RayNbow: android?
05:02:08 <RayNbow> jelly12gen: Chrome OS
05:02:17 <Ferdirand> won't you pay a significant penalty for prepends ?
05:02:17 <jelly12gen> lol what is that ?
05:02:25 <PeakerWork> Ferdirand: perform in what operations?
05:02:36 <jelly12gen> RayNbow: i reading tweakers :P
05:02:41 <PeakerWork> Ferdirand: Haskell's lists are singly-linked lists, prepend is O(1)
05:02:46 <jelly12gen> s/i/i am/
05:02:58 <Ferdirand> but if you implement ordered lists, you have to mainain the order
05:03:27 <Ferdirand> so you cannot just add an item in O(1)
05:04:18 <PeakerWork> Ferdirand: you can prepend without affecting the order of the existing list
05:04:27 <PeakerWork> > let l = [1,2,3] in (l, 0 : l)
05:04:28 <lambdabot>   ([1,2,3],[0,1,2,3])
05:06:44 <portnov> @index modify
05:06:44 <lambdabot> Control.Monad.State, Control.Monad.RWS
05:06:55 <Ferdirand> I was just wondering if it would make sense to have an ordered list type
05:07:03 <portnov> :t modify
05:07:03 <quicksilver> it does.
05:07:04 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
05:07:09 <quicksilver> there are interesting operations on ordered lists.
05:07:14 <Ferdirand> or if it is mostly always better to use a tree
05:07:15 <quicksilver> But, they're less general-purpose than sets
05:07:21 <quicksilver> so in general I'd just use a set.
05:07:29 <quicksilver> there are specific use cases where an ordered list will be faster.
05:07:40 <quicksilver> however, since we have sets, and lists, in the standard library
05:07:44 <maartenm> I like lists better for things like priorityqueues
05:07:48 <maartenm> since you can slice them up cheaper
05:07:54 <quicksilver> maartenm: then you are very misguided ;)
05:07:57 <Ferdirand> which ones ?
05:08:14 <Ferdirand> priority queues ? isn't that a typical efficient usage of a tree ?
05:08:18 <maartenm> yes it is
05:08:19 <quicksilver> maartenm: lists are terrible for priority queues unless you happen to know that new insertions almost always occur at the front.
05:08:42 <maartenm> but you can keep a segment of the list thread-safe
05:08:43 <quicksilver> which is the kind of thing I meant by "specific cases when an ordered list will be faster"
05:08:45 <maartenm> instead of keeping the zhole tree thread-safe
05:09:30 <maartenm> I always use lists for when the priority of events isn't to be taken too accurately
05:09:56 <quicksilver> that sounds like a complex observation which I can't respond to in detail.
05:10:07 <quicksilver> I'll just remark that thread-safety is less of an issue with immutability.
05:10:20 <maartenm> yeah I guess it doesn't have any context here
05:10:23 <portnov> :t rem
05:10:24 <lambdabot> forall a. (Integral a) => a -> a -> a
05:14:30 <maartenm> I meant event priorityqueues, btw.. like, f.i.m you have a network game and UI/control events are thrown onto a central queue
05:14:43 <maartenm> then thread safety usually causes your tree to be much slower than a list
05:15:32 <jelly12gen> http://github.com/jelly/TodoList/tree/master/todo.hs so this is my todolist editor app
05:15:44 <jelly12gen> now i wanted to filter out all illegal arguments
05:15:49 <maartenm> not talking about a queue for rendering 3d objects or anything
05:15:51 <jelly12gen> so that the program doesnt hanig
05:24:52 <jelly12gen> ok lol question
05:25:23 <jelly12gen> wait nevermind
05:34:43 <lilac> jelly12gen: i like how your program becomes 'cat' if given no arguments :)
05:35:16 <jelly12gen> lilac: orly?
05:35:17 <jelly12gen> WUT
05:35:30 <jelly12gen> ok bad ripoff hten
05:35:41 <gwern> 'A free implementation of an NX server based on NoMachine's libraries named FreeNX was published in 2004 by Fabian Franz. FreeNX's primary target is to replace the one closed component and is written in a mix of several thousand lines of BASH, Expect and C, making FreeNX difficult to maintain. '
05:35:44 <gwern> WTF
05:36:26 <lilac> Expect? because bash and C are too easy, they threw in some Tcl?!
05:36:30 <gwern> C, I could understand. bash, well, maybe. but *expect*? what on earth sort of X network programming is this franz doing that requires expect? that pushes it over into daily wtf territory
05:37:24 <lilac> the stuff written in Expect is a convertor from the C into befunge
05:38:28 <jelly12gen> lilac: i dont understand how it becomes cat?
05:39:16 <lilac> jelly12gen: well, first, does it? :)
05:39:39 <jelly12gen> lilac: i dont want it to do it
05:40:04 <lilac> jelly12gen: looks like if getOpt returns an empty actions list, then you do optInput defaultOptions >>= optOutput defaultOptions, which is getContents >>= putStr
05:40:40 <jelly12gen> lilac: i dont completely understand that part rly
05:40:49 <jelly12gen> i just wanted to use getOpt
05:41:12 <jelly12gen> lilac: aah that's why it hangs
05:43:38 <lilac> if you just want a bunch of independent modes of operation, you could change it so options :: [OptDescr (IO ())]
05:43:53 <lilac> then in main check length actions == 1, then execute head actions
05:45:51 <jelly12gen> well there must be a simple method to do this
05:45:57 <jelly12gen> just this getOpt thing
05:46:07 <jelly12gen> i have looked at the wiki
05:46:11 <jelly12gen> several but i was confused
05:46:23 <jelly12gen> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Console-GetOpt.html#v:getOpt
05:46:27 <jelly12gen> that first example i get
05:46:32 <jelly12gen> s/get/understand
05:49:31 <lilac> jelly12gen: will you want to allow command lines with multiple flags / switches / arguments?
05:49:58 <jelly12gen> well i will use just one argument at once
05:50:41 <lilac> do you understand what getOpt is doing, and how the code you have works?
05:51:14 <jelly12gen> i dont understand the main part
05:52:26 <lilac> ok, so suppose you are given the command line ["-v", "-a", "foo"]. getOpt will return an 'actions' list containing [view, add "foo"]
05:52:46 <jelly12gen> ok
05:52:54 <lilac> each of those is :: Options -> IO Options
05:53:12 <lilac> the foldl line chains them together as: return defaultOptions >>= view >>= add "foo"
05:53:19 <lilac> producing a result which is :: IO Options
05:53:36 <jelly12gen> ok
05:53:43 <lilac> so that's basically saying do { newOptions <- view defaultOptions; add "foo" newOptions }
05:54:18 <jelly12gen> ah i see that the code is doing more then i need
05:54:20 <lilac> Options itself is a pair of IO String (some kind of input action) and String -> IO () (some kind of output action)
05:54:53 <lilac> this code seems to be trying to be some kind of IO filter
05:54:54 <jelly12gen> String -> IO() could just be  func str = putStrLn str
05:55:03 <jelly12gen> lilac: http://leiffrenzel.de/papers/commandline-options-in-haskell.html
05:55:06 <jelly12gen> took it from there
05:55:14 <jelly12gen> what would be nicer
05:55:40 <jelly12gen> if i first write my own ofcourse and just check if we have an legal argument  and parameter
05:55:43 <jelly12gen> then execut
05:56:43 <lilac> the conventional way in which option parsing is done using getopt in imperative languages is:
05:56:53 <lilac> 1) you build some kind of data structure based on the options, then
05:57:06 <lilac> 2) you run some code which examines that structure and chooses what to do
05:57:28 <lilac> the code you have is trying to side-step that to some extent, and build a 'what to do' action in step 1
05:57:44 <jelly12gen> so i need some sort of  Data Flag =  Version | Add | ..
05:57:57 <lilac> whether or not that's a good idea, the contents of the Options type is specific to that program
05:57:58 <EvilRanter> which might  be okay, seeing as we can manipulate effects as values in haskell :)
05:58:08 <jelly12gen> http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Argument_handling
05:58:28 <mauke> int c; while ((c = getopt(argc, argv, "asdf:")) != -1) { switch (c) { default: I don't need no data structures; } }
05:58:29 <lilac> jelly12gen: what do you want to happen if someone types "yourProgram -v -a foo --help" ?
05:58:47 <jelly12gen> nothing
05:58:55 <lilac> the "conventional" thing is that --help and --version take priority over everything else
05:59:01 <jelly12gen> ok
05:59:14 <jelly12gen> well maybe i could just do it easier
05:59:15 <jelly12gen> and just
06:01:24 <jelly12gen> be really easy use getArgs
06:02:05 <jelly12gen> and make a function like ["args","operand"
06:04:37 <jelly12gen> ok might do this later
06:05:35 <saml> procrastranationing
06:05:47 <jelly12gen> saml: ?
06:05:54 <saml> procrastination
06:07:05 <saml> > let procrastination f = id in procrastination (+1) 1 -- i'll increment later
06:07:07 <lambdabot>   1
06:07:37 <dainanaki> lol
06:08:12 <lilac> data Procrastination b where Procrastionation :: a -> (a -> b) -> Procrastination b
06:08:23 <lilac> -- i'll apply that function when i get around ti ot
06:08:25 <lilac> *to it
06:09:03 * saml has never seen data with where
06:09:22 <RayNbow> GADT syntax
06:10:22 <lilac> if you prefer, data Procrastination b = Procrastionation a (a -> b)
06:10:39 * quicksilver likes lilac's metaphor but actually that's what haskell does anyway ;)
06:10:42 <paolino> jelly12gen: seen parseargs lib ?
06:11:33 <lilac> quicksilver: too lazy to even lazily evaluate ;-)
06:11:53 <paolino> I found it easier than getopt to use
06:11:58 <RayNbow> > let {split = foldr (\a ~(x,y) -> (a:y,x)) ([],[]); pairs xs = [(a,b) | (a:b:_) <- (fst . split . tails) xs]} in pairs [1..10]
06:12:00 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
06:12:05 <jelly12gen> paolino: er no
06:12:15 <lilac> i'd quite like an arg lib which allows me to specify dependencies between the arguments
06:12:27 <jelly12gen> hmm
06:12:51 <quicksilver> lilac: it's not terribly hard to add that as a second pass over the top of GetOpt
06:13:01 <quicksilver> lilac: although it might be nice to have the combinators for that pre-packaged.
06:13:20 <lilac> quicksilver: indeed. i'd also like automatic help generation which incorporates the dependencies
06:14:18 <RayNbow> > > unfoldr (\xs -> case xs of {(a:b:xs') -> Just ((a,b), xs'); _ -> Nothing}) [1..10]  -- probably clearer :p
06:14:19 <lambdabot>   <no location info>: parse error on input `>'
06:14:26 <RayNbow> > unfoldr (\xs -> case xs of {(a:b:xs') -> Just ((a,b), xs'); _ -> Nothing}) [1..10]  -- probably clearer :p
06:14:28 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
06:15:02 <lilac> > map snd . filter fst . zip (cycle [True,False]) . ap zip tail $ [1..10]
06:15:04 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
06:15:45 <RayNbow> lilac: ap makes my head hurt :p
06:15:57 <lilac> ap on (->) is just S
06:16:10 <paolino> :t ap
06:16:10 <lilac> S f g x = f x (g x)
06:16:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:16:28 <paolino> :t <*>
06:16:30 <lambdabot> parse error on input `<*>'
06:16:30 <RayNbow> lilac: my SKI skills are near non-existent
06:16:40 <RayNbow> :t (<*>)
06:16:40 <paolino> :t (<*>)
06:16:41 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:16:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:16:50 <lilac> RayNbow: might be easier to think of as: zip <*> tail, where both sides are in the (->) a Applicative
06:17:24 <lilac> so given an argument, zip <*> tail applies zip and tail to that, then applies the results to each other
06:17:35 <codebliss> I cannot for the life of me understand the State monad.  I've read all the tutorials, and none of them will click in my head.  I understand all of the other monads fully, except Cont.
06:17:36 <lilac> (zip <*> tail) x = zip x $ tail x
06:17:56 <lilac> codebliss: you understand Reader?
06:18:06 <codebliss> lilac: Quite well, I'll take another look
06:18:11 <paolino> @src State
06:18:12 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:18:12 <codebliss> lilac: I spent more time on writer
06:18:15 <lilac> codebliss: State is just Reader where you can change the value that's read in the middle of the computation
06:18:32 <lilac> codebliss: State is just Writer where you can read the value you've written so far (minus the Monoid stuff)
06:18:53 <codebliss> Alright.  Ill keep googling, thanks.
06:18:57 * Botje keeps mis-reading Monoid for Metroid
06:19:13 <lilac> codebliss: bothe Reader and Writer basically thread a value through a computation, and allow reading or writing of it. state is the same but it allows both
06:19:22 <hackagebot> Lucu 0.3.2 - HTTP Daemonic Library (MasatakeDaimon)
06:19:32 <codebliss> lilac: State is like a more general version?
06:19:36 <lilac> yes.
06:19:51 <lilac> you can implement both Reader and Writer in terms of State
06:19:51 <quicksilver> lilac: reliable automatic error message generation is hard.
06:20:11 <codebliss> I never understood in the monad declerations why there's instance Monad (State s) ... and then later there's return a = State $ \s -> ...?
06:20:15 <codebliss> Are the s's related?
06:20:22 <quicksilver> lilac: that's one of the things that changes writing a parser from an easy, fun combinator exercise, into a toothpulling, hot wire under fingernails, nightmare.
06:20:23 <lilac> quicksilver: we have a system here at work which does pretty well, and it's done in C++ ;-)
06:20:35 <jmcarthur> :t runState
06:20:37 <lambdabot> forall s a. State s a -> s -> (a, s)
06:20:50 <quicksilver> lilac: let me guess, it's all run at compile time in a hideous nested template expansion?
06:20:52 <lilac> quicksilver: our constraints are of the form: Require (foo && bar || ExactlyOneOf(a, b, c, d, e), "Error message")
06:21:18 <lilac> quicksilver: it's done at runtime but the constraints are built via operator overloading
06:21:19 <paolino> codebliss: State is the easier one actually, Reader has 'local' and Writer has 'listen' and 'pass'
06:21:45 <lilac> no templates are involved except for things like Argument<T>
06:22:01 <codebliss> In theory, does IO a = State IO' a?
06:22:04 <quicksilver> lilac: that sounds too easy to understand.
06:22:08 <quicksilver> lilac: that's not idiomatic C++!
06:22:25 <codebliss> State s a, s is the type of the state being changed and a is the return type?
06:22:32 <quicksilver> right.
06:22:39 <paolino> codebliss IO = State World
06:22:42 <lilac> quicksilver: yeah, we have coding standards which force us to use comprehensible code. it strips away like half of c++'s features! ;-)
06:22:45 <codebliss> Ah ya
06:22:49 <quicksilver> some people think "State RealWorld a" is a good model for IO a
06:22:53 <quicksilver> however it's only a model
06:22:55 <quicksilver> and it's not very good.
06:23:06 <codebliss> Yes, of course, I think much better in theory than real-world examples
06:23:29 <codebliss> I'm not experienced enough to understand tutorials like RWH  =D.  I went through LYAH
06:23:31 <lilac> IO in GHC is actually implemented as ST RealWorld, but ST and State aren't as similar as they sound
06:23:39 <codebliss> Ah, alright.
06:24:02 <quicksilver> I'm not sure that's true in a useful sense.
06:24:18 <quicksilver> ST RealWorld does not have the primitives required to implement putStrLn (for example)
06:24:30 <mmorrow> quicksilver: (State () a) i think says it without implying that RealWorld is something other than nothing
06:24:32 <maartenm> main = print $ maximumBy (\x -> compare $ length $ show (1/x)) $ [1..100]
06:24:37 <quicksilver> IO in GHC is actually State# RealWorld#
06:24:39 <maartenm> why can't I 'show' a Fractional Int?
06:24:49 <quicksilver> maartenm: because there aren't any franctional ints.
06:24:59 <quicksilver> ...but State# is a fiddly beast.
06:24:59 <mmorrow> (well, i guess s/()/some flagged one-constructor type that ghc knows what it's for/)
06:25:04 <quicksilver> it's not actually haskell.
06:25:11 <maartenm> ok
06:25:14 <quicksilver> it's an impure language, with side-effects.
06:25:15 <maartenm> so, eh..
06:25:25 <maartenm> I'll try to figure it out
06:25:30 <quicksilver> which happens to share syntax with haskell.
06:26:53 <codebliss> Maybe I'm confused with the State monad because of the newtype decleration
06:27:04 <codebliss> I understnad the theory around it, bu don't get how it's implemented
06:27:16 <paolino> :t maximumBy (\x -> compare (length $ show (1/x)))
06:27:17 <codebliss> Mostly the State $ \s and instance (State s)
06:27:18 <lambdabot>     No instance for (Fractional Int)
06:27:18 <lambdabot>       arising from a use of `/' at <interactive>:1:41-43
06:27:18 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
06:27:36 <quicksilver> codebliss: you're right to suggest they are different
06:27:45 <quicksilver> codebliss: but they are related, which is why the author used the same letter
06:27:52 <quicksilver> codebliss: (I'm talking about the two "s" es)
06:27:59 <skorpan> @pl \f -> gets vty >>= liftIO . f
06:27:59 <lambdabot> (gets vty >>=) . (liftIO .)
06:28:01 <EvilRanter> codebliss, if you were to use a type, it'd be "type State s a = s -> (a,s)", so you could expand out the "m" in the types, and get:
06:28:05 <codebliss> Okay.  I'm still partially imperative thinking XD
06:28:05 <quicksilver> codebliss: in (State s), "s" is a type, like "Int".
06:28:06 <EvilRanter> return:: a -> s -> (a,s)
06:28:18 <quicksilver> codebliss: in \s -> blah, "s" is a variable (it holds the current state)
06:28:26 <skorpan> @pl \x -> lift $ withMPD x
06:28:26 <lambdabot> lift . withMPD
06:28:30 <EvilRanter> and (>>=) :: (s -> (a,s)) -> (a -> s -> (b,s)) -> (s -> (b,s))
06:28:38 <quicksilver> marmolak: the
06:28:40 <paolino> :t compare
06:28:41 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
06:28:47 <quicksilver> maartenm: the real problem is that compare takes two arguments.
06:28:59 <quicksilver> maartenm: the confusion over / and Int is a sideshow.
06:29:03 <EvilRanter> codebliss, and both of those types have fairly direct implementations
06:29:10 <maartenm> it takes two arguments?
06:29:24 <maartenm> oh, \x y -> ...
06:29:35 <paolino> :t maximumBy (\x y -> compare (length $ show (1/x)) (length $ (show (1/y)))
06:29:37 <lambdabot> parse error (possibly incorrect indentation)
06:29:40 <skorpan> does anyone recognize this error when using Graphics.Vty? "Prelude.chr: bad argument#
06:29:46 <jmelesky> i'm looking to upgrade my GHC (on a mac) -- is macports still the way to go, or is the .dmg the new blessed way of installing on macs?
06:29:47 <EvilRanter> (return a s = (a,s); (m >>= f) s = let (a, s') = m s in f a s')
06:30:00 <paolino> :t maximumBy (\x y -> compare (length $ show (1/x)) (length $ (show (1/y))))
06:30:03 <lambdabot> forall a. (Fractional a) => [a] -> a
06:30:12 <EvilRanter> codebliss, and the usual definition of return and >>= for State are just those definitions with newtype-(un/)wrapping
06:30:17 <quicksilver> jmelesky: I think the dmg is more blessed these days.
06:30:30 <jmelesky> quicksilver: i thought that might be the case. thanks.
06:30:31 <paolino> :t comparing
06:30:33 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
06:30:33 <lilac> quicksilver: ST s is a newtype around (State# s, (# State# s, a #)), and IO is a newtype around (State# RealWorld, (# State# RealWorld, a #), so ST RealWorld and IO are isomorphic
06:30:45 <EvilRanter> codebliss, have you seen "you could have invented monads"?
06:30:46 <codebliss> EvilRanter: Sorry, I still don't get it.  Overflowed with letters
06:30:55 <codebliss> EvilRanter: Yep.  That's what made it click.
06:31:02 <codebliss> Oh, it's you.
06:31:05 <codebliss> =D
06:31:10 <EvilTerran> :)
06:31:17 <maartenm> thanks, sorry for another trivial question.. I promise I will get better
06:31:21 <codebliss> Yes, you could have invented monads is what made it click for me
06:31:35 <EvilTerran> > map sort $ words "evilterran evilranter irrelevant"
06:31:38 <lambdabot>   ["aeeilnrrtv","aeeilnrrtv","aeeilnrrtv"]
06:32:07 <codebliss> lol
06:32:21 <EvilTerran> :D
06:32:44 <quicksilver> lilac: that's rather different from saying "IO is implemented as ST RealWorld"
06:32:46 <paolino> :t comparing (length  . show . (1/))
06:32:48 <lambdabot> forall b. (Fractional b) => b -> b -> Ordering
06:33:07 <paolino> :t maximumBy $ comparing (length  . show . (1/))
06:33:09 <lambdabot> forall a. (Fractional a) => [a] -> a
06:33:13 <quicksilver> lilac: that suggests that the tools to make the basic IO operations - like input, output, and concurrency - will be found in ST RealWorld.
06:33:18 <quicksilver> lilac: whereas actualy they aren't.
06:33:41 <codebliss> I'm saying, totally abstractly, that IO is basically a State monad holding the RealWorld
06:33:50 <quicksilver> codebliss: and I'm saying "no".
06:33:56 <codebliss> quicksilver: That works =P
06:33:59 <quicksilver> I'm saying that's a model, which some people like, which is wrong.
06:34:29 <quicksilver> because the realworld can change "during" an IO action.
06:34:40 <quicksilver> (especially in the presence of concurrency, but even without it)
06:34:54 <quicksilver> so the idea that an IO action is a map from RealWorld to RealWorld is wrong.
06:35:13 <quicksilver> an IO action may induce changes in the RealWorld, but it can't stop other things happening.
06:35:22 <paolino> can change , without the action saying it ?
06:35:23 <quicksilver> there is no serialisation between IO actions and other stuff which might happen.
06:35:52 <jmcarthur> the "token passing" of RealWorld from one action to the next is not atomic
06:35:59 <quicksilver> if it was true that 'putStrLn "Hello"' had the type (RealWorld -> (RealWorld,()))
06:36:06 <quicksilver> then it would be true that for a given 'input' RealWorld
06:36:10 <quicksilver> you always got the same output
06:36:11 <jmcarthur> although it is modeled that way
06:36:19 <paolino> ok
06:36:20 <quicksilver> actualy that's not true, because other stuff can happen along the way.
06:36:39 <quicksilver> it's not a totally useless model but I actually think it has the potential to mislead quite badly.
06:36:51 <quicksilver> [ and so deos the State# model, because State# is not a haskell type ]
06:37:04 <jmcarthur> the advantage of the monad is the sequencing, not the model
06:37:09 <quicksilver> it's better to think of an IO action a bit more abstractly, in my opinion.
06:37:17 <lilac> quicksilver: the tools to make the basic IO operations actually do exist in ST RealWorld as much as they exist in IO
06:37:37 <quicksilver> lilac: given that they are isomorphic, yes.
06:37:43 <quicksilver> lilac: but they don't "come from" ST in any sense.
06:37:48 <quicksilver> lilac: the comparison with ST is not educating.
06:37:50 <codebliss> Has anybody read the beginning of (http://spbhug.folding-maps.org/wiki/MonadsEn)?
06:37:51 <quicksilver> We do not learn form it.
06:37:57 <quicksilver> the ST primitives do not teach us anything.
06:38:03 <quicksilver> they do not show how IO is made.
06:38:10 <quicksilver> it is not a useful definition for understanding IO.
06:38:12 <codebliss> The first page I thought was really damn ingenius
06:38:14 <lilac> they do if we understand how ST is made
06:38:17 <jmcarthur> lilac: perhaps you are thinking of STRef and IORef? they are the same thing in implementation, i believe
06:38:30 <quicksilver> lilac understands as well as you or me, jmelesky
06:38:33 <quicksilver> jmcarthur rather.
06:38:35 <lilac> but ST is more general, so that'd be a harder starting point
06:38:46 <quicksilver> I just disagree rather strongly with his pedagocical approach.
06:38:56 <jmcarthur> oh maybe i should read higher
06:39:04 <quicksilver> given two isomorphic structures it is quite subjective which is more "basic".
06:39:08 <quicksilver> after all, they're isomorphic.
06:39:25 <quicksilver> However, it is clear to me that the statement "IO is implemented in terms of ST" contains no useful content.
06:39:30 <quicksilver> it teaches nothing.
06:39:35 <quicksilver> I would not personally make this statement.
06:39:44 <quicksilver> It would be like saying "Integers are implemented in terms of church numerals"
06:39:47 <jmcarthur> how would you implement putStrLn in terms of ST?
06:40:12 <quicksilver> just because church numerals and Integers are isomorphic does not make church numerals a good model for explaining anything.
06:40:14 <lilac> quicksilver: it would be more like saying "Int is implemented in terms of 32-bit lumps of memory"
06:40:20 <dschoepe> Is there a variant of runghc that compiles the file first and runs the resulting binary?
06:40:25 <quicksilver> no, it wouldn't.
06:40:30 <quicksilver> Because that would actually be useful.
06:40:38 <quicksilver> because 32-bit lumps of memory are a genuinely more basic concept.
06:40:44 <lilac> quicksilver: since the latter don't give you the primitives you want, but are a more general form of the "same" thing
06:41:00 <quicksilver> I am going to stop this conversation, because you are not going to be convinced and I am not interested in convincing you.
06:41:13 <lilac> actually, i am pretty persuaded by your arguments
06:41:33 <paolino> quicksilver , which is the more abstract definition for IO ?
06:42:06 <quicksilver> paolino: something like data IO a = PutChar | GetChar | OpenFile | .....
06:42:16 <quicksilver> (it looks a bit better with GADT syntax)
06:42:28 <quicksilver> where you just view IO as being a way to construct rather abstract descriptions of IO programs
06:42:38 <paper_cc> I have a function on polynomials composePow :: (Num a) => (forall b. (Num b) => Polynomial b) -> Int -> Polynomial a. As-is it only works when the passed polynomial works for any Num a => a. Is it possible to make it work in other cases or have I run into limits of the type system?
06:42:42 <quicksilver> and you assume that the runtime system / compiler somehow "runs them" for you.
06:43:01 <lilac> isn't it more, data IOFunctor a = PutCahr | ... , with IO being the free monad over that?
06:43:10 <quicksilver> yes.
06:43:21 <quicksilver> it was only a sketch :)
06:43:34 <quicksilver> I think this sketch is elaborated in some blog post or other, somewhere, but I don't remember by whom.
06:44:17 <paolino> lilac: free monad?
06:44:19 <paper_cc> dschoepe: there isn't, but you can always make a script
06:44:30 <lilac> paolino: something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1676
06:44:44 <codebliss> I still don't get newtypes.. See:  newtype State s a = State { runState :: s -> (a, s) }
06:44:53 <dschoepe> paper_cc: Yes, that's what I did, I just figured that using a already existing tool would be better for portability
06:45:36 <EvilTerran> codebliss, you can read that as "newtype State s a = State (s -> (a,s)); runState (State m) = m"
06:45:54 <EvilTerran> (and hence runState :: State s a -> s -> (a,s))
06:46:21 <EvilTerran> (and State :: (s -> (a,s)) -> State s a)
06:47:49 <codebliss> EvilTerran: I'm not understanding a thing  =/
06:47:53 <lilac> quicksilver: i think the key is, the 'state' in ST doesn't have the same meaning as in State, so the metaphor of a computation using the real world as state doesn't hold
06:48:05 <lilac> quicksilver: based on that, i agree, it's not a useful observation at all
06:48:17 <quicksilver> right.
06:48:28 <quicksilver> whereas, State# RealWorld# really does look like a state monad
06:48:31 <quicksilver> but, it's not
06:48:37 <quicksilver> because State# isn't really a type ;)
06:49:09 <quicksilver> I was always rather surprised that GHC compiles IO via a language which looks like haskell but has side-effects.
06:49:17 <quicksilver> seems to make their optimiser quite a bit more difficult.
06:49:19 <lilac> although IO is isomorphic to State (State# RealWorld), and perhaps that's the more interesting observation
06:49:27 <quicksilver> but I imagine they considered the alternatives.
06:49:41 <EvilTerran> codebliss, given "newtype <some type expression> = <some constructor> { <some function name> :: <some type expression> }", the two types are isomorphic to each other
06:49:54 <codebliss> Isomorphic?
06:49:57 <EvilTerran> codebliss, and you can get between them with the constructor or the function name
06:50:16 <lilac> codebliss: fancy way of saying the values of the types are in 1-to-1 correspondence
06:50:19 <EvilTerran> codebliss, every value in one type corresponds to some value in the other in a natural way
06:50:56 <codebliss> I'll just shut up, I'll look at this another day...
06:51:01 <EvilTerran> codebliss, to take an example, "State s a" and "s -> (a,s)" both contain the same selection of values
06:51:10 <EvilTerran> namely, functions from s to (a,s)
06:51:32 <EvilTerran> it's just "State s a" wraps these values in a constructor, (slightly confusingly) also called State
06:51:43 <codebliss> Alright.
06:51:50 <lilac> quicksilver: i don't really see why it causes optimization difficulties, if the primitives are opaque objects :: State# RealWorld -> (State# RealWorld, a)
06:51:56 <codebliss> Don't you use newtype so you can make it an instance of Monad?
06:52:02 <EvilTerran> you do, yes
06:52:07 <codebliss> Since you can't with type
06:52:12 <quicksilver> lilac: because referential transparency says you can duplicate things, and CSE things
06:52:13 <codebliss> Since you need to specificy every kind
06:52:20 <quicksilver> lilac: whether they are opaque or not ;)
06:52:25 <EvilTerran> codebliss, it's more that you can't partially apply a type synonym
06:52:33 <codebliss> Ya, gotcha
06:52:45 <EvilTerran> if you had "type State s a = s -> (a,s)", you wouldn't be able to write "instance Monad (State s)"
06:52:45 <lilac> quicksilver: but you never run multiple opaque things on the same State# RealWorld
06:52:46 <codebliss> So we use newtype to make it an instance of Monad
06:52:54 <codebliss> Ya, gotcha
06:53:09 <codebliss> So State s a is a wrapper for s -> (a,s)
06:53:15 <EvilTerran> yep
06:53:18 <lilac> quicksilver: so CSE etc would never seem to have an opportunity to kick in
06:53:29 <codebliss> Lemme mess in ghci for a min, I'll be back
06:53:51 <lilac> (unless someone goes under the covers and applies seq to a State# RealWorld, you can't join two state threads together)
06:54:27 <EvilTerran> codebliss, and the constructor, State, injects from "s -> (a,s)" to "State s a", and runState injects the other way
06:54:32 <codebliss> I think what's confusing me is I keep thinking state is the (a,b) tuple.
06:55:30 <quicksilver> lilac: well, see http://hackage.haskell.org/trac/ghc/ticket/1168
06:55:31 <codebliss> lke type State s a = (a,s)
06:55:39 <codebliss> I never thought of State as the conversion
06:55:39 <quicksilver> lilac: for an example of how State# gets the optimiser in a twist.
06:55:44 <doserj> codebliss: yes, a value of type State s a is not really a value of type a with some state, but rather a state *transformer* that produces a value of type a
06:55:52 <paper_cc> codebliss: actually State should be called Stateful instead
06:56:35 <quicksilver> lilac: although that's a second-order bug report : it's a report on how the hack which was added to the optimiser to make it more agressive on State#, causes space leaks
06:56:40 <paper_cc> codebliss: so (State s a) is a thing that computes something (namely an a) and transforms a state (of type s) by the way
06:56:49 <codebliss> That's exactly what I was thinking
06:56:50 <quicksilver> lilac: but the fact the hack was there in the first place is my point
06:56:59 <codebliss> I always thought of State as a tuple
06:57:12 <codebliss> Not a function to a tuple
06:57:24 <paper_cc> codebliss: a tuple is a Writer, not a State
06:57:43 <codebliss> Well I'm getting state now, I'm just saying I think the name is a bit lackluster
06:58:58 <codebliss> So.  foo :: State a b.  foo is a wrapped (function to tuple)?
06:59:16 <quicksilver> codebliss: Yes.
06:59:17 <EvilTerran> yup
06:59:31 <codebliss> That is not at all how I would have implemented it XD.  Alright thanks.
06:59:35 <quicksilver> codebliss: foo is a computation, which computes a "b" using a state of type "a".
06:59:42 <codebliss> Alright
07:00:05 <lilac> quicksilver: the original hack tells the optimizer that "any lambda with a State# inside it will be evaluated only once, so feel free to inline inside it"
07:00:39 <lilac> quicksilver: so it sounds like State# provides additional optimization opportunities in some cases, and GHC over-optimizes those cases sometimes
07:00:56 <quicksilver> lilac: yes, that's definitely one way to express it ;)
07:01:19 <quicksilver> lilac: but I would have expected a strong separation between the side-effectful and non-side-effectful constructs, personally.
07:01:26 <lilac> quicksilver: however, without the state hack, the optimizer is still correct
07:01:33 <quicksilver> although OTOH maybe that would have made unsafePerformIO hard to implement.
07:02:14 <lilac> quicksilver: would you have given them a different kind or something along those lines?
07:03:22 <lilac> to be honest i have no idea if the optimizer pays attention to kinds
07:03:58 <Heffalump> I doubt it, why would it?
07:04:03 <EvilTerran> lilac, that's an interesting thought, though, some kind-based trickery for controlling IO
07:06:09 <codebliss> Are State and runState opposites?
07:06:46 <codebliss> AKA.  state . runState = id?
07:07:14 <codebliss> *State
07:07:47 <lilac> @src State
07:07:48 <lambdabot> Source not found. My pet ferret can type better than you!
07:07:57 <ldlework> If when I installed haskell I'm missing a bunch of basic dependancies like parsec, network, stm, and -any
07:08:07 <ldlework> Am I missing a standard library package?
07:08:17 <lilac> codebliss: yes, they are, since State is a newtype with 'State' as its constructor, with a single field named 'runState'
07:08:22 <quicksilver> lilac: I think I'd have compiled IO into an obviously side-effectful language.
07:08:37 <quicksilver> lilac: Not necessarily Cmm, but definitely not something which looks like haskell but isn't.
07:08:40 <doserj> ldlework: http://hackage.haskell.org/platform/
07:08:40 * quicksilver shrugs
07:08:55 <quicksilver> lilac: I'm not as good at writing compilers as the GHC team so I have no confidence my appraoch would be better :)
07:09:12 <ldlework> doserj: Wassat
07:09:13 <hkBst> @src fold1
07:09:14 <lambdabot> Source not found. Where did you learn to type?
07:09:38 <lilac> quicksilver: i guess the issue is, where do you draw the line between the haskell bit and the primitives implemented externally?
07:10:07 <lilac> quicksilver: and the more you can push into haskell, the more optimization you can do (but the more risk there is of breaking the semantics)
07:10:47 <hkBst> @src foldr1
07:10:48 <lambdabot> foldr1 _ [x]    = x
07:10:48 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
07:10:48 <lambdabot> foldr1 _ []     = undefined
07:14:25 <ldlework> doserj: I'm not sure what you were implying by linking me to that
07:14:33 <ldlework> Does that have the  core libraries I need included?
07:14:35 <EvilRanter> -.-
07:14:57 <codebliss> Yay I made a working trivial state function... XD
07:14:59 <codebliss> incState = State $ \x -> (x,x+1)
07:15:00 <doserj> ldlework: that's the standard library package you are missing...
07:15:23 <ldlework> do you know what the package name is called? Synaptic can't find anything called haskell-platform
07:15:25 <ldlework> :)
07:16:07 <doserj> ldlework: ah, you are using distribution-specific packages?
07:16:34 <ldlework> Well... I installed ghc and friends through synaptic at least
07:16:45 <doserj> ldlework: than look for packages called libghc6-* or similar
07:17:23 <doserj> ldlework: I guess that's ghc-6.8.x? in that case the haskell-platform won't work anyways...
07:23:54 <lilac> codebliss: that's the same as: do x <- get; put (x+1); return x
07:24:49 <lilac> or do x <- get; modify (+1); return x
07:25:29 <quicksilver> or get <* modify (+1)
07:25:50 <lilac> nice :)
07:26:00 <quicksilver> yeah, I like *> and <*
07:26:25 <quicksilver> bracketed_expr = char '(' *> expr <* char ')'
07:26:37 <lilac> that's neat.
07:27:20 <lilac> much better than what i've been doing: bracketed_expr = char '(' >> expr >>= ignore (char ')')
07:27:21 <quicksilver> I should really credit the person who showed me that trick, but unfortunately I've forgotten.
07:27:24 <quicksilver> senility is a bitch.
07:27:46 <EvilTerran> (*>) and (<*) are particularly useful as parser combinators
07:28:37 <quicksilver> EvilTerran: that's what my example was intended to illustrate? ;)
07:28:48 <lilac> quicksilver: i hope one day to hit the middle ground between youth and senility where the probability of being simultaneously thoroughly certain and thoroughly wrong is minimized
07:29:11 <quicksilver> lilac: What makes you sure the middle ground isn't precisely the opposite?
07:29:12 <lilac> quicksilver: (i also hope i'm still on the young side of it, but who knows...)
07:29:15 <EvilTerran> quicksilver, indeed
07:29:41 <lilac> quicksilver: i'm thoroughly certain it isn't ;-)
07:38:11 <Arnar> any vim users here who do a lot of haskell programming?
07:38:24 <skorpan`> the probability is high
07:38:26 <mauke> well, sort of
07:38:40 <codebliss> I will be since I can't get gnome to work on my new arch =P
07:38:42 <Arnar> I love the hs intergration with emacs.. but I miss vi navigation
07:39:01 <Arnar> codebliss: :)  gvim is beautilful on gnome :)
07:39:21 <codebliss> Yes of course, I still love my console hack
07:39:26 <Arnar> I was wondering if there were plugins/scripts/environments that make vim play nicely with hs
07:39:35 <Arnar> e.g. indentation rules, interaction with the repl etc.
07:40:09 <skorpan`> i remember my haskell examiner had made a vim script for better indentation or something
07:40:12 <codebliss> I changed my desktop background to black, and then I made it so the gnome-terminal had no window border.  It was like a desktop console.  Loved it
07:40:18 <skorpan`> google "ulf norell vim" or something :)
07:40:34 <Arnar> codebliss: nice. I use xmonad myself.. kindof gives the same result
07:40:36 <Arnar> skorpan`: thanks
07:41:16 <codebliss> Ah.  I'm still a linux noob.  Although I assume getting arch to work and configuring bashrc, aliases, doing some scripting, getting the daemons to work, etc added some credibility
07:41:48 <Arnar> a good start
07:41:52 <maartenm> Arnar: why don't you use Viper?
07:42:04 <codebliss> I always wanted to get leksah to work.
07:42:05 <maartenm> I use emacs with vim navigation
07:42:15 <maartenm> it doesn't always feel right though
07:42:41 <Arnar> maartenm: hmm, maybe I should try it again.. I remember wrestling with it quite a bit
07:42:45 <navaati> hello
07:42:50 <Arnar> hi
07:42:53 <psl> hi
07:42:58 <psl> i need some help
07:43:06 <psl> im reading real world haskell online tutorial
07:43:11 <maartenm> my main problem with Viper is that it's slow, compared to vim
07:43:20 <psl> im supposed to write a function that checks the lenght of a list
07:43:25 <psl> listLenght []           = 0
07:43:25 <psl> listlenght xs           = 1 + listLenght (tail xs)
07:43:29 <psl> that dont work
07:43:45 <mauke> psl: yeah, spelling errors
07:43:54 <psl> ah omg xD
07:43:55 <mauke> it's length, not lenght
07:43:58 <skorpan`> psl: haskell is also case-sensitive
07:43:59 <mauke> also L
07:45:37 <jleedev> also pattern matching
07:46:43 <mauke> > let listLength [] = 0; listLength (x : xs) = 1 + listLength xs in listLength [1,1,1,5]
07:46:45 <lambdabot>   4
07:46:59 <skorpan`> > let listLength = length in listLength [1,2,3,4]
07:47:01 <lambdabot>   4
07:47:07 <skorpan`> i made that myself
07:47:11 <skorpan`> ;P;P;P;P;P;);););)
07:48:37 <RayNbow> > foldl (const.succ) 0 [1,2,3,4]
07:48:38 <lambdabot>   4
07:48:39 <mauke> > let listLength = last in listLength [1,2,3,4]
07:48:40 <lambdabot>   4
07:49:19 <codebliss> RayNbow: That's exactly what I was typing =P
07:49:25 <RayNbow> :p
07:50:39 <lilac> > let listLength = getSum . mconcat . map (const (Sum 1)) in listLength [1,2,3,4]
07:50:41 <lambdabot>   4
07:50:55 <skorpan`> i'd probably calculate length with the state monad though... just to be safe.
07:51:23 <lilac> skorpan`: i hear the Etats monad is fashoinable these days, could use that
07:51:36 <skorpan`> what's that?
07:51:49 <codebliss> > let len =  foldl (+) 0 . map (const 1)
07:51:51 <lambdabot>   not an expression: `let len =  foldl (+) 0 . map (const 1)'
07:51:52 <codebliss> That's what I got
07:52:24 <lilac> skorpan`: reverse state monad
07:52:33 <skorpan`> which means?  i put to get and get to put?
07:52:47 <lilac> it means the state flows backwards through the computation
07:53:04 <skorpan`> wat
07:53:24 <jkff> > let len = fst . last . zip [1..] in len [10..20]
07:53:25 <lambdabot>   11
07:53:42 <RayNbow> > getSum . Data.Foldable.foldMap (const$Sum 1) $ [1..4]  -- lilac
07:53:44 <lambdabot>   4
07:53:49 <EvilTerran> (mx >>= f) s = let (x, s'') = mx s'; (fx, s') = f x s in (fx, s'') -- skorpan`
07:53:55 <PeakerWork> > let len = fst . last . zip [1..] in len [10..9]
07:53:57 <lambdabot>   * Exception: Prelude.last: empty list
07:54:04 <skorpan`> EvilTerran: too little do-notation
07:54:12 <EvilTerran> no do-notation
07:54:15 <EvilTerran> i'm defining >>= here
07:54:16 <EvilTerran> :P
07:54:16 <codebliss> You guys are crazy.
07:54:18 <skorpan`> oh, heh
07:54:21 <jkff> PeakerWork: You got me.
07:54:35 <lilac> , let (_ >>= _) = undefined in do return 1 :: Maybe Int
07:54:36 <lunabot>  luna: Parse error in pattern
07:54:51 <EvilTerran> skorpan`, basically, it's the same definition as State, except m>>=f is tweaked to thread the state through the result of f before threading it through m
07:55:01 <EvilTerran> skorpan`, so "do x <- get; put 1; return x" will give you 1
07:55:19 <jkff> > let len = fst . last . zip [0..] . (undefined:) in len [10..9]
07:55:19 <skorpan`> that's wicked
07:55:20 <lambdabot>   0
07:55:21 <EvilTerran> by the power of laziness!
07:55:22 <jkff> Take that!
07:55:22 <skorpan`> in a bad way
07:55:47 <skorpan`> > let len = fst . last . zip [0..] . (undefined:) in len [1..9]
07:55:49 <lambdabot>   9
07:55:52 <PeakerWork> @type scanl
07:55:53 <RayNbow> http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/ ?
07:55:53 <skorpan`> just making sure it works ;P
07:55:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
07:56:10 <jkff> However, it won't work for negative-sized lists.
07:56:31 <PeakerWork> > let len = scanl (const . (+1)) 0 in len [1..10]
07:56:32 <skorpan`> there is no such thing, is there?
07:56:33 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
07:56:43 <PeakerWork> > let len = last . scanl (const . (+1)) 0 in len [1..10]
07:56:45 <lambdabot>   10
07:56:47 <pikhq> skorpan`: Only if you define an anti-cons.
07:56:52 <PeakerWork> > let len = last . scanl (const . (+1)) 0 in len [10..9]
07:56:54 <lambdabot>   0
07:56:57 <skorpan`> snoc is ... almost ...
07:57:01 <skorpan`> *brain explodes*
07:57:02 <jkff> skorpan: Thanks to the fact, the function is usable :)
07:57:07 <PeakerWork> > let len = foldl (const . (+1)) 0 in len [10..9]
07:57:08 <lambdabot>   0
07:57:09 <lilac> jkff: len = fst . last . zip [..,0,1,..]
07:57:53 <jkff> Oh yes, that will work. Consider proposing that for Haskell Prime?
07:58:24 * lilac thinks about designing a lazy Stack data type which can return values it's not been given yet
07:58:38 <harlekin> Does bootstrapping from C files work with the current ghc again?
07:58:48 * skorpan` sticks to StateT with IO...
07:58:54 <skorpan`> the rest is only for academics
08:03:28 <codebliss> You guys make babies cry.  Just saying =D
08:03:33 <Twey> foo (words -> [bar, (read -> baz), (read -> quux), (read -> arnold)]) — why does this single pattern alone give me a ‘patterns are overlapped’ error?
08:03:50 <codebliss> Is it possible to make a full IRC client in the console?  Where it accepts chat commands and also posts the traffic?
08:03:59 <Twey> codebliss: Of course
08:04:01 <Twey> Never seen irssi?
08:04:12 <jkff> Wow, view patterns!
08:04:15 * quicksilver is using irssi
08:04:15 <codebliss> I was just wondering how you can get input and display it at the same time.
08:04:17 <Twey> jkff: Yeah <3
08:04:21 <skorpan`> codebliss: threads basically
08:04:25 <quicksilver> rubbish
08:04:29 <quicksilver> (no offense intended)
08:04:32 <jkff> Do they exist in ghc for a long time already?
08:04:33 <codebliss> skorpan`: I knew it was a simple answer, lol
08:04:38 <quicksilver> irssi doesn't use threads ;)
08:04:40 <Twey> jkff: Yeah
08:04:48 <skorpan`> true, you don't even need threads
08:04:51 <quicksilver> if you were writing in it haskell, you would, though, if that's what you meant.
08:04:57 <codebliss> Well, what would you do?  In haskell
08:04:59 <Twey> jkff: -XViewPatterns or {-# LANGUAGE ViewPatterns #-}
08:05:00 <skorpan`> actually, i'm not sure threads would help at all... hm.
08:05:01 <quicksilver> because haskell makes threads simpler than select().
08:05:09 <Twey> codebliss: In Haskell I would use threads
08:05:09 <quicksilver> but irssi surely uses select().
08:05:13 <Twey> Yeah.
08:05:18 <Twey> Because irssi is in C.
08:05:20 <Twey> Poor thing.
08:05:22 <jkff> Twey: I thought so. Probably I wasn't daring enough to try them out
08:05:25 <codebliss> I'm wondering how you would get input and display it at the same time.
08:05:31 <skorpan`> codebliss: you don't! :)
08:05:32 <quicksilver> the OS does that for you.
08:05:40 <quicksilver> the OS handles your input and your output
08:05:41 <codebliss> =X
08:05:45 <EvilTerran> Twey, iirc, the overlap checking for view patterns is slightly overzealous at the moment
08:05:49 <quicksilver> you just ask it "is their input pending? Can I output?"
08:05:54 <quicksilver> and then you do what you can.
08:05:54 <Twey> EvilTerran: Ah
08:05:57 <quicksilver> s/their/there/
08:06:04 <Twey> EvilTerran: I rather thought it might be, given that it's a single pattern
08:06:10 <Twey> I've never heard of a pattern overlapping with itself :-P
08:06:15 <quicksilver> although programs like irssi probably assume output is always possible.
08:06:54 <codebliss> Like in haskell.  How could I be showing what you guys say, and type what I'm saying, hit enter, and display it?
08:06:58 <Twey> EvilTerran: Is there an easy way I can tell it not to do that?
08:07:03 <Twey> EvilTerran: It's annoying.
08:07:03 <codebliss> While getting your messages whilst I type
08:07:05 <EvilTerran> Twey, given that the overlap warning should only come up when one branch will never be taken, it's trivially nonsensical when there's only one branch, yeah :P
08:07:11 <EvilTerran> dunno how to mask the warning
08:07:34 <quicksilver> codebliss: they appear in different lines of the display.
08:07:50 <quicksilver> codebliss: my typing is in the bottom line, what you're saying is the top (n-2) lines.
08:07:50 * Twey is falling in love with view patterns
08:07:52 <codebliss> I mean how would the code itself work?  Obviously you don't use getLine?
08:07:54 <quicksilver> I'm not reall sure what you're asking.
08:07:57 <codebliss> Yes, I understand that =D
08:08:02 <quicksilver> in haskell, you use getLine, and you use threads.
08:08:08 <codebliss> Alright.
08:08:08 <quicksilver> one thread to read, one to write.
08:08:17 <codebliss> I don't know threads, so that's probably why I'm confused =D
08:08:18 <codebliss> That works.
08:08:23 <EvilTerran> Twey, see http://hackage.haskell.org/trac/ghc/ticket/2395
08:08:36 <EvilTerran> Twey, that page says "-fno-warn-overlapping-patterns", although then you lose all such warning
08:08:37 <EvilTerran> s
08:08:40 <Twey> Yeah
08:08:52 <Twey> Well, I'll take it off when I'm done iteratively-developing to check.
08:08:53 <Twey> Thanks.
08:09:02 <codebliss> I'm looking at roll your own irc bot, but I'm going for a client, not a bot =P.  So I want to be able to send out messages from the program
08:09:15 * EvilTerran can't actually remember getting a legitimate instance of that warning through accidentally writing overlapping patterns, so wouldn't be that bothered
08:09:31 <Twey> Does GHC have a pragma for -f options?
08:09:41 * Twey dislikes passing stuff directly to GHC
08:09:44 <EvilTerran> i think you use OPTIONS_GHC or whatever it is
08:10:20 <Twey> Ah, found it
08:10:24 <Twey> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
08:10:24 <EvilTerran> Twey, so that'd be {-# GHC_OPTIONS -fno-warn-overlapping-patterns #-}
08:10:26 <Twey> Thanks
08:10:31 <Twey> OPTIONS_GHC
08:10:48 * EvilTerran had it right the first time >.<
08:10:49 <hackagebot> curry-frontend 0.2.1 - Compile the functional logic language Curry to several intermediate formats (HolgerSiegel)
08:12:01 <Twey> Hehe
08:12:23 <Arnar> maartenm: can I ask you a viper/haskell-mode question?
08:12:26 <codebliss> Okay, I'm done.  I still don't totally get State, or this IRC bot..
08:12:33 <Saizan_> codebliss: so you're asking how'd you manage the user interface?
08:12:45 <maartenm> arnar: yeah, sure
08:13:31 <Arnar> maartenm: in viper mode.. after inserting a new line it goes to the default indentation level, then I press tab once and nothing happens. only the second time it starts cycling the indent levels.. is this the case for you as well?
08:13:43 <Twey> codebliss: Probably you should work on Haskell in general a bit more before diving into this stuff.
08:13:46 <Twey> Try RWH.
08:14:11 <maartenm> arnar: insert with "o" ?
08:14:28 <Arnar> maartenm: I only tried with "i", hang on
08:14:31 <maartenm> arnar: it doesn't even jump to the correct identation level, with me, I always have to press TAB
08:14:40 <Arnar> maartenm: ah, no I mean in insert mode, when I press return
08:14:47 <Arnar> maartenm: ah, ok
08:15:00 <maartenm> I press TAB about a million times a day
08:15:08 <codebliss> It's alright.  I've finished most everything in the realm of beginners, I just need some time to wrap my head around this..
08:15:13 <Arnar> maartenm: but tab immediately starts cycling the indent levels (or it just inserts a tab/spaces)?
08:15:24 <maartenm> yeah, mine starts immediately!
08:15:39 <codebliss> My problem is I read a lot, and understand it, but I never really code anything.
08:15:44 <maartenm> and in the correct emacs manner
08:15:52 <maartenm> did you set the correct option in your .emacs?
08:15:56 <Badger> codebliss: I feel your pain.
08:16:08 <maartenm> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
08:16:16 <maartenm> (there are two haskell ident modes.. I only use this one)
08:16:25 <EvilTerran> codebliss, i found project euler to be a pretty entertaining way to get my familiarity with haskell up
08:16:30 <Arnar> maartenm: add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
08:16:30 <codebliss> I'm starting college this coming semester, so I guess I don't have enough experience to just know when/what to code...
08:16:32 <Arnar> yup
08:16:37 <codebliss> EvilTerran: I did about 10 of the euler problems in f#
08:16:49 <maartenm> and you didn't set the othe rone? (they fight each other)
08:16:50 <codebliss> Euler doesn't help with monads though.
08:16:50 <troutwine> I've got a non-trivial program segfaulting. What's the proper way to debug flakey Haskell programs of this sort? Do the usual C tools do the trick?
08:16:52 <Twey> codebliss: RWH has exercises
08:17:03 <codebliss> Twey: RWH and I are mortal enemies XD
08:17:12 <Twey> No, RWH loves you
08:17:15 <codebliss> I'm too much a theory junky.  I can't stand real world coding
08:17:15 <Twey> Let RWH into your heart
08:17:31 <MyCatVerbs> Twey: from a distance, with binoculars.
08:17:31 <Twey> Well, you're trying to do real-world coding now :-P
08:17:32 <codebliss> All the complication gives me headaches lol
08:17:33 <Twey> What happened?
08:17:35 <maartenm> I tried RWH to learn haskell.. I think it's one of the worst books ever written
08:17:38 <Badger> @where lyah
08:17:38 <lambdabot> www.learnyouahaskell.com
08:17:40 <Twey> MyCatVerbs: *grin*
08:17:40 <Badger> *ahem*
08:17:40 <Arnar> maartenm: don't think so.. looking at the haskell-mode/haskell-site-file
08:17:41 <codebliss> I hated RWH
08:17:43 <codebliss> I love LYAH
08:17:56 <Twey> You people are nuts
08:17:58 <maartenm> arnar: sorry, our mileage varies, it seems
08:18:02 * Badger chuckles
08:18:04 <codebliss> Hehe.  LYAH makes stuff click.
08:18:06 <Twey> Choosing fluff and elephants over RWH... *shakes head*
08:18:08 <Plouj> codebliss: why do you hate rwh?
08:18:15 <quicksilver> maartenm, Arnar : kuribas' indentation mode is much better than the haskell-mode one. It might not work in viper-mode.
08:18:16 <Arnar> maartenm: yub, nm.. thanks for the help
08:18:16 <MyCatVerbs> Twey: oh Hell, might as well make the other (cruder) joke. "Up close and by surprise too."
08:18:19 <Japsu> R'LYEH makes people click.
08:18:21 <paolino> :t (>>=)
08:18:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:18:25 <Badger> Twey: But it's got fluff! And elephants!
08:18:30 <Botje> Twey: don't forget the awesome list monster!
08:18:31 <codebliss> It doesn't click and it gives me headaches.  I've never even taken a programming class, of course I prefer a different enviornment XD
08:18:32 <lament> Choose fluff. Choose elephants. Choose LYAH.
08:18:37 <Arnar> quicksilver: kuribas'?  how can I tell which one I have?
08:18:39 <Twey> Botje: >.<
08:18:43 <Twey> The pain
08:18:45 <Twey> The pain
08:18:50 <quicksilver> maartenm: (I'm pretty sure one of the worst books is ever written is a fairly harsh exagerration)
08:18:56 <codebliss> I like pure theory, not real world (this should probably change soon lol)
08:18:58 <quicksilver> Arnar: you don't have it.
08:19:01 <Japsu> Choose madness. Choose tindaloos. Choose R'LYEH.
08:19:06 <quicksilver> @where kuribas-indentation
08:19:06 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
08:19:09 <Twey> Heck yes — a *serious* exaggeration.
08:19:11 <Japsu> ;P
08:19:26 <Twey> Obviously you folks have never tried any of the pre-RWH Haskell books.
08:19:27 <skorpan`> ooh, em dash
08:19:38 * EvilTerran prefers comical exaggeration to serious exaggeration
08:19:39 <skorpan`> you sure like your typography
08:19:40 <Arnar> quicksilver: any specific reason it wouldn't work in viper-mode? or just a hunch? .. I'll just try it
08:19:42 <maartenm> maybe it isn't that bad for a seasoned haskell developer
08:19:54 <maartenm> but for me it was horrible, structurally at least
08:19:56 <Twey> skorpan`: I enjoy it.
08:19:58 <Twey> skorpan`: *hug*.
08:20:12 <skorpan`> Twey: i like it as well, just never bothered setting it up
08:20:12 <Twey> maartenm: Odd
08:20:36 <maartenm> I am referring to the online version
08:20:37 <Twey> skorpan`: Ah, my input setup is kind of complicated anyway, for other, more practical reasons
08:20:38 <troutwine> Twey: I enjoyed Bird's, though it's a bit out of date now.
08:20:40 <quicksilver> Arnar: viper mode changes lots of stuff that intereferes with other modes, but it's just a hunch.
08:20:42 <Twey> So I figure I might as well.
08:21:12 <Twey> troutwine: Well, I was thinking freely-available resources
08:21:29 <troutwine> Twey: Ah, now that's a different matter.
08:21:30 <codebliss> I attribute most of my understanding to LYAH, blogs, and http://channel8.msdn.com/.  lol
08:22:08 <codebliss> I have an intro to cs class in java next semester =(
08:22:11 <codebliss> Smite me please.
08:22:17 <jkff> Bird is very cool in a certain sense; I've never seen another book so cool at showing the beauty and power of the functional approach
08:22:18 <codebliss> Java...the anti-haskell!
08:22:29 <Twey> troutwine: I'm a poor student.  :)
08:22:37 <jkff> codebliss: I code in Java for life. It's not that bad if you know how to cook it
08:22:45 <Twey> (again... yay)
08:22:49 <codebliss> jkff: What's Bird?
08:23:00 <jkff> Richard Bird, Introduction to Functional Programming Using Haskell
08:23:07 <codebliss> Ah.
08:23:26 <jkff> It has an emphasis on equational reasoning, deriving programs from specifications and proving properties of programs
08:24:02 <jkff> It has several examples starting from a very naive implementation and gradually being transformed with equational reasoning to very efficient ones. They're fascinating.
08:24:30 <codebliss> Is it a good idea to try and grasp advanced haskell concepts before I even take a programming class?  I'm probably going to be all confused when I hit up the books in a month.
08:24:58 <codebliss> I've done the C's etc, I just..they feel weird now lol
08:25:16 <jkff> You can give it a try. At worst, it will leave you with a feeling of their uselessness, because you don't have the experience to see use for them
08:25:30 <Twey> Just remember: that's fake.
08:25:35 <codebliss> Well I've done PLENTY of coding, just none of it was for a reason.
08:25:36 <Twey> Except in the case of arrows.
08:25:47 <jkff> If you want a pure feeling of uselessness, you can try to learn category theory :)
08:25:52 <Twey> Heh
08:26:31 <codebliss> I mean I love how haskell approaches scalability, I understand it.  I shouldn't at this age, cause I haven't really coded anything.  But I get it.
08:26:55 <codebliss> I just have no peers who will ever give a shit about hs XD
08:27:10 <jkff> Heh, get used to that until Haskell rules the world (hopefully soon :) )
08:27:14 <codebliss> I don't care if something works, I care how it works..
08:27:14 <Twey> Heh
08:27:27 <codebliss> I'm an anti script kiddie lmao
08:27:39 <Twey> codebliss: Rewrite their hundred-line Java homeworks in five lines of Haskell
08:27:43 <codebliss> LOL
08:27:43 <Twey> They'll soon get it
08:27:45 <dschoepe> jkff: world domination would conflict with "avoid success at all costs" though
08:28:09 <jkff> Twey: Many hundred-line java programs may be rewritten in ten lines of java, though.
08:28:20 <Twey> But not all
08:28:22 <codebliss> But haskell is pretty ingrained now.  Yes it's still following agile programming, but we have lots of content finished now
08:28:28 <jkff> Yes, and not if you don't know haskell :)
08:28:28 <Twey> Nor most, for that matter
08:28:34 <Twey> Heheh
08:28:57 <codebliss> cough*Monads are under Functors*cough
08:29:08 <codebliss> Well, I guess it would be over
08:29:13 <codebliss> Whatever, you get my point lol
08:29:18 * Twey chuckles.
08:29:20 <jkff> codebliss: seriously, if you *really* wish to understand that stuff well, you might consider learning category theory
08:29:40 <Twey> And getting a degree in pure maths
08:29:44 <jkff> You'll see that Haskell is not the final destination in terms of "how things are" (vs "whether they work")
08:29:53 <codebliss> I really don't care about getting stuff done lol.  Haskell should be my middle name
08:30:04 <Twey> Haskell cares about getting stuff done :)
08:30:13 <paolino> :t app
08:30:15 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
08:30:19 <codebliss> Welll, what's the point if in the end you never get anything done?  =P
08:30:40 <jkff> Monad is just a functor and 2 natural transformations (that's why it is, or could be, "under" Functor: class (Functor m) => Monad m). Or, it is just a monoid in the category of endofunctors :)
08:30:43 <paolino> > app ((+1),2)
08:30:45 <lambdabot>   3
08:30:48 <codebliss> I'll look into category theory, thanks
08:31:19 <codebliss> PS:  Stop scaring me!  =P
08:31:28 <jkff> codebliss: Try finding Barr and Wells, "Category Theory for Computing Science". There's not much computing science there, however, but the book is great.
08:31:43 <codebliss> Whenever I joke about haskell, I point and a friends code and say "That's an Applicative Functor."  Lmfao
08:32:30 <paolino> :t \f g -> ﻿State ((first (runState . g) >>> app)  .  runState f)
08:32:32 <lambdabot> lexical error at character '\65279'
08:32:32 <codebliss> jkff: I'll go shopping soon.  Working all day and being unable to walk doesn't help my coding lol
08:32:52 <jkff> I ordered the book from their website
08:33:12 <paolino> :t \f g -> State ((first (runState . g) >>> app) . runState f)
08:33:14 <lambdabot> forall a b d. State d b -> (b -> State d a) -> State d a
08:33:38 <codebliss> jkff: Is this good?  ( http://www.amazon.com/Categories-Computer-Science-Cambridge-Texts/dp/0521422264/ref=sr_1_3?ie=UTF8&s=books&qid=1247067193&sr=1-3 )
08:33:49 <codebliss> Maxed reviews.
08:34:06 <codebliss> Wait that's not category theory I don't think
08:34:13 <jkff> I bet that is
08:34:14 <codebliss> The book you said is unavailible, ouch.  Got some hunting to do
08:34:33 <codebliss> Wait, is this yours?  ( http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing/dp/0262660717/ref=sr_1_2?ie=UTF8&s=books&qid=1247067193&sr=1-2 )
08:35:00 <jkff> Don't know :) As for CT books, I only read half of Barr&Wells, most of Pierce ("Basic category theory for computer scientists") and started Mac Lane. Then I saw that I know too few abstract algebra, and am now crawling through Dummit+Foote
08:35:14 <jkff> http://www.cwru.edu/artsci/math/wells/pub/ctcs.html
08:35:22 <jkff> I The third edition is now available from Centre de recherches mathématiques, or by email to crmbooks@crm.umontreal.ca .
08:35:22 <jkff> I emailed them.
08:35:32 <codebliss> Ya, I came across that =P
08:35:36 <quicksilver> codebliss: you could watch the catsters videos
08:35:42 <quicksilver> if you like learning from videos
08:35:52 <codebliss> I learned some monad from videos, I don't mind
08:35:59 <quicksilver> I didn't really find any of the CT books useful for learning, per se.
08:36:09 <quicksilver> although they're good for reference + proofs of theorems.
08:36:09 <jkff> quicksilver: Thanks for the reminder, I've been wishing to watch them for a long time already.. /me turns on a video
08:36:12 <codebliss> This?  ( http://golem.ph.utexas.edu/category/2007/09/the_catsters_on_youtube.html )
08:36:41 <quicksilver> yes.
08:36:48 <codebliss> Alright, thanks.
08:37:06 <codebliss> I REALLY need to get gnome working on arch, I can't stand windows
08:37:22 <drhodes> there's a download utility for firefox called downloadHelper for videos
08:37:39 <jkff> Hey!! Seems like the catsters published a lot more lectures on youtube
08:37:51 <drhodes> to play with mplayer, for pause, quick rewind and slow motion.
08:38:20 <jkff> http://www.youtube.com/user/TheCatsters Aahh
08:38:28 <sayyestolife> is it only me who found those videoes extremly difficult to watch due to low-quality?
08:38:42 <drhodes> there is an HD version of those
08:38:48 <codebliss> LOL.  They said endofunctor with two naturals transformations.  Someone said that earlier =P
08:39:54 <EvilTerran> ...
08:40:29 * EvilTerran seems to know what that means. how peculiar.
08:40:34 <EvilTerran> functor on hask, with the natural transformations return and join?
08:40:45 <jkff> Yes
08:41:32 <codebliss> http://www.haskell.org/haskellwiki/Category_theory 's introduction actually makes sense
08:41:53 <Arnar> quicksilver: you were right.. kuribas' indentation mode does not work with viper
08:42:05 <codebliss> I mean section 1
08:42:06 <bnijk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6687#a6687
08:42:59 <quicksilver> Arnar: shame. It's much better.
08:43:08 <quicksilver> Arnar: try it with viper mode off just to see.
08:44:23 * jkff has a hard time decrypting Eugenia Cheng's fast speech
08:44:43 <wli> Who's Eugenia Cheng?
08:44:49 <jkff> The lecturer
08:45:00 <jkff> The Catster
08:45:22 <skorpan``> the MAN
08:45:35 <skorpan``> well... not literally.
08:45:38 <jkff> Well, in a category-theoretical sense
08:46:14 <jkff> Oh my, she's got 77 videos
08:46:47 <skorpan``> main = do
08:46:48 <skorpan``>   mpdcon <- mpdConnect "localhost" 6600
08:46:48 <skorpan``>   putStrLn "Connected!"
08:46:57 <skorpan``> will the middle line never be evaluated because of laziness?
08:47:08 <skorpan``> or is there some strictness magic that i'm not aware of?
08:47:21 <jkff> There's some strictness magic
08:47:53 <skorpan``> where can i find more about this ... thing.
08:48:04 <jkff> @source IO
08:48:05 <lambdabot> IO not available
08:48:07 <jkff> Hm
08:48:10 <skorpan``> hehe
08:48:24 <jkff> @google IO Inside
08:48:25 <mauke> @src IO
08:48:25 <lambdabot> http://www.haskell.org/haskellwiki/IO_inside
08:48:25 <lambdabot> Title: IO inside - HaskellWiki
08:48:26 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
08:48:29 <codebliss> +1 to http://www.haskell.org/haskellwiki/Category_theory/Monads .  Excellent article
08:48:31 <jkff> Yeah!
08:49:27 <codebliss> I remember in typeclassopedia I did a problem to define bind in terms of fmap and join.  Now I know why  =D
08:49:35 <Saizan_> skorpan``: laziness has generally nothing to do with effects done in IO, unless you use things implemented with unsafeInterleaveIO
08:49:49 <skorpan``> Saizan_: yeah, i just came to think of "putStr", which is never lazied away
08:49:59 <Saizan_> skorpan``: if the line is not printed immediately that's because of I/O bufgering
08:50:05 <Saizan_> *buffering
08:50:19 <quicksilver> skorpan``: laziness is explicitly about not bothering to calculate stuff when it's unobservable
08:50:33 <quicksilver> skorpan``: if it faield to do something observable, it would be quite a broken notion.
08:50:49 <quicksilver> (broken like, say, readFile and getContents are broken :P )
08:51:49 <codebliss> @t \a b -> join ((fmap b) a)
08:51:50 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:52:01 <codebliss> @type \a b -> join ((fmap b) a)
08:52:02 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => m a -> (a -> m a1) -> m a1
08:52:36 <jkff> @pl \a b -> join ((fmap b) a)
08:52:36 <lambdabot> (join .) . flip fmap
08:52:58 <codebliss> I know, that's just the easiest to understand, but the ugliest
08:53:16 <jkff> That's why it's called pl = pointless :)
08:53:23 <codebliss> I know =D
08:53:25 <skorpan``> @pl \a b -> join (b <$> a)
08:53:26 <lambdabot> (join .) . flip (<$>)
08:53:32 <codebliss> Hey, sometimes it gives useful code!  =P
08:54:18 <bnijk> HACK THE PLANET
08:54:37 <roconnor> They are trashing our rights!
08:54:41 <codebliss> @pl \a b c -> ((,) a (flip (/) b c),show b)
08:54:42 <lambdabot> (`ap` show) . ((flip . ((,) .)) .) . (. flip (/)) . (.) . (,)
08:54:46 <codebliss> XD
08:54:54 <Rembane> :)
08:54:57 <codebliss> I love haskell.
08:55:16 <bnijk> everyone loves haskell
08:55:16 <codebliss> > (`ap` show) . ((flip . ((,) .)) .) . (. flip (/)) . (.) . (,) $ 3 4 5
08:55:18 <lambdabot>   Add a type signature
08:55:21 <codebliss> Damn!
08:55:24 <codebliss> XD
08:55:25 <bnijk> but haskell ain't for videos games
08:55:29 <bnijk> ain't that a kick in the head ./`
08:55:50 <codebliss> Buuuut.  getHealth :: Player -> Health, map getHealth getPlayers.  !
08:55:51 <codebliss> =P
08:55:53 <maartenm> man those J solution for the Euler problems
08:55:55 <maartenm> what the hell
08:55:57 <roconnor> > ((`ap` show) . ((flip . ((,) .)) .) . (. flip (/)) . (.) . (,)) 3 4 5
08:55:58 <lambdabot>   ((3,1.25),"4.0")
08:56:05 <bnijk> can we have a euler problem marathon here
08:56:07 <bnijk> would that be ok
08:56:10 <codebliss> A very useful function indeed.
08:56:34 <bnijk> mmnn... http://projecteuler.net/index.php?section=problems
08:56:56 <codebliss> Alright I'm working on a monad that threads generated programming languages as the state, wish me luck!
08:57:08 * jkff solved 104 and doesn't understand how people solve 252
08:57:10 <codebliss> XD
08:57:26 <bnijk> http://projecteuler.net/index.php?section=problems&id=5
08:57:30 <bnijk> what's the best way to solve that
08:57:39 <mauke> brute force
08:57:41 <bnijk> my first idea is to just iterate blindly and test for equality
08:57:43 * mauke clicks the link
08:57:45 * jkff has a colleague who solved 247
08:57:47 <bnijk> there's no better way?
08:58:04 <jkff> Ehm, it's called "least common multiple"
08:58:08 <jkff> :t gcd
08:58:10 <lambdabot> forall a. (Integral a) => a -> a -> a
08:58:10 <bnijk> orly
08:58:15 <mauke> > lcm [1 .. 20]
08:58:16 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
08:58:16 <lambdabot>    arising from a use ...
08:58:21 <mauke> oh
08:58:31 <idnar> @type lcm
08:58:33 <lambdabot> forall a. (Integral a) => a -> a -> a
08:58:35 <mauke> > foldl' lcm 1 [1 .. 20]
08:58:36 <lambdabot>   232792560
08:58:45 <bnijk> > foldl' lcm 1 [1 .. 10]
08:58:47 <lambdabot>   2520
08:58:47 <bnijk> just to check
08:58:52 <maartenm> bnijk: there is a better way
08:58:57 <bnijk> what is it maartenm
08:59:05 * jkff gets distracted too much by the talk on #haskell from Catsters and has to quit
08:59:09 <maartenm> you'll learn once you solve the problem
08:59:13 <mauke> bnijk: collect prime factors, multiply
08:59:21 <bnijk> i thought it was something like that
08:59:26 <mauke> I think I could that on paper
08:59:31 <bnijk> let's see...problem...20
08:59:31 <bnijk> !
08:59:39 <bnijk> > foldl (+) 1 [1..100]
08:59:41 <lambdabot>   5051
08:59:44 <bnijk> nifty
09:00:33 <mauke> > sum [1 .. 100]
09:00:35 <lambdabot>   5050
09:00:43 <mauke> > product [1 .. 7]
09:00:45 <lambdabot>   5040
09:00:46 <bnijk> > foldl (+) 0 [1..100]
09:00:47 <lambdabot>   5050
09:00:50 <bnijk> see haskell
09:00:51 <bnijk> has all these functions
09:00:55 <jleedev> > product [0..]
09:00:55 <bnijk> o.o
09:01:00 <lambdabot>   mueval-core: Prelude.read: no parse
09:01:00 <lambdabot>  mueval: ExitFailure 1
09:01:01 <doserj> bnijk: that doesn't solve problem 20, though
09:01:08 <bnijk> oh sum of DIGITS
09:01:15 <bnijk> oops
09:01:23 <bnijk> i thought it was a bit too easy
09:01:38 <mauke> > sum . map digitToInt . show . product $ [1 .. 100]
09:01:40 <lambdabot>   648
09:01:45 <bnijk> so what do you have to do there...do 100!
09:01:59 <bnijk> and then turn it into a string and piece apart each number?
09:02:06 <mauke> yeah, basically
09:02:07 <bnijk> or you could do x mod 10, divide by ten
09:02:18 <mauke> you have to turn each Char into a number somehow
09:02:22 <mauke> so you can add them up
09:02:25 <bnijk> yes
09:02:48 <pikhq> > (100/2)*(2+(100-1))
09:02:49 <lambdabot>   5050.0
09:02:53 <bnijk> > map ord [1..255]
09:02:54 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
09:02:55 <lambdabot>    arising from the literal `1...
09:02:59 <bnijk> > map chr [1..255]
09:03:00 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\E...
09:03:04 <pikhq> Better solutions through smart math.
09:03:05 <bnijk> stupid lambdabot
09:03:28 <mauke> bnijk: btw, did you really not notice the solution I gave above?
09:03:46 <bnijk> oh geez
09:03:48 <bnijk> ok
09:03:49 <maartenm> btw please stop spoiling the euler solutions
09:03:59 * bnijk opens ghci
09:04:17 <mauke> aww, just the easy ones?
09:04:23 <maartenm> the easy ones are fine
09:04:35 <bnijk> > sum (map (\x->x**x) [1..1000])
09:04:37 <lambdabot>   Infinity
09:04:41 <bnijk> infinity??
09:04:59 <mauke> yep
09:05:07 <bnijk> am i missing something
09:05:09 <mauke> that's caused by **
09:05:17 <bnijk> > sum (map (\x->x^x) [1..1000])
09:05:18 <pikhq> Which is code for "very large number".
09:05:19 <lambdabot>   100036819914469517709537501122764679556779368062293465458376098810023491074...
09:05:26 <bnijk> > sum (map (\x->x^x) [1..10])
09:05:28 <lambdabot>   10405071317
09:05:29 <bnijk> excellent
09:05:40 <bnijk> haskell + project euler = entertaining
09:05:49 <mauke> > sum (map (\x->x**x) [1..1000]) :: CReal
09:05:54 <lambdabot>   mueval-core: Prelude.read: no parse
09:05:55 <lambdabot>  mueval: ExitFailure 1
09:05:58 <mauke> hah, too slow
09:06:00 <pikhq> Yeah, Haskell's a really good language for it.
09:07:27 <jleedev> > sum $ unfoldr (\x -> case divMod x 10 of (0,0) -> Nothing; (q,r) -> Just (r,q)) (product [1..100]
09:07:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:07:39 <jleedev> > sum $ unfoldr (\x -> case divMod x 10 of (0,0) -> Nothing; (q,r) -> Just (r,q)) (product [1..100]))
09:07:40 <lambdabot>   <no location info>: parse error on input `)'
09:07:45 <jleedev> > sum $ unfoldr (\x -> case divMod x 10 of (0,0) -> Nothing; (q,r) -> Just (r,q)) (product [1..100])
09:07:46 <lambdabot>   648
09:07:48 <jleedev> (sorry)
09:09:28 <bnijk> > [1..10^9}
09:09:29 <bnijk> > [1..10^9]
09:09:29 <lambdabot>   <no location info>: parse error on input `}'
09:09:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:09:33 <bnijk> good
09:09:53 <lilac> > [1 .. 0]
09:09:54 <lambdabot>   []
09:10:33 <bnijk> i wonder how to solve 204
09:10:38 <pikhq> > [10^9,10^9-1,..0]
09:10:40 <lambdabot>   <no location info>: parse error on input `..'
09:10:45 <pikhq> > [10^9,10^9-1..0]
09:10:47 <lambdabot>   [1000000000,999999999,999999998,999999997,999999996,999999995,999999994,999...
09:10:49 <wli> 204?
09:10:57 <bnijk> problem 204 on euler
09:10:59 <pikhq> bnijk: With a 404.
09:11:05 <bnijk> good one pikhq
09:20:46 <lilac> lazy fifo monad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6688#a6688
09:20:54 <lilac> like a normal fifo, but it can pop values you've not pushed yet
09:22:07 <EvilTerran> lilac, hehe, nice
09:22:27 * EvilTerran attempts to work out how it works
09:23:49 <EvilTerran> lilac, why case/of instead of let/in? strictness?
09:24:24 <EvilTerran> (for the tuple pattern-matching, i mean)
09:24:47 <lilac> EvilTerran: for no good reason at all. i've already changed it to 'let' in my local version
09:25:08 <lilac> EvilTerran: too much looking at core
09:25:21 <EvilTerran> ah
09:25:35 <EvilTerran> > (\x -> y where y = x*x) 2
09:25:37 <lambdabot>   <no location info>: parse error on input `where'
09:26:01 <EvilTerran> aww
09:26:18 <byorgey> lilac: heh, that's pretty cool =)
09:26:24 <byorgey> lilac: what are you using it for?
09:26:46 <anders^^> is there some extension to haskell that allows same selector name for different records?
09:27:04 <anders^^> right now i get an Multiple declaration error
09:27:08 <lilac> byorgey: just thought it'd be fun. i don't have a use case yet ;-)
09:27:17 <byorgey> ah, ok =)
09:27:31 <lilac> obviously i'm now looking for the most obscure way to write fibonacci in it
09:28:04 <lilac> mostly i was looking for a way to generalize the state and reverse state monads
09:28:07 <byorgey> anders^^: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
09:28:33 <anders^^> byorgey: thanks!
09:28:53 <quicksilver> by the way, don't use that extension.
09:29:03 <quicksilver> it is a poor compromise which doesn't solve the problem.
09:29:06 <doserj> it won't help anders^^ anyways
09:29:42 <quicksilver> You should think of a record field name as a selector - that is, a function.
09:30:00 <quicksilver> You would not try to define two functions with the same name, like "x :: Bar -> Int" and "x :: Baz -> Int".
09:30:11 <quicksilver> and that's all a field name is. It's a function name.
09:30:25 <lilac> perhaps a better extension would be DontGenerateSelectorsForFields
09:30:41 <quicksilver> Either use unique names (like you do for all other functions), put them in separate modules, or...
09:30:49 <Heffalump> lilac: you'd still have name clash problems for updaters, though
09:30:57 <anders^^> quicksilver: ah ok, thanks
09:30:59 <Heffalump> quicksilver: what we need is multiple modules per file
09:31:06 <quicksilver> ...if you *really* want to overload 'x', do "class HasX a where x :: a -> Int"
09:31:06 <byorgey> yes!!
09:31:18 <quicksilver> Heffalump: and nested modules and local modules.
09:31:21 <quicksilver> Heffalump: yes, that would help a bit.
09:31:23 <wli> > let primes = 2 : 3 : 5 : [p | p <- [7,9..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q*q <= p) primes)] ; hams n = let ps = takeWhile (<= n) primes ; hs = 1 : foldr1 merge [map (p*) hs | p <- ps] in hs ; merge ~(x:xs) ~(y:ys) = case x `compare` y of { LT -> x : merge xs (y:ys) ; GT -> y : merge (x:xs) ys ; EQ -> x : merge xs ys } in take 250 $ hams 100
09:31:24 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:31:33 <lilac> Heffalump: i didn't realise type inference would infer record types from fields, but in retrospect that's obvious :)
09:31:35 <wli> quicksilver: Yeah, those would help a bit.
09:32:11 <quicksilver> lilac: I don't know how important that inference is. Maybe we could drop that too.
09:32:25 <Petrosian> Hmm, what about an extension to turn selectors into overloaded functions, rather than monomorphic functions?
09:32:32 <Heffalump> quicksilver: what's a nested module?
09:32:44 <Heffalump> Petrosian: using an implicit MPTC?
09:32:56 <quicksilver> lilac: so "a { x = 1 }" is simply an error, if "a"'s type can't be inferred.
09:32:58 <Petrosian> Heffalump: Something along those lines, ye
09:33:09 <Petrosian> I suppose disambiguation might be a problem
09:33:12 <Heffalump> quicksilver: that sounds pretty weird
09:33:20 <quicksilver> Heffalump: module Foo where { module Bar where { .. }; ... }
09:33:40 <quicksilver> Heffalump: in which, module Bar is only visible inside Foo unless, of course, Foo chooses to export some of Bar's symbols, or possibly the whole module.
09:33:42 <Heffalump> take a look at F# for how abandoning type inference to help with name resolution makes things ugly
09:33:58 <Heffalump> quicksilver: ah. That sounds like a complication of the module system.
09:34:04 <Heffalump> multiple modules in a file isn't :-)
09:34:10 <quicksilver> sure.
09:34:10 * jkff has watched the lectures on Monads
09:34:15 <quicksilver> my proposal was much more substantial than yours.
09:34:22 <Heffalump> local modules are also a complication though only minor, if by them you just mean implicit prefixing of the namespace
09:34:26 <quicksilver> although really it's just namespace shuffling, I don't think it's deep.
09:34:28 <lilac> i think i'm being dumb. how does mutltiple modules in a file help?
09:34:29 <jkff> Hey, can anyone tell me if (Float, mean) are an algebra for the monad of statistical distributions?
09:34:55 <Heffalump> lilac: you can start a new module to define each record type, thus getting qualified names for the selectors
09:35:03 <Heffalump> without it being really really painful
09:35:03 <quicksilver> Heffalump: by local modules I mean "foo = let module Bar where { ... } in <defn of foo which has Bar in scope>
09:35:10 <Heffalump> quicksilver: oh, ok :-0
09:35:11 <jkff> Heh, probably I should just quickcheck it
09:35:28 <jkff> And looks like the second law is violated.
09:35:48 <quicksilver> Heffalump: but it really is just mucking about with namespaces
09:36:02 <quicksilver> Java does it all by sticking hidding "$" into type names
09:36:12 <quicksilver> (inner classes, local classes, anonymous classes)
09:36:34 <Heffalump> oh, right, just making mangled names
09:36:40 <Heffalump> mangled and obscure
09:37:26 <quicksilver> sure, but that doesn't matter as long as we unmangle them for the user.
09:37:27 <lilac> quicksilver: do you actually want 'module' here or just 'namespace'?
09:37:38 <quicksilver> lilac: what is a haskell module other than a namespace?
09:37:46 <lilac> it also has a program-wide name
09:38:03 <quicksilver> yes, these ones wouldn't have that.
09:38:09 <quicksilver> unless you exported them.
09:38:10 <lilac> and rules for what to do with type class instances
09:38:17 <quicksilver> type class instances are global.
09:38:20 <quicksilver> Anything else is heresy.
09:38:34 <quicksilver> Attempting to use my extension for local type class instances would be a burning-at-the-stake sin.
09:38:40 <lilac> global but not always in scope
09:38:46 * quicksilver nods
09:39:41 <bnijk> ok wait, what function converts int to string representation of that int, and binary as well
09:39:49 <bnijk> binary to string representation of that binary, that is
09:39:56 <lilac> don't we want global names for these modules? otherwise you couldn't use the conflicting selectors outside of the file
09:40:06 <quicksilver> solving different problems.
09:40:18 <quicksilver> Heffalump's was jsut multiple modules in one file (at the top level)
09:40:28 <dmwit> bnijk: show?
09:40:29 <quicksilver> those would indeed have global names.
09:40:34 <bnijk> > show 243
09:40:36 <lambdabot>   "243"
09:40:37 <lilac> that would have problems with ghc --make, too
09:40:39 <quicksilver> I was just saying "If we're messing with this stuff, it would also be nice to have...."
09:40:46 <lilac> *nod*
09:40:54 <monochrom> bnijk: “show i” gives decimal. Do you want something different?
09:40:56 <quicksilver> an inner module might end up exported
09:41:01 <quicksilver> if you export it "up" the tree
09:41:07 <bnijk> i want dec and binary
09:41:10 <Heffalump> actually, my proposal wouldn't help much unless there was some sane way to import the extra modules in the "main" module of the file
09:41:15 <quicksilver> but I guess it would be qualified relative to its owning global.
09:41:17 <monochrom> binary as in "01011011"?
09:41:20 <bnijk> yes
09:41:33 <quicksilver> > showIntAtBase 2 9 ""
09:41:34 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
09:41:34 <lambdabot>    arising from a use ...
09:41:34 <lilac> if dealing with multiple files is too onerous, that sounds like an editor issue rather than an issue with how the language is serialized into the filesystem
09:41:42 <quicksilver> :t showIntAtBase
09:41:43 <bnijk> no no
09:41:46 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
09:41:51 <bnijk> ok well
09:41:57 <quicksilver> > showIntAtBase 2 intToDigit 9 ""
09:41:58 <lambdabot>   "1001"
09:42:04 <bnijk> i'm trying to compute the sum of all numbers palindromic in base 10 and 2 up to 1 million
09:42:18 <bnijk> so i'm trying to do it via list comprehension
09:42:28 <bnijk> where i can test it  via string reverse = string
09:42:50 <quicksilver> > let asBinary n = showIntAtBase 2 intToDigit n "" in (asBinary 9) == reverse (asBinary 9)
09:42:52 <lambdabot>   True
09:42:57 <quicksilver> bnijk: like that :)
09:43:45 <bnijk> what is binary 9...1001
09:43:48 <bnijk> 101
09:43:50 <bnijk> =-o
09:44:07 <bnijk> too tired to think
09:45:12 <bnijk> ok let's see
09:45:30 <osfameron> how do you write 'let' on a single line?
09:45:49 <bnijk> @define asBinary n = showIntAtBase 2 intToDigit n ""
09:45:59 <bnijk> @let asBinary n = showIntAtBase 2 intToDigit n ""
09:46:01 <lambdabot>  Defined.
09:46:13 <bnijk> then...
09:47:00 <dmwit> osfameron: let { x = y; w = z } in ...
09:47:14 <bnijk> > [x | x <- [1..10^6], reverse asBinary x = asBinary x && reverse show x = show x]
09:47:15 <osfameron> hmmm... that's what I thought... I must have another error... thanks :-)
09:47:16 <lambdabot>   <no location info>: parse error on input `='
09:47:24 <bnijk> > [x | x <- [1..10^6], reverse asBinary x == asBinary x && reverse show x == show x]
09:47:26 <lambdabot>   Couldn't match expected type `[a]'
09:47:32 <dmwit> osfameron: With guards, let { x | a = y | b = z; y = t } in ...
09:47:35 <bnijk> how do i say "and" in an equality test
09:47:54 <dmwit> bnijk: reverse (asBinary x) == ...
09:48:08 <dmwit> bnijk: Otherwise you're applying "reverse" to "asBinary", and then to "x".
09:48:12 <bnijk> > [x | x <- [1..10^6], reverse (asBinary x) == asBinary x && reverse (show x) == show x]
09:48:18 <lambdabot>   mueval-core: Prelude.read: no parse
09:48:18 <lambdabot>  mueval: ExitFailure 1
09:48:35 <bnijk> mmnnn
09:48:52 <bnijk> > [x | x <- [1..10^6], reverse (asBinary x) == asBinary x, reverse (show x) == show x]
09:48:57 <dmwit> Are there any such numbers?
09:48:57 <lambdabot>   mueval-core: Prelude.read: no parse
09:48:58 <lambdabot>  mueval: ExitFailure 1
09:49:02 <bnijk> dmwit: yes
09:49:06 <bombshelter13_> bnijk: like 'and [True, True]'?
09:49:25 <bnijk> no like if (... && ...) in C-likes
09:49:30 <bnijk> you know
09:49:35 <bombshelter13_> yeah
09:49:49 <bnijk> k
09:49:54 <bnijk> what is it then, 'and'?
09:50:01 <bnijk> > [x | x <- [1..10^6], reverse (asBinary x) == asBinary x and reverse (show x) == show x]
09:50:04 <lambdabot>   Precedence parsing error
09:50:04 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
09:50:07 <bnijk> =-o
09:50:26 <dmwit> > let palindrome = ap (==) reverse; special = all palindrome . sequence [asBinary, show] in special 0
09:50:27 <bombshelter13_> bnijk: let x = 7 in and [5 < x, 10 < x]
09:50:28 <lambdabot>   True
09:50:33 <bombshelter13_> bnijk: and is not an infix operator
09:50:45 <dmwit> bnijk: What's another example of a bi/dec palindrome?
09:50:49 <monochrom> > 2==2 && 3==3
09:50:51 <bnijk> > [x | x <- [1..10^6], and [reverse (asBinary x) == asBinary x, reverse (show x) == show x]]
09:50:51 <lambdabot>   True
09:50:56 <lambdabot>   mueval-core: Prelude.read: no parse
09:50:56 <lambdabot>  mueval: ExitFailure 1
09:50:57 * SamB wishes aptitude would show what distribution (etch,squeeze/testing,sid) a package is offered by
09:51:09 <bnijk> o.o
09:51:25 <monochrom> Sigh.
09:51:25 <bombshelter13_> 'and [bool1, bool2]' makes sense... 'bool1 and bool2' is meaningless
09:51:30 <bnijk> > [x | x <- [1..10^6], reverse (asBinary x) == asBinary x && reverse (show x) == show x] -- so why doesn't this work
09:51:34 <monochrom> 2==2 && 3==3   ignore all other people.
09:51:36 <lambdabot>   mueval-core: Prelude.read: no parse
09:51:36 <lambdabot>  mueval: ExitFailure 1
09:52:08 <lilac> dmwit: 1, 3, 5, 7 are all palindromic in base 2 and 10
09:52:21 <dmwit> > let palindrome = ap (==) reverse; special = all palindrome . sequence [asBinary, show] in filter special [1..10]
09:52:23 <lambdabot>   [1,3,5,7,9]
09:52:50 <bnijk> > let palindrome = ap (==) reverse; special = all palindrome . sequence [asBinary, show] in filter special [1..10^6]
09:52:55 <monochrom> > [x | x <- [1..10], reverse (asBinary x) == asBinary x && reverse (show x) == show x]
09:52:56 <lambdabot>   [1,3,5,7,9,33,99,313,585,717,7447,9009,15351,32223,39993,53235,53835,73737,...
09:52:57 <lambdabot>   [1,3,5,7,9]
09:52:58 <bnijk> > sum palindrome
09:52:59 <lambdabot>   Not in scope: `palindrome'
09:53:04 <bnijk> eep
09:53:20 <rovar> greetings
09:53:29 <monochrom> It works.
09:53:32 <bnijk> where's the sum get jammed in, let's see
09:53:37 <bnijk> why doesn't mine work though monochrom
09:53:47 <bnijk> :t ap
09:53:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:53:57 <monochrom> number too big?
09:54:02 <lilac> hmm, there are ony 19 of them
09:54:04 <monochrom> Takes too long?
09:54:11 <rovar> i'm going through the 20 intermediate exercises that have been so popular lately.. althought I don't consider myself intermediate quite yet.
09:54:15 <bnijk> worthless lambdabot
09:54:15 <lilac> those 18 plus 858858
09:54:18 <monochrom> > last [1..10^6]
09:54:19 <rovar> mostly because I'm stuck on #1
09:54:19 <lambdabot>   1000000
09:54:24 <lilac> > sum $ filter (\n -> show n == reverse (show n) && asBinary n == reverse (asBinary n)) [1..1000000]
09:54:28 <lambdabot>   872187
09:54:53 <monochrom> > length [x | x <- [1..10^6], reverse (asBinary x) == asBinary x && reverse (show x) == show x]
09:54:58 <lambdabot>   mueval-core: Prelude.read: no parse
09:54:58 <lambdabot>  mueval: ExitFailure 1
09:55:08 <rovar> with [] being the instance of Fluffy, how do I apply [] to a ?
09:55:40 <monochrom> > length [x | x <- [1..10^5], reverse (asBinary x) == asBinary x && reverse (show x) == show x]
09:55:43 <lambdabot>   18
09:56:06 <lilac> > length $ filter (\n -> show n == reverse (show n) && asBinary n == reverse (asBinary n)) [1..1000000]
09:56:11 <lambdabot>   19
09:56:20 <rovar> heh
09:56:25 <monochrom> I think it takes too long.
09:56:31 <dmwit> bnijk: Your computation probably just ran out of time.  It takes a while to run here.  (whereas my ap (==) reverse one should go roughly twice as fast, since it calls show about half as many times)
09:56:38 <lilac> filter and list comprehension enter. only filter leaves
09:56:42 <bnijk> oic
09:56:43 <codebliss> Category theory is brutal.
09:56:48 <bnijk> lol lilac
09:57:04 <bnijk> there can be only one
09:57:14 <lilac> dmwit: i don't think it's that. mine works and calls show twice
09:57:25 * dmwit shrugs
09:57:30 <dmwit> His code works in ghci just fine.
09:57:59 <lilac> > length $ [n | n <- [1..1000000],  show n == reverse (show n) && asBinary n == reverse (asBinary n)]
09:58:05 <lambdabot>   19
09:58:08 <lilac> ah, duh
09:58:23 <lilac> the show check rules out many more than the asBinary check (and is probably faster)
09:59:20 <lilac> > length [n | n <- [1..1000000], show n == reverse (show n)]
09:59:26 <lambdabot>   1998
09:59:30 <lilac> > length [n | n <- [1..1000000], asBinary n == reverse (asBinary n)]
09:59:36 <lambdabot>   mueval-core: Prelude.read: no parse
09:59:36 <lambdabot>  mueval: ExitFailure 1
09:59:42 <lilac> > length [n | n <- [1..100000], asBinary n == reverse (asBinary n)]
09:59:45 <lambdabot>   644
10:00:31 <dmwit> But... mine checks isBinary first.
10:00:38 <dmwit> asBinary
10:00:56 <bnijk> > sum (map (\n -> (ord n)-48) (show (product [1..100])))
10:00:57 <lambdabot>   648
10:01:18 <bnijk> that is correct right, sum of all digits in 100! ?
10:01:30 <dmwit> > chr '0'
10:01:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:01:36 <dmwit> > ord '0'
10:01:38 <lambdabot>   48
10:01:41 <dmwit> looks right
10:01:49 <dmwit> :t digitToInt -- better than your \n -> hack
10:01:50 <lambdabot> Char -> Int
10:01:58 <bnijk> i was trying to figure out
10:02:01 <bnijk> what the deal was with that o.o
10:02:05 <bnijk> > digitToInt '3'
10:02:07 <lambdabot>   3
10:02:13 <bnijk> damn i was using double quotes
10:02:21 <dmwit> > sum . map digitToInt . show $ product [1..100]
10:02:22 <lambdabot>   648
10:02:24 <bnijk> > map digitToInt "3"
10:02:25 <lambdabot>   [3]
10:02:31 <bnijk> no wonder
10:03:18 <dmwit> > sum . map digitToInt . asBinary $ product [1..100]
10:03:20 <lambdabot>   207
10:03:33 <bnijk> > sum . map digitToInt . show $ 2^1000
10:03:35 <lambdabot>   1366
10:03:48 <bnijk> > 2^1000
10:03:50 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
10:04:17 <lilac> > length [n | n <- [1..1000000], let a = asBinary n in a == reverse a]
10:04:22 <lambdabot>   mueval-core: Prelude.read: no parse
10:04:23 <lambdabot>  mueval: ExitFailure 1
10:04:34 <bnijk> what's a quick prime number tester in haskell
10:04:37 <dmwit> > last (show (2^1000)) -- probably times out
10:04:39 <lambdabot>   '6'
10:04:43 <dmwit> whop
10:04:56 <bnijk> i suppose you can find the square root of a number and test every number less than or equal to it for clean division
10:05:00 <bnijk> anything better?
10:05:06 <bnijk> (excluding negative numbers)
10:05:13 <bnijk> and all ints =-o
10:05:18 <dmwit> Yes, check the wiki and/or hackage.
10:05:40 <bnijk> =-o
10:06:44 <lilac> bnijk: it's better to do: \n -> any (\m -> n `mod` m == 0) $ takeWhile (\m -> m * m <= n) [1..n]
10:07:04 <lilac> bnijk: where 'better' depends on how big numbers you want to deal with
10:07:13 <bnijk> depends in which way
10:07:15 <lilac> taking the square root has problems
10:07:16 <bnijk> that's best for bigger ones?
10:07:37 <bnijk> problems in efficiency? or inaccuracies?
10:07:43 <lilac> for very small numbers, square root will be slower than squaring, and for very big numbers square root will be inaccurate
10:08:02 <bnijk> inaccurate why?
10:08:05 <lilac> also, use 2:[3,5..] not [1..]
10:08:19 <lilac> bnijk: well, it depends what square root method you use
10:09:07 <lilac> using sqrt on Double is probably fine for integers up to about 53 bits
10:09:13 <bnijk> @let primes :: [Integer]; primes = sieve [2..]; where sieve (p:xs) = p : sieve [x | x<-xs, x`mod` p /= 0]
10:09:13 <lambdabot>   Parse error
10:09:22 <lilac> (ie much bigger than you want to be exhaustively testing)
10:09:36 <bnijk> so many sieves, so little time
10:09:42 <bgs100> Hi. I'm thinking of trying either Haskell, erlang, or OCaml.
10:09:50 <bnijk> try haskell
10:10:37 <jmcarthur> if you are looking for bias, you will find plenty here :)
10:10:38 <lilac> > take 10 $ nubBy (((==0).).mod) [2..]
10:10:40 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
10:11:28 <bnijk> what jmcarthur said
10:12:05 <bgs100> Well, I'm wondering, what would be some advantages of using haskell over erlang/OCaml?
10:12:07 <lilac> bgs100: What properties are you looking for in your language of choice?
10:12:09 <bnijk> :t nubBy
10:12:10 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
10:12:16 <paolino> bgs100: erlang for concurrency, ocaml for speed , haskell for the rest
10:12:25 <jmcarthur> bgs100: it is my opinion that the real question is between haskell and ocaml, as i think erlang is very different from the other two. it's worth learning erlang either way ;)
10:12:35 <jmcarthur> paolino: it has not been my experience that ocaml is really any faster
10:12:57 <lilac> the shootout indicates that carefully-tweaked haskell programs can be faster than ocaml
10:12:57 <jmcarthur> bgs100: that said, i strongly prefer haskell over ocaml
10:13:20 <paolino> jmcarthur: is erlang good foor concurrency ? :P
10:13:22 <bnijk> i still don't really understand monads
10:13:46 <jmcarthur> paolino: for a particular kind of concurrency, of course...
10:13:53 <lilac> bnijk: try this: metafoo.co.uk/practical-monads.txt
10:14:12 <drhodes> or this: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
10:15:10 <jmcarthur> my "monad tutorial" has shortened to "look at the type signatures and the laws" :\
10:15:13 <bgs100> I don't really know what properties I'm looking for (as long as it's not too slow, I'm good ;)). I come from Python and Common Lisp (which I enjoyed very much)
10:15:41 <paolino> jmcarthur: I suppose usually ocaml is faster because it's less prone to wonderful abstractions
10:16:03 <jmcarthur> paolino: assembly is faster, too ;)
10:16:16 <jmcarthur> "faster"
10:16:30 <bnijk> just think of zsnes
10:16:37 <bnijk> that's one hell of a program, and it's like 60% assembly
10:16:37 <Heffalump> also it's generally (but not always) faster to calculate things that will eventually be needed early
10:16:43 <jmcarthur> bgs100: if you want abstraction, you definitely definitely want haskell
10:16:46 <Peaker> bnijk: what part do you understand and what part don't you?
10:16:54 <bnijk> Peaker: of monads?
10:16:58 <Peaker> bnijk: yeah
10:17:03 <bnijk> i understand they're there to handle side-effects
10:17:06 <Heffalump> so the strict-by-default evaluation strategy wins, at the cost of forcing the programmer to think more about what will be actually needed (and weakening compositionality in some ways)
10:17:07 <bnijk> i don't understand how they're used in haskell
10:17:10 <bnijk> syntactically
10:17:29 <Heffalump> bnijk: normally the syntax associated with monads is do-notation
10:17:29 <Peaker> bnijk: well, syntactically, there's just "do notation" and normal infix operators, and a normal function
10:17:36 <jmcarthur> bnijk: do you understand Functor?
10:17:39 <bnijk> no
10:17:42 <Heffalump> but you don't have to use it, you can just use the operators directly
10:17:44 <jmcarthur> :t fmap
10:17:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:17:47 <Peaker> bnijk: "do" notation is just sugar for binding a bunch of statements together into a larger statement
10:17:54 <Peaker> bnijk: using the >> and >>= operators
10:18:12 <bnijk> i thought the point of do was to put imperative order into functional code
10:18:27 <jmcarthur> common misconception
10:18:31 <jmcarthur> in my opinion
10:18:37 <Peaker> bnijk: that's one use of Monads, but Monad is a really really general idea that's applicable to many other things too
10:19:00 <Peaker> bnijk: its probably better to understand IO (the thing that gives imperative ordering) separately from understanding general Monads
10:19:02 <bnijk> i know that Peaker ;)
10:19:06 <Heffalump> bnijk: the point of >>= is to align the ordering of effects with the dataflow
10:19:10 <Heffalump> @type (>>=)
10:19:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:19:14 <burp> don't start with IO monad
10:19:18 <burp> forget about it first ;)
10:19:21 <paolino> jmcarthur: one thing I would like to see is some "notation" for erlang style programming in haskell
10:19:24 * bnijk forgets about it
10:19:28 <Heffalump> here the dataflow is from m a into (a -> m b)
10:19:35 <jmcarthur> paolino: what do you mean?
10:19:38 <Heffalump> and the effects of the first argument will also happen first
10:19:57 * bnijk stares
10:19:59 <Peaker> bnijk: do you know types and type constructors?
10:20:00 <Heffalump> (note that effect is a very general term here, and can encompass such things as exceptions and non-determinism)
10:20:10 <Peaker> bnijk: e.g: The difference between [] and [a] and [] a?
10:20:19 <bnijk> what is [] a
10:20:36 <paolino> jmcarthur: message matching , I guess
10:21:04 <paolino> jmcarthur: hiding threads
10:22:30 <bgs100> ok, thanks
10:22:52 <jmcarthur> paolino: wait.. how does erlang hide threads?
10:22:58 <paolino> jmcarthur: erlang distributes load transparently
10:23:07 <rovar> am I on the right track?  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2953#a2953
10:23:32 <rovar> unfortunately i'm not near a repl
10:23:41 <Beelsebob> rovar: you might want to consider lists with a number of elements that is not 1
10:23:50 <rovar> good idea
10:23:51 <Beelsebob> what's furry f []?
10:23:56 <Beelsebob> and what's furry f (x:xs)
10:24:31 <rovar> furry _ [] = []
10:24:43 <jmcarthur> paolino: oh, distribution. ambiguous use of the word "thread" there ;)
10:24:58 <paolino> jmcarthur: I'm just a lurker with erlang,  sorry
10:25:18 <jmcarthur> paolino: this gets close, notationally, although it doesn't get your distribution: http://gist.github.com/111482
10:25:30 <paolino> (not that I shine here ;-) )
10:25:33 <jmcarthur> using some actor library that i forgot
10:26:29 <rovar> Beelsebob: how's this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2954#a2954
10:26:45 <Beelsebob> rovar: looks sensible to me :)
10:26:50 <rovar> goooood
10:26:56 <rovar> my master plan is coming together
10:27:06 <Beelsebob> does it satisfy the Fluffy laws?
10:27:45 <Beelsebob> furry id == id and furry (f . g) == furry f . furry g?
10:27:48 <paolino> jmcarthur: I saw that lib, still it's not going outside the mainboard , and I suppose never will
10:28:07 <paolino> *motherboard
10:28:11 <rovar> tmk there are no laws, only one interface for furry.. but i think it satisfies the functor laws :)
10:28:21 <jmcarthur> paolino: are you saying you want widespread use of erlang style concurrency in haskell? i'm afraid i don't think that would be a good thing
10:28:32 <jmcarthur> erlang is great for a specific domain
10:28:36 <Beelsebob> rovar: can you prove it?
10:28:53 <Beelsebob> I'd suggest structural induction
10:30:06 <skorpan> i'm writing a haskell program using sockets... now i'm trying to figure out a way to read from a socket, but if there's nothing to read for 60 seconds, send something instead. how do i do that?
10:30:27 <FunctorSalad_> have two threads?
10:30:31 <Beelsebob> skorpan: I'd suggest setting two threads up
10:30:34 <Beelsebob> both writing to a Chan
10:31:12 <Beelsebob> specifically writing a data structure like this: data Timeout = SixtySecondsUp | DataRecieved Data
10:32:36 <paolino> jmcarthur: I hope STM is the not the last word for haskell, in that area
10:33:05 <jmcarthur> paolino: shared memory concurrency is only one kind of concurrency. we have more than that
10:33:59 <jmcarthur> STM is great, even our MVars are great, we also have various Chans and concurrency libraries, and that's not even touching our parallelism stuff which many people conflate with concurrency
10:34:53 <paolino> jmcarthur: what about cloud computing ? do we have something nice for it?
10:35:17 <jmcarthur> not yet. that is erlang's domain, for now
10:35:25 <rovar> paolino: what are you looking for, in particular?  I am working on yet another actor lib for haskell which transparently instantiates actors into their own "processes" (forkIO threads) .  The existing libs, which are more complex, hide threading, but still facilitate the same lightweight concurrency.  They communicate via channels, and have mailboxes.
10:35:40 <jmcarthur> of course, you could argue that HTTP/XMPP/etc. are good solutions for that, too
10:35:48 <hackagebot> curry-frontend 0.2.2 - Compile the functional logic language Curry to several intermediate formats (HolgerSiegel)
10:36:06 <rovar> it's the message matching and lack of atoms that can make things a little clunkier in hs, but not much.
10:36:08 <jmcarthur> although they aren't very lightweight, syntactically, yet
10:36:57 <paolino> rovar, yes, I was looking for that thing, possibly with a new notation, like we have for monads
10:37:11 <jmcarthur> i think a new notation is the wrong way to go
10:37:18 <paolino> :)
10:37:21 <jmcarthur> do notation is bad enough
10:38:09 <rovar> a receive block which implicity creates the pattern matching code wouldn't suck
10:38:28 <paolino> jmcarthur: how is that bad ?
10:38:56 <rovar> the problem is that if you want to dispatch to a function to have the elegant looking pattern matching, you have to go through an intermediary.
10:38:59 <jmcarthur> do notation is imperative, but monads are not generally imperative
10:39:32 <rovar> man I can't figure out how to use hugs
10:39:36 <jmcarthur> and the presence of do notation means we don't try to find more meaningful monadic combinators, a lot of the time
10:39:40 <rovar> got spoiled with ghc
10:40:39 * rovar downloads haskell platform for windows. 
10:40:58 <rovar> actually.. i think my problem is with windows, not hughs
10:41:01 <rovar> hugs
10:41:07 <jmcarthur> for example: bind2 :: Monad m => (a -> b -> m c) -> (m a -> m b -> m c) -- this does not exist in the libs even though it would be immensely useful, like liftM2 is
10:41:23 <paolino> jmcarthur: ap, fmap and friends are everywhere
10:41:27 <jmcarthur> the reason it doesn't exist, i think, is due to the existence of do notation
10:41:42 <mauke> :t liftM2
10:41:44 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:41:46 <jmcarthur> paolino: ap and fmap are not everything
10:42:23 <bgs100> Back (was was afk). What are some good places to get started with haskell? I already have ghc installed.
10:42:32 <jmcarthur> :t liftM join . liftM2
10:42:33 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
10:42:33 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
10:42:33 <lambdabot>     In the second argument of `(.)', namely `liftM2'
10:42:42 <jmcarthur> :t fmap join . liftM2
10:42:43 <paolino> jmcarthur: I think do notation is there for readability
10:42:43 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
10:42:44 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
10:42:44 <lambdabot>     In the second argument of `(.)', namely `liftM2'
10:42:46 <jmcarthur> bleh
10:42:55 <jmcarthur> paolino: yes, but i don't think it helps much there
10:43:05 <pikhq> :t fmap $ join . liftM2
10:43:07 <lambdabot> forall (f :: * -> *) a2 r (m :: * -> *). (Functor f, Monad m) => f (a2 -> a2 -> r) -> f (m a2 -> m r)
10:43:14 <jmcarthur> eh
10:43:19 <rovar> bgs100, what languages are you familiar with?
10:44:03 <mauke> :t (join .) . liftM2
10:44:05 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
10:44:05 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
10:44:05 <lambdabot>     In the second argument of `(.)', namely `liftM2'
10:44:08 <bgs100> rovar, Python and Common Lisp
10:45:13 <monochrom> @remember jmcarthur my "monad tutorial" has shortened to "look at the type signatures and the laws" :\
10:45:14 <lambdabot> Good to know.
10:48:57 <rovar> bgs100,   for python programmers, i would recommend http://learnyouahaskell.com/ and for functional programmers i would recommend http://www.haskell.org/tutorial/
10:49:55 <maltem> Python programmers like funny pictures, and functional programmers like TeX'ed papers? :)
10:50:06 <NEEDMOAR> Haha.
10:50:14 <lilac> maltem: sounds like a reasonable generalization ;-)
10:50:17 <rovar> maltem: that's basically the gist of it
10:51:01 <rovar> learnyou smacks considerably of whyTheLuckyStiff's writings for ruby
10:51:09 <jmcarthur> s/Python/Ruby/ and you have a fact
10:52:54 <monochrom> A formula is worth a thousand pictures.
10:53:44 <lilac> class Monad m where / return and Kleisli compose / must form a monoid
10:54:40 <jmcarthur> quite elegant
10:56:22 <lilac> that's my new monad tutorial haiku
10:56:49 <jmcarthur> i think that is the best monad tutorial i have ever read
10:57:05 <lilac> \o/
10:57:07 <monochrom> ... hahahaha
10:57:11 <roconnor> lilac: can I add that to my library ticket?
10:57:25 <lilac> roconnor: sure, if you like
10:57:32 <roconnor> http://hackage.haskell.org/trac/ghc/ticket/3362#preview
10:58:06 <roconnor> oh, can I not edit the description?
11:01:21 <roconnor> lilac: http://hackage.haskell.org/trac/ghc/ticket/3362#comment:1
11:01:55 <monochrom> @remember lilac class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever read
11:01:55 <lambdabot> Okay.
11:01:58 <wokka> I've just started playing with haskell, and I was curious: can it collect the output of another program for manipulation?  I've found System.Cmd.rawSystem, which naturally returns the exitcode of whatever it ran, but is there a way to capture stderr/stdout from a called process?
11:02:19 <jmcarthur> wokka: System.Process, i believe
11:02:28 <wokka> Ah, thank you so much.
11:02:31 <wokka> I will look into it.
11:02:31 <jmcarthur> in that module, i mean
11:03:10 <wokka> jmcarthur: Right.  Thanks
11:04:46 <rovar> woo.. i'm on a roll now! kicking these exercises collective (_|_)
11:05:10 <rovar> up to #5 :P
11:05:26 <rovar> doing actual work inbetween exercises
11:06:26 <mxc> hi.. need a hand with forkIO, mapM_ and a lazy, infinite list..  spefically, trying to do something like:
11:06:27 <mxc> > forkIO $ mapM_ myIOAction myInfiniteList
11:06:27 <mxc> but, and I suspect its because of laziness, I can't get myIOAction to be evaluated at all
11:06:29 <lambdabot>   Not in scope: `forkIO'Not in scope: `myIOAction'Not in scope: `myInfiniteLi...
11:06:36 <mxc> sry lamdabot..
11:07:18 <mxc> i tried: forkIO $ mapM_ (\a -> myIOAction a `seq` return ()) myInfiniteList but that didn't help and was mostly a shot in the dark
11:07:56 <lilac> maltem: the `seq` method won't work. forcing an IO action won't execute it
11:08:02 <lilac> s/maltem/mxc/
11:08:19 <lilac> mxc: but the original code you pasted looks fine to me.
11:08:19 <monochrom> No laziness in it.
11:08:41 <monochrom> IO commands are not that lazy.
11:09:13 <lilac> mapM_ f [] = return (); mapM_ f (x:xs) = f x >> mapM_ f xs
11:09:51 <lilac> mxc: can you paste the code in question, in context, to hpaste.org?
11:09:57 <monochrom> forkIO (mapM_ (\x -> threadDelay 1000000 >> print x) [1..])   try this
11:10:38 <monochrom> I just tried it in GHC. I have problem even stopping it!
11:10:44 <mxc> lilac the problem is that its buried deep, and would ahve to copy lots of scattered code for it to make sense
11:10:53 <mxc> i was wondering if conceptually, there something wrong
11:10:57 <monochrom> I mean GHCi
11:12:23 <lilac> mxc: I'd guess either one of your earlier IO actions is blocking the later ones from happening, or perhaps the forkIO is never being reached, or your myIOAction doesn't work
11:12:24 <monochrom> Your myIOAction does nothing, or another thread is hogging.
11:12:39 <lilac> mxc: are you using GHC?
11:12:48 <mxc> lilac: yes
11:13:10 <mxc> i tried replaction myIOAction with (const $ error "err")
11:13:19 <jleedev> ?hoogle System.Process
11:13:20 <lambdabot> module System.Process
11:13:20 <lambdabot> package process
11:13:20 <lambdabot> System.Posix.Types type ProcessGroupID = CPid
11:13:26 <mxc> and no error was raised, so i assume somehting else is blocking it
11:13:38 <grahamhutton> <advert> make sure to register for ICFP and associated events in Edinburgh if you haven't already --- lots of great talks, great venue, great city, etc, etc </advert>
11:13:43 <lilac> mxc: try replacing the entire forkIO line with fail "error"
11:13:46 <monochrom> Put a lot of print statements before and after your forkIO
11:14:11 <grahamhutton> http://www.cs.nott.ac.uk/~gmh/icfp09.html
11:14:26 <lilac> mxc: my guess is it's just not being reached at all. or perhaps your infinite list is empty?
11:17:21 <mxc> think you're right..
11:17:49 <mxc> fixed something, onto the next bug
11:19:19 <mux> finds it weird that the sendHTTP function and friends from Network.HTTP constrain the request and the result datatypes to have the same HStream instance
11:20:18 <monochrom> Ah, that may be an oversight.
11:20:31 <lilac> it doesn't copy any values from the request to the result does it?
11:23:20 <mux> I guess I should actually complain about the lack of getRequest-like function for bytestrings
11:29:04 <rovar> anyone know where I can get information on (->) ?  :t isn't helping much.  I figure it's a constructor, but  ((->) t) doesn't make much sense to me.
11:29:06 <mux> actually, the type of getRequest is just wrong
11:29:47 <zebrafinch> rovar: (a -> b) is the same thing as ((->) a) b
11:29:47 <EvilTerran> rovar, it's a type constructor. (->) a b = a -> b
11:31:06 <rovar> type constructor makes more sense..  i gathered that   ((->)a) b = a -> b         -  but I'm still having a hard time wrapping my head around that..
11:34:46 <jmcarthur> @kind (->)
11:34:47 <lambdabot> ?? -> ? -> *
11:35:03 <mxc> lilac - it was creating my infinite list that was blocking..  I create it by calling: sequence $ repeat (readChan chan)..  that was blocking the thread, if youre curious
11:35:08 <jmcarthur> oh yeah, i forgot (->) has a weird kind
11:35:14 <rovar> how do I make a type out of it so that I may:  a: use :t on it in haskell, and b: use it as a parameter in a function..
11:35:35 <zakwilson> Should I be considering using GHC for soft real-time stuff?
11:36:14 <jmcarthur> rovar: it's a *type* constructor, so it can't itself be used as a parameter
11:36:26 <jmcarthur> rovar: although you can have a parameter of type (a -> b)
11:36:38 * mux also notes that Request_String as a type synonym for Request String doesn't look very useful
11:36:50 <rovar> zakwilson:   i dunno much about this, but it might get you started:  http://www.reddit.com/r/haskell/comments/8fnsn/atom_is_a_haskell_dsl_for_designing_hard_realtime/
11:37:11 <FunctorSalad_> what is that "??" kind?
11:38:14 <jmcarthur> something to do with unboxed types i think
11:38:26 <Baughn> Anecdotally, I just now sped up a C++ program 20-fold by rewriting it in haskell. :3
11:38:45 <mux> Baughn: that is seriously blog-worthy
11:38:54 <mux> except
11:39:10 <mux> except if you don't want to get accused of being a lousy C++ coder :)
11:39:34 <jmcarthur> :t foldl (+) 0 [1..20]  -- 20-fold?
11:39:35 <lambdabot> forall a. (Num a, Enum a) => a
11:39:58 <jmcarthur> :t 20 - fold
11:39:59 <lambdabot> Not in scope: `fold'
11:40:05 <jmcarthur> :t 20 - Data.Foldable.fold
11:40:06 <lambdabot> forall (t :: * -> *) m. (Num (t m -> m), Data.Foldable.Foldable t, Monoid m) => t m -> m
11:40:11 <zakwilson> rovar: hard real-time - even better. Thanks.
11:40:21 <byorgey> rovar: you can only use :t on *values*.
11:41:10 <SamB> woah, neat, now if I wanted something near the top of my google results I can just enter the URL...
11:41:14 <Baughn> mux: Heh. I didn't write the C++ code in the first place, the program isn't open-source (and I'm under an NDA), and rewriting lousy C++ into good haskell is hardly that unusual
11:41:40 <jmcarthur> c++ programmers don't know that
11:41:43 <Baughn> mux: The fifty-fold reduction in line count might be equally blog-worthy
11:41:51 <mux> Baughn: indeed
11:42:47 <rovar> byorgey:  that makes sense..   so  would the logic follow that I have to construct a type with it in order to use it as a parameter of a function, at which point it becomes a value?
11:43:30 <Baughn> mux: But I suppose.. I replaced an exhaustive search with a /lazy/, biased exhaustive search. The code looks incredibly naive now, and I'm sure I could get another ten-fold speed if we needed it, which we don't.
11:43:59 <rovar> i wish I could get paid to write haskell
11:44:04 <jmcarthur> rovar: well, you could just say: map (a -> b) [1..3], but you could say: map (f :: a -> b) [1..3]
11:44:10 <rovar> I guess the 1st step is getting better at haskell :)
11:44:10 <jmcarthur> *couldn't just say
11:44:18 <mux> rovar: that is exactly what I was thinking and was going to answer to Baughn
11:44:19 <ray> i'll give you a dollar if you give me a file full of haskell
11:44:21 <ray> any haskell
11:44:29 <ray> must be at least 1k
11:44:37 <Baughn> Have you checked hackage? :P
11:44:41 * mux feels confident enough in haskell now, but there are still no jobs :-P
11:44:51 <ray> i'm just providing an economic stimulus :P
11:44:59 <jmcarthur> we should all make a giant haskell startup
11:45:06 <mxc> galois, stan chart, DB.. not hiring?
11:45:08 <jmcarthur> all of us
11:45:14 <mxc> i've heard stan chart is hiring in london
11:45:14 <jmcarthur> ?users
11:45:14 <ray> #haskell startup
11:45:14 <lambdabot> Maximum users seen in #haskell: 658, currently: 625 (95.0%), active: 25 (4.0%)
11:45:23 <jmcarthur> a 658 an startup
11:45:26 <mxc> actualyl, they're apparently hiring in singapore too
11:45:32 <jmcarthur> *625
11:45:36 <mux> mxc: also, I'm in France and we don't tend to be on the edge of technology around here, unfortunately
11:45:42 <Heffalump> I thought Galois was hiring
11:45:51 <mxc> mux - any objection to working in london?
11:45:58 <mxc> mux - france is ocaml country...
11:46:02 <mux> heh
11:46:15 <jmcarthur> ugh, mxc and mux are the same color in my irc client
11:46:19 <mauke> we can't stop here
11:46:21 <mauke> this is ocaml country
11:46:22 <mux> mxc: I could live with working in London, but not for a very long time
11:46:28 <mux> mauke: hahahaha
11:46:50 <mxc> mux if you want a haskell job and a 6 week continental style vacation... might not be that easy
11:46:54 <wli> My plot is to starve.
11:46:58 <Heffalump> and if anyone is interested in Credit Suisse at any time, give me a yell, though we aren't hiring that often (and you'd probably end up doing much more F# than Haskell)
11:47:23 <mux> mxc: I'd love something like a 6-month job
11:47:35 <mxc> heffalump - i'm always curious about haskell/F# jobs at banks, since i have as mcuh experience as a statarb/algo trader as I do writing haskell
11:47:38 <Heffalump> internships exist
11:47:43 <rovar> +1 to mauke for tying fear and loathing into haskell chat
11:47:56 * mux seconds that
11:48:02 <mux> this needs to land in the HWN quotes
11:48:09 <bgs100> I imagine I'm doing something stupid, but, I'm trying the quicksort example from http://www.haskell.org/haskellwiki/Introduction, and:
11:48:12 <rovar> Jane St. Capital here in Manhattan is always hiring for ocaml
11:48:20 <Heffalump> Jane St are in London and I think Tokyo too
11:48:21 <bgs100> Prelude> let qsort []     = []
11:48:21 <bgs100> Prelude> let qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
11:48:21 <bgs100> Prelude> qsort([2, 3, 1])
11:48:21 <bgs100> *** Exception: <interactive>:1:4-76: Non-exhaustive patterns in function qsort
11:48:28 <mxc> jane street is a great place to work
11:48:29 <Heffalump> I know a couple of the London hackers
11:48:38 <mauke> bgs100: every 'let' defines a new set of bindings
11:48:39 <mxc> i used to work in tokyo office
11:48:40 <jmcarthur> bgs100: ghci doesn't like multiple line lets
11:48:45 <mauke> bgs100: i.e. you're doing it wrong
11:48:47 <mux> bgs100: you need to define all this on the same line
11:48:59 <mux> bgs100: let qsort []     = []; qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++  qsort (filter (>= x) xs)
11:49:16 <Baughn> bgs100: A new let creates a new binding, unrelated to the first one
11:49:17 <jmcarthur> bgs100: ghci puts you in a mode similar to do notation, so multiple lets for the same identifier replace the older
11:49:22 <paolino> bgs, I think the 2 lets go on the same line
11:49:28 <Baughn> bgs100: Also, you don't need parantheses around parameters
11:49:31 <mux> @quote stereo
11:49:32 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
11:49:32 <bgs100> Oh, thanks
11:49:33 <ray> separated by a semicolon
11:49:41 <mux> hah.
11:49:41 <Baughn> paolino: No, it's just one binding per let
11:49:46 <ray> @quote quote
11:49:47 <lambdabot> mauke says: @quote vim
11:49:49 <paolino> ok
11:49:52 <jmcarthur> #haskell: overwhelmingly helpful
11:49:52 <mauke> wtf
11:49:52 <Baughn> paolino: Or rather, bindings can't span multiple lets.\
11:50:11 <ray> @quote contrapuntal
11:50:11 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:50:22 <Baughn> @remember jmcarthur #haskell: Overwhelmingly helpful.
11:50:23 <lambdabot> It is forever etched in my memory.
11:50:43 <mauke> @quote firehose
11:50:44 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
11:50:45 <rovar> jmcarthur: I'm not sure how the example you gave me relates to the (->) operator
11:50:48 <jmcarthur> i like the contrapuntal fugues one better
11:50:49 <rovar> err type constructor
11:50:59 <mux> type operator :)
11:51:03 <jmcarthur> rovar: (a -> b) is the type of a function
11:51:19 <rovar> yar
11:51:34 <rovar> ((->) a) b      is as well, correct?
11:51:39 <Botje> 0.0
11:51:40 <jmcarthur> i don't know what you are trying to capture about it
11:51:40 <Botje> 0
11:51:40 <Botje> .+
11:51:43 <jmcarthur> yes
11:51:46 <Botje> uh
11:51:47 <Botje> oops
11:51:52 <Botje> sorry :)
11:51:58 <rovar> http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/     #3
11:52:05 <jmcarthur> Botje: +0
11:52:11 <jmcarthur> Botje: .
11:52:14 <rovar> i have no problem with the ones following.. but I just am not grokking ->
11:52:18 <jmcarthur> Botje: .-
11:52:20 <Botje> :)
11:52:21 <rovar> the few following.. that is
11:52:50 <bnijk> http://video.google.com/videoplay?docid=-8142733917997460212&hl=en
11:53:05 <jmcarthur> rovar: instance Fluffy ((->) t) where ?
11:53:17 <rovar> yea
11:53:40 <rovar> i can kind of understand what needs to happen, but not sure how to express it.
11:53:43 <jmcarthur> rovar: okay, so we know furry :: (a -> b) -> f a -> f b
11:53:46 <Baughn> rovar: Given that instance, what is the type signature for furry?
11:53:53 <jmcarthur> and we know f should be ((->) t)
11:54:17 <jmcarthur> rovar: so we have: furry :: (a -> b) -> ((->) t a) -> ((->) t b)
11:54:27 <jmcarthur> which we can simplify, visually...
11:54:38 <jmcarthur> rovar: (a -> b) -> (t -> a) -> (t -> b)
11:54:47 <Baughn> Slow.. do... never mind.
11:54:54 <jmcarthur> woops, didn't mean to answer Baughn's question
11:55:01 <jmcarthur> rovar: does that help?
11:55:15 <Baughn> I bet it helped, but I wanted rovar to figure that out for himself. :P
11:55:33 <Baughn> The last type signature should look mighty familiar
11:55:52 <jmcarthur> Baughn: well, i was just figuring that the point of the exercises was the definition, not the oddities of type operators
11:55:54 <SamB> Baughn: why? is it his mother?
11:55:58 <wli> @type flip (.)
11:56:00 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
11:56:15 <wli> @type (.)
11:56:16 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:56:27 <jmcarthur> *sigh*
11:56:42 <rovar> overwhelmingly helpful
11:56:50 <jmcarthur> yes
11:56:52 <Baughn> jmcarthur:  Maybe. From my viewpoint, the point is to get used to manipulating types
11:58:06 <paolino> wli, you shouldn't ....
11:59:21 <paolino> :t fmap
11:59:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:00:28 <rovar> i guess my problem is that I understand the type signature
12:00:36 <rovar> but still can't define the function.
12:01:26 <EvilTerran> rovar, how many parameters does the function have?
12:01:45 <rovar> 2
12:01:53 <EvilTerran> *bzzzt*
12:01:57 <rovar> 1
12:01:57 <rovar> 3
12:01:59 <rovar> i dunno
12:02:00 <paolino> 4
12:02:01 <EvilTerran> 3
12:02:19 <EvilTerran> furry :: (a -> b) -> (t -> a) -> t -> b
12:02:40 <rovar> err
12:03:18 <rovar> so that's different (yet the same) :  (a -> b) -> (t -> a) -> (t -> b)
12:03:25 <EvilTerran> furry takes three parameters: a function from 'a' to 'b', a function from 't' to 'a', and a value of type 't'
12:03:31 <EvilTerran> yes, (->) is right-associative
12:03:38 <EvilTerran> so a -> b -> c = a -> (b -> c)
12:03:56 <mux> @djinn (a -> b) -> (t -> a) -> t -> b
12:03:57 <lambdabot> f a b c = a (b c)
12:04:05 <EvilTerran> so, may as well give those parameters names when you're working out the implementation of it
12:04:10 <mux> djinn saw you coming
12:04:10 <EvilTerran> "furry f g x = ..."
12:04:26 <EvilTerran> may make sense as parameter names, as the first two are functions and the last is a value
12:05:41 <EvilTerran> rovar, and then it's a case of finding some expression, in terms of f, g, and x, that has type 'b'
12:05:46 <EvilTerran> to put in the "..." position
12:05:53 <rovar> yar
12:06:09 <paolino> or furry f g = \x -> .. -- if it's 2 parameter function
12:07:13 <rovar>    ((a (b x) ) x)
12:07:23 <rovar> err (( f ( g x) ) x)
12:07:28 <EvilTerran> er, close
12:07:37 <EvilTerran> too many "x"s
12:07:56 <EvilTerran> ?type let furry f g x = ((f(g x))x) in furry
12:07:57 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t1 -> t) -> t1 -> t2
12:09:58 <EvilTerran> rovar, you're trying to get something of type 'b', but the only way you can get such a value is as the result of "f"
12:10:10 <EvilTerran> so it'll have to be "furry f g x = f (...)"
12:10:19 <EvilTerran> but then you need something of type 'a' to pass as a parameter to f
12:11:07 <EvilTerran> which you can work out as a sub-problem, without regard to the fact that your eventual goal is something of type 'b'
12:12:05 <EvilTerran> rovar, can you see what the expression of type 'a' would be?
12:12:17 <rovar> ?type let furry f g x = (f (g x)) in furry
12:12:19 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
12:12:36 <EvilTerran> yep
12:12:37 <EvilTerran> :)
12:13:11 <rovar> i was trying to apply the final t parameter as well
12:13:21 <rovar> to achieve the result of b
12:15:42 <dankna> hm
12:15:46 <dankna> splices are not allowed in hs-boot files
12:15:48 <dankna> this is a problem for me :(
12:15:56 <dankna> hmm, how to work around it...
12:16:17 <dankna> I think I just don't use hs-boot files, heh
12:16:47 <EvilTerran> unless you've got circular imports, you don't need them
12:16:50 <rovar> grr.. that solution doesn't parse..
12:17:01 <dankna> I know, but I want to have circular imports
12:17:31 <rovar> ah
12:17:40 <EvilTerran> dankna, can you reduce it so that the only module in a loop that has a .hs-boot has no splices in it?
12:18:00 <EvilTerran> seeing as, iirc, you only need one .hs-boot to break the loop
12:18:16 <dankna> EvilTerran: I don't think so.  The splices are from HOC (a binding to the Objective-C language) and I want to have multiple classes that can refer to each other.
12:18:23 <dankna> Without putting them all in one huge file.
12:18:28 <EvilTerran> ah
12:18:44 <dankna> Most of the important symbols in the package are therefore defined by splices.
12:18:58 <rocketman> Why don't you write in Obj-C?
12:19:01 <dankna> I guess the splices wouldn't do what I want them to even if I could have them,
12:19:11 <dankna> rocketman: well... because I'd rather write in Haskell?
12:19:31 <rocketman> just because haskell is more fun or because of a technical reason?
12:19:39 <dankna> because the splices give both declarations and definitions, and the hs-boot should only have declarations
12:19:43 <dankna> rocketman: well
12:19:55 <dankna> part of my goal is to gain fluency in Haskell
12:20:02 <jmcarthur> because haskell is awesome
12:20:12 <paolino> addictive
12:20:13 <dankna> and for the higher-level features of this program, which I haven't gotten to yet, I'll definitely want something that can do functional style
12:20:25 <dankna> and I've found that monads are a good match for even the infrastructure which I've already done
12:20:51 <dankna> so both technical and nontechnical reasons
12:21:03 <dankna> I'm not adverse to writing parts of it in other languages if it turns out that I have to...
12:21:12 <rocketman> That is the most sensible thing to do
12:21:26 <dankna> well, it wouldn't help with this particular issue
12:21:31 <rocketman> (making an object oriented interface to the haskell program via CFFI)
12:22:00 <dankna> mm
12:22:26 <rocketman> Anyway if you are having fun putting yourself through a tennis racket while balancing on a rola bola I wont stop you :)
12:22:27 <dankna> well, I'm using HOC, not the FFI directly, because ObjC is a pain to bind against without some higher-level wrappers.  but that doesn't really bear on what you said.
12:22:35 <dankna> oh, I assure you, I am having fun
12:22:43 <dankna> wtf is a rola bola? :)
12:23:03 <dankna> never mind, I looked it up
12:23:44 <dankna> I haven't really found that it's hard to write the OO parts in Haskell at all... it's very nearly as straightforward as it would be to write them in ObjC
12:24:09 <dankna> except there's the occasional thing that I simply can't do, like this :(
12:24:44 <mux> erm, those strings I'm matching against with regexps (from a rss feed) contain zero width space characters
12:24:54 <mux> they are utf-8
12:25:29 <mux> I'm wondering if an utf-8 aware regexp implementation would strip these out?
12:26:12 <mux> because right now, I'm forced to insert nasty \226\128\139 escape sequences in my REs...
12:26:16 <dankna> "this character is intended for line break control; it has no width, but its presence between two characters does not prevent increased letter spacing in justification"
12:26:44 <dankna> (in other words, it means "line breaks can go here, but so can kerning")
12:26:48 <mux> yup, I've read that in the character map accessory from gnome
12:27:01 <dankna> (no word on whether ligatures are allowed, ie if you put it between an "f" and an "i")
12:27:15 <mux> I understand that, but I'm wondering something else :-)
12:27:21 <dankna> yeah, I see what you're asking
12:29:27 <mux> > filter isControl "foo\226\128\139bar"
12:29:29 <lambdabot>   "\128\139"
12:29:36 <mux> err
12:29:44 <mux> > filter (not . isControl) "foo\226\128\139bar"
12:29:45 <lambdabot>   "foo\226bar"
12:29:50 <mux> ok this is weird
12:31:14 <poucet> 226 is not a control character
12:31:18 <poucet> it's a^
12:31:40 <poucet> Though 128 should not be either, that's Euro
12:31:42 <mux> the whole sequence is a 3-byte encoding of a zero width space (U+200B)
12:31:49 * poucet ahs
12:31:50 <mux> in utf-8
12:32:00 <mauke> then it shouldn't be in a String in the first place :-/
12:32:03 <poucet> Yeah
12:32:09 <poucet> String stores unicode points as one element
12:32:13 <poucet> hence why you can have
12:32:22 <poucet> > "\0x200"
12:32:24 <lambdabot>   "\NULx200"
12:32:28 <poucet> whoops
12:32:32 <mauke> > '\1234'
12:32:34 <lambdabot>   '\1234'
12:32:35 <poucet> That one :)
12:33:02 <poucet> mux: String is not a list of 8byte elements
12:33:06 <poucet> it's a list of characters
12:33:06 <mux> I agree with that, but Text.Feed is only giving me strings
12:33:12 <mux> I know what a String is
12:33:15 <mauke> interface fail
12:33:18 <mux> (in haskell)
12:33:20 * poucet agrees with mauke 
12:33:47 <mux> indeed - but can I somehow work my around this with CompactString or some other module?
12:33:58 <mux> this is weird btw, since the feed package depends on utf8-string
12:33:58 <poucet> I -am- surprised, hwoever, that \128 is coutned as a control character
12:34:11 <mauke> what else would it be?
12:34:14 <poucet> Euro
12:34:17 <mauke> er, no
12:34:21 <mauke> euro is much higher
12:34:23 <poucet> http://www.petefreitag.com/cheatsheets/ascii-codes/
12:34:31 <dolio> > '\128'
12:34:33 <lambdabot>   '\128'
12:34:34 <mauke> that site is fail, I don't even need to click on it
12:34:39 <mauke> (it says "ascii codes")
12:34:45 <mauke> U+20AC (e2 82 ac): EURO SIGN [€]
12:34:50 <poucet> Ok
12:35:05 <poucet> So ascii and utf only overlap from 0-127 ?
12:35:10 <mauke> poucet: where does that say "unicode"?
12:35:15 <mux> ASCII is really only 7-bit
12:35:23 <mauke> ascii is a subset of unicode
12:35:27 <mauke> ascii goes from 0 to 127
12:35:39 <mauke> "utf" doesn't exist
12:35:39 <poucet> Ok, so basically extended ascii is not contained as is in Unicode, good to know :)
12:35:42 <poucet> That was my assumption
12:35:46 <mauke> there is no "extended ascii"
12:35:57 <mauke> there are hundreds of mutually incompatible extensions of ascii
12:36:14 <mauke> one of them is latin-1, which is also a subset of unicode (from 0 to 255)
12:36:55 <mauke> ascii ⊂ latin-1 ⊂ unicode
12:37:31 <poucet> ah, 128 is non-breaking-space?
12:37:58 <mauke> no, it's a control character
12:38:03 <poucet> > "b " ++ ( chr 128 : " a")
12:38:04 <lambdabot>   "b \128 a"
12:38:11 <mauke> U+00A0 (c2 a0): NO-BREAK SPACE [ ]
12:38:15 <mauke> that's 160
12:39:04 <dankna> are you confusing the encoding with the codepoint?
12:39:07 <dolio> , text "a \128 b"
12:39:07 <mauke> so ... ascii is a 7-bit charset, latin-1 is an 8-bit charset, and unicode is a 21-bit charset
12:39:08 <lunabot>  a  b
12:39:24 <Twey> Unicode is not a charset
12:39:24 <veryalias> Say that I have a function that randomly permutes the rows of a matrix and returns it as :: IO matrix, then I use a lift to split it into two parts IO (first n columns, remaining columns). What am I doing wrong if it results in possibly non-identical permutations of the rows of the first and second parts. Should I force the permutation be evaluated in some way before the split, or bind the permuation between the parts in some way? 
12:39:40 <mauke> there are various ways to encode 21-bit code points into bytes
12:40:05 <mauke> they are called UTFs, and the most common ones are UTF-8 and UTF-16
12:40:08 <dankna> Twey: Did you mean, Unicode is not an *encoding*?  A charset is exactly what it is.
12:40:20 <Twey> Yes, okay :)
12:40:23 <dankna> hehe
12:40:56 <Twey> The notion of it being X-bit is nonsensical, is what I meant.
12:41:09 <dankna> ah, yeah
12:41:13 <mauke> I disagree
12:41:13 <Twey> Numbers don't have a fixed size in bits; only their representation does
12:41:23 <dankna> but its codepoints could be fit in X bits, anyway
12:42:02 <Twey> If you apply compression, you can probably fit them in less bits than that
12:42:17 <mauke> what
12:42:33 <Twey> And there are any number of ways you can fit them in more bits :-P
12:42:46 <dankna> haha
12:42:48 <dankna> there certainly are
12:43:35 <dankna> the fact remains that in an information-theoretic sense, each character in Unicode, assuming a random distribution among all possible characters (in other words, assuming you can't compress them, haha), has X bits of entropy.  Where X probably = 21.
12:43:51 <dolio> You can only fit some of them into fewer bits. And some of them will be fit into more bits.
12:44:04 <inimino> it's less than 21
12:44:10 <mauke> > maxBound :: Char
12:44:12 <lambdabot>   '\1114111'
12:44:24 <mauke> > logBase 2 1114112
12:44:26 <lambdabot>   20.087462841250343
12:44:32 <dankna> yeah, I'm not sure what 1114111 is in binary, although I knew that number off the top of my head as I'd been doing this stuff recently, haha
12:44:35 <dankna> ah
12:44:47 <inimino> not all 21-bit values are used
12:44:57 <mauke> ok, so 20.09 bits?
12:45:01 <dolio> > showHex . ord $ maxBound
12:45:03 <lambdabot>   Overlapping instances for GHC.Show.Show
12:45:03 <lambdabot>                              (GHC.B...
12:45:15 <mauke> 10ffff or something like that
12:45:30 <dolio> > ($"") . showHex . ord $ maxBound
12:45:31 <lambdabot>   "10ffff"
12:45:47 <inimino> yes, exactly that
12:46:15 <dankna> in practice it usually fits in sixteen bits, unless someone is using one of the private ranges
12:46:45 <mauke> in practice it doesn't fit in sixteen bits, and everyone who uses UCS-2 needs to be shot :-(
12:46:49 <inimino> indeed
12:47:03 <mauke> javascript likes to annoy me with it
12:47:08 <dankna> haha, I see
12:47:10 <inimino> tell me about it :(
12:47:43 <dankna> yeah, the dangerous thing about UCS-2 is that people tend to falsely assume that there's a 1:1 correspondence between sixteen-bit chunks and characters
12:48:02 <inimino> actually in UCS-2 there is
12:48:03 <dankna> UTF-8 really seems like the way to go
12:48:22 <dankna> inimino: am I confusing UCS-2 with something else?  I thought it was the same as UTF-16?
12:48:43 <mauke> UCS-2 is 16 bits only; no surrogates
12:48:47 <inimino> it's UTF-16 where that assumption fails
12:48:48 <dankna> oh!
12:48:49 <inimino> that's a common misconception
12:48:51 <inimino> and UCS-2 is obsolete for that reason
12:48:56 <dankna> gotcha
12:49:04 <dankna> then I'd agree, UCS-2 sounds broken and should not be used
12:49:34 <pikhq> If you must use a UCS, UCS-4 is quite nice.
12:49:37 <mauke> I couldn't be bothered to write my own UTF-16 support in javascript, so I had to cut a bunch of characters from http://mauke.ath.cx/stuff/javascript/unicode.html :-/
12:49:39 <pikhq> If overhead-tastic.
12:50:26 <dankna> nice page, mauke
12:51:09 <inimino> mauke: looks nice
12:52:09 <Mr_Awesome> i just upgraded to ghci 6.10.1, and now when i use ghci in emacs i get the input echoed and newlines are replaced by "^J".  anyone else have this problem?
12:52:12 <inimino> mauke: there's also Richard Ishida's page that does something like that
12:54:05 <rfmge> Mr_Awesome: i think 6.10 switched from readline to editline, might be the reason, i don't know what to do about it though
12:54:53 <Mr_Awesome> rfmge: i see. thanks, that should be helpful.
12:56:43 <Cale> 6.10.3 uses Haskeline which is nicer than editline
12:57:06 <Cale> I'm not certain about whether it fixes the problem with emacs though
12:57:22 <veryalias> Sorry to post this again: Say that I have a function that randomly permutes the rows of a matrix and returns it as :: IO matrix, then I use a lift to split it into two parts IO (first n columns, remaining columns). What am I doing wrong if it results in possibly non-identical permutations of the rows of the first and second parts. Should I force the permutation be evaluated in some way before the split, or connect the permutation b
12:57:40 <Mr_Awesome> Cale: if you don't mind, which editor do you use?
12:57:53 <Cale> Mr_Awesome: vim
12:58:07 <Mr_Awesome> ah, i guess we'll leave it at that then. ;)
12:58:07 <Cale> Mr_Awesome: I also occasionally use emacs, but I don't use ghci from inside it
12:58:26 <Cale> (emacs is just an editor for me ;)
12:58:32 <Cale> veryalias: hmm...
12:58:54 <hzap> veryalias: are you splitting it into IO (Matrix, Matrix)?
12:59:09 <veryalias> hzap yes
12:59:13 <Cale> veryalias: Well, if you permute the rows and then split them, the permutations of the top and bottom parts will reflect that original permutation
13:00:12 <veryalias> cale: if I use $ on the permutation before the split, then the permutations are the same in the split parts, otherwise not.
13:00:24 <Cale> veryalias: Are you saying that it's as if you permuted the one matrix in two different ways and then split each of them, took the top half of one and the bottom half of another?
13:01:11 <Cale> veryalias: Uhh... seeing as $ is the identity function, I'm not sure how that's supposed to be. :) Can I see the code?
13:01:37 <Cale> @src ($)
13:01:37 <lambdabot> f $ x = f x
13:02:21 <veryalias> cale: is it ok to post on moonpatio or should I use pastebin or something else?
13:03:41 <wokka> another quick question: I'm tooling around with System.Process.runProcess, and I want to create a generic handle to read from the process, how do I do that?
13:03:43 <Cale> Yeah, moonpatio or hpaste
13:05:42 <Cale> wokka: You might try runInteractiveProcess / runInteractiveCommand, or the more general createProcess
13:06:18 <Cale> runInteractiveProcess will hand you Handles you can use to communicate with the new process, rather than demanding them from you.
13:06:26 <wokka> Ahhh
13:06:35 <wokka> that explains the difference in syntax.
13:07:31 <wokka> and then I can simply get the out handle by (_, Just outhandle, _, _) <- createProcess (...
13:07:54 <Cale> It's not a Maybe Handle even
13:08:23 <Cale> oh, it is for createProcess, sorry
13:08:30 <Cale> yes, that's what you'd do
13:08:51 <Cale> There are some examples in the documentation
13:09:07 <Cale> (_, Just hout, _, _) <- createProcess (proc "ls" []) { std_out = CreatePipe }
13:09:26 <Cale> It's a cute usage of record update syntax :)
13:12:03 <wokka> Cale: hmm, and that's in System.Process?
13:12:23 <veryalias> Cale: I posted it on moonpatio.com
13:12:58 <Cale> wokka: yeah
13:13:06 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html
13:13:16 <wokka> cale: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2956#a2956
13:14:22 <Cale> wokka: Looks like you have an older System.Process
13:14:31 <Cale> wokka: What version of GHC is it?
13:14:52 <wokka> cale: 6.8.2
13:15:03 <Cale> ah, yeah, createProcess is new in 6.10.*
13:15:12 <wokka> :(
13:15:17 <Cale> wokka: You might try runInteractiveCommand or runInteractiveProcess, since I think they've been around longer.
13:15:34 <wokka> but then how do I create the pipe?
13:15:41 <Cale> veryalias: looking :)
13:15:49 <Cale> wokka: It makes it for you
13:17:24 <Cale> veryalias: id $ do x  is the same as  do x  which when x is just one statement is the same as  x
13:17:40 <wokka> with runProcess?
13:17:49 <veryalias> Cale: it is just garbage do x is the same
13:18:02 <Cale> wokka: runInteractiveCommand or runInteractiveProcess
13:18:09 <wokka> ahhh.
13:18:18 <Cale> wokka: The interactive versions are the ones which create pipes for you.
13:18:28 <wokka> well, just out of curiosity, how does one initialize a handler for such a purpose?
13:19:04 <Cale> I'm not sure... there's probably a posix api to get hold of a new fifo.
13:19:14 <wokka> Thanks so much.
13:19:19 <Cale> (that is, without creating a file)
13:19:20 <wokka> I appreciate the help.
13:20:04 <Cale> veryalias: um... hmmm
13:20:19 <Cale> veryalias: result here is not a result
13:20:43 <Cale> veryalias: result is an IO action which computes a different shuffle every time it is run
13:21:01 <Cale> veryalias: You seem to like the applicative style, but I don't think it's really the best thing here.
13:21:15 <Cale> veryalias: try:
13:21:27 <Cale> do result <- fromLists <$> l
13:21:49 <veryalias> I suspected something like that was happening, how can I "freeze" the value of result?
13:21:54 <Cale>    (,) <$> subMatrix (0,0) (t,s) result <*> subMatrix (0,s) (b,a) result
13:22:04 <Cale> you want to *run* the action
13:22:12 <Cale> which you do in do-notation with  <-
13:22:30 <veryalias> cale: I will try it
13:23:30 <Cale> That was a valiant attempt not to use the monad operations for IO though ;)
13:24:46 <veryalias> Cale: I admit that I am not sure what I am doing :-D
13:24:47 <hackagebot> hsparql 0.0 - A SPARQL query generator and DSL, and a client to query a SPARQL server. (JeffWheeler)
13:24:51 <jeffwheeler> Yay! I like this package a lot. It lets me query DBPedia, which is like a structured Wikipedia.
13:25:09 * jeffwheeler spams about it some more
13:27:09 <wokka> Cale: my syntax is crap, apparently. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2958#a2958
13:28:44 <hzap> veryalias: I think you need the <- on the shuffle ... line
13:31:06 <Cale> veryalias: Values of type (IO t) are nothing like values of type t
13:31:18 <Cale> veryalias: They are actions which when carried out, will produce a value of type t.
13:31:38 <Cale> veryalias: But you can define them, pass them around, put them in data structures, etc. without causing them to run.
13:31:48 <wokka> Cale: ah, got it.  Forgot a couple bits of "Nothing"
13:32:03 <Cale> wokka: great :)
13:32:28 <Cale> veryalias: In order to get them to run, you can use the notation v <- x inside a do-block, which means to run the action x, and name its result v
13:32:29 <byorgey> jeffwheeler: neat =)
13:32:49 <Cale> veryalias: the do-block as a whole then becomes another IO action, which doesn't happen until something runs it :)
13:33:08 <Cale> veryalias: Eventually you get up to main, or the ghci prompt and something really gets run :)
13:33:19 <jeffwheeler> byorgey: check out the tests to see it in action; the "tricky" query will find all the web browsers that don't have Freebase addresses
13:33:50 <jeffwheeler> byorgey: the other three were taken from the examples at DBPedia
13:35:07 <Twey> Cale, wokka: It's pipe(2)
13:35:13 <veryalias> cale: thank you for your explanations, Sorry that I am slow to get it to compile.
13:35:20 <Twey> Creates two FIFOs
13:35:35 <mauke> ... if you call it twice
13:35:39 <veryalias> hzap: thanks for your input also I will try it too
13:35:46 <dons> http://www.reddit.com/r/programming/comments/8zf6k/converting_a_site_from_mysql_to_couchdb_and/ is very cool
13:36:11 <Twey> mauke: ?
13:36:27 <mauke> Twey: ?
13:36:29 <Twey> It takes an int[2] and places two FIFOs into it
13:36:37 <Twey> In one call
13:36:45 <mauke> no
13:36:48 <Twey> The idea being that you read from one and write to the other
13:36:54 <mauke> that's one FIFO
13:37:11 <Twey> How do you figure that?
13:37:42 <Twey> It's a bidirectional pipe, i.e. a pair of FIFOs
13:37:48 <mauke> it's unidirectional
13:38:03 <Twey> Ah!
13:38:36 <mauke> at least that's what posix says; some OSes make it bidirectional, but not linux AFAIK
13:38:44 <gbacon> ?pl \x -> [x, id x]
13:38:45 <lambdabot> ap (:) return
13:38:51 <Twey> Right
13:38:56 <Twey> Silly me.  Okay.
13:38:59 <gbacon> ?pl \x -> [x, f x]
13:39:00 <lambdabot> ap (:) (return . f)
13:39:43 <rocketman> :t sequence [id, f]
13:39:45 <lambdabot> forall a. (Show a, SimpleReflect.FromExpr a) => a -> [a]
13:39:53 <rocketman> @pl sequence [id, f]
13:39:54 <lambdabot> sequence [id, f]
13:40:59 <gbacon> ?pl \x -> take 2 $ iterate f x
13:41:00 <lambdabot> take 2 . iterate f
13:41:12 <gbacon> ?src ap
13:41:14 <lambdabot> ap = liftM2 id
13:47:34 <Twey> @pl \ n t -> t + fst n
13:47:35 <lambdabot> (+) . fst
13:48:46 <rocketman> @unpl flip (liftA2 id fst)
13:48:47 <lambdabot> (\ b c -> liftA2 (\ d -> d) fst c b)
13:50:15 <yitz> dons: that json post looks hauntingly familiar. and the comment about poor haskell docs sounds pre-rwh.
13:50:36 <dons> yeah...
13:51:01 <dons> http://www.reddit.com/r/haskell/comments/8oxqt/converting_from_mysql_to_couchdb_in_haskell/ ...
13:51:15 <dons> yitz 2 points 1 month ago
13:51:27 <yitz> he
14:09:36 <kuribas> Is this valid?
14:09:36 <lambdabot> kuribas: You have 1 new message. '/msg lambdabot @messages' to read it.
14:09:43 <kuribas> module A
14:09:45 <kuribas> (module B)
14:10:09 <Saizan_> yes
14:10:20 <Saizan_> it reexports all of module B
14:11:30 <kuribas> ok
14:12:50 <kuribas> The layout rule doesn't work at the toplevel?
14:13:12 <Cale> kuribas: It works, it's just that it's more permissive than we usually describe it.
14:13:27 <Heffalump> yes, but it has an exclusion to allow everything at the top-level to be unindented
14:13:48 <Cale> Oh, is it an explicit exception?
14:14:17 <Heffalump> I think so, yes
14:15:00 * kolmodin is pleased to see get a mail about haskell hack day in edinburgh
14:15:11 <kolmodin> even though it's just a day
14:15:35 <kuribas> Maybe layout only follows the "where" after module.
14:15:40 <Cale> hmmm... "If the first lexeme of a module is not { or module, then it is preceded by {n} where n is the indentation of the lexeme."
14:16:26 <Cale> That's the only place that "module" is mentioned in the description of the layout rule.
14:16:35 <Cale> http://haskell.org/onlinereport/syntax-iso.html#layout
14:17:55 <quicksilver> kuribas: yes, that's one very minir thing which annoys me about haskell-indentation
14:18:06 <quicksilver> kuribas: it tries to make me indent the entire body of my module slightly.
14:18:17 <kuribas> It does?
14:18:22 <quicksilver> kuribas: fortunately, though, it "learns" after the first non-indented line
14:18:30 <quicksilver> so it's not a big problem in practice.
14:18:35 <Cale> quicksilver: It doesn't really, does it?
14:18:49 <kuribas> quicksilver: It doesn't for me.
14:18:54 <quicksilver> kuribas: hmm
14:19:17 <kuribas> I'll upload my new version.  Can you see if it still does so?
14:19:25 <Cale> Apparently the exception is that the 'module' keyword itself may be indented, but that this in itself doesn't introduce an indentation level on the stack.
14:19:26 <quicksilver> kuribas: it doesn't.
14:19:39 <quicksilver> kuribas: I think it must have been a aerlier version
14:19:41 * Cale tries it
14:19:41 <quicksilver> kuribas: sorry :)
14:20:13 <Cale>     module Foo where
14:20:13 <Cale> a = 5
14:20:16 <Cale> ^^ that is valid
14:20:24 <Cale> hmm
14:20:32 <kuribas> quicksilver: I've just fixed some of the bugs, so I'll upload a new version in a moment.
14:20:51 <Cale>     a = 5
14:20:51 <Cale> b = 10
14:20:58 <Cale> ^^ that (as a complete file) is not
14:21:11 <Cale> (because the b is not sufficiently indented)
14:21:11 <quicksilver> kuribas: nice.
14:21:31 <quicksilver> module Foo where
14:21:34 <quicksilver> a = 5
14:21:40 <quicksilver> Cale: ^^ IMO that is an exception ot the layout rule
14:21:46 <Cale> no, it's not
14:22:02 <quicksilver> Cale: because for all other layout constructs, that would read as module Foo where {} a = 5
14:22:27 <Cale> hmmm
14:22:52 <quicksilver> e.g, class Foo a where\nx :: a -> Int
14:22:57 <quicksilver> that 'x' is not a method of Foo.
14:23:00 <quicksilver> Foo has no methods.
14:23:57 <rovar> I'm working on question #4 of the 20 intermediate questions. I think I've substituted the types to create the function param correctly...  :   (a -> b) -> (EitherLeft x) a ->  (EitherLeft x) b    - i just have no idea how to get that result
14:24:34 <Peaker> cool thing, yairchu discovered that the Producer/Consumer thing we worked on (for Python-like generators) is very useful in the list monad, and not just the IO monad -- its like the normal list monad, except you get a bit more modularity, as the monadic computation allows its consumer to apply actions in between the list monad actions.  Its probably like using ContT [], but a bit easier to grok :)
14:25:36 <Saizan_> Peaker: don't you need Codensity to make it a monad?
14:25:44 <Peaker> Saizan_: Codensity?
14:25:47 <Saizan_> at least you need it for ProducerT
14:26:00 <Saizan_> Peaker: the forall r. ContT r thing.
14:26:45 <Peaker> Saizan_: not sure what you mean,  Producer is not a monad, but there's a Cont-based ProducerT monad to avoid passing continuations explicitly when generating Producers, and ConsumerT is a monad transformer that allows interlacing consumer actions between the producer's actions
14:27:25 <Peaker> Saizan_: Producer should probably be a monad with list-monad-like semantics, but we haven't implemented that yet (given the effects involved, its not clear its a good idea)
14:27:37 <kuribas> quicksilver: The layout list can start at the same column, I think.
14:28:17 <Peaker> Saizan_: the idea is that you write something like:   blah = producer $ do { <lifted actions> ; yield <value> ; <lifted actions> ... } and the yields interlace the consumers actions with the generated value there
14:29:02 <Peaker> Saizan_: in the list monad, that means the consumer gets to "guard" there, for example, so can filter out large unwanted computations based on part of the list monad's output, allowing for both performance and modularity there
14:29:47 <Peaker> say:  someProducer = produce $ do { x <- lift [1,2,3] ; yield x ; .... }   the yield allows the consumer, also in the list monad, to put a guard that filters out even numbers, so the whole x=2 branch is not computed
14:30:26 <Peaker> with the current list monad, someProducer would generate the whole list-monad result, and filtering on that would be slow (as it would filter *after* generating all the options with x=2 in them)
14:30:56 <Peaker> I wonder if we should write a paper, or just put a documented cabal package online
14:32:52 <Peaker> so usually you'd create less modular code where the generation & pruning happens at the same place
14:33:10 * Peaker wonders if anyone is listening :)
14:34:15 <dankna> sure, I'm listening
14:34:18 <dankna> have nothing to say though
14:35:21 <zebrafinch> Peaker: the guard-before-generating-everything application reminds me of Oleg's lazy nondeterminism paper, although I'm only partway through it atm
14:35:53 <Peaker> zebrafinch: there's a library described on reddit for doing heuristic search pruning in a monad -- it seems to be a special case of Producer on the list monad
14:37:35 <tommd> Wahoo!   Password changes for Hackage-server.  Things just keep getting better bit by bit.
14:39:41 <Peaker> zebrafinch: Oleg's paper describes a library or what?
14:39:43 <Peaker> zebrafinch: the cool thing is that this library also replaces Iteratee..  It just seems to have surprising scope :)
14:41:07 <copumpkin> producer sounds awfully concrete... can't we call it generamorphism or something?
14:42:27 <Peaker> e.g: print . bfs . iscanl t [] . permute $ "abc"        vs:     print . dfs . iscanl t [] . permute $ "abc"              where permute is defined very generally -- so you can bfs or dfs it without breaking modularity
14:42:44 <Peaker> @pl t x y = return $ y : x
14:42:45 <lambdabot> t = (return .) . flip (:)
14:45:24 <dons> http://twitter.com/tomlokhorst/statuses/2539313506   Haskell'10 : I like it :)
14:47:45 <ehird> dolio: please let's not do the two-digit year mistake again...
14:48:26 <ehird> er
14:48:27 <ehird> dons:
14:50:06 <dolio> We need an acronym with some Rs and numbers.
14:50:20 <dolio> To confuse people looking for scheme standards.
14:50:41 <Saizan_> hah
14:50:59 <ehird> Really Really Really Really Really Really Really Reckoned-with Awesome Language Haskell
14:51:13 <ehird> (Awesome replaces Algorithmic)
14:51:17 <ehird> R7RH
14:51:20 <copumpkin> lol
14:52:21 <ehird> i wish the title of the scheme reports expanded the Revised^N
14:52:53 <ehird> in 100 years the blogosphere will be a-twitter about how Revised Revised Revised Revised Revised Revised Revised Revised Revised Revised Revised Revised Revised Revised Revised Report on the Algorithmic Language Scheme kicks Haskell’109's ass
14:53:57 <dankna> Let's hope they call it Haskell2109 or there could be some significant year 3100 problems
14:54:14 <ehird> 22:47 ehird: dolio: please let's not do the two-digit year mistake again...
14:54:16 <ehird> Way ahead of you.
14:54:19 <dankna> haha okay
14:54:40 <ehird> Yeah, so it's not relevant _now_. Insert blabber about learning from the mistakes of the past; are we going to use 4-digit years when it hits XX80 all the time?
14:54:45 <ehird> Then stop at YY50?
14:55:38 <dankna> at least one software system I've seen which had been thoroughly revised for y2k actually had code that checked the current year for the purpose of converting two-digit to four-digit...
14:55:46 <dankna> which strikes me as error-prone, depending on what components of the system use it
14:56:11 <dankna> but it seems to reflect an assumption that people are going to keep wanting to use abbreviations
14:56:12 * Saizan_ would hope we'd have found some better language by 2100 anyway
14:56:27 <ehird> Saizan_: that's not even the point though
14:56:31 <pikhq> We've been using C for nearly 40 years now.
14:56:35 <ehird> we realized using two-digit numbers breaks things really badly
14:56:39 <ehird> so we started using four-digits
14:56:44 <ehird> now, when it seems important is so far away
14:56:44 <dankna> if you always apply that filter soon after the textual year is entered into the system, it might actually be the right approach
14:56:49 <ehird> so we say "hey, why not make the same mistake"?
14:56:55 <ehird> and so history repeats itself
14:58:05 <pikhq> ehird: You've got to give UNIX guys some credit; at least they're responding to y2038 by making their basic time measurement cover what is likely all of time.
14:58:18 <pikhq> (64-bit time_t, IIRC, should get us from Big Bang to heat-death of the Universe)
14:58:44 <ehird> pikhq: tell me that once we've established a schedule of traveling back in time every N millennia to avoid that >:)
14:59:21 <pikhq> Then, of course, we'll redo the whole thing by making time_t a bignum.
14:59:22 <pikhq> ;)
14:59:30 <kulakowski> It's something like 300 billion (american billion) years for 64 bits
14:59:56 <ehird> The question is why we're not using bignums for it already.
15:00:08 <ehird> kulakowski: american billion is the only kind; the other format is dead even in the UK
15:00:36 <pikhq> ehird: ... Because the lifespan of the Universe is probably long enough?
15:01:06 <ehird> pikhq: the lifespan of the universe according to what we currently know; and "good enough" isn't good. there's no reason NOT to use a bignum, only potential advantages
15:01:10 <cytzol> you shouldn't rest until every elementary particle has its own IP address
15:01:15 <ehird> and if we use a bignum, we never ever have to change it
15:01:24 <kulakowski> ehird: I think it's more non-English speaking Europe that uses long scale now, but I'm sure everyone in this channel uses short, just a habit.
15:01:27 <ehird> so why use a fixed size "integer"? because that is what is non-awkward in C.
15:01:30 <ehird> it's kludgey
15:01:51 <ehird> kulakowski: ah
15:01:53 <pikhq> You're saying this about UNIX.
15:02:05 <pikhq> UNIX is the embodiment of the kludge spirit.
15:02:20 <ehird> I know, and I hate it :)
15:02:29 <ehird> well, I like worse is better
15:02:32 <ehird> just a purist form of it
15:02:55 <pikhq> A, ah, purely functional form of it?
15:02:57 <pikhq> :P
15:02:59 <mux> so it seems the utf8-string provides various ways to get utf-8 strings into bare String's
15:03:05 <ehird> pikhq: doesn't seem to function in practice :-)
15:03:12 <ehird> mux: just use Strings?
15:03:18 <ehird> and the IO functions from utf8-string
15:03:18 <mux> I've been able to get rid of the utf-8 control characters with filter isPrint . decodeString
15:03:58 <jeffwheeler> (Just documentation . . .)
15:04:06 <jeffwheeler> err, sent that out before HackageBot
15:04:12 <ehird> haha
15:04:14 <hackagebot> hsparql 0.1 - A SPARQL query generator and DSL, and a client to query a SPARQL server. (JeffWheeler)
15:04:14 <ehird> time traveler!
15:04:22 <ehird> <jeffwheeler> (Just documentation . . .)
15:04:22 <jeffwheeler> There it goes
15:04:22 <mux> the problem was with regexps who'd choke on the utf-8 control sequence
15:04:25 <ehird> FTFY
15:04:39 <ehird> jeffwheeler: may I interest you in some unicode: …?
15:05:01 <jeffwheeler> ehird: I'd love it, and I used to always use that when I had a Mac; same goes for curly quotes
15:05:07 <jeffwheeler> ehird: because on a Mac, they're easy to type
15:05:15 <ehird> jeffwheeler: Make a keyboard map, man!
15:05:19 <jeffwheeler> ehird: unfortunately, I can't seem to find a convenient way to do it on Linux
15:05:19 <ehird> I'm assuming you don't use Windows.
15:05:24 <ehird> If you use Windows, just cry yourself to sleep :-P
15:05:28 <ehird> jeffwheeler: It's an X11 thing
15:05:30 <jeffwheeler> ehird: haha, no; I'm on Ubuntu
15:05:40 <jeffwheeler> ehird: yeah, but I don't want to do it half-assedly; I want the full Mac keymap
15:06:34 <ehird> Well foo to that :-) I bound my own keys because the option and option-shift map lacks ←→↑↓↖↗↙↘λ‽⌃⌥⌘⇧¹²³⁴⁵⁶⁷⁸⁹⁰☺☹
15:06:37 <jeffwheeler> Anyways, according to the Chicago Manual of Style, it's supposed to be a thin space between each period, so I really need a way to type that, not the Unicode character.
15:06:44 <ehird> All of which are vital. Especially ☺
15:06:53 <jeffwheeler> ehird: haha :D
15:06:56 <ehird> jeffwheeler: the unicode character should render as that, anyway
15:07:06 <pikhq> jeffwheeler: Compose key.
15:07:06 <ehird> if it doesn't, well, that's the viewer's choice :P
15:07:08 <jeffwheeler> ehird: it should, but I think I'd like to have the expanded version
15:07:19 <ehird> jeffwheeler: … is quite spaced here
15:07:25 <ehird> . . . always looks weird to me ;)
15:07:26 <ehird> *:)
15:07:41 <pikhq> … isn't spaced to me, but that's because I've got a monospace font.
15:07:47 <jeffwheeler> ehird: Yeah, but I prefer . . . to ... anyday; … is definitely the best of the three
15:07:50 <pikhq> So, it's three dots in the space of a single char.
15:07:54 <ehird> I even bound subscript numbers and a unicode blackface smiley, but they were shifted and it won't accept that.
15:08:06 <ehird> pikhq: Monospace… is… awesome… for… natural… language… text… not… really.
15:08:12 <ehird> Okay, this is a #haskell-blah topic
15:08:21 <pikhq> Totally.
15:08:36 * jeffwheeler goes to announce my pkg
15:10:17 <jeffwheeler> The standard is to send to haskell@, and set the reply-to to haskell-cafe@?
15:10:40 <ehird> The standard is to subvert the standard!*
15:10:42 <ehird> *Not really.
15:10:59 <jeffwheeler> :(
15:12:17 <dons> i'd announce on haskell@ AND haskell-cafe@
15:12:51 <ehird> I'd announce on both of those and rec.pets.cats.
15:12:57 <ehird> Just in case.
15:13:30 <jeffwheeler> dons: okay, thanks
15:13:34 <jeffwheeler> ehird: uh . . . :D
15:14:00 <ehird> jeffwheeler: Hey, there are cats who code Haskell. They might want to know (cf http://arcanux.org/lambdacats.html)
15:14:51 <byorgey> ehird: but cats don't read rec.pets.cats.  they read rec.pets.humans.
15:15:10 <ehird> byorgey: Sure cats read rec.pets.cats; as long as they're pets, I guess.
15:16:23 <pikhq> Or if they have cats themselves.
15:16:37 <ehird> Kinky?
15:16:42 <ehird> Aaaanyway.
15:17:40 <kuribas> quicksilver: http://kuribas.hcoop.net/haskell-indentation.el
15:18:05 <kulakowski> the io-monad one is sort of
15:18:11 <kulakowski> well I dont want to be that cat
15:18:51 <ehird> kulakowski: thanks for writing hs-indentation.el
15:18:53 <ehird> it's nice.
15:19:19 <kuribas> ehird: A third indentation mode?
15:19:40 <ehird> No.
15:19:43 <ehird> I was abbreviating ;)
15:19:57 <pikhq> Thanks for the Emacs love.
15:20:28 <ehird> pikhq: Wait, who said I love Emacs? ;-)
15:20:30 <kulakowski> being just ahead of someone alphabetically is fun
15:20:44 <ehird> oops :-D
15:20:47 <ehird> kuribas: redirect it at you.
15:20:51 <pikhq> kuribas: Thanks.
15:21:01 <kuribas> :)
15:21:04 <pikhq> ehird: It's got Lisp. Thou shalt like the Lisp.
15:21:16 <ehird> it's got a lisp without lexical scope. or closures.
15:21:36 <ehird> or namespaces of any sort where the prevailing style is "let's have a TON of symbols in one environment!".
15:21:43 <pikhq> What, you expect it to not be hackish yet run on UNIX?
15:21:43 <pikhq> :P
15:22:10 <Twey> Heh
15:22:27 <Twey> Some emacsen have CL or Scheme.
15:22:39 <Twey> They're just not as popular.
15:22:43 <Twey> Which... disturbs me.
15:22:47 <ehird> like climacs or edwin?
15:23:01 <ehird> they don't even have the popular extension base that makes emacs worth using at all
15:23:18 <kulakowski> Twey: how long do you think it would take to rewrite every emacs mode included with GNU emacs, if you could port them as fast as you could type?
15:24:01 <ehird> kuribas: about 25000000 words, would you say?
15:24:05 <pikhq> Wasn't there one Emacs that implemented Emacs Lisp in CL?
15:24:06 <Twey> Me?  I don't know, I don't speak elisp
15:24:17 <Twey> pikhq: xemacs is thinking of switching to CL
15:24:21 <ehird> er
15:24:22 <ehird> kulakowski:
15:24:22 <Twey> IIRC
15:24:29 <pikhq> Twey: Huh.
15:24:32 <ehird> kulakowski: if 25000000 words, then 5.7 months.
15:24:43 <ehird> Twey: now THAT'D get me to use xemacs
15:24:50 <pikhq> Can't say I blame them; Elisp had a time and place, and it no longer does.
15:24:53 <Twey> Yeah.
15:25:17 <Twey> Actually, I should confirm that: I heard it from #emacs, so reliability is questionable
15:25:43 <kulakowski> Yeah it's not like there was much choice in 1654 of suitable langues
15:25:46 <kulakowski> languages
15:25:58 <ehird> kulakowski: including scheme and cl :)
15:26:09 <ehird> Twey: oh, we're talking #emacs truth
15:26:28 <Twey> Oh, here we are
15:26:30 <Twey> http://gd.tuwien.ac.at/.vhost/xemacs.org/Architecting-XEmacs/lisp-engine.html
15:27:08 <Twey> « The only language change that I could possibly imagine justifying would involve switching to some ubiquitous web language, such as Java and JavaScript, or Perl. (Even among those, I think Java would be the only possibility that really makes sense). »
15:27:12 <Twey> Oh gods no
15:27:31 <ozy`> there are emacs clones on the JVM
15:27:37 <ozy`> they have no souls
15:27:47 <ozy`> so you have to surgically remove your soul to make them compile
15:28:01 <ehird> ozy`: you mean like the J editor?
15:28:01 <ozy`> naturally this does not result in an enthusiastic user base
15:28:08 <ehird> that has ABCL built in I think, maybe
15:28:12 <ehird> J is quite nice though.
15:28:21 <ehird> 23:27 Twey: « The only language change that I could possibly imagine justifying would involve switching to some ubiquitous web language, such as Java and JavaScript, or Perl. (Even among those, I think Java would be the only possibility that really makes sense). »
15:28:25 <ehird> that's the weirdest sentence I've ever read.
15:28:40 <jeffwheeler> I'd use Hayoo so much more if it had an easy URI like Hoogle.
15:28:43 <Twey> WTF
15:28:46 <ehird> it's grammatically formed and appears to be expressing an opinion… but I can't detect a trace of cognition
15:28:50 <Twey> Hah
15:28:56 <Twey> I think the person who wrote this may be an idiot
15:29:08 <ehird> idiots generally have a brain, it's just a bad one
15:29:17 <kulakowski> That page mentions `Emacs 18'
15:29:21 <ehird> i think this may be written by a non-sentient AI
15:29:23 <Twey> « Switching to a language that is more standard and more commonly in use would be beneficial for various reasons. First of all, the language that is more commonly used and more familiar would make it easier for users to write their own extensions and in general, increase the acceptance of XEmacs. »
15:29:29 <Twey> ... blah blah blah ...
15:29:35 <Twey> « However, both Scheme and Common Lisp flunk the familiarity test. Neither language is being actively used for program development outside of small research communities, and few prospective authors of XEmacs extensions will be familiar with any Lisp variant for real world uses. »
15:29:40 <Twey> o.@
15:29:48 <Twey> Additionally:
15:29:57 <Twey> « The object-oriented paradigm is the dominant one in use today for new languages. User interface concepts in particular are expressed very naturally in an object-oriented system. However, neither Scheme nor Common Lisp has been designed with object orientation in mind. There is a standard object system for Common Lisp, but it is extremely complex and difficult to understand. »
15:30:14 <ehird> Twey: LOL
15:30:21 <kulakowski> wow
15:30:25 <ehird> CLOS is incredibly simple and elegant...
15:30:31 <ehird> This person clearly hasn't used Lisp properly.
15:30:47 <Twey> Mr. Wing, sir, if you are listening: you have the I.Q. of a semolina pudding
15:30:53 <Twey> And your homepage is full of <font> tags
15:31:09 <kulakowski> I do think that page is about 9 years old though
15:31:18 <Twey> I'm not sure which is the greater insult, but at least one is objectively true
15:31:23 <Twey> kulakowski: That's true
15:31:32 <Twey> But CL is, what, twenty years old?
15:31:47 <pikhq> "Few prospective authors of XEmacs extensions will be familiar with any Lisp variant"...
15:31:53 <Twey> Fifteen
15:32:02 <pikhq> You mean few Elisp authors are familiar with Lisp?
15:32:03 <ehird> @remember Twey <Twey> Mr. Wing, sir, if you are listening: you have the I.Q. of a semolina pudding <Twey> And your homepage is full of <font> tags <Twey> I'm not sure which is the greater insult, but at least one is objectively true
15:32:04 <lambdabot> I will never forget.
15:32:34 <ehird> Twey: his homepage is on 666.com, lol
15:32:34 <kulakowski> Even if any of those arguments were valid, it would seem to beg to make Python the scripting language wouldn't it? Basically as a lowest common denominator of scripting languages that everyone would be able to hack at? And has objects?
15:32:37 <ehird> hey, I've seen this page before
15:32:38 <Twey> Yeah :-P
15:32:38 <ehird> I'm sure
15:32:47 <ehird> "In former incarnations, I've been a software developer (I am the chief architect of XEmacs),"
15:32:52 <ehird> Buh?! They put him in charge of this thing?!
15:33:00 <ehird> Oh, wait, "architect".
15:33:06 <ehird> He writes the abstract proposals that nobody ever implements.
15:33:07 * Twey pain
15:33:10 <Twey> Haha.
15:33:17 <Twey> So *that's* what architects are for.
15:33:19 <Twey> I always wondered.
15:33:28 <ehird> Managers are the same but they don't have to write the proposals
15:33:45 <ehird> http://www.666.com/ben/images/art/morphine-150dpi.jpg // this painting reflects his xemacs development philosophy
15:33:56 <ehird> specifically, in the ideal situation, when you use xemacs, you will experience it
15:34:41 <Twey> Hahaha
15:36:54 <jeffwheeler> Does your first message on haskell@ get moderated? My haskell-cafe@ message went right through, but the other seems stuck.
15:46:50 <gOcOOl> is there a function in haskell core that tells me if a given number is prime or not? (i.e. testing for primality)
15:47:28 <mux> not in the Prelude, and not in standard packages either
15:47:29 <ehird> nope
15:47:33 <ehird> but you can write one
15:47:37 <mux> there are some packages for that on hackage though
15:47:42 <ehird> use a sieve or something unless it needs to be fast
15:47:44 <ehird> or use hackage yeah
15:48:09 <gOcOOl> ah ok, I'll check Hackage. thanks
15:48:21 <kuribas> @tell quicksilver My new version has fixed the module bug and the multiline string bug: http://kuribas.hcoop.net/haskell-indentation.el
15:48:22 <lambdabot> Consider it noted.
15:53:11 <byorgey> is there really a package with an efficient primality testing function?  I actually don't know of one.
15:53:53 <byorgey> aha, the Numbers package does
15:53:55 <byorgey> cool =)
16:01:22 <kulakowski> byorgey: are you using the isPrime or isProbablyPrime function in that package?
16:02:41 <byorgey> kulakowski: well, I'm not actually using either.  but looking at the source, I would use isProbablyPrime iterated a bunch of times.  isPrime is just trial division, if I wanted trial division I could write it myself =)
16:04:05 <kulakowski> byorgey: If you aren't looking to test arbitrarily large numbers, you can use the miller-rabin algorithm on a few particular numbers and it will be deterministic and not probabalistic.
16:04:31 <kulakowski> Off the top of my head, for anything less than 2^32, you can just test it with 2 7 and 61 as seeds
16:04:49 <byorgey> kulakowski: cool.  well, then that package ought to be improved.
16:04:53 <kulakowski> and then you don't have to drag in random stuff
16:05:03 <byorgey> i.e. a function with a comment saying 'this is guaranteed to be correct for all values less than blah'
16:05:08 <byorgey> yeah
16:05:14 <kulakowski> http://primes.utm.edu/prove/prove2_3.html if you are curious
16:07:23 <kulakowski> Is this for PE?
16:21:09 <solrize> http://en.wikipedia.org/wiki/AKS_primality_test
16:24:17 <mcnster> any gtk2hs wiz's around?  if so, have a look at http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6705#a6705
16:24:50 <mcnster> i'm trying to sort a TreeModel but running into problems and don't quite grasp the issues
16:28:42 <mcnster> Cale, hate to bother you... i forget if you were a gtk2hs wiz... :)
16:34:49 <mcnster> sigh.  maybe i should go on vacation too...
16:36:27 <rocketman> mcnster yeah!
16:37:04 <mcnster> life!
16:37:53 <mcnster> i've never seen the # so dead...
16:38:31 <rocketman> mcnster, twilight zone
16:39:06 <pikhq> That's on right now? Hot damn!
16:41:03 <deech> Hi all, I was wondering about the new Control.Exception. Since errors can now be thrown from anywhere, is there any reason for MonadError?
16:41:41 <rocketman> deech,  yes
16:43:42 <deech> rocketman, ok, I thought that I could now throw Exceptions from any function, but they can only be caught in the IO Monad.
16:44:29 <rocketman> this has always been
16:44:49 <roconnor> deech: you can catch errors thrown in MonadError outside IO
16:45:39 <deech> rocketman, oh, I hadn't realized that. roconnor, thanks, I didn't know that.
16:46:04 <roconnor> @type catch
16:46:05 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
16:46:08 <roconnor> @type catchError
16:46:10 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
16:46:35 <erisco> http://pastebin.ca/1488986 would this function, taken from the "Real World Haskell" book, be TCO'd?
16:46:58 <roconnor> > catch (throwError "Hi deech") (\x -> return x)
16:47:00 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:47:08 <roconnor> > catch (throwError "Hi deech") (\x -> return x) :: Either String String
16:47:10 <lambdabot>   Couldn't match expected type `Data.Either.Either
16:47:16 <roconnor> hmm
16:47:24 <roconnor> > catchError (throwError "Hi deech") (\x -> return x) :: Either String String
16:47:26 <lambdabot>   Right "Hi deech"
16:47:43 <roconnor> ... maybe not the most informative example. :/
16:47:59 <roconnor> > catchError (throwError "Hi deech") (\x -> return (x++"!")) :: Either String String
16:48:01 <lambdabot>   Right "Hi deech!"
16:48:06 <dons> erisco: yeah
16:48:12 <dons> erisco: its tail recursive :)
16:48:18 <ehird> roconnor: I'm trying to make a pun on (Right "Hi deech!") and failing.
16:48:30 <dons> compile with -O2 though, as it requires strictness analysis
16:48:40 <erisco> dons, how exactly is tail recursion defined? I thought it might have been defined as the innermost function call has the final answer
16:48:57 <erisco> dons, in this case, it doesn't, it just has a piece of it, and to me it would have to go back up the stack and build the list
16:48:58 <dons> well, this isn't actually. this recurses under a constructor
16:49:05 <roconnor> erisco: the term "Tail Call Optimization" isn't applicable to Haskell because Haskell is non-strict
16:49:07 <dons> so it suspends on the first (:)
16:49:11 <vinicius> > catch (1/0) (liftM id)
16:49:12 <lambdabot>   Couldn't match expected type `GHC.IOBase.IOException'
16:49:25 <dons> roconnor: well... tail calls are turned into loops, thanks to strictness analysis
16:49:29 <dons> but this isn't that case.
16:49:33 <jeffwheeler> dons: the hackage-daily-graph you posted to -cafe says that it's a 90-day rolling avg at the top, but the bottom axis suggests that it's sense the dawn of Hackage.
16:49:33 <deech> roconnor, oh so it returns an error in whatever monad it is currently in. In your example the Either monad, correct?
16:49:49 <dons> jeffwheeler: both are correct.
16:49:50 <jeffwheeler> Err, wait; nevermind
16:49:55 <erisco> roadwarrior, why does it use that terminology in the book?
16:49:56 <jeffwheeler> dons: hehe, yeah
16:50:06 <dons> erisco: because tail recursion /is/ relevant to haskell
16:50:15 <dons> because the implementation, ghc, uses strictness analysis.
16:50:30 <mcnster> dons, could you look at http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6705#a6705 and tell me why my treeiters aren't valid?
16:50:33 <dons> your function though will run in constant space thanks to lazines
16:50:39 <rocketman> #
16:50:39 <rocketman> square (x:xs) = x*x : square xs   isn't tail recursive
16:50:40 <dons> s. not TCO
16:50:58 <roconnor> deech: yes, throwError throws an error in the particular monad.  In this case throwError is Left, and catchError catches in this monad.  (note it must be the same monad to work together)
16:51:04 <erisco> rocketman, is it truly not?
16:51:18 <roconnor> erisco: I don't know I haven't read the book.  I disagree with dons.
16:51:23 <rocketman> erisco:  look  (cons (* x x) (square xs))
16:51:39 <dons> erisco: right. it is returning a list of cons nodes. the recursion isn't in the "tail position".
16:52:06 <roconnor> erisco: The important point is that "entering a function" does not push a stack frame like it does in strict functional languages.
16:52:14 <dons> roconnor: our implementation does different things, based on the results of strictness analysis, including turnign things into loops that don't touch the stack.
16:52:31 <erisco> rocketman, what does "cons" mean in your example?
16:52:42 <roconnor> erisco: in GHC it is "entering a case analysis" (or pattern match which is really the same) that pushes a stack frame.
16:52:48 <pikhq> erisco: That's Lisp-speak for :
16:53:47 <roconnor> dons: whatever GHC does to turn things into loops, it isn't tail call optimization.
16:54:19 <erisco> roconnor, does the square function get turned into a loop?
16:54:21 <Twey> rocketman: Try ((:) ((*) x x) (square xs)) :)
16:54:32 <roconnor> erisco: probably. :)
16:54:47 <roconnor> erisco: it realy depends on how it is consumed
16:54:47 <rocketman> What is a loop?
16:55:01 <dons> roconnor: that's interesting. so removing stack allocated thunks, when the recursive call is in the tail position, by inserting a tail call, isn't classical TCO?
16:55:17 <erisco> rocketman, something imperative languages use
16:55:49 <roconnor> dons: nope, because the function call isn't pushing a stack frame.  It is the case analysis (that often occurs right after a function call) that does the stack frame push (GHC specific).
16:57:06 <dons> so ghc uses eval/apply, right?
16:57:20 <erisco> roadwarrior, given that : is the last function called, not square, I am convinced it cannot be optimized
16:57:29 <dons> right, so we call the function.
16:57:33 <erisco> I mean roconnor*
16:57:39 <dons> then case.
16:58:08 <erisco> dons, are you replying to me? what do you mean by "then case"?
16:58:48 <roconnor> erisco: oh it can be, because the control flow is totally different from what you are thinking.  Even without strictness analysis it will probably run in constant space (depending on how it is used) because the recurive call is guarded by the (:) constructor
16:59:28 <dons> yes, this runs in constant space due to laziness. if it was strict it would be /worse/ :)
16:59:36 <roconnor> @let swap ~(x,y) = (y,x)
16:59:37 <lambdabot>  Defined.
16:59:55 <roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap (foo z xs) in foo 0 [0..1000000]
17:00:00 <lambdabot>   (0,500000500000)
17:00:11 <erisco> okay, but I do not understand why this optimization can still take place. hopefully I understand it by the end of the book
17:00:25 <roconnor> dons: ^^ this is the example I was using when understanding stack allocation in Haksell
17:00:32 <rocketman> which optimization?
17:00:46 <roconnor> notice that foo is not in the tail position, but it is fine because swap doesn't do case analysis
17:00:54 <roconnor> @let swap' (x,y) = (y,x)
17:00:55 <lambdabot>  Defined.
17:01:02 <roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap' (foo z xs) in foo 0 [0..1000000]
17:01:04 <lambdabot>   * Exception: stack overflow
17:01:17 <roconnor> now it stack overflows because swap' does do a case analysis
17:01:56 <roconnor> so the whole tail call thing is irrelevent.  It is all about where the various case analysis occur and where constructors are added.
17:03:09 <rocketman> roconnor yes except we can also have a strict sub-lang in haskell
17:03:20 <deech> I am trying to install lambdabot locally and ran into this error: HSreadline-1.0.1.0.o: unknown symbol `rl_completion_word_break_hook', I currently have libreadline5 and libreadline5-dev installed on my Ubuntu machine.
17:03:43 <rocketman> roconnor this fragment is not what e.g. I program in
17:03:58 <pikhq> rocketman: O.o
17:04:09 <pikhq> I think my brain just broke again.
17:05:04 <monochrom> We're in the business of breaking minds and challenging everything you knew.
17:05:10 <monochrom> At least I am.
17:05:32 <dolio> GHC already has (I think) a strict sub-language.
17:05:33 <roconnor> erisco: when (double list) is processed by case analaysis, it will only do enough computation to reach a constructor, in this case the constructor is (:).
17:05:37 <dolio> The types just aren't very interesting.
17:05:38 <roconnor> erisco: afterwards, often, the head of the list will be processed, while the tail of the list (contining the recurive call) remains suspended.
17:05:41 <roconnor> erisco: usually the head of the list will be freed before needing the tail.  Then, the tail will go under a case analysis again.  This will force one more step of recursion to expose another (:) constructor
17:05:44 <roconnor> erisco: and again the tail (contining the recursive call) will remain suspended again.
17:05:46 <roconnor> erisco: This all depends on how (double list) is consumed, but what I describe is a typical scenario.
17:06:00 <_roconnor> erisco: Essentially lists act give you a coroutine for consumer producer for free
17:06:06 <_roconnor> god damn connection
17:06:17 <monochrom> Hi more roconners :)
17:06:49 <_roconnor> ah, it seems everything I said got through.
17:06:49 <jeffwheeler> I thought one was amazing by himself
17:07:07 <erisco> roconnor, what do you refer to when you say case analysis? the case expression? pattern matching?
17:07:11 <jeffwheeler> I want to see them talk together; that'll break pikhq and my minds
17:07:20 <pikhq> monochrom: Function calls not using the stack. My brain went boom.
17:07:24 <_roconnor> erisco: pattern matchin is translated to case analysis, so yes, both.
17:08:14 <_roconnor> foo True = 1; foo False = 2  is translated into foo x = case x of {True -> 1; False -> 2}
17:08:16 <mmorrow_> erisco: "case" is what triggers evaluation
17:08:39 <monochrom> Even for executing eager languages, stack is not necessary. Stack is an optimization by itself, using space to save time.
17:08:56 <monochrom> Or actually using some space to save time and more space.
17:10:19 <monochrom> Suppose you're executing "f(g(0))" as C. Nothing says you need a stack or even a program counter. Here is an inefficient but correct way to execute it.
17:10:55 <monochrom> So first you go over "f(g(0))" and decide that eagerness means you have to process g(0) first. Expand it using the definition of g.
17:11:04 <_roconnor> erisco: often in Haskell we don't want "tail recursive function".  It is usually best to have function calls made underneath some constructor, which I might call "guareded recursive functions" or "corecursive functions"
17:11:36 <_roconnor> because the constructor "guards" the recursive call and delays it from occuring.
17:11:46 <dons> "recursion under a constructor" I think is also a common way to talk about that.
17:12:00 <pikhq> monochrom: That is both silly and impressive.
17:12:06 <_roconnor> dons: oh.  Good to know.
17:12:06 <monochrom> You probably get "f(return 0+5;)". Now you go over "f(return 0+5;)" again, and probably decide that you still have to further process the inner thing "return 0+5" first.
17:12:36 <monochrom> I need no stack. I just need to re-scan, re-scan, re-scan... Looking for "what should I do now?"
17:13:25 <erisco> _roconnor, hm, let me dwell on this
17:13:33 <_roconnor> erisco: take your time
17:13:45 <monochrom> The only purpose of the stack is to save all the re-scanning. You use the stack to remember "where was I last time so I can get back there quickly". If you don't need "quickly", where you were last time can still be unambiguously found everytime. It's just quadratically more expensive or something.
17:13:55 <_roconnor> erisco: this is a major hurdle when moving to Haskell from other languages.
17:14:25 <erisco> _roconnor, trying to write efficient functions? yeah
17:14:28 <monochrom> Stack is an optimization for eager execution. You can see it may be useless for some parts of lazy execution.
17:14:59 <_roconnor> erisco: efficient functions in Haskell are almost opposite what efficient functions in ML are. :)
17:15:27 <erisco> sorry, what does ML refer too?
17:15:39 <vinicius> Is there some datatype in the hierarchical library with Top and Bottom? Something like Maybe but with a 'Sure' top.
17:15:40 * erisco also finds the bombardment of new terminology confusing
17:15:44 <rocketman> ML Tne language
17:16:03 <pikhq> monochrom: I'm highly impressed.
17:16:05 <_roconnor> ML is a well-known strict typed functional language.
17:16:33 <_roconnor> erisco: efficient functions in Haskell are almost opposite what efficient functions in scheme are. :)
17:16:50 * _roconnor hopes that is more familiar?
17:17:03 <rocketman> he doesn't know scheme either..
17:17:10 <_roconnor> crap :(
17:17:26 <_roconnor> erisco: how do you even know what TCO is? :)
17:17:30 <rocketman> Try C#:)
17:17:40 <erisco> _roconnor, yes I know what TCO is
17:17:42 <rocketman> or python
17:17:48 <_roconnor> erisco: but how?
17:17:57 <erisco> _roconnor, what do you mean?
17:18:12 <erisco> _roconnor, what it stands for, yes, how it is implemented, not very clearly
17:18:15 <_roconnor> erisco: most people using scheme or ML need to know it.  But there is no TCO in C (in general) and presumably not in C#
17:18:37 <erisco> _roconnor, what I understood is that a recursive function could be TCO'd if the innermost function call returned the final result
17:18:54 <erisco> _roconnor, because then there would be no need to unwind the stack, thus it can be translated to a loop
17:18:59 <rocketman> that's not it
17:19:09 <_roconnor> erisco: yes, you do appear to understand TCO.  I'm just not sure where you picked it up.
17:19:14 <_roconnor> oh oops
17:19:36 <pikhq> rocketman: C#? I'm so sorry. Such a boring language.
17:19:37 <erisco> _roconnor, gcc does do tail optimization in cases
17:19:43 <_roconnor> erisco: really?
17:19:45 <_roconnor> wow
17:19:54 <rocketman> yeah
17:19:58 <pikhq> Yeah.
17:20:06 <_roconnor> erisco: anyhow.
17:20:21 <rocketman> lol
17:20:46 <_roconnor> erisco: IMHO completely forget about tail calls in Haskell.  Functions in Haskell have totally different operational behaviour.
17:21:06 <erisco> _roconnor, if I step through the evaluation of square manually, will I see how it could be optimized into a loop due to lazy evaluation?
17:21:27 <erisco> _roconnor, or it is something the compiler detects half-magically and not easily spotted?
17:21:59 <_roconnor> erisco: hmm. ... I would guess the latter, but I'm not sure.  BTW, TCO isn't really about making loops.
17:22:12 <_roconnor> erisco: making loops is a second step after TCO.
17:22:16 <rocketman> erisco in scheme it is syntactic and clear where tail calls are -- not in haskell
17:22:40 <monochrom> int f(int n) { if (n==0) { return n; } else { return f(n-1); } }   This doesn't use stack with gcc -O2.  Try it: gcc -O2 -S and look at the assembly code.
17:22:41 <_roconnor> a second step that may or may not be applicable in some cases.
17:23:12 <_roconnor> erisco: stepping through your double code would be a very instructive experince.
17:23:18 <_roconnor> erisco: I could try to illustrate
17:23:50 <_roconnor> er, square code
17:24:18 <Twey> Tail-calls are still useful for, e.g., huge lists
17:24:34 <_roconnor> Twey: not really, it is misleading
17:25:00 <Twey> How so?
17:25:47 <_roconnor> Twey: there are certain useful optimizations in Haskell that end up coincidentally putting the recursive call in the tail position in many of the common cases when this optimization is needed.
17:26:04 <_roconnor> but the optimization isn't "put the recursive call in tail position"
17:26:38 <_roconnor> I'm not sure what it is exactly, but I think it is "put the recursive call outside the case analysis
17:26:53 <_roconnor> hmm
17:26:58 <_roconnor> maybe that isn't quite right
17:27:15 <_roconnor> maybe it is
17:27:26 <_roconnor> maybe I should say "after" instead of outside.
17:27:48 <_roconnor> let x = expr in x `seq` (rec x)
17:27:59 <monochrom> Show an example for "Tail-calls are still useful for, e.g., huge lists". I don't know what it means. Really.
17:28:09 <_roconnor> in the above (rec x) is "after" the case analysis done by seq
17:29:21 <erisco> functions that do not take advantage of the optimization have stack overflows when given large lists, that is why it would matter
17:30:10 <_roconnor> erisco: right.  TCO is all about saving stack space.  You can do that without making a loop.
17:30:43 <_roconnor> erisco: however in TRE (tail recursion elimination) which occurs after (TCO), that turns things into loops.
17:30:56 <_roconnor> erisco: but that is a minor optimization to TCO
17:31:18 <_roconnor> erisco: TCO can transform linear (stack) space into constant space, while TRE just makes things go a little bit faster.
17:32:12 <erisco> well, I will keep going through the book. hopefully I can identify what makes this happen
17:32:15 <erisco> eventually
17:32:45 <dolio> The optimization is: manually cause eager evaluation to happen. :)
17:32:47 <_roconnor> erisco: probably best.  You should slowly get used to all this after some experience writing your own code and asking about it here. :)
17:33:23 <_roconnor> dolio: that might be right.  And you don't need to be in tail position to do that.
17:33:43 <_roconnor> Twey: observe the following example
17:33:55 <_roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap (foo z xs) in foo 0 [0..1000000]
17:34:00 <lambdabot>   (0,500000500000)
17:34:03 <_roconnor> vs
17:34:08 <_roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap' (foo z xs) in foo 0 [0..1000000]
17:34:10 <lambdabot>   * Exception: stack overflow
17:34:16 <ehird> how did _roconnor grow an _?
17:34:21 <erisco> he disconnected
17:34:24 <ehird> *a, maybe.
17:34:24 <bremner> he is excited
17:34:28 <_roconnor> Twey: notice that in neither case is foo in tail position
17:34:42 <dolio> We bombarded him with high energy gamma radiation.
17:34:48 <_roconnor> Twey: but one has a stack overflow, and one does not
17:35:08 <_roconnor> Twey: for reference: swap ~(a,b) = (b,a)  and swap' (a,b) = (b,a)
17:35:36 * erisco doesn't know what the tilde does :P
17:35:41 <erisco> but it looks important then!
17:35:46 <Twey> Hmmm
17:35:50 <Twey> I see
17:35:51 <ehird> think he meant !
17:35:56 <Twey> erisco: Lazy pattern matching
17:35:58 <Twey> ehird: No
17:35:59 <ehird> oh
17:36:07 <Twey> The ' is used to mark the stricter variant
17:36:17 <Twey> I guess (!a, !b) would be swap'' :-P
17:36:47 <_roconnor> erisco: the ~ is very rarely important.  But this is one example where it is.
17:36:47 <monochrom> ~ means ~.
17:37:02 <monochrom> ~ delays the pattern matching.
17:37:59 <monochrom> > let f (_,_) = True in f undefined
17:38:01 <lambdabot>   * Exception: Prelude.undefined
17:38:15 <monochrom> That sucks (kind of), doesn't it?
17:38:19 <monochrom> > let f ~(_,_) = True in f undefined
17:38:21 <lambdabot>   True
17:38:25 <monochrom> Success!
17:38:49 <monochrom> Of course, delay is not skip. Sometimes you procrastinate but still need to do it eventually.
17:38:59 <_roconnor> > let f (_,_) = True in f (undefined,undefined) -- for completeness
17:39:00 <lambdabot>   True
17:39:07 <monochrom> > let f ~(x,_) = x in f undefined
17:39:08 <lambdabot>   * Exception: Prelude.undefined
17:39:37 <monochrom> This one can't be helped because you really ask for the x eventually. The bomb is postponed but not avoided.
17:40:28 <monochrom> However, sometimes by just procrastinating a bit you save the day because you just need a few more steps to have the data ready.
17:41:38 <monochrom> Especially if you have f ~(x,y) = .... recursively call f ...
17:46:05 <rocketman> f ~(x,y) = (..,..) in fix f
17:46:18 <monochrom> Yes.
17:47:03 <monochrom> > let f (x,y) = (True,'A') in fix f
17:47:09 <lambdabot>   mueval-core: Prelude.read: no parse
17:47:09 <lambdabot>  mueval: ExitFailure 1
17:47:16 <monochrom> > let f ~(x,y) = (True,'A') in fix f
17:47:18 <lambdabot>   (True,'A')
17:47:57 <rocketman> > let f ~(x,y) = (y,'A') in fix f
17:47:59 <lambdabot>   ('A','A')
17:48:22 <_roconnor> > let f (x,y) = (y,'A') in fix f
17:48:28 <lambdabot>   mueval-core: Prelude.read: no parse
17:48:28 <lambdabot>  mueval: ExitFailure 1
17:48:42 <monochrom> If you force the pair too early, it does not exist yet, it bombs. If you postpone even by one step and allow yourself to see (True,'A'), suddenly the pair is ready and it won't hurt to force it later.
17:48:56 <kylebutt> How do you compose more than the final result in a function?
17:49:18 <kylebutt> e.g f :: a -> b -> c, g (b -> c) -> d
17:49:18 <monochrom> Sorry what does that mean?
17:49:47 <kylebutt> f . doesn't give what's expected.
17:49:47 <monochrom> g (f x) :: d
17:50:14 <kylebutt> monochrom: any point-free way?
17:50:32 <_roconnor> kylebutt: it's probably best to write out a lambda expression
17:50:37 <bd_> kylebutt: what are you trying to do? where does g come from?
17:50:38 <monochrom> (g . f) x :: d.  g . f :: a -> d
17:51:00 <_roconnor> however, (f .) . g  and ((f .) .) . g  might do what you want.
17:51:15 <_roconnor> @type (?f .) . ?g
17:51:16 <lambdabot> forall b c a a1. (?g::a1 -> a -> b, ?f::b -> c) => a1 -> a -> c
17:51:22 <kylebutt> I'm trying to write liftM point-free
17:51:26 <_roconnor> @type ((?f .) .) . ?g
17:51:28 <lambdabot> forall b c a a1 a2. (?g::a2 -> a1 -> a -> b, ?f::b -> c) => a2 -> a1 -> a -> c
17:51:38 <bd_> kylebutt: write it like this: liftM  :)
17:51:59 <kylebutt> bd_: it's an exercise, not a requirement.
17:52:08 <monochrom> @src liftM
17:52:09 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:52:25 <monochrom> @undo do { x1 <- m1; return (f x1) }
17:52:26 <lambdabot> m1 >>= \ x1 -> return (f x1)
17:52:37 <monochrom> m1 >>= (return . f)
17:53:02 <monochrom> liftM f = (>>= (return . f))
17:53:04 <rocketman> :t flip liftA2 (>>=) id . return
17:53:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
17:53:18 <rocketman> liftM2 = flip liftM2 (>>=) id . return
17:53:29 <bd_> @. pl . undo src liftM
17:53:29 <lambdabot> (line 1, column 3):
17:53:30 <lambdabot> unexpected "\n"
17:53:30 <lambdabot> expecting variable, "(", operator or end of input
17:53:32 <kylebutt> @type (return .) . (=<<) :: Monad m => (m a -> m b )
17:53:32 <bd_> :|
17:53:32 <monochrom> Ah flip would be useful.
17:53:33 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
17:53:34 <lambdabot>     In the expression: (return .) . (=<<) :: (Monad m) => (m a -> m b)
17:54:29 <monochrom> liftM f = (=<<) (return . f) = (=<<) ( (.) return f )
17:55:14 <monochrom> liftM = (=<<) . ( (.) return ) = (=<<) . (return . )
17:55:44 <monochrom> Brought to you by "let the symbols do the work".
17:56:34 <kylebutt> monochrom: I was just doing it backword.
17:56:58 <kylebutt> thanks.
17:59:55 <_roconnor> :t fmap fmap fmap `fmap` fmap fmap
17:59:55 <bododo> hi folks!
17:59:57 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) a1 b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> a1 -> b) -> f (f1 a) -> f (f1 (f2 a1 -> f2 b))
18:01:06 <bododo> I'm on debian lenny ppc, and It seems that I can't use ghci is this "natural"? It says that it wasn't built with that feature. ghc 6.8.2 - I'm really eager to learn haskell but without ghci that'd be hard :(
18:01:11 <bododo> any idea, please?
18:01:31 <FunctorSalad_> _roconnor: now find a problem solved by that...
18:02:38 <blackh> bobodo: Debian versions of GHC are old, and I think ppc is more advanced now.  If you download 6.10.3 from haskell.org it should solve the problem.
18:02:44 <monochrom> I think it's "natural". http://www.haskell.org/ghc/download_ghc_683.html#macosxppc may help.  But no ghc 6.10.x story.
18:03:54 <bododo> blackh: well, I did download the sources but it takes ages to build :(
18:04:13 <bododo> the .deb packages are only available for intel
18:07:08 <blackh> bobodo: Looking at the source code, it looks like powerpc support is there.  It should all work.  You just need to make sure ghci is enabled in your build.mk - I can't tell you the exact configuration.
18:07:27 <blackh> I've built ghc from source many times, and it works well.
18:07:46 <blackh> Not on powerpc, though
18:09:26 <bododo> blackh: but did it took "ages" to build?
18:09:39 <bododo> when I run "make" it never finishes
18:09:53 <bododo> this ibook G4 is not a beast
18:10:09 <monochrom> Oh, then maybe 4-8 hours.
18:10:43 <monochrom> About 4 hours for my several-years-old Intel 1GHz PC.
18:10:45 <blackh> bododo: It takes about half an hour on a core 2 duo (non-parallel build), so it'll take a while.
18:11:01 <bododo> :(
18:11:09 <monochrom> Admittedly my several-years-old PC also has a very slow system bus.
18:11:13 <bododo> no way to build it without ghc?
18:11:19 <blackh> PowerPC Macs are very slow
18:11:28 <bododo> dunno maybe with gcc alone?
18:11:42 <monochrom> Very hard to build without ghc.  Use ghc 6.8.3 binary first.  I posted a url.
18:11:58 <blackh> You can use lenny's ghc - you don't need ghci
18:12:06 <bododo> monochrom: hum... sorry, but I thought that it won't work on debian
18:12:22 <monochrom> Oh! Sorry.
18:12:32 <bododo> blackh: but I want to "learn" :) I'm still a noob
18:12:57 <monochrom> use lenny's ghc to help you build a newer ghc+ghci
18:13:03 <blackh> ^ That's what I meant
18:13:22 <bododo> monochrom: yes that's what I tried, and the make took hours and I stoped it
18:13:30 <monochrom> Watch for discolouration of your iBook after it's done.  <duck>
18:14:24 <bododo> :)
18:14:25 <blackh> bododo: You can still learn Haskell without ghci, but it's better to have it.
18:14:54 <bododo> anyway, I'll find a way to run, and I'll often come here to bug you with haskell questions! thanks you folks! :)
18:15:09 <bododo> blackh: yeah sure, that's how I actually learnt python
18:15:28 <_roconnor> what about hugs?
18:17:28 <bododo> yes, but I've been told that ghc is "better"? I don't know, just supposing
18:18:03 <bododo> and to be honnest, I'm such a stubborn, I won't give up on that ghci
18:18:04 <pikhq> Ghc is just a crazy-good and very complete implementation.
18:18:07 <monochrom> ghc has more language extensions.
18:18:27 <monochrom> hugs type error messages are cleaner.
18:19:23 <monochrom> cleaner means it omits the two words "inferred" and "expected" so you don't have to care what they mean. All you need is two conflicting types shown anyway.
18:20:03 <bododo> ok, thanks monochrom, I'll explore hugs then!
18:20:06 <m3ga> bododo: personally, i rarely use ghci. i tend to use 'runghc6 <file>' instead. you might try that with the installed ghc-6.8.x you have now.
18:21:02 <monochrom> ghc enjoys more libraries. actually probably you'll run into them sooner than you'll run into language extensions.
18:21:54 <bododo> ok, so I guess that I'll do it like real men do. Use "screen", and "vim" and ghc. :)
18:21:56 <monochrom> E.g. you follow RWH and then suddenly it says "let's play with ByteString!" and sudden you find it's too hard to have hugs use the ByteString library.
18:22:34 <bododo> ah8 I see now why use ghc rather than hugs
18:23:04 <Plouj> oh my gosh
18:23:10 <Plouj> there is no glew libary for haskell!
18:23:24 <monochrom> I started with hugs when I learned Haskell. This was because I just read the Gentle Introduction and there was no RWH or even YAHT.  I didn't need anything extra.
18:23:45 <aavogt> no YAHT?
18:23:55 <pikhq> Yet Another Haskell Tutorial.
18:23:57 <aavogt> that's quite some time ago
18:24:05 <ozy`> monochrom: I hear you on the error message thing. took me a fair bit of practice to get used to reading the error messages... I suspect more people are driven away by GHC's error messages than by the term "monad"
18:24:11 <monochrom> Right, YAHT was after I learned Haskell.
18:24:44 <bododo> thanks for the info y'all :) I actually learnt lisp some 11 years ago (back when I was a student) and I wanted so hard to write functional code again
18:24:53 <monochrom> Actually I don't see the problem with GHC type errors either. Apart from "what is inferred and what is expected?"
18:25:36 <ozy`> I exaggerate my plight :p
18:26:14 <monochrom> I never really cared what is inferred and what is expected. I ignore those two words. So OK it says "look at this expression", "it's at line x column y", "something wants it [Int]" "something else wants it [[Char]]".  OK I see, it's perfectly clear and informative.  I don't understand what more you could expect.
18:26:16 <roconnor> people like python.  It doesn't complain when their programs are wrong.
18:26:39 <monochrom> Only tenable complaint is the infinite-type business.
18:27:07 <bododo> thanks again folks! see you very soon!
18:27:44 <aavogt> as in, what is an infinite type? or why they are not allowed?
18:27:57 <kulakowski> a = [a]
18:29:39 <aavogt> kulakowski: Haskell has limited my creativity, what does the result look like when you have an infinite type?
18:29:46 <monochrom> Some people want the compiler to start being Paper Clip and suggest things like "maybe you are calling a 3-parameter function with 2 parameters!"  I say that's bunk.
18:30:08 <aavogt> clippy I believe it calls itself
18:30:12 <monochrom> IMO the best type error message is an electric shock sent to the programmer.
18:30:45 <monochrom> And the second best looks like "you want it [Int] and you want it [[Char]] too. Why don't you make up your mind now?"
18:31:30 <monochrom> The third best is take the second best and add two sequent deductions showing how [Int] and [[Char]] are arrived at.
18:31:44 <kulakowski> aavogt: well if the type a is equal to a list of a's, then a = [[a]] too, and a=[[[a]]], and [[[[a]]]], and...
18:31:58 <pikhq> The worst type involves magically making an [Int] into a [[Char]]
18:33:10 <monochrom> f (x:xs) = xs:x  is how you can achieve infinite type.
18:33:48 <monochrom> Try it! It won't give you an electric shock because those sissy people are so friendly.
18:34:15 <monochrom> perhaps f(x:xs) = f(xs:x) is even better.
18:35:20 <pikhq> That would just be a type failure, I think...
18:35:22 <pikhq> :t (:)
18:35:23 <lambdabot> forall a. a -> [a] -> [a]
18:35:47 <pikhq> xs:x would be [a] -> a -> [a]. Which is... Not right.
18:36:17 <aavogt> kulakowski: so you aren't going to have any actual values with infinite types, unless of course you have implicit coercions like [[a]] -> [a]
18:37:24 <dolio> a = [a] has plenty of values.
18:37:45 <aavogt> []?
18:37:46 <dolio> [], [[]], [[],[]], [[[]],[],[[[]]]], ...
18:40:21 <Rotaerk> hmm... unlines and unwords shouldn't really be called that
18:40:36 <Rotaerk> because their names suggest that they're the inverse of lines and words, when they're not
18:41:00 <aavogt> @type unlines . lines
18:41:01 <lambdabot> String -> String
18:41:21 <dolio> They aren't the exact inverse, but they're about as close as you'll get.
18:41:47 <aavogt> @check \x -> (unlines . lines) x == x
18:41:48 <lambdabot>   "Falsifiable, after 1 tests:\n\"\\343779\\73596\"\n"
18:42:09 <monochrom> almost_inverse_of_line_but_not_quite_see_the_doc_for_details is a really meaningful identifier name.
18:42:15 <Rotaerk> :P
18:42:39 <aavogt> @check \x -> (lines . unlines) x == x
18:42:42 <Rotaerk> I was thinking a name that describes directly what they do, without being in reference to their semi-counterparts
18:42:43 <lambdabot>   "OK, passed 500 tests."
18:43:03 <dolio> You need to camel case that bad boy to achieve Java compliance.
18:43:52 <monochrom> Every English-inspired name under 10 letters long will not describe directly what it does.
18:44:04 <monochrom> Chinese may get closer.
18:44:49 <pikhq> monochrom: Needs more objects.
18:45:47 <Rotaerk> monochrom, that's cause chinese has far too many characters
18:46:48 <lament> \o/ chinese identifiers
18:47:37 <tavelram> is there some abstract notion of "File", or do i need to write one version for posix and one for win32? System.Win32.File is only FFI, while posix isnt...
18:48:00 <tavelram> or would it actually be possible to use posix on ghc under windows?
18:48:15 <erisco> as per the real world haskell book, I am trying to make a splitWith function that splits a list into a list of lists with the separator being when the predicate returns false on one of the list elements
18:48:29 <erisco> much like words splits on whitespace, but this generic
18:48:55 <erisco> I had no idea how to do it first, but now reading about folding gave me an idea
18:48:56 <erisco> http://pastebin.ca/1489071
18:49:06 <Rotaerk> erisco, heh, I'm actually in that same exercises section of the book
18:49:09 <erisco> but I get an error and I am unsure as to what is going on
18:49:30 <erisco> Rotaerk, I am half-way through chapter four and just coming back now with hopes of solving it :
18:49:31 <erisco> :(
18:49:38 <Rotaerk> ah
18:49:47 <erisco> Rotaerk, did you have better luck?
18:49:55 <Rotaerk> I am on the previous exercise
18:49:58 <monochrom> Haha talk about infinite types.
18:50:10 <erisco> monochrom, I know, you guys just had an infinite type problem
18:50:17 <erisco> I get them very often and I really do not get what is causing this one
18:50:31 <monochrom> "whole : part" ?
18:50:34 <erisco> both w and p are supposed to be a list of a variable type
18:51:07 <monochrom> with all due respect it ought to be (whole,part) shouldn't it?
18:51:09 <erisco> monochrom, yes, my thought was to step through the array keeping two accumulators... one for all the parts (the whole) and one for building the part
18:51:31 <monochrom> I should really look what step is doing.
18:51:38 <erisco> monochrom, splitWith is supposed to return a list of lists, wait
18:51:38 <monochrom> @type foldl
18:51:40 <erisco> hmm
18:51:40 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:51:59 <erisco> monochrom, I guess I need to wrap that all in a list then yes?
18:52:05 <aavogt> @type pred
18:52:05 <erisco> I don't know :P
18:52:06 <lambdabot> forall a. (Enum a) => a -> a
18:52:22 <erisco> monochrom, I think you've given me a hint as to what I did wrong
18:52:26 <erisco> monochrom, give me a second here
18:52:29 <aavogt> shadowing identifiers can be tricky at times
18:53:38 <monochrom> order of parameters of step is wrong. should be step (w,p) x.
18:54:49 <erisco> monochrom, I don't think so are they? I thought the accumulator came second
18:55:07 <monochrom> @type foldl
18:55:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:55:13 <monochrom> I trust that only.
18:55:14 <erisco> monochrom, after thinking I knew what was wrong, I discovered that I no longer know what is wrong
18:55:36 <monochrom> Take inspiration from the source code of "lines" and "words" instead.
18:55:44 <erisco> monochrom, the problem seems to be in my step definition, not my usage of foldl, surely?
18:56:16 <monochrom> @src lines
18:56:16 <lambdabot> Source not found. :(
18:57:10 <erisco> @src words
18:57:11 <lambdabot> words s = case dropWhile isSpace s of
18:57:11 <lambdabot>     "" -> []
18:57:11 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:58:00 <erisco> words does not quite do what I want it to do I do not think
18:58:20 <erisco> as, if I understand the problem correctly, I am not supposed to drop any of the elements
18:58:26 <erisco> or maybe it did not specify
18:58:50 * erisco does not know what to do anymore
18:59:19 <aavogt> > groupBy (const $ not . isSpace) "hello this is a space keeping words "
18:59:20 <erisco> okay, my original thought was that the separator itself gets put into the next part
18:59:21 <lambdabot>   ["hello"," this"," is"," a"," space"," keeping"," words"," "]
18:59:23 <Tsion> Whoa, I didn't realize otherwise wasn't just special syntax for guards. I should read the Prelude
19:00:01 <aavogt> > otherwise == True
19:00:03 <lambdabot>   True
19:00:14 <aavogt> > otherwise
19:00:16 <lambdabot>   True
19:00:46 <erisco> monochrom, does my function make any sense at all?
19:01:02 <Tsion> aavogt: Yeah I noticed that while reading the Prelude ;)
19:01:07 <erisco> it makes perfect sense to me, I just need to convince Haskell of it
19:02:37 <erisco> monochrom, I fixed my first error! I keep forgetting when I need : versus ++
19:02:53 <ivanm> @type (:)
19:02:54 <lambdabot> forall a. a -> [a] -> [a]
19:02:57 <ivanm> @type (++)
19:02:58 <lambdabot> forall a. [a] -> [a] -> [a]
19:03:14 <monochrom> @let step ' ' (w,p) = (w, ' ':p); step x (w,p) = (w : p, x : [])
19:03:16 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
19:03:19 <pikhq> Tsion: Why would it be a special syntax for guards?
19:03:21 <erisco> ivanm, thanks, but really the effort is in vain because I can hardly understand type signatures at this point
19:03:27 <ivanm> erisco: ahhh
19:03:42 <ivanm> erisco: OK, use : when you're putting an element on the front of the list; ++ when you're joining two lists together
19:03:50 <pikhq> It makes a whole lot more sense to just make some Prelude sugar instead of adding more syntax.
19:03:53 <erisco> ivanm, yes, I remembered this, thanks :)
19:03:57 <Tsion> pikhq: It just seemed so, I never realized it wasn't.
19:04:05 <Tsion> pikhq: Yeah, it does make a lot more sense.
19:04:06 <pikhq> Ah.
19:04:20 <bgs100> What are lambdabot's commands? I've seen > and @ used
19:04:36 <ivanm> @list
19:04:36 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:04:40 <ivanm> bgs100: ^^
19:04:41 <Tsion>  > is shortcut for @run
19:04:45 <ivanm> that's all the @ commands
19:04:50 <ivanm> Tsion: :o didn't know that
19:04:50 <monochrom> Actually > is the exception. All other commands start with @
19:05:03 <bgs100> Oh, thanks
19:05:05 <Tsion> monochrom: there are also :t and :k
19:05:11 <Tsion> and maybe some others
19:05:14 <erisco> :t head
19:05:15 <lambdabot> forall a. [a] -> a
19:05:21 <erisco> yup, that works :)
19:05:34 <Tsion> :k []
19:05:36 <lambdabot> * -> *
19:05:39 <erisco> but ghci works fine for me...
19:05:51 <Tsion> ghci doesn't have @src :(
19:05:56 <erisco> true
19:06:03 <erisco> not that has been mentioned to me anyways
19:06:35 <ivanm> well, there's GoA
19:06:40 <ivanm> but IIRC that's dead
19:06:56 <Tsion> I think I tried to use that and it didn't work too well
19:07:01 <bgs100> @elite test
19:07:02 <lambdabot> +ez+
19:07:22 * Tsion just runs his own lambdabot so he can spam it all he wants ;)
19:07:31 <ivanm> @. elite yow
19:07:32 <lambdabot> t|-|e k0RE4n \/\/4R mus+ h4VE 8eeN FUN.
19:07:50 <monochrom> erisco: Convince me what step is supposed to do. Just step. Just one step.
19:08:07 <ivanm> convince or explain?
19:08:14 <monochrom> Perhaps w:p is supposed to be w++p.
19:08:15 <bgs100> @echo test
19:08:16 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "bgs100!n=ian@unaffiliated/bgs100", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo test"]} rest:"test"
19:08:38 <monochrom> convince is closer to program correctness than explain.
19:09:02 <erisco> monochrom, if the predicate returns true on x, it is supposed to add x to the p buffer. If the predicate returns false on x, it is supposed to append the p buffer on the w buffer and reset the p buffer as just containing x
19:09:15 <pikhq> It could be said that lambdabot is treating the channel as Literate Haskell.
19:09:23 <monochrom> Probably w++p will do.
19:09:42 <ivanm> pikhq: with extra @ pre-processor commands?
19:09:43 <monochrom> @let step ' ' (w,p) = (w, ' ':p); step x (w,p) = (w++p, x : [])
19:09:44 <lambdabot>  Defined.
19:09:47 <pikhq> ivanm: Right.
19:09:50 <erisco> monochrom, I do have w ++ p
19:10:07 <pikhq> And minus the TeX-y \begin and \end.
19:10:09 <erisco> monochrom, now anyhow. I will post my new error because it is again an infinite type problem and I am confused :)
19:10:12 <monochrom> OK this step now distinguishes spaces from non-spaces. We can test it.
19:10:27 <monochrom> @undefine step
19:10:43 <bgs100> *goes to mess with lambdabot via pm so as to not spam the channel*
19:10:45 <monochrom> @undefine
19:10:50 <monochrom> @help let
19:10:50 <lambdabot> let <x> = <e>. Add a binding
19:11:11 <erisco> this is my new standing: http://pastebin.ca/1489081
19:11:42 <ivanm> pikhq: well, I presumed you meant bird-style literate
19:11:43 <erisco> monochrom, from what I can see, the inferred type is indeed what I want but the expected type isn't
19:12:27 <monochrom> should whole:part be whole++part?
19:12:45 <erisco> monochrom, whole:part is not longer in the source
19:13:18 <monochrom> step (w,p) x  instead of  step x (w,p)
19:13:26 <monochrom> @type foldl
19:13:27 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:13:41 <monochrom> a=([Char],[Char]), b=Char, [b]=String
19:14:03 <monochrom> This is why you should learn types.
19:14:38 <erisco> monochrom, ah, you are right, they are supposed to be the other way around
19:14:57 <erisco> monochrom, the book does not teach all there is to know about type signatures as of chapter 4
19:15:07 <erisco> I know a bit but not too much
19:15:31 <Cale> Nice, I can implement list comprehensions as a function in mathematica :)
19:15:49 <monochrom> Does mathematica have unsafeInterleaveIO?
19:15:53 <Cale> no
19:16:39 <Cale> It's not even really lazily evaluated, but it has a way to ensure that the parameters to a function are not evaluated before it.
19:17:01 <erisco> monochrom, my function does not seem to do anything I want at all :(
19:17:21 <erisco> monochrom, but I'll try and fix that I guess :P
19:17:34 <monochrom> x:p suggests to me that some strings are reversed.
19:18:06 <Cale> SetAttributes[Comprehend, HoldAll]
19:18:06 <Cale> Comprehend[expr_] := {expr}
19:18:06 <Cale> Comprehend[expr_, {var_, l_}, rest___] := FlatMap[Function[var, Comprehend[expr, rest]], l]
19:18:06 <Cale> Comprehend[expr_, cond_, rest___] := If[cond, Comprehend[expr, rest], {}]
19:18:11 <erisco> monochrom, well, for example: splitWith (== " ") "hey how are ya"
19:18:17 <erisco> monochrom, just generates a type error
19:18:31 <erisco> monochrom, splitWith (>5) [1..10] does nothing
19:18:36 <monochrom> splitWith (== ' ') "hey how are ya"
19:19:03 <monochrom> The (>5) example is more interesting.
19:19:15 <Cale> (It's also possible to use a pretty left arrow or element of sign for the generators, but it doesn't paste so nicely into IRC)
19:19:26 <erisco> monochrom, ah, yes, supposed to use single quotes
19:19:34 <erisco> monochrom, it does something really weird and not what I want :P
19:19:42 <erisco> monochrom, I think I do not want w ++ p after all
19:19:52 <erisco> monochrom, what I get back is just a list, I need a list of lists
19:20:00 <erisco> monochrom, w is supposed to be a list of lists
19:20:27 <monochrom> splitWith (const True) "hey how are ya"  and  splitWith (const False) "hey how are ya"  should be the first examples you look at.
19:21:32 <monochrom> p:w or w++[p] will make w a list of lists.
19:21:56 <monochrom> w:p is the opposite, it makes p a list of lists. which is absurd in light of x:p.
19:22:43 <erisco> monochrom, yeah, I had already made the changes of concating [p] instead of p
19:23:14 <erisco> monochrom, and yes, after that change and writing a correct predicate (it is supposed to separate on failure, not success, whoops)
19:23:26 <erisco> monochrom, I do get the strings backwards :P
19:23:41 <monochrom> That's the doing of x:p
19:23:56 <monochrom> It makes me feel that foldl is not a suitable tool for this.
19:24:14 <monochrom> It can work but you have to p++[x] and that's slow.
19:24:40 <erisco> monochrom, with my limited knowledge of Haskell... yeah, probably doing the whole thing wrong
19:24:50 <erisco> it was just an idea that sprang to mind to solve the problem
19:24:54 <erisco> and it is failing
19:25:36 <monochrom> If p++[x] works then you're done. You can worry about a faster method later.
19:25:44 <erisco> monochrom, it does work, thanks
19:25:58 <monochrom> Neato.
19:26:58 <erisco> monochrom, although when doing: splitWith (const False) [1..2]
19:27:19 <erisco> monochrom, I get an extra empty list at the beginning and I am not entirely sure why
19:27:36 <monochrom> I don't know either.
19:28:28 <drhodes> :t splitWith
19:28:30 <lambdabot> Not in scope: `splitWith'
19:28:51 <monochrom> It's an exercise.
19:31:15 <erisco> monochrom, it would not be slow if I was using a doubly linked list. does Haskell provide them if I wish to use them in the future?
19:32:22 <monochrom> No. And it's more than that. An immutable doubly linked list will not help either.
19:34:26 <erisco> monochrom, wait, not a doubly linked list per se, I am thinking of a different term
19:35:49 <erisco> monochrom, I forget the fancy name for it, but you hold both the start and end node
19:35:54 <vinicius> zipper?
19:36:00 <copumpkin> Seq?
19:36:03 <aavogt> Data.Sequence?
19:36:03 <monochrom> dequeue
19:36:47 <erisco> monochrom, anyways, that data structure has O(1) append time while the default Haskell list has O(n)
19:37:02 <monochrom> dequeue or fifo may work
19:37:03 <Cale> erisco: Immutable doubly linked lists are kind of useless, because the same thing which makes them really efficient for mutable use makes them extremely ineffective with regard to sharing.
19:37:23 <Cale> (You have to copy the whole thing on every operation)
19:37:36 <mikezackles_> I'm having some trouble building lambdabot: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2959#a2959  I'm new, so I could be missing something simple.  Any ideas?
19:37:47 <Cale> erisco: If you want fast immutable sequences, you need some kind of tree structure, and Data.Sequence does it really well.
19:37:50 <erisco> Cale, I found out I was not referring to doubly linked lists, I meant something else
19:38:07 <Cale> It has log time concatenation and splitting and constant time access to both ends.
19:38:54 <Cale> mikezackles_: Oh, that's interesting, I wonder why base is hidden...
19:39:16 <Cale> mikezackles_: Check in the .cabal file for lambdabot that base is listed as a dependency.
19:39:36 <erisco> Sentinel nodes, that's it
19:39:47 <erisco> a list with sentinel nodes on both ends
19:39:56 <copumpkin> won't really help
19:40:06 <erisco> mind you, I do not think sentinel node refers to the fact you actually maintain the reference to them
19:40:15 <erisco> but that is what I mean, not just a dummy element
19:40:21 <mikezackles_> Cale: Yes, I see it under build-depends.
19:40:21 <Cale> I am not sure what a sentinel node is :)
19:40:30 * erisco sighs, my nomenclature skills are lacking
19:41:08 <ray> []s?
19:41:13 <erisco> Cale, it is a dummy node that ensures that every element has a following node
19:41:25 <erisco> Cale, or in doubly linked lists, ensures they they all have previous and next nodes
19:41:29 <copumpkin> [] ?
19:41:45 <ray> tangentially, i really love zippers
19:42:04 <erisco> Cale, but my point is that you would typically hang onto the references to the sentinel nodes and thus you have constant time access to the beginning and end of the list, be it doubly linked or not
19:42:23 <copumpkin> stick an IORef at the end
19:42:27 <copumpkin> ;)
19:42:38 <erisco> Cale, mind you, you will not gain O(1) append time without a doubly linked list, but, anyhow
19:42:43 <mikezackles_> What does it mean for the package to be "hidden".  Does that have something to do with ghc-pkg expose, or is that totally different?
19:42:45 <Cale> mikezackles_: :| I wonder if the package has just gone out of date. The system which lambdabot runs on was using 6.8.3 for a really long time.
19:43:03 <jeffwheeler> Is it possible to see any download statistics from Hackage? Or see what packages depend on another?
19:43:12 <mmorrow_> roconnor: re: gcc doing jmps instead of calls http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6707#a6707
19:43:21 <erisco> monochrom, well I will try and figure out that extra empty list problem
19:43:23 <Cale> mikezackles_: It's related, but when you're using cabal, it means that the package isn't listed as a dependency, usually.
19:43:25 <erisco> monochrom, thanks for your help
19:43:42 <roconnor> mmorrow_: Yes, but it still isn't TCO
19:44:00 <mmorrow_> roconnor: yes it is. it's doing a jmp instead of a call/ret
19:44:11 <roconnor> oh
19:44:15 <roconnor> sorry, I read ghc
19:44:19 <roconnor> then clicked on the link
19:44:23 <mmorrow_> (but only when the ret type is void..)
19:44:25 <roconnor> mmorrow_: that's cool
19:44:55 <monochrom> When I was learning imperative linked lists, sentinel nodes were great, I found them to induce elegant algorithms. Oh, recursion is another cause of elegance.
19:44:58 <Cale> erisco: hmm... that would be quite expensive for the benefit it would provide, since each list node would have an extra pointer just to point to the last element of the list...
19:45:20 <erisco> Cale, no, not quite like that
19:45:41 <erisco> Cale, each node would contain a reference to the node before and the node after it
19:45:51 <copumpkin> ... a mutable one
19:45:51 <erisco> Cale, you yourself hold the two sentinel nodes
19:45:54 <roconnor> DLists have O(1) append.  Is that relevent to this conversation?
19:45:59 <Cale> Oh, then that's going to screw up your complexity isn't it?
19:46:06 <Cale> You won't have O(1) cons anymore.
19:46:09 <mikezackles_> Cale: OK, I can accept that.  I don't really want to start trying to downgrade things, so I guess I'll just wait a little while and have another go :)
19:46:12 <monochrom> Then during a lab session I had to traverse a list of graphical shapes and draw them. I used recursion. I got a stack overflow because it was DOS, small stack and all.
19:46:30 <Cale> mikezackles_: Okay, I'll try to have a look at getting lambdabot to build on the new GHC in a little while.
19:46:34 <erisco> Cale, yes you would. One sentinel node is at the end, and you can access that node in O(1) time
19:47:02 <monochrom> (Then people in the other hemisphere invented haskell.)
19:47:05 <copumpkin> it works fine if it's mutable
19:47:20 <Cale> erisco: But when you cons a new element to a list, the first node of the tail has to be different, so it can't be shared, and then recursively, every node in the list has to change.
19:47:22 <erisco> Cale, and the end sentinel node contains a reference to the previous node, which is the last non-sentinel node, and you can then relink the node with the new node, and the new node with the sentinel node, to append
19:47:23 <mikezackles_> Cale: Thanks, no rush on my part.
19:47:43 <erisco> Cale, we are no longer using lists
19:47:50 <Cale> I know that...
19:47:59 <erisco> Cale, we are using doubly linked lists with start and end sentinel nodes :)
19:48:13 <Cale> erisco: Mutable ones?
19:48:26 <erisco> Cale, yes, which you could setup by making your own types really simply
19:49:08 <Cale> Er, okay, but not in Haskell, without some indirect method like using STRefs, IORefs, or a Data.IntMap.
19:49:08 <roconnor> Also possibly relevent: there is *no* known problem that can be solved in a strict language with mutation with lower asymtotic complexity than in a lazy language without mutation.
19:49:28 <Cale> roconnor: That is interesting.
19:49:51 <copumpkin> roconnor: I thought people generally said that you pay a roughly logarithmic complexity cost for immutability?
19:49:54 <Cale> roconnor: Can we prove that it's the case that no problem can exist?
19:49:56 <copumpkin> not that I have a citation either :)
19:50:06 <Cale> copumpkin: Right, I know how to prove that much.
19:50:11 <roconnor> Cale: there is not proof it doesn't exist either AFAIK
19:50:53 <Cale> I suppose it's equivalent to saying that there's an SSA algorithm?
19:50:56 <erisco> lack of proof that something is false is not proof that it is true, you know
19:51:02 <roconnor> copumpkin: that's what people say, but I'm not sure it is really true.  However I did sneak in the word asymtotic in my phrasing.  That could cause the difference
19:51:21 <roconnor> erisco: Oh yes.
19:51:39 <monochrom> You pay a log cost if you mimick the data structures rather than re-solve the real problem.
19:51:41 <copumpkin> erisco: he just said he didn't think a proof existed :P
19:51:43 <Cale> erisco: Right, but given the range of problems that we know about, it's interesting that so far the two have been equivalent.
19:51:43 <roconnor> erisco: I want to say that if you discover such an problem, then you can write a paper on the topic for publication.
19:51:46 <kulakowski> roconnor: What other measure of complexity would you be using?
19:52:04 <roconnor> kulakowski: oh oops
19:52:14 <roconnor> sorry everyone, I messed up the statement!
19:52:22 <roconnor> Also possibly relevent: there is *no* known problem that can be solved in a strict language with mutation with lower ammortized complexity than in a lazy language without mutation.
19:52:26 <roconnor> *ammortized*
19:52:28 <roconnor> my bad
19:52:29 <copumpkin> -m
19:52:29 <roconnor> really sorry
19:52:31 <Cale> Is there a proof that for every imperative algorithm, there's a static-single-assignment algorithm of the same complexity?
19:52:33 <copumpkin> :P
19:52:37 <monochrom> Oh ammortized! That's different!
19:52:42 <roconnor> ya
19:52:44 <erisco> roconnor, Cale, the lack of proof of falsehood is evidence of it being true. You cannot say that it is true when there is no proof for it
19:52:46 <roconnor> really really sorry
19:52:54 <Cale> erisco: Nobody did.
19:53:01 <erisco> but, I don't think its totally relevant :P
19:53:07 <erisco> because I am not talking about that
19:53:09 <FunctorSalad_> do you mean it is proved that no-mutation is just as good, or just that they can't prove no-mutation is worse?
19:53:11 <monochrom> But I'm glad enough that fifo is asymptotic O(1) too, not just amortized O(1).
19:53:18 <roconnor> FunctorSalad_: they can't prove.
19:53:21 <FunctorSalad_> (proving lower bounds is a hard business I hear)
19:53:23 <Cale> erisco: I'm a mathematician, I know what counts as a proof ;)
19:53:53 <monochrom> We are all mathematicians, we know what is proof and what is can't prove yet.
19:53:58 <roconnor> um, let me get the relevent link
19:54:25 <Cale> In any case, it's easy to show that every imperative algorithm has a corresponding purely functional one with at most an additional logarithmic performance factor in time and space.
19:54:29 <roconnor> http://r6.ca/blog/20040905T000700Z.html
19:54:34 <roconnor> and the really relevent link
19:54:55 <roconnor> ftp://ftp.comlab.ox.ac.uk/pub/Documents/techpapers/Geraint.Jones/FP-1-96.ps.Z
19:55:07 <roconnor> and another nice link: http://web.comlab.ox.ac.uk/people/Geraint.Jones/morehaste.html
19:55:17 <Cale> Right, I've seen that paper :)
19:55:31 <FunctorSalad_> Cale: what is the general approach there?
19:55:49 <FunctorSalad_> (risking LMGTFY because you said it's easy ;))
19:55:50 <Cale> FunctorSalad_: Use something like a Data.Map as your memory.
19:55:50 <erisco> Cale, but are you trying to say that I would not have O(1) append time?
19:56:07 <FunctorSalad_> ah, ok
19:56:09 <monochrom> Oh! Haha.
19:56:55 <erisco> monochrom, by the way, I know what that problem happens now
19:57:11 <erisco> monochrom, s/what/why/
19:57:21 <Cale> erisco: Well, it depends which operations you want to be fast. If you want fast access to anywhere in the middle, log is the best you can do, I think.
19:58:09 <Cale> erisco: If you only care about fast access to the beginning, but want constant concatenation, you can represent lists as functions which add elements to lists, and then concatenation becomes composition, which is constant time
19:58:12 <erisco> Cale, there are tactics for reaching the middle, yes, but I am purely looking for constant append time
19:58:15 <monochrom> I have to log in to use haskell wiki's sandbox??!!!
19:58:32 <Cale> That is, replace [a] with [a] -> [a]
19:58:59 <Cale> and replace (++) with (.)
19:59:14 <Cale> as an example of that, suppose we have:
19:59:28 <Cale> data Tree a = Leaf | Branch (Tree a) a (Tree a)
19:59:28 <monochrom> replace "hello" with ("hello" ++)
19:59:34 <Cale> right
19:59:47 <Cale> and we want an inorder traversal
19:59:58 <Cale> The naive thing to write would be:
20:00:04 <Cale> inorder Leaf = []
20:00:15 <Cale> inorder (Branch l x r) = inorder l ++ x ++ inorder r
20:00:41 <Cale> This is bad for left-leaning trees because xs ++ ys takes O(length xs) time in general
20:00:53 <Cale> So, we can instead write:
20:00:57 <Cale> inorder' Leaf = id
20:01:02 <erisco> monochrom, and it is expected behaviour, actually, so I guess I leave it
20:01:09 <Cale> inorder' (Branch l x r) = inorder l . (x:) . inorder r
20:01:12 <Cale> and then
20:01:18 <Cale> inorder t = inorder' t []
20:01:46 <Cale> and composition is constant time, so this gets us back down from quadratic to linear complexity
20:02:53 <Cale> That's the standard trick for fast concatenation, and it usually works well, but not if you have to peek at the lists you're constructing a whole lot as you go.
20:03:44 <Cale> It's even prettier if you have the treeFold, like
20:04:10 <Cale> treeFold l b = f where f Leaf = l; f (Branch l x r) = b (f l) x (f r)
20:04:14 <Cale> then
20:04:34 <Cale> inorder t = treeFold id (\l x r -> l . (x:) . r) t []
20:05:11 <Cale> rather than
20:05:24 <Cale> inorder t = treeFold [] (\l x r -> l ++ [x] ++ r) t []
20:05:27 <Cale> er
20:05:29 <Cale> inorder t = treeFold [] (\l x r -> l ++ [x] ++ r) t
20:07:03 <Cale> If you need fast access to both ends of a list, there are tricks you can play by separating the list into two parts, and storing the second half of the list as a list in reverse order.
20:07:39 <Cale> It's reasonably straightforward to construct an amortised constant time access queue that way.
20:08:08 <Cale> (without any mutation of any kind :)
20:09:45 <erisco> Cale, well, I will type up what I was imagining
20:10:20 <erisco> Cale, I am far off from tricks in Haskell, but I think I know enough about how to make types to create a doubly linked list
20:10:47 <Cale> erisco: The trick is creating a doubly linked list which isn't horrifyingly slow or unsafe.
20:11:04 <Cale> (when you do anything to extend it with additional elements)
20:11:12 <erisco> Cale, yeah, that bit I am working on :P
20:11:45 <Cale> The reason that (:) is a constant time operation in Haskell is that the tail of the list can be shared, and doesn't have to be aware that the first element was added to it.
20:13:17 <Cale> http://hackage.haskell.org/packages/archive/dequeue/0.1.2/doc/html/Data-Dequeue.html#t%3ABankersDequeue
20:13:51 <erisco> Cale, yeah, that is probably the same structure I am building
20:14:09 <Cale> data BankersDequeue a = BankersDequeue Int [a] Int [a]
20:15:12 <Cale> It stores two lists along with their lengths, the first being the front and the second being the back, kept in reverse order
20:17:02 <erisco> Cale, no that is not how I have mine structured
20:17:05 <bgs100> Okay.. haskell's ranges are cool... Doing number ranges is easy enough (for instance, in python, with the range function), but character ranges (['a'..'z']) seems very cool
20:17:11 <Cale> and it uses a function  check :: BankersDequeue a -> BankersDequeue a  whenever you push elements onto it, which examines the sizes of the lists and judges whether or not it's time to balance the two parts.
20:17:18 <erisco> Cale, then again I am a really bad functional programmer at this point :P
20:18:57 <coCocoa> erisco: Now, now. You can be a bad programmer, or a functional one, but you can't be both bad AND functional... ;p
20:19:26 <erisco> coCocoa, oh that's a little biased isn't it? :P
20:19:28 <Cale> erisco: It's actually not *great* in that while the push and pop operations are O(1) amortised, they can take linear time in the worst case for any single one.
20:20:17 <erisco> Cale, I think my imperative mind is leaking in again... after I create a type, I cannot mutate it can Iiiiiiii
20:20:22 <Cale> (it's just that you're guaranteed to only have to do that linear-time balancing after a linear number of operations)
20:20:25 <erisco> sorry, that is my keyboard acting up
20:20:43 <Cale> erisco: Once you create a value, it cannot be modified. It just is.
20:21:02 <erisco> Cale, yeah, okay, how I wanted to build this structure completely fails then
20:21:18 <erisco> Cale, considering it relies on changing the links in each node
20:21:38 <erisco> Cale, which would result in reconstruction of the whole list if anything had to be done to it =\
20:21:46 <Cale> The tail of a list is really a list, and not a cell containing a reference to a list, even if that's how it's represented by the compiler.
20:22:12 <erisco> Cale, I know, I am trying to really make it that though
20:22:17 <Cale> right
20:22:43 <erisco> see, in an imperative language I could rig up a doubly linked list easily and be on my way
20:22:51 <erisco> where am I in this functional world?
20:23:14 <Cale> Here, you would probably use one of the fast sequence libraries which someone conveniently put all the work into already :)
20:23:51 <erisco> dequeue is interesting but storing the list frontwards and backwards is crazy
20:23:58 <Cale> Even if you take a log-time hit for some operations, that's usually ignorable, since your sequences are only ever going to be as large as the memory you can purchase.
20:24:46 <Cale> (so that log factor can be treated as a reasonably small constant factor)
20:25:08 <Cale> Incidentally, we do this all the time with hardware memory already.
20:25:53 <wli> Well, you can do a bit better.
20:25:58 <Cale> (If you have the unbounded amount of memory you'll need for asymptotic analysis, just reading your pointers takes log(n) time.)
20:26:33 <wli> Operation counts are f(m,n,k) + O(g(m,n)) or some such and you're doing better.
20:27:15 <Cale> erisco: Generally, if I need a reasonably fast queue in Haskell, I'll just use Data.Sequence
20:27:35 <Cale> Access to both ends of a Data.Sequence is O(1) time
20:27:50 <bgs100> >take 12 (cycle "test")
20:27:59 <Cale> > take 12 (cycle "test")
20:28:00 <lambdabot>   "testtesttest"
20:28:10 <Cale> (the space is important)
20:28:17 <erisco> > cycle "foo"
20:28:19 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
20:28:26 <bgs100> >take 12 (cycle "test ")
20:28:37 <Cale> bgs100: You need a space after >
20:28:40 <erisco> cycle is an infinite list then?
20:28:42 <bgs100> Oh
20:28:44 <bgs100> Whoops
20:28:45 <Cale> erisco: yeah
20:28:52 <bgs100> Thanks Cale
20:28:56 <bgs100> > take 12 (cycle "test ")
20:28:57 <lambdabot>   "test test te"
20:29:02 <bgs100> > take 14 (cycle "test ")
20:29:04 <lambdabot>   "test test test"
20:29:19 <erisco> take 5 (cycle [1])
20:29:29 <erisco> > take 5 (cycle [1])
20:29:30 <lambdabot>   [1,1,1,1,1]
20:29:31 <roconnor> > replicate 5 1
20:29:32 <lambdabot>   [1,1,1,1,1]
20:29:37 <Cale> and, this is an operational semantics thing, but cycle xs will only take about the memory that xs does
20:29:42 <erisco> now who's output is which? :)
20:29:56 <jeffwheeler> > intercalate " " $ replicate 3 "test"
20:29:57 <lambdabot>   "test test test"
20:30:07 <bgs100> erisco, Lol
20:30:13 <roconnor> erisco: reminds me of "which electron is which"
20:30:31 <dankna> the one over there is the one over there.
20:30:43 <bgs100> > [ x | x <- [50..100], x `mod` 7 == 3]
20:30:44 <lambdabot>   [52,59,66,73,80,87,94]
20:31:10 <Cale> One of the really nice but simple things which we can do because of infinite lists is to allow things like map to work with the indices of elements simply by zipping with the infinite list [0..] first.
20:31:18 <bgs100> (I'm testing some code from http://learnyouahaskell.com/, which looks pretty cool :))
20:31:41 <Cale> > map (\(k,x) -> replicate k x) (zip [1..] "hello")
20:31:42 <lambdabot>   ["h","ee","lll","llll","ooooo"]
20:31:56 <bgs100> :o
20:32:21 <Cale> > concatMap (\(k,x) -> replicate k x) (zip [1..] "hello")
20:32:21 <bgs100> > zip [1..] "hello"
20:32:22 <erisco> Cale, something tells me this is not quite what you wanted to do
20:32:22 <lambdabot>   "heelllllllooooo"
20:32:23 <lambdabot>   [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
20:32:35 <Cale> > zip [0..] "hello"
20:32:37 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
20:32:49 <Cale> > filter (even . fst) . zip [0..] $ "hello"
20:32:50 <lambdabot>   [(0,'h'),(2,'l'),(4,'o')]
20:32:54 <Cale> > map snd . filter (even . fst) . zip [0..] $ "hello"
20:32:55 <lambdabot>   "hlo"
20:33:28 <erisco> that is a very convoluted way to get every other element Cale
20:33:45 <Cale> Well, you might prefer the list comprehension
20:34:00 <Cale> > [x | (k,x) <- zip [0..] "hello", even k]
20:34:00 <jeffwheeler> erisco: What would be even more convoluted? Recursive definitions of even and odd.
20:34:01 <lambdabot>   "hlo"
20:34:40 <jeffwheeler> > let even 0 = True; even 1 = False; even n = not (even $ n-1) in even 6
20:34:41 <lambdabot>   True
20:34:45 <erisco> this is an O(2n) operation when only O(n) is needed, no?
20:34:45 <jeffwheeler> > let even 0 = True; even 1 = False; even n = not (even $ n-1) in even 5
20:34:47 <lambdabot>   False
20:34:50 <Cale> > let evens [] = []; evens (x:xs) = x : odds xs; odds [] = []; odds (x:xs) = evens xs in evens [0..]
20:34:52 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
20:34:54 <xmonader> i want some review on that code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6709#a6709 specially a better way for isolating non pure code ?
20:34:59 <Cale> erisco: hm?
20:35:26 <erisco> Cale, the zip transverses "hello" once, then the filter transverses it again, thus O(2n)
20:35:31 <erisco> Cale, we can do this in O(n)
20:35:40 <Cale> erisco: They happen in one pass, because of laziness.
20:35:47 <jeffwheeler> > let even 0 = True; even 1 = False; even n = not (even $ n-1) in map snd . filter (even . fst) . zip [0..] $ "Hello, world!"
20:35:48 <lambdabot>   "Hlo ol!"
20:35:54 <erisco> Cale, this laziness thing I will never understand easily :P
20:36:09 <Cale> erisco: I'll do some evaluation by hand to show the steps, one moment :)
20:36:34 <bgs100> > [if even k then x else '' | (k, x) <- zip [0..] "hello"]
20:36:36 <lambdabot>   <no location info>:
20:36:36 <lambdabot>      lexical error in string/character literal at chara...
20:36:48 <erisco> Cale, I would have been using say a fold to do this
20:36:57 <bgs100> > [if even k then x else '-' | (k, x) <- zip [0..] "hello"]
20:36:59 <lambdabot>   "h-l-o"
20:37:03 <bgs100> :o
20:37:11 <erisco> Cale, but I guess I am not thinking lazy functional =\
20:37:20 * coCocoa eagerly awaits erisco's first gander at Okasaki's BFS code...
20:37:58 <bgs100> Cale, I heard you have to have an else. Is there a way to return a empty character or something?
20:38:17 <coCocoa> ...or is it BFT(raversal)?
20:38:30 <erisco> coCocoa, I do not know Okasaki, or the definition of BFS, so you might not want to get your hopes up
20:38:43 <maurer> Is there a library that has a word dictionary for haskell?
20:39:02 <maurer> i.e. an easily accessible (not IO) version of /usr/share/dict/words ?
20:39:37 <dankna> you could write one fairly easily
20:39:43 <roconnor> xmonader: that code isn't too bad.
20:40:15 <kulakowski> tab fail
20:40:29 <roconnor> xmonader: to do better you'd need to use the sophisticated lazyIO package that I have never used.
20:40:32 <bgs100> Cale, oh, nevermind, just read the part about predicates :P
20:40:35 <Rotaerk> hmm well I came up with my initial draft of that splitWith function
20:40:40 <xmonader> roconnor, really? i thought running actions everywhere takes the *purity* out of haskell
20:40:41 <Rotaerk> it works but it's .. clunky
20:40:49 <coCocoa> erisco: Yes, that's why I'm eagerly awaiting your first gander at it. It's very logical, and rather mind-blowing. (Think: assume your function comes up with part of your answer, and you use that part to get the whole answer - in one pass!)
20:41:12 <erisco> Rotaerk, with monochrom's help I finished the solution using a left fold (introduced in chapter 4)
20:41:13 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6710#a6710
20:41:18 <Cale> erisco: ^^
20:41:20 <roconnor> xmonader: well, naively I would traverse all the directories first into a tree structure, then format the tree structure into a string (or string structure) and print the string.
20:41:22 <erisco> Rotaerk, but because of all the appends it is really slow...
20:41:37 <bgs100> snd? filter?
20:41:38 <Cale> erisco: That shows the order in which it computes the result.
20:41:49 <Cale> bgs100: snd (x,y) = y
20:41:55 <Rotaerk> erisco, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6711#a6711 is what I came up with
20:41:56 <roconnor> xmonader: however, your code starts outputing before the entire directory is traversed, which is a good thing that my naive approach doesn't do
20:42:02 <bgs100> Cale, ah
20:42:04 <maurer> danka: Yes, I was just wondering if there was already one. atm I'm just using dicts turned into a compiled gynormous constant list
20:42:04 <bgs100> ok
20:42:10 <bgs100> > snd(1, 2)
20:42:10 <Cale> bgs100: filter p [] = []; filter p (x:xs) = if p x then x : filter p xs else filter p xs
20:42:11 <lambdabot>   2
20:42:20 <bgs100> > snd 1 2
20:42:21 <lambdabot>   Add a type signature
20:42:29 <Cale> filter picks the elements of a list for which a predicate is true
20:42:31 <Rotaerk> erisco, I'm trying to figure out how I can better factor that
20:42:44 <bgs100> > snd (1, 2, 3)
20:42:44 <roconnor> xmonader: the spiffy new lazyIO package would allow you to write code like my naive / nice pure way, and still have the online behaviour that your code has.
20:42:45 <lambdabot>   Couldn't match expected type `(a, b)'
20:42:49 <Cale> > filter (`elem` "aeiou") "what are the vowels in this?"
20:42:51 <lambdabot>   "aaeeoeii"
20:43:01 <bgs100> :o
20:43:09 <erisco> Rotaerk, okay, your function does something different than mine
20:43:16 <xmonader> roconnor, merci :$ another thing.. i want to join lines 26 and 29 instead of defining the value of newindent ?
20:43:28 <xmonader> roconnor, i'll check on it
20:43:36 <bgs100> > 1 : [2, 3]
20:43:38 <lambdabot>   [1,2,3]
20:43:40 <Rotaerk> erisco, splitWith odd [5,7,8,9,10,2,8,7,6,8,5,899,9,86,5,76986,58,87]
20:43:45 <erisco> Rotaerk, I presumed that we did not want to drop the separators, instead putting them into the next part
20:43:58 <wli> Is there a faster data structure to use than a giant list?
20:43:58 <Rotaerk> erisco, produces: [[5,7],[9],[7],[5,899,9],[5],[87]]
20:44:01 <Cale> erisco: Lazy evaluation works by always expanding the definition of the *outermost* function which can successfully pattern match.
20:44:03 <roconnor> xmonader: I don't understand your join question
20:44:13 <Rotaerk> erisco, ah
20:44:34 <Cale> erisco: So if you have f (g x) then f is applied first, and g x is substituted into the body.
20:44:43 <erisco> Rotaerk, on splitWith odd [1..10] yours produces [[1],[3],[5],[7],[9],[10]] and mine produces [[1],[2,3],[4,5],[6,7],[8,9],[10]]
20:44:49 <Rotaerk> I see
20:45:04 <xmonader> roconnor, instead of     let newindent=indent+1 <newline>    treePath (combine parent dir) newindent
20:45:17 <xmonader> i want to do something like  treePath (combine parent dir) indent + 1?
20:45:18 <Cale> (actually, there's a little wibble which I'm not mentioning in this -- if the parameter to f occurs more than once in its body, then any evaluation of it gets shared between the copies)
20:46:19 <roconnor> xmonader: well, you use the variable twice.  You could put (indent + 1) in both places if you'd like.  It might be epsilon less efficient, and I'm not sure it would be more clear.
20:46:38 <erisco> Rotaerk, one thing you might want to notice is that your function incorrectly returns 10 ;)
20:46:57 <roconnor> xmonader: actually there is a change I would make
20:47:10 <xmonader> roconnor, hmmm ?
20:47:30 <Rotaerk> erisco, huh, didn't see that
20:47:31 <Rotaerk> hmm
20:47:37 <Cale> erisco: do the steps in that evaluation trace make sense?
20:47:49 <Cale> erisco: (particularly the order in which they occur is the important bit)
20:47:55 <roconnor> xmonader: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6709#a6713
20:47:57 <roconnor> very slight
20:48:08 <roconnor> put the +1 in visitPath
20:48:08 <erisco> Cale, I will take a look in a second, thank's for writing it out for me
20:48:14 <Cale> Basically, the outermost function which can succeed in its pattern matching will get applied first.
20:48:20 <bgs100> > let nouns = ['pie', 'cereal', 'cheese']; let adjectives = ['yummy', 'bad', 'moldy']; [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
20:48:21 <lambdabot>   <no location info>:
20:48:21 <lambdabot>      lexical error in string/character literal at chara...
20:48:27 <bgs100> Oops
20:48:34 <bgs100> Wrong quote :P
20:48:39 <maurer> New, related question--is there any way to put a large amount of static data into the program? (The wordlist is very sad, and it's static data so an array would be nicer, but the array code would need to run on startup which would be sad. I could try using the binary module to dump and reload it, but :(
20:48:51 <Rotaerk> oh I see why
20:49:14 <bgs100> > let nouns = ["pie", "cereal", "cheese"]; let adjectives = ["yummy", "bad", "moldy"]; [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
20:49:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:49:19 <Cale> maurer: Is there a particularly good reason not to just load it from a file?
20:49:34 <maurer> Cale: I would prefer to load it from a file, but then I'm going to be met with the same slowness
20:50:00 <mmorrow_> mauke: the only two ways (unfortunately) are to either put it in an Addr# literal (==> "asdf"# :: Addr#), or put in in foo.c as char dat[] = {...}, and foreign import ccall unsafe "dat" dat :: Ptr Word
20:50:12 <erisco> Rotaerk, both of our functions suffer from stack overflows given large lists
20:50:16 <Cale> maurer: I suppose you could try to use Template Haskell to parse the file at compile time and construct a large literal constant. I'm not sure how well that works, I've never tried it.
20:50:27 <roconnor> xmonader: actually, lets keep moving that +1 upwards
20:50:39 <Rotaerk> erisco, I think tail recursion isn't automatic
20:50:41 <maurer> Cale: I was mostly hoping for a literal constant with array-like access
20:50:49 <Rotaerk> or maybe it is..
20:50:52 <mmorrow_> Cale: that only gets you to the same place you'd be if you wrote the file out by hand and then passed it to ghc :(
20:50:55 <Rotaerk> inside a fold..
20:51:07 <xmonader> roconnor, i think that's better instead of repeating ourselves :)
20:51:09 <erisco> Rotaerk, the compiler detects it, neither of our functions are compatible for it
20:51:14 <Cale> Oh, I suppose so.
20:51:17 <Rotaerk> I see
20:51:21 <roconnor> xmonader: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6709#a6714
20:51:28 <bgs100> Night all
20:52:00 <erisco> Rotaerk, for just dropping values, I imagine the source of words is helpful
20:52:02 <coCocoa> maurer: Maybe instead of worrying about the file, you should worry about where the "slow" part is...? :)
20:52:04 <erisco> @src words
20:52:04 <lambdabot> words s = case dropWhile isSpace s of
20:52:05 <lambdabot>     "" -> []
20:52:05 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
20:52:11 <roconnor> xmonader: that feels good.  usually parameters are modified before calling functions rather than being modified at the begining of a function.
20:52:12 <xmonader> roconnor, i think lines 27, 28 have only indent in scope not newindent
20:52:14 <Cale> Tail recursion is sort of irrelevant in lazy evaluation.
20:52:32 <mmorrow_> mauke: you can do the C import or the Addr# literal way, and then use one of the O(1) ByteString creation functions, and then finally use unsafeIndex :: ByteString -> Int -> Word8 on it
20:52:42 <maurer> Right now I've got something similar to what you describe working with list access, but that is very sad for a l ntof constant data
20:52:42 <maurer> If I cd be lal my ipla
20:52:45 <Cale> Well, that is, TCO doesn't mean anything in the context of lazy evaluation.
20:52:53 <Rotaerk> erisco, .. oh wow
20:52:56 <Rotaerk> heh
20:53:01 <roconnor> xmonader: ah, right.  I forgot to rename those
20:53:04 <Cale> But tail recursion is still a useful concept, sorry :)
20:53:11 <erisco> Rotaerk, I think dropWhile is introduced in Chapter 4
20:53:14 <Rotaerk> guess mine reinvents a bit of functionality
20:53:19 <Rotaerk> yep
20:53:25 <maurer> Sorry for the garbage, machine locked up due to compiling said ridiculous file.
20:53:32 <mmorrow_> hah
20:53:38 <maurer> (had to increase ghc's stack size)
20:53:50 <Cale> Most tail recursive functions will perform poorly without optimisations in the compiler being turned on, and even then you may want to strictify any accumulating parameters to be safe.
20:54:03 <maurer> maurer@heaven:~/Sources/Cipher$ ghc -c Dictionary.hs +RTS -K4G
20:54:03 <maurer> Killed
20:54:03 <maurer> maurer@heaven:~/Sources/Cipher$
20:54:06 <maurer> It self killed :(
20:54:06 <Cale> This is because they give their parameters no chance to evaluate, so large expressions can build up.
20:54:13 <Cale> Consider something like:
20:54:19 <mmorrow_> mauke: (truly, those two ways are the only reasonable ways to do it if you'll need to be compiling this more than once (ever))
20:54:25 <Cale> length n [] = n
20:54:33 <Cale> length n (x:xs) = length (1+n) xs
20:54:47 <Cale> length (1:2:3:[])
20:54:51 <Cale> er
20:54:53 <Cale> length 0 (1:2:3:[])
20:55:02 <Cale> = length (1+0) (2:3:[])
20:55:07 <Cale> = length (1+(1+0)) (3:[])
20:55:14 <Cale> = length (1+(1+(1+0))) []
20:55:18 <Cale> = 1+(1+(1+0))
20:55:18 <xmonader> roconnor, i was thinking about adding a few arms, leader,.. etc but nah that's is super ok  http://blog.moertel.com/articles/2007/03/07/directory-tree-printing-in-haskell-part-two-refactoring
20:55:36 <Cale> this is the part where you will get a stack overflow if the list was very long
20:55:54 <Cale> The stack is used to search for a reducible subexpression of the expression being evaluated.
20:56:02 <maurer> Well, evidently ghc becomes very sad at some point in compilation when building a multimeg list, even with gigs of stack. I suppose C import may be the way to go here.
20:56:20 <roconnor> xmonader: I think that is my naive version that reads the entire directory before printing anything.
20:56:36 <maurer> Actually, would using Data.Binary to serialize the dictionary array on a first program run, and later just load the binary be a reasonable thing to do?
20:56:58 <Cale> 1+... will be pushed on the stack, giving 1+(1+0) to be evaluated, and then 1+... will get pushed on the stack, giving 1+0, which can evaluate to 1, and then 1+... gets popped and we evaluate 1+1 = 2, and then 1+... gets popped and we evaluate 1+2 = 3
20:57:10 <xmonader> roconnor, is that your blog?
20:57:15 <erisco> Cale, yeah, okay, I guess that made sense
20:57:30 <roconnor> xmonader: nope.
20:57:51 <Cale> So, because it constructs an expression which is very large and no part of which can be evaluated until the innermost bits are, this tail-recursive length gives a stack overflow
20:57:58 <roconnor> xmonader: by "my naive" I mean the one I was describing before.  The "purely funcitonal way" that you thought your code ought to be.
20:58:12 <coCocoa> mmorrow: Psst! You might want to give that tab-completion an extra press, otherwise I think mauke is gonna wonder what you're smoking... ;)
20:58:22 <Cale> If we want to improve it, we can force the parameter to length to be evaluated before recursing either using seq, which is a primitive, or bang-patterns which is a syntax extension
20:58:41 <Cale> length !n (x:xs) = length (1+n) xs
20:58:43 <Cale> or
20:58:52 <Cale> length n (x:xs) = n `seq` length (1+n) xs
20:58:54 <xmonader> roconnor, yup i got that
20:59:02 <adu> Cale: what about fusion?
20:59:05 * erisco is giving up for tonight... Haskell has him trumped
20:59:11 <xmonader> now i need to work on some summer project and i'm thinking of using haskell these days
20:59:23 <Cale> adu: fusion?
20:59:26 <roconnor> xmonader: I think your way is better, and in principle using the lazyio package would be better still.
20:59:36 <Cale> adu: I suppose this is a bit of a separate issue.
20:59:44 <adu> ok
20:59:53 <Cale> It stems from the fact that Integers must either be fully evaluated or not-evaluated-at-all
21:00:20 <Cale> So there's no way for 1+x to do anything without knowing x completely
21:01:09 <Cale> Oh, the thing I was doing earlier with the composite of map, filter, and zip would be improved by fusion
21:01:23 <Cale> But that's just a constant factor/allocation thing.
21:01:23 <erisco> learning Haskell makes you feel like you do not know how to program at all... the normal mindset just is not applicable!
21:01:26 * erisco cries
21:01:49 <Cale> erisco: Yeah, it's best to get into a mindset of not expecting to know what you are doing first.
21:02:15 <Cale> erisco: Thinking that you know what you are doing because you know an imperative language is probably harmful ;)
21:02:54 <erisco> I cannot complete the majority of the exercise questions that I could complete in a couple minutes using an imperative language
21:02:59 <erisco> and that is frustrating :P
21:03:22 <Cale> The first super-important goal, I would say, is getting *really* comfortable with the higher-order list functions.
21:03:49 <roconnor> @botsnack
21:03:49 <lunabot>  :)
21:03:49 <lambdabot> :)
21:03:51 <Cale> Lists in Haskell are not really lists, they are loops which haven't happened yet.
21:03:56 <erisco> because then as I try to think of how to solve it, I have this nagging knowledge of how I'd do it so easily imperatively and it ruins my concentration on functional
21:03:58 <coCocoa> erisco: Welcome to real learning! Now, you can't "cheat" by just doing what you've always done, and get the same thing; now, you have to Do Something Different. :)
21:04:19 <Cale> (if you want an imperative analogue)
21:04:51 <Cale> applying higher-order functions to a list is comparable to adding things inside of a loop
21:05:03 <erisco> coCocoa, I was hoping real learning would not have burdens of prior knowledge... but this isn't the first time so I should know better :P
21:05:58 * coCocoa is firmly convinced that people find imperative language learning "easy" because they don't actually treat the new language as a new language, but as the same old language they already know, just with some "odd corner cases" of difference.
21:06:14 <erisco> Cale, lists are loops that haven't happened yet... to someone who normally does imperative this would sound like some wacko science fictiony conspiracy-like concept :P
21:07:25 <Cale> Just like a list is either empty, or consists of a first element followed by another list, a loop either does nothing or has a first iteration followed by another loop.
21:07:39 <erisco> coCocoa, okay, but give imperative credit on some things... my example being variable arguments
21:07:52 <erisco> coCocoa, but I read this was being resolved in "type families" or something?
21:08:20 <Cale> Variable arguments is really a dynamically typed thing more than it is a functional/imperative thing
21:08:50 <Cale> Though we can assign meaningful types to such things using typeclasses.
21:08:51 <erisco> it makes functions like zip3 to zip7 look like a weakness
21:09:07 <Cale> Yeah, that's more to do with the inflexibility of larger tuples
21:09:20 <Cale> Pairs and triples are *completely separate* types.
21:09:39 <Cale> If they were at least related in some way, then we could use a typeclass to write the various zips.
21:09:42 <erisco> yes, so I have read, because they have a different type signature
21:09:52 <roconnor> you don't need zip3, just use (,,) <$> ziplist1 <*> ziplist2 <*> ziplist3
21:10:08 <Cale> But in practice, it's not a big deal anyway, since anything larger than a pair or maybe the occasional triple is usually replaced by a proper datatype.
21:10:37 <Cale> and you can always nest zips
21:10:50 <Cale> > zip [0..] (zip ['a'..'z'] "hello")
21:10:52 <lambdabot>   [(0,('a','h')),(1,('b','e')),(2,('c','l')),(3,('d','l')),(4,('e','o'))]
21:11:22 <Cale> (but you get nested pairs, rather than triples)
21:11:35 <mmorrow_> maurer: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6715
21:11:37 <jeffwheeler> > zip [0..] . zip ['a'..] $ "hello"
21:11:39 <lambdabot>   [(0,('a','h')),(1,('b','e')),(2,('c','l')),(3,('d','l')),(4,('e','o'))]
21:12:02 <jeffwheeler> > map (\(x, (y, z) -> (x, y, z)) . zip [0..] . zip ['a'..] $ "hello"
21:12:03 <lambdabot>   <no location info>: parse error on input `.'
21:12:12 <jeffwheeler> > map (\(x, (y, z)) -> (x, y, z)) . zip [0..] . zip ['a'..] $ "hello"
21:12:13 <lambdabot>   [(0,'a','h'),(1,'b','e'),(2,'c','l'),(3,'d','l'),(4,'e','o')]
21:12:36 <Cale> > [(x,y,z) | x <- [0..] | y <- ['a'..] | z <- "hello"]
21:12:37 <lambdabot>   [(0,'a','h'),(1,'b','e'),(2,'c','l'),(3,'d','l'),(4,'e','o')]
21:12:42 <jeffwheeler> > map (\(x, (y, z)) -> (x, y, z)) . map (\(x, (y, z)) -> (x, y, z)) . zip ['a'..] . zip [0..] . zip ['a'..] $ "hello"
21:12:44 <lambdabot>   Couldn't match expected type `(t, (t1, t2))'
21:12:56 <erisco> how would roconnor's example work?
21:13:03 <mmorrow_> mauke: errr, just realized i was directing the last 10 or so comment at you ... :)
21:13:25 <Cale> erisco: Oh, there's a special wrapper and an instance of Applicative which does zipping automatically...
21:13:40 <Cale> erisco: It's not very convenient usually...
21:13:49 <jeffwheeler> @type ziplist1
21:13:51 <lambdabot> Not in scope: `ziplist1'
21:14:01 <Cale> > (,,) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
21:14:02 <lambdabot>   No instance for (GHC.Show.Show
21:14:02 <lambdabot>                     (Control.Applicative.Zip...
21:14:04 <maurer> mmorrow_: Thanks. I'll try that with some modifications to handle strings.
21:14:09 <roconnor> @src ZipList
21:14:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:14:16 <jeffwheeler> @type ZipList
21:14:17 <Cale> > getZipList $ (,,) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
21:14:17 <erisco> Cale, okay, and I know nothing of a wrapper or Applicative or an instance (in functional languages) is... so I'll leave that alone :P
21:14:18 <lambdabot> forall a. [a] -> ZipList a
21:14:18 <lambdabot>   Overlapping instances for GHC.Show.Show (c -> (a, a1, c))
21:14:18 <lambdabot>    arising from a...
21:14:26 <Cale> er
21:14:40 <adu> :t flip (<$>)
21:14:41 <Cale> > getZipList $ (,,) <$> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList "abc"
21:14:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
21:14:42 <lambdabot>   [(1,4,'a'),(2,5,'b'),(3,6,'c')]
21:14:57 <ivanm> what would be the best way of defining the attributes listed here so that I can specify that they're only valid for a node, etc.? (so far they're all just defined in the same datatype) http://graphviz.org/doc/info/attrs.html
21:15:46 <Cale> erisco: Well, a wrapper type is simple. It's just a datatype which we wrap a single value of another type in, so that it's marked for processing in some way
21:16:07 <Cale> erisco: In this case, it helps us pick the instance of Applicative we want to use
21:16:29 <Cale> erisco: Applicative itself is a typeclass which has some generic operations that various datatypes/libraries can define
21:16:39 <Cale> and some handy functions defined in terms of those
21:16:50 <wmealing_> juhp, hi
21:17:02 <wmealing_> another hatter.
21:17:08 <Cale> (so that you can use those operations and polymorphic functions in various different libraries)
21:17:23 <erisco> Cale, oh, I think I remember reading a bit about that, and the fact being while we can avoid zip(n), we have to wrap each zip list in a datatype
21:17:29 <erisco> Cale, which is a convenience thing
21:17:30 <Cale> erisco: yeah
21:17:50 <Cale> erisco: Well, we wouldn't have to, except that there's actually a more important instance of Applicative for lists
21:17:59 <Cale> which does all combinations instead of pairing things up
21:18:17 <Cale> > (,,) <$> [1,2,3] <*> [4,5,6] <*> "abc"
21:18:18 <lambdabot>   [(1,4,'a'),(1,4,'b'),(1,4,'c'),(1,5,'a'),(1,5,'b'),(1,5,'c'),(1,6,'a'),(1,6...
21:18:28 <erisco> Cale, and one for permutations as well surely?
21:18:49 <Cale> hmm... I'm not sure what permutations would mean in this case.
21:19:04 <juhp> wmealing_: what you doing here? ;-P
21:19:09 <Cale> (since we're picking from separate lists, rather than one list over and over)
21:19:14 <kulakowski> I don't think he was using `combination' in the sense of a binomial coefficient.
21:19:19 <erisco> Cale, it would be 3^3 possibilities
21:20:02 <erisco> I might have that wrong
21:20:05 <wmealing_> juhp, ive done a bit of haskell, i'm beginning to think _you_ stalk me !
21:20:19 <Cale> erisco: yeah, that's what this instance does
21:20:28 <Cale> > length ((,,) <$> [1,2,3] <*> [4,5,6] <*> "abc") == 3^3
21:20:29 <lambdabot>   True
21:20:30 <juhp> wmealing_: cool didn't know - lol :)
21:20:35 <wmealing_> heh
21:20:42 <juhp> wmealing_: the fedora haskell sig is waiting for you :)
21:20:48 <wmealing_> i didnt know there was one :)
21:20:50 <erisco> Cale, point being that all permutations of (1,4,'a') would be included
21:21:00 <juhp> wmealing_: #fedora-haskell :)
21:21:01 <Cale> ah, that wouldn't be well-typed
21:21:13 <erisco> Cale, oh, true...
21:21:15 <Cale> because (1,'a',4) isn't the same type as (1,4,'a')
21:22:00 <Cale> You can however use the list monad (which is related to this applicative thing) along with a separate permutations function
21:22:11 <monochrom> hahahahah I have great MonadFix fu!
21:22:12 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
21:22:13 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
21:22:18 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]] >>= permutations
21:22:19 <lambdabot>   [[1,4,6],[4,1,6],[6,4,1],[4,6,1],[6,1,4],[1,6,4],[1,4,7],[4,1,7],[7,4,1],[4...
21:22:48 <Cale> which is effectively the same as
21:23:04 <Cale> > concat (map permutations (sequence [[1,2,3],[4,5],[6,7,8]]))
21:23:05 <lambdabot>   [[1,4,6],[4,1,6],[6,4,1],[4,6,1],[6,1,4],[1,6,4],[1,4,7],[4,1,7],[7,4,1],[4...
21:23:12 <Cale> because that's just what >>= does in the list monad
21:23:31 <erisco> Cale, cannot wait to get to monads I am sure
21:24:36 <Cale> Basically, the importance of recognising that certain types/libraries are monads is that you get a whole bunch of functions (see Control.Monad) which work on every such library.
21:25:09 <Cale> That's really the only reason -- the convenience of not having dozens of what is really the same function over and over in many libraries.
21:25:39 <Cale> Don't believe anyone who says that Haskell has monads to do IO. IO is a monad, but only because it's convenient for that to be the case.
21:26:49 <Cale> For something to be a monad, you need to define two functions: return and >>=
21:26:58 <jeffwheeler> @src IO return
21:26:59 <lambdabot> return x    = returnIO x
21:27:04 <jeffwheeler> @src returnIO
21:27:04 <lambdabot> Source not found. That's something I cannot allow to happen.
21:27:06 <ivanm> Cale: well, wasn't the introduction/inclusion of monads driven by IO?
21:27:17 <jeffwheeler> @type returnIO
21:27:19 <lambdabot> Not in scope: `returnIO'
21:27:24 <jeffwheeler> That's lame. :(
21:27:25 <Cale> ivanm: Well, the earlier papers on monads didn't really touch on IO.
21:27:43 <Cale> ivanm: It was more a convenient structure for interprer libraries to use.
21:27:47 <Cale> interpreter*
21:28:30 <Cale> erisco: The monad itself is a type constructor, like Maybe or IO or [] (at the type level, which we usually write surrounding the type)
21:28:46 <Cale> return :: a -> m a, if m is our monad
21:28:57 <Cale> In the list monad,  return x = [x]
21:29:04 * jeffwheeler thinks lists have too much sugar
21:29:23 <Cale> In monads which have a computation sort of feel, return v will be a computation which "does nothing" but returns v
21:29:36 <erisco> Cale, chapter 14 covers monads. I think I will have to get there progressively before I really have any idea what you are talking about :P
21:29:40 <Cale> okay
21:29:53 <Cale> It's important to understand data types pretty well first, and typeclasses.
21:30:03 <Cale> Or at least, it's helpful
21:30:39 <Cale> I can show you specific monads and you can probably understand reasonably well already anyway:
21:30:53 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
21:30:54 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
21:31:03 <Cale> that's the list monad
21:31:21 <ray> the lost monad
21:31:21 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
21:31:22 <lambdabot>   ("hello","olleh","HELLO")
21:31:27 <Cale> That's the function monad :)
21:32:12 <erisco> I sort of see what is happening but I am not too certain as to the use
21:32:22 <paolino> hi, I have a question on licenses , I see iteratee (BSD3 licensed) depends on ListLike (LGPL licensed) , what restrictions for my executable that depends on iteratee ?
21:32:31 <Cale> well, it means that you get certain operations, like that sequence thing that I was using, for free
21:32:34 <erisco> chapter 14 uses a parser of sorts to example the usage of monads, which is what you said they were originally introduced for
21:32:41 <kulakowski> erisco: Does that notation look at all familiar?
21:33:10 <Cale> Well, to the extent that constructing a parser is like running an interpreter, yes :)
21:33:13 <RyanT5000> Cale: that's pretty awesome; it's reminiscent of RPN
21:33:15 <erisco> kulakowski, from IO operations I recognize the <-
21:33:30 <kulakowski> erisco: List comprensions is what I meant specifically
21:33:56 <Cale> Monadic parser libraries are nice -- you run the parsers with <- and capture their results
21:34:10 <Cale> (and things like backtracking are built in)
21:34:20 <erisco> kulakowski, I am going to say no
21:34:51 <Cale> erisco: If you know list comprehensions, it's possible to turn any list comprehension into a do-block in the list monad
21:35:22 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
21:35:23 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
21:35:40 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; guard (x^2 + y^2 == z^2); return (x,y,z)
21:35:41 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
21:35:47 <erisco> Pythagorean triples!!
21:35:51 <Cale> yep
21:36:18 <erisco> is that really the best way to find them?
21:36:29 <Cale> Not really, there are much better ways
21:36:40 <RyanT5000> but it's one of the simpler ways to find them :)
21:36:48 <ivanm> what would be the best way of defining the attributes listed here so that I can specify that they're only valid for a node, etc.? (so far they're all just defined in the same datatype) http://graphviz.org/doc/info/attrs.html
21:36:48 <Cale> (generating rational numbers and turning them into triples is my favourite way)
21:36:53 <erisco> I would have thought starting with the hypotenuse and trying to break it into two bases would be a better approach
21:37:01 <kulakowski> It's conceptually simple. There's an algorithm for generating them all
21:37:24 <Cale> and so the advantage here isn't that we get to write list comprehensions in an imperative-looking syntax, but rather that there are lots of functions which work on any of the types for which this do-notation works
21:37:32 <Cale> So, for example...
21:37:42 <Cale> > filterM (const [True, False]) [1,2,3]
21:37:43 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
21:38:29 <erisco> Cale, you really love functional programming don't you? :)
21:38:33 <Cale> We can get a combinations function *really* simply, because filterM captures the idea of deciding whether or not to keep each element of a list in any monad, and the list monad takes care of trying all possibilities for us.
21:39:09 <Cale> So that says "for each element of the list, regardless of what its value is (const), keep it, or drop it"
21:39:35 <Cale> yeah, I do happen to like it a lot :)
21:39:48 <Cale> In fact, imperative programming has come to seem difficult.
21:39:58 <idnar> @type filterM
21:39:59 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
21:40:05 <Cale> I have no idea how people keep track of so many changing variables all the time. :)
21:40:23 <erisco> Cale, I have no idea how you... do whatever you functional programmers do :P
21:41:00 <idnar> keep track of all that flowing data? :P
21:41:05 <erisco> having variables not really being variable in the sense of the word is confusing right off the bat :)
21:41:26 <idnar> erisco: they're variables in the mathematical sense of the word :P
21:41:33 <Cale> It's really nice when testing to be able to give a function some parameters and look at the result and know that no matter where you call that function in the program, it will give the same result.
21:41:47 <Cale> and it will continue giving the same result no matter how many times you call it
21:41:52 <Cale> or what day it is :)
21:42:13 <Cale> erisco: variables vary, but not so long as they remain in scope
21:42:21 <Cale> So if I have some function  f x = x^2
21:42:34 <erisco> Cale, that is something you can do in imperative languages yourself, there is nothing stopping you from it
21:42:36 <Cale> Then x might take on different values, but not in the same call to f
21:42:54 <Cale> erisco: Right, but I can't ensure it without looking at the source code for every function that I use.
21:43:37 <erisco> Cale, no, the language does not enforce it, but one of the principles we employ is that we can do bad things if we want to do bad things
21:44:20 <erisco> Cale, just makes us feel less conformed you know? :P
21:44:22 <kulakowski> erisco: But then you have to trust strangers when they say 'we didn't do anything bad', if you want to use they're library
21:44:24 <jmcarthur_work> the massive amount of purity in haskell is what has led to so many of our most elegant abstractions
21:44:46 <erisco> kulakowski, yes you do. imperative languages builds on your ability to trust
21:44:50 <Cale> erisco: The nice thing is that when you do this, types suddenly become way way more meaningful.
21:45:05 <Cale> erisco: and they become more like suggestions of how to use libraries
21:45:39 <Cale> So, once you're comfortable with types, you can often use a library correctly without even reading the documentation, because the types tell you how to use it
21:45:52 <monochrom> such as foldl
21:46:01 <erisco> hey, shush, monochrom :P
21:46:07 * monochrom hides again
21:46:19 <paolino> @unmtl ContT r (State s) a
21:46:19 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
21:46:22 <Cale> (well, it's not as simple as just eliminating effects, but a number of other things contribute to the type system being awesome as well)
21:46:59 <erisco> can we have a nice type system in an imperative environment?
21:47:07 <Cale> Basically, types are like the nubs on lego bricks which show you a good way to fit things together in order that you get something structurally sound
21:47:39 <Cale> You can... and in fact, you can even use Haskell like an imperative language to see how it would look.
21:47:50 <jmcarthur_work> haskell is my favorite imperative language
21:47:59 <erisco> -enable-imperative-mode
21:48:02 <erisco> where is that option? :)
21:48:06 <Cale> I think one of the main things which kills good types is subtyping which is popular in OO.
21:48:08 <jmcarthur_work> IO ()
21:48:14 <ivanm> erisco: do everything in do ;-)
21:48:21 <Twey> What's wrong with subtyping?
21:48:30 <Cale> Subtyping makes type inference hard, and parametric polymorphism painful.
21:48:30 <jmcarthur_work> subclassing isn't even real subtyping, much of the time
21:49:06 <Twey> I don't see why.  Subtyping is basically just automatically creating a class along with every type, and using that class in type signatures.
21:49:20 <Cale> and I think parametric polymorphism is way more important than subtype polymorphism for expressing what functions don't do.
21:49:39 <RyanT5000> Cale: is there a reasonable way of making extensible ADTs? it seems to me that that would cover most of the use cases of subtyping
21:49:50 <erisco> Cale, working in this mystical "loop that hasn't been done yet" lazy functional language, another thing I am accustomed to is objects
21:50:20 <Cale> erisco: You're in luck, I wrote a tutorial about how to handle cases where objects seem natural in Haskell, just yesterday :)
21:50:31 <erisco> Cale, how does Haskell represent a "thing"? a type with functions that act upon it?
21:50:31 <jmcarthur_work> you can make objects in haskell, but it's usually unnecessary
21:51:03 <erisco> but, then, without changing variables I am not entirely sure what an object in Haskell would mean
21:51:06 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
21:51:08 <jmcarthur_work> erisco, you could loosely compare a "class" to a module, and you could loosely compare an "interface" to a type class
21:51:09 <erisco> its all so confusing at the moment :P
21:51:42 <Cale> erisco: You can do pure objects as values which consist of a bunch of functions, and things which would normally mutate the object instead give you a new object.
21:51:58 <Cale> You can to impure objects using the IO monad or the ST monad too, in a very similar way.
21:52:02 <Cale> do*
21:52:23 <jeffwheeler> Wait, yi.org?
21:52:31 <jmcarthur_work> regardless, all this is just "can do" stuff, but what's really important is *forgetting* OO for a while
21:52:36 <jeffwheeler> Oh, total trick.
21:52:36 <Cale> jeffwheeler: Yeah, it's a free subdomain provider.
21:52:46 <jeffwheeler> Was hoping somebody had registered it for Yi. :P
21:52:47 <monochrom> I am in fact writing imperative code in IO left right and center now.
21:53:23 * erisco will have to stay away from do blocks
21:53:36 <Cale> It doesn't give you subtyping, but you can group similar object-types together using typeclasses. (which is not the same thing as subtype polymorphism, and there's no inheritance, but can often alleviate much of the feeling that you need it)
21:53:48 <Cale> erisco: do-blocks on their own are not harmful
21:54:07 <Cale> erisco: They're just a convenient syntax for a bunch of calls to >>=
21:54:09 <jmcarthur_work> do blocks just make it easy to use imperative notation as a crutch
21:54:26 <Cale> jmcarthur_work: no, that's not what they're really for :)
21:54:33 <Cale> But do-blocks in the IO monad do that.
21:54:45 <monochrom> A binary tree of numbers is given. Oh let's say the numbers are even mutable, e.g., IORef Int. Keep the tree but replace all those numbers (they're mutable eh) by their sum. For example if you had 4,3,5,1 in the tree, replace all of them with 13, since 13=4+3+5+1.  Do this by traversing the tree just once.
21:54:50 <erisco> Cale, I bookmarked that link
21:54:54 <Cale> I would not consider something like the list monad 'imperative' at all.
21:55:05 <jmcarthur_work> Cale, i never said what they're for, just what they are :P
21:55:09 <erisco> Cale, how haskell relates to common things accomplished in imperative programming will be important for me to see
21:55:27 <Cale> jmcarthur_work: Apart from the fact that there's the word 'do', it's not very imperative.
21:55:39 <jmcarthur_work> Cale, in semantics
21:55:41 <Cale> For one,  <-  is *not* the same thing as variable assignment.
21:55:44 <erisco> Cale, so, writing games in Haskell is practical too?
21:55:46 <monochrom> In most imperative languages you can't do it in one traversal. In Haskell you can do it imperatively in one traversal using mfix or mdo an a tying-the-knot. Yes here tying-the-knot even works over IORef Int.
21:55:46 <jmcarthur_work> Cale, it's just a trick
21:55:49 <Cale> erisco: yep
21:56:06 <erisco> Cale, since it is very important to games, what is the performance like? how far can you go?
21:56:06 <monochrom> Haskell is the finest imperative language!
21:56:40 <jmcarthur_work> erisco, we have a quake clone, as an example, although it was really an experiment in a certain *style* of functional programming
21:56:43 <Cale> In imperative programming, variables are boxes which assignment updates with new values. In do-notation v <- x does not mean that v is a box where the result of x is placed, it means that v is the result of x.
21:56:55 <monochrom> Some days later you will see my code for how to do it on the haskell wiki.
21:57:15 <Cale> I think that's one very important but subtle difference.
21:57:29 <RyanT5000> erisco: I founded a game company writing in Haskell - and on the iPhone no less; so, either Haskell can be used for games or I'm going to be terribly poor very soon :)
21:57:34 <Cale> The IO monad gives you imperative semantics via IORefs and other mutable state.
21:57:40 <Cale> But other monads don't.
21:57:44 <jmcarthur_work> erisco, my feelings are that there isn't anything stopping haskell from being as efficient as c for most kinds of games, although there isn't much as far as proof
21:57:45 <Cale> (not necessarily)
21:57:57 <erisco> RyanT5000, granted, iPhone hardware doesn't push gaming too far
21:58:16 <RyanT5000> erisco: well, performance is super-critical on such a small device like that
21:58:29 <Associat0r> http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP
21:58:32 <idnar> erisco: surely it pushes it even farther? :P
21:58:36 <Cale> erisco: There's something called functional reactive programming which I think is the future of game development, if we can just get it off the ground :)
21:58:53 <RyanT5000> erisco: so, profiling is one of the first things we're making sure is going well; haskell's profiler is top-notch
21:59:03 <jmcarthur_work> the problem with frp is we keep thinking of ways to improve it before we even have a good implementation of the old idea
21:59:04 <RyanT5000> Cale: I agree wholeheartedly :)
21:59:24 <erisco> Cale, is this an extension to the Haskell standard?
21:59:25 <Cale> There are presently some issues with performance of FRP, but I don't think they are fundamental issues at all.
21:59:33 <jmcarthur_work> i really think luke palmer hit the nail on the head with his most recent blog post, though
21:59:42 <Cale> erisco: Well, it could conceivably be, but current approaches are just libraries.
21:59:58 <Cale> It's possible that in order to make it really practical, we'll need to have some compiler support.
22:00:23 <Cale> (the difficulties with conal's library are starting to make me think this way)
22:00:45 <jmcarthur_work> i don't think it's necessary to have compiler support
22:00:48 <jmcarthur_work> although it might be better
22:01:14 <Cale> But it's really cool. The basic idea is that you have values which abstractly represent:
22:01:33 <Associat0r> Cale: do you have any idea on how to solve the perf issues?
22:01:34 <Cale> 1) things which vary over time continuously (like the position of the mouse, the location of the player, etc.)
22:02:10 <Cale> 2) events which consist of a sequence of values occurring at specific times (like mouse clicks, key presses)
22:02:21 <RyanT5000> i'm kind of confused why everyone's so focused on the "time-varying" nature of things
22:02:37 <Cale> Yeah, values of the first sort are called behaviours, and values of the second sort are called events.
22:02:45 <RyanT5000> the idea of a timeline seems distinct from most of the problems that are really key
22:02:52 <jmcarthur_work> RyanT5000, because if time is abstracted out then you don't have to worry about it :)
22:02:55 <Cale> and then we have operations for acting on behaviours and events which are just like the normal operations on values
22:03:03 <mike-burns> How does one test a function written using FRP?
22:03:10 <RyanT5000> jmcarthur_work: that sounds like a *good* thing
22:03:18 <jmcarthur_work> RyanT5000, right
22:03:21 <jmcarthur_work> that's the point
22:03:44 <RyanT5000> jmcarthur_work: oh, you mean that if the library worries about it, its user doesn't need to?
22:03:57 <RyanT5000> i misinterpreted what you meant by "abstracted out"
22:04:06 <RyanT5000> it seems to me that that could be handled orthogonally
22:04:10 <jmcarthur_work> RyanT5000, if i say: mousePos + (5,5), i'm done! no time or loop involved
22:04:15 <RyanT5000> i.e.: by a different library
22:04:17 <RyanT5000> oh right, i get that
22:04:25 <RyanT5000> but that doesn't depend on a *timeline*
22:04:45 <RyanT5000> just some variable that might take on different values
22:04:45 <jmcarthur_work> why not?
22:04:50 <jmcarthur_work> yes
22:05:01 <Cale> mike-burns: Basically, you compose your FRP function with a function that turns the resulting behaviours/events into output behaviour (like the current state of the display), and then pass in the events and behavours which consist of the user interface
22:05:02 <RyanT5000> timeline, to me, means an ordered (usually totally ordered), dense set of points
22:05:19 <mike-burns> Cale: I mean test in the HUnit sense.
22:05:34 <RyanT5000> it seems like a notion of push-variables (events) and a notion of pull-variables (behaviors) would be sufficient
22:06:12 <Associat0r> Cale: can you tell us some more about the performance issues?
22:06:15 <jmcarthur_work> RyanT5000, since behaviors are time varying, they can be sampled with arbitrary precision
22:06:38 <Cale> mike-burns: Ah, well, Behaviours are really just functions of time, and Events are really lists/sequences of time/value pairs, so you'd test them in a similar way to how you'd test functions/sequences of those types.
22:07:01 <Cale> Associat0r: Well, it's really subtle and I don't claim to fully understand it
22:07:11 <Cale> Associat0r: (If I did, I'd probably fix the issue myself ;)
22:07:19 <RyanT5000> i dunno, this whole treatment of time as some kind of magical, special thing seems a bit odd to me
22:07:21 <jmcarthur_work> Associat0r, the performance issue currently, in my opinion, is unnecessarily massive multithreading and GHC bugs
22:07:44 <RyanT5000> i certainly think that it should be easy to model time-varying functions, either continuous or discreet, in whatever library we call "FRP"
22:07:55 <RyanT5000> but i'm not so sold on the idea that time should be made explicitly special
22:08:02 <Cale> Associat0r: But there are issues for instance with representing events, where the beginning of a sequence of events gets held in memory for too long or is forced before it's needed
22:08:03 <mike-burns> Cale: With Hunit (as I understand it) you know the setup and the result of a function call based on that setup. You're saying you can you say "when I call this fuction the mouse's x-coordinate will be 5"?
22:08:21 <jmcarthur_work> RyanT5000, why do you keep saying it's explicit? the whole point is to make it implicit
22:08:25 <Cale> mike-burns: Yeah, you'd pass in fake mouse input as a parameter, say.
22:08:27 <jmcarthur_work> RyanT5000, the time stuff is just a semantic model
22:08:36 <mike-burns> Cale: Okay, that makes sense.
22:08:39 <RyanT5000> jmcarthur_work: i mean explicit in the design of the library
22:08:47 <Cale> jmcarthur_work: Well, it's a semantic model which can be made real.
22:08:49 <Associat0r> Cale: what about the filtering of events and multi object interaction?
22:09:15 <Cale> jmcarthur_work: One would hope that there are conversions between Behaviours and Time -> Value functions.
22:09:19 <jmcarthur_work> RyanT5000, i'd say the time is about as meaningful as IO's RealWorld stuff, just with some actual values
22:09:24 <Associat0r> jmcarthur_work: I don't think the perf issues are  GHC related
22:09:24 <Cale> jmcarthur_work: (at least for the pure case)
22:09:30 <jmcarthur_work> Cale, right
22:09:35 <RyanT5000> jmcarthur_work: it's the actual values i'm worried about :)
22:09:52 <jmcarthur_work> RyanT5000, you shouldn't be worried about them :P
22:09:52 <RyanT5000> also, the fact that it implies you can't have a branching structure
22:09:56 <Cale> Associat0r: I'm not sure.
22:10:04 <jmcarthur_work> RyanT5000, how does it imply that?
22:10:10 <RyanT5000> maybe i'm mistaken
22:10:25 <RyanT5000> i don't fully understand how state works in FRP
22:10:31 <jmcarthur_work> RyanT5000, we have all kinds of steppers and switchers and stuff
22:10:40 <jmcarthur_work> state is behavior
22:10:41 <RyanT5000> right, i remember reading about those
22:10:42 <jmcarthur_work> :)
22:10:49 <Cale> Associat0r: What I am fairly certain about is that in all the cases we've run into, it's obvious that there ought to be a way to translate the code into something efficient, but it's tricky to get the library to do that itself.
22:11:02 <RyanT5000> jmcarthur_work: i dunno; i'll come back when i understand things better :P
22:11:04 <jmcarthur_work> RyanT5000, FRP itself abstracts the state
22:11:22 <jmcarthur_work> RyanT5000, time and state are intertwined, in a sense
22:11:31 <RyanT5000> jmcarthur_work: yeah, i suppose they rae
22:11:32 <RyanT5000> *are
22:12:09 <RyanT5000> incidentally, is there any clean way to serialize the state of an FRP circuit?
22:12:22 <RyanT5000> it's obvious how you could thread the state along, out of it
22:12:36 <Associat0r> Cale: FRP GUI's is a solved problem now right?
22:12:45 <RyanT5000> but it would be very interesting to know if there's some way to make state just sort of fall out of the whole thing, without adding code
22:12:54 <Cale> Associat0r: I suppose it depends on what you mean by solved problem.
22:13:10 <Associat0r> Cale: solved as in no issues
22:14:12 <Cale> Associat0r: There are Arrow FRP libraries based on signal transformers which are efficient, but I think getting the more traditional Behaviour/Event model to work efficiently is still a concern, which is a shame since that way is much nicer.
22:14:39 <Cale> (just from a programming model standpoint)
22:15:59 <erisco> Cale, is FRP receiving active development?
22:16:34 <Cale> Yeah, Conal Elliott in particular is working very hard on it, and his blog is a good resource.
22:16:52 <Cale> and there are a bunch of other people who are working on various libraries
22:17:48 <Cale> The Arrow interface to FRP, which looks more like designing circuits has been more practically successful, but I think the programming model is not as pretty. People have been doing fun things like robotics control with it though.
22:18:16 <erisco> not as pretty as what?
22:18:28 <Cale> As the Behaviour/Event model which I described
22:18:44 <erisco> ah, and this is your own conception?
22:18:50 <Cale> Not mine
22:18:54 <Cale> Just a conception which I like
22:19:00 <Associat0r> Cale: the normal FRP model right?
22:19:18 <Cale> Yeah, I think Behaviour/Event is considered the 'normal' or 'traditional' model.
22:20:02 * erisco decides that he is going to learn functional programming
22:20:06 <erisco> but first, some sleep
22:20:08 <erisco> night everyone
22:20:13 <Cale> and then there's the circuit/arrow model which is newer(?) and has been more practically successful from what I've seen, but makes some hard concessions in terms of how pretty the code is
22:20:17 <erisco> good talking with you Cale and thanks for all the insight
22:20:28 <Cale> No problem! See you around!
22:21:09 <Cale> basically, you end up wiring together the connections between what would be your behaviours explicitly
22:21:30 <Cale> and it ends up looking a lot like a textual representation of a circuit
22:22:03 <Cale> But we don't really want that. We want to think of behaviours as values, and operate on those values directly.
22:22:10 <mjs22> cale: Any examples that you can point someone at that illustrates this?  I missed the beginning of the conversation.
22:22:49 <Cale> mjs22: Well, Yampa is an example of the Arrow-based FRP
22:24:18 <Cale> and well, Reactive is in a sad state right now, but if only it weren't, it would be a good example of the traditional model
22:25:01 <Associat0r> Fregl
22:25:09 <mjs22> ok.  this sounds relevant to a project I've been working on lately, and my knowledge of FRP is pretty shallow.  I'm trying to fix that. :-)
22:25:30 <Cale> There's also grapefruit (which I think is circuits)
22:25:52 <Cale> and wxFruit which is I think historically related to grapefruit
22:26:07 <Cale> and Fran which is older, but there are papers about it which you might want to look for
22:26:34 <mjs22> I've run across Fran in the past, I know that.
22:27:07 <dsturnbull> i just installed X11 1.4.5 and utf8-string 0.3.5 through cabal, but the xmobar cabal configure fails because it needs X11 >=1.3.0, utf8-string -any
22:27:17 <dsturnbull> what's going wrong?
22:27:33 <Cale> dsturnbull: hmm...
22:27:40 <Cale> dsturnbull: that is quite odd
22:28:12 <Cale> dsturnbull: Maybe ensure that other versions of those packages are hidden using ghc-pkg hide
22:28:50 <dsturnbull> ghc-pkg list shows that i _only_ have those versions
22:29:04 <Cale> okay, that's really unusual then
22:29:39 <Cale> I'll give things a try
22:30:13 <dsturnbull> oh, i just tried bulding with cabal instead of runhaskell Setup.lhs..
22:30:23 <Cale> oh, always use cabal now :)
22:30:55 <Cale> But that does sound like a bit of a bug. I wonder what's going on there.
22:31:14 <Cale> Maybe it's trying to install it globally and you have the dependency packages installed as user?
22:31:31 <Cale> (it can't lift the dependencies like that when installing globally)
22:31:38 <Associat0r> Cale: how does your OO example compare to this one? http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP
22:31:59 <Cale> Associat0r: I *briefly* mention existential types near the end.
22:32:03 <dsturnbull> right
22:32:06 <dsturnbull> well, just using cabal now
22:32:17 <Cale> Associat0r: But the overall effect is pretty similar, I suppose.
22:32:34 <Cale> I'll write that example in my way :)
22:32:46 <Associat0r> Cale: what about the lack of subtyping?
22:33:19 <Cale> Associat0r: Well, if you only work with Shapes it's not so much of a concern.
22:33:49 <Cale> Actually, my example would be almost degenerate
22:34:09 <Cale> I would have  data Shape = Shape { perimeter :: Double, area :: Double }
22:34:28 <Cale> circle radius = Shape { .. }
22:34:40 <Cale>   where perimeter = 2 * pi * r
22:34:50 <Cale>         area = pi * r * r
22:35:40 <Cale> But if the only operations you have are perimeter and area, you might as well just have a pair of doubles anyway.
22:36:08 <Cale> er, that should read  circle r = Shape { .. }
22:37:02 <Cale> Let's suppose you also want to give each Shape a centre and a way to move the shapes
22:38:49 <Cale> Well, for the moveTo, you'd add a function of type  (Double, Double) -> Shape
22:39:14 <Cale> and then implement it for each shape accordingly, by a recursive call to the constructing function
22:40:26 <Cale> and for the centre, I suppose that can just be another pair of doubles, and it will be a different pair in the moved shape
22:41:38 <Cale> In some sense, my translation detects those cases where you'd be silly to use an object type and gives you a normal algebraic one :)
22:42:11 <Cale> (because the only difference is how you look at it)
22:42:39 <Associat0r> Cale: but also in what way you want to extend easily
22:42:43 <Cale> right
22:43:22 <Cale> So if you store shapes as perimeter/area pairs, because those are the only basic operations you care about, then that gives you an incredible freedom in the sorts of shapes you can define
22:44:02 <Cale> (but it also doesn't tell you much about the shapes once you have them)
22:46:16 <ivanm> Cale: any idea how I can have graphviz attributes specified for Nodes, Edges, etc. but where some of them can be for more than one type?
22:47:05 <Cale> I've never used the graphviz library, but I'll look at it :)
22:47:42 <ivanm> well, the fact that it's graphviz is irrelevant ;-)
22:47:47 <Cale> What do you mean 'for more than one type'?
22:47:50 <ivanm> http://graphviz.org/doc/info/attrs.html
22:48:35 <ivanm> ^^ some of the attributes can be for Nodes, Edges, etc.; some are for more than just one type (e.g. for Nodes _and_ Edges)
22:48:47 <Cale> ahh
22:49:14 <ivanm> so is there a nice, type-safe way of representing that?
22:49:19 <ivanm> without duplication?
22:49:24 <Cale> There are a few ways...
22:49:29 <ivanm> atm, the library just has one big datatype
22:49:33 <Cale> right
22:50:00 <Cale> There's a trick for representing lists of types, and using typeclasses to decide if some type is in that list of types
22:50:22 <Cale> (You can also use typefamilies)
22:50:24 <ivanm> I'd prefer not to have to do something like "NodeAndEdge = NodeAttr NodeAttribute | EdgeAttr EdgeAttribute"
22:50:36 <Cale> right
22:50:54 <ivanm> Cale: links on the wiki or something?
22:50:59 <Cale> So, this is currently all one big ADT, and it's unsafe, yeah?
22:51:04 <ivanm> very
22:51:16 <Cale> okay, so the strategy, I think...
22:51:55 <Cale> will be to define it as a GADT, where the type parameter tells us which of the things it's used by
22:52:11 <soupdragon> Cale, it lets you write [1, Bool?]
22:52:17 <Cale> soupdragon: hm?
22:52:30 <soupdragon> this trick?
22:52:40 <Cale> soupdragon: Oh, not a list in that sense
22:53:08 <Cale> I mean we'll have some types which just serve as values at the type level
22:53:11 <Cale> data Node
22:53:15 <Cale> data Edge
22:53:43 <Cale> and then a way to cons up some lists at the type level
22:54:15 <Cale> data a ::: b
22:55:10 <ivanm> hmmmm.....
22:55:13 <Cale> and then a way to decide if some type is in our list of types
22:56:02 <Cale> hmm, let me think about this a bit, I don't think I've done it myself before, only read it :)
22:56:11 <ivanm> heh
22:57:43 <Cale> Well... actually, there's a simpler way.
22:58:03 * coCocoa lights some cyber-incense to help Cale channel Oleg... ooh, it Worked! ;)
22:58:22 <Cale> Have a couple of classes for each of the things the attributes can apply to
22:58:31 <Cale> and then a plain old empty type for each of the combinations
22:58:41 <Cale> and then make it an instance of the relevant classes
22:58:54 <Cale> and tag each of the attributes with that type (using a GADT)
22:59:41 <ivanm> empty classes?
22:59:54 <Cale> not empty classes, they'll have these label types as members
23:00:08 <Cale> there's a more extensible way, but you really don't have that many cases to handle here
23:00:12 <ivanm> as in no functions in the class
23:00:16 <Cale> oh, yes
23:00:28 <Cale> class NodeAttr
23:00:33 <Cale> class EdgeAttr
23:00:36 <Cale> er
23:00:38 <Cale> class NodeAttr t
23:00:41 <Cale> class EdgeAttr t
23:00:54 <Cale> data NodeA
23:01:01 <Cale> data EdgeA
23:01:04 <Cale> data NodeEdgeA
23:01:10 <ivanm> then a forall for the list of attributes?
23:01:18 <Cale> instance NodeAttr NodeA
23:01:25 <Cale> instance NodeAttr NodeEdgeA
23:01:35 <Cale> instance EdgeAttr EdgeA
23:01:38 <Cale> instance EdgeAttr NodeEdgeA
23:02:06 <Cale> and then your GADT will have things like...
23:02:34 <Cale>   Image :: String -> Attribute NodeA
23:02:52 <Cale>   LabelAngle :: Double -> Attribute EdgeA
23:03:25 <ivanm> ahhh
23:03:38 <ivanm> then have a list of [Attribute NodeA] ?
23:03:45 <Cale>   Color :: ColorType -> Attribute NodeEdgeA
23:03:49 <Cale> ah
23:03:51 <jeffwheeler> @where liftIO
23:03:52 <lambdabot> I know nothing about liftio.
23:03:53 <Cale> but then you have a problem
23:03:59 <ivanm> oh, right
23:04:00 <ivanm> duh
23:04:27 <ivanm> Cale: what about a foral on the classes being used?
23:04:29 <Cale> I was thinking that the operations on nodes would have types like   (NodeAttr t) => Attribute t -> ...
23:04:45 <Cale> But you could also use an existential type if you really need to put them in a list
23:05:16 <Cale> data NodeAttribute where
23:05:38 <Cale>   NA :: (NodeAttr t) => Attribute t -> NodeAttribute
23:05:49 <ivanm> yeah, that's a bit ugly, isn't it? :s
23:06:00 <Cale> We have so many things with similar names that it might be worth thinking about.
23:06:38 <ivanm> what is worth thinking about?
23:06:43 <Cale> Better names
23:07:08 <kulakowski> Naming things is the hard part.
23:07:25 <kulakowski> Or naming things well
23:07:38 <ivanm> by "ugly", I meant having to have [NA foo, NA bar], etc.
23:08:15 <Cale> well, if you're going to give foo and bar separate types...
23:08:31 <ivanm> yeah :s
23:08:56 <Cale> It all comes down to what you want to check at compile time and what you're willing to defer to runtime.
23:09:13 <quicksilver> In general if you want a 'list' of different types, you have to give up something.
23:09:13 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
23:09:20 <quicksilver> You either give up list notation
23:09:25 <ivanm> you mean what I want ghc to catch and what I want the graphviz programs to complain about?
23:09:31 <quicksilver> (and use foo ::: bar ::: baz ::: Nil)
23:09:41 <ivanm> @hoogle (:::)
23:09:42 <lambdabot> Warning: Unknown type :::
23:09:42 <lambdabot> Prelude undefined :: a
23:09:42 <lambdabot> Data.Array.Base arrEleBottom :: a
23:09:43 <quicksilver> with a special polymorphic :::
23:09:46 <ivanm> ahhh
23:09:48 <quicksilver> (of your own design)
23:09:52 <Cale> ivanm: Well, it would also be easy enough for the graphviz library itself to check.
23:10:03 <Cale> ivanm: At runtime rather than being a type constraint.
23:10:06 <quicksilver> or, you introduce a convertor on each one, like cale's NA.
23:10:06 <ivanm> a validity test?
23:10:35 <quicksilver> @messages
23:10:36 <lambdabot> kuribas said 7h 22m 13s ago: My new version has fixed the module bug and the multiline string bug: http://kuribas.hcoop.net/haskell-indentation.el
23:10:45 <quicksilver> @tell kuribas \o/
23:10:46 <lambdabot> Consider it noted.
23:11:00 <ivanm> ooohhhh, that (multi-line string) was a bug I was complaining about!
23:11:10 <ivanm> I just wish kuribas versioned it :s
23:12:28 <ivanm> Cale: how could I have the library check the attrs?
23:12:38 <kulakowski> What does kuribas's indent mode do differently than the one included in haskell.el?
23:12:59 <quicksilver> kulakowski: it gets it right much more often, for one.
23:13:14 <quicksilver> kulakowski: and it cycles through the possible indent levels in a more logical order.
23:13:18 <ivanm> kulakowski: it "forces" correct indentation
23:13:29 <ivanm> but it complains a lot more if you don't do something it thinks is right
23:13:31 <dolio> It doesn't actually cycle them.
23:13:38 <dolio> You just indent/outdent.
23:13:40 <Cale> ivanm: Well, it would check in the main functions in Data.GraphViz
23:13:46 <kulakowski> sounds worth a download then, thanks
23:13:56 <quicksilver> dolio: OK, cycle was a bad choice of words.
23:13:59 <ivanm> Cale: _how_ to do such a check (check which types are in each list? :s)
23:14:04 <Cale> yeah
23:14:09 <quicksilver> in enables you to traverse the possible indent levles ina  more logical order :)
23:14:10 <dolio> Same ultimate effect, I suppose.
23:14:20 <Cale> all isEdgeAttribute edgeAttrs
23:14:34 <ivanm> right
23:14:35 <ivanm> duh
23:14:35 <ivanm> :s
23:15:09 <Cale> Unfortunately the types of those functions are not Maybe'd, so you'll perhaps just throw an exception, or write a safe variant
23:15:30 <ivanm> yeah
23:15:32 <quicksilver> did we already discard the "naive" solution of data NodeAttr; data EdgeAttr; and then use [NodeAttr] or [Either NodeAttr EdgeAttr] as appropriate?
23:15:35 <ivanm> I'm slowly working my way up
23:15:48 <ivanm> quicksilver: it needs more than that
23:15:55 <quicksilver> (you could give a name to Either NodeAttr EdgeAttr or not, as you choose)
23:16:17 <ivanm> there's five levels: ENGCS; some attributes are only one of each, others are some combination
23:16:30 <Cale> I think the problem is the naming overlap between edge and node attributes.
23:16:47 <ivanm> so having it checked at runtime with a validity test is probably going to be the easiest to write and use
23:16:51 <Cale> Of course, you can resolve this just by using different names.
23:16:53 <quicksilver> well "data NodeAttr" can be an existential.
23:17:06 <ivanm> quicksilver: as in a forall?
23:17:11 <Cale> quicksilver: right, we looked at that
23:17:19 <ivanm> prob with that is, the library parses the dot output...
23:17:29 <Cale> quicksilver: but it was decided that having to write the existential constructor over and over wasn't so nice :)
23:17:37 <ivanm> so wouldn't existentials make it harder to get values back out (e.g. positional info)?
23:17:43 <Cale> eh?
23:18:18 <Cale> ah, I think I might know what you mean there
23:18:29 <ivanm> something like the graphToGraph function in Data.GraphViz
23:20:10 <ivanm> right, so runtime checks it is
23:20:35 * ivanm will probably be rewriting most of the Data.GraphViz module when the generic graph classes have been finalised and released
23:20:47 <ivanm> atm, I just care about the attributes
23:23:52 <quicksilver> I think possibly the best answer to ivanm's question can't be decided without seeing what kinds of functions he needs to write over these attributes.
23:24:09 <quicksilver> the best answer is determined by what kind of polymorphism you need most often in practice.
23:24:54 <dainanaki> I'm trying to put together a Haskell grammar parser using Parsec. I'm a little stuck though. Is there an existing Haskell parser out there that uses parsec?
23:26:09 <quicksilver> I don't think so, dainanaki.
23:26:19 <quicksilver> The best haskell parser is haskell-src-exts
23:26:24 <quicksilver> but it's not written using parsec.
23:26:50 <dainanaki> Yeah, but I was wanting to write one from scratch as a project. It wouldn't have to be perfect.
23:30:49 <paolino> @where parsect
23:30:50 <lambdabot> I know nothing about parsect.
23:31:03 <paolino> @hoogle parsecT
23:31:04 <lambdabot> Text.Parsec.Prim data ParsecT s u m a
23:31:04 <lambdabot> Text.Parsec.Prim ParsecT :: State s u -> m (Consumed (m (Reply s u a))) -> ParsecT s u m a
23:31:04 <lambdabot> Text.Parsec.Prim runParsecT :: ParsecT s u m a -> State s u -> m (Consumed (m (Reply s u a)))
23:32:57 <paolino> uhm, where is runParserT in the docs ?
23:33:19 <paolino> *runParsecT
23:34:48 <paolino> and in my module...., is this a 6.10.3 feature ?
23:36:05 <Twey> paolino: On Hackage
23:36:09 <Twey> That's from Parsec 3
23:37:33 <paolino> installing parsec package ?
23:38:07 <shepheb> is there a bundled cabal-install-and-dependencies tarball somewhere?
23:38:32 <paolino> bootstrap.sh
23:39:10 <paolino> is inside the tarball of cabal-install
23:39:50 <paolino> Twey: No packages to be installed. All the requested packages are already installed, from cabal install parsec
23:40:10 <Twey> paolino: You'll have a Parsec already, but maybe not Parsec 3
23:40:11 <Twey> Check your version
23:41:23 <paolino> Twey: shouldn't it upgrade with cabal install ?
23:42:36 <paolino>  cabal upgrade parsec
23:42:36 <paolino> made nothing different
23:43:11 <paolino> is parsec the package name we are talking about ?
23:45:22 <paolino> --reinstall installed 2.1.0.1 .....
23:46:50 <paolino> also after cabal update
23:52:58 <jeffwheeler> Am I totally confused, or does the second example here not work? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
23:53:11 <jeffwheeler> Because request returns a pair, with the URI and the Result.
23:53:16 <jeffwheeler> While getResponseBody only expects the Result.
23:53:56 <paolino> I installed by parsec by hand but at the command line ghci refuses to load it
23:54:16 <paolino> module `Text.Parsec.Prim' is not loaded
23:54:37 <jeffwheeler> Maybe 'request' was different in an older version? Here's the latest: http://hackage.haskell.org/packages/archive/HTTP/4000.0.7/doc/html/Network-Browser.html#v%3Arequest
23:55:06 <Cale> paolino: which version are you trying to get?
23:55:21 <paolino> last one
23:55:36 <paolino> parsec-3.0.0.tar.gz
23:56:00 <paolino> theone with ParsecT
23:56:17 <Cale> cabal install parsec-3.0.0
23:57:36 <paolino> cabal install --reinstall parsec-3.0.0
23:58:16 <paolino> Cale why it's not installing last version by default ?
23:58:52 <paolino> Prelude> :m Text.Parsec
23:58:52 <paolino> module `Text.Parsec' is not loaded
23:59:10 <Cale> are you sitting in a directory where Text/Parsec.hs  exists?
23:59:40 <Cale> If so, then change the current directory
