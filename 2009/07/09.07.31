00:00:12 <copumpkin> ooh, a fancy new package on hackage
00:00:18 <copumpkin> since hackagebot just died trying to announce it
00:00:31 <edwardk> i'm using it to round trip my lexer, etc. and find what doesn't lex . unlex . lex = lex properly
00:03:11 <edwardk> ok, so now i can pass 100k tests and not bomb so i'm a bit happier =)
00:03:18 <copumpkin> lol
00:03:24 <edwardk> (i found the first failure around 7k or so0
00:04:33 <edwardk> i need to build a series of monoid test suite combinators that verify that a monoid is associative, etc. by randomly permuting the associativity and adding units, etc.
00:04:48 <edwardk> for some non-trivial toys
00:05:37 <copumpkin> does your monoid lib still use the stdlib monoid library?
00:05:43 <copumpkin> writting mappend everywhere is icky
00:05:46 <edwardk> yeah
00:05:49 <edwardk> but i sugar it
00:05:51 <copumpkin> ah
00:06:06 <edwardk> (<+>) for mappend (+>) for cons and (<+) for snoc
00:06:42 <edwardk> (where the latter are my reducer operations) i may actually make those the standard names if the libraries proposal for the _other_ (+>) and (<+) doesn't go through
00:06:50 <edwardk> er the standard names in 'monoids'
00:06:58 <copumpkin> ah
00:07:17 <edwardk> since i often use them infix
00:10:10 <edwardk> its sad i'm thinking about ripping monoids into 'monoids' and 'monoid-extras' ;)
00:10:32 <copumpkin> lol
00:10:44 <copumpkin> soon you'll be sticking categories into monoids
00:10:49 <edwardk> i just want monoids, reducers and generators for kata, i don't need the rest of the crap
00:10:49 <copumpkin> they do belong, after all
00:10:59 <edwardk> well every monoid is a category at least
00:11:11 <edwardk> even if you can't express that well in haskell (though you can in kata!) ;)
00:11:36 <edwardk> in fact you may be somewhat sickened to hear my monoid class provides a member to view any subclass as a category =P
00:12:01 <copumpkin> :o
00:12:59 <edwardk> originally i had monoid subclass category but the spurious (.) and id members got kind of annoying ;)
00:13:38 <edwardk> if i add proper namespacing for members then that becomes less of a problem, but its annoying for now
00:15:44 <Gracenotes> meow
00:29:37 <wmealing_> so, cal deals with being linked to on reddit
00:29:41 <wmealing_> by password protecting their entire site
00:29:42 <wmealing_> good work.
00:30:25 <copumpkin> huh? works for me
00:30:47 <wmealing_> http://openquark.org/Open_Quark/Welcome.html ?
00:32:37 <copumpkin> works for me :P
00:32:40 <copumpkin> unless it's cached somehow
00:32:54 <copumpkin> aha, it was I think
00:32:57 <ftrvxmtrx> jim
00:32:58 <copumpkin> asking me for password now
00:33:05 <ftrvxmtrx> oops, sry
00:33:18 <copumpkin> jimdeed
00:33:52 <wmealing_> thats the way, avoid getting your name out, no matter what !
00:33:59 <wmealing_> i think they should just remove it from the net, that might be easier.
00:34:10 <copumpkin> lol
00:34:20 <copumpkin> they just adopted haskell's motto and took it more seriously
00:34:30 <copumpkin> "oh shit, looks like success is coming from reddit, better hide"
00:34:50 * wmealing_ laughs
00:35:33 <wmealing_> evasive maneuvers !!
00:35:42 * copumpkin would like to do some ridiculous knot-tying to build a graph
00:36:01 <edwardk> copumpkin: stablenames ;)
00:36:06 <edwardk> cheat
00:36:12 <copumpkin> edwardk: never tried those
00:36:26 <copumpkin> it would make the whole algorithm ridiculously elegant
00:36:30 <edwardk> sounds like a good time to learn ;)
00:36:41 <copumpkin> if I could represent the graph in haskell
00:36:51 <copumpkin> In Haskell, that is
00:37:16 <copumpkin> makeStableName# :: a -> State# RealWorld -> (#State# RealWorld, StableName# a#)	
00:37:24 <copumpkin> surely there's something higher-level than that?
00:37:39 <copumpkin> or do I need to wrap it in IO myself?
00:38:10 <copumpkin> aha
00:38:16 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
00:38:57 <copumpkin> edwardk: hmm, how would I use those to do my epic knot-tying?
00:39:47 <copumpkin> lol
00:39:48 <copumpkin> #if defined(__PARALLEL_HASKELL__)
00:39:48 <copumpkin> makeStableName a =
00:39:48 <copumpkin>   error "makeStableName not implemented in parallel Haskell"
00:39:55 <copumpkin> that's fun
00:42:42 <ketil> @seen cale
00:42:42 <lambdabot> cale is in #haskell, #haskell-overflow, #haskell-in-depth and #ghc. I last heard cale speak 5h 24m 2s ago.
00:44:48 <copumpkin> zomg edwardk1
01:04:32 <hackagebot> network-fancy 0.1.2 - Networking support with a cleaner API (TaruKarttunen)
01:15:03 <mornfall> Hmm.
01:15:28 <mornfall> Is there a way to unpack a zip archive on-the-fly from HTTP, using the HTTP and zip-archive libs?
01:15:48 <mornfall> The naive version loads complete file into memory and when done, unpacks it.
01:16:35 <koala_man> zip archives have the file index at the end, unlike .tar.gz and such
01:16:52 * WorkyBob hates that
01:17:01 <mornfall> Does that mean you can't unpack as you go? :|
01:17:02 <WorkyBob> the logic is supposed to be that it makes writing it easier
01:17:02 <copumpkin> a friend of mine wrote a c library to do just that
01:17:03 <copumpkin> http://github.com/planetbeing/partial-zip/tree/master
01:17:06 <WorkyBob> because you already know how long it is
01:17:14 <WorkyBob> mornfall: yes, because you don't know where the files are in it
01:17:18 <mornfall> Bah.
01:17:19 <mornfall> Ok.
01:17:23 <copumpkin> mornfall: look at that link
01:17:33 <mornfall> So is there a hackage lib that understands tar? :)
01:17:58 <copumpkin> oh I guess you don't want what he wrote
01:18:02 <copumpkin> although you could apply it
01:18:05 <mornfall> Indeed.
01:18:19 <mornfall> There's tar, so zlib+tar could fix that.
01:21:09 <ziman> does the "<command line>: not built for interactive use" message mean I need to recompile GHC?
01:21:40 <ziman> this is gentoo distribution ghc :\
01:22:37 <hackagebot> nntp 0.0.2.1 - Library to connect to an NNTP Server (MaciejPiechotka)
01:28:37 <mornfall> But, still no streaming.
01:28:53 <mornfall> And this time it's not the format (I hope).
01:30:21 <mornfall> Maybe it's simpleHTTP that doesn't let things stream...
01:31:20 <mornfall> The tar library claims it is lazy, I believe zlib is as well... Hmh.
01:34:24 <mornfall> I guess simpleHTTP is not the right one.
01:37:43 <hydo> Does there happen to be a version of 'concat' that will let you mash together two lists of lists, but will not collapse the sublists of both?
01:38:48 <mornfall> hydo: Like ++?
01:38:59 <mornfall> :t (++)
01:39:01 <lambdabot> forall a. [a] -> [a] -> [a]
01:40:10 <earthy> > concat [ [[1],[2]] , [[3,5],[4,6]] ]
01:40:11 <lambdabot>   [[1],[2],[3,5],[4,6]]
01:40:14 <earthy> doesn't do what you want?
01:40:26 <hydo> weird... I could have sworn ++ was giving me back [[x]] instead of [x]... I must have been doing something funky somewhere else.
01:40:45 <hydo> Maybe it's time to take a break. heh
01:41:18 <hydo> Thanks!  I appreciate the help
01:42:30 <mornfall> I wish I knew why simpleHTTP isn't streaming the response body. : - (
01:48:30 <mle> > [ [[1],[2]] , [[3,5],[4,6]] ] >>= id >>= id >>= show
01:48:31 <lambdabot>   "123546"
01:54:20 <blueonyx> > show . concat . concat $ [ [[1],[2]] , [[3,5],[4,6]] ]
01:54:21 <lambdabot>   "[1,2,3,5,4,6]"
01:55:45 <blueonyx> > map show . concat . concat $ [ [[1],[2]] , [[3,5],[4,6]] ]
01:55:47 <lambdabot>   ["1","2","3","5","4","6"]
01:55:55 <mornfall> :)
01:56:04 <mornfall> concat . map show . concat . concat
01:56:46 <blueonyx> ah yea the show gets concatenated too
01:56:48 <mmorrow> (show =<<) . join . join
01:56:58 <mornfall> :)
01:56:59 <mmorrow> ((show . join) =<<)
01:57:01 <mmorrow> ?
01:57:04 <mmorrow> @type (show =<<) . join . join
01:57:06 <lambdabot> forall a. (Show a) => [[[a]]] -> [Char]
01:57:10 <mmorrow> @type ((show . join) =<<)
01:57:10 <mornfall> Bingo.
01:57:12 <lambdabot> forall (m :: * -> *) a. (Show (m a), Monad m) => [m (m a)] -> [Char]
01:57:20 <ziman> concatMap show :)
01:57:32 <mmorrow> @type (show =<<)
01:57:34 <lambdabot> forall a. (Show a) => [a] -> [Char]
01:57:42 <Gwern-away> the editorial for the latest TMR is funny
01:57:47 <mmorrow> @src [] (>>=)
01:57:48 <lambdabot> xs >>= f     = concatMap f xs
01:57:49 <Gwern-away> but is wouter being sarcastic?
01:58:59 <mmorrow> @type [((show . join) =<<), concatMap (show . concat . concat)]
01:59:01 <lambdabot> forall a. (Show a) => [[[[[a]]]] -> [Char]]
01:59:37 <mmorrow> err
01:59:40 <mmorrow> @type [((show . join) =<<), concatMap (show . concat)]
01:59:42 <lambdabot> forall a. (Show a) => [[[[a]]] -> [Char]]
02:00:43 <mmorrow> @let lolcat = (join =<<)
02:00:45 <lambdabot>  Defined.
02:00:52 <mornfall> join . fmap show . join . fmap id . join . fmap id $  [ [[1],[2]] , [[3,5],[4,6]] ]
02:00:58 <mornfall> Er.
02:01:02 <mornfall> > join . fmap show . join . fmap id . join . fmap id $  [ [[1],[2]] , [[3,5],[4,6]] ]
02:01:04 <lambdabot>   "123546"
02:01:17 <mmorrow> fmap id ?
02:01:27 <mornfall> Translation of the original >>= id
02:01:35 <mmorrow> @src join
02:01:35 <lambdabot> join x =  x >>= id
02:01:44 <mornfall> : - )
02:01:45 <mmorrow> @type fmap id
02:01:47 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
02:03:21 * hask11 hi
02:03:45 <mornfall> @src (>>=)
02:03:46 <lambdabot> Source not found. My brain just exploded
02:03:53 * hask11 i am newcomer to this channel
02:04:05 <mornfall> (Well, it *could* have the definition from join and fmap...)
02:04:05 <hask11> in fact, newcomer to IRC
02:04:22 <mle> heh
02:04:43 <mornfall> hask11: Are you the category of Haskell types?
02:04:46 <hask11> I have started
02:04:48 <mle> >>= on list is concatMap; there being used for the concat.
02:05:09 <mornfall> mle: Yeah. It's just another form of masturbation, really.
02:05:56 <mle> wonderful.
02:06:12 <ziman> hask11, welcome then :)
02:06:37 <mornfall> But back to the problem, is there a ... Drat.
02:06:50 <hask11> Thanks ziman
02:07:03 <mornfall> Is there a way to make HTTP provide the body lazily?
02:07:29 <hask11> Hi mornfall, I am using Haskell for some time
02:08:03 <mornfall> :)
02:11:35 <fg3_> did a cabal install pandoc  -- says it's installed but not in my path
02:11:38 <fg3_> where is it
02:11:44 <mornfall> ~/.cabal/bin
02:12:03 <fg3_> I  have to add that to my $PATH i guess
02:12:10 <mornfall> That's one option.
02:12:22 <mornfall> You can ask cabal to symlink these elsewhere (say ~/bin).
02:12:28 <mornfall> Whichever you prefer.
02:12:31 <mornfall> (I have that on my PATH.)
02:12:36 <fg3_> I installed as root -- is it in the root home dir -- is that ideal?
02:12:50 <mornfall> You can use --system or so to install system-wide.
02:12:55 <Axman6> you usually don't use root with cabal-install
02:13:05 <fg3_> ok
02:13:05 <mornfall> Right, it's better to keep things in your regular home.
02:13:18 <fg3_> i'll try again
02:16:10 <cjs> Ho! I found a real-life use for scanl!
02:16:18 <cjs> > scanl1 (</>) $ splitPath "/foo/bar/bam"
02:16:19 <lambdabot>   Not in scope: `</>'Not in scope: `splitPath'
02:16:27 <cjs> Bah.
02:16:45 <cjs> scanl1 System.FilePath.(</>) $ System.FilePath.splitPath "/foo/bar/bam"
02:16:51 <cjs> > scanl1 System.FilePath.(</>) $ System.FilePath.splitPath "/foo/bar/bam"
02:16:52 <lambdabot>   Not in scope: data constructor `System.FilePath'Not in scope: `</>'Not in s...
02:17:13 <cjs> Anyway, the result is ["/","/foo/","/foo/bar/","/foo/bar/bam"]
02:17:13 <cjs> .
02:43:57 <hackagebot> cautious-file 0.1.5 - Ways to write a file cautiously, to reduce the chances of problems such as data loss due to crashes or power failures (RobinGreen)
03:03:05 <cjs> Hm. I notice that that uses "#ifdef _POSIX". But cpp -dM /dev/null doesn't show that as defined. Are there additional things that gcc is definingg?
03:15:48 <mmorrow> cjs: touch 0.c && gcc -E -dM 0.c && rm 0.c # ?
03:17:01 <mmorrow> heh
03:17:03 <mmorrow> #define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
03:17:32 <mmorrow> > (length . show) (9.999999999999999999999999999999999e6144::CReal)
03:17:34 <lambdabot>   6147
03:20:48 <Axman6> > (length . show) (0.000000000000000000000000000000001E-6143DL :: CReal)
03:20:49 <lambdabot>   Not in scope: data constructor `DL'
03:20:55 <Axman6> > (length . show) (0.000000000000000000000000000000001E-6143 :: CReal)
03:20:57 <lambdabot>   3
03:21:00 <Axman6> ...
03:21:01 <Axman6> ha
03:21:10 <Axman6> > (length . show) (0.000000000000000000000000000000001e-6143 :: CReal)
03:21:11 <mmorrow> > (show) (0.000000000000000000000000000000001E-6143 :: CReal)
03:21:12 <lambdabot>   3
03:21:13 <lambdabot>   "0.0"
03:21:21 <mmorrow> pssht
03:21:24 <mmorrow> :)
03:21:26 <cjs> mmorrow: I think that gives me the same output as cpp -dM /dev/null.
03:21:31 <Axman6> oh makes sense
03:21:42 <mmorrow> cjs: yeah i was just realizing that..
03:21:45 <Axman6> since the default show wouldn't go to that precision
03:21:50 <cjs> Anyway, it also doesn't include anything with "posix" in the output.
03:22:09 <mmorrow> Axman6: why don't then show "0.000000000000000000000000000000000000000000.." ?
03:22:21 <mmorrow> > 0 == (0.000000000000000000000000000000001E-6143 :: CReal)
03:22:24 <lambdabot>   True
03:22:28 <Axman6> huh
03:22:32 <mmorrow> looks like CReal truncates
03:22:41 <mmorrow> tsk tsk :)
03:22:46 <doserj> > show (1E-41 :: CReal)
03:22:47 <lambdabot>   "0.0"
03:22:56 <Axman6> > 0.000000000000000000000000000000001 * 10**(-6143) :: CReal
03:22:58 <lambdabot>   0.0
03:23:02 <mmorrow> > show (1E-41 :: Double)
03:23:04 <lambdabot>   "1.0e-41"
03:23:28 <Axman6> > drop 100 . showCReal 200 $ 0.000000000000000000000000000000001 * 10**(-6143)
03:23:29 <lambdabot>   ""
03:23:47 <Axman6> > drop 100 . showCReal 200 $ 10**(-6143)
03:23:49 <lambdabot>   ""
03:23:53 <Axman6> > drop 100 . showCReal 2000 $ 10**(-6143)
03:23:55 <mmorrow> CReal fail
03:23:56 <cjs> Ah, the cabal file has "if flag(posix) cpp-options: -D_POSIX"
03:23:57 <lambdabot>   ""
03:24:02 <Axman6> mmorrow: yeah :\
03:24:24 <mmorrow> > 0 == (0.000000000000000000000000000000001E-6143 :: CReal)
03:24:26 <lambdabot>   True
03:24:27 <Axman6> so what's DEC128 anyway?
03:24:28 <mmorrow> says it
03:24:42 <mmorrow> Axman6: 128 bit floats
03:24:45 <mmorrow> ooh
03:24:49 <Axman6> thought as much
03:24:49 <mmorrow> DEC being decimal..
03:24:55 <Axman6> ah
03:25:15 <mmorrow> i dunno the particular, but it looks unpleasant (that encoding)
03:25:38 <mmorrow> but there's also the base 2 encoding too..
03:26:19 <mmorrow> (%xmmN : 64bit), and (%ymmN : 128bit) on x86_64
03:27:29 <Axman6> so, Ada's concurrency primitives are quite nice
03:27:33 <mmorrow> and there're sseN instrs that let you operate one them as if they were a vector of 8/16/32/64 bit ints iirc
03:27:40 <mmorrow> s/one/on/
03:27:41 <Axman6> well, maybe not primitives, but features
03:54:33 <Axman6> oh man, this guy is totally right: http://www.reddit.com/r/programming/comments/968d7/why_do_we_still_have_to_explicitly_save_files_why/
03:56:14 <burp> zfs auto snapshot like?
03:57:14 <Axman6> well, more like programs saving revisions automatically
03:57:35 * Axman6 has got to go pick up his girlfriend
03:58:05 <Ke> anything not explicitly saved is garbage!
03:58:22 * Ke runs
04:01:35 <saml> given a list, how would you substitute nth element with x?
04:02:00 <saml> take n l ++ x : drop (n+1) l   ?
04:02:24 <Philippa> I wouldn't do it that way because you pay a price for the ++
04:02:41 <Zao> Assuming that the list has enough elements, otherwise it'll end up at the end.
04:02:47 <Wraithan> Prelude> import Text.HTML.Download (openURL)
04:02:49 <Wraithan> oopes
04:03:07 <Philippa> also a good point, what's the desired behaviour in that case?
04:03:25 <agapoulitsas> hi, in http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
04:03:33 <MyCatVerbs> saml: Yes. But at the very least use Data.Sequence instead of lists - if the lists are going to be long.
04:03:41 <agapoulitsas> what does 'modify succ' do in 1.2?
04:03:45 <saml> i guess it should just return orignal in that case
04:03:55 <saml> or maybe i'll do Maybe [a]
04:04:57 <Philippa> honestly, I'd probably just write the recursion out of habit myself
04:05:32 <Pistahh> agapoulitsas: modifies the state by calling the "succ" function
04:05:47 <Wraithan> Um, so I am trying to use the script at the bottom of the page on http://www.haskell.org/haskellwiki/Xmonad/Config_archive this page. It is giving a lot of funky errors, so I tried to input it line by line into GHCi, I am getting "<interactive>:1:0 parse error on input `import'" for any import line I try to use the "import Text.HTML.Download (openURL)" notation for only getting a single function from
04:05:49 <Wraithan> the module
04:06:06 <Wraithan> I am running ghc 6.10.3 (have to rebuild several packages to use .4 so I haven't moved yet)
04:06:47 <agapoulitsas> Pistahh: what state? 'n' in our case?
04:07:31 <Pistahh> agapoulitsas: no. the one that is returned by "get"
04:08:09 <Pistahh> agapoulitsas: n gets the value of the current state, than state is updated (imperatively: state := succ(state))
04:08:14 <saml> > let replace _ _ [] = []; replace 0 a (x:xs) = a : xs; replace n a (x:xs) = x : replace (n - 1) a xs  in  replace 3 'a'  "holla back"
04:08:15 <lambdabot>   "holaa back"
04:08:34 <saml> > let replace _ _ [] = []; replace 0 a (x:xs) = a : xs; replace n a (x:xs) = x : replace (n - 1) a xs  in  replace 33453454 'a'  "holla back"
04:08:36 <lambdabot>   "holla back"
04:08:45 <agapoulitsas> Pistahh: but how is the state returned by "get" passed to modify? can you write the math formalism for me to get it? thanks
04:09:05 <Pistahh> agapoulitsas: http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/src/Control-Monad-State-Class.html#modify
04:09:13 <Ytinasni> @src modify
04:09:13 <lambdabot> Source not found. Just try something else.
04:10:09 <Ytinasni> ...
04:10:17 <Ytinasni> anyway, > modify f = do { a <- get; put (f a) }
04:10:45 <agapoulitsas> pistahh: no. the question is about the 'do' notation. can someone rewrite it please?
04:10:55 <Ytinasni> modify does a SECOND get, and then a put.
04:11:37 <Pistahh> agapoulitsas: get >>= (\s -> return (f s))
04:12:13 <Peaker> Pistahh: that's fmap f get
04:13:12 <agapoulitsas> i want a more mathematical version of newId without the do notation to understand the bindings.
04:13:31 <agapoulitsas> sorry if i am being annoying but i am having trouble understanding the state monad
04:14:04 <Ytinasni> agapoulitsas: get >>= \a -> modify succ >> return a
04:15:20 <Ytinasni> what don't you understand, in particular?
04:16:36 <agapoulitsas> Ytinasni: how state produced by 'modify succ' is passed on to return a?
04:17:35 <Pistahh> agapoulitsas: by the >>= operator (which is implicitly called by the "do" construct)
04:18:03 <agapoulitsas> yes but >> is like >>= \_ -> ...
04:18:15 <agapoulitsas> therefore it should be gone
04:18:25 <Ytinasni> it's not; "return a" returns a from before modify succ happens.
04:18:44 <saml> am i here?
04:18:53 <saml> darn hard disk dies
04:19:31 <agapoulitsas> before??? where is that documented?
04:20:26 <Ytinasni> (whereas if i did "modify succ >>= get", it'd return the "a" from after the modify.
04:21:42 <Pistahh> @src get
04:21:42 <Ytinasni> > evalState (get >>= \a -> modify succ >> return a) 0
04:21:42 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:21:44 <lambdabot>   0
04:22:30 <Ytinasni> .... and if lambdabot would answer me, I'd show you what's happening here :(
04:23:05 <agapoulitsas> > evalState (get >>= \a -> modify succ >> get) 0
04:23:07 <lambdabot>   1
04:23:21 <agapoulitsas> Right!!! Thank you guys.
04:26:24 <hackagebot> tkhs 0.1.0.2 - Simple Presentation Utility (YusakuHashimoto)
04:36:16 <Pistahh> agentzh: btw http://en.wikibooks.org/wiki/Haskell/Understanding_monads is an excellent article to understand state monads
04:36:38 <Pistahh> s/agentzh/agapoulitsas/
04:42:32 <Philippa> MyCatVerbs: you making Anglohaskell this year, btw?
04:46:08 <MyCatVerbs> Philippa: Oooh, I've been looking forward to it. :)
04:46:30 <Philippa> go sign up!
04:46:35 <MyCatVerbs> Note that this doesn't mean that I've actually gotten around to organizing going.
04:46:36 <Philippa> especially if you want wifi, the deadline's today
04:47:51 <MyCatVerbs> Uhoh
04:47:54 <MyCatVerbs> @where Anglohaskell
04:47:55 <lambdabot> http://haskell.org/haskellwiki/AngloHaskell
04:48:37 <MyCatVerbs> Crap! A week away? I thought it was much later in August than that. =)
04:49:47 <MyCatVerbs> Philippa: "Institution"?
04:51:05 <MyCatVerbs> Philippa: I have no idea what to put in there. I'm certainly not going to AH as a representative of any organisation, except maybe the collective in my head. :)
05:00:03 <Gilly> Can I install cabal-install so that it will install the packages to /usr/local so that every user on the machine can use them?
05:01:46 <Philippa> MyCatVerbs: remind me, are you an undergrad? If so, you can still put your uni. Alternatively, N/A or a vanity domain
05:07:21 <doserj> Gilly: user-install: False in .cabal/config
05:18:14 <Gilly> doserj: Thank you. :)
05:20:50 <MyCatVerbs> Philippa: Nah, I'm out now. I've just stuck "???" in for the moment, I'll correct it to "N/A" later.
05:20:59 <MyCatVerbs> Philippa: Mental note, I need to get a vanity domain. =)
05:31:23 <poe> Pistahh: wikimedia is down for maintenance :(
05:33:41 <lilac> Philippa: i've forgotton my haskell wiki password. can you add me to the 'definites' list for AngloHaskell 09?
05:33:53 * lilac smiles sweetly
05:35:16 <Philippa> lilac: the wiki should be able to mail you your password - more important for now's wifi signups if you want to PM me details for that?
05:54:04 <sioraiocht> mutually dependent modules make me sad...
05:56:06 <Philonous> I've installed scion and the server compiles and runs without error messages, but when I try to connect via emacs I get "error in process filter: open-network-stream: make client process failed: Connection refused, :name, Scion Server, :buffer, nil, :host, 127.0.0.1, :service, 4005 " Any clues about what went wrong ?
06:08:36 <mreh> can you suggest a good paper that really explains the differences of functional vs imperative programming
06:11:40 <soupdragon> I could point to the standard reference for that but I bet there's something better
06:15:11 <mreh> actually, a good paper on type systems would be nice, java's type system seems so sucky now i've done a teeny bit of haskell
06:15:47 <soupdragon> I don't know a paper about type systems, but I know a good book
06:16:07 <soupdragon> It's called Lectures on Curry-Howard Isomorphism
06:16:16 <mreh> mmm Curry
06:16:48 <MiniCow> Am I reading the docs right? Does Data.Map require the key to be an instance of Ord?
06:17:14 <roconnor> MiniCow: yes
06:17:32 <gwern> to support the minimum/maximum functions?
06:17:35 <mreh> has anyone tried Nice here
06:17:37 <roconnor> MiniCow: keys need to be sortable in order for efficent lookup
06:18:15 <MiniCow> Is there an alternative that doesn't? I'm not storing a lot, so efficiency isn't that important.
06:18:25 <roconnor> MiniCow: association lists
06:18:35 <roconnor> [(key,value)] type
06:18:48 <roconnor> there are several function that operate on this type in the standard libraries
06:18:51 <roconnor> @type lookup
06:18:52 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:19:19 <MiniCow> Ah, cool. That's exactly what I need. Thanks
06:27:17 * edwardk waves hello
06:27:22 <edwardk> @seen bos
06:27:27 <lambdabot> I saw bos leaving #ghc, #haskell and #haskell-in-depth 8h 24m 2s ago, and .
06:31:21 <poe> (context: cabal install mkcabal, precisely when it does configure its dependency readline) What does it mean "checking for GNUreadline.framework... checking for readline... no" and then "checking for readline in -lreadline... yes" but ultimately "configure: error: readline not found, so this package cannot be built"
06:46:26 <etpace> Is it impossible to have a function that takes two functions, and returns whether they are equal or not? if so, I guess it's a reduction from the halting problem?
06:49:58 <Philonous> etpace: You can test for equal representation, but not for extensional equality, no.
06:52:10 <lilac> etpace: it depends what their domain is
06:52:22 <lilac> (iirc)
06:52:40 <etpace> ok, thanks
06:52:42 <lilac> and it depends on whether they're total
06:52:43 <lilac> :)
06:52:44 <Philonous> lilac: True, if you have function Bool -> Bool you actually can test them for equality
06:52:57 <Philonous> But not in general
06:52:58 <lilac> Philonous: i think you still need them to be total
06:53:36 <lilac> in general, you can get a strong positive but only a weak negative
06:54:00 <lilac> hmm, that's not right
06:54:09 <Philonous> The other way around, no?
06:54:24 <lilac> yes. if they're different, there exists a proof that they're different.
06:55:00 <lilac> ... unless they're different only in the sets of elements for which they're defined, perhaps
06:55:16 * lilac is too tired to think clearly :(
06:57:15 <Philonous> etpace: In practice you can use quickcheck or try to transform one representation into the other. Depending on you demands that might be good enough
06:59:03 <etpace> I was just wondering was it was written as a footnote -- i've read a little about TMs so if there was a related proof I'd have liked to read it
06:59:09 <etpace> as it*
07:02:41 <poe> Where is the config.log of a non-completing cabal install ?
07:02:46 <lilac> etpace: i vaguely recall that equality on total functions from finite lists of Bool to Bool is computable
07:03:55 <edwardk> Philonous: though you might be able to do bad things in your Bool -> Bool function in Haskell. after all, it could take your bool, start up an unsafePerformIO context in which it can catch the error, evaluate and and return whether or not the error contains an even or odd number of characters... ;)
07:04:17 <edwardk> silly language letting you distinguish bottoms
07:04:27 <Philonous> edwardk: But then it wouldn't be a function any more
07:04:27 <Cale> edwardk: That's not really Haskell proper anymore though.
07:04:40 <edwardk> cale, Philonous: I was being facetious ;)
07:11:03 <ray> instance Eq (Void -> Void) where...
07:12:21 <doserj> instance Eq (a -> Void) where _ == _ = True
07:12:37 <ray> yeah, a -> Void is better
07:12:55 <igel> what's Void?
07:13:00 <igel> Void === () ?
07:13:06 <ray> no, Void has no values
07:13:08 <ray> () has one value
07:13:13 <igel> oh
07:14:01 <doserj> () is terminal, Void is initial in Hask *ducks*
07:14:27 <igel> is void defined in prelude or sth?
07:14:53 <ray> it's defined in category-extras!
07:15:07 <Philonous> _|_ is in Void, is it not?
07:15:17 <ray> yes
07:16:09 <Berengal> _|_ is in everything
07:17:46 <edwardk> ray: lol
07:17:55 <edwardk> i should add the instances ;)
07:18:02 <ray> you should
07:18:11 <Philonous> Isn't (a -> Void) -> Void isomorphic to a?
07:18:38 <ray> edwardk: speaking of instances, i get overlapping instances in Data.Monoid.Instances
07:18:42 <edwardk> that said it does conflict with the evil option of allowing people to abuse stable names to test for function equality
07:18:50 <edwardk> ray: which ones?
07:18:55 <ray> fingertree
07:19:02 <ray> i haven't commented it out yet, there could be more
07:19:09 <edwardk> ray: yeah ross added that one when i pointed it out, i need to go back and remove mine
07:19:21 <doserj> it also overlaps with instance Eq a => Eq (Void -> a) where f == g = f undefined == g undefined
07:19:31 <lilac> Philonous: arent all inhabitants of that type existentially equivalent?
07:20:09 <edwardk> i think i'm going to split monoids into two packages. one which provides Reducer, Generator, Multiplicative, Log and Exp, and the Applicative/Monad wrappers and the other that provides the rest.
07:20:18 <edwardk> the former has almost no dependencies
07:20:38 <lilac> instance Eq Void where _ == _ = undefined?
07:20:50 <lilac> is it meaningful for that to return True?
07:20:59 <ray> there's a case to be made for it returning True
07:21:06 <ray> it probably shouldn't though
07:21:34 <Saizan> just add bangs to those _ and you're set :)
07:21:37 <Berengal> If there's no values, how can they be equal?
07:21:48 <doserj> Berengal: how can they not?
07:21:59 <Berengal> doserj: How can what?
07:22:01 <Berengal> ;)
07:22:10 <Rotaerk> rotti... someone called me that once
07:22:14 <ray> and that's why it should probably be bottom
07:22:40 <lilac> Saizan: "instance Eq Void where !_ == !_ = True" :)
07:23:05 <Saizan> right :)
07:23:12 <lilac> instance Eq Void where a == b = case a of;
07:23:32 <edwardk> lilac: cute
07:23:35 <Saizan> Philonous: forall r. (a -> r) -> r is isomorphic to a, but not that
07:24:14 <Philonous> Saizan: OK, that makes sense, thanks
07:26:21 <edwardk> lol, shapr is lurking in #kata. somehow i think he wants me to actually ship something ;)
07:29:19 <edwardk> instance Eq (a -> b) where !f == !g = unsafeDupablePerformIO $ liftM2 (==) makeStableName makeStableName
07:29:24 <edwardk> muahaha
07:31:38 <ray> what a reasonable way to do function equality
07:31:42 <Saizan> well, he founded #haskell, maybe #kata will reach 600 users in a few years :)
07:32:04 <Taejo> what is #kata
07:32:06 <Taejo> ?
07:32:08 <edwardk> instance Show (a -> b) where show !f = show $ hashStableName $ unsafeDupablePerformIO makeStableName
07:32:15 <edwardk> Taejo: a toy language of mine
07:32:41 <edwardk> which picked up a lot of energy in getting towards a releasable state at hac phi last weekend
07:32:57 <Taejo> edwardk: cool. what kind of language is it?
07:33:18 <Axman6> edwardk: got more details/somewhere people could find them?
07:33:43 <edwardk> Taejo: heh i slammed up a topic on #kata to mess with shapr: "A monoidally-parsed atypical pure lazy functional programming language, embeddable in Haskell, which leverages types and multiple inheritance for module definitions, but not for method dispatch to avoid the limitations of Hindley-Milner inference on subset types."
07:39:56 <Axman6> holy crap, i have the #2 story on reddit.com :O
07:42:03 <Cale> Axman6: number 1 apparently
07:42:07 <alinp> hi
07:42:10 <Axman6> whoot
07:42:17 <alinp> does haskell have call tail optimization?
07:42:27 <Axman6> well, #2 for me, but i've probably got more subscriptions
07:42:54 <Axman6> alinp: yep
07:42:55 <Cale> alinp: TCO doesn't mean a whole lot in terms of lazy evaluation
07:42:57 <jmcarthur_work> alinp, TCO isn't very applicable for most haskell functions
07:43:15 <Axman6> well, ghc does it i believe
07:43:32 <Cale> alinp: The simple answer is "yes, sort of", though it's really more subtle than that, because it doesn't actually use a stack in the same way that strict evaluation does
07:44:29 <alinp> I see
07:44:38 <Raevel> @type (\f g -> (>>= f) . g)
07:44:40 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => (a -> m b) -> (a1 -> m a) -> a1 -> m b
07:44:45 <alinp> $! to force evaluation may do the trick ?
07:44:59 <jmcarthur_work> alinp, what is the problem at hand?
07:45:23 <jmcarthur_work> typically instead of TCO we think about laziness and strictness
07:45:28 <Cale> alinp: If you're getting a stack overflow, it doesn't mean what it means in a strict language.
07:45:38 <alinp> want to get the sum of 999999 ints
07:46:02 <alinp> something that I can easily do in erlang for instance
07:46:08 <Jedai> alinp: You could use sum with optimization
07:46:14 <Cale> Well, the quick answer is  foldl' (+) 0
07:46:16 <jmcarthur_work> > foldl' (+) 0 [1..999999]
07:46:18 <lambdabot>   499999500000
07:46:21 <alinp> :)
07:46:24 <Jedai> alinp: or use a stricter version of sum
07:46:27 <Axman6> alinp: you probably want to define your own sum: sum' = foldl' (+) 0
07:46:31 <jmcarthur_work> or sum with optimizations
07:46:38 <Cale> But let's take a look at how foldl (+) 0 is evaluated
07:46:41 <Cale> @src foldl
07:46:42 <lambdabot> foldl f z []     = z
07:46:42 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:46:48 <Cale> foldl (+) 0 [1,2,3]
07:46:51 <Axman6> i don't know why sum is lazy
07:46:56 <Cale> -> foldl (+) (0+1) [2,3]
07:46:58 <Jedai> alinp: With optimization GHC will realize your sum should be strict
07:47:01 <Cale> -> foldl (+) ((0+1)+2) [3]
07:47:07 <Cale> -> foldl (+) (((0+1)+2)+3) []
07:47:07 <Jedai> Axman6: Because the report say so
07:47:11 <Cale> -> ((0+1)+2)+3
07:47:15 <alinp> Jedai: how can that optimizaion may be done ?
07:47:16 <Plouj> hi
07:47:16 <Axman6> the report is silly
07:47:22 <Cale> ^^ every step up to this point required no use of a stack
07:47:25 <Axman6> what's the advantage of having a strict sum?
07:47:32 <Axman6> uh, lazy even
07:47:41 <Cale> It immediately reduced a foldl to another foldl
07:47:58 <jmcarthur_work> Axman6, foldl' wasn't around at the time, IIUC
07:48:04 <Cale> Axman6: The Report assumes that the compiler will figure out strictness.
07:48:06 <Jedai> alinp: I mean when you compile with -O or -O2, GHC will realize that your sum may as well be strict and will optimize it automatically
07:48:11 <Plouj> why would I be getting this error: http://fpaste.org/paste/20485 ?
07:48:18 <Axman6> i see
07:48:30 * Axman6 is still happy he has the #1 story on reddit :D
07:48:36 <jmcarthur_work> and also, lazy sum could theoretically be useful for lazy naturals or something, although i can't think of many cases for it
07:48:38 <Cale> alinp: It's only after the foldl has finished its work that the stack is needed.
07:48:42 <alinp> oh, Jedai thanks
07:48:50 <alinp> ok guys
07:48:53 <Cale> alinp: (+) can't evaluate until both the parameters are known completely
07:48:54 <alinp> got the point
07:49:21 <alinp> the thing was that I'm doing some simple sum
07:49:36 <alinp> sum [] = 0
07:49:36 <alinp> sum (x:xs) = x + sum xs
07:49:36 <Cale> alinp: and so we push (...)+3 on the stack, and then (...)+2, and finally get to 0+1 which reduces to 1, and then 1+2 reduces to 3, and then 3+3 reduces to 6
07:49:41 <Cale> ah
07:49:49 <Taejo> jmcarthur_work: in the case of, say, [Integer], you certainly want lazy summation (since the lists might be infinite)
07:49:53 <Cale> That's more or less like a right fold
07:49:53 <alinp> and I'm calling it this way:
07:50:12 <Saizan> alinp: that really needs the stack because it's not tail recursive
07:50:13 <Jedai> alinp: Well, with this code it won't work (it's not a tail call) whatever the language
07:50:14 <alinp> sum (take 999999 [1..])
07:50:19 <jmcarthur_work> Taejo, isn't Integer a strict type anyway?
07:50:22 <Taejo> and foldl' is the wrong level of strictness even if you want strictness
07:50:27 <Taejo> jmcarthur: [Integer]
07:50:36 <Cale> sum [1..999999]
07:50:37 <alinp> Jedai: is not a tail call ?
07:50:37 <Taejo> as in power series
07:50:40 <alinp> how come ?
07:50:43 <Cale> -> 1 + sum [2..999999]
07:50:50 <Cale> -> 1 + (2 + sum [3..999999])
07:50:56 <Cale> -> 1 + (2 + (3 + sum [4..999999]))
07:51:03 <Jedai> alinp: Well the last call in your sum function is not to sum, it's to (+)
07:51:04 <jmcarthur_work> Taejo, so what would we be summing?
07:51:16 <alinp> oh crap
07:51:16 <Cale> ^^ you can see that the expression is going to get very large before any reduction can be done
07:51:16 <ray> axman6: my isp is "ARIN Allocation", apparently
07:51:17 <alinp> indeed
07:51:21 <alinp> I forgot
07:51:25 <Axman6> ray: ha
07:51:26 <Jedai> alinp: So even in a strict language (even in Erlang) you would have the problem
07:51:30 <alinp> the way of evaluation
07:51:35 <alinp> that's right
07:51:36 <Axman6> ray: you're abviously a terrorist
07:51:38 <Axman6> o*
07:51:42 <alinp> Jedai:
07:51:48 <Taejo> jmcarthur_work: lists of power series
07:51:49 <alinp> the exact way is in erlang
07:51:55 <alinp> and I don't have the problem
07:51:58 <alinp> is the last call
07:52:09 <jmcarthur_work> Taejo, so we're summing the sums of the lists?
07:52:31 <Jedai> alinp: Really ? Did you try on bigger lists ?
07:52:32 <Cale> Perhaps Erlang has a larger stack.
07:52:33 <jmcarthur_work> just a little lost on the example, is all
07:52:38 <Axman6> alinp: you sure you actually have a tail call? if it's x + f y, then + is the in the tail
07:52:40 <alinp> Jedai:
07:52:44 <alinp> test([]) -> 0;
07:52:44 <alinp> test([H|T]) ->
07:52:44 <alinp>     H + test(T).
07:52:49 <Taejo> jmcarthur_work: no, I'm summing lists of lists: sum [[1,2,3], [1,1,1]] == [2. 3. 4]
07:52:51 <alinp> this is the erlang version
07:52:51 <Cale> You could also fix the problem just by throwing a larger stack at it.
07:52:54 <Axman6> yeah, that's not a tail call
07:52:56 <hzap> some languages might not have a stack limit, so you don't overflow
07:53:00 <alinp> wt..f /
07:53:06 <alinp> oh man
07:53:09 <Jedai> alinp: the stack size can be changed (it's not very large by default, especially with GHCi)
07:53:13 <Cale> Yeah, or remove the limitation and just let the stack grow forever
07:53:41 <Cale> (though I don't think there's an RTS option for that)
07:53:44 <Jedai> alinp: Anyway, even in Erlang you shouldn't do it this way, even if it work it will be very innefficient
07:53:51 <Daimonic> @src take
07:53:51 <lambdabot> take n _      | n <= 0 =  []
07:53:51 <lambdabot> take _ []              =  []
07:53:51 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
07:53:53 <Daimonic> @src drop
07:53:53 <lambdabot> drop n xs     | n <= 0 =  xs
07:53:53 <lambdabot> drop _ []              =  []
07:53:53 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
07:54:22 <Jedai> Cale: There was a big discussion on how to do that efficiently on the cafe some times ago but I don't think any of the ideas was implemented
07:54:23 <jmcarthur_work> looks more like folding a zipWith to me
07:54:42 <Taejo> jmcarthur_work: (+) on [Integer] *is* zipWith (+)
07:54:47 <jmcarthur_work> although i could see a Monoid instance for that
07:54:57 <alinp> ok guys ...
07:54:57 <jmcarthur_work> but sum isn't defined in terms of Monoid, it's in terms of Num
07:55:01 <alinp> I got confused
07:55:03 <pikhq> alinp: The Haskell version looks a lot like zipWith (+). AKA, "sum".
07:55:05 <alinp> now is ok, thanks
07:55:14 <Cale> alinp: no problem :)
07:55:24 <jmcarthur_work> > [1,2,3] + [1,1,1]
07:55:25 <lambdabot>   No instance for (GHC.Num.Num [t])
07:55:26 <lambdabot>    arising from a use of `GHC.Num.+' at <...
07:55:56 <Taejo> jmcarthur_work: it's not a defined instance by default, but it's one that's occasionally useful to define
07:55:58 <Jedai> pikhq: ???
07:55:58 <Cale> + isn't actually defined by default on [Integer] anyway
07:56:10 <pikhq> > (+) <$> [1,2,3] <*> [1,1,1] -- Hate zipping? Need more non-determinism?
07:56:11 <lambdabot>   [2,2,2,3,3,3,4,4,4]
07:56:14 <pikhq> Jedai: ?
07:56:14 <jmcarthur_work> but theoretically, i get it
07:56:20 <Cale> You'd want to define it by extending the shorter list by 0's, not just zipWith
07:56:32 <Taejo> Cale: good point
07:56:54 <jmcarthur_work> Cale, yeah, a zip for monoids
07:56:59 <Jedai> pikhq: I don't see what zipWith (+) has to do with alinp, or did you mean to send this to someone else "alinp: The Haskell version looks a lot like zipWith (+). AKA, "sum"."
07:57:23 * Axman6 was confused too
07:57:38 <pikhq> Jedai: I may just be missing context, but it *seems* like it's just zipWith (+) there.
07:57:43 <jmcarthur_work> this is something i have had to write a few times. should probably find or make a library that has it
07:57:58 <pikhq> Of course, I may just be stupid right now; I have yet to drink my coffee.
07:58:13 <Cale> pikhq: the problem was just to sum a list of numbers
07:58:21 <Berengal> Hmmm, applicative monoids?
07:58:23 <Jedai> pikhq: alinp is trying to do sum, that is foldl (+) 0, there's no zip in there
07:58:43 <pikhq> Jedai: XD You're right.
07:58:47 <Cale> (with the qualification that the list may be very long)
07:59:19 <jmcarthur_work> Berengal, where does the applicative come in?
07:59:28 <Berengal> jmcarthur_work: zip lists
07:59:36 <Berengal> I was just thinking out loud
07:59:50 <jmcarthur_work> well, this zip would only work on Monoid a => [a], not just any [a]
08:00:51 <jmcarthur_work> it would itself make a monoid though
08:01:29 <jmcarthur_work> mempty = repeat mempty; mappend = monoidZipOrWhatever
08:02:26 <Berengal> jmcarthur_work: Indeed. It'd be like ZipList except it'd extend the lists by repeat mempty
08:02:38 <jmcarthur_work> right
08:03:14 <jmcarthur_work> oh, actually, mempty could just be [] since the mappend would extend it anyway... i wonder if there is a reasonable difference between the two
08:04:13 <alinp> Jedai: may I bother you with one more example ?
08:04:27 <alinp> should look like a tail call .. but ...
08:04:31 <Jedai> alinp: Go ahead
08:04:39 <Cynner>  http://www.lostworlds.lv/go.php?1139723800 new website game, come and play
08:04:42 <alinp> s :: Int -> [Int] -> Int
08:04:42 <alinp> s counter [] = counter
08:04:42 <alinp> s counter (x:xs) = s (counter+x) xs
08:04:54 <Jedai> We're here to help (and I may not be the one to help you this time but someone probably will)
08:05:07 <Jedai> alinp: ok, this is a tail call
08:05:11 <alinp> ok
08:05:12 <alinp> so
08:05:18 <edwardk> jmcarthur: of course there is always the Zip applicative, and an applicative wrapped around a monoid gives rise to a monoid
08:05:23 <Jedai> alinp: but, that's were lazyness change things.
08:05:31 <alinp> s [1..999999]
08:05:32 <alinp> :)
08:05:36 <Cale> s 0 [1..999]
08:05:39 <alinp> yeah
08:05:41 <alinp> with 0
08:05:46 <Cale> -> s (0+1) [2..999]
08:05:53 <Cale> -> s ((0+1)+2) [3..999]
08:05:55 <alinp> s 0 [1..999999]
08:05:57 <edwardk> jmcarthur: there is the App monoid in Data.Monoids.Applicative that could be used to get the behavior you want more or less i think
08:05:57 <alinp> try this
08:06:06 <alinp> *Test> s 0 [1..999999]
08:06:06 <alinp> *** Exception: stack overflow
08:06:10 <Cale> yeah, it's the same as what I was just reducing
08:06:10 <edwardk> er Data.Monoid.Applicative
08:06:17 <jmcarthur_work> edwardk, the length of mappended ZipLists is the minimum of the two lengths
08:06:21 * jmcarthur_work peeks at that module
08:06:23 <Jedai> alinp: The thing is that you don't need to evaluate "counter" to evaluate s as long as there's an element in the list so it doesn't
08:06:23 <Cale> alinp: let's look at what happens with a short list by hand
08:06:31 <Cale> s 0 [1,2,3]
08:06:38 <Cale> -> s (0+1) [2,3]
08:06:43 <Cale> -> s ((0+1)+2) [3]
08:06:48 <Cale> -> s (((0+1)+2)+3) []
08:06:54 <Cale> -> ((0+1)+2)+3
08:07:00 <alinp> yes
08:07:02 <Cale> Up to this point, no stack usage
08:07:04 <jmcarthur_work> edwardk, the lengths interestingly form a monoid themselves for these things :D
08:07:06 <edwardk> jmcarthur: ah, yeah, though, the unit App (Zip (repeat mempty)) -- so its close at least =)
08:07:10 <Cale> But this large expression has been built up
08:07:12 <edwardk> heh
08:07:14 <Jedai> alinp: and as Cale is showing you, at the end it has to evaluate at once an expression that will need to stack a lot of (+)....
08:07:28 <alinp> ooooooooooo kkkkkkkkkk
08:07:29 <alinp> :)
08:07:30 <Cale> and now in order to find a reducible subexpression of that, the stack will grow
08:07:35 <jmcarthur_work> aha, which makes me think that [] would be the better mempty
08:07:37 <edwardk> it does look like you'd need to just define your own monoid though
08:07:47 <alinp> so, it's about the lazy, not about the sum function design
08:07:51 <jmcarthur_work> since the length monoid here is Max
08:07:57 <edwardk> yeah
08:07:58 <Jedai> alinp: which is where the stack overflow happen (not in s, really, because of TCO s doesn't have to stay in the stack)
08:07:59 <Cale> So the solution is to force the accumulating parameter to evaluate before recursing
08:08:10 <Deewiant> Well, the advantage of this design is that you can add the strict ;-)
08:08:16 <Cale> TCO is irrelevant
08:08:27 <Cale> Because this isn't strict evaluation anymore
08:08:33 <Cale> It's outermost first (well, lazy)
08:08:36 <alinp> ok ok
08:08:58 <alinp> In conclusion, I can't use the same approach as erlang/scheme
08:09:04 <alinp> when it comes to haskell
08:09:05 <edwardk> alinp: yeah
08:09:05 <alinp> right ?
08:09:06 <Jedai> Cale: I woudn't say it's irrelevant (it still works) but it may not do exactly what you thought about it
08:09:13 <alinp> finally :)
08:09:18 <jmcarthur_work> edwardk, ah i see, Data.Monoid.App is just the Monoid from an Applicative
08:09:23 <Cale> Well, in this case, you just have to use a touch of strictness.
08:09:31 <Jedai> alinp: Well you can but then you have to put strictness annotation everywhere !
08:09:45 <alinp> btw, how this can be done ?
08:09:49 <edwardk> alinp: i wrote a bunch of nice tail call optimized code and then realized that it was better if i focused on keeping my corecursion productive than if i focused on tail call optimization, any attempt at TCO actually tends to screw you because it makes the work to get the outermost constructor often larger
08:09:52 <Cale> Jedai: uh... but the compiler isn't going to do anything explicitly which looks like tail call optimisation, because its evaluation model is so different as to make that meaningless
08:10:10 <Jedai> Cale: well yes, but it still has the same effect :)
08:10:18 <jmcarthur_work> edwardk, i'm glad to see this though. TypeCompose's (:$) type doesn't derive all the other instances for the wrapper, which limits its applicability for me
08:10:36 <jmcarthur_work> edwardk, ((:$) is the same as your App, essentially)
08:10:42 <Cale> alinp: Well, there are a few choices of syntax
08:10:47 <Jedai> Cale: but I think we shouldn't let ourselves be sidetracked here, it's not really important if it does TCO or not
08:10:57 <Cale> alinp: If you enable the BangPatterns extension, you can simply write
08:10:57 <alinp> Cale: please ...
08:11:08 <Cale> s !counter (x:xs) = s (counter+x) xs
08:11:13 <alinp> ooooo
08:11:14 <alinp> :)
08:11:18 <alinp> now I see
08:11:23 <edwardk> jmcarthur: yeah, there is a Data.Monoid.Applicative.App and Data.Monoid.Monad.Mon which does the same thing. -- and the Alt definition generates the appropriate Seminearring
08:11:28 <alinp> and there is other approach ?
08:11:30 <Cale> That is, stick a ! in front of counter. This will make counter be evaluated while pattern matching
08:11:32 <alinp> other way to do it ?
08:11:42 <Cale> Haskell includes a primitive called seq
08:11:42 <alinp> pretty straight forward
08:12:00 <edwardk> by mapping the generalized (*>) onto multiplication and (<|>) onto addition, since the right seminearring laws hold if you are a valid alternative/monadplus
08:12:06 <Berengal> s counter (x:xs) = counter `seq` s (counter + x) xs
08:12:09 <jmcarthur_work> edwardk, oh nice!
08:12:14 <Cale> Such that evaluating seq x y forces x to be evaluated (up to determining which data constructor it is) before the result of evaluating y is available.
08:12:27 <Cale> and yes, it looks just like Berengal wrote
08:12:44 <Cale> This is a little more verbose, but it doesn't require a language extension
08:12:45 <Berengal> @type seq
08:12:46 <lambdabot> forall a t. a -> t -> t
08:12:46 <edwardk> jmcarthur_work: which i make use of in my parsimony library -- if i can ever get around to shipping it
08:13:22 <vav> ?src foldl'
08:13:22 <jmcarthur_work> edwardk, what's that?
08:13:23 <lambdabot> foldl' f a []     = a
08:13:23 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:13:31 <edwardk> since parsing a seminearring result can be cheaper than keeping around the attribute for the full alternative-based result. i.e. recognition is cheaper than extracting the answer from a parser
08:13:40 <jmcarthur_work> oh parsing
08:13:54 <Berengal> alinp: You should note that 'seq a b' may be rewritten by the compiler as 'seq (seq b a) b'
08:13:54 <edwardk> jmcarthur_work: a family of monoidal parsers for lots of interesting language classes
08:14:03 <jmcarthur_work> nice name for the package
08:14:10 <edwardk> thanks =)
08:14:12 <alinp> Berengal: thanks
08:14:20 <Jedai> alinp: And then there's ($!) which is written using seq, with which you could write : s counter (x:xs) = (s $! counter + x) xs
08:14:21 <jmcarthur_work> well now i'm interested. can't wait to see it
08:14:23 <Cale> Berengal: that's a really subtle point though...
08:14:25 <Berengal> alinp: Which isn't that usefull unless you're doing parallel stuff
08:14:30 <Cale> yeah
08:15:00 <Berengal> For implicit parallelism, there's pseq, which guarantees the order of evaluation
08:15:05 <edwardk> i gave a talk on it (but mostly on monoids) at hac phi and will be giving another at the next boston haskell user group.
08:15:09 <Cale> And last, but certainly not least, you can use a strict fold
08:15:16 <edwardk> but that probably isn't local to you =)
08:15:16 <jmcarthur_work> i wish i could have made it to hac phi
08:15:19 <jmcarthur_work> i really wanted to go
08:15:22 <Cale> foldl' is a left fold which does this seq'ing for you
08:15:27 * jmcarthur_work is in huntsville, al
08:15:31 <edwardk> ah
08:15:36 <Cale> So as to keep the accumulating parameter evaluated as it goes.
08:15:45 <Cale> @src foldl
08:15:46 <lambdabot> foldl f z []     = z
08:15:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:15:48 <Cale> @src foldl'
08:15:49 <lambdabot> foldl' f a []     = a
08:15:49 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:16:08 <Cale> The second line of which could also reasonably be written:
08:16:26 <Cale> foldl' f !a (x:xs) = foldl' f (f a x) xs
08:16:30 <jmcarthur_work> edwardk, is there any video that you know of?
08:16:41 <Cale> (though that does change the order of evaluation very slightly)
08:16:43 <edwardk> jmcarthur_work: alas there was no camera
08:16:44 <Berengal> Monoids are fun
08:16:47 <Jedai> Cale: Well it doesn't do exactly the same thing though
08:16:50 <jmcarthur_work> :(
08:16:52 <edwardk> i can probably at least upload my slides though
08:16:55 <Cale> Jedai: right, but more or less
08:16:55 <Berengal> But I hate the function names...
08:16:57 <jmcarthur_work> please do
08:17:02 <jmcarthur_work> i would much appreciate it
08:17:16 <edwardk> though, what is on my slides was all about the monoids lib, i talked through the parsimony bits/performance results
08:17:22 <alinp> Cale: s !counter (x:xs) = s (counter+x) xs
08:17:27 <alinp> what is wrong with this line ?
08:17:29 <jmcarthur_work> ah
08:17:34 <Cale> alinp: nothing
08:17:42 <alinp> but it seems to be wrong :)
08:17:43 <Cale> alinp: But make sure you have the BangPatterns extension on
08:17:50 <Cale> {-# LANGUAGE BangPatterns #-}
08:17:57 <Cale> at the top of your file will do that
08:18:27 <alinp> yey
08:18:39 <alinp> yep, that did the trick
08:18:40 <alinp> thanks
08:18:49 <jmcarthur_work> @src length
08:18:50 <lambdabot> Source not found. Just try something else.
08:19:00 <jmcarthur_work> uh
08:19:05 <Cale> odd
08:19:17 <Berengal> length = sum . map (const 1)
08:19:36 <Berengal> length [1..1000000]
08:19:42 <Berengal> > length [1..1000000]
08:19:43 <lambdabot>   1000000
08:20:00 <Berengal> > sum (replicate 1000000 1)
08:20:02 <lambdabot>   * Exception: stack overflow
08:20:21 <Berengal> Well, could've been
08:21:06 <benmachine> > foldl' (+) 0 $ replicate 1000000 1
08:21:08 <lambdabot>   1000000
08:23:03 <benmachine> > foldl' (flip $ const succ) 0 $ [1..1000000]
08:23:04 <lambdabot>   1000000
08:23:23 <benmachine> > foldl' (flip . const succ) 0 [1..1000000]
08:23:25 <lambdabot>   No instance for (GHC.Num.Num ((b -> c) -> c))
08:23:25 <lambdabot>    arising from the literal `...
08:34:48 <etpace> Hmm... How does partial application work with explicit recursion? like combine [] ys = ys; combine (x:xs) ys = x:(comine xs ys); let foo = combine [1,2,3]? Does it build the "recursion tree" straight away so something like foo ys= 1:2:3:ys? or does it save it as "combine [1,2,3]" and then waits for the second argument
08:35:33 <jmcarthur_work> etpace, the latter
08:35:53 <Berengal> I think I saw some work about evaluating under lambdas...
08:36:02 <Berengal> Can't remember where
08:36:16 <jmcarthur_work> Berengal, that would not be lazy
08:36:41 <jmcarthur_work> i would love to see a language that evaluates HNF though
08:36:48 <jmcarthur_work> i think luke palmer is playing around with that
08:36:48 <etpace> is that always the case? so in a simpler example of foo x y = 2*(x + y), bar y = foo 5 y, is bar y = foo 5 y, or bar y = 2*(5 + y)?
08:37:03 <Berengal> jmcarthur_work: It would, if it didn't evaluate the resulting closure until it was called the first time
08:37:47 <jmcarthur_work> Berengal, i see what you mean
08:38:24 <Berengal> jmcarthur_work: so 'foo x y = let x' = fib x in x' + y; bar = foo 50; print (bar 10) >> print (bar 20)' would only evaluate fib 50 once. GHC evaluates it twice now
08:38:41 <jmcarthur_work> Berengal, yeah, fib is a good example for it
08:39:25 <jmcarthur_work> Berengal, i would also like to see the benefits for GC. luke palmer's blog has a cool example for that
08:40:02 <Berengal> jmcarthur_work: If i my understanding is correct, it requires runtime compilation of the closures though
08:40:07 <Berengal> Or something not too far removed from that
08:40:22 <jmcarthur_work> it's just a different evaluation order, really
08:40:28 <jmcarthur_work> but it would be a rather fundamental change
08:40:56 <jmcarthur_work> would be nice to have runtime compilation though
08:41:05 <jmcarthur_work> explicit, at the very least
08:42:06 <jmcarthur_work> compile :: (a -> b) -> (a -> b) -- heh heh
08:42:46 <Berengal> There is the garbage issue though
08:42:46 <Saizan> etpace: if you've combine written in that way then let f = combine [1,2,3] in (f xs,f ys) will traverse [1,2,3] twice
08:43:13 <Saizan> etpace: but there's a way to rewrite it so that [1,2,3] is traversed only once
08:43:31 <lilac> Berengal: 'foo x = let x' = fib x in \y -> x' + y' if you only want the fib done once in a partial application. otherwise there's a potential space leak (imagine if fib 50 is huge and you hold onto foo 50 for a long time)
08:44:16 <lilac> i think ghc sometimes lifts lets across lambdas (at least, i think i've seen it do so in ghc-core's output) but not always
08:44:17 <Saizan> yeah, what lilac says :)
08:44:34 <lilac> quite possibly it has some heuristic for determining when it's 'safe'
08:44:36 <Berengal> lilac: Yes, I've seen some blog posts about it, but I'm afraid I can't remember where
08:44:37 <deech`> Hi all, I am trying to understand how STM is implemented in GHC. What do the hash-marks in the source mean? For example atomically is implemented as 'IO (\s -> (atomically# m) s )' and atomically# is nowhere to be found.
08:44:37 <deech`>  
08:45:02 <Berengal> deech`: Usually they indicate magic
08:45:02 <Saizan> deech`: they mean those are ghc primitives
08:45:32 <Saizan> deech`: the real implementation might be in C or Cmm
08:45:51 <lilac> deech`: that's the MagicHash language extension, which essentially just allows #s in identifiers. GHC primitives all have #s in them so they can't clash with user identifiers
08:45:58 <deech`> Hmmm ... does that mean they can't be implemented in Haskell, or did they do it for efficiency reasons?
08:46:34 <Saizan> it depends on the specific one
08:47:00 <Saizan> *case
08:47:02 <deech`> I am trying to understand how STM works by re-implementing it in pure Haskell.
08:47:29 <deech`> So I was curious as to how 'atomically' keeps transactions atomic.
08:47:37 <jmcarthur_work> i certainly think it could be done. not sure how it all works though
08:47:56 <Saizan> deech`: have you read some of the papers on STM?
08:48:13 <Berengal> You can do manual memory management and peek and poke stuff, can't you?
08:48:19 <deech`> saizan, I have read the main one by Peyton-Jones
08:48:29 <Berengal> Don't need much more to be programming in C...
08:49:41 <deech`> unfortunately, with my current understanding of Haskell, the way he talks about, say the transaction log, can't be implemented in Haskell.
08:49:43 <lilac> "\s -> (atomically# m) s"? why the extra parens, i wonder
08:50:08 <deech`> At least not without TH.
08:50:13 <jmcarthur_work> i think it could be done in haskell
08:50:14 <Botje> someone afraid of the eta-monster? :)
08:50:16 <jmcarthur_work> TH?!
08:50:37 <Saizan> deech`: well, yeah, you'd need to build your own runtime system in haskell
08:50:40 <jmcarthur_work> what does TH have to do with it?
08:50:45 <Saizan> deech`: to keep track of TVars
08:51:13 <Saizan> yeah, TH doesn't seem like it'd help
08:51:34 <jmcarthur_work> TH is syntactical. if you can do it with TH, you can do it without
08:51:52 <soupdragon> that's not true
08:52:19 <deech`> jmcarthur_work, the problem is that I can't store any variable regardless of type in a transaction log.
08:52:20 <soupdragon> that's like saying if you can do it in brainfuck you can do it in haskell
08:52:21 <Saizan> depends on if what you want to do includes requirements on syntax :)
08:52:27 <lilac> it's not so bad, is it? i would think you could make a TVar be a pair of a unique ID and an IORef, and implement the transaction log in terms of the IDs
08:52:49 <jmcarthur_work> soupdragon, but you can, can't you?
08:52:51 <lilac> soupdragon: i think the point was more, you can implement a preprocessor to turn a program using TH into a program without
08:52:52 <soupdragon> no
08:52:59 <soupdragon> it's utterly not true
08:53:16 <jmcarthur_work> counterexample?
08:53:35 <monochrom> proof?
08:53:41 <Berengal> TH can do IO, which means it's not just a function
08:53:42 <jmcarthur_work> heh
08:53:58 <Saizan> soupdragon: the difference between Haskell+TH and Haskell is not comparable to the difference between Haskell and Brainfuck though
08:54:04 <jmcarthur_work> Berengal, yeah, but during the runtime of the program it makes no difference
08:54:08 <jmcarthur_work> it's just a preprocessor
08:55:22 <Cale> You could do a Brainfuck quasiquote interpreter using TH though :)
08:55:26 <Saizan> though it's true that with TH you can analyze the source and collect information that's very hard to collect with just Haskell
08:55:30 <deech`> The paper says that within a transaction every readTVar stores a snapshot of the TVar in the log, and all writeTVar's and modifyTVars modify the log.
08:56:07 <deech`> At the end of the transaction if the original TVar value has changed the transaction is retried.
08:56:46 <Saizan> deech`: you'll might need something like Dynamic to store the values using an uniform type
08:56:56 <lilac> deech`: you can store the old version in the TVar instead of in the transaction log to avoid Dynamic, i think
08:57:30 <benmachine> dudes, is there any way to make this work: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3125#a3125
08:57:30 <deech`> Yes, but a single log can only hold variables of one type.
08:57:32 <jmcarthur_work> deech`, data LogEntry = forall a . LogEntry (TVar a) a a  -- for old and new values in some TVar? (not sure what the actual entry should look like, just an example)
08:57:49 <benmachine> (as currently it says that p is not in scope before the =, which is pretty true)
08:58:04 <Saizan> deech`: that depends on how you design the log
08:58:07 <lilac> deech`: the transaction log can contain undo actions :: IO () instead of references to TVars
08:58:29 <lilac> (if you want to stay in Haskell'98 and avoid existentials)
08:58:51 * benmachine wonders if the qualification pretty can ever be applied to truth
08:58:53 <Berengal> benmachine: No, I don't think so, not for arbitrary types. Use modify instead
08:58:59 <Cale> It might be considered a bit distasteful, but since it's a low-level detail and the types have already been ensured by your API, you could just use unsafeCoerce to construct the log.
08:59:19 <jmcarthur_work> yuck, i'd rather use existentials! :P
08:59:24 <lilac> benmachine: fields in haskell are annoyingly not first-class; you can't use them like that :(
08:59:27 <Cale> Existentials?
08:59:31 <benmachine> aw, ok
08:59:39 <Cale> Of what existential type?
08:59:42 * benmachine defines three functions that are virtually identical
08:59:42 <Saizan> benmachine: see data-accessor for something like that
08:59:51 <deech`> Cale, Saizan, this is essentially the strategy that Ocaml's STM implementation takes.
08:59:56 <Cale> Dynamic won't work, because that'll create a Typeable constraint
09:00:08 <lilac> benmachine: you should be able to factor out the commonality at leat
09:00:11 <lilac> *least
09:00:18 <lilac> or some of it :)
09:00:30 <Saizan> right, and you don't need to check the types at runtime anyway
09:00:34 <benmachine> lilac: they are just that one only without p as a parameter
09:00:52 <Berengal> benmachine: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3125#a3126
09:01:05 <lilac> Cale: you don't need a type-class constraint on the existential; something like jmcarthur_work's 'forall a. LogEntry (TVar a) a a' sounds like it's enough
09:01:28 <Cale> uh, how so?
09:01:29 <deech`> jmcarthur_work, does your LogEntry type allow me to store a list of LogEntries each with a different a? So something like [LogEntry, LogEntry] where one is Int and the other is String, for example.
09:01:41 <Saizan> lilac: what are the 'a'?
09:01:44 <jmcarthur_work> deech`, yes
09:01:49 <Cale> lilac: I'm not sure I can see that working at all.
09:02:14 <Cale> deech`: It does, but the types are forever obscured, and you won't be able to use the values.
09:02:15 <jmcarthur_work> it's enough to commit or roll back
09:02:18 <lilac> Saizan, Cale: that's the type of the TVar. you don't need /any/ properties from that type.
09:02:29 <lilac> (other than assignment, which is provided for all types :: *)
09:02:36 <jmcarthur_work> you don't need the types for a transaction log, though, do you?
09:02:44 <Saizan> lilac: i mean, why do you have two fields of type 'a' in that constructor?
09:02:45 <Cale> lilac: You do though. You need to be able to unify the type with the exact type that it was when you readTVar
09:03:06 <jmcarthur_work> Saizan, i only put two because i don't know whether there is an extra "commit" step or not, or whatever
09:03:06 <benmachine> Berengal: handy, thanks
09:03:11 <lilac> Cale: why would readTVal touch that value?
09:03:12 <jmcarthur_work> i guess it it still doesn't need two
09:03:21 <jmcarthur_work> whatever, the important part was the forall
09:03:22 <Saizan> jmcarthur_work: but what were you going to do with them?
09:03:47 <Cale> lilac: readTVar looks in the existing transaction log for the variable in question, and reads it from there if it exists.
09:03:59 <jmcarthur_work> Saizan, the a would for rolling back. just stick it in the TVar. we know the TVar holds the same type, which is enough information
09:04:04 <etpace> combine [] = id; combine (x:xs) = make_cons x (combine xs); make_cons x f = (\ys -> x:(f ys)); <- I saw this (admittedly in another language) and I just feel a little.. wierd with it. I can see why it works, but is there a reason it's written in that way rather than the simpler combine (x:xs) ys = x:(combine ys)?
09:04:06 <lilac> Cale: semantically yes, but it doesn't need to be implemented that way
09:04:22 <Cale> Well, just try to make this work. I will be surprised if you manage :)
09:04:38 <lilac> Cale: you can just write the values to the TVar directly, and retry if you try to write to something which is already-written but not committed
09:04:45 <Cale> (without unsafeCoercing that existential type anywhere)
09:05:04 <lilac> (indeed i vaguely recall reading that that's what the GHC implementation does)
09:05:17 <jmcarthur_work> i still don't see where you will ever need to extract the value directly from the transaction log
09:05:24 <jmcarthur_work> maybe i should read the paper
09:05:39 <Saizan> etpace: it might be to make partial application actually reduce the first list without waiting for the second one
09:05:43 <Cale> At the very least, you'll need to extract the value from the transaction log when you go to commit.
09:05:45 <lysgaard> Someone good at MonadTransformers here? I have this snippet from my code that produces an error i don't understand: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7780#a7780
09:05:59 <lilac> Cale: you don't need it to unify with anything external then, though
09:06:10 <etpace> what do you mean Saizan?
09:06:11 <jmcarthur_work> Cale, if you are committing to the TVar which is already referenced in the transaction log then the types are already known to be the same
09:06:13 <Cale> So it can't be exists a. a, because there's nothing you can do with a value of that type.
09:06:40 <lilac> Cale: you have a "TVar a" and an "a", for the same a. what's the problem here?
09:06:52 <jmcarthur_work> to reiterate:  data LogEntry = forall a . LogEntry (TVar a) a
09:06:58 <Saizan> Cale: i think the unsafeCoerce is just hidden inside the IORef or STRef you're going to use to implement TVar
09:07:02 <jmcarthur_work> there is both an a and a TVar a there
09:07:23 <Cale> Saizan: hmm
09:07:25 <benmachine> lysgaard: I can't guarantee it'll help, but typesig everything, usually it makes debugging easier
09:07:31 <benmachine> (not to mention reading your code)
09:08:16 <lysgaard> benmachine: Hehe, the problem is that i don't understand MonadTransformers very well yet, so i don't know what the types should be.. =/
09:08:32 <benmachine> ah
09:08:33 <Saizan> etpace: i mean that with that version of combine if you write something like let f = combine longlist and start using f in multiple places, longlist will be traversed by combine only once, instead of once for every application of f
09:08:38 <Cale> Okay, so suppose that I'm doing something like  atomically (writeTVar t 0 >> readTVar t)
09:08:57 <Saizan> lysgaard: can you annotate with the error?
09:09:19 <lysgaard> Saizan: ofc, just a sec.
09:09:19 <Cale> The writeTVar t 0 presumably adds LogEntry t 0 to the transaction log
09:09:23 <Saizan> etpace: i'd have to test if that formulation has that property, but it seems written with that aim
09:09:34 <Cale> and then readTVar t needs to get at that 0
09:09:42 <Cale> What happens?
09:09:52 <lilac> Cale: as i said, writeTVar can write to the TVar.
09:09:58 <deech`> Cale, I'm not sure that is allowed unless 't' was previously assigned.
09:10:05 <jmcarthur_work> Cale, the log entry has the *old* value
09:10:07 <lilac> then readTVar reads the TVar and doesn't read the log
09:10:16 <lysgaard> Saizan: it's is a revision on the paste now
09:10:18 <jmcarthur_work> deech`, you are mixing up with MVars ;)
09:10:20 <deech`> So your example is a nested transaction?
09:10:27 <Cale> Oh, you're doing optimistic writes? That's backwards from what GHC does...
09:10:38 <lilac> Cale: i'm saying it's one possible implementation
09:10:39 <etpace> that's true Saizan, it builds up combine by what seems to be something like 'nested lambdas' and passed the new list all the way to the center, where its passed to id
09:10:46 <Cale> okay, so let's see...
09:10:50 <etpace> it just made me feel a bit uncomfortable!
09:10:51 <jmcarthur_work> i'm not sure how ghc does it, or whether deech`'s goal is to do it the exact same way
09:11:03 <Saizan> lysgaard: you forgot to liftIO (putStrLn (show replyM))
09:11:18 <lilac> Cale: if you prefer, we can store the old data as a map inside an IORef inside the TVar
09:11:26 <Cale> How do you detect that no other transaction has interfered with the variable since your transaction started running?
09:11:29 <lilac> Cale: and do deferred writes
09:11:43 <Cale> Or are you just locking the whole world for each transaction?
09:11:43 <jmcarthur_work> Cale, the writes needn't be strictly optimistic, either. the TVars can be annotated with transaction ids upon read and write so that other threads know whether they should stop immediately
09:12:00 <lilac> Cale: if you're doing optimistic writes, and you try to write or read a written-but-not-committted TVar, you retry
09:12:12 <lilac> (that is, written by another transaction)
09:12:14 <Cale> lilac: okay
09:12:22 <deech`> jmcarthur_work, I want to understand STM as an idea. I'm not really worried about doing things the same as GHC. I am not worried about efficiency either, mostly clarity.
09:12:26 <lysgaard> Saizan: Ah, so it's so simple. I've got to say that the error message is quite cryptic for me. I'm in the process of learning MonadTransformers and everything is quite messy right now
09:12:31 <lilac> Cale: actually, i'm not sure you're still guaranteed to make progress that way
09:13:03 <lilac> Cale: i /think/ you are, but i'm worried about atomic block 1: write a, write b, atomic block 2: write b, write a
09:13:18 <Cale> deech`: If you want to understand STM as an idea, it's best not to concern yourself with implementation details like this at all.
09:13:48 <Saizan> lysgaard: the error message is saying that you're using an action of type IO Something and an action of type MonadState NodeState m => m SomethingElse in the same do-block
09:13:50 <lilac> if you have a global lock for each operation, i think you can probably get a working implementation out of it (but obviously not a /good/ one) :)
09:14:06 <Saizan> lysgaard: at that point it has to unify 'm' and IO
09:14:20 <Cale> lilac: Right, there's an interleaving where those two make no progress, but probabilistically it's unlikely to go on forever.
09:14:34 <Saizan> lysgaard: so it nees to find an instance for MonadState NodeState IO, but there's not such instance
09:14:45 <jmcarthur_work> lilac, if either block rolls back then it doesn't have to run again until the other block makes another change
09:18:07 <jmcarthur_work> well, i guess if *both* roll back...
09:18:07 <Saizan> lysgaard: MonadState is what provides get and put, btw
09:18:07 <Saizan> lysgaard: how familiar are you with typeclasses?
09:18:07 <Cale> jmcarthur_work: Right, the idea is that both of them roll back, and then either they're both stuck, or they both retry, in which case they might do the same thing again
09:18:07 <lysgaard> Saizan: Yeah, I've made my own instances of eg binary and so on
09:18:07 <jmcarthur_work> i learned some about transactions in databases a few years back. they actually go so far as *scheduling* transactions to avoid predictable conflicts. i wonder if such a scheme would be at all feasible/useful for a general programming language like haskell?
09:18:07 <jmcarthur_work> scheduling individual pieces of transactions, even, i mean
09:18:07 <jmcarthur_work> like "i can do this part in block a before this part in block b without messing up block b, but if i let this part of block b happen first then it will mess up block a" etc.
09:18:09 <lysgaard> Saizan: I see that liftIO sorta wraps an IO (a) in a monad m so it becomse m (IO (a)) Am i correct?
09:18:19 <Saizan> lysgaard: no
09:18:26 <Saizan> ?type liftIO
09:18:28 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
09:18:58 <Saizan> lysgaard: liftIO gives you back an action of type MonadIO m => m a,
09:19:19 <lysgaard> Saizan: Oh, i was using lift it worked too :S
09:19:23 <lysgaard> ?type lift
09:19:25 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:19:44 <Saizan> lift wraps in a transformer yea
09:19:54 <jmcarthur_work> for monad transformers, the result would look like (t m a), not t (m a), and of course this type doesn't even apply if t has kind * -> *
09:19:59 <lysgaard> Saizan: But they are not the same?
09:20:00 <Saizan> lysgaard: but it becomes t IO a, not t (IO a)
09:20:06 <jmcarthur_work> oh i mixed things up
09:20:10 <jmcarthur_work> liftIO and lift
09:20:34 <Saizan> lysgaard: in your case they do exactly the same thing at the value level, but their types are different
09:20:45 <lysgaard> Saizan: Ah, i messed it up.
09:20:53 <lilac> Cale, jmcarthur_work: yeah, you've got to guarantee that you only roll back one of them (which requires a global lock on writes to TVars i think)
09:21:18 <lysgaard> Saizan: But how can both liftIO and lift work the same way, but have different type sigs..
09:21:53 <Saizan> lysgaard: the result types are different but compatible
09:22:13 <monochrom> They don't work the "same"...
09:22:31 <lysgaard> What is the difference then?
09:22:37 <Saizan> lysgaard: MonadTrans t, Monad m => t m a, vs. Monad m1 => m1 a
09:22:47 <lilac> lysgaard: lift lifts things up 1 level in the monad transformer stack. liftIO lifts to IO (which might not be in the stack)
09:22:56 <Saizan> lysgaard: if you use them in the same do-block you'd get m1 = t m
09:22:58 <lilac> if IO is in the stack, it has to be at the top, since an IOT can't exist
09:23:00 <monochrom> lift assumes MonadTrans and liftIO assumes MonadIO?
09:23:35 <Saizan> well, same do block and with only one transformer
09:23:50 <Saizan> like in your case
09:24:18 <lilac> lysgaard: if you have FooT (BarT (BazT IO)) a, then lift will take BarT (BazT (IO)) a -> FooT (BarT (BazT IO)) a, and liftIO will take IO a -> FooT (BarT (BazT IO)) a
09:24:50 <lilac> in that case, liftIO = lift . lift . lift
09:24:53 <etpace> if I have something like f=(\x1 -> 1+(\x2 -> 1+(\x3 -> 1+x3) x2) x1), does the compiler have to walk through all the lambdas each time f is called, or does it flatten it to f = (\x -> 1+1+1+x)
09:25:16 <benmachine> guys does this make sense: (\s@~(x:xs) -> if null s then s else xs)
09:25:49 <benmachine> (I just realised it's unnecessary, but I'd be interested in the answer anyway)
09:25:50 <monochrom> It makes sense but self-defeating.
09:25:52 <lilac> etpace: i'm pretty sure it'll beta-reduce it down to f x = 1 + 1 + 1 + x
09:26:32 <etpace> is that common place in other languages as well, like sml?
09:26:54 <benmachine> monochrom: you mean, if null s then the pattern will fail, even though neither x nor xs are used?
09:27:31 <monochrom> "if null s" destroys the laziness created by ~ immediately.
09:28:01 <soupdragon> etpace, I suppose we could (attempt) to find out by using  trace  and interpreting the results
09:28:11 <monochrom> "null s" does its own (_:_) strict pattern matching.
09:28:37 <lysgaard> lilac: Hm.. So liftIO can lift "all the way" into the IO monad, but lift only takes one monad at a time. I know i sound very unshure here, but I am :S
09:28:51 <benmachine> monochrom: what would happen if (\s@(x:xs) -> if null s then s else xs) was given []?
09:29:33 <benmachine> my expectation is that it'd be upset because @(x:xs) didn't match
09:29:40 <monochrom> Ha, cunning.
09:29:51 <jfredett> > let f s@(x:xs) = if null s then s else xs in f []
09:29:53 <lambdabot>   * Exception: <interactive>:1:137-173: Non-exhaustive patterns in function f
09:29:58 <monochrom> I only looked at strictness. I forgot to look at answers.
09:30:03 <benmachine> oic
09:30:10 <jfredett> benmachine: apparently that.
09:30:18 <benmachine> > let f s@~(x:xs) = if null s then s else xs in f []
09:30:19 <lambdabot>   <no location info>: Parse error in pattern
09:30:22 <benmachine> :(
09:30:34 <benmachine> > let f ~s@(x:xs) = if null s then s else xs in f []
09:30:36 <lambdabot>   * Exception: <interactive>:1:137-174: Irrefutable pattern failed for patter...
09:30:39 <monochrom> try s@(~(x:xs))
09:30:50 <jfredett> hmm, apparently patterns are not lazy unless forced to be.
09:30:52 <jfredett> interesting
09:30:53 <benmachine> > let f s@(~(x:xs)) = if null s then s else xs in f []
09:30:54 <lambdabot>   []
09:31:00 <jfredett> there it is.
09:31:03 <benmachine> :D
09:31:35 * benmachine is almost tempted to use that instead of the far clearer 'tail s' just so that he won't forget the trick
09:32:05 <Saizan> lysgaard: you're mostly right
09:32:52 <Saizan> lysgaard: except that lift only goes through one _transformer_ at a time, which is not the same as a monad
09:33:06 <jfredett> benmachine: thats probably a better option, I think it'd be more clear to do `if null s then s else tail s`
09:33:07 <Saizan> lysgaard: a transformer is something that given a monad returns a monad
09:33:26 <Saizan> lysgaard: like "StateT s" is
09:33:42 <monochrom> > tail []
09:33:48 <gonzales5> please help me
09:33:49 <gonzales5> visual basic
09:33:49 <lambdabot>   * Exception: Prelude.tail: empty list
09:33:52 <gonzales5> 6.0
09:33:56 <Philonous> leksah crashes with the complaint that since ghc 6.10.2 finalizers are not allowed to call back into haskell. A mailing list entry suggested it is a problem with gtk2hs, but I can't seem to find the corresponding bug report or any other hint on the gtk2hs site. Is this fixed with gtk2hs 0.10.1 or maybe the darcs version?
09:33:56 <gonzales5> please
09:33:59 <benmachine> visual basic? ewwww
09:34:06 <Cale> gonzales5: This is #haskell
09:34:08 <gonzales5> please
09:34:09 <jfredett> gonzales5: we're haskell here, sorry.
09:34:12 * benmachine has nothing to do with basic ever
09:34:15 <michaelfeathers> quesiton: is it typical to put QuickCheck properties in the same file as the code they test?
09:34:18 <monochrom> Wrong channel, gonzales5. This channel doesn't do visual basic.
09:34:20 <gonzales5> what does it mean?
09:34:21 <jfredett> gonzales5: is there a #vb6 channel?
09:34:30 <Cale> gonzales5: Haskell is a pure functional programming language
09:34:38 <gonzales5> thank you guys
09:34:41 <jfredett> michaelfeathers: i generally do testing in a separate file.
09:35:05 <michaelfeathers> jfredett: thanks
09:35:37 <jfredett> michaelfeathers: separation of concerns or whatever, makes it easier to know what you've tested and stuff
09:35:58 <lysgaard> benmachine: "visual basic? ewww" hehe
09:36:28 <lysgaard> benmachine: That was harsh
09:36:58 <joga> but justified? ;)
09:37:09 <jfredett> lysgaard: vb6 is ew... vb in general makes me a little queasy.
09:37:37 <michaelfeathers> jfredett: Yeah, was just re-reading the original QuickCheck paper and it gave that as a recommendation but I haven't seen that style.
09:37:59 <jfredett> michaelfeathers: I've heard good things about the test-framework package (on hackage) too.
09:38:23 <michaelfeathers> jfredett: Thanks.  I'll take a look.  Does anyone actually use HUnit?
09:38:55 <Berengal> Sometimes I wish we could solve the halting problem just so I didn't have to write tests...
09:39:10 <jfredett> michaelfeathers: I've used it, it's nice, but you really only need it for stateful stuff- most of the time you should be writing functions, which are better quickchecked
09:39:32 <jfredett> a unit test is -- imo -- intended to test that the state is changed in the expected way
09:39:38 <sm> michaelfeathers: some related discussion at http://koweycode.blogspot.com/2009/07/some-ideas-for-practical-quickcheck.html
09:39:47 <sm> I use HUnit
09:39:58 <jfredett> quickcheck is intended to ensure that a general identity/property of a function holds for all cases.
09:39:59 <tingi> i know the number of minimum chains in a poset and the chains themselves. How do i find the members of largest antichain ?
09:40:25 <jfredett> in a nutshell, HUnit is for IO or State Monad stuff, Quickcheck is for everything else.
09:41:02 <Saizan> jfredett: you should make properties for State too :P
09:41:18 * sm uses hunit for functional stuff too, it's easier to understand
09:42:30 <jfredett> Saizan: sure, i suppose, i don't know, I wish I lived in Soviet Russia, where Code Tests You!
09:43:22 <monochrom> For the most part, computers solve a large fraction of the halting problem than humans do.
09:43:24 <jfredett> sm: what about QC don't you understand? I found it very straightforward, SmallCheck even more so.
09:43:29 <monochrom> s/large/larger/
09:44:02 <sm> jfredett: just one more thing to learn, I try to economise. I haven't needed to dive in yet
09:44:50 <jfredett> sm: QC is _well_ worth the trouble, it's a very nice way to do testing.
09:46:48 * dolio even uses QC for his library that's about 90% ST stuff.
09:47:12 <jfredett> well then, use HUnit for IO and State, and QC for everything.
09:47:15 <SamB> lazy smallcheck and chasing bottoms are pretty nice too, IMO
09:47:17 <jfredett> problem solved. :)
09:47:18 <dolio> Actually, more than 90%, probably.
09:47:33 <jfredett> SC makes me happy.
09:48:29 <SamB> it'd be nice if we could make a more unified properties interface, though ;-)
09:48:55 <dolio> I suppose the fact that all my ST stuff can be checked in terms of non-ST stuff is kind of cheating, though. :)
09:49:14 <dolio> Or is it...
09:50:32 <Cynner>  http://www.lostworlds.lv/go.php?1139723800 New Website game,Come registrer and play.
09:51:05 <lilac> oh yes please can i go to the spam site? i'd love to support spammers by looking at their ads!
09:51:12 <soupdragon> yeah I'd love to play your awsome game
09:51:35 <lilac> unfortunately i hit a type error on the word registrer. maybe next time
09:51:38 <roconnor> it's written in Haskell!
09:54:04 <lysgaard> YAY! I made it! I got the function with the Monad transformers to work! :D Thanks for the help everybody
09:54:43 <lysgaard> I think i understood some of the consept too =)
09:55:32 <kyagrd> Is Benedikt Huber here?
09:59:29 <dons> kyagrd: beschmi
09:59:36 <dons> oh, no. that's benedickt schmidt.
09:59:57 <kyagrd> I'm looking for the author of http://www.sivity.net/projects/smt-yices/
10:01:24 <dons> kyagrd: oh, btw, people at Galois were impressed by your yices binding. good work!
10:01:53 <kyagrd> Thanks, it was needed for my intern work here.
10:02:05 <Cale> preflex: seen visq
10:02:05 <preflex>  Sorry, I haven't seen visq
10:02:19 <jeffersonheard> can this be made faster?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7783#a7783
10:23:41 <lilac> jeffersonheard: umm, you could probably compute the next greater power of 2 faster but other than that i'm out of my depth :)
10:24:32 <jeffersonheard> bleh
10:24:34 <jeffersonheard> alright
10:24:38 <jeffersonheard> thanks lilac
10:38:06 <lars9> :t =?
10:38:08 <lambdabot> parse error on input `=?'
10:38:27 <enolan> :t (=?)
10:38:29 <lambdabot> Not in scope: `=?'
10:38:43 <lars9> =? appears in XMonad's config file
10:38:52 <enolan> I have no idea what it does.
10:38:52 <lars9> className =? "Gimp"            --> doFloat
10:39:07 <lars9> seems like string matching
10:39:14 <vav> (=?) :: (Eq a) => Query a -> a -> Query Boo
10:39:50 <Cale> lars9: It's probably an operator defined by XMonad itself
10:39:58 <lars9> vav: hey do you know it?
10:40:06 <lars9> Cale: i see, thanks
10:40:19 <vav> lars9: sure, come on over to #xmonad
10:40:19 <Cale> http://hackage.haskell.org/packages/archive/xmonad/0.8.1/doc/html/XMonad-ManageHook.html#v%3A%3D%3F
10:40:28 <lars9> vav: ok
10:43:02 <Cale> lars9: Basically, it executes the className query, and if that's "Gimp" then the result is True, and --> will then cause the ManageHook called doFloat to happen.
10:46:57 <Cale> (well, really it just turns it into another ManageHook which only happens when that's true, I guess)
10:48:28 <vav> yeah Query is scary -- newtype Query a = Query (Control.Monad.Reader.ReaderT Window X a)
10:49:30 <Cale> Well, not that scary. That just means that it's a monad which has implicit access to information about some Window, as well as the ability to do anything that the X monad can.
10:51:41 <vav> I've been slowly working on joining lysgaard's battle against the Decepticons, but still get lost unraveling Transformers
10:52:15 <Cale> :)
10:53:28 <Cale> Basically, you can think of it like Query a = Window -> X a, if that helps at all
10:53:53 <Cale> That's how the ReaderT transformer implements it anyway
10:56:23 <vav> ok, that's how I've fuzzily thought of it, as having a Window parameterized, had not gotten the X() vs X a distinction, will have to look for that.
10:57:35 <defun> Hi. How do I take a string containing digits and convert those digits into a number (Integer, Float, etc.)?
10:58:17 <benmachine> > read "34" :: Int
10:58:19 <lambdabot>   34
10:58:30 <vav> Cale: and ManageHook = Query (Endo WindowSet) just means manage hooks are WindowSet -> WindowSet making use of the Window?
10:58:34 <defun> > read "34.4" :: Float
10:58:36 <lambdabot>   34.4
10:58:43 <defun> awesome...
10:58:53 <benmachine> defun: the easiest way is read, but it's a little inflexible - you can also use reads if you want to catch errors or you have other stuff in the string
10:59:12 <benmachine> > reads "    14k" :: [(Int, String)]
10:59:14 <lambdabot>   [(14,"k")]
10:59:31 <benmachine> > reads " 3   blah" :: [(Int, String)]
10:59:33 <lambdabot>   [(3,"   blah")]
10:59:34 <ski> > (reads :: ReadS Int) "    14k"
10:59:36 <lambdabot>   [(14,"k")]
10:59:42 <benmachine> > reads "blah" :: [(Int, String)]
10:59:43 <lambdabot>   []
11:00:29 <ski> nicer to use `ReadS' if you need an explicit type ascription, imo
11:00:47 <benmachine> ski: it is indeed
11:01:25 <Petrosian> Why does reads return a list?
11:01:31 <rhapsodyv> 
11:01:33 <Petrosian> When is there ever more than a single element?
11:01:40 <Cale> vav: and possibly doing other stuff with X
11:01:52 <Cale> Petrosian: well, if the parse is ambiguous
11:02:05 <Cale> Petrosian: It doesn't generally happen with the Prelude types
11:02:05 <Petrosian> Cale: Got an example?
11:02:06 <Saizan> Petrosian: String -> [(a,String)] is kind of the simplest parsing monad
11:02:20 <Petrosian> Fair enough
11:02:48 <Saizan> and intermediate steps while parsing a value might be ambiguous
11:03:14 <Saizan> even if the parser associated with reads generally isn't
11:09:03 <soupdragon> <3 String -> [(a,String)]
11:10:35 <athos> soupdragon: everyone loves the state monad!
11:10:51 <soupdragon> that's not state ..?
11:10:58 <athos> yeah, you're right :)
11:11:10 <athos> but almost ;-)
11:11:36 <soupdragon> @src Stats
11:11:36 <lambdabot> Source not found.
11:11:37 <soupdragon> @src State
11:11:38 <lambdabot> Source not found. :(
11:11:41 <soupdragon> :(
11:11:47 <athos> , src 'State
11:11:48 <lunabot>  luna: Not in scope: data constructor `State'
11:11:49 <athos> , src ''State
11:11:53 <lunabot>  newtype State i a = S' {unS :: (StateT i Id a)}
11:12:01 <soupdragon> -_- helpful lol
11:12:16 <athos> it is, yeah.
11:12:28 <soupdragon> I think it's  a -> (s, a)
11:12:30 <soupdragon> dunno
11:12:45 <athos> no
11:12:49 <athos> it's s -> (a, s)
11:13:00 <soupdragon> ahh
11:13:04 <soupdragon> that makes sens
11:13:06 <athos> that's at least the canonical definition :-)
11:13:23 <athos> you can of course use a -> (s, a), but s for "state" makes more sense
11:13:38 <soupdragon> a -> (s, a)  is just nonsens
11:13:56 <athos> no it's not
11:14:15 <athos> a -> (s, a) is the same as s -> (a, s)
11:14:43 <athos> but the latter makes more sense because you can associate s with state
11:14:44 <athos> :)
11:15:24 <Cale> s -> (s, a) is better than s -> (a, s) though.
11:15:36 <Cale> Because (,) s is a Functor.
11:16:15 <Cale> (whereas we can't write the other instance without type-lambda, and it would be ambiguous in general even if we could)
11:16:47 <athos> well, we're talking about a -> (s, a) and s -> (a, s), and i think both are the same :)
11:17:17 <athos> but it didn't know about that s -> (s, a) thing though, interesting
11:17:23 <jmcarthur_work> (->) s :. (,) s
11:17:26 <jmcarthur_work> best!
11:17:30 <athos> hehe
11:17:31 <seydar> greetings all
11:17:51 <Cale> Well, the first is State s a and the second is State a s, but that gets the convention wrong.
11:17:53 <seydar> i'm reading http://users.aber.ac.uk/afc/stricthaskell.html, but I still don't understand why laziness can be bad for the heap
11:18:07 <seydar> can someone fix that?
11:18:19 <Cale> seydar: The person who wrote that is a bit crazy about making things strict.
11:18:54 <Cale> seydar: But it's possible for large expressions to build up on the heap and strictness can help with that.
11:18:56 <athos> Cale: i don't see how s -> (a, s) and a -> (s, a) are different
11:19:09 <Cale> athos: a and s are swapped
11:19:15 <athos> yeah.
11:19:29 <Cale> athos: If you defined  State s a = S (a -> (s,a)) you wouldn't be able to write the Monad instance.
11:19:35 <athos> but i can just define my own state monad with a and s swapped, and the behaviour is jsut the same
11:19:50 <jmcarthur_work> athos, proof?
11:20:02 <Cale> It would have to be State a s, but then you're just talking about alpha conversion, which is obvious
11:20:04 <seydar> ok, i figured it out
11:20:06 <athos> Cale: if i'd swap those to i'd just write State a s
11:20:12 <athos> yeah
11:20:33 <seydar> I seemed to have forgotten that when haskell works from the outside in, it REALLY works from the outside in, so f x is never ever ever guaranteed to be run
11:20:36 <jmcarthur_work> right, so they are different. you had to change the lhs to make them the same
11:20:41 <athos> that was my idea. but what i really did not know is the fact that swapping and keeping it State s a would screw everything up
11:21:05 <jmcarthur_work> seydar, main = print (f x) -- f x is guaranteed to run
11:21:25 <seydar> jmcarthur_work: ok well nyah not my point
11:21:38 <ski> @unmtl StateT s [] a
11:21:38 <lambdabot> s -> [(a, s)]
11:21:54 <seydar> I ALSO forget that the GC runs super fast and super much
11:22:02 <seydar> s/forget/forgot
11:22:12 <soupdragon> ah clever ski
11:22:31 <ski> (Cale : yes .. also, i think `(s,) --| (s ->)' makes more sense than `(,s) --| (s ->)')
11:25:06 <Cale> seydar: Yeah, GHC's GC is basically optimised to take care of tons of short-lived small garbage.
11:26:06 <seydar> Cale: which is why making things strict helps at all, right? because the GC never lets the heap grow very big
11:26:07 <seydar> ?
11:26:10 <Cale> Because there are lots of lists and other data structures about for which maybe only one cell is alive at a time.
11:26:35 <fnord123> Hi all. Gtk2hs/cairo question: Are there conversion methods between Pixbuf and Pixmap? Or is this a place to use the dreaded unsafeCoerce?
11:26:37 <Cale> Well, making things strict is more about ensuring that unevaluated expressions don't hang around for a long time
11:26:38 <soupdragon> seydar, no
11:26:52 <soupdragon> being strict there can still be lots on the heap for GC
11:26:52 <Cale> (when you know that later on you will definitely evaluate them)
11:27:06 <Cale> Consider something like foldl (+) 0 [1..4]
11:27:17 <Cale> -> foldl (+) (0+1) [2..4]
11:27:23 <Cale> -> foldl (+) ((0+1)+2) [3..4]
11:27:29 <Cale> -> foldl (+) (((0+1)+2)+3) [4..4]
11:27:36 <Cale> -> foldl (+) ((((0+1)+2)+3)+4) []
11:27:40 <seydar> soupdragon: if i changed heap to unreferenced stuff on the heap, would I be right?
11:27:42 <Cale> -> (((0+1)+2)+3)+4
11:27:44 <Saizan_> both too strict and too lazy can be bad for the heap, even if all the values are going to be needed
11:27:55 <soupdragon> I don't think so
11:28:25 <Cale> seydar: that expression (((0+1)+2)+3)+4 gets built up on the heap, and then later ends up causing the stack to pile up (while the evaluator digs for the 0+1)
11:28:28 <fnord123> > foldr (+) [1..4]
11:28:30 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
11:28:30 <lambdabot>    arising from a us...
11:28:34 <Saizan_> if you're too strict you can change a program that basically does stream processing, to one that allocates the whole data at once
11:28:44 <fnord123> > foldr (+) 0 [1..4]
11:28:46 <lambdabot>   10
11:29:06 <Cale> seydar: So making the foldl into a strict one will force the evaluation to happen on each step before recursing
11:29:18 <Cale> foldl' (+) 0 [1..4]
11:29:35 <Cale> -> let y = 0 + 1 in y `seq` foldl' (+) y [2..4]
11:29:37 <seydar> @src fold'
11:29:38 <lambdabot> Source not found.
11:29:42 <Cale> -> foldl' (+) 1 [2..4]
11:29:45 <seydar> @src foldl'
11:29:46 <lambdabot> foldl' f a []     = a
11:29:46 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:29:54 <Cale> -> let y = 1 + 2 in foldl' (+) y [2..4]
11:30:03 <Cale> er
11:30:06 <Cale> -> let y = 1 + 2 in y `seq` foldl' (+) y [2..4]
11:30:41 <Cale> er, also forgot to tail the list :)
11:30:48 <Cale> -> let y = 1 + 2 in y `seq` foldl' (+) y [3..4] -- there, this is right now ;)
11:31:04 <seydar> I see now
11:31:13 <Cale> So basically, it ensures that the expression never gets very large
11:31:20 <Cale> and keeps the heap small
11:32:50 <seydar> so here's what i'm worried about now: looking at your hGetContents' on that link i pasted, wouldn't it perform a lot slower since it has to be called for every single character?
11:34:42 <Cale> seydar: Maybe. See Simon's version.
11:35:05 <Cale> seydar: However, these days if I want strict hGetContents, I just use strict ByteStrings
11:35:54 <seydar> Cale: sheesh, it looks like he sold his first born for his revision
11:36:13 <seydar> is it normal to cal out to c?
11:36:21 <soupdragon> no
11:36:37 <Cale> seydar: It's all pretty irrelevant now anyway
11:36:43 <Cale> seydar: That page is really old
11:37:03 <seydar> wait, how is it irrelevant?
11:37:11 <Cale> seydar: These days, you'd just use Data.ByteString.hGetContents
11:37:21 <Cale> Or Data.ByteString.Char8.hGetContents
11:37:30 <seydar> ByteStrings are strict?
11:37:38 <Cale> apart from the lazy ones, yes
11:37:52 <Cale> There are strict bytestrings and lazy bytestrings.
11:38:05 <Cale> The lazy bytestrings are in Data.ByteString.Lazy(.*)
11:38:25 <seydar> i see bytestrings getting used a lot. Is there ever a time when i would want just plain strings?
11:38:38 <Cale> plain strings are convenient because they're also lists.
11:38:52 <jmcarthur_work> depends on the kind of performance characteristics you need
11:39:03 <seydar> bytestrings are arrays?
11:39:18 <dons> yes
11:39:18 <Cale> bytestrings are directly allocated chunks of memory, yeah
11:39:46 <seydar> except for lazy bytestrings, which are...
11:39:59 <Cale> Lazy bytestrings are lists of approximately-cache-sized strict bytestrings
11:40:17 <seydar> approximately-cache-sized?
11:40:41 <seydar> what does that mean?
11:41:04 <Cale> Well, it helps when the chunks are about the size of the L2 cache, iirc. I forget the exact size they settled on.
11:41:06 <jmcarthur_work> it means they are optimized to reduce bottlenecks to the cpu a bit
11:41:26 <ray> optimised to reduce cache misses?
11:41:35 <dons> there's a nice performance curve of , say, map over bytestrings, that varies with the chunks ize
11:41:46 <dons> reducing cache misses helps.
11:42:00 <Cale> The sourcecode links to http://www.cse.unsw.edu.au/~dons/tmp/chunksize_v_cache.png
11:42:20 <seydar> Cale: but that means only the latest piece will be in L2 cache, and isn't the L2 cache size measured in MB?
11:42:47 <ray> bytestrings are often measured in MB
11:43:19 <Cale> seydar: Well, you just won't have as many chunks unless the lazy bytestring is very long.
11:43:39 <Cale> (some lazy bytestrings are infinite, of course :)
11:44:30 <seydar> ok, im gonna have to go do some reading on CPU caches
11:44:56 <Saizan_> it also depends on how the bytestring gets built
11:45:05 <jmcarthur_work> you know you don't need to know all these operational details just to use it, right?
11:45:33 <Cale> seydar: It's really unimportant, since you can't actually change the value yourself anyway.
11:45:34 <seydar> yea, i do
11:45:45 <seydar> but it'sa lot better to know how it works
11:45:46 <Cale> (unless you want to recompile your ByteString library)
11:46:54 <Cale> If you just want to know how it works, there's a paper or two.
11:47:49 <Cale> However, I can't seem to connect to www.cse.unsw.edu.au for some reason
11:47:55 <Cale> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
11:48:20 <seydar> so here's kind of a jump in questions: how can I pack/unpack strings? I know there's Data.Binary, but i can't make any sense of it
11:49:17 <Cale> There are pack and unpack functions in the various Data.ByteString libraries
11:49:27 <Cale> If that's what you're talking about.
11:49:50 <Cale> If you need unicode, there are libraries on Hackage for convenient UTF-8/etc. encoding
11:50:25 <seydar> Cale: i think the bytestring stuff was what i was looking for
11:50:47 <Cale> Data.Binary is for serialising other arbitrary data structures into a binary format.
11:51:19 <Cale> It works best when you don't have to worry about coinciding with an existing binary format, but it has some usable stuff for that too.
11:54:01 <seydar> yargh, i'm trying to match up with a file format made by ruby's pack/unpack
11:54:10 <seydar> as well as python's
11:54:20 <dons> seydar: you can use Data.Binary to read arbitrary binary formattttts
11:54:43 <dons> you just define an AST in haskell for the type, and use the Get monad to parse out fields of different size
11:54:54 <dons> then release the library on hackage :)
11:55:20 <jmcarthur_work> edwardk1, thank you for posting your slides! definitely got me more interested in the monoids library
11:55:22 <seydar> :-)\
11:56:00 <seydar> dons: i am planning on making an AST for the type, but I can't find anything with the get monad to put a string in, say, network byte order
11:56:11 <seydar> or an unsigned integer
11:56:15 <seydar> etc
11:56:22 <dons> look in Data.Binary.Put
11:56:29 <dons> do you want to put out, or read in ?
11:56:49 <dons> btw, a string in network byte order? it just puts out the bytes. which are in byte order
11:57:01 <dons> for other sizes, there are big , little and host-endian primitives
11:57:20 <dons> http://hackage.haskell.org/packages/archive/binary/0.5.0.1/doc/html/Data-Binary-Put.html
11:57:26 <dons> putWord64le :: Word64 -> Put  . e.g.
11:57:33 <dons> getWord16le :: Get Word16 et al
11:57:49 <seydar> ahh
11:57:57 <seydar> you are a great resource, thank you
11:58:03 <dons> runGet (do x <- getWord16le ; y <- getWord8 ; return (x,y))
11:58:08 <seydar> may you never get a job so you can always stay on irc
11:58:10 <dons> applied to a string
11:58:23 <dons> hehe. i have a job thankfully :) but now it is lunch time!
11:58:24 <jmcarthur_work> seydar, too late
11:58:35 <jmcarthur_work> it's a haskell job though
11:58:59 <mauke> may you get paid for being on irc :-)
11:59:56 <leeda> a haskell job? what do you do?
12:00:03 <defun> Basides galois, what other companies (anywhere in the world) are there that use haskell as their primary language?
12:00:08 <Jedai> seydar: look at http://www.galois.com/
12:03:59 <jmcarthur_work> defun, the one in my imagination
12:04:05 <jmcarthur_work> my dreams
12:04:30 <ray> ray laboratories
12:05:13 <edwardk> jmcarthur_work: did you see the slides i posted to comonad I had to run shortly thereafter
12:05:23 <edwardk> er drop a period somewhere in that =)
12:06:09 <edwardk> Hah, read that paper that wadler linked to, there was a paragraph that read like an advertisement for kata. ;)
12:06:24 <edwardk> "We believe that the class-based mindset itself drags along the implication that the class of an object is a reasonable thing for client code to know. But, this very knowledge inhibits reuse. On the other hand, existing prototype-based languages, even Self, do not seem to allow for sufficient latitude for the programmer to express his or her intentions at the linguistic level."
12:06:34 <Raevel> is it possible to import constructors by explicitly naming them, or for a specific type?
12:07:04 <edwardk> raevel: import Some.Module (SomeType(SomeConstructor,SomeOtherCon))
12:07:36 <Raevel> aha, thank you!
12:07:44 <Raevel> been wondering about that for a while now
12:07:46 <byorgey> edwardk: heh, nice
12:07:59 <jmcarthur_work> edwardk, yes i saw it. thank you for posting it! got me more interested in the monoids library, for sure
12:08:32 <edwardk> jmcarthur_work: i'll try to drill into more of the seminearring/rich structure stuff over the next couple of months in little talks here and there
12:08:37 <byorgey> edwardk: so how's kata coming?
12:08:56 <edwardk> byorgey: actually quite well. i gave in and went back to monoidal parsing
12:09:00 <jmcarthur_work> is there any material sitting around that explains the ideas behind kata?
12:09:03 <jfredett> yah, are you done yet? you take forever, learn to cowboy code. :P
12:09:15 <edwardk> jmcarthur_work: not yet. just a mostly empty irc channel =)
12:09:17 <byorgey> edwardk: awesome!
12:09:38 <edwardk> jmcarthur_work: i usually link to a big syntax example and scare the hell out of people with it
12:09:53 <jmcarthur_work> edwardk, i think i saw that
12:11:03 <seydar> is there a tutorial on making your own monads?
12:11:12 <seydar> where's that guy who wrote learn you a haskell?
12:11:36 <jmcarthur_work> seydar, his nick here is BONUS
12:11:54 <seydar> BONUS: hey, are you still working on learn you a haskell?
12:11:59 <truthair> haskell.org claims haskell (as a pure functional language) has no side-effects, but this is of course patently untrue.
12:12:29 <jmcarthur_work> haskell doesn't have any side-effects. its runtime does
12:12:30 <pikhq> truthair: No, no, it's perfectly true.
12:12:39 <truthair> I mean, I've only been looking into it for 2 days and it's already causing severe amounts of maniacal cackling... :p
12:13:01 <pikhq> That Haskell happens to compile into an imperative program that has side effects is completely irrelevant to Haskell itself. :P
12:14:22 <truthair> On a more serious note, I'm assuming Data.Map is an associative list and hence is O(n) lookup?
12:14:27 <mmorrow> truthair: when people say "Haskell" they mean "as in the Haskell specification"
12:14:44 <soupdragon> no they mean "as in the GHC implementation"
12:15:00 <mauke> truthair: stop that
12:15:03 <truthair> mmorrow: Or that might have been a lead-in to the joke of maniacal laughing being a side-effect :p
12:15:03 <CalJohn> truthair: actually it is O(log n)
12:15:08 <mmorrow> truthair: in "whatever you want to call what you can compile with ghc", you can access arbitrary memory, and jump to arbitrary code if you like
12:15:18 <CalJohn> truthair: otherwise it would be no better than a list...
12:15:31 <mauke> truthair: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
12:15:34 <brad_larsen> So, I'm using inf-haskell from the haskell-mode emacs package.  But I'm having troubles with it.
12:16:04 <brad_larsen> C-c C-l (load file in interpreter) first executes `:cd ~/.cabal/' in ghci
12:16:04 <truthair> CalJohn: Oh, yeah...I guess binary tree would make more sense as an implementation
12:16:10 <mmorrow> soupdragon: are you vixey?
12:16:32 <soupdragon> yes
12:16:37 <mmorrow> soupdragon: ahhhh. :)
12:16:40 <CalJohn> truthair: i haven't actually read the paper
12:16:43 <brad_larsen> this means hierarchical modules used in the projects I'm hacking on aren't loaded properly.
12:16:47 <brad_larsen> Anyone know how to fix this?
12:16:59 <mmorrow> soupdragon: i was wondering where you'd been
12:19:48 <seydar> mmorrow: do you have a blog?
12:20:53 <mmorrow> seydar: no, but i'm actually planning on setting one up in the very short term
12:21:03 <seydar> ping me when you do, k?
12:21:08 <mmorrow> seydar: ok :)
12:21:47 <michaelfeathers_> ping
12:21:56 <Jedai> brad_larsen: Well I think the latest don't do that, but I seem to remember having this problem on Ubuntu, I probably corrected the Lisp code or something, I don't remember (and this laptop is now very much dead so I can't check)
12:22:19 <truthair> If I implement an infinite data structure (say Pascal's Triangle or something). I know it's not evaluated until the answer is required and even then only as far as needed, but after it has been evaluated how long is the evaluation kept in memory?
12:22:49 <Jedai> truthair: forever
12:23:09 <brad_larsen> Jedai: I have haskell-mode 2.4 and ghc 6.10.4.  There is a bug in haskell-mode?  I found a quick/dirty fix though:  <http://sandersn.com/blog/index.php?title=how_to_prevent_haskell_mode_2_4_from_gue&more=1&c=1&tb=1&pb=1>
12:23:10 <mauke> until nothing refers to it anymore
12:23:23 <mmorrow> soupdragon: i was about to say you should get soupdragon.{com,..} immediately, but looks like someone beat you to the punch
12:23:38 <Jedai> truthair: which means you should probably not use it like that in a long running program, you should localize its evaluation and let the GC take care of it
12:24:28 <mmorrow> soupdragon: looks like at least soupdragon.org is available. do you want it? (if not, i'm taking it :).
12:24:48 <truthair> Jedai: And is there any way to use an infinite list/data structure in a way that only keeps the tail in memory so as to not run out of memory if you need to evaluate up to VERY large numbers?
12:25:00 <soupdragon> mmorrow: what for?
12:25:14 <Jedai> truthair: Well, if the head is not referenced anywhere it won't be kept in memory
12:25:23 <mmorrow> soupdragon: because it's a cool name, and domain names are cheap
12:25:44 <soupdragon> it seems pointless if you don't have a use but I don't want it
12:25:56 * korpios remembers when he owned several dozen domains ... ugh :p
12:26:00 <Jedai> truthair: for instance if you do "print (foldl' (+) 0 [1...10000000])" it will take a constant and small amount of memory
12:26:12 <mmorrow> soupdragon: ok, so that's you're final answer i take it.
12:26:17 <mmorrow> *your
12:26:20 <soupdragon> yes Chris
12:26:24 * mmorrow logs into his account
12:26:30 <Jedai> truthair: (well in this particular case it may even be compiled to a tight assembler loop)
12:27:06 <truthair> Maybe I should study foldl/foldr again before I continue these questions. I've covered them once during an ocaml class, but that was about 3 years ago and I didn't really grasp them back then to begin with
12:27:34 <Jedai> truthair: Haskell is much more about its higher order function than OCaml
12:27:48 <Jedai> truthair: We try to avoid explicit recursion as much as possible
12:28:18 <Jedai> truthair: Some Haskell programmer even said "[explicit] recursion is the goto of functional programming"
12:28:24 <brad_larsen> http://foldr.com/
12:28:27 <brad_larsen> http://foldl.com
12:28:53 <pikhq> Jedai: I'd think that because it's obvious what's being summed there, it might even be compiled into direct output. ;)
12:28:54 <mmorrow> damn! soupdragin.<all the good ones> is taken
12:28:57 <mmorrow> *gon
12:29:06 <mauke> GORN
12:29:18 <soupdragon> hehe
12:29:25 * mmorrow is the proud owner of http://unsafecoerce.com
12:30:29 <mmorrow> (which just points to moonpatio.com)
12:30:42 <Raevel> in putStr "x" >> getLine, why is the x not printed until the user has written a line?
12:31:14 <soupdragon> Raevel, I think it's because stdout wasn't flushed
12:31:19 <truthair> Raevel: Output gets buffered until a newline
12:31:20 <Jedai> Raevel: that's buffering issues
12:31:22 <pikhq> Raevel: Because stdio defaults to being buffered.
12:31:24 <soupdragon> if you used putStrLn or flushed
12:31:43 <Jedai> Raevel: (nothing to do with lazyness, you'll see the same thing in some languages)
12:31:45 <pikhq> putStr "x" >> hFlush stdout >> getLine -- That would do it, I think.
12:32:01 <Raevel> thank you all :-)
12:32:06 <Raevel> i'll try hFlush
12:32:23 <Raevel> yes.
12:32:36 <lilac> mmorrow: what about unsafePerformHTTP.com?
12:32:50 <soupdragon> cabbage crates coming over the briney
12:33:22 <mmorrow> lilac: it's all you
12:33:23 <truthair> I'm kind of dissappointed no one registered unsafePerformSex.com ...
12:33:56 <CalJohn> Why does this fragment complain about instances?: print $ take 3 $ foldr (+) 0 [1..100]
12:34:07 <mmorrow> truthair: be the first (?) to write a porn site in haskell!!
12:34:17 <brad_larsen> @type foldr (+) 0 [1..100]
12:34:19 <lambdabot> forall a. (Num a, Enum a) => a
12:34:27 <CalJohn> @type print
12:34:28 <pikhq> @type take 3
12:34:28 <lambdabot> forall a. (Show a) => a -> IO ()
12:34:30 <lambdabot> forall a. [a] -> [a]
12:34:31 <truthair> mmorrow: I'd need to actually finish learning Haskell first :p
12:34:52 <mauke> > print $ take 3 $ foldr (+) 0 [1..100]
12:34:54 <lambdabot>   No instance for (GHC.Num.Num [a])
12:34:54 <lambdabot>    arising from a use of `GHC.Num.+' at <...
12:35:10 <Raevel> > take 3 $ foldr (+) 0 [1..100]
12:35:11 <lambdabot>   No instance for (GHC.Enum.Enum [a])
12:35:11 <lambdabot>    arising from the arithmetic sequence...
12:35:12 <mauke> because you can't take 3 elements of 5050
12:35:21 <CalJohn> "duh"
12:35:25 <CalJohn> sorry, i am a moron
12:35:30 <brad_larsen> no no
12:35:31 <soupdragon> me too
12:35:41 <ajdhs> When running configure in the GHC source tree, I keep getting errors of the form "./configure: line 10677: syntax error: unexpected end of file" - anyone know what's going on here?
12:35:41 <Raevel> hah, me three
12:35:47 <Jedai> CalJohn: The error message isn't very helpful though
12:35:52 <seydar> mauke: that doesn't make sense to me
12:35:56 <seydar> oh wait
12:35:56 <seydar> nvm
12:36:11 <bremner> ajdhs: what is your environment?
12:36:15 <seydar> for some reason i forgot that an int isn't a list
12:36:24 <CalJohn> Jedai: in my defence, that is true
12:36:34 <ajdhs> Linux i686
12:36:52 <ajdhs> or do you mean like environment variables?
12:37:07 <Jedai> CalJohn: It point an interference error but we would prefer it point another (but the compiler isn't extralucid yet so I guess we'll have to be content with that for now)
12:37:10 <bremner> no the former
12:37:47 <bremner> ajdhs: I don't know about ghc in particular, but usually I would try running autoconf at that point
12:37:59 <CalJohn> Jedai: by the way, you forgot to make it clear to truthair that you can't use foldl' on an infinite list
12:38:09 <ajdhs> hm
12:38:11 <ajdhs> same problem
12:38:14 * bremner was secretly hoping ajdhs was using windows so he could not care :)
12:38:21 <CalJohn> checking that is what make me try and take 3 from an Int
12:38:22 <CalJohn> ;)
12:38:52 <ajdhs> it looks like it's having trouble with if tests
12:39:02 <Jedai> ajdhs: what version of GHC
12:39:11 <ajdhs> it didn't make it past a line of the form if test "$BootingFromHc" = "NO"; then
12:39:16 <ajdhs> latest HEAD
12:39:32 <Jedai> CalJohn: You're right... should have used map to make my point
12:40:18 <Jedai> ajdhs: I suggest you ask your question in #ghc too, it's more likely people able to answer would be there
12:40:32 <ajdhs> thanks
12:40:47 <Jedai> ajdhs: they may be here too but that's not sure (and they may not be as attentive)
12:40:51 <CalJohn> or just plain foldl
12:41:04 <CalJohn> so long as you are catamorphing
12:41:27 <michaelfeathers_> Anyone game for a silly type class question?
12:41:42 <Jedai> CalJohn: foldl wouldn't work very well on an infinite list either, I suspect you were thinking of foldr
12:42:02 <brad_larsen> hmmph, the inferior-haskell-type procedure of inf-haskell doesn't work if ghci spits out the type signature of the symbol in question on multiple lines.
12:42:05 <byorgey> michaelfeathers_: sure
12:42:41 <Jedai> brad_larsen: maybe recent version would work ? (CVS version)
12:43:15 <Jedai> michaelfeathers_: ask away
12:43:41 <michaelfeathers_> Books and blogs refer to "the list monad."  I know that you can only have one instance of Monad for a particular type, but would it be possible for there to be many implementations with different behavior on List which would obey the monad laws?
12:43:53 <Jedai> michaelfeathers_: Yes
12:44:00 <michaelfeathers_> would->wouldn't
12:44:25 <Jedai> michaelfeathers_: but the typeclass system wouldn't be able to have several different Monad instance for the same type simultaneously
12:44:39 <Jedai> michaelfeathers_: (it couldn't decide which one to choose...)
12:44:44 <byorgey> michaelfeathers_: in theory, yes.  although mathematically it turns out that the list monad is the ONLY possible monad for lists.
12:44:45 <pikhq> Sure; the instance of monad for List in the libraries is merely the *useful* one, not the only possible one.
12:44:48 <pikhq> ;)
12:44:50 <brad_larsen> Jedai: I'll check it out.
12:45:02 <michaelfeathers_> Thanks
12:45:02 <jmcarthur_work> well, for List specifically i can't think of any other monads
12:45:04 <Jedai> michaelfeathers_: often this kind of case is handled by using newtype
12:45:05 <sm> darn.. I had leksah showing current package module info, but I really can't replicate it
12:45:08 <jmcarthur_work> unless i'm missing something trivial
12:45:15 <pikhq> jmcarthur_work: Oh. Well.
12:45:15 <edwardk> michaelfeathers_: thats why we have newtypes
12:45:17 <pikhq> For List specifically. XD.
12:45:32 <pikhq> There's other monads that have multiple instances, at least.
12:45:43 <pikhq> Well, multiple feasible ones.
12:46:30 <byorgey> michaelfeathers_: also, that wasn't a silly question =)
12:46:46 <Jedai> byorgey: there is no silly question !!
12:47:57 <tessier__> Happy 10th Annual Sysadmin Appreciation Day everyone! http://sysadminday.com
12:48:14 <pikhq> tessier__: :)
12:48:26 <dmhouse> tessier__: the same day as Hawaiian flag day?!
12:48:30 <lysgaard> Any mods at haskellwiki here? I'd love to get an account please
12:48:42 <tessier__> hehe
12:48:53 <byorgey> lysgaard: I can set you up.
12:49:15 <lysgaard> byorgey: super! =) I guess you need some info?
12:49:23 <byorgey> lysgaard: just email me (byorgey at gmail) your desired username
12:49:24 <CalJohn> Jedai: doesn't that depend on if the operation is destructive or not?
12:49:37 <lysgaard> byorgey: Wilco
12:50:17 <Jedai> CalJohn: No, foldl don't work on infinite list (that's due to the fact that it has to go to the end of the list before it evaluate to anything other than a foldl
12:50:46 <Jedai> CalJohn: foldl f i (x:xs) = foldl (f i x) xs
12:51:03 <Jedai> CalJohn: so if the list is infinite you never get to evaluate f
12:51:22 <mmorrow> preflex: zdec integer_GHCziIntegerziInternals_Szh_static_info
12:51:22 <preflex>  integer_GHC.Integer.Internals_S#_static_info
12:52:16 <Jedai> CalJohn: Anyway foldl is silly for most usages, "you either want foldl' or foldr, almost never foldl" is a good rule for a beginner (though it's not strictly always true
12:52:41 <thaldyron> Is it possible to perform ByteString.writeFile, if the file is already opened for reading in another thread?
12:53:25 <Vulpyne> It's possible, but it may not do what you want it to.
12:53:30 <sm> how do/can you tell cabal to pick one cabal file when the directory contains several ?
12:54:44 <lysgaard> byorgey: Sent.
12:55:12 <seydar> I'd like to have a pipe that is concurrently readable and writable. What should I use? Control.Concurrent.Chan?
12:55:13 <thaldyron> Vulpyne: well I was wondering whether I need to use explicit locking to avoid data corruption.
12:55:32 <Jedai> seydar: depends on if you want to use STM or not
12:55:45 <seydar> Jedai: what happens if i say yes?
12:55:45 <byorgey> lysgaard: got it, thanks.
12:55:49 * seydar looks up STM
12:56:25 <Jedai> thaldyron: it depends on the OS, so if you want to be portable, try to do something a bit more basic
12:56:41 <Jedai> thaldyron: write somewhere else and move the file when you can
12:58:10 <seydar> Jedai: should I use STM?
12:58:28 <seydar> Jedai: It doesn't sound like I want to, after briefly reading about it
12:58:43 <seydar> actually it sounds like i do
12:58:48 <Jedai> seydar: it depends on what you want to do, I would say if there's a lot of common state between your threads STM is a boon
12:59:00 <seydar> but if my # writes == # reads, then it doesn't matter, does it
12:59:09 <Jedai> seydar: if not, you probably don't need/want it
13:00:06 <Jedai> seydar: there's Chan for usage in normal concurrence and in STM, if you only need a Chan and no MVar, then you probably don't need STM
13:00:25 <seydar> and MVar is mutable, right?
13:00:54 <Jedai> seydar: MVar is IORef but with multithreading support
13:01:15 <seydar> what is "normal concurrence" here?
13:01:24 <Jedai> seydar: No STM
13:01:39 <Jedai> seydar: STM is software transactional memory
13:01:53 <thaldyron> Jedai: but I would still need to wait for the reader-thread to finish (to avoid reading corrupt data) before moving the written file. So it seems I need to use locks anyway.
13:01:58 <seydar> and if the only thing shared is a pipe, then how should my thinking change?
13:02:13 <Jedai> seydar: then you don't need STM
13:02:34 <Jedai> seydar: and your initial choice was right
13:03:01 <seydar> to confirm, i don't need STM because my threads aren't similar enough?
13:03:30 <Jedai> thaldyron: why locks, you can just add the moving part in the reading thread after the reading is finished
13:04:12 <Jedai> thaldyron: or you could use "lock" (or rather MVar used as semaphore) to make the moving in another thread after the reading is finished
13:04:44 <Jedai> seydar: You don't need STM because you don't have a lot of shared state between your threads whatever they are
13:05:05 <seydar> Jedai: thank you for clearing this up and explaining this all to me
13:05:18 <lysgaard> byorgey: Thanks alot, worked like a charm =)
13:05:25 <byorgey> lysgaard: great =)
13:05:40 <thaldyron> Jedai: I'll give that a try, thanks for the hint
13:08:51 <seydar> is STM slower than normal concurrency?
13:10:31 <jmcarthur_work> seydar, currently
13:10:44 <Jedai> seydar: somehow, at least  now, there's hardware support for it coming on the next cpu architecture
13:10:44 <jmcarthur_work> seydar, it's like GC when it was in the early stages of development
13:10:57 <Peaker> seydar: I think it may also be faster, depending on how optimal you got your "normal concurrency". If you had coarse locks, it may easily be faster
13:11:15 <Peaker> GC is still considered problematic for many types of apps, no?
13:11:28 <Jedai> seydar: STM is much nicer to write though, and easier to get right
13:11:44 <jmcarthur_work> STM probably will be considered problematic for some things also, even once it catches on
13:12:40 <thaldyron> seydar: For benchmarks see "The limits of software transactional memory (STM)" http://www.citeulike.org/user/myui/article/3273075
13:12:56 <cwraith> most obviously, STM doesn't work with IO
13:13:00 <jmcarthur_work> it's no magic bullet, but it's waaaaaaaay nicer than manual locks
13:13:25 <cwraith> (I wish it did.  Can I just rollback the state of the whole universe, please?)
13:13:29 <jmcarthur_work> for fine grained locking, at the least
13:13:54 <jmcarthur_work> certain *kinds* of IO could theoretically be rolled back, of course
13:13:58 <Jedai> cwraith: launchNuclearMissile; rollback
13:13:59 <thaldyron> cwraith: for IO with STM see package stm-io-hooks
13:16:01 <truthair> I'm going over one of the tutorials, one of the examples is "main = interact (count . lines)" and the explanation is that . is a normal function of the following "(.) f g x = f (g x)". Ok, I get what it does, buit the way it's used in the example makes it look infix instead of prefix like I'd expect from a function. (Also, just to be sure f (g x) is identical too f g x, right?)
13:16:03 <Adamant> Jedai: that brings up an important point. maybe it's not as important to have rollback as a no-commit (blowing up the missile in the upper atmosphere analogy)
13:16:43 <soupdragon> truthair, (f . g) x = f (g x)
13:16:57 <seydar> truthair: they left out the declaration that makes it infix
13:17:01 <seydar> otherwise you'd use
13:17:12 <seydar> f `.` g
13:17:51 <Jedai> seydar: No
13:17:54 <truthair> There's a declaration to make functions infix? Brilliant.
13:18:16 <cwraith> no.  operators (functions whose names consist only of punctuation) are always infix
13:18:21 <Jedai> seydar: operators written with symbol are infix by default (though you can change their priority and associativity)
13:18:25 <cwraith> The infix declaration just sets their precedence
13:19:02 <Jedai> truthair: sorry, no, but you can't use any normal function (written with letters) infix with backquotes ``
13:19:10 <seydar> i stand corrected then
13:19:17 <Deewiant> Jedai: s/can't/can/
13:19:27 <Jedai> truthair: like this "5 `elem`[1..10]"
13:19:32 <truthair> To sum up, operators default to infix and other functions can be infix'ed by backquotes
13:19:40 <cwraith> yes
13:19:47 <Jedai> Deewiant: oops ^^
13:19:49 <seydar> can you use operators prefixedly?
13:19:55 <cwraith> yes
13:20:02 <cwraith> By using the section syntax (.)
13:20:06 <Jedai> seydar: Yes, with parens : (+) 5 6
13:20:18 <Jedai> > (+) 5 6
13:20:25 <lambdabot>   11
13:20:40 <truthair> And that answers my next question. Thanks for the help
13:20:44 <cwraith> lambdabot is slower at addition of two one-digit integers than I am. <_<
13:20:49 <dmhouse> > ((+) 5 ((*) 2 4)) -- yes, you can write Lisp (with even more parens!)
13:20:50 <lambdabot>   13
13:20:57 <hackagebot> atom 0.1.0 - A DSL for embedded hard realtime applications. (TomHawkins)
13:21:40 <byorgey> truthair: also, f (g x) is not identical to  f g x
13:21:49 <byorgey> truthair: application associates to the left, so  f g x = (f g) x
13:21:58 <truthair> Oh, right
13:26:28 <cwraith> truthair:  operator sections are handy, and I didn't discover them early on.
13:26:29 <stepcut> ?get-dons
13:26:29 <lambdabot> Unknown command, try @list
13:26:33 <stepcut> grrr
13:26:39 <cwraith> @ty (/ 5)
13:26:40 <lambdabot> forall a. (Fractional a) => a -> a
13:26:47 <cwraith> @ty (5 /)
13:26:49 <lambdabot> forall t. (Fractional t) => t -> t
13:26:55 <fxr> 'fl.p
13:27:09 <fxr> @src flip
13:27:09 <lambdabot> flip f x y = f y x
13:27:18 <fxr> @src fix
13:27:18 <lambdabot> fix f = let x = f x in x
13:28:08 <ray> truthair: it all depends on the characters used in the name
13:28:09 <Jedai> > let (!) n = product [1..n] in (5 !)
13:28:11 <lambdabot>   120
13:28:37 <Jedai> cwraith: section abuse ^
13:29:09 <cwraith> doesn't that require at least 6.10 ?
13:29:27 <Jedai> cwraith: nope, it's a "feature" that was in GHC for some time
13:29:46 <cwraith> I know the version in fink was too old
13:29:52 <cwraith> but that was like 6.4
13:29:57 <lysgaard> @hoogle a -> [a] -> [a]
13:29:58 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:29:58 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
13:29:58 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:30:12 <Jedai> cwraith: it just has to forget to check that operators have more than one argument
13:33:33 <seydar> fxr: how do you use fix? it looks like it just applies f endlessly
13:33:58 <jmcarthur_work> seydar, exactly :)
13:34:06 <seydar> jmcarthur_work: but how's it useful?
13:34:18 <jmcarthur_work> > fix (1:)
13:34:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:34:30 <jmcarthur_work> seydar, laziness makes a lot of things possible
13:35:02 <benmachine> > fix (const 1)
13:35:03 <dmhouse> seydar: it's useful from a theoretical point of view.
13:35:03 <lambdabot>   1
13:35:12 <dmhouse> seydar: it turns out to be equivalent to recursion, in a certain sense.
13:35:19 <seydar> dmhouse: ok, that's what i was looking for
13:35:30 <jmcarthur_work> i think it is practically useful as well. makes for very concise, readable definitions sometimes
13:35:37 <dmhouse> seydar: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
13:35:42 <dmhouse> (If you're interested.)
13:35:46 <pikhq> > fix (\x -> if x >= 100 then x else x * x)
13:35:52 <lambdabot>   mueval-core: Prelude.read: no parse
13:35:52 <lambdabot>  mueval: ExitFailure 1
13:36:02 <pikhq> Oh, pooh. Uselessness.
13:36:04 <fxr> > let s = \f -> f f in s s
13:36:05 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:36:31 <jmcarthur_work> > let foo = 1 : foo in foo  -- vs.  fix (1:)     i much prefer the fix version
13:36:33 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:36:49 <seydar> > fix (2 +)
13:37:04 <jmcarthur_work> of course, repeat is the best in this case, but there are other cases where fix is still a great option
13:37:10 <jmcarthur_work> fail
13:37:14 <lambdabot>   mueval-core: Prelude.read: no parse
13:37:14 <lambdabot>  mueval: ExitFailure 1
13:37:21 <Deewiant> > fix (scanl (+) 0 . (1:))
13:37:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:37:25 <seydar> will fix (2+) fail because it attempts to be printed?
13:37:36 <jmcarthur_work> seydar, it fails because it is strict and will never terminate
13:37:41 <dmhouse> The essence is this:
13:37:43 <dmhouse> Prelude> let fact n = if n == 0 then 1 else n * fact (n-1) in fact 5
13:37:43 <dmhouse> 120
13:37:43 <dmhouse> Prelude> fix (\rec n -> if n == 0 then 1 else n * rec (n-1)) 5
13:37:43 <dmhouse> 120
13:37:46 <seydar> jmcarthur_work: why is it strict?
13:38:02 <jmcarthur_work> seydar, you have to evaluate the entire thing to get the result
13:38:03 <dmhouse> But again, I'd recommend reading http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion rather than just trying to grok it through random examples here.
13:38:04 <pikhq> > fix (\x -> if x >= 100 then x else x * x) 2
13:38:05 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
13:38:06 <lambdabot>    arising from the literal `100' at...
13:38:06 <jmcarthur_work> instead of just the head
13:38:16 <jmcarthur_work> well, the head *is* the entire thing, that is
13:38:39 <ray> pikhq: the first one was correct
13:38:47 <ray> that one is not even the right type
13:38:59 <pikhq> ray: Bleh.
13:39:05 <dmhouse> Also, the first three sections of http://en.wikibooks.org/wiki/Haskell/Laziness are good for understanding strictness
13:39:22 <ray> mueval always says "no parse", don't take it to mean that your expression doesn't parse
13:39:31 <Deewiant> > fix (\f x -> if x >= 100 then x else f (x * x)) 5
13:39:33 <lambdabot>   625
13:40:39 <Deewiant> > flip map [2..] $ fix (\f x -> if x >= 100 then x else f (x * x))
13:40:41 <lambdabot>   [256,6561,256,625,1296,2401,4096,6561,100,121,144,169,196,225,256,289,324,3...
13:41:55 <malosh> Hi. For parsing postscript code, would you rather use alex/happy or the parsec library ?
13:43:14 <seydar> parsec ftmfw!
13:44:21 <malosh> ?
13:44:55 <Jedai> Isn't Postcript pretty easy to parse once you've lexed it ?
13:45:04 <malosh> in fact yes
13:45:12 <fxr> @src cycle
13:45:12 <lambdabot> cycle [] = undefined
13:45:12 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:45:29 <malosh> and I'm even parsing a subset of it
13:45:58 * soupdragon hates this = undefined thing
13:46:02 <fxr> even more interesting
13:46:46 <Jedai> malosh: I think I would go with Parsec
13:46:53 <malosh> why ?
13:46:54 <seydar> > cycle [1, 2]
13:46:56 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
13:47:03 <ray> why isn't cycle [] ===== []?
13:47:17 <Deewiant> > cycle []
13:47:18 <lambdabot>   * Exception: Prelude.cycle: empty list
13:47:43 <Jedai> malosh: since there is no big ambiguities you won't need try so Parsec's "simplicity and integration into Haskell in this case win out IMHO
13:47:51 <ray> i cannot think of any reason for it to be bottom
13:47:54 <malosh> ok, thanks
13:48:13 <Jedai> malosh: but really I would go with what you're more confortable with
13:49:04 <malosh> (I'm parsing things for the first time in Haskell. I know Yacc and Lex in C but that's all, in fact)
13:49:52 <fxr> > fix id
13:49:57 <lambdabot>   mueval-core: Prelude.read: no parse
13:49:57 <lambdabot>  mueval: ExitFailure 1
13:50:25 <fxr> > Control.Monad.Fix.fix id
13:50:30 <lambdabot>   mueval-core: Prelude.read: no parse
13:50:30 <lambdabot>  mueval: ExitFailure 1
13:50:54 <ray> mueval saying "no parse" doesn't mean your expression didn't parse
13:51:04 <Jedai> malosh: then you'll be familiar with Alex brand of logic but it may be more interesting to discover Parsec, your choice
13:51:05 <fxr> yeah I see
13:51:20 <brad_larsen> malosh:  i'd try parsec first then.  getting alex/happy integrated in a project is non-trivial.  parsec is lower startup cost.
13:51:33 <ray> fix id is bottom
13:51:58 <malosh> ok, I'll try it then. Thanks !
13:51:59 <brad_larsen> malosh: although if you want an example of alex/happy integration, check language-c on hackage, and pour through the alex & happy docs.
13:54:12 <ray> in general, if f _|_ is _|_, fix f is also _|_
13:54:24 <ray> which makes sense, because that's a fixed point
13:54:40 <dmhouse> And in fact the least one, since _|_ is less-defined than all other values.
13:54:50 <ray> yeah
13:55:06 <ray> it is the least (defined) fixed point
13:57:06 <jvoorhis> dmhouse, ray: i have only a little intuition about fix; do you have any pointers for understanding better what is meant by "least defined" ?
13:57:23 <Raevel> ooh fixed point theory
13:58:10 <dmhouse> jvoorhis: read the first three sections of http://en.wikibooks.org/wiki/Haskell/Laziness
13:58:14 <Raevel> jvoorhis: _|_ is undefined for all inputs, so all other functions are more defined
13:58:31 <dmhouse> jvoorhis: then read http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
13:58:48 <dmhouse> jvoorhis: also http://en.wikibooks.org/wiki/Haskell/Denotational_semantics really goes into detail if you want.
13:58:57 <jvoorhis> thanks all :)
13:58:59 <ray> _|_ is the key concept
13:59:27 <seydar> g2g
13:59:32 <seydar> fare thee all well
13:59:38 <seydar> good sirs and madams
13:59:39 <Raevel> i learnt fixed point theory from "semantics with applications", i think the 1st ed is freely available
13:59:46 * seydar flees
13:59:47 <jvoorhis> right, but i guess my brain wants to go on tangents about how some non-bottom values may be "more defined" than others
14:00:30 <ray> jvoorhis: you probably want to read the denotational semantics one
14:01:24 <ray> that talks about "definedness" as a partial ordering relation
14:01:30 <jvoorhis> ray: does it cover fixpoint types as well?
14:02:00 <ray> yeah
14:02:14 <ray> if that means what i think it means
14:02:41 <jvoorhis> i'm thinking of a Graham Hutton paper i read about the duality of fold and unfold
14:02:51 <jvoorhis> i had some difficulty with that one :)
14:03:20 <Saizan_> there's a wadler one too on that subject
14:03:27 <Saizan_> non-published
14:06:16 <jvoorhis> ah, it was Fold and Unfold for Program Semantics
14:11:58 <soupdragon> @go Fold and Unfold for Program Semantics
14:12:01 <lambdabot> http://citeseer.ist.psu.edu/298179.html
14:15:41 <dufflebunk> Is there a way to surpress "path outside of the source tree" warnings in cabal files?
14:24:13 <truthair> Is the calling length on a list O(1), O(n) or (if I get earlier explanations on lazy evaluation right) O(n) the first time and O(1) for all following occasions?
14:24:43 <mauke> it's O(n)
14:25:35 <fxr> hmm
14:26:07 <Vulpyne> Lists are pretty much like linked lists from C, if that helps you.
14:26:16 <ray> truthair: the "lazy evaluation" part is that the result will be shared if possible
14:26:48 <truthair> ray: So the last option then, O(n) the first time and O(1) if it's called on the same list again?
14:26:57 <mauke> the "lazy evaluation" part is that 'let foo = length xs in ...' won't immediately walk down the list
14:26:58 <fxr> me and my friend evrim just proved that javascript in our browser is not lazy.
14:27:01 <mauke> truthair: no
14:27:10 <ray> well, i wouldn't call it O(1)
14:27:17 <fxr> using fix, id, eval and apply
14:27:34 <truthair> ray: It's constant time if the answer is shared, no?
14:27:40 <ray> length is clearly O(n)
14:27:45 <mauke> fxr: (function () {})(alert("not lazy"))
14:27:58 <mauke> truthair: if you're calling length again, it's not shared
14:28:51 <fxr> mauke: yeah we did it using a metacircular evaluator
14:29:03 <truthair> mauke: Hmm, why not?
14:29:03 <bos> @src enumFromTo
14:29:04 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:29:05 <byorgey> truthair: if you say  let foo = length xs in ...
14:29:09 <fxr> mauke: to learn fix op
14:29:14 <byorgey> er, sorry
14:29:18 <mauke> truthair: by definition
14:29:24 <bos> dons: can vacuum display thunked values?
14:29:31 <byorgey> truthair: if you say  'let foo = length xs in ... foo appears multiple times' then the length will only be computed once.
14:29:42 <byorgey> and only if it's actually needed.
14:29:45 <brad_larsen> @check map f (map g xs) == map (f . g) xs
14:29:47 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
14:29:49 <dons> bos: i think mmorrow added that
14:29:51 <byorgey> but if you call 'length' twice it will be computed twice.
14:29:52 <dons> so it won't eval thunks
14:29:54 <dons> previously it did
14:29:55 <fxr> and sure it's a oneliner: e.apply(this,[1,2,fix(id)]);
14:29:56 <brad_larsen> @check \f g xs -> map f (map g xs) == map (f . g) xs
14:29:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
14:29:58 <lambdabot>    arising from a use of `...
14:30:52 <brad_larsen> @check 1 == 1
14:30:54 <lambdabot>   "OK, passed 500 tests."
14:30:57 <brad_larsen> ha
14:31:14 <bos> dons: hmm, ok. i can't seem to convince it to do so.
14:31:15 <cwraith> @check True
14:31:16 <lambdabot>   "OK, passed 500 tests."
14:31:23 <cwraith> @check False
14:31:25 <lambdabot>   "Falsifiable, after 0 tests:\n"
14:31:37 <ray> oh no false is falsifiable
14:31:46 <kyagrd> dons: By the way what happen to the Real Wrold Haskell blog?
14:31:53 <dons> bos: check with mmorrow
14:31:59 <bos> dons: will do
14:32:01 <kyagrd> s/Wrold/World/
14:32:08 <fxr> @check fix id == id $ fix id
14:32:10 <lambdabot>   Couldn't match expected type `a -> b'
14:32:12 <truthair> byorgey: Let's see if I got it right with an example someone used last night. If I have "double x = x + x" and call "double (length myList") that would expand to "length myList + length myList", but only the first will be calculated.
14:32:28 <dons> kyagrd: oh hmm. Firefox can't establish a connection to the server at www.realworldhaskell.org.
14:32:32 <dons> bos:
14:32:42 <bos> yeah, sadface.
14:32:48 <dons> :(
14:32:49 <mauke> truthair: it won't expand to length myList + length myList
14:33:21 <truthair> mauke: What then?
14:33:22 <sioraiocht> is calling hGetChar repeatedly a lot less efficient than hGetLine?
14:33:35 <byorgey> truthair: it's slightly more complicated than that.  it will basically expand to something like  'let x = length myList in x + x'
14:33:37 <mauke> truthair: let x = length myList in x + x, basically
14:33:37 <ray> it'll expand to something like let x = length myList in x + x
14:33:56 <truthair> Ah, right
14:34:00 <augustss> It expands to a graph
14:34:24 <augustss> in princimple
14:34:27 <bos> dons: i'm trying to reboot it. we'll see if it works.
14:34:43 <dons> k.
14:35:05 <ray> lazy evaluation is about evaluating arguments either zero or one times
14:35:13 <bos> makes me half-wish i was using a VPS like linode instead of a real physical host.
14:38:43 <bos> dons: the box is dead :-(
14:39:00 <dons> urgh
14:39:34 <kyagrd> Would be nice if book.realworldhaskell.org could be alias temporarily to www.realworldhaskell.org then
14:39:41 <ray> bos: VPSes can be pretty convenient and cost-effective :)
14:39:55 <ray> once you go virtual, you can't go back
14:40:39 <ray> well, until you can afford your own server room, i guess
14:40:45 <shepheb> how does gitit handle sessions and login and so on? implemented unique to gitit?
14:41:23 <bos> shepheb: why are you asking here?
14:41:48 <shepheb> oh, is there a #gitit?
14:42:06 <kyagrd> gitit /= git :)
14:42:29 <ray> gitit is haskelly
14:42:32 <kyagrd> http://hackage.haskell.org/package/gitit
14:43:03 <shepheb> I want to write a simple web interface for a Haskell app, but I don't want to have to write handling for sessions and all that junk by hand if I can avoid it.
14:46:13 <akway> hey
14:47:18 <kyagrd> @check \x y z -> x<y && y<z ==> x<z
14:47:19 <lambdabot>   Not in scope: `==>'Precedence parsing error
14:47:19 <lambdabot>      cannot mix `GHC.Classes.<'...
14:47:31 <kyagrd> @check \x y z -> (x<y && y<z) ==> x<z
14:47:32 <lambdabot>   Not in scope: `==>'
14:47:47 <kyagrd> @check \x y -> x/=y
14:47:49 <lambdabot>   "Falsifiable, after 0 tests:\n()\n()\n"
14:48:01 <kyagrd> @check \x y -> x/=(y::Integer)
14:48:02 <soupdragon> @let p ==> q = not p || q
14:48:03 <lambdabot>   "Falsifiable, after 1 tests:\n0\n0\n"
14:48:04 <lambdabot>  Defined.
14:48:05 <soupdragon> @check \x y z -> (x<y && y<z) ==> x<z
14:48:06 <lambdabot>   Not in scope: `==>'
14:48:15 <soupdragon> @check \x y z -> let p ==> q = not p || q in (x<y && y<z) ==> x<z
14:48:16 <lambdabot>   "Falsifiable, after 0 tests:\nTrue\nFalse\nFalse\n"
14:48:32 <kyagrd> ???
14:48:34 <soupdragon> @check \x y z -> let p ==> q = not p || q in (x<=y && y<=z) ==> x<=z
14:48:35 <lambdabot>   "Falsifiable, after 0 tests:\nTrue\nTrue\nFalse\n"
14:48:59 <soupdragon> @check \x y z -> let p ==> q = not p || q in (x<y && y<=z) ==> x<=z
14:49:01 <lambdabot>   "Falsifiable, after 2 tests:\nFalse\nFalse\nFalse\n"
14:49:12 <kyagrd> check \x y z -> let p ==> q = not p || q in (x<y && y<=z) ==> (x<=z)
14:49:16 <soupdragon> most peculiar !
14:49:24 <kyagrd> @check \x y z -> let p ==> q = not p || q in (x<y && y<=z) ==> (x<=z)
14:49:26 <lambdabot>   "OK, passed 500 tests."
14:49:37 <kyagrd> > trace
14:49:39 <lambdabot>   Not in scope: `trace'
14:49:48 <soupdragon> ahha
14:50:21 <brad_larsen> @check \(f :: Integer -> Integer) (g :: Integer -> Integer) (xs :: [Integer]) -> map f (map g xs) == map (f . g) xs
14:50:22 <lambdabot>   Parse error in pattern at "(g" (column 28)
14:51:19 <brad_larsen> @check \f g xs -> map f (map g xs) == map (f . g) xs :: (Integer -> Integer) -> (Integer -> Integer) -> [Integer] -> Bool
14:51:20 <lambdabot>   Couldn't match expected type `(GHC.Integer.Internals.Integer
14:51:52 <brad_larsen> lambdabot hates me
14:52:13 <kyagrd> @check \f g xs -> map f (map g xs) == (map (f . g) xs :: (Integer -> Integer) -> (Integer -> Integer) -> [Integer] -> Bool)
14:52:15 <lambdabot>   Couldn't match expected type `(GHC.Integer.Internals.Integer
14:52:34 <kyagrd> @check \f g xs -> map f (map g xs) == (map (f . g) xs :: [Integer])
14:52:35 <lambdabot>   Overlapping instances for GHC.Show.Show
14:52:35 <lambdabot>                              (a -> ...
14:52:37 <brad_larsen> hates you too ;-)
14:52:51 <kyagrd> @check \f g xs -> map f (map g xs :: [Integer]) == (map (f . g) xs :: [Integer])
14:52:53 <lambdabot>   Overlapping instances for GHC.Show.Show
14:52:53 <lambdabot>                              (GHC.I...
14:53:04 <kyagrd> @check \f g xs -> map f (map g (xs :: [Integer])) == (map (f . g) xs :: [Integer])
14:53:06 <lambdabot>   Overlapping instances for GHC.Show.Show
14:53:06 <lambdabot>                              (a -> ...
14:53:10 <Peaker> @check \x y z -> let p ==> q = not p || q in (x<y && y<z) ==> (x<(z::Int))
14:53:11 <lambdabot>   "OK, passed 500 tests."
14:54:32 <ronc> hey there, good evening haskell people
14:54:43 <kyagrd> Oh, to test functions one has to make function types showable just giviing then dummy definition fior show f = "<function>" or something
14:55:11 <brad_larsen> but lambdabot was reporting overlapping instances
14:55:15 <brad_larsen> not no instance
14:55:18 <brad_larsen> ?
14:55:20 <kyagrd> yeah that's wierd
14:55:33 <brad_larsen> i think it already has a show instance for functions
14:55:37 <brad_larsen> > id
14:55:39 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:55:39 <lambdabot>    arising from a use of `...
14:55:43 <brad_larsen> hmm
14:55:45 <kyagrd> oops
14:55:53 <brad_larsen> > id :: Int -> Int
14:55:55 <lambdabot>   Overlapping instances for GHC.Show.Show
14:55:55 <kyagrd> Maybe it has too many
14:55:55 <lambdabot>                              (GHC.T...
14:56:08 <brad_larsen> guess so
14:56:39 <ronc> guys, is there such a thing has operators in haskell?
14:56:45 <soupdragon> yes
14:57:20 <jmcarthur_work> > 1 + 1
14:57:22 <lambdabot>   2
14:57:34 <ronc> yes, but they are also functions, right?
14:57:45 <jmcarthur_work> > let a @@@ b = a + b in 5 @@@ 6
14:57:46 <lambdabot>   11
14:57:48 <Peaker> ronc: operators are just special names that functions can have. Other than being special names, they are not very special
14:58:04 <jmcarthur_work> (+) is infix plus
14:58:17 <jmcarthur_work> err
14:58:18 <jmcarthur_work> prefix
14:58:23 <jmcarthur_work> + is infix plus
14:58:33 <soupdragon> yes they are functions
14:58:59 <soupdragon> > let (+) = 3 in ((+),(+))
14:59:00 <lambdabot>   (3,3)
14:59:09 <soupdragon> or not..
14:59:37 <pikhq> Basically, operators are functions without alphanumerics in their name.
15:01:26 <pikhq> Because of that, they are by default called infix -- but can be made prefix by sticking them in parens.
15:02:07 <pikhq> No magic at all.
15:02:07 <ronc> prefix always made moar sense to me
15:02:15 <ronc> even in first grade
15:02:27 <pikhq> (except for unary minus -- that's just a pain)
15:02:58 <soupdragon> unary minus is the worst thing in haskell imo
15:03:11 <pikhq> 'Tis an ugly, ugly wart.
15:03:38 <mmorrow> dos, dons: i still have yet to upload the most recent vacuum to hackage. i'll do that now, since i happen to be hacking on vacuum-related stuff currently..
15:03:38 <ronc> any way to fix it?
15:03:47 <soupdragon> no
15:03:54 <ronc> banning negative numbers?
15:03:55 <pikhq> Redefine Haskell.
15:04:24 <mmorrow> bos, dons: i just realized how to export a vacuum'ed heap graph *to asm + an .hs stub that ffi imports it and does addrToHValue#* !!@  http://moonpatio.com/repos/GenAsm.hs
15:04:30 <jaredj_> how is it? negate?
15:04:49 <bos> mmorrow: wow
15:05:33 <mmorrow> bos: it's funny how simple it is, but how hard it was to realize that that was all that needed to be done
15:05:54 <bos> mmorrow: the reason i asked about thunks is that i was curious whether [1..5] generates a list of [1,1+1,1+1+1,...]
15:06:06 <bos> mmorrow: but the current vacuum doesn't tell me
15:06:27 <soupdragon> mmorrow: that's the mark of innovation
15:06:55 <mmorrow> bos: ah, hmm. int-e's patch that makes vacuumLazy work is in the darcs repo (i'll update the hackage shortly), but iirc [0..5] gives you [CONSTR, THUNK]
15:06:55 <bos> presumably it generates a list of thunks, each depending on its predecessor
15:07:16 <benmachine> isn't [0..5] basically equivalent to enumFromTo 0 5
15:07:23 <soupdragon> CONSTR:THUNK ??? no
15:07:35 <mmorrow> bos: yeah, it's really a bummer that unpackClosure# doesn't let you look inside APs and PAPs
15:07:39 <SamB> soupdragon: why not?
15:07:56 <soupdragon> oh I get it
15:07:58 <mmorrow> soupdragon: [evaluated to whnf, thunk-for-the-tail]
15:08:00 <bos> benmachine: it is
15:08:08 <soupdragon> [CONSTR, THUNK] means (:) CONSTR THUNK
15:08:11 <Philonous> @seen nominolo
15:08:11 <lambdabot> I saw nominolo leaving #haskell-soc, #yi, #ghc, #haskell-in-depth and #haskell 11h 22m 33s ago, and .
15:08:13 <bos> benmachine: but that still doesn't tell me what i get
15:08:24 <jmcarthur_work> @check \x y -> ([x..y] :: Int) == enumFromTo x y
15:08:25 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:08:33 <jmcarthur_work> @check \x y -> ([x..y] :: [Int]) == enumFromTo x y
15:08:34 <lambdabot>   "OK, passed 500 tests."
15:08:43 <mmorrow> soupdragon: yeah, i guess it was slightly misleading that i was using [] to hold the closures and what the closures happen to represent is also a [] ..
15:08:52 <mmorrow> s/misleading/unclear/
15:09:47 <mmorrow> bos: from what i understand, "AP" closures double as "THUNK" closures, so you'd be getting probably:
15:10:29 <mmorrow> CONSTR(I# n), AP(enumFromTo (n+1) m)
15:11:14 <mmorrow> but we can't see inside the AP (which i think is actually "seen" (whatever that means) as a THUNK there)
15:11:24 <mmorrow> , closureType (const 42)
15:11:27 <lunabot>  AP
15:11:28 <mmorrow> , closureType $! (const 42)
15:11:30 <lunabot>  PAP
15:11:39 <mmorrow> , closureType $! (const 42 0)
15:11:41 <lunabot>  Constr
15:13:25 <jaredj_> is there a function like (s :: RecordType {foo :: Int}) \x s -> s { foo = x }?
15:13:39 <jaredj_> already built in? like foo is as soon as i define RecordType?
15:13:54 <jaredj_> like a setFoo?
15:14:29 <dons> hey all
15:14:40 <dons> need quick testing of the haskell platform 2009.2.0.2 release, http://hackage.haskell.org/platform/
15:15:00 <dons> could you check the installer for your architecture as appropriate, and let me know of any trouble in the next 30 mins?
15:17:05 <jaredj_> dons: so for debian it's a bunch of packages? is there a metapackage?
15:18:22 <dons> at the moment it is a bunch of packages getting up to date, yes.
15:18:29 <dons> there will be a metapackage in the future
15:20:00 <jaredj_> kk
15:21:39 <poh> how bad an idea is it to make ord and eq disagree?
15:22:22 <pikhq> poh: Absurdly.
15:22:37 <tromp_> we have to kill you for even considering it
15:22:55 <tromp_> where do you live again?
15:23:16 <poh> I can't see any way it could not be a bad idea, but I was hoping
15:23:25 <shapr> tromp_: Dude, you showing up for the Boston HUG sometime?
15:23:44 <tromp_> not likely, Shae:(
15:23:49 <poh> trommp_: um... Moscow
15:24:22 <mmorrow> here's "Data.IntMap.fromList (take 64 (zip [(0::Int)..] (cycle ['a'..'c']))" serialized to asm (and recoverable from withing haskell) with all sharing retained:  http://moonpatio.com/repos/myIntMap.s
15:24:54 <mmorrow> (this prog gives access to it http://moonpatio.com/repos/MyIntMap.hs)
15:27:31 <edwardk> mmorrow: nice!
15:29:35 <mmorrow> edwardk: i'm amazed at how relatively simple it is too
15:30:47 <mmorrow> edwardk: (and you could do away with needing gas if you do your own relocations, using ObjLink to get the needed ".._static_info" symbol addresses
15:31:27 <mmorrow> where here relocation would just simply be writing the addresses at the offsets that you kept around
15:31:55 <jmcarthur_work> mmorrow, so this can serialize a lazy structure to be deserialized later?
15:31:58 <mmorrow> (since ghc uses absolute addresses and static linking)
15:32:31 <mmorrow> jmcarthur: you can serialize data with all the sharing retained, but you can't serialize frozen applications of functions/stuff like that
15:32:46 <mmorrow> like, "fix (0:)" works, but "[0..]" doesn't
15:32:47 <jmcarthur_work> ah
15:32:52 <edwardk> mmorrow: slick
15:32:52 <ray> dons: i don't know if it's feasible, but it would be nice if the windows installer removed the previous version from the path
15:33:24 <edwardk> now you just need to figure out function closures, etc. ;)
15:33:49 <mmorrow> edwardk: totally, that would really be cool
15:34:00 <edwardk> and i can have a nice portable-ish haskell higher order types over the wire representation ;)
15:34:08 <mmorrow> wooo
15:36:08 <Peaker> ronc: you don't like  (3 + 5)  you prefer prefix?  Like (+ 3 5) ?
15:36:18 <ronc> yes
15:36:22 <ronc> it makes sense to me
15:36:35 <truthair> ronc: I just learned ((+) 3 5) works
15:36:36 <pikhq> You must love Lisp.
15:36:47 <ray> yeah, do (+) 3 5 then
15:36:48 <pikhq> truthair: Well why wouldn't it?
15:36:50 <pikhq> ;)
15:36:58 <ronc> I never learned or seen Lisp
15:37:01 <ronc> :P
15:37:13 <ray> truthair: this is haskell, not some language where operators are magic and not just regular functions
15:37:19 <truthair> pikhq: Well, I spend the past 2 weeks trying to get into lisp and I got thrown of by operators being functions but still being infix
15:37:27 <ray> what kind of weird language makes operators magic anyway
15:37:32 <pikhq> Never seen it? But you just typed valid Lisp! (+ 3 5)
15:37:34 <pikhq> ray: C.
15:37:44 <truthair> ray: Python
15:37:45 <ray> "all of them"
15:37:47 <mauke> lisp
15:37:55 <ronc> + 3 5 6 3 should be also valid
15:38:04 <ray> :t sum
15:38:05 <lambdabot> forall a. (Num a) => [a] -> a
15:38:07 <truthair> ronc: Look into lisp :p
15:38:12 <Peaker> ronc: so in first grade, when they teach  1+1  and stuff it made no sense?  Or 3 + 4*5?
15:38:20 <mauke> *> (+) 3 5 6 3
15:38:20 <mauke> 8
15:39:01 <pikhq> Tcl doesn't. Though it can be a PITA to do infix stuff, since infix handling itself is not in the language, but rather done by the function "expr"...
15:39:33 <ronc> Peaker: no, not really, because I see it as functions being applied to arguments
15:40:48 <anRch> dons: mild obvious typo in link url for mac installer -- '....01.dmg' rather than '....02.dmg'
15:41:04 <dons> oh, thanks.
15:42:08 <dons> anRch: fixed
15:43:07 <ray> dons: or it could at least insert itself earlier in the path
15:44:11 <dons> ray: can you make a ticket for that? http://trac.haskell.org/haskell-platform/ click the green button, set the type to Windows Installer
15:44:17 <ray> sure
15:46:18 <RayNbow`> has anyone read or is planning to read http://cs.anu.edu.au/people/Ben.Lippmeier/project/thesis/thesis-lippmeier-sub.pdf ?
15:46:34 * RayNbow` has been reading the Introduction chapter the last few nights
15:47:30 <erikc> that's an awesome Thanks section
16:05:01 <sclv> reading now -- the section on nested record update is badly flawed by the omission of lenses.
16:06:04 <soupdragon> nested nerds
16:10:54 <RayNbow> sclv: lenses?
16:11:15 <sclv> a getter/setter pair. you can chain them.
16:11:37 <sclv> there's another common term for them, which I forget. accessor, perhaps.
16:11:46 <RayNbow> sclv: functional references?
16:11:48 <sclv> there are a few packages on hackage, and then there's pierce's work.
16:11:52 <sclv> yeah -- same thing.
16:12:17 <RayNbow> twanvl's blog posts made my head hurt at the end :p
16:12:39 <sclv> the notion is really simple, even though people can get goofy with it.
16:13:01 <sclv> and the neat thing is that its much more general than record update.
16:16:58 <RayNbow> sclv: more general as in it can also be applied to non-record data types (like tuples)?
16:17:17 <RayNbow> or are you referring to something even more general I can't think of?
16:18:28 <sclv> well, it can be applied to e.g. the fourth word of a sentence
16:18:56 <sclv> or it can be treated like a reversible view -- i.e. it can be applied to the whole sentence, but viewed in reverse order.
16:19:14 <sclv> or the transpose of a matrix
16:19:37 <RayNbow> hmm, is it possible to give a lens applied to the fourth word of a sentence a type in Haskell?
16:19:58 <sclv> Lens String String :-)
16:20:13 <Baughn> Specifically the /fourth/ word?
16:20:16 <sclv> or Lens [String] String
16:20:52 <sclv> obv. it does more than is contained in the type.
16:20:52 <sclv> but so does Lens SomeRecord Int, if there is more than one int in the record
16:21:27 <RayNbow> hmm, true :)
16:23:20 <Baughn> RayNbow: This is what dependent types are for, is it not?
16:25:18 <RayNbow> Baughn: dependent types are too much for me to handle :p
16:25:27 * RayNbow is not ready to tackle those :p
16:44:15 <dons> Lemmih: what did you realize?
17:05:39 <dmhouse> http://www.maths.cam.ac.uk/undergrad/catam/II/index.html someone choose me a programming project for my 3rd year! :)
17:17:07 <seydar> i keep finding myself in this channel
17:17:17 <seydar> i haven't even touched haskell in months
17:17:27 <seydar> it's like i'm coding haskell in my head
17:18:19 <jvoorhis> hey, me too
17:18:49 <jvoorhis> though i've found myself writing haskell in other languages
17:19:30 <seydar> jvoorhis: haha how do you do that?
17:19:37 <jvoorhis> lots of folds
17:20:33 <ni|> folds ftw
17:20:41 <skorpan> fold you
17:21:06 <jvoorhis> also, i make far fewer mutable things now
17:21:45 <skorpan> everything's impure in the end so why bother
17:21:58 <jvoorhis> maybe folds and immutability don't quite make up the essence of haskell, but i haven't been able to shake its influence :)
17:23:07 <jvoorhis> skorpan: minimizing IO can be helpful because side effect-free code is easier to reason about
17:23:09 <seydar> i connect with this on a whole new level: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
17:23:15 <skorpan> jvoorhis: i'm trolling ;P
17:23:54 <jvoorhis> skorpan: i figured, but i wasn't sure yet ;)
17:24:33 <skorpan> a friend of mine trolled this channel well once
17:24:51 <skorpan> possibly the best trolling of this channel ever
17:24:58 <seydar> skorpan: oh?
17:25:03 <jcd1> dmhouse: you have to pick a subset of those projects, adding up to some total?
17:25:27 <dmhouse> jcd1: yeah, I'm not sure of the exact mechanics, but I guess I'll do 3 or 4 of them.
17:25:41 <skorpan> yeah, he was asking stuff like "i did 'sort $ reverse [1..10000000000]'" but it didn't work and asked why people use haskell, since c++ is faster
17:26:18 <dmhouse> He's surely got some competition.
17:26:19 <skorpan> surprisingly many took the bait
17:26:19 <dmhouse> ?keal
17:26:19 <lambdabot> perhaps i just genius and never tested
17:26:26 <daed> hahahaha
17:26:29 <dmhouse> ?proton-torpedo
17:26:30 <lambdabot> how would haskell solve the following gnarley problem: many client distributed accross the usa, transfers must take palce in the form of file transfer, and data must be read from files, and recorded,
17:26:30 <lambdabot>  then other partners who apply taxes to this data and then give abck new files with taxes aded, then last transers to 4th parties who get us paid for the phone calls that are the product
17:27:00 <skorpan> who's keal?
17:27:02 <dmhouse> I think there's another as well, but I can't remember the name.
17:27:04 <dmhouse> ?help quote
17:27:04 <lambdabot> quote <nick>
17:27:04 <lambdabot> remember <nick> <quote>
17:27:04 <lambdabot> Quote somebody, a random person, or save a memorable quote
17:27:13 <skorpan> ?skorpan
17:27:13 <lambdabot> Unknown command, try @list
17:27:16 <skorpan> ?quote skorpan
17:27:17 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
17:27:20 <skorpan> ?quote skorpan
17:27:21 <lambdabot> skorpan says: as if everything in C isn't an ugly hack
17:27:33 <dmhouse> skorpan: there's a reference in lambdabot's source
17:27:44 <jvoorhis> ?quote jvoorhis
17:27:45 <lambdabot> No quotes match. :(
17:27:52 <jvoorhis> that's probably for the best
17:28:00 <dmhouse> ?quote dmhouse
17:28:01 <lambdabot> dmhouse says: Apparently, "python" is some sort of snake.
17:28:08 <dmhouse> Huh. Don't remember saying that.
17:28:09 <dmhouse> Huh. Don't remember saying that.
17:28:11 <dmhouse> ?quote dmhouse
17:28:11 <lambdabot> dmhouse says: Apparently, "python" is some sort of snake.
17:28:14 <dmhouse> ?quote dmhouse
17:28:14 <lambdabot> dmhouse says: Apparently, "python" is some sort of snake.
17:28:20 <dmhouse> Guess I've not said a lot of funny things.
17:28:22 <seydar> ?quote skorpan
17:28:23 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
17:28:30 <seydar> ?quote seydar
17:28:30 <lambdabot> seydar says: what's the nick of the drug addict who wrote learn you a haskell? and i mean that in the best possible way.
17:28:35 <seydar> oh jessu
17:28:41 <skorpan> BONUS that is
17:28:48 <jcd1> dmhouse: that's a cool way to run a course.  FWIW I'd do the combinatorics projects and the primality tests.
17:28:48 <seydar> you guys quoted me on that?
17:29:21 <skorpan> i just realised.. bonus in latin is boner!!
17:29:23 <seydar> ?quote Twey
17:29:24 <lambdabot> Twey says: Tuple tipple  alcohol made from distilled pairs
17:29:25 <skorpan> !!!!!!!!!
17:29:26 <dmhouse> jcd1: yeah, the primality tests looked really interesting.
17:29:30 <BONUS> hahaha :D
17:29:34 <BONUS> nice quote
17:29:37 <skorpan> @remember <dmhouse> jcd1: yeah, the primality tests looked really interesting.
17:29:37 <lambdabot> Good to know.
17:29:41 <skorpan> ?quote dmhouse
17:29:42 <lambdabot> dmhouse says: Apparently, "python" is some sort of snake.
17:29:44 <skorpan> ?quote dmhouse
17:29:44 <lambdabot> dmhouse says: Apparently, "python" is some sort of snake.
17:29:48 <skorpan> @remember dmhouse jcd1: yeah, the primality tests looked really interesting.
17:29:49 <lambdabot> Okay.
17:29:50 <skorpan> ?quote dmhouse
17:29:51 <lambdabot> dmhouse says: Apparently, "python" is some sort of snake.
17:29:54 <skorpan> ?quote dmhouse
17:29:55 <lambdabot> dmhouse says: jcd1: yeah, the primality tests looked really interesting.
17:30:02 <dmhouse> I'm sure the python thing was funny in context.
17:30:10 <dmhouse> jcd1: the percolation one under "Probablity" looks like it might be interesting, too.
17:30:24 <skorpan> the primality tests weren't funny, but people will say "I'm sure the primality test thing was funny in context"
17:30:35 <seydar> ?quote dmhouse
17:30:36 <lambdabot> dmhouse says: jcd1: yeah, the primality tests looked really interesting.
17:30:41 <dmhouse> (Although quite hard.)
17:30:55 <jvoorhis> @remember dmhouse <dmhouse> ?quote dmhouse
17:30:55 <lambdabot> Done.
17:31:26 <dmhouse> jvoorhis: hah :)
17:31:33 <dmhouse> ?remember jvoorhis @remember dmhouse <dmhouse> ?quote dmhouse
17:31:33 <lambdabot> Nice!
17:31:40 <skorpan> dmhouse... HOUSE MD???
17:32:09 <soupdragon> @remember ,()
17:32:09 <lambdabot> Incorrect arguments to quote
17:32:11 <seydar> ?quote dmhouse
17:32:11 <lambdabot> dmhouse says: <dmhouse> ?quote dmhouse
17:32:13 <soupdragon> @remember ,() ()
17:32:13 <lambdabot> It is forever etched in my memory.
17:32:18 <soupdragon> @quote ,()
17:32:18 <lambdabot> ,() says: ()
17:32:19 <lunabot>  luna: Not in scope: `says'
17:32:23 <dmhouse> skorpan: sadly, my name is just "D. M. House". Damn parents got the initials the wrong way around :)
17:32:34 <skorpan> dmhouse: you should get that fixed
17:32:54 <jvoorhis> > fix $ quote "dmhouse"
17:32:55 <lambdabot>   Not in scope: `quote'
17:32:57 <skorpan> speaking of nonsense, an anagram of my name is "nazi end god"
17:33:00 <jvoorhis> blast
17:33:22 <skorpan> when my initials are spelled out and read like a word, it's pronounced "damned"
17:33:23 * dmhouse has neither a medical degree nor an addiction to Vicodin
17:33:35 <skorpan> i'm going to HELLLL
17:34:26 <dmhouse> I do have an agreement with a recently-qualified doctor friend of mine that I'll marry her (so she'll be Dr. House) if she legally changes her name to Gregory.
17:35:18 <skorpan> Lieutenant-General Sir David George House, GCB, CBE, KCVO, MC
17:35:23 <skorpan> wow man, congrats
17:35:27 <soupdragon> heh
17:35:31 <skorpan> oh, your name isn't george
17:36:03 <skorpan> The Davidic line (also referred to as the House of David)
17:36:05 <skorpan> that's cool
17:36:41 <dmhouse> skorpan: dude, /who
17:36:56 <skorpan> what?
17:37:29 <skorpan> http://www.imdb.com/name/nm1450145/
17:37:39 <skorpan> i love your work on breaking bad dmhouse!
17:37:55 <skorpan> good night
17:37:59 <seydar> gnight kiddo
17:39:03 <seydar> mmorrow: pingpingpingping 10MB ping!
17:39:20 <seydar> mmorrow: what was the link to your fabulous lil' cheney GC?
17:39:20 <mmorrow> seydar: hey :)
17:39:40 <mmorrow> seydar: http://moonpatio.com/repos/Cheney.hs
17:40:03 <seydar> thanks!
17:40:15 <mmorrow> np
17:41:59 <fnord123> so this is late night haskell
17:42:03 <fnord123> on a friday
17:42:14 <daed> i have no life
17:42:15 <daed> that's why i'm her
17:42:17 <daed> :(
17:44:59 <seydar> dude get psyched
17:45:05 <seydar> this is gonna be the awesomest pahtay evah
17:45:15 <seydar> we're gonna bust out code
17:45:25 <seydar> and peeps are gonna be like "DUDE, you can do THAT in HASKELL?!?!?!"
17:45:28 <seydar> shit's gonna be so fast
17:45:40 <SamB> seydar: do what?
17:45:40 <Adamant> I'M PSYCHED BRAH
17:45:41 <daed> hellz yeah!!!
17:45:46 <seydar> linus torvalds himself will be like "well.... they're cheating"
17:45:46 <daed> PSYCHED FO'REALZ
17:45:50 <seydar> e'erybody
17:45:58 <SamB> seydar: what party?
17:45:59 <fnord123> the eternal september
17:46:05 <seydar> we gotses to port mercurial to haskell
17:46:09 <SamB> I didn't know Linus went to any parties
17:46:15 <seydar> SamB: he doesn't
17:46:24 <seydar> he'll skype some secret agent at our party
17:46:43 <SamB> also, I thought he liked cheating
17:46:57 <SamB> well, that is, taking performance anywhichway
17:46:58 <fnord123> why are typeclass types decld as Blah a => a -> Whatever
17:47:03 <pstickne> seydar:  no darcs?
17:47:06 <daed> if i like git, does that make me a haskell outcast?
17:47:19 <SamB> daed: not really
17:47:21 <SamB> I like git
17:47:23 <fnord123> why wouldn't the syntax be defined as Blah -> Whatever
17:47:24 <pstickne> daed:  a decentralized outcast at that!
17:47:24 <SamB> except I hate it
17:47:33 <SamB> I mean, both are true!
17:47:35 <daed> why do you hate it?
17:47:41 <daed> is this a Maybe monad?!
17:47:43 <SamB> the UI is so crazy
17:47:49 <daed> gitk?
17:47:51 <seydar> pstickne: no darcs :-( I love it, but we gotses to do something to get mucho attention to haskell
17:47:52 <SamB> I like the graph expressions
17:47:52 <daed> or porcelain
17:47:55 <SamB> the CLI
17:48:02 <daed> i <3 the cli
17:48:10 <fnord123> hm i think I answered my own question when asking that... Blah a => a -> a ensures that a is the same type that instances Blah
17:48:23 <SamB> the things that each porcelein command does, basically
17:48:33 <seydar> i'm gonna port mercurial to haskell so i can better learn it
17:48:38 <SamB> doesn't make a whole lot of sense what each one does, often
17:49:15 <SamB> I like a lot of the scripting commands, though
17:49:33 <SamB> I love git-rev-{parse,list}
17:49:41 <daed> you still use dashes?
17:49:54 <SamB> er, when referring to them, yes
17:49:56 <SamB> calling them, no
17:50:02 <daed> ahh
17:50:03 <seydar> someone's already porting git to haskell, calling it gat
17:50:05 <seydar> it's on github
17:50:06 <SamB> mostly because the manpages still have dashes in the names ;-)
17:50:10 <daed> seydar; that's awesome.
17:50:15 * daed follows project on github
17:50:39 <seydar> daed: it's pretty solid. IMHO, things could be cleaned up a little (perhaps with MONADS?!?!?!?!)
17:50:44 <SamB> gitk is awesome, too, though I wish it would eat less RAM
17:50:45 <seydar> but it's solid stuff lads
17:51:17 <daed> oh snap. monads.
17:51:33 <SamB> and it doesn't look quite as curvy as "bzr viz", but of course it works way better ;-)
17:51:40 <daed> haha
17:51:54 <seydar> daed: you find it?
17:52:19 <SamB> and bzr's repacking code really needs work
17:52:22 <daed> martine/gat
17:52:26 <daed> just have to sign in to follow it
17:52:35 <sjanssen> talking about bzr in #haskell?  Wird
17:52:42 <sjanssen> s/Wird/Weird
17:53:22 <daed> whoa, latest gat commit was nov 08
17:54:10 <seydar> daed: EXACTLY! It needs a bit of TLC
17:54:13 <seydar> and some THC
17:54:16 <SamB> I'm lobbying for a git-rev-{parse,list}(1)-like revision expression syntax for "bzr viz" at minimum
17:54:36 <daed> i'm not sure THC is the solution to a haskell git port
17:54:39 <SamB> well, and actually I would of course prefer that it also support qbzr
17:54:42 <daed> but hey maybe!
17:55:34 <SamB> the thing I love about bzr is that bzr-svn is not antisocial
17:55:57 <SamB> it encourages it's users to share their branches
17:55:58 <sjanssen> SamB: antisocial?
17:56:10 <SamB> it doesn't do horrible things when you push things back to svn
17:56:24 <daed> yeah
17:56:24 <SamB> you still end up with the same bzr branch after a normal push to svn
17:56:43 <daed> i use svn daily and want to destroy its authors with great vigor.
17:57:34 <SamB> bzr-svn makes it much easier to not want to destroy them, but to simply feel that SVN is a really bad DVCS ;-P
17:57:42 <daed> yeah
17:57:49 <daed> well git svn is fantastic until externals are involved.
17:57:59 <daed> and the svn repo maintainer wants to redefine externals on a weekly basis.
17:58:05 <daed> does bzr handle that?
17:58:20 <SamB> daed: I thankfully don't know
17:58:27 <daed> i envy you sir.
17:58:51 <SamB> I suspect it won't do anything useful when a repository uses externals
17:59:09 <SamB> I also suspect that it might sometimes crash when that happens ;-)
17:59:22 <SamB> but that jelmer would be able to fix it
17:59:22 <daed> git has "submodules" which i presume are better
17:59:27 <daed> bzr surely has something similar
17:59:46 <SamB> bzr's thing isn't sanctioned yet
17:59:56 <daed> ahh
18:00:17 <SamB> that is, they're working on something but it's not going to be in bzr 2.0's default format
18:01:02 <SamB> (bzr has this wierd tendancy to go through a lot of repository formats, though they apparantly change the default roughly every 18 months)
18:01:20 <daed> i like progress, but i rage when things break, it's so conflicting :(
18:01:43 <SamB> yeah, that's probably why they change the default so much less often then they invent a new format
18:03:22 <Twey> skorpan: You screwed up the @remember
18:03:26 <Twey> @quote <dmhouse>
18:03:26 <lambdabot> <dmhouse> says: jcd1: yeah, the primality tests looked really interesting.
18:03:43 <SamB> my bzr is a week old, so I'm beginning to wonder what happened to the automatic builds ...
18:04:09 <gnuvince> What's the Read function that I need to implement to have my own Read instance already?
18:04:21 <SamB> gnufied: readsPrec
18:09:20 <hackagebot> jmacro 0.1.2 - QuasiQuotation library for programmatic generation of Javascript code. (GershomBazerman)
18:10:20 <hackagebot> HStringTemplate 0.6.1 - StringTemplate implementation in Haskell. (SterlingClover)
18:12:53 <seydar> is anyone drunk yet?
18:20:35 <gwern> so weird. wonder why I cannot log into reddit
18:20:49 <gwern> other people apparently can, judging from the changing front page
19:01:34 <JaVak> http://blog.onlinecheapharmacy.com/  ----> http://www.onlinecheapharmacy.com/
19:02:02 <badsheepy> my word, i feel immediately compelled to medicate myself.
19:02:19 <Zeiris> :t (---->)
19:02:21 <lambdabot> parse error (possibly incorrect indentation)
19:02:52 <desp> $ops
19:04:14 <desp> @users
19:04:15 <lambdabot> Maximum users seen in #haskell: 661, currently: 561 (84.9%), active: 7 (1.2%)
19:04:17 <desp> Hrm.
19:04:20 <desp> @yhjulwwiefzojcbxybbruweejw
19:04:21 <lambdabot> Just 'J'
19:04:23 <roconnor> @where ops
19:04:23 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
19:04:23 <lambdabot> mauke
19:04:32 <desp> Ahh.
19:04:54 <roconnor> the trick is that it isn't a special command
19:04:56 <Zeiris> Surprisingly, the #python channel has 712 people... Which is weird. Number of people in the channel does not correlate to language popularity :(
19:04:59 <roconnor> just a where entry
19:05:12 <desp> I really wonder about this one, though.
19:05:13 <desp> @yhjulwwiefzojcbxybbruweejw
19:05:13 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
19:05:20 --- mode: ChanServ set +o sjanssen
19:05:24 --- mode: sjanssen set +b *!*i=JaVaK@*.adsl196-15.iam.net.ma
19:05:25 --- kick: JaVak was kicked by sjanssen (sjanssen)
19:05:29 <rovar> it corresponds to how many people actually care
19:05:34 --- mode: ChanServ set -o sjanssen
19:05:48 <soupdragon> > fix (Just . show . head)
19:05:49 <lambdabot>   Couldn't match expected type `[a]'
19:05:59 <soupdragon> > fix (Just . head . show)
19:06:00 <lambdabot>   Just 'J'
19:06:08 <Zeiris> I suppose python is easy enough not to need extensive support, and haskell is the direct opposite... Justifying the similar numbers.
19:06:20 <soupdragon> > fix (return . head . show)
19:06:22 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
19:06:22 <lambdabot>    arising from a use of...
19:06:26 <desp> @remember badsheepy my word, i feel immediately compelled to medicate myself.
19:06:27 <lambdabot> Done.
19:06:37 <sjanssen> @keal
19:06:38 <lambdabot> somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
19:06:49 <sjanssen> hahahaha
19:10:53 <SamB> sjanssen: how do you understand that well enough to find it funny?
19:14:00 <sjanssen> SamB: it's the nonsense that makes it funny
19:14:25 <sjanssen> the "dicks" vs. "disks" humor is obvious, if a bit crude
19:16:58 <dufflebunk> 'runhaskell Setup.lhs configure' tells me I'm missing regex-tdfa, but 'cabal info regex-tdfa' tells me I have it installed. Anyone have any suggestions about what I"m doing wrong?
19:20:29 <Lemmih> @seen dons
19:20:29 <lambdabot> dons is in #haskell-hacphi, #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 2h 31m 56s ago.
19:22:38 <Berengal> dufflebunk: runhaskell Setup.lhs --user
19:32:01 <Saizan> dufflebunk: use --user
19:46:59 <dufflebunk> Berengal, Saizan: Thanks, that did it.
19:58:12 <dufflebunk> Is there a list constructor? Give it an element and it returns a one element list?
19:59:02 <Saizan> > (:[]) 1
19:59:04 <lambdabot>   [1]
19:59:32 <Saizan> also return in the [] monad
20:00:00 <dufflebunk> looks like a guy eating a 1.
20:00:05 <dufflebunk> thanks
20:01:03 <ray> @let omnomnom = (:[])
20:01:04 <SamB> @quote I.saw
20:01:05 <lambdabot>  Defined.
20:01:05 <lambdabot> Philippa says:  in this case using the FFI sounds rather like masturbating with a running chainsaw
20:01:17 <SamB> @quote it.eat
20:01:17 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
20:03:23 <Badger> :o
20:03:26 <Badger> monstrous
20:03:40 <Saizan> @quote monkey
20:03:41 <lambdabot> bakert says: haskell is so weird.  you just monkey around with types until the program writes itself.
20:03:46 <Saizan> @quote monkey
20:03:46 <lambdabot> bakert says: haskell is so weird.  you just monkey around with types until the program writes itself.
20:03:51 <Saizan> gah
20:03:59 <Saizan> it's the monkey operator!
20:04:01 <ray> @thump lambdabot
20:04:02 <lambdabot> Unknown command, try @list
20:04:02 <Saizan> ..from hell
20:07:15 <eric__> @djinn
20:07:16 <lambdabot> Cannot parse command
20:07:22 <eric__> @djinn f ? a -> a
20:07:22 <lambdabot> Cannot parse command
20:07:32 <eric__> @help
20:07:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:07:37 <eric__> @help djinn
20:07:37 <lambdabot> djinn <type>.
20:07:37 <lambdabot> Generates Haskell code from a type.
20:07:37 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
20:07:46 <eric__> @djinn a -> a
20:07:46 <lambdabot> f a = a
20:07:51 <eric__> @djinn a -> b -> a
20:07:51 <lambdabot> f a _ = a
20:08:19 <erikc`> new haskell platform AND new emacs in a single week, it's all too much
20:08:27 <eric__> @djinn (a -> a) -> a
20:08:27 <lambdabot> -- f cannot be realized.
20:10:00 * SamB isn't about to upgrade to emacs 23 just yet ;-)
20:10:10 <inimino> @djinn (a -> a) -> a -> a
20:10:10 <lambdabot> f a = a
20:10:47 <eric__> @djinn a -> a -> a
20:10:47 <lambdabot> f _ a = a
20:11:37 <eric__> @djinn a -> (a -> a) -> a
20:11:37 <lambdabot> f a b = b a
20:11:48 <eric__> @djinn a -> (b) -> a
20:11:48 <lambdabot> f a _ = a
20:11:52 <copumpkin> @djinn (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:11:53 <lambdabot> f a b (c, d) = (a c, b d)
20:12:07 <eric__> @djinn a -> ([a]) -> a
20:12:07 <lambdabot> Error: Undefined type []
20:12:13 <copumpkin> @djinn (a -> b) -> (a -> c) -> a -> (b, c)
20:12:14 <lambdabot> f a b c = (a c, b c)
20:33:53 <pastah> if height == success, this is my dream for haskell: http://i29.tinypic.com/ergbyo.gif
20:34:05 <pastah> at least the first half of that
20:36:44 <beutdeuce> :)
20:36:48 <Petrosian`> pastah: That implies to me that you want Haskell to get big enough for it to all go horribly wrong?
20:37:31 <beutdeuce> say, anyone here got access to the wave sandbox?
20:42:03 <dufflebunk> I have a beach nearby...
20:43:35 <dufflebunk> pastah: WTF? Was he supposed to jump as far as he could?
20:44:29 <dufflebunk> or is that from a comercial?
20:49:10 <seydar> everyone here should be intoxicated by haskell fun
20:49:41 <dufflebunk> seydar: yeah, but I'm lazy. I haven't gotten around to the fun part.
20:51:14 <pastah> dufflebunk: if you watch closely you can see that the ramp breaks
20:52:02 <Cale> It says "Do not attempt. Controlled environment."
20:52:17 <Cale> So, perhaps the ramp was meant to break?
20:52:26 <dufflebunk> yeah, that's why I'm wondering...
20:54:14 <seydar> guys this night is gonna be fucking AWESOME
20:57:17 <soupdragon> ok
20:58:11 <seydar> hey wait a minute
20:58:22 <seydar> wouldn't saving yourself for marriage mean using haskell till mariage
20:58:26 <seydar> in that you're remaining pure?
20:58:36 <seydar> dons, do you wear a purity ring symbolizing haskell?
20:59:10 <copumpkin> o.O
20:59:26 <seydar> in that case i am no longer pure
20:59:53 <seydar> but i don't know if i want to say that to a girl: "i'm not actually pure... i've programmed in other languages besides haskell"
21:00:00 <seydar> she'll be like "whaaaa? you neeeerd"
21:01:56 <Cale> seydar: That's it, I'm cutting you off. No more drinks.
21:02:13 <seydar> copumpkin: what are you up to tonight?
21:02:19 <seydar> copumpkin: we should hang out
21:02:24 <copumpkin> I'm not on campus
21:02:28 <seydar> !!!!!
21:02:31 <seydar> blasmephy!
21:02:37 <copumpkin> lol
21:03:03 <seydar> where am you?
21:03:23 <copumpkin> in lebanon
21:03:25 <seydar> how do I extract subsets from a list?
21:03:33 <seydar> like what's the general algorithm?
21:03:41 <copumpkin> how do you mean?
21:03:41 <Cale> > subsequences [1..3]
21:03:44 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
21:03:57 <seydar> @src subsequences
21:03:57 <lambdabot> Source not found.
21:03:59 <Cale> > filterM (const [True,False]) [1..3]
21:04:01 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
21:04:13 <SamB_XP> Cale: that's the one!
21:04:19 <seydar> what's const [True, False] do?
21:04:20 <SamB_XP> I was just trying to remember how that went
21:04:29 <copumpkin> seydar: it says for each element, both select it and don't
21:04:37 <Cale> seydar: It's a function which regardless of its argument, gives the result [True,False]
21:04:41 <SamB_XP> const [True, False] = \_ -> [True, False]
21:04:49 <SamB_XP> @type filterM
21:04:50 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
21:05:21 <seydar> that's not fair
21:05:24 <seydar> how does that work
21:05:29 <Cale> seydar: Basically, in the list monad, 'running' a list, means picking an element from it in all possible ways.
21:05:38 <SamB_XP> so, you get one list where you filter that item in, and one where you filter it out
21:05:42 <seydar> oh dudezor
21:05:46 <seydar> you just made all combinations
21:05:48 <seydar> llama
21:05:59 <Cale> seydar: filterM is a filter which works in any monad where the condition is a monadic computation.
21:06:27 <seydar> if i have [1, 2, 3, 0, 0, 0, 0, 0, 5, 7, 0 ,0 8], how can I get [[0,0,0,0,0], [0, 0,]]
21:06:27 <Cale> seydar: So I use the condition that regardless of the element's value, try the possibilities True and False
21:06:52 <Cale> > filter ((==0) . head) . group $ [1, 2, 3, 0, 0, 0, 0, 0, 5, 7, 0 ,0 8]
21:06:53 <lambdabot>   Add a type signature
21:07:03 <Cale> > filter ((==0) . head) . group $ [1, 2, 3, 0, 0, 0, 0, 0, 5, 7, 0, 0, 8]
21:07:05 <lambdabot>   [[0,0,0,0,0],[0,0]]
21:07:17 <seydar> ah, the group command is your secret
21:07:36 <seydar> what's group's runtime?
21:07:40 <Cale> linear
21:07:49 <seydar> @src group
21:07:49 <lambdabot> group = groupBy (==)
21:07:54 <seydar> @src groupBy
21:07:55 <lambdabot> groupBy _  []       =  []
21:07:55 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
21:07:55 <lambdabot>     where (ys,zs) = span (eq x) xs
21:09:01 <Saizan> i've a piece of code that goes like all p xs but where i want False if null xs, it feels so weird
21:09:03 <Cale> Basically, it takes the first element of the remaining elements of the list, starts a new group with that, and then splits the list at the point where elements stop being equal to that first one, and that's the rest of the first group, and the case to recurse on
21:09:08 <seydar> so remember those GCs i kept talking about? well i'm actually trying to write one now on a fake heap
21:12:07 <resistor> hello folks
21:13:39 <resistor> question:  i have a function where i'm using the list monad to evaluate what's basically a triply-nested loop.  the problem i'm running into is that, in the outermost loop, if the inner loops returned the empty list, i need to return something different
21:13:58 <resistor> the best solution i have is to split the inner loops into a helper function, like so: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3127#a3127
21:14:02 <resistor> but it seems kind of ugly
21:14:09 <resistor> i was wondering if there's a better way to write it
21:14:59 <glguy> in the logict library, you'd use ifte
21:15:30 <glguy> ifte innerElements (\ e -> stuff ) ( i_didnt_have_any_es)
21:15:40 <centrinia> resistor: What is wrong with replacing line 18 with: else [ws]
21:15:43 <glguy> (if then else)
21:16:22 * resistor ponders
21:16:25 <centrinia> @let ifte t a b = if t then a else b
21:16:27 <lambdabot>  Defined.
21:16:46 <soupdragon> @let bool = ifte
21:16:47 <lambdabot>  <local>:23:7:
21:16:47 <lambdabot>      Ambiguous occurrence `ifte'
21:16:47 <lambdabot>      It could refer to either...
21:16:48 <resistor> centrinia: that seems like it would work.  now i feel stupid :-/
21:17:09 <resistor> wait, no, it won't
21:17:09 <seydar> did you try distributing the load to multiple servers?
21:17:18 <seydar> make good use of skynet
21:17:26 <seydar> *PEACE*
21:17:27 <resistor> centrinia: that'll produce multiple copies of ws in the final list
21:17:58 <centrinia> Wait, that wasn't what I was afraid of.
21:18:26 <centrinia> Why would it produce multiple copies of ws in the final list?
21:18:48 <resistor> because, for each ws, it iterates through all occupied coors and all start-end pairs
21:18:58 <resistor> each time that double iteration fails the if...
21:18:59 <centrinia> Oh.
21:19:04 <resistor> it'll insert a copy of ws into the list
21:19:55 <resistor> glguy: is there documentation for that somewhere?
21:20:04 * resistor is relatively new to this stuff
21:20:24 <resistor> centrinia: this the logic for a board game with checkers-like rules
21:20:32 <michaelfeathers> let useless = concat . group
21:21:03 <resistor> given a set of board states, this generates the set of board states that are reachable by a single jump
21:21:18 <resistor> if there are no jumps for a given input state, the input state is carried over to the output
21:25:59 <resistor> hrm
21:26:07 <resistor> it doesn't look like ifte would make it much simpler
21:30:40 <edwardk> ok, i pared down monoids to a small core, uploading to hackage now
21:30:56 <edwardk> i'll move the rest in an -extras package
21:32:58 <copumpkin> :o
21:33:02 <copumpkin> zomg
21:33:19 <edwardk> basically all the ring stuff, etc is punted off to another module
21:33:28 <edwardk> er package
21:33:42 <edwardk> so it can build without category extras, without defining a million 3rd party instances, etc.
21:33:58 <edwardk> base, array, bytestring, fingertree, text, parallel, and containers is all it needs now
21:34:00 * copumpkin is building his own algebra library too!
21:34:05 <copumpkin> but it's rather impractical right now :P
21:34:08 <edwardk> hah
21:34:14 <edwardk> i am too, but its called 'kata' ;)
21:34:21 <copumpkin> impractical in the sense that it has uncallable functions in it
21:34:40 <soupdragon> uncallable ?
21:34:40 <edwardk> and i was sick of bringing in category-extras to get monoids to build ;)
21:34:50 <edwardk> using them as proof constructors?
21:35:02 <copumpkin> soupdragon: functions of a MPTC that only mention a subset of the MP in their signature :P
21:35:15 <copumpkin> class Moo a b where moo :: a -> a
21:35:17 <copumpkin> that kind of stuff
21:35:20 <copumpkin> (no fundeps)
21:35:21 * centrinia is only fixing up bugs in some pre-existing algebra libraries in the numeric-prelude! :(
21:35:24 <edwardk> copumpkin: ugly
21:35:30 <copumpkin> edwardk: yeah, I love it
21:35:30 <edwardk> thats a sign you need a finer grained class system
21:35:40 <copumpkin> edwardk: indeed :)
21:35:49 <copumpkin> edwardk: trying to figure out a nicer way to do it
21:35:57 <soupdragon> oh weird
21:36:14 <copumpkin> yeah :P
21:36:18 <edwardk> its one of the things i had to wrestle with in category-extras, etc. how to avoid those cases.
21:36:19 <centrinia> class Moo a where moo :: a -> a
21:36:29 <edwardk> thats where the crazy PFunctor and QFunctor stuff comes from
21:36:29 <copumpkin> centrinia: nope, the b is important :P
21:36:49 <edwardk> for when I _know_ I can call 'second' or 'first' but I don't know if the other half is covariant/contravariant, etc.
21:37:08 <centrinia> class Moo a b where { moo :: a -> a; burger :: b }
21:37:17 <copumpkin> centrinia: I just need to figure out a way of specifying the b I want to use without a bogus argument
21:37:19 <copumpkin> centrinia: that won't fix it
21:37:29 <edwardk> copumpkin: then all you can do is witness the b with a phantom argument or newtype noise
21:37:36 <copumpkin> edwardk: yeah :/
21:37:50 <copumpkin> edwardk: for a little while I was considering implicit parameters as a way of specifying it implicitly
21:37:55 <edwardk> moo :: a -> Phantom b -> a ; newtype Phantom a = Phantom ()
21:37:55 <copumpkin> but it turned ugly
21:38:03 <copumpkin> cause implicit parameters don't work the way I'd like them to
21:38:10 <edwardk> or data Phantom = Phantom
21:38:14 <centrinia> Why is b important?
21:38:19 <edwardk> er data Phantom a = Phantom
21:38:38 <copumpkin> centrinia: well for my two-binop structures, b (and c) specify which binary operations you're using
21:39:00 <copumpkin> I didn't want newtypes
21:39:04 <copumpkin> but I might have to give in
21:39:55 <edwardk> ultimately i think you'll have to or you won't be able to use the library you construct ;)
21:40:04 <edwardk> nothing will be able to call into it, etc. ;)
21:40:06 <copumpkin> yeah :P
21:40:17 <copumpkin> but its "fidelity" right now makes me happy
21:40:26 <edwardk> and then you can port it to kata later and not worry about it ;)
21:40:31 <centrinia> Weird, why would you want to specify the operators in terms of those type variables?
21:40:31 <copumpkin> the fact that it can't be used for anything useful is of secondary importance ;)
21:40:46 <copumpkin> centrinia: how else would I do it?
21:41:02 <copumpkin> I'd love to be able to pass function values :P
21:41:18 <centrinia> Have type variables that represent the types of elements that are in the structure.
21:41:24 <edwardk> copumpkin: the other question is why is your class not class Moo a b | a -> b; then you can have moo :: a -> a all you want
21:41:41 <copumpkin> edwardk: yeah, but that's not necessarily true
21:42:01 <copumpkin> I mean, the fundep doesn't make sense
21:42:02 <edwardk> thats what newtypes are for ;) to get in and out of the structure.
21:42:05 <copumpkin> :P
21:42:17 <centrinia> class (Field s) => VectorSpace s v where { (*) :: s -> v -> v; (+) :: v -> v -> v; }
21:42:34 <copumpkin> centrinia: yeah, but you're basically specifying say a ring only by the set involved, and not the two binary operations
21:42:50 <copumpkin> or in that case a field
21:43:08 <copumpkin> I didn't want to be that limiting :)
21:43:08 <edwardk> copumpkin: yeah. thats what the newtypes are for. they are yout 'module selection mechanism' in haskell.
21:43:22 <copumpkin> edwardk: yeah, I've done that approach before
21:43:29 <copumpkin> it just felt ugly and I wanted to experiment with other approaches
21:43:56 <copumpkin> maybe I'll go and reimplement my classes in agda or something
21:44:04 <edwardk> in kata/ML you just make a bunch of modules, and have to name them explicitly or open them. in haskell you have to use fundeps/class associated types and use newtypes to change the dispatch.
21:44:11 <copumpkin> yeah
21:44:13 <copumpkin> :/
21:44:24 <edwardk> you could also do one other thing =)
21:44:25 <edwardk> muahaha
21:44:30 <copumpkin> :o?
21:44:47 <copumpkin> I was going to implement my own impure implicit variable approach
21:44:50 <copumpkin> but that was a last resort :P
21:44:54 <edwardk> import Data.Reflection and reify your operations into an explicit dictionary that you can reflect back down. so you turn the terms for your operations into a type.
21:45:09 <copumpkin> ah, I was wondering if there was a way of doing that
21:45:18 <edwardk> yeah its in the reflection library i put on hackage
21:46:04 <copumpkin> ah neat
21:47:24 <edwardk> i think someone asked for an explicit monoid from a given user supplied function/value on haskell-cafe and i gave a reply with an example of the usage of that lib a few months back
21:47:46 <edwardk> http://www.mail-archive.com/haskell-cafe@haskell.org/msg57747.html
21:47:52 <centrinia> copumpkin: How about class Moo a b where { moo :: a -> a; oom :: b -> b; } :p
21:48:02 <copumpkin> centrinia: that doesn't help me call moo
21:48:05 <copumpkin> or oom
21:48:39 <edwardk> copumpkin: give up on the typeclasses and plumb around explicit dictionaries
21:48:48 <copumpkin> yeah, I was thinking of that too
21:48:55 <edwardk> data Moo a b = Moo { moo :: a -> a, oom :: b -> b }
21:49:01 <copumpkin> yeah
21:49:25 <copumpkin> and then I can pass that around with a hacky impure implicit system :P
21:49:25 <edwardk> then you can pass those as implicit parameters and make people sick ;)
21:49:31 <edwardk> hah
21:49:32 <copumpkin> nah, not just implicit parameters
21:49:36 <copumpkin> cause they don't behave the way I want them to
21:49:44 <copumpkin> I'll invent my own
21:49:47 <copumpkin> :P
21:49:59 <edwardk> look at the reflection stuff, it generally does what you should do to pass around defaults, etc.
21:50:00 <JamesSanders> is there any librarys or anything that can help me visualize tree data structures in Haskell?
21:50:07 <copumpkin> Data.Tree
21:50:11 <copumpkin> @hackage containers
21:50:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/containers
21:50:24 <copumpkin> http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Tree.html#v%3AdrawTree
21:50:38 <edwardk> JamesSanders: depends on what you want to do with it. vacuum can take a haskell data structure and reify it as a graphviz graph for instance.
21:51:25 <copumpkin> edwardk: btw, you never explained how to use StableName to do some massive knot-tying to represent graphs without fake references
21:51:27 * Saizan uses a ReaderT and HList to pass dictionaries around
21:51:55 <JamesSanders> I'm basically just experimenting with building Trees and find it kinda hard to easily see whats going on with larger trees
21:52:42 <edwardk> well, i use it to rederive sharing information, but you'd only be able to use it to get things like extracting that you have edges that share the same object, and you could only chase from a given starting point, so you'd need all the starting points in the graph somehow
21:52:43 <edwardk> hrmm
21:53:58 <edwardk> basically identify vertices by comparing if they have the same stable name, and identify edges that connect them by comparing the stable names of the endpoints. its all terrible, but you could probably do it all in a let expression or something
21:54:03 <Berengal> > drawTree (Node "foo" [Node "bar" [Node "baz" []], Node "quux" []])
21:54:05 <lambdabot>   "foo\n|\n+- bar\n|  |\n|  `- baz\n|\n`- quux\n"
21:54:08 <edwardk> and have the compiler rewrite your graph into oblivion ;)
21:55:07 <edwardk> fake references are the right way to do it though
21:55:40 <copumpkin> hmm
21:55:54 <copumpkin> it'd still be awesome to have a graph that is directly represented in haskell data
21:56:05 <copumpkin> with cycles and all
21:56:13 <copumpkin> just for haskell-fu sake
21:56:26 <edwardk> vacuum [1..2]
21:56:29 <edwardk> =)
21:56:38 <copumpkin> well that's what I mean
21:56:47 <copumpkin> vacuum would show the actual graph structure you want to represent
21:56:54 <copumpkin> rather than the IntMap you have hiding behind the scnes
21:56:59 <copumpkin> or whatever it's using
21:57:35 <edwardk> those are probably hashed stablenames or something
21:57:47 <edwardk> mmorrow would know, obviously
21:58:13 <Saizan> vacuum messes with the pointers in the binary representation directly
21:58:43 <edwardk> ah
21:58:51 <copumpkin> I dunno, I think it would be cool :P
21:59:06 <edwardk> hrmm so a GC mid-vacuum would er... suck
21:59:23 <copumpkin> I think he's using stablenames too
22:01:44 <edwardk> ok. i've officially dumbed down monoids and will release monoid-extras with the rest of the stuff later
22:01:50 <Saizan> http://hackage.haskell.org/packages/archive/vacuum/0.0.95/doc/html/src/GHC-Vacuum-Internal.html <- the gory details
22:01:59 <edwardk> http://hackage.haskell.org/package/monoids-0.2.0
22:02:04 <copumpkin> zomg
22:02:31 <hackagebot> monoids 0.2.0 - Monoids, specialized containers and a general map/reduce framework (EdwardKmett)
22:02:50 <copumpkin> wow, edwardk == hackagebot
22:03:08 <edwardk> hah
22:03:32 <Apocalisp> @hoogle (a -> b -> m c) -> m a -> m b -> m c
22:03:32 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
22:03:33 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
22:03:33 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
22:03:50 <edwardk> i needed an alter-ego for when i wasn't spouting category theory or heresy about functional programming and type systems in general so people would know when to pay attention ;)
22:03:58 <copumpkin> lol
22:05:28 <edwardk> lol and of course i missed a version bump on text ;)
22:07:32 <hackagebot> monoids 0.2.0.1 - Monoids, specialized containers and a general map/reduce framework (EdwardKmett)
22:08:24 <edwardk> and with that i can return to developing kata without 9 million dependencies
22:13:48 <Apocalisp> How do I implement the type (a -> b -> c) -> m a -> m b -> m c?
22:14:01 <Apocalisp> Sorry,  (a -> b -> m c) -> m a -> m b -> m c?
22:14:24 <dufflebunk> IS there a delinter for haskell?
22:15:16 <copumpkin> @hoogle+
22:15:57 <Apocalisp> @type (join .) . liftM2
22:15:58 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
22:15:59 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
22:15:59 <lambdabot>     In the second argument of `(.)', namely `liftM2'
22:16:21 <Saizan> @type ((join .) .) . liftM2
22:16:23 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
22:16:58 <Apocalisp> Close
22:17:07 <copumpkin> ?
22:17:07 <Apocalisp> Thanks, Saizan
22:17:08 <ski> sometimes it might be nice with a family `bindM2',`bindM3',`bindM4', et.c. for this ..
22:18:18 <ski> (or maybe s/bind/extend/ ..)
22:19:36 <Saizan> i've needed bindM2 sometimes, but not the others
22:22:30 <mauke> :t fmap (liftM2 (,)) . (=<<) . uncurry
22:22:32 <lambdabot> forall a2 (m :: * -> *) b a b1. (Monad m) => (a -> b1 -> m b) -> m (a, b1) -> m a2 -> m (b, a2)
22:22:46 <vav> dufflebunk: for source: http://hackage.haskell.org/package/hlint (needs ghc-6.10*)  -- for files, dunno.
22:23:39 <Apocalisp> @let bindM2 = fmap (liftM2 (,)) . (=<<) . uncurry
22:23:41 <lambdabot>  Defined.
22:24:46 <mauke> :t bindM2
22:24:47 <lambdabot> forall a b1 (m :: * -> *) b a2. (Monad m) => (a -> b1 -> m b) -> m (a, b1) -> m a2 -> m (b, a2)
22:24:52 <mauke> that looks wrong
22:25:07 <dufflebunk> vav: Cool! That's even more than I needed.
22:27:28 <vav> dufflebunk: there's emacs integration hlint around somewhere, not sure about other editors/leksah
22:28:04 <mauke> :t (. liftM2 (,)) . fmap . (=<<) . uncurry
22:28:06 <lambdabot> forall (m :: * -> *) b a b1. (Monad m) => (a -> b1 -> m b) -> m a -> m b1 -> m b
22:28:52 <ski> @type curry . (. uncurry (liftM2 (,))) . (=<<) . uncurry
22:28:53 <lambdabot> forall (m :: * -> *) b a b1. (Monad m) => (a -> b1 -> m b) -> m a -> m b1 -> m b
22:29:24 <mauke> @unpl (. liftM2 (,)) . fmap . (=<<) . uncurry
22:29:24 <lambdabot> (\ i u -> fmap (\ r -> r >>= (uncurry i)) (\ e -> u >>= \ b -> e >>= \ a -> return ((,) b a)))
22:29:48 <mauke> @unpl (. liftM2 (,)) . (.) . (=<<) . uncurry
22:29:49 <lambdabot> (\ l x i -> (x >>= \ b -> i >>= \ a -> return ((,) b a)) >>= (uncurry l))
22:31:02 <dufflebunk> vav: I use emacs so I'll have to try that out too
22:32:32 <ski> @type \f -> curry . (. uncurry f)
22:32:33 <lambdabot> forall a b c c1. (a -> b -> c1) -> (c1 -> c) -> a -> b -> c
22:33:19 <mauke> :t (.) . (.)
22:33:19 <ski> @type \f -> ((f .) .)
22:33:20 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
22:33:21 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
22:34:27 <copumpkin> @unpl \f -> curry . (. uncurry f)
22:34:27 <lambdabot> \ f d -> curry (\ h -> d (uncurry f h))
22:38:14 <FunctorSalad> @type join (?f <$> ?x1 <*> ?x2 <*> ?x3)
22:38:15 <lambdabot> forall a a1 a2 (m :: * -> *) a3. (?f::a -> a1 -> a2 -> m a3, ?x1::m a, Applicative m, ?x2::m a1, ?x3::m a2, Monad m) => m a3
22:38:27 <FunctorSalad> (bindM3)
22:41:16 <mmorrow> copumpkin: vacuum's literally extracting the heap graph
22:41:25 <copumpkin> ah
22:41:25 <ski> @type (. liftM2 (,)) . (.) . (=<<) . uncurry
22:41:27 <lambdabot> forall (m :: * -> *) b a b1. (Monad m) => (a -> b1 -> m b) -> m a -> m b1 -> m b
22:42:12 <mmorrow> copumpkin: ooh, and i figured out earlier how to vacuum directly to an asm file containing all the closures with sharing retained !
22:42:30 <copumpkin> mmorrow: how do you mean to an asm file?
22:42:38 <mmorrow> http://moonpatio.com/repos/myIntMap.s
22:42:39 <ski> (.. ah, that's the same as mauke's version ..)
22:42:51 <mmorrow> copumpkin: check out the comment at the top of
22:43:01 <mmorrow> http://moonpatio.com/repos/GenAsm.hs
22:43:09 <mmorrow> it show the whole process
22:43:53 <copumpkin> hmm
22:44:05 <mmorrow> that func in GenAsm vacuum whatever, then generates a .s containing the in-memory-closure rep of that heapgraph + a .hs that does addrToHValue# on the root
22:44:39 <mmorrow> so "vacuumToAsmAndHsStub (fix (0:))"
22:44:39 <copumpkin> oh nice
22:44:44 <copumpkin> I see
22:44:45 <mmorrow> err
22:44:47 <mmorrow> yeah
22:44:58 <mmorrow> you literally can save the heap for later
22:45:09 <copumpkin> that sounds pretty awesome
22:45:33 <mmorrow> (but you can't serialize frozen applications of functions though, since unpackClosure# doesn't give that info)
22:45:37 <ski> but it forces, yes ?
22:45:41 <copumpkin> yeah, I was wondering about that
22:45:48 <mmorrow> so "fix (0:)" works, but not "[0..]"
22:46:04 <copumpkin> mmorrow: you need to build this into GHC so you can get that info too! :D
22:46:11 <ski> and neither `\x -> x*x', i assume
22:46:21 <mmorrow> copumpkin: totally, that would be sweet
22:46:50 <mmorrow> ski: yeah, unfortunately only graphs made up of all data constructors can be done like this
22:46:54 <mmorrow> (at the moment)
22:47:12 <ski> (s/graphs/finite graphs/)
22:48:03 <mmorrow> yeah, just because you can't get at the internals of APs or PAPs
22:48:28 <seydar> i have a morals question
22:48:39 <seydar> i just told another channel i was going to bed so i could hang out here
22:48:41 <seydar> is that wrong?
22:48:50 <ski> if something like this would be supported, one need to decide on where one can import exported values
22:48:53 <copumpkin> seydar: yeah
22:49:03 <copumpkin> seydar: which channel?
22:49:20 <mmorrow> ski: how do you mean?
22:49:23 <seydar> copumpkin: #rubinius. only one person was talking with me, and he had kinda drifted off
22:49:28 <copumpkin> ah
22:49:31 <copumpkin> you're fine then
22:49:34 <copumpkin> it's just rubinius
22:49:37 <ski> same process ? same program on same platform ? different platforms ? different programs ? different compiler versions ?
22:50:11 <ski> (different platform entails different computer)
22:50:20 <jrty> if I have a type like, data Foo = A | B; how can I extend this to a new type where A, B, and C are constructors for the type?
22:50:30 <mmorrow> copumpkin, ski: oh yeah, and this is the .hs that was generated along with myIntMap.s that reifies the vacuumed value http://moonpatio.com/repos/MyIntMap.hs
22:50:57 <copumpkin> I'd never noticed addrToHValue#
22:51:02 <copumpkin> seems interesting
22:51:10 <copumpkin> if massively hackish
22:51:11 <copumpkin> :P
22:51:31 <mmorrow> it literally turns an arbitrary pointer into a haskell value
22:51:45 <mmorrow> so it bettar point to a valid closure.. :)
22:51:56 <copumpkin> sounds pretty sweet
22:51:59 <pstickne> seydar:  what a good "IRC friend" you are :(
22:52:04 <copumpkin> I wonder how much evil could be done with that
22:52:25 <seydar> pstickne: g2g, "going to bed"
22:52:32 <seydar> no really, i'm legit going to bread now
22:52:38 <copumpkin> :o
22:52:38 <seydar> gnight everybody
22:52:42 <copumpkin> don't sleep in bread
22:52:44 <copumpkin> it's bad for you
22:52:48 * pstickne wonders how long seydar will have to rise
22:52:50 <seydar> copumpkin: watch more simpsons
22:52:55 <ski> (also, this shows the `IO' in `getArgs' can be a good idea)
22:52:59 <seydar> WAIT
22:53:17 <seydar> is there a nice fancy lil' option parsing lib, or does everyone just roll their own in haskell?
22:53:27 <copumpkin> there's a nice fancy lil option parsing lib
22:53:29 <mauke> @hoogle getopt
22:53:29 <lambdabot> module System.Console.GetOpt
22:53:29 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
22:53:29 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
22:53:38 <seydar> thank you
22:53:42 <seydar> gnight everybody
22:53:48 <seydar> copumpkin: i expect to see you a lot this coming term
22:55:27 <mmorrow> ski: ah yeah, so the only reason that the assembler needs to be involved currently is to generate a .o so the linker can fill in the addresses of the rts labels <...>_static_info that you need, but you could also do these relocations yourself, in which case you can skip the .s altogether and e.g. send the bits over the wire (along with some reloc info), then re-link on the other side
22:56:10 <mmorrow> (ignoring any other things you'd have to think about..)
22:57:09 <ski> it might be nice to compare with relevant systems in other languages
22:57:25 <ski> like the marshalling in OCaml, e.g.
22:57:28 <mmorrow> ski: yeah, and you'd have to assume that the prog that it came from and the prog that it's being injected into both are using/assuming the same closure layout (i.e. <..>_static_info are the same in both runtimes for a given value of "<..>")
22:57:40 <ski> or Alice / Oz
22:58:05 <ski> (s/Alice/Alice ML/)
22:58:17 <mmorrow> oh yeah, Alice seems interesting, i came across that a while ago
22:58:23 <mmorrow> but forgot about it
22:58:38 <mmorrow> ski: smlnj too
22:59:01 <dufflebunk> @src bracket
22:59:01 <lambdabot> bracket before after thing = block $ do
22:59:01 <lambdabot>     a <- before
22:59:01 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
22:59:01 <lambdabot>     after a
22:59:01 <lambdabot>     return r
22:59:02 <ski> possible (i didn't know it had marshalling)
22:59:54 <mmorrow> yeah, smlnj does both import of saved heaps, export of the current heap, a heap2asm cli util, serialization of functions, import of functions, ...
22:59:59 <ski> O'Caml supports marshalling over network into another process, but i think it must be the same program (at least if closures is marshalled) with same compiler version & platform
23:00:19 <gwern> dang, why do the other ML langs get all the nice compiler features
23:00:27 <gwern> and we're stuck with the latest type theoretical toy
23:00:49 <Berengal> We have some parallelism stuff too
23:01:07 <mmorrow> ski: oh nice, i haven't really looked at much ocaml stuff. do you mean in general, or some particular compiler/rts implements this?
23:01:22 <Cale> How well does O'Caml support SMP?
23:01:40 <ski> Alice ML allows marshalling packages that will get explicitly (iirc) linked to imported structures on the other side .. iirc other references to e.g. library function will implicitly communicate backwards over the network link
23:02:21 <Berengal> I want to send arbitrary functions/closures over the wire to other haskell apps...
23:02:30 <gwern> ski: sounds lazy
23:02:34 <mmorrow> ski: Alice ML looked really cool from what i remember reading a while ago
23:02:44 <ski> mmorrow : there is only one O'Caml implementation (maybe there's some experimental version too, but that's basically it)
23:03:03 <ski> Cale : i don't know
23:03:07 <mmorrow> ski: ah, ok
23:04:00 <ski> mmorrow : *nod*
23:07:51 <Saizan> is O'Caml interpreted or compiled or ..?
23:08:57 <Elly> I suspect the answer is "that depends"
23:09:16 <mauke> ocamlopt.opt
23:10:47 <ski> native compiler + bytecode compiler
23:14:13 <ski> Module Marshal <http://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html>
23:16:55 <vegai> what's all this ML then?
23:19:33 <vegai> huh, I hadn't seen alice ml before. Cool stuff
23:20:31 <ski> Distribution <http://www.ps.uni-sb.de/alice/manual/distribution.html>
23:21:14 <vegai> ski: yeah, I was reading just that
23:21:46 <vegai> not revolutionary but nifty nevertheless
23:34:33 <ski> Joachim Durchholz' FPL Marshalling Survey <http://web.archive.org/web/20070706205236/http://durchholz.org/jo/fpl-marshalling-survey/index.html>
23:35:03 <ski> (appeared also on comp.lang.functional)
23:35:31 <ski> (note that this one is somewhat dated, though)
23:46:35 <mmorrow> ski: nice link
23:47:12 <mmorrow> ski: the table at the bottom is particularly nice
23:48:04 <mmorrow> hmm, i guess they're considering `Show' for the Haskell case..
23:50:03 <gwern> wow, reddit is so broken
23:50:14 <gwern> 2 days now?
23:52:15 <Gracenotes> gwern: suddenly started working for me earlier
23:52:40 <gwern> Gracenotes: some of it works - if I refresh enough. but checking a reply with a 'context' link is irrevocably broken
23:52:45 <gwern> and I think my votes are getting lsot
23:54:31 <ski> (FPL Marshalling survey, third revision <http://groups.google.com/group/comp.lang.functional/browse_thread/thread/3b93194f217e144f/12ca9d4de6506201>)
23:54:42 <Gracenotes> no! not the votes!
23:56:46 <hydo> Assuming there are others that use flymake-mode, how do you handle multiple project files in your flymake script for haskell?
