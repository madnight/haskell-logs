00:34:15 <Zeiris> @src putStr
00:34:15 <lambdabot> putStr s  = hPutStr stdout s
00:34:31 <Zeiris> @src hPutStr
00:34:32 <lambdabot> Source not found. stty: unknown mode: doofus
00:35:51 <Zeiris> Is putStr REALLY defined in terms of putChar? Wouldn't that not be buffered, and result in horribly slow stdout writes?
00:41:29 <Heffalump> why wouldn't it be buffered?
00:43:58 <Zeiris> That... Is a good question. putChar isn't guaranteed to be instant?
00:45:40 <Heffalump> not unless you set the handle to NoBuffering, correct
01:04:39 <Cale> There really ought to be a withBuffering/withEcho/etc. for convenience.
01:06:20 <Cale> (to set the buffering/echo locally, and reset it when done)
01:25:47 <EnglishGent> morning :)
01:26:58 <Heffalump> 'lo
01:27:07 <EnglishGent> hi Heffalump :)
01:28:12 <preflex> "@where ops"
01:33:48 <elbar> @bots
01:33:48 <lambdabot> :)
01:33:48 <lunabot>  :)
01:35:01 <FunctorSalad> :)
01:35:09 <elbar> ;)
01:37:25 <medfly> hi guys, my friend asked me to write something for his website and I would like to use mostly Haskell for it, I imagine his server might be a bit limited, what do I need to do to make sure it will run?
01:38:24 <elbar> i guess dedication is the answer :P
01:38:53 <medfly> no I mean, I imagine the worst case scenario is that somehow the server doesn't want to run what I wrote, and I wouldn't like that to happen
01:39:00 <medfly> (even though it is working properly)
01:41:57 <FunctorSalad> are you asking for hardware specs? (not that I had an answer)
01:42:42 <medfly> uhh... well, I imagine some of those website hosts limit what can be run on the server
01:42:50 * EnglishGent is a newbie to haskell & so probably cant answer the question - but is also a bit confused as to exactly what you mean
01:43:00 <elbar> > 6*7
01:43:01 <lambdabot>   42
01:43:11 <Heffalump> if you can run arbitrary binaries you can build them elsewhere and upload them
01:43:21 <Heffalump> if it's just PHP or something then you're stuck
01:43:47 <EnglishGent> if it allows servlets there's a Haskell-to-Java bytecodes compiler
01:43:55 <EnglishGent> but I think it's flagged as still experimental
01:43:59 <medfly> okay, thanks
01:44:04 <EnglishGent> most decent webhosts provide you with a virtual box though
01:44:06 <medfly> I will try to ask that :)
01:44:12 <EnglishGent> and you can run arbitrary binaries :)
01:44:30 <Heffalump> I don't think it's usable (Haskell -> JVM)
01:45:24 <mjs22> I'm tired of seeing perfectly reasonable code emit stack overflows for no particular reason.  It's irritating to have code that runs just fine under SM/NJ die of a stack overflow when ported to Haskell....
01:45:43 <mjs22> I need to learn the art of where to put $!.  Or `seq`.
01:45:56 <Heffalump> can you give an example of such perfectly reasonable code?
01:46:09 <mauke> as a first step, you should get rid of tail recursion/accumulators
01:46:09 <Heffalump> I think the community as a whole needs to document that art better
01:46:27 <Heffalump> well, if you accumulate values, do so strictly
01:46:31 <Heffalump> bang patterns are good
01:46:40 <FunctorSalad> rnf might be convenient too
01:46:52 <Heffalump> rnf is convenient but a rather large hammer
01:46:53 <mjs22> Heffalump: Exactly.  I know it's quite possible, but it's not obvious from the tutorials and literature out there how to adopt the "right" coding style.
01:46:55 <FunctorSalad> the derive package can even derive it
01:46:58 <dibblego> I want to give instructions for users of a Haskell program -- is it fair to appropriate that if The Haskell Platform is unavailable to them to install GHC then cabal-install? i.e. am I missing something?
01:47:08 <Heffalump> dibblego: I think that's right
01:47:14 <Heffalump> though in future GHC might be shorn of libraries
01:47:25 <Heffalump> but GHC then cabal-install then cabal-install haskell-platform should do the trick
01:47:42 <dibblego> righto thanks
01:48:54 <mjs22> Heffalump: I think that's it -- I'm not sure I'm accumulating values in a strict fashion.  Off to emacs....
01:49:30 * EnglishGent waves to the fellow emacs user :)
01:50:31 <FunctorSalad> you know what would be a neat feature for haskell-mode? auto-insert a "case" statement skeleton
01:50:41 <FunctorSalad> but I don't know the elisp
01:54:58 <dibblego> @seen dcoutts
01:54:58 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow, #haskell-soc and #haskell-iphone. I last heard dcoutts speak 11h 14m ago.
01:58:15 <Peaker> FunctorSalad: elisp sucks :-(
01:59:28 <Peaker> I especially hate how side-effects are buried deep inside evaluation expressions, so you don't really get a sense of the imperative program
02:00:03 <Peaker> I think a mix of functional and imperative, where the imperative program is just buried as evaluation side-effects and nested deep inside expressions is worse than either functional or imperative programming
02:00:47 <Heffalump> if you write externally visible side-effects that way, you deserve all you get
02:01:47 <hackagebot> Lastik 0.2 - A library for compiling programs in a variety of languages (TonyMorris)
02:03:43 <Peaker> Heffalump: "let" doing lots of nesting in ELisp is part of the problem, you sometimes have to let/lambda/loop some, and then you're way inside by the time you get to describe what effects you want
02:04:16 <Peaker> though that is relatively decent, usually you have side-effecting getters that are just buried deep as arguments of functions and stuff
02:04:27 <FunctorSalad> Peaker: is elisp any worse than other non-pure langs there?
02:04:52 <Peaker> FunctorSalad: ELisp is a bad imperative language, IMO.  Python is a much nicer imperative language, for example
02:05:04 <shachaf> FunctorSalad: Well, it's dynamically scoped.
02:05:12 <FunctorSalad> *non-pure functional languages
02:05:23 <FunctorSalad> (since you were referring to the mix specifically)
02:05:27 <Peaker> FunctorSalad: I don't think "non-pure functional languages" are really very different to imperative languages
02:05:38 <Peaker> FunctorSalad: they just encourage this horrible style of nesting side effects deep inside :(
02:05:48 <mjs22> Python?  I guess, if you're not concerned with type checking...
02:06:13 <Peaker> mjs22: ELisp has no type-checking either, except runtime tag-checking (like Python's). Except Python is far more helpful about failed runtime tag-checks
02:08:54 <mjs22> peaker: Elisp too.  I'm not a big fan of any of the languages that adopt the runtime type checking model.  That has caused one too many errors in projects I've worked on to care much for them.  I like compiling programs and having some assurance that certain things have been checked and verified - like types.
02:09:51 <Peaker> mjs22: Yeah, I like the distinction between compile-time "types" and runtime "tags".  Calling them by the same name is not helpful, because something that a "term" is, is very different to something that a runtime value is
02:09:53 <mjs22> Python just happens to be the language I run across it more frequently with.  I only hit elisp when I need to tweak my editor.
02:10:39 <Peaker> mjs22: I liked Python a lot simply because I hadn't known static type systems have advanced as far as Haskell's.  I still prefer Python's no-types over C++, Java, etc types.  I think without type-classes, static types suck too much..
02:11:41 <mjs22> Heh.  True.  You won't ever find me defending C++ types (or anything related to C++ for that matter, other than the // comment improvement over the /* */ from C....)
02:11:56 <Peaker> mjs22: C99 has // comments :)
02:12:09 <mjs22> yes, but C++ introduced them. :-)
02:12:36 <Peaker> Look at how C++ caused all mainstream languages to adopt this horrible<syntax> for generics :-(
02:13:11 <mjs22> Have you seen CUDA?  I had to laugh the first time I saw the <<< >>> syntax for invoking kernels.
02:13:32 <mauke> mjs22: reintroduced
02:13:33 <mjs22> Annoying syntax cubed.
02:13:42 <mauke> didn't B have // comments?
02:14:14 <mjs22> mauke: quite possible.
02:18:44 <dcoutts> dibblego: pong
02:43:59 <hackagebot> list-tries 0.1 - Tries and Patricia tries: finite sets and maps for list keys (MattiNiemenmaa)
02:43:59 <hackagebot> Lucu 0.3.1 - HTTP Daemonic Library (MasatakeDaimon)
02:46:22 <dibblego> dcoutts, I was just uploading using "cabal upload" and it hung (although the upload seemed to work) -- though you might know something
02:47:08 <dcoutts> dibblego: I've no idea why it takes so long sometimes
02:47:30 <dibblego> dcoutts, I CTRL-C after a few minutes
02:47:47 <dcoutts> dibblego: I usually just let it complete
02:48:06 <dcoutts> dibblego: if you cut it too soon then sometimes not everything gets updated
02:48:13 <dcoutts> yay for non-atomic transations
02:48:23 * dcoutts notes the new server does not have this failure mode
02:52:44 <dibblego> dcoutts, also, how often is haddock run?
02:53:27 <dcoutts> dibblego: 3 or 4 times a day iirc
03:06:15 <FunctorSalad> what are these weird dollar-prefixed vars when :info'ing a GADT?
03:06:29 <FunctorSalad> data Foo $a where
03:06:29 <FunctorSalad>   Foo1 :: (($a) ~ Int) => String -> Foo Int
03:07:39 <skorpan> looks like template haskell for all i know ;|
03:08:32 <EvilTerran> FunctorSalad, the ~ there looks related to the "equality constraints" that associated types use
03:08:32 <Cale> FunctorSalad: hmm, well, I suppose it's some internal information about how the type system works leaking out. It makes sense if you leave out the $'s
03:08:48 <Cale> yes
03:08:53 <Cale> it's an equality constraint
03:10:09 <Cale> They're new in 6.10, you can use them in your own types :)
03:10:41 <shanker> : Lol boobs
03:10:45 <FunctorSalad> hehe "the type system leaking out". good description
03:11:11 <FunctorSalad> nothing a "filter (/='$')" can't solve I suppose ;)
03:11:22 <FunctorSalad> (I'm parsing :infos)
03:12:39 <lilac> hmm. can you write 'data Foo a = (a ~ Int) => Foo1 String' as another way of expressing GADTs then?
03:12:58 <EvilTerran> FunctorSalad, might there be an easier way to get the same data than parsing :i, with ghc-api or something?
03:13:01 <Cale> I'm not sure, try it :)
03:13:06 * lilac does so
03:15:04 <FunctorSalad> EvilTerran: I'm not familiar with the ghc api :(
03:15:25 <lilac> Cale: yes, you can! it requires ExistentialQuantification and TypeFamilies, but not GADTs
03:15:28 <FunctorSalad> (so I doubt it'd be easier :))
03:15:57 <Cale> lilac: neat. Handmade GADTs.
03:16:25 <FunctorSalad> unfortunately I think you can't reify these either
03:16:47 <FunctorSalad> not sure
03:19:59 <lilac> Cale: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=6536#a6536
03:52:10 <jlaire> what would be a good way to take from a list as many elements as can be computed in N seconds?
03:53:26 <Gracenotes> there's no way to know, is there? o_O
03:53:33 <jlaire> IO is fine
03:54:38 <PeakerWork> jlaire: you could run a thread that extracts from the list, and kill the thread when N seconds pass
03:54:40 <Gracenotes> well, list-taking is lazy.. you could conceivable do a producer/consumer thing with Chan (unbounded concurrent queue) and kill the producing thread after a bit
03:55:08 <Gracenotes> conceivably
03:55:17 <PeakerWork> you can also use the Producer/Consumer library yairchu and I made -- and just stop consuming after N seconds
03:55:58 <jlaire> I'll look into that, thanks PeakerWork and Gracenotes
03:56:10 * PeakerWork will write a little example of that
04:00:40 <Saizan> be sure to force the elements to evaluate
04:05:33 <lilac> jlaire: i think i'd run a thread which evaluated then wrote elements of the list to a Chan myself. forkIO that, then threadDelay, then killThread, then read the Chan
04:05:37 <wunki> what a negative attitude towards Haskell on reddit.. (bloxorz post)
04:05:54 <PeakerWork> @src guard
04:05:54 <lambdabot> guard True  =  return ()
04:05:54 <lambdabot> guard False =  mzero
04:05:57 <PeakerWork> @index guard
04:05:57 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:06:04 <PeakerWork> What's mzero in MaybeT?  Basically fail "" ?
04:07:21 <Gracenotes> hm.. it would make sense to require MonadZero of the transformed monad, not have a mix of fail/mzero
04:08:15 <Gracenotes> er, MonadPlus, as it were
04:09:04 <Gracenotes> hm.. it would probably involve Nothing?
04:09:23 <lilac> well, fail "" in MaybeT /is/ Nothing, so... ;-)
04:09:28 <Gracenotes> monad stacks make me go o_o
04:09:44 <Gracenotes> it would have to be of type m (Just a)
04:09:56 <Gracenotes> m (Maybe a)
04:10:07 <lilac> i'd assume 'mzero = MaybeT (return Nothing)'
04:10:13 <Gracenotes> with monad stacks, the responsibilities can be blurred..
04:10:45 <lilac> but whether MonadZero comes from the MaybeT or whether it comes from the base monad doesn't seem at all obvious
04:11:30 <Saizan> i guess it isn't MonadPlus m => MonadPlus (MaybeT m), so the mzero can't come from the base monad
04:11:31 <lilac> maybe it's not inherited and you need to manually lift guard to the level where you want it
04:12:31 <Gracenotes> instance here, http://www.haskell.org/haskellwiki/New_monads/MaybeT
04:14:13 <Gracenotes> I love how NGE has random voices announcing things
04:14:42 <lilac> NGE?
04:15:10 <Gracenotes> neon genesis evangelion. It is becoming more interesting
04:18:18 <EvilRanter> as i see it, the point of MaybeT (like ListT) is to introduce MonadPlus-like structure, so i'd def make its MonadPlus instance be non-inherited
04:20:04 <dibblego> is it possible to list all top-level functions in a module loaded into GHCi?
04:20:06 <Gracenotes> hm.. the URL's version does not require inheritance
04:20:33 <Saizan> dibblego: :browse
04:20:41 <dibblego> awesome thanks
04:21:12 <Gracenotes> mplus is Monad m => m (Maybe a) -> m (Maybe a) -> m (Maybe a)... mzero is m (Maybe a)...
04:21:54 <Gracenotes> if the first arg fails, the second arg is tried.. otherwise the first is returned
04:22:23 <Gracenotes> fails meaning, is Nothing. the Maybe structure is the property here
04:22:45 <Gracenotes> it is useful to think of mplus in terms of failure, I think.. not just mzero..
04:22:53 <Saizan> isn't that what you'd expect?
04:23:16 <Gracenotes> it is... just as planned!
04:25:12 <Saizan> mh, so in general m >> mzero = m doesn't hold for MaybeT, interesting
04:25:49 <EvilRanter> Saizan, i thought m >> mzero = mzero was a more common property, anyway
04:25:54 <Gracenotes> hm.. does it?
04:26:13 <paolino> wunki: in which programming field is reddit important ?
04:26:16 <Saizan> EvilRanter: ah, yeah, that's what i meant :)
04:26:42 <Gracenotes> in 'm >> mzero', if m is Just something, it will be returned.. if m is Nothing, then Nothing will be returned (mzero)
04:27:14 <EvilRanter> @check \m -> (m >> mzero :: [Int]) == mzero
04:27:15 <lambdabot>   "OK, passed 500 tests."
04:27:40 <Saizan> in m >> mzero you always get a Nothing, though the effects of the base monad are not rolled back
04:28:07 <Gracenotes> yes.. it's the effects I'm stuck reasoning about..
04:29:31 <paolino> wunki: the attitude there is negative. Money , sex, what else? Those people won't appreciate haskell, reddit is squatted badly
04:38:13 <briml> i'm trying to dabble in wxhaskell. But the documentation is hard to follow. For example i have an 'attribute' called columns :: Attr (ListCtrl a) [(String, Align, Int)]. Where can I find out what the Int here represents?
04:38:14 <burp> > "Users: " ++ foldr (\a b -> a++", "++b) [] ["burp", "bla", "blub"]
04:38:15 <lambdabot>   "Users: burp, bla, blub, "
04:38:21 <burp> how do I get rid of the final ","?
04:38:26 <burp> is there an elegant way? :>
04:39:27 <wunki> paolino: I guess so.. still sad to see such reactions from what should be a intelligent demographic
04:39:34 <Botje> burp: foldr1
04:39:40 <mpwd> burb: intercalate
04:39:41 <jlaire> > "Users: " ++ intercalate ", " ["burp", "bla", "blub"]
04:39:42 <lambdabot>   "Users: burp, bla, blub"
04:39:56 <Badger> @src intercalate
04:39:56 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
04:39:58 <burp> nice
04:40:10 <Axman6> @check \xs -> length (xs :: [Int]) >= 2
04:40:11 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
04:40:11 <Botje> > "Users: " ++ foldr1 (\a b -> a++", "++b) ["burp", "bla", "blub"]
04:40:12 <lambdabot>   "Users: burp, bla, blub"
04:40:13 <PeakerWork> lilac: mzero = MaybeT (return Nothing)  -- from the actual lib
04:40:25 <Axman6> @check \xs -> (length . show) (xs :: [Int]) >= 2
04:40:26 <lambdabot>   "OK, passed 500 tests."
04:40:28 <burp> I like the foldr1 approach ;)
04:40:45 <burp> although.. intercalate is nice too
04:40:48 <Botje> if all you're doing is adding ", " i'd use intercalate
04:41:00 <burp> ok
04:41:45 <Botje> @pl \a b -> a++", "++b
04:41:45 <lambdabot> (. (", " ++)) . (++)
04:42:01 <Botje> eww :p
04:42:04 <burp> ugh
04:44:14 <opqdonut> @unpl ap (++) (++", ")
04:44:14 <lambdabot> ((++) >>= \ c -> (\ a -> a ++ ", ") >>= \ b -> return (c b))
04:44:29 <opqdonut> hrmn
04:44:38 <PeakerWork> pico=nano/1000?
04:44:41 <PeakerWork> or vice versa?
04:45:00 <Botje> pico is smaller than nano, yes
04:45:06 <opqdonut> @unpl (ap :: (a->r->b) -> (r->a) -> r- (++) (++", ")
04:45:06 <lambdabot> Unbalanced parentheses
04:45:08 <opqdonut> gah
04:45:16 <opqdonut> @unpl (ap :: (a->r->b) -> (r->a) -> r->b) (++) (++", ")
04:45:16 <lambdabot> ((\ e f -> e >>= \ c -> f >>= \ b -> return (c b)) :: (a -> r -> b) -> (r -> a) -> r -> b) (++) (\ a -> a ++ ", ")
04:45:18 <opqdonut> there
04:45:25 <opqdonut> well, not any better really
04:45:44 <EvilTerran> ah, if only we had two-sided sections, and that'd be (++", "++)
04:46:36 <PeakerWork> Botje: thanks
04:46:42 <Zao> I parsed that as the tuple of (++") and ("++), wondering what obscure operators you had found.
04:46:47 <PeakerWork> @hoogle Integer -> TimeDiff
04:46:47 <lambdabot> Warning: Unknown type TimeDiff
04:46:47 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
04:46:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:46:53 <PeakerWork> @hoogle Integer -> System.Time.TimeDiff
04:46:53 <lambdabot> Parse error:
04:46:53 <lambdabot>   --count=20 "Integer -> System.Time.TimeDiff"
04:46:53 <lambdabot>                               ^
04:49:49 <altmattr> will and SSD speed up my ghc compilation much?
04:50:07 <Axman6> could do
04:50:17 <Axman6> but i can think of far better reasons for buying one
04:51:20 <altmattr> I spend a good chunk of my day watching ghc compile
04:51:28 <altmattr> I want to make it go faster!
04:51:30 <altmattr> faster!
04:51:33 <altmattr> faster!!!!!
04:51:35 <mbz> altmattr, it will if you havn't enough amount of RAM
04:51:46 <opqdonut> a ramdisk will be faster than an ssd ;)
04:51:47 <mbz> and it's swaping
04:51:52 <Zao> make fast? :)
04:51:55 <opqdonut> yeah, swapping is bad
04:52:09 <altmattr> yeah - it aint ram - I have tons of that
04:52:33 <mbz> altmattr, then you'd better upgrade your CPU
04:52:44 <EvilTerran> FSB?
04:52:45 <mbz> what do you have now?
04:52:50 <PeakerWork> @index evaluate
04:52:51 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
04:52:55 <altmattr> if only - stuck on PPC mac
04:53:19 <altmattr> but if two new computers is the cheapest way to updgrade (home and office) then, so be it
04:54:46 <mbz> IIRC ghc-6.10.1 compiles about 1-2 hour on my laptop (4gib of ram, dual core cpu@2400mhz and 4mib cache)
04:55:18 <altmattr> takes overnight on this old thing
04:58:09 <altmattr> but that is not the problem.  The problem is I have a 7500 line (including whitespace and comments) program that is getting very sllllooooowww to compile
04:59:56 <Zao> Ah, you're not watching GHC get compiled, you're watching it compiling other code.
04:59:58 <Saizan> altmattr: a single 7500 lines file?
05:00:11 <altmattr> ha! no
05:00:20 <altmattr> a few dozen files
05:00:32 <Axman6> thank fook for darcs >_< just did a rm *.hs instead of a rm *.hi by accident >_<
05:00:41 <Botje> altmattr: does everything in your file change?
05:01:11 <Zao> Axman6: Sounds like when my subconcious took charge and made the clean: action in my Makefile -rm *.java
05:01:13 <altmattr> Botje: no, but sometimes I am on an intel box, and I am stuck with ghci
05:01:29 <Axman6> Zao: ha
05:01:31 <Botje> what? :)
05:02:23 <michaelcdever> hey all, im uploading a package to hackage, how do i get it to build the haddock for it?
05:02:28 <altmattr> Botje: I boot into whatever mac is in front of me, my drive has ppc ghc on it.  GHCi works fine on intel boxes, but ghc tries to generate machine instuctions that don't exists!
05:02:37 <Taejo> michaelcdever: wait
05:02:40 <Axman6> michaelcdever: wait
05:02:55 <Botje> altmattr: weird :)
05:02:56 <michaelcdever> ah. its automatic, fair enough :)
05:02:57 <Taejo> I think the build queue gets run every six hours
05:03:09 <altmattr> Botje: but you did just remind me (tell me if I am wrong) that if I compile with ghc, when I go back into ghci it will use the compiled files and not re-interpret right?
05:03:23 <Botje> no idea how it works
05:03:39 <Botje> i think ghci can re-use the bytecode generated
05:03:56 <altmattr> Botje: Indeed, all a consequence of being a poor cyclist (can't afford new computers, can't carry laptop)
05:04:18 <Botje> i'm happy with my eee
05:04:18 <altmattr> can anyone else confirm if ghci can be made to not interpret every file every time?
05:04:33 <Botje> altmattr: can't you beg/borrow/steal a shell account somewhere?
05:04:34 <Zao> Your core problem seems to be that you consider macs computers.
05:04:50 <altmattr> Zao: ha!
05:04:56 <Botje> then you don't have to cope with changing environments
05:05:07 <altmattr> I have tried the alternatives, I assure you
05:05:18 <Zao> My shell box doesn't have a GHC.
05:05:31 <Zao> For some strange reason, FreeBSD sparc64 isn't a horribly common target.
05:05:56 <altmattr> the fact that i ride a bike 12kms through the bush to work means I can't use a laptop (can't carry it), and I *hate* having two computers to keep organised
05:06:01 <Zao> I'd have to cross-compile an unregisterised one to have a remotely fair chance of getting anything working.
05:06:14 <altmattr> so I boot from the one disk no matter what computer I am in front of
05:06:22 <altmattr> linux an windows suck at that
05:06:31 <Botje> altmattr: get an eee laptop
05:06:40 <Botje> they're light :)
05:06:55 <Axman6> altmattr: why can't you carry a laptop? o.O
05:07:13 <altmattr> You tried riding a mountain bike with a laptop
05:07:25 <altmattr> heavy, bumps, dirt, mud, sweat, heavy and ... heavy
05:07:43 <altmattr> oh, and the far-too-regular accidents :)
05:07:51 <altmattr> invisible trees, etc
05:08:06 <Botje> my EEE weighs all of 1.5kg
05:08:16 <altmattr> I have been thinking very hard about netbooks
05:08:18 <Botje> and that's because i chose the model with a decent keyboard :)
05:08:34 <Botje> the 9-inch models are crazy light
05:09:30 <altmattr> Botje: on the shell account - a total pain to use since my internet is not really reliable enough
05:09:39 <altmattr> Botje: been there and tried that :)
05:10:23 <altmattr> one of the wonderful things about computing these days - so many options
05:10:35 <malosh> Hi. Is it possible to declare a new instance of an unboxed type in GHC ?
05:10:38 <altmattr> but back to ghci not interpreting every file every time - anyone?
05:10:42 <Axman6> altmattr: you could always ride carefully, and get a good bag. i recommend the STM bags, the proteck laptops very well, and lots of them come with a rain proof cover
05:11:19 <Axman6> altmattr: if you compile them with ghc, ghci will use the .hi and .o files i believe
05:11:21 <altmattr> Axman6: You will have to trust me on this one since I can't really take you for a ride to show you :)
05:13:19 <altmattr> Axman6: unless you make a trip up to old sydney town :)
05:13:38 <Axman6> well, i'll be in ulladulla tomorrow, that's not an unreasonable request ;)
05:13:47 <altmattr> :)
05:13:56 <Axman6> i'm from canberra
05:14:18 <altmattr> frosty
05:14:25 <Axman6> yah
05:15:10 <Axman6> 2.1Â°C atm
05:15:33 <altmattr> Axman6: you have my sympathy
05:15:41 <Axman6> it's not so bad
05:15:46 <altmattr> it won't get that cold all winter here
05:15:49 <Axman6> at least it's not sydney :P
05:15:51 <altmattr> maybe just
05:15:55 <altmattr> ha!
05:16:19 * Axman6 dislikes sydney a lot
05:17:28 * RayNbow is blown away by the sheer awesomeness of sigfpe's latest blog post O_O
05:19:41 <dibblego> how might I have got a unix-2.3.2.0 dependency in my package?
05:19:59 <dibblego> http://hackage.haskell.org/packages/archive/Lastik/0.2/Lastik.cabal
05:20:15 <Axman6> dep of a dep?
05:20:23 <dibblego> yeah but which one?
05:21:01 <dibblego> oh FileManip
05:21:08 <dibblego> dang
05:21:22 <dibblego> @seen bos
05:21:22 <lambdabot> bos is in #haskell-in-depth, #ghc and #haskell. I last heard bos speak 7h 50m 54s ago.
05:21:38 * Zao shuns people who depend on unix.
05:22:36 <dibblego> @tell bos does FileManip work on Windows at all?
05:22:36 <lambdabot> Consider it noted.
05:24:11 <altmattr> Zao: mac bad - unix bad - ???
05:24:24 <altmattr> Zao: :)
05:25:12 <altmattr> RayNbow: when do you think blogs will tip the scales over journals?
05:25:24 <Taejo> altmattr: portability good?
05:25:49 <altmattr> RayNbow: stuff like this is bloody impressive
05:26:09 <altmattr> Taejo: I know, I am being facetious - as always
05:26:29 <PeakerWork> jlaire: I wrote a little proof-of-concept using producers/consumers
05:26:44 <Taejo> I must say I sometimes feel Windows isn't worth the effort
05:26:55 <PeakerWork> jlaire: its not in hackage yet, but you can run "cabal install" after git cloning from http://github.com/yairchu/generator/, and then here's a timed producer: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6538#a6538
05:27:41 <RayNbow> altmattr: well, the problem is that the majority of blogs out there are of low quality
05:27:42 <hackagebot> Gtk2hsGenerics 0.1 - Convenience functions to extend Gtk2hs. (MichaelDever)
05:27:42 <jlaire> PeakerWork: thanks, I'll have a look
05:28:55 <altmattr> RayNbow:  oh - I know.  What I mean is that I think eventually the immediacy of blogs could win out over the journals (plenty of other problems to be fixed first of course, like replacing peer review) and posts like this make it feel inevitable
05:29:48 <PeakerWork> @hoogle killThread
05:29:48 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
05:31:57 <jlaire> PeakerWork: here's a quick solution using an MVar I wrote: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6539
05:33:03 <LiHong>  /part
05:33:08 <PeakerWork> jlaire: cool, I was just working on that too, to compare it to the Producer solution in terms of performance.  I think its probably much faster :)
05:34:23 <jlaire> PeakerWork: fortunately efficiency isn't a problem for me, because forcing just 10 or so elements takes a long time :)
05:45:53 --- mode: ChanServ set +o Heffalump
05:46:09 <Zao> altmattr: As a developer with Windows as my core platform, seeing libraries depend unnecessarily to unportable packages and using configure scripts in vain, makes my heart cry.
05:46:11 --- mode: Heffalump set -b *!*@amcant.demon.co.uk
05:46:18 --- mode: Heffalump set -o Heffalump
05:46:18 <Zao> altmattr: Also, OSX and I do not agree :P
05:46:31 <altmattr> Zao: point taken
05:47:05 <Axman6> Zao: your loss :)
05:47:48 <Zao> Axman6: I'm quite happy on real free platforms like OpenSolaris, FreeBSD, heck, even Linux.
05:48:00 <Zao> And Windows, of course, as that's the only one that matters.
05:48:30 <dibblego> is there a way of viewing the haddock for a function at ghci?
05:58:29 <Gracenotes> hm... I think it's time I had organized folders for storing pdf papers and ebooks
05:58:48 <Gracenotes> dumping it all on my Desktop or in bin just isn't going to work... it's reached a critical mass >_>
05:59:20 * Beelsebob nods -- iTunes for papers would be really rather nice
06:00:04 <opqdonut> jabref is pretty nice for maintaining a .bib + pdfs of the papers
06:02:18 <Axman6> Beelsebob: seen Papers.app?
06:02:42 * Beelsebob grabs it
06:02:55 <Axman6> not free, but looks nice
06:02:56 * SamB_XP bets it doesn't work in GNUStep
06:03:28 <Axman6> i highly doubt it would
06:03:35 <Axman6> it's pretty flashy
06:04:05 <SamB_XP> eww, flash!
06:04:52 <Axman6> nothing wrong with flash either
06:07:29 <SamB_XP> it's not very efficient for walk-around adventure games ;-P
06:20:07 * byorgey makes bacon and scrambled lambdas
06:22:31 <Axman6> \om -> nom nom nom
06:23:43 <RayNbow> Axman6: what's the type of nom? :p
06:23:56 <Axman6> nom = fmap... >_>
06:24:02 <Axman6> :t fmap fmap fmap
06:24:04 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:24:09 <mauke> :t id id id
06:24:11 <lambdabot> forall a. a -> a
06:24:28 <mauke> :t flip flip flip
06:24:29 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
06:25:56 <LeoD> :t const const const
06:25:57 <lambdabot> forall a b. a -> b -> a
06:26:29 <Axman6> :t const const
06:26:30 <lambdabot> forall a b b1. b1 -> a -> b -> a
06:26:37 * bremner was reading backlog and misquoted Zao as saying "Windows is the only real free platform that matters". I wondered if he was actually the ion3 guy in disguise
06:27:37 <Zao> Hah. I'm no Tuomo, that's for sure.
06:28:04 <Axman6> :t const const const const const
06:28:05 <lambdabot> forall a b. a -> b -> a
06:28:11 <Axman6> how interesting
06:28:39 <EvilTerran> Axman6, const x undefined = x, so const const const = const
06:28:48 <Axman6> ah yes
06:28:54 <Axman6> makes perfect sense
06:29:10 <Axman6> EvilTerran++ for an excellent explanation ;)
06:29:20 <EvilTerran> :)
06:29:53 <RayNbow> :t let false = flip const in false false false
06:29:54 <lambdabot> forall b a. b -> a -> a
06:31:13 <Axman6> > foldl1 (flip const) [1..10]
06:31:14 <lambdabot>   10
06:31:19 <Axman6> > foldl1 (const) [1..10]
06:31:20 <lambdabot>   1
06:31:57 <Woof> @bf .
06:31:57 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
06:32:22 <Woof> @seen Cale
06:32:22 <lambdabot> Cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard Cale speak 3h 16m 24s ago.
06:36:47 <jav> Hi there! I am using Gtk2Hs but would like to set the _NET_WM_STRUT_PARTIAL property on my main window. Can anyone give me some pointers how I can manage that?
06:51:18 <michaelcdever> hey all, im having a problem with an amiguous type variable... could someone take a look and point me in the right direction? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6542#a6542
06:52:16 <mauke> yeah, import Control.OldException
06:52:16 <Beelsebob> wow, that's some ugly code
06:52:42 <Beelsebob> also, that whole last line can be replaced with words <$> at the start
06:53:48 <mauke> blargh, why is haskell.org down
06:54:20 <Raynes> mauke: Just to piss you off.
06:54:42 <paolino> mauke: OldException is going to stay there ?
06:55:30 <Raynes> mauke: Haskell.org seems to be up.
06:57:11 <mauke> fdToHandle =<< openFd "exts.txt" ReadOnly (Just 0o644) defaultFileFlags
06:57:28 <Saizan> michaelcdever: "`Er.catch` (\(SomeException _) ->"
06:57:44 <Saizan> michaelcdever: if you stick with Control.Exception
06:58:26 <mauke> no need to catch exceptions when you can just create the file in the open
06:58:39 <paolino> it seems not deprecated , then it was better to give a new name to the new framework, and don't break all the code, maybe
06:59:02 * Raynes felt stricken with the plague when he had to figure out how to use new exceptions because RWH preceded them.
06:59:12 <Saizan> paolino: i think the idea is that .OldException should go away
06:59:38 <paolino> it's not documented in the module docs, or .. I don't see it
06:59:52 <michaelcdever> cool, thanks
07:00:35 <michaelcdever> now if someone could tell me why some gtk2hs code runs perfectly on linux, but fails on OSX, i'd be delighted
07:01:18 * paolino thinks the open world  assumption should also be taken for modules hierarchy
07:01:41 <dcoutts> could people please try this pre-release of cabal-install:
07:01:42 <dcoutts> http://haskell.org/~duncan/cabal/cabal-install-0.6.3.tar.gz
07:01:57 <dcoutts> all going well I'll release it on hackage as version 0.6.4
07:03:08 <Raevel> going, going
07:04:34 <dcoutts> one reason I'd like reasonable testing is because existing versions of cabal-install notice when an upgrade is available and will notify when you 'cabal update'
07:04:59 <dcoutts> so since everyone is going to get prompted to update, it'd be nice if it worked :-)
07:05:27 <Raevel> well, it did compile and manage to install some packages for me, on os x
07:06:02 <dcoutts> (I've adjusted the new version so that it also takes into account the preferred-versions file so that in future it'll be possible to make beta releases)
07:06:10 <dcoutts> Raevel: thanks
07:07:37 <dcoutts> Raevel: actually one think I'd like to check on OSX is if sdist works properly, that code got a big update
07:07:56 <Raevel> sure, how can i help?
07:08:19 <dcoutts> pick any project that uses cabal, cd to it's dir and cabal sdist
07:08:32 <dcoutts> for extra points, check that you can then install from the tarball it creates
07:09:32 <dcoutts> Saizan: we should really make is possible to do cabal install http://example.com/foo-1.0.tar.gz
07:09:45 <dcoutts> Saizan: btw, I intend to integrate your recent patches today
07:10:19 <Raevel> worked fine all the way through installation
07:10:26 <dcoutts> Raevel: great
07:10:44 <dcoutts> Saizan: it'd be great for easy beta testing, and would reduce the incentives for people to stick alpha releases on hackage
07:11:23 <dcoutts> though it'd only help for individual packages, not whole sets
07:11:55 <Saizan> mh, you might accept a list of paths
07:12:17 <Saizan> but it becomes complicated to plan the build i guess
07:13:20 <Saizan> you'd have to generate a repo-cache on the fly
07:17:14 <dcoutts> Saizan: yeah I guess when it's a remote url, we have to download it first before doing any planning
07:17:34 <dcoutts> download all, extract the .cabal files and then make a plan
07:18:44 <Saizan> dcoutts: i've found a minor problem with the generation of docs btw, i check for DocsOk to see if any doc has been generated, but you get DocsOk also for packages with only executables that don't generate any doc, so i'm not sure if it's a bug in the generation of the build result or i should check for the presence of a library in the package too
07:19:40 <Saizan> when checking if we've to refresh the haddock index page, i mean
07:19:47 <jav> Gtk2Hs is not a complete binding to GTK or is it? Could it be, that gdk_property_change() is not exposed through Gtk2Hs?
07:20:31 <dcoutts> Saizan: if you'd like to change the DocOk to make it more accurate then that's fine
07:21:14 <dcoutts> Saizan: I agree if there's only exes and they didn't use that flag to generate internal docs, then it's really docs not done, rather than ok
07:24:22 <Saizan> dcoutts: ok, checking the flags and the presence of a library should be enough to tell when it's really not done i guess, since i don't think Setup haddock returns any useful information to discriminate, right?
07:25:20 <Saizan> we could actually avoid calling it in that case, since we're kind of breaking that abstraction anyhow
07:25:38 * Saizan looks at the code
07:26:03 <Rahis> hey anbody chat me
07:26:11 <Rahis> join room
07:26:14 <Rahis> ml lice
07:38:29 <Raevel> once you learn haskell, there is no haskape
07:41:14 <Pegazus> haskape?
07:43:28 <Raevel> work with me here
07:43:51 <Zao> http://arcanux.org/lambdacats/dumb.jpg
07:43:55 <eu-prleu-peupeu> hi
07:43:59 <Zao> That's how I usually feel when coding Haskell.
07:44:15 <burp> lol
07:44:22 <redline6561> Zao: Oh, yes sir. I have been there.
07:45:22 <mauke> http://arcanux.org/lambdacats/io-monad.jpg
07:45:46 <burp> aw
07:45:59 <burp> this cat needs unsafePerformIO
07:46:40 <mauke> http://arcanux.org/lambdacats/unsafe.jpg
07:49:09 <dsouza> lol
07:57:08 <briml> is there any dictionary type in ghc?
07:57:26 <mauke> Data.Map
07:57:37 <briml> thx
08:01:22 <portnov> @src foldl'
08:01:22 <lambdabot> foldl' f a []     = a
08:01:22 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:26:01 <chrisdone> :t (.)
08:26:02 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:26:42 <chrisdone> :t fmap
08:26:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:27:38 <chrisdone> can (a -> b) be equivalent to f a? and (a -> c) equiv to f b?
08:27:58 <chrisdone> :instance
08:28:05 <chrisdone> @instance
08:28:05 <lambdabot> Maybe you meant: instances instances-importing
08:28:10 <chrisdone> @instances Functor
08:28:11 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:28:45 <chrisdone> :t flip fmap (+3)
08:28:47 <lambdabot> forall b a. (Num a) => (a -> b) -> a -> b
08:28:58 <chrisdone> :t fmap (*2) (+3)
08:28:59 <lambdabot> forall a. (Num a) => a -> a
08:29:07 <chrisdone> well I be
08:30:36 <chrisdone> why isn't (.) = fmap?
08:31:24 <Heffalump> because it'd be very confusing when you made a mistake
08:31:46 <chrisdone> like what?
08:32:33 <Heffalump> @type (+1) . (*)
08:32:34 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a -> a
08:32:40 <Heffalump> @type (+) . (*1)
08:32:42 <lambdabot> forall a. (Num a) => a -> a -> a
08:32:49 <Heffalump> @type (+) . (*)
08:32:50 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
08:32:58 <Heffalump> @type (+) `fmap` (*)
08:32:59 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
08:33:16 <Heffalump> ok, something more complicated than that :-)
08:33:30 <Heffalump> but you'd get Functor all over your error messages
08:34:15 <chrisdone> I can see those might be confusing
08:35:00 <chrisdone> when I make a mistake with <*> I am similarly baffled..
08:36:26 <paolino> is anyone using hslogger? I have some problem understanding how addHandler works
08:36:35 <peter_12> what is so "algebraic" about "algebraic data types"?
08:38:46 <chrisdone> "A branch of mathematics in which symbols, usually letters of the alphabet, represent numbers or members of a specified set and are used to represent quantities and to express general relationships that hold for all members of the set."
08:39:13 <ski> peter_12 : <http://en.wikipedia.org/wiki/F-algebra#Initial_F-algebra>
08:42:34 <RayNbow> \
08:42:40 <RayNbow> ah crap, wrong key...
08:42:40 <LeoD> /
08:45:44 <peter_12> so the "algebraic" part is to relate the idea of data types in Haskell to things like monoids, groups and rings?
08:48:02 <kpreid> if I understand correctly... better to say the types themselves are an algebra
08:48:28 <kpreid> data Foo = Bar X Y is a product and data Baz = A X | B Y is a sum
08:49:14 <ski> peter_12 : that's how i understand it, yes
08:49:32 <peter_12> kpreid: how is it that data Foo = Bar X Y is a product? No operation is specified.
08:49:36 <peter_12> ski: thanks
08:50:10 <ski> kpreid presumably means roughly `Foo ~= X * Y' and `Baz ~= X + Y'
08:50:49 <kpreid> peter_12: no, the type construction *is* the operation. to see the analogy, or 'isomorphism' if you like, count the number of members of those types
08:51:03 <kpreid> count(Foo) = count(X) * (Y)
08:51:10 <kpreid> count(Baz) = count(X) + count(Y)
08:51:27 <stevan> peter_12: http://blog.lab49.com/archives/3011
08:51:42 <nainaide> I find a very good url about explaining monad http://sequence.complete.org/node/175
08:51:52 <nainaide> state monad
08:57:33 <RayNbow> http://homepage.mac.com/sigfpe/Computing/diff.html <-- peter_12, this might be an interesting read for you
08:58:14 <peter_12> stevan: nainaide: RayNbow: Thanks for the links. Lots to read.
08:58:25 <ski> (btw, to clarify : i'm not claiming `F-Algebras' are why it's called `algebraic data type' (i don't know for sure); i'm claiming that reason seems most sensible to me - otherwise i'm not sure how to explain `coalgebraic data type')
09:00:19 <paolino> how can I write a hGetLine which reads at most n char and discard the rest until newline character ?
09:00:59 <monochrom> do { all <- hGetLine; return (take n all) }
09:01:00 <ski> liftM (take n) . hGetLine
09:01:36 <paolino> the rest will be read ?
09:01:48 <ski> as you wanted
09:02:09 <monochrom> A problem is that the rest consumes memory for a moment. But I'm too lazy to solve it.
09:02:34 <paolino> eh, that was the point, not explode
09:02:36 <Woof> @seen Cale
09:02:36 <lambdabot> Cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard Cale speak 5h 46m 38s ago.
09:02:50 <monochrom> Note that "discard the rest until newline" implies you must read the rest. Your only choice is how much memory you use.
09:03:04 <nominolo|uni> @seen mmorrow
09:03:04 <lambdabot> I saw mmorrow leaving #yi, #haskell-blah, #haskell-in-depth, #ghc and #haskell 1d 11h 59m 57s ago, and .
09:03:04 <monochrom> @src hGetLine
09:03:04 <lambdabot> Source not found. There are some things that I just don't know.
09:03:38 <paolino> discard as in "use no memory"
09:05:24 <ski> try collecting `hGetChar' (at most) `n' times, then use `hGetChar' (discarding) until newline ?
09:05:48 <paolino> they set the server out of memory with hGetLine :-/
09:09:48 <paolino> ski, which is the correct approach to avoid this kind of attack , if there is a better one ?
09:10:13 <ski> avoid what ?
09:10:24 <rovar> laser satellites
09:10:37 <paolino> flooding, if this is the right word
09:10:45 <ski> do you have very long lines ?
09:11:18 <ski> or is the problem the GC is overworked ?
09:11:50 <paolino> the protocol admit long lines (big serialized values)
09:12:01 <ski> ok
09:12:37 <Saizan> maybe use ByteString.Lazy?
09:12:53 <paolino> and use the parser ?
09:13:47 <paolino> parser error -> discard anything until newline ?
09:14:19 <burp> data Test = Test [Int] deriving (Show)          foo = do   x <- [1,2,3]; y <- [1,2,3]; return (x+y)
09:14:29 <Saizan> yeah, something like that
09:14:30 <burp> foo returns a list of numbers
09:14:38 <burp> how can I make it return Test?
09:14:51 <burp> (embed it into data Test)
09:14:59 <mauke> Test foo
09:15:00 <ski> burp : `foo = Test $ do ...'
09:15:08 <burp> ah. right =)
09:20:38 <nainaide> Cale,  Is this post from you? http://sequence.complete.org/node/175
09:21:41 <Heffalump> nainaide: I imagine the bit by "Cale Gibbard" is
09:22:09 <nainaide> Heffalump, me too.
09:23:24 <nainaide> Heffalump, I am wondering why the s0 is has type s,
09:24:41 <chrisdone> I've got the state monad and formlets defined in terms of it in javascript and it works great, I just hope none of my colleages try to understand it one day. I'll have to wave it off as magic
09:25:24 <nainaide> chrisdone, cool
09:27:14 <nainaide> chrisdone,  could you explain the my question above?
09:27:34 <nainaide> state monad makes me crazy
09:27:42 <Botje> why?
09:27:49 <Botje> it's warm and fuzzy.
09:27:56 <nainaide> :)
09:28:10 <ray> it's so cute it drives people mad
09:28:14 <Igloo> nainaide: Why which s0 has type s?
09:28:26 <nainaide> http://sequence.complete.org/node/175
09:28:58 <nainaide> from above url , the definition of state monad, there is a \s0
09:29:19 <Igloo> nainaide: Ah, I see. You mean in "p >>= k = \s0 -> let (s1, a) = p s0", right?
09:29:31 <nainaide> yes
09:29:41 <Igloo> OK, do you know what type "p >>= k" has?
09:29:56 <nainaide> >>= p k
09:30:17 <nainaide> means from ma -> (a -> mb )-> m b
09:30:44 <Igloo> Not quite
09:30:56 <Igloo> (>>=) has type m a -> (a -> m b)-> m b
09:31:08 <nainaide> yeah, I see,
09:31:14 <Igloo> But if you have (>>=) p k then you've already applied 2 arguments to it
09:31:38 <nainaide> yeah
09:32:01 <Igloo> OK, so what type does (>>=) p k have then?
09:32:17 <nainaide>  should be m b
09:32:21 <Igloo> Right
09:32:41 <nainaide> I think the lambda function confuse me
09:32:43 <Igloo> But in this example, we're using a specific instance of (>>=)
09:32:51 <Igloo> So it says (>>=) :: StateTrans s a -> (a -> StateTrans s b) -> StateTrans s b
09:33:08 <Igloo> Which is the same thing, with m = StateTrans s, right?
09:33:09 <nainaide> yes
09:33:14 <nainaide> yes
09:33:22 <Igloo> So (>>=) p k has type StateTrans s b
09:33:30 <nainaide> sure
09:33:36 <Igloo> And above that we're told that "type StateTrans s a = s -> (s, a)"
09:33:48 <nainaide> yep
09:33:55 <Igloo> So (>>=) p k has type s -> (s, b)
09:34:05 <nainaide> yes
09:34:14 <Igloo> And we're also told that p >>= k = \s0 -> let (s1, a) = p s0
09:34:36 <Igloo> So \s0 -> let (s1, a) = p s0 must also have type s -> (s, b), right?
09:34:47 <nainaide> here, where did the lambda function get the argument s0?
09:35:12 <Igloo> Ah, OK, that's a fresh name. We could call it anything we like
09:35:27 <Igloo> We could equally well say   p >>= k = \hello -> let (s1, a) = p hello
09:35:31 <nainaide> yes, from p s0, I can infer
09:36:01 <nainaide> that p s0 should be s->(s, a) take s0
09:36:32 <chrisdone> indeed
09:36:49 <Igloo> That's true, but you don't even need to look at the use in this case
09:37:13 <Igloo> If it was p >>= k = \s0 -> error "haven't finished yet" then you'd still be able to work out the type of s0
09:37:16 <nainaide> my question is in lambda, I can have (\s -> s*2) 5, where 5 is a argument, but here, where is the argument come from?
09:37:51 <Igloo> (\s -> s*2) means "The function that takes an argument, and returns <that argument>*2"
09:38:35 <chrisdone> nainaide: are you aware of partial application?
09:39:02 <Woof> Hey, how do I use lambdabot's lambda calculus interpreter?
09:39:25 <monochrom> > (\x -> f x) a
09:39:26 <lambdabot>   Add a type signature
09:39:29 <nainaide> partial application ?
09:39:30 <monochrom> > (\x -> f x) a :: Expr
09:39:31 <lambdabot>   f a
09:39:34 <monochrom> Like that?
09:39:54 <Woof> Thank you dearly, monochrom!~
09:40:29 <Woof> Hm, type signature. It's typed lambda calculus? >.<
09:40:40 <monochrom> It is very typed.
09:40:50 <PeakerWork> Woof: Its Haskell, not simple LC
09:40:54 <Woof> I see
09:41:05 <chrisdone> nainaide: what does the (>>=) function do?
09:41:09 <monochrom> I don't recall any other part of lambdabot doing untyped lambda calculus.
09:41:18 <nainaide> lgloo, in let (s1, a) = p s0, where is the s0 come from ?
09:41:49 <monochrom> I don't know what lunabot does.
09:41:50 <nainaide> chrisdone, transfer results ?
09:41:59 <Woof> Perhaps the unlambda interpreter then. Oh well : /
09:42:10 <Igloo> nainaide: It's from the lambda binding that that expression is inside
09:42:26 <ski> nainaide : it comes from the `\s0 -> ' part of `\s0 -> let (s1, a) = p s0 ...'
09:42:32 <Igloo> nainaide: It's \s0 -> (let (s1, a) = p s0)
09:43:19 <ski> nainaide : `\s0 -> ...' means "make a function, that whenever someone calls it with argument `s0', returns `...')
09:43:20 <nainaide> well, probable a instance would be better for me to understand
09:43:38 <ski> nainaide : so `s0' comes from whoever would call this function later
09:43:58 <nainaide> ski,  yes "so `s0' comes from whoever would call this function later"
09:44:25 <Igloo> nainaide: In your (\s -> s*2) 5 example, the argument passed in is 5
09:44:35 <Igloo> nainaide: So (\s -> s*2) 5 reduces to 5*2
09:44:35 <ski> e.g. if you say `let q = p >>= k in q 42' then that `s0' here gets the value `42' when `q' is called
09:44:42 <nainaide> could you pls give a real call here with state monad
09:45:28 <chrisdone> nainaide: what is the result of this? (\s -> (s,3)) >>= (\number -> (\s -> (s,number*2)))
09:45:57 <nainaide> yes
09:47:26 <chrisdone> nainaide: what is it?
09:47:56 <nainaide> wow,
09:48:04 <nainaide> cant go through
09:48:24 <nainaide> chrisdone,  help
09:48:30 <chrisdone> sorry?
09:48:46 <nainaide> very sorry
09:49:15 <nainaide> looks the same to state monad
09:49:47 <chrisdone> make sure that you are thinking of all state values as functions that take a new state and return a 2-tuple
09:49:50 <nainaide>  (\s -> (s,3)) >>= (\number -> (\s -> (s,6)))
09:50:08 <nainaide>   (\s -> (s,3)) >>= (\3 -> (\s -> (s,6)))
09:50:27 <chrisdone> sure
09:51:06 <nainaide> so the result is (\s -> (s,6)
09:51:18 <chrisdone> correcto
09:51:21 <ski> how about
09:51:26 <ski>   tick = \n -> (n+1,n)
09:51:28 <ski>   p = tick >>= (\n -> return (10*n))
09:51:33 <ski> and then evaluating
09:51:37 <ski>   p 7
09:51:40 <ski> ?
09:51:55 <nainaide> let me think
09:52:27 <ski> (you can do the evaluation step-by-step, if you want)
09:52:42 <nainaide> yeah, I am doing
09:53:17 <ski> (and you could show the steps here, if you're not too shy :)
09:53:26 <nainaide> ok
09:53:55 <chrisdone> one nice way to understand things like this is to compile it, and then start adding type annotations to all the sub expressions. that forces you to ask all the necessary questions
09:53:56 <nainaide> let me try:      \n -> (n+1,n) >> (\n -> return (10*n))
09:54:13 <nainaide> let me try:      \n -> (n+1,n) >>=  (\n -> return (10*n))
09:54:15 <ski> how did you get to that expression ?
09:54:54 <ski> (it's not quite right)
09:54:57 <nainaide> p = (tick >>= (\n -> return (10*n)) and tick  = \n -> (n+1,n)
09:55:18 <ski> you need to use brackets on the left argument to `>>='
09:55:29 <ski>      p
09:55:41 <ski>   =  tick >>= (\n -> return (10*n))
09:55:48 <ski>   =  (\n -> (n+1,n)) >>= (\n -> return (10*n))
09:55:53 <nainaide> p = yes
09:55:55 <nainaide> yes
09:56:13 <ski> like that, since otherwise the first `\n -> ' will "enclose all of it"
09:56:38 <nainaide> yes
09:57:03 <ski> now, you can either continue simplifying this .. or you can add the argument `7' already, and then continue simplifying
09:57:30 <nainaide> let ( s1, a) =  (\n -> (n+1,n)) S0
09:57:49 <ski> where did that come from ?
09:58:02 <ski> is that supposed to be equal to all of `p' ?
09:58:05 <ski> all of `p 7' ?
09:58:07 <nainaide> ski, from the statemond definiton
09:58:13 <ski> or maybe a subexpression (which ?) ?
09:58:17 <nainaide> I sam p >>= k = \s0 -> let (s1, a) = p s0 ...
09:58:22 <ski> yes
09:58:49 <ski> don't forget the `\s0 -> ' part
09:58:54 <nainaide> what is the value of \s0?
09:59:00 <ski> no
09:59:02 <nainaide> n?>
09:59:31 <ski> (`\s0' is not an expression, it can't have a value)
09:59:50 <monochrom> (It's like "what is the value of 0 ->")
10:00:07 <nainaide> S0:: s, mean s->(s,a) ?
10:00:22 <ski> i'm not sure what you are asking
10:00:29 <Igloo> nainaide: Would it help if we said that   f x = x*2   is the same as   f = \x -> x*2   ?
10:00:37 <skorpan> s0 :: s typically means that s0 has type s (at least in haskell)
10:00:56 <nainaide> yes
10:01:16 <nainaide> let me continue from  (\n -> (n+1,n)) >>= (\n -> return (10*n))
10:02:50 <ski> nainaide : it might be simpler if you don't yet replace `tick' with its definition .. but either way works
10:03:17 <nainaide> p 7 , means \7->(7+1, 7)
10:03:25 <ski> no
10:03:33 <briml> how do I convert a function that returns IO Exitcode to IO ()?
10:03:41 <ski>      p 7
10:03:46 <ski>   =  (tick >>= (\n -> return (10*n))) 7
10:03:54 <ski> per the definition of `p'
10:04:10 <jad4> theory/notation question which greek letters to you use to represent types, other than sigma and tau?
10:04:11 <ski> also
10:04:25 <jad4> alpha, beta and gamma is for type vars :S
10:04:28 <monochrom> alpha is pretty popular
10:04:35 <nainaide> ski
10:04:38 <nainaide> ski, yes
10:04:40 <ski>   p :: StateTrans Integer Integer
10:04:41 <jad4> hmm isn't that for polymorphic stuff monochrom
10:04:49 <ski>   p :: Integer -> (Integer,Integer)
10:04:50 <nainaide> p7 = =  (tick >>= (\n -> return (10*n))) 7
10:04:51 <ski>   7 :: Integer
10:04:53 <ski> so
10:04:58 <ski>   p 7 :: (Integer,Integer)
10:05:22 <monochrom> There is no such restriction.
10:05:35 <ski> (so `p 7' must be a pair of numbers, it can't be a function, like `\7->(7+1, 7)' looks like)
10:05:37 <hzap> briml: put return () at the end of the function
10:05:41 <mauke> briml: >> return ()
10:05:50 * ski assumed `Integer' numbers, for simplicity
10:05:55 <briml> thx
10:06:01 <jad4> well I'm using alpha, beta and gamma for type vars already
10:06:07 <jad4> so can't use those :S
10:06:16 <nainaide> ski, I think I am lost, could  use this example on the definition of p >>= k = \s0 -> let (s1, a) = p s0 ... , so I know how it works
10:06:33 <jad4> someone should extend the greek alphabet
10:06:36 <lysgaard> Is it possible to print a Word128 in some way?
10:06:44 <monochrom> Use Chinese.
10:06:45 <SamB> jad4: hebrew ?
10:06:50 <SamB> kana?
10:06:56 <jad4> SamB, hmmm you have got a point
10:07:00 <nainaide> \7 -> let (s1, a) = p7
10:07:23 <mauke> > 42 :: Word128
10:07:26 <lambdabot>   Not in scope: type constructor or class `Word128'
10:07:29 <monochrom> \7->... is horrible.
10:08:05 <monochrom> > (\x -> f x) 7 :: Expr
10:08:07 <lambdabot>   f 7
10:08:09 <ski> nainaide : i'd advice against writing `\7 -> ' here .. either use `\variable -> ' or substitute in values, removing the lambda altogether
10:08:16 <monochrom> > (\x -> x+1) 7 :: Expr
10:08:17 <lambdabot>   7 + 1
10:08:36 <nainaide> monochrom, I see, I just try to   go through (\n -> (n+1,n)) >>= (\n -> return (10*n)) according to the state monad definition
10:09:13 <monochrom> You were doing it unfaithfully. You used faulty intuition rather than mechanically use the definition. Let the symbols do the work.
10:09:22 <ski> nainaide : would you like if i showed (one possible way) to simplify the expression ?
10:09:35 <lysgaard> mauke: The constructor is in Data.LargeWord
10:09:36 <nainaide> ski, sure
10:09:50 * ski states definitions first
10:10:04 <ski>   return a  =  \s -> (s, a)
10:10:16 <ski>   p >>= k  =  \s0 -> let (s1, a) = p s0; q = k a in q s1
10:10:29 <ski>   tick  =  \n -> (n+1, n)
10:10:30 <SamB> the one problem with kana is that if you write ã', people might wonder whether to pronounce it "ki prime" or "gi"
10:10:38 <lysgaard> mauke: I think it consists of two Word64
10:10:47 <ski> and then i defined
10:10:48 <nainaide> ski, yes
10:10:55 <briml> how do I start a new process (e.g. notepad.exe) from haskell but the haskell program should not wait for notepad to exit.
10:10:56 <ski>   p  =  tick >>= (\n -> return (10*n))
10:11:10 <ski> and the expression to evaluate was
10:11:19 <ski>   p 7
10:11:28 <nainaide> yes
10:11:31 <mauke> lysgaard: it has a Show instance, so print should work
10:11:51 <ski> so, i would first replace `p' with its definiendum, then expand the `>>=' call
10:11:54 * ski shows
10:12:00 <ski>      p 7
10:12:08 <ski>   =  (tick >>= (\n -> return (10*n))) 7
10:12:20 <nainaide> yes
10:12:42 <ski>   =  (\s0 -> let (s1, a) = tick s0; q = (\n -> return (10*n)) a in q s1) 7
10:12:45 <ski> ok, so far ?
10:12:55 <nainaide> right
10:13:19 <lysgaard> Okay, hmm
10:13:28 <ski> one could now simplify the `(\n -> return (10*n)) a' subexpression if one wanted .. or the `tick s0' one
10:13:44 <nainaide> sure
10:13:59 <ski> but i will here do it in the order typical haskell implementations does it
10:14:11 <ski> (as a possible simplification order)
10:14:15 <ski> so, we had
10:14:19 <ski>   =  (\s0 -> let (s1, a) = tick s0; q = (\n -> return (10*n)) a in q s1) 7
10:14:27 <ski>   =  let (s1, a) = tick 7; q = (\n -> return (10*n)) a in q s1
10:14:43 <nainaide> haha
10:15:01 <ski> i substituted the argument expression `7' for the variable `s0' in the lambda `\s0 -> ..s0..' (result being `..7..')
10:15:05 <ski> ok ?
10:15:26 <nainaide> great, that is what I want to know
10:15:57 <ski> (well, actually, i'll do the `let'-bindings first, instead of forcing the `q s1' ..)
10:16:09 <ski> so, then i expand `tick'
10:16:22 <ski>   =  let (s1, a) = (\n -> (n+1, n)) 7; q = (\n -> return (10*n)) a in q s1
10:16:23 <nainaide> yes
10:16:35 <ski>   =  let (s1, a) = (7+1, 7); q = (\n -> return (10*n)) a in q s1
10:16:47 <ski> (and arithmetic, while we're at it)
10:16:53 <ski>   =  let (s1, a) = (8, 7); q = (\n -> return (10*n)) a in q s1
10:17:07 <ski>   =  let q = (\n -> return (10*n)) 7 in q 8
10:17:20 <ski>   =  let q = return (10*7) in q 8
10:17:28 <ski>   =  let q = return 70 in q 8
10:17:41 <nainaide> great!!!
10:17:52 <ski>   =  let q = \s -> (s,70) in q 8
10:18:00 <ski>   =  (\s -> (s,70)) 8
10:18:05 <ski>   =  (8,70)
10:18:07 <ski> and that's it
10:18:21 <ski> do you understand better, now ?
10:18:37 <nainaide> sure, thank you ski
10:19:24 <ski> now, maybe you could try
10:19:51 * SamB thinks readline needs more QuickCheck
10:19:53 <monochrom> expanding >>= is a must. You shouldn't postpone it. In (blah >>= stuff)7, 7 is to be plugged into >>= first, not into blah first.
10:19:56 <ski>   q  =  p >>= (\x -> tick >>= (\y -> return (x,show y)))
10:20:03 <ski> evaluating
10:20:08 <ski>   q 3
10:20:11 <ski> on you own ?
10:20:18 <ski> (same `p' as before)
10:20:18 <nainaide> ok,
10:21:39 <nainaide> q 3 =  p >>= (\x -> tick >>= (\y -> return (x,show y))) 3
10:21:54 <ski> you need more brackets
10:22:28 <ski> `p >>= ... 3' is interpreted as `p >>= (... 3)', while you want `(p >>= ...) 3'
10:22:50 <nainaide> let  (\x -> tick >>= (\y -> return (x,show))) = f
10:23:44 <nainaide> q 3 =( p >> = f ) 3
10:24:03 <ski> (i assume you mean `f  =  (\x -> tick >>= (\y -> return (x,show)))' ..)
10:24:05 <ski> yes
10:24:58 <nainaide> = let (s1, a) = p 3; q = f a in q s1
10:25:27 <ski> yes
10:26:16 <nainaide> but I dont know q 3
10:26:25 <nainaide> but I dont know p 3
10:26:35 <ski> remember
10:26:42 <ski>   p  =  tick >>= (\n -> return (10*n))
10:26:42 <etpace_> Hmm, so I've finished LYAH -- now what?
10:26:59 <ski> etpace_ : RWH ? YAHT ?
10:27:18 <etpace_> I guess both cover monads?
10:27:28 <nainaide> p 3 = (4, 30) ?
10:27:35 <SamB> the gentle introduction?
10:27:45 <SamB> (not!)
10:27:45 <monochrom> LYAH doesn't do monads?
10:27:46 <ski> etpace_ : they ought to (i've not read either)
10:28:23 <etpace_> it does some monochrom
10:28:30 <etpace_> I'm sitll not completely comfortable though
10:28:34 <ski> nainaide : are you asking if that's the correct final answer .. or whether you have been showing most relevant evaluation steps ?
10:28:46 <nainaide> no
10:28:57 <nainaide> just in let (s1, a) = p3
10:29:03 * ski likes the gentle introduction ..
10:29:33 <ski> nainaide : yes .. but why ?
10:29:34 <nainaide> = let (s1, a) = p 3; q = f a in q s1
10:29:54 <monochrom> I started with the gentle introduction. It's no-nonsense. I like no-nonsense. Hate fluffy philosophical essays.
10:30:11 <nainaide> I think I need to evaluate p 3 to get (s1,a)
10:30:21 <ski> yes
10:30:58 <etpace_> Hmm.. How can I get vim's haskell-mode to align nicely like emacs? The way it aligned guards and the = sign was pretty nice, is it possible in the vim version?
10:31:00 <nainaide> let (4, 30) = p3, f  a in q s1
10:31:32 <ski> do you want to make sure you understand all evaluation steps of evaluating `p 3' ? or do you think you understand that good now, due to having done the similar `p 7' before ?
10:32:19 <ski> nainaide : that last `let (4, 30) = p3, f  a in q s1' is nonsense
10:32:20 <nainaide> ski, I dont think I understand it good, just according to p7 to infer p 3
10:32:31 <nainaide> my god
10:33:07 <ski> ok, then i suggest you continue from
10:33:15 <ski>   =  let (s1, a) = p 3; q = f a in q s1
10:33:28 <ski> and expand `p' there
10:34:04 <nainaide> = let (s1, a) = tick >>= (\n -> return (10*n)) 3; f a in q s1
10:34:14 <ski> (and brackets, again)
10:34:29 <nainaide> = let (s1, a) = (tick >>= (\n -> return (10*n))) 3; f a in q s1
10:34:33 <ski> yes
10:35:15 <ski> (if you're unsure about bracketing rules, you can always wrap expressions in brackets, when substituting)
10:35:42 <ski> so .. how to continue ?
10:35:47 <nainaide> = let (s1, a) = (\n -> (n+1, n)) 3;
10:36:13 <ski> no
10:36:16 <nainaide> (4,3)
10:36:46 <nainaide> ?
10:36:58 <ski> you forgot the ` >>= (\n -> return (10*n))' part
10:37:26 <ski> you want to know the values of `s1', and `a', right ?
10:37:33 <nainaide> yes
10:37:35 <Woof> @let bn 0 = id; bn n = tuple falsch (bn (n - 1))
10:37:37 <lambdabot>  <local>:19:18:
10:37:37 <lambdabot>      Occurs check: cannot construct the infinite type:
10:37:37 <lambdabot>       ...
10:37:40 <Woof> Why why why : (
10:38:00 <ski> so you need to simplify the right-hand-side of the definition of `(s1, a)' there, i.e. you need to simplify
10:38:05 <ski>      (tick >>= (\n -> return (10*n))) 3
10:38:41 <nainaide> = let (s1, a) = tick 3;   (\n -> return (10*n))) a in q s1
10:38:41 <ski> (Woof : mayhaps you're looking for dependent types ?)
10:39:15 <Woof> (ski: What's that? I was trying to define Barendregt encoding of numerals)
10:39:24 <nainaide> = let (s1, a) = (4, 3) ;    (\n -> return (10*n))) a in q s1
10:39:39 <ski> nainaide : stop
10:39:42 <nainaide> Am I right?
10:39:45 <ski> no
10:40:01 <ski> Woof : what is the (expected) type of `bn' ?
10:40:24 <ski> nainaide : `let (s1, a) = tick 3;   (\n -> return (10*n))) a in q s1' is invalid haskell syntax
10:40:28 <ski> it can't be right
10:40:41 <Woof> ski: Well I only know untyped lambda calculus. So I don't know
10:40:59 <nainaide> \s0->(let (s1, a) = tick 3;   (\n -> return (10*n))) a in q s1)
10:41:16 <ski> Woof : probably it can't be encoded in a typed lambda calculus, unles one has some form of dependent typing
10:41:32 <ski> nainaide : yes, that is invalid
10:41:40 <Woof> Hm, let's see. bn 0 gives id, which is of type a -> a. But bn 1 gives tuple false (bn 0) = tuple false id
10:42:03 <nainaide> \s0->(let (s1, a) = tick 3;  q= (\n -> return (10*n))) a in q s1)
10:42:18 <ski> it is invalid because you have `let (s1, a) = tick 3; (\n -> return (10*n))) a in ...' where the part between `;' and `in' not being a definition (or several)
10:43:42 <Woof> tuple m n= \x - > x m n, and false = \x y -> y
10:43:45 <ski> nainaide : which previous expression is that supposed to be equal to ?
10:44:22 <nainaide> = (let (s1, a) = tick 3;   q =(\n -> return (10*n))) a in q s1)
10:44:54 * ski awaits an answer ..
10:45:23 <Woof> So, bn 1  = \x -> x (\a b -> b) (\a -> a)
10:46:01 <nainaide> ski, mine still has errors?
10:46:08 <Woof> bn 1 = \x -> x (\b - > b)
10:46:39 <ski> nainaide : i can't tell if you don't tell me which previous expression that is supposed to be a simplification of
10:46:42 <Woof> Or: bn 1 = \x a -> x a
10:46:42 <nainaide>    =  let (s1, a) = (\n -> (n+1, n)) 7; q = (\n -> return (10*n)) a in q s1
10:46:47 <Woof> Which makes sense
10:47:55 <nainaide> ski, dont quite understand you.
10:49:01 <ski> that line was from my previous simplification of `p 7', which is not directly related to the current simplification of `q 3'
10:49:39 <ski> i'm expecting you to either continue simplify the *whole* expression
10:49:41 <ski>   =  let (s1, a) = p 3; q = f a in q s1
10:49:44 <ski> or
10:50:02 <ski> simplify a subexpression of this (and then say so)
10:50:12 <nainaide> understand now.
10:50:22 <nainaide> =  let (s1, a) = p 3; q = f a in q s1
10:50:43 <ski> (if you want to simplify another (related ?) expression for some reason, you must say so, too)
10:51:03 <nainaide> understand.
10:52:06 <conal> is there a handy tool for generating Show & Read instances for GADTs
10:52:07 <conal> ?
10:52:40 <ski> Woof : how does one check whether a barendregt numeral is zero or positive; i.e. how to define `caseNat' in `caseNat n (..if zero..) (\m. ..if succ m..)' ?
10:53:15 <FunctorSalad> conal: I just wrote a thing that uses haskell-src-exts to convert :info output to a case expression for the given type... might want to do something similar
10:53:20 <Woof> zero = \x -> x wahr
10:53:21 <Woof> That's how
10:53:22 <ski> (conal : existentials ?)
10:53:23 <Woof> (wahr = true)
10:53:26 <nainaide> ski, thank you, I think I have to calm done and do it offline. Because my response maybe too  slow and may cost you to much time. I can do this as my home work/
10:53:31 <Woof> > wahr 1 2
10:53:33 <lambdabot>   1
10:53:34 <conal> FunctorSalad: nice!
10:53:39 <FunctorSalad> conal: http://code.haskell.org/~daniels/infoToCaseE/
10:53:46 <conal> FunctorSalad: thx.
10:53:51 <ski> nainaide : ok, np
10:53:56 <nainaide> ski, thank you again.
10:54:06 <FunctorSalad> conal: (I mean, in case it's helpful as a starting point.)
10:54:18 <ski> nainaide : my advice is to do it slow and clear, one step at a time
10:54:18 <conal> FunctorSalad: got it.
10:54:41 <nainaide> ski, yes
10:54:44 <nainaide> I will
10:55:05 <ski> nainaide : also, it might be a good idea to rename bound variables when substituting
10:55:11 <ski> i.e. using
10:55:21 <ski>   p >>= k  =  \s0 -> let (s1, a) = p s0; q = k a in q s1
10:55:35 <conal> does TH handle GADTs?
10:55:45 <ski> instead of simplifying
10:55:50 <ski>      (tick >>= (\n -> return (10*n))) 7
10:55:50 <ski> as
10:55:58 <FunctorSalad> conal: no. that's why I had to use haskell-src-exts
10:56:00 <ski>   =  (\s0 -> let (s1, a) = tick s0; q = (\n -> return (10*n)) a in q s1) 7
10:56:06 <ski> simplify it as
10:56:24 <conal> FunctorSalad: okay.  thx again.
10:56:32 <ski>   =  (\s0_0 -> let (s1_0, a_0) = tick s0_0; q_0 = (\n_0 -> return (10*n_0)) a_0 in q_0 s1_0) 7
10:56:51 <nainaide> yes, I see.
10:57:03 <ski> er, actually i mean
10:57:14 <ski>   =  (\s0_0 -> let (s1_0, a_0) = tick s0_0; q_0 = (\n -> return (10*n)) a_0 in q_0 s1_0) 7
10:57:27 <ski> nainaide : that way you won't accidentally confuse different `s0',`s1',`q' from different calls to `(>>=)'
10:58:08 <ski> (i.e. only rename the local variables of `(>>=)' when you replace a call to it by its definiendum)
10:58:23 <nainaide> I see
10:58:32 <ski> (and next time use `_1', `_2', et.c.)
10:58:41 <conal> i just asked on haskell-cafe also (about Read/Show for GADTs)
10:59:22 <ski> nainaide : you might not need that for `q 3' .. but in some more complicated simplifications, this is needed to avoid confusion
10:59:28 <nainaide> yes, that is  a programer's  kongfu
10:59:52 <ski> nainaide : anyway, good luck
11:00:13 <nainaide> ski, thank you, have a good day!
11:02:58 <FunctorSalad> conal: my source could use a few comments ;) but the idea is to parse a decl, convert the constructors to a common abstract form, and then generate something from it
11:03:41 <FunctorSalad> currently the abstract constructor form is just name + arity, but that's enough for Show, isn't it?
11:05:40 <nainaide>   /quit
11:25:12 <conal> FunctorSalad: probably would be enough.
11:40:48 <hackagebot> gsasl 0.2 - Bindings for GNU SASL (JohnMillikin)
11:42:28 <iop> legalize weed, that will take income away from organized crime, tax businesses making legal weed and cut the income tax. police can focus on organized crime and less black people will go to jail because of ridiculous stuff like 3 strikes and youre out and get 20 years for smoking pot 3 times.
11:43:20 --- mode: ChanServ set +o shapr
11:43:23 <arjanb> agreed but what has this to do with haskell?
11:43:23 --- kick: iop was kicked by shapr (Kicked by shapr)
11:43:32 <shapr> I really need a ban alias.
11:43:37 <pikhq> Valid point, but WTF?
11:43:46 <shapr> I dunno, especially weird coming from a swede.
11:43:51 <Vanadium> legalise unsafePerformIO
11:43:52 <pikhq> Yeah.
11:47:51 <inimino> shapr: a ban alias?
11:47:57 <shapr> Yeah, for erc
11:48:08 <inimino> oh
11:50:24 <FunctorSalad> conal: cleaned it up a bit (split into general util / MakeCase example) and changed name ;) http://code.haskell.org/~daniels/srcExtsCodeGen/
11:50:47 <conal> FunctorSalad: sweet!
11:51:34 <FunctorSalad> I'll try making a Show deriver...
11:53:56 <Taejo_> When the world's getting complex and I miss the old days (when men were men and I was but a lad), I write my CGI scripts in bash
12:01:18 <Nereid_> :t \a b c -> (a b) (a c)
12:01:19 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
12:01:19 <lambdabot>     Probable cause: `a' is applied to too few arguments
12:01:19 <lambdabot>     In the first argument of `(a b)', namely `(a c)'
12:01:30 <Nereid_> er
12:01:36 <Nereid_> :t \a b c -> (a c) (b c)
12:01:37 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
12:01:42 <Nereid_> er
12:01:45 <Nereid_> @pl \a b c -> (a c) (b c)
12:01:45 <lambdabot> ap
12:01:49 <Nereid_> hur
12:03:23 <Nereid_> :src ap
12:03:26 <Nereid_> @src ap
12:03:26 <lambdabot> ap = liftM2 id
12:03:47 <trofi> @do liftM2 id
12:03:47 <lambdabot> liftM2 id not available
12:04:04 <Nereid_> where is this defined?
12:04:16 <trofi> ap ?
12:04:18 <Nereid_> yeah
12:04:21 <Badger> @index ap
12:04:21 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
12:04:21 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
12:04:55 <Raynes> Nereid_ Control.Monad is at the top of the Hoogle results. I'd go for it. :p
12:04:59 <Nereid_> wrong type though
12:05:26 <Nereid_> that one's m (a -> b) -> m a -> m b
12:05:37 <Badger> @ty ap
12:05:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:06:01 <Badger> I wonder if you can
12:06:08 <Badger> @index forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:06:08 <lambdabot> bzzt
12:06:24 <Badger> @hoogle forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:06:24 <lambdabot> Parse error:
12:06:24 <lambdabot>   --count=20 "forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b"
12:06:24 <lambdabot>                     ^
12:07:36 <Nereid_> @hoogle (t -> t1 -> t2) -> (t -> t1) -> t -> t2
12:07:36 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:07:36 <lambdabot> Data.Generics.Basics gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
12:07:36 <lambdabot> Data.Generics.Basics gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
12:07:54 <Nereid_> nope
12:08:43 <LeoD> what are you looking for? :o
12:08:54 <Nereid_> I'm looking for what @pl says ap is
12:08:57 <roconnor> @hoogle UArray i x -> [x]
12:08:57 <lambdabot> Data.Array.Base elems :: (IArray a e, Ix i) => a i e -> [e]
12:08:57 <lambdabot> Data.Array.IArray elems :: (IArray a e, Ix i) => a i e -> [e]
12:08:57 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
12:08:59 <Nereid_> @pl \a b c -> (a c) (b c)
12:08:59 <lambdabot> ap
12:09:06 <LeoD> Nereid_: Control.Monad is the right one
12:09:12 <Nereid_> @ty \a b c -> (a c) (b c)
12:09:13 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
12:09:20 <Nereid_> it certainly is not
12:09:40 <Nereid_> in any case, it's easy enough to define
12:09:47 <roconnor> @type unfoldr
12:09:48 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:10:03 <roconnor> @type until
12:10:05 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
12:10:54 <Nereid_> > until (==5) (+1) 0
12:10:55 <lambdabot>   5
12:11:41 <tibbe> @index until
12:11:41 <lambdabot> Prelude
12:11:48 <tibbe> woot
12:12:16 <tibbe> there's a function in the Prelude I don't know of
12:12:30 <LeoD> Nereid_: yes, i'm pretty sure it's the right one. ((->) r) is a monad too
12:12:52 <Zao> @src until
12:12:52 <lambdabot> until p f x | p x       = x
12:12:52 <lambdabot>             | otherwise = until p f (f x)
12:14:54 <LeoD> @ty ap :: (t -> t1 -> t2) -> (t -> t1) -> t -> t2
12:14:55 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
12:23:24 <Nereid_> LeoD: hmmm
12:31:47 <Nereid_> :t ap const const
12:31:48 <lambdabot> forall b. b -> b
12:31:56 <Nereid_> :-)
12:33:11 <FunctorSalad> conal: kinda got the Show deriver working. try cabal install; makeShow < Test
12:33:30 <FunctorSalad> it doesn't handle the type parameters or infix constructors yet
12:33:42 <Vanadium> @src liftIO
12:33:42 <lambdabot> Source not found.
12:33:55 <conal> FunctorSalad: doesn't handle any type parameters?
12:34:21 <FunctorSalad> conal: well, it just produces the instance decl as a string so you can add them manually ;)
12:34:38 <conal> FunctorSalad: sure.  easy enough.
12:34:46 <FunctorSalad> wouldn't it be kinda hard to get the context right with GADTs?
12:34:54 <conal> probably
12:36:29 <conal> FunctorSalad: i've heard that instance derivation is tough for GADTs.  haven't thought about it, myself.
12:38:35 <FunctorSalad> not sure how to handle infix constructors with all this precedence stuff :(
12:39:01 <Heffalump> it's tough because of existentials
12:39:11 <FunctorSalad> GHC's native "deriving Show" depends on infix declarations
12:39:14 <Heffalump> and also perhaps because you can have class contexts in the constructors and people might expect the derivation touse them
12:39:15 <FunctorSalad> (infixl etc)
12:39:21 <Heffalump> (instance derivation for GADTs, that is)
12:39:49 <FunctorSalad> I guess it should just be left to the user on a case-by-case basis
12:41:38 <conal> FunctorSalad: maybe the haskell-cafe note will turn up some insights.
12:48:05 <FunctorSalad> conal: to clarify, it does work with GADTs with parameters, it just doesn't produce any params in the output
12:50:31 <olsner> one thing that annoys me with haskell is that the syntax for a single-constraint context is completely different from multiple-constraint contexts
12:52:48 <olsner> e.g. if I have "foo :: Foo a => a" and suddenly realize i need to add Bar a as well, I have to add a pair of parens to make it (Foo a, Bar a) - annoying
12:53:11 <FunctorSalad> would you rather if the first form was just banned...?
12:53:28 <canvon> AFAIK you can just use "foo :: (Foo a) => a" as well
12:53:56 <canvon> (same with "deriving")
12:55:20 <olsner> FunctorSalad: I'd rather something like "Foo a, Bar a => a", but that is impossible since it would create ambiguosities in other parts of the grammar
12:55:45 <rocketman> how about Foo a => Bar a => a
12:56:05 <conal> yeah.  curried contexts work
12:56:11 <olsner> (at least, I assume that is the reason for currently requiring tuple syntax)
12:56:15 <conal> i asked for that syntactic extension.
12:57:02 <conal> tho curried contexts haven't been consistently applied.
12:57:15 <conal> i don't think they work for class or instance decls
12:57:16 <olsner> they only work sometimes?
13:01:20 <Heffalump> I understand what you mean by curried, but it seems an odd name given that order is insignificant.
13:01:33 <hackagebot> happstack-server 0.3.3 - Web related tools and services. (MatthewElder)
13:01:33 <hackagebot> happstack-state 0.3.3 - Event-based distributed state. (MatthewElder)
13:01:33 <hackagebot> cabal2spec 1.0 - Generates RPM Spec files from cabal files (YaakovNemoy)
13:03:28 <conal> Heffalump: maybe not so odd if you think of implicit arguments.
13:04:17 <conal> Heffalump: and the same ordering considerations apply to the non-curried notation.
13:05:33 <rocketman> clearly we should be using {Foo a, Bar a} => a
13:16:12 <Heffalump> conal: implicit arguments are just like type classes in terms of ordering
13:16:14 <Heffalump> aren't they?
13:18:45 <conal> Heffalump: whoever is filling in the arguments has to get them in a particular order
13:19:30 <conal> whether curried or uncurried, explicit (human-written) or implicit (compiler-written)
13:20:31 <Heffalump> true, but you're not normally one for letting implementation considerations affect the source language ;-0
13:20:34 <Heffalump> s/0/)/
13:22:40 <conal> i wonder if there *is* a simpler semantic explanation of type classes than dictionary passing.  (note: semantics, not implementation)
13:22:56 <conal> more generally, argument synthesis.
13:24:24 <dons> dictionary passing is fairly intuitive though, isn't it?
13:24:53 <conal> it is for me.  that's why i don't think of it as an implementation consideration.
13:25:24 <conal> there might be a simpler way though.
13:30:55 <Heffalump> I was more thinking of argument order as the implementation consideration; I sort of view them as all appearing at once, but not in any particular order.
13:34:19 <conal> Heffalump: i could tell.  the oddness is perspective-dependent.
13:35:58 <conal> as in http://lesswrong.com/lw/ro/2place_and_1place_words/
14:01:53 <vijay4114> babel
14:02:40 <vijay4114> @help
14:02:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:02:56 <vijay4114> @list
14:02:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:03:04 <vijay4114> list
14:03:09 <vijay4114> help list
14:03:18 <vijay4114> @help list
14:03:18 <lambdabot> list [module|command]
14:03:18 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
14:03:31 <vijay4114> @babel
14:03:31 <lambdabot>   bzzt.
14:03:46 <vijay4114> @babel hello
14:03:46 <lambdabot>   bzzt.
14:04:00 <vijay4114> @src
14:04:00 <lambdabot> src <id>. Display the implementation of a standard function
14:04:07 <vijay4114> @src map
14:04:07 <lambdabot> map _ []     = []
14:04:07 <lambdabot> map f (x:xs) = f x : map f xs
14:05:18 <vijay4114> @system
14:05:18 <lambdabot> Unknown command, try @list
14:05:32 <vijay4114> @listmodules
14:05:32 <lambdabot> activity babel base bf check compose dice dict djinn dummy elite eval fact free fresh ft haddock help hoogle instances irc karma localtime more oeis offlinerc pl pointful poll pretty quote search
14:05:32 <lambdabot> seen slap source spell state system tell ticker todo topic type undo unlambda unmtl version vixen where
14:06:27 <vijay4114> @karma
14:06:27 <lambdabot> You have a karma of 0
14:06:32 <vijay4114> @karma-all
14:06:32 <lambdabot>  "moritz"              744
14:06:32 <lambdabot>  "pmichaud"            511
14:06:32 <lambdabot>  "lwall"               485
14:06:32 <lambdabot>  "jnthn"               406
14:06:32 <lambdabot>  "pmurias"             388
14:06:34 <lambdabot> [1566 @more lines]
14:06:51 <vijay4114> @fact
14:06:51 <lambdabot> I can not handle empty facts.
14:07:06 <vijay4114> @users
14:07:06 <lambdabot> Maximum users seen in #haskell: 658, currently: 615 (93.5%), active: 10 (1.6%)
14:07:09 <Botje> vijay4114: mind /querying lambdabot ?
14:07:23 <vijay4114> how do you do that??
14:07:27 <vijay4114> i'm new here
14:07:28 <Botje> /query lambdabot
14:07:34 <vijay4114> ok thanks
14:07:36 <Botje> or /msg lambdabot @users
14:07:40 <vijay4114> sorry for interrupting the channel
14:07:52 <mauke> Botje: /msg will not necessarily open a query window
14:08:01 <Botje> the response will :)
14:08:05 <mauke> Botje: no
14:08:20 <coCocoa> What's a good name for (factor . not) ?
14:08:22 <Botje> i recall mirc, xchat, and irssi doing that
14:08:35 <Botje> coCocoa: what's factor do?
14:08:36 <rocketman> don'tFactor
14:08:47 <vijay4114> i did the /query
14:08:47 <coCocoa> Sorry, s/factor/filter
14:08:52 <vijay4114> sorry for interrupting guys
14:08:57 <coCocoa> What's a good name for (filter . not) ?
14:08:58 <Botje> no problem :)
14:09:04 <rocketman> :t filter . not
14:09:05 <lambdabot>     Couldn't match expected type `a -> Bool'
14:09:05 <lambdabot>            against inferred type `Bool'
14:09:05 <lambdabot>     In the second argument of `(.)', namely `not'
14:09:06 <Botje> if you have a haskell question, don't hesitate to ask us humans
14:09:11 <rocketman> :t (filter .) . not
14:09:12 <lambdabot>     Couldn't match expected type `a1 -> a -> Bool'
14:09:12 <lambdabot>            against inferred type `Bool'
14:09:12 <lambdabot>     In the second argument of `(.)', namely `not'
14:09:26 <coCocoa> :t (filter . not)
14:09:27 <lambdabot>     Couldn't match expected type `a -> Bool'
14:09:27 <lambdabot>            against inferred type `Bool'
14:09:27 <lambdabot>     In the second argument of `(.)', namely `not'
14:09:41 <rocketman> :t filter . (not .)
14:09:42 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:09:43 <coCocoa> :t filter . (not .)
14:09:44 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:09:59 <mauke> Botje: depends on autocreate_query_level
14:10:02 <coCocoa> Okay, what's a good name for that function? :)
14:10:03 <Botje> coCocoa: without ?
14:10:10 <Botje> without even [1..]
14:10:30 <coCocoa> Botje: Sounds good, thank you. :)
14:11:05 <Botje> mauke: never heard of it, but fair enough
14:20:45 <RenJuan> is there something that contrasts/compares 6.8 vs. 6.10?
14:20:58 <Botje> 6.10 has base 4
14:21:03 <RenJuan> (i.e. ghc)
14:22:56 <RenJuan> Botje, I see. And how much stuff is sensitive to the base-3 vs base-4 diff?
14:23:42 <RenJuan> or is it transparent after compile?
14:23:43 <Botje> almost all of hackage should compile in 6.10
14:23:54 <Botje> and i believe there's some support for parallel GC in 6.10
14:24:05 <Botje> RenJuan: have you read the GHC 6.10.0 release notes?
14:24:44 <Botje> they probably have more info :)
14:25:05 <RenJuan> no, and I would expect the practical matter of fact of how current 6.10 stood to Haskell apps generally (vs. 6.8) to be there
14:25:11 <RenJuan> *wouldn't
14:25:59 <RenJuan> I any case I take it virtually any haskell package would compile with either
14:26:05 <RenJuan> *In
14:26:17 <byorgey> most do, yes.
14:26:36 <RenJuan> got it, thx
14:26:39 <byorgey> and those that don't generally would require only small changes.
14:26:47 <Botje> all the New Shiny Exciting stuff in 6.10 is in the release notes :)
14:27:08 <RenJuan> Acknowledged, will review.
14:27:36 <coCocoa> TH and QQ are 6.10+
14:28:23 <noteventime> QQ?
14:28:37 <Botje> a glorious pair of queens!
14:28:37 <RenJuan> TH requires it?
14:28:37 <ski> (maybe quasi-quotation ?)
14:28:41 <coCocoa> No, maybe some of TH came in with 6.8... but QQ was definitely 6.10 (well, 6.9, but that's a HEAD release, not main-line). :)
14:29:05 <coCocoa> noteventime: Yes, QQ is QuasiQuotations
14:29:29 <noteventime> Ahh, ok
14:30:19 <coCocoa> TH (Template Haskell) may have been available somewhere in the 6.8 line, but I remember all sorts of folks had to "hack" the 6.9 HEAD to get QQ in. :)
14:31:25 <coCocoa> And by "all sorts of folks," I mean like Audrey Tang-level.
14:32:18 <sjanssen> coCocoa: TH has been in GHC for much longer than that
14:32:50 <sjanssen> but yes, QQ were new
14:33:31 <Badger> > lines "foo\nbar"
14:33:32 <lambdabot>   ["foo","bar"]
14:33:57 <Badger> > unlines ["baz","quux"]
14:33:58 <lambdabot>   "baz\nquux\n"
14:35:05 <Peaker> @src unlines
14:35:05 <lambdabot> unlines = concatMap (++ "\n")
14:36:26 <Badger> Peaker: what does foo' signify?
14:36:36 <Peaker> Badger: where?
14:36:41 <Badger> @src words
14:36:41 <lambdabot> words s = case dropWhile isSpace s of
14:36:41 <lambdabot>     "" -> []
14:36:41 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
14:36:43 <Raynes> @index when
14:36:43 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:36:47 <dcoutts> @seen Saizan_
14:36:47 <lambdabot> Saizan_ is in #haskell-in-depth, #ghc, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard Saizan_ speak 2h 21m 6s ago.
14:37:03 <Peaker> Badger: it usually means either a "modified" foo, or a strict foo
14:38:22 <Badger> Peaker: when s has been modified the case matches?
14:39:12 <Peaker> Badger: s' is a pattern, so it is assigned the value of s after having dropped spaces
14:39:24 <Peaker> Badger: so s' is "s" which was "modified" to remove heading spaces
14:39:27 <idnar> Badger: the ' doesn't have any syntactic meaning, it's just a naming convention
14:39:41 <idnar> you could use s2 and s3 instead of s' and s''
14:40:03 <Badger> ah, okay
14:57:46 <Peaker> yairchu: hey http://www.reddit.com/r/haskell/comments/8ye59/functional_pearl_a_program_to_solve_sudoku_pdf/
14:57:55 <Peaker> yairchu: maybe your solver is even more elegant, with Producer/Consumer? :)
14:58:19 <yairchu> Peaker: My solver doesn't use Producer, just list monad
14:58:29 <Peaker> yairchu: oh, I thought you said it did
14:58:45 <yairchu> Peaker: I used Producer for other project euler problems
15:00:04 <hackagebot> terrahs 0.7 - A library for GIS Programs in Haskell. (SergioCosta)
15:08:32 <RenJuan> Terrah was Abrahams father or something wasn't e?
15:15:17 <roconnor> oh no.  Richard Bird is solving sudoku.  I fear to look.
15:15:38 <conal> i liked his icfp07 sudoku talk!
15:16:06 <Peaker> conal: is that the source of the "Functional Pearl"?
15:16:26 <conal> Peaker: i'm pretty sure it is.  or vice versa.
15:17:08 <roconnor> this doesn't look as nice as Conor's solution
15:17:17 <roconnor> not enough use of traversable!
15:17:20 <dcoutts> he did it first for some of our first year students
15:17:33 <dcoutts> then turned it into the functional perl paper
15:18:21 <roconnor> Conor defined a board to be of type (Triple (Triple (Triple (Triple a))))
15:18:48 <ehird> Triple^4 a
15:18:57 <conal> roconnor: four dimensional??
15:19:14 <ehird> conal: He plays sudoku IN TIME.
15:19:15 <roconnor> then provided symmetry operations to turn rows into columns or columns into blocks, or blocks into rows, etc.
15:19:23 <conal> ehird: conor rules!
15:19:37 <roconnor> which is all implemented by using something like sequence or traversiable or something lifted at appropriate levels.
15:19:43 <conal> wow!
15:19:44 <inimino> hehe "functional perl paper"
15:19:48 <SamB_XP> conal: you're maybe thinking of tic-tac-toe?
15:19:50 <roconnor> (of course Triple is an applicative functor)
15:19:59 <conal> (richard bird programs in pugs?)
15:20:03 <Peaker> roconnor: Doesn't that structure have 3^4 a's in it?
15:20:14 <ehird> blank=(=â.â)
15:20:17 <ehird> Syntax fail :-)
15:20:20 <Peaker> roconnor: oh, forget that ;-)
15:20:24 <SamB_XP> > 3^4
15:20:25 <lambdabot>   81
15:20:29 <roconnor> conal: sudoku is a 3*3 square of 3*3 squares
15:20:31 <SamB_XP> > 9*9
15:20:32 <lambdabot>   81
15:20:51 <conal> roconnor: oh yeah.  thx.
15:21:20 <roconnor> so conor just writes 1 function to say, check 3x3 blocks for consistency
15:21:43 <roconnor> and then uses symmetries to check rows and columns using this one function
15:31:39 <chrisdone> so did that dude figure out the state monad then?
15:32:44 <chrisdone> nainade or whatever
15:46:52 <dmner> Hello #haskell, I have a few questions
15:47:44 <dmner> So I am using System.Posix.Files to get filestatus information and extract what I need and I am trying to serialize the data back out
15:48:41 <dmner> I can generate a string via show although show is slow and most of the program's time is "wasted" in show
15:49:06 <Twey> Look into bytestrings
15:49:38 <Twey> Haskell strings are linked lists â they're not designed for heavy-duty usage
15:50:00 <dmner> I read into them however, how can I convert CInt and other Foreign.C.types as FileStatus information is returned via those types
15:50:10 <Zao> Twey: Single-linked, even.
15:50:32 <SamB_XP> Zao: well, yeah -- doubly-linked lists are even slower in Haskell!
15:51:01 <dmner> doublely linked lists ... that would be a bit wonky to implement
15:52:18 <Twey> DLList a = DLNode a a | DLNull
15:52:22 <Twey> Er
15:52:38 <Twey> DLList a = DLNode a (DLList a) (DLList a) | DLNull
15:52:53 <Zao> Also known as a list zipper.
15:52:53 <SamB_XP> Twey: what about the beginning and end ?
15:53:10 <Vanadium> Can you write fromList :: [a] -> DLList a?
15:53:13 <Twey> You'd have to maintain them separately, I guess
15:53:33 <dmner> ok so most of the types I need (with the exception of some time types) are integrals. So fromIntegral could get me Integers and then use bytestring to serialize it?
15:54:52 <Twey> Hmm.
15:55:07 <Twey> True, it's trickier than it seems
15:56:12 <Twey> It's annoying that so many IO functions return String rather than ByteString...
15:56:23 <dmner> I've been racking my brain on this conversion for a bit now, I can't see a way to get rid of show some where, Text.printf gives the approximately the same performance as show
15:57:39 <dmner> I agree Twey, many things require (FilePath for instance) or give (readDirStream) strings
15:59:22 <chrisdone> Twey: I'd like a Stringish class...
15:59:36 <Twey> I'd like extensible types
15:59:38 <chrisdone> getLine :: Stringish a => IO a
15:59:57 <peter_12> I don't mean this with any connotation: While I'm reading about Haskell it seems like Common Lisp in the way that Common Lisp is the Lisp family's "industrial strength" member. Is there al language in the Haskell family that is more along the lines of Scheme's place in the Lisp family?
16:00:02 <dmner> It would cause problems for programs that deconstruct strigns knowing that they are lists
16:00:16 <Twey> peter_12: Er, there isn't really a âHaskell familyâ per se
16:00:19 <chrisdone> dmner: a Stringish class?
16:00:24 <Twey> There's just Haskell
16:00:40 <Twey> And a couple of conceptual variations like Liskell and O'Haskell
16:00:46 <peter_12> Twey: alright then
16:01:06 <dmner> chrisdone: yes a Stringish class (if they reimplemented functions to use it)
16:01:08 <chrisdone> OâCaml could be class as Haskell without anything good, disregarding the modules
16:01:11 <chrisdone> dmner: why?
16:01:12 <Twey> Haskell isn't a minimalistic language, by design
16:02:05 <dmner> chrisdone: ... on second thought it wouldn't cause problems they could just explicitly use Strings as lists
16:02:08 <chrisdone> mhm
16:02:18 <rocketman> peter_12 interesting question
16:02:18 <Nereid_> so, I'm getting an error
16:02:29 <Nereid_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6553
16:02:53 <peter_12> Twey: I think that is why I'm getting the impression that Haskell is "industrial strength" (I don't know why they use that term but they do.)
16:02:59 <chrisdone> peter_12: perhaps you could judge it by implementation, GHC is the industiral stength hardcore implementation
16:03:00 <Nereid_> I don't quite like the fix in id'
16:03:16 <peter_12> chrisdone: that is a good point
16:03:24 <noteventime> peter_12: Maybe SML?
16:03:30 <Nereid_> also, as soon as I remove the type constraints there are no problems
16:03:30 <noteventime> It's not Haskell family
16:03:52 <rocketman> peter_12: There isn't any parallel with lisp but if you would like to see a different take on haskell, http://www.cs.uu.nl/wiki/bin/view/Ehc/Examples builds it (actually a slighly more advanced, more uniform) up progressively
16:03:54 <Nereid_> any other ways to fix it? some sort of pragma perhaps
16:04:01 <Elly> SML is not like scheme
16:04:04 <peter_12> noteventime: SML is on my list of languages to learn. It is strongly typed with type inference, correct?
16:04:22 * Elly personally finds SML distinctly inferior to haskell
16:04:25 <dmner> Well, thanks Zao and Twey I will look into going through integrals and then create bytestrings from that
16:04:52 <peter_12> rocketman: thanks
16:05:08 <noteventime> Elly: Couldn't say, barely used it. And I found all ML languages to feel like boring Haskell's :p
16:05:25 <noteventime> But that can probably be attributed to the fact that I've barely used any of them
16:05:29 <Elly> SML lacks typeclasses, or even anything remotely useable as an emulation tthereof
16:05:40 <Elly> (please excuse my typing; I'm on a very laggy link)
16:06:01 <Elly> SML's module system is tied up with its structure/functor system, which strikes me as inelegant
16:06:04 <noteventime> peter_12: Dunno, if anything I'd check out OCaml, but I still think Haskell more fun
16:06:13 <Elly> and development tools (esp. debuggers) are lacking or nonexistent
16:06:57 <noteventime> Or possible F# is you're into .NET
16:07:08 <noteventime> Not that I see how anyone can _be into_ .NET :p
16:07:23 <chrisdone> being employed can make you _into_ .NET
16:07:31 <SamB_XP> at least .NET has tools
16:07:32 <chrisdone> Jon Harrop makes me not want to try F#, which is amusing
16:07:36 <SamB_XP> chrisdone: that's horrip
16:07:42 <chrisdone> whatever
16:07:42 <SamB_XP> er. horrible
16:07:46 <SamB_XP> you can become .NET?
16:07:55 <noteventime> chrisdone: I wouldn't say _be into_ is the say as _forced into_ :p
16:08:05 <SamB_XP> wasn't correcting your spelling, just misspelling horrible ;-)
16:08:07 <chrisdone> SamB_XP: do spangles? lojbano?
16:08:33 <SamB_XP> ???
16:08:43 <chrisdone> I use .NET at work and it has a nice big library
16:08:44 <inimino> harrople?
16:09:02 <chrisdone> pitty it takes about ten lines of X = new StupidlyGenericThingie(..); to do anything
16:09:44 <noteventime> There seems to be some kind of connection between "office" programming languages and verbosity
16:09:56 <noteventime> Programmers aren't being payed per LOC, are they?
16:10:13 <SamB_XP> noteventime: not in sane places, no
16:10:23 <SamB_XP> but too many places aren't sane
16:10:34 <chrisdone> (judging software progress by lines of code = judging planes progress by weight)
16:11:04 <SamB_XP> (not to say that there are a lot of places that actually display insanity in this particular way)
16:11:15 <noteventime> SamB_XP: The only reason I can think of for COBOL ever being popular p
16:11:35 <Elly> COBOL was popular back when we thought the hard part of programming was the syntax
16:11:35 * coCocoa is waiting for the inevitable release of COBOL.NET
16:11:35 <Nereid_> no one has any ideas I guess?
16:11:44 <inimino> many software projects go the way of the Grey Goose
16:11:45 <SamB_XP> noteventime: perhaps it gave bussinesspeople the illusion that they could understand the code?
16:11:56 <Elly> unfortunately, it cdidn't become unpopular when we realized that was wrong :P
16:12:04 <Elly> didn't, rather
16:12:13 <noteventime> coCocoa: VB.NET was released ages ago?
16:12:16 <SamB_XP> coCocoa: it's not out yet?
16:12:31 <noteventime> SamB_XP: Interesting theory :)
16:12:47 <coCocoa> SamB_XP: It still "Slouches towards Redmond, to be born"... ;)
16:12:47 <SamB_XP> noteventime: VB is sane compared to cobol, I think
16:12:47 <chrisdone> I use horrible not-even-MVC (shock! horror! get out!) style code and use JScript server side rather than c# or visual basic... one day I may learn how to program ENTERPRISE but it's so hard to enjoy it
16:13:05 * Elly uses python, C, and scheme :)
16:13:10 <Elly> (for work, I mean)
16:13:12 <noteventime> SamB_XP: Well, it has had a number of years to evolve, I guess even Microsoft can make progress
16:13:13 <snurble> coCocoa, Fujitsu has COBOL for .NET if you're intrested. :-)
16:13:37 <copumpkin> coCocoa: are you Cocoa's dual?
16:13:38 <Axman6> Elly: could  be worse :)
16:13:44 <SamB_XP> chrisdone: to this day, I don't understand the view/controller split
16:13:45 <inimino> chrisdone: JScript?
16:13:50 <coCocoa> snurble: No thanks, I was just jesting.
16:13:55 <Elly> Axman6: those are pretty much my languages of choice
16:14:06 <Elly> well, python's not, but the simulator we're using only has python bindings
16:14:06 <Axman6> o haskell?
16:14:07 <chrisdone> inimino: yeah it's like Microsoft's JavaScript, but .NET -- so it has type annotations and .NET goodies
16:14:09 <Axman6> no*
16:14:24 <SamB_XP> coCocoa: why not just "coa"?
16:14:26 <Elly> Axman6: I've yet to trip over a task for which I can justify using haskell
16:14:36 <coCocoa> copumpkin: Yes; I am completely uninvolved in development for Apple technologies. :)
16:14:36 <Axman6> :(
16:14:45 <inimino> chrisdone: I've never heard of it outside of the context of IE.
16:14:59 <coCocoa> SamB_XP: You mean "Coa"? ;p
16:15:01 <Peaker> Elly: What "justifies" the use of Scheme, btw?
16:15:20 <Elly> Peaker: I wanted to learn scheme ;P
16:15:26 <SamB_XP> coCocoa: eh? now the co at the beginning cancels the one before the a?
16:15:34 <chrisdone> SamB_XP: I actually go the the opposite end, e.g. with formlets. putting the view/control together in one place keeps it nice and consitent and abstract. but that doesn't allow !SEPERATION OF CONCERNS!
16:15:38 <Peaker> Elly: Ah, at work I use Haskell for little tools and stuff, as of yet
16:15:45 <inimino> chrisdone: so I guess it has all the elegance of the JavaScript programming language without any of the annoying portability?
16:15:51 <Elly> that's what I use scheme for
16:15:56 <Peaker> Elly: Once we have a good FRP implementation that works reliably, I'd use it for GUIs all over the place :)
16:16:03 <Peaker> Elly: why not Haskell for that?
16:16:07 <Elly> in practice I know I can't use scheme for anything major because nobody else there knows scheme
16:16:18 <Elly> because I decided to use scheme first, and the less languages the better
16:16:34 <SamB_XP> chrisdone: I only like to seperate concerns when I can figure out what the heck the concerns that I'm seperating are differentiated by ;-)
16:16:45 <chrisdone> inimino: yeah. the annoying thing about it is that the standard datatypes can't be extended in the usual prototype based javascript way. so I've got my own jquery like wrapper e.g. $(something).map(function(){..}) etc
16:17:29 <coCocoa> I feel as if we should be doing FRP development with comonads. But then, I'm prejudicially fond of comonads for some reason... ;)
16:17:44 <inimino> chrisdone: oh, wow
16:17:54 <Peaker> coCocoa: I don't think the problem with FRP is the type-classes?
16:18:05 <chrisdone> SamB_XP: indeed. from the literature I've read on MVC, the hardest part is differentiating the controller and the view. most programs seperate model from control and view anyway, so the whole idea is basically a silly way to say 'try to make code cleaner'??
16:18:22 <Peaker> coCocoa: When you say comonadic FRP, what changes to the primitives/types do you mean?
16:18:25 <dibblego> chrisdone, yes (though it gets even sillier)
16:18:56 <chrisdone> dibblego: it does? *eyebrow*
16:19:15 <noteventime> chrisdone: Most programming/IT buzz seems to be fancier ways of saying "write code cleaner"
16:19:24 <Peaker> coCocoa: Instead   of a (Behavior a) monad, it should be a comonad?
16:19:26 <dibblego> chrisdone, yes, in the implicitly stated effort to make code cleaner, it does it quite the opposite
16:19:44 <inimino> or it was a brilliant way to sell books that say "try to make code cleaner"
16:19:52 <chrisdone> haha... yes!
16:19:58 <roconnor> I feel the same way about capabilities security.  It just seems like a smart way to code.
16:20:25 <noteventime> inimino: Not just books, people get payed for telling people to do it
16:20:30 * copumpkin wonders if we could enforce MVC through typing, just for the **** of it
16:20:41 <coCocoa> Peaker: For instance, Streams are "obviously" comonadic, so I feel as if the Event/Behavior is more analogous to a comonadic transformer, than a monadic one. Of course, I'm just commenting, and not helping, so take my ramblings lightly. :)
16:20:45 <Peaker> chrisdone: lots of programs throw actual *logic* in GUI callbacks, so MVC is more about those
16:20:47 <inimino> well, yes books and consultants
16:21:14 <Peaker> coCocoa: But if Event is a comonad, it means there's   (Event a -> a) right?
16:21:19 <noteventime> Which I as an outsider find quite hilarious :p
16:21:44 <inimino> maybe not quite as successful as design patterns and agile methodologies in that department
16:21:46 * Axman6 is quite happy. got 68% in a course he was expecting to just pass :D
16:21:54 <chrisdone> Axman6: yaaay!
16:22:02 <noteventime> If my income was depending on the money spent on paying people like that, I'd be furious
16:22:09 <Axman6> kinda cut i didn't get a distinction now :P
16:22:29 <Axman6> i get the rest of my results today :o
16:22:41 <noteventime> Axman6: Similar thing just happened to me
16:22:51 <dmner> Hello, again. So going through integral ( trying to convert CInt and other Foreign.C.Types returned by System.Posix.Files FileStatus functions) resulted in some interesting results. Obviously Word8 values were not  what I was looking for.
16:22:52 <noteventime> With a horrible multivariable calculus course
16:22:53 <Axman6> :D
16:23:29 <Peaker> coCocoa: Is IO a Comonad?
16:23:51 <Axman6> mine was an engineering systems analysis course. all stats :(
16:24:06 <Cale> Peaker: no, not really
16:24:25 <Peaker> Cale: then I don't think FRP's Event/Behavior are, either
16:24:34 <Cale> Peaker: There's no reasonable way to make it one without providing for arbitrarily many universes.
16:25:05 <Cale> Hmm... though, whichever one it was that already had a value ready might be one.
16:25:12 <Cale> Was that Reactive?
16:25:13 <SamB_XP> roconnor: since when is capabilities about security?
16:26:17 <SamB_XP> to me, it just seems like a good way to get pieces of code in touch with the facilities they need ...
16:26:38 <roconnor> SamB_XP: since http://en.wikipedia.org/wiki/Capability-based_security
16:27:18 <roconnor> or since http://www.erights.org/
16:27:22 <Peaker> SamB_XP: capabilities were always about security, but they happen to coincide with good design anyway
16:27:28 <dmner> So does anyone have a suggestion for serializing CInt Ctime and other Foreign.C.Types
16:27:29 <hackagebot> feed-cli 2009.7.5 - A simple command line interface for creating and updating feeds like RSS (IsaacJones)
16:27:50 <Peaker> dmner: maybe they have Data.Binary instances?
16:27:51 <roconnor> I can't wait until 128-bit computers
16:27:56 <Peaker> roconnor: why?
16:28:03 <Cale> Peaker: yeah, Reactive is a Comonad.
16:28:12 <roconnor> then we can have true capabilites based OSs
16:28:14 <dmner> Peaker: They don't, already checked into that one
16:28:17 <Cale> Peaker: (and a Monad)
16:28:33 <chrisdone> nice, hackagebot has been upgraded to show the description since I last saw it. *thumbs up*
16:28:34 <roconnor> Peaker: you just hide your sensitive functions somewhere random in the address space
16:28:59 <roconnor> don't know where the function is?  Then you can't call it.
16:29:08 <Axman6> roconnor: IBM has an OS that's 128 bit
16:29:10 <Ansible> noob question here:  I installed grapefruit, the frp lib, with cabal and it says on the wiki documentation should be in "$HOME/.cabal/share/doc/".  Nothing is there except for some license files though.  Anything I'm normally supposed to do to get docs?
16:29:15 <roconnor> Axman6: really?
16:29:22 <Axman6> yep
16:29:31 <Cale> dmner: They must have Storable instances though. So you could use storable-vector or whatever it was called.
16:29:33 <roconnor> is it capabilities based? :)
16:29:50 <Cale> http://hackage.haskell.org/package/storablevector
16:30:02 <dmner> Cale: thanks
16:30:04 * roconnor also wants to know the answer to Ansible's question
16:30:05 <zebrafinch> roconnor: can't you read the code of anything you can call to get access to the transitive closure of your capabilities?
16:30:11 <FunctorSalad> Ansible: --enable-documentation
16:30:12 <Axman6> roconnor: http://en.wikipedia.org/wiki/IBM_System_i
16:30:34 <Ansible> so "cabal --enable-documentation"
16:30:45 <roconnor> zebrafinch: yep, but you can't get the code of anything that calls you.
16:30:46 <Cale> Wow, a whole library where Henning Thielemann managed not to name anything T or C!
16:30:59 <Peaker> Cale: Behavior is a Comonad, but Event isn't
16:31:01 <FunctorSalad> Ansible: "cabal install --..." yes
16:31:18 <zebrafinch> roconnor: can't you read the return address off the stack?
16:31:28 <Ansible> ah, have to reinstall those packages... thx.
16:31:37 <Peaker> roconnor: why is that so much better than language-level or OS-level enforcement of capabilities?
16:31:56 <roconnor> zebrafinch: presumably not.
16:31:57 <chrisdone> speed?
16:32:14 <Peaker> chrisdone: was that an answer to my question?
16:32:16 <roconnor> Peaker, easier enforcement.
16:32:36 <Peaker> chrisdone: language-level is fast -- basically a type system.  OS-level is fast in the sense everyone is already paying the penalties for it
16:32:44 <Axman6> "While in Unix-like systems everything is a file, on the System i everything is an object, with built-in persistence and garbage collection. It also offers Unix-like file directories using the Integrated File System [2]. Java compatibility is implemented through a native port of the Java virtual machine."
16:32:50 <Axman6> interesting
16:33:37 <Ansible> yay, did "cabal install grapefruit-frp --enable-documentation --reinstall" and now have an html folder.  Is there a way to make --enable-documentation to always be on?
16:33:57 <chrisdone> Peaker: ok
16:34:01 <roconnor> Peaker: langauge level enforcement means you can't load arbitrary binaries (which might actually be an advantage)
16:34:20 <SamB_XP> roconnor: how so?
16:34:28 <roconnor> Peaker: I don't see how to enforce it at the OS without hardware support such as this.
16:35:01 <roconnor> SamB_XP: if you have only a 32-bit address space, then an arbitrary binary can hunt around for the sensitive functions.
16:35:04 <SamB_XP> and using 128 bit addresses just sounds like "security through obscurity"
16:35:23 <Peaker> roconnor: what are "arbitrary binaries"? what can load them?
16:35:28 <roconnor> SamB_XP: in the say way that a 128-bit encryption key is security through obsurity.
16:35:31 <roconnor> same way
16:35:42 <Philippa> give or take, anyway
16:35:49 <Philippa> the addresses are keys
16:35:52 <Peaker> roconnor: fine-grained capabilities at the hardware-level probably means lots of little processes, which may be inefficient, I guess.  But coarse-grained caps are ok with OS-level
16:35:55 <SamB_XP> but all of the bits of the key are more-or-less arbitrary
16:36:02 <roconnor> Peaker, arbitrary binaries is what I download with binary based linux distributions such as ubuntu.
16:36:25 <Philippa> SamB: and a 128-bit address space is enough to do the same with addresses. Well, maybe 64 bits' worth of them
16:36:26 <SamB_XP> what exactly is enforced ?
16:36:26 <Peaker> roconnor: they're specially-formatted for execution. The special format can include type-proofs
16:36:29 <chrisdone> g'night chaps, have a good'un
16:36:50 <roconnor> Peaker, yes there are plausible ways to do language based security.
16:37:44 <roconnor> Peaker, or is this what you mean by OS-based security? The executables are "type-checked" for security first?
16:37:48 <Peaker> roconnor: btw: I'd like my binary format, my executed format, my installer format to be unified.. "executing" should be "swapping in" and perhaps "instantiating"
16:38:02 <Peaker> roconnor: no, that's language-level. OS-level is like EROS-OS
16:38:23 <SamB_XP> how about plan9?
16:38:23 <roconnor> how does EROS-OS enforce things?
16:38:50 <Peaker> roconnor: Similarly to UNIX (file descriptors are caps), without "open" of course
16:39:06 <roconnor> SamB_XP: the bits of the function locations would be more-or-less arbitary.
16:39:10 <Peaker> roconnor: and Orthogonal persistence solves the bootup cap dispersal problem
16:39:42 <Peaker> roconnor: the caps are coarse-grained, because your entities are processes rather than single functions, but its still nicer than Unix
16:39:47 <roconnor> Peaker: what prevents me from trying to use a made up file descriptor and get lucky?
16:40:00 <Peaker> roconnor: same thing as in Unix -- you can only "attack" your own process's fd's
16:40:17 <Peaker> roconnor: An fd is a process-local index into a kernel-controlled array of files
16:40:24 <SamB_XP> roconnor: that sounds like it would play bloody hell with using the executable files to back the RAM pages :-(
16:41:22 <roconnor> SamB_XP: why is that?  The current virtual to physical location translation mechanism should work fine.
16:41:43 <Peaker> roconnor: EROS does resource accounting much much nicer than unix too -- all allocations (except some caches, perhaps) are done by user-processes out of their expenses, and the kernel operations take resources as args, never allocate them in the name of the kernel
16:41:52 <SamB_XP> roconnor: wouldn't that considerably reduce the amount of arbitrariness ?
16:42:05 <Peaker> roconnor, SamB_XP: It would probably mean all executables are -fPIC like .so's
16:42:23 <roconnor> SamB_XP: the translation is done by the CPU.  There is no way to address anything by a physical memory location.
16:42:24 <Peaker> SamB_XP: .so's are already loaded to arbitrary virtual addresses
16:43:13 <SamB_XP> Peaker: well, yes, but the relative branch instructions they usually use don't NEED any relocation for that
16:43:25 <Peaker> SamB_XP: what do you mean?
16:43:34 <roconnor> Peaker:  Interesting.  I'm surprised EROS works.
16:43:36 <SamB_XP> at least on i386
16:43:58 <Peaker> SamB_XP: some stuff need to know not to use absolute addresses, that's why .so's are compiled with -fPIC
16:44:06 <sbahra> Peaker, have you looked at FreeBSD's MAC or Linux's LSM?
16:44:10 <Peaker> roconnor: EROS was a research project, Coyotos is supposed to be a superset of EROS-OS I think
16:44:15 <Peaker> sbahra: nope, what are those?
16:44:35 <sbahra> Peaker, http://www.trustedbsd.org/mac.html
16:44:45 <sbahra> Peaker, LSM is similar.
16:44:46 <roconnor> SamB_XP: relative jumps should still be fine.
16:45:13 <sbahra> Peaker, allows you to implement security policies on top of DAC, framework covers a majority of the kernel.
16:45:19 <SamB_XP> roconnor: well ... wouldn't that mean you'd have rather large chunks of code with known relationships to eachother ?
16:45:28 <Peaker> roconnor: EROS-OS also had nice ideas like:  You can allocate from the "memory bank" (which is a user-level manager of all memory pages) either "pages" or "nodes". "nodes" are physical pages that are only directly accessible by the kernel, that contains caps.  Then, to "spawn" a process, you fill a "node" with caps (using kernel provided APIs), including a "cap" to scheduler run-time, and "bless" it into a process
16:45:50 <Peaker> sbahra: Is it supposed to be an approximation of capabilities?
16:45:54 <mux> is there a trick to know what character some escape sequence represents? ie \226\128\139
16:45:56 <sbahra> Peaker, for example...here is a simple policy: http://repnop.org/projects/mac_suidacl.html
16:46:31 <Peaker> roconnor: The address space and registers of the process would be accessible from this node.  A "debugger" doesn't need special kernel interfaces, it can directly interact with the node/struct that's describing the process
16:46:40 <sbahra> Peaker, if you are referring to the capabilities I know of, then no. However, you can implement capabilities using these sub-systems (in fact, this is how they are implemented for FreeBSD and Linux).
16:46:41 <Peaker> roconnor: mess with the registers/etc
16:46:44 <roconnor> SamB_XP: I guess.  I don't know how large the chunks would be, but any "chuck" that will always have the same privledges can be grouped.
16:46:49 <sbahra> Peaker, they provide the framework for implementing such policies.
16:47:01 <Peaker> sbahra: Linux doesn't have the caps I mean
16:47:01 <roconnor> SamB_XP: I wouldn't be surprised if many chucks are large
16:47:21 <sbahra> Peaker, what standard are you referring to?
16:47:38 <sbahra> For example...
16:47:39 <sbahra> <Peaker> roconnor: EROS does resource accounting much much nicer than unix too -- all allocations (except some caches, perhaps) are done by user-processes out of their expenses, and the kernel operations take resources as args, never allocate them in the name of the kernel
16:47:43 <Peaker> sbahra: ah, that's not what I mean -- I mean real object caps.  Described well in http://www.erights.org/elib/capability/duals/myths.html
16:47:54 <sbahra> This is possible to implement (well, functionally) using MAC.
16:48:02 * sbahra reads
16:48:08 <roconnor> Peaker: sounds like you know a lot about EROS
16:48:17 <Peaker> roconnor: I used to be a fan :)
16:48:34 <sbahra> Peaker, yes, this is possible to implement using MAC.
16:48:44 <Peaker> sbahra: what is MAC exactly?
16:48:55 <Peaker> sbahra: does it get rid of the "open" call?
16:48:59 <sbahra> Peaker, no.
16:49:05 <Peaker> sbahra: then how can it implement it?
16:49:10 <roconnor> Peaker: used?
16:49:11 <sbahra> Peaker, but you can, for example..."intercept" access decisions for open.
16:49:14 <Peaker> sbahra: "open" conflicts with capabilities
16:49:22 <SamB_XP> Peaker: wouldn't you need kernel interfaces of some kind (well, schedular interfaces, anyway) to make sure that the other proces was stopped while trying to debug it?
16:49:24 <sbahra> Peaker, and you can attach labels (which can act as tickets) to various kernel objects.
16:49:29 <Peaker> roconnor: EROS was a pure-research project. Coyotos is supposed to be used. But I'm no longer a fan
16:49:41 <roconnor> Peaker: what changed
16:49:42 <Peaker> SamB_XP: you just remove its scheduler capability from the node
16:49:47 <Peaker> roconnor: The goals, I think
16:49:53 <SamB_XP> Peaker: and how does open conflict with capabilities?
16:50:11 <SamB_XP> Peaker: how does that stop it from running if it was already running when you started messing with it?
16:50:11 <edwardk> > let z k = k []; s :: (([a]->b)->c)->([a]->b)->a->c; s n k x = n $ \v -> k (x:v); p s = s id in p (s (s z)) 1 2
16:50:13 <lambdabot>   [1,2]
16:50:21 <Peaker> roconnor: Shapiro took the research results/ideas from EROS (one of which was that C/C++ sucked, and he needs a new language: BitC) and wrote Coyotos with that, with the goal of making a working system rather than learning more about one
16:50:39 <edwardk> peaker: too bad he got dragged off into MSR and will never finish coyotos
16:50:40 <roconnor> sbahra: what do you mean by MAC?
16:50:42 <SamB_XP> Peaker: well duh C/C++ suck
16:50:45 <Peaker> SamB_XP: I think the semantics of removing the scheduler capability from a process node is that it stops running
16:50:58 <sbahra> roconnor, the TrustedBSD/FreeBSD MAC framework/subsystem.
16:51:07 <SamB_XP> Peaker: that sounds like a lot of fancy talk for a kernel interface to me!
16:51:09 <Peaker> SamB_XP: open conflicts with capabilities because by definition it does "ambient authority" which is what capabilities are supposed to eliminate entirely
16:51:13 <sbahra> roconnor, which stands for "Mandatory Access Control framework" (not a good name)
16:51:26 <roconnor> sbahra: how does that work?
16:51:36 <sbahra> I thought this was #haskell-blah. :(
16:51:42 <sbahra> Maybe we should move this discussion there?
16:51:42 <SamB_XP> Peaker: well, I figure your capabilities are the filesystem as seen by your process ;-)
16:51:47 <Peaker> sbahra: That sounds like it would add a lot of flexibility, but its still not capabilities -- and I think suffers from the same problems ACL's suffer in general
16:51:48 <sbahra> roconnor, it's very simple.
16:51:53 <roconnor> sbahra: okay,
16:51:55 * roconnor moves
16:51:58 <edwardk> sbahra: heh fair enough
16:52:09 * roconnor to haskell-blah
16:52:35 <Peaker> SamB_XP: that's reasonable, but then why is "open" needed? Why aren't all these files already accessible fd's in your space?
16:52:47 <SamB_XP> Peaker: names are more meaningful
16:52:52 <Peaker> SamB_XP: and also -- I suppose this "open" still does ACL checks - which shows its not supposed to be used as caps
16:52:56 <SamB_XP> and let's not forget the trees
16:52:59 <Peaker> SamB_XP: names can be fd's
16:53:20 <Peaker> SamB_XP: I guess  nameToHandle  is reasonable, if it has nothing to do with security
16:53:31 <Peaker> SamB_XP: unfortunately I think Plan9 still suffers from ACL's
16:53:37 <defun> Is the haskell macro system (template haskell) capable of creating special syntaxes, such as do-syntax or the special arrow-notation?
16:54:30 <thoughtpolice> defun: you can use quasiquoting to embed arbitrary syntaxes into your code, sure
16:54:42 <defun> ?quasiquoting?
16:54:42 <lambdabot> Unknown command, try @list
16:54:43 <thoughtpolice> defun: but what you're looking for is a preprocessor, i.e. something that adds a special version of 'do'
16:54:55 <thoughtpolice> defun: there's a package for that
16:55:01 <thoughtpolice> @hackage preprocessor-tools
16:55:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/preprocessor-tools
16:55:08 <defun> I see. Thanks.
16:55:35 <thoughtpolice> defun: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ixdopp <- package that uses preprocessor-tools, to add a special version of 'do' for session types
17:10:21 <thoughtpolice> copumpkin: boo!
17:11:01 <copumpkin> thoughtpolice: !oob
17:11:06 <copumpkin> thoughtpolice: wuzup?
17:11:42 <thoughtpolice> copumpkin: not much. happy to see GHC HEAD now follows new cabal changes, so trying to rebuild ghc for 64bit again
17:11:59 <copumpkin> ooh
17:12:05 <thoughtpolice> copumpkin: I got a stage2 64bit compiler built (unregistered,) but now the unregistered stage2 segfaults, we don't even get to a registered build lol
17:12:16 <copumpkin> lol
17:12:23 <FunctorSalad> what is "quasi" about quasiquoting?
17:13:24 <monochrom> s/registered/registerized/
17:13:34 <monochrom> or registerised
17:13:48 <thoughtpolice> copumpkin: seems to segfault in the GC
17:14:02 <thoughtpolice> copumpkin: which means I'll have to bug JaffaCake a bit when I get the chance :)
17:15:03 <monochrom> Silly joke: "prove or disprove: GHC HEAD is a total function."
17:15:27 <SamB_XP> monochrom: answer: only on DOS
17:15:41 <thoughtpolice> :)
17:15:44 * inimino doesn't get it
17:15:53 <monochrom> is head a total function?
17:16:05 <inimino> oh... I see
17:16:41 <thoughtpolice> head GHC == undefined, for varying definitions of 'undefined', particularly where GHC == on mac, and 64bit :)
17:16:45 <inimino> and combined with the segfaults... right
17:18:55 <FunctorSalad_> hehe http://personal.cis.strath.ac.uk/~conor/pub/she/
17:19:44 <monochrom> hehe "who is she?"
17:20:36 <FunctorSalad_> "If you want to inspect the mess she makes of your lovely program ..."
17:20:59 <copumpkin> I really like she
17:21:05 <copumpkin> played with it some the other day
17:21:16 <copumpkin> I like the direction it's going in, anyway
17:21:54 <Cale> http://imgur.com/Ech6z.jpg -- lol
17:21:56 <FunctorSalad_> yeah, the manual code duplication for type-level mirroring was starting to get silly
17:22:27 <Axman6> thoughtpolice: well keep up the good work :)
17:22:43 <thoughtpolice> FunctorSalad_: wow neat :)
17:22:57 <FunctorSalad_> not mine, thoughtpolice
17:23:06 <thoughtpolice> Axman6: i'm done with class for a while now, so I have plenty of time to work on ghc :)
17:23:11 <thoughtpolice> FunctorSalad_: yeah, but still, neat
17:23:17 <Axman6> whoot :)
17:23:18 <FunctorSalad_> Cale: they actually did that? great
17:23:47 <Axman6> i wish i could help, but i'd need to spend some time working on GHC first to familliarise myself :(
17:23:54 <FunctorSalad_> Cale: let's ask for infinite perimeter next...
17:24:03 <monochrom> supposedly the "special directions" part is for delivery rather than pizza making.
17:27:18 <beutdeuce> how come in ghci i cannot do assignments, it gives me a parse error?
17:28:30 <Axman6> let x = y
17:28:31 <kulakowski> beutdeuce: let x = whatever
17:29:08 <beutdeuce> kulakowski, ah ok. Just curious, why can't i do that unless i do your method or when i load a module and im in that module'
17:29:12 <beutdeuce> s namespace
17:29:41 <Axman6> that's just how ghci works
17:30:12 <beutdeuce> k
17:30:34 <kulakowski> the techinical reason is that you're in the IO monad in ghci (if you dont know what a monad is yet it doesn't really matter)
17:30:41 <FunctorSalad_> "Just put a type in {..}, the braces of upward mobility, and it's a kind!"
17:30:54 <Cale> kulakowski: well... sort of ;)
17:31:10 <Cale> It already does lots more than the inside of a do-block does
17:31:24 <Cale> So, it wouldn't be *too* unreasonable to allow other declarations in-place
17:32:30 <Cale> But I suppose the general idea is that ghci is not really meant as the place where you enter declarations, only as an interactive way of trying them out. Most people keep an editor window alongside ghci, and :r whenever they save changes to the file.
17:33:43 <Cale> Making the ghci prompt the same as the Haskell top-level would generally be pretty tricky, since you can have mutual recursion.
17:33:46 <beutdeuce> 'speaking of blocks, how would i be able to "let" a function with multiple statements? i keep getting parse errors
17:34:02 <Cale> let f [] = 0; f (x:xs) = 1 + f xs
17:34:09 * kpreid notices cap talk
17:35:08 <monochrom> I add {}'s like let {f [] = 0; f (x:xs) = 1 + f xs} just to be redundant.
17:35:11 <beutdeuce> Cale, something like let f x = if x < 0 then -1 else if x > 0 then 1
17:35:36 <byorgey> beutdeuce: ...and what if x == 0 ?
17:35:42 <Cale> beutdeuce: your last 'if' is missing its 'else'
17:35:47 <beutdeuce> byorgey, not the point
17:36:06 <Cale> beutdeuce: if-expressions in Haskell *always* have both 'then' and 'else' parts
17:36:19 <beutdeuce> k, thnx
17:36:24 <beutdeuce> first day
17:36:25 <beutdeuce> lol
17:36:30 <beutdeuce> i did a bit clojure before
17:36:35 <pikhq> Also, you could do that more concisely with guard notation.
17:36:35 <Cale> (otherwise, what value would it be? :)
17:36:43 <pikhq> let f x
17:36:43 <Zao> pikhq: Just in case :P
17:36:45 <Cale> f x | x < 0 = -1
17:36:51 <Cale>     | x > 0 = 1
17:36:52 <pikhq>     | x < 0 = -1
17:36:59 <kpreid> Peaker: open() as in Unix is bad, yes (given the difficulty of chroot), but an open(dirFD, filename) would be just fine and normal
17:37:00 <pikhq>     | x> 0 then 1
17:37:06 <Cale> pikhq: too slow ;)
17:37:07 <pikhq> Erm. What Cale said.
17:37:07 <Cale> hehe
17:37:31 <Cale> I suppose you did start just before me :)
17:38:00 <kpreid> Peaker: (cwd in unix is basically a unique dir cap, and with fchdir() you can have more than one, so you could actually just throw out absolute paths and ../ and win, but that would be unnecessarily complicated over open-relative-to-dircap)
17:38:09 <Cale> beutdeuce: In that case, if none of the guards return True, you get a runtime error and your program dies, so it's prudent to always have an 'otherwise' case:
17:38:12 <Cale>     | otherwise = 0
17:38:26 <beutdeuce> Cale, gotcha
17:38:50 <Cale> If none of the guards match though, and there are more patterns to try, it will fall through and try to match those patterns
17:38:50 <monochrom> let {f x | x<0 = -1 | x>0 = 1 | x<0 = -1}  since we're talking about that.
17:39:21 <beutdeuce> does haskell compile to c?
17:39:26 <monochrom> No.
17:39:31 <Axman6> it can
17:39:45 <Axman6> but it's not as good as the native compiler now i believe
17:39:56 <pikhq> GHC can compile *via* C, but it does a lot of frobbing on the resulting assembly.
17:40:03 <SamB_XP> Axman6: only 3 of the 4 FFI forms can be implementd in ANSI C, actually
17:40:04 <beutdeuce> k
17:40:10 <Cale> beutdeuce: There is -via-C but there's never really a point at which there's valid working C code going on. GHC generates C code which it gets GCC to compile, and then it mutilates the resulting assembly into something that actually works.
17:40:27 <Axman6> SamB_XP: i don't know what that means, but ok :)
17:40:38 <beutdeuce> so its portable"
17:40:38 <Cale> beutdeuce: But that's the old way, now we have a native code generator which is the default.
17:40:42 <pikhq> Cale: I thought the resulting assembly worked, but had nasty stacks and such?
17:41:00 <SamB_XP> Axman6: the one that lets you dynamically convert closures to C function pointers can't be done in ANSI C
17:41:07 <pikhq> So the mutilator removed the stack code, IIRC...
17:41:11 <Axman6> ah, i see
17:41:13 <SamB_XP> you need something like libffi to do that
17:42:00 <beutdeuce> being compiled rather than interpreted (though it can be interpreted), how low-level can Haskell get?
17:42:31 <pikhq> Being able to be compiled does not make something low-level.
17:42:34 <SamB_XP> since you'd need to be able to dynamically generate machine-code stubs that can pass closure data to closure code ...
17:43:02 <Axman6> beutdeuce: you can get fairly low level if you know what you're doing
17:43:07 <beutdeuce> pikhq, makes it more, no? since it depends on the processor architecture rather than a middle man or vm
17:43:33 <beutdeuce> i could be wrong about that though, i dont know haskell much yet
17:43:47 <Cale> beutdeuce: Well, there's an FFI which lets you interact with C code, and it provides lots of low-level operations.
17:43:48 <SamB_XP> beutdeuce: well, if being able to compile something to native machine code does require some lower-level code than compiling to bytecode, yeah ...
17:43:58 <Cale> beutdeuce: For instance, operations on pointers.
17:43:58 <pikhq> beutdeuce: All that being compiled means is that the language's semantics aren't dynamic enough to require an interpreter.
17:44:00 <Axman6> beutdeuce: haskell is a high-level language, but you can do low level stuff
17:44:18 <monochrom> Haskell itself is not very low-level. It can call C bindings of OS API if you want.
17:44:21 <SamB_XP> beutdeuce: but you didn't seem to be asking about how low-level the compiler had to get?
17:44:26 * pikhq notes that Java can be compiled directly to machine code
17:44:46 <Cale> beutdeuce: It's mostly viewed as a sort of external interface kind of thing though. You normally wouldn't write the Haskell side of things that way.
17:44:50 <beutdeuce> pikhq, u mean bytecode?
17:44:59 <Cale> beutdeuce: No, machine code :)
17:45:07 <beutdeuce> assembly?
17:45:11 <Cale> beutdeuce: If you want.
17:45:11 <pikhq> No, gcj can compile it to machine code.
17:45:26 * Axman6 was very surprised when he found out about the picojava processor, which natively runs java bytecode
17:45:28 <pikhq> The JVM itself is a very low-level language.
17:45:37 <beutdeuce> how would u run it though? like a c applicatrion then?
17:45:41 <mux> last time I heard though, gcj managed to produce executables that performed warse than the jvm
17:45:43 <Cale> beutdeuce: yep
17:45:45 <pikhq> Yeah.
17:45:52 <MMcGee> Can someone tell me why I get this error? http://img219.imageshack.us/img219/6082/hssk.jpg
17:45:57 <Axman6> and that all ARM processors are now supposed to have a java bytecode execution too
17:45:58 <beutdeuce> mux, then it should be faster?
17:46:03 <pikhq> mux: It's not an exceptionally *good* compiler. ;)
17:46:08 <copumpkin> Axman6: yeah, but you can't use it :P
17:46:10 <Axman6> beutdeuce: the JVM is very fast
17:46:15 <Cale> MMcGee: Because there are tabs in your file
17:46:19 <Axman6> copumpkin: details! :P
17:46:23 <MMcGee> !
17:46:25 <Cale> MMcGee: It's best to configure your editor not to produce them.
17:46:29 <MMcGee> I didn't have a problem with this before, thanks.
17:46:35 <beutdeuce> Axman6, yes it is, but significantly slower than machine code
17:46:43 <Cale> MMcGee: The compiler will treat them as aligning to 8 spaces.
17:46:47 <copumpkin> beutdeuce: not really
17:46:53 <Axman6> beutdeuce: not really, the hotspot JVM compiles to machine code anyway
17:46:54 <beutdeuce> copumpkin, how so?
17:46:57 <MMcGee> Ok, thank you.
17:47:00 <copumpkin> Axman6: well, you can if you want to pay big money to ARM, but there's no public spec on how it all works, and the only thing we know is that there's a bxj instruction that jumps into java code
17:47:02 <Axman6> the JVM is _fast_
17:47:12 <Cale> MMcGee: So, if you *do* use hard tabs, then your editor should be set to treat them as 8 spaces. That's really ugly though, so nobody does that.
17:47:15 <beutdeuce> i know its fast, but "slower"
17:47:17 <pikhq> beutdeuce: Most of the result of Java being slow is something I will call "Java-itis".
17:47:18 <copumpkin> beutdeuce: it actually runs the bytecode instructions in hardware
17:47:22 <beutdeuce> or "less fast"
17:47:34 <Axman6> beutdeuce: check out the language shootout. java is up there with C and C++
17:47:41 <pikhq> It's a disease whereby Java programmers write shitty code with more objects than lines of functional code.
17:47:42 <beutdeuce> copumpkin, more like virtual hardware?
17:47:50 <pikhq> *That* is what makes Java slow.
17:47:53 <mux> beutdeuce: it's not because theoritically you could produce an executable that would be faster than running with the JVM that's it's either easy or even feasible in practice
17:48:13 <dibblego> > fmap head $ foldM (\k b -> return $ b : k) [] [1,2,3,undefined] -- is there a lazy foldM?
17:48:14 <lambdabot>   No instance for (GHC.Show.Show (m a))
17:48:14 <lambdabot>    arising from a use of `M8277869876...
17:48:29 <copumpkin> beutdeuce: well, they don't specify how it is to be implemented but I've heard it's directly comparable to native performance. The only issue is that there are some callbacks for security things and similar that the CPU makes back into your code (and no one knows how to use them without paying big bucks)
17:48:34 <beutdeuce> on a "worse" machine, running code through jvm will be slower imo
17:48:56 <Axman6> beutdeuce: it might be slower, but not much slower
17:49:10 <Axman6> of course, it all depends on the code
17:49:15 <pikhq> Java is fast. Java programs are generally slow.
17:49:21 <mux> beutdeuce: you are over-estimating gcj :-)
17:49:24 <pikhq> (because Java programmers aren't all that good)
17:49:24 <Cale> dibblego: you're explicitly picking out the undefined at the beginning of the list...
17:49:30 <mux> the JVM has much improved these last years
17:49:31 <beutdeuce> pikhq, wouldnt u define a language through its programs?
17:49:36 <Cale> dibblego: Try fmap (!! 1) $ ...
17:49:37 <pikhq> beutdeuce: No.
17:49:39 <dibblego> Cale, what undefined at the beginning?
17:49:45 <Cale> dibblego: foldM is a foldl
17:49:46 * Axman6 somewhat resents that statement, but he identifies himself as a haskell programmer
17:49:46 <dibblego> Cale, oh I see
17:49:52 <dibblego> Cale, right thanks
17:49:58 <pikhq> You can make Java code that's actually somewhat speedy.
17:50:10 <beutdeuce> how is it that java is fast but java programs are slow?
17:50:15 <pikhq> Most Java programmers seem to think that more objects makes code better.
17:50:20 <Axman6> beutdeuce: because they
17:50:25 <Axman6> they're written in a slow way
17:50:54 <pikhq> A program that is really slow will be slow no matter what language it's written in.
17:51:02 * mux just wrote a haskell script that fetches an RSS feed via HTTP, matches items with a set of regexps, automatically downloads the torrent associated with the item if it matches, and adds it to the deluge bittorrent client's queue
17:51:27 <mux> for a total of 58 lines - I think this was as easy as if I had used perl and LWP::UserAgent
17:51:36 <conal> mux: wowzers!
17:51:39 <beutdeuce> does/can haskell get access to the c standard library?
17:51:43 <pikhq> mux: Nice.
17:51:58 <pikhq> beutdeuce: Sure it can. That's what a foreign function interface is *for*.
17:52:09 <beutdeuce> pikhq, didnt get up to that yet :P
17:52:11 <mux> at the risk of looking like an otaku, I can put this online if you are interested
17:52:26 <beutdeuce> how would i open a tcp connection with haskell?
17:52:31 <pikhq> For just the standard library, it's probably not what you *should* do, though. ;)
17:52:34 <mux> very script-like though; lots of error calls and the like
17:52:34 <beutdeuce> lets say, to fetch a page
17:52:52 <thoughtpolice> beutdeuce: use a package to do it like the curl bindings or something
17:52:58 <thoughtpolice> beutdeuce: otherwise just use the 'network' package
17:53:08 <pikhq> mux: Just a sec while I look that up. I'm a bit nooby. ;)
17:53:15 <pikhq> Erm. beutdeuce.
17:53:17 <beutdeuce> thoughtpolice, are packages modules?
17:53:30 <mux> beutdeuce: see Network.HTTP (network package)
17:53:55 <monochrom> OOP education teaches people to speculate "what if this modification is needed next month? what if that modification is needed next month?..." and therefore build-in too much generality than one ever needs.
17:54:25 <thoughtpolice> beutdeuce: not sure how to parse that statement
17:54:34 <beutdeuce> thoughtpolice, "module"
17:54:34 <monochrom> In reality, next month you will need a modification you would never speculate.
17:54:42 <thoughtpolice> beutdeuce: packages (like curl) are composed of modules like Network.HTTP, etc. etc.
17:54:42 <pikhq> beutdeuce: http://hackage.haskell.org/packages/archive/network/2.2.1.3/doc/html/Network.html
17:54:55 <beutdeuce> ah k, thnx
17:54:56 <thoughtpolice> beutdeuce: if you're looking for HTTP stuff, you really want the HTTP package
17:54:56 * mux notes python guys are dropping the axe on 3.0 - the native IO library probably was too much for python to handle :-)
17:54:59 <thoughtpolice> @hackage HTTP
17:54:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
17:55:05 <beutdeuce> hackage is haskell's package manager?
17:55:17 <monochrom> No. Library repository.
17:55:20 <thoughtpolice> beutdeuce: it's a repository of haskell packages
17:55:35 <beutdeuce> thoughtpolice, k
17:57:25 <beutdeuce> how would i check for type? like tell a function to do osmehting specific or not depending on the type of the argument?
17:57:45 <mux> straight into the hardcore stuff ;-)
17:58:26 <mux> it actually depends on wether your set of types is closed and known at compile time or if it's meant to stay open
17:58:39 <beutdeuce> meant to stay open
17:58:48 <mux> the typeclass is probably what you want then
17:59:13 <monochrom> Use typeclass. It's our story for overloading.
17:59:43 <mmorrow> conal: re: show for GADTs: http://moonpatio.com/cgi-bin/gadtshow.cgi
17:59:49 <mux> I was scared at first because I though you wanted to have type-directed types
18:00:21 <beutdeuce> mux, lol
18:00:40 <mux> not that this is hard, but it's a recent GHC extension
18:00:56 * conal tries gadtshow ...
18:01:08 <mmorrow> conal: (it uses the old-old haskell-src-exts ast though but here's the code: http://moonpatio.com/repos/MISC/GadtDerive.hs
18:01:14 <beutdeuce> speaking of ghc, what the difference between ghc and hugs?
18:01:19 <hackagebot> hspresent 0.2 - A terminal presentation tool (EvanKlitzke)
18:01:22 <beutdeuce> which would/should i use
18:01:52 <mux> well, ghc is maintained
18:02:02 <conal> mmorrow: neat.  thx.
18:02:05 <mux> and hugs has a cool name :-)
18:02:07 <mmorrow> conal: :)
18:02:07 <conal> mmorrow: any thoughts on Read?
18:02:19 <pikhq> Hugs is a simple, easy to use interpreter.
18:02:28 <pikhq> GHC is an insanely good compiler and interpreter.
18:02:37 <beutdeuce> pikhq, not helping ;)
18:02:46 <mmorrow> conal: i think you'd have to Read to some sort of existential container. Saizan had this idea for parsing to a GADT
18:02:46 <mux> you should probably go for ghc
18:03:00 <pikhq> beutdeuce: Most people use GHC.
18:03:01 <beutdeuce> how is it insanely good?
18:03:02 <monochrom> ghc is powerful and practical (apart from exe file size, but can't be helped)
18:03:06 <beutdeuce> k
18:03:07 <conal> mmorrow: yeah.  existential is what i'm thinking also.
18:03:08 <mmorrow> conal: err, but then it wouldn't be "Read" i guess..
18:03:13 <mux> monochrom: this is about to change btw! :-)
18:03:20 <mmorrow> conal: that would neat to sort out for sure
18:03:28 <pikhq> mux: ?
18:03:28 <monochrom> Woah?! This world is too good to be true!
18:03:41 <mux> pikhq: GHC is gaining shared library support
18:03:47 <beutdeuce> there is fst and snd, is there a function to extract the nth term?
18:03:48 <pikhq> Ah.
18:03:52 <monochrom> Oh, in that way.
18:04:05 <monochrom> This world is still too good to be true.
18:04:18 <conal> mmorrow: i want to read & show interactive 3D effects that run on graphics hardware.  i have a GADT for the degrees of freedom.
18:04:54 <pikhq> :t fst
18:04:56 <lambdabot> forall a b. (a, b) -> a
18:05:22 <pikhq> beutdeuce: No. For that matter, fst and snd only work on tuples of size 2.
18:05:24 <conal> mmorrow: i guess i'll have a type something like 'data Foo = forall a. Foo (UI a) (Effect a)', where UI and maybe Effect are GADTs
18:05:36 <conal> mmorrow: plus some constraints on 'a'.
18:05:38 <beutdeuce> pikhq, k
18:05:52 <thoughtpolice> mux: for x86/x86_64 linux, anyway
18:05:57 <mux> yup
18:06:00 <pikhq> I strongly recommend considering if a tuple is what you want.
18:06:00 <dibblego> has anyone written ifM :: m Bool -> m a -> m a -> m a yet?
18:06:08 <conal> Saizan: ping.  GADT parsing?
18:06:18 <mux> thoughtpolice: I may take some time to look into the code and see if I can add FreeBSD support
18:06:45 <mux> dibblego: probably everyone in this channel implemented it a few times already ;-)
18:06:50 <mmorrow> conal: hmm cool, that seems like it'd work
18:07:42 <mux> dibblego: except that it shouldn't be called ifM
18:07:51 <coCocoa>  mif? ;p
18:08:08 <conal> mmorrow: the GPU compiler part is working, and i'm hacking on the UI generation now.
18:08:34 <thoughtpolice> mux: yeah, I would like to do the same for x86_64/os x
18:08:46 <thoughtpolice> mux: which will require me getting x86_64/os x to work :)
18:09:04 <mux> thoughtpolice: it wouldn't be fun without a bit of challenge, would it? :)
18:09:29 <mmorrow> conal: ooh sweet! so it compiles from some sort of edsl to ? (C?)
18:10:06 <conal> mmorrow: generates opengl shader language (glsl)
18:10:10 <conal> and runs insanely fast
18:10:32 <mmorrow> interesting, i'll have to read about that
18:10:35 <conal> i want to have one or more run-times that don't depend at all on the haskell RTS.  just has to read & interpret the shown UI and shaders, makes a few opengl calls and runs.
18:11:10 <conal> i'd really like one rts to be in flash.  i read that flash 10 has opengl hooks.
18:11:48 <mmorrow> nice. so how is glgl represented?
18:11:53 <mmorrow> *glsl
18:12:02 * coCocoa eavesdrops on conal's ambitions...then goes to get a hand towel to sop up the drooling...
18:12:09 <conal> :)
18:12:51 <conal> mmorrow: i'm pretty-printing a typed lambda calculus GADT right into the glsl code, which is a C variant.
18:13:25 <conal> mmorrow: the string form of glsl code gets passed to opengl for compilation & linking & execution.
18:14:00 <jmcarthur> ooh conal is finally surfacing some detail?
18:14:34 <mmorrow> nice, /me is browsing over http://www.opengl.org/registry/doc/GLSLangSpec.Full.1.20.8.pdf now
18:14:48 <conal> mmorrow: that's the doc i use.
18:15:00 <mmorrow> conal: that seems really convenient in that you can be self-contained
18:15:02 <conal> mmorrow: there are also 1.3 and 1.4, with a few improvements.
18:15:33 <conal> mmorrow: yeah.  fast & lightweight.  as with pan, vertigo, & pajama
18:15:53 <mmorrow> conal: very cool, looking forward to checking it out :)
18:16:14 <beutdeuce> whats "in" ?
18:16:24 <conal> mmorrow: i'm looking forward to showing it off.  i love purely functional graphics.
18:16:25 <dibblego> a keyword that is used alongside 'let'
18:16:26 <jmcarthur> conal: so my understanding is that the goal is to write shaders in a edsl?
18:17:00 <jmcarthur> sounds really sexy
18:17:14 <jmcarthur> i knew you were doing something with the gpu, but i wasn't sure exactly what
18:17:25 <conal> jmcarthur: yes.  a semantically transparent edsl.
18:17:28 <rocketman> beutdeuce: you have to use in to finish let bindings,   let <binding> ... in ...
18:17:31 <jmcarthur> excellent
18:17:39 <beutdeuce> rocketman, k
18:17:43 <conal> i.e., one with a simple, precise denotational semantics.
18:17:43 <jmcarthur> i saw this as a gaping hole in the opengl bindings
18:17:48 <monochrom> > let { x=1 } in x*x
18:17:49 <lambdabot>   1
18:17:53 <rocketman> beutdeuce: you can find this sort of thing in haskell tutorial
18:17:58 <rocketman> beutdeuce: Or the report
18:18:13 <jmcarthur> of course, the opengl bindings themselves don't have such nice semantics anyway
18:18:22 <jmcarthur> since they are just direct reflections of the C api
18:18:30 <conal> opengl scares me.  so does cuda.  some much complexity!
18:19:08 <conal> and graphics is such a natural for the purely functional/denotational approach, since graphics is mostly made of functions.
18:19:09 <jmcarthur> the relationship between opengl and glsl confuses me, recently. is opengl defined solely in terms of glsl now or something?
18:19:32 <conal> jmcarthur: sigh.  no.  there's a huge amount of opengl cruft remaining.
18:19:37 <jmcarthur> :(
18:19:58 <jmcarthur> i think the transition is inevitable, really
18:20:05 <jmcarthur> wish they would just go ahead and do it
18:20:26 <Woof> @seen Cale
18:20:26 <lambdabot> Cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard Cale speak 30m 41s ago.
18:20:29 <conal> me too.  i haven't learned cuda or opencl yet.  maybe they dispense with opengl.
18:20:50 <conal> jmcarthur: opengl is terribly complex & error-prone.  a huge opportunity for functional (not IO) programming.
18:21:28 <Cale> Woof: hello
18:21:37 <jmcarthur> conal: i agree 100%
18:21:40 <Woof> Ah yes, Cale
18:21:40 <conal> jmcarthur: and ironically, opengl is massively sequential/stateful, while purity/parallelism pays off immensely in graphics.
18:21:48 <Woof> The BF interpreter for lambdabot is broken, Cale : (
18:21:52 <Cale> I know.
18:21:56 <olsner> opengl is something like a huge arbitrary state modifying thingy that builds functional programs for rendering stuff
18:22:03 <jmcarthur> opengl is nothing more than a state machine
18:22:04 <Woof> Do you plan on keeping that way for long? Lol
18:22:12 <Cale> Woof: I didn't write it in the first place.
18:22:19 <jmcarthur> olsner: oh that's an interesting way of looking at it
18:22:24 <Woof> Hm, it was broken from the start? Okay : /
18:22:24 <Cale> Woof: If someone wants to fix it, I will take patches.
18:22:32 <Woof> Okay : )
18:22:37 <jmcarthur> olsner: rather like our IO monad which is a functional thingy that builds imperative programs?
18:22:41 <Woof> I'll take a look at it when I've learned more Haskell : D
18:24:00 <olsner> hmm, I guess it is kind of like that
18:24:01 <jmcarthur> conal: is your GPU library orthogonal to FRP?
18:24:30 <jmcarthur> or is it dependent on it?
18:24:33 <conal> mmorrow: about gadtshow: the generated Show constraints on the type arguments got in my way.  iiuc, they work for your F example because of One.
18:24:44 <conal> jmcarthur: orthogonal.
18:24:47 <jmcarthur> sweet!
18:24:57 <conal> i like orthogonal!
18:24:59 <jmcarthur> i very very much look forward to seeing some of it
18:26:46 <conal> mmorrow: i deleted the Show constraint in my UI type, and the code type-checks & runs correctly. :)
18:28:35 <conal> is there a general way to tell cabal about code generators, like hsc2hs?
18:29:29 <jmillikin> Cabal seems to detect that c2hs should be used for .chs files, but I don't know if that extends to hsc2hs
18:30:10 <dcoutts> conal: yes, by declaring hookedPreProcessors in the Setup.hs, though as jmillikin says, Cabal already has builtin support for hsc2hs (and c2hs)
18:30:27 <conal> dcoutts: cool.  thx.
18:40:08 <Twey> @hoogle Int -> [a] -> [[a]]
18:40:09 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
18:40:09 <lambdabot> Prelude drop :: Int -> [a] -> [a]
18:40:09 <lambdabot> Prelude take :: Int -> [a] -> [a]
18:40:15 <Twey> @more
18:40:33 <Twey> Bah :(
18:42:19 <Twey> Is there no function that takes a list and chunks it into sublists of a specified size?  I'm sure I remember there being such a thing
18:42:37 <dibblego> @type Data.List.Split.split
18:42:38 <lambdabot> Couldn't find qualified module.
18:42:44 <dibblego> blah
18:43:02 <Twey> :t split
18:43:03 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
18:43:07 <Twey> Er
18:43:12 <Twey> Not that one, huh :-P
18:43:39 <dibblego> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html#v%3AsplitEvery
18:43:43 <beutdeuce> what does it mean when it says no exhaustive patterns
18:44:09 <Tsion> beutdeuce: None of the function's patterns matched the input
18:44:10 <dibblego> beutdeuce, it means you have pattern-matched but missed out a possibility in the match
18:45:14 <beutdeuce> whats wrong with, "let len (a:b) = 1 + len b" ?
18:45:39 <dibblego> you're missing len []
18:45:58 <beutdeuce> same error
18:46:23 <shachaf> beutdeuce: Well, it won't work with let; you need to use a semicolon to put both definitions on one line.
18:46:39 <dibblego> > let len (a:b) = 1 + len b; len [] = 0 in len [1,2,3]
18:46:40 <lambdabot>   3
18:46:46 <shachaf> > let len [] = 15; len (a:b) = 1 + len b in len [8]
18:46:47 <lambdabot>   16
18:46:47 <beutdeuce> oh
18:46:52 <beutdeuce> thx
18:49:18 <beutdeuce> what/when are semi colons used in Haskell?
18:49:44 <Vanadium> When you cannot be botherd to start a new line and indent it, mostly
18:50:36 <beutdeuce> k
18:51:40 <roconnor> some people like to use ; for formatting anyways
18:51:43 <roconnor> do { foo
18:51:45 <roconnor>     ; bar
18:51:48 <roconnor>     ; baz }
18:51:54 <roconnor> except lined up properly
18:52:06 <beutdeuce> thnx
18:52:30 <roconnor> also when doing 1 line demonstrations with lambdabot
18:52:37 <SamB> or using records!
18:52:43 <SamB> don't forget records
18:52:46 <roconnor> > let x = y; y =1 in x
18:52:47 <lambdabot>   1
18:53:00 <roconnor> records?
18:53:11 * roconnor has forgotten about records
18:53:12 <SamB> roconnor: don't those use ;?
18:53:23 <SamB> I could be mistaken
18:53:27 <roconnor> maybe, in record updates?
18:53:33 <roconnor> record declairations use ,
18:53:33 <beutdeuce> records?
18:53:37 <SamB> oh
18:53:40 <SamB> whoops
18:53:43 <SamB> nevermind then
18:53:44 <roconnor> I think
18:54:02 <SamB> probably because I've been doing more C lately or something ...
18:54:18 <beutdeuce> a list cannot be composed of mixed data types?
18:54:33 <SamB> beutdeuce: not without creating a mixed data type
18:54:40 <roconnor> beutdeuce: but they can be composed of Either a b
18:54:40 <coCocoa> SamB: I could recommend a substance abuse clinic that could help you... ;p
18:54:53 <SamB> coCocoa: it's not a substance, though
18:54:55 <beutdeuce> i know either, SamB, what do u mean?
18:55:21 <dibblego> beutdeuce, Either is a data type like []
18:55:22 <roconnor> beutdeuce: you can make your own sophisticated data type if either doesn't suit your needs
18:55:24 <SamB> beutdeuce: you could create data Duck = Foo Int | Bar Double | Baz String
18:55:51 <beutdeuce> hgow?
18:55:52 <beutdeuce> how?
18:56:01 <jmcarthur> data Duck = Foo Int | Bar Double | Baz String
18:56:42 <beutdeuce> i get parse error
18:57:25 <roconnor> you need to write it in a module/file and load it in GHCi to make new datatypes
18:57:27 <jmcarthur> you must be using ghci
18:58:25 <beutdeuce> jmcarthur, i am
18:59:36 <beutdeuce> thnx for the help guys, i g2g now
18:59:42 <Cale> beutdeuce: I thought it was strange when I first heard about it, but in fact, when you put items in a list, usually you want to operate on them uniformly, which means that they pretty much have to have the same type anyway.
19:06:23 <mmorrow> conal: ah yeah, often times you need to tweak the code that gadtshow spits out
19:06:57 <mmorrow> conal: it just uses the same pre-packaged strategy regardless of any particulars
19:12:09 <mmorrow> (also the code in there that uses TH to build the Show instance code is a mess, since that was before i knew how to "clean" TH code so that it prettyprints to valid syntax, so i went the long way there)
19:12:23 <mmorrow> (a single call to `cleanNames' does the trick)
19:13:06 <mmorrow> , cleanNames <$> [|(Just 42, fmap . id)|]
19:13:08 <lunabot>  TupE [AppE (ConE Just) (LitE (IntegerL 42)),InfixE (Just (VarE fmap)) (Va...
19:13:10 <mmorrow> , [|(Just 42, fmap . id)|]
19:13:12 <lunabot>  TupE [AppE (ConE Just) (LitE (IntegerL 42)),InfixE (Just (VarE fmap)) (Va...
19:13:27 <mmorrow> err, the Show instance in lunabot is applying cleanNames regardless..
19:17:22 <kulakowski> the techinical reason is that you're in the IO monad in ghci (if you dont know what a monad is yet it doesn't really matter)
19:17:29 <kulakowski> oops
19:18:56 <SamB_XP> kulakowski: scrolled up, were you ?
19:18:58 <jmcarthur> the IO monad plus implicit print around pure expressions plus the :commands
19:19:21 * SamB_XP does that a lot too
19:19:30 <jmcarthur> yeah i hate that
19:20:07 <kulakowski> jmcarthur: yes i know
19:20:10 <kulakowski> SamB_XP: yes
19:21:42 <jmcarthur> conal: have you heard of nip2? my wife found it yesterday and i thought it might be something of interest to you
19:22:02 <jmcarthur> lazy functional graphic manipulation
19:22:09 <jmcarthur> with its own pure lazy functional language
19:22:21 <jmcarthur> the interface kind of stinks though, unfortunately
19:22:36 <jmcarthur> ... watch it be your creation, now that i've said that
19:22:52 <jmcarthur> i don't think it's your style though
19:22:58 * jmcarthur is probably safe
19:23:10 <mjs22> wow - that is a strange looking interface.
19:23:45 <roconnor> jmcarthur: what does your wife do?
19:23:56 <jmcarthur> freelance web/graphic design
19:24:20 <jmcarthur> she uses only open source software, and she is getting fed up with the options and is thinking about learning to program just to get into graphics programming
19:24:28 <roconnor> wow, this looks like a audio track editor for images
19:24:30 <jmcarthur> she was looking into more of what's out there
19:25:28 <jmcarthur> yeah i thought it looked neat. kind of a primitive version of what i would want my own hypothetical editor to work
19:25:34 <jmcarthur> *of how
19:26:04 <roconnor> ... but nip2 does now have lambdas  ...
19:35:22 * jmcarthur submits the obligatory link to proggit
19:37:42 --- mode: shapr set -o shapr
19:46:11 * mmorrow loves codes that writes machine code directly to memory at runtime :)
19:50:18 <erlanguid> if I was interested in learning more about some of the applied mathematics behind haskell (category theory, etc) where would I go?
19:50:56 <kulakowski> it's just a little bit weird seeing category theory called applied math
19:51:55 <SamB_XP> lol
19:52:00 <kulakowski> how much of a mathematical background do you have erlanguid?
19:52:21 <erlanguid> kulakowski basic college math
19:52:25 <erlanguid> cal 3
19:52:30 <erlanguid> :(
19:52:41 <rocketman> What does that mean?  "The mathematics behind haskell"?
19:52:41 <SamB_XP> you had 3 semesters of courses on how to read the calendar?
19:53:05 <erlanguid> yes, you'd be surprised how important february is to my family
19:53:07 <kulakowski> any linear algebra or abstract algebra? like, do you know what a 'vector space' or a 'group' is?
19:53:14 <erlanguid> no
19:53:19 <rocketman> Do you just wonder interesting topics which are related to functional programming?
19:53:41 <erlanguid> rocketman, more interested in how I can use it to improve my applications I guess
19:53:46 <SamB_XP> erlanguid: what major ?
19:53:50 <erlanguid> cs
19:54:11 <rocketman> ah I can recommend only one thing: Reading Algebra of Programming
19:55:30 <erlanguid> rocketman: this looks perfect
19:55:42 <erlanguid> whats the required math background
19:55:46 <rocketman> None
19:56:35 <erlanguid> lately I've been feeling like I'm faking being a dev without a solid math background
19:57:14 <rocketman> I think it's very wise to question that and work on improving it
19:57:23 <erlanguid> obviously it doesn't make much of a difference when writing web apps in ruby, but as I'm studying haskell it feels important somehow
19:57:37 <erlanguid> thanks for the info
19:58:33 <jrick> Cale: hey, I was just wondering if you could have lambdabot join #colemak
19:58:41 <jmcarthur> i think even writing web apps in ruby can benefit from applying some math to it, although it is certainly more difficult to do with ruby than with haskell
19:59:02 <wmealing_> http://www.amazon.com/Algebra-Programming-Prentice-Hall-International-Computer/dp/013507245X <-- that book ?
19:59:15 <rocketman> yes
20:00:05 * wmealing_ balks at amazons price
20:00:46 <jmcarthur> crazy
20:01:29 <jmcarthur> lol "List Price: $48.00" "New: from $359.31"
20:02:01 <gwern> that's just the bots trying to maximize profits
20:03:35 <mjs22> yep.  it's pretty annoying when the prices shoot that high for out of print books.  I was trying to track down the pH book recently and saw it listed at around $150.
20:32:51 <SamB> lol @ http://contikistrip.kjempekjekt.com/index.php?p=8
20:37:22 <roconnor> @free filter
20:37:23 <lambdabot> $map f . filter (g . f) = filter g . $map f
20:37:49 <roconnor> wow
20:38:04 <roconnor> this is really close to Bird's first filter law in the sudoku paper
20:38:30 <roconnor> bird says  when f . f = id => filter (p . f) = map f . filter p . map f
20:39:57 <roconnor> when f . f = id, then map f . map f = id. So take $map f . filter (g . f) = filter g . $map f and compose with  map f on the left on both sides of the equation
20:40:16 <roconnor> which gives map f . map f . filter (g . f) = map f . filter g . map f
20:40:32 <roconnor> as we said, map f . map f = id
20:40:34 <roconnor> so
20:40:46 <roconnor> we get filter (g . f) = map f . filter g . map f
20:40:57 <roconnor> which is Bird's first filter theorem
20:42:09 <conal> jmcarthur: i don't know if i've seen nip2 before.  it does look something like what i'm into.  thx for the pointer.
20:42:42 <jmcarthur> conal: no prob
20:54:14 <Twey> @pl \x -> f (g x) (h x)
20:54:14 <lambdabot> liftM2 f g h
20:58:12 <portnov> @pl \f g x -> f x (g x)
20:58:12 <lambdabot> ap
20:58:46 <portnov> :t ap
20:58:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:00:03 <jmcarthur> :t (<*>)
21:00:04 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:16:17 <contrapumpkin> yay for iPhone irc clients
21:17:03 <wmealing_> the book mentioned earlier, is it/would it be valid for someone learning haskell, or is it more for the intermediately skilled programmer ?
21:17:15 <wmealing_> (how does one ever know where ones skill level lies though)
21:17:32 <bos> contrapumpkin: which one?
21:17:32 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
21:17:51 <wmealing_> http://www.amazon.com/Algebra-Programming-Prentice-Hall-International-Computer/dp/013507245X <-- for those who have left/join in the mean time
21:17:55 <contrapumpkin> bos: flowchat, just got released :)
21:18:03 <bos> contrapumpkin: free, perchance?
21:18:27 <contrapumpkin> bos: unfortunately not, 5 bucks
21:18:44 <contrapumpkin> but it's a full irc client
21:18:47 <bos> contrapumpkin: bummer. i aint payin no greenbacks for an irc client.
21:18:55 <contrapumpkin> lol
21:19:47 <contrapumpkin> supports multiple servers etc... I just wish I could leave it on in the background, but that's not their fault I guess :(
21:20:15 <wmealing_> its their fault for not writing it for android :P
21:20:20 <copumpkin> whoops
21:20:23 <copumpkin> it just crashed :P
21:21:32 <wmealing_> copumpkin, can't find a page for it, know a url with screenshots/features ?
21:21:52 <copumpkin> http://flowchat.me/
21:46:18 <Twey> Is Data.List.Split (of the split package) going to be available on the Platform?
21:47:48 <dm`> Prelude> :m Data.List.Split
21:47:48 <dm`> Could not find module `Data.List.Split':
21:47:48 <dm`>   Use -v to see a list of the files searched for.
21:47:48 <dm`>  
21:48:06 <dm`> [I have haskell-platform-2009.2.0 installed]
21:49:15 <Twey> Hm
21:49:16 <Twey> :(
21:49:19 <Twey> It should be there
21:49:28 <Twey> It's too useful not to make generally available
21:49:34 <Twey> I'd have it in H', even...
21:49:40 <bos> Twey: not being in the initial release doesn't mean anything
21:49:47 <Twey> True
21:49:53 <Twey> Can I vote for it somewhere?
21:49:55 <bos> Twey: which functions in it do you use? i find it faintly absurdly complicated
21:50:11 <Twey> Really?
21:50:21 <Twey> Mostly splitOn and splitWhen
21:50:49 <Twey> splitEvery is fairly often useful, too
21:51:07 <Twey> The combinators do seem a little overwrought for the purpose
21:51:48 <brian6> i'm not getting exactly what's going on in instance Functor (Either a). i know it needs to be (Either a) to fix the kind, but why does it have to be Left's type parameter?
21:52:11 <bos> Twey: i had a reason for asking, by the way: i want to build the most useful of those functions into Data.Text
21:52:24 <bos> brian6: just because, pretty much.
21:52:39 <copumpkin> brian6: because you don't get to flip type constructors
21:53:01 <SamB_XP> brian6: because that's the one that could be applied to leave it (* -> *)
21:53:11 <mmorrow> bos: i like (split :: (a -> Bool) -> [a] -> [[a]]) where the (a -> Bool) is what `break' would expect
21:53:35 <brian6> copumpkin: i mean, if i redefine Either a b = Right a | Left b and try to make instance Functor (Either a), the kind will be ok, but it won't work.
21:53:38 <copumpkin> brian6: it's pretty arbitrary...
21:53:40 <Twey> mmorrow: That's Data.List.Split.splitWhen
21:53:40 <bos> i have split :: Text -> Text -> [Text]
21:53:52 <copumpkin> brian6: you can wrap it in a newtype
21:53:55 <bos> and splitWith :: (Char -> Bool) -> Text -> [Text]
21:54:00 <mmorrow> nice
21:54:04 <bos> and splitChar :: Char -> Text -> [Text]
21:54:11 <mmorrow> very nice
21:54:24 <SamB_XP> brian6: how won't it work ?
21:54:32 <bos> i don't have chunksOf :: Int -> Text -> [Text] yet
21:54:35 <aavogt> there's groupBy . const
21:54:40 <mmorrow> ooh, that's another really handy one
21:54:43 <aavogt> but that's sort of unclear
21:54:44 <mmorrow> (chunk)
21:54:46 <brian6> SamB_XP: i'll make a little example.
21:54:51 <Twey> bos: Don't forget splitOn :: String -> Text -> [Text]
21:54:56 <aavogt> @type groupBy . const
21:54:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
21:55:08 <mmorrow> i end up defining "chunk" in probably 80% of modules i write (annoyingly)
21:55:15 <Twey> Yeah
21:55:23 <Twey> It's surprisingly useful
21:55:23 <bos> Twey: that's split :: Text -> Text -> [Text]
21:55:24 <copumpkin> it'd be nice to be able to do this generically
21:55:33 <copumpkin> we need a suitable typeclass
21:55:36 <Twey> bos: What's the difference between Text and String?
21:55:46 <copumpkin> it's his superfast unicode text isn't it?
21:55:50 <mmorrow> Twey: Text is like a ByteString
21:55:53 <bos> Twey: Text == Fast and Compact, String == Slow and Chompy
21:55:58 <Twey> Oh, right :-P
21:56:02 * copumpkin chomps
21:56:13 <bos> copumpkin: i don't think a typeclass is enough, you need either fundeps or ATs.
21:56:20 <Twey> So you aim to replace String entirely?
21:56:25 <SamB_XP> bos: wouldn't Text use even bigger chomps?
21:56:33 <brian6> SamB_XP: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6564
21:56:38 <mmorrow> variable-sized chomps too!
21:56:56 <mmorrow> hmm
21:56:57 <brian6> it has something to do with not changing Lefts.
21:56:58 <bos> Twey: not necessarily. i aim not not care about whether String exists any longer, by being able to say "just use Text instead, it's faster and better and goes up to 11"
21:57:05 <mmorrow> doit uses utf16 actually, right?
21:57:12 <mmorrow> err
21:57:19 <mmorrow> s/do/hmm, /
21:57:20 <Twey> bos: So that's a yes, then :-P
21:57:25 <SamB_XP> brian6: well, yeah, you'd have to swap the Left and Right in the instance to get that to work
21:57:30 <Twey> Feature-wise.
21:57:30 <mmorrow> is utf16 variable-sized?
21:57:33 <bos> Twey: sort of.
21:57:35 <bos> mmorrow: it is.
21:57:35 <Twey> mmorrow: Yes
21:57:38 <brian6> SamB_XP: tjat
21:57:39 <mmorrow> goo
21:57:44 <brian6> SamB_XP: that's what i'm getting at.
21:57:49 <SamB_XP> brian6: which makes sense, since you swapped which one holds values of which type
21:58:06 <bos> mmorrow: but you can't tell from looking at a Text what the internal representation is
21:58:06 <brian6> SamB_XP: what does the (Either a) really mean in instance Functor (Either a)?
21:58:26 <mmorrow> bos: oh, a Text might have other encodings?
21:58:28 <SamB_XP> brian6: it means that the first argument of Either is held constant across an fmap
21:58:37 <brian6> SamB_XP: yeah, ok.
21:58:47 <bos> mmorrow: it *could*, but it doesn't. it's UTF-16, host endian.
21:58:55 <mmorrow> ah, i see
21:58:56 <SamB_XP> which means the fmap has to apply the function to the *second* argument type
21:59:08 <copumpkin> bos: true, but it still seems silly to duplicate this work for list-based strings, bytestrings, and now text... they share so much functionality, differing mainly in their underlying representation :/
21:59:16 <copumpkin> seems like an ideal place for associated type
21:59:17 <copumpkin> s
21:59:24 <copumpkin> :(
21:59:42 <mmorrow> copumpkin: what we really want is to be able to hijack list pattern-matching syntax for ByteString/Text
21:59:52 <mmorrow> which would need compiler-support i'm pretty sure
21:59:52 <copumpkin> yeah, that would be really nice
21:59:55 <SamB_XP> bos: is that actually fast for stuff beyond the BMP?
22:00:04 <bos> mmorrow: that's why we have view types now
22:00:15 <SamB_XP> bos: we have what ?
22:00:23 <mmorrow> bos: hmm, true those do make the situation better
22:00:27 <SamB_XP> I thought that was vaporware
22:00:32 * mmorrow should use those more
22:00:37 <bos> SamB_XP: did i say view types? i meant view patterns.
22:00:46 <SamB_XP> ah, okay, those I know we have ;-)
22:00:56 <mmorrow> err, i didn't even notice..
22:01:09 <Twey> SamB_XP: Stuff beyond the BMP is so rarely used that I don't think speed really matters for it...
22:01:15 <bos> SamB_XP: nobody really cares whether UTF-16 is fast for astral plane code points, since they're so rare.
22:01:21 * copumpkin uses stuff beyond the BMP!
22:01:36 <roconnor> what's beyond BMP, PNG?
22:01:38 <SamB_XP> bos: what about the COBOL Multilingual Plane?
22:01:44 * mmorrow wonders if the unicode snowman is an astral plane codepoint
22:02:02 <roconnor> oh, unicode
22:02:12 <inimino> â
22:02:19 <copumpkin> lol
22:02:20 <mmorrow> weee!
22:02:27 <SamB_XP> roconnor: you should have not said anything and just let on that it was a bad pun
22:02:29 <mmorrow> , "â"
22:02:31 <lunabot>  "\9731"
22:02:36 <SamB_XP> that's what I thought it was until you said "oh, unicode"
22:02:39 * roconnor was so confused
22:02:40 <mmorrow> , utf8enc "â"
22:02:42 <lunabot>  "\226\152\131"
22:02:45 <inimino> U+2603
22:02:49 * mmorrow commits that to memory
22:02:54 <copumpkin> > 0x2603
22:02:56 <lambdabot>   9731
22:03:10 <mmorrow> , text . utf8enc $ "\x2603"
22:03:11 <lunabot>  â
22:03:35 <SamB_XP> so ... windows needs more christmas
22:04:13 <Stinger> eh?
22:04:24 * SamB_XP can't see the snowman
22:04:32 <copumpkin> so has anyone played with she yet?
22:04:34 <Stinger> oh thats a snowman is it
22:04:40 <Stinger> I thought it was a lightbulb
22:04:43 <Stinger> rather small
22:04:47 <copumpkin> I like everything but the import < - and import -> stuff
22:04:49 <copumpkin> :P
22:05:02 <SamB_XP> Stinger: no, a lightbulb has the fat part at the top
22:05:20 <Stinger> not in its operating orientation :)
22:05:38 <SamB_XP> Stinger: oh, the one I use to read in bed every night seems to indicate otherwise
22:05:54 <Stinger> you must have weird lightbulbs where you live
22:06:11 <SamB_XP> in fact, I'm pretty sure the majority of the lightbulbs we use are either that way up or side-ways
22:06:23 <SamB_XP> well, except maybe if you count the basement
22:06:37 <Stinger> the majority of lightbulbs we use are probably fluros
22:07:01 <SamB_XP> I wasn't counting those, on account of them being tubes
22:07:07 <SamB_XP> not bulbs
22:07:39 <Stinger> topologically equivalent :P
22:08:01 <SamB_XP> yes, but the topologist doesn't care which end is the fat end
22:08:06 <Stinger> haha
22:08:10 <Stinger> touche
22:08:51 <SamB_XP> though a topologist might notice that a florescent tube has a filamint at each end...
22:08:58 <SamB_XP> since they loop around inside
22:09:07 <jeffwheeler> Did I join #haskell?
22:09:12 <SamB_XP> jeffwheeler: yeah
22:09:25 <SamB_XP> where else do they discuss the topology of lighting elements?
22:09:27 <jeffwheeler> SamB_XP: I thought I might have joined #engineering :)
22:09:37 <SamB_XP> heh
22:09:56 <jeffwheeler> Or, heaven knows. I don't even know where I might have ended up . . .
22:10:07 <SamB_XP> well, probably not #furries
22:11:29 <jeffwheeler> Woah, I clearly missed something: http://en.wikipedia.org/wiki/Furry_fandom
22:11:33 <jeffwheeler> What the heck?
22:11:58 <mmorrow> copumpkin: what's "she"?
22:12:12 <inimino> sadly, from that day on jeffwheeler would never be quite the same
22:12:36 <jeffwheeler> This is just weird . . .
22:12:51 <copumpkin> mmorrow: http://personal.cis.strath.ac.uk/~conor/pub/she/
22:13:01 <jeffwheeler> It definitely explains this girl I knew once, in high-school.
22:14:22 <mmorrow> copumpkin: hmm, interesting
22:14:55 <mmorrow> copumpkin: preprocessors in general are interesting...
22:15:18 <mmorrow> hmm
22:15:38 <copumpkin> mmorrow: I'm hoping it'll eventually turn into a part of GHC rather than being just a preprocessor :) except for the import < - stuff :P
22:17:08 <mmorrow> copumpkin: i finally got that linker working without needing to use -mcmodel=large
22:17:13 <copumpkin> oh nice
22:17:29 <copumpkin> you have a page up yet?
22:17:41 <copumpkin> is it connected to that bytecode thing you had?
22:17:50 <mmorrow> not yet, although i'm going to put it up in a little bit (cleaning it up now)
22:18:12 <mmorrow> copumpkin: yeah, it's going to be actually, as it surprisingly works nicely
22:18:39 <mmorrow> $ ./reloc64 'entry(42)' a.o b.o c.o asdf.o
22:18:52 <mmorrow> links everything, then calls entry(42)
22:18:54 <mmorrow> e.g.
22:19:11 <mmorrow> (and those .o files are straight from gcc, no ld involved)
22:19:29 <copumpkin> nice
22:20:03 <copumpkin> entry(42) being some sort of mangled symbol, or the entry function with one parameter of 42?
22:20:08 <mmorrow> it's got me to thinking... if you could generate machine code, then you could dynamically gen code and link it in to your current proc
22:20:17 <mmorrow> copumpkin: oh no, it could have been
22:20:27 <mmorrow> $ ./reloc64 'oh_hai(42)' a.o b.o c.o asdf.o
22:20:28 <mmorrow> or
22:20:32 <mmorrow> $ ./reloc64 'main(42)' a.o b.o c.o asdf.o
22:20:49 <copumpkin> could it have been 'main(41+1)' ?
22:20:50 <mmorrow> (the entry function this is just a hack for now so i can test it.."
22:20:54 <copumpkin> ah
22:21:03 <mmorrow> copumpkin: no, pretty simple parser
22:21:08 <copumpkin> ok :)
22:21:16 <copumpkin> so you just do c "mangling" and prepend an underscore?
22:21:20 <mmorrow> (although it uses lex and yacc, so it /could/ be extended..)
22:21:24 <copumpkin> or I guess that isn't even needed on many platforms
22:21:28 <mmorrow> there's no c mangling
22:21:45 <mmorrow> i just lookup the sym in the symtab after everything is linked and relocated, then call it
22:21:55 <copumpkin> ah
22:22:06 <mmorrow> (the symtab is IntMap implem in C ;)
22:22:16 <copumpkin> aw, so this isn't in haskell?
22:22:18 <copumpkin> :'(
22:22:22 <mmorrow> no, but it could be
22:22:32 <copumpkin> it'd be nice to give GHC its own linker
22:22:34 <copumpkin> :P
22:22:42 <mmorrow> you'd just need to ffi import mmap and dlsym
22:23:18 <mmorrow> (but then of course you're relying on the ghc rts (not that that's bad, but you're not freestanding anymore)
22:23:41 <mmorrow> copumpkin: GHC /has/ its own linker!?
22:23:49 <copumpkin> ?
22:23:54 <mmorrow> oh, you mean a user controllable one..
22:24:01 <copumpkin> oh you mean for ghci
22:24:08 <mmorrow> yeah
22:24:34 <mmorrow> but it has nothing to do with bytecode really, it's just /for/ the bytecode interpreter
22:24:40 <copumpkin> yeah
22:24:59 <mmorrow> but yeah, it's not very transparent, and it has a single global symtab
22:25:04 <mmorrow> (mine has no global state)
22:25:27 <copumpkin> ooh
22:25:30 <mmorrow> (mine doesn't do -fPIC code though (yet))
22:25:40 <copumpkin> and only does ELF, right?
22:25:44 <mmorrow> yeah, that too
22:25:53 <SamB_XP> there's some other object format ?
22:25:54 <mmorrow> i want to look at the macho spec though
22:25:57 <copumpkin> lol
22:25:59 <mmorrow> heh
22:26:00 <copumpkin> I like macho
22:26:09 * SamB_XP says as he runs x-chat on Windows
22:26:13 <mmorrow> haha
22:26:21 <copumpkin> we can omit PE, nobody uses that
22:26:28 <mmorrow> yeah, that's my plan ;)
22:26:32 * mmorrow ducks
22:26:33 <sjanssen> copumpkin: worst thing about she is that its totally ungooglable
22:26:49 <copumpkin> sjanssen: yeah :P
22:26:50 <SamB_XP> sjanssen: too bad for her :-(
22:27:08 <copumpkin> sjanssen: but on the good side, it does allow him to make silly puns and .hers file extensions :P
22:30:54 <phenrique> algum brasileiro acordado aÃ­? :)
22:31:47 <mmorrow> copumpkin: can i install darwin in vmware?
22:32:04 <copumpkin> mmorrow: yeah
22:32:05 <mmorrow> copumpkin: (i.e. isn't there an open-source version or something?)
22:32:08 <mmorrow> nice
22:32:17 <copumpkin> mmorrow: you can even install mac os :P *clears throat*
22:32:20 <sjanssen> copumpkin: is this "import <-" stuff documented yet?  I have no idea whats going on
22:32:33 <copumpkin> oh, he mentioned it on his blog
22:32:39 <copumpkin> http://www.e-pig.org/epilogue/
22:33:03 <mmorrow> copumpkin: also, is this "the" for mach-o? reference http://developer.apple.com/documentation/DeveloperTools/Conceptual/MachORuntime/Reference/reference.html
22:33:05 <copumpkin> instead of import and export, he has "import ->" and "import < -"
22:33:28 <copumpkin> mmorrow: yeah, that's the one I use, it covers almost the entire format
22:33:38 <mmorrow> copumpkin: umm, "almost"?
22:33:54 <copumpkin> mmorrow: only some recent changes that are optional, like code signatures and such
22:34:00 <rocketman> 'she' is cute
22:34:00 <copumpkin> (aren't in that file)
22:34:10 <mmorrow> ah ok, so nothing essential is missing
22:34:12 <copumpkin> nope
22:34:20 <copumpkin> and the code signature stuff is easy if you want to implement it :P
22:36:41 <dainanaki> Hey everyone, how is the monad instance for ((->) t) defined? I don't know where to find the source code for the reader monad with that notation.
22:38:03 <dainanaki> @src ((->) e) (>>=)
22:38:03 <lambdabot> Source not found. My mind is going. I can feel it.
22:38:54 <rocketman> @src (->) (>>=)
22:38:55 <lambdabot> f >>= k = \ r -> k (f r) r
22:39:46 <dainanaki> @src (->) return
22:39:46 <lambdabot> return = const
22:40:05 <dainanaki> such a weird definition
22:40:15 <rocketman> @src (->) fmap
22:40:15 <lambdabot> fmap = (.)
22:41:43 <dibblego> dainanaki, it is in Control.Monad.Instances
22:42:44 <dainanaki> Oh, ok. The Hierarchical Libraries don't link to instance definitions, so I wasn't sure how to find it.
22:43:02 <dainanaki> Seems like that would be a pretty useful feature enhancement.
22:50:56 <ian_> Has anyone read the book "Introduction to Functional Programming using Haskell" by Bird and Wadler?
22:52:21 <mmorrow> copumpkin: what exactly does "jailbreaking" an iphone mean?
22:52:31 <mmorrow> copumpkin: can you then run arbitrary code?
22:52:49 <copumpkin> mmorrow: breaking through the massive chain of signage to run arbitrary programs on it
22:52:50 <copumpkin> yeah
22:53:38 <mmorrow> ooh, and do you still have full control over everything (or something)?
22:53:53 <mmorrow> as in, does jailbreaking it break anything?
22:56:32 * mmorrow tries to find the darwin boot iso..
22:57:43 <bos> first steps with haskell text API improvement: http://bit.ly/62TDL
22:58:51 <copumpkin> mmorrow: yeah, you have full control over everything. the only thing it breaks is the signature checking, which has minor security advantages
22:59:15 <mmorrow> copumpkin: nice
23:01:22 <contrapumpkin> now I can be a haskell addict on the go
23:01:55 <mmorrow> copumpkin/contrapumpkin: am i misunderstanding what darwin is? is there not a separate OS "darwin" on a .iso somewhere?
23:02:11 <mmorrow> (i could've sworn there was for at least x86..)
23:02:47 <inimino> there was opendarwin or something for a time
23:02:55 <inimino> for powerpc at least
23:03:08 <mmorrow> goo, opendarwin aparently disappeared in 2007
23:03:08 <copumpkin> yeah, they killed that, I don't think there are premade packages anymore
23:03:13 <mmorrow> sigh
23:03:19 <copumpkin> they still release all the source of the whole thing :P
23:03:23 <copumpkin> you just gotta compile it yourself
23:03:41 <copumpkin> mmorrow: it's to encourage you to pirate os x I think ;)
23:03:45 <mmorrow> copumpkin: ah, nice. have you done this? (is it painful?)
23:03:46 <mmorrow> heh
23:04:01 <copumpkin> mmorrow: nope, all my computers are macs, so I just go for mac os :/
23:04:30 <mmorrow> copumpkin: what is the appeal of mac (out of curiosity, not to suggest anything ;)?
23:04:37 <desp> I'm having trouble compiling the Cairo Clock example code.
23:04:51 <copumpkin> mmorrow: having a decent unix system + nice UI that all works nicely together, for me
23:04:55 <blackh> bos: FWIW my opinion on the matter is that all functions create API bloat and so they need to be very useful to be justified. So I would vote against 'strip', 'stripLeft', etc
23:05:01 <mmorrow> copumpkin: cool
23:05:07 <desp> GHC does not recognize the following style of pattern matching (records?):
23:05:07 <desp> onConfigure window $ \Configure { eventWidth = w, eventHeight = h } ->
23:05:24 <mmorrow> you may need parens around the pattern
23:05:27 <bos> blackh: yeah, i've mixed feelings on that myself.
23:05:30 <Cale> haha: "There's no maths involved. You solve the puzzle with reasoning and logic." -- Advice on how to play Sudoku, The Independent Newspaper
23:05:37 <desp> GHC treats Configure as a data constructor.
23:05:38 <copumpkin> lol
23:05:51 <bos> if haskell had default arguments that didn't make everyone throw up in their mouths, we could keep the function proliferation down more easily.
23:05:52 <blackh> bos: Another argument regarding these is that the definition of 'whitespace' can vary so assuming it's 0x20 only may not be so good - though 'words' and 'unwords' set the precedent for this assumption.
23:05:58 <mmorrow> desp: ? (it is)
23:06:24 <bos> blackh: well, isSpace /= (==' ')
23:06:55 <mmorrow> , words "a\fb\nc\rd\t"
23:06:57 <lunabot>  ["a","b","c","d"]
23:07:06 <copumpkin> > words "alloãã¢ãã­"
23:07:07 <lambdabot>   ["allo","\12450\12483\12525"]
23:07:13 <inimino> is in Unicode Zs?
23:07:17 <mmorrow> , filter isSpace ['\0'..]
23:07:19 <copumpkin> that's not a regular space btw
23:07:19 <lunabot>  "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\8...
23:07:36 <rocketman> Cale funny but also makes me want to cry
23:07:39 <mmorrow> , length $ filter isSpace ['\0'..]
23:07:40 <desp> Well, never mind.  Looks like I have an outdated version of the Cairo sample code.
23:07:40 <lunabot>  23
23:07:45 <inimino> looks like it
23:08:10 <mmorrow> , "ã"
23:08:12 <lunabot>  "\12288"
23:08:23 <blackh> bos: If I had designed the Prelude it definitely wouldn't have "words" and "unwords" but they are incredibly useful!
23:08:48 <Cale> rocketman: Yeah, it's pretty depressing to think about how dire the situation with mathematics education is. I think it might actually be worse than not teaching anything at all.
23:09:24 <Cale> (with respect to elementary and highschool)
23:09:29 <copumpkin> mmorrow: oh lookie, http://www.puredarwin.org/
23:09:41 <mmorrow> copumpkin: crap, now i have an osx cd but no cd-drive :/
23:09:48 <mmorrow> ooh /me looks
23:09:49 <copumpkin> mmorrow: of course, you don't get any of the mac osey stuff, just an odd bsd-like thing
23:10:10 * mmorrow just needs gcc and something that uses mach-o
23:10:25 <copumpkin> that should work then :)
23:10:26 <blackh> bos: I would have made them more like your 'split' where you can specify the delimiter.  Is there an easy way to just get the tokens from split and throw out the initial "" 's ?  "dropAround null . split X" I suppose!
23:10:48 <blackh> bos: No, that doesn't work!
23:11:24 <mmorrow> copumpkin: oh crap yesh, they've got a downloadable vmware image
23:11:28 <blackh> bos: 'tokenize' is something I really like to have - split is almost that.
23:11:31 <copumpkin> mmorrow: nice!
23:12:19 <bos> blackh: you could use filter (not . T.null) . T.split
23:13:05 <blackh> bos: I like it!  Leave it like you've got it, I say.
23:13:32 <blackh> bos: That is, don't add any helper functions for tokenizing.
23:14:27 <bos> blackh: yeah
23:17:50 <blackh> bos: One trouble with dropAfter is that the name is a bit misleading. It sounds like it drops everything after the (first occurrence on the left) of the delimiter.
23:18:11 <bos> blackh: if you have a better name, i'm all ... eyes?
23:18:35 <dibblego> bos, is there any way to use FileManip without the unix dependency?
23:19:05 <blackh> bos: Err... dropLasts?
23:19:16 <copumpkin> mmorrow: thinking of "Switching"? :P
23:19:21 <copumpkin> :D
23:20:37 <bos> dibblego: not currently
23:21:48 <blackh> bos: This one is slightly better: dropFinal
23:22:39 <mmorrow> copumpkin: gahhhh, it booted me to a bash prompt, but now the 'c' key is apparently stuck and repeating endlessly!
23:22:47 <copumpkin> mmorrow: ack!
23:23:02 <bos> blackh: for best stickiness in my late-night brain, you might want to add comments to the blog posting
23:23:28 <mmorrow> ok, it works now :)
23:23:36 <blackh> bos: I'll see if I can come up with something worth posting, then I'll do that.
23:24:05 <mmorrow> copumpkin: i actually have a macbook 15'', but the keybd is broken and i just never got it fixed
23:24:16 <mmorrow> (i like my thinkpad too much too)
23:24:22 <wmealing_> <3's his thinkpad
23:24:31 <wmealing_> 5 year onsite replacement warranty.
23:24:38 <mmorrow> (and i had a powerbook G4, but it spontaneously self-combusted (not kidding))
23:24:43 <wmealing_> oh god.
23:24:46 <mmorrow> hehe
23:24:49 <rocketman> O
23:24:50 <wmealing_> lucky you were watching !
23:24:56 <wmealing_> (were you ?)
23:25:09 <mmorrow> heh, yeah i ripped the battery out immediately
23:25:55 <mmorrow> (one of the hinges on the display broken, and the jagged edge cut through the insulation of the display power wire and shorted it, the insulation then caught on fire )
23:26:00 <mmorrow> bizarrex10
23:27:25 <mmorrow> copumpkin: err, s/macbook/macbook-pro/
23:27:42 <wmealing_> did apple repair ? or was this too far outside the warranty ?
23:28:02 <mmorrow> the warranty was up unfortunately, but i didn't try too hard though
23:28:17 <mmorrow> (it was already beat to shit anyways)
23:28:47 <copumpkin> mmorrow: zomg what's wrong with you! use an external keyboard at least :o
23:28:52 <copumpkin> mmorrow: you didn't like mac os?
23:30:02 <mmorrow> copumpkin: no, it was nice. i didn't like how certain parts of the kernel are off-limits (e.g. the soundcard(driver)), and how half the time i ./configure && make'd it'd fail on account of some header for some lib that doesn't work on osx
23:30:25 <mmorrow> the latter being the main appeal of linux (everything works)
23:30:36 <copumpkin> ah
23:30:53 <mmorrow> but the ui on osx is really nice
23:31:44 <desp> @hoogle windowWindowPosition
23:31:44 <lambdabot> No results found
23:32:00 <mmorrow> copumpkin: i should recover that macbookpro though, it's in some storage unit i haven't looked in in like a year
23:32:13 <copumpkin> aw, poor mac pro
23:32:17 <copumpkin> I mean macbook pro
23:32:21 <mmorrow> so ronery
23:32:35 <mmorrow> s/r/l/
23:32:50 <copumpkin> lol
23:33:06 <copumpkin> I feel so connected now
23:33:14 <copumpkin> I have IRC, AIM, twitter, and more on my iphone now
23:33:42 <mmorrow> copumpkin: do you have hugs running on it?
23:33:56 <copumpkin> nope, just reinstalled the OS so haven't jailbroken yet
23:34:11 <mmorrow> ah, have you ever had hugs running on it?
23:34:28 <mmorrow> (it'd be easily doable, right?)
23:35:01 <Twey> Can GetOpt handle multiple arguments?  E.G. GHC's +RTS options, where you just want to return a list of all following arguments?
23:37:52 <phenrique> nome :: [String] -> String
23:37:53 <phenrique> nome (a:b:c:d:e) = b
23:38:20 <phenrique> Non-exhaustive patterns in function nome
23:38:26 <Dae> > repeat "nom "
23:38:27 <lambdabot>   ["nom ","nom ","nom ","nom ","nom ","nom ","nom ","nom ","nom ","nom ","nom...
23:38:40 <Twey> phenrique: Consider: nome []
23:38:44 * Dae slays his inner troll
23:38:48 <Dae> also, good morning
23:38:49 <Twey> Or: nome ["Hello"]
23:38:56 <Twey> Good Dae!
23:39:02 <Twey> (had to)
23:39:06 <phenrique> Twey i consider but not work
23:39:15 <Twey> phenrique: Too right it doesn't work
23:39:21 <Twey> phenrique: That's what your problem is.
23:39:37 <Twey> You need cases to handle lists with less than four elements, too.
23:39:52 <copumpkin> > "om " ++ cycle "nom "
23:39:53 <lambdabot>   "om nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom...
23:39:58 <Dae> phenrique: you lack a cases for lists shorter than 5 (abcde)
23:40:15 <phenrique> only a minute
23:40:21 <phenrique> i will paste my code
23:41:08 <Twey> Dae: Shorter than 4
23:41:12 <Twey> e can be []
23:41:28 <phenrique> Main.hs
23:41:29 <phenrique> http://pastebin.com/m1d39f810
23:42:05 <Dae> Twey: so could e and d? Pretty sure you need a [] case to get exhaustive patterns?
23:42:34 <phenrique> Menus.hs
23:42:37 <phenrique> http://pastebin.com/m6b153e69
23:42:55 <jeffwheeler> Ooh, there's a GPS package on Hackage?
23:43:07 <Twey> Dae: A list is defined as data [a] = [] | a : [a]
23:43:26 <Dae> but....non exhaustive patterns, it'll still compile, no?
23:43:37 <jeffwheeler> I wonder if anybody's built a PAM module with Haskell, too.
23:43:38 <phenrique> it compile
23:43:41 <Twey> Yes
23:43:45 <jeffwheeler> I can see an obvious combination of those two that would be quite neat.
23:44:02 <Dae> but phenrique, looking at your code, what you're doing should probably be using tupples rather than lists?
23:44:11 <Twey> phenrique: You're going about this in entirely the wrong way.  Look into using records.
23:44:25 <Dae> or listen to Twey
23:44:39 <Twey> Using records you'll get those accessor functions generated automatically
23:45:01 * Dae has yet to use records, as he on principle never writes software that needs the real world
23:45:50 <Twey> Dae: Heh :-P
23:45:50 <jeffwheeler> Hmm, there appears to be a way to authenticate using pam, but not provide an authentication mechanism for pam. That's disappointing.
23:46:19 <Twey> Mmm
23:46:33 <Twey> IIRC, PAM uses C-style SOs for its authentication modules
23:46:41 <Twey> You'd need to write a C frontend
23:46:47 <jeffwheeler> I think a pam module that authenticates based on GPS location would be nifty.
23:46:49 <Twey> Although of course it could call Haskell
23:46:57 <Twey> jeffwheeler: Truly
23:47:51 <phenrique> I am not understand : /
23:47:54 <Dae> pam?
23:48:56 <jeffwheeler> Dae: pluggable authentication modules; that is, it is the glue between things that need to authenticate, and the methods (e.g. passwords, or fingerprints or anything) to do that authentication
23:48:57 <mmorrow> copumpkin: oh nice, erikc's macho parser parses relocation stuff too
23:49:02 <copumpkin> yup :)
23:49:19 <copumpkin> I had a patch somewhere that gave it code signage and the other new load command
23:49:21 <copumpkin> but I eated it
23:49:36 <phenrique> Dae
23:49:43 <phenrique> tupples?
23:49:47 <Dae> jeffwheeler: I see
23:50:21 <Dae> phenrique: a tupple is like (a,b,c), but Twey is right you want to be using records instead
23:50:35 <Twey> âTupleâ
23:50:48 <Dae> lies!
23:51:22 <jeffwheeler> Tubble, I think.
23:51:24 <mmorrow> i love how in C "parsing" a binary fmt consists of a call to `read' followed by a cast to the appropriate struct
23:51:47 * Dae has an infinite list of p's that needs emptying into proper words
23:51:55 <mmorrow> copumpkin: oh noes you eated it!
23:52:06 <copumpkin> I did :(
23:52:12 <copumpkin> ceiling cat saw me do it too ;(
23:52:14 <Dae> jeffwheeler: dons calls it a tuple.... guess Twey is right
23:52:21 <mmorrow> copumpkin: that's kinda neat how it has "commands"
23:52:29 <Twey> Haha, tubbles
23:52:31 <solidsnack> Is Niklas Broberg ever in here?
23:52:36 <copumpkin> yeah, it's pretty simple to decode
23:52:38 <copumpkin> nibro
23:52:38 <jeffwheeler> Dae: I know; but tubbles are so much better
23:52:45 <copumpkin> solidsnack: that's his nick
23:52:51 <jeffwheeler> @seen solidsnack
23:52:52 <lambdabot> solidsnack is in #ghc, #haskell-in-depth, #haskell-blah and #haskell. I last heard solidsnack speak 20s ago.
23:52:54 <copumpkin> @seen nibro
23:52:54 <lambdabot> I saw nibro leaving #haskell-soc, #ghc and #haskell 3d 12h 15m 40s ago, and .
23:53:03 <jeffwheeler> Wait . . . doh.
23:53:25 <Dae> phenrique: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.record
23:54:24 <Dae> I need more sleep to be up to snuff with all you youngster and your modern expressions
23:54:46 * Twey pelts Dae with zygohistomorphic prepromorphisms
23:55:15 <Dae> Twey, you can get arrested for that kind of thing
23:56:15 <Dae> Does it make you a bad haskelleer if you have no idea what zygohistomorphic prepromorphisms means, and the haskellwiki isn't helping?
23:57:13 * Twey laughs.
23:57:18 <phenrique> hei, Dae, in this site have all code from bookstore?
23:57:33 <Twey> Dae: I think they're the Haskell equivalent of the bugbear
23:57:38 <Twey> We use them to keep newbies in line
23:57:55 <Twey> âHands off that unsafePerformIO, or the zygohistomorphic prepromorphisms will get you!â
23:57:55 <jeffwheeler> Twey: but now that you just broke the secret . . . ?
23:58:01 <Dae> phenrique: I think so
23:58:02 <phenrique> :D
23:58:18 <Twey> jeffwheeler: What?  Everyone knows bugbears are real.
23:58:22 * Dae uses unsafePerformIO to get proper random numbers in haskell
23:58:31 <Twey> Dae: ...
23:58:34 <Twey> ... but why?
23:58:55 <Twey> We have a perfectly nice pure PRNG
23:58:58 <jeffwheeler> Twey: because random :: Integer is a helluva lot simpler than the other options.
23:59:43 <Twey> jeffwheeler: You mean randomIO :: IO Integer
