00:00:55 <lpsmith> berengal:  the way I wrote it should be somewhat more efficient,  and should allocate less
00:01:50 <lpsmith> you could also use my version of nub after you sort,  and be pretty efficient.  Still, nubSort would allocate less
00:02:07 <Berengal> Ah, yes, true
00:02:33 <Berengal> Am I right in thinking it's just mergesort with a nubbing merge?
00:04:59 <lpsmith> yeah, basically
00:06:17 <lpsmith> union doesn't quite nubbing;  it simply returns the number of a given element that either list has
00:06:21 <copumpkin> > wliComeBack
00:06:24 <lambdabot>   wli please come back
00:06:34 <copumpkin> (I'll stop now)
00:06:42 <lpsmith> but since you start at single element lists,  each element is guaranteed to appear exactly once in each intermediate result
00:08:01 <lpsmith> in fact, it's based of the "sort" implementation in Data.List,  except that it replaces "merge" by union
00:08:12 <lpsmith> and it's a bit more friendly to GHC's inliner
00:08:25 <Berengal> Ah
00:14:52 <Berengal> sort always struck me as a function which could be generalized into a function taking about five higher-order functions
00:15:11 <lpsmith> nubSort?
00:15:23 <copumpkin> hylo?
00:15:24 <Berengal> No, just mergesort in general
00:16:08 <Berengal> Well, at least two parameters: compare and merge
00:16:58 <Berengal> sortBy compare mergeUniq, for example
00:17:23 <Berengal> (= nubSort in this case)
00:20:42 <lpsmith> but is there many other useful arguments other than merge and mergeUniq?
00:21:21 <copumpkin> that seems pretty close to hylo really
00:21:41 <copumpkin> did you see apfelmus' recent post on that lazy sorting algorithm thread on -cafe?
00:22:48 <lpsmith> I saw it, I haven't read it yet.
00:23:42 <copumpkin> damn restricted access academic paper sites
00:23:52 <copumpkin> I'm so used to living on a college campus :P
00:25:00 <Ke> heh, we have university proxy for that
00:25:52 <copumpkin> our VPN sucks and I don't have a nice proxy set up :/
00:26:15 <copumpkin> ah well, I can usually find the papers for free on the authors' sites
00:30:01 <Ke> also it kind of makes science invalid since sources cannot be verified
00:34:39 <copumpkin> it annoys me how imperative most algorithm definitions are
00:35:33 <Rembane> It's easy to think imperatively, especially if those algorithms are going to be implemented in C.
00:35:55 <sioraiocht> Some algorithms lend themselves to it, imo
00:36:09 <sioraiocht> And some are much nicer in haskell
00:36:23 <sioraiocht> Structural recursion is nicer than a for loop over a linked list =p
00:36:38 <copumpkin> sioraiocht: I agree, but some of them definitely could be quite elegant
00:36:47 <sioraiocht> copumpkin: so write them!
00:36:47 <lpsmith> copumpkin:  sieve of Eratosthenes and many graph algorithms lend themselves well to imperative programming
00:36:52 <copumpkin> but you see x = list.start; x = x.next and things like that
00:37:07 <lpsmith> hah,  that's STL badness, not imperative badness
00:37:14 <copumpkin> lol, I mean in pseudocode
00:37:16 <sioraiocht> STL?
00:37:24 <lpsmith> C++ Standard Template Library
00:37:28 <copumpkin> ##c++'s ceiling cat disapproves of your mention of STL
00:37:31 <sioraiocht> ew
00:37:49 <Zao> SC++L, you mean.
00:37:53 <Zao> Standard C++ Library :)
00:37:55 <copumpkin> I actually quite like the STL, I just hate the language it's implemented in
00:38:17 * sioraiocht is a afraid of getting a job, because he is sure it will involve C++
00:38:21 <Ke> like missing proper tokenizer
00:38:27 <lpsmith> Sigh, it's been about 7 years or so since I've written any C++ at all
00:38:34 <lpsmith> I'm not sure if that's a good or bad thing
00:38:34 <copumpkin> well boost adds what the STL is missing
00:38:44 <Rotaerk> lpsmith, it's a good thing
00:38:45 <Zao> If you target gcc, you could always interop to Parsec :)
00:38:46 <copumpkin> and the error messages it produces make one want to gouge one's eyes out
00:38:46 <Rotaerk> no question
00:39:17 <Zao> copumpkin: I had the Salsa package spit out thousands of lines of ghc output.
00:39:20 <lpsmith> I never got deep into STL, and I don't think Boost was available then
00:39:24 <Ke> copumpkin: like the freedom to write cool "< aa<a> >" template-expressions
00:39:36 <copumpkin> :P
00:39:39 <lpsmith> Or template metaprogramming in general
00:39:50 <copumpkin> also, WTF is up with them not letting you put adjacent >>
00:39:53 <copumpkin> for template parameters
00:39:58 <Zao> copumpkin: Fixed in 0x :)
00:40:12 <copumpkin> just cause their tokenizer is dumb doesn't mean it should give me irrelevant error messages :P
00:40:15 <copumpkin> yeah yeah
00:40:19 <copumpkin> :)
00:40:32 <Zao> foo<42 >> 3> // tokenize _this_
00:40:59 <Ke> copumpkin: g++-4.5 omit default template parameters
00:41:01 <copumpkin> you tokenize > individually every time and merge later during the parsing
00:41:10 <Ke> omits
00:41:10 <copumpkin> Ke: ah nice
00:41:15 <Zao> That's what C++ needs. Even more complicated parses :)
00:41:24 <copumpkin> Zao: damn right!
00:41:54 <Zao> Ke: boost::foo<int, boost::nil, boost::nil, boost::nil, ...
00:43:55 <lpsmith> I know Haskell today because I hated C++
00:44:13 <copumpkin> :)
00:44:26 <Rembane> :)
00:44:38 <lpsmith> I learned C++ my junior year of HS,  and at first I was like how much 1337er than all yall,  I know C++!
00:44:56 <lpsmith> And a month later I was like, I hate C++, I hate pascal, I gotta find something better
00:45:47 <Elly> heh :)
00:45:50 <Berengal> Deciding to learn Haskell was one of the first things I did when I started programming
00:45:56 <lpsmith> That lead me to Modula-3, which led me to SML,  and then finally Haskell
00:46:15 <copumpkin> lpsmith: how long did that take?
00:46:51 <Berengal> Actually, I decided to learn Java, C, Python, Perl, Lisp, Haskell, Erlang, Prolog, Forth, Ruby...
00:47:05 <copumpkin> lol
00:47:11 * Elly went C -> Perl -> Java -> SML -> Scheme :P
00:47:12 <soupdragon> Java, C, Python, Perl, Lisp, Haskell, Erlang, Prolog, Forth, Ruby???
00:47:32 <Berengal> The only ones I haven't gotten to yet on that list is Perl and Forth
00:47:40 <copumpkin> do factor instead
00:47:45 <Berengal> I was thinking that
00:47:53 <copumpkin> it has a purty REPL on mac os
00:48:09 <Rotaerk> I did qbasic, C++, gained some sanity and learned C#, then F# and haskell
00:48:14 <Berengal> I don't have a mac, so that notion holds no sway over me
00:48:22 <lpsmith> copumpkin: about a year
00:48:23 <soupdragon> I'm still mystified that anyone can write programs in forth
00:48:38 <lpsmith> of course, I wasn't very good at SML or Haskell for a while;  I had a lot of re-learning to do
00:48:43 <lpsmith> I learned both in parallel
00:50:08 <Berengal> After learning Haskell, my quest to learn as many languages as possible, to collect the best aspects of all of them, kind of lost its appeal
00:50:18 <soupdragon> haha
00:51:18 <Berengal> Really, before haskell I'd spend a month with a language. After I've just spent a week, at most, and doing haskell at the same time
00:52:30 <Berengal> This is why I haven't gotten to Perl and Forth yet. They were scheduled for christmas, but I learned haskell in october
00:53:34 <lpsmith> I was BASIC -> Turbo Pascal -> C++ -> Modula-3 -> SML -> Haskell
00:53:47 <lpsmith> And then python, erlang, scheme, and a few others after that
00:53:49 <lpsmith> PHP
00:53:54 <Rembane> *shiver*
00:53:54 <lpsmith> god I hate PHP
00:54:08 <copumpkin> lol
00:54:17 <copumpkin> it has the ugliest standard library of any language I've encountered
00:54:24 <Rembane> PHP is... hm... considering the alternatives... well, it isn't as bad as classic ASP
00:54:37 <Berengal> I have managed to avoid PHP thus far, even though I'm rewriting a PHP app
00:54:43 <lpsmith> PHP encourages sloppy programming, that's for sure
00:54:48 <Rembane> PHP is like duct tape and wd40 gone bad
00:55:13 <soupdragon> is there life beyond haskell
00:55:18 <Berengal> The only thing I know about PHP is that . is string concatenation
00:55:26 <Berengal> I know that because I needed to know what the DB looked like...
00:55:57 <lpsmith> oh, throw Java in there too.
00:56:03 <Berengal> Oh, and it apparantly has this weird concept of "arrays"
00:56:19 <lpsmith> that arrays are hash tables?
00:56:21 <copumpkin> everything is an associative array
00:56:30 <Berengal> Yeah, something like that
00:56:47 <Rembane> That's quite neat in the context it lives
00:57:12 <lpsmith> Rembrane:  not really, it mostly means that your arrays are slower than they should be
00:57:21 <mahogny> only advantage of php is that it's so easy to start with, people get stuck with it. it's no fun to write large codes in
00:58:13 <Rembane> lpsmith: Well, speed isn't really an issue in this context. Just throw more hardware at it.
00:59:16 <fermento> from reading the docs it seems PHP's "arrays" are hash tables with a doubly-linked list through the values
00:59:41 <lpsmith> fermento:  you mean open chaining?
00:59:41 <copumpkin> like java's linkedhashmap I guess
00:59:52 <fermento> what's open chaining?
00:59:58 <lpsmith> Doesn't suprise me,  open chaining is more common than probing
01:00:09 <lpsmith> every bucket in a hashtable is a linked list
01:00:24 <fermento> that's an implementation detail of the hashtable
01:01:03 <fermento> I'm talking about a single list that provides a user-visible ordering
01:01:55 <lpsmith> hmm
01:02:36 <mahogny> so summing a list in php would trivially be O(n^2)? great.
01:04:10 <fermento> er, why?
01:04:35 <mahogny> linkedlist[i] is i steps
01:04:42 <mahogny> plug into a loop
01:04:58 <mornfall> mahogny: Yeah, but you use foldl (+) 0 to sum, right? : - P
01:05:11 <mahogny> in haskell yes. but does php have anything like this?
01:05:20 <mornfall> mahogny: I expect iterators to exist.
01:05:29 <mahogny> hm. they have foreach, that would do
01:05:34 <fermento> there is no linkedlist[i]
01:05:38 <fermento> it's hashtable[i]
01:05:57 <mornfall> Yeah, that's randomized O(1).
01:05:59 <mahogny> yes, which is a linked list for this purpose
01:06:17 <fermento> mahogny: no
01:06:28 <mahogny> oh
01:06:29 <mornfall> mahogny: Well, *asymptotically*, yeah, it's O(n), but for all practical purposes, it's O(1).
01:06:54 <mahogny> so what use is the linked list then?
01:06:58 <fermento> for extra fun, look up the meaning and differences of: sort, arsort, asort, krsort, ksort, natsort, natcasesort, rsort, usort, array_multisort, uasort, uksort, dbx_sort, imap_sort, ldap_sort, yaz_sort
01:07:00 <mornfall> mahogny: for the iterator?
01:07:34 <mahogny> I assume it would be used for [i] as well, or the iterator would not be consistent with indexing
01:08:03 <mornfall> mahogny: Why not?
01:08:14 <mahogny> that'd be confusing -_-
01:08:25 <fermento> mahogny: I don't understand what you mean
01:08:36 <mornfall> I don't see why it would be inconsistent, I guess.
01:09:07 <mornfall> Although it may be not-so-straightforward to implement.
01:09:08 <mahogny> most users when they hear "array" would expect an iterator to just go through [i], step by step
01:10:04 <fermento> [i] is "lookup by key", it doesn't care about the internal order
01:10:53 <mahogny> oh. right. so php doesn't use different brackets for array indexing and key indexing
01:12:49 <fermento> PHP has no arrays
01:16:44 <quicksil1er> desp: pong
01:46:08 <tibbe> hey, where are people staying for the icfp?
01:46:51 * ivanm will be staying in Serbia at that time...
01:46:52 <ivanm> ;-)
01:46:58 <tibbe> heh
01:47:46 <ivanm> I wanted to go to ICFP... but since I didn't get any funding for studying there, I didn't want to waste my time/money just for ICFP
01:48:52 <tibbe> I'm lucky enough that my employer pays for me
01:49:22 <ivanm> @slap tibbe
01:49:22 * lambdabot karate-chops tibbe into two equally sized halves
01:49:24 <ivanm> :p
01:50:26 <tibbe> :)
01:58:00 <amr> my accunt banned
01:58:16 <amr> help me
01:58:42 <quicksilver> if you have problems with your freenode account, you need to go speak to the freenode staff, not us.
01:59:00 <ivanm> or else if it was banned here, ask on #gentoo-ops
01:59:05 <ivanm> as stated in the haskell IRC policy
01:59:17 * quicksilver peers at ivanm 
01:59:22 <quicksilver> ITYM #haskell-ops
01:59:28 <ivanm> gah
01:59:30 <ivanm> I keep doing that :s
01:59:37 * ivanm bangs head on a convenient surface
01:59:41 <ivanm> ow!
02:01:16 <amr> my data lost
02:01:39 <amr> What do I do
02:02:25 <ivanm> amr: which data?
02:06:26 <Trafalgard> Got an exception from doesFileExist - "No such file or directory". Description of the function says: "The operation doesFileExist returns True if the argument file exists and is not a directory, and False otherwise." No mention of exceptions.
02:06:35 <Trafalgard> Figured out why though, I think
02:06:53 <Trafalgard> I was testing it in the same folder as my project is in, the file in question is .hsproject :P
02:07:13 <Trafalgard> kind of odd though, you'd think it could tell at least that it's a file and not a directory
02:07:27 <Trafalgard> even if it's not openable because it's in use
02:07:59 <FauxFaux> Iirc you have to use the doesDirectoryExist thing (RWH whines about it for about 30 pages).
02:08:08 <Trafalgard> ... unless it really does think it doesn't exist for some reason
02:08:40 <Trafalgard> wait, what? This is a file :P
02:08:53 <Trafalgard> and both functions should work
02:09:09 <Trafalgard> besides which, I need both to know whether something exists and what it is
02:10:22 <Trafalgard> anyways, just thought I'd mention it
02:10:28 <Trafalgard> going to sleep now
02:11:43 <quicksilver> Trafalgard: that means one of the parent directories doesn't exist, I imagine.
02:12:09 <Trafalgard> which would make it rather difficult for it to have found that file and for the project files and source code to exist
02:13:34 <Trafalgard> the only two obvious things I could think of are that either it's because it's in use, which I could test by shutting down eclipse -- *does so* -- or it's a bug or feature due to the filename beginning with .
02:13:56 <sioraiocht> dcoutts: ping?
02:14:27 <Trafalgard> still got an exception with eclipse closed
02:17:17 <quicksilver> Trafalgard: that does sound odd.
02:17:24 <quicksilver> Are you sure the path you're passing is what you think it is?
02:20:46 <Trafalgard> maybe not, I had been testing it in the current directory (the src folder) before and that worked fine; but it just occured to me that getDirectoryContents might not like relative paths
02:20:53 <Trafalgard> since I'm giving it one now
02:21:21 <quicksilver> getDirectoryContents is fine with relative paths.
02:21:30 <quicksilver> the bug you claim is in doesDirectoryExist
02:21:39 <quicksilver> I bet you're giving it the wrong path :P
02:22:12 <Trafalgard> well I was giving it ".."
02:22:17 <Trafalgard> so...
02:22:20 <Ke> quicksilver: Ii still could always return false
02:22:25 <Ke> It
02:22:32 <quicksilver> it could.
02:22:46 <quicksilver> however, I think what it does it throw an exception if the path is invalid
02:22:53 <quicksilver> (i.e. one of the parent components doesn't exist)
02:22:57 <Trafalgard> if the path is supposed to be different it should say the path is invalid in the exception
02:23:13 <quicksilver> and return true/false if the path is valid
02:23:16 <quicksilver> maybe it could do that.
02:23:19 <quicksilver> but I don't think it doe.
02:23:33 <quicksilver> I think it follows, roughly, the POSIX semantics for the file/directory functions.
02:23:39 * Trafalgard tries "../"
02:23:59 <Trafalgard> *exception*
02:24:12 <Trafalgard> okay, going to just sleep.
02:24:17 <quicksilver> doesDirectoryExist ".." returns True for me.
02:24:26 <quicksilver> (and so does "../")
02:24:28 <Trafalgard> yes, I'm trying to check things inside it
02:24:57 <Trafalgard> yeah, hmm, getDirectoryContents appears to work fine with ".."
02:25:58 <quicksilver> doesDirectoryExist "../blah" returns correctly for me
02:26:06 <quicksilver> that is, True or False depending if blah exists.
02:26:09 <Trafalgard> wait. It was trying to open ".hsproject" - that means it didn't have the .. on the front of it...
02:26:15 <Trafalgard> so that's probably the problem
02:26:27 <quicksilver> yes, you need to build the paths.
02:26:33 <Trafalgard> but it shouldn't have been going KABLAM
02:26:36 <quicksilver> getDirectoryContents doesn't return full paths
02:27:59 <quicksilver> I don't think there is a bug here :)
02:46:33 <apfelmus> Pandoc 1.2.1 fails to install :'(
02:46:36 <apfelmus> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3059#a3059
02:47:06 <apfelmus> "Couldn't match expected type `old-time-1.0.0.1:System.Time.ClockTime' against inferred type `ClockTime'"
02:47:34 <apfelmus> It seems my installation is botched up to some extend, just how exactly?
02:47:39 <ivanm> apfelmus: :o
02:47:41 <ivanm> WORKSFORME
02:48:04 <ivanm> apfelmus: I have 1.0.0.2
02:48:08 <ivanm> of old-time
02:48:35 <apfelmus> I've got both 1.0.0.1 and 1.0.0.2
02:48:38 <quicksilver> apfelmus: looks like you have two versions of old-time
02:48:45 <quicksilver> apfelmus: and some packages compiled against one, and some against other.
02:48:54 <ivanm> the dreaded diamond dependency problem!
02:49:01 <quicksilver> you want to rebuild all the packages which are compiled against the old
02:49:02 * apfelmus hates diamonds
02:49:06 <quicksilver> so they are now compiled against the new
02:49:12 <apfelmus> How do I do that?
02:49:23 <quicksilver> I have no idea :(
02:49:24 <ivanm> apfelmus: remove 1.0.0.1
02:49:28 <ivanm> then run ghc-pkg check
02:49:34 <ivanm> it will tell you which ones are dodgy
02:49:38 <ivanm> don't forget the ones at the bottom
02:50:13 <ivanm> apfelmus: which OS/distro?
02:50:21 <apfelmus> OS X
02:50:31 <ivanm> OK, can't help you there then ;-)
02:50:38 <apfelmus> :'( ;)
02:50:54 <apfelmus> oldtime is part of the core libraries, right?
02:51:00 <quicksilver> you should get those teeth fixed.
02:51:04 <ivanm> quicksilver: heh
02:51:26 <ivanm> apfelmus: yes
02:51:42 <apfelmus> Ok, then I'm probably better off deleting the 1.0.0.2 from my user install.
02:52:01 <ivanm> yeah
02:52:27 <apfelmus> Hm, what do I have to delete for that?
02:52:51 <ivanm> apfelmus: ghc-pkg unregister old-time-1.0.0.2 ?
02:53:40 <apfelmus> Ok, that worked. ghc-pkg check says nothing.
02:54:52 <apfelmus> ivanm: Wee, the old-time problem is gone! Thanks a lot :)
02:55:18 <ivanm> no worries
02:55:21 <apfelmus> quicksilver: And thank you, too :)
03:32:12 <hackagebot> traced 2009.7.20 - Simple evaluation trace (MaxBolingbroke)
04:17:23 <hackagebot> cautious-file 0.1.3 - Ways to write a file cautiously, to reduce the chances of problems such as data loss due to crashes or power failures (RobinGreen)
04:20:27 <Raevel> dudes, wake up
04:24:00 <ivanm> Raevel: nah, I like sleeping
04:37:46 <ivanm> there, I think I've fixed all the Either-based graphviz problems :s
04:44:58 <ivanm> @seen zsol
04:44:59 <lambdabot> zsol is in #haskell. I last heard zsol speak 17h 35m 20s ago.
04:46:06 <ivanm> @tell zsol OK, I've finally updated/replaced all the Either-based values in graphviz... about to do the release
04:46:07 <lambdabot> Consider it noted.
04:49:19 <Oejet> @tell ivanm That is a neat lambdabot function, I did not know about.
04:49:20 <lambdabot> Consider it noted.
04:50:32 <Oejet> Hm, then it waits for the recipient to say something?
04:50:40 <Cale> right
04:59:23 <Raevel> @hoogle Ordering -> Ordering
04:59:24 <lambdabot> Prelude pred :: Enum a => a -> a
04:59:25 <lambdabot> Prelude succ :: Enum a => a -> a
04:59:25 <lambdabot> Prelude id :: a -> a
04:59:38 <Cale> Raevel: what function are you looking for?
05:00:03 <Raevel> i want to negate the ordering to sort descending
05:00:14 <Cale> flip compare
05:00:27 <Cale> (is the simplest way)
05:00:45 <Raevel> ah
05:00:49 <Raevel> @type (compare, comparing)
05:00:51 <lambdabot> forall a b a1. (Ord a, Ord a1) => (a -> a -> Ordering, (b -> a1) -> b -> b -> Ordering)
05:01:03 <Cale> or yes,  flip (comparing f)
05:01:07 <Cale> compare EQ  will flip an Ordering value though
05:01:19 <Cale> > map (compare EQ) [LT, EQ, GT]
05:01:21 <lambdabot>   [GT,EQ,LT]
05:02:14 <Raevel> okay thanks
05:03:56 <Oejet> That could be called a meta comparison.
05:04:18 <FauxFaux> Ow.
05:04:25 <Oejet> > compare EQ GT
05:04:27 <lambdabot>   LT
05:05:27 <quicksilver> also of note is the fact that you can `mappend` comparisons to get lexicographic sort
05:05:56 <Oejet> quicksilver: Give an example, please.
05:06:02 <quicksilver> (a,b) `compare` (c,d) == (a `compare` c) `mappend` (b `compare` d)
05:06:28 <ceal> when i try to use ghc <filename>.hs i get an error cannot find -lgmp. what's wrong?
05:06:44 <quicksilver> ...and furthermore this has the desired laziness property.
05:06:50 <quicksilver> > LT `mappend` undefined
05:06:52 <lambdabot>   LT
05:07:10 <Oejet> ceal: Perhaps you need to add the "--make" option?
05:07:19 <PeakerWork> @src Ordering mappend
05:07:20 <lambdabot> Source not found. Maybe you made a typo?
05:07:56 <ceal> oejet:same error
05:07:57 <quicksilver> PeakerWork: your tireless optimism on what you expect @src to contain always cheers me :)
05:08:07 <PeakerWork> Heh :)
05:08:10 <bremner> @src P=NP
05:08:10 <lambdabot> Source not found. My pet ferret can type better than you!
05:08:16 <PeakerWork> someone ought to get @src to be as complete as >
05:08:25 <quicksilver> it's a different thing.
05:08:34 <PeakerWork> someone ought to fix it to be the same thing :)
05:08:41 <quicksilver> the database accessed by @src is a small, manually entered database.
05:08:51 <quicksilver> with the goal of being concise - single line where possible.
05:09:02 <quicksilver> full library source is easily available in your web browser
05:09:06 <quicksilver> why should it be hereA?
05:09:22 <Oejet> ceal: Do you have the
05:09:51 <ceal> oejet:the what?
05:09:52 <Oejet> ceal: gmp-devel package installed?
05:10:56 <ceal> i cant find any such package in my repository
05:11:47 <Oejet> ceal: Which OS?
05:11:56 <kfranke> how does one convert a NominalDiffTime to a Float?
05:12:14 <ceal> ubuntu 9.04
05:12:32 <Saizan> ceal: something like libgmp3-dev
05:13:07 <quicksilver> kfranke: realToFrac
05:13:11 <quicksilver> kfranke: (but never use Float)
05:13:20 <quicksilver> kfranke: use Double, perhaps.
05:13:20 <ceal> have it in my repo it's not installed; is it the solution?
05:13:27 <quicksilver> ceal: almost certainly.
05:13:43 <ceal> thanks
05:13:47 <PeakerWork> quicksilver: for the same reason other stuff available online is available with lambdabot. Its damn convenient and pedagogical :)
05:13:59 <quicksilver> PeakerWork: it would be extremely inconvenient and spammy :P
05:14:31 <PeakerWork> quicksilver: it could golf the code or at least unwrap it into a single line, or truncate it and place a link or such
05:14:43 <quicksilver> I'd hate anything which caused lambdabot to emit more than 2 lines or so.
05:14:48 <jkramer> Hello
05:14:55 <PeakerWork> quicksilver: it already easily emits ~4-5 lines
05:14:57 <quicksilver> A feature which generated HTTP link to the source would be nice though.
05:14:58 <dcoutts> sioraiocht: pong
05:15:00 <quicksilver> PeakerWork: and, I hate that.
05:15:03 <jkramer> How can I extract the error message from an (IO)Exception?
05:15:06 <sioraiocht> dcoutts: haha, quickish qeustion
05:15:26 <jkramer> I want to provide my own message instead of just printing (show e)
05:16:45 <quicksilver> jkramer: ugly: show it and parse the string it produces?
05:17:41 <kfranke> quicksilver: thanks!
05:18:20 <sioraiocht> if I have two Streams that have the same lements in the same order, but one is the concatenation and the other is not, is there a performance cost to unfolded the concatenated one?
05:18:29 <sioraiocht> s/unfolded/unfold/
05:19:05 <dhun> is there a function to see what goes on in haskell, something like trace or dribble in lisp?
05:19:21 <mux_> Debug.Trace.trace
05:20:12 <dhun> thank you
05:21:23 <mux_> I wish hSeek / hTell would take a FileOffset instead of pretending to work with Integer offsets
05:21:48 <dcoutts> sioraiocht: versus what? I'm not clear what you mean
05:22:12 <mux_> the Integer offset is currently silently truncated with fromIntegral and passed to lseek() as is
05:33:16 <desp> quicksilver: hi :)
05:35:35 <quicksilver> desp: you pinged.
05:35:49 <jkramer> If anyone cares, I solved the problem by importing GHC.IOBase and resolving the exception with  (\ (IOError _ _ _ s _) -> ...
05:37:37 <desp> quicksilver: ah, that must've been a while ago.
05:37:53 <desp> Is anyone interested in adventures with vector physics in the type system?
05:45:13 <ivanm> Oejet: that is pretty much _the_ lambdabot function! how could you have _not_ known about it! :o
05:46:59 * Oejet waits for lambdabot to deliver the message.
05:47:48 <ivanm> Oejet: which message?
05:47:49 <ivanm> ;-)
05:48:00 * ivanm is on several different channels which contain lambdabot...
05:48:14 <ivanm> desp: that sounds like a bad idea...
05:49:51 <Oejet> ivanm: Should it not deliver the last part of "Oejet: @tell ivanm That is a neat..." to you? Is that a private message? When exactly is it delivered then?
05:49:55 <desp> ivanm: why? :)
05:50:09 <ivanm> @tell Oejet you have a new message
05:50:09 <lambdabot> Consider it noted.
05:50:13 <ivanm> Oejet: now say something
05:50:22 <ivanm> desp: why would you want to?
05:50:40 <desp> ivanm: to help NASA stop losing Mars orbiters.
05:50:45 <ivanm> heh
05:50:59 <ivanm> desp: isn't that just a matter of telling everyone to use SI units?
05:51:09 <desp> ivanm: yes, including the Haskell type system. :)
05:51:32 <desp> http://varsztat.com/physics/Physics.hs
05:51:47 <hackagebot> graphviz 2999.1.0.0 - GraphViz wrapper for Haskell. (IvanMiljenovic)
05:51:52 <Oejet> Magic!
05:51:52 <lambdabot> Oejet: You have 1 new message. '/msg lambdabot @messages' to read it.
05:52:11 <ivanm> gah, I forgot to change that .cabal message _again_! :@
05:53:40 <Oejet> ivanm: Thanks, I see, that it works.
05:58:17 <ivanm> gah, there's a semi-serious bug in graphviz! :@
06:02:18 <hackagebot> graphviz 2999.1.0.1 - GraphViz bindings for Haskell. (IvanMiljenovic)
06:14:10 <desp> @type fmap
06:14:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:16:25 <Botje> the f in fmap stands for 'fruit'
06:17:01 <ivanm> or not
06:17:08 <Vanadium> Only if the m in fmap stands for meat
06:17:09 <badsheepy> but its still one of your five a day
06:18:29 <Botje> the a is aardvark, obviously
06:19:00 <ivanm> no, wouldn't it be "and"?
06:19:49 <Badger> fruitmeatand?
06:19:51 <Vanadium> I think we can all agree on pie for the p :|
06:19:55 <Badger> fruitmeatandpie!
06:21:13 <Badger> > let fruitmeatandpie = fmap in fruitmeatandpie (+1) [1,2,3]
06:21:14 <lambdabot>   [2,3,4]
06:21:19 <ivanm> Badger: no, you have to capitalise to make it easy to get the acronym back out!
06:21:24 <ivanm> or at least camelCase it
06:21:30 <Badger> hmm
06:21:33 <Badger> fair point
06:21:48 <Badger> > let fruitMeatAndPie = fmap in fruitMeatAndPie (+1) [1,2,3]
06:21:50 <lambdabot>   [2,3,4]
06:21:56 <ivanm> > let fruitMeatAndPie = fmap in fruitMeatAndPie (\x -> x^x) [1..10]
06:22:00 <lambdabot>   [1,4,27,256,3125,46656,823543,16777216,387420489,10000000000]
06:22:16 <ivanm> :D
06:22:57 <Badger> heh
06:23:01 <Badger> that just has to be
06:23:13 <Badger> @let fruitMeatAndPie = fmap
06:23:16 <lambdabot>  Defined.
06:23:50 <Botje> yay :[
06:23:58 <Botje> :], even
06:33:00 <burp> > fruitMeatAndPie (\x -> x^x) [1..10]
06:33:03 <lambdabot>   1
06:33:44 <Oejet> @hoogle (a,b,c) -> a
06:33:45 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
06:33:45 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
06:36:27 <spb-vlan> hi! could you recommend some introductionary reading on using foldable and traversable? i've read "the typeclassopedia", but still not got it
06:37:37 <quicksilver> spb-vlan: http://www.haskell.org/haskellwiki/Foldable_and_Traversable
06:37:43 <quicksilver> may have some nuggets of use to you.
06:37:53 <quicksilver> spb-vlan: otherwise, just ask. I"m not sure they are complex enough topics to merit a tutorial.
06:39:16 <\stro> @djinn IO ()
06:39:17 <lambdabot> Error: Undefined type IO
06:39:34 <\stro> @djinn (a,b)->(b,a)
06:39:35 <lambdabot> f (a, b) = (b, a)
06:40:07 <ivanm> @type fruitMeatAndPie
06:40:09 <lambdabot> forall a b1 b. (Num a) => (a -> b1) -> b -> b1
06:40:10 <ivanm> ^^ Badger
06:40:52 <spb-vlan> quicksilver: is it appropriate to use a traversable to transform an abstract syntax tree?
06:41:13 <quicksilver> depends what 'transform' means.
06:41:35 <quicksilver> traversable is a way of threading a monad (or an applicative) through a tree-like structure, returning results in the same 'shape'.
06:42:15 <ivanm> quicksilver: only tree-like structures? so no cycles?
06:42:42 <quicksilver> explicitly modelled cycles should be fine.
06:42:54 <quicksilver> implicit cycles within haskell data structures are, of course, not cycles.
06:42:57 <quicksilver> they are infinite structures.
06:45:04 <spb-vlan> what does a traversable preserve in the shape of a structure? could it map Tree [Tree a, Tree b] to Tree c?
06:46:53 <quicksilver> it almost sounds like you're trying to solve a problem you don't have.
06:46:58 <quicksilver> or dont' understand :)
06:47:04 <quicksilver> traversables are nothing magic.
06:47:16 <quicksilver> they don't suddenly do arbitrary transformations of your data.
06:47:21 <quicksilver> they are structure-preserving.
06:47:37 <quicksilver> the fundamental operation of a traversable is Tree (m a) -> m (Tree a)
06:48:04 <quicksilver> but obviously you can use traversables as part of your toolkit to build complex structure changing transformations.
06:49:56 <gbacon_> okay, I just tried to type Monday, but it came out Monady
06:50:04 <gbacon_> Assimilation complete.
06:50:29 <elbar> :)
06:50:47 <mauke> preflex: remember gbacon okay, I just tried to type Monday, but it came out Monady.  Assimilation complete.
06:54:02 <bsdemon> How I can express in Haskell a function that returns some value of non-specified type? for example func :: (Num a) => Int -> a
06:54:14 <bsdemon> Is it possible?
06:54:16 <mauke> depends on what you mean
06:54:20 <mauke> that type is valid
06:54:42 <BONUS> :t fromIntegral
06:54:43 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:55:04 <bsdemon> ok, I have my custom binary protocol encoder: encode :: (Encodable a) => a -> ByteString
06:55:26 <bsdemon> and need decoder for that: decode (Encodable a) => ByteString -> a
06:55:39 <mauke> that works
06:56:18 <bsdemon> decode :: (Encodable a) => B.ByteString -> a
06:56:18 <bsdemon> decode s = 2
06:56:27 <Axman6> bsdemon: but the program will have to be able to figure out what that a is at some point
06:56:31 <bsdemon> I have instance Encodable Int
06:56:38 <mauke> that doesn't work
06:56:41 <bsdemon> why?
06:56:47 <mauke> with that type, the caller gets to choose the 'a'
06:56:54 <mauke> you can't just hand them an Int
06:57:06 <spb-vlan> quicksilver: maybe you are right :) i'm just writing some piece of code and thinking in terms of mapping trees. and the name "traversable" suggests that there might be something related to my problem. maybe it isn't so, but i don't have a clear understanding where a traversable instance is appropriate (as opposed to fmap, which usage is quite clear for me)
06:57:20 <bsdemon> mauke, I do not understand
06:57:27 <quicksilver> spb-vlan: it's not like a matter of taste ;)
06:57:29 <bsdemon> caller will work with Encodable type
06:57:30 <Axman6> :t read
06:57:32 <lambdabot> forall a. (Read a) => String -> a
06:57:40 <quicksilver> spb-vlan: it's appropriate when it actually has the right type for what you're trying to do.
06:57:43 <Axman6> > read "2"
06:57:45 <lambdabot>   * Exception: Prelude.read: no parse
06:57:53 <quicksilver> spb-vlan: the comparison with fmap is very apposite though.
06:57:55 <Axman6> no type was specified for 'a' there.
06:57:58 <Axman6> > read "2" :: Int
06:58:00 <lambdabot>   2
06:58:03 <quicksilver> spb-vlan: map applies a pure function, and keeps the structure.
06:58:17 <spb-vlan> ok, and traversable?
06:58:17 <quicksilver> spb-vlan: traverse applies a monadic (or applicative) functions and keeps the structure.
06:59:02 <gbacon> EPARALLELSPACETIME
06:59:43 <quicksilver> spb-vlan: did that answer your question?
07:00:37 <spb-vlan> quicksilver: thanks for this analogy, i should think about it and look at the types
07:00:52 <quicksilver> spb-vlan: also, are you familiar with the function 'sequence' ?
07:00:54 <quicksilver> :t sequence
07:00:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:01:07 <Badger> ivanm: er
07:01:09 <spb-vlan> yes
07:01:14 <Badger> I don't understand that
07:01:14 <quicksilver> spb-vlan: that is the 'jumping-off' point for the whole Applicative/Traversable bandwagon.
07:01:26 <Badger> shouldn't it be the same type?
07:01:27 <quicksilver> spb-vlan: 'traverse' generalise sequence away from lists [].
07:01:37 <quicksilver> spb-vlan: ...to an arbitrary traversable 't'.
07:01:50 <quicksilver> spb-vlan: and simulatenously generalises from Monads to Applicatives.
07:01:57 <ivanm> Badger: it defaulted methinks
07:02:06 <Badger> :/
07:05:32 <ivanm> @type fmap
07:05:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:05:47 <ivanm> @let fruitMeatAndPie f func = fmap f func
07:05:48 <lambdabot>  <local>:2:25:
07:05:49 <lambdabot>      Occurs check: cannot construct the infinite type: b = f b...
07:05:56 <ivanm> :o
07:06:01 <ivanm> @let fruitMeatAndPie f = fmap f
07:06:03 <lambdabot>  <local>:1:0:
07:06:03 <lambdabot>      Equations for `fruitMeatAndPie' have different numbers of ...
07:06:09 <ivanm> @unlet fruitMeatAndPie
07:06:10 <lambdabot>   Parse error
07:06:12 <ivanm> gah
07:07:02 <Saizan>  @undef
07:07:05 <Saizan> @undef
07:07:42 <FauxFaux> @undef
07:08:17 <desp> @djinn
07:08:18 <lambdabot> Cannot parse command
07:08:28 <desp> @djinn f ? a->a
07:08:28 <lambdabot> Cannot parse command
07:08:34 <desp> Is there a djinn command?
07:08:45 <ivanm> desp: I thought that was it...
07:09:18 <Erikie> Hi, i figured here would be the best place to ask, does anyone know if spaced repitition software has ever been implemented in haskell?
07:09:23 <desp> @help
07:09:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:09:27 <desp> @list
07:09:28 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:09:28 <quicksilver> name doesn't mean much to me, Erikie
07:09:37 <Erikie> http://en.wikipedia.org/wiki/Spaced_repetition
07:09:38 <quicksilver> @djinn a -> a
07:09:39 <lambdabot> f a = a
07:09:41 <desp> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
07:09:42 <quicksilver> desp: ^^
07:09:45 <desp> Aha, thanks.
07:10:24 <quicksilver> Erikie: google search doesn't find anything and there is nothing on hackage.
07:10:30 <quicksilver> Erikie: so I'm guessing "no"
07:10:36 <Erikie> aha, guess i'll need to go about myself then :)
07:10:39 <Erikie> thanks.
07:10:43 <straw> Hey! Short question. How was it called again, when I could omit a variable like in.. odd = not . even
07:11:05 <ivanm> straw: point-free?
07:11:23 <straw> Hmm, I was thinking of something different somehow.
07:11:48 <mauke> pointless?
07:11:58 <doserj> straw: eta-reduction?
07:12:40 <straw> Hmm, it's not what I was thinking, but if you say so, I'll remember those :)
07:12:50 <BONUS> function composition?
07:13:18 <straw> That's the . one, but not the name of the omitting variable thingy
07:13:36 <mauke> omitting variables is points-free
07:13:45 <straw> oki, thanks!
07:13:49 <BONUS> that's pretty much what it is yeah
07:13:51 <ivanm> or pointless if you think you're funny
07:14:05 <straw> ;]
07:14:36 <bsdemon> is there any overview of how haskell type system works?
07:14:46 <bsdemon> in detail, typeclasses and etc.
07:15:06 <spb-vlan> quicksilver: ok, a Traversable generalizes sequence away from [] to Monad and furhter to Applicative (sequenceA). so traverse f is just sequenceA . fmap f...
07:15:14 <quicksilver> spb-vlan: no.
07:15:23 <quicksilver> spb-vlan: from [] to Traversable, not to Monad.
07:15:45 <quicksilver> spb-vlan: from [] to Traversable, from Monad to Applicative - two separate directions of generalisation.
07:15:46 <spb-vlan> ah, of course
07:16:29 <quicksilver> bsdemon: tehre are a few chapters in RWH abotu it.
07:16:42 <killerstorm2> @djinn a -> b -> a
07:16:43 <lambdabot> f a _ = a
07:17:08 <bsdemon> quicksilver, I'd read them all
07:17:34 <bsdemon> especially i want to read about ghc type system's extensions
07:18:09 <Beelsebob> @. pl djin a -> b -> a
07:18:09 <lambdabot> Plugin `compose' failed with: Unknown command: "djin"
07:18:13 <Beelsebob> @. pl djinn a -> b -> a
07:18:13 <lambdabot> f = const
07:19:00 <desp> bsdemon: I found http://www.haskell.org/haskellwiki/GHC/Type_families very useful during the past week
07:19:18 <bsdemon> desp, thanks!
07:19:42 <desp> bsdemon: that's just the type families extension, though.
07:19:50 <quicksilver> bsdemon: there is not much, in general, about GHC extensions.
07:19:55 <quicksilver> bsdemon: :(
07:20:06 <quicksilver> bsdemon: the user manual has at least a brief description of most of them.
07:20:29 <quicksilver> bsdemon: please don't use Overlapping or IncoherentInstances ;)
07:20:46 <bsdemon> ok, is there list of extensions, that are safe to use?
07:22:41 <killerstorm2> @djinn-add data Tree4 a = Leaf a | QTuple (Tree4 a) (Tree4 a) (Tree4 a) (Tree4 a)
07:22:42 <lambdabot> Error: Recursive types are not allowed: Tree4
07:24:01 <pozic> bsdemon: it depends on what you mean by safe.
07:24:23 <pozic> bsdemon: nobody knows what will happen with Haskell compilers in 20 years for example.
07:24:31 <bsdemon> :) ok
07:24:33 <pozic> bsdemon: of course the same holds for C#3.0
07:24:42 <soupdragon> @djinn-add data Tree4 tree4 a = Leaf a | QTuple (tree4 tree4 a) (tree4 tree4 a) (tree4 tree4 a) (tree4 tree4 a)
07:24:43 <lambdabot> Error: cyclic kind
07:24:46 <pozic> See Visual Basic horror stories.
07:24:59 <spb-vlan> quicksilver: i feel that traverse is in some sense similar to >>=. although it could be defined using functions with simpler types (join and sequenceA, respectively), it is sometimes easier to define traverse, not sequenceA in instances
07:25:08 <pozic> If you want to be "safe", you write your own Forth, and you compile from Haskell to Forth.
07:25:36 <pozic> Then you build your own microchip and own factories and buy enough sand ;)
07:26:20 <pozic> See, you depend on a _lot_ of infrastructure, so do not think you can be completely independent with current levels of technology sharing.
07:26:21 <CalJohn> @google reduceron
07:26:23 <Gracenotes> djinn is to do with finding proofs in a logic. Once you find the proof, you find the implementation. Unfortunately, recursive types require a different sort of logic... although I think it is still implementable
07:26:23 <lambdabot> http://www.cs.york.ac.uk/fp/reduceron/
07:26:24 <lambdabot> Title: The Reduceron
07:26:44 <hackagebot> comonad-random 0.1.0 - Comonadic interface for random values (JakeMcArthur)
07:26:44 <pozic> CalJohn: there is a successor to the reduceron.
07:26:53 <quicksilver> spb-vlan: sequenceA is only very slightly simpler, but yes, I agree with your intuition.
07:27:03 <quicksilver> spb-vlan: maybe sequenceA is better seen as the primitive here.
07:27:12 <quicksilver> spb-vlan: traverse is to sequenceA as mapM is to sequence.
07:27:12 <CalJohn> pozic: is there?  as far as I can see the research is still going on
07:27:33 <pozic> CalJohn: Reduceron II exists, AFAIK and maybe they even continued.
07:28:05 <CalJohn> I'm not sure what you mean by "continued" - they are currently continuing
07:28:44 <pozic> CalJohn: ok, I think this is a new website.
07:29:00 <pozic> CalJohn: so, this is the continuation, as a Reduceron already existed a few years ago.
07:29:30 <CalJohn> pozic: yes, it was someones PhD thesis.  now it is someones research project
07:29:30 <spb-vlan> quicksilver: ok,thanks a lot! i'll try to write the instances for [] and Maybe on paper :)
07:29:47 <CalJohn> i think the research project ends in december or something, and they're planning to publish then
07:30:24 <pozic> Do they already implement mutable instructions?
07:30:49 <CalJohn> I'm not sure
07:48:28 <desp> @hoogle (a -> b) -> f a -> b
07:48:29 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:48:29 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
07:48:29 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
07:48:45 <desp> @hoogle (Functor f) => (a -> b) -> f a -> b
07:48:46 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
07:48:46 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
07:48:46 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
07:51:06 <Petrosian> Does anyone know anything about lexing/parsing indentation based languages?
07:51:24 <Petrosian> Specifically, what the rules are for inserting "}" and";" tokens into the stream
07:52:20 <Botje> indent stays the same: ; indent goes down, } ?
07:52:41 <Petrosian> Botje: That was my conclusion, seemed a little too simple tho'!
07:55:18 <quicksilver> that's basically it.
07:55:27 <quicksilver> I'm not sure about "indentation based languages" as a group, though
07:55:32 <quicksilver> I think haskell's rules are unique
07:55:35 <pikhq> I seem to recall that Python, at least, had the lexer add ADDINDENT and DELINDENT tokens.
07:55:40 <quicksilver> (I don't think they are the same as python's, say)
07:56:01 <Petrosian> Right, well it's for Haskell, so that's no issue
07:57:00 <Petrosian> So, to verify...
07:57:06 <Petrosian> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7265 Something like that looks reasonable?
07:58:20 <Petrosian> Hmm, not sure why hpaste has decided to squish it into that scrollbox...
08:02:29 <Botje> squishy squishy!
08:02:53 <hackagebot> fsmActions 0.3.0 - Finite state machines and FSM actions (AndyGimblett)
08:03:15 <dhun> where can I find the type definition of the bind operator of the state monad?
08:03:28 <quicksilver> Petrosian: why would a desugarrer add } but not { ?
08:04:20 <quicksilver> dhun: "type definition" ?
08:04:32 <dhun> what comes after ::
08:04:34 <WaGE> question for anyone who has a good amount of experience with lisp: I've often heard of lisp programmers writing programs that in turn write other programs / functions themselves. I believe its because everything in Lisp is a list and peicing together code this way is quite natural. Can haskell do something like this as well?
08:04:38 <quicksilver> :t (>>=)
08:04:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:04:47 <dhun> thanks
08:04:49 <quicksilver> dhun: it's that, with "m" replaced by State s
08:05:05 <quicksilver> >>= :: State s a -> (a -> State s b) -> State s b)
08:05:13 <Petrosian> quicksilver: Ah, ye, missed that one out by mistake. Focusing on "}" and ";" too much
08:05:29 <quicksilver> Petrosian: the tricky cases are where you have to introduce two (or more) ; at once
08:05:40 <quicksilver> Petrosian: sorry, two or more }, I mean.
08:05:52 <Petrosian> quicksilver: Can it be done in a single pass?
08:05:57 <quicksilver> yes.
08:06:00 <Petrosian> Easily? :P
08:06:05 <quicksilver> subjective.
08:06:09 <quicksilver> I would say "no".
08:13:23 <Saizan> WaGE: there's template-haskell for that, though it's not quite so easy to use
08:14:03 <WaGE> Saizan: thanks
08:16:08 <quicksilver> WaGE: although you don't need TH to piece together a function
08:16:14 <quicksilver> you can piece together a function using (.)
08:16:26 <quicksilver> and more generally, you can piece together programs using similar combinators.
08:16:38 <quicksilver> this is not the same as real metaprogramming
08:16:44 <quicksilver> but it is very powerful and often is enough.
08:16:51 <desp> @hoogle Foldable t => [a] -> t a
08:16:52 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
08:16:53 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
08:16:53 <lambdabot> Distribution.Simple.PackageIndex Ambiguous :: [a] -> SearchResult a
08:17:10 <quicksilver> desp: can't be done.
08:17:26 <quicksilver> desp: Foldable contains no information about how to construct one.
08:17:28 <desp> Yeah.
08:17:36 <quicksilver> none of the Foldable methods let you build new Foldables.
08:17:40 <desp> I'm trying to understand how Zippable works.
08:17:51 <desp> http://www.mail-archive.com/haskell-cafe@haskell.org/msg62427.html
08:17:52 <quicksilver> by defining exactly the method it needs.
08:18:01 <quicksilver> I'm not sure it's any better than my generic traversable one
08:18:06 <quicksilver> apart from the error checking, perhaps.
08:20:25 <desp> Oh, now I see it.
08:22:09 <kevink> Hi, anyone available to help me with some Control.Monad.Reader issues?
08:23:17 <Baughn> "emember that comments take up space in compiled Haskell programs, and furthermore they take up processing time if execution passes through them. For these reasons, keep comments to a minimum, and never put comments inside of optimized Haskell code. Ideally all of your comments will lie outside of the path of execution."
08:23:47 <Phillemann> Absolutely.
08:24:48 <Vanadium> Baughn: Where is that from?
08:25:00 <Baughn> Vanadium: http://cadie.googlecode.com/svn/trunk/INTERCAL-style-guide.html, sort of.
08:25:05 <Vanadium> Aah
08:25:39 <Baughn> It's the official Google INTERCAL style guide.
08:26:10 <Vanadium> What does cadie know of proper style~
08:30:39 <desp> @pl fmaps fs a = fmaps (toList fs) a
08:30:40 <lambdabot> fmaps = fix (. toList)
08:31:06 <desp> @pl funzip a = (fmap fst a, fmap snd a)
08:31:07 <lambdabot> funzip = ap ((,) . fmap fst) (fmap snd)
08:31:14 <desp> Nah.
08:45:05 <Beelsebob> desp: fmap fst &&& fmap snd
08:49:34 <eflister> hi - i'd like to make a version of Data.Function.on that can operate on two values of different types, as long as they both instantiate some class that provides a method compatible with the supplied functions.  that is, (K a1, K a2, K a3) => (b -> b -> c) -> (a3 -> b) -> a1 -> a2 -> c, as long as some K satisfies this type.  is this possible?  it seems something like existential types, but it's an existential class.
08:49:37 <byorgey> @remember Baughn remember that comments take up space in compiled Haskell programs, and furthermore they take up processing time if execution passes through them. For these reasons, keep comments to a minimum, and never put comments inside of optimized Haskell code. Ideally all of your comments will lie outside of the path of execution.
08:49:38 <lambdabot> It is stored.
08:50:03 * Baughn meeps
08:51:20 <byorgey> eflister: I don't know how such a class would work.  I think perhaps what you want instead is a multi-param type class:  class K a1 a2 a3 where foo :: (b -> b -> c) -> (a3 -> b) -> a1 -> a2 -> c
08:52:44 <byorgey> eflister: if you really mean what you wrote then you have to figure out what method K would provide which you could use to write something of type  (b -> b -> c) -> (a3 -> b) -> a1 -> a2 -> c.
08:52:50 <byorgey> but I don't see how such a thing is possible.
08:53:50 <RayNbow> twanvl++
08:53:51 <sdg0sdg09sdug0s9> @djinn (b -> b -> c) -> (a3 -> b) -> a1 -> a2 -> c
08:53:52 <lambdabot> -- f cannot be realized.
08:53:53 <RayNbow> @karma twanvl
08:53:54 <lambdabot> twanvl has a karma of 3
08:54:11 <sdg0sdg09sdug0s9> @djinn (b -> b ->  c) -> (a3 -> b) -> a1 -> a2 -> c
08:54:11 <lambdabot> -- f cannot be realized.
08:54:14 <eflister> byorgey: an example would be wanting to call (+) on two Integrals that aren't necessarily of the same type.  i want to use `on` in cases like this without having to prespecify `+` and Integral in this case, and not have to have the arguments in any specific order.
08:54:15 <quicksilver> eflister: what you want is something liek generalised higher rank unification.
08:54:21 <quicksilver> eflister: it's undecidable.
08:54:32 <LeoD> sdg0sdg09sdug0s9: where's the a3 supposed to come from?
08:54:42 <quicksilver> although you may be able to identify a decidable fragment for a class of circumstances
08:54:43 <sdg0sdg09sdug0s9> how should i know
08:54:47 <sdg0sdg09sdug0s9> ;)
08:54:50 <LeoD> :p
08:55:05 <sdg0sdg09sdug0s9> carried in by a pelican
08:55:11 <sdg0sdg09sdug0s9> or a stork, i suppose
08:55:11 <LeoD> hah
08:55:41 <byorgey> "daddy, where do a3's come from?"  "oh, um, a3's?  well... erm... "
08:57:33 * sdg0sdg09sdug0s9 blushes
08:59:21 <jmcarthur_work> is it worth ANNouncing small packages (one module, one type, six functions, four instances) on the mailing lists, or would it be less annoying to only ANN larger projects?
08:59:29 <eflister> quicksilver: does the example i gave clarify it?  it seems decidable to check for classes implemented by a1, a2, and a3 that also have functions a3 -> b
09:00:44 <eflister> does djinn handle class constraints?
09:01:03 <eflister> @djinn (Integral a) => a -> a -> a
09:01:03 <lambdabot> Error: Class not found: Integral
09:01:27 <eflister> @djinn (Ord a) => a -> a -> a
09:01:28 <lambdabot> Error: Class not found: Ord
09:03:48 <quicksilver> eflister: yes, but in general there are multiple answers.
09:04:06 <quicksilver> eflister: and that's ignoring the fact that your idea makes no sense for haskell typeclasses, which are open :)
09:04:18 <LeoD> @djinn a -> a -> a
09:04:19 <lambdabot> f _ a = a
09:05:01 <Blu3_C4rd> how to get free shell this chan here
09:05:22 <Beelsebob> pardon?
09:05:30 <Beelsebob> english please :)
09:05:33 <soupdragon> Blu3_C4rd: LOL
09:05:54 <Blu3_C4rd> help me pleace
09:06:00 <LeoD> :O
09:06:19 <eflister> quicksilver: but since the a3 -> b function will be specified as an argument, haskell doesn't have to figure out what to call -- it just is supposed to do some type (class) checking for me.
09:06:40 <eflister> quicksilver: doesn't it seem to be in the sprit of `on` and haskell in general?
09:06:50 <eflister> (btw i'm a n00b!)
09:07:14 <sdg0sdg09sdug0s9> http://pugpuppiesforsale.net/wp-content/uploads/2008/05/pug_puppy.jpg
09:07:20 <pikhq> Djinn isn't a mind-reader.
09:07:43 <soupdragon> sdg0sdg09sdug0s9: yuck
09:07:45 <pikhq> Rather, it is, but it's not a very good one. :P
09:07:50 <sdg0sdg09sdug0s9> you don't like those?
09:07:56 <soupdragon> not that one
09:08:00 <sdg0sdg09sdug0s9> i think they're cute
09:08:29 <Beelsebob> that one is pretty ugly
09:08:54 <sdg0sdg09sdug0s9> look at its eyes!
09:09:03 <sdg0sdg09sdug0s9> and its claws, it's still a baby
09:09:15 <Beelsebob> yes, the redness, and droopyness of its eyelids are a lot of what makes it ugly
09:09:21 <sdg0sdg09sdug0s9> i think it's cute
09:09:33 <defun> :t (const id)
09:09:35 <lambdabot> forall a b. b -> a -> a
09:10:01 <defun> > const x y
09:10:06 <lambdabot>   x
09:10:20 <defun> > (const id) x y
09:10:22 <lambdabot>   y
09:10:58 <defun> > const . id $ x y
09:11:00 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> a'
09:11:13 <pikhq> > const . id $ 1 2
09:11:15 <lambdabot>   Add a type signature
09:12:47 <defun> > const (id x) y
09:12:50 <lambdabot>   x
09:13:18 <sdg0sdg09sdug0s9> http://learnyouahaskell.com/dognap.png
09:13:20 <defun> > const id
09:13:22 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a -> a)
09:13:23 <lambdabot>    arising from a use...
09:14:58 <eflister> quicksilver: could you explain what would be undecidable about it?
09:15:07 <defun> why does (const id) yeild the second argument, but not the first arg?
09:15:52 <Beelsebob> defun: (const id) x y ~> (const id x) y ~> id y ~> y
09:16:49 <eflister> byorgey: did the example not address your point?
09:17:05 <BONUS> const id = flip const
09:17:33 <Vanadium> const id is surely faster, because flipping a function sounds like it takes a lot of effort
09:17:46 <Blu3_C4rd> how to get shell account
09:17:50 <Beelsebob> both are one beta reduction
09:17:58 <copumpkin> Blu3_C4rd: you typically pay for one
09:18:02 <eflister> another question i've been having: is there a best practice for expressing functions of two arguments in pointfree style?  the only way i can find involves currying (.) which never seems helpful.  has anyone suggested a $1, $2... syntax ala bash?  not exactly pointfree, but more readable than a lambda.
09:18:22 <copumpkin> eflister: I use (f .) . g
09:18:29 <copumpkin> assuming that's the correct order
09:18:42 <jmcarthur_work> somebody reading an old hacker tutorial?
09:18:54 <copumpkin> lol
09:18:58 <copumpkin> zomg I R HAX)R
09:19:09 <jmcarthur_work> i need shell pleace
09:19:58 <copumpkin> U HAZ SUB7 / backorifice / netbus? I NEED KTHX
09:23:26 <Vanadium> Why are we making fun of shell accounts?
09:24:25 <copumpkin> Vanadium: cause we're prejudiced against random people who join the channel, ask how to get a shell account, with numbers in the place of letters in their nick
09:24:37 <sdg0sdg09sdug0s9> i want a shell account
09:24:54 <copumpkin> sdg0sdg09sdug0s9: nice try but you've already spoken haskell to us :P
09:24:59 <sdg0sdg09sdug0s9> :(
09:25:07 <osfameron> WEN COME BACK BRING SHELL!
09:25:09 <jmcarthur_work> hashell
09:25:19 <sdg0sdg09sdug0s9> there are free shells..but they all suck
09:25:42 <sdg0sdg09sdug0s9> at least every one i've tried
09:25:45 <Vanadium> Oh, I did not catch that he had just joined recently.
09:28:05 <Vanadium> If anyone finds a free shell place that has ghc installed, do let me know :>
09:28:11 <eyeris> Could someone tell me why the type signature changes for a function if I bind it to a sympol? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7268#a7268
09:28:44 <sdg0sdg09sdug0s9> Vanadium: i've seen one i believe
09:28:51 <sdg0sdg09sdug0s9> let me think
09:28:55 <eyeris> Vanadium What do you need it for? Most dev shells have disappeared since VirtualBox, etc became free.
09:29:03 <sdg0sdg09sdug0s9> ^
09:29:36 <Vanadium> eyeris: Just curiosity, really. I figured such a place would come with a functional programming community or similar.
09:30:02 <sdg0sdg09sdug0s9> hmph http://bigkitty.freeshell.org/
09:31:58 <Vanadium> eyeris: That sounds like the monomorphism deal.
09:32:34 <Vanadium> Do not get to bind polymorphic expressions to symbols that do not look like function defintions? eh.
09:33:01 <eyeris> Vanadium then shouldn't let fail?
09:33:59 <BONUS> yeah it's the MR along with defaulting i think
09:34:15 <BONUS> if you do :set -XNoMonomorphismRestriction and try it again, you get the desired result
09:35:09 <eyeris> I see. Thanks.
09:35:24 <BONUS> 90% of the time when point-free functions with class constraints on type variables act strangely, it's the monomorphism restriction
09:36:09 <Vanadium> I figured ghci(?) tried to do the simplest thing that would possibly work :V
09:36:34 <BONUS> it defaulted the Show a => a type to ()
09:36:42 <BONUS> just like it sometimes defaults Num a => a to Int
09:36:47 <BONUS> that's part of H98 i think
09:36:51 <Vanadium> Oi
09:37:07 <doserj> defaulting to () is a ghcism, not really H98
09:37:13 <BONUS> ah rly?
09:38:31 <doserj> "default" defaulting is (Integer,Double). ghci does (Integer,Double,())
09:38:45 <quicksilver> only wiht -fextended-defaulting
09:38:48 <quicksilver> or whatever it's called.
09:38:57 <quicksilver> and it also increases the typeclasses for which defaulting is allowed.
09:39:44 <BONUS> does ghci first try Integer or ()?
09:40:07 <BONUS> if you do > read "13" in ghci you get a no parse error, but if you do > read "()" it defaults it to type ()
09:40:36 <doserj> ah, yes. it does ((),Integer,Default)...
09:40:51 <doserj> err, ((),Integer,Double)...
09:41:55 <gwern> hm. does anyone know what the rule of thumb in UI design which says that mouse users can only reliably hit 4 points on the screen - the corners. it was something like Fit's law, iirc
09:42:11 <BONUS> fitt's law
09:42:51 <esap> http://en.wikipedia.org/wiki/Fitts%27s_law
09:42:53 <gwern> ah, so it is
09:43:04 <gwern> I wonder why Fit's law didn't turn up anything useful in WP search
09:43:05 <quicksilver> unless they use window managers which map the corners of the screen to flip virtual desktop
09:43:26 <BONUS> i wonder how he came up with T = a + b * log (1 + D/W)
09:43:28 <Vanadium> Then they only have themselves to blame
09:43:33 <quicksilver> then they have to learn to hit other areas of they just fly all over the palce
09:43:41 <Vanadium> Also more mouse users need to be trained with FPSes
09:45:36 <lilac> BONUS: i think there was science involved :)
09:45:51 <BONUS> i hope so!
09:46:16 <gwern> your cookiees. give me. I will do science on them.
09:47:16 <Vanadium> Ooh, webcomics.
09:47:23 <BONUS> it could be one of those ad hoc things like the amdahl-case rule
09:48:01 <gwern> I sometimes wonder how desden codak survives, updating only every couple of months
09:48:28 * Saizan wants to overload "="
09:48:36 <Saizan> semicolons are not enough!
09:49:41 <BONUS> i made a transformer version of sigfpe's penalty monad. turns out it's horribly unlazy for most underlying monads :[
09:50:34 <hzap> what's a penalty monad?
09:50:36 <Saizan> how did you implement it?
09:50:47 <Saizan> like ListT or ListT_done_right ?
09:51:04 <BONUS> hmm there's a ListT done right? link
09:51:19 <gwern> ...someone sends a message, in english, to the english -cafe, about his icfp writeup - in portuguese
09:51:21 <BONUS> hzap: http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html
09:51:28 <Saizan> ?wiki ListT done right
09:51:29 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
09:51:42 * gwern is missing something here. did he translate his original portuguese email into english? that'd be consistent
09:52:25 <BONUS> this is my implementation (excuse the ugly): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7270#a7270
09:53:11 <BONUS> yeah looking at it now it seems i did it more in the way of ListT
09:53:17 <BONUS> wish i'd known about the done right version earlier
09:53:31 <hzap> BONUS: thanks
09:54:00 <Saizan> there's also a recent oleg paper about lazyness and backtracking
09:54:43 <BONUS> wow, making this unlazy version was pretty challenging, combining it with this new ListT would be interesting
09:56:00 <ski> (Saizan : overload `=' for what ?)
09:57:13 <desp> Can someone help me with a type family problem?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7271
09:57:29 <desp> "Illegal type synonym family application in instance"
09:58:28 <desp> That's not a very helpful message.
10:00:48 <Saizan> (ski: because i'm making an edsl based on declaring some function to be memoized, and i need to collect the types of such functions up front so i can deserialize the memomap from disk)
10:01:09 <pikhq> gwern: Presumably by living on SCIENCE!
10:01:09 <pikhq> (also cookies)
10:01:25 <gwern> cookies made - via SCIENCE
10:01:43 <Saizan> (it'd be like a form of staging i think..)
10:01:52 <gwern> stand back everyone! I have regexp cookiees
10:02:24 <desp> Saizan: can I has helpful advice?
10:02:25 <desp> :)
10:02:47 <Saizan> desp: i don't guarantee on helpful :)
10:03:09 <Saizan> (s/some function/some functions/)
10:03:16 <BONUS> does TypeSynonymInstances carry over to type families?
10:03:33 <BONUS> e.g. does it enable you to make type families instances of typeclasses
10:03:46 <Saizan> i'd be very surprised
10:03:54 <BONUS> yeah me too
10:04:19 <kulakowski> urlLauncher: firefox
10:04:22 <kulakowski> gah
10:05:33 <desp> I thought there might be a way to write this using the ~
10:06:01 <Saizan> oh, i didn't see you already pasted your problem
10:06:14 <desp> instance (TypeNat a, TypeNat b, a :+: b ~ c) => TypeNat c
10:06:18 <desp> But this also errors
10:06:24 <desp> "Type constructor `:+:' used as a class"
10:07:05 <Saizan> with paretheses?
10:07:23 <SamB> put parens around (a :+: b) ?
10:07:42 <Saizan> however, why you want such an instance? the ones for S a and Z should already cover all the relevant types
10:07:57 <Badger> @src (:+:)
10:07:58 <lambdabot> Source not found. Maybe if you used more than just two fingers...
10:08:02 <desp> Huh
10:08:02 <desp> instance (TypeNat a, TypeNat b, (:+:) a b ~ c) => TypeNat c
10:08:04 <desp> This works
10:08:10 <Badger> @hoogle (:+:)
10:08:11 <lambdabot> Did you mean: :+: a a /count=20
10:08:11 <lambdabot> Prelude undefined :: a
10:08:11 <lambdabot> Data.Array.Base arrEleBottom :: a
10:08:19 <desp> Looks like TypeOperators does not reach that far!
10:08:24 <desp> Badger: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7271
10:08:31 <Badger> ah
10:08:37 <Saizan> instance (TypeNat a, TypeNat b, (a :+: b) ~ c) => TypeNat c ?
10:08:46 <desp> Saizan: yep, that works.
10:08:51 <desp> Wait...
10:09:05 <desp> Oh, that works as well.
10:09:06 <desp> :)
10:09:31 <gwern> ok, I just freed up 5 gigs of hard drive space. maybe now I have enough space to compile highlighting-kate, pandoc, and gitit!
10:09:45 <deech> Hi, I had a question about functional dependencies. On the HaskellWiki page presents the following example: "class Mult a b c | a b -> c where ..." and says that c is uniquely determined from a *and* b. But it seems that c is uniquely determined by a *or* b. Is this correct?
10:09:54 * gwern kids. I will of course have to remove all the intermediates for each one, lest I fill up my hard drive
10:10:06 * mux really doesn't like System.IO lying about file sizes & offsets being Integer
10:10:23 <BONUS> c is uniquely determined by a and b. meaning that for every combination of a and b, there can only be one c
10:10:55 <BONUS> so you can do instance Mult Int Int Float but once you've done that you can't do instance Mult Int Int Int
10:11:07 <deech> BONUS, ah I get it! Thanks!
10:11:08 <BONUS> but you can do instance Mult Int Float Double or whatever
10:11:21 <BONUS> :]
10:11:26 <Saizan> BONUS: ? i think you flipped some arguments there
10:11:32 <BONUS> where
10:11:32 <desp> Saizan: but that does not help for (:-:)
10:11:54 <Saizan> BONUS: ah, no i misparsed :)
10:11:59 <burp> Mult Float Int Float ; Multi Int Float Float <- does that work with | a b -> c?
10:12:02 <desp> Saizan: when I try doing the same for another type function, I get a duplicate instance error.
10:12:09 <BONUS> yeah it does
10:12:11 <burp> ok
10:12:18 <desp> Saizan: you were saying that all the relevant types are covered...
10:12:38 <desp> Saizan: I'm showing this simple part of my code; if you have a moment to dig in, you could take a look at the actual problem?
10:12:57 <Saizan> desp: ok
10:13:47 <desp> Saizan: in http://varsztat.com/physics/Vector.hs, line 64, I don't understand why I have to provide  TypeIntList (ZipWithAdd xs ys)  in the context.
10:13:56 <Saizan> desp: well, the types are only (S a) and Z, though i guess you might have a need from TypeNat (a :+: b) without being able to reduce that to anything of that form?
10:14:09 <desp> Saizan: all the relevant modules are in that directory.
10:15:16 <desp> All the code typechecks and should work, as well. :)
10:15:43 <lilac> does 'instance (TypeNat a, TypeNat b, (a :+: b) ~ c) => TypeNat c' really work? and if so, how?
10:15:54 <lilac> does GHC search for types a and b which add to c?
10:16:39 <Saizan> lilac: that's what i wondered too
10:17:28 <desp> lilac: I'm not sure at all.
10:17:37 <lilac> also, doesn't that overlap /itself/?
10:17:38 <desp> lilac: I'm not using that yet.
10:18:08 <lilac> since a ~ Z, b ~ S (S Z) and a ~ S Z, b ~ S Z both match for C ~ S (S Z)
10:18:13 <lilac> s/C/c/
10:21:21 <FliP^2eH> Say I'd send something to a server, and it returns some binary chunks, including zero terminated strings..
10:21:26 <FliP^2eH> How'd I read it in?
10:23:12 <Saizan> desp: i'm not sure how that instance should work, the result type should involve Vector or not?
10:25:20 <desp> Saizan: no, the result type should be just a Quantity
10:25:28 <desp> Saizan: look above, type instance Vector d (Quantity xs) :*: Vector d (Quantity ys) = Quantity xs :*: Quantity ys
10:25:49 <Samy> @seen vixey
10:25:50 <lambdabot> I saw vixey leaving #haskell, #scala, #perl6 and ##logic 6m 6d 17h 24m 20s ago, and .
10:25:52 <desp> That instance is dot product.
10:25:54 <Samy> Wow.
10:25:59 <Samy> Hope she's alright.
10:26:18 <BONUS> 6 months?
10:26:31 <Saizan> desp: ah, now i see, i was confused by foldr, well TypeIntList comes out of the instance Num (Quantity xs), no?
10:26:39 <BONUS> i think i saw her here in the last few months
10:27:09 <Saizan> and type instance Quantity xs :*: Quantity ys = Quantity (ZipWithAdd xs ys)
10:28:19 <sdg0sdg09sdug0s9> http://bob.freeshell.org/html_save/me_07042000.jpg
10:28:42 <desp> Saizan: so you're saying that I should expect to have to specify the context here?
10:28:42 <BONUS> cool bro
10:28:59 <desp> Saizan: what's confusing me is that I don't have to do so for the other instances just below.
10:30:39 <jmcarthur_work> most informal announcement ever... a link to the docs in irc: http://hackage.haskell.org/packages/archive/comonad-random/0.1.0/doc/html/Control-Comonad-Random.html
10:31:01 <Samy> sdg0sdg09sdug0s9, heh
10:31:15 <desp> sdg0sdg09sdug0s9: uh, what?
10:31:55 <Saizan> desp: do you have a Mulable (Quantity xs) (Quantity ys) instance somewhere?
10:32:14 <desp> Saizan: yes, in Quantity.hs, line 88
10:32:21 <sdg0sdg09sdug0s9> what?
10:34:20 <Saizan> desp: ok, since that doesn't require any context on xs and ys, you don't have to add anything to the Mulable Vector Quantity or Mulable Quantity Vector instances, because you only use Mulable Quantity Quantity and Functor Vector (discarding the parameters for conciseness)
10:35:12 <Saizan> desp: it's the use of (+) and 0 that requires the TypeIntList context
10:37:39 <Saizan> desp: does that make sense?
10:38:21 <desp> Saizan: it does.  Is there a general way to say that results of ZipWithAdd on TypeIntLists should be also TypeIntLists?
10:38:46 <desp> Saizan: that's what I was trying to do earlier.
10:41:01 <Saizan> so you want to be able to deduce TypeIntLists (ZipWithAdd xs ys) from (TypeIntLists xs,TypeIntLists ys)?
10:41:15 <desp> Yes.
10:41:50 <desp> Which would allow me not to have to specify that context we've just discussed, right?
10:42:14 <Saizan> you'd have to specify (TypeIntLists xs,TypeIntLists ys)
10:42:34 <desp> Ah, right.
10:42:58 <soupdragon> TypeIntLists??
10:43:05 <soupdragon> what are you doing?
10:43:19 <desp> soupdragon: physics with units in the type system; http://varsztat.com/physics/
10:43:42 <soupdragon> I though they already did that
10:44:06 <desp> They did, but not taking into account vector quantities, AFAIK.
10:44:23 <soupdragon> did you take these photographs?
10:44:29 <desp> Yeah.
10:44:44 <soupdragon> I like them
10:45:08 <desp> Thanks.  I should reupload them, now that tumblr allows higher-res.  Taken with my cell phone.
10:46:05 <FliP^2eH> No answer yet :(
10:46:14 <FliP^2eH> I want to read a binary stream, how'd I do it?
10:46:23 <FliP^2eH> In C I could just read it into a struct and be done
10:46:42 <Saizan> use Data.ByteString.hGetContents or similar and parse it
10:47:02 <Saizan> maybe using the Data.Binary.Get monad
10:47:06 <pikhq> FliP^2eH: Note: that technique is horribly non-portable in C.
10:47:15 <desp> And unsafe.
10:47:36 <pikhq> Byte orders change. Type sizes change.
10:47:36 <FliP^2eH> Of course, I'm not coding in C anyways
10:47:41 <FliP^2eH> Just as a demonstration
10:47:56 <pikhq> It's a demonstration of horrible C.
10:48:21 <Vanadium> /var/log/lastlog does not change :|
10:48:51 <Randroid> pikhq: It depends on whether you care that your app is portable or not. Not all C has to be portable.
10:49:33 <desp> Saizan: poke? :)
10:50:23 <desp> Saizan: just wondering if it's possible to do such a deduction.
10:50:30 <Saizan> desp: well i guess the only way is to write an instance like you were trying for :+: and see if it works
10:50:53 <desp> The problem with that was again, overlap.
10:51:16 <desp> Oh well.
10:51:18 <Saizan> it does overlap with any other instance, right
10:51:27 <desp> I'm very satisfied with this code now.
10:51:37 <desp> I should just add proper TypeInt division instead of Half.
10:52:01 <desp> And also some way to do exponentiation on quantities...
10:52:08 <desp> Saizan: what do you think about the code in general?
10:53:14 <Saizan> desp: i'd have to play with it a little to comment :) some examples would help
10:53:22 <desp> Saizan: have you seen Physics.hs?
10:54:42 <Saizan> desp: oh, it looks nice
10:55:27 <Saizan> desp: the inferred types are horrible though :\
10:55:33 <desp> I know...
10:56:10 <desp> Maybe if GHCI was able to inteligently choose the type for display?
10:56:35 <desp> Not sure how that'd work, the most concise textually?
10:58:28 <lilac> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7275 -- type system: broken! mwahahaha
10:58:32 <MyCatVerbs> desp: it picks anything it can unify with a Show instance.
10:58:55 <MyCatVerbs> desp: or do you mean intelligently selecting type synonyms?
10:58:56 <Saizan> MyCatVerbs: we're talking about the types themselves
10:59:15 <desp> Saizan: oh, but I have a nice Show instance.
10:59:22 <lilac> looks like it's this bug: http://hackage.haskell.org/trac/ghc/ticket/1496
10:59:25 <MyCatVerbs> Oh, the latter. I think expanding all the synonyms fully is probably a good idea in that case.
11:00:24 <desp> Saizan: I mean,  orbitV earthM (2 * earthR)  ->  5612.246435422386 [1,0,-1]
11:00:36 <Saizan> desp: btw, you use only units of measure, i'd have it distinguish between physical quantities and then units instead
11:00:39 <desp> Saizan: so if you can't read the inferred type, at least you can write a type afterwards.
11:00:42 <MyCatVerbs> Otherwise you run the risk of using more than three type synonyms in a row and then swearing at the computer a lot because the data structure has a different shape than you expected it to be. You would swear *more* if GHCi went and hid the expansion by printing it in terms of the synonyms.
11:01:09 <desp> MyCatVerbs: maybe as an option? :)
11:02:10 <desp> Saizan: could you give an example?
11:02:26 <lilac> yay, ghci segfaulted :)
11:07:10 <Berengal> Anyone here use tabs for indenting in haskell at all?
11:07:19 <pikhq> Does Emacs?
11:07:36 <Berengal> No, I'm pretty sure emacs uses spaces
11:07:44 <pikhq> Then no.
11:07:49 <soupdragon> I use the tab BUTTON for indent
11:08:00 <soupdragon> it inserts spaces though
11:08:04 <Nebasuke> same here
11:08:11 <Berengal> Well, the tab button is something completely different from the tab character
11:08:15 <mikesteele81> pikhq: emacs uses tabs by default.  I put this in my .emacs file: (setq-default indent-tabs-mode nil)
11:08:54 <Berengal> mikesteele81: huh, you're right. I've got that too
11:09:03 <Berengal> Just didn't know it...
11:09:21 <Berengal> Does haskell-mode use tabs too?
11:10:53 <mikesteele81> IIRC haskell-mode uses a mixture unless you explicitly turn off tab characters.
11:15:05 <Oejet> How come hscairo is not on Hackage?
11:17:51 <dons> Oejet: cairo is part of gtk2hs, which isn't cabalised.
11:21:47 <FliP^2eH> Any Tutorials for UDP Sockets?
11:21:53 <Oejet> dons: Ah, so it is typically an OS package. Thanks.
11:22:00 <dons> right
11:22:07 <dons> pacman -S gtk2hs -- on Arch Linux
11:22:21 <benmachine> why isn't it cabalised?
11:22:29 <benmachine> just lacking someone to do it?
11:22:49 <byorgey> no, cabal doesn't have the necessary features yet
11:23:12 <desp> Is there anything I can do about orphan instances?
11:23:21 <byorgey> specifically with respect to the quite complicated schemes gtk2hs uses to autogenerate FFI code, IIRC
11:23:42 <dcoutts> byorgey: and gtk2hs needs to get back to using the mainline version of c2hs
11:23:55 <byorgey> desp: it's sad, isn't it?  we need more people willing to adopt
11:24:16 <byorgey> ah, I didn't realise that was an issue too
11:24:23 <desp> :)
11:30:45 <lilac> hah, casting []'s >>= to the type of Maybe's >>= gives me a working(-ish) bind!
11:31:21 <Berengal> lilac: casting as in unsafeCoerce?
11:31:36 <lilac> Berengal: casting as in this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7275
11:31:49 <lilac> (but yeah, it's effectively unsafeCoerce)
11:32:22 <lilac> type families + generalized newtype deriving = unsound type system, sadly
11:32:53 <Berengal> Ah, yes, the bug
11:33:04 <Berengal> I was just thinking about that in the car on my way home from work today
11:33:22 <byorgey> yikes!
11:33:33 <lilac> i'm in favour of the 'ghc generates and typechecks the instance, then throws it away' fix
11:34:40 <lilac> it seems like GADTs + generalized newtype deriving should allow building cast too, but i can't see how :-/
11:35:54 <Berengal> I found it somewhat amusing that being able to prove 1 = 0 through some obscure proof using two experimental features of the language is the cause of much concern in Haskell, but the same can be done in java using features of the language...
11:35:56 <byorgey> GADTs are strictly less powerful than type families, I think
11:36:07 <byorgey> but I wouldn't be able to actually give details on that.
11:36:42 <lilac> byorgey: http://hackage.haskell.org/trac/ghc/ticket/1251
11:37:42 <jmcarthur_work> is it an implementation or semantic bug?
11:38:09 <lilac> jmcarthur_work: as i understand it, it's a semantic bug in the definition of generalized newtype deriving
11:38:16 <jmcarthur_work> ah
11:39:02 <lilac> in the case of newtype B = B A, generalized newtype deriving doesn't just expose an isomorphism between A and B, it introduces an "isomorphism" between f A and f B, for all f
11:39:38 <jmcarthur_work> yeah i remember following some of that on the mailing list
11:39:40 <lilac> if 'f' is not an algebraic functor, that leads to Not Good
11:39:48 <jmcarthur_work> i wasn't sure whether we were talking about the same thing
11:52:29 <FliP^2eH> Not in scope: `getAddrInfo'
11:52:32 <FliP^2eH> Any fix for this yet?
11:52:38 <FliP^2eH> Still fails under windows
11:54:01 <saml> what's getAddrInfo?
11:54:17 <FliP^2eH> getAddrInfo :: Maybe AddrInfo -> Maybe HostName -> Maybe ServiceName -> IO [AddrInfo]
11:54:27 <FliP^2eH> Resolves a hostname
11:54:32 <FliP^2eH> That's one of it's uses
11:54:37 <FliP^2eH> Network.Socket, sorry
11:54:39 <saml> which mmodule?
11:54:48 <lilac> hmm, GHC still checks that irrefutable patterns match in -O2 builds
11:54:51 <FliP^2eH> It works on Linux
11:54:57 <FliP^2eH> But not on Windows
11:55:03 <FliP^2eH> http://trac.haskell.org/network/ticket/5
11:55:13 <FliP^2eH> I just wonder if there's news on that already
11:55:51 <saml> FliP^2eH, i use windows, i confirm that bug
11:56:16 <FliP^2eH> I just need a way to resolve a Hostname to an IP
11:56:24 <dolio> GADTs are different than type families.
11:57:56 <saml> FliP^2eH, do you have AddrInfo?
11:58:02 <FliP^2eH> Let me see
11:58:13 <FliP^2eH> Nope
11:58:26 <saml> then how would you use getAddrInfo?
11:58:34 <saml> getAddrInfo :: Maybe AddrInfo ....
11:58:54 <FliP^2eH> getAddrInfo Nothing "google.com" Nothing
11:59:01 <FliP^2eH> Supply it with the hostname and receive the IP
11:59:15 <FliP^2eH> Just "google.com"
11:59:37 <FliP^2eH> getAddrInfo Nothing (Just "google.com") Nothing
12:04:40 <FliP^2eH> This is really bad, I can ONLY use the high level Network module if I don't know the IP address
12:04:50 <FliP^2eH> I can only supply Hostnames to the connectTo function
12:05:07 <FliP^2eH> Because that one strangely CAN resolve
12:06:54 <Saizan_> i think connectTo also accepts an IP in xxx.xxx.xxx.xxx form
12:07:09 <FliP^2eH> "the module Network.Socket provides 'getaddrinfo' only if IPv6 support is enabled. "
12:07:19 <FliP^2eH> How do I enable IPv6?
12:08:37 <LuisaM> hey there
12:08:46 <LuisaM> do you guys know something called hlint?
12:08:54 <jmcarthur_work> yup
12:08:55 <LeoD> yea
12:09:13 <LuisaM> cool! do you guys know if there's an executable for that?
12:09:13 <Philonous> Is there a comprehensive documentation of ghc's arrow notation? I'd like to know especially what exactly the "special brackts" (|... |) and the rec keyword do.
12:09:29 <LeoD> hrm, i think i installed it using cabal install hlint
12:09:30 <Vulpyne> Anyone tried to compile a recent snapshot of GHC? I'm having a problem where it can't find GHC.IO.Handle.FD.
12:09:31 <jmcarthur_work> LuisaM, you can't just use cabal?
12:10:10 <LuisaM> well, I can't
12:10:24 <LuisaM> I know that cabal is like a repository for haskell stuff, right?
12:10:34 <jmcarthur_work> cabal is a build system, hackage is a repository
12:11:06 <LuisaM> can I install it easily in ubuntu?
12:11:16 <soupdragon>  yes
12:11:19 <LuisaM> I'm new in Linux and programming (learning C and haskell)
12:11:37 <jauaor> hi LuisaM
12:11:45 <mornfall> LuisaM: Skip C, go straight to Haskell. ]:-)
12:11:52 <jauaor> LuisaM: hablas español?
12:11:55 <jmcarthur_work> LuisaM, if you have installed ghc, you can download and untar http://hackage.haskell.org/packages/archive/hlint/1.6.4/hlint-1.6.4.tar.gz, then do runhaskell Setup confgure && runhaskell Setup build && runhaskell Setup install
12:12:16 <jmcarthur_work> you may be able to get cabal-install installed, which would be nicer
12:12:22 <jmcarthur_work> then you could just say: cabal install hlint
12:12:29 <mornfall> Yes, and bootstrapping cabal-install is fairly easy these days.
12:12:52 <mornfall> Just grab a tarball and run ./bootstrap.sh, it *should* work on a reasonable GHC-enabled system.
12:13:15 <pikhq> On some distros, you can just install cabal-install.
12:13:44 <jmcarthur_work> i doubt ubuntu is one of those
12:13:47 <pikhq> (well... On Gentoo, I set up haskell-overlay and did some keywording of packages)
12:13:59 <mornfall> http://haskell.org/cabal/release/cabal-install-0.6.2/cabal-install-0.6.2.tar.gz this one hopefully
12:14:01 <jmcarthur_work> on arch i can just install it with yaourt
12:14:35 <LuisaM> LuisaM: yo no hablo muy bien en castillano
12:14:53 <mornfall> Yeah, Debian is a few years behind as usual. (But I still use it... it'll eventually get there.)
12:15:05 <LuisaM> jmcarthur_work: thanks for the tips
12:15:09 <mornfall> Actually, it comes with GHC 6.10.3 nowadays (unstable). That's progress.
12:15:12 <FliP^2eH> saml, found a workaround, using Network.BSD and getHostByName
12:15:46 <jauaor> LuisaM: aah ok, hah, sorry, i was just wondering because of your name
12:15:53 <saml> FliP^2eH, ah nice. i was writing createProcess (proc "ping" ["-n", "1", "google.com"])  and parse the output :P
12:16:03 <FliP^2eH> ;)
12:16:28 <FliP^2eH> addr <- getHostByName "google.com"
12:16:28 <FliP^2eH> putStrLn $ show $ hostAddresses addr
12:16:33 <FliP^2eH> [1680702794,1686076746,1682144586]
12:17:25 <FliP^2eH> Just apply inet_ntoa of Network.Socket on it to get the string representatio
12:21:17 <Peaker> FliP^2eH: putStrLn . show . hostAddresses $ addr     -- considered nicer notation, and then you see that   putStrLn . show = print,  so its  print . hostAddresses $ addr
12:21:29 <Peaker> @src print
12:21:29 <lambdabot> print x = putStrLn (show x)
12:22:31 <FliP^2eH> This is why I miss imperative programming sometimes :)
12:22:50 <FliP^2eH> Whatever I'm writing, someone always finds a better way to write the same thing
12:23:16 <BONUS> that's what's awesome about Haskell
12:23:26 <FliP^2eH> Makes me feel stupid
12:23:40 <Peaker> FliP^2eH: there's nothing "stupid" about it, its just a style you learn as you go, and the library you learn as you go
12:23:44 <BONUS> nah, that's a negative way to view it, view it as a learning experience
12:24:14 <BONUS> i'm happy when someone shows me a better way to do something, means i learned something
12:24:18 <LeoD> print should be putStrLn . show :P
12:24:23 <Peaker> LuisaM: I disagree with mornfall, I think its a great idea to also learn C
12:24:48 <Peaker> @type getLine
12:24:53 <Peaker> @type putStrLn
12:24:54 <lambdabot> IO String
12:24:55 <lambdabot> String -> IO ()
12:25:04 <Peaker> Symmetry dictates it should be called PutLine
12:25:10 <Peaker> putLine that is
12:25:11 <FliP^2eH> I'm still trying to decide if Haskell is the right choice for this little project
12:25:30 <Peaker> FliP^2eH: Why not? :)
12:25:33 <FliP^2eH> Querying informations from a HalfLife 2 server
12:25:36 <FliP^2eH> Heavily IO
12:25:44 <FliP^2eH> Much binary crunchung
12:25:59 <Peaker> FliP^2eH: binary crunching is good in Haskell, also heavy IO, so Haskell sounds like a great choice :)
12:26:13 <Vanadium> What other language even has a *type* for IO?~
12:26:23 <BONUS> like the saying goes, haskell is great for writing imperative programs
12:26:25 <FliP^2eH> The type is considered a cage :(
12:26:25 <sdg0sdg09sdug0s9> i think it's just haskell
12:26:28 <BONUS> haha
12:26:28 <sdg0sdg09sdug0s9> BONUS: ?
12:26:45 <thoughtpolice> or: haskell is the finest imperative language there is :)
12:26:45 <sdg0sdg09sdug0s9> what do they call that construct to do imperative programming
12:26:50 <sdg0sdg09sdug0s9> it's a four-letter acronym
12:26:51 <mauke> Peaker: the functions aren't symmetric
12:26:51 <sdg0sdg09sdug0s9> FRP
12:27:01 <Peaker> mauke: why not?
12:27:07 <Oejet> Beelsebob: Do you know the datetime package on hackage? It has some nice utility function for doing time arithmetic.
12:27:16 <Peaker> sdg0sdg09sdug0s9: FRP is about taking the "imperative" out of reactive programming, its very funcitonal
12:27:18 <mauke> Peaker: because putStrLn can output more than one line
12:27:36 <pikhq> thoughtpolice: Haskell is the finest everything.
12:27:49 <Peaker> @type putStrLn
12:27:50 <lambdabot> String -> IO ()
12:27:52 <Peaker> @src putStrLn
12:27:53 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
12:27:53 <mauke> LtU
12:27:53 <mornfall> Peaker: It is good to learn C, but making it the first thing you learn will hinder you needlessly.
12:27:59 <Peaker> mauke: LtU?
12:28:11 <mauke> "lambda the ultimate"
12:28:20 <pikhq> mauke: :D
12:28:27 <mauke> it was triggered by pikhq's comment
12:28:29 <Peaker> mauke: That's true, though its probably kind of nasty to use putStrLn on more than one line
12:28:30 <pikhq> mauke: Only, Monad the Ultimate.
12:28:41 <FliP^2eH> How do I create UDP sockets with the Netork module?
12:28:46 <mauke> Peaker: nah, I do that all the time
12:30:07 <Peaker> FliP^2eH: http://hackage.haskell.org/packages/archive/network/2.2.1.3/doc/html/Network-Socket.html#v%3AsendTo
12:30:16 <Peaker> though it seems to use a String for a packet, which sucks
12:30:31 <FliP^2eH> Mh.
12:30:32 <Peaker> thse use of String instead of ByteString in Network-Socket really sucks, doesn't it?
12:30:41 <Ke> Get your impartial programming language comparisons from #haskell ;o)
12:30:44 <Peaker> mauke: why?
12:31:08 <mauke> Peaker: why not? (see also network-bytestring)
12:31:11 <desp> FliP^2eH: why not Erlang?
12:31:22 <FliP^2eH> I don't want to learn a new language :)
12:31:28 <pikhq> desp: Because Haskell > Erlang.
12:31:58 <Ke> haskell needs a movie as cool as erlang the movie
12:32:01 <soupdragon> Haskell = Erlang
12:32:02 <mornfall> Peaker: I suspect Network is older than ByteString. So some porting work needs to be done...
12:32:09 <desp> pikhq: depends.
12:32:18 <mornfall> ByteString is actually quite new. :)
12:32:38 <benmachine> @faq can haskell beat any other programming language ever in a fair fight?
12:32:39 <lambdabot> The answer is: Yes! Haskell can do that.
12:32:51 <pikhq> soupdragon: Erlang is like Haskell with Concurrent Haskell standardised and without the monads. :P
12:32:53 <Peaker> FliP^2eH: http://hackage.haskell.org/packages/archive/network-bytestring/0.1.2.1/doc/html/Network-Socket-ByteString.html#v%3AsendTo
12:33:04 <desp> pikhq: and without the type system, and...
12:33:06 <mornfall> benmachine: The "ever" part is a little troubling.
12:33:10 <pikhq> Ah, yes.
12:33:15 <pikhq> Also without the lazy semantics.
12:33:21 <mornfall> @faq can haskell decide termination?
12:33:22 <lambdabot> The answer is: Yes! Haskell can do that.
12:33:25 <desp> Also without the nice syntax.
12:33:26 <mornfall> ;)
12:33:29 * copumpkin terminates mornfall
12:33:43 * mornfall reverses copumpkin's arrows.
12:33:56 <desp> But!  With other nice things.
12:33:59 <pikhq> mornfall: Compile "main = main" with ghc and tell me that Haskell doesn't have a halting oracle. :P
12:34:02 <pumpkin> damn
12:34:07 <pumpkin> mornfall: take that back!
12:34:23 <pikhq> desp: Like Concurrent Haskell.
12:34:45 <desp> pikhq: OTP.
12:34:53 <desp> Also, binary sytnax.
12:34:58 * mornfall ponders.
12:35:01 <desp> s/tn/nt/
12:35:11 <Berengal> Also, prologisms
12:35:28 <dolio> Compile 'main = print (sum [1,1..] :: Int)' and tell me that it does.
12:35:28 <pikhq> See, nothing you want.
12:35:29 <pikhq> :P
12:35:58 <balor> Anyone else have an issue with cabal installing happy 1.18.4?
12:36:18 <pikhq> dolio: Obviously, it produces an executable which adds 1 to an accumulator indefinitely.
12:36:18 <desp> pikhq: I use it to earn a living.
12:36:24 <dcoutts> balor: does it fail, or is the problem that it doesn't end up on your path?
12:36:44 <pikhq> desp: Ntohing. You. Want. :P
12:36:56 <desp> Are you saying I should stop living?
12:37:02 <desp> :(
12:37:06 <balor> dcoutts: It throws warnings during install.  The binary is installed in ~/.cabal/bin and I can run happy.  But a cabal list happy shows it as uninstalled.
12:37:29 <dcoutts> balor: ah, that's just because we do not track binaries
12:37:55 <dcoutts> balor: the text for cabal list should be fixed to make it clear that it's installation status is not tracked
12:38:01 <balor> dcoutts: so I shouldn't add happy > x.y.z to my Product.cabal?
12:38:23 <dcoutts> balor: you can use build-tools: happy >= x.y
12:38:42 <dcoutts> balor: but not build-depends, since it's not a library package
12:38:42 <balor> dcoutts: Great.  I was using Build-Depends
12:40:20 <mornfall> But even build-tools won't DWIM, will it?
12:40:24 <mornfall> I mean, not yet.
12:40:29 <mornfall> ;)
12:42:40 <jeffersonheard> okay, here's a new one
12:42:56 <jeffersonheard> user error (Failed to load image '/home/jeff/Desktop/BigBoard/bigboard/cache/3395-1.sid.7_1_3.jpg': reason not known, probably a corrupt image file)
12:43:18 <jeffersonheard> however, doing a pixbufNewFromFile in ghci gives a valid pixbuf reference
12:43:24 <jeffersonheard> so why the error in the program?
12:44:01 <soupdragon> I don't know
12:44:08 <jeffersonheard> me neither...
12:44:28 <Berengal> It says unknown reason though, not that it's definitely corrupt
12:44:35 <soupdragon> is it supprosed to be jpg
12:44:45 <jeffersonheard> checked it -- it's definitely jpg
12:45:00 <jeffersonheard> and it can be opened from GHCI
12:45:12 <jeffersonheard> so...  I guess my question is what are the possible unknown reasons...
12:45:18 <soupdragon> what akout png
12:46:04 <jeffersonheard> Hrm...  so compiling another program, it seems to work fine.  It's just here in this one.
12:46:35 <jeffersonheard> Also, I tried to use Prelude.catch to catch the error and print out, and Prelude.catch isn't handling it
12:47:04 <mauke> try Control.Exception.catch
12:47:29 <jeffersonheard> mauke - that was going to be my next try.  I suppose a user error isn't necessarily an IOError
12:47:50 <SamB_XP> yeah, it's unfortunate that catch was in Prelude :-(
12:48:01 <SamB_XP> jeffersonheard: indeed not
12:48:16 <SamB_XP> IOErrors are now just one of many types of exceptions
12:48:52 <jeffersonheard> One problem I've noticed is that it's impossible to know the type of the exception that someone's library's going to throw
12:48:59 <jeffersonheard> as far as I can tell anyway
12:50:41 <mornfall> jeffersonheard: Well, not from the type of whatever they export, no.
12:50:53 <SamB_XP> @type Control.Exception.catch
12:50:54 <jeffersonheard> mornfall: how else do you figure it out?
12:50:55 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
12:51:04 <mornfall> There's some explicit-exceptions package, but looks pretty messy to me.
12:51:08 <BONUS> just say no to exceptions
12:51:18 <SamB_XP> @instances-importing Control.Exception Exception
12:51:20 <lambdabot> ArithException, ArrayException, AssertionFailed, AsyncException, BlockedIndefinitely, BlockedOnDeadMVar, Deadlock, ErrorCall, IOException, NestedAtomically, NoMethodError, NonTermination, PatternMatch
12:51:20 <lambdabot> Fail, RecConError, RecSelError, RecUpdError, SomeException
12:51:22 <BONUS> unless you're using them with forkIO and friends
12:51:25 <mornfall> jeffersonheard: Well, if they were nice, they probably mention exceptions in their haddocks, or something.
12:51:37 <SamB_XP> jeffersonheard: I guess that's what SomeException is for?
12:52:44 <jeffersonheard> I think I see it.  finalizers are being called before the thing blows completely up, meaning that files are flushed and closed.  I bet that calling ByteString.writeFile is lazy enough that when the file is read it has zero length
12:53:43 <saml> (1 :: Int) `myadd` 2.3     -- can you make it work?
12:53:57 <saml> > (1 :: Int) + 1.0
12:53:59 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
12:53:59 <lambdabot>    arising from the lit...
12:54:09 <saml> using existential?
12:54:21 <jeffersonheard> would that make sense?
12:55:22 <Jedai> saml: You have to use another class than Num
12:55:32 <Jedai> saml: but that's not really hard
12:59:56 <Jedai> class Add a b where type { SumT :: * -> * -> *; myAdd :: a -> b -> SumT a b }
13:00:26 <pumpkin> why not just type family (:+:) a b ?
13:00:50 <Jedai> pumpkin: Well you need a myAdd after that
13:01:11 <Jedai> pumpkin: though I guess by using convert, you could do something like
13:01:21 <pumpkin> it doesn't have to be a method
13:01:26 <Jedai> myAdd a b = convert a + convert b
13:01:37 <CalJohn> @src map
13:01:38 <lambdabot> map _ []     = []
13:01:38 <lambdabot> map f (x:xs) = f x : map f xs
13:02:01 <CalJohn> why doesn't prelude use: "map f = foldr ((:) . f) []"
13:02:07 <pikhq> > (fromIntegral (1 :: Int)) + 1.0
13:02:09 <lambdabot>   2.0
13:02:26 <pikhq> CalJohn: Good question.
13:02:44 <Jedai> myAdd :: (Convert a (a :+: b), Convert b (a :+: b)) => a -> b -> a :+: b
13:02:52 <CalJohn> pikhq: indeed.
13:02:56 <pikhq> Better question is, why map? It's just fmap but less general. :P
13:03:02 <Jedai> pumpkin: something like that ?
13:03:03 <CalJohn> @src filter
13:03:04 <lambdabot> filter _ []     = []
13:03:04 <lambdabot> filter p (x:xs)
13:03:04 <lambdabot>     | p x       = x : filter p xs
13:03:04 <lambdabot>     | otherwise = filter p xs
13:03:21 <pumpkin> Jedai: what is Convert?
13:03:34 <CalJohn> filter is also foldless
13:03:51 <dafra> hi, anybody got grapefruit up and running on windows ?
13:04:04 <Jedai> pumpkin: something someone put on Hackage, Convert a b indicate you can do a meaningful conversion from one to the other
13:04:08 <pumpkin> oh I see
13:04:26 <Jedai> pumpkin: I'm not sure its name is really Convert by now though ;)
13:04:30 <dafra> i get an error when loading a gtk dll
13:04:38 <CalJohn> pikhq: the next question is "does ghc optimise folds away using the fusion law"
13:04:48 <BONUS> :t \f -> foldr (\x z -> if f x then x:z else z) []
13:04:50 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:04:51 <Jedai> pumpkin: I forgot (Num (a :+: b)) in my solution too
13:05:00 <CalJohn> pikhq: because if it does, then surely having non-fold based recursion operators is slow?
13:05:58 <benmachine> CalJohn: lambdabot's @src is meant to be illustrative of what a function does
13:06:04 <benmachine> it's not necessarily how it is Really Done
13:06:29 <CalJohn> benmachine: it is how it is really done
13:06:34 <CalJohn> benmachine: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#map
13:06:36 <Vanadium> @src evaluate
13:06:36 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
13:07:07 <Vanadium> I do not understand why this is not just return $! a
13:07:58 <dafra> @i (#, #)
13:07:59 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
13:08:15 <dafra> :t (#, #)
13:08:18 <lambdabot> forall t t1. t -> t1 -> (# t, t1 #)
13:08:29 <dafra> @instances (#, #)
13:08:31 <lambdabot> Couldn't find class `(#, #)'. Try @instances-importing
13:08:31 <Vanadium> (#, #) is an unboxed tuple?
13:08:40 <dafra> @instances-importing (#, #)
13:08:40 <Vanadium> aaah what is happening
13:08:41 <lambdabot> Couldn't find class `#)'. Try @instances-importing
13:08:43 <Jedai> Vanadium: Yes and no
13:09:27 <dafra> :i (#, #)
13:09:38 <Jedai> Vanadium: The truth is that those unboxed tuples don't really exists in the compiled code, it use two register to return the results of the function
13:10:01 <Vanadium> Jedai: Huh. I just kind of assumed that nothing really exists in compiled code :c
13:10:05 <Jedai> Vanadium: In other words it's really a syntax for multivalued returns
13:10:12 <Vanadium> Oh, okay
13:10:32 <dafra> that's compilation, ghc could do the same with lazy tuples, if you are lucjy
13:10:34 <Jedai> Vanadium: Well that's not so simple, most data structure remains identifiable
13:11:00 <tibbe> hmm, what would a FFI binding for `pipe` look like? It has signature `:: Ptr CInt -> IO CInt` where the first argument is a two element array.
13:11:12 <Jedai> dafra: True, but you would need to be very lucky, (#,#) always have this semantic
13:11:20 <Vanadium> tibbe: Is pipe not already in system.unix.something?
13:12:30 <jeffersonheard> argh.  well, that wasn't it -- I read the files back in and printed their lengths before using pixbufNewFromFile
13:12:33 <tibbe> Vanadium: perhaps hoogle is hiding it from me
13:12:38 <Vanadium> tibbe: It is, sec
13:12:55 <Vanadium> http://book.realworldhaskell.org/read/systems-programming-in-haskell.html mentions it, anyway
13:13:05 <Vanadium> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html#v%3AcreatePipe
13:13:11 <tibbe> Vanadium: thanks
13:13:31 <Vanadium> I am going to be a jerk and assume that you use ghc, here :3
13:15:14 <BONUS> i think only grade school children use hugs
13:15:40 <pikhq> A mathematician friend of mine uses Hugs.
13:15:46 <saml> free hug
13:15:47 <tibbe> sigh, the array interface is a real PITA, why can't we simply have zero indexed arrays?
13:15:47 <BONUS> which grade is he in
13:15:49 <ddvlad> hey, i'm thinking of writing a mafia irc bot and have just discovered the wonders of RWST + IO. is there anything i should look out for, or is this really a free awesome ride? :)
13:15:49 <Vanadium> I could use some hugs :C
13:15:50 <BONUS> haha
13:16:06 <pikhq> BONUS: Erdős number of 5.
13:16:20 <saml> wht is RWST?
13:16:33 <saml> ReaderWriterStateTransformer ?
13:16:44 <ddvlad> saml: yup
13:16:47 <jmcarthur_work> wow
13:16:55 <saml> @hoogle ReaderWriterStateTransformer
13:16:56 <lambdabot> No results found
13:16:59 <cjb> pikhq: bah, mine's lower than that and I don't even do math :)
13:17:04 <ddvlad> @hoogle RWST
13:17:05 <lambdabot> Control.Monad.RWS.Lazy newtype RWST r w s m a
13:17:05 <lambdabot> Control.Monad.RWS.Lazy RWST :: r -> s -> m (a, s, w) -> RWST r w s m a
13:17:05 <lambdabot> Control.Monad.RWS.Strict newtype RWST r w s m a
13:17:46 <CalJohn> pikhq, benmachine: the answer is that ghc uses some clever rewrite rules to do fusion, so that definition never actually happens
13:17:52 <BONUS> what's the point of RWS anyway besides hey let's join reader, writer and state into one big monad wouldn't that be fun
13:18:56 <Botje> saves you from layering them yourself?
13:18:58 <ddvlad> BONUS: exactly... i've just discovered it's too fun to be true :)
13:19:04 <Botje> slight performance gain?
13:19:07 <Twey> Doesn't State cover Reader and Writer anyway?
13:19:18 <Botje> saves people from figuring out which combination of the three they need? :)
13:19:41 <BONUS> yeah you can do reader and writer with state, don't see why you should layer them
13:19:42 <Berengal> Also, it's not too uncommon to need one reader type, one writer type and one state type
13:20:19 <dolio> Why use booleans when you can use integers?
13:20:54 <BONUS> don't see why not
13:21:19 <jeffersonheard> .me 's head explodes
13:21:27 <BONUS> if you use integers to represent booleans then you can do stuff like 4 + true
13:21:30 * jeffersonheard 's head explodes rather
13:21:33 <dolio> Why use type systems when you can write code without them?
13:21:40 <ddvlad> my point exactly -- i could just stuff everything up in a State, but would't it be fair that read-only stuff go in Reader?
13:21:47 <BONUS> oh that was ironic
13:21:51 <BONUS> oh man my bad
13:22:36 <LuisaM> BONUS: hey are you the guy from learn you a haskell for great good?
13:22:50 <BONUS> yo! yeah
13:22:50 <dolio> No, that's another BONUS.
13:23:01 <BONUS> its me
13:23:07 <saml> it's me too
13:23:15 <BONUS> i guess we're all me
13:23:18 <Berengal> I'm the real BONUS
13:23:29 <BONUS> haha
13:23:36 <LuisaM> BONUS: I started learning haskell for your guide
13:23:43 <LuisaM> it complemented my school classes
13:23:46 <LuisaM> thanks BONUS
13:23:48 <BONUS> nice :]
13:23:57 * Botje is going to urge his school to use LYAH too
13:24:15 <BONUS> currently writing newtypes, monoids and foldables. then it's just monads, monad transformers, zippers and i can put the book out in irl form
13:24:18 <Ke> cute pictures about dognapping were a BONUS
13:24:21 <pikhq> BONUS: LYAH was a great guide.
13:24:25 <BONUS> hehe
13:24:27 <sdg0sdg09sdug0s9> yup
13:24:41 <pikhq> Got me up to the point of being able to learn monads.
13:24:44 <LuisaM> BONUS: make a pdf book for great good
13:24:54 <BONUS> the link to the pdf is in the FAQ imo
13:24:54 <pikhq> (that was tricky, because that wasn't written up, but hey. C'est la vie)
13:25:16 <BONUS> hehe yeah but if you get how applicative functors work, monads aren't really a big mental leap away
13:25:31 <pikhq> Applicatives were a big mental leap.
13:25:34 <Berengal> Applicatives are much more fun anyway ;)
13:25:48 <BONUS> because you see how applicatives are values in contexts and how operations between them work
13:25:53 <BONUS> hehe applicatives are fun indeed
13:26:10 <jeffersonheard> The brilliant error thrown by Glib is "System.Glib.GError.GError".
13:26:15 <ddvlad> @hoogle liftIO
13:26:16 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
13:26:16 <jeffersonheard> how descriptive
13:26:16 <Berengal> And as with most classes, function is the most fun instance
13:26:24 <tibbe> @pl \(x,y) -> [x,y]
13:26:24 <lambdabot> uncurry ((. return) . (:))
13:26:28 <tibbe> great
13:26:41 <BONUS> :t sequence [fst, snd]
13:26:43 <lambdabot> forall a. (a, a) -> [a]
13:26:57 <BONUS> > sequence [fst, snd] (1,2)
13:26:59 <lambdabot>   [1,2]
13:27:11 <jeffersonheard> this worked before, so I'm not sure what the problem is.  Now removing all forkIOs from my code to make sure that pixbufNewFromFile is being called on the main thread
13:27:21 <pumpkin> BONUS: that's kinda elegant
13:28:00 <BONUS> yeah and it makes sense because the tuple gets fed into every function in the list
13:28:06 <BONUS> and the results are collected in a list
13:28:30 <pumpkin> > sequence [(+1), (^3), (`mod` 7), (*4)] 125
13:28:32 <lambdabot>   [126,1953125,6,500]
13:28:50 <LuisaM> BONUS: I never noticed that you already had a pdf, thanks!
13:29:02 <pikhq> Ah, the function monad.
13:29:04 <BONUS> > sequence xs a = map ($ a) xs
13:29:05 <FliP^2eH> Any function that takes and drops at the same time?
13:29:06 <lambdabot>   <no location info>: parse error on input `='
13:29:08 <cjb> oh!  I hadn't noticed that either
13:29:11 <pikhq> Such a great monad.
13:29:28 <cjb> LuisaM: where's the pdf?
13:29:31 <Berengal> pikhq: Also, the function monoid
13:29:36 <FliP^2eH> like takeAndDrop "One.Two" "." -> ("One", ".Two") ?
13:29:43 <pikhq> Berengal: Heheh.
13:30:07 <pikhq> @hoogle split
13:30:08 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
13:30:08 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
13:30:08 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
13:30:18 <cjb> ah hah!  http://learnyouahaskell.com/learnyouahaskell.pdf
13:30:35 * pikhq looks in Data.List
13:30:47 <cjb> the PDF is less pretty than the webpage though :)
13:31:00 <BONUS> but your printer will be grateful though
13:32:31 <pikhq> FliP^2eH: break (== '.')
13:32:44 <pikhq> > break (== '.') "One.Two"
13:32:46 <lambdabot>   ("One",".Two")
13:33:01 <BONUS> break and span are takeWhile and dropWhile together
13:33:05 <BONUS> yeah
13:33:10 <FliP^2eH> Thanks :)
13:37:40 <LuisaM> sorry cjb, I didn't read your question
13:37:46 <LuisaM> too much lines here
13:37:57 <cjb> LuisaM: it's ok
13:37:59 <jeffersonheard> hahah.  found it..  anyone ever try to open a pixbuf at 32k by 32k?  I don't recommend it...
13:38:51 <Berengal> > 32^2*1024^2
13:38:53 <lambdabot>   1073741824
13:39:36 <Berengal> 4 bytes / pixel?
13:40:07 <BONUS> a man takes a haskell program to a CS prof, says he needs to make the program faster. the CS prof says "the best way to optimize a program is to give to dons". the man says: "but, doctor, I *am* dons!"
13:40:48 <BONUS> ah yes pagliacci jokes
13:40:57 <Botje> grin :)
13:41:11 <pumpkin> Ridi, pagliaccio
13:41:14 <pikhq> :)
13:41:17 <pumpkin> sul tuo amore infranto
13:53:53 <thetallguy1> Anyone know why TH newName generates names that ghci reports like this Foo[fa3e], and sometimes like this: foo_1?
13:54:07 <jeffersonheard> Berengal, yes
13:54:18 <thetallguy1> Is the former used in Q [Dec] contexts and the latter in Q Exp?
13:55:52 <FliP^2eH> Quick! A nice and clean way to make a nicely formated data record out of something like "firstpart\NULsecondpart\NUL\thirdpart\NULIMTRAPPEDINAUNIVERSEFACTORY!!\NUL"
13:55:54 <FliP^2eH> Show me your moves.
13:59:06 <Berengal> unfoldr (Just . break '\0')
14:03:22 <FliP^2eH> Berengal, that takes care of splitting
14:03:25 <thetallguy1> Berengal:  that doesn't even type check.
14:03:30 <FliP^2eH> But how do I nicely put them into a record?
14:03:52 <thetallguy1> Flip^2eH:  You want a record specifically for that type?
14:04:00 <thetallguy1> Is the record pre-defined?
14:04:00 <FliP^2eH> I got one already
14:04:08 <FliP^2eH> @hpaste
14:04:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:04:38 <FliP^2eH> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7282#a7282
14:05:34 <Berengal> thetallguy1: I don't typecheck my programs, that's what computers are for :P
14:06:07 <yakov_> hey
14:06:13 <saml> hey yakov_
14:07:20 <FliP^2eH> Berengal: That's like saying you don't steer your car because it's the other's job of avoiding you :)
14:07:45 <pikhq> FliP^2eH: No, that's like saying you don't steer your car because that's what cars are for.
14:07:50 <pikhq> :P
14:08:01 <Berengal> FliP^2eH: No, it's like saying I don't steer the train because that's what tracks are for
14:08:01 <yakov_> seems like "ghc: panic! (the 'impossible' happened)" when using directive in first line of source e.g. {-# LANGUAGE: ForeignFunctionInteface #-} is not fixed in 6.10.4, isn't it
14:08:44 <FliP^2eH> You won
14:09:27 <FliP^2eH> > break mySpine 'T' where mySpine = "1T2T3T4"
14:09:29 <lambdabot>   <no location info>: parse error on input `where'
14:09:32 <FliP^2eH> Mhhh
14:09:41 <FliP^2eH> > let mySpine = "1T2T3T4" in break mySpine 'T'
14:09:43 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
14:09:46 <FliP^2eH> I give up
14:09:47 <pikhq> FliP^2eH: break takes a predicate at which to break things.
14:09:53 <FliP^2eH> Ahh
14:10:00 <FliP^2eH> Can't break my spine without reason, huh?
14:10:03 <pikhq> Think "takeWhile", not "take".
14:10:28 <pikhq> > break (== 'T') mySpine where mySpine = "1T2T3T4"
14:10:29 <lambdabot>   <no location info>: parse error on input `where'
14:10:47 <pikhq> o.O
14:10:58 <Badger> > break (== 'T') mySpine in mySpine "1T2T3T4"
14:11:00 <lambdabot>   <no location info>: parse error on input `in'
14:11:01 <pikhq> > let mySpine = "1T2T3T4" in break (== 'T') mySpine
14:11:03 <lambdabot>   ("1","T2T3T4")
14:11:08 * Badger crumples.
14:11:10 <FliP^2eH> @src split
14:11:11 <lambdabot> Source not found.
14:11:46 <FliP^2eH> I want it recursivly :(
14:12:21 <yakov_> could you take a look, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7284#a7284
14:12:33 <yakov_> what is wrong with this foreign import?
14:12:41 <Berengal> FliP^2eH: Since you already know how many fields you want, you can't do it with a list function
14:12:53 <pumpkin> yakov_: you need the external symbol in quotes
14:12:56 <Berengal> FliP^2eH: Well, you could... but it's not idiomatic
14:13:05 <pumpkin> yakov_: also, it probably should be CInt
14:13:08 <FliP^2eH> How could I do it the smart way?
14:13:12 <FliP^2eH> I just want to split it first
14:13:17 <FliP^2eH> To get the individual values
14:13:27 <FliP^2eH> And then fill them in
14:13:32 <yakov_> pumpkin, so it is not possible to omit external symbol is it same as haskell func name?
14:13:32 <pumpkin> yakov_: foreign import ccall "sift" sift :: CInt
14:13:34 <pumpkin> for example
14:13:50 <pumpkin> yakov_: nope, and you also need to specify ccall to tell it how to mangle the symbol
14:13:53 <pumpkin> if at all
14:14:01 <pumpkin> (and how to call the function if it's a function)
14:14:18 <yakov_> aha, thx!
14:14:33 <Berengal> FliP^2eH: Well, actually, now that I think about it, it's not too bad, really
14:17:39 <FliP^2eH> Why is there no words function for other things than spaces?
14:17:45 <FliP^2eH> The split function that every language has?
14:18:27 <pumpkin> @hackage split
14:18:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
14:18:36 <pumpkin> epic combinators
14:18:44 <kw317> hi
14:18:52 <LeoD> nextPowerOf2 x = head . dropWhile (< x) . iterate (* 2) $ 1 -- any other funky way to do this? :)
14:20:54 <Chile> I'm getting the following exception in code I didn't write.. guessing there's bad input somewhere, but I don't quite know quite what to look for, since I don't quite get what the error means:  Data/Graph/Inductive/NodeMap.hs:130:8-30: Irrefutable pattern failed for pattern Data.Maybe.Just es'
14:22:56 <Beelsebob> LeoD: grab the binary form and fill in all 1s
14:23:40 <benmachine> Beelsebob: and then add 1
14:23:50 <Beelsebob> quite
14:24:01 <benmachine> Beelsebob: I was thinking of something like that but I'm not sure there's an efficient way to stop filling in
14:24:13 <Beelsebob> hmm?
14:24:26 <benmachine> well like
14:24:43 <Beelsebob> (+1) . toDecimal . map (const 1) . bits
14:24:51 <benmachine> ah
14:24:53 <Beelsebob> assuming a sensible bits and toDecimal function
14:24:57 <benmachine> well
14:25:09 <benmachine> that's the thing, you need to count the number of bits
14:25:24 * Beelsebob nods
14:25:31 <Beelsebob> oh, good point
14:25:32 <benmachine> if you did that you may as well just do 2 ** number of bits
14:25:34 <Beelsebob> yep
14:25:42 <tavelram> or grabbing the binary and traverse it from the left until you find a 1 digit.
14:25:47 <benmachine> which is effectively what LeoD did originally :P
14:25:49 <tavelram> if its a fixed number of bits
14:26:01 <Beelsebob> benmachine: yeh, fair point
14:26:25 <benmachine> tavelram: if you wanted the binary representation to be a fixed number of bits you can't work with Integer
14:26:31 <tavelram> indeed
14:26:32 <benmachine> which might be ok
14:26:47 <benmachine> on the whole though I don't think the original can be improved upon
14:27:22 <benmachine> (although, worth asking what happens if x is negative)
14:27:59 <benmachine> (or what the next power of 2 after 0 is)
14:28:57 <tavelram> since he has >, id say it would be 2 for 0.
14:29:06 <tavelram> next for 4 would be 8, etc.
14:30:10 <tavelram> sorry
14:30:28 <tavelram> <, so it would be 0 for 0, 4 for 4, etc.
14:31:23 <tavelram> so semantics would probably be MAX value for the same amount of significant digits.
14:35:46 <pastah> @type (>>=)
14:35:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:37:09 <FliP^2eH> Why is there no split function in Data.List when it's that easy to write? Even I could do it :D
14:37:17 <FliP^2eH> Did it*
14:37:27 <pumpkin> it's not clear how it should behave
14:37:29 <mauke> your split function sucks
14:37:29 <Peaker> FliP^2eH: there are many ways to split lists, so there's a whole module just for that
14:37:29 <BONUS> it's trickier than it sounds
14:37:42 <FliP^2eH> I think mauke wins here
14:37:47 <pumpkin> should it eat the splitting tokens or include them? should it include them at the beginning or the end of each chunk? should it split
14:38:00 <FliP^2eH> split sep str = case break (==sep) str of
14:38:01 <FliP^2eH>                    (fr, []) -> [fr]
14:38:01 <FliP^2eH>                    (fr, se) -> fr : split sep (drop 1 se)
14:38:04 <BONUS> say you're splitting on ".", how do you split "...a.b.c..d.."
14:38:06 <FliP^2eH> This is how I do it
14:38:23 <FliP^2eH> ["","","","a","b","c","","d","",""] for me
14:38:28 <FliP^2eH> I don't exclude empties
14:38:29 <BONUS> what if you want to split on something that's more than one character?
14:38:43 <mauke> what if I want to split on a class of characters?
14:38:56 <BONUS> it's tricksies like that that make it tricky
14:39:06 <Botje> the tricksie pictsies!
14:40:26 <Peaker> @package split
14:40:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
14:40:42 <BONUS> although python's split is pretty sane imo
14:41:00 <Peaker> FliP^2eH: http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html#v%3AsplitOn
14:59:56 <flippeh_> I want to apply a function to a list, map, but the function I want to apply is in the IO monad, so I'm getting [IO String]
15:00:03 <flippeh_> What can I do? I need it for outputting
15:00:41 * andresj wonders why there is no ((a -> Bool) -> a -> Maybe a) or (Bool -> a -> Maybe a) function in standard libraries; or is it im the only one that uses such a thing? :p
15:00:56 <andresj> flippeh_: use fmap
15:00:58 <andresj> :t fmap
15:01:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:01:34 <pumpkin> andresj: guard works sort of like that
15:01:36 <pumpkin> :t guard
15:01:38 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:01:48 <flippeh_> How?
15:02:18 <flippeh_> fmap inet_ntoa (hostAddresses s)
15:02:36 <andresj> flippeh_: wait, i'm not sure i understood what u meant: what is the type of your function, and of your list?
15:02:44 <BONUS> wait, i think he wants mapM?
15:02:45 <LeoD> looks more like you'd want mapM there
15:03:06 <LeoD> @type mapM
15:03:07 <andresj> pumpkin: hum, that seems promising: although I need `m a`, not `m ()`
15:03:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:03:09 <pikhq> Definitely mapM.
15:03:10 <flippeh_> List is String
15:03:11 <pumpkin> @type \p a -> guard p >> return a
15:03:13 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
15:03:13 <flippeh_> Function is IO STring
15:03:18 <flippeh_> I'd say mapM
15:03:27 <pumpkin> @type \p a -> guard p >> return a :: Bool -> a -> Maybe a
15:03:29 <lambdabot>     Inferred type is less polymorphic than expected
15:03:29 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
15:03:29 <lambdabot>         a :: a -> Maybe a (bound at <interactive>:1:3)
15:03:32 <andresj> pumpkin: you read mym ind, lol
15:03:33 <pumpkin> bah :P
15:03:34 <BONUS> if you do mapM putStrLn ["haha","blah","blah"], it returns an action that makes [IO ()] and then runs each of those actions, so it's IO [()]
15:03:43 <pumpkin> :)
15:03:57 <pumpkin> @pl  \p a -> guard p >> return a
15:03:58 <lambdabot> (. return) . (>>) . guard
15:04:03 <pumpkin> that's not so bad
15:04:11 <pumpkin> probably nicer in pointful form though
15:04:14 <pikhq> And if you do mapM_, it does all that, except it then does a return (), so it's IO ().
15:04:26 <Axman6> pikhq: things usually are
15:04:28 <Axman6> pumpkin*
15:04:30 <andresj> yeah, i just saw that
15:04:57 <flippeh_> Erm
15:05:14 <flippeh_> I solved the problem, I knew the solution from the beginning, somehow I made some stupid mistake
15:05:24 <flippeh_> s <- getHostByName "google.com"
15:05:24 <flippeh_> a <- mapM inet_ntoa (hostAddresses s)
15:07:04 <benmachine> speaking of mapM
15:07:09 <Beelsebob> mapM inet_ntoa . hostAddress =<<  getHostByName "guest.com"
15:07:24 <benmachine> those 20 intermediate haskell exercises that were mentioned in here a while ago
15:07:34 <benmachine> effectively asked me to reimplement it and I couldn't work it out
15:07:35 <pumpkin> oh dibblego's ones?
15:07:38 <flippeh_> Couldn't match expected type `[HostAddress]'
15:07:41 <flippeh_> Beelsebob :)
15:07:42 <benmachine> could anyone give me a hand?
15:07:44 <LeoD> benmachine: it's sequence . map
15:07:46 <pumpkin> benmachine: sure, which one?
15:07:50 <pumpkin> oh
15:08:12 <benmachine> LeoD: yeah I think I worked that out, except that I haven't done the sequence one yet :P
15:08:26 * benmachine looks for somewhere to put exercises.hs
15:08:44 <pumpkin> gist.github.com
15:08:59 <mike-burns> hpaste
15:09:20 <pumpkin> gist.github.com provides nice versioning of your pastes too :)
15:09:23 <benmachine> http://benmachine.net/haskell/exercises.hs <-- scroll down to... 14 I think?
15:09:43 <pumpkin> ah
15:09:57 <benmachine> I implemented it for every instance I'd made so far in the hope of some insight
15:09:59 <benmachine> but none came
15:10:08 <pumpkin> so you have an a
15:10:10 <benmachine> (also if anyone wants to criticise the other entries feel free)
15:10:22 <pumpkin> and a function that takes an a and gives you a m b
15:10:33 <pumpkin> what can you do with that a? :P
15:10:33 <benmachine> yus
15:10:39 <benmachine> I can make an m b!
15:10:46 <pumpkin> so start with that
15:10:47 <benmachine> I don't have an a though I have a lsit of a
15:10:54 <benmachine> so I can make a list of m b
15:10:58 <benmachine> but then what?
15:11:14 <kevink> Hi. Is it possible to extract from two different Monads in the same do block? e.g. do { a <- (Monad m1) .... b <- (Monad m2) ...}
15:11:56 <Axman6> not really
15:12:04 <pumpkin> these names are messing with my head :P
15:12:28 <benmachine> heh
15:12:40 <pumpkin> benmachine: you don't want to do it all at once though
15:12:47 <pumpkin> you've already broken it into x:xs
15:12:56 <pumpkin> so you want to apply that function to x to get an m b
15:13:05 <benmachine> yeah
15:13:11 <benmachine> then I have an m b and an m [b]
15:13:22 <benmachine> (the latter from the recursive call)
15:13:31 <Axman6> kevink: do blocks are just sugar for (>>=) and (>>) basically, so the types won't match
15:13:50 <benmachine> but then I need to : them
15:13:58 <Saizan> benmachine: right
15:13:59 <benmachine> wait a sec
15:14:09 <benmachine> that's not as hard as I thought is it
15:14:34 <Axman6> @undo do { x <- f y; z <- g q; h x z; g x} -- kevink
15:14:35 <lambdabot> f y >>= \ x -> g q >>= \ z -> h x z >> g x
15:14:37 <Saizan> pumpkin: unicorn, banana..
15:15:23 * benmachine writes it in do-notation and then tries to translate into the exercise-names
15:19:40 <kevink> Axman6: thanks
15:22:46 <BONUS> h <$> f y <*> g q >> f y >>= g
15:23:32 <jmcarthur_work> @pl f y >>= \ x -> g q >>= \ z -> h x z >> g x
15:23:33 <lambdabot> (g q >>=) . ap (flip . ((>>) .) . h) g =<< f y
15:23:50 <jmcarthur_work> :(
15:24:04 <pikhq> jmcarthur_work: Too many lambdas, eh?
15:24:30 <pikhq> ap (flip . ((>>) .) . h) g -- heheh, that's a good one.
15:25:39 <vav> Suggestions what would cause local \bot to give "caught (and ignoring) too few bytes. Failed reading at..." with each use? Still gives correct output after error msg. (ghc-6.10.4, x86-64, latest cabal install of \bot)
15:30:06 <jorick> hello everyone, i found a website http://www.mentalfx.com/ and i was wondering what the possibilities where if you wanted to use haskell to generate psychedelic animations
15:30:35 <jorick> i used to make em with winamp when i was a kid but kind of stopped doing that, which is a shame cuz it's really fun
15:30:53 <pumpkin> benmachine: sorry, someone called me for help :P did you get it?
15:31:36 <sjanssen> jorick: Haskell does have opengl bindings that are supposed to be fairly good
15:31:43 <pumpkin> benmachine: you're going to need banana
15:31:47 <shepheb> is there a reason why there's no "this" or other keyword that allows anonymous functions in \bot or lambdas to refer to their nameless selves?
15:32:06 <jmcarthur_work> s/fairly good/basically like the C API/
15:32:15 <conal> jorick: i'm very interested in that sort of thing and have been doing functional graphics & animation for quite a while.
15:32:38 <jmcarthur_work> shepheb, you mean something like fix?
15:32:43 <jorick> cool, do you know how i should start with it?
15:32:54 <jorick> i gather there is probably a great deal of math involved
15:33:18 <pikhq> If by "math" you mean "mathematical reasoning", then yes.
15:33:23 <conal> jorick: yeah.  definitely math.  not deep math, though.  algebra & trig.
15:33:28 <shepheb> I guess it'd be a question of scope. take 10 $ 1 : 1 : zipWith (+) this (tail this) is ambiguous
15:33:30 <jorick> shepheb you can use the y combinator
15:33:34 <jmcarthur_work> shepheb, fix $ \self -> blah blah self blah
15:33:38 <jorick> for recursive anonymous lambdas
15:33:40 <shepheb> truth
15:33:42 <wjt> shepheb: what would 'this' refer to in '\a b -> this' ? how about '\a -> \b -> this'?
15:33:59 <pumpkin> shepheb: fix does pretty much what you want without a special keyword
15:34:00 <conal> jorick: what sort of background do you have now?
15:34:09 <pikhq> It's like normal programming, except you spend very little time dealing with fiddly bits like state.
15:34:17 <benmachine> pumpkin: I haven't got it but I think I know how to now, thanks
15:34:22 <jorick> i've had some math, but it's been a few years
15:34:29 <pikhq> wjt: \a b -> this -- also known as \a -> \b -> this
15:34:33 <pumpkin> benmachine: cool, let me know if you figure it out :)
15:34:33 <pikhq> Welcome to curry
15:34:43 <conal> jorick: btw, when you asked aobut math, i figured you meant for psychedelic graphics
15:34:53 <jorick> yeah of course :D
15:34:55 <pumpkin> pikhq: wrong language, this is haskell :P curry's at http://www.informatik.uni-kiel.de/~curry/
15:35:07 <pikhq> pumpkin: -_-'
15:35:30 <jorick> i think the ones that have fractals are the nicest
15:35:31 <wjt> pikhq: yes yes i know, that was kind of my point: it's ambiguous as to which lambda it would refer to, and it could only consistently refer to the one you don't want
15:35:34 <conal> jorick: functional programming itself is also mathy, though in a different sense.
15:36:27 <conal> jorick: cool applets!  thanks much for the pointer.
15:37:13 <jorick> i like haskell because it seems like once i got the types right everything always works
15:37:38 <conal> jorick: yeah.  especially if you stay away from IO.
15:37:43 <pikhq> conal: Programming is mathy.
15:37:52 <jorick> so i want to make applets like that
15:37:55 <conal> pikhq: for me also.  not for everyone.
15:38:15 <jmcarthur_work> functional programming tends to not hide the math as much, imo
15:38:22 <pikhq> Most programming languages just abstract away mathematics to let you fiddle with a finnicky machine. :P
15:38:35 <mike-burns> Most Web programming is less mathy than, say, financial programming.
15:38:38 <jmcarthur_work> i don't know if i would call that abstraction
15:38:51 <jmcarthur_work> mike-burns, i don't think it must be inherently like that
15:38:54 <conal> jorick: are you thinking of generating java code?
15:38:59 <pikhq> mike-burns: Math is not all numbers.
15:39:16 <jorick> nooo i want it all in haskell
15:39:16 <pikhq> Algorithms are inherently mathematical.
15:39:20 <kw317> hi
15:39:29 <pikhq> And most programming deals with algorithms. ;)
15:39:51 <mike-burns> Web programming is, 90% of the time: take input from a form, stick it in the database; take data from the database, render it to the user.
15:39:56 <conal> jorick: check out http://conal.net/pajama.  full of interactive graphics applets, all generated in haskell.
15:40:08 <pumpkin> mike-burns: that can be mathy too, just not the numerical mathyness
15:40:18 <jorick> you generate the java code in haskell?
15:40:20 <ray> abstract nonsense
15:40:35 <BONUS> i'd say haskell feels more "mathy" primarily because it's value oriented
15:40:41 <pikhq> mike-burns: Mathematical.
15:40:47 <hzap> and monads.
15:40:48 <BONUS> just like in maths, you mostly deal with data and transformations on it, instead of a series of steps
15:41:01 <mike-burns> I think we're now defining "mathematical" as "something you do with a programming language".
15:41:02 <BONUS> and there's no global state
15:41:06 <kniu> So who's writing lambdabot 2?
15:41:22 <ray> gwern?
15:41:26 <conal> jorick: the Pajama language & implementation are very like Pan's (http://conal.net/pan -- bit-rotten, but see Papers).
15:41:29 <jmcarthur_work> mathematical is any formal system, really
15:41:41 <BONUS> wait scratch that. i think what makes haskell "mathy" is that haskell articles tend to circulate in PDF format, often typeset in LaTeX
15:41:45 <pikhq> mike-burns: No, "mathematical" is being defined as "dealing with a formal system of reasoning".
15:41:59 <mike-burns> Okay, so all programming languages are mathy.
15:42:00 <pumpkin> lol
15:42:09 <Vanadium> BONUS: hahaha
15:42:16 <pikhq> Programming languages tend to be formal systems of reasoning.
15:42:17 <pikhq> ;)
15:42:18 <kw317> silly question: how can I do equivalent of tail xs if xs is a parallel vector?
15:42:22 <jmcarthur_work> some programming languages embrace this more than others, of course
15:42:31 <pikhq> jmcarthur_work: Well, of course.
15:42:33 <conal> jorick: oh, and see the Pan image Gallery
15:42:38 <Vanadium> BONUS: I was rather intimidated by the mathy looking parts of the tex in the, uh, Tackling The Awkward Squad thing
15:43:02 <jmcarthur_work> the best ones are the simple ones. they make mathematical reasoning easier
15:43:29 <jmcarthur_work> the lambda calculus happens to be a nice fit for much of our existing mathematical reasoning :)
15:43:40 <BONUS> yeah i used to be intimidated by stuff like that too but then you see it's just for shows
15:44:03 <jorick> i love xorgon rings 5
15:44:10 <BONUS> i'm still intimidated by "Why Dependent Types Matter" though :[
15:44:41 <jmcarthur_work> i think it is not so well written compared to why functional programming matters
15:44:42 <pikhq> TeX, intimidating?
15:44:56 <ray> > text "TeX"
15:44:58 <lambdabot>   TeX
15:45:29 <sm> heard in a michael feathers interview today: OO says tell, don't ask. FP says ask, don't tell
15:45:41 <jmcarthur_work> i disagree with that
15:46:25 <conal> i wonder if mf is relating to demand-driven vs data-driven logic.
15:46:25 <jmcarthur_work> OO says tell, don't ask. FP simply describes.
15:47:26 <jmcarthur_work> scratch that
15:47:28 <mike-burns> How am I supposed to pronounce  <*>  (from Control.Applicative)?
15:47:31 <sm> more context here: http://www.infoq.com/interviews/michael-feathers-programming-languages
15:47:32 <jmcarthur_work> OO says tell, don't ask. FP says "I am."
15:47:49 <BONUS> mike-burns: very carefully
15:47:54 <sm> I think it's not a bad sound bite, myself
15:47:59 <tavelram> conal, could you expand on the haskell generated java in pajama? is it something like jaskell, or simply that you generate some DSL code that you run in a applet vm?
15:48:28 <tavelram> sever not found for the wiki
15:48:36 <pikhq> mike-burns: LT-splat-GT
15:48:41 <conal> tavelram: sure.  i have a haskell dsel that, when run, generates java code.
15:48:47 <mike-burns> <*> looks kinda like a spaceship with a splat in the middle; I'm thinking "splatship".
15:48:47 <BONUS> one of my favorite papers is "The Derivative of a Regular Type is its Type of One-Hole Contexts" ... at first it seems intimidating but once you get it you're just amazed
15:49:07 <jmcarthur_work> i liked that one as well
15:49:12 <jmcarthur_work> been meaning to read it again
15:49:17 <BONUS> but anyway, if i had to pronounce <*>, i'd say ap
15:49:20 <BONUS> as in app
15:49:21 <conal> jorick: i like the trippy applets on mentalfx.com
15:49:32 <BONUS> :t ap
15:49:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:49:48 <conal> BONUS: hey, thanks.  i like that pronunciation.
15:49:50 <mike-burns> Oh, huh. How about  <|>  ?
15:50:07 <jorick> conal: you should have mouse mode default to rings
15:50:10 <mike-burns> @hoogle f a -> f a -> f a
15:50:11 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
15:50:12 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
15:50:12 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
15:50:12 <jorick> and add zoom :)
15:50:42 <tavelram> conal, ok, did that imply that you had to change how you coded theses things, compared to if you'd done it to be displayed in haskell directly?
15:50:43 <conal> jorick: zoom is in there
15:50:47 <conal> jorick: and pan & rotate
15:50:49 <BONUS> i woudln't mind pronouncing <|> "alt"
15:51:19 <Vanadium> :V
15:51:49 <tavelram> -s
15:52:02 <mike-burns> I wish Control.Applicative's docs had a pronounciation guide. Or non-punctuation functions.
15:52:10 <conal> tavelram: yes & no.  i use types like 'Exp Float', 'Exp Bool' etc (with convenient aliases) in place of Float, Bool etc.  overloading means that the difference is mostly invisible.
15:52:26 <jmcarthur_work> i wish we had FunctorPlus rather than MonadPlus and Alternative
15:52:34 <conal> tavelram: see my papers on Pan & Vertigo for more info.
15:52:41 <ray> i wish we had MonoidPlus
15:52:41 <tavelram> conal, ok, will do, cheers :)
15:52:42 <ray> oh wait
15:53:01 <BONUS> hehe
15:53:07 <conal> tavelram: enjoy!  :)
15:53:12 <dibblego> jmcarthur, fmap + mplus?
15:53:20 <pumpkin> fmaplus
15:53:32 <jmcarthur_work> fplus, maybe
15:53:46 <jmcarthur_work> although fmaplus is more fun to say
15:54:23 <jmcarthur_work> heck, we could even call it FunctorMonoid or something
15:54:28 <Vulpyne> The wild fmapaplus gyred and gimbled in the wabe.
15:54:29 <jmcarthur_work> generic
15:56:32 <twanvl> I wish haskell allowed the forall keyword inside class constraints
15:56:49 <conal> twanvl: me too!
15:56:51 <twanvl> then you could just write  (forall a. Monoid (f a)) => stuff
15:57:34 <hzap> that'd be awesome
15:57:36 <conal> twanvl: instance selection is so close to being a higher-order logic programming language (like lambda-prolog) but falls short in ways like that one.
15:58:27 <twanvl> yes, backtracking would also be nice sometimes, but that opens a whole can of worms
15:58:40 <conal> twanvl: and how (both)
15:58:58 <conal> and then there's higher-order unification.
15:58:58 <benmachine> man, that took far too long
15:59:03 <benmachine> who was I supposed to tell I did it?
15:59:06 <twanvl> but the explicit forall seems fairly straightforward to add
15:59:09 <pumpkin> are functional dependencies getting phased out in favor of type families and associated types, or will the two coexist as different ways of solving similar problems?
15:59:18 <pumpkin> benmachine: mee!
15:59:24 <benmachine> pumpkin: think I did it :D
15:59:28 <pumpkin> benmachine: great :)
15:59:31 <BONUS> pumpkin: that's a pretty common question around here imo
15:59:45 <benmachine> pretty convoluted though, going to see if I can reduce it a bit
16:00:13 <BONUS> i don't see what fundeps can do that associated types can't
16:00:25 <BONUS> i.e. type functions
16:00:36 <Vanadium> welp
16:00:53 <Vanadium> I read the parts of real world haskell that are not about gui, dbs, etc
16:00:54 <sjanssen> pumpkin: I think the ultimate goal is to implement fundeps in terms of type families
16:00:59 <dolio> Work correctly with GADTs.
16:01:03 <Vanadium> Where do I go now? :C
16:01:04 <pumpkin> BONUS: it seems to not cover some use cases as elegantly
16:01:26 <pumpkin> maybe not though
16:02:17 <redocdam> is there are trie implementation in the standard library somewhere?
16:02:28 <Twey> No
16:02:31 <dolio> Also, the termination conditions on fundeps don't lend themselves to type-level programming without UndecidableInstances.
16:02:31 <Twey> But there's one on Hackage
16:02:33 <Twey> Data.Trie
16:02:39 <benmachine> pumpkin: if you're curious, you can refresh to see what I eventually got
16:02:52 <pumpkin> benmachine: :o
16:02:57 <pumpkin> two bananas
16:03:03 <benmachine> indeed
16:03:11 <conal> @hackage MemoTrie
16:03:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MemoTrie
16:03:13 <pumpkin> not sure about that
16:03:15 <benmachine> heh
16:03:17 <benmachine> it compiles :P
16:03:20 <pumpkin> let me think of how I'd do it
16:03:52 <benmachine> you could be right though
16:03:56 * benmachine goes back to the do
16:03:58 <Cale> http://www.superpoop.com/072009/banana-visiting-hours.jpg -- did someone say bananas?
16:04:17 <pumpkin> o.O
16:04:52 <BONUS> hahah
16:04:59 <BONUS> that's B-A-N-A-S!
16:05:18 <BONUS> forgot a N-A
16:05:22 <BONUS> ugh
16:06:00 <pastah> this channel is going apeshit crazy
16:06:14 <inimino> or did you forget A-N?
16:06:42 <BONUS> haha
16:06:46 <mike-burns> http://arcanux.org/lambdacats/catamorphism.png -- oh yes, someone said bananas.
16:07:26 <redocdam> is there any effort going into putting some trie implementation into the standard library?
16:09:17 <bd_> redocdam: Data.IntMap is implemented as a binary trie
16:11:10 <redocdam> thanks, I'll look at that
16:11:29 <redocdam> I was wondering about implementing a HAT-trie
16:11:38 <redocdam> just to have something to do
16:14:12 <pumpkin> benmachine: I have my version
16:14:27 <benmachine> go on
16:14:35 <pumpkin> benmachine: two bananas are fine, but let me see if it's equivalent to yours
16:15:03 <pumpkin> it might be actually, but I think banana would look nicer if written infix
16:15:16 <pumpkin> yeah it is equivalent :)
16:15:22 <erikc> banana . split
16:15:25 <Vanadium> Why can I not turn (\x y -> printf "%d, %d\n") a b into (uncurry $ printf "%d, %d\n") (a, b)? :(
16:15:48 <benmachine> pumpkin: banana = (=<<) >_>
16:15:58 <pumpkin> benmachine: yeah, but I just meant `banana`
16:16:04 <benmachine> m
16:16:04 <pumpkin> > (uncurry $ printf "%d, %d\n") (15, 2)
16:16:06 <lambdabot>   Add a type signature
16:16:07 <benmachine> I guess so
16:16:18 <pumpkin> > (uncurry printf $ "%d, %d\n") (15, 2)
16:16:20 <lambdabot>   Couldn't match expected type `(GHC.Base.String, b)'
16:16:38 <Vanadium> I am trying to be compact here :C
16:16:39 <pumpkin> > (uncurry $ printf "%d, %d\n") (15 :: Int, 2 :: Int)
16:16:41 <lambdabot>   Add a type signature
16:16:42 <caxaf> > (uncurry $ printf "%d, %d\n") (15, 2) :: String
16:16:43 <lambdabot>   "15, 2\n"
16:16:47 <pumpkin> aha :)
16:17:28 <benmachine> @type printf
16:17:30 <lambdabot> forall r. (PrintfType r) => String -> r
16:17:40 <benmachine> hmm
16:17:47 <pumpkin> it's a weird type
16:17:58 <Vanadium> I am really trying to write main = forM_ (zip [1..] $ take 32 fibs) $ uncurry $ printf "n=%d => %d\n" where fibs = zipWith (+) (1:fibs) (1:1:fibs)
16:17:58 <benmachine> I was just wondering how you'd write sprintf
16:17:59 <pumpkin> @instances PrintfType
16:18:00 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
16:18:04 <benmachine> I can't see an easy way
16:18:04 <pumpkin> benmachine: it already is sprintf
16:18:11 <benmachine> pumpkin: yes but I mean
16:18:11 <Vanadium> I am not sure where to inject a type signature without messing this up.
16:18:18 <benmachine> unambiguously-sprintf
16:18:26 <pumpkin> oh
16:18:43 <pumpkin> you'd have to get rid of the IO () PrintfType instance I think :P
16:19:06 <caxaf> Vanadium: You often don't need an explicit type signature with printf -- just use what it returns as a String.
16:19:31 <caxaf> Oh, you had some code.
16:20:13 <caxaf> Vanadium: That code seems to work without an explicit type signature.
16:20:38 <Vanadium> caxaf: Whaaat.
16:20:56 <Vanadium> Perhaps my printf is defective~
16:21:50 <pumpkin> probably depends on whether you're in GHCI or not
16:21:55 <Vanadium> Ah. I am not!
16:21:57 <pumpkin> since GHCi has more defaulting
16:22:00 <Vanadium> Also my fibs definition appears to be slightly defective :D
16:22:09 <caxaf> Vanadium: Also, consider using zipWithM_.
16:22:14 <pumpkin> there's a shorter fibs btw
16:22:18 <pumpkin> if you're going for golf
16:22:25 <caxaf> «zipWithM_ (printf "n=%d => %d\n") [1..] (take 32 fibs)»
16:22:36 <Vanadium> I am going for a minimal example that is not slower than doing memoisation or whatever
16:22:59 <pumpkin> > fix ((0:) . scanl (+) 1)
16:23:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:23:01 <caxaf> > fix((1:).scanl(+)1)
16:23:03 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:23:16 <caxaf> Are there any that are shorter?
16:23:36 <pumpkin> > fix((1:).scanl1(+))
16:23:38 <lambdabot>   [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
16:23:41 <pumpkin> damn :P
16:23:47 <pumpkin> same length anyway
16:24:02 <Vanadium> caxaf: Thanks, anyway. That makes it easier.
16:24:24 <aavogt> @src scanl
16:24:25 <lambdabot> scanl f q ls = q : case ls of
16:24:25 <lambdabot>     []   -> []
16:24:25 <lambdabot>     x:xs -> scanl f (f q x) xs
16:25:00 <Vanadium> Aw, I still need the type signature. Come on, ghc :(
16:25:08 <oinc> stupid question guys
16:25:19 <Vanadium> Okay, uh, let me not use printf here
16:25:39 <oinc> if break is span (not . p) xs
16:25:50 <Vanadium> @pl \x y -> "a" ++ x ++ "b" ++ y ++ "c"
16:25:50 <lambdabot> (('a' :) .) . (. (('b' :) . (++ "c"))) . (++)
16:25:53 <oinc> then break is (span .not . p) xs
16:26:01 <oinc> am i rite?
16:26:02 <mike-burns> @src break
16:26:02 <lambdabot> break p =  span (not . p)
16:26:22 <mike-burns> @pl span (not . p)
16:26:22 <lambdabot> span (not . p)
16:26:36 <benmachine> @pl \p -> span (not . p)
16:26:37 <conal> @pl \ p -> span (not . p)
16:26:37 <lambdabot> span . (not .)
16:26:37 <lambdabot> span . (not .)
16:26:41 <conal> :)
16:26:47 <oinc> 0_o
16:26:56 <oinc> I'm wrong?
16:27:03 <benmachine> you are
16:27:18 <oinc> bloody hell
16:27:59 <pumpkin> lol
16:28:06 <benmachine> (span . not . p) xs is span (not (p xs))
16:28:26 <benmachine> whereas you want span (not . p) xs
16:28:42 <benmachine> the key being that span takes two arguments
16:28:54 <oinc> ahh
16:28:57 <oinc> got it
16:29:10 <caxaf> benmachine: Well, in pointless form, p shouldn't even be there.
16:29:48 <dschoepe_> caxaf: p is no an argument("a point") so it still has to be there
16:30:23 <pumpkin> it is an argument
16:30:38 <caxaf> dschoepe_: Hum? <oinc> then break is (span .not . p) xs
16:30:45 <pumpkin> @src break
16:30:45 <lambdabot> break p =  span (not . p)
16:31:06 <dschoepe_> ah, okay I should've read the stuff before first, my mistake
16:32:26 <dschoepe_> @type (span . (not .))
16:32:28 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:33:27 <jdrake_> hmm, itunes doesn't seem to perform very well with 18000 song library
16:34:32 <pastah> jdrake_: i bet you ripped all that music from CDs you own
16:34:42 <jdrake_> pastah: How did you know?
16:34:45 <blackh> jdrake_: RhythmBox performs well with a 9000-song library on an NFS mount. Use that instead.
16:35:13 <jdrake_> blackh: Rhythmbox is an abomination
16:35:22 <jdrake_> (that is ritualistically unclean)
16:35:31 <blackh> jdrake_: And iTunes isn't?
16:35:32 <BONUS> try mpd and the ncmpcpp front-end for mpd
16:36:00 <jdrake_> blackh: It is less so. Carbon is ritualistically cleaner than Gtk+
16:36:13 <jauaor> hello
16:36:15 <pastah> --> #haskell-blah?
16:36:21 <jdrake_> Cocoa of course is what the priests use :p
16:36:34 <desp> I'd like to write a function with the type  foo :: a -> b -> Bar a (fromNumToTypeNum b)
16:36:57 <desp> I.e. the type needs to depend on the value of the function parameter.
16:37:01 <pastah> desp: use @djin
16:37:09 <desp> Any ideas?
16:37:15 <jdrake_> @djin
16:37:15 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
16:37:16 <desp> pastah: no.
16:37:17 <BONUS> is fromNumToTypeNum supposed to be a type parameter?
16:37:35 <pikhq> foo :: (Bar c, fromNumToTypeNum d) => a -> b -> c a d b
16:37:56 <desp> BONUS: that's just pseudocode; it's supposed be to be some way of lifting a value into the type system.
16:38:01 <pikhq> Or something.
16:38:09 <BONUS> ah
16:38:43 <desp> If printf can have a type in Haskell, then this function should also be able to.
16:38:57 <pastah> @type printf
16:38:59 <lambdabot> forall r. (PrintfType r) => String -> r
16:39:01 <pumpkin> not necessarily
16:39:18 <pumpkin> printf's type doesn't depend on the value of the string parameter
16:39:29 <desp> pumpkin: no?
16:39:32 <pumpkin> even though we'd love for it to
16:39:43 <desp> Didn't Oleg write a printf that behaved that way?
16:39:45 <pumpkin> > printf "%d %d" 5 :: String
16:39:46 * desp goes off to look
16:39:47 <lambdabot>   "5 * Exception: Printf.printf: argument list ended prematurely
16:39:51 <jdrake_> printf is an abomination
16:40:01 <pumpkin> desp: he can't, but it can be done with TH/QQ
16:40:07 <pumpkin> desp: or with combinators
16:40:12 <pumpkin> but not with a string directly
16:40:16 <EvilTerran> desp, that wasn't a String parameter, that was more closely analogous to an HList
16:40:18 <jdrake_> It is monadically unclean, and it shall be unclean until evening.
16:40:27 <Saizan> desp: the typed printf takes a GADT for the format string, which has the right type
16:40:29 <EvilTerran> (a tuple built up from pairs and nil)
16:41:21 <Saizan> desp: however you can do something like what you want but it must return an existential type, since the type will be determined at runtime, by seeing the value
16:41:26 <pikhq> I am intrigued in how Oleg wrote his printf.
16:41:31 <pikhq> Intrigued and disgusted.
16:41:54 <EvilTerran> pikhq, oleg's work seems to get that reaction fairly oftem
16:42:28 <Saizan> the typed printf is quite sane, actually
16:42:52 <pikhq> EvilTerran: Heheh.
16:43:06 <conal> would someone remind me of the differences between (a) ForeignPtr and (b) Ptr with addFinalizer?
16:43:11 <desp> Saizan: but I see Olega has a typed printf in Haskell98...
16:43:20 <desp> Oleg*
16:43:38 <desp> Saizan: http://okmij.org/ftp/typed-formatting/FPrintScan.html#DSL-FIn
16:44:23 <Saizan> desp: yes, by encoding a gadts with a typeclass, more or less
16:44:34 <Saizan> desp: however see reifyIntegral here http://hackage.haskell.org/packages/archive/reflection/0.1.1/doc/html/src/Data-Reflection.html
16:45:36 <desp> What I'd like to do is write a raiseToPower function that returns a value with the base type also raised to the given power.
16:45:38 <lpsmith> pikhq: which version of printf?
16:45:51 <desp> I have type-level raising-to-power working on integers.
16:45:52 <pikhq> lpsmith: Oleg's.
16:45:52 <lpsmith> Oleg has many printfs
16:46:02 <pikhq> o.O
16:46:25 <desp> Saizan: thanks, looking.
16:46:49 <Vanadium> How comes printf can do the varargs thing, anyway?
16:47:10 <Twey> It's maaagic.
16:47:20 <Twey> At least, you'd be happier thinking that.
16:47:43 <ray> type maaaaaaagic o/~
16:47:50 <lpsmith> vanadium:  it's not that hard to do varargs in Haskell,  using typeclasses
16:48:19 <Saizan> Vanadium: PrintfType has instances for function types
16:48:38 <Vanadium> That seems cruel and unusual
16:48:50 <Twey> printf :: (PrintfType r) => String -> r, where r includes PrintfType r => Int -> r, PrintfType r => String -> r, String, and IO ()
16:49:03 <Twey> It is cruel and unusual
16:49:17 <Twey> And it relegates type-checking to runtime
16:49:24 <Twey> (essentially)
16:49:28 <Saizan> well
16:49:34 <Saizan> more parsing than typechecking
16:49:40 <Vanadium> Does the type-checking happen inside printf?
16:49:47 <Twey> Well, typechecking can only really be done after parsing
16:49:48 <Twey> Vanadium: Yes
16:49:55 <Twey> It just errors if it gets the wrong type
16:50:00 <Twey> > printf "%d" "hello"
16:50:01 <lambdabot>   Add a type signature
16:50:15 <Vanadium> > printf "%d" 1 2 3
16:50:16 <Twey> > printf "%d" "hello" :: String
16:50:17 <hzap> why do we even have the many kinds of type specifiers if it's going to be run time checked anyways?
16:50:19 <lambdabot>   Add a type signature
16:50:20 <lambdabot>   "* Exception: Printf.printf: bad argument
16:50:22 <Twey> There we go
16:50:27 <Saizan> the point is that the instance is chosen based on the type you give to prinft
16:50:28 <Vanadium> Oh
16:50:29 <Vanadium> > printf "%d" 1 2 3 :: String
16:50:31 <Saizan> *printf
16:50:31 <lambdabot>   "1* Exception: Printf.printf: formatting string ended prematurely
16:50:35 <Vanadium> Okay
16:50:38 <Vanadium> Neat.
16:50:43 <Twey> hzap: Because the types it take are specified by the string
16:50:49 <Saizan> and later it checks if the format string matches
16:50:50 <Twey> Really we should be able to write something much cooler with TH
16:50:55 <deech> Hi all, I have a non-working example of a network client here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7290#a7290. I'm trying to use ErrorT to handle the exceptions. Could someone take a look at it for me?
16:51:04 <desp> Saizan: I'm reading the paper now, and it looks like the exact thing I need.
16:51:13 <Saizan> Twey: it's already done, iirc
16:51:23 <hzap> for example, couldn't it be just "%a" for all types?
16:52:14 <Saizan> however printf doesn't do any typechecking "inside", unless by a very vague meaning of typechecking
16:52:41 <Twey> hzap: But then you can't do formatting and stuff
16:52:46 <Twey> Which is what printf is really for, anyway
16:53:18 <hzap> Twey: nothing stops you from using "%.3a" :) but my point is that the distinction between the s and d and f are pretty redundant
16:53:47 <Twey> If you use "%.3a" on a string, what happens?
16:53:54 <hzap> run time error
16:53:58 <hzap> or whatever
16:54:03 <Vanadium> .3 has a meaning for strings in C printf
16:54:03 <Twey> At least this way we do get type-checking, even if it's not until run-time
16:54:09 <dino-> I am reminded by this of TotalPrintF  http://hackage.haskell.org/packages/archive/liboleg/0.2/doc/html/Text-TotalPrintF.html
16:54:27 <hzap> it's meaningful in C because C is weakly typed
16:54:39 <dino-> Which I have not yet tried out.
16:54:41 <Twey> Hahaha, liboleg
16:54:46 <Twey> I am scared
16:54:57 <Vanadium> hzap: How is that?
16:54:57 <hzap> lol
16:55:26 <hzap> Vanadium: if you printf("%d", "blah") in C, things screw up, but if you try that in Haskell it's a runtime error
16:55:32 <Twey> dino-, does it do good type-checking?
16:55:33 <dino-> From examples on the cafe it looked pretty simple to use though.
16:55:38 <dino-> Twey: No idea.
16:55:44 * Twey installs
16:55:59 <Saizan> deech: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7290#a7294
16:56:00 <desp> liboleg :)
16:56:32 <Vanadium> hzap: Oh, I just wanted to point out that "%.3s" is meaningful in C for strings
16:56:38 <Vanadium> ie, .3 is not only used with floating point formatting
16:56:41 <hzap> Vanadium: oh didn't know that
16:56:51 <Vanadium> I think it just prints the first three characters of the string.
16:57:13 <Twey> Huh, we accept pattern guards in GHC with only a warning, even without the switch?
16:57:29 <pikhq> hzap: printf("%d", "blah") doesn't screw things up.
16:57:37 <pikhq> You just get a really weird float. :P
16:58:09 <pikhq> (in GNU C, you get a compiler error -- GCC typechecks printf)
16:58:11 <benmachine> printf("%s", 3) on the other hand...
16:58:23 <hzap> yeah mine was bad example
16:58:25 <pikhq> benmachine: GCC type error.
16:58:34 <benmachine> pikhq: gcc type *warning* :P
16:58:35 <Vanadium> I believe it ought to screw things up as far as interpreting an int as a char* or the other way around is an aliasing violation
16:58:46 <pikhq> benmachine: ... ITS A WARNING‽
16:59:06 <benmachine> pikhq: I believe so, could be wrong
16:59:15 <benmachine> you can always say -Werror if it bothers you
16:59:17 <flippeh_> Man, I had to learn Haskell to be able to understand some haskell tutorials :D
16:59:21 <deech> saizan, what is the difference between your version and mine? I made sure to use liftIO.
16:59:30 <flippeh_> Mad world... mad world..
16:59:34 <pikhq> I think I demand a strongly typed systems programming language.
16:59:42 <Saizan> deech: you used liftIO where you shouldn't :)
17:00:01 <hzap> test.c:2: warning: format argument is not a pointer (arg 2)
17:00:17 <hzap> so it's a warning
17:00:21 <desp> pikhq: I think I've seen one.
17:00:43 <pikhq> hzap: Geeesh.
17:00:50 <Saizan> deech: "throwError ServerNoResponse" is an action in the ErrorT Errors IO monad, so you don't want to liftIO it
17:00:59 <deech> saizan, oh so if I am adapting a function written entirely in the IO monad with Exception handling and I want to use ErrorT I have to break it up into little pieces?
17:01:02 <Saizan> deech: you've to liftIO only the IO actions
17:01:12 <Twey> Awesome.
17:01:37 <Saizan> deech: yeah, you've to liftIO only the IO parts
17:02:29 <Saizan> deech: another option is to stick in IO and make use of Control.Exception.Exception class, which let you define your own exceptions
17:02:50 <pumpkin> zomg interrobang
17:03:14 <deech> saizan, is there someway to use Control.Exception.throw to throw an error back up to the monad transformer?
17:03:17 <ray> interrobang should mean "strict, possibly"
17:05:07 <Saizan> deech: not really, unless you write a custom liftIO that catches the exceptions and puts them in the ErrorT, using Control.Exception.try
17:05:42 <Saizan> ?type ErrorT . Control.Exception.try
17:05:43 <lambdabot> forall e a. (GHC.Exception.Exception e) => IO a -> ErrorT e IO a
17:05:50 <pikhq> pumpkin: Interrobang‽
17:05:57 <pumpkin> zomg!
17:05:59 <pumpkin> there it is again
17:06:00 <pikhq> Gnaborretni!
17:06:21 <ray> InterrobangPatterns
17:06:47 <aavogt> strictly implicit
17:09:50 <Nafai> Hey sm
17:10:13 <sm> hey Nafai
17:20:25 <desp> Saizan: there's one thing I don't see yet.
17:21:07 <desp> Saizan: given the reifyFoo function that takes a value and a continuation, what's the initial continuation I should pass to it?
17:22:17 <ManateeLazyCat> How to transform [a, b, c] to [(a,0), (b, 1), (c,2)] ?
17:22:25 <ManateeLazyCat> Use zip
17:22:25 <desp> Saizan: and how do I actually use the reified value?
17:22:29 <ManateeLazyCat> :t zip ['a','b','c'] [0,1,2]
17:22:32 <lambdabot> forall t. (Num t) => [(Char, t)]
17:23:11 <Saizan> desp: the initial continuation is the one that wants to use that value/type
17:23:42 <Saizan> desp: you use the type with the typeclass methods
17:24:07 <Saizan> desp: do you know how existentials work?
17:24:08 <pastah> ManateeLazyCat: why ask questions you know the answer to?
17:24:25 <desp> Saizan: no, I haven't touched them before.
17:24:27 <ManateeLazyCat> pastah: I find how to do that after i ask. :)
17:24:39 <desp> ManateeLazyCat: invest in a rubber duck. ;)
17:24:56 <ManateeLazyCat> heh
17:25:07 <pastah> ManateeLazyCat: http://www.c2.com/cgi/wiki?RubberDucking
17:25:11 <aavogt> > (subtract 40) $ ord 'a'
17:25:13 <lambdabot>   57
17:25:31 <Saizan> desp: ok, so i'll continue explaining without them :)
17:25:39 <aavogt> > (subtract 96) $ ord 'a'
17:25:41 <desp> Saizan: reading up on them now :)
17:25:41 <lambdabot>   1
17:26:14 <Saizan> desp: since the type is created from the value it can't be known statically (since the value will only be seen at runtime, even if it's constant)
17:26:26 <desp> Right.
17:26:37 <Saizan> desp: so only a function that's polymorphic can accept it
17:26:58 <Saizan> desp: that's why we have the forall in the type of the continuation
17:27:02 <desp> Aha.
17:27:35 <Saizan> then we add a typeclass context so that the continuation can do something with it
17:29:00 <pumpkin> :t uncurry flip
17:29:02 <lambdabot> forall a b c. (a -> b -> c, b) -> a -> c
17:29:05 <pumpkin> ew
17:29:05 <Saizan> with (forall a. a -> r) -> r, the continuation can't touch its argument because it doesn't know anything about it
17:29:18 <pumpkin> what's the most elegant pair flipper?
17:29:21 <pumpkin> snd &&& fst?
17:29:33 <Twey> uncurry flip
17:29:39 <pumpkin> that doesn't work
17:29:39 <Saizan> flip (uncurry (,))
17:29:40 <Twey> :t uncurry flip
17:29:42 <lambdabot> forall a b c. (a -> b -> c, b) -> a -> c
17:29:43 <Saizan> ?type flip (uncurry (,))
17:29:44 <lambdabot>     Couldn't match expected type `b -> c'
17:29:45 <lambdabot>            against inferred type `(a, b1)'
17:29:45 <lambdabot>     In the first argument of `flip', namely `(uncurry (,))'
17:29:47 <Twey> Hmph
17:30:03 <pumpkin> :t uncurry (flip (,))
17:30:05 <lambdabot> forall b a. (a, b) -> (b, a)
17:30:10 <Saizan> yeah, that.
17:30:19 <Twey> @let flp = uncurry $ flip (,)
17:30:21 <lambdabot>  Defined.
17:30:25 <aavogt> @unpl uncurry $ flip (,)
17:30:26 <lambdabot> (uncurry (\ b c -> (,) c b))
17:30:32 <Twey> @let frmLst [a, b] = (a, b)
17:30:34 <lambdabot>  Defined.
17:30:38 <aavogt> @. unpl unpl uncurry $ flip (,)
17:30:39 <lambdabot> (uncurry (\ b c -> (,) c b))
17:30:42 <desp> Saizan: so... I thought this would work:
17:30:46 <desp> test a = reifyTypeNat a (\(b :: (forall t . (TypeNat t) => t) -> reflectTypeNat (undefined :: t))
17:31:01 <pikhq> @. pl unpl uncurry $ flip (,)
17:31:02 <lambdabot> uncurry (flip (,))
17:31:27 <Saizan> desp: the type on the lambda is wrong
17:31:56 <Saizan> desp: but you can just use reflectTypeNat as continuation, no?
17:33:28 <Saizan> assuming the result of it doesn't mention the type of its argument
17:34:45 <desp> Indeed I can...
17:35:14 * desp is confused a bit.
17:35:18 <desp> Thanks, though.
17:35:30 <desp> What was wrong with the type on the lambda?
17:36:05 <Saizan> that annotation on 'b' specifies it as a polymorphic value
17:36:15 <Saizan> while 'b' isn't
17:36:51 <Saizan> otherwise the type of the whole lambda would be (forall t. TypeNat t => t) -> r instead of forall t. TypeNat t => (t -> r)
17:36:51 <desp> Aha.
17:37:22 <Saizan> (parens added for emphasis in the latter type)
17:37:50 <desp> Thanks!
17:37:59 <desp> This has been most enlightening.
17:38:14 <Saizan> np :)
17:39:05 <Saizan> if you get this you also know how to deal with existentials, since they are isomorphic to this polymorphic continuation pattern
17:40:03 <BioShock^> Hey, join in channel #r00tsecure ! PLEASE !
17:40:11 <Saizan> data AnyTypeNat where AnyTypeNat :: forall t. TypeNat t => t -> AnyTypeNat
17:41:09 <Saizan> case reifyTypeNat a of AnyTypeNat t -> reflectTypeNat t
17:41:29 <Saizan> (if you adjust reifyTypeNat accordingly)
17:52:12 <pumpkin> @pl \(x, (y, z)) -> (y, (x, z))
17:52:13 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip ((.) . (,)) . (,))
17:52:28 <pumpkin> @type \(x, (y, z)) -> (y, (x, z))
17:52:30 <lambdabot> forall t t1 t2. (t, (t1, t2)) -> (t1, (t, t2))
17:53:08 <ray> @pl \(v,(w,(x,(y,z)))) -> (z,(y,(x,(w,v))))
17:53:11 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . (((.) . (flip (,) .) . flip (,)) .) . flip (,)) .) .
17:53:11 <lambdabot> flip (,))
17:53:11 <lambdabot> optimization suspended, use @pl-resume to continue.
17:53:18 <LeoD> oh god
17:53:31 <ray> <3 @pl
17:53:52 <Saizan_> mmh
17:54:03 <Saizan_> i wonder if we could make an esolang out of @pl
17:54:22 <pumpkin> @type (fst . snd &&& second snd)
17:54:24 <lambdabot> forall a b a1. (a1, (a, b)) -> (a, (a1, b))
17:54:33 <pumpkin> that's not so bad
17:55:24 <pumpkin> sure beats that nasty @pl output
17:55:51 <ray> @users
17:55:52 <lambdabot> Maximum users seen in #haskell: 658, currently: 602 (91.5%), active: 15 (2.5%)
17:56:19 <pumpkin> what I'm trying to do elegantly
17:56:28 <pumpkin> is "invert" nested IntMap
17:56:42 <pumpkin> so I have IntMap (IntMap a)
17:56:45 <aavogt> @type \f -> (,) `ap` f
17:56:47 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
17:57:32 <pumpkin> :t strength
17:57:34 <lambdabot> Not in scope: `strength'
17:58:14 <pumpkin> > let strength = fmap . (,) in uncurry strength
17:58:16 <lambdabot>   Overlapping instances for GHC.Show.Show ((a, f a1) -> f (a, a1))
17:58:16 <lambdabot>    arising...
17:58:29 <pumpkin> aha
17:58:32 <pumpkin> just what I need
18:04:00 <pumpkin> transpose (Graph v e) = Graph v . IM.fromListWith IM.union . map (second (uncurry IM.singleton) . (fst . snd &&& second snd)) . concatMap (strength' . second IM.toList) . IM.toList $ e
18:04:02 <pumpkin> holy crap :P
18:04:45 <LeoD> wow
18:04:52 <pumpkin> surely there's something nicer than that :P
18:05:28 <pumpkin> all I'm doing is inverting nested maps :(
18:05:31 <bd_> yes, sometimes it's not worth it to make things point-free :)
18:05:48 <pumpkin> it's complicated even if it isn't point-free
18:05:53 <pumpkin> this isn't very point-free
18:06:11 <Saizan_> mmh
18:06:26 <pumpkin> I bet Saizan_ has a better way of doing it
18:06:34 <pumpkin> :P
18:06:44 <Saizan_> actually, i've also found that shuffling tuples around gets messy easily
18:07:09 <Saizan_> though maybe a list comprehensions might help here?
18:07:16 <pumpkin> ah true
18:07:23 <pumpkin> I forget about those periodically
18:07:34 <pumpkin> anyway, gonna go get food and ponder while I walk :P
18:07:35 <pumpkin> bbiab
18:12:04 <Saizan_> ?type Data.IntMap.singleton
18:12:06 <lambdabot> forall a. IM.Key -> a -> IM.IntMap a
18:15:28 <Saizan_> Graph v . IM.fromListWith IM.union $ [(b, IM.singleton a c) | (a,m) <- IM.toList e, (b,c) <- IM.toList m ] ?
18:17:09 <ManateeLazyCat> Find function that transform [a] to [0, 1, 2, 3, ... n], (n + 1) is the length of [a]
18:17:53 <Cale> ManateeLazyCat: Is that a question for anyone in particular?
18:17:53 <Saizan_> zipWith const [0..]
18:18:06 <ManateeLazyCat> Cale: Yep
18:18:14 <Cale> Saizan got it :)
18:20:03 <ManateeLazyCat> :t zipWith const [0i]
18:20:05 <lambdabot> forall a b. (Num (Expr -> a)) => [b] -> [a]
18:22:02 <ManateeLazyCat> Why in ghci i got "Not in scope: `i' " ?
18:23:34 <mike-burns> Because you entered [0i] instead of [0..]
18:24:16 <ManateeLazyCat> mike-burns: Have different? I can't see
18:25:08 <Cale> ManateeLazyCat: i is a letter, .. is two periods
18:25:22 <mike-burns> Is your IRC client turning .. into i ? It should be [ 0 . . ] without the spaces.
18:25:41 <ManateeLazyCat> mike-burns: Yep, my IRC client got two `i` letter
18:25:50 <Cale> ahaha, is it morse code?
18:26:01 <pikhq> I'd file a bug report or something.
18:26:03 <Cale> .... . .-.. .-.. ---
18:26:34 <Cale> .. is i in morse code
18:26:59 <ManateeLazyCat> Cale: I know, my IRC enable morse code transform.
18:27:13 <ManateeLazyCat> Cale: It will transform morse code automatically.
18:27:22 <Cale> ManateeLazyCat: that would be your problem then :)
18:27:44 <ManateeLazyCat> Cale: I think i should turn off it. :)
18:28:30 <ManateeLazyCat> :t zipWith const [0..]
18:28:32 <lambdabot> forall a b. (Num a, Enum a) => [b] -> [a]
18:28:48 <ManateeLazyCat> Oh, yep, it's two `.` and not `i`.
18:29:00 <wmealing_> for great justice.
18:32:36 <ManateeLazyCat> Saizan_: Thanks! Your function is nice.
18:33:22 <uman> how can I install cabal packages on debian?
18:33:40 <uman> like what is the name of the cabal package, assuming there is one in the repos
18:34:36 <ManateeLazyCat> uman: Install three package 'HTTP` `zlib` `cabal-install`
18:34:41 <ManateeLazyCat> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
18:34:45 <ManateeLazyCat> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
18:34:49 <ManateeLazyCat> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
18:34:56 <ray> you may want to ignore the debian package system, if you aren't already
18:35:17 <QtPlaty[HireMe]> I'm using haskel mode under emacs, why does it keep ":cd"ing to ~/.cabal before it loads files?
18:35:21 <uman> ray: why's that?
18:35:24 <ManateeLazyCat> uman: Then execute command "ghc --make Setup && ./Setup configure && ./Setup build && sudo ./Setup install " for install those packages.
18:35:48 <uman> ray: why's that?
18:35:48 <ray> because it's a pain
18:35:52 <uman> sorry for double post
18:36:32 <ray> using cabal is much nicer
18:36:38 <ray> cabal the program
18:36:45 <uman> ray: heh, I just got done using Linux from Scratch
18:36:54 <uman> finally decided to repartition and install an easy distro
18:36:59 <uman> borked my LFS partition by accident in the process
18:37:14 <pikhq> Gentoo
18:37:14 <uman> so anything an easy distro like debian does, will automatically not seem like a pain to me
18:37:15 <mike-burns> Aha! I knew I had seen that typeclasses are most comparable to OO interfaces: http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/ECOOP-July09.pdf
18:37:23 <ray> trust me, it's a pain
18:37:30 <ManateeLazyCat> uman: Cabal is package manager of Haskell packages like apt-get for debian.
18:37:31 <ray> and i think you might still be stuck with ghc 6.8
18:37:38 <uman> ManateeLazyCat: I know
18:37:50 <ManateeLazyCat> uman: So just use cabal
18:37:56 <ray> i use the generic ghc binary and cabal-install for libraries
18:38:13 <ManateeLazyCat> uman: In Debain ghc is 6.8, but i use ghc-6.10.4
18:38:28 <uman> ManateeLazyCat: Yes, I was asking how to install Cabal
18:38:30 <ManateeLazyCat> uman: Haskell package is TOO OLD in Debian sources.
18:38:37 <ManateeLazyCat> uman: I told you.
18:38:41 <uman> ManateeLazyCat: I know
18:39:07 <ManateeLazyCat> uman: Download three package `HTTP` `zlib` `cabal-install`, then compile them
18:39:19 <vav> uman: sid has 6.10.3 but yes, I agree cabal-install is the way to go for most stuff
18:39:32 <ManateeLazyCat> compile command is "ghc --make Setup && ./Setup configure && ./Setup build && sudo ./Setup install"
18:40:36 <ManateeLazyCat> uman: Compile sequence is `HTTP` -> `zlib` -> `cabal-install`.
18:42:02 <ManateeLazyCat> uman: After you compile complete, just use command "cabal update" update package list first, then use command "cabal install foo" to install any package you want.
18:43:07 <uman> ugh, I also need to install network and parsec before installing HTTP
18:44:12 <ManateeLazyCat> uman: First install GHC binary package, then install above three packages.
18:44:20 <uman> ManateeLazyCat: ah, debian had packages for it
18:44:32 <ManateeLazyCat> uman: GHC in debian is too OLD
18:44:39 <uman> ManateeLazyCat: why?
18:44:55 <ManateeLazyCat> uman: http://www.haskell.org/ghc/download_ghc_6_10_4.html
18:44:56 <uman> have there been important major changes since 6.8.2?
18:45:02 <uman> I understand but why bother downloading
18:45:05 <uman> what does 6.10 offer
18:45:20 <ManateeLazyCat> uman: 6.10.4 is current version
18:45:35 <ManateeLazyCat> uman:  6.8 is REALLY old.
18:45:49 <uman> ManateeLazyCat: that doesn't answer my question: what are the differences
18:46:21 <ManateeLazyCat> uman: See Releases notes, too many
18:46:27 <uman> ok
18:46:47 <uman> cabal-install says it requires Cabal version >= 1.4
18:46:54 <uman> however I already installed Cabal-1.6.0.2
18:46:56 <uman> what gives
18:47:00 * BMeph|out facepalms
18:47:15 <ManateeLazyCat> uman: Just install GHC binary from http://www.haskell.org/ghc/download_ghc_6_10_4.html first.
18:47:15 <Cale> uman: http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/release-6-10-1.html -- this is the release notes for 6.10.1 vs. 6.8.3
18:47:41 <ManateeLazyCat> uman: Then you can compile above three packages and won't any require.
18:48:00 <wmealing_> After getting over the initial hurdle of syntax and functional programming, does anyone else feel that their applications are simpler in haskell or is it just me ?
18:48:16 <wmealing_> (admittedly i come from a c background)
18:48:31 <jaredj> wmealing_: after parsing things with parsec, i can't think of another way to do it anymore
18:48:34 <Cale> wmealing_: Yes, much simpler.
18:48:58 <pikhq> wmealing_: I feel as though I achieved enlightenment.
18:49:08 <uman> alright alright, I'll get it :D
18:49:13 <jaredj> speaking of enlightnemtntn
18:49:14 <BMeph> pikhq: Parse-vaana? ;)
18:49:29 <pikhq> BMeph: Haven't learned Parsec yet.
18:49:29 <uman> i just hate bypassing my package manager... always creates problems
18:49:34 <uman> but I guess I will make an exception
18:49:42 <jaredj> http://patch-tag.com/r/ofx1/snapshot/current/content/pretty/Text/OFX1.hs
18:49:50 <pikhq> I intend to, though; should make esolang development much nicer.
18:49:52 <jaredj> can anyone tell me if this is a bad use for type classes?
18:49:55 <wmealing_> well, i'm not quite at that level. but ok.
18:49:57 <BMeph> pikhq: Ah, then you have Hask-tori, then. ;)
18:50:06 <pikhq> Hask-tori?
18:50:09 <Cale> wmealing_: I wrote a program which was about 1200 lines, maybe half of which were comments, and it would have been probably 50000 lines of C.
18:50:27 <BMeph> pikhq: Hask(ell Sa)tori
18:50:41 <Cale> (and I wouldn't have been able to write it in the given time frame at all)
18:50:43 <pikhq> The expansion is unexplanatory.
18:50:55 <ManateeLazyCat> wmealing_: Yep, like Cale saied, Haskell save your code lines,
18:51:15 <ManateeLazyCat> wmealing_: And give your clearer logic
18:51:25 <copumpkin> I love me some clear logic
18:51:35 <pikhq> And as we all know, lines of readable code is, in fact, an *inverse* metric.
18:51:49 <thoughtpolice> copumpkin had his arrows reversed again? :)
18:52:08 <copumpkin> thoughtpolice: it was mornfall earlier :(
18:52:11 <jaredj> most of them should be unreadable? (;
18:52:12 <copumpkin> oh wait, they're fixed
18:52:17 <copumpkin> yay
18:52:21 <pikhq> jaredj: No.
18:52:43 <BMeph> pikhq: satori = "(personal) enlightenment" in Japanese -- as opposed to enlightenment about everything. To get that, you need a Buddhist pizza shop
18:52:43 <pikhq> There should be few lines, and they should be readable.
18:52:49 <Cale> Especially cases where you really *need* laziness, the difference in the amount of code you'd have to write is huge.
18:52:58 <pikhq> BMeph: A word in Japanese I didn't know.
18:53:05 <pikhq> I need to go back to studying Japanese. XD
18:53:05 <wmealing_> yay pizza
18:53:06 * QtPlaty[HireMe] guesses no-one knows.
18:53:07 <jaredj> om nom nom?
18:53:11 <Cale> 悟り
18:53:20 <pikhq> QtPlaty[HireMe]: Kio?
18:53:21 <shapr> @yow !
18:53:22 <lambdabot> I would like to urinate in an OVULAR, porcelain pool --
18:53:23 <tkr> lots of perl people here.
18:53:31 <ManateeLazyCat> Cale: Are you understand Japanese?
18:53:44 <ray> there is also satori the species
18:53:44 <Cale> ManateeLazyCat: I'm learning it :)
18:53:46 <shapr> tkr: Are you a perl people?
18:53:49 <QtPlaty[HireMe]> pikhq: My struggles with haskel mode.
18:53:50 <tkr> shapr: yes.
18:54:03 <ManateeLazyCat> Cale: Are you understand Chinese?
18:54:09 <Cale> Not really.
18:54:15 <ray> they can read minds
18:54:29 <shapr> tkr: Are you a Haskell people?
18:54:34 <ManateeLazyCat> Cale: In Japanese, have many Chinese word.
18:54:50 <copumpkin> indeed!
18:54:50 <ManateeLazyCat> Cale: Like 悟 is Chinese word
18:54:51 * QtPlaty[HireMe] has seen the cross population between the perl and haskell communities.
18:54:55 <tkr> shapr: learning to be.
18:55:01 <Cale> ManateeLazyCat: yeah, I can recognise some Chinese characters like that already :)
18:55:02 <wmealing_> i'm not a haskell person, i'm a real boy!
18:55:04 <shapr> spiffy!
18:55:10 <tkr> shapr: about perl, chinese, larry wall etc. very interesting article: http://oreilly.com/catalog/opensources/book/larry.html
18:55:17 <ray> hascerl mode
18:55:24 <BMeph> ManateeLazyCat: For Chinese, ask monochrom. :)
18:55:28 <ray> wait, that'd be erlang
18:55:34 <Cale> ManateeLazyCat: But I don't really know how they'd be pronounced in Mandarin, or any of the grammar.
18:56:00 <ManateeLazyCat> Cale: Sound like woo
18:56:26 <BMeph> pikhq: Look for the author "Dennis Schmidt"; "Satori" is the title of one of his books. It's a good series. :)
18:56:28 <copumpkin> japanese doesn't use that "I" character does it? I'm assuming it's "I"
18:56:34 <tkr> shapr: larry wall just rocks. :) Im still very new to Haskell, but Im trying to learn, and am not 'unknowledgeable' about currying etc high-order stuff.
18:56:36 <copumpkin> I know the one for watashi, boku, and ore
18:56:41 <copumpkin> and it's none of those
18:56:50 <Cale> 私、僕、俺
18:56:54 <Badger>  
18:57:05 <ike_> exactly (from a Japanese)
18:57:07 <ray> you mean 我?
18:57:17 <Cale> 我 is used in Japanese too
18:57:24 <ManateeLazyCat> Cale: In Japanese have many Chinese word, the only different is their's pronounced, them have same mean between Chinese and Japanese in generic.
18:57:39 <copumpkin> yeah, but I've never seen 悟 in japanese
18:57:41 <ManateeLazyCat> Cale: Yep 我 is me, and Chinese is this .
18:57:43 <copumpkin> is what I meant
18:57:58 <copumpkin> but I'm not very well read in japanese :P
18:58:08 <ManateeLazyCat> Cale: I think 停车场 is same mean between Chinese and Janpanese.
18:58:15 <ray> copumpkin: now you have
18:58:18 <Cale> copumpkin: 悟り is さとり
18:58:20 <hzap> sometimes it's possible to guess sort of what a japanese sentence is talking about, for a Chinese person
18:58:25 <copumpkin> ManateeLazyCat: too much simplification :P
18:58:31 <Cale> ManateeLazyCat: funny simplified characters ;)
18:58:32 <shapr> tkr: Welcome to the community! There's definitely more than one way to explore the world.
18:58:36 <copumpkin> Cale: aha
18:58:42 <copumpkin> sounds profound
18:58:48 <tkr> shapr: thank you. :)
18:58:49 <ManateeLazyCat> 这个频道有中国人吗？
18:58:54 <ManateeLazyCat> 我是中国人
18:58:55 <hzap> simplified characters are awesome
18:59:00 <uman> Would it be acceptable to install the Debian ghc package from sid, or must I get it directly from the ghc website
18:59:09 <shapr> I use Debian's ghc
18:59:27 <copumpkin> anyway, bbl
18:59:54 <ManateeLazyCat> Cale: What's mean "悟り is さとり"? I can't understand Japanese.
18:59:57 * BMeph looks at shapr funnily
18:59:58 <wmealing_> uman, use the local version until you have a problem.  Choose the path of least resistance.
19:00:09 <Cale> 道有中国人 and 是 I recognise.
19:00:15 <tkr> shapr: Im currently only reading http://learnyouahaskell.com/, maybe I will be wiser after finishing that one. :)
19:00:16 * BMeph is funny-looking already, though, so you can hardly tell...
19:00:22 <Cale> ManateeLazyCat: comprehension, understanding, enlightenment
19:01:04 <monochrom> 频道 = channel
19:01:34 <ManateeLazyCat> Cale: I saw you join ##English, what's it? It teach English?
19:01:45 <monochrom> more precisely 频道 = frequency channel, generalized to electronic communication channel
19:01:48 <Cale> ManateeLazyCat: yeah
19:01:57 <Cale> ManateeLazyCat: I sometimes help out there. :)
19:01:57 <BMeph> ManateeLazyCat: What English speakers mean when they say "a-ha!" :)
19:02:05 <ManateeLazyCat> Cale: I should join it, my English is very bad sometimes. :)
19:02:48 <monochrom> since 海峽 = channel too, but the water kind
19:03:16 <tkr> Cale: I read about you from Autrijus Tang's article. It doesnt sounds like that you only 'sometimes' help out there :)
19:03:25 <ManateeLazyCat> monochrom: 海峡 is water channel between two land or island.
19:03:36 <Cale> tkr: ehh? There was an article about me?
19:03:54 <BMeph> I recognize that first ideogram as "sea/ocean", right?
19:03:54 <Cale> tkr: I've only joined ##English kind of recently.
19:04:08 <ManateeLazyCat> tkr: Autrijus Tang? The author of puge?
19:04:52 <ray> how rude, writing an article about someone without telling them
19:05:05 <tkr> ManateeLazyCat: yes, the one.
19:05:10 <tkr> Cale: I think it mentioned you
19:06:11 <monochrom> Yes BMeph
19:06:35 <tkr> Cale: ahh. here. http://www.perlmonks.org/?node_id=520826 :)
19:06:49 <tkr> Cale: I find many references to you just using trivial googling.
19:07:05 <tkr> 'I'd like to thank the helpful IRC #perl6 folks (especially audreyt, luqui, gaal, aufrank, nnunley) for answering my questions and Cale Gibbard of Haskell-Cafe for explaining Control.Exception.evaluate to me.'
19:07:26 <pikhq> Pugs.
19:07:27 <tkr> ah. that wasnt tang's, but there are ones with references to you by Tang also. :)
19:07:37 <Cale> tkr: Ah, I've been helping out in the Haskell and IRC math communities for much longer.
19:08:03 <tkr> Cale: nods. I also remember you from #math :) asking my silly questions about complex analysis, riemann surfaces etc
19:08:53 <ManateeLazyCat> Cale: You also teach mathematics?
19:09:42 <Cale> ManateeLazyCat: yeah, sometimes :)
19:09:44 <tkr> Cale: thank you for all your help this far. maybe I will start asking about Haskell in the future also. :)
19:09:54 <Cale> tkr: great :)
19:10:09 <ray> @quote contrapuntal
19:10:10 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
19:10:20 <gwern> @quote stereo
19:10:20 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
19:10:25 <gwern> -_-
19:10:33 <gwern> I deserved that
19:10:37 <wmealing_> Cale, I'm jealous of your fu.
19:10:40 <tkr> Cale: Im a great math enthusiastic also. :) never studied the shit, but I find it very fascinating.
19:10:41 * wmealing_ tips his hat
19:10:41 <ray> contrapuntal is better anyway
19:10:43 <ManateeLazyCat> Cale: My mathematics is not very good, maybe i will ask you mathematics sometimes
19:10:45 <ManateeLazyCat> :)
19:11:38 <tkr> Cale: especially my heart is very close to complex analysis. :) I just love (the first 200 pages that Ive read this far of) Penrose's Road to Reality. :)
19:12:50 <Cale> tkr: Hmm, I haven't seen that one. Needham's "Visual Complex Analysis" is rather good too, if you're looking for more ;)
19:12:53 <thoughtpolice> tkr: it's a good, but very dense book
19:13:17 <thoughtpolice> i gave up somewhere in the first chapter after deciding I should spend more time on actual course work, but I plan to revisit it :)
19:14:07 <tkr> Cale: and also Visual Complex analysis by Needham I like very much. :) as I havent studied this stuff officially, just as a hobby.
19:14:14 <monochrom> Stereo is so 20th century anyway. If anything it should be something like 7.1 by now. The 1 there is lambdabot. :)
19:14:35 <tkr> thoughtpolice: nahh. I disagree. you should read it BEFORE actually studying the stuff. :)
19:14:57 <tkr> Cale: heh. :)
19:15:08 <tkr> Cale: I wrote this before reading your comment :)
19:15:41 <tkr> Cale: about Visual Complex Analysis I especially love the chapters 10-13. :)
19:17:05 <SamB> tkr: does it have four-dimensional popups?
19:17:14 <tkr> Cale: this was my first enlightement about maths: http://rehn.fi/euler.txt :) I still have a lot of notes about this thing. all started after reading betterexplained.com :)
19:17:59 <tkr> SamB: what? no idea. only thing about four-dimensional thing that ever drew my attention was about Quaternions :) what are 4 dimensional popups?
19:18:22 <ManateeLazyCat> Cale: ##English is very funny, i got a American that want study Chinese.
19:18:41 <Cale> :)
19:19:41 <SamB> tkr: oh, I was juste thinking if you need 2D pictures to understand normal derivatives, surely you need 4D pictures to understand complex ones!
19:19:47 <tkr> Cale: http://rehn.fi/hyperbolic.txt :) I think I got the answer to this one, but not clearly explained in the language of mathematics (if you happen to know the answer)
19:20:16 <ray> they have these argand diagram things i never understood for 4D things
19:20:30 <tkr> SamB: I dont think you can offer me what I need if you have officially studied mathematics. I find the dudes, who are able to explain this stuff, very rare. :)
19:21:03 <SamB> tkr: oh, mostly not officially
19:21:33 <tkr> Cale: http://oreilly.com/catalog/opensources/book/larry.html look for 'like to talk about triangles' :)
19:22:14 <SamB> I was just figuring you'd need 2 axes for the "Δx" bit, and 2 more axes for the "Δy" bit!
19:23:09 <tkr> SamB: Im still using latin-1 so Im only seeing "?x" and "?y" here.. :/
19:23:22 <ray> those were deltas
19:23:26 <ray> fix your computer :P
19:23:47 <tkr> I should. but I still irc a lot on ircnet, where the finnish dudes still are forced to use latin1
19:23:57 <tkr> (by other finnish dudes)
19:24:39 * SamB wonders how to type snowman
19:24:43 <jaredj> i have a question about classes.
19:24:48 <ray> pff, ircnet
19:24:56 <ManateeLazyCat> I really hate Emacs, erc crash again....
19:25:03 * ray is an efnet supporter
19:25:36 <jaredj> most classes already in Haskell are about attributes that types share
19:25:42 <tkr> ray: well. when I started ircing, there was only one network. its not my fault, that the network didnt work well enough for to be able not to split it to different parts :)
19:25:57 <ray> you were on the wrong side of the netsplit!
19:26:02 <jaredj> i made a class not based on ontology but because i wanted to make a particular operation work for several gadt's
19:26:05 <jaredj> is that bad?
19:26:23 <ray> i doubt it's bad
19:26:27 <SamB> what the heck is ircnet?
19:26:39 <pikhq> The original IRC network.
19:26:39 <SamB> tkr: you should have Cd more
19:26:50 <SamB> they call it an RFC for a reason, you know!
19:27:03 * SamB still hasn't figured out what that reason is, though
19:27:20 <ray> because they're requesting comments
19:27:40 <SamB> ray: yeah, I know what it stands for
19:27:44 <jaredj> furthermore: my gadt is full of Maybe everything, and it's filled by a parser which parses a large element which can contain smaller elements in any order. the stateful parser starts with a state of everything being Nothing
19:27:48 <tkr> SamB: cd ?
19:27:55 <SamB> tkr: Commented
19:28:13 <tkr> anyhow, this is getting rather off topic. Ill drop the discussion as I dont know the channel's habits very well yet.
19:28:15 <ray> ircnet and efnet are like the roman catholic and eastern orthodox churches, but i'm not sure which is which
19:28:23 <ray> there is #haskell-blah for offtopic
19:28:29 <SamB> ray: best to stay clear of both ?
19:28:34 <jaredj> this means that semantically invalid documents will parse, leaving Nothing in places where there should be Just something and necessitating another layer of checking if i really wanted to make sure everything is correct
19:28:41 <ray> no, they can both claim to be "original"
19:29:06 <jaredj> ray: and they're on either side of a netsplit? ;)
19:29:09 <SamB> ray: but the Way was a heck of a lot different from the Roman Catholic church ...
19:29:32 <ray> yes!
19:29:38 <ray> the great schism was just a netsplit
19:29:38 <SamB> for instance, the Way got persecuted a lot more!
19:29:44 <SamB> was a lot less trendy, too
19:30:05 <jaredj> narrower?
19:30:12 <tkr> ray: yes it was. I remember using ./ll (link looker) when I was like 12 years old (Im almost 30 nowadays)
19:30:13 <SamB> kind of like Haskell in the old days :-(
19:30:41 <ray> i'm only 12 or so myself
19:30:45 <gwern> ray: efnet would be the eastern one, of course. efnet - eris net - discordianism <- heavily influenced by orientalism
19:30:51 <SamB> ray: you already can't remember?
19:30:57 <ray> eastern frorthodox network
19:31:04 <ray> internet roman catholic network
19:31:09 <SamB> I think I got to be around 18 before I started having trouble remembering ;-)
19:31:26 <gwern> and freenode would be catholicism - martyred founder and all
19:31:30 <ray> remembering is a drag
19:31:46 <ray> i'm pretty sure all these minor irc networks are protestantism
19:32:02 <SamB> yay that
19:32:07 <ray> the ones with services
19:32:10 <tkr> well. the undernet was the only network beside the 'usual' irc network back then, and it still was quite new. :)
19:32:15 <jaredj> *facepalm*
19:32:19 <gwern> we need a day where we go about in a procession, flagellating ourselves over the bicycle martyrdom of lilo
19:32:30 <SamB> tkr: we can call that devil-worship
19:32:49 <gwern> he died for our petrosins
19:32:59 <tkr> SamB: I had a warez-bbs before I started ircing, I wonder what you'd call that :)
19:33:18 <SamB> tkr: the bookstore
19:33:39 <ray> roman paganism
19:33:45 <SamB> or possibly the library
19:33:50 <BMeph> Isdis cult? ;)
19:33:54 <BMeph> *Isis
19:34:13 <tkr> my step-father still can really well remember that, as they were forced to change phone number after I quit having my bbs. :) pcboard 14.5 and 15.0 rocks <3
19:34:19 <SamB> seriously, warez is *good* for you and the economy
19:34:33 <Cale> tkr: hmm... it'd take some work to determine if those formulas for the circumference and area of a hyperbolic circle/disc are correct.
19:34:53 <tkr> not to mention Desqview or QEMM. :)
19:35:12 <tkr> Cale: they should be correct. but its not all about the formulas.
19:35:58 <Cale> tkr: How did you arrive at them?
19:36:36 <tkr> Cale: actually there was some problems with the at wikipedia, but my dear perl friend help to correct them. here's a log of that: http://rehn.fi/ton.hyperbolic.radius.txt
19:37:02 <tkr> Cale: (its at the very end where he fixed a problem with wikipedia article)
19:37:27 * pikhq discovers Template Haskell
19:37:43 <pikhq> OMG. The metaprogramming opportunities are astounding.
19:37:50 <pikhq> (note: not a Lisper.)
19:38:06 <Cale> ah, okay, it figures that you'd go by way of some much more general tools from differential geometry
19:38:10 <Cale> :)
19:39:19 <tkr> Cale: I dont know how you should 'officially' study these things, as I told before - math is only my hobby. :)
19:39:35 <tkr> Cale: I think therefore its only easier for me to figure this out :)
19:39:46 <Cale> I should perhaps take the time to read a proof of the Bertrand-Diquet-Puiseux theorem. The overall idea of it is somewhat intuitive, but the details are not so obvious to me.
19:40:14 <tkr> pikhq: have you ever read about perl6's (and perl5 with Moose) meta-object model? :) I find it fascinating.
19:41:16 <gwern> pikhq: they'd be astounding if TH weren't so painful
19:41:26 <gwern> and the restrictions on TH are bogus
19:41:29 <Cale> (like the constants 3 and 12 popping up, perhaps suggesting n!/2)
19:41:57 <pikhq> gwern: So, what you're saying is: needs to be more Lispy?
19:42:04 <gwern> I once tried to get TH to evaluate a Data.Map.insert of constants at compile-time, and the necessary contortions were... mindboggling
19:42:16 <gwern> pikhq: no, it needs to suck less period
19:42:29 <tkr> Cale: this all comes interesting when you dive into how fractions work, how these things are related to riemann surfaces (and of course the multi-valuedness of ln(z) on complex plane) etc.
19:42:29 <pikhq> Fair enough.
19:42:33 <gwern> forget the fundmanetal model; GHC's TH implementation is just terrible
19:43:51 <ray> pikhq: lisp is blub!
19:44:45 <tkr> Cale: but again: thanks a lot for also your help on #math here. :) I still well remember you from there.
19:45:09 <Cale> No problem. :)
19:45:41 <aavogt> @slap blub
19:45:41 * lambdabot pokes blub in the eye
19:46:03 <gwern> lisp is irritating, is what it is. last night I spent 20 minutes staring at a simple cond that was failing at runtime, trying to figure out why the heck #f was being used as a function, until I put it into a debugger and realized that I had one too few pairs of parens
19:46:25 <Cale> I could stand to have a much better understanding of differential geometry. There's a joke about differential geometry though which I've found to be frustratingly true: it seems to be a study of invariants under change of notation. ;)
19:46:32 * gwern was like what the hell scheme, can't you give me *any* compiletime analysis, even something like 'your cond has only one argument. idiot.'
19:47:00 <ray> cale: i don't know anything about that, but that's a funny joke
19:47:28 <Cale> It's all the physicists' fault.
19:47:49 <Vanadium> I am a physicist in training; I apologise
19:47:55 <tkr> Cale: have you read the chatpres 10-13 of visual complex analysis?
19:48:05 <Vanadium> (thought I am doing pretty badly at it, not least due to spending too much time reading about haskell)
19:48:29 <Cale> There are a lot of really awkward notations in differential geometry, and it's often difficult (at least in the presentations I've seen), to work out the types of the things involved in a given expression.
19:48:39 <tkr> Cale: very interesting ideas about how this was all originally discovered. and how you can relate complex analysis to vector fields using topology etc.
19:48:56 <tkr> Cale: (discovered by Newton, of course)
19:49:05 <Cale> tkr: Actually, I haven't read very much of that book yet, but enough to see that it's quite good. :)
19:49:47 <Cale> (I did take a course in complex analysis in university, but we didn't use Needham's book)
19:50:00 <tkr> Cale: nods. you should skip the the chapters 2-9 and read the the 10-13 ones. :)
19:50:34 <tkr> Cale: I find math history also very fascinating to study how this all was originally discovered, how did they think etc.
19:50:43 <aavogt> @pl concatMap (\(xs,e) -> map (flip (,) e) xs)
19:50:44 <lambdabot> (uncurry (flip (map . flip (,))) =<<)
19:51:16 <pikhq> I'm not sure which of those is more comprehendable.
19:51:33 <Cale> tkr: I agree with that, but also think that often a well-constructed fake history can be more satisfying than the real one. :)
19:51:36 <tkr> Cale: I dont like the math taught at universities that much. I think its bit like "bla-bla-bla, yes I know you were that things are like this, but you have no idea what they were thinking while this was originally discovered)
19:52:10 <pikhq> I strongly prefer it to math taught in high school.
19:52:24 <pikhq> (and other forms of public education, for that matter)
19:52:31 <SamB> I think I'd rather be forced to learn it off wikipedia
19:52:41 <tkr> Cale: studying the history at the same time gives you an idea what they were thinking originally, it was (of course) more of intuitive ideas instead of poofs that nowadays exist by definition.
19:52:50 <pikhq> It's particularly bad in the US.
19:53:04 <Cale> One of the nice things about mathematics, is that once we have the right idea, there's an extent to which the exact route we took to get there is not so important. From the top of the mountain, you can see all the roads you might have taken. :)
19:53:11 <tkr> pikhq: well. of course. but I didnt like high-school math either. :)
19:53:18 <SamB> I'm like "wake me up when you cover something I didn't learn playing around on the computer, mkay?"
19:53:24 <ManateeLazyCat> Cale: Are you a professor in university? I think this channel have so many professors.
19:53:33 <tkr> its a lot more fun if you study this all by yourself and maybe then go to university. :)
19:53:37 <Cale> ManateeLazyCat: no, but someday it would be nice to be one :)
19:53:48 <SamB> ManateeLazyCat: what? who?
19:53:48 <pikhq> By the end of high school, you are just about qualified to be a calculator.
19:53:55 <pikhq> And a pitiful one, too.
19:53:56 <ray> pikhq: if your university is public education you are doing it wrong (zomg controversial!)
19:53:57 <tkr> I wonder what the teachers think (if I ever end up and university) when I start asking them questions :)
19:54:04 <tkr> s/and/at/
19:54:07 <SamB> pikhq: in the US, you are hopefully qualified to *use* one
19:54:11 <pikhq> No numeric or symbolic integration.
19:54:14 <ManateeLazyCat> SamB: Just guess, i think many professor like Haskell.
19:54:16 <pikhq> SamB: Barely.
19:54:21 <Cale> tkr: My professor in first year basically told us to forget everything we learned in highschool and read the first 100 pages of Spivak.
19:54:35 <Cale> (on the first day)
19:54:41 <tkr> Cale: spivak is a lot about proofs also. :) but that's nice to hear.
19:54:44 <SamB> tkr: they probably think "shut up, you're going to confuse everyone!"
19:54:49 <ray> the problem with high school is pretending all numbers are real
19:55:03 <pikhq> Cale: Good call; more math in those 100 pages than in the previous 12 years.
19:55:06 <Cale> I still do think that proofs are the larger part of the content of mathematics.
19:55:06 <SamB> ray: most of them are just integers or fractions!
19:55:13 <pikhq> ray: ... Pretending all numbers are real? What?
19:55:17 <SamB> Cale: oh, yes
19:55:24 <ray> you know complex numbers, right?
19:55:27 <pikhq> You mean most people hardly touch on the imaginaries or complexes?
19:55:28 <tkr> SamB: :) nah. but Im wondering if they can really answer the questions. I DO tend to confuse people at #math also with my questions.
19:55:35 <pikhq> WHAT?
19:55:35 <tkr> ray: me? yes, of course.
19:55:38 <Cale> There's something to be said for interesting constructions though.
19:55:43 <SamB> tkr: well, "disrupt" anyway ...
19:55:55 <pikhq> ray: I knew about the complex numbers in middle school.
19:55:55 <SamB> Cale: how's that different from proofs?
19:56:15 * ManateeLazyCat I want to study mathematics again in high school someday.  
19:56:29 <pikhq> ManateeLazyCat: In high school?
19:56:32 <tkr> SamB: nahh. when I find the people who are able to answer the questions (besides relying mainly on proofs) they also seem to like the discussions I can bring up. :)
19:56:35 <pikhq> You're better off hitting #wikipedia.
19:56:35 * SamB didn't have to go to highschool, thank God, but college is waaay too boring unless he has to write a paper, in which case it's too hard :-(
19:56:37 <Cale> SamB: Well, I suppose you prove that they satisfy certain properties, but you don't really think of them as being theorems.
19:57:04 <ray> pikhq: all the functions in high school math are real functions of real variables
19:57:08 <tkr> SamB: I hate the people on #matematiikka (finnish #math on ircnet), who think they know all the shit. :)
19:57:11 <ray> they mention complex numbers briefly
19:57:22 <tkr> SamB: they cant explain *anything*
19:57:29 <SamB> tkr: well, okay, some of them might go "I like the way you think"
19:57:33 <pikhq> ray: Funny, I touched on higher order functions in high school.
19:57:45 <hzap> higher order functions in math class?
19:57:50 <pikhq> Oh, right. That's because I did calculus, and what's integration but a higher-order function? :P
19:57:50 <tkr> SamB: some of them even have told me I might be a good mathematician, yes. :)
19:57:56 <hzap> (other than calculus)
19:58:02 <pikhq> hzap: Not explicitly named as such.
19:58:05 <ray> all the integration is real too
19:58:09 <SamB> hzap: some of them cover (.)
19:58:18 <hzap> oh yeah, the dot
19:58:23 <SamB> of course, they call it something different, but I'll spare tkr that pain
19:58:23 <ManateeLazyCat> pikhq: I never study in high school, i studya everything myself, not can't go to high school, just hate high school in China.
19:58:34 <pikhq> I also discussed the concept of a stack with my math teacher. But that's because we were at a Magic tournament. XD
19:58:34 <hzap> i had that mentioned a lot in high school
19:58:56 <ray> the graveyard being a stack?
19:59:02 <pikhq> ManateeLazyCat: That's about how it is in the US, too. Autodidactism got me through high school.
19:59:02 <SamB> but I betcha they usually forget to mention that (+) and (.) are functions at all!
19:59:06 <pikhq> ray: No, the stack being a stack.
19:59:08 <ManateeLazyCat> pikhq: I would like to study in high school that in other countery.
19:59:14 <ray> oh, the action stack
19:59:27 <pikhq> ManateeLazyCat: Sure, but not the US.
19:59:28 <ray> if it were a queue you couldn't counter anything
19:59:29 <SamB> ManateeLazyCat: you think it's ever that great ?
19:59:31 <tkr> SamB: ok. now a joke about 'I like the way you think' .. there was this dude, called lets say little-John .. his teacher asked him about mathematics, he answered something and the the teacher told him that she likes the way he thinks. then this little-John decided to ask the teacher a question ...
19:59:34 <pikhq> Try any other developed nation.
19:59:44 <pikhq> (though autodidactism will do you better)
19:59:46 <ManateeLazyCat> pikhq: Why not US?
19:59:52 <SamB> ManateeLazyCat: in japan they have that whole stick up/hammer down thing
19:59:54 <pikhq> Bad education.
19:59:57 <SamB> ManateeLazyCat: the schools are terrible!
20:00:04 <hzap> until in my university linear algebra course we have some fun vector space stuff
20:00:25 <ray> the public schools are terrible, you mean
20:00:26 <SamB> I heard we are at like the 50th percentile despite spending the most money
20:00:30 <tkr> SamB: .. it was like "ok, there are 3 women sitting on a bench, eating ice-cream. one of them is licking it, one of them is sucking it and one of them is biting it. which one of them is married?' .. the teacher answred:
20:00:34 <ray> you can still pay for a good education in the US
20:01:03 <tkr> SamB: "the one who is sucking it, I think" .. little-John answered "nahh. the one with wedding ring, but I like the way you are thinking" ;)
20:01:07 <ManateeLazyCat> SamB: I just don't want waste time on examination, i want spend all time on particular programming.
20:01:19 <BMeph> I'm planing on using HRR to do partition counting. Any suggestions on which type to work the Floating stuff in? :)
20:01:40 <ManateeLazyCat> SamB: But i found i need improve my mathematics knowledge since i use Haskell programming.
20:01:42 <SamB> ManateeLazyCat: create a robot simulacron and have it go in your stead?
20:01:59 <tkr> SamB: what do they call it if they call it something different? Im bit curious. I also got logs (I call them notes) from #math also, when Ive been asking questions.
20:02:02 <SamB> then you can stay at home and have time to learn
20:02:29 <SamB> tkr: oh, they call it composition -- but they spell it with a circle centered at the midline
20:02:31 <ManateeLazyCat> SamB: Yep, i always at home programming.
20:03:07 <tkr> SamB: ahh. I thought you were going to tell me that they call me an idiot or something :) thank you for this.
20:03:11 <SamB> tkr: I'd show you, but you already said you're using latin1, so it wouldn't work
20:03:26 <hzap> would be funny if they start using pointless style in math class
20:03:40 <tkr> SamB: can you provide me with a link?
20:03:49 <tkr> SamB: wait a sec. Ill open another irc.
20:04:09 <SamB> http://en.wikipedia.org/wiki/Function_composition
20:05:04 <Cale> tkr: Function composition is normally displayed as a little circle, in Haskell we use . because it is much easier to type.
20:05:21 <copumpkin> whoa, costrength is sequence?
20:05:24 <SamB> Cale: not to mention more ASCII-friendly
20:05:30 <ray> unfortunately, some crazy person decided . would be a good hierarchical module separator
20:05:39 <hzap> calculus homework question: "differentiate sin . (^3) . (*5)" :D
20:05:41 <SamB> @let weakness = sequence
20:05:44 <lambdabot>  Defined.
20:05:48 <copumpkin> :t dif
20:05:50 <lambdabot> Not in scope: `dif'
20:06:10 <copumpkin> hzap: there's a module on lambdabot that will do that for you, but I can't remember how to call it
20:06:29 <SamB> hzap: you need to add parens around the stuff after differentiate
20:06:29 <tkr_> test.. äöå ..
20:06:37 <tkr_> SamB: here. working now.
20:06:44 <SamB> hzap: other than that your code should be fine
20:06:53 <hzap> SamB: lol
20:07:09 <SamB> f ∘ g = f . g
20:07:32 <tkr> SamB: actually this is why I joined #haskell, to be able to test these math things with something. :)
20:07:52 <tkr> s/SamB/Cale/
20:08:28 <hzap> didn't know that the direct-to-person is a first-class value in IRC chat
20:08:34 * SamB really wouldn't be surprised if there was a library on hackage that let you do what hzap wrote, after you add in those missing parens and maybe change "differentiate" to some other name
20:09:42 <tkr_> SamB: that looks like a big square to me. is my utf-8 working correctly?
20:09:57 <ray> nope :(
20:10:01 <SamB> tkr: I guess you need more fonts
20:10:05 <ray> actually, change your font
20:10:08 <SamB> that happens to me a lot on Windows ;-)
20:10:29 <ray> :þ
20:10:43 <tkr_> unfortunately this is a windows box (mainly because of my gf [http://rehn.fi/aki_ja_heidi.jpg]) ...
20:10:47 <SamB> ray: heh
20:10:51 <SamB> nice emoji!
20:10:53 <tkr_> a sec. Ill try to change it.
20:11:01 <ray> normally i'm against that letter, but i made an exception
20:11:22 <wmealing_> you kids and your non UTF8 operating systems.
20:11:28 <pikhq> Bu,but doeſt þou not like þe þorn?
20:11:42 <ray> operating systems don't have character encodings :)
20:11:54 <wmealing_> true.
20:11:54 <ray> the closest thing they have is support for processor architectures
20:12:01 <wmealing_> "applications and toolkits"
20:12:12 <copumpkin> Saizan_: you were right, it's much shorter
20:12:23 <copumpkin> transpose (Graph v e) = Graph v $ IM.fromListWith IM.union [(d, IM.singleton s l) | (s, ds) <- IM.toList e, (d, l) <- IM.toList ds]
20:12:24 <SamB> ray: uh ... yeah they do
20:12:44 <SamB> usually at least one
20:13:01 <ray> not in that sense
20:13:11 <ray> kernel strings have them, true
20:13:56 <SamB> NTFS stores it's paths in UCS-2 or UTF-16
20:13:59 <tkr_> darn. cant seem to make it. anyone know the correct font using putty + windows?
20:14:01 <SamB> might vary ;-)
20:14:07 <BMeph> Any suggestions, anyone? :)
20:14:16 <copumpkin> BMeph: for what?
20:14:18 <ray> i think most windows systems use utf-16 internally
20:14:21 <BMeph> I'm planing on using HRR to do partition counting. Any suggestions on which type to work the Floating stuff in? :)
20:14:32 <copumpkin> what's HRR?
20:14:35 <ray> tkr_: there's no "correct font" of course, but try dejavu sans mono
20:14:43 <SamB> tkr_: hold on ...
20:15:11 <SamB> tkr_: http://naesten.dyndns.org:8080/unifont-mono.zip
20:15:13 <SamB> there you go
20:15:26 <BMeph> HRR = Hardy-Ramanujan-Rademacher.
20:15:48 <copumpkin> zomg
20:15:50 <SamB> that's the one -- now just to warn you, it's a pixel font translated to TTF, so you'll have to adjust the pointsize a bit until it snaps into focus
20:16:07 <ray> fun!
20:16:32 <copumpkin> it makes sense to make Graph a functor, right?
20:16:34 * BMeph always thinks of Windows' font code as "WTF-16" ;)
20:16:35 <SamB> it's got way more symbols than dejavu sans mono
20:16:39 <ray> copumpkin: yes
20:16:43 <SamB> dejavu seems to neglect the mono variant
20:16:54 <ray> graph means "graph" right? and not something weird
20:16:57 <copumpkin> it also makes sense to make my graph a bifunctor
20:17:08 <copumpkin> ray: yup, edges and vertices
20:17:18 <ray> then yeah, should work out fine
20:17:22 <SamB> ray: compsci graph, or the ... other kind ?
20:17:42 <ray> edges and vertices
20:17:51 <copumpkin> ray: how about an applicative?
20:17:57 <copumpkin> that seems like it'd be weird
20:17:57 <ray> hmm
20:18:07 <copumpkin>  a graph product?
20:18:11 <ray> you might be able to come up with something, but it's not as obvious
20:18:27 <SamB> tkr_: now I have to warn you that I'm semi-violating the GPL here
20:18:37 <copumpkin> lol
20:18:41 * copumpkin calls up RMS
20:18:45 <ray> oh noes
20:18:48 <SamB> since that obviously isn't the preferred form of unifont to edit
20:18:51 * ray runs around in circles
20:19:02 <ray> btw, it wants to be 12 points
20:19:08 <SamB> but I figure you won't want the sources for that version, you'll probably want the latest ones if you want to hack it, yeah?
20:19:10 <tkr_> crap. I dont know how to use windows and how to install the font. :)
20:19:14 <RichardStallman> SamB: *ahem*
20:19:18 <ray> drag it to c:\windows\fonts
20:19:20 <SamB> tkr_: take it out of the zip
20:19:27 <SamB> RichardStallman: you don't have time to IRC
20:19:32 <SamB> therefore you aren't actually RMS
20:19:33 <ray> and your nick would be rms
20:19:44 <RichardStallman> dammit
20:19:47 <ray> /ns info rms
20:19:50 <RichardStallman> I'll use whatever nick I want
20:19:51 <SamB> also, you aren't ranting about dynamic loading or anything
20:20:12 <ray> if you were rms, the nick you would want to use would be rms
20:20:41 <SamB> anyway, I only have to give you the sources *upon request*, really, so please just don't ask me for them
20:20:51 <tkr_> SamB: yes. and then what? if I double click it just opens a sample of the font.
20:20:53 <SamB> 'cause it might be work to find the ones that that font came from
20:20:59 <ray> drag it to c:\windows\fonts
20:21:02 <tkr_> SamB: (Im more of a linux dude by profession)
20:21:10 <tkr_> ray: thanks. sec.
20:21:10 <SamB> yeah, ray has the idea there
20:21:33 <ray> which is a magic directory, so that's all you have to do
20:21:45 <SamB> c:\windows\fonts has the WIERDEST UI of *any* actual directory in the entirety of Windows
20:21:59 <ray> there are other magic ones, but none quite so magic
20:22:08 <tkr_> ok. I need to change the to my administrator account. sec more.
20:22:14 <SamB> the recycling bin directories are maybe almost as magic
20:22:14 <tkr_> (this is frustrating)
20:22:54 <tkr_> hehe. windows cant change the account, I might need to restart my computer, it says (i just HATE windows)
20:23:02 <ray> what version of windows is this
20:23:05 <tkr_> this will take a while. be back after a while.
20:23:07 <tkr_> windows xp.
20:23:19 <tkr_> I dont know why it says so. but brb.
20:23:23 <ray> sounds like someone screwed it up
20:23:48 <ray> <heresy>vista's really better</heresy>
20:24:56 <ray> @faq can Haskell expect the spanish inquisition?
20:24:56 <lambdabot> The answer is: Yes! Haskell can do that.
20:25:01 <tkr> ah. didnt need to reboot. just a sec more
20:25:14 <ray> linux people are a bit reboot happy
20:25:16 <copumpkin> NOBODY EXPECTS THE SPANISH INQUISITION
20:25:39 <SamB> ray: actually, my computer reboots more than I want it to
20:25:45 <SamB> I think it's just crazy
20:25:49 <ray> mine too
20:25:54 <tkr> hm. still cant find the font even if told me it's installed.
20:25:56 <ray> i often mistake the "lock" button and the "shutdown" button
20:26:08 <tkr> SamB: my work-debian hardly ever need a reboot.
20:26:10 <Stinger> I wish I could reboot :(
20:26:21 <tkr> SamB: its uptimes are like hundreds of days.
20:26:33 <ray> anyway, i specifically meant that linux people get reboot happy on windows because they heard all the dumb memes
20:26:37 <SamB> tkr: I'm thinking the HARDWARE is crazy
20:26:47 <tkr> Ill try to reboot know. brb (again).
20:26:48 <SamB> ray: they aren't dumb memes
20:26:52 <SamB> they're just mostly about 9x
20:26:56 <ray> samb: my last machine had a chronic overheating problem
20:26:59 <ray> yeah, that too
20:27:10 <SamB> NT is way better
20:27:15 <ray> 9x was pretty damn stable compared to its contemporaries, incidentally
20:27:20 <SamB> I think I've panicked the kernel *maybe* 5 times
20:27:23 <SamB> but I'm advanced
20:27:24 <Stinger> yeah the thing is, rebooting still fixes 90% of problems in windows
20:27:28 <ray> mac os locks-up-a-lot, infant lunix
20:27:31 <pikhq> I've done it more than that.
20:27:35 <SamB> I don't think typical users could be so successful
20:27:35 <pikhq> X11 was involved.
20:28:03 <SamB> pikhq: the NT kernel!
20:28:03 <SamB> I guess I should have said BSOD'd
20:28:03 <ray> i have yet to bring down NT
20:28:04 <ray> wait - once
20:28:05 <pikhq> And failing hardware, too.
20:28:09 <ray> some bad drivers
20:28:10 <pikhq> SamB: Oh, NT.
20:28:16 <ray> very bad drivers
20:28:21 <SamB> Linux is easier to bring down
20:28:22 <ray> they have driver certification now though
20:28:26 <pikhq> I've panicked it maybe 5 times.
20:28:34 <SamB> it's got all those hacker-friendly features
20:28:42 <pikhq> I've also been using Linux for nearly 7 years now.
20:28:51 <pikhq> And only had 6 months of XP.
20:28:54 <SamB> which is to say, enough rope to easily hang yourself several times over
20:29:19 <pikhq> It's easy enough to complain about NT making for too many reboots, though.
20:29:19 <SamB> pikhq: were you doing crazy shit?
20:29:31 <pikhq> Too much rebooting from software installation.
20:29:33 <pikhq> SamB: No.
20:29:42 <SamB> what happened?
20:29:43 <pikhq> Well, I was, but that was on the other entry in GRUB.
20:30:03 * SamB doesn't think he's rebooted his NT box in a long time
20:30:06 * SamB wonders how you tell
20:30:09 <pikhq> BSOD. Dunno what else was involved.
20:30:16 <ray> nt doesn't bsod :P
20:30:20 <ray> well, not like 9x anyway
20:30:21 <SamB> ray: oh, it can
20:30:31 <SamB> it just doesn't do it on a daily basis
20:30:34 * Twey has been using Linux for some eight years, and has managed a kernel panic exactly twice: once with a bad batch of madwifi drivers back in '06, and once when he tried patching some webcam drivers in live memory
20:30:34 <pikhq> I've had to spawn an NT VM, get it up to date.
20:30:41 <ray> neither did 9x
20:30:41 <pikhq> WHY DOES THAT INVOLVE A REBOOT?
20:30:47 <monochrom> Most Windows Updates require rebooting. That's the main cause.
20:30:59 <tkr_> now? äöö
20:30:59 <pikhq> monochrom: WHY?!?
20:31:03 <SamB> pikhq: oh, because you can't delete files or rename over files on NT
20:31:04 <ray> :þ
20:31:05 <monochrom> I dunno.
20:31:08 <SamB> I mean, open files
20:31:25 <tkr_> can you re-show me the square-char?
20:31:27 <SamB> at least, not withotu special flags
20:31:41 <SamB> f ∘ g = f . g
20:31:58 * Twey thinks tkr_'s Unicode-fu is weak.
20:31:59 <monochrom> It's like "why doesn't Haskell have non-linear patterns?"  It's defined that way.
20:32:01 <tkr_> now it looks like a small dot :)
20:32:12 <Twey> It's meant to :-P
20:32:16 <SamB> tkr: that's basically what it should look like, except it's supposed to be hollow
20:32:18 <tkr_> \o/ :)
20:32:18 <Twey> The one you didn't see was a thorn
20:32:19 <Twey> þ
20:32:27 <tkr_> SamB: its working. :) thank you.
20:32:36 <tkr_> SamB: ok. now go on with your explanation :)
20:33:13 <SamB> well, NT updates require a reboot because you can't replace files that are still open, at least not if they were opened in the usual way
20:33:13 <tkr_> Twey: my unicode-fu IS very weak. my windows-fu is even weaker.
20:33:35 <tkr_> Twey: I only know how to program perl using unicode ;)
20:33:49 <SamB> unlike unix where you can unlink or move an open file and everything keeps ticking
20:34:21 <ray> unix is just different like that
20:34:33 <Twey> NT updates also require a reboot because there's way more stuff integrated into the kernel than is natural
20:34:35 <SamB> I mean, I could upgrade x-chat and you wouldn't notice a thing ;-)
20:34:43 <Twey> (anyone remember that JPEG-rendering hole?)
20:34:50 <ray> you'd still be stuck with the old xchat though
20:34:52 <tkr_> I personally hate windowses. I shoudld teach my gf to use something like ubuntu (but I dunno how it will work with my integrated sound card and graphics card)
20:34:58 <SamB> ray: true
20:35:01 <ray> you should learn to use windows, tkr_
20:35:01 <tkr_> SamB: I love irssi. :)
20:35:10 <SamB> yeah, irssi can do one better
20:35:17 <Twey> tkr_: Almost certainly fine.
20:35:28 <SamB> but that's special stuff that only irssi and xmonad's ilk can do ;-)
20:35:40 <ray> xmonad is better
20:35:46 <ray> it passes its state on the command line
20:35:49 <Twey> Sound- and graphics-card incompatibilities are so last decade.
20:35:52 <ray> suck on that, trebek
20:35:56 <Twey> ray: That scares me
20:35:56 <ray> er, irssi
20:35:57 <tkr_> ray: I use linux/unix (hp-ux/aix/debian linux) by profession, so it seems quite silly to learn to use Windows. :)
20:35:58 <SamB> how does irssi pass it?
20:36:10 <SamB> tkr_: eh.
20:36:23 <SamB> you could become a win32 porter of *nix stuff
20:36:24 <Twey> By config file
20:36:25 <ray> tkr_: well, if you want to use computers outside work
20:36:48 <ray> you'll be considered a heretic on irc, of course, but i've found it's well worth it
20:37:06 <tkr_> ray: thats true. @work I havent even got a working flash player, not to mention sound card (what would I do with those @work) :)
20:37:11 <ray> i now keep all my unix separated from me by one atlantic ocean
20:37:21 <copumpkin> is Data.Tree stdlib?
20:37:29 <tkr_> anyhow. I got this working now, finally. Thanks to you all.
20:37:38 <ray> i don't remember it copumpkin
20:37:44 <SamB> copumpkin: no, stdlib is a Python thing
20:37:51 <copumpkin> I think it is
20:37:57 <monochrom> We haven't had some Haskell stuff for a long time. :)
20:37:58 <copumpkin> SamB: ;)
20:37:58 <Twey> copumpkin: I tihnk so
20:38:00 <Twey> think**
20:38:42 <ray> yep, it's i n base
20:39:16 <ray> :o
20:40:35 <copumpkin> :t unfoldTreeM
20:40:36 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (b -> m (a, [b])) -> b -> m (Tree a)
20:43:04 <copumpkin> > unfoldTree (\n -> (n, [n-1, n+1])) 0
20:43:07 <lambdabot>   Node {rootLabel = 0, subForest = [Node {rootLabel = -1, subForest = [Node {...
20:43:20 <copumpkin> > flatten $ unfoldTree (\n -> (n, [n-1, n+1])) 0
20:43:22 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
20:44:00 <copumpkin> > levels $ unfoldTree (\n -> (n, [n-1, n+1])) 0
20:44:02 <lambdabot>   [[0],[-1,1],[-2,0,0,2],[-3,-1,-1,1,-1,1,1,3],[-4,-2,-2,0,-2,0,0,2,-2,0,0,2,...
20:45:31 <copumpkin> > levels $ unfoldTreeM_BF (\n -> Identity (n, [n-1, n+1])) 0
20:45:32 <lambdabot>   Couldn't match expected type `Data.Tree.Tree (a, [b])'
20:45:37 <copumpkin> > unfoldTreeM_BF (\n -> Identity (n, [n-1, n+1])) 0
20:45:39 <lambdabot>   No instance for (GHC.Show.Show
20:45:39 <lambdabot>                     (Control.Monad.Identity....
20:45:55 <copumpkin> > runIdentity $ unfoldTreeM_BF (\n -> Identity (n, [n-1, n+1])) 0
20:45:59 <lambdabot>   * Exception: stack overflow
20:46:02 <copumpkin> aw
20:46:12 <copumpkin> no infinite breadth-first trees for me :(
20:50:48 <Axman6> :t unfoldTree
20:50:50 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
21:01:01 <boyscared> @quote xahlee
21:01:01 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
21:03:47 <ray> the perfection of wisdom in one logo
21:06:04 <copumpkin> @quote xahlee
21:06:05 <lambdabot> xahlee says: i do wonder, if any reputable computer scientist would blub out such idiotic things as this thread's lispers have been.
21:20:31 <jdrake> Does anyone know of a great parsec tutorial that does not involve strings? I need to be able to deal with a list of my own data type.
21:21:04 <jdrake> I was considering a function with pattern matching, but to be exhaustive it would be 15 to 20 patterns. So I figure there has to be a better way.
21:24:30 <tkr_> SamB: oh, well. maybe another time then. Im sure you dont forget the triangle/circle stuff. :)
21:24:40 <tkr_> I need to get some sleep now.
21:26:08 <centrinia> With respect to the numeric-prelude, why does the product of a 2x2 matrix and a 2x1 matrix have the dimensions of a 2x2 matrix?
21:26:32 <SamB> centrinia: isn't that normal ?
21:26:38 <Cale> jdrake: Well, normally you define a datatype whose cases are each of the basic terminal symbols in your grammar, and each symbol at least has a SourcePos field (for use by the parser later). Then you can write a lexer (in Parsec if you want), and then use Parsec to parse the list of those tokens, first defining a bunch of basic parsers for them using tokenPrim
21:26:42 <centrinia> I don't think so.
21:26:44 <SamB> I mean, given that it's not a type error?
21:26:54 <SamB> centrinia: oh, wait, you're right
21:26:57 <Cale> That should be 2x1, I would think
21:27:03 <SamB> centrinia: good question!
21:27:04 <centrinia> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7304#a7304
21:27:33 <jdrake> Cale, I am not sure I understand. I am not experienced at all with parsers, let alone this one.
21:27:56 <Cale> jdrake: okay... hmm, perhaps I can find you an example.
21:28:08 <jdrake> Cale, that would be most awesome
21:29:20 <Cale> jdrake: Well, are you okay about producing a list of values of your token type?
21:29:26 * SamB personally tends to use Happy whenever he has to write his own lexer, (and often uses Alex to actuallly write the lexer)
21:30:09 <centrinia> I don't think this is correct: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7304#a7305
21:30:10 <SamB> so many of Parsec's functions are (or were in Parsec 2) specialized to CharParsers :-(
21:30:12 <jdrake> Cale, if you mean if I have a [Gene] where it is data Gene = ... then yes, I have a [Gene] already
21:30:33 <jdrake> SamB, What is Happy
21:30:44 <uman> I wish GHC took longer to compile
21:30:46 <SamB> jdrake: it's the Haskell equivalent of Yacc
21:30:54 <SamB> uman: a strange wish, to be sure!
21:31:02 <SamB> uman: we could swap computers if you like?
21:31:06 <uman> SamB: it'd be in the guiness book of world records for sure
21:31:12 <jdrake> hmm, what exactly does that imply? I have never used yacc
21:31:20 <uman> ESPECIALLY the bootstrap build, which thank god I'm not doing on this comp
21:31:21 <SamB> jdrake: parser generator
21:32:02 <SamB> http://www.haskell.org/happy/
21:32:05 <jdrake> My problem right now is that I have a [Gene], but it doesn't follow the rules of good ordering, but there has to be certain things done when something invalid comes up.
21:32:26 <SamB> it's great how you can actually find that by googling just "happy"
21:32:55 <uman> SamB: the first link for "wine" on Google is the program
21:32:59 <uman> I always loved that
21:33:12 <Cale> jdrake: Okay, first of all you'll need a prettyPrint :: Gene -> String, and then nextPos :: SourcePos -> Gene -> [Gene] -> SourcePos which is meant to compute the next source position will probably just be nextPos p t s = incSourceColumn p
21:33:26 <SamB> uman: surely happy is a bit more obscure
21:33:36 <Cale> Then you'll need a function  Gene -> Maybe a
21:33:43 <SamB> (well, I mean, it was at #3 for me just now ...)
21:33:49 <jdrake> Next source position?
21:33:54 <SamB> (but even more than that implie ;-)
21:34:15 <Cale> jdrake: Yeah, if your tokens were more complicated than elements of the list, you might have to do something more
21:35:09 <jdrake> Cale, if I were to do up a pattern matching that worked (might take a day or two), do you think you might be able to help me understand what it would take to right a proper parsec whatever for it?
21:35:24 <Cale> jdrake: and then you pass those three functions to tokenPrim and it gives you a parser for parsing a single Gene value, which succeeds when the Gene -> Maybe a gives Just x, with result x
21:35:36 <jdrake> I do not understand what you are talking about now, but I understand the general stuff about what I can do now.
21:35:44 <Cale> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html#v%3AtokenPrim
21:35:47 <Cale> look at that function
21:36:21 <Cale> The three things I just described are what you need to pass to it in order to get a primitive parser for parsing a single Gene
21:36:39 <jdrake> I don't understand why I would need a pretty printer
21:36:48 <SamB> jdrake: error messages
21:36:53 <SamB> it doesn't need to be all that pretty
21:36:55 <centrinia> If I want to submit a patch to the maintainer of something like numeric-prelude, do I simply email the maintainer with the diff output and a short comment? :p
21:37:01 <SamB> show would suffice in a pinch!
21:37:21 <jdrake> There are no errors that would be generated, the problem is simply fixing the code so it is valid
21:37:25 <SamB> centrinia: well, first you look to see if there's a darcs repo, maybe
21:37:32 <centrinia> Thanks. :p
21:37:42 <Cale> jdrake: Parsers are allowed to fail.
21:37:44 <uman> is there a possibility the version of a package in Squeeze will change before Squeeze is released?
21:37:47 <SamB> of course, even so you *could* send a regular old patch
21:37:47 <uman> I'm assuming yes
21:37:54 <jdrake> This won't ever fail
21:38:00 <uman> er
21:38:05 <SamB> uman: yeah
21:38:07 <uman> sorry, thought I was typing to #debian
21:38:11 <SamB> that's why they call it released
21:38:28 <SamB> they might even change *after* if there's a severe enough bug!
21:38:46 <uman> SamB: it's hard for me to understand the difference between "testing" and "unstable" in that case
21:38:54 <uman> god, I should've installed Fedora
21:38:56 <uman> oh well
21:39:11 <uman> pretty sure Fedora ships with Firefox's normal logos
21:39:11 <SamB> uman: I think it's about 2 weeks and some automated sanity checks
21:39:44 <SamB> well, Debian feels pretty strongly about that DFSG
21:39:59 <uman> I don't
21:40:03 <uman> so, I shouldn't have installed debian
21:40:11 <SamB> Mozilla wouldn't let them modify Firefox as they see fit (mostly for security reasons)
21:40:14 <uman> firefox doesn't matter; I build my own from trunk anyway
21:40:26 <SamB> because they called "trademark" over the firefox branding
21:40:42 <SamB> Mozilla did, I mean
21:40:46 <uman> I know the issues surrounding it
21:41:11 <SamB> oh, okay then. I usually forget about the whole thing, actually
21:41:19 <SamB> I keep calling iceweasel firefox
21:41:27 <SamB> ... 'cause it basically is
21:41:36 <uman> I just don't see the value in confusing users by rebranding one of the most popular pieces of software out there, in order to have Free logos
21:41:44 <uman> it seems a little over the top to me
21:42:05 <SamB> uman: well, they really do insist on being able to do security patches and so forth
21:42:15 <SamB> Mozilla wouldn't let them with the Firefox branding
21:42:37 <SamB> at least, not without mozilla.org approval :-(
21:43:10 <uman> security patches to logos?
21:43:20 <Cale> uman: no, to firefox itself
21:43:27 <uman> oh, right
21:43:32 <SamB> uman: no, I mean Mozilla wouldn't even license the logo to them for use with patched firefox!
21:43:44 <uman> well both sides were sort of silly then
21:43:59 <uman> but either way mozilla patches firefox vulnerabilities within a day or two of their discovery...
21:44:00 <SamB> well, Debian sounds kind of silly
21:44:12 <SamB> uman: for OLD versions?
21:44:23 <uman> You have a point
21:44:53 <SamB> I think Fedora have some kind of deal where they can backport fixes *with* mozilla.org approval ...
21:45:18 <SamB> or perhaps they only need that for RHEL
21:46:11 <SamB> but Debian has a very strict policy against Debian-specific deals
21:46:24 <uman> why
21:46:30 <impl> Fedora probably doesn't have as many patches as Debian either
21:46:42 <impl> Debian maintainers love the patch the fuck out of everything
21:46:47 <impl> s/the/to/
21:47:15 <SamB> impl: well, I see an awful lot of those patches disappear again pretty soon as "appied upstream"
21:47:22 <SamB> er. applied*
21:47:31 <impl> SamB: it depends on the package
21:47:34 <SamB> impl: yeah
21:47:41 <impl> take a look at gcc sometime. you might cry. :P
21:47:42 <SamB> some maintainers are more cooperative than others
21:48:07 <impl> indeed
21:49:07 <SamB> honestly I'm wondering why the GNU toolchain hasn't broken away from GNU because of the FSF's really annoying copyright assignment procedures ...
21:49:25 <impl> I wonder that about all GNU projects.
21:49:54 <SamB> it's taking me forever to get my disclaimer signed by my school :-(
21:50:15 <SamB> by the time they get it signed, it will be time for school again and I shouldn't be writing code to contribute to GDB anyway
21:51:14 <centrinia> Is there a preferred channel for submitting bug reports and patches for HackageDB projects? It seems that the darcs repository version still contains this bug.
21:52:10 <Trinithis> @quote
21:52:11 <lambdabot> jcreigh says: 99 times out of 100.0000000000000000032467823764876238476, you're better off without floats.
21:52:33 <uman> @quote uman
21:52:34 <lambdabot> uman says: so you can pass functions around as objects... this sounds like JavaScript
21:52:35 <uman> :(
21:52:36 <copumpkin> centrinia: usually the maintainer is the best place
21:52:41 <centrinia> Thanks.
21:54:28 <Trinithis> uman: lol
21:54:33 <Trinithis> @quote Trinithis
21:54:34 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
21:54:37 <Trinithis> fail
21:55:02 <thoughtpolice> SamB: you're writing patches for GDB?
22:08:18 <ray> i think if you search for quotes by yourself and there aren't any, that's "succeed"
22:11:43 <jeffwheeler> Is it possible to install a man page as part of a cabal package?
22:11:44 <jdrake> With function pattern matching is there any equivalent for case's 'otherwise'?
22:12:00 <ray> _
22:12:25 <ray> _s are irrefutable and don't bind anything
22:12:59 <copumpkin> or just a variable you don't use
22:13:26 <copumpkin> > case undefined of x -> 5
22:13:28 <lambdabot>   5
22:13:47 <ray> then you might get whiny warnings like boo hoo unused variable waaaaahhhh
22:13:51 <ray> @ghc
22:13:52 <lambdabot> ghc says: Occurs check: cannot construct the infinite kind
22:14:11 <copumpkin> lol
22:14:31 * mmorrow wonders how to possibly get that error msg
22:14:33 <SamB> oooh, I didn't know you could get those at the kind level too ;-)
22:14:38 <ray> boo hoo cannot construct infinite kind
22:14:40 <SamB> mmorrow: me too
22:14:56 <SamB> ray: heck, it doesn't even allow polymorphic kinds, what did you expect?
22:15:17 <mmorrow> @ghc
22:15:18 <lambdabot> ghc says: Functional dependencies conflict between instance declarations
22:15:22 <ray> haskell kinds are a bit wimpy
22:19:55 <dolio> UHC does polymorphic kinds.
22:24:14 <jdrake> Is this function an abomination? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3064#a3064
22:25:37 <Twey> jdrake: It's not too horrible, but it looks like it could be improved
22:26:02 <jdrake> Twey: I would like to have suggestions. For one, I am not entirely sure if it is truly able to handle all cases
22:26:05 <Twey> What are the values of Gene, and what's the first type?
22:26:32 <Twey> Oh, the first argument of sequence' is also a Gene, huh
22:27:11 <jdrake> The whole code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3064#a3065
22:27:43 <centrinia> jdrake: sequence' _        (Number n  :[])   = Number n : []
22:28:06 <jdrake> centrinia: What about it?
22:28:22 <jdrake> hmm
22:28:22 <centrinia> I think that consolidates lines 3 and 4.
22:28:51 <centrinia> Also, sequence' _ (Number n  :tail) = Number n   : sequence' (Number n) tail
22:28:59 <centrinia> That should consolidate lines 5 and 9.
22:29:02 <jdrake> ok, I can take your first one
22:29:30 <copumpkin> what does hlint have to say? :P
22:29:45 <centrinia> Also, sequence' x (_         :tail) = sequence' x tail
22:29:53 <jdrake> I have never heard of hlint
22:30:04 <copumpkin> @hackage hlint
22:30:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hlint
22:30:07 <centrinia> That should consolidate 6, 8, and 10.
22:30:27 <copumpkin> wow, centrinia is the human hlint, but way better
22:30:39 <centrinia>  :O
22:31:19 <J11> Has anyone here tried Hat?
22:31:27 <jdrake> centrinia: I am getting lost with your line numbers
22:32:01 <centrinia> I'm using the line numbers from your post.
22:32:25 <jdrake> Oh, I have the revision up with different :p
22:32:26 <centrinia> Uh, this post: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3064#a3064
22:33:06 <centrinia> Uh, add 58 to everything I said. :p
22:33:27 <J11> It seems I have to hat-trans every ghc base file
22:33:27 <hackagebot> comonad-random 0.1.1 - Comonadic interface for random values (JakeMcArthur)
22:33:36 <copumpkin> hat?
22:33:49 <J11> the tracer
22:34:56 <jdrake> ok, lets try this out
22:34:58 <jdrake> centrinia: thank you
22:34:59 <J11> @where hat
22:34:59 <lambdabot> http://www.haskell.org/hat/
22:35:50 <J11> used for debugging your programs
22:36:47 <jdrake> I have to write a test for these functions now, too tedious to test
22:37:28 <hackagebot> comonad-random 0.1.2 - Comonadic interface for random values (JakeMcArthur)
22:39:17 <centrinia> jdrake: No problem. :p
22:40:22 <jmcarthur> eek. i don't mean to be noisy
22:40:33 <jdrake> centrinia: Some how the simplification fails
22:40:54 <jdrake> I will have to try it out tomorrow
22:52:47 <jdrake> I finally have cabal
22:56:59 <jdrake> Configuring haskell-src-exts-1.0.1... setup: happy version >=1.17 is required but it could not be found.    <-- but I have 1.18 installed
22:59:44 <vav> jdrake: is happy in PATH? vaguely remember having a similar problem with HsColour once.
22:59:52 <Twey> jdrake: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3064#a3066
23:00:05 <jdrake> It seems to be installing it in the user prefix when I would like it to go into global
23:00:13 <jdrake> It has the rights to install it globally
23:00:33 <jdrake> What is @ mean
23:00:45 <Twey> ‘Also known as...’
23:03:37 <vav> > let f xxs@(x:xs) = xxs ++ "|" ++ xs in f
23:03:39 <lambdabot>   Overlapping instances for GHC.Show.Show
23:03:39 <lambdabot>                              ([GHC....
23:03:54 <vav> > let f xxs@(x:xs) = xxs ++ "|" ++ xs in f "abc"
23:03:56 <lambdabot>   "abc|bc"
23:06:31 <jdrake> Twey: I thank you, I can't detect any errors in it
23:06:55 <jdrake> I must bed now
23:06:56 <Twey> jdrake: You're welcome
23:06:58 <jdrake> Thanks again
23:07:03 <Twey> Good-night :)
23:07:20 <Twey> The order is important — rule out specific general cases first
23:10:17 <jdrake> Twey: specific and general seem contradictory
23:10:37 <Twey> Only to an unenlightened mind
23:10:50 <Twey> *makes sage gestures*
23:11:26 <Twey> General as in cases that cover a large number of possibilities.  Specific as in cases that can be specified tersely and don't overlap with other cases.
23:13:37 <jdrake> Now aren't the first and the last cases, basically the same?
23:16:13 <Twey> jdrake: No
23:16:53 <Twey> The last case covers _ []
23:17:06 <copumpkin> you sure you want to reuse sequence as a name?
23:17:13 <Twey> Yeah, ‘sequence’ is taken
23:17:30 <copumpkin> you'd have to import Prelude hiding (sequence) every time you use it
23:18:02 <jdrake> Can you think of a name that would make sense as an alternative to 'dna sequencing'?
23:18:13 <Twey> dnaSequence
23:18:14 <Twey> :-P
23:18:17 <Twey> sequenceDNA
23:18:47 <copumpkin> sqnce
23:18:49 <copumpkin> :P
23:18:56 <ray> seQuence
23:18:56 <Twey> Nah
23:19:02 <Twey> That sounds like it ought to work on tuples, copumpkin :-P
23:19:12 <copumpkin> :P
23:19:16 <jdrake> All this thing is meant to do is put it in good order...
23:19:25 <ray> sqnce :: (a,b,c,d,e) -> (b,e)
23:19:36 <jdrake> I think I am going to get rid of my special newtype as well
23:19:38 <Twey> How d'you figure?
23:19:45 <Twey> The second and the quince'th?  :-P
23:19:49 <ray> yeah
23:19:52 <Twey> Hahaha
23:19:53 <copumpkin> did you see the tuple sections patch BSP submitted?
23:19:53 <Twey> Nice
23:19:56 <ray> not very subtle
23:19:58 <copumpkin> I hope it makes it in
23:20:05 <Twey> copumpkin: No, I didn't
23:20:07 <Twey> Link?
23:20:20 <jdrake> :t order
23:20:22 <lambdabot> Not in scope: `order'
23:20:28 <jdrake> Does that mean I can use that?
23:20:35 <Twey> :t sort
23:20:36 <lambdabot> forall a. (Ord a) => [a] -> [a]
23:20:41 <Twey> You mean this one?
23:20:49 <copumpkin> (5,) ==> \x -> (5,x), (,5,,,7) = \a b c -> (a,5,b,c,7)
23:20:49 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3377#comment:7
23:21:05 <Twey> It looks to me as though this function does more than that, jdrake
23:21:09 <Twey> But hey, maybe I'm wrong.
23:21:19 <jdrake> It is like a filter more than a sort
23:21:22 <ray> pretty cool, copumpkin
23:21:34 <jdrake> but 'order' implies putting it in order, which does not mean sort necessarily
23:21:43 <Twey> jdrake: Yes, but it's complicated
23:21:56 <Twey> You could maybe do it with a fold
23:22:26 <Twey> But it doesn't fold particularly nicely that I can see — this would seem to be clearer
23:22:30 <Twey> And it's not horribly long.
23:22:35 <Twey> Oh, I see, you meant as a name
23:22:40 <Twey> Sure, call it whatever you will.
23:23:16 <Twey> I would probably end up calling it nicygau, so I'm not one to talk :-P
23:23:52 <jdrake> Well considering my original spreadsheet list had 32 patterns before simplifying, this is pretty good
23:24:03 <Twey> Owch
23:24:38 <jdrake> I was going over ALL possibilities, just in case
23:25:25 <Twey> jdrake: But you have a _ _ case
23:25:34 <Twey> That catches all the ‘just in case’ cases.
23:25:56 <jdrake> But I didn't know what were for sure going to be in the _ _ case
23:26:21 <jdrake> Originally I was going to be using an Ignore field in the result and filter it out, until I realized it was completely unncessary
23:26:31 <jdrake> Anyways, I have to go, good night
23:26:34 <Twey> Everything goes in the _ _ case
23:26:35 <Twey> 'night
23:29:51 <copumpkin> I need commutative memoization or something, hrm
23:37:34 <ray> memoized commutativity
23:43:41 <wmealing_> http://qik.com/video/2258970 Cool effect. , not haskell though
23:52:25 <ac> wmealing_: this is the Haskell channel. Get out of here ;)
23:53:18 <copumpkin> it seems like you could get that effect with fix :P
