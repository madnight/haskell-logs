00:00:10 <Cale> Zeiris: large integer support is provided in part by the GMP library, so you can possibly judge things in terms of the algorithms that it's using if it's really crucial. Overall though, it tends to be rather fast, and the performance for Integers which fit into a machine word is better yet, since it doesn't use GMP integers for those.
00:00:40 <Cale> (it tests for overflow and switches representation when they get too large)
00:00:59 <copumpkin> Zeiris: the limits of GMP are outlined on its website, but are around 2^30-2^50 bits iirc, depending on your platform
00:06:10 <mle> limbcount has to fit in a limb or something
00:06:39 <ivanm> hey Cale
00:06:54 <Cale> hey
00:07:57 <cads> Zeiris: haskell's bignums are frighteningly efficient, right out of the box
00:09:19 <ivanm> Cale: if we're accepting neighbour*List, then I think we can by default make arcLabel return [ALabel g] for multiple edges
00:09:41 <ivanm> since if we're having a simple Int for some graphs, that can be obtained from the List functions
00:10:09 <m4k3r> what's the most elegant way to check if a float is int (= x.0) ?
00:10:20 <ivanm> x == round x ?
00:10:21 <ivanm> @type round
00:10:23 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:10:29 <ivanm> OK, fromIntegral . round
00:10:36 <m4k3r> ah :\
00:10:53 <cads> Zeiris: you can ask it to compute the decimal representation of the largest mersenne prime and it'll happily crank out the whole 12 megabyte number, using around 80 megs for computations
00:11:00 <Cale> ivanm: Well... I suppose that's possible. My intent was just to have neighbourXList g v = Set.toList (neighbourX g v)
00:11:31 <ivanm> my point for having *List is to get all the multiple edges up ;-)
00:20:59 * ivanm is looking through the graphviz lib, and thinking of re-writing the entire datatype setup to more closely match the specification of the Dot language
00:23:07 <dhun> can write a function that takes an argument that is of eq, but which behaves differently if the argument is also of class ord, so somthing like a set that switches to a faster implementation if ord is supported by the key type?
00:23:22 <m4k3r> the only way to use multiple-lines string is to put a \ at the end and the beginning of the line (eventually with \n), right?
00:24:26 <QtPlaty[HireMe]> dhun: I think GHC rules allow that.
00:24:53 <ski> > "m4\  \k3r"
00:24:54 <lambdabot>   "m4k3r"
00:25:16 <dhun> ok, I will look at it
00:25:25 <m4k3r> ski: yes, but is the only way? it's so boring put a \ on a 100-lines string
00:25:59 <copumpkin> dhun: you thinking of the map head . group . sort instead of nub?
00:26:00 <ski> (i.e. you can indent with as much whitespace you like)
00:26:16 <ski> m4k3r : i don't think there's anything HEREDOC-like ..
00:26:23 <ivanm> m4k3r: or you can use ++, or create a list and use unwords or soemthing
00:26:30 <ClaudiusMaximus> you could use template haskell to include a file, i believe (but that's as much as i know)
00:26:43 <copumpkin> and GHC hates large constants
00:26:55 <copumpkin> by hates, I mean will punish you by making you wait a lot longer for compilation
00:27:12 <m4k3r> mmh, ok. thx
00:27:13 <soupdragon> m4k3r why not use a text file
00:27:32 <soupdragon> the program can load the text file
00:28:49 <ClaudiusMaximus> you could do what i do for fragment shaders in C, and write a script that converts the text into a C source code file that defines a string - then you could access it as a CString via the FFI - if you really want 1 executable with no deps
00:32:31 <portnov> @index forkIO
00:32:31 <lambdabot> Control.Concurrent
00:32:36 <portnov> :t forkIO
00:32:37 <lambdabot> Not in scope: `forkIO'
00:36:14 <ski> @type Control.Concurrent.forkIO
00:36:15 <lambdabot> IO () -> IO GHC.Conc.ThreadId
00:39:32 <m4k3r> sorry for all these questions :) ...  a lambda function with built-ins like map, flodl, .. is associated to a variable or executed each time? For example here "foldl (\acc x -> (acc + x) `mod` 10^10 ) listBigInts" I should assing intx = 10^10 before (-> optimization)?
00:41:35 <QtPlaty[HireMe]> m4k3r: Try it both ways benchmarking them.
00:42:29 <Axman6> i think ghc might be able to optimise constants like that out
00:42:38 <Axman6> also, you could use 1e10 i think
00:42:42 <Axman6> > 1e10
00:42:43 <lambdabot>   1.0e10
00:42:48 <m4k3r> QtPlaty[HireMe]: time on unix isn't usually really good for benchmark , and I haven't a big list of ints
00:42:50 <Axman6> > 1e10 :: Integer
00:42:51 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
00:42:51 <lambdabot>    aris...
00:43:03 <Axman6> >  fromIntegral 1e10 :: Integer
00:43:04 <lambdabot>   Add a type signature
00:43:07 <m4k3r> Axman6: yep
00:43:14 <Axman6> > (fromIntegral 1e10) :: Integer
00:43:14 <lambdabot>   Add a type signature
00:43:18 <Axman6> >_<
00:43:18 <m4k3r> lol
00:43:28 <Axman6> > (fromIntegral 1e10 :: Double) :: Integer
00:43:29 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
00:43:34 <m4k3r> > 10^10
00:43:35 <Axman6> > (fromIntegral (1e10 :: Double)) :: Integer
00:43:35 <lambdabot>   10000000000
00:43:36 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
00:43:36 <lambdabot>    arising from a use ...
00:43:41 <Axman6> gah
00:43:45 <Axman6> der
00:43:51 <QtPlaty[HireMe]> Axman6: Thats what I suspect as well.  Content folding, also some form of memoization would help there.
00:43:54 <m4k3r> 10^10 return 10e10?
00:44:04 <Axman6> no
00:44:06 <m4k3r> nopw
00:44:08 <m4k3r> *nopw
00:44:12 <m4k3r> grr *nope
00:44:42 <QtPlaty[HireMe]> > 10^10 == 1e10
00:44:43 <lambdabot>   True
00:45:30 <Axman6> but that'll be Double, not integer, which i'm guessing is needed
00:51:13 <Saizan> btw, x `mod` 10^10 == (x `mod` 10) ^ 10
00:51:44 <Saizan> @check \x -> x `mod` 10^10 == (x `mod` 10) ^ 10
00:51:45 <lambdabot>   "Falsifiable, after 3 tests:\n-2\n"
00:52:08 <Saizan> @check \x -> x `mod` 10^10 == x `mod` (10 ^ 10)
00:52:09 <lambdabot>   "OK, passed 500 tests."
00:52:14 <Saizan> i was wrong :)
00:53:12 <Axman6> hmm, wasn't there a GSoC project on EclipseFP?
00:53:30 <ivanm> Axman6: I think so...
00:53:39 <ivanm> planet has mentioned it a few times IIRC
00:53:47 <Axman6> yeah
00:54:03 <Axman6> http://eclipsefp.wordpress.com/
00:55:04 <ivanm> hmmm... with using polyparse, can't I return a non-parsed value (i.e. False) ?
00:55:46 <Saizan> you mean a parse failure?
00:56:02 <ivanm> no... I'm constructing a value with different parsed values
00:56:23 <ivanm> and until I setup the parsing of one bit, I just want to return False (it's meant to parse if something is there or not)
00:56:40 <Saizan> can't you use return?
00:56:47 <ivanm> so I have at the end of the do-block: return $ Foo False blah
00:56:58 <ivanm> but it complains about a parseError
00:57:11 <ivanm> actually, I wonder if it's due to NamedFieldPuns
00:57:33 <ivanm> yup, it is
01:20:39 <hackagebot> HaskellForMaths 0.1.5 -  (DavidAmos)
01:22:24 <Axman6> huh, why is PackedString included with the platform, if it's deprecated?
01:24:36 <quicksilver> Axman6: GHC depends on it.
01:24:43 <Axman6> i see
01:24:54 <Dae> silly exscuse....
01:26:58 <derrida> does anyone know of a good resource for exploring interesting algorithms similar to the peano curve?
01:27:38 <Axman6> hmm... Data.Seq looks quite interesting. anyone know of a nice article about it?
01:27:42 * Axman6 looks at quicksilver 
01:28:44 <Saizan> have you read about fingertrees?
01:28:53 <ivanm> Seq is a poor mans fingertree
01:29:14 <Axman6> i think i saw an article once, and i have a feeling they are what i was looking for a few days ago
01:29:21 <Saizan> Seq is a specialization of the fingertrees
01:29:21 <doserj> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
01:29:24 <Saizan> http://apfelmus.nfshost.com/monoid-fingertree.html
01:29:45 <ivanm> specialisation, schmesialisation ;-)
01:29:51 <Saizan> maybe start with apfelmus' introduction and then proceed to the paper
01:29:53 <Axman6> excellent, thanks :)
01:30:08 <ivanm> yeah, the paper is kinda scary in its detail
01:30:30 <ivanm> @where fingertree
01:30:30 <lambdabot> I know nothing about fingertree.
01:30:31 <ivanm> @where fingertrees
01:30:32 <lambdabot> I know nothing about fingertrees.
01:30:49 <ivanm> @where fingertrees http://www.soi.city.ac.uk/~ross/papers/FingerTree.html http://apfelmus.nfshost.com/monoid-fingertree.html
01:30:49 <lambdabot> I know nothing about fingertrees.
01:30:54 <ivanm> @where+ fingertrees http://www.soi.city.ac.uk/~ross/papers/FingerTree.html http://apfelmus.nfshost.com/monoid-fingertree.html
01:30:54 <lambdabot> Done.
01:30:57 <ivanm> @where fingertrees
01:30:58 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html http://apfelmus.nfshost.com/monoid-fingertree.html
01:31:02 <ivanm> voila!
01:31:04 <Axman6> ah hmm, i did see that article.
01:31:13 <Axman6> anyway, dinner time
01:33:22 <quicksilver> ivanm: why is it a poor man's fingertree?
01:33:37 <ivanm> it is missing the extra monoid bit thingy whatever it is
01:33:38 <ivanm> ;-)
01:36:55 <sjanssen> Seq is a rich man's fingertree specialized to sequences
01:37:16 <sjanssen> use Seq over FingerTree when you can, it's much faster
01:40:30 <Cale> It's unfortunate that it *has* to be specialised like that to get the performance that it has.
01:40:33 <quicksilver> ivanm: it's no so much missing, as specialised.
01:41:06 * quicksilver agrees with Cale.
01:41:08 <Cale> It'd be nice if GHC could detect when the originally polymorphic datatype wasn't polymorphic anymore and specialise the structure.
01:41:33 <Cale> (provided that you haven't exported the data constructors for it)
01:41:34 <quicksilver> I think that breaks the way GHC handles parametricity.
01:41:50 <Cale> Well, it would mean generating a good chunk of code
01:42:00 <quicksilver> you might later pass your Seq to a library function which is fully polymorphic over FingerTree m a
01:42:16 <quicksilver> so you'd need to bundle up a runtime "unspecialiser"
01:42:20 <Cale> Except that wouldn't work because they're not the same type?
01:42:48 <quicksilver> well I thought your suggestion was that Seq just become FingerTree m for a specific m
01:42:54 <quicksilver> and specialised form that.
01:43:06 <Cale> Well, that would be nice too, but yeah, that really would break parametricity.
01:43:27 <Cale> I just mean that you could implement Data.Sequence as a newtype, and specialise the functions on FingerTree, and automatically get that performance without having to reimplement FingerTree.
01:43:50 <quicksilver> it's separate compilaton that's the problem, of course.
01:44:04 <quicksilver> I wonder if we should be prepared to give that up
01:44:19 <Cale> for the FingerTree m way
01:44:21 <Cale> yeah
01:44:30 <quicksilver> have -O11 to whole-program compilation with parametricity-breaking specialisation optimisations.
01:44:35 <quicksilver> (apologies to ndm for stealing his joke)
01:45:14 <sjanssen> once I tried sticking the entire Data.FingerTree module in a TH quote, with the measurement and stored values as arguments
01:45:18 <sjanssen> it didn't really work out
01:45:32 <tihomirwwf> Hi all
01:46:05 <Saizan> quicksilver: that's more or less what LHC is trying to do now, starting from ghc's external core
01:46:06 <sjanssen> hello
01:46:42 <tihomirwwf> how is it going?
01:47:51 <quicksilver> Saizan: interesting
01:48:36 <quicksilver> the other choice is to do some optimisation at link time
01:49:29 <tihomirwwf> my boss is on holiday and I work all day on my own site, isn't life cool !? :)
01:49:57 <Dae> where I'm at, life is rather hot....
01:51:12 <tihomirwwf> do you want to spam you with link to my site :)
01:51:46 <soupdragon>  no I don't want that
01:52:46 <tihomirwwf> ok :)
01:53:33 <Meady> Lol hey guys
01:53:33 <tihomirwwf> time for lunch here, buy to all :)
01:53:43 <soupdragon> lol
01:56:00 <quicksilver> Saizan: and all this time I thought LHC was trying to make strangelets and turn us all into grey mush.
01:56:33 <Axman6> that was strange
01:59:19 <Saizan> quicksilver: well, that's one possible side-effect of whole-program compilation
02:14:17 <inbuninbu> anyone have any tips on programming with Data.Tree? a simplified example of what i want to do is:
02:15:14 <inbuninbu> take a Tree Int, and produce a new tree that adds the parent to the children
02:16:08 <inbuninbu> i guess i'm having trouble thinking about trees from a functional perspective; i keep reverting to thinking of it in destructive updates
02:21:33 <HugoDaniel> hi
02:23:56 <quicksilver> > let addParents n (Node m ns) = Node (m+n) (map (addParents m) ns) in addParents 0 (Node 1 [Node 2 [], Node 3 [Node 1 [], Node 0 []]])
02:23:57 <lambdabot>   Node {rootLabel = 1, subForest = [Node {rootLabel = 3, subForest = []},Node...
02:24:05 <quicksilver> inbuninbu: something like that ?
02:24:28 <quicksilver> depending if you meant to recursive add up parents, or just add "one-level-down" which is what I did
02:24:46 <inbuninbu> quicksilver: recursively
02:24:52 <dainanaki> Hey everyone. I'm fiddling around with the implementation of the state monad code listings in RWH, and I was curious if partially applied functions being contained in type constructors is a common pattern for rolling one's own monad?
02:25:00 <quicksilver> just change the last "m" to "m+n" then :P
02:25:26 <Axman6> dainanaki: depends on the monad, they don't need to be functions at all
02:25:30 <inbuninbu> quicksilver: thanks, i'm going to need to look at that a minute
02:25:31 <Axman6> like []
02:26:06 <dainanaki> Axman6, I realize that... the Either monad and Maybe monad doesn't work that way either.
02:26:39 <Axman6> uh huh...
02:26:46 <dainanaki> I was just curious if for more advanced monads that was common.
02:27:34 <Taejo> dainanaki: Well, a lot of monads are some combination of Reader/Writer/State, which all have that kind of pattern
02:27:35 <rocketman> dainanaki: It's nothing to do with monad actually, just a slighter shorter way to write the code which crops up in many places
02:28:22 <Taejo> Reader s a ~= s -> a, State s a ~= (s, a) -> (s, a)
02:28:35 <Taejo> :i Writer
02:28:44 <Taejo> @info Writer
02:28:44 <lambdabot> Writer
02:29:28 <Taejo> yeah, I made a mistake, Writer s a ~= (s, a)
02:31:17 <Saizan> State s a ~= s -> (s, a)
02:31:28 <Taejo> Saizan: yes, sorry
02:31:50 <Saizan> Cont r a ~= (a -> r) -> r
02:41:54 <dainanaki> So, are there any papers on monadic design strategies? I've read one on building a monadic parser, but I'm having a hard time figuring out how to identify patterns as convenient monadic abstractions.
02:45:19 <Saizan> dainanaki: the paper from witch the mtl is extracted might be a good resource
02:45:27 <Saizan> *which
02:46:34 <quicksilver> dainanaki: Do you have an intuition on how to identify a pattern as a convenient monoid?
02:46:56 <quicksilver> because a monad is just a monoid which can return values along the way and use them to influence later behaviour.
02:47:23 <dainanaki> quicksilver, not particularly. I have a basic feel for monoids, but have generally skipped over them in favor of arrows and monads.
02:47:35 <Saizan> or just a way to compose functions with "rich" return types
02:48:07 <opqdonut> quicksilver: would you mind opening up that analogy a bit?
02:49:10 <inbuninbu> quicksilver: thanks! i think i'm on the right track!
02:49:45 <dainanaki> quicksilver, what do you mean by influence later behavior?
02:49:57 <quicksilver> OK, opqdonut ;)
02:50:01 <quicksilver> consider composing graphics
02:50:16 <quicksilver> square <+> circle <+> red triangle
02:50:45 <quicksilver> here the monoid operation is just put the graphics on top of each other
02:50:52 <quicksilver> the later ones go on top (probably)
02:51:03 <opqdonut> ok
02:51:17 <opqdonut> (i've always had Saizan's view of monads)
02:51:17 <Beelsebob> quicksilver: that's a great example to support +>
02:53:17 <dainanaki> quicksilver, how would converting this shape example into a monad change its capabilities?
02:53:56 <Beelsebob> dainanaki: it's not a monad -- it's just putting one thing over the top of another -- appending them
02:54:21 <opqdonut> yeah well it seems quicksilver is building up to monadifying it
02:54:29 <dainanaki> right
02:54:36 <dainanaki> that's what i was asking about
02:54:46 <opqdonut> i assume he's writing it down atm
02:55:01 <Saizan> or actually working :)
02:56:24 <jpcooper> hello
02:56:52 <jpcooper> I am reading http://en.wikibooks.org/wiki/Haskell/Monad_transformers . I am trying to understand what MaybeT $ runMaybeT tmb_v does. Is this any different from tmb_v itself?
02:59:19 <lilac> jpcooper: data MaybeT a = MaybeT { runMaybeT :: ... }. so yes
02:59:29 <lilac> (yes, they're exactly the same)
02:59:55 <doserj> jpcooper: you are missing the next line, I guess
03:00:28 <jpcooper> tmb_v is of type MaybeT m a, right?
03:00:57 <doserj> 'MaybeT $ runMaybeT tmb_v >>= blah' is not the same as 'tmb_v >>= blah' there
03:00:58 <jpcooper> then MaybeT $ runMaybeT tmb_v muyst be of type MaybeT m (Maybe a)
03:01:08 <jpcooper> is that correct?
03:01:16 <quicksilver> dainanaki: sorry, phone clal :)
03:01:27 <Cale> the next line really could have been indented a *little* more
03:01:28 <quicksilver> dainanaki: now consider:
03:01:52 <quicksilver> square 10 <+> circle 50 <+> red triangle
03:02:01 <quicksilver> and supppose I want '50' to depend on the current screen size
03:02:05 <quicksilver> then I do something like
03:02:05 <Cale> jpcooper: yes, except that it's not a subexpression
03:02:26 <quicksilver> square 10 <+> getscreenwidth <+>>= \w -> circle w <+> red triangle
03:02:28 <Cale> jpcooper: MaybeT is applied to the whole 3 following lines
03:02:41 <jpcooper> oh
03:02:41 <Cale> jpcooper: It's just indented poorly
03:02:45 <jpcooper> thanks
03:02:47 <quicksilver> getscreenwidth some how "returns a value in a monoid"
03:02:51 <quicksilver> which you can't do.
03:02:54 <quicksilver> but that's what monads do.
03:03:12 <quicksilver> do {square 10; w <- getscreenwidth; circle w; red triangle }
03:03:20 <opqdonut> hmm
03:03:28 <quicksilver> a monad is a monoid in which you can 'return values' from some operations, and use them later.
03:03:41 <quicksilver> conversely, any monad is a monoid if you just use operations with return value ().
03:03:47 <quicksilver> (>>) being mappend.
03:04:07 <jpcooper> Cale, with that, I totally understand it
03:04:08 <Saizan> though getscreenwidth doesn't produce anything to append, going a little out of the analogy
03:04:13 <opqdonut> indeed
03:04:17 <opqdonut> that's what i've been pondering
03:04:19 <jpcooper> I think I shall edit the page
03:04:56 <quicksilver> Saizan: yes, but that's OK. It's just like 'mempty' in that respect.
03:05:06 <quicksilver> Saizan: nothing wrong with elements which produce nothing to append.
03:05:09 <opqdonut> would something like "square 10 <+> clickablecircle >>= \(x,y) -> red (dot x y)"
03:05:13 <opqdonut> be better?
03:05:26 <quicksilver> some elements manage to append something and return a value.
03:05:46 <opqdonut> in the spirit of immediate guis (or whatever they were called)
03:08:59 <quicksilver> you can do a parser example too; parsers can be monoids instead of monads if they don't need to be context sensitive in a particular sense - that is if the later parser doesn't depend on earlier values.
03:09:23 <quicksilver> edwark's parsers are monoidic not monadic
03:09:46 <quicksilver> and ISTR ndm had a monoidic lexer/parser plan.
03:10:58 <quicksilver> you can say something like "a monad is a monoid which has access to some facets of current state as it goes along"
03:11:10 <quicksilver> but I don't really like that because it promulgates the antimeme that monads are about state :)
03:13:14 <ivanm> it's an antimeme?
03:13:21 <ivanm> how is it anything like a meme?
03:14:08 <Dae> quicksilver: so State would be a monoid, and IO a monad?
03:15:31 <quicksilver> Dae: no, they're both monads.
03:15:54 <quicksilver> Dae: writer (in its simplest form) could be formulated as a monoid
03:16:06 <quicksilver> since a simple writer actually doesn't give you any way to get something back
03:16:21 <quicksilver> but of course, writer in its simplest form is useless :) It's useful as WriterT.
03:16:35 <quicksilver> state is very definitely a monad, because of 'get'
03:16:59 <quicksilver> ivanm: I mean, it's a meme in that it sounds convincing and is therefore easily repeated.
03:17:04 <quicksilver> ivanm: but it's wrong, so "anti"
03:17:05 <ivanm> ahhhh
03:17:15 <quicksilver> I've no idea if that's what antimeme means. I just liked the sound of it.
03:17:21 <ivanm> so not a meme in the internetz sense, but in an actual sense?
03:17:40 <ivanm> though antimeme sounds like something that targets and gets rid of memes... ;-)
03:17:56 <quicksilver> HALP I ACCIDENTALLY THE WHOLE MEME
03:17:58 <pharell> http://my-first-time-naked.net/?id=3498430
03:18:01 --- mode: ChanServ set +o quicksilver
03:18:03 --- mode: quicksilver set +b *!*n=Igor@87.110.193.*
03:18:03 --- kick: pharell was kicked by quicksilver (quicksilver)
03:18:27 <quicksilver> actually most people's first time naked is the day they are born. I think it's pretty weird if that's not the case.
03:18:28 <ivanm> quicksilver: heh
03:18:39 <ivanm> (to both that and the HALP)
03:18:48 <Dae> so...a monoid is a monad that doesn't return anything?
03:18:54 <quicksilver> Dae: Yes.
03:19:00 --- mode: ChanServ set +o quicksilver
03:19:09 <quicksilver> Dae: return () is the 'mempty' and (>>) is the 'mappend'.
03:19:44 <quicksilver> print "hello" >> print " there" >> print "\n" -- monoidic IO
03:19:45 <Dae> right.... I'll have to wrap my head a bit around it before I see the connection betweeen that, and what the dynamic algorithm dude said....
03:19:57 --- mode: quicksilver set -o quicksilver
03:20:04 <quicksilver> I'm not tryigm to suggest this is the only way to look at it.
03:20:07 <quicksilver> but I find it helpful.
03:20:17 <quicksilver> the "rich functions" view is equally valid.
03:20:29 <quicksilver> (and in a different sense, arrows are rich functions)
03:20:56 <Dae> no no, it would be nice to have the math part and the haskell part finally merge together in a glorious revelation
03:25:22 <Dae> (>>) is the associative binary operation for monoids, correct? but what's the identity?
03:26:18 <ivanm> quicksilver: "rich functions"?
03:26:28 <ivanm> how did they manage to obtain such wealth?
03:26:59 <Dae> from Microsoft via F#?
03:27:10 <ivanm> heh
03:27:56 <Philonous1> Dae: mappend is the operation for monoids and mempty is the identity
03:29:25 <Philonous1> (>>) is like the monad bind operator but throws aways the value (only retains the side effects)
03:31:26 <Dae> right... I get the feeling monoids and monads are less alike than I thought
03:31:47 <quicksilver> but any monad is a monoid under mappend = (>>) and mempty = return ()
03:31:52 <quicksilver> restricting to the non-returning case
03:31:55 <quicksilver> I.e. m ()
03:32:05 <quicksilver> like my print example.
03:33:19 <EvilTerran> mappend = (>=>); mempty = return -- would also be a monoid
03:34:16 <quicksilver> yes, on (a -> m a) for each fixed a.
03:34:56 <EvilTerran> ah, true; i guess it's a, er, kleisli category in general?
03:35:47 * EvilTerran was thinking of the monadic version of Endo, tho, yeah
03:36:04 <Meady> map (\x -> x*x + x*x) [1..4]
03:36:08 <Meady> > map (\x -> x*x + x*x) [1..4]
03:36:09 <lambdabot>   [2,8,18,32]
03:36:20 <EvilTerran> > map ((2*).(^2)) [1..4]
03:36:21 <lambdabot>   [2,8,18,32]
03:37:11 <Philonous1> Wow, that looks almost like perl code
03:37:38 <Dae> I guess I need more category theory to fully appreciate the math at work here
03:38:50 <EvilTerran> > map (\x -> 2 * x^2) [1..4] -- might be easier on the eyes than either previous version
03:38:51 <lambdabot>   [2,8,18,32]
03:42:08 <osfameron> Philonous: the equivalent perl code is uglier... closest I can get so far is map (op(2*) << op(^2))->($_), (1..4)   ;-P
03:42:42 <osfameron> I think the best thing might be to provide an alternative map_ function for perl that is less broken than the default
03:43:01 <EvilTerran> osfameron, surely just map {2 * $_^2} (1..4) would do it?
03:43:13 <osfameron> probably yeah
03:43:25 <osfameron> but with the pipelining of sections I mean
03:43:34 <EvilTerran> ah, of course
03:46:35 * EvilTerran wonders if you could do something hideous with tie or bless to improve that
03:46:52 <lilac> isn't it "monoidal" rather than "monoidic"?
03:47:00 <EvilTerran> lilac, i'd say monoidal, yes
03:47:17 <osfameron> EvilTerran: well that's using overload to get << for composition.  And Devel::Declare to get the op(2*) syntax (otherwise it'd have to be op('2*'))
03:47:58 <EvilTerran> osfameron, ah, it's already pretty hideous, then. i guess the best thing would, then, be to Not Use Perl :P
03:48:16 <osfameron> overload/bless (the sub objects have to be blessed as Sub::Composable, cos autoboxing doesn't work (yet) with overload)
03:48:22 <osfameron> EvilTerran: yeah, but what would be the fun in that :D
03:48:39 <lilac> > (2*).(^2)<$>[1..4]
03:48:40 <lambdabot>   [2,8,18,32]
03:49:36 <quicksilver> lilac: probably :)
03:51:34 <ivanm> anyone knows what this (regex?) means? [-]?(.[0-9]+ | [0-9]+(.[0-9]*)? );
03:52:12 <profmakx> homework-question ;)
03:52:15 <ivanm> does that mean that it might start with a '-' ?
03:52:20 <osfameron> yeah
03:52:21 <Cale> yeah
03:52:25 <ivanm> profmakx: nah, trying to set up some parsing
03:52:35 <ivanm> oh, duh, negatives :s
03:52:46 * ivanm was trying to work out why a "number" would start with a hyphen :s
03:52:48 <osfameron> it's also most probably very wrong
03:52:55 <osfameron> or not PCRE
03:52:56 <ivanm> osfameron: hmmm?
03:53:01 <osfameron> as . doesn't mean [.] ;-)
03:53:01 <ivanm> ahhh
03:53:19 <osfameron> vim and some other dialects reverse . and \. though
03:53:21 <ivanm> no idea wtf regex syntax it uses ;-)
03:53:35 * RayNbow hates regexps with a passion :p
03:53:36 <ivanm> this is from the Dot language definition
03:53:37 <jpcooper> @hoogle ((a -> b), (a -> c)) -> m a -> (b, c)
03:53:38 <lambdabot> No results found
03:53:49 <jpcooper> :(
03:53:51 <profmakx> once a programmer had a problem and he thought i want to solve it with regular expressions! now he's got two problems....
03:53:58 <ivanm> heh
03:54:23 <ivanm> jpcooper: liftM the (\a -> (b,c)) function into the mkonad
03:54:31 <ivanm> *monad
03:54:43 <jpcooper> yeah
03:54:54 <quicksilver> then you'll get m (b,c) though
03:55:04 <jpcooper> oh that's what I want actually
03:55:04 <quicksilver> but that's the best you can do ;)
03:55:08 <jpcooper> @hoogle ((a -> b), (a -> c)) -> m a -> m (b, c)
03:55:09 <lambdabot> No results found
03:55:12 <jpcooper> right I'll just do that
03:55:18 <RayNbow> I mean... the following regexp is awful, while the original NFA I used to get this regexp is much easier to understand: ((00|11)*(01|10)(11|00)*(10|01))*(00|11)*(01|10)(11|00)*
03:56:55 <RayNbow> the NFA: http://dpaste.com/62111/ (q3 is an accepting state)
03:57:44 <opqdonut> RayNbow: but some regexes are nicer than their state machine counterparts
03:57:50 <opqdonut> especially if one allows complementation
03:59:08 <RayNbow> ah right, complementation is cumbersome in NFAs
03:59:54 <opqdonut> but yeah, usually the minimised dfa for a regex is pretty concise
04:00:04 <Meady> Guys length (x:xs) means x is first element of the xslist?
04:00:12 <profmakx> but an nfa is potentially exponentially smaller ;)
04:00:28 <opqdonut> Meady: (x:xs) is the list with x as the first element, followed by xs
04:00:34 <Meady> ahh i see
04:00:41 <opqdonut> so length xs = length (x:xs) - 1
04:00:52 <Meady> yeah im watching haskell lectures
04:00:53 <opqdonut> > let (a:as) = [1,2,3] in (a,as)
04:00:54 <Zao> Much similiar to how you prepend elements to lists.
04:00:54 <lambdabot>   (1,[2,3])
04:00:58 <opqdonut> indeed
04:01:10 <Zao> > 42:[3,5]
04:01:11 <lambdabot>   [42,3,5]
04:01:27 <BONUS> :t liftM (uncurry (***))
04:01:28 <lambdabot> forall (a :: * -> * -> *) b c b' c' (m :: * -> *). (Arrow a, Monad m) => m (a b c, a b' c') -> m (a (b, b') (c, c'))
04:01:43 <ben> > let (a:b:c) = [1..2] in (a,b,c)
04:01:44 <lambdabot>   (1,2,[])
04:01:48 <opqdonut> BONUS: that looks _really_ bad
04:01:56 <BONUS> wait that's not right :D
04:02:06 <BONUS> the type signature is awesome haha
04:02:15 <opqdonut> indeed, arrow + monad
04:02:25 <opqdonut> were you after the -> arrow?
04:03:02 <BONUS> nah, just playing around with jpcooper looking for ((a -> b), (a -> c)) -> m a -> m (b,c)
04:03:05 <BONUS> but this ain't it
04:03:41 <RayNbow> :t uncurry (&&&)
04:03:42 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
04:05:00 <RayNbow> :t liftM2 (uncurry (&&&))
04:05:01 <lambdabot> forall b c c' (m :: * -> *). (Monad m) => m (b -> c, b -> c') -> m b -> m (c, c')
04:06:15 <RayNbow> ^ BONUS ?
04:06:40 <BONUS> nah the first parameter is not monadic
04:06:47 <Meady> i really understand the whole function, and the imperetive equivilent but im not fully comprehending (x:xs)
04:07:01 <RayNbow> oh right
04:07:08 <BONUS> @pl (\(a,b) k -> liftM (\x -> (a x, b x)) k)
04:07:08 <lambdabot> uncurry ((fmap .) . liftM2 (,))
04:07:17 <BONUS> ah well that's not very readable
04:07:41 <sjanssen> @. pl djinn a -> ((a -> b), (a -> c)) -> (b, c)
04:07:41 <lambdabot> f = (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . flip id) (flip id)
04:07:42 <RayNbow> :t liftM2 (uncurry (&&&)) . return -- let's add a return then :p
04:07:43 <lambdabot> forall b c c' (m :: * -> *). (Monad m) => (b -> c, b -> c') -> m b -> m (c, c')
04:07:46 <sjanssen> yikes
04:07:56 <RayNbow> (quick hack :p)
04:07:57 <Meady> (x:xs) x is the first element xs is the second?
04:08:10 <Vanadium> Meady: No, x is the first element, xs is a list of all the other elements.
04:08:16 <Meady> ahh i see
04:08:16 <Cale> Meady: xs is the entire rest of the list
04:08:20 <doserj> @type  fmap . uncurry (&&&)
04:08:21 <lambdabot> forall (f :: * -> *) b c c'. (Functor f) => (b -> c, b -> c') -> f b -> f (c, c')
04:08:23 <Meady> > (x:xs)
04:08:24 <lambdabot>   Not in scope: `xs'
04:08:26 <Meady> hmm
04:08:45 <Cale> > 1 : (2 : (3 : (4 : [])))
04:08:46 <lambdabot>   [1,2,3,4]
04:23:02 <hape71_> 1==1
04:23:10 <rocketman> True
04:23:19 <hape71_> when comes lamdabot in place automatically here ?
04:23:28 <burp> it's renamed
04:23:29 <hape71_> rocketman, thanks :-)
04:23:34 <burp> to rocketman
04:23:49 <hape71_> ah perfect
04:24:04 <BONUS> @botsnack
04:24:04 <lambdabot> :)
04:24:05 <lunabot>  :)
04:24:05 <burp> but you could try "> " in front instead
04:24:06 <LeoD> > 1==1
04:24:07 <lambdabot>   True
04:24:11 <BONUS> ?yow
04:24:11 <lambdabot> I know th'MAMBO!!  I have a TWO-TONE CHEMISTRY SET!!
04:24:43 <hape71_> ah i see
04:27:33 <HugoDaniel> can someone help out in making this code "better": http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6483#a6484  ?
04:27:48 <HugoDaniel> specially the sig for the "renameFiles" function
04:28:10 <Beelsebob> HugoDaniel: runBackup looks suspiciously like a mapM to me
04:28:35 <Beelsebob> also, call liftM by it's real name (fmap)
04:28:45 <rocketman> HuoDaniel:  renameFiles = mapM_ (setCorrectFileName . snd)  gives you IO () instead of IO [()]
04:29:02 <HugoDaniel> nice nice :D
04:29:08 <HugoDaniel> you guys rock!
04:30:05 <HugoDaniel> my "error handling" in getLocation could also get a fix
04:30:08 <HugoDaniel> it doesnt seem "right"
04:30:17 <Beelsebob> setCorrectFileName = renameFile fname . replaceFileName fname . (++ ('-':fname)) =<< getDateString
04:30:21 <dschoepe> Maybe (String,String) would be an option
04:30:51 <Beelsebob> HugoDaniel: I'd expect it to have type Either String (String,String)
04:31:02 <HugoDaniel> nice, thanks :D
04:31:04 <Beelsebob> or as you're not returning an interesting error Maybe (String, String)
04:31:19 <skanev> Hey all. What is the haskell world using for unit testing, if anything?
04:31:24 <skanev> and is TDD popular here? :)
04:31:28 <Beelsebob> skanev: quickcheck
04:31:33 <Beelsebob> much much better than unit testing
04:31:37 <Beelsebob> it generates the unit tests for you :)
04:31:42 <HugoDaniel> :)
04:31:52 <skanev> I would argue that quickcheck does not do unit testing :)
04:31:55 <HugoDaniel> indeed, quickcheck is quite nice
04:31:57 <skanev> but it is extremely nice, I agree :)
04:32:32 <Beelsebob> skanev: sure it does -- if you *really* want to go all the way to unit testing you specify properties like prop_unit_test_1 = f 5 9 3 = 2.946
04:32:56 <Beelsebob> but in general you can get better coverage by specifying the properties you actually mean, not a small subset of them
04:32:57 <HugoDaniel> Beelsebob: the usage of =<< there makes me feel like an elite hacker
04:33:03 <Beelsebob> lol
04:33:19 <Botje> i wonder if quickcheck can be extended so you can pass in your own corner cases
04:33:20 <Beelsebob> HugoDaniel: you've not got to <=< yet
04:33:28 <HugoDaniel> ahah
04:33:37 <Beelsebob> Botje: sure -- you add a property specifically for them
04:33:40 <Botje> :t (<=<)
04:33:41 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
04:33:45 <skanev> I disagree. I see unit tests as an approach to come up with a design, while quickcheck seems to me like a way to verify correct behavior
04:33:51 <Beelsebob> prop_cornerCase = f cornerCaseInput == cornerCaseOutput
04:34:06 <Botje> Beelsebob: heh. fair enough :)
04:34:15 <Beelsebob> skanev: huh? How do you design something with unit tests?
04:34:26 <skanev> well, it's called test-driven development :)
04:34:37 <quicksilver> Beelsebob: the unit tests are the specification.
04:34:38 <Beelsebob> skanev: sure -- and in test driven development you're meant to write a test
04:34:44 <quicksilver> although I don't think quickcheck is any different
04:34:45 <Botje> i like type-driven development better
04:34:47 <Beelsebob> then write code to pass the tests
04:34:48 <HugoDaniel> i design with pseudo-code :P
04:34:49 <Beelsebob> and *no more*
04:34:57 <skanev> well, then refactor :)
04:35:04 <Beelsebob> so with traditional unit tests, all you can get out is a bunch of cases
04:35:16 <Beelsebob> with quickcheck, to get a property to go through, you actually have to code the logic correctly
04:35:22 <HugoDaniel> i like designing with pseudo-code
04:35:34 <HugoDaniel> then i just replace the pseudo-code with real-code, and leave it out as comment
04:36:07 <skanev> Beelsebob: well, yes and no
04:36:28 <skanev> if you are doing TDD and you're not sure what your design should be, the first thing you do is sit down and write a test
04:36:35 * Beelsebob nods
04:36:41 <skanev> then you start iteratively deriving your design in the proces
04:36:42 <Beelsebob> so the first thing you should do now is write a property
04:36:45 <skanev> process
04:36:53 <Beelsebob> "I know the output of this function should be the same length as the input"
04:36:55 <Beelsebob> *writes property*
04:37:07 <Beelsebob> etc
04:38:32 <Beelsebob> but again, you *can* think in specific tests with quickcheck
04:38:35 <hackagebot> bloxorz 0.1 - OpenGL Logic Game (ViktorDevecseri)
04:38:45 <Beelsebob> "I know that when given [1,9,3] this function should return [1,3,9]"
04:38:58 <Beelsebob> prop_UnitTest1 = f [1,9,3] == [1,3,9]
04:39:05 <skanev> hmm
04:39:06 <rocketman> @hackage bloxorz
04:39:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bloxorz
04:39:15 <Beelsebob> it's not a very good property
04:39:17 <Beelsebob> but it still works
04:39:17 <skanev> do you really do that kind of a property? :)
04:39:23 <Beelsebob> no
04:39:28 <skanev> exactly :)
04:39:31 <Beelsebob> because I usually have a more general property to express
04:39:34 <Beelsebob> but you *can* do that
04:39:41 <skanev> but you're not supposed to
04:39:47 <Beelsebob> so?
04:39:51 <Beelsebob> if you want to do unit tests, you can
04:40:00 <Beelsebob> if you want to do unit tests++, you can do that too
04:40:01 <skanev> but I wouldn't go with quickcheck
04:40:09 <Beelsebob> why not?
04:40:24 <skanev> because it is not unit test-oriented, if I may call it that
04:40:30 <skanev> mind you, I will *still* use quickcheck
04:40:38 <Beelsebob> what could be more simple than specifying your unit tests like that?
04:40:40 <dibblego> what you call "unit test-oriented" I call "bogus"
04:40:48 <Beelsebob> yeh, I agree with dibblego
04:41:16 <dibblego> I only hope this goes away soon
04:41:17 <skanev> well...
04:41:22 <Beelsebob> I have a language... it has one symbol -- 5, it's grammar consists of only one element -- that symbol, once, the semantics of that symbol is the mathematical value 5
04:41:30 <Beelsebob> you could say that it's a 5 oriented language
04:41:36 <Beelsebob> Haskell also has a concept of 5
04:41:40 <skanev> now you're being rhetoric :)
04:41:45 <Beelsebob> but I wouldn't use it for 5s
04:41:48 <Beelsebob> because it's not 5 oriented
04:42:46 <skanev> but seriously, I don't want to bash quickcheck, go into details why I don't find it very TDD-ish or even imply that TDD a good idea in Haskell
04:42:56 <skanev> I am simply wondering whether there is an alternative
04:43:03 <dibblego> I have found that marriage to what is being called "unit test-oriented" (bogus, laborious, pointless methods of verification) are a result of marriage to bad programming practices, particularly the love of side-effects
04:43:05 <Beelsebob> yes, but what do you want your alternative to do better?
04:43:09 <skanev> (which is not HUnit, because I've heard that too)
04:43:20 <kynky> i like to write tests after not before
04:43:24 <Beelsebob> what does quickcheck do wrong?
04:44:07 <dibblego> skanev, use the types -- to the extent that you don't (and can't) use automated testing (you're describing manual testing that is misnamed automated testing)
04:44:11 <skanev> Beelsebob: have you ever written your tests first and used that to come up with a design? :)
04:44:16 <dibblego> that's a good idea in any language
04:44:17 <Beelsebob> skanev: yes
04:44:37 <kynky> i normally have a design in mind b4 i write tests
04:45:08 <skanev> kynky: well, normally I have a vague idea of a design and I use the test-writing to come up with it
04:45:13 <kynky> or at least an objecive
04:45:24 <Beelsebob> skanev: so again -- what's the shortcoming of quickcheck?
04:45:28 <dibblego> in chess tournaments, a second board is disallowed -- use more discipline
04:45:31 <Beelsebob> what does it do that you want
04:45:34 <BONUS> imo doing ruby-ish test first unit-test-everything designs in haskell is not a good fit
04:45:39 <Beelsebob> don't want even
04:46:07 <skanev> BONUS: I'm getting the same idea, yeah, but I'm not proficient enough with haskell to be able to judge that on my own
04:46:20 <dibblego> skanev, which language has taught you these things?
04:46:24 <skanev> BONUS: would you care to extrapolate
04:46:42 <skanev> dibblego: I did it once in Java, but my current idea of it is Ruby + RSpec (BDD)
04:46:48 <kynky> not saying unit testig is not needed, but it more important with ruby than haskell, due to the nature of languages
04:47:04 <skanev> kynky: would you care to go on why?
04:47:17 <dibblego> skanev, Functional Java has the best Java test framework and look at RushCheck (but not really -- it's Ruby)
04:47:24 <kynky> strict vs dynamic
04:47:29 <BONUS> well, imo a lot of the unit-test-everything mentality in ruby is because it catches errors that haskell catches only with its type system at compile time
04:47:30 <kynky> typing
04:47:39 <BONUS> so doing that in haskell would be kind of redundant
04:47:56 <dibblego> skanev, a static type system eliminates much of the need for tests
04:48:15 <skanev> BONUS: I've been hearing about the greatness of Haskell's type system. Risking to venture in a flame war, I really have not seen how it protects you from error
04:48:42 <skanev> it is an *awesome* tool for programming, at least for me, but I have not yet convinced myself that it catches that much errors
04:48:42 <kynky> dibblego, good argument, but tests are god, you shouldnt rely on compiler, but it a nice safety net for some things
04:48:43 <dibblego> skanev, in the languages you are used to, you have probably come to believe that stdin.readLine() returns a String -- this is a LIE
04:49:05 <skanev> dibblego: it actually does :)
04:49:12 <dibblego> skanev, no actually, it's a lie
04:49:18 <skanev> dibblego: it also has some side-effects, but it most definitely returns a string :)
04:49:20 <dibblego> skanev, once you have this realisation, I will ask you to write a function that satisfies this signature forall a b. a -> b -> a
04:49:25 <kynky> ruby has duck typing, far easier to have an error without realising
04:49:26 <dibblego> no, it doesn't definitely return a String
04:49:31 <dibblego> it *says it does* but *this is a lie*
04:49:39 <dibblego> this is the important realisation that I allude to
04:49:40 <skanev> oh, existential types
04:49:48 <skanev> please, enlighten me
04:49:57 <dibblego> sure, welcome to pure functional programming :)
04:50:11 <dibblego> here's a Java signature: <A, B> B f(A a, B b) { .. file in this bit
04:50:18 <dibblego> *fill
04:50:20 <Saizan> (that type is not existential)
04:50:45 <dibblego> you are *guaranteed* to either side-effect (subvert the type) or fail to terminate
04:50:52 <dibblego> ergo, the type implies the implementation
04:50:53 <skanev> Saizan: (I haven't grokked forall yet, so please excuse my ignorance)
04:51:00 <dibblego> it is *impossible* for you to write a unit test
04:51:21 <dibblego> this is one example of a static type check making it not only not necessary, but redundant, to write any unit test
04:51:29 <dibblego> (assuming your type system doesn't lie ala Java)
04:52:06 <skanev> ah, if you care to use a more familiar language (for me), it returns a string or throws an exception? :)
04:52:13 <dibblego> no
04:52:17 <dibblego> it returns b
04:52:31 <dibblego> (or it doesn't terminate or it subverts the type -- which is not possible in Haskell)
04:52:43 <skanev> subverts the type, meaning?
04:52:48 <dibblego> tells lies
04:52:48 <Beelsebob> tbf, in haskell non-termination *is* returning a b
04:52:55 <Beelsebob> it's returning _|_ :: b
04:53:01 <dibblego> no it isn't
04:53:06 <dibblego> <A, B> B f(A a, B b) { return b; }
04:53:06 <RayNbow> Beelsebob: bottoms are evil :p
04:53:38 <skanev> hahah
04:54:03 <skanev> when I "listen" to Haskell people "talking", I get an idea of how ordinary people feel when they listen to programmers talking :)
04:54:37 <dibblego> return null; / throw new Error(); / return f(a, b); <-- all non-terminating cases
04:55:08 <FunctorSal> skanev: I don't see what "forall a b. a -> b -> b" has to do with readFile returning strings either
04:55:09 <malumalu> skanev: so true :)
04:55:13 <skanev> why is 'return null' nonterminating?
04:55:23 <dibblego> null denotes logical absurdity
04:55:33 <skanev> that is rather extreme
04:55:40 <dibblego> Java is rather extreme
04:55:46 <dibblego> have you seen it?
04:55:49 <skanev> now, are you bashing Java, or enlightening me? :)
04:55:57 <Meady> I dont mind java
04:56:02 <dibblego> Java does a fine job of that itself
04:56:03 <skanev> I'm not into language wars :)
04:56:05 <quicksilver> null means lots of things in java.
04:56:06 <kynky> java serves a purpose
04:56:07 <Meady> Just dont like the fact i have to catch everything regardless of my certainty
04:56:09 <Meady> :D
04:56:11 <dibblego> me neither, but this is your story
04:56:14 <quicksilver> it's used for 'Nothing' to make everythign into a Maybe type
04:56:28 <quicksilver> like NULL is used in C++ to make all pointeres into a Maybe type.
04:56:35 <quicksilver> it's a bit painful when you make a mistake though.
04:56:51 <dibblego> one may think of it like that, in which case, the type is not satisfied
04:56:55 <skanev> well, I would say that 'having a Maybe for everything' is more of a design decision, than a fallacy
04:56:57 <kynky> null checking can be frustrating if you forget
04:57:09 <skanev> one might not like it, but I see in no way how it could be absurd
04:57:19 <quicksilver> skanev: it's not absurd, no.
04:57:26 <dibblego> skanev, it stands for the uninhabited type
04:57:26 <quicksilver> skanev: it's just worse than the alternative
04:57:34 <quicksilver> (of really having something liek Maybe)
04:57:44 <skanev> similarly with the null-object semantics with Objective C, which I definitely don't like, but they are a design decision too :)
04:58:00 <quicksilver> skanev: the key point being that in java there is no type for "definitely-non-null-reference"
04:58:07 <skanev> quicksilver: well, if you say 'it is worse', I would ask 'in what context' :)
04:58:09 <kynky> java has a lower learning curve
04:58:17 <dibblego> kynky, disagree
04:58:18 <quicksilver> skanev: which I just answered :P
04:58:28 <FunctorSal> what are you arguing about by now, anyway?
04:58:33 <kynky> i found c++ harder than java
04:58:34 <dibblego> kynky, Java has a low learning curve if you're used to bad languages -- children pick up Haskell much easier in my experience
04:58:34 <skanev> quicksilver: there is a 'int' which cannot be null, actually, but it sucks :)
04:58:42 <quicksilver> having tought Java to ab initio students I disagree entirely.
04:59:11 <BONUS> java has a pretty steep learning curve compared to something like python or ruby, imo
04:59:18 <skanev> what, everybody teaches something somewhere these days? :)
04:59:25 <skanev> BONUS: I agree with that too
04:59:28 <dibblego> I also find that people who have "learned Java" usually don't know very much about Java -- so the qualification for having learned Java is itself low
04:59:58 <skanev> but, I actually came here to ask about other unit testing 'frameworks' in haskell  (other than HUnit and quickcheck) :)
05:00:15 <kynky> i prefer haskell to java, but going from c++ to java, o a start there is garbage collection, now iagree its importanto know how it works, but you dont have to know to use it
05:00:30 <dibblego> skanev, you won't find much better than QC
05:00:34 <skanev> most of the time, I find Java not worth discussing, btw :)
05:00:51 <skanev> dibblego: and what is the general opinion on HUnit?
05:00:52 <dibblego> we might use Ruby, but it doesn't have a type system at all -- let alone one that tells lies
05:01:10 <dibblego> skanev, I cannot speak for a general population
05:01:48 <FunctorSal> skanev: which functionality is missing in QC? (not a rhetorical question)
05:02:25 <kynky> i believe that a good language doesnt nccsarily mean a good implementation, and vice-versa
05:02:38 <ivanm> FunctorSal: you have to be able to describe the behaviour functionally? *shrug*
05:03:14 <FunctorSal> ivanm: properties are in IO IIRC
05:03:48 <skanev> FunctorSal: I wouldn't say that there is missing functionality, I would say that it solves another problem. If you do BDD, you treat the stuff you write both as examples and documentation. And you use the process of writing both to come up with your design
05:04:00 <ivanm> FunctorSal: *shrug*
05:04:04 <skanev> FunctorSal: Now, I have no idea whether that is appliable in Haskell. It might be altoghter a bad approach
05:04:12 <dibblego> skanev, it solves the same problem, but does it a shed load better
05:04:23 <skanev> FunctorSal: And one can definitely bend QC to do RSpec-like stuff
05:04:35 <dibblego> ivanm, Testing Monadic Programs with QuickCheck
05:04:59 <dibblego> skanev, why would one do that? simply for the sake of getting to say you are doing "RSpec-like stuff"?
05:06:06 <skanev> dibblego: no, because in some cases RSpec fits nicer :)
05:06:14 <dibblego> skanev, provide such a case
05:06:22 <FunctorSal> ok, I don't know what RSpec is :)
05:06:29 <dibblego> it's a dog's breakfast
05:06:35 <dibblego> I eny you
05:06:36 <skanev> dibblego: well, I'm doing web applications most of the time. Like, with databases and all
05:06:38 <dibblego> *envy
05:06:43 <skanev> lots of state, rendering html
05:06:43 <dibblego> skanev, so the case is?
05:07:11 <skanev> looking at my code, I can come up with a very few properties that are QCable and their coverage is not very significant
05:07:42 <dibblego> I don't doubt that there exists code where QC and RSpec would be equally useless
05:07:51 <dibblego> or useful if you're a half-full person
05:07:59 <dibblego> I would say "fix your code"
05:08:14 <skanev> I would say you are assuming too much :)
05:08:16 <dibblego> but even then, RSpec must provide an advantage, not be equal, which it is, even for what I expect is bad code
05:08:28 <dibblego> sure, show me where RSpec provides the advantage
05:08:54 <skanev> how do you QC a webapp? :)
05:09:01 <dibblego> I am trying really hard to imagine one, thinking of even really reallybad code, and I still cannot come up with one
05:09:06 <skanev> and that is not a rhetorical question too :)
05:09:07 <dibblego> easily?
05:09:27 <dibblego> the way web applications are done in Ruby are broken
05:09:31 <dibblego> so that needs fixing
05:09:36 <skanev> well, then I will assume that I still have to learn about using QC and avoid this discussion until I am better with it
05:09:40 <dibblego> once that is done, the rest is trivial
05:09:55 <dibblego> but even if you insist on the broken way, then you still can't provide a benefit of RSpec
05:10:20 <dibblego> (fwiw, I have written a Scala port of QuickCheck and fixed the way web applications are written and benefited)
05:10:21 <skanev> well, maybe I can, but I see no point in discussing it :)
05:10:38 <dibblego> I do, since my imagination is truly struggling to come up with one
05:10:45 <dibblego> and I need to put it to rest
05:11:27 <dibblego> can we say "there isn't one" so I can go and get drunk and watch football?
05:11:29 <skanev> if I were you, I would port QC to Ruby and start experimenting in writing something both styles and comparing
05:11:39 <skanev> well, if you wish :)
05:11:42 <dibblego> RushCheck is a port and I have compared both, believe me
05:12:00 <dibblego> even if a gun was held to my head and I were forced to use Ruby, I still wouldn't use RSpec
05:12:11 <skanev> I still disagree with you, I only want to point out that you shouldn't care whether I agree or not :)
05:12:25 <dibblego> I care that you disagree, since you have no grounds for that disagreemtn
05:12:29 <dibblego> *disagreement
05:12:37 <dibblego> you seem to be disagreeing simply for the sake of it
05:13:04 <dibblego> you need only provide *one* case
05:13:10 <skanev> nope, I disagree because I haven't had any real QuickCheck experience and I cannot compare empirically
05:13:21 <dibblego> that's not disagreeing, that's not knowing
05:13:36 <skanev> or rather, that's why I don't want to venture into the discussion
05:14:02 <ivanm> with polyparse, is the Text.ParserCombinators.Hutton* parsers completely seperate from the Text.ParserCombinators.Poly ones?
05:14:37 <dibblego> skanev, Ishall go get drunk now -- but leave you with a tip -- divorce side-effects, she is hurting you
05:14:41 <skanev> I disagree simply because I am not yet convinced that QC a better approach than  RSpec all the time
05:14:48 <dibblego> no you don't disagree, you do not know
05:14:53 <dibblego> stop saying you disagree, you don't
05:15:04 <skanev> if you want to put it that way :)
05:15:18 <skanev> I believe that I know enough to at least disagree when I have no convincing evidence :)
05:15:25 <dibblego> I want to put it the way that is truhful -- why is this too much to ask?
05:15:27 <skanev> but nevermind that, this isn't going anywhere :)
05:15:57 <skanev> dibblego: put it any way you like, I am not the one to tell anyone how to put anything :)
05:16:06 <skanev> I just won't repeat most of the stuff I hear/read :)
05:16:34 <dibblego> then on what ground is your disagreement?
05:16:59 <dibblego> skanev, I shall get a glass of wine and try to help you, one moment
05:17:05 <skanev> heheh :)
05:17:29 <skanev> nah, I would really rather go and write some code now, not continue this discussion
05:17:37 <dibblego> this is a new discussion
05:17:43 <skanev> I would prefer being better equipped for it :)
05:17:48 <dibblego> I would like to teach you some basics of unit testing
05:18:04 <dibblego> that way you can at least try to disagree :)
05:18:15 <skanev> now, that is impolite :)
05:18:21 <dibblego> look at this Java signature: <A> List<A> boo(List<A>)
05:18:30 <dibblego> in Haskell, we write: [a] -> [a]
05:18:37 <dibblego> how many implementations exist?
05:18:54 <dibblego> there are infinity
05:19:38 <dibblego> you might return an empty list or the given argument or a list that concats the argument to itself or whatever
05:19:39 <dibblego> right?
05:20:47 <skanev> right
05:20:57 <kynky> so its stupid to unit test every eventualaity
05:20:59 <dibblego> right, but suppose I said this to you:
05:21:10 <dibblego> boo [] = [] and forall x. boo [x] = [x]
05:21:14 <dibblego> now how many implementations?
05:21:35 <skanev> I don't know what forall does in Haskell
05:21:37 <dibblego> still infinity but we know more about what it is not right?
05:21:47 <dibblego> forall has nothing to do with Haskell
05:21:55 <skanev> then I don't know what you mean
05:22:03 <dibblego> for any value x then putting that value x in a list and calling boo returns the same list
05:22:16 <skanev> ah, x is a value
05:22:17 <skanev> or
05:22:18 <skanev> ok
05:22:23 <skanev> and?
05:22:29 <dibblego> its called a universally quantified variable
05:22:44 <dibblego> ok, so you're still not sure of what boo does, but you know a bit about what it doesn't
05:22:50 <malcolmw> ivanm: yes, they are entirely separate
05:22:57 <dibblego> but then I wrote: forall x y. boo (x ++ y) == boo y ++ boo x
05:23:03 <ivanm> good, they looked seperate but I wasn't sure ;-)
05:23:04 <dibblego> now how many?
05:23:08 <ivanm> thanks malcolmw
05:23:13 <skanev> probably one :)
05:23:23 <dibblego> right one
05:23:54 <dibblego> try writing a useful RSpec test
05:24:04 <dibblego> or any test for that matter
05:24:07 <dibblego> you can't right?
05:24:15 <ivanm> malcolmw: what's the difference between the Lazy and Plain Poly types?
05:24:29 <skanev> if we're talking about pure functions that have exactly one implementation - yes
05:24:37 <malcolmw> ivanm: the Lazy ones are lazy - the Plain ones are not
05:24:38 <dibblego> no, we are talking about a type system that doesn't lie
05:24:39 <skanev> but I fail to see how you can generalize
05:24:48 <dibblego> skanev, because we have a type system that doesn't lie
05:24:50 <ivanm> plain is strict?
05:24:56 <skanev> then a type system should be able to speak :)
05:25:02 <skanev> in order to not lie
05:25:06 <dibblego> skanev, it does
05:25:09 <skanev> anyway, I am loosing your point
05:25:13 <skanev> can you be more brief? :)
05:25:17 <malcolmw> ivanm: the idea is that there is a single interface as much as possible, then you choose whether you want lazy/strict state/nostate
05:25:17 <skanev> and less theatrical
05:25:20 <dibblego> skanev, those are quickcheck properties
05:25:34 <dibblego> skanev, I tried to be brief earlier but you insisted on disagreeing for no reason at all
05:25:41 <ivanm> malcolmw: well, I'm wanting some of the functions in Text.Parse which use Plain, but the lib I'm working on is using Lazy :s
05:25:44 <skanev> not exactly :)
05:26:02 <ivanm> e.g. parseFloat looks _much_ nicer than the current floating point number parser :s
05:26:25 <malcolmw> ivanm: ah, maybe you just need to clone Text.Parse and change the import at the top
05:26:26 <dibblego> skanev, the type proves a certain subset of properties -- the remainder are taken up by quickcheck to the point of disambiguity
05:26:42 <dibblego> skanev, it is now redundant to write any more tests (unless you wish to test the tests)
05:26:58 <ivanm> malcolmw: yeah.... I was hoping to avoid that dodginess :s
05:27:05 <skanev> the thing I would like to note, is that tests are not about proving correctness
05:27:12 <malcolmw> ivanm: it would be nice if Haskell had a way to parametrise a module on some of its imports, but I don't know of a good way round that
05:27:14 <dibblego> skanev, once you divorce side-effects, this will be one profound realisation that will come about
05:27:18 <skanev> furthermore, I would note that test-driven development is even not about testing
05:27:20 <ivanm> malcolmw: *nod*
05:27:25 <dibblego> skanev, yes they are
05:27:36 <dibblego> skanev, TDD is a bogus pseudoscience that infects this industry and I wish it would disappear
05:27:45 <ivanm> the Text.Parse stuff can't work on an arbitrary PolyParse instance?
05:27:46 <skanev> well, if you say that, then I would like to conclude that you are in no position to teach me anything about unit-testing :)
05:28:04 <dibblego> skanev, how else will you learn?
05:28:08 <skanev> or alternatively, that I am far below your level to be able to elevate to it via IRC :)
05:28:21 * ivanm uses ghci to test, and sample data
05:28:28 <dibblego> skanev, why aren't you able to learn? it doesn't seem hard to me *shrug*
05:28:35 <malcolmw> ivanm: hmm, maybe it could, yes
05:28:51 <kynky> you can learn from your own mistakes or from the wisdom of others who have made those mistakes before
05:29:14 <dibblego> kynky, or you can hang on to this TDD nonsense and eschew anything that is to the contrary
05:29:41 <skanev> that's slightly rude
05:29:52 <pozic> What's wrong with writing tests first?
05:30:09 <dibblego> skanev, what is?
05:30:37 <skanev> nevermind, I don't want to lecture people on ethics
05:30:52 <kynky> i find TDD gets in the way in practice, i write tests afterwards normally, reason i like tests, that on a big project say, if some1 else changes code, those tests can act as garentees
05:30:54 <dibblego> skanev, no really. what is rude? (which has nothing to do with ethics)
05:30:56 * ivanm didn't read anything rude...
05:31:14 <skanev> I said 'slightly'
05:31:25 <ivanm> I think it would be cool if we could define logic constraints on our functions (not tests they have to pass, actual contstraints that throw an error when they're not met)
05:31:26 <pozic> dibblego: without following the discussion completely, but declaring TDD nonsense is a bit rude.
05:31:28 <skanev> seriously, nevermind. Please disregard that statement, I take it back :)
05:31:30 <dibblego> skanev, what is slightly rude (which has nothing to do with ethics)?
05:31:41 <ivanm> pozic: rude isn't quite the right term here I think...
05:31:43 <skanev> should I repeat?
05:31:46 <pozic> Even though, it might be :)
05:31:48 <rocketman> pozic http://www.youtube.com/watch?v=T69TOuqaqXI
05:31:51 <dibblego> pozic, declaring TDD nonsense is in no way rude, but is an accurate statement supported by evidence
05:32:04 <ivanm> at the very least, it's an opinion
05:32:14 <pozic> rocketman: ?
05:32:16 <dibblego> (and even if it weren't supported by evidence is still not rude -- just a false statement)
05:32:25 <pozic> rocketman: are you suggesting I don't have an open mind?
05:32:29 <Dae> TDD, test driven design?
05:32:38 <FunctorSal> dibblego: a statement can be rude and supported by evidence ;)
05:32:44 <pozic> rocketman: I was merely explaining how a random human _might_ perceive it.
05:32:47 <dibblego> FunctorSal, this is true
05:32:49 <lilac> TDD can be a really useful technique if you want to build a complete and thorough test suite
05:32:55 <kynky> i think TDD came about strongely because on projects ther was no testing what so ever, which led to really buggy software, and soTDD was forced
05:33:10 <pozic> rocketman: which says nothing about my open mindedness.
05:33:24 <RayNbow> the only time I have trouble with writing tests first is when I don't quite understand the problem I'm trying to solve :p
05:33:36 <lilac> but i think most projects probably don't need two or three times as much test code as production code -- it seems to go against agility
05:34:01 * FunctorSal didn't even know there was such a strong controversy about TDD
05:34:19 <dibblego> FunctorSal, saying TDD is nonsense, albeit true, is blasphemous in the true sense of the term
05:34:31 <ivanm> malcolmw: is the main reason you specify a Parse type is because you want it to act as a Read drop-in?
05:34:37 <Dae> why is TDD nonsense? *hides behind rock*
05:34:45 <kynky> RayNbow, that could be argued as bad, but i prefer to write tests after, as i can develop faster that way, i hate riting tests first then realising that i have to trow them away as they not needed, and i find a waste of time
05:34:47 * pozic believes all 'methodologies' are only written to sell books, not to make intelligent people write software better
05:34:48 <dibblego> FunctorSal, you will observe that it is construed as a personal attack rather than a statement with a potential truth value
05:34:49 <malcolmw> ivanm: yes. I think so
05:35:21 <kynky> pozic, u should use that quote in your book
05:35:40 <pozic> There is no universal method of software construction, which is optimal. If there was, theorem provers would use it.
05:35:43 <ivanm> malcolmw: so the Parse class can be completely seperate from the actual functions you have there?
05:36:07 <dibblego> pozic, no, but there is most certainly pseudoscience that serves only to deceive the layperson
05:36:17 <pozic> kynky: u \not\in English language.
05:36:24 <kynky> all the acronym stuff
05:36:31 * skanev likes this channel
05:36:32 <lilac> pozic: i don't think that follows. methods of software construction exist to make software construction and modification easier for fallible humans
05:36:39 <alaa3> hi alaa
05:36:42 <alaa3> hi all
05:36:47 <ivanm> oh..... the word based ones require a constructor :s
05:36:52 <skanev> lilac: I would add that tehre are no infallible humans
05:36:56 <dibblego> skanev, stay a while, ask questions -- nobody is trying to be rude -- just trying to help
05:37:00 <malcolmw> ivanm: I guess so.  the Parse class is to make it possible to derive instances for any user-defined type, but if you just want some of the specific parsers at specific types, then fine
05:37:19 <MaciejP> Hi all! Are there docs anywhere on how to make a Windows Apache show websites written in Haskell?
05:37:25 <skanev> dibblego: It might be a cultural thing or I might have been away from IRC for a while :)
05:37:55 <kynky> u is definately a letter in English language, but i rather try to get the point across than get bogged down in red tape, but yes my bad English, sorry
05:38:11 <lilac> skanev: for an IRC channel, #haskell is usually outstandingly mild-mannered and helpful
05:38:30 <skanev> lilac: I actually agree :) but still, it is IRC
05:38:43 <lilac> yeah, there's no escaping that :)
05:38:51 <Vanadium> Your face is still IRC
05:38:55 <lilac> lol
05:38:59 <skanev> there we go :)
05:39:48 <lilac> in my experience, TDD is useful in python, but gets in the way in haskell
05:40:12 <skanev> lilac: Well, I wouldn't know that
05:40:13 <kynky> you shouldnt rely on the compiler
05:40:23 <lilac> TDD seems to exist mostly to facilitate correct refactoring, and a strong type system helps a lot with that
05:40:24 <skanev> skanev: I just wanted a way to come up to the same conclusion myself
05:40:36 <ivanm> malcolmw: well, from what I can tell there's no easy way to make the functions generic, since they require next and satisfy which aren't class methods :(
05:40:52 <ivanm> so looks like all I can do is a copy/paste :s
05:41:09 <skanev> lilac: yes and no on both. strong type systems + ide helps a lot with that and TDD exists to provide emergent design too
05:41:20 <malcolmw> ivanm: yes, unfortunately it was not possible to make next and satisfy part of the class interface
05:41:27 <ivanm> *nod*
05:42:27 <Vanadium> What are popular IDEs?
05:42:35 <Dae> for haskell?
05:42:43 <ivanm> emacs and vim are popular editors
05:42:46 <skanev> I mostly use vim :)
05:42:48 <Dae> Leksah
05:43:12 <Vanadium> I tried saying "cabal install leksah", that did not work and then I gave up and stuck to vim. :]
05:43:14 <lilac> skanev: fair point. but istm the emergent design property is predicated on 'designed to be easily testable' and 'designed to be easily usable' being confluent
05:43:33 <Vanadium> I only really use vim as an editor rather than an ide, though :\
05:43:38 <skanev> you have a point there
05:43:38 <kynky> vim/emacs , believe there is a plugin for eclipse now, leksah mentioned, haskell ide written in haskell, also yi i guess
05:43:48 <lilac> it's not clear to me to what extent that's true
05:44:21 <skanev> but still, the clear idea behind emergent design is "let's write some code and see how it looks like, before we commit to anything"
05:44:48 <Dae> cabal install leksah works if you installed the gtk stuff first...
05:44:53 <kynky> haskell is great for prototyping or so i thought
05:45:15 <Vanadium> Dae: Is there a button to make cabal do that for me too?
05:45:19 <lilac> you couldn't design something like the ST monad with TDD, IMO, since it requires a type system insight and proofs of correctness
05:45:29 <skanev> which I am curious on how can be achieved in Haskell, if only for the sake of having a first-hadn experience on the righteousness of dibblego
05:45:31 <skanev> :)
05:45:32 <quicksilver> lilac: designed-to-be-easily-testable is at least comorbid with broken down well into modules
05:45:44 <quicksilver> lilac: since you're forced to break things down to write tests of them.
05:45:55 <pozic> lilac: I can write tests that test ST monad semantics.
05:45:57 <kynky> lilac, i would imagine common-sense a virtue too :)
05:46:31 <lilac> quicksilver: the two are certainly correlated. i do wonder whether the correlation is the same across languages with stronger/weaker type systems
05:46:47 <skanev> I've never seed the word 'comorbid' in my life
05:46:52 <Dae> Vanadium: sadly no, cabal can't install 3rd party stuff (as in non-haskell)
05:47:08 <Dae> However, your package manager might be able to
05:47:08 <skanev> I fail to understand whether it is extremely cool to be using it or a sign of too much haskell :)
05:47:20 <pozic> Dae: cabal install leksah doesn't work if you have gtk2hs installed.
05:47:30 <Vanadium> Dae: Oh. I figured you refered to gtk haskell bindings. I do have all kinds of gtk installed.
05:47:33 <FunctorSal> it's a medical word, not haskell
05:47:55 <pozic> cabal: dependencies conflict: ghc-6.10.2 requires Cabal ==1.6.0.3 however
05:47:55 <pozic> Cabal-1.6.0.3 was excluded because Cabal-1.6.0.1 was selected instead
05:47:57 <pozic> Cabal-1.6.0.3 was excluded because leksah-0.4.4.1 requires Cabal ==1.6.0.1
05:48:03 <Dae> ohh, right
05:48:24 <Vanadium> I basically never successfully used cabal. I was kind of expecting it to do all the legwork for me.
05:48:35 <skanev> yeah, apparently it is not co-morbid. Or it actually is, but it is valid without the existence of haskell
05:48:37 <pozic> Vanadium: for other packages it does.
05:48:44 <skanev> you learn new things everyday
05:48:46 <pozic> Vanadium: gtk stuff is an exception.
05:48:52 <hackagebot> edit-distance 0.1.2 - Levenshtein and restricted Damerau-Levenshtein edit distances (MaxBolingbroke)
05:49:13 <Dae> Vanadium: for much stuff it works, but leskah has a bug in it, which means you need to download the files from hacakge, edit the cabal file and then run it. http://leksah.org/
05:49:25 <Dae> I guess it sorta defies "batteries included"
05:49:36 <lilac> pozic: perhaps i've missed some clever trick. how can you write a test that STVars can't escape a runST?
05:49:45 <Dae> as this is more of an "assemple yourself powerplant"
05:50:01 <FunctorSal> in the type system.
05:50:13 <Vanadium> I vaguely recall trying this. Let me see how far I got.
05:50:46 <quicksilver> lilac: a large proportion of tests for, say, python or perl, will indeed be roughly "sane typing" tests.
05:50:48 <Cale> Dae: haha, "assemble yourself powerplant"
05:51:26 <quicksilver> lilac: btu even haskell will have some such, since some things are sufficiently inconvenient to express in the type system that most people don't bother. (Like 'f(x)' always returns an even number of x is a multiple of 5"
05:51:27 <Cale> It's strange that it would depend on a specific point release of Cabal.
05:51:31 <pozic> lilac: it depends on how you define test. You can write a test which essentially just implements the typing rules for runST, otherwise you can only test it for a finite number of cases.
05:52:05 <LeoD> wow, -O2 makes quite a difference... 300 vs 6000 FPS ;D
05:52:13 <quicksilver> lilac: but then other tests are more like the specifcation of what the algorithm is supposed to do; that's the kind people generally used quickcheck for.
05:52:24 <Cale> LeoD: vs no optimisation? Yeah :)
05:52:34 <LeoD> yep :)
05:53:31 <Cale> Many of the basic list functions and other libraries have rewriting rules which they rely on for performance, and those are only applied with at least -O
05:53:49 <lilac> quicksilver: i'm not intending to argue that unit tests are a bad idea in haskell.
05:54:10 <LeoD> Cale: i see
05:54:15 <Cale> unit tests are a special case of quickcheck properties :)
05:54:29 <skanev> Cale: I disagree
05:54:40 <quicksilver> lilac: I wasn't intending to argue at all. I was just elaborating on your point ;0
05:54:41 <Saizan> pozic: about leksah, you can probably relax the constraint on Cabal editing its .cabal file and get it to build
05:54:44 <Dae> Cake: :D
05:54:47 <Cale> skanev: what about?
05:54:52 <pozic> skanev: only because you don't know quickcheck and smallcheck
05:54:58 <lilac> quicksilver: in that case, interpret my comment as, "yes I completely agree"
05:55:01 <skanev> pozic: I know quickcheck
05:55:14 <Cale> skanev: Unit tests are quickcheck properties with no function parameters.
05:55:14 <pozic> skanev: then I think you just disagree :)
05:55:16 <skanev> pozic: I have not written anything significant with it, but I know enough from it to disagree :)
05:55:43 <lilac> unit tests which test a collection of random inputs are still unit tests as far is i understand the term
05:55:53 <kynky> me2
05:55:54 <skanev> Cale: similarly, quickcheck properties are unit tests that verify a property with random data a high number of times
05:56:00 <pozic> Saizan: anything which does not install should never be on Hackage in the first place.
05:56:21 <Vanadium> Oh, my ghc is not even recent enough for leksah.
05:56:21 <skanev> both can be bend to do the others job, but none is a subset of the other
05:56:26 <Vanadium> This is harder than expected.
05:56:28 <Cale> Well, yeah, perhaps I mean the traditional sort of unit test :)
05:56:33 <Dae> pozic: it did install, it just hasn't been updated
05:56:46 <Cale> (which is just testing specific inputs at any given time)
05:56:51 <Saizan> pozic: it does install if you've ghc-6.10.1
05:56:52 <kynky> pozic, they trying to make it better, but lots of combinations with new packages etc
05:57:20 <Dae> Vanadium: installing leskah really isn't as daunting as it may sound, I did it a couple of days ago. I can walk you through it if you want
05:57:20 <skanev> btw, there is something called BDD that is a bit hot right now
05:57:31 <skanev> and there we don't call them tests, we call them examples
05:57:46 <skanev> which kind of illustrates the difference better
05:58:04 <pozic> skanev: most people here don't really care about what's "hot".
05:58:08 <Vanadium> Dae: I am going to give it another try, if I fail I will try to get back to you later tonight. I am trying to figure out why my distribution is not giving me the most recent ghc right now.
05:58:14 <lilac> pozic: my point with regard to ST was, if implemented incorrectly, your type system becomes unsound. so i would want something stronger than a demonstration of a collection of ways it doesn't fail
05:58:22 <skanev> pozic: I did not imply that it's hotness should be meaningful to anyone
05:58:38 <skanev> pozic: so I don't see why on earth you would reply that way :)
05:58:40 <dibblego> skanev, I had a friend who was into Java, Ruby and BDD -- I've counselled him, but it took a while
05:58:46 <lilac> something like a (or several) peer-reviewed paper(s) explaining it and proving it correct ;-)
05:58:50 <skanev> again with the preaching :)
05:58:54 <hackagebot> regular 0.1 - Generic programming library for regular datatypes. (JosePedroMagalhaes)
05:59:18 <lilac> BDD? boolean decision diagrams?
05:59:22 <EvilTerran> hmm
05:59:25 <EvilTerran> ?hackage regular
05:59:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regular
05:59:36 <dibblego> lilac, Behaviour Driven Dvelopment (another bogus pseudoscience)
06:00:35 <Dae> Vanadium: what distro are you using? also, check their site, it has installation instructions (but you can probably ignore the gtk2hs thing, I could under Fedora 11)
06:00:46 <Taejo> dibblego: is a bogus pseudoscience something which pretends to pretends to be science, but is actuall science? :)
06:01:35 <skanev> I think 'preudoscience' entails claiming to be 'science' :)
06:01:52 <dibblego> more specifically, making scientific claims
06:02:01 <Dae> but without scientific proofs
06:02:07 <lilac> dibblego: it seems to me that all of these methodologies make falsifiableable predictions (usually that they statistically reduce defect rate or development time)
06:02:19 <Taejo> skanev: but it's bogus pseudoscience, so it's not really claiming to be science
06:02:21 <skanev> what scientific claims did BDD ever make?
06:02:24 <dibblego> lilac, indeed they do and indeed they have been falsified repeatedly
06:02:42 <kynky> like alot of mathematical theorems without proof
06:02:46 <kynky> ?
06:02:57 <skanev> Taejo: Ahha! Then everything is bogus pseudoscience, given that it doesn't claim to be science :)
06:03:13 <dibblego> claiming to be science and making scientific claims are not the same
06:03:24 <lilac> dibblego: if that's the case (and i have seen no evidence either way) then they're not pseudoscience, they're just provably bad development models
06:03:26 <skanev> still, BDD made scientific claims?
06:03:27 <dibblego> crystal healers make scientific claims
06:03:29 <dibblego> yes
06:03:36 <skanev> when?
06:03:51 <Taejo> I think pseudoscience is as much about the language used as actually making scientific claims
06:04:04 <dibblego> lilac, you are right -- I should point out, that the (extremely small) subset of BDD which is falsifiable has been'
06:04:20 <dibblego> lilac, the rest is ill-defined, like most pseudosciences
06:04:34 <dibblego> lilac, providing the tautological appearance
06:04:37 <Taejo> if you're talking about radiation, quantum energy, etc. that's pseudoscience, even if you aren't making scientific claims
06:04:37 <skanev> I am still waiting for an answer of my 'when?' question :)
06:04:49 <pozic> dibblego: if you make your methodology easy to understand, you can't sell a book.
06:04:49 <dibblego> skanev, I'm still waiting for an answer to mine *shrug*
06:04:56 <skanev> hahah :)
06:05:00 <lilac> sounds like the old dvorak thing. scientific tests show that it's not better, but people like it for some reason anyway
06:05:05 <skanev> ok, fair enough
06:05:10 <Dae> kynky: not exactly. Math theorems without proofs are usually assumbtions, and stated as such. If you're basing something on an unproven theorem, you go "if (insert theorem here) then...etc". You don't claim something to be true, merely say that you assume it is
06:05:11 <Taejo> or maybe my understanding of "scientific claim" is different
06:05:33 <dibblego> lilac, programming is a fashino industry and programmers are easily to manipulate -- I have found that they are largely scientifically illiterate
06:05:39 <kynky> like with fermats last ?
06:06:05 <gwern> dibblego: illiterate in comparison with whom?
06:06:05 <Dae> for instance, although that is proven now
06:06:07 <lilac> dibblego: i've found people favour anecdotes over studies
06:06:26 <dibblego> gwern, they make basic errors in the process of acquiring knowledge
06:06:28 <lilac> "we used this here and it worked really well". how do you know if you didn't try without it?
06:06:32 <dankna> I'd just like to point out the irony in that claim
06:06:40 <dankna> anecdotally, you say people prefer anecdotes :)
06:06:51 <dibblego> there is no irony and this is part of the problem that annoys me :)
06:06:56 <dankna> hrm
06:06:57 <gwern> dibblego: I wasn't aware most people were perfect bayesian reasoners on par with AIXI
06:07:47 <pozic> gwern: where did you hear about that?
06:08:53 <gwern> pozic: I'm sarcastically making the point that all people make basic errors in acquiring knowledge, and I'm pointing out that comparing programmers' scientific literacy to that of scientists is hardly fair
06:09:23 <GPC> Hello everybody. I've started to learn Haskell and now I have a question regarding an exercise in the "Yet Another Haskell Tutorial". I've posted the exercises and the code I could come up with so far here: http://codepad.org/kxMYJwxK
06:09:25 <GPC> While I think I did manage to solve 4.6, I really have no idea about how to approach 4.7. Thanks in advance for any help :)
06:10:24 <Vanadium> Dae: Sorry; I was just bicycling home off university. I am using Gentoo.
06:10:45 <Dae> Vanadium: ohh...no idea how its packages work, sorry
06:10:51 <Vanadium> Dae: badly
06:10:56 <saml> gentoo lol
06:11:08 <pozic> gwern: That part was perfectly clear. I was referring to the AIXI part.
06:11:24 * Dae tried to install gentoo once, and failed when it didn't want to aknowledge the existance of harddrives
06:11:46 <gwern> pozic: what was unclear about it? if you don't know what it is, then google would be glad to help
06:12:07 <dibblego> GPC, you want to write a function that has the type :: Tuple a b c d -> Either a (Either (a, b) (Either (a, b, c) (a, b, c, d)))
06:12:09 <kynky> Vanadium, there is the haskell overlay for portage, it has both leksah and leksah-darcs, and also has hackport which allows you to createebuilds from hackage in your local overlay
06:12:10 <lilac> dankna: it would be ironic if i were aware of studies indicating the opposite
06:12:17 <pozic> gwern: I wanted to know how _you_ know about it. I know what it is.
06:12:23 <dankna> lilac: I suppose
06:12:37 <Vanadium> kynky: Right. Going to look into that.
06:12:37 <pozic> gwern: they don't teach that on universities, AFAIK.
06:12:44 <kynky> Vanadium, also there is the #gentoo-haskell channel
06:13:20 <lilac> dankna: though the potential for irony had completely passed me by, which i think helps illustrate my point :)
06:13:31 <GPC> dibblego: Thanks for the hint. I'll try my luck
06:13:37 <gwern> pozic: no; but schmidhuber and legge's stuff are all online, and aixi is quite relevant to theoretical AI discussions as well as the general digital universe area of thought; so it comes up on occasion in forums such as sl4
06:13:43 <dibblego> GPC, no prob -- ask more questions if you get stuck
06:13:45 <saml> i'm not sure those exercises really help (referring to YAHT)
06:13:47 <dankna> haha, okay
06:13:50 <gwern> although not as often as it might; it's pretty inacessible stuff!
06:14:18 <pozic> gwern: legge?
06:14:30 <gwern> shane legge, iirc
06:14:34 <GPC> dibblego: Oh, the solution to 4.6 is correct, is it?
06:15:04 <lilac> GPC: no, not quite
06:15:11 <gwern> he recently put his thesis online, which had some interesting results about limits of computable approximations of AIXI
06:15:24 <dibblego> GPC, I think so
06:15:25 <lilac> GPC: tuple1 (Tuple4 a b c d) should be Just a, shoudln't it?
06:15:30 <pozic> gwern: ah, cool. Something new on the subject.
06:15:51 <dibblego> lilac, no, since "Nothing if the number is invalid(i.e., you ask for the tuple4 on a tuple holding only two elements)."
06:16:07 <lilac> dibblego: but that's not invalid
06:16:15 <gwern> pozic: to save you the reading, they're mostly pessimistic results - the old result of you can't get more out than you put in
06:16:33 <lilac> dibblego: it looks like tuple1 should return the value in position 1, and in particular should never return Nothing
06:16:50 <lilac> dibblego: whereas tuple3 would return Nothign for a Tuple1 or a Tuple2
06:16:55 <saml> w00t that'll increase boiler plate code
06:17:09 <saml> how would normal haskell programmer do that?
06:17:10 <dibblego> lilac, perhaps
06:17:19 <GPC> lilac: okay, I see your point. I'm not sure what the author means however, so I went for the straightforward solution :)
06:17:22 <lilac> dibblego: the question could perhaps be phrased more clearly :)
06:17:31 <dibblego> lilac, or not phrased at all imo :)
06:17:38 <saml> data Tuple a b c d = Tuple1 { tuple1 :: a } |...
06:17:44 <saml> no that's same ias GPC's
06:18:04 <pozic> gwern: he doesn't describe it himself as being very interesting (some extensions of work Hutter did).
06:18:08 <lilac> saml: not quite. data Tuple a b c d = Tuple1 { tuple1 :: a } | Tuple2 { tuple1 :: a, tuple2 :: b } | ...
06:18:12 <lilac> saml: that'd work, i think
06:18:22 <saml> really, no name conflict?
06:18:34 <gwern> pozic: I thought it was interesting, but then, I don't remember how much of Hutter I've read
06:18:39 * saml tries
06:18:43 <lilac> i *think* it's ok if they're for the same data type and of the same type
06:19:01 <lilac> but it's not quite right, because we want Nothing not _|_ for tuple4 (Tuple1 a b c d)
06:19:05 <gwern> (hutter/legge/schmidhuber have always been very difficult reading for me, so I do less than I should)
06:19:26 <MaciejP> Why does "runhaskell -x hs Test.txt" not work wehre Test.txt is a simple Haskell program?
06:19:55 <lilac> saml: although to be honest i think just using (Maybe a, Maybe b, Maybe c, Maybe d) would be appropriate for most cases ;-)
06:20:13 <saml> lilac, it works. nice.
06:20:15 <lilac> saml: along with perhaps a newtype and construction functions whihc only allow creating the four interesting cases
06:20:22 <quantax> hello, I need some insight
06:20:25 <quantax> I wrote a function using foldr which takes a list of Strings and appends the Strings beginning with a whitespace character to the previous String in the list
06:20:48 <quantax> however the function has to consume the whole list before it return the modified list
06:21:09 <quantax> here is the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6485#a6485
06:21:28 <gwern> MaciejP: does runhaskell really take arguments like that?
06:22:05 <quantax> I also rewrote the function without foldr.  this function doesn't consume the whole list
06:22:13 <MaciejP> gwern: runhaskell: syntax: runghc [-f GHC-PATH | --] [GHC-ARGS] [--] FILE ARG...
06:22:35 <lilac> quantax: it needs to know whether the next one starts with a space before it produces the current string
06:22:59 <quantax> it always only keeps two Strings and the prints the result
06:23:24 <saml> quantax, what did you use to write code? it's indented nicely. did you manually type up spaces to align?
06:23:40 <lilac> quantax: you need to somehow defer the isSpace test until after you've already produced x
06:23:51 <quantax> lilac: yes, but then it only should wait for the next string, not for the whole list, shouldn't it?
06:24:08 <lilac> quantax: no, because the same argument applies recursively to finding the first character of the next string
06:24:42 <quantax> lilac: but then why does f2 (see paste above) work like this and not f1?
06:24:44 <lilac> quantax: you need to tell the compiler that the first element of the result starts with x irrespective of whther the next starts with a space
06:24:50 <quantax> I'm a bit puzzled
06:24:59 <jpcooper> say I have StateT X Y Z and I have another value which is of type State X A. Is there any easy way in which I can get to the A from StateT X Y?
06:25:20 <jpcooper> apart from using runState
06:25:43 <quantax> saml: I did it manually in vim, but there is also an align script: http://www.vim.org/scripts/script.php?script_id=294
06:25:58 <saml> quantax, ahsnkx
06:25:59 <saml> thanks
06:27:37 <lilac> quantax: f x xs = (x ++ maybeX' xs):rest xs where maybeX' (x'@(h:_):xs) | isSpace h = x' | otherwise = []; rest xs | ... = [] | otherwise = xs
06:27:44 <lilac> quantax: something like that
06:28:04 <lilac> quantax: so that ghc can see that f x xs is always (x ++ something):something else
06:28:10 <Cale> jpcooper: I'm not 100% sure what you're asking... turn a State computation into a StateT computation?
06:28:33 <Jedai> jpcooper: Why wouldn't you just use runState ?
06:28:50 <Cale> jpcooper: I think the easiest way to do that is just to use runState with get in the surrounding StateT
06:28:55 <jpcooper> okay
06:29:04 <jpcooper> I'll just do that
06:29:12 <Cale> jpcooper: You can write a function which does it if you need to do it often :)
06:29:30 <quicksilver> jpcooper: well the bottom line is that State X A doesn't *have* an A until you give it an X
06:29:41 <quicksilver> jpcooper: somehow you have to give it the X, to get the A.
06:30:01 <quicksilver> you can certainly choose to give it the X you receive from calling 'get' in your StateT monad
06:30:09 <quicksilver> and also to 'put' back the final X.
06:30:13 <jpcooper> that's what I was thinking
06:30:19 <quicksilver> I think that's what some people call 'hoist'.
06:30:24 <quantax> lilac: ok, let me think about that for a while.  still learning...
06:30:36 <jpcooper> or I could just put everything in the StateT
06:30:56 <quicksilver> best to put everything in MonadState s m =>
06:30:57 <quicksilver> probably.
06:31:01 <Cale> hoist x = do s <- get; let (r,s') = runState x s; put s'; return r
06:31:05 <MaciejP> I just found out "ghc -x hs -e main Test.txt" works fine.
06:31:13 <quicksilver> right.
06:31:20 <Cale> just let the type get inferred :)
06:31:48 <quicksilver> jpcooper: if your action has type MonadState s m => m a then you can use it in a StateT context as well as a State context.
06:31:54 <quicksilver> jpcooper: that's what the class is for.
06:32:29 <jpcooper> wait a minute
06:32:37 <jpcooper> I don't know what MonadState is about
06:32:52 <rocketman> state monad
06:32:58 <quicksilver> jpcooper: you do now :)
06:33:09 <quicksilver> jpcooper: it is *precisely* the solution to what you've been wondering about.
06:33:18 <quicksilver> its' a way to write an action which will run in StateT or State.
06:33:27 <jpcooper> oh excellent
06:33:42 <quicksilver> :t do { x <- get; put (x+1); }
06:33:45 <lambdabot> forall (m :: * -> *) s. (MonadState s m, Num s) => m ()
06:33:53 <quicksilver> ^^ that action will run in StateTs or States.
06:34:00 <quicksilver> or transformers with a StateT 'buried' somewhere.
06:34:05 <jpcooper> amazing
06:34:09 <quicksilver> e.g. ErrorT StateT
06:34:37 <quicksilver> :t do { x <- get; liftIO $ putStrLn ("State was " ++ show x); put (x+1); }
06:34:38 <lambdabot> forall (m :: * -> *) s. (MonadState s m, MonadIO m, Num s) => m ()
06:34:52 <quicksilver> ^^ that one will run in any monad with a StateT somehwere, and IO at the bottom.
06:36:27 <hackagebot> serial 0.2.3 - POSIX serial port wrapper (FrederickRoss)
06:39:16 <monn> may I ask algorithm-related problem here?
06:39:38 <jpcooper> I'm just trying to map this to my problem at the moment
06:41:50 <quicksilver> monn: if it's a pure functional algorithm question it's probably not off-topic
06:43:50 <timonator> hello folks. i'm trying to run this program "hback" (version 0.0.3 gotten from the hackagedb), but i cannot compile it and i'm too much of a haskell noob in order to know what to do. in one line i get many, many "not in scope" errors. what should i try to do in order to fix it?
06:43:54 <monn> quicksilver: what is "pure functional algorithm"?
06:44:22 <timonator> pure == without side-effects, monn
06:45:17 <monn> timonator: well, I think every stateful algorithm can be converted into stateless one, and vice versa :)
06:45:56 <gwern> timonator: need to paste error
06:45:58 <gwern> @hpaste
06:45:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:47:38 <timonator> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6490#a6490 - forgot to highlight the offending line, it's the "processEvent stateRef (Key {eventKeyName = keyName, eventModifier = evModifier, eventKeyChar = char}) = do" one.
06:47:52 <rocketman> monn: there can be insurmountable efficiency differences
06:47:55 <timonator> well, and the line before it.
06:48:25 <pozic> rocketman: has anyone ever proved this?
06:48:44 <rocketman> yes but I don't have a reference
06:49:20 <pozic> rocketman: please find it, since I thought it was still unresolved.
06:49:23 <gwern> didn't someone or other show purely functional was at worst a log n slow down?
06:49:52 <Cale> rocketman: well, at worst a logarithmic factor in time and space
06:50:17 <pozic> It depends on how you count DiffArrays.
06:50:20 <Cale> It's easy to show, you can use a structure like Data.Map as your memory
06:50:41 <pozic> If DiffArrays are purely functional, then you can do it with a O(1) slow-down.
06:50:46 <Cale> hmm...
06:51:02 <Cale> yeah I suppose that is true :)
06:51:08 <pozic> The problem is that purely functional is ill-defined.
06:51:41 <Cale> It's too bad that the practical performance of DiffArrays isn't better.
06:52:10 <Taejo> pozic: it's not too hard to define purely-functional complexity, you just have to decide whether DiffArrays are a primitive or not
06:52:27 <pozic> Taejo: yes, but nobody has done that.
06:52:42 <pozic> Taejo: everyone uses purely functional without any qualifications.
06:53:01 <Cale> I think I usually disregard them.
06:53:34 <Cale> But I also just disregard log factors in complexity too.
06:54:15 <Cale> We already disregard the log factor of time for memory accesses because we always pick a finite address space.
06:54:49 <Cale> and given that we're already ignoring that much, it doesn't hurt much to ignore one more log ;)
06:56:26 <timonator> so solving my problem is impossible? ;)
06:56:57 <Cale> timonator: oh, I'll have a look
06:57:31 <timonator> thank you :)
06:57:45 <Cale> hmm...
06:58:07 <Cale> Ah, gtk2hs recently changed the api for events...
06:58:12 <timonator> oh
06:58:17 <Cale> I'll grab the package and see what I can do.
06:58:29 <timonator> do you think this is a good task for a beginner?
06:58:45 <saml> why do I have to name my module Main to ghc --make ?
06:59:00 <saml> oh never mind i can have any file name I want
06:59:52 <Cale> timonator: If you don't mind learning about gtk2hs, it shouldn't be too bad.
07:00:17 <Cale> timonator: GTK itself is a bit daunting, and the complexity shines through though :)
07:00:48 <saml> how can I http authenticate using haskell?
07:01:27 <Cale> oh, hmm, there do appear to be structures here which look like the ones which you need
07:01:41 <Cale> timonator: maybe try importing Graphics.UI.Gtk.Gdk.Events
07:01:43 <timonator> hmm, i guess i shouldn't start with gtk2hs then :)
07:01:47 <kynky> there is wxhaskell too, with a more relaxed license
07:02:12 * timonator checks out the darcs repository of hback
07:02:27 <timonator> it werks!
07:02:44 <Cale> timonator: It's probably the nicest thing to work with if you want a GUI. It's just that GUIs are hard for now. (Not any worse than in other languages though). We have people working on that. :)
07:03:34 <quantax> lilac: I tried implementing your previous suggestion: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6485#a6492
07:03:41 <Cale> If we can sort out the problems getting reactive to work, it will be very nice.
07:03:59 <kynky> xhb look good to me, but they def harder than gtkhs, also there is opengl/sdl
07:04:10 <quantax> but it still does not show the desired behavior
07:04:33 <quantax> f3 still consumes the whole list before producing output
07:05:15 <quantax> erm, it works...
07:05:33 <quantax> I just noticed I called the wrong function in main
07:05:54 <quantax> lilac: thanks, for the suggestion
07:07:18 <quantax> however the version using foldr is less concise :)
07:07:41 <timonator> i suppose i should do other newbish stuff before starting with gui and such
07:07:43 <Cale> I think xhb is a worthwhile effort, but even farther away from being a nice programming model for actually writing GUIs :)
07:08:11 <Cale> timonator: Well, http://haskell.org/gtk2hs/docs/current/ if you want to skim the docs and see how it is :)
07:08:29 <Cale> timonator: It's actually not so bad for simple cases, if you use glade to construct the UI
07:08:45 <timonator> uh huh
07:09:51 <gwern> timonator: incidentally, if you just want to practice dual n-back, brain workshop is much nicer and more polished than h-back
07:10:48 <timonator> haha
07:10:59 <timonator> well, apart from not working at all, it may be much better, yes.
07:11:21 <timonator> if you want to help me get it up and running, though, i'd appreciate that
07:11:46 <gwern> ironically, I have a laptop and desktop running identical versions of brain workshop; on one, it runs perfectly, on the other it segfaults instantly.
07:11:54 <gwern> so I can compare both ways!
07:11:57 <timonator> for me it just freezes
07:12:09 <timonator> the call that creates the window just doesn't finish
07:13:52 <timonator> maybe i should start implementing a dual/triple n-back game for the nintendo DS
07:14:21 <timonator> i wonder if anyone ever tried writing haskell for the nds.
07:15:22 <timonator> oh my, how fun!
07:17:06 <saml> what is haskell equivalent of urllib2 of python?
07:17:35 <Zao> saml: Depends on what urrllib2 does.
07:17:57 <Zao> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:network http://hackage.haskell.org/packages/archive/pkg-list.html#cat:web
07:18:12 <saml> ah it has HTTP!
07:21:06 <quicksilver> timonator: there's a bunch of people pretty keen to get haskell working on the iphone, which IIRC is a similary power platform to the nds.
07:21:58 <dankna> iPhone is more powerful than NDS by a factor of about five
07:22:16 <dankna> if that's similar (which it is, for some purposes) then yes
07:22:25 <EvilTerran> ah, we're academics, we don't believe in constant factors :P
07:22:33 <dankna> haha
07:22:36 <dankna> well I'm not
07:26:24 <jpcooper> quicksilver, could you give me some pointers on using this MonadState for my own problem?
07:28:51 <quicksilver> jpcooper: I can have a go
07:29:21 <quicksilver> rule (1) : never give a reusable function the type 'State s a'. It is equivalent, btu more convenient, to use MonadState s m => m a
07:30:01 <jpcooper> right, so I should change the types of these functions
07:30:06 <quicksilver> yes.
07:30:12 <quicksilver> try leaving one out
07:30:18 <quicksilver> and ask ghci what it thinks the type is ;)
07:30:23 <quicksilver> I imagine it will be the monadstate version.
07:30:39 <jpcooper> whoah
07:30:41 <jpcooper> it compiles
07:30:55 <jpcooper> indeed it is MonadState
07:33:19 <lilac> quantax: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=6485#a6493
07:34:09 <jpcooper> quicksilver, when I use "sortOutput :: MonadState ControllerState m => M.Output -> m (Maybe Output)", I get something about Non type-variable arguments
07:34:30 <lilac> quantax: your f2 isn't really a normal fold (if it were a foldr, then both cases would use "f xs", and if it were a foldl, both non-[] cases would call f2 directly)
07:34:54 <lilac> quantax: so it's not really a surprise that recasting it as a foldr isn't completely trivial
07:35:37 <jpcooper> is there any way to do it without -XFlexibleContexts?
07:36:53 <EvilTerran> jpcooper, don't think so; that's a pretty widely-adopted extension, though, so i wouldn't worry too much
07:37:26 <EvilTerran> jpcooper, i imagine any haskell implementation that supports multi-parameter typeclasses (as needed for MonadState anyway) will probably also support flexible contexts
07:40:44 <lilac> isn
07:41:00 <quantax> lilac: now this looks a bit nicer. thank you
07:41:44 <lilac> quantax: sadly it needs an extension in order to be rewritten that way
07:41:50 <pragma_> I am thinking about tacos.
07:42:59 <lilac> what's the general feeling on the PatternGuards extension?
07:43:29 * Heffalump loves it
07:43:37 <EvilTerran> it's nice
07:43:48 <EvilTerran> the use of <- bugs me, though i can't see a better way of doing it
07:43:50 <lilac> i really like the way it unifies guards in bindings and guards in list comprehensions
07:44:06 <lilac> ... which makes it kinda natural that it uses <-
07:44:08 <Zao> Got any example of what it does?
07:44:25 <Heffalump> lilac: not really, because there's no monad involved
07:44:41 <EvilTerran> ^ the use of <- where there's no monad is what bugs me
07:44:44 * EvilTerran saw someone suggest a curious hybrid of views and pattern guards a while ago
07:44:50 <maltem> @go PatternGuards
07:44:51 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
07:44:51 <lambdabot> Title: 7.3.Syntactic extensions
07:45:03 <lilac> Heffalump: identity monad? ;-)
07:45:12 <Heffalump> :-p
07:45:53 <EvilTerran> something like PAT ::= ... | PAT "|" PATGUARD; PATGUARD ::= EXPR | PAT = EXPR
07:46:05 <pragma_> Hard shell tacos are crunchy.
07:46:30 <EvilTerran> er, PAT "|" (PATGUARD ",")* PATGUARD, rather
07:46:40 <lilac> Zao: firstOf xs ys | (x:_) <- xs ++ ys = x
07:46:45 <timonator> @go go power rangers
07:46:45 <lambdabot> http://www.youtube.com/watch?v=OfOACVCOJsM
07:46:45 <lambdabot> Title: YouTube - Power Rangers
07:46:56 * timonator is pleasantly surprised
07:47:20 <EvilTerran> so you could write "f (x | even x) = ...", or "f x (y | Just z = x `mappend` y) = ..."
07:47:31 <Zao> lilac: Ah. Now it clicks. It's patterns, in guards :)
07:47:38 <lilac> Zao: bingo :-)
07:47:54 <EvilTerran> i guess that'd be more "guarded patterns" than "pattern guards" :P
07:49:18 <EvilTerran> i guess it'd be pretty much equivalent to view patterns, although you'd be writing "foo (x | p x) = ..." instead of "foo (p -> True) = ..."
07:49:39 <lilac> EvilTerran: see http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=6485#a6493
07:49:46 <lilac> EvilTerran: you can't do that with view patterns
07:49:50 <lilac> (as far as i know)
07:50:02 <skorpan> hey. is there any tutorial or beginner's introduction to parsec 3.0.0?
07:50:31 <Lemmih> This game rocks: http://hackage.haskell.org/package/bloxorz
07:50:43 <EvilTerran> lilac, well, there'd be an (isSpace -> True), if you were determined to do it with view patterns exclusively (no guards)
07:52:18 <EvilTerran> lilac, actually, as that pattern guard you're using involves a variable not matched in the pattern the guard's attached to, i guess it would be rather different
07:52:53 <quicksilver> Lemmih: I very nearly kicked you then, as "this game rocks: <URL>" is a metapattern in my autokick neurons.
07:53:09 <quicksilver> Lemmih: fortunately, I saw the word 'hackage' and recalled my fingers.
07:53:31 --- mode: ChanServ set +o Lemmih
07:53:44 --- kick: Lemmih was kicked by Lemmih (Bad Spammer!)
07:53:47 <SamB_XP_> quicksilver: you wouldn't have noticed the nick and relented ?
07:53:59 <Heffalump> it was my immediate reaction too
07:54:17 <SamB_XP_> <SamB_XP_> quicksilver: you wouldn't have noticed the nick and relented ?
07:54:17 <SamB_XP_> <Heffalump> it was my immediate reaction too
07:54:36 <Heffalump> though I didn't get anywhere near executing
07:55:40 <idnar> haha
08:01:22 <GPC> dibblego: If you have time, would you mind having a look at the code I could come up with for exercise 4.7? http://codepad.org/1drgYSBK  I'm pretty sure it's not correct, so I'd appreciate another hint ;)
08:02:16 * byorgey does 'cabal update && cabal install bloxorz'
08:03:06 <byorgey> oh yes, THAT game =)
08:03:21 <EvilTerran> what's the status of cabal-install on windows these days?
08:03:41 <byorgey> someone ported it to Haskell, neat.  sort of broken though, it doesn't seem to take window size into account, so part of the board is getting cut off.
08:04:34 <Jedai> GPC: I don't really see why you have a String in your last Either ?
08:04:35 <EvilTerran> ah, just a case of downloading cabal.exe. nifty.
08:05:09 <Jedai> EvilTerran: or just installing the platform :)
08:05:17 <GPC> Jedai: Well, Either is supposed to have two alternatives and the Tuple a b c d is the first one... can I just leave the second type blank?
08:05:42 <Jedai> GPC: You don't need the last Either alltogether
08:06:07 <Jedai> extractTuple :: Tuple a b c d -> Either a (Either (a, b) (Either (a, b, c) (a, b, c, d)))
08:06:16 <GPC> Oh :O
08:06:45 <GPC> Very nice, thank you
08:07:07 <Jedai> GPC: It seems to be correct anyway :)
08:07:34 <quicksilver> for some reason, exercise 4.7 is one of the most commonly brought to this channel
08:07:40 <GPC> Jedai: I realized that the string is ugly there... but I had no idea on how to remove it :D And I'm only beginning with Haskell, so there's a lot of "Aha" and "WTF?!"-moments
08:08:04 <quicksilver> I wonder if that indicates a particular weakness in the book's explanation order.
08:08:20 * EvilTerran notes, with -XInfixTypeOperators and "infixr :|:; type (:|:) = Either", you could write that "a :|: (a,b) :|: (a,b,c) :|: (a,b,c,d)"
08:08:26 <EvilTerran> :D
08:09:08 <GPC> quicksilver: As for me, a proper example of how to use Either would've helped... maybe. On the other hand, this exercise is kinda "around-the-corner"-thinking and not so obvious. At least not to me
08:09:55 <quicksilver> I think it's a very valuable exercise actually
08:10:06 <GPC> Once you mastered it, yes ;)
08:10:09 <quicksilver> I'm not sure the best thing the book could do to 'set it up' better.
08:11:47 <Axman6> GPC: stick around, you 'll learn a lot, and people here are always very helpful
08:11:58 <Jedai> GPC: You may want to remove some parens from your expression when you're more familiar with Haskell syntax, for example "Right (Right (Left (a, b, c)))" can be written "Right . Right . Left $ (a, b, c)"
08:12:23 <Axman6> :t Right
08:12:24 <lambdabot> forall b a. b -> Either a b
08:12:26 <GPC> Jedai: looks similar to function composition, doesn't it?
08:12:36 <Jedai> GPC: it is function composition
08:12:38 <Axman6> GPC: that's because it is :)
08:12:44 <Axman6> GPC: constructors are functions too
08:12:48 <GPC> Oh right, "constructors" are actually functions
08:12:48 <Axman6> :t Just
08:12:49 <lambdabot> forall a. a -> Maybe a
08:12:50 <Jedai> GPC: (.) is the function composition operator
08:14:18 <portnov> (it's a function too) :)
08:14:28 <GPC> Jedai: I must admit, the lack of parentheses is kinda odd to me (being a C++ developer)
08:14:30 <EvilTerran> ?src (.)
08:14:30 <lambdabot> (f . g) x = f (g x)
08:15:21 <Axman6> GPC: parens are ugly
08:15:58 <GPC> Well, I guess it's a matter of taste, usage and in which environment they're used.
08:16:04 <Peaker> idnar: cool.. tell yairchu as well
08:16:36 <Axman6> hmm, i wonder how well a language would go that didn't need closing parens where their use can be inferred. like "Right (Left (2"
08:16:38 <GPC> I do see that they're considered kinda ugly in Haskell though :)
08:16:38 <portnov> GPC, for parens see Lisp and its family )
08:17:19 <GPC> portnov: Okay, that's kinda extreme ;)
08:17:40 <EvilTerran> GPC, the fundamental issue with parens is that you end up with two syntactic elements, "(" and ")", that are inexorably linked, but arbitrarily far apart and arbitrarily nested
08:18:09 <Axman6> by which he means their evil
08:18:21 <GPC> Now well, I guess they can get confusing
08:19:05 <GPC> Btw.. don't get me wrong, I'm not defending parens, it's just unusual to me to not use them :)
08:19:30 <Axman6> you
08:19:36 <Axman6> you'll learn* :)
08:19:40 <EvilTerran> and, if you can represent the same thing with only one syntactic element, there's no risk of half the construct getting mis-placed
08:20:30 <FunctorSal> () are still better than ""
08:20:37 <FunctorSal> syntactically ;)
08:21:29 <EvilTerran> yeah, you don't get leaning toothpick syndrome trying to nest ()s
08:22:12 <idnar> EvilTerran: on the other hand, you're not tempted to nest "" as much
08:22:18 <idnar> (or required)
08:30:13 <RayNbow> > 0^0
08:30:15 <lambdabot>   1
08:32:07 <quicksilver> idnar: you'd obviously not done as much horrific shell scripting as I have :)
08:32:31 <quicksilver> try writing perl code which generates a makefile which contains shell code to execute SQL commands, and then try to add a single quote :)
08:33:16 <idnar> quicksilver: what kind of lunatic would do a thing like that???? *efg*
08:44:51 <skorpan> who put the "title" tag on the body element in the parsec documentation?
08:44:52 <skorpan> :P
09:00:19 <solrize> http://www.archivist.info/addedsql.jpg <-- i guess you get results like this (ingredients list fail)
09:00:19 <Meady> Guys is it better to avoid argument processing/parenthesis
09:00:21 <solrize> quicksilver
09:00:23 <Meady> i.e. func (12*12)
09:00:30 <Meady> Or doesnt it matter
09:01:02 <solrize> meady the parens are necessary in that example
09:01:21 <solrize> > (+1) 12 * 12
09:01:23 <lambdabot>   156
09:01:38 <solrize> > show 12 * 12
09:01:39 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
09:01:39 <lambdabot>    arising from the literal `...
09:01:51 <lilac> Meady: you could say func $ 12 * 12, if you prefer
09:02:35 <quicksilver> solrize: :)
09:02:37 <GPC> What's the meaning of the dollar sign here? Argument grouping?
09:02:45 <Meady> lilac im reading that its prefered mostly as a precalculated
09:02:49 <Meady> so func result
09:02:54 <quicksilver> GPC: a $ b is (a) (b)
09:03:07 <quicksilver> GPC: it's just an operator form of function application but since it has very low precedence
09:03:11 <quicksilver> you can use it to avoid some parens.
09:03:24 <GPC> quicksilver: I see, thanks
09:03:46 <quicksilver> it's occasionaly useful in sections
09:03:58 <quicksilver> Want to apply multiple functions to the same argument?
09:04:03 <quicksilver> map ($x) [f,g,h]
09:04:11 <GPC> I also saw it being used with function composition before and wondered
09:04:17 <Axman6> GPC: it's often used like f . g . h $ x instead of (f . g . h) x
09:04:44 <Axman6> it's a paren remover ;)
09:04:45 <GPC> Down with the parens, huh? ;)
09:04:56 <FunctorSal> @type ($) ($) ($)
09:04:57 <lambdabot> forall a b. (a -> b) -> a -> b
09:05:02 <FunctorSal> hmm
09:05:45 <quicksilver> FunctorSal: in prefix position ($) is just the identity on functions.
09:05:53 <quicksilver> FunctorSal: and "id id id" is still id :)
09:06:01 <FunctorSal> true...
09:06:56 <Axman6> > id id id id id id id id id id id id id id id id id id id id id id id id id "id"
09:07:01 <lambdabot>   mueval-core: Prelude.read: no parse
09:07:01 <lambdabot>  mueval: ExitFailure 1
09:07:08 <LeoD> huh
09:07:10 <Axman6> o.O
09:07:18 <Axman6> > id id id "id"
09:07:19 <lambdabot>   "id"
09:07:23 <Axman6> how odd :o
09:07:40 <Axman6> > id id id id id id id id id id id id id id id id id id id id "id"
09:07:44 <lambdabot>   "id"
09:07:53 <Axman6> > id id id id id id id id id id id id id id id id id id id id id "id"
09:07:58 <lambdabot>   mueval-core: Prelude.read: no parse
09:07:58 <lambdabot>  mueval: ExitFailure 1
09:08:04 <Axman6> O.O
09:08:20 <FunctorSal> > length "id id id id id id id id id id id id id id id id id id id id id " `div` 3
09:08:21 <lambdabot>   21
09:08:41 <quicksilver> :t id id id id id id id id id id id id id id id id id id id id id "id"
09:08:43 <lambdabot> [Char]
09:08:48 <quicksilver> how peculiar.
09:10:03 <FunctorSal> nobody will ever need more than 21 levels of nesting?
09:10:14 <byorgey> it doesn't *parse* ?
09:10:31 <ziman> i'd guess it's a limitation of mueval
09:10:58 <byorgey> yes, but I am having trouble imagining what kind of limitation would lead to such an error.
09:11:04 <FunctorSal> hmm... the type does growth exponentially, doesn't it?
09:11:16 <FunctorSal> String -> String, then (String -> String) -> (String -> String) etc
09:11:25 <byorgey> yeah, but why would that make it not *parse* ?
09:11:46 <byorgey> surely it doesn't interleave parsing and type checking.
09:11:49 <AVbd> they could have put a deliberate limitation on it to avoid abuse or something
09:11:49 <FunctorSal> maybe it says "no parse" if the security checker fails to terminate after some time?
09:11:59 <byorgey> well, that could be.
09:12:19 <lilac> @type id id id id id id id id id id id id id id id id id id id id id
09:12:20 <lambdabot> forall a. a -> a
09:12:27 <lilac> @type id id id id id id id id id id id id id id id id id id id id id "id"
09:12:28 <lambdabot> [Char]
09:12:51 <quicksilver> byorgey: "@68-187-218-249.dhcp.oxfr.ma.charter.com] has  joined #haskell
09:12:55 <quicksilver> damn.
09:13:03 <byorgey> quicksilver: thanks for letting me know
09:13:08 <quicksilver> byorgey: "mueval-core: Prelude.read: no parse" does not mean the string you gave it didn't parse
09:13:10 <byorgey> =)
09:13:14 <FunctorSal> @type ?x id id id id id id id id id id id id id id id id id id id id "id"
09:13:16 <lambdabot> forall t a a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19. (?x::(a -> a) -> (a1 -> a1) -> (a2 -> a2) -> (a3 -> a3) -> (a4 -> a4) -> (a5 -> a5) -> (a6 -> a6) -> (a7 -> a7) -> (a8 -
09:13:16 <lambdabot> > a8) -> (a9 -> a9) -> (a10 -> a10) -> (a11 -> a11) -> (a12 -> a12) -> (a13 -> a13) -> (a14 -> a14) -> (a15 -> a15) -> (a16 -> a16) -> (a17 -> a17) -> (a18 -> a18) -> (a19 -> a19) -> [Char] -> t) =>
09:13:16 <lambdabot> t
09:13:20 <byorgey> quicksilver: oh, what does it mean?
09:13:22 <FunctorSal> :o
09:13:23 <quicksilver> it means something else, which it refuses to tell you about, didn't parse
09:13:32 <quicksilver> some kind of output from ghc I think
09:13:36 <Axman6> yeah
09:13:38 <byorgey> oh! I see.
09:13:42 <byorgey> that would make sense.
09:13:52 <lilac> but still, the input is a well-formed fragment of haskell
09:13:54 <quicksilver> you see that messafe when it gets a ghc error condition it doesn't know how to report.
09:14:29 <byorgey> ah.  someone should patch it so it uses 'reads' instead of 'read'.
09:15:03 <byorgey> and then gives a sensible error message, like "error: I have no idea what the hell ghc just said to me."
09:15:24 <FunctorSal> "user error"
09:15:30 <lilac> hmm. my local mueval seems to time out on that input
09:16:05 <FunctorSal> you could fire up the profiler if you really care
09:17:10 <quicksilver> byorgey: error: mueval: my brain just exploded
09:17:44 <quicksilver> or perhaps: You are in a maze of type inference errors, all alike. It is dark. You may be eaten by a grad student.
09:18:00 <burp> anyone using happstack stat with ixset? I'm trying to build a quote-datastructure for my bot: data Quotes = Quotes (IxSet Quote) deriving (Typeable, Show)
09:18:07 <burp> $(deriveSerialize ''Quotes)
09:18:17 <burp> "No instance for (Serialize Quote)"
09:18:45 <burp> hm
09:20:41 <burp> an example with ixset and happstack state would be good
09:23:15 <Meady> Guys, hPutStrLn sock "JOIN " ++ chan says found IO expected [a]
09:23:22 <Meady> ++ chan isnt IO is it :S?
09:24:01 <Lemmih> Meady: hPutStrLn sock ("JOIN " ++ chan)
09:24:06 <Meady> I see
09:24:12 * Zao huggles ($)
09:24:22 <Meady> without the perenthesis, it would be 2 arguments right?
09:24:49 <FunctorSal>  (hPutStrLn sock "JOIN ") ++ chan -- without the parens it's this
09:24:51 <Zao> Your expression is roughly   (((hputStrLn sock) sock) "JOIN ") ++ chan
09:24:55 <LeoD> three actually
09:25:00 <LeoD> no wait
09:25:03 <Meady> ++ would count as one?
09:25:08 <LeoD> no nevermind :P
09:25:50 <Ffxk> HI
09:27:11 <Woof> Eh
09:27:17 <Woof> How do I stop lambdabot in pm?
09:27:19 <Woof> : /
09:28:58 <Woof> Nvm
09:30:34 <Twey> Is it possible to get an in-memory binary representation of a data-type, one that can be transmitted across a data stream with no need to encode/decode it at each end?
09:31:02 <Axman6> if it's a ByteString, sure >_>
09:31:57 <Twey> Axman6: Ha ha :-P
09:32:06 <Axman6> :)
09:32:19 <Heffalump> Twey: no, because typically the in-memory representation will involve pointers
09:32:25 <Twey> Ah, right
09:32:27 <Heffalump> but look for things with Storable instances
09:32:49 <Heffalump> though those may well do encoding/decoding themselves
09:32:54 <Heffalump> but hey, what are type classes for?
09:33:04 <Twey> Yeah...
09:33:07 <nominolo|uni_> @users
09:33:07 <lambdabot> Maximum users seen in #haskell: 658, currently: 600 (91.2%), active: 22 (3.7%)
09:34:18 <Twey> I was just wondering why more applications don't use external FIFOs for internal communication, taking advantage of the benefits that provides, like scriptability, module-independence, and so on
09:34:46 <Twey> I guessed it was probably something to do with programmer and runtime inefficiency, doing all that recoding
09:39:53 <Vanadium> Twey: Bad excuse considering half of unix is text-based anyway O:)
09:40:02 <Twey> Yeah, heh
09:40:11 <Meady> whats the raw IRC command to register with nickserv
09:40:29 <Twey> Meady: PRIVMSG NickServ :REGISTER password email
09:40:54 <Meady> ah ok
09:41:21 <Meady> i get not registered with that tho
09:41:41 <Meady> ahh i know
09:45:14 <Meady> Why does hGetcontents hang?
09:46:45 <Twey> Because it's looking for more content?
09:47:18 <Meady> ahh
09:47:26 <lilac> Meady: on what sort of handle?
09:48:11 <lilac> on a file handle it should stop at EOF, but on other types of handle it might need to wait in order to find the EOF
09:48:30 <lilac> i should say, on a regular file handle.
09:48:34 <Twey> Even on a file handle, for certain types of file
09:48:36 <Twey> Right :)
09:49:01 <lilac> put another way, it'll stop at EOF on all handles, but sometimes it doesn't know where EOF is yet
09:49:33 <Meady> Ahh ok
09:50:14 <Twey> For example, if you use it on stdin, it will continue reading until the user inputs an EOF with C-d (or Windows C-z)
09:53:12 <Meady> How can i loop socket
09:53:19 <Meady> say i want to loop the reading
09:53:23 <Meady> until theres nothing to be read
09:53:36 <Meady> hGetLine sock is fine
09:53:44 <Twey> hGetContents will do that for you, at least if you force it
09:54:09 <Meady> But hGetcontents is blocking
09:54:20 <Twey> Until there's nothing to be read, yes
09:54:24 <Twey> You just said you wanted that
09:54:45 <Meady> Yeah, but its blocking even when theres nothing
09:54:58 <Meady> Read line until there is nothing left in socket buffer
09:55:40 <Twey> Meady: Aha  you want non-blocking IO
09:55:44 <Lemmih> Meady: Use forkIO, hGetLine and a Chan?
09:55:45 <Meady> INdeed!
09:55:48 <Meady> :s
09:55:49 <Meady> huh
09:56:18 <Meady> whats the simplest way of non blocking
09:56:47 <Twey> I think what Lemmih says is the best way
09:56:50 <Heffalump> you could use hReady or hIsReady
09:56:55 <Meady> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#v:forkIO
09:56:57 <Heffalump> or just let the underlying stuff do it for you
09:57:13 <Twey> There's also working with h(Put|Get)BufNonBlocking
09:57:21 <Meady> so its literally just forkIO func?
09:59:11 <Meady> forkIO (hGetContents sock >>= putStrLn)
10:00:45 <Twey> Meady: Er, that's one way of doing it, but not very useful
10:04:11 <Meady> looprecv sock  = do
10:04:11 <Meady> 			ret <- hGetContents sock
10:04:11 <Meady> 			putStrLn ret
10:04:11 <Meady> 			looprecv sock
10:04:11 <Meady> 		
10:04:11 <Meady> main = do
10:04:13 <Meady> 		sock <- connectTo server (PortNumber (fromIntegral port))
10:04:15 <Meady> 		hSetBuffering sock NoBuffering
10:04:17 <Meady> 		forkIO (looprecv sock)
10:04:26 <Meady> thats quite messy, how could i define the function inside forkio, using lambda?
10:05:24 <ziman> [there's hpaste.org for more than two lines of code ;) ]
10:05:40 <quicksilver> Meady: forkIO (forever $ hGetContents sock >>= putStrLn)
10:05:53 <ziman> hGetCOntents will read until EOF so I don't see running it multiple times on the same socket useful
10:06:02 <Meady> ive changed it for line
10:06:06 <quicksilver> yes, it's quite likely 'hGetLine' would be better :)
10:06:08 <Meady> :t forever
10:06:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:06:54 <log0ut> Meady, think about hGetContents as that it has actually read everything which will ever come into the socket.
10:06:57 <Twey> Meady: forkIO \sock -> hGetContents sock >>= putStrLn >> looprecv
10:07:11 <LeoD> what's the implementation of forever? i mean where does it get the 'm b' from?
10:07:13 <Twey> But that's not what we suggested at all
10:07:18 <Twey> @src forever
10:07:18 <lambdabot> Source not found. Maybe if you used more than just two fingers...
10:07:22 <Twey> Hmph
10:07:24 <LeoD> yeah :/
10:07:36 <Meady> Hmm
10:07:43 <Twey> LeoD: forever act = act >> forever act
10:07:50 <ziman> LeoD, forever will never return so it can return values of any type :)
10:07:54 <Meady> while the socket isnt close hGetContents is ran forever?
10:07:55 <LeoD> hm, right
10:07:58 * Twey nods.
10:07:59 <LeoD> nifty
10:08:25 <Meady> forkIO (looprecv sock)
10:08:26 <Meady> 		forkIO (loopsend sock)
10:08:29 <Meady> woould that work
10:08:29 <Meady> ?
10:08:30 <Twey> Meady: Yeah, but it will just print it interlaced with the contents of the rest of the program, which isn't what you want to do at all
10:08:34 <Meady> looprecv sock  = do
10:08:34 <Meady> 			ret <- hGetLine sock
10:08:34 <Meady> 			putStrLn ret
10:08:34 <Meady> 			looprecv sock
10:08:34 <Meady> 		
10:08:34 <Meady> loopsend sock = do
10:08:36 <Meady> 			sen <- getLine
10:08:38 <Meady> 			hPutStr sock sen
10:08:39 <ziman> in fact, Prelude.forever is (unnecessarily) restricted to m (), iirc
10:08:40 <Meady> 			loopsend sock
10:08:43 <log0ut> Meady: as soon as you say ret <- hContents, you are now able to treat ret as though it holds all data that will ever in the future come into the socket, because it is lazy.
10:08:53 <Twey> You seem to have missed ziman's original comment about hpaste
10:08:53 <ziman> Meady, hpaste please
10:08:54 <log0ut> Even if it hasn't come in yet.
10:08:57 <Meady> ahhh i see logout
10:09:04 <Meady> so i can just keep printing?
10:09:25 <log0ut> When you print it, that causes it to actually read (and block if there is nothing to read)
10:09:28 <Twey> What Lemmih suggested was to get each line with hGetLine and then write it to a Chan
10:09:34 <Meady> yeah
10:09:36 <Meady> so i could fork it?
10:09:46 <ziman> hm, it's not.
10:09:49 <Twey> You fork that, yes
10:10:13 <Twey> Then you can read the Chan  after checking if there's anything in the Chan using Control.Concurrent.isEmpty
10:10:25 <quicksilver> log0ut: please don't call that lazy.
10:10:38 <Meady> :t forever
10:10:39 <log0ut> quicksilver: Well, ok, I mean it acts like a pipeline.
10:10:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:10:44 <Meady> what do i import to use forever?
10:11:49 <quicksilver> "You are now able to treat ret as though it holds all the data that will ever in the future come into the socket, because it is X" : possible values for X are "a broken primitive"; "weird unsafe shit", "a clever trick using GHC internals", "interleaving IO with evaluation in a subtle way"
10:11:52 <LeoD> Meady: Control.Monad
10:11:54 <quicksilver> ;)
10:12:06 <portnov> @index installHandler
10:12:06 <lambdabot> System.Posix.Signals, System.Posix.Signals.Exts, System.Posix
10:12:16 <Twey> quicksilver: *grin*
10:12:57 <Twey> I find forever to be a bit of a misleading name.
10:12:58 <Meady> 			ret <- hGetContents sock
10:12:58 <Meady> 			forever (putStrLn ret)
10:12:58 <Meady> 		
10:13:06 <Twey> It calls to mind IO.
10:13:15 <Twey> It's really more like mfix
10:13:38 <Meady> can two fork IOS print in the same console without problems?
10:13:52 <Twey> Define without problems
10:13:58 <Twey> There's a possibility they'll interleave
10:14:25 <Twey> I.E. putStrLn "foo" and putStrLn "bar" can overall print something like "fbooar"
10:14:57 <Twey> You should set aside a thread that just prints whatever it receives, if you don't want that to happen
10:15:22 <quicksilver> Twey: well, it calls to mind "some monad where progress feels timelike"
10:15:42 <quicksilver> Twey: it's not related to mfix, though. Just to plain 'fix'.
10:16:00 <quicksilver> forever $ blah is fix (\x -> blah >> x)
10:16:08 <Twey> quicksilver: Exactly
10:16:11 <Twey> It's fix for monads
10:16:16 <quicksilver> mfix is something other.
10:16:18 <Meady> ahh ok
10:16:20 <Twey> I thought it might be
10:16:23 <Twey> What is mfix?
10:16:25 <Twey> @src mfix
10:16:25 <lambdabot> Source not found. stty: unknown mode: doofus
10:16:28 <coCocoa> forever == fix (>>) ? :)
10:16:29 <Meady> looprecv sock  = do
10:16:29 <Meady> 			ret <- hGetContents sock
10:16:29 <Meady> 			forever (putStrLn ret)
10:16:29 <Meady> 		
10:16:29 <Meady> 		
10:16:29 <Meady> loopsend sock = do
10:16:30 <Twey> :t mfix
10:16:31 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
10:16:31 <Meady> 			sen <- getLine
10:16:33 <quicksilver> mfix is where the fixed point is taken "through" the monadicity.
10:16:33 <Meady> 			hPutStr sock sen
10:16:35 <Meady> 			loopsend sock
10:16:37 <Meady> 		forkIO (looprecv sock)
10:16:39 --- mode: ChanServ set +o quicksilver
10:16:39 <Meady> 		forkIO (loopsend sock)
10:16:40 --- kick: Meady was kicked by quicksilver (quicksilver)
10:16:54 <Meady> sigh
10:16:54 <Twey> quicksilver: Aha
10:16:59 <quicksilver> which means, mfix has a different definition for each monad
10:17:01 <Meady> Tyvm quicksilver
10:17:03 * Twey nods.
10:17:05 <quicksilver> although, they mostly look similar.
10:17:09 <quicksilver> Meady: please use hpaste ;0
10:17:14 <Meady> Please ask
10:17:16 <Twey> Meady: You're welcome  please hpaste next time
10:17:18 <Twey> You were asked thrice
10:17:26 <quicksilver> Meady: you were asked twice.
10:17:34 <Twey> Once by me, and twice by ziman
10:17:37 <Meady> how do i clear hGetContents, so it doesnt print same thing twice
10:17:44 <Meady> Ok guys, easy on the gangbanging yeh?
10:17:49 <Twey> I answered that, too
10:17:51 <Twey> 18:15:03 < Twey> You should set aside a thread that just prints whatever it receives, if you don't want that to happen
10:18:00 <quicksilver> hGetContents always gets "everything"
10:18:06 <quicksilver> you should only call it once, if at all.
10:18:08 <Meady> lol ok
10:18:09 --- mode: quicksilver set -o quinter
10:18:13 --- mode: quicksilver set -o quicksilver
10:18:19 <quicksilver> hGetLine is for one line at a time (e.g)
10:18:20 <Twey> Oh, you were asking a different question  I apologise
10:18:26 <quicksilver> and that certainly won't get the same thing twice.
10:18:26 <Twey> quicksilver: Heh, tab completion strikes
10:18:39 <Twey> 18:09:34 < Twey> What Lemmih suggested was to get each line with hGetLine and then write it to a Chan
10:18:42 <Twey> 18:10:19 < Twey> Then you can read the Chan  after checking if there's anything in the Chan using Control.Concurrent.isEmpty
10:18:48 <quicksilver> "once" <- well, once per handle.
10:20:05 <Meady> sigh at hpaste
10:20:21 <quicksilver> you can use another pastebin if you don't like hpaste, we're not fussy.
10:20:26 <Meady> http://pastebin.com/mf040179
10:20:27 <quicksilver> codepad will even run your haskell, which is quite neat.
10:20:52 <Meady> Run that guys, notice how you dont get any more data from server, yet same thing in a telnet client will constantly send messages how your not registered
10:21:03 <lilac> "forever act = act >> forever act" looks wrong to me. shouldn't it be "forever act = let result = act >> result in result"?
10:22:31 <paolino> @src forever
10:22:31 <lambdabot> Source not found. I feel much better now.
10:23:13 <lilac> forever a   = a >> forever a
10:23:31 <lilac> (according to the GHC docs on haskell.org)
10:23:36 <Meady> You see, i pastebin and get no help
10:23:41 <Meady> foooking charming
10:23:43 <Twey> 18:07:48 < Twey> LeoD: forever act = act >> forever act
10:23:51 <quicksilver> Meady: I was just typing a response.
10:23:54 <lilac> Meady: we're not your slaves, you know :)
10:23:54 <quicksilver> I have deleted it.
10:24:05 <LeoD> @type forever
10:24:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:24:06 <quicksilver> I do not help people, for free, who have just called me fucking charming.
10:24:10 <Meady> But you are interested in helping, or you wouldnt be here?
10:24:17 <paolino> lilac: I used forever  before, it worked
10:24:17 <Meady> well apparently your not interested by yeh
10:24:22 <LeoD> hm, the docs on haskell.org say m (m a) -> m a
10:24:23 <Twey> Maybe we're working on it
10:24:26 <Twey> Did you think of that?
10:24:41 <LeoD> ohh sorry, was looking at the wrong line
10:24:47 <lilac> paolino: they're functionally equivalent, but i think in some cases the latter will use less space
10:25:03 <paolino> ok
10:25:03 <lilac> paolino: that said, i'm having trouble thinking of such a case, so perhaps it actually can't happen...
10:25:06 <Meady> Lol okok
10:26:15 <Meady> Anyone notice how it stops printing data after the first sending?
10:26:23 <paolino> anyway the idiom has always been forkIO . forever
10:26:30 <Meady> i could imagine that being using 1 socket in 2 places
10:26:54 <paolino> looprecv looks different
10:26:59 <lilac> Meady: could be that your handle is being closed at some point?
10:27:17 <Meady> I dont think the handle closes till the socket is close
10:27:18 <Meady> d
10:27:39 <lilac> Meady: also your looprecv looks broken to me
10:27:46 <Meady> i see, how so
10:28:04 <lilac> Meady: it looks like it'll print whatever it's received over and over again (once it gets to EOF)
10:28:11 <Meady> Yeha
10:28:12 <Meady> it will
10:29:53 <Meady> question, if i call a function from the different threads, will it waiti till free to execute?
10:30:25 <lilac> what happens if a program gets to the end of main with forkIO'd threads still running?
10:30:41 <lilac> Meady: until what's free?
10:30:43 <paolino> it exits
10:30:57 <Meady> the socket lilac
10:31:06 <lilac> that's what i thought. in that case i'm a little surprised that's not what Meady's seeing
10:31:32 <lilac> Meady: i don't think it waits (but i could be wrong)
10:31:43 <Meady> it is
10:31:46 <Meady> that is the issue
10:31:58 <Meady> if i put a socket send inside the recv loop it works fine
10:32:02 <paolino> second forkIO is wrong
10:32:06 <Meady> in another and the socket blocks each IO
10:32:33 <Meady> so i need to basically pass the command to be sent to the recv function
10:33:41 <lysgaard> Is arrays in haskell just stupid since it's functional?
10:34:17 <Meady> so i need to basically check to see if theres a command to be sent on each loop
10:34:22 <Meady> so it stacks instead of runs at same time
10:34:36 <lilac> lysgaard: there are uses of immutable arrays which lead to efficient and clean algorithms, but it can be trickier than using mutable state
10:34:53 <lilac> lysgaard: there's also STArray if you want mutable arrays temporarily in a pure computation
10:35:07 <ziman> for example, dynamic programming is usually clean with lazy immutable arrays
10:36:28 <lysgaard> Hm. well. I want to implement a routing table, but it seems very akward to make it an array..
10:36:44 <paolino> hGetContents read lazily ?
10:37:21 <coCocoa> lysgaard:   Why not a map? :)
10:37:33 <Meady> oooo
10:37:55 <Meady> i could have a thread, with an infinate list of getLine from the socket, and when i want to send a command i could insert a command at the head of the list?
10:37:57 <lysgaard> Well, it's two dimentional
10:38:35 * coCocoa mumbles something about using pairs...
10:38:41 <Meady> im trying to think of a way of doing this @:s
10:40:14 <lilac> Meady: you might want to read this: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
10:42:03 <lysgaard> coCocoa: Maybe, but it's quite big. What about having a map describing the y direction, and each key leading to another map representing the x direction?
10:43:16 <lilac> lysgaard: how dense is this table?
10:44:14 <lysgaard> lilac: Not very. If you mean how many possitions (x,y) have a value.
10:44:18 <lilac> yes
10:44:29 <Meady> how do we pop something into the start of a list
10:44:30 <Meady> an io action
10:44:38 <Meady> or a function call in general
10:44:46 <lilac> Meady: something:list
10:44:58 <Meady> so literally on its own ?
10:45:09 <Meady> 10:myints would pop 10 to myints?
10:45:26 <lilac> Meady: 10:myints would produce a list which started with 10 and then contained myints
10:45:28 <lysgaard> lilac: Actually, if you wan to read what i want to make: http://www.freepastry.org/PAST/overview.ps
10:45:32 <ziman> > let myints = [11, 12] in 10 : myints
10:45:33 <lambdabot>   [10,11,12]
10:45:51 <ziman> there
10:45:58 <Meady> ty
10:46:08 <glguy> Does anyone know where the UnicodeSyntax language extension is documented?
10:46:09 <lysgaard> lilac: The datatype I'm having problems with is the routing table described there
10:46:17 <glguy> I'm wondering what all it enables
10:46:38 <Cale> lysgaard: You can have a Map with pairs as keys
10:47:06 <mauke> this is the opposite/opposite of pop
10:47:12 <Cale> (as well as an array with pairs as keys, if it's close to being dense and you don't need to update it often)
10:47:18 <Meady> and how would i call that list of functions to be done ?
10:48:28 <Meady> hmm
10:48:36 <Meady> :t foreach
10:48:37 <lambdabot> Not in scope: `foreach'
10:48:37 <lysgaard> Cale: Yeah, not a dumb idea. Wow, now i feel stupid :D
10:48:59 <Meady> cale how do i call a function thats inside a list
10:49:15 <Meady> a <- [list]?
10:49:33 <Cale> Meady: uh, can you explain a bit more what you're doing?
10:50:02 <Meady> say i have a list
10:50:16 <Meady> [putStr "hi",putStr "World"]
10:50:26 <Cale> (that isn't a list of functions)
10:50:33 <Meady> shizer
10:50:36 <Cale> but okay :)
10:50:49 <Cale> Remember I was talking about sequence before?
10:50:54 <Meady>  okok from the top then, let mylist = []
10:51:01 <Meady> if i wanted to pop something into it ide put..
10:51:02 <Cale> oh, an empty list?
10:51:13 <Meady> (popmeinto:mylist)?
10:51:22 <Meady> without perenthesis
10:51:32 <lilac> Meady: "pop" typically (in the context of data structures) means "remove an item from"
10:51:35 <Cale> well, yeah, you define a new list with the additional element
10:51:37 <Meady> sorry
10:51:38 <Meady> yeah
10:51:41 <Meady> right ok
10:51:50 <Meady> so how would i A. put a function into the list, and b grab it out
10:52:22 <Cale> I'm not sure that exactly makes sense.
10:52:27 <Jedai> Meady: You can't put a function into the list, you can only create a new list that include the function
10:52:34 <Cale> You defined mylist to be empty
10:52:38 <Cale> so it will always be empty
10:52:46 <Cale> You can make a new list with another element in it.
10:52:54 <Meady> okok, how would i pull an String from the list
10:52:58 <Meady> if i had a string inside it
10:53:05 <Cale> Normally by pattern matching
10:53:12 <Jedai> Meady: and as for "grabbing it out", the functions are just elements of the list, you can get them as with any list (head tail, pattern matching, (!!)...)
10:53:13 <Cale> f (x:xs) = ... use x here ...
10:53:36 <coCocoa> Meady: I think you meant "push" a String from the list... ;p
10:53:47 <LeoD> heh
10:53:50 <Meady> okok :p lol my term is a bit sucky
10:53:58 <Cale> But yeah, there are functions like !! which extracts the nth element. You should usually avoid !! though. Lists are meant to be operated on in a uniform way.
10:54:18 <Meady> yeah i want to run a function on every string in the list
10:54:36 <Cale> Well, to start with, there's map.
10:54:53 <Meady> that creates a new list, i dont need that
10:54:58 <Cale> eh?
10:55:08 <Cale> How would you like the results presented then?
10:55:14 <Meady> basically, for each string in list do putStr string
10:55:20 <LeoD> he probably wants mapM_
10:55:20 <Cale> okay
10:55:22 <mauke> forM_
10:55:23 <log0ut> Meady:  Are you using this list of functions to try to simulate a sequence of things happening?
10:55:23 <Cale> yes
10:55:27 <Meady> they wont be presented, they will be ran through a socket
10:55:36 <mauke> oh, they will be presented
10:55:39 <Meady> ok guys in structured english...
10:55:49 <mauke> every call to putStr will create an IO action
10:55:51 <Cale> Let me put it this way...
10:56:01 <Cale> you *do* want the list of actions, it's just not the last step
10:56:04 <mauke> you want to combine those actions into one big compound action
10:56:06 <coCocoa> Meady: Part of the "vibe" of functional/declarative programming is "explain what you want; worry about how the mechanism works later." :)
10:56:27 <Meady> loopfunc sock = hGetLine sock >>= putStr; for each string in list, hPutStr sock string, then loopfunc sock
10:56:38 <Cale> Meady: Suppose you had a way to take a list of actions and perform them all. Then you'd be done, right?
10:57:51 <Cale> Meady: You'd just map putStr over the list of strings, and get the list of actions you wanted, and then you'd use that bit I just mentioned to combine them.
10:57:54 <Meady> cale basically my socket operations block if i try to do more than one at once, so forkio isnt the solution, however i need to run getline then get line then get line, but i also need to be able to send
10:58:22 <Meady> nvm then ill write this one in pytho
10:58:22 <Meady> n
10:58:29 <paolino> Meady: (http://pastebin.com/m71f4b38a)
10:58:40 <lysgaard> Any efficient way to turn a number into a hexidecimal list?
10:58:50 <mauke> lysgaard: f _ = []
10:58:57 <lysgaard> Haha
10:59:08 <Meady> Doesnt that cause issues paolino with sockets on multiple threads
10:59:11 <coCocoa> lysgaard: Numeric.showHex? :)
10:59:27 <Cale> > showHex 43298432 ""
10:59:28 <lambdabot>   "294ae80"
10:59:42 <bd_> :t showHex
10:59:43 <lambdabot> forall a. (Integral a) => a -> String -> String
10:59:51 <bd_> what's the string argument for?
10:59:56 <Cale> > showHex 43298432 "hello"
10:59:58 <lambdabot>   "294ae80hello"
11:00:16 <bd_> surely ++ and a rewrite rule would be just as good :)
11:00:18 <coCocoa> > showHex 43298432 " in hexadecimal"
11:00:19 <lambdabot>   "294ae80 in hexadecimal"
11:00:22 <Cale> It's so that they can be efficiently chained together. (++) is expensive normally
11:00:22 <paolino> Meady: socket thread safeness is an OS issue, I believe
11:00:27 <Meady> ahh
11:00:31 <Meady> Paolino thats working fine
11:00:32 <Meady> i dont get it
11:00:37 <Cale> but (.) is constant time
11:01:17 <paolino> Meady: like python
11:01:41 <conal> perhaps ShowS could be replaced by Data.DList
11:01:44 <Meady> paoline, how comes my one didnt work when i forked both
11:01:48 <Cale> I don't like Data.DList
11:01:58 <SamB> Cale: what's wrong with it?
11:02:03 <Cale> It's straightforward just to use functions.
11:02:16 <paolino> Meady there are some errors , not one
11:02:18 <SamB> you don't like my newtype?
11:02:28 <SamB> it can't be a Monoid without that newtype nowadays, you know
11:02:30 <Meady> would you point them out
11:02:49 <lysgaard> coCocoa: Hm, strange I don't have the function, is it a part of any library?
11:02:52 <Cale> Well, sure, you can use the Endo monad if you really need it.
11:02:53 <Meady> http://pastebin.com/mf040179
11:02:58 <Cale> monoid*
11:02:59 <lilac> showHex :: Integral a => a -> ShowS
11:03:02 <coCocoa> SamB: But it's an endofunction! :)
11:03:06 * Cale is not 100% awake :)
11:03:27 <Cale> But (.) is good enough notation for the monomorphic case
11:03:33 <coCocoa> SamB: ...yeah, what Cale said. :)
11:03:36 <lysgaard> coCocoa: forgeti it, my bad :S
11:03:51 <Cale> and id is much nicer to write than mempty
11:04:01 <Meady> 		forkIO (do
11:04:02 <Meady> 				ret <- hGetContents sock
11:04:02 <Meady> 				forever $ putStrLn ret)
11:04:05 <lilac> type String = ShowS; ...
11:04:06 <Meady> Is that a better way of putting it
11:04:06 <SamB> Cale: that sounds like it'd be ugly when using MonadWriter
11:04:06 <Meady> ?
11:04:26 <paolino> yes, on pastebin
11:04:44 <Cale> SamB: eh, well, if it's MonadWriter, you just wrap the functions in Endo.
11:04:55 <lilac> Meady: why do you say 'forever $ putStrLn ret' not just 'putStrLn ret'?
11:04:58 <burp> newtype Name = Name String deriving (Read,Show) .. how do I get the string value of a Name? with read I get "Name str"
11:05:00 <Cale> SamB: But otherwise, you don't really need to wrap them in anything.
11:05:02 <SamB> Cale: how can you do that prettily?
11:05:07 <lilac> Meady: or even 'putStr ret' actually
11:05:18 <Cale> SamB: How do you do anything with DList prettily?
11:05:30 <Cale> SamB: It's exactly as pretty as DList
11:05:54 <SamB> maybe you should just use 0.1
11:05:58 <SamB> it didn't have the newtype
11:06:08 <SamB> (though it might be buggy)
11:06:19 <Cale> (but why import anything at all!)
11:06:52 <SamB> Cale: well, you know, there's no point in using the package if you'd rather do it yourself ;-P
11:07:08 <Cale> Right, that's my point.
11:07:15 <SamB> so why complain?
11:07:26 <SamB> you don't even WANT the bikeshed, so just don't use the bikeshed
11:07:31 <SamB> there's plenty of grass for everyone
11:07:37 <Cale> Eh?
11:07:46 <byorgey> Meady: 'forever $ putStrLn ret' means 'ret' will be printed an infinite number of times, which I doubt is what you want.
11:08:00 <SamB> well, I was thinking that usually when you build a bikeshed, it replaces some grass
11:08:01 <paolino> lilac: it works :) nice, forkIO $ hGetContents sock >>= putStr
11:08:03 <Cale> I didn't randomly bring up DList to complain about it ;)
11:08:17 <Meady> Ah i see
11:08:26 <SamB> Cale: oh, true
11:08:31 <Cale> Conal mentioned it and I just pointed out that I didn't like it.
11:08:44 <Cale> I think the direct style is nicer.
11:08:52 <Meady> http://pastebin.com/mf040179 why doesnt that work
11:08:59 <SamB> Cale: it's certainly fine for ShowS
11:09:22 <LeoD> why is {-# INLINE ... #-} used so much? can't the compiler figure out itself when to inline function calls?
11:09:23 <ziman> Meady, because there's an error
11:09:33 <paolino> 3 errors
11:09:38 <SamB> I agree that there'd be no point in replacing ShowS with DList Char -- just pain, no gain
11:09:42 <Meady> show me
11:09:54 <byorgey> Meady: you're still using 'forever' there
11:10:08 <Meady> ??
11:10:21 <byorgey> Meady: and you probably don't want to use hGetContents. It reads EVERYTHING lazily, and puts the handle in a semi-closed state.
11:10:26 <Cale> Meady: you should generally avoid hGetContents on a handle obtained from a network connection, except for really simplistic situations.
11:10:30 <byorgey> so it wouldn't work after the first time.
11:10:36 <Meady> ok
11:10:45 <byorgey> isn't there an hGetLine ?
11:10:46 <SamB> Cale: unless of course you wanted to concatMap or something like that ...
11:10:53 <SamB> does DList even have concatMap?
11:10:55 <paolino> byorgey: here it works :)
11:11:11 <SamB> @hoogle concatMap
11:11:12 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
11:11:12 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
11:11:12 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
11:11:18 <SamB> @hoogle DList concatMap
11:11:18 <lambdabot> No results found
11:11:19 <Meady> so just to clarify, i understand hGetContents is 1 error, the other 2?
11:11:29 <byorgey> paolino: ah, I guess it might.  but still...
11:11:46 <paolino> Meady: hPutStr sock sen ....
11:12:03 <paolino> never send a line
11:12:11 <Meady> that was my issue
11:12:13 <Cale> SamB: The foldr is implemented via cheating (which is really the only reasonable way) and converting back to a list, map and concat in terms of that. There's no specialised concatMap
11:12:28 <Meady> why paolino
11:12:31 <paolino> Meady: and last forkIO is wrong
11:12:40 <themroc-> is there any predifined list operation to merge two lists and having the duplicates removed automatically?
11:12:54 <paolino> take it away and use main thread
11:13:16 <byorgey> themroc-: no, you can just do   nub (l1 ++ l2)
11:13:18 <Meady> can i not use 2 paolino? and why did it never send?
11:13:25 <mauke> themroc-: are the lists sorted?
11:13:30 <paolino> Meady: hPutStrLn is what you want there
11:13:47 <themroc-> mauke no they're not
11:13:54 <themroc-> nub, hmmm, lemme c :p
11:14:02 <SamB> Cale: oh, and I guess you'd probably not usually really want to concatMap over a DList ...
11:14:06 <themroc-> ah great
11:14:11 <themroc-> thx byorgey :p
11:14:24 <Meady> AHH that was my issue, it was never returning
11:14:42 <SamB> more likely you'd want (a -> DList b) -> [a] -> [DList b]
11:14:51 <SamB> er.
11:14:53 <SamB> more likely you'd want (a -> DList b) -> [a] -> DList b
11:15:00 <SamB> whoops!
11:15:15 <paolino> Meady: protocol error, nothing to do with threads
11:15:37 <Meady> Pal i changed it slightly
11:15:56 <Meady> http://pastebin.com/m56ce9d0
11:16:07 <Meady> Works fine now but i really dont need full named functions so ill do it the other way
11:19:24 <Meady> :t foreach
11:19:24 <lambdabot> Not in scope: `foreach'
11:19:44 <quicksilver> mapM is a bit like foreach
11:19:51 <Meady> :t mapM
11:19:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:19:58 <quicksilver> forM_ has the arguments flipped so it looks nicer
11:20:11 <Meady> could you give a quick example
11:20:13 <quicksilver> e.g. forM_ ["apple","pear","ornage"] $ \s -> print s
11:20:17 <balor> I'm trying to get the head of a reversed list "head . (reverse [1, 2, 3])". But this gives me some type error. I thought function composition would mean that head would operate on the output of the reverse function.  Where am I going wrong?
11:20:18 <Meady> wicked, thanks
11:20:55 <mauke> balor: reverse [...] returns a list. you're trying to compose head with a list. that doesn't work; you can only compose functions
11:21:02 <Meady> > forM_ [1..20] (*2)
11:21:03 <lambdabot>   No instance for (GHC.Show.Show (m ()))
11:21:03 <lambdabot>    arising from a use of `M380787198...
11:21:06 <paolino> balor: (.) is composition not application
11:21:13 <mauke> balor: (head . reverse) [...] would work, though
11:21:25 <balor> mauke: ah. Thanks.
11:21:34 <Meady> > forM_ [1..20] $ \s -> s*10
11:21:35 <lambdabot>   No instance for (GHC.Show.Show (m ()))
11:21:35 <lambdabot>    arising from a use of `M667405856...
11:21:36 <mauke> or head (reverse [...])
11:22:06 <Meady> what do i import for form
11:22:44 <mauke> Meady: http://www.haskell.org/hoogle/?q=forM_
11:22:45 <Meady> Whats the GHCI Command again to import btw
11:22:52 <mauke> Meady: import
11:22:54 <log0ut> :m +
11:23:10 <log0ut> :m + Data.List or whatever.
11:23:13 <Meady> ty
11:23:24 <mauke> log0ut: but 'import' is easier to remember
11:23:35 <paolino> Meady, also read a tutorial .....
11:23:36 <log0ut> Slightly :P
11:24:12 <Meady> m + Control.Monad
11:24:15 <Meady> ON what paolino
11:24:27 <paolino> haskell
11:24:36 <mauke> basic haskell, functions and data structures
11:24:36 <Meady> Lol i have, im just rushing
11:25:22 <Meady> I am reading learnyouahaskell and the video tutorials atm
11:25:29 <paolino> :t forM
11:25:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
11:25:47 <paolino> the function argument is monadic
11:29:07 <paolino> lilac : here (unix) if main thread finish , program exits
11:29:23 <paolino> possibly windows is different ?
11:37:41 <kniu> hey guys
11:37:47 <kniu> what's the '|' character called?
11:38:08 <conal> kniu: i call it "such that"
11:38:16 <solrize> vertical bar, or "pipe" if you're a unix user
11:38:25 <kniu> thanks
11:38:45 <conal> kniu: do you mean the character, or its role in haskell, or what?
11:39:40 <coCocoa> kniu: It's the famous gladiator, solidus! ;p
11:40:01 <kniu> just the character
11:40:02 <pragma_> Semenis
11:40:05 <Gracenotes> I believe that's Mr. /
11:40:17 <conal> kniu: then i'd go with "vertical bar"
11:40:52 <Gracenotes> unicode calls it VERTICAL LINE... bar is common in practice...
11:41:23 <Gracenotes> hm... "Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process." (one of Perlis's epigrams) What do you think of this in the context of Haskell?
11:41:50 <Gracenotes> after all, when designing Haskell programs one tends to construct data structures first :)
11:43:10 <Gracenotes> on the other hand, when one wants to add/remove/change fields in an ADT... it can be tedious to replace everything throughout a program...
11:43:28 <Cale> Gracenotes: relative to OOP, everything is backward in functional programming
11:43:44 <Cale> Gracenotes: there's a certain duality to them
11:43:54 <Gracenotes> Cale: well. I don't think even OOP was around when Perlis wrote that.
11:44:46 <Gracenotes> or am I a few decades off? It seems I am.
11:45:06 <portnov> on the other hand, FP and OOP are the same :)
11:45:40 <Gracenotes> http://www.cs.yale.edu/quotes.html .. some are outdated, true..
11:46:45 <Cale> In Haskell, what I'd refer to as the standard FP style is to introduce datatypes with multiple cases, and write arbitrarily many functions on them which pattern match on the cases.
11:47:23 <Cale> If you want to do what I'd call the OO style, you define a datatype with a single case, but multiple fields, and those fields consist of the operations you want to support.
11:47:51 <Cale> Then you design as many values of that type (which are essentially implementations of those operations) as you want.
11:48:58 <Cale> (using normal functions as constructors, and parameters to those functions as what would be private data in an OO language)
11:51:10 <Cale> So "FP-style" fixes the data first, and allows easy extension of operations, and "OO-style" fixes the operations first, and allows easy extension of the data representations.
11:52:57 <dons> Cale: is it more type-directed that function-directed though.
11:53:05 <dons> so doooes the same approach work for, e.g. scheme?
11:54:04 <Gracenotes> this one's also fun: "A LISP programmer knows the value of everything, but the cost of nothing."
11:54:09 <Cale> I think so, sort of :)
11:54:20 <Cale> You just have to imagine the types then ;)
11:54:22 <Gracenotes> but the same would apply for Java or Python nowadays :)
11:54:59 <Gracenotes> at least the cost part. they can be somewhat sneaky...
11:55:05 <Cale> I like to think that there are types in scheme programs, it's just the compiler doesn't know about them.
11:55:29 <Gracenotes> >_>
11:55:37 <dons> there's always types.
11:55:45 <Berengal> Everything above assembly is typed in the mind of the programmer
11:55:57 <Berengal> And even assembly has types from time to time
11:56:20 <Cale> Even when writing assembly code -- well, especially when writing assembly code -- you have to think about types a lot.
11:56:24 <coCocoa> One of the misleading statements about FP, to me, is how it's said that "there's no state in FP", when there's tons of state - arguments!
11:56:30 <Gracenotes> Berengal: types? Like 1-byte registers, 2-byte registers... etc? :P
11:56:40 <Cale> Because there will be absolutely no net to catch you when you screw it up.
11:57:09 <Cale> Gracenotes: No, more like Haskell types -- it's just they've migrated from the program code into your head.
11:57:22 <burp> > 1+1
11:57:23 <lambdabot>   2
11:57:30 <Badger> :t 1+1
11:57:31 <lambdabot> forall t. (Num t) => t
11:57:36 <burp> ok, he reacts :>
11:57:43 <dons> "Types are Haskells (machine-checked) design language" -- SPJ, June 2009
11:57:48 <burp> erm, she
11:58:01 <Berengal> Cale: Okay, most of the time, you're thinking in types... however, every blue moon everything is a bitarray, and you're squaring strings and adding file-handles
11:58:02 <Badger> @vixen you're a woman?!
11:58:02 <lambdabot> of course i'm female
11:59:05 <Berengal> dons: I've been saying that for almost a year now...
11:59:20 <Cale> Berengal: Usually to the detriment of your code's correctness or maintainability ;)
11:59:51 <burp> hm, lambdabot doesn't react to ":t" in query?
11:59:59 <copumpkin> nope
12:00:01 <Cale> I'm pretty sure that people realised that quite a while back ;)
12:00:02 <copumpkin> only @type
12:00:05 <copumpkin> or ?type
12:00:11 <Cale> (about types being like a design language)
12:00:18 <Badger> not hackagebot!
12:00:19 <Berengal> Cale: I wouldn't know. I try to stay away from assembly. You actually have to run your program to get a proof of correctness...
12:00:29 <Badger> oh, phew.
12:00:39 <Gracenotes> only :t in public
12:00:45 <quicksilver> coCocoa: I agree that's a misleading statement.
12:00:50 <Gracenotes> lambdabot is too embarrassed to :t in private
12:01:06 <sm> Badger: just the routine restart 6-hourly restart
12:01:11 <quicksilver> coCocoa: no "global, mutable" state might be clearer
12:01:30 <Badger> sm: why's that needed?
12:01:42 <coCocoa> quicksilver: Right. I was going to say something on those lines, but it looked too wordy. :)
12:01:50 <sm> it stops echoing new items after a few hours, and I haven't figured out why yet
12:02:07 <sm> would love some more eyes on it
12:02:55 <sm> http://joyful.com/darcsweb/darcsweb.cgi?r=rss2irc;a=headblob;f=/Main.hs
12:11:09 <Woof> Hey, does lambdabot make her pm logs public?
12:12:45 <hape_> > (1,2,3,4)
12:12:46 <lambdabot>   (1,2,3,4)
12:12:54 <SamB> Woof: she *keeps* PM logs?
12:13:02 <hape_> >[1..]
12:13:02 <Woof> She doesn't?
12:13:04 <Woof> Okay : D
12:13:11 <Woof> > [1..]
12:13:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:13:23 <Woof> > sieve [2..]
12:13:24 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:13:26 <byorgey> Woof: I don't think so.  But all the same, I wouldn't go telling her top secret stuff in a pm...
12:13:39 <Woof> > primes 102
12:13:40 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]
12:13:41 <hape_> @type sieve
12:13:42 <lambdabot> forall a. (Integral a) => [a] -> [a]
12:13:47 <hape_> ah
12:13:51 <Woof> Okay, byorgey : (
12:14:27 <byorgey> Woof: if you want some really efficient primes, try the 'primes' package on Hackage =)
12:14:37 <byorgey> the sieve method is infamously inefficient
12:14:47 <Woof> Ah
12:14:58 <eu-prleu-peupeu> hello
12:15:10 <Woof> Salut, Monsieur Hugo
12:15:22 <eu-prleu-peupeu> hey Woof
12:15:24 <eu-prleu-peupeu> you haskle ?
12:15:42 <Woof> I do indeed Haskell a bit
12:15:46 <Woof> Un petit peu, you see
12:16:02 <eu-prleu-peupeu> marveilleuse
12:16:06 <Woof> Mais oui, je l'apprends
12:16:12 <eu-prleu-peupeu> moi aussi
12:16:22 <Woof> Moi plus que toi
12:16:29 * Woof wins
12:17:09 <eu-prleu-peupeu> you are from france ?
12:17:28 <Woof> Not even an atom of me
12:17:38 <eu-prleu-peupeu> canada ?
12:17:49 <Woof> Pas de tout!
12:17:59 <eu-prleu-peupeu> ivory coast ?
12:18:16 <Woof> Ah, where the skeletons of elephants lie
12:18:18 <Woof> No, never been to the place
12:18:27 <eu-prleu-peupeu> hmm...
12:18:28 <eu-prleu-peupeu> nigeria ?
12:18:31 <Woof> Nay, nor French Polynesia, if that is what you are about to ask
12:18:41 <Woof> Allow me
12:18:48 * Cale guesses india
12:18:53 <Woof> To rapidly bring your queries to a conclusion by telling you that I am from India
12:18:57 <eu-prleu-peupeu> thats english
12:18:58 <Cale> woo!
12:19:04 <Woof> As Cale has rightly guessed
12:19:09 <eu-prleu-peupeu> :D
12:19:19 * Cale cheated.
12:19:22 <eu-prleu-peupeu> big endian or little endian ?
12:19:23 <eu-prleu-peupeu> :D
12:19:24 * Woof bets
12:19:29 <Woof> What's that, eu-prleu-peupeu?
12:19:37 <eu-prleu-peupeu> oh, nothing
12:19:53 <Woof> I'm not very big, if that's what you mean. Nearly 6', but quite slim
12:20:54 <eu-prleu-peupeu> im going to renouce my nationality, i want to belong to planet haskel
12:21:11 <copumpkin> oh my, he's bac
12:21:22 <eu-prleu-peupeu> home of the free
12:21:31 <eu-prleu-peupeu> hmm, no... we use a garbage collector..
12:21:39 <eu-prleu-peupeu> eh
12:21:46 <eu-prleu-peupeu> bah
12:21:54 <bos> ok, whew
12:21:54 <Woof> What the hell was that
12:22:11 <bos> longstanding troll
12:22:56 <Woof> Might've keep the grass to myself if I'd known he was a troll in a goat's hide
12:24:39 <copumpkin> either he's a troll or he's just exceptionally unperceptive
12:24:44 <copumpkin> unperceptive being a euphemism
12:25:15 <copumpkin> whoops, the word is imperceptive :)
12:25:16 <Beelsebob> hehehe, you said tiny penis!
12:25:19 <Beelsebob> >.>
12:25:35 <copumpkin> lol
12:28:14 <tristes_tigres> hello
12:28:34 <Woof> What
12:28:36 <Woof> kept*
12:28:41 <Woof> No idea why I said keep
12:30:08 <tristes_tigres> If I import a module A, which in turn imports module B ... can I force it to import C instead without changing the module B ?
12:30:50 <Beelsebob> tristes_tigres: you want higher order modules!
12:30:59 <Beelsebob> unfortunately, haskell's module system is pretty horrible
12:31:13 * Beelsebob really wishes modules were just functions that returned sets of functions
12:31:28 <Beelsebob> (and constants)
12:31:44 <Cale> (and types?)
12:31:49 <tristes_tigres> Beelsebob: does ghc hve such an extension ?
12:32:03 <Beelsebob> not that I know of
12:32:08 <Beelsebob> Cale: indeed
12:32:14 <Beelsebob> and instances/classes obv
12:33:02 <tristes_tigres> class hierarchy in Haskell is not very developed, it seems
12:50:11 <zelnick> JJK
12:57:05 <Petrosian> kr1snaga
13:42:40 <birdspider> hi, how can I apply !! on a Maybe [] ? (i.e "Just [1,2,3] >>= liftM (flip (!! 2)" ... 2)  any ideas cause im stuck for almost 2 hours :/
13:43:06 <birdspider> which should actually give 3 not 2
13:44:57 <LeoD> what's wrong with Just [1,2,3] >>= (!! 2)?
13:46:05 <pikhq> > Just [1,2,3] >> = (!! 2)
13:46:06 <lambdabot>   <no location info>: parse error on input `='
13:46:13 <pikhq> > Just [1,2,3] >>= (!! 2)
13:46:14 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
13:46:14 <lambdabot>    arising from the lite...
13:46:33 <pikhq> I believe there's your answer. ;)
13:46:34 <enolan> > (!! 2) <$> Just [1..3]
13:46:35 <lambdabot>   Just 3
13:47:02 <enolan> I think that is what you want.
13:47:11 <LeoD> ah, missing a return
13:49:45 <birdspider> well .. yes :) but wth is this
13:50:39 <birdspider> hoogle states its a synonym for fmap, so is this the "Monadic" fmap ?
13:51:01 <FunctorSal> ? it really is just fmap
13:51:27 <enolan> That's the same as Just [1..3] >>= (return . (!! 2)
13:51:38 <FunctorSal> fmap (!! 2) (Just [1..3])
13:51:40 <FunctorSal> > fmap (!! 2) (Just [1..3])
13:51:41 <lambdabot>   Just 3
13:52:27 <ray> there are no monads involved here
13:53:28 <ray> <$> is an infix fmap to be used until someone's man enough to generalize . to all Functors
13:53:41 <FunctorSal> :)
13:53:42 <Twey> Heh
13:54:00 <idnar> @src (<$>)
13:54:00 <lambdabot> f <$> a = fmap f a
13:54:20 <FunctorSal> how is (.) similar to fmap?
13:54:21 <Twey> > Just 3 >>= (*5) . return
13:54:22 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
13:54:22 <lambdabot>    arising from the lite...
13:54:36 <Twey> Hmph
13:54:36 <FunctorSal> (.) is a special case of (<=<) if anything
13:54:43 <Twey> FunctorSal: (.) is fmap on functions
13:54:46 <FunctorSal> (ignoring identity monad wrapping)
13:54:49 <Twey> > f a
13:54:50 <lambdabot>   Add a type signature
13:54:55 <Twey> > f a :: Expression
13:54:56 <lambdabot>   Not in scope: type constructor or class `Expression'
13:55:01 <LeoD> > f a :: Expr
13:55:02 <lambdabot>   f a
13:55:04 <Twey> What happened to SimpleReflect?
13:55:04 <Twey> Oh
13:55:07 <Twey> Thanks
13:55:16 <Twey> > f `fmap` g $ a :: Expr
13:55:16 <lambdabot>   Add a type signature
13:55:22 <Twey> > f . g $ a :: Expr
13:55:23 <lambdabot>   Add a type signature
13:55:26 <Twey> Bah
13:55:36 <Twey> > (*2) . (+1) $ 3 :: Expr
13:55:36 <ray> see? they're both the same
13:55:36 <ehird> gwern: Lambdabot died a few days ago, or at least left #esoteric. Did it die or did it leave for some reason? Just curious
13:55:37 <lambdabot>   (3 + 1) * 2
13:55:43 <Twey> > (*2) `fmap` (+1) $ 3 :: Expr
13:55:44 <lambdabot>   (3 + 1) * 2
13:55:50 <LeoD> :)
14:23:24 <a_guest> is there some sleep function living in the IO monad, similar to usleep?
14:23:37 <mauke> threadDelay
14:23:54 <mauke> beware the limited range of Int
14:26:08 <a_guest> mauke: ok. I know nothing about threads/concurrency, but it might work for my purpose.
14:26:31 <mauke> it makes the current thread sleep
14:26:55 <mauke> if you don't spawn any threads with forkIO, it will effectively pause your program
14:29:57 <michie1> is there a haskell newbies channel?
14:30:07 <mauke> I thought this was the newbie channel :-)
14:30:29 <michie1> ah, that's pleasantly daunting, thanks
14:31:28 <mauke> why daunting?
14:32:06 <jeffwheeler> @users
14:32:06 <lambdabot> Maximum users seen in #haskell: 658, currently: 595 (90.4%), active: 10 (1.7%)
14:32:11 <michie1> most of the discussion in this channel flies straight over my head :)
14:32:14 <jeffwheeler> See, only 1.7% are actually active. :)
14:32:17 <mauke> that's normal
14:32:26 <jeffwheeler> Oh, I thought you were referring to the number of people . . .
14:32:38 <themroc-> is there any proper debugger for haskell?
14:33:06 <dankna> because of the nature of Haskell, a stop-and-step debugger wouldn't make sense.  or that's what I've concluded.
14:33:14 <themroc-> hmmmm
14:33:16 <mauke> ghci has something like that
14:33:22 <dankna> hmm
14:33:30 <themroc-> i get more and more confused
14:33:37 <themroc-> the bigger the prog gets
14:33:54 <dankna> use ghci; "debug" by testing your functions in isolation
14:33:54 <themroc-> but i guess its just bad layout :
14:34:22 <a_guest> which sort of tasks are typically using threads/concurrency in applications?
14:34:34 <themroc-> nah just function calls
14:34:44 <themroc-> i thought it would be nice to see states of vars
14:34:58 <tristes_tigres> themroc: Debug.Trace
14:34:59 <themroc-> i could print em out all the time, sure
14:35:05 <themroc-> hmm
14:35:07 <themroc-> never heard
14:35:10 <themroc-> lemme check :)
14:35:20 <FunctorSal> I agree lazyness makes step-by-step less straightforward but still there should be *some* way of tracing
14:35:28 <FunctorSal> other than littering "trace" everywhere
14:35:44 <mauke> a_guest: I/O with multiple channels; interactive GUI stuff sometimes uses multiple threads
14:35:49 <jeffwheeler> Can't GHCi set "breakpoints"-ish?
14:35:57 <FunctorSal> make each step say where it is currently working or so
14:36:10 <tristes_tigres> jeffwheeler: something like it yes
14:36:16 <FunctorSal> jeffwheeler: yes you can, but I find the debugging state you get into incomprehensible
14:36:30 <dankna> huzzah - it's not just me
14:36:53 <jeffwheeler> Hmm, I haven't used it, just seen it. I rarely find I have problems beyond typechecking. :P
14:37:07 <tristes_tigres> jeffwheeler: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
14:37:40 <themroc-> hmm nice thx for the link
14:38:21 <a_guest> mauke: but there is still a main thread where most of the programs behavior happen?
14:38:23 <FunctorSal> admittedly, I didn't rtfm ;)
14:39:12 <mauke> a_guest: depends
14:41:06 <hackagebot> network-protocol-xmpp 0.1 - Client <-> Server communication over XMPP (JohnMillikin)
14:41:15 <FunctorSal> maybe you could make a "debugger" by using haskell-src-exts to put a trace statement around every expression automatically ;)
14:42:05 <FunctorSal> the trace message would be a sort of "source code path" like "myFunction/case expression/2nd branch"
14:42:30 <a_guest> mauke: ok. thank you for answering these unprecise questions; I am just curious how applications usually are structured!
14:43:22 <mauke> I structure my applications with an IRON FIST and BRUTE FORCE!
14:44:04 <michie1> using the Police Force monad that quietly dispatches stray functions?
14:44:07 <michie1> eh
14:44:12 <tristes_tigres> mauke: The three weapons of the Spanish Inquisitiion are :
14:44:12 <michie1> Secret Police monad
14:44:20 * coCocoa wonders who gave the "mauke: yow" command...
14:44:29 <a_guest> I structure my programs with paper, pencil and eraser!
14:45:29 <dankna> philosophers structure their programs with just paper and pencil
14:45:53 <solrize> in republic of haskell, program structures YOU
14:46:47 <schizofrank> in haskell of republic, structures program you!
14:47:17 <tristes_tigres> @vixen19 How do you structure your programs ?
14:47:17 <lambdabot> a program? what do you mean a program??
14:49:01 <themroc-> omg
14:49:04 <themroc-> i feel so bad
14:49:15 <themroc-> this looks bad:
14:49:16 <themroc-> buildNewVectorList (tail oldList) ((replaceIfNeeded (head oldList) (getEdgeElement edgeList (e2First (head ( oldList)))) distanceInit):newList) edgeList distanceInit 	
14:49:29 <dankna> indent it some
14:49:47 <mauke> head/tail? needs more pattern matching
14:50:02 <mauke> (x) can be replaced by x
14:50:39 <tristes_tigres> @vixen19 need some head and tail
14:50:39 <lambdabot> f
14:50:44 <mauke> you don't need parens around the part before :
14:50:50 <mauke> put spaces around your operators
14:52:12 <Twey> let (h : t) = oldList in buildNewVectorList t ((replaceIfNeeded h . getEdgeElement edgeList $ e2First h) : newList) edgeList distanceInit
14:52:30 <FunctorSal> which has the added advantage of sharing the h
14:52:57 <themroc-> hmm Twey
14:53:13 <themroc-> right i can use $
14:58:50 <themroc-> hmm strange thing... if my app compiles proper but the function wont take the expected parameters with an error...
14:59:05 <themroc-> ERROR - Cannot infer instance
14:59:05 <themroc-> *** Instance   : Num Distance
14:59:05 <themroc-> *** Expression : buildNewVectorList [(2,1),(3,4),(4,34),(5,32)] [] [(1,2,4),(1,5,23)] (Finite 3)
14:59:11 <themroc-> i guess i mixed up types, right?
14:59:34 <mauke> what is Distance?
14:59:39 <themroc-> an own type
14:59:45 <mauke> (also, why are you using hugs and not ghc?)
14:59:57 <mauke> what's the definition of Distance?
15:00:08 <themroc-> >data Distance = Finite Int | Infinite
15:00:08 <themroc-> >
15:00:08 <themroc-> >instance Show Distance where
15:00:08 <themroc-> >  show = showDistance
15:00:08 <themroc-> >
15:00:09 <themroc-> >showDistance :: Distance -> String
15:00:09 <lambdabot>   <no location info>: parse error on input `='
15:00:11 <themroc-> >showDistance (Finite n) = show n
15:00:13 <themroc-> >showDistance Infinite = "+inf"
15:00:17 <themroc-> we are recommended to use hugs
15:01:22 <mauke> what's the type of buildNewVectorList?
15:01:50 <themroc-> w8
15:01:55 <themroc-> lemme post on pastebin
15:02:34 <themroc-> http://pastebin.com/m555b48b
15:02:42 <themroc-> its still heavy development and im a total beginner
15:02:51 <themroc-> so excuse my propably groundbreaking misstakes :p
15:03:13 <themroc-> buildNewVectorList [] [] [(1,2,4),(1,5,23)] (Finite 3) works fine btw
15:03:47 <schizofrank> themroc-: shouldn't you be in bed? ;))
15:04:01 <themroc-> i should be in a club :p
15:04:06 <mauke> ah, there's your problem
15:04:17 <mauke> buildNewVectorList [(2,1),(3,4),(4,34),(5,32)]
15:04:39 <themroc-> do i have to add Finite to all distance parameters?
15:04:44 <mauke> according to the type of buildNewVectorList, [(2,1),(3,4),(4,34),(5,32)] :: Dvector
15:05:06 <mauke> Dvector = [(Node, Distance)]
15:05:14 <mauke> so it tries to check 1 :: Distance, which fails
15:05:20 <mauke> yes, that's one way to solve it
15:05:24 <themroc-> ic
15:05:30 <mauke> (the other would be to make Distance an instance of Num)
15:05:48 <mauke> (which is what hugs was looking for and couldn't find, thus the error)
15:05:54 <themroc-> ok
15:05:55 <schizofrank> themroc-: so you're in a dance club and you're coding haskell?
15:06:04 <themroc-> no im supposed to be out :p
15:06:09 <themroc-> friday night
15:06:32 <schizofrank> oh, i read a "n't" where there was none
15:06:34 <themroc-> i rather decided to work on this great peace to prepare my exams in 2 weeks
15:06:50 <themroc-> *piece
15:06:51 <themroc-> haha :p
15:07:34 <themroc-> mauke, so even if the show instance gives me a plain number, the other way around isnt possible?
15:07:49 <themroc-> even if i specified the parameter as type Distance
15:08:14 <mauke> huh? show gives you a String, not a number
15:08:16 <schizofrank> i saw on tv that in a sports event males who had sex prior to the event (a tennis match i believe) performed better, so maybe that works with your exam as well
15:09:14 <themroc-> yeag mauke
15:09:34 <themroc-> anyway, with Finite it works, and its debugging only anyway
15:09:39 <themroc-> so should be fine :p
15:09:59 <tristes_tigres> schizofrank: programmers don't have sex
15:10:41 <themroc-> heh!
15:10:42 <schizofrank> are you saying that the two dreams of my future cannot coexist?
15:10:57 <themroc-> having sex AND having an exam?
15:11:04 <schizofrank> no, having sex and being a programmer
15:12:31 <themroc-> mauke thx again, now it works like a charm :p
15:12:32 <tristes_tigres> schizofrank: maybe it doesn't apply to Haskell programmers
15:13:12 <schizofrank> that may be true. in that case, i suppose i made the right decision to become one of those
15:13:20 <Heffalump>   
15:14:04 <Heffalump> sorry
15:14:46 <fynn> programmers are logical people, and sex isn't logical.
15:14:52 <schizofrank> as a probably more experienced person, do you (meaning practically everyone on this channel) think making a clone of one of these games where you have a cannon that you can steer up and down and vary the amount of force to launch the cannonball with, in order to compensate for the wind and destroy the other players cannon? (this sentence totally fell apart, but i'm tired and i suppose you'll still understand it)
15:14:57 <fynn> so we will have none of it.
15:15:11 <schizofrank> fynn: the daily wtf will show you, that there are programmers that don't care for logic :)
15:15:43 <inimino> schizofrank: I think it was missing something like "...is a good idea?"
15:15:51 <fynn> schizofrank: these are not programmers, but random people who can't even successfully masquerade as such.
15:16:02 <marcot> Hello, how do I produce a static binary of a program packaged with Cabal?
15:16:02 <Zao> schizofrank: http://en.wikipedia.org/wiki/Scorched_Earth_(computer_game)
15:16:27 <schizofrank> yeah, a bit like that. only i was thinking of the one that came with windows 3.11 (i believe)
15:16:31 <schizofrank> which was much simpler
15:16:32 <marcot> I've tried ghc-options: -static and ld-options: -static.
15:16:42 <inimino> fynn: successfully enough to get paid, apparently
15:17:06 <schizofrank> incidentally, scorched 3d is pretty awesome
15:18:13 <Zao> schizofrank: http://en.wikipedia.org/wiki/Tank_Wars <- I have fond memories of that :)
15:19:20 <jix> hi, i'd like to get an unboxed array of pairs of Word32s .. is that possible?
15:25:05 <mauke> I don't know, but you can always do it C style
15:25:15 <mauke> (use an array of 2*N Word32s)
15:25:59 <jix> but that would render the code almost unreadable
15:27:19 <mauke> I doubt that
15:27:36 <dcoutts> marcot: I'd try --ghc-options=-optl-static
15:28:15 <marcot> dcoutts: I tried that, and got some linking errors... But anyway, I could solve the problem I had.  Thanks for answering.
15:28:53 <dcoutts> marcot: is that because it was missing static libs for some C libs?
15:29:06 <dcoutts> marcot: generating fully static libs isn't always possible iirc
15:29:51 <marcot> dcoutts: I'm not sure.  I'm on debian, and I checked that the -dev packages were installed, so the static libs should be there.
15:30:14 <dcoutts> marcot: do you have a log of the output?
15:30:32 <jeffersonheard> I'm a bit surprised...  is it correct that there are no data constructors for NaN and Infinity in the prelude?
15:31:05 <mauke> jeffersonheard: yes
15:31:55 <jeffersonheard> so how do they get returned and stored as values?  because it seems to be perfectly doable to assign log (-1) to the variable nan and always get NaN
15:32:08 <dcoutts> jeffersonheard: besides, you don't really mean data constructors, Float and Double don't have (exported) constructors
15:32:35 <dcoutts> jeffersonheard: "NaN" is just the output of show, it's not a data constructor
15:32:41 <jeffersonheard> ah
15:33:19 <jeffersonheard> can be input to "read" as well, apparently
15:33:26 <jeffersonheard> just can't directly use it as a value
15:33:39 <dcoutts> the Prelude has isNaN, isInfinite :: RealFloat a => a -> Bool
15:34:22 <jeffersonheard> dcoutts: I'm aware of the predicates, but I was curious if I could store NaN or Infinity in unboxed float arrays to be seen by a C library
15:34:44 <dcoutts> jeffersonheard: you certainly can
15:36:31 <jeffersonheard> excellent.  then I'll just write an unexported nan = log (-1) and use it.  thanks
15:36:53 <mauke> > 0/0
15:36:54 <lambdabot>   NaN
15:37:09 <Heffalump> > 0/0 == 0/0
15:37:10 <lambdabot>   False
15:37:19 <Heffalump> NaNs are silly.
15:37:33 <jeffersonheard> Heffalump, I agree.  It wasn't my design decision, tho :P
15:43:01 <themroc-> hmmmm
15:44:24 <coCocoa> jif: Why can't you use a UArray of Word64s, and a splitter function? :)
15:44:42 <themroc-> i wonder: i have a function i have to call unknown times... now im not supposed to use recursion but to use lazy evaluation
15:44:52 <themroc-> i have no clue how to accomplish this
15:45:24 <Berengal> iterate
15:45:27 <Berengal> @type iterate
15:45:28 <lambdabot> forall a. (a -> a) -> a -> [a]
15:45:38 <Berengal> For example...
15:46:21 <Berengal> However, I don't understand the requirement completely myself..
15:46:44 <themroc-> [initialstate, step initialstate, step2 initialstate , step3 initialstate, step4 initialstate , ...]
15:46:51 <themroc-> the list should look like that
15:47:01 <coCocoa> themroc: Right, like a hand-crafted replicateFunc? :)
15:47:01 <tristes_tigres> is there an explanation of mfix more concise than the doctoral dissertaion of that guy ?
15:47:08 <Berengal> Then iterate is what you want
15:47:15 <themroc-> ic
15:47:17 <coCocoa> themroc: That's iterate. :)
15:47:18 <Berengal> > iterate (+1) 0
15:47:19 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:47:23 <coCocoa> @typr iterate
15:47:24 <lambdabot> forall a. (a -> a) -> a -> [a]
15:47:28 <coCocoa> @type iterate
15:47:29 <lambdabot> forall a. (a -> a) -> a -> [a]
15:47:31 <Berengal> However, iterate is a recursive function...
15:47:34 <Berengal> @src iterate
15:47:34 <lambdabot> iterate f x =  x : iterate f (f x)
15:47:41 <tristes_tigres> @src iterate
15:47:41 <lambdabot> iterate f x =  x : iterate f (f x)
15:48:09 <themroc-> ok
15:48:13 * tristes_tigres thinks GHCi ought to have @src macro
15:48:16 <jix> coCocoa: i could use it but i have the feeling that might cause the compiler to have no idea what i'm really doing
15:48:36 <jix> and it isn't as nice
15:48:36 <themroc-> so the output of the function should be the new input of the next call
15:48:37 <tristes_tigres> out of the box
15:48:45 <themroc-> its working with this, right?
15:48:52 <jix> but i think uvector on hackage might support what i want
15:49:00 <coCocoa> jix: I kind of get the feeling that when you say "compiler," you're really talking about a person... ;)
15:49:43 <Berengal> themroc-: Yup, that's what src says
15:49:45 <jix> coCocoa: no... but it might end up reading it into a 64 bit register and doing shift operations on it
15:49:46 <Toxaris> themroc-: yes, but note that the first element of the result of iterate is the input unchanged
15:50:10 <Toxaris> > iterate f x
15:50:10 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
15:50:32 <coCocoa> jix: It's just that, AFAIU, a piar is itself a box, so "an unboxed array of pairs" sounds non-sensical to me. Just like "an unboxed array of Integers" does. :)
15:50:38 <Berengal> > scanl (+) 1 (repeat 1)
15:50:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:50:44 <coCocoa> Er, *pair
15:51:09 <Twey> Isn't there a scanl1?
15:51:18 <jix> coCocoa: Word32 is boxed too
15:51:18 <Twey> > scanl1 (+) $ repeat 1
15:51:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:51:24 <Twey> Yeah, there we go
15:51:33 <jix> coCocoa: still an uarray of it would use an unboxed internal representation
15:51:38 <jix> coCocoa: the same could be done for pairs
15:51:41 <Toxaris> > [1..] -- easier
15:51:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:51:48 <jix> coCocoa: and as i said there is a lib on hackage that just supports that
15:51:54 <coCocoa> themroc: I think what you want, is to copy the way that iterate is written, but where it has ":", you should use a "." instead. :)
15:52:15 <Berengal> Can you get iterate from scanl?
15:52:20 <themroc-> ehm
15:52:24 <Twey> Hm
15:52:27 <themroc-> : and . ?
15:52:57 <Toxaris> coCocoa: why? themroc- wants a list as output, I understand
15:53:06 <Twey> > iterate (+ 1) 0
15:53:07 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:53:15 <coCocoa> themroc-: Hmm, then again, when you say "no recursion," I'm totally lost. So, never mind. :\
15:53:15 <Twey> > scanl1 (const (+ 1)) 0
15:53:16 <lambdabot>   No instance for (GHC.Num.Num [a])
15:53:16 <lambdabot>    arising from the literal `0' at <inter...
15:53:32 <themroc-> yeah im lost too haha
15:53:43 <themroc-> but lemme play around a bit
15:53:51 <Berengal> > let iterate f x = scanl1 (($x) . foldl (.) id . flip replicate f) [0..] in iterate (+1) 0
15:53:52 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Int))
15:53:52 <lambdabot>    arising f...
15:53:55 <Berengal> :/
15:54:08 <themroc-> dijkstra ownz
15:54:09 <themroc-> ftw!
15:55:49 <Berengal> > let iterate f x = scanl1 (const ( ($x) . foldl (.) id . flip replicate f)) [0..] in iterate (+1) 0
15:55:53 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:56:04 <coCocoa> jix: So, you want... "UArray jixsIxType (# Word32# Word32# #)", basically. :)
15:57:24 <Toxaris> > let iterate f x = scanl (flip id) x (repeat f) in iterate f x
15:57:25 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
15:58:51 <themroc-> hmmm
15:59:03 <jix> coCocoa: yeah
15:59:07 <themroc-> how do i handle parameters?
15:59:12 <themroc-> my header looks like that:
15:59:13 <themroc-> >step :: (Node, Dvector, [Node], [Node]) -> (Node, Dvector, [Node], [Node])
15:59:41 <themroc-> (iterate step start d u v) wont work :p
16:00:05 <Berengal> themroc-: Your function only takes one parameter (a four-tuple)
16:00:07 <mauke> yeah, because step takes/returns a tuple
16:00:19 <Berengal> Also, iterate only works with one argument...
16:00:19 <Toxaris> themroc-: you need tuple syntax, because your step takes a tuple as input: iterate step (start, d, u, v)
16:01:10 <themroc-> ah ic
16:01:32 <Vanadium> @src sequence
16:01:32 <lambdabot> sequence []     = return []
16:01:32 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:01:32 <lambdabot> --OR
16:01:32 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:05:47 <Toxaris> @type let curried = (curry .) . (. uncurry) in curried iterate
16:05:48 <lambdabot> forall a b. (a -> b -> (a, b)) -> a -> b -> [(a, b)]
16:06:06 <Toxaris> @type let curried = (curry .) . (. uncurry) in curried (curried iterate)
16:06:07 <lambdabot> forall a b b1. (a -> b -> b1 -> ((a, b), b1)) -> a -> b -> b1 -> [((a, b), b1)]
16:09:09 <coCocoa> jix: I think it may work better to take a feather from DPH, and just use a pair of unboxed arrays instead. :)
16:09:26 <coCocoa> Drat, I Hate it when that happens. :\
16:12:56 <Vanadium> Monad transformers seem silly. Why can there not be a single more generic transformer instead of having MaybeT, ListT, StateT, ...?
16:23:01 <uzytkownik> @undo do { (v, l') <- runPureInputT m l; runPureInputT (f v) l' }
16:23:01 <lambdabot> runPureInputT m l >>= \ (v, l') -> runPureInputT (f v) l'
16:23:25 <uzytkownik> @pl  \(v, l') -> runPureInputT (f v) l'
16:23:25 <lambdabot> uncurry (runPureInputT . f)
16:39:25 <purplepenguins> where is a good place to get started with ghc extensions?
16:49:41 <hackagebot> mps 2009.7.4 - OO duck syntax (JinjingWang)
16:58:18 <EvilTerran> Vanadium, there is, it's called ContT :P
16:58:39 <Vanadium> I remain suspicious
16:59:29 <EvilTerran> Vanadium, the fundamental problem is that the class of monads is not closed under composition
17:00:14 <Vanadium> Could we not come up with a more specialised class that fixes this
17:00:15 <EvilTerran> ie, if m and n are both monads, then (m `O` n) still may not be a monad
17:00:42 <EvilTerran> (where (m `O` n) a ~= m (n a))
17:00:51 <EvilTerran> Vanadium, well, Applicatives are composable, iirc
17:01:05 <EvilTerran> Functors definitely are
17:01:28 <pikhq> In theory, the Applicatives are a subset of the Functors.
17:01:35 <pikhq> And the Monads are a subset of the Applicatives.
17:01:41 <pikhq> Of course, in practice, that is bullshit. :P
17:02:04 <EvilTerran> pikhq, the problem is the additional restrictions on both Applicative and Monad that are not preserved by all Functors
17:02:33 <pikhq> EvilTerran: True.
17:05:20 <EvilTerran> a subset of a set closed under an operation need not be closed under the same operation
17:14:02 <jmcarthur> yes, Applicatives can in general compose
17:14:21 <jmcarthur> Monads not only may or may not compose, but may even compose in more than one way!
17:15:20 <jmcarthur> not sure if the same applies generally to Applicative (more than one possible way of composing)
17:15:30 <jmcarthur> afaik there is usually only one way
17:15:47 <Heffalump> if monads can compose in multiple ways, then since all monads are applicatives..
17:15:52 <Vanadium> Surely you could build a system that lets you specify the way of composure :|
17:16:40 <jmcarthur> Heffalump: but it could be that all the different ways to compose monads could result in the same `ap`
17:16:46 <jmcarthur> i am unsure, though
17:17:36 <jmcarthur> Vanadium: yes, see TypeCompose and category-extras (both are incomplete in monad composition so far, though)
17:17:48 <jmcarthur> in fact... i think neither of them have monad composition right now
17:17:59 <Vanadium> All right
17:18:12 <mmorrow> what's the definition of "composition" here?
17:18:14 <jmcarthur> category-extras should after a while, according to the comments, but i don't know if conal will ever get around to it in TypeCompose
17:18:28 <Vanadium> I am only trying to figure out how to use monad transformers right now, it just felt utterly backwards and lacking in generality :|
17:18:47 <mmorrow> Vanadium: monad tranformers aren't commutative
17:19:13 <mmorrow> @unmtl StateT s (ContT o (Writer w)) a
17:19:13 <lambdabot> s -> (a -> s -> (o, w)) -> (o, w)
17:19:14 <jmcarthur> mmorrow: i think TypeCompose defines it something like: newtype (f :. g) a = O (f (g a))
17:19:32 <mmorrow> @unmtl ContT o (WriterT w (State s)) a
17:19:32 <lambdabot> (a -> s -> (o, w, s)) -> s -> (o, w, s)
17:19:52 <mmorrow> @unmtl ContT o (Reader r) a
17:19:52 <lambdabot> (a -> r -> o) -> r -> o
17:20:00 <mmorrow> @unmtl StateT s (ContT o) a
17:20:01 <lambdabot> err: `ContT o (a, s)' is not applied to enough arguments.
17:20:04 <mmorrow> @unmtl StateT s (Cont o) a
17:20:04 <lambdabot> s -> (a -> s -> o) -> o
17:20:07 <mmorrow> @unmtl ContT o (Reader r) a
17:20:07 <lambdabot> (a -> r -> o) -> r -> o
17:20:53 <mmorrow> the result of applying monad transformers (from the mtl) is definitely non-trivial
17:22:11 <mmorrow> s/applying/composing/
17:22:43 <mmorrow> ("composing" here as defined by how monad transformers work)
17:30:15 <Berengal> There are surprisingly few resources for how to start doing web development in haskell...
17:32:11 <mmorrow> Berengal: what sort of things are you looking to do?
17:32:31 <Berengal> mmorrow: hsp, mainly
17:32:56 <mmorrow> ah, hsp is pretty undocumented yes
17:33:05 <FunctorSalad_> there's loli ;)
17:33:17 <mmorrow> i've never used hsp either, so i'm not sure where you'd start
17:33:20 <Berengal> I've just read the paper, which was pretty interesting, but it doesn't say anything about how to go about compiling and serving the bastards...
17:34:31 <Berengal> There is hsp-cgi, which looks promising, except I don't know anything about cgi and haskell either...
17:34:39 <mmorrow> Berengal: i think the lack of any information on them may be an indication of how much they're used
17:35:53 <Berengal> Yeah, I've kind of gotten that impression myself. Still, I like hsp the best of all server-side languages I've seen so far, simply because it's not just a fancy string library
17:38:05 <mmorrow> main = runCGI (output . renderHtml $ [header << thetitle << toHtml "oh hai", body << toHtml "oh hai"])
17:38:16 <mmorrow> is a minal complete cgi prog
17:38:19 <mmorrow> *minimal
17:38:28 <mmorrow> (well, not really "minimal" i guess)
17:38:38 <mmorrow> main = runCGI (output "zomg")
17:38:49 <mmorrow> import Network.CGI import Text.XHtml
17:38:55 <Heffalump>    
17:39:33 <Berengal> I assume I'll want some kind of server to serve these as well
17:39:43 <Berengal> Which means figuring out apache, probably...
17:39:50 <mmorrow> apache, lighttpd
17:40:00 <Berengal> Yeah...
17:40:20 <mmorrow> building + configuring apache is like a 5-10 minute task :)
17:40:33 <mmorrow> (once you already know how to do it, of course)
17:40:47 <Berengal> I've feel like I've been banging my head against lacking documentation for long enough already though, but I guess it's about time to learn what apache is all about...
17:41:07 <mmorrow> ./configure --help | less
17:41:12 <mmorrow> is informative
17:41:22 <mmorrow> the just read through the default httpd.conf
17:41:42 <mmorrow> and make the obvious changes you come across
17:42:17 <mmorrow> (./configure .. if you want to build it yourself that is, which probably would be worth it if you want to get to know it)
17:42:25 <Berengal> Yeah, I'll probably figure it out with a few more hours of headbashing...
17:42:36 <mmorrow> heh, good luck
17:43:20 <Berengal> But it feels like it's all I've done today, fighting every java API between java.lang and GlassFish at work :/
17:44:13 <Berengal> And then trying to figure out hsp... oh well, it'll be great once everything fits together
17:44:54 <mmorrow> hpaste2 uses fastcgi, which has the exact same interface as cgi
17:45:05 <mmorrow> module the "run*" functions
17:45:08 <mmorrow> *modulo
17:46:00 <mmorrow> http://code.haskell.org/hpaste.git
17:47:32 <mmorrow> Berengal: i've never actually seen a real living working hsp program to be honest, so i'm not sure i'd recommend pursuing that (not to say one has never existed of course ;)
17:49:11 <mmorrow> fastcgi + your wedserver of choice however..
17:49:14 <mmorrow> @paste
17:49:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:49:39 <mmorrow> also, there's happs(erver)
17:50:03 <mmorrow> and (fast)cgi or happs(erver) are used quite a bit
17:50:26 <Berengal> Yeah, I've thought about happs...
17:51:04 <Berengal> And yes, I haven't seen a proper hsp program myself, but someone has to be the first :P
17:51:55 <Berengal> The underlying idea seems the best of what I've seen so far
17:53:09 <Woof> Haskell is compiled from .hs-files which means HOMO SEXUAL - Oscar Wilde on Haskell -_-
17:53:12 <Woof> http://uncyclopedia.wikia.com/wiki/Haskell
18:06:38 <ehird> Woof: I'm not sure Oscar Wilde ever said that.
18:07:54 <Woof> ehird: I'm sure he didn't! It's Uncyclopedia
18:08:01 <ehird> Whooooooooooooooooooooooooooooooooooooooooosh!
18:09:43 <inimino> heh
18:25:00 <coCocoa> "Owing to the monolithic nature of Haskell programs, and the undecidability of their output, even very simple programs can run to many thousands of lines of curry sauce code. " -- Mmm...Saucy! ;p
18:25:46 <idnar> haha
18:27:49 <inimino> mmm, curry
18:38:29 <gwern> yeah, that's uncyc for you
18:38:41 <gwern> I think the Objectivist C article is probably the best one, though
18:39:31 <gwern> most uncyc articles are just an accumulation of sub-par uncyc memes and negations; apparently they think it's funny to just make a list of characteristics and negate them
18:40:29 <bremner> I'm pretty sure Wilde meant it as a compliment
18:40:55 <Woof> Hehe
18:41:37 <gwern> wilde didn't compliment your mom last night
18:42:13 <inimino> he said nice things about your dad, though
18:42:24 <pikhq> Some of them are pretty funny, though.
18:42:35 <Woof> > ln 5
18:42:37 <lambdabot>   1.6094379124341003
18:42:40 <gwern> some of them, but blessed few
18:43:05 <Woof> > log 5
18:43:06 <lambdabot>   1.6094379124341003
18:44:02 <pikhq> Quite a bit of it is "Lawl, random noise is funny!"
18:44:14 <pikhq> It's like 4chan only less sane.
18:44:21 <pikhq> (if that's possible)
18:48:07 <mmorrow> http://uncyclopedia.wikia.com/wiki/Brainfuck
18:48:21 <mmorrow> , [$bf|<<+++++++++++++++.>.|] ""
18:48:25 <lunabot>  "\SI\NUL"
18:48:46 <mmorrow> hmm, i wonder if these bf progs are just random banging on the keybd
18:49:00 <mmorrow> , [$bf|,>,>++++++++[<------<------>>-]<<[>[>+>+<<-]>>[<<+>>-]<<<-]|] ""
18:49:02 <lunabot>  "*** Exception: bf blocked on input"
18:49:05 <mmorrow> , [$bf|,>,>++++++++[<------<------>>-]<<[>[>+>+<<-]>>[<<+>>-]<<<-]|] "asdf"
18:49:07 <lunabot>  ""
18:49:08 <Axman6> i should try writing a bf interpreter some time
18:49:36 <mmorrow> the QQ that lunabot uses is included in the haskell-src-meta pkg on hackage
18:49:38 <gwern> Axman6: no need, there's already one on hackage
18:49:54 <Axman6> that's not the point
18:49:57 <mmorrow> http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.4/doc/html/src/Language-Haskell-Meta-QQ-BF.html
18:49:57 <Axman6> :\
18:50:03 <ehird> gwern: writing a bf interp takes 3 seconds
18:50:05 <ehird> it's fun, though
18:50:11 <gwern> ehird: oh yeah?
18:50:12 <gwern> go!
18:50:15 <ehird> no.
18:50:21 <mmorrow> Axman6: (in case you want to look at one person's version of it)
18:50:39 <roconnor> @bf
18:50:39 <lambdabot>  Done.
18:50:40 <Axman6> i'd rather start from a clean mental slate :)
18:51:08 <mmorrow> Saizan made one that uses Monad.Prompt explicitly (whereas lunabot's uses the idea, not the package) and additionally uses mtl to the maximum extent possible, and then some
18:51:12 <gwern> @bf ++++++++++[>+++++++>++++++++++++>++++++++++>+++++++++++>+++<<<<<-] >-.>.----.--.>+.>-.<.>>++.<+++.++.---.<++.>+++.<------.>-----..----.+++++.<++++++.
18:51:12 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
18:51:38 <ehird> @bf is broken.
18:51:38 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
18:51:46 <mmorrow> Saizan's http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=839
18:51:55 <gwern> indeed. last I checked, it was because the bf binary wasn't there
18:51:56 <mmorrow> , [$bf|.+[.+]|] ""
18:51:57 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
18:52:02 <pikhq> @bf ++++++++++.
18:52:02 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
18:52:16 <mmorrow> , [$bf|,+.|] "a"
18:52:17 <ehird> mmorrow: that's a truly awful implementation of something that takes ~10 lines
18:52:18 <lunabot>  "b"
18:52:18 <pikhq> Yup. Borken.
18:52:27 <mmorrow> ehird: which one?
18:52:34 <ehird> the saizan one
18:52:41 <ehird> overengineering at its finest
18:52:55 <mmorrow> ehird: (it's all about style, since it does in fact implement something trivial ;)
18:53:02 <ehird> well exactly
18:53:04 <mmorrow> heh, exactly
18:53:15 <ehird> mmorrow: actually you can implement brainfuck very non-trivially
18:53:20 <mmorrow> here's mine http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=772
18:53:25 <mmorrow> well, exactly!
18:53:27 <ehird> as a compiler
18:53:32 <ehird> mmorrow: no, i mean legitimately
18:53:47 <ehird> reducing loops with balanced < and > to polynomials, inferring values of cells, constant folding
18:53:52 <ehird> propagating and moving move operations
18:54:04 <ehird> http://code.google.com/p/esotope-bfc/ can compile the standard hello world program to: PUTS("Hello World!");
18:54:08 <mmorrow> here's rwbarton's bf compiler that produces an elf .o http://moonpatio.com/repos/brain/
18:54:11 <ehird> interesting stuff, if useless
18:54:29 <pikhq> ehird: Not useless if you can write a Brainfuck specialiser in Brainfuck.
18:54:37 <pikhq> :P
18:54:39 <ehird> pikhq: no... it's still useless then :P
18:54:50 <pikhq> But it's the projections of Futamura!
18:55:14 <mmorrow> this asm bf compiler modifies its own code into that of the program it's compiling http://www.muppetlabs.com/~breadbox/software/tiny/bf.asm.txt
18:55:43 <rocketman> mmorrow: very clever
18:55:43 <ehird> mmorrow: ah, brian raiter. also behind the smallest elf file that linux will run.
18:55:50 <mmorrow> ehird: heh, exactly
18:55:59 <ehird> also he wrote a game in intercal
18:56:02 <mmorrow> rocketman: yeah, i particularly like that one too
18:56:03 <ehird> then made it into an intercal CGI.
18:56:18 <pikhq> Brian Raiter is great.
18:56:49 <gwern> hm. potential paper titles - 'The Island of Dr. Futamura'. 'The Sinister Projections of Futamura', 'The Yellow Projection', 'Tin-Tin and the Third Projection'
18:57:09 <mmorrow> (if anyone is interested in learning about elf, these are nice too http://www.muppetlabs.com/~breadbox/software/elfkickers.html)
18:57:38 <ehird> gwern: 'Futamura in the Year 3000'
18:57:57 <gwern> Futamura's Good News
18:58:03 <ehird> ARGH!
18:58:20 <gwern> :)
19:02:07 * wli went in for ELF standard docs. They're actually relatively readable.
19:04:47 <mmorrow> wli: yeah, the spec is decent
19:05:15 <wli> "The" spec? I've mostly seen them done up per-arch.
19:05:31 <mmorrow> wli: well yeah, i mean the i386 one
19:05:54 <mmorrow> (i've found all the other "specs" to just be chapters in particular arch's abi spec)
19:06:30 * wli saw the i386 done similarly.
19:06:36 <mmorrow> whereas the "Elf Specification" i've seen only details 32bit elf, with relocations specific to x86
19:06:51 <mmorrow> yeah
19:07:00 <mmorrow> wli: oh, you mean in the abi?
19:07:36 <wli> SVR4/i386 ABI specification
19:07:40 <mmorrow> www.skyfree.org/linux/references/ELF_Format.pdf
19:08:03 <mmorrow> (that was just the first link from google, dunno if there's an "official location" this pdf resides at)
19:11:34 <wli> mmorrow: I read some dead tree thing.
19:11:47 <mmorrow> wli: goo
19:12:06 * mmorrow prints pdf's out that he actually needs to grok if that counts
19:15:58 <wli> mmorrow: It was a 15-year-old book with thoroughly-yellowed pages.
19:16:57 <mmorrow> wli: ouch
19:18:30 <wli> The idea being that I didn't kill trees anew for the sake of it. I rather saved the book from ending up in a landfill.
19:18:56 <mmorrow> ahh
19:18:58 * mmorrow is guilty as charged
19:20:12 <Cromulent> hi folks - sorry if this is a stupid question - but does anyone know if there is a C interface for GHCi to allow you to embed Haskell programs in a C application and then run them through the Haskell interpreter rather than compiling them?
19:20:31 <Cromulent> is much the same way as it is possible with Python or Ruby
19:20:57 <lpsmith> Cromulent:   there is an FFI that you can use to call C from Haskell and vice-versa
19:20:59 <Saizan> you can call compiled haskell from C via the FFI
19:21:04 <lpsmith> And there is the GHC API
19:21:19 <Saizan> so i guess you can call the ghc api via the FFI
19:21:27 <Cromulent> ah brilliant thanks - I'll do some googling :)
19:22:24 <lpsmith> :t mapCont
19:22:25 <lambdabot> forall r a. (r -> r) -> Cont r a -> Cont r a
19:22:38 <lpsmith> that type is a bit more complicated than strictly necessary
19:23:14 <lpsmith> because   (mapCont f m) >> n  == mapCont f (m >> n)
19:23:35 <lpsmith> so you can always just mapCont f (return ())
19:24:13 <lpsmith> (just thinking out loud,  not really in response to anything at all)
19:25:14 <Saizan> i guess it's the principal type
19:25:58 <lpsmith> :t  \f -> mapCont f (return ())
19:26:00 <lambdabot> forall r. (r -> r) -> Cont r ()
19:27:00 <Saizan> ah, now i see what you mean :)
19:27:12 <lpsmith> :)
19:36:26 <Axman6> @src Cont
19:36:26 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
19:36:55 <Axman6> @src Monad Cont
19:36:55 <lambdabot> Source not found. :(
19:36:58 <Axman6> :(
19:38:13 <lpsmith> hmm
19:38:26 <lpsmith> wonder if there is a way to do that...
19:38:45 <Saizan> @src Cont Monad
19:38:45 <lambdabot> Source not found. Wrong!  You cheating scum!
19:38:46 <lpsmith> the instance definitions for Cont are not easy to grasp, in my opinion.   It took me a few years
19:39:37 <Axman6> @src Cont return
19:39:38 <lambdabot> return a = Cont ($ a)
19:39:57 <Axman6> @src Cont (>>=)
19:39:57 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
19:40:47 <Saizan> they are easier without all the newtyping
19:41:42 <Saizan> ?djinn (Not (Not a)) -> (a -> (Not (Not b))) -> Not (Not b)
19:41:42 <lambdabot> f a b c = void (a (\ d -> void (b d c)))
19:42:01 <Saizan> you can remove the voids :P
20:12:18 <mmorrow> djinn-add Cont o a = (a -> o) -> o
20:12:21 <mmorrow> @djinn-add Cont o a = (a -> o) -> o
20:12:21 <lambdabot> Cannot parse command
20:12:27 <mmorrow> @djinn-add type Cont o a = (a -> o) -> o
20:12:47 <mmorrow> @djinn ((a -> Cont o b) -> Cont o a) -> Cont o a
20:12:47 <lambdabot> f a b = a (\ c _ -> b c) b
20:12:56 <mmorrow> callcc
20:13:43 <mmorrow> @djinn-add data Cont_ o a = Cont_ ((a -> o) -> o)
20:13:43 <lambdabot> Cannot parse command
20:14:17 <mmorrow> iirc djinn gets shift and reset right too
20:15:31 <mmorrow> @djinn ((a -> Cont x o) -> Cont o o) -> Cont o a
20:15:31 <lambdabot> f a b = a (\ c d -> d (b c)) (\ e -> e)
20:15:50 <mmorrow> @djinn Cont a a -> Cont o a
20:15:50 <lambdabot> f a b = b (a (\ c -> c))
20:16:11 <mmorrow> @. pl djinn ((a -> Cont x o) -> Cont o o) -> Cont o a
20:16:11 <lambdabot> f = flip flip id . (. (flip id .))
20:16:18 <mmorrow> @. pl djinn Cont a a -> Cont o a
20:16:18 <lambdabot> f = flip id . ($ id)
20:16:29 <mmorrow> @. pl djinn ((a -> Cont o b) -> Cont o a) -> Cont o a
20:16:29 <lambdabot> f = join . (. (const .))
20:18:28 <Lemonator> I just got another crazy idea.
20:18:43 <mmorrow> @djinn Cont o a -> (a -> Cont o b) -> Cont o b
20:18:43 <lambdabot> f a b c = a (\ d -> b d c)
20:18:54 <Lemonator> say we have dependent types and records with subtyping.
20:18:58 <mmorrow> (>>=) for Cont
20:19:17 <Lemonator> let typeof = \(x :: T) -> T
20:19:37 <mmorrow> ok
20:20:41 <mmorrow> @djinn a -> Cont o a
20:20:41 <lambdabot> f a b = b a
20:21:05 <mmorrow> et voila, djinn does return,(>>=),callCC,shift,reset for Cont
20:21:36 <mmorrow> (without the newtype noise that is)
20:21:53 <Lemonator> then, a function (f :: (x :: {a :: A}) => typeof x) won't need row variables at all.
20:22:10 <Lemonator> hm.
20:22:20 <Lemonator> Maybe I should have taken this to #ML.
20:22:38 <mmorrow> i think here is a perfectly acceptable place
20:22:51 <mmorrow> (but i don't have anything to add, although i'm listening :)
20:23:11 <Lemonator> I don't know of other uses of row variable polymorphism,
20:23:27 <mmorrow> what's the definition of "row variable" ?
20:23:31 <Lemonator> but dependent types seem to be able to solve the loss-of-information problem associated with subtyping records.
20:23:38 <mmorrow> like an sml record?
20:23:52 <Lemonator> I'll explain.
20:23:58 <Lemonator> say you have a function
20:24:03 <Lemonator> f x = x.a
20:24:13 <Lemonator> if the language has subtyping,
20:24:22 <Lemonator> then you can pass into f any record that has an 'a' field.
20:24:28 <Lemonator> thus, the type of f should be
20:24:43 <Lemonator> f :: {a :: T} -> T
20:24:51 <Lemonator> simple, aye?
20:24:54 <Lemonator> BUT
20:25:13 <Lemonator> say function f not only returns the element,
20:25:17 <Lemonator> but also the original record itself.
20:25:25 <Lemonator> so f x = (x.a, x)
20:25:46 <Lemonator> would (f :: {a :: T} -> ({a :: T}, T))?
20:25:50 <mmorrow> hmm
20:26:08 <Lemonator> you pass in a record {a = x, b = y}
20:26:36 <Lemonator> but the output type specifies a record with only one field, namely 'a'.
20:26:51 <mmorrow> wait, so "{ a :: T }" means "has a field whose label is `a', and the type of the field this label labels is `T'"?
20:26:58 <Lemonator> hence, you lost info.
20:27:01 <Lemonator> mmorrow, yeah.
20:27:12 <roconnor> Does "Verlag" mean incorporated?
20:27:19 <Lemonator> {a :: T} <: {a :: T, b :: U}
20:27:23 <mmorrow> ahhh, ok
20:27:25 <Lemonator> where <: means "subtype of"
20:27:40 <mmorrow> so then i guess the type would be
20:28:24 <mmorrow> f :: {a::T} -> ({a::T}, x s.t. {a::T} <: x)
20:28:51 <Lemonator> sure, that works.
20:29:01 <Lemonator> I forgot what the syntax is,
20:29:07 <mmorrow> whether that notion fits in with a particular type system i'm not sure
20:29:30 <Lemonator> but row variables in Ocaml basically let you say something like
20:29:35 <mmorrow> "polymorphism w.r.t. supertypes" or something
20:29:58 <Lemonator> hm.
20:30:24 <mmorrow> err, actually i guess the type i gave should be:
20:30:36 <mmorrow> f :: x -> ({a::T}, x), where {a::T} <: x)
20:31:18 <mmorrow> (minus that trailing ')')
20:33:50 <ManateeLazyCat> Hi all, i want use some File library, and i found have two version in Prelude and Data.ByteString, what's different between those two libraries?
20:34:38 <mmorrow> ManateeLazyCat: the functions in ByteString by the same name operate on ByteStrings, whereas the prelude ones operate on String
20:34:44 <mmorrow> ManateeLazyCat: (so you need to do
20:34:54 <mmorrow> import qualified Data.ByteString as B
20:34:59 <mmorrow> import qualified Data.ByteString.Lazy as L
20:35:07 <mmorrow> import Data.ByteString (ByteString)
20:35:08 <mmorrow> e.g.
20:35:25 <mmorrow> )
20:35:29 <ManateeLazyCat> mmorrow: Thanks!
20:35:37 <mmorrow> ManateeLazyCat: no problem
20:35:59 <ManateeLazyCat> mmorrow: Can you explain ByteString more details?
20:36:00 <ManateeLazyCat> :)
20:36:16 <ManateeLazyCat> mmorrow: I can use ByteString instead String always?
20:36:47 <mmorrow> ManateeLazyCat: ByteString is represented as an array (in the C sense) of bytes, so characters are 8bits, whereas String = [Char] and
20:36:51 <mmorrow> , maxBound :: Char
20:36:56 <lunabot>  '\1114111'
20:36:59 <ManateeLazyCat> mmorrow: In fact, i want to know different between String and ByteString
20:37:00 <mmorrow> Char supports unicode
20:37:36 <ManateeLazyCat> mmorrow: So you mean String not support unicode in Prelude?
20:37:49 <mmorrow> the size of a Char is 32bits
20:37:56 <mmorrow> and a String = [Char]
20:38:08 <mmorrow> so you have a list of 32bit chars
20:38:23 <mmorrow> each list cell needs a ptr to its contents, and a ptr to the next list cell
20:38:35 <mmorrow> so 2 ptrs + 32bits
20:38:38 <mmorrow> for each character
20:38:47 <mmorrow> a bytestring uses 8bits for each character
20:39:05 <mmorrow> and needs no additional ptrs, because it's packed into memory
20:39:19 <mmorrow> (that's the "low-level" difference i guess)
20:39:39 <ManateeLazyCat> mmorrow: Thanks for explain! Can you recommend some book or website that for File operation in Haskell?
20:39:40 <Lemonator> 32-bit chars?
20:39:48 <ManateeLazyCat> mmorrow: I know RWH
20:40:07 <ManateeLazyCat> mmorrow: I mean a book just explain File operation details.
20:40:14 <Lemonator> they really shouldn't be called "char"s, then.
20:40:15 <mmorrow> Lemonator: well Char is represented by 4bytes, but its max value os less than maxBound :: Int
20:40:21 <Lemonator> It might confuse C programmers.
20:40:26 <mmorrow> Lemonator: heh
20:40:53 <mmorrow> ManateeLazyCat: hmm, i can't think of a book. i'd suggest reading other peoples code
20:41:12 <mmorrow> ManateeLazyCat: what type of stuff are you interested in learning about in particular
20:41:21 <mmorrow> ?
20:41:21 <ManateeLazyCat> mmorrow: Thanks, BTW, thanks for your ZList.hs, even i never use it.
20:41:26 <ManateeLazyCat> mmorrow: Editor
20:41:29 <mmorrow> ManateeLazyCat: heh, no problem
20:41:43 <ManateeLazyCat> mmorrow: I'm developing editor module
20:42:03 <mmorrow> ManateeLazyCat: ah, ok. so for a text editor?
20:42:09 <mmorrow> (yi?)
20:42:30 <ManateeLazyCat> mmorrow: I know Yi project, but that's not my purpose.
20:42:57 <ManateeLazyCat> mmorrow: I'm developing Haskell dynamic environment, and it including editor module for file.
20:42:59 <mmorrow> hmm, i'd suggest browsing through the hackage package list, and looking at the code for packages that do something similar to what you want to do
20:43:25 <mmorrow> the "view source" link on the haddock doc pages is handy
20:44:14 <ManateeLazyCat> mmorrow: Thanks, just want more suggestion before i write it. :)
20:44:31 <mmorrow> ManateeLazyCat: cool :)
20:45:58 <mriou> I have a tricky Haskell question
20:46:08 <mriou> well tricky to explain, hopefully not to answer :)
20:46:33 <mriou> I have a long computation that happens in a monad in which a function is "stored"
20:46:55 * ManateeLazyCat pasted "ListZipper.hs" at http://paste2.org/get/301891
20:46:56 <mriou> say the monad is a ready and I set a function that will act as some callback
20:46:56 <ManateeLazyCat> mmorrow: BTW, i use ListZipper.hs that i modified version to instead your ZList.hs, look above link.
20:47:15 <mriou> say the function type is Foo -> bar
20:47:18 <bos> @seen byorgey
20:47:18 <lambdabot> I saw byorgey leaving #haskell-blah, #haskell-in-depth, #xmonad, #haskell-overflow and #haskell 26m 36s ago, and .
20:47:27 <ManateeLazyCat> mmorrow: Your ZList.hs is cool, but too complicate for my project.
20:47:44 <mriou> now this computation could lead to actually need a function Baz -> bar sometimes
20:48:13 <mriou> so I'd like to pass something like a -> Bar but it's not really that easy
20:48:27 <mriou> does the question make sense?
20:49:00 <mriou> (re-read mysef: "say the monad is a reader" no ready)
20:57:24 <coCocoa> @src Reader >>=
20:57:24 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:57:40 <coCocoa> @src List >>=
20:57:40 <lambdabot> Source not found. My mind is going. I can feel it.
20:57:47 <coCocoa> @src [] >>=
20:57:47 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:58:01 <coCocoa> @src >>= Reader
20:58:01 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:58:08 * coCocoa sighs
20:59:07 <roconnor> @src (>>=) Reader
20:59:07 <lambdabot> Source not found. Where did you learn to type?
20:59:15 <roconnor> @src (>>=) Control.Monad.Reader
20:59:15 <lambdabot> Source not found. Take a stress pill and think things over.
20:59:18 <roconnor> @src (>>=) Control.Monad.Reader.Reader
20:59:18 <lambdabot> Source not found.
20:59:25 <roconnor> @src (>>=) []
20:59:25 <lambdabot> Source not found. There are some things that I just don't know.
20:59:31 <roconnor> @src [] (>>=)
20:59:31 <lambdabot> xs >>= f     = concatMap f xs
20:59:37 <roconnor> @src Reader (>>=)
20:59:38 <lambdabot> Source not found.
20:59:44 <roconnor> @src Control.Monad.Reader.Reader (>>=)
20:59:44 <lambdabot> Source not found. Wrong!  You cheating scum!
20:59:53 * roconnor fails
21:00:50 <coCocoa> @src -> (>>=)
21:00:50 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:01:15 <mmorrow_> @src (->) (>>=)
21:01:16 <lambdabot> f >>= k = \ r -> k (f r) r
21:04:45 <pcc1> can anyone explain why this does not compile? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6507
21:13:52 <dibblego> pcc1, the compile error in the comment is not the one I get
21:17:38 <pcc1> dibblego: which version of ghc are you using? the code uses the new exception mechanism in ghc 6.10
21:17:50 <dibblego> 6.10.2
21:18:16 <pcc1> hm, what error do you get?
21:18:42 <coCocoa> pcc1: I'm a Haskell newbie, so don't mind if I'm just clueless, but I just wondered if your original program has definitions for from/toException, and you just left them out for succinctness? :)
21:18:48 <dibblego> the error is about deriving Typeable and the requirement for a GHC extension
21:19:02 <dibblego> your error message appears to be about the monomorphism restriction though
21:19:36 <pcc1> coCocoa: no I don't, may that be the cause of the error?
21:19:58 <pcc1> dibblego: I turned off the restriction as you can see from the ghc command
21:20:53 <pcc1> dibblego: did you supply -fglasgow-exts?
21:22:45 <dibblego> pcc1, yes I have reproduced it
21:24:58 <pcc1> according to the documentation, to/fromException isn't usually required, and the default definitions seem to be correct in this case
21:27:51 <pcc1> I copied in the default to/fromException, didn't make any difference
21:28:33 <meanburrito920_> I'm a bit confused about how ReadS works. can someone explain to me how it is different than read, and how I can extract the String from it?
21:30:49 <roconnor> @type ReadS
21:30:50 <lambdabot> Not in scope: data constructor `ReadS'
21:30:55 <roconnor> @src ReadS
21:30:55 <lambdabot> Source not found. I feel much better now.
21:31:08 <meanburrito920_> @src reads
21:31:08 <lambdabot> reads = readsPrec minPrec
21:31:18 <roconnor> doesn't ReadS return a list of all possible parses?
21:31:34 <roconnor> plus the remaining unparsed string
21:31:37 <roconnor> @src read
21:31:38 <lambdabot> read s = either error id (readEither s)
21:31:46 <roconnor> @src readEither
21:31:46 <lambdabot> Source not found.
21:32:39 <meanburrito920_> I'm basically trying to get readOct and readHex to return a number as does read, but instead they return [(a, String)]
21:33:01 <meanburrito920_> or rather, ReadS a
21:33:13 <roconnor> essentially read x = y where [(y,"")] = reads x
21:33:42 <roconnor> @hoogle ReadS -> String
21:33:42 <lambdabot> Did you mean: ReadS a -> String /count=20
21:33:42 <lambdabot> Distribution.Text display :: Text a => a -> String
21:33:42 <lambdabot> Prelude show :: Show a => a -> String
21:34:03 <roconnor> er
21:34:12 <roconnor> @hoogle ReadS a -> a
21:34:12 <lambdabot> Text.ParserCombinators.ReadP readS_to_P :: ReadS a -> ReadP a
21:35:13 <meanburrito920_> roconnor: but I cant find any function that extracts the 'a' element out of the returned list. It would seem like such a thing would be often used, so that suprises me a bit that I couldnt find anything.
21:36:12 <coCocoa> > readHex "BADBEEF"
21:36:13 <lambdabot>   [(195935983,"")]
21:36:58 <coCocoa> > fmap fst . readHex $ "BADBEEF"
21:36:59 <lambdabot>   [195935983]
21:37:50 <coCocoa> > fst . sequence . readHex $ "BADBEEF"
21:37:51 <lambdabot>   No instance for (GHC.Base.Monad ((,) a))
21:37:51 <lambdabot>    arising from a use of `Control....
21:38:17 <coCocoa> > fst . sequenceA . readHex $ "BADBEEF"
21:38:18 <lambdabot>   Not in scope: `sequenceA'
21:38:55 <coCocoa> Oh well, be risky and use 'head,' I guess. :)
21:39:10 <coCocoa> > fst . head . readHex $ "BADBEEF"
21:39:11 <lambdabot>   195935983
21:39:18 <pcc1> solved my problem, I simply used catch instead of catchJust
21:41:25 <roconnor> meanburrito920_: I think I've always extraced the element myself.  You'd think there would be a function.
21:41:35 <roconnor> @hoogle readEither
21:41:35 <lambdabot> No results found
21:42:10 <meanburrito920_> roadwarrior: yep. I'll do that then. I agree though. funny there isnt a built in function.
21:42:15 <dibblego> cabal install x, then put Build-Depends: x in My.cabal then configure and I am told that the dependency on x is missing -- wtf?
21:42:57 <roconnor> meanburrito920_: you probably want to check that the remaining unparsed string is empty
21:43:19 <meanburrito920_> roconnor: what does it mean if it is not?
21:43:26 <meanburrito920_> that the parse failed?
21:51:04 <roconnor> meanburrito920_: it means the parse only was able to read and understand a prefix of the string
21:51:23 <meanburrito920_> roconnor: ah. thanks
21:51:29 <roconnor> > readHex "BADBEEG"
21:51:30 <lambdabot>   [(12245998,"G")]
21:52:19 <meanburrito920_> does anyone in here know if cabal has a .deb package? I never was able to find one, i just installed from the tarball
21:57:03 <ivanm> meanburrito920_: cabal-the-library or cabal-install ?
21:57:22 <ivanm> (I don't know either way, but you should probably qualify what you're looking for)
21:58:48 <monochrom> debs are always lagging. do not care about debs.
21:59:01 * ivanm likes ebuilds
21:59:24 <meanburrito920_> ivanm: cabal-install
21:59:40 <ivanm> @go cabal-install deb
21:59:41 <lambdabot> No Result Found.
21:59:43 <ivanm> *shrug*
22:00:56 <meanburrito920_> so I'm assuming no one in here uses ubuntu/debian and has the need for one? or everyone is just a big fan of installing from source...
22:01:02 <Woof> Oh hey there, meanburrito920_
22:01:12 <meanburrito920_> Woof: hey!
22:01:14 <monochrom> I use ubuntu but I ignore the debs.
22:01:32 <monochrom> I don't install from source either.
22:01:40 <meanburrito920_> what do you use?
22:02:20 <meanburrito920_> I like debs because of apt-get and dependency handling. it is true that they lag behind on releases though...
22:02:21 <monochrom> I use ghc binary tarball. I haven't installed cabal. If I were to install cabal I would install from source, yes.
22:02:39 <ivanm> monochrom: so you just use the stuff that comes with extralibs/HP ?
22:02:43 <inimino> meanburrito920_: I have founding Debian's GHC support to be made of fail, and usually end up compiling everything from source
22:02:55 <monochrom> Yes I use extralibs binary tarball too.
22:03:05 <inimino> meanburrito920_: I don't know why this is, and I really like debian
22:03:20 <monochrom> I haven't checked Haskell Platform but I bet they have binary tarball and I would use it one day.
22:03:51 <ivanm> monochrom: atm they don't IIRC, because currently HP == extralibs
22:04:03 <Saizan_> dibblego: user vs. global package db?
22:04:05 <ivanm> with 6.12, HP will replace extralibs and then there might be binary tarballs
22:04:28 <Saizan_> dibblego: are you using cabal configure or runghc Setup configure? you have to add --user to the latter
22:04:39 <dibblego> cabal configure
22:04:49 <Gracenotes> @vixen
22:04:49 <lambdabot> so, what do you think of me?
22:04:53 <dibblego> and I tried to cabal install --global to no avail
22:05:19 <ivanm> I think you need --global for configure as well
22:05:29 <dibblego> that doesn't help
22:05:52 <ivanm> hmmm...
22:05:54 <ivanm> @seen dcoutts
22:05:54 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow, #haskell-soc and #haskell-iphone. I last heard dcoutts speak 6h 31m 10s ago.
22:06:16 <dibblego> http://paste.pocoo.org/show/126582/
22:06:22 <meanburrito920_> #haskell-iphone?
22:06:36 <ivanm> yes
22:06:43 <meanburrito920_> nice.
22:07:49 <ivanm> they're only talking about it atm IIRC
22:08:18 <Saizan_> dibblego: .cabal files are case sensitive
22:08:34 <jeffwheeler> @seen nominolo|uni_
22:08:35 <lambdabot> nominolo|uni_ is in #haskell, #ghc, #haskell-in-depth and #haskell-soc. I last heard nominolo|uni_ speak 12h 16m 10s ago.
22:08:35 <ivanm> Saizan_: as in the filename or the content?
22:08:37 <jeffwheeler> @seen nominolo
22:08:37 <lambdabot> I saw nominolo leaving #haskell-soc, #yi, #ghc, #haskell-in-depth and #haskell 7h 18m 23s ago, and .
22:08:51 <Saizan_> ivanm: what you put in build-depends
22:09:02 <ivanm> *nod*
22:09:13 <Saizan_> ivanm: you can't depend on filemanip if you really want FileManip
22:09:22 <ivanm> right
22:09:41 <ivanm> it then looks like it won't work with zip-archive because it's looking in global, but zip-archive is only in local
22:10:06 <dibblego> got FileManip resolved -- putting zip-archive in global
22:10:18 <Saizan_> dibblego: you could just stick with user
22:10:31 <Saizan_> but i guess you know what you want better :)
22:10:32 <dibblego> how?
22:10:53 <ivanm> dibblego: don't use --global
22:11:06 <ivanm> how can I find out which characters \200, etc. represent?
22:11:12 <Saizan_> use "cabal configure" or "runghc Setup configure --user"
22:13:10 <jeffwheeler> ivanm: I don't really know what I'm talking about, but this might be useful: http://www.fileformat.info/info/unicode/block/latin_supplement/images.htm
22:13:36 <monochrom> One way is to install some Haskell utf8 library and then make it print out "\200\n".
22:14:06 <ivanm> hmm.... doesn't lambdabot or lunabot have utf8 capability?
22:14:13 <ivanm> ,utf8 "\200\n"
22:14:15 <lunabot>  luna: Not in scope: `utf8'
22:14:16 <jeffwheeler> That is,http://www.fileformat.info/info/unicode/char/00c8/index.htm
22:15:09 <monochrom> More GUI-dependently, most GUIs (Windows, GNOME) come with a small program for browsing all characters. You can see glyphs, decriptions, decimal number, hexadecimal number...
22:16:24 <ivanm> monochrom: thanks, forgot I had gucharmap installed :s
22:16:46 <ivanm> though which number would \200 refer to?
22:17:02 <jeffwheeler> 0xC8
22:17:08 <monochrom> I forgot whether \200 stands for octal 200 or decimal 200.
22:17:18 <ivanm> monochrom: that's my confusion as well :s
22:17:27 <jeffwheeler> Oh, I have no idea.
22:17:33 <monochrom> It is easy to test though.
22:17:37 <monochrom> > '\65'
22:17:38 <lambdabot>   'A'
22:17:45 <ivanm> ahhhh
22:17:49 <monochrom> \200 is decimal 200 because \65 is decimal 65.
22:18:02 <jeffwheeler> > '\200' -- ?
22:18:03 <lambdabot>   '\200'
22:18:04 <monochrom> Yes I memorize 65 = 0x41 = 'A'
22:18:06 <jeffwheeler> Ah :(
22:19:39 <Gracenotes> > text "\200 \u200 \0200 \0x200"
22:19:40 <lambdabot>   <no location info>:
22:19:40 <lambdabot>      lexical error in string/character literal at chara...
22:20:14 <Gracenotes> > text "\200 \0200"
22:20:15 <lambdabot>    
22:20:22 <Gracenotes> mrrrrrr.
22:20:40 <jeffwheeler> Yay, so the link above was correct.
22:21:10 <ivanm> ahhh, text
22:21:17 <ivanm> > text "\377"
22:21:18 <lambdabot>   
22:21:56 <inimino> is text new?
22:22:04 <ivanm> @hoogle text
22:22:04 <lambdabot> Text.PrettyPrint.HughesPJ text :: String -> Doc
22:22:04 <lambdabot> Text.XHtml.Transitional text :: String -> HtmlAttr
22:22:04 <lambdabot> Language.Haskell.TH.PprLib text :: String -> Doc
22:22:09 <ivanm> pretty printing
22:24:41 <ivanm> bugger, Data.Char.isLatin1 does up to 0xff, whereas I need up to \377 :s
22:26:41 <monochrom> But Latin1 is defined to be just up to 0xff.
22:26:47 <ivanm> yeah, I know
22:27:05 <ivanm> but what I need to parse is [a-zA-Z\200-\377]
22:30:49 <monochrom> I see.
22:30:50 <inimino> ivanm: those aren't octal?
22:31:09 <inimino> looks suspiciously like it...
22:31:21 <Saizan_> > text "\200"
22:31:22 <lambdabot>   
22:32:52 <inimino> octal 377 = 0xFF though
22:37:09 <monochrom> In Haskell \200 is decimal 200. In other languages (e.g. C) \200 is octal 200.
22:37:45 <inimino> it's just that 0x80-0xFF looks like a more likely range to be interested in than 0x200-0x377
22:37:55 <Woof> I think in C 00200 was octal
22:38:05 <monochrom> If you are reading from a randomly sampled book/person and ask "what is the probability that it writes \200 to mean octal 200", the answer is "pretty high".
22:38:42 <inimino> right, exactly
22:38:49 <inimino> especially given that 0x377 is nothing particularly interesting
22:39:44 <Saizan_> > foldl (\a x -> a * 8 + x) 0 [2,0,0]
22:39:45 <lambdabot>   128
22:39:46 <monochrom> 0x80 is supposedly a control character.
22:40:18 <Saizan_> 0x80 is the first non-ascii too, right?
22:40:42 <inimino> yes
22:50:01 <ivanm> inimino: I'm following the specs of the Dot language
22:50:20 <monochrom> ...
22:50:57 <kniu> Hey guys.
22:51:06 <kniu> In terms of syntax, which is more important?
22:51:10 <kniu> Looking pretty?
22:51:17 <kniu> or being useful?
22:51:36 <monochrom> Not sure what being useful means, but I will go with it anyway.
22:51:58 <flippo> I vote for being able to induce a trancelike state.
22:53:03 <Zeiris> They're both important.
22:53:03 <monochrom> I do things the calculational way. I let the symbols do the work. I want syntax to be useful for that. Prettiness is a bonus.
22:53:22 <Zeiris> I mean, C syntax is pretty useful. Not that pretty.
22:53:57 <ski> C syntax is not that easy to reason about
23:21:43 <Woof> > map [1..100]
23:21:44 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
23:21:45 <Woof> Oops
23:21:50 <Woof> > map ln [1..100]
23:21:54 <lambdabot>   mueval-core: Prelude.read: no parse
23:21:54 <lambdabot>  mueval: ExitFailure 1
23:21:59 <Woof> What's that? : /
23:22:32 <altmattr> I am looking for a tool that will take in a function name and a .hs file and give me the text of that function definition
23:22:36 <davidL> > map log [1..100]
23:22:37 <lambdabot>   [0.0,0.6931471805599453,1.0986122886681098,1.3862943611198906,1.60943791243...
23:22:45 <Woof> Yeah but why does it fail with ln?
23:22:52 <Woof> This is ln: let ln x = foldl (+) 0 $ map (rd ((x - 1) / x)) [1..54321] where rd x n = x ^ n / fromIntegral n
23:23:13 <alexsuraci> > e
23:23:14 <lambdabot>   e
23:23:25 <ski> > exp 1
23:23:26 <lambdabot>   2.718281828459045
23:23:27 <Woof> @let e = exp 1
23:23:28 <lambdabot>  Defined.
23:23:29 <alexsuraci> there we go
23:23:34 <Woof> > e
23:23:35 <lambdabot>   Ambiguous occurrence `e'
23:23:35 <lambdabot>  It could refer to either `L.e', defined at <local...
23:23:37 <alexsuraci> haha
23:23:39 <Woof> --
23:23:59 <alexsuraci> couldn't you just @let ln = logBase (exp 1)?
23:24:15 <Woof> log is already log base e
23:24:28 <Woof> I was trying to write my own ln function
23:24:28 <alexsuraci> oh, right
23:24:34 <alexsuraci> I usually swap them
23:24:40 <alexsuraci> I'm used to log being logBase 10
23:24:45 <Woof> Yeah
23:25:20 <davidL> > let ln x = foldl (+) 0 $ map (rd ((x - 1) / x)) [1..54321] where rd x n = x ^ n / fromIntegral n in ln (exp 1)
23:25:22 <lambdabot>   0.9999999999999998
23:25:40 <Woof> Eh?
23:25:51 <Woof> It's already defined
23:25:59 <Woof> > ln (exp 1)
23:26:01 <lambdabot>   0.9999999999999998
23:26:18 <Woof> @undef
23:26:39 <davidL> > let ln x = foldl (+) 0 $ map (rd ((x - 1) / x)) [1..54321] where rd x n = x ^ n / fromIntegral n in map ln [1..10]
23:26:44 <lambdabot>   mueval-core: Prelude.read: no parse
23:26:44 <lambdabot>  mueval: ExitFailure 1
23:26:50 <Woof> @let ln x = foldl (+) 0 $ map (rd ((x - 1) / x)) [1..60000] where rd x n = x ^ n / fromIntegral n
23:26:51 <lambdabot>  Defined.
23:27:06 <Woof> > ln (exp 1)
23:27:08 <lambdabot>   0.9999999999999998
23:27:12 <Woof> Bleh
23:27:42 <monochrom> Bear in mind that exp 1 itself isn't all that accurate. You only have so many bits to begin with.
23:27:55 <Woof> But log (exp 1) is perfect
23:27:59 <Woof> > log (exp 1)
23:28:00 <lambdabot>   1.0
23:28:12 <monochrom> Ah. Then nevermind me.
23:28:17 <ski> > let ln x = foldl (+) 0 . reverse $ map (rd ((x - 1) / x)) [1..54321] where rd x n = x ^ n / fromIntegral n in ln (exp 1)
23:28:19 <lambdabot>   1.0
23:28:31 <Gracenotes> D:
23:28:51 <ski> > let ln x = foldr (+) 0 $ map (rd ((x - 1) / x)) [1..54321] where rd x n = x ^ n / fromIntegral n in ln (exp 1)
23:28:52 <Woof> Ooh
23:28:53 <lambdabot>   1.0
23:29:07 <Woof> But why is everyone here using let with > ? : s
23:29:21 <monochrom> local let
23:29:27 <ski> Woof : i was defining `ln' slightly different that you ..
23:29:39 <ski> (s/that/than/)
23:29:45 <monochrom> > let ln x = foldr (+) 0 $ map (rd ((x - 1) / x)) [1..54321] where rd x n = x ^ n / fromIntegral n in ln (exp 2)
23:29:46 <lambdabot>   2.0
23:29:50 <Gracenotes> instead of introducing global definitions, it is often better to "let x = y in z"
23:29:53 <Woof> Ah
23:30:00 <Woof> I see
23:30:05 <Gracenotes> which is a let/in expression, rather than a statement (declaration)
23:30:33 * ski still misses the `where' "hack", here
23:30:34 <ski> > () where () = ()
23:30:35 <lambdabot>   <no location info>: parse error on input `where'
23:30:44 <alexsuraci> Anyone here using OS X with multiple displays?
23:30:47 <Gracenotes> > let in ()
23:30:48 <lambdabot>   ()
23:30:49 <alexsuraci> Two preferrably
23:30:53 <monochrom> It is strange that you did not hear of let...in before you heard of @let and ghci's let.
23:31:00 <altmattr> alexsuraci: yep
23:31:16 <monochrom> I blame it not people not reading the Gentle Introduction anymore.
23:31:17 <alexsuraci> altmattr: When you launch Dashboard, does it come in from the left for you?
23:31:24 <monochrom> s/it not/it on/
23:31:50 <altmattr> alexsuraci: not using dashboard I am afriad. the first thing I disable when I setup a system :)
23:31:55 <alexsuraci> haha
23:32:03 <jeffwheeler> altmattr: I feel you there.
23:32:11 <alexsuraci> It's just making me paranoid because I can't tell if it's supposed to do that or if my hackintosh is bugging out.
23:32:11 <jeffwheeler> I've had it on my Mac for ages, never launched it.
23:32:31 <alexsuraci> I only ever use it for delivery status and...I think that's it.
23:32:37 <Woof> Ty, ski : D
23:32:41 <Woof> That reverse does the trick
23:32:43 <Woof> Somehow
23:32:49 <altmattr> jeffwheeler: thanks to TinkerTool I get rid of it (and anchor the dock to a corner)
23:32:50 <ski> you don't see why ?
23:32:54 <Woof> Don't tell me
23:33:13 * ski keeps lips shut
23:33:34 <jeffwheeler> altmattr: I haven't been using my Mac much recently, so I'm not worrying about it
23:33:48 <Woof> What does reverse do generally, ski?
23:34:00 <ski> it reverses the list
23:34:00 <monochrom> > reverse [a,b,c]
23:34:01 <lambdabot>   [c,b,a]
23:34:06 <Woof> That's all. Hm
23:34:11 <altmattr> jeffwheeler: fair enough, I am wringing the neck of an old g4 so I *do* worry about these things :)
23:34:15 <Gracenotes> hm.. how is () a valid symbol?
23:34:31 <ski> Gracenotes : sorry ? it's the empty tuple
23:34:32 <monochrom> () is a value of some famous type.
23:34:33 <Gracenotes> it must be specifically declared one?
23:34:44 <Gracenotes> I mean, it's not letters. it's not punctuation.
23:34:44 <ski> > ( )
23:34:45 <lambdabot>   ()
23:34:55 <ski> > ( 'a' , False )
23:34:56 <lambdabot>   ('a',False)
23:35:00 <ski> > ( 'a' , False , 3 )
23:35:01 <lambdabot>   ('a',False,3)
23:35:13 <Gracenotes> no, I'm wondering is there's a special parsing rule for it
23:35:16 <Gracenotes> if
23:35:19 <jeffwheeler> altmattr: ha, ouch; I mainly use my old Linux box running on <1 gig of ram, and a P4
23:35:30 <monochrom> perhaps you may like http://www.haskell.org/onlinereport/decls.html#sect4.1.2
23:35:34 <Gracenotes> it as anomaly, symbol-wise
23:35:47 <altmattr> jeffwheeler: hooray for old hardware!
23:35:49 <Gracenotes> yes, there, it is part of the grammar. gotcha.
23:35:52 <ski> > [     ]
23:35:53 <lambdabot>   []
23:35:58 <monochrom> Yes it occupies one line of grammar rule for itself.
23:36:09 <jeffwheeler> altmattr: I'm very excited for the upgrade I've got coming in the mail, after probably eight years.
23:36:12 <Woof> >let ln x = foldr (+) 0 $ map (rd ((x - 1) / x)) [1..60000] where rd x n = x ^ n / fromIntegral n in ln (exp 1)
23:36:18 <alexsuraci> difference being you can't have a tuple with a single element
23:36:26 <Woof> > let ln x = foldr (+) 0 $ map (rd ((x - 1) / x)) [1..60000] where rd x n = x ^ n / fromIntegral n in ln (exp 1)
23:36:27 <lambdabot>   1.0
23:36:37 <Woof> Aha
23:36:43 <ski> > foldr (+) 0 $ [a,b,c,d]
23:36:44 <lambdabot>   a + (b + (c + (d + 0)))
23:36:44 <altmattr> jeffwheeler: hooray for *new* hardware!
23:36:49 <ski> > foldl (+) 0 . reverse $ [a,b,c,d]
23:36:49 <jeffwheeler> altmattr: yeah!
23:36:50 <lambdabot>   0 + d + c + b + a
23:36:53 <Gracenotes> foldrawr
23:37:03 <Gracenotes> foldlol
23:37:03 <jeffwheeler> @type a
23:37:05 <lambdabot> Expr
23:37:08 <jeffwheeler> > a
23:37:10 <lambdabot>   a
23:37:13 <jeffwheeler> :(
23:37:16 <monochrom> http://www.hck.sk/users/peter/HaskellEx.htm is a great page for quickly finding your way through Haskell 98 grammar and linking you to the actual manual section.
23:37:26 <Woof> Not sure why that works though : /
23:37:34 <ski> > foldl f 0 . reverse $ [a,b,c,d]
23:37:35 <lambdabot>   Add a type signature
23:37:36 <jeffwheeler> Those Expr's are weird to me.
23:37:43 <ski> > foldl f 0 . reverse $ [a,b,c,d] :: Expr
23:37:44 <lambdabot>   f (f (f (f 0 d) c) b) a
23:37:48 <Woof> @undef
23:37:52 <ski> > foldr f 0 $ [a,b,c,d] :: Expr
23:37:53 <lambdabot>   f a (f b (f c (f d 0)))
23:38:13 <Woof> @let ln x = foldr (+) 0 $ map (rd ((x - 1) / x)) [1..50000] where rd x n = x ^ n / fromIntegral n
23:38:14 <lambdabot>  Defined.
23:38:17 <Gracenotes> Exprs are symbolic values
23:38:30 <Woof> > ln 1000 / ln 10
23:38:33 <lambdabot>   3.0000000000000036
23:38:35 <SubStack> > uncurry ((,) `on` length) ([1,2,3],[7,8,9,10])
23:38:35 <lambdabot>   (3,4)
23:38:42 <Gracenotes> they are a-z, except f/g/h, which can be expr functions
23:38:44 <Woof> > log 1000 / log 10
23:38:45 <lambdabot>   2.9999999999999996
23:38:49 <SubStack> seems like there should be a more concise way to write that...
23:39:02 <SubStack> with arrows or some such
23:39:13 <sbahra> Woof, \o/
23:39:18 <Woof> @let mean2 a b = a + b / 2
23:39:19 <lambdabot>  Defined.
23:39:21 <Gracenotes> it should seem there is
23:39:26 <Gracenotes> @type join (***) length
23:39:27 <lambdabot> forall a. ([a], [a]) -> (Int, Int)
23:39:31 <SubStack> ah
23:39:44 <Woof> > mean 2 (ln 1000 / ln 10) (log 1000 / log 10)
23:39:45 <lambdabot>   Not in scope: `mean'
23:39:51 <Woof> > mean2 (ln 1000 / ln 10) (log 1000 / log 10)
23:39:53 <lambdabot>   4.5000000000000036
23:39:56 <sbahra> Woof, by the way, do you know what '$' does?
23:40:03 <sbahra> @src ($)
23:40:03 <lambdabot> f $ x = f x
23:40:07 <Woof> sbahra!!
23:40:07 <Woof> Hello : D
23:40:16 <sbahra> Woof, you might find it useful (for example, in your ln definition)
23:40:18 <sbahra> Woof, hi. :)
23:40:18 <Woof> Yes, it helps avoid a ton of ((((((((()))))))))))))
23:40:29 <SubStack> Gracenotes++ # that part of my code looks much prettier
23:40:33 <Woof> How are you? : )
23:40:38 <monochrom> I hate a ton of $$$$$$$
23:40:44 <Woof> That too
23:40:46 <jeffwheeler> $s are better than ()s anyday
23:40:48 <sbahra> Woof, not bad. And you?
23:40:54 <sbahra> $ over ().
23:40:58 <Woof> Not bad either. Sleepy though
23:41:05 <Woof> I like a combination of both
23:41:06 <ski> `.' is better than `$'
23:41:06 <monochrom> I prefer ( ) because that's what I learned in kindergarten.
23:41:11 <Gracenotes> SubStack: good :) Although it does require Control.Arrow and Control.Applicative/Control.Monad
23:41:20 <SubStack> I was already using those anyways
23:41:25 <jeffwheeler> . is better than $
23:41:33 <Woof> > mean2 1 5
23:41:34 <lambdabot>   3.5
23:41:54 <Woof> Hm, that's weird
23:41:57 <sbahra> No.
23:42:00 <sbahra> > 1 + 5 / 2
23:42:01 <lambdabot>   3.5
23:42:06 <sbahra> > (1 + 5) / 2
23:42:07 <lambdabot>   3.0
23:42:20 <sbahra> <Woof> @let mean2 a b = a + b / 2
23:42:23 <Woof> Yeah well I'd've thought it'd evaluate 1 + 5 first
23:42:32 <sbahra> No.
23:42:33 <Woof> That's why I dropped the () there
23:42:36 <Woof> I see
23:42:42 <ski> `/' binds tighter than `+'
23:42:49 <Woof> I see
23:42:50 <sbahra> Woof, http://www.haskell.org/onlinereport/standard-prelude.html
23:43:01 <sbahra> Woof, see "infixl 6 +, -" somewhere in there.
23:43:21 <Woof> @let avg2 a b = (a + b) / 2
23:43:22 <lambdabot>  Defined.
23:43:43 <Woof> Ah, okay
23:44:09 <monochrom> mean a b = a + b / 2 is mean.
23:44:13 <Woof> > avg2 (ln 1000 / ln 10) (log 1000 / log 10)
23:44:16 <lambdabot>   3.0000000000000018
23:44:21 <Woof> Heck
23:44:37 <Woof> > ln 1000 / log 10
23:44:39 <lambdabot>   3.0000000000000036
23:44:43 <ski> > Node {}
23:44:44 <lambdabot>   Node {rootLabel = * Exception: <interactive>:1:129-135: Missing field in re...
23:44:46 <ski> > (Node) {}
23:44:47 <lambdabot>   <no location info>: Empty record update
23:44:52 <Woof> Anyway
23:44:54 <ski> strange
23:44:55 <Woof> I should SLEEP
23:45:39 <SubStack> this algorithm would be so hideous in c
23:46:01 <sbahra> SubStack, which algorithm?
23:46:12 <SubStack> experimental algorithm I'm working on
23:46:33 <monochrom> C is mean.
23:46:36 <Woof> Just about any algorithm
23:46:37 <SubStack> it's true
23:46:42 <SubStack> mine is for sequence prediction
23:46:51 <SubStack> like context weighted trees except it's very lazy
23:46:54 <Woof> And on that note
23:46:56 <Woof> Good night
23:47:05 <Woof> Nice to see you again, sbahra! : )
23:47:12 <sbahra> Likewise.
23:47:18 <ray> > let arithmean = liftA2 (/) sum length in arithmean [1..10]
23:47:19 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
23:47:19 <lambdabot>    arising from a use o...
23:47:22 <sbahra> Thanks a lot for your help, B+ BTW.
23:47:24 <sbahra> Good night.
23:47:30 <Woof> B+ : o
23:47:35 <Woof> Not good enough >: O
23:47:39 <ray> > let arithmean = liftA2 (/) sum (fromIntegral . length) in arithmean [1..10]
23:47:40 <lambdabot>   5.5
23:47:41 <ivanm> when using polyparse, can anyone suggest a way I can parse String that begins and ends with quotes but might have escaped quotes in it?
23:47:51 <Woof> Lol jk, better than anything I've ever got, I bet
23:47:53 <mgsloan> I can very quicky rewrite any haskell algorithm in C
23:48:02 <mgsloan> ghc does most of the work for me though ;)
23:48:07 <ivanm> e.g. something like "\"Hello \\\"you\\\"\""
23:48:23 <monochrom> @shape mgsloan
23:48:23 * lambdabot decomposes mgsloan into several parts using the Banach-Tarski theorem and reassembles them to get two copies of mgsloan!
23:48:36 <mgsloan> :O
23:48:40 <mgsloan> excellent
23:48:44 <mgsloan> I've always wanted two of me
23:48:48 <monochrom> lambdabot always guesses my mind correctly.
23:48:52 <sbahra> O
23:49:05 <ivanm> monochrom: @shape == @slap ?
23:49:12 <monochrom> Yes.
23:49:13 <Woof> sbahra: http://khanacademy.org/
23:49:40 <Beelsebob> KHAAAAAAAAAAAAAAAAAAAAAAN!?
23:49:57 <Woof> = Lion
23:50:03 <monochrom> The amazing part is that of all the tricks it can play, it chose the geometric one, going so well with my @shape. I don't know how it understands me, but it does!
23:50:28 <Woof> Prince* Not lion, nvm
23:50:39 <Woof> 'Nyway
23:54:29 <edwardk> lam :: Symantics r => (r c sa da  r c sb db)  r c (r c sa da  r c sb db) (da  db) -- sometimes types just look silly
23:55:33 <monochrom> That is the problem with looking for meaning.
23:55:59 <edwardk> deep. you should write fortune cookies ;)
23:56:06 <monochrom> If you just calculate and let the symbols do the work, you will get work done.
23:56:32 <monochrom> meaning doesn't scale.
23:57:00 <edwardk> That cleans up a bit with ~ judgments:  lam :: Symantics r => (x ~ (r c sa da  r c sb db))  x  r c x (da  db)
