00:00:13 <Twey> Well, elvenporn's sequence has its merits too
00:00:38 <Twey> There's probably something Applicative that you can do with it...
00:00:41 <Twey> :t <$>
00:00:42 <lambdabot> parse error on input `<$>'
00:00:47 <Twey> :t (<$>)
00:00:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:00:57 <Twey> :t (<*>)
00:00:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:01:31 <Twey> [succ, pred, (2*)] <$> [3]
00:01:35 <Twey> > [succ, pred, (2*)] <$> [3]
00:01:36 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
00:01:38 <Twey> Damn
00:01:40 <groberts> can anyone help me with a very simple yet frustrating problem ( http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3075#a3075 )
00:01:58 <Twey> > [succ, pred, (2*)] <*> [3]
00:01:59 <lambdabot>   [4,2,6]
00:02:02 <ray> > let ($) = id in map ($3) [succ, pred, (2*)]
00:02:02 <Twey> That's the one
00:02:03 <lambdabot>   [4,2,6]
00:02:36 <ray> <$> is just `fmap`
00:02:55 <Twey> Yeah
00:03:08 <Twey> I read the name of one and the signature of the other :-P
00:03:09 <ray> it'd be the same as the original one with some infix instead of prefix
00:04:17 <RayNbow> @users
00:04:18 <lambdabot> Maximum users seen in #haskell: 658, currently: 583 (88.6%), active: 8 (1.4%)
00:05:01 <elvenporn> groberts: yeah, you can't do that
00:05:25 <Cale> groberts: The solution is to use let inside the do-block
00:05:49 <groberts> alright
00:05:57 <Cale> let foo = bar
00:06:09 <Twey> It's always seemed strange to me that do { let x = y; z } isn't exactly equivalent to let x = y in z.
00:06:24 <Twey> > do { let x = 5; x + 1 }
00:06:25 <groberts> Is where not allowed in do blocks at all?
00:06:25 <lambdabot>   <no location info>: parse error on input `}'
00:06:35 <Cale> on a line inside the do-block will define foo to be bar for the remainder of the block, and bar is allowed to contain references to everything in scope up to that point
00:06:43 <Twey> And even stranger that it generates a parse error
00:06:45 <RayNbow> Twey: I never managed to get "let ... = ..." to work in braces/semicolons notation
00:06:46 <Cale> groberts: The where isn't inside the do-block really
00:07:00 <Cale> groberts: It's attached to the declaration as a whole
00:07:10 <Cale> that is, directly to 'main' in this case
00:07:16 <groberts> okay
00:07:17 <elvenporn> > do { let {x = 5}; return (x + 1) } :: Maybe Int
00:07:18 <lambdabot>   Just 6
00:07:32 <RayNbow> ah, thx elvenporn :)
00:07:36 <Cale> If it were a definition with multiple guards, 'where' would scope over the guards (so that things bound in the where can be used inside the guards)
00:07:37 <groberts> Cale: thanks for you help
00:07:41 <Cale> No problem
00:16:04 <daviddd> I've been following YAHT (Yet Another Haskell Tutorial) and am getting confused with type instances. Can someone take a look at http://haskell.pastebin.com/m787635ee and point me in the right direction?
00:18:29 <elvenporn> instance (Eq a) => Eq (List a) where
00:20:23 <daviddd> Thanks elvenporn, that did the trick.
00:22:14 <idnar> enjoying my holiday :)
00:22:17 <idnar> er, wrong window
00:38:07 <edwardk> i still love this program: http://comonad.com/haskell/remorse-1.0/remorse.hs
00:45:46 * cjs is amazed.
00:46:00 <Deewiant> :-D
00:47:34 <edwardk> that was written by malcolm wallace and won the 0th annual IOHCC competition
00:49:11 <Deewiant> Are the full results anywhere?
00:49:29 <edwardk> deewiant: on a hard drive in sweden with shapr's ex-girlfriend ;)
00:49:40 <Deewiant> >_<
00:50:03 <Deewiant> Not quite the answer I was looking for :-P
00:50:30 <malcolmw> thanks for the love :-)
00:53:17 <edwardk> malcolmw: had i thought about it i would have just asked you for a copy. shapr was trying to reconstitute the files from the IOHCC contests a while back
00:53:31 <edwardk> i just happened to be cleaning off and old drive and tripped over it a few minutes ago
00:53:45 <habitue> @pl \f -> zipWith ($) (cycle [f,id])
00:53:45 <lambdabot> zipWith id . cycle . (: [id])
00:53:47 <cjs> How do I pass a pattern to another function for it to try to match?
00:54:06 <mux_> you can't do that, patterns aren't first-class objects
00:54:14 <cjs> I suppose I could define a function that matches the pattern and returns Maybe a, but that seems a bit awkward.
00:54:32 <mux_> you'll have to do that, or a variant along the same idea
00:54:40 <edwardk> pass a function that does the matching for you and returns a value in some type that you know how to deal with
00:57:38 <malcolmw> edwardk: remorse is also hosted at http://www.cs.york.ac.uk/ftpdir/pub/haskell/contrib/
00:58:11 <cjs> Argh! All the words I can think of for my function name are already used by the prelude!
00:58:45 <edwardk> malcolmw: ah nice
00:59:06 <edwardk> for some reason i had thought it was lost =)
01:48:44 <lament>    
01:49:15 <Rembane> I take the blue dot
01:49:24 <matsuura> Then i'll take the green
02:18:58 <`steven> is it possible to DFS in a purely functional way
02:25:52 <WorkyBob> `Steven: sure df :: Tree a -> [a]; df (Branch l v r) = df l ++ v:df r; df (Leaf v) = [v]
02:28:42 <WorkyBob> or, more efficiently, dfs :: Tree a -> (a -> Bool) -> Maybe a; dfs f (Branch l v r) = case dfs f l of {Nothing -> if f v then Just v else dfs f r; v' -> v'}; dfs f (Leaf v) = if f v then Just v else Nothing
02:29:12 <cjs> Man I love type classes. How did I ever live without them in all those other languages?
02:33:17 <`steven> WorkyBob: i see... i guess i'll be spending the rest of my night trying to figure out how that works
02:35:28 <bremner> `steven: if you understand pattern matching, WorkyBob's first code is completely classical
02:36:13 <Phillemann> "Unfortunately, Darcs is written in Haskell and depends on GHC, or Glasgow Haskell Compiler; yet another Modern Language compiler suite suffering from a severe case of the penis-envy, wanting to become an operating system." - Does anybody know what he means by that? o_O
02:36:42 <WorkyBob> Phillemann: I think it means "oh no, it's not written in C, and I don't have the compiler by default, it must suck"
02:39:06 <`steven> bremner: i'm still new to haskell, but the first version looks quadratic which is not really what i'm looking for
02:40:53 <bremner> `steven: from the append? or some more subtle reason?
02:41:51 <`steven> bremner: the append
02:44:12 <Kanoja> good morning haskell people
02:44:53 <bremner> `steven: the second version avoids append by solving a different problem :-)
02:45:18 <WorkyBob> yep
02:45:31 <Kanoja> does anyone know if there is a web hlint interface?
02:45:42 <Kanoja> I can't install hlint here
02:45:59 <WorkyBob> `steven: also, the first one should work out nicely, assuming that the compiler does well
02:47:07 <matsuura> can you guys teach me haskell?
02:47:25 <WorkyBob> matsuura: we can direct you to resources from which you can learn it
02:47:30 <WorkyBob> and we can help if you have questions
02:47:40 <WorkyBob> but I doubt anyone here has time to sit down and teach you
02:47:48 <Kanoja> matsuura: http://learnyouahaskell.com/
02:49:10 <matsuura> I don't agree with you. I am very pleased as to which you are doing for me, however :)
02:49:14 <matsuura> Thank you very much
02:49:21 <matsuura> I will ask my questions as need be ^_^
02:51:14 <cjs> Phillemann: well, GHC does have a fairly large and sophisticated runtime, including not only memory management but algorithms for scheduling threads across processors.
02:57:29 <`steven> is that site intentionally not "for great justice"?
03:03:19 <soupdragon> dunno
03:04:43 <MyCatVerbs> soupdragon: are the Clangers misbehaving?
03:04:51 <soupdragon> no no
03:10:17 <thaldyron> According to the HLint manual "hlint darcs-2.1.2.2" should work if I have a subdir darcs-2.1.2.2 in the current directory. But why do I get "hlint: darcs-2.1.2.2: openFile: inappropriate type (is a directory)"
03:12:34 <eflister> hola.  why does this start printing numbers in the right order?   foldr (\x -> if x < 10 then (x :) else id) [] [1..]
03:13:22 <cjs> thaldyron: sounds suspiciously like the manual's wrong.
03:13:36 <eflister> shouldn't the foldr never get started if the list is infinite?
03:14:12 <soupdragon> eflister, no
03:14:31 <cjs> It just evaluates as much as it needs to, which is not the entire list.
03:15:18 <eflister> i thought i understood that, but in this case i don't see how it decides how much it needs to
03:15:27 <eflister> note that the operation doesn't complete
03:15:38 <eflister> but it does print out [1..9]
03:15:39 <soupdragon> > foldr (\x -> if x < 10 then (x :) else id) [] [1..]
03:15:45 <lambdabot>   mueval-core: Prelude.read: no parse
03:15:45 <lambdabot>  mueval: ExitFailure 1
03:15:51 <soupdragon> oh right
03:15:54 <eflister> ah, that looks more reasonable
03:16:00 <eflister> ghci acts different
03:16:04 <soupdragon> it does a bit then goes into a loop
03:16:11 <soupdragon> so e.g.
03:16:14 <soupdragon> > head $ foldr (\x -> if x < 10 then (x :) else id) [] [1..]
03:16:17 <lambdabot>   1
03:16:19 <soupdragon> > length $ foldr (\x -> if x < 10 then (x :) else id) [] [1..]
03:16:24 <lambdabot>   mueval-core: Prelude.read: no parse
03:16:24 <lambdabot>  mueval: ExitFailure 1
03:16:27 <soupdragon> somethings work some don't
03:16:31 <eflister> yeah i totally get that
03:16:44 <eflister> what i don't get is how the bit that it does is at the beginning
03:16:55 <soupdragon> well it's like  print . head
03:17:00 <eflister> OH
03:17:04 <soupdragon> then  print . head . tail
03:17:04 <eflister> that totally makes sense
03:17:14 <soupdragon> then boooom! when it goes too far
03:17:17 <eflister> it's the act of showing it that is causing it
03:17:51 <eflister> soupdragon++
03:18:02 <thaldyron> cjs: So I just call it with "hlint foo.hs" ?
03:18:12 <eflister> soupdragon ++
03:18:18 <eflister> why doesn't that work?
03:22:11 <thaldyron> mhm, "hlint foo.hs" simply prints "#line 1 "foo.hs" and then echos the whole file that can't be right...
03:22:21 <Kanoja> I must speak with neal
03:22:29 <Kanoja> can't install hlint in this place
03:23:11 <Kanoja> it would be really sweet for a web version of hlint
03:23:17 <Kanoja> fuuu ^__^
03:24:15 <quicksilver> .wub 26
03:24:18 <quicksilver> nice typo.
03:31:58 <deadlock> hi guys.... i have a little question about GUI
03:35:12 <deadlock> in a fram i want to place a static text and 2 buttons, so i wanted the text& the 1 button as  al  column ( column 25 [ widget static_text, widget button 1] ) the 2. button in a row with the column so i thought row 15 [column 25 [ widget static_text, widget button 1], widget button 2] would work but it doesnt....how do i manage that
03:37:20 <ivanm> deadlock: which gui library are you using?
03:37:28 <ivanm> gtk2hs? wxhaskell? something else?
03:37:41 <ivanm> (not that I can help, but someone else might be able to with that information)
03:38:17 <deadlock> wxhaskell yes
03:39:05 <Gwern-away> @tell sm emailing it to the -users or giti ml would be fine too - get it out there and searchable
03:39:05 <lambdabot> Consider it noted.
03:41:46 <deadlock> i get "parse error (possibly incorrect indentation)" every time
03:42:56 <EvilTerran> deadlock, could you hpaste.org the relevant bit of code?
03:44:15 <deadlock> wait
03:45:31 <deadlock> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7381#a7381
03:46:22 <EvilTerran> deadlock, count [s and ]s
03:46:46 <EvilTerran> the '[' in "set f [ layout :=
03:46:46 <EvilTerran> " has no matching ']'
03:47:15 <tututata> hallo
03:47:22 <tututata> !liste
03:47:29 <tututata> !list
03:48:12 <ivanm> why join, say hello and then leave? :s
03:48:15 <quicksilver> !list -- because all IRC channels are obviously warez channels.
03:48:21 <ivanm> heh
03:48:28 * EvilTerran has been in channels where people get kickbanned by the bot for saying "!list"
03:48:35 <ivanm> hmmm...
03:48:37 <ivanm> @list
03:48:37 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:48:37 <quicksilver> that's pretty lenient.
03:48:38 <ivanm> ;-)
03:48:50 <quicksilver> Hunted down like a dog and shot is also fairly common I think.
03:49:04 <Twey> We should have \b DCC a copy of GHC !list'ers
03:49:08 <ivanm> quicksilver: you mean there are actually people bored enough that they'll do that? :o
03:49:20 <deadlock> *facepalm.... thx EvilTerran....sometimes i hate myself ;)
03:49:36 <Twey> s/GHC/GHC to/
03:49:54 <ivanm> Twey: heh
03:50:34 <EvilTerran> deadlock, do you have a text editor that does any kind of visual bracket matching? that can help prevent that sort of (otherwise inevitable) oversight
03:51:07 <bremner> quicksilver: on behalf of dogs everywhere, I deeply resent the comparison to warez-kiddies
03:51:08 <deadlock> which is preferred for haskell....i still use win editor
03:51:23 <EvilTerran> i use SciTE. a lot of people use vim or emacs.
03:51:38 <EvilTerran> i think some people may even use yi.
03:51:51 <ivanm> or leksah
03:52:07 <ivanm> or the OSX people use the fancy OSX editor, whose name I can't recall
03:52:11 <ivanm> bremner: lol
03:52:24 <ivanm> deadlock: by "win editor", do you mean notepad?
03:52:54 <EvilTerran> ivanm, wouldn't that be "fail editor"? :P
03:53:03 <deadlock> no not notepad....the simple editor...no highlightning or some kind of this fancy stuff
03:53:23 <ivanm> EvilTerran: heh
03:54:06 <osfameron> I think notepad gained a feature in the Vista version... I was horrified
03:54:35 <osfameron> (line numbers or something like that.  if God had wanted us to be able to browser to a line without having to count from the top, he'd have given us a computer).
03:54:39 <deadlock> ok im trying scite
03:54:45 <Beelsebob> ivanm: TextMate or SubEthaEdit?
03:54:59 <ivanm> deadlock: which one? that _is_ the windows editor...
03:55:09 <ivanm> osfameron: heh
03:55:45 <Beelsebob> ivanm: there's two reasons why OS X users don't like leksah quite so much -- one of which is that it doesn't support multiple windows all over the place, it wants to be run maximised and have its window split up instead, which is very un-OS X; secondly, it runs in X11 for now, which means that most of the nice features of OS X aren't available in it
03:56:05 <Beelsebob> (I think it's a bloody impressive piece of software, it just doesn't fit on a Mac very well atm)
03:56:11 <osfameron> though of course the nice features of X11 are :-)
03:56:26 <osfameron> (i.e., it can probably run in xmonad... um.  Anything else? ;-)
03:56:47 <Beelsebob> osfameron: who cares about running it in xmonad -- it does its own window/pane management
03:56:52 <Beelsebob> (which brings me back to point 1)
03:57:11 <jnwhiteh> I prefer vim, since I can have a consistent interface regardless of what computer I sit down to; although emacs has the same property.  I don't like OS specific editors just because I like having mobility
03:57:41 <LeoD> would be cool if leksah had vim keybindings :p
03:57:45 <bremner> I don't like language specific editors for the same reason, more or less
03:57:45 <Beelsebob> jnwhiteh: *nod* I just SubEthaEdit wherever I can, and vim wherever I can't :(
03:58:09 <jnwhiteh> I need to figure out how to define omni completion for other languages, however.
03:58:16 <jnwhiteh> for all the documentation, seems tough to find.
04:00:17 <quicksilver> yes, language specific editors really annoy me because a good editor is actually a very complex peice of software - which you can develop quite a high level of skill using.
04:00:30 <quicksilver> it's annoying to have to re-learn because some language decided to invent its own editor.
04:01:28 <deadlock> @ivanm oh youre right....mixed it up with wordpad
04:01:28 <lambdabot> Unknown command, try @list
04:01:38 <deadlock> @list
04:01:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:15:21 <MarcWeber> nominolo_: I'd like to implement missing features such as adding functinos to import list etc. Do you already have some ideas how this should be done?
04:20:26 <deadlock> is there an internal command to quit a programm...something like exit(0) ?
04:21:13 <Zao> exitWith
04:21:13 <quicksilver> exitWith ExitSuccess
04:21:15 <EvilTerran> ?hoogle exit
04:21:15 <lambdabot> module System.Exit
04:21:15 <lambdabot> System.Exit data ExitCode
04:21:15 <lambdabot> Control.Exception ExitException :: ExitCode -> Exception
04:21:27 <EvilTerran> ?hoogle exitWith
04:21:28 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
04:22:57 <Saizan_> it does so by throwing an exception, so make sure you call it from the main thread
04:23:56 <nominolo_> MarcWeber: that's a bit tricky, because the code won't typecheck, or more precisely, it will not rename.  I've been thinking about adding a callback to GHC so that unbound variables are replaced by 'undefined's
04:24:17 <deadlock> how to put it  on command of a button?...i.e. exit_button <- button f [ text:= "EXIT" , on command *****]
04:25:15 <nominolo_> MarcWeber: you could of course just parse the error messages and play around with the source text, but that would be more prone to failure, I think
04:25:25 <nominolo_> But it could be done right now
04:26:02 <Twey> Or just exitSuccess
04:26:09 <Twey> ?hoogle exitSuccess
04:26:10 <lambdabot> System.Exit ExitSuccess :: ExitCode
04:26:17 <Twey> Oh, not that one
04:26:28 <Twey> Huh.
04:26:41 <Twey> Why doesn't hoogle find System.Exit.exitSuccess?
04:27:22 <Saizan_> case sensitivity bug?
04:35:14 <MarcWeber> nominolo_ I've had this error message parsing in the past. It works quite well. (at least for now). However I'm not sure which is the best way to implement this adding to import list.
04:35:43 <nominolo_> MarcWeber: you can look things up in the package database
04:35:46 <Ke> http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/GHC-Base.html broken link
04:35:56 <MarcWeber> nominolo_: Should list-rdr-names-in-scope return a list of functions which are in scope?
04:36:33 <nominolo_> MarcWeber: yeah, that's for completing.  it will only look through imported modules
04:36:38 <MarcWeber> nominolo_: Anyway bg-check works fine now. I don't know what was wrong this morning :-)
04:37:37 <MarcWeber> It returns an empty list here. That's why I've asked
04:38:37 <MarcWeber> ThingAtPoint works for main = print "hw"
05:10:10 <FliP^2eH> My god what have you done to me? I can't read C code without thinking how ugly it is with it's changable variables and stuff!
05:10:29 <benmachine> :D
05:12:06 <Rembane> :D
05:12:21 <vegai> it'll pass
05:12:32 <Erikie> anyone know a simple way to check if a number is palindromatic?   9009 = true etc.
05:12:34 <FliP^2eH> :)
05:12:44 <FliP^2eH> Apply show on it
05:12:47 <leifw> Erikie: in what base
05:12:55 <Erikie> Decimal
05:12:56 <FliP^2eH> And us reverse == reverse
05:13:14 <Erikie> ah, not sure why i didn't use show, I'm an idiot
05:13:17 <Erikie> move along.
05:13:49 <ivanm> FliP^2eH: you mean reverse == id ?
05:13:49 <FliP^2eH> I'm sure the guys here find a solution that's about 25 chars big, so let's just wait a while
05:13:52 <Twey> More efficiently, you only need to check the first half of each
05:13:54 <FliP^2eH> Yep
05:14:19 <FliP^2eH> I always did it with "if word == (reverse word)"
05:15:06 <ivanm> Twey: though what's an efficient way of taking half the string?
05:15:17 <Twey> palindrome str = let len = ceiling $ genericLength str / 2 in take len str == take len (reverse str)
05:15:25 <sebaseba> > let isPalindromatic n = let s = show n in s == reverse s in isPalindromatic 9009
05:15:26 <lambdabot>   True
05:15:32 <FliP^2eH> take (length str `div` 2) str
05:15:34 <Twey> It's not much better because of that reverse, but it's a small improvement.
05:15:35 <sebaseba> > let isPalindromatic n = let s = show n in s == reverse s in isPalindromatic 9008
05:15:36 <lambdabot>   False
05:15:45 <doserj> > let palindrome = ((==) <*> reverse) . show in palindrome 9009
05:15:47 <lambdabot>   True
05:15:48 <Twey> FliP^2eH: That'll miss the middle character if the string has an odd number of characters
05:15:53 <FliP^2eH> Hm
05:16:02 <Phillemann> Hmmm, how can I convert three "m Char" to one "m String"?
05:16:10 <EvilTerran> ?type sequence
05:16:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:16:13 <ivanm> FliP^2eH: besides, length isn't efficient
05:16:13 <Twey> E.G. it thinks 969 and 979 are palindromes
05:16:21 <EvilTerran> Twey, er, they are
05:16:27 <Twey> Er
05:16:31 <Twey> Yeah.
05:16:34 <FliP^2eH> Just was about to say that
05:16:35 <Twey> Forget that :-P
05:16:38 <FliP^2eH> :)
05:16:40 <ivanm> Twey: heh
05:16:42 <Twey> `div` 2 it is
05:16:58 <matsuura> :D
05:17:06 <EvilTerran> Phillemann, sequence :: (Monad m) => [m a] -> m [a], so sequence :: (Monad m) => [m Char] -> m String
05:17:24 <EvilTerran> (as type String = [Char])
05:17:33 <Phillemann> EvilTerran: Hmmm, ok. Can that be generalized so it uses another operator instead of (:)? That could also come in handy some day.
05:17:58 <FliP^2eH> > -- O M G Comment.
05:17:59 <lambdabot>   not an expression: `-- O M G Comment.'
05:18:08 <ivanm> heh
05:18:10 <Twey> > 3 -- O M G Comment.
05:18:11 <lambdabot>   3
05:18:22 <benmachine> > 3{--}4
05:18:23 <lambdabot>   Add a type signature
05:18:25 <ivanm> Twey: so it's an "O M G" comment as opposed to a normal comment? :p
05:18:30 <sebaseba> ?type foldM
05:18:31 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
05:18:33 <Twey> Apparently so.
05:18:39 <ivanm> > 3 {--} + 4
05:18:40 <FliP^2eH> Comments on steroids
05:18:40 <lambdabot>   7
05:18:42 <Twey> benmachine: Parses as 3 4
05:19:12 <benmachine> Twey: k, so why would adding a type signature help?
05:19:17 <ivanm> > 3 {-|-} + 4 -- is that a TIE interceptor?
05:19:18 <lambdabot>   7
05:19:28 <ivanm> benmachine: that means lambdabot has NFI what "3 4" means ;-)
05:19:42 <benmachine> fair enough
05:19:44 <Twey> benmachine: Because that's valid code if there's a Num type that the compiler can use for that 3 that also happens to be a function type
05:19:45 <ivanm> but there might be some random weird data type in which that makes sense
05:19:53 <doserj> @type Data.Traversable.sequenceA -- Phillemann
05:19:53 <ivanm> (which it can't, because numbers aren't constructors)
05:19:54 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
05:19:57 <ivanm> s/aren't/can't be/
05:20:07 <FliP^2eH> > let theMeaningOfLife = 42 in theMeaningOfLife * 2
05:20:08 <lambdabot>   84
05:20:22 <Phillemann> doserj: Ah, great.
05:21:05 <FliP^2eH> if(buffer[0]=='P' && buffer[1]=='I' && buffer[2]=='N' && buffer[3]=='G')
05:21:06 <FliP^2eH> Tehee.
05:21:37 <benmachine> buffer[1] = 'O'; send(buffer);
05:21:39 <Twey> > let 6 * 9 = 42 in 6 * 9
05:21:40 <lambdabot>   42
05:21:54 <Twey> FliP^2eH: Gack!
05:22:06 <benmachine> > let 2 + 2 = 5
05:22:07 <lambdabot>   not an expression: `let 2 + 2 = 5'
05:22:08 <FliP^2eH> Disclaimer: I didn't write it :)
05:22:11 <Twey> strncmp(), man, strncmp()!
05:22:20 <FliP^2eH> Found it in a random source
05:22:21 <Twey> (also, man strncmp)
05:22:22 <benmachine> memcmp'd probably be as good
05:22:28 <Twey> FliP^2eH: Which one?
05:22:34 <FliP^2eH> Some IRC Bot
05:22:41 <Twey> Somebody wrote an IRC bot in C?
05:22:45 <benmachine> I did that
05:22:50 * Twey did that once, as an exercise in masochism
05:22:53 <benmachine> back when I didn't know better
05:22:59 <benmachine> it did rpn
05:23:03 <FliP^2eH> Actually, the most popular one is writtin in C
05:23:08 <FliP^2eH> Think off Eggdrop
05:23:10 <Twey> ... Eggdrop?  :-P
05:23:18 <Twey> Isn't Eggdrop in Tcl?
05:23:29 <FliP^2eH> Nope, that's it's scripting part
05:23:40 <Twey> Oh, no, written in C
05:23:47 <Twey> Eep
05:24:24 <benmachine> incidentally, quake3's QVM tools' parser is basically exactly that PING example
05:24:31 <FliP^2eH> Brainf*** interpreter in 80 lines CPP. I shall try Haskelling that one
05:24:33 <benmachine> except for 500 lines
05:24:48 <mercury^> benmachine: ah, you're that guy who modded for tremulous?
05:24:52 <benmachine> yus
05:26:18 <Twey> benmachine: >.<
05:26:22 <benmachine> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3076#a3076 hee hee
05:26:41 <Twey> MY EYES
05:27:00 * Twey falls to the floor theatrically
05:27:08 <FliP^2eH> WHYYYYy
05:33:01 <hamishmack> Beelsebob: Please try out http://leksah.org/Leksah-0.6.1.0.dmg if you have a chance
05:33:11 <hamishmack> It does not use X11
05:33:26 <hamishmack> uses mac menu bar
05:34:04 <hamishmack> and there is a "View -> Detach" feature which allows you to use multiple monitors
05:34:22 <Cale> The ridiculous thing about that code is that it looks like it was written by someone who ought to know a more sensible way to do that.
05:36:32 <Cale> Hehe, but if you're going to write code that looks like it was generated by a machine, you could have gone all out and used nested cases.
05:37:46 <Twey> Cale: Haha
05:44:37 <Plouj> I don't get why I should use composition to do suffixes = init . tail but application to do printStrLn $ show [("hi")]
05:45:02 <Plouj> putStrLn*
05:45:56 <quicksilver> you could do putStrLn . show $ [("hi")]
05:46:01 <quicksilver> does that help clear it up?
05:46:20 <benmachine> the thing on the right of a . has to be a function
05:47:13 <leifw> Plouj: unless I'm mistaken, printStrLn . show [("hi")] would be equivalent to (printStrLn show) [("hi")]
05:47:14 <Nebasuke> and function application has a higher priority than composition so putStrLn . show [("hi")] would apply [("hi")] to show first
05:47:37 <leifw> which probably doesn't obey the type system
05:47:53 <benmachine> leifw: you are mistaken I believe
05:47:57 <leifw> k
05:48:11 <leifw> I believe so too
05:48:51 <Nebasuke> putStrLn . show $ [("hi")] would be equivalent to (putStrLn . show) [("hi")]
05:49:40 <badsheepy> i just installed ghc and ghc+platform, and now cabal tells me openfile: does not exist when i try to upgrade/install etc
05:49:47 <leifw> right
05:49:49 <badsheepy> anyone got an idea what did i do wrong?
05:49:56 <leifw> how would you get (putStrLn show) [("hi")]
05:50:10 <Plouj> you can't seen to do putStrLn show
05:50:18 <leifw> you shouldn't be able to
05:50:24 <doserj> just do putStrLn show [("hi")]
05:51:12 <doserj> f a b === (f a) b
05:51:22 <Plouj> so, composition vs applicaiton is not just about the data flow but about the precendence of operators?
05:51:22 <leifw> oh ok
05:51:23 <ivanm> doserj: putStrLn $ show [("hi")]
05:51:23 <ivanm> ?
05:51:48 <doserj> ivanm: if you want it to type-check, yes. but that wasn't the question :)
05:51:54 <ivanm> ahhhh
05:51:55 <ivanm> ;-)
05:52:25 <Nebasuke> Plouj: well you're already applying in your example
05:52:44 <Nebasuke> you're applying [("hi")]
05:52:55 <smorg> i thought (foo $ bar baz) == ( foo (bar baz))
05:52:56 <Plouj> Nebasuke: I don't care about the example specifically. I just want to understand when to use $ and when to use .
05:53:17 <Nebasuke> well . is for function composition
05:53:22 <Nebasuke> @src (.)
05:53:22 <lambdabot> (f . g) x = f (g x)
05:53:31 <benmachine> smorg: yes
05:53:39 <Nebasuke> so you have to use that when you want to compose functions
05:53:51 <Nebasuke> when you want to have function application to have less precedence you use $
05:53:55 <leifw> so if smorg is right, and foo $ bar baz == foo (bar baz)
05:54:00 <leifw> and if lambdabot is also right
05:54:04 <Nebasuke> @src ($)
05:54:04 <lambdabot> f $ x = f x
05:54:08 <leifw> then it looks like $ and . are interchangable
05:54:15 <Nebasuke> $ is just function application really
05:54:17 <benmachine> in some situations
05:54:24 <leifw> even though they are probably not
05:54:28 <benmachine> foo . bar baz is not allowed
05:54:35 <benmachine> because bar baz will be done first
05:54:41 <benmachine> well
05:54:48 <leifw> so you'd have to do foo . bar $ baz?
05:54:49 <benmachine> if bar baz returns a function then you're ok
05:54:52 <benmachine> yes
05:54:54 <smorg> (foo . bar . baz) bork  =  foo $ bar $ baz $ bork  =  foo (bar (baz bork))
05:54:55 <leifw> ok
05:55:05 <benmachine> smorg: yes
05:55:07 <leifw> starting to understand, thanks
05:55:10 <benmachine> however
05:55:24 <opqdonut> = foo . bar . baz $ bork
05:55:28 <smorg> and then theres currying too which i don't quite understand yet.
05:55:31 <benmachine> @pl f x = 0 == 1 + x
05:55:31 <lambdabot> f = (0 ==) . (1 +)
05:55:36 <opqdonut> = foo . bar $ baz bork
05:55:41 <opqdonut> the last two ones are pretty widely used
05:55:45 <benmachine> ^ in this case (0 ==) $ (1 +) wouldn't make sense I think
05:56:48 <dcoutts> badsheepy: got a log of the problem?
05:57:00 <badsheepy> uhm, thats all it says :o
05:57:42 <badsheepy> update didnt work to begin with, till i rm -r .cabal
05:57:45 <badsheepy> now update works
05:58:10 <dcoutts> badsheepy: ah well, I guess we'll never know then :-(
05:58:17 <badsheepy> and upgrade with -v3 stops at:hehe
05:58:22 <badsheepy> oops -hehe :p
05:58:38 <badsheepy> cabal: ?: openFile: does not exist (No such file or directory)
05:58:50 <badsheepy> i dont think thats actually a ?, just my character set is demented :)
05:59:27 <dcoutts> badsheepy: you mean you can still reproduce it?
05:59:48 <badsheepy> yeah, i cant NOT reproduce it :)
06:01:15 <dcoutts> badsheepy: can you post a log of cabal upgrade -v3 on hpaste, also the content of your ~/.cabal/config file
06:01:22 <Erikie> What's the option for GHCi to output time taken to evaulate a function ?
06:01:43 <badsheepy> oh yeah np, just a sec ty
06:01:53 <dcoutts> Erikie: :set +s
06:02:33 <Erikie> dcoutts: thanks
06:03:21 <Erikie> ughh my brute force for problem 4 on euler challenge takes 1.75 seconds....horrible.
06:05:06 <Saizan_> Erikie: ghci is generally quite slower than compiling with optimizations
06:05:26 <Philippa> though that may itself take longer than 1.75s
06:05:32 <ehamberg> and 1.75 seconds is great if you are on an amiga 500.
06:05:37 <Erikie> haha.
06:05:38 <Philippa> no kidding
06:06:29 <badsheepy> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7386#a7386
06:07:00 <MarcWeber> dcoutts: Is there a way to amke cabal reconfigure projects after the .cabal file has changed automatically reusing previous settings?
06:08:01 <dcoutts> MarcWeber: not yet, but we have a plan for how to do so. If you want to help that'd be great.
06:08:15 <dcoutts> otherwise it likely will not get done for some time
06:08:32 <MarcWeber> dcoutts: Ah ok. Yeah. When I have time I'll look into it. Thanks.
06:09:00 <dcoutts> MarcWeber: basically we'd serialise all the configure options to a file
06:10:59 <lysgaard> Someone would like to help with a bytestring problem i've got. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7387#a7388. The errors are in the 2 nd. revision. This is really confusing me
06:11:05 <dcoutts> badsheepy: what version of cabal is that?
06:11:09 <ivanm> what's the difference between regex-0.7* and regex-0.9* (in terms of choosing one to use) ?
06:11:39 <badsheepy> its SUPPOSED to be the one from the haskell platform, downloaded like 8 hours ago
06:11:52 <badsheepy> actually, it is, or at least it reports..
06:11:56 <dcoutts> ivanm: one comes with ghc and the HP, the other is the latest from hackage
06:12:06 <dcoutts> badsheepy: reports itself as 0.6.2 ?
06:12:23 <badsheepy> cabal-install version 0.6.2
06:12:23 <badsheepy> using version 1.6.0.3 of the Cabal library
06:13:10 <badsheepy> previously, i had ghc + cabal etc all installed via apt-get on ubuntu
06:13:22 <ivanm> dcoutts: is the API meant to be the same or different? (because I've hacked the .cabal file of several packages to use 0.9 rather than 0.7)
06:13:30 <badsheepy> removed them and installed ghc binary package, then the platform
06:13:38 <badsheepy> its possible theres some.. residue hehe
06:13:50 <dcoutts> badsheepy: actually, my mistake, I thought the log was inconsistent with the version, but it's not. It's failing while trying to read the installed packages.
06:14:23 <badsheepy> is it something demented i have done or do i just need to fix some paths?
06:14:34 <dcoutts> badsheepy: it seems pretty demented to me
06:14:53 <dcoutts> badsheepy: especially the fact that it seems to be trying to open a file with a wacky name
06:15:12 <dcoutts> when it should be opening ~/.cabal/hackage.haskell.org/00-index.tar
06:15:35 <badsheepy> hrm ok, i shall go and fiddle and see if i can work out whats going on
06:15:38 <badsheepy> thanks:)
06:15:59 <dcoutts> badsheepy: if nothing works, try rebuilding cabal, though save the old one
06:16:19 <dcoutts> badsheepy: and look for anything suspicious in ~/.cabal/
06:16:20 <badsheepy> alright will do
06:16:42 <badsheepy> well, i already rm -r'd ~/.cabal/ when it wouldnt work when i reinstalled..
06:16:51 <dcoutts> mm
06:17:05 <ivanm> dcoutts: is the API meant to be the same or different? (because I've hacked the .cabal file of several packages to use 0.9 rather than 0.7)
06:17:10 <badsheepy> i mean, its there now cause it rebuilt it hehe
06:17:27 <ivanm> dcoutts: as in, HP aside, what is the difference between them?
06:18:09 <dcoutts> ivanm: yes there are API differences, I'm not sure of the details
06:18:12 <lysgaard> I'm having a problem with ByteString. I want to use ByteString.Lazy.Char8, but the compiler or something says it needs ByteString.Internal.ByteString
06:18:41 <dcoutts> lysgaard: you're getting a mismatch between strict and lazy bytestring types
06:18:52 <ivanm> dcoutts: *nod*
06:19:05 <lysgaard> Could i use strict?
06:19:08 <Saizan_> lysgaard: see Data.ByteString.Char8
06:19:34 <lysgaard> Haha, that did the trick! :D
06:20:33 <Saizan_> different type names might have been a better choice, for documentation purpouses
06:21:31 <benmachine> documentation porpoises
06:21:34 <ivanm> shapr2: are you a clone? :p
06:21:51 <quicksilver> Saizan_: I think the bug is in the way we handle qualified names in documentaiton and error messages
06:22:01 <quicksilver> Saizan_: (NB: I have no solution to suggest. All hope is lost)
06:30:07 <Saizan_> quicksilver: i guess you could make error messages link to a description of the type and the main interfaces for it
06:31:21 <quicksilver> heresy! he who suggests a non-plaintext UI to the compiler shall be put in the #haskell stocks and have rotten lambdas pelted at him by passing peasants.
06:31:29 <hackagebot> darcs 2.3.0 - a distributed, interactive, smart revision control system (PetrRockai)
06:31:51 <mux_> oh, darcs 2.3.0 is out of beta-land, cool!
06:32:26 * Philippa would quite like GHC(i) with HTML output or something
06:32:41 <Philippa> that, and I'm slowly working on a relevant prettyprinting lib
06:34:08 <Saizan_> quicksilver: i want an Error datatype for the ghci API, so you can render it as you please :)
06:34:21 <WorkyBob> Philippa: that would indeed be win
06:34:30 <Philippa> Saizan_: yeah, let people write lightweight frontends
06:36:37 <quicksilver> Philippa: notebook UI!
06:36:55 <quicksilver> Philippa: with a set of graphical combinators which you can output from a Show-like class
06:37:04 <quicksilver> Philippa: to optionally have values 'shown' in 2D representation.
06:39:05 <WorkyBob> quicksilver: Pivotal!
06:39:09 <WorkyBob> (or Vital)
06:39:24 <WorkyBob> Pivotal was complete and utter win
06:41:54 <Philippa> quicksilver: sure, if you want. SEP :-)
06:42:45 <pao> is hackage down?
06:43:04 <ivanm> pao: nope
06:43:21 <WorkyBob> pao: http://downforeveryoneorjustme.com/hackage.haskell.org
06:43:42 <pao> ivanm: thanks
06:43:55 <pao> WorkyBob: I was looking for that site :-)
06:44:39 <WorkyBob> :)
06:45:28 <quicksilver> now I want metaclasses.
06:45:56 <Saizan_> metaclasses?
06:46:01 <Saizan_> i want kindclasses.
06:46:20 <quicksilver> metaclass Representation S rep where { class S a where { rep :: a -> rep } }
06:46:36 <quicksilver> so that "Show" is in the metaclass Representation Show String
06:46:58 <WorkyBob> quicksilver: ohhh, neat idea
06:47:06 <quicksilver> and 2DRendering is in the metaclass Representation 2DRendering Cairo2D
06:47:08 <WorkyBob> so Show, Pretty, and Display would all be in that class?
06:47:21 <quicksilver> (or, substitute your favourite 2D concrete type at the back end)
06:55:41 <WorkyBob> where does HsFFI.h live?
06:58:28 <quicksilver> /Library/Frameworks/GHC.framework/Versions/608/usr/lib/ghc-6.8.3/include/HsFFI.h
06:58:39 <quicksilver> or opt/local/lib/ghc-6.6.1/include/HsFFI.h
06:58:41 <quicksilver> for example :")
07:01:28 <doserj> or /usr/lib/hugs/include/HsFFI.h
07:02:42 <WorkyBob> what libraries do I need to link into C code?
07:02:50 <WorkyBob> -lffi still generates link errors for some rts calls
07:08:06 <quicksilver> WorkyBob: use ghc to compile/link and it provides the corect flags.
07:09:06 <WorkyBob> quicksilver: I can't -- the MS C# .net compiler is eventually going to have to be dealing with it
07:10:19 <WorkyBob> also, that doesn't seem to produce a binary -- only a .o
07:11:34 <quicksilver> well, a .o is a binary.
07:11:42 <quicksilver> if you want an executable, try ghc --make
07:11:51 <WorkyBob> already am doing
07:12:07 <WorkyBob> it produces main.o, rather than a.out
07:12:53 <Ytinasni> does `ghc main.o` produce a binary?
07:13:03 <Ytinasni> (possibly with --make)
07:13:36 <WorkyBob> nope, it produces a no input files error with --make, and it produces a link error without it
07:14:57 <Plouj> I don't get how it makes sense to map foo inside the definition of foo:  http://book.realworldhaskell.org/read/using-typeclasses.html#id608327
07:15:54 <Plouj> maybe I just need to understand how to read that function
07:16:08 <hzap_> Plouj: the foo in map foo is a different function
07:16:30 <Plouj> hzap_: what's the definitio of hta tfoo then?
07:16:33 <Plouj> that* foo*
07:16:51 <doserj> that's the foo that comes from the Foo a instance
07:17:03 <doserj> and you use it to define the foo for the Foo [a] instance
07:17:07 <hzap_> it's defining "foo" for type [a], and it uses the "foo" for type a
07:17:21 <Plouj> oh gosh, that's so confusing
07:18:01 <hzap_> it requires instance Foo a => Foo [a], because it wants to make sure that the type 'a' has foo defined
07:18:28 <Plouj> hzap_: what requires/wants to make sure?
07:18:32 <SamB> hzap_: not just that -- it wants to *use* foo on type a ;-)
07:18:46 <Plouj> huh?
07:18:49 <hzap_> SamB: bad wording from me
07:19:27 <SamB> Plouj: the instance uses Foo a
07:19:44 <Plouj> I love it how after reading so far into RWH I can be so confused by a little line of code
07:19:52 <Axman6> heh
07:20:04 <hzap_> typeclasses can be weird sometimes
07:20:55 <Axman6> Plouj: do you understand that when you're using class functions, the version that is called on a type is the one defined in its class instance definition
07:21:28 * Plouj takes time to understand that question
07:22:01 <hzap_> basically the code says: to "foo" a list of something, you first "foo" each element of that list, and then concatenate them
07:22:15 <Plouj> hzap_: yeah, I get that now
07:22:24 <hzap_> but that only makes sense if the "something" in the "list of something" is a Foo
07:22:43 <Plouj> which is true because Foo a => Foo [a]
07:23:41 <Axman6> so if you have class Foo a where blah :: a -> Int, and you have instances: instance Foo String where blah str = ..., and instance Foo a => Foo [a] where blah xs = map blah xs. if we ran blah ["Hello","Bye"], that would then call map blah "Hello","Bye"], which uses the first definition of blah, for strings
07:24:12 <Axman6> um, let me know if your problem isn't related to what i just said :P
07:24:20 <Plouj> Axman6: I think I understand that too now
07:24:57 <athos> http://www.google.com/search?hl=en&q=recursion
07:25:48 <Axman6> argh!
07:25:50 <lesshaste> hello
07:26:00 <lesshaste> I want to get http://taz.cs.wcupa.edu/~dmead/code/halp/Cnf.hs working
07:26:02 <Axman6> athos:heh :)
07:26:13 <lesshaste> what do I need to do get the infixlogic part?
07:27:24 <Axman6> what do you mean 'get'?
07:27:32 <Axman6> what's your actual problem?
07:27:49 <lesshaste> Axman6, I don't know how to run that code
07:27:51 <Axman6> oh, i get it, sorry
07:28:11 <Axman6> you'll need to download http://taz.cs.wcupa.edu/~dmead/code/halp/InfixLogic.hs too
07:28:20 <Axman6> and have it in the same directory
07:28:50 <lesshaste> ok and I can just do "ghc Cnf.hs" then?
07:29:03 <doserj> darcs get http://taz.cs.wcupa.edu/~dmead/code/halp/ should get you all you need
07:29:08 <Axman6> ghc --make Cnf.hs
07:29:21 <lesshaste>  Could not find module `Text.ParserCombinators.Parsec.Language':
07:29:28 <lesshaste> looks like I am short on modules
07:29:39 <lesshaste> maybe there is an ubuntu package I am missing
07:29:47 <Axman6> need to install parsec
07:29:49 <hzap_> install the parsec library then
07:30:16 <doserj> darcs get http://taz.cs.wcupa.edu/~dmead/code/prover/Prop/ seems to be a newer version
07:30:40 <doserj> and the code seems cabalized
07:30:50 <lesshaste> Axman6 hzap_ thanks
07:31:35 <lesshaste> sorry.. but how do I run it now?
07:33:35 <hzap_> lesshaste: the provermain.hs file has a main function
07:34:08 <hzap_> lesshaste: so if you want to run the whole thing then you'll need the entire package
07:34:27 <lesshaste> hzap_,  ok I think I have that
07:34:37 <lesshaste> hzap_, just don't know what to actually type at the command line to start it
07:34:47 <lesshaste> I am trying to follow http://www.reddit.com/r/programming/comments/10wtg/logic_conjunctive_normal_form_a_short_logic
07:34:55 <hzap_> lesshaste: something like ghc --make provermain.hs
07:35:12 <lesshaste> there is no such file
07:35:15 <lesshaste> there is Cnf.hs
07:35:35 <lesshaste> and that compiled fine
07:36:33 <soupdragon> lesshaste: isn't there a much simpler algorithm based on rewriting/
07:36:34 <soupdragon> ?
07:37:51 <hzap_> lesshaste: do you have all 4 .hs files?
07:38:59 <lesshaste> soupdragon, probably.. actually I have a real need to just do some conversions
07:39:04 <lesshaste> I don't really care how it is done
07:39:12 <lesshaste> hzap_, sorry I don't know what you are referrring to
07:39:20 <lesshaste> are there 4 .hs files?
07:40:06 <hzap_> doserj wrote this - http://taz.cs.wcupa.edu/~dmead/code/halp/
07:41:13 <lesshaste> ah I see
07:41:19 <lesshaste> I wasn't expecting a GUI :)
07:41:33 <lesshaste> all I want to do is convert to cnf
07:41:37 <lesshaste> I don't need the rest
07:41:50 <lesshaste> I just have formulae that I want to end up in cnf
07:44:56 <doserj> ghci Cnf.hs
07:45:02 <doserj> *Cnf> cnf (P:->Q)
07:45:08 <doserj> ~PvQ
07:45:34 <soupdragon> that sucks
07:50:29 <lesshaste> doserj, ah! I just missed the 'i'.. oops
07:50:35 <lesshaste> thanks
07:50:46 <lesshaste> soupdragon, why is it bad?
07:51:58 <soupdragon> I don't like P and Q like that, I don't like the show instance
07:52:17 <lilac> am I reading this right? RWH introduces OverlappingInstances /before/ newtype?
07:53:52 <lesshaste> soupdragon, ok
07:57:53 <athos> ?seen byorgey
07:58:03 <lambdabot> Last time I saw byorgey was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #
07:58:06 <lambdabot> ghc, #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #
07:58:09 <lambdabot> haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #
07:58:12 <lambdabot> xmonad and #yi 1m 21d 10h 6m 57s ago.
07:58:15 <athos> Whoops.
07:58:25 <mauke> preflex: seen byorgey
07:58:25 <preflex>  byorgey was last seen on #haskell 2 days, 20 hours, 22 minutes and 19 seconds ago, saying: but I wouldn't be able to actually give details on that.
07:59:39 <jmelesky> that's a lot of channels to track
08:15:36 <pao> @pl \x y -> uncurry (&&) . (x &&& y )
08:15:36 <lambdabot> ((uncurry (&&) .) .) . (&&&)
08:17:10 <soupdragon> :t \x y -> uncurry (&&) . (x &&& y )
08:17:12 <lambdabot> forall a. (a -> Bool) -> (a -> Bool) -> a -> Bool
08:17:35 <soupdragon> :t liftA2 (&&) :: (a -> Bool) -> (a -> Bool) -> a -> Bool
08:17:37 <lambdabot> forall a. (a -> Bool) -> (a -> Bool) -> a -> Bool
08:18:14 <pikhq> soupdragon: You expected any different from the explicit type signature?
08:18:31 <soupdragon> yes
08:18:59 <pao> soupdragon: which is the Applicative Functor you've used? (r ->) ?
08:19:08 <pikhq> Well, you already handed it exactly the type. ... And that's a perfectly valid type signature for liftA2. So...
08:19:16 <pikhq> :t liftA2 (&&)
08:19:17 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
08:19:29 <soupdragon> I'm not looking for f Bool -> f Bool -> f Bool man
08:19:43 <pikhq> You're looking for the function instance, yes.
08:20:17 <pikhq> (a ->) is a valid Applicative. So...
08:22:41 <pao> soupdragon: nice... definitely the nicest pointfree version :-)
08:22:58 <soupdragon> thanks
08:23:32 * pao is going to try to abuse lambdabot
08:23:40 <pao> @pl liftA2 (&&)
08:23:41 <lambdabot> liftA2 (&&)
08:23:43 <pao> :-)
08:24:13 <Baughn> > liftA2 (&&) [True,False,True] [False,True]
08:24:14 <lambdabot>   [False,True,False,False,False,True]
08:25:15 <pikhq> Oh, right. Lists are also applicatives. :)
08:25:40 <pikhq> > getZipList $ liftA2 (&&) $ ZipList [True,False,True] $ ZipList [False,True]
08:25:41 <lambdabot>   Couldn't match expected type `a -> b'
08:25:56 <pikhq> XD
08:26:07 <soupdragon> my advice is don't use $
08:26:12 <pikhq> > getZipList $ liftA2 (&&) (ZipList [True,False,True]) (ZipList [False,True])
08:26:24 <pikhq> soupdragon: Good advice.
08:26:26 <lambdabot>   [False,False]
08:26:38 <pikhq> That took quite a bit of time to compute.
08:26:59 <pikhq> And in this case was a needlessly verbose way of writing:
08:27:14 <pikhq> > zipWith (&&) [True,False,True] [False,True]
08:27:15 <lambdabot>   [False,False]
08:27:44 <MyCatVerbs> @type getZipList
08:27:45 <lambdabot> forall a. ZipList a -> [a]
08:28:52 <pikhq> @src ZipList Monad
08:28:52 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:29:04 <pikhq> @src ZipList (>>=)
08:29:04 <lambdabot> Source not found. :(
08:29:14 <pikhq> ...
08:34:21 <Philonous> Is there a newer haskell mode for emacs than the version from Dec 2007=
08:34:23 <Philonous> ?
08:35:23 <lilac> pikhq: ZipList is not a monad
08:35:28 * jmcarthur_work currently has 2.4
08:35:33 <jmcarthur_work> dunno when that is from
08:35:49 <BONUS> i thought infinite ziplists were a monad
08:35:56 <BONUS> and only finite lists were a monad
08:36:04 <lilac> infinite ones are, but ZipList supports finite values
08:36:17 <BONUS> yeah true
08:36:24 <pikhq> lilac: Aaaw.
08:36:27 <jmcarthur_work> ZipStream
08:36:29 <jmcarthur_work> weeee!
08:36:57 <pikhq> That would explain why ZipList doesn't have a monad instance, at least.
08:37:07 <lilac> (also, pedantically, there's no correct Monad instance for ZipList which gives rise to the ZipList Applicative instance)
08:37:15 <Philonous> jmcarthur_work: That one seems to be from 02/2008
08:37:35 <lilac> there /is/ a law-abiding Monad instance possible for ZipList since it's isomorphic to [] ;-)
08:38:58 <jmcarthur_work> the stream monad results in the same applicative though, doesn't it?
08:39:09 <jmcarthur_work> intuitively, to me, it would
08:39:27 <jmcarthur_work> it just wouldn't obey the monad laws for possibly-finite lists
08:39:41 <Zeiris> Suppose I want to write a game that uses a large bitmap image as a map, and does a lot of pixel testing for pathing and significant amounts of writing (think Liero and other old DOS games like it). How would I do this in Haskell efficiently?
08:40:27 <jmcarthur_work> Zeiris, so you mean there is a lot of mutation?
08:41:16 <Zeiris> Yes, significant amounts.
08:41:55 <jmcarthur_work> what exactly is being mutated? i am not familiar with the example game you mentioned
08:42:31 <Ytinasni> platformer, but the world is initially 99% solid, and destroyable.
08:42:55 <jmcarthur_work> the straightforward way would be to use a mutable array, of course, but there is often a better way
08:43:10 <jmcarthur_work> oh, okay, the world itself is mutable
08:44:10 <lilac> jmcarthur_work: liero is a game somewhat like worms
08:44:27 <lilac> Zeiris: use a mutable unboxed array
08:44:38 <lilac> STUArray or IOUArray
08:45:55 <pao> is HughesPJ the "state of art" of pretty printing? is there any other nice alternative worth looking?
08:46:29 <jmcarthur_work> does the world *constantly* change, or just (on average) every <some high number of> seconds. if the latter, it's probably not too inefficient to just make a new copy each time the world is mutated
08:46:52 <Zeiris> Well, changes are likely to happen in bursts and be localized.
08:46:57 <jmcarthur_work> where "high number" can still be low, i guess
08:47:14 <Zeiris> So I guess caching them is an option, and splitting the image up in a grid.
08:48:15 <jmcarthur_work> coming up with the perfect implementation for these things can take a lot of work in haskell. usually you can tell if what you are doing is the wrong approach though
08:48:27 <jmcarthur_work> s/implementation/design/
08:48:35 <mikesteele81_> Zeiris: You may be interested in tho Monao project, which is a Super Mario Brothers clone.  Monao uses a list of lists to represent the game world.  http://github.com/mokehehe/monao/tree/master
08:48:52 <jmcarthur_work> eek, i don't think a list of lists would be ideal for this one
08:49:11 <Zeiris> I'll think it over on the bus - thanks for the feedback :)
08:49:13 <LeoD> monao uses a tile-based world though, i don't think a list of lists is a good idea if you have thousands of pixels
08:49:32 <Zao> Sounds like it would get more costly the further to the right you move.
08:49:39 <Ytinasni> LeoD: probably *millions* of pixels.
08:49:43 <Zao> However, SMB1 didn't allow backtracking, so you can discard the init :)
08:49:59 <Zao> So you'd only have a screenful or so of evaluated thunks at once. That's brillian :)
08:50:00 <LeoD> well i'd vote for IO(U)Array anyway
08:50:10 <Vanadium> U?
08:50:14 <jmcarthur_work> Zeiris, perhaps you could use an immutable array and a set of "changes" to it. during the animations you just change the changes, and you apply them at render time. once the animation is done you just make a new immutable array to replace the old one
08:50:19 <LeoD> Vanadium: unboxed
08:51:09 <lilac> Zeiris: it might be worth your while splitting the play area up into tiles, and having special 'all empty' and 'all full' values for tiles
08:51:49 <lilac> that might save you a bit of memory at least, and make collision detection against empty tiles easier
08:54:20 <pstickne> Zeiris:  I believe the old-old DOS games simply used and tested the video buffer/memory, which was very fast.
08:55:28 <lilac> these days reading video ram is slow :-(
08:55:32 <pstickne> Zeiris:  as lilac pointed out, you could use various tiling approaches (imagine a bunch of squares, each cut up into quads, like a fractal). It won't save memory, but depending on usage pattern, could save a check to the backing-store, provided that such a check was slow or checks could be arranged in such a way.
08:55:56 <pstickne> err, it might not save memory I guess ... depends how the backing is allocated
08:57:11 <lilac> i would guess that Worms 2 and the like have an in-memory 1-bit bitmap and a separate in-vram background image
08:57:13 * pstickne wonders what overhead the FFI in haskell carries
08:57:34 <pstickne> lilac:  sounds fair
08:57:46 * pstickne first thought of Chopper and Lemmings :-)
08:58:18 <lilac> i wonder how lemmings 3d handles it. csg, i guess
08:59:21 <soupdragon> lemmings 3D doesn't let you dig like you can it lemmings 2D
08:59:56 <soupdragon> iirc ..
09:00:06 <lilac> oh. that's disappointing
09:00:24 <soupdragon> 3D adaptations usually are
09:00:34 <Rembane> 3D-digging would be awesome
09:00:38 <soupdragon> I think that red faction and worms 3D let you dig
09:02:26 <lilac> i was utterly disappointed by sonic 3d iirc
09:03:06 <Rembane> Nice.
09:19:32 <Baughn> @type (<*)
09:19:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
09:19:55 <Baughn> > [1..4] <* [10,20,30]
09:19:56 <lambdabot>   [1,1,1,2,2,2,3,3,3,4,4,4]
09:20:35 <Baughn> @src (<*)
09:20:35 <lambdabot> (<*) = liftA2 const
09:21:39 <quicksilver> it's like (>>) but returns the first not second result.
09:21:57 <quicksilver> fmap fst . liftA2 (,) if you like
09:23:28 <pikhq> > [1..4] >> [10,20,30]
09:23:29 <lambdabot>   [10,20,30,10,20,30,10,20,30,10,20,30]
09:23:35 <pikhq> Whee.
09:23:46 <jmcarthur_work> > [10,20,30] >> [1..4]
09:23:47 <lambdabot>   [1,2,3,4,1,2,3,4,1,2,3,4]
09:24:10 <jmcarthur_work> huh, not the same as flip (<*)
09:24:15 <quicksilver> no, definitely not.
09:24:20 <quicksilver> it still does effecgts left to right
09:24:29 <quicksilver> it just returns a different result.
09:25:30 <jmcarthur_work> makes perfect sense but i did not realize it before so now i wonder if i have used it wrong anywhere
09:26:46 <CalJohn> Is it correct to think that f $! a will evaluate a and everything about a?
09:26:59 <jmcarthur_work> weak head normal form
09:27:04 <jmcarthur_work> not deep evaluation
09:27:51 <jmcarthur_work> > head $! 1:undefined
09:27:52 <lambdabot>   1
09:28:27 <Elly> google 'recursion' :)
09:28:32 <jmcarthur_work> > const 5 $! undefined
09:28:33 <lambdabot>   * Exception: Prelude.undefined
09:29:45 <Saizan_> > const 5 $! [undefined]
09:29:46 <lambdabot>   5
09:29:47 <CalJohn> Elly: i understand recursion, i just don't know what this evalution does
09:30:11 <Saizan_> $! which uses seq, evaluates only up to the outermost constructor
09:30:24 <Saizan_> if you want full evaluation you can use Control.Parallel.Strategies.rnf
09:30:48 <Saizan_> you might need to make an NFData instance for your datatype
09:31:33 <Saizan_> oh, and rembember that evaluation will happen only if/when you demand the result of f
09:32:00 <Elly> CalJohn: google search the word 'recursion'. Note suggested correction. Laugh quietly to yourself.
09:32:21 <CalJohn> Elly: oh, heh
09:32:24 <CalJohn> :D
09:33:36 <CalJohn> ok, I understand the evaluation issue.  thanks :)
09:33:39 <SamB> Elly: oh ... let me guess
09:33:42 <SamB> it's "recursion"
09:34:13 <Elly> SamB: how did you know!? :P
09:34:17 <Beelsebob> hamishmack: thanks, it's much improved, is there a bug database I can use to add a few more things that would make it a lot nicer under OS X?
09:34:18 <lambdabot> Beelsebob: You have 1 new message. '/msg lambdabot @messages' to read it.
09:34:27 <Beelsebob> @messages
09:34:27 <lambdabot> vav said 39m 55s ago: leksah-0.6.* versions have window detach functionality, although it's a little quirky, and I've never tried with OSX, barely with linux.
09:34:30 * SamB wonders if he remembered that or if he just figured it out based on the "dictionary definition"
09:38:39 <ray> yo dawg we herd you like recursion so we put some recursion in your recursion so you can blow the stack while you realize there's no base case
09:38:46 <Tordmor> I've written my first haskell program: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3077#a3077 What do you think? Am I on the right track?
09:38:59 <benmachine> you are writing haskell so by default yes
09:39:06 <Tordmor> :)
09:39:36 <Tordmor> maybe it's still a bit python-ish
09:39:39 <EvilTerran> Tordmor, it's very nicely laid-out
09:39:44 <tommd> Tordmor: At first glance that looks good.
09:39:46 <Beelsebob> Tordmor: looks much better than many beginners codes
09:39:50 <tommd> Tordmor++
09:39:51 <EvilTerran> hangman is inevitably very imperative
09:39:52 <Beelsebob> it's much more functional than most
09:40:01 <Tordmor> thanks
09:40:37 <pikhq> Seems quite reasonable.
09:40:46 <EvilTerran> Tordmor, one thing to note is that function application (the ' ' in "f x") binds tighter than any operator
09:40:47 <ray> i saw "tries" and got excited, but there's not a single trie
09:41:21 <gwern> ray: maybe 'blow the base case'?
09:41:37 <gwern> a good yo dawg uses as many words in multiple senses as possible
09:41:39 <ray> well, there is no base case
09:41:58 <EvilTerran> Tordmor, so you can write "Game word (toLower guess : guessed)", "if lost stat' || won stat'", etc
09:42:02 <Beelsebob> Tordmor: I'd write the IO code a little less imperative styley... stat <- game . ((flip Game) []) <$> choice . lines <$> readFile "handman.txt"
09:42:31 <Beelsebob> for that reason though, I'd switch around the arguments in Game
09:42:34 <Beelsebob> so you didn't need the flip
09:42:40 <ray> i am not very good with yo dawg
09:42:44 <Beelsebob> oh, those fmaps should be binds
09:42:44 <Beelsebob> oops
09:42:55 <EvilTerran> Tordmor, the only other thing i'd mention is that there's a few places you could make it look neater (in my opinion, anyway) with $
09:43:05 <EvilTerran> and (.)
09:43:26 <EvilTerran> Tordmor, "x <- getStdRandom $ randomR (1, length a)", for instance
09:43:26 <Beelsebob> stat <- game . Game [] =<< choice . lines =<< readFile "hangman.txt"
09:43:28 <gwern> ray: that'd be using 'blow it' as in mess up - 'yo, he really blew writing the base case', 'I hope I don't blow it'
09:43:33 <Tordmor> EvilTerran, Beelsebob: thanks I'll look into it
09:44:59 <lilac> Tordmor: i'd implement wrong and hidden in terms of another function (since they're doing basically the same thing)
09:45:35 <Tordmor> lilac: right. I noticed that but somehow failed to do it.
09:45:37 <lilac> Tordmor: i'd also do it with length and filter rather than with foldr :)
09:45:50 <EvilTerran> or with length and a list comprehension
09:45:52 <ray> is there some way you could shove a trie into it? :(
09:45:52 <Tordmor> another good thing :)
09:46:47 <ray> maybe if it were nondeterministic hangman you could
09:47:01 * lilac wrote a nondeterministic hangman the other day
09:47:06 <Tordmor> ray: If you find out how I'll think about it :)
09:47:13 <lilac> i'm trying to make an optimally cheating hangman
09:47:26 <lilac> (that maximizes the minimum number of wrong guesses)
09:47:32 <vav> Tordmor: choice starting with !! 1 is intentional?
09:47:35 <vav> > [0..5] !! 1
09:47:36 <lambdabot>   1
09:47:42 <Tordmor> hmm
09:47:47 <jmcarthur_work> lilac, so evil
09:48:15 <Tordmor> vav: no, was not intentional. thanks
09:48:37 <lilac> jmcarthur_work: yeah :)
09:49:38 <ray> yo dawg i herd you like base cases so we put a base case in your infinite recursion so you can return while you return while you return while you return while you return...
09:50:04 <EvilTerran> ?type randomRIO
09:50:05 <lambdabot> forall a. (Random a) => (a, a) -> IO a
09:50:06 <lilac> i have it saying "no" if there are /any/ possible words which don't contain the guessed letter, but it's actually a bit easy like that
09:50:10 <EvilTerran> Tordmor, you could also use randomRIO ^
09:51:05 <lilac> @hoogle [a] -> IO a
09:51:06 <lambdabot> Prelude head :: [a] -> a
09:51:06 <lambdabot> Prelude last :: [a] -> a
09:51:06 <lambdabot> Data.List head :: [a] -> a
09:51:42 <EvilTerran> lilac, unfortunately, there's no "pick a random element from the list"
09:52:03 <ray> lilac: i was thinking just pick 20 or so possible words
09:52:03 <lilac> that's a pity
09:52:37 <ray> @hoogle RandomGen g => g -> [a] -> a
09:52:37 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
09:52:38 <lambdabot> Control.Parallel par :: a -> b -> b
09:52:38 <lambdabot> Control.Parallel pseq :: a -> b -> b
09:53:48 <ray> there's fromList in MonadRandom
09:55:41 <lilac> @type let choose (x:xs) = go x 1 xs where go x _ [] = return x; go x n (y:ys) = do k <- randomRIO (0,n); go (if k == 0 then y else x) (n+1) ys in choose
09:55:42 <lambdabot> forall t. [t] -> IO t
09:56:28 <lilac> hmm, i think that's not strict enough
09:56:35 <jmcarthur_work> so much IO :(
09:56:49 <lilac> @type let choose (x:xs) = go x 1 xs where go x _ [] = return x; go x n (y:ys) = do k <- randomRIO (0,n); (if k == 0 then go y else go x) (n+1) ys in choose
09:56:50 <lambdabot> forall t. [t] -> IO t
09:56:52 <lilac> better
09:57:40 <jmcarthur_work> a (Reader word / State guessed) monad would be nice to have
09:57:41 <Tordmor> that takes some time to read ...
10:00:16 <jmcarthur_work> little games like this are excellent candidates for things like MonadPrompt, which adds some complexity but makes it more testable since it keeps IO out of the core of the monad
10:00:37 <jmcarthur_work> being a beginner, i don't know that i would recommend all those things
10:00:43 <jmcarthur_work> *for you
10:01:01 <jmcarthur_work> i only mention them so that you are aware that there are some nice ways to abstract out a lot of the duplication and IO
10:01:09 <jmcarthur_work> in the future
10:01:25 <jmcarthur_work> for larger programs, especially
10:02:18 <ray> no dumbing down haskell! let's talk about zygohistomorphic prepromorphisms
10:02:31 <copumpkin> yeah, and get rid of the damn if expression
10:02:40 <copumpkin> makes it too easy for newbies
10:02:54 <copumpkin> (to do it wrong)
10:03:10 <pikhq> Get rid of the names for literals.
10:03:19 <copumpkin> one = 1
10:03:21 <copumpkin> two = 2
10:03:22 <copumpkin> ?
10:03:27 <copumpkin> or 1 = 1
10:03:29 <pikhq> "foo = bar" is evil and wrong.
10:03:33 <copumpkin> :P
10:03:47 <pikhq> foo x y = x+y? NO!
10:04:00 <copumpkin> how about foo x y = x + y + 0
10:04:01 <pikhq> You should have to write out your damned lambdas all the time!
10:04:20 <pikhq> Nope. (\x y->x+y+0).
10:04:28 <ray> no
10:04:30 <pikhq> And (+) only gets a free pass because it's a constructor.
10:04:31 <ray> (+) is a name
10:04:37 <copumpkin> it isn't
10:04:42 <ray> church numerals required
10:04:53 <pikhq> ray: Yes. Yes! YES!
10:04:57 <ray> yeah also it isn't, which is why everyone hates n+k patterns
10:05:13 <pikhq> Oh.
10:05:33 <pikhq> Well, we could have Peano numerals instead.
10:06:06 <dansa> what's a Peano numeral?
10:06:24 <copumpkin> an inefficient number that's easy to reason about
10:06:29 <mux> hahah
10:06:31 <soupdragon> 0 is a Peano numeral
10:06:40 <mux> copumpkin: I love that definition.
10:06:50 <soupdragon> if n is a Peano numeral so is S n
10:06:52 <copumpkin> :)
10:07:04 <jmcarthur_work> it's not inefficient for a lot of things
10:07:17 <dansa> *that* definition seems to imply that numerals are numbers
10:07:20 <dansa> :)
10:07:22 <copumpkin> it just happens to have O(value) representation
10:07:28 <jmcarthur_work> comparing the lengths of two lists, for example
10:07:32 <jmcarthur_work> using genericLength, anyway
10:07:35 <copumpkin> whereas most numbers have O(log(value))
10:07:40 <copumpkin> yup
10:07:42 <ray> it's pretty damn efficient for taking the successor of a number
10:07:49 <jmcarthur_work> heh
10:07:53 <mux> but O(n) addition makes the baby jesus cry
10:07:58 <pikhq> ray: Similar to church numerals.
10:08:02 <copumpkin> O(n) space also makes jesus cry
10:08:07 <pikhq> mux: Baby Jesus hates Brainfuck.
10:08:25 <copumpkin> at least BF stores numbers efficiently
10:08:32 <copumpkin> let's do RSA in peano!
10:08:42 <pikhq> Sure, but addition is still O(n).
10:08:43 <jmcarthur_work> excellent idea
10:09:01 <MyCatVer1s> mux: Er, addition is O(n).
10:09:03 <copumpkin> maybe I'll do that as a joke package
10:09:05 <pikhq> And division is O(n^OHGODIDONTWANTOTHINKABOUTIT)
10:09:11 <ray> when we want a slow hash function, we should just use peano numbers
10:09:15 <copumpkin> type-level-asymmetric-crypto
10:09:30 <ray> slow hash functions are very often desirable
10:09:36 <mux> MyCatVer1s: sorry? this is what we said
10:09:47 <copumpkin> ray: not slow in a way that's directly proportional to its value :P
10:09:47 <MyCatVer1s> mux: Nope. :)
10:09:48 <ray> the problem is someone would just reimplement it to use faster numbers :(
10:09:49 <jmcarthur_work> ray, sure, but that doesn't help if somebody gets a hold of the hash and can brute force it locally
10:09:51 <pikhq> (man, division via iterated subtraction)
10:09:54 <jmcarthur_work> yeah that
10:10:08 <MyCatVer1s> mux: Addition by incrementing and decrementing is O(2^n). Remember that n is measured in the number of bits in the input word, not the magnitude of the number itself.
10:10:15 <copumpkin> ray: generally you want slow constant-time operations :P
10:10:35 <MyCatVer1s> mux: Bitwise addition (as it's done in practice) is actually linear in cost.
10:10:49 <copumpkin> linear in the number of bits
10:11:03 <copumpkin> which is logarithmic in the value
10:11:44 <Nafai> shapr1!
10:11:46 <mux> I bet that ghc is going to overflow before RSA type-checking is done
10:11:52 <MyCatVer1s> copumpkin: the only people who measure complexity of operations on numbers by the numbers' values instead of their size are naive undergrads, yo.
10:11:59 <copumpkin> lol
10:12:15 <opqdonut> using the logarithm for complexity parameter is hardly appropriate for peano numerals
10:12:17 <copumpkin> or people working on peanos
10:12:26 * copumpkin is a peanist
10:12:27 <copumpkin> har har
10:12:28 <shapr1> Nafai!
10:12:43 <shapr1> I'm on the train, on the way to Hac phi!
10:13:06 <Nafai> Sweet!
10:15:02 <ray> but it's a logarithm base 2, which is why we should start using trinary cpus
10:15:26 <mux> I'm putting my money on q-bits
10:16:03 <mux> maybe we can implement efficient peano arithmetic with quantum processors
10:16:54 <ray> i'm not sure even nondeterminism would help peano arithmetic's efficiency
10:17:14 <shapr1> 4IV Li7
10:17:17 <a_guest> if 'build-type' in .cabal file is 'Simple', do I need a 'Setup.hs' file to install packages (runhaskell Setup configure etc.)
10:17:21 <a_guest> ?
10:17:42 <Saizan_> a_guest: no if you have cabal-install
10:17:42 <shapr1> Um, isn't there a hac phi irc channel?
10:17:44 <mux> a_guest: not really, but you'd need cabal-install; in practice we still have a Setup.hs file in that case
10:17:51 <dcoutts_> a_guest: if you use 'cabal' instead of 'runhaskell Setup' then you do not
10:18:19 <dcoutts_> a_guest: "runhaskell Setup" requires that there be a Setup.hs or .lhs file, otherwise there's nothing for runhaskell to run! :-)
10:18:39 <shapr1> aha #haskell-hacphi
10:18:56 <a_guest> dcoutts_: that was what I thougt.
10:19:20 <a_guest> what is a .lhs file?
10:19:23 <copumpkin> literate haskell
10:19:39 <a_guest> what is literate haskell?
10:19:49 <lesshaste> sorry about this but when I start Cnf.hs it drops me into "Prelude Cnf"
10:19:59 <copumpkin> haskell where the comments are the default and the code is relegated to delimited areas
10:20:05 <lesshaste> how do I get out of that and actually ask it to evaluate scnf "(P->Q)&(R->S))->((PvR)->(QvS))"
10:20:06 <mux> a weird way to write haskell code, where everything is a comment by default, and you introduce code via specific espace sequences
10:20:10 <lesshaste> for example
10:20:42 <dcoutts_> a_guest: it's good when you want to thoroughly document your code
10:20:53 <dcoutts_> or write an article with code snippets
10:22:29 <a_guest> so the usual way to install packages is using 'cabal-install'?
10:23:21 <mux> cabal install takes care of dependencies, and does everything in one go, so it's much more convenient
10:24:02 <dcoutts_> a_guest: the command line is just 'cabal'. Confusingly the package that provides it is called cabal-install
10:24:16 <dcoutts_> historical accident
10:24:38 <mux> you don't intend to push it into Cabal some day?
10:25:30 <dcoutts_> mux: no, the longer term plan is to split the Cabal lib into bits. Separating the build system from the declarative stuff
10:25:45 <mux> okay
10:25:58 <mux> is cabal-install in the haskell platform?
10:26:04 <dcoutts_> mux: yes
10:26:09 <mux> nice
10:26:12 <dcoutts_> mux: and at that time there's the opportunity to rename things, eg Cabal -> cabal-lib + cabal-build; cabal-install -> cabal.
10:26:22 * mux nods
10:29:23 <Daimonic> :t unfold
10:29:25 <lambdabot> Not in scope: `unfold'
10:29:36 <Tordmor> a_guest: lhs is something like this: http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
10:37:45 <voker57_> :t unfoldr
10:37:46 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:42:11 <pikhq> Tordmor: That is a nice sudoku solver.
10:43:16 <drhodes> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7392#a7392
10:43:26 <drhodes> dealing with nested state
10:43:50 <soupdragon> drhodes what
10:43:58 <drhodes> I'm not sure the state monad is appropriate for that or not
10:44:19 <Tordmor> pikhq: I found it with stumble upon. It's a good tutorial
10:44:22 <soupdragon> drhodes are you trying to write a function that does that?
10:44:46 <drhodes> no I'm seeking general advice on how to deal with nested state.
10:44:46 <kfranke> ok, dumb question: how do you delete an item from a list by index? (deleteFunctionINeed 1 "Hello" -> "Hllo")
10:44:54 <soupdragon> drhodes, I don't understand..
10:45:06 <pikhq> Tordmor: Great example of literate programming.
10:45:57 <drhodes> soupdragon: that's ok :)
10:46:40 <soupdragon> drhodes, I thought you pasted that here cause you wanted some advice about it or somedhing
10:47:24 <soupdragon> drhodes, why did you paste it?
10:48:30 <drhodes> soupdragon: It's a simple example of nested state ..
10:48:39 <soupdragon> drhodes, I don't agree
10:48:52 <soupdragon> drhodes, nothing about it is 'state'
10:49:04 * drhodes bangs head on desk
10:49:22 <soupdragon> now were getting somewhere
10:50:02 <pikhq> drhodes: There is no state there. None at all.
10:50:41 <soupdragon> drhodes, you should explain it
10:51:45 <soupdragon> rather than going "that's ok :)" which is a bit rude
10:55:42 <drhodes> I've been trying to ask this question for a long time.
10:56:06 <drhodes> it's frustrating.
10:56:08 <pikhq> ... And you're asking your question poorly.
10:56:11 <otulp> Keep at it. Eventually, you'll find your question.
10:56:20 <drhodes> heh
10:56:33 <pikhq> What's frustrating is seeing someone asking "Help! State! Constructor! Switch!"
10:56:55 <soupdragon> drhodes, You're not trying to write any function?
10:57:34 <Taejo> If somebody's looking for a nice project combining parsec (or some other parsing lib) and diagrams, something like http://web.meson.org/pyBlazon/ would be cool -- parse blazons (formal descriptions of coats of arms) and produce pictures of them
10:59:41 <otulp> drhodes: Could it be that you're trying to understand function pattern matching syntax, not state?
10:59:58 <drhodes> the trivial decompose with accessors and rebuild manually is not what I'm looking for.  Rather, to build a higher order mechanism to handle the peeling away of layers and rebuilding
11:00:43 <soupdragon> drhodes, so you are trying to write a function?
11:00:57 <drhodes> well everything's a function, so yeah
11:01:20 <soupdragon> okay
11:01:26 <soupdragon> what does it do?
11:01:45 <Taejo> drhodes: if you're looking for a *framework* for writing such functions, you might be interested in conal's semantic editor combinators (http://conal.net/blog/posts/semantic-editor-combinators/)
11:02:08 <Taejo> or the data-accessor library: http://hackage.haskell.org/package/data-accessor
11:02:46 <conal> drhodes: "everything's a function" is a popular misconception about functional programming.
11:03:33 <PeakerWork> swap :: Data.Accessor a b -> Data.Accessor a b -> a -> a -- swaps between the two b's inside a
11:03:35 <conal> sure one can wrap up everything as a function, but one could also wrap up everything as a list, and Either, or a 13-tuple.
11:04:18 <PeakerWork> drhodes: that's one possible answer to your dillema
11:04:22 <BMeph> I blame the "everything's an object" knuckleheads, trying desparately to make it a meme, instead of the dumb saying that it is. :\
11:04:27 <drhodes> PeakerWork: that's exactly it thank you
11:04:42 <PeakerWork> drhodes: Do you know Data.Accessor?
11:04:42 <ray> everything's a meme
11:04:59 <drhodes> I took a look at it a couple months ago PeakerWork
11:05:08 <soupdragon> everything's an object is true BMeph
11:05:12 <drhodes> or last year, I've been on haskell leave
11:05:19 <lament> soupdragon: obviously you aren't a Taoist
11:05:22 <PeakerWork> drhodes: If Haskell records didn't suck, the names inside them would be Accessors to the values of the record, rather than getters
11:06:02 <BMeph> "Everything" is everything. It's not something else.
11:06:11 <conal> BMeph: my guess is that people hear it and don't give it much thought.  the typical explanation always strikes me as a way to hang onto the belief rather than to arrive at it.
11:07:12 * BMeph is a faithful member of the "The Map is Not the Territory" church.
11:07:15 <SamB> what about the "everything's a file" knuckleheads?
11:07:45 <liyang> ray: yes, but Milhouse is not a meme.
11:07:48 <soupdragon> haha
11:07:51 <mmorrow> sudo cat /dev/mem | od
11:07:54 <mmorrow> wee
11:07:57 <SamB> or aren't you guys talking about smalltalk/Python/Java ?
11:08:03 <pikhq> SamB: If UNIX actually did that, that'd be great.
11:08:07 <ray> but "milhouse is not a meme" is a meme
11:08:07 <SamB> pikhq: I know!
11:08:15 <soupdragon> everything's a file, everything's an object. ... you're wrong, everything's an interpreter
11:08:18 <liyang> ray: OH SHI-
11:08:21 <pikhq> <3 Plan 9
11:08:25 <SamB> oh, sweet plan9, how I long for the with a nicer UI
11:08:28 <SamB> darn it
11:08:30 <soupdragon> no no everything is _____
11:08:40 <soupdragon> everything is everything
11:08:43 <SamB> soupdragon: you've been listening to PoppaVic too much!
11:08:48 <liyang> everything is not what you think it is.
11:09:16 <badsheepy> subjectively it is :p
11:09:16 <ray> > fix ("everything is " ++)
11:09:18 <lambdabot>   "everything is everything is everything is everything is everything is ever...
11:09:56 <Saizan_> initial inductive vs. final coinductive, both are nice to have
11:10:45 <copumpkin> > fix ("to understand recursion, you must first understand \"" ++)
11:10:47 <lambdabot>   "to understand recursion, you must first understand \"to understand recursi...
11:10:56 <copumpkin> damn
11:11:20 * BMeph wonders what would happen if we locked the Haiku folks and the Inferno folks in a conference room for a year...
11:11:21 <liyang> copumpkin: http://www.google.co.uk/search?q=recursion
11:11:26 <copumpkin> yeah :)
11:11:37 <ray> > text $ fix ("to understand recursion, you must first understand \"" ++)
11:11:42 <lambdabot>   mueval-core: Prelude.read: no parse
11:11:42 <copumpkin> now everyone's making dumb recursion jokes
11:11:42 <lambdabot>  mueval: ExitFailure 1
11:11:50 <lilac> BMeph: are you into NLP?
11:11:52 <ray> you've failed me, text
11:12:07 <copumpkin> > text . take 100 $ fix ("to understand recursion, you must first understand \"" ++)
11:12:08 <lambdabot>   to understand recursion, you must first understand "to understand recursion...
11:12:45 <athos> haha
11:12:45 <athos> :>
11:12:52 <ray> this could all have been avoided if you used french and «
11:13:17 <athos> @type text
11:13:19 <lambdabot> String -> Doc
11:13:46 <mmorrow_> , fix show
11:13:49 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\...
11:17:47 <BMeph> lilac: Not at all. Not even the ones I speak. ;p
11:18:31 <soupdragon>  <copumpkin> now everyone's making dumb recursion jokes
11:18:33 <soupdragon> hahahaha
11:18:43 <mikesteele81_> @type fix
11:18:44 <Taejo> <soupdragon>  <copumpkin> now everyone's making dumb recursion jokes
11:18:45 <lambdabot> forall a. (a -> a) -> a
11:18:52 <soupdragon> yeah nobody ever did that every day for years
11:18:52 <copumpkin> oh god :P
11:20:31 <copumpkin> bbl
11:23:53 <azathoth99> is haskell good for making interactive apps?
11:24:04 <azathoth99> I know happstack is tuff
11:24:09 <azathoth99> I am going to learn haskell first
11:24:50 <lament> i don't think there's any language that's good for making interactive apps
11:24:51 <soupdragon> azathoth99 lol
11:26:34 --- mode: ChanServ set +o mauke
11:26:34 --- mode: mauke set +b *!*@w005.z209031033.sjc-ca.dsl.cnc.net
11:27:04 <soupdragon> aw mauke they make me laugh
11:27:34 --- mode: mauke set -o mauke
11:28:43 <RayNbow> hmm, interesting... you need msys to cabal install darcs under Windows...
11:29:05 <Botje> hey, azathoth is back!
11:29:19 <mauke> @protontorpedo
11:29:20 <lambdabot> so is haskell going to redo x windows and make it better?
11:29:23 <mauke> @protontorpedo
11:29:24 <lambdabot> what echniques can be used to scael application in haskell?
11:29:49 <soupdragon> I wish lambdabot could grep #haskell
11:30:34 <jmcarthur_work> has azathoth99 been trolling or something?
11:30:37 <FliP^2eH> Say I'm getting sent a RAW binary integer, not as ASCII but as single bytes. How do I use them in Haskell?
11:30:41 <lilac> @@ @@ @run let a = "@@ @run let a = in text $ take 16 a ++ show a ++ drop 15 a" in text $ take 16 a ++ show a ++ drop 15 a
11:30:43 <lambdabot>     <no location info>:
11:30:43 <lambdabot>      lexical error in string/character literal at end o...
11:31:00 <mauke> jmcarthur_work: oh yes
11:31:01 <mmorrow> FliP^2eH: Data.Binary or similar
11:31:11 <lilac> hmm, that one only works in privmsg :(
11:31:24 * lilac needs a shorter quine
11:32:03 <mauke> @Unknown command, try @list
11:32:04 <lambdabot> Unknown command, try @list
11:36:15 <lilac> @@ @@ @run let a="@@ @run let a=in text$take 14 a++show a++drop 14 a" in text$take 14 a++show a++drop 14 a
11:36:18 <lambdabot>     <no location info>: parse error (possibly incorrect indentation)
11:37:07 <soupdragon> @@
11:37:41 <lilac> @@ @@ @run let a="@@ @run let a=in evil a" in evil a
11:37:56 <lambdabot>                       thread killed
11:38:14 <jeffwheeler> @@?
11:38:15 <lilac> yo dawg we herd you liked recursion so we put lambdabot evaluation in your lambdabot evaluation in your lambdabot evaluation in your
11:38:22 <lilac> thread killed
11:38:56 <bremner> yo dawg we herd you liked yo dawg...
11:38:57 <lilac> @@ @djinn @type maybe
11:38:59 <lambdabot>  f a b c =
11:38:59 <lambdabot>     case c of
11:38:59 <lambdabot>     Nothing -> a
11:38:59 <lambdabot>     Just d -> b d
11:40:29 <soupdragon> @Source not available @Source not
11:40:30 <lambdabot> not available @Source not not available
11:42:41 <Daimonic1> I am trieing to build length with foldl, but I came with no idea yet, any hints or adivces? =)
11:43:26 <mauke> well, try to make it work on empty lists first
11:43:50 <Daimonic1> ok
11:43:54 <benmachine> why foldl?
11:44:06 <mauke> why not?
11:44:17 <benmachine> fair enough
11:44:37 <soupdragon> @Mab e you meant: faq map
11:44:38 <lambdabot> Maybe you meant: faq map
11:45:04 <benmachine> @map
11:45:04 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
11:45:11 <benmachine> oh, that kind of map :P
11:45:35 <benmachine> (404 :()
11:45:49 <benmachine> http://www.haskell.org/haskellwiki/HaskellUserLocations
11:46:34 --- mode: ChanServ set +o mauke
11:46:34 --- mode: mauke set -b *!*@w005.z209031033.sjc-ca.dsl.cnc.net
11:47:14 <conal> does anyone know how to run an os x app (foo.app) from a shell? i try "path/to/foo.app" and get "path/to/foo.app: is a directory"
11:47:19 <mercury^> Daimonic1: length = foldl (const.(+1)) 0
11:47:34 <benmachine> conal: open foo.app
11:47:34 --- mode: mauke set -o mauke
11:47:58 <benmachine> (open <path> is more or less equivalent to double clicking on <path> in the finder)
11:48:00 <Daimonic1> mercury^: thanks :o)
11:48:04 <soupdragon> conal: or path/to/foo.app/Contents/Resources/MacOS/<binary>
11:48:18 <soupdragon> for gdb et
11:48:21 <soupdragon> etc*
11:48:27 <lilac> @Maype you meant: faq map
11:48:28 <lambdabot> [Char]
11:48:35 <conal> benmachine: soupdragon: thx!  new OS.  so much to learn.
11:48:38 <soupdragon> @Maype you meant: [Char]
11:48:39 <lambdabot> Not in scope: data constructor `Char'
11:48:42 <soupdragon> :(
11:49:12 <Daimonic1> benmachine: because its the task
11:50:41 <ac> is there an llvm IRC channel?
11:50:52 <benmachine> ahh, tasks
11:50:55 * benmachine gets back to his
11:51:22 <mercury^> Daimonic1: actually, foldl (const.succ) 0 is more in the spirit of length, but then the actual length returns Int...
11:51:46 <lilac> @Maype you meant: faq map
11:51:47 <lambdabot> forall (i :: * -> *) lied. [Maybe (i lied)]
11:51:59 <soupdragon> haha
11:52:07 <shapr1> @seen byorgey
11:52:07 <lambdabot> Last time I saw byorgey was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #
11:52:07 <lambdabot> ghc, #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #
11:52:07 <lambdabot> haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #
11:52:07 <lambdabot> xmonad and #yi 1m 21d 14h 1m 10s ago.
11:52:11 <shapr1> eesh
11:52:49 <mercury^> Daimonic1: or not, 0 forces it to be Num already.
11:52:56 <mercury^> I better keep quiet. :<
11:53:20 <Daimonic1> I will make a side-function which maps every element to 0
11:53:30 <mercury^> Huh?
11:53:50 <mercury^> I think you misunderstood what I meant.
11:54:40 <lilac> > let length = sum . map (const 1) in length "Hello world"
11:54:41 <lambdabot>   11
11:55:41 <lilac> > let length = tail . zipWith const [0..] . (undefined:) in length "hello world"
11:55:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
11:55:42 <mercury^> lilac: that's not using foldl and also less efficient on some processors, notably most x86 models.
11:56:40 <lilac> mercury^: why would it be less efficient?
11:56:45 <lilac> > let length = last . zipWith const [0..] . (undefined:) in length "hello world"
11:56:46 <lambdabot>   11
11:57:31 <lilac> with decent fusion i'd hope they'd compile to the same thing
11:57:45 <Daimonic1> oh k
11:57:55 <mercury^> lilac: the solution using sum is, because incrementing can be done with inc, while adding always has to be done with add.
11:58:25 <mercury^> The compiler won't notice that it will only add 1s if you replace the list with a list of 1s.
11:58:31 <mercury^> (I think)
11:59:17 <lilac> mercury^: as i said, any decent fusion rules should merge the map with the sum
11:59:56 <mercury^> Yes, but will sum [1,1..] be compiled efficiently?
12:00:45 <lilac> mercury^: i wouldn't be surprised if there's a rule: foldl f x (map g xs) = foldl (\a -> f a . g) x xs
12:00:47 <drhodes> ac: irc.oftc.net, #llvm
12:01:12 * lilac plays with ghc-core
12:01:21 <mercury^> lilac: that will definitely happen.
12:02:01 <lilac> not at -O0 :-)
12:02:39 <daviddd> Is there any difference between a [Char] and a String?
12:02:57 <mauke> daviddd: no
12:03:12 <daviddd> Thanks
12:03:18 <jmcarthur_work> daviddd, type String = [Char], literally
12:03:30 <ac> drhodes: thanks
12:04:15 <burp> @src String
12:04:15 <lambdabot> type String = [Char]
12:06:18 <mercury^> lilac: to see a difference, you need to look at the assembly when optimizing for size.
12:06:48 <mercury^> probably compiling via C is needed too
12:07:13 <lilac> mercury^: i'm looking at the core right now :)
12:07:35 <tromp_> @pl \s ->                         putStr s>>print s
12:07:35 <lambdabot> liftM2 (>>) putStr print
12:08:11 * SamB suddenly realizes that distributed computing is mostly only useful for NP problems
12:09:08 <jmcarthur_work> ?
12:09:45 <Elly> SamB: how's that?
12:10:08 <SamB> well, you don't really trust random computers on the internet to give you back only right answers?
12:10:27 <Elly> that's not the only kind of distributed computing oO
12:10:37 <jmcarthur_work> clusters are also distributed computing
12:10:40 <SamB> I should have clarified in the @home style
12:10:42 <bos31337> @seen dons
12:10:43 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 1h 49m ago.
12:10:52 <tromp_> :t liftM2
12:10:53 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:11:14 <jmcarthur_work> SamB, could still be useful in cases where the computation is expensive but a correctness test is inexpensive
12:11:28 <SamB> jmcarthur: well, okay, yeah
12:11:32 <tromp_> :t liftM2 (>>) putStr print
12:11:33 <lambdabot> String -> IO ()
12:11:49 <SamB> there *are* cases where that occurs but NP isn't involved ...
12:13:35 <tromp_> :t liftM2
12:13:36 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:13:37 <tromp_> :t ap
12:13:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:17:29 <lilac> mercury^: to be honest, the codegen for both of the non-foldl methods looks really bad :-(
12:18:28 <FliP^2eH> @hpaste
12:18:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:22:08 <lilac> @type \f x y -> y >>= (((x >>= return . f) >>=) . flip id)
12:22:09 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a1 -> a -> m b) -> m a1 -> m a -> m b
12:22:24 <lilac> @@ @type \f x y -> y >>= (((x >>= return . f) >>=) . flip id) :: @type liftM2
12:22:26 <lambdabot>     Inferred type is less polymorphic than expected
12:22:26 <lambdabot>       Quantified type variable `m' is mentioned in the environment:
12:22:26 <lambdabot>         f :: a11 -> a -> (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:24:09 <FliP^2eH> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7394#a7394
12:24:18 <FliP^2eH> This works so far, in that it splits off the first 4 byte (FF FF FF FF)
12:24:23 <FliP^2eH> And it gives me the replyType
12:24:31 <FliP^2eH> But how do I continue, reading all of it?
12:24:55 <FliP^2eH> Don't let me down now, I've formated all that hex by hand :)
12:25:01 <FliP^2eH> Just for you!
12:25:10 <Daimonic1> @src reverse
12:25:10 <lambdabot> reverse = foldl (flip (:)) []
12:26:09 <Daimonic1> @src flip
12:26:09 <lambdabot> flip f x y = f y x
12:28:26 <hackagebot> Tensor 1.0.0.0 - State variables (SvenPanne)
12:28:36 <FliP^2eH> Haskell is too high level :(
12:29:10 <dansa> that makes me smile :)
12:29:27 <FliP^2eH> I just want to read out byte by byte
12:29:42 <FliP^2eH> And be able to use it just like I could do so in D
12:29:42 <dansa> you can compile it to c :)
12:30:14 <dansa> you wanna read a string byte by byte?
12:30:17 <FliP^2eH> f.read();
12:30:22 <FliP^2eH> Is how I'd do it in D
12:30:32 <hackagebot> OpenAL 1.4.0.0 - A binding to the OpenAL cross-platform 3D audio API (SvenPanne)
12:30:33 <pikhq> You don't want to read a string byte by byte.
12:30:38 <dansa> f.read() is very high level :)
12:30:43 <FliP^2eH> I just want to read it ;<
12:30:49 <dansa> hehe
12:30:53 <pikhq> You want to read in a bytestring and iterate over each char in the bytestring.
12:30:56 <FliP^2eH> I'd be happy with i
12:30:56 <FliP^2eH> t
12:30:57 <jmcarthur_work> deserialiseHeader = getWord32be
12:31:01 <jmcarthur_work> replyType = getWord8
12:31:03 <jmcarthur_work> :)
12:31:32 <Saizan> once you've read the file you can use Data.ByteString.tail and .head to get the bytes, no?
12:31:53 <Daimonic1> how about build map with fold?
12:32:07 <FliP^2eH> Why didn't I think about it?
12:32:16 <FliP^2eH> I was about to read it all within runGet
12:32:19 <pikhq> Or perhaps even Data.ByteString.map or fold or something if you want to do something on each byte...
12:32:30 <Daimonic1> @src map
12:32:31 <lambdabot> map _ []     = []
12:32:31 <lambdabot> map f (x:xs) = f x : map f xs
12:32:45 <Saizan> if you can do all the parsing as a single Get action that's even better
12:33:11 <Saizan> because you don't have to thread the string around manually
12:33:13 <pikhq> BTW, "foo >>= return" is the same as "foo".
12:33:33 <hackagebot> ALUT 2.2.0.0 - A binding for the OpenAL Utility Toolkit (SvenPanne)
12:33:34 <Vanadium> Is not~
12:33:39 <Saizan> or you can use something like StateT ByteString IO if you need IO in the middle
12:34:03 <Saizan> m >>= return = m, that's one of the monad's laws
12:34:17 <Vanadium> Then Control.Exception.evaluate's documentation is being a jerk
12:34:25 <Saizan> Vanadium: yes it is
12:35:25 <CalJohn> how is it?  return returns m a
12:35:34 <CalJohn> it might be, i suppose
12:35:56 <jonathanturner> someone mind fielding my newbie question?  I was wondering if monads, as a concept, is like building up a continuation piece by piece, and like a continuation, executing it at a later time
12:36:18 <BMeph> @@ @type \f x y -> y >>= (((x >>= return . f) >>=) . flip id) :: @type (Join .).liftM2
12:36:20 <lambdabot>  parse error on input `in'
12:36:25 <BMeph> @@ @type \f x y -> y >>= (((x >>= return . f) >>=) . flip id) :: @type (join .).liftM2
12:36:27 <lambdabot>  parse error on input `type'
12:36:40 <BMeph> @@ @type \f x y -> y >>= (((x >>= return . f) >>=) . flip id) :: @type ((join .).liftM2)
12:36:42 <lambdabot>  parse error on input `type'
12:36:58 * BMeph sighs
12:37:21 <copumpkin> failmeph
12:37:58 <pikhq> jonathanturner: Sort-of.
12:38:00 <BMeph> jonathanturner: Since continuations are one kind of Monad, that would be a neat trick! ;)
12:38:06 <CalJohn> BMeph: wait, I just saw it myself
12:38:07 <Badger> @src evaluate
12:38:07 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
12:38:26 * CalJohn is an idiot
12:38:53 <jonathanturner> pikhq: can you clue me into what I'm not quite getting?
12:38:59 <BMeph> @type ((join .).liftM2)
12:39:01 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
12:39:01 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
12:39:01 <lambdabot>     In the second argument of `(.)', namely `liftM2'
12:39:34 <hackagebot> Tensor 1.0.0.1 - Tensor data types (SvenPanne)
12:39:40 <pikhq> jonathanturner: Well, that's true of the continuation monad.
12:39:43 <Saizan> jonathanturner: that's quite accurate, in that the second argument to (>>=) can be seen as a continuation
12:39:58 <mmorrow> conal: ping
12:39:58 <pikhq> And you can *sort-of* view the other monads like that.
12:40:25 <Saizan> jonathanturner: i think this article says it best :) http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
12:40:53 <BMeph> pikhq: I think sigfpe wrote about how every monad is writeable using Cont, so I guess it's accurate. :)
12:41:03 <pikhq> BMeph: Oh.
12:41:05 <BMeph> Saizan: Jinx!
12:41:22 <mmorrow> man, GADTs are super painful to use if you want Read on any types they're used in..
12:41:29 <PeakerWork> jonathanturner: >>= chain a monadic value and a continuation, so a whole sequence built from multiple statements bound by  (>>=)  can be seen as a chain of  continuation->Monadic action->Continuation->Monadic action,  which is how Haskell IO, for example, interleaves pure computation with monadic side effects
12:41:34 <BMeph> pikhq: Yeah; Saizan linked the article in question. :)
12:42:04 <jonathanturner> PeakerWork: that's exactly what I was wondering, but wasn't sure if it was just true of the IO monad or of others as well
12:42:07 <copumpkin> mmorrow: yeah :/
12:42:13 <jonathanturner> Saizan: thanks, reading that article now
12:42:22 <Saizan> well, Cont (or more precisely Codensity) is what builds up the chaining of >>=, the effects of each particular monad need more structure
12:42:32 <soupdragon> mmorrow, how so?
12:42:42 * mmorrow 's current hack is to "un-GADT" the definition  and "un-existential" any of those defs used to hide the GADTs types in another file, then run derive -dShow -dRead on that file, then fix up all the instances by hand...
12:42:44 <soupdragon> mmorrow, I think it's dead easy :P
12:43:06 <mmorrow> soupdragon: :o
12:43:13 <mmorrow> soupdragon: given how many hours of tedium?
12:43:15 <soupdragon> un-GADT -- yeah, you must do type erasure
12:43:33 <mmorrow> soupdragon: no, but i only un-GADT to fool derive into generating gobs of code
12:43:42 <mmorrow> then i use the real GADT for Show/Read
12:44:06 <mmorrow> (the Read instance may need to be split apart into an instance for each con depending..)
12:44:40 <mmorrow> it's a lot of busy work to say teh least :)
12:45:02 <soupdragon> I guess you are right
12:45:09 <soupdragon> it could all be automated though
12:45:12 <mmorrow> totally!
12:45:33 <soupdragon> hey you know like
12:45:54 <mmorrow> i've got a half-decent Show deriver at http://moonpatio.com/cgi-bin/gadtshow.cgi
12:45:57 <PeakerWork> > filterM (\x -> if odd x then [True] else [True, False]) [1,2,3]
12:45:58 <lambdabot>   [[1,2,3],[1,3]]
12:46:01 <mmorrow> Read is a bit more work though
12:46:02 <Saizan> does TH have a representation for gadts yet?
12:46:04 <soupdragon> data Exists f where Exists :: f t -> Exists f
12:46:15 <mmorrow> (although i think i see how to do it actually (in the cases where it can be done)
12:46:23 <soupdragon> and
12:46:27 <mmorrow> soupdragon: i'm just doing:
12:46:30 <soupdragon> data Exists2 f where Exists2 :: f u v -> Exists2 f
12:46:31 <mmorrow> err, i'll paste
12:46:35 <soupdragon> and.. Exists3
12:46:38 <soupdragon> etc
12:46:54 <soupdragon> is it possible to make an Exists n using she?
12:48:42 <FliP^2eH> @hpaste
12:48:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:48:44 <mux> woot, tuple sections
12:49:06 <FliP^2eH> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7396#a7396 Help! In the serverName function, how do I read everything as a String?
12:49:09 <soupdragon> mux WHAT?
12:49:16 <mux> http://www.haskell.org/pipermail/cvs-ghc/2009-July/049441.html
12:49:18 <soupdragon> oops didn't mean caps lock
12:49:41 <soupdragon> cool
12:49:43 <Saizan> FliP^2eH: as a String?
12:49:55 <FliP^2eH> Yes, it's a name after all
12:49:59 <FliP^2eH> ByteString is fine, too
12:50:22 <mmorrow> soupdragon, Saizan: so i'm generating these instances e.g. with a lot of hackery http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3078
12:50:28 <Saizan> FliP^2eH: have you looked at Data.Binary.Get ?
12:50:59 <FliP^2eH> Yep
12:51:02 <FliP^2eH> I'm puzzled at least
12:51:33 <mmorrow> soupdragon, Saizan: where hackery := making a scratch module with data decls are are similar enough to those so that the Show and Read instances will be as similar as possible, then running $ derive -dShow -dRead over them, then manually fixing that ouput up by hand
12:52:02 <soupdragon> hmmmmmmm
12:52:05 <mmorrow> i think for Read you can do:
12:52:09 <mmorrow> say you have
12:52:21 <FliP^2eH> I mean those are C style strings, zero terminated
12:52:32 <mmorrow> data Foo a where A :: .... -> Foo Int; B :: .. -> Foo Int; C :: .. -> Foo Double
12:52:46 <mmorrow> you need an instance of Read for each possible `a' in "Foo a"
12:52:55 <mmorrow> that seems simple enough to automate
12:53:20 <mmorrow> (and then just use Data.Derive's existing machinery to generate the code for each of those instances)
12:53:26 <conal> mmorrow: pong
12:53:53 <mmorrow> conal: hey, was wondering if you played around with deriving Read for GADTs any further
12:54:08 <Saizan> FliP^2eH: http://hackage.haskell.org/packages/archive/binary/0.5.0.1/doc/html/Data-Binary-Get.html#v%3AgetLazyByteStringNul
12:54:18 <mmorrow> conal: i'm slogging through getting Read/Show for this one module..
12:54:21 <conal> mmorrow: no, not at all.
12:54:32 <conal> mmorrow: pretty painful, isn't it?
12:55:06 <mmorrow> conal: i think i see (a simple) strategy for deriving Read (which would work in all cases where Read is possible at all) (i *think*)
12:55:18 <mmorrow> conal: so given
12:55:19 <copumpkin> mmorrow: GHC patch!!
12:55:24 <mmorrow> data Foo a where A :: .... -> Foo Int; B :: .. -> Foo Int; C :: .. -> Foo Double
12:55:25 <conal> mmorrow: sweet!
12:55:27 <mmorrow> you need
12:55:38 <mmorrow> instance Read (Foo Int) where ...
12:55:45 <mmorrow> instance Read (Foo Double) where ...
12:55:51 <mmorrow> but then that breaks if
12:56:04 <mmorrow> there's a con==> D :: ... a ... -> Foo a
12:56:06 <mmorrow> i think
12:56:23 <Saizan> you'd need overlapping instances there
12:56:35 <mmorrow> Saizan: is that doable?
12:57:00 <Saizan> well, it won't work very well
12:57:07 <mmorrow> heh
12:57:15 <mmorrow> hmm
12:57:54 <mmorrow> so i guess then this strategy is only an option for GADTs without polymorphic types in the `a' in "Foo a" there
12:58:08 <mmorrow> but that still covers a range of useful GADTs at least
12:58:14 <Saizan> and without existential quantification
12:58:19 <mmorrow> ah yeah, that too
13:00:42 <Saizan> it'd still be nice
13:00:42 <FliP^2eH> @hpaste
13:00:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:00:45 <mmorrow> so then the only GADTs that doesn't cover (which it's possible to have Read at all for) are _, where "_" is ?
13:00:54 <jmcarthur_work> i don't see how there could be a completely general way without a dependent type system or something
13:00:59 <FliP^2eH> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7398#a7398 Help me before my line length kills me!
13:01:10 <mmorrow> Saizan: oh yeah totally, i think i'm going to hack this up with haskell-src-exts
13:01:11 <FliP^2eH> It reads flawlessy
13:01:16 <FliP^2eH> But it's getting out of hands
13:01:38 <mmorrow> Saizan: how many other "cases" of GADTs do you think there are wrt deriving Read
13:01:43 <Saizan> FliP^2eH: why don't use use a single runGet and return a record?
13:01:47 <mmorrow> Saizan: i'm thinking one, maybe two.
13:02:01 <FliP^2eH> No idea how to do it, Saizan
13:02:06 <FliP^2eH> Can you help me on that one?
13:02:07 <mmorrow> Saizan: one := with polymorphic `a' but no existentials
13:02:24 <FliP^2eH> I'd LOVE to use a record, but I have no idea
13:02:32 <PeakerWork> FliP^2eH: why do you parenthesize + expressions?
13:02:34 <mmorrow> Saizan: two := with polymorphic `a' and existentials... but i'm not sure you can even have Read for the existential case at all
13:02:36 <FliP^2eH> I always sucked at parsing/reading or building up results
13:02:53 <mmorrow> which would make it just one other case for Read (the polymorphic one)
13:03:17 <Saizan> FliP^2eH: i'll make you an example
13:03:20 <PeakerWork> FliP^2eH: replyType = getWord8
13:03:27 <mmorrow> which maybe could be done with some clever trickery
13:03:35 <PeakerWork> FliP^2eH: your use of "drop" there is exactly what the Get monad is about not having to do
13:03:58 <FliP^2eH> :(
13:04:13 <FliP^2eH> That's one point where I miss changable variables
13:04:23 <FliP^2eH> Building up results is a pain
13:04:36 <pikhq> It means that you have to think, and thinking is hard?
13:04:41 <Saizan> FliP^2eH: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7398#a7399
13:04:43 <FliP^2eH> Yep
13:04:49 <FliP^2eH> Thinking in Haskell, that is
13:04:58 <Saizan> that's quite simple ^^^
13:05:20 <Saizan> and, instead of a big tuple, define a custom datatype with meaningful field names
13:05:28 <Saizan> then it'd get nicer to look at :)
13:05:34 <jmcarthur_work> heh, needs liftM6
13:05:53 <Saizan> or record WildCards or how that Foo { .. } is called
13:06:41 <jmcarthur_work> could probably just put deserialiseHeader on its own line in foo rather than doing the unintuitive >> replyType thing
13:06:55 <Saizan> that too
13:07:33 <PeakerWork> I also added one: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7398#a7399
13:07:39 <PeakerWork> oops
13:07:43 <PeakerWork> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7398#a7400
13:07:45 <Saizan> mmorrow: though i'm thinking that you often want Read for exists a. YourGadt a, rather than YourGadt A
13:08:27 <jmcarthur_work> interesting use of replicate
13:08:28 <PeakerWork> FliP^2eH: Pure code forces you to make the data-flow/organization out of the chaos that was in there, and it usually ends up simpler and shorter :)
13:08:43 <PeakerWork> oops, that + is a ++
13:08:47 <PeakerWork> I've used Python a lot recently :(
13:09:04 <FliP^2eH> I don't doubt it, but it's really hard for me to get used to the Haskell way
13:09:13 <FliP^2eH> I'm still way to used to imperative programming
13:09:19 <Botje> don't do that then :p
13:09:20 <FliP^2eH> Spoils everything I'm trying
13:09:48 <Saizan> PeakerWork: even with ++ it won't typecheck though :)
13:09:54 <jmcarthur_work> Peaker, i'm not sure yours will work
13:10:05 <PeakerWork> Yeah, different getter types there
13:10:10 <jmcarthur_work> PeakerWork, the list is heterogeneous
13:10:11 <jmcarthur_work> yeah
13:10:12 <mmorrow> Saizan: hmm, true. i guess you only really want Read for (YourGadt A) when there /doesn't/ exist a con of type (.. -> YourGadt a), in which case the above strategy applies (?)
13:10:32 <mmorrow> ooh, actually wait
13:10:47 <Saizan> well, it depends on what you're doing, i think
13:11:11 <Saizan> i.e. if you already know the type to use for A or not when parsing
13:11:17 <mmorrow> since you have to spit out multiple instances of Read (one for each monomorphic possibility), then you can just omit ... grr
13:11:31 <mmorrow> i dunno, but yeah i think it definitely depends on what you're doing
13:11:51 <mmorrow> "i.e. if you already know the type to use for A or not when parsing"
13:11:53 <mmorrow> exactly
13:12:00 <mmorrow> that's a good way to say it
13:12:28 <PeakerWork> you can also use:      let (^^^) = liftM2 (,) in (deserialiseHeader >> replyType) ^^^ getWord8 ^^^ replicateM 4 getLazyByteStringNul
13:12:32 <mmorrow> in fact, i'd say s/to use/you want/
13:12:55 <Saizan> yeah
13:13:04 <PeakerWork> FliP^2eH: you're still quite new. After a bit more learning, it will become so much less painful to write Haskell, that it will be painful to write in anything else :)
13:13:21 <PeakerWork> that yields a rather nice type of  Get ((Word8, Word8), [B.ByteString])
13:13:29 <FliP^2eH> I'm in THAT stage, where I find imperative code ugly, but I can't produce anything good in Haskell either :)
13:13:39 <FliP^2eH> It's frustrating
13:13:54 <jmcarthur_work> yeah that's the worst stage
13:13:57 <PeakerWork> FliP^2eH: do you understand the Get monad?  It seems your code only used (>>) between Get's once, and not any >>= anywhere
13:14:06 <Saizan> FliP^2eH: you might want to read some good haskell code to get a feel for how things get done
13:14:20 <FliP^2eH> I understand monads so far that I can use them
13:14:24 <PeakerWork> FliP^2eH: Do you know what (>>) does in the Get monad?
13:14:30 * Heffalump is currently being annoyed by the lack of higher-kinded type variables in F#
13:14:34 <FliP^2eH> Nope
13:14:37 <FliP^2eH> I know what it does in the IO
13:14:39 <FliP^2eH> :/
13:14:55 <FliP^2eH> Ignore the result and run the next action
13:15:07 <Saizan> heh, when you use a monad the first thing is to learn what "running an action" means for it
13:15:29 <PeakerWork> FliP^2eH: (>>) chains two "actions" together, such that the left one is "executed" but its result discarded, and the right one is executed and its result returned.    In (Get), "executing" an action means "moving" in the input stream, but discarding the result means that your use of (deserialiseHeader >> replyType) actually discards the parsed header itself
13:15:50 <jmcarthur_work> heh, i mostly just ignore what >> and >>= do anymore and just pay attention to their types
13:16:11 <FliP^2eH> I didn't know that Get maintains a "file pointer", that's what my initial problem was :)
13:16:16 <PeakerWork> today I made someone go "wow" at:
13:16:17 <PeakerWork> > filterM (const [True, False]) [1,2,3]
13:16:19 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:16:34 <PeakerWork> FliP^2eH: where did this "file" of yours come from? :)
13:16:39 <PeakerWork> FliP^2eH: its an input bytestring/stream
13:16:51 <FliP^2eH> It's actually no file, It's a server response to an informations query
13:16:58 <FliP^2eH> Network based
13:17:08 <jmcarthur_work> Get is pure, afaik
13:17:27 <jmcarthur_work> it's just working with a buffer, essentially
13:17:31 <FliP^2eH> Just wanted to get the binary reading done before actually trying out real responses
13:17:33 <Saizan> i guess "file pointer" was just a way to say "position in a string"
13:17:57 * jmcarthur_work is surprised he has made it this far and never used the binary package
13:18:21 <pikhq> Get seems to basically be the State monad storing a bytestring and a pointer into it, with some handy helper functions.
13:18:56 <pikhq> Quite pure, that.
13:19:44 <hackagebot> maid 2009.7.24 - A simple static web server (JinjingWang)
13:23:03 <jmcarthur_work> i'm going comonad crazy. i keep thinking Get would make an awesome comonad
13:23:32 <Saizan> would it?
13:23:44 <BMeph> jmcarthur_work: ...or that Get would be more easily written ith a Zipper? ;)
13:23:49 <BMeph> *with
13:24:12 <jmcarthur_work> extend would not be very useful i guess
13:24:44 <Saizan> mmh, parsing over a zipper?
13:28:00 <PeakerWork> jmcarthur_work: I don't like the Binary package
13:28:48 <LeoD> is there some introductory text on comonads? i've been hearing that word a lot, but have no clue what that is
13:29:13 <PeakerWork> jmcarthur_work: A) Its not declarative enough, IMO, defining a parser and builder for the same structure is unnecessarily repeating yourself...  B) It has no proper error handling (Pure exceptions!)  C) It doesn't allow using an actual input stream and interleaving parsing with actions on that stream
13:29:52 <mmorrow> Saizan: what do you think about these 6 cases of GADTs that Read can be derived for? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3079#a3079
13:30:07 <pragma_>  /win 12
13:30:07 <PeakerWork> jmcarthur_work: Something like Iteratee should be nicer than Binary for the latter 2 problems (though I don't like Iteratee either!), whereas solving the first is more complicated
13:30:08 <mmorrow> Saizan: (here just considering (Read (YourGadt A)))
13:30:22 <sinelaw_> hi PeakerWork
13:30:26 <mmorrow> Saizan: but /also/ allowing a polymorphic `a' in there as well
13:30:31 <PeakerWork> pragma_: don't you think 8 key strokes to switch between windows is a bit too much? :-)
13:30:37 <PeakerWork> sinelaw_: hey
13:30:40 <BMeph> LeoD: I'd say look at either sigfpe's of edwardk's blogs.
13:30:56 <BMeph> Er, *or
13:31:01 <mmorrow> Saizan: (and just including that in all the Read instances for the types of cons that it unifies with)
13:31:26 * BMeph needs to learn to quit hitting the 'f' instead of the 'r'
13:31:33 <pragma_> PeakerWork: beats reaching for the mouse
13:31:42 <LeoD> BMeph: ok, thanks
13:31:53 <mmorrow> Saizan: err, the comments above the One and Two cases are extraneous
13:32:02 <lysgaard> What is the best way to express a 160bit word. I need to do xor etc. on it
13:32:10 <mmorrow> since there's no polymorphic `a' anywhere in those
13:32:25 <PeakerWork> pragma_: I use alt-digit.  If I had >10 windows, I guess I'd prefer two rows and switching between rows and then using alt-digit
13:32:28 <mmorrow> Saizan: err, sorry. it DOES apply to Two
13:32:44 <pragma_> PeakerWork: technically, I could have used alt-digit as well
13:32:46 <leithaus> is there a good reference on the comonad zipper connection?
13:32:52 <mmorrow> Saizan: heh, actually i was right the first time. the comments apply to both One and Two
13:33:28 <pragma_> PeakerWork: for 11-19, I can use the alphabetical row directly under the digit row.  11 -> q; 12 -> w; and so on.
13:33:31 <PeakerWork> pragma_: it would reduce 6 keystrokes, or save 75% of them :)
13:34:18 <pragma_> I suppose so, I already type at 110 wpm or so and it doesn't bother me much :s
13:39:25 <Saizan> mmorrow: your doing something similar to dead case elimination here
13:39:54 <Saizan> mmorrow: one thing to note is that for Two you need to cover the TwoC case in the instances for Int and Double too
13:43:08 <mmorrow> Saizan: totally, i'm gonna do some quick and dirty unification of all the cons with polymorphic types with the other cons, then include those in the Read instances for the types they unify with
13:43:16 <RayNbow> @where typeclassopedia
13:43:16 <lambdabot> Byorgey's Typeclassopedia in <http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf>
13:46:37 <erikc> i think my honeymoon with f# is over
13:47:13 <erikc> back to the haskell
13:47:25 <copumpkin> haskell is much nicer anyway
13:47:29 <copumpkin> dump f#
13:47:35 <erikc> :)
13:47:47 <Saizan> mmorrow: then there's ...X a -> X b -> ..  -> Foo (T a b ..) that you should also be able to cover
13:47:56 <Saizan> mmorrow: where X can be Foo itself
13:48:04 * copumpkin stares at erikc until macho supports Put too :P
13:48:15 <erikc> haha, oh yea...that
13:48:28 * copumpkin stares
13:54:58 <dufflebunk> I have a program which is outputting "<<loop>>". It does some FFI stuff so it has a bunch of allocating and peeking. I added some putStr, to try to see what's going on, and one line, a peek, seems to cause it.
13:55:19 <BMeph> leithaus: I'd check sigfpe's stuff. :)
13:55:41 <dufflebunk> I can't find anything online about what <<loop>> means, although I can guess. But I can't see how a peek would cause a loop
13:55:46 <Phillemann> Can I pattern match on a record field _and_ its contents? Like f { field = (DataType x) }?
13:56:04 <soupdragon> dufflebunk: maybe it's by coincidence
13:56:12 <bos31337> @src concatMap
13:56:12 <lambdabot> concatMap f = foldr ((++) . f) []
13:56:20 <bos31337> @src concat
13:56:20 <lambdabot> concat = foldr (++) []
13:57:31 <Baughn> dufflebunk: When the runtime starts evaluating a thunk, it temporarily alters the thunk to a blackhole - a bit of code that just waits for the thunk to finish evaluating. THis also has the thread ID of the threat in the process of working on it stored.
13:57:43 <BMeph> Ah, that makes sense, since (:) = (++) . return
13:57:44 <Baughn> dufflebunk: If that thread later runs into a blackhole with the /same/ thread id, you get <<loop>>
13:57:53 <Phillemann> Hmmm, can I pattern match a record field at all?
13:58:06 <Baughn> Sure
13:58:35 <Baughn> "foo (Bar { baz = 3, kibble } ) = kibble" should work
13:58:46 <Baughn> ..well, with an extension in this case
13:58:47 <Phillemann> Ah.
13:59:14 <soupdragon> (:) = (++) . return
13:59:16 <soupdragon> ??
13:59:16 <Baughn> I don't think the actual pattern-matching needs an extension, which would make the extension-less equivalent
13:59:21 <soupdragon> is that true
13:59:25 <Baughn> "foo (Bar { baz = 3, kibble = kibble } ) = kibble"
13:59:30 <Badger> @src (:)
13:59:30 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:59:33 <Badger> heh
13:59:37 <Badger> well, might've
13:59:37 <soupdragon> :t (++) . return
13:59:38 <lambdabot> forall a. a -> [a] -> [a]
13:59:40 <Phillemann> a = a works? Hehe
13:59:41 <soupdragon> wow
13:59:59 <FliP^2eH> How do I get Int values from Word8?
14:00:00 <Baughn> Phillemann: Not only does it work, it's sufficiently common that there's syntactic sugar for it.
14:00:05 <FliP^2eH> And Word16?
14:00:06 <dufflebunk> Baughn: So some kind of reference loop? That's what I figured it meant, but hoped it meant something else because I can't see how it would happen
14:00:21 <Baughn> Phillemann: You can also say "foo Bar{..}", which brings everything in Bar into scope, with the record wildcards extension
14:00:32 <mmorrow> Saizan: ah right
14:00:39 <Phillemann> Baughn: Hehe, nice
14:01:03 <Baughn> Phillemann: Or, conversely, Bar{..} looks for local bindings with the appropriate names to generate the Bar
14:01:16 <Phillemann> That'll come in handy
14:01:41 <hzap_> Baughn: wow, I didn't know the second usage of {..}
14:02:01 <Baughn> Phillemann: Though if you just change /one/ of them, I'd use the at-pattern instead. "f x@Bar{ kibble, pedigree = 42 } = x { kibble + 2 }" would be a summary..
14:02:08 <Baughn> Which increments kibble by two if pedigree is 42
14:02:37 <Baughn> Still, nice as this is, it's little use for deep structures
14:03:10 <Baughn> ..well, a mite verbose at least
14:04:28 <Baughn> hzap_: I find it useful to browse the GHC user guide at random on occasion. It never fails to teach me something new. :3
14:05:16 <FliP^2eH> Okay, how do I convert a ByteString to a normal char array?
14:05:28 <Baughn> FliP^2eH: That depends on what's stored in it.
14:05:32 <FliP^2eH> ASCII
14:05:34 <FliP^2eH> :)
14:05:48 <Baughn> Then you should be able to use the Char8 bytestring variant, and just unpack it
14:05:51 <hzap_> Baughn: I never read the record sugar section in a focused manner :)
14:07:24 <hzap_> Baughn: I guess randomly staying in #haskell is a pretty good substitute :D
14:08:41 <Baughn> FliP^2eH: Though I should mention, the utf8-string bytestring converter would work just fine on ascii too, and could be useful later
14:09:07 <FliP^2eH> If I use unpack, I'm getting those Word8's, but how do I convert them to Chars?
14:09:34 <Baughn> toEnum . fromIntegral would work, but I already told you to use the Char8 bytestring module
14:11:52 <Saizan> FliP^2eH: Data.ByteString[.Lazy].Char8.unpack has a different type
14:13:39 <FliP^2eH> Thanks :)
14:15:31 <lpsmith> @seen mmorrow
14:15:32 <lambdabot> mmorrow is in #yi, #haskell-blah, #haskell-in-depth, #ghc and #haskell. I last heard mmorrow speak 15m ago.
14:24:51 <dufflebunk> Baughn: Do you know if there's any way to get mor information about the thing creating the loop?
14:25:43 <lpsmith> dufflebunk:  Is this an unexplained infinite loop?
14:26:31 <lpsmith> dufflebunk:  if it is,  I'll bet you've accidentally written something like   "let x = some_expression_containing_x" by accident
14:26:59 <lpsmith> that's a surprisingly common source of errors
14:27:17 <dons> bos31337: ?
14:27:37 <bos31337> dons: nemmind, just writing up some slides on stream fusion for a talk tomorrow
14:27:50 <dons> k. yell if you want me to look 'em over.
14:27:56 <bos31337> cheers
14:28:14 <dons> btw, we have isabelle proofs now that it works :)
14:29:09 <lpsmith> dons:  is the plan still to replace Data.List with stream-fusion in GHC at some point in the future?
14:29:10 <mmorrow> Saizan: this is where i'm at. only the 3 steps at the top need doing now (i think): http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3079#a3080
14:31:15 <bos31337> dons: yeah, i saw
14:31:27 * mmorrow tries to get someone else interested ..
14:31:43 * bos31337 plans to handwave fusiously around the forall in the definition of Stream :-)
14:33:09 <dons> well, it has to abstract over the states of all the loop bodies
14:33:25 <dons> so obviously the state of a body of a loop has to have existential type :)
14:34:24 <Saizan> mmorrow: :O
14:34:33 <Saizan> mmorrow: it's already working?
14:35:07 <mmorrow> Saizan: just those 3 steps to do..
14:35:24 <mmorrow> all the "busy work" is out of the way
14:35:42 <mmorrow> (parsing,organizing,etc)
14:39:54 <Saizan> mmorrow: do you already have unification for Type?
14:40:37 <mmorrow> Saizan: no, but i have unification code to another (slightly more limited) "Type" type, which i'm gonna hack to use here
14:41:48 <mmorrow> once we've got a unify function, then it's just a matter of writing the code the generate the readsPrec function.. which we can just model after how derive does it
14:42:04 <Saizan> heh, i think we should use generics to write unification once and for all :)
14:44:16 <soupdragon> hehe
14:45:08 <soupdragon> Saizan I bet you'd like the dependent type stuff Thorsten and those guys do if you didn'd already
14:46:18 <Saizan> i didn't, where can i find it?
14:48:38 <soupdragon> http://www.cs.nott.ac.uk/~txa/oxford04/ http://www.cs.nott.ac.uk/~txa/publ/wcgp02.pdf
14:49:06 <LeoD> @hoogle IORef a -> (a -> b) -> IO b
14:49:07 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
14:49:07 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:49:07 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
14:49:27 <soupdragon> http://www.cs.nott.ac.uk/~txa/publ/ssgp06.pdf aha!
14:49:51 <pikhq> $! ?
14:49:54 <pikhq> @src ($!)
14:49:55 <lambdabot> f $! x = x `seq` f x
14:50:17 <pikhq> That should not have surprised me in the slightest.
14:50:47 <ray> strict so strict
14:51:21 <Saizan> hah! thanks :)
14:51:21 <pikhq> I had forgotten that ! meant strict, for some reason.
14:57:19 <lysgaard> Is it possible to enumerate a Word160? So that i can: (1234 :: Word160) > (5432 :: Word160) == false
14:58:00 <dons> yes, assuming you have Word160 type, instance of Num and Ord
14:59:08 <dufflebunk> lpsmith: It's unexplained output of "<<loop>>". It's in a big do block with a bunch of aloca's and some FFI stuff, then some peeks. It prints out some stuff, and with putStr I /think/ the line causing it is a peek.
14:59:51 <lysgaard> dons: I'm using Data.LargeWord, It seems like it's an instance of Ord but i can't get the former to work
15:00:30 <pikhq> dufflebunk: Clearly, you're just triggering ghc's halting oracle.
15:00:57 <lysgaard> You can read about it here: http://hackage.haskell.org/packages/archive/Crypto/4.2.0/doc/html/Data-LargeWord.html#v:Word160
15:02:07 <dufflebunk> pikhq: Yeah, and I'm sure I'm doing something wrong... but I've no idea what.
15:02:21 <pikhq> There's a trivial infinite loop there.
15:03:31 <lpsmith> dufflebunk:  you've definitely got something like "let x = x"  or "where x = x"
15:04:01 <kyagrd> Is anyone using SMT solver, calling from Haskell sice?
15:04:11 <dufflebunk> lpsmith: http://haskell.pastebin.com/m1e94de97
15:04:12 <lpsmith> pikhq:  GHC's halting oracle is easily confused ;-)
15:04:19 <kyagrd> "sice" => "side" I mean
15:04:52 <dufflebunk> lpsmith: I don't think I have anything that obvious... in that code it outputs the DBG1 line, but not the DBG2 line.
15:05:10 <dons> kyagrd: yep
15:05:22 <dons> kyagrd: we have haskell bindings to various smt and sat solvers
15:05:42 <dons> there's a binding to yices
15:05:50 <pikhq> lpsmith: Heheh.
15:05:53 <lysgaard> What does this error mean? Exception: "Data/LargeWord.hs:(102,9)-(103,20): No instance nor default method for class operation GHC.Num.*"
15:05:54 <kyagrd> Ah, I was just about to roll yices interface ...
15:05:59 <dufflebunk> I'm pretty sure my code is going to make someone eyes bleed, but I'd appreciate any suggestions on what I'm doing wrong.
15:06:02 <kyagrd> Is it on hackage yet?
15:06:03 <dons> kyagrd: ah , but not open source i think.
15:06:08 <ivanm> so, when can we expect to see tuple sections in a GHC release?
15:06:16 <kyagrd> Oh, OK, then I'll upload mine.
15:06:42 <kyagrd> It's just a IPC (pipe) to yices but usable for primitive purposes (e.g. test case generation)
15:07:23 <kyagrd> dons: So, that one is Galois internal?
15:08:05 <benmachine> woo I did exercise #20
15:08:15 <benmachine> although this is quite a wordy solution
15:08:43 <benmachine>   banana f sa = State $ (\(x, f) -> f x) . (state . furry' (state . f) $ sa)
15:09:03 <soupdragon> @pl (\(x, f) -> f x)
15:09:03 <lambdabot> uncurry (flip id)
15:09:12 <soupdragon> :t flip id
15:09:14 <lambdabot> forall b c. b -> (b -> c) -> c
15:09:46 <benmachine> interesting
15:09:49 <soupdragon> :t join (liftA2 fst snd)
15:09:50 <lambdabot>     Couldn't match expected type `(a1, (b1 -> a, b))'
15:09:51 <lambdabot>            against inferred type `(a1, (b1 -> a, b)) -> b1'
15:09:51 <lambdabot>       Expected type: (a1, (b1 -> a, b)) -> (a1, (b1 -> a, b)) -> a
15:10:07 <soupdragon> :t join (liftA2 ($) fst snd)
15:10:09 <lambdabot>     Occurs check: cannot construct the infinite type:
15:10:09 <lambdabot>       m = (->) (b -> m a, b1)
15:10:09 <lambdabot>     Probable cause: `fst' is applied to too few arguments
15:10:21 <pikhq> Uh.
15:10:48 <pikhq> What in the world are you wanting to do?
15:11:01 <benmachine> pikhq: who
15:12:34 <pikhq> soupdragon.
15:12:42 <benmachine> oh
15:12:51 <benmachine> at a guess, trying to golf my banana
15:12:57 <soupdragon> I was trying to do (\(x, f) -> f x) in a certain way but I got it wrong
15:15:11 <LeoD> @pl \f (a, b) -> (f a, b)
15:15:12 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
15:15:29 <BONUS> > first (*3) (1,4)
15:15:30 <lambdabot>   (3,4)
15:15:40 <LeoD> ah :D
15:15:53 <BONUS> Control.Arrow has some very useful combinators :]
15:16:51 <kyagrd> @pl forall a . a
15:16:51 <lambdabot> forall a . a
15:17:10 <Saizan> "trying to golf my banana" makes for a nice surreal image
15:17:37 <kyagrd> @pl \f (a,b) -> (f a, f b)
15:17:37 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
15:18:25 <kyagrd> @t first
15:18:26 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:23:41 <lpsmith> dufflebunk:  I would guess that you are creating a loop with your cppoints
15:23:52 <lpsmith> look where it is defined
15:24:15 <lpsmith> And then you use it in the c_RmfReaderNextFeature
15:24:48 <lpsmith> dufflebunk:  what is c_RmfReaderNextFeature?
15:25:17 <dufflebunk> It's a foreign function.
15:25:46 <lpsmith> hmm, something's not quite making sense...  but that looks suspicious to me
15:26:14 <lpsmith> if you are right and the "peek cppoints" is where it's blowing up
15:29:28 <dufflebunk> cppoints is given to the do block, it's not the same as a let.
15:30:29 <lpsmith> Yeah, I'm aware.  I'm not saying I'm right :-)
15:30:40 <lpsmith> I've done some FFI, but am no guru
15:32:08 <dufflebunk> Could it be that since cppoints is only used before that as an arg to c_RmfReaderNextFeature, that it doesn't bother to do the allocating first. Then it hits the peek cppoints, and tries to eval the alloca function?  That doesn't make any sense.
15:32:28 <lpsmith> What's the type of c_RmfReaderNextFeature?
15:33:35 <dufflebunk> I added the type to http://haskell.pastebin.com/d17bcfd4
15:38:02 <LeoD> heh, refactoring is awesome using haskell.. if it compiles, it most likely works
15:38:47 <lpsmith> LeoD:  only for very simple things.  I find I have my share of bugs.  ;-)
15:39:23 <LeoD> heh
15:40:04 <FliP^2eH> How do I enforce strictness on sockets?
15:40:07 <lpsmith> But yes, the compiler will catch a lot of common mistakes :-)
15:40:13 <FliP^2eH> When I tell it to send, it has to send NOW
15:40:53 <Peaker> FliP^2eH: the IO monad is strict in the actions performed
15:41:08 <LeoD> yea, i was quite surprised though; i ran my program after a long session of refactoring, and it just worked :D
15:41:13 <Peaker> FliP^2eH: x >>= y  necessarily executes x before the y function is even called in the IO monad
15:41:25 <BONUS> maybe you're thinking about buffering?
15:41:27 <BONUS> in which case just flush
15:41:32 <Peaker> LeoD: it compiles -> it works   is awesome in Haskell :)
15:41:35 <FliP^2eH> That might be it
15:41:43 <LeoD> Peaker: yea :)
15:41:57 <FliP^2eH> Oh yes, it was buffering
15:42:03 <Peaker> LeoD: I also rewrote some of my code upside down and fixed everything everywhere and it just worked too
15:42:03 <FliP^2eH> Thanks BONUS, forgot about that :)
15:42:08 <BONUS> :]
15:42:14 <LeoD> Peaker: nice :D
15:42:38 <Peaker> FliP^2eH: lazyness doesn't delay IO effects, only pure computations
15:44:51 <lpsmith> dufflebunk:  Wait,  the last argument to RMFReaderNextFeature is a (Ptr (ForeignPtr ...)) ?
15:45:01 <lpsmith> or in c types,  **something
15:45:55 <lpsmith> What does it mean to have a pointer to a foreign pointer... hmm...
15:46:13 <lpsmith> The latter has a finalizer, the former does not
15:46:35 <hackagebot> List 0.1 - List monad transformer and class (YairChuchem)
15:47:09 <dufflebunk> lpsmith: Yeah
15:48:41 <lpsmith> I assume RdfReaderNextFeature fills up an array with something?
15:49:09 <dufflebunk> yeah, its own internal array
15:49:13 <lpsmith> By taking the array by reference?
15:49:18 <lpsmith> err
15:49:39 <lpsmith> right
15:50:16 <lpsmith> Is this internal array allocated on the heap or the stack?
15:51:35 <dufflebunk> It's on the heap.
15:51:36 <hackagebot> generator 0.5.2 - Python-generators notation for creation of monadic lists (YairChuchem)
16:03:00 <dufflebunk> The library has a hunk of memory, writes a bunch of stuff to the memory, the assigns the location of the memory to the pointer passed in.
16:03:59 <lpsmith> right
16:04:03 <dufflebunk> although since I don't have a finalizer, I guess it doesn't have to be a ForeignPtr
16:04:41 <lpsmith> well,  I assume the library is responsible for allocating/deallocating this array...
16:04:52 <dufflebunk> yes
16:05:08 <FliP^2eH> Short question, I'm connecting to a server which sends 3 lines at startup, the first one is important, the other 2 are just disturbing, so I just suck them off the stream and continue. What'd be a nice solution to do that? Currently I'm doing it very.. lame...
16:05:08 <FliP^2eH> hGetLine handle
16:05:08 <FliP^2eH> hGetLine handle
16:07:29 <Elly> in your mind, what would make a solution nice?
16:07:54 <ivanm> has anyone managed to build darcs-2.3 yet?
16:07:57 <FliP^2eH> One that does not look so bad
16:08:02 <Saizan> ivanm: i did
16:08:14 <ivanm> Saizan: is it missing a network dependency?
16:08:23 <ivanm> because I'm looking at the build log on hackage: http://hackage.haskell.org/packages/archive/darcs/2.3.0/logs/failure/ghc-6.10
16:08:24 <Saizan> FliP^2eH: replicateM_ 2 (hGetLine handle)
16:09:08 <ivanm> oh, wait, hackage just lies
16:09:09 <ivanm> nvm
16:09:33 <FliP^2eH> Thanks Saizan :)
16:09:33 <Saizan> cabal install darcs worked fine here
16:14:34 <Kanoja> hey guys
16:14:43 <Kanoja> can someone hlint me something?
16:15:14 <conal> anyone here familiar with xcode "make" vs GNU "make"?  i'm having a weird inconsistency with "make -C".  my "include ../common.mk" directives aren't finding ../common.mk in xcode but work fine in gnu.
16:15:34 <benmachine> conal: I thought xcode tools included GNU make?
16:15:39 <benmachine> what does make --version say?
16:15:55 <Saizan> Kanoja: you mean give comments to your code?:)
16:16:06 <conal> benmachine: oh, yeah.  weird.  exactly the same version on both machines: "GNU Make 3.81"
16:16:22 <benmachine> that is odd
16:16:52 <pikhq> That's a screwy path issue, not make.
16:17:02 <benmachine> tha'd be my guess
16:17:08 <Kanoja> Saizan: well, to check it with hlint, to see if it's okay... very newbie code
16:17:43 <hackagebot> maid 2009.7.24.1 - A simple static web server (JinjingWang)
16:18:18 <gs4> if I have a data type, Tri thats basically a four tuple, can I pattern match to get the arguments (i.e. blah (a,b,c,d) = ... ) ?
16:18:59 <Kanoja> Saizan: do you want the hpaste of it? :)
16:19:04 <dufflebunk> gs4: blah (Tri a b c d) = ...  ?
16:19:07 <bremner> gs4: sure, what tutorial/book doesn't cover that?
16:19:18 <gs4> ohhh ok, haha my syntax was wrong :P
16:19:20 <gs4> thanks :)
16:19:24 <conal> the line in my Makefile is "for lib in $(libs); do (make -C $$lib $@;) done;", which is a rule for "%".  oddly, if i just type "make -C TypeCompose install", no problem.
16:19:59 * dufflebunk wonders why a data tructure called tri would have four things
16:20:24 <Peaker> conal: why make and not Cabal?
16:20:35 * BMeph wonders why a data tructure called tri would not have six things... ;p
16:20:59 <conal> Peaker: it's cabal-make, which builds on cabal
16:21:03 <gs4> i'm trying to implement a delaunay triangulation algorithm, and i wanted to have the opposite vertex
16:21:12 <ivanm> gah, the darcs cabal file is weird! :s
16:21:13 <conal> @wiki cabal-make
16:21:13 <lambdabot> http://www.haskell.org/haskellwiki/cabal-make
16:21:31 <ivanm> on one line it has base < 4, then later on it has base >= 3 ... why not combine the two? :s
16:21:47 <ivanm> conal: so you prefer using make rather than cabal-install?
16:21:50 <conal> Peaker: lots of useful features/targets.
16:22:13 <Peaker> conal: ah. I wonder why they chose Make for this
16:22:16 <conal> ivanm: for other folks' packages, i use cabal-install.
16:22:21 <ivanm> *nod*
16:23:08 <conal> Peaker: because there were a lot features not in cabal.  still are some.
16:23:43 <conal> which is no criticism of cabal.  it's already pretty complicated.
16:23:58 <Kanoja> can someone hlint me 2 lines of code?
16:24:05 <Kanoja> well, 3
16:24:41 <Peaker> conal: I simply have a strong dislike for Make, because of its ignorance of the true dependencies of stuff which causes it to not actually rebuild when required, sometimes causing cryptic bugs which take a while to find
16:24:59 <conal> Peaker: totally!
16:25:00 <Peaker> Kanoja: You can probably paste <=3 lines of code here
16:25:30 <ivanm> Peaker: yeah, we won't necessarily kill him for that
16:25:35 <ivanm> >3 is a different story though ;-)
16:25:37 <Kanoja> Peaker: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7402#a7403
16:25:44 <Peaker> conal: Build systems tend to be a super-special-case of FRP...
16:25:52 <conal> Peaker: i think we could make a general, optimal, and elegant replacement based on a purely model.
16:25:57 <conal> Peaker: exactly.
16:26:26 <Peaker> conal: I think I've come to a conclusion (which may be wrong) that Push-based FRP with the Reactive API has to have unsafePerformIO to have reasonable efficiency/caching of values
16:26:27 <conal> in most cases, the programs being run are purely functional.  if they weren't, then make couldn't really work.
16:26:59 <conal> Peaker: internally?  or just at the inputs (as in Reactive)?
16:27:15 <bremner> functional in the leave crap all over the filesystem monad
16:27:15 <conal> Peaker: by internally, i mean the combinators.
16:27:20 <conal> Peaker: rather than the leaves
16:27:31 * Saizan does actually have a stub of a FRP-like build system
16:27:33 <Peaker> conal: I am not sure where exactly, but somewhere in the library
16:27:53 * conal  has one also
16:28:10 <conal> i'd love to see haskell & ghc move away from an imperative model of program compilation
16:28:10 <Peaker> Kanoja: I wouldn't recommend using Int to represent Bit -- what do non 0/1 values mean?
16:28:47 <conal> Peaker: btw, watch out for thoughts like "has to have".  they become self-fulfilling prophecies.
16:28:51 <Peaker> conal: Haskell is such an awesome imperative language that people are tempted :)
16:29:12 <Kanoja> Peaker: nothing... it just throws 0s and 1s
16:29:28 <Peaker> Kanoja: then you should use the type to signify that it can only be 0 or 1, and not any Int at all
16:29:43 <conal> Peaker: yeah.  sigh.
16:30:27 <Peaker> conal: I have hand-wavingly proved it to myself, but maybe I ought to write it down to semi-formalize my explanation of why, if I am right, an unsafePerformIO has to hide somewhere behind an FRP implementation with Reactive's API
16:30:31 <Peaker> that is Push-based and efficient
16:31:07 <mmorrow> preflex: seen Saizan
16:31:07 <preflex>  Saizan was last seen on #haskell 3 minutes and 36 seconds ago, saying: * Saizan does actually have a stub of a FRP-like build system
16:31:26 <Saizan> mmorrow: pong!
16:31:46 <conal> Peaker: if you try to prove it, you'll probably either get stuck, or you'll succeed in realizing your mistaken assumption.
16:32:14 <Peaker> conal: are you pretty sure that's not true?
16:32:15 <mmorrow> Saizan: ok, that took me a little longer than i anticipated (found an error in my code, had to fix it), here's that Unify module (not on the haskell-src-exts Type type yet, ..)  http://moonpatio.com/repos/Unify.hs
16:32:40 <mmorrow> Saizan: (also there's a con "Exists" in that Type type, but i didn't know what to do with it so it's pretty much just ignored)
16:32:54 <conal> Peaker: my hunch is that it's false.  my strong hunch is that you can't prove it to be true.
16:33:58 <Saizan> mmorrow: what do you use Q for in unify?
16:34:00 <Peaker> conal: Thanks, I'll think about it more
16:34:05 <conal> Peaker: and if it does turn out to be provable, the proof would be be a valuable result.
16:34:32 <mmorrow> Saizan: just for unique vars... (used an IORef, since that Q was meant to be a copy of the TH Q)
16:35:06 <mmorrow> Saizan: but the Q monad could be dropped and that S monad used instead, with a counter in the state (which would be nicer than Q + IORef)
16:35:37 <mmorrow> Saizan: also there are a few hacks still floating around in there, it's rough atm
16:35:58 <Saizan> mmorrow: ah, i see, i was thinking that if you were using IO you could use IORefs for unification, rather than Map's
16:35:59 <mmorrow> i *think* it's correct though
16:36:22 <mmorrow> Saizan: yeah, i like the "zipping trees" + Maps formulation for some reason though
16:36:49 <mmorrow> Saizan: but i could be converted if doing it that way is a lot easier/shorter/something though
16:37:36 <mmorrow> Saizan: (also that UnifyEnv isn't very well organized either, was added to as i needed things in it, probably would do redo that too)
16:39:06 <lpsmith> dufflebunk:  Just trying to duplicate the issue you are having, I'm not even sure why your code type-checks...
16:39:54 <lpsmith> dufflebunk:  ForeignPtr is not Storable... so you should be able to peek and get back a ForeignPtr
16:40:11 <lpsmith> Which sort of lays to rest one thing I didn't understand, but raises another
16:40:17 <Peaker> conal: do you know if the Elerea FRP library has nice semantics?
16:40:18 <Saizan> there's a paper on UHC's way of implementing unification that's a kind of hybrid, using an IntMap to implement IORefs, so you keep referential transparency and asymptotic efficiency
16:40:51 <lpsmith> dufflebunk:  err, should not be able to peek and get back a ForeignPtr
16:41:53 <Saizan> but for deriving Show/Read the simple Map approach should be fine, if correct
16:42:24 <conal> Peaker: rings a bell.  who's is it?
16:42:39 <FliP^2eH> dsajkdl why do I fail so much?
16:42:53 <FliP^2eH> I hate parsing without loops :(
16:42:53 <Peaker> conal: Patai Gergely
16:43:05 <Peaker> FliP^2eH: Haskell has "loops"
16:43:11 <conal> Peaker: oh yeah.  i don't know.  i doubt it.  i haven't heard of any Reactive spinoff that gets the semantics right.
16:43:17 <FliP^2eH> I have no idea how to do it recursivly
16:43:58 <Saizan> mmorrow: do you have the occurs check there?
16:44:10 <solrize> anyone know how the ghc runtime 1) switches between lightweight threads during long computations; and 2) handles waiting on semaphores?
16:44:16 <mmorrow> Saizan: ah, no
16:44:17 <FliP^2eH> I'm having an array of 32 pascal strings (first byte = string length, next bytes = the string, padding to 24 with \0)
16:44:20 <FliP^2eH> And I have NO IDEA
16:44:24 <Peaker> conal: It apparently is a difficult problem.  Maybe the Reactive API should be posed as a challenge -- to see if anyone can make an implementation fully faithful to those semantics. "Crowdsource" it :)
16:44:48 <Saizan> FliP^2eH: replicateM 32 parseOneString
16:44:59 <conal> Peaker: yeah. that's how i see it now.  i could be more explicit.
16:45:19 <conal> can anyone recommend an irc channel for mac os x technical help?  like customizing the environment.
16:45:30 <Saizan> FliP^2eH: parseOneString = do len <- fmap fromIntegral getWord8; ...
16:45:51 <conal> now i'm annoyed with using command-tab between apps but command-twiddle between windows of an app.
16:46:44 <conal> i have two very different activities going on in different windows of what happens to be the same app, so i have to keep correcting my impulse to use control-tab.  :(
16:46:57 <mmorrow> Saizan: oh, actually i do
16:47:03 <mmorrow> Saizan: "isInf a t = a `S.member` ftvs t"
16:47:06 <conal> just did it again :p
16:47:49 <mmorrow> Saizan: but i don't do anything with it, (i used that function in the code that i just deleted from that module and did differently)
16:48:17 <mmorrow> Saizan: i didn't error out on the infinite type, just noted it
16:49:11 <jimmyjazz14> I find having to keep creating case statements to determine Just or Nothing (when using lookup) annoying, is there a better way?
16:49:20 <LeoD> @type maybe
16:49:21 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:49:38 <Peaker> jimmyjazz14: either maybe, or use the Monad instance of Maybe
16:50:10 <Saizan> ?type fromMaybe
16:50:11 <lambdabot> forall a. a -> Maybe a -> a
16:50:15 <LeoD> evil :P
16:50:26 <Saizan> why?
16:50:35 <LeoD> ohh thought you meant fromJust
16:50:54 <Saizan> fromJust is indeed evil
16:51:13 <Peaker> > let xs = zip [0..] [1,2,0,5] look = (`lookup` xs) in look 0 >>= look >>= look
16:51:14 <lambdabot>   <no location info>: parse error on input `='
16:51:27 <Peaker> > let xs = zip [0..] [1,2,0,5] ; look = (`lookup` xs) in look 0 >>= look >>= look
16:51:27 <lambdabot>   Just 0
16:51:36 <lpsmith> heh, didn't know about fromMaybe,  I just called it maybe
16:51:37 <mmorrow> it's funny that `fromJust' is seen as more evil than `head'
16:51:46 <Peaker> > let xs = zip [0..] [1,2,0,5] ; look = (`lookup` xs) in look 3
16:51:47 <lambdabot>   Just 5
16:51:48 <FliP^2eH> Thanks Saizan :)
16:51:51 <Peaker> > let xs = zip [0..] [1,2,0,5] ; look = (`lookup` xs) in look 3 >>= look
16:51:52 <lambdabot>   Nothing
16:51:54 <FliP^2eH> You really help me out here
16:52:01 <ray> head is equally evil, of course
16:52:11 <Badger> > zip [0..] [1,2,0,5]
16:52:13 <lambdabot>   [(0,1),(1,2),(2,0),(3,5)]
16:52:43 <mmorrow> jimmyjazz14: use `maybe', it makes using Maybe bearable
16:52:50 <Saizan> FliP^2eH: feel free to ask for details if the snippets are not clear to you :)
16:52:56 <Peaker> jimmyjazz14: or use (>>=)
16:53:00 <mmorrow> , maybe 0 length (Just [0..9])
16:53:03 <lunabot>  10
16:53:04 <mmorrow> , maybe 0 length Nothing
16:53:06 <lunabot>  0
16:53:07 <SamB_XP_> so, did everyone notice that Rejecta Mathematica has put out an issue?
16:53:31 <mmorrow> jimmyjazz14: (and `either' too)
16:53:48 <Saizan> mmorrow: i tend to see more useless fromJust errors than head ones
16:53:57 <SamB_XP_> http://math.rejecta.org/vol1-num1
16:53:58 <ray> , maybe (-1) length Nothing
16:53:59 <lunabot>  -1
16:54:04 <ray> it's almost like using C!
16:54:09 <jimmyjazz14> ah seems to be many better ways, I'll experiment around with these
16:54:10 <Badger> @src maybe
16:54:10 <lambdabot> maybe n _ Nothing  = n
16:54:10 <lambdabot> maybe _ f (Just x) = f x
16:54:59 <Peaker> jimmyjazz14: is your maybe computation result also a Maybe?
16:55:00 <mmorrow> Saizan: yeah true
16:55:19 <shachaf> @ty flip (maybe Nothing)
16:55:20 <lambdabot> forall a a1. Maybe a1 -> (a1 -> Maybe a) -> Maybe a
16:55:33 <ray> zomg
16:55:57 <mmorrow> @type maybe mempty
16:55:57 <Peaker> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
16:55:58 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> Maybe a1 -> a
16:55:58 <lambdabot> f a b =
16:55:58 <lambdabot>     case a of
16:55:58 <lambdabot>     Nothing -> Nothing
16:55:58 <lambdabot>     Just c -> b c
16:56:08 <Peaker> auto-monads
16:56:12 <dufflebunk> lpsmith: I still don't know the problem, but I changed that ForeignPtr to a plain Ptr and now I'm not getting that error.
16:56:30 <mmorrow> @type maybe mzero return
16:56:31 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
16:56:43 <conal> Peaker: do you know about the spaniel method of debugging?
16:56:47 <Badger> :t maybe
16:56:47 <lpsmith> dufflebunk:  Have you written everything yourself, or you working with others on a private codebase?
16:56:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:56:49 <Nereid_> so I'm trying to figure out why my in-place bubble sort using STArray is so slow
16:56:50 <Nereid_> http://haskell.pastebin.com/m40dd4568
16:56:53 <Nereid_> any ideas?
16:56:56 <Badger> hm
16:57:22 <lpsmith> dufflebunk:  I'm suspicious that somebody added some kind of evil instance for Storable ForiegnPtr.
16:57:34 <EvilTerran> Nereid_, i don't like the look of that reverse
16:57:35 <Badger> > maybe pi head (Just [1,2,3])
16:57:36 <dufflebunk> lpsmith: The C library is not written by me.
16:57:36 <lambdabot>   1.0
16:57:42 <mmorrow> @let rotate a = either Right Left a
16:57:44 <lambdabot>  Defined.
16:57:44 <Nereid_> EvilTerran: even without that reverse
16:57:47 <Nereid_> it's slow
16:57:57 <dufflebunk> however I'm writing all the haskell.
16:57:59 <EvilTerran> you could make that [max, max-1 .. min]
16:58:00 <Nereid_> (without it it doesn't sort properly but it's still slow)
16:58:01 <lpsmith> dufflebunk:  which version of GHC are you using?
16:58:12 <EvilTerran> Nereid_, are you compiling, with -O2?
16:58:18 <Nereid_> I'm running it in ghci
16:58:20 <dufflebunk> lpsmith: ghc 6.10.3
16:58:24 <mmorrow> @let mapE f g = either (Left . f) (Right . g)
16:58:25 <lambdabot>  Defined.
16:58:25 <EvilTerran> Nereid_, aha, there's your problem
16:58:30 <Nereid_> ok I'll try that hten
16:58:34 <flippeh_> There goes my connection.
16:58:34 <EvilTerran> Nereid_, ghci does pretty much no optimisation
16:58:36 <flippeh_> Now I'm getting send 32 IPs, each as 4 bytes. replicateM 32 parseOneIP, clear thing, inside parseOneIP I'm having 4 lines of partN <- getWord8
16:58:46 <flippeh_> How could that be tuned?
16:58:49 <mdmkolbe> What is the easiest way to add a datatype to SmallCheck?  (It would be nice if I could say "deriving (Serial)", but ghci (6.8.2) doesn't seem to know how to do that.)
16:58:56 <EvilTerran> Nereid_, (well, that might be your problem. i may be wrong.)
16:59:12 <lpsmith> dufflebunk:  hmm.. weird.  Maybe there is an instance in a library for Storable ForeignPtr,  but on my end that construct that you are using gives me a type error
16:59:25 <lpsmith> so... I dunno
16:59:35 <Saizan> flippeh_: replicateM works there too
16:59:43 <Saizan> ?type replicateM
16:59:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
16:59:50 <flippeh_> replicateM 4 getWord8 ?
16:59:54 <Saizan> yup
16:59:57 <Nereid_> EvilTerran: that does it :)
16:59:57 <mmorrow> @let both f = either (Left . f) (Right . f)
16:59:58 <lambdabot>  Defined.
17:00:03 <lpsmith> dufflebunk:  Honestly that Ptr (ForeignPtr ...) bit did have me confused at first, and had to review my FFI
17:00:06 <Nereid_> so why is it so slow otherwise?
17:00:09 <Saizan> so you get a list of those 4 bytes
17:00:17 <Badger> :t both
17:00:18 <flippeh_> :D
17:00:18 <lambdabot> forall a a1. (a -> a1) -> Either a a -> Either a1 a1
17:00:23 <dufflebunk> lpsmith: I think I'll jsut stay away from the ForeignPtr then.
17:00:52 <EvilTerran> Nereid_, it's probably the strictness analysis that's giving you the big boost
17:01:08 <EvilTerran> (i'm guessing again, but that seems to tend to be it)
17:01:30 <Saizan> or array fusion
17:01:30 <shachaf> Haskell sure is direction-biased.
17:01:41 <lpsmith> dufflebunk:  heh,  it can be the right tool for the job.  Maybe not today though.
17:01:43 <Peaker> conal: nope, never heard of that
17:01:47 <Peaker> conal: what's that?
17:01:51 <lpsmith> dufflebunk:  good luck, and happy hacking!
17:01:57 <conal> @go spaniel method
17:02:00 <lambdabot> http://portal.acm.org/citation.cfm?id=307866
17:02:00 <lambdabot> Title: Literate programming and the “Spaniel“ method
17:02:27 <dufflebunk> lpsmith: Thanks for your help
17:02:50 <conal> Peaker: it's a great reason to go for a formal proof of impossibility (of anything) rather than a hand-waving one.
17:03:19 <mmorrow> > (twist (twist (twist id))) (Right (Left (Right 42)))
17:03:21 <lambdabot>   Left (Right (Left 42))
17:03:28 <mmorrow>  @let twist f = either (Right . f) (Left . f)
17:03:38 * mmorrow finally remembered the function he was thinking of
17:04:17 <dons> dufflebunk: what's the problem?
17:04:40 <conal> Peaker: with hand-waving proofs, one's blind spots get *reinforced*.
17:04:54 <dons> mmm. conal, that's insightful.
17:04:55 <conal> Peaker: making a way out harder & harder to see.
17:05:13 <EvilTerran> conal++ insightful :)
17:05:24 <dons> :)
17:05:25 <conal> that's why i say that statements about what cannot be don are self-fulfilling prophecies.
17:05:31 <conal> (are usually)
17:05:33 <conal> :)
17:05:36 <dufflebunk> dons: http://haskell.pastebin.com/d17bcfd4  a program was outputting <<loop>> in a weird spot. Somehow changing ForeignPtr to Ptr made the problem go away
17:05:57 <mmorrow> Saizan: ahh, so there's no need for the occurs check in this particular situation, since that "unify" function does NOT equate vars with the same name in the two types it gets passed
17:06:02 <conal> spaniels (the dog) have the benefit of open-minded skepticism.
17:06:17 <mmorrow> Saizan: (which for GADTs is just what we need)
17:06:56 <dons> mm
17:07:00 <mmorrow> Saizan: err, so i guess an equiv way to say it is that all freevars in each type are implicitly forall'ed
17:07:39 <conal> words like "obviously" and "clearly" often have the same effect.  reinforcing a blind spot.  old thinking become more & more obvious (entrenched).
17:07:44 <Saizan> mmorrow: isn't it more that the free vars of the two types are considered disjoint?
17:08:13 <mmorrow> Saizan: yes exactly, although i think that might be the same as saying they're implicitly forall'ed (?)
17:08:22 * lpsmith thinks that dufflebunk has a mistaken instance Storable ForeignPtr around somewhere ;-)
17:08:23 <conal> that's what i was getting at in http://conal.net/blog/posts/fostering-creativity-by-relinquishing-the-obvious/
17:08:32 <mmorrow> (forall a. .... a ...) (forall a. .... a ....)
17:08:42 <mmorrow> (\a -> a) and (\a -> a)
17:08:51 <SamB_XP_> conal: I thought they were used when you couldn't see why something was the case ;-P
17:08:55 <conal> from the comments on that blog post, i couldn't tell that anyone got what i was saying.
17:08:56 <Saizan> mmorrow: if you can unify say Int -> Int with a -> a then a is not forall'ed
17:09:05 <EvilTerran> mmorrow, couldn't leaving out the occurs check still potentially get you in trouble in that case, say, unifying "(x, x)" with "(y, (y, y))"?
17:09:07 <mmorrow> Saizan: ahhh, maybe doing the "Exists" case has something to do with identifying the existential tyvars in the two types (???)
17:09:27 <dufflebunk> lpsmith: henh, I just did a grep. I do indeed have a definition in my code for a Storable (ForeignPtr a)
17:09:37 <mmorrow> EvilTerran: true, but that case can be checked after the fact actually in this particular code
17:09:41 <EvilTerran> (depending on what you're unifying, but it seems to me that an equivalent case could come up in a variety of expression langauges)
17:09:46 <mmorrow> EvilTerran: (i haven't done that step yet though)
17:09:46 <conal> SamB_XP_: and maybe when you'd like no one else to see why something *isn't* the case ;-P
17:09:54 <dons> hey guys, here's an interesting problem that came up at work. you have a list of values of a sum type (i.e. Either). what's the best way to determine if the list is all of one constructor?
17:10:01 <SamB_XP_> conal: clearly not!
17:10:04 <mmorrow> EvilTerran: http://moonpatio.com/repos/Unify.hs
17:10:33 <dons> i.e. either all Left _ or all Right _ ? (and then how do you generalize that to arbitrary numbers of constructors?)
17:10:37 <conal> if i could save only one of all my blog posts, that'd be the one.
17:10:59 <EvilTerran> dons, all isLeft where isLeft Left{} = True; isLeft _ = False -- ?
17:11:08 <lpsmith> dufflebunk:  yeah, you want to ax that.   In order for that to work correctly,  you'll need C to know at least a little bit about GHC values and the GHC runtime
17:11:34 <Saizan> you need a compareConstructors :: SumT -> SumT -> Bool
17:11:37 <sclv> two passes: map the constructors to enums
17:11:40 <dons> EvilTerran: but what if it is all Right ?
17:11:43 <sclv> then check that all the enums are equal
17:11:49 <Saizan> which you can write using Data.Data if you're inclined
17:11:51 <dons> sclv: yeah, that was my soln.
17:11:53 <sclv> you can do the first pass generically with reflection
17:11:58 <dons> surely there's a one pass soln though?
17:12:03 <dons> two passes feels inelegant
17:12:04 <EvilTerran> dons, ah, all of any constructor... that's trickier
17:12:07 <sclv> two passes fuse into one?
17:12:09 <mmorrow> EvilTerran: ah, actually in that code it returns the subst (a -> (a,a)), which is a perfectly valid infinite type ... ;)
17:12:19 <dons> sclv: yeah, right an accumulating fold
17:12:30 <dons> essentially all (== head xs) xs
17:12:36 <sclv> you going to hac-phi tomorrow?
17:12:39 <dons> but for constructors
17:12:45 <EvilTerran> mmorrow, oh, ok, if you're allowing infinite types...
17:12:50 <dons> no, i'm on the west coast.
17:13:02 <dons> too much travel this year :) but canada, then england next month
17:13:16 <EvilTerran> dons, uncurry (||) . (null *** null) . partitionEithers?
17:13:18 <sclv> heh. sounds busy enough for you.
17:13:23 <jimmyjazz14> what is the best way to test IO Bool without cluttering up my code?
17:13:25 <dons> EvilTerran: what's null ?
17:13:29 <dons> partiion is a good idea
17:13:31 <mmorrow> EvilTerran: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3079#a3081
17:13:34 <lpsmith> dons:  is the plan still to replace GHC list fusion with stream-fusion at some point?
17:13:38 <EvilTerran> dons, er, the prelude null
17:13:39 <EvilTerran> ?src null
17:13:40 <lambdabot> null []     = True
17:13:40 <lambdabot> null (_:_)  = False
17:13:44 <dons> oh, hehe
17:13:56 * dons has been reading too many void vs null vs zero posts
17:14:11 <EvilTerran> if it's all Left, the snd will be [], and if it's all Right, the fst will be []
17:14:18 <mmorrow> EvilTerran: i'll have to add that check though for the used-in-the-GADT-Read-deriving process though :(
17:14:20 <mmorrow> :)
17:14:37 <Saizan> jimmyjazz14: there aren't great solutions for that, except writing an ifM :: Monad m => m Bool -> m a -> m a
17:15:21 <dons> we need a caseM
17:15:23 <mmorrow> ahh perfect, so the occurs check just can be run over the result of that "unify" function
17:15:34 <mmorrow> how convenient
17:15:36 <lpsmith> caseM would be wonderful.  I agree completely
17:16:26 <sclv> >>= \x' -> case x' of... is a bit noisy, sure.
17:16:36 <mmorrow> s/occurs check/isInf function/
17:16:42 <mmorrow> (which is the same thing)
17:16:42 <jimmyjazz14> caseM would make sense
17:17:32 <flippeh_> Any good data type to represent a byte, or should I keep using Word8?
17:17:43 <dons> Word8 makes a good type to represent a byte.
17:17:57 <sclv> an alternate solution would be to have standard datatypes automatically generate their catamorphisms
17:18:51 <dons> yeah, that keeps coming up as useful
17:21:21 <Nereid_> http://www.cs.utah.edu/~hal/STPP/ <- here's something that provides mcase and mif
17:21:55 <dons> mm
17:22:20 <boyscared> question: i'm rebuilding ghc from source on freebsd, and got this warning: WARNING: unversioned dependencies are deprecated, and will NOT be accepted by GHC 6.10: hpc bytestring template-haskell readline unix Cabal base haskell98
17:22:28 <boyscared> any suggestions how to address that?
17:25:08 <kyagrd> Why do hackage give this wanring when I uplaod a library package? "Exposed modules use unallocated top-level names: Math"
17:25:10 <hackagebot> yices 0.0.0.1 - Haskell programming interface to Yices SMT solver (KiYungAhn)
17:25:30 <kyagrd> hackagebot: You are fast :)
17:41:39 <conal> i'm having trouble with with cabal not finding library .h files in os x.  i have INCLUDE set to /opt/local/include, which has GL/glew.h, but i get "error: GL/glew.h: No such file or directory" when i try to process a .hsc file that #includes GL/glew.h.  any ideas?
17:42:53 <lpsmith> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3082
17:43:13 <lpsmith> Is there any downside to the latter style of definition?
17:44:31 <lpsmith> The schemer in me would say the first version of my hpaste avoids allocating a closure,  but I know that this intuition doesn't apply all that well to GHC
17:44:41 <Cale> lpsmith: Uh, the first isn't exactly using stream-fusion.
17:44:52 <Cale> lpsmith: It's just a straightforward recursive definition.
17:45:24 <lpsmith> cale:  zipWIth is defined that way in stream-fusion:  the magic happens in the {-# RULES ... #-}
17:45:48 <conal> oh  maybe i want CPATH instead of INCLUDE
17:45:50 <Saizan_> conal: tried with --extra-inclide-dirs ?
17:46:41 <flippeh_> filter (/= B8.null) names
17:46:44 <flippeh_> Why does this fail?
17:46:49 <conal> Saizan_: no, i haven't.  i'll try that
17:46:52 <flippeh_> B8 is Data.ByteString.Lazy.Char8
17:46:52 <lpsmith> cale:  of course,  zipWith often gets rewritten to something else, sure :-)
17:46:56 <Cale> lpsmith: Well yes, if you want stream fusion, you'd need some additional rules. I'm a little surprised that it's not defined something like  zipWith f xs ys = fromStream $ zipWithStream (toStream xs) (toStream ys)
17:47:01 <flippeh_> Couldn't match expected type `B8.ByteString'
17:47:02 <flippeh_>        against inferred type `B8.ByteString -> Bool'
17:47:10 <Cale> lpsmith: though I suppose they use the rules to turn it into that.
17:47:23 <lpsmith> yeppers :-)
17:47:40 <lpsmith> That's not really my question though :-)
17:47:54 <Cale> So that recursive definition won't be used at all in stream fusion
17:47:57 <conal> Saizan_: that worked. :)
17:47:58 <Cale> anyway
17:48:08 <lpsmith> The point is,  the alternate zipWith' is a bit better if you want to inline that exact definition
17:48:11 <Saizan_> flippeh_: B8.null is a function, while names presumably contains bytestrings, you can't compare those
17:48:11 <conal> i'll also try CPATH.
17:48:12 <Cale> The only advantage I can see to the second version is that you're not passing f around
17:48:24 <Saizan_> flippeh_: maybe you want (not . B8.null) ?
17:48:33 <Cale> er, actually, there's a type error in it
17:48:42 <Cale> but modulo that type error ;)
17:48:53 <lpsmith> cale:  if you inline the second version,  GHC can then also inline f.  Whereas it won't touch f in the first version
17:48:58 <flippeh_> Yep, I certainly want that
17:49:01 <flippeh_> Thanks again :)
17:49:11 <Cale> Right.
17:49:23 <lpsmith> So that's the advantage.  I'm trying to figure out what the disadvantages to the style of definition, if any :)
17:49:29 <Cale> GHC isn't smart enough to recognise cases like that on its own yet.
17:49:51 <Cale> I would go with the simpler means of definition unless I determined that it actually mattered for the performance that I needed.
17:50:24 <lpsmith> Well, stylistically I somewhat prefer the latter, actually.
17:50:32 <lpsmith> I think it's slightly simpler
17:50:36 <Cale> eh?
17:50:43 <CalJohn> Not sure how to fix this type error.  Can someone help?: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7406#a7406
17:51:37 <Saizan_> CalJohn: give a type annotation to x
17:51:52 <lpsmith> cale:  you can change the name of zipWith' easier,  since it's not directly recursive,  and the recursive cases have fewer parameters, which I think is slightly easier to read
17:51:55 <Cale> CalJohn: The problem is that remote is apparently polymorphic in its result type, while print is polymorphic in its input type
17:52:06 <Cale> CalJohn: So it doesn't know what type you want x to be.
17:52:45 <Cale> lpsmith: But you're giving a name to something which doesn't really need to be named.
17:53:00 <Cale> Well, sometimes that style works out okay.
17:53:13 <CalJohn> but they are polymorphic on different typeclasses.  i am not sure myself which one show be.  perhaps both...
17:53:31 <CalJohn> Saizan_: yes, i think so to, but I'm not sure which one
17:53:34 <Saizan_> you need to pick a type that's an instance of both
17:53:35 <lpsmith> Cale:  Heh,  I call most of those things "loop".  So I view it as a very cheap name :-P
17:53:42 <Cale> CalJohn: so you need to pick a type which is in both Show and XmlRpcType
17:54:20 <Saizan_> CalJohn: the documentation for XmlRpcType should list the instances
17:54:44 <flippeh_> Okay, probably last question now. I've got... 7 lists, and a number. Every list contains one part of the information (In this case it's for a game, one list stores the score, the other stores the name, ...). The number is the amount of player I have, and I need to "loop" that many times and take the head from every list to get every information boundled. Help :((
17:55:00 <Cale> lpsmith: Well, don't let me stop you, but I find the direct recursive equations easier to read myself. (Or avoiding recursion altogether whenever possible)
17:55:38 <lpsmith> But I don't really care about debating style;  I'm much more interested in understanding the quantitative difference between the two definitions, relative to GHC :)
17:55:40 <Cale> flippeh_: Why separate lists?
17:55:42 <Saizan_> flippeh_: so the number is the length of the lists?
17:55:48 <flippeh_> That's how I get it from the server :(
17:55:56 <Cale> flippeh_: ah, okay
17:55:56 <flippeh_> The number is the amount of players I have
17:56:08 <flippeh_> I know it's kind of complicated
17:56:28 <flippeh_> scores !! 0 has the score of player ID 0
17:56:33 <flippeh_> names !! 0 has teh name of player ID 0
17:56:34 <flippeh_> And so on
17:56:57 <Saizan_> it seems like "take n $ zip7 list1 list2 ..."
17:57:10 <Saizan_> though i'd define a PlayerInfo type
17:57:15 <Cale> Or use zipWith7 and a proper datatype rather than a tuple
17:57:22 <flippeh_> I've got that player info type
17:57:22 <Saizan_> right
17:58:05 <Cale> Lucky that it goes up to 7 ;)
17:58:30 <Cale> I suppose if you needed more fields you could always do something like using Applicative and ZipList
17:58:57 <Cale> Or just do the zipping in stages
17:59:45 <flippeh_> Where are the zips located? :)
17:59:52 <Cale> Data.List
17:59:53 <Saizan_> Data.List
18:02:05 <ray> joyful.com!
18:06:38 <CalJohn> Cale: I don't understand what you mean by "pick a type", because I'm not really sure what the method normally returns, it's hard to guess...
18:06:59 <CalJohn> "probably" a list, but I don't really know
18:07:01 <Vanadium> Types are hard
18:07:02 <Vanadium> fuck'em
18:07:15 <lpsmith> cale:  I don't entirely disagree;  I like avoiding (explicit) recursion too.  :-)
18:10:08 <watermind> CalJohn:  sounds like you want as type,  Maybe List a
18:10:09 <watermind> :D
18:10:30 <watermind> I know I know... rubish joke... it's late :S
18:11:13 <Saizan_> CalJohn: it really depends on what the method you're calling is returning
18:11:31 <Saizan_> CalJohn: though it seems that using Value should always work
18:11:56 <Saizan_> CalJohn: since that's the "low-level" representation used for xml-rpc values
18:11:59 <hamishmack> Beelsebob: You can log leksah issues here... http://code.google.com/p/leksah/issues/list
18:15:40 <seliopou> I have a question about compiling recursive modules
18:15:53 <seliopou> is it possible when there's a cyclic dependency on datatypes/newtypes?
18:17:43 <ray> see http://haskell.org/haskellwiki/Mutually_recursive_modules
18:18:32 <CalJohn> Saizan_: I have looked as his example code an found that it returns something like IO (a)
18:18:35 <SamB_XP_> seliopou: possible? yes. can GHC avoid "The impossible happened"? well, since I think they changed that message, probably ;-P
18:18:40 <CalJohn> Saizan_: I don't understand how I was supposed to know that
18:19:07 <SamB_XP_> CalJohn: reading the implementation?
18:19:08 <seliopou> ughhhhhh, type parameters
18:19:25 <seliopou> That is the worst
18:19:26 <lpsmith> SamB_XP_:  aww,  I've often appreciated the humor in GHC error messages
18:19:53 <Saizan_> CalJohn: you can look there to see the instances of Remote http://hackage.haskell.org/packages/archive/haxr/3000.2.1/doc/html/Network-XmlRpc-Client.html#t%3ARemote
18:20:00 <SamB_XP_> lpsmith: maybe that one was just too confusing for newbies and/or theorem provers?
18:20:36 <Saizan_> CalJohn: however you could use the call function instead, which is monomorphic
18:20:40 <CalJohn> SamB_XP_: well, aside from that way
18:20:53 <aavogt> @ghc
18:20:54 <lambdabot> ghc says: Illegal binding of built-in syntax
18:20:56 <aavogt> @ghc
18:20:56 <lambdabot> ghc says: Urk infer
18:21:00 <aavogt> @ghc
18:21:01 <lambdabot> ghc says: No explicit method nor default method
18:21:02 <lpsmith> quick,  whats the fasted way to generate the "impossible just happened" error message?
18:21:14 <aavogt> @ghc brain
18:21:14 <lambdabot> ghc says: My brain just exploded.
18:21:20 <SamB_XP_> lpsmith: look for a ticket on trac?
18:21:24 <SamB_XP_> that's still open?
18:21:55 <inimino> @ghc
18:21:55 <lambdabot> ghc says: Illegal deriving item
18:22:17 <CalJohn> Saizan_: I have to be honest, but I don't really understand those type signatures.  Remote(IO a) doesn't make sense to me, because i know now it's just IO a
18:22:45 <Saizan_> CalJohn: do you understand typeclasses in general?
18:23:07 <CalJohn> i thought i did
18:23:21 <CalJohn> classes are things with certain functions defined over them
18:23:28 <CalJohn> *class members
18:23:56 <Saizan_> the functions are defined over the instances of a class
18:24:09 <Saizan_> a class is a collection of types, which are called instances
18:24:22 <Saizan_> (and open collection, since you can always add more)
18:24:40 <CalJohn> right, that's essentially my understanding too
18:24:50 <Saizan_> so Remote (IO a) there is saying that (IO a) is an instance of Remote
18:25:02 <Saizan_> Remote is not a type constructor
18:25:02 <CalJohn> yes
18:25:12 <CalJohn> yes
18:25:26 <lpsmith> SamB_XP_:  well,  I've only gotten the impossible error message in very specific setups... but
18:25:33 <Saizan_> so i don't understand your comment about "it's just IO a"
18:26:12 <CalJohn> wait, but Remote is used like a type constructor
18:26:15 <Saizan_> also, there's a typeclass context on that 'a', from the docs
18:26:18 <lpsmith> SamB_XP_:  a search of "strings /usr/local/lib/ghc-6.10.3/ghc"  turns up "panic! (the 'impossible' happened)"
18:26:27 <CalJohn> in the instances
18:26:31 <lpsmith> So it appears it hasn't been changed as of GHC 6.10.3
18:26:41 <SamB_XP_> or maybe they re-changed it ?
18:26:49 <SamB_XP_> could be either ;-))
18:26:50 <lpsmith> heh, dunno
18:26:56 <Saizan_> CalJohn: no, that's the way haddock displays instances
18:26:58 <SamB_XP_> woops, double chin or something
18:27:09 <CalJohn> SamB_XP_: what is?
18:27:20 <SamB_XP_> the "))" in that smiley
18:27:29 <CalJohn> *Saizan_: what is?
18:27:49 <lpsmith> SamB_XP_:  maybe they just use that message in fewer cases now
18:27:50 <Saizan_> CalJohn: e.g. XmlRpcType a => Remote (IO a)
18:28:08 <SamB_XP_> lpsmith: one would HOPE that that message would NEVER occur
18:28:17 <Saizan_> CalJohn: in the code you'd find "instance XmlRpcType a => Remote (IO a) where ..."
18:28:27 <SamB_XP_> though obviously if you use really evil TH you can make it happen anyway ;-)
18:29:17 <SamB_XP_> (I'm talking TH so evil it mutates immutable compiler-owned values ;-)
18:31:12 <CalJohn> Saizan_: oh, i see.  that was a kind of silly mistake to make
18:34:24 <JamesSanders> Data.Time is kinda akward
18:34:54 <thoughtpolice> @hackage datetime
18:34:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/datetime
18:35:03 <Vanadium> Are people regarding pattern-matching tuples with the same kind of bile as n+k patterns?
18:35:30 <ray> who did that?
18:35:32 <thoughtpolice> no?
18:35:39 <thoughtpolice> at least i have not seen any outlash or whatnot
18:35:40 <Vanadium> Okay, just wondering.
18:35:43 <CalJohn> Vanadium: i doubt it, because tuples are a kind of type constructor
18:35:54 <ray> the problem with n+k patterns is that + isn't a constructor at all
18:36:12 <hzap> the only way to get stuff in a tuple is pattern matching so ...
18:36:30 <thoughtpolice> also it's arguable that it requires a bit of library knowledge, because n+k are of type Integral a => a, which requires knowledge of type classes and some of the standard lib
18:36:52 <ray> http://www.patternnkfarm.com/
18:36:56 <CalJohn> i don't understand why anyone would add n+k patterns to the language, anyway.  they are such a minor thing, and they break rules
18:37:40 <SamB_XP_> CalJohn: why do you think we are taking them out again? we couldn't figure it out either!
18:37:48 <lpsmith> SamB_XP_:  heh,  we could start a website of GHC exploitz  :-P
18:37:55 <JamesSanders> hmm datetime should be part of the standard libraries
18:38:02 <thoughtpolice> iirc it was a compromise between the people designing haskell
18:38:19 <lpsmith> But seriously,  no software of sufficient complexity is perfect.   And "sufficient complexity" is pretty small.
18:38:38 <SamB_XP_> thoughtpolice: probably!
18:38:40 <CalJohn> thoughtpolice: who wanted them added?
18:38:43 <thoughtpolice> someone wanted n+k patterns to go, and someone else wanted something else to go/be added, and so they just compromised
18:38:51 <thoughtpolice> and n+k ended up being left in
18:38:54 <SamB_XP_> I think someone wanted views
18:38:58 <thoughtpolice> yeah, that was it
18:39:07 <thoughtpolice> CalJohn: see "A History of Haskell"
18:39:11 <SamB_XP_> but nobody had figured out how they'd work
18:39:14 <Saizan_> nice compromise that!
18:39:19 <CalJohn> thoughtpolice: ok, thanks
18:39:38 <SamB_XP_> so they thought "let's put in something like a special case of views!"
18:39:48 <davidL> @check \x -> if x == pi then False else True
18:39:49 <lambdabot>   "OK, passed 500 tests."
18:40:18 <Saizan_> there's no number like pi
18:40:45 <lpsmith> There is no number like 2 either :-D
18:40:50 <ray> there's no typeclass like Show typeclass
18:41:04 <davidL> > 3.141592653589793 == pi
18:41:05 <lambdabot>   True
18:41:07 <Saizan_> @check \x -> (x :: Double) > 1
18:41:08 <lambdabot>   "Falsifiable, after 0 tests:\n0.0\n"
18:41:18 <Saizan_> @check \x -> (x :: Double) <= 1
18:41:19 <lambdabot>   "Falsifiable, after 4 tests:\n3.0\n"
18:41:22 <Badger> > 3.141 == pi
18:41:23 <lambdabot>   False
18:41:28 <Badger> > pi
18:41:29 <lambdabot>   3.141592653589793
18:41:33 <Badger> ah
18:41:44 <Badger> > pi :: CReal
18:41:45 <lambdabot>   3.1415926535897932384626433832795028841972
18:41:53 <davidL> pi should really be one of quickcheck's test cases
18:42:39 <lpsmith> how many bits is a CReal?
18:42:49 <ray> it comes up with random test cases via an Arbitrary instance
18:42:56 <copumpkin> lpsmith: lots!
18:42:56 <Saizan_> lpsmith: arbitrary
18:43:07 <mmorrow> Saizan_: a working gadt-read http://moonpatio.com/repos/gadt-read/
18:43:08 <hzap> == on floating point isn't too effective anyways
18:43:18 <ray> floating point isn't too effective
18:43:30 <mmorrow> that took like more than 2 hours longer than i thought it would....
18:43:41 * mmorrow always underestimates how long things will take
18:44:14 <Saizan_> nice
18:44:24 <\}> object oriented programming >!= functional paradigm
18:44:38 <Saizan_> but we miss Show then!
18:44:44 <flippeh_> Man, this works awesome
18:44:48 <lpsmith> Saizan_:  arbitrary as in machine-dependent, or arbitrary arbitrary?
18:44:53 <Rotaerk> >!= ?
18:45:01 <mmorrow> Saizan_: it generates these instances for these gadt decls http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3079#a3085
18:45:06 <flippeh_> This is not like most other language I wrote stuff in. This compiles and ACTUALLY WORKS!
18:45:14 <hzap> (>!=) = (<) i guess
18:45:22 <pikhq> Rotaerk: Ah, the monadic strict unstrict bind.
18:45:22 <Rotaerk> yea maybe
18:45:23 <pikhq> :P
18:45:25 <flippeh_> No hard to spot "Oh I forgot to read a byte here" mistakes
18:45:37 * mmorrow goes to eat
18:45:39 <Saizan_> lpsmith: it's arbitrary precision, so don't expect them to be particulary fast
18:45:40 <Rotaerk> OOP strick unstrict FP
18:45:45 <Rotaerk> hmm
18:46:02 <hzap> Roaterk: ?
18:46:02 <davidL> Saizan_: can you specify a precision?
18:46:12 <Baughn> pikhq: Nonono, that's the unstrict recursive bind
18:46:19 <pikhq> Baughn: Right.
18:46:31 <pikhq> How right you are.
18:46:31 <pikhq> :)
18:46:46 <\}> meaning functional < oop
18:47:03 <pikhq> \}: Bullshit.
18:47:26 <Rotaerk> \}, you can't compare FP and OOP like that... they aren't mutually exclusive or anything
18:47:34 <hzap> \}: but >!= means < right?
18:47:44 <hzap> "not greater than or equal to"
18:47:52 <hzap> :D
18:47:57 <Saizan_> davidL: i think so, the documentation should tell
18:47:59 <lpsmith> Ahh,  CReal is exact, not arbitrary :-P
18:48:03 <Saizan_> @hoogle CReal
18:48:03 <lambdabot> No results found
18:48:46 <Saizan_> http://hackage.haskell.org/packages/archive/numbers/2009.5.28.1/doc/html/Data-Number-CReal.html#v%3AshowCReal
18:49:10 <Saizan_> hzap: or maybe the ! is just for emphasis
18:49:11 <davidL> aha
18:49:30 <Baughn> hzap: I'm pretty sure you're thinking of >/=
18:49:48 <Rotaerk> FP is more comparable to procedural, and OOP to pattern matching and discriminated unions
18:50:05 <Rotaerk> or maybe type classes
18:50:08 <davidL> > showCReal 200 pi
18:50:09 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
18:50:13 <\}> c++ = #1
18:50:13 <lpsmith> ((1 + sqrt 5)**1000000) / sqrt 5
18:50:14 <vav> Baughn: or is it "strictly greater than or equal to"
18:50:24 <lpsmith> ((1 + sqrt 5)**1000000) / sqrt 5 :: CReal
18:50:28 <lpsmith> >  ((1 + sqrt 5)**1000000) / sqrt 5 :: CReal
18:50:33 <lambdabot>   mueval-core: Prelude.read: no parse
18:50:33 <lambdabot>  mueval: ExitFailure 1
18:50:41 <pikhq> \}: How many lines is cat in C++ (with argument handling)?
18:50:44 <Saizan_> anyway, we have O'Haskell, so that's settled :)
18:50:53 <Baughn> vav: Hm. Perhaps it's an FP-specific version of >=
18:50:58 * CalJohn gets the impression that there is a troll in the channel...
18:51:05 <\}> yoohoo
18:51:07 <lpsmith> >  (((1 + sqrt 5) ** 1000000 ) / sqrt 5) :: CReal
18:51:10 <\}> yoooooohooooo
18:51:10 <pikhq> Mi ankaû.
18:51:12 <lambdabot>   mueval-core: Prelude.read: no parse
18:51:12 <lambdabot>  mueval: ExitFailure 1
18:51:19 <vav> no, it's under the null pointer, not really here
18:51:27 <lpsmith> >  (((1 + sqrt 5) ** 100 ) / sqrt 5) :: CReal
18:51:29 <lambdabot>   449033341410194799297186300014146470742593511175372.23130083868189821871171...
18:51:38 <SamB_XP_> CalJohn: Rotaerk or \}
18:51:39 <SamB_XP_> ?
18:51:39 <lpsmith> >  (((1 + sqrt 5) ** 10000 ) / sqrt 5) :: CReal
18:51:44 <lambdabot>   mueval-core: Prelude.read: no parse
18:51:45 <lambdabot>  mueval: ExitFailure 1
18:51:50 <lpsmith> >  (((1 + sqrt 5) ** 1000 ) / sqrt 5) :: CReal
18:51:52 <lambdabot>   465747906863118952927238104995592399669312172633620631691046475188746708087...
18:51:54 <ray> i don't know why you would throw around the t-word in public
18:51:58 * Saizan_ still wants to find where that Prelude.read error comes from
18:52:11 <ray> me too
18:52:16 <hzap> me three
18:52:20 <\}> me four
18:52:42 <Rotaerk> SamB_XP_, how would anything I said be construed as trolling?
18:52:48 <pikhq> \}: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7408#a7408
18:52:51 <SamB_XP_> Rotaerk: dunno
18:53:20 <SamB_XP_> but that bit about procedural and OO was about as incomprehensible as some of keal's stuff!
18:53:36 <Rotaerk> really?
18:53:50 <ray> it is kinda incomprehensible
18:53:54 <ray> :/
18:54:03 <Saizan_> i guess it was just referring to the expression problem?
18:54:10 <Rotaerk> Saizan_, yep
18:54:25 <SamB_XP_> hmm. is that harder than the halting problem?
18:54:35 <Rotaerk> it's entirely unrelated ..
18:54:39 <Rotaerk> :P
18:54:56 <ray> i think it's a bit easier
18:54:57 <SamB_XP_> can you prove that ?
18:55:06 <Saizan_> well, the halting problem is solved :)
18:55:19 <Rotaerk> the expression problem has many solutions, some better than others
18:55:19 <SamB_XP_> the "entirely unrelated", I mean
18:55:31 <pikhq> @faq Can Haskell solve the halting problem?
18:55:31 <lambdabot> The answer is: Yes! Haskell can do that.
18:55:38 <Rotaerk> the goal is to solve it without being cumbersome
18:55:47 <ray> the halting problem is solved, the solution is that halting is insoluble
18:56:01 <pikhq> ray: But GHC has a halting oracle!
18:56:12 <ray> yes. it's only insoluble in general
18:56:22 <Rotaerk> @faq Can Haskell peel bananas?
18:56:22 <lambdabot> The answer is: Yes! Haskell can do that.
18:56:31 <Rotaerk> orly
18:56:33 <ray> @faq can haskell peel bananas with lenses?
18:56:33 <lpsmith> bah,  error in my binet's formula.  Oh well.
18:56:33 <lambdabot> The answer is: Yes! Haskell can do that.
18:57:10 <SamB_XP_> ray: that's not a solution!
18:57:18 <SamB_XP_> that's a proof of nonsolution!
18:57:35 <lpsmith> >  ((((1 + sqrt 5) / 2) ** 1000 ) / sqrt 5) :: CReal
18:57:35 <ray> and the "halting problem" here is "can you make a universal halting oracle"
18:57:37 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
18:57:52 <SamB_XP_> ray: but, can it peel barbed wire with bananas?
18:58:10 <ray> yes! haskell can do that
18:58:13 <ray> @quote infinitely
18:58:13 <lambdabot> Berengal says: [On infinitely fast computers] The OS probably has a failsafe built in: If a program is  running it's in an infinite loop and needs to be killed...
18:58:36 <SamB_XP_> lol
18:58:46 <Rotaerk> SamB_XP_, to make it clear:  in OO you define interfaces (collections of operations), and you implement these interfaces in terms of an arbitrary number of data models.  You can extend the data models by just adding a new subclass, but it's harder to extend the operations.  (this typically involves diamond heirarchies... multiple inheritance)
18:58:56 <SamB_XP_> Berengal: but what if it's a server program?
18:59:11 <SamB_XP_> those are supposed to keep running until explicitly restarted or hung!
18:59:16 <Baughn> SamB_XP_: "Running", as opposed to "blocked waiting on I/O"
18:59:16 <lpsmith> > foldl (snd &&& uncurry (+)) (0,1) 1000
18:59:18 <lambdabot>   Couldn't match expected type `b -> (b1, b1)'
18:59:24 <SamB_XP_> oh
18:59:28 <SamB_XP_> that kind of running
18:59:32 <lpsmith> > iterate (snd &&& uncurry (+)) (0,1) !! 1000
18:59:33 <lambdabot>   (43466557686937456435688527675040625802564660517371780402481729089536555417...
18:59:46 <Baughn> SamB_XP_: http://www.frc.ri.cmu.edu/~hpm/project.archive/general.articles/1991/TempComp.html <-- Also see this
18:59:54 <Baughn> For an actual implementation. :D
19:00:08 <SamB_XP_> I guess there never will be infinitely fast users to go with such a computer ;-)
19:00:24 <Baughn> There.. could be
19:00:28 <Baughn> They'd just have to be uploads
19:00:37 <Rotaerk> SamB_XP_, with pattern matching, on the other hand, you can define discriminated unions (collections of data models), and then implement an arbitrary number of functions in terms of each of the data models using pattern matching.  you can extend the operations by writing new functions, but it's harder to add new data models.
19:00:44 * Baughn quietly freaks out at the consequences
19:01:09 * pikhq <3 the Infinity Machine
19:01:17 <SamB_XP_> Rotaerk: okay, sensible so far
19:01:18 <Rotaerk> SamB_XP_, the expression problem is finding a way to do both at the same time, in a non-cumbersome way
19:01:22 <SamB_XP_> but where does "FP" come in?
19:01:31 <Rotaerk> FP = functional programming
19:01:38 <Cale> > map fst . iterate (snd &&& uncurry (+)) $ (0,1)
19:01:39 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:01:43 <SamB_XP_> yeah -- I *know* that
19:01:51 <Rotaerk> and that wasn't part of the "OO and pattern matching" dichotomy I suggested
19:01:54 <SamB_XP_> what kind of an idiot do you think I am?
19:02:07 <SamB_XP_> Rotaerk: ah
19:02:07 <Rotaerk> well you quoted it, as though you didn't recognize it
19:02:20 <\}> big one
19:02:22 <SamB_XP_> well, maybe I thought you had a wierd idea of what it might be ;-)
19:02:35 <SamB_XP_> \}: thankfully I've stopped growing taller
19:02:41 <Rotaerk> FP vs procedural was the other dichotomy...
19:02:45 * Baughn has had people confusing it with formal programming in the past
19:02:47 <SamB_XP_> I was hitting my head on enough doorways ...
19:02:50 <Rotaerk> i.e. different paradigms for describing algorithms
19:02:59 <SamB_XP_> don't need to hit it on more!
19:03:06 <SamB_XP_> Rotaerk: ah
19:03:12 <pikhq> haltp f = infinity f >> wait >> return running f -- <3 infinity machine so much
19:03:14 <ray> i hit my head on enough floors, so it would be cool if i started growing again
19:03:25 <SamB_XP_> ray: what the ?
19:03:25 <copumpkin> \}: interesting nick
19:03:43 <ray> how is that legal but _|_ isn't
19:03:59 <pikhq> Cale: That is a nice bit of fibonacci.
19:04:00 * SamB_XP_ wonders if |] will trigger highlighting
19:04:25 <Cale> pikhq: I was just following lpsmith's line :)
19:04:34 <pikhq> Still. :)
19:04:40 <lpsmith> @unpl  (iterate (snd &&& uncurry (+)) !!)
19:04:41 <lambdabot> (\ a -> (iterate (snd &&& (uncurry (+)))) !! a)
19:04:44 <Cale> Traditionally, FP favours the style of relatively fixed discriminated unions with flexible sets of operations defined on them, and OO favours fixed products of operations, with flexible variations on their implementation.
19:04:49 <ray> thanks, @unpl
19:04:52 <ray> thunpl
19:04:56 <lpsmith> @unpl  (snd &&& uncurry (+))
19:04:57 <lambdabot> (snd &&& (uncurry (+)))
19:05:06 <Cale> But nothing says that you have to do it one way or the other just because you're using an FP or OO language.
19:05:12 <lpsmith> oh,  &&& is arrows in general, that's why
19:06:30 <ray> samb_xp_: if i use a dodgy script to convince irssi that the server has changed my name to the empty string, every line highlights me
19:06:36 <lpsmith> @unpl  (snd &&& uncurry (+)) :: (Integer, Integer) -> (Integer, Integer)
19:06:36 <lambdabot> (snd &&& (uncurry (+))) :: (Integer, Integer) -> (Integer, Integer)
19:06:52 <\}> @faq Can Haskell make me attractive?
19:06:52 <lambdabot> The answer is: Yes! Haskell can do that.
19:07:45 <lpsmith> the name "uncurry" strikes me as a little verbose,  but I'm not sure I have a better suggestion
19:08:07 <lpsmith> @pl  (\(x,y) -> (y, x+y))
19:08:07 <lambdabot> uncurry (ap (,) . (+))
19:08:12 <copumpkin> ncry
19:08:14 <\}> @faq Can Haskell enlarge my weiner?
19:08:14 <lambdabot> The answer is: Yes! Haskell can do that.
19:08:24 <ray> samb_xp_: also, irc casemapping means {}|^ are lowercase []\~
19:08:45 <ray> lpsmith: well, what else to name a function that uncurries things
19:08:51 <ray> unschoenfinkel?
19:09:05 <SamB_XP_> ray: except this network specifies ascii ;-)
19:09:14 <copumpkin> \}: probably, but it can enlarge your mind better
19:09:24 <SamB_XP_> but, does \} get highlighted when I say
19:09:27 <SamB_XP_> |]
19:09:28 <ray> ascii casemapping is STUPID and WRONG, incidentally
19:09:36 <ray> (for irc)
19:09:37 <SamB_XP_> ray: why is it wrong ?
19:09:49 <SamB_XP_> I mean that's what it tells your client!
19:10:17 <ray> it's wrong for arbitrary reasons like "rfc1459 says so"
19:10:21 <SamB_XP_> sure, it's not in the rfc, but there WAS a draft
19:10:36 <flippeh_> @src zipWith7
19:10:37 <lambdabot> Source not found. You speak an infinite deal of nothing
19:10:39 <SamB_XP_> rfc1459 is wrong ;-P
19:10:47 <ray> i'm just expressing my irc political views (rfc1459 literalist, no services)
19:11:13 <dibblego> flippeh_, you might like to use ZipList and its Applicative
19:11:25 <flippeh_> I think so
19:11:31 <flippeh_> I'll need a zipWith10 for my next update
19:11:34 <SamB_XP_> ray: numeric 5 just isn't what the RFC says it is, and that's final!
19:12:24 <ray> irc is not a living document
19:14:38 <lpsmith> @let g = fst . dropWhile ((/= 0) . snd) . iterate (snd &&& mod)
19:14:39 <lambdabot>  <local>:9:54:
19:14:39 <lambdabot>      Occurs check: cannot construct the infinite type:
19:14:39 <lambdabot>        ...
19:15:01 <Saizan_> map fst ?
19:15:11 <lpsmith> @let g = fst . head . dropWhile ((/= 0) . snd) . iterate (snd &&& mod)
19:15:13 <lambdabot>  <local>:9:61:
19:15:13 <lambdabot>      Occurs check: cannot construct the infinite type:
19:15:13 <lambdabot>        ...
19:15:41 <ray> samb_xp_: although, you are correct, since that numeric is only in false rfcs, and not reserved
19:15:47 <Saizan_> ?type (snd &&& mod)
19:15:49 <lambdabot> forall a c. (Integral (a, c)) => (a, c) -> (c, (a, c) -> (a, c))
19:16:06 <Saizan_> ?type iterate
19:16:07 <lambdabot> forall a. (a -> a) -> a -> [a]
19:16:21 <Saizan_> that's not going to match :)
19:16:41 <lpsmith> @let g = fst . head . dropWhile ((/= 0) . snd) . iterate (snd &&& uncurry mod)
19:16:48 <lambdabot>  Defined.
19:17:01 <lpsmith> Now, what does g do?  :)
19:17:10 <SamB_XP_> ray: "false rfcs"?
19:18:19 <lpsmith> And, for extra credit,  what is g's relationship to the fibonacci sequence?
19:18:35 <ray> you know the ones i mean, the ones whose numbers begin with 2
19:18:54 <Berengal> I just had the weirdest dream. I dreamt I was programming in jvm bytecode becase java was too verbose and restrictive
19:19:08 <mmorrow> * SamB_XP_ wonders if |] will trigger highlighting
19:19:19 <mmorrow> the annoying thing with a lot of highlighters is how
19:19:22 <mmorrow> , 'Just
19:19:24 <lunabot>  Data.Maybe.Just
19:19:33 <Saizan_> lpsmith: gcd?
19:19:39 <lpsmith> yep
19:19:39 <mmorrow> screws up the everything until another "unmatched" '\''
19:20:17 <lpsmith> > g (45, 25)
19:20:18 <lambdabot>   Ambiguous occurrence `g'
19:20:18 <lambdabot>  It could refer to either `L.g', defined at <local...
19:20:23 <ray> i think he meant irc highlighting, mmorrow
19:20:25 <lpsmith> > local.g (45, 25)
19:20:26 <lambdabot>   Ambiguous occurrence `g'
19:20:26 <lambdabot>  It could refer to either `L.g', defined at <local...
19:20:33 <mmorrow> ray: :o
19:20:39 <lpsmith> @let mygcd = fst . head . dropWhile ((/= 0) . snd) . iterate (snd &&& uncurry mod)
19:20:40 <lambdabot>  Defined.
19:20:41 <mmorrow> ray: irc highlighting?
19:20:48 <ray> mmorrow: like this
19:20:51 <lpsmith> > mygcd (45, 20)
19:20:53 <lambdabot>   5
19:20:59 <lpsmith> > mygcd (45, 27)
19:21:01 <lambdabot>   9
19:21:12 <ray> though i had a bit of trouble trying to figure out what you were talking about
19:21:22 <pikhq> > curry mygcd $ 45 27
19:21:24 <lambdabot>   Add a type signature
19:21:34 <pikhq> Thinkotastic.
19:21:36 <mmorrow> ray: so you mean as in my nick was highlighted because you said "mmorrow"?
19:21:40 <ray> yeah
19:21:44 <mmorrow> ray: is "|]" a valid nick?
19:21:50 <mmorrow> \nick |]
19:21:57 <|]> ha
19:21:58 <|]> ok
19:22:18 <ray> there's this \} guy in here
19:22:22 <Saizan_> that looked like you morphed into a robot
19:22:33 <mmorrow> Saizan_: well maybe i did
19:23:12 <lpsmith> > uncurry (mygcd 45 27)
19:23:13 <lambdabot>   Overlapping instances for GHC.Show.Show ((a, b) -> c)
19:23:13 <lambdabot>    arising from a use...
19:23:26 <lpsmith> > uncurry mygcd 45 27
19:23:27 <lambdabot>   No instance for (GHC.Real.Integral (b -> t -> a))
19:23:27 <lambdabot>    arising from a use of ...
19:23:32 <Saizan_> > curry mygcd 45 27
19:23:34 <lambdabot>   9
19:23:38 <lpsmith> duh
19:23:46 <lpsmith> brainfart there
19:25:16 * mmorrow just registered |]
19:26:17 <pikhq> I need to stop using $ so much.
19:26:20 <lpsmith> Aww, no extra credit?   The answer has to do with the first practical application of the fibonacci sequence!
19:26:21 <ray> samb_xp_: where is your ascii casemapping now
19:26:24 <mmorrow> pikhq: use (.)!
19:26:34 <pikhq> mmorrow: Yuh.
19:27:02 <vav> > takeWhile ((/=) 0 . fst) $ iterate (snd &&& uncurry mod) (4181,2584)
19:27:03 <lambdabot>   [(4181,2584),(2584,1597),(1597,987),(987,610),(610,377),(377,233),(233,144)...
19:28:27 <Saizan_> lpsmith: something about the complexity?
19:28:57 <lpsmith> indeed.  The worst case performance of the euclidean algorithm happens on adjacent pairs of fibonacci numbers.
19:29:14 <Saizan_> uh
19:29:40 * Saizan_ 'd like to see the proof
19:29:49 <lpsmith> And since binet's formula demonstrates the fibonacci sequence grows exponentially,  gcd is O(log n)
19:31:23 <mmorrow> , let fibs = let go !m !n = m : go n (m+n) in go 0 1; diff = fmap (uncurry (-)) . ap zip tail in diff fibs
19:31:24 <lunabot>  [-1,0,-1,-1,-2,-3,-5,-8,-13,-21,-34,-55,-89,-144,-233,-377,-610,-987,-159...
19:31:31 <mmorrow> , let fibs = let go !m !n = m : go n (m+n) in go 0 1; diff = fmap (uncurry subtract) . ap zip tail in diff fibs
19:31:32 <lunabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1...
19:31:58 <mmorrow> @let diff = fmap (uncurry subtract) . ap zip tail
19:31:59 <lambdabot>  Defined.
19:32:18 <SamB_XP_> ray: you still didn't explain what you meant by "false RFCs"
19:32:25 <mmorrow> @let diffN n = foldr (.) id (replicate n diff)
19:32:26 <lambdabot>  Defined.
19:32:50 <ray> yes i did
19:32:57 <ray> the 2xxx ones
19:32:58 <mmorrow> @let fibs = let go m n = m `seq` m : go n (m+n) in go 0 1
19:32:59 <lambdabot>  Defined.
19:33:01 <lpsmith> Fibonacci-like sequences also appear with AVL trees:  the fibonacci trees are the maximally unbalanced AVL trees.
19:33:09 <mmorrow> > diffN 1 fibs
19:33:10 <SamB_XP_> ray: oh, missed it
19:33:11 <lambdabot>   [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
19:33:12 <mmorrow> > diffN 2 fibs
19:33:14 <lambdabot>   [-1,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,...
19:33:18 <SamB_XP_> you didn't say my nick ;-P
19:33:23 <mmorrow> > diffN 3 fibs
19:33:25 <lambdabot>   [2,-1,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,676...
19:33:43 <mmorrow> um
19:33:58 <mmorrow> :o
19:34:12 <mmorrow> heh, diff fibs == fibs ..
19:34:19 <mmorrow> (of course)
19:34:34 <mmorrow> well, except for the noise at the start
19:35:20 <lpsmith> Not exactly noise,  that's the generalization of the fibonacci sequence in the other direction...
19:35:36 <mmorrow> hmm true
19:35:40 <Berengal> Is it a generalization though
19:35:59 <mmorrow> not sure
19:36:10 <Berengal> Does the definition of the fibonacci numbers specifically state >(=) 0 somewhere?
19:36:22 <Saizan_> > diffN 10 fibs
19:36:23 <lambdabot>   [-55,34,-21,13,-8,5,-3,2,-1,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,...
19:36:29 <mmorrow> > reverse . takeWhile (/=0) . diffN 100 $ fibs
19:36:30 <lambdabot>   [1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,-2584,4181,-67...
19:36:40 <mmorrow> > drop 1 fibs
19:36:42 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:37:08 <mmorrow> i guess it's fibs with every other element negated
19:37:18 <mmorrow> not sure exactly what that means
19:37:55 <SamB_XP_> ray: so do you think *all* 2xxx RFCs are false ?
19:37:56 <mmorrow> @let sbif = reverse . takeWhile (/=0) . diffN 100 $ fibs
19:37:58 <lambdabot>  Defined.
19:38:02 <Berengal> mmorrow: The definition 'f_2 = f_1 + f_0' still works
19:38:06 <ray> just the four that claim to be about irc
19:38:10 <mmorrow> > zipWith (+) fibs sbif
19:38:11 <lambdabot>   [1,0,3,-1,8,-3,21,-8,55,-21,144,-55,377,-144,987,-377,2584,-987,6765,-2584,...
19:38:15 <SamB_XP_> ray: ah
19:38:18 <ray> i mean, look at the crap that's in there
19:38:21 <ray> !channels wtf
19:38:22 <mmorrow> > zipWith (+) (drop 1 fibs) sbif
19:38:23 <lambdabot>   [2,0,4,0,10,0,26,0,68,0,178,0,466,0,1220,0,3194,0,8362,0,21892,0,57314,0,15...
19:38:35 <aavogt> > revfibs = 1:(-1) : zipWith subtract revfibs (tail revfibs)
19:38:37 <lambdabot>   <no location info>: parse error on input `='
19:38:45 <aavogt> > let revfibs = 1:(-1) : zipWith subtract revfibs (tail revfibs) in revfibs
19:38:46 <lambdabot>   [1,-1,-2,-1,1,2,1,-1,-2,-1,1,2,1,-1,-2,-1,1,2,1,-1,-2,-1,1,2,1,-1,-2,-1,1,2...
19:39:00 <aavogt> > let revfibs = 1:2 : zipWith subtract revfibs (tail revfibs) in revfibs
19:39:02 <lambdabot>   [1,2,1,-1,-2,-1,1,2,1,-1,-2,-1,1,2,1,-1,-2,-1,1,2,1,-1,-2,-1,1,2,1,-1,-2,-1...
19:39:03 <mmorrow> > sbif
19:39:04 <lambdabot>   [1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,-2584,4181,-67...
19:39:29 <Berengal> > let fibs = 0:(-1):zipWith (-) (tail fibs) fibs in fibs
19:39:31 <lambdabot>   [0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1...
19:39:34 <Berengal> Meh
19:39:42 <SamB_XP_> ray: so what you actually meant was RFC281[0-3]
19:41:00 <Berengal> > let fibs = 8:5:zipWith (-) fibs (tail fibs) in fibs
19:41:01 <lambdabot>   [8,5,3,2,1,1,0,1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,...
19:41:21 <mmorrow> > zipWith (*) (cycle [1,-1]) (drop 1 fibs)
19:41:22 <lambdabot>   [1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,-2584,4181,-67...
19:41:24 <mmorrow> @sbif
19:41:24 <lambdabot> Maybe you meant: bf bid
19:41:28 <mmorrow> > sbif
19:41:29 <lambdabot>   [1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,-2584,4181,-67...
19:42:02 <mmorrow> ahhh
19:42:31 <mmorrow> > (fmap (uncurry (+)) . ap zip tail) sbif
19:42:33 <lambdabot>   [0,1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,-2584,4181,-...
19:42:36 <pikhq> @src diffN
19:42:36 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:42:50 <mmorrow> > (fmap (uncurry (+)) . ap zip tail) (0 : sbif)
19:42:51 <lambdabot>   [1,0,1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,-2584,4181...
19:43:21 <mmorrow> @let pairs (a:b:cs) = (a,b) : pairs cs; pairs _ = []
19:43:22 <lambdabot>  Defined.
19:43:30 <dufflebunk> Anyone know the name of a general purpose algorithm for comparing trees (as in acyclic graphs)? I'm just looking for a starting point and google isn't giving me anything terribly useful.
19:43:40 <mmorrow> > (fmap (uncurry (+)) . pairs) (0 : sbif)
19:43:41 <lambdabot>   [1,1,2,5,13,34,89,233,610,1597,4181,10946,28657,75025,196418,514229,1346269...
19:43:49 <mmorrow> almost
19:45:13 <Baughn> dufflebunk: Comparing in what sense? What are you testing for?
19:45:18 <mmorrow> @let zipT (<>) (Node a as) (Node b bs) = Node (a<>b) (zipWith (zipT (<>)) as bs)
19:45:19 <lambdabot>  Defined.
19:45:45 <mmorrow> @type and . flatten . zipT (==)
19:45:46 <lambdabot>     Couldn't match expected type `Tree a'
19:45:46 <lambdabot>            against inferred type `Tree t -> Tree Bool'
19:45:46 <lambdabot>     In the second argument of `(.)', namely `zipT (==)'
19:46:08 <mmorrow> @type \a b -> (and . flatten) (zipT (==) a b)
19:46:09 <lambdabot> forall t. (Eq t) => Tree t -> Tree t -> Bool
19:46:30 <mmorrow> that loses info though on account of zip
19:47:46 <mmorrow> it's kind of a glaring omission that there's no (std) function to get at the pieces that zip drops
19:48:18 <mmorrow> "glaring" because there's no way to get that with the std functions
19:48:47 <SamB_XP_> is zip possible to fuse ?
19:49:03 <mmorrow> not sure. fuse how?
19:49:17 <dufflebunk> Baughn: comparing for differences...  I have two tree structures (multiple root nodes, multiple nodes can also have the same child). And I need to compare the values of the nodes between the trees. But the nodes are unordered (?) so I don't know which siblings match between trees.
19:49:32 <mmorrow> SamB_XP_: i think there's some kinda foldr/build analog thing for zip iirc
19:49:54 <dufflebunk> Baughn: So although I can write something that'll probably work, I'm just wondering if there's already well known algorithms for doing it well
19:50:12 <mmorrow> dufflebunk: usually ordering matters
19:50:32 <mmorrow> dufflebunk: so in your case you may need to invent something
19:50:37 <lpsmith> fucking ay,  my keyboard just took a dump
19:50:52 <lpsmith> Acting like a loose wire
19:51:00 <mmorrow> (like, unification is essentially zipping two trees, then mapping each to a common target tree)
19:51:26 <mmorrow> where the "common target tree" is computed by comparing the differences
19:51:38 <mmorrow> differences/whatever
19:52:27 <mmorrow> dufflebunk: err, wait what do you mean "unordered"
19:52:29 <mmorrow> ?
19:52:54 <Taggnostr> I wrote a program that creates a list of 200k numbers, but when I print it, only the first 45152 are printed
19:53:12 <lpsmith> dufflebunk:  bisimulation would work,  although it's a bit overkill
19:53:28 <mmorrow> dufflebunk: if you're (implicitly or otherwise) identifying two different nodes as equivalent (wrt some (==)), then you've really got a graph
19:53:48 <Taggnostr> any idea about what could cause that?
19:53:53 <dufflebunk> I mean if a node has two children, there's no ordering between the two sibling... so not like a btree or binary tree.
19:54:01 <mmorrow> and in that case maybe representing it explicitly as a graph might lead to an easier task
19:54:36 <mmorrow> dufflebunk: ok, is that different than the usual definition of "tree"?
19:54:42 <lpsmith> I'm sure what dufflebunk is asking for exists,  and I think I know what it looks like,  but I don't know what'd be called off the top of my head
19:54:44 <mmorrow> oh wait
19:54:49 <aavogt> mmorrow: there is '(dropWhile .) . length', perhaps the versions that use lazy Naturals could be bearable
19:54:50 <mmorrow> NOT like a binary tree
19:55:21 * mmorrow still doesn't understand "unordered" here
19:55:24 <mmorrow> aavogt: hmm
19:55:25 <dufflebunk> mmorrow: acyclic graph would be a better name for what I'm comparing
19:55:30 <lpsmith> dufflebunk:  you could basically just do a graph reachability on the cross product
19:55:35 <mmorrow> dufflebunk: ah ok sure
19:56:01 <mmorrow> dufflebunk: might as well also consider it directed
19:56:13 <mmorrow> since a tree in haskell is just that
19:56:17 <mmorrow> (no back links..)
19:56:29 <mmorrow> s/tree/data/
19:56:55 <mmorrow> (unless you construct them with fix/letrec)
19:57:00 <lpsmith> i.e. if you represent a graph as (a -> [a],  a -> b),  where "a" is node identifiers
19:57:07 <lpsmith> and "b" is labels
19:57:45 <mmorrow> i like (Map a (Set a)), then you can do  g ! a = maybe mempty id (M.lookup a g)
19:58:02 <mmorrow> (g !) :: a -> Set a
19:58:05 <hzap> Taggnostr: what's the code?
19:58:36 <lpsmith> cross (children, label) (children', label') = (\(a,b) -> [(a',b') | a' <- children a,  b' <- children' b] , label *** label')
19:59:04 <Taggnostr> hzap, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6130#a6135
19:59:08 <lpsmith> not sure if you could do better though or not...
20:00:01 <lpsmith> You could probably do better... hmm...
20:00:42 <Baughn> Before I start hacking, could someone familiar with template haskell tell me if it's possible to enumerate all the data-types defined in the module I'm invoking it from?
20:00:58 <Baughn> (For the purpose of deriving data-accessors for all of them)
20:01:00 <lpsmith> Although that should often work well in practice:  it would be linear if the graphs are equal,  and if the graphs aren't equal it shouldn't take that long to show they aren't, in most cases.
20:01:09 <mmorrow> Baughn: not with TH, but you can do that by
20:01:21 <Taggnostr> hzap, run it with 1e100000
20:01:30 <mmorrow> Baughn: using (location :: Q Loc), which includes the FilePath of the current module
20:01:34 * dufflebunk has to look up ***
20:01:42 <mmorrow> Baughn: then readFile it and parse with haskell-src-exts
20:01:56 <Baughn> mmorrow: So - not quite easily, but possible.
20:02:03 <mmorrow> Baughn: there's code in haskell-src-meta to translate from the haskell-src-exts AST to the TH AST
20:02:06 <hzap> umm interesting
20:02:10 <Baughn> mmorrow: I think I'll write an emacs function to add the deriving call instead. :)
20:02:17 <mmorrow> Baughn: (although some of the Dec cases are incomplete..)
20:02:17 <lpsmith> Dufflebunk:  although you could use the fact that if they are equal,  that it would be linear to cut things off if they take too long...
20:02:21 * dufflebunk now has to look up more stuff related to ***
20:02:35 <Baughn> mmorrow: Also, do you know if there's any interest in moving data-accessors into GHC proper?
20:02:39 <mmorrow> Baughn: most of the cases are there though (incomplete only because i'm lazy..)
20:02:40 <dufflebunk> lpsmith: These aren't huge graphs, they are less than 1000 nodes
20:02:42 <hzap> Taggnostr: that's weird
20:02:52 <Taggnostr> can you reproduce it?
20:02:53 <dufflebunk> so speed isn't a big problem
20:02:59 <mmorrow> Baughn: i'm not sure. i haven't used Data.Accessor myself
20:03:12 <mmorrow> Baughn: oh, "data-accessors" in general
20:03:15 <mmorrow> Baughn: not sure
20:03:28 <hzap> Taggnostr: yes, it stopped after a while, and when I tried to Ctrl-C it, it kept going ...
20:03:42 <Taggnostr> I'm trying now with ghci -e '[1..1e100000]' and it seems to work fine
20:04:16 <Baughn> mmorrow: It looks pretty nice. If you haven't looked very closely at it, you probably should. :)
20:04:16 * lpsmith is reconsidering some of what I said,  I'm thinking this through off the cuff, maybe there is aspects I've overlooked in some of what I've said
20:04:35 <mmorrow> Baughn: does it construct lenses?
20:04:47 <mmorrow> Baughn: i think a lens for each field is the way to go
20:05:11 <mmorrow> data Foo a = Foo {one :: a, two :: Int}
20:05:19 <Baughn> mmorrow: I couldn't say. I'm reading up on them now.,
20:05:28 <mmorrow> oneL :: Foo a -> (a, a -> Foo a)
20:05:33 <hzap> Taggnostr: the compiled version works fine too
20:05:36 <mmorrow> twoL :: Foo a -> (Int, Int -> Foo a)
20:05:44 <mmorrow> is what i'd do
20:05:53 <Taggnostr> hzap, I had the problem with the compiled version
20:06:26 <copumpkin> > id id 5
20:06:27 <lambdabot>   5
20:06:41 <copumpkin> > id id id id 5
20:06:43 <lambdabot>   5
20:06:51 <Baughn> mmorrow: I doubt it uses that exact structure, but it looks to have the same functionality
20:06:55 <chessguy> why no, google, i actually don't mean "hoc phi" thank you very much
20:07:00 <mmorrow> > foldr (.) id (replicate 100000 id) 42
20:07:01 <lambdabot>   42
20:07:03 <copumpkin> > let fourtimes f = f f f f in fourtimes id 5 -- this makes me sad :(
20:07:05 <lambdabot>   Occurs check: cannot construct the infinite type:
20:07:05 <lambdabot>    t = t -> t -> t -> t1
20:07:17 <mmorrow> Baughn: hmm, i'll check it out
20:07:20 <Baughn> mmorrow: That is, the accessor functions it constructs, while opaque values, are used like lenses
20:07:23 <Taggnostr> hzap, I just remembered that I added a timeout in the compile version, so that is probably the cause, but if it's true how did you manage to reproduce it?
20:07:45 <hzap> Taggnostr: directly called the function in ghci
20:08:09 <hzap> Taggnostr: but it might be me messing things up
20:08:31 <lpsmith> copumpkin:  you demonstrated two different identities  :-)
20:08:35 <Baughn> mmorrow: For (,), extracting 4 from x=(2,(4,9)) would be "x ^. snd ^. fst"
20:08:35 <chessguy> bos, you in location yet?
20:08:41 <copumpkin> lpsmith: :(
20:08:55 <Baughn> mmorrow: And there are of course combinators to give you an update or modifying function instead. :)
20:08:59 <lpsmith> >  ((((id id) id) id) id) 5
20:09:00 <lambdabot>   5
20:09:10 * Baughn is ecstatic over having found this
20:09:21 <lpsmith> > id (id (id (id 5)))
20:09:22 <lambdabot>   5
20:09:39 <mmorrow> Baughn: hmm, i dunno how i feel about that. why not just use a lens? it seems a lot simpler
20:09:51 <lpsmith> copumpkin:  no biggie, just weren't sure what you were going for :-)
20:10:13 <web-user03> 5
20:10:30 <copumpkin> :'(
20:10:37 <lpsmith> you'd need to use polymorphic recursion to demonstrate the first property
20:11:16 <hzap> Taggnostr: tried it again in ghci and it worked fine
20:11:56 <Baughn> Whee, with explicit combinators for state monad (transformers) too. That'll make those actually /useful/. :)
20:12:50 <Taggnostr> hzap, ok
20:13:08 <Taggnostr> the problem was the timeout I added in the compiled version then
20:15:18 <Berengal> ghc is only 32 bit on windows, is it not?
20:15:34 <Berengal> Does this mean you can compile something on a 64 bit machine and have it work on a 32 bit one?
20:15:41 * Sam__ wonders why http://tools.ietf.org/html/draft-brocklesby-irc-isupport-03 died
20:16:57 <Baughn> mmorrow: Having looked a little closer, data-accessors does indeed explicitly use lenses
20:17:33 <lpsmith> >  (id :: (Int -> Int) -> (Int -> Int))  (id :: Int -> Int)  (5 :: Int -> Int)
20:17:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:17:41 <lpsmith> >  (id :: (Int -> Int) -> (Int -> Int))  (id :: Int -> Int)  (5 :: Int)
20:17:42 <lambdabot>   5
20:17:57 <pikhq> ... 5 :: Int -> Int.
20:17:59 <pikhq> Really.
20:18:57 <lpsmith> I wonder if lambdabot does scoped type variables...  and how you'd type that into the command line
20:22:15 --- mode: irc.freenode.net set +o ChanServ
20:23:18 <lpsmith> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3086#a3086
20:23:54 <copumpkin> :o
20:23:57 <copumpkin> that works?
20:24:32 <copumpkin> > let nod_id :: forall a. a -> a; not_id = (id :: a -> a) (id :: a -> a) in not_id 5
20:24:33 <lambdabot>   The type signature for `nod_id' lacks an accompanying binding
20:24:38 <copumpkin> > let not_id :: forall a. a -> a; not_id = (id :: a -> a) (id :: a -> a) in not_id 5
20:24:39 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
20:24:44 <copumpkin> meh
20:24:45 <lpsmith> ooh
20:24:46 <lpsmith> there you go
20:24:49 <rovar> hah
20:24:59 <lpsmith> Well, it is entitled "type error" :-P
20:25:07 <copumpkin> :(
20:25:13 <copumpkin> haskell fails!!!
20:26:00 <lpsmith> let not_id :: a -> a; not_id = (id :: a -> a) (id :: a -> a) in not_id 5
20:26:12 <lpsmith> > let not_id :: a -> a; not_id = (id :: a -> a) (id :: a -> a) in not_id 5
20:26:14 <lambdabot>   5
20:26:18 <copumpkin> :o
20:26:46 <copumpkin> > let not_id :: a -> a; not_id = id id in not_id 5
20:26:47 <lambdabot>   5
20:26:49 <lpsmith> in this case,  a /= a
20:26:56 <copumpkin> > let not_id = id id in not_id 5
20:26:57 <lambdabot>   5
20:27:11 <copumpkin> the issue is that with thrice f = f f f, it's forcing f to have a single type, right?
20:27:18 <flippeh_> How can I give arguments to threads used with forkIO?
20:27:46 <mike-burns> > 5 -- stop writing this the long way, guys!
20:27:48 <lambdabot>   5
20:29:01 <SamB_XP> argh "GROUP" is hard to use!
20:31:01 <lpsmith> yup
20:32:03 <lpsmith> copumpkin:  though you should be able to type "thrice" using a higher-ranked type
20:32:13 <copumpkin> ah, didn't think of that
20:33:10 <lpsmith> > let thrice :: (forall a. a -> a) -> a -> a;  thrice f = f f f in thrice id 5
20:33:11 <lambdabot>   5
20:33:15 <lpsmith> hmm
20:33:42 <lpsmith> how could you do that for say,  thrice dup,  where dup a = (a,a)
20:33:44 <copumpkin> that's nice
20:34:16 <lpsmith> only problem is,  the only function you could apply thrice to at this point is "id"
20:34:23 <copumpkin> yeah
20:34:28 <lpsmith> we need a UHC bot!
20:35:06 <Cale> But dup dup dup on its own wouldn't typecheck
20:35:16 <Cale> (what would that even mean?)
20:35:21 <lpsmith> wait,  Cale is right
20:35:52 <copumpkin> there aren't many functions you'd want to apply to themselves
20:37:22 <aavogt> > fix (1:)
20:37:24 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:38:03 <lpsmith> >  let dup x = (x,x) in dup (dup (dup 5))
20:38:05 <lambdabot>   (((5,5),(5,5)),((5,5),(5,5)))
20:39:22 <lpsmith> Chris Okasaki talks about this kind of polymorphic recursion in his book "Purely Functional Datastructures"
20:39:56 <lpsmith> Of course,  you really need to define a datatype using polymorphic recursion...
20:40:06 <Cale> Yeah, maybe you're thinking of thrice f = f . f . f
20:40:13 <lpsmith> I don't suppose lambdabot allows you to define datatypes...
20:40:26 <lpsmith> That would work
20:40:31 <lpsmith> hmm
20:40:32 <Cale> (which typechecks on its own, but its type isn't polymorphic enough to accept dup as a parameter)
20:40:33 <raxas> hello
20:41:00 <lpsmith> @let  data List a = Null | Cons a (List (a,a))
20:41:01 <lambdabot>  Invalid declaration
20:41:08 <lpsmith> fooey
20:41:15 <lpsmith> hi raxas
20:41:26 <pikhq> > fix ([]:)
20:41:27 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
20:41:43 <pikhq> Single most useless list ever.
20:42:38 <raxas> lpsmith: sorry me, that /amsg should target only local irc server :]
20:43:10 <Cale> pikhq: It might make a decent base case for some algorithms.
20:43:41 <Cale> I used  repeat (0,[])  just the other day :)
20:44:43 <mmorrow> Baughn: http://moonpatio.com/repos/MkLenses.hs
20:45:03 <mmorrow> Baughn: oh nice, it /does/ use lenses you say
20:48:48 <pikhq> Cale: Just goes to show that even the most useless list ever is still rather useful. ;)
20:49:06 <Cale> :)
20:49:17 <pikhq> > map (1:) $ fix ([]:)
20:49:17 <lpsmith> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3087#a3087
20:49:18 <lambdabot>   [[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1...
20:50:11 <mmorrow> Baughn:
20:50:12 <mmorrow> @type \lens f -> modify (uncurry (flip ($)) . first f . lens)
20:50:13 <lambdabot> forall b b1 c (m :: * -> *). (MonadState b m) => (b -> (b1, c -> b)) -> (b1 -> c) -> m ()
20:50:29 <lpsmith> hmm... would you need dependent types to define thrice f = f . f . f  and apply it to dup x = (x,x) ?
20:52:04 <mapreduce> :t \f -> f . f . f
20:52:06 <lambdabot> forall c. (c -> c) -> c -> c
20:53:09 <mmorrow> you just need unsafeCoerce (or a newtype, which is the same thing)
20:53:33 <Cale> mmorrow: Presumably we want to do it safely
20:53:33 <mmorrow> err, well hmm
20:53:39 <lpsmith> bah.  No unsafeCoerce!
20:53:42 <mapreduce> :t let thrice f = f . f . f in thrice \x -> (x, x)
20:53:43 <lambdabot> parse error on input `\'
20:53:47 <lpsmith> a newtype _might_ work
20:53:59 <copumpkin> :o
20:54:11 <mmorrow> Cale: well sure, newtype => unsafeCoerce, but not (unsafeCoerce => newtype)
20:54:35 <Cale> I think there's a way to do it using explicit bounding constraints
20:54:36 <lpsmith> :t let thrice f = f . f . f in thrice (\x -> (x,x))
20:54:37 <lambdabot>     Occurs check: cannot construct the infinite type: c = (c, c)
20:54:37 <lambdabot>       Expected type: c
20:54:37 <lambdabot>       Inferred type: (c, c)
20:54:39 <mmorrow> lpsmith: it won't be clean like i first thought though :(
20:55:25 <mmorrow> data a:::b = (Either a (a:::b) ::: Either b (a:::b)
20:55:26 <Cale> You need a way to say that the function parameter has type t where (a -> b) < t and (b -> c) < t and (c -> d) < t, and then the second parameter will have type a, and the result has type d
20:55:28 <mmorrow> or something
20:55:42 <mmorrow> which is kinda ugly with the Eithers in there
20:55:57 <Cale> I wonder if ~ can work like that... probably now
20:55:59 <Cale> not*
20:56:12 <mmorrow> ooh, i forgot about Nest
20:56:29 <mmorrow> , nesty $(nat 18) (:[]) 42
20:56:33 <lunabot>  [[[[[[[[[[[[[[[[[[[42]]]]]]]]]]]]]]]]]]]
20:56:47 <mmorrow> uses a type family to tell ghc the type
20:56:55 <mmorrow> (a type family plus a GADT)
20:57:11 <mmorrow> i think maybe this could work for dup here
20:57:33 <mmorrow> (although you'd need a newtype wrapper just on account of haskell syntax)
20:57:46 <Cale> ah, right,  (t ~ (a -> b), t ~ (b -> c), t ~ (c -> d)) => t -> a -> d  is the same as  (a -> a) -> a -> a
20:57:49 <Cale> so it doesn't work
20:58:03 <mmorrow> here's Nest http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2166
20:58:11 <mmorrow> , $(nat 8)
20:58:13 <lunabot>  N (N (N (N (N (N (N (N Z)))))))
20:58:22 <mmorrow> (TH just for convenience, it's not essential)
20:59:21 <Baughn> Why TH? Looks to me like ordinary haskell would do
21:00:34 <dolio> nat would have a dependent type.
21:01:02 <mmorrow> hehe, it works with
21:01:08 <mmorrow> newtype Dup a = Dup (a,a)
21:01:17 <mmorrow> dup :: a -> Dup a; dup a = Dup (a,a)
21:01:25 <mmorrow>  nest $(nat 18) dup 42
21:01:30 <mmorrow> is friggin massive
21:01:55 <mmorrow> Baughn: there's the opposite direction in haskell ==> N a -> Int
21:02:06 <mmorrow> but the other way is mapping Value->Type
21:02:19 <lpsmith> 2^18?   That's close enough to infinity!
21:02:19 <mmorrow> , toInt $(nat 8)
21:02:21 <lunabot>  8
21:02:39 <mmorrow> , 2^18
21:02:40 <lunabot>  262144
21:02:43 <mmorrow> heh
21:02:49 <Baughn> Apparently so. I was assuming a different structure to the type.
21:02:57 <lpsmith> (in this particularly case anyway :-P)
21:04:32 <mmorrow> , nesty $(nat 18) dup 42
21:04:34 <lunabot>  Dup (Dup (Dup (Dup (Dup (Dup (Dup (Dup (Dup (Dup (Dup (Dup (Dup (Dup (Dup...
21:04:45 <mmorrow> , (length . show) (nesty $(nat 18) dup 42)
21:04:47 <lunabot>  4718585
21:04:54 <Baughn> Eep
21:05:01 <mmorrow> , (length . show) (nesty $(nat 19) dup 42)
21:05:03 <lunabot>  luna: Context reduction stack overflow; size = 20
21:05:09 <mmorrow> argh
21:05:13 <mmorrow> , (length . show) (nesty $(nat 17) dup 42)
21:05:14 <dolio> You can write: nat' :: Int -> exists n. Nat n without TH.
21:05:15 <lunabot>  2359289
21:05:27 <dolio> But that doesn't help you use nesty.
21:05:36 <mmorrow> dolio: ooh, yeah. i just started to realize what you can do with existential types
21:05:46 <lpsmith> Not with GHC...
21:05:54 <mmorrow> dolio: with GADTs + existentials you can pretty much get dependent types
21:05:55 <lpsmith> UHC, probably
21:06:00 <dolio> With GHC you'd have to make an explicit wrapper.
21:06:02 <mmorrow> well, you need to do
21:06:11 <mmorrow> data Exists = forall a Exists (f a)
21:06:15 <mmorrow> or whatever
21:06:18 <mmorrow> data Exists f = forall a Exists (f a)
21:06:20 <mmorrow> i mean
21:06:20 <dolio> mmorrow: You can get ATS dependent types. Not good dependent types. :)
21:06:24 <lpsmith> right... point taken
21:06:27 <mmorrow> dolio: :(
21:07:10 <Cale> There's a new SPJ interview up on a Russian site. Really slow to load though.
21:07:45 <dolio> ATS dependent types are good enough to have a provably sorting quicksort, though, so they're pretty good, I guess. :)
21:07:54 <dolio> At least, I think that's what they did.
21:08:09 <mmorrow> dolio: what an example that you couldn't do with GADTs + Exists?
21:08:24 <mmorrow> (not that i don't believe you, i just can't think of one)
21:08:35 * lpsmith wonders if UHC could "show" dolio's nat'
21:08:36 <dolio> It's not so much about what you can and can't do, but about how you have to structure things.
21:09:01 <mmorrow> dolio: well of course here you can never recover the type once it goes into the Exists
21:09:18 <mmorrow> dolio: the trickery though is that your function that cases on the GADT inside /can/
21:09:33 <dolio> In ATS, you write everything twice. Once at the static level, and once at the dynamic level, indexed by the static level, and then existentially quantified.
21:09:33 <mmorrow> hrm, but yeah you're limited by the GADT
21:09:43 <mmorrow> oh, interesting
21:09:51 <dolio> In Agda, you just write it once.
21:09:55 <mmorrow> i should read a quick spiel on ATS
21:10:10 * lpsmith isn't sure what that even means.   Is ATS worth looking at closely?
21:10:16 <mmorrow> heh
21:10:18 <dolio> (Well, except for universe polymorphism issues, where you have to rewrite all your Set types to work on Set1s, and Set2s, and so on).
21:10:33 <mmorrow> lpsmith: just to see what the similarity is with GADTs + existentials
21:10:42 <mmorrow> dolio: ugh
21:10:43 <lpsmith> heh
21:11:12 <dolio> So maybe Coq should be the example. In Coq you write things once. :)
21:11:28 <lpsmith> yeah, I definitely need to learn more Agda.  And Isabelle and Coq.
21:13:04 <mmorrow> dolio: ooh, i just wrote a gadt Read deriver (for a subset of GADTs)
21:13:12 <mmorrow> dolio: http://moonpatio.com/repos/gadt-read/
21:13:29 <mmorrow> so this file i think gives the best explanation of what happens
21:13:36 <mmorrow> http://moonpatio.com/repos/gadt-read/GADTTest.hs
21:13:48 <mmorrow> those instances are the ones that GADTRead derived
21:13:50 <dolio> Except Coq has type-based erasure, so I guess you have to write things once for erasible types (Prop) and once for non-erasible types (Type), unless you pull in stuff from that erasure pure type systems paper. :)
21:14:07 <dolio> But in some ideal language, you write things once. :)
21:14:19 <mmorrow> heh
21:15:04 <mmorrow> (there's also a unifier in that repo, which could be used for whatever in its own right)
21:15:14 <dolio> Oh, you figured out a show for things like "data Foo a where Foo1 :: Int -> Foo Int ; Foo2 :: a -> Foo a"?
21:15:24 <mmorrow> ah yeah, i've got that
21:15:25 <dolio> I figured that was a case where it legitimately broke.
21:15:42 <mmorrow> oh, i dunno if it actually works for that particular example though :)
21:15:57 <mmorrow> this is my gadt show code
21:15:58 <mmorrow> http://moonpatio.com/cgi-bin/gadtshow.cgi
21:16:08 <mmorrow> need to update it to use the new haskell-src-exts
21:16:13 <mmorrow> (and clean it up)
21:16:46 <mmorrow> the Show deriving code and that cgi prog are in this module http://moonpatio.com/repos/MISC/GadtDerive.hs
21:17:23 <dolio> Oh, never mind. I was thinking about Read.
21:17:45 * mmorrow wants to combine both of these, then wrap it in TH code that uses (location :: Q Loc), which contains the FilePath of the current module, so then that code can read the current module, parse it, extract all GADTs, and finally derive Show and Read for the (parts of the) ones that it can
21:18:18 <lpsmith> I've long thought being able to put existentials in arbitrary locations and typeclasses was key for a nice integration between static and dynamic typing
21:18:32 <lpsmith> unfortunately UHC doesn't support existentials with typeclasses yet
21:18:39 <mmorrow> dolio: ah, yeah this scheme for Read generates one Read instance for each possible monomorphic type of `a' in (Foo a), where Foo is some GADT
21:18:44 <dolio> However its solution for: "data F :: * -> * where F1 :: (Int -> Int) -> F Int ; F2 :: a -> F a" is not going to work.
21:19:12 <mmorrow> ahh, but it will (if you s/Int->Int/something showable/
21:19:24 <mmorrow> the trick is to unify the type of F2 with all the other cons
21:19:39 <mmorrow> then include F2 in the Read instance for any con-group it unifies with
21:19:56 <Berengal> It's a sad thing the halting problem is unsolveable...
21:19:57 <mmorrow> err, i said that partially oddly, but that's the general idea
21:20:25 <mmorrow> * s/Int->Int/something readable/
21:20:43 <dolio> No, I mean your cgi thing, there.
21:20:48 <mmorrow> oh
21:20:56 <dolio> It's outputting an instance that won't work, because Int -> Int isn't showable.
21:21:01 <mmorrow> yeah, that one is pretty dumb
21:21:07 <mmorrow> it doesn't special case anything iirc
21:21:09 <dolio> Same if you make it "F1 :: a -> F Int".
21:21:12 <dolio> Ah, okay.
21:21:14 <mmorrow> ah yeah, that too
21:21:24 <mmorrow> it doesn't know what's Showable or not
21:21:36 <mmorrow> and it always assumes it need a Show context for each var
21:22:09 <mmorrow> (but for GADTs which /can/ have a show, it either works verbatim, or you need to delete part/all of the context by hand)
21:22:28 <mmorrow> err, it also gets confused by higher-kinded tyvars iirc
21:26:01 <lpsmith> http://www.osnews.com/story/21882/Microsoft_s_Linux_Kernel_Code_Drop_Result_of_GPL_Violation
21:26:20 <lpsmith> hahaha,   I know of some other companies that need to get do the same
21:27:49 <mmorrow> dolio: also in that Unify module i included an "Exists" con in the Type type, but i didn't know what to do with it during unification, so it's just ignored atm
21:29:40 <mmorrow> dolio: like, what does ==> unify (forall a. exists b. (a,b)) (exists c. (Int,c))
21:29:42 <mmorrow> mean>
21:29:44 <mmorrow> ?
21:30:36 <mmorrow> err, i guess that one's kind of trivial (i think), but in general i'm not sure how to treat tyvars bound with "exists"
21:30:43 <mmorrow> as opposed to bound by "forall"
21:31:01 <lpsmith> mmorrow:  how is that related (or not) to function types?
21:31:19 <mmorrow> i'm not sure how you mean exactly
21:31:26 <mmorrow> like (a -> a)?
21:31:44 <mmorrow> oh i think i know what you mean
21:31:57 <lpsmith> n/m
21:32:00 <mmorrow> so the similarity between (forall a. a) and (\a -> a)
21:32:00 <lpsmith> well
21:32:01 <mmorrow> ?
21:32:20 <mmorrow> in that the "forall" binds those tyvars
21:32:27 <mmorrow> just like the lambda
21:32:39 <lpsmith> It's just when I see forall a. exists b.  I think function
21:32:46 <mmorrow> and (forall a. a) `"apply"` Int ===> Int
21:33:09 <lpsmith> I guess it's more like a function from a to b^{1,2,3...}
21:34:10 <mmorrow> i guess it's like a mapping from types to types
21:34:16 <mmorrow> yeah
21:34:58 <lpsmith> where each number is interpreted in the set theoretic way...  name is slipping my mind
21:35:23 <mmorrow> as an index?
21:35:36 <dolio> mmorrow: As a first guess, I'd say unifying P[T] with exists a. P[a] gives exists a. P[a].
21:35:47 <lpsmith> no
21:35:54 <lpsmith> Von Neumann ordinal
21:35:55 <lpsmith> that's it
21:36:04 <mmorrow> dolio: ahh, think i see kind of
21:36:05 <Berengal> Is there a fundamental reason why ghc's brain exploding on pattern-binding on GADTs, or is it just a shortcoming?
21:36:27 <mmorrow> dolio: so "exists a. a" swallows everything, whereas (forall a. a) /becomes/ anything
21:36:36 <dolio> mmorrow: Following the subtyping relation, yes.
21:36:37 <mmorrow> or something
21:36:48 <mmorrow> hmm
21:36:48 <lpsmith> GHC's brain explodes on pattern matching on existential types.
21:36:55 <inimino> @faq can Haskell make GHC's brain explode?
21:36:55 <lambdabot> The answer is: Yes! Haskell can do that.
21:36:56 <dolio> forall a. a < anything else < exists a. a
21:37:26 <dolio> Plus the rule for functions.
21:37:30 <mmorrow> oh?
21:37:30 <lpsmith> mmorrow,  no it's more like a function from a to the powerset of b,  minus the empty set
21:37:40 <mmorrow> lpsmith: interesting
21:38:16 <mmorrow> lpsmith: i think this is kind of related http://moonpatio.com/papers/homotopy_theoretic_models_of_identity_types.pdf
21:38:29 <mmorrow> (rwbarton linked me to that initially)
21:39:24 <mmorrow> lpsmith: err, maybe that's not quite related, but this made me think of it at least ;)
21:39:33 <lpsmith> heh,  well, rwbarton would be a couple levels over me w.r.t. math ability :)
21:39:33 <mmorrow> (it may be though..)
21:40:01 <mmorrow> so the thing that made me think of that is:
21:40:03 <lpsmith> me,  I learn slow.  Real slow.   But what I do know I know very well, and I don't readily forget
21:40:29 <mmorrow> (x::A) -> B(x)  is and indexed family of maps:
21:40:41 <mmorrow> f_i : B_i -> A
21:40:58 <mmorrow> (so /from/ B_i, not /to/ it)
21:41:27 <mmorrow> this is the part i think may or may not be relevant here
21:41:39 <mmorrow> dolio: what's the rule for functions?
21:42:24 <dolio> mmorrow: T' < T, U < U' ==> T -> U < T' -> U', I think.
21:42:30 <dolio> If I got the contravariant one right.
21:42:54 <dolio> First parameter should be contravariant, I think.
21:44:11 <Berengal> FUCK YEAH!
21:44:12 <Berengal> map :: (forall a. a -> f a) -> l -> LAp f l
21:44:19 <Berengal> *Main> map (:[]) (1 ::: "Hello" ::: Nil)
21:44:19 <Berengal> [1] ::: ["Hello"] ::: Nil
21:44:25 <copumpkin> oooh, I found a library to bind to that I can use my fancy failgebra typeclass hierarchy nicely on
21:46:02 <Berengal> I'm one step closer to creating my multi-indexed map
21:46:19 <copumpkin> :o
21:47:39 <Berengal> data Person = Person {firstName, lastName :: String, phoneNumber :: Int}; (emptyPersonMap, lastNameIndexer ::: phoneNumberIndexer ::: Nil) = createMap (lastName ::: phoneNumber ::: Nil)
21:47:55 <Berengal> That typechecks
21:48:12 <Gracenotes> ..seaking
21:48:12 <lambdabot> Gracenotes: You have 1 new message. '/msg lambdabot @messages' to read it.
21:48:21 <copumpkin> zomg Gracenotes gets all the lovin
21:48:35 <Gracenotes> haha
21:49:29 <Gracenotes> it was a link to a true work of art, http://danbooru.donmai.us/post/show/158844/billhook-cat-comparison-crazy_eyes-higurashi_no_na !
21:50:04 <Gracenotes> I see the comparison, and approve
21:52:31 <Gracenotes> I can at least translate the lower-left part: "AH HA HA HA HA HA HA HA"
21:53:14 <copumpkin> lol
21:54:24 <Gracenotes> then "<omg kanji>jinaiyone"
21:55:19 <copumpkin> what's the best automatic c binding generator?
21:55:22 <copumpkin> I remember there was more than one
21:55:28 <copumpkin> c2hs?
21:55:55 <mmorrow> copumpkin: if you find out how to get it to do the "automatic" part, pleeze tell me too :)
21:56:11 <Gwern-away> Gracenotes: I figured you'd like't
21:56:26 <copumpkin> mmorrow: isn't there something that takes an h file and generates foreign import ccall declarations for it?
21:56:35 <mmorrow> copumpkin: i'm not so sure it does "automatic", although that's what it makes it sound like
21:56:57 <mmorrow> copumpkin: i really wish there was (hope there is, but i'm losing hope..)
21:57:34 <mmorrow> copumpkin: i think you could do it though with language-c + generate a .hsc file or something
21:57:44 <copumpkin> hmm
21:58:02 <mmorrow> copumpkin: if you want to have a go at it, here's some language-c dealing-with code that might help:
21:58:31 <mmorrow> http://moonpatio.com/repos/flounder/src/flounder.hs
21:58:49 <copumpkin> oh my :)
21:59:01 <mmorrow> (and there's a hacked version of language-c in that repo too, which makes the Show instance actually valid haskell syntax)
21:59:29 <mmorrow> i've wanted to try to do this too and was planning on starting with this code..
21:59:44 <copumpkin> hmm
21:59:58 <copumpkin> maybe I'll just write the binding myself for now, don't want to shave too much yak
22:00:05 <copumpkin> but it does seem like it'd be a handy tool
22:00:11 <copumpkin> I'm surprised there isn't something already
22:00:12 <mmorrow> copumpkin: heh, yeah that's what i decide every time..
22:00:19 <Gwern-away> 3oh the irony
22:00:28 <mmorrow> copumpkin: me too. someone needs to eventually suck it up and just write one
22:00:32 <copumpkin> :)
22:00:32 <Gwern-away> it's like you're playing a prisoner's dilemma against your future self!
22:00:34 <copumpkin> lol
22:00:57 * mmorrow was hoping copumpkin waz about to do it
22:01:00 <mmorrow> ;)
22:01:02 <copumpkin> lol
22:01:24 <Gwern-away> hm. maybe the snowdrift game is closer
22:01:49 <copumpkin> so I'm binding to a library called PBC
22:01:50 <Gwern-away> ah, I know, it's a snowdrift game against people in the present, but a prisoner's dilemma against future people. seems hard to model...
22:02:07 <copumpkin> should it be pbchs or hspbc (or can you think of better names?)?
22:02:37 <Gwern-away> is hpbc really that bad?
22:02:45 <Gwern-away> I mean, if you're considering pbchs...
22:02:57 <copumpkin> nope :)
22:03:02 <copumpkin> I'd love to come up with a better name
22:03:07 <copumpkin> but I'm not feeling too imaginative now
22:03:51 <mmorrow> dood, imagine all the imagining time you'd have if you had an automagic C binding generator!
22:04:01 <copumpkin> lol
22:04:04 <mmorrow> :)
22:04:22 <copumpkin> so the library is for pairing-based crypto
22:04:53 <copumpkin> any suggestsions for what module hierarchy to use?
22:05:11 <Gwern-away> data?
22:05:14 <mmorrow> what does the Crypt pkg use?
22:05:17 <mmorrow> *Crypto
22:05:30 <copumpkin> it's more mathematical though, it'd be nice if we had a Math.*
22:05:31 <copumpkin> :P
22:05:40 <copumpkin> it's basically a bilinear map abstraction library
22:05:48 <mmorrow> ooh, start Math.*
22:05:59 <mmorrow> (there's a Numeric.* if it's more that too)
22:06:22 <copumpkin> ugh, naming is always the hardest stuff
22:06:29 <copumpkin> Numeric feels too concrete somehow
22:06:35 <copumpkin> not sure why the numeric prelude was called that
22:06:44 <lpsmith> what,  an automagic binding generator that creates high-level bindings?
22:06:49 <lpsmith> That'd be nice
22:06:49 <ray> algebraic prelude
22:06:56 <copumpkin> ray: that's what I'd have called it if anything
22:07:01 <mmorrow> lpsmith: .h -> .hs(c)
22:07:04 <copumpkin> ray: I'd prefer to just call it "The Prelude" though ;)
22:07:10 <ray> that comes later
22:07:11 <mmorrow> just the barebones busy work
22:07:25 <ray> after we crush proponents of other preludes in a 30 second war
22:07:29 <lpsmith> My understanding is that algebraic prelude was considered, but not done because it was a bit too cumbersome to use
22:07:49 <copumpkin> lpsmith: how did that differ from the numeric prelude, which seems like a massive definition of algebraic structures
22:07:58 <lpsmith> I haven't taken a close look at c2hs,  but what's wrong with that?
22:08:14 <lpsmith> I dunno,  I don't know how concrete the proposals were
22:08:53 <ray> concrete enough to be on hackage
22:08:54 <lpsmith> I'm not even sure where I heard that statement, to be honest.
22:09:06 <ray> maybe you confabulated it
22:09:37 <lpsmith> well, I'm talking available circa 1995-ish, when the prelude was getting written and revised
22:09:57 <lpsmith> I got started in 1997,  and I remember a few changes made;  like map used to be fmap
22:09:59 <ray> ah yeah, i doubt there was anything on hackage then :P
22:10:34 <lpsmith> they decided a generalized map by default lead to too many cryptic type errors for people new to the language
22:11:01 <ray> boo hoo cryptic type errors
22:11:18 <copumpkin> lpsmith: you started haskell in 1997??
22:11:20 <lpsmith> I played around a bit with my own algebraic type classes when I was taking Algebra
22:11:23 <ray> we still have that "no instance for whatever" error and people manage
22:11:25 <lpsmith> Aye
22:11:31 <ray> @ghc
22:11:32 <lambdabot> ghc says: Malformed context in instance header
22:11:46 <copumpkin> wow
22:12:42 <lpsmith> hey, I started with Basic when I was 3... I don't claim to be normal :-P
22:12:49 <copumpkin> lol
22:12:53 <copumpkin> how old are you now?
22:13:30 <ray> 4
22:13:39 <copumpkin> hah
22:13:47 <Warrigal> let va b r | b > 0 && r > 0 = max 0 ((b*(va (b-1) r + 1) + r*(va b (r-1
22:13:49 <Warrigal> ...
22:13:55 <copumpkin> :o
22:14:00 <Warrigal> let va b r | b > 0 && r > 0 = max 0 ((b*(va (b-1) r + 1) + r*(va b (r-1) - 1))/(b+r)); va 0 r = 0; va b 0 = b
22:14:07 <lpsmith> 29
22:14:10 * copumpkin whispers "> "
22:14:39 <Warrigal> That definition runs in something like O(c^(b+r)) time, when it could run in O(b*r) time.
22:14:40 <copumpkin> I wish I'd found haskell that early
22:14:43 <Berengal> copumpkin: How do you even pronounce that?
22:14:44 <copumpkin> I was busy fumbling with c++ at the time
22:14:54 <ray> > unsafeLaunchMissiles
22:14:55 <lambdabot>   Not in scope: `unsafeLaunchMissiles'
22:15:09 <Warrigal> Berengal: by looking up its pronunciation in a dictionary and saying that. :-P
22:15:26 <copumpkin> Berengal: double quote greater than space double quote
22:15:36 <Berengal> Warrigal: Which dictionary has pronunciation for '>' and ' '?
22:15:59 <byorgey> Warrigal: the calls to va won't get memoized.  that looks like a classic dynamic programming problem.
22:16:05 <copumpkin> mmorrow: Math.Pairing?
22:16:08 <ray> are berengal and warrigal twins?
22:16:11 <Warrigal> Anyway, is there an easy way to optimize this so that it memoizes?
22:16:14 <byorgey> Warrigal: you can actually express dynamic programming quite nicely in Haskell using lazy immutable arrays
22:16:22 <Warrigal> Berengal: try OED?
22:16:33 <Berengal> Warrigal: Try let/where
22:16:34 <copumpkin> mmorrow: nothing in it is inherently crypto, it's just that it's very helpful for writing crypto
22:16:34 <lpsmith> hah
22:16:41 <copumpkin> Math.BilinearMap?
22:16:49 <lpsmith> I fumbled with C++ for a month,  and within a year had moved on to Haskell
22:17:07 <byorgey> Berengal: no.
22:17:07 <byorgey> read it more carefully. =)
22:17:08 <ray> it was so bad, you wanted to find the complete opposite
22:17:09 <Warrigal> ray: I'm a subspecies of Canis lupus. I don't think Berengal is even a real thing.
22:17:11 <Berengal> Ah, I see...
22:17:19 <Berengal> There's no CSEs
22:17:24 <Berengal> Data.MemoTrie?
22:17:47 <byorgey> Warrigal: see http://hackage.haskell.org/packages/archive/array/0.2.0.0/doc/html/Data-Array-IArray.html
22:17:49 <Warrigal> I take it there isn't a "memoize this" pragma or anything.
22:17:55 <copumpkin> Warrigal: nope
22:17:57 <lpsmith> but honestly it was more a mistake and happenstance than anything else;  I liked Modula-3 and noticed that most universities that taught Modula-3 also taught SML
22:17:58 <ray> did somebody say trie?!
22:18:16 <Berengal> I said trie
22:18:23 <copumpkin> trie harder
22:18:28 <copumpkin> apple trie
22:18:38 <ray> sorry, i'm a trie fan
22:18:47 <byorgey> Warrigal: you can construct an array using 'array' which takes a list of (index, value) pairs, and the indices can be pairs themselves if you want a 2D array
22:18:53 <Berengal> fib = memo go where go 0 = 0; go 1 = 1; go n = fib (n-1) + fib (n-2)
22:18:57 <copumpkin> it's just a triefle
22:19:01 <lpsmith> I suppose that wasn't that coincidental... Luca Cardelli wrote the first halfway fast ML compiler
22:19:04 <byorgey> Warrigal: but it's lazy, so the values can depend on other array values
22:19:06 <Berengal> put an import Data.MemoTrie on top, and bob's your uncle
22:19:13 <byorgey> and it will work out the correct order to evaluate everything in
22:19:16 <Warrigal> @docs Data.MemoTrie
22:19:17 <lambdabot> Data.MemoTrie not available
22:19:21 <Warrigal> Yay.
22:19:30 <Berengal> cabal install MemoTrie
22:19:32 <ray> @hackage MemoTrie
22:19:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MemoTrie
22:19:46 <cjs> Is there a function to "coerce" a Double to an arbitrary Num?
22:20:00 <copumpkin> realToFloat?
22:20:03 <copumpkin> actually no
22:20:09 <copumpkin> unsafeCoerce ;)
22:20:11 <ray> fromGooglyMoogly
22:20:17 <Berengal> Warrigal: If the domain is limited an array might work better
22:20:22 <cjs> copumpkin: That was not the answer I'm looking for. :-)
22:20:32 <Berengal> memotries have infinite domain
22:20:38 <byorgey> cjs: how is that even possible?  how would you coerce a Double to, say, Integer?
22:20:43 <ray> unsafeCoercing a double is even worse than just unsafeCoercing
22:20:55 <byorgey> I mean how would you do it generically so it would work for ANY Num, including things like Integer
22:20:57 <Warrigal> Well, the domain is limited to something like integers greater than or equal to -1.
22:21:07 <mmorrow> copumpkin: i dunno if i'd take a name like Math.BilinearMap for an ffi binding, maybe Math.Bilinear.PBC or something
22:21:17 <copumpkin> mmorrow: true
22:21:41 <copumpkin> Math.Pairing.PBC?
22:21:42 <Berengal> Warrigal: But unbounded in the positives?
22:21:47 <copumpkin> dammit I hate naming
22:21:50 <mmorrow> copumpkin: that sounds good
22:21:59 <mmorrow> Math.<whatever>.PBC
22:22:01 <Warrigal> The inputs will never go higher than 26, in practice.
22:22:12 <mmorrow> Math.PBC ?
22:22:27 <copumpkin> Math.UnsafeDivisionRing.PBC
22:22:31 <mmorrow> heh
22:22:32 <copumpkin> (totally unrelated)
22:22:34 <Berengal> Warrigal: Then an array is probably the way to go.
22:22:43 <copumpkin> hmm
22:23:01 <copumpkin> I dunno, do people typically put a name in a module name, or the general class of functionality
22:23:22 <Warrigal> How about a list of lists?
22:23:54 <mmorrow> copumpkin: i'd probably go for <top-level-category>.<name-of-lib>.<subcategories>
22:23:59 <Berengal> Warrigal: Would also work, but would be much slower
22:24:06 <mmorrow> or at least that seems like a good compromise
22:24:09 <mmorrow> (to me)
22:24:09 <copumpkin> hmm
22:24:17 <Warrigal> It'll be plenty fast.
22:24:21 <mmorrow> Math.PBC.<everything>
22:24:26 <copumpkin> I guess it isn't set in stone even if I release it, people will just get pissed off at me if I change it
22:24:31 <copumpkin> all 0 people who will use this lib
22:24:34 <Berengal> Warrigal: Then do that :)
22:24:42 <copumpkin> mmorrow: seems reasonable enough though
22:24:52 <Warrigal> > [[3]] ! 0 ! 0
22:24:53 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
22:25:00 <Warrigal> > [[3]] !! 0 !! 0
22:25:01 <lambdabot>   3
22:25:06 <Warrigal> Wunderbar.
22:25:13 <mmorrow> copumpkin: just write it and you'll either get really annoyed at your naming scheme and change it, or you'll love it and keep it!
22:25:37 <Warrigal> !! binds more tightly than anything else, right?
22:26:01 <Berengal> Personally I like <top-level-category>.<broadish-functionality-definition>.<library-name>
22:26:08 <Gwern-aw1y> @tell shachaf maybe I'll get that imrpo book soon - on a lw post very like my respect essay, someone recommends it! http://lesswrong.com/lw/13s/the_nature_of_offense/z1s
22:26:09 <lambdabot> Consider it noted.
22:26:13 <Berengal> Warrigal: function application binds the tightest
22:26:21 <copumpkin> Berengal: then I'd end up with Math.Pairing.PBC.Pairing
22:26:28 <copumpkin> and Math.Pairing.PBC.Element
22:26:31 <Warrigal> Right, but it binds more tightly than +, right?
22:26:39 <ray> yes
22:26:44 <ray> it's infixsomething 9
22:26:51 <Berengal> copumpkin: And a Math.Pairing.PBC that exports all of those
22:26:55 <ray> i guess it has to be infixl 9
22:27:15 <copumpkin> Berengal: I just don't like the repetition even if the user doesn't deal with it directly
22:27:23 <copumpkin> Berengal: because then I'd have a type called pairing
22:27:26 <ray> Math.PBC is good
22:27:31 <copumpkin> and I'd get Math.Pairing.PBC.Pairing.Pairing as a type :P
22:27:40 <ray> you might as well switch to java!
22:28:01 <Berengal> Hah, in java that's considered short
22:28:03 <mmorrow> remember to always import it fully qualified too!
22:28:04 <Berengal> :(
22:28:17 <ray> Pairing.Pairing pairing = new Pairing.Pairing.Pairing(Pairing pairing pairingiohsgsdalsgadl;asgd;;sdg;gs;;;;;;;;;;;
22:28:25 <mmorrow> yay!
22:28:30 <ray> is the java
22:28:31 <copumpkin> edu.stanford.cs.bonehslab.lynn.pbc
22:28:50 <Warrigal> ray: you forgot your <>.
22:28:52 <pikhq> Too much Java.
22:28:54 <Berengal> ray: Forgot the "generic" parameters
22:29:13 <Warrigal> Function<List<Object>><List<Object>>
22:29:15 * Warrigal grins.
22:29:32 <copumpkin> how frowned upon is it to not use the default prelude in a library?
22:29:45 <ray> i frown not
22:29:48 <pikhq> You also neglected the crazy object hierarchy.
22:30:04 <copumpkin> I just want to use my algebraic typeclasses on this library because it would work nicely
22:30:15 <Berengal> copumpkin: Do I need to bother?
22:30:18 <ray> you should make those a seperate package first :P
22:30:23 <copumpkin> Berengal: as a user?
22:30:27 <Berengal> copumpkin: Yes
22:30:29 <copumpkin> ray: I was thinking of it
22:30:34 <Warrigal> Hmm, I can't immediately think of a way to make a list that goes [[f 0 0, f 0 1, ...], [f 1 0, f 1 1, ...], ...]
22:30:38 <copumpkin> Berengal: probably :P depends how much of the library you actually want to use
22:30:46 <copumpkin> ray: pity the best name I have for it is failgebra though :P
22:30:58 <ray> name it MY ALGEBRA TYPECLASSES (THEY ARE (VERY) LOVELY)
22:31:17 <Warrigal> Mm, I think I got it.
22:31:19 <Berengal> Warrigal: [[f x y | x <- [0..]] | y <- [0..]]
22:31:46 <copumpkin> ray: lol
22:32:01 <ray> module Lovely.Algebra where
22:32:22 <copumpkin> Math.Failgebra
22:32:23 <copumpkin> :P
22:32:37 <Gracenotes> .Internal
22:32:45 <copumpkin> Math.Wingebra
22:32:54 <copumpkin> Math.Aljabr
22:32:59 <Berengal> Control.Oops.Wrong.Module
22:33:13 <copumpkin> I'd actually kinda like to call it aljabr
22:33:15 <ray> Prelude.FromTheFuture
22:33:18 <Gracenotes> Control,Oops,Wrong,Punctuation
22:33:24 <ray> no, people will think it's a jabber client
22:33:24 <copumpkin> lol
22:33:31 <copumpkin> al-jabr ?
22:33:41 <copumpkin> can I have hyphens in a module name
22:33:41 <copumpkin> ?
22:33:45 <ray> yes
22:33:48 <Warrigal> Control.NetHack."
22:33:53 <copumpkin> I could take algebra as a module name but that'd be kinda arrogant
22:33:56 <Warrigal> The infamous amulet module, which drives compilers nuts.
22:34:12 <purplepenguins> Math.Prealgebra
22:34:12 <ray> but they will think it's a jabber client that uses some ridiculous library or whatever called al
22:34:35 <copumpkin> ray: or they'll think it's terrist unsafeLaunchICBM library
22:34:44 <Berengal> Math.Al-ğabr
22:34:45 <Warrigal> I can imagine there being a type of mathematical thing called a prealgebra.
22:35:06 <copumpkin> zygohistomorphic preproalgemorphism
22:35:39 <purplepenguins> Data.Lore
22:35:45 <Berengal> Or you could go crazy: Math.الجبر
22:35:48 <copumpkin> lol
22:35:49 <Warrigal> > round 26.0 :: Int
22:35:51 <lambdabot>   26
22:35:54 <Warrigal> Woo.
22:36:31 <jekor> Is there a way to pattern match based on the specific type of a typeclass? I'd like to take something of (Exception e) => e and then use a case statement to take actions based on the specific exception type.
22:36:43 <Berengal> Now I want to make a global thermonuclear war game and put it in Acme.Unsafe.Missiles
22:36:47 <copumpkin> casematch!
22:36:49 <copumpkin> except no
22:37:12 <purplepenguins> unsafeLaunchMissiles?
22:37:28 <Berengal> jekor: You need a SomeException and 'cast'
22:37:39 <Berengal> Then you can match on the Maybe you get back
22:38:11 <jekor> Thanks.
22:38:20 <ray> unsafeLaunchMissiles :: LaunchCodes -> [(Latitude,Longitude)] -> IO ()
22:39:43 <ray> or just () since it's unsafe i guess.. unsafeDestroyUniverse could have type Void
22:39:57 <Berengal> Universe -> Void
22:40:00 <Berengal> Heh
22:40:19 <ray> it destroys the current universe
22:40:33 <Berengal> Luckily it's pure, so you've got a copy
22:40:50 <ray> i could put that in Acme.QuantumComputer
22:40:56 <Warrigal> Well, it works now. Yay.
22:41:04 <Berengal> We need more modules in Acme. I feel kind of lonely there now
22:41:25 <ray> i can write some, but it feels like cheating to get a hackage account just for joke packages
22:41:51 <Berengal> ray: I did, though I do indent to get a real library up some day soonish
22:41:58 <ray> indent!
22:42:08 <Berengal> Huhu
22:42:11 <ray> clearly a freudian slip
22:42:19 <ray> your library is some kind of indentation combinator library
22:42:44 <Warrigal> You know, for a few years around 1970, the launch codes were always 00000000.
22:42:45 <Berengal> Not really, but it will need indentation combinators to get the prettyprinting in order
22:43:12 <Warrigal> They didn't want the fact that someone had to enter the correct launch code to get in the way of their missile launches.
22:43:45 <Warrigal> Which defeats the purpose of having launch codes in the first place, but... that's government for you?
23:07:08 <Warrigal> @hoogle clipboard
23:07:09 <lambdabot> No results found
23:07:14 <Warrigal> Fun.
23:10:38 <lpjhjdh> so I'm trying to write a monad instance for a datatype mapping environments to values (same as reader monad) but I'm having a bit of trouble
23:10:51 <lpjhjdh> (E e) >>= f = E . join $ f . e
23:11:58 <Zeiris>  /j #moderncalcs
23:12:01 <lpjhjdh> and I'm getting Couldn't match expected type `String -> v' against inferred type `E b'
23:13:01 <aavogt> lpjhjdh: shouldn't 'E . join' basically be id?
23:14:07 <lpjhjdh> aavogt: not sure I follow
23:14:22 <lpjhjdh> I was thinking E (\k -> f (e k) k)
23:14:47 <lpjhjdh> I actually looked up the reader monad and found the same thing, not sure I'm thinking right though
23:14:58 <Twey> Warrigal: See Win32 and X11
23:15:15 <Twey> We could probably do with a low-level-ish library abstracted over those two
23:15:17 <lpjhjdh> data E v = E (Var -> v)
23:15:29 <aavogt> @unpl join $ f . g
23:15:30 <lambdabot> ((\ i -> f (g i)) >>= \ c -> c)
23:17:00 <aavogt> @pl (\k -> f (e k) k)
23:17:01 <lambdabot> f =<< e
23:17:50 <aavogt> and you have:  join $ fmap f e, which should be the same thing....
23:18:45 <lpjhjdh> I see
23:19:08 <lpjhjdh> converting to E (\k -> f (e k) k) I get essentially the same message
23:19:29 <lpjhjdh> Couldn't match expected type `k -> b' against inferred `Env k b'
23:20:24 <sjanssen> Twey: I would go straight to GTK if you want to implement clipboard stuff properly in X11
23:20:34 <Twey> I guess so
23:20:36 <lpjhjdh> oh, have to run, thanks for the help aavogt
23:20:38 <Twey> GTK works on Win32 too
23:37:51 <Zeiris> What's the Haskell GUI library of choice? (Ought to work on Windows, preferably Linux too.)
23:38:07 <Zeiris> It seems like there's a wide selection, much of it alpha/experimental.
23:39:29 <Twey> Zeiris: Yeah... the primary non-alpha choice is Gtk2Hs
23:39:47 <Twey> It's low-level, but it's a pretty solid binding.  It can use Glade and stuff, too.
23:40:22 <Zeiris> I've barely touched Gtk in Python and feel scared of it - is there anything higher level?
23:40:39 <ivanm> Zeiris: not that I know of
23:40:42 <ivanm> there's wxhaskell
23:41:05 <ivanm> IIRC, there's also fruit or grape or something
23:41:09 <ivanm> and there have been a few attempts at Qt bindings
23:42:30 <Twey> Zeiris: GTK isn't that scary, especially combined with Glade
23:43:12 <Twey> qtHaskell was actually maintained by the Trolltech team
23:43:21 <Twey> http://qthaskell.berlios.de/
23:43:29 <Twey> I presume it's comprehensive
23:43:31 <Zeiris> Oh. Glade is a GUI designer. My god, it's been a while since I had the pleasure of using one :D
23:43:52 <Twey> Hehe
23:44:04 <Twey> Yeah, Glade's one of the best GUI designers I've used
23:44:41 <Twey> It also exports its interface as an XML file that you can load into your app, so you don't have to recompile your app to change the interface, and you can use it from any language
23:45:26 <adu> is there a hac-phi channel?
23:47:16 <wqw> hi
23:48:42 * ivanm idly waves in wqw's general direction
23:49:07 <vav> adu: #haskell-hacphi
23:49:18 <adu> vav: thanks
23:49:48 <ivanm> vav: is there anyone actually there? :p
23:50:45 <vav> ivanm: I'm just lurking, not attending, but yes a few people have arrived in Phi and a few are in the channel.
23:51:40 <ivanm> vav: wasn't sure if you were serious or joking about the channel, that's all
23:53:32 <Xenophobe> how would i write "map (filter . isDigit) xs" where xs is a list of strings properly?
23:53:54 <ivanm> @type map (filter isDigit)
23:53:55 <lambdabot> [[Char]] -> [[Char]]
23:54:14 <ivanm> Xenophobe: ^^
23:54:26 <adu> oh
23:54:58 <adu> well something came up and I can't make it until saturday, or possibly sunday
23:55:03 <Xenophobe> ivanm: thanks
23:55:08 <adu> either that or I would have to cancel 2 things
23:55:08 <ivanm> Xenophobe: no probs
23:57:30 <adu> yea, looks like I can only make Hac phi on sunday...
