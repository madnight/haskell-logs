00:26:27 <kaol> It'd be nice if Cabal had a field named Changelog. It'd make browsing hackage easier. Now I have to download them to see if there's such a file or run diff or hope to see that the developer added something to the description in the newer versions.
00:33:21 <ski> (theonewhoisone : just fyi, it appears by common agreement that lambdabot is a she)
00:33:29 <ike_> kaol: It sounds nice, and I agree with it.
00:38:58 <vav> kaol: http://hackage.haskell.org/trac/hackage/ticket/299 and http://hackage.haskell.org/trac/hackage/ticket/244
00:42:56 <kaol> And some of the packages on hackage are of rather questionable usability.
00:50:00 <Beelsebob> kaol: that would indeed be nice
00:50:18 <Beelsebob> especially with a set format, so that hackage could list changes nicely between each version on the site
01:03:07 <eoeas> mike-burns: nice tutorial, simple with good sense of humour :)
01:10:27 <cads> hey is there a document that is for java as legible and elightening as the haskell98 standard is for haskell?
01:10:48 * BMeph laughs.
01:12:51 <Phillemann> Why can't I read from a named pipe via readFile? It says the file wouldn't exist, but it does.
01:12:58 <cads> you laugh only at my anguish!
01:13:19 <cads> :)
01:13:36 <cads> I'd kill for an annotated EBNF of java
01:13:45 <mmorrow> Phillemann: you may need to resort to using System.Posix.* and Fd's
01:14:10 <mmorrow> Phillemann: (or just foreign importing open/read/write)
01:14:17 <cads> oooo, http://infoether.com/~tom/java.bnf
01:14:24 <cads> *kills*
01:14:24 <mmorrow> Phillemann: i don't know how Handles deal with fifos
01:14:40 * BMeph feels sorry for cads anguish...in between discrete, muffled snickers.
01:15:07 <Phillemann> mmorrow: Me neither, but you should be able to "fopen" a fifo as if it were a file - normally.
01:15:51 <mmorrow> Phillemann: yeah i'd think so too
01:15:52 <cads> BMeph, now if haskell certification was done by some big corporation who's authority would get me a job, I would be not anguished.
01:16:26 <mmorrow> Phillemann: maybe readFile doesn't consider a fifo to be a "file" (?)
01:16:47 <mmorrow> hmm, can you readFile /dev/input?
01:17:42 <Phillemann> mmorrow: Yes.
01:18:29 <BMeph> cads: Well, you got a point there. I just hope that it doesn't come with mandatory DB training... =8*O
01:19:05 <mmorrow> hehe, /me whips the mouse around and watches the input dumped in ghci
01:19:17 <mmorrow> readFile "/dev/input/mouse1"
01:19:36 <mmorrow> Phillemann: beats me..
01:19:57 <Phillemann> mmorrow: Haskell says "/tmp/hitbot: openFile: does not exist (No such device or address)" and "ls -l" says "prwxr-xr-x 1 philipp philipp 0 2009-07-19 12:17 /tmp/hitbot".
01:20:12 <mmorrow> [m@monire ~]$ mkfifo phil.fifo
01:20:18 <mmorrow> ghci> readFile "phil.fifo"
01:20:18 <mmorrow> "^CInterrupted.
01:20:20 <mmorrow> ?
01:20:25 <mmorrow> seems to work here
01:20:30 <Phillemann> Hmmmm
01:20:43 <mmorrow> (ghc-6.10.1 in case that matters)
01:22:07 <plediii> is it worth while to make a function point free if you have to use flip?
01:22:09 <Phillemann> mmorrow: Interestring, readFile works for me, too, but writeFile doesn't.
01:22:23 <ivanm> plediii: sometimes
01:22:24 <caxaf> plediii: Depends on how it looks/works. Sometimes.
01:22:30 <ivanm> usually I use flip more for function chains
01:22:39 <ivanm> in an intermediary step of the chain
01:22:42 <Phillemann> mmorrow: I'd have thought that both functions use openFile first.
01:22:56 <plediii> ivanm: sorry, I'm new.  A chain is a series of compositions?
01:23:13 <ivanm> plediii: that's what I call it, anyway ;-)
01:23:14 <mmorrow> Phillemann: is the program running as user "philipp"?
01:23:17 <ivanm> so f . g . h
01:23:22 <Phillemann> mmorrow: Yep
01:23:39 <caxaf> plediii: If the function makes sense as infix you can also use (`f` x).
01:24:17 <mmorrow> Phillemann: ah yeah, i get that same error with {write,append}File
01:24:19 <mmorrow> *** Exception: phil.fifo: openFile: does not exist (No such device or address)
01:24:25 <plediii> i like that
01:30:49 <Peaker> plediii: calling  map (flip f)   is nicer than   map (\x y -> f y x)
01:31:00 <mmorrow> Phillemann: alternatively you could use unix domain sockets
01:35:04 <plediii> good example, thank you.
01:35:27 <Phillemann> mmorrow: Seems like I have to.
01:35:36 <Phillemann> Strange problem, though.
01:35:59 <Phillemann> I'd like to take a look at the source code for readFile and writeFile.
01:36:50 <mmorrow> Phillemann: ah nice, if you want to go there i
01:37:28 <mmorrow> 'd look at GHC.Handle maybe
01:37:28 <mmorrow> you probably need to look lower than read/writeFile
01:37:49 <Phillemann> mmorrow: Well, where do I even start? Where is read/writeFile located?
01:37:54 <mmorrow> http://darcs.haskell.org/libraries/base/GHC/
01:38:19 <Phillemann> Ah, okay.
01:38:23 <mmorrow> maybe darcs get http://darcs.haskell.org/libraries/base/
01:38:25 <mauke>        A  process can open a FIFO in non-blocking mode.  In this case, open‚Äê
01:38:25 <mauke>        ing for read only will succeed even if no-one has opened on the write
01:38:25 <mauke>        side yet, opening for write only will fail with ENXIO (no such device
01:38:25 <mauke>        or address) unless the other end has already been opened.
01:38:27 <mmorrow> then start grepping
01:38:46 <mmorrow> mauke to teh rescue with spex!
01:39:15 <Phillemann> So I have to somehow open it in blocking mode.
01:39:49 <mmorrow> [m@monire ~]$ cat phil.fifo &
01:39:49 <mmorrow> [1] 4615
01:39:56 <mmorrow> ghci> appendFile "phil.fifo" "asdf"
01:39:56 <mmorrow> asdfghci>
01:39:58 <mmorrow> nice
01:40:04 <ajray> is the website down?
01:41:00 <Phillemann> So is there a function which wraps open()?
01:42:03 <Phillemann> ajray: At least hoogle seems down.
01:42:50 <ajray> thanks
01:43:07 <mmorrow> Phillemann: openFile
01:43:12 <mmorrow> System.IO
01:44:30 <Phillemann> mmorrow: Too high level. openFile seems to pass O_NONBLOCK by default (not the best default behaviour imo).
01:44:44 <mmorrow> Phillemann: ah yeah
01:44:58 <mmorrow> Phillemann: if you need control like that just ffi import open/read/write
01:45:00 <mauke> the runtime system relies on all fds being in non-blocking mode
01:45:17 <Phillemann> mmorrow: Before I do that I better use UNIX sockets. :P
01:46:47 <mmorrow> Phillemann: for instance i'm ffi import open/read/write/dup/dup2/select in this module http://moonpatio.com/repos/lunabot/Luna/Bot/Util/Dup.hs
01:46:55 <mmorrow> it's super easy and lightweight
01:47:04 <Beelsebob> mmorrow: wow
01:47:09 <Beelsebob> that's haskell????
01:47:10 <Beelsebob> o.O
01:47:13 <mmorrow> Beelsebob: hehe
01:47:19 <mmorrow> Caskell
01:47:51 <ivanm> mmorrow: it's by Cale? :p
01:47:57 <mauke> what does that buy you?
01:48:03 <mmorrow> mauke: amusement
01:48:14 <Beelsebob> ivanm: that's Caleskell
01:48:17 <ivanm> ahhh
01:48:52 <mmorrow> (that select code i stole and slightly adapted from the oleg zfs code)
01:49:29 <mmorrow> mauke: well, it also buys not having to depend on System.Posix
01:49:35 <mmorrow> oops
01:49:43 <mmorrow> looks like i import it there anyways
01:49:54 <mauke> yeah, because non-posix systems are going to provide pipe/dup/select
01:49:59 <mmorrow> heh
01:50:16 <mauke> I still have a thread-based select somewhere
01:50:24 <mauke> done in pure haskell
01:51:49 <Phillemann> I could really use some select equivalent actually.
01:53:20 <mauke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7217#a7217
01:53:47 <mmorrow> mauke: interesting
01:54:06 <Phillemann> mmorrow: Is that tested? :)
01:54:20 <mmorrow> (@mauke)
01:54:33 <Phillemann> Yes...sorry. ;)
01:54:38 <mauke> only for trivial stuff
01:54:51 <mauke> I'm not sure if this belongs in acme or not
01:55:36 <mmorrow> Phillemann: ghc's io-manager uses select itself, so threadWaitRead/Write are hooks to uses that particular ffi import of select
01:56:30 <mmorrow> Phillemann: but the io-manager does "foreign import ccall unsafe "select"" just the same
01:57:13 <mmorrow> err, actually
01:57:22 <mmorrow> foreign import ccall safe "select"
01:57:32 <mmorrow> (s/unsafe/safe/)
01:57:48 <mmorrow> err, hmm
01:58:47 <mmorrow> yeah "safe"
01:59:23 <mmorrow> Phillemann: you can look at the haskell code that implements the io-manager (and interacts with select ffi import) in http://darcs.haskell.org/libraries/base/GHC/Conc.lhs
02:11:39 <Phillemann> Hmmm. Is there a way to wait for both a Handle and a "takeMVar" call?
02:12:25 <mauke> yeah, just do both
02:12:27 <mauke> sequentially
02:12:40 <Heffalump> you want to do something when the first returns?
02:12:59 <Heffalump> you'd have to use extra threads and another MVar/Chan
02:13:17 <Phillemann> Heffalump: Just that. I tried "race" from Unamb but it...just doesn't work.
02:13:32 <Heffalump> I don't think trying race on impure things is a good idea
02:13:46 <Phillemann> I'll try it with another thread then :)
02:14:07 <Heffalump> hmm, actually it's not obvious why it doesn't work
02:14:55 <Phillemann> Heffalump: It simple to describe how it doesn't work, however. The race doesn't return when the mvar has been filled. :)
02:15:27 <Heffalump> odd, it looks like it should..
02:16:19 <Phillemann> I can't reproduce it right now, I've replaced the code with a "wait for n seconds on the handle, then try the mvar" hack.
02:18:54 <mmorrow> i'd just forkIO a thread for each wait, then have a Chan (Either Handle a), and readChan twice
02:19:03 <mmorrow> (the `a' being from the (MVar a))
02:20:04 <Fairweather> a quick question, could ((+) . (*)) mean anything?
02:20:15 <mauke> yes
02:20:36 <mauke> ((+) . (*)) :: (Num a) => a -> (a -> a) -> a -> a
02:20:39 <Fairweather> I'm trying to figure out composition of functions of more than one argument
02:20:39 <ivanm> @type ((+) . (*))
02:20:41 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
02:20:53 <ivanm> mauke: you actually worked it out yourself? :o
02:21:00 <mauke> ivanm: no, I used ghci
02:21:13 <ivanm> why not use lambdabot or lunabot?
02:21:25 <mauke> *> ((+) . (*)) 1 2 3
02:21:25 <mauke> 5
02:21:32 <Fairweather> I still can't make head nor tail of it
02:21:46 <mauke> because they don't have an instance for Num (a -> a)
02:21:46 <mmorrow> Fairweather: you can make arbitrary instances of Num
02:22:20 <Fairweather> hmm
02:22:29 <Fairweather> so what is (a -> a) supposed to mean?
02:22:55 <mauke> Fairweather: a function taking an 'a', returning an 'a'
02:23:30 <mmorrow> instance (Num a) => Num (a -> a) where fromInteger n = (+ fromInteger n); (+) = (.)
02:23:34 <mmorrow> or something e.g.
02:24:15 <mauke> instance (Num a, Applicative f) => Num (f a)
02:24:41 <Fairweather> :t ((+) . (*2))
02:24:42 <lambdabot> forall a. (Num a) => a -> a -> a
02:25:03 <mauke> :t ((+) .) . (*)
02:25:04 <lambdabot> forall a. (Num a) => a -> a -> a -> a
02:25:09 <mmorrow> , ((+) . (*2)) 2 3
02:25:12 <lunabot>  7
02:25:22 <mauke> > ((+) .) . (*) 2 2 3
02:25:24 <lambdabot>   Overlapping instances for GHC.Show.Show (a1 -> a -> b -> b)
02:25:24 <lambdabot>    arising from...
02:25:32 <mauke> > (((+) .) . (*)) 2 2 3
02:25:34 <lambdabot>   7
02:25:45 <mmorrow> @unpl ((+) .) . (*)
02:25:46 <lambdabot> (\ d g -> (+) (d * g))
02:26:02 <mmorrow> @unpl ((+) . (*2))
02:26:02 <lambdabot> (\ d -> (+) (d * 2))
02:28:26 <Fairweather> ok, I know I can read this in a tutorial, but why isn't ((+) . (*)) just a -> a -> a -> a
02:28:43 <mauke> @src (.)
02:28:44 <lambdabot> (f . g) x = f (g x)
02:28:45 <mmorrow> @src Nm
02:28:46 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:28:47 <mmorrow> @src Num
02:28:48 <lambdabot> class  (Eq a, Show a) => Num a  where
02:28:48 <lambdabot>     (+), (-), (*)           :: a -> a -> a
02:28:48 <lambdabot>     negate, abs, signum     :: a -> a
02:28:48 <lambdabot>     fromInteger             :: Integer -> a
02:29:07 <mauke> so, let's substitute the definition of (.)
02:29:08 <mmorrow> because (+) and (*) constrain the type of `a' to be (Num a => a)
02:29:15 <caxaf> Fairweather: In (+)'s type, the b is (a -> a).
02:29:20 <mauke> mmorrow: not the point
02:29:22 <caxaf> That is, it's :: a -> (a -> a)
02:29:43 * mmorrow is confused
02:29:49 * Fairweather ponders
02:30:04 <mmorrow> @type  ((+) . (*))
02:30:06 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
02:30:07 <caxaf> ((.) only does what you think with single-argument functions.)
02:30:08 <mmorrow> oh
02:30:10 <mauke> Fairweather: ((+) . (*)) x ===> (+) ((*) x) ===> ((* x) +)
02:30:13 <mmorrow> this is the original one
02:30:25 <mmorrow> @type ((+) .) . (*)
02:30:27 <lambdabot> forall a. (Num a) => a -> a -> a -> a
02:30:37 <mauke> Fairweather: so basically, this tries to add something to (* x), which is a function
02:30:38 <mmorrow> (is what i thought we were talking about)
02:30:46 <mauke> Fairweather: and functions can't be added to because they're not numbers
02:30:59 <mauke> bah, except it should be (x *)
02:31:16 <Fairweather> I think i'm beginning to understand
02:31:36 <mmorrow> @unpl ((+) . (*))
02:31:37 <lambdabot> (\ c -> (+) ((*) c))
02:31:51 <mauke> f . g says "wait for an argument x, shove it into g, then shove the result of that into f"
02:32:03 <Fairweather> a single argument
02:32:21 <mmorrow> like dominoes waiting for the first one to be knocked over
02:32:36 <Fairweather> and suppose we pass two arguments
02:32:37 <mauke> if g really takes two arguments, it'll shove a partially applied g into f
02:32:46 <caxaf> Fairweather: Remember all functions in Haskell are of a single argument.
02:33:07 <mauke> (f . g) x y ==> ((f . g) x) y ==> (f (g x)) y ==> f (g x) y
02:33:16 <mauke> so the second argument ends up being passed to f, not g
02:33:33 <caxaf> So in (+) :: a -> (a -> a), if (.) gets an argument :: (b -> c), you can substitute a = b and a -> a = c.
02:33:44 <mmorrow> (f a . g) x y ==> f a (g x) y
02:33:52 <caxaf> (Or the other way around, rather.)
02:34:24 <Fairweather> what if we have f . g . h x y
02:34:35 <mmorrow> @unpl f . g . h x y
02:34:35 <lambdabot> (\ c -> f (g (h x y c)))
02:34:37 <Fairweather> this is f(g(h(x)) y
02:34:41 <mauke> no
02:34:54 <mmorrow> the x and y are attacked to 'h'
02:34:54 <mauke> that's \z -> f (g (h x y z))
02:35:04 <mmorrow> *attached
02:35:14 <mauke> you require more parentheses
02:35:23 <mmorrow> let h' = h x y in f . g . h'
02:35:32 <mmorrow> make it more clear i think
02:35:35 <mmorrow> makes
02:35:45 <mauke> (f . g . h) x y ==> f (g (h x)) y
02:37:40 <Fairweather> ok, thanks for the help
02:37:50 <Fairweather> I'm going to have to go over this again
02:38:37 * Fairweather buys the next round of drinks
02:38:43 <Rembane> \o/
02:44:39 * ManateeLazyCat pasted "import cycle output" at http://paste2.org/get/331854
02:44:46 <ManateeLazyCat> Above is import cycle module output by ghc, have a tips that fix .hs-boot file problem fast?
02:45:00 <ivanm> ManateeLazyCat: don't have an import cycle?
02:45:00 <ivanm> :p
02:45:12 <ManateeLazyCat> I always waste too much time to fix .hs-boot file.
02:45:31 <ManateeLazyCat> ivanm: Not one, have many import cycle,
02:45:43 <ManateeLazyCat> ivanm: If i change one file, i will got another cycle.
02:45:46 <ivanm> :o
02:45:56 <ivanm> create a non-cyclic base module?
02:46:08 <ivanm> realistically, IMHO if you have an import cycle then you've done something wrong...
02:46:13 <ManateeLazyCat> ivanm: I have change hs-boot file 10 minuts, but information http://paste2.org/get/331854 can't help me deeply.
02:46:48 <mmorrow> ManateeLazyCat: each one of those error messages is showing a strongly connected component
02:47:00 * ivanm has no idea how to use hs-boot files...
02:47:09 <ManateeLazyCat> ivanm: I developing Gtk program by Haskell, so many case i just can use IORef.
02:48:40 <ManateeLazyCat> mmorrow: In gtk2hs, some function callback must be use IORef, and i have so many modules, connected between modules is unavoidable.
02:49:14 <mmorrow> ManateeLazyCat: so to fix it you just need to pick an edge(s) in each strongly connected component to cut
02:49:44 <mmorrow> where "cut" := put the decls that cause that edge to exist in a boot module
02:50:31 <ManateeLazyCat> mmorrow: Yep, i try, but when i cut one boot file, another cycle is out.
02:50:56 <ManateeLazyCat> mmorrow: I'm tired....
02:51:22 <mmorrow> ManateeLazyCat: heh, yeah this is definitely the kinda thing that could be made easier if the compiler figured it out ..
02:51:59 <ManateeLazyCat> mmorrow: Yep, but ghc developers don't care it.
02:52:20 <ManateeLazyCat> mmorrow: They think it just a `little` problem.
02:52:31 <mmorrow> oh oops, that's a *single* scc there
02:52:35 <ManateeLazyCat> mmorrow: But import cycle problem waste much time everyday.
02:52:57 <mmorrow> (for a second there i thought it was an epic 10-different SCCs error msg :)
02:54:07 <ManateeLazyCat> mmorrow: I try to write module avoid too much connected with other modules, but it's hard to do when i just can use IORef fix gtk2hs callback function.
02:55:28 <ManateeLazyCat> I avoid to write module with too much connect with other modules.
02:56:12 <ManateeLazyCat> mmorrow: I really hope ghc support recursive import problem and without any otiose files.
02:56:25 <ManateeLazyCat> Then i'm free. :(
02:56:40 <mmorrow> ManateeLazyCat: i think the easiest solution would be to make a module TheVeryTopOfEverything, that any other module is *not* allowed to import, and that contains all the code that deals with the IORef callbacks
02:57:38 <ManateeLazyCat> mmorrow: But then code is dirty, you know i have so many modules for different function.
02:57:45 <mmorrow> then, start removing edges in the dependency graph, and any code that breaks because of that, move to TheVeryTopOfEverything
02:58:04 <mmorrow> (which may mess up your abstraction ..)
02:58:11 <ManateeLazyCat> mmorrow: I think that's a bad idea write all code in one file even it can fix import cycle problem.
02:58:47 <mmorrow> ManateeLazyCat: i'm not saying it's a good idea or pretty, but it's one way to get your program to work :)
02:59:09 <mmorrow> ManateeLazyCat: i don't mean move *everything* into one module, just the IORef callback code
02:59:22 <mmorrow> (which i guess means everything is all the code deals with those)
02:59:26 <mmorrow> s/is/if/
03:00:19 <ManateeLazyCat> mmorrow: You know, when my project is 2 file, import cycle is really `little` problem, but now it's have 30 files, import cycle make me crazy....
03:00:41 <mmorrow> ManateeLazyCat: heh, yeah it definitely starts to become an issue when you've got a lot of modules
03:01:21 <mmorrow> ManateeLazyCat: good luck
03:02:01 <ManateeLazyCat> mmorrow: I think ghc developers should output IMAGE for show cycle import path, then that's will be more help, and not information like http://paste2.org/get/331854
03:02:50 <mmorrow> ManateeLazyCat: it shouldn't be too hard to parse that output to a [(String,[String])], then prettyprint a .dot
03:04:17 <ManateeLazyCat> mmorrow: I think ghc developers will fix import cycle problem if them can output cycle import path with image.
03:05:49 <ManateeLazyCat> mmorrow: Thanks for your help, i will try to use .hs-boot file fix import cycle problem, even i hate it. I think i will hacking ghc code when i have enough time or i can't endure .hs-boot file.
03:07:25 <mmorrow> ManateeLazyCat: nice! that would be interesting. if you're interested in exploring that, join #ghc and talk about it.
03:09:47 <mmorrow> ManateeLazyCat: i'd imagine if you have (parseAndInfo :: String -> [(Import,[UsedDecls])]), you could derive a [BootFileModule] given a [FilePath{-modules-}]
03:11:22 <mmorrow> type Import = String; type UsedDecl = HsDecl
03:11:38 <mmorrow> (where the String is a module name)
03:12:25 <mmorrow> type BootFileModule = the boot module code as a String
03:13:09 <ManateeLazyCat> mmorrow: I thik should parse ghc output information and then generate image that show all connect path with modules, then parse image and highlight path that in cycle, then fix problem with highlight path in image, if it can work, then `generate image' step, patch in ghc.
03:13:56 <ManateeLazyCat> then remove `generate image` step, patch in ghc.
03:16:16 <desp> @pl (\v -> v |/ norm v)
03:16:17 <lambdabot> ap (|/) norm
03:16:22 <desp> Does this assume I'm in a monad?
03:16:39 <EvilTerran> no
03:16:45 <EvilTerran> it's using the (e ->) monad
03:16:52 <EvilTerran> > ap f g x :: Expr
03:16:54 <lambdabot>   Add a type signature
03:16:57 <ivanm> so it _uses_ a monad
03:16:59 <EvilTerran> > ap f (g :: Expr -> Expr) x :: Expr
03:17:01 <lambdabot>   f x (g x)
03:17:05 <ManateeLazyCat> mmorrow: I will try to write code fix import cycle problem after i fix current problem in my projects, thanks for your help and suggestions! :)
03:17:17 <ivanm> @type norm
03:17:17 <mauke> desp: you are in a monad.
03:17:18 <lambdabot> Not in scope: `norm'
03:17:21 <ivanm> gah
03:17:24 <ivanm> @type ap
03:17:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:17:31 <ivanm> the identity monad also works
03:21:16 <Peaker> hmm.. the ghci debugger is not as bad as I remembered it. At least not if you know :list :)
03:21:38 <mmorrow> @tell ManateeLazyCat i've got some (rough) code that makes module dep graphs ($ find . | grep -E "\.l?hs" | grep -v _darcs | ./modg.sh | dot -Tpng > foo.png) **you need ghc-6.10.* http://moonpatio.com/repos/modg/
03:21:38 <lambdabot> Consider it noted.
03:21:56 <mmorrow> dang, just missed him
03:24:29 <desp> mauke: you're making me scared.
03:24:30 <desp> :)
03:26:00 <mauke> desp: functions form a monad. they're everywhere.
03:26:01 <EvilTerran> desp, you are number six.
03:26:04 <EvilTerran> ;)
03:26:05 <ivanm> mmorrow: I still think he should have rewritten his code not to have cycles in his imports...
03:26:18 <ivanm> EvilTerran: he
03:26:25 <ivanm> *he's number six _what_?
03:26:46 <mmorrow> ivanm: yeah, given that ghc can't do cyclic modules, that probably would have been the easiest way
03:27:01 <mmorrow> ivanm: sometimes it really becomes unavoidable though
03:27:17 <EvilTerran> google.com/search?q=you+are+number+six
03:27:21 <ivanm> O RLY? to the extent that he was complaining?
03:27:43 <mmorrow> ivanm: and then the fact that you have to force acyclicity (a word?) breaks your abstractions
03:27:47 <ivanm> ahhh, TV show reference
03:28:04 <ivanm> mmorrow: yeah
03:36:35 <mmorrow> heh, i get some sort of sick amusement out of generating 100,000 line C files of data/variations on a single function
03:38:44 <mmorrow> @let combs n xs = foldr (\xs xss -> [a:as | a <- xs, as <- xss]) [[]] (replicate n xs)
03:38:46 <lambdabot>  Defined.
03:39:23 <mmorrow> > length (combs 7 [1,2,3,4,5,6])
03:39:26 <lambdabot>   279936
03:40:17 <mmorrow> > length (combs 7 ["void","int","long","float","double"])
03:40:19 <lambdabot>   78125
03:41:48 <mmorrow> if CPP could do computations and splice the result into the C, it would be soooo much better
03:42:09 <mauke> boost::preprocessor
03:42:22 * mmorrow googles
03:44:33 <mmorrow> interesting
03:44:34 <soupdragon>  <mmorrow> if CPP could do computations and splice the result into the C, it would be soooo much better
03:44:35 <soupdragon> ????
03:44:40 <mmorrow> i guess that needs C++ though
03:44:47 <mmorrow> soupdragon: like
03:44:51 <mauke> don't be fooled by the C++ examples, the headers themselves are pure preprocessor hax
03:45:05 <mauke> i.e. usable from C
03:45:09 <mmorrow> mauke: ooh, interesting. /me checks that out
03:45:32 <mmorrow> soupdragon: like suppose i want a data decl like
03:45:39 <mmorrow> (using haskell here)
03:45:58 <mmorrow> data Vec1024 = Vec1024 !Int !Int ...... !Int
03:46:03 <mmorrow> x1024 Ints
03:46:08 <dblhelix> question: can I somehow tweak the haddock options that cabal-install uses when installing a package and its documentation?
03:46:15 <mmorrow> i can do that in TH with one line
03:46:46 <mmorrow> but struct {int x1; ..... int x1024;}; however ...
03:47:08 <mmorrow> or suppose i want 80,000 variations on a function, each with minor differences
03:47:11 <soupdragon> wtp
03:47:21 <soupdragon> youse an array though
03:47:28 <mmorrow> soupdragon: ok, bad example
03:47:37 <mmorrow> soupdragon: one second, i'll get a good one
03:50:03 <mmorrow> soupdragon: it would be swell if you could use CPP to generate e.g. this http://moonpatio.com/repos/unpack_pap.c
03:51:26 <mmorrow> also, with TH you can do arbitrary IO too..
03:52:17 * mmorrow imagines some TH code that runs a webserver for a year, collect some sort of statistic, then splices a single Int into the program :)
03:52:34 <mmorrow> longest compile evar!
04:20:39 <dennda> Hi. I'm sorry for asking a somewhat offtopic question immediately, but I figured you may be familiar with the topic: What is the difference between 2-vitality and 3-vitality as defined here: http://www.softwarekompetenz.de/?27006&highlight=teilw ? (where "vitality" is "lebendig" in german)
04:21:19 <mauke> that link doesn't work
04:21:36 <dennda> hm works for me
04:21:47 <mauke> Bitte nutzen Sie den folgenden Link zur Einstiegsseite:
04:21:51 <mauke> Homepage software-engineering.de
04:22:05 <dennda> let me translate
04:22:27 <C-Keen> please use the following link to the starting page
04:22:39 <mauke> why translate?
04:23:14 <dennda> because it's german and this channel is english and obviously I need to type it anyways :-)
04:23:39 <mauke> there's an English version below
04:24:42 <dennda> I'm blind, obviously
04:40:45 * mmorrow svn co boost
04:43:10 <desp> Is there any way I could express something like this:  type family Foo a b; type instance (Bar a) => Foo a Baz = Baz
04:44:20 <desp> I would like the type instance to be valid only for types in the type class Bar
04:44:22 <mmorrow> data IsBar a where IsBar :: (Bar a) => IsBar a; this:  type family Foo a b; type instance Foo (IsBar a) Baz = Baz
04:44:23 <mmorrow> maybe
04:44:50 <mmorrow> hmm, that could be a useful trick in general
04:44:58 * mmorrow wonders if it works
04:45:04 * desp checks
04:45:57 <ivanm> desp: usually, that's left up to the functions rather than the data structures, etc. themselves...
04:46:22 <desp> ivanm: I know, but I'm reaching into millioleg range now.
04:46:28 <ivanm> heh
04:46:51 <mmorrow> ooh nice, looks like it accepts it at least
04:47:28 <desp> mmorrow: this requires GADT syntax?
04:48:01 <mmorrow> desp: yes, although hmm
04:48:18 <mmorrow> desp: err, yeah i think there's no way to phrase that without a GADT
04:48:36 <desp> OK, thanks.  I'll let you know how this turns out.
04:48:43 <Saizan> data IsBar a = Bar a => IsBar a
04:48:47 <mmorrow> desp: cool, good luck
04:48:57 <mmorrow> Saizan: but IsBar has no value inside
04:49:07 <mmorrow> data IsBar a where IsBar :: (Bar a) => IsBar a
04:49:29 <Saizan> oh, misparsed
04:49:42 <Saizan> maybe it still works though
04:51:39 <desp> BTW, I'm still impressed by the trick used to lift numbers from the type system to values.
04:52:01 <mmorrow> aww crap, it looks like ghc doesn't actually check that there's an instance of Bar here
04:52:22 <dhun> I am playing with monads for a few hours now, an I wanted to do something with monads IO and concurrency
04:52:23 <mmorrow> (which actually i think could be considered a bug, given that the type instance is accepted at all?)
04:52:52 <dhun> I wrote the a very simple code using only the IO monad
04:52:57 <dhun> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7219#a7219
04:53:24 <dhun> but I would like to write my own monad, in order to hide concurrency a bit more
04:53:35 <dhun> but somehow I don't manage to that
04:53:35 <mmorrow> desp, Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7220  ??
04:54:06 <dhun> I ended up with the error data constructor IO not in scope
04:54:12 <desp> mmorrow: aw.
04:54:14 <mmorrow> desp, Saizan: i was expecting "test0 (42::Float)" to be rejected, but it wasn't. is that a valid thing to expect?
04:54:31 <desp> mmorrow: I think it would, but hey, that's what I would like to do.
04:54:38 <desp> s/would/is/
04:54:53 <mmorrow> because "IsBar :: IsBar Float" *is* rejected
04:55:10 <desp> Do you have GHC HEAD?
04:55:15 <Saizan> mmorrow: mmh, i don't think it's quite valid to expect, the context is only checked at construction of an IsBar
04:55:21 <mmorrow> ooh, no but i'll check it in that
04:55:27 <Saizan> mmorrow: but you don't actually have an IsBar value anywhere
04:55:46 <mmorrow> Saizan: ahh, so a workaround would be:
04:58:00 <mmorrow> hmm, so i guess you need to require an (IsBar a) as one of the args
04:58:12 <mmorrow> (or else put an (Bar a => ) constraint there
04:58:28 <mmorrow> which makes sense
04:58:42 <Saizan> and pattern match on it, otherwise i can pass you undefined :)
04:59:59 <mmorrow> heh
05:00:56 <mmorrow> oh
05:01:27 <mmorrow> i see, so it only actually checks at construction time (which you said, but i didn't realize all that that meant)
05:01:32 <mmorrow> ghci> :t undefined :: IsBar Float
05:01:32 <mmorrow> undefined :: IsBar Float :: IsBar Float
05:02:16 <mmorrow> Saizan: is there any particular reason why ghc doesn't reject that?
05:02:19 <Saizan> yup, and it does so because of the type of the IsBar constructor
05:03:29 <Saizan> mmorrow: because you'd have to extend the kind system, i think
05:03:39 <mmorrow> ah, hmm
05:05:50 <mmorrow> i dunno though, since the typechecker has to check whether Float is an instance of Bar to construct a value, why not also do it when some value claims to be an (IsBar Float) also?
05:06:09 <mmorrow> it seems to me there'd be no difference
05:06:48 <EvilTerran> mmorrow, because the class constraint is associated with the value constructor, not the type constructor
05:07:23 <mmorrow> EvilTerran: ah, so then ghc just doesn't bother checking the type if it doesn't actually have to physically attach a class dictionary to some value?
05:07:26 <EvilTerran> in this case, there's only one value constructor, so it *could* infer as you suggest, but that doesn't apply in general
05:08:05 <mmorrow> EvilTerran: wouldn't the applicability be checkable also?
05:08:08 <Saizan> also, right now i can have a function :: IsBar Float -> Something, and let the caller decide if it wants to make a Bar Float instance
05:08:45 <EvilTerran> mmorrow, "the applicability"?
05:08:46 <Saizan> if you check the existence of the instance everytime i apply the IsBar type constructor that type is invalid
05:08:55 <mmorrow> Saizan: hmm, that's a good argument for not checking
05:09:04 <mmorrow> EvilTerran: "but that doesn't apply in general"
05:09:17 <EvilTerran> sure, but that'd be adding special cases
05:09:50 <EvilTerran> anyway, (undefined :: IsBar a) regardless of what type 'a' is
05:09:50 <mmorrow> EvilTerran: well sure, the typechecker would need to see if the situation is such that it does apply
05:10:21 <mmorrow> EvilTerran: ah, hmm that's an interesting viewpoint
05:10:57 <EvilTerran> in contrast to (IsBar undefined :: IsBar a), which demands a (Bar a) constraint.
05:11:00 <mmorrow> EvilTerran: hmm, actually thinking about that, that type should be constrained to be
05:11:14 <mmorrow> undefined :: Bar a => IsBar a
05:11:19 <mmorrow> i'd think
05:11:34 <mmorrow> (?)
05:11:55 <mmorrow> but that's incompatible with how you don't have to specify the constraint there
05:12:09 <mmorrow> which brings us back to where we started
05:12:42 <EvilTerran> mmorrow, as i say, the class constraint is attached to the value constructor, so that Bar constraint would naturally be on (IsBar undefined), but not on undefined proper, as that's not using the constructor
05:13:02 <mmorrow> EvilTerran: IsBar contains no value
05:13:33 <EvilTerran> sorry, not "IsBar undefined", then, just the value IsBar
05:13:52 <mmorrow> hmm
05:14:07 <EvilTerran> IsBar :: Bar a => IsBar a; undefined :: IsBar a
05:15:48 <EvilTerran> mmorrow, compare "data FooOrBar a where IsFoo :: Foo a => FooOrBar a; IsBar :: Bar a => FooOrBar a"
05:15:58 <Berengal> Augh! Unicode trouble!
05:16:29 <Berengal>  \248 is read as \195\194
05:17:26 <desp> Saizan: do you remember the URL of the page about context-senstivie instances?
05:17:32 <desp> Saizan: sensitive*
05:17:45 <Saizan> ?google haskellwiki AdvancedOverlap
05:17:45 <desp> I can't find it on the GHC wiki.
05:17:47 <lambdabot> http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
05:17:47 <lambdabot> Title: GHC/AdvancedOverlap - HaskellWiki
05:17:50 <desp> Ahh, Overlap.
05:17:51 <desp> Thanks.
05:18:10 <mmorrow> EvilTerran: i see. but i still feel like there's some sort of "impedance mismatch" (closest phrase i could think of to describe this) between how you can do pseudo-dependent types with GADTs and the parametric-polymorphism-caller-determines-the-type-of-a-forall-a thing with haskell's type system
05:18:56 <Saizan> mmorrow: it's just that haskell is inconsistent and you can prove anything :)
05:18:58 <mmorrow> err, actually i guess this is about how GADTs and typeclasses interact
05:19:05 <mmorrow> Saizan: heh
05:19:28 <Berengal> Now it suddenly stopped... :/
05:19:35 <Saizan> that's why gadts give you the refinements only if you strictly match on them
05:19:46 <Saizan> you've checked termination that way.
05:20:10 <mmorrow> Saizan: ahh
05:21:13 <mmorrow> so the check is forced to be deferred until runtime because of how the typesystem works
05:22:56 <mmorrow> anyways, boost finally finished svn co'ing
05:22:58 * mmorrow disappears
05:25:18 <mmorrow> gah, 91600 files in the svn repo
05:27:06 <Phillemann> svn co should _really_ pack the data before sending them (file by file)
05:31:45 <hackagebot> persistent-map 0.2.2 - A thread-safe interface for finite map types with optional persistency support. (PeterRobinson)
05:32:12 <EvilTerran> Phillemann, yeah, even just on-the-fly tarballing would probably speed that up substantially
05:32:18 <desp> I'm confused again.  Is it possible to write a function with type :: (Num a) => Double -> a -> Double
05:32:21 <desp> ?
05:32:40 <EvilTerran> ?type const :: (Num a) => Double -> a -> Double
05:32:42 <lambdabot> forall a. (Num a) => Double -> a -> Double
05:32:50 <EvilTerran> desp, did you have something more specific in mind? :P
05:32:53 <desp> :)
05:33:03 <desp> Yes, mutiplication.
05:33:09 <desp> Multiplication, even.
05:33:26 <mauke> desp: in general, no
05:33:33 <mauke> because that a could be a complex number
05:34:03 <desp> I guess what I really want is  numToDouble :: (Num a) => a -> Double
05:34:19 <mauke> what would that do for complex numbers?
05:34:23 <EvilTerran> ?type realToFrac -- is the best you'll do in that regard, i believe, desp
05:34:25 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
05:34:36 <EvilTerran> ?instances Real
05:34:37 <lambdabot> Double, Float, Int, Integer
05:34:41 <EvilTerran> ?instances Fractional
05:34:42 <lambdabot> Double, Float
05:34:47 <desp> Right.
05:34:51 <Erik____> hey guys, quick piece of help for a beginner if you will, why does           map ("A":) [],        return an empty [], when I'm expecting ["A"]
05:35:02 <EvilTerran> ?src map
05:35:03 <lambdabot> map _ []     = []
05:35:03 <lambdabot> map f (x:xs) = f x : map f xs
05:35:17 <EvilTerran> Erik____, map ("A":) [] = map _ [] = []
05:35:51 <EvilTerran> Erik____, mapping over a list of a given length will always give back a list of the same length
05:35:55 <mauke> Erik____: because map calls a function for each list element. you have no elements.
05:35:56 <Saizan> Erik____: map applies the function to every element in the list, if the list is empty it returns an empty list
05:36:06 <EvilTerran> ?quote fire.hose
05:36:07 <lambdabot> byorgey says: sometimes asking #haskell for help can be like taking a drink from a fire hose
05:36:11 <Erik____> ah, okay okay.
05:36:12 <Erik____> thanks.
05:36:15 <mauke> > ("A":) []
05:36:16 <EvilTerran> :)
05:36:16 <lambdabot>   ["A"]
05:36:29 <mauke> > let map = id in map ("A":) []
05:36:31 <lambdabot>   ["A"]
05:36:38 <ike_> hehe
05:36:50 <dobblego> > ($) ("A":) []
05:36:52 <lambdabot>   ["A"]
05:37:47 <desp> #haskell-in-depth seems to be dead, though.
05:37:53 <pikhq> > ("A":)<$>[]
05:37:54 <lambdabot>   []
05:38:02 <pikhq> Yay.
05:38:19 <EvilTerran> desp, in that case, we might as well discuss in-depth haskell in here, if you've got something specific in mind
05:38:56 <desp> EvilTerran: I've been getting great help here all weekend. ;)
05:41:33 <ike_> well, it seems my turn; we plan a local and informal meeting about Haskell
05:42:09 <ike_> how to link our announce page to the official Haskell webpage as an event?
05:42:20 <ike_> http://atnd.org/events/1048
05:42:37 <mmmulani> are infinite maps possible?
05:43:02 <ike_> > take 3 (map (+1) [0..])
05:43:04 <lambdabot>   [1,2,3]
05:43:34 <ike_> more simple one
05:43:40 <ike_> > take 3 [0..]
05:43:42 <lambdabot>   [0,1,2]
05:43:49 <mmmulani> I mean a Data.Map
05:47:12 <Berengal> No, Map is strict in its keys
05:47:30 <mmmulani> ahhh
05:47:53 <Berengal> You can see this with :info Map in ghci
05:48:11 <mmmulani> would it be faster to use a map in a memoized function?
05:48:35 <Berengal> If you want memoization, you want lazyness usually
05:48:43 <Berengal> Otherwise you'll have to pass the map in as an extra parameter
05:48:56 <mmmulani> yeah, that's how I was thinking of doing it
05:48:57 <Berengal> Fortunately, there's Data.MemoTrie
05:49:05 <mmmulani> oh
05:49:17 <Berengal> (In the MemoTrie package)
05:49:41 <mmmulani> hmm reading up on this now
05:49:49 <mmmulani> is list access in a memoized function still O(n)?
05:50:08 <mmmulani> (for the list of previous values of the function)
05:50:29 <Berengal> Tries have O(log n) lookup I believe
05:50:48 <Berengal> Well, -ish
05:51:12 <Berengal> O(length key) or something...
05:52:57 <Berengal> If you want to know which values are already memoized, that's a bit hard with lazy memotries, as the answer is always "all of them"
05:55:58 <mmmulani> ahahah
05:56:13 <mmmulani> I'm going to try this out with a Map
05:56:58 <ike_> I noticed my previous question was wrong
05:57:37 <ike_> by the way, I'll try to contact the admin of the Haskell page : http://www.haskell.org/
06:01:47 <jav> Hi there! I'm trying my first steps with the FFI ... I would like to access GDK_WINDOW_XID(win) (#defined in gdk/gdkx.h) from Haskell. I read somewhere that #define is not accessible for the FFI. How do I go about this then?
06:04:59 <desp> jav: if that's indeed the case, why not wrap it into a C function of your own?
06:05:40 <pikhq> Yeah, write a quick C function.
06:06:34 <jav> desp: I have thought of that, yes .. alright, I'll give that a try
06:12:21 <mmorrow> jav: hsc2hs is handy for that
06:12:48 <mmorrow> jav: oh, a macro..
06:13:21 <mmorrow> jav: hmm, maybe you can do macros in hsc2hs, not sure
06:13:28 <mmorrow> i usually wrap those in C functions
06:14:01 <jav> mmorrow: I see, thx.. I'll have a look at hsc2hs as well
06:17:37 <mmorrow> jav: here's a minimal example of using hsc2hs http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7224#a7224
06:17:50 <CalJohn> How important do people making the default evaluation lazy is?  (Compared to Scheme or Oz, for example, where the default is strict but lazy is possible.)
06:19:04 <jav> mmorrow: cool, thx.. I'll use that as a starting point
06:19:08 <mmorrow> jav: also, (#peek <typename>,<field>), (#poke <typename>,<field>), (#ptr <typename>,<field>) for structs are super handy
06:23:34 <mmorrow> CalJohn: strict is possible in haskell too, with i'd say the equivalent amount of extra work as being lazy in scheme is
06:24:54 <CalJohn> mmorrow: yeah, i know, I'm justing wondering about the importance of which is the default
06:25:43 <mmorrow> CalJohn: also, if you have a pure strict language, then "tying the knot" becomes a lot more complicated
06:27:00 <mmorrow> CalJohn: i think which is the default is a very important choice if you want to make a language that you can use to program in a particular way
06:27:45 <mmorrow> CalJohn: but not relative to some pre-idea as to what you want to do, i don't think it's possible to answer that
06:29:17 <gwern> huh. did you know there's a moore's law for hard drives? krdyer's law: they get 40% better every year
06:29:35 <mmorrow> CalJohn: i wonder what a language would be like that lets you alternate between strict-/by default/ and lazy-/by default/ somehow
06:29:57 <Berengal> There were a couple of papers some time back showing how a pure strict language couldn't solve a given problem with as good time complexity as an impure strict language, but a pure lazy language could
06:30:44 <mmorrow> foo 0 = (|0|); foo n = (|if n < 10 then foo (n+1) else [|foo (n+1)|]|)
06:30:51 <mmorrow> (|...|) := strict
06:30:57 <mmorrow> [|...|] := lazy
06:31:00 <mmorrow> or something
06:31:04 <mmorrow> would be interesting
06:32:06 <mmorrow> let f n = (|let x = n-1 in [|foo x|]|)
06:32:43 <CalJohn> Berengal: I've vaguely heard about that issue, but I don't know of any good examples.  Any ideas what the paper was called?
06:32:51 <CalJohn> mmorrow: what do you mean by "tying the knot"?
06:32:54 <mmorrow> heh, that's essentially like TH, but s/quote/lazy/ and s/now/strict/
06:33:16 <mmorrow> CalJohn: constructing a value that contains a pointer to itself
06:33:23 <pikhq> mmorrow: Strictly evaluating n-1 and handing out a thunk. Nice. :D
06:33:43 <mmorrow> let x = Node () [x,x] in x
06:33:48 <Berengal> CalJohn: The response paper was called "More haste, less speed: lazy versus eager evaluation"
06:34:27 <CalJohn> thank you
06:34:37 <mmorrow> pikhq: a language like that would be pretty cool
06:34:44 <pikhq> It would.
06:35:21 <mmorrow> CalJohn: re: tying the knot and strict (pure) langs, this is relevant too: http://www.ittc.ku.edu/~andygill/papers/RecBinds.pdf
06:35:23 * CalJohn wonders what he will do when he graduates and can't get papers for free anymore
06:35:53 <mike-burns> CalJohn: You'll get them for free through your friends-of-friends who still can.
06:35:53 <lambdabot> mike-burns: You have 1 new message. '/msg lambdabot @messages' to read it.
06:36:39 <mike-burns> Berengal: Agreed about the IRC lectures. I'll keep my eye out for more and try to add to my collection of one.
06:36:59 <Berengal> mike-burns: perhaps set up a wiki or something too...
06:37:16 <mike-burns> Could we use an existing wiki for this?
06:37:22 <Berengal> gitit?
06:37:27 <mmorrow> gitit++
06:37:36 <mike-burns> I meant like this: http://www.haskell.org/haskellwiki/
06:38:20 * Berengal is planning on leveraging the synergestic interoperation between gitit and darcs to provide a multi-platform dynamic project management platform
06:38:36 <Berengal> mike-burns: Yeah, That could work too
06:39:42 <mike-burns> Project management with gitit, darcs, ... and some ticket tracker/todo list thing?
06:39:49 <Berengal> Yeah
06:40:09 <mmorrow> Berengal: ooh, do it!
06:40:24 * mmorrow would start using that immediately
06:40:30 <CalJohn> mike-burns: argh, actually, I can't get that one for free
06:40:32 <Berengal> Based on the complete lack of project integration at work, plus we're using CVS...
06:41:16 <CalJohn> ah, found it
06:41:17 <mike-burns> Would this be a replacement for SourceForge, or a replacement for e.g. BaseCamp + JIRA + CVS?
06:41:26 <Berengal> I was thinking something that created a wiki, darcs repo and issue tracker, plus some user management stuff...
06:41:42 <mmorrow> yeah, like a TRAC replacement-ish thingy
06:41:46 <soupdragon> get some CS seminars on IRC
06:42:01 <soupdragon> like #mathematics sometimes do
06:42:17 <CalJohn> Berengal: ...that sounds like Trac
06:42:33 <soupdragon> hmm
06:42:35 <mike-burns> Sounds like Github, too. Only with git instead of darcs.
06:42:35 * mmorrow hates trac
06:42:44 <soupdragon> I wish I had a better term than 'CS'
06:42:53 <CalJohn> mmorrow: why?
06:43:12 <CalJohn> soupdragon: 'FP'?
06:43:46 <mmorrow> CalJohn: because it's written in an untyped, interpreted language
06:44:25 <mmorrow> CalJohn: and it needs apache/whatever
06:44:26 <mike-burns> I hate Trac because it's ugly and I find it difficult to use.
06:44:31 <mmorrow> yeah, that too
06:44:46 <MyCatVerbs> mmorrow: Trac doesn't need Apache.
06:44:49 <soupdragon> not FP
06:44:51 <CalJohn> yeah, the apache thing is quite annoying, but I'm not one to shun things that largely work
06:44:52 <mmorrow> and it being difficult to use probably means that it would be hellish to customize
06:44:59 <MyCatVerbs> I've deployed it without myself.
06:45:03 <CalJohn> cutting out apache from trac would be very nice
06:45:09 <mmorrow> MyCatVerbs: their standalone webserver is pretty sucky iirc
06:45:16 <mike-burns> Oh Trac is written in Python. Interesting.
06:45:29 <MyCatVerbs> mmorrow: it's fine for a few dozen people to use as an internal app.
06:46:39 <mmorrow> MyCatVerbs: sure, but not for much more than that
06:47:01 <mmorrow> whereas many public-internet-facing sites are running on HAppS
06:47:32 <mike-burns> What's the highest-trafficked HAppS site these days?
06:47:43 <mmorrow> i was just trying to think of that
06:47:45 <mmorrow> i dunno
06:47:49 <mike-burns> Ha.
06:48:46 <CalJohn> speaking of happs, what's the best tutorial to use?
06:49:04 <gwern> @quote square.root
06:49:05 <lambdabot> Berengal says: For me, understanding the basics/reasoning behind haskell's type system was just a minute meditating on the phrase "what's the square root of hello?"
06:49:09 <CalJohn> considering that http://happstutorial.com/ is down and has been for a while
06:49:19 <gwern> @quote studliness
06:49:20 <lambdabot> bitwize says: The oleg is to functional studliness as the farad is to capacitance: a hopelessly large base unit.
06:49:59 <gwern> isn't the tutorial at http://code.google.com/p/happs-tutorial/ ?
06:50:08 <gwern> @quote euclidate
06:50:09 <lambdabot> maartenm says: euclidate: to promote a conjecture to an axiom just for the sake of simplicity
06:50:21 <gwern> @quote pale.imitation
06:50:22 <lambdabot> RobertGreaye says: Some suggest the original English remained in Britain when the North Americas by the British settlers, leaving a pale imitation back in Britain. The truth is much stranger: the
06:50:22 <lambdabot> original English was actually smuggled out of Britain to the West Indies in a wardrobe
06:50:40 <gwern> @flush
06:50:44 <gwern> boring week in haskell-land
06:51:14 <mike-burns> I was shocked at how small the Haskell Sequence was this week.
06:51:35 <mike-burns> Must be the nice weather. Worldwide. Or something.
06:52:03 <ManateeLazyCat> Have Haskell compiler fix "mutual recursion import"  problem without hs-boot file or anything? I can't endure ghc's hs-boot file anymore.
06:52:04 <lambdabot> ManateeLazyCat: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:53:30 <mmorrow> CalJohn: i'd read the Gitit sourcecode as a start
06:54:19 <gwern> I wouldn't. it's more than a bit messy, and involves tons of libraries
06:54:20 <mmorrow> CalJohn: there's a single 1000-line-ish module that implements 90% of the entire thing iirc
06:54:56 <ManateeLazyCat> I ready hacking ghc code to re-implement "mutual recursion import" solution.
06:55:05 <mmorrow> gwern: do you know of another module that implements an entire HAppS-based (nice) application in a single module?
06:55:06 <ManateeLazyCat> Have Haskell compiler fix "mutual recursion import"  problem without hs-boot file or anything?
06:55:18 <gwern> mmorrow: the tutorials?
06:55:28 <Saizan> ManateeLazyCat: no
06:55:29 <ManateeLazyCat> I want to read source code if have compiler implement that.
06:55:29 <mmorrow> gwern: (emphasis on "nice" :)
06:55:37 <mmorrow> (also on "entire")
06:55:55 <uzytkownik> Hello. I need to get into parsec. What's the difference between Consumed and Empty
06:55:59 <mmorrow> gwern: i just mean that it is "real world" code
06:56:07 <ManateeLazyCat> Saizan: Haven't any compiler implement it?
06:56:55 <Saizan> ManateeLazyCat: JHC, i think
06:57:04 <gwern> well, Consumed means that the input's soul has been devoured by Cthulhu; Empty means that it's been sucked out by a dementor. needless to say, these use existential quantification so they aren't observably different
06:57:08 <Saizan> ManateeLazyCat: but JHC does whole-program compilation
06:57:16 <mmorrow> Saizan: jhc can do it, but unfortunately it's incomplete wrt having a garbage collector
06:57:54 <ManateeLazyCat> Saizan: You mean JHC will compile all modules even you just modified one?
06:58:22 <gwern> ManateeLazyCat: it *is* a whole-programm compiler, after all
06:58:30 <gwern> so that wouldn't be too surprising
06:58:31 <uzytkownik> gwern: That was helpful...
06:58:46 <gwern> np
06:59:01 <mmorrow> gwern: lol
06:59:41 <Berengal> uzytkownik: I've used parsec for some time, and I have no idea. I don't think you need to know
06:59:43 <mmorrow> ManateeLazyCat: jhc really isn't an option for a "real" project
06:59:44 <ManateeLazyCat> gwern: whole-program compiler? What's mean?
07:00:32 <ManateeLazyCat> mmorrow: I'm don't use jhc compile project, i just want to know it how to fix "mutual recursive import" problem, then i implement it in GHC
07:00:46 <ManateeLazyCat> s/don't/don't want
07:01:05 <mmorrow> ManateeLazyCat: ah, let me find a link that i saw the other day that might be useful
07:01:24 <mmorrow> ManateeLazyCat: also, that "modg" code can make a pretty graph of your module deps in the meantime
07:01:28 <ManateeLazyCat> mmorrow: I can't endure GHC's hs-boot file anymore, ANYMORE!
07:01:33 <mmorrow> heh
07:01:47 <gwern> he who is tired of GHC, is tired of life.
07:01:50 <ManateeLazyCat> mmorrow: http://moonpatio.com/repos/modg/ ?
07:01:55 <mmorrow> ManateeLazyCat: yes
07:02:10 <ManateeLazyCat> mmorrow: Thanks! I try it.
07:02:55 * Saizan wonders if you could infer .hs-boot files
07:03:19 <mmorrow> ManateeLazyCat: it's rough code at the moment, i just threw haphazardly a bunch of modules from different places into that repo the other day, and made a quicky shell script wrapper, but it works (And uses ghc's parser)
07:03:35 <mmorrow> ManateeLazyCat: i usually run it like
07:03:45 <uzytkownik> Berengal: Unfortunately I need to suspend/resume parsing as I'm dealing with network input and parsec seems to evaluate the result of getInput. This hangs the hole execution as it tries to read input which will be send when I send the next command to server - but the command is send in next step so I achived deadlock.
07:03:50 <mmorrow> (in the root directory of a package)
07:04:10 <ManateeLazyCat> mmorrow: Can you upload it by cabal?
07:04:11 <mmorrow> find . | grep -E "\.hs$" | grep -v _darcs | modg.sh
07:04:23 <mmorrow> ManateeLazyCat: it's not cabal-ified at the moment
07:04:34 <mmorrow> there's just that Makefile (and you need ghc-6.10.*)
07:04:41 <ManateeLazyCat> mmorrow: Ok.
07:05:02 <Berengal> uzytkownik: Are you using monad transformers?
07:05:10 <ManateeLazyCat> mmorrow: Just download all file in http://moonpatio.com/repos/modg/, then make?
07:05:18 <mmorrow> the "modg.hs" driver prog is really simple too, should be easy to modify
07:05:33 <Paczesiowa> > show $ read ""
07:05:38 <lambdabot>   "* Exception: Prelude.read: no parse
07:06:05 <uzytkownik> Berengal: Yes. But not in this code. If you want I pastie code in a second.
07:06:49 <mmorrow> ManateeLazyCat: basically it does 'pprintDot . extractModuleGraph =<< mapM readModuleParseHeader . lines =<< getContents'
07:08:10 <ManateeLazyCat> mmorrow: I'm installing miss libraries for modg
07:08:26 <mmorrow> ManateeLazyCat: that "Parser.hs" is ghc's parser i took from ghc and made a few changes (which are irrelevant here i iirc), and that "P.hs" is code that wraps actually using the parser, and "LunaGHC.hs" is random other ghc-related code i have that P.hs uses i think
07:09:26 <mmorrow> like i said, this repo wasn't really "planned", just thrown together really fast to link someone to
07:09:40 <jav> I don't understand these type information... working with gtk2hs, I get this output from ":info Window": newtype Window Graphics.UI.Gtk.Types.Window (GHC.ForeignPtr.ForeignPtr Window) ... how can Window be defined in terms of itself? appearing next to ForeignPtr again?
07:09:42 <uzytkownik> Berengal: Hole file: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7225#a7225, Problematic method: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7226#a7226
07:10:21 <jav> missing an =, this is correct: newtype Window = Graphics.UI.Gtk.Types.Window (GHC.ForeignPtr.ForeignPtr Window)
07:10:26 <uzytkownik> Berengal: Execution does not pass after the highlighted line.
07:11:01 <Paczesiowa> jav: second window is different than first one, and third one is just phantom type for pointers
07:11:14 <ManateeLazyCat> mmorrow: Sorry, Emacs crash,
07:11:34 * ManateeLazyCat I can't endure Emacs too....
07:12:04 <mmorrow> ManateeLazyCat: ah yeah, also you may want to pipe the .dot through "tred" too, which makes it much more readable
07:12:14 <mmorrow> .. | tred | dot -Tpng > out.png
07:12:40 <jav> Paczesiowa: I see... if I have a 'Window', is there a way to get to the underlying ForeignPtr? or is this impossible because of the 'newtype'?
07:12:42 <ManateeLazyCat> mmorrow: I have compile modg successful, how to use it?
07:13:01 <ManateeLazyCat> mmorrow: Sorry, i use Emacs login IRC, and emacs crash, message you send miss.
07:13:15 <mmorrow> ManateeLazyCat: use the shell script modg.sh which wraps it
07:13:37 <mmorrow> echo 'Foo.hs Asdf.hs' | modg.sh | tred | dot -Tpng | display
07:13:39 <mmorrow> e.g.
07:13:57 <mmorrow> find . | grep -E "\.hs$" | modg.sh | tred | dot -Tpng | display
07:14:05 <Paczesiowa> jav: windows IS pointer wrapped in a newtype, if there is no extractor exported, oyu can unsafeCoerce it
07:14:07 <ManateeLazyCat> mmorrow: Ok, i try
07:14:09 <mmorrow> it needs all the module filenames on stdin
07:14:44 <Paczesiowa> jav: but why would you touch those pointers? feeling naughty?
07:14:49 <dhun> I did a new try, now it looks approximatly like what I wanted
07:14:52 <dhun> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7227#a7227
07:14:55 <mmorrow> ManateeLazyCat: if you just use "modg" (not the shellscript), it outputs a [(String,[String])] on stdout
07:15:09 <Igloo> Is there an easy way I can get the latest tarball of every package on hackage?
07:15:14 <ManateeLazyCat> mmorrow: I see.
07:15:20 <dhun> I am not so sure about how to get my results back
07:15:36 <dhun> and I do not yet know how to activate do notation for that
07:15:40 <mmorrow> ManateeLazyCat: and "modg -r" takes a [(String,[String])] on stdin, "read"s it, then prints an .dot to stdout
07:15:55 <mmorrow> (i don't remember why i used "-r")
07:16:13 <jav> Paczesiowa: I wish I could avoid it... but gtk2hs is missing a function from gtk that I would like to use. Now I'm trying to create my own FFI for this function but need to feed a Window into it.. I figure I need to access the pointer for this.. at least GHC tells me that 'Window' is an 'Unacceptable argument type in foreign declaration'
07:16:38 <zsol> anyone experimented with the new graphviz package?
07:16:45 <mmorrow> ManateeLazyCat: but anyways, the modg.hs driver prog is super simple, so it should be self-explanatory if you want to modify it
07:17:17 <Berengal> uzytkownik: The solution that springs to mind is to use ParsecT s u IO
07:17:38 <Paczesiowa> jav: makes sense
07:17:53 <uzytkownik> Berengal: How is it suppose to help?
07:18:18 <ManateeLazyCat> mmorrow: That's tred? I haven't this command.
07:18:24 <mmorrow> transitive reduction
07:18:34 <mmorrow> stdin=.dot, stdout=.dot
07:18:35 <jav> Paczesiowa: hopefully.. I'm completely new to this FFI thing... I'll try the unsafeCoerce hack for now, thx
07:18:46 <Berengal> uzytkownik: So you can do something like "setInput =<< liftIO (hGetLine socketHandle)"
07:19:36 <Paczesiowa> jav: it's not a hack (at least not an ugly one) when coercing newtypes or phantom types
07:19:59 <mmorrow> ManateeLazyCat: this directory has some images from 3 different pkgs http://moonpatio.com/repos/MISC/modg/
07:20:30 <mmorrow> ManateeLazyCat: (although for those i filtered some modules out)
07:20:54 <mmorrow> ManateeLazyCat: ohh, do you have $ dot  ?>
07:21:00 <mmorrow> s/>//
07:21:22 <mmorrow> ManateeLazyCat: you'll need GraphViz (which has tred and dot and others)
07:21:27 <ManateeLazyCat> mmorrow: Yep, that's looks cool,
07:21:27 <uzytkownik> Berengal: Well. But it will cause problems: 1. During testing [I'd prefer to keep without any network]  2. What with multi-line input?
07:21:55 <mmorrow> ManateeLazyCat: cool :) let me know if you need any help getting that code to work for you
07:22:29 <Paczesiowa> uzytkownik: ad 2: hGetContents
07:22:30 <Berengal> uzytkownik: During testing, you can hand it a handle to something else, like a file, or stdin. For multi-line input you read multiple lines
07:22:57 <Berengal> The second option is to use hGetContents and a lazy parser
07:23:11 <uzytkownik> Paczesiowa: Wonderful - that's what I'm currently have problems with ;)
07:23:28 <Paczesiowa> uzytkownik: what problems?
07:23:32 <uzytkownik> Berengal: How to use lazy parser?
07:24:20 <Berengal> uzytkownik: pretty much like you would use a strict parser... check out polyparse
07:24:22 <uzytkownik> Paczesiowa: deadlock - parsec tries to evaluate ByteString from network despite there is no more input - but it will arrive after I send a command.
07:24:41 <mmorrow> jav: yeah, most everything (other than primitive types) is through Ptrs
07:25:04 <mmorrow> jav: and most of the time you just make a dummy data decl for some C type
07:25:41 <mmorrow> jav: "data CFoo; instance Storable CFoo where .. peek p = .. castPtr p .... castPtr p ..."
07:25:47 <Berengal> uzytkownik: The difference between lazy and strict parsers is that the lazy parser will start outputting data before it's done
07:25:51 <uzytkownik> Is there any possibility of transmitting lazy value in strict filed?
07:26:10 <mmorrow> foreign import ccall unsafe "new_foo" c_new_foo :: ... -> IO (Ptr CFoo)
07:26:43 <Paczesiowa> uzytkownik: what's the response format? can you detect end of response?
07:27:04 <mmorrow> jav: err, well if you make a storable instance it wouldn't be for "CFoo" there, but some datatype that can hold values
07:27:18 <uzytkownik> Berengal: I understand the difference - I wondered if it is possible with parsec or I have to use something else - hence formulation of question.
07:27:34 <jav> mmorrow: I see... I think the added difficutly for me is, that I need to be working with existing types that I can't change. Because I'm trying to 'extend' gtk2hs for some functions that are not exposed there. But I don't want to change the gtk2hs source
07:27:37 <Berengal> uzytkownik: Ah, right, I don't think parsec does lazy
07:27:51 <uzytkownik> Paczesiowa: Depending on few factors it is either "\r\n" or "\r\n.\r\n"
07:28:36 <mmorrow> jav: ah. for some of those gtk2hs might have a Storable instance for them, so you can e.g. (peek :: Ptr Window -> IO Window)
07:28:43 <Paczesiowa> uzytkownik: Parsec3 is polymorphic in stream of input type, maybe write an instance where readiny next token is hGetChar
07:29:04 <Paczesiowa> jav: maybe take a look at code for some other widget from gtk2hs sources
07:29:48 <mmorrow> jav: but if gtk2hs doesn't export the data constructors for some types you need to build, then you'll probably have to either modify the gtk2hs code itself, or make an identical datadecl in your module, and unsafeCoerce
07:30:03 <uzytkownik> Berengal: No. But I could work around by reimplementing runParserT - but I need to know what Consumed and Empty means.
07:30:27 <Berengal> uzytkownik: I have no idea
07:30:29 <Berengal> Sorry
07:31:45 <mmorrow> jav: you should ask dcoutts about gtk2hs particulars, since i believe he maintains (the code that generates the code for) gtk2hs
07:32:13 <jav> mmorrow: mmh, I see... well I thought I needed to modify gtk2hs, but someone on the gtk2hs mailing list made it sound like it would be easy to slap a foreign import declaration in my code and be fine. I guess it isn't quite that easy
07:32:55 <mmorrow> jav: well, it is that easy if gtk2hs gives you access to the constructors for datatypes you might need to build
07:33:32 <mmorrow> jav: if it hides them, you'll have to modify gtk2hs and either add your code to it, or change it to export the constructors you need
07:33:36 <ManateeLazyCat> jav: I'm interested what's function you need change in gtk2hs, i use gtk2hs always
07:34:30 <ManateeLazyCat> mmorrow: I compile modg successful, and have install graphviz, i move `modg` to my cabal directory, then use command "find . | grep -E "\.hs$" | ./modg -r | tred | dot -Tpng | display", but i got "modg: Prelude.read: no parse" error.
07:34:46 <mmorrow> ManateeLazyCat: ah, so do
07:34:53 <Raevel> okay, now i'm clueless, i try to compile my program, and when i add the import Text.RJson statement i get this error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7228#a7228 , any ideas? :-)
07:34:56 <mmorrow> "find . | grep -E "\.hs$" | ./modg | ./modg -r | tred | dot -Tpng | display
07:35:08 <mmorrow> (it's a hack currently, i know :)
07:35:14 <Berengal> Raevel: Compile with --make
07:35:31 <Raevel> Berengal: i am
07:35:44 <hackagebot> ivor 0.1.9 - Theorem proving library based on dependent type theory (EdwinBrady)
07:35:44 <ManateeLazyCat> mmorrow: I got it, cool
07:35:49 <mmorrow> ManateeLazyCat: great!
07:35:50 <jav> ManateeLazyCat: I need to set _NET_WM_STRUT_PARTIAL on my windows and the functions needed for that are not exposed. This is my post to the mailing list: http://sourceforge.net/mailarchive/forum.php?thread_name=20090717135610.GA7879%40archer.localdomain.org&forum_name=gtk2hs-users
07:36:25 <ManateeLazyCat> mmorrow: It generate a BIG picture for my project, wonderful.... :)
07:36:59 <Raevel> it only seems to happen when i have a main module
07:38:31 <ManateeLazyCat> mmorrow: I want give your my picture generate by modg. Okay?
07:38:48 <mmorrow> ManateeLazyCat: cool, i'd love to see it :)
07:39:03 <Paczesiowa> uzytkownik: why would you reimplement runParserT?
07:39:33 <uzytkownik> Paczesiowa: To get a state without passing it through the ParsecT monad
07:39:55 <Axman6> > '@' > '&'
07:39:57 <lambdabot>   True
07:40:10 <Paczesiowa> what state? input stream?
07:40:31 <mmorrow> ManateeLazyCat: (also, if you give me the [(String,[String])] that the first "./modg" outputs, i can add that to the "test" graphs i have to experiment with different layout ideas)
07:40:34 <desp> Isi it possible to write a nullary type operator, such as :[]:?
07:40:36 <ManateeLazyCat> mmorrow: 362kb
07:40:41 <desp> Is*
07:41:19 <desp> A symbolic parameterless type constructor, in other words.
07:41:22 <mmorrow> ManateeLazyCat: hmm, if you don't have anywhere to upload it to, you can hpaste the [(String,[String])] and i can regenerate the image myself
07:41:35 <ManateeLazyCat> mmorrow: Okay,
07:41:57 <Paczesiowa> desp: make it binary, and feed it two dummy non-symbolic parameters
07:42:12 <Paczesiowa> desp: T:[]:T
07:42:24 <jav> mmorrow: I see, thx for the clarifications ... I managed to build something using a little c wrapper code and unsafeCoerce the 'Window' into a 'ForeignPtr Window' and then calling the wrapper with that (using withForeignPtr) ... it compiles and runs, but I get a GDK-Warning: 'drawable is not a pixmap or window' ... so I guess that means I'm not feeding the correct data in or mangled it too much or something (?)
07:42:25 <mmorrow> (also, you can read that [(String,[String])] in in ghci and filter it/whatever then write out a smaller .dot)
07:42:36 <mmorrow> (if you want to)
07:43:10 <mmorrow> jav: err, what exactly did you unsafeCoerce to (ForeignPtr Window) ?
07:43:11 * ManateeLazyCat pasted "modg -r" at http://paste2.org/get/332021
07:43:13 <ManateeLazyCat> mmorrow: Above
07:43:38 <ManateeLazyCat> mmorrow: I use command "find . | grep -E "\.hs$" | ./modg | ./modg -r"
07:44:13 <ManateeLazyCat> mmorrow: Is it?
07:44:18 <jav> mmorrow: a 'Window' (:info Window gives 'newtype Window = Graphics.UI.Gtk.Types.Window (GHC.ForeignPtr.ForeignPtr Window)')
07:46:01 <mmorrow_> gah my laptop died
07:46:05 * mmorrow_ reads the logs
07:46:09 * ni| waves
07:47:24 <ManateeLazyCat> mmorrow_: I use command "find . | grep -E "\.hs$" | ./modg | ./modg -r" generate date at http://paste2.org/get/332021 , is it?
07:47:28 <djsiegel> Hi, I've installed haskell-platform on Ubuntu 9.04 (GHC 6.10.4) but cabal update and cabal install fail with "cabal: 	: openFile: does not exist (No such file or directory)". I googled the error and didn't find any solutions.
07:48:19 <Paczesiowa> djsiegel: there is no filename in that error?
07:48:34 <djsiegel> Paczesiowa: no, that is the whole error
07:48:56 <ManateeLazyCat> djsiegel: openFile will throw error if file or directory not exist, so we need which file in error.
07:49:12 <tomh> guys, if you want cabal install to execute alex/happy commands etc you do that in Setup.hs ?
07:49:21 <Saizan> djsiegel: can you try with -v3 ?
07:49:22 <mmorrow_> ManateeLazyCat: cool, i'm looking at the image now :)
07:49:29 <ManateeLazyCat> mmorrow_: So big.
07:49:38 <ManateeLazyCat> mmorrow_: And really cool... :)
07:49:48 <mmorrow_> ManateeLazyCat: heh, so you can do
07:49:57 <Saizan> tomh: if you have .x and .y files Cabal will call alex/happy for you
07:49:58 <mmorrow_> find . | grep -E "\.hs$" | ./modg > foo.txt
07:50:06 <djsiegel> Saizan: http://paste2.org/p/332028
07:50:17 <mmorrow_> ghci> xs :: [(String,[String])] <- read `fmap` readFile "foo.txt"
07:50:28 <mmorrow_> then filter out the stuff you don't want in there
07:50:40 <mmorrow_> ghci> writeFile "foo2.txt" (show xs')
07:50:54 <mmorrow_> cat foo2.txt | modg -r
07:51:29 <mmorrow_> (or modify modg.hs to take command-line options to do that automatically)
07:51:30 <Saizan> djsiegel: "cabal --help" works at least?
07:51:34 <ManateeLazyCat> mmorrow_: I think modg should improve that filter all modules that not in current project.
07:51:51 <djsiegel> Saizan: yes, --help works
07:51:53 <tomh> Saizan, what about other pre-processing apps which need to run?
07:52:04 <mmorrow_> ManateeLazyCat: totally. if you look at the code in modg.hs, it actually takes a cli option to do that, but for some reason it doesn't work anymore
07:52:05 <ManateeLazyCat> mmorrow_: Then just generate module that in current projects.
07:52:09 <djsiegel> Saizan: looks like my install is pretty messed up... I will redo GHC
07:52:22 <Paczesiowa> > :t show . read
07:52:24 <lambdabot>   <no location info>: parse error on input `:'
07:52:30 <Paczesiowa> :t show . read
07:52:34 <lambdabot> String -> String
07:52:45 <Berengal> :t read . show
07:52:46 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
07:52:56 <Saizan> tomh: there's a list of the built-in ones at http://haskell.org/ghc/docs/latest/html/libraries/Cabal/src/Distribution-Simple-PreProcess.html#knownSuffixHandlers
07:53:04 <Paczesiowa> Berengal: read . show is ok, show . read isn't
07:53:15 <ManateeLazyCat> mmorrow_: Let's talk image for my project.
07:53:25 <Saizan> tomh: you can add others via the Hooks mechanism in the Setup.hs script
07:54:00 <ManateeLazyCat> mmorrow_: In middle of image, have modules, such as Manatee.TabGroup, Manatee.ViewList, .... them connected so strongly.
07:54:16 <desp> How can I define Sum in terms of Zip?  I can't figure out how to pass (:+:) as the f parameter in Zip.
07:54:19 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7230
07:54:19 <tomh> ok cool
07:54:19 <tomh> I use something which is not part of those built-in ones
07:54:22 <ManateeLazyCat> mmorrow_: So i think problem at here.
07:56:32 <Saizan> desp: i don't think you can
07:56:57 <desp> Saizan: I can do that with fundeps
07:57:28 <desp> I thought they said type families are equivalent in power. :)
07:57:45 <Saizan> ICBW :)
07:57:51 <uzytkownik> Berengal, Paczesiowa: If you'd like to know - AFAIU Consumed is returned after successful paring and Empty indicates failed parser.
07:58:20 <ManateeLazyCat> mmorrow_: modg don't care hs-boot file?
07:58:39 <Saizan> desp: do you get an error with (undefined :: Zip (:+:) Nil Nil) ?
07:59:02 <Paczesiowa> why ghci allows that "show . read"? defaults to Integer or what?
07:59:03 <desp> Yes, Type synonym `:+:' should have 2 arguments, but has been given 0
07:59:08 <mmorrow_> ManateeLazyCat: oh hmm, i don't think i've tried it on boot files
07:59:22 <mmorrow_> ManateeLazyCat: is there anything different about them other than the filename?
07:59:54 <desp> It seems as if GHC doesn't support partial application of type operators, no?
08:00:03 <ManateeLazyCat> mmorrow_: No, A.hs 's boot file is A.hs-boot
08:00:17 <mmorrow_> ManateeLazyCat: so then i guess do
08:00:20 <desp> Actually, of type functions in general.
08:00:30 <ManateeLazyCat> mmorrow_: All is same except extension is `.hs`  and `.hs-boot`
08:00:37 <mmorrow_> find . | grep -E "\.hs(-boot)?$" | ... ?
08:00:42 <Saizan> desp: yeah, that's what i recall too from what i've read about type families
08:01:02 <mmorrow_> ManateeLazyCat: (remember that modg takes filenames on stdin)
08:01:06 <Paczesiowa> desp: no big lambda
08:01:17 <mmorrow_> ManateeLazyCat: ohhh, hmm
08:01:25 <desp> Saizan: is there a reason for that, or is it just unimplemented yet?
08:01:35 <mmorrow_> ManateeLazyCat: so i guess that the module name for A.hs and A.hs-boot are /the same/
08:01:58 <mmorrow_> which could make them look like a single module with both of their imports
08:02:21 <Saizan> desp: i think with partial application you can get the equivalent of unrestricted type lambdas, and so make the whole thing undecidable
08:02:23 <mmorrow_> ManateeLazyCat: just hack modg.hs
08:02:41 <Paczesiowa> desp: google big lambda
08:03:22 <dhun> can I make a do block in wihich each line runs in a seperate thread?
08:03:47 <Saizan> dhun: if you forkIO at each line
08:03:48 <Berengal> dhun: Good question. Is that a monad?
08:04:13 <desp> "Stay tuned, but don't hold your breath." @ 2003
08:04:21 <desp> ;)
08:04:23 <Paczesiowa> isn't that like unix pipes?
08:04:27 <dhun> essentially I was hoping to be able to define a monade that forks
08:04:34 <zachk> dhun: you could just store all the "commands" in a list then mapM_ forkIO saidList
08:04:36 <zachk> i think
08:04:43 <mmorrow_> jav: <jav> mmorrow: a 'Window' (:info Window gives 'newtype Window = Graphics.UI.Gtk.Types.Window (GHC.ForeignPtr.ForeignPtr Window)')
08:05:00 <mmorrow_> jav: hmm, that looks like it'd work at first glance i think
08:05:06 <dhun> you can do something like this
08:05:30 <Berengal> dhun: That monad would essentially consist only of return, bind and liftIO, which would be the same as forkIO-ing every line in regular IO anyway
08:06:03 <Paczesiowa> dhun: that monad whould deeply fork (not only on every line in a do-computation), e.g. in every return and every primitive computation
08:06:23 <dhun> that looks ok to me
08:06:34 <jmcarthur> you have to be able to return values from those threads, and you'd have to be able to block on those values, so you would essentially just have a maximally parallel monad, which probably wouldn't be too efficient or predictable
08:06:38 <Paczesiowa> you want a fork for every return 1 ?
08:07:21 <dhun> I will only use it for I/O bound stuff
08:07:44 <ManateeLazyCat> mmorrow_: I found another problem, modg can't display REVERSE arrow, example, A.hs import B.hs and B.hs import A.hs, then import CYCLE, modg just display A -> B, not B -> A
08:07:45 <jmcarthur> you still have to block
08:07:59 <dhun> yes I have to wait for completion
08:08:05 <zachk> unless you dont care about your output much
08:08:24 <Paczesiowa> dhun: do you really need a monad? wouldn't functor be enough?
08:08:25 <jmcarthur> yeah, it could be beneficial to override the default for >>
08:08:43 <dhun> maybe
08:08:56 <dhun> the interesting point is do notation
08:09:00 <ManateeLazyCat> mmorrow_: BTW, what's MyParser.hs ? It's so large.
08:09:08 <jmcarthur> do notation is, in my opinion, the least interesting thing about monads
08:09:56 <jmcarthur> i was a ruby programmer before i came to haskell and tried to look for opportunities to use do a lot because i was addicted to sugar, but i broke that addiction when i realized it wasn't healthy
08:10:17 <dhun> maybe you are right
08:10:21 <zachk> sugar does tend to rot the teeth
08:11:04 <badsheepy> not true :p
08:11:08 <jmcarthur> sugar makes certain things taste better, though, but it doesn't belong in everything
08:11:10 <mike-burns> So many tutorials introduce monads as "that thing you use with `do' notation", too.
08:11:18 <dhun> so I made something quite sugarless http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7227#a7227
08:12:10 <Badger> If only man could live on sugar alone.
08:12:29 <Badger> Life would be sweet.
08:12:35 <mike-burns> I get it.
08:12:51 <zachk> i think the decepticons tried that with some captured humans one episode in the old transformers. they just fed their hostages candy bars
08:13:00 <zachk> in one
08:13:13 <jav> mmorrow_: yeah.. so I wrote 'getWindowPointer = unsafeCoerce :: Window -> ForeignPtr Window'  ... here are the relevant snippets from my code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7231#a7231
08:13:34 <zachk> what does $= actually do ?
08:14:02 <Petrosian`> @src ($=)
08:14:02 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:14:05 <dhun> fun $ x is the same as (fun x) i think
08:14:12 <Petrosian`> @ty ($=)
08:14:13 <lambdabot> Not in scope: `$='
08:14:18 <ManateeLazyCat> jav: Mix C and Haskell for gtk2hs programming?
08:14:47 <jav> ManateeLazyCat: yes.. because the gtk2hs bindings are not complete for what I want to do
08:15:12 <mike-burns> dhun: f $ x is the same as f (x)
08:16:27 <ManateeLazyCat> jav: I try to avoid use C in my gtk2hs program. :)
08:17:14 <jav> anyway... I'm thinking of giving up on this one and just rewriting the application in C++ instead where I have access to the full GTK library. Sometimes I wonder if the benefits of a bleeding edge language are worth the trouble you get yourself in by venturing so far off the mainstream :-/
08:17:21 <mmorrow_> jav: ohh, so newtype Window = Graphics.UI.Gtk.Types.Window (GHC.ForeignPtr.ForeignPtr Window)
08:17:39 <mmorrow_> jav: it looks like Window is just being used recursively as a placeholder(?)
08:17:56 <mmorrow_> jav: you can always just castPtr a (Ptr a) to a (Ptr b) for any a and b
08:18:03 <ManateeLazyCat> mmorrow_: Your modg will help me more even i can't implement `cycle import` solution in GHC. Graphics make me can find cycle path faster than text (generate by GHC now).
08:18:25 <mmorrow_> ManateeLazyCat: awesome! glad it's useful :)
08:18:46 <jav> mmorrow_: I don't really understand the Window type either, but Paczesiowa was talking about a 'phantom type' (?)
08:18:55 <dhun> Berengal forkIO, seems like a good idea
08:20:01 <ManateeLazyCat> mmorrow_: I think i should hacking your code, then generate "cycle import path" with Graphics rather than text.
08:20:07 <mmorrow_> jav: hmm, i'm not sure what's happening here exactly. are you sure that (ForeignPtr Window) is to a (GdkWindow *window) ?
08:20:20 <Paczesiowa> jav: it is a phantom type, pointers don't know to what they point, so in haskell they are wrapped in datatype that has phantom info what does it point to, you can castPtr all you want
08:20:41 <mmorrow_> ManateeLazyCat: go for it, that would be very cool.
08:20:55 <ManateeLazyCat> mmorrow_: Then my life will be easier even i still use hs-boot file.
08:21:01 <mmorrow_> heh
08:21:08 <Paczesiowa> jav: you can also get the real pointer (the one you can pass to C) out of ForeignPtr
08:21:08 <jav> mmorrow_: I'm not sure no.. I tried reading the gtk2hs source code to verify that, but I'm not really understand much there
08:21:21 <ManateeLazyCat> mmorrow_: I can release your code under GPL?
08:21:34 <ManateeLazyCat> mmorrow_: I want modified something.
08:21:36 <mmorrow_> ManateeLazyCat: yes of course
08:21:41 <Paczesiowa> mmorrow_: gtk2hs code is written by compiler, for compiler
08:21:54 <ManateeLazyCat> mmorrow_: Thanks, great work!
08:22:01 <mmorrow_> ManateeLazyCat: :)
08:22:07 <mmorrow_> Paczesiowa: heh
08:23:00 <Paczesiowa> mmorrow_: that was supposed to be for jav
08:23:23 <pikhq> Paczesiowa: He may be referring to the gtk2hs c2hs code.
08:23:35 <pikhq> Which is, of course, quite a different thring from the resulting Haskell. ;)
08:23:52 <jav> I'm refering to whatever is in their darcs repository
08:24:15 <ManateeLazyCat> jav: I think it's not Haskell problem, just low-level code written by C, so we need write interface that between C and Haskell.
08:24:35 <ManateeLazyCat> jav: If GTK written by Haskell, then that's will be wonderful.
08:25:49 <pikhq> Y'know, the >>= operator is *so* much more intuitive if you think of it like a UNIX pipe.
08:25:50 <jav> ManateeLazyCat: sure, that's not a Haskell problem.. but it's a non-mainstream-language problem. Because setting the _NET_WM_STRUT_PARTIAL property is not such an unusual thing, it's just that apparently no-one has tried that before using gtk2hs.. which is a non-mainstream problem
08:26:00 <pikhq> (only more flexible)
08:26:04 <kynky> i wish gtk2hs had linking exception in license
08:26:41 <pikhq> kynky: ... Isn't it LGPL, like GTK?
08:26:58 <ManateeLazyCat> jav: Indeed
08:28:02 <ManateeLazyCat> jav: I wonder all code that run on machine is Haskell .... just joking...... :)
08:28:15 <kynky> pifish, wxhaskell is lgpl with linking exception, gtk2hs is lgpl without linking exception, big difference for haskell, not so much for c++
08:29:07 <pikhq> kynky: ... What "linking exception" has any meaning for LGPL?
08:29:22 <kynky> lgpl in c/c++ world means if your code uses lib, you dont have to make our code lgpl, with haskell you do, except of you have exception
08:29:39 <kynky> of=if
08:29:58 <pikhq> ... How?
08:30:20 <pikhq> Oh, because the module gets included in the binary. *facepalm*
08:30:24 <tomh> anyone from UU here by any chance?
08:31:22 <kynky> http://www.mail-archive.com/haskell-cafe@haskell.org/msg46529.html
08:31:41 <kynky> The big problem with the LGPL and Haskell is static linking.
08:31:57 <pikhq> And Haskell does static linking, in effect.
08:32:20 <kynky> so hope that explains :)
08:32:26 <Saizan> ghc should soon have proper shared library support
08:32:36 <Saizan> Haskell doesn't have any linking :)
08:32:41 <kynky> hope so too, in 6.12 ?
08:32:57 <pikhq> kynky: Yeah, that explains it.
08:33:11 <pikhq> I just, uh, wasn't thinking "Oh, right. Static linking."
08:33:35 <pikhq> Saizan: It's static linking. If it didn't have *any*, we'd not actually be able to use modules. :P
08:33:43 <ManateeLazyCat> I want release code under GPL, but cabal always notify "Warning: 'license: GPL3' is not a recognised license.", how to delete it?
08:33:49 <dhun> is it dangours to use unsafeInterleaveIO?
08:34:01 <dhun> I did it here and it seems to work http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7233#a7233
08:34:12 <kynky> thats why i think bsd3 license is promoted over lgpl for haskell. also for compatability with existing base libs
08:34:49 <Berengal> dhun: unsafeInterleaveIO is the road of madness. As long as  it works it should be okay, but it ever stops working, don't bother trying to debug
08:35:18 <Saizan> pikhq: the language spec doesn't even get near the issue of static vs. dynamic
08:36:06 <pikhq> Saizan: Fair enough.
08:36:11 <dhun> I am happy with the code because it does exatly what I want
08:36:12 <pikhq> That kinda *is* an implementation detail, so...
08:36:12 <kynky> all in the implemenation ?
08:36:28 <p_l> LLGPL should work with Haskell, though
08:36:49 <dhun> so I will have to learn how to rewrite it without unsafe
08:37:00 <pikhq> dhun: Of course, since you're using unsafeInterleaveIO, what you want may not be the right thing. :P
08:37:33 <kynky> just have linking exception :) like wxhaskell?
08:37:48 <Saizan> ManateeLazyCat: use just GPL
08:38:28 <dhun> no I really think the program looks very cute this way
08:38:59 <ManateeLazyCat> Saizan: Can remove warning by Cabal, nevermind just ask, it's little problem.
08:39:13 <dhun> I can solve the same problem differently of course, but I don't think its that cute anymore
08:42:41 <mmorrow_> dhun: heh, interesting. what does unsafeInterleaveIO do with takeMVar?
08:43:02 <dhun> it does not block there
08:43:14 <dhun> it does not take the mvar
08:43:18 <mmorrow_> does it block if you try to use the value but the MVar is still empty?
08:43:34 <dhun> but when the thing insive the mvar is used it blocks there
08:43:43 <mmorrow_> ah, i see
08:44:05 <mmorrow_> that could be a handy idiom to use
08:44:17 <dhun> I also think it is very cool
08:44:19 <mmorrow_> (unsafeInterleaveIO (takeMVar mvar))
08:44:36 <dhun> but there is the word unsafe in the code
08:44:42 <dhun> so I don't want to use it
08:45:02 <dhun> but there must be a way to do the same thing in a proper way
08:45:03 <McManiaC> how can i catch a SIGTERM signal?
08:45:12 <McManiaC> is the error monad able to do this?
08:45:16 <mmorrow_> dhun: bah, without unsafeInterleaveIO we wouldn't have getContents or readFile
08:45:32 <dhun> readFile uses it
08:45:34 <dhun> ?
08:45:35 <mmorrow_> or countless other things that we take for granted
08:46:05 <mmorrow_> dhun: yeah, or else reading a file wouldn't return until the whole thing was in memory
08:46:16 <Berengal> As long as you're aware of the madness that might ensue, it's not as bad as unsafePerformIO
08:47:05 <dhun> what kind of madness can happen
08:47:28 <Berengal> Things happen completely out of order
08:47:40 <dhun> thats what I wanted
08:48:04 <Berengal> You lose control over which order things happen in
08:48:15 <dhun> am happy to
08:48:34 <mmorrow_> McManiaC: System.Posix.Signals
08:48:42 <Berengal> This isn't good when working with side-effects
08:48:58 <mmorrow_> Berengal: it depends on the side-effects
08:49:29 <mmorrow_> the rts performs the side-effect of overwriting a thunk with its value whenever you evaluate anything
08:49:33 <Berengal> mmorrow_: It depends on alot of things, most of which are too complex for a poor programmers mind
08:49:39 <mmorrow_> that most definitely happens out of order
08:49:57 <Berengal> I wouldn't call that a side-effect in the language.
08:50:09 <mmorrow_> also, elf dynamic linking does essentially the same thing, but with addresses in the GOT
08:50:18 <beutdeuce> Why is tail a polymorphic type?
08:50:46 <Berengal> beutdeuce: Should it have a non-polymorphic type?
08:51:09 <beutdeuce> Berengal: no, i'm just wondering what makes it a polymorphic type
08:51:26 <mike-burns> :t tail
08:51:28 <lambdabot> forall a. [a] -> [a]
08:51:46 <Berengal> beutdeuce: It works with lists, but it never looks at the elements, so the type of the element is never decided
08:52:07 <Berengal> So the type is "lists of whatever type"
08:52:12 <beutdeuce> so any type with 'a' in its signature is polymorphic?
08:52:49 <Berengal> Any type with type variabes
08:53:40 <beutdeuce> right
08:53:50 <McManiaC> mmorrow_: thx
08:53:56 <zachk> ok i have a problem. I have a list of functions that operate in the IO monad, i know i should be using StateT IO but im not sure how that works, so i recurse over this list of functions. I want to check for list=[] but i get a type error saying Eq is not defined basically for my functions. Ive tried list++repeat nullfunction, runs out of memory, waiting for a key right now, but that makes the window have an hourglass, so can I even 
08:53:57 <conal> though i guess monomorphi/polymorphic is more a spectrum than a dichotomy, considering constraints.
08:54:45 <Berengal> conal: Not just constraints, but type constructors as well
08:55:27 <conal> pattern subsumption?
08:55:43 <int-e> > map null [[id], []]
08:55:45 <lambdabot>   [False,True]
08:55:49 <ManateeLazyCat> Bye all, good night! :)
08:56:37 <Berengal> conal: Something like that
08:56:39 <int-e> zachk: null checks whether a list is empty or not. fundamentally, you can use pattern matching for that, case xs of [] -> "list is empty"; _ -> "list is non-empty"
08:56:45 <int-e> @src null
08:56:46 <lambdabot> null []     = True
08:56:46 <lambdabot> null (_:_)  = False
09:06:03 <PeakerWork> @type foldr (const . const $ True) False
09:06:04 <lambdabot> forall b. [b] -> Bool
09:06:31 <PeakerWork> @check \xs -> (foldr (const . const $ False) true) x == null xs
09:06:32 <McManiaC> mmorrow_: stupid question, but how do i use that handler?
09:06:32 <lambdabot>   Not in scope: `true'
09:06:37 <PeakerWork> @check \xs -> (foldr (const . const $ False) True) x == null xs
09:06:38 <lambdabot>   Couldn't match expected type `[b]'
09:06:49 <PeakerWork> @check \xs -> (foldr (const . const $ False) True) xs == null xs
09:06:51 <lambdabot>   "OK, passed 500 tests."
09:07:39 <McManiaC> @src System.Posix.Signals.installHandler
09:07:39 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:07:52 <McManiaC> @src installHandler
09:07:52 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:07:56 <McManiaC> hmm
09:09:09 <beutdeuce> :t (<-)
09:09:10 <lambdabot> parse error on input `<-'
09:09:40 <mike-burns> McManiaC: http://therning.org/magnus/archives/285 might help
09:09:50 <Paczesiowa> jav: you still struggling?
09:10:55 <jav> Paczesiowa: given up on it for now ... maybe I'll give it another try some other time
09:11:25 <tkr> what's a good resource to start learning about haskell?
09:11:34 <Paczesiowa> jav: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7237
09:11:41 <McManiaC> hmkay
09:11:43 <McManiaC> thx mike-burns
09:11:48 <mike-burns> tkr: http://learnyouahaskell.com/ and http://mike-burns.com/project/all%20your%20haskell/
09:11:56 <tkr> mike-burns: thank you. :)
09:11:59 <Paczesiowa> jav: that helps?
09:12:40 <Paczesiowa> jav: it works here (tm), but woudln't be suprised if that unsafeForeignPtrToPtr would bite you later, but someone else will probably help you with that
09:13:30 <jav> Paczesiowa: cool, thx for looking into it... it looks similiar to what I tried, but I will change my code to match yours more closely and see if it helps
09:14:08 <Paczesiowa> jav: what function do you need to wrap?
09:15:36 <jav> Paczesiowa: I'm on Linux and would like to get the Xlib Window ID (XID) of a GTK Window.. GDK_WINDOW_XID(win) (http://library.gnome.org/devel/gdk/stable/gdk-X-Window-System-Interaction.html#GDK-WINDOW-XID--CAPS) promises to do that... but the first problem is, that that is a #define and not a real function
09:17:15 <Paczesiowa> my c is really bad, what does it define GDK_WINDOW_XID to? looks like "GDK_WINDOW_XID=" but no rhs
09:18:14 <jav> it defines it to: (GDK_DRAWABLE_IMPL_X11(((GdkWindowObject *)win)->impl)->xid)
09:18:26 <jav> I couldn't find the definition of GDK_DRAWABLE_IMPL_X11 (?)
09:20:21 <Paczesiowa> structures, damn - plenty of instances for storable and some peeks and pokes. easiest way would be if you could get at least impl from native haskell
09:21:14 <beutdeuce> i want to write a function that counts the length of a filtered list, but for some reason my type signature is not complying. mycount :: (Integral b) => (a -> Bool) -> [a] -> b  ;   mycount p l = length $ filter p l
09:21:50 <Paczesiowa> :t length
09:21:52 <lambdabot> forall a. [a] -> Int
09:22:07 <Paczesiowa> :t \p l -> length $ filter p l
09:22:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
09:22:13 <Paczesiowa> :t \p l -> genericLength $ filter p l
09:22:15 <lambdabot> forall b i. (Num i) => (b -> Bool) -> [b] -> i
09:22:23 <beutdeuce> i see, thanks
09:22:25 <Paczesiowa> use genericLength
09:23:58 <jav> Paczesiowa: oh, I'm just realizing that there is a difference between GtkWindow and GdkWindow and I need to convert those first... that could explain why my other attempt failed
09:25:04 <Paczesiowa> jav: maybe write that function of type Windows* -> Int in C and import that?
09:25:29 <jav> Paczesiowa: exactly, that's what my 'other attempt' was
09:26:11 <jav> Paczesiowa: so I'm adding the code to convert between GtkWindow and GdkWindow to that wrapper now and see if helps
09:26:26 <Paczesiowa> jav: oh, keep going then, makes more sense than all those peeks and pokes whan you don't know what's behind a keyhole
09:30:48 <jav> Paczesiowa: holy smokes, that actually worked! Thx so much for sticking with it Paczesiowa, you as well mmorrow_ .. thx a lot!
09:31:43 <Paczesiowa> jav: it took 30min to install gtk2hs and 1min to write it:>, btw why do you need xid?
09:33:16 <jav> Paczesiowa: because I need to set the _NET_WM_STRUT_PARTIAL property on it... now I can use low-level xlib calls to do that. The alternative would have been to create FFI stuff for gdk_property_change () (also not exposed in gtk2hs at the moment) .. but that seemed even more daunting
09:33:21 <beutdeuce> why cant i import Data.Numbers?
09:34:01 <jav> Paczesiowa: _NET_WM_STRUT_PARTIAL is for dock applications... so the window manager knows how much space to reserve... there is DockTypeHint in gtk2hs, but it's not enough
09:34:43 <Paczesiowa> jav: are you writing taskbar thingie?
09:35:56 <jav> Paczesiowa: sort of, yes... I'm working on a window manager based on XMonad that aims to be 'a tiling window manager with a gentle learning curve' .. I'm writing a supporting dock application for it
09:37:18 <jav> I looked into modifying xmobar instead, but ended up writing something from scratch with gtk2hs
09:37:56 <jav> ... at which point I ran into the STRUT-problem .. and that's pretty much the history of this challenge =)
09:38:33 <kosmikus> any lambdabot admins around?
09:42:38 <Apocalisp> can I get the minBound of a type given a value of that type?
09:43:37 <Paczesiowa> > minBound `asTypeOf` (2::Int)
09:43:38 <b_jonas> ghc 6.10.4? was there even a 6.10.3?
09:43:41 <lambdabot>   -9223372036854775808
09:43:55 <Apocalisp> Paczesiowa: Awesome. Thanks.
09:43:56 <copumpkin> b_jonas: certainly!
09:44:04 <copumpkin> > minBound :: Int
09:44:06 <lambdabot>   -9223372036854775808
09:44:12 <copumpkin> > ord maxBound
09:44:14 <lambdabot>   1114111
09:44:21 <beutdeuce> > minBound Integer
09:44:22 <lambdabot>   Not in scope: data constructor `Integer'
09:44:23 <Paczesiowa> @src asTypeOf
09:44:24 <lambdabot> asTypeOf = const
09:44:26 <MyCatVerbs> b_jonas: hrmn? I think I have 6.10.3 on one of my machines... somewhere. :)
09:44:31 <MyCatVerbs> This one, in fact.
09:44:57 <jav> Paczesiowa: unsafeForeignPtrToPtr is probably best replace with 'withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b' .. I should be fine using that, I guess
09:46:08 <Paczesiowa> jav: yes
09:52:12 <b_jonas> I'll look at the changelogs
09:52:35 <b_jonas> though it's likely not much I care about
09:52:36 <b_jonas> but still
09:52:38 <b_jonas> I like changelogs
09:53:13 <Beelsebob> anyone know a nice function for generating a bell curve?
09:54:53 <copumpkin> e^(-x^2) ? :P
09:55:15 * Beelsebob gets the feeling he's missing a large wadge of knowledge here
09:55:26 <beutdeuce> graphToGraph?
09:55:27 <mauke> repeat '\a'
09:55:37 <beutdeuce> :t graphToGraph
09:55:39 <lambdabot> Not in scope: `graphToGraph'
09:55:47 <copumpkin> > map (exp . negate . (^2)) [-1,-0.8..1]
09:55:49 <lambdabot>   [0.36787944117144233,0.5272924240430485,0.697676326071031,0.852143788966211...
09:55:58 <Beelsebob> cheers copumpkin :)
09:56:08 <copumpkin> np :)
10:01:05 <Beelsebob> copumpkin: I'm perhaps failing at googling here -- what topic should I be looking at to find out about this?
10:01:13 <beutdeuce> if you want to use a lambda expression as the function in a fold, does it need to take two parameters?
10:01:22 <copumpkin> Beelsebob: normal distribution
10:01:27 <Beelsebob> cool, thanks :)
10:01:41 <copumpkin> there are a few parameters you can tune to affect the shape and location of the curve
10:03:14 <Paczesiowa> beutdeuce: yes
10:03:27 <beutdeuce> thanks
10:03:31 <Paczesiowa> beutdeuce: or more
10:03:34 <beutdeuce> ?
10:03:37 <beutdeuce> how more?
10:03:50 <Paczesiowa> beutdeuce: result from fold can also be a function
10:03:52 <beutdeuce> isnt there always the element you're at and the one after it? or is it the one after that as well?
10:04:08 <Saizan> ?type foldr
10:04:10 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:04:31 <Saizan> the second argument is not the element after it
10:04:40 <Saizan> it's the result of the recursive call
10:04:43 <Saizan> ?scr foldr
10:04:44 <lambdabot> Maybe you meant: arr rc src
10:04:48 <Saizan> ?src foldr
10:04:49 <lambdabot> foldr f z []     = z
10:04:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:05:15 <Paczesiowa> > foldl (\f g x -> f $ g x) id (replicate 10 (+1)) 0
10:05:17 <lambdabot>   10
10:05:57 <Paczesiowa> > (foldl (\f g x -> f $ g x) id [(+1),(*2)]) 2
10:05:59 <beutdeuce> see, that just confuses me o.0
10:05:59 <lambdabot>   5
10:06:15 <PeakerWork> @pl (\f g x -> f $ g x)
10:06:15 <lambdabot> (.)
10:06:19 <Paczesiowa> your accumulator and result is a function
10:06:32 <PeakerWork> > foldl (.) id [(+1), (*2)] 2
10:06:33 <lambdabot>   5
10:06:41 <beutdeuce> if i do foldr(\x c -> blah blah) [1..5]...what is the x, and what is the c?
10:07:00 <BONUS> x takes on every value from 1 to 5
10:07:03 <BONUS> c is the accumulator
10:07:05 <deech> Hi all, have any of you read the Caltech's CS 11 Haskell track page( http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html ) ? As a student I would be turned off the language - for instance it says that Haskell is "somewhat slow" and has a "seemingly endless" learning curve. Real World Haskell isn't even mentioned. This doesn't seem like the best way to introduce Haskell. What do you think?
10:07:06 <PeakerWork> beutdeuce: I think a good way to think of foldr as a list pattern-matcher for you
10:07:13 <Saizan> x is the current element, c is the result of applying foldr f z on the rest of the list
10:07:23 <PeakerWork> beutdeuce: it is really common to write:      case xs of [] -> nil ; (x:xs) -> handle x xs
10:07:34 <Paczesiowa> beutdeuce: write your lambdas for folds like this: \el acc ->
10:07:47 <Paczesiowa> * for foldrs
10:07:48 <PeakerWork> or even:      f xs = case xs of [] -> nil ; (x:xs) -> handle x (f xs)
10:07:55 <beutdeuce> what if i have (\a b c -> blah blah) [blah], what is the c, if a is the current element and c is the accumulator?
10:08:04 <PeakerWork> beutdeuce: the above pattern is so common for lists, so  foldr  captures it:   instead of that you can use:  f = foldr nil handle
10:08:23 <Paczesiowa> beutdeuce: then c is the argument to the function that acc is
10:08:26 <beutdeuce> b* is the accumulator
10:08:32 <PeakerWork> beutdeuce: don't think of foldr as having an accumulator
10:08:40 <PeakerWork> beutdeuce: foldr is a "search & replace" on lists
10:08:53 <PeakerWork> beutdeuce: you search&replace each (:) in the list with some other func, and each [] with something else
10:09:03 <PeakerWork> beutdeuce: foldr (+) 0       makes 1 : 2 : 3 : []        into 1 + 2 + 3 + 90
10:09:09 <PeakerWork> 1 + 2 + 3 + 0   even
10:09:22 <Paczesiowa> beutdeuce: anyway, don't worry about them, you can use 2arg functions for folds and be perfectly happy haskeller:)
10:09:24 <beutdeuce> hmm, so sum [1..5] is the same as foldr (+) 0 [1..5] ?
10:09:33 <Paczesiowa> @src sum
10:09:35 <lambdabot> sum = foldl (+) 0
10:09:38 <beutdeuce> lol
10:09:42 <beutdeuce> nice
10:10:36 <PeakerWork> beutdeuce: when the result of your fold is a single "atomic" value and not a data constructor that contains more data constructors in it -- its better to compute it strictly than lazily, with a foldl' rather than foldr, but you can understand all of that after understanding foldr better..
10:11:00 <beutdeuce> so, as describe in yaht, mycount p l = foldr (\x c -> if p x then c+1 else c) 0 l, returns the length once the list has been filtered, by checking if each element 'x' returns True with p, then it increases the accumulator, ah, i see
10:11:11 <Paczesiowa> there is nice explanation on fold[lr]s['] on haskell wiki
10:11:35 <PeakerWork> there's also http://foldr.com
10:11:36 <beutdeuce> PeakerWork: when will a fold return a non-atomic value?
10:11:37 <PeakerWork> and foldl.com
10:11:57 <PeakerWork> beutdeuce: xs ++ ys = foldr (:) ys xs
10:12:10 <PeakerWork> beutdeuce: you replace each (:) with (:) in xs, and the [] of xs, you replace with ys
10:12:23 <Paczesiowa> beutdeuce: when the folding function returns smth non-atomic (write custom data-type or a function)
10:12:24 <PeakerWork> beutdeuce: the result is again a list, so is built from smaller things
10:13:04 <beutdeuce> so, it is common to use maps in folds?
10:13:21 <PeakerWork> beutdeuce: what do you mean? the function map?
10:13:22 <beutdeuce> or at least, when returning value is non-atomic
10:13:36 <beutdeuce> yes
10:13:42 <beutdeuce> give fold returns a list
10:14:47 <Paczesiowa> it is very common for foldr to return lists again (foldr-build fusion is all about it)
10:14:59 <beutdeuce> k
10:15:03 <beutdeuce> thanks
10:15:09 <PeakerWork> beutdeuce: btw: if foldr ignores its right-hand argument, the recursion never takes place
10:15:16 <PeakerWork> @src null
10:15:17 <lambdabot> null []     = True
10:15:17 <lambdabot> null (_:_)  = False
10:15:30 <PeakerWork> ^^ can be replace with:  null = foldr (\_ _ -> False) True
10:15:40 <beutdeuce> oh, thats why u need the accumulator, even if you're not going to use it
10:15:52 <PeakerWork> foldr can be seen as a pattern-match on []/(:) plus recursive call
10:16:10 <PeakerWork> beutdeuce: I don't think of foldr as having an "accumulator" at all
10:16:41 <beutdeuce> PeakerWork: how do u think of the second argument?
10:17:08 <PeakerWork> beutdeuce: I see this:   foldr returnThisWhenCons returnThisWhenNil [] = returnThisWhenNil ; foldr returnThisWhenCons returnThisWhenNil (x:xs) = returnThisWhenCons x (foldr ...same args here...)
10:17:27 <PeakerWork> beutdeuce: I think of it as a "What to return when hitting nil", or "what to replace nil with"
10:17:41 <Paczesiowa> *cons with"
10:18:02 <PeakerWork> beutdeuce: so you just tell foldr what to do for each of the possible patterns
10:18:10 <mmorrow_> jav: nice!
10:18:21 <Paczesiowa> http://en.wikipedia.org/wiki/File:Right-fold-transformation.png
10:18:58 <PeakerWork> yeah, that's a search&replace of (:) and [] with f and z
10:19:57 <beutdeuce> why does foldr (\x c -> c+x) 0 [1..5] return sum [1..5]? i'm still not 100% about the c
10:20:29 <burp> @pl (\x c -> c+x)
10:20:30 <lambdabot> (+)
10:20:34 <burp> that's the reason ;)
10:20:42 <burp> and
10:20:43 <burp> @src sum
10:20:44 <lambdabot> sum = foldl (+) 0
10:21:04 <beutdeuce> but isnt c 0?
10:21:20 <EvilTerran> that's a different variable with the same name
10:21:23 <Paczesiowa> beutdeuce: c is different at each point
10:21:48 <EvilTerran> one bound by "foldr f c = ...", and the other by "\x c -> ..."
10:22:13 <Paczesiowa> does lambdabot support that trick wich symbolic computation (I think from Lennart Augustsson)?
10:22:42 <mauke> beutdeuce: which c?
10:23:00 <PeakerWork> beutdeuce: \x c -> c+x   ==  (+)     you see why?
10:26:47 <davidL> > foldr (\x c -> c+x) 0 [1..5] :: Expr
10:26:49 <lambdabot>   0 + 5 + 4 + 3 + 2 + 1
10:27:24 <badsheepy> whoa i never knew you could do that
10:30:02 <beutdeuce> cool
10:30:46 <beutdeuce> > foldl (\x c -> c+x) 0 [5..1] :: Expr
10:30:48 <lambdabot>   0
10:30:57 <beutdeuce> ?
10:31:09 <beutdeuce> i thought that would be the same
10:31:10 <mauke> > [5..1]
10:31:12 <lambdabot>   []
10:31:15 <beutdeuce> oh right
10:31:22 <beutdeuce> > foldl (\x c -> c+x) 0 [5,4..1] :: Expr
10:31:24 <lambdabot>   1 + (2 + (3 + (4 + (5 + 0))))
10:31:43 <badsheepy> wheres :: Expr from?
10:31:52 <badsheepy> or, more to the point, how do i make ghci do that :d
10:32:00 <beutdeuce> > foldl (\x c -> c+x) 0 [1..5] :: Expr
10:32:01 <Cale> simple-reflect
10:32:01 <lambdabot>   5 + (4 + (3 + (2 + (1 + 0))))
10:32:06 <badsheepy> ty :)
10:32:20 <Cale> http://hackage.haskell.org/package/simple-reflect
10:34:03 <pikhq> beutdeuce: You know that (\x c -> c + x) = (+), right?
10:34:13 <pikhq> Erm. Actually, no. = flip (+)
10:34:22 <beutdeuce> pikhq: i'm trying to reason that out
10:34:37 <beutdeuce> in the context of a fold
10:34:56 <pikhq> > foldl (flip (+)) 0 [5,4..1] :: Expr
10:34:57 <lambdabot>   1 + (2 + (3 + (4 + (5 + 0))))
10:35:10 <pikhq> Hmm.
10:35:13 <pikhq> > foldl ((+)) 0 [5,4..1] :: Expr
10:35:15 <lambdabot>   0 + 5 + 4 + 3 + 2 + 1
10:35:35 <pikhq> Double-hmm.
10:35:36 <EvilTerran> > (+) x y
10:35:38 <lambdabot>   x + y
10:35:52 <EvilTerran> > (\x c -> c + x) y z
10:35:54 <lambdabot>   z + y
10:36:08 <pikhq> > flip (+) $ y z
10:36:11 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> a'
10:36:21 <EvilTerran> > flip (+) y z
10:36:23 <lambdabot>   z + y
10:36:44 <burp> > reduction $ sum [1..3]
10:36:46 <lambdabot>   Not in scope: `reduction'
10:36:53 <burp> that reduction from simple-reflect is cool
10:36:55 <lilac> > foldr f x [1..5] :: [Expr]
10:36:57 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
10:37:00 <lilac> > foldr f x [1..5] :: Expr
10:37:02 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 x))))
10:37:14 <desp> I know how to lift numbers from the type system to values.
10:37:14 <Saizan> anyone has a dictionary indexed by Dynamic (or similar) keys around?
10:37:22 <desp> Does anyone know how to do the reverse?
10:37:45 <EvilTerran> desp, you'd need template haskell for that
10:37:47 <mauke> desp: you want to turn a number into a type?
10:37:54 <desp> mauke: yes.
10:38:00 <mauke> at runtime or at compile time?
10:38:07 <desp> At compile time.
10:38:22 <mauke> then template haskell sounds right
10:38:26 <desp> :/
10:38:35 <Saizan> at runtime you can with higher-rank polymorphism
10:39:59 <mauke> or existentials
10:41:16 <beutdeuce> > foldr1 f [1..5] :: Expr
10:41:17 <lambdabot>   f 1 (f 2 (f 3 (f 4 5)))
10:42:12 <mauke> > foldr f z [1..5]
10:42:14 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
10:42:23 <lilac> Saizan_: Dynamic sounds like it's not possible. but you could probably get something working with keys :: (forall a. Typeable a, Ord a) => a
10:43:06 <lilac> in fact, an existential with an Ord instance based on TypeRep and value would probably work in a Data.Map
10:43:34 <desp> I'd like to write a raise-to-integral-power function that, applied to a value with type u, returns the value raised to the k-th power, with type u^k.
10:43:51 <Saizan_> lilac: you just need to settle for some Ord instance for TypeRep's
10:44:46 <beutdeuce> > foldr (\elem acc -> if isPrime elem then acc+1 else acc) 0 [1..10] :: Expr
10:44:48 <lambdabot>   Not in scope: `isPrime'
10:44:51 <Paczesiowa> desp: writing that function on two levels should be enough
10:44:59 <beutdeuce> foldr (\elem acc -> if even elem then acc+1 else acc) 0 [1..10]
10:45:07 <beutdeuce> > foldr (\elem acc -> if isPrime elem then acc+1 else acc) 0 [1..10]
10:45:09 <lambdabot>   Not in scope: `isPrime'
10:45:11 <beutdeuce> argh
10:45:12 <Paczesiowa> desp: type level is primary and value level follows the shape
10:45:17 <beutdeuce> > foldr (\elem acc -> if even elem then acc+1 else acc) 0 [1..10]
10:45:19 <lambdabot>   5
10:45:26 <beutdeuce> foldr (\elem acc -> if even elem then acc+1 else acc) 0 [1..10] :: Expr
10:45:34 <beutdeuce> wow
10:45:42 <beutdeuce> > foldr (\elem acc -> if even elem then acc+1 else acc) 0 [1..10] :: Expr
10:45:44 <lambdabot>   0 + 1 + 1 + 1 + 1 + 1
10:46:07 <lilac> Saizan_: gah, i thought TypeRep had Ord. apparently not :(
10:46:08 <pikhq> You expected anything else? ;)
10:46:35 <lilac> Saizan_: if you're ok with unsafePerformIO, there's typeRepKey
10:47:02 <desp> Paczesiowa: would you care to offer a hint?
10:47:06 <beutdeuce> > foldr (\x fx -> x+fx) 0 [1..5]
10:47:08 <lambdabot>   15
10:47:11 <lilac> but then you'd need to be careful with letting pure code see the order of the map
10:47:14 <beutdeuce> > foldr (\x fx -> x+fx) 0 [1..5] :: Expr
10:47:16 <lambdabot>   1 + (2 + (3 + (4 + (5 + 0))))
10:47:28 <desp> Paczesiowa: I have type-level exponentiation working.
10:47:46 <desp> Paczesiowa: but it takes a type-level integer.
10:48:02 <Saizan_> lilac: and on top of all i need to [de]serialize the Map, and that's where things get nasty
10:49:03 <Paczesiowa> desp: make another type-level exponentation - class Exp u k r where exp :: u -> k -> r
10:49:32 <beutdeuce> when would one use foldl as opposed to foldr? Why?
10:49:34 <Paczesiowa> desp: and use the previous exponentation, and toValue on second argument
10:49:58 <Paczesiowa> beutdeuce: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
10:51:58 <Fairweather> what module is Expr defined in?
10:52:18 <Fairweather> no, scratch that
10:52:31 <Fairweather> *how do I find out* what module Expr is defined in
10:52:42 <Berengal> @hoogle Expr
10:52:43 <lambdabot> module Text.Parsec.Expr
10:52:44 <lambdabot> module Text.ParserCombinators.Parsec.Expr
10:52:44 <lambdabot> Distribution.Simple.Program alexProgram :: Program
10:53:06 <Berengal> Doubt that's the Expr you want, but in general, hoogle
10:53:57 <Fairweather> thanks
10:55:11 <Paczesiowa> desp: all your classes have no methods?
10:55:32 <beutdeuce> > foldr (\x y -> (x+y)/2) 54 [12,4,10,6] :: Expr
10:55:34 <lambdabot>   (12 + (4 + (10 + (6 + 54) / 2) / 2) / 2) / 2
10:55:37 <Fairweather> so if it none of these is the Expr I want, which one is it
10:55:55 <pikhq> SimpleReflect.Expr
10:56:20 <mmorrow_> mauke: ping
10:56:58 <mmorrow_> McManiaC: ah i just saw your question... handler?
10:57:28 <mmorrow_> McManiaC: oh
10:57:58 <beutdeuce> @src maximum
10:57:58 <lambdabot> maximum [] = undefined
10:57:58 <lambdabot> maximum xs = foldl1 max xs
10:59:09 <beutdeuce> i think i get folding now, thanks to all who helped
11:00:29 <beutdeuce> nso, a scanr is like a foldr, but it returns the results of each step, not just the end function?
11:00:32 <beutdeuce> so*
11:00:36 <Berengal> beutdeuce: Can you write foldl as a foldr ? ;)
11:00:39 <mmorrow_> McManiaC: e.g.: installHandler sigUSR1 (Catch (print "zomg SIGINT")) Nothing
11:00:46 <Paczesiowa> Berengal: that's crueal:>
11:00:59 <beutdeuce> o.0
11:01:27 <mmorrow_> McManiaC: this paste uses Posix.Signals a bunch too http://hpaste.org/fastcgi/hpaste.fcgi/view?id=445
11:01:27 <Paczesiowa> *cruel
11:01:58 <Berengal> beutdeuce: Yes, the scan* functions return a list of intermediate results
11:02:06 <beutdeuce> Berengal: what is its use?
11:02:40 <Berengal> > scanl1 (+) [1..]
11:02:43 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
11:02:47 <Berengal> Triangle numbers
11:02:51 <Berengal> for example...
11:03:46 <Berengal> I don't use them often, to be honest. Mostly when I need to look at the intermediate results for some reason
11:03:46 <beutdeuce> right
11:05:38 <beutdeuce> so, scanr and scanl will return the end result, but each intermediate result will be differenve
11:06:55 <beutdeuce> scanl (+) 0 [1..5]  ==  reverse $ scanr (+) 0 [5,4..1]
11:07:08 <beutdeuce> > scanl (+) 0 [1..5]
11:07:10 <lambdabot>   [0,1,3,6,10,15]
11:07:16 <beutdeuce> > reverse $ scanr (+) 0 [5,4..1]
11:07:18 <lambdabot>   [0,1,3,6,10,15]
11:07:43 <mmorrow_> @src inits
11:07:44 <lambdabot> inits []     =  [[]]
11:07:44 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
11:07:57 <mmorrow_> @let inits' = scanl ((reverse .) . flip (:)) []
11:07:58 <lambdabot>  Defined.
11:08:16 <mmorrow_> @check \xs -> inits xs == inits' xs
11:08:18 <lambdabot>   Not in scope: `inits''
11:08:27 <mmorrow_> > (\xs -> inits xs == inits' xs) [0..9]
11:08:31 <lambdabot>   False
11:08:33 <mmorrow_> aw
11:08:37 <zsol> @src inits'
11:08:38 <lambdabot> Source not found. I feel much better now.
11:08:41 <mmorrow_> > inits [0..9]
11:08:43 <lambdabot>   [[],[0],[0,1],[0,1,2],[0,1,2,3],[0,1,2,3,4],[0,1,2,3,4,5],[0,1,2,3,4,5,6],[...
11:08:46 <mmorrow_> > inits' [0..9]
11:08:48 <lambdabot>   [[],[0],[0,1],[1,0,2],[2,0,1,3],[3,1,0,2,4],[4,2,0,1,3,5],[5,3,1,0,2,4,6],[...
11:08:53 <mmorrow_> oh bah
11:09:15 <mmorrow_> @let inits'' = fmap reverse . scanl (flip (:)) []
11:09:17 <lambdabot>  Defined.
11:09:22 <mmorrow_> > (\xs -> inits xs == inits'' xs) [0..9]
11:09:24 <lambdabot>   True
11:09:37 <zsol> yay
11:09:38 <beutdeuce> almost like a reverse tails
11:09:48 <mmorrow_> @src tails
11:09:49 <lambdabot> tails []         = [[]]
11:09:49 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
11:10:00 <mauke> mmorrow_: pong
11:10:56 <mmorrow_> mauke: ah, you may find this amusing (i just figured out how to get it to work on x86): a way to do tailcalls with gcc http://moonpatio.com/repos/jump-c/
11:11:16 <mmorrow_> mauke: (for x86 it relies on gcc's __attribute__ ((regparms(n))))
11:11:22 <mmorrow_> *regparm
11:12:21 <mmorrow_> mauke: you can tailcall an arbitrary number of functions, then return to the original caller from the very last one without growing the stack at all
11:12:31 * mmorrow_ cackles
11:12:41 <beutdeuce> :t nub
11:12:43 <lambdabot> forall a. (Eq a) => [a] -> [a]
11:12:47 <mauke> I can do that too
11:12:52 <mmorrow> mauke: :o
11:12:54 <mauke> return f2();
11:13:13 <mmorrow> ?
11:13:18 <mmorrow> ohh.
11:13:19 <mauke> tail call to f2
11:13:25 <mmorrow> mauke: really??!
11:13:39 <mmorrow> cool
11:13:41 <the_edge> Can I use a where clause after a monad bloc of code? Here is an example that does not compile: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3052#a3052
11:13:41 <Beelsebob> copumpkin: I might be being really dumb here... but I expected (sqrt . negate . log) to generate a natural distribution from a linear distribution, but it generates a gap near 0, why? http://www.cs.kent.ac.uk/people/rpg/tatd2/galaxy.png
11:13:44 * mmorrow tries that
11:13:50 <hackagebot> hoogle 4.0.6 - Haskell API Search (NeilMitchell)
11:13:54 <copumpkin> > log 0
11:13:56 <lambdabot>   -Infinity
11:14:02 <copumpkin> Beelsebob: that's why :)
11:14:17 <copumpkin> why log?
11:14:25 <Beelsebob> enverse of e^x
11:14:28 <Beelsebob> inverse too
11:14:33 <Beelsebob> am I being a moron here?
11:14:59 <mmorrow> mauke: i'm not positive that that gets you everything that that jump.S does, but if it truly does i'll be very happy
11:15:58 <mauke> I don't know what jump.S does, but I've seen gcc turn non-tail-calls into jmps
11:15:59 <mmorrow> mauke: (like, in the asm it actually cleans the stack and jmp's to the function with "return f2()"?)
11:16:39 <beutdeuce> i see a lot of zipping going around sometimes, so i began to wonder, what is this zip,unzip function, and why is used so many times in solving various computations. So I went and looked up what zip is all about, and I still dont see how is it useful, if tuples are rarely (at least significantly less) used in contrast to lists. Anyone care to shed some light?
11:16:46 <mmorrow> one of the crucial things about that jump-c code is that the C stack gets cleaned and the code never has to pass back through the function that it jumps from
11:16:52 <mmorrow> even when you're returning a value
11:17:09 <mmorrow> hmm
11:18:10 <Berengal> I thought gcc did tailcalls if compiling with O3 automatically
11:18:32 <copumpkin> Beelsebob: why are you taking its inverse?
11:18:39 <SamB> beutdeuce: tuples are used all the time
11:18:47 <mauke> Berengal: -O2 actually
11:18:48 <SamB> they just make a lousy sequence type here ;-)
11:19:56 <Beelsebob> copumpkin: because I want to take a set of points that have a linear distribution, and move to a set of points in a normal distribution -- so that the galaxy is dense in the centre
11:21:04 <mmorrow> mauke: you're right
11:21:33 <Beelsebob> copumpkin: the distribution I'm trying to get is distance from the centre of the galaxy, the offset from the centre of the spiral is not an inverse
11:21:35 <mmorrow> mauke: i wish i'd thought of that before i spent an hour on that jump.S ... :)
11:22:21 <mauke> :-)
11:22:46 <mmorrow> mauke: adding the return i guess is the key (even for functions returning void)
11:23:13 <mauke> functions returning void may require foo(); return;
11:23:38 <mmorrow> hmm, now i can't remember why i thought that i had to do this at all
11:23:42 <beutdeuce> @let listt = [[1..5],[1..10],[1..100]]
11:23:44 <lambdabot>  Defined.
11:24:07 <beutdeuce> maximumBy length listt
11:24:17 <beutdeuce> > maximumBy length listt
11:24:18 <lambdabot>   Couldn't match expected type `[a] -> GHC.Ordering.Ordering'
11:24:54 <beutdeuce> :t maximumBy
11:24:54 <mae_> anyone with a 32-bit freebsd box want to help me with some testing for sendfile?!?! :)
11:24:56 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
11:25:27 <mauke> > maximumBy (comparing length) listt
11:25:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:25:47 <beutdeuce> o, k
11:27:34 <kosmikus> any lambdabot admins around?
11:27:53 <Baughn> Cale: Heh. I wouldn't /really/ use the try.unsafePerformIO.evaluate trick, except if I really want to. ^_^
11:28:35 <mauke> kosmikus: why?
11:28:41 <stepcut> when I run haddock on some of my libraries, it forks off instances of cc1 that take minutes to compile and consume gigabytes of RAM :(
11:29:15 <Cale> Baughn: I know, I was really just referring to all the insanity that you'd been hacking on lately :)
11:29:25 <stepcut> I don't think running haddock should take several orders of magnitude longer to run than it takes ghc to compile the same files
11:29:58 <kosmikus> mauke: I'd like to request lambdabot to join a channel
11:30:08 <Baughn> Cale: Don't worry, I've taken to doing some of it as primops
11:30:54 <Cale> ah, so ghc might have an unamb primop soon?
11:31:47 <Baughn> Cale: Not.. quite
11:32:00 <Baughn> Cale: I'm looking at an IVar primop
11:32:20 <Baughn> Cale: (Because implementing them with MVars has too much overhead)
11:32:33 <olsner> I'm starting to like applicative, turns out my parsing wasn't really monadic at all
11:32:57 <Baughn> If you can define a sane join, and it's applicative, then it's monadic
11:33:36 <kosmikus> mauke: do you have permissions to do that?
11:33:37 <olsner> sure, it's parsec so there is a monad beneath it but the point is I'm not using it
11:33:41 <kosmikus> Cale: or do you?
11:34:02 <Cale> kosmikus: I have permissions
11:34:11 <mauke> kosmikus: I used to, but I seem to be doing something wrong
11:34:14 <burp> I'd also have a channel which needs lambdabot ;)
11:34:40 <beutdeuce> > listt
11:34:42 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16...
11:35:17 <beutdeuce> how would i calculate the total length of listt (length when sublists are flattened into one list) using foldr?
11:35:37 <Baughn> length.concat?
11:35:50 <beutdeuce> using foldr
11:36:33 <Cale> foldr (\xs xss -> length xs + xss) 0
11:36:46 <mauke> :t foldr (\x z -> foldr (const succ) 0 x + z) 0
11:36:48 <lambdabot> forall b a. (Enum b, Num b) => [[a]] -> b
11:36:58 <mauke> > foldr (\x z -> foldr (const succ) 0 x + z) 0 listt
11:36:59 <lambdabot>   Couldn't match expected type `[a]'
11:37:32 <beutdeuce> Cale: shouldnt it be foldr (\xs xss -> length xs + length xss) 0 ?
11:37:46 <mauke> beutdeuce: no, because length 0 is invalid
11:37:59 <mike-burns> :t foldr
11:38:00 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:38:25 <Cale> beutdeuce: foldr takes two parameters: a replacementf for (:) and a replacement for [], and it produces a function which makes those replacements throughout a list
11:38:38 <beutdeuce> > foldr1 (\x xs -> length x + length xs) listt
11:38:40 <lambdabot>   Couldn't match expected type `[a]'
11:39:08 <beutdeuce> should of worked with foldr1 though, no?
11:39:18 <mike-burns> :t foldr1
11:39:20 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
11:39:32 <Cale> So my replacement for (:), rather than adding the list to the list of lists, adds the length of that list to the total, and my replacement for [] is 0
11:39:52 <Cale> foldr1 doesn't work on the empty list
11:39:56 <hackagebot> hoogle 4.0.7 - Haskell API Search (NeilMitchell)
11:39:58 <Cale> Don't use it unless you really have to.
11:40:21 <beutdeuce> got it
11:40:33 <Cale> foldr1 doesn't work here at all though
11:40:38 <beutdeuce> > foldr ( \x xs -> length x + xs) 0 listt
11:40:40 <lambdabot>   115
11:40:48 <Cale> because the type of the result is different from the element type of the list
11:40:55 <soupdragon> > listt
11:40:57 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16...
11:41:04 <beutdeuce> right, [a] instead of Int
11:41:36 <beutdeuce> > scanr (\x xs -> length x + xs) 0 listt
11:41:38 <lambdabot>   [115,110,100,0]
11:41:52 <mmorrow> mauke: __attribute__ ((constructor)) are really handay too
11:42:59 <SamB> mmorrow: is that the one that makes the code run on load?
11:43:08 <mmorrow> SamB: yeah, before main
11:43:19 <SamB> depends when the code gets loaded ;-P
11:43:24 <mmorrow> well, yeah
11:43:53 <mmorrow> SamB: yeah, i guess it's when that lib is loaded in the .so case
11:44:50 <mmorrow> SamB: http://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Function-Attributes.html#Function-Attributes
11:45:48 <SamB> mmorrow: I know how to find the page, I didn't feel like doing it just now ;-)
11:46:10 <mmorrow> SamB: well now you just have to "open link in browser" ;)
11:46:14 * SamB would probbly be reading "(gcc)Function Attributes", though ;-)
11:46:22 <SamB> mmorrow: I don't really feel like reading it either
11:46:44 <mmorrow> SamB: gcc just decided it hates you, sry
11:46:56 <Cale> beutdeuce: Have you seen my fold diagrams?
11:47:03 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
11:47:05 <beutdeuce> Cale: on wikipedia?
11:47:17 <beutdeuce> oh, no. i shall now
11:47:23 <Cale> beutdeuce: Well, yeah, a couple are on wikipedia too ;)
11:47:30 <mmorrow> SamB: what is "(gcc)Function Attributes" ?
11:47:32 <beutdeuce> only 2 though
11:47:32 <SamB> I don't expect the GCC manual gives too many details, anyway, as it's probably more of a linker/loader detail what actually happens...
11:47:37 <Cale> I happen to have written most of that article
11:47:40 <SamB> mmorrow: the info node
11:47:43 <beutdeuce> Cale:  :)
11:47:55 <SamB> I'm guessing at the name based on that URL
11:48:08 <mmorrow> SamB: ah, 2leet4me :)
11:48:20 <SamB> hey, I got started on GNU with DJGPP
11:48:41 <SamB> that was the main way to read docs there ;-)
11:49:34 <mmorrow> i just realized how much i take man pages for granted
11:49:59 <SamB> well, in gcc's case the manpage isn't that detailed
11:50:04 <SamB> just like with ghc, really
11:50:09 <mmorrow> that'd be sweet if haddock generated manpages too
11:50:24 <SamB> unlike most GNU tools, they have a *valid* reason not to document everything in the manpage
11:50:30 <SamB> mmorrow: that would not help!
11:50:45 <SamB> mmorrow: heck, writing a .pod file would make more sense!
11:51:20 <SamB> unless you meant 3hs manpages of some kind?
11:51:33 <stepcut> I have a haskell library that automatically generates manpages from GetOpts, http://src.seereason.com/haskell-help/
11:51:41 * SamB was thinking section 1 at first
11:51:52 <mmorrow> SamB: ghc has a manpage?
11:51:56 <stepcut> so when you add/remove command-line options in your code, the manpage is automatically updated
11:51:57 <gwern> how would haddock generate man pages? it covers just the api, and I don't see much man-like stuff in the haddocks in executables
11:52:04 <mmorrow> SamB: the gcc one is detailed enough to be handy for
11:52:05 <SamB> mmorrow: oh, well, maybe that's a Debian thing
11:52:06 <mmorrow> $ man gcc | grep "fmorefaster"
11:52:08 <mmorrow> stuff
11:52:09 <beutdeuce> Cale: the diagrams are for z | z <- [1..5] ?
11:52:12 <stepcut> needs to be updated to use pandoc though
11:52:17 <SamB> mmorrow: yeah, the gcc one is not unhandy
11:52:22 <gwern> stepcut: that sounds liek a nice, if an incomplete man page generator
11:52:23 <Cale> [1..5], yeah
11:52:24 <mae_> stepcut: hola
11:52:27 <SamB> it's just not the manual, with an excuse for once!
11:52:27 <beutdeuce> k
11:52:33 <mmorrow> stepcut: ooh cool, i'll check that out
11:52:42 <SamB> usually they're like "dur, we don't like man! read the info file!"
11:52:45 <Cale> [1..5] = 1 : (2 : (3 : (4 : (5 : []))))
11:52:59 <gwern> SamB: what info file, is always my reaction
11:53:01 <SamB> (where they == GNU)
11:53:03 <beutdeuce> k, and starts at the bottom, in the diagrams
11:53:07 <stepcut> gwern: it's actually pretty complete, here is an example, http://src.seereason.com/haskell-help/examples/Help.lhs
11:53:10 <Cale> at the bottom?
11:53:18 <pikhq> SamB: At least their info files are actually comprehensive.
11:53:20 <Cale> It starts at the top :)
11:53:23 <SamB> gwern: for which reason?
11:53:33 <gwern> I hate that boilerplate - 'see the info file for more detail', 'info foo' == nothing
11:53:37 <SamB> (a) they don't say or (b) it got left out for DFSG violations
11:53:41 <beutdeuce> whats the difference between the left and right? yes, at the top, i meant to say bottom gets evaluated first
11:53:43 <stepcut> gwern: supports groff, additional manpage sections, etc. though the groff DSL is a bit buggy
11:53:55 <Cale> beutdeuce: Nope, the bottom is evaluated last, generally.
11:53:56 <SamB> gwern: you know, it seemed like that used to work more often :-(
11:54:00 <pikhq> gwern: You must use Debian, which doesn't install the info pages.
11:54:09 <SamB> pikhq: that's not quite true
11:54:11 <Cale> beutdeuce: Things are backwards from what you'd expect though, since the language is lazy :)
11:54:18 <stepcut> mae_: hola
11:54:20 <SamB> pikhq: though it's a simpler thing to assume than that they do
11:54:26 <SamB> or, well, safer
11:54:30 <beutdeuce> Cale: i see, so what did u mean by, "Lines go from the bottom of a symbol to the top of its parameters"
11:54:40 <mae_> stepcut: you wouldn't by chance, have access to a freebsd box? :) Oh and, I MISS MATH QUIZ!
11:54:54 <Cale> beutdeuce: When you apply foldr f z to [1,2,3,4,5], the first thing it does is give you f 1 (foldr f z [2,3,4,5])
11:55:02 <Cale> beutdeuce: at this point, f gets to do its thing
11:55:14 <stepcut> the other 'cool' feature about my man/help text library, is that it calculates your terminal width and automatically reformats the output of --help to fit :)
11:55:15 <gwern> pikhq: ubuntu, but I suspect that that boilerplate may be wrong in some manpages anyway
11:55:19 <Cale> and if f doesn't use its second parameter, then the recursion is over
11:55:29 <stepcut> mae_: not anymore.
11:55:36 <gwern> stepcut: if one needs that feature, one's docs are too prolix!
11:55:44 <beutdeuce> Cale: k
11:55:55 <gwern> docs should be written so that only those who don't need them can understand them. that's the unix wya
11:55:57 <Cale> beutdeuce: So it really does start evaluating at the top :)
11:55:57 <stepcut> gwern: :p
11:56:10 <beutdeuce> Cale: u can say
11:56:42 <Cale> The f 2 (f 3 (f 4 (f 5 z))) might never get evaluated
11:57:14 <beutdeuce> Cale: that is if f z doesnt return, right?
11:57:42 <Cale> er, it's if f 1 (...) doesn't end up needing to know what (...) is to produce part or all of its result
11:58:03 <beutdeuce> Cale: example?
11:58:29 <Cale> > repeat False
11:58:31 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
11:58:40 <Cale> > foldr (&&) True (repeat False)
11:58:42 <lambdabot>   False
11:58:50 <mauke> > foldr (\x z -> x) 42 [0 ..]
11:58:51 <lambdabot>   0
11:59:16 <mae_> stepcut: I've been talking with tibbe lately, I implemented sendfile in happs (dev branch) and it performs quite well, but eventually you hit the 1024 open file select limit
11:59:23 <mae_> (when your concurrency is high)
11:59:28 <beutdeuce> i see, but so it seems that in all of these scenarios, foldr isnt necessary to begin with
11:59:32 <Cale> ?
11:59:37 <mae_> stepcut: so we're working on an event lib that uses epoll / kqueue etc
11:59:39 <Cale> No, there are useful things
11:59:53 <Cale> map f = foldr ((:) . f) []  for one ;)
12:00:00 <beutdeuce> > foldr (\x z -> x) 42 [0 ..]  == head [0..]
12:00:02 <lambdabot>   True
12:00:08 <mauke> @src and
12:00:09 <lambdabot> and   =  foldr (&&) True
12:00:32 <Cale> You'd want 'and' to shortcut its evaluation, and it's defined in terms of foldr so that it can.
12:00:51 <byorgey_> right, mauke's \x z -> x example doesn't really need a fold, but the 'and' example really does.
12:00:55 <helmut> is there something like an offline version of lambdabot?
12:01:02 <mauke> yeah, lambdabot
12:01:12 <Cale> > foldr (&&) True ([True, True, True, False] ++ repeat True)
12:01:13 <lambdabot>   False
12:01:15 <byorgey_> helmut: you can build lambdabot yourself and run it offline.  not sure how easy it is to build though.
12:01:23 <Cale> > foldr (&&) True (repeat True)
12:01:24 <beutdeuce> Cale: i see, so it serves its purpose as an axiom for lower-level functions, such as &&
12:01:28 <lambdabot>   mueval-core: Prelude.read: no parse
12:01:28 <lambdabot>  mueval: ExitFailure 1
12:01:31 <Raevel> i recall it being easy to build it
12:01:39 <mmorrow> SamB: this macro is exceedingly super:
12:01:41 <mmorrow> #define CON(type,name,exp) type name;void __attribute__ ((constructor)) init_##name(void){name = exp;}
12:01:43 <helmut> I've just seen @src and that would have often helped me.
12:01:44 <byorgey_> well, only one way to find out =)
12:01:52 <mmorrow> SamB: then at top-level
12:01:54 <Cale> beutdeuce: You don't want to do more work than necessary to determine the result.
12:01:55 <mmorrow> CON(List*,xs,cons(0,cons(1,cons(2,cons(3,NULL)))));
12:01:57 <mmorrow> e.g.
12:02:11 <beutdeuce> Cale: exactly
12:02:20 <Cale> beutdeuce: So by giving control to the combining function, it allows things to stop early.
12:02:21 <byorgey_> helmut: you can also send private messages to lambdabot with /msg.
12:02:49 <Cale> beutdeuce: It's worth noticing that  foldr (:) []  is the same as the identity function, even for infinite lists
12:02:54 <Cale> > foldr (:) [] [1..]
12:02:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:03:18 <helmut> byorgey_: I really meant offline.
12:03:25 <Cale> > foldr ((:) . (*10)) [] [1..]
12:03:27 <lambdabot>   [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210...
12:03:34 <Cale> > map (*10) [1..]
12:03:36 <lambdabot>   [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210...
12:03:41 <byorgey_> helmut: OK, sure.
12:03:52 <byorgey_> @where lambdabot
12:03:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
12:03:58 <helmut> thanks
12:04:08 <byorgey_> hmm, is that still the most up-to-date URL?
12:04:09 <beutdeuce> > foldr (\x xs -> (x*10):xs) 0 [1..]
12:04:11 <lambdabot>   No instance for (GHC.Num.Num [a])
12:04:11 <lambdabot>    arising from the literal `0' at <inter...
12:04:26 <Cale> byorgey_: A reasonably up-to-date version is on hackage, I think.
12:04:34 <byorgey_> @hackage lambdabot
12:04:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lambdabot
12:04:40 <Cale> > foldr (\x xs -> (x*10):xs) [] [1..]
12:04:40 <byorgey_> there we go
12:04:41 <lambdabot>   [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210...
12:04:43 <helmut> byorgey_: that url is a redirect
12:04:53 <byorgey_> ah, ok
12:04:59 <Cale> beutdeuce: Of course, with that list, the [] is never used ;)
12:04:59 <beutdeuce> Cale: right
12:05:20 <Cale> > foldr (:) [4,5] [1,2,3]
12:05:22 <lambdabot>   [1,2,3,4,5]
12:05:36 <Cale> So, xs ++ ys = foldr (:) ys xs
12:05:46 <pikhq> @src ++
12:05:47 <lambdabot> []     ++ ys = ys
12:05:47 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:05:47 <lambdabot> -- OR
12:05:47 <lambdabot> xs ++ ys = foldr (:) ys xs
12:06:11 <Cale> Well, of course, xs ++ ys is just replacing the [] at the end of xs with ys
12:06:23 <Cale> So that definition is natural :)
12:07:25 <jmcarthur_> am i right that Control.Monad.Writer.Lazy.WriterT is lazy but Control.Monad.Writer.Lazy.Writer is not, or am i missing something when reading the source?
12:07:39 <Cale> beutdeuce: It takes a bit of getting used to that when you see f (g x), it's f that evaluates first and not g or x :)
12:07:41 <jmcarthur_> (i may have asked that already, but i got disconnected, so i'm not sure)
12:08:00 <Cale> beutdeuce: But it's at least somewhat natural that it's in the order that you read across the page :)
12:08:02 <beutdeuce> Cale: currying?
12:08:07 <Cale> beutdeuce: Not currying
12:08:11 <Cale> lazy evaluation
12:08:45 <beutdeuce> Cale: f (g x), where f evaluates first made me think of f evaluating to a function that takes g(x) as a parameter
12:08:57 <Cale> Lazy evaluation is just outermost-first evaluation, plus an optimisation which says that if a parameter to a function occurs more than once in the body of the function, then any evaluation done to that parameter is shared amongst the copies.
12:09:10 <Cale> beutdeuce: well, that much is true
12:09:33 <Cale> beutdeuce: When you evaluate f (g x), you take the body of f, and substitute in (g x) for the parameter.
12:09:53 <Cale> (without evaluating (g x) yet)
12:09:54 <pikhq> And that's all the evaluation there is.
12:10:13 <Cale> Well, you'd then continue on with whatever the outermost thing was in the body of g
12:10:14 <Cale> er
12:10:14 <Cale> f
12:10:34 <Cale> (heh, the keys are right next to each other :P)
12:10:59 <Cale> I'll give the example that I usually do:
12:11:06 <Cale> Suppose we have double x = x + x
12:11:17 <Cale> and we want to evaluate  double (double 5)
12:11:29 <Cale> Using strict evaluation, it would look like:
12:11:31 <Cale> double (double 5)
12:11:36 <Cale> -> double (5 + 5)
12:11:38 <Cale> -> double 10
12:11:39 <Cale> -> 10 + 10
12:11:41 <Cale> -> 20
12:12:00 <Cale> Using plain outermost-first evaluation (not quite full lazy evaluation)
12:12:03 <Cale> double (double 5)
12:12:09 <Cale> -> (double 5) + (double 5)
12:12:16 <Cale> -> (5 + 5) + (double 5)
12:12:24 <Cale> -> 10 + (double 5)
12:12:29 <Cale> -> 10 + (5 + 5)
12:12:31 <Cale> -> 10 + 10
12:12:33 <Cale> -> 20
12:12:52 <Cale> Note that we wasted some time computing double 5 twice though
12:13:06 <Cale> This is because x occurs twice in the body of  double x = x + x
12:13:06 * jmcarthur_ thinks Cale needs to just keep this example handy for a quick copy/paste ;)
12:13:14 <Cale> jmcarthur_: I don't mind typing it
12:13:14 <EvilTerran> put it on the wiki!
12:13:34 <Cale> This also lets people stop me if at any point it stops making sense.
12:13:51 <jmcarthur_> true
12:13:52 <beutdeuce> i appreicate that
12:13:56 <Cale> So anyway, with lazy evaluation, we prevent this duplication of work.
12:14:18 <Cale> In lazy evaluation it looks like:
12:14:22 <Cale> double (double 5)
12:14:43 <Cale> -> let x = double 5 in x + x  -- note that this is still outermost-first
12:14:51 <Cale> -> let x = 5 + 5 in x + x
12:14:56 <Cale> -> let x = 10 in x + x
12:14:58 <Cale> -> 10 + 10
12:14:59 <Cale> -> 20
12:15:45 <jmcarthur_> keeping in mind that let-bound variables are not actually duplicated if they are used more than once
12:16:01 <Cale> So, with strict evaluation, every parameter is always evaluated exactly once. With outermost first evaluation, parameters are evaluated zero or more times. With lazy evaluation, parameters are evaluated zero or one times.
12:16:48 <Cale> Right, I'm really using the 'let' there to represent the fact that in memory, there is a graph representing that expression which has a + node with two arcs leading to the same thing
12:17:25 <Cale> let actually does have that effect in code too, so it's a convenient way to represent it
12:18:01 <Cale> beutdeuce: Is all this comprehensible?
12:18:35 <beutdeuce> yes
12:19:09 <Cale> I hope it gives the impression that lazy evaluation is not all that magical. It's just a different order of evaluating expressions, together with a little optimisation to ensure that work is not unnecessarily duplicated when a parameter to a function occurs more than once in the body of the function.
12:19:15 <Cale> That's all there is to it, really :)
12:20:00 <pikhq> Cale: Now, memoizing lazy evaluation, that could count as magic. :P
12:20:04 <beutdeuce> if its as optimal as it seems to me now, why are there different kinds of evaluations?
12:20:26 <pikhq> beutdeuce: Strict evaluation is easier to implement.
12:20:32 <Berengal> It's hard to reason about the operational semantics of lazy evaluation
12:20:33 <Cale> beutdeuce: Well, lazy evaluation does mean that we have to have a runtime representation of expressions.
12:20:38 <pikhq> And language developers are lazy.
12:21:00 <pikhq> Since language *developers* are lazy, their languages can't be. :P
12:21:05 <beutdeuce> pikhq: pun? o.0
12:21:11 <pikhq> beutdeuce: Yuh.
12:21:17 <beutdeuce> :)
12:21:17 <hzap> it's hard to be lazy while a language isn't purely functional
12:21:37 <pikhq> hzap: Yeah; the side effects! The side effects!
12:21:41 <Cale> beutdeuce: (If you hear the word 'thunk', it's the word people usually use to refer to the in-memory representation of an expression. I prefer just to call these things 'expressions' myself, but 'thunk' is more traditional.)
12:22:43 <Cale> beutdeuce: There *is* a bit of overhead to allowing every value to potentially be an expression, which is difficult to eliminate (though more and more research has been poured into it, and this is one of the goals of Haskell)
12:22:47 <beutdeuce> thunk as in cmp eax,15F73 jmp Call() nop ?
12:23:00 <tkr> your tutorial is bit confusing. I read the the IRC thing first that mike-burns adviced and now going throug leanyourahaskell.com. there it says that if I do a let b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] and then b !! 2 it return [1,2,2,3,4] which is obviously wrong.
12:23:00 <Cale> beutdeuce: er, eh?
12:23:24 <Cale> tkr: that is obviously wrong, yes ;)
12:23:35 <Cale> > let b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] in b !! 2
12:23:37 <lambdabot>   [5,3,3,3]
12:23:48 <beutdeuce> Cale: lol, nvm, was thinking of expression representation in machine code, not memory, slight differernce there ;)
12:24:00 <beutdeuce> well
12:24:02 <beutdeuce> not expressions
12:24:06 <byorgey_> @seen BONUS
12:24:07 <lambdabot> BONUS is in #haskell. I last heard BONUS speak 2h 17m 3s ago.
12:24:08 <beutdeuce> more like calls
12:24:09 <Cale> beutdeuce: Well, basically, you have every value be a code pointer
12:24:30 <mike-burns> tkr: Which page is that on?
12:24:31 <tkr> Cale: well, I got confused while reading it. maybe it should be fixed. this is on the 'Starting Out' page, look for "Lists can also contain lists."
12:24:32 <byorgey_> tkr: BONUS is the author of LYAH, I'm sure he'd love to know about any typos/mistakes
12:24:36 <beutdeuce> @seen byorgey_
12:24:37 <lambdabot> byorgey_ is in #haskell-overflow, #haskell-in-depth, #haskell-blah, #xmonad and #haskell. I last heard byorgey_ speak 4s ago.
12:24:46 <Cale> beutdeuce: and before it's been evaluated, you have that pointer point at a piece of code to calculate it.
12:24:53 <tkr> mike-burns: just told to Cale
12:24:57 <mike-burns> Cool.
12:25:11 <Cale> beutdeuce: But then at the end of that code, you have it replace the pointer with a pointer to a piece of code which just returns the result directly.
12:25:33 <beutdeuce> interesting
12:25:48 <Cale> beutdeuce: You can do it in a number of other ways, but I think this is how GHC does it.
12:25:54 <int-e> enter pointer tagging ...
12:26:04 <Cale> (well, a somewhat more elaborate version of that, with pointer tagging...)
12:26:59 <pikhq> typedef *(hs_data_t*)expression_t(expression_t *); // This. :P
12:27:09 <Cale> GHC actually additionally stores a bit of information on which constructor the thing evaluated to, and whether it's been evaluated in the low-order bits of the pointer, since memory alignment allows you to do that anyway
12:27:39 <int-e> but that's the basic version described in the STG paper (the implementing lazy functional languages on stock hardware one)
12:28:05 <Cale> So, for instance, when you have a Bool value and it's already been evaluated, it can just mask off the low order bits of the code pointer to see what it is without jumping into the code.
12:28:17 <Cale> It's all very clever.
12:29:43 <Cale> But going that low-level to understand the performance of Haskell code is usually unnecessary. Usually just thinking about it from the perspective of making substitutions in expressions is a close enough approximation to get a good idea of whether something will perform reasonably well.
12:30:20 <beutdeuce> Cale: i would like to see the paste to your solution to #18, now that i have a better understanding of folding
12:32:09 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7200#a7204 -- at the bottom
12:32:34 <beutdeuce> thnx
12:36:54 <beutdeuce> Cale:  what is getContents?
12:37:21 <Cale> beutdeuce: It gets all the text from stdin.
12:37:22 <int-e> beutdeuce: getContents returns the standard input of the program as a (lazy) String
12:37:35 <beutdeuce> Cale: when does it stop? White space?
12:37:48 <Cale> It stops when stdin gets closed.
12:39:06 <Cale> It is slightly magical.
12:40:34 <Baughn> Cale: While an unamb primop would be neat, I don't think one is actually /possible/
12:40:44 <Cale> Baughn: hmm...
12:40:56 <Baughn> Better would be some improvements and variations on upIO, to make the non-prim implementation of unamb better
12:41:01 <beutdeuce> Cale, magically, it worked, but the only function i understand is main :(
12:41:22 <Cale> beutdeuce: okay
12:41:40 <Baughn> Cale: Anyway, unamb is vast overkill for my purposes, eg. FRP. I've almost gotten that one figured out, and while it could use some RTS support, it's much simpler support.
12:42:06 <Cale> Baughn: oh cool, there's a way to avoid unamb altogether?
12:42:15 <Cale> beutdeuce: Let's take a look at each piece.
12:42:23 <beutdeuce> That would be great
12:42:47 <Baughn> Cale: Yep, basically by implementing it using the observer pattern - well, I haven't got all the details down yet, and there are plenty of devils in there
12:43:02 <Baughn> Cale: Thus my interest in IVars
12:44:00 <Baughn> I'll have the various functions on Time produce a record of their intentions instead of actually trying to do work, until someone else tries to use their result values - that is, some function not in that set
12:44:16 <Cale> beutdeuce: The main idea is that if you have the solutions for the triangles below two points in the triangle which are side-by-side, then you can combine them into a solution for the point just above those two.
12:44:18 <Baughn> And then have the event sink fill in the details by chasing (weak) pointers afterwards
12:44:29 * gwern blinks. this is the first thing I've seen a CS thesis hail Discordia
12:44:33 <gwern> *time
12:45:36 <beutdeuce> Cale: not sure what u mean by that
12:46:05 <Baughn> Cale: All in the interests of reasonably efficient FRP. My only real problem is the required extensive use of MVars, which I hope to cut down on using primops /later/.
12:46:06 <gwern> also, first time I've seen one thank Aleister Crowley
12:46:12 <Berengal> gwern: Link?
12:46:17 <Cale> beutdeuce: Okay, pick two positions in the same row of the triangle which are next to each other
12:46:22 <Baughn> gwern: I think you should stop reading now.
12:46:28 <gwern> Berengal: 'type inference and optimization for an impure world'
12:46:34 <beutdeuce> Cale: one min, got to switch computers, sorry bout that
12:46:42 <Baughn> Yeah. I figured it'd be unholy.
12:46:51 <Cale> Baughn: interesting. I hope it works out well :)
12:46:57 <int-e> Baughn: hmm, you'd need IVars with notifier support, I guess.
12:47:06 <Cale> beutdeuce: okay
12:47:20 <Baughn> int-e: I'm not quite sure what I need yet, so I'm trying not to jump too far ahead. I have to implement this first. :}
12:47:47 <Baughn> int-e: This'll be my third attempt at FRP. First was a total failure, second might have worked if I hadn't had this idea..
12:47:52 <Baughn> Well, third time's the charm
12:48:28 <Baughn> unamb acts as a join, collecting information from various event sources. The trick is that you don't need a join if you don't branch in the first place
12:49:40 <Baughn> ..also, two nights ago I dreamt that unamb killed my family. Um.. yeah.
12:50:00 <gwern> that's some nasty lsd there
12:50:14 <gwern> but wait, isn't murder an observable side-effect?
12:50:15 <Baughn> Who needs LSD when he has unsafePerformIO?
12:51:01 <Baughn> Ugh. With all this effort, I think I'll try to write something I can publish in the end.
12:51:43 <beutdeuce> Cale, back
12:52:11 <int-e> Baughn: fwiw, I agree with your assessment of unamb as a primop; making unamb work is rather complex - you have to spawn at least one thread if both arguments are unevaluated, for example, and then synchronise them. My own conclusion was that a primop simply wouldn't be much more efficient than the Haskell implementation we've been toying with. In particular I didn't see anything to optimize in the thread synchronization area.
12:52:11 <beutdeuce> Cale, mind repasting the url?
12:53:52 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7200#a7204
12:54:09 <beutdeuce> thanks
12:54:25 <Cale> http://cale.yi.org/share/triangle.png
12:54:29 <Cale> take a look at that
12:55:05 <Cale> Suppose we know that the red path is the best path from that node near the top down to the anything at the bottom, and the sum of the path is 29
12:55:36 <Cale> and similarly for the blue path, it's the best path from the node near the top down to the bottom of the triangle, and the sum was 47
12:56:25 <Cale> Even without knowing what number the top node is, we can say that the winning path for the whole triangle will consist of the top node plus the blue path
12:58:54 <Cale> If you'll refresh the image, I've added the two subtriangles which the paths were the winners of.
12:59:29 <beutdeuce> so, the idea is that u find the best path, starting from the bottom up, and add it to nodes above it?
12:59:39 <gwern> @remember BenLippmeier Are Haskell and O‚ÄôCaml destined to be The Velvet Underground of programming languages, where hardly anyone has heard them, but everyone who does forms a band?
12:59:40 <lambdabot> Okay.
12:59:43 <gwern> @flush
12:59:50 <Cale> right, you find *all* the best paths below each node in each row
12:59:57 <mike-burns> Haha.
13:00:18 <Cale> successively combining the best paths from the row below to get the best paths for the next row up
13:00:29 <beutdeuce> how did u manage to find the *best* path
13:00:44 <Cale> beutdeuce: Well, for the bottom row, it's really easy.
13:01:37 <Cale> beutdeuce: The only path for any of the nodes in the bottom row is just that one node.
13:03:26 <Cale> and if we have the list of solutions for some row, and we have the row r above it, we can look at adjacent pairs of best paths, pick the better one, and add the corresponding element of r to the start of the path (and the sum)
13:03:48 <Cale> and build the solutions for row r
13:04:06 <Cale> and eventually we get to the top and there's only one solution left which is the winner
13:04:40 <beutdeuce> k, but how did u know that to code?
13:04:50 <beutdeuce> what*
13:05:05 <Vanadium> How do I write a case expression without using layout?
13:05:31 <dolio> case foo of { case1 -> exp1 ; case2 -> exp2 ; ... }
13:05:32 <Cale> Vanadium: case foo of { pat1 -> expr1 ; pat2 -> expr2}
13:05:44 <Cale> beutdeuce: okay, let's look at each piece
13:06:07 <Cale> beutdeuce: I'm representing a solution to some subtriangle as a pair, consisting of the sum, and the actual path
13:06:14 <Vanadium> Oh, okay. I got confused because @pl would not parse the {
13:06:45 <Vanadium> Is there a way to write a points-free case so that someIOAction >>= \x -> case x of does not need to name x?
13:06:54 <Cale> For example, something like (10,[4,1,3,2])
13:07:05 <mae_> stepcut: what have you been up to lately?
13:07:11 <mauke> Vanadium: no
13:07:25 <beutdeuce> Cale, k
13:07:38 <Cale> beutdeuce: The only reason I'm keeping the sum alongside the list is to avoid recomputing the sums of the lists, and because it makes it easy to use the max function to get the better of two solutions
13:08:03 <Cale> > max (10,[4,1,3,2]) (12,[4,2,5,2])
13:08:06 <lambdabot>   (12,[4,2,5,2])
13:08:27 <beutdeuce> Cale, k
13:08:37 <Cale> beutdeuce: My function  insert  takes a number, and one of these pairs, and adds the number to the total, and to the beginning of the list
13:08:45 <Cale> @let insert v (s,xs) = (v+s,v:xs)
13:08:46 <lambdabot>  Defined.
13:08:55 <Cale> > insert 5 (12,[4,2,5,2])
13:08:56 <lambdabot>   Ambiguous occurrence `insert'
13:08:56 <lambdabot>  It could refer to either `Data.List.insert',...
13:09:02 <Cale> oh, duh ;)
13:09:03 <Badger> woops
13:09:06 <Cale> > L.insert 5 (12,[4,2,5,2])
13:09:08 <lambdabot>   (17,[5,4,2,5,2])
13:09:40 <Cale> beutdeuce: so that much is good, yeah?
13:09:53 <beutdeuce> Cale, yes
13:10:31 <Cale> So now let's look at layer. The idea is that layer takes a row of the triangle, and the solutions for each of the nodes in the row below that, and it somehow combines those together to get the solutions for the given row.
13:11:05 <Cale> Take a look at  zipWith max maxpaths (drop 1 maxpaths)  first
13:11:41 <Cale> What is this doing? It's taking adjacent solutions in the list, and determining which of the two is better.
13:12:02 <beutdeuce> Cale, how is it doing that?
13:12:30 <Cale> well, let's start with a simpler example
13:12:35 <Cale> > let xs = [5,12,17,6,20,9] in zipWith (,) xs (drop 1 xs)
13:12:36 <lambdabot>   [(5,12),(12,17),(17,6),(6,20),(20,9)]
13:12:47 <Cale> Here, the (,) function just pairs the elements of that list together
13:13:25 <Cale> See, it's pairing the elements of the list [5,12,17,6,20,9] with the elements of drop 1 of that, which is [12,17,6,20,9]
13:13:43 <Cale> so this gets us a list of the adjacent pairs
13:13:52 <Cale> But we don't just want to pair them, we want the better of the two
13:13:58 <Cale> > let xs = [5,12,17,6,20,9] in zipWith max xs (drop 1 xs)
13:14:00 <lambdabot>   [12,17,17,20,20]
13:14:47 <Cale> So, 12 is the winner of the first pair, 17 is the winner of the second and third pairs, and 20 is the winner of the last two pairs
13:15:21 <Cale> Does that much make sense?
13:15:42 <Cale> max is polymorphic, so it'll work on our solutions too (which have a list along with each number)
13:15:57 <beutdeuce> i'm trying to accomodate with zipWith
13:16:19 <Cale> zipWith [1,2,3,4,5] (words "here are some words")
13:16:23 <Cale> > zipWith [1,2,3,4,5] (words "here are some words")
13:16:25 <lambdabot>   Couldn't match expected type `a -> b -> c'
13:16:27 <Cale> er
13:16:30 <Cale> > zipWith (,) [1,2,3,4,5] (words "here are some words")
13:16:31 <lambdabot>   [(1,"here"),(2,"are"),(3,"some"),(4,"words")]
13:16:44 <Cale> (zipWith (,) is also known as zip)
13:16:55 <Cale> Note that it stops when either of the lists stop
13:17:01 <beutdeuce> yeah, i remember zip
13:17:09 <beutdeuce> yes
13:17:50 <Cale> zipWith, rather than producing pairs, takes a function of two parameters, and applies it to the corresponding pairs of elements
13:18:07 <Cale> @src zipWith
13:18:08 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
13:18:08 <lambdabot> zipWith _ _      _      = []
13:18:39 <beutdeuce> k
13:18:50 <Cale> Starting to become clear what's happening?
13:19:18 <beutdeuce> why is max after zipWith not before, like max $ zipWith (,) xs (drop 1 xs)
13:19:46 <Cale> oh, we could use something like  map (uncurry max) $ zip xs (drop 1 xs)
13:20:08 <Cale> map (uncurry f) (zip xs ys) = zipWith f xs ys
13:20:09 <soupdragon> why not tail?
13:20:15 <Cale> soupdragon: drop 1 is safer
13:20:28 <Cale> > drop 1 []
13:20:29 <soupdragon> > zip [] (tail [])
13:20:31 <lambdabot>   mueval-core: Prelude.read: no parse
13:20:31 <lambdabot>  mueval-core: GhcException "mkTopLevEnv...
13:20:31 <lambdabot>   []
13:20:38 <soupdragon> hmmm
13:20:43 <soupdragon> okay
13:20:44 <Cale> oh, I suppose in this case, it's not a problem
13:20:54 <Cale> since zip will stop anyway
13:20:59 <soupdragon> it is a problem even here!
13:21:05 <soupdragon> , zip [] (tail [])
13:21:06 <lunabot>  []
13:21:11 <Cale> > zip [] (tail [])
13:21:12 <lambdabot>   []
13:21:18 <pikhq> @src uncurry
13:21:18 <lambdabot> uncurry f p = f (fst p) (snd p)
13:21:21 <soupdragon> > drop 1 []
13:21:22 <beutdeuce> what does (,) mean? u later replace it with max
13:21:23 <lambdabot>   []
13:21:30 <pikhq> That was... Totally obvious.
13:21:30 <Cale> > (,) 5 6
13:21:32 <lambdabot>   (5,6)
13:21:34 <soupdragon> what :|
13:21:49 <Cale> beutdeuce: it's the constructor for pairs
13:21:53 <beutdeuce> but max isnt
13:21:57 <Cale> beutdeuce: right
13:22:05 <Cale> beutdeuce: max will pick the maximum of the two
13:22:10 <Cale> > max 5 6
13:22:11 <lambdabot>   6
13:22:52 <Cale> zipWith max xs (drop 1 xs)  will take adjacent elements of xs, and pick the max of each pairing
13:23:29 <pikhq> AKA zipWith max xs $ tail xs
13:23:31 <beutdeuce> again, zipWith takes a function and two lists as a parameter, and what does it do then?
13:23:42 <Cale> @src zipWith
13:23:42 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
13:23:42 <lambdabot> zipWith _ _      _      = []
13:23:53 <Cale> It applies the function to corresponding elements of the two lists.
13:24:03 <Cale> and stops when either list ends
13:24:14 <twanvl> > zipWith f [a,b,c] [d,e]
13:24:15 <beutdeuce> Cale, so a zipWith is a map that operates on two lists?
13:24:16 <lambdabot>   Add a type signature
13:24:19 <Cale> > zipWith (+) [1,2,3] [40,50,60]
13:24:21 <lambdabot>   [41,52,63]
13:24:29 <Cale> beutdeuce: if you want, sort of, yes
13:25:03 <Cale> > zipWith f [a,b,c] [d,e] :: [Expr]
13:25:04 <beutdeuce> k
13:25:05 <lambdabot>   [f a d,f b e]
13:25:09 <BMeph> Cale: If you want?!? Of course it is!
13:25:26 <Cale> BMeph: it's a combination of map and zip
13:25:59 * BMeph has campaigned in the past to rename "map" as "zipWith1", and "zipWith" as "zipWith2", just to accentuate that point.
13:26:07 <Cale> It's fairly different in my mind, in that it's doing all this work to pair up corresponding elements of the lists.
13:26:41 <ray> > (,,,,,,,,) 1 2 3 4 5 6 7 8 9 -- what's the max for tuple size in ghc again?
13:26:42 <lambdabot>   (1,2,3,4,5,6,7,8,9)
13:26:47 <Cale> and that it may ignore some elements of one of the lists
13:27:06 <Cale> map is a much more straightforward thing
13:27:23 <pikhq> ray: n
13:27:29 <Cale> ray: big, but the instances cut out after a while.
13:27:52 <Cale> ray: If you use anything larger than a triple, you shouldn't be using tuples anymore.
13:27:59 <Saizan> ray: you get instances up to 7, but the maximum size is around 62
13:28:00 <ray> purely hypothetical
13:28:07 <BMeph> ray: Instances stop somewhere b/t 15 and 17, but GHC "understands" tuples up to 64, I believe. :)
13:28:20 <ray> cool, everyone has a different answer
13:28:30 <Cale> ray: You should just test it on your own.
13:28:49 <dolio> > (1,2,3,4,5,6,7,8)
13:28:51 <lambdabot>   (1,2,3,4,5,6,7,8)
13:29:02 <dolio> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18)
13:29:03 <BMeph> ray: Well, kind of cool; just keep in mind that, being newer to Haskell, my answers are more frequent, and more frequently wrong. ;)
13:29:04 <lambdabot>   No instance for (GHC.Show.Show
13:29:04 <lambdabot>                     (t,
13:29:04 <lambdabot>                     ...
13:29:05 <pikhq> Or just don't touch n-tuples where n is greater than 2.
13:29:06 * Saizan is clearly wrong
13:29:52 <Saizan> oh, it's Typeable that stops at 7
13:29:54 <Cale> beutdeuce: anyway, is that little segment of code starting to make sense?
13:30:00 <dolio> Show ends at 15-tuples.
13:30:07 <BMeph> I think zip<n>/zipWith<n> is defined up to seven, though. :)
13:30:10 <beutdeuce> Cale, yes
13:30:28 <Cale> beutdeuce: The only thing to do once we have the winner of each adjacent pair, is to attach the element of the row which lies above those two
13:30:37 <Cale> beutdeuce: which is accomplished using another zipWith
13:31:12 <Cale> beutdeuce: this time, using insert
13:32:17 <ray> i can :t some pretty massive tuple constructors in ghci
13:32:29 <Cale> > zipWith L.insert [4,2,3] [(10,[4,2,3,1]), (12,[5,2,4,1]), (14,[5,3,4,2])]
13:32:31 <lambdabot>   [(14,[4,4,2,3,1]),(14,[2,5,2,4,1]),(17,[3,5,3,4,2])]
13:32:47 <dolio> ray: I don't think there's any limit on how big tuple constructors can get.
13:32:59 <dolio> Which is odd since actual large tuples are disallowed.
13:33:13 <Cale> beutdeuce: So, now we almost have everything that we need.
13:33:23 <dolio> At least, for the purpose of :t.
13:33:25 <BMeph> I blame the unsatisfying record types for the "bumpy cases" (i.e., not quite corner-y) of tuples. :\
13:33:56 <dolio> You can even do "(,... 200 tuple ...,) 1 ... 200 1s ... 1", and get a :t.
13:34:20 <Cale> beutdeuce: We have (from the I/O portion), a list of lists corresponding to the elements in each row, and we have a way to take a row, and the solutions for the following rows, and combine them into the solutions for that row.
13:34:22 <dolio> But you can't do "(1,1,... 200 tuple ...,1)".
13:34:31 <ray>     A 8156-tuple is too large for GHC
13:34:31 <ray>       (max size is 62)
13:34:31 <ray>     A 8156-tuple is too large for GHC
13:34:31 <ray>       (max size is 62)
13:34:43 <ray> i don't know how that appeared twice, but there we go
13:35:34 <Cale> beutdeuce: The idea is to take layer and use it to combine the successive rows of the triangle.
13:35:53 <beutdeuce> Cale, yes
13:36:18 <Cale> beutdeuce: but what about when we get to the end? Well, we need a row of empty solutions which the bottom row of elements will be inserted into
13:36:29 <Cale> beutdeuce: For that, I just used (repeat (0,[]))
13:36:39 <Cale> > repeat (0,[])
13:36:40 <lambdabot>   [(0,[]),(0,[]),(0,[]),(0,[]),(0,[]),(0,[]),(0,[]),(0,[]),(0,[]),(0,[]),(0,[...
13:37:04 <Cale> > zipWith L.insert [1,2,3,4,5] (repeat (0,[]))
13:37:05 <lambdabot>   [(1,[1]),(2,[2]),(3,[3]),(4,[4]),(5,[5])]
13:37:26 <beutdeuce> but later takes 2 parameters, u gave it one
13:37:36 <Cale> hm?
13:37:41 <beutdeuce> layer*
13:37:56 <Cale> What did I give it now?
13:38:02 <Cale> layer is a parameter to foldr
13:38:16 <Cale> the parameter to foldr is supposed to take two parameters
13:38:22 <beutdeuce> so its getting (0,[])
13:38:26 <Cale> I didn't give layer anything before passing it to foldr
13:38:48 <Cale> but it will eventually get  repeat (0,[])  as a second parameter
13:39:06 <Cale> at the end of the list of rows
13:39:16 <beutdeuce> how about at the end of the last row?
13:39:41 <Cale> So if our triangle is, say,  [[4],[2,3],[5,7,5],[10,3,6,4]]
13:40:03 <Cale> foldr layer (repeat (0,[]))  applied to it will give
13:40:30 <Cale> layer [4] (layer [2,3] (layer [5,7,5] (layer [10,3,6,4] (repeat (0,[])))))
13:40:43 <balor> If Foo.hs contains "main = getContents >>== some_sequence" how do I pass param1 into main?  I had thought "runhaskell Foo.hs param1" would do it.
13:40:57 <balor> s/>>==/>>=/
13:41:12 <Cale> balor: getContents reads input from stdin, is that what you're wondering?
13:41:15 <beutdeuce> Cale, i see.
13:41:30 <balor> Cale: I *think* so.  So I'll have to pipe in.
13:41:32 <Cale> balor: If you want to read arguments from the commandline, you'd use getArgs from System.Environment
13:41:39 <beutdeuce> Cale, very impressive
13:41:42 <balor> Cale: thanks.
13:42:35 <beutdeuce> Cale, brb
13:52:33 <gwern> 'We will take a moment to meditate on the following type signature, from the
13:52:34 <gwern> analtypes module of the Clean 2.2 compiler source code:
13:52:34 <gwern>    checkKindsOfCommonDefsAndFunctions
13:52:34 <gwern>         :: ! Index ! Index ! NumberSet ![ IndexRange ]
13:52:34 <gwern>             !{# CommonDefs } ! u :{# FunDef } ! v :{# DclModule }
13:52:36 <gwern>             !* TypeDefInfos !* ClassDefInfos !* TypeVarHeap
13:52:39 <gwern>             !* ExpressionHeap !* GenericHeap !* ErrorAdmin
13:52:41 <gwern>         -> ( ! u :{# FunDef } , ! v :{# DclModule } , !* TypeDefInfos
13:52:44 <gwern>             , !* TypeVarHeap , !* ExpressionHeap , !* GenericHeap
13:52:44 <hackagebot> HStringTemplate 0.6 - StringTemplate implementation in Haskell. (SterlingClover)
13:52:48 <gwern>             , !* ErrorAdmin )
13:53:01 <Twey> gwern: Holy monkeys
13:53:25 <gwern> I'd @remember that, but it wouldn't fit...
13:53:35 <Twey> Hmm
13:53:36 <Twey> It might
13:53:51 <gwern> no wai. not even if you removed all the spaces
13:54:08 <gwern> the first sentence blows half your character budget; and the type sig is hopeless
13:54:23 <Twey> ‚ÄòWe will take a moment to meditate on the following type signature, from the analtypes module of the Clean 2.2 compiler source code: checkKindsOfCommonDefsAndFunctions :: ! Index ! Index ! NumberSet ![ IndexRange ] !{# CommonDefs } ! u :{# FunDef } ! v :{# DclModule } !* TypeDefInfos !* ClassDefInfos !* TypeVarHeap!* ExpressionHeap !* GenericHeap !* ErrorAdmin -> ( ! u :{# FunDef } , ! v :{# DclModule } , !* TypeDefInfos, !* TypeVarHeap , !* ExpressionHea
13:54:36 <Twey> That's no more than two messages at most
13:54:48 <gwern> lb doesn't take 2 messages
13:54:52 <Deewiant> Still more than one :-)
13:54:57 <caxaf> Twey: That got cut off, you know. :-)
13:55:01 <gwern> although I don't know how @remember works on a CLI lb, though
13:55:15 <gwern> might be you could have quotes of unlimited length there, or if you manually edited the quote sfile
13:56:43 <Twey> Hamn
13:56:53 <Twey> It can *output* two messages
13:57:03 <Twey> So yeah, perhaps if it were inserted manually...
13:57:11 <gwern> you'll notice the 2 messages are each below the max, though
13:57:28 <gwern> probably that breaking is there to be friendly to some cruddy client or something
13:57:38 <Twey> Could be
14:00:00 <Gracenotes> @src foldr
14:00:01 <lambdabot> foldr f z []     = z
14:00:01 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:00:15 <SamB> gwern: I think where freenode will truncate is somewhat unpredictable
14:00:28 <Twey> It's 300 bytes
14:00:39 <benmachine> SamB: it probably truncates based on message length, which will include your nick and hostname
14:00:46 <Twey> Nope
14:00:48 <benmachine> oh
14:00:50 <Cale> But that includes its representation of your hostname
14:00:56 <benmachine> that would make sense if it was true
14:00:58 <Twey> Three hundred bytes, fixed
14:01:00 <benmachine> k
14:01:00 <Twey> I measured it
14:01:03 <Twey> Once
14:01:21 <benmachine> using more than one sender?
14:01:28 <SamB> well, also take into account that maybe lambdabot is supposed to work on more than one server?
14:01:55 <SamB> --- IRCD=dancer CAPAB CHANTYPES=# EXCEPTS INVEX CHANMODES=bdeIq,k,lfJD,cgijLmnPQrRstz CHANLIMIT=#:20 PREFIX=(ov)@+ MAXLIST=bdeI:50 MODES=4 STATUSMSG=@ KNOCK NICKLEN=16 :are supported by this server
14:01:55 <SamB> --- SAFELIST CASEMAPPING=ascii CHANNELLEN=30 TOPICLEN=450 KICKLEN=450 KEYLEN=23 USERLEN=10 HOSTLEN=63 SILENCE=50 :are supported by this server
14:02:26 <SamB> hmm ... is there anything about message length in there ?
14:02:31 <Twey> Not that I can see.
14:02:38 <benmachine> how awkward
14:02:39 <Gracenotes> maybe that includes null characters, because the nick length is actually 15
14:02:56 <Plouj> hi guys
14:03:04 <Twey> IRC doesn't use nulls, Gracenotes
14:03:10 <Twey> Hi, Plouj
14:03:16 <Gracenotes> I mean the internal representation of course
14:03:17 <SamBSamBSamBSamB> so what's my nick?
14:03:23 <benmachine> Twey: IRC software might, though
14:03:34 <gwern> SamBSamBSamBSamB: obviously it's > cycle "SamB"
14:03:38 <Gracenotes> hm. it is 16 after all
14:03:52 <Plouj> I'm compiling a RWH book example without a main function and I get this error: $ ghc -c PrettyStub.hs
14:03:52 <gwern> unfortunately, hardware limitations prevent your nick from being evaluated fully
14:03:55 <Plouj> PrettyStub.hs:1:0: The function `main' is not defined in module `Main'
14:03:59 <Twey> benmachine: Yes, but considering that as part of the nick length would be an error on the part of the software
14:04:11 <benmachine> Twey: yeah it would
14:04:15 <Plouj> I shouldn't be getting the error about missing main since -c means no linking, what gives?
14:04:30 <gwern> Plouj: executables can't exist wiout a main; why would linking or not make a difference?
14:04:49 <Plouj> gwern: I'm just trying to create an object (.o)
14:05:26 <arjanb> why haven't many standard monads an Applicative instance?
14:06:41 <drhodes> more verb!
14:07:20 <twanvl> arjanb: because Applicative is too new, or equivalently, the standard monads are too old
14:07:33 <pikhq> arjanb: Because making a Monad an Applicative is hard (even though all monads are functors)!
14:07:42 <Cale> huh?
14:07:46 <Cale> pikhq: no, it's trivial
14:08:04 <Cale> instance Applicative MyMonad where pure = return; (<*>) = ap
14:08:12 <Berengal> instance Monad m => Applicative m where (<*>) = ap; pure = return
14:08:46 <Cale> (except that doesn't work because it overlaps with everything)
14:09:02 <Berengal> Cale: Insignificant details :P
14:09:31 <Berengal> (It should work. Or rather, it should be class (Applicative m) => Monad m)
14:09:55 <Cale> Well, the latter would just force people to define the appropriate instances of Applicative
14:10:43 <Berengal> Couldn't you still do "instance Monad MyMonad where [...]; instance Applicative MyMonad where (<*>) = ap; pure = return" if you wanted?
14:10:54 <Cale> yes
14:11:04 <Plouj> let me ask this differentely
14:11:15 <Plouj> how do I invoke ghc to generate an object rather than a full blow executable?
14:11:38 <SamB> Plouj: what do you plan to do with it?
14:11:49 <Plouj> SamB: load it as a module by another .hs file
14:12:10 <Cale> Plouj: just give it a non-Main module
14:12:20 <Cale> Plouj: and it will give you a .o
14:12:20 <SamB> or you could possibly also pass -c
14:12:28 <Berengal> Plouj: ghc --make
14:12:44 <SamB> does --make -c work?
14:13:03 <Berengal> SamB: don't know about -c, but --make a non-main and you get a .o
14:13:48 <arjanb> i wish Applicative were invented before Monad, now Monad are over used and Applicative is only a second rate citizen in the libraries
14:13:54 <Berengal> --make -c doesn't throw errors at least
14:14:18 <byorgey_> anyone know a sneaky Oleg-style way to express a constraint like  (forall a. Show (f a)) => blah blah f blah ... ?
14:14:28 <Cale> arjanb: I'm not sure I agree that Monad is overused.
14:15:06 <Berengal> Applicatives force a pointless style
14:15:23 <Cale> Obviously if something is a Monad we may as well make use of that fact.
14:15:50 <Philippa> Berengal: only because we don't have the pointed sugar
14:15:56 * pikhq is still vaguely of the opinion that <$> should be called .
14:15:56 <Philippa> Berengal: it's doable
14:16:10 <Berengal> Philippa: How would you point an applicative?
14:16:13 <Philippa> pikhq: the class resolution doesn't work
14:16:32 <Philippa> Berengal: first-order do, with the 'return' line going through fmap
14:16:51 <Berengal> Philippa: do you have an example?
14:16:52 <Philippa> named things use <*>, unnamed use <* or *?
14:16:57 <Philippa> *>, even
14:17:08 <Philippa> then slap a lambda around the front and apply the rest
14:17:36 <pikhq> Philippa: First, how-so? Second, I also want a halting oracle. All desires of mine must be considered with this in mind.
14:18:00 <Philippa> pikhq: it becomes ambiguous whether you want the id functor or another applicative
14:18:06 <Berengal> pikhq: <$> /= Control.Category.(.), unfortunately
14:19:12 <Philippa> Berengal: having a slow day and don't have the docs to hand. Hand-crank one for a couple of named fields to a constructor in a parsing applicative or something?
14:19:26 <pikhq> Berengal: Control.Category.(.)?
14:19:41 <SamB> Cale: Monad is often overkill ...
14:19:57 <defun> Hi. I just read about CPS (continuation passing style). I understand /what/ it does. I don't understand /why/ one should use it, instead of 'regular' functions. Any ideas?
14:20:53 <SamB> defun: I think there are a number of compilers that use it as an IR for some reason ...
14:20:59 <BMeph> defun: Short answer: control flow. Er, make that flow control. :)
14:21:04 <SamB> maybe you should look on citeseer?
14:21:24 <BMeph> Or Wikipedia, for that matter. :)
14:22:10 <Philippa> SamB: that "some reason" being that amongst other things, A-normal form was only discovered afterwards. Existance of and static eliminability of administrative regexes, uniform representation of flow/control...
14:22:23 <Cale> defun: Well, in IO particularly, it's a handy technique for controlling allocation and deallocation of resources.
14:22:26 <Berengal> pikhq: It's a class function in Control.Category
14:22:54 <SamB> Philippa: what is this "A" and why do I want it to be normal?
14:23:04 <pikhq> Berengal: I got that much.
14:23:24 <defun> thanks. i will research further.
14:23:38 <Cale> defun: Suppose you have something like  takeResource :: IO Resource, and releaseResource :: Resource -> IO () which need to be called in pairs. You can write a function  withResource :: (Resource -> IO a) -> IO a  which allocates the resource, applies the given function and executes the resulting action, and then deallocates.
14:23:38 <SamB> pikhq: it does basically the same thing as Prelude's (.)
14:23:45 <pikhq> defun: It's like state, only purely functional.
14:23:46 <Berengal> pikhq: for functions (.) is (.), for kleisli arrows it's (<=<), for arrows it's (<<<)
14:23:53 <int-e> defun: CPS improves the control you have over strictness. (a  lookup :: key -> Map key value -> (value -> r) -> r  could call the (value -> r) function with the lookup already done, without forcing the value itself)
14:23:59 * SamB really doesn't like that new qualified infix notation ...
14:24:03 <pikhq> Oh, it's (.) with multiple instances.
14:24:03 <pikhq> Neet.
14:24:34 <Philippa> SamB: you just don't know much about FPL IRs, huh?
14:24:35 <int-e> defun: sorry, I should say 'order of evaluation' instead of 'strictness'
14:25:07 <SamB> Philippa: well, I don't know nearly everything
14:25:12 <SamB> Philippa: is that good or bad?
14:25:44 <Gracenotes> @type (<=<)
14:25:46 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:26:06 <pikhq> Gracenotes: o.o
14:26:18 <Plouj> for some reason ctrl+p/n doesn't search through the ghci readline instory for me...what can I do to enable it in Linux?
14:26:19 <bgs100> @src words
14:26:19 <lambdabot> words s = case dropWhile isSpace s of
14:26:20 <lambdabot>     "" -> []
14:26:20 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
14:26:20 <pikhq> Must learn arrows. Any good links?
14:26:22 <Gracenotes> KITTY
14:26:33 <Philippa> SamB: some people might take "for some reason" to be a comment on whether it's a good IR or a good reason
14:26:38 <Plouj> however, ctrl+a and ctrl+e work as expected in readline
14:26:42 <SamB> Plouj: well, first you need to make sure your GHCi is actually using readline ...
14:27:01 <Badger> @quote Gracenotes
14:27:02 <lambdabot> Gracenotes says: > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
14:27:08 <pikhq> (I can already see that it's vaguely similar to >>=, but... That's about all I've got going for me)
14:27:18 <SamB> Philippa: when I say "for some reason", all I'm implying is that I don't remember (or don't wish to elaborate on) why
14:27:31 <SamB> in this case, I just don't remember ;-)
14:27:40 <BMeph> @wiki Arrows
14:27:40 <lambdabot> http://www.haskell.org/haskellwiki/Arrows
14:27:49 <Badger> Gracenotes: You're a monster. :P
14:28:01 <SamB> not sure if I ever really knew, but that's the way not remembering works sometimes ;-)
14:28:09 <Plouj> SamB: how? I just installed ghc in Fedora 11
14:28:10 <pikhq> BMeph: Sure, the obvious link. :P
14:28:33 <SamB> Badger: hmm, those expressions and/or patterns look like the monsters to me ;-)
14:28:46 <SamB> Plouj: you could use objdump on it
14:29:18 <Badger> SamB: the real reason he's a monster is
14:29:20 <Badger> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
14:29:21 <lambdabot>   [[0.0]]
14:29:28 <BMeph> pikhq: "When all else fails, try the obvious." ;)
14:30:03 <Plouj> SamB: well, /usr/lib64/ghc-6.10.3/ghc doesn't lik to readline
14:30:50 <BMeph> beutdeuce: Welcome back. :)
14:31:43 <beutdeuce> BMeph, thank you BMeph. If only a welcome message would suffice to calm my nerves after a tormenting accounter with Windows' narrow-mindness and stupidity with file management
14:32:05 <ray> gracenotes: (=^_^=), the kitty combinator
14:32:56 <Gracenotes> unfortunately said combinator is not syntactically correct anywhere
14:32:59 <copumpkin> there was the wrestling belt combinator
14:33:06 <beutdeuce> apparently, explorer.exe is showing me that i have a file in a folder, however, it has 0 bytes, and when i try to delete it, it tells me that file doesn't exist. I dont know if things could get any worse
14:33:16 <copumpkin> let (==<<\/\/>>==) = (+) in 5 ==<<\/\/>>== 7
14:33:23 <copumpkin> > let (==<<\/\/>>==) = (+) in 5 ==<<\/\/>>== 7
14:33:25 <lambdabot>   12
14:34:05 <copumpkin> > let (==\/\/==) = (+) in 5 ==\/\/== 7 -- or does this look better?
14:34:07 <lambdabot>   12
14:34:13 <copumpkin> it's not as epic though
14:34:18 <twanvl> > let a\/\/b = show a++"w"++show b in   w \/\/ w
14:34:20 <lambdabot>   "www"
14:34:46 <Axman6> >_<
14:35:00 <Badger> copumpkin: :D
14:35:10 <copumpkin> zomg ray is following me on twittur
14:35:25 <nominolo> @seen mmorrow
14:35:26 <lambdabot> mmorrow is in #yi, #haskell-blah, #haskell-in-depth, #ghc and #haskell. I last heard mmorrow speak 2h 33m 28s ago.
14:35:28 <ray> yeah, i figured i'd jump on the bandwagon
14:35:43 <copumpkin> ray: there's a big list of haskell twits on the haskell wiki
14:35:45 <jeffwheeler> > let (‚äª) = xor in True ‚äª True
14:35:47 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
14:35:47 <lambdabot>    arising from a use of `Da...
14:35:52 <ray> how do you get 3536 followers
14:35:56 <ray> assuming they are not spambots
14:35:57 <copumpkin> http://haskell.org/haskellwiki/Twitter
14:35:59 <copumpkin> lol
14:36:11 <copumpkin> ray: a bunch of iphone fanboys :P
14:36:18 <Berengal> > let (\/\/\/\/\/\/) = (++).(++"://www."); http = "http" in http \/\/\/\/\/\/ "example.com"
14:36:20 <lambdabot>   "http://www.example.com"
14:36:30 <copumpkin> awesome!
14:36:33 <copumpkin> we have a URL combinator now!
14:36:37 <jeffwheeler> > let (‚äª) = xor in 4 ‚äª 3
14:36:39 <lambdabot>   Add a type signature
14:36:45 <jeffwheeler> > let (‚äª) = xor in 4 ‚äª 3 :: Int
14:36:47 <lambdabot>   7
14:36:55 <beutdeuce> BMeph, why have a separate function called zipWith when one could define map taking 3 parameters, if the last isnt provided, default to the map it is now
14:37:03 <Badger> The whitespace combinator :D
14:37:09 <Cale> beutdeuce: What type would it have?
14:37:20 <copumpkin> beutdeuce: because we don't do functions that take variable numbers of arguments without great hackery
14:37:36 <beutdeuce> copumpkin, not variable
14:37:40 <Berengal> The bad kind of hackery
14:38:00 <copumpkin> beutdeuce: it's a single function that takes different numbers of arguments
14:38:21 <jeffwheeler> > let (‚Äâ) = (++) in "http://"‚Äâ"www."‚Äâ"google.com"
14:38:21 <bgs100> @quote
14:38:21 <lambdabot> arrogance says: I'm not arrogant. I'm just better than you in every way possible!
14:38:23 <lambdabot>   Couldn't match expected type `()'
14:38:23 <beutdeuce> Cale, map :: (a -> b) -> [a] -> [a] -> [b] ?
14:38:33 <Gracenotes> this is the best ktty combinator I have been able to discover
14:38:36 <Gracenotes> > let (__,(^==),(==^))= (5,(+),(*)) in 7 ==^__^== 7
14:38:38 <lambdabot>   42
14:38:45 <beutdeuce> or rather
14:38:45 <copumpkin> beutdeuce: that doesn't really work
14:39:02 <Cale> er, if that's the case, what does it do?
14:39:05 <beutdeuce> map :: (a->b->c) -> [a] -> [b] -> [c]
14:39:07 <ray> let cheezburger = ...
14:39:11 <Cale> :t zipWith
14:39:12 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:39:18 <beutdeuce> wait...
14:39:18 <Cale> beutdeuce: That's the type of zipWith
14:39:21 <copumpkin> lol
14:39:33 <beutdeuce> lol, nvm, that i was getting a type of the wrong function
14:39:38 <beutdeuce> then*
14:39:39 <jmcarthur> beutdeuce: also, liftA2
14:39:56 <jmcarthur> beutdeuce: with ZipList, it's the same as zipWith
14:40:04 <beutdeuce> :t ZipList
14:40:06 <lambdabot> forall a. [a] -> ZipList a
14:40:16 <beutdeuce> so, ZipList is a wrapper?
14:40:20 <copumpkin> yup
14:40:21 <jmcarthur> yeah
14:40:33 <copumpkin> it just allows us to use a different instance for the same thing
14:40:35 <beutdeuce> great, more monadic paradigms o.0
14:40:46 <jmcarthur> > getZipList $ liftA2 (+) (ZipList [1,2,3]) (ZipList [5,3,2])
14:40:47 <lambdabot>   [6,5,5]
14:40:52 <jmcarthur> applicative, actually
14:40:55 <Berengal> Not even monadic, applicative
14:40:57 <jmcarthur> ZipList is not a monad
14:40:58 <copumpkin> it's a bit like how we have Sum and Product wrapper types
14:41:07 <beutdeuce> jmcarthur, yes, but why when there isnt a need?
14:41:16 <Cale> zipping actually isn't as common as picking combinations, so the default instance does all combinations
14:41:21 <jmcarthur> beutdeuce: "need"?
14:41:21 <copumpkin> ray: why is drong not a cat?
14:41:33 <Cale> > liftA2 (+) [1,2,3] [40,50]
14:41:34 <lambdabot>   [41,51,42,52,43,53]
14:41:36 <ray> he thinks he's a cat :P
14:41:41 <beutdeuce> Why work in a sub-context when one could just worry about one general context?
14:41:55 <beutdeuce> or rather, should worry
14:41:58 <jmcarthur> beutdeuce: exactly, why use zipWith when you could just use liftA2?
14:41:59 <jmcarthur> ;)
14:42:14 <beutdeuce> well, thats more of a hack
14:42:17 <jmcarthur> :t zipWith (+)
14:42:17 <ray> why use liftAn when you could just use <$> and <*>?
14:42:18 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
14:42:21 <jmcarthur> :t liftA2 (+)
14:42:22 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> f a -> f a
14:42:50 <beutdeuce> exactly, it lifts from sub-context to context...asking the question now, why have a sub-context?
14:42:50 <jmcarthur> ray: for partial application
14:42:53 <Berengal> I never really got the lift[A/M]n functions...
14:43:02 <copumpkin> why not?
14:43:03 <ray> i prefer liftAn, that's just rhetorical
14:43:16 <beutdeuce> copumpkin, introduces need for working in sub-contexts
14:43:19 <ray> :t liftA2 (*) abs signum
14:43:21 <lambdabot> forall a. (Num a) => a -> a
14:43:26 <copumpkin> beutdeuce: I don't know what you mean by that
14:43:27 <jmcarthur> beutdeuce: i don't understand your objection
14:43:36 <ray> > liftA2 (*) abs signum -45
14:43:37 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
14:43:38 <lambdabot>    arising from the literal `45' at ...
14:43:39 <beutdeuce> ok, let me rephrase
14:43:42 <ray> g a h
14:43:44 <Berengal> I've always used fmap and ap...
14:43:53 <ray> it's just id anyway
14:43:58 <copumpkin> Berengal: then you introduce an additional constraint
14:44:11 <Berengal> copumpkin: Okay, liftM and ap then
14:44:20 <jmcarthur> Berengal: you still are requiring Monad there
14:44:23 <ray> <$> and <*> :P
14:44:28 <jmcarthur> vs. just Applicative
14:44:30 <Berengal> jmcarthur: and liftMn doesn't?
14:44:36 <copumpkin> it does
14:44:38 <jmcarthur> Berengal: liftA doesn't
14:44:48 <jmcarthur> Applicative is more general than Monad
14:44:53 <Berengal> Applicative is a functor anyway
14:45:00 <copumpkin> so is monad :P
14:45:02 <jmcarthur> it's less general than Functor
14:45:06 <beutdeuce> Lets say there is a type Int (which there is). Instead of keeping the context under all general types (such as Int, Fraction, Double...) when handling input/output, a wrapper (IO) is created, so now we have IO Int. Now, we need to write functions that worry about the sub-context (IO), instead of directly worrying with the Int
14:45:10 <copumpkin> that doesn't mean haskell knows that hough
14:45:12 <copumpkin> though
14:45:19 <ray> shh, don't tell it
14:45:23 <Berengal> jmcarthur: Yeah, but we're talking about function application inside functors, which is applicative
14:45:25 <ray> or we'll all be out of a job writing instances
14:45:33 <Cale> IO isn't just a wrapper...
14:45:39 <jmcarthur> Berengal: then why force it to be a monad?
14:45:53 <jmcarthur> that's an unnecessary constraint
14:46:07 <copumpkin> > mconcat . map Product $ [1..10]
14:46:09 <beutdeuce> Cale, yes, it isnt just, but still is partially considered
14:46:09 <lambdabot>   Product {getProduct = 3628800}
14:46:22 <Berengal> jmcarthur: I was uttering my preference for liftM and ap/ <$> and <*> over liftMn/liftAn
14:46:23 <Cale> beutdeuce: I don't think I understand your question at all.
14:46:26 <jmcarthur> beutdeuce: don't consider IO, consider monads
14:46:39 <Berengal> jmcarthur: I said nothing about forcing it to be a monad
14:46:40 <jmcarthur> Berengal: they don't have the same types, is all i mean
14:46:43 <copumpkin> beutdeuce: your objection is to having type constructors that "wrap" a type?
14:46:48 <beutdeuce> Cale, yes, like jmcarthur said, replace IO with a monad
14:47:03 <Cale> beutdeuce: What's a context?
14:47:14 <jmcarthur> beutdeuce: monads are as general as possible for these sort of things... i really don't get your objection
14:47:23 <Berengal> jmcarthur: Yes they do. liftM and ap only requires Monad, liftMn requires Monad too. Same for the applicatives
14:47:41 <beutdeuce> Cale, supposed Int is the general context. IO Int would be a sub-context
14:47:57 <copumpkin> I think the confusion is that we have another definition for context
14:48:17 <beutdeuce> Cale, the programmer doesnt need to be in the IO context when he is worrying about the Int
14:48:39 <jmcarthur> Berengal: consider if our libraries didn't suck and we had class Applicative m => Monad m where ...
14:48:46 <BMeph> beutdeuce: Yeah, what copumpkin said. For example, Maybe Int as a "sub-context" sounds odd. Well, it does to me. :)
14:48:57 <jmcarthur> Berengal: that's what was *should* have. having the monad constraint should be unnecessary if you are just using ap
14:49:02 <Cale> beutdeuce: IO Int and Int are totally separate types
14:49:05 <jmcarthur> Monad is an unnecessary constraint
14:49:11 <jmcarthur> for example, you can't use ZipList with ap
14:49:15 <jmcarthur> because it's not a Monad
14:49:16 <Berengal> jmcarthur: Then I'd use (<*>)
14:49:23 <jmcarthur> why the distinction?
14:49:25 <beutdeuce> Cale, yes, but the value the programmer wants to work with is the same
14:49:32 <jmcarthur> why not just always use the general one?
14:49:33 <Berengal> jmcarthur: What I wouldn't use is liftAn
14:49:42 <Cale> an IO Int is a value which is not at all anything like an Int
14:50:00 <copumpkin> beutdeuce: do you feel the same way about [] Int?
14:50:04 <beutdeuce> Cale, indeed, but when i am reading an Int from a file, i want it to be Int, not IO Int
14:50:12 <copumpkin> where [] is an additional "context" ?
14:50:20 <jmcarthur> beutdeuce: but it's not an Int...
14:50:21 <beutdeuce> copumpkin, u could say
14:50:27 <copumpkin> beutdeuce: except it's a bunch of ints
14:50:34 <Cale> The Int that you read is an Int, the process of reading it from a file is an IO Int
14:50:46 <copumpkin> beutdeuce: the programmer wants to work with a single Int, but [] Int is lots of them (being [Int])
14:50:57 <copumpkin> (or none)
14:51:02 <Berengal> jmcarthur: I frequently use applicatives, even when I'm working with a specific monad. That's not what's at issue here
14:51:03 <beutdeuce> jmcarthur, yes, its an IO Int. BUT, IO should be a buffer, not a type, so it WOULD be an Int, not an IO Int
14:51:14 <Cale> huh?
14:51:17 <Cale> buffer?
14:52:02 <beutdeuce> Cale, buffer as in something that retrieves and returns
14:52:06 <Axman6> beutdeuce: you have a lot to learn young padawan
14:52:09 <Cale> I don't understand. A value of type IO Int is a description of some stuff to do in order to produce an Int. You might think of it as the source code of a program which could be compiled and run to produce an Int.
14:52:09 <Axman6> :)
14:52:13 <copumpkin> beutdeuce: IO Int = A computation of some sort that produces an Int, not necessarily from disk or network or anything.
14:52:25 <copumpkin> beutdeuce: [] Int = A computation that produces 0 or more Int values
14:52:38 <Cale> [] Int is the same as [Int], by the way
14:52:48 <copumpkin> yes, I'm just trying to draw the analogy of the f Int
14:52:49 <copumpkin> :P
14:53:20 <BMeph> beutdeuce: Likewise, "Maybe Int" is a computation that produces 0 or 1 Int(s).
14:53:23 <Cale> beutdeuce: So, how is IO Int not a type?
14:53:39 <Cale> IO itself is a type constructor, is that what you're talking about?
14:53:41 <Axman6> it is a type, i've _seen_ it!
14:53:50 <beutdeuce> the other day, i had an assignment to read a list of lists from a file and work with it. I found out that i was not able to work with it directly, rather i needed to apply functions that work in the sub-context it was in, for the list of lists i read from a file didn't have a type of a list of lists
14:54:03 <Cale> beutdeuce: hm?
14:54:08 <pikhq> (Monad m) => m a -- this is a type for all m and a. :)
14:54:35 <Cale> do xs <- readFile "foo.txt"; ... xs is a String here and you can do anything you can do to a String ...
14:55:04 <pikhq> Including, (inexplicable as it may be) return xs
14:55:06 <pikhq> :P
14:55:12 <BMeph> beutdeuce: I _almost_ think you're thinking in reverse; if anything, "Int" is a sub-context of "IO Int", not the reverse. :)
14:55:50 <Berengal> Int, being the same as Identity Int, is at least less general than (Monad m) => m Int
14:55:53 * BMeph wags a finger at pikhq for being "naughty"...
14:56:18 <copumpkin> @src Identity
14:56:19 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
14:56:46 <beutdeuce> BMeph, perhaps
14:56:49 * BMeph thinks it's time for another episode of "All your Haskell are belong to Cale"... ;)
14:57:00 <hackagebot> stream-fusion 0.1.2.2 - Faster Haskell lists using stream fusion (DonaldStewart)
14:57:00 <hackagebot> cautious-file 0.1.1 - Ways to write a file cautiously, to reduce the chances of problems such as data loss due to crashes or power failures (RobinGreen)
14:57:13 <copumpkin> :o
14:57:17 <copumpkin> a new stream-fusion version :o
14:57:35 <beutdeuce> what does this mean, (Monad m) => m Int
14:57:43 <BMeph> copumpkin: "The crowd goes wild"? ;)
14:57:52 <beutdeuce> Monad being any wrapper?
14:57:55 <copumpkin> for any one-parameter type constructor m that is an instance of Monad, the type m Int :P
14:58:19 <copumpkin> so m could be IO, [], Maybe, and a variety of other ones
14:58:29 <Cale> beutdeuce: A value of that type is a polymorphic value which for any monad m, can have type m Int
14:58:53 <Cale> beutdeuce: A monad is a type constructor which supports a given set of operations (specifically, return and >>=)
14:59:02 <copumpkin> beutdeuce: incidentally, that (Monad m) bit is what we typically call context in haskell, although there can be more than one constraint of that sort
14:59:57 <defun> has anyone made a haskell virtual machine? Or is it possible to use pure haskell (i.e. no ffi) to create virtual machine to (for example) virtualize an OS. Or is purity/laziness getting in the way. BTW, I have no idea how VMs are made, but I do find them fascinating.
15:00:02 <Cale> :t return (5 :: Int)
15:00:03 <lambdabot> forall (m :: * -> *). (Monad m) => m Int
15:00:12 <beutdeuce> i see
15:00:13 <Cale> > return (5 :: Int) :: [Int]
15:00:14 <lambdabot>   [5]
15:00:15 <beutdeuce> * ->
15:00:17 <beutdeuce> *
15:00:18 <beutdeuce> ?
15:00:20 <Cale> > return (5 :: Int) :: Maybe Int
15:00:21 <lambdabot>   Just 5
15:00:28 <copumpkin> beutdeuce: that's a bit like a function but for types
15:00:34 <copumpkin> it's called a kind signature
15:00:35 <dons> ?yow
15:00:36 <lambdabot> I feel like I'm in a Toilet Bowl with a thumbtack in my forehead!!
15:00:39 <dons> yikes
15:00:39 <Axman6> defun: to make a fast VM, you'd probably want something low level and hacky... like CPU's (so C or something)
15:00:54 <Cale> beutdeuce: Yeah, ignore that bit, basically it's just saying explicitly that m is something which takes a type and gives another type.
15:01:04 <dons> defun: people have written hypervisors and vms in haskell
15:01:08 <dons> and kernels
15:01:15 <defun> Cool!
15:01:20 <beutdeuce> Cale, could return same type? or absolutely returns a different type?
15:01:25 <copumpkin> any type
15:01:27 <dons> laziness, purity et al are just things in the langauge to use or not use, as you see fit.
15:01:31 <Axman6> defun: i hear you're after some more vegemite
15:01:33 <copumpkin> probably not the same type :)
15:01:35 <dons> Axman6: that's right
15:01:38 <Axman6> uh, dons even
15:01:39 <pikhq> defun: It is theoretically possibly, but not very practical.
15:01:39 <copumpkin> lol
15:01:48 <pikhq> (Haskell is Turing-complete)
15:01:51 <dons> pikhq: ?
15:02:02 <pikhq> s/possibly/possible/
15:02:17 <defun> Axman6: vegemite?
15:02:29 * copumpkin loves vegemite
15:02:30 <dons> pikhq: not sure what you meant by "not very practical"
15:02:38 <copumpkin> but /me also loves marmite, oh the conflict
15:02:45 <Badger> mix them!
15:02:47 <Cale> beutdeuce: Usually not the same type, but there are some cases where that happens using GHC extensions.
15:02:49 <Axman6> dons: they've brought out a new vegemite that's mixed woith cream cheese (i think). it's pretty nice actually. they're looking for a name for it
15:02:56 <dons> scary
15:03:03 <defun> ?vegemite
15:03:03 <lambdabot> Unknown command, try @list
15:03:04 <copumpkin> creamcheesymite
15:03:27 <pikhq> dons: A hacky C VM will probably be much better.
15:03:29 * beutdeuce is switching back to a more usable computer
15:03:30 <dons> long term virtualization and kernel projects, http://web.cecs.pdx.edu/~kennyg/house/
15:03:37 <dons> pikhq: but we can verify the haskell one :)
15:03:43 <dons> pikhq: practical for verification
15:04:12 <pikhq> Because VMs tend to be done quick by the horrid hack of compiling just in time and then executing that.
15:04:13 <defun> what does vegemite have to do with any of this?
15:04:24 <BMeph> copumpkin: Hmm, cheesymite sounds like an option - quick, trademark it! ;)
15:04:27 <pikhq> defun: Yeast.
15:04:32 <Badger> Haskell is powered by vegemite.
15:05:05 <Axman6> pikhq: NICTA, the commercial arm of ANU and UNSW here has written an L4 microkernel in haskell, which they've proved correct, and are then translating it to C for better forperformance
15:05:23 <defun> I am quite perplexed by this...
15:05:30 <dons> yeah, there's a few projects on extraction of C from verified Haskell.
15:05:59 <pikhq> Axman6: !!!
15:06:02 <Axman6> pikhq: NICTA, the commercial arm of ANU and UNSW here has written an L4 microkernel in haskell, which they've proved correct, and are then translating it to C for better forperformanceL4.Verified i think it was called
15:06:07 * Axman6 hopes to either end up at NICTA orlecturing at ANU
15:06:16 <beutdeuce> how does Maybe and Just work?
15:06:23 <dons> ?src Maybe
15:06:24 <lambdabot> data Maybe a = Nothing | Just a
15:06:25 <p_l> Axman6: AFAIK the one they deployed was fork of L4::Pistachio, L4.secure was separate project
15:06:34 <pikhq> @src Maybe >>=
15:06:34 <lambdabot> Source not found.
15:06:42 <dons> its a data type, that holds an 'a'. It's values can be a Nothing, or a box Just containing a
15:06:45 <Axman6> argh, my network's being rerally fucked atm, i'm getting lassive lag to the server that's just next door >_<
15:06:47 <beutdeuce> @src Maybe (>>=)
15:06:47 <lambdabot> (Just x) >>= k      = k x
15:06:48 <lambdabot> Nothing  >>= _      = Nothing
15:06:49 <pikhq> Really? I though that was trivial to define.
15:06:54 <pikhq> XD
15:07:15 <pikhq> beutdeuce: That's how the monad instance works. works.
15:07:19 <pikhq> Well, also,
15:07:23 <pikhq> @src Maybe just
15:07:24 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:07:30 <p_l> Axman6: The Haskell-based L4 variant was for research, the one used on ARM is L4::Pistachio with long history of patches
15:07:34 <pikhq> @src Maybe return -- XD
15:07:35 <lambdabot> Source not found.
15:07:37 <jeffwheeler> @hoogle on
15:07:38 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
15:07:39 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
15:07:39 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
15:07:40 <pikhq> @src Maybe return
15:07:41 <lambdabot> return              = Just
15:07:41 <pikhq> -- No comments
15:07:53 <defun> so what does yeast have to do with haskell?
15:07:58 <beutdeuce> > Maybe 1
15:07:59 <lambdabot>   Not in scope: data constructor `Maybe'
15:08:03 <Badger> > Just 1
15:08:04 <lambdabot>   Just 1
15:08:11 <copumpkin> defun: cause the *mites are yummy
15:08:12 <pikhq> beutdeuce: Maybe is not the data constructor, Just is.
15:08:19 <dons> yeast is like the K combinator for the animal kingdom
15:08:28 <Badger> :t Just 1
15:08:30 <lambdabot> forall t. (Num t) => Maybe t
15:08:58 <beutdeuce> so, there can be a time when i do Just 1, and it will return Nothing?
15:09:08 <pikhq> No.
15:09:11 <dons> > Just 1 == Nothing
15:09:13 <Axman6> "do Just 1"?
15:09:13 <lambdabot>   False
15:09:26 <Axman6> :t lookup
15:09:27 <pikhq> > do Just 1
15:09:27 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:09:29 <lambdabot>   Just 1
15:09:41 <beutdeuce> But Maybe says that it could be just that, or nothing
15:09:58 <Axman6> > lookup 7 (zip [1..10] ['a..]]
15:10:00 <lambdabot>   <no location info>:
15:10:00 <lambdabot>      lexical error in string/character literal at chara...
15:10:01 <beutdeuce> if its never nothing, why have a maybe?
15:10:09 <Axman6> > lookup 7 (zip [1..10] ['a..])
15:10:11 <pikhq> No, Maybe says that it could be either *a number* or nothing.
15:10:12 <lambdabot>   <no location info>:
15:10:12 <lambdabot>      lexical error in string/character literal at chara...
15:10:26 <pikhq> Specifically, that the *type* is either a number or nothing.
15:10:26 <Axman6> > lookup 7 (zip [1..10] ['a'..])
15:10:28 <lambdabot>   Just 'g'
15:10:31 <Axman6> >_<
15:10:31 <beutdeuce> > Just "Hello"
15:10:33 <lambdabot>   Just "Hello"
15:10:40 <Axman6> > lookup 17 (zip [1..10] ['a'..])
15:10:42 <lambdabot>   Nothing
15:11:14 <beutdeuce> > lookup 5 [1..5]
15:11:15 <lambdabot>   No instance for (GHC.Enum.Enum (t, b))
15:11:16 <lambdabot>    arising from the arithmetic seque...
15:11:17 <Axman6> beutdeuce: Maybe is used to represent a something that can fail to return a result
15:11:23 <pikhq> do x <- foo; y <- bar; return $ x + y -- will return Nothing if foo or bar returned nothing, otherwise, will return Just x + y
15:11:43 <beutdeuce> Axman6: oh
15:11:45 <beutdeuce> k
15:11:56 <Axman6> and since lookup is a function that can fail to find the value you're looking for, it returns a Maybe b
15:12:10 <pikhq> It's (*VAGUELY*) like exceptions.
15:12:18 <Badger> :t lookup
15:12:20 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:12:23 <Axman6> and i've got to get going. later all
15:12:26 <cschneid> is there an eclipse equivalent for haskell that provides all the type hinting, auto-complition, etc for early detection of errors?
15:12:33 <Badger> @src lookup
15:12:33 <lambdabot> lookup _key []          =  Nothing
15:12:33 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
15:12:33 <lambdabot>                         | otherwise = lookup key xys
15:12:38 <pikhq> cschneid: Emacs
15:12:39 * Axman6 starts another semester at ANU
15:13:19 <cschneid> pikhq: :( I'm used to vim. But yeah, was wondering about that, seems like haskell would benefit a ton from incremental compilation and inline function docs
15:13:46 <pikhq> cschneid: Haskell benefits from though.
15:13:57 <pikhq> What you suggest is not-thought.
15:14:18 <dons> cschneid: EclipseFP and Leksah
15:14:23 <pikhq> s/though./thought./
15:14:34 <copumpkin> having incremental compilation is nice
15:14:48 <copumpkin> I advocate thought but only for things that we're better at the computer than doing
15:14:55 <copumpkin> and figuring out syntax errors isn't something we're that good at :P
15:15:12 <beutdeuce> How do you pronounce Haskell? Emphasis on the 'a' or the 'e'?
15:15:46 * BMeph says it "HASS-kull"
15:16:03 <Philippa> "no, not Pascal, Haskell!"
15:16:42 <Badger> hask-L
15:17:24 <birdspider> hi, anyone who can point out a tutorial on hslogger ? I'm having difficulties setting up 2 different loggers
15:19:43 <benmachine> Philippa: I have that problem :(
15:20:05 <mike-burns> cschneid: Make sure you're using http://www.vim.org/scripts/script.php?script_id=2062 before you switch to emacs.
15:20:20 <cschneid> thanks
15:20:46 <Berengal> Everyone I've talked to in person first thought I meant Pascal. The weird looks I've gotten...
15:21:00 <mike-burns> "Haskell with a 'h'" is what I say.
15:21:34 <Cale> beutdeuce: I pronounce it like haskl
15:21:37 <jmcarthur> rhymes with rascal
15:21:37 <mike-burns> ("... 'Phascal'?" is the typical response.)
15:22:07 <jmcarthur> Berengal: i share the same experience
15:22:28 <benmachine> I tend to say haskle but I think hask-L is probably better
15:22:44 <jmcarthur> "You program in Pascal? Intentionally?!" "No, *Haskell*." "Oh, never heard of it."
15:23:07 <Berengal> jmcarthur: That, repeatedly
15:23:23 <dons> jmcarthur: I had that happen last week. Was weird.
15:23:25 <Cale> The way that I pronounce Haskell tends to produce a little less of that.
15:23:37 <beutdeuce> :)
15:23:39 <dons> Wish I had pocket-sized RWH copies to give out ot people
15:23:41 <Cale> At least, unless the room is noisy.
15:23:46 <jmcarthur> dons: exactly!
15:24:06 <dons> iphone app version is about the closest equiv.
15:24:09 <jmcarthur> we need obviously handouts
15:24:49 <dons> we need to go door-to-door asking if people have heard the good news (about multicore programming with STM!)
15:24:52 <copumpkin> is the iphone app version complete?
15:24:57 <dons> copumpkin: yeah.
15:24:57 <copumpkin> I mean, the entire book?
15:24:59 <copumpkin> ah cool
15:25:37 * beutdeuce wonders why operating systems are continuing to be developed in imperative languages when functional ones seem to be more robust
15:25:44 <Berengal> I figure I just have to develop a killer app...
15:26:05 <dons> http://web.cecs.pdx.edu/~kennyg/house/ also still being developed in functional languages with strong types
15:26:12 <Philippa> beutdeuce: adequate FPLs for low-level programming are still an ongoing effort
15:26:38 <BMeph> That happened to me Wednesday. I also accent the last syllable of Pascal, though, so I got the "never heard of it" pretty quick.
15:26:41 <Philippa> you can't really rely on the language having garbage collection when you're trying to write a kernel
15:26:44 <copumpkin> beutdeuce: also, most programmers consider academic an insult, and consider anything remotely functional to be academic
15:27:01 <BMeph> Followed by an hour of explaining how Haskell avoids buffer overrun exploits...
15:27:11 <beutdeuce> copumpkin: yes, i'ved noticed that trend
15:27:25 <jmcarthur> copumpkin: true :(
15:27:48 <pikhq> BMeph: What, by being higher-level than something with direct pointers? ;)
15:28:09 <dons> check the HASP project, http://hasp.cs.pdx.edu/ for a language + kernel + verification co-design project.
15:28:22 <dons> "We have openings for PhD students in 2009 and 2010"
15:28:34 <dons> a bunch of haskellers have moved to Portland to work on this too :)
15:28:41 <Philippa> yeah, I got an invite
15:29:01 <Philippa> not a particularly formal one, but still :-)
15:29:02 <pikhq> I find it highly amusing that Haskell is being used as a systems programming language.
15:29:13 <jmcarthur> dons: oh no, i'm being tempted
15:29:18 <pikhq> And not exactly upset. :)
15:29:23 <beutdeuce> dons: a new fpl? Why when Haskell isn't over yet?
15:29:27 <dons> pikhq: its not so funny, its all about the types + verification.
15:29:31 <BMeph> pikhq: Yes. It still leads to more of "But, how does it avoid having memory written over when it takes in the string?"...
15:29:45 <dons> beutdeuce: haskell variant, essentially, to better support the verification requirements and design of low level sytsems
15:30:01 <beutdeuce> dons: cool
15:30:20 <dons> haskell as-is has been used to write kernels multiple times. now the challenge is to make that super easy, and efficient, and easy to verify
15:30:45 <gwern> well, that doesn't sound difficult at all
15:30:49 <mike-burns> ... and on people's computers.
15:31:04 <Cale> mike-burns: On people's computers?
15:31:23 <mike-burns> A kernel is kinda useless, practically, if people aren't using it.
15:31:23 <Berengal> "You know how annoying null pointers are?" "Yeah" "Well, here's a language where you don't have that problem. There are no nulls!". "You know how annoying it is to find your variables have been overwritten in some remote part of the program?" "Yeah" "Well, here's a language where you don't have that problem. There are no variables!". "You know how annoying buffer overruns are?" "Yeah" "Well, here's a language where you don't have that problem. T
15:31:37 <Philippa> dons: hrmm, I wasn't aware of that as opposed to eg RTS-as-linux-kernel-module. I imagine the haskell implementations involved are somewhat specialist?
15:31:57 <dons> I think everyone's just using the GHC Rts
15:32:00 <Cale> mike-burns: Ah, I think the expectation that anything written will probably fill some niche anyway.
15:32:04 <dons> the bare metal variant's been around for a while
15:32:40 <Philippa> interesting, I think I missed the bare metal variant outright
15:32:46 <kpreid> Berengal: Your message was truncated within the reply to "buffer overruns"
15:32:47 <pikhq> dons: Funny as in "Huh, that's odd" not as in "Huh, that's hilarious that they think they can do that".
15:32:53 <mike-burns> I've had a dream of doing an API-compatible re-write of BSD for a while. But I'm not even close to qualified, nor do I have the time.
15:32:58 <pikhq> I'm actually glad that they're doing it.
15:33:01 <disgrntld> Reading a tutorial.. I'm stumped on how "Map k" is made an instance of Functor? I guess I don't understand how to recurse on Maps. Can someone explain please?
15:33:06 <Philippa> though I guess in one sense it's not too surprising
15:33:37 * BMeph waits with baited breath to see how Berengal finishes that "here's a language" section
15:34:06 <Berengal> BMeph: "Well, here's a language where you don't have that problem. There are no buffers!"
15:34:23 <Berengal> Surprising, I know
15:34:29 <Cale> disgrntld: It depends on the actual Map representation and is internal to the Data.Map library.
15:34:46 <Cale> disgrntld: Is it asking you to write the instance somehow?
15:35:02 <Cale> Or is this a different Map type?
15:35:52 * gwern waves away BMeph's fishy breath
15:37:09 <disgrntld> Cale: I suppose this is asking me to try and emulate making Data.Map an instance of Functor.. So how they did it internally
15:37:17 <disgrntld> http://pastebin.com/m2d11f475
15:37:37 <Cale> disgrntld: That's hard.
15:37:38 <disgrntld> ..is what I came up with before I got stuck
15:38:12 <disgrntld> Cale: ok, is it because the internal structure of Data.Map isn't exposed?
15:38:13 <Cale> disgrntld: I suppose you can do it in terms of toAscList and fromDistinctAscList
15:38:37 <Cale> disgrntld: also, you can't pattern match like that
15:38:46 <disgrntld> Cale: perfect, that's the path I was leaning down which clearly isn't that pretty
15:38:47 <Cale> Data.Map.empty is not a data constructor
15:39:03 <Cale> disgrntld: Really, the tutorial shouldn't ask you a question like that.
15:39:18 <Berengal> Wouldn't fromList . map (second f) . toList do it?
15:39:33 <Cale> It's not really possible to do it the way that they did it internally without having the constructors for Data.Map.Map which are not exported from the module.
15:39:50 <disgrntld> Cale: cool, I was hoping it was more of a theoretical quesiton than practical
15:40:03 <Cale> Berengal: No, because that incurs an Ord context which means that it doesn't match fmap's type.
15:40:18 <disgrntld> Cale: thanks!
15:40:19 <Berengal> Cale: Ah, true
15:40:35 <Cale> disgrntld: If you just want to know what it does, it just applies the given function to all the elements in the Map (not the keys)
15:41:37 <Cale> The current Data.Map has fromDistinctAscList which goes ahead and builds a balanced tree under the assumption that the elements of the list are distinct and ascending.
15:41:50 <Cale> (and doesn't use Ord to check)
15:42:22 <BMeph> disgrntld: Personally, I'd just say "fmap = map". Then, leer obnoxiously. ;)
15:43:04 <Cale> But this is not quite as efficient as just copying the existing structure which is what the map function in Data.Map does.
15:44:48 <disgrntld> Cale: awesome, I knew it was a tree and didn't see any interface to iterate over it, so I was scratching my head..
15:46:06 <disgrntld> haha BMeph, if this was for class I would try that..
15:46:13 <Cale> disgrntld: Well, the interface to iterate over it consists of stuff like map, and things like mapAccumWithKey, etc.
15:46:44 <Cale> (and Data.Traversable, Data.Foldable)
15:47:23 <disgrntld> but those aren't Value Constructors?
15:47:37 <disgrntld> *Cale: but those aren't Value Constructors?
15:48:01 <Cale> disgrntld: Data constructors all start with uppercase letters.
15:48:38 <Cale> In Map's case, the data constructors are Tip and Bin and they're not exported.
15:48:53 <disgrntld> Cale: ok, that makes sense
15:49:13 <Cale> though, empty is exported, and empty = Tip, you still can't pattern match on it.
15:49:19 <disgrntld> Cale: how'd you know about Tip and Bin if they're not exported?
15:49:39 <Cale> disgrntld: By reading the source code :)
15:49:44 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map.html#Map
15:49:53 <disgrntld> XD cool
15:49:58 <Cale> disgrntld: There are links to it from the documentation for the module.
15:50:08 <Cale> (over on the far right)
15:50:28 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#t%3AMap -- (I clicked on the Source link from here)
15:51:09 <disgrntld> Cale: perusing now
15:51:22 <balor> How can I get cabal to run happy as part of a library build?
15:52:26 <xenoblitz> can anyone point me to a website which describes the use of the @ operator? thanks
15:52:37 <mike-burns> :t (@)
15:52:40 <lambdabot> parse error on input `@'
15:52:41 <mauke> @ is not an operator
15:53:04 <xenoblitz> mauke: donno what it is called exactly
15:53:40 <pikhq> Pure syntax.
15:54:00 <pikhq> @xs(x:_) -- xs is the whole list, x is the first element of xs
15:54:01 <lambdabot> Unknown command, try @list
15:54:06 <pikhq> (in a pattern match)
15:54:11 <BMeph> @where report
15:54:11 <lambdabot> http://www.haskell.org/onlinereport/
15:54:20 <BMeph> xenoblitz: ^^
15:54:40 <Berengal> pikhq: Mixed up the order there. It's xs@(x:_)
15:55:20 <xenoblitz> thanks people, so its related to pattern matching
15:55:22 <xenoblitz> thanks
15:55:31 <ClaudiusMaximus> http://www.haskell.org/onlinereport/exps.html#sect3.17.1 as-pattern
15:56:05 <BMeph> Thanks, ClaudiusMaximus, I was just about to post that. :)
15:56:15 <xenoblitz> thanks to all :)
15:56:43 <pikhq> Berengal: XD
15:58:57 <det> Does haskell support a generic "sequence" type class so you can do write a function that accepts any kind of sequence, list, array, etc ?
15:59:20 <det> I mean to say, is this implemented in the standard library or some common library ?
15:59:37 <dolio> Depends on what operations you want.
15:59:44 <mike-burns> det: Strictly speaking, no.
16:00:11 <det> Is there any reason why it hasnt been done?
16:00:11 <dolio> Most are likely to be Functors, Foldable and Traversable.
16:00:43 <det> those sounds like what I mean
16:01:02 <det> I am guessing Foldable is a MPTC ?
16:01:08 <dolio> Some are Monoids, too.
16:01:12 <dolio> No.
16:01:44 <dons> det: what operations? Foldable, Functor, Monoid, Traversable... :)
16:02:06 <det> something like SML getItem
16:02:45 <det> 'a collection -> 'a option
16:02:48 <BMeph> Pointed, then. ;)
16:03:22 <dolio> No, pointed is the other direction.
16:03:27 <det> How to write that in Haskell syntax? Collection(a) -> Option(a) ?
16:03:42 <dolio> Anyhow...
16:03:43 * BMeph knows it's not *really* Pointed, but it sounded funny at the time...
16:03:54 <pikhq> Write a Collection typeclass and make instances of it for what you need. :P
16:04:03 <dolio> :t Data.Foldable.foldr (const . Just) Nothing
16:04:05 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> Maybe a
16:04:14 <det> I am just curious of any caveats associated with such a type class
16:04:31 <det> Seems like a perfect application of type classes
16:04:37 <pikhq> For example, the Functor instance thereof would be fmap.
16:04:37 <det> odd that it isnt standard
16:04:57 <pikhq> (for those functors which contain more than one piece of data)
16:05:12 <Cale> det: standard in what sense?
16:05:18 <pikhq> det: The thing is, we deal with higher abstractions than that.
16:05:37 <dobblego> det, Functor is in Prelude -- can't get any more standard
16:05:42 <pikhq> We don't deal with "things that have a sequence of data", we deal with "things that have data".
16:05:42 <Plouj> why doesn't this work: $ runghc Setup build
16:05:42 <Plouj> <command line>:
16:05:42 <Plouj>     Could not find module `Setup':
16:05:42 <Plouj>       Use -v to see a list of the files searched for.
16:05:57 <dobblego> Plouj, Setup.hs or Setup.lhs
16:06:12 <Plouj> I don't have either
16:06:13 <Plouj> ...
16:06:16 <det> there are times when a fold abstraction is insufficient, and you need a getItem-style interface
16:06:28 <dolio> I just wrote getItem using fold.
16:06:32 <Plouj> I'm just following http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html#id601900
16:06:42 <pikhq> :t (!!)
16:06:44 <lambdabot> forall a. [a] -> Int -> a
16:06:52 <pikhq> That was totally going to be a C-k.
16:06:58 <pikhq> Not a C-j.
16:07:11 <det> I dont see how you can implement getItem in terms of fold
16:07:17 <dolio> :t Data.Foldable.foldr (const . Just) Nothing
16:07:17 <hackagebot> pugs-DrIFT 2.2.3.1 - DrIFT with pugs-specific rules. (AudreyTang)
16:07:19 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> Maybe a
16:07:24 <Philippa> det: how does getItem differ from a toList function in a lazy setting?
16:07:35 <det> Philippa, great point
16:07:57 <det> not at all
16:08:03 <BMeph> :t listToMaybe . toList
16:08:05 <lambdabot> Not in scope: `toList'
16:08:18 <BMeph> Bah. :p
16:08:24 <BMeph> :t listToMaybe . Data.Foldable.toList
16:08:26 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> Maybe a
16:08:46 <det> Laziness is probably my least favorite part of Haskell, though ;-)
16:08:54 <Cale> det: There are also problems with many types of operations in that in order to have efficient collections of many sorts, you need instances of things like Ord or Eq, and yet it would be presumptuous for a general collections class to assume that an instance of Ord is present in many cases.
16:08:55 <BMeph> But, since toList uses foldr, dolio's is more direct. :)
16:09:15 <dobblego> det, change that
16:09:16 <pikhq> det: ... Your *least* favorite?
16:09:26 * pikhq beats det with an infinite list
16:09:38 <Cale> Laziness is in my top 3 features of Haskell for sure.
16:09:48 <det> I'd really like a hybrid of ML and Haskell
16:09:48 <Cale> I can't stand programming without it.
16:10:03 <det> things like type classes are great
16:10:10 <Berengal> Thunking is hard. I'm glad I don't have to
16:10:13 <Philippa> mmm, it's intermittently useful for me - I have to admit, I've had cause to consider using ocaml instead for some of my projects lately
16:10:21 * BMeph points det in augustss' direction...for no apparent reason.
16:10:29 <Philippa> and type classes are more of a blocker than strictness
16:11:03 <Philippa> Cale: what's the current state of the art on predictable resource usage, btw?
16:11:06 <det> Cale, I'm trying to understand what you just said
16:11:12 <BMeph> Berengal: Actually, I'd like an "exposed" means for explicit thunking...oh wait, Futures do that already. ;)
16:11:22 <Cale> Philippa: For lazy functional programming?
16:11:32 <Philippa> Cale: yeah
16:11:39 <det> Cale, would a collection class need to expose the Ord/Eq ?
16:12:05 <Philippa> (so what I really mean is: what range of things can you predict it for, for given required accuracy?)
16:12:20 <Cale> Philippa: I'm not sure about research on it, but typically I have a pretty good idea of how my program is going to perform.
16:12:25 <det> Is there any example of a haskell type that isnt ordable ?
16:12:38 <dobblego> det, Int -> String
16:12:41 <Cale> det: Lots of them.
16:12:51 <det> arrow types maybe
16:12:51 <Philippa> Cale: *nod* - any refinements in your intuitions from stuff I remember a couple of years back?
16:12:54 <Cale> det: IO String
16:13:04 <Philippa> det: a -> b
16:13:15 <Philippa> (for any values thereof)
16:13:26 <benmachine> complex numbers also aren't orderable
16:13:33 <benmachine> well
16:13:44 <det> really, that sounds easy to order
16:13:56 <benmachine> you could define an ordering for them, but it'd be mathematically invalid
16:14:09 <Philippa> det: in a pure language, with no introspection?
16:14:10 <det> ordering just needs to be consistent
16:14:24 <Cale> Philippa: The main difference when thinking about asymptotic complexity is that it's not enough just to consider the input, but the access pattern on the output (usually for simplicity, it's enough to mind just the size of the consumed output)
16:14:48 <pikhq> forall a. IO a
16:14:51 <benmachine> det: ordering needs to be consistent, sure, but that doesn't mean that anything consistent can be an ordering
16:14:54 <Philippa> Cale: yeah, I knew that much :-)
16:15:04 <det> I also find it kind of strange that Haskell claims to be so pure, when laziness is such an imperative thing
16:15:15 <pikhq> det: ... Laziness, an imperative thing?
16:15:16 <benmachine> how is laziness imperative?
16:15:22 <Cale> Philippa: I think it would be interesting to see complexity theory treated in that way more often.
16:15:22 <dobblego> det, laziness is most emphatically not an imperative thing
16:15:24 <Philippa> det: that's because the programmers're lazy and say 'lazy' instead of 'non-strict'
16:15:28 <pikhq> Laziness is nearly impossible to do in an imperative context.
16:15:43 <det> but haskell is more than just non-strict
16:15:57 <Philippa> det: actually no, the standard makes no further guarantees
16:15:58 <Cale> det: Actually, non-strict is all that Haskell is.
16:16:06 <det> it is memoizes
16:16:09 <det> I mean
16:16:09 <dschoepe_> Can someone recommend a library for 2D graphics besides HGL?
16:16:10 <Philippa> det: it's GHC that's lazy
16:16:11 <det> it memoizes
16:16:15 <det> which is imperative
16:16:18 <Cale> det: It doesn't memoise.
16:16:26 <Philippa> det: no, a valid haskell implementation can use call-by-name
16:16:29 <pikhq> And memoization isn't imperative, anyways.
16:16:51 <balor> How do I call cabal's ppHappy during configure?
16:16:52 <det> not using memoization would destroy the performance characteristics of many Haskell programs
16:16:53 <Philippa> pikhq: it's sure as hell operational, which looks suspiciously close
16:16:58 <Cale> det: ?
16:17:05 <Cale> det: What memoisation are you talking about?
16:17:09 <det> it would be like losing tail-call-optimization
16:17:14 <dcoutts> balor: it happens automagically
16:17:20 <Cale> det: Functions in GHC-Haskell are not memoised by default at all.
16:17:21 <pikhq> Philippa: Since Haskell is purely functional, memoization is merely an implementation detail.
16:17:25 <Philippa> Cale: I think someone's confusing memoisation with c-b-need
16:17:37 <balor> dcoutts: How?  Don't I have to tell it that I have a .y file somewhere?
16:17:41 <dobblego> det, TCO is an optimisation, memoisation is not
16:17:42 <det> maybe I am mixing up terms
16:17:51 <Cale> (if they were, then all your memory would be consumed in the blink of an eye, on average ;)
16:18:08 <det> I mean, how once you evaluate a function, further calls to that function use the already evaluated value
16:18:10 <balor> dcoutts: Like in extra-source-files or somewhere?
16:18:11 <Philippa> pikhq: wow, I never considered that, thanks!
16:18:15 <Cale> det: Perhaps you're thinking of sharing, which is different from memoisation.
16:18:24 <Cale> det: No, that doesn't happen.
16:18:55 <Philippa> det: all sharing in GHC is introduced via let or similar constructs
16:19:04 <Cale> If you have something like f x = x^2, and you apply f to 5, it doesn't store the result that f 5 = 25 anywhere.
16:19:16 <det> I mean
16:19:19 <dcoutts> balor: nope, if it finds a .y file for a module then it uses it, and puts it in the source tarball too.
16:19:21 <Cale> If it did, GC would be impossible and you'd run out of memory very rapidly.
16:19:31 <det> let x = calculatePrimesFromZeroTo 100
16:19:36 <balor> dcoutts: thanks.
16:19:42 <Cale> det: x isn't a function there.
16:19:48 <Philippa> Cale: det means that you still want an implementation that guarantees c-b-need when you want it, ala Scheme's TCO requirement
16:19:48 <Cale> ?
16:19:54 <xenoblitz> dschoepe_: try Gtk2hs
16:20:28 <det> the internals of laziness are inherently imperative there, If I understand correctly
16:20:33 <Cale> ?
16:20:46 <Philippa> they are. But laziness is only an operational requirement, not a denotational one
16:20:53 <det> isnt x internally a thunk before it is first inspected?
16:21:05 <Cale> graph reduction is functional, isn't it?
16:21:11 <lilac> det: haskell implementations are required to be non-strict. they are not required to be lazy in the way you mean.
16:21:14 <pikhq> Sure, but that's a mere implementation detail.
16:21:17 <Philippa> Cale: so's a State monad
16:21:24 <dschoepe_> xenoblitz: I'll check it out, thanks.
16:21:25 <BMeph> Some folks call memoization a "run-time optimization", though, just to quibble. ;)
16:21:35 <Cale> Philippa: I guess I don't understand what "inherently imperative" means.
16:21:49 <lilac> det: in your example, x + x is allowed to calculate the primes twice (or more even)
16:21:54 <Philippa> Cale: graph reduction only works with something akin to a mutable graph
16:22:04 <Cale> det: In Haskell, expressions are graphs, and evaluation reduces graphs to other graphs.
16:22:07 <Philippa> the value of 'akin to' varies, of course
16:22:21 <det> yes, aka non-strict
16:22:26 <det> but GHC uses laziness
16:22:29 <det> which shares results
16:22:35 <pikhq> Implementation detail.
16:22:39 <det> no way
16:22:44 <amz> Hrm, could it be that 12 years of C, C++, Java and other imperative languages have rendered my brain hardened against Haskell? :(
16:22:47 <Cale> det: In strict evaluation, you have that situation too, it's just that usually you reduce trees to other trees.
16:22:49 <pikhq> It changes no semantics.
16:22:51 <det> take for example "purly functional data structures"
16:22:53 <Philippa> det: GHC runs on physical hardware, it's going to look imperative somewhere
16:22:59 <det> those depend on laziness
16:23:03 <Cale> det: Since you always evaluate the leaves of the tree first.
16:23:06 <dobblego> amz, it's a very common condition -- I have no easy cure
16:23:07 <pikhq> Just how long it takes to execute arbitrary programs.
16:23:09 <mike-burns> amz: Nah, you're not that far gone yet.
16:23:48 <amz> at least it wasn't cobol, eh? ;)
16:23:56 <det> Philippa, of course, but Haskell is just using inherently imperative techniques to claim purely functional performance
16:23:58 <Cale> det: I *really* don't see what you mean by imperative. Do you mean that one graph is being replaced by another, and that makes it mutable? By that definition lambda calculus reduction is imperative.
16:24:15 <meanburrito920_> what is c-b-need?
16:24:22 <pikhq> meanburrito920_: Call-by-need
16:24:24 <det> I mean, x has an internal state
16:24:29 <Philippa> det: "purely functional performance"?
16:24:33 <Cale> det: huh?
16:24:37 <lilac> det: not denotationally, no
16:24:38 <Cale> det: No, it doesn't.
16:24:38 <pikhq> det: Wha?
16:24:48 <benmachine> x is just a name
16:24:49 <Philippa> that sounds like an oxymoron, set theoretic functions don't /have/ performance
16:25:03 <mike-burns> det: Are you confusing the underlying implementation with how we use it?
16:25:09 <det> and evaluating x in 1 place changes the performance characterstics of using x some other place
16:25:15 <Philippa> mike-burns: or indeed with its semantics
16:25:27 <mike-burns> Right.
16:25:39 <det> because x has internal state
16:25:41 <Philippa> det: okay, so your complaint is that evaluating pure functions in the physical world displays physical characteristics?
16:25:42 <det> aka imperative
16:25:45 <pikhq> mike-burns: He'd probably be interested in SSA, a functional technique used in the implementation of imperative languages. ;)
16:25:48 <Cale> det: It's observationally independent though. You evaluate x exactly once, and you can't tell which place you evaluated it first.
16:25:59 <Philippa> det: no, x doesn't
16:26:04 <lilac> det: haskell doesn't give any performance guarantees
16:26:17 <Philippa> the /implementation corresponding to x/ has performance characteristics, x itself does not
16:26:20 <lilac> det: therefore, it doesn't change the performance characteristics since they're undefined before and after
16:26:24 <det> to write practical programs, you need to know if laziness is happening
16:26:24 <Cale> det: The only thing you need to know is that it's evaluated at some point prior to the first time you pattern match on it, and the cost of evaluation is paid then.
16:26:50 <Cale> det: As opposed to plain outermost-first evaluation?
16:26:54 <Cale> det: Or what?
16:27:08 <det> what do you mean by outermost ?
16:27:21 * pikhq honestly wonders what's imperative about fibs = 0:1:zipWith (+) fibs (tail fibs)
16:27:25 <Cale> det: I mean you reduce the outermost reducible subexpression first.
16:27:26 <lilac> det: denotationally, x has no internal state. that internal state is used by the compiler is irrelevant to the meaning of your program.
16:27:32 <Philippa> det: so if you care about 'practical' you have some additional issues to consider, yes. This doesn't mean that one can't succesfully reason about things in a purely functional manner - just not about properties which clearly don't belong to a pure function itself
16:27:35 <det> Cale, you mean strict ?
16:27:45 <Cale> det: Strict evaluation is innermost-first.
16:28:05 <det> Philippa, but Haskell is a programming language, these things are important
16:28:07 <Philippa> this is just as true in a strict language as in a lazy one
16:28:29 <benmachine> what is the claim here?
16:28:33 <pikhq> det: I strongly suspect you're confused about what "imperative" means.
16:28:34 <Philippa> det: as has already been said, Haskell itself makes no guarantees. All performance concerns are left to specific implementations
16:28:36 <det> "practical" isnt a dirty word
16:28:39 <pikhq> benmachine: Haskell is imperative.
16:28:39 <Cale> det: Suppose we have a function double x = x + x
16:28:52 <Cale> det: and we go to reduce the expression double (double 5)
16:29:07 <Cale> under strict (innermost-first) evaluation, it goes like:
16:29:08 <SamB_XP_> det: yeah, but Haskell isn't practical
16:29:10 <Cale> double (double 5)
16:29:14 <Cale> -> double (5 + 5)
16:29:14 <SamB_XP_> implementations could be
16:29:16 <Cale> -> double 10
16:29:16 <det> benmachine, that Haskell uses imperative techniques to acheive certain performance characteristics (aka laziness)
16:29:18 <Cale> -> 10 + 10
16:29:19 <SamB_XP_> one would hope they were
16:29:19 <Cale> -> 20
16:29:25 <Cale> det: right?
16:29:43 <Philippa> det: Haskell uses no such techniques
16:29:49 <det> GHC then
16:29:55 <Philippa> det: Haskell implementations do, of necessity as they run on imperative hardware
16:30:03 <pikhq> GHC is not Haskell, but an implementation thereof.
16:30:03 <Cale> det: So, we're replacing expression trees with other expression trees, starting with the innermost reducible subexpressions we can find.
16:30:10 <Philippa> this does not mean that they do not succesfully implement the evaluation of pure functions
16:30:26 <benmachine> det: it seems to me that what is important about haskell's being a functional language is things like referential transparency, which are indisputable
16:30:27 <SamB_XP_> if you see unsafeInterleaveIO standardized, then maybe you can claim that ;-)
16:30:47 <Cale> det: does that make sense so far?
16:30:55 <Cale> det: (I realise lots of people are trying to talk to you ;)
16:30:58 <det> Cale, sorry, I will read now
16:31:25 <det> Cale, ok
16:31:38 <Cale> det: Now I'll do outermost-first evaluation
16:31:41 <Cale> double (double 5)
16:31:50 <Cale> -> (double 5) + (double 5)
16:31:58 <mike-burns> Right.
16:31:58 <Cale> -> (5 + 5) + (double 5)
16:32:01 <det> I understand strict vs non-strict
16:32:03 <Cale> -> 10 + (double 5)
16:32:06 <Cale> -> 10 + (5 + 5)
16:32:08 <Cale> -> 10 + 10
16:32:09 <Cale> -> 20
16:32:14 <det> I am talking about laziness as an optimization
16:32:24 <Cale> So, you can see that double 5 was evaluated twice there
16:32:28 <Philippa> det: then it has nothing to do with the purity of the language, does it?
16:32:35 * BMeph is now REALLY confused!
16:32:46 <Philippa> so long as laziness preserves the denotational semantics, the language is still purely functional
16:32:50 <Cale> as a result of x occuring twice in the body of double x = x + x
16:32:56 <det> Philippa, any serious Haskell program probably depends on its existence
16:33:05 <pikhq> BMeph: I *think* he's saying Haskell is imperative because... Common implementation techniques are imperative?
16:33:07 <pikhq> det: No.
16:33:16 <Philippa> det: I've written plenty that don't
16:33:24 <Cale> det: So lazy evaluation *does* make an optimisation to this process, however, I think you misunderstand (possibly) what that optimisation is
16:33:30 <Philippa> additionally: even if it did at an operational level, it /still/ denotes a pure function
16:33:53 <BMeph> pikhq: No, he's saying that lazyness depends on being imperative...I think. :\
16:33:53 <det> but it changes the big o
16:34:08 <Philippa> so? Pure functions don't /have/ big o
16:34:18 <pikhq> det: Yes, and optimisations sometimes do that.
16:34:18 <det> changes the big o of other things
16:34:34 <pikhq> Welcome to languages that can be optimised well.
16:34:38 <Cale> det: (since you seem to think that it involves something imperative, which I don't think that it does, insofar as we don't usually regard expression reduction as imperative)
16:34:41 <det> if you manually programed thunks in an eager language
16:34:43 <Philippa> one can pay attention to performance with one's chosen implementation, or not
16:34:46 <det> it would be obviously imperative
16:34:59 <Cale> det: oh?
16:35:06 <pikhq> And we're not manually programming thunks in an eager language, now are we?
16:35:07 <det> but a imperative thing that doesnt expose itself to the rest of the program
16:35:25 <Philippa> det: not necessarily
16:35:31 <Philippa> det: it can be done by manually passing a heap
16:35:35 * BMeph wonders how you *Could* "manually program[ed] thunks in an eager language"
16:35:40 <Cale> det: "If we manually programmed strict evaluation, it would be imperative"
16:35:50 <Cale> det: Or would it?
16:35:57 <pikhq> We're denoting expressions which have a trivial isomorphism with a form of typed lambda calculus.
16:36:04 <Philippa> Cale: he's an SMLer, he's thinking imperative cell operations
16:36:15 <det> how can you manually program strict evaluation in a lazy language? :-)
16:36:18 <Philippa> because you can't implement it /with the performance characteristics/ in SML without using them
16:36:26 <pikhq> BMeph: What GHC does.
16:37:10 <Cale> det: The same way you manually program any evaluation mechanism: Using a function which reduces trees or graphs to other trees or graphs.
16:37:24 <Cale> This function is generally a pure function.
16:37:48 <det> Ok, I think I see what you are saying
16:37:52 <Cale> From the set of expression graphs to the set of expression graphs. Nothing imperative about it.
16:37:54 * BMeph wonders is "pure" is being understood properly...
16:38:11 <BMeph> Er, *if pure
16:38:14 <Zao> BMeph: "it's shorter than return"
16:38:16 <Philippa> det: it's recognised that call-by-need potentially has better asymptotic performance than call-by-value for exactly that reason
16:38:35 <BMeph> Zao: Ha! :)
16:38:51 <Philippa> but they're still just evaluation strategies for the lambda calculus
16:38:57 <det> you can easily implement call-by-need in a call-by-valure language without writing implementing graph reduction
16:39:12 <Cale> det: But if you mean a shallower embedding, Haskell has a primitive for strict evaluation.
16:39:13 <pikhq> det: ... You're implementing graph reduction.
16:39:25 <det> no
16:39:27 <Cale> det: But you're implementing graph reduction via mutation there.
16:39:28 <pikhq> You may just not realise it.
16:39:34 <Cale> det: That mutation is inessential.
16:39:47 <Philippa> det: c-b-need evaluation is equivalent to graph reduction
16:40:08 <Cale> det: It's just that you're not removing it because you find it convenient not to do so, which is fine, but it's best not to be confused.
16:41:58 <det> also, thunks and values in a strict language have different types, which is useful
16:42:16 <Cale> det: I think it's best not to think about thunks.
16:42:33 <Cale> Even when reasoning about performance of lazily evaluated programs.
16:42:36 <det> this is all about understanding the performance characteristics of your program
16:42:43 <det> which requires you to think about thunks
16:42:43 <Cale> Right.
16:42:51 <Cale> Not quite.
16:43:05 <det> I've heard before that you should always use the strict version of fold in haskell
16:43:12 <Cale> I reason about performance by understanding the graph reduction.
16:43:23 <Cale> That's patently untrue.
16:43:45 <Philippa> det: are you a c.l.f reader?
16:43:48 <Cale> You should almost always use the strict version of the *left* fold, but really the right fold is the one you want more often than not.
16:43:59 <det> Philippa, not often
16:44:17 <det> Cale, ok, that is what I meant
16:44:29 <Philippa> *nod* - just wondering, you're starting to sound like the particular breed of disinfo that's popular there
16:44:30 <CalJohn> is there function in the standard libraries that forces evaluation of it's argument, but throws it away and tell you how long it too to evaluate?
16:44:34 <det> why is right the more often wanted fold ?
16:44:44 <Cale> det: because it can stop early.
16:44:50 <Cale> det: and works on infinite lists
16:45:01 <CalJohn> det: foldr is more efficient for construction
16:45:01 <det> doesnt that depend on the datastructure ?
16:45:10 <Philippa> also, because it's /the/ catamorphism on lists
16:45:15 <Cale> right
16:45:21 <Cale> det: lists
16:45:23 <Philippa> det: it's presumed to be [a] lists
16:45:44 <Philippa> not least because anything else you wanted to treat as one, you just write toList, as mentioned before
16:45:54 <CalJohn> i am not even sure it does depend on the datastructure
16:45:55 <Cale> det: Unless you're talking about the one from Data.Foldable, in which case, well, there's not much you can say in general without picking a datastructure about the performance.
16:46:17 <Philippa> CalJohn: sure it does, some have an awful lot more than just foldl and foldr...
16:46:28 <CalJohn> Philippa: an awful lot more what?
16:46:30 <Cale> CalJohn: I'm pretty sure it depends on the datastructure -- on Snoc lists, the left fold is more natural.
16:46:35 <CalJohn> Philippa: more folds?
16:46:39 <Philippa> CalJohn: yeah
16:46:41 <Cale> CalJohn: right
16:46:59 <CalJohn> out of curiousity, can you give an example?
16:47:28 <Philippa> CalJohn: how many folds does a trinary tree have?
16:48:03 <Cale> CalJohn: the natural folding function for trees doesn't traverse the tree from either direction actually
16:48:11 <ray> right folds on lists just replace all the (:)s with your function ((+) or whatever)
16:48:14 <Cale> It reflects the structure of the tree.
16:48:15 <ray> i think cale didn't say that yet
16:48:21 <Cale> yeah
16:48:29 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
16:48:46 <Philippa> ray: yeah, that's what I was implying when I said it's the catamorphism
16:48:52 <Cale> Looking at the diagram for foldr there should make it more than apparent why it's usually the nicer one ;)
16:49:10 <det> but if you do want to fold a list from the left, you need to be aware of these things
16:49:25 <det> or reverse/foldr
16:49:32 <ray> if you want the leftmost stuff to be evaluated first
16:49:57 <Cale> det: Well, the cases where foldl' is usually important are almost identically the cases where strictness is important in general.
16:50:14 <Cale> (not 100% of them, but the vast majority)
16:50:14 <Philippa> det: honestly? It depends, it's not often mattered for the lists I've been foldling over
16:50:30 <Philippa> (which are, admittedly, usually rather short lists produced by a parser)
16:50:59 <det> think about evaluating an expression list that has an environment
16:51:05 <det> you must do that from the left
16:51:16 <CalJohn> Cale: isn't the rule for lists something like "construct with foldr, destroy with foldl'"?
16:51:19 <Cale> This is because the cases where strictness matters are exactly those cases where you're taking lots of separately evaluable pieces of data and summarising them down into something with not many separately evaluable parts.
16:51:20 <Philippa> I didn't say I'm not foldling
16:51:26 <Philippa> I said the performance didn't matter
16:51:33 <Cale> (and not searching through them too -- the result has to depend on all of them)
16:52:09 <Cale> This is often naturally a fold, and you just pick the strict one there.
16:52:16 <Cale> Performance issue solved ;)
16:52:43 <Philippa> det: TCO doesn't make a language impure either
16:52:44 <Cale> det: what's a list with an environment?
16:52:50 <Philippa> det: does that make sense?
16:52:50 <det> my whole point is that laziness makes it hard to reason about your program and leads to unexpected corner cases (such as foldl)
16:53:01 <Cale> det: huh?
16:53:01 <ray> you're saying that the choice is between foldr (matches the list structure) and foldl' (strict), cale?
16:53:07 <Philippa> it is? That sure isn't the point you started with
16:53:14 <Cale> det: It's not at all hard to reason about why making foldl strict is a decent idea.
16:53:25 <Cale> ray: Usually.
16:53:30 <det> Philippa, that was just a comment, not something I care much about
16:53:36 <ray> that's a good way to think about it
16:53:39 <ray> it's always "usually"
16:53:51 <Cale> ray: I would put my most common fold as being foldr, and after that foldl', and the others are way way less common.
16:53:54 <det> It's usually always usually
16:54:05 <ray> yeah, like i said
16:54:27 <Cale> det: Would you like to see why it's important when the combining function is strict to use foldl' rather than foldl?
16:54:29 <Philippa> det: spend a while asking Cale about what can be done, instead of saying it can't. You'll learn something
16:54:43 <Cale> @src foldl
16:54:43 <lambdabot> foldl f z []     = z
16:54:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:54:48 <det> what did I say cant be done ?
16:54:53 <Cale> Let's evaluate foldl (+) 0 [1,2,3]
16:55:06 <Cale> -> foldl (+) (0+1) [2,3]
16:55:10 <det> I'm sorry if I'm not making my points very clear, I had many people talking at me
16:55:11 <Cale> -> foldl (+) ((0+1)+2) [3]
16:55:17 <Cale> -> foldl (+) (((0+1)+2)+3) []
16:55:23 <Cale> -> ((0+1)+2)+3
16:55:31 <Philippa> det: reliably reasoning about the performance of your program, if it's been written in a sane way. At least, by implication
16:55:35 <mxweas> :O a copumpkin
16:55:48 <Cale> This is the point at which the stack starts getting used -- that is, after foldl finishes its work of building up the expression.
16:55:49 <Philippa> (yes, "sane way" isn't necessarily the same as you'd write in a strict lang)
16:56:16 <Cale> You need to push things on the stack because (...) + 3 can't evaluate without knowing what (...) is.
16:56:27 <det> Cale, so is the only downside that it must use the stack ?
16:56:31 <Cale> right
16:56:42 <det> well, that is just the same as in a strict language
16:56:44 <Cale> and uses more memory than necessary storing expressions
16:56:54 <Cale> So foldl' removes that problem
16:57:24 <Cale> by simply reducing (f z x) before recursing
16:57:26 <det> is lazy foldl any different than a strict language building a list and then using foldl ?
16:58:14 <Cale> I suppose that memory-wise, it's not *too* different
16:58:24 <det> performance wise ?
16:58:28 <Philippa> depends on whether the list itself's live - you're building a new one
16:58:37 <Philippa> there's a constant overhead for thunk building
16:59:06 <Cale> The lazy foldl walks down the list building up an expression which is as large as the original list, and then that expression starts getting evaluated. If the combining function involved is strict, then the stack is used to walk all the way to the innermost part of that expression and start reducing.
16:59:31 <Cale> However, the list that it's walking down in the first place may only have one cons-cell in memory at a time.
16:59:33 <desp> @instances Floating
16:59:34 <lambdabot> Double, Float
16:59:50 <Cale> So building the expression is not unlike building the list in a strict language.
17:00:11 <Cale> But there is a difference, as Philippa points out.
17:00:38 <det> now I have you guys thinking in thunks :x
17:00:39 <Vanadium> This makes foldr seem rather unattractive.
17:00:51 <Cale> Vanadium: huh, we're not even talking about foldr
17:00:55 <Vanadium> Exactly!
17:00:58 <Cale> det: thunks?
17:01:01 <beutdeuce> @instances Monad
17:01:02 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:01:06 <Pseudonym> We don't think in thunks.  We prefer our delayed execution to be implicit.
17:01:09 <Cale> det: Did I use the word thunk anywhere?
17:01:13 <det> Cale, Philippa did
17:01:18 <Pseudonym> Only (hack spit) implementors think in thunks,.
17:01:30 <det> and I thought that is what y ou meant when you said "as Philippa points out"
17:01:35 <Cale> det: Oh, then let me rephrase what she said in higher level terms.
17:01:57 <Cale> det: replace the word 'thunk' with 'expression' whenever you hear it. :)
17:02:16 <Cale> det: Because a thunk is just one possible implementation mechanism for expressions.
17:02:20 <det> a name is irrelevent :-)
17:02:31 <Cale> (just like a closure is one possible implementation mechanism for a function)
17:02:47 <det> yeah..
17:02:52 <pikhq> A thunk is but an implementation detail.
17:02:58 <Cale> The important thing to realise is that you can think in terms of substitution of expressions.
17:03:13 <Cale> and reason quite adequately about the performance of your program
17:03:22 <det> I still find it easier to reason about strict programs, and most of the time I want strictness
17:03:35 <det> maybe that is just because experience
17:03:43 <Cale> That's actually not true. I would estimate that it's less than 25% of the time.
17:03:55 <det> I am talking from personal experience
17:03:58 <Cale> Around half of the time, it doesn't matter.
17:04:18 <det> right, and when it "doesnt matter", I want strictness, because it is more performance
17:04:22 <det> performant*
17:04:25 <Cale> Not really.
17:04:28 <dons> heh. not really
17:04:43 <det> thunks or expressions or w/e have an overhead
17:04:44 <Cale> When I say that it doesn't matter, I mean that *it doesn't matter for performance*
17:04:50 <dons> its very hard to know if evaluating something at a particular point will improve or decrease performance
17:04:57 <dons> try adding ! on every function argument, bet things get worse
17:05:26 <dons> det: oh, certainly, you may gain a different representation, that's different though
17:05:33 <dons> and doesn't work for all types, only relatively simple ones.
17:05:51 <det> I'm not really talking about strictness *in Haskell*
17:05:56 <dons> most types are represented with a boxed heap value, whether or not it is strict.
17:05:59 <Cale> det: I have a feeling that the reason you end up wanting strictness so often is that you're so used to bending your programs into awkward shapes to get around the fact that things are strict that you don't even notice that you're doing it.
17:05:59 <det> I am largely ignorant of Haskell
17:06:20 <dons> i usually want the compiler to do what i mean
17:06:21 <Vanadium> That is the syntax for adding !s to make things strict?
17:06:30 <dons> yeah, f !x = 1 + x
17:06:35 <dons> evaluate x before it is needed
17:06:38 <det> Cale, I think that type classes can help you not care about these things of a good strict language had them
17:06:38 <Vanadium> I thought you had to sprinkle everything with rst or seq or $!
17:06:54 <ray> well, you can if you want
17:07:02 <monochrom> data Strict = Strictness !Die !Die !Die
17:07:05 <dons> you can use rnf, seq, $!, strict types, relie on strictness analysis, use unboxed types, ...
17:07:13 <dobblego> det, a good strict language does have them (Scala) and it is an enormous pain in the arse that it is default-strict
17:07:14 <det> for example, you could have a generic Sequence type class, and you wouldnt care of a Range.T was a list or some infinite type using thunks
17:07:25 <det> scala doesnt have type classes
17:07:28 <dobblego> yes it does
17:07:38 <det> it has traditional OO AFAIK
17:07:42 <det> C++/Java style
17:07:42 <Cale> det: That takes care about one particular data structure... what about function application?
17:07:48 <dobblego> it has implicit dictionary passing, which is what type classes are
17:08:02 <det> type classes are more general
17:08:05 <dobblego> no they aren't
17:08:12 <dobblego> (the opposite in fact)
17:08:28 <det> Num is perfect example
17:08:30 <ben_w_> dons: what's strictness analysis?
17:08:31 <det> how to do that in Scala
17:08:40 <det> Cale, I dont know what you mean
17:08:55 <dobblego> det, I didn't intend to give you a Scala tutorial
17:09:21 <det> dobblego, the "this" type in scala can only occure occur once
17:09:29 <Cale> det: Suppose I have a function and it's applied to some parameters, but the function may not use them all. How do you use typeclasses to deal with that?
17:09:31 <det> err, occur*
17:10:00 <dons> ben_w_: an analysis the compiler does of your program to determine which functions evaluate their arguments strictly, basically. That information can then be used to propagate representation improvements through your program
17:10:04 <Cale> (that is, for some values of some of the parameters, other parameters may not be used)
17:10:05 <dobblego> det, there are papers out there for you to read -- Scala has type-classes
17:10:21 <det> Cale, A good strict compiler could optimize that away
17:10:21 <dons> machine-level + (the +# operator), for example (and most primops) are strict in their arguments.
17:10:33 <Cale> det: no it couldn't, since it's a runtime issue
17:10:37 <ben_w_> dons: ah, neat, thanks
17:10:38 <det> dobblego, I'll look into it
17:10:43 <det> dobblego, thanks
17:10:45 <dons> "A function is strict in an argument if a demand for its result leads to a demand for that argument"
17:10:51 <Cale> det: Unless you have a halting oracle handy...
17:11:09 <Philippa> ...or are working in a total language
17:11:15 <Cale> Philippa: sure :)
17:11:19 <det> Cale, that's not a problem I've ever encountered
17:11:37 <det> but a compiler could *sometimes* optimize that
17:11:47 <monochrom> Please don't summon the halting tarpit so hastely.
17:12:09 <Philippa> det: and GHC sometimes does too
17:12:11 <Cale> det: Because you program in such a way that you ignore easy solutions to your problem because they would be "too inefficient", when lazily evaluated, they wouldn't be.
17:12:23 <det> Cale, I dont program in such a way
17:12:33 <Cale> You do, all strict programmers do.
17:12:46 <det> Cale, I've never had to ignore a lazy solution because it would be "inneficcient"
17:12:52 <det> you can easily implement laziness after all
17:13:00 <dons> det: ?
17:13:08 <Philippa> eh, FCVO "easily"
17:13:09 <Cale> You have to turn your programs inside out to get decent efficiency, and often have to ignore the fact that there are perfectly good library functions available.
17:13:28 <Philippa> it's a bit like not having type inference and implicit generalisation - you miss stuff
17:13:32 <Cale> det: No, it's not easy.
17:13:38 <dons> people rarely use infinite structures in strict languages, for example,..
17:13:50 <desp> What's the precendence of (:)?
17:13:52 <desp> And fixity?
17:13:54 <det> Cale, I really dont see this, any example ?
17:13:55 <dons> ?src (:)
17:13:55 <Cale> det: and even if you can, your libraries aren't all written that way
17:13:55 <lambdabot> Source not found. Wrong!  You cheating scum!
17:13:58 <dons> bah
17:14:13 <desp> Precedence, I guess.
17:14:13 <dons> desp: ask :info in ghci
17:14:16 <det> dons, I already covered that issue
17:14:25 <desp> dons: oh, neat, thanks.
17:14:51 <det> I view that as a more general problem solved by type classes
17:14:54 <Philippa> det: it's not pervasive, you have to think to do it
17:15:00 <Philippa> and really, type classes /won't/ fix that
17:15:06 <dons> type classes? now I'm confused.
17:15:16 <Philippa> you can, of course, go and prove us wrong...
17:15:31 <det> I need an example to really prove anything wrong
17:15:49 <det> and I am more interested in learning than being right
17:15:53 <Philippa> det: how about the entire ML ecology?
17:16:08 <det> Philippa, what do you mean
17:16:21 <Philippa> you don't have type classes, but you /do/ have functors. It's a matter of effort using them
17:16:27 <BMeph> desp: According to GHCi (6.10.4), it's: "infixr 5 :"
17:16:29 <Cale> det: Write me a program which decides whether or not a list occurs somewhere inside another list as a substring. Just the naive algorithm with an early bailout if it finds the string, or if it starts checking at a particular point in the haystack and finds that it doesn't match before reaching the end of the needle.
17:17:18 <det> type classes are fine grained
17:17:21 * dons tries to determine the actual average occurence of strict values in average haskell programs.
17:17:23 <det> they are similar to fucntors
17:17:50 <monochrom> @src isInfixOf
17:17:50 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
17:17:55 <det> but functors are too heavy handed
17:18:10 <monochrom> Like that. Translate that to an eager language.
17:18:11 * BMeph guesses the answer dons needs is: 0.42 ;)
17:18:26 <monochrom> (Can we stop saying "strict language" yet?)
17:18:40 <det> what is wrong with "strict" ?
17:18:47 * copumpkin cracks his whip
17:18:57 <dons> my guess is about half the types mentioned in functions are strict.
17:19:09 <ManateeLazyCat> I plan to remove hs-boot file from GHC, how difficult to do this work? Have any detail resource talk about this feature?
17:19:10 <monochrom> eager and lazy. strict and non-strict.  Not eager and non-strict, strict and lazy.
17:19:17 * BMeph is more impressed with Philippa's whip than copumpkin's.
17:19:25 <copumpkin> BMeph: sexist :(
17:20:00 <Cale> monochrom: Did you actually want us to stop saying eager language, even though that's not what we were saying? ;)
17:20:07 <BMeph> copumpkin: I'd say "meritist", actually. ;p
17:20:12 <copumpkin> :(
17:20:12 <Philippa> monochrom: Haskell is, strictly speaking, a non-strict language rather than a lazy one
17:20:14 <monochrom> When I am in this channel I feel like people talk like "male vs housewife".
17:21:09 <copumpkin> :o
17:21:18 <monochrom> Philippa: I saw lots of "lazy" and no "non-strict" in the last 15 minutes of wholesome conversations.
17:21:45 <Cale> monochrom: Though, to be fair, it's often called strict evaluation.
17:22:07 <Cale> I've even heard eager evaluation used to describe an evaluation mechanism with nonstrict semantics.
17:22:17 <Philippa> Cale: that, and the entire class of /sane/ strict evaluation methods is fairly limited
17:23:05 <dons> so I grabbed a random n-queens program, after optimization, there are 82 arguments in the program. 46% are marked as required to be lazy. 37% are judged to be strict, and 15% are strict and unboxed.
17:23:16 <dons> most of the lazy ones are data structure arguments (e.g. lists)
17:23:56 <dons> so much for a lazy language. its about half/half :)
17:24:10 <Cale> dons: How many explicit strictness annotations does the program source contain?
17:24:14 <dons> none.
17:24:17 <Cale> Good :)
17:24:25 <dons> i'll add some
17:24:38 <dons> mostly it is just pattern matching
17:24:43 <Cale> None is close enough to the average
17:24:48 <dons> yep
17:25:03 <monochrom> I'm more than happy to say "data X = X !Int is strict" and "Haskell lists are non-strict".
17:25:03 <dons> plenty of natural demand-based strictness
17:25:23 <Cale> dons: right.
17:25:28 <dons> i hope i don't break the program, adding bangs...
17:25:28 <Philippa> monochrom: right. And the ML implementations were specifically of lazy evaluation
17:25:29 <dons> hard to tell
17:25:44 <dons> oh, hard to add bangs to point-free programs
17:26:04 <ManateeLazyCat> I need compile all source code again if change some GHC source file?
17:26:07 <Philippa> probably easier to add seq?
17:26:14 <Cale> . ($!) . ?
17:26:16 <det> @src any
17:26:17 <lambdabot> any p =  or . map p
17:26:40 <jmcarthur> i wonder if point free programs tend to be more strict or more lazy than pointful programs?
17:26:41 <ManateeLazyCat> Have a better way to debug GHC?
17:26:57 <det> I find points free to be difficult to read :-)
17:27:00 <jmcarthur> if i had to guess i'd say maybe slightly more lazy
17:27:06 <jmcarthur> by pure accident, i mean
17:27:07 <Cale> det: any p xs = or (map p xs)
17:27:26 <det> @src or
17:27:27 <lambdabot> or    =  foldr (||) False
17:28:20 <dons> heh. adding bangs on *everything* increased the amount of strictness in the program by 2 values (2.5%)
17:28:22 <Cale> det: So naturally, or will shortcut as soon as an element is found where it's True
17:28:39 <Cale> @src (||)
17:28:39 <lambdabot> True  || _ =  True
17:28:39 <lambdabot> False || x =  x
17:28:40 <dons> so GHC already got it right, to a first approximately. adding extra stuff did nothing.
17:28:58 <Cale> Because || doesn't use its second parameter when its first parameter is True
17:28:59 <dons> one value is now unboxed, where it wasn't previously (so that's an optimiztion)
17:29:27 <dons> hmm, i think this program wouldn't work if we used fully strict listtts.
17:29:43 <det> I have a hard time beleiving some Haskell programmer would arive at this definition of isInfixOf very naturally
17:29:50 <dons> ?src isInfixOf
17:29:50 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
17:29:55 <Cale> det: It's the first thing which would come to my mind.
17:30:05 <dons> isn't it the one proposed on the libraries@ list?
17:30:23 <copumpkin> det: it seems pretty reasonable to me
17:30:30 <gwern> needle, haystack? -_-
17:30:32 <jmcarthur> i don't know if it's the first i would think of, but it reads perfectly to me
17:30:52 <det> I still dont undertand that definition
17:30:53 <copumpkin> it's not the most efficient way to do it
17:30:57 <Cale> It's as idiomatic as the nested loops version in python or some imperative language.
17:31:00 <dons> generate a lazy list of all the tails
17:31:07 <dons> match the prefix of them until you find a match
17:31:11 <dons> laziness is your loop here.
17:31:15 <copumpkin> > tails "moomoo"
17:31:19 <lambdabot>   ["moomoo","oomoo","omoo","moo","oo","o",""]
17:31:20 <Cale> det: The needle occurs in the haystack if any of tails of the haystack has the needle as a prefix
17:31:30 <det> oh
17:31:32 <dons> ?src tails
17:31:33 <lambdabot> tails []         = [[]]
17:31:33 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
17:31:35 <det> tails was the missing piece
17:31:37 <copumpkin> > map (isPrefixOf "moo") . tails $ "moomoo"
17:31:39 <lambdabot>   [True,False,False,True,False,False,False]
17:31:43 <dons> tails is the driver here
17:32:21 <Cale> Normally you wouldn't use tails in a strict language, because you want to avoid checking past the first tail where you found the item, and so constructing all the tails is wasteful.
17:32:21 <pikhq> det: You find it hard to believe that some Haskell programmer would write a Haskell idiom.
17:32:43 <det> you are suggesting that an eager program would needlessly generate unused tails ?
17:32:46 * Philippa suspects a lot of people would find pointless style easier if it were written backwards
17:32:58 <Cale> det: No, I'm suggesting that you'd program this in a different way.
17:33:04 <pikhq> det: No, he's suggesting that an eager program wouldn't be written like that at all.
17:33:11 <Cale> det: A way which used fewer stock library functions.
17:33:15 <jmcarthur> Philippa: i think that a lot as well
17:33:19 <Cale> Or otherwise didn't decompose as well.
17:33:27 <dons> Philippa: the Factor guys do
17:33:28 <pikhq> Not to mention harder to read.
17:33:37 <hackagebot> uacpid 0.0.4 - Userspace Advanced Configuration and Power Interface (DinoMorelli)
17:33:43 <Philippa> dons: yeah, but they don't write much else
17:33:44 <jmcarthur> for example: flip (.) tails . any . isPrefixOf     -- a pointfree version isInfixOf
17:33:49 <det> that's probably true
17:33:57 <dons> Hudak defined >.> in CofFP
17:33:57 <det> I dont really consider it a bad thing though
17:34:02 <jmcarthur> reading that backwards... "isPrefixOf any tails" makes perfect english sense :)
17:34:17 <Philippa> I write mostly pointed, tend to use pointless for navigating functor levels
17:34:32 <BMeph> Heh-heh, "tails is a coKleisli." ;)
17:34:41 <Cale> det: The reason we all love lazy evaluation so much as a default is that it gives us more ways to write our programs -- but in order to do this, all the libraries need to be no stricter than necessary.
17:35:47 <det> it seems most of these things really amount to lazy lists
17:35:53 <Philippa> det: type classes can't resolve that in general because you'd need to propagate /all/ the decisions
17:35:55 <Cale> det: Problems decompose into parts much more naturally, on average, because you don't have to worry all the time about whether the data structure you're producing is not going to be entirely used or not, and you end up inserting code which does work and/or checks various conditions into the code for generating the structure
17:35:59 <BMeph> Wait a minute, that's not right - "tails is duplicate for lists-as-streams" is closer.
17:36:08 <pikhq> det: Lazy lists are just easier to discuss.
17:36:08 <jmcarthur> which reminds me to ask again.... Control.Monad.Writer.Lazy.Writer appears to be strict even though Control.Monad.Writer.Lazy.WriterT is lazy. has this not been noticed because i am wrong or has it actually been noticed and simply not changed for some other reason?
17:36:19 <det> you can easily have a module that creates lazy streams
17:36:24 <Philippa> det: lists crop up more often than any other structure because they double as a control structure, that's all
17:36:25 <Cale> det: Actually, trees are probably even more important than lists.
17:36:36 <Cale> Well, maybe not entirely true.
17:37:01 <Cale> Lists have all sorts of use cases which are essential to the way we program... they replace loops.
17:37:08 <mike-burns> det: You can easily create any module; the fact that it's part of the language is the selling point.
17:37:13 <det> and I bet I could decompose your example into nice eager library functions, as well
17:37:28 <Cale> det: I bet they're not as nice ;)
17:37:29 <Philippa> det: go on, then
17:37:38 <dons> how would you determine when to stop generating values?
17:37:44 <dons> pass in a limit function?
17:37:59 <Cale> I suppose you could transform the whole program into CPS.
17:38:02 <det> I didnt say it would be the same
17:38:13 <Philippa> Cale: that's not nice!
17:38:17 <jmcarthur> what's the point then?
17:38:18 <Cale> Philippa: indeed.
17:38:27 <dons> having to come up with the limit condition beforehand is annoying :/
17:38:40 <Philippa> det: go for it, it's not a big example
17:38:45 <dons> oh, maybe tailsUntil (any . isPrefixOf)
17:38:50 <Cale> The problem is that the limit condition is the same as the original problem.
17:38:52 <Cale> ;)
17:38:58 <dons> where the hof argument would yield Just/Nothing
17:39:05 <pikhq> det: Lazy streams, eh?
17:39:08 <dons> Cale: zactly
17:39:18 <pikhq> I do believe that's part of our IO system.
17:39:21 <dons> so the whole program has to be flipped around
17:39:32 <Cale> yep
17:39:50 <jmcarthur> it exposes details i'd rather not look at
17:40:00 <dons> you start by stating the termination condition, then propagate that test back through the functions.
17:40:22 <pikhq> det: Waiting.
17:40:36 <Cale> det: But really, the only reason that I picked this example with lists is that lists are simple. There are lots of much more complicated examples which crop up all the time and which don't involve lists, it's just I can't think of easy one-liners.
17:41:06 * Philippa heads off
17:41:08 <Philippa> have fun
17:41:21 <BMeph> Do we have a popular lazy tree DS?
17:41:30 <dons> Data.Map ?
17:41:45 <dons> seems popular, is lazy, is a tree.
17:41:57 <Cale> I always end up just defining my own trees because I don't like Data.Tree's Show instance at all.
17:42:04 <jmcarthur> i thought Data.Map was strict...
17:42:06 <dons> actually, its spine strict, element lazy. I never remember why
17:42:09 <monochrom> http://www.haskell.org/haskellwiki/MonadFix  is a lot of fun.
17:42:17 <Cale> Data.Map is structure-strict and element-lazy.
17:42:20 <jmcarthur> ah
17:42:30 <det> pikhq, I'm not doing that now
17:42:30 <BMeph> dons: Is it? Because Data.Sequence is strict, and don't they use similar internal reps?
17:42:35 <Cale> It's also only strict enough in the keys to do the comparisons.
17:42:36 <dons> FingerTree looks better.
17:42:46 <jmcarthur> <3 finger trees
17:42:48 <dons> data FingerTree a = Empty | Single a | Deep {-# UNPACK #-} !Int !(Digit a) (FingerTree (Node a)) !(Digit a)
17:43:11 <dons> as usual, complex structures half a delicate balance of strict and lazy properties
17:43:14 <pikhq> det: Lame.
17:43:15 <dons> you often want a mix.
17:43:20 <det> pikhq, why ?
17:43:28 <Cale> I wrote a full featured priority search queue using finger trees in about an hour the other day :)
17:43:33 * SamB_XP_ attempts to find an adjective for this: http://knol.google.com/k/kazuhiko-kotani/an-objection-to-cantors-diagonal/1ibusyvuup78g/2#
17:43:51 <Cale> (just because I felt there should be more examples on Hackage)
17:44:07 <pikhq> det: It's non-trivial in an eager language. Lame.
17:44:12 <jmcarthur> it's amazing how a structure i can't even claim to really understand is such a swiss army knife
17:44:35 <det> pikhq, It's non-trivial *with a large library of quirky functions available to you*, such as Haskell has
17:44:50 <pikhq> det: It's not exactly difficult without, either.
17:44:59 <Cale> jmcarthur: Well, there's understanding and then there's understanding. ;)
17:45:06 <jmcarthur> Cale: exactly ;)
17:45:08 <det> sure, but the point is to compose it in terms of other composable things
17:45:18 <det> not write self-contained
17:45:25 <monochrom> People use Data.Map for looping over something and keep inserting things into the Map. Then they get stack overflow and so insert' is provided. But insert' would be meaningless if the tree inside were not somewhat strict.
17:45:27 <jmcarthur> det: then make smaller things first and use them to make your bigger things
17:45:30 <benmachine> all the library functions involved have like two-line definitions anyway :P
17:45:48 <det> jmcarthur, I dont feel like doing that right now, obviously
17:45:49 <Cale> det: Well, the functions aren't really that quirky. They're standard things which we use constantly.
17:45:50 <pikhq> And the intuitive way to write that without a standard library would be to write the same definition there, except... You'd also define the other functions.
17:45:51 <jmcarthur> benmachine: most of them needn't be so long
17:46:03 <gwern> 'Indicate the type of each of the following expressions. Use the symbols "->" to denote "maps to", for example, the procedure square has type "number->number". Use the following terms to describe primitive types of data: number, boolean, string.' <-- ouch. these sicp exercises can be painful for a haskeller
17:46:08 <jmcarthur> det: oh i missed the point of what you were saying. sorry
17:46:09 <Cale> det: There ought to be similar things in an eager language if your case was true ;)
17:46:37 <det> Cale, not neccesarily
17:47:02 <Cale> (Shouldn't there? Or are they so complicated to find that they haven't been found in the last 30 years of programming in strict languages. Either way...)
17:47:05 <SamB_XP_> so if you hadn't got a standard library, how would you get []?
17:47:20 <ray> gwern: seems more like "so easy a haskeller can do them in his sleep"
17:47:23 <det> Cale, the language I use most has a rather limited standard library
17:47:27 <mike-burns> So much of the language's libraries are dictated by the evaluation order that I don't even understand the arguments for or against det.
17:47:34 <gwern> ray: well, except that some of the base functions have weird types
17:47:40 <pikhq> SamB_XP_: Oh, you want to do this from lambda on up?
17:47:43 <pikhq> Let's do this!
17:47:59 <gwern> like, and or or - they'll return booleans - and any ol' object.
17:48:04 <Philippa> det: it took me about a minute to get as far as "and I should look up those functions, because I don't touch this but I know they're there" - I had the same definition as the one given in chan otherwise. I could write tails and isPrefixOf easily enough. You should be able to achieve a similar sensible decomposition if you have a viable competitor, without taking more than a few minutes
17:48:04 <det> and I dont really think the standard library size is really related to Ocaml being strict
17:48:06 <ray> data List = Cons List List | Nil
17:48:15 <ray> er
17:48:16 * SamB_XP_ didn't think Haskell had a good enough type system to do it lambda-on-up
17:48:20 <gwern> what type is that? Either a Bool -> Either a Bool?
17:48:23 <Philippa> filling in the functions takes longer, that's fair enough
17:48:24 <ray> List a = Cons a List
17:48:26 <ray> fdhgsjkldgh
17:48:32 <SamB_XP_> and actually I was just talking syntax
17:48:35 <pikhq> SamB_XP_: Untyped lambda calculus can, it just ignores the type system.
17:48:36 <Philippa> anyway, I'm actually heading off instead of checking other stuff first this time
17:48:44 <SamB_XP_> pikhq: well, yeah
17:49:00 <pikhq> Aside from the [] notation *specifically*, you can do that from lambda on up in Haskell.
17:49:06 <Cale> det: Even when Haskell had a tiny standard library, these functions were in it because they are among the most commonly used. (tails and any are, anyway)
17:49:24 <det> any makes sense
17:49:32 <det> tails surprises me
17:49:46 <pikhq> Why, it's just a list of tails.
17:49:46 <Cale> tails is super-important because it's what we use to do things to lists when those things need context.
17:50:11 <pikhq> It's like two lines.
17:50:23 <Cale> Like, map f . tails will map a function over the list, but give it access not just to the one element, but to the elements after that
17:51:07 <det> Ya, I dont really see why that is so useful
17:51:18 <Cale> Or, for example...
17:51:28 <monochrom> It is useless in strict languages.
17:51:35 <det> monochrom, strong language
17:51:36 <Cale> [(x,y) | (x:xs) <- tails [1..5], y <- xs]
17:51:38 <Cale> > [(x,y) | (x:xs) <- tails [1..5], y <- xs]
17:51:40 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
17:52:00 <monochrom> Yes I speak a strong language.
17:52:05 <gwern> and these instructions blow. how is one to know that while single args look like number->number, multiple args look like (number,boolean)->number?
17:52:10 <det> no use at *all* really ?
17:52:19 <Cale> Picking pairs of elements from a list where we only want one ordering of each pair.
17:52:23 <copumpkin> > let sublists = filter (not . null) . concatMap tails . inits in sublists [1..5]
17:52:27 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
17:52:59 <det> Now you've thrown list comprehensions into it! :-)
17:53:11 <beutdeuce> I perfectly understand http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7252#a7252, but I dont understand the Functor and Monad. Cannot someone please explain the two to me by using this example that i understand of working with wrapped types -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7252#a7252
17:53:18 <Cale> det: Sure, but those are really just concatMap
17:53:43 <monochrom> I can use your experience to justify what I said.
17:54:12 <Cale> beutdeuce: That is not a very interesting monad.
17:54:14 <caxaf> beutdeuce: This is the Identity monad, which might well seem pointless by itself.
17:54:32 <pikhq> gwern: number->boolean->number. ;)
17:54:32 <det> less useful is debatable for sure, but useless is really dramatic
17:54:40 <SamB_XP_> Cale: so what word would you apply to someone who claims cantor's diagonalization argument doesn't work ... because he tries to apply it to finite-length binary fractions?
17:54:41 <Cale> det: I agree there.
17:55:04 <Cale> det: It's not *useless* in a strict language, but by comparison, it's far less useful.
17:55:08 <ray> samb_xp_: cantoron
17:55:16 <det> like I said, it is debatable :-)
17:55:27 <pikhq> Certainly not "stick in standard library" useful.
17:55:42 <Cale> SamB_XP_: I would say that it sounds as if he made a mistake.
17:55:57 <det> Cale, thanks for your time, I will reflect on your points
17:56:04 <SamB_XP_> Cale: you want to find it? http://knol.google.com/k/kazuhiko-kotani/an-objection-to-cantors-diagonal/1ibusyvuup78g/2#
17:56:09 <Cale> det: No problem. Let me know if you have more questions :)
17:56:10 <ray> cantor's diagonal argument is fun to explain to friends and family in a restaurant, so it can't be that hard
17:56:22 <pikhq> det: I'LL REFLECT ON YOUR POINTS! Uh, I mean...
17:56:24 <pikhq> :P
17:56:31 <SamB_XP_> @yow
17:56:32 <lambdabot> Is something VIOLENT going to happen to a GARBAGE CAN?
17:56:38 <SamB_XP_> @bofh
17:56:38 <lambdabot>  Done.
17:56:39 <det> pikhq, I dont get it
17:56:44 * SamB_XP_ wonders what was done
17:56:56 <pikhq> det: Reacting angrily at random.
17:57:03 <pikhq> @bofh
17:57:03 <lambdabot>  Done.
17:57:10 <Cale> SamB_XP_: Wait, he's applying Cantor's diagonalisation argument to try to prove there are uncountably many rationals?
17:57:12 <ray> @. @yow @bofh
17:57:12 <lambdabot> Plugin `compose' failed with: Unknown command: "@yow"
17:57:15 <pikhq> SamB_XP_: Probably the backup to /dev/null.
17:57:24 <pikhq> @@ @yow @bofh
17:57:25 <lambdabot> Plugin `compose' failed with: Unknown command: "bofh"
17:57:52 <EvilTerran> @. vixen yow
17:57:55 <lambdabot> no
17:58:03 <ray> sensible
17:58:05 <SamB_XP_> Cale: hmm ... it looked like he was only even ever doing it for one length of fraction ...
17:58:09 <bgs100> @yarr
17:58:09 <lambdabot> Keelhaul the swabs!
17:58:18 <EvilTerran> > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
17:58:20 <lambdabot>   Ambiguous occurrence `var'
17:58:20 <lambdabot>  It could refer to either `Data.Number.Symbolic....
17:58:23 <EvilTerran> doh!
17:58:29 <Cale> SamB_XP_: Oh, it sounds as if he's explaining what primitive mathematicians thought was a problem with the argument.
17:58:37 <EvilTerran> > text . ((++) <*> show) $ "> text . ((++) <*> show) $ "
17:58:39 <lambdabot>   > text . ((++) <*> show) $ "> text . ((++) <*> show) $ "
17:59:04 <ray> they didn't have diagonals back then
17:59:07 <SamB_XP_> Cale: it doesn't look like that's how he sees what he's doing
17:59:27 <pikhq> EvilTerran: Nice quine.
17:59:28 <Cale> "Cantor‚Äôs diagonal argument uses the completion of infinite processes. However, the mathematicians before Cantor did not accept the completion of infinite processes. This is the controversial point of Cantor‚Äôs diagonal argument."
17:59:53 <caxaf> SamB_XP_: "Therefore, no matter how large n is, we can not apply diagonal procedure to all n-digit binary fractions in interval [0,1]."
18:00:01 <caxaf> SamB_XP_: That is correct, isn't it?
18:00:12 <caxaf> Just not relevant to the argument.
18:00:18 <EvilTerran> Cale, i guess cantor's diagonal argument involves a corecursive process, then?
18:00:18 <SamB_XP_> caxaf: true, but it complely misses the point!
18:00:43 <bgs100> @. elite yarr
18:00:43 <lambdabot> Ge7 0ut O' mE W4y, Y3H l4ND|UBbEr
18:00:49 <bgs100> :D
18:00:54 <pikhq> :D
18:00:54 <Cale> EvilTerran: yes, and it's a proof by contradiction too ;)
18:01:00 <pikhq> @. yow bofh
18:01:01 <lambdabot> Plugin `compose' failed with: Unknown command: "bofh"
18:01:12 <caxaf> Any irrational number, for instance, could not be expressed by an n-digit binary fraction.
18:01:12 <bgs100> @help bofh
18:01:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:01:16 <pikhq> Grr.
18:01:28 <bgs100> @. elite help
18:01:28 <lambdabot> He1p <Co/\/\maNd>. A5k phOr He|p 4 <CO/\/\MAND>. Try '|is+' 4 41| (OMmANd$
18:01:34 <bgs100> Wow.
18:01:52 <pikhq> @@ @elite @help elite
18:01:53 <lambdabot>  Eli7e <p|-|razE>. TRAnsLa+3 englI5|-| 7O E1i+e5P3ax
18:02:02 <bgs100> @?
18:02:06 <ray> @. elite type fmap
18:02:07 <copumpkin> composes
18:02:08 <lambdabot> ph0R4|1 a 8 (f :: * -> *). (FUN(+or f) => (A -> 8) -> F a -> f b
18:02:12 <copumpkin> lol
18:02:26 <bgs100> @. elite @src words
18:02:26 <lambdabot> Plugin `compose' failed with: Unknown command: "@src"
18:02:26 <mike-burns> Haha.
18:02:31 <bgs100> @. elite src words
18:02:31 <lambdabot> Say again?
18:02:33 <copumpkin> is elite invertible?
18:02:34 <bgs100> :P
18:02:39 <Cale> copumpkin: no
18:02:39 <pikhq> @@ @elite @src words
18:02:40 <lambdabot>  Say again?
18:02:41 <copumpkin> :(
18:02:42 <ray> no
18:02:43 <monochrom> That's a very disturbed forall.
18:02:50 <bgs100> @@ @elite @src words
18:02:51 <lambdabot>  Say again?
18:02:52 <Cale> copumpkin: at least, I'm pretty sure it's not
18:02:54 <ray> i think some things are ambiguous
18:02:59 <copumpkin> it'd be fun to have an eliteskell
18:03:03 <monochrom> And a very disturbed Functor
18:03:13 <Cale> @elite |
18:03:13 <lambdabot> |
18:03:16 <Cale> @elite l
18:03:16 <lambdabot> l
18:03:17 <bgs100> @@ @elite @arr
18:03:18 <Cale> @elite l
18:03:18 <lambdabot>  i'l1 x3e1 |-|Aul yA fER 7|-|a+!
18:03:18 <lambdabot> L
18:03:19 <Cale> @elite l
18:03:19 <lambdabot> |
18:03:25 <copumpkin> lol
18:03:28 <hzap> @arr
18:03:29 <lambdabot> Ahoy mateys
18:03:29 <bgs100> @@ @elite @run 1 + 1
18:03:31 <lambdabot>  2
18:03:35 <copumpkin> @@ @elite @vixen I'm so elite
18:03:36 <bgs100> >:)
18:03:36 <lambdabot>  yOu'Re 7uRnin9 M3 0n :)
18:03:40 <pikhq> @@ @elite @arr @elite
18:03:41 <lambdabot>  ShIv3R Me +Imberz!
18:03:54 <Cale> This is probably almost enough playing with these in the channel ;)
18:03:58 <monochrom> @elite Functor FUN(+or
18:03:59 <lambdabot> phUNc70r FUn(+oR
18:04:02 <pikhq> @@ @elite @vixen @elite @arr
18:04:02 <lambdabot>  I hEAR Ya!
18:04:19 <bgs100> @@ @elite @run words "Elite! Yay!"
18:04:19 <monochrom> @elite Functor FUN(+or Functor FUN(+or
18:04:21 <lambdabot>  ["E|i+e!","Y4y!"]
18:04:21 <lambdabot> fUNC+Or phUN(+or fuNc+0R FUN(+0r
18:04:34 <monochrom> It contains some randomness, too.
18:08:43 <bgs100> @. elite girl19
18:08:43 <lambdabot> I5 +HIz A H31p c|-|ANNeL 4 haxxeRz-BE9inNERS?
18:09:14 <bgs100> @@ @elite @vixen @girl19
18:09:14 <lambdabot>  A pr09ra/\/\?
18:09:57 <monochrom> So, I have a slick algorithm for "longest increasing subsequence", it uses Data.Set and no array, it has the same Œò(n log n) complexity as the imperative, array algorithm. But it is awkward to explain. The easiest way perhaps is "a data refinement of the imperative array algorithm".
18:10:31 <Vanadium> I have a bar of chocolate.
18:10:34 <Vanadium> It is pretty slick as well.
18:10:47 <monochrom> My hair is slick too.
18:11:15 <bgs100> @@ @elite @vixen @quote
18:11:15 <lambdabot>  aWeS0Me
18:11:41 <bgs100> @@ @elite @vixen @quote @yarr
18:11:42 <lambdabot>  \/\/ha+'z0rz \/\/0RTH More 4 phlUsh oR 4 phUl1 h0U5E?
18:11:44 <beutdeuce> > foldr1 (\x c -> x*c) [1..5] -- factorial with foldr
18:11:46 <lambdabot>   120
18:12:11 <mike-burns> @src product
18:12:11 <lambdabot> product = foldl (*) 1
18:12:18 <pikhq> beutdeuce: Not bad.
18:12:38 <pikhq> Perhaps a bit trivial, and (*) works just as well as (\x c -> x*c), but it does show you comprehending things.
18:12:56 <beutdeuce> Haskell is awesome! :)
18:13:14 <pikhq> 'Tis.
18:14:26 <bgs100> @@ @elite @src product
18:14:26 <lambdabot>  Say again?
18:14:54 <bgs100> @@ @elite (@src product)
18:14:54 <lambdabot>  Say again?
18:16:25 <copumpkin> > scanl1 (+) [1,3..]
18:16:27 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
18:16:48 <monochrom> la Square numeroe
18:16:50 <hzap> @src foldr1
18:16:50 <lambdabot> foldr1 _ [x]    = x
18:16:50 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
18:16:50 <lambdabot> foldr1 _ []     = undefined
18:17:46 <copumpkin> now we need triangular numbers!
18:18:18 <copumpkin> > scanl1 (+) [1..]
18:18:20 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
18:18:22 <beutdeuce> Which one is more commonly used, foldr or foldl?
18:18:23 <copumpkin> zomg!
18:18:42 <copumpkin> beutdeuce: depends on what you need, but foldr is more "fundamental"
18:18:49 <copumpkin> and foldl' tends to be more common than foldl
18:19:03 <beutdeuce> :t foldl'
18:19:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:19:16 <copumpkin> it's the same as foldl but strict in its accumulator
18:19:25 <beutdeuce> k
18:19:26 <monochrom> Both foldl and foldr are equally commonly used.
18:20:10 <copumpkin> > scanl1 (+) [1,4..]
18:20:11 <lambdabot>   [1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,...
18:20:19 <copumpkin> zomg a pentagon!
18:21:31 <pikhq> > scanl1 (*) [1,3..]
18:21:33 <lambdabot>   [1,3,15,105,945,10395,135135,2027025,34459425,654729075,13749310575,3162341...
18:21:44 <pikhq> Yes, that's just silly.
18:22:04 <copumpkin> @oeis 1,3,15,105,945,10395
18:22:05 <lambdabot>  Double factorial numbers: (2n-1)!! = 1.3.5....(2n-1).
18:22:05 <lambdabot>  [1,1,3,15,105,945,10395,135135,2027025,34459425,654729075,13749310575,316234...
18:22:05 <monochrom> scanl can lead to stack overflow. you don't see it now because you force the individual items in the answer in a helpful order.
18:22:08 <copumpkin> lol
18:22:27 <pikhq> I stand corrected. Double factorial. :D
18:22:45 <kulakowski> Just because it has a name, doesn't mean it isn't silly
18:23:05 <monochrom> Most named things are silly.
18:23:07 <pikhq> kulakowski: Oh, right. *Math*.
18:23:11 <pikhq> Half of it is silly.
18:23:29 <pikhq> The other half is touched by those bloody "engineer" types that deal with real things.
18:24:11 <monochrom> In corporate culture there are lots of named silly things.
18:24:36 <mike-burns> "test driven development", for example. Ha!
18:24:52 <bgs100> In corporate culture there are lots of things named silly. :P
18:25:19 <beutdeuce> > foldr (\x c -> if even x then c+1 else c) 0 [1..100] -- amt. of even numbers between 1 and 100
18:25:21 <lambdabot>   50
18:25:30 <pikhq> monochrom: Corporate culture is about as abstract as most mathematics -- it just has shitty abstractions.
18:25:44 <monochrom> Anyway http://www.haskell.org/haskellwiki/Stack_overflow#Scans has my explanation of possible stack overflow with scanl
18:26:15 <pikhq> beutdeuce: Not bad.
18:26:19 <pikhq> Though I'd be tempted to write it as:
18:26:47 <pikhq> > length $ filter even [1..100]
18:26:48 <lambdabot>   50
18:28:14 <mmmulani> how are tuples compared?
18:28:29 <Zao> Lexicographical, I believe.
18:28:30 <pikhq> Uh.
18:28:34 <pikhq> @instance Eq
18:28:35 <lambdabot> Maybe you meant: instances instances-importing
18:28:40 <pikhq> @instances Eq
18:28:41 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:28:49 <Zao> > (42, 3) < (3, 7)
18:28:51 <lambdabot>   False
18:28:57 <pikhq> Guess they are instances of Eq.
18:29:28 <pikhq> Wait. Why wouldn't they be?
18:29:30 <pikhq> Nice thinko, me.
18:29:30 <bgs100> @@ @elite @slap <person>
18:29:31 <lambdabot>  //\/\3 p0kes <per5oN> in +|-|e 3ye
18:29:49 <mmmulani> Zao: thanks
18:30:25 <monochrom> @trap monochrom
18:30:26 <lambdabot> Maybe you meant: map slap
18:30:31 <monochrom> busted
18:32:52 <beutdeuce> when u want to define afunction to lambdabot, do u include type signature?
18:33:59 <monochrom> @slut monochrom
18:34:00 <lambdabot> Maybe you meant: let slap
18:34:05 <monochrom> busted again
18:34:42 <beutdeuce> @let filterLength :: (Num b) => (a -> Bool) -> [a] -> b
18:34:43 <lambdabot>  <local>:3:0:
18:34:44 <lambdabot>      The type signature for `filterLength' lacks an accompanyin...
18:35:16 <beutdeuce> @let filterLength :: (Num b) => (a -> Bool) -> [a] -> b ; filterLength f l = foldr (\x c -> if f x then c+1 else c) 0 l
18:35:18 <lambdabot>  Defined.
18:35:29 <beutdeuce> filterLength even [1..1000]
18:35:39 <beutdeuce> > filterLength even [242..23465]
18:35:42 <lambdabot>   11612
18:35:48 <Vanadium> Is there a standard name for \x -> case x of True -> 1 ; False -> 0?
18:36:00 <QinGW> >
18:36:01 <monochrom> Yes. C booleans.
18:36:11 <monochrom> I mean no.
18:36:17 <BMeph> > fromEnum True
18:36:19 <lambdabot>   1
18:36:23 <BMeph> > fromEnum False
18:36:25 <byorgey_> Vanadium: no, but it would be more concise to say 'if x then 1 else 0'
18:36:25 <lambdabot>   0
18:36:34 <Vanadium> BMeph: Oh. Thanks.
18:36:37 <byorgey_> oh... or fromEnum. =)
18:36:46 <Vanadium> byorgey_: I suppose so
18:37:02 <BMeph> Vanadium: Or even fromEnum. However, it's implementation-dependent. ;)
18:37:11 <byorgey_> fromEnum is a bit too opaque in this case for my tastes.
18:37:21 <caxaf> @pl \x -> if x then 1 else 0
18:37:21 <lambdabot> flip (flip if' 1) 0
18:37:38 <Vanadium> @src if'
18:37:39 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:37:41 <Vanadium> :|
18:37:44 <twanvl> how is fromEnum implementation dependent?
18:37:47 <caxaf> if' b x y = if b then x else y
18:38:03 <Vanadium> Ah
18:38:15 <olsner> > let 'if x y b = if' b x y in 'if 1 0 False
18:38:16 <lambdabot>   <no location info>:
18:38:17 <lambdabot>      lexical error in string/character literal at chara...
18:38:27 <olsner> > let if'' x y b = if' b x y in if'' 1 0 False
18:38:30 <lambdabot>   Not in scope: `if''
18:38:39 <BMeph> twanvl: It depends on "data Bool = False | True". If Bool were defined the other way, it'd still work the same, but the from/toEnum functions would be reversed.
18:38:44 <olsner> oh, bollocks
18:38:58 <copumpkin> BMeph: but the order is defined in h98 isn't it?
18:39:06 <twanvl> that would also break deriving Ord
18:39:13 <monochrom> The order ought to be set in stone.
18:39:33 <twanvl> > let (?) True= const; (?) _ = flip const in  True ? 1 $ 0
18:39:35 <lambdabot>   1
18:40:01 <pikhq> twanvl: Nice.
18:40:22 <twanvl> if' is probably nicer in practice
18:40:57 <twanvl> or bool, rather
18:41:00 <pikhq> But if' is a bit of Caleskell, isn't it?
18:41:01 <pikhq> ;p
18:41:06 <olsner> > let (?) True= const; (?) _ = flip const in (? 1 $ 0) True
18:41:08 <lambdabot>   The operator `?' [infixl 9] of a section
18:41:08 <lambdabot>      must have lower precedence th...
18:41:18 <Cale> pikhq: It's not mine
18:41:32 <monochrom> Calic Haskell
18:41:47 <monochrom> Calicism
18:41:49 <pikhq> > let (?) True = const; (?) _ = flip const in ((? 1) $ 0) True
18:41:50 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
18:41:51 <lambdabot>    arising from the literal `1'...
18:41:57 <pikhq> Curses.
18:42:12 <pikhq> That's some screwy stuff right there.
18:42:31 <monochrom> (? 1) True 0  is right
18:42:44 <twanvl> ?pl \a -> a?1$0
18:42:44 <lambdabot> flip (? 1) 0
18:43:09 <Petrosian`> Can I find an enumeration anywhere of the characters covered by the various "isX" predicates in Data.Char?
18:43:23 <bgs100> Hum.... One of the things I miss in haskell from common lisp, is when defining a function, There's nothing like &optional, &rest, or &key.... :P
18:43:41 <BMeph> Petrosian`: Yes. Next question? ;)
18:43:50 <twanvl> Petrosian`: in the Unicode standard
18:43:54 <pikhq> bgs100: NO N-ADIC FUNCTIONS.
18:43:57 <bgs100> Although, I suppose for &rest you could use a list
18:44:07 <bgs100> pikhq, H?
18:44:09 <bgs100> ?*
18:44:09 <lambdabot> Maybe you meant: . ? @ v
18:44:10 <copumpkin> optional you can use a Maybe :P
18:44:23 <pikhq> (that was random)
18:44:44 <bgs100> copumpkin, That's what I was thinking, but it'd be kinda annoying to use it all the time :P
18:53:41 <desp> @pl (\a b -> Vector1 (f a b))
18:53:41 <lambdabot> (Vector1 .) . f
18:53:49 <desp> Is there a more readable way to rewrite this?
18:54:16 <desp> @unpl (Vector1 .) . f
18:54:16 <lambdabot> (\ d h -> (Vector1) (f d h))
18:54:48 <BMeph> desp: Half-way it: \a -> Vector1 . f a
18:55:19 <desp> I thought it should be  Vector1 . f
18:55:46 <BMeph> desp: But that's: \a -> Vector1 (f a)
18:55:51 <desp> Yeah.
18:57:15 <desp> @hoogle (a -> a -> a) -> [a] -> [a] -> a
18:57:17 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
18:57:17 <lambdabot> Data.List foldl :: (a -> b -> a) -> a -> [b] -> a
18:57:17 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
18:57:34 <desp> @hoogle zipWith
18:57:35 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:57:35 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
18:57:35 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:01:17 <gwern> As ace reporter Jack Brannigan reported for duty, he racked the slide of his walther ppk. it soothed his amp-inflamed nerves to stroke the gun made iconic by James Bond; and dueling the Senatorial Guard for the right to a question was no picnic. He turned the corner into the press pool, and froze. Snakes! and rats! his least favorite security obstacle. It was clearly going to be another one of those days.
19:05:40 <pikhq> I have a complaint about Haskell.
19:05:56 <pikhq> A month ago, there were so many languages that seemed like they were doing cool and interesting things.
19:06:09 <pikhq> Now, I realise that Haskell beats them all.
19:06:33 <pikhq> And so, I look at, say, F# and think "Oh, so it's Haskell with a worse syntax".
19:06:40 <kulakowski> That's a complaint about every other language, not about Haskell.
19:06:50 <pikhq> Or LINQ and "Oh, so it's monads with a worse abstractions".
19:06:53 <pikhq> kulakowski: True.
19:06:59 <monochrom> Yes, Haskell makes you feel miserable and depressed about the real world.
19:07:54 <kulakowski> And the short version of the story is "ignorance is bliss".
19:07:56 <pikhq> And then I find out about arrows and wonder why in the world people haven't all just gotten up and joined a monastery -- I mean, learned Haskell.
19:08:07 <pikhq> kulakowski: No, it wasn't.
19:08:19 <ray> yeah, i considered joining a monestary
19:08:24 <pikhq> I write a lot in C.
19:08:24 <pikhq> There is no bliss to be had there.
19:08:25 <pikhq> :P
19:08:33 <impl> C has a certain elegance to it
19:08:39 <pikhq> ray: Misspelling or bad pun?
19:08:45 <impl> it's not like Haskell, to be certain
19:08:46 <ray> i cant spel
19:08:49 <pikhq> impl: For what it's meant to be used for, certainly.
19:08:56 <impl> Yeah.
19:09:07 <pikhq> It just gets used for a lot of stuff that it shouldn't be.
19:09:17 <kulakowski> pikhq: Well not C. But everything else *seemed* nice until you found out that it wasn't.
19:09:29 <pikhq> kulakowski: Hahah.
19:09:38 <pikhq> Actually, I still maintain that Tcl's nice.
19:09:44 <pikhq> ... For an imperative language.
19:10:02 <pikhq> And that's primarily because they've got a culture of crazy metaprogramming.
19:10:53 <kulakowski> I've never done much Tcl (just some hacked up expect stuff), but I think I know what you mean
19:10:57 <impl> I think I'd like TCL a lot more if my only experience with it weren't writing scripts for eggdrop bots
19:11:11 <pikhq> Eggdrop is a pretty bad library.
19:11:22 <pikhq> And it's completely at a disconnect from the actual Tcl community.
19:11:31 * impl isn't surprised
19:11:55 <pikhq> The actual Tcl community has fun doing things like, say, golfing lambda in Tcl.
19:12:01 <pikhq> (why they don't just add lambda is beyond me)
19:12:23 <SamB_XP_> pikhq: it would ruin the fun?
19:12:51 <ray> every non-haskell program is a clumsy attempt to hack around the fact that you aren't using haskell
19:12:54 <ray> or something
19:12:58 <pikhq> Actually, they've been arguing about the string representation of C-implemented procs.
19:13:04 <pikhq> XD
19:13:24 <pikhq> ray: Some more so than others.
19:13:27 <SamB_XP_> pikhq: easy! just use the address in hex notation!
19:13:34 <pikhq> SamB_XP_: I know!
19:13:48 <SamB_XP_> well, my other idea was funnier
19:13:52 <BMeph> C is excellent for writing BF implementations... ;)
19:13:58 <SamB_XP_> use the raw machine code!
19:14:17 <jdrake> Greetings
19:14:28 <pikhq> Address in hex is what the Tcl-in-500-lines-of-C hack did when it got used as a test bed for lambda in Tcl.
19:17:22 <jdrake> I have a function, bool2int, that I am trying to get to take 4 items from a list, but it falls on its face when the list is less than 4 length. Any ideas on how I can improve this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3054#a3054
19:17:49 <mike-burns> Use a pattern match to split the list.
19:18:02 <mike-burns> bool2int (a:b:c:d:[]) = ...
19:18:31 <mike-burns> Well, that will have the same issue.
19:18:38 <jdrake> I have tried a few things so far
19:18:46 <twanvl> consider: what is bool2int (x:xs) in terms of bool2int xs
19:19:21 <jdrake> twanvl: I am not entirely sure what you are trying to get me to think about.
19:19:25 <twanvl> bool2int xs = (fromBool (xs !! 0)) * 1 + {stuff depending on the rest of the list}
19:19:40 <twanvl> right?
19:19:45 <twanvl> you can write that as:
19:20:02 <CalJohn> I've written this implementation of fib :: [Integer] with the state monad: http://xrl.in/2qi6 What is an obvious way to simplify it (retaining the state monad)?
19:20:07 <twanvl> bool2int (x:xs) = (fromBool x) * 1 + {stuff depending xs}
19:20:20 <CalJohn> non-obvious ways are also good
19:20:58 <gwern> why is there a * 1 at all...
19:21:07 <jdrake> notice the pattern of 1,2,4,8
19:21:21 <twanvl> CalJohn: why do you want to use the state monad here?
19:21:24 <jdrake> I am converting 4 bools to a binary number
19:21:28 <pikhq> fib = evalState $ do return . fibs where fibs = 0:1:zipWith (+) fibs (tail fibs) -- :P
19:21:35 <CalJohn> twanvl: self education
19:21:37 <gwern> jdrake: which pattern would that be? even numbers or powers of two?
19:21:45 <gwern> or some other sequence...
19:21:48 <jdrake> powers of two, even numbers would include 6
19:21:50 <pikhq> Erm. fib n = ... returns $ fibs !! n
19:21:55 <gwern> @oeis 1 2 4 8
19:21:56 <lambdabot>  Powers of 2: a(n) = 2^n.
19:21:57 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
19:22:08 <jdrake> What is this @oeis thing?
19:22:22 <caxaf> @go oeis
19:22:23 <lambdabot> http://www.research.att.com/~njas/sequences/
19:22:24 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
19:22:35 <jdrake> twanvl: Are you suggesting that I just have the !! stuff after x entry using xs?
19:22:45 <Cale> jdrake: pretend that !! doesn't exist, for one ;)
19:23:17 <jdrake> Cale, I can't see any way of doing it with recursion (the 2^n pattern seems difficult to pass through)
19:23:20 <jdrake> So...
19:23:33 <gwern> jdrake: you just need to be a little more clever
19:23:41 <pikhq> CalJohn: On a more serious note, that looks about how you'd do it with the state monad
19:23:49 <Cale> jdrake: there is a straightforward way to do it recursively
19:23:52 <pikhq> (which is totally not the way to do it. :P)
19:23:57 <Cale> jdrake: or you can use a fold
19:24:05 <twanvl> jdrake: what if you knew   (fromBool (xs !! 1)) * 1 + (fromBool (xs !! 2)) * 4 + (fromBool (xs !! 3)) * 4?
19:24:07 <jdrake> Cale: I am not a folder :p
19:24:12 <gwern> > map (\(x,y) -> x^y) $ zip [2,4,8] [1..]
19:24:14 <lambdabot>   [2,16,512]
19:24:35 <jdrake> I do not know this zip
19:24:41 <gwern> > map (\(x,y) -> x^y) $ zip [2,4,8,16,32,64,128] [1..]
19:24:43 <lambdabot>   [2,16,512,65536,33554432,68719476736,562949953421312]
19:24:51 <Cale> jdrake: okay, so you have the base case right. Now suppose we have that bool2int xs = n. Can you think of a way to construct bool2int (x:xs) ?
19:24:59 <gwern> > zip [a,b,c,d,e] [1..]
19:25:01 <lambdabot>   [(a,1),(b,2),(c,3),(d,4),(e,5)]
19:25:14 <gwern> phew. I wasn't sure simplereflect could handle that!
19:25:46 <CalJohn> pikhq: apparently not.  Just realised that the entire fibInit function is redundant
19:25:50 <jdrake> Cale, I suppose cascading heads and tails
19:25:54 <Cale> jdrake: hm?
19:25:57 <gwern> jdrake: see the trick? I encode the index into the list entry, then the map can deconstruct it - normally a map couldn't figure out 'where' in the list it is
19:25:57 <pikhq> gwern: uncurry (^)?
19:26:13 <gwern> pikhq: hush you. if he doesn't know zip, he's not gonna know uncurry
19:26:13 <CalJohn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7254#a7255
19:26:21 <Cale> jdrake: Suppose we know that bool2int xs = 47, for example
19:26:21 <pikhq> gwern: Fair enough.
19:26:34 <jdrake> Cale, 4 bits only :p
19:26:34 <Cale> jdrake: What is bool2int (True : xs) ?
19:26:48 <Cale> jdrake: The length of the list shouldn't matter.
19:27:09 <gwern> I've always liked my little zip-map trick; I think it's clearer than any fold would be
19:27:11 <caxaf> jdrake: In Haskell things can often be more elegant if you solve for the general case and then make it specific.
19:27:51 <Cale> jdrake: It's twice that isn't it?
19:27:52 <jdrake> Cale, it would be False, True, True, True, True
19:28:03 <Cale> jdrake: huh?
19:28:06 <jdrake> oops
19:28:08 <Cale> jdrake: I'm not asking what xs is.
19:28:30 <jdrake> Cale, can we move to the indepth channel so I can focus a little easier?
19:28:34 <Cale> sure
19:28:58 * caxaf is not sure that's what -in-depth is for.
19:29:22 <Cale> that's fine, nobody is using it right now
19:29:28 <pikhq> gwern: For that, yeah. I was just about to write the equivalent out with foldr, and then I was like "Uh. I was about to do foldr on the tails of a list and some recursive folding and. OH GOD THATS SICK AND EVIL AND WRONG!"
19:29:42 <gwern> heh heh
19:29:52 <twanvl> gwern: (sum . zipWith (*) (map (2^) [0..]))  vs.  (foldr (\x y -> x + 2*y) 0), how is that better?
19:29:52 <pikhq> So, point demonstrated, sir!
19:29:53 <gwern> foldr is often less clear than map + auxiliary data
19:30:42 <gwern> twanvl: for starters, the zip clearly includes the exponentiation, which the fold doesn't
19:30:59 <gwern> (I mean, x + 2*y? I'll have to think about that one)
19:31:44 <twanvl> ok
19:31:54 <twanvl> maybe the pointfree style makes it uglier
19:32:56 <twanvl> this is better: sum [ x*2^p | (x,p) <- zip xs [0..] ]
19:34:18 <gwern> that's definitely better than the fold
19:34:51 <gwern> @check \xs -> (sum . zipWith (*) (map (2^) [0..])) xs == sum [ x*2^p | (x,p) <- zip xs [0..] ] xs
19:34:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a] -> a
19:35:18 <caxaf> @check \xs -> (sum . zipWith (*) (map (2^) [0..])) xs == sum [ x*2^p | (x,p) <- zip xs [0..] ]
19:35:19 <lambdabot>   "OK, passed 500 tests."
19:35:21 <_SamB_> hmm, that reminds me ...
19:36:23 * SamB wonders why that x-chat was listed as:
19:36:25 <SamB> 17440 tty1     TNl   57:09 xchat
19:36:27 <SamB> vs.
19:36:27 <pikhq> I just discovered that Yhc has a Javascript backend with reasonable bindings to the DOM.
19:36:32 <SamB> 24192 ?        SNsl   1:18 /usr/bin/xchat
19:36:42 <pikhq> My God, Haskell obsoletes everything.
19:37:14 <SamB> twanvl: so why bother with zip anyway ?
19:37:15 <CalJohn> please stop gushing :)
19:37:18 <gwern> pikhq: haskell has everything, but not everything is maintained or usable
19:37:31 <gwern> academia has no rewards for maintenace
19:37:48 <pikhq> Shame, too.
19:37:51 <SamB> gwern: that was for academia?
19:37:58 <gwern> wasn't it?
19:37:59 <twanvl> SamB: how would you do it without zip?
19:38:16 <SamB> twanvl: I'd use another |
19:38:21 <SamB> iirc
19:38:30 <twanvl> parallel list comprehension is evil
19:38:36 <SamB> oh?
19:38:36 <gwern> SamB: I'm pretty sure it wasn't commercial, and it's a bit ambitious for a amateur work
19:38:51 <caxaf> Has that notation been generalized at all, or is it just for lists?
19:39:02 <SamB> gwern: you have to pick *one* reason ?
19:39:09 <twanvl> it is too easy to mess up, and if you use a | instead of a , or vice versa, the typechecker will not catch your mistake
19:39:18 <caxaf> If it's just for lists then it is indeed evil-ish, because it stops us from getting monad comprehensions.
19:39:23 <pikhq> Only a year or two old, though; can't be too much cruft there.
19:39:36 <mike-burns> That's pretty old in Internet years.
19:39:40 <caxaf> Can it be made to work with Applicatives?
19:39:42 <SamB> @hoogle (a->b->c) -> [a] -> [b] -> [c]
19:39:43 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:39:43 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:39:43 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
19:40:01 * SamB was expecting another one
19:40:02 <pikhq> mike-burns: Not all that old in software years.
19:40:12 <gwern> pikhq: also, don't underestimate the disadvantage of being only for yhc, and not ghc
19:40:15 <SamB> @hoogle [a] -> [b] -> [(a,b)]
19:40:16 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
19:40:16 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
19:40:16 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (a -> d -> (a, d)) -> a -> d -> (a, d)
19:40:22 <gwern> I'd bet at least half of hackage won't work out of the box on yhc
19:40:28 <SamB> where's the darn cartesian product?
19:40:50 <caxaf> @hoogle [a] -> [b] -> [a -> b -> c] -> [c]
19:40:51 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:40:51 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:40:51 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
19:41:09 <pikhq> gwern: It's running in freaking Javascript; it's not like there's too much useful outside of the DOM there, anyways.
19:41:38 <gwern> admittedly, I doubt one would use most of hackage in something you're compiling to JS, but that's still something sucking the oxygen oiut of the yhc fire. networke ffects y'know
19:41:41 <sjanssen> gwern: I'd wager a much larger percentage doesn't build on yhc
19:41:44 <mike-burns> Ah, but is it cross-browser compatible?
19:42:05 <pikhq> mike-burns: Yes.
19:42:11 <gwern> sjanssen: which makes my not-working bet a safe one then :)
19:42:26 <caxaf> SamB: I don't think there is a function for that, is there?
19:42:37 <caxaf> > sequence [[1,2],[3,4]]
19:42:39 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
19:42:40 <SamB> pikhq: what about ... Network.Http and Text.Xml ?
19:42:41 <beutdeuce> i'm surprised as to how functional ruby can get
19:42:44 <sjanssen> in my (very limited) experience with yhc, it even had some trouble with Haskell '98 code
19:42:57 <SamB> caxaf: I guess not :-(
19:43:09 <SamB> sjanssen: with or without the MR?
19:43:15 <SamB> the MR is pretty tricky :-(
19:43:17 <caxaf> SamB: At least Network.Http would have to be reimplemented completely if it were to use XmlHttpRequest (ugh).
19:43:19 <mike-burns> beutdeuce: There's a lot of use of #map and #select in Ruby.
19:43:32 <SamB> caxaf: was kidding
19:43:39 <beutdeuce> mike-burns: as well as lambdas and the whole do block abstraction
19:43:53 <mike-burns> Oh and #inject.
19:44:13 <dolio> They should use #collect.
19:44:15 <lament> select, collect, detect, reject, inject, surject, object, protect, perfect, dissect
19:44:17 <dolio> Stick to their smalltalk roots.
19:44:18 <pikhq> SamB: Network.XMLHTTP is provided. :P
19:44:25 <SamB> caxaf: obviously you can't implement a library with that interface with the much-less-flexible XHR
19:44:28 <pikhq> (for purposes of AJAX, I'd imagine)
19:44:31 <mike-burns> dolio: They do, but when I write it I use the #map alias.
19:44:47 <SamB> I mean, I don't remember how XHR works but it'd be odd if it weren't less flexible ;-)
19:44:48 <caxaf> mike-burns: #inject is foldl, right?
19:44:56 <dolio> Yes.
19:44:57 <mike-burns> caxaf: Yes, and there is no foldr.
19:45:05 <SamB> pikhq: well, yes, that's what XHR is for ;-)
19:45:08 <mike-burns> beutdeuce: And don't forget Ruby's list monad! http://mikeburnscoder.wordpress.com/2009/05/30/powerset-in-ruby-using-the-list-monad/
19:45:13 <caxaf> And there are no linked lists...
19:45:19 <beutdeuce> good call :)
19:45:59 <caxaf> Hmm, monads could probably be implemented almost-workingly as mixins in Ruby.
19:46:08 <mike-burns> ... I hadn't even thought of that.
19:46:10 <mike-burns> Huh.
19:46:26 <mike-burns> Wait, no, that wouldn't make sense.
19:46:29 <gwern> didn't whatshisface do monads in ruby?
19:46:32 <gwern> I forget how
19:46:52 <mike-burns> mentalguy?
19:47:11 <gwern> looks like there're several attemptz
19:47:20 <dolio> You use explicit dictionary passing.
19:47:26 <mike-burns> There's a lot of Rubyists who play with Haskell.
19:47:43 <dolio> Possibly with some tricks.
19:47:47 <beutdeuce> mike-burns: came from Ruby :)
19:47:59 <mike-burns> beutdeuce: It's my day job.
19:48:23 <beutdeuce> mike-burns: what a coincedence. I'm interning for the Alt-law project.
19:48:42 <beutdeuce> which is how i got to know clojure
19:48:46 <beutdeuce> and functional programming
19:48:52 <mike-burns> Oh awesome.
19:48:55 <beutdeuce> then i said, what other fpl's are there
19:48:59 <beutdeuce> then i stumbled upon Haskell
19:49:04 <beutdeuce> and here i am :)
19:49:07 <caxaf> "Mixins" correspond to type classes reasonably well, right?
19:49:17 <caxaf> Well, except people ignore the "type" part in Ruby.
19:49:20 <mike-burns> caxaf: We don't have anything that corresponds to typeclasses.
19:49:21 <beutdeuce> caxaf: yes, to a certain degree
19:49:40 <mike-burns> Typeclasses are more like OO's interfaces, and Ruby doesn't have those.
19:49:43 <CalJohn> beutdeuce: altlaw uses clojure?
19:49:54 <dobblego> mike-burns, type-classes are very much not like OO interfaces
19:49:57 <beutdeuce> CalJohn: alt-law's backend is 80% clojure :)
19:50:10 <gwern> what is alt-law?
19:50:11 <mike-burns> dobblego: They're more like mixins than interfaces?
19:50:27 <dobblego> mike-burns, they are more like implicit conversions/arguments than interfaces
19:50:34 <CalJohn> gwern: a search engine for appellate court cases
19:50:43 <gwern> ah
19:50:51 <beutdeuce> gwern: an open-source alternative to $$$ ones
19:50:53 <mike-burns> dobblego: I don't follow.
19:51:11 <mike-burns> dobblego: Oh I kinda follow.
19:51:16 <Vanadium> "powerset = filterM (const [True, False])" scares me
19:51:24 <gwern> beutdeuce: I figured it'd be open-source; I couldn't see studly FP hackerly types throwing in on another evil legal corporate site
19:51:36 <beutdeuce> dobblego: mixins are more like modules mixed with classes
19:51:39 <dobblego> mike-burns, a type-class is implicit dictionary passing; an OO interface is more like newtype I = I { method1 :: X -> Y }
19:51:46 <beutdeuce> gwern: :P
19:51:55 <pikhq> Vanadium: As it should.
19:51:55 <CalJohn> gwern: as far as I know, there is actually a lot of non-foss fp work
19:52:08 <caxaf> Vanadium: It shouldn't be that scary. Think of what filterM does, what a power set is, and what the list monad means.
19:52:14 <pikhq> gwern: See: Microsoft.
19:52:36 <caxaf> Vanadium: (The list monad corresponds to computations that return multiple values.)
19:52:47 <mike-burns> dobblego: So back to the question I was responding to, are typeclasses like mixins?
19:52:51 <gwern> I think the closed FP stuff is outweighed by the open; MS doesn't use FP all that much internally - I've heard it's like, a driver model checker
19:52:54 <dobblego> mike-burns, no
19:53:00 <mike-burns> dobblego: So we're in agreement.
19:53:05 <tkr> about the tutorial again. fromIntegral has wrong type class on the types-and-typeclasses page. who should I tell about these to? I think Ill try to follow slowly (but surely) the whole tutorial true.
19:53:09 <dobblego> mike-burns, Ruby has no equivalent
19:53:15 <Vanadium> I was trying to play around with filterM to get an intuition for what it does to lists, but I am not sure I get it.
19:53:17 <beutdeuce> mike-burns: mixins are "kind-of" like Haskell modules mixed into classes
19:53:20 <dobblego> mike-burns, on that point, yes
19:53:29 <beutdeuce> or to whomever is wondering, i forgot o.0
19:53:54 <CalJohn> gwern: outweighed is an interesting idea.  Seems to me that almost all commercial fp is non-foss
19:53:55 <mike-burns> tkr: Which tutorial?
19:53:58 <tkr> ops. type declaration that is. Im not yet so familiar what you guys call things with my perl background.
19:53:58 <dobblego> mixins are more like tuples
19:54:07 <tkr> mike-burns: learnyouahaskell.com
19:54:07 <Vanadium> Oooh. Crazy.
19:54:35 <caxaf> Vanadium: Well, what does filter do?
19:54:37 <beutdeuce> http://altlaw.org/
19:54:38 <mike-burns> tkr: You should send your feedback for that to BONUS.
19:54:40 <Vanadium> tkr: learnyouahaskell is by BONUS
19:55:07 <beutdeuce> @seen BONUS
19:55:07 <lambdabot> BONUS is in #haskell. I last heard BONUS speak 9h 48m 3s ago.
19:55:07 <Vanadium> caxaf: It filters. That appears easy so far.
19:55:16 <tkr> ok. Ill try to remember these and tell him. thanks.
19:55:16 <caxaf> Vanadium: For each value in the list, it uses the function you give to decide whether it should be in the list or not. Yes?
19:55:18 <Vanadium> I think the whole lists-as-a-monad thing is scaring me right now.
19:55:34 <mmorrow> @src [] (>>=)
19:55:34 <lambdabot> xs >>= f     = concatMap f xs
19:55:47 <mmorrow> @src concatMap
19:55:48 <lambdabot> concatMap f = foldr ((++) . f) []
19:56:10 <caxaf> Vanadium: Ignore the word "monad" if you like. :-) Just think of "[] a" as "a computation that can return more than one a".
19:56:13 <mmorrow> (\f -> concat . map f)
19:56:30 <caxaf> Someone should make lambdabot's @src database nicer.
19:56:41 <mike-burns> caxaf: With regard to making monads a mixin in Ruby: what besides list (really Array) would have monadic methods defined on it?
19:56:55 <pikhq> Vanadium: The word "monad" is like a Zen koan.
19:57:07 <pikhq> You don't get it, and then you do.
19:57:08 <caxaf> @instances Monad
19:57:09 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:57:10 <dobblego> mike-burns, forall t. (t ->)
19:57:10 <Vanadium> I am okay with monads as long as they refrain from returning more than one value.
19:57:11 <lament> The word monad is like an analogy.
19:57:28 <pikhq> lament: :)
19:57:31 <copumpkin> @src ArrowMonad
19:57:31 <mike-burns> dobblego: I don't know that this is possible in Ruby.
19:57:31 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:57:34 <copumpkin> never heard of that
19:57:45 <ray> sounds cool
19:57:49 <pikhq> ArrowMonad?
19:57:49 <ray> i like arrows, i like monads
19:57:57 <dobblego> mike-burns, it is, in a degenerate sense
19:58:06 <caxaf> Vanadium: Monads don't "return" anything.
19:58:08 <caxaf> They are a type.
19:58:10 <ray> it certainly fits haskell better
19:58:22 <pikhq> But all monads can be shoved into arrows already! Abstracting the monads into arrows into monads? MUST BE AWESOME!
19:58:23 <CalJohn> caxaf: I don't understand that powerset function either
19:58:42 <caxaf> "data M a = M" is a monad (though not very interesting).
19:58:47 <ray> arrows of arrows of kleisli arrows of arrows
19:58:48 <ray> or something
19:58:58 <pikhq> ray: YAY!
19:59:04 * pikhq just found out about arrows today, BTW
19:59:06 <CalJohn> caxaf: I can't see the effect of filtering by (const [True, False])
19:59:11 <CalJohn> caxaf: how is it a monad?
19:59:11 <ray> they sure are cool
19:59:12 <tkr> so haskell has no anykind of type casting since the tutorial tells one to do fromIntegral (length [1,2]) + 3.2  to get past the problem that length is of a type Int ? (is it wrong to say that length returns the type Int here?)
19:59:20 <CalJohn> caxaf: it doesn't have bind or unit defined
19:59:21 <desp> "Illegal type synonym family application in instance:"
19:59:21 <copumpkin> filterM'ing
19:59:22 <caxaf> CalJohn: How is what a monad?
19:59:24 <mmorrow> @src (->) (>>=)
19:59:24 <lambdabot> f >>= k = \ r -> k (f r) r
19:59:27 <caxaf> CalJohn: [] is a monad.
19:59:28 <desp> Does anyone know what causes this error?
19:59:32 <mmorrow> @src (->) return
19:59:32 <lambdabot> return = const
19:59:36 <caxaf> CalJohn: And (>>=)/return are defined on it.
19:59:37 <sjanssen> tkr: length does have type [a] -> Int, yes
19:59:38 <CalJohn> caxaf: but "data M a = M" is not?
19:59:45 <caxaf> CalJohn: Oh, that. Yes, it is.
19:59:46 <mike-burns> tkr: Right, but we do have typeclasses.
19:59:51 <caxaf> I just didn't type out the definitions. :-)
19:59:57 <ray> if you know about the s and k combinators, those are the s and k combinators
19:59:58 <tkr> mike-burns: type casting I was asking about
20:00:01 <CalJohn> caxaf: please explain
20:00:05 <mmorrow> instance Monad M where return _ = M; _ >>= _ = M
20:00:09 <caxaf> return :: a -> M a; return x = M
20:00:10 <sjanssen> tkr: you're right that there is no "type casting" as such, especially no implicit conversions
20:00:22 <tkr> ok thanks.
20:00:31 <caxaf> (>>=) :: M a -> (a -> M b) -> M b; m >>= f = M
20:00:34 <ray> not the snk combinator, however, which is what happens when you put a cartridge into your neo-geo
20:00:40 <mike-burns> Ha.
20:01:01 <SamB> I can has capcom combinator?
20:01:13 <CalJohn> caxaf: sorry, can we move to -in-depth?
20:01:24 <CalJohn> oh, it is being used
20:01:25 <caxaf> Er, -in-depth has a policy against monad tutorials.
20:01:26 <CalJohn> nevermind
20:01:31 <ray> -overflow
20:01:44 <ray> i don't think you're overflowing though
20:02:01 <mike-burns> I can be more quiet while powerset is explained.
20:02:10 <CalJohn> caxaf: ok, so now you have defined bind and unit on it, it is a monad
20:02:17 <SamB> who's move is powerset?
20:02:41 <caxaf> Move?
20:02:46 <dobblego> CalJohn, the "M" in data M a is what makes the monad -- it is called a type constructor
20:02:55 * SamB is still doing the game joke
20:03:00 <CalJohn> caxaf: so what is the use of filtering by (const [True, False]
20:03:14 <CalJohn> dobblego: yes, but monads need bind and unit
20:03:23 <caxaf> CalJohn: filtering by that -- not much. filterM-ing is more useful. :-)
20:03:27 <dobblego> CalJohn, yes and three laws -- but the M is what makes the monad
20:03:33 <ray> technically, they need join and unit
20:03:33 <BMeph> CalJohn: Check the types for filterM
20:03:33 <CalJohn> dobblego: nevermind, i think we're past that
20:03:41 <Vanadium> Why will lambdabot not give me the source to filterM?
20:03:43 <caxaf> ray: And fmap.
20:03:46 <copumpkin> :t filterM
20:03:48 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:03:52 <dobblego> caxaf, no, this is implied
20:03:55 <ray> well, they have to be functors
20:03:57 <Gracenotes> -overflow, lol
20:04:02 <ray> in haskell you need fmap
20:04:02 <caxaf> dobblego: ?
20:04:28 <dobblego> @type \f x -> x >>= return . f -- caxaf
20:04:29 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
20:04:30 <gwern> Gracenotes: if people would just stop using Int!
20:04:40 <ray> because to have a functor on Hask you need a type constructor (to map objects to objects) and fmap (to map morphisms to morphisms)
20:04:41 <BMeph> CalJohn: filterM wants a function (a -> m Bool). const [True, False] is type (a -> [Bool]). Does that help? :)
20:04:45 <Gracenotes> D:
20:04:55 <gwern> Vanadium: @src is a manual database of definitions; if something you want isn't there, send a patch
20:05:12 <CalJohn> BMeph: it makes me think, but i haven't quite got it yet
20:05:17 <Gracenotes> gwern: off-topic but Higurashi is making less and less sense and starting to become depressing
20:05:18 <ray> and a monad is a functor, join, and unit (pursuant to some laws)
20:05:38 <gwern> Gracenotes: I know the feeling. around episode 15 now, I'm guessing?
20:05:50 <Gracenotes> finished episode 21
20:05:59 <Gracenotes> that's the end of Shion's arc
20:06:21 <gwern> Gracenotes: ah. I forget, was that the original, or the behind-the-scenes version of that arc?
20:06:32 <Gracenotes> latter.
20:06:59 <gwern> I thought that was the bee's knees. I always love that sort of thing - you thought A was happening, but all along it was B!
20:07:17 <caxaf> dobblego: Oh, I was responding to ray. Never mind. :-)
20:07:38 <caxaf> @let powerSet = filterM (const [True,False])
20:07:41 <lambdabot>  Defined.
20:07:43 <caxaf> > powerSet [1,2,3]
20:07:46 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
20:07:51 <Gracenotes> I don't yet get the arcs' relations to each other, because they are obviously contradictory. but I'll see...
20:08:06 <caxaf> CalJohn: Note that for each element, it's in half the lists and not the other half.
20:08:10 <caxaf> Right?
20:08:30 <CalJohn> caxaf: right
20:08:53 <caxaf> CalJohn: The normal filter gets an element and says whether or not it should be in the resulting list.
20:08:58 <CalJohn> right
20:09:03 <gwern> Gracenotes: this may be a bit spoilerish, but each one has the same sinister enemy working behind the scenes; you're supposed to try to figure it out before the central character does
20:09:09 <gwern> mystery games, remember
20:09:34 <caxaf> CalJohn: filterM in the [] monad, however, can say at the same time that it should and shouldn't be in the resulting list(s).
20:09:54 <caxaf> CalJohn: ("list(s)" because m [a] = [[a]].)
20:10:36 <caxaf> CalJohn: So for each element, it's saying "both include this element, and don't include it".
20:10:43 <CalJohn> caxaf: but what happens then?
20:10:50 <caxaf> CalJohn: (It ignores the value of the element itself -- that's what the const does.)
20:12:57 <caxaf> CalJohn: Did you see the definition of filterM?
20:13:16 <Vanadium> Oh, someone gave one?
20:13:19 <CalJohn> I will look now, I have seen the type
20:13:47 <mike-burns> @src filterM
20:13:47 <lambdabot> Source not found. :(
20:14:06 <caxaf> filterM          :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:14:06 <caxaf> filterM _ []     =  return []
20:14:06 <caxaf> filterM p (x:xs) =  do flg <- p x ys  <- filterM p xs return (if flg then x:ys else ys)
20:14:19 <caxaf> Hmm, that didn't paste quite right. Anyway...
20:14:29 <caxaf> Do you know how <- does a cartesian product in []?
20:14:33 <Vanadium> p x >>= \result -> myFilterM p xs >>= \rest -> return $ if result then x : rest else rest
20:14:37 <Vanadium> :toot:
20:15:00 <CalJohn> caxaf: no, I don't
20:15:11 <caxaf> Well, it's like list comprehensions.
20:15:34 <caxaf> Lists, or computations that return multiple values, roughly correspond to "for each".
20:15:37 <BMeph> Try:   filterM p (x:xs) =  do { flg <- p x;  ys  <- filterM p xs;  return (if flg then x:ys else ys) }
20:17:27 <caxaf> CalJohn: So, in that definition, p x is always [True,False], right?
20:17:36 <CalJohn> caxaf: yes
20:18:47 <CalJohn> but is that equivalent to True or False?
20:18:50 <caxaf> > let ourF _ [] = return []; ourF p (x:xs) =  do { flg <- p x;  ys  <- ourF p xs;  return (if flg then x:ys else ys) } in ourF (const [True,False]) [1,2,3]
20:18:52 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
20:19:01 <caxaf> CalJohn: I tis equivalent to both. :_)
20:19:53 <CalJohn> but what happens then?
20:20:08 <caxaf> > let ourF [] = return []; ourF (x:xs) =  do { flg <- [True, False]; ys <- ourF xs; return (if flg then x:ys else ys) } in ourF [1,2,3]
20:20:10 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
20:20:14 <caxaf> Do you see how that is the same?
20:21:01 <mike-burns> (Keep in mind that >>= is concatMap here.)
20:21:16 <CalJohn> hold on, am reading
20:21:17 <caxaf> > let ourF [] = return []; ourF (x:xs) = [if flg then x:ys else ys | flg <- [True,False], ys <- ourF xs] in ourF [1,2,3]
20:21:19 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
20:21:36 * caxaf feels that he's way overcomplicating this.
20:21:56 <caxaf> "It's just like filter, except it both includes and doesn't include each element."
20:22:14 <CalJohn> I "sort of" see how they are the same
20:22:25 <caxaf> CalJohn: I just inlined and executed p.
20:22:29 <CalJohn> yes
20:22:35 <caxaf> CalJohn: Then translated do-notation to a list comprehension.
20:23:25 <CalJohn> i still feel like I am not sure what happens when the predicate is true and false
20:23:36 <CalJohn> sorry I am being slow
20:24:22 <caxaf> Hmm, let's do the cartesian product ourselves.
20:24:36 <caxaf> What is [True,False] x [1,2,3]?
20:24:49 <caxaf> (That's not what is being done in the function, but start with that.)
20:24:56 <gfreeman> How do you flush standard output?
20:24:59 * caxaf wonders if -overflow would be a better place to go to.
20:25:06 <CalJohn> gfreeman: hFlush stdout
20:25:30 <gfreeman> CalJohn: That's in System.IO, right? Why isn't there a "flush" in Prelude?
20:25:57 <caxaf> gfreeman: ...Because it's defined that way.
20:26:17 <CalJohn> gfreeman: I really have no idea, sorry...busy trying to get obviously simple concept
20:26:19 <caxaf> If you want to do non-completely-trivial IO, import the appropriate module. :-)
20:26:40 <gfreeman> It's just... unnerving to have programs give "unexpected" output, when the order has been specifically sequenced.
20:27:06 <gfreeman> After all, that's why it's in IO right?
20:27:08 <caxaf> gfreeman: You can hSetBuffering stdout NoBuffering if you like.
20:27:09 <CalJohn> gfreeman: then either close the handle, or use the with wrapper
20:27:36 <CalJohn> caxaf: I'm sorry, I'm not sure how to apply [True,False] x to [1,2,3]
20:27:46 <CalJohn> wait, ignore previous dumb comment
20:27:47 <caxaf> Sorry, that x is a cartesian product.
20:28:07 <gfreeman> CalJohn : [(True, 1), (False, 1), (True, 2), (False, 2), (True,3), (False, 3)]
20:28:18 <CalJohn> [[True,1],[True,2],[True,3],[False,1],[False,2],[False,3]]
20:28:30 <CalJohn> erk, well, should have used tuples :)
20:28:53 <CalJohn> either way, that is the cartesian product
20:29:08 <caxaf> It actually ends up being lists in our context. :-)
20:29:46 <caxaf> Er, except not. Never mind.
20:29:53 <caxaf> (That's not even a valid type.)
20:30:07 <caxaf> But, anyway, that's what a list comprehension does, right?
20:30:09 <CalJohn> caxaf: I sat there confused for a while until i realised that it was a cartesian product, sorry.  i am giving this my full attention
20:31:13 <caxaf> > let ourF [] = return []; ourF (x:xs) = [if flg then x:ys else ys | flg <- [True,False], ys <- ourF xs] in ourF [1,2,3]
20:31:15 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
20:31:26 <caxaf> Does that definition make sense?
20:31:28 <CalJohn> so part of what we actually get is [[True, 1],[False,1]
20:31:43 <caxaf> CalJohn: No part -- that list doesn't type-check.
20:32:38 <aavogt> > instance Num Bool where ...
20:32:39 <CalJohn> yes, except I am not certain how flg is of type Bool
20:32:39 <lambdabot>   <no location info>: parse error on input `instance'
20:32:48 <ProfessorBob> Hi guys
20:33:01 <mmorrow> , id =<< [[0..4],[5..9]]
20:33:04 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
20:33:05 <ProfessorBob> Any expert programmers here
20:33:09 <ProfessorBob> I have a job
20:33:10 <ProfessorBob> for you
20:33:26 <impl> Nope, none here. Sorry.
20:33:32 <ProfessorBob> OK
20:33:39 <pikhq> Only us amateurs.
20:33:45 * pikhq puts away Control.Arrow
20:33:57 <ProfessorBob> i'm not a progressor
20:34:01 <ProfessorBob> professor
20:34:04 <ProfessorBob> im 18 lol
20:34:06 <mmorrow> ProfessorBob: does it involve Norad, DEFCON levels, and global thermonuclear war?
20:34:14 <ProfessorBob> no
20:34:33 <impl> NORAD would be so awesome if it could do more things than track Santa.
20:34:37 <pikhq> ProfessorBob: I strongly suggest learning good IRC style.
20:34:39 * pikhq = 19
20:34:48 <ProfessorBob> ;)
20:35:01 <ProfessorBob> Anyone know about visual basic programming
20:35:09 <mike-burns> ProfessorBob: Wrong channel.
20:35:12 <pikhq> First, don't insert random, spurious newlines. It's very annoying. Only use them for ends of statements.
20:35:12 * CalJohn types /ignore
20:35:25 <BMeph> I've heard rumors, but I saw pics, or it didn't happen. ;p
20:35:26 <pikhq> Second, wrong channel.
20:35:28 <impl> Guys. He's a troll.
20:35:31 <impl> Come on
20:35:34 <ProfessorBob> what
20:35:45 <ProfessorBob> who is admin here
20:35:57 <impl> See? Told you.
20:36:01 <pikhq> impl: That much is clear.
20:36:11 <ProfessorBob> can you tell me which channel to go for visual basic programming
20:36:17 <inimino> maybe he's just a newbie :-)
20:36:19 <ProfessorBob> I'm not a troll either
20:36:19 <mmorrow> ProfessorBob: so what is the job?
20:36:33 <ProfessorBob> The job is making a program with me
20:36:35 <mike-burns> ProfessorBob: My guess is #vb but I don't actually know.
20:36:35 <impl> ProfessorBob: First mistake of the amateur troll. Admitting you know what trolling is.
20:36:38 <ProfessorBob> that will bring us money
20:36:39 <pikhq> I like to give a couple nibbles, just in case it's a misguided newbie, and not a troll, though.
20:36:40 <impl> ProfessorBob: Noob. Go away.
20:36:40 <caxaf> ProfessorBob: channel9.msdn.com
20:36:50 <inimino> he is asking about VB after all
20:37:03 <mcglk> That seems punishment enough, doesn't it?
20:37:08 <pikhq> ProfessorBob: I've got a paying sysadmin job already, and it involves no Visual Basic.
20:37:09 <pikhq> Sorry.
20:37:12 <Justice> do VB people know about IRC?
20:37:18 <glomarexplorer> ProfessorBob was just trolling in #math
20:37:20 <pikhq> Justice: Some do.
20:37:20 <impl> I'm afraid so, yes
20:37:27 <ProfessorBob> no i wasn't
20:37:49 <ProfessorBob> why u guys noobs ;(
20:37:50 <inimino> trollfail
20:37:50 <mike-burns> I don't know how, but legitimate non-trolls sometimes stumble in here. Doesn't make sense to me.
20:37:54 <glomarexplorer> and since I see VB discussion in #haskell
20:38:01 <glomarexplorer> ... draw your own conclusion
20:38:08 <ProfessorBob> this is teh programming chat room
20:38:14 <ProfessorBob> i'm asking about VB
20:38:24 <ProfessorBob> So anyone know or you guys noobs
20:38:25 <Cale> ProfessorBob: It's not just programming. It's specifically programming in the language Haskell. Not VB.
20:38:35 <ProfessorBob> visual basic is a programmign luangage
20:38:44 <ProfessorBob> and this is the programming room
20:38:51 <mmorrow> ProfessorBob: the only way out of the hole is to describe how you are going to make millions and rule the world with your devious scheme
20:38:54 <Cale> Yes, probably most of us do. This is not the general programming room though.
20:38:57 <Justice> wait ... wait ... hold on a minute! Haskell is a programming language?
20:39:10 <pikhq> > foldr (*) 1 [2..]
20:39:12 <lambdabot>   * Exception: stack overflow
20:39:13 <ProfessorBob> I said this is the programming room
20:39:19 <Justice> i thought this was the Mr. Curry fan club room
20:39:22 <Cale> ProfessorBob: But you were wrong.
20:39:25 <mike-burns> Justice: I'm sorry you had to find out this way.
20:39:26 <pikhq> Justice: I thought it was a typed lambda calculus.
20:39:28 <ProfessorBob> how am i wrong?
20:39:31 <olsner> Justice: it will be a programming language if it succeeds, but you know the haskell motto :)
20:39:33 <impl> SO GUYS
20:39:38 <impl> How about those monads?
20:39:48 <Cale> ProfessorBob: It's about Haskell specifically.
20:39:50 <inimino> Justice: no, no, that's Visual Basic
20:39:54 <lpsmith> impl:  what kind of monad do you want to know about?  :-)
20:39:58 <mike-burns> Oh right, we were discussing powerset using the list monad.
20:40:03 <Justice> yeah those monads really itch ... shoulda worn protection
20:40:08 <impl> ^^
20:40:47 <ProfessorBob> where the hell is the programming room
20:40:59 <mike-burns> ProfessorBob: I'd guess #programming.
20:41:02 * hzap shoots a Kleisli arrow at ProfessorBob
20:41:06 * mmorrow is waiting for ProfessorBob to unfold his plans for global domination
20:41:15 <Cale> ProfessorBob: Or seeing as you're looking for VB, ##vb.net
20:41:15 * impl mutters something about feeding the trolls
20:41:18 <ProfessorBob> I got a plan to hack google
20:41:21 <mike-burns> ProfessorBob: But that's not a good place to hire people. Try the Craigslist job board.
20:41:28 <Cale> ProfessorBob: wonderful. Take it elsewhere.
20:41:32 <ProfessorBob> i was joking
20:41:35 <ProfessorBob> n00b
20:41:43 * pikhq mutters something about being more competent at the age of 8
20:41:44 <ProfessorBob> anyway wat u guys talking about
20:41:45 --- mode: ChanServ set +o Cale
20:41:49 <Cale> bye
20:41:51 <mmorrow> ProfessorBob: you have probably one more try avoid the kickbban
20:41:56 --- mode: Cale set +b *!*@pool-71-172-173-171.nwrknj.east.verizon.net
20:41:57 --- kick: ProfessorBob was kicked by Cale (Cale)
20:42:00 --- mode: Cale set -o Cale
20:42:05 <mmorrow> s/1/0/
20:42:13 <pikhq> s/0/-1/
20:42:15 <lpsmith> Anyone want to see a concurrency monad?
20:42:24 <impl> Yes.
20:42:25 <olsner> he did have a try, seems he was slightly too slow though :)
20:42:26 <pikhq> lpsmith: I'm intrigued.
20:42:26 <mike-burns> Sure!
20:42:29 <mmorrow> lpsmith: why yes
20:42:36 <olsner> 5s should be enough for anyone with a plan to hack google!
20:42:44 <copumpkin> lpsmith: how would it work?
20:42:49 <pikhq> olsner: ... Hack... Google?
20:42:53 <aavogt> do tell
20:42:55 <mmorrow> olsner: yeah, not much of a salesman
20:43:12 <pikhq> I'm sorry I'm not in #math much.
20:43:13 <lpsmith> gimme a second to hpaste it
20:43:19 <olsner> pikhq: scroll up, "<ProfessorBob> I got a plan to hack google" :)
20:43:42 <mcglk> Thanks, Cale.
20:43:56 <copumpkin> whoa, who's putting pascal/delphi on hpaste?
20:44:01 <copumpkin> that's random
20:45:03 <mmorrow> copumpkin: hah, sweet
20:45:50 <vav> copumpkin: co worker asked me for a "passkl" pastebin and I thought she said haskell pastebin. ;)
20:48:14 <ray> hascal?
20:48:37 <copumpkin> lpsmith: we're getting blue balls here!
20:49:31 <lpsmith> sorry :-)
20:49:44 <lpsmith> it works via continuations, of course :-)
20:50:08 <pikhq> ... Your hpaste?
20:52:21 <lpsmith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7256#a7256
20:52:40 <ray> thank god, finally
20:53:20 <lpsmith> it can handle an arbitrary number of "threads",  which all share a single state variable
20:53:44 <lpsmith> oh,  and you pick the schedule
20:53:50 <copumpkin> :o
20:53:53 <lpsmith> the scheduler is pretty primitive that way
20:54:00 <mmorrow> i did a brief description of and test implem (short, only the essential part) of how the dynamic linker intercepts yet-to-be-resolved references and resolves them (essentially the exact same idea as updating a thunk) if anyone is interesting in this kind of thing http://moonpatio.com/repos/dynlink.s
20:54:01 <mmorrow> it's pretty neat actually how it works
20:54:35 <copumpkin> yeah, they're actually called thunks too :)
20:56:11 <copumpkin> lpsmith: wouldn't an array be nicer?
20:56:37 <BMeph> mmorrow: Looks like Forth. ;)
20:57:30 <lpsmith> copumpkin:  sure, why not?
20:57:57 <lpsmith> A list was sufficient for my purposes though.   This was basically a final project for a class
20:58:02 <copumpkin> ah :)
20:58:15 <lpsmith> Well that and I transliterated this all into a theorem prover and proved the prop_
20:59:03 * BMeph gives lpsmith is theorem prover props...er, so-to-speak. ;)
20:59:10 <BMeph> *his
21:00:46 <mmorrow> lpsmith: this is an interesting paper, which is related.. also they implemented a complete webserver with a custom scheduler that uses posix aio *in haskell* and i just happened to stumble across it (dunno why this code isn't widely known (i had to hack it slightly to get it built iirc)). anyways, this just reminded me of it http://www.seas.upenn.edu/~lipeng/homepage/papers/lz07pldi.pdf
21:00:47 <ray> mad props
21:02:44 <mmorrow> lpsmith: err, actually i meant this paper www.cis.upenn.edu/~stevez/papers/LZ06b.pdf
21:03:02 <mmorrow> (that other one looks related and/or a revision of this though)
21:03:16 * mmorrow wonders if he's still connected
21:03:20 <copumpkin> you are!
21:03:26 <mmorrow> wee
21:05:52 <mmorrow> i can't remember or find where i got that webserver code from though..
21:08:24 <mmorrow> gah, i think the code i've got is on my old laptop too..
21:08:29 <mmorrow> all is lost!
21:09:51 <lpsmith> heh
21:10:47 <mmorrow> lpsmith: that one "a poor man's concurrency monad" paper is neat too
21:10:47 <lpsmith> I had the weirdest experience:  I was away from home for a few weeks;  and got a new laptop while I was away.   But when I came back I got to log into my old desktop and my old laptop once, before my passwords on both stopped working.
21:11:26 <lpsmith> And my old lappy's a PowerBook and my old desktop is an AMD running windows
21:11:37 <lpsmith> Kinda at a loss to explain that
21:11:47 <ray> a rich man's concurrency monad: "bob, go write me something concurrent"
21:11:58 <olsner> lpsmith: it was haxxored, obviously
21:12:02 <olsner> *they were
21:12:12 <mmorrow> ray: "bob, ..... FORK DAMNIT!!"
21:12:14 <lpsmith> apparently :-/
21:14:25 <caxaf> "But the value it retusn is actually () : []"
21:14:42 <caxaf> Poor Cookie Monster!
21:15:32 <ray> cookieMonster :: Cookie -> IO ()
21:15:51 <mmorrow> omnomnom :: forall b. Cookie -> b
21:22:19 <jdrake> In my data Gen = ... I have Number Integer. Is there a way of making this more general? The range of numbers I am using is 0 to 13
21:23:35 <Gwern-away> jdrake: if you're only using 0-13, you could get a bit more safety with an enum?
21:23:54 <jdrake> Any other value is ignored
21:24:04 <jdrake> I am not too aware of enums
21:24:28 <Gwern-away> data Gent = One | Two ... deriving (Ord, Enum) whatever
21:24:52 <Gwern-away> you switch your | x == 1... | x == 2 for case expressions, basically
21:25:07 <Gwern-away> but now ghc can catch whether your case expressions are exhaustive
21:25:29 <jdrake> hmm, not entirely sure the complete consequences of doing this
21:25:31 <Gwern-away> before you could do something like x == 0 ...., x >= 1 ..., and it would bomb on negative numbers
21:25:51 <tkr> Im bit confused again. :) in "function n x | n <= 0 = [] | otherwise x:function (n-1) x" .. what does this x:function mean? why not just function ?
21:26:07 <Gwern-away> jdrake: and ghc couldn't warn you about that since maybe you have a programmer level proof that there will never be negative numbers
21:26:10 <jdrake> tkr, : is a list constructor
21:26:42 <Gwern-away> tkr: think of it as, [x, (function n-1 x)]
21:27:21 <jdrake> Gwern-away: Could you perhaps help me understand exactly what the changes would be to the code I have now? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3055#a3058
21:27:35 <tkr> ah. so it simply forces this to be a list?
21:28:31 <tkr> Gwern-away: ok. thanks I think I got it now.
21:28:33 <jdrake> I am not specifically sure how the Enum would be derived for my example
21:29:09 <mike-burns> tkr: More than that: it builds a list whose head is x and whose tail is the result of  (function (n-1) x)
21:29:11 <Gwern-away> not so much 'forces', as says, I'm creating a list with x as the head, and the rest of it will be defined by whatever function does - so you get nested calls - [x, (f x, [x, (f x..., and it works out as a nice list
21:29:30 <Gwern-away> jdrake: enum would be derived in the order you wrote the enums
21:29:51 <jdrake> Would it start at 0 or 1?
21:30:01 <Gwern-away> so for operator, [Add..Divide] would evaluate to [Add, Substract, Multiply, Divide]
21:30:25 <Gwern-away> (I think [Add..] would just cycle through the 4 indefinitely, but I'm not sure)
21:30:28 <aavogt> > [False..]
21:30:30 <lambdabot>   <no location info>: parse error on input `]'
21:30:33 <aavogt> > [False ..]
21:30:35 <lambdabot>   [False,True]
21:30:54 <Gwern-away> jdrake: well, if you wrote dataq foo = One | Zero | Two..., then it'd go One, Zero, Two...
21:30:58 <Gwern-away> is thatwhat you mean?
21:31:07 <aavogt> > fromEnum False
21:31:09 <lambdabot>   0
21:31:33 <jdrake> Gwern-away: Right now I have a numeric conversion 0 -> Number 0, and so on
21:31:47 <aavogt> derived enum instances seem to go from 0
21:31:57 <Gwern-away> on the other hand, I find your toGene a little odd because of the n < 10 = Number n; this seems like it could be more typeful
21:32:03 <aavogt> > toEnum 1 :: Bool
21:32:05 <lambdabot>   True
21:32:37 <jdrake> chromosome.hs:18:39:
21:32:37 <jdrake>     Can't make a derived instance of `Enum Gene'
21:32:37 <jdrake>       (`Gene' has non-nullary constructors)
21:32:37 <jdrake>     In the data type declaration for `Gene'
21:34:26 <Gwern-away> yeah, the Number n thing is why I'm not sure enum may be the best way to go; the overall structure is unclear
21:34:56 <tkr> mike-burns: and it's exactly the same as x : function n x, I assume ?
21:35:09 <tkr> mike-burns: ie. the spaces dont matter here.
21:35:19 <mike-burns> tkr: Spaces don't matter, that's right.
21:35:19 <Gwern-away> go go infix operators...
21:35:21 <jdrake> Gwern-away: What do you mean the overall structure is unclear?
21:35:35 <tkr> mike-burns: ok. :)
21:35:44 <Gwern-away> jdrake: well, dispatching on integers like that is a very C or Java-ish thing to do, if you follow me
21:36:05 <Gwern-away> javaers use switch on chars and ints; haskellers use switch/case on types :)
21:37:02 <jdrake> Gwern-away: To be honest that sounds like the most ridiculous way of doing this. Because when these are actually used it will be used as the number.
21:37:31 <monochrom> Javaers use if-then-else on instanceOf  <duck>
21:37:34 <Gwern-away> doing so is a sign that you may've not thought through or expressed idiomatically; maybe it is the best thing to do, but I don't know
21:37:46 <Gwern-away> (there're always exceptions of course)
21:38:27 <jdrake> I think I will keep it as it is, it is the way I understand it.
21:38:35 <jdrake> But I do have a rather annoying type problem I have to work through
21:42:32 <jdrake> ok, it works
21:46:53 <jdrake> I thank all ye
22:17:26 <Gwern-away> argh, I'm really hating on these SICP practice problems; their faux type signature exercises are in a syntax just close enough to haskell to really mess me up
22:22:14 <jdrake> If I have a [Gene] and I want to make sure it has a certain ordering, like Number, Operator, Number, repeatable, just as long as it begins with a Number and ends with a Number and between Numbers has Operator, what would be the best way to do it?
22:23:22 <caxaf> jdrake: Can you express what you're after more clearly? :-)
22:23:53 <Gwern-away> the best way would to express those requirements as a type, of course, so you don't need to check
22:24:11 <jdrake> Gwern-away: I have no idea if that is even possible
22:24:40 <Gwern-away> haskell's type system can be Turing complete, so it's possible
22:24:48 <Gwern-away> question is, can you personally do it? :)
22:24:53 <jdrake> Gwern-away: not likely
22:24:54 <mornfall> Maybe don't make it a [Foo] but an ADT expressing those constraints?
22:25:42 <jdrake> mornfall: It is coming from [Bool] to [Gene] at least, so somewhere along the lines I have to do some conversion
22:25:42 <mornfall> I mean, what you asked for sounds like GeneList = GeneCons Number Operator GeneList
22:26:15 <jdrake> mornfall: That would have an Operator being the last entry, which is wrong
22:26:39 <mornfall> jdrake: The "empty" constructor would carry its Number with it.
22:26:45 <mornfall> GeneLast Number
22:27:07 <caxaf> mornfall: That is roughly equivalent to ([(Number,Operator)],Number), yes?
22:27:21 <mornfall> caxaf: Yeah, but less ugly. :)
22:27:36 <jdrake> caxaf: That does appear to be a nice way of stating it.
22:28:00 <mornfall> But a tree may be better, yet, unless you want to avoid precedence at all costs...
22:28:17 <sjanssen> data Expression = Last Number | Op Number Operator Expression
22:28:30 <copumpkin> it'd be fun to have a function on Data.Data or something that would tell you if two instances are ismorphic or not
22:28:51 <copumpkin> and would give you a conversion between them if they were
22:28:58 <jdrake> mornfall: I really want this as simple as possible
22:29:17 <jdrake> sjanssen: I rather like tha tone
22:29:57 <mornfall> jdrake: Well, to just check the constraint, just pick the odd indexes and check they are numbers and even indexes are ops and there's an odd number of elements. :)
22:30:12 <mornfall> About as simple as it gets.
22:30:37 <caxaf> jdrake: Is there a particular reason you're not using a tree?
22:30:37 <mornfall> check (n:o:rest) = is_number n && is_op o && check rest
22:30:44 <mornfall> check [n] = is_number n
22:30:47 <mornfall> check _ = False
22:31:03 <jdrake> caxaf: Because it isn't required
22:31:17 <sjanssen> jdrake: if you're actually doing meaningful operations (like evaluation, for example) on these expressions, then a proper type that enforces the struct should be best
22:32:08 <jdrake> sjanssen: I could see that as a thought
22:32:33 <sjanssen> you don't want to check syntax in your evaluation function -- any good compiler or interpreter will separate these things into separate phases
22:32:48 <jdrake> Can parsec be used for stuff like this?
22:33:02 <sjanssen> parsec can be used for the [Token] -> Expression step
22:33:07 <mornfall> Yeah, parsec can build ASTs just fine.
22:33:23 <jdrake> Any really easy intro on it?
22:36:02 <copumpkin> is there a nice easy function in fgl that tells me whether a given graph is a tree?
22:37:36 <BMeph> If so, is there one that tells if it's a forest? :)
22:39:48 <lpsmith> heh, I never liked the FGL... it doesn't quite feel right
22:39:59 <lpsmith> I certainly don't have a better suggestion though
22:40:02 <copumpkin> lpsmith: I feel the same way, but it has lots of stuff
22:40:10 <copumpkin> lpsmith: I'd very much like to see a better option :)
22:40:16 <lpsmith> indeed it does
22:42:19 <sdg0sdg09sdug0s9> i train in the arcane ways of haskell, but to no avail
22:42:34 <sdg0sdg09sdug0s9> yaourt -S djinn
22:44:05 <sdg0sdg09sdug0s9> @djinn a -> [a] -> [a]
22:44:06 <lambdabot> Error: Undefined type []
22:44:16 <sdg0sdg09sdug0s9> @help djinn
22:44:16 <lambdabot> djinn <type>.
22:44:17 <lambdabot> Generates Haskell code from a type.
22:44:17 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
22:44:32 <sdg0sdg09sdug0s9> @djinn (a,b) -> a
22:44:32 <lambdabot> f (a, _) = a
22:44:40 <sdg0sdg09sdug0s9> no kidding
22:45:09 <sdg0sdg09sdug0s9> @djinn (a -> b) -> (c -> a) -> Either a b -> c
22:45:09 <lambdabot> -- f cannot be realized.
22:45:21 <sdg0sdg09sdug0s9> @djinn (a -> b) -> (c -> b) -> Either a c -> b
22:45:22 <lambdabot> f a b c =
22:45:22 <lambdabot>     case c of
22:45:22 <lambdabot>     Left d -> a d
22:45:22 <lambdabot>     Right e -> b e
22:45:52 <sdg0sdg09sdug0s9> this shit is handy
22:46:22 <lpsmith> copumpkin:  my biggest complaint is that many of the FGL combinators don't produce well-defined functions for most arguments
22:47:01 <lpsmith> and there isn't,  AFAIK, even much guidance of what properties arguments of this nature should have
22:47:19 <sdg0sdg09sdug0s9> what's an example of a fixed point combinator
22:47:27 <lpsmith> it just seems rather barren on the "nice properties" count
22:47:42 <lpsmith> ?src fix
22:47:43 <lambdabot> fix f = let x = f x in x
22:47:46 <sdg0sdg09sdug0s9> let's see...computes f(g) = g for values
22:47:55 <sdg0sdg09sdug0s9> uhhh
22:48:07 <sdg0sdg09sdug0s9> hmm
22:48:14 <sdg0sdg09sdug0s9> how on earth does that work
22:48:15 <lpsmith> :t fix
22:48:17 <lambdabot> forall a. (a -> a) -> a
22:48:32 <lpsmith> > fix (\fact n -> if n == 0 then 1 else n * fact (n-1)) 5
22:48:34 <lambdabot>   120
22:49:07 <lpsmith> > fix (1:)
22:49:09 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:49:32 <lpsmith> of course (1:) is the same as (\x -> 1 : x)
22:49:40 <sdg0sdg09sdug0s9> yes...
22:49:50 <sdg0sdg09sdug0s9> how would you formalize that
22:49:56 <sdg0sdg09sdug0s9> in mathss
22:50:27 <lpsmith> That's _somewhat_ complicated,  you are getting into domain theory :-)
22:50:30 <sdg0sdg09sdug0s9> f(x) = f(x) (append) one?
22:50:35 <sdg0sdg09sdug0s9> oh dear
22:51:26 <lpsmith> http://en.wikipedia.org/wiki/Knaster-Tarski_theorem
22:52:28 <lpsmith> but, formalism aside
22:53:07 <lpsmith> :t  \fact n -> if (n == 0) then 1 else n * fact (n-1)
22:53:08 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
22:53:36 <lpsmith> basically "fact" is what to do next in this case, it's not a recursive definition
22:53:57 <sdg0sdg09sdug0s9> remind me what this has to do with fixed point combinators
22:54:10 <copumpkin> he used fix above
22:54:14 <copumpkin> :t fix
22:54:16 <lambdabot> forall a. (a -> a) -> a
22:54:22 <aavogt> :t fix fix
22:54:23 <jmcarthur> i have finally realized the beauty of Cofree
22:54:24 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
22:54:24 <lambdabot>     Probable cause: `fix' is applied to too many arguments
22:54:24 <lambdabot>     In the first argument of `fix', namely `fix'
22:54:32 <copumpkin> jmcarthur: lol
22:54:47 <lpsmith> @let fact = \fact n -> if (n==0) then 1 else n * fact (n-1)
22:54:49 <lambdabot>  <local>:5:0:
22:54:49 <lambdabot>      Multiple declarations of `L.fact'
22:54:49 <lambdabot>      Declared at: <local...
22:54:57 <lpsmith> @def fact
22:54:57 <lambdabot> Maybe you meant: bf let
22:55:11 <copumpkin> Cofree Maybe ftw ;)
22:55:12 <caxaf> sdg0sdg09sdug0s9: The factorial function is a fixed point of (\fact n -> if (n == 0) then 1 else n * fact (n-1)).
22:55:16 <lpsmith> @let fact = \f n -> if (n==0) then 1 else n * f (n-1)
22:55:17 <lambdabot>  <local>:5:0:
22:55:18 <lambdabot>      Multiple declarations of `L.fact'
22:55:18 <lambdabot>      Declared at: <local...
22:55:23 <lpsmith> @let myfact = \f n -> if (n==0) then 1 else n * f (n-1)
22:55:24 <copumpkin> aw
22:55:25 <lambdabot>  Defined.
22:55:32 <lpsmith> > myfact 0
22:55:34 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
22:55:34 <lambdabot>    arising from the literal `0' at <...
22:55:38 <lpsmith> > myfact id 0
22:55:41 <lambdabot>   1
22:55:43 <lpsmith> > myfact id 1
22:55:44 <sdg0sdg09sdug0s9> id?
22:55:45 <lambdabot>   0
22:55:48 <copumpkin> > id 5
22:55:49 <lambdabot>   5
22:55:53 <copumpkin> id x = x
22:56:01 <caxaf> sdg0sdg09sdug0s9: (Is there a particular reason you're using that nick, by the way?)
22:56:03 <sdg0sdg09sdug0s9> why did you have to include that
22:56:08 <sdg0sdg09sdug0s9> caxaf: yes
22:56:11 <lpsmith> > myfact (myfact id) 0
22:56:13 <lambdabot>   1
22:56:15 <lpsmith> > myfact (myfact id) 1
22:56:18 <lambdabot>   1
22:56:29 <lpsmith> actually, if you want to be all domain theory like
22:56:32 <lpsmith> this should be
22:56:36 <lpsmith> > myfact undefined 0
22:56:38 <caxaf> > myfact (myfact (myfact (myfact (myfact (myfact undefined))))) 5
22:56:38 <lambdabot>   1
22:56:40 <lambdabot>   120
22:56:48 <lpsmith> cafax: indeed
22:56:54 <copumpkin> carfax!
22:56:54 * caxaf is reminded of The Little Schemer.
22:57:10 <sdg0sdg09sdug0s9> > myfact 5
22:57:12 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
22:57:12 <lambdabot>    arising from the literal `5' at <...
22:57:13 <lpsmith> caxaf:  decent book:
22:57:14 <sdg0sdg09sdug0s9> > myfact id 5
22:57:16 <lambdabot>   20
22:57:19 <sdg0sdg09sdug0s9> what
22:57:21 <lpsmith> > myfact undefined 5
22:57:21 <copumpkin> 5 * 4
22:57:23 <lambdabot>   * Exception: Prelude.undefined
22:57:34 <sdg0sdg09sdug0s9> oh yes
22:57:38 <sdg0sdg09sdug0s9> why did you define it like that again :O
22:57:40 <copumpkin> sdg0sdg09sdug0s9: myfact is only doing one "step" of it
22:57:50 <lpsmith> > myfact (myfact undefined) 0
22:57:50 <copumpkin> sdg0sdg09sdug0s9: that's the form you need for the fixpoint
22:57:52 <lambdabot>   1
22:57:54 <lpsmith> > myfact (myfact undefined) 1
22:57:56 <lambdabot>   1
22:57:57 <lpsmith> > myfact (myfact undefined) 2
22:57:59 <lambdabot>   * Exception: Prelude.undefined
22:58:10 <lpsmith> > myfact (myfact (myfact undefined)) 2
22:58:12 <lambdabot>   2
22:58:13 <lpsmith> > myfact (myfact (myfact undefined)) 3
22:58:16 <lambdabot>   * Exception: Prelude.undefined
22:58:23 <sdg0sdg09sdug0s9> :src myfact
22:58:28 <caxaf> sdg0sdg09sdug0s9: If you know a bit of Scheme, you might find http://www.ccs.neu.edu/home/matthias/BTLS/sample.ps helpful.
22:58:30 <lpsmith> > myfact (myfact (myfact (myfact undefined))) 3
22:58:32 <lambdabot>   6
22:58:37 <lpsmith> > myfact (myfact (myfact (myfact undefined))) 4
22:58:39 <lambdabot>   * Exception: Prelude.undefined
22:58:41 <copumpkin> > fix ((1 :: Natural) +) > 5
22:58:43 <lambdabot>   True
22:58:47 <copumpkin> yay
22:58:50 <caxaf> <lpsmith> @let myfact = \f n -> if (n==0) then 1 else n * f (n-1)
22:58:50 <sdg0sdg09sdug0s9> what is this
22:58:52 <sdg0sdg09sdug0s9> postscript
22:58:54 <sdg0sdg09sdug0s9> or a scheme file
22:59:13 <caxaf> sdg0sdg09sdug0s9: A Postscript document.
22:59:37 <sdg0sdg09sdug0s9> what's the scheme file extension
23:00:02 <caxaf> sdg0sdg09sdug0s9: The Little Schemer is pure and above such ugly things as file extensions.
23:00:11 <lpsmith> so we can continue this ad infinitum
23:00:36 <caxaf> fix f = f (f (f (f (f (f (f (f (f (f ...
23:00:56 <sdg0sdg09sdug0s9> i should not have opened that in gimp
23:01:02 <lpsmith> and so in the limiting case,  you get,  as cafax suggested,   myfact (myfact (myfact (myfact ...
23:01:13 <copumpkin> I think his nick is caxaf :P
23:01:14 <osfameron> whenever I see that, part of my brain screams out "BUT HOW DOES IT KNOW WHEN TO STOP!?" ;-)
23:01:28 <lpsmith> haha, sorry caxaf
23:01:37 <copumpkin> show me the caxaf!
23:01:53 <caxaf> Aw, people still mess up my nick, even at 5 letters. .uinai
23:02:35 <sdg0sdg09sdug0s9> caxaf
23:03:00 <caxaf> osfameron: Well, that's the point of the if, yes? :-)
23:03:15 <copumpkin> :t headCofree
23:03:17 <lambdabot> Not in scope: `headCofree'
23:03:22 <copumpkin> , headCofree
23:03:27 <lunabot>  luna: Not in scope: `headCofree'
23:03:34 <copumpkin> it'd be fun to play with category-extras on lambdabot
23:03:42 <lpsmith> so anyway,  in the limit, the argument passed to myfact is equal to the function itself
23:03:47 * copumpkin hints strongly and stars at Cale
23:03:51 <copumpkin> *stares
23:03:53 <lpsmith> sort of like
23:04:20 <caxaf> @ty join id
23:04:22 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
23:04:22 <lambdabot>     Probable cause: `id' is applied to too few arguments
23:04:22 <lambdabot>     In the first argument of `join', namely `id'
23:04:25 <lpsmith> fix myfact = let fact = fact myfact in fact
23:04:36 <lpsmith> err,
23:04:45 <lpsmith> fix myfact = let fact = myfact fact in fact
23:04:53 <sdg0sdg09sdug0s9> wtf am i reading
23:04:57 <lpsmith> so
23:05:04 <lpsmith> > fix myfact 5
23:05:06 <lambdabot>   120
23:05:08 <lpsmith> > fix myfact 12324
23:05:11 <lambdabot>   419852674238082170556793133650491616257948914494831830124476241092703649302...
23:05:13 <copumpkin> lol
23:05:26 <copumpkin> > length . show . fix myfact $ 12345
23:05:28 <lambdabot>   45151
23:05:35 <copumpkin> damn right
23:05:44 <sdg0sdg09sdug0s9> > fix myfact (fix myfact 12324)
23:05:51 <lambdabot>   mueval-core: Prelude.read: no parse
23:05:51 <lambdabot>  mueval: ExitFailure 1
23:05:54 <sdg0sdg09sdug0s9> whoosh
23:06:04 <Berengal> Hah, limits of functions. It makes perfect sense, but it still messes with people's heads
23:06:05 <caxaf> "no parse"? Huh.
23:06:11 <copumpkin> > wliComeBack
23:06:13 <lambdabot>   wli please come back
23:06:14 <lpsmith> yeah, at that point you really want a more efficent way to calculate myfact...
23:06:21 <lpsmith> err, fix myfact
23:06:36 <sdg0sdg09sdug0s9> what is this book lpsmith
23:06:53 <lpsmith> Little Schemer?
23:07:07 <sdg0sdg09sdug0s9> maybe
23:07:21 <lpsmith> It's a book by Dan Friedman,  presents recursion using a very socratic method
23:07:27 * caxaf remembers that Scheme is strict, so things are somewhat more complicated.
23:07:27 <lpsmith> maybe too socratic, IMO
23:07:59 <lpsmith> caxaf: nothing a little eta-abstraction can't solve!
23:08:02 <caxaf> (On the other hand, at least Y can be defined, unlike *some* languages... :-) )
23:08:12 <lpsmith> well, fix is basically y
23:08:22 * copumpkin debates killing lambdabot
23:08:38 <lpsmith> Except in the traditional presentation of the Y combinator,  it replaces recursion with self-application
23:08:40 <sdg0sdg09sdug0s9> why would you charge for a book like this
23:08:43 <copumpkin>   @pl (\x -> x x) (\x -> x x)
23:08:45 <sdg0sdg09sdug0s9> does anybody else think MIT is evil btw
23:08:51 <copumpkin> sdg0sdg09sdug0s9: not me
23:08:58 <lpsmith> but of course,  you can't do self-application in Hindley-Milner
23:09:00 <copumpkin> unless you mean for killing SICP
23:09:08 <sdg0sdg09sdug0s9> i mean in general
23:09:16 <Cale> sdg0sdg09sdug0s9: evil?
23:09:16 <copumpkin> then nope
23:09:16 <sdg0sdg09sdug0s9> as an institution
23:09:25 <copumpkin> this sounds like #haskell-blah material
23:09:32 <sdg0sdg09sdug0s9> then whatever
23:09:42 <Cale> sdg0sdg09sdug0s9: why?
23:09:57 <sdg0sdg09sdug0s9> a couple things have gotten that point to me
23:10:04 <sdg0sdg09sdug0s9> something to do with global warming lately
23:10:08 <sdg0sdg09sdug0s9> something to do with police
23:10:09 <Cale> sdg0sdg09sdug0s9: They provide a fair amount of free educational materials which are for the most part pretty good.
23:10:12 <sdg0sdg09sdug0s9> i don't remember
23:10:22 <sdg0sdg09sdug0s9> they do have that shakespeare archive
23:10:26 <sdg0sdg09sdug0s9> as well
23:10:45 <lpsmith> copumpkin:  MIT still uses SICP in their UG curriculum, just not in their introductory programming course
23:10:52 <copumpkin> lpsmith: yeah :)
23:10:58 * Berengal <3 SICP on YouTube
23:11:01 <copumpkin> I'm not a fan of starting with python
23:11:08 <copumpkin> best start with haskell!
23:11:34 <Berengal> Python is a decent language, considering some of the alternatives
23:11:35 <lpsmith> And honestly,  I dunno about MIT,  but I doubt there aren't that many institutions that you can't talk and/or test your way out of the intro programming courses if you got the chops
23:11:49 <ray> it's not just the fact that sicp uses scheme, it's the material in sicp
23:12:01 <ray> it could use scheme and be absolutely vapid
23:12:10 <sdg0sdg09sdug0s9> wtf is this "quote" function in scheme
23:12:20 <sdg0sdg09sdug0s9> too many damn parentheses
23:12:31 <lpsmith> Me,  I started programming Basic at the age of 3,  I definitely did not take intro to programming, ever.
23:12:39 <osfameron> write a ($) macro for it ;-)
23:13:28 <sdg0sdg09sdug0s9> how do you write the y combinator in haskell
23:13:33 <lpsmith> @src fix
23:13:34 <ray> @src fix
23:13:34 <lambdabot> fix f = let x = f x in x
23:13:35 <lambdabot> fix f = let x = f x in x
23:13:37 <sdg0sdg09sdug0s9> damn
23:13:42 <sdg0sdg09sdug0s9> i thought that was just the fixed point combinator
23:13:44 <sdg0sdg09sdug0s9> same thing?
23:13:51 <lpsmith> basically, yes
23:13:59 <sdg0sdg09sdug0s9> basically?
23:14:00 <ray> Y is the combinator name for the least-fixed-point combinator
23:14:02 <Cale> sdg0sdg09sdug0s9: The Y combinator is actually a particular implementation of a fixpoint combinator.
23:14:17 <ray> there's such a thing as greatest fixed points too
23:14:26 <sdg0sdg09sdug0s9> i have no idea what that means
23:14:27 <Berengal> They do the same thing, but go about doing it differently
23:14:38 <Berengal> The result is the same though
23:14:42 <caxaf> sdg0sdg09sdug0s9: You can't write Y in Haskell.
23:14:43 <ray> you can also do fix f = f (fix f)
23:14:49 <ray> i forget why that's less good
23:14:56 <Berengal> ray: sharing
23:15:02 <Berengal> Or rather, lack thereof
23:15:06 <ray> i see
23:15:17 <Cale> actually you can write the proper Y in Haskell, if you're willing to put up with a little wrapping and unwrapping (without which it won't typecheck)
23:15:31 <Cale> newtype Rec a = In { out :: Rec a -> a }
23:15:31 <Cale> y :: (a -> a) -> a
23:15:31 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
23:15:42 <caxaf> Cale: That's cheating, isn't it?
23:15:49 <caxaf> You're still using recursion.
23:15:51 <ray> define "cheating"
23:15:52 <lpsmith> but basically,  you can take the source of fix,  express the recursion using self-application, eta-reduce, and get the traditional Y combinator... the traditional implementation can't be expressed  in haskell
23:15:59 <Cale> caxaf: But only at the type level.
23:16:10 <ray> there's no y on the rhs
23:16:11 <sdg0sdg09sdug0s9> i want to just see all these haskell functions reduced into asm - but i'm too lazy to start a debugger
23:16:13 <lpsmith> Or you can take ray's definition of fix,  do the same thing, and get Turing's Y combinator
23:16:30 <copumpkin> sdg0sdg09sdug0s9: they can look quite nice, or be quite monstrous
23:16:46 <sdg0sdg09sdug0s9> ok
23:16:47 <ray> the traditional implementation is less clear than the haskell definitions
23:16:49 * sdg0sdg09sdug0s9 zzzzzz
23:16:50 <caxaf> Cale: But still, you're relying on recursion to define recursion.
23:17:06 <sdg0sdg09sdug0s9> thank you for the help
23:17:08 <caxaf> ray: Which Haskell definitions? The ones that cheat? :-)
23:17:10 <Cale> caxaf: mm... not really
23:17:10 <ray> the haskell definitions let you see exactly what it *does*
23:17:16 <ray> yes, the ones that cheat :)
23:17:31 <Cale> caxaf: The value level definition of that y has no recursion in it.
23:17:32 <caxaf> I'm sure you could do a nicer Scheme one if you cheated, too.
23:18:16 <lpsmith> caxaf:  yes,  you can define the y combinator using letrec or define, all you have to do is eta-reduce
23:18:37 <lpsmith> lambdabot needs to support OCAML and/or Scheme
23:18:51 <ray> i think preflex supports scheme
23:18:51 <Cale> caxaf: and since Rec is a newtype, In and out are boiled away by compilation
23:19:11 <caxaf> Cale: Fair enough, I suppose...
23:19:45 <jdrake> Any ideas why I don't have this on my osx install? file:///usr/share/doc/ghc/libraries/ghc-mtl/Control-Monad-State.html
23:20:15 <Cale> does /usr/share/doc/ghc/ exist?
23:20:25 <caxaf> jdrake: Is mtl installed?
23:20:41 <jdrake> Cale, I use all the rest of the docs
23:20:48 <jdrake> caxaf: Waht is that?
23:20:49 <Cale> ah, the links are broken?
23:20:50 <Cale> hmm
23:21:31 <jdrake> It appears at least that one is
23:21:33 <lpsmith> jdrake:  type "which ghc" at the command line
23:21:46 <jdrake>  /usr/bin/ghc
23:21:49 <lpsmith> hmm
23:22:33 <jdrake> I am not using macports :p
23:23:34 <caxaf> jdrake: The library that Control.Monad.State is in.
23:24:07 <jdrake> I can import Control.Monad.State
23:26:24 <Cale> jdrake: hmm, maybe somehow the haddock for mtl didn't get packaged with it... you have cabal?
23:26:53 <jdrake> I have not specifically done anything other than install, so I do not know
23:27:20 <Cale> try cabal at the commandline
23:27:46 <jdrake> not there
23:28:12 * adu <3 cabal
23:28:17 <adu> hi Cale
23:28:22 <Cale> hi adu
23:28:32 <adu> Cale: are you going to hac phi?
23:28:36 * jdrake <3 cpan
23:28:37 <Cale> nope
23:28:48 <Cale> Yeah, cabal is like our cpan.
23:29:16 <adu> i am
23:29:22 <Cale> cool :)
23:30:03 <adu> i think its next weekend
23:30:47 <Cale> jdrake: anyway, you might be able to get the mtl source from hackage (an easy way to do that is to use the cabal-install program)
23:30:52 <adu> jdrake: I've had a lot of problems with macports
23:31:09 <Cale> jdrake: and then you can  cabal haddock  from the source directory to build the documentation
23:31:10 <adu> jdrake: about 1 out of 20 ports will error during installation
23:31:23 <jdrake> adu, I try not to use it where possible
23:31:46 <jdrake> You would not believe how it is written underneath the port command :p
23:32:36 <adu> maybe I should find out
23:36:49 <BMeph|out> I thought it was mentioned, but I should do it again, I guess.
23:37:51 <BMeph|out> The docs call the package name "ghc-mtl", but the directory is still called just "mtl".
23:38:03 <jdrake> adu, tcl hack :p
23:40:14 <adu> tcl isn't all that bad
23:40:32 <adu> at least they chose a datatype like string
23:40:38 <Cale> BMeph|out: Oh, you mean he can just go and rename it?
23:40:49 <Cale> jdrake: try that :)
23:42:42 <jdrake> It works
23:43:05 <dblhelix> good morning, #haskell
23:48:41 <Mobsan> :t sortBy
23:48:43 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
23:49:14 <copumpkin> sortOn would still be nice :P
23:49:56 <Mobsan> Does <= return an ordering?
23:50:05 <copumpkin> nope, a Bool
23:50:06 <copumpkin> :t compare
23:50:08 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
23:50:09 <copumpkin> :t comparing
23:50:11 <Mobsan> :(
23:50:11 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
23:50:22 <copumpkin> :t (compare `on`)
23:50:24 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
23:50:42 <copumpkin> dblhelix: good morning!
23:51:13 <dblhelix> copumpkin: great link you posted (jailbreak tutorial)
23:51:20 <copumpkin> lol thanks :)
23:52:59 <lpsmith> copumpkin:  http://hackage.haskell.org/packages/archive/data-ordlist/0.0.1/doc/html/Data-OrdList.html
23:53:32 <copumpkin> aha nice
23:53:48 <copumpkin> that looks like a handy addition to my standard set of things
23:54:51 <copumpkin> not sure I agree on your abbreviation of intersect though :P
23:54:54 <lpsmith> if you have any suggestions for additions and/or tweaks, I'm definitely open to them :-)
23:55:03 <lpsmith> what would you use?
23:55:21 <copumpkin> probably the full word, but I'm terrible at naming :)
23:57:53 <hackagebot> cautious-file 0.1.2 - Ways to write a file cautiously, to reduce the chances of problems such as data loss due to crashes or power failures (RobinGreen)
23:57:55 <copumpkin> but it looks really useful
23:59:15 <Berengal> lpsmith: Why is nubSort written the way it is instead of just map head . group . sort?
