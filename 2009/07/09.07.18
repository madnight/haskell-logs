00:00:32 <ivanm> wtf? haddock complains about a parse error on a line that just has "{- |" :s
00:00:57 <ivanm> ahhh, it didn't like something in the comment starting there
00:08:03 <Cale> Right, you have to remember that it parses comments :)
00:08:14 <cads> ivan, a process calculus is like the lambda calculus, where any calculus is just heavy formal machinery which we wield through a handy syntax to reduce complex descriptions.\
00:08:14 <Cale> It's also really picky about blank lines
00:08:45 <cads> Instead of modelling computational functions, we deal with descriptions of computational processes
00:08:49 <Cale> In other words a tool for calculating :)
00:09:05 <cads> or something the dentist scrapes from your teeth
00:09:10 <Cale> hehe
00:13:14 <cads> what's neat is that p-calcs can be used to model processes that could be mobile or running on a network with changing topology, or what might have to hold to certain properties like security or capabilities or resources models
00:13:38 <cads> heck, I bet there are dudes that made some for modelling quantum processes
00:14:44 <cads> eventually there'll be a process calculus on how to get twisted chunks of carbon nanotubes to compute shit, I reckon
00:16:38 <Axman6> ivanm: i've had the same experience in #java. they don't seem to understand the difference between homework and research
00:16:57 <ivanm> Axman6: yeah, finding a lib to _use_ in homework /= homework IMHO
00:17:04 <ivanm> especially since this was a large year-long group project
00:17:51 <Axman6> yeah
00:18:21 <Axman6> and while the java docs are often quite ice, finding the docs you need is quite often not easy (things have strange names)
00:19:09 <Axman6> o/ pifish
00:19:18 <pifish> hello
00:19:52 <cizra> Morning.
00:20:01 <cizra> I'm trying to come up with elegant code for this problem:
00:20:22 <pragma_> ()
00:20:31 <cizra> I'm writing a strategic tic-tac-toe thinker. It must consider many cases.
00:20:36 <cizra> I want to write something like
00:21:04 <cizra>   | Just twoInARow = [use the value here and make a move]
00:21:28 <cizra> I must make a where-block somewhere, right? No more elegant way?
00:23:14 <Axman6> it'd help if you could show more of the code
00:23:28 <cizra> It's not there yet (=
00:24:47 <cizra> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7151#a7151
00:24:50 <cizra> There it is.
00:25:10 <copumpkin> :o
00:25:19 <copumpkin> I think you're confusing guards and patterns
00:25:20 <cizra> What I hope it does: it figures out if there are two-in-a-row situations
00:25:36 <cizra> .. then, if it happens to be Just mark, return it.
00:25:44 <cizra> And yes, entirely possible (=
00:26:05 <shachaf> Perhaps view patterns are what you're after?
00:26:06 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
00:26:21 <soupdragon> cizra the Either monad
00:26:55 <soupdragon> or you can use [] and take the head
00:27:18 <cizra> soupdragon: Either Move Nothing?
00:27:54 <cizra> shachaf: What are view patterns?
00:27:57 <Vq^> cizra: why not just do a minimax search?
00:28:16 <Vq^> tic-tac-toe is a very small problem
00:28:20 <cizra> Vq^: Because I don't know how to evaluate a given position's goodness.
00:28:36 <Peaker> cizra: sure you do: Win/lose/recurse
00:28:39 <cizra> I tried to invent a brute-force way for it, but failed (too much brain power required :-D)
00:28:42 <Peaker> win/lose/tie/recurse, that is
00:28:57 <cizra> I thought about this a lot..
00:29:04 <Vq^> cizra: three in a row is all you need
00:29:42 <Peaker> cizra: Tic-tac-toe is small enough that you don't need heuristics ("Evaluating a board") you can just scan until the end
00:29:48 <Vq^> cizra: and because the minimax search can be total you don't need any "goodness" heuristics
00:30:04 <cizra> oooookay.. lemme put it in words
00:30:24 <cizra> I take the list of valid moves (function already implemented), for each of these moves:
00:30:43 <cizra> check if making it would win the game, or at least force a draw
00:31:02 <cizra> If yes, return the winning move
00:31:20 <cizra> If no, try to make the move and recurse into it
00:31:30 <cizra> hmm
00:31:34 <Vq^> i solved the same problem for a more complex game last year
00:31:46 <cizra> Must be smarter than me.
00:31:57 <Vq^> i did a custom radix tree for the entire set of possible boards
00:33:00 <Vq^> it's fairly easy to do, then you have a tree of possible boards to search for the best result/leaf
00:33:00 <lpsmith> peaker:   but you should check out my highly optimized negascout tic-tac-toe algorithm with alpha-pruning :-P
00:33:14 <Peaker> lpsmith: What's "negascout"?
00:33:33 <Vq^> lpsmith: he could start with minimax, those are mostly optimisations of that anyway :P
00:38:50 <Peaker> cizra: I think it took me a bit of mind bending to understand minimax at first, many years ago.. The main insight, IMO, is that only one move really matters, the best move -- and so each state really has just one interesting end-state, and that's it's value. You control what you choose, and if the other guy chooses differently, he'll only do worse.. So you have a lower bound on the value of each move, from your perspective
00:38:52 <lpsmith> NegaScout is a minimax algorithm,   in many cases it's supposed to be one of the most efficient
00:39:10 <Peaker> lpsmith: ah, minimax+alpha-pruning is just alpha-beta, isn't it?
00:39:37 <Peaker> There's probably a cabal package to do alpha-beta search on problem spaces you can define, I'd suppose. If not, it could be a fun package to write
00:40:49 <Axman6> still here pifish?
00:41:06 <pifish> yep
00:41:06 <Peaker> cizra: for example, one of the wrong thoughts I had that obfuscated the understanding of minimax at first, was that the moves you're not going to choose matter somehow.  e.g: Lets say all moves you can make are moves that cost you losing the game, but one wins the game.  The important thing to understand is that the losing moves are irrelevant because you can choose not to perform them, but rather always choose the winning move..
00:41:14 <Axman6> thweet
00:41:33 <Peaker> cizra: you there? :)
00:42:35 <Peaker> @type negate
00:42:36 <lambdabot> forall a. (Num a) => a -> a
00:43:51 <Peaker> cizra: basically, minimax looks like:   boardValue board = if endGame board then endValue board else maximum . map (negate . boardValue) . allPossibleNextBoards $ board
00:44:51 <copumpkin> could finger trees be used for any semigroup, or is the identity element fundamental somehow?
00:46:03 <copumpkin> it "feels" (given apfelmus' blog post on it) that it should be possible to rework it to not use mempty
00:46:12 <copumpkin> but I haven't thought through it too far
00:50:15 <copumpkin> :o
00:58:07 <jeffwheeler> Is there any trick to getting a package included into Hoogle, with the +package syntax?
00:59:44 <ivanm> jeffwheeler: contact ndm?
01:00:05 <jeffwheeler> ivanm: I'll do that in the next release :)
01:00:14 <ivanm> heh
01:00:30 <jeffwheeler> thanks, btw
01:10:36 <ivanm> how does one use tryJust from extensible-exceptions without defining useless function with a specific type sig again?
01:10:45 <ivanm> IIRC, it's something to do with SomeException ...
01:21:56 <cizra> Peaker: Yeah, I'm reading the backlog now
01:23:17 <cizra> Peaker: Was away and will be for some days. But I've read your thoughts and I really appreciate your input. Thank you.
01:24:47 <Peaker> cizra: sure thing
01:27:06 <drbean> :t fmap
01:27:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:34:15 <cizra> Peaker: Are you claiming that I can lookahead far enough to decide for a given move that it is GUARANTEED to win?
01:34:25 <cizra> Peaker: (or draw in case of defense)
01:34:27 <Peaker> cizra: in tic-tac-toe, yep
01:34:36 <Peaker> cizra: or lose, if you are playing an unbalanced game
01:34:55 <Peaker> (or if that move is one you won't choose, and sucks)
01:35:24 <cizra> Peaker: So the most important thing is, if a given move guarantees win, then the previous one also by extension guarantees win?
01:35:32 <cizra> Peaker: How about countering winning?
01:35:58 <Peaker> cizra: no, the previous one by the opponent guarantees him losing (if you play right), the previous move you made may not have guaranteed a win
01:36:38 <Peaker> cizra: A guaranteed winning-move means the whole board is a win for you (because you can choose it and win). What it means is that *all* possible follow up moves by the opponent will lead to his loss
01:36:40 <cizra> hm.
01:37:22 <Peaker> cizra: the board may be balanced now (all moves are lose or draw, you choose draw), but then the opponent may make a mistake and choose a lose, instead of choosing a draw, and then you can win
01:37:40 <cizra> That I understand
01:38:12 <cizra> What I don't understand is how I should choose moves when I'm not winning yet. Lemme try:
01:38:53 <Peaker> cizra: that's indeed a problem :)  If all your moves are losses or draws -- it may make sense to try to choose something that encourages a "mistake" of the opponent, if that's possible. If he's a computer, you might as well call it quits or just choose randomly
01:39:00 <cizra> On the last step of recursion, we have my winning move. On my penultimate move, I must choose such a move that all opponent moves lead to his loss.
01:39:31 <cizra> ooops, gotta run!
01:39:36 <cizra> kthxbai
01:39:41 <Peaker> ;
01:43:13 <Peaker> OOHaskell seems pretty slick :)
01:43:19 <thomastc> http://flyingfrogblog.blogspot.com/2009/07/ocaml-vs-f-burrows-wheeler.html can Haskell do that?
01:43:22 <Peaker> yet another cute demonstration of Haskell's power
01:45:28 <Peaker> what does "industrial strength" really mean?
01:45:40 <Peaker> I mean, the software industry is nothing to gloat about
01:46:15 <dobblego> Peaker, _|_
01:46:23 <ivanm> with Cabal, when should one use data-files vs extra-source-files (for README, etc.)?
01:46:35 <Peaker> dobblego: don't need to moon me, an explanation would do
01:47:15 <thomastc> Peaker: industrial strength: of sufficient strength that it makes industry happy?
01:47:37 <ivanm> thomastc: OCaml is a previous generation of language vs F#?
01:47:48 <ivanm> what makes it a "previous generation"? doesn't use .Net? ;-)
01:47:58 <thomastc> I'm just curious how a properly optimized Haskell implementation would perform, compared to bzip2
01:48:26 <thomastc> ivanm: don't know... guess so
01:48:31 <dobblego> Peaker, it has no meaning -- it's bunk
01:48:39 <Peaker> IMO, getting performance out of Haskell is a bonus, not a core feature, and that Haskell is actually higher-level than Ocaml/F# and I'm willing to pay some performance for this high-level-ness
01:49:21 <thomastc> Peaker: yes, but with Haskell we are getting close to having our cake and eating it too :)
01:51:05 <Peaker> I do expect a strict-by-default language with more transparent operational semantics and various hacks (side effects as part of evaluation, native support for various language features that Haskell defers to a stdlib) to potentially perform better than Haskell, at least on a uni-processor
01:54:27 * Beelsebob is not so certain about that expectation
01:54:42 <Beelsebob> at least not as effort put into the compiler approaches infinity
01:54:48 <Beelsebob> (on both parts)
01:55:27 <Ke> well at least precalculating constant expressions is nice
01:55:48 <Beelsebob> hmm?
01:56:37 <Peaker> Beelsebob: I agree higher-level languages allow more optimizations to be made.  You could approximate the "infinite effort compiler" with a human -- the programmer who is told to write bzip2 however he likes may write a better bzip2 than one told to do it in any particular way or language :)
01:56:59 <Peaker> Beelsebob: i.e: Boss -> Programmer   is also a programming language, one that is very high-level and performs very well, given good programmers :)
01:57:10 * Beelsebob nods
01:57:39 <thomastc> yes, the article mentions that they had to inline a closure to make it faster, I guess currying in Haskell would take care of this automatically, "inlining" the thing just once?
01:57:54 <Peaker> btw: It also completely takes the air out of the "No silver bullet" tautologic paper, that claims the programming problems we face today are inherent and cannot be overcome - so we shouldn't expect even a single order of magnitude improvement with the programming tools of the future
01:58:44 <thomastc> Peaker: given good programmers... and good bosses :)
01:58:59 <Peaker> he says the inlining sped it up 150x times, and that it was the closure call that slowed it down. Are closure calls 150x slower than direct function calls?
01:59:04 <Peaker> I find that hard to believe
01:59:17 * soupdragon wtf is 'closure calls'
01:59:33 <thomastc> Peaker: 150x slower than no calls at all, that I can believe
01:59:45 <thomastc> because the compare function was inlined
02:00:06 <Peaker> thomastc: still hard to believe, IMO, because that would mean the rest of the algorithm isn't doing much
02:00:13 <Peaker> soupdragon: a call to a function that has some free variables bound already
02:00:19 <thomastc> and I don't know F#, but if it has to do stuff like overload resolution and such, in order to call that compare function...
02:00:23 <soupdragon> if you don't beleive it test it
02:00:30 <thomastc> ... and the compare function just compares two integers...
02:00:43 <Peaker> soupdragon: I'd hope someone who's more interested does so :)
02:00:48 <thomastc> ... then I can imagine those numbers to be true
02:00:56 <thomastc> also, no telling what the optimizer makes of both cases
02:00:56 <soupdragon> lame
02:03:40 <Peaker> augustuss' name is appearing in each of the 3 papers I've read recently. Damn :-)
02:04:09 <Peaker> soupdragon: unfortunately, the level of interest required to engage in discussion is sometimes lower than that required to actually go and program something about it :)
02:04:41 <Peaker> soupdragon: note I said "hard to believe" and not a certain accusation -- which I'd probably make if I actually tested it out myself
03:06:31 <RayNbow> hmm, are there categories C for which no forgetful functor C/A -> C exists?
03:06:44 <RayNbow> @seen Cale
03:06:45 <lambdabot> Cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard Cale speak 2h 57m 35s ago.
03:08:35 <ivanm> with Cabal, when should one use data-files vs extra-source-files (for README, etc.)?
03:20:06 <Saizan> ivanm: data-files gets installed on the user's system, while extra-source-files are only packaged in the source tarball
03:20:23 <ivanm> *nod*
03:20:36 <ivanm> so for README, etc. I should use extra-source-files?
03:20:55 <Koper> geordi-irc: nobody: getGroupEntryForName: does not exist (no group name)
03:20:58 <Koper> What does this error mean?
03:21:31 <ivanm> Koper: depends on what context it's in
03:21:40 <Koper> It's an error message when i try to execute a program
03:21:59 <ivanm> which program?
03:22:05 <Koper> geordi, it's written in haskell
03:22:43 <ivanm> Koper: this one? http://www.xs4all.nl/~weegen/eelis/geordi/
03:22:47 <kulakowski> RayNbow: Do you mean, a category C such that for one, or for all, A, there is no forgetful functor C/A -> C
03:22:50 <Koper> yes ivanm
03:23:08 <ivanm> @seen eelis
03:23:09 <lambdabot> Last time I saw eelis was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #
03:23:09 <lambdabot> ghc, #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #
03:23:09 <lambdabot> haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #
03:23:09 <lambdabot> xmonad and #yi 1m 16d 5h 32m 15s ago.
03:23:13 <ivanm> heh
03:23:19 <ivanm> Koper: maybe ask in #geordi ?
03:23:33 <Koper> ivanm it's a haskell error
03:23:40 <ivanm> are you sure?
03:23:43 <Koper> I want to fix it myself if I know what it means
03:23:43 <Koper> Yes
03:23:47 <Koper> http://www.google.com/search?hl=en&site=&q=getGroupEntryForName%20haskell
03:23:49 <ivanm> Koper: is this a local install of geordi?
03:23:57 <Koper> What do you mean by local?
03:23:59 <ivanm> because it sounds like you need permissions to run it
03:24:09 <Koper> I'm running it as root
03:24:10 <ivanm> Koper: you installed it on your machine rather than trying to use it over IRC
03:24:23 <Koper> Trying to use it over irc? o.o
03:24:30 <ivanm> Koper: it's an IRC bot...
03:24:33 <ivanm> @whois geordi
03:24:34 <lambdabot> Unknown command, try @list
03:24:37 <ivanm> gah
03:24:45 <ivanm> Koper: do /whois geordi
03:24:56 <Koper> And?
03:25:05 <Koper> I don't understand what IRC has to do with the problem
03:25:33 <ivanm> Koper: nothing, I'm just asking if you're running it on your machine or using the bot over IRC
03:25:50 <ivanm> because I bet it needs to have something belong to a specific owner or something
03:26:11 <Koper> I'm running it, it's a program
03:26:20 <Koper> I think I found out what the problem is though
03:26:41 <RayNbow> kulakowski: well, I was looking at a poset {x,1,2,3} with arrows from 1 to 2, 2 to 3, 1 to 3 and then considering P/3...
03:26:52 <Saizan>  nobody: getGroupEntryForName: does not exist (no group name) <- it expects the existence of a nobody group on your machine
03:27:02 <ivanm> yeah
03:27:09 <Koper> Thank you Saizan
03:27:09 <ivanm> as I said, it's a permissions problem
03:27:35 <Saizan> but you can always create one :)
03:27:50 <Koper> It's not a permission problem
03:27:53 <Koper> The group didn't exist
03:27:56 <Koper> It works now though, thanks
03:28:09 * ivanm would count that as a permissions problem
03:30:02 <kulakowski> I think in general there's only a forgetful functor C/A -> C if, for all B, Hom(B,A) is either empty or has exactly one arrow.
03:31:08 <RayNbow> ( http://img190.imageshack.us/img190/3498/awodeyslicecategory.png diagram from Awodey's CT book )
03:31:35 <kulakowski> If there is more than one arrow in Hom(B,A), you can't faithfully associate each arrow with target A to an object of C.
03:31:50 <kulakowski> So there can't be a forgetful functor.
03:32:02 <RayNbow> if you replace X with 1, X' with 2, C with 3 and add another object x, you get the poset {x,1,2,3} I mentioned earlier
03:32:39 <RayNbow> but I was wondering, what would happen with the object x and the identity arrow x->x when you construct P/3...
03:32:50 <RayNbow> since there is no arrow from x to 3
03:33:03 <kulakowski> id_x isn't an object of P/3
03:33:36 * RayNbow nods
03:33:55 * soupdragon is a forgetful functor
03:34:37 <RayNbow> but if there's no trace of the object x nor id_x in P/3... how would you get x back if you try to find a forgetful functor P/3 -> P?
03:35:05 <kulakowski> Ah. You wouldn't.
03:35:17 <kulakowski> Forgetful functors don't have to be full.
03:36:04 <osfameron> except of forget
03:37:00 <kulakowski> Sorry I didn't mean full, I meant surjective for objects.
03:37:11 <RayNbow> ah
03:37:17 <kulakowski> For example there's a forgetful functor Field -> Set right?
03:37:34 <kulakowski> But no set of cardinality 10 has a field structure.
03:38:19 <RayNbow> ok, thx :)
03:38:45 <RayNbow> it was my misconception that the functor had to be surjective :)
03:43:09 <kulakowski> RayNbow: Is that book online by any chance?
03:48:23 <soupdragon> does anyone know if there is a GL example with a camera you can move and a background
03:48:52 <soupdragon> in haskell
03:49:39 <soupdragon> in a cube map
04:08:46 <themroc> yo :o
04:25:17 <Erik____> hey if someone is willing to help me with a quick problem message me, thanks :)
04:25:59 <RayNbow> you're not going to get help that way... it's not how IRC works ;)
04:26:14 <Erik____> well, i could type my problem in here
04:26:21 <Erik____> but it'd take up quite a bit of space :)
04:26:55 <RayNbow> then use a pastebin containing the relevant info ?
04:29:20 <themroc----> paste your code on http://pastebin.com/
04:29:24 <themroc----> and link it here
04:29:42 <Erik____> shouldn't you be reccomending that pastebin clone written in haskell?
04:29:42 <Erik____> anyway
04:29:43 <Erik____> http://pastebin.com/m52b98bbb
04:29:51 <Erik____> any help would be appreciated,thanks
04:31:14 <Saizan_> the pattern [b] matches only lists with a single element in them
04:31:21 <Saizan_> which is the 'b' in that case
04:31:34 <Saizan_> to match any list just use a variable like bs
04:32:18 <Saizan_> > [(a,True:xs) | (a,xs) <- [('c', [])] ]
04:32:20 <lambdabot>   [('c',[True])]
04:33:12 <Saizan_> > case [] of [b] -> ()
04:33:14 <lambdabot>   * Exception: <interactive>:1:133-152: Non-exhaustive patterns in case
04:33:38 <Erik____> ah, thanks, my bad I always fall into pattern match traps
04:35:44 <RayNbow> > let combine xs ys = map (fmap (False:)) xs ++ map (fmap (True:)) ys     in    combine [('a', [False]), ('b', [True])] [('c', [])]
04:35:46 <lambdabot>   [('a',[False,False]),('b',[False,True]),('c',[True])]
04:36:36 <RayNbow> > let combine xs ys = map (second (False:)) xs ++ map (second (True:)) ys     in    combine [('a', [False]), ('b', [True])] [('c', [])]
04:36:38 <lambdabot>   [('a',[False,False]),('b',[False,True]),('c',[True])]
05:07:40 <Phillemann> Can I specify a git repository in a cabal package?
05:10:03 <Phillemann> Ah, I can.
05:12:39 <ivanm> where?
05:13:51 <Saizan_> ivanm: e.g. http://hackage.haskell.org/packages/archive/syb-with-class/0.5.1/syb-with-class.cabal
05:14:56 <ivanm> *sigh* how do you decide if you've done enough to warrant a release?  I keep thinking I'm missing something... >_>
05:15:13 <ivanm> :o I didn't know about source-repository
05:15:19 <ivanm> is it new for 1.6 syntax?
05:16:02 <Phillemann> It is? Then I have to increase the cabal version number...
05:16:26 <ivanm> Phillemann: I don't know
05:16:31 <ivanm> hence why I'm asking ;-)
05:17:00 <Saizan_> probably, cabal check should tell you
05:17:10 <ivanm> http://www.haskell.org/pipermail/cabal-devel/2008-October/003915.html <-- applied in 08...
05:18:45 <ivanm> cabal check doesn't say anything...
05:20:25 <ivanm> and our friendly neighbourhood cabal hacker isn't around :s
05:21:17 <ivanm> well, ghc 6.6.1 doesn't mention it in it's cabal docs...
05:21:48 <Saizan_> show recent is your cabal-install ?
05:21:51 <Saizan_> *how
05:21:59 <ivanm> latest AFAIK
05:22:05 <ivanm> 0.6.2
05:22:08 <ivanm> is there a newer one?
05:22:38 <ivanm> 6.8.3 doens't have it either
05:22:42 <ivanm> so it must require cabal 1.6
05:22:54 <Saizan_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7161#a7161 <- i guess you need one compiled against Cabal-1.7
05:23:21 <Saizan_> hackage will tell you if you use the test upload anyway, i guess
05:23:33 <automatical> hey, i'm trying to find a library function that will remove the last item in a list and place it at the front
05:24:02 <automatical> either that, or take the first item and place it at the back
05:24:22 <ivanm> Saizan_: yup
05:24:24 <ivanm> it needs it
05:24:34 <ivanm> automatical: that's not a good thing to be doing with lists
05:24:37 <ivanm> do you _have_ to use lists?
05:24:49 <ivanm> otherwise, the second one isn't that bad:
05:25:06 <ivanm> s/bad/hard/
05:25:06 <twanvl> > let rotate xs = last xs ++ init xs in rotate "abcde"
05:25:08 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
05:25:11 <automatical> yea, i'm stuck with lists :(
05:25:14 <twanvl> > let rotate xs = last xs : init xs in rotate "abcde"
05:25:16 <lambdabot>   "eabcd"
05:25:26 <ivanm> > let firstAtBack (x:xs) = xs ++ [x]; firstAtBack _ = error "empty list" in firstAtBack [1..10]
05:25:27 <lambdabot>   [2,3,4,5,6,7,8,9,10,1]
05:25:53 <ivanm> twanvl: yeah, problem with that is it takes two list traversals just to get the last and init
05:26:06 <ivanm> you _could_ roll your own custom list traversing function...
05:26:11 <twanvl> usually that doesn't matter
05:26:33 <automatical> hmm
05:27:13 <ivanm> twanvl: well, yes, they could be fused or laziness could make it magically disappear
05:27:44 <ivanm> but if you were dealing with large lists and doing this a lot (in which case, why oh why are you using lists?), I'd still prefer to make a manual traversal
05:27:49 <twanvl> or the performance of your program doesn't matter at all, or this operation is not a bottleneck
05:28:01 <ivanm> true
05:28:12 <twanvl> If you plan on doing this a lot you should be using Data.Sequence anyway
05:28:23 <ivanm> twanvl: or something like it, yes
05:28:30 <ivanm> DList might even be suitable
05:28:39 <automatical> i'll have a look at Data.Sequence
05:28:43 <ivanm> or any other data structure that has cheap append
05:29:12 <ivanm> if you think Data.Sequence is cool, wait till you see FingerTrees! ;-)
05:30:00 <ivanm> @seen Cale
05:30:00 <lambdabot> Cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard Cale speak 5h 20m 50s ago.
05:30:04 <ivanm> hmmm....
05:32:02 <ivanm> @ask Cale do you think we should start making a Graphs category on hackage?
05:32:03 <lambdabot> Consider it noted.
05:43:59 <Peaker> down with explicit categories, go labels, or something less rigid
05:44:55 <ivanm> hmmm?
05:48:30 <Saizan_> Peaker: hackage's category are labels, each package can be in many of them
05:49:51 <Peaker> oh
05:53:01 <kulakowski> Am I the only one who gets confused when category is used to mean something not having to do with math?
05:53:47 <ivanm> kulakowski: heh
05:54:20 <ivanm> though most people have used the term category way before learning about it wrt maths, even those that don't learn category theory...
05:54:39 <mornfall> Yeah, but when you say graphs category...
05:54:46 <ivanm> heh
05:54:48 <hackagebot> network-multicast 0.0.4 - Simple multicast library (AudreyTang)
05:58:35 <soupdragon> kulakowski, no
06:00:36 <bremner> yay,  a terminology debate.  Maybe we can get something cross-channel going with #emacs by insisting on GNU/AJAX
06:01:10 * bremner mystifies all and sundry by responding a long finished discussion
06:02:33 <soupdragon> woah
06:02:37 <soupdragon> this is crazy
06:02:50 <Saizan_> what?
06:03:02 <mapreduce> That can happen when you don't use ERC, an IRC client where you need to scroll to the bottom to enter text.
06:05:26 <mxweas> So I downloaded a haskell installer for mac from http://hackage.haskell.org/platform/ It includes GHC and Haskell Platform. Is Haskell Platform just a collection of common libraries?
06:05:50 <Saizan_> mxweas: and some tools
06:06:05 <Saizan_> mxweas: like happy/alex/cabal-install
06:06:09 <mxweas> anything a beginner would be interested in?
06:06:35 <kulakowski> Has anyone written an IRC client in haskell? Seems like a lot of the IRC end of things would already exist for lambdabots
06:07:07 <mornfall> Hm. World rewritten in Haskell. Interesting idea. :)
06:07:50 <Saizan_> an haskell-scriptable client would be nice
06:08:32 <kulakowski> Saizan_: I think I meant that moreso than all written in Haskell, really.
06:08:57 <Saizan_> i've read of hircules, but i think it's a dead project
06:10:34 <kulakowski> One other thing I wondered about was a web browser. uzbl is about 3k lines of C in front of libwebkit, so I wonder how much effort it would be to have bindings in haskell etc.
06:10:55 <a_guest> I have unregistered a package installed from cabal source (runghc Setup unregister). How do I know which files were installed (copied to /usr/local/*), so I can remove them?
06:11:24 <ivanm> a_guest: if you hadn't of unregistered it, you might have been able to tell... ;-)
06:11:56 <a_guest> ivanm: how?
06:12:34 <ivanm> ghc-pkg describe <foo>
06:15:10 <ivanm> that gives you some info, anyway
06:16:08 <a_guest> ivanm: it seems to show lib-dir and import-dir. Cabal also use share-dir and bin-dir.
06:17:18 <ivanm> a_guest: did you do it globally or locally?
06:17:28 <a_guest> ivanm: globally
06:17:48 <ivanm> then I don't know :s
06:18:01 <ivanm> a_guest: which library was it?
06:18:39 <a_guest> since the package is manually installed, it is placed in /usr/local. Since I do not have much there, I manually search and remove.
06:19:47 <a_guest> ivanm: I had several libraries. These was removed by hand after 'runghc Setup unregister'.
06:20:37 <a_guest> I was wondering how
06:20:50 <ivanm> a_guest: you _could_ for each library configure and then build it, and see which files it creates
06:20:53 <a_guest> ... I can see all installed files.
06:20:56 <ivanm> otherwise... *shrug*
06:21:10 <mornfall> How do you check for existence of input of some properties with QC(2)?
06:21:32 <mornfall> I mean, will something like (property) ==> True DWIM?
06:21:59 <a_guest> ivanm: yes. But I thought there should be a standard way to see all installed files, such that I can remove them.
06:22:13 <ivanm> a_guest: not that I know of
06:22:29 <ivanm> a_guest: you might want to consider using something like stow in future
06:23:00 <ivanm> note that "runhaskell Setup.hs" isn't a package manager
06:23:12 <ivanm> it just builds and installs packages, just like a Makefile does
06:23:15 <pejo> mornfall, is "==>" implication?
06:23:36 <mornfall> pejo: Sort of. :)
06:24:57 <a_guest> ivanm: I used stow before i switched to gentoo. I have never understand why it should "inpossible" to remove installed packages.
06:25:05 <mornfall> Right, I get:   root-superset reachable sets exist: [Arguments exhausted after 0 tests]
06:25:11 <ivanm> a_guest: why don't you use the ebuilds then?
06:25:18 <ivanm> we spend so much time making them :(
06:25:18 <mornfall> Now I would like this to be a failure...
06:25:33 <ivanm> a_guest: but it's "imposibble" because the installed files aren't recorded anywhere
06:25:37 <ivanm> and tbh, why should they be?
06:25:43 <ivanm> don't forget, this is cross-platform...
06:25:50 <ivanm> and where would the file locations be stored?
06:27:31 <a_guest> ivanm: when installing from source packages, Makefile often provides a 'uninstall' option. If I save the source, I can remove packages afterwards.
06:27:54 <ivanm> a_guest: yes, but that's a per-source thing in Makefiles, isn't it?
06:28:04 <ivanm> and how many people do or want to keep the source floating around?
06:28:11 <mornfall> Well, more importantly, this uninstall feature in makefiles is quite unsafe.
06:28:17 <ivanm> yeah
06:28:18 <mornfall> It'll happily remove things you overwrote since then.
06:28:24 <ivanm> dependencies, etc. as well
06:28:39 <mornfall> You better save secure hashes of files you install so you know that you are removing what you installed.
06:28:49 <mornfall> And either way, this is somewhat complex.
06:28:57 <a_guest> emerge is my friend
06:29:12 <ivanm> a_guest: we have a haskell overlay
06:29:16 <Berengal> User installs are my friend
06:29:20 <ivanm> and we can add extra libs if you want them
06:29:25 <ivanm> s/libs/ebuilds/
06:29:49 <ivanm> mornfall: and should really be left to the package manager (and a real one, not just "make uninstall") as well
06:30:24 <a_guest> ivanm: does the overlay provides more recent versions than the official?
06:30:29 <ivanm> yes
06:30:45 <a_guest> the official are often old.
06:30:54 <ivanm> yes, we know
06:31:01 <pejo> mornfall, if ==> is implication, then both True and False implies True, so no testing is necessary.
06:31:02 <ivanm> (it's not my fault, I'm only an unofficial dev)
06:31:35 <a_guest> but there is also some safety risk using overlays.
06:31:54 <ivanm> what safety risk?
06:32:53 <mornfall> pejo: Yeah, but it's implication in the sense that the test won't proceed unless the head is True -- it'll abort and try with different values.
06:32:56 <Saizan_> a_guest: an uninstall feature is a long-standing ticket for cabal-install
06:33:01 <mornfall> pejo: I.e. not logical implication per se.
06:33:25 <mornfall> The problem sort of is that it's not a failure to not get any tests done.
06:33:26 <a_guest> ivanm: the layer provider can provide modified, evil, software (which gentoo also can)
06:33:38 <ivanm> a_guest: yes, so it's not that more evil
06:33:59 <ivanm> note that this isn't a public overlay (as in only certain people can make changes to it)
06:36:12 <a_guest> I might use this overlay, I am tired of few, old packages from the official gentoo. Thank you!
06:36:29 <ivanm> no worries
06:36:35 <ivanm> a_guest: we also have #gentoo-haskell
06:37:24 <a_guest> ivanm: good. I have spammed this channel too much today.
07:08:38 <desp> Type families!
07:08:51 <ivanm> desp: what about them?
07:08:55 <desp> They rule.
07:09:03 <desp> quicksilver: ping.
07:11:39 <hackagebot> graphviz 2999.0.0.0 - GraphViz wrapper for Haskell. (IvanMiljenovic)
07:23:16 <jeffwheeler> ivanm: congrats on completing the graphviz update :)
07:23:21 <ivanm> dammit, I should have changed that description...
07:23:29 <ivanm> > "bindings" > "wrapper"
07:23:31 <lambdabot>   False
07:23:37 <ivanm> lambdabot: what would you know?
07:23:45 <ivanm> ;-)
07:23:49 <ivanm> jeffwheeler: thanks! :D
07:23:54 <ivanm> the announcement has just gone out
07:24:29 <jeffwheeler> Yep, there it is at the top of my @haskell.org folder.
07:25:53 * ivanm creates the ebuild for gentoo and hits the sack
07:26:16 <ivanm> yay, late night last night to get all the code finished; late night tonight fixing it up and getting the documentation finished :s
07:43:36 <Peaker> ivanm: what kind of binding for graphviz are these? Around a library?
07:43:53 <Peaker> ivanm: do you interface with graphviz by creating a text .dot file or by an API to build a graph?
07:44:03 <Peaker> does it return an image, or positioning information?
07:44:11 <ivanm> Peaker: ummmm..... both ;-)
07:44:28 <Peaker> ah, I was kinda hoping to get rid of the textual intermediate :)
07:44:29 <ivanm> it creates the Dot code version of your graph, and passes it through to dot/neato/etc.
07:44:37 <ivanm> Peaker: well, there's no text file
07:44:45 <ivanm> AFAIK, there is no actual API to bind to :s
07:44:58 <Peaker> ivanm: oh, so what did you mean by "both"?  You mean you wrap the text interface with a combinator API?
07:45:16 <ivanm> <Peaker> does it return an image, or positioning information?
07:45:22 <ivanm> both to that question ^^ ;-)
07:45:25 <Peaker> oh :)
07:45:42 <Peaker> so to use your library, I use combinators, right? No need to write any text stuff?
07:45:43 <ivanm> I don't have graph drawing combinators, no
07:45:51 <Peaker> oh, so I do describe the graph textually?
07:45:57 <ivanm> there's various FGL -> DotGraph functions
07:46:06 <Peaker> What's FGL?
07:46:07 <ivanm> or you can create it by hand, using the data structure
07:46:11 <ivanm> @where fgl
07:46:12 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
07:46:51 <Peaker> oh, so you build an FGL Haskellishly, and you convert that to DotGraph which has an image or positioning information?
07:47:07 <Peaker> s/or/and at the end there
07:47:11 <ivanm> Peaker: DotGraph's show instance is the .dot code
07:47:24 <ivanm> but it passes the code to dot/neato/etc. directly without using a text file
07:47:43 <Peaker> and you don't have to deal with the text I suppose, the show instance is invoked by your dot invocation wrappers, I suppose?
07:48:01 <Peaker> too many "I suppose" there :)
07:48:02 <ivanm> and you can get back either the image from dot, the dotgraph with positioning information, or else get the positioning information put back into the FGL graph
07:48:06 <ivanm> Peaker: yup
07:48:09 <Peaker> ivanm: cool
07:48:11 <Peaker> ivanm++
07:48:20 <ivanm> Peaker: it was originally matthew-_'s
07:48:25 <ivanm> but I added the invocation stuff
07:48:32 <ivanm> (amongst other things)
07:48:44 <Peaker> ivanm: One problem we used to have when interfacing with dot from Python was that we had difficulty understanding, in the positioning information, what items of the source graph are what in the output graph - there were no unique labels :-(
07:49:06 <ivanm> *nod*
07:49:10 <ivanm> @time
07:49:11 <lambdabot> Local time for ivanm is Sun Jul 19 00:49:10
07:49:14 <Peaker> so we had to abuse the text label as a unique ID
07:49:14 * ivanm heads off to bed
07:49:17 <ivanm> Peaker: heh
07:49:26 <Peaker> but that's wrong because the label size is used by dot
07:49:36 <Peaker> anyway, night
07:49:40 <ivanm> well, if you do the FGL -> Dot -> FGL route, that's basically how you get it back
07:50:28 <Peaker> how do you find the unique ID's?
07:50:44 <ivanm> Peaker: of the nodes?
07:50:49 <ivanm> use the ones provided...
07:50:49 <Peaker> yeah
07:51:04 <ivanm> note that FGL uses [1..] as IDs
07:51:14 <Peaker> FGL -> Dot -> FGL  would just attach positions/sizes to each node, right?
07:51:22 <ivanm> Peaker: and edge, right
07:51:39 <Peaker> ah, dot retains the order, and thus FGL Id's remain right?
07:51:44 <ivanm> yup
07:52:03 <ivanm> but I really should go to bed now ;-)
07:52:03 <ivanm> cya
08:02:18 <jeffwheeler> Is there any way to move files in a darcs repo without having them deleted and recreated?
08:02:21 <Peaker> I wish coq/etc tutorials were HTML rather than PDF.  PDF is such an annoying format to read on a computer screen
08:03:14 <Axman6> jeffwheeler: darcs mv?
08:03:40 <jeffwheeler> Axman6: Oh, that seems so obvious. Thanks! :)
08:03:47 <Axman6> :)
08:04:48 <Peaker> I wish the entire FP community stopped using PDF's altogether
08:05:00 <Axman6> why? PDF's are awesome
08:05:10 <Axman6> it's just adobe's tools that suck
08:05:13 <Peaker> Axman6: because reading from 2 columns on my computer monitor is painful :-(
08:05:28 <Axman6> print :P
08:05:38 <Peaker> Axman6: I don't have a printer, and I prefer reading on-screen
08:05:49 <tavelram> Peaker, get a PDA?
08:06:01 <Peaker> The solution is not more hardware :-P
08:06:31 <tavelram> :p
08:06:33 <Peaker> Give me the text in more declarative form (i.e HTML), so I can print it, view it on screen, or what not..
08:07:08 <Peaker> I'm pretty sure people coming from different languages see this PDF stuff as another way this community is "detached" and academic, as the rest of the world is using HTML/blogs, and everyone here uses 2-column PDF's :-(
08:08:00 <dancor> write a pdf converter in haskell
08:08:21 <Peaker> extracting text with sane layout from PDF is extremely difficult, isn't it?
08:08:23 <tavelram> and your not allowed to ffi an existing one!
08:08:29 <Peaker> Its somewhat like decompiling Haskell back from the executable?
08:08:36 <dancor> ya your program will have to use awesome techniques
08:08:45 <dancor> you'll probably want to do a writeup afterward on it
08:08:49 <jeffwheeler> Peaker: I think you nailed it with that academic observation
08:09:33 <Peaker> jeffwheeler: I wish everyone just puts an .HTML and .pdf links right next to each other..
08:09:47 <dancor> well the fact that haskell is like "screw you, we're doing this the math way" might be more direct than the pdf thing
08:09:47 <jeffwheeler> Peakerer: I can understand that
08:10:24 <dancor> haskell is categorically exclusive
08:10:30 <Peaker> dancor: A *lot* of people find appeal in that, but would still be repelled by the annoying print-only formats
08:11:05 <Peaker> Its so much more fun reading Conal's/Augustuss's posts on their blog than in papers, IMO
08:11:07 <dancor> i'm not so sure about the size of that Venn segment
08:12:19 * jeffwheeler prefers the informal format of blogs, too; perhaps it's that I have yet to find a paper I can understand
08:12:27 <jeffwheeler> even papers about subjects I know, I can't follow
08:12:46 <kulakowski> I personally wish that we didn't need fingers, keyboards, eyeballs and screens as middlemen. It's practically 2010, shouldn't the computers be directly connected to my brain by now.
08:13:34 <dancor> i think a technology solution is more likely than a ppl solution
08:13:45 <dancor> i.e. OCR or pdf-decompiling
08:13:57 <dancor> wish i knew more about pdf text elements
08:14:03 <jeffwheeler> dancor: I think the solution has already started, in planet-haskell
08:14:13 <Peaker> jeffwheeler: I have spent a lot of effort following parts of "Simply efficient partial reactivity" by conal, then I read the same stuff from his blog, a while later, and it was much easier and nicer to read
08:14:52 <Peaker> dancor: doing OCR on PDF's and trying to reverse-engineer the columns out of it, and removing the hyphens and what-not, is a lot of unnecessary difficulty
08:14:58 <jeffwheeler> Peaker: exactly; it's much easier to follow peoples' blogs . . . I guess because they write in simpler language
08:14:59 <Berengal> Peaker: In my experience, stuff is usually much easier and nicer to read "a while later", no matter which source you're reading
08:15:13 <Berengal> Not to say blogs aren't sometimes easier to follow than papers...
08:15:35 <Peaker> jeffwheeler: http://xkcd.com/547/
08:15:43 <dancor> it's unnecessary difficulty ..when it's unnecessary ;)
08:16:41 <Berengal> A good paper is about as easy to read as a good blog post, but covers more material
08:16:45 <jeffwheeler> Peaker: haha, I had forgotten this one :)
08:16:52 <Peaker> "I spent all night reading simple.wikipedia.org, and now I can't stop talking like this." :)
08:16:55 <kulakowski> I think a lot of academic writing is terrible, but not because of techinical language. Some people are just bad writers.
08:17:08 <Berengal> A bad paper, however, is way more confusing than a bad blog. At least the blog you might catch the drift of
08:17:25 <Peaker> papers tend to be much more information-dense per page
08:17:29 <Peaker> than blogs
08:17:46 <Peaker> which makes it much harder to control the rate at which you want to swallow the information...
08:18:12 <Berengal> That too
08:18:20 <Peaker> you have to deeply follow it and be careful to maintain understanding, or else you just lose it.  With blogs you can drift in and out and still get the majority of the information
08:18:55 <Berengal> The problem with blogs is that people post half-finished subjects
08:19:08 <kulakowski> I think those blogs are intended to be more pedagogical than papers
08:19:36 <Berengal> kulakowski: Some are, but some are just about "this nifty thing I coded last night"
08:19:50 <CalJohn> Peaker: the thing I found helpful when I started reading papers was that you have to give up on the idea that reading a paper is a constant time operation
08:20:00 <CalJohn> Peaker: I pore over some pages for many, many minutes
08:20:27 <CalJohn> that is not something that is "easy and fun reading" in the same way that I think a blog intends to be
08:20:30 <kulakowski> Berengal: Probably. (A lot of my perspective is from math rather than CS).
08:21:04 <Berengal> CalJohn: Some papers are easy and fun reading though, and some are outright entertaining
08:21:10 <CalJohn> a lot of the haskell papers are approaching mathematics papers in style (ie: "from this it follows that..." x)
08:21:30 <Peaker> CalJohn: yes. And I don't think that it has to be that way. If you stretch that page over 5-10 pages in a blog, and the whole paper over 10 blog entries, you get something that's much more fun to read, and can be done at leisure, rather than as a full-concentration chore
08:21:31 <CalJohn> Berengal: yeah, agreed, but it's not something I would do when I'm tired, unlike poking around reddit
08:22:49 <CalJohn> Peaker: I actually rather the papers, I have to say. The concentration and clarity of them is, for me, a nice thing
08:23:27 <Peaker> CalJohn: papers also tend to go out of date (I guess it has something to do with having to re-generate/upload pdf files) whereas blogs seem to be more up-to-date w.r.t errata and such
08:23:38 <CalJohn> that's not to say that I don't get annoyed sometimes, especially when I didn't know some of the concepts.  I'm still a beginner, but when I was a real beginner, it was really hard
08:23:43 <Peaker> CalJohn: and blogs have comments on the bottom where people ask about the stuff that wasn't clear, or you can ask, etc
08:24:13 <CalJohn> yes, I with there was some kind of site with a thread for each published paper so people could talk about them
08:24:18 <CalJohn> s/with/wish
08:24:21 <Peaker> CalJohn: I just read "Why Dependent Types Matter".  It doesn't make clear what audience it caters to, but it definitely wasn't me - as I had to reverse engineer tons of the terms being used there in order to follow anything at all
08:24:46 <Peaker> CalJohn: I tried giving it to my friends, but they all gave up on understanding any of it after a few pages, despite, IMO, the content not being that difficult to grasp, if explained properly
08:25:04 <Peaker> its not that the paper is badly written, just too information-dense and assumes too much background in the audience
08:25:35 <Peaker> btw: It was an awesome read, I finally got a glimpse of dependent types -- totally awesome :-)
08:26:21 <CalJohn> Peaker: I haven't read that paper, sorry.  I can understand exactly the feeling when papers are above your level.  Is it so frustrating, because you trudge through before having to give up.
08:26:35 <Peaker> CalJohn: eventually I think I understood most of it, but it was very difficult
08:30:37 <Peaker> ouch, Coq uses type-level information to decipher the syntax.. Bad idea, IMO
08:30:50 <Peaker> at least, that's the way it seems so far
08:31:47 * Berengal wonders if proof-driven development will become a fad some day
08:32:00 <soupdragon> haha
08:32:24 <soupdragon>  <Peaker> ouch, Coq uses type-level information to decipher the syntax.. Bad idea, IMO
08:32:29 <soupdragon> no it doesn't
08:32:31 <kulakowski> Berengal: do you mean proof-as-computation, or programs with proofs of correctness?
08:32:50 <soupdragon> It's called interpretation scopes
08:32:59 <Berengal> kulakowski: either, actually. Both would be interesting as a fad
08:33:14 <soupdragon> it's conceptually similar but much cleaner
08:33:17 <kulakowski> I think the latter has happened before.
08:33:29 <Peaker> soupdragon: I'm reading "Coq in a hurry" and it says Coq distinguishes * (type product) from * (multiplication) by checking the types "must respect a type discipline"
08:33:48 <Berengal> To some degree, yes. Although I wasn't around for it, tdd seems to be a bigger fad
08:34:15 <Peaker> Berengal: I don't think it will be a fad. I think that once it becomes as easy as it can be, it will be a mainstream discipline. But it may take a loong time :)
08:34:52 <Peaker> soupdragon: I interpret that to mean that to understand what the name of the function actually is, it does a type-check.  Is that wrong?
08:35:31 <Berengal> Peaker: Well, proof-of-correctness is already the underlying philosophy behind types
08:35:32 <jeffwheeler> What was that GHC z syntax thing, that the linker sometimes uses?
08:35:44 <Berengal> Although some languages do their utmost to hide that fact...
08:35:51 <soupdragon> Berengal: I don't agree with that
08:36:12 <mauke> jeffwheeler: z-encoding?
08:36:12 <Peaker> Berengal: proof of type-correctness is not yet proof of correctness.  Even with dependent types its not quite there (but its much closer)
08:36:28 <soupdragon> to me, types are not related to program correctness
08:36:32 <jeffwheeler> I'm getting strange linking errors to yizm0zi6zi1_YiziUIziPangoziMenu_a_closure; I have no idea what that means
08:36:38 <jeffwheeler> @where z-encoding
08:36:39 <lambdabot> I know nothing about z-encoding.
08:36:40 <mauke> preflex: zdec yizm0zi6zi1_YiziUIziPangoziMenu_a_closure
08:36:40 <preflex>  yi-0.6.1_Yi.UI.Pango.Menu_a_closure
08:36:54 <jeffwheeler> hmm
08:37:16 <jeffwheeler> Oh, I know.
08:37:26 <Peaker> soupdragon: how do you see types, if not proofs of correctness of some aspect of the program?
08:37:29 <Berengal> Peaker: Types allow a computer to prove some errors aren't present. To me that's a proof of correctness, even though it doesn't prove everything's correct
08:37:30 <jeffwheeler> Thanks, mauke.
08:38:01 <Peaker> Berengal: correctness of limited aspects, though.  Extending the scope of that could be a great "fad" or better yet, a great improvement in software discipline
08:38:42 <jeffwheeler> (The error was caused by a module being imported, but not listed in the cabal file)
08:40:05 <kynky> compiler compiles, but also does some checking like a test, although never a replacement, for a strict language, can do more checks than say a dynamic one, so the dynamic one has more chance of run time errors, but unit tests should be written in any case, and there are many elements to programming which make it correct, if something works doesnt mean its the correct soluion
08:40:26 <Berengal> Peaker: Indeed, types don't prove everything, and different type systems prove very different things to very different degrees of completeness. However, they're a stepping-stone
08:40:44 <soupdragon> types just repeat what was written in the program -- although they might focus and clarify on specific aspects, erasing others
08:40:57 <Peaker> Berengal: also, the proof is only valid without stuff like unsafePerformIO/unsafeCoerce/etc
08:41:31 <Berengal> Peaker: Indeed, and sometimes, in a bad type-system, you'll get false positives
08:42:14 <Berengal> in java, 'if (foo instanceof Bar) foo.barMethod();' is an error, but it's provably correct.
08:42:51 <soupdragon> consider:   3 :: Int,   3 :: Num a => a,  3 :: Odd,  3 :: Number 3
08:43:16 <Saizan_> all consistent type systems have "false positives"
08:43:34 <Saizan_> i.e. well-behaved terms that are ill-typed
08:44:06 <Berengal> True...
08:46:05 <soupdragon> In Haskell types focus on what programs fit together (mostly),  but there are ones that focus on making sure macro expansions are well scoped,   or where effects do/don't can/can't propagate to
08:50:13 <Peaker> Haskell types have lots of creative uses as witnesses and what-not
08:50:45 <badsheepy> :r
08:50:49 <badsheepy> oops
08:50:50 <Peaker> also, I find the use of types to make sure ST computations are not dependent on evaluation order (cannot pass STRefs between ST computations) to be creative
08:51:05 <Peaker> badsheepy: I thought that was a smiley slurping spaghetti
08:51:17 <Axman6> badsheepy: are you trying to kill us all? :O
08:54:19 <Berengal> Someone wants to give me lots of money
08:57:15 <Axman6> Berengal: i can see how that could be a problem. how about you give it to me and everything will be all right
08:57:20 <Cale> Hmm... I suppose one definition would be that types are properties of a program for which the program itself can serve as a proof.
08:57:21 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:58:22 <soupdragon> I think programs as proof is valuable only in theorem proving
08:58:53 <Cale> soupdragon: It's also useful as a way of thinking while writing programs, I find.
08:59:23 <Cale> Many of the ways of thinking which you employ in trying to write a proof are similar to those you'd want to employ in writing a program.
09:00:01 <soupdragon> I agree with that but types don't matter,
09:00:18 <Cale> Oh?
09:00:32 <soupdragon> I use 'induction' on the length of a list in scheme too
09:00:38 <Cale> That's like saying that theorems don't matter. It's somewhat true, the proofs are more important than the theorems.
09:00:58 <Cale> But I think they're still important.
09:01:18 <SamB> Cale: why "like"?
09:01:23 * Berengal is suddenly 15K richer
09:01:30 <Cale> SamB: huh?
09:01:39 <SamB> Cale: why not "is"?
09:01:49 <soupdragon> haha it's only like saying that theorems don't matter *if* I accept programs as proof!
09:02:05 <soupdragon> I'm disputing that though
09:02:27 <SamB> soupdragon: well, point, Haskell programs really aren't
09:02:28 <Cale> soupdragon: Well, there's a sense in which types are undisputably theorems.
09:02:53 <SamB> Cale: is it a theorem if you haven't figured out how to prove it yet?
09:03:14 <Cale> SamB: Depends on context.
09:03:53 <kynky> there is a god, is just a theorem?
09:04:12 <SamB> I mean, something doesn't get to be a theory until you can show that it is consistant with observations -- before that it's called a hypothesis, yes?
09:04:16 <Cale> kynky: Things which you can't write formally obviously can't be.
09:04:51 <SamB> yeah, mathematics and science are unable to express a concept of "God"
09:04:52 <Cale> There's a metamathematical definition of the theorems of a formal system as the set of all provable statements.
09:05:02 <desp> What's the simplest way to get integers in the type system?
09:05:15 <SamB> desp: simplest for what?
09:05:20 <soupdragon> desp, you can use she
09:05:28 <Cale> But normally, things only become theorems once we have a proof, and before that, they are at most conjectures.
09:05:43 <soupdragon> desp, e.g. http://www.e-pig.org/epilogue/?p=195
09:05:44 <desp> SamB: Peano numerals seem the simplest way to get naturals.
09:05:45 <SamB> Cale: ah, conjectures.
09:05:54 <kynky> i thought the proof came after the theorem ?
09:06:05 <Cale> kynky: It actually comes before :)
09:06:09 <soupdragon> hehehe
09:06:17 <SamB> desp: might be a bit slow to typecheck though
09:06:26 <desp> SamB: no worries, small sizes.
09:06:29 <Cale> kynky: We just tend to write it after, since it's usually helpful to know what we're proving.
09:07:19 <desp> soupdragon: literate Haskell without the literacy? :)
09:07:58 <SamB> desp: ah, okay, well then I guess you want a "negative | zero | positive" representation, where the magnitudes for negative and positive are represented with peano+1
09:08:21 <soupdragon> nicer is binary.. than peano
09:08:34 <SamB> kynky: well, in a book, yes. in history, the proof makes the theorem.
09:08:41 <Cale> Nicer in some ways, harder to define operations though.
09:08:55 <SamB> Cale: hmm?
09:09:02 <SamB> oh, binary
09:09:03 <soupdragon> hm stuff like division is easier
09:09:05 <Cale> yeah
09:09:14 <desp> I'll be happy with a working sum relation.
09:09:15 <SamB> is division actually easier in binary representation?
09:09:19 <soupdragon> yes
09:09:20 <kynky> most famous theorem i can think of is pythags
09:09:42 <soupdragon> desp, I showed you that already
09:10:03 <SamB> desp: anyway, did you look for what you want on hackage?
09:10:05 <desp> soupdragon: I don't see how that includes negative numbers.
09:10:06 <Saizan_> soupdragon: integers /= naturals
09:10:10 <desp> SamB: yes.
09:10:18 <Berengal> I like the theorems that turned out to be wrong the best
09:10:21 <SamB> desp: no signed numbers in the type system?
09:10:28 <Cale> Berengal: like what?
09:10:37 <Berengal> Gives me home that the second law of thermodynamics might not be true after all
09:10:44 <Berengal> sope*
09:10:45 <Berengal> bah
09:10:47 <Berengal> hope*
09:11:07 <kynky> but if the proof is before the theorem, than for wrong theroems, then those proofs were justplain wrong i take it ?
09:11:12 * SamB gives Berengal some soap lambdas
09:11:34 <SamB> desp: what about type-int?
09:11:36 <Cale> Berengal: Because some foundational theorems in statistical mechanics might be overturned?
09:11:37 <SamB> @hackage type-int
09:11:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-int
09:12:12 <Cale> Berengal: I think it's somehow more likely that the scientific application of those theorems as a model turns out to be inappropriate in some cases.
09:12:13 <SamB> hmm, it has a shorter URL too: http://hackage.haskell.org/package/type-int
09:12:26 <Cale> kynky: right
09:12:41 <beutdeuce> What is Haskell 2010?
09:12:54 * SamB does hope that the laws of thermodynamics turn out to be oversimplifications
09:12:54 <Berengal> Cale: Yeah... It's a silly notion of mine, really
09:13:05 <soupdragon> new name for Hypeskell'
09:13:18 <SamB> soupdragon: not really
09:13:34 <SamB> I think Hypeskell' is now known as Haskell 2
09:13:56 <soupdragon> I thought it was same people same project?
09:13:57 <Cale> kynky: If the proof is correct, but the theorem is wrong, then the assumptions used by the proof must have been wrong.
09:14:00 <Berengal> I think Haskell 2000 would be a better name...
09:14:15 <SamB> hmm. hackage really needs something debtags-like ...
09:14:16 <kulakowski> Berengal: are you the one that said Haskelltron 3000 would be best?
09:14:22 <soupdragon> I like Haskevac 3000 Turbo
09:14:26 <Peaker> anyone knows what Epigram offers beyond Coq, except for syntactic differences?  Is it the allowing of unproven partial functions?
09:14:26 <kulakowski> or anythingTron
09:14:29 <Cale> kynky: Which is something that usually we don't worry about, since every mathematical truth is relative to the assumptions used by it.
09:14:37 <Berengal> kulakowski: Yes, that would be best. I'm going for gradual change though
09:14:43 <desp> SamB: well, thanks, I'll see if I can simplify that a bit.
09:14:45 <soupdragon> Peaker: It's a completely different theory
09:14:54 <kynky> bt he proof could prove an unintentional theorem, based on those original assumptions?
09:15:05 <kulakowski> Berengal: That's no fun. Start a radical fundamentalist sect based on overturning the status quo.
09:15:05 <desp> SamB: best I found previously was http://liftm.wordpress.com/2007/06/03/scientificdimension-type-arithmetic-and-physical-units-in-haskell/ but it has some errors
09:15:08 <kynky> bt he = but the
09:15:09 <Cale> (that is, at some point it becomes not-a-mathematical-problem whether the assumptions are true or not)
09:15:13 <Peaker> soupdragon: any example differences?  I just read introductory papers of both and they seem very similar
09:15:16 <SamB> desp: hmm, except that seems to fail building often ...
09:15:20 <soupdragon> Peaker: Coq is the only one with a serious impl. though
09:15:26 <Berengal> kulakowski: Like the illuminati?
09:15:30 <kynky> (stupid keyboard :)
09:15:45 <kulakowski> I didn't know the illuminati cared about what haskell is called, but yes.
09:15:52 <Cale> kynky: Oh, I suppose it's possible that a proof is misinterpreted as proving something which it really doesn't and it actually proves something else, but that's just a big mistake then.
09:16:40 <Berengal> kulakowski: Of course you wouldn't know that. You wouldn't know anything about the illuminati unless we wanted you to
09:16:56 <kynky> Cale, well it happens in chemistry, but i guess thats off topic :)
09:16:57 <Cale> kynky: Normally, we view proofs as sort of like arrows going from a set of assumptions to some conclusion (or set of conclusions)
09:17:23 <Cale> and proofs are written in such a way (normally) as to make it clear as to what the assumptions are and what the conclusion is
09:17:26 <kynky> with a square or q.e.d. at the end
09:17:36 <Cale> If you want :)
09:18:20 <Ke> and can be trivially seen - operator in the middle of the proof ;o)
09:18:35 <Cale> One way of defining a proof is as a sequence of statements where each statement is either an axiom (or assumption), or it follows via a logical rule from some set of preceding statements in the sequence.
09:18:48 <beutdeuce> can someone point me in the right direction as to how i can approach the following problem => http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7168#a7168 . The thing is that i'm not sure how to get haskell to parse it to begin with.
09:19:08 <kynky> Cale, cheers
09:19:23 <Cale> and the last statement in the sequence is the conclusion of the theorem
09:20:04 <kynky> but you can prove proofs backwards though ?
09:20:07 <Berengal> beutdeuce: You can make the triangle into a list, or you could read it from a file with 'readFile "foo" >>= return . map (map read) . map words . lines'
09:20:25 <Cale> kynky: Well, when trying to find a proof, you can work backwards.
09:22:03 <Cale> and say, "Well, P is true, if this other thing Q is, so Q implies P", and then try to prove Q.
09:22:59 <beutdeuce> does haskell intepret 04 as 4?
09:23:07 <Berengal> > 04
09:23:09 <lambdabot>   4
09:23:31 <kynky> -1 = e^(i*pi) has many diff proofs, found that intresting
09:23:44 <beutdeuce> k
09:24:09 <soupdragon> > 010
09:24:11 <lambdabot>   10
09:24:16 <Saizan_> beutdeuce: "map (map read) . map words . lines" to parse that triangle
09:24:22 <Cale> kynky: Or you can turn things around by starting with the negation of the statement you're trying to prove as an assumption along with the other assumptions you're making, and show that this leads to a contradiction. This kind of proof tends to be unacceptable from a computational perspective, but in mathematics, we usually take it that if it's not the case that something is false then it must be true :)
09:24:43 <beutdeuce> what is the difference between . and $ ?
09:24:52 <Cale> beutdeuce: their types for starters
09:24:55 <Cale> :t (.)
09:24:55 <kynky> Cale like i the haskell prelude for false
09:24:57 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:25:00 <Cale> :t ($)
09:25:01 <Saizan_> the first is function composition, the other is function application
09:25:02 <lambdabot> forall a b. (a -> b) -> a -> b
09:25:17 <beutdeuce> o
09:25:18 <Cale> (.) takes two functions and composes them together to give a new function
09:25:27 <beutdeuce> k
09:25:33 <Cale> ($) takes a function and a value, and applies the function to the value
09:25:44 <soupdragon> (f . g) x = f (g x),  f $ x = f x
09:26:15 <Cale> $ is mostly interesting because it has really low precedence
09:26:16 * Berengal is now sitting on a one-liner to solve the problem
09:26:23 <Cale> So if you write something like:
09:26:25 <darkhelmetlive> i'm having an issue with the haskell platform. running ubuntu 9.04 x86, install ghc 6.10.4, install haskell platform, cabal update, then after that cabal segfaults or tells me a file does not exist
09:26:29 <Cale> f . g . h $ k x y
09:26:32 <Cale> then it means
09:26:38 <Cale> (f . g . h) (k x y)
09:26:43 <Cale> which means
09:26:48 <monochrom> Doesn't haskell platform include GHC?
09:26:50 <beutdeuce> f(g(h(k x y)
09:26:50 <Cale> f (g (h (k x y)))
09:26:57 <beutdeuce> k
09:27:20 <darkhelmetlive> monochrom: no. i have to grab it from source, and you need ghc 6.10.x already installed
09:27:24 <Cale> darkhelmetlive: hmm... Isn't the Haskell platform supposed to contain GHC?
09:27:35 <Cale> darkhelmetlive: ehhh?
09:27:56 <Berengal> Ubuntu needs to compile the platform from source, unless I'm mistaken
09:27:59 <Berengal> At least that's what I've done
09:28:01 <mike-burns> The definition of the Haskell Platform says that GHC is a part of it; however, the source tarball for Platform expects you have to GHC 6.10.3 or higher installed.
09:28:08 <Cale> darkhelmetlive: You shouldn't install GHC from source if you can avoid it. I was also unaware that there was even an Ubuntu version of the Haskell platform yet.
09:28:09 <darkhelmetlive> Cale: no. when i ./configure it it whines that i have an old version (6.8.2 is what's with Jaunty) and should update
09:28:46 <Cale> darkhelmetlive: ah, you're not meant to compile the Haskell platform yourself, I think. It's intended as a binary distribution.
09:28:53 <darkhelmetlive> Cale: i didn't installed ghc from source, i just used the binary install for 6.10.4. and there isn't, it's just the source distribution.
09:29:01 <monochrom> I see.
09:29:01 <Cale> huh
09:29:04 <mike-burns> darkhelmetlive: You can pass --enable-unsupported-ghc-version to Platform's configure.
09:29:18 <beutdeuce> i'm getting an 'Unexpected symbol ">>=" error
09:29:19 <Berengal> Remove Jaunty's ghc
09:29:25 <beutdeuce> @type >>=
09:29:27 <lambdabot> parse error on input `>>='
09:29:33 <Berengal> @type (>>=)
09:29:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:29:42 <Cale> darkhelmetlive: Personally, if I already had GHC 6.10.4 and cabal-install working, I wouldn't bother with the platform.
09:29:50 <beutdeuce> lol, i never got into Monads, they confuse me
09:29:54 <Cale> darkhelmetlive: You can get all those packages as you need them.
09:29:56 <darkhelmetlive> the weird thing is, i did this before, and it worked fine (but my HD died in a fire)
09:30:01 <Cale> darkhelmetlive: (by cabal-installing them)
09:30:29 <Berengal> beutdeuce: The monad was to read from file
09:30:52 <beutdeuce> Berengal: well, i'm getting an unexpected symbol >>=
09:31:08 <Berengal> beutdeuce: You could include the triangle as a string in your program to not have to do that, but then again you could just write it into a list of lists in the first place
09:31:11 * Cale is amused with the amount of gibberish produced over confusion about what the word 'monad' refers to ;)
09:31:14 <Berengal> beutdeuce: Got some code?
09:31:45 <beutdeuce> list = readFile "triangle.rtf" >>= return . map (map read) . map words . lines
09:32:10 <Berengal> beutdeuce: That in a file, or in ghci?
09:32:16 <beutdeuce> file
09:32:22 <conal> beutdeuce: if monads confuse you, try one at a time.
09:32:23 <Cale> beutdeuce: I'd start with   x >>= return . f  =  fmap f x
09:32:33 <monochrom> It's the same with "economics", "science", "education"... anything that society deems important.
09:33:14 <Cale> beutdeuce: so  list = fmap (map (map read) . map words . lines) (readFile "triangle.rtf")
09:33:33 <beutdeuce> whats the difference between fmap and map?
09:33:40 <Cale> fmap is more general
09:33:42 <mike-burns> :t fmap
09:33:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:33:44 <mike-burns> :t map
09:33:45 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:33:46 <Cale> map only works on lists
09:33:51 <Cale> fmap works on other structures too
09:33:57 <conal> fmap used to be named "map"
09:33:59 <Cale> It's sad that fmap isn't simply called map
09:34:05 <conal> amen
09:34:07 <mxweas> i'm up to chapter 6 in Real World Haskell. I feel like i understand the concepts, but im looking for some more hands on experience. Are there any beginner tutorials i could go through?
09:34:12 <Berengal> conal: It used to? When?
09:34:13 <Petrosian> Did it not used to be called simply map
09:34:18 <Cale> Berengal: Haskell 1.4
09:34:18 <Petrosian> `back in the day'
09:34:20 <conal> Berengal: 1.4 iirc
09:34:23 <Berengal> Ah
09:34:25 <conal> Petrosian: :)
09:34:31 <Petrosian> conal: Ye, just noticed!
09:34:37 <Cale> Berengal: Haskell 1.4 was *so* much cooler than Haskell 98 when it came to the Prelude
09:34:39 <jeffwheeler> mxweas: you might try playing with some of the more popular packages on Hackage
09:34:44 <conal> Berengal: left behind along with monad comprehensions
09:34:51 <Cale> Berengal: other features too, like monad comprehensions
09:34:52 <conal> sigh
09:34:53 <Cale> yeah
09:34:54 <jeffwheeler> mxweas: that is, bytestring, binary, etc.
09:34:59 <Berengal> Aren't monad comprehensions still in?
09:35:04 <beutdeuce> Cale: unresolved top-level overloading?
09:35:12 <Cale> Berengal: Only if you count do-notation.
09:35:24 <Petrosian> Record punning too, which was convenient
09:35:29 <Cale> beutdeuce: the type of 'list' that you're defining there is polymorphic
09:35:32 <mxweas> jeffwheeler sounds good
09:35:39 * monochrom counts do-notation. 1 little, 2 little, 3 little do-notations...
09:35:39 <mauke> since H98 no one has been able to comprehend monads :-(
09:35:41 <mxweas> ill check them out
09:35:46 <Berengal> Cale: I don't, but I usually prefer do-notation to list comprehensions
09:35:53 <beutdeuce> Cale: give it a type signature?
09:36:00 <Cale> beutdeuce: yeah, that'll work :)
09:36:14 <Cale> beutdeuce: Or use the results you get from it in a way that nails down what the type should be
09:36:15 <Berengal> Or :set -XNoMonomorphismRestriction in ghci
09:36:27 <Cale> It's not just the monomorphism restriction
09:36:48 <Berengal> Cale: Compiles for me with just NoMonomorphismRestriction
09:36:51 <Cale> and if you're going to set a language option, set it at the top of your file with  {-# LANGUAGE NoMonomorphismRestriction #-}
09:37:12 <Cale> Berengal: list on its own would, but do you get that same error?
09:37:23 <Cale> (without the option)
09:37:58 <Cale> Normally 'unresolved overloading' means that you tried to use something polymorphic and it couldn't tell in the end which type you wanted to use it at.
09:38:00 <Berengal> Cale: Right, true
09:38:08 <beutdeuce> Cale, Cannot justify constraints in explicitly typed binding?
09:38:20 <Cale> :t fmap (map (map read) . map words . lines) (readFile "triangle.rtf")
09:38:21 <lambdabot> forall a. (Read a) => IO [[a]]
09:38:44 <Cale> beutdeuce: You could give it a type like  list :: IO [[Integer]]
09:38:57 <beutdeuce> yeah
09:39:05 <Cale> (which is a bit of a funny name for it, since it's not a list)
09:39:11 <Berengal> getList
09:39:21 * jeffwheeler wonders why statusbar's 'b' is lowercase in Gtk/Gtk2Hs
09:39:39 <Cale> or how about getTriangle? :)
09:39:56 <Berengal> Something with get anyway. Or at least that's my style
09:40:01 <Berengal> get* or do*
09:40:15 <Berengal> Sometimes put*
09:40:36 <Cale> readAndParseTriangleFromFileEnterpriseEdition
09:41:03 <Berengal> Also, doesn't .rtf files save stuff in a funky format?
09:41:06 <Peaker> if inductive types are "initial algebras" - what are non-initial algebras?
09:41:33 <Cale> Peaker: Okay.
09:41:45 <Peaker> Cale: ?
09:42:07 <Peaker> Cale: I am wondering why inductive types are called "initial algebras"
09:42:18 <beutdeuce> hmm, the list is empty
09:42:19 <Cale> Peaker: If F is a functor C -> C, then an F-algebra is an object A of C, together with an arrow f: FA -> A
09:43:20 <Peaker> Cale: Okay.
09:43:40 <Cale> Peaker: The F-algebras of a given category, themselves form a category, where an arrow between two algebras (A,f) and (B,g) is an arrow h: A -> B such that h . f = g . h
09:44:44 <Ke> btw is there some module that does inverse on any linear operator (a->b)
09:44:59 <Cale> For example, consider C to be the category of sets, and let F be the functor which sends a set X to the set 1 + X (where + is disjoint union)
09:45:00 <Ke> or solves x out of Ax=y
09:45:06 <Berengal> beutdeuce: Try printing out the list, see what haskell reads it as
09:45:23 <Cale> Ke: there are a few packages for linear algebra on Hackage
09:45:31 <beutdeuce> Berengal: cannot infer instance
09:45:52 <Peaker> Cale: that's a bit abstract, I was hoping it wouldn't involve deep category theory.. Thanks for the explanation so far, but I think I'm going to work on my CT before understand that :)
09:46:12 <Berengal> beutdeuce: Sorry, meant, try printing out the file. readFile "triangle.rtf" >>= putStrLn
09:46:17 <Cale> Well, I can make this more Haskelly
09:46:21 <beutdeuce> k
09:46:29 <Cale> Take F to be the functor Maybe on the category Hask :)
09:46:35 <Berengal> beutdeuce: If it looks strange, the file's saving stuff in a weird format.
09:46:46 <beutdeuce> nope, its normal
09:46:54 <Cale> Then a Maybe-algebra is a type t together with a function Maybe t -> t
09:47:06 <Cale> Peaker: yeah?
09:47:25 <Peaker> Cale: sure
09:47:32 <Berengal> beutdeuce: put getTriangle makes an empty list?
09:47:34 <Berengal> but*
09:47:49 <beutdeuce> whats getTriangle?
09:48:00 <Berengal> beutdeuce: Sorry, "list"
09:48:08 <beutdeuce> yep
09:48:11 <Peaker> Cale: class Algebra t where extract :: t a -> a  ?
09:48:23 <Peaker> oops
09:48:23 <beutdeuce> well no
09:48:27 <beutdeuce> cannot infer instance
09:48:28 <Peaker> class Algebra f where extract :: f t -> t  ?
09:48:28 <Cale> Peaker: not quite...
09:48:44 <Cale> class Algebra f t where extract :: f t -> t
09:48:51 <Peaker> ah, okay
09:48:55 <Berengal> beutdeuce: Did you put its type as list :: IO [[Integer]] ?
09:49:00 <beutdeuce> yes
09:49:01 <Cale> It's not polymorphic, that is.
09:49:21 <Berengal> beutdeuce: What's the full error message?
09:49:29 <Peaker> Cale: each instance is not polymorphic, and is an Algebra that way, right?
09:49:35 <Cale> yeah
09:49:39 <beutdeuce>  print list
09:49:39 <beutdeuce> ERROR - Cannot infer instance
09:49:39 <beutdeuce> *** Instance   : Show (IO [[Integer]])
09:49:39 <beutdeuce> *** Expression : print list
09:49:58 <Berengal> beutdeuce: Ah, yeah, you don't "print list"
09:50:05 <Berengal> Just "list" in ghci should do it
09:50:16 <beutdeuce> doesnt return anything
09:50:29 <Cale> Now, notice that Nat together with the function f :: Maybe Nat -> Nat; f Nothing -> Zero; f (Just n) = Succ n is a Maybe algebra, but it's not just any Maybe algebra.
09:50:30 <beutdeuce> returns an empty line
09:50:30 <Berengal> doesn't print anything?
09:50:45 <Berengal> Try "list >>= print"
09:51:12 <Cale> If we have any other type t and function g :: Maybe t -> t
09:51:16 <beutdeuce> now i got it :), but what does >>= do?
09:51:28 <mike-burns> :t (>>=)
09:51:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:51:34 <pikhq> It's the monad bind operator.
09:51:56 <beutdeuce> Can someone please explain to me what a Monad is?
09:52:04 <Cale> Then there will be a unique function h :: Nat -> t with the property that h . f = g . h
09:52:07 <mike-burns> beutdeuce: It's a typeclass.
09:52:16 <Berengal> beutdeuce: If you look at it's type: m a -> (a -> m b) -> m b, the intuitive understanding is that it first performs "m a", then takes the result, the "a", and applies the argument (the function) to it, giving an "m b", which it returns
09:52:17 <beutdeuce> i know that :)
09:52:22 <Cale> Let's try to see what this will be :)
09:52:58 <Berengal> beutdeuce: It's how you get to the values inside the monads
09:53:51 <beutdeuce> oh, so because IO is a Monad, listing it doesnt return anything, but if you use >>=, it runs through the Monad and returns the values m b?
09:54:20 <Cale> oh, oops
09:54:32 <Cale> I've consistently made a stupid mistake ;)
09:54:38 <conal> beutdeuce: you might have an easier time if you try to understand IO and Monad separately rather than together.
09:54:42 <Peaker> Cale: the types didn't match up there, it was confusing
09:54:44 <Berengal> beutdeuce: I don't know how hugs works, but ghci at least will run an IO value if that's the result of an expression
09:54:46 <Cale> Peaker: It should be h . f = g . fmap h
09:55:07 <Cale> Peaker: Or, in CT notation, h . f = g . F h
09:55:26 <beutdeuce> Berengal: i would never choose to use Hugs, in fact, i always used ghci until i found out emacs has a haskell-mode, and that comes with Hugs. If i could change it to ghci, i definitely would ;)
09:55:27 <Berengal> beutdeuce: In ghci, if the value inside the monad is something other than () it will also print it
09:55:31 <Cale> (in the definition of an algebra morphism)
09:55:43 <Berengal> beutdeuce: haskell-mode can use ghci. I thought that was the default...
09:56:02 <conal> beutdeuce: i'm use haskell-mode with ghci right now
09:56:03 <Cale> Well, we know that  (h . f) Nothing = h Zero, and then (g . fmap h) Nothing = g Nothing
09:56:16 <Cale> So we have that h Zero = g Nothing
09:56:21 <Cale> and then
09:56:22 <beutdeuce> huh, mine starts Hugs with C-c, C-l, or C-c, C-b
09:56:25 <conal> beutdeuce: maybe you have an old haskell-mode
09:56:36 <Cale> (h . f) (Just n) = h (Succ n)
09:57:00 <beutdeuce> is '.' prefix? so . f x = f(x), or is it infix? so f.x = f(x)?
09:57:01 <Peaker> Cale: I see why   (h . f) Nothing = h Zero     but why    (g . fmap h) Nothing = g Nothing ?
09:57:11 <Peaker> oh, ok
09:57:12 <Peaker> :-)
09:57:12 <Peaker> silly me
09:57:17 <Cale> okay :)
09:57:35 <Berengal> beutdeuce: All operators are infix
09:58:10 <Beelsebob> beutdeuce: if you want to use an operator prefix, you can use (operator)
09:58:19 <Beelsebob> if you want to use a function infix, you can use `function`
09:58:29 <Berengal> > (.) (+1) (*2) $ 5
09:58:31 <Cale> (g . fmap h) (Just n) = g (Just (h n))
09:58:31 <lambdabot>   11
09:58:41 <Cale> right?
09:58:53 <Peaker> yeah
09:59:05 <beutdeuce> so fmap(map(map read) . map words . lines) (readFile "blah") = fmap(map(map read (map words lines))) (readFile "blah") ?
09:59:06 <Cale> (I could probably use some more time for the coffee to sink in here, so probably good to check things ;)
09:59:24 <Cale> So we have h (Succ n) = g (Just (h n)
09:59:26 <Cale> er
09:59:28 <Cale> h (Succ n) = g (Just (h n))
09:59:34 <beutdeuce> fmap(map(map read) . map words . lines) (readFile "blah") = fmap(map(map read (map words (lines)))) (readFile "blah") ?
09:59:45 <Saizan> beutdeuce: no
10:00:08 <Cale> So we have a recursive definition for h which falls out of the fact that it's supposed to be an algebra morphism, and that it's coming from Nat
10:00:08 <Berengal> beutdeuce: No, it's fmap (\x -> (map(map read (map words (lines x)))) (readFile "blah")
10:00:41 <Peaker> Cale: so h is uniquely defined by just the (Maybe t -> t) algebra, without needing the definition for the other algebra?
10:00:57 <beutdeuce> k, thnx
10:00:57 <Cale> We needed g to define h
10:01:17 <Cale> But we didn't care about the particulars of what g was.
10:01:24 <darkhelmetlive> Cale: the haskell platform works find with ghc 6.10.3
10:01:25 <darkhelmetlive> weird
10:01:29 <Peaker> Cale: Yeah, that's what I meant, before saying something completely different :)
10:01:39 <Cale> darkhelmetlive: Yeah, 6.10.4 just came out, I doubt it's been tested.
10:01:50 <conal> btw, here's some emacs code for viewing current day's #haskell log: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7171#a7171
10:01:53 <darkhelmetlive> oh well it's up and running now
10:01:59 <Cale> and this is the *unique* algebra morphism from (Nat,f) -> (t,g)
10:02:28 <Cale> Whenever there's a unique morphism from some object to any other object in a category, we say that object is initial.
10:02:36 <Cale> So Nat is an initial Maybe-algebra.
10:02:49 <Peaker> conal: cool, thanks :)
10:03:01 <conal> :)
10:03:18 <Cale> And one nice thing about initial objects is that they are all isomorphic to one another.
10:03:21 <Peaker> Cale: when is it said to be "non-initial"?
10:03:35 <Cale> When it's just some other non-special F-algebra
10:03:36 <Peaker> conal: can emacs show URLs in an emacs buffer?
10:03:45 <Peaker> conal: I guess with w3, iirc
10:03:52 <conal> Peaker: show URLs??
10:04:06 <conal> Peaker: oh -- page contents, given URLs?
10:04:11 <Peaker> conal: Yeah
10:04:25 <Peaker> conal: does emacs still have a web browser, basically :)
10:04:27 <Cale> For example, g :: Maybe Char -> Char; g Nothing = '\n'; g (Just c) = c
10:04:30 <conal> Peaker: i don't know.  that'd be useful.
10:04:35 <Cale> Or any other function like that.
10:04:42 <conal> Peaker: emacs does everything, so i guess it must.
10:04:55 <Cale> Almost any Haskell type will be a Maybe algebra in many different ways.
10:05:39 <Cale> But once we can talk about Maybe algebras and morphisms between them, we can start to find the special ones.
10:05:47 <Peaker> h Zero = g Nothing ; h (Succ n) = g . Just . h $ n
10:06:44 <Peaker> conal: emacs is a great operating system, but..
10:06:59 <Cale> In general, we might start with some functor, and ask what the initial and final algebras of it will look like
10:07:12 <Peaker> conal: but it lacks a good editor, in case you haven't heard that one yet :)
10:07:17 <Cale> and it turns out that these are like least and greatest fixed points (respectively) at the type level
10:07:26 <dolio> Has anyone not heard that one?
10:07:31 <conal> Peaker: hah!  no, i hadn't.  :)
10:07:42 <Cale> (I'm sure SamB will complain about my use of the word 'like' there)
10:09:38 <Cale> Peaker: If you think about types as subsets of some giant universe of elements and functors as functions on that universe, then Nat is a fixed point of Maybe
10:09:53 <Cale> Well, you have to be a little careful...
10:10:12 <Cale> It's a fixed point, up to isomorphism
10:10:30 <Peaker> Cale: thanks for all of that... (I gotta go now, and its starting to be difficult... :-)
10:10:35 <Cale> okay :)
10:14:35 <beutdeuce> is anyone here who is using ghci with haskell-mode in emacs able to get tab completion?
10:14:41 <nainaide> I am confused on  zipWith ($) (cycle [(*3),id]) [1..10]
10:15:01 <nainaide> what is (cycle [(*3),id]) mean ?
10:15:11 <nainaide> >  zipWith ($) (cycle [(*3),id]) [1..10]
10:15:13 <lambdabot>   [3,2,9,4,15,6,21,8,27,10]
10:15:15 <soupdragon> > cycle ["(*3)","id"]
10:15:17 <lambdabot>   ["(*3)","id","(*3)","id","(*3)","id","(*3)","id","(*3)","id","(*3)","id","(...
10:15:35 <nainaide> soupdragon, thanks
10:15:41 <conal> soupdragon: nice trick
10:15:44 <soupdragon> >  zipWith ($) (cycle ["(*3)"++,"id"++]) (map show [1..10])
10:15:46 <lambdabot>   A section must be enclosed in parentheses thus: ("(*3)" ++)A section must b...
10:16:14 <mauke> >  zipWith ($) (cycle [(*3),id]) [1..10] :: [Expr]
10:16:17 <lambdabot>   [1 * 3,2,3 * 3,4,5 * 3,6,7 * 3,8,9 * 3,10]
10:16:29 <pikhq> Ah, expr.
10:16:50 <nainaide> cycle [(*3),  cycle ["(*3)", id] both work
10:17:35 <nainaide> >zipWith ($) (cycle ["(*3)",id]) [1..10]
10:17:45 <nainaide> > zipWith ($) (cycle ["(*3)",id]) [1..10]
10:17:46 <lambdabot>   Couldn't match expected type `b -> b1'
10:17:53 <nainaide> > zipWith ($) (cycle [(*3),id]) [1..10]
10:17:55 <lambdabot>   [3,2,9,4,15,6,21,8,27,10]
10:18:30 <conal> expr++
10:18:34 <SamB> Cale: actually I won't
10:18:44 <SamB> since I forgot what initial and final algebras are again
10:18:45 <nainaide> soupdragon,  still a little confuse on  cycle ["(*3)","id"] and cycle [(*3),id]
10:19:13 <burp> :t "(*3)"
10:19:14 <Cale> Er, actually, was supposed to be final coalgebras
10:19:15 <lambdabot> [Char]
10:19:18 <Cale> But whatever ;)
10:19:20 <SamB> Cale: that too!
10:20:05 <SamB> I was thinking maybe you had actually said coalbebras, and had to scroll up to make sure not ;-). I guess my brain remembers that final goes with coalgebras?
10:20:28 <jeffwheeler> burp: try it without the quotes
10:20:49 <kulakowski> SamB: Usually when you dualize you can just put co- in front of everything
10:20:56 <burp> jeffwheeler, I wanted to show nainaide the difference ;)
10:21:05 <kulakowski> final could just as well be called coinitial (some authors might actually do so)
10:21:13 <jeffwheeler> burp: oh, didn't see the message above yours; my mistake
10:21:19 <monochrom> co-final :)
10:21:41 <SamB> kulakowski: I expect a lot of them mention this but continue to call them final?
10:22:09 <SamB> the co-ness is easy to remember, isn't it?
10:22:35 <Cale> But you can have final algebras, at least speculatively. I'm not sure if perhaps there aren't so many of them, or if they're usually not so interesting or why they're ignored.
10:22:51 <monochrom> Initially it was easy to pick opposite nouns for the duals, e.g., product-sum, initial-final, epic-monic. After a while it became too hard, e.g., algebra-what?
10:23:00 <kulakowski> SamB: Even if they don't it's perfectly clear. For words with natural duals (initial vs terminal/final and some others) its natural to just use the 'normal' words instead of using a prefix.
10:23:13 <monochrom> err that is not enough pun
10:23:22 <monochrom> Initially it was easy to pick opposite nouns for the duals, e.g., product-sum, initial-final, epic-monic. Finally it became too hard, e.g., algebra-what?
10:23:33 <SamB> kulakowski: yeah, that's what I meant by easy to remember ;-)
10:23:37 <kulakowski> But there's no natural english word for the dual of an algebra, or a limit, so coalgebra, colimit, cofinite, etc
10:23:43 <kulakowski> SamB: yes exactly
10:24:06 <beutdeuce> there is a problem now, lets say i want to add 1 to every number in the list. I cannot do that because there is no instance of (Num [[Integer[[)
10:24:12 <SamB> though for some of us it might not be easy to figure out that that counts as duality ;-P
10:24:13 <beutdeuce> Berengal: ^^
10:24:20 <Raevel> is Data.Data some recent ghc module?
10:24:29 <Berengal> beutdeuce: map (map (+1)
10:24:31 <Berengal> )
10:24:34 <monochrom> The opposite of algebra is make-a-guess.
10:24:37 <Cale> Cofinally it was codifficult to coannihilate opposite coverbs for the duals.
10:24:43 <copumpkin> lol
10:25:03 <SamB> Raevel: it's probably a "base" module used to implement "Data.Generic"
10:25:03 <monochrom> doublepluscogood
10:25:05 <kulakowski> At points it can get confusing. Direct limits being colimits and inverse limits being limits seems backwards, doesn't it :)
10:25:40 <Cale> It *is* backwards.
10:26:00 <SamB> Cale: s/coannihilate/colose/
10:26:26 <beutdeuce> Berengal: couldnt match a -> a1
10:26:37 <monochrom> It rubbed me the wrong way that co-equalizer and colimit are the desired directions for functional programming.
10:26:44 <Berengal> beutdeuce: Some code?
10:26:57 <Cale> picking something is 1 -> A, so copicking is A -> 1, which yeah, is losing it or annihilating it :)
10:27:34 <Cale> monochrom: hmmm
10:27:44 <beutdeuce> Berengal: list :: IO [[Integer]]  ; list = fmap (map (map read) . map words . lines) (readFile "/Users/Mark/Desktop/euler/triangle")  ;  revised = map (map (+1) list)
10:28:14 <Berengal> beutdeuce: fmap (map (map (+1))) list
10:28:15 <Cale> beutdeuce: type error
10:28:24 <Cale> beutdeuce: list is not a list
10:28:41 <Cale> beutdeuce: it's an action which when carried out will construct a list by reading a file.
10:29:01 <Berengal> Anyway, you probably want something like "main = do realList <- list; return (solveProblem realList)" then write solveProblem
10:29:06 <copumpkin> :t putStrLn <=< readFile
10:29:08 <lambdabot> FilePath -> IO ()
10:29:08 <kulakowski> Combine this with the fact that function application is on the wrong side (f:A->B should be written (a)f not f(a), or at least so say some) and who can remember left from right any more
10:29:12 <vav> nainaide:  ["(*3)","id"] -- to illustrate what cycle [(*3),id] looks like since plain (*3) isn't Show, can't print it
10:29:15 <Cale> beutdeuce: So the operations on lists don't directly apply to it, though you can fmap operations on lists over it to apply functions to the result of the eventual action
10:29:40 <Cale> beutdeuce: If you want to get a list from it, you can execute it inside of main, say.
10:29:45 <beutdeuce> Cale: got it, Berengal, i'll probably do that now
10:29:46 <Cale> main = do xs <- list
10:30:02 <Cale>           ... in here xs :: [[Integer]] ...
10:30:04 <Berengal> beutdeuce: Alternatively, instead of return, use print
10:30:41 <Cale> Also, you seem to be building a lot of the program into the IO here.
10:30:59 <Cale> Perhaps better to define a function  String -> [[Integer]]
10:31:20 <Cale> and then just use that from inside main once you read the file as a String
10:31:38 <Cale> (this is just about how you break up the program)
10:31:57 <monochrom> Cale: Fokkinga uses co-equalizer and colimit in his algorithm stuff. In his primer he doesn't even bother to primer on equalizer and limit.
10:32:10 <copumpkin> oh my, http://plan9.bell-labs.com/sources/contrib/fernan/escomma/Circuit.hs
10:32:53 <Cale> monochrom: That is interesting. I suppose that for computational purposes at least, coequalisers (equivalence relations) are much simpler than equalisers (solution sets of equations)
10:34:57 <Cale> and we do tend to make use of coproducts a little more liberally than products in functional programming, somehow.
10:35:04 <beutdeuce> whats the quickest way to convert that to a real list right off the abt?
10:35:08 <beutdeuce> bart
10:35:10 <beutdeuce> bat*
10:35:14 <Cale> beutdeuce: what I just said
10:35:19 <Cale> beutdeuce: Run it inside of main
10:35:37 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7172#a7172
10:35:39 <Cale> beutdeuce: But better yet, run the readFile right away
10:35:49 <Berengal> Write solveProblem
10:35:57 <Cale> beutdeuce: and that gives you a String, and you can forget about I/O from that point on, up until it's time to print the result
10:36:05 <beutdeuce> k
10:36:26 <Cale> beutdeuce: So structure your program as a pure function  String -> Integer, or whatever the result type is.
10:36:37 <Cale> and then the main action looks like
10:36:48 <Berengal> Also, there's a nice function...:
10:36:49 <Cale> main = do xs <- readFile; print (foo xs)
10:36:51 <Berengal> @type interact
10:36:53 <lambdabot> (String -> String) -> IO ()
10:37:12 <beutdeuce> k
10:37:31 <copumpkin> :t getContents
10:37:33 <Cale> Right. Somewhat ironically, interact is terrible if you're writing interactive programs, but for things like this, it's good :)
10:37:33 <lambdabot> IO String
10:38:25 <Berengal> I wuvs interact. It's like this gatekeeper between IO and pure programs...
10:38:43 <Berengal> The minimal needed to get a pure program to run
10:38:55 <Cale> (If you try to use interact to write interactive programs, you end up having to be very careful in controlling alternate strictness and laziness.
10:39:15 <Berengal> Cale: It's nifty for shell scripts
10:39:57 <monochrom> When I write in imperative languages I separate the I/O from the algorithm, too. It's just natural. I don't understand why other people interleave them.
10:40:12 <pikhq> monochrom: Bad habit.
10:40:20 <Cale> Yeah, if it's something where you don't care *exactly* when the output comes relative to the input, it's perfect.
10:41:02 <Berengal> main = interact (unlines . zipWith ((++) . (++" ") . show) [1..] . lines)
10:41:31 <monochrom> Of course I am referring to exactly the simple kind of programs specified to be "input the parameters, output the answers, batch mode".
10:41:35 <pikhq> Berengal: Line numbering?
10:41:39 <Berengal> pikhq: Indeed
10:41:46 * pikhq applauds
10:42:01 <monochrom> The wrong interleaving way actually pollutes most people's OOP programs too.
10:42:04 <Berengal> I also had one for indenting, but it used getArgs, so doesn't really fit in one line
10:42:07 <beutdeuce> Berengal: Couldn't match expected type `Char' against inferred type `[Char]'
10:42:13 <Cale> I feel that much points-free inside the zipWith isn't making things clearer
10:42:39 <Berengal> beutdeuce: I had a type in my first version, reload the paste to get the updated one
10:42:49 <beutdeuce> i did
10:42:57 <Cale> I'd probably have gone with zipWith (\x y -> unwords [show x,y])
10:43:06 <mike-burns> Cale: I agree.
10:43:14 <monochrom> A specification is given "read a filename from the user, open that file, operate on it, do this OOly, use an object to represent the file".  Do you know how people do it?
10:43:30 <monochrom> They read the filename inside the constructor of that class/object.
10:43:42 * Berengal needs to test his programs before releasing them to the world
10:43:57 <pikhq> monochrom: What?
10:44:01 <pikhq> That's evil.
10:44:01 <monochrom> class File { public F() { getLine...
10:44:04 <monochrom> YES!
10:44:10 <mike-burns> I do no such thing!
10:44:20 <pikhq> When I write in C, I try to do all my I/O in main().
10:44:30 <monochrom> It's so rampantly common that these days OO lessons have to stage a whole lecture telling you "don't do it".
10:44:38 <pikhq> It just doesn't seem right to do anything else.
10:44:48 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7172#a7175
10:45:00 <monochrom> It is a derivative of the same wrong interleaving of UI and internal algorithms.
10:45:22 <monochrom> It is even the antithesis to the "3-tier enterprise software" architecture!
10:45:32 <pikhq> People actually stick UI and internal algorithms together?
10:45:53 <monochrom> YES!
10:45:56 <soupdragon> yes
10:46:03 <soupdragon> thats the best way
10:46:06 <beutdeuce> Berengal: thnx
10:46:12 <pikhq> I thought the whole point of UI libraries was to let you just deal with the UI and have a small handful of callbacks into the code where you do all the computation?
10:46:33 <CalJohn> monochrom: yeah, it's pretty typical that most people don't know how to properly do OO
10:46:47 <CalJohn> monochrom: depressing though, isn't it
10:46:52 <mike-burns> It's pretty typical that most people don't know how to properly do FP, either.
10:47:02 <CalJohn> ^ agreed.
10:47:05 <kulakowski> OO being not at all special in this way
10:47:05 <Berengal> So in conclusion, most people can't program?
10:47:11 <mike-burns> Right.
10:47:12 <pikhq> We can conclude that most people don't know how to program, yes.
10:47:13 <CalJohn> I would say that, Berengal
10:47:20 <kulakowski> Most people can't _
10:47:22 <monochrom> So, as it happens, our functional "separate I/O from algorithm" predates the 3-tier enterprise architecture. Ain't us smart.
10:47:49 <mike-burns> Smalltalk was doing MVC long ago.
10:48:31 <Berengal> It's easier to get FP right
10:48:31 <CalJohn> IMO, if people were educated even only to OO right, the quality of software would vastly improve
10:48:43 <Berengal> At least in pure languages
10:48:49 <Cale> At least, Haskell makes it more painful than average if you don't separate the I/O from the rest.
10:48:53 <mike-burns> If people were educatd in how to test software, the quality of anything would improve.
10:49:02 <impl> I don't think the problem is education so much as it is comprehension
10:49:10 <impl> i.e., people are simply too dumb to understand it properly
10:49:23 <impl> or not interested. because they only write software to make money.
10:49:26 <monochrom> Folks, I have an alternative solution. If there were fewer people, the quality of anything would improve.
10:49:28 <Cale> impl: Then... educate them?
10:49:43 <impl> Cale: Education doesn't cure stupidity or indifference
10:49:55 <Cale> impl: It can.
10:50:09 <Cale> (when done properly)
10:50:28 <impl> I suspect there might be a chicken-and-egg problem there
10:50:30 <mike-burns> impl: The "only write software to make money" argument doesn't hold in a tough economy; those people are having their jobs taken away by people willing to learn new stuff, so they have to keep up.
10:50:45 <Cale> monochrom: As clearly evidenced by the past.
10:50:53 <monochrom> We have only seen and proven the effect of bad education. We haven't seen enough of the effect of good education to be sure.
10:51:09 <CalJohn> imo, the real problem is that computer software is largely a market for lemons -- ie: consumers find it hard to distinguish products
10:51:14 <Berengal> mike-burns: The new people willing to learn stuff won't touch the crappy legacy code with a ten foot pole
10:51:30 <mike-burns> Berengal: Not true; we just charge twice as much for it. :)
10:52:06 <monochrom> not with a ten-foot pole but with  ten thousand dollar paycheck :)
10:52:14 <Berengal> mike-burns: Hehe, true, but then the company has to decide if it wants to spend twice as much on you or the same amount on the other guy
10:54:15 <monochrom> The problem with the existing and scarce evidence of "good education => good work" is that good education has only been available to already non-stupid non-indifferent people (some exceptions but too few), so there is too much selection-bias to draw conclusions.
10:55:06 <shapr> Er, is this #haskell?
10:55:21 <monochrom> :(
10:55:50 <beutdeuce> Berengal: problem is much harder than i though ;)
10:58:43 <Berengal> beutdeuce: Stop coding and spend some time meditating on the algorithm
10:58:53 <copumpkin> om
10:58:57 <beutdeuce> good idea
11:00:15 <JuanDaugherty> just goes to show how complete the domination of the simple is, evern thinkers don't think thinking is doing
11:01:04 <Berengal> Thinking is doing, but coding isn't thinking
11:01:45 <monochrom> I probably derive the algorithm rather than meditate.
11:02:33 <JuanDaugherty> a few years ago I had the pleasure of having a client actually tell  me that he didn't want to pay for time I spent thining (about his application).
11:02:49 <pikhq> Cale: Haskell doesn't make it more painful than average to not seperate IO from the rest! There's unsafePerformIO!
11:02:52 <pikhq> :P
11:03:03 <pikhq> JuanDaugherty: I assume you walked right then?
11:03:22 <Berengal> pikhq: unsafePerformIO is painful to use
11:03:38 <pikhq> Berengal: Not painful enough.
11:03:55 <Berengal> pikhq: More than painful enough in a lazy environment
11:03:56 <pikhq> Its direct execution should involve physical pain.
11:04:04 <Berengal> Hahaha
11:04:27 <JuanDaugherty> well, not literally it was a completely remote biz relationship, and no it didn't end then, I just ignored it. You can't persist long as a humong if you don't learn to do so.
11:10:40 <amz> is it possible to do a O(n) shuffle in Haskell?
11:11:13 <monochrom> is that random shuffle?
11:11:49 <Saizan> via a mutable array you can
11:12:08 <monochrom> I use a mutable array for it too
11:12:13 <EvilTerran> oleg's written about pure shuffles
11:12:23 <det> Are multi parameter type classes known to break type inference?
11:12:31 <CalJohn> amz: http://hackage.haskell.org/package/random-shuffle
11:12:57 <monochrom> Yes. Usually adding fundeps helps.
11:12:59 <CalJohn> amz: though i don't remember the time complexity
11:13:02 <sjanssen> det: they're known to not work very well with type inference, this is why functional dependencies were invented
11:13:36 <det> What does "not very well" mean?
11:13:40 <det> confusing error messages?
11:13:59 <monochrom> Impossible to auto-infer everything.
11:14:00 <Saizan> the type information doesn't propagate as you'd expect
11:14:05 <copumpkin> having to annotate lots of things
11:14:18 <EvilTerran> a MPTC with no fundeps often fails to convey to the typechecker all the semantic meaning you want
11:14:36 <monochrom> I like it. Sometimes I don't want auto-infer.
11:15:51 <det> I'm thinking about something like a type class of a generic sequence (2 parameters, container type and element type) and it is hard to imagine why type inference would fail
11:15:57 <dolio> Oleg's is O(n log n), I think. It uses a tree.
11:16:10 <Saizan> i.e. if you have class Foo a b where foo :: a -> b, an instance Foo X Y, and you use "foo (x :: X)" it can't infer that the result you want has type Y
11:16:25 <Saizan> because nothing prevents you to also have an instance Foo X Z
11:16:34 <Cale> det: Because you wouldn't be able to tell from the container type alone that there isn't going to be another instance with a different element type
11:16:39 <EvilTerran> (unless you use a fundep)
11:16:40 <monochrom> That one is a solved problem. Use fundep. container instance determines element instance.
11:17:03 <EvilTerran> monochrom, unless you want containers that can contain more than one type
11:17:11 <det> Ok, thanks. I'll look into that.
11:17:15 <Cale> det: You can only tell that an instance exists and not that it doesn't exist when compiling a module, in general.
11:17:22 * EvilTerran has written a "FunctorOf" class which relied on there being no fundeps
11:17:29 <Saizan> if you add a fundep like Foo a b | a -> b then it can infer that the result is Y, because there can only be one instance for X as first parameter
11:17:42 <Cale> det: Because a future module might always come along and define another instance.
11:18:13 <Berengal> Fundeps mess up classes, imho...
11:18:18 <EvilTerran> "instance FunctorOf a a where fomap = id; instance (Functor f, FunctorOf a ga) => FunctorOf a (f (ga)) where ..."
11:18:23 <beutdeuce> Berengal: Cale: win :) => http://i3.photobucket.com/albums/y75/gmaster1440/Picture1-12.png
11:19:12 <Saizan> EvilTerran: the name doesn't look right to me..
11:20:04 <EvilTerran> Saizan, this was a while ago, i'd only recently picked up the term 'Functor', and didn't mind that i was probably abusing the term
11:21:48 <EvilTerran> Saizan, i was going for the intuition that, you could write an instance of that class for some complicated type `iff` you could write a Functor instance for a newtype-wrapping of that type
11:22:07 <EvilTerran> with the same behaviour
11:22:19 <det> is the MPTC problem solved only by fundeps or also by annotations ?
11:22:19 <Saizan> is fomap usable btw? or do you need a lot of annotations?
11:22:26 <EvilTerran> it worked, yeah
11:23:04 <BMeph> det: I don't see how annotating Saizan's example would resolve it.
11:23:20 <Saizan> foo (x :: X) :: Y would solve it :)
11:23:35 <Saizan> most of the time you can use annotations to manually do the work of fundeps
11:23:36 <monochrom> Annotation solves all problems.
11:23:50 <BMeph> Saizan: Until someone comes along with a "foo (x :: X) :: Z", sure. ;)
11:24:13 <Saizan> BMeph: well, that depends on what you think the problem is
11:24:30 <Saizan> BMeph: with :: Y i've chosen the instance, if there's also a Foo X Z might not matter to me
11:24:46 <det> im not sure what Saizan means by "foo (x :: X)"
11:25:02 <Saizan> i just meant foo applied to an argument of type X
11:25:21 <Saizan> i've started with "class Foo a b where foo :: a -> b"
11:25:32 <det> oh, ok
11:25:59 <det> ah, ok, I think I understand what you mean now
11:26:24 <monochrom> instance Foo (IO a) a where foo m = unsafePerformIO m
11:26:36 <det> fundeps somehow constrain the possible instances?
11:26:42 <Saizan> yes
11:26:42 <monochrom> instance Foo (Maybe a) a where foo = fromJust
11:26:51 <tavelram> what should i turn my attention to if i want a hash that isnt affected by datacorruption in the source, so that i can use it to some extent to decide if two corrupt files are the same?
11:27:02 <det> so if you already have a Foo X Y, it will complain if you define a Foo X B?
11:27:20 <Saizan> fundeps = functional dependencies, as in relational databases
11:27:23 <Saizan> det: right
11:27:28 <BMeph> Psychic powers? :0
11:27:39 <det> I'll have to look into fundeps, thanks.
11:28:15 <monochrom> Is there an MPTC article on the haskell wiki?
11:29:14 <tavelram> ie that it reacts more easily to larger changes than smaller ones, sort of the dual to the normal preferred characteristics...
11:30:35 <tavelram> perhaps summing up blocks and then single corruptions wouldnt propagate through the rest of the hash?
11:30:42 <tavelram> as much...
11:31:21 <monochrom> There is no MPTC article on the haskell wiki.
11:31:46 <monochrom> It may be wasteful to make one now, since we're at the turning corner of going AT.
11:33:03 <copumpkin> hmm, so AT repalces all cases for MPTC?
11:33:23 <Cale> tavelram: that's the usual strategy, I think.
11:34:42 <tavelram> Cale, ok, is there a name for this kind of behaviour? it having low entropy/something? any standard algorithms?
11:35:26 <Cale> tavelram: though, this still means that slightly different files hash differently, it's just that you can tell where there's a good deal of similarity and where there isn't.
11:35:29 <tavelram> its only a simple fold, but id rather base it on some research.
11:35:48 <tavelram> yeah
11:35:56 <copumpkin> http://en.wikipedia.org/wiki/Locality_sensitive_hashing ?
11:35:59 <Raevel> how do i get cabal to generate an executable?
11:38:03 <BMeph> tavelram: Another issue is how to handle the (presumably) huge number of ways that a file could be deliberately different from another.
11:38:05 <tavelram> Cale, yeah, i thought of grabbing like a few KiB and hash that, and ocmpare hashes, and when suitable compare the grabbed samples as well, toe liminate those kinds of things. I dont need a one-to-one mapping though, just a way to say "this seems to be the same files, within a certain corruption ratio.
11:38:08 <tavelram> codemac, Ill check it out.
11:39:14 <tavelram> BMeph, how do you mean?
11:39:21 <BMeph> ...and tab completion bites another @$$, yay. :\
11:39:34 <copumpkin> lol
11:40:28 <BMeph> tavelram: Say, your file is a program. Does adding another function at the front/middle/end qualify as a new file, or "the old file, but with (wanted) corruption"? :)
11:41:32 <tavelram> BMeph, true, in my case that would be a different file.
11:42:18 <tavelram> Im only interrested in the kind of corruption that can be caused by faulty memory, networktranmissions, storage etc.
11:43:08 <BMeph> tavelram: Case 2: What if you refactor an existing function in the file: same file (corrupted), or different?
11:43:36 <tavelram> BMeph, you are to source code oriented :p
11:44:40 <BMeph> tavelram: Hmm, I guess I am. My issue, though is: how do you separate the deliberate changes from the random? How do you measure the info content? :)
11:45:11 <tavelram> BMeph, this mainly concerns media files, which I dont intend to change myself :p
11:45:31 <BMeph> tavelram: Mmm...Photoshop! ;)
11:46:04 <tavelram> well, sure, but then you could visually inspect thme to decide :p
11:46:20 <BMeph> tavelram: A-HA! ;p
11:46:36 <tavelram> this should really be a fallback when a md5-check complains :)
11:47:57 <tavelram> Locality sensitive hashing seems to be kind of what i want though.
11:48:47 <BMeph> tavelram: Except what you want is "locality-insensitive hashing". :)
11:49:27 <tavelram> BMeph, actually not, but i do agree that the name seems a bit counter-intuitive.
11:49:42 <tavelram> "The basic idea is to hash the input items so that similar items are mapped to the same buckets with high probabilit"
11:50:22 <BMeph> Distance-sensitive hashing? :) <shrugs>
11:51:07 <tavelram> that would contain both of the above though :p
11:51:36 <BMeph> Coarse hashing! ;)
11:53:30 <BMeph> So, on another note: When do we start the Comonadic Revolution, and scare the bejeebus out of all those C# programmers who think they've gotten over their fright over "all that 'monad' stuff"? :)
11:53:30 <tavelram> ;)
11:54:27 <tavelram> just start blogging, and the community will follow...
11:55:05 <michie1> Comonads?  Good grief!
11:55:08 * michie1 cowers in fear.
12:02:25 <ray> zygohistomorphic prepromorphisms
12:04:18 <Berengal> katanamorphism
12:05:15 <kulakowski> Berengal: should be real. Why should everything be all greek anyway
12:05:59 <Berengal> because greek letters aren't in ascii
12:06:53 <copumpkin> lol
12:07:17 <copumpkin> 
12:07:31 <copumpkin> seems like *morphism should have something to do with that character
12:10:32 <copumpkin> and maybe 
12:13:45 <dolio> People eventually deviated from Greek.
12:14:24 <dolio> I don't think "prepro" is Greek.
12:14:45 <dolio> Futu probably isn't, either.
12:17:58 <kulakowski> which one's futu-? dual to hiso?
12:18:00 <kulakowski> histo
12:18:04 <dolio> Yeah.
12:18:31 <dolio> I'm not sure "histo" is legitimate Greek, either.
12:19:04 <dolio> I just looked it up, and it's Greek but it doesn't appear to have anything to do with "history", which is the connection with histomorphism.
12:19:51 <dolio> Futu- being future.
12:20:15 <kulakowski> 'history' actually does come from greek, but not directly
12:20:51 <copumpkin> katanamorphisms are the best though
12:20:58 <kulakowski> yes
12:21:10 <lpsmith> is there some reason (+) :: Double -> Double -> Double isn't fully strict?     The standard (sum [1..1000000]) example overflows the stack when compiled -O2
12:21:25 <lpsmith> (When using Doubles, that is,  not Ints)
12:21:29 <copumpkin> @src sum
12:21:29 <lambdabot> sum = foldl (+) 0
12:21:32 <copumpkin> it's not using foldl'
12:21:45 <dolio> > sum [1..1000000] :: Double
12:21:46 <copumpkin> or is that a different issue?
12:21:47 <lambdabot>   * Exception: stack overflow
12:21:50 <BMeph> lpsmith: Those two observations are not tied together the way you think they are. :)
12:22:01 <dolio> > sum (map fromInteger [1..1000000]) :: Double
12:22:05 <lambdabot>   * Exception: stack overflow
12:22:20 <lpsmith> > sum [1..1000000] :: Double
12:22:21 <Berengal> If (+) wasn't fully strict it wouldn't overflow the stack
12:22:21 <copumpkin> > foldl' (+) 0 [1..1000000] :: Double
12:22:23 <lambdabot>   * Exception: stack overflow
12:22:24 <lambdabot>   5.000005e11
12:22:38 <tavelram> > foldr (+) 0 $ [1..1000000]:: Double
12:22:41 <lambdabot>   * Exception: stack overflow
12:22:50 <lpsmith> BMeph:   the strictness analyser will fix the Int case
12:22:51 <Cale> lpsmith: It *is* strict, and that's the problem
12:23:02 <copumpkin> StrictAnal?
12:23:08 <Berengal> lpsmith: No, the Int case is speshulcased in the compiler
12:23:28 <ray> LaxAnal
12:23:52 <Cale> lpsmith: Watch what happens when we foldl (+) 0 [1,2,3]
12:23:57 <Cale> foldl (+) 0 [1,2,3]
12:24:04 <Cale> -> foldl (+) (0+1) [2,3]
12:24:09 <Cale> -> foldl (+) ((0+1)+2) [3]
12:24:14 <Cale> -> foldl (+) (((0+1)+2)+3) []
12:24:18 <lpsmith> Cale:  I'm well aware :-)
12:24:19 <Cale> -> ((0+1)+2)+3
12:24:19 <dolio> The answer appears to be: sum and product have SPECIALIZE pragmas for Int and Integer, but not Double.
12:24:33 <Cale> This next step is where the stack overflow occurs.
12:24:55 <copumpkin> dolio: ugh
12:25:01 <ray> sounds a bit more complicated than just using foldl'
12:25:10 <NHA_> Anyone around here actively using any of the FRP libraries on hackage?
12:25:12 <Cale> The previous steps will have been handled without any use of the stack, since foldl was able to pattern match without any difficulty
12:25:20 <Berengal> What happens to 'foldl (\!x !y -> x + y) 0'?
12:25:37 <Berengal> Compiled at -O2
12:25:40 <Cale> Berengal: The exact same thing
12:25:49 <Cale> Berengal: because (+) is already strict
12:25:54 <lpsmith> yupp
12:25:57 <Cale> Adding bang patterns isn't going to change anything
12:26:06 <Berengal> So the strictness analyzer doesn't catch that?
12:26:22 <Cale> It doesn't catch replacing foldl with foldl'
12:26:36 <copumpkin> there was a thread on -cafe recently about this
12:27:04 <copumpkin> apparently people want to keep sum = foldl (+) 0 in obviously very common case that anyone ever needs lazy numbers :P
12:27:18 <lpsmith> hahaha
12:27:18 <copumpkin> > sum [1..1000000000 :: Natural] > 5
12:27:22 <Cale> I wouldn't mind having sum' = foldl' (+) 0
12:27:24 <lambdabot>   mueval-core: Prelude.read: no parse
12:27:24 <lambdabot>  mueval: ExitFailure 1
12:27:29 <Cale> But I would like to keep both.
12:27:39 <Berengal> copumpkin: In my case it's a matter of consistency, but sum' would be nice to have
12:27:53 <copumpkin> why didn't that work by the way?
12:28:14 <Cale> the list was too long
12:28:22 <copumpkin> oh
12:28:24 <dolio> sum = foldl (+) 0 isn't actually good for lazy numbers.
12:28:25 <Cale> foldr is the one you actually want
12:28:27 <hackagebot> HXQ 0.17.2 - A Compiler from XQuery to Haskell (LeonidasFegaras)
12:28:28 <Berengal> > sum [1..1000000]
12:28:31 <lambdabot>   * Exception: stack overflow
12:28:34 <copumpkin> yeah, bah :P
12:28:35 <dolio> You'd want sum = foldr (+) 0.
12:28:37 <copumpkin> so why foldl at all?
12:28:39 <Berengal> > sum [1..1000000] > (5::Natural)
12:28:42 <lambdabot>   * Exception: stack overflow
12:28:43 <Cale> > foldr (+) 0 [1..1000000000 :: Natural] > 5
12:28:45 <lambdabot>   True
12:28:52 <BMeph> copumpkin: Your foldl' one worked, BTW. :)
12:29:02 <ray> in case (+) isn't associative?
12:29:05 <copumpkin> :)
12:29:13 <Cale> ray: hmm?
12:29:19 <Berengal> > foldl (flip (+)) 0 [1..1000000] > (5::Natural)
12:29:22 <lambdabot>   True
12:29:26 <ray> "why foldl at all"
12:29:41 <tavelram> > foldr (+) 0 $ [1..1000000]:: [Double]
12:29:43 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Double])
12:29:43 <lambdabot>    arising from the arit...
12:29:58 <Cale> Ah, yeah, you'd typically want it to be a right fold for the lazy one.
12:30:09 <Cale> I'm not sure why it's a foldl
12:30:21 <dolio> Because foldl' isn't in the report.
12:30:26 <Cale> Oh, right.
12:30:28 <BMeph> > foldl' (+) 0 [1..1000000] :: Double
12:30:30 <lambdabot>   5.000005e11
12:30:32 <lpsmith> foldl isn't completely useless in the lazy case, just not as generally useful as foldr.
12:30:38 <Berengal> In the case of lazy numbers, foldl vs foldr is just a matter of which argument the (+) is strict in
12:30:48 <Cale> The expectation is that it's up to the compiler to do optimisations which make that work properly.
12:31:06 <Cale> and I kind of agree with that view
12:31:09 <tavelram> > foldr (:) [4,5,6] $ [1,2,3]
12:31:10 <lambdabot>   [1,2,3,4,5,6]
12:31:12 <tavelram> > foldl (:) [4,5,6] $ [1,2,3]
12:31:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:31:31 <Cale> It would be terribly nice if we didn't need foldl' because applying foldl to a strict function would always compile to something efficient.
12:31:46 <lpsmith> > foldl (flip (:)) [4,5,6] [1,2,3]
12:31:48 <lambdabot>   [3,2,1,4,5,6]
12:32:04 <dolio> That might be doable if you're jhc.
12:32:07 <Berengal> Cale: Isn't this what the strictness analyzer is for ostensibly?
12:32:23 <Cale> Berengal: the strictness analyser is not quite that smart
12:32:27 <jmillikin> Is there any way to catch an exception outside of the IO monad? I'm working with a pure function which can throw, and would like to convert it to using Either.
12:32:33 <tavelram> anyone familiar with timber-lang btw?
12:32:37 <Berengal> Cale: I know, but couldn't it be made to be?
12:32:44 <Berengal> In some magical land with unicorns?
12:32:48 <copumpkin> maybe you could annotate an exported function to say it's strict in certain arguments
12:32:51 <Cale> Maybe, but separate compilation is hard.
12:33:07 <Cale> You might have to compile multiple versions of every higher order function.
12:33:16 <dolio> I guess you could get away with compiling two sums, one when you use strict functions, and another for non-strict functions.
12:33:19 <Cale> jmillikin: By design, no.
12:33:29 <Berengal> Yeah, you'd have to automatically derive and compile foldl' from foldl when compiling the prelude, sort of thing
12:33:45 <copumpkin> jmillikin: how do you have a pure function that can throw?
12:33:51 <Berengal> jmillikin: The solution is to use Either to start with
12:33:54 <Cale> jmillikin: Though you *can* cheat if you're insane like Baughn.
12:33:59 <Cale> ;)
12:34:08 <Cale> copumpkin: error
12:34:14 <pikhq> copumpkin: Define 'throw'. :P
12:34:16 <lpsmith> copumpkin:  pure functions can throw,  they just can't catch
12:34:21 <copumpkin> well yeah
12:34:36 <jmillikin> I'm using Data.Binary.Get , and when I try to getWord8 on a state with no more bytes, it prints an error.
12:34:48 * BMeph imagines a "trebuchet" function that throws copumpkins...
12:34:58 * copumpkin smashes BMeph
12:34:59 <jmillikin> I'm assuming that was generated via exception, since I don't know any other way to generate errors that ignore typing
12:35:00 <Berengal> I'm considering cheating as well. I need first-class patterns...
12:35:10 <ray> :t error
12:35:12 <Cale> jmillikin: Well, that's not exactly a pure function then is it? It's an action in the Get monad, no?
12:35:12 <lambdabot> forall a. [Char] -> a
12:35:20 <copumpkin> Berengal: meaning?
12:35:24 <jmillikin> Well, pure as opposed to IO
12:35:27 <ray> see, that doesn't ignore typing, it has a forall a
12:36:05 <jmillikin> ray: but if I understand correctly, there's no way to catch an exception raised via `error' except within IO.
12:36:09 <Cale> ah, but the Get monad is just a plain state monad.
12:36:16 <jmillikin> Right
12:36:23 <pikhq> Cale: Seems perfectly pure to me. It has no side effects, does it? It just happens that its return type is a monad.
12:36:33 <Berengal> copumpkin: choice [(\(Foo (Bar x)) -> x), (\(Bar x) -> x+2), (\(Foo Baz) -> 0)]
12:36:52 <copumpkin> Berengal: oh, for case
12:36:58 <Cale> pikhq: I was thinking that possibly the Get monad had a mechanism for errors (which you'd expect), but no, it's not a proper parsing monad.
12:37:13 <Berengal> copumpkin: For example
12:37:42 <copumpkin> how would you get taht working with GADTs?
12:38:04 <Berengal> No idea. I just know I want it, I haven't thought through how to get it :P
12:38:20 <pikhq> Cale: I'm considering IO functions perfectly pure under the interpretation that they simply return a world with modifications. ;)
12:38:33 <jmillikin> Prelude Data.Binary.Get Data.ByteString.Lazy> runGet getWord8 (pack [])
12:38:33 <jmillikin> *** Exception: too few bytes. Failed reading at byte position 1
12:38:41 <pikhq> (and that that world being returned actually *does something* is completely irrelevant. :P)
12:38:50 <copumpkin> jmillikin: yeah, that's a little annoying
12:38:52 <Cale> However, there is a Get action remaining :: Get Int64 which you can use beforehand to check if there's enough left.
12:39:21 <copumpkin> it's still frustrating to have to effectively check it twice
12:40:00 <jmillikin> So there isn't any sort of pureHandle :: (a -> b) -> b -> b function?
12:40:11 <Cale> Indeed. Data.Binary is really not so good if you don't have complete control over the input in the first place.
12:40:26 <Cale> jmillikin: Right, because that breaks referential transparency.
12:40:43 <jmillikin> Cale: how so? Given the same input, it should always return the same output.
12:40:49 <copumpkin> although in this case if you look from the outside it's referentially transparent
12:41:06 <Cale> jmillikin: Because you can use it to determine things about the order in which values are evaluated.
12:41:31 <Cale> jmillikin: Depending on which error gets thrown.
12:42:14 <jmillikin> Hmm. In that case, is there any alternative to Data.Binary which will provide better error handling?
12:42:32 <Cale> Yeah, Parsec ought to work better.
12:42:44 <jmillikin> Oh, parsec works on binary input?
12:42:56 <jmillikin> For some reason I had assumed it was string-only.
12:42:59 <Cale> It can. I'm not sure if there's an appropriate instance to start with.
12:43:06 <Berengal> Parsec works on arbitrary tokens on any instance of Stream
12:43:07 * Cale looks
12:43:11 <Cale> right
12:43:29 <Cale> It has an instance for ByteStrings
12:43:32 <Cale> (well, two)
12:43:35 <Berengal> Although it has mostly support for strings, or at least Char tokens...
12:44:43 <Cale> oh, that's really annoying
12:44:54 <copumpkin> it needs a Data.Text instance
12:45:02 <Cale> There are existing instances of Stream ByteString m Char
12:45:12 <Cale> and   Stream s m t  has a fundep  s -> t
12:45:17 <copumpkin> boo
12:45:19 <copumpkin> lame
12:45:33 <copumpkin> that needs to be Data.Text m Char
12:45:39 <Cale> right
12:46:07 <Cale> Well, it could also possibly be argued that the fundep is wrong.
12:46:19 <copumpkin> hm
12:46:23 <Cale> But I'm not sure how inconvenient it would make things to remove it.
12:46:24 <Berengal> Cale: ByteString isn't polymorphic, is it?
12:46:46 <Cale> Berengal: nope
12:47:13 <Berengal> So you'd need to fix the type of the tokens it contains
12:47:15 <Cale> There are two separate modules for Strict and Lazy bytestrings.
12:47:29 <Cale> ByteStrings are made of Word8 values of course
12:47:44 <Berengal> Yeah, but I assume the Stream instance use Char for convenience...
12:47:52 <Cale> But there's a module of functions which let you imagine that they are Chars
12:48:16 <Cale> Berengal: right, the problem isn't necessarily that there is an instance for Char. The problem is that there is not an instance for Word8
12:48:36 <Cale> (and there can't be now, because of the fundep)
12:48:47 <Berengal> Ah, yes, true. I'm too far into text world right now
12:48:50 <Saizan> i'm not sure if a typeclass really makes sense here
12:49:49 <Cale> Yeah, it would be better for the run function just to take uncons as a parameter.
12:49:51 <dolio> A first class module would make more sense. :)
12:50:10 <Cale> You don't have to go as far as a module, there's only one function.
12:50:51 <Berengal> uncons :: (List l) => l a -> Maybe (a, l a)
12:50:52 <Cale> There should just be a version of runParser which takes a function (s -> m (Maybe (t,s))) as a parameter
12:50:58 <BMeph> Cale: Yeah, shouldn't that be "Stream ByteString m Word8", assuming that "should" is the right word to use here... :)
12:51:33 <BMeph> ...and slow typing/reading bites another @$$, yay! ;p
12:51:47 <Cale> BMeph: Well, if you're going to keep the functional dependency, then perhaps.
12:51:55 <dolio> If you don't use a type class or a module, all your functions/parsers have to be parameterized by that uncons function, too.
12:52:07 <Cale> dolio: Really?
12:52:11 <Cale> dolio: Maybe internally.
12:52:21 <Cale> dolio: But >>= can take care of that.
12:52:30 * BMeph is lucky that his @$$ is so gi-normous, that all of those bites hardly even make a dent
12:52:44 <dolio> You'd have to roll it into a Parser type at least.
12:52:59 <Cale> Which is sort of what we've already done, isn't it?
12:53:10 <Berengal> dolio: Yep, but that's like one type and a Monad instance ;)
12:53:17 <Cale> I suppose currently it's just that all the functions take the typeclass dictionary as a parameter
12:54:04 <Cale> But you could also just make the Parser type internally take the uncons as a parameter.
12:54:14 <dolio> I suppose it turns every "Parser ..." into "ReaderT <uncons> (Parser ...) ...".
12:54:22 <Cale> right.
12:55:35 <dolio> Anyhow, that seems like a module thing to me, because the stuff in the Reader would be statically determined.
12:56:14 <Cale> I think there's a certain tendency for people to get distracted by fancy typeclass and module systems and forget about basic functional programming techniques :)
12:56:22 <dolio> Hence why the type class works, too.
12:57:58 <Cale> Typeclasses/first-class modules are great when you have comparatively little variation in the parameter, so for a given type, there will only be one implementation you'd ever want to use.
12:58:29 <Cale> (or few of them, anyway)
12:59:38 <desp> soupdragon: this she-thing...
12:59:55 <desp> Oh, he's gone.
13:00:00 <desp> Does anyone recognize this syntax?
13:00:03 <beutdeuce> how can i define multi-line functions in mathematica?
13:00:16 <desp> http://www.e-pig.org/epilogue/?p=195
13:00:35 <desp> Specifically, the {} bits.
13:00:54 <desp> Does this use some sort of preprocessor?
13:03:00 * Saizan thinks of a situation where a runtime-generated uncons would make sense
13:03:08 <Saizan> *tries to think
13:03:24 <dolio> she is the preprocessor, I think.
13:03:37 <Saizan> ?hackage she
13:03:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/she
13:04:07 <desp> Right.
13:04:07 <dolio> It appears to be a realization of the going-toward-dependent-typing Conor was talking about a few months back.
13:04:09 <desp> OK, never mind.
13:04:13 <dolio> Sooner than I'd have expected. :)
13:07:54 <dolio> The pattern declarations are cute.
13:08:44 <copumpkin> she is nice
13:08:52 <Cale> beutdeuce: don't hit shift-enter?
13:08:56 <copumpkin> but I'm not a fan of the import -> and import < - :P
13:09:40 <beutdeuce> Cale: ah, k. cause it doesnt indent
13:10:14 <Cale> It should indent things somewhat reasonably on its own if you haven't closed the bracket yet.
13:10:29 <beutdeuce> there is no bracket to close, just a :=
13:11:43 <BMeph> Is there a way to make it so that a module exports modules it imports, without making an explicit list of everything in said module?
13:11:46 <Cale> If I type f[x_] := and press enter, the next line is indented a bit automatically.
13:12:26 <beutdeuce> thanks, byt the line after that isnt
13:12:43 <beutdeuce> but*
13:15:24 <beutdeuce> Cale: only the line right after the := is indented, all following lines aren't, is that ok/
13:16:24 <Cale> eh? They'll be indented if they're logically a part of what came before
13:16:24 <FauxFaux> A list is totally not the right datastructure fo the topic.
13:16:44 <beutdeuce> Cale, lets say i want to define a variable then return it on the next line
13:16:55 <beutdeuce> f[x_] :=
13:16:57 <beutdeuce> x = 1
13:17:03 <beutdeuce> x // Return
13:17:15 <Cale> uh...
13:17:20 <Cale> What?
13:17:21 <beutdeuce> well not x in this case
13:17:22 <beutdeuce> but n
13:17:49 <beutdeuce> Traverse[{}] = 0
13:17:50 <beutdeuce> Traverse[x_] :=
13:17:50 <beutdeuce>  currentPosition = Position[list, x]
13:17:50 <beutdeuce> Return[currentPosition]
13:18:00 <Cale> Return?
13:18:04 <beutdeuce> Return isnt indented, only currentPosition = is
13:18:22 <Cale> ah, you want them to be connected with a ; ?
13:18:30 <beutdeuce> o?
13:18:41 <Cale> But you don't even need to do that separately
13:18:54 <Cale> the value of  a = b  is a
13:19:26 <Cale> So you could just write  Traverse[x_] := currentPosition = Position[list,x]
13:19:27 <beutdeuce> i just want to have abody to my function, which mathematica isnt letting me do
13:19:41 <desp> Does anyone have a simple example of type-level arithmetic using type families?  The one given in http://www.cse.unsw.edu.au/~chak/papers/families-fp-syd.pdf appears not to compile in the current GHC.
13:19:52 <Cale> beutdeuce: I'm not sure what you mean by 'body'
13:20:05 <beutdeuce> multiple lines of variable declarations
13:20:23 <Cale> beutdeuce: You want it to be a sequence of expressions evaluated in turn? Then use semicolons to connect them.
13:21:00 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7182 -- here's the problem.
13:21:05 <beutdeuce> how would i do so?
13:22:31 <Cale> beutdeuce: But in this case, you don't even need it. (x = 1; Return[x]) is the same thing as x = 1
13:22:50 <beutdeuce> i know i dont, i just gave a bad example of what i want
13:22:57 <Cale> But yeah, just like that.
13:23:05 <beutdeuce> so u need parens as well
13:23:43 <desp> Oh, I think I got it.
13:23:45 <Cale> Or, more likely, you can use Block[{x=1}, ...]
13:23:57 <Cale> where ... maybe has semicolons in it
13:23:58 <beutdeuce> k, thnx
13:24:38 <Cale> That ensures that the value of x is only affected inside the Block, and reset when it finishes.
13:24:40 <hackagebot> fsmActions 0.2.0 - Finite state machines and FSM actions (AndyGimblett)
13:24:54 <beutdeuce> nice
13:25:14 <Cale> There is also the slightly purer version:  With[{x = 1}, ...] which substitutes x for 1 wherever it occurs, more like Haskell's let/in
13:25:15 <Twey> Those are Flying Spaghetti Monster actions, of course
13:25:18 <Badger> Flying Spaghetti Monster
13:25:19 <Badger> heh
13:25:21 <Badger> quite.
13:25:24 <Twey> :)
13:26:04 <Badger> Twey: Is the FSM an FSM? :P
13:26:42 <Botje> pasta .. infinite tape .. sounds pretty similar :)
13:27:02 <Twey> Heh
13:28:39 <Berengal> The FSM is multi-threaded
13:35:07 <Peaker> The FSM is full of spaghetti code?
13:35:44 <Heffalump> just some no[odly|ndeterministic] appendages
13:35:55 <monochrom> ha
13:41:40 <jmillikin> Here's an implementation of what I'm trying to do in D.B.Get w/ error handling; any suggestions on how to make it not-ugly? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7186#a7186
13:43:55 <Beelsebob> jmillikin: things like Right $ Signature (map byteToType bytes), I'd express as Right . Signature . map byteToType $ bytes
13:44:14 <Beelsebob> getEither has an either in there
13:44:41 <Beelsebob> either (return . Left) f =<< getBytes count
13:45:45 <hackagebot> pandoc 1.2.1 - Conversion between markup formats (JohnMacFarlane)
13:46:27 <Beelsebob> getBytes has a bool in there
13:46:27 <Beelsebob> bool (return $ Left "not enough bytes") (return . Right . BS.unpack =<< G.getBytes count) . (< fromIntegral count) =<< G.remaining
13:47:37 <jmillikin> Any ideas on the block of lambdas in getSignature?
13:47:59 <Beelsebob> well, they can be done as a do block...
13:48:26 <Beelsebob> do [len] <- getEither 1
13:48:26 <Beelsebob>    bytes <- getEither (fromIntegral len)
13:48:26 <Beelsebob>    terminator <- getEither 1
13:48:45 <Beelsebob> oh wait
13:48:47 <Beelsebob> no
13:48:49 <jmillikin> I don't think that would work
13:48:55 <Beelsebob> yeh, I was misreading it
13:49:03 <Beelsebob> was reading $ as >>=
13:49:15 <Beelsebob> okay, well, you can get rid of the dos
13:49:22 <Beelsebob> because there's only 1 liners in there
13:49:57 <Beelsebob> Having said that...
13:50:03 <Beelsebob> I wouldn't aproach this problem this way at all
13:50:04 <jmillikin> If I remove the `do`s, GHC states there is a syntax error.
13:50:24 <jmillikin> Is there a better way? I'd be very eager to learn it.
13:50:34 <Peaker> jmillikin: Use EitherT  instead of Get (Either ..) ?
13:50:37 <Beelsebob> well, you need to add extra spaces in front of each subsequent line
13:50:45 <Beelsebob> I'd do it not in an imperative style at all though
13:50:48 <Beelsebob> read in the stream
13:50:53 <Beelsebob> and then do some functional programming to parse it
13:51:09 <jmillikin> "some functional programming to parse it" -- isn't that what this is?
13:51:21 <Beelsebob> it looks very imperative to me
13:51:54 <Beelsebob> there's no need for most of your program to be in the Get monad there
13:51:54 <jmillikin> Well the `len` needs to be parsed before reading the rest of the bytes, the terminator should be checked before converting bytes to types.
13:52:08 <Peaker> Beelsebob: The Get monad is imperative, yeah -- I am not sure how you define something with similar power declaratively
13:52:27 <Peaker> Beelsebob: But you can have significantly less power with something far more functional, e.g: The Applicative instance
13:52:32 <Peaker> jmillikin: Do you know Monad transformers?
13:52:39 <jmillikin> Peaker: never heard of them
13:52:51 <Peaker> jmillikin: I think they're exactly what you need here.. I can give a short tutorial
13:53:04 <jmillikin> This isn't showing any results for EitherT: http://haskell.org/hoogle/?hoogle=eitherT
13:53:33 <Peaker> jmillikin: unfortunately, EitherT is missing from prominent packages and there's ErrorT instead, though that probably fits your needs (a little ugly, imo)
13:53:44 <Peaker> jmillikin: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:EitherT
13:54:19 <Peaker> jmillikin: EitherT m l r    is basically   m (Either l r)    except "return" wraps it in both monads, and bind behaves like you'd like it to
13:55:35 <jeffwheeler> > 3  3
13:55:37 <lambdabot>   Not in scope: `'
13:55:49 <Peaker> jmillikin: Your getEither is really a ContT, btw :-)
13:55:49 <jeffwheeler> > let () = (==) in 3  3
13:55:51 <lambdabot>   True
13:56:00 <Peaker> @src ContT
13:56:00 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
13:56:03 <Peaker> ([Word8] -> G.Get (Either String a)) -> G.Get (Either String a)
13:56:18 <Peaker> a = [Word8] ;  m = EitherT G.Get String
13:56:23 <Peaker> @src ErrorT
13:56:23 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
13:56:35 <Peaker> oops, the arg order for EitherT/ErrorT is reversed
13:59:38 <Peaker> jmillikin: you there?
13:59:44 <jmillikin> Yes
13:59:50 <jmillikin> Trying to implement EitherT
14:00:17 <Peaker> jmillikin: ah. I was trying to compile your example, but its missing some stuff
14:00:26 <Peaker> jmillikin: but implementing EitherT is a great exercise
14:00:48 <jmillikin> Oh dear, that sounds dreadfully like something a professor would say.
14:00:59 <jmillikin> Just before walking out of the room, laughing.
14:01:38 * Peaker supresses some ha-has
14:01:54 <Peaker> jmillikin: its nice that you invented ContT for this
14:02:13 <Peaker> well, ContT in disguise as regular CPS :)
14:03:05 <ray> @let () = (==)
14:03:06 <lambdabot>  Defined.
14:03:09 <ray> too bad lambdabot forgets lets
14:11:19 <jeffwheeler> > let f = a -> 3 + a in f 4
14:11:20 <lambdabot>   <no location info>: parse error on input `->'
14:11:29 <jeffwheeler> > let f = \a -> 3 + a in f 4
14:11:31 <lambdabot>   7
14:12:11 <pikhq> @let (.) = fmap
14:12:13 <lambdabot>  .L.hs:75:36:
14:12:13 <lambdabot>      Ambiguous occurrence `.'
14:12:13 <lambdabot>      It could refer to either `L....
14:12:27 * jeffwheeler just learned to use the compose key
14:12:58 <jeffwheeler> > let () = (!=) in 3  3 -- 
14:13:00 <lambdabot>   Not in scope: `!='
14:13:07 <jeffwheeler> > let () = (=) in 3  3 -- 
14:13:09 <jeffwheeler> ack
14:13:09 <lambdabot>   <no location info>: parse error on input `='
14:13:13 <jeffwheeler> > let () = (/=) in 3  3 -- 
14:13:15 <lambdabot>   False
14:13:45 <jeffwheeler> GHC should have these by default 
14:14:16 <Heffalump> why?
14:14:26 <jeffwheeler> So that source code can be beautiful.
14:14:37 <Heffalump> I don't understand how ? makes source code beautiful
14:14:43 <jeffwheeler> What?
14:14:47 <pikhq> You fail at Unicode.
14:14:52 <jeffwheeler> Who?
14:14:53 <Heffalump> oh, I see.
14:15:01 <Heffalump> never mind :-)
14:15:09 <pikhq> That's a not-equal sign. ;)
14:15:17 <jmillikin> Peaker: I'm trying to use EitherT, but having some trouble with functions in the Get monad. When I try "rem <- getBytes", GHC states: Couldn't match expected type `BS.ByteString'
14:15:17 <jmillikin>            against inferred type `G.Get BS.ByteString'
14:15:21 <jeffwheeler> @type a :: String -> String
14:15:23 <lambdabot>     Couldn't match expected type `String -> String'
14:15:23 <lambdabot>            against inferred type `Expr'
14:15:23 <lambdabot>     In the expression: a :: String -> String
14:15:33 <jeffwheeler> @type f :: String -> String
14:15:34 <lambdabot>     No instance for (SimpleReflect.FromExpr [Char])
14:15:34 <lambdabot>       arising from a use of `f' at <interactive>:1:0
14:15:34 <lambdabot>     Possible fix:
14:15:48 <jmillikin> Trying to follow the tutorial at http://www.haskell.org/all_about_monads/html/transformers.html , but it's using a rather complex example.
14:15:55 <Peaker> jeffwheeler: Why is  more beautiful than /=   ? :)
14:16:06 * Heffalump doesn't actually know which bit of his chain of terminals fails at Unicode
14:16:12 <jeffwheeler> Peaker: more concise :)
14:16:20 <pikhq> jmillikin: Clearly, you're using getBytes in the Get monad, not the ByteString monad.
14:16:34 <jmillikin> There is no bytestring monad.
14:16:42 <pikhq> Erm.
14:16:43 <Peaker> jeffwheeler: about the same amount of black pixels :)
14:16:46 <pikhq> jmillikin: Ignore that.
14:17:02 <Phillemann> Is there a Linux shell in Haskell? The thought of it seems really nice somehow.
14:17:10 <Gowilla> could someone repeat the unicode /= ?
14:17:16 <jmillikin> 
14:17:19 <Gowilla> gah
14:17:39 <Peaker> jmillikin: ContT is a hard transformer to start with, especially if you don't know Cont yet
14:17:47 <Peaker> jmillikin: I'd start with MaybeT as a first one
14:18:16 <jmillikin> Peaker: perhaps MaybeT would be easier, but ContT will solve the problem, so I'd prefer to learn it.
14:18:54 <Twey> Phillemann: Kind of... http://nellardo.com/lang/haskell/hash/
14:18:56 <conal> jmillikin: i think Peaker was suggesting you learn ContT -- just not first.
14:19:04 <Peaker> jmillikin: You don't need ContT for your problem, I don't think
14:19:16 <Phillemann> Twey: "No code has yet been written" - hehe
14:20:13 <jmillikin> Which transformer would be best, then? I'm trying to use EitherT, as suggested earlier.
14:20:27 <Peaker> jmillikin: Basically,   MaybeT m a = m (Maybe a)   and   mt >>= f   =   {- if mt has a Nothing, then just mt, else feed the Just contents to f and return that -}
14:20:41 <Twey> Phillemann: Yeah :-P
14:20:41 <Peaker> jmillikin: return x = return . Just
14:20:47 <Peaker> oops: return = return . Just
14:20:59 <jmillikin> Which transformer would be best, then? I'm trying to use EitherT, as suggested earlier.
14:21:02 <Peaker> or since its actually wrapped in a MaybeT constructor,   return = MaybeT . return . Just
14:21:08 <Peaker> jmillikin: MaybeT, IMO
14:21:18 <Peaker> jmillikin: EitherT is simply the one you need in this example, afaiu it
14:21:25 <Peaker> jmillikin: but MaybeT is a little easier
14:23:00 <Peaker> Whoever decided to use ContT as a primary/first example of monad transformers? :-P
14:31:35 <dhun> I am just trying to understand monads and especially the fmap function
14:32:10 <dhun> one something is inside a monad you can not get it out anymore, at least not in all cases
14:32:25 <pikhq> fmap has little to do with monads.
14:32:47 <pikhq> (the reason why fmap is relevant to monads is that most Monads are Functors (and all monads are functors))
14:33:02 <dhun> yes this is what I thought
14:33:33 <pikhq> And that's pretty much it -- a monad doesn't have to let you get anything out of the monad.
14:33:47 <pikhq> (though I think it's mostly just the IO monad that's one-way like that)
14:34:11 <conal> dhun: are you trying to understand monads in general?  or maybe one monad in particular?
14:34:21 <dhun> well how can you implement bind without taking something out of the monad
14:34:44 <dhun> conal I looked it Maybe as an example
14:35:01 <dhun> I read this text http://en.wikibooks.org/wiki/Haskell/Category_theory
14:35:04 <conal> dhun: nice starting point :)
14:35:13 <conal> dhun: do you understand how fmap works for Maybe?
14:35:30 <dhun> yes I looked at the definition
14:35:33 <lpsmith> > fmap (^2) (Just 5)
14:35:34 <lambdabot>   Just 25
14:35:39 <lpsmith> > fmap (^2) Nothing
14:35:40 <lambdabot>   Nothing
14:35:48 <dhun> yes thats clear
14:36:15 <dhun> but this lines is confusiong to me :
14:36:18 <dhun>  fmap f (Just x) = Just (f x)
14:36:32 <dhun> I am actually taking x out of the monad
14:36:42 <conal> dhun: right -- you are!
14:36:52 <pikhq> In a way, yes.
14:37:16 <dhun> well but we just sayed that you can't do that in general
14:37:25 <conal> we mispoke
14:37:38 <Saizan_> you can't do it via the Monad interface
14:37:45 <conal> yeah
14:37:57 <conal> it's not really that monads don't let you extract values.  it's that there are different ways to extract for different monads.
14:37:58 <lpsmith> "in general" has a slightly ambiguous meaning;   in this case you can't do that for any arbitrary monad, but you can for some
14:38:02 <Saizan_> but you most likely have to do it while implementing such an interface
14:38:31 <conal> and if you try to extract a value from an *arbitrary* Maybe, you'll run into trouble.
14:38:41 <dhun> well is there any example of fmap, for any monad that does not do it this way
14:38:44 <conal> because of Nothing
14:39:17 <conal> dhun: try list and (->)
14:39:30 <conal> dhun: and really, i think your question is about Functor, not Monad
14:39:32 <Saizan_> there's the data Const a = Const monad, which has no value, so there's nothing to take out :)
14:40:18 <dhun> Saizan_, that is a typical mathematicians answer
14:40:38 * conal likes Saizan_'s example
14:40:44 <Saizan_> then there's Reader r a = (r -> a), for which fmap is (.), not sure if you consider that "taking out"
14:41:06 <dhun> I will read about it
14:41:33 <Saizan_> however the comment about "you can't take a value out of a monad" that you read in (not very good) monad tutorials mostly refer to IO
14:41:45 <conal> you could say that fmap on Reader r takes out all of the values, applies f to each and puts them all back
14:42:01 <Saizan_> which doesn't expose a way to get a value outside of it
14:42:13 <dhun> what does -> mean
14:42:24 <conal> function type
14:42:32 <Peaker> dhun: a -> b       means a function from a to b
14:42:37 <dhun> yes
14:42:38 <dhun> ok
14:42:57 <monochrom> class TakeOut c e | c -> e where take'out :: c -> e; instance TakeOut (IO a) a where take'out = unsafePerformIO
14:45:01 <copumpkin> :o
14:45:22 <jmillikin> Peaker: I think I've figured out how to implement this, using the transformer chapter from RWH. However, the book uses a function "lift" from the "mtl" library, which requires its transformer to be an instance of MonadTrans. EitherT doesn't have an instance -- am I doing something wrong?
14:45:50 <Peaker> jmillikin: you should write that instance
14:45:59 <jmillikin> Ah
14:46:06 <Peaker> jmillikin: you just need to implement lift
14:46:19 <monochrom> Haskell is all about inversion of control. Don't take out a value; put in the algorithm you want to be used upon that value. Don't read data; submit a callback that processes data (like Iteratee). Don't call us; we'll call you.
14:46:52 <dhun> yes, this sounds like a good idea
14:47:04 <jmcarthur> "Inversion of control" is nothing more than an OO programmer's way of saying that it's not the way he's used to.
14:47:41 <dhun> the only thing I did not understand was how can I implement fmap without taking out something, but you have given me so hints now that I need to look at before beeing able to answer
14:47:45 <Twey> Haha
14:48:13 <mgsloan> the only thing that worries me about inversion of control, is that it potentially reveals too much about the inner workings
14:48:26 <jmcarthur> mgsloan: example?
14:49:02 <Twey> On the contrary, it allows that to which control is being passed to choose exactly what the function needs to know
14:49:41 <mgsloan> But what if down the line you realize that the function really needs to take a slightly different function type? then you're hosed
14:49:57 <jmcarthur> how are you hosed?
14:50:06 <mgsloan> type classes largely alleviate this concern
14:50:11 <jmcarthur> i don't see how that is any different than any other changing requirements
14:50:24 <Twey> mgsloan: Then you screwed up in the first place: it turns out that the function needs more information than you allowed it, so your judgement was wrong
14:50:30 <mgsloan> yup
14:50:48 <Twey> But you should have given it everything it could possibly need anyway
14:50:56 <mgsloan> the problem is, it's much too easy for your judgment to be wrong in these situations
14:51:06 <Twey> No, it's not
14:51:10 <monochrom> OK, anytime you design an API you risk wrong judgements.
14:51:12 <Twey> It's a question of what the function is operating on
14:51:13 <dhun> going to sleep now, have a good night
14:51:21 <SamB> mgsloan: well, it depends on what control you're inverting
14:51:44 <SamB> Smalltalk programmers are already quite happy with their for loops being inside-out, the same as us ;-)
14:52:15 <monochrom> Don't wrap your brain around Haskell. Wrap Haskell around your brain.
14:52:47 <monochrom> And by the latter I mean immersion. Immerse yourself into Haskell.
14:52:48 <pikhq> Don't have a Brain monad with Haskell in it, have a Haskell monad with your brain in it!
14:52:56 <monochrom> Haha
14:53:39 <jmcarthur> that way your brain can't leave haskell!
14:53:53 <mgsloan> I'm not saying it's not better :)  I'm just saying it's not magic.  It brings its own set of issues and concerns
14:54:39 <desp> Can someone help me a bit with type families?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7187
14:55:26 <mgsloan> I've been thinking on this issue for a while, and I haven't come up with a convincing solution. maybe because it's a fundamental issue
14:56:29 <Saizan_> desp: those are equal types, i'm not sure if there's a way to force ghci to show the normalized form
14:56:52 <desp> Saizan_: hmm.
14:57:12 <desp> Saizan_: let me get back to my non-simplified problem...
14:57:22 <desp> Saizan_: I *thought* the issue was the types weren't seen as equal.
14:58:07 <Saizan_> :t (+++) (undefined :: S Z) (undefined :: S Z)
14:58:09 <lambdabot> Not in scope: type constructor or class `S'
14:58:09 <lambdabot> Not in scope: type constructor or class `Z'
14:58:09 <lambdabot> Not in scope: type constructor or class `S'
14:58:23 <Saizan_> try ":t (+++) (undefined :: S Z) (undefined :: S Z) :: S (S Z)"
14:58:48 <desp> Oh right, that works.
14:58:48 <Saizan_> that'll fail if they are not seen as equal
14:58:55 * desp grumbles...
14:59:28 <Twey> :t (+++) (undefined :: S Z) (undefined :: S Z)
14:59:29 <lambdabot> Not in scope: type constructor or class `S'
14:59:29 <lambdabot> Not in scope: type constructor or class `Z'
14:59:29 <lambdabot> Not in scope: type constructor or class `S'
14:59:36 <Twey> Hmn.
14:59:42 <desp> Twey: hpaste above.
15:00:32 <Twey> No, I was just checking something to do with the bot.
15:01:10 <Twey> I never seem to get >1-line error segments; I was wondering whether it just hates me :-P
15:02:09 <desp> :)
15:04:20 <beutdeuce> Cale_:  do u think u can help me with Euler #18 in Mathematica? I've been stabbing it for a couple of hours and i can't seem to make progress. I have the following so far, which only returns the sum of the first column => http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7191#a7191
15:04:53 <lpsmith> hmm... foldl is not good consumer...
15:05:24 <zachk> beutdeuce, do you need to sum the whole thing?
15:05:49 <beutdeuce> no, i need to find path down triangle of adjacent values that produces the greatest sum out of all possible paths
15:06:23 <lpsmith> beutdeuce:  think dynamic programming
15:06:32 <lpsmith> I started at the base and worked up...
15:07:01 <zachk> so you can only have one number out of each layer?
15:07:15 <BMeph> zachk: Yes
15:15:41 <merus> is the GHC really ~380 MB? if so, why?
15:15:55 <merus> a friend of mine just d/l'ed it, so maybe it's not the right thing.
15:15:56 <Peaker> merus: mathematical rigor takes up space!
15:16:16 <Cale> merus: Hmm...
15:16:27 <Cale> merus: The download was that large, or the installed size?
15:16:43 <merus> not sure; he wasn't clear.
15:16:45 <nominolo> @seen benl
15:16:45 <lambdabot> I haven't seen benl.
15:16:51 <desp> Saizan_: all right, I found the problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7192
15:16:57 <desp> Saizan_: do you see what causes it?
15:17:01 <Cale> beutdeuce: Follow lpsmith's advice. This is a natural problem for dynamic programming.
15:17:24 <beutdeuce> k
15:18:15 <lpsmith> merus: the tar.bz2 files are only like 70mb or so
15:18:26 <lpsmith> lemme check how big they are uncompressed
15:19:09 <lpsmith> du reports 691M
15:19:33 <copumpkin> it's a histomoprhism!
15:19:34 <copumpkin> :P
15:19:38 <pikhq> That is very low entropy.
15:19:52 <Saizan_> desp: does (undefined :: Norm (P Z Z)) :: P Z Z ?
15:20:50 <lpsmith> pikhq:  well it's a tradeoff:   C source code tends to be larger than their binaries,   whereas Haskell binaries tend to be larger than their source code :-P
15:20:54 <desp> Saizan_: indeed it does not...
15:21:06 <desp> Saizan_: and yet (undefined :: Norm (P (S Z) Z)) :: P (S Z) Z
15:21:09 <lpsmith> Do you want low-entropy sources,  or low-entropy binaries?
15:21:24 <desp> Saizan_: and also (undefined :: Norm (P Z (S Z))) :: P Z (S Z)
15:21:35 <SamB> lpsmith: well, perhaps it won't be so bad once GHC supports shared libraries?
15:21:39 <copumpkin> is Norm a type family?
15:21:45 <Saizan_> yes
15:21:52 <zachk> he is also a character on Cheers
15:21:59 <Nafai> Haha
15:22:13 <copumpkin> (undefined :: Cheers (P Z (S Z))) :: P (S Z) Z
15:22:23 <desp> I tried adding an explicit type instance for this case, and it doesn't help.
15:22:29 <desp> I am confused.
15:22:40 <lpsmith> SamB:  well,  judging the size of the binary is pretty tricky... I once wrote a scheme program to generate VHDL,  as VHDL didn't appear to support the right kind of abstraction I needed...
15:22:59 <lpsmith> It was about 700 lines of scheme to generate 1100 lines of VHDL
15:23:22 <SamB> but how many cells did it take on the FPGA?
15:23:28 <lpsmith> Then I noticed something somewhat obvious,  and then my 700 lines of scheme generated 700 lines of VHDL...
15:23:40 <desp> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7192#a7194
15:23:45 <lpsmith> SamB: I dunno
15:24:42 <lpsmith> but even at a 1:1 ratio, it was definitely a net win,  as I could debug and change the VHDL much, much easier
15:25:20 <lpsmith> I could make local changes in the Scheme program that would have been global changes if I had been using strictly VHDL
15:25:58 <Saizan_> desp: i think the fact that two instances apply is confusing the solver
15:26:12 <Saizan_> desp: it might be a ghc bug
15:26:50 <desp> Ahhh.
15:27:04 <desp> Indeed, rewriting as  type instance Norm (P (S a) Z) = P (S a) Z  seems to help
15:27:44 <Saizan_> right
15:28:04 <desp> Thanks.
15:28:33 <Saizan_> though the two instances are confluent, that's also why they are not rejected
15:32:29 <jeffwheeler> bgs100: ?
15:32:42 <jeffwheeler> bgs100: did one part of you fall off or something?
15:32:46 <bgs100> :P
15:32:54 <Cale> Actually, the triangle problem is really easy to express as a foldr of a particular function over the list of rows.
15:33:17 <bgs100> jeffwheeler, My connection just got messed up for a second
15:33:55 <desp> All right, almost done.
15:34:06 <desp> How do you feel about type signatures such as:  gravConst :: (Meter Scalar :^: Three) :/: (Kilogram :*: Second :^: Two)  ? :)
15:34:22 <monochrom> :^)
15:34:37 <monochrom> (That's how I feel :) )
15:34:39 <copumpkin> lol
15:34:57 <Peaker> :,)
15:35:02 <monochrom> It's interesting. I think it's fine.
15:35:08 * desp is rewriting his ICFP code to avoid NASA-like mistakes
15:35:19 <zachk> i feel :-/ im back installing mingw/msys again to get cabal working on windows again. i tried linux but my opengl drivers for linux are broke on this machine
15:35:29 <monochrom> Why is it Meter Scalar, not Meter?
15:35:35 <desp> For the first two days of the contest, I've been calculating the Earth gravitational force using the Earth radius instead of mass.
15:35:57 <desp> monochrom: because it can also be  (Dimension d) => Meter (Vector d)
15:36:46 <monochrom> So why doesn't Kilogram get the same treatment?
15:36:54 <monochrom> Err more to the point...
15:37:19 <monochrom> Why doesn't Second get the same treatment? Second (Vector Four)? Like Timecube?
15:37:22 <desp> Because I'm only modelling classical physics, where mass isn't a vector quantity.
15:37:25 <desp> :)
15:38:08 <desp> To the best of my knowledge, at least...
15:38:11 <monochrom> Do you actually use Meter (Vector Three) somewhere?
15:38:15 <zachk> wait mass can be a vector in nonclassical physics? is that the same as someone randomly banging on a piano and calling it neoclassical music?
15:38:18 <desp> Oh my yes, indeed.
15:38:29 <Cale> beutdeuce: My solution in Haskell which constructs the actual path and not just the maximum is 4 lines long, or 5 if you count the I/O. Would you like to see?
15:38:32 <desp> zachk: I don't know, monochrom seems to want it
15:38:48 <Cale> oh, he left
15:38:49 <desp> monochrom: let me polish this thing up, one moment.
15:40:17 * monochrom goes create a web page on "Masscube"
15:40:22 <desp> :)
15:40:48 <Saizan_> desp: oh, i bumped into this by chance, it was you who wanted instance resolution to take the context into account, right? http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
15:42:32 <desp> Saizan_: yes, thank you.  I found this today as well, but type families are so much better.
15:42:59 <desp> What I'd really love now is a way to force GHCI to normalize types.
15:43:28 <desp> Why:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7195#a7195
15:43:49 <desp> That's a nice type, isn't it?
15:43:57 <desp> Equivalent to  gravForce :: (Dimension d) => Kilogram -> Kilogram -> Meter (Vector d) -> Newton (Vector d)
15:44:19 <Peaker> Could be nice if   S (S (S Z))  was  shown as  3  or C_3  or something like that
15:45:02 <Saizan_> desp: ugh
15:45:08 <copumpkin> 3 would be nicest :)
15:45:25 <copumpkin> unfortunately we already have 1 in types
15:45:31 <copumpkin> which is kinda annoying imo
15:46:08 <Saizan_> {-# LANGUAGE NoImplicit1 #-}
15:46:08 <desp> All right, if anyone wants to play with what I have so far:
15:46:09 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7196
15:46:16 <copumpkin> Saizan_: is that a real option?
15:46:27 <Saizan_> copumpkin: no
15:46:33 <desp> monochrom: take a look :)
15:46:37 <copumpkin> @hoogle 1
15:46:37 <lambdabot> Parse error:
15:46:37 <lambdabot>   --count=20 1
15:46:37 <lambdabot>              ^
15:46:40 <copumpkin> lol
15:46:45 <copumpkin> :t undefined :: 1
15:46:46 <lambdabot> Unit
15:47:29 <Saizan_> we should have a Num kindclass!
15:47:38 <copumpkin> I agree :D
15:47:41 <copumpkin> except not Num
15:47:50 <Saizan_> yeah, one that makes sense
15:48:22 <fhsanches> Good night. Could someone help me with a doubt on liftM on Data.Tree, please?
15:48:45 <ray> kindclass!
15:48:53 <Saizan_> just ask :)
15:50:10 <fhsanches> Oh, thanks. I thought liftM was fmap specialized for Monads. But when I use liftM2 on two similar Trees, the resulting tree is bigger than the original ones. I'm not sure I understand what's happening.
15:50:35 <Peaker> > () :: 1
15:50:36 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
15:50:45 <Peaker> what's a Unit?
15:51:20 <Saizan_> fhsanches: liftM2 is not like zipWith for the tree or list monads
15:51:32 <copumpkin> :t Unit
15:51:33 <lambdabot> Unit
15:51:37 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Generics.html#t%3AUnit
15:52:03 <Peaker> > Unit :: 1
15:52:04 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
15:52:05 <lambdabot>    arising from a use of ...
15:52:14 <Saizan_> fhsanches: for the list monad liftM2 forms a list by applying the function to all the possible pairs
15:52:16 <Peaker> why no Show?
15:52:28 <Saizan_> fhsanches: and i think you get something similar for Data.Tree too
15:52:55 <copumpkin> Peaker: beats me, that module is voodoo to me, but it's unfair that they get to put a number in their types :P
15:53:10 <copumpkin> :t show
15:53:12 <lambdabot> forall a. (Show a) => a -> String
15:53:13 <copumpkin> :t gshow
15:53:14 <lambdabot> forall a. (Data a) => a -> String
15:53:22 <fhsanches> Saizan_: I see. So, how do I find out what it's really doing?
15:53:23 <copumpkin> uh
15:53:32 <copumpkin> > gshow Unit
15:53:34 <lambdabot>   No instance for (Data.Data.Data GHC.Generics.Unit)
15:53:34 <lambdabot>    arising from a use of...
15:54:29 <Peaker> I've never seen Unit or 1 in Haskell code
15:54:31 <Saizan_> fhsanches: liftM2 f m1 m2 = do x <- m1; y <- m2; return (f x y) so if you know how the Tree monad works you can deduce it
15:54:31 <copumpkin> > gsize 5
15:54:32 <lambdabot>   1
15:54:41 <copumpkin> > gsize (Left 5)
15:54:42 <lambdabot>   Add a type signature
15:54:44 <Twey> Peaker: Unit is ()
15:54:51 <copumpkin> > gsize (Left 5 :: Either Int Double)
15:54:53 <lambdabot>   2
15:54:55 <Peaker> Twey: not that Unit
15:54:59 <Twey> Woah
15:55:10 <copumpkin> > () :: Unit -- failz
15:55:11 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
15:55:14 <Twey> What is it for?
15:55:14 <Peaker> > const 1 (Unit :: 1)
15:55:15 <copumpkin> > Unit :: 1
15:55:16 <lambdabot>   1
15:55:17 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
15:55:17 <lambdabot>    arising from a use of ...
15:55:26 <Peaker> > const 1 (() :: 1)
15:55:27 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
15:55:39 <Twey> :info 1
15:55:49 <fhsanches> Saizan_: I don't actually know how the Tree monad behaves, but based on the list monad I think I can find out. Thanks very much!
15:55:53 <Twey> @info 1
15:55:54 <lambdabot> 1
15:57:25 <Saizan_> fhsanches: the source helps :) http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Tree.html#Tree
15:57:55 <gs4> hm.. How do i pattern match an IO Bool? can i convert it to a regular Bool or something?
15:58:10 <gs4> or do i have to use if/then/else?
15:58:10 <Twey> gs4: You don't  pattern match on the value inside it
15:58:21 <Saizan_> gs4: do b <- yourIOBool; if b then .. else ..
15:58:24 <gs4> how do you mean? (Sorry, i'm kinda new to lang)
15:58:30 <Twey> Or case b of ...
15:58:36 <gs4> ah ok
15:59:00 <gs4> thanks guys
15:59:07 <Saizan_> yeah if .. then .. else is the same as case .. of True -> ..; False -> ..
15:59:43 <shachaf> Twey: "value inside it" is only a confusing phrase, I think.
16:00:01 <shachaf> The "value it returns" would perhaps be more accurate?
16:00:11 <Twey> Then, pattern match on the value, inside it :-P
16:00:23 <Twey> I don't think so, seeing as it doesn't really return.
16:00:30 <Twey> Easier to follow, though, maybe.
16:00:32 <shachaf> What is the "value inside" getLine?
16:00:40 <Twey> 00:00:11 < Twey> Then, pattern match on the value, inside it :-P
16:01:00 <Twey> Inside getLine, pattern match on the value.
16:01:09 <shachaf> Twey: The point is that there is no value until you execute it.
16:01:29 <shachaf> Why doesn't it return?
16:01:33 <Twey> Which is why you can't possibly be pattern-matching on it
16:01:50 <Twey> Because you can't escape from IO
16:01:54 <Twey> (uPIO aside)
16:01:55 <shachaf> getLine :: World -> (String,World)
16:02:10 <Twey> But that's not true
16:02:29 <Twey> getLine :: (String -> World) -> World
16:02:44 <Twey> Semantically speaking
16:03:00 <shachaf> Well, OK.
16:03:05 * shachaf thinks this has gotten to an irrelevant point. :-)
16:03:07 <Twey> Well, (getLine >>=) I guess
16:03:14 <Twey> I think it was irrelevant to begin with :-P
16:03:20 <shachaf> I just think saying that "inside it" is confusing.
16:03:26 <shachaf> Because it's an action, not a value.
16:03:39 <Twey> I think you're still misinterpreting my original sentence
16:03:55 <Twey> I meant that, inside the action, you match on a value
16:04:07 <shachaf> Ah, I see!
16:04:09 <Twey> getLine >>= \b -> case b of ...
16:04:13 <shachaf> OK, irrelevant indeed. :-)
16:04:37 <desp> Saizan_: would "Confluent type instances confuse the solver" be a good short summary for the bug?
16:04:46 <gs4> haha, but it was sure entertaining :P
16:04:49 <shachaf> "Inside [your own IO action], you pattern match on the Bool"
16:05:02 <Twey> Right
16:05:06 <kyagrd> Is there an open example or tutorial on writing quickcheck generators that uses IO action (e.g. reading from a file or getting input from user or other processes)?
16:05:08 <Twey> I apologise for English
16:05:13 <Twey> It's not my doing
16:05:20 <kyagrd> I don't want to use unsafePerformIO for this ...
16:05:28 <Twey> May the Lojban Singularity be soon :-P
16:05:33 <Badger> heh
16:05:39 <Twey> kyagrd: For impure code, I believe you should use HUnit
16:05:53 <Twey> QuickCheck is primarily for pure code
16:06:16 <kyagrd> Twey: My code is not  impure, I want test case generator (e.g. arbitrary) which is custom ... and that generator needs to do some IO
16:06:53 <kyagrd> Twey: Do you meant this kind of custom generators are not possible to write in the QuickCheck framework?
16:08:00 <kyagrd> I have a pure code and want to check pure property, but only need a custiom value generator (other than arbitrary) that needs to do some dirty stuff :-)
16:08:06 <Twey> kyagrd: Ah, I see.  I don't know, then: I'm not as familiar with QC as I should be.
16:08:11 <kulakowski> This is entirely not haskell related, but does Lojban have some sort of facility for generating new words etc.?
16:08:21 <kyagrd> QuickCheck master's help needed :)
16:08:51 <Twey> kulakowski: Yes, it has a system of root combination similar to the way words are often formed of Latin/Greek roots in English (but using only Lojban roots)
16:09:04 <kyagrd> I know that I can always use unsafePerformIO but I will feel guilty for trhat.
16:09:10 <Twey> kyagrd: Hehe
16:09:25 <Twey> kyagrd: TBH, I don't think it matters overmuch in a utility script for generating test cases.
16:10:30 <uzytkownik> @hoogle range
16:10:31 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
16:10:31 <lambdabot> Language.Haskell.TH data Range
16:10:31 <lambdabot> Language.Haskell.TH.Syntax data Range
16:13:03 <monochrom> Dynamic programming makes me hungry.
16:13:26 <daed> haskell has namespaces? :O
16:13:31 <daed> <- still learning
16:13:47 <Saizan_> desp: "type family instances" maybe
16:14:03 <monochrom> haskell modules implies namespaces.
16:15:10 <desp> monochrom: did you see the gravForce function? :)
16:15:56 <monochrom> No, I only saw Zero, MinusOne, etc.
16:16:14 <monochrom> Oh haha I didn't scroll down.
16:16:20 <desp> :)
16:19:38 <monochrom> I see. You still allow me to have type MassCubeUnit = Quantity (Vector Three) Zero One Zero. I feel better now.
16:20:21 <monochrom> And I want to eat more newbies.
16:21:43 <desp> monochrom: :)
16:22:00 <monochrom> got to go. later.
16:22:02 <Apocalisp> can you find the middle element of a list in O(log n) ?
16:22:14 <gs4> ok, newb question, im learning haskell, and i'm confused as to how you kind of "switch" from IO to pure code. For instance, if you read in your input, that's IO, but at some point I assume you're going to call a pure algorithm or something on that IO value, so how do you make that switch?
16:22:19 <gs4> Apocalisp: if it's sorted :P
16:22:21 <desp> monochrom: actually, Quantity is hardcoded to keep meters, kilograms and seconds.
16:22:24 <desp> Aw.
16:22:42 <Cale> gs4: By passing your input to that pure function as a parameter
16:22:43 <Apocalisp> gs4: I mean middle position of the list.
16:23:03 <Cale> Apocalisp: No.
16:23:08 <gs4> Cale: well if my input is type IO String, can I just pass that to something expecting just a String?
16:23:49 <Cale> Apocalisp: It takes at least n/2 steps to even walk down the list to the middle, though knowing the length in the first place takes O(n) steps to calculate
16:23:51 <Berengal> Is it possible to turn off a given warning in just one file?
16:23:54 <gs4> Apocalisp: ah, like the index? well so basically you need to find the length in logn? doesn't sound likely unless you know something extra thats useful
16:24:10 <Cale> gs4: You can't, but you can run it and pass the result to something expecting a String.
16:24:24 <Berengal> I make heavy use of viewpatterns in one module, and it makes ghc spam "overlapping patterns" warning all over
16:24:59 <gs4> Cale: hm.. so does "a <- ioFunc \n pureFunc a" work? does <- store it as a pure value once executed?
16:25:38 <Cale> gs4: Well, the result of an IO String is just a pure String value.  v <- x  means "run the action x, and name its result v in what follows"
16:26:06 <Cale> However, pureFunc a will probably be a type error there, you'll want to probably do some output with the result of pureFunc
16:26:24 <gs4> Cale: wait, you just lost me :P
16:26:33 <Cale> okay
16:26:41 <gs4> Cale: so is v an IO String or a String?
16:26:45 <Cale> String
16:26:52 <Cale> x :: IO String
16:26:53 <gs4> Cale: ok, so why the type error?
16:26:55 <Cale> v :: String
16:27:09 <Cale> since the result of pureFunc will probably not be an IO action
16:27:25 <Apocalisp> I guess if I know the length in advance
16:27:26 <Cale> (if it is, then that's fine)
16:27:34 <Apocalisp> that's still O(n)
16:27:39 <Cale> Apocalisp: right
16:27:39 <gs4> Cale: oh, ok, gotcha, yeah i just meant like "then later call pureFunc on v"
16:27:49 <Cale> right
16:28:17 <lpjhjdh> is the pan compiler source floating around anywhere nowadays?
16:28:28 <Berengal> Cale: I've got plenty of pure functions returning IO actions whenver I do IO. In fact, almost all my IO actions are generated by pure code ;)
16:28:41 <gs4> Cale: ok, awesome, thanks for the help :)
16:28:46 <Cale> gs4: It's important to note that v <- x doesn't store the result of x in some kind of box named v, it just gives the result of x the name v directly.
16:29:07 <gs4> Cale: yeah, thats what was catching me i think
16:29:08 <Cale> gs4: So v really is a pure immutable value there.
16:29:33 <gs4> Cale: perfect, thanks :P
16:29:48 <Cale> Berengal: indeed
16:30:02 <Cale> Berengal: (but it's not usually what we think of when we say 'pure function')
16:30:40 <Berengal> Function returning a non-IO value
16:30:56 <Berengal> (Or "non-monad, unless it's a list" value)
16:31:14 <copumpkin> zomg why list?
16:31:17 <Berengal> (("or Maybe, or Either, or...))
16:31:17 <Apocalisp> Different question then. Say you have a convex polygon :: [(Int, Int)] and you want to find the highest x coordinate. You know that x increases and then decreases, so the list of xs is unimodal. How quickly can you find the (max . map fst)?
16:31:22 <copumpkin> Identity monad?
16:31:30 <Berengal> copumpkin: :O
16:31:44 <Berengal> All my code just became isomorphic to monad code :(
16:31:58 <MyCatVerbs> Berengal: you used ArrowApply? =D
16:32:06 * copumpkin grins evilly and rubs his hands with glee
16:33:10 <Apocalisp> I guess my answer is that if I want to find the rightmost vertex of a polygon, I should't represent it as a list :)
16:33:23 <Apocalisp> *in log time*
16:33:53 <Berengal> Sometimes lists are too obvious a datastructure...
16:33:53 <Twey> Yeah... I guess that would be an IntMap keyed on x
16:34:03 <MyCatVerbs> Apocalisp: uh? You have to at least the whole polygon into memory.
16:34:15 <MyCatVerbs> Apocalisp: if you only want the *one* vertex... ;D
16:34:19 <beutdeuce> what are the ninety-nine haskell problems?
16:34:23 <Twey> Haha
16:34:34 <Berengal> beutdeuce: There's only like 88 of them...
16:34:35 <MyCatVerbs> Er, to at least *read* the whole polygon into memory, I mean.
16:34:55 <Berengal> beutdeuce: did you solve PE problem 18 by the way?
16:34:56 <Twey> beutdeuce: Google says http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
16:35:05 <Apocalisp> Yeap, I guess I'd want an array-like structure then.
16:36:58 <beutdeuce> Berengal: i decided my knowledge of problem solving is rather limited so i decided to practice on, lets say the ninety-nine problems. I left on a function i wrote that returns the two adjacent elements of any number that can be traversed. I guess i just need to make a function that uses that function on every number and find individual sums, and then sum the greater ones, like Cale suggested (dynamic programming). But ya, i need to bec
16:37:43 <beutdeuce> unless, of course, 99 problems are harder ;)
16:38:05 <EvilTerran> beutdeuce, you got cut off at "But ya, i need to be"
16:38:15 <Berengal> beutdeuce: The difficulty and time requirements vary widely
16:38:31 <Berengal> On the 99 problems, that is
16:38:40 <Berengal> Also...
16:38:42 <Berengal> > foldr1 ((. (zipWith max <*> tail)) . zipWith (+)) $ [[3], [7,5], [2,4,6], [8,5,9,3]]
16:38:44 <lambdabot>   [23]
16:39:57 <beutdeuce> Berengal: do you have any good problems for me, preferably easier than #18, that can help train me to become a better problem solver using programming (functional in this case)
16:41:02 <Berengal> beutdeuce: Eh, it's okay to skip # 18 and try some of the later PE problems.
16:41:20 <beutdeuce> not that later is harder :)
16:41:47 <Berengal> Actually, thinking about it, I've got no idea how I learned haskell. I can't remember any of the problems I did :/
16:42:20 <Berengal> beutdeuce: Some of the later ones are harder, well, most of them are, but not all of them, and more importantly, they're different
16:42:30 <beutdeuce> True
16:43:48 <Berengal> Hmm, does LYAH have exercises?
16:44:07 <beutdeuce> whats LYAH?
16:44:18 <beutdeuce> oh
16:44:19 <stepnem> FTGG
16:44:21 <Berengal> @where LYAH
16:44:22 <lambdabot> www.learnyouahaskell.com
16:44:23 <stepnem> :D
16:44:24 <beutdeuce> yeah
16:44:34 <beutdeuce> thats the first guide i read to Haskell
16:44:49 <beutdeuce> its more of there is a scenario and here is how u would approach it
16:44:59 <Berengal> http://en.wikibooks.org/wiki/Haskell has some exercises, but there could be more of them
16:45:14 <pikhq> LYAH gives you demonstrations and assumes you're coding as you go along.
16:46:13 <beutdeuce> pikhq: yeah
16:49:39 <uzytkownik> @hoogle [[a]] -> [a] -> [a]
16:49:40 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
16:49:41 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
16:49:41 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
16:50:42 <beutdeuce> how would i for-loop in Haskell?
16:50:47 <Berengal> foldr
16:51:03 <beutdeuce> @type foldr
16:51:05 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:51:51 <chturne> I am having a problem with list comprehensions, some sort of type misunderstanding I think, would appreciate your time -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3039#a3039
16:51:56 <beutdeuce> what is the variable who's value is constantly incrementing?
16:52:01 <beutdeuce> in foldr
16:52:26 <Berengal> beutdeuce: The answer is that you probably don't need to increment a variable at all
16:52:29 <shachaf> beutdeuce: There are no variables in Haskell.
16:52:56 <shachaf> But if you want, you can do something with the list [1..n] (or some other list).
16:53:05 <beutdeuce> in PE #48, it is raising each number to the power of that number, if folding, how do i tell it to do that?
16:53:11 <gwern> variables don't. unask the question
16:53:15 <gwern> beutdeuce: sounds like a map
16:53:27 <beutdeuce> iyes, it does
16:53:27 <gwern> > map (\x -> x^x) [1..10]
16:53:29 <lambdabot>   [1,4,27,256,3125,46656,823543,16777216,387420489,10000000000]
16:53:44 <beutdeuce> hrm
16:53:48 <BMeph> Berengal: Shame on you, you big fibber! ;p
16:54:05 <beutdeuce> i forgot u can do lambda functions in maps
16:54:11 <Berengal> chturne: You'll only get results if there's only one book for the author because of your pattern matching
16:54:48 <Berengal> chturne: "(person, [book]) <- dBase" is the same as "(person, book:[]) <- dBase"
16:54:55 <BMeph> beutdeuce: Heck, in most other languages, you can only "do lambda functions in maps". :)
16:55:01 <shachaf> chturne: [book] is a pattern match, not to be confused with the type [Book].
16:55:03 <Twey> > map (join (^)) [1..10]
16:55:04 <lambdabot>   [1,4,27,256,3125,46656,823543,16777216,387420489,10000000000]
16:55:05 <beutdeuce> BMeph: right :)
16:55:26 <Berengal> map is a foldr :P
16:55:27 <gwern> BMeph: really? wouldn't a weaker language allow only named functions in maps and not lambdas?
16:55:42 <gwern> seems like if you can pass in a lambda, that's more complex than a named function
16:56:11 <Tom___> newbie question - reading a monad explanation http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html *but*...
16:56:12 <shachaf> gwern: I assume he/she/it means it as in for (...) { }
16:56:38 <Tom___> I don't understand the excerises: "Exercise Three
16:56:39 <Tom___> Show that lift f * lift g = lift (f.g)"
16:56:53 <BMeph> gwern: Well, I was thinking about Python in particular, and while I'm sure you *can* use lambdas elsewhere, I haven't heard of any "BDFL-Approved" instances of it. ;)
16:56:55 <Tom___> Since the whole point of this was that f.g wasn't legal
16:57:09 <Tom___> Any explanation?
16:57:19 <chturne> Berengal, shachaf, I'm not sure how I could match multiple items in the list then
16:57:30 <Vanadium> Tom___: why is it not legal?
16:57:31 <shachaf> chturne: (person, books)
16:57:34 <Berengal> chturne: Just (person, books)
16:57:48 <beutdeuce> this should be the answer >  take 10 $ reverse $ show sum $ map (\x -> x^x) [1..1000]
16:57:48 <Botje> Tom___: in that context, f and g are pure functions which can be composed normally
16:57:58 <gs4> if i need to pass an empty list to a function expecting an "IO [String]" (for tail recursion), how can i do that? Passing [] results in a type error :(
16:57:59 <beutdeuce> > take 10 $ reverse $ show sum $ map (\x -> x^x) [1..1000]
16:58:00 <kyagrd> :info join
16:58:01 <lambdabot>   Couldn't match expected type `a -> b'
16:58:05 <kyagrd> > :info join
16:58:05 <beutdeuce> huh?
16:58:06 <Botje> and the lift function takes those pure functions and produces a monadic function
16:58:07 <lambdabot>   <no location info>: parse error on input `:'
16:58:08 <Tom___> Vanadium: since the type of f and g is a->(a,String)
16:58:15 <kyagrd> @join
16:58:16 <lambdabot> Not enough privileges
16:58:17 <Botje> gs4: "return []"
16:58:21 <gwern> show sum?
16:58:25 <gs4> Botje: lol, of course, thanks :)
16:58:25 <Tom___> Botje: BUt their return type doesn't match the input
16:58:28 <kyagrd> @ join
16:58:31 <shachaf> Tom___: Are you perhaps confusing lift with bind?
16:58:39 <gwern> > take 10 $ reverse $ show $ sum $ map (\x -> x^x) [1..1000]
16:58:41 <lambdabot>   "0076480119"
16:58:45 <Tom___> shachaf: perhaps?
16:58:47 <Berengal> beutdeuce: I think you need to rearrange your functions (and using . instead of $ isn't such a bad idea)
16:58:50 * gwern thinks that's a little weird
16:58:52 <chturne> shachaf, Berengal: I get type errors if I remove the brackets around book in the pattern :(
16:58:57 <kyagrd> >! ls
16:59:00 <Tom___> shachaf: but I still think that f.g with or without the lift would be illegal
16:59:07 <Cale> beutdeuce: oh, you left before, but I constructed a solution to that triangles problem in Haskell which was 4 or 5 lines.
16:59:11 <gwern> kyagrd: lb isn't ghci :)
16:59:14 <shachaf> Tom___: f is :: a -> b, isn't it?
16:59:17 <Cale> beutdeuce: If you'd like to see it I can paste it somewhere.
16:59:23 <beutdeuce> Cale: i hate you :D
16:59:24 <shachaf> Or something like that.
16:59:26 <Berengal> chturne: Because you're only returning a list of books, which means you only get one book per author.
16:59:29 <Cale> beutdeuce: It turns out that it's a straightforward foldr
16:59:39 <shachaf> Those functions don't know about (a,String).
16:59:45 <Tom___> shachaf: it's Float->(Float,String)
16:59:48 <Cale> beutdeuce: Well, once you have the right combining function and starting value ;)
16:59:48 <beutdeuce> hmm, i'm curious, but i want to solve it firrst
16:59:52 <Berengal> chturne: If your intention is to find the books of one author only, there's the lookup function
16:59:54 <Berengal> @type lookup
16:59:55 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:00:09 <Tom___> Shachaf: Oh wait, is that f' and not f?
17:00:10 <shachaf> Tom___: I don't think that's the same f. :-)
17:00:38 <Tom___> shachaf: ah yes, f,g :: Float -> Float
17:00:38 <Cale> beutdeuce: Think about a way to take one row r, and each of the solutions starting at each of the numbers in the following row, and construct the solutions for row r.
17:00:55 <Berengal> Cale: I'd like to see it
17:00:56 <beutdeuce> Cale: i actually just began to do that ;)
17:01:07 <beutdeuce> kinda at least
17:01:10 <chturne> Berengal: Ah, I have it now. Thanks for your time Berengal and shachaf.
17:01:26 <Tom___> Shachaf: okay, then how abou Excercise 6 (the same thing but for sqrt and cbrt of complex numbers)
17:01:28 <Cale> Berengal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7200#a7200
17:01:28 <beutdeuce> getPair[num_Integer, col_, row_] :=
17:01:29 <beutdeuce>  (
17:01:29 <beutdeuce>   a = list[[col + 1]][[row]];
17:01:29 <beutdeuce>   b = list[[col + 1]][[row + 1]];
17:01:29 <beutdeuce>   Return[{a, b}];
17:01:30 <beutdeuce>   )
17:01:31 <beutdeuce> getPair[92, 8, 8]
17:01:33 <beutdeuce> {70,33}
17:01:35 <beutdeuce> oops
17:01:40 <Twey> That doesn't look like Haskell
17:01:42 <beutdeuce> i hate when that happens
17:01:46 <beutdeuce> no, thats mathematica
17:01:49 <shachaf> Tom___: The same thing, I assume?
17:01:55 <Cale> Very imperative-looking mathematica
17:02:00 <Tom___> shachaf: never mind, I guess the originals are once again Complex Float -> Complex Float
17:02:08 <Tom___> Shachaf: BUt then I guess I don't see the point in doing this
17:02:12 <beutdeuce> Cale: indeed
17:02:14 <shachaf> Tom___: There is usually an implied "for all f and g" in that sort of exercise.
17:02:25 <Cale> beutdeuce: I don't understand what the point of defining a and b like that there is.
17:02:31 <shachaf> Tom___: Well, you're proving that what you have is a monad. :-)
17:02:40 <beutdeuce> Cale: that returns the two possible traversable elements of any number
17:02:40 <Tom___> shachaf: certainly, but I stil don't see the use
17:02:44 <andresj> hello; is there an efficient way of doing `reverse $ enumFromTo 2 500000000`?
17:02:54 <Tom___> shachaf: we've let them return multiple values, BUT they don't.
17:03:03 <Cale> beutdeuce: why not:  getPair[num_Integer, col_, row_] := {list[[col + 1]][[row]], list[[col + 1]][[row + 1]]}
17:03:07 <nominolo> @tell MarcWeber see last section http://github.com/nominolo/scion/blob/master/README.markdown.  Incidentally, you added that section...
17:03:08 <lambdabot> Consider it noted.
17:03:08 <shachaf> Tom___: That means that all the various monad libraries can assume those laws.
17:03:08 <Tom___> shachaf: So all we've really done is stuffed their returnes into lists
17:03:11 <Berengal> Cale: Ah, yours remembers the path
17:03:13 <shachaf> Tom___: ?
17:03:17 <Twey> [500000000, 499999999, .. 2]
17:03:18 * shachaf hasn't actually read the article.
17:03:31 <Cale> Berengal: yeah, I wanted to see the actual path at the end, so I made it do that too.
17:03:32 <beutdeuce> Berengal: memoization?
17:03:36 <beutdeuce> Cale: same thing?
17:03:43 <Tom___> shachaf: Okay, i guess I don't have any experience with any monad libraries so no comment on that yet
17:03:44 <nominolo> @seen marmolak
17:03:45 <lambdabot> marmolak is in #haskell and #haskell.cz. I don't know when marmolak last spoke.
17:03:49 <nominolo> @seen MarcWeber
17:03:50 <lambdabot> MarcWeber is in #haskell. I last heard MarcWeber speak 1d 1h 30m 20s ago.
17:03:57 <andresj> Twey, oh good point!
17:03:58 <Cale> beutdeuce: that getPair I wrote does the same thing but with less imperative garbage in it ;)
17:03:58 <Berengal> Cale: I pasted mine after yours
17:04:11 <BMeph> AKA "enumFromThenTo 500000000 499999999 2" :)
17:04:17 <beutdeuce> Cale: good idea, i should accustom myself to functional ways
17:04:21 <shachaf> Tom___: The important thing to keep in mind is that just knowing that something is a monad by itself isn't very interesting.
17:04:22 <Twey> Yeah :)
17:04:38 <shachaf> Tom___: It becomes more interesting/useful when you see that several things share a similar structure.
17:04:45 * desp can now raise quantity types to negative integer exponents
17:05:00 <Tom___> Shachaf: Okay, though I guess I still don't see the point of the structure that we have created
17:05:01 <shachaf> Tom___: (Multivalued roughly corresponds to list comprehensions.)
17:05:03 <BMeph> andresj: ^^
17:05:25 <Tom___> Shachaf: what is the pointof doing this to sqrt and cbrt if they actually only return one value?
17:05:35 <Cale> Berengal: Yeah, it's simpler still when you don't want to remember the path :)
17:05:35 <desp>  Meter :^: Three :/: (Kilogram :*: Second :^: Two)    or    Meter :^: Three :*: Kilogram :^: MinusOne :*: Second :^: MinusTwo
17:05:36 <shachaf> Tom___: Hm? They do?
17:05:44 <shachaf> > map (^2) [2, -2]
17:05:46 <Tom___> Shachaf: yeah, otherwise you couldn't compose them
17:05:46 <lambdabot>   [4,4]
17:05:54 <shachaf> Tom___: Sure you can.
17:06:00 <shachaf> Tom___: Well, not with (.).
17:06:08 <Tom___> Shachaf: sqrt' and cbrt' return multiple values
17:06:11 <Tom___> shachaf: right
17:06:29 <shachaf> Tom___: Keep in mind that sqrt isn't one of the f/g that we're talking about.
17:06:37 <Tom___> shachaf: it's not?
17:06:47 <Tom___> shachaf: is sqrt'?
17:07:14 <shachaf> Tom___: Er, I mean, sqrt' isn't.
17:07:17 <Berengal> Cale: I think I've done too much pointless style. I actually had to pause for a few seconds to figure out what your insert function did
17:07:21 <Tom___> shachaf: oh oka
17:07:38 <beutdeuce> >  sum . map (\x->x^x) [1..1000]
17:07:40 <lambdabot>   Couldn't match expected type `a -> [a1]'
17:07:43 <beutdeuce> ?
17:07:56 <EvilTerran> beutdeuce, that's sum . (map (...) [...])
17:08:06 <BMeph> >  sum . map (\x->x^x) $ [1..1000]
17:08:07 <shachaf> > sum . map (join (^)) $ [1..1000]
17:08:13 <lambdabot>   100036819914469517709537501122764679556779368062293465458376098810023491074...
17:08:15 <lambdabot>   100036819914469517709537501122764679556779368062293465458376098810023491074...
17:08:25 <EvilTerran> beutdeuce, function application ("f x") binds tighter than any infix operator
17:08:28 <Tom___> shachaf: So then am I right in thinking that those excercises I had questions about were just "sanity checks"
17:08:39 <Tom___> Shachaf: to make sure that lift behaved sanely?
17:08:46 <shachaf> Tom___: Well, pretty much, yes.
17:08:47 <Berengal> beutdeuce: When in doubt: Parenthesize!
17:08:49 <Cale> liftM2 (***) (+) (:)
17:08:56 <Cale> If it helps ;)
17:09:13 <shachaf> Those laws are pretty intuitive most of the time.
17:09:19 <Tom___> shachaf: okay, I thought the point of the whole bind/lift/unit was to do that
17:09:24 <Cale> I wonder what @pl gives
17:09:29 <Cale> @pl insert v (s,xs) = (v+s,v:xs)
17:09:30 <lambdabot> insert = (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . (+)) (:)
17:09:30 <Berengal> Cale: Hehe, not much. Maybe if it was applicative ;)
17:09:39 <beutdeuce> @type (.)
17:09:41 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:09:45 <Berengal> oh, but that makes perfect sense
17:10:06 <Cale> (***) <$> (+) <*> (:)
17:10:26 <Cale> That's starting to become line noise
17:10:30 <Berengal> Cale: I thought I was joking, but I'm not. It /is/ more readable to me :/
17:10:37 <Tom___> shachaf: so lift is there entirely to let a regular function enter our "monad-ized" ones?
17:10:46 <shachaf> Tom___: Just about.
17:10:49 <shachaf> Like map:
17:10:50 <shachaf> @ty map
17:10:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:11:05 <shachaf> Er, rather.
17:11:05 <Tom___> shachaf: okay good this is much saner now, thanks!
17:11:08 * shachaf might be confused.
17:11:13 <shachaf> What is the type of lift?
17:11:18 <ehird> :t (***) <$> (+) <*> (:)
17:11:19 <lambdabot> forall c. (Num c) => c -> (c, [c]) -> (c, [c])
17:11:29 <ehird> i gotta say the original definition was simpler
17:11:55 * Berengal wonders if there's a Pointless Style Anonymous group
17:12:01 <Tom___> shachaf: hm I think it's (Complex Float->Complex Float)->(Complex Float->[Complex Float])
17:13:26 <Botje> > ((***) <$> (+) <*> (:)) (5,[1,2,3])
17:13:27 <lambdabot>   Overlapping instances for GHC.Show.Show
17:13:27 <lambdabot>                              (((t, ...
17:13:34 <Botje> > ((***) <$> (+) <*> (:)) 2 (5,[1,2,3])
17:13:35 <Cale> However, I should have noticed that the zipWiths commute because max distributes over (+)
17:13:36 <lambdabot>   (7,[2,1,2,3])
17:13:46 <Cale> (and (:))
17:13:48 <Botje> oh.
17:14:16 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7200#a7204
17:14:32 <Berengal> Cale: I think we might have thought this through in different directions, because I didn't notice that until just now
17:15:27 * shachaf thinks You Could Have Invented Monads is written somewhat confusingly.
17:15:41 <ehird> a gentle introduction to monads
17:15:48 <Tom___> shachaf: hehe - aren't they all, though?
17:15:55 <monochrom> invent yourself a monad
17:16:03 <Cale> A gentle introduction to gentle introductions.
17:16:33 <Tom___> I do like it's approach, though
17:16:40 <Cale> Someone should have read that before writing the "gentle" introduction to Haskell.
17:16:54 <pikhq> Botje: ARROWS! AGH!
17:17:18 <monochrom> Apart from its title, nothing wrong.
17:17:40 <Tom___> Yeah I agree, gentle introduction is very solid if misleading by title
17:18:06 <monochrom> "a gentle introduction to ___" was a meme. It meant nothing. It's the same as "yo dawg ..." today.
17:18:39 <Cale> A gentle introduction to getting completely pwned by something which calls itself a gentle introduction.
17:18:59 <Tom___> oh, okay. Like "Yet another..."
17:19:26 <monochrom> Today no one would hold the title "learn yourself a haskell" responsible.
17:19:37 <shachaf> "Gentle introductions considered harmful"
17:19:55 <Tom___> monochrom: well that title is clearly a parady
17:20:20 <monochrom> If you read Learn Yourself a Haskell and you fail to learn Haskell, you don't go around saying "the title is misleading", "someone should give the author a Learn Yourself a Learn Yourself".
17:20:25 <gwern> @quote gentle
17:20:25 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
17:20:43 <monochrom> You clearly know the title promises nothing. It's a meme.
17:21:02 <monochrom> And so A Gentle Introduction to ___ is the same. It promises absolutely zilch.
17:21:16 <Tom___> monochrom: but it's *obviousl* a meme/joke where as gentle isn't (to someone who doesn't know the meme)
17:21:37 <ehird> 01:18 monochrom: "a gentle introduction to ___" was a meme. It meant nothing. It's the same as "yo dawg ..." today.
17:21:52 <ehird> Yo dawg, yet another gentle introduction to learning yourself a new Haskell book
17:21:54 * BMeph can't wait to read the upcoming tutorial, "Not Knowing Haskell Considered Harmful"
17:21:59 <ehird> ...considered harmful
17:22:00 <CalJohn> it's not a meme, it's just a way to make the namespace for books on a certain topic seem biggger
17:22:01 <monochrom> There is always a lot of people who doesn't know past, present, future memes.
17:22:03 <ehird> BOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOM
17:22:52 <monochrom> I actually had been unaware of the "yo dawg" meme until some three months ago.
17:23:47 * shachaf still does not have a clear place to point people when they ask about monads.
17:23:58 <MyCatVerbs> LYAH.
17:24:02 <Berengal> shachaf: #haskell?
17:24:02 <monochrom> Phil Wadler's papers.
17:24:10 <MyCatVerbs> RWH is too... RWey.
17:24:17 <MyCatVerbs> YAHT's treatment is inadequate.
17:24:35 <Berengal> LYAH has pictures at least
17:24:48 <shachaf> MyCatVerbs: I tried YAHT first. It was awful (for me). :-(
17:25:07 <MyCatVerbs> You can count on a blind butcher's hand the number of blog post "Monad tutorials" that are not shit.
17:25:08 <shachaf> Made it seem like this really magical imperative thing.
17:25:13 <monochrom> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf  is superb monad exposition. From concrete to abstract.
17:25:46 <MyCatVerbs> Wadler's papers, I think I've read one of them and it was good.
17:25:53 <monochrom> If you want a summary I can give one.
17:25:57 <Berengal> @quote return.and.Kleisli
17:25:58 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
17:25:58 <lambdabot> read
17:26:17 <nominolo> @tell MarcWeber ok, I just pushed a fix for your problem (hopefully)
17:26:18 <lambdabot> Consider it noted.
17:26:21 <MyCatVerbs> But maybe it could've done with, oh... somebody stealing Wadler's ideas and his explanations and packaging them up a little more accessibly.
17:26:27 <ehird> My approach to teaching monads is "just use do-notation as imperativeness"; when they've understood typeclasses and the like, look at Functor and the like, then Monad, and see how it applies to IO, and then see how it applies to list.
17:26:36 <ehird> (This works only on a Sufficiently Smart(TM) "student".)
17:26:48 <MyCatVerbs> i.e. without the .pdf, with some nice diagrams, links to the appropriate All About Monads pages, etc.
17:26:49 <monochrom> "you can write a simple evaluator" "OK so what if you want to add: counting the number of steps" "OK so what if you want to add: error handling of division by 0" "OK so what if you want both"
17:27:14 <Berengal> My approach to learning monads was basically to bash my head against a brick wall until I got it...
17:27:16 <shachaf> ehird: That seems like it's just lying (because do isn't imperativeness).
17:27:19 <beutdeuce> this should be the answer to 48, but it isnt for some strange reason:
17:27:24 <beutdeuce> > take 10 . reverse . show . sum . map (\x -> x^x) $ [1..1000]
17:27:25 <lambdabot>   "0076480119"
17:27:38 <ehird> shachaf: It's lying so they can write programs that Do Things. The only way to truly learn monads is to see their definition and how it applies.
17:27:54 <shachaf> ehird: Ew, Doing Things is overrated. :-)
17:27:58 <ehird> So I tell them a brief lie  but point out it's a lie  to let them code happily until they can understand the definition.
17:28:03 <Berengal> beutdeuce: You forgot a reverse
17:28:09 <ehird> shachaf: It turns out doing things is a good way to learn a language. :P
17:28:16 <beutdeuce> the reverse is for taking the last ten digits
17:28:25 <Berengal> beutdeuce: You forgot another one
17:28:31 <BMeph> > reverse . take 10 . reverse . show . sum . map (\x -> x^x) $ [1..1000]
17:28:33 <lambdabot>   "9110846700"
17:28:38 <monochrom> Perhaps you can introduce Functor and Applicative first.
17:28:45 <BMeph> beutdeuce: ^^ ^_^
17:28:47 <beutdeuce> Why reverse 2 times?
17:29:00 <Berengal> beutdeuce: Because otherwise you get the last 10 digits, but in reverse order
17:29:06 <Petrosian`> > take 2 . reverse $ [1..10]
17:29:08 <lambdabot>   [10,9]
17:29:12 <beutdeuce> oh right
17:29:13 <Cale> It's no harm to explain how to do IO without explaining monads. We make too much of a big deal out of the fact that IO happens to be a monad.
17:29:21 <beutdeuce> > reverse . take 10 . reverse . show . sum . map (\x -> x^x) $ [1..1000]
17:29:23 <lambdabot>   "9110846700"
17:29:28 <shachaf> Cale: Sure -- but lying about do notation is unhelpful.
17:29:33 <BMeph> Reverse 1#: To get the last ten; reverse #2: To print them out in non-Hebrew/Arabic order. ;)
17:29:45 <monochrom> I lie about 0 all the time.
17:29:47 <shachaf> BMeph: Numbers are left-to-right in Hebrew.
17:30:09 <monochrom> "0 is Int" "OK 0 is (Num a) => a"
17:30:20 <shachaf> monochrom: 0 *is* an Int, though.
17:30:23 <Cale> Well, I don't know. You can say that it's actually more general but for the time being show that it can combine smaller IO actions into larger ones.
17:30:25 <monochrom> I can't say Num too early
17:30:26 <shachaf> I guess if you do the lying carefully it can be OK.
17:30:27 <BMeph> shachaf: Really? What the language itself isn't tough enough? ;)
17:30:52 * shachaf thought for a long time that let had a completely different behavior in do blocks (like a variable in imperative languages).
17:31:23 <monochrom> OK, new lie: "negate is Int -> Int" "OK negate is (Num a) => a -> a"  I still can't say Num too early.
17:31:24 <beutdeuce> lol, how can # 48 be so easy when #18 isnt
17:31:28 <BMeph> Cale: That statement you made is a good "disclaimer" for what we like to call "Caleskell". ;)
17:31:32 <Berengal> shachaf: If you can't tell the difference, is there one?
17:31:47 <shachaf> Berengal: Hm?
17:31:59 <BMeph> Cale: Well, not specifically about the IO stuff, anyway. :)
17:32:09 <Berengal> shachaf: About lets in dos, or in general, really...
17:32:22 <Cale> You certainly can tell the difference between let and do-blocks, even in the identity monad.
17:32:24 <shachaf> Berengal: Well, you can't, e.g., update in loops.
17:32:28 <shachaf> Cale: Sure, the fact that it's a monad (with the general functions >>= and return) doesn't need to be said.
17:32:41 <ehird> 01:28 monochrom: Perhaps you can introduce Functor and Applicative first.
17:32:42 <ehird> Yeah, I do.
17:32:43 <shachaf> But the "action"/"computation" thing is important, I think.
17:32:49 <ehird> But once they're writing programs and understand type classes, etc.
17:33:01 <Cale> shachaf: You can explain how >>= and return work too, without saying that they really have anything to do with monads.
17:33:14 <monochrom> x++y has complexity Theta(length x). That is not a lie. But I lie about the reason why. The reason for lazy evaluation is a bit more complicated than the reason for eager evaluation.
17:33:20 <ehird> Anyway, lying is fine.
17:33:22 <Berengal> Cale: This was about let IN do-blocks, and them being something entirely different from regular lets
17:33:25 <ehird> You just have to mention it's lying.
17:33:28 <Cale> Berengal: oh
17:33:36 <Berengal> Which is a lie, of course...
17:33:37 <ehird> As a language newbie I'd always prefer to leap in with a lie than stagnate with the trth.
17:33:40 <ehird> *truth
17:34:00 <shachaf> ehird: Yes, but a bad lie can take a long time to recover from. :-)
17:34:16 <shachaf> Choose your lies carefully. :-)
17:34:22 <monochrom> Yes, it has to be a good lie, not a bad lie.
17:34:42 <Berengal> I like to introduce IO with do-blocks, and monads with (>>=), not neccessarily in any order
17:35:01 <Berengal> Then when they've groked monads, tell them how do is the same
17:35:11 <Berengal> However, by that point they've usually figured it out by themselves
17:35:35 <ehird> shachaf: "To do IO we can use 'do notation'; this isn't actually just for IO or anything, it's a really clever abstractional tool (the fabled 'monads'), but that doesn't matter. Right now, you can just think of it as a way to do side-effects."
17:35:49 <ehird> Anyone who'd be permanently confused by that would suck at haskell anyway.
17:36:03 <shachaf> ehird: OK, fair enough.
17:36:21 <Berengal> It's strange how easy something is when it was incredibly hard only 6 months earlier...
17:36:43 <hzap> or even a week earlier...
17:36:52 <ehird> hzap: Days earlier for pikhq.
17:37:16 <ehird> He'd completely grokked functors, applicatives and monads in his 4th (I think) day with Haskell..
17:37:20 <ehird> *...
17:37:49 <hzap> my comment referred to me figuring out Applicative
17:38:00 <ehird> right
17:38:02 <ehird> I was just tying it in
17:38:21 <hzap> from that awesome article on The Monad.Reader
17:38:22 <Berengal> I got applicative the same day I heard about it, but then again I'd already groked monads and functors
17:53:39 <desp> Has anyone tried writing function application in reverse?  For example:  1 kilo -> 1000
17:53:50 <desp> (Instead of:  kilo 1)
17:54:14 <Tom___> woah - is the ghci a monad? Is that why I can't do regular "a = 5" statements in it?
17:54:14 <copumpkin> o.O
17:54:26 <copumpkin> Tom___: it behaves like a big do block mostly, yeah
17:54:31 <copumpkin> in IO
17:54:37 <Tom___> right, thanks
17:54:44 <copumpkin> so let x = 5 will work
17:54:48 <Tom___> yup
17:54:48 <kyagrd> a = 5 is a delceartation we don't call it a statement
17:54:56 <Berengal> x <- foo also works
17:54:56 <kulakowski> desp: I wish function application was written that direction universally.
17:55:06 <Tom___> okay, sorry I'm still used to imperative terminology
17:55:15 <desp> kulakowski: well, let's do something about it. :)
17:55:44 <kyagrd> We often call IO or monadic actions like x <- foo as statements though
17:55:52 <Berengal> desp, kulakowski: stack-based languages work like that
17:55:53 <Tom___> okay
17:56:17 <desp> Berengal: this is just syntax.
17:56:26 <Berengal> x <- foo has funky scoping...
17:56:36 <kyagrd> Statement not really as a technical term just as an analogy ...
17:58:00 <desp> > let (%) = \x y -> y $ x
17:58:02 <lambdabot>   not an expression: `let (%) = \x y -> y $ x'
17:58:34 <copumpkin> @let (%) = flip ($)
17:58:35 <lambdabot>  Defined.
17:59:05 <desp> > 1 % id
17:59:07 <lambdabot>   Ambiguous occurrence `%'
17:59:07 <lambdabot>  It could refer to either `L.%', defined at <local...
17:59:22 <desp> ...or?
17:59:34 <Berengal> (%) is already an operator
17:59:37 <desp> @let grargh = flip ($)
17:59:39 <lambdabot>  Defined.
17:59:45 <desp> > 1 `grargh` id
17:59:47 <lambdabot>   1
17:59:51 <desp> kulakowski: ^^
18:00:07 <kulakowski> I see :)
18:00:39 <kyagrd> % is not Prelude operator though
18:00:48 <desp> @forget (%)
18:00:49 <lambdabot> Incorrect arguments to quote
18:01:08 <RayNbow> @undefine
18:01:16 <RayNbow> > 1 % 3
18:01:17 <lambdabot>   1 % 3
18:01:20 <desp> @undefine (%)
18:01:37 <RayNbow> desp: afaik you can't undefine a specific definition
18:01:39 <desp> @dowhatimean
18:01:40 <lambdabot> Unknown command, try @list
18:01:49 <kyagrd> It's Ration.(%) shouldn't be in Prelude
18:01:53 <kyagrd> Ratio
18:05:56 <Twey> kyagrd: It isn't
18:13:45 <Tom___> monochrom: That paper you linked to is really great! Thanks for it.
18:14:39 <beutdeuce> > (\x -> 28433*(2^7830457)+1)
18:14:41 <lambdabot>   Overlapping instances for GHC.Show.Show (t1 -> t)
18:14:41 <lambdabot>    arising from a use of ...
18:15:07 * impl ponders beutdeuce 
18:15:59 <beutdeuce> > 28433*(2^7830457)+1
18:16:04 <lambdabot>   mueval-core: Prelude.read: no parse
18:16:05 <lambdabot>  mueval: ExitFailure 1
18:17:19 <beutdeuce> @let answer = reverse . take 10 . reverse . show $ 28433*(2^7830457)+1
18:17:20 <lambdabot>  Defined.
18:17:23 <beutdeuce> answer
18:17:37 <beutdeuce> > answer
18:17:42 <lambdabot>   mueval-core: Prelude.read: no parse
18:17:42 <lambdabot>  mueval: ExitFailure 1
18:17:56 <beutdeuce> hmm, calculates offline, what is the runtime limit on lambdabot?
18:32:41 <copumpkin> > let nqueens n = [zipWith (\x y -> x : show y) ['a'..] x | x <- permutations [1..n], (length $ nub $ zipWith (+) (x ++ x) $ [0,-1..1-n] ++ [n..]) == n*2] in nqueens 4
18:32:43 <lambdabot>   [["a2","b4","c1","d3"],["a3","b1","c4","d2"]]
18:33:06 <copumpkin> zomg it's mxweas
18:33:15 <copumpkin> > let nqueens n = [zipWith (\x y -> x : show y) ['a'..] x | x <- permutations [1..n], (length $ nub $ zipWith (+) (x ++ x) $ [0,-1..1-n] ++ [n..]) == n*2] in length (nqueens 8)
18:33:18 <lambdabot>   92
18:33:45 <copumpkin> > let nqueens n = [zipWith (\x y -> x : show y) ['a'..] x | x <- permutations [1..n], (length $ nub $ zipWith (+) (x ++ x) $ [0,-1..1-n] ++ [n..]) == n*2] in length (nqueens 10)
18:33:51 <lambdabot>   mueval-core: Prelude.read: no parse
18:33:51 <mxweas> omnomnom
18:33:51 <lambdabot>  mueval: ExitFailure 1
18:33:56 <copumpkin> > let nqueens n = [zipWith (\x y -> x : show y) ['a'..] x | x <- permutations [1..n], (length $ nub $ zipWith (+) (x ++ x) $ [0,-1..1-n] ++ [n..]) == n*2] in length (nqueens 9)
18:34:02 <lambdabot>   mueval-core: Prelude.read: no parse
18:34:02 <lambdabot>  mueval: ExitFailure 1
18:34:04 <copumpkin> boo
18:38:47 <Berengal> So even that's a one-liner...
18:38:53 <Berengal> Haskell keeps surprising me
18:39:24 <copumpkin> it wasn't mine :)
18:39:26 <copumpkin> I just found it
18:39:27 <hackagebot> first-class-patterns 0.1.0 - First class patterns and pattern matching, using type families (ReinerPope)
18:39:33 <copumpkin> :o
18:39:35 <Berengal> First class patterns!
18:39:39 <copumpkin> Berengal: is that you?
18:39:43 <Berengal> @hackage first-class-patterns
18:39:43 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/first-class-patterns
18:39:44 <Berengal> Nope
18:39:59 <copumpkin> dammit I can't browse the docs yet
18:40:01 <codolio> Type families? Well I never!
18:40:02 * copumpkin sighs
18:40:27 * Berengal cabal installs
18:41:21 <Berengal> ... and I just pulled myself together enough to write my matcher as well...
18:41:55 <MarcWeber> nominolo: What's up ?
18:41:56 <lambdabot> MarcWeber: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:42:11 <nominolo> MarcWeber: check your messages
18:43:45 <MarcWeber> nominolo: That time I used grep. I've switched to gnu id utils. But I didn't tell it to index .markdown files :-(
18:44:44 <nominolo> anyway, it was a bug, but it should be fixed now
18:44:45 <MarcWeber> Anyway: Thank you for reminding me of that comment
19:09:06 <beutdeuce> oh cool, Cale, you actually can overload Prelude functions (and classes i believe) by hiding them in the import, import Prelude hiding (blah,blah,blah)
19:09:30 <tavelram> indeed
19:09:30 <beutdeuce> > import Prelude hiding (foldr,foldl)
19:09:32 <lambdabot>   <no location info>: parse error on input `import'
19:09:46 <beutdeuce> i guess lambda bot doesnt import
19:09:56 <Berengal> beutdeuce: With some restrictions. Some syntax will still use the Prelude definitions
19:10:32 <beutdeuce> Berengal: even if explicitly hiding those definitions? Will it just not let you hide them?
19:10:43 <tavelram> > foldr (++) [[4],[5],[6]] [[1],[2],[3]]
19:10:44 <lambdabot>   No instance for (GHC.Num.Num [t])
19:10:45 <lambdabot>    arising from the literal `1' at <inter...
19:10:59 <tavelram> > foldr [[4],[5],[6]] (++) [[1],[2],[3]]
19:11:01 <lambdabot>   Couldn't match expected type `a -> b -> b'
19:11:07 <tavelram> :t foldr
19:11:08 <Berengal> beutdeuce: It'll let you hide them, but it'll still use them behind the scenes
19:11:09 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:11:13 <tavelram> :t foldl
19:11:15 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:11:33 <beutdeuce> Berengal: if you overload them, will it use the overloaded function, or the original prelude?
19:11:56 <Berengal> beutdeuce: That depends on just what's overloaded and just how you use it, I'm afraid
19:12:05 <Berengal> This was specified somewhere, but I forget where
19:12:10 <beutdeuce> Berengal: k, np
19:13:25 <beutdeuce> how is it that fmap is able to operate on not just lists? Is it because of the Functor? What is this Functor?
19:15:23 <mxweas> > foldr (:) [] [1..100]
19:15:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:16:20 <beutdeuce> > map (+) $ tails [1..10]
19:16:22 <lambdabot>   No instance for (GHC.Num.Num [t])
19:16:22 <lambdabot>    arising from a use of `GHC.Num.+' at <...
19:16:29 <mxweas> > foldr (+) 1 [1..6]
19:16:30 <beutdeuce> > tails [1..10]
19:16:31 <lambdabot>   22
19:16:32 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
19:16:36 <mxweas> > foldr (+) 1 [1..6]
19:16:38 <lambdabot>   22
19:16:49 <jeffwheeler> > sum [1..6] + 1
19:16:51 <lambdabot>   22
19:16:55 <beutdeuce> sum [1..6] + 1
19:17:20 <beutdeuce> > foldr1 (+) [1..6]
19:17:22 <lambdabot>   21
19:17:36 <jeffwheeler> > foldr1 (+) []
19:17:38 <lambdabot>   * Exception: Prelude.foldr1: empty list
19:17:58 <Badger> @src foldr1
19:17:59 <lambdabot> foldr1 _ [x]    = x
19:17:59 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
19:17:59 <lambdabot> foldr1 _ []     = undefined
19:18:08 <vav> beutdeuce: http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf -- typeclassopedia has neat discussion of Functor, Also http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass may help.
19:18:10 <jeffwheeler> That's not tru!
19:18:12 <jeffwheeler> * true
19:19:33 <beutdeuce> vav: thanks for that, reading the Typeclassopedia
19:20:08 <ray> data Boo = Fals | Tru
19:21:05 <babusrini> How do I convert a lazy bytestring to a strict bytestring?
19:21:05 <beutdeuce> so true: When I asked how to do something I thought was real ly complicated, people
19:21:05 <beutdeuce> started typing things like zip.ap fmap.(id &&& wtf) and the scary thing
19:21:05 <beutdeuce> is that they worked! Anyway, I think those people must actual ly be robots
19:21:06 <beutdeuce> because theres no way anyone could come up with that in two seconds o the
19:21:06 <beutdeuce> top of their head.
19:21:27 <ray> it comes with a bit of haskell practice
19:21:28 <ski> (beutdeuce : btw .. that's not overloading)
19:21:38 <monochrom> Yeah, it would take me 2 minutes, not 2 seconds.
19:21:54 <monochrom> The secret to becoming intelligent is becoming inhuman.
19:22:14 <beutdeuce> :P Someone in the #haskel l IRC channel used (***), and when I asked lambd-abot to tel l me its type, it printed out scary gobbledygook that didnt even t on one line! Then someone used fmap fmap fmap and my brain exploded.
19:22:30 <beutdeuce> epic
19:22:36 <ski> monic
19:22:51 <monochrom> &&& and *** are very general. Not easy to explain the full generality.
19:23:01 <jeffwheeler> @type (***)
19:23:03 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:23:08 <beutdeuce> lol o.0
19:23:26 <monochrom> But a special case is (f***g)(x,y) = (f x, g y)
19:23:37 <ray> if you think of &&& and *** as being less general (basically, only consider the function arrow), they're easier
19:23:44 <monochrom> @type (&&&)
19:23:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:23:50 <jeffwheeler> Is a in that type supposed to be a type constructor?
19:24:01 <monochrom> And (f&&&g) x = (f x, g x)
19:24:11 <ski> jeffwheeler : yes, `a :: * -> * -> *'
19:24:17 <monochrom> Yes, for example I'm using (->) for "a".
19:24:24 <beutdeuce> What is this Monad.Read? It has some really useful articles
19:24:34 <beutdeuce> Monad.Reader rather
19:24:37 <jeffwheeler> @type (->)
19:24:38 <lambdabot> parse error on input `->'
19:24:45 <beutdeuce> @type (==>)
19:24:47 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
19:25:03 <dobblego> @kind (->)
19:25:05 <lambdabot> ?? -> ? -> *
19:25:20 <beutdeuce> @hoogle Monad.Reader
19:25:21 <lambdabot> No results found
19:25:27 <jeffwheeler> @where Monad.Reader
19:25:28 <lambdabot> I know nothing about monad.reader.
19:25:30 <beutdeuce> @hayoo Divisors
19:25:31 <dobblego> @src Reader
19:25:31 <lambdabot> Unknown command, try @list
19:25:31 <lambdabot> Source not found. Where did you learn to type?
19:25:35 <beutdeuce> @list
19:25:36 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:25:40 <jeffwheeler> @google Monad.Reader
19:25:41 <monochrom> http://www.haskell.org/haskellwiki/The_Monad.Reader is Monad.Reader it is an electronic magazine.
19:25:42 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
19:25:42 <lambdabot> Title: The Monad.Reader - HaskellWiki
19:26:21 <Berengal> Success!
19:26:30 <Berengal> I can now convert sexprs to xml
19:26:55 <beutdeuce> @wikipedia sexprs
19:26:57 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=sexprs
19:27:07 <beutdeuce> @wikipedia Monad
19:27:09 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=Monad
19:27:18 <monochrom> sexpr means like scheme, (f x (g y z))
19:27:25 <ray> @go comonad.reader
19:27:28 <lambdabot> http://comonad.com/
19:27:28 <lambdabot> Title: The Comonad.Reader
19:27:44 <ray> that's where all the good stuff lives
19:27:45 <beutdeuce> monochrom: o
19:27:57 <Berengal> beutdeuce: http://en.wikipedia.org/wiki/S-expressions
19:28:17 <Berengal> They're just a convenient syntax for writing trees
19:28:58 <beutdeuce> Berengal: nice
19:29:04 <monochrom> (g y z) is better than <g><y /><z /></g>
19:29:11 <Berengal> Which suits my purposes because xml is just an unconvenient syntax for writing trees...
19:29:17 <monochrom> I mean more concise.
19:29:30 <beutdeuce> http://foldl.com :)
19:29:45 <ray> there's a foldr.com too
19:30:02 <Berengal> Let's see, parser: 50 lines. converter: 45 lines. Type: 5 lines.
19:30:29 <Berengal> Still lack a pprinter for the sexprs though...
19:31:19 <beutdeuce> Berengal: printer as in an instance of Show?
19:31:30 <Berengal> beutdeuce: No, pprinter, as in pretty-printer
19:32:15 <Berengal> Show prints: Cons (Cons (Cons (Atom "name") (Atom "Sjur Karevoll")) Nil) (Cons (Cons (Atom "property") (Cons (Cons (Cons (Atom "type") (Atom "car")) (Cons (Cons (Atom "value") (Atom "5000")) Nil)) Nil)) Nil)
19:32:34 <Berengal> for (person ((name \"Sjur Karevoll\")) (property ((type car) (value 5000))))
19:42:46 <BMeph> Wouldn't "(Cons (Atom "name") (Atom "Sjur Karevoll"))" be "(name . Sjur Karevoll)"? :)
19:43:13 <Berengal> Uh, yeah, that seems to be the wrong paste
19:43:34 <Berengal> Anyway, my point stands. Show is ugly
19:44:04 <Woof> How?
19:44:13 <Berengal> It doesn't print sexprs
19:44:26 <ski> it's not supposed to ..
19:44:32 <Berengal> I know
19:44:44 <Berengal> I'm using ugly as the technical term here
19:45:28 <codolio> Clearly "(Cons (Cons (..." is much better, yes.
19:47:03 <RyanT5000> quick straw poll: best noun to describe "people who use haskell"
19:47:18 <dolio> Haskellator.
19:47:20 <impl> haskellites
19:47:25 <Berengal> haskellerators
19:47:28 <RyanT5000> hahaha
19:47:36 <caxaf> Hasks.
19:47:38 <dobblego> programmer
19:48:07 <RyanT5000> no no, i mean the serious kind of "best", not the "aw man that's hilarious" kind of "best"
19:48:07 <beutdeuce> Haksors
19:48:09 <ski> > let infix 4 `n`; n = not in (True `n`)
19:48:11 <lambdabot>   False
19:49:18 <monochrom> Haskellists
19:49:24 <Berengal> Haskell programmers? Haskellers?
19:49:27 <monochrom> Haskellismists
19:49:35 <Berengal> Haskellista?
19:49:47 <BMeph> Haskelliers!
19:49:57 <jeffwheeler> Haskellers is the standard
19:49:59 <monochrom> Homo Haskellus
19:50:02 <jeffwheeler> Haskellista is singular; that can't work
19:50:10 <beutdeuce> Skellers
19:50:12 <Berengal> Haskellistia?
19:50:19 <copumpkin> haskellisti
19:50:24 <Berengal> Ah, right
19:50:34 <Berengal> I tend to use haskell hackers..
19:50:36 <Woof> Hasxers
19:50:50 <ski> haskellerati
19:50:53 <jeffwheeler> copumpkin: it was feminine
19:50:54 <Berengal> Woof: Surely you mean Hasxzorz
19:51:04 <Woof> No, Hasx0rz!
19:51:06 <monochrom> haha
19:51:10 <monochrom> Haskellcats
19:51:18 <copumpkin> haskelliste then
19:51:23 <Berengal> Lazy programmers
19:51:24 <copumpkin> but it feels masculine to me
19:51:34 <BMeph> Haskillets?
19:51:52 <jeffwheeler> copumpkin: Haskellistus? :P
19:51:52 <monochrom> Haskellishmen and Haskellishwomen
19:52:07 <Berengal> monochrom: Haskellishpeople
19:52:16 <jeffwheeler> Really, I think the challenge it to find a term like Pythonic.
19:52:16 <monochrom> Haskellese
19:52:22 <caxaf> Haskephiles.
19:52:24 <jeffwheeler> That is, a term that describes idiomatic Haskell.
19:52:34 <monochrom> Haskellism
19:52:36 <Berengal> Pointless
19:52:49 <jeffwheeler> monochrom: Not an idiom; idiomatic code
19:52:51 <kynky> Haskellion
19:52:59 <copumpkin> idiotic haskell?
19:53:00 <caxaf> jeffwheeler: In Haskell? "beautiful"? :-)
19:53:13 <monochrom> Haskellonic
19:53:17 <Woof> medfly: Topic - Noun to describe Haskell programmers
19:53:21 <monochrom> Haskellmorphic
19:53:26 <medfly> nerds
19:53:29 <monochrom> Haskellene
19:53:30 <BMeph> Haskellistic!
19:53:31 <ski> haskellcthonic
19:53:38 <jeffwheeler> I like Haskellestic.
19:53:40 <Woof> That's an adjective, BMeph
19:53:56 <jeffwheeler> Woof: Yeah, describing idiomatic code . . .
19:54:03 <jeffwheeler> Just like Pythonic.
19:54:04 <BMeph> Woof: Fine, then "Haskellistics". ;p
19:54:07 <monochrom> Haskellenic = Helenic
19:54:14 <Berengal> He did say noun, didn't he?
19:54:33 <monochrom> I mean,     ...
19:54:37 <medfly> I think mine is the best.
19:54:54 <Berengal> I like    
19:54:56 <monochrom> Perhaps Hellenic
19:55:15 <copumpkin> yup
19:55:31 <monochrom> It's all Greek to me
19:55:55 <Berengal> monochrom: When you get down to it though, it's really just bits and bytes
19:56:12 <kynky> goes nice with a curry though
20:11:06 <babusrini> How do I convert lazy bytestring from encode to strict bytestring required by sendAll sock? I get Couldn't match expected type `Data.ByteString.Internal.ByteString' against inferred type `Data.ByteString.Lazy.Internal.ByteString'
20:37:04 <bgs100> @src length
20:37:04 <lambdabot> Source not found. Sorry.
20:40:34 <beutdeuce>  @type length
20:40:51 <beutdeuce> @hoogle length
20:40:52 <lambdabot> Prelude length :: [a] -> Int
20:40:52 <lambdabot> Data.ByteString length :: ByteString -> Int
20:40:52 <lambdabot> Data.List length :: [a] -> Int
20:51:18 <Axman6> :t fildl (const (+1)) 0
20:51:19 <lambdabot> Not in scope: `fildl'
20:51:21 <Axman6> :t foldl (const (+1)) 0
20:51:22 <lambdabot> forall a. (Num a) => [a] -> a
20:51:29 <Axman6> :t foldl (flip const (+1)) 0
20:51:31 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
20:51:31 <lambdabot>     Probable cause: `flip' is applied to too many arguments
20:51:31 <lambdabot>     In the first argument of `foldl', namely `(flip const (+ 1))'
20:52:16 <BMeph> "length" is a comonad. Spread the word - the Comonadic Revolution (patent pending) is coming! ;)
20:52:48 * jeffwheeler doesn't understand what a comonad is
20:53:04 <jmcarthur> wait, how is length a comonad?
20:53:14 <BMeph> jeffwheeler: Actually, that's kind of the point. ;)
20:53:23 <soupdragon> lol
20:53:30 <jmcarthur> ugh
20:53:35 <jmcarthur> i fell for the joke
20:53:43 * soupdragon too
20:53:54 <BMeph> Actually, length isn't a comonad. It's a Kleisli comonad, or "coKleisli". :)
20:54:08 * Axman6 was thinking that it might have something to do with length and replicate
20:54:10 <jeffwheeler> :-/
20:54:15 <Axman6> :t (length, replicate)
20:54:17 <lambdabot> forall a a1. ([a] -> Int, Int -> a1 -> [a1])
20:54:26 <Berengal> Crap, I accidentally the xml
20:54:44 <BMeph> Berengal: Dude, that's soooo dangerous! ;p
20:54:58 <Berengal> BMeph: I know.
20:55:00 <jeffwheeler> Berengal: you lost a verb!
20:55:14 <BMeph> Meme alert! Meme alert!
20:55:37 <Berengal> In completely unrelated news, I now know what lisp looks like when run through a sexpr -> xml converter
20:55:52 <soupdragon> everyone does that
20:56:12 <BMeph> Yo dawg i herd u liek memes so I accidentally a mudkip so...you know. ;p
20:56:23 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7207#a7207
20:56:56 <soupdragon> Berengal, thats what lisp looks like to normal people
20:57:09 <Berengal> Interestingly enough, functions become tags, arguments become elements
20:57:24 <BMeph> Ah, so THAT's what the IR of Clojure looks like... ;p
21:00:05 <mae_> is anyone with a freebsd box willing to run some unit tests for me? I am trying to make sure that the freebsd support for sendfile passes the tests before I release the new version.
21:03:03 <beutdeuce> @let data W a = W a deriving Show
21:03:04 <lambdabot>  Invalid declaration
21:07:09 <beutdeuce> @let message = "Good night"
21:07:11 <lambdabot>  Defined.
21:07:14 <beutdeuce> message
21:07:19 <beutdeuce> > message
21:07:21 <lambdabot>   "Good night"
21:10:22 <mike-burns> mae_: I've a FreeBSD box. You might also get better help from #haskell-freebsd
21:12:28 <Zao> mae_: I would, but as the box is sparc64 FreeBSD, I doubt I've got much chance getting even ghc up :)
21:13:00 <mae_> mike-burns: please see http://groups.google.com/group/HAppS/browse_thread/thread/eb300f2c4356bd9
21:15:05 <mike-burns> Huh, I didn't have darcs installed. Doing that now.
21:15:33 <mae_> mike-burns: ahh ok, let me know! thanks alot
21:15:49 <mike-burns> mae_: Thank you for thinking of FreeBSD!
21:16:51 <mae_> mike-burns: yeah not a problem, a person named maxime henrion contributed the code, but I couldn't get a response from him to run the test suite, and I also slightly changed the interface so I need to know that it builds as well
21:17:15 <mae_> i wrote "theoretically it should build" code
21:17:21 <mae_> without having actual verification P:)
21:17:37 <mike-burns> Ha, we'll see how it goes!
21:17:43 <mike-burns> If the docs are good ...
21:18:25 <mae_> lol
21:18:34 <mae_> well like i said, i didn't write the code, i just slightly tweaked it
21:18:51 <mae_> though the good part is that, since the backend interface is minimalistic, once it works i shouldn't have to touch it to change the frontend interface
21:18:52 <mike-burns> Ah, right right.
21:20:34 <mae_> pastebin the output if you run into trouble
21:20:39 <mae_> and let me know what version of ghc
21:22:50 <mike-burns> Installing the missing dependencies now. Network.Socket.ByteString
21:22:56 <mae_> err
21:23:06 <mae_> thats only for the portable implementation
21:23:15 <mae_> and um, you don't have cabal install?
21:23:24 <mike-burns> I do, but it didn't install that for me.
21:23:31 <mae_> like i said
21:23:43 <mae_> you don't need that unless its building the portable implementation (haskell)
21:23:45 <mike-burns> I just followed the directions from the email and it failed to run the tests.
21:23:48 <mae_> ahh
21:23:57 <mae_> oh right right
21:23:58 <mae_> sorry
21:24:00 <mae_> i forgot the tests need it
21:24:12 <mae_> silly me
21:25:06 * mae_ waits while biting his nails in anticipation
21:25:39 <mike-burns> Do I have to be root to run these tests?
21:26:00 <mae_> no
21:26:02 <mae_> well
21:26:11 <mae_> i am not sure, you shouldn't have to
21:26:22 <mae_> i don't know if freebsd wants to be root to open some sockets
21:26:42 <mae_> you could try if your getting some permission denied type errors..
21:26:53 <mike-burns> Didn't help.
21:26:56 <mike-burns> http://pastebin.com/d6d0b6a79
21:26:59 <mae_> paste the output please
21:27:04 * mae_ looks
21:27:20 <mae_> ahh o,m
21:27:21 <mae_> o
21:27:29 <mae_> so there is something bad happening here
21:27:30 <mae_> hehe
21:29:13 <mae_> it doesn't like something in SocketPair.hs
21:29:29 <mike-burns> Yeah, that's the only place that `connect' and `accept' are called.
21:29:36 <mae_> a bit weird as it works on linux and windows
21:29:40 <mae_> you are 64 bit right?
21:29:56 <mike-burns> Yes.
21:30:17 <mae_> so maybe it doesn't like aNY_PORT
21:30:29 <mae_> try changing this line
21:30:31 <mae_> (listenOn (PortNumber aNY_PORT))
21:30:34 <mae_> to something like
21:30:51 <mae_> (listenOn (PortNumber 12345))
21:31:16 <mike-burns> Do I have to re-run the 'cabal install' line?
21:31:20 <mae_> no
21:31:24 <mae_> this is just for the testing side of things
21:31:26 <mike-burns> It didn't change anything when I did that.
21:31:32 <mike-burns> Same error as before.
21:31:35 <mae_> hmm
21:31:50 <mae_> that is strange, why would accept not work after using listenOn
21:32:11 <mae_> what version of ghc?
21:32:17 <mike-burns> 6.10.2
21:32:23 <mae_> ahh yeah thats in the first pastebin
21:33:31 <mae_> ok well i only wrote this lib because windows doesn't have socketPair
21:33:33 <mae_> but this should work
21:33:35 <mae_> open up Test.hs
21:33:39 <mike-burns> Okay.
21:34:03 <mae_> add this import:
21:34:29 <mae_> or actually, change this import from: import Network.Socket (Socket)
21:35:40 <mae_> to : import Network.Socket (Family(..), Socket, SocketType(..), defaultProtocol)
21:36:02 <mae_> ahh one more too
21:36:12 <mae_> import Network.Socket (Family(..), Socket, SocketType(..), defaultProtocol, socketPair)
21:36:28 <mike-burns> Ambiguous occurrence `socketPair'
21:36:48 <mike-burns> I'll remove it from the import one line below.
21:36:51 <mae_> yep
21:37:13 <mike-burns> http://pastebin.com/d2a586dfc
21:37:13 <mae_> and then err, you know what, this is going to get pretty hairy
21:37:18 <mike-burns> Ha.
21:37:21 <mike-burns> Yeah, it didn't work.
21:37:23 <mae_> because i have handlepair also
21:37:54 <mike-burns> I wish I had GHC on a server; I'd give you access.
21:38:08 <mae_> you know what, i'll just add some cpp magic to this to make it work on freebsd
21:38:11 <mae_> give me 10 minutes
21:38:14 <mike-burns> Can do.
21:40:10 <hackagebot> swish 0.2.1 - A semantic web toolkit. (VasiliGalchin)
21:46:31 <mae_> mike-burns: try replacing the contents of SocketPair.hs with: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3045#a3045
21:46:51 <mae_> hopefully socketpair is supported by your operating system build
21:47:09 <zoheb> @pl (\x -> readFile x >>= print)
21:47:10 <lambdabot> (print =<<) . readFile
21:47:13 <mike-burns> Test.hs: socketpair: unsupported operation (Operation not supported)
21:47:16 <mae_> argh
21:47:28 <mae_> so this tells me that socketPair doesn't even work
21:47:30 <mike-burns> I undid all the Test.hs changes.
21:47:33 <mae_> man the network package is borked
21:47:36 <zoheb> @type (=<<)
21:47:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:48:08 <mae_> ok so i'm reverting those changes
21:48:40 <zoheb> @pl (\x -> readFile x >>= print)
21:48:41 <lambdabot> (print =<<) . readFile
21:49:55 <mike-burns> Hadn't heard of socketpair before tonight. Interesting.
21:49:59 <mae_> ok heres a shot in the darkb ut
21:50:02 <mae_> but *
21:50:17 <mae_> what is your ulimit set to for open files? (freebsd has ulimit right?)
21:50:51 <mike-burns> Seems to be a shell built-in.
21:50:55 <mike-burns> [mike@battered] ~/sendfile% ulimit
21:50:57 <mike-burns> unlimited
21:51:00 <mae_> ulimit -a
21:51:12 <mike-burns> 11095
21:51:18 <mike-burns> That's this line:
21:51:19 <mae_> try setting it to 1024
21:51:20 <mike-burns> -n: file descriptors           11095
21:51:22 <mae_> and try the original again
21:51:37 <mike-burns> How do I gte the original file back with darcs?
21:51:41 <mae_> ulimit -n 1024
21:51:42 <mike-burns> (This is my first time using it.)
21:51:44 <mae_> darcs revert <file>
21:52:09 <mike-burns> Back to the first error.
21:52:19 <mae_> ok so what does ulimit -a say?
21:52:25 <mae_> for open files
21:52:26 <mike-burns> -n: file descriptors           1024
21:52:28 <mae_> ok
21:52:37 <mae_> hmm man, invalid file descriptor what the heck!
21:52:40 <bgs100> Night all
21:52:43 <mae_> we are using haskell functions
21:52:51 <mae_> maybe 6.10.2 is borked on bsd?
21:52:58 <mae_> which ver of network
21:53:02 <mike-burns> It's possibly. 6.10.3 doesn't run at all.
21:53:23 <mike-burns> Network 2.2.1.1
21:53:28 <zoheb> @type (print =<<).((return =<<) . getModificationTime)
21:53:29 <lambdabot> Not in scope: `getModificationTime'
21:53:40 <zoheb> @type (print =<<).((return =<<) . readFile)
21:53:41 <lambdabot> FilePath -> IO ()
21:53:49 <mae_> latest version is 2.2.1.3
21:53:53 <mike-burns> I can try upgrading.
21:53:55 <mae_> can you try updating to this
21:53:58 <mae_> k
21:54:56 <mike-burns> Couldn't match expected type `network-2.2.1.1:Network.Socket.Socket'
21:55:03 <mike-burns> I screwed somethin gup.
21:55:09 <mike-burns> (In case you can't tell, I'm new to Haskell.)
21:55:40 <mike-burns> How do I tell it that it needs to use 2.2.1.3?
21:55:41 <mae_> hah no worries
21:56:06 <mae_> add -package network-2.2.1.3 to your arguments
21:56:11 <mae_> so the same runghc command
21:56:12 <mae_> but add that
21:56:29 <mike-burns> Same error.
21:56:33 <mae_> heh
21:56:36 <mae_> man i am at a loss
21:56:52 <mae_> maybe bug in 6.10.2
21:57:02 <mae_> thats no good
21:57:18 <mae_> have you tried 6.10.4 yet?
21:57:27 <mike-burns> I couldn't get it to build.
21:57:38 <mike-burns> I got 6.10.3 to build, but it crashes immediately on AMD64.
21:57:43 <mae_> right
21:57:50 <mae_> i'm running on 32bit
21:57:58 <mae_> i bet theres tons of unclean 64-bit code
21:58:16 <thoughtpolice> 'unclean'?
21:58:23 <mae_> yeah err
21:58:25 <mike-burns> Hah, 'unworking'.
21:58:35 <mae_> you know, hardcoding Word32 for instance for a ffi function
21:58:39 <mae_> and then you go to 64 bit
21:58:43 <mae_> and it doesn't behave as expected
21:58:44 <mae_> for instance
21:59:31 <thoughtpolice> L
21:59:42 <thoughtpolice> damn wrong terminal tab :X
21:59:47 <mae_> heh
21:59:54 <mae_> thoughtpolice: did I offend your sensibilities?
22:00:14 <thoughtpolice> i just kind of stumbled my key combos there for a sec I think :p
22:00:17 <mae_> heh
22:00:23 <mae_> ok so, mike-burns
22:00:30 <mae_> borked ghc installation or borked ghc?
22:00:33 <mike-burns> mae_: So you think it's bigger than just FreeBSD AMD64? It might be all 64-bit?
22:00:33 <mae_> that is the question
22:00:42 <mae_> mike-burns: i don't know
22:00:52 <thoughtpolice> AFAIK ghc 6.10 isn't even in freeBSD ports yet
22:00:54 <mae_> probably i would say 50/50 chance at this point, since you say you are new to haskell >:]
22:00:56 <thoughtpolice> it's still 6.8 i thought?
22:00:57 <mike-burns> thoughtpolice: It's not.
22:01:13 <thoughtpolice> 64bit should be fine though, at least on linux :p
22:01:17 <mae_> haha
22:01:27 <mae_> oh lord, what have thou done with our posix
22:01:44 <mae_> mike-burns: do you have 6.8.3 installed?
22:01:52 <mike-burns> I do not.
22:01:56 <mae_> hm ok
22:02:09 <mae_> well, the sendfile impl could be completely fine for all we know
22:02:10 <mae_> it builds right?
22:02:15 <mike-burns> It builds.
22:02:16 <mae_> we just can't accept a port
22:02:17 <mae_> lol
22:02:41 <mae_> well accept a peer, to be more correct with my terminology
22:02:43 <mae_> bummer
22:02:57 <mae_> thanks for trying at least
22:03:09 <mike-burns> Sure thing. Wish I could debug this better.
22:03:28 <mae_> yeah, well, if you turn up some gold, then let the happs mailing list know :) or me directly
22:03:34 <mike-burns> Ha will do.
22:03:45 <mae_> i might just release it anyways
22:03:46 <mae_> har
22:03:54 <mae_> and say "experimental" next to bsd
22:04:03 <mike-burns> Wouldn't be the first time something's been released that doesn't work on FreeBSD.
22:06:19 <hackagebot> sendfile 0.4 - A portable sendfile library (MatthewElder)
22:06:24 <mae_> and thar she is
22:06:39 <mike-burns> The prior release worked with FreeBSD AMD64?
22:06:47 <mae_> prior release had no native freebsd
22:06:50 <mae_> (sendfile)
22:06:52 <mike-burns> Ah.
22:07:45 <eoeas> Hello masters of the Haskell, any good tutorials for an absolute newbie out there?
22:07:58 <mike-burns> eoeas: http://learnyouahaskell.com/
22:08:22 <mike-burns> eoeas: Also, I liked this so I made a Web page out of it: http://mike-burns.com/project/all%20your%20haskell/
22:09:53 <eoeas> mike-burns: wicked, will get cracking :-D
22:10:15 <eoeas> mike-burns: thanks
22:10:20 <mike-burns> Any time.
22:20:32 <mike-burns> Is there any tutorial on the non-Haskell side of Haskell? Various GHC pragmas and when we'd use them; how cabal and ghc-pkg work; ideal directory structures for libraries. Things like that?
22:20:58 <Berengal> cabal ang ghc both have user manuals
22:20:58 <Axman6> there's a wikibook, and the ghc docs
22:21:03 <Berengal> and*
22:22:03 <mike-burns> User manuals tend not to have motivating reasons behind the examples.
22:22:28 <mike-burns> But you're right, I should just sit down and read the manuals.
22:22:57 <Berengal> I think those are the best you can get at this point...
22:23:16 <mike-burns> I suppose I should write one as I read the manuals. That'd be the right thing to do.
22:23:42 <Berengal> Yeah, that seems like a good attitude
22:25:43 <mike-burns> http://en.wikibooks.org/wiki/Haskell/Packaging is pretty decent with regards to the ideal directory structures for libraries thing, and also includes how to write documentation (which I forgot in my original list).
22:28:14 <mike-burns> Ah I'll read the cabal docs tomorrow. Goodnight.
22:39:44 <Berengal> mike-burns: That IRC-lecture was pretty good. I think we should start collecting more of them. They're common enough at least
22:40:30 <Berengal> Hmm, he's gone, isn't he...
22:40:39 <Berengal> @tell mike-burns That IRC-lecture was pretty good. I think we should start collecting more of them. They're common enough at least
22:40:39 <lambdabot> Consider it noted.
23:20:59 <theonewhoisone> hey there haskell noobie here
23:21:11 <sjanssen> uh oh
23:21:14 <theonewhoisone> I'm having the following error with my program:
23:21:29 <theonewhoisone> prog.hs:16:57: Not in scope: `sort'
23:21:35 <sjanssen> import Data.List
23:21:40 <theonewhoisone> thx :)
23:21:51 <theonewhoisone> you'd e surprised how hard that is to find in the tuts
23:22:36 <sjanssen> @docs
23:22:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
23:22:50 <sjanssen> that's a list of all the modules that come with GHC
23:23:18 <theonewhoisone> which of those don't need to be imported?
23:24:17 <sjanssen> Prelude is the only implicit import, the rest have to be imported if you need a function from them
23:24:22 <sjanssen> @docs Prelude
23:24:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
23:25:19 <theonewhoisone> ok cool
23:25:22 <theonewhoisone> thx again
23:25:26 <theonewhoisone> and thx lambdabot lol
23:25:31 <theonewhoisone> he's such a great guy
23:34:22 <vav> theonewhoisone: some search engines that are helpful are http://haskell.org/hoogle and http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:38:29 <Fairweather> > let fibs = 1 : scanl (+) 1 fibs in take 10 fibs
23:38:30 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
23:40:41 <jfm> \quit
23:45:20 <ray> > let fibs = fromJust . getSequenceByID $ "A000045" in fibs
23:45:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:46:21 <caxaf> ray: Blach.
23:48:37 <ray> > programs <$> lookupSequenceByID "A000045"
23:48:39 <lambdabot>   Just [(Mathematica,"with(combinat): A000045 := proc(n) fibonacci(n); end;")...
23:57:40 <ray> it would be pretty cool if oeis stored haskell code for a sequence as an infinite list and that library could useit
