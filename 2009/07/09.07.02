00:00:20 <kulakowski> FunctorSalad: i've seen bayesian thought argued as a definition of how much we can objectively believe a statement to be true
00:01:00 <kulakowski> although that just leads you to run around in a different circle i suppose
00:04:08 <zeiris> foldl and foldr both cause an equal amount of space leak, right? And both have foldr' and foldl' versions?
00:04:10 <zeiris> :t foldr'
00:04:11 <lambdabot> Not in scope: `foldr''
00:04:12 <FunctorSalad> kulakowski: yeah, like assigning priors and interpreting observations... what I find funny is that any concept leads to circles if you analayze it, but on the other hand when doing anything else than philosophising one quickly notices that things aren't completely arbitrary ;)
00:05:37 <Twey> dancor: That's because there isn't one
00:05:49 <dancor> ah
00:06:02 <Twey> Moral objectivism and metaphysical objectivism are completely different concepts
00:06:21 <dancor> well the moral one is a superset of the metaphysical one, supposedly
00:06:50 <luqui> zeiris, foldl and foldr are different things, to compare like that them doesn't make sense.
00:07:06 <dancor> s/is a superset/subsumes/
00:07:23 <Twey> They belong to different disciplines
00:07:50 <kulakowski> FunctorSalad: yeah. i think that not trying to make 'rigorous' or axiomatize everything at every step is what leads to understanding.
00:09:05 <kulakowski> like defining a functor as something that preserves commutative diagrams, when a diagram is defined as a functor from a discrete category...another vicious circle, but understanding what it actually means won't be found by staring at the axioms
00:10:16 <edwardk> @seen luqui
00:10:16 <lambdabot> luqui is in #haskell and #haskell-blah. I last heard luqui speak 3m 26s ago.
00:10:37 <luqui> edwardk, hallo
00:10:52 <edwardk> just posted a blurb on your -On vs. -By post
00:11:15 <luqui> edwardk, reader told me so.  reading.
00:11:30 <zeiris> @seen waldo
00:11:30 <lambdabot> I haven't seen waldo.
00:11:33 <FunctorSalad> kulakowski: for that reason I'm beginning to suspect that formalising category theory (on the computer) is dangerous to one's sanity. there are lots of these circles there..
00:11:40 <edwardk> <- guilty of typeclass abuse
00:12:28 <kulakowski> FunctorSalad: I'm not convinced that it is dangerous for one's mental health, but I don't think it's especially productive (on or off the computer).
00:12:56 <edwardk> and arguably the argument order for newtype EqBy s a = EqBy a should be newtype EqBy a s = EqBy a -- with things flipped around so you can say Eq (a `EqBy` s) -- where s `Reflects` (a -> a -> Bool) -- would read more naturally, but I just banged it out fast
00:13:22 <FunctorSalad> kulakowski: I was exaggerating a bit there ;)
00:13:41 <luqui> edwardk, what is Data.Reflection?
00:13:47 <edwardk> er instance (s `Reflects` (a -> a -> Ordering)) => Eq (a `EqBy` s) where ...
00:13:55 <edwardk> turns a term into a type
00:14:04 <kulakowski> but i'm also a person that feels that, as long as you don't go looking for trouble regarding sets (i.e. saying the set of all sets, ordinal of all ordinals, category of all categories) then you won't get in any paradox trouble (especially since what you really want to be talking about is the class of all sets, the what could be called 2-ordinal of all ordinals, and the 2-category of all categories
00:14:11 <kulakowski> and i know you were joking :)
00:14:26 <FunctorSalad> retrospectively it would probably have been easier to just use ZFC than try to encode it in some type system, or directly as a first-order theory, or ...
00:14:47 <edwardk> which you can then reflect back into that term. lets you abuse unification to propagate the same term to many places in your code and ensure they will all be the same
00:15:35 <luqui> edwardk, interesting.  is this on hackage?
00:15:39 <edwardk> so in this case OrdBy abuses the fact that the type 's' reifies a function of type a -> a -> Ordering into the type level, so you consistently apply the same function when you reflect it
00:15:39 <edwardk> yeah
00:15:55 <luqui> interesting that it's not in the Reflection category
00:16:07 <edwardk> But note you don't need the reflection package, you can get by with the Haskell 98 EqBy2 and OrdBy2 definitions
00:16:20 <edwardk> i think the reflection category may have been created after
00:16:41 <luqui> oh it's a pearl
00:16:52 <luqui> i love those :-)
00:17:13 <edwardk> reify, reflect and the 'Reflects' typeclass are the key considerations
00:17:20 <edwardk> the rest are just vehicles towards getting those to work
00:17:32 <edwardk> technically I should bump the minor version and rename 'Reflects' to 'Reifies'
00:17:32 <FunctorSalad> kulakowski: I tend to agree, though the universe approach solves it quite neatly too IMHO
00:17:58 <FunctorSalad> (category of sets which are elements of some universe)
00:18:01 <edwardk> since s reifies a term into the type level and it can be reflected back down.
00:18:14 <nlogax> in some haskell sauces i look at, there are functions with under_scores instead of camelCase, why is that?
00:18:20 <luqui> edwardk, unrelated:  have you seen the recent activity about FMList?
00:18:32 <edwardk> nlogax: because its like herding cats to get consistency out of people. =)
00:18:32 <luqui> representing a list as its foldMap?
00:18:36 <Meady> anyone here use GTK2HS?
00:18:37 <edwardk> luqui: yeah
00:18:44 <kulakowski> FunctorSalad: I think so too, or at least it means that anything we actually think about is sufficiently small enough to be controlled by some huge cardinal.
00:18:59 <Meady> just trying to find how to add event handler to button click
00:19:01 <edwardk> luqui: although i think i pointed out to folks that an illegal monoid instance can detect shape differences in it
00:19:05 <luqui> edwardk, I was wondering if there was some underlying theory you knew of about data structures of that form:  forall b. C b => (a -> b) -> b
00:19:23 <luqui> edwardk, illegal instances don't concern me ;-)
00:19:57 <luqui> since it seems to be up your alley
00:20:01 <edwardk> well, lets take your type apart real fast. its just the Yoneda lemma applied to your dictionary.
00:20:07 <FunctorSalad> if you allow arbitrary instances it seems like it's actually a tree, not a list
00:20:45 <FunctorSalad> I didn't quite follow the activity, what do you gain by encoding *lists* that way?
00:21:05 <luqui> FunctorSalad, well, bi-infiniteness was interesting.
00:21:11 <aavogt> Meady: onClicked button somethingToDo
00:21:15 <luqui> FunctorSalad, a list can be infinite from the left and from the right
00:21:40 <aavogt> should be covered in the documentation of gtk2hs, or even the original C library
00:22:11 <luqui> edwardk, so the functor in this case is (b, C b), where C is the dictionary for the class C
00:22:15 <luqui> ?
00:22:19 <edwardk> (a -> b) can do anything to get a b, but the only thing a function (a -> b) -> b can do with that b once it has it is apply the methods in the typeclass because of parametricity
00:22:28 <edwardk> looks something like that to me, yeah
00:22:30 <mmorrow> zeiris: you want foldl', but foldr you don't want the strictness because in foldl' you're forcing the accumulator, whereas with foldr' you'd be forcing the entire rest of the fold in order to get at the result of the first step
00:22:38 <mmorrow> , foldr (\x !xs
00:22:40 <lunabot>  luna: parse error on input `)'
00:22:52 <mmorrow> , foldr (\x !xs -> x : xs) (:) [0..]
00:22:53 <lunabot>  luna: Couldn't match expected type `[a]'
00:23:01 <mmorrow> , foldr (\x !xs -> x : xs) [] [0..]
00:23:03 <lunabot>  Stack space overflow: current size 8388608 bytes.
00:23:03 <lunabot>  Use `+RTS -Ksize' to increase it.
00:23:07 <mmorrow> , foldr (\x xs -> x : xs) [] [0..]
00:23:09 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
00:24:02 <edwardk> i may be wrong on that but it sounds right to me
00:24:38 <luqui> edwardk, hm.  ok... i was just considering what sorts of generalizations such a pattern might have and it turned out difficult
00:24:49 <Meady> im getting not in scope errors defining functions
00:24:55 <Meady> a <- putStr "hi" for example
00:25:32 <FunctorSalad> luqui: if C describes some sort of algebra, then "forall b. C b => (a -> b) -> b" is the free algebra with generators in a I'd say
00:25:41 <Saizan> zeiris: http://www.haskell.org/haskellwiki/Stack_overflow
00:25:42 <FunctorSalad> (like with C=Monoid)
00:26:07 <Twey> Meady: Why?
00:26:07 <copumpkin> Meady: hmm?
00:26:15 <edwardk> the problem is the FMList conversion only works because of the laws for Monoid that you can't actually express in Haskell's type system. The best you should really be able to get under Haskell's type system that is enforceable is one that has a dictionary with the type for the usual right fold.
00:26:28 <Meady> NOT SURE
00:26:35 <copumpkin> Meady: you haven't given us much information :P
00:26:50 <Meady> import Graphics.UI.Gtk
00:26:50 <Meady> main :: IO ()
00:26:50 <Meady> main = do
00:26:50 <Meady> 	  initGUI
00:26:50 <Meady> 	  window < - windowNew
00:26:54 <Meady> lAST LINE THROWS THE ERROR
00:27:04 <Meady> Sorry for caps
00:27:15 <copumpkin> Meady: what's the actual error?
00:27:21 <copumpkin> @where hpaste
00:27:22 <lambdabot> http://hpaste.org/
00:27:22 <luqui> edwardk, yeah, but i know haskell's type system is fairly weak, and i can always imply stronger laws behind an abstraction barrier
00:28:04 <Meady> window not in scope
00:28:23 <copumpkin> Meady: is that <- or < *space* - ?
00:28:25 <Twey> And what is the line after that one?
00:28:31 <Twey> Ah
00:28:33 <Twey> copumpkin's got it
00:28:55 <Meady> cancel that
00:28:57 <Meady> ive fixed it
00:29:23 <copumpkin> Meady: in future, you'll get the best answers if you post the snippet that fails and the error message GHC spat at you :)
00:29:31 <Meady> Yeah
00:29:33 <copumpkin> (in hpaste)
00:29:34 <Meady> Thanks
00:29:50 <copumpkin> how're you feeling about haskell now btw?
00:30:48 <Meady> Erm its actually becomming quite nice, can i show some source if i pastebin it? and ill explain my issue with haskell and me
00:31:04 <FunctorSalad> good night... :)
00:31:06 <copumpkin> Meady: hpaste is the nice haskell pastebin :) it has syntax highlighting etc.
00:31:09 <copumpkin> Meady: but sure
00:31:26 <copumpkin> Meady: we'll even read other paste services if you insist :P
00:31:34 <meder> hi Twey
00:31:49 <meder> damn, i see you like every 6 months
00:31:50 <meder> :p
00:31:59 <Twey> Hi, meder
00:32:02 <Twey> Who are you?  :-P
00:32:05 <mmorrow> yeah, the syntax highlighting is great
00:32:06 <Meady> Ok http://pastebin.com/m1dd31b01    Basically it still feels like im not programming in a functional manner
00:32:11 <mmorrow> (python...)
00:32:35 <meder> Twey: the artist formerly known as facedown on freenode ##javascript from 07-08
00:32:43 <copumpkin> Meady: so break it up!
00:32:47 <meder> or soulscratch, whatever my name was backthen..
00:32:53 <meder> the guy Woosta banned several times :p
00:32:54 <Twey> Ah :)  Hi
00:32:58 <meder> heh
00:33:04 <Meady> Hmm kinda chuffed copumpkin you asked how i was finding it tbh
00:33:05 <mmorrow> ah, pygments is the name of the python lib that hpaste uses (couldn't remember for a second there)
00:33:14 <Twey> Meady: That's because you're just doing IO there
00:33:28 <Twey> Once you get to a real program, with actual calculation, it gets a lot nicer
00:33:40 <copumpkin> Meady: I'm glad you're liking it :) just saying that even something that simple can be abstracted a bit :)
00:33:44 <Twey> (and you can do a lot of interesting stuff even with IO code)
00:33:52 <copumpkin> Meady: but indeed things will get more interesting as your programs do too
00:35:13 <mmorrow> hah, i just found this brainfuck quine online, but it's too long to fit in a single irc message for [$bf||]
00:35:16 <Meady> yeah definately, even thinking about switching back to archlinux tmorow
00:35:20 <copumpkin> ooh
00:35:30 <zeiris> @pastebin
00:35:30 <lambdabot> Unknown command, try @list
00:35:32 <zeiris> @paste
00:35:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:35:38 <mmorrow> (is the message length-limit imposed by the client or by the irc server?)
00:35:46 <Zao> Protocol.
00:35:50 <meder> Twey: you read RWH?
00:35:51 <Meady> so quick question, IO String would be executed by (\x <- IOSTRCOMMAND)
00:35:51 <mmorrow> ah
00:36:03 <Meady> Im getting expected string found IO string, which means io needs to be processed right?
00:36:05 <Twey> Meady: I did, yes
00:36:38 <Meady> Ok that was completely wrong
00:36:42 <copumpkin> Meady: :)
00:36:43 <Zao> Meady: You seem to be mixing up lambdas and do blocks.
00:36:51 <copumpkin> lambdo
00:37:00 <Meady> basicall IO String is IO to be done whcih i have to execute first
00:37:04 <Meady> but im tired of assigning
00:37:06 <Zao> do { omg <- wtf; bbq <- rofl; print (omg + bbq) }
00:37:15 <copumpkin> Meady: you can use what <- becomes directly... >>=
00:37:18 <Meady> onClicked cmdCommand (labelSetText output (entryGetText txtCommand))
00:37:24 <mmorrow> anyways, here's the bf quine http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6444#a6444
00:37:29 <copumpkin> Meady: that's where you start getting fancy :)
00:37:29 <Meady> entryGetText returns IO String, not string
00:37:33 <Meady> So how do i execute it
00:37:47 <Meady> intead of () i use<-?
00:37:48 <copumpkin> you'd want to use =<<
00:38:05 <copumpkin> assuming it's all in IO
00:38:29 <Meady> ahh, i need to execute IO and give result to other func
00:38:50 <Meady> but i dont want to use func to store results all the time
00:39:09 <Meady> a <- entryGetText txtCommand works, but thats not what i wana do, i wana have it return to the funciton that needs it
00:39:18 <copumpkin> I'm not familiar with those functions, but onClicked cmdCommand (labelSetText output =<< entryGetText txtCommand) -- should work I think
00:39:22 <Zao> Meady: do { x <- getLine; print x }  and getline >>= print  are equivalent.
00:39:31 <Zao> ( or print =<< getline)
00:39:36 <copumpkin> actually, it may need another layer of that for the outer ()
00:40:21 <zeiris> So what's the difference between foldr and foldl? One evaluates (((1*2)*3)*4) the other (1*(2*(3*4)))... I take it the internal stack storage results in the first representation requiring a lot more thunks than the second to store?
00:40:35 <Meady> yeah zao thats what im getting to work essentially
00:40:51 <copumpkin> Meady: did what I said work?
00:40:54 <Meady> does $ just substitute ()
00:40:57 <copumpkin> you might need another =<<
00:41:02 <Meady> Seems to have yeah
00:41:09 <Zao> omg $ wtf bbq  === omg (wtf bbq)
00:41:11 <copumpkin> Meady: effectively, yeah
00:41:20 <Zao> Meady: It's like a space with very low precedence.
00:41:26 <Zao> @src ($)
00:41:26 <lambdabot> f $ x = f x
00:41:32 <copumpkin> Meady: it takes advantage of the fact that in haskell you can specify the precedence of operators, and gives itself the lowest
00:42:19 <mmorrow> zeiris: foldl and foldl' don't need any stack (foldl uses a lot of heap though), and foldr only needs stack (a lot of it too, which is why foldl' should be used if this is the case) if it's producing an "atomic" result (e.g. Int)
00:42:28 <Meady> a <- entryGetText txtCommand
00:42:28 <Meady> labelSetText output a
00:42:34 <Meady> Thats what worked in the end, but i wanted it one line
00:42:45 <copumpkin> labelSetText output =<< entryGetText txtCommand
00:42:45 <shachaf> zeiris: Well, for one, with a non-associative operator, those two expressions are very different.
00:43:00 <Meady> so that processes the IO and puts it into labelSetText?
00:43:08 <copumpkin> Meady: they are almost exactly equivalent
00:43:22 <copumpkin> Meady: the former notation is simply translated by the compiler into something almost identical to the latter
00:43:22 <mmorrow> zeiris: doing foldr (+) 0 is essentially like doing:
00:43:54 <Meady> very nice
00:44:09 <Meady> Right ok, next how do i stop gtk resizing when i adjust controls
00:44:19 <copumpkin> so everything you write in a do block is really a string of >>= and >> and lambdas :)
00:44:26 <Meady> yeah
00:44:33 <mmorrow> int go(int *xs, int i, int n){if(n<=i) return 0; return xs[i] + go(xs,i+1,n);}
00:44:33 <Meady> >> doesnt carry result >>= does
00:44:38 <copumpkin> Meady: yeah
00:44:42 <Meady> how do i stop gtk resizing
00:44:51 <mmorrow> (the testing for the end of the array was kinda noisy there, but you see what i mean)
00:44:52 * copumpkin has never used GTK :/
00:45:06 <mmorrow> "return xs[i] + go(xs,i+1,n);}" being the relevant bit
00:45:21 <mmorrow> i.e. you would never do that
00:45:37 <mmorrow> because you could just use a loop to sum it
00:45:44 <mmorrow> which is essentially what foldl' does
00:46:24 <mmorrow> *but* is you're not using '+' and using something like (:) for instance, foldr *is* what you want
00:46:53 <copumpkin> even if you are using + in some cases I think
00:46:58 <mmorrow> nevar!
00:47:03 <Cale> zeiris: I have a diagram which shows the difference in terms of structure
00:47:12 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
00:47:12 <mmorrow> copumpkin: well, which (+) is that?
00:47:17 <copumpkin> what if you make up an instance of Num that defines + nice and lazily
00:47:24 <mmorrow> copumpkin: yeah, then you want foldr
00:47:26 <copumpkin> with a S|Z or something
00:47:31 <copumpkin> yup
00:47:37 <zeiris> I think I need to write this down. Is this a compiler definition of foldr, or the way the compiler translates the haskell definition of it?
00:47:58 <Meady> anyone? if i change a label it shrinks the whole gui to fit it
00:48:17 <Cale> zeiris: I think he just gave an analogy
00:48:20 <mmorrow> zeiris: that C code was just an analogy
00:48:21 <mmorrow> yeah
00:48:33 <zeiris> Okay :)
00:49:03 <Cale> Here's the difference in terms of steps of actual Haskell evaluation
00:49:12 <Cale> foldr (+) 0 [1,2,3]
00:49:25 <Cale> -> 0 + (foldr (+) 0 [2,3])
00:49:33 <Cale> er oops
00:49:37 <Cale> -> 1 + (foldr (+) 0 [2,3])
00:49:40 <Cale> of course ;)
00:49:48 <copumpkin> edwardk: does mapAccumR have a fancy *morphism name? it seems like it should
00:49:49 <Cale> -> 1 + (2 + (foldr (+) 0 [3]))
00:49:58 <Cale> -> 1 + (2 + (3 + (foldr (+) 0 [])))
00:50:02 <copumpkin> or mapAccumR (flip f) as Cale's diagram points out
00:50:03 <Cale> -> 1 + (2 + (3 + []))
00:50:20 <Saizan> 0
00:50:21 <copumpkin> (sorry for breaking that up btw)
00:50:24 <Cale> er, yeah
00:50:29 <Cale> -> 1 + (2 + (3 + 0))
00:50:31 <Cale> blah ;)
00:50:46 <Cale> (possibly should be getting to sleep soon, if I can't do that ;)
00:51:13 <Saizan> i'm surprised you don't have a macro for that yet :)
00:51:35 <Cale> How would I know when I needed sleep?
00:51:37 <zeiris> So for 'easy' operations, foldl' is simpler and faster because it doesn't thunk/cache them. But for more complex ones, foldr... Ug. I see what they evaluate to, but don't see how it affects which one to select.
00:51:47 <Cale> zeiris: uh...
00:51:59 <Cale> zeiris: the nice thing about foldr is that it immediately passes control to f
00:52:13 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
00:52:23 <Cale> the foldr f z xs will only be evaluated if f needs it
00:52:29 <Cale> (and when f needs it)
00:52:49 <Cale> So if f can return part of its result without computing the foldr, maybe the recursion will never happen.
00:52:57 <Cale> foldl on the other hand...
00:53:08 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
00:53:17 <mmorrow> zeiris: since function applications don't immediately get evaluated, ie they're "frozen", if the (<>) in (foldr (<>)) is such that (a <> THUNK) is a fully evaluated result, then you want foldr
00:53:21 <Cale> passes control to itself until the list ends
00:53:32 * Cale doesn't like the word thunk
00:53:41 <Cale> What's wrong with the word 'expression'?
00:53:47 <copumpkin> it feels like a bad past tense
00:54:00 <mmorrow> since (1 + THUNK) is not fully evaluated, you want foldl', because to evaluate (1 + THUNK), you need to evaluate 1 and THUNK first
00:54:20 <zeiris> Cale: oohhhhh, eurika!
00:54:43 <mmorrow>  (1 + THUNK{1 + THUNK{1 + THUNK{1 + .... ) is where all the stack comes in
00:54:44 <zeiris> Thunk is the sound of your head hitting your desk in exasperation.
00:54:53 <mmorrow> heh
00:55:09 <mmorrow> Cale: heh
00:55:14 <Cale> I just think of the evaluator as replacing expressions with other expressions repeatedly.
00:55:32 <mmorrow> Cale: i think of "expression" as refering to the source-code level representation
00:55:33 <Cale> Thunk is a closure type and too specific to the way GHC does things for me :)
00:55:51 <luqui> the only way that doesn't necessarily work is re: sharing, but even then it's vague enough that it's a good model
00:56:14 <mmorrow> i dunno, i think of "thunk" as := a non-fully-evaluated value
00:56:48 <Saizan> (1: foldr f 0 [2,3]) is not fully evaluated to me
00:56:50 <ray> a thunk doesn't (necessarily) exist, but it's convenient to talk about
00:56:56 <mmorrow> Saizan: it is though
00:57:00 <mmorrow> whnf
00:57:11 <mmorrow> well, once you've seq'ed it
00:57:16 <Cale> It's evaluated enough for a case
00:57:22 <Saizan> we've a different opinion on "fully"
00:57:22 <mmorrow> err, bad way to say it
00:57:30 <mmorrow> Saizan: whnf is my def
00:58:13 <luqui> hnf ftw!
00:58:15 <mmorrow> (better way to say it is that `seq`ing it doesn't trigger evaluating it to rnf)
00:58:45 <mmorrow> `seq`ing (1 + (1 + (1 + ...) on the other hand is equiv to rnf
00:58:54 <mmorrow> (1::Int)
01:00:41 <copumpkin> > 1 :: Nat
01:00:42 <lambdabot>   Not in scope: type constructor or class `Nat'
01:00:44 <copumpkin> > 1 :: Natural
01:00:45 <lambdabot>   1
01:01:05 <copumpkin> > fix ((1 :: Natural) +) > 5
01:01:06 <lambdabot>   True
01:01:46 <copumpkin> > fix ((1 :: Natural) +) > 500
01:01:47 <lambdabot>   True
01:02:05 <mmorrow> > (not . null . drop 5) (fix (():))
01:02:06 <lambdabot>   True
01:02:51 <mmorrow> most defs of "lazy" numbers that i've seen are just [()]
01:03:05 <mmorrow> (..equivalent to..)
01:03:28 <copumpkin> wouldn't it be closer to a list of newtype Void = Void ?
01:03:43 <copumpkin> (shouldn't it be)
01:04:08 <mmorrow> i dunno
01:04:51 <mmorrow> The constructor of a newtype must have exactly one field
01:04:56 <copumpkin> oh yeah
01:04:57 <edwardk> copumpkin: hrmm
01:04:57 <mmorrow>   but `Void' has none
01:05:01 <copumpkin> newtype Void = Void Void
01:05:03 <copumpkin> :P
01:05:12 <copumpkin> is that even valid?
01:05:16 <edwardk> copumpkin: yeah
01:05:22 <copumpkin> yeah, so that
01:05:28 <edwardk> i mentioned it earlier today or yesterday when someone was asking for a Haskell 98 Void type
01:05:33 <mmorrow> but then you couldn't ever print it
01:05:52 <mmorrow> since you'd have to do [undefined,undefined]
01:06:00 <edwardk> mmorrow: sure you can just define a custom show instance that says 'fix Void' =)
01:06:06 <mmorrow> heh, true
01:06:39 <copumpkin> edwardk: did you catch the mapAccumR (flip f) question?
01:06:47 <edwardk> @type mapAccumR
01:06:47 <edwardk> checking
01:06:48 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
01:07:07 <copumpkin> it's one of those functions I've never really used other than to get a feel for it at the beginning
01:07:57 <edwardk> copumpkin: its in somewhat exotic territory for the Control.Morphism.* because you need a bifunctor fixpoint to start.
01:08:04 <mmorrow> hehe
01:08:05 <edwardk> but there can exist a generalization, sure.
01:08:08 <copumpkin> zomg
01:08:17 <copumpkin> sounds fancy
01:08:38 <copumpkin> bifixomorphism
01:08:39 <copumpkin> :P
01:08:46 <copumpkin> there, I made you one
01:09:02 <uzytkownik> @undo f -< x + 1
01:09:02 <lambdabot> f -< x + 1
01:09:10 <uzytkownik> @undo proc f -< x + 1
01:09:10 <lambdabot> proc f -< x + 1
01:09:18 <copumpkin> I don't think it knows about arrow notation
01:09:18 <mmorrow> don't think arrow syntax is on
01:09:25 <copumpkin> @unproc
01:09:25 <lambdabot> Unknown command, try @list
01:09:41 <edwardk> mapAccum :: Functor f => (f x acc -> (acc,y)) -> Fix f x -> (acc, Fix f y)
01:09:49 <edwardk> er not Functor f
01:09:52 <edwardk> BiFunctor f
01:10:00 <uzytkownik> :( it would be a great tool to understand arrows a bit...
01:10:27 <copumpkin> uzytkownik: the notation seemed harder than the arrows themselves
01:11:00 <uzytkownik> copumpkin: Well - I meant both arrows and notation
01:11:11 <copumpkin> there's a good tutorial paper on them
01:11:49 <copumpkin> I think http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf is the one I'm thinking of
01:11:52 <mmorrow> uzytkownik: there's an arrow notation preprocessor that was used before arrow syntax was included in ghc's parser. you could track that down
01:12:16 <mmorrow> (you could even use it to make an @unproc lambdabot plugin)
01:12:40 <Raevel> rwh recommends minihttp for lazy downloads, but hackage says it deprecated. What package should I use?
01:13:11 <mmorrow> what's a lazy download?
01:13:19 <mmorrow> only getting pieces as you need them?
01:14:26 <Raevel> um, kind of i guess. I don't want my program to have to load an entire file into memory before i can write it do disk
01:14:49 <mmorrow> i'm not sure http supports that, although i guess if the server was using chunked coding for a resource, you could just not respond to a chunk until you wanted the next one... (that might have bad consequences though)
01:15:13 <Raevel> this is what rwh says
01:15:16 <Raevel> "The HTTP library used here does not read the HTTP result lazily. As a result, it can result in the consumption of a large amount of RAM when downloading large files such as podcasts. Other libraries are available that do not have this limitation."
01:15:34 <mmorrow> Raevel: oh, that just seems like something any decent http code would do
01:15:40 <Raevel> right :-)
01:16:43 <mmorrow> (i don't know what lib to use or not to though)
01:18:02 <balor> Is elemIndex in the standard prelude? "let l = [1,2,3]" and then "zip l l" works for me, but "elemIndex 3 l" tells me that elemIndex is not in scope.
01:18:07 <balor> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html suggests that if I have zip then I should have elemIndex
01:18:23 <mmorrow> zip is in Prelude
01:18:28 <mmorrow> elemIndex is in Data.List
01:19:17 <balor> mmorrow: Thanks
01:21:02 <mmorrow> balor: weird, i dunno why Data.List is exporting all those functions that are in the prelude
01:21:27 <mmorrow> (i've never actually looked at the Data.List haddocks now that i think about it)
01:21:54 <balor> mmorrow: If you're confused, then I'm lost.  I started Haskell'ing on Monday!
01:22:04 <mmorrow> balor: heh
01:22:24 <Axman6> Data.List is a little odd, but damn useful too
01:23:29 <ziman> mmorrow, i've been told that Prelude only reexports things from Data.List
01:24:00 <mmorrow> ziman: yeah, it looks that way for ghc
01:24:28 <quicksilver> mmorrow: that's the design they adopted; more-or-less everything in the Prelude lives somewhere else and gets re-exported.
01:24:37 <quicksilver> mmorrow: it's a shame re-exporting is broken.
01:24:54 * mmorrow wishes foldl' would sneak into the Prelude's export list
01:27:49 <zeiris> Just want to say: thanks, guys, for providing all this information and answering questions and all :)
01:34:22 <McManiaC> what is a "!a" type?
01:35:57 <quicksilver> McManiaC: it's not techncially a different type from a
01:36:03 <quicksilver> McManiaC: the ! is a strictness annotation.
01:36:32 <quicksilver> McManiaC: in "data Foo = Foo !Int" the Int will be stored strictly, meaning it will be evaluated whenever it is assigned, so you never get a thunk there.
01:37:02 <McManiaC> hmkay
01:37:09 <luqui> it could mean unlifted?
01:37:15 <McManiaC> cant see why its necessary but ok :)
01:37:27 <luqui> McManiaC, you can optimize away an indirection
01:38:00 <luqui> i.e. data Foo = Foo Int  is a pointer to an Int (thunk), but data Foo = Foo !Int could very well be represented as a plain machine integer
01:38:01 <Raevel> McManiaC: http://www.haskell.org/haskellwiki/Performance/Strictness
01:38:33 <McManiaC> ok
01:40:26 <quicksilver> luqui: I think the avoidance of massive thunks is actually a more important reason than a potential, but rather minor, optimisation :)
01:41:14 <luqui> quicksilver, that could be too.  though that optimization isn't always minor
01:41:18 <copumpkin> edwardk: no more #haskell-iphone for you?
01:41:33 <luqui> 8 bytes here and there can make a big difference in a big data structure
01:45:30 <edwardk> copumpkin: i didn't think to log in there today
01:45:52 <edwardk> i have been toying with an idea for an iphone game today though.
01:46:12 <edwardk> if nothing else i'm curious to see what RyanT5000 will have to show at the next user group meeting
01:46:19 <copumpkin> :o
01:46:24 <copumpkin> when is that by the way?
01:46:25 <edwardk> copumpkin: btw- i'm planning on presenting a bunch of stuff on monoids there as well
01:46:32 <copumpkin> yeah, I saw your tweet
01:46:37 <copumpkin> I don't want to miss that!
01:46:38 <edwardk> Mid July, i want to say like the 13th or 14th
01:47:06 <copumpkin> cool
01:47:27 <edwardk> i figure i'll cover the 'monoids' library as it stands, monoidal file positions, regexes, utf8 parsing, using data compression to improve monoidal reuse, etc.
01:47:38 <copumpkin> sounds like fun
01:48:03 <edwardk> and then for august or september i'll pick up with zipping applicatives and maybe fox derivatives and see if i can fit in how to build a bottom up parser with stable names
01:48:17 <copumpkin> stable names in the GHC sense?
01:48:21 <edwardk> yeah
01:48:49 <copumpkin> hmm
01:48:55 <copumpkin> how do those help with parsing?
01:49:29 <edwardk> when you build bottom up you need to know all paths that exist to the root of the grammar. well, those paths can contain cycles... you'd rather have those cycles be recognized than have an infinite # of paths
01:49:39 <copumpkin> oh :)
01:49:42 <copumpkin> yeah, makes sense
01:49:50 <edwardk> its an issue when you want to parse monoidally especially, but it affects a lot of parser designs
01:50:05 <edwardk> its also useful in packrat parsing because you can see the cycles so you know what to memoize
01:50:35 <copumpkin> ah yeah
01:51:03 <FalconNL> Does anyone know if there's an alternative to show that gives the compact representation of a record, e.g. Foo 1 "a" instead of Foo { bar = 1, baz = "a" } ?
01:51:23 <RyanT5000> is there a random oracle in hackage?
01:51:47 <edwardk> FalconNL: just define your own Show instance
01:51:58 <edwardk> rather than rely on newtype deriving
01:52:04 <Meady> Guys is haskell a new language? doesnt have much docs online
01:52:18 <edwardk> Meady: no its been around for nigh on 2 decades now
01:52:19 <RyanT5000> Meady: what sort of docs are you looking for? they may just be hiding
01:52:38 <Meady> gtk2hs TextView
01:53:13 <RyanT5000> Meady: gtk2hs http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.10.0/
01:53:23 <Meady> Yeah i know, but specifically looking to get and set text inside it
01:53:26 <Meady> Cant see that
01:53:34 <Meady> Well i can, but ide like an example cause i dont understand the function
01:54:03 <mmorrow> FalconNL: one thing i've done for that is to stick a def of the type without the record stuff in a scratch file, then run "$ derive -dShow -dRead Scratch.hs" on that, and paste that into your prog as the Show,Read instances
01:54:05 <RyanT5000> Meady: well, I'm not sure if there's standalone gtk2hs tutorials; maybe a gtk+ tutorial would be helpful?
01:54:23 <RyanT5000> (i've never used Gtk+ or gtk2hs, so I may not be of much help :( )
01:54:25 <mmorrow> then you get the legit Show/Read instances, without the record noise
01:54:36 <Meady> not many haskell devs care about Guis huh
01:54:58 <RyanT5000> Meady: well, i'm a haskell developer who cares very much about GUIs, but only OpenGL ones :)
01:55:37 <copumpkin> Meady: the GTK bindings are just GTK as far as I know, and need to be used in the same way GTK is
01:55:38 <FalconNL> mmorrow: the adt I want to show already is an instance of show, so that approach doesn't work. I figured if there was a generic way to do it I could just use that, but I guess I'll just write my own function in this case
01:55:41 <Meady> Ahh wana show me some work
01:55:50 <Meady> Opengl
01:55:57 <mmorrow> FalconNL: ah, yeah if you didn't define it you're out of luck
01:56:34 <mmorrow> FalconNL: (but nothing prevents you from pulling the generated show/read functions out of the instances derive derives, and renaming them)
01:56:48 <RyanT5000> Meady: well, i haven't done much yet, but i'm leading a company that's developing a game in haskell
01:56:57 <mmorrow> FalconNL: have you ever used "derive" before? it's nice
01:57:01 <RyanT5000> Meady: so, i care about it, but i haven't got much experience yet :P
01:57:17 <RyanT5000> Meady: talk to me in a month or two :)
01:57:45 <FalconNL> mmorrow: Naturally I've used 'deriving', but I'm guessing derive is something different. Got a link?
01:58:08 <quicksilver> @google haskell data.derive
01:58:08 <lambdabot> http://hackage.haskell.org/package/derive
01:58:08 <lambdabot> Title: HackageDB: derive-0.1.4
01:58:13 <Meady> ahah Ryan, maybe we could learn together :P, ide like to do data representation in Opengl, and ive worked with basic directx, so i might pick it up
01:58:56 <mmorrow> FalconNL: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6446#a6446
01:59:11 <RyanT5000> Meady: well, i'm sure i'll be hanging out in this chatroom a lot
01:59:33 * copumpkin is writing an iphone app as we speak!
01:59:37 <mmorrow> FalconNL: (ignore the hstidy program there, it's on hackage but borken atm since i'm a lazy bum :)
01:59:37 <RyanT5000> copumpkin: awesome :)
01:59:41 <copumpkin> (unfortunately)
01:59:43 <copumpkin> depends :P
01:59:53 <RyanT5000> lol, i guess it would
01:59:53 <copumpkin> because I'm writing in objective c! :(
02:00:03 <Meady> Ah i found out now, i need to create a buffer to the text then retrieve it from that, quite simple really
02:00:04 <RyanT5000> aww :(
02:01:00 <copumpkin> what pain, what sorrow!
02:01:03 <copumpkin> oh woe, woe
02:01:36 <RyanT5000> Meady: just to be clear, that "aww" was directed at copumpkin :)
02:01:51 <Meady> Lol :d
02:01:59 <copumpkin> lol, we have (at least) three east-coasters up at 5 am
02:02:09 <RyanT5000> yeah, that's kinda funny :P
02:02:11 <Meady> Man im excited get my laptop today at 1pm, problem is, guy who i brought it off is 50/50 on wether it has dedi gpu
02:02:12 <mmorrow> copumpkin: i hope you've got some toothpicks laying around... you know, so you can shove them under your fingernails too :P
02:02:36 <copumpkin> mmorrow: I've actually had that happen unintentionally, wasn't fun :P
02:02:41 <RyanT5000> Meady: you should probably look up a Gtk+ tutorial, and then try searching the gtk2hs docs for the stuff to translate it
02:02:48 <mmorrow> copumpkin: oh wonderful
02:03:10 <copumpkin> it wasn't toothpicks though, it was flakes of peeling-off paint
02:03:18 <copumpkin> but definitely not pleasant
02:03:18 <mmorrow> lead paint i hope
02:03:20 <copumpkin> lol
02:03:23 <copumpkin> probably, it was in italy
02:03:24 <mmorrow> haha
02:03:34 <copumpkin> italians love their lead
02:03:41 <mmorrow> haha @lol, not "probably" ;)
02:03:54 <copumpkin> :P
02:04:09 <Meady> Ryan was just looking for a method im doing ok lol
02:04:23 <RyanT5000> k :)
02:04:40 <copumpkin> @localtime mmorrow
02:04:41 <RyanT5000> so... guys... is there a decent random oracle in hackage?
02:04:52 <lambdabot> Local time for mmorrow is Thu Jul  2 04:02:40
02:05:01 <RyanT5000> or, alternatively, any suggestions on implementing one?
02:05:03 <RyanT5000> it seems nontrivial
02:05:14 <copumpkin> :o
02:05:25 <copumpkin> I thought the point of oracles was to not implement them
02:06:00 <RyanT5000> copumpkin: well... perhaps i'm just looking for any random permutation :P
02:06:17 <copumpkin> of a list?
02:06:19 <RyanT5000> no
02:06:26 <RyanT5000> " Put another way, a random oracle is a mathematical function mapping every possible query to a random response from its output domain."
02:06:28 <RyanT5000> from wikipedia
02:06:31 <RyanT5000> that's what i'm looking for
02:06:40 <copumpkin> oh
02:06:45 <copumpkin> just pick a hash function
02:06:47 <RyanT5000> i want a function, e.g.: RandomGen g => g -> a -> b
02:06:55 <RyanT5000> obviously i need more constraints there
02:07:03 <copumpkin> hash functions are our practical oracles
02:07:07 <mmorrow> , fmap snd . sortBy (compare `on` fst) . zip (randoms (mkStdGen 2664332) :: [Int]) $ ['a'..'z']
02:07:07 <RyanT5000> well, yeah, a hash function would do
02:07:08 <lunabot>  "htcyriqkzlwodsvbengmupfjax"
02:07:19 <mmorrow> , fmap snd . sortBy (compare `on` fst) . zip (randoms (mkStdGen 876) :: [Int]) $ ['a'..'z']
02:07:21 <lunabot>  "chvkombgxiaplfsruyznejtwdq"
02:07:28 <RyanT5000> mmorrow: iirc, that's not actually a correct shuffle
02:07:42 <RyanT5000> (because of the chance of collisions?)
02:07:53 <copumpkin> when your crypto scheme's proof uses an oracle, you implement it with a cryptographic hash
02:08:00 <mmorrow> RyanT5000: it'd depend on your rng
02:08:09 <RyanT5000> copumpkin: right, so how do i type that properly in haskell?
02:08:10 <mmorrow> (but that method is rng-indep)
02:08:22 <RyanT5000> also, i'd like to be able to seed it - but i can just do that as a salt
02:08:40 <RyanT5000> i really want a super-cheap hash more than a cryptographically sound one
02:08:47 <RyanT5000> i guess i can find this on my own in hackage now, though
02:08:53 <copumpkin> RyanT5000: I'd map whatever types you need to send to it to a bytestring (prepend a constant seed if you want)
02:09:10 <copumpkin> then just grab sha256 or something and run your bytestring through it
02:09:19 <RyanT5000> copumpkin: *way* too expensive
02:09:23 <copumpkin> oh, what's this for?
02:09:27 <RyanT5000> this is just for random fractal terrain generation :P
02:09:30 <copumpkin> oh
02:09:54 <copumpkin> oracles are typically used in strong crypto, so you'd use a cryptographic hash
02:09:56 <mmorrow> ah yeah, did you ever try the elf hash for that? (istr this coming up before)
02:09:59 <copumpkin> otherwise just use a good PRNG
02:10:01 <copumpkin> with a seed
02:10:13 <RyanT5000> copumpkin: yeah, but i want it to be fractal
02:10:16 <RyanT5000> that's the tricky bit :)
02:10:21 <copumpkin> hmm
02:10:28 <mmorrow> what does that mean?
02:11:11 <RyanT5000> it means that if you "zoom in" by a factor of 2, you get the same value at (2x, 2y) as you would have gotten at (x, y) before
02:11:33 <mmorrow> is "2" special here?
02:11:37 <RyanT5000> yeah
02:11:43 <copumpkin> hrm
02:11:49 <Heffalump> surely anything has that property?
02:11:50 <Axman6> so (n x,n y) is not?
02:11:50 <RyanT5000> i'm not about to make a continuous fractal
02:11:55 <mmorrow> hmm
02:12:12 <RyanT5000> Axman6: perhaps for integer n
02:12:19 <mmorrow> i dunno what that would mean wrt the prng you use
02:12:25 <copumpkin> RyanT5000: if you just map a "continuous" value to a discrete one (unsafeCoerce *cough*) and use that as the seed for your PRNG
02:12:25 <mmorrow> (if anything?)
02:12:49 <copumpkin> RyanT5000: you'd probably want a fixed-point representation though
02:12:50 <RyanT5000> well, i want to generate an infinite expanse of terrain
02:12:57 <copumpkin> hm
02:13:07 <RyanT5000> so i need to be able to go "far" in O(1) time if possible
02:13:17 <mmorrow> there's gotta be an algo for this somewhere..
02:13:19 <RyanT5000> basically, i want to be able to specify a zoom level and rectangle
02:13:26 <RyanT5000> and get the same terrain
02:13:33 <RyanT5000> for any zoom level
02:13:42 <RyanT5000> i think i've basically got the algorithm figured out
02:13:49 <copumpkin> RyanT5000: so you really just want a pure function Int -> (Double, Double) -> Int ?
02:13:55 <copumpkin> where the first int is a seed
02:14:01 <RyanT5000> it's pretty easy to implement as a function of a random oracle with the "fractal" properties
02:14:01 <copumpkin> the second two are x and y, and the output is z?
02:14:21 <RyanT5000> copumpkin: well, i don't think double would be a good choice
02:14:31 <RyanT5000> copumpkin: since any error results in a complete change of output
02:14:35 <copumpkin> yeah
02:14:44 <copumpkin> the fixed-point thing I mentioned
02:14:50 <copumpkin> unless you want it to really be infinite
02:14:53 <edwardk> RyanT5000: just got back, saw part of that. you're looking for a way to get a terrain that works nicely regardless of projection?
02:15:11 <edwardk> or did i parse the bits i saw incorrectly
02:15:15 <RyanT5000> edwardk: for some value of "projection"
02:15:21 * mmorrow loves when he has two copies of a particular book, and then loses both of them
02:15:30 <RyanT5000> i'm trying to represent an infinite expanse of terrain
02:15:35 <RyanT5000> which can be rendered at any zoom level
02:15:40 <RyanT5000> with any level of detail
02:15:41 <edwardk> *nods*
02:15:48 <RyanT5000> so i figured i'd make a fractal random oracle
02:16:06 <RyanT5000> and then filter it
02:16:10 <edwardk> bad idea in a lot of ways. fractals have lots of lacunarity artifacts and alignment issues
02:16:27 <mmorrow> lacunabot?!
02:16:55 <RyanT5000> edwardk: i'm not sure we're thinking of the same "fractal"
02:16:57 <edwardk> one way to go is to look at Perlin noise as a basis. you can adjust lacunarity to break off from powers of 2, and its got pretty good tunability. and if you rotate layers you can break up any axis alignment as well
02:17:18 <RyanT5000> hm, yeah
02:17:28 <RyanT5000> perlin noise is definitely something to consider
02:17:35 <edwardk> and the nice thing is you can sample your noise function and tune its frequencies locally. a common terrain technique is to use the product of two perlin noise functions, that way you get smooth areas and jagged areas both
02:17:53 <edwardk> and it mixes things up a bit
02:18:26 <edwardk> the best part is of course that you can sample arbitrarily at any point and get smooth derivatives
02:18:29 <copumpkin> oh yeah, I remember playing with that in terragen a million years ago
02:18:33 <RyanT5000> hm
02:19:47 <edwardk> you can also then use the second 'variability' one to drive your terrain texture selector function, using some other common perlin clamping functions, etc. so you get areas of rock mixed with grassland, etc.
02:20:10 <edwardk> it has a really good power-to-weight ratio
02:20:51 <RyanT5000> hm
02:21:41 <edwardk> the biggest problem is of course the frequencies in the terrain are axis aligned, but you had that with your fractal to begin with. you can mitigate that by rotating child layers if its really a problem, but gamers these days are tuned not to notice these things, and you can really get away from it by rotating the two different perlin noise functions differently and using different lacunarities on them.
02:23:05 <edwardk> what i mean is that if you look at a slow undulation that is axis aligned it'd have period n, but if it was diagonal it'd have period (n sqrt 2) -- a common artifact of most fractal style terrain engines anyways
02:24:15 <edwardk> by lacunarity i mean the relative scale of the smaller random surfaces used by your perlin noise. normally you scale up or down by a power of 2. if you scale up by 1.7, say. then you break away from the rigid grid. if you sample the lower function slightly rotated then you break up the axis alignment of all of your frequencies
02:25:18 <edwardk> http://www.amazon.com/Introduction-Implicit-Surfaces-Kaufmann-Computer/dp/155860233X/ref=sr_1_1?ie=UTF8&s=books&qid=1246526692&sr=1-1 covered this kind of surface if I recall correctly.
02:26:07 <Meady> had no idea Haskell had a bindings set for SDL
02:26:29 <edwardk> meady: yeah but at last check there were issues getting them to run right out of cabal
02:26:33 <ivanm> you obviously didn't look through hackage well enough!
02:26:35 <edwardk> i don't recall exactly what
02:26:41 <Meady> what does $= mean
02:26:56 <Meady> http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
02:26:56 <edwardk> meady: its probably an assignment of a Data.Accessor style accessor
02:27:05 <Meady> Opengl doesnt look to different from pythons bindings
02:29:41 <edwardk> RyanT5000: i may have some perlin noise code lying around in haskell somewhere if you are interested I could see if i can dredge it up
02:30:15 <RyanT5000> edwardk: yeah; i just finished processing everything you said; i think that would be really useful
02:30:32 <edwardk> alright. i may have to hunt for it tonight though.
02:31:01 <edwardk> the version i banged out last time didn't have tunable rotation, but i did have variable lacunarity
02:31:40 <edwardk> I don't know that many other people ever bother to tune either, but I find it to be good practice ;)
02:31:58 <RyanT5000> edwardk: thanks :) if I end up using it, do you want me to package it up and stick on hackage?
02:32:17 <RyanT5000> edwardk: well, we'll actually have to tune things, i think :)
02:32:24 <RyanT5000> this actually impacts our gameplay
02:32:37 <edwardk> If it makes sense I might just do that myself when I drudge it up.
02:32:42 <RyanT5000> ok, cool
02:32:42 * copumpkin is really looking forward to playing this game
02:33:02 <RyanT5000> copumpkin: I hope hundreds of thousands of other people do, as well ;)
02:33:12 <RyanT5000> copumpkin: but i'm glad you are, as well :)
02:33:22 <copumpkin> copumpkin: I'll be sure to get you many customers :P
02:33:29 <RyanT5000> awesome
02:33:33 <RyanT5000> we'll also need beta testers
02:33:34 <copumpkin> lol
02:33:40 <RyanT5000> oh right
02:33:40 <copumpkin> not sure why I just spoke to myself
02:33:48 <RyanT5000> i get your joke now >.>
02:33:49 <edwardk> RyanT5000: My interest in your Haskell port has piqued as I'm starting to think about a little iphone game myself.
02:33:58 <copumpkin> RyanT5000: nope, I wasn't talking about pirates
02:34:05 <RyanT5000> copumpkin: ah, ok
02:34:06 <copumpkin> RyanT5000: in fact, I may be able to help protect against them :P
02:34:19 <RyanT5000> haha, so now you're selling to both sides; good play :)
02:34:30 <uzytkownik> @pl \s -> k >>= (\x -> return (x, s))
02:34:30 <lambdabot> (`fmap` k) . flip (,)
02:34:34 <copumpkin> RyanT5000: I don't support piracy in the least! the dev team as a whole has denounced it several times :)
02:34:41 <RyanT5000> that's fair
02:34:47 <copumpkin> RyanT5000: it just so happens that jailbreaks allow piracy (among other things)
02:35:02 <venomen> Looo! You are on mybrute and want to get a bear? Be my Pupil and get one GUERANTEED at Level4 experience at the game: http://lecktsmiamorsch.mybrute.com/ get my Pupil!
02:35:07 <copumpkin> we've debated locking the jailbreaks down more to hinder their efforts, but don't have enough manpower to do it
02:35:29 <Botje> venomen: good news! i'm going to get your account banned!
02:35:33 <RyanT5000> yeah; well, as someone trained in copyright (and other) law, i can't say i'm certain that intellectual property is worth the cost
02:36:03 <RyanT5000> at least, not for the upcoming century
02:36:21 <RyanT5000> anyway, let's not get into that right now
02:36:25 <RyanT5000> as it is, i won't be sleeping :P
02:36:34 <copumpkin> RyanT5000: either way, the mere fact that your app is in haskell will throw many of the pirates off if you even put the weakest copy protection scheme in, as anyone trying to disassemble it (who's used to the output of a regular c compiler) will want to shoot himself
02:36:47 <RyanT5000> hahaha
02:36:52 <copumpkin> I'm serious, it looks very different
02:36:55 <edwardk> speaking of sleeping. i'll catch you guys later while I proceed to do that for a couple of hours before I head into the office.
02:36:56 <RyanT5000> yeah, that makes sense
02:37:09 <RyanT5000> edwardk: alright; thanks for the advice :)
02:37:25 <edwardk> no problem. if there is one thing I'm never lacking in, its opinions ;)
02:37:44 <RyanT5000> haha
02:37:47 <copumpkin> RyanT5000: anyway, we can talk about it if you feel the need (and I'm definitely not "selling" either side, I'd help you for free like I do jailbreaks for free :P)
02:37:47 <RyanT5000> that's fine :)
02:38:40 <RyanT5000> copumpkin: i was kidding, but I certainly would appreciate that
02:38:54 <copumpkin> :)
02:45:05 <Cynner> New web browser based game, check it - http://www.lostworlds.lv/go.php?1139730844
02:45:13 <copumpkin> ugh
03:06:26 <Zao> copumpkin: I have a feeling that the output from the mangler is rather "interesting", technique-wise.
03:07:01 <Peaker> http://www.reddit.com/r/haskell/comments/8xkak/ask_haskell_is_supermonad_a_bad_idea/
03:08:32 <ivanm> tl;dr
03:08:32 <ivanm> ;-)
03:22:32 <Saizan> Peaker: tried it in practice?
03:23:07 <Saizan> Peaker: OverlappingInstances tend to be a pain if the class members are parametrized types
03:23:32 <Peaker> Saizan: I haven't.. yairchu is considering it
03:24:18 <yairchu> Saizan: tried it. it works
03:24:29 <Saizan> that it works i'm sure
03:24:55 <Saizan> but it's easy to get annoying contexts you can't easily satisfy due to polymorphism
03:25:58 <Saizan> not so easy to spot them early though :)
03:26:46 <yairchu> if "get" and "put" were for StateT and not for MonadState, it would had been much better for this.
03:27:43 <Saizan> so you use lifts on the operations or write a MonadState instance using them?
03:28:07 <Saizan> (btw, you can have MonadState instances not using StateT or State)
03:28:33 <yairchu> I use lifts on the operations
03:28:41 <lilac> Peaker: if it works reliably, that sounds pragmatically to be a Good Thing
03:28:52 <Peaker> Saizan: i.e: MonadState is useful beyond auto-lifting
03:29:07 <yairchu> Peaker: what for? alternative implementations?
03:29:24 <Peaker> yairchu: If your monad happens to be able to do what State/StateT do, I guess
03:29:32 <BONUS> if it carries notions of state
03:29:49 <Saizan> e.g. ReaderT (IORef s) IO
03:30:04 <HugoDaniel> hi
03:30:16 <yairchu> hmm. good point
03:30:37 <yairchu> so at least making MonadState not auto-lift will be nice for SuperMonad
03:30:47 <Saizan> (which is a type useful for callbacks)
03:31:07 <Peaker> I dislike lifting based on monad-type in both MonadState and Super monad, though
03:32:45 <Peaker> I like:  newtype MyMonadT m a = MyMonadT { runMyMonadT :: StateT GameState (ReaderT Fonts (StateT something_else m)) a } ; gameState = MyMonadT ; fonts = MyMonadT . lift ; something_else = MyMonadT . lift . lift
03:32:54 <Peaker> gameState . modify $ (+1)
03:33:11 <Peaker> f <- fonts $ getDefaultFont
03:34:26 <Peaker> auto-lifting of IO is fine because its always unambiguous :-)
03:34:37 <fasta> What are the actual costs of monad transformers, btw? Oleg once made a remark about that, but it was never rebutted, AFAIK.
03:36:39 <Peaker> yairchu: In our example, we needed the producer to jump through an arbitrary amount of ConsumerT's, right?
03:36:50 <Peaker> yairchu: We could have a type-class just for that,  liftC (lift beyond consumerT)
03:37:53 <Saizan> fasta: did he quantify?
03:38:11 <Peaker> yairchu: then instead of MonadIO and liftIO in our int/strProducers, we can have  MonadConsumer and liftC to get to the MyMonadT, and then use myMonadT lifters
03:38:19 <yairchu> Peaker: izip lifts through two ConsumerT and a MaybeT
03:38:42 <Saizan> i'm sure there's an overhead, but i've never seen any extensive benchmark
03:39:10 <Toxaris> afaik there are two problems with monad transformers: mtl is not very optimized (so inline mtl stuff, compile with -O2 => higher performance); and mtl does use data structures instead of CPS (so extra costs for pattern matches)
03:39:27 <fasta> Saizan: he was basically saying that in parts of programs that don't use a certain effect in Haskell, you do pay the monad transformer tax, while in OCaml this was not the case. So, he didn't really have numbers, but from my experience there is a real overhead. I removed a WriterT layer once, because it slowed down things noticeably.
03:39:31 <Peaker> yairchu: Hmm.. then maybe a MyMonad class like a MonadState/etc, but only needs an instance for MyMonad and anything else
03:40:09 <Peaker> can't pattern-matches be auto-compiled into CPS? Why is CPS "faster" than pattern matches?
03:40:20 <fasta> Most programs never enter the "optimization" stage, though.
03:40:34 <fasta> And I guess certainly most functional programs.
03:41:04 <Saizan> fasta: yeah, that's known, edwardk wrote monad-ran on hackage that addresses some of that
03:41:33 <Saizan> Peaker: the pattern match is avoided altogether by using a CPS monad, it's not just transformed to CPS
03:41:46 <Peaker> Saizan: example?
03:41:51 <RyanT5000> > sum $ map Data.Digest.Adler32.adler32 $ replicate 1000000 [fromIntegral 0 :: Word8]
03:41:53 <lambdabot>   Not in scope: `Data.Digest.Adler32.adler32'
03:42:18 <Peaker> fasta: what's the OCaml alternative to monad transformers?
03:42:35 <Saizan> Peaker: do you know how ContT's >>= work?
03:42:49 <fasta> Peaker: hmm, I guess OCaml is irrelevant. The IO monad would also work.
03:42:51 <Peaker> Saizan: I haven't implemented ContT, just Cont, and I can presume how it works
03:42:53 <Saizan> Peaker: side-effects and control operators
03:43:08 <RyanT5000> > sum $ map length $ replicate 1000000 [fromIntegral 0 :: Word8]
03:43:10 <lambdabot>   * Exception: stack overflow
03:43:11 <Peaker> Saizan: that's not really as powerful as monad transformers, though
03:43:18 <RyanT5000> why does that cause a stack overflow?
03:43:30 <Saizan> because sum is silly
03:43:33 <fasta> Peaker: powerful is not an argument.
03:43:40 <RyanT5000> Saizan: that's pretty silly
03:43:43 <Peaker> fasta: why not?
03:43:46 <Peaker> @src sum
03:43:46 <lambdabot> sum = foldl (+) 0
03:43:54 <Peaker> really?
03:43:56 <fasta> Peaker: it has no meaning.
03:43:57 <Saizan> > foldl' (+) 0 $ map length $ replicate 1000000 [fromIntegral 0 :: Word8]
03:43:58 <lambdabot>   1000000
03:44:13 <Peaker> fasta: the meaning is that you can mix&match language features by adding monad transformers
03:44:19 <RyanT5000> @where foldl'
03:44:19 <lambdabot> I know nothing about foldl'.
03:44:24 <Peaker> fasta: add new control operations/etc to your language
03:44:28 <Saizan> @index foldl'
03:44:28 <lambdabot> Data.List
03:44:36 <fasta> Peaker: you can do the same without monad transformers.
03:44:47 <Peaker> fasta: how?
03:44:52 <Peaker> fasta: macros?
03:45:06 <fasta> Peaker: for example
03:45:06 <Saizan> fasta: you can't really control which effects are allowed though
03:45:19 <Peaker> fasta: macros suck ;-)
03:45:37 <fasta> Saizan: sure you can. You can just write a traversal which checks which effects there are.
03:46:10 <Saizan> fasta: traversal of what?
03:46:24 <fasta> 'Powerful' in the context of programming languages means nothing. Arguing that Haskell + ideal IDE is better than Haskell + Emacs is something you can do however.
03:46:27 <fasta> Saizan: AST.
03:47:02 <Saizan> fasta: ah, ok, you're suggesting a completely different "type system"
03:47:19 <Saizan> s/completely//
03:48:40 <fasta> If power is how low the barrier is to change random parts of the stuff at will, then Haskell is not all that powerful.
03:49:13 <fasta> Oh, well, maybe with all the extensions it is.
03:50:48 <Peaker> fasta: The power to control the DSL in which you write the language, both in your ability to extend it and in the ability to limit it
03:51:04 <Saizan> Peaker: however, back to "CPS avoids pattern matching" suppose you've Maybe, to fmap f into a Maybe a you've to pattern match on the value, if you instead use forall o. (a -> o) -> o -> o you can just compose f with the first argument
03:51:36 <Peaker> fasta: With macros I guess you can just reimplement Haskell and a type-system, sort of -- so maybe on top of macros you could also have that power.  macros don't directly give you what Monad Transformers do, however
03:52:01 <Peaker> @type maybe
03:52:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:52:04 <fasta> Anyway, I stop arguing about power :)
03:52:25 <Peaker> Saizan: but can't ADT's be compiled into their catamorphism in general?
03:52:40 <Peaker> Saizan: or at least, when some pragma is present? :)
03:55:46 <Saizan> Peaker: you lose sharing
04:23:56 <Peaker> Saizan: one of these days I'm going to have to write a compiler just so I understand these issues at depth
04:33:05 <saml>  symbol lookup error: librtaudio_c.so: undefined symbol: _ZN7RtAudioC1ENS_3ApiE
04:35:16 <saml> do I need to pass ghci something that it is not C, but C wrapper to C++?
04:46:36 <uzytkownik> @hoogle Handle -> IO String
04:46:36 <lambdabot> System.IO hGetContents :: Handle -> IO String
04:46:36 <lambdabot> System.IO hGetLine :: Handle -> IO String
04:46:36 <lambdabot> System.IO hShow :: Handle -> IO String
04:46:57 <uzytkownik> @hoogle Handle -> (String -> String) -> IO ()
04:46:57 <lambdabot> No results found
04:48:07 <uzytkownik> @hoogle interact
04:48:07 <lambdabot> Prelude interact :: (String -> String) -> IO ()
04:48:07 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
04:48:07 <lambdabot> System.IO interact :: (String -> String) -> IO ()
04:50:57 <Cale> dmwit: btw, pow Z Z = S Z  ;)
04:51:04 <uzytkownik> @hoogle IO a -> a
04:51:04 <lambdabot> Foreign unsafePerformIO :: IO a -> a
04:51:04 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
04:51:04 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
04:51:05 <ivanm> hey Cale
04:51:19 <Cale> hey ivanm
04:51:24 <ivanm> "pow Z Z" <-- are you punching Z twice? ;-)
04:51:55 <Twey> Heh
04:51:59 <Twey> pow pow Z
04:52:13 <ivanm> double-punch?
04:52:20 <ivanm> special bonus move?
04:52:21 <ivanm> ;-)
04:52:27 <ivanm> Cale: want to work on graph stuff?
04:52:31 <Cale> dmwit implemented the power function for naturals in a reddit comment, and he explicitly set that case to undefined, even though there's no good reason (especially for Nat!) for it not to be 1
04:53:02 <Philonous> Is there a way to get around the boilerplate when updating fields of a record? Having to build a function for each and every field per hand seems very un-haskellish
04:53:21 <ivanm> ummm..... 6.10 has views or something IIRC
04:53:24 <Cale> Philonous: there's record update syntax
04:53:34 <Twey> There's also Data.Accessor
04:53:55 <Cale> myRecord { field = newValue }
04:54:17 <ivanm> Cale: I think Philonous wants to have seperate updater functions for composition
04:54:26 <ivanm> by having updateField or something
04:54:33 <Twey> Data.Accessor then
04:54:42 <Philonous> Cale, yes, but you still can't write a function that takes a record, an accessor and a new value and return the record updated with the new val at the given position
04:55:37 <paolino> oleg's records
04:56:12 <Philonous> Twey, thanks, that sounds promising
04:56:50 <ivanm> Cale: want to work on graph stuff?
04:57:14 <Cale> ivanm: well, I'm pretty tired, not having slept, but I suppose I could :)
04:57:22 <ivanm> heh
04:57:31 <ivanm> any particular reason for not sleeping?
04:57:40 <Heffalump> Philonous: the data-accessor package has TH to do it for you
04:58:00 <Cale> Well, this isn't much later than I went to bed the night before, to be honest.
04:58:28 <ivanm> :o
04:58:30 <ivanm> @time Cale
04:58:31 <lambdabot> Local time for Cale is Thu Jul  2 07:58:30
04:58:39 <Dae> :o
04:58:43 <ivanm> that's about the time I get _out_ of bed!
04:58:56 <Heffalump> I used to do that occasionally when I was a student
04:59:11 <Heffalump> these days my normally getting up time is 5:30am :-(
04:59:28 <ivanm> Heffalump: I've very rarely done all nighters (and I was a student until the end of last year)!
04:59:36 <ivanm> Heffalump: long commute? :s
04:59:38 <etpace_> Is there a way I can check that a list has a number that is >= 3 and another number that is >= 2 without explicit recursion?
04:59:43 <Heffalump> ivanm: yeah
05:00:00 <cgizmo> hi
05:00:13 <Zao> etpace_: Are duplicates allowed?
05:00:18 <cgizmo> is anyone here familiar with emacs' haskell-mode ?
05:00:27 <etpace_> Yes, so [3,3,1] would pass the test
05:00:37 <Heffalump> etpace_: length (filter (>=3) list) >= 1 && length (filter (>=2) list) >= 2
05:00:39 <Zao> etpace_: Sort it descending, pick the first two?
05:00:41 <Cale> etpace_: mm... there would be if only there was a particularly handy function in Data.List which isn't there
05:00:56 <Cale> oh, of course you could do that :)
05:01:04 <ivanm> cgizmo: vaguely (as in I use it)
05:01:25 <ivanm> Cale: is your gobby host up?
05:01:42 <cgizmo> ivanm: did you manage to get the haskell-ghci mode work ?
05:01:51 <ivanm> yes
05:02:02 <ivanm> is this with ghc-6.10.{1,2} ?
05:02:18 <etpace_> thanks
05:02:18 <Cale> a better way, I think, is to write the function  select :: [a] -> [(a,[a])]; select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
05:02:24 <cgizmo> it's with GHC 6.10.2
05:02:39 <cgizmo> my emacs tells me that haskell-ghci is obsolete
05:02:46 <ivanm> :o
05:03:12 <ivanm> that's a different problem...
05:03:18 <Cale> that'll give you the elements of the list conveniently paired with the remainder of the list
05:03:23 <cgizmo> i asked the guys at #emacs
05:03:29 <cgizmo> well they told me to go here
05:03:37 <ivanm> cgizmo: do you explicitly set it?
05:03:42 <Philonous> TH = lisp macros for haskell?
05:03:58 <cgizmo> ivanm: i autoload it in my .emacs
05:04:00 <ivanm> it's called inferior haskell or something...
05:04:01 <Zao> lithp?
05:04:29 <Heffalump> Cale: and then what?
05:04:36 <cgizmo> but it doesn't even show up if I do M-x turn-on-haskell-ghci
05:04:41 <cgizmo> it's pretty weird
05:04:46 <ivanm> cgizmo: which version of haskell-mode?
05:04:47 <ivanm> 2.4?
05:05:13 <Cale> null (do (x,ys) <- select xs; guard (x >= 2); (y,zs) <- select ys; guard (y >= 3))
05:05:15 <cgizmo> yes
05:05:31 <Cale> er, hmm
05:05:41 <ivanm> cgizmo: there's a site file in it IIRC... it sets most of what you want/need without having to do anything
05:05:42 <Heffalump> oh, so backtrack
05:05:43 <Cale> the conditions should go the other way
05:05:44 <Heffalump> nasty
05:06:21 <ivanm> cgizmo: (load "/usr/share/emacs/site-lisp/haskell-mode/haskell-site-file" nil t) ; fix the path up
05:06:28 <ivanm> that's pretty much all I have
05:06:41 <ivanm> Cale: is your gobby host up?
05:06:47 <cgizmo> ivanm: so I should use this instead of the 10 lines that load all the modules ?
05:06:50 <Cale> ivanm: I can bring it up
05:06:58 <ivanm> cgizmo: yeah
05:07:04 <cgizmo> ok, i'll try
05:07:32 <Cale> (because if the x which is selected is larger it could be problematic)
05:07:41 <ivanm> though you'll soon come across another error when using emacs with editline'd ghci :s
05:07:59 <ivanm> Cale: well, bit hard to discuss files, etc. without it ;-)
05:08:40 <Heffalump> Cale: it's still a problem, because you insist on the >=2 element being after the >=3 element then
05:08:54 <Cale> Heffalump: hm?
05:09:05 <Cale> Heffalump: no, only different from it
05:10:11 <Cale> It'll work either way
05:10:15 * EvilTerran toys with generalized monads etc
05:10:37 <cgizmo> ivanm: doesn't work, but it's probably because I use the CVS version of emacs
05:10:41 <cgizmo> thanks anyways
05:10:49 <EvilTerran> (class Functor (~>) where fmap :: (x -> y) -> (a ~> b) x -> (a ~> b) y, and so on)
05:10:55 <ivanm> cgizmo: so do I ;-)
05:11:02 * RayNbow wonders if Cale ever sleeps
05:11:07 <Cale> But if the first >=2 element is the only thing which is >=3, then picking that first would mean going through the whole thing
05:11:15 <EvilTerran> (app :: Applicative (~>) => (a ~> b) (x -> y) -> (b ~> c) x -> (a ~> c) y -- illustrates the point better)
05:11:40 <ivanm> Cale: are you going to bring it up? or leave it for another time?
05:11:54 <Cale> ivanm: there we are
05:12:20 <cgizmo> ivanm: must be some problem with my distribution's package...
05:12:21 * EvilTerran wonders if that use of type operators counts as evil
05:12:25 <cgizmo> too bad
05:12:30 <cgizmo> bye
05:14:51 <Heffalump> Cale: no, it won't work on [2,3]
05:15:03 <Cale> Heffalump: why not?
05:15:12 <Heffalump> oh, it's not just the tails that are returned by select, sorry
05:15:25 * Heffalump was confused
05:15:41 <tomlok> :q
05:17:23 <EvilTerran> tomlok, i don't think this is vim
05:17:44 <tomlok> yeah, wrong window :)
05:18:08 <hesselink> :r doesn't work here, either. Believe me, I've tried
05:18:39 <portnov> but :t works :)
05:22:18 <^anty^> How do I embed resources like icons on linux? I managed to do this on Windows with windres, but how do I do this for linux binaries?
05:23:51 <WorkyBob> where does one find a Monoid instance for IArrays?
05:25:18 <EvilTerran> WorkyBob, what would you want it to do exactly?
05:25:57 <WorkyBob> EvilTerran: concatonate them, with the indicies of the right hand one starting from the maximum index of the left hand one + 1
05:25:59 <ivanm> WorkyBob: you mean for Array ?
05:26:14 <WorkyBob> ivanm: plausable
05:26:14 <ivanm> IArray has a limit on what values it can have IIRC, so Monoid wouldn't work
05:26:34 <EvilTerran> WorkyBob, wouldn't that be pretty inefficient?
05:26:44 <EvilTerran> sounds like Seq may suit your purposes later - that's ideal for concatenation
05:26:45 <WorkyBob> EvilTerran: plausable -- doesn't stop it being useful
05:26:53 <EvilTerran> s/later/better/ weird typo...
05:26:58 <WorkyBob> yes, but it's not ideal for putting on a graphics card
05:27:03 <EvilTerran> ahhh
05:30:50 <WorkyBob> slightly unfortunate, I think that even with the knowledge that I have two 0 based arrays with contiguous values, the best I can do is still stick them in a list, mappend the lists and convert back to an array
05:37:40 <lilac> WorkyBob: I think DPH's PArrays might be able to do that
05:39:53 <ivanm> WorkyBob: IIRC, hmatrix does that for a lot of its matrix operations... still works reasonably well
05:40:12 <ivanm> I think the problem with a general instance is that you can't guarantee the indexing
05:40:14 <ivanm> or the index type
05:44:52 <WorkyBob> ivanm: *nod*
05:45:09 <ivanm> maybe if you newtype it?
05:46:14 <Philonous> Template haskell seems pretty cool. Is it bad style to use it? It would be pretty nifty for ad-hoc typeclasses
05:46:36 <ivanm> slow to build
05:46:47 <ivanm> since it basically interprets the code IIRC
05:46:55 <ivanm> and can thus chew up a lot of memory as well
05:47:09 <ivanm> (unless you use zeroth or something to strip out TH before packaging it)
05:47:55 <quicksilver> well, uses of TH are generally pretty modest
05:48:01 <quicksilver> and therefore not really that slow.
05:48:44 <ivanm> quicksilver: highlighting-kate is _awful_
05:49:07 <quicksilver> eh?
05:49:17 <quicksilver> well presumably that does a lot of work in TH :)
05:49:18 <LeoD> are there any examples to get SDL+OpenGL running with haskell?
05:51:24 <Philonous> Maybe one could devise a two-stage aproach: Build a code generator an than build the generated code.
05:52:07 <ivanm> quicksilver: _heaps_ of work
05:52:19 <ivanm> pre-processing files and converting them into haskell AFAICT
05:52:26 <ivanm> (which could really be done before packaging...)
05:52:39 <paolino> funny that google didn't match any document with "Data.Accessor HList"
05:52:46 <EvilTerran> if all your TH is defined in its own module, surely it could be compiled separately prior to working out splices
05:53:57 <paolino> is it just me or they share something , Data.Accessor and HList ?
05:54:26 <quicksilver> they're both about product types, yes.
05:54:31 <Philonous> Just extract it from the source, no need to put it into it's own module
05:54:35 <quicksilver> and there is some record stuff built on hlist iirc.
05:55:21 <paolino> I was looking for performance differences, but nothing appeared
05:55:37 <quicksilver> I don't think they are closely comparable enough to compare performance.
05:56:20 <paolino> uh, they have an almost same interface, at least
05:56:26 <paolino> and semantic
05:56:44 <paolino> looks the same
05:57:11 <quicksilver> I think quite a few people use Data.Accessor and nobody uses HList
05:57:19 <quicksilver> on that basis, I would use Data.Accessor
05:57:22 <saml> stateref-0.2.1.1: Abstraction for things that work like IORef.   HList-0.1: Heterogeneous lists
05:57:34 <quicksilver> HList is more about polymorphism, really.
05:57:41 <quicksilver> Data.Accessor isn't at all abot polymorphism.
05:57:51 <paolino> HList works very nice in my experience
05:58:11 <quicksilver> I personally view HList as more of a collection of tricks / ideas / experiments which demonstrate what you can do with GHC
05:58:18 <quicksilver> rather than a practical library.
05:58:27 <quicksilver> After all, it enabled extensions which ruin the language.
05:58:35 <paolino> ah
05:59:02 <quicksilver> I would think very hard before using a library which used incoherentinstances.
05:59:13 <quicksilver> And I don't really like overlapping instances either
05:59:18 <quicksilver> (although I do occasionally use the mtl)
05:59:48 <paolino> I cannot think big state, pluginned software without them, but it's just my opinion :)
06:01:32 <paolino> I tend to make fall in that class almost everything, which is probably wrong
06:01:53 <quicksilver> you mean overlapping or incoherent?
06:01:56 <quicksilver> I assume you mean overlapping.
06:02:08 <quicksilver> Still, I wouldn't use overlapping instances to implement plugins.
06:03:03 <saml> in OOP, I write interfaces and write classes..  how do you start programming in haskell?  class first then make custom monad that is instance of the class?
06:03:08 <paolino> uhm, I cannot look it from that height really
06:04:27 <Zao> saml: You could start by defining suitable data structures then write code that acts on those (similiar to OOP).
06:04:32 <paolino> quicksilver: but I suppose that is the point, how make extensible state for plugins
06:04:41 <Zao> saml: Or write functions first to find out what data structures you need to support them.
06:04:47 <Zao> saml: Or both. Or none.
06:04:49 <quicksilver> paolino: polymorphism.
06:04:52 <quicksilver> Plugin s
06:04:56 <quicksilver> paolino: 's' is the state type
06:05:03 <quicksilver> the host app doesn't need to know what it is.
06:05:07 <saml> Zao, oh that makes sense. thanks
06:05:29 * edwardk waves hello.
06:05:30 <Gracenotes_> rarely do you need to create typeclasses, or make monad instances
06:05:57 <Zao> saml: You should get pretty far with just data declarations and a whole lot of "free functions".
06:06:06 <edwardk> I define a lot more typeclasses than i do monads anyways =)
06:06:29 <Zao> A decent approach would probably be "how you would write C code if you didn't have mutable variables"
06:06:36 <edwardk> If only because every time I have to define a monad I am defining a typeclass, so that inequality holds trivially. ;)
06:11:23 <edwardk> hrmm is there any GIS stuff for haskell other than http://lucc.ess.inpe.br/doku.php?id=terrahs ?
06:22:57 <edwardk> The Funct typeclass in http://hackage.haskell.org/packages/archive/terrahs/0.5/doc/html/Algebras-Functor-Category.html weirds me out
06:23:37 <wpearson> Is there a more modern/in print equivalent of "The Implementation of Functional Programming Languages"?
06:24:08 <edwardk> wpearson the old SPJ book?
06:24:27 <wpearson> Yup. I know it is on-line, but I'd prefer a dead tree copy.
06:24:31 <edwardk> wpearson: that was last published in like 1987. he put a copy of it online, but thats it
06:25:13 <wpearson> Or a book that covers similar material.
06:26:20 <earthy> http://www.amazon.com/Functional-Programming-Parallel-Rewriting-International/dp/0201416638 is only a tad newer and describes much underlying the Clean compilers..
06:26:34 <edwardk> hrmm. i can't think of anything that covers the whole implementation of a lazy functional language like that book did. TaPL is as close as I can come up with on short notice, but its more oriented towards an ML-like setting
06:27:07 <edwardk> ooh, thats one I don't have
06:27:12 <earthy> I think you'd be hard pressed finding anything quite as complete as SPJ's book
06:27:13 <RayNbow> hmm, TaPL... I still have to finish that book...
06:27:44 <earthy> ofcouse, you *could* ask Atze Dijkstra for his PhD thesis. http://www.cs.uu.nl/wiki/Atze/WebHome
06:27:50 <earthy> that describes the EHC compiler...
06:27:56 <earthy> and is quite recent.
06:28:21 <wpearson> Thanks all.
06:28:34 <edwardk> Well, if you broaden the scope to implementation papers/theses then Robert Ennals' thesis is probably my favorite =)
06:28:54 * EvilTerran liked TaPL
06:29:20 <Plouj> It seems that haskell isn't widely used for 3d/OpenGL applications. Can someone show me otherwise? Libraries seem to be deserted and I don't know of many 3d applications.
06:29:26 <edwardk> TaPL rewired large portions of my brain
06:29:42 <Plouj> Is Haskell not practically suitable for 3d application programming?
06:29:42 <earthy> libraries deserted?
06:29:45 <EvilTerran> Plouj, well, there's frag...
06:29:49 <earthy> wha?
06:29:51 <RayNbow> the problem with TaPL is... it's not suitable for reading in bed :p
06:29:53 <Plouj> EvilTerran: yeah, please :)
06:30:00 <earthy> there's HOpenGL, which basically is all you need...
06:30:01 <edwardk> Plouj: its not widely used but there are 2-3 3d engines that are written in haskell. frag was an frp game in haskell, there is lambdacube and something else
06:30:08 <Zao> Plouj: Depends on what libraries you're referring to.
06:30:09 <luite> RayNbow: why not?
06:30:11 <EvilTerran> there's that reactive 3d graphics doodad
06:30:18 <kynky> dont see why opengl api should be harder than any other in haskell
06:30:20 <Zao> Plouj: I'm rather happy with just GLFW and OpenGL.
06:30:22 <earthy> isn't kosmikus doing some game with opengl graphics?
06:30:26 <edwardk> HOpenGL works, there are SDL bindings (though they have trouble installing directly from hackage)
06:30:33 <Plouj> Zao: what's GLFW?
06:30:52 <Zao> Plouj: It's like GLUT, but works :)
06:30:54 <RayNbow> luite: heavy to hold... not an easy read... and you often tend to get sleepy quite quickly when you're lying in bed :p
06:30:58 <edwardk> You have basically everything you need to get going with OpenGL in Haskell these days, especially since the advent of the Haskell Platform project
06:31:16 <RayNbow> although I did manage to read several TaPL chapters while in bed
06:31:34 <Zao> http://www.acc.umu.se/~zao/Hastris/ <- I made that with just GLUT, OpenGL and some custom texture code.
06:31:37 <luite> RayNbow: I've been looking for an ebook version for a while, that should at least fix the heavy part :p
06:31:46 <earthy> http://www.haskell.org/haskellwiki/GLFW
06:31:57 <Cale> Plouj: It's not that there's anything about Haskell which makes it unsuited to 3D applications. It's that most Haskell users are too picky about APIs to enjoy using OpenGL directly, and there's only been a little bit of work put into wrappers around it so far.
06:33:02 <Plouj> well
06:33:12 <Plouj> if I was writing an OpenGL program, I'd use SDL
06:33:27 <Plouj> but apparently that's got problems in Haskell
06:33:37 <Zao> Plouj: For what? Windowing and input?
06:33:50 <EvilTerran> our opengl API isn't sucky compared to anyone else's opengl API, it's just sucky compared to other APIs haskellers are used to ;)
06:33:57 <Peaker> Plouj: its got problems with OSX.  Probably better to use GLUT
06:34:01 <edwardk> My biggest problem is there are little corners where OpenGL bindings does wrap the underlying abstraction in ways that causes it to perform poorly for me. =)
06:34:03 <Plouj> Zao: for example, GLUT has it's mainloop thing and I don't want that.
06:34:12 <Peaker> EvilTerran: It also segfaults and stuff :(
06:34:14 <saml> Zao, nice. everything is in Haskell?
06:34:27 <Peaker> EvilTerran: forget to call init -- segfault, various other stuff too. :(
06:34:29 <Plouj> I don't think anyone these days would pick GLUT if they were writing a game in C/C++.
06:34:36 <EvilTerran> Peaker, that's unfortunate
06:34:41 <Zao> saml: Aye.
06:34:53 <Peaker> Plouj: I wrote something with SDL, and my OS X friend says it just doesn't work on OSX. GLUT does work
06:35:08 <Peaker> EvilTerran: I don't know if the segfaults are true in other bindings for GLUT (E.g Python)
06:35:27 <Zao> http://www.acc.umu.se/~zao/Hastris/trunk/
06:35:39 <Zao> Make sure you shade your eyes first, it's beginner-level Haskell code.
06:35:58 <EvilTerran> Peaker, regardless, any such things should be protected against in haskell. we've got a shiney type system, we might as well make the most of it
06:35:59 <edwardk> Graphics.Rendering.OpenGL.GL.Shaders comes to mind as an example where the library gets particularly invasive
06:36:49 <Peaker> EvilTerran: yeah, to guarantee Init you could have a token that has to be passed as an argument for something to work, and withGLUT $ \token -> ... could pass it only into the function that is in init context
06:37:02 <Peaker> EvilTerran: or something like the ST trick
06:37:10 <EvilTerran> yeah, quite
06:37:30 <edwardk> setAttachedShaders works as long as you have the same usage pattern as the author, but there are a lot of times when you are manipulating shaders that you don't want to be diffing lists, etc just to attach a shader
06:37:57 <fasta> In ghci, in the context Prelude Foo> how can you reload Foo, s.t. all bindings are available, not just those that are exported without resaving the file? I tried :l Foo (which used to work) and :r.
06:38:18 <edwardk> and shaders are a fairly common use case in modern OpenGL code
06:38:49 <nvoorhies> all non-shader stuff is deprecated in the newest versions
06:39:03 <Saizan> fasta: rm the .hi
06:39:36 <fasta> Saizan: I then consider this a bug in ghci.
06:39:47 <Plouj> nvoorhies: really "all"?
06:39:58 <kig> Plouj: yes
06:40:02 <SamB> fasta: did you try anything involving a *?
06:40:22 <nvoorhies> In GL 3.1 all the fixed function stuff got removed from core opengl if I remember right
06:40:25 <edwardk> plouj: its hard to find an area of classic opengl that isn't deprecated under the abortion that was put out by Khronos
06:40:26 <Plouj> another, sort-of related problem, is that if I want to learn OpenGL, I have to write/read C/C++ tutorials/books
06:40:27 <kig> Plouj: well, the fixed-function pipeline is deprecated, so you need shaders to draw anything
06:40:37 <fasta> SamB: no, but now you say it, I seem to recall that they changed the behaviour and that * was made special.
06:41:07 <nvoorhies> Which makes sense since there's no actual hardware corresponding to the fixed function pipeline.  You just give the drivers the job of writing a shader for you.
06:41:15 <gwern> 'I haven't seen any real complaints...' 'I'll complain. I'm still not convinced that we need a name for (>> return ()).' <-- dammit, I should've known someone would see that as a dare
06:41:26 <Botje> :)
06:41:54 <djahandarie> Hey all, for some reason http://darcs.haskell.org/http/test/get.hs doesn't compile (with the latest package). First it says `ConnError' isn't defined, then when I add import Network.Stream, it says `Request' is not applied to enough type arguments.
06:41:56 <edwardk> gwern: I'm down with ignore, but I think patching void is a bit of a stretch. ;)
06:42:03 <fasta> gwern: I thought you already had a name, ignore.
06:42:24 <gwern> fasta: yeah, but turns out the FFI standard specifies a very similar function
06:42:26 <jmcarthur_work> discard!
06:42:33 <fasta> gwern: it does?
06:42:40 <fasta> gwern: which one?
06:42:44 <gwern> @hoogle void
06:42:44 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
06:42:47 <edwardk> fasta: void :: IO a -> IO () in Foreign.Marshall.Error
06:42:59 <edwardk> hah beaten by someone using the tools ;)
06:43:14 <gwern> tools ftw
06:43:32 <fasta> I think void is a bad name for that. I define void = return ()
06:43:53 <fasta> And ignore is better than what void apparently is now.
06:44:13 <edwardk> yeah
06:44:47 <edwardk> plus the Data.Void proposals like the name void for void :: Void -> a -- or similar =)
06:44:51 <gwern> fasta: well, one possibility is to define C.M.ignore and then just set F.M.E.void = ignore
06:45:28 <jmcarthur_work> my ideal: void :: Monad m :: m () ; discard :: Monad m => m a -> m ()
06:45:40 <jmcarthur_work> not FFI compatible though
06:45:45 <fasta> Discussing this is also quite pointless. If you want to change what old code does, write a source-to-source code transformation. For new code, just put it on hackage with a small bit of marketing.
06:46:13 <edwardk> Changing the type of void is somewhat annoying because its specified right in the FFI 1.0 addendum to the Haskell 98 report with its signature
06:46:15 <gwern> jmcarthur_work: you'd leave the type sig in F.M.E alone
06:46:30 <gwern> which would narrow it to the report-specified type
06:46:40 <jmcarthur_work> gwern, right. my *ideal* is not realistic ;)
06:47:11 <gwern> the point of that would be to reduce code duplication; and while you're at it, you could mention in the docs that you should be using C.M.ignore
06:47:25 <Woof> </3 gwern
06:48:06 <jmcarthur_work> i like Foreign.Marshall.Error.void = ignore, for the record, or s/ignore/discard/
06:48:33 <jmcarthur_work> where void keeps its signature, of course
06:49:27 <quicksilver> I like 'skip' for 'return ()'
06:49:30 <quicksilver> yay for bikesheds.
06:49:38 <fasta> Red!
06:49:51 <edwardk> Blue!
06:49:54 <fasta> Skip gets Dijkstra points.
06:50:05 <jmcarthur_work> "ignore" really makes me think that it should be defined ignore = const (return ())
06:50:20 <edwardk> fasta: sure, but he's not around to distribute them any more
06:50:31 <fasta> Maybe we should also change guards to non-deterministic guards.
06:50:42 <Cale> Rather than having lots of names for (>> return ()) how about we just agree that when a function takes an IO action and doesn't care about the type of its result, it should be polymorphic?
06:50:43 <fasta> (that last one was a joke)
06:51:06 <Cale> The only reason people end up needing that so much is because of other badly-typed things.
06:51:11 <Cale> :t forkIO
06:51:12 <lambdabot> Not in scope: `forkIO'
06:51:14 <edwardk> fasta: I have actually always like the idea of non-deterministic guards in a perverse way
06:51:19 <Cale> :t Control.Concurrent.forkIO
06:51:20 <fasta> Cale: yep, that's the actual problem.
06:51:20 <ville> quicksilver: your brain will break if you try to understand some C++ nuance and think about Haskell at the same time.
06:51:20 <lambdabot> IO () -> IO GHC.Conc.ThreadId
06:51:26 <Cale> So fix ^^ that
06:51:54 <edwardk> it means you can read any line of a definition in any order and they are all real equalities. fall through guards are dangerous. (although technically requiring disjoint guards is probably better if intractable)
06:51:58 <quicksilver> ville: haskell doesn't make my brain hurt at all ;) it's like a stroll in the park compared to C++
06:52:00 <fasta> I already fixed when and cond in some code base, so that they work with m Bool and Bool values and don't return ().
06:52:30 <Cale> I find it funny that in SPJ's presentation he got the type of forkIO right, but in the libraries, it's not ;)
06:52:31 <RayNbow> :t sortWith
06:52:32 <lambdabot> Not in scope: `sortWith'
06:52:33 <ville> quicksilver: Yes water is safe as well but when combined with other cemichals causes violent explosions - similar principle
06:52:42 <ville> err chemicals
06:52:46 <RayNbow> :t GHC.Exts.sortWith
06:52:47 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [a]
06:52:48 <edwardk> @type forkIO
06:52:49 <lambdabot> Not in scope: `forkIO'
06:52:54 <jmcarthur_work> Cale, IO a means the type system can't warn us if we ignore a potentially important return value
06:53:20 <Peaker> quicksilver: really a matter of getting used-to.. a year ago, the talk in #haskell made me feel everyone here must be crazy geniuses :-)  Now it all seems like a piece of cake :)
06:53:23 <EvilTerran> edwardk, ah, not necessarily disjoint, with proven equivalent branches in the case of overlap :P
06:53:26 <edwardk> @src GHC.Exts.sortWith
06:53:26 <lambdabot> Source not found. You untyped fool!
06:53:34 <edwardk> EvilTerran: that'd work too
06:53:38 <jmcarthur_work> Cale, in fact, i believe the motivation for the whole thing is the possibility of (>>) :: Monad m => m () -> m a -> m a
06:53:43 <EvilTerran> if you're going to go undecidable, may as well go the whole hog! :D
06:53:52 <Peaker> jmcarthur_work: why () there?
06:53:54 <Cale> jmcarthur_work: I think that's a silly type for >>
06:54:09 <Peaker> jmcarthur_work: oh, I see
06:54:09 <Cale> Don't make things less polymorphic than their inferred type!
06:54:11 <jmcarthur_work> Peaker, so the type system warns you if you ignore a result
06:54:31 <Heffalump> Cale: if a function won't do anything with the result of an IO action, it should indicate this by taking IO ()
06:54:35 <Cale> I don't think it should. You use >> to ignore results. That's what it means.
06:54:35 <Peaker> jmcarthur_work: fmap is allowed to ignore it, though?
06:54:38 <edwardk> jmcarthur_work: i'm not a big fan of that change
06:54:47 <Peaker> jmcarthur_work: and >>= const .. ?
06:54:58 <Cale> Heffalump: It can indicate that better through parametric polymorphism
06:55:04 <quicksilver> Cale: I think you have to acknowledge the other side of the argument.
06:55:13 <edwardk> thankfully that bikeshed was already painted the much nicer shade long ago
06:55:15 <jmcarthur_work> Peaker, i don't see how fmap ignores it, and using const means you are *explicitly* ignoring it
06:55:16 <quicksilver> Cale: It *is* often an error to ignore the result of a function.
06:55:20 <Cale> A function of type  IO a -> IO ()  can't possibly use the result of the IO action which it takes as a parameter.
06:55:30 <Heffalump> true
06:55:31 <quicksilver> Cale: (a programming error, I mean)
06:55:38 <quicksilver> and it's something the type checker could warn us about.
06:55:46 <quicksilver> which is not saying I'm in favour of changing it.
06:55:50 <Peaker> jmcarthur_work: Well, lots of actions have results that you often don't care about
06:55:50 <Heffalump> so the question comes down to whether having the type checker warn us is worth the pain
06:55:55 <RayNbow> edwardk: sortWith is used in the paper on generalized comprehensions
06:55:58 <quicksilver> but I think the other side of the argument is valid and should be considered.
06:56:10 <jmcarthur_work> Peaker, that's why we have this whole void/ignore/discard/skip thing going on
06:56:33 <Cale> It's too painful to type things like  >> return ()  just because something happens to return a result that I don't care about.
06:56:35 <jmcarthur_work> that's how it started in the mailing list, anyway, iirc
06:56:35 <edwardk> RayNbow: ah yeah i remember that paper now. I was just thinking about it in terms of luqui's sortOn, etc types from planet.haskell
06:56:49 <edwardk> and I was curious if it did the schwartzian transform
06:56:59 <Peaker> jmcarthur_work: ignore = (()<$)   could make that bearable
06:57:01 <lilac> Cale: i'd assume the suggestion comes with an ignore :: IO a -> IO ()
06:57:05 <SamB> I maintain that we should use Void where the function doesn't return
06:57:10 <jmcarthur_work> Peaker, right
06:57:18 <Peaker> Cale: what if (>> return ()) or (()<$) get an alias short-name?
06:57:25 <quicksilver> Cale: "it's too painful having to type fromIntegral when the types match, why don't we have implicit coercion"
06:57:32 <edwardk> lilac: there is an ignore :: Functor m => m a -> m () -- proposal right now as a separate animal.
06:57:41 <Cale> quicksilver: This isn't even a coercion.
06:57:43 <quicksilver> Cale: that's a pretty limited and subjective argument.
06:57:48 <quicksilver> it is very much like a coercion.
06:57:49 <edwardk> which seems to have near universal support modulo bikeshedding
06:57:55 <quicksilver> It is a change of type which might discard information
06:58:02 <quicksilver> and you might want the compiler to warn you about it.
06:58:09 <Cynner> New web browser based game, check it - http://www.lostworlds.lv/go.php?1139730844
06:58:13 --- mode: ChanServ set +o quicksilver
06:58:13 <Cale> This is not being able to use a function because it has a type which is less polymorphic than its implementation.
06:58:18 <ivanm> *sigh*
06:58:20 --- mode: quicksilver set -o quicksilver
06:58:23 <Peaker> Cale: "not being able" is not accurate
06:58:28 <ivanm> quicksilver: he was in before IIRC...
06:58:32 <ivanm> maybe a ban?
06:58:38 <Cale> Peaker: Well, not without using additional stuff :)
06:58:42 <lilac> Cale: this came up yesterday: which is better, forever :: m a -> m b, or forever :: m a -> m Void?
06:58:53 <edwardk> peaker: sure, but that fmap might not be cheap
06:58:54 <Peaker> Cale: The question is whether that additional stuff is considered harmful or beneficial
06:58:55 <lilac> sometimes the most general type only allows additional things which are wrong
06:58:57 <quicksilver> I think there is a high level analogy between the two cases.
06:59:04 <Cale> lilac: I'd go for m a -> m ()
06:59:05 <ivanm> quicksilver: yeah, he did it 4 hours ago as well
06:59:08 <Peaker> edwardk: why can't it be compiled into nothing?
06:59:11 <Cale> lilac: m Void is also fine
06:59:24 <SamB> Cale: Void is nothing like (), though
06:59:41 <SamB> Void is there to tell you that it *does not return*
06:59:52 <Peaker> Cale: What are you trying to optimize?  Ease of writing code, or ease of reading/modifying that code?
06:59:55 <ivanm> as did someone called [AM]-Kasp a couple of weeks ago...
07:00:00 <lilac> Cale: that's not the most polymorphic type, though, so you must concede there is value in the middle ground here
07:00:08 <Peaker> Cale: Making certain classes of errors less likely, etc?
07:00:12 <jmcarthur_work> discard actionWithResultIDoNotCareAbout >> blah -- extra "discard"   ... actionWithResultIMightCareAbout >> blah -- type system catches error
07:00:14 <Peaker> Cale: Or code-golf?
07:00:24 <Cale> When it's the result type, pick something concrete if you don't use it. When it's the input type, leave it parametric if you don't use it.
07:00:48 <SamB> well, Void isn't what I'd call concrete ;-P
07:01:04 <quicksilver> forkIO is a more interesting example IMO.
07:01:15 <edwardk> peaker: a lot of the time fmap takes the default liftM implementation, its often non-trivial to prove the correctness of the liftM implementation, and you ARE asking it to replace the contents when you plumb those ()'s down. so there is information being added, (after all with that type you could be seeding it with some 'errrors'. so its not obvious just from the type that its erasable
07:01:16 <quicksilver> Cale said "the whole point of >> is to ignore the result"
07:01:17 <Peaker> ignore . forkIO $ ...
07:01:20 <quicksilver> I accept that argument.
07:01:28 <quicksilver> however, the "whole point" of forkIO is definitely not to ignore the result.
07:01:41 <quicksilver> so arguably I *do* want the compiler to warn me if I pass somethign to forkIO which returns something
07:01:47 <quicksilver> that very possibly is a bug.
07:01:47 <Peaker> edwardk: not from the type - but from the implementation
07:02:01 <Peaker> edwardk: if you inline it, intuitively I'd expect it to be clear that it can be erased
07:02:27 <Peaker> quicksilver: oh, I was referring to the ThreadId, not the IO *a* :)
07:02:38 <Peaker> ignore . forkIO . ignore $ ...
07:02:45 <Peaker> for ignoring both ;-)
07:02:48 * EvilTerran notes that the heterogeneous state generalized monad (newtype State s s' a = State { unState :: s -> (s', a) }) has a >>= that looks suspiciously symmetric
07:02:49 <edwardk> I'm a bit more pessimistic about how good the compiler is at optimizing complex monads/functors ;)
07:02:54 <paolino> @type Control.Concurrent.forkIO
07:02:55 <lambdabot> IO () -> IO GHC.Conc.ThreadId
07:03:44 <EvilTerran> (in that it's (nearly) isomorphic to id)
07:03:45 * SamB wishes for unlifted types
07:03:52 <Peaker> quicksilver: the "whole point" of >> is to chain actions together, not to ignore the result.  You might ignore a result by accident there, e.g: The result ThreadId you must kill when you die, or such
07:04:03 <Peaker> SamB: unlifted bottom-wise?
07:04:06 <ivanm> SamB: "sunken types"?
07:04:13 <SamB> Peaker: yeah
07:04:23 <Peaker> SamB: yeah, I wish products were separate from sums
07:04:25 <Peaker> SamB: and unlifted
07:04:59 <EvilTerran> (State m >>= f = State $ \s -> let (s', x) = m s in unState (f x) s')
07:05:28 <jmcarthur_work> thanks freenode
07:05:46 <ivanm> @bot
07:05:55 <lambdabot> :)
07:05:59 <ivanm> don't worry, lambdabot is here with us!
07:06:08 <lunabot>  :)
07:06:08 <EvilTerran> gesundheit
07:06:08 <edwardk> peaker: i suppose the simplest answer is that changing it breaks untold amounts of code throughout the community. the current type was specified a decade ago. and there are arguments for both sides. would I give it the more restrictive type in a new language? I dunno, but in this world I doubt it'll change
07:06:35 <Peaker> edwardk: I agree there are more pressing concerns anyway
07:06:56 <jmcarthur_work> i would gladly use a package that provides these kind of "fixes" in new code, though
07:07:37 <jmcarthur_work> i certainly agree that suddenly changing this kind of thing would be idiotic
07:08:28 <Cale> Peaker: Well, obviously all of those things are important, but I can't remember a single time where I've said "oops, I ignored the result of that IO action by using >> by accident" or "oops, I ignored the result of the action which I forkIO'd"
07:08:40 <SamB> jmcarthur: the trouble is the amount of import you'd have to write, I think ...
07:09:05 <jmcarthur_work> SamB, my imports tend to be rather numerous anyway
07:09:06 <Cale> (In the latter case, the compiler nagging me has *never* been the helpful sort of nagging.)
07:09:09 <edwardk> In the end I would rather make a richer type system that can express the linearity of the file handle ;)
07:09:11 <SamB> the forkIO case sounds especially stupid
07:09:34 <Peaker> Why doesn't (MonadTrans t)   have a context:   (Monad t m)  ?
07:09:38 <Peaker> (subclass)
07:09:40 <jmcarthur_work> edwardk, ;)
07:09:58 <fasta_> Changing this kind of thing if you supply an automatic way to port old code to new code is not stupid, otherwise it is sort of like declaring your language to be dead.
07:10:06 <Peaker> Cale: I'm sure >90% of forkIO calls are error-prone/wrong when it comes to terminating the created thread when they hit an exception/error
07:10:36 <Peaker> Cale: Because its so non-obvious that you have to clean up the thread-id.  Its somewhat related, because if you knew you had to do something with that thread-id you received from forkio, you'd have a reminder
07:11:11 <SamB> Peaker: oh, that part I'll give you
07:11:21 <Cale> Er...
07:11:50 <Cale> What do you mean by 'clean up the thread-id' here?
07:11:55 <Cale> kill the thread you created?
07:12:21 <nainaide> In run conn "CREATE TABLE test (id INTEGER NOT NULL, desc VARCHAR(80))" [],  how to split SQL statement in different lines?
07:12:37 <quicksilver> Peaker: I disagree. The entire point of >> is to ignore values.
07:12:45 <Peaker> I think forkIO is possibly the wrong kind of primitive to expose -- maybe something like:  withThread :: IO () -> IO a -> IO a -- sort of a bracket that also kills the thread eventually
07:12:47 <quicksilver> Peaker: if you didn't want to ignore the value, you'd use >>=
07:12:50 <Peaker> Cale: yeah
07:13:00 <SamB> Peaker: so how about something like the GCC __attribute__((warn_unused_result)) ?
07:13:19 <quicksilver> __couldtheypossibly__((have_thought_of_uglier_syntax)) ?
07:13:20 <Peaker> quicksilver: typically you use >> in the context of a do block, where you want the effect, and don't think about the result. But maybe you *should* have thought about the result
07:13:30 <Cale> Peaker: If I wanted the ThreadId, I'd have written  tid <- forkIO (...)  wouldn't I?
07:13:40 <Peaker> quicksilver: so sometimes >> is chosen not *in order* to ignore a result, but because the result was accidentally ignored
07:13:51 <quicksilver> Peaker: in a do block the argument is weak. But as stated, when you explicitly choose >> you have chosen to ignore the result.
07:13:56 <Peaker> Cale: You *do* want the ThreadId, otherwise your code is almost certainly wrong w.r.t error handling
07:14:00 <Cale> Peaker: For example, if I was going to throw an exception and realised that I needed to kill the thread, *then* I'd capture the ThreadId.
07:14:05 <Peaker> Cale: the type-system could warn you that you actually wanted it
07:14:12 <Cale> Maybe I don't want it.
07:14:12 <quicksilver> Peaker: this is comparable to explicitly choosing + when you want to subtract. Nobody can help you from there.
07:14:17 <Cale> Actually I usually don't want it.
07:14:19 <SamB> quicksilver: the point of __attribute__ is that it (a) doesn't conflict with any valid user variable names and (b) can be #defined away
07:14:32 <edwardk> Hah the ultimate bikeshedding fix. Add a new phantom type parameter to every monad to address just this issue and define data Unimportant; then (>>) :: m Unimportant a -> m i b -> m i b -- and just make everyone annotate their code. no big deal. ;)
07:14:33 <SamB> quicksilver: I mean, that's what the extra parentheses are for
07:14:50 <SamB> so you can "#define __attribute__(x)"
07:15:01 <Cale> Usually I just want to fork a thread which is going to run until it's finished with whatever it's doing, regardless of what happens in the main thread (unless the program exits)
07:15:08 <quicksilver> SamB: I do know that; I was joking. It does offend my eyes, though :)
07:15:09 <Peaker> quicksilver: I disagree.. >> joins effects together AND ignores, so if you want the former, you also get the latter (even when you may have not actually explicitly wanted it).  "ignore" would ONLY ignore the result, so if you used that, then you are much more likely to be accidentally ignoring a result
07:15:29 <quicksilver> Peaker: then you should have used >>=.
07:15:29 <SamB> quicksilver: that's why you're *supposed* to #define a macro to use instead of actually using that everywhere
07:15:32 <Cale> Peaker: wanting to kill threads is comparatively rare, I think
07:15:35 <Peaker> quicksilver: consider the use of >> to chain effects, and then a function being *changed* to also return a resource.  If >> told you about non-() results, then you could use the type system for your benefit in this case
07:15:41 <quicksilver> Peaker: true.
07:15:48 <SamB> quicksilver: anyway, I was talking about what it *does*, not the way it looks
07:15:52 <Cale> Heh, hugs doesn't even support killThread
07:15:54 <quicksilver> SamB: I know you were.
07:16:04 <Gracenotes_> keeeel
07:16:04 <SamB> though I'm sure it's harder to do in Haskell
07:16:05 <Cale> (It has ThreadId = ()
07:16:06 <Cale> )
07:16:07 <Heffalump> I don't really care what >> does, but I care about whatever do { foo ; bar } desugars to does
07:16:09 <quicksilver> SamB: you can always ignore me when I'm just being flippant, I won't be hurt :)
07:16:29 <Peaker> Cale: If you want robust software that doesn't leak in unexpected cases of exceptions/errors, you probably want to kill the threads when you exit the thread's user block.  Most software being written isn't support to be robust in various kinds of failure, though
07:16:35 <SamB> quicksilver: well, I didn't know you know the entirety of why it's so ugly
07:16:45 <quicksilver> AH
07:16:48 * quicksilver nods
07:17:00 <edwardk> peaker: then improve the type system to track the resource =)
07:17:11 <Peaker> edwardk: that's just crazy talk
07:17:13 <Peaker> ;-)
07:17:15 <jmcarthur_work> some code i have right now has a function of the form a -> IO a, and i am *supposed* to grab hold of the result to use in place of the parameter from that point on. it would be an error to accidentally ignore it because it would actually lead to a space leak in this case
07:17:18 <Cale> Peaker: I don't get what you mean there. What if the thread is just a task which is going to run and complete, and I don't care about ever killing it?
07:17:49 <jmcarthur_work> if i keep using the old one, i mean
07:17:53 <Cale> (which I think is pretty common)
07:17:58 <Peaker> Cale: are most threads of this kind? I think most threads are usually used to parallelize some process/computation for a purpose of some parent thread
07:18:12 <EvilTerran> jmcarthur_work, StateT a IO ()!
07:18:25 <Peaker> Cale: there are not that many independent tasks you just want done without relation to anything else going on
07:18:34 <Peaker> EvilTerran: use "s" in State/StateT there :)
07:18:51 <EvilTerran> Peaker, it was by analogy to the "a" in jmcarthur's type sig
07:18:51 <Cale> Peaker: We could also go on doing something which cannot possibly fail before reading an MVar
07:18:58 <Cale> Peaker: that's pretty common
07:19:00 <quicksilver> jmcarthur_work: that's what the State monad is for :)
07:19:05 <Cale> Peaker: and there's no exceptions
07:19:18 <Cale> Peaker: so no reason to kill the threads
07:19:41 <Peaker> Cale: Its a question of how robust to unexpected failures you plan to be, I guess
07:19:43 <edwardk> peaker: sounds like in this case you want something like erlang style kill-propagation. a neat primitive but one i rarely want. in any sort of native code, killing a thread is a last resort shutdown thing. on most platforms it can't even be recovered. in haskell it at least has a modicum of grace, but i don't see that particular usecase as all consuming
07:19:44 <Cale> Actually, the only case in which I've actually ever wanted to killThread was to create timeouts, myself.
07:19:58 <Cale> Peaker: what unexpected failures?
07:20:14 <Cale> Peaker: If the things I'm doing don't throw exceptions, then there's nothing to worry about.
07:20:14 <Peaker> Cale: pure bottoms
07:20:18 <jmcarthur_work> EvilTerran, quicksilver: sure, but sometimes that's inconvenient, and either way (>>) :: Monad m => m () -> m a -> m a would catch my error
07:20:36 <Peaker> Cale: (can happen due to underlying platform errors or all sorts of stuff)
07:20:36 <jmcarthur_work> if i wasn't using state yet, for example
07:20:37 <Cale> Peaker: You mean nontermination?
07:21:07 <Philonous> Like in unamb
07:21:07 <Cale> Peaker: You can't very well killThread if you don't terminate on something.
07:21:22 <Cale> (because you'll never make it there)
07:21:23 <Peaker> Cale: no, I meant other kinds of bottom
07:21:36 <Cale> Other kinds of bottom are equally problematic.
07:21:44 <Peaker> Cale: also, often you create threads in generic code that doesn't know if its going to be thrown async exceptions (e.g race in unamb)
07:21:45 <Cale> Your main thread dies and the program ends.
07:22:09 <Cale> unamb is *not* typical thread code
07:22:18 <Peaker> Cale: or maybe it catches the error, prints it to a log, and tries to carry on its critical mission :)
07:22:33 * EvilTerran ponders type hackery so that any thread created must either be waited for or killed
07:22:45 <Cale> Catching that kind of exception is stupid to even try. You should avoid throwing them in the first place.
07:23:07 <Cale> (if you were interested in catching the error)
07:23:17 <edwardk> I think we all acknowledge that forkIO is a particularly sharp tool to keep in the drawer. It violates the world-as-state model, so there are all sorts of things to think about when you use it. That you may or may not want to deal with its thread id is sort of the least of your concerns ;)
07:23:18 <EvilTerran> probably require generalized monads again, and likely something hlist-esque as well
07:23:37 <Cale> edwardk: I never liked the world as state model to begin with.
07:23:49 <edwardk> cale: hah i knew you would speak up the moment i said that =)
07:23:53 <Cale> edwardk: but I agree with your point
07:24:05 <Peaker> Cale: server code/event loops   often have a:  catch-all-log-error-and-continue wrapper around their loops
07:24:23 <Cale> Peaker: but those errors should never be thrown by error
07:24:44 <Peaker> Cale: what if you have some other code throwing pure errors? e.g (`div` 0)?
07:24:49 <Peaker> > 1 `div` 0
07:24:49 <lambdabot>   * Exception: divide by zero
07:25:02 <Cale> Peaker: likelihood is that you will fail to catch them
07:25:04 <Peaker> Cale: you don't necessarily throw the pure exception intentionally
07:25:08 <Peaker> Cale: why?
07:25:31 <quicksilver> that's an attempt to sandbox.
07:25:33 <edwardk> peaker: sure. i would argue there that forkIO isn't the right combinator to be building them out of. Haskell simply hasn't evolved an equivalent of Erlangs OTP for dealing with error propagation/restart/etc.
07:25:44 <quicksilver> exception catching in haskell is a poor tool for sandboxing
07:25:48 <quicksilver> although it's convenient to use it
07:25:50 <Cale> Peaker: because they can easily slip through catch unless you are careful to use evaluate and rnf and all sorts of machinery to ensure that absolutely everything gets evaluated inside the catch
07:25:51 <quicksilver> since we don't have much else.
07:26:15 <Cale> Peaker: you almost have to know where the exception will be in order to catch it
07:27:09 <Peaker> Cale: If the main loop is very simple - and implements some sort of an event loop, there are relatively few pure evaluations it calls that it needs to protect with evaluate/catch, no?
07:27:35 <Cale> Though, I'm pretty sure that if there's a (`div` 0) in my program, I want it to stop completely and immediately in an uncatchable way.
07:28:09 <Cale> Don't go on computing gibberish, please stop and let me fix things.
07:29:04 <Cale> Same goes for if I called head and the list wasn't empty. The fact that I called head means that I'm assuming that the list is not empty and if it is, then I *want* the program to stop and die.
07:29:08 * EvilTerran would suspect that protecting against that sort of thing would be most appropriately placed in ghc-api or suchlike
07:29:21 <Cale> er, was empty*
07:29:26 <Twey> Cale: In an *uncatchable* way?
07:29:29 <Cale> Twey: yes
07:29:35 <Peaker> Cale: most code that forkIO's that I looked at does it around other IO operations that *can* fail, but does not actually worry about cleaning up the threads.. I think its a common idiom
07:29:39 <jmcarthur_work> oh i certainly would want that to be uncatchable
07:29:40 <Twey> How can you stop and fix things if you can't tell when the error has occurred?
07:29:48 <jmcarthur_work> _|_ should not be catchable
07:29:51 <Heffalump> has anyone used mapException significantly?
07:29:57 <Cale> Twey: well, it can report things to me as it dies
07:30:04 <EvilTerran> i'd only want to catch unexpected _|_s if i were running user-supplied code that i didn't trust
07:30:10 <Cale> Twey: But it should not try to recover and continue.
07:30:24 <mansour> I need to construct a list of fib numbers, I know I can use (n:ns) to access elements in a list, but fib depends on the previous two elements and I don't know how to access them. Any one knows ?
07:30:38 <MyCatVerbs> mansour: the common way to write that one is...
07:30:42 <Cale> (n1:n2:ns) ?
07:30:45 <koeien> MyCatVerbs: (n:n':ns)
07:30:46 <EvilTerran> > let x:y:rest = [1..] in (x, y, rest) -- mansour
07:30:48 <lambdabot>   (1,2,[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:30:51 <koeien> mansour: ^
07:31:07 <quicksilver> Cale: I think the application being discussed is a sandboxed one
07:31:10 <mansour> Guys, cooooool.
07:31:11 <MyCatVerbs> mansour: fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
07:31:13 <quicksilver> Cale: like, for example, ghci itself.
07:31:21 <quicksilver> Cale: I think that's rather different from a 'normal' program.
07:31:25 <Cale> quicksilver: well, sure
07:31:25 <Twey> Cale: *shakes head* That just doesn't make for good, robust code
07:31:33 <quicksilver> Cale: some application server type programs might run individual requests 'sandboxed'
07:31:39 <MyCatVerbs> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 21
07:31:40 <lambdabot>   17711
07:31:42 <Cale> Twey: The idea is that it's the same as going into an infinite loop.
07:31:42 <quicksilver> Cale: haskell really doesn't support this very well, to be honest.
07:31:50 <Twey> If you're running a Serious Application, you *really* don't want it to die horribly if it encounters an error in its work where it could just skip that step and move on
07:31:54 <mansour> MyCatVerbs: I am trying to keep things simple in order to understand the idea, and necessarly looking for the shortest code
07:32:05 <fasta>  Why doesn't readFile "/foo/./bar" work?
07:32:08 <EvilTerran> > 1 : 2 : [3,4,5] -- mansour, it's the same syntax to build up a structure as it is to pattern-match it; (:) is right-associative, so you don't need to write the parens in x:y:z when you mean x:(y:zs)
07:32:09 <lambdabot>   [1,2,3,4,5]
07:32:36 <Twey> For any seriously complicated code, you'd want to have some much simpler code standing by checking that nothing went wrong like an infinite loop, too
07:32:37 <koeien> fasta: E_WORKSFORME
07:32:43 <Cale> Twey: When I call error (or a function which calls error), I am making the assumption that whatever conditions prevent that error from occurring will *always* be true, and that there is a serious world-stopping bug in my program if not.
07:33:03 <Twey> That's a bad assumption
07:33:04 <fasta> koeien: what OS?
07:33:06 <doserj> fasta: what do you mean with "doesn't work"?
07:33:12 <Twey> Especially for things like head
07:33:12 <mansour> ok, I am trying to understand (x:y:rest) as I haven't used it before
07:33:14 <koeien> fasta: linux
07:33:15 <Cale> Twey: It's an okay assumption if I prove it.
07:33:18 <fasta> doserj: I get that the file does not exist.
07:33:23 <fasta> doserj: but it does.
07:33:24 <koeien> Cale: "world"-stopping ?
07:33:33 <EvilTerran> mansour, it's the same as (x:(y:rest))
07:33:36 <Cale> koeien: well, I just mean the program should end.
07:33:37 <jmcarthur_work> i think you guys are talking about completely different kinds of scenarios
07:33:47 <MyCatVerbs> > let fibs = 1 : (1 : fibSpitter fibs) where fibSpitter (a : more@(b : _)) = a + b : fibSpitter more in fibs !! 21
07:33:48 <lambdabot>   17711
07:33:51 <koeien> Cale: why not log the error, and restart yourself/the request you were handling
07:33:51 <Twey> If I happen to use head on a list that I think can never be empty whilst recursing (say I forgot my base case) and we get to the end of the list, having processed the whole thing, and something bad happens
07:34:03 <Cale> koeien: because that's not what 'error' means
07:34:12 <Cale> koeien: I would have used another kind of exception handling for that.
07:34:14 <Twey> I don't want the whole application to die
07:34:17 <doserj> fasta: works for me (well, if foo/bar actually exists)
07:34:18 <fasta> doserj, koeien: never mind.
07:34:26 <Cale> Twey: Then you should use Maybe :)
07:34:26 <Twey> It should just shrug, log an error for later inspection, and move on to the next list
07:34:34 <koeien> ya precisely
07:34:34 <Cale> Twey: or pattern matching
07:34:39 <jmcarthur_work> well, you certainly don't want ghci or lambdabot to die under those circumstances, anyway..
07:35:04 <Cale> Twey: don't use head if you're not absolutely certain that the list is nonempty.
07:35:06 <jmcarthur_work> > head [] -- on noes! lambdabot might crash!
07:35:07 <lambdabot>   * Exception: Prelude.head: empty list
07:35:14 <Cale> jmcarthur_work: sure
07:35:14 <Twey> Cale: I'm talking Serious Code  it's highly modular, the modules shouldn't know any more about one another than they strictly need to, and I might not even be the one writing this code
07:35:29 <EvilTerran> mansour, consider the list (x:xs): x is a single element, and xs is another list. if xs = (y:rest), then (x:xs) = (x:(y:rest)) = (x:y:rest)
07:35:31 <mansour> EvilTerran: thank you, but I am just trying to fit it in a function ... lol
07:35:41 <Twey> Cale: It's all very well to answer the question of how do we handle bugs? by saying don't write buggy code, but that's not really how it works in the real world :-P
07:35:43 <Cale> Twey: that seems best served by something like running parts of the program in separate processes.
07:36:06 <koeien> and let the OS handle it?
07:36:08 <jmcarthur_work> Cale is ascribing to the Erlang model for robustness, i suspect
07:36:11 <koeien> then why not let the GHC runtime handle it?
07:36:13 <Twey> Processes are heavy
07:36:14 <Cale> Twey: but yes, 'head' and 'error' are dangerous, which is why I don't advocate using them except in the most obvious situations.
07:36:17 <Twey> Really heavy
07:37:08 <Twey> Bugs will eventually occur  situations will happen that we thought could not be possible
07:37:10 <Cale> Well, it's what lambdabot does :)
07:37:13 <Twey> That's why there are bugs :-P
07:37:21 <Twey> \b is not Serious Code
07:37:28 <Cale> Right, it's not.
07:37:33 <Twey> She runs maybe, what, five to ten processes at a time?
07:37:39 <Cale> Not even :)
07:37:40 <Twey> At that scale, sure, it's easy to afford
07:38:00 <Cale> Just one for whatever separate potentially-failing request there is right then.
07:38:03 <Twey> When it gets to the hundreds of thousands mark, it's a bit trickier :-P
07:38:15 <Cale> Well, then don't use so many :)
07:38:17 <Twey> Cale: But the idea behind robust design is that *any* code is potentially-failing
07:38:27 <Twey> And the more complex it is, the more likely it is to fail
07:38:44 <Cale> Twey: I think you're missing my key point.
07:38:45 <Twey> The code has to be capable of dealing with *unexpected* errors
07:38:55 <Twey> Which was?
07:38:59 <Cale> My key point is not that we shouldn't catch exceptions.
07:39:25 <Cale> My point is that we shouldn't catch throw exceptions with error if we want to catch them.
07:39:29 <Cale> er
07:39:34 <Cale> -spurious catch
07:39:37 <jmcarthur_work> perhaps somebody could write a "robustness" package that allows one to gracefully handle failing threads by logging, killing, and restarting them in some way? this seems to be the only case for catching exceptions from pure code, and if we contain all that into one package then we can accurately say you should never have to do it yourself
07:39:58 <Twey> Cale: If that's so then I would respond by saying that error should *never* be used, then
07:40:05 <Cale> right.
07:40:06 <EvilTerran> exception handling as throwing continuations everywhere!
07:40:13 <Cale> You're free to never ever use it then :)
07:40:23 <koeien> but then you also cannot use head
07:40:24 <Twey> Because any use of it potentially introduces a whole-app-killing bug into your code
07:40:29 <Cale> or fromJust
07:40:32 <Twey> Cale: But if it's there, it's going to be used
07:40:43 <koeien> why not use a total language in the first place then?
07:40:45 <Cale> It's for more lightweight programs
07:40:55 <Twey> Touch
07:41:45 <lilac> FWIW, my \b runs on a slow machine, and mueval usually fails, because the forking and startup time are too long
07:41:56 <lilac> (usually as in, a lot more than half the time)
07:42:14 <Peaker> Cale: I wish we had a total language with partiality as a monad
07:42:21 <Peaker> no pure exceptions :)
07:42:23 <Cale> Twey: Imagine a program whose sole purpose is to calculate a number, and if some list is empty as some point, it violates the theorem I was supposed to be using in the construction of that number.
07:42:33 <Cale> at*
07:43:02 <Cale> Twey: I want the program to die if it's empty by accident, because something has gone very wrong, and there's no point in continuing.
07:43:20 <Twey> Cale: *nod* For tiny programs like that, it makes sense
07:43:27 <quicksilver> the question boils down to "what can continuing possibly mean"
07:43:33 <quicksilver> if my program is "a + b"
07:43:39 <quicksilver> and it hits an error when computing a
07:43:42 <quicksilver> then it can't continue.
07:44:00 <fasta> It can continue nops. :)
07:44:04 <quicksilver> in a program like an application server
07:44:08 <jmcarthur_work> i rather like the erlang model for this
07:44:10 <quicksilver> (or a web server)
07:44:20 <quicksilver> then each individual request might sensibly be sandboxed
07:44:24 <quicksilver> so if it dies, the server continues.
07:44:33 <quicksilver> and I do think that haskell does not have great tools for this case.
07:44:43 <jmcarthur_work> just kill the "process" (thread which does not really share state with other threads)
07:44:45 <Twey> Yes, jmcarthur_work  it's not bad.
07:44:52 <Cale> hehe, we could kill the thread which was computing the number and restart it and hope that it's okay the next time ;)
07:44:56 <quicksilver> jmcarthur_work: right.
07:45:12 <quicksilver> jmcarthur_work: in some sense, at least, the request needs to be a sandboxed entity.
07:45:12 <jmcarthur_work> if the thread does share state with other threads, those other threads should die as well
07:45:19 <Twey> Cale: And for some (impure) computations, that's reasonable
07:45:28 <quicksilver> incidentally, the behaviour of a pure exception is precisely to terminate the thread ;)
07:45:35 <Cale> Twey: right, the joke is when it happens to be pure :)
07:45:41 <quicksilver> so that much, I suppose, works out ok.
07:45:46 <Twey> Haha, aye
07:45:51 <jmcarthur_work> quicksilver, yeah, the problem is what to *do* with that
07:45:56 <Twey> Well, it could be corrupted memory or something
07:46:02 <koeien> or a runtime bug :)
07:46:08 <inimino> cosmic rays
07:46:08 <EvilTerran> or unsafePerformIO :P
07:46:11 <koeien> or unsafePerformIO
07:46:14 <Twey> Hehe
07:46:44 <jmcarthur_work> quicksilver, and also whether one thread dying should result in some other threads dying
07:46:56 * EvilTerran notes the unsafePerformIO comment got executed twice when different threads forced it there :P
07:47:18 * koeien notes the unsafePerformIO comment got executed twice when different threads forced it there :P
07:47:19 <jmcarthur_work> NOINLINE
07:47:35 <koeien> ;)
07:47:38 <jmcarthur_work> oh threads
07:48:32 <jmcarthur_work> a single thunk could be evaluated multiple times by multiple threads, couldn't it, if they happen to be around the same time?
07:48:54 <jmcarthur_work> which means NOINLINE wouldn't not be enough to limit an unsafePerformIO to just one call
07:48:57 <jmcarthur_work> ?
07:49:00 <EvilTerran> jmcarthur_work, i think a thread reserves a thunk for itself before evaluating it, so the other would just wait
07:49:01 <jmcarthur_work> *would not
07:50:02 <Cale> EvilTerran: iirc, there is something like a one-step gap during which two threads can start evaluating the same expression
07:50:20 <EvilTerran> ... race conditions, in my haskell?!
07:51:25 <Cale> Well, they'll get the same result, won't they? ;)
07:51:28 <jmcarthur_work> "Haskell on a Shared-Memory Multiprocessor" says: "The lock-free technique, by design, leaves a small possibility of semantically-harmless duplicate evaluation."
07:51:52 <koeien> Cale: sure, the result is of type a ;)
07:51:53 <Cale> Semantically harmless, as long as you're not unsafePerformIO-ing?
07:52:09 <jmcarthur_work> although i suspect that unsafePerformIO has a lock on it
07:52:17 <Cale> probably, yeah
07:55:12 <edwardk> cale: its a little worse than a one step gap in practice because of relaxed fencing and coherence guarantees
07:55:21 <edwardk> unsafePerformIO has a lock
07:55:28 <edwardk> unsafeDupablePerformIO skips the lock
07:55:38 <Cale> cute
07:55:47 <Cale> where is that one?
07:55:56 <jmcarthur_work> oh i do remember seeing that now
07:56:17 <jmcarthur_work> when i would doing some absolutely horrible things
07:56:21 <jmcarthur_work> *was doing
07:56:38 <edwardk> GHC.IOBase IIRC
07:57:10 <edwardk> hrmm maybe i'm wrong
07:57:45 <edwardk> ah nope there it is
07:57:49 <Cale> hmm, perhaps unsafeDupablePerformIO could be used to test the probability of such collisions for different access patterns :)
07:58:34 <edwardk> in any event eager blackholing can shorten the window in which things can race
07:58:51 <FliP^2eH> Is there ANY way to launch an external program and capture it's output LIVE, as in, not just when it's closed?
07:59:20 <edwardk> FliP^2eH: have you turned off buffering to it?
07:59:25 <edwardk> er from it
07:59:30 <FliP^2eH> I have not done anything yet
07:59:35 <FliP^2eH> Just want to know if it's possible
07:59:40 <edwardk> sure
07:59:41 <jmcarthur_work> it's possible
07:59:44 <EvilTerran> FliP^2eH, iirc, System.Process does that kinda thing
07:59:49 <FliP^2eH> ;o
07:59:52 <Cale> FliP^2eH: This is what terminal emulators do :)
07:59:54 <FliP^2eH> I'll take a look at it
07:59:56 <FliP^2eH> :)
07:59:59 <jmcarthur_work> http://www.haskell.org/ghc/dist/current/docs/libraries/process/System-Process.html#v%3AcreateProcess
08:00:13 <Cale> (and shells for that matter)
08:00:52 <FliP^2eH> So
08:01:09 <jmcarthur_work> there are a few variations on that for convenience, too
08:01:11 <FliP^2eH> I can create a process, give it an STDOUT handle, and do hReadLine on it?
08:01:20 <jmcarthur_work> yup
08:01:25 <FliP^2eH> That is like
08:01:26 <FliP^2eH> Awesome
08:01:41 <FliP^2eH> :)
08:03:01 <ehird> That's, er, not very Haskell-unique :p
08:03:16 <FliP^2eH> I know, probably easier in other languages
08:03:22 <FliP^2eH> But I didn't know this even works
08:03:23 <Cale> Wow, that library has become quite a bit more elaborate since I last looked at it though
08:03:27 <jmcarthur_work> no harder in haskell either, just not unique
08:03:35 <FliP^2eH> I only know of process starting and getting the return code
08:04:25 <fasta> FliP^2eH: you can do readProcess, IIRC, to get the whole output of the program as a String.
08:04:36 <FliP^2eH> Weel
08:04:37 <FliP^2eH> l
08:04:47 <FliP^2eH> But that gets it all once the process ends
08:04:48 <Cale> Well, in a shell script, of course you can do this a bit more easily, but it's less flexible :)
08:04:52 <edwardk> FliP^2eH: this is the stuff perl used to get famous ;)
08:05:25 <edwardk> that and a gentle sprinkle of line noise
08:05:37 <FliP^2eH> And =~
08:06:13 <edwardk> I always hated the =~ operator. I felt there should be an infix ~ operator so you can define ~= like all the others.
08:06:42 <jmcarthur_work> hmm...
08:07:01 <jmcarthur_work> makes me think about using data-accessor with State to do +=, -=, etc.
08:07:17 <jmcarthur_work> probably been done already, i suppose
08:07:23 <edwardk> does data-accessor have those?
08:07:33 <jmcarthur_work> i didn't see them last i looked
08:07:45 <edwardk> clearly an opportunity missed =)
08:09:03 <edwardk> speaking of accessors, I had this rather perverse thought of playing with sharing-preserving maps (and potentially accessors) by abusing stablenames a while back but wasn't sure what would be the right way to proceed on it
08:09:27 <McManiaC> @pl \_ x -> x
08:09:27 <lambdabot> const id
08:09:41 <jmcarthur_work> in what way do maps not typically preserve sharing?
08:10:20 <Heffalump> do you mean the map function or the map structure?
08:10:34 <jmcarthur_work> oh, function!
08:10:45 <jmcarthur_work> that makes sense to me then
08:11:00 <edwardk> (+1) `fmap` let ones = 1:ones in ones -- probably makes a big long chain of thunks in memory
08:11:17 <Cale> mkfifo fifo; prog < fifo | filter > fifo   -- this is a fun idiom to try in a shell script :)
08:11:37 <Cale> Especially when 'prog' is an instance of netcat :)
08:11:44 <edwardk> (f)map function
08:12:08 <EvilTerran> Cale, er, fixedpoint of a prog?
08:12:14 <Cale> 'filter' is a program for turning the lines of output from 'prog' into new lines of input.
08:12:26 <Cale> EvilTerran: yeah, basically :)
08:12:30 <edwardk> cale: buffering often plays hell with that though
08:12:48 <edwardk> since it usually detects that its reading/writing to a file and moves to block buffering
08:13:18 <Cale> edwardk: I wrote an IRC bot way back when which used that successfully... I don't recall if I did anything special to turn off buffering
08:14:23 <edwardk> cale: you can get away with it. i had a student use that approach for a chat server in an systems programming class i was teaching once, but its just something that usually trips people up when they go to tie the knot that way
08:14:55 <Cale> Seems like something you might avoid by a useless use of cat
08:15:18 <Cale> (if cat itself doesn't do it...)
08:15:32 <jeffersonheard> I want to do random access of elements in a sequence of Maybe a values...  can I use a Data.Array.ST.STArray, or is it more sensible to use Data.IntMap ?
08:16:14 <Cale> jeffersonheard: that does sound like an IntMap a
08:16:32 <Cale> jeffersonheard: Or there's also Data.Sequence
08:16:35 <jeffersonheard> Cale: That's what I thoguht, but does the same hold for 2 dimensions?
08:16:47 <Cale> jeffersonheard: for 2D, use Map
08:17:05 <Cale> (or other key types)
08:17:11 <jeffersonheard> Yes...  was just curious if I could use STArray at all
08:17:14 <Cale> You could IntMap (IntMap a)
08:17:21 <Cale> Oh, you could also use 2D STArrays
08:17:34 <Cale> There's an instance of Ix for pairs
08:17:43 <Cale> (and some larger tuples as well)
08:17:51 <jeffersonheard> Just never used STArray, so I wasn't sure if it was actually efficient or not
08:18:01 <jeffersonheard> space / time efficient
08:18:08 <Cale> STArray is pretty efficient
08:18:23 <Cale> It's just the programming model that it subjects you to which might be a concern :)
08:18:24 <fasta> jeffersonheard: it all depends on the number of elements.
08:18:35 <jeffersonheard> I figured for reasonably small sequences, IntMap would be faster
08:18:48 <fasta> jeffersonheard: but STArray is always going to be faster.
08:18:56 <jeffersonheard> but for a large dense dataset with a few missing values, like a statistical set, the STArray is going to be faster
08:19:02 <Cale> It depends what operations you're doing.
08:19:06 <jeffersonheard> and have better space constraints
08:19:18 <jeffersonheard> characteristics, rather
08:19:52 <fasta> jeffersonheard: you can also do both.
08:19:59 <Cale> Is it really a sequence, or are the indices important?
08:20:20 <jeffersonheard> Cale: I know....  Writing a generic container for datamining datasets, and data mining / machine learning tasks on tabular data have to deal with missing data
08:20:34 <jeffersonheard> also plan on performing joins
08:20:45 <Cale> by join, do you mean concat?
08:20:46 <fasta> jeffersonheard: you can also just port the R stuff.
08:20:54 <jeffersonheard> no, by join, I mean join
08:20:56 <fasta> jeffersonheard: I think they have that data type in C.
08:21:06 <Cale> :t join
08:21:07 <jeffersonheard> Hrm.  Alright.
08:21:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:21:17 <jeffersonheard> Cale: I mean in the SQL sense, sorry
08:21:23 <jeffersonheard> inner / outer joins
08:21:28 <Cale> ah, okay
08:22:08 <jeffersonheard> fasta: the R stuff was precisely what I was thinking of
08:24:52 <edwardk> Every time you use a STArray another kitten dies.
08:25:18 <jeffersonheard> edwardk, considering how much I like cats, that's a definite argument against :-D
08:25:20 * mux likes STU?Array's
08:25:28 <edwardk> STUArrays are fine
08:25:41 <jeffersonheard> STUArrays + Maybe = bork
08:25:53 <edwardk> jeffersonheard: but what is it a Maybe of?
08:26:09 <jeffersonheard> Maybe Double
08:26:10 <Peaker> who is cgibbard ?
08:26:21 <edwardk> jeffersonheard: can you use NaNs for your Nothings?
08:26:49 <Saizan> Peaker: Cale
08:26:53 <quicksilver> edwardk: evil! evil! evil!
08:27:17 <edwardk> jeffersonheard: if so you can smash it into an STUArray and you don't have to suffer the terrible GC headaches that come from STArrays
08:29:01 <wli> Use STUArrays as radix trees.
08:29:34 <wli> The limitations on the branching factors will calm the GC headaches down.
08:29:38 <quicksilver> STUArray + IntMap can be useful. But it does depend what you're trying to do.
08:30:10 * Peaker is watching augustss's embedded languages talk
08:30:21 <Peaker> Saizan: thanks
08:30:41 <Saizan> Peaker: link to the talk?
08:30:51 <Peaker> Saizan: http://www.infoq.com/presentations/Strongly-Typed-DSEL-Lennart-Augustsson
08:30:54 <jeffersonheard> quicksilver: writing a somewhat general type for processing tabular data
08:31:13 <jeffersonheard> like SAS or R datasets
08:31:23 <wli> Say there are 64K objects to index. Instead of one big STUArray of size 64K use a radix tree with a branching factor of 16 and a depth of 4 to index the dataset.
08:32:23 <jeffersonheard> wli: how does that help with a tabular dataset?
08:32:26 * wli hasn't actually tested if this idea reduces GC headaches.
08:32:46 <jeffersonheard> oh wait, nm.  I see what you mean
08:33:04 <wli> jeffersonheard: IIRC there's no card marking, so cutting down the branching factors is somehow supposed to help.
08:33:37 <quicksilver> jeffersonheard: where processing it means mutating the array inplace?
08:34:13 * wli has forgotten the potentially relevant aspects of the GC algorithm that would give some idea of whether this scheme would actually help.
08:34:15 <jeffersonheard> quicksilver: sometimes, yes.  These datasets are large enough in the general sense that in-place mutation makes sense.
08:34:33 <jeffersonheard> and I need random access for operations like convolution
08:34:41 <jeffersonheard> or MDS
08:35:27 <quicksilver> well in the spirit of "Get it working, then get it fast", I'd start with arrays.
08:35:44 <quicksilver> it's likely that refactoring it to use something else if necessary won't be terribly hard
08:35:55 <quicksilver> after all, something which is array-like is bound to have a similar interface :)
08:36:18 <wli> The radix trees are decidedly array-like.
08:38:53 <jeffersonheard> quicksilver: yeah.
08:40:08 <jeffersonheard> the general workflow here is read in the data, select columns, select rows, join with other tables, take the results of some series of mining algorithms
08:40:27 <Saizan> http://www.nabble.com/Re%3A-Questions-about-slow-GC-with-STArray-p22904415.html <- from 1 minute to 6 seconds by splitting up the array
08:40:40 <jeffersonheard> Saizan: thanks
08:41:02 <jeffersonheard> so for the first parts of the workflow, I'm pretty good
08:41:34 <jeffersonheard> but for that last part, I need some final dataset type that has O(1) random element access
08:42:11 <jeffersonheard> because most of the algorithms I'm interested in using are O(n^2) at best and O(n^4 or 5) at worst
08:42:41 <quicksilver> I wonder if a further log n makes any difference on top of O(n^4) :P
08:42:44 <jeffersonheard> MDS or Viterbi
08:43:03 <quicksilver> I guess the constant factor is more important.
08:43:31 <jeffersonheard> quicksilver: yes, I've tried this the simple way and the constant factor is definitely more important
08:43:48 <jeffersonheard> if I was only sampling the data, that'd be one thing
08:44:01 <jeffersonheard> but since I'm accessing every element multiple times
08:44:17 <jeffersonheard> that's the easiest place to save a lot of processing time
08:45:02 <jeffersonheard> Now edwardk has me thinking about the NaNs, because that would mean I could use parallel arrays to do some of this, but really only if I guaranteed that there's no missing data
08:45:16 <jeffersonheard> or if I explicitly code everything to test for NaNs
08:45:22 <jeffersonheard> seems unsafe tho
08:45:46 <quicksilver> seems like a disgusting hack to me :) But of course, occasionally such things are worth it for the performance boost.
08:46:17 <jeffersonheard> quicksilver: I'm generally of the opinion that coding things correctly is worth more than the performance boost except in extreme cases
08:46:31 <jeffersonheard> so I'm not going to go with the NaN solution however tempting, at least
08:46:38 <jeffersonheard> until I satisfy myself that it'll save a lot
08:47:11 <jeffersonheard> right now, I'm using Data.Map (Int,Int) (Maybe Double)
08:47:33 <quicksilver> IntMap will be quite a lot faster
08:47:53 <quicksilver> either coding the indices into single Int, or doing an IntMap of IntMaps
08:48:13 <jeffersonheard> Yes.  And I was debating the intmap of intmaps solution when I wondered if just using the STArray would be simpler
08:48:43 <quicksilver> well, in the sense that using STArray will force you to "monadify" all your code
08:48:49 <quicksilver> and an IntMap of IntMaps doesn't
08:48:58 <quicksilver> I guess the latter is simpler.
08:48:59 <jeffersonheard> quicksilver: it's true
08:49:03 <Saizan> Maybe Double for the Map/IntMap seems redundant
08:49:12 <quicksilver> good point.
08:49:28 <quicksilver> why not have absence from the Map denote absences, instead of using Nothing for that?
08:49:51 <jeffersonheard> Oh, yes... sorry, overtyping.  I was going to use the Maybe with the STArray
08:49:58 <jeffersonheard> indeed, right now it's Map (Int,Int) Double
08:50:13 <quicksilver> Aha. :)
08:50:19 <jeffersonheard> There are maybes, but in the earlier stages of data processing
08:50:26 <jeffersonheard> when I'm first reading in data and performing joins
08:52:12 <jeffersonheard> so the last question I have, then, is what the space complexity of the IntMap of IntMaps solution is...  log(2N) ?
08:52:44 <jeffersonheard> since I know ahead of time that I will be accessing every element
08:52:53 <jeffersonheard> so the whole structure will be in memory at some point
08:54:53 <Saizan> it's quite big i think, compared to the 64bits for a Double
08:55:24 <Saizan> data Map k a  = Tip  | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
08:55:45 <Saizan> Size = Int
08:57:43 <Saizan> if list has a 20 words overhead, here you've to add 1 for Size and 2 for the pointers to the key and the other child
08:58:21 <jeffersonheard> right.
09:01:50 <jeffersonheard> Thanks.  That's what I needed to know.
09:05:41 <quicksilver> Saizan: list doesn't have 20 words overhead.
09:05:52 <quicksilver> Saizan: it has 16, or 24, bytes overhead.
09:06:01 <quicksilver> which IIRC is two words, plus 8 bytes.
09:06:29 <quicksilver> or maybe I misunderstand entirely what you're trying to say.
09:06:59 <Saizan> i think you understood and i'm just recalling incorrectly :)
09:09:25 <Saizan> jeffersonheard: ^^^
09:12:00 <etpace_> Hmm, how can I check if a string can be converted to a number?
09:16:32 <fasta> etpace_: you just do so and you catch the call to error when it doesn't work with either an evil hack or in the IO monad.
09:17:10 <Saizan> etpace_: use reads
09:17:22 <fasta> Saizan: oh, right, that's better.
09:17:54 <etpace_> I'm wondering how I can append a "%" sign after all numbers in a string, so I was thinking of: foldr (\x acc -> if (canbeInt x) then x:'%':acc else x:acc) [] $ words
09:19:21 <Saizan> > let canBeInt s = case reads s of [(x,"")] -> True; _ -> False in (canBeInt "foo",canBeInt "-123")
09:19:22 <lambdabot>   Add a type signature
09:19:25 <Saizan> > let canBeInt s = case reads s of [(x,"")] -> True; _ -> False in (canBeInt "foo",canBeInt "-123") :: (Int,Int)
09:19:26 <ben> Suggesting regexp
09:19:26 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:19:46 <Saizan> > let canBeInt s = case reads s of [((x::Int),"")] -> True; _ -> False in (canBeInt "foo",canBeInt "-123")
09:19:47 <lambdabot>   (False,True)
09:35:29 <jpcooper> how do I combine two state monads?
09:35:35 <jpcooper> use a state transformer for one of them?
09:35:48 <jpcooper> that is monad transformer
09:36:38 <SamB> jpcooper: yeah, and hopefully the other one is abstracted behind a newtype too
09:36:56 <jpcooper> why is that?
09:37:27 <SamB> well, you can try without if you like
09:38:39 <jpcooper> I don't have much experience with newtypes and monad transformers, so I'd like to know the reason
09:39:22 <SamB> it just tends to get messy if you don't abstract it such that putting it in a newtype would be easy
09:39:25 <jpcooper> as opposed to just type
09:40:30 <SamB> you'd also want a MonadFoo class for that inner one, I think, and you could then write instances for all levels in the stack
09:41:08 <jpcooper> what would MonadFoo do?
09:41:49 <SamB> dunno
09:41:56 <SamB> depends what the inner State monad is for
09:42:18 <jpcooper> could you give me any examples on the web of where this type of thing is done?
09:42:32 <SamB> hmm, can't think of anything off the top of my head :-(
09:45:50 <quicksilver> > runState (runStateT (do x <- get; y <- lift get; return ("The inner state was " ++ show x ++ " and the outer state was " ++ show y)) 0) "hi"
09:45:52 <lambdabot>   (("The inner state was 0 and the outer state was \"hi\"",0),"hi")
09:45:57 <quicksilver> jpcooper: there you go.
09:46:04 <lilac> jpcooper: another option would be to use a pair for the state... :)
09:46:29 <jpcooper> lilac, I considered this
09:46:37 <jpcooper> but it's not as pretty
09:46:40 <jpcooper> I may just do it
09:46:47 <quicksilver> jpcooper: in real code you might make a name for get, and a name for lift get, which are a bit mnemonic.
09:46:47 <jpcooper> thanks quicksilver
09:47:30 <lilac> jpcooper: or, outerState = id; innerState = lift. then say x <- innerState $ get; y <- outerState $ get
09:47:45 <lilac> (with names chosen to reflect what those states are actually for)
09:48:14 <quicksilver> > runState (runStateT (do x <- get; y <- lift get; put (length y); lift . put $ show x) 0) "hi"
09:48:15 <lambdabot>   (((),2),"0")
09:48:26 <quicksilver> jpcooper: A slightly more interesting example which uses put.
09:48:44 <quicksilver> It takes the length of the string state and store it in the int, and 'shows' the int state and puts that in the string.
09:48:48 <pikhq> Too much state.
09:52:45 <HugoDaniel> can someone help me out with this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6459#a6459
09:52:56 <HugoDaniel> is there any better way to write the function "postBackup" ?
09:53:50 <quicksilver> HugoDaniel: well, you might as well case location direction
09:53:53 <quicksilver> directly.
09:53:54 <HugoDaniel> it performs a post on a webpage (that exports some stuff onto the disk), and then checks to see if the answer has the word successfully
09:54:07 <quicksilver> case location of [] -> Nothing; (x:xs) -> Just x
09:54:09 <HugoDaniel> by "better way" i mean, more readable
09:54:24 <quicksilver> which is also known as listToMaybe
09:54:31 <HugoDaniel> ah nice
09:54:46 <quicksilver> otherwise it looks fine to me.
09:55:36 <HugoDaniel> allright, thanks for the hint :)
09:57:27 <lilac> HugoDaniel: i personally would write: html <- respBody <$> curlGetResponse ..., but i think that's a matter of taste
09:58:30 <lilac> @hoogle [a] -> Maybe a
09:58:31 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
09:58:31 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:58:31 <lambdabot> Prelude head :: [a] -> a
09:58:53 <lilac> HugoDaniel: that whole location thing is just 'return $ listToMaybe location'
09:59:21 <lilac> HugoDaniel: you can probably write the setopt section more compactly, but it might be less clear
10:00:21 <HugoDaniel> the setopt is just for debugging, ill write a diff function for post once this is working properly :)
10:00:35 <lilac> i guess you can't take a section on =~ due to its excessive polymorphism?
10:00:42 <HugoDaniel> i also prefer using the applicative
10:00:57 <HugoDaniel> thanks
10:01:20 <HugoDaniel> hmm, what i wanted was to check the html for the string "successfully"
10:01:34 <lilac> i wouldn't call the second parameter of postBackup 'id' myself :)
10:01:38 <HugoDaniel> i didn't think much about it
10:01:59 <lilac> HugoDaniel: filter ("successfully" `isInfixOf`)
10:02:05 <lilac> @index isInfixOf
10:02:06 <lambdabot> bzzt
10:02:34 <lilac> @type Data.List.isInfixOf
10:02:35 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
10:02:56 <HugoDaniel> nice
10:03:03 <HugoDaniel> infixOf :D didn't know about that one
10:03:07 <lilac> > "successfully" `isInfixOf` "We successfully avoided using regular expressions"
10:03:08 <lambdabot>   True
10:03:14 <HugoDaniel> yes, great
10:03:23 <HugoDaniel> then i dont even need to transform the output of curl onto a list
10:04:31 <HugoDaniel> hmm
10:04:35 <HugoDaniel> but then i wont have the string
10:04:49 <lilac> HugoDaniel: listToMaybe . filter f  is  find f
10:04:52 <HugoDaniel> which is what i want, because the string gives me the location where the backup is
10:05:13 <HugoDaniel> ok, nice
10:06:41 <lilac> HugoDaniel: the last two lines in doPost: x <- foo; return x == foo
10:06:54 <lilac> (but the compiler will do that for you so it's a matter of taste)
10:10:53 <hallettj> Help? I cannot install hack-contrib due to a type error.
10:12:11 <dmwit> hallettj: It is impossible to help with such a vague problem description.
10:12:28 <hallettj> Right, I just pasted the log here: http://gist.github.com/139596
10:13:14 <dmwit> Have you taken a look at the line it points to (and the definition of b2u)?
10:13:59 <hallettj> I have taken a look at that line, but I do not know where to find the definition of b2u.
10:14:10 <dmwit> ack/grep
10:14:31 <hallettj> I was hoping there might be some problem with me using the wrong version of the compiler, rather than having to fix hackage packages.
10:14:40 <hallettj> Tried grep
10:14:47 <hallettj>  I think b2u is in a different package.
10:15:06 <dmwit> :i b2u in ghci should tell you where it came from and stuff
10:15:20 <dmwit> It's not likely that a change in compiler version would turn a String into a function.
10:15:55 <hallettj> I am trying that too. But I still don't know which package to load to get the definition of b2u.
10:16:40 <dmwit> Load up all the modules in H.C.M.ShowStatus. ;-)
10:16:47 <Saizan> well, comment out and/or add undefined somewhere in that module so that it typechecks
10:17:00 <Saizan> once loaded you'll have the same scope
10:17:20 <edwardk> jeffersonheard: which way did you go with the STUArray Double/IntMap (IntMap (Maybe Double)) -- dilemma
10:17:38 <Apocalisp> @hoogle Maybe a -> a -> a
10:17:38 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
10:17:38 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:17:38 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
10:17:47 <hallettj> Ok, I will try that. Thanks dimwit and Saizan.
10:17:57 <hallettj> *dmwit, sorry!
10:20:54 <Apocalisp> \k p -> fromMaybe false $ fmap p (lookup k)
10:21:26 <Apocalisp> Seems like a long way around
10:21:28 <dmwit> maybe false p (lookup k)
10:21:33 <Apocalisp> yes!
10:22:46 <Apocalisp> if maybe false p (lookup k) else e -- can I eliminate the false?
10:23:42 <dmwit> There's no "then" there.
10:24:01 <Apocalisp> if maybe then False p (lookup k) else e
10:24:20 <dmwit> ...wut
10:24:27 <Apocalisp> hah
10:24:45 <Apocalisp> (seat of pants)
10:25:16 <Apocalisp> if maybe False p (lookup k) then a else b
10:25:39 <dmwit> The reduction ain't that pretty.
10:25:55 <dmwit> maybe b (\x -> if p x then a else b) (lookup k)
10:26:04 <Apocalisp> @pl  if maybe False p (lookup k) then a else b
10:26:05 <lambdabot> if' (maybe False p (lookup k)) a b
10:26:38 <dmwit> maybe b (lookup k >>= ensure p >> return a)
10:26:47 <Apocalisp> nice one
10:26:55 <dmwit> ensure p x = guard (p x) >> return x
10:27:02 <Apocalisp> @hoogle ensure
10:27:02 <lambdabot> No results found
10:27:12 <dmwit> 'snot in the standard libraries
10:27:22 <dmwit> But it's in Prelude.Dmwit. ;-)
10:27:43 <tommd> @seen byorgey
10:27:43 <lambdabot> byorgey is in #haskell-blah, #haskell-in-depth, #xmonad, #haskell-overflow and #haskell. I last heard byorgey speak 1d 4h 34m 21s ago.
10:27:46 <Apocalisp> :load Prelude.Dmwit
10:27:48 <dmwit> um
10:27:53 <dmwit> I meant fromMaybe b (...)
10:32:35 <lilac> umm, isn't "lookup k" a function :: [(x, y)] -> Maybe y?
10:32:47 <lilac> @type lookup ?k
10:32:48 <dmwit> err, yep
10:32:49 <lambdabot> forall a b. (?k::a, Eq a) => [(a, b)] -> Maybe b
10:33:07 <dmwit> whoops =P
10:33:28 <dmwit> fromMaybe b (lookup k xs >>= guard . p >> return a) -- most correct one yet!
10:33:28 <tommd> dmwit: How is organizing for Phi going?  I'm tempted to have another hackathon here in Portland but am hesitant over the setup/coordination involved.
10:33:46 <dmwit> tommd: Actually, after the first week or so, there's been almost no effort involved.
10:34:09 <tommd> Reserved a room, announced and made a useful page - that sums up the main efforts then?
10:34:10 <dmwit> A few emails here and there, and that's pretty much it.
10:34:20 <dmwit> yeah
10:34:22 <tommd> Nice to hear
10:34:39 <dmwit> We've got one or two things left to work out -- food, wireless.
10:35:21 <tommd> Yeah, its always good to have a corner with wires too, just in case.
10:35:35 <copumpkin> what's going on here? http://www.e-pig.org/epilogue/ is he maintaining a separate GHC?
10:36:22 <tommd> This looks like it will have a web-programming focus.  I look forward to the results.
10:37:12 <tommd> copumpkin: What makes you ask that?  OPTIONS_GHC used to be common.
10:37:24 <copumpkin> tommd: the pattern keyword he seems to be using?
10:37:27 <dmwit> tommd: Yeah, you should definitely organize your own!
10:37:37 <copumpkin> oh
10:37:40 <copumpkin> it's a function
10:37:42 <jmcarthur_work> fromMaybe b . (a <$) . (guard . p <=< lookup k)
10:37:54 <copumpkin> tommd: still, in the post before that, he has new type syntax
10:37:59 <dmwit> copumpkin: He claims to have submitted some patches or something.
10:38:07 <tommd> dmwit: I'm seriously considering it.  But it would have to be either after fall quarter or next summer.
10:38:15 <copumpkin> dmwit: I haven't seen it anywhere on the ghc lists though
10:38:43 <dmwit> copumpkin: ...oh, submitted to his own repository.
10:38:58 <dmwit> http://personal.cis.strath.ac.uk/~conor/pub/she
10:39:02 <copumpkin> ah
10:39:04 <tommd> 'pattern' is a function
10:39:10 <copumpkin> tommd: you sure about that?
10:39:15 <tommd> I think - not sure.
10:39:18 <copumpkin> tommd: it isn't
10:39:29 <copumpkin> look at its parameter's types, and where they're used
10:40:07 <tommd> Humm, yeah ok.  Odd.
10:41:00 <FunctorSal> "'pattern' is a function"?
10:41:15 <copumpkin> FunctorSal: ?
10:41:52 <copumpkin> the syntax in the second to last post is even weirder
10:42:05 <copumpkin> but I don't object to its goal :P
10:42:23 <FunctorSal> I don't know the context :)
10:42:28 <copumpkin> http://www.e-pig.org/epilogue/
10:42:32 <FunctorSal> oh, not haskell
10:42:37 <copumpkin> it is haskell
10:42:40 <dmwit> copumpkin: type-indexed types...?
10:42:59 <FunctorSal> so i herd you like indices in your types so ...
10:43:00 <copumpkin> dmwit: but nicer syntax for dealing with them
10:43:14 <dmwit> copumpkin: By which of course I mean value-indexed types, i.e. dependent types.
10:43:34 <FunctorSal> copumpkin: that looks a lot like the approach taken by multirec
10:44:03 <monochrom> Hahaha
10:44:13 <copumpkin> dmwit: I'm not really sure what he's going for there... it does look dependent though :)
10:44:36 <copumpkin> damn mysterious blog
10:45:43 <dmwit> copumpkin: It's simple, http://www.e-pig.org/epilogue/wp-content/uploads/2006/11/board-wed-22-nov-06.jpg explains everything
10:45:53 <copumpkin> lol
10:46:01 <copumpkin> thanks!
10:46:01 <monochrom> hahaha
10:46:24 <monochrom> Mad scientist!
10:47:00 <Berengal> I like the top right of that board...
10:47:13 <copumpkin> lol
10:47:51 <LeoD> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6463#a6463 -- is there a better way to implement the sequence function?
10:49:10 <etpace_> Has anyone here read SICP? Would they reccomend it? Would it be worth doing the examples in Haskell instead of lisp to improve my haskell-fu, or does it rely on using lisp?
10:49:19 <dmwit> LeoD: Why, yes, I believe there is!
10:49:45 <Botje> etpace_: you'll run into problems due to haskell's typing with some of them, though.
10:49:56 <dmwit> :t mapM (\(k, v) -> fmap ((,) k) v)
10:49:57 <lambdabot> forall t a (m :: * -> *). (Functor m, Monad m) => [(t, m a)] -> m [(t, a)]
10:50:03 <dmwit> heh
10:50:10 <dmwit> :t mapM (\(k, v) -> liftM ((,) k) v) -- simpler type
10:50:10 <lambdabot> forall t a1 (m :: * -> *). (Monad m) => [(t, m a1)] -> m [(t, a1)]
10:50:23 <LeoD> whoa nice
10:50:31 <LeoD> thanks
10:50:35 <Berengal> etpace_: Great book, and if you're not a total n00b, using Haskell can be worthwhile
10:50:39 <dmwit> :t mapM (uncurry (liftM . (,)))
10:50:40 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => [(a, m a1)] -> m [(a, a1)]
10:51:00 <Berengal> (Some knowledge of lisp and haskell required to not be a total n00b)
10:51:12 <copumpkin> looks like uncurry strength
10:51:49 <etpace_> my knowledge of LISP is reading through the little schemer and the reasoned schemer, and my knowledge of haskell is just finished LYAH, although i've not coded anything of substance -- would you say its worth attempting it in haskell Berengal?
10:51:58 <copumpkin> mapM (uncurry strength) that is
10:52:36 <dmwit> sequence (IL k as) = fmap (IL k) . mapM (uncurry (liftM . (,))) $ as -- LeoD, try this on for size
10:53:12 <copumpkin> Control.Functor.Strong :P
10:53:14 <Berengal> etpace_: If forced at gunpoint, I'd say yes. The best would be to just try it out for yourself though, and if it doesn't work out it doesn't work out
10:53:23 <copumpkin> *try this out for strength
10:53:32 <dmwit> copumpkin: =)
10:53:42 * copumpkin flexes his massive muskles
10:54:20 <Berengal> I haven't read through the book with haskell in mind, but I had no trouble following the lectures
10:54:56 <monochrom> IIRC some advanced parts of SICP is specifically Scheme-ish, e.g., uses macros, exploits dynamic typing...
10:55:05 <Berengal> Most of the dynamic typing can be resolved through the power of algebraic datatypes...
10:55:31 <jeffersonheard> So...  to Saizan and quicksilver, I decided in the end to use unboxed arrays using Double with NaN as my "nothing" value... sort of
10:55:52 <glguy> Is there an arrow that works with UnicodeSyntax as an operator?  seems to be causing me trouble
10:55:58 <monochrom> And of course, SICP introduces the idea of algebra datatypes by implementing that idea in terms of dynamic typing.
10:56:49 <jeffersonheard> I wrote this nice little monad called Translate that takes a get function and set function.  The get/set access the underlying data and translate to/from the unboxed type
10:56:58 <monochrom> IIRC  is already for ->
10:57:01 <jeffersonheard> so I can use anything as a "missing" value
10:57:02 <nibro> any cabal expert who could tell me how to send extra options to ghc when building the Setup.hs file?
10:57:26 <glguy> monochrom, I just figured that out :)
10:57:51 <jeffersonheard> nibro: put in a line called "ghc-options" in the .cabal file
10:57:55 <FunctorSal> \longrightarrow? ;)
10:57:58 <monochrom>  may be worth a try. afterall we write ~> for variable.
10:58:04 <Zao> \longcat
10:58:11 <FunctorSal> (I think it looks just like \rightarrow in fixed fonts)
10:58:19 <FunctorSal> for great obfuscation
10:58:48 <BONUS> ?yow
10:58:48 <lambdabot> I am a traffic light, and Alan Ginzberg kidnapped my laundry in 1927!
10:58:50 <monochrom> There is \longrightarrow in unicode? which codepoint?
10:58:59 <jeffersonheard> FunctorSal: that phrase immediately puts the All Your Base thing in my head
10:59:09 <jeffersonheard> For Great Justice!
10:59:11 <nibro> x27F7
10:59:23 <nibro> ... for \longrightarrow
10:59:24 <FunctorSal> monochrom: hmm it is there in emacs tex mode but I don't actually know if it's a distinct char
10:59:30 <FunctorSal> jeffersonheard: intended :)
10:59:48 <jeffersonheard> FunctorSal: oh good.  I'd hate to think I got that running through my head by accident
10:59:50 <nibro> monochrom: eh, x27F6 I mean
11:00:04 <monochrom> Ah, I see.
11:00:30 <glguy> monochrom, I was thinking of doing:  point1 --> point2
11:00:37 <glguy> for creating my vectors
11:00:48 <glguy> I guess that might not be the most obvious notation
11:00:50 <monochrom>  is the long one,  is the short one
11:00:57 <glguy> I had point1 `to` point2
11:01:15 <FunctorSal> monochrom: looks different in dejavu sans, but probably not in dejavu mono
11:01:23 <monochrom> Yeah, almost indistinguishable in fixed-width.
11:01:29 <Saizan> nibro: --ghc-options=
11:01:32 <nibro> glguy: x21A6 ?
11:01:42 <monochrom> WILL PROGRAMMING BE LIBERATED FROM THE FIXED WIDTH FONT?
11:02:12 <nibro> Saizan: are those ghc-options passed to ghc when compiling Setup.hs?
11:02:15 <FunctorSal> we need LONGCHARACTERS
11:02:18 <Berengal> monochrom: I lambdabot in a floating width irc client. Does that count?
11:02:23 <jeffersonheard> @lambdabot: can haskell liberate programming from the fixed with font?
11:02:23 <lambdabot> Unknown command, try @list
11:02:28 <jeffersonheard> lambdabot: can haskell liberate programming from the fixed with font?
11:02:29 <nibro> Saizan: I tried with ghc-options in the cabal file, but that didn't work
11:02:41 <jeffersonheard> @list
11:02:41 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:02:46 <monochrom>  is worth a try too.
11:03:00 <Badger> @faq can haskell liberate programming from the fixed width font?
11:03:00 <lambdabot> The answer is: Yes! Haskell can do that.
11:03:06 <Saizan> nibro: ghc-options in the .cabal file is used only for building the code, iirc, --ghc-options should add those options to any use of ghc
11:03:09 <jeffersonheard> Badger, thank you.  that wsa driving me nuts
11:03:12 <Badger> @vixen can haskell liberate programming from the fixed width font?
11:03:12 <lambdabot> Ooh, functional programmers are so hot!
11:03:15 <monochrom> Berengal heh
11:03:42 <monochrom> haha we're hot
11:03:44 <FunctorSal> there are lots of arrows in unicode... kcharselect 4 has them all in a group (or several groups actually)
11:03:55 <nibro> Saizan: yep, you're right, thanks!
11:04:20 <saml> how can I test if a string ends with .txt ?
11:04:21 <nibro> Saizan: any idea how I can make that transparent for an installer of my package?
11:04:32 <Berengal> saml: isSuffixOf
11:04:42 <FunctorSal> 
11:04:54 <Heffalump> Badger: seems unlikely given the identation-specific syntax!
11:05:02 <Heffalump> s/identation/indentation/
11:05:03 <monochrom> _
11:05:05 <saml> Berengal, thanks to be you
11:05:11 <Saizan> nibro: {-# OPTIONS_GHC .. #-} in the Setup script?
11:05:33 <FunctorSal> 
11:05:35 <nibro> Saizan: that was my first attempt, but it doesn't seem to work... I'll dig a bit more though, thanks for the help
11:05:39 <FunctorSal> these really are obscure.
11:05:51 <Saizan> nibro: what's the flag, btw?
11:06:12 <Saizan> those are squares
11:06:18 <Saizan> :)
11:06:25 <monochrom> _
11:07:07 <nibro> Saizan: I have a hs-source-dirs directory called 'src', and I want to make my test machinery aware of that location so it can build against it
11:07:17 <nibro> Saizan: so I want to add a -isrc flag
11:07:56 <nibro> Saizan: not even -v workes in the OPTIONS_GHC pragma... ???
11:08:40 <Saizan> mh, maybe it's GHC_OPTIONS ?
11:09:01 <Saizan> there are some flags that won't work there, however
11:09:17 <nibro> Saizan: no, it's definitely OPTIONS_GHC
11:09:32 <nibro> Saizan: -i is a "static" flag, so it makes sense for it to not work there
11:10:07 <LeoD> debugging memory leaks is hard :(
11:10:21 <Saizan> tried heap profiling?
11:10:25 <LeoD> yea
11:11:05 <monochrom> Not hard.
11:14:40 <saml> how do you print usage string? like in bash, I do  cat <<HEREDOC Usage: $0 arg1 arg2  ...
11:15:55 <idnar> what the heck
11:16:00 <saml> wow printf!
11:16:18 <idnar> somebody sent something into this window that irssi /really/ didn't like
11:16:38 <copumpkin> idnar: um less than less than heredoc?
11:16:51 <copumpkin> idnar: not sure if that would mess it up
11:16:56 <idnar> comdoubtful
11:16:57 <idnar> err
11:16:59 <idnar> copumpkin: doubtful
11:17:05 <saml> > printf "Usage: %s arg" "./bash"
11:17:06 <lambdabot>   Add a type signature
11:17:11 <idnar> copumpkin: but all I know is, I had about a page of blank space that spilled over into the status bar and everything
11:17:14 <saml> > printf "Usage: %s arg" ("./bash" :: [Char] )
11:17:15 <lambdabot>   Add a type signature
11:17:30 <saml> lambdabot, you add a type signare
11:17:43 <copumpkin> > printf "Usage: %s arg" ("./bash" :: [Char] ) :: String
11:17:44 <lambdabot>   "Usage: ./bash arg"
11:17:45 <mauke> saml: it needs a type signature for the result, not arguments
11:18:02 <saml> ah thanks
11:18:12 <mauke> > ""++ printf "%d %c" 64 64
11:18:13 <lambdabot>   "64 @"
11:20:01 <LeoD> ok, finding memory leaks isn't that hard, getting lazy evaluation right is :P i had an unevaluated thunks it seems
11:29:42 <saml> drop (length l - 3) l  -- this is a good way to get suffix?
11:32:54 <kpreid> > let last3 (_:xs@(_:_:_:_)) = last3 xs; last3 xs = xs in last3 "abcdefg"
11:32:55 <lambdabot>   "efg"
11:32:59 <kpreid> > let last3 (_:xs@(_:_:_:_)) = last3 xs; last3 xs = xs in last3 "fg"
11:33:00 <lambdabot>   "fg"
11:33:13 <kpreid> this might be more efficient by a constant factor...
11:54:32 <FunctorSal> saml: or take 3 . reverse
11:54:36 <byorgey> anyone know of a highly optimized Haskell implementation of modular exponentiation?
11:54:40 <FunctorSal> or use an array ;)
11:54:50 <FunctorSal> err, reverse . take 3 . reverse
11:54:51 <saml> > (take 3 . reverse) "sample.txt"
11:54:52 <lambdabot>   "txt"
11:54:57 <saml> > (take 3 . reverse) "sample.abc"
11:54:58 <lambdabot>   "cba"
11:55:00 <saml> lol
11:55:01 <copumpkin> byorgey: I wrote a primop binding for gmp's version but it's not anywhere easy
11:55:15 <FunctorSal> > (reverse . take 3 . reverse) "tac.gnol"
11:55:16 <lambdabot>   "nol"
11:55:31 <copumpkin> @src (^)
11:55:31 <lambdabot> x ^ 0            =  1
11:55:31 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
11:55:31 <lambdabot>   where f _ 0 y = y
11:55:31 <lambdabot>         f x n y = g x n
11:55:31 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
11:55:33 <lambdabot>                       | otherwise = f x (n-1) (x*y)
11:55:35 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
11:56:09 <portnov> good smile: _^_
11:56:28 <copumpkin> byorgey: you could just add mod to the multiplications there unless you need blistering speed :P
11:57:34 <byorgey> copumpkin: yes, I've already written a version using repeated squaring and intermediate mod operations.  But I really want one that is as blisteringly fast as possible.
11:58:05 <byorgey> I have a program where currently modular exponentiation is taking around 30% of the running time, so any optimization to that is a big win.
11:58:36 <copumpkin> byorgey: you could manually ffi bind to the gmp function
11:58:37 <monochrom> "Montgomery multiplication" may help.
11:58:55 <SamB> copumpkin: you have that code somewhere, right?
11:59:16 <byorgey> copumpkin: well, this is for a programming competition where the code has to run on their server, so I probably can't use FFI =)
11:59:18 <copumpkin> yeah, not sure where, and it was as a primop before gmp got split out of ghc
11:59:24 <copumpkin> byorgey: aw
11:59:36 <copumpkin> SamB: so it'd need a few tweaks to the cmm
11:59:42 <SamB> copumpkin: I thought you'd tried it a bunch of ways
11:59:51 <FunctorSal> byorgey: manual loop untrolling? ;)
11:59:55 <copumpkin> SamB: the modular exponentiation?
12:00:02 <SamB> yeah
12:00:08 <byorgey> FunctorSal: hmm, maybe =)
12:00:09 <FunctorSal> also make sure your stuff is getting specialised to the # operations
12:00:14 <SamB> maybe that was another guy
12:00:18 <byorgey> FunctorSal: how do I do that?
12:00:21 <copumpkin> SamB: not really :)
12:00:56 <byorgey> also, unfortunately, Int32 is slightly too small =(
12:00:56 <FunctorSal> byorgey: hmm I'm not an expert but you can see which rules fire by compiling with "-ddump-simpl-stats", and you could look at the core (e.g. with the ghc-core package) to make sure
12:01:08 <byorgey> ok, thanks
12:01:43 <byorgey> I may also just try porting my solution to C.  but I would be ashamed.
12:01:55 <FunctorSal> so are you using Int64?
12:02:09 <FunctorSal> hmm, how can you use C with no FFI allowed?
12:02:22 <byorgey> I've tried that, but Int64 seems not to give me any speed benefit over just using Integer.
12:02:47 <byorgey> FunctorSal: you can submit solutions in many different languages.
12:03:04 <SamB> maybe plain-old C is a bit more reliable than trying to FFI on someone else's server where you aren't sure what's there ...?
12:03:07 <FunctorSal> hmm I'm by no means a CPU expert but I would have thought Int64 is still way faster than Integer even on 32 bit systems :)
12:03:26 <copumpkin> SamB: well my point about FFI'ing to gmp is that gmp is linked to your program anyway
12:03:34 <SamB> FunctorSal: it's nothing to do with the CPU
12:03:34 <byorgey> doesn't seem to make a difference here (32-bit).
12:03:49 <copumpkin> it's a bit like ffi'ing to memcpy or the like
12:03:49 <SamB> GHC generates lousy code for Int64 on 32-bit arches
12:04:01 <byorgey> ah, well, there you have it =)
12:04:11 <SamB> copumpkin: except that sounds a lot dummer
12:04:37 <copumpkin> SamB: ?
12:04:39 <SamB> copumpkin: it might be faster to use memcpy written in haskell
12:04:44 <copumpkin> why?
12:04:53 <SamB> inlining
12:04:59 <SamB> depends on the size of the region to copy
12:05:04 <SamB> I guess
12:05:09 <copumpkin> yeah, you'd obviously use it on large chunks of memory
12:05:10 <FunctorSal> SamB: maybe roll your own pair-of-Int32s then?
12:05:59 <SamB> FunctorSal: would work okay if you have a Int32# -> Int32# -> (# Int32#, Int32# #) multiply primop
12:08:59 <copumpkin> I'd like to see a primop like that
12:09:07 <copumpkin> there's something that vaguely approximates it
12:13:37 <copumpkin> what is the point of disallowing unboxed tuples on the left of (->) ?
12:13:45 <copumpkin> :k (->)
12:13:46 <lambdabot> ?? -> ? -> *
12:16:44 <thoughtpolice> weee
12:16:57 <copumpkin> thoughtpolice: wuzzup?
12:16:58 * thoughtpolice is getting an unregistered mac osx/64bit ghc again
12:17:03 <thoughtpolice> copumpkin: DONE WITH CLASS OMG
12:17:08 <copumpkin> zomg!
12:17:30 <thoughtpolice> took my final today. i did like that class a lot, though
12:17:37 * thoughtpolice is very fond of logic and had a very good professor
12:18:02 <copumpkin> :o
12:18:09 <thoughtpolice> copumpkin: so, more time to spend on ghc hacking!
12:18:15 <copumpkin> awesome!
12:21:42 <Botje> thoughtpolice: lucky you
12:21:49 <Botje> I hada thesis defense on monday
12:22:04 <Botje> and on tuesday i was already tasked with writing up a phd proposal :p
12:27:48 <hackagebot> Pipe 2.1.2 - Process piping library (MattiNiemenmaa)
12:30:02 <thoughtpolice> Botje: :)
12:36:29 <copumpkin> thoughtpolice: so your current plan is to get a registered build going and figure out what's crashing?
12:38:18 <monochrom> @hpaste2
12:38:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:38:22 <monochrom> Hmm.
12:38:34 <michie1> hmm, general style question from a complete newbie:  I need to parse a file with lines of numbers.  Would I build something using parsec for that, or use regexes, or just use read in some form?
12:38:56 <michie1> I'm looking for "how it's supposed to be done" recommendations
12:39:18 <monochrom> I would first go for: n<-readLn; ...; loop back
12:39:50 <michie1> eh, there's multiple numbers per line, although I suppose that shouldn't be a complication.
12:39:54 <michie1> so, just use read then?
12:40:14 <mauke> michie1: fmap (map read . words) . readFile
12:41:29 <monochrom> When the Iteratee framework becomes mature, we will be all using that. :)
12:41:39 * Heffalump hopes not
12:41:46 <Heffalump> I like lazy data
12:41:50 <michie1> mauke: that looks like a good starting point, thanks.  I just tend to be unsure about these things; I've programmed imperatively since I was 8 or 9.  Finding the way to do things in Haskell takes some adjustment.
12:41:59 <Heffalump> we just need to learn how to tame it properly
12:42:38 <kig> does currying partially evaluate monadic functions? like if i have foo x y = do {v <- somethingExpensive x; somethingCheap v y}, does mapM_ (foo x) [1..1000] call somethingExpensive only once or a 1000 times?
12:43:52 <michie1> kig: I think it'll give you a list of partial functions, completely unevaluated.  I may be completely wrong, but I want to see if people dismiss my hypothesis
12:43:58 <monochrom> 1000 times. For example putStrLn. You can observe 1000 times.
12:44:55 <thoughtpolice> copumpkin: that seems to be the idea
12:45:40 <sjanssen> kig: mkFoo x = do { v <- somethingExpensive x; return (\y -> somethingCheap v y)}; do foo <- mkFoo x; mapM_ foo [1 .. 1000]
12:48:17 <kig> ok, thanks
12:58:21 <idnar> Peaker: that producer / consumer thing looks quite nice, btw
12:58:51 <idnar> Peaker: it sort of feels like a python generator or coroutine or whatever, except inside-out
13:01:57 <hackagebot> HaskellForMaths 0.1.4 - <i>Added by DavidAmos, Thu Jul  2 20:01:04 UTC 2009.</i>
13:19:05 <ehird> Is there any decent work going into GHC-to-JVM? I'm curious.
13:19:19 <Zao> ehird: There was a thread on -cafe the other day about it.
13:19:23 <ehird> Yes.
13:19:30 <ehird> Hm.
13:20:15 <ehird> OTOH jvm languages are unappealing because of their infrastructure. No way around that.
13:37:33 <hackagebot> HDBC-sqlite3 2.1.0.2 - Sqlite v3 driver for HDBC (JohnGoerzen)
13:37:40 <LeoD> does anyone know if there are problems with HOpenGL's genObjectNames? isObjectName always returns false for the names it generates.
13:40:28 <Cynner> Download new music, films, games and lot of more, check it - http://www.lostworlds.lv/go.php?1139730844
13:41:10 --- mode: ChanServ set +o sjanssen
13:41:14 --- mode: sjanssen set +b *!*n=plinka@87.110.242.*
13:41:14 --- kick: Cynner was kicked by sjanssen (sjanssen)
13:42:31 --- mode: ChanServ set -o sjanssen
13:43:00 <Badger> #haskell seems to get an alarming number of those.
13:43:18 <sjanssen> we're one of the most populated channels
13:43:50 <monochrom> "Fight spam. Avoid success at all costs."
13:44:02 <dankna> So I'm trying to learn Template Haskell for a small-but-deep project I have in mind.  My mastery of even plain Haskell is not great, but...
13:44:10 <dankna> I think the compiler is telling me that what I want is flat-out impossible.
13:44:25 <sjanssen> dankna: what are you trying to do?
13:44:32 <dankna> The basic idea is to bring Lisp-style exceptions to Haskell, because I used to be big into Lisp and they're one of the few things I miss from it.
13:44:47 <dankna> That is, separate "restarts" (the actual transfer of control) from the "throw" mechanic.
13:45:19 <dankna> It's somehow a little hard to explain how that works without going into examples, but...
13:45:38 <dankna> http://www.nopaste.com/p/aODPCtNtv I nopasted a small amount of code and the error message I get.  Maybe that will help explain, or not?
13:46:20 <dankna> The idea is that one would use restartBind to say "the restarts with these names, which are just strings, mean to transfer control to here",
13:46:24 <dankna> and the template system would generate an anonymous exception
13:46:32 <dankna> and use that exception to perform the control transfer
13:47:07 <dankna> the error I get seems a little peripheral to the heart of the issue, so it seems as though there ought to be some way to reorganize things so I don't need to do what it tells me I can't do
13:47:22 <dankna> but I think I'm out of my depth.  so before I give up I thought I'd come talk about it in here :)
13:48:01 <dankna> note that there's nothing in the code sample I pasted about actually performing the transfer, yet; I'm still stuck on even generating the exception
13:48:28 <sjanssen> dankna: it is true that you can't do this
13:48:49 <dankna> well, I figured as much
13:48:57 <lpsmith> dankna:  you could do it in a monad,  or some other technique to declare effects
13:48:57 <dankna> I saw something in the docs to that effect, so.
13:48:58 <sjanssen> TH is expanded at compile time, you're attempting a splice that involves a value passed at runtime
13:49:03 <dankna> hm
13:49:05 <dankna> so I am
13:49:51 <dankna> well, ideally I want something that IS expanded ad compile-time.  do I need to make restartBind itself into a template function (or whatever they're called), then?
13:50:20 <dankna> lpsmith: hmm... if you could expand on that? :)
13:50:42 <sjanssen> dankna: you'd need to do something like that, yes
13:50:57 <sjanssen> but I think you're going to have trouble making Haskell's exception act like Lisp's
13:51:04 <SamB> does anyone know a LaTeX fixpoint-finder that works a bit better than rubber?
13:51:06 <dankna> I guess my thinking was "the compiler knows that this value is constant, so it can precompute the expression when it compiles".  but that's not really the same thing as it being real compile-time, is it.  hm.
13:51:19 <dankna> well, yes, I didn't expect it would be easy.  but any insight is welcome.
13:51:39 <sjanssen> but, I think you could make your own monad with semantics similar to Lisp
13:51:57 <sjanssen> with a continuation monad or something
13:52:22 <dankna> I guess since exceptions are only catchable in IO anyway, having to do everything within that monad isn't really a big deal
13:53:08 <dankna> the semantics I want don't really involve continuations... hm... I need to chew on it and come up with a new implementation strategy, I guess
13:55:13 <Taejo> is it possible to coerce values to a different type (the type has a phantom argument that I want to change) without copying?
13:55:16 <sjanssen> dankna: maybe I'm misremembering how Lisp's exceptions work
13:55:39 <dankna> well, as I said, it's a little hard to explain, but I can try if you're curious
13:55:52 <sjanssen> dankna: sure
13:55:55 <SamB> Taejo: well, there is unsafeCoerce
13:56:08 <SamB> but of course you'd better be sure that's really a phantom
13:56:09 <dankna> so in Lisp you've got "conditions" (exceptions), "handlers", and "restarts"
13:56:22 <lilac> i'm getting a stack overflow. how can i find out which thunks are being evaluated?
13:56:43 <dankna> the first thing your program does when it's executed is bind some restarts, which are points at which control can be resumed
13:57:10 <dankna> a restart is just a name, some parameters, and a spot in the code to jump back to.  if we were using C it would be doable with setjmp/longjmp.
13:58:06 <dankna> restarts, once bound, have dynamic extent (wouldn't be much good if they didn't), so you can see them from functions called by the one that actually bound them
13:58:08 <Taejo> SamB: I'm compiling lambda terms to SK combinators, and I have a GADT where expressions with lambdas have type Term Lambda, and I have a compile :: Term Lambda -> Term NoLambda, but I'd like it to share subterms that where lambda-less to start with
13:58:10 <dankna> then there are conditions, which are relatively rich objects; they have classes and inheritance and all that good stuff.
13:58:27 <dankna> and handlers
13:58:37 <Taejo> SamB: since Lambda and NoLambda are uninhabited, they have to be phantoms
13:58:59 <dankna> handlers ALSO have dynamic extent
13:59:10 <dankna> when a condition is signaled, the innermost applicable handler (as determined by type compatibility) is called on it
13:59:23 <dankna> the important thing is that this happens before the stack has been unwound at all
13:59:30 <dankna> no transfer of control has yet taken place
13:59:43 <dankna> if a nonlocal transfer is to happen, making it so is totally up to the handler
13:59:45 <lilac> can i get ghci to give me a stack trace for the running code?
13:59:47 <dankna> which it can do by invoking a restart
13:59:50 <leithaus_> dankna: have you looked at delimited continuations?
13:59:59 <dankna> I have not, and I'll do that, thank you
14:00:16 <dankna> it can also just return control to the place that signalled the condition as though nothing has happened, which it does by just returning
14:00:29 <malumalu> do I have to have a monad in my function type declaration if I want to use _do_?
14:00:33 <sjanssen> dankna: exceptions without unwinding the stack will be the tricky (impossible?) part with native Haskell exceptions
14:00:40 * dankna nods
14:00:43 <malumalu> (stupid question, I guess)
14:00:50 <dankna> I thought they might be, I was willing to compromise on that point
14:00:57 <mauke> sjanssen: can't you just call a function?
14:01:10 <dankna> I think the restarts are the real power of it, although it's not totally clear to me
14:01:19 <dankna> just to finish my thought before I address that
14:01:22 <sjanssen> mauke: the exception has to be intercepted where it was thrown, not where it's caught
14:01:37 <mauke> I mean, it was some time ago, but I thought I could implement lisp-like exceptions in perl, on top of its normal exception handling
14:01:40 <dankna> new handlers are used to do powerful things like make all errors go to the closest "abort" restart
14:02:00 <dankna> or make them pause execution while the user chooses a restart by hand
14:02:12 <mauke> sjanssen: yeah, so you use your own throw function
14:02:35 <sjanssen> mauke: note my statement said "native Haskell exceptions"
14:02:37 <dankna> that was my strategy, yeah.  call your own throw function which hooks in before the real throw.
14:02:59 <dankna> or would have been my strategy.  I'm reevaluating whether this is doable by me at this time :)
14:03:31 <sjanssen> dankna: but is this useful if every third party function uses the standard throw?
14:03:42 <mauke> "native Haskell exceptions" doesn't mean you have to use Control.Exception.throwIO
14:03:46 <dankna> well, it would become a dialect
14:03:52 <dankna> which one would try to gain adoption for
14:04:01 <dankna> yes, it would be some trouble when interacting with libraries that don't use it
14:04:23 <mauke> I understood it to mean "use Haskell exceptions internally instead of full-blown continuations"
14:04:42 <hackagebot> hlint 1.6.3 - Source code suggestions (NeilMitchell)
14:04:56 <sjanssen> mauke: yeah, I guess my statement wasn't clear
14:05:35 <dankna> ideally the interface to throw would be pretty much the same, so porting code to use it could be as simple as changing which module is imported, for code that doesn't get into the internals of exceptions
14:05:38 <sjanssen> I still think a dedicated monad would be better, because you can store all your handlers and such in the monad
14:05:55 <dankna> well, that's the approach I'll probably look at if I continue this, yes
14:06:20 <SamB> that kind of stuff makes callbacks hell, though :-(
14:06:42 <hackagebot> hack-contrib 2009.7.3 - Hack contrib (JinjingWang)
14:08:28 <dankna> anyway.  so that's what I'm trying to do.  at least I don't dream small, right?
14:09:24 <Berengal> Haskell probably makes for a good web language... pages are simply functions of type Input -> ([IO ()], Output)
14:10:09 <SamB> Berengal: eh?
14:10:19 <SamB> usually you need to do some IO to work out the Output ...
14:10:24 <ben> More like Input -> IO Output
14:10:44 <Berengal> SamB: Yeah, ben got the type more right
14:10:57 <Berengal> Still
14:11:12 * glguy wonders how Haskell's  Input -> IO Output type might make it more suited for web programming
14:11:28 <leithaus_> dankna: from what i've seen, i'm pretty sure you're looking for delimited continuations: http://okmij.org/ftp/
14:11:37 <malumalu> do I have to have a monad in my function type declaration if I want to use _do_?
14:11:40 <michie1> up to some extent, can't all programs be summarised using a relatively simple type signature?
14:12:01 <dankna> leithaus: Thanks... doing some reading on them now.
14:12:04 <Berengal> glguy: As opposed to hacking state into it in most other languages
14:12:13 <jmcarthur> malumalu: even with a monad, i would discourage the use of do unless what you are doing is inherently imperative, like IO
14:12:16 <Berengal> michie1: IO a
14:12:16 <mauke> malumalu: why do you want to use do?
14:13:26 <glguy> if you are looking to add in a bit of extra monadishness and do-sugar, try the Id monad
14:13:50 <monochrom> All programs have type: Blah.
14:14:04 <glguy> monochrom, I've never used a type "Blah", tbh
14:14:05 <glguy> ;)
14:14:06 <Berengal> Monads are inherently sequential. It's what (>>) does...
14:14:14 <Berengal> (Note, sequential /= imperative)
14:14:18 <ehird> no
14:14:19 <malumalu> mauke: I'm computing a score1, and if score1 is >1 I want to compute score2. if score1 <= 1, score1 should be returned, otherwise score2
14:14:20 <jmcarthur> nope
14:14:22 <dons> >>= you mean :)
14:14:23 <ehird> monads are inherently dependive
14:14:27 <dons> creates a data dependency
14:14:27 <ehird> they have dependencies
14:14:29 <mauke> numbers are inherently sequential; it's what (-) does
14:14:30 <ehird> no ordering implied
14:14:41 * glguy <3 IRC
14:15:11 <mauke> malumalu: how is 'do' helpful in that situation?
14:15:16 <Berengal> Sequential data depencies then, to be even more precise
14:15:26 <michie1> another newbie question: What's the difference between a monadic dependency relation, and the kind of relation imposed by `seq` or $!?
14:15:36 <michie1> (other than syntax)
14:15:53 <jmcarthur> i'd say even saying "dependencies" is pushing it. if i have a Writer but at the top level i only evaluate the return value and not the Monoid part, i didn't create any dependencies
14:15:53 <sinelaw> I have a moto, now just need to invent a project that will use it.
14:16:07 <sinelaw> "To protect and to swerve"
14:16:14 <malumalu> mauke: I come from an imperative background, so that was my first try
14:16:15 <sinelaw> it must involve robots, i guess
14:16:15 <deech`> Hi all, in the Maybe monad, is there a way of trying two Maybe ops in case of them of Nothing?
14:16:22 <mauke> malumalu: that's not a real answer
14:16:28 <mauke> malumalu: how would you do it with 'do'?
14:16:39 <Heffalump> deech`: mplus
14:16:39 <ehird> deech`: You mean like "whichever of these isn't Nothing"?
14:16:43 <Berengal> jmcarthur: The monoid is sequentially dependent on the order of computation, even if you're not depending on the monoid afterwards
14:16:44 <ehird> Yeah, Heffalump.
14:16:59 <deech`> Heffalump: awesome, thanks!
14:17:20 <malumalu> mauke: firstScore <- blah; if score1 <= 1 them score1 else score2
14:17:34 <malumalu> eh, score1 <- blah
14:17:45 <jmcarthur> Berengal: what if the monoid is commutative?
14:17:45 <mauke> malumalu: let score1 = blah in if score1 <= 1 then score1 else score2
14:17:51 <Berengal> let score1 = blah in if score1 < 1 then score1 else score2
14:17:57 <mauke> malumalu: you don't need 'do' to give names to intermediate results
14:18:30 <malumalu> mauke: oh, thank you :)
14:19:06 <mauke> hell, (\score1 -> if score1 <= 1 then score1 else score2) blah
14:19:09 <Berengal> jmcarthur: Then all hell breaks loose
14:19:14 <jmcarthur> ;)
14:19:37 <Berengal> Meh, it's only one way to look at it. It makes sense in some contexts, but not equally much in others
14:19:39 <jmcarthur> A Monad is nothing more than a value that carries hidden information with it, as I see it.
14:20:02 <jmcarthur> I would certainly not say that Monads inherently have anything to do with imperative code, sequencing, or data dependencies.
14:20:28 <olsner> it's a type class and that's it :)
14:20:28 <jmcarthur> *Anything* can have something to do with data dependencies. This is not even unique to just a subset of Monads.
14:21:27 <gwern> @quote Jonathan
14:21:27 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
14:21:55 <monochrom> It's just philosophy.
14:22:11 <gwern> @quote piro
14:22:11 <lambdabot> No quotes match. I am sorry.
14:22:15 <gwern> lies
14:22:30 <jmcarthur> olsner: Some might say that Monads capture side-effects. I could see this as a reasonable generalization.
14:22:34 <leithaus_> Berengal: monads are not inherently sequential
14:22:47 <Berengal> jmcarthur: Sure, in some cases the "hidden information" perspective works better, but you wouldn't be too wrong to think of it as sequencing computations in a context from time to time.
14:22:47 <gwern> @remember JonathanShapiro The ML module system is fully understood only by David MacQueen, and only on alternating weeks.
14:22:47 <lambdabot> Okay.
14:23:02 <jmcarthur> Berengal: right, but you can't say that's what a Monad *is*
14:23:04 <gwern> @flush
14:23:42 <gwern> hm. where did jonathan shapiro et al say monads don't scale...
14:23:57 <jmcarthur> "<Berengal> Monads are inherently sequential." and "<Berengal> Sequential data depencies then, to be even more precise" are what i'm disagreeing with
14:23:58 <olsner> jmcarthur: hmm, doesn't that fall into the same trap as every other "monads are" statements? I think you can *use* monads to capture side-effects, which isn't the same as to say that monads in general capture side-effects
14:24:08 <gwern> ah, 'don't scale' was the right phrase
14:24:11 <gwern> http://www.bitc-lang.org/docs/bitc/bitc-origins.html
14:24:14 <Berengal> jmcarthur: Not objectively, no, but from a certain perspective they are
14:24:16 <jmcarthur> olsner: this is with a definition not limited to IO
14:24:18 <leithaus_> In Caires' Spatial Behavioral Types paper of 06 he gives a really nice monadic characterization of parallel computation
14:24:23 <jmcarthur> Berengal: only some of them, though
14:24:31 <gwern> @quote told
14:24:31 <lambdabot> stepcut says: I wish someone had told the designers of XML about monoids :(
14:24:33 <jmcarthur> which means this isn't something you can generally say about monads
14:24:52 <gwern> @quote Neo
14:24:52 <lambdabot> gwern says: Unfortunately Neo, no one can be *told* what the Monad is.
14:25:15 <leithaus_> parallel composition is defined by (e1 | e2 ) := let x1 = e1 , x2 = e2 in nil
14:25:17 <leithaus_> while sequential composition is defined by (e1 ; e2 ) := let x1 = e1 in e2
14:25:32 <Berengal> jmcarthur: I still haven't found a monad for which the perspective completely breaks down
14:25:46 <jmcarthur> Berengal: a commutative Writer doesn't cut it?
14:25:51 <leithaus_> the let form is given by let (ptn = e)* in e
14:26:07 <leithaus_> this is a monad
14:26:43 <Berengal> jmcarthur: It's somewhat strained, but doesn't break down completely
14:27:04 <jmcarthur> Berengal: where is the sequentiality in that?
14:27:11 <pikhq> ListT?
14:27:29 <olsner> "Support for state in Haskell exists in the form of the I/O monad" <-- this really makes it sound like the author doesn't know what he's talking about, which is strange given the consequent statement that monads don't scale
14:27:55 <jmcarthur> olsner: link?
14:28:04 <olsner> there are like a hundred ways haskell has "support for state" not involving the IO monad...
14:28:12 <monochrom> Is this some kind of "monochrom's law"? That if I say "it's philosophy" then a dead thread is resurrected? Kind of like an opposite of Godwin's law?
14:28:16 <olsner> jmcarthur: http://www.bitc-lang.org/docs/bitc/bitc-origins.html
14:28:21 <kosmikus> olsner: it's just a very imprecise statement
14:29:04 <Berengal> jmcarthur: You won't get the wrong results even if you think of it as a sequence of computations
14:29:25 <jmcarthur> Berengal: but that's clearly not what it *is*
14:29:29 <lilac> how does one track down stack overflows in programs compiled with GHC?
14:29:32 <jmcarthur> i think it's misinformation to say that it is
14:29:33 <Berengal> jmcarthur: From that perspective it is
14:29:51 <Berengal> Of course, there are better ways to look at commutative writers...
14:30:59 <jmcarthur> Berengal: Why would it ever be beneficial to pretend that something which is not necessarily sequential is so?
14:31:11 <jmcarthur> it's simply an unknown
14:31:42 <Berengal> Which perspective is best doesn't always depend on which monad you're in either. For example, the list monad can be seen both as computations on the product of lists, and as nondeterministic computation
14:31:46 <olsner> kosmikus: yeah, I suppose he's referring to "state" as in "hardware state" and "all that low-level stuff you do in C"
14:31:46 <jmcarthur> This seems about as sensible as claiming that Monoids are inherently commutative just because some are.
14:31:53 <troutwine> zip discards elements of longer list inputs. Is there an implementation of a zip-like function that doesn't trim excess elements about?
14:31:57 <jmcarthur> err
14:31:57 <yairchu> lilac: Good question. You can use Debug.Trace.trace if there isn't a more adequate solution
14:31:59 <jmcarthur> i worded that wrong
14:32:11 <jmcarthur> * This seems about as sensible as claiming that Monoids are inherently not commutative just because some aren't.
14:32:36 <jmcarthur> and by "not commutative" i mean "sequential"
14:32:44 <olsner> lilac: I think you can compile with profiling and run with (iirc) +RTS -xc to get a stack trace when the error happens
14:32:48 <troutwine> It's a quick modification, I'd just rather not duplicate the wheel.
14:33:36 <copumpkin> byorgey: what did you end up doing about your modexp?
14:33:40 <ehird> troutwine: what would it do instead?
14:33:56 <byorgey> copumpkin: nothing yet, I've been getting some real work done instead =)
14:34:07 <byorgey> copumpkin: but I think I will try porting my code to C
14:34:14 <copumpkin> oh no! :(
14:34:53 <troutwine> ehird: The excess would be paired with [].
14:35:09 <ehird> troutwine: ? please give an example.
14:35:09 <copumpkin> byorgey: not c!! what's the contest btw?
14:35:28 <lilac> olsner: thanks. looks like the call stack is only 4 elements deep, but it's used 8MB of stack space ;-/
14:35:42 <olsner> I think you only get the last few entries
14:35:48 <ehird> lilac: thunks?
14:36:10 <monochrom> your_zip [1,2] [3] = [(1,3), (2, [])] ?  That's a type error fail.
14:36:15 <byorgey> copumpkin: http://www.codechef.com/JULY09/
14:36:18 <troutwine> ehird: Ah, I guess my needs aren't generally useful. Sorry, not enough sleep of late.
14:36:27 <byorgey> copumpkin: it's fun, you should participate =)
14:36:38 <ehird> troutwine: i just don't understand
14:36:38 <Berengal> jmcarthur: It's not about claiming they're one thing or another, it's about finding analogies that work
14:36:43 <ehird> as monochrom says, it won't type
14:36:59 <lilac> ehird: i assume so, but i'm not sure what i need to make strict
14:37:02 <ehird> unless you have an [[a]]
14:37:06 <ehird> lilac: bang patterns, seq, etc
14:37:08 <monochrom> I am sorry but this is not Scheme and you can't just use nil everywhere.
14:37:08 <jmcarthur> Berengal: Analogies are the kind of thing that confuse people, in my opinion. Too easy to draw false assumptions.
14:37:26 <ehird> jmcarthur: In that sense, analogies are like ...
14:37:26 <monochrom> Analogies don't work.
14:37:58 <copumpkin> byorgey: wow, they actually have a reasonably recent GHC
14:38:00 <SubStack> if analogies were cars, they'd crash all the time
14:38:07 <Berengal> jmcarthur: Saying (tell (Sum 4) >> tell (Sum 5)) first adds 4 then adds 5 is (maybe) wrong, but you won't get wrong results
14:38:08 <byorgey> copumpkin: yes, they do!
14:38:09 <monochrom> Analogies are like watching Japanese manga to quelch your thirst for a spouse.
14:38:10 <troutwine> ehird: Yeah. I need something like mangle :: [[a]] -> [[b]] -> ([a], [b]). If [[a]] is longer than [[b]] the second element of the tuple should just be [], for my purposes.
14:38:16 <troutwine> ehird: Make sense?
14:38:22 <ehird> troutwine: Right.
14:38:30 <byorgey> copumpkin: my Haskell-optimizing-foo is just not (yet) that great.
14:38:34 <ehird> troutwine: You could do a zipWith giving Maybes.
14:38:38 <byorgey> er, I mean -fu =)
14:38:40 <ehird> For a more general thingy.
14:38:46 <copumpkin> byorgey: definitely looks fun :) now if only I didn't have an important upcoming deadline :(
14:39:06 <lilac> ehird: i want to find out /what/ to make strict (not how) :)
14:39:08 <byorgey> copumpkin: when's the deadline?  the contest goes for another 10 days... =)
14:39:27 <byorgey> copumpkin: anyway, it looks like they will have a contest every month
14:39:28 <ehird> lilac: anything you pass, give a name or otherwise use is suspect. use the profiler. show us the code.
14:39:29 <jmcarthur> Berengal: I wouldn't get wrong results by assuming that Monads are like unicorn sex, either, but that doesn't mean it's helpful.
14:39:32 <lilac> hooray, now my program segfault
14:39:34 <copumpkin> byorgey: I might be able to cram something in then, we'll see :)
14:39:34 <byorgey> so you can always do the next one.
14:39:57 <ehird> lilac: uh oh, ghc bug?
14:39:59 <Berengal> jmcarthur: It might be, in the unicorn monad.
14:40:08 <ehird> SexT Unicorn
14:40:10 <jmcarthur> @quote unicorn
14:40:10 <lilac> ehird: second one today
14:40:11 <lambdabot> No quotes match. There are some things that I just don't know.
14:40:17 <ehird> lilac: you're unlucky
14:40:17 <jmcarthur> Really? No unicorn quotes?!
14:40:27 <lilac> ehird: but i'm on 6.8.2 so i guess this is partly my fault
14:40:34 <ehird> lilac: Don't do that
14:40:48 <lilac> tell that to ubuntu, not me ;-)
14:41:01 <Berengal> jmcarthur: Anyway, if your perspective isn't helping, find a new one. I was perhaps a bit strong in my initial statement...
14:41:09 <mansour> what is the power function in haskell, for example if I want to get 5^2 = 25, how do i do it ?
14:41:16 <Berengal> > 5^2
14:41:17 <lambdabot>   25
14:41:20 <monochrom> 5^2 does it
14:41:38 <pikhq> :t (^)
14:41:39 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
14:41:40 <Berengal> mansour: Also, (^^) and (**)
14:41:44 <ehird> When in doubt, just type it :)
14:41:58 <mansour> thank you
14:42:03 <mansour> hum
14:42:16 <mansour> I didn't know anything about ^^
14:42:21 <Berengal> @type (^^)
14:42:22 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
14:42:26 <Berengal> @type (**)
14:42:27 <lambdabot> forall a. (Floating a) => a -> a -> a
14:42:34 <monochrom> ^^ is for 5^^(-2), negative exponents
14:42:34 <mansour> I just tried (sum [1..n]) ^ 2 and it's ok
14:42:43 <byorgey> mansour: ^^ is for exponents that can be negative,  ** is for any exponents at all
14:42:44 <luqui> @src (^^)
14:42:44 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
14:42:51 <byorgey> ^ is only for positive integer exponents.
14:43:02 <byorgey> > 5 ^^ (-2)
14:43:03 <lambdabot>   4.0e-2
14:43:12 <byorgey> > 5 ^^ (-2) :: Rational
14:43:13 <lambdabot>   1 % 25
14:43:19 <byorgey> > 5 ** pi
14:43:20 <lambdabot>   156.99254530886589
14:43:37 <luqui> > exp 1 ** pi - pi
14:43:38 <lambdabot>   19.99909997918947
14:43:49 <mansour> so, If I do 5^(-2) I wont get 1/25 ?
14:43:58 <luqui> > 5^(-2)
14:43:59 <lambdabot>   * Exception: Negative exponent
14:43:59 <monochrom> Correct. It's an error.
14:44:00 <byorgey> mansour: no, you will get an error =)
14:44:16 <Berengal> mansour: In general, computation with integral types always yield intergral results
14:44:39 <Berengal> There might be exceptions...
14:44:40 <mansour> I tried it. and guess what , u r right. ;)
14:44:48 <mansour> I C
14:44:54 <mansour> yeah, I forgot about this,
14:45:05 <Berengal> This is why we have both / and div
14:45:09 <mansour> I shold keep the type in mind, it's not Java
14:45:23 <byorgey> right =)
14:45:28 <mansour> lol
14:47:02 <Toxaris> how unsafe has something to be to get an unsafe prefix?
14:47:26 <dons> it has to require some side condition for correct operation
14:47:42 <dons> that's all. i.e. typical stuff in other languages
14:48:34 <Toxaris> so head could be unsafeHead?
14:48:43 <Toxaris> could error be unsafeError?
14:48:45 <mauke> unsafePerformList
14:48:58 <dons> Toxaris: yeah. things that error.
14:49:13 <dons> but generally the side condition is something operational. outside the language
14:49:18 <jmcarthur> It's a matter of whether you consider _|_ to be "unsafe."
14:49:20 <dons> pattern match failure isn't so much
14:49:39 <dons> partial functions are not generally prefixed as "unsafe"
14:49:41 <Toxaris> but unsafePerformIO is even more unsafe then that, because its not even type-safe
14:49:46 <jmcarthur> and it's that's the case, the we should have things like unsafeSum, as well
14:49:50 <jmcarthur> > sum [1..]
14:49:55 <lambdabot>   mueval-core: Prelude.read: no parse
14:49:55 <lambdabot>  mueval: ExitFailure 1
14:50:11 <jmcarthur> s/it's/if/
14:50:15 <Toxaris> but unsafeSum could use foldl' at least
14:50:37 <jmcarthur> Toxaris: it's still _|_, and semantically the same as head [] or error ""
14:51:04 <jmcarthur> > foldl' (+) 0 [1..]
14:51:09 <lambdabot>   mueval-core: Prelude.read: no parse
14:51:09 <lambdabot>  mueval: ExitFailure 1
14:51:11 <Berengal> unsafePerformIO isn't typesafe?
14:51:32 <jmcarthur> Berengal: check out the definition for unsafeCoerce ;)
14:51:35 <dons> in combination with polymorphic references, you can write the type coercion function
14:51:40 <jmcarthur> we were just talking about it yesterday
14:51:51 * osfameron wonders if spj would deign to speak at a perl conference...
14:51:52 <dons> its a well-known System F issue, going back to ML days of yore
14:51:52 <Berengal> Ah, yes, didn't think of that
14:53:06 <Toxaris> jmcarthur: that seems unrelated to typesafey
14:53:10 <ehird> ghc does stuff to infer the type of the reference if you stay in IO bounds
14:53:15 <ehird> why can't it infer over unsafePerformIO?
14:53:24 <jmcarthur> Toxaris: Then you conclude that head is not unsafe?
14:53:47 <sjanssen> ehird: it works thanks to the type inference rules involved with (>>=)
14:54:08 <Toxaris> jmcarthur: I conclude that its a different kind of unsafe
14:54:13 <ehird> bah
14:54:15 <ehird> specialcase it!
14:54:21 <sjanssen> ehird: it isn't a special case
14:54:25 <jmcarthur> Toxaris: For the record, I am a proponent of total languages. I'm not trying to say whether partial functions are "good," just talking their type safety.
14:54:25 <ehird> i mean
14:54:27 <ehird> unsafeperformio
14:54:28 <ehird> :)
14:54:45 <jmcarthur> *about
14:54:58 <Toxaris> jmcarthur: of course, one could argue that (->) is for total functions only, and then of course, its unsafeHead
14:55:07 <Toxaris> jmcarthur: ah well, there you go and argue so
14:56:17 <dons> yeah, we need -> and ~> :)
14:57:12 <jmcarthur> ~>:) looks mischievous
14:57:17 <jmcarthur> or something
14:57:55 <Toxaris> jmcarthur: but Haskell is at least dynamically typesafe with respect to head (instead of actually nonterminating, you get a runtime error)
14:58:33 <Toxaris> jmcarthur: while Haskell is not dynamically typesafe with respect to unsafePerformIO (instead of a runtime error, your program does arbitrary things, hopefully crashing due to OS supervision)
14:59:24 <jmcarthur> Toxaris: error is semantically the same as _|_, though. Just because you can discover at runtime that the computation is nonterminating and cancel it doesn't make the computation terminating.
14:59:50 <jmcarthur> at least in a pure sense
15:00:08 <ski> (nonterminating `head []' wouldn't make it not "dynamically typesafe")
15:00:42 <jmcarthur> ski: That seems to say that head [] is *safer* than sum!
15:00:55 <jmcarthur> wait i think i missed a negative, there
15:01:04 <Toxaris> jmcarthuer: no, but if you could discover it at compile-time, and cancel the compilation, it wouldnt make the computation terminating. Type-safety is not about what happens, but whether and when you detect Bad Things.
15:01:41 <Toxaris> ski: i assume that "nontermination" is added to the list of Bad Things we want to avoid by typing, along with core dumps and missile launches
15:02:02 <ski> why ?
15:02:16 <Toxaris> for the sake of the argument
15:02:18 <jmcarthur> Toxaris: So your claim is that nontermination is a bad thing?
15:02:26 <jmcarthur> or just a hypothesis?
15:02:34 <ski> sure it's often "bad" in the sense of "unintended" .. just as side-effects often are
15:02:39 <jmcarthur> or just a working assumption, even?
15:02:53 <Toxaris> nontermination is an interesting thing, so a type system to detect would be useful
15:03:06 <jmcarthur> Toxaris: there do exist some
15:03:31 <Toxaris> so I feel free to adopt "we want to detect nontermination" as a working hypothesis
15:03:32 <jmcarthur> Toxaris: They have varying degrees of strength and usefulness.
15:03:41 <HairyDude> any agda people around?
15:03:49 * jmcarthur is _sort of_ an agda person
15:03:51 <jmcarthur> just barely
15:04:26 <HairyDude> it's annoying when the standard library doesn't load.
15:04:28 <jmcarthur> Toxaris: are you aware of what the unamb package does?
15:04:45 <jmcarthur> HairyDude: path issue, or something else that i haven't bumped into?
15:05:02 <therp> toxaris: I remember to have seen something along a "Partial" monad on LTU
15:05:03 <Toxaris> somewhat magically evaluates two expressions in parallel, returns the first terminating?
15:05:34 <jmcarthur> Toxaris: yes, with the precondition that both expressions would both arrive at the same value if they are not _|_
15:05:42 * glguy wants a hackage.haskell.org/gc.cgi
15:06:03 <jmcarthur> Toxaris: Does unamb make you uneasy in any way?
15:06:15 <HairyDude> jmcarthur: might be that I should be using a tarballed library instead of the darcs one... how long has "Set" been a synonym for "Set1"?
15:06:40 <ski> Toxaris : my point was merely that i'd hesitate to lump Nontermination in with the Undefined Behaviour of `unsafeCoerce' .. i'd "just" regard the former as an effect, to possibly be controlled by a type-system, like the haskell monads
15:06:42 <jmcarthur> HairyDude: i never even know about that synonym. perhaps my information is as outdated as yours
15:06:47 <kosmikus> HairyDude: you shouldn't use the darcs lib with the released Agda
15:06:52 <HairyDude> hm
15:06:59 <jmcarthur> *knew
15:07:00 <kosmikus> HairyDude: either use both the released versions
15:07:06 <kosmikus> HairyDude: or both from darcs
15:07:23 <Toxaris> ski: yeah I think I agree. unsafeCoerce is worse then head.
15:07:57 <hackagebot> nikepub 1.0 - Command line utility publishes Nike+ runs on blogs and Twitter (UweHoffmann)
15:08:43 <ski> (Toxaris : yes, s/Nontermination/Nontermination as well as Partiality/)
15:08:47 <monochrom> Godawful. "Today I jogged 1.00000398390243 miles!"
15:10:29 <jmcarthur> nontermination/partiality will never result in a runtime type error
15:11:34 <HairyDude> right, that fixed it
15:11:41 <Toxaris> jmcarthur: yes and no. a hard precondition to meet; sounds hard to implement correctly (but maybe the RTS is already providing the liveness guarantuees); and from an algebra-vs-coalgebra point of view, its not clear for me where it lives
15:11:56 <HairyDude> now I just have to figure out if you can use 'open' in the middle of a record definition.
15:11:57 <kosmikus> jmcarthur: indirectly, it can
15:12:16 <Toxaris> jmcarthur: otoh, it reminds me of the computability arguments from my undergraduate studies :)
15:12:33 <jmcarthur> kosmikus: by "inderectly" do you mean "in conjunction" with something else that is not type safe?
15:12:39 <jmcarthur> *indirectly
15:13:26 <kosmikus> jmcarthur: oh, actually, I was wrong
15:13:40 <ski> (Toxaris : ".. its not clear for me where it lives"; "it" being ?)
15:13:50 <Toxaris> ski: unamb
15:14:25 <ski> oh (/me was thinking one or both of "nontermination","partiality")
15:15:06 <jmcarthur> Toxaris: Do you at least see unamb as a good example of when nontermination can be safe and useful?
15:16:19 <jmcarthur> foldl1 (||) (repeat False) `por` True
15:16:44 <copumpkin> #haskell.es
15:16:50 <Meady> Hey guys
15:16:56 <jmcarthur> all i mean is that nontermination somewhere doesn't have to be the end of the computation
15:17:04 <jmcarthur> if we accept unamb as pure, at least
15:17:11 <copumpkin> unamb is wonderful
15:17:14 <Toxaris> jmcarthur: useful, yes. safe, not sure.
15:17:24 <Meady> are there any haskell functions to get lists of files?
15:17:40 <copumpkin> Meady: http://www.haskell.org/ghc/docs/latest/html/libraries/directory/System-Directory.html
15:17:56 <jmcarthur> copumpkin: it's okay... semantically it's awesome, although i wish it had a nicer implementation
15:18:08 <Meady> ty copumpkin
15:18:33 <copumpkin> jmcarthur: should be built into ghc imo :P
15:18:34 <jmcarthur> like... one that satisfied its spec
15:18:37 <jmcarthur> yes
15:18:37 <copumpkin> unamb#
15:18:38 <copumpkin> :P
15:18:47 <eu-prleu-peupeu> hello
15:18:51 <copumpkin> omg it's eu-prleu-peupeu
15:19:08 <eu-prleu-peupeu> how is teh haskelling ?
15:19:18 <copumpkin> can you feel the depthness yet?
15:19:19 <Badger> omg it's copumpkin
15:19:28 * copumpkin badgers Badger
15:19:38 * Badger comonads pumpkin
15:20:11 <eu-prleu-peupeu> copumpkin: how is teh iphone ?
15:20:17 * copumpkin uses hiz cofree comonad on Badger
15:20:21 <copumpkin> eu-prleu-peupeu: what about it?
15:20:37 <eu-prleu-peupeu> its a tool from teh devil!
15:21:01 <copumpkin> :o
15:21:11 <eu-prleu-peupeu> thou shalt not mix haskle with tha tools from teh devil!
15:21:28 <Badger> copumpkin: what is a comonad, incidentally? :P
15:21:38 <Taejo> eu-prleu-peupeu: you obviously haven't met The Evil Mangler (dun-dun-duh)
15:21:40 <copumpkin> Badger: a monad, but backwards
15:21:52 <Badger> copumpkin: a damon?
15:21:57 <copumpkin> Badger: lol, no
15:22:03 <eu-prleu-peupeu> copumpkin: isn't that a danom ?
15:22:10 <Badger> oh
15:22:11 <Badger> it is
15:22:22 <Badger> copumpkin: a danom?
15:22:36 <eu-prleu-peupeu> the rts should be removed
15:22:51 <copumpkin> Badger: it supports "unjoin" and "unreturn" :P
15:22:58 <copumpkin> eu-prleu-peupeu: ?
15:23:06 <Badger> copumpkin: ...seriously?
15:23:16 <copumpkin> Badger: basically :)
15:23:17 <Badger> I could almost believe unjoin.
15:23:18 <Meady> is this true? Haskell is a niche language, not a general purpose language. It is also an interpreted language...
15:23:28 <Meady> And can be compiled....
15:23:31 <copumpkin> Meady: false false false :P
15:23:35 <eu-prleu-peupeu> hmm
15:23:37 <Meady> got that from a forum, mainly the first line im on about
15:23:37 <Badger> copumpkin: ahem
15:23:38 <copumpkin> well the niche bit is arguable
15:23:41 <Badger> False False False
15:23:43 <Meady> Not general purpose
15:23:45 <eu-prleu-peupeu> prolog was also like haskle...
15:23:45 <Toxaris> jmcarthur: ok, I see no problem with unamb, except that its type does not express the precondition
15:23:46 <copumpkin> Badger: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad.html
15:23:52 <Badger> Meady: it is general purpose
15:24:07 <jmcarthur> Toxaris: that would basically require dependent types to prove in the type system
15:24:10 <Badger> @faq Can Haskell do anything?
15:24:10 <lambdabot> The answer is: Yes! Haskell can do that.
15:24:12 <copumpkin> and it can be interpreted or compiled, but most commonly it is compiled
15:24:19 <eu-prleu-peupeu> prolog was like "look at this, this is quite the nouvelle shiznit", much like haskle
15:24:42 <Badger> copumpkin: w?
15:24:45 * copumpkin is guessing eu-prleu-peupeu still hasn't figured out how to spell haskell
15:24:51 <copumpkin> Badger: m upside down ;)
15:24:58 <Badger> oh har har
15:25:33 <jmcarthur> Meady: haskell is my primary programming language outside of work
15:25:50 <eu-prleu-peupeu> jmcarthur: why not prolog ?
15:26:05 <copumpkin> why not x?
15:26:08 <Meady> jmcarthur, but what do you enjoy coding?
15:26:20 <jmcarthur> Meady: i'm working on game stuff right now
15:26:26 <eu-prleu-peupeu> haskell is going on the same road as prolog
15:26:34 <jmcarthur> eu-prleu-peupeu: in what sense?
15:26:35 <copumpkin> Meady: I've never had as much fun programming as I have with haskell, and I've enjoyed programming for a while now :P
15:26:37 <copumpkin> eu-prleu-peupeu: uh
15:26:50 <solrize> does anyone know the ghc command line option to tell it where to find libgmp ?
15:26:51 * Badger sends copumpkin back to C
15:27:13 <copumpkin> :(
15:27:17 <Badger> Meady: Haskell is far more enjoyable than common use languages like C
15:27:24 <Meady> Fair enough guys, it just seems that IO (which is my main intrest) cant be coded very functionally
15:27:44 <eu-prleu-peupeu> in 10 years, the world is going to be like "look, there was this very exotic programming language back in the days called haskle!"
15:27:45 <jmcarthur> Meady: my area of research currently is an alternative to the IO monad, actually
15:27:46 <copumpkin> Meady: most of what people do isn't IO, even in IOish apps
15:28:07 <copumpkin> eu-prleu-peupeu: you seem to have quite a strong opinion for someone who can't code in haskell :P
15:28:15 <eu-prleu-peupeu> well, maybe not, maybe F# can save haskle fate
15:28:33 <jmcarthur> eu-prleu-peupeu: haskell is growing very fast. i don't know where you are getting your information
15:28:34 <Badger> jmcarthur: what's that?
15:28:38 <jmcarthur> Badger: frp
15:28:42 <Badger> ooh!
15:28:46 <jmcarthur> it subsumes, among other things, IO
15:28:54 <Badger> is Reactive working yet?
15:28:58 <eu-prleu-peupeu> one day, in teh distance future, haskell will be to teh mainstream languages, what smalltalk is to C#
15:29:00 <copumpkin> I'd like  la carte IO in the men time
15:29:07 <eu-prleu-peupeu> jmcarthur: so did prolog
15:29:07 <dons> poor eu-prleu-peupeu, trying to learn Haskell all year.
15:29:09 <jmcarthur> Badger: Reactive is still hung up on GHC bugs. I'm working on my own thing right now
15:29:13 <copumpkin> eu-prleu-peupeu: are you done prophesizing? :)
15:29:15 <jmcarthur> eu-prleu-peupeu: since when?
15:29:21 <Badger> ah
15:29:21 <eu-prleu-peupeu> dons: i love you :)
15:29:26 <jmcarthur> i don't remember prolog ever doing all that well
15:29:31 <jmcarthur> i'm not the old, either, though
15:29:35 <eu-prleu-peupeu> today i feel apocaliptical
15:29:45 <jmcarthur> *that old
15:29:51 <copumpkin> eu-prleu-peupeu: I think we might take your opinion more seriously if you actually indicated some knowledge of the language
15:29:52 <eu-prleu-peupeu> about haskle that is...
15:29:58 <jmcarthur> haskell!
15:29:58 <copumpkin> eu-prleu-peupeu: and knew how to spell its name
15:30:09 <copumpkin> jmcarthur: he makes a point of spelling it that way
15:30:11 <copumpkin> it's almost trollish
15:30:18 <jmcarthur> sometimes i do suspect
15:30:37 <dons> http://www.cse.unsw.edu.au/~dons/eu-prleu-peupeu.txt
15:30:37 <eu-prleu-peupeu> there is this university here in PT that decided to do their management systems in prolog
15:30:52 <eu-prleu-peupeu> then they tried to sell it
15:30:52 <copumpkin> it's like me going into #ruby and calling it screwby whenever I talk of it
15:31:07 <Badger> copumpkin: please please do that :P
15:31:16 <dons> too many questions, not enough thinking.
15:31:31 <eu-prleu-peupeu> ...now they are bankrupt, and trying to survive until they buy someone elses management system
15:31:35 <Badger> dons: To be, or not to be?
15:31:36 <eu-prleu-peupeu> (all thanks to prolog)
15:31:38 <copumpkin> liftM :: (Gonad g) => (a -> b) -> (g a -> g b)
15:31:43 <copumpkin> har har
15:31:47 * copumpkin is clever
15:32:09 <Badger> Gonad A and Gonad B.
15:32:18 <eu-prleu-peupeu> hey dons, im following your twitzer
15:32:24 <skorpan> gonads and strife
15:32:37 <copumpkin> eu-prleu-peupeu: if you expect so little from haskELL, why do you keep coming here?
15:33:31 <eu-prleu-peupeu> i guess a part of me hopes it succeeds
15:33:39 <eu-prleu-peupeu> just so we can all get rid of java and C#
15:33:46 <skorpan> haskELL.. kal-el's younger brother.
15:33:47 <Meady> man this 17" laptop is mahusive
15:33:48 <copumpkin> but then you'd have no language to code in?
15:34:35 <Toxaris> jmcarthur: thinking about it, the problem with unamb is not that the precondition is hard to check, but *what* happens if the precondition is not true. For such inputs, unamb is not referentially transparent, which is bad imo.
15:35:26 <dons> d
15:35:46 <eu-prleu-peupeu> if you had to choose a language for a university management system, what would you choose ? prolog ?
15:36:24 <copumpkin> clearly #haskell people would choose prolog
15:36:26 <dons> eu-prleu-peupeu: OT. please stick to Haskell-specific questions in here. your transcript has a /lot/ of off topic noise.
15:36:54 <Taejo> Toxaris: you could launch an extra thread that waited until the other argument was evaluated and throw an exception if they differed
15:37:35 <eu-prleu-peupeu> ok
15:37:40 <Toxaris> Taejo: sounds expensive, given that they may never terminate at all
15:37:45 <ksf> I need some micro-olegs of advice.
15:38:09 <eu-prleu-peupeu> if you had to choose a language for a university management system what would make you choose haskell ? (and why not java?)
15:38:18 <eu-prleu-peupeu> btw, how do i remove the IO monad from inside a list ?
15:38:20 <eu-prleu-peupeu> like
15:38:27 <ksf> Can I write a http://hackage.haskell.org/packages/archive/stateref/0.2.1.1/doc/html/Data-StateRef-Classes.html#t%3AModifyRef  instance that uses a named adt field as ref?
15:38:32 <eu-prleu-peupeu> [IO Shiznit] -> IO [Shiznit] ?
15:38:34 <copumpkin> sequence
15:38:43 <Toxaris> eu-prleu-peupeu: you can use hoogle to answer such questions
15:38:45 <copumpkin> @hoogle [IO shiznit] -> IO [shiznit]
15:38:45 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:38:45 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:38:45 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
15:39:00 <eu-prleu-peupeu> wow, now thats the shiznit!
15:39:11 <Toxaris> eu-prleu-peupeu: http://haskell.org/hoogle/?q=[IO%20a]%20-%3E%20IO%20[a]
15:39:37 <Taejo> Toxaris: indeed, but my point is that you can write a version of unamb that behaves the same when unamb's condition is met but also throws an error when it's not. Not that you should use such an unamb
15:40:24 <eu-prleu-peupeu> hey dons, do you have a new bike ?
15:40:43 <Toxaris> Taejo: but at least you can write it, yeah. So its theoretically dynamically checkable. Not sure whether that is worth for much, but I guess it is much better then being not-checkable no matter what.
15:40:55 * copumpkin facepalms
15:41:07 <Toxaris> does unamb seq in the process?
15:41:45 <Itkovian> Is there a simpler way to write: (\xs -> (takeWhile xs &&& dropWhile xs)) (\x -> x `mod` 2 == 0) [2,2,4,5,7,6]
15:42:11 <Toxaris> I guess it would be helpful to have the following operational behavior:   (1 : foo) `unamb` (1 : bar) ~> 1 : (foo `unamb` bar)
15:42:19 <copumpkin> @pl  (\xs -> (takeWhile xs &&& dropWhile xs)) (\x -> x `mod` 2 == 0)
15:42:19 <lambdabot> liftM2 (&&&) takeWhile dropWhile ((0 ==) . (`mod` 2))
15:42:43 <Taejo> Toxaris: that function is know is lub, and it's rather harder to write
15:42:44 <copumpkin> or (&&&) <$> takeWhile <*> dropWhile :P
15:43:08 <Sisu> (\x -> x `mod` 2 == 0) is already in prelude with name 'even'
15:43:10 <tromp> :t even
15:43:10 <Taejo> lub stands for least upper bound (in the definedness order) btw
15:43:10 <lambdabot> forall a. (Integral a) => a -> Bool
15:43:57 <copumpkin> :t (&&&) <$> takeWhile <*> dropWhile
15:43:58 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:44:04 <copumpkin> :t (&&&) <$> takeWhile <*> dropWhile even
15:44:05 <lambdabot>     Couldn't match expected type `a -> Bool'
15:44:05 <lambdabot>            against inferred type `[a1]'
15:44:05 <lambdabot>     In the second argument of `(<*>)', namely `dropWhile even'
15:44:10 <copumpkin> :t (&&&) <$> takeWhile <*> dropWhile $ even
15:44:11 <lambdabot> forall a. (Integral a) => [a] -> ([a], [a])
15:44:50 <Taejo> Toxaris: http://conal.net/blog/posts/merging-partial-values/ describes lub
15:44:52 <aavogt> @type break
15:44:53 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:44:59 <copumpkin> lol
15:45:12 <aavogt> or is it span
15:45:27 <copumpkin> > (\xs -> (takeWhile xs &&& dropWhile xs)) (\x -> x `mod` 2 == 0) [2,2,4,5,7,6]
15:45:28 <lambdabot>   ([2,2,4],[5,7,6])
15:45:45 <Itkovian> thx
15:45:47 <copumpkin> > break even [2,2,4,5,7,6]
15:45:48 <lambdabot>   ([],[2,2,4,5,7,6])
15:45:51 <copumpkin> > span even [2,2,4,5,7,6]
15:45:52 <lambdabot>   ([2,2,4],[5,7,6])
15:45:58 <Taejo> aavogt: break breaks the list when the predicate is true
15:46:53 <aavogt> Taejo: as demonstrated by copumpkin and lambdabot
15:47:12 * RayNbow didn't know how to pronounce Cabal until he saw SPJ's recent talk
15:47:17 <Taejo> aavogt: demonstrated, but not mnemonised
15:47:33 <eu-prleu-peupeu> if i had a big company and had a job position for a haskel programmer, what would i put on the ad ? "functional programmer" or "haskel programmer" ?
15:47:48 <aavogt> Haskell?
15:48:01 <eu-prleu-peupeu> its liek, if i put the haskel programmer nobody would probably show up :P
15:48:04 <Taejo> I've often seen their demonstration (or performed it myself), but it was that mnemonic that let's me get away without testing each time
15:48:11 <dcoutts> RayNbow: so were you pronouncing it like the capital of Afghanistan? :-)
15:48:14 * araujo sends his CV to eu-prleu-peupeu way
15:48:14 <lambdabot> araujo: You have 1 new message. '/msg lambdabot @messages' to read it.
15:48:17 --- mode: ChanServ set +o dons
15:48:24 * araujo hides from dons 
15:48:26 <RyanT5000> eu-prleu-peupeu: it depends on where you're advertising
15:48:41 --- mode: dons set +b *!*n=hugo@*.dsl.telepac.pt
15:48:42 --- kick: eu-prleu-peupeu was kicked by dons (Come back when you've got some specific coding questions.)
15:48:46 --- mode: ChanServ set -o dons
15:48:54 <dons> 12 months of this. Sigh.
15:48:54 * copumpkin cheers
15:49:01 <RayNbow> dcoutts: I was pronouncing it in a way that resembled "cable"...
15:49:08 <Taejo> * araujo hides from dons -- the innocent have nothing to fear
15:49:14 <dons> araujo roxors
15:49:15 <araujo> :P
15:49:16 <dcoutts> RayNbow: ahh :-)
15:49:17 <araujo> hah
15:49:19 <Taejo> dons is goodcop
15:49:23 <RayNbow> well, I only pronounced it mentally... I never met any devoted Haskell user IRL yet :p
15:50:39 <Meady> Anyone know where i can find some info on (\x ->) syntax?#
15:50:46 <Meady> Cause im not understanding nameless functions
15:50:55 <Meady> Google showed me nothing i searched haskell \x
15:51:08 <copumpkin> Meady: what about it?
15:51:08 <RayNbow> Meady: well, it should be somewhere in the Haskell report
15:51:19 <kpreid> Meady: that is called a lambda expression
15:51:19 <Taejo> Meady: the only punctuation that google indexes is special cases like c++
15:51:26 <dcoutts> Meady: google for lambda functions
15:51:30 <Meady> ahh ok
15:51:46 <kpreid> Meady: (the backslash \ is an asciification of  lambda)
15:51:57 <Toxaris> Taejo: thanks, good pointer.
15:51:59 <Meady> ok this for example map (\x -> 3*x + x/4) [1,2,3,4]
15:52:05 <Meady> map (3*x + x/4) [1,2,3,4]
15:52:07 <Meady> isnt that the same?
15:52:10 <kpreid> no
15:52:21 <kpreid> x is free in the latter, it's not defined in the expression
15:52:24 <Meady> Because x has no value
15:52:28 <kpreid> right
15:52:34 <lpsmith> @define f x = 3*x + x/4
15:52:41 <Meady> so 1..4 is passed to x and then ran that function on it
15:52:50 <RayNbow> ? let f x = 3*x + x/4    in     map f [1..4]
15:52:52 <lpsmith> > map f [1,2,3,4]
15:52:53 <RayNbow> > let f x = 3*x + x/4    in     map f [1..4]
15:52:53 <lambdabot>   Add a type signature
15:52:54 <lambdabot>   [3.25,6.5,9.75,13.0]
15:54:04 <lpsmith> Meady:  basically an anonymous function is the same as a regular definition, except you don't have to give it a name
15:54:20 <Meady> so yoou can make it on the fly to feed modified arguments to another function?
15:54:35 <lpsmith> > map (\x -> 3*x + x/4) [1,2,3,4]
15:54:36 <lambdabot>   [3.25,6.5,9.75,13.0]
15:54:57 <Mauke> Meady: yes, for example
15:55:07 <lpsmith> Yes,  you can "make it on the fly",  kind of.  I'm not sure what you are getting at with the last bit.
15:55:17 <Mauke> > map (\x -> show (x + 1)) [1 .. 4]
15:55:18 <lambdabot>   ["2","3","4","5"]
15:55:21 <lpsmith> Your example feeds four different arguments to the same function
15:55:33 <kulakowski> I think he meant, a throwaway function that doesn't deserve to have a name bound to it.
15:56:01 <lpsmith> > map (\x -> x^2) [1..10]
15:56:02 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
15:56:29 <copumpkin> zomg mauke is uppercase today
15:56:54 <Meady> hmm makes sense
15:56:59 <lpsmith> > map (\x -> [1,4,9,16] !! x) [3,1,2,0]
15:57:00 <lambdabot>   [16,4,9,1]
15:57:14 <mansour> I am not sure if I can assign a function with more than one param a value, for example I can do this fun 2 = 4  but I can not do this myFun 2 x = 4 when x is a param
15:57:35 <Mauke> > map (\f -> f 42) [id, (+1), subtract 4, (`div` 2)]
15:57:36 <lambdabot>   [42,43,38,21]
15:58:42 <lpsmith> :t map (\x -> (\y -> x + y)) [1,2,3,4]
15:58:43 <lambdabot> forall a. (Num a) => [a -> a]
15:58:45 <mansour> any idea ?
15:59:13 <Mauke> mansour: I don't understand.
16:00:10 <lpsmith> > zipWith ($) (map (\x -> (\y -> x + y)) [1,2,3,4]) [4,3,2,1]
16:00:10 <lambdabot>   [5,5,5,5]
16:00:20 <mansour> ok, let's say in the factorial function , you can do fact 1 = 1 as a stoping condition
16:00:48 <mansour> and then fact x = x * fact (x-1)
16:01:19 <mansour> but what if you have a function that takes two argument (variables) ? how can you assign a value
16:01:20 <mansour> ?
16:01:55 <Mauke> Nope, still nothing.
16:01:56 <mansour> when the recurse in fact x = x * fact (x-1) hits fact 1, it evaluates to 1
16:01:58 <dons> I'm not sure what the question is, mansour
16:02:10 <dons> foo 1 x = 27 ; foo a b = 2444442
16:02:11 <mansour> hum,
16:02:22 <mansour> can you do this ?
16:02:26 <dons> yep.
16:02:26 <mansour> I will try it
16:02:34 <Mauke> Wait, you didn't even try it?
16:02:36 <mansour> I tried it before and I got an error
16:02:39 <dons> you can always substitute a constructor for a variable in a pattern
16:02:46 <Mauke> What error?
16:03:01 <mansour> I did it yesterday when I was playing
16:03:14 <mansour> I will try to regenerate the error,
16:03:15 <yowgi> > let fact x = if x == 0 then 1 else x * fact (x-1) in fact 5 -- mansour, this?
16:03:16 <lambdabot>   120
16:03:34 <Shaka> Can somebody help me?
16:03:53 <yowgi> > let fact 0 = 1; fact x =  x * fact (x-1) in fact 5 -- also this.
16:03:54 <lambdabot>   120
16:03:55 <Shaka> Is somebody here
16:04:10 <Shaka> Please help
16:04:11 <dons> Shaka: what's your question.
16:04:22 <Shaka> im trying to edit a .exe
16:04:25 <Shaka> for a game...
16:04:27 <lpsmith> > let fact x a = if x == 0 then a else fact (x-1) (a * x) in fact 5 1
16:04:28 <lambdabot>   120
16:04:28 <dons> Is this a Haskell question?
16:04:32 <Shaka> so when i click start it starts the game lol
16:04:39 <mansour> it's working now.
16:04:48 <mansour> I must have done something wrong yesterday,
16:04:53 <dons> You're in the wrong channel, I think, Shaka
16:04:59 <Shaka> uggg
16:05:22 <mansour> thank yo uguys
16:05:25 <mansour> thanks all
16:05:51 <Mauke> @Girl19
16:05:52 <lambdabot> nobody can catch me
16:05:58 <Mauke> @Girl19
16:05:58 <lambdabot> I have stolen about 50 msn and yahoo accounts
16:06:08 <lpsmith> mansour:  you are welcome!
16:06:25 <mansour> :)
16:07:34 <lpsmith> @define fact a 0 = a  ;  fact a x = fact (a*x) (x-1)
16:07:43 <lpsmith> > fact 1 5
16:07:44 <lambdabot>   Not in scope: `fact'
16:07:48 <lpsmith> hmm
16:08:09 <lpsmith> can lambdabot accept multiline definitions somehow?
16:09:22 <Mauke> haha
16:09:30 <Toxaris> @let bar 1 = 27
16:09:31 <lambdabot>  Defined.
16:09:34 <Toxaris> @let bar 2 = 42
16:09:35 <lambdabot>  Defined.
16:09:37 <Toxaris> > bar 1
16:09:38 <lambdabot>   27
16:09:41 <Toxaris> > bar 2
16:09:42 <lambdabot>   42
16:09:47 <Mauke> @define autocorrects to @undefine
16:09:51 <Mauke> > bar 1
16:09:52 <lambdabot>   Not in scope: `bar'
16:10:27 <Toxaris> @undefine is *really* confusing
16:12:23 <m3ga> @seen arjanoosting
16:12:23 <lambdabot> arjanoosting is in #haskell and #haskell.dut. I don't know when arjanoosting last spoke.
16:12:34 <Mauke> preflex: seen arjanoosting
16:12:34 <preflex>  Sorry, I haven't seen arjanoosting
16:13:04 <Luyt> In which language is lambdabot written?
16:13:22 <copumpkin> haskell
16:13:24 <monochrom> edit-distance 2
16:13:39 <Luyt> Ah ;-)
16:13:50 <copumpkin> Luyt: incidentally, so is geordi in ##c++
16:14:02 <ehird> geordi works too much
16:14:03 <ehird> it's no fun
16:14:05 <ehird> you can't break it!
16:14:51 <aavogt> > (,5) 3
16:14:52 <lambdabot>   <no location info>: parse error on input `5'
16:14:55 <chrisdone> looks like funky stuff coming for the next ghc sept. release.. So, you want GHC plugins, huh?
16:15:04 <aavogt> is there a reason we can't have sections with , ?
16:15:38 <Taejo> aavogt: because , is not a function
16:15:53 <chrisdone> aavogt: what type is (,"a")?
16:16:12 <ehird> aavogt:
16:16:13 <Mauke> chrisdone: a -> (a, [Char])
16:16:18 <chrisdone> sounds good to me
16:16:19 <Toxaris> @type flip (,) "a"
16:16:20 <lambdabot> forall a. a -> (a, [Char])
16:16:23 <ehird> what Toxaris said
16:16:31 <ehird> Mauke: is it?
16:16:36 <ehird> Mauke: how do we get that for a three-tuple?
16:16:39 <ehird> i see.
16:16:40 <Mauke> Well, that is what it would be.
16:16:45 <ehird> Mauke: no it wouldn't
16:16:51 <ehird> nothign in (,"a") suggests a 2-tuple
16:16:52 <Mauke> Why not?
16:17:01 <Mauke> ehird: What about the comma?
16:17:01 <ehird> because it doesn't?
16:17:06 <chrisdone> the single comma suggests a tuple
16:17:13 <aavogt> @type (,)
16:17:14 <lambdabot> forall a b. a -> b -> (a, b)
16:17:17 <jmcarthur> i see no ambiguity there. it's just not valid haskell
16:17:18 <ehird> so (,,"a") would be a triple?
16:17:23 <aavogt> @type (,,)
16:17:24 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
16:17:27 <jmcarthur> yeah
16:17:28 <ehird> so we're inventing ridiculous syntax here for this weird special case?
16:17:30 <ehird> that's silly.
16:17:38 <Mauke> ehird: We already have ridiculous syntax.
16:17:40 <aavogt> , should be a function like : ?
16:17:40 <jmcarthur> ehird: is (+3) silly?
16:17:42 <lunabot>  luna: parse error on input `?'
16:17:46 <Mauke> (,,) is valid.
16:17:52 <ehird> That's not syntax
16:17:56 <ehird> between the current way and that way, I choose the former.
16:18:02 <ehird> jmcarthur: that's different
16:18:06 <ehird> (a,b,c) is syntax
16:18:08 <ehird> (2+2) isn't
16:18:25 <jmcarthur> just because the parser treats it differently doesn't mean it *should*
16:18:34 <jmcarthur> is (,) syntax?
16:18:37 <ehird> okay, how do you propose this mythical thing is parsed?
16:18:42 <Toxaris> should [, foo] == (: foo)?
16:18:44 <ehird> ((a,b),c)?
16:18:50 <jmcarthur> the same way as an operator?
16:18:53 <ehird> and how do you turn this into the triple a-b-c?
16:19:02 <jmcarthur> nobody said that should do what you're saying
16:19:12 <chrisdone> Toxaris: and with the empty list on the end?
16:19:13 <ehird> that's what would happen if we removed the special case.
16:19:18 <aavogt> ehird: probably (,,'a')
16:19:29 * Toxaris is talking nonsense
16:19:31 <chrisdone> \x -> x : foo : []?
16:19:33 <jmcarthur> the proposal is only for the partially applied forms
16:19:42 <Toxaris> chrisdone: that's what I mean!
16:20:02 <jmcarthur> we already make a special case for (,) ; (,,) ; (,,,) ; etc.
16:20:04 <chrisdone> I rate like this idea
16:20:32 <aavogt> I hate writing (\x -> (x,y))
16:20:47 <Rotaerk> then stop it!
16:20:50 <jmcarthur> well, you could write (,) x instead
16:20:52 <Toxaris> aavogt: (,) x
16:20:57 <jmcarthur> but i agree (x,) would be nicer
16:21:11 <Mauke> flip (,) y
16:21:13 <aavogt> hmm, the other order tuple is worse
16:21:27 <aavogt> @type (,) 'a'
16:21:28 <lambdabot> forall b. b -> (Char, b)
16:21:44 <aavogt> Mauke's right
16:22:13 <Mauke> @let (~>) x = (,) x
16:22:14 <lambdabot>  Defined.
16:22:24 <Mauke> :t (~> y)
16:22:25 <lambdabot> forall a. a -> (a, Expr)
16:22:35 <jmcarthur> ugh
16:22:44 <chrisdone> :t x
16:22:45 <lambdabot> Expr
16:22:58 <Mauke> > x ~> y
16:22:59 <lambdabot>   (x,y)
16:23:06 <ziman> :t let (.,) = (,) in (., 3)
16:23:07 <lambdabot> parse error on input `,'
16:23:35 <chrisdone> can you define a `<,>' function or is that invalid syntax?
16:23:47 <allbery_b> comma is special
16:23:47 <Toxaris> comma is not an operator character
16:23:48 <elliottt> i think that , is a special case
16:23:53 <chrisdone> oh =(
16:24:05 <ziman> :t let a <,> b = a+b in 3 <,> 5
16:24:06 <lambdabot> parse error on input `,'
16:24:37 <aavogt> do some characters /look/ like ,, but aren't?
16:24:37 <allbery_b> (lambdabot isn't a good test, its parser is more limited than ghc's IIRC)
16:24:53 <allbery_b> there are some unicode characters that look like commas
16:25:02 <chrisdone> mauke's (~>) pretty much solves it.. for 2-tuple, at least -- but I suppose any n-tuple is the point
16:25:04 <aavogt> =)
16:25:22 <Toxaris> but pairs are so much the most important kind of tuples
16:25:40 <ziman> :t let (~~>) x y = (,,) x y in (x ~~> y)
16:25:41 <lambdabot> forall c. c -> (Expr, Expr, c)
16:25:49 <Mauke> @let xy = (x, y)
16:25:49 <lambdabot>   Illegal character ''\65292''
16:26:21 <Toxaris> I am against too much "leave a hole to denote a function"
16:26:39 <ehird> eh?
16:26:41 <ehird> you mean pointfree?
16:26:43 <chrisdone> Toxaris: why so?
16:27:04 <Toxaris> because it does not scale to functions of more then one argument, while lambda notation easily scales, and is not much more verbose
16:27:40 <Toxaris> I mean I am against (1, 2, , 4, , 6) :: Int -> Int -> Int
16:27:44 <ehird> placeholder names are a damnable folly and naming anything that is not a significant concept is a flaw
16:27:50 <aavogt> @type  (((?f . ) .) .)
16:27:51 <lambdabot> forall b c a a1 a2. (?f::b -> c) => (a2 -> a1 -> a -> b) -> a2 -> a1 -> a -> c
16:27:58 <ehird> imo
16:28:18 <soupdragon> Toxaris: why?
16:28:24 <chrisdone> I suppose that is true. you can't do \x y -> [x,y,x] with holes
16:28:42 <Toxaris> it does not scale because you cannot specify which hole corresponds to which argument position
16:28:59 <aavogt> @pl \x y -> [x,y,x]
16:28:59 <lambdabot> liftM2 (.) (:) (flip (:) . return)
16:29:14 <aavogt> chrisdone: I expected worse =)
16:29:28 <chrisdone> still, that is horrible
16:30:02 <Toxaris> ehird: I agree that placeholder names are bad, so use meaningful names, or use pointfree notation, but done use holefull notation
16:30:03 <dons> glguy: iavor's suggested    paramaterized tactics to hlint
16:30:08 <dons> so we don't get @pl style all the time
16:30:16 <ehird> Toxaris: eh?
16:30:16 <Toxaris> s/done/don't
16:30:28 <dons> you could have galois house-style enforcement, for example.
16:30:49 <glguy> dons, so the current mode would become: hlint --style=#haskell
16:30:49 <glguy> ?
16:30:53 <glguy> :)
16:30:56 <dons> :)
16:30:58 <chrisdone> so are records easier to work with since ghc 6.8?
16:31:09 <ehird> --style=caleskell
16:31:11 <dons> Or "this is all the things the tool can spot, so why not"
16:31:11 <ehird> note: replacements do not work.
16:31:11 <Cale> How far does hlint go in suggesting @pl?
16:31:17 <ehird> unless you write your own prelude :)
16:31:26 <Cale> If I write \x -> x^2 + x + 1, will it suggest the points-free version?
16:31:45 <Cale> In that case, then yeah, it has to be toned down :)
16:31:53 <aavogt> I don't think it does
16:31:58 <Cale> But the examples that I saw were mostly reasonable points-free refactorings.
16:32:18 <Toxaris> ehird: from my pov, the difference between a (hypothetical) syntax with holes, and pointfree style, is that holes focus on points without even naming them, while pointfree style *really* focuses on the functions as meaningful concepts
16:32:25 <dons> mostly reasonable. for intermediate-to-advanced code though, all that's left are @pl-isms
16:32:40 <Cale> Toxaris: yeah
16:32:41 <dons> since the coder already knows about catMaybes, flip and concatMap
16:32:43 <elliottt> chrisdone: what do you mean by easier?
16:33:13 <ehird> Toxaris: example?
16:33:25 <ehird> @pl \x -> x^2 + x + 1
16:33:25 <lambdabot> (1 +) . ((+) =<< (^ 2))
16:33:26 <Cale> The nice thing about compositional style is that function composition is associative, and that simple fact lets you break down functions in n^2 ways really easily without having to think about it anymore.
16:33:33 <ehird> hmm
16:33:39 <ehird> that could be made nicer with like applicative, couldn't it
16:33:50 <ehird> or `on`
16:33:59 <Cale> (and even if you don't do it, it can help you understand the function by looking at little segments of it at a time)
16:34:07 <Taejo> dons: does it really suggest catMaybes? Is there a simple expansion like "concatMap f == concat . map f"?
16:34:17 <allbery_b> polynomial dsl?
16:34:27 <Mauke> :t ((+) <*> (^ 2))
16:34:28 <lambdabot> forall a. (Num a) => a -> a
16:34:42 <Mauke> > ((1 +) . ((+) <*> (^ 2))) 4
16:34:43 <lambdabot>   21
16:34:52 <Cale> > ((1 +) . ((+) <*> (^ 2))) x
16:34:53 <lambdabot>   1 + (x + x * x)
16:35:49 <lilac> > (x + 3) ^ 2 - (x - 5) ^ 3
16:35:51 <lambdabot>   (x + 3) * (x + 3) - (x - 5) * (x - 5) * (x - 5)
16:35:51 <chrisdone> elliottt: like.. let x = { foo = 1, bar = 2 }, and now I use x { foo = 3 } to "update" the value of foo in x, which is fine. but, let's say I'm in the state monad with this record value, and I want to double the `foo' value, I usually have to write modify $ \s -> s { foo = foo s * 2 }. which is.. tiresome
16:36:25 <elliottt> ah, in that regard, it remains unchanged (as far as i know)
16:36:25 <aavogt> @hackage data-accessor
16:36:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
16:36:41 <lilac> just today i wrote "foo { bar // [(a, b)] }" and was saddened that that didn't work
16:36:41 <elliottt> chrisdone: i don't think that first class labels have made it in yet
16:36:53 <Toxaris> ehird: putStr (show (process (read (loadFile _)))) =<< getArgs
16:37:05 <ehird> Toxaris: Is that valid syntax?
16:37:13 <Toxaris> ehird: no, it is hypothetical syntax
16:37:15 <aavogt> there may be other libraries that do reasonable records
16:37:15 <ehird> Ah.
16:37:19 <ehird> So you oppose that?
16:37:20 <ehird> Well, no duh!
16:37:21 <Toxaris> ehird: yes
16:37:33 <chrisdone> elliottt: I'll google first class labels, thanks
16:37:41 <Toxaris> ehird: (and probably it is not type correct, because they are three IO things, but only one =<<, but anyway)
16:37:45 <chrisdone> aavogt: having a gander now
16:38:08 <Toxaris> ehird: I oppose that, and I fear that (1, 2, 3, , 5, 6) :: Int -> Int is a first step in that direction
16:38:12 * lilac isn't sure whether "foo { bar `op` stuff }" as a shortcut for "foo { bar = bar foo `op` stuff }" would be nice or ugly
16:38:13 <ehird> mm
16:38:49 <Toxaris> ehird: Scala has a policy of "put a _ somewhere, and you get a function", and it makes code harder to read imho
16:39:02 <ehird> mm
16:39:03 <Toxaris> while sometimes, it is just cool
16:39:36 <chrisdone> does ruby do something similar?
16:40:01 * Taejo spent half an hour debugging a bug he'd already fixed
16:40:25 <jleedev> must a Data.Map be finite?
16:40:29 <copumpkin> yeah
16:40:31 <jleedev> doh
16:40:40 <copumpkin> it used to be called Data.FiniteMap
16:40:42 <copumpkin> I think
16:40:55 <Taejo> jleedev: it's fairly tricky to make a useful infinite balanced tree
16:41:15 <jleedev> what if the keys are the natural numbers?
16:41:18 <chrisdone> does the implementation re-shuffling stop any infinite map?
16:41:49 <Toxaris> jleedev: *all* natural numbers?
16:42:00 <Mauke> A function!
16:42:05 <jleedev> the point is to memoize it
16:42:22 <Toxaris> some kind of trie?
16:42:24 <jleedev> the context here is project euler 14, the collatz sequence
16:42:35 <Taejo> jleedev: look at the memotrie library
16:42:56 <Toxaris> or you can guess an upper bound and use an array
16:42:58 <Taejo> but in the euler problem I think I only memoized up to some upper bound
16:43:06 <Toxaris> and just not memoize for larger numbers
16:43:31 <Toxaris> should work for collatz, since one usually assumes that we move towards 1 eventually
16:44:05 <jleedev> ok, i'll try an upper bound
16:45:08 <Mauke> you don't need any memoization for that
16:46:04 <Mauke> assuming you're patient enough
16:46:15 <jleedev> that's rather tautological
16:48:04 <Taejo> Mauke: project euler solutions are supposed to run in under a minute (if you're not doing them by hand)
16:49:03 <Mauke> Pfft, you're just not awesome enough to use pure brute force.
16:49:36 <Meady> Whats the function to make string uppercase
16:49:37 <Mauke> Runtimes of >24 hours are normal.
16:49:47 <Mauke> :t map toUpper
16:49:48 <lambdabot> [Char] -> [Char]
16:49:53 <Meady> ty
16:50:49 <Meady> if something returns IO [FilePath] and FilePath = String, i could use map (toUpper) \x <- io [filepath]????
16:51:02 <Mauke> Aiieee
16:51:06 <Meady> REally!?
16:51:22 <Meady> Sif i just made my first namless function
16:51:27 <Meady> That right in theory then yeh?
16:51:28 <Mauke> fmap (map toUpper) something
16:51:52 <Mauke> do x <- something; let y = map toUpper x; ...
16:52:09 <Meady> so what i said wont work??
16:52:53 <Mauke> Right, there's at least two syntax errors in there.
16:53:13 <Mauke> ') \' and '\x <-'
16:53:55 <Meady> okok map toUpper (\x <- do sometihng)
16:54:35 <Mauke> no
16:54:43 <Mauke> that still contains '\x <-'
16:55:50 <Meady> isnt that namless?
16:56:00 <copumpkin> ->
16:56:02 <copumpkin> not <-
16:56:11 <Meady> oh :S
16:56:18 <Taejo> :t cycle
16:56:19 <lambdabot> forall a. [a] -> [a]
16:56:36 <Meady> i though (\x <- do something) would say like do this to each entry assign it to x and ppass it to map?
16:57:07 <mauke> it doesn't, and why would map care about it being called 'x'?
16:57:12 <Taejo> Meady: \ and -> go together, <- is an entirely different thing
16:57:14 <sjanssen> Meady: that isn't valid Haskell
16:58:38 <Meady> ok you tell me mauke, you act like you invented map?
16:58:57 <monochrom> Yes, mauke invented map.
16:59:07 <mauke> I named it after myself
16:59:28 <lilac> before mauke we all implemented map witha fold every time we needed it
16:59:29 <mauke> map stands for "mauke processor"
17:00:05 * lilac still remembers the pain of "foldr ((:).f) []"
17:00:19 <gwern> little known fact - gmap stands for "gwern's mauke processor'
17:01:03 <gwern> @hoogle gmap
17:01:03 <lambdabot> Data.Generics.Twins gmapAccumM :: (Data d, Monad m) => (a -> d -> (a, m d)) -> a -> d -> (a, m d)
17:01:03 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])
17:01:03 <lambdabot> Data.Generics.Twins gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (a -> d -> (a, r')) -> a -> d -> (a, r)
17:01:05 <Taejo> fmap stands for funtastic mauke processor
17:01:14 <copumpkin> lilac: wow, really?
17:01:26 <monochrom> mmap is monochrom's food processor
17:01:27 <gwern> Taejo: I thought it was 'flensing mauke processor'
17:01:36 <Taejo> copumpkin: lilac's been around since the bad old days
17:01:42 <inimino> IMAP, on the other hand, is not /at all/ my fault
17:01:44 <copumpkin> :o
17:01:49 <monochrom> this is because mauke is monochrom's food
17:01:59 <Taejo> gwern: nah, it's funtastic cause it works on funtors
17:02:08 <lilac> lambdas were named after me.
17:02:19 <gwern> but then what do we use for soft fuzzy things?
17:02:23 <Taejo> @remember lilac before mauke we all implemented map witha fold every time we needed it
17:02:23 <lambdabot> Done.
17:02:24 * mauke funrolls some loops
17:02:34 <lilac> lambda actually is just the greek letter l. iit stands for lilac.
17:02:47 <Taejo> @remember lilac lambda actually is just the greek letter l. it stands for lilac.
17:02:47 <lambdabot> It is stored.
17:02:48 <mauke> 
17:03:16 <kynky> mauke processor on wikipedia, didnt realise was true
17:03:17 <mauke> \i.\a.k
17:03:43 <pikhq> mauke: I HATE YOUR IOTA ALPHA AND KAPPA.
17:03:52 <pikhq> LAMBDA IS PERFECTLY OKAY HOWEVER.
17:04:04 <Taejo> pikhq: huh?
17:04:04 <gwern> a cat is fine too
17:04:19 <soupdragon> hey it's childrens hour
17:04:32 <Taejo> yeah, gwern, keep it family-safe
17:04:33 <pikhq> Taejo: 
17:04:39 <monochrom> children love lambda and cats
17:04:53 <gwern> Taejo: hey, that's a perfectly family-safe comment in this context!
17:05:01 <gwern> if you're reading something else into it, that's your problem
17:05:01 <Taejo> pikhq: what do you have against iota, though?
17:05:15 <mauke> gwern: it's awwwwwright!
17:05:37 <pikhq> Taejo: It's an esoteric combinator.
17:05:39 <monochrom> children are also curious about how lambda and cats give birth to lambda and cats.
17:05:52 <lilac> -!-  Erroneous Nickname  :(
17:06:01 <gwern> the simon flys over their house and drops a new one on their doorsteps
17:06:05 <monochrom> Yeah, stupid IRC.
17:08:11 <Taejo> yes! my manpage parser almost understands rm.1
17:08:32 <Taejo> though it doesn't deserve the name parser
17:10:28 <Taejo> @remember KF8NH all monads are functors, but for Hysterical Raisins not all Monads are Functors
17:10:28 <lambdabot> I will remember.
17:11:29 <ben> KF8NH?
17:11:47 <Taejo> Brandon S. Allbery KF8NH
17:11:55 <Taejo> KF8NH looked like it might be a nick
17:12:09 <Taejo> otherwise I'm just confused
17:12:14 <allbery_b> ham callsign. I'm allbery_b here
17:12:23 <Taejo> I see
17:12:35 <mansour> what does this mean ?  Warning: Pattern match(es) are overlapped
17:13:06 <lilac> mansour: it means that part of a later case is unreachable due to earlier cases
17:13:21 <jleedev> Taejo: http://codepad.org/OasW0n9V but it stack overflows on larger values
17:13:33 <mansour> I C
17:14:12 <allbery_b> example:  case foo x of { a -> something; [] -> somethingElse } the [] is unreachable because a matches anything
17:14:16 <Taejo> jleedev: you're not doing any memoization there
17:14:36 <Taejo> and it's probably a good idea to memoize into an array rather than a list, anyway
17:15:07 <jleedev> ok. do i just want to see how big they get and use that as the size of the array?
17:15:34 <mansour> allbery_b: I did change the order of the function and it's ok now.
17:15:54 <Taejo> jleedev: well that 1000 in your code, I assumed you meant that to be the upper bound
17:16:08 <FunctorSal> maybe we need ArrayLists
17:16:33 <copumpkin> I thought someone was writing one
17:16:51 <jleedev> Taejo: but the values get much larger after a few 3n+1 iterations
17:17:42 <Taejo> jleedev: my feeling is that it's only worth memoizing a few (maybe a million) cause higher numbers don't get repeated often
17:17:51 <Taejo> but you do need to memoize
17:17:56 <jleedev> and you'd suggest an array?
17:18:28 <Taejo> jleedev: yeah. you could use a Map, but I'd just go straight for an array
17:18:58 <copumpkin> unless your thing is sparse
17:19:04 <conal> or a trie
17:19:08 <Meady> guys i know we dont program in haskell in sequence, but reall i do lol
17:19:09 <copumpkin> if it's sparse, use an IntMap or Map
17:19:11 <conal> maybe an IntMap
17:19:23 <Taejo> wouldn't it be nice if the Jargon File specified its encoding correctly?
17:19:24 <conal> could use a memotrie
17:19:45 <conal> @hackage MemoTrie
17:19:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MemoTrie
17:19:47 <Taejo> with a memotrie you don't have to bother about putting an upper bound on the memoization
17:20:10 * jleedev will investigate memotrie
17:20:10 <conal> nice & elegant
17:20:48 <conal> jleedev: i hear IntMap is very efficient.
17:21:49 <jleedev> well, http://codepad.org/o4b3u69Q runs in 10 seconds or so (now that i'm not wastefully making a bunch of lits)
17:21:59 <conal> jleedev: a lovely thing about MemoTrie is that you needn't explicitly insert key/value pairs.  just say "memo f", where f is a function.
17:22:38 <conal> jleedev: make sure any recursive calls are to the memoized function.
17:22:40 <soupdragon> conal elegant interface or implementation?
17:23:31 <sjanssen> I think this is the dozenth time #haskell has been asked about this problem
17:23:33 <sjanssen> weird
17:23:33 <conal> soupdragon: the elegance of not having an arbitrary memo table size.
17:23:52 <FunctorSal> lambdabot: that got wrapped to "emoTrie" :)
17:24:35 <lilac> FunctorSal: Mmm... emoTrie
17:25:03 <Cale> Meady: If you're really stuck for how to encode an imperative algorithm, there is a straightforward but inelegant way: turn each step of the algorithm into a function, and all the variables which are changing throughout the algorithm into parameters to the functions. (Usually you can do a little better by collapsing multiple steps into one). Then write a function which starts things off by calling the first step with initial values of the variables.
17:25:37 <FunctorSal> or use ST ;)
17:26:02 <Cale> Meady: While it's not pretty, it's usually one way to start to get a handle on what is really being computed, and by transforming and simplifying things, sometimes a more functional algorithm will pop out.
17:26:09 <Taejo> FunctorSal: yes, but Cale's way allows gradual functionalisation
17:26:38 <FunctorSal> yes, if the algorithm can be functionalised it's better of course
17:27:46 <Cale> Just to clarify a bit, the intention is that each step of the algorithm call the next one with the new set of parameters.
17:30:21 <Rotaerk> what IDE do you guys use for Haskell?
17:30:39 <lilac> vim and irssi
17:30:50 <Cale> vim and ghci in separate terminal windows
17:30:52 <Rotaerk> irssi? :D
17:30:59 <Rotaerk> I don't think IRC counts as part of the IDE
17:31:08 <lilac> i use it as my online help system
17:31:08 <conal> Rotaerk: emacs with haskell-mode
17:31:12 <Rotaerk> heh
17:31:14 <Meady> Hmm i see
17:31:18 <lilac> it does refactoring and so on
17:31:24 <Meady> But if we are saying each step, we are planning sequence
17:31:24 <Meady> :s
17:32:01 <Cale> Meady: you said you couldn't think of a way to write a program without a sequence of steps, this gives you one option :)
17:32:32 <Cale> Meady: that at least will be a starting point for figuring out what it is that sequence of steps is really doing
17:32:35 <Meady> it doesnt, cause we are saying, func1 >>= func2 etc
17:32:50 <Cale> Meady: I didn't say anything about >>=
17:32:59 <Cale> those are pure functions, and they just call each other
17:33:05 <Meady> hmm
17:33:06 <Meady> example?
17:33:58 <conal> @pl \ x y -> y * x
17:33:58 <lambdabot> (*)
17:34:01 <Cale> Okay, simple example... let's take the imperative version of computing the fibonacci numbers
17:34:02 <conal> wtf?
17:34:09 <Cale> conal: heh
17:34:21 <conal> known bug?
17:34:25 <Cale> conal: I guess it assumes that it's commutative.
17:34:26 <pikhq> conal: You asked for point-free form, didn't you?
17:34:35 <conal> oh!
17:34:35 <conal> wow
17:35:02 <bremner> @pl \ x y -> y - x
17:35:02 <lambdabot> subtract
17:35:10 <ben> Cale: This is basically handled in one of the first chapters of SICP, isn't it :v
17:35:11 <bremner> fail
17:35:11 <conal> @pl \ x y -> y / x
17:35:11 <lambdabot> flip (/)
17:35:16 <Cale> ben: yes
17:35:34 <conal> clever pl
17:35:45 <pikhq> @pl \ x y -> flip (-) y x
17:35:45 <lambdabot> (-)
17:35:54 <FunctorSal> bremner: the subtract one is correct
17:35:56 <Meady> Lol ben chillout
17:35:59 <FunctorSal> > subtract 1 0
17:36:00 <lambdabot>   -1
17:36:15 <bremner> oops, just checked. subtract does work that way
17:36:26 <FunctorSal> it makes sense for partial apps
17:36:43 <aavogt> @type (1-)
17:36:44 <lambdabot> forall t. (Num t) => t -> t
17:36:56 <aavogt> @type (-1)
17:36:57 <lambdabot> forall a. (Num a) => a
17:36:58 <ben> Especially as I appear to be unable to write subtract x as a section using -
17:37:29 <aavogt> @type (-(1))
17:37:30 <lambdabot> forall a. (Num a) => a
17:37:36 <FunctorSal> it's zeh unary minus
17:37:47 <pikhq> aavogt: Unary minus! OHNOES!
17:37:51 <ben> @type (flip (-) 1)
17:37:52 <lambdabot> forall a. (Num a) => a -> a
17:37:59 * shapr boings quietly
17:38:24 <aavogt> hmm, it would be just as ugly if they left it out
17:38:58 * sjw suggests ~ for unary minus
17:39:05 <sjw> I mean, really
17:39:12 <soupdragon> yeah
17:39:14 <soupdragon> Oz does that
17:39:24 <aavogt> > show (0-1)
17:39:25 <lambdabot>   "-1"
17:39:27 <soupdragon> Scheem just has - as part of number syntax
17:39:32 <soupdragon> (that sucks too)
17:39:41 <ben> Because you want to have unary minus for variables?
17:40:38 <bremner> soupdragon: yeah, people learning Oz love unary minus
17:40:52 <ben> We should just deprecate subtraction
17:41:25 <Cale> I like the status quo regarding -
17:41:36 <Cale> I think Haskell got it right.
17:42:16 <gwern> ben: we could represent everything as just adding negative numbers!
17:42:47 <gwern> having negative numbers subtraction and addition is just redundant
17:43:00 <dancor> commas are so redundant too
17:43:06 <FunctorSal> unary minus for variables would be good *bikeshed*
17:43:19 <conal> non-trivial equational theories are redundant
17:44:05 <dancor> conal: what is the best haskell frp library for me to make something cool in _right_now_
17:44:16 <conal> dancor: i don't know
17:44:25 <gwern> conal: your propaganda has worked too well! people actually want to *use* FRP!
17:44:37 <conal> oops!
17:44:48 <FunctorSal> :)
17:44:55 <gwern> conal: don't worry; it's an easy mistake. heck just look at dons
17:45:04 <QtPlaty[HireMe]> EXPN FRP?
17:45:13 <FunctorSal> btw I meant "minux in variable names would be good" o_O
17:45:16 <FunctorSal> minus
17:45:32 <dancor> i was looking at elerea
17:46:26 <FunctorSal> what did dons propagandise gwern?
17:46:45 <sjw> FunctorSal: like this-is-not-a-test?
17:46:58 <FunctorSal> sjw: yeah
17:47:12 <sjw> I find it much easier to read that thisIsNot ... or this_is_not even if it is lispish
17:47:13 <gwern> FunctorSal: haskell, of course
17:47:39 <FunctorSal> sjw: yeah, underscores look too much like spaces
17:51:39 <gwern> this SICP tutorial isn't too well-written
17:51:41 <allbery_b> QtPlaty: functional reactive programming
17:51:42 <gwern> 'Your procedure be written so that is gives rise to a recursive proces.'
17:53:06 <inimino> SICP tutorial?
17:53:32 <gwern> inimino: well, MIT's website which is a CGI thing of a whole bunch of problems for each chapter
17:53:46 <inimino> oh
17:54:05 <inimino> right
17:54:15 <gwern> (anyway, it sounds a little like a pirate - arr, your procedure be written right purty!)
17:54:41 <inimino> heh
18:25:16 <mkfort> I know that cabal upgrade says not to upgrade core packages. How do I know what's a core package?
18:30:54 <mkfort> channel seems real quiet tonight
18:33:02 <soupdragon> nobody uses haskell anymore
18:34:00 <mkfort> oh noes
18:34:13 <kpreid> > 1 + 1 -- I use haskell!!!
18:34:14 <lambdabot>   2
18:35:00 <pikhq> > (+)<$>[1,1..]<*>[1,1..]
18:35:01 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
18:36:11 <jeffwheeler> > head $ (+) <$> [1,1..]<*>[1,1..]
18:36:12 <lambdabot>   2
18:36:50 <pikhq> > cycle $ head $ (+) <$> [1,1..]<*>[1,1..]
18:36:51 <lambdabot>   No instance for (GHC.Enum.Enum [a])
18:36:51 <lambdabot>    arising from the arithmetic sequence...
18:37:09 <pikhq> XD
18:38:47 <jeffwheeler> :t cycle
18:38:49 <lambdabot> forall a. [a] -> [a]
18:39:02 <jeffwheeler> > cycle . (:[]) . head $ (+) <$> [1,1..]<*>[1,1..]
18:39:03 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
18:43:56 <copumpkin> why cycle . (:[]) and not repeat?
18:44:46 <jeffwheeler> Because pikhq wanted cycle.
18:44:57 <pikhq> Because I was stupid.
18:45:20 <copumpkin> > cycle . pure . head $ (+) <$> [1,1..]<*>[1,1..]
18:45:21 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
18:45:26 <copumpkin> no more angry monkey!
18:45:39 <jeffwheeler> pure?
18:45:41 <jeffwheeler> @src pure
18:45:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:45:43 <jeffwheeler> :t pure
18:45:44 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
18:45:58 <pikhq> @src pure :: [a]
18:45:58 <lambdabot> Source not found. Do you think like you type?
18:46:02 <jeffwheeler> > pure [1..]
18:46:03 <lambdabot>   No instance for (GHC.Show.Show (f [t]))
18:46:03 <lambdabot>    arising from a use of `M78497404...
18:46:08 <jeffwheeler> > pure [1, 2, 3]
18:46:09 <lambdabot>   No instance for (GHC.Show.Show (f [t]))
18:46:09 <lambdabot>    arising from a use of `M15566856...
18:46:15 <jeffwheeler> pure 3
18:46:19 <jeffwheeler> > pure 3
18:46:20 <lambdabot>   No instance for (GHC.Show.Show (f t))
18:46:20 <lambdabot>    arising from a use of `M2918587386...
18:46:23 <copumpkin> @src [] pure
18:46:23 <lambdabot> pure = return
18:46:32 <copumpkin> > pure 3 :: [Int]
18:46:33 <lambdabot>   [3]
18:46:35 <jeffwheeler> > pure 3 :: [Int]
18:46:36 <lambdabot>   [3]
18:46:37 <jeffwheeler> err, yeah
18:46:44 <pikhq> Applicative functors. Yeah.
18:47:04 <jeffwheeler> How would you use it for something other than lists?
18:47:05 <pikhq> @src [] return
18:47:05 <lambdabot> return x    = [x]
18:47:21 <pikhq> @src (->) pure
18:47:21 <lambdabot> pure = const
18:48:06 <pikhq> Hmm. The IO monad is also an applicative functor, right?
18:48:23 <copumpkin> yup
18:48:31 <copumpkin> that's why calling it "The IO Monad" is a little odd
18:48:39 <saml> hi
18:48:47 <pikhq> I'm a little odd.
18:48:49 <pikhq> Also noob.
18:48:53 <aavogt> Monad is more specific than Applicative Functor?
18:48:55 <copumpkin> it's the IO type constructor, that happens to be functor, applicative, monad
18:49:15 <saml> wanna be my mentor and help me with this Haskell wrapper of a C wrapper of a C++ library?
18:49:30 <saml> wait.. i should post a testcase
18:49:53 <pikhq> aavogt: Except that not all Monads are Applicatives.
18:49:59 * Nafai updates and tries leksah again
18:50:04 <copumpkin> pikhq: they can be
18:50:35 * jeffwheeler wishes Yi got as much attention as Leksah
18:51:14 <Pseudonym> It does.  Just not at the same time.
18:51:34 <Nafai> Yi would definitely be more my style
18:51:52 <Nafai> Actually, just some very nice functionality, perhaps like what Scion is doing, would be preferred
18:51:56 <Nafai> And then I could just keep using Emacs
18:52:22 <jeffwheeler> Yeah, _eventually_ we'll get Scion integration.
18:52:23 <blackdog> Nafai: what does scion actually give you in emacs? i couldn't work out what it gave above flymake
18:52:31 <jeffwheeler> But I don't know how much progress that project has made.
18:53:37 <Nafai> Eventually, I think source navigation (jump to definition, etc), code transformations, etc
18:53:52 <jeffwheeler> Some of that is already possible with htags, though.
18:54:03 <jeffwheeler> Or is hasktags? I never remember.
18:54:50 <Nafai> Unless you are navigating a static code base -- say, like Prelude -- tags are insufficient, in my opinion
18:55:16 <jeffwheeler> Indeed, they're definitely not great
18:55:24 <Nafai> After using Java ides where I could jump to any class anywhere in my code and any of its dependencies with just a single keystroke, I realize how very very nice that is
18:55:37 <saml> http://codepad.org/nlw2TWNU   halp
18:55:59 <blackdog> hm, never really used that feature. typechecking as you go in the editor is fantastic, that's all i really missed...
18:56:43 <blackdog> but i take your point about tags - unless they're continually regenerated by 'make' or something similar.
18:57:10 * jeffwheeler goes to look at scion progress
18:58:18 <Nafai> Plus hitting a keystroke (or using the mouse, if so inclined) on any method call / variable reference takes you to its definition
18:58:24 <Nafai> It makes understanding code much easier
18:58:33 <Nafai> Made me wonder why I ever thought using grep was a good idea
18:59:00 <jeffwheeler> haha, yeah
18:59:11 <jeffwheeler> how much of that stuff does Scion do?
18:59:26 <Nafai> I honestly don't know
18:59:33 <Nafai> nominolo|uni_: You around?
19:01:44 <monochrom> Just a moment ago from #math I understood why take k . quicksort plus laziness can avoid sorting the whole list.
19:01:44 <Nafai> I'm not sure how to build it right now, no .cabal file
19:02:58 <jeffwheeler> http://github.com/nominolo/scion/tree/master
19:03:02 <jeffwheeler> There's a Setup.hs file, though.
19:03:10 <jeffwheeler> So, runhaskell Setup install works.
19:03:23 <jeffwheeler> Here's the Yi bug: http://code.google.com/p/yi-editor/issues/detail?id=97
19:03:26 <monochrom> It goes like this: modify the algorithm this way. Find pivot and partition. Don't bother to sort the larger partition if clearly the smallest k elements are all in the smaller partition (because it has at least k elements).
19:04:15 <monochrom> If you do take k . quicksort then it's like doing that, dropping the larger partition.
19:04:50 <Pseudonym> monochrom, most modern sort algorithms can be modified to do that.
19:05:05 <Pseudonym> Merge sort, radix sort and heap sort most notably.
19:05:12 <Pseudonym> Older sort algorithms generally can't.
19:05:15 <monochrom> All the better!
19:05:16 <Nafai> jeffwheeler: Hrm.  When I do runhaskell Setup configure it complains about no .cabal
19:05:29 <jeffwheeler> Nafai: oh, let me see
19:05:35 <jeffwheeler> (I mean, let me try it myself.)
19:06:15 <monochrom> Anyway I'm happy because I couldn't explain it and now I can. And very simple explanation too.
19:06:36 <jeffwheeler> Nafai: oh, everything is in lib/
19:11:19 <Nafai> jeffwheeler: Oh!
19:12:45 <poh> how do I tell ghc about libraries that I install?
19:13:19 <poh> nevermind
19:13:35 <ikegami__> poh: the ghc-pkg command may help you
19:13:51 <poh> ikegami__: thanks, I'll look into it
19:15:01 <jeffwheeler> Okay, now I have to learn the basic design of Scion. Looks like I need to have a server running in the background to do anything?
19:15:14 <jeffwheeler> Or maybe not, if I'm running it inside a Haskell app.
19:15:24 <ikegami__> poh: Try `ghc-pkg list`. And, if you want to use the package, you can test 'ghci -package THE_PACKAGE_NAME'
19:15:38 <Nafai> jeffwheeler: I think the server is just for Emacs (for example) to communicate with
19:15:52 <jeffwheeler> I guess so, yeah.
19:16:03 <Nafai> I think it's designed to be able to be embedded in any Haskell program
19:16:10 <Nafai> Like Yi or Leksah or whatever
19:16:22 <jeffwheeler> Nifty. Now, I assume it doesn't really have to have an entire cabal project setup to work, though.
19:17:22 <Nafai> I can't imagine so
19:17:44 <Nafai> Remind me how to fix an error like this when I'm trying to build something:
19:17:44 <Nafai>     Could not find module `Control.Monad.Error':
19:17:44 <Nafai>       it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
19:18:27 <jeffwheeler> $ ghc-pkg unexpose mtl
19:18:29 <jeffwheeler> or is it hide?
19:19:13 <Gracenotes_> :x
19:19:14 <jeffwheeler> It's probably possible just for that installation, too, with an argument to cabal install.
19:22:12 <saml> ghci can't load .a ?
19:22:38 <saml> ghci /usr/lib/librtaudio.a     Warning: ignoring unrecognised input `/usr/lib/librtaudio.a'
19:23:29 <pikhq> How do you expect it to load .a?
19:23:46 <pikhq> That's not a dynamic library, that's just an archive of .o files.
19:25:16 <freedrull> think this website is about what i think it is about? http://tinc.debian.net/
19:25:38 <saml> pikhq, ah i see. thanks.
19:35:49 <jeffwheeler> I can't wait until I have a machine that can link GHC binaries without causing my music to skip.
20:44:47 <deech`> Hi all, anyone still here?
20:44:53 <Cale> yep
20:45:28 <deech`> Cool, just a quick question. I recently found out that function fall under the Category typeclass
20:45:44 <Cale> mhm
20:46:11 <deech`> So given a function say (1-), I can do (1-) >>> (1-).
20:46:18 <Cale> yeah
20:46:22 <deech`> This has the signature a -> b
20:46:32 <Cale> well, (Num a) => a -> a
20:46:57 <deech`> But when I do (1-) >>> (1-) 2, ghci answers 2, not 0 as I would have expected.
20:47:20 <FunctorSal> heh how does that typecheck at all
20:47:53 <Cale> actually, it should be a type error
20:47:55 <deech`> My ghci output:  Prelude Control.Arrow> ((1-) >>> (1-)) $ 15
20:47:55 <deech`> 15
20:47:56 <BMeph[A]> > 1-2
20:47:56 <lambdabot>   -1
20:48:05 <Cale> right, there you go
20:48:07 <BMeph[A]> > 1-(1-2)
20:48:08 <lambdabot>   2
20:48:30 <Cale> 1 - (1 - x) = 1 + x - 1 = x
20:48:43 <FunctorSal> deech`: ah, I was referring to the lack of $ in your first expression
20:48:52 <deech`> Oh
20:49:08 <FunctorSal> thought it was the (->) monad striking again or sth like that ;o
20:49:30 <deech`> So it doesn't do 15 - 1 - 1?
20:49:37 <Cale> You wrote 1 -  :)
20:49:45 <Cale> (1-) x = 1 - x
20:50:02 <deech`> Oh crap!
20:50:03 <coCocoa> Haskell: Sorry, it's not Psychic, it only does what you tell it to do. ;p
20:51:07 <deech`> Thanks! Embarassed, but appreciative!
20:52:13 <inimino> @faq Can Haskell DWIM?
20:52:13 <lambdabot> The answer is: Yes! Haskell can do that.
20:57:01 <FunctorSal> @faq needs some new tricks
20:57:01 <lambdabot> The answer is: Yes! Haskell can do that.
21:00:20 <pikhq> @faq Can functional programming solve the halting problem?
21:00:20 <lambdabot> The answer is: Yes! Haskell can do that.
21:02:03 <soupdragon> @faq is it possible with at least under or below but using minimum to produce possibly excess in what one wanted but not beyond threshold in under a reasonable time using only household exceptions?
21:02:03 <lambdabot> The answer is: Yes! Haskell can do that.
21:02:43 <soupdragon> @faq given at least eight can haskell unenumerate beyond past what started with to the point at which backwards wouldn't left, under or out?
21:02:43 <lambdabot> The answer is: Yes! Haskell can do that.
21:03:45 <shapr> I couldn't even parse the grammar on that last one.
21:03:55 <shapr> much less understand what it meant
21:05:30 <soupdragon> @faq does haskell at the type level isn't what without couldn't not beyond past under or at least the module system basically packaging or depacking as opposed to typeclass 'hackery'?
21:05:30 <lambdabot> The answer is: Yes! Haskell can do that.
21:09:24 <soupdragon> just because hes gay donent maen hes any less better
21:09:27 <soupdragon> oops
21:09:41 <greap> Are there any image manipulation / analysis libraries for haskell?
21:10:10 <Pseudonym> greap, have you looked at SWiK?
21:10:23 <greap> Pseudonym: nope
21:10:27 <Pseudonym> hang on.
21:10:31 <Pseudonym> No, not that.
21:10:45 <Pseudonym> http://covector.blogspot.com/
21:11:04 <Pseudonym> That.
21:11:21 <Pseudonym> And in particular:
21:11:22 <Pseudonym> http://www.easyvision.googlepages.com/
21:11:41 <Pseudonym> It's obviously designed for computer vision specifically.
21:11:54 <greap> That looks pretty wild.
21:12:00 <greap> But not quite what I'm after.
21:12:03 <Pseudonym> Yeah, it's pretty cool stuff.
21:12:35 <greap> Something more along the lines of imagemagick bindings would suit me better.
21:12:41 <meder> @faq Can Haskell Fail?
21:12:41 <lambdabot> The answer is: Yes! Haskell can do that.
21:19:47 <troutwine> Has anyone written an instance of Convertible SqlValue for a (String,Int)? I'm coming up a bit short of HDBC conversion examples.
21:31:12 <TheColonial> Hi guys. How do I go about getting an account on Haskell wiki?
21:36:58 <troutwine> TheColonial: Slow night.
21:37:14 <TheColonial> aint that the truth :)
21:39:21 <troutwine> Out of curiosity, have you ever written a Convertible instance for a (String,Int)? I'm a bit confused.
21:39:53 <Cale> troutwine: Convertible?
21:40:05 <troutwine> Cale: Data.Convertible.
21:40:49 <troutwine> Cale: Specifically, something like "instance Convertible SqlValue (String,Int) ..."
21:41:39 <troutwine> The instances provided in Data.Convertible are all basic types and I can't find complex type examples.
21:41:41 <Cale> troutwine: Okay. So apparently all you have to do is write a function  safeConvert :: a -> ConvertResult b
21:42:07 <Cale> and  ConvertResult b  is apparently the same as  Either ConvertError a
21:42:43 <troutwine> Hmm... thanks, Cale.
21:43:58 <Cale> and ConvertError is a record with four string fields: a representation of the source value, source type, destination type, and an error message.
21:45:45 <troutwine> Cale: Yep, I'm lost. Mind limping a neophyte along toward enlightenment, once again?
21:46:10 <Cale> instance Convertible SqlValue (String, Int) where
21:46:18 <Cale>   safeConvert x = ...
21:47:33 <Cale> When it succeeds, you'll want to produce  Right v, and when it fails you'll want to produce  Left (ConvertError (show x) "SqlValue" "(String,Int)" "description of what went wrong")
21:48:55 <Cale> I don't know how it is that you intend to convert a SqlValue into a (String,Int) pair though
21:49:43 <troutwine> Me neither. Which is strange because if I can't I'm not sure how to SELECT more than basic types with HDBC.
21:51:17 <Cale> troutwine: Normally you get a list of SqlValue results
21:51:31 <Cale> (well, a list of lists of SqlValue results)
21:52:33 <Cale> So you pattern match on that list and convert the elements.
21:53:32 <Cale> If you're sure that the query will result in values of appropriate types, you could write something like:
21:53:52 <Cale> [(convert s, convert n) | [s,n] <- resultList]
21:54:53 <troutwine> That's a thought.
21:55:06 <Cale> If resultList :: [[SqlValue]], then that can have type [(String,Integer)]
21:56:07 <Cale> you'll want to make sure that your query gets rows of the right length, or you'll get no results, and of the right types, or you'll get an error converting
21:56:40 <Cale> If you want to actually handle the errors, using the Either monad and safeConvert won't be too much more work
21:57:14 <jeffwheeler> Hmm, I've got an IO () that's printing to stdout, but I'm using a vty interface, which is getting thoroughly confused by the other text.
21:57:21 <troutwine> Thanks, again, Cale. That is indeed a much simpler approach.
21:57:39 <troutwine> Cale: Just in case no one has ever told you, you're a terribly helpful person.
21:57:42 <Cale> jeffwheeler: That's tricky.
21:57:46 <Cale> troutwine: :)
21:57:59 <jeffwheeler> What?
21:58:06 <jeffwheeler> oh
21:58:13 <Cale> jeffwheeler: Redirecting the stdout of individual IO actions.
21:58:27 <jeffwheeler> Yeah; didn't see the user "troutwine" above me, haha
21:58:55 <Cale> Probably easier to find a way to get that IO action to use your vty library :)
21:59:26 <Cale> (but not if you don't have its source code)
21:59:26 <jeffwheeler> Hmm . . . I wonder if Yi provides a standard mechanism for this.
21:59:49 <jeffwheeler> I'm running Scion actions in Yi.
22:04:18 <jeffwheeler> It looks like some stuff does exist, but it's specifically for separate processes, not generic IO actions.
22:06:18 <Nafai> jeffwheeler: How's Scion working out?
22:06:45 <jeffwheeler> Nafai: I just got back to it, but it seems to startup correctly.
22:06:52 <Nafai> Cool
22:06:54 <jeffwheeler> (Albeit messing with my vty in doing so, but heh)
22:09:00 <jeffwheeler> Oh, I can probably just set the verbosity. :)
22:18:02 <jeffwheeler> Evidently setting GHC verbosity to 0 (via Scion) was not as clever as I thought . . .
22:18:30 <lispy> isn't Scion a type of car?
22:18:39 <jeffwheeler> It is.
22:18:53 <mmorrow> jeffwheeler: for ghc you've gotta intercept stdout/err
22:19:10 <mmorrow> (lunabot (needs to) do exactly this)
22:19:35 <jeffwheeler> How can I do that for a specific IO action?
22:19:37 <mmorrow> jeffwheeler: http://moonpatio.com/repos/lunabot/Dup.hs
22:20:04 <mmorrow> (that could be done with a lot less ffi, but i got carried away :)
22:20:16 <mmorrow> (select()!!)
22:20:38 <jeffwheeler> Hmm . . . :-/
22:20:40 <mmorrow> iirc there's a pkg on hackage that does essentially the same exact thing
22:21:32 <mmorrow> (dunno if it blocks though under the circumstances (which i don't recall exactly) that prompted select() in that module though)
22:21:57 <mmorrow> jeffwheeler: http://hackage.haskell.org/package/io-capture
22:22:25 <jeffwheeler> That might work.
22:22:37 * jeffwheeler looks a bit more closely at that package
22:27:32 <thoughtpolice> clear
22:27:38 <thoughtpolice> damn, wrong window :)
22:28:41 <jeffwheeler> #resuscitation?
22:33:15 <jeffwheeler> mmorrow: that seems to be working alright; thanks for the tip
22:33:29 <mmorrow> jeffwheeler: nice, no problem
22:39:43 <coCocoa> mmorrow: Just curious, but have you checked out Kevin Hanna's stuff?
22:39:59 <coCocoa> Er, *Keith HAnna, sorry. :\
22:40:04 <mmorrow> no, what is that?
22:40:45 * mmorrow finds http://www.cs.kent.ac.uk/people/staff/fkh/
22:40:49 <coCocoa> @go PIVOTAL kent
22:40:50 <lambdabot> http://www.cs.kent.ac.uk/projects/pivotal/
22:40:50 <lambdabot> Title: Pivotal home page
22:41:04 <coCocoa> mmorrow: ^^
22:43:10 <mmorrow> coCocoa: interesting, thanks for the tip
22:44:16 <coCocoa> mmorrow: Sure. As if you didn't have enough side-projects already, lol. ;)
22:44:33 <ivanm> doesn't it use that evil Java language?
22:44:52 <ivanm> oh, it isn't, Vital was
22:45:10 <coCocoa> ivanm: His earlier one, PIVOT, did. I wonder if it'd make a good CAL interpreter... ;)
22:45:30 <ivanm> look how old it is though...
22:45:36 <coCocoa> Right, Vital. I forgot which five-letter name he used. ;p
22:45:46 <ivanm> it uses hsplugins and ghc 6.4 (apparently 6.40, but I think that's wrong...)
22:45:56 * ivanm thinks it's dead
22:48:38 <mmorrow> i remember Cale was describing come cool stuff about the mathematica ui, and it seems like pivotal/vital has similar stuff going on
22:49:15 <mmorrow> like say you print a value (that's mutable i guess or something), then you update it 5 lines later
22:49:35 <mmorrow> the display of the val 5 lines up changes
22:49:53 <mmorrow> stuff like that. i thought that was cool
22:51:31 <soupdragon> it's not a mutable value .. it's a 'behavior' :P
22:51:50 <jeffwheeler> :t liftIO
22:51:51 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
22:53:52 <te> Anyone around?
22:54:00 <coCocoa> te: Nope. ;)
22:54:12 <coCocoa> te: Heh-heh. Go ahead. :)
22:54:14 <te> I am trying to figure out how to make a prompt in XMonad that will take the input and give it to a commanbd line twitter utility
22:54:25 <te> I've been doing my studying, but the docs are still swahili to me
22:55:39 <te> i keep thinking in terms of $1 for passing the user input, but that's wrong
22:55:51 <te> like spawn "twitter update $1"
22:56:01 <mmorrow> soupdragon: hehe
22:56:48 <mmorrow> te: what is your input coming from?
22:57:03 <te> The user input that will be typed into the Prompt that comes up
22:57:23 <mmorrow> so is all the gui stuff out of the way at this point, and you have a String?
22:57:49 <mmorrow> (because if not, i don't know xmonad gui particulars)
22:58:03 <mmorrow> @type System.system
22:58:03 <te> the "gui" stuff is taken care of by XMonad.Prompt
22:58:04 <lambdabot> String -> IO GHC.IOBase.ExitCode
22:58:26 <mmorrow> @hoogle process
22:58:27 <lambdabot> package process
22:58:27 <lambdabot> module System.Process
22:58:27 <lambdabot> System.Posix.Types type ProcessGroupID = CPid
22:58:30 <mmorrow> @hoogle command
22:58:31 <lambdabot> module Distribution.Simple.Command
22:58:31 <lambdabot> Distribution.Simple.Command data Command action
22:58:31 <lambdabot> Distribution.Simple.Command commandAddAction :: Monoid flags => CommandUI flags -> (flags -> [String] -> action) -> Command action
22:58:38 <mmorrow> err, bad results
22:58:53 <te> mmorrow: here's another example entry of a prompt from my config...
22:59:03 <mmorrow> do you need output from the shell command?.
22:59:09 <te>     , ("M-p n", appendFilePrompt myXPConfig "/home/defn/Dropbox/NOTES")
22:59:11 <te> no
23:00:04 <mmorrow> what's the type of appendFilePrompt?
23:00:17 <mmorrow> te: (do you have ghci?)
23:00:22 <te> yes
23:00:40 <mmorrow> cool, how familiar are you with haskell/ghci?
23:00:45 <te> i dont know much though
23:00:52 <te> ive done some reading and am grasping the theoretical stuff
23:01:00 <mmorrow> ok, have you ever loaded xmonad code in ghci?
23:01:01 <te> but when it comes to /doing stuff/, i am still a little bewildered
23:01:10 <te> it's been a couple weeks
23:01:23 <mmorrow> what i would do is run ghci, then
23:01:30 <te> k, running...
23:01:33 <mmorrow> :m + XMonad.
23:01:38 <mmorrow> and then start tapping tab
23:01:49 <mmorrow> "tab fishing" ;)
23:02:00 <te> haha yes, only 3200+ entries!
23:02:03 <mmorrow> you should see all the xmonad modules pop up
23:02:05 <mmorrow> oh noes
23:02:25 <mmorrow> did you type out ":m + XMonad."
23:02:27 <mmorrow> first?
23:02:32 <te> yessir
23:02:37 <te> i think it's all the contrib stuff
23:02:45 <te> there's a lot of stuff in there
23:02:45 <mmorrow> ah, heh
23:03:09 <te> tabbing on XMonad.[tab] [tab]
23:03:09 <mmorrow> ok, just start loading a few top-level XMonad modules
23:03:13 <te> gives me 1400, so heh
23:03:27 <mmorrow> better yet, look in your xmonad.hs and load the modules it imports
23:03:43 <mmorrow> then find the type of appendFilePrompt
23:03:49 <mmorrow> :t id
23:03:50 <lambdabot> forall a. a -> a
23:04:39 <te> mmorrow: how do I load everything within a specific scope
23:04:43 <te> like XMonad.Prompt.*
23:04:49 <mmorrow> so one really handy thing is to just sit there and build up the expression you want by continually using ":t" and incrementally adding to it
23:04:58 <mmorrow> te: unfortunately you can't
23:05:06 <mmorrow> but try loading XMonad
23:05:06 <te> ah, no worries
23:05:19 <te> i tried 'import XMonad'
23:05:26 <mmorrow> usually the top-level modules will export a bunch of modules
23:05:30 <te> it gave me "InterruptInterruptInterrupt"
23:05:32 <mmorrow> :m + XMonad
23:06:03 <te> so with the :m + XMonad I've already 'imported' XMonad?
23:06:16 <te> I really don't need much else to test this besides Prompt I don't think
23:06:35 <mmorrow> we need to find out the type of appendFilePRompt
23:06:43 <te> okay, i can get that for you, one sec
23:06:43 <mmorrow> to figur eout how we can do this
23:07:30 <te> mmorrow: it seems like there might be a better way
23:07:38 <te> mmorrow: that function is specifically for appending to a file
23:07:49 <te> there are lots of other functions in Prompt.*
23:08:00 <mmorrow> what does
23:08:09 <te> appendFilePrompt
23:08:10 <mmorrow> ":t appendFilePromopt" output?
23:08:19 <mmorrow> s/o//
23:08:44 <te> appendFilePrompt :: XPConfig -> FilePath -> X ()
23:08:55 <mmorrow> woohoo, ok that's a start :)
23:09:34 <mmorrow> hmm, unfortunately that doesn't mean much to me since i'm not familiar with xmonad :(
23:09:45 <te>  :t XMonad.Prompt.Input.inputPrompt
23:09:45 <te> XMonad.Prompt.Input.inputPrompt :: XPConfig -> String -> X (Maybe String)
23:10:14 <mmorrow> te: (basically, if you can get a hold of a String, and get into IO, you can use (System.system :: String -> IO ExitCode))
23:10:29 <te> XPConfig doesn't really do anything in this instance except for give the Prompt a background color
23:12:43 <mmorrow> te: what does this say in ghci?:
23:13:41 <mmorrow> :t \a b -> io . System.command .  maybe [] id =<< inputPrompt a b
23:13:42 <lambdabot> Not in scope: `io'
23:13:42 <lambdabot> Not in scope: `System.command'
23:13:42 <lambdabot> Not in scope: `inputPrompt'
23:14:10 <mmorrow> (http://hackage.haskell.org/packages/archive/xmonad/0.8.1/doc/html/XMonad-Core.html   btw)
23:14:32 <mmorrow> io looks to be the ticket to run IO actions in X
23:14:43 <te> <interactive>:1:13: Not in scope: `System.command'
23:14:50 <mmorrow> err, my bad
23:14:51 <te> i imported System, System.CMD
23:14:53 <mmorrow> System.system
23:14:54 <te> System.IO
23:14:56 <te> ah okay
23:15:45 <te> still didnt work
23:15:49 <te> not in scope
23:15:53 <mmorrow> which
23:16:03 <te> the line you gave above
23:16:10 <te> "not in scope 'System.command'"
23:16:13 <mmorrow> oh yeah gah, System.Cmd.system
23:16:16 <mmorrow> heh
23:16:51 <te> \a b -> io . System.Cmd.system .  maybe [] id =<< inputPrompt a b :: XPConfig -> String -> X ExitCode
23:17:09 <mmorrow> wooo, that should do something at least
23:17:20 <mmorrow> (exactly what, i guess we'll find out ;)
23:17:30 * mmorrow was to sleeep
23:17:33 <mmorrow> good luck
23:17:38 <te> thanks for your help
23:17:41 <mmorrow> np
23:18:38 <cads> vixey oh no you've been hanging out in the #not-math channel, they haven't warped you have they?
23:18:55 <cads> evening, all
23:24:26 <adu> hi
23:45:53 <soupdragon> hi
23:50:33 <Zeiris> Is there a limit on the size of Integer? How efficient are operations on ridiculously large ones?
23:51:30 <ivanm> Zeiris: your memory
23:51:33 <soupdragon> Zeiris: There is no conceptual limit on the size of Integer
23:51:36 <ivanm> and processing time
23:51:55 <ivanm> bigger numbers => more RAM for storage, more CPU time for processing
23:53:43 <portnov> humm. Maybe, there is a library for DB connections pool for Haskell?
