00:01:14 <ray> kleisli motorbike
00:03:09 <copumpkin> *Main> let ?plus = Plus; ?times = Times in zero :: Integer
00:03:10 <copumpkin> :P
00:04:30 <Trinithis> You can have ? mixed with letters in an id?
00:04:48 <copumpkin> it's implicit parameters
00:04:49 <lpsmith> not in Haskell
00:05:01 <Trinithis> o
00:05:05 <lpsmith> err,  yeah
00:09:36 <copumpkin> hmm, seems like implicit parameters aren't very friendly
00:10:50 <dolio> > let ?x = 5 in let f y = ?x + y in let ?x = 4 in f 1
00:10:51 <lambdabot>   5
00:11:15 <copumpkin> I can't figure out how to write a function that sets implicit parameters for me, a bit like an implicit parameter "bracket"
00:11:27 <copumpkin> trying Rank2Types now
00:12:10 <copumpkin> hmm doesn't seem to be working
00:12:25 <dolio> > let f y = let ?x = 4 in y in let y = ?x + 1 in f y
00:12:26 <lambdabot>   Unbound implicit parameter (?x::a)
00:12:27 <lambdabot>    arising from a use of implicit parame...
00:16:24 <copumpkin> doesn't feel very "composable" if that isn't possible
00:16:42 <dolio> Heh, composable.
00:16:51 <copumpkin> not sure what else to call it :P
00:17:32 <copumpkin> if I can't abstract that stuff away into a function it isn't very useful to me
00:17:43 <dolio> Implicit parameters are an impure reader monad with not-really-dynamic-scope semantics.
00:18:14 <dolio> So 'composable' isn't high on the list of expectations, I'd say.
00:18:21 <copumpkin> :)
00:20:23 * copumpkin pouts
00:21:30 <blueonyx> :t forM
00:21:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
00:21:45 <mmorrow> dolio: yeah, (granted i haven't rtfm, but) i'm constantly guessing incorrectly how they'll behave in different situations
00:22:13 <mmorrow> they seem weird to me, but again maybe it'll make sense having rtfm
00:22:29 <copumpkin> tfm on implcit parameters is short
00:22:32 <erikc> what's a good book for learning about all this ring, category, lie algebra stuff
00:22:41 <erikc> sometimes i regret doing ece instead of math
00:22:59 <mmorrow> copumpkin: hmm, so is there nothing to them, or is tfm not really descriptive?
00:23:15 <mmorrow> copumpkin: iirc there's some paper (surprise)
00:23:18 <copumpkin> mmorrow: I dunno, tfm was short and referred to a paper which I didn't feel like reading
00:23:21 <copumpkin> yeah
00:23:23 <mmorrow> heh
00:23:35 <copumpkin> and didn't cover my use case or give an explanation beyond the obvious
00:23:39 <mmorrow> , let ?x = ?x in ?x
00:23:41 <lunabot>  luna: Unbound implicit parameter (?x::a)
00:23:49 <dolio> > let y = ?x + 1 ; z = let ?x = 5 in y in let ?x = 4 in z
00:23:49 <mmorrow> , let ?x = 42 in let ?x = ?x in ?x
00:23:50 <lambdabot>   Unbound implicit parameter (?x::a)
00:23:50 <lambdabot>    arising from a use of implicit parame...
00:23:51 <lunabot>  42
00:24:00 <mmorrow> , let ?x = 42; ?x = ?x in ?x
00:24:01 <lunabot>  luna: Unbound implicit parameter (?x::a)
00:24:09 <copumpkin> it sort of feels half-assed from my tinkering
00:24:11 <mmorrow> , let ?x = 42; x = ?x in x
00:24:12 <lunabot>  luna: parse error on input `x'
00:24:20 <copumpkin> but maybe I just had my expectations set too high
00:24:27 <mmorrow> , let {?x = 42; x = ?x} in x
00:24:28 <lunabot>  luna: parse error on input `x'
00:24:33 <mmorrow> hrm
00:24:53 <mmorrow> , let ?x = 42 in let x = ?x in x
00:24:54 <lunabot>  42
00:25:11 <copumpkin> (ew)
00:25:12 <mmorrow> i wonder why the parse error
00:25:21 <mmorrow> , let {?x = 42; y = ?x} in y
00:25:22 <lunabot>  luna: parse error on input `y'
00:25:27 <mmorrow> , let {?x = 42; y = ?x} in z
00:25:28 <lunabot>  luna: parse error on input `y'
00:25:31 <mmorrow> , let {?x = 42; z = ?x} in y
00:25:32 <lunabot>  luna: parse error on input `z'
00:25:36 <mmorrow> hmm
00:25:40 <copumpkin> I guess you can't define implicit parameters in the same let block as explicit bindings?
00:25:46 <mmorrow> ahh
00:25:47 <copumpkin> "just cuz"?
00:25:54 <mmorrow> yeah, that would explain this
00:26:26 <mmorrow> and also that just made me remember seeing implicit param binding groups separated from other binding groups in the haskell-src-exts AST
00:26:31 <copumpkin> , let {?x = 42; y = 56} in y
00:26:32 <lunabot>  luna: parse error on input `y'
00:26:36 <mmorrow> so i guess that is how it works
00:26:39 <copumpkin> , let {?x = 42; ?y = 56} in ?y
00:26:40 <lunabot>  56
00:26:49 <copumpkin> separate but equal
00:26:54 <mmorrow> heh
00:28:52 <mmorrow> , let ?x = 1 in let go !n = ?x : let ?x = 100*(n+1) in go (n+2)
00:28:53 <lunabot>  luna: parse error on input `)'
00:29:05 <mmorrow> , let ?x = 1 in let go !n = ?x : let ?x = 100*(n+1) in go (n+2) in go 0
00:29:06 <lunabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:29:25 <copumpkin> :o
00:29:42 <dolio> > let ?x = 4 in (let ?x = 5 in (\y -> ?x + y)) 1
00:29:43 <lambdabot>   6
00:29:47 <mmorrow> , let f = let go !n = ?x : let ?x = 100*(n+1) in go in let ?x = 1 in f 0
00:29:48 <lunabot>  luna: parse error on input `)'
00:30:07 <nanothief> perl called, he wanted his syntax back :P
00:30:15 <dolio> > let ?x = 4 in (let ?x = 5 in let f y = ?x + y in f) 1
00:30:16 <lambdabot>   6
00:30:23 <mmorrow> , let f = let {go !n = ?x : let {?x = 100*(n+1) in go (n+2)} in go} in let {?x = 1} in f 0
00:30:24 <lunabot>  luna: parse error on input `in'
00:30:41 <mjs22> Quick question about type signatures.  I have a function that, when I write without providing an explicit signature that is accepted just fine by GHC.  When I add the signature that is provided by saying ":t" on the function in the interactive shell, GHC starts complaining about not being able to deduce the signature that I gave it.  Any idea what could cause it to be happy without the signature, and unhappy when I give it the one ghci d
00:30:51 <mmorrow> , let {f = let {go !n = ?x : let {?x = 100*(n+1) in go (n+2)} in go}} in (let ?x = 1 in f 0)
00:30:53 <lunabot>  luna: parse error on input `in'
00:32:24 <mmorrow> , let f = (let go !n = ?x : (let ?x = 100*(n+1) in go (n+2)) in go) in (let ?x = 10 in f 0)
00:32:25 <lunabot>  luna: Unbound implicit parameter (?x::a)
00:32:47 <mmorrow> ok, i'm gonna rtfp because this is driving me crazy
00:33:48 <mmorrow> ooh
00:33:53 <copumpkin> ?
00:34:09 <mmorrow> i just saw dolio's last exp and am trying to parse it
00:34:21 <Cale> mjs22: That's interesting, what is the type?
00:35:48 <mmorrow> , let f y = ?x + y in let (left,right) = (let ?x = 1 in f, let ?x = 2 in f) in (left 3, right 3)
00:35:50 <lunabot>  (4,5)
00:36:01 <mmorrow> hmm, ok i think i'm starting to see
00:36:11 <Cale> mjs22: still with us?
00:36:28 <copumpkin> :o
00:36:40 <mjs22> cale: It's a bit hairy.  It is  -- (Streamer c1 b, Streamer c (Maybe b), Streamer a' Bool, Streamer a b) => a -> a' -> c1.  Where "Streamer" is a typeclass I created where given an instance "Streamer a b", b is uniquely determined by a. (Functional dependency syntax used to state this)
00:37:10 <mjs22> I'll try to get a reproducer that isn't huge.  The code is a bit large to stick in a pastebin page right now.
00:37:26 <Cale> mjs22: okay
00:38:05 <mjs22> it's been driving me up a wall for the last few hours....
00:38:20 <mmorrow> so the ?x 'll capture the value of the current ?x if there's one in scope at the point of definition of `f', and if not then it will delay capturing it until it's evaluated
00:38:46 <mmorrow> the part i'm still not sure about though, is whether "... until it's evaluated" is when the capture in that case happens
00:38:52 <Cale> mjs22: That  Streamer c (Maybe b)  seems weird, doesn't it?
00:39:06 <Cale> mjs22: c isn't mentioned anywhere else in the type
00:39:21 <mmorrow> but it seems like it might as well (?)
00:39:33 <mmorrow> (might as well := wlog)
00:40:01 <nyingen> Library problem here: when I try to import Control.Monad.Identity, I get an error about it being found in both mtl and transformers. What should I do?
00:40:14 <mjs22> cale: Yes, it is.  The signature I came up with on my own was "Streamer a (Maybe b), Streamer c Bool, Streamer d b => a -> c -> d".  But that caused problems, so I decided to try the one GHCi inferred from the function itself.
00:40:33 <Cale> nyingen: ghc-pkg hide transformers
00:41:08 <Cale> nyingen: It'll make sure that the transformers package is only used if explicitly requested
00:41:17 <nyingen> Cale: gotcha
00:41:43 <nyingen> I found some msgs on the mailing list archive about mtl possibly being phased out in favor of transformers, so I wasn't sure
00:42:10 <Cale> oh, maybe, but mtl is far more common
00:42:13 <mmorrow> err, yeah. so s/evaluated/at any point where a closure's created that ?x is reachable from, there's the possibility of capturing the current ?x in scope (if there is one), but once you capture an ?x, then it's fixed/
00:42:15 <mmorrow> or something
00:42:27 <mmorrow> (???)
00:43:19 <mmorrow> , let f y = ?x + y in let (left,right) = (let ?x = 1 in f, let ?x = 2 in f) in let (up,down) = (let ?x = 100000 in left, let ?x = 54321 in right) in (left 3, right 3, up 3, down 3)
00:43:20 <lunabot>  (4,5,4,5)
00:43:29 <copumpkin> :o
00:43:41 <mmorrow> , let f y = ?x + y in let (left,right) = (let ?x = 1 in f, let ?x = 2 in f) in let (up,down) = (let ?x = 100000 in f, let ?x = 54321 in f) in (left 3, right 3, up 3, down 3)
00:43:42 <lunabot>  (4,5,100003,54324)
00:44:30 <mmorrow> and the last case
00:44:51 <mmorrow> , let f y = ?x + y in let (left,right) = (f, f) in let (up,down) = (let ?x = 100000 in left, let ?x = 54321 in right) in (left 3, right 3, up 3, down 3)
00:44:52 <lunabot>  luna: Unbound implicit parameter (?x::a)
00:44:56 <mmorrow> , let f y = ?x + y in let (left,right) = (f, f) in let (up,down) = (let ?x = 100000 in left, let ?x = 54321 in right) in (up 3, down 3)
00:44:56 <lunabot>  luna: Unbound implicit parameter (?x::a)
00:45:09 <mmorrow> err, i expected the first, but not the second
00:45:19 <mmorrow> err, that makes sense actually
00:45:31 <mmorrow> hmm
00:46:31 <mmorrow> i think staring at these four expressions might be enough to completely describe how they work (did i miss any possibilities?)
00:48:23 <copumpkin> I think I'm gonna go to bed :P
00:48:42 <mmorrow> heh
00:48:43 <mmorrow> night
00:49:02 * mmorrow stares
00:59:41 <EnglishGent> hello :)
00:59:47 <Cale> hello
01:00:20 <EnglishGent> hi Cale :)
01:32:43 <hackagebot> type-level 0.2.3 - Type-level programming library (LennartAugustsson)
02:02:58 <agapoulitsas> is there a way to uninstall packages through cabal?
02:03:18 <dolio> No.
02:03:37 <agapoulitsas> so how do i do this?
02:04:12 <dolio> To remove something, you use ghc-pkg unregister, and then delete it by hand.
02:18:09 <blueonyx> :t error
02:18:10 <lambdabot> forall a. [Char] -> a
02:19:20 <blueonyx> is there a way to catch such errors?
02:27:26 <WorkyBob> anyone know the relevant options to throw at ghc to make it produce a dynamic library given some C and some haskell?
02:27:40 <Axman6> all of them
02:27:44 <WorkyBob> (the haskell providing FFI exports)
02:27:47 <Axman6> just check 'em all in there ;)
02:27:58 <WorkyBob> the manual implies that you can do it – but doesn't say what the necessary magic is
02:28:02 <Axman6> add a little oregano, and BAM!
02:36:29 <agapoulitsas> i am trying to install sqlite through cabal
02:36:41 <agapoulitsas> and the error message says:
02:36:58 <agapoulitsas> cabal: Missing dependency on a foreign library:
02:36:59 <agapoulitsas> * Missing header file: sqlite3.6
02:37:04 <agapoulitsas> cabal: Missing dependency on a foreign library:
02:37:19 <agapoulitsas> what sshould i do?
02:38:35 <ryo_hazuki> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=7572#a7572
02:40:03 <blackh> agapoulitsas: Try installing the dev package for sqlite for your operating system
02:41:25 <agapoulitsas> blackh: you mean download the src and install it manually?
02:41:38 <blackh> agapoulitsas: What operating system are you using?
02:41:45 <agapoulitsas> ubuntu
02:42:24 <blackh> agapoulitsas: Then install a package called libsqlite-dev using apt-get
02:45:21 <agapoulitsas> blackh: Failed to load interface for `Database.SQLite'
02:45:25 <agapoulitsas> the problem remains
02:46:00 <blackh> Did you do the cabal install again?
02:47:03 <agapoulitsas> yes
02:47:26 <blackh> Oh dear.
02:48:58 <blackh> Well, there can't be much wrong if that's the only error message.
02:49:40 <blackh> If you get stuck, paste the whole output and I might be able to help.
02:51:35 <ryo_hazuki> if anyone has some sparetime left and wants a small exercise: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=7572
02:52:03 <blackh> This isn't your homework, is it? :)
02:52:29 <agapoulitsas> no i am experimenting with the package system
02:53:31 <RayNbow> I think blackh's last comment was directed at ryo_hazuki :p
02:53:51 <blackh> agapoulitsas: If you want help with BerkeleyDB or DBXML I can help more.  I'm the maintainer, and I want to eliminate SQL !
02:53:59 <agapoulitsas> i installed the "dev" package that produced the sqlite3.o
02:54:04 <ryo_hazuki> nope, it isn't
02:54:11 <ryo_hazuki> found it in a german forum
02:54:25 <blackh> ryo_hazuki: In that case, I might find it hard to resist!
02:54:31 <ryo_hazuki> hehe
03:14:06 <zmyrgel> hi, how can I specify which package to use while building?
03:14:42 <zmyrgel> I'm trying to install old-time but it fails as it finds System.Locale on my home and with ghc package.
03:14:49 <zmyrgel> I want it to use the one in my home
03:23:20 <zmyrgel> I found some info how to pass ghc option '-package P' but the step './Setup build' won't accept it
03:24:02 <quicksilver> if it's a cabal package, which it obviously is if you're Setup build'ing it
03:24:07 <quicksilver> then change the dependences in the .cabal file
03:24:12 <quicksilver> to depend on the version you want.
03:26:51 <zmyrgel> quicksilver: the other package is in base so I can't just remove that from dependencies as then it fails to find other stuff
03:31:00 <quicksilver> zmyrgel: I don't understand what you are saying.
03:31:12 <quicksilver> you can only build the pacakge if you have a set of dependencies which it iwll work with.
03:31:22 <quicksilver> if you specify those dependencies in the .cabal file, then it will work.
03:31:31 <quicksilver> dependencies are always at the package level, not module level.
03:32:14 <hackagebot> hex 0.1.1 - Convert strings into hexadecimal and back. (TaruKarttunen)
03:33:00 <zmyrgel> quicksilver: I'm trying to install old-time package as cabal-install lists it as dependency
03:33:39 <zmyrgel> during the 'Setup build' step it exists the build as it finds the System.Locale package in two places
03:33:51 <zmyrgel> and lists those as: base, old-locale
03:34:15 <zmyrgel> the old-locale is installed in my ~ and base with ghc package.
03:35:29 <zmyrgel> I need to specify the Setup build to use the old-locale thats in my home.
03:35:57 <zmyrgel> the cabal-install.cabal file has base and old-locale both as dependencies
03:37:29 <blackh> zmyrgel: Sounds like something is wrong.  I don't know what the real solution is, but you could easily hack cabal-install.cabal and put in a specific version number.  Then ghc will see only the one you chose.
03:37:59 --- mode: irc.freenode.net set +o ChanServ
03:40:16 <hackagebot> network-fancy 0.1 - Networking support with a cleaner API (TaruKarttunen)
03:40:31 <mmorrow> @hackage network-fancy
03:40:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/network-fancy
03:41:17 <zmyrgel> hmm, I think I'll try to update my ghc with some wip status port and then install cabal and stuff
03:41:39 <zmyrgel> My original goal was to try to install latest ghc from darcs repo
03:41:52 <zmyrgel> Currently running 6.6.1
03:42:17 <mmorrow> if the network-fancy author happens to be present, i think you forgot to darcs add network-fancy.h
03:42:47 <blackh> zmyrgel: The binary releases of GHC are generally very good, unless you have an uncommon architecture.
03:43:20 <blackh> zmyrgel: 6.6.1 is very old
03:43:27 <zmyrgel> blackh: OpenBSD doesn't have newer port of it
03:43:47 <zmyrgel> and all the newer ones are buggy on amd64
03:44:04 <zmyrgel> thats why I was planning to test the latest version
03:44:17 <zmyrgel> to see if ghci would work
03:44:22 <Ke> how come buggy?
03:44:34 <blackh> zmyrgel: In theory you should be able to build 6.10.X from source against your existing 6.6.1.  ghc is completely bug free on amd64 on Ubuntu
03:44:39 <zmyrgel> Ke: ghci segfaults for example
03:44:44 <Ke> isn't x86_64 like the only actual arch nowadays
03:45:10 <zmyrgel> a lot of stuff still likes x86 :(
03:45:29 <Ke> legacy stuff like ghc =oP
03:45:46 <sioraiocht> If I have a function foo x = foo (init x) ++ x, how much copying is taking place?
03:45:49 <Ke> zmyrgel: any example code?
03:45:50 <sioraiocht> sorry
03:45:52 <zmyrgel> blackh: yeah, openbsd-ports@ had some wip port of 6.10.1 which installs
03:45:55 <sioraiocht> sorry
03:45:58 <sioraiocht> let me do that again =p
03:46:09 <zmyrgel> Ke: segfaults on startup
03:46:19 <Ke> can't say it does
03:46:26 <sioraiocht> if I have foo x = foo (init x) ++ [x], does it copy have to do much copying
03:46:38 <sioraiocht> minus the first copy
03:47:20 <Ke> would be curious to see segfault in haskell, unless there is a compiler bug
03:47:27 <sioraiocht> it seems to me it has to copy every element only once of the resulting list only once
03:47:31 <sioraiocht> am I totally wrong?
03:47:32 <Ke> or stack overflow
03:47:36 <zmyrgel> Ke: theres an issue about it on ghc bug tracker but they're waiting to hear if the suggested patch would work on openbsd. FreeBSD seemed to work with it
03:47:56 <Ke> zmyrgel: so the bug is only on OpenBSD?
03:48:12 <mmorrow> , let xs = [0,1] in vacuum (init xs ++ xs)
03:48:15 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[4,5]),(4,[]),(5,[])]
03:48:21 <Ke> zmyrgel: I would expect openBSD people to like things like no execute bit
03:48:42 <mmorrow> , vacuum [0,0,1]
03:48:44 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[])]
03:48:57 <mmorrow> , let x = 0;xs = [x,x,1] in vacuum xs
03:49:00 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[4,5]),(4,[]),(5,[])]
03:50:04 <zmyrgel> Ke: probably. I only have 64-bit OpenBSD systems and not anything else so I haven't tested it that well
03:50:34 <zmyrgel> at least the current 6.6.1 gives: ghc-6.6.1: internal error: R_X86_64_PC32 relocation out of range: environ = 0xfffffffdf6fd940e
03:51:28 <zmyrgel> Gotta check how far I can get with the 6.10.1 port.
03:52:00 <athos> @src vacuum
03:52:00 <lambdabot> Source not found. :(
03:52:17 <ivanm> athos: it's probably inbuilt into lunabot
03:52:21 <ivanm> using the vacuum library/app
03:52:24 <ivanm> @hackage vacuum
03:52:24 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum
03:53:32 <mmorrow> , let xs = [0..8]; ys = xs++[9]; zs = [0..9] in fmap (length . vacuum) [(xs ++ ys),(init ys ++ ys),(init zs ++ zs),(xs ++ zs)]
03:53:34 <lunabot>  [30,30,30,39]
03:54:33 <mmorrow> http://moonpatio.com/vacuum/gallery/transpose.html
03:54:50 <mmorrow> that one's still my favorite i think
03:55:28 <ivanm> mmorrow: can't zoom in :(
03:55:36 <ivanm> and I suppose the box is the code that it's showing?
03:56:01 <mmorrow> ivanm: yeah, you could regenerate that yourself with literally that code in ghci
03:56:38 <ivanm> , left = replicate 4 [0..3]; right = transpose left in vacuum right
03:56:39 <lunabot>  luna: parse error on input `='
03:56:44 <ivanm> , let left = replicate 4 [0..3]; right = transpose left in vacuum right
03:56:46 <lunabot>  [(0,[1,2]),(1,[3,4]),(2,[8,9]),(3,[]),(4,[3,5]),(5,[3,6]),(6,[3,7]),(7,[]...
03:57:43 <agapoulitsas> $hackage sqlite
03:57:48 <athos> i still don't get what that stuff is about ;-)
03:57:55 <agapoulitsas> @hackage sqlite
03:57:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sqlite
03:58:04 <mmorrow> athos: that's the heap graph formed by the data
03:58:11 <athos> but perhaps it's good the way things are. otherwise i'd launch nuclear weapons by using vacuum
03:58:43 <mmorrow> (nodes := closures), (edges := ptrs to closures (which are located in closures))
03:58:58 <mmorrow> , vacuum (fix (0:))
03:59:01 <lunabot>  [(0,[1,0]),(1,[])]
03:59:59 <mmorrow> void *xs[2]; int n; n = 0; xs[0] = xs; xs[1] = &n;
04:00:27 <mmorrow> (well, swap [0] and [1])
04:00:38 <mmorrow> xs[0] = &n; xs[1] = xs
04:00:42 <Ke> so haskell actually has a module that can draw graphs that actually do not cause seizures when people see them?
04:01:25 <mmorrow> Ke: i think some sort of helpless animal is struck by lightning each time you run it though..
04:01:47 <ivanm> Ke: why would a graph cause a seizure?
04:02:49 <Ke> ivanm: no idea, there arent too many free programs that can automatically draw graphs
04:03:25 <ivanm> Ke: graphviz
04:03:27 <ivanm> end of story
04:03:28 <ivanm> ;-)
04:03:41 <Ke> (would be nice to have such a extension to latex)
04:03:46 <ivanm> (OK, it might not produce the prettiest graphs...)
04:03:50 <ivanm> Ke: you can use graphviz in latex
04:03:57 <ivanm> I did it for my thesis last yera
04:03:59 <ivanm> *year
04:04:02 <ivanm> @go graphviz latex
04:04:05 <lambdabot> http://www.graphviz.org/Resources.php
04:04:05 <lambdabot> Title: Graphviz
04:04:14 <Ke> ivanm: I thought graphviz required manual labour
04:04:55 <ivanm> Ke: define "manual labour"
04:05:02 <mmorrow> cat foo.dot | dot -Teps
04:05:03 <ivanm> you have to specify the graph
04:05:14 <ivanm> mmorrow: you forgot the > foo.eps
04:05:30 <mmorrow> i wanted to see it! :)
04:05:31 <Ke> ivanm: but no actual application of any pointer device is required?
04:05:39 <ivanm> no
04:05:50 <ivanm> mmorrow: the actual physical postscript output? :o
04:06:19 <ivanm> also, you don't need to cat the dot file
04:06:32 <ivanm> dot -Teps foo.dot > foo.eps
04:07:38 <mmorrow> @type let indent=2; dQText = doubleQuotes . text; ppEdge (x,xs) = (dQText x) <+> (text "->") <+> (braces . hcat . punctuate semi . fmap dQText $ xs); ppGraph xs = (text "digraph g" <+> text "{")$+$ nest indent (vcat . fmap ppEdge $ xs)$+$ text "}" in ppGraph
04:07:40 <lambdabot>     Ambiguous occurrence `<+>'
04:07:40 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:4:0-19
04:07:40 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:54:0-46
04:07:55 <mmorrow> , [$ty| let indent=2; dQText = doubleQuotes . text; ppEdge (x,xs) = (dQText x) <+> (text "->") <+> (braces . hcat . punctuate semi . fmap dQText $ xs); ppGraph xs = (text "digraph g" <+> text "{")$+$ nest indent (vcat . fmap ppEdge $ xs)$+$ text "}" in ppGraph |]
04:07:58 <lunabot>  [] ((String, [] String)) -> Doc
04:08:58 <ray> anyone else think characters of code might be more appropriate for haskell than lines of code? :)
04:10:53 <mmorrow> heh, unsafeCoerce + vacuum is amusing
04:10:54 <quicksilver> tokens would probably be more interesting.
04:11:00 <mmorrow> ghci> (toAdjList . vacuum) (let x = (); y = (x,unsafeCoerce y); z = (y,y) in z)
04:11:00 <mmorrow> [(0,[1,1]),(1,[2,1]),(2,[])]
04:11:00 <ivanm> mmorrow: in what way?
04:11:07 <ray> tokens, yeah
04:11:19 <ray> that's best for measuring golf
04:12:27 <mmorrow> ghci> (toAdjList . vacuum) (let cons a b = (unsafeCoerce a, unsafeCoerce b); in foldr cons (unsafeCoerce ()) [0..4])
04:12:42 <mmorrow> a list! ;)
04:13:20 <ivanm> what's toAdjList?
04:13:55 <etpace> Is it possible to list all the items of a Tree using : instead of ++?
04:14:16 <tibbe> dcoutts: You had a suggestion to make foldl' stricter, what was the difference from:
04:14:19 <tibbe> @src foldl'
04:14:19 <lambdabot> foldl' f a []     = a
04:14:19 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
04:15:28 <mmorrow> this is what that last one produces (as you'd expect) http://moonpatio.com/vacuum/gallery/coerce.png
04:15:56 <mmorrow> etpace: Data.Tree.flatten if you're using Data.Tree
04:16:14 <mmorrow> etpace: oh, i might have misunderstood
04:16:25 <mmorrow> etpace: (what do you mean?)
04:16:31 <etpace> Is Data.Tree the typical Tree a = Branch a (Tree a) (Tree a) | Leaf a?
04:16:37 <mmorrow> , src ''Tree
04:16:40 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
04:16:45 <mmorrow> , src ''Forest
04:16:48 <lunabot>  type Forest a = [Tree a]
04:17:05 <mmorrow> so not binary, no
04:17:18 <etpace> Well, I can list all items with something like listTree (Leaf x) = [x], listTree (Branch x l r) = [x] ++ (listTree l) ++ (listTree r)
04:17:34 <etpace> but is it possible to build the list with : instead of ++? I can't think of how to do it
04:18:05 <mmorrow> listTree (B x l r) = x : concatMap listTree [l,r]
04:18:16 <mmorrow> but your's is essentially equiv to that
04:18:19 <mmorrow> *yours
04:18:56 <mmorrow> @src (++)
04:18:56 <lambdabot> []     ++ ys = ys
04:18:57 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:18:57 <lambdabot> -- OR
04:18:57 <lambdabot> xs ++ ys = foldr (:) ys xs
04:19:21 <etpace> oh cool, ++ is just :?
04:19:37 <etpace> I thought ++ was quite bad speed wise or something
04:20:04 <mmorrow> etpace: it's only bad if you add to the end of a list continually
04:20:16 <Twey> etpace: It's a foldr (:)
04:20:22 <mmorrow> (in that case you should be consing, then reverse)
04:20:29 <Twey> I.E. it's a (:) for each element of the first list
04:21:07 <Twey> Is there a way to make the automatic ‘derive Read’ Unicode-aware?  Some library?
04:21:44 <Twey> Oh, or possibly it's GHCi's fault, actually
04:21:49 <Twey> Hmn.
04:22:13 <matsuura> Hmm... I don't quite understand
04:22:53 <Twey> There seems to be a bug, #782
04:25:01 <ryo_hazuki> Parse error in pattern ---> jump xxs@(i,x):xs vs
04:25:05 <ryo_hazuki> where? =o
04:25:16 <Twey> ryo_hazuki: You need brackets around the ((i, x) : xs)
04:25:21 <ryo_hazuki> oh
04:25:40 <Twey> Constructor matching generally requires bracketing, although record syntax is an exception
04:25:53 <ryo_hazuki> that was it... thx =)
04:26:04 <Twey> Welcome :)
04:27:23 <blueonyx> jump xxs@((i,x):xs) vs, maybe?
04:27:32 <Twey> blueonyx: *nod*
04:27:38 <blueonyx> oh scrolling xD
04:27:44 <Twey> Hehe
04:30:17 <ryo_hazuki> why can't i use the variables in the tupel in this case:
04:30:23 <ryo_hazuki> jump xxs@((i, x) : xs) vs
04:30:28 <ryo_hazuki> | i == length xxs = True
04:30:35 <Twey> ryo_hazuki: You can
04:30:38 <Twey> That's fine
04:30:49 <ryo_hazuki> | x `elem` vs = jump xxs vs
04:31:01 <ryo_hazuki> | x == xs !! s = jump xxs (vs : x)
04:31:13 <ryo_hazuki> last row gives a type exception
04:31:21 <ryo_hazuki> expected Int - inferred (Int, Int)
04:31:44 <ryo_hazuki> s is simply the sum of i + x
04:31:57 <Twey> ryo_hazuki: Where's that defined?
04:32:06 <ryo_hazuki> | otherwise = False
04:32:09 <ryo_hazuki> where s = i + x
04:32:22 <Twey> Maybe you could pastebin it somewhere rather than pasting to the channel?
04:32:40 <Twey> You can keep formatting better that way, too :)
04:32:46 <ryo_hazuki> true ;)
04:33:19 <Twey> Ah
04:33:21 <Twey> I see the problem
04:33:39 <Twey> xs :: [(Int, Int)], so xs !! s :: (Int, Int)
04:33:45 <Twey> But s :: Int
04:33:58 <ryo_hazuki> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=7577
04:34:10 <Twey> So when you compare (s :: Int) == (xs !! s :: (Int, Int)), you get an error because the types don't match up.
04:34:37 <blueonyx> but he compares x to xs!!s :>
04:34:49 <Twey> Er, x sorry :-P
04:35:13 <ryo_hazuki> aaaaaaaaaahhhhhhhhhrrrrrrrr
04:35:18 <ryo_hazuki> =D
04:41:50 <smorg> Is there a way to have an editor whose text buffer is interpreted by ghci such that changes to a function will work in real time rather than having to save/load files?
04:41:58 <RayNbow> @hoogle ErrorT
04:41:59 <lambdabot> Control.Monad.Error newtype ErrorT e m a
04:41:59 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
04:41:59 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
04:43:58 <Twey> smorg: I think emacs' haskell-mode might do something similar
04:44:56 <smorg> ghci would need to be able to read from it directly somehow
04:44:59 <tibbe> @src unless
04:45:00 <lambdabot> unless p s = if p then return () else s
04:45:06 <tibbe> @src when
04:45:06 <lambdabot> when p s = if p then s else return ()
04:48:22 <mmorrow> smorg: how does the interp/editor know when to try to recompile/load ?
04:49:00 <smorg> do it whenever a function is called
04:49:02 <mmorrow> (le** Exception: parse errort x = 12 i***Exception: parse errorn (x,x***...)
04:49:09 <smorg> when you press enter ;)
04:49:12 <mmorrow> :)
04:51:22 <mmorrow> smorg: (i'm not sure if you mean as in reload the entire file/module or just update a function, but) in the second case ghci (as it is) won't do that since :reload'ing drops all currently (interactively) defined functions
04:53:11 <mmorrow> so (save doing a non-trivial amount of hacking), if you were to manage to hack something together, it'd still essentially be no different that having ghci automatically just do the ":r" for you
04:53:15 <smorg> reloading the entire file i suppose. The idea would be to have the source file itself be interactive, rather than interactively defining functions in ghci
04:53:43 <mmorrow> ah, so the only diff then is the fact that there's no intermediate file-on-disk?
04:53:52 <smorg> right, read from a buffer
04:53:58 <smorg> maybe a named pipe
04:54:52 <mmorrow> smorg: that should be doable for sure (although (aside from some sort of external hackery) it'd probably take playing with the ghci code)
04:56:18 <mmorrow> smorg: have you ever seen "vimdot"? if you have graphviz you already have it. it uses inotify and sets it to notify it when the currently-being-edited file in vim is written, at which point it updates the view of the graph
04:57:44 <mmorrow> (i tried to get it to read from a named pipe once (just was using shell script(s)) and it turned out to be a total pita, never ended up getting it working correctly :(
04:57:46 <smorg> hm interesting. I've got graphviz but haven't heard of vimdot
04:58:14 <mmorrow> smorg: neither had i, but at the time i was doin g something where i wanted a similar functionality and stumbled upon it
04:58:44 <smorg> I really need to bite the bullet and learn vim one of these days
04:59:15 <mmorrow> smorg: the nice thing about it is that "wimdot" is just a shell script that does:
04:59:19 <mmorrow> dot -Txlib $f &
04:59:20 <smorg> everyone says its totally worth it
04:59:22 <mmorrow> gvim $f &
04:59:26 <mmorrow> # end
04:59:43 <mmorrow> so it's really the xlib backend that does the work (via inotify)
04:59:48 <Twey> emacs' inferior modes do that for a variety of different interpreters
04:59:54 <mmorrow> so it's actually independent of vim
04:59:56 <smorg> It would make playing around with functions really fast
05:00:04 <Twey> I believe ghci is among them
05:00:44 <mmorrow> yeah, being that all you need to do is tell ghci to ":r", it should be pretty easy to get (the most basic form of) this idea
05:00:46 <smorg> hm theres a dev-haskell/hinotify
05:01:13 <mmorrow> smorg: yeah, there's (at least two) inotify packages on hackage
05:03:26 <mmorrow> what ghci really needs (which would be really nice in general) is the ability to control ghci itself from the code (ours) that it's interpreting
05:03:48 <mmorrow>  :t reload :: IO ()
05:03:49 <smorg> that would be interesting
05:04:18 <mmorrow> then you could just forkIO a thread that waits on inotify, and does `reload'
05:04:38 <mmorrow> (although i think it would get zapped upon reload (?))
05:04:47 <quicksilver> nope.
05:04:51 <quicksilver> ghci never zaps threads.
05:05:02 <quicksilver> ghci is really not very friendly for threaded development.
05:05:31 <mmorrow> heh, cool
05:05:33 <quicksilver> mmorrow: http://hackage.haskell.org/trac/ghc/ticket/1399
05:05:44 <mmorrow> you can forkIO a thread, and it'll survive across :l and :r
05:05:44 <smorg> for inotify it would still have to make changes to the disk though
05:06:29 <mmorrow> smorg: inotify can do more than just files, but i don't recall off hand exactly what it can listen too
05:07:06 <quicksilver> mmorrow: Nine Inch Nails, I think.
05:07:11 <mmorrow> quicksilver: heh, i guess that "bug" is useful in this case ;)
05:07:22 <quicksilver> mmorrow: well there's more than one way to fix a bug.
05:07:24 <mmorrow> quicksilver: heh
05:07:28 <quicksilver> mmorrow: ghci should have thread inspection commands
05:07:32 <mmorrow> quicksilver: true
05:07:35 <quicksilver> mmorrow: list of all threads, what they're doing, kill them one by one
05:07:38 <mmorrow> ah, yeah that'd be cool
05:07:41 <quicksilver> launch groups, kill groups
05:07:52 <mmorrow> threadocide
05:07:53 <quicksilver> run a command in a specific group + kill at the end.
05:07:54 <quicksilver> etc.
05:08:16 <mlesniak_> I have some big arrays (3 x 2500 x 2500) with Int's. Would it considerably change speed if I refactor the code to use Int32?
05:08:36 <quicksilver> I doubt it.
05:08:50 <quicksilver> if that requires considerable refactoring there is something suspicious about your dcode, though :)
05:08:56 <bd_> mlesniak_: on amd64, they're both a box around GHC.Prim.Int#
05:08:57 <quicksilver> that sounds like it should be something you coudl try out in 5 minutes.
05:09:06 <bd_> so I don't think there'll be any difference at all :)
05:09:10 <mlesniak_> quicksilver: well it's more a kind of "doing intelligent sed" ;)
05:09:14 <etpace> > let foo = bar:[] where bar = 1:2
05:09:15 <lambdabot>   not an expression: `let foo = bar:[] where bar = 1:2'
05:09:21 <quicksilver> and on ia32, they are of course the same.
05:09:24 <etpace> how would I do something like that?
05:09:39 <mlesniak_> bd_: quicksilver: Sounds reasonable, thanks :)
05:09:41 <quicksilver> etpace: exactly like that.
05:09:42 <bd_> > let bar = (1:).(2:) in foo = bar []
05:09:44 <lambdabot>   <no location info>: parse error on input `='
05:09:45 <Zao> @t (:)
05:09:45 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:09:50 <Zao> @type (:)
05:09:51 <lambdabot> forall a. a -> [a] -> [a]
05:09:52 <quicksilver> > let foo = bar:[] where bar = 1:2 in foo
05:09:53 <bd_> > let bar = (1:).(2:) in bar []
05:09:53 <lambdabot>   No instance for (GHC.Num.Num [t])
05:09:53 <lambdabot>    arising from the literal `2' at <inter...
05:09:54 <lambdabot>   [1,2]
05:10:05 <quicksilver> > let foo = bar:[] where bar = 1:2:[] in foo
05:10:07 <lambdabot>   [[1,2]]
05:11:49 <etpace> Is there an id element or something for :? so that 1:id:2:[] = [1,2]
05:12:25 <quicksilver> etpace: there can't be, no.
05:12:29 <mmorrow> , concat ([1]:[]:[2]:[])
05:12:30 <lunabot>  [1,2]
05:12:51 <etpace> @src concat
05:12:51 <lambdabot> concat = foldr (++) []
05:13:06 <mmorrow> @src (++)
05:13:06 <lambdabot> []     ++ ys = ys
05:13:06 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:13:06 <lambdabot> -- OR
05:13:06 <lambdabot> xs ++ ys = foldr (:) ys xs
05:13:11 <mmorrow> @src reverse
05:13:11 <lambdabot> reverse = foldl (flip (:)) []
05:13:35 <mmorrow> @src sum
05:13:35 <lambdabot> sum = foldl (+) 0
05:13:39 <mmorrow> @src product
05:13:40 <lambdabot> product = foldl (*) 1
05:13:45 <mmorrow> @src and
05:13:46 <lambdabot> and   =  foldr (&&) True
05:13:48 <mmorrow> @src or
05:13:48 <lambdabot> or    =  foldr (||) False
05:14:23 <etpace> I'm looking through some questions and it says to write the function elemsi that takes a tree and a list, and returns a list of all items in the tree, with the second list appended -- without requiring appending of lists. but as I can see, appending of lists can be defined in terms of :, so im quite confused
05:15:39 <quicksilver> mmorrow: that was a bit spammy :P
05:17:09 <etpace> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7579#a7579 what's wrong with this? i'm supposedly having an infinite type
05:17:22 <stevan> hi, i ran into the same problem with the platform (cabal-install) as described here: http://www.nabble.com/cabal:-:-openFile:-does-not-exist-(No-such-file-or-directory)-td24521829.html  when i add the -v3 flag i get a segfault... any ideas? thanks.
05:17:48 <quicksilver> etpace: you don't understand what : does.
05:18:04 <quicksilver> etpace: "x:(elems'H l):(elems'H r)" makes no sense.
05:18:33 <ray> you can't : two lists together
05:18:34 <quicksilver> etpace: : appends a single item (on the left) to a list (on the right) making a list.
05:18:38 <etpace> well it would ideally return something like 1:2:5:9, and then return to elems' and be 1:2:5:9:[]
05:18:49 <quicksilver> etpace: no no no no no :)
05:18:57 <gwern> is haskell.org down?
05:19:03 <ray> haskell.org is slow
05:19:04 <quicksilver> etpace: "1:2:5:9" is not a subexpression of "1:2:5:9:[]"
05:19:05 <ray> but up
05:19:18 <quicksilver> etpace: in fact, "1:2:5:9" is not a valid expression at all.
05:19:26 <ray> it1:(2:(5:(9:[])))
05:19:29 <ray> gah
05:19:32 <ray> it's 1:(2:(5:(9:[])))
05:19:56 <etpace> hmm, I think erlang poluted me a bit there
05:19:57 <ray> you have to start with [] and add things to the left
05:20:10 <quicksilver> etpace: this is why people use [1,2,5,9] syntax
05:20:25 <quicksilver> it's more comfortable to most people than "1:2:5:9:[]"
05:20:37 <ray> if you had come from lisp, you would be polluted in other ways, but you would get lists :)
05:20:48 <quicksilver> I strongly suspect that what you wanted for that last case is
05:21:01 <quicksilver> x : (elems'H l ++ elems'H r)
05:21:09 <quicksilver> ++ appends two lists together
05:21:20 <quicksilver> : prepends a single item (not a list) to a list.
05:21:29 <etpace> yeah, the problem is the question asks to not "require appending of lists", which as youve shown is just defined as :
05:21:34 <etpace> so it's quite ambiguous
05:22:04 <quicksilver> well I can't comment on the question without seeing it in context.
05:22:18 <quicksilver> It may be it's an exercise about avoiding excessive use of ++.
05:22:39 <quicksilver> but I think you need to get more familiar with the syntax of lists in the first place before you worry about excessive use of anything.
05:22:48 <Axman6> etpace: i'd call that prepending personally
05:23:21 <ray> @unpl ap pending
05:23:21 <lambdabot> (\ e -> pending >>= \ b -> e >>= \ a -> return (b a))
05:23:34 <quicksilver> etpace: yes, normally "++" is the one people call append.
05:23:44 <Axman6> ray: what the..
05:23:58 <ray> :)
05:25:25 <Philippa> Axman6: half of us still call it cons :-)
05:25:44 <Axman6> i would too, half the time
05:29:27 <LeCamarade> Wow. HaXml takes forever to link, and locks up me system. I should try using gold to link. Heard it was faster. Much faster.
05:29:59 <ray> i've been having that problem with any decently large haskell package
05:30:07 <ray> but only on my remote vps
05:31:35 <LeCamarade> Problem of ld, really. gold was the answer, but I failed to compile it recently.
05:33:38 <mmorrow> quicksilver: if only we had @src ((++),reverse,sum,product) ;)
05:33:45 <gwern> does gold work with ghc? I've never heard of anyone using it
05:34:38 <mmorrow> i've heard that gold is hugely faster, but haven't used it
05:37:23 <mmorrow> LeCamarade: although once ghc gets dynamic libs link time will plunge
05:37:56 * mmorrow was trying to think of the opposite of "skyrocket" and couldn't think of anything satisfactory
05:38:56 <Axman6> antisplode
05:39:30 <quicksilver> mmorrow: if only we didn't have @src at all :P
05:39:30 <Ke> implode?
05:39:40 <quicksilver> "groundhog"
05:40:25 <Plouj> morning
05:40:52 <Plouj> does anyone know of programming jobs that don't require any specific language knowledge but rather just expect you to be able to solve problems whatever language you know?
05:41:41 <Daimonic> @src sum
05:41:41 <lambdabot> sum = foldl (+) 0
05:41:57 <Plouj> I haven't found any Haskell jobs in Canada using job search sites (like indeed.com, monster.ca, workopolis.ca) so I want to try to modify my search somehow
05:42:01 <mmorrow> hah, antisplode
05:42:49 <mmorrow> quicksilver: does that make you a closed @src advocate?
05:43:39 <yottis> i thought there were like 10 haskell jobs in the world, all in the "let's replace excel sheets with something else" industry
05:44:02 <Axman6> you thought wrong
05:44:20 <Axman6> see Galois for one excellent example
05:46:27 <kalven> there are at least 20
05:52:07 <Ke> Plouj: you could study erlang from haskell
05:52:39 <Daimonic> @src length
05:52:40 <lambdabot> Source not found. It can only be attributed to human error.
05:52:57 <Plouj> Ke: I already know Erlang :)
05:53:21 <Daimonic> @src map
05:53:21 <lambdabot> map _ []     = []
05:53:22 <lambdabot> map f (x:xs) = f x : map f xs
06:14:30 <athos> @remember < yottis> i thought there were like 10 haskell jobs in the world, all in the "let's replace excel sheets with something else" industry < kalven> there are at least 20
06:14:30 <lambdabot> Done.
06:17:08 <dufflebunk> Plouj: if you find any good companies like that in Canada let me know. I'm stuck in the US until Canadian companies actually start doing interesting stuff.
06:17:58 <kpreid> athos: @remember's first arg is a nick, you've just recorded a quote said by "<"
06:18:04 <liyang> So, I'd like to draw a live plot of some incoming data. Is anyone aware of a Gtk(2Hs)+ widget that would do that for me?
06:18:21 <kpreid> I would suggest @remember kalven <yottis> ...
06:22:38 <mmorrow> omg, i just discovered +RTS -B -RTS
06:22:47 <mmorrow> "Sound the bell at the start of each (major) garbage collection."
06:23:06 * kpreid finds that amusing for some reason
06:23:28 <kpreid> (also: sounds like something from the days of Lisp Machines...)
06:23:58 <mmorrow> me too, for the same reason i like the five realtime scrolling graphs of cpu/mem/network/swap/load/disk on my gnome-panel
06:24:16 <mmorrow> (although -B doesn't exactly fade into the background ..)
06:25:08 * mmorrow is currently running program after program with -B to see how they sound
06:25:38 <mmorrow> heh, just realized you (of course) can run ghc and ghci with -B
06:25:58 <Raevel> try to make a song out of it
06:28:48 <mmorrow> with threadDelay and rnf
06:32:28 <mmorrow> -B is actually really amusing in ghci
06:32:34 <mmorrow> s/amusing/interesting/
06:39:34 <dufflebunk> ghc is telling me: WARNING in hptSomeThingsBelowUs, missing module <some module I've removed>, Probable cause: out-of-date interface files
06:39:43 <dufflebunk> What is this interface file?
06:39:57 <sean_> I believe that's the .hi file
06:40:48 <mmorrow> quicksilver: i just noticed a "-fno-state-hack" flag, iirc you were doing something re: OpenGL where this somehow was an issue?
06:41:07 <mmorrow> (i remember that instance because that was the first i'd heard of the state hack)
06:41:21 <dufflebunk> sean_: must have been. I deleted them all and recompiled and the warning went away
06:43:34 <sean_> dufflebunk: yep, I think that warning means that an imported module was present when the .hi was generated, but is no longer around.
06:45:37 <quicksilver> mmorrow: http://hackage.haskell.org/trac/ghc/ticket/2284
06:46:16 <mmorrow> quicksilver: ah nice, i hadn't seen that one though
06:48:41 <mmorrow> quicksilver: oh, so i get the sense from that ticket that it's felt there /is/ a "fix"? (i was under the impression that this was an either/or kind of thing)
06:48:48 <sioraiocht> dons: ping?
06:49:07 <mmorrow> (i though -fno-state-hack _was_ the fix..)
06:50:02 <quicksilver> mmorrow: there isn't an easy fix, or it would have been done.
06:50:07 <sean_> Has anyone ever seen the threaded runtime of ghc spawn more processes than you ask for with -N?
06:50:20 <quicksilver> mmorrow: it's an optimiser hack, which is "wrong" but was implemented because it improves an important special case.
06:50:33 <mmorrow> quicksilver: but it's not some fundamental/inherent roadblock that prevents a solution though (?)
06:50:33 <quicksilver> mmorrow: however it also pessimises another special case, which seems important to me ;)
06:50:41 <mmorrow> yeah
06:50:50 <quicksilver> mmorrow: the real solution would be to find a non-hacky way to optimise the first case :)
06:50:50 <mmorrow> hmm
06:51:48 <mmorrow> quicksilver: remind me what the first case is again :)
06:52:32 <quicksilver> I dunno
06:52:58 <quicksilver> something to do with the way GHC compiles IO to lambdas I think
06:53:07 <mmorrow> ah found an explanation
06:53:13 <mmorrow> http://hackage.haskell.org/trac/ghc/ticket/1168
06:54:15 <dufflebunk> sean_: yeah. Strangely, it doesn't regenerate the ho file when the imports change
06:54:30 <dufflebunk> hi, not ho
06:56:14 <mmorrow> quicksilver: couldn't you just add another level of indirection to the pure value by putting it in an IORef/equivalent and solve the problem?
06:56:43 <mmorrow> (or do the equivalent at the rts/lower-than-haskell level)
06:56:48 <quicksilver> I don't know, I didn't try it.
06:56:52 <quicksilver> interesting though though
06:57:16 <mmorrow> and you're in IO anyways too
06:57:34 <DrSyzygy> No Kmett here? Any category wizards awake?
06:57:40 * DrSyzygy wonders whether Hask is a topos.
07:03:41 <FunctorSalad_> DrSyzygy: I'm no wizard, but interesting question
07:04:52 <FunctorSalad_> DrSyzygy: IIRC there are some issues with seq that prevent it from even being a category though
07:05:06 <FunctorSalad_> ( Cale ?)
07:05:23 <DrSyzygy> I'll be happy restricting it throwing out smallish bits and pieces until it does become a category.
07:06:02 <DrSyzygy> What I'm wondering is that if Hask \ {seq} or whatever you need to pick to make it a category is a topos, and see issues with, mainly, the finite limits and the subobject classifier.
07:06:18 <DrSyzygy> Does Hask, for instance, have pullbacks?
07:06:54 <FunctorSalad_> naively these would seem to require dependent types
07:10:14 <dikini> I know I asked this before, but is this (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7584) reasoning sound, and if yes is there a way to make it typecheck, if no, where do I go wrong with it
07:11:14 <mmorrow> quicksilver: wow, that prog in the ticket gets crushed without -fno-state-hack
07:11:33 <dikini> my current guess is that the categorical functor is just larger than the haskell definition, but I might be wrong
07:11:39 <Saizan_> dikini: it's not correct reasoning because 'x' won't be of type F b
07:12:15 <dikini> Saizan_: can't a == b be accepted?
07:12:34 <Saizan_> dikini: even in CT a functor F :: C -> D is supposed to transform any morphism A -> B in C to a morphism F A -> F B in D
07:12:47 <Saizan_> dikini: you're not given the choice
07:13:36 <Saizan_> dikini: something similar that does work almost like yours is data Const a = Const, then "fmap _ Const = Const" typechecks
07:14:11 <Saizan_> dikini: however the problem is that fmap is supposed to work for any objects A and B in the source category
07:14:36 <Saizan_> dikini: and for the class Functor the source category is Hask
07:14:37 <DrSyzygy> To illustrate Saizan_'s point, what do you expect > fmap ord < to do?
07:14:49 <DrSyzygy> :t ord
07:14:52 <lambdabot> Char -> Int
07:15:22 <Saizan_> dikini: i guess your F is a functor for a restricted category where there's only one object
07:15:41 <dikini> Saizan_:  ok, i'm not that versed in CT, but Const does sound right, since it is what I want to express, without raising errors and such
07:15:53 <dikini> Saizan_: yes
07:16:30 <doserj> DrSyzygy: pull-backs can model intersection, right? haskell has no intersection types.
07:16:33 <dikini> or rather a family of those
07:16:47 <dikini> sorry, got to go for a while, brb
07:16:56 <quicksilver> doserj: intersection under predicate, even.
07:16:58 <DrSyzygy> doserj: Right! That would clinch it. Thank you!
07:17:11 <quicksilver> doserj: (which is presumeably what FunctorSalad_ meant about dependent types)
07:18:26 <sean_> is this the right place to ask about ghc's threaded runtime?  #ghc seems like it doesn't want me asking questions :)
07:19:46 <FunctorSalad_> Saizan_: I think he wants the identity on objects, not const
07:19:46 <Saizan_> try asking :)
07:20:09 <Saizan_> FunctorSalad_: F a b = a ?
07:20:28 <FunctorSalad_> F a = F a
07:20:42 <FunctorSalad_> actually I wonder why the linked code doesn't typecheck
07:20:49 <nominolo> sean_: depends on the question
07:20:52 <sean_> I'm under the impression that -N controls how many threads the runtime will use
07:21:14 <sean_> however, -N2 seems to sometimes result in 4 processes
07:21:16 <nominolo> correct, if the program was compiled with -threaded
07:21:16 <Saizan_> FunctorSalad_: see the definition of fmap
07:21:19 <sioraiocht> is there anyway to get the name of a function as a string in haskell?
07:21:24 <FunctorSalad_> oh, nvm, I see the problem now. the a/=b case
07:21:27 <nominolo> sean_: processes?
07:21:40 <nominolo> you'll still have only one process
07:22:21 <sean_> nominolo: Well, I mean LWPs under linux
07:22:37 <FunctorSalad_> DrSyzygy: this raises the alternative question whether dependent theories such as coq's are toposes
07:23:05 <Philippa> what's the minimal sensible logic that's a topos?
07:23:07 <quicksilver> sean_: one for the IO manager, one for the GC, or something? I'm not sure.
07:23:09 <nominolo> sean_: I think some IO operations need a special OS-thread
07:23:42 <Axman6> sean_: i think there's N threads and N garbage collection threads, but i'm probably wrong
07:24:17 <FunctorSalad_> "pullback `(f1:A1 -> B) `(f2:A2 -> B) := { p in A1*A2 | f1 (fst p) = f2 (snd p) }" <---- this certainly *looks* like a pullback, but who knows if it actually is one ;)
07:24:46 <FunctorSalad_> *"p : A1*A2", not "p in A1*A2"
07:25:04 <dufflebunk> Is anyone able to fix the hackage version of hsc2hs? I think all it needs is some minor tweaking to do with System.Process being part of the bassse libraries now.
07:25:36 <nominolo> dufflebunk: doesn't the platform come with hsc2hs?
07:25:48 <sean_> Axman6: I read something about that in the docs.  I'm recompiling with -threaded (again) and going to see what happens with -N1
07:26:03 <quicksilver> sean_: why does it matter to you?
07:26:29 <dufflebunk> nominolo: hmmm, it might
07:27:20 <sean_> quicksilver: well, I'm writing a high performance service, and I want exactly as many running threads as cores if I can manage that
07:28:39 <quicksilver> sean_: I think you're worrying too much.
07:28:44 <dufflebunk> nominolo: You're right, it comes with hsc2hs. So why is it complaining when I try to configure my cabal thing that I need hsc2hs -any?
07:28:48 <nominolo> sean_: well, then measure first
07:28:50 <quicksilver> sean_: if you have 4 cores, then you should use probably -N4
07:29:02 <quicksilver> sean_: the extra threads are for housekeeping and you probably shouldn't worry about them.
07:29:13 <quicksilver> although some people show better times with -N5 or -N6 on four cores
07:29:16 <sioraiocht> I'm looking to do some primitive parsing of haskell code to extract certain information, is there a library in haskell for parsing haskell?
07:29:16 <quicksilver> it varies by workload.
07:29:23 <sean_> that makes sense
07:29:37 <Axman6> sean_: in general, i think from benchmarks, it's often to use N-1 threads for N cores
07:29:39 <dufflebunk> probably because I put that in my cabal file. duh
07:29:43 <nominolo> dufflebunk: is your path set up correctly?
07:29:46 <hackagebot> rwlock 0.0.0.1 - Multiple-read / single-write locks (JamesCook)
07:29:54 <sean_> OK, so the theory about GC threads is correct I believe; I observe n threads until the first GC, then 2n threads
07:29:57 <Axman6> there can be a very significant decrease with N/N threads/cores
07:30:00 <nominolo> sioraiocht: hasell-src-exts
07:30:05 <sioraiocht> nominolo: thanks
07:30:11 <dufflebunk> nominolo: just user error
07:30:11 <nominolo> haskell* that is
07:30:40 <sean_> so that leads me to my followup question: when my process is blocked on I/O, what could possibly be causing it to use 50% of one core?
07:31:02 <nominolo> sioraiocht: if you want type checking though, you'll probably have to go through the ghc api
07:31:05 <Saizan_> dufflebunk: for build tools there's the build-tools: field
07:31:07 <Axman6> the whole process might not be blocked...
07:31:26 <sioraiocht> nominolo: no, all I really want are function names and arity according type signatures
07:31:46 <hackagebot> dbf 0.0.0.1 - Read and write XBase ".dbf" files (JamesCook)
07:32:07 <nominolo> then src-exts should be fine.  It's currently being improved as part of Google's Summer of Code
07:32:45 <sioraiocht> nominolo: nice, thanks
07:32:46 <nominolo> dufflebunk: I'll need a few more details
07:32:55 <Phyx-> what exactly's being changed on src-exts?
07:32:55 <ivanm> nominolo: does hsx always return parity types? even for functions without explicit type sigs?
07:33:12 <ivanm> Phyx-: atm, IIRC it's comment support
07:33:22 <Axman6> sean_: i'm sure the guys in #ghc would be more than happy to help answer your problems too
07:33:26 <ivanm> though he's mentioned cpphs support as well
07:33:28 <sean_> Axman6: well, there appears to be only one I/O thread, unless happstack (the service is JSON-RPC) is making one behind my back, which would be impressive without calling forkIO
07:33:35 <Phyx-> ah ok, comments would be much appreciated indeed
07:34:54 <nominolo> ivanm: sorry haven't used it myself.  Neil's hlint is using it though.  I suspect it's difficult to get the correct arity of a function without knowing its type, though.
07:35:00 <nominolo> due to currying
07:35:16 <sean_> Axman6: ok, thanks :)
07:37:07 <Phyx-> on the haskell trac, in the cc field, is "," or ";" the delimiter?
07:37:59 <nominolo> Phyx-: ","
07:38:02 <dufflebunk> Saizan_: thanks
07:38:32 <Phyx-> nominolo: thanks
07:38:35 <dufflebunk> nominolo: I had hsc2hs listed in the build-depends field, it shouldn't have been.
07:39:13 <quicksilver> nominolo: I was faintly expecting it to be `mappend`
07:39:55 <dikini> Saizan_:  thanks, I think data Const a b = Const a    does exactly what I want
07:40:01 <nominolo> quicksilver: you mean (<>) surely!
07:40:17 <dikini> Saizan_:  now I need to digest it =)
07:42:21 <ivanm> 1.1 has partial support for comments
07:42:23 <quicksilver> dikini: it's exactly the advice we gave you last week and you didn't want to follow it :P
07:42:30 <quicksilver> dikini: (in the context of a larger data type)
07:43:03 <ivanm> nominolo: yeah, that's what I was thinking
07:43:05 <mmorrow> quicksilver: it goes from slow to broken if you try to pull a fast one with an IORef
07:43:06 <dikini> quicksilver: yes, I think, but my brains a bit slow lately
07:43:54 <quicksilver> mmorrow: ok that's very odd.
07:44:32 <dikini> quicksilver: it is a bit of a workout, and I might have jumped in a deep end
07:44:33 <Daimonic> @src foldr
07:44:34 <lambdabot> foldr f z []     = z
07:44:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:44:44 <Daimonic> @src foldl
07:44:45 <lambdabot> foldl f z []     = z
07:44:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:45:15 <dikini> for me that is
07:46:28 <quicksilver> dikini: best way to learn
07:46:29 <quicksilver> maybe :)
07:46:49 <dikini> quicksilver: I'll kiss and tell
07:46:53 <dikini> later :)
07:47:51 <athos> > foldr f z [a,b,c]
07:47:53 <lambdabot>   f a (f b (f c z))
07:47:54 <athos> > foldl f z [a,b,c]
07:47:56 <lambdabot>   f (f (f z a) b) c
07:48:04 <athos> oh, daimonic just left
07:48:29 <DrSyzygy> > foldr f q [a..z]
07:48:31 <lambdabot>   * Exception: not a number
07:48:37 * DrSyzygy tsks.
07:48:41 <dikini> quicksilver: I'm playing around with expressing a particlular optimisation algorithm in a number of ways, and it seems as a good excuse to learn
07:49:23 <quicksilver> nothing like having goals to help  you learn, I reckon.
07:49:25 <dikini> quicksilver: it doesn't help (or maybe actually it does) that the description is a fluffball
07:49:32 <quicksilver> > 1 + "asd"
07:49:33 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
07:49:33 <lambdabot>    arising from the literal ...
07:49:47 <quicksilver> I wonder what that odd 'not a number' exception was.
07:49:54 <quicksilver> > [a..z]
07:49:55 <lambdabot>   * Exception: not a number
07:49:58 <quicksilver> ah.
07:49:59 <sean_> Axman6 (and other interested parties): the problem was that HDBC makes finalizers in its finalizers, which makes the idle GC timer stay active.  Idle GC can be disabled with -I0
07:50:03 <EvilTerran> quicksilver, I blame simple-reflect
07:50:03 <mmorrow> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7588
07:50:10 <quicksilver> sean_: hmm amusing.
07:50:45 <quicksilver> yo dawg I heard you like undefined behaviour, so I put a finalizer in your finalizer so you can ....
07:50:50 <hackagebot> dbf 0.0.0.2 - Read and write XBase ".dbf" files (JamesCook)
07:50:57 <athos> > ['a'..'z']
07:50:59 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
07:51:05 <sean_> :)
07:51:24 <mmorrow> quicksilver: with the IORef, nothing ever even is drawn in the first place
07:52:26 <quicksilver> mmorrow: I cant explain that.
07:53:12 <mmorrow> quicksilver: neither can i (although my best guess is that the "newIORef" gets inlined, so there are more than 1 of them)
07:53:41 <mmorrow> i don't even know it that can happen, but i don't know what else could be happening
07:54:58 <mmorrow> quicksilver: oh, oops i forgot a line in that diff (doesn't change the situation)
07:55:00 <mmorrow>       fs <- getFaces
07:55:00 <mmorrow>       forM_ fs $ \f ->
07:55:17 <mmorrow> (so yes, i do in fact read from the ref in the callback..)
07:56:53 <mmorrow> (the full diff http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7588#a7590)
07:57:14 <quicksilver> mmorrow: this seems such a broken program transformation I'm at a loss to explain why it doesn't bite people more often...
07:57:20 <quicksilver> mmorrow: it always seems to bite me.
07:58:43 <mmorrow> yeah that surprises me too
07:59:20 <mmorrow> and also surprises me that this hasn't bitten me before
07:59:51 <mmorrow> i guess i never pass expensive pure things into IO callbacks which get run repeatable
08:00:09 <mmorrow> *repeatedly
08:05:08 <rfmge> i have a question about lazy evaluation or maybe ghc's optimizer or rts, i'm not quite sure what this falls under
08:05:18 <rfmge> i need to be able to find the center of a rectangle quickly
08:05:22 <rfmge> the code is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7586
08:05:39 <rfmge> originally i had center, but center' gives the same answer using less operations
08:05:57 <rfmge> but when i ran it, center' was slower than center
08:06:43 <rfmge> i need maxLength whenever i need the center, so am i right to assume that ghc was evaluating hx - lx and hy - ly just once for both center and maxLength?
08:07:25 <rfmge> sorry if i'm not being clear
08:07:27 <quicksilver> no
08:07:38 <EvilTerran> rfmge, that seems unlikely; ghc doesn't generally do common subexpression elimination, as it can lead to space leaks when using lazy evaluation
08:07:45 <quicksilver> GHC does very little CSE.
08:08:16 <rfmge> okay
08:08:30 <quicksilver> is the speed difference really significant? I'd be surprised.
08:08:55 <rfmge> not too significant
08:09:19 <rfmge> but using center was consistantly ~0.5 seconds faster than center'
08:09:31 <rfmge> was just wondering why
08:10:13 <EnglishGent> EvilTerran - why can it? (lead to space leaks)
08:10:25 * EnglishGent was unaware of that & would like to understand it better :)
08:11:02 <EvilTerran> EnglishGent, compare "sum [1..10^10] / genericLength [1..10^10]" vs "let xs = [1..10^10] in sum xs / genericLength xs]
08:11:29 <EvilTerran> EnglishGent, in the first case, each list can be garbage-collected as sum or genericLength moves along it
08:12:04 <EvilTerran> in the second case, though, the list will be forced entirely during the evaluation of "sum xs", but the reference to the head of the list in "genericLength xs" stops any of it being GCd
08:12:11 <EvilTerran> so the entire list ends up being in memory at once
08:12:28 <EvilTerran> they're not space leaks like C's space leaks, but they're still unexpectedly large chunks of memory going AWOL
08:12:30 <athos> @type genericLength
08:12:32 <lambdabot> forall b i. (Num i) => [b] -> i
08:12:35 <EnglishGent> thanks :)
08:13:05 <EnglishGent> yeah ... I know GC doesnt automatically mean no space-leaks - I just couldnt see off hand why common subexpression elimination could introduce problems
08:13:12 <EnglishGent> I do now :)
08:13:20 * EnglishGent still something of a Haskell newbie :)
08:13:31 <athos> > genericLength [1..100] :: Ratio Int
08:13:33 <lambdabot>   100 % 1
08:13:57 <EvilTerran> ?type (%)
08:13:58 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
08:14:04 <EnglishGent> I was a bit surprised when I saw you mention it as it's a common compile optimisation
08:14:05 <EvilTerran> ?type (:+)
08:14:06 <EnglishGent> :)
08:14:06 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
08:14:17 <conal> @seen povman
08:14:18 <lambdabot> I haven't seen povman.
08:14:40 <athos> > genericLength [1..100] :: Complex Float
08:14:41 <lambdabot>   100.0 :+ 0.0
08:15:32 <Cale> DrSyzygy: Hask is not a topos, in particular, it doesn't have equalisers.
08:15:38 <EvilTerran> > genericLength [0 .. sqrt (-1) :: Complex Float]
08:15:40 <lambdabot>   No instance for (GHC.Enum.Enum
08:15:40 <lambdabot>                     (Data.Complex.Complex GH...
08:15:42 <EvilTerran> aw :P
08:16:08 <Deewiant> > genericLength [0 .. sqrt 2] :: Double
08:16:10 <lambdabot>   2.0
08:19:01 <doserj> > genericLength [0 .. exp 1] :: Double -- :(
08:19:03 <lambdabot>   4.0
08:21:12 <Phyx-> @src join
08:21:12 <lambdabot> join x =  x >>= id
08:21:42 <Phyx-> @quickcheck \x -> join (+) x = ap (+) id x
08:21:42 <lambdabot> Unknown command, try @list
08:21:48 <Phyx-> @list
08:21:48 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:22:15 <Phyx-> @check \x -> join (+) x = ap (+) id x
08:22:15 <lambdabot>   Parse error at "=" (column 18)
08:22:20 <Phyx-> @check \x -> join (+) x == ap (+) id x
08:22:22 <lambdabot>   "OK, passed 500 tests."
08:22:36 <Phyx-> @src ap
08:22:36 <lambdabot> ap = liftM2 id
08:23:05 * doserj always cringes when he sees that definition
08:24:45 <EnglishGent> which definition doserj? any why cringe? :)
08:25:18 <doserj> ap = liftM2 ($) is much clearer IMHO
08:25:26 <quicksilver> definitely.
08:27:06 <impl> @src id
08:27:06 <lambdabot> id x = x
08:27:34 <impl> @src ($)
08:27:35 <lambdabot> f $ x = f x
08:28:04 <rocketman> ($) f x = f x
08:28:07 <rocketman> ($) f = f
08:28:08 <Vanadium> @check \a b -> ($) a b == id a b
08:28:09 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
08:28:09 <lambdabot>    arising from a use of `...
08:30:22 <impl> @type ap
08:30:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:05:07 <conal> does anyone have lhs2tex working on mac os x?  mine dies in configuration, though works fine on linux.
09:06:32 <copumpkin> wow, the most recent haskell-cafe post is rather inflammatory
09:06:40 <conal> kosmikus: ping
09:08:23 <Saizan_> copumpkin: Johannes Waldmann?
09:08:28 <copumpkin> yup
09:08:48 <rocketman> @go Johannes Waldmann
09:08:49 <lambdabot> http://www.imn.htwk-leipzig.de/~waldmann/
09:08:49 <lambdabot> Title: Dr. Johannes Waldmann
09:09:08 <quicksilver> I think his arguments should be taken as arguments against the proposal ;)
09:09:10 <quicksilver> avoid success, remember?
09:09:19 <quicksilver> but the proposal reads like a very off-the-cuff SPJ idea
09:09:29 <quicksilver> someone would need to implement it to decide how painful it was.
09:09:35 <Cale> what is the proposal? (I haven't gone to look at the post yet)
09:09:42 <copumpkin> oh I wasn't talking specifically about the idea
09:09:57 <quicksilver> having a special syntax for application which permits ambiguity in scope
09:09:59 <copumpkin> just his wording that the proposal might make haskell into a "somewhat usable" language
09:10:09 <Cale> hmm
09:10:12 <quicksilver> and uses type inference to pick which of the ambiguous choices to use.
09:10:15 <zmyrgel> hmm, I just tried to build latest ghc from darcs but 'make' step fails to find iconv
09:10:27 <quicksilver> basically, another kind of ad-hoc overloading ;)
09:10:44 <zmyrgel> iconv is /usr/local/bin so I'd quess it should be able to find it
09:10:46 <copumpkin> it's a bit like c++'s overloading
09:11:02 <RayNbow> Cale: http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
09:11:07 <Cale> That sounds like the idea from the other day. Does it amount to selecting which module to pick things from if there is an unambiguous choice among the imported modules to qualify it with?
09:11:29 <copumpkin> well he goes and talks about adding dots as syntax
09:11:31 <copumpkin> which I don't like
09:11:37 <quicksilver> based on the type (only) of the argument.
09:11:44 <Cale> boo, we don't need to overload . any furhter
09:11:48 <Cale> further*
09:11:48 <quicksilver> if I read it right.
09:12:10 <copumpkin> but my issue was with the -cafe post :) I wasn't commenting on the haskell' proposal
09:12:47 <quicksilver> yes, it was a kind of gentle troll
09:13:00 <Saizan_> yeah, why do the type-directed name resolution only on this new "syntactic" form? just do it for everything where it's possible
09:13:32 <quicksilver> because it breaks type inference, if you do it in general, I think.
09:15:49 <Saizan_> well type-inference already breaks with "ambiguous reference" when there's such an ambiguity
09:15:50 <RayNbow> <Cale> boo, we don't need to overload . any furhter <-- why not? It would be nice if we could also abuse it for mappend :p
09:16:01 <francescobianco> haskell
09:16:04 <francescobianco> http://www.openplanning.net/products/biiiio/
09:16:33 <francescobianco> pls. anyone can post a simple message i need to test this form
09:16:37 <francescobianco> http://www.openplanning.net/products/biiiio/
09:16:41 <rocketman> no
09:16:49 <francescobianco> pls. a need only few second
09:16:52 <rocketman> no
09:16:58 <francescobianco> why no
09:17:03 <bremner> francescobianco: test it yourself?
09:17:11 <glguy_> francescobianco: This channel is about Haskell programming
09:17:19 <glguy_> Did you have a Haskell question?
09:17:20 <francescobianco> ho ho
09:17:25 <rocketman> francescobianco: I just like saying no
09:17:48 <francescobianco> what is the main feature of haskell
09:17:50 <francescobianco> ?
09:18:05 <mmorrow> testing forms
09:18:13 <bremner> lack of popularity
09:18:15 <RayNbow> rocketman: you should add a period after 'no', so it looks like Prolog :p
09:18:20 <rocketman> no.
09:18:23 <glguy> lazy, pure, functional programming
09:18:24 <glguy> pick 3
09:18:42 <rocketman> I like the types
09:18:48 <glguy> (and we'll throw in a free advanced type system)
09:18:51 <rocketman> yay
09:18:52 <copumpkin> te faccio nero
09:19:05 <francescobianco> ti spaccu u culu
09:19:52 <francescobianco> haskell is web oriented or have a mission in other side
09:19:54 <francescobianco> ?
09:20:03 <copumpkin> it's a general purpose programming language
09:20:16 <copumpkin> that is purely functional and has a mad cool type system ;)
09:20:57 <francescobianco> ho ho
09:21:02 <francescobianco> great
09:21:32 <francescobianco> what think about the HASKELL vs. ML
09:22:15 <rocketman> francescobianco: That sounds like a great idea
09:23:27 <hackagebot> shapefile 0.0.0.1 - Parser and related tools for ESRI shapefile format (JamesCook)
09:23:34 <jnwhiteh> that was one of the most bizarre conversations I've ever witnessed on IRC
09:23:36 <jnwhiteh> and that's saying a lot.
09:23:43 <copumpkin> lol
09:24:08 <jnwhiteh> and I only caught the last few minutes
09:24:33 <Saizan> it didn't go on for long
09:31:21 <pikhq> Mmm, pure functions.
09:33:53 <conal> Beelsebob: ping
09:34:27 <conal> Mmm, precise & simple denotations.
09:37:00 <Beelsebob> pong
09:37:20 <quicksilver> Mmm, doughnuts
09:37:30 <conal> Beelsebob: do you use lhs2tex?  i can't get it to build on os x, though the same version builds on linux
09:37:50 <Beelsebob> I don't -- what's the error you're seeing?
09:38:28 <conal> just "cabal: Error: some packages failed to install: lhs2tex-1.14 failed during the configure step. The exception was: exit: ExitFailure 11"
09:38:56 <copumpkin> I just cabal install'd lhs2tex and it worked fine
09:39:04 <conal> copumpkin: on os x?
09:39:06 <copumpkin> yup
09:39:09 <copumpkin> 'sall I run
09:39:13 <conal> wow.
09:39:21 <copumpkin> what error did it give you?
09:39:26 <conal> copumpkin: which version of lhs2tex did you find?
09:39:33 <copumpkin> 1.14
09:39:38 <conal> copumpkin: see above for the error message
09:39:51 <copumpkin> oh, weird
09:40:20 <Beelsebob> conal: can you use verbose to find out why configure is failing?
09:40:29 <conal> hm.  that's the version i use also.  there's something strange going on.  i don't think that version can compile, since it uses the old exception interface.
09:41:05 <copumpkin> well, ghc still ships with base3
09:41:05 <copumpkin> so cabal should resolve that for you
09:41:05 <conal> Beelsebob: yeah.  the last thing i see in --verbose before it dies is the setup configure line.
09:41:25 <benmachine> is this a runhaskell Setup.hs or a cabal install
09:41:32 <Beelsebob> conal: anything before that?
09:41:34 <conal> copumpkin: what does the first build-depends line say about base?
09:41:39 <copumpkin> wow, lhs2tex's Setup.hs is pretty involved
09:41:58 <copumpkin>   if flag(splitBase)
09:41:58 <copumpkin>     build-depends:      base >= 3, regex-compat, mtl, filepath, directory, process, utf8-string
09:41:58 <copumpkin>   else
09:41:58 <copumpkin>     build-depends:      base < 3, regex-compat, mtl, filepath, utf8-string
09:42:04 <copumpkin> maybe you have a splitBase flag set?
09:42:06 <copumpkin> I gotta run
09:42:37 <conal> hm.  i'd think that first base constraint would pick up the most recent base, not 3
09:42:52 <conal> and the second base constraint wouldn't be satisifiable.
09:43:24 <conal> Beelsebob: i'll paste
09:43:26 <vav> yeah, probably will build with --constraint='base < 4.0'
09:44:34 <hackagebot> bindings-common 0.2.1 - Low-level library bindings, base package. (MauricioAntunes)
09:45:56 <Beelsebob> I get setup: kpsewhich command not found
09:46:27 <Beelsebob> oh, looks like I'm lacking a tex distribution
09:46:41 <conal> Beelsebob: yeah -- that's the symptom of missing tex
09:46:58 <conal> here's my failure log: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3096#a3096
09:47:34 <Beelsebob> hmm, no idea
09:47:35 <Beelsebob> :/
09:47:35 <hackagebot> bindings-posix 0.0.2 - Check bindings-common package for directions. (MauricioAntunes)
09:48:21 <conal> Beelsebob: what cabal version do you have?
09:48:31 <Beelsebob> 1.6.0.3
09:48:53 <conal> hm.  me too.
09:49:09 <conal> Beelsebob: what OS version?
09:49:23 <Beelsebob> 10.5.7
09:49:33 <conal> me too.  weird.
09:50:20 <conal> i wonder if some macports stuff could be interfering
09:50:48 <conal> Beelsebob: have you tried gtk2hs on os x?
09:50:56 <Beelsebob> yep
09:51:02 <Beelsebob> took a little hoop jumping, but it works fine
09:51:24 <Beelsebob> if you look in the gtk2hs mailing list archives, you'll find a message about how to do it
09:51:25 <conal> Beelsebob: with os x style gtk or x11 style gtk?
09:51:30 <Beelsebob> X11
09:51:36 <Beelsebob> the native one is pretty nastily unstable
09:51:44 <conal> oh.  okay.
09:51:50 <conal> i guess i'll go x11 :p
09:52:31 <conal> Beelsebob: does it have the same problem with ghci that glut has?
09:52:39 <Beelsebob> no idea
09:52:43 <Beelsebob> I rarely use ghci
09:53:23 <conal> i've been wondering how people are satisfied with not using a repl.
09:53:29 <conal> it's such a boost for me.
09:54:33 <Baughn> Boo yah. I think this is the first time I've gotten a nontrivial haskell program to type-check first try.
09:54:45 <Baughn> ..even if it /does/ look like lisp
09:54:55 * conal high-fives Baughn 
09:56:05 <Baughn> conal: Oh, by the way, do you think it's a problem if I have my strictly increasing getTime function do the "strictly increasing" bit by occasionally increasing the nanosecond-precision time value it returns slightly?
09:56:22 <Cale> conal: I know... It's really hard to live without ghci
09:57:38 <conal> Baughn: i don't know.  sounds like a dodgy work-around that may succeed in hiding rather than curing an important conceptual issue.
09:58:12 <Baughn> conal: Time.hs is nothing /but/ a dodgy workaround. I'm not sure what the non-dodgy version would look like; it seems almost uncomputable.
09:58:24 <conal> Cale: glut & ghci don't get along in os x, and what i've been hearing so far is "oh yeah -- i don't use ghci".
09:58:30 <Baughn> conal: But you're right. I should probably have an arbitrary-precision serial value attached instead.
09:58:34 * Baughn won't, though
10:00:39 <iago> does not the type of deleteBy be (a -> b -> Bool) -> b-> [a] -> [a] ?
10:00:55 <Baughn> @type deleteBy
10:00:56 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
10:01:18 <iago> its type is restrictive without a good reason I think
10:01:23 <conal> iago: hm.  your signature sounds better to me.
10:01:27 <iago> it avoids you to use predicates like ((==) . fst)
10:01:54 <conal> iago: maybe someone added the signature without realizing its loss of generality.
10:02:12 <Baughn> @src deleteBy
10:02:13 <lambdabot> deleteBy eq x []        = []
10:02:13 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
10:02:26 <Baughn> @type let deleteBy eq x [] = []; deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
10:02:27 <lambdabot> on the commandline:
10:02:28 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
10:02:28 <lambdabot> <no location info>:
10:02:31 <Baughn> @type let deleteBy eq x [] = []; deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys in deleteBy
10:02:33 <lambdabot> forall t a. (t -> a -> Bool) -> t -> [a] -> [a]
10:02:56 <conal> although in wonder if deleteBy is worthwhile at all, considering how close it is to filter . not
10:05:01 <glguy> deleteBy only deletes one element
10:05:06 <conal> oh
10:05:17 <glguy> "deleteFirstBy"
10:05:43 <conal> i guess deleteBy is part of the old last-as-set api
10:05:53 <conal> before we had efficient functional sets
10:06:12 <conal> oops -- list-as-set
10:06:41 <iago> well
10:07:01 <iago> "feature request" or "bug report" ?
10:07:01 <iago> :P
10:09:23 <dufflebunk> cabal doesn't seem to build the *_hsc.c files which hsc2hs generates
10:10:06 <dcoutts> dufflebunk: right, it doesn't support that hsch2s feature yet, there's an open ticket on it if you're interested, otherwise just don't use the feature and use separate .c files
10:11:01 <dufflebunk> dcoutts: Ticket #245? Yeah, I saw it. I hoped it was just old.
10:17:17 <Beelsebob> quicksilver: do you have a way to use ghci to view OpenGL stuff on a mac?
10:18:52 <erisco> what is up with the posix regexp library? http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html#x_TF
10:19:09 <erisco> their examples error out but the involved reading says they should be working
10:19:30 <erisco> and on my machine, Ubuntu 9.04 with the posix regexp library installed from the repo, has the exact same problem
10:20:22 <erisco> in the comments they suggest to use [[String]] but that frankly does not obtain the desired result for me either. I get [["ii","ii"],["uu","uu"]] as a result on their first example
10:21:55 <benmachine> ghc --version?
10:22:56 <erisco> 6.8.2
10:25:03 <dcoutts> dufflebunk: we keep the Cabal trac pretty up to date.
10:28:31 <erisco> okay, now even more examples are erroring out
10:28:41 <erisco> even in the book and they continue on like they are not :s
10:28:47 <erisco> "i foobarbar a quux" =~ pat :: [(Int,Int)]
10:28:54 <erisco> that causes a no instance error as well
10:29:01 <erisco> pat is "(foo[a-z]*bar|quux)"
10:30:09 <gwern> 'I mean, if 10 years from now, when you are doing something quick and dirty, you suddenly visualize that I am looking over your shoulders and say to yourself "Dijkstra would not have liked this", well, that would be enough immortality for me.'
10:31:16 <gwern> http://lemonodor.com/images/dijkstra-quick-n-dirty-s.jpg <-- made famous by this one, I suppose
10:41:57 <shepheb> www.happstutorial.com is down... is this a permanent state of affairs?
10:46:09 <hackagebot> WebBits 1.0 - JavaScript analysis tools (ArjunGuha)
10:48:26 <pchiusano> hello
10:48:34 <dufflebunk> hello pchiusano
10:49:41 <saml> hi pchiusano
10:49:49 <pchiusano> the company i work for is looking to hire someone with FP experience to work in Scala
10:50:19 <pchiusano> several months ago I posted something on the haskell mailing list and a few other places, but we haven't gotten many responses
10:50:25 <pchiusano> http://www.haskell.org/pipermail/haskell-cafe/2008-December/051295.html
10:50:31 <cjb> pchiusano: try the Scala lists instead :)
10:50:55 <pchiusano> I was wondering if there is just a drought of Haskell programmers in Boston or if we need to advertise position better
10:51:03 <saml> can I work?
10:51:13 <pchiusano> or if Haskell programmers just hate Scala and don't want anythign to do with it
10:51:23 <pchiusano> :)
10:51:37 <saml> oh i don't know scala at all
10:51:52 <cjb> pchiusano: there isn't a drought; there's a Haskell user group meeting up regularly now
10:51:56 <pchiusano> saml: we don't expect you to know scala at all
10:52:13 <cjb> but I thihk it's also likely that Haskell programmers are more interested in writing Haskell than Scala
10:53:08 <saml> can I get interviwe quiz? I want to see if my programming skillz are marketable
10:53:12 <pchiusano> cjb: probably, but Scala is a very nice language and I think it is incredible what I get paid to do at my job
10:53:48 <dufflebunk> whoa, your home page crashes firefox
10:54:24 <pchiusano> dufflebunk: the clarifi home page?
10:54:30 <cjb> pchiusano: a lot of people think it's incredible what the trading industry gets paid to do for their jobs these days ;-)
10:54:39 <pchiusano> cjb: hehe
10:54:46 <dufflebunk> pchiusano: yeah, ff 3.5, fedora 11.
10:56:05 <jmelesky> seems to work fine on ff3.0, ff3.5 on OSX, fwiw
10:56:41 <iago> there is some package with Applicate instances for common monads?
10:57:17 <iago> oh, ok, I have to use WrappedMonad ;P
10:58:12 <PeakerWork> I just realized that the notion of catamorphism may be quite useful for more type-safe programming in C
10:58:22 <pchiusano> saml: are you able to work in the boston area?
10:58:24 <monochrom> Applicative instances for common monads are in base-3.0.1.0 and probably before.
10:58:37 <PeakerWork> i.e: When I have a struct with a tag and a union, I can write a vtable-based catamorphism that makes sure the guy calling me knows to handle all of the data in there
10:58:53 <dons> Did an interview for SDTimes on Haskell: http://www.sdtimes.com/blog/post/2009/07/27/Everyonee28099s-talking-about-Haskell.aspx
10:59:57 <Beelsebob> dons: man, they need a better name
11:00:02 <Beelsebob> I read that as STD Time
11:00:04 <jmelesky> dons: congratulations
11:00:09 <dons> cheers
11:00:10 <Beelsebob> but yeh, gz
11:00:20 <Nafai> dibblego:
11:00:25 <Nafai> Whoops
11:00:29 <Nafai> dons: Awesome
11:00:44 <Nafai> Hate it when my fingers aren't on the home row right
11:01:50 <saml> pchiusano, oh boston.. i might. but on the negative side now. well, i'll email you through mailing list link you posted
11:02:13 <pchiusano> saml: cool, yeah let me know if you have more questions about the position
11:02:40 <pchiusano> cjb: do you think it'd be cool for me to send an email to the boston haskell mailing list?
11:03:44 <luite> 11000 libraries on hackage?
11:03:51 <dons> hmm. 1100 I think.
11:04:29 <dons> there's 1450 or so now
11:04:34 <dons> around 12k modules
11:04:43 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/stats
11:05:20 <luite> dons: ah. the sdtimes article says 11,000
11:05:38 <dons> heh. oops. I'll mail the author
11:05:59 <dons> 11k libraries would be a lot
11:06:12 <dcoutts> :-)
11:07:51 <luite> it's a quote from Jason Dusek so it may not be the author's fault :)
11:08:00 <dons> yeah
11:08:10 <dons> he might have got the package/module count mixed up.
11:08:19 <dons> mailed the author
11:13:55 <saml> > e m a i l
11:13:57 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
11:17:12 <Badger> @pl \e m a i l -> l i a m e
11:17:13 <lambdabot> flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))
11:17:29 <PeakerWork> Badger: how's the Haskell studying going?
11:17:36 <Badger> PeakerWork: Slowly.
11:17:39 <ray> flippity floppity id
11:18:20 <PeakerWork> maybe @pl could use let for CSE
11:18:25 <PeakerWork> to make results shorter
11:18:41 <conal> copumpkin: ping
11:20:40 <copumpkin> hi
11:31:06 <lpsmith> @seen copumpkin
11:31:07 <lambdabot> copumpkin is in #haskell-iphone, #haskell, #haskell.it, #darcs, #ghc, #haskell-in-depth and #haskell-blah. I last heard copumpkin speak 10m 26s ago.
11:32:47 <copumpkin> ?
11:34:03 <lpsmith> was it you that was asking about how call/cc can be efficiently implemented?
11:34:25 <lpsmith> (it may have been mmorrow or ski now that I think about it)
11:34:35 <lpsmith> anyway
11:34:57 <copumpkin> not me
11:35:10 <lpsmith> n/m then :-)
11:35:22 <copumpkin> although I wouldn't be opposed to hearing about it :)
11:36:29 <lpsmith> haha,  http://lambda-the-ultimate.org/node/3527
11:44:41 <seanmcl> I just noticed that you can have two 'qualified' modules with the same name.  Is that a bug?
11:44:46 <seanmcl> import qualified Data.List as L
11:44:46 <seanmcl> import qualified Data.Char as L
11:44:46 <seanmcl>  
11:44:46 <seanmcl> x = L.concat []
11:44:49 <seanmcl> y = L.toUpper 'c'
11:44:53 <seanmcl>     
11:46:01 <PeakerWork> seanmcl: Sure seems like a bug, but the design of imports in Haskell is so borked that I wouldn't be surprised if it was intentional
11:46:29 <saml> seanmcl, think about import Data.List ;  import Data.Char
11:46:35 <saml> it's the samething without the L
11:47:00 <Daimonic> @src iter
11:47:00 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:47:47 <saml> iter 0 comb = id
11:47:47 <saml> ; iter n comb = comb . iter (n-1) comb
11:47:58 <PeakerWork> saml: same horrible thing :-(
11:48:25 <PeakerWork> Haskell should just copy Python's import syntax and (as much as applicable) semantics
11:48:27 <hackagebot> file-embed 0.0.0 - Use Template Haskell to embed file contents directly. (MichaelSnoyman)
11:48:30 <PeakerWork> They got it right..
11:48:41 <Daimonic> > id . succ 5
11:48:43 <lambdabot>   No instance for (GHC.Enum.Enum (a -> b))
11:48:43 <lambdabot>    arising from a use of `GHC.Enum...
11:48:44 <PeakerWork> Well, until they started adding relative imports, not sure if that part is right
11:48:53 <PeakerWork> > id . succ $ 5 -- ?
11:48:54 <lambdabot>   6
11:49:32 <Daimonic> hm, (.) <=> f(g x) <=> f . g x
11:49:39 <Daimonic> so why do I have to put 5 in brackets?
11:50:00 <seanmcl> saml: I was interpreting 'import qualified Data.List as L' to be equivalent to 'structure L = List' in ML
11:50:01 <saml> associativity
11:50:03 <Saizan> dcoutts: around? do you know where i can find the code that builds and creates docs on hackage currently?
11:50:10 <seanmcl> this is clearly not what is going on
11:50:34 <PeakerWork> Daimonic: f (g x) <=> (f . g) x
11:50:38 <saml> LL in haskell does not stand for ML
11:50:45 <Daimonic> ouh, bis misstake, thanks!
11:50:46 <seanmcl> :)
11:50:49 <Daimonic> big*
11:51:23 <Gracenotes> Haskell's module system is pretty straightforward
11:51:28 <hackagebot> data-object 0.0.0 - Represent hierachichal structures, called objects in JSON. (MichaelSnoyman)
11:52:05 <Gracenotes> wherever it's imported, a module behaves the same anywhere
11:52:21 <Gracenotes> except you can change scoping rules and whatnot
11:52:58 <Gracenotes> import qualified names, hiding names, importing only certain names..
11:53:30 <seanmcl> Gracenotes: so import qualified M as L creates a new namespace L, and all teh imports jsut dump names into L?
11:53:39 <hackagebot> yaml 0.0.0 - Support for serialising Haskell to and from Yaml. (MichaelSnoyman)
11:53:59 <seanmcl> and later imports shadow earlier ones of the same name?
11:54:21 <Daimonic> so the dot-operator (.) has a higher binding than a regular function?
11:54:21 <Saizan> seanmcl: no shadowing
11:54:34 <saml> Daimonic, no.
11:54:58 <saml> infixr 9 .
11:55:15 <Gracenotes> there is no import shadowing... there are no real conflicts unless you reference a name that is ambiguous
11:55:16 <PeakerWork> Gracenotes: the default module namespacing (unqualified open import of everything) is horrible
11:55:30 <seanmcl> :browse Data.List
11:55:35 <seanmcl> oops
11:55:38 <Gracenotes> PeakerWork: you cannot deny it is straightforward, though
11:55:40 <hackagebot> json2yaml 0.2.0 - Utility to convert a file from JSON to YAML format. (MichaelSnoyman)
11:55:53 <PeakerWork> Gracenotes: I am not sure that is a good measure of anything important, though
11:56:06 <PeakerWork> Gracenotes: The ability to read code and understand where names are coming from is important..
11:56:16 <saml> lol
11:56:24 <Gracenotes> making a point: as opposed to ML where it is not straightforward
11:56:27 <saml> :i name.. duh
11:56:32 <PeakerWork> Gracenotes: I don't know ML
11:56:33 <Saizan> seanmcl: import qualified A as L; import qualified B as L; and suppose both A and B export foo, then L.foo will give an "ambiguous occurrence L.foo" error
11:56:38 <Daimonic> so when I have id . iter n id I can write straight: iter n id
11:56:50 <PeakerWork> saml: Do you suggest I have each module I read loaded in ghci, always, and switch to the ghci window to make queries at each point?
11:57:16 <PeakerWork> Daimonic:   id . f  =  f . id  = f
11:57:27 <saml> PeakerWork, ok go type Language.Haskell.Factory.XML.Java.Hola.Monad.Class.YAML.XML.XML.XML.succ
11:57:37 <Saizan> or in other words, (id .) = (. id) = id :)
11:57:39 <saml> so that you can know where succ comes from
11:57:52 <PeakerWork> saml: No, you can just import qualified Language.Haskell.Factory.XML.Java.Hola.Monad.Class.YAML.XML.XML.XML as X
11:57:54 <PeakerWork> saml: X.succ
11:58:05 <PeakerWork> saml: or import (succ) in parens
11:58:11 <PeakerWork> saml: import Language.Haskell.Factory.XML.Java.Hola.Monad.Class.YAML.XML.XML.XML(succ)
11:58:27 <PeakerWork> Saizan: :)
11:58:37 <Gracenotes> a basic objective, within the system anyway, is to mainly prevent ambiguous names from happening. The compiler doesn't complain too much or require too much otherwise.
11:58:37 <saml> PeakerWork, do you suggest I browse head of source code to find where X.succ is from?
11:58:55 <PeakerWork> saml: No, do a reverse-lookup of a name in the file
11:59:05 <PeakerWork> saml: it finds either a local definition, or the import
11:59:07 <saml> F3 goes to definition of what's under cursor. and F2 opens tultip
11:59:24 <PeakerWork> saml: How does F3 find definitions? Using a running ghci?
11:59:29 <saml> using IDE
11:59:34 <Saizan> PeakerWork: being able to alias multiple modules in the same way is quite handy however, it's nice when the modules you're importing are semantically grouped
11:59:44 <saml> reverse-lookup = feature of your editor. F3/F2 = feature of my IDE
11:59:47 <PeakerWork> saml: Why can't your IDE maintain the imports with parens? That way, its friendly to both you and the other readers?
11:59:55 <seanmcl> :Gracenotes I don't understand your comment about no shadowing.  I can do 'import qualified Data.List as L import qualified Data.Map as L'.  These modules share identifiers like 'union'.  Does ghc figure out which of L.union it means by typing?  It seems L.union should be uniquely identified.
11:59:57 <PeakerWork> saml: Your IDE screws everyone else :)
12:00:14 <PeakerWork> Saizan: Example?
12:00:38 <Saizan> seanmcl: L.union will error out because it's ambiguous
12:01:01 <seanmcl> oh, ok
12:01:10 <PeakerWork> Saizan, saml: I think the practical disadvantages, where adding new exported names breaks backwards compatibility of modules for no benefit except perhaps a dubious aesthetics one is unjustified
12:01:22 <Saizan> seanmcl: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7597#a7597
12:01:30 <Gracenotes> seanmcl: either union function is effectively unusable, since any reference would be truly ambiguous
12:01:39 <PeakerWork> saml: So your way requires I use your IDE too, and it also makes new exported names break existing code :-(
12:02:35 <saml> ? use different namespace
12:02:41 <Phyx-> damnit.. i need one of those "NO i will not fix your pc" t-shirts
12:02:44 <Gracenotes> however, you can also have many imports for one module.
12:02:45 <saml> import Data.List as List; import Data.Char as Char
12:03:11 <saml> or just import Data.List; import Data.Char;   and Data.Char.union
12:03:14 <Gracenotes> for example, two qualified names for the same module. But a better idea would just to use two separate ones to begin with if there is danger for overlap, not have them share.
12:03:19 <hackagebot> dotgen 0.4 - A simple interface for building .dot graph files. (AndyGill)
12:03:42 <PeakerWork> saml: if you "just import Data.List" then if Data.List gets a new export name that is like one of your names it breaks
12:04:00 <dufflebunk> In a cabal file for a library, if there's c-sources line, are those supposed to be compiled and linked into the library?
12:04:30 <saml> PeakerWork, breaks? you mean compiler hinting me of ambiguity so that i can clarify ?
12:04:50 <PeakerWork> saml: Only if it breaks while you develop.  If Data.List gets a new name, half of hackage may break
12:05:06 <PeakerWork> saml: so it will be "hinting" hundreds of developers about packages they've long forgot about that they need to clarify
12:05:30 <saml> so good developers will always clarify
12:05:32 <PeakerWork> saml: unqualified imports with paren listing of names are fine.  Qualified imports are fine.  Unqualified open imports suck and have no advantage at all
12:05:43 <PeakerWork> saml: exactly, good developers won't ever use unqualified open imports
12:05:55 <PeakerWork> But first, good developers must understand that unqualified open imports are bad
12:07:59 <PeakerWork> One of the most important things namespaces should do - is allow different authors not to worry about colliding their names (except for chosen module names, perhaps, but it would be nice to solve this one too).  Unqualified imports defeat this purpose
12:08:53 <mmorrow> dufflebunk: yes
12:10:48 <Saizan> PeakerWork: i was talking about the ability to do import Foo as M; import Bar as M; which you said it looks like a bug, not about the question of qualified imports
12:11:13 <PeakerWork> Saizan: I understand, I was still wondering about an example of the "semantically grouped" modules
12:13:01 <Daimonic> @src (++)
12:13:01 <lambdabot> []     ++ ys = ys
12:13:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:13:01 <lambdabot> -- OR
12:13:01 <lambdabot> xs ++ ys = foldr (:) ys xs
12:13:16 <dufflebunk> mmorrow: yeah, it does if I spelled the names right.
12:13:40 <PeakerWork> If you think of foldr as "search&replace" of (:) and [],  then seeing it replacing (:) with (:) and [] with ys  is actually a very readable definition :)
12:14:31 <Saizan> PeakerWork: there are times when you split the interface of some datatype or similar across different modules
12:14:44 <Daimonic> any idea how I could show: map f (as ++ bs) = map f as ++ map f bs
12:15:02 <PeakerWork> Daimonic: What do you mean?
12:15:12 <PeakerWork> Daimonic: When you "show" it, it will just show the resulting list?
12:15:27 <Beelsebob> I think he's asking how to prove it
12:15:29 <mmorrow> dufflebunk: ah, the old spelling-the-function-names-right trick. works every time!
12:15:35 <Daimonic> I am doing structural induction on haskell functions
12:15:37 <conal> quicksilver: ping
12:15:45 <Daimonic> I mean theoretical proof
12:15:48 <Saizan> PeakerWork: e.g. for Seq you need to import Data.Foldable and Data.Traversable too, and you might just want to alias those to Seq if you're not using them for other datatypes
12:15:53 <Daimonic> based on function definitions :)
12:15:58 <Beelsebob> Daimonic: try a base case that looks like as == []
12:16:07 <mmorrow> , [d|map f (as ++ bs) = map f as ++ map f bs|]
12:16:08 <lunabot>  luna: Parse error in pattern
12:16:12 <Beelsebob> and an inductive case that assumes it works for as, and tries to prove it for a:as
12:16:16 <Saizan> PeakerWork: but the examples i've seen are mostly inside Cabal or hackage-server
12:16:42 <mmorrow> err, since that'd not valid syntax you'd need to build it yourself
12:16:57 <mmorrow> , [|map f as ++ map f bs|]
12:16:58 <lunabot>  luna: Not in scope: `as'
12:17:04 <mmorrow> , [|\f as bs -> map f as ++ map f bs|]
12:17:06 <lunabot>  LamE [VarP f_0,VarP as_1,VarP bs_2] (InfixE (Just (AppE (AppE (VarE map) ...
12:17:13 <PeakerWork> Saizan: Not sure I see what advantage there is from sharing the name there. I think I'd still prefer to know which name is from Foldable, and which from Traversable
12:17:16 <mmorrow> , [|\x -> x|]
12:17:18 <lunabot>  LamE [VarP x_0] (VarE x_0)
12:17:57 <Beelsebob> Daimonic: hint... base case: map f ([] ++ bs) = map f bs = [] ++ map f bs = map f [] ++ map f bs
12:18:01 <mmorrow> Daimonic: if you want to do this programmatically, you probably need to work with some AST
12:18:02 <Beelsebob> that one works :)
12:18:11 <Saizan> PeakerWork: why? you're just using them to work on a Seq
12:18:12 <PeakerWork> also: map f . map g = map (f . g)
12:18:29 <Saizan> PeakerWork: i agree that it's not the best example :)
12:18:39 <Daimonic> Beelsebob: nice
12:18:44 <mmorrow> Daimonic: oh, which i just realized you aren't (i don't think) :)
12:18:51 <Beelsebob> Daimonic: now you just have an inductive case to work on :)
12:19:00 <PeakerWork> Saizan: because I like knowing if I'm using Foldable methods or Traversable methods. For similar reasons why I'd like functions that only use liftM to have Functor contexts rather than Monad contexts
12:19:36 <Saizan> PeakerWork: in this use case you're not creating polymorphic functions though
12:19:51 <Saizan> PeakerWork: the assumption was that you were working with Seq
12:19:56 <PeakerWork> Saizan: Still, am I using Seq's Foldableness or its Traversableness? :)
12:20:06 <Saizan> why do you care?:)
12:20:24 <PeakerWork> Saizan: It may give me insights about the nature of what I'm doing to the Seq
12:20:44 <PeakerWork> Saizan: Its like extra documentation inside the names of the operations  I'm using, what kind of operations they are
12:22:07 <Saizan> PeakerWork: the distinction doesn't look so deep to deserve that much attention, however i guess you've understood my original point by now :)
12:22:47 <PeakerWork> :)
12:23:15 <PeakerWork> Saizan: I still place more value on the pragmatic issue of namespace collisions than any of the aesthetic ones..
12:23:49 <dufflebunk> mmorrow: in this case it was the file name /and/ the cabal file field name I had wrong. This is startingout as a GREAT day!
12:23:57 <Saizan> PeakerWork: this doesn't have much to do with the pragmatics you were talking about, no?
12:24:27 <PeakerWork> Saizan: Still does, if a name you used from either Foldable or Traversable is later put in the other
12:24:34 <PeakerWork> Saizan: later also exported from the other, that is
12:24:57 <PeakerWork> Saizan: In these particular packages, its likely the authors are synchronized, but I think relying on this implicitly this way is not a good idea
12:26:36 * Saizan loves when stale code breaks
12:28:14 <PeakerWork> N-tuples and open unqualified imports are my pet Haskell peeves :)
12:29:35 <Gracenotes> but Haskell died, didn't he? :( *moment of silence*
12:29:48 <Gracenotes> the pet Haskell, that is
12:30:05 <Saizan> there's no need to remind us at every occasion though :P
12:30:24 <rocketman> Gracenotes what are you on about
12:33:45 <badsheepy> whats wrong with n-tuples?
12:34:41 <conal> badsheepy: they break compositionality and require infinitely many variations of utility functions.
12:35:10 <Haudrex> What's the type of a tuple of arity n?
12:35:24 <badsheepy> so should you just never use them ever then? or do they have specific benefits?
12:35:50 <PeakerWork> badsheepy: The language shouldn't have had them in that form in the first place, but rather composed of 2-tuples or 2-tuples and 0-tuples
12:35:52 <conal> badsheepy: oh, no.  use them as you want.
12:35:58 <PeakerWork> something more like HLists
12:36:16 <conal> badsheepy: just realize that you'll run into awkwardnesses.
12:36:22 <Saizan> badsheepy: they have direct access to any element and a more compact representation than nested 2-tuples
12:36:49 <badsheepy> my plan is generally to avoid awkwardness, but i never had a use for a more than 2-tuple yet, so i was just wondering for if i ever did )
12:36:58 <conal> yeah.  they have some implementation benefits.  not sure how much anymore, now that compilers are smarter.
12:37:14 <Saizan> badsheepy: however if you go over a 3-tuple you should use a custom datatype or people will righly hunt you down with pitchforks
12:37:14 <badsheepy> well ty :)
12:37:22 <PeakerWork> conal: there's the issue of lifted tuples making the bottoms different
12:37:33 <conal> PeakerWork: yeah.  that's the semantic difference.
12:37:33 <Haudrex> TreeLoc has a 4-tuple in it :)
12:37:37 <PeakerWork> I'd also like it if type products weren't lifted...
12:37:43 <conal> oh.
12:38:08 <Saizan> Haudrex: where is the author located? ;)
12:38:57 <Haudrex> Saizan: Not sure. Let's cojoin, merge, and then find out.
12:40:03 * lilac considers right-strict pairs
12:40:58 <lilac> something like: data a :, b = a :, {-# UNPACK #-} !b
12:41:07 <byorgey> Saizan: how is the hbuild project going?
12:41:10 <byorgey> Saizan: someone at Hac phi was talking about wanting a more flexible make-like system with cabal and I pointed him in the direction of your project, I don't know if he contacted you
12:43:02 <Saizan> byorgey: he didn't, the project has been quite stalled mostly for lack of time/motivation on my part, though i've started working on it again just recently
12:43:45 <Saizan> byorgey: if you need to infer build-depends: extensions: and other-modules: fields it's quite handy currently :)
12:44:10 <byorgey> ok, cool, well it sounded like he (twadleigh) might even be interested in contributing some code, I hope he does contact you.
12:44:14 <byorgey> nice =)
12:48:44 <Haudrex> A lot of algorithms require knowing the length of a list (binary search comes to mind), how do you work around this in Haskell?
12:49:16 <rocketman> do not work around
12:49:19 <SamB> Haudrex: binary search isn't sensible on linked lists
12:49:20 <Saizan> binary search on an haskell list is not going to work well anyway
12:49:39 <SamB> linear search is truly the most efficient way to search a linked list
12:49:40 <Haudrex> so, Arrays?
12:49:54 <Baughn> Haudrex: Data.Map?
12:49:56 <SamB> Haudrex: typically we just use binary search trees if we want to binary search them
12:50:04 <SamB> yes, like Data.Map does
12:50:19 <Baughn> Haudrex: If you want the gritty details, I can recommend Purely Functional Data Structures
12:50:22 <Haudrex> good point, so you would have a binary graph already in the first place
12:50:33 <Saizan> if you need something more list-like with random access there's Data.Seq
12:50:36 <etpace> how much of a tome is Purely Functional Data Structures?
12:50:43 <etpace> i'm looking for a new book to read but i'm not too good
12:51:03 <Baughn> etpace: It's pretty slim, but it's not about /using/ haskell, it's essentially about /implementing/ it.
12:51:24 <Baughn> Once the various structures in it have been implemented, you rarely need to do so on your own - and they have
12:51:30 <Haudrex> I read Okasaki's paper on red-black trees and it was quite comprehensible and terse.
12:51:40 <Baughn> etpace: Still, it's mind-expanding. :3
12:51:42 <SamB> Baughn: the cost models might be handy!
12:51:49 <etpace> Yeah, I'm just looking for an interesting book
12:51:53 <Baughn> etpace: And free! Google it. Can't hurt you.
12:51:53 <etpace> thanks
12:51:58 <etpace> oh free? why not
12:52:03 <Baughn> (I prefer having the paper version at hand, though)
12:52:34 <Baughn> SamB: Sure. It's mind-expanding, I just don't think it's a high priority when learning haskell.
12:52:48 <Baughn> OTOH, neither is unsafePerformIO, and I've found that function to be invaluble in practice.
12:52:50 <SamB> Baughn: sure, it's not part of knowing the language
12:53:06 <lysgaard> I want to make Data.LargeWord.Word160 an instance of Binary, but I'm doing something worng. I guess it's just me being a bit stupid. Anyone want to show me how?
12:53:14 <SamB> I think unsafePerformIO is more important to saying you know really Haskell ;-P
12:53:22 <SamB> s/know really/really know/
12:53:24 <Baughn> lysgaard: It's an instance of Bits, right?
12:53:31 <Baughn> lysgaard: Just extract 8 bits at a time and use putWord8
12:53:45 <lysgaard> Baughn: Can i do that?
12:54:03 <glguy> The Bits instance of Crypto's LargeWord was wrong last I tried it
12:54:04 <Baughn> lysgaard: I don't see why not. It'd be a simple mapM-loop.
12:54:04 <SamB> lysgaard: you can shift and fI, can't you?
12:54:31 <Baughn> glguy: ..right, that'd be a problem.
12:55:12 <lysgaard> There's something fishy about this LargeWord type, but since I'm such a greenhorn in haskell I can't point out what
12:55:38 <Baughn> Oh, right. I remember now - it bugged out on me when I tried using it in my crypto class a year ago.
12:55:41 <Baughn> Avoid, I guess.
12:55:47 <Baughn> And that was /not/ for the Bits instance
12:56:03 <FunctorSalad_> "<conal> badsheepy: they break compositionality and require infinitely many variations of utility functions." <-- hehe true http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7598#a7598
12:57:32 <conal> FunctorSalad_: sigh.  exactly.
12:57:34 <Baughn> lysgaard: What are you using Data.LargeWord for?
12:57:50 <lysgaard> Baughn: A sha-1 digest
12:57:52 <conal> still, it's impressive that the bear can dance at all.
12:58:04 <Baughn> conal: *blink*
12:58:30 <FunctorSalad_> wrote that some time ago. apparently it makes a projection onto the positions specified by the bit mask, and applies a function to the result while it's at it
12:58:46 <saikobee> is there some kind of system call command in haskell?
12:58:49 <Baughn> lysgaard: You could newtype Integer to make yourself a new Word160 type. If speed is an issue, I expect that HsOpenSSL would be faster than either.
12:59:01 <Baughn> saikobee: Several, in System.Process
12:59:03 <FunctorSalad_> @type system
12:59:04 <lambdabot> Not in scope: `system'
12:59:15 <FunctorSalad_> @type System.IO.system
12:59:16 <lambdabot> Not in scope: `System.IO.system'
12:59:20 <FunctorSalad_> @type System.IO.rawSystem
12:59:22 <lambdabot> Not in scope: `System.IO.rawSystem'
12:59:31 <Baughn> saikobee: And an explicit system :: String -> IO ExitCode in System.Cmd
12:59:33 <benmachine> FunctorSalad_: I think lambdabot doesn't know about syscalls
12:59:47 <benmachine> so that people don't do anything untoward
12:59:49 <conal> Baughn: an old joke/saying
12:59:56 <lysgaard> Baughn: Speed is kinda of an essence, because the whole DHT runs on  these sha digests. What's the HsOpenSSL type?
13:00:03 <SamB> @type Foreign.unsafePerformIO
13:00:04 <lambdabot> forall a. IO a -> a
13:00:16 <SamB> benmachine: are you certain that's what's up?
13:00:16 <benmachine> huh
13:00:21 <benmachine> clearly not
13:00:22 <Baughn> lysgaard: digestBS :: Digest -> ByteString -> String
13:00:39 <FunctorSalad_> (and it's in System.Process, not System.IO)
13:00:58 <saikobee> thanks, hoogle didn't seem to know about any system command
13:01:03 <Baughn> lysgaard: It's actually just a byte-array; a slight bit of hacking on the source would give you Digest -> ByteString -> ByteString.
13:01:25 <Baughn> lysgaard: http://hackage.haskell.org/packages/archive/HsOpenSSL/0.6.4/doc/html/OpenSSL-EVP-Digest.html
13:02:17 * Baughn opines that HsOpenSSL could use a bit of cleanup
13:02:31 * lysgaard Agrees
13:02:45 <lysgaard> This is messy
13:03:17 <Baughn> The crypto stuff has gotten a lot better, but the digest functions are still in a sorry state.
13:03:31 <Baughn> For the time being, you can compose them with Data.ByteString(.Lazy).Char8.pack
13:04:14 <lysgaard> I don't get this. How do i digest let's say a byte stirng to get a sha-1?
13:04:16 <Baughn> lysgaard: ..and just so you know, even this is a vast improvement on raw OpenSSL.
13:04:59 <lysgaard> Baughn: I believe you. I'm spoiled I guess
13:05:14 <Baughn> lysgaard: To digest a byte-string..
13:05:41 <Baughn> lysgaard: getDigestByName "sha-1" >>= flip digestBS bytestring
13:05:50 <Baughn> Or LBS, as the case may be
13:05:52 <lilac> lysgaard: data Data160 = D160 Word32# Word32# Word32# Word32# Word32# ?
13:06:34 <lysgaard> Baughn: Ah, so i have to retrieve a "digest" function first. Kinda clumsy, but i get it =)
13:07:00 <Baughn> lysgaard: Right. libssl doesn't guarantee that any particular digest functions exist, so it's really the only way.
13:07:39 <Baughn> lysgaard: Oh, and while you need to call this inside withOpenSSL in your program, for ghci purposes you may wish to note that withOpenSSL does no uninitialization.
13:07:46 <lysgaard> Baughn: See. Why can't libssl guarantee that? Seems kinda strange thinking that it's only digest functions
13:07:51 <Baughn> In other words, you can call it with return (), and then use ssl in ghci
13:07:55 <Baughn> Just don't rely on that
13:08:33 <Baughn> lysgaard: The functions may later be subject to cryptographic breaches, in which case it's better for a program to crash than to use a broken function
13:08:44 <Baughn> At least that's the reasoning I got when I asked, but..
13:08:51 <Baughn> ...it's still got MD5.
13:09:01 <lysgaard> lilac: This Word32# Word32# syntax. I've never seen the # used in that way. What does it mean?
13:09:36 <Baughn> lysgaard: It's the Magic Hash. It becomes just part of the typename, but it isn't valid haskell syntax unless you enable an extension, so it won't be used casually.
13:09:36 <lysgaard> Baughn: True, you don't want security to be broken
13:09:37 <SamB> lysgaard: it generally means "this is a GHC-internal type or value thereof, probably primitive"
13:09:54 <Baughn> lysgaard: In this particular case, Word32# is the unlifted version of Word32; in other words, a raw machine word that can't be a thunk, undefined, or so.
13:10:29 <lysgaard> Ah, so it's much more efficient, bet less easy to handle?
13:10:40 <SamB> lysgaard: something like that
13:10:45 <SamB> definately lower-level
13:10:53 <Baughn> lysgaard: It's only rarely more efficient, actually. THe optimizer is good at using them when it can prove it'S safe.
13:11:22 <SamB> yeah, if you use {-# UNPACK #-} in the right places at least ;-)
13:11:22 <lysgaard> Baughn: So GHC can optimise such things, cool
13:11:35 <Baughn> lysgaard: "data Foo = Foo !Word32 !Word32" is roughly equivalent to "data Foo = Foo Word32# Word32#" for most purposes of performance, but much safer.
13:12:05 <Baughn> Still, if you have deep knowledge of how the compiler operates, it can be handy.
13:12:21 <lysgaard> Baughn: What does the ! mean then?
13:12:27 <lilac> lysgaard: it means 'strict'
13:12:29 <Baughn> lysgaard: That makes it strict
13:12:44 <Baughn> lysgaard: Meaning that it shares a thunk with the Foo constructor
13:13:06 <lilac> lysgaard: essentially it means that the Word32 value cannot be _|_. in principle that means that the Word32 can be unpacked into Foo, but in practice GHC does not automatically do that
13:13:08 <lysgaard> Ah, see, that's probably the way to go i guess
13:13:11 <SamB> Baughn: uh
13:13:12 --- mode: irc.freenode.net set +o ChanServ
13:13:36 <SamB> Baughn: -funpack-strict-fields isn't actually recommended, afaik
13:14:01 <lilac> if you want to force GHC to unpack the Word32's, you can use 'data Foo = Foo {-# UNPACK #-} Word32 {-# UNPACK #-} Word32', but that has the disadvantage that if you call a function which needs a Word32 thunk, GHC will need to create one
13:14:21 <SamB> that's presumably why it's not recommended ;-)
13:14:33 <SamB> to use -funpack-strict-fields, I mean
13:14:59 <lilac> right, it can be a pessimization in some cases
13:15:32 <lysgaard> Wow, I love how deep and almost philosopical discussions get in haskell, compared to all other "lesser" languages :D
13:15:35 <lilac> that's an upside of using Word32# I guess; the compiler won't implicitly convert it to a boxed Word32
13:15:56 <Baughn> SamB: No, -funpack-strict-field /forces/ the compiler to unpack them
13:16:05 <Baughn> SamB: But the optimizer does it without forcing in many cases, I'm pretty sure
13:16:17 <SamB> Baughn: you think?
13:16:35 <Baughn> SamB: Based on random gdb grovelling, yes.
13:16:41 <SamB> I don't think it has any way of predicting whether that will help or not at definition time, which is when it would need to ...
13:16:42 <Baughn> Admittedly I could be mistaken
13:16:55 <Baughn> Sure it can, via data-flow analysis
13:17:16 <Baughn> If it sees that the data is passed only to functions that treats it strictly /anyway/..
13:17:22 <SamB> Baughn: it doesn't know how you actually use the datatype until it compiles the modules that use it!
13:17:36 <Baughn> SamB: I mean inside a single module
13:17:54 <SamB> maybe it could do it if you don't export the type at all ... not sure
13:17:57 <Baughn> It's pretty rare to have performance-critical loops cross module boundaries, too!
13:18:10 <lilac> i guess strictness analysis can turn a functor :: Foo -> a into one :: (# Word32, Word32 #) -> a, then presumably into (# Word32#, Word32# #) -> a
13:18:17 <Baughn> Well, if the data doesn't escape, what's stopping it from inventing a new type just for local use?
13:18:38 <Baughn> lilac: Exactly
13:18:54 <SamB> Baughn: oh, I was talking about in the *actual* type
13:19:11 <lilac> although if it knows the function is strict in both parts of Foo, it could do that lowering anyway
13:19:19 <Baughn> SamB: The canonical form? No, that one's obviously more limited.
13:19:43 <SamB> Baughn: that's the form that {-# UNPACK #-} and -funpack-strict-fields affect
13:20:00 <Baughn> SamB: Yes, I can see why those would be more questionable.
13:20:15 <Baughn> Which was rather my point to lysgaard. Trust the compiler, don't try to overrule it without good reason. :)
13:20:51 <SamB> Baughn: this isn't a matter of overruling so much as "the compiler can't guess without doing whole-program compilation"
13:21:11 <Baughn> SamB: Right, but most of the performance-critical loops won't have this problem
13:21:36 <SamB> certainly it can do the worker-wrapper transform on just about everything
13:21:49 * Baughn did once have the dubious pleasure of seeing a virtual C++ call inside one such loop, thus cementing that opinion. ^^;
13:33:55 <lysgaard> Baughn: The getDigestNames function of ssl returns an empty list. Am I missing something?
13:34:12 <Baughn> lysgaard: Yes, withOpenSSL. I mentioned it earlier.
13:35:55 <lysgaard> Hm, worked =) Is the reason i need this because it's an foregin library?
13:36:47 <Baughn> Pretty much. OpenSSL needs to be initialized before use, and there
13:36:56 <Baughn> there's currently no way to register a function to be called before main.
13:36:59 <Baughn> Would be nice, though.
13:38:51 <lysgaard> Baughn: Yeah, shure would. But afterall, the best would me having an algorithm as effecient in pure haskell
13:39:12 <Baughn> lysgaard: COnsidering that the libssl one is hand-tuned assembly, this might take a bit of work.
13:41:27 <lilac> is it possible to implement this without any unsafe* functions? withUnsafePerformIO :: ((IO a -> a) -> b) -> IO b
13:41:35 <McManiaC> does anyone know if theres a haskell lib for .netrc stuff?
13:41:45 * lilac thinks probably not
13:42:22 <PeakerWork> lilac: doesn't that need Rank-N types?
13:42:45 <Saizan> lilac: maybe in the Cont monad
13:42:47 <lilac> PeakerWork: i think it's rank 3, so yeah
13:43:02 <Saizan> it's a third order function
13:43:10 <Saizan> but there's not higher rank type there
13:43:32 <lilac> Saizan: i messed it up, i wanted :: ((forall a. IO a -> a) -> b) -> IO b
13:43:41 <Saizan> ah, ok
13:44:16 <dolio> That function isn't safe.
13:44:42 <lilac> dolio: that's what i thought. it lets us see when things inside the function are evaluated, in what order, how many times, etc
13:44:45 <dolio> So being unable to implement it without unsafe functions isn't surprising.
13:44:46 <Berengal> unsafePerformIO is the only IO a -> a function out there. The only other option is undefined
13:45:21 <lysgaard> Baughn: Hm.. This returns nothing, i can't understand why: withOpenSSL $ getDigestByName "RSA-SHA1"
13:45:26 <Berengal> Or const undefined
13:45:38 <Baughn> lysgaard: Try getDigestNames instead.
13:45:57 <dolio> withUnsafePerformIO (\uPIO -> let x = uPIO foo in bar x x) /= withUnsafePerformIO (\uPIO -> bar (uPIO foo) (uPIO foo))
13:45:59 <lysgaard> Baughn: I've done that, it returns RSA-SHA1
13:46:05 <Baughn> lysgaard: Also. If you say "withOpenSSL (return ())" first, you probably won't have to wrap your ghci experssions with withOpenSSL anymore.
13:46:17 <lilac> Berengal: withUnsafePerformIO _ = forever (putStrLn "Hello world") is the right type ;-)
13:46:21 <Baughn> lysgaard: Hm. Are you /sure/ it returns nothing?
13:46:28 <Baughn> lysgaard: I mean, does it actually return Nothing?
13:46:38 <Baughn> lysgaard: The digest functions aren't printable
13:46:52 <Berengal> lilac: True. I was talking about the IO a -> a function
13:47:06 <lilac> fair enough :)
13:47:19 <lysgaard> Baughn: No, it returns a blank screen
13:47:48 <lysgaard> Baughn: Ah, then i guess it works, even though it _looks_ like nothing happens
13:48:20 <Baughn> lysgaard: Nothing never happens. You do need to explicitly deconstruct the returned type to find out if it succeeded or not, but it never returns a /different/ type.
13:48:50 <Gracenotes> D:
13:50:45 <lilac> can we implement usesArgument :: (a -> b) -> a -> IO (b, Bool), which returns (b, True) if a was forced, and (b, False) if not, without unsafe*?
13:51:19 <dolio> Yes, I think so.
13:51:25 <Baughn> Why would you want to?
13:51:31 <Baughn> unsafePerformIO is so /handy/
13:51:43 <dolio> You'd have to ask mmorrow what the relevant functions are for asking GHC about whether something is evaluated.
13:51:50 <lilac> Baughn: i'm trying to get a feel for what unsafe /means/ ;-)
13:52:10 <lilac> dolio: that sounds almost like cheating :)
13:52:18 <Baughn> dolio: But what if it was already evaluated before being passed?
13:52:29 <Baughn> Also, my isEvaluated package is on hackage. ;)
13:52:35 <dolio> Well, then there's no way to tell. :)
13:52:40 <Baughn> Sure there is
13:52:57 <dolio> You could stick something of your own in there, I guess.
13:53:02 <lilac> do b' <- unsafeInterleaveIO (putMVar result True >> return b); f b'
13:53:05 <pikhq> lilac: "unsafe" in this case means "if you use this wrong, it will kick your puppy and nuke Russia".
13:53:07 <dolio> f undefined and catch the exception.
13:53:34 <lilac> dolio: that's pretty elegant, i like it
13:54:03 <Baughn> lilac: ..okay, that's much better than mine.
13:54:09 <monochrom> I don't understand the specification. Is it "determine whether the a->b function forces a", or is it "determine whether a is already forced before calling the function a->b"?
13:54:38 <lilac> monochrom: it's really, determine whether the a->b function can possibly give a different answer with a different value for a
13:55:07 <lysgaard> Baughn: If you wouldn't mind. Here is the digest func I'm trying to put together, but it complain about types: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7602#a7602
13:55:24 <Baughn> lysgaard: That is not how to use withOpenSSL.
13:55:28 <glguy> Is the SHA library on Hackage not fast enough?
13:55:45 <Baughn> lysgaard: It should be wrapped around /every/ call to openssl, preferably by saying "main = withOpenSSL $ do ..."
13:56:05 <lysgaard> Baughn: Man, that's stupid
13:56:15 <glguy> dolio: Do you have time for a logict question?
13:56:17 <Baughn> lysgaard: I also don't see the definition of digestBS', nor the actual error.
13:56:31 <dolio> Sure.
13:56:45 <Baughn> lysgaard: Also, you can say "Just d <- getDigestByName "foo"".
13:57:08 <lysgaard> Baughn: I found digestBS' in the source, its type is: digestBS' :: digest -> ByteString -> ByteString
13:57:23 <Baughn> lysgaard: Interesting. I wonder why it isn't exported.
13:57:32 <lysgaard> Baughn: It is
13:57:34 <glguy> I've got a three-dimensional search space. I have a predicate that will always return false in any one direction after the first time
13:57:43 <lysgaard> Baughn: Atleast in my version
13:57:52 <glguy> I'm wondering now to do something like?: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7601#a7601
13:58:01 <Baughn> lysgaard: 0.6.4?
13:58:25 <Baughn> lysgaard: This is weird. Yes, I see it being exported..
13:58:36 <Baughn> lysgaard: It just doesn't show up in the haddock documentation
13:58:43 <lysgaard> Baughn: 6.2
13:58:52 <glguy> it is kind of like searching do a<-[1..?];b<-[1..?];c<-[1..?];... where I don't know the ? until I find an example that didn't work
13:59:01 <glguy> does this fit into logict in any way?
13:59:17 <glguy> using >>- helps to search the whole space
13:59:22 <glguy> when I just wanted to find one element
13:59:26 <lysgaard> Baughn: But i think i'll let performance pass for this time. What was the other digest function and Word160 I could use?
13:59:28 <glguy> but doesn't tell me when I'll never find more
13:59:38 <Baughn> lysgaard: There's a sha library on hackage.
13:59:53 <Baughn> lysgaard: There isn't a Word160 you can use, really, if you care about correctness. Unless it got fixed.
13:59:57 <Baughn> lysgaard: There is Integer, though
14:00:09 <lysgaard> Baughn: I'm just to greenhorn to deal with this openssll
14:00:18 <Baughn> lysgaard: http://hackage.haskell.org/packages/archive/SHA/1.4.0/doc/html/Data-Digest-Pure-SHA.html
14:00:48 <lysgaard> Baughn: I think I'll use Integer, easier since it's an instance of almost evenything
14:01:00 <lilac> glguy: i don't follow what you mean by 'in any one direction'
14:01:33 <lilac> also 'after the first time' :)
14:01:49 <glguy> in two dimensions with lists, I mean: concat $ takeWhile (not . null) $ map (takeWhile myPredicate) $ searchSpace
14:02:34 <glguy> the function increases monotonically in all three of its arguments
14:02:59 <glguy> and I'm looking for values below one size
14:03:05 <lilac> hmm. so if predicate is false for (x,y,z) then it's false for (x,y,z+k) and if it's false for (x,y,0) then it's false for (x,y+k,0)?
14:03:15 <glguy> yeah
14:03:27 <dolio> Hmm...
14:03:31 <glguy> I'm just wondering if there is some "pretty" or "intended" way to do this
14:03:39 <glguy> I've already done it in an ugly way :)
14:05:48 <glguy> I tried to capture "if this value produces no results, don't bother going on to the next one" in my paste
14:06:02 <glguy> but I seem to be missing something, as it is generating a lot of duplicates
14:06:17 <jfoutz> and [x<=y,y<=z] ?
14:06:22 <kyagrd> Has anyone tried using quickcheck for testing a property that is a nested implecation? e.g. (A ==> B) ==> C
14:07:22 <kyagrd> The problem with (==>) in quickcheck is that its type is Testable prop => Bool -> prop -> Property  rather than Testable prop => prop -> prop -> Property
14:08:00 <kyagrd> I'm wondering what's the trick to to do this kind of thing ...
14:10:03 <dolio> glguy: Well, I think the duplicates may come from progression.
14:10:36 <wffbot> \leave
14:10:57 <dolio> glguy: thenClause happens one time for every time (f n) succeeds.
14:11:04 <glguy> ahh
14:11:07 <glguy> right
14:11:19 <dolio> And each one contains 'progression (n + 1)'
14:14:26 <dolio> glguy: You might try "ifte (once (f n)) thenClause mzero".
14:15:27 <glguy> now it loses some results :)
14:16:31 <Dirrk> glguy: sorry, I joined the channel in between, and didn't get the whole problem. Do you want all (x,y,z) below some limit?
14:17:25 <glguy> I'm generating triangles with sides x y and z, and I know my generator generates larger triangles given larger inputs
14:17:34 <dolio> glguy: Oh, right. What if you also turn 'return r' into 'f n' in thenClause.
14:17:35 <glguy> and I wanted to make all of the triangles below a certain perimeter
14:17:55 <Dirrk> glguy: why not use a priority queue, and spread out "diagonally"?
14:18:09 <Dirrk> glguy: that will generate solutions of increasing size.
14:18:31 <glguy> Dirrk: because it doesn't ever stop generating them
14:18:41 <glguy> and you can't tell when you've seen the last small triangle
14:19:09 <Dirrk> glguy: But you want all below some limit. So just take all below the limit out of the priority queue, and the stop.
14:19:28 <glguy> dolio: that seems to do it
14:19:39 <Dirrk> glguy: the priority queue will make sure all other solutions are larger.
14:20:13 <glguy> Dirrk: the other constraint was to try doing it within logict
14:20:34 <glguy> I know how to write it outright
14:20:39 <Dirrk> glguy: why that constraint?
14:20:52 <dolio> Because logict is awesome?
14:20:56 <glguy> makes it prettier
14:21:05 <glguy> easier to follow the logic, ideally
14:21:19 <glguy> that a nested mix of list manipulation functions :)
14:22:36 <Dirrk> glguy: might be a matter of taste, but I think "spreading out" is easier to follow and more "symmetric" than LogicT.
14:22:47 <glguy> ok
14:22:47 <Dirrk> glguy: But of course it's up to you :-)
14:26:07 <lilac> glguy: do you know that predicate (x,y,z) == False implies that predicate (x+j,y+k,z+m) is False
14:26:22 <lilac> or just that it implies that predicate (x,y,z+k) is False?
14:26:30 <glguy> lilac: both
14:26:54 <glguy> increasing any of the parameters will increase the perimeter in this case
14:27:10 <lilac> ok, that sounds more tractible :)
14:30:00 <lilac> glguy: somewhat esoteric suggestion: make your computation produce as a side-effect a 3-tuple (maxX, maxY, maxZ) of the max coords where the predicate was True as lazy naturals, then iterate over [0..S maxX], [0..S maxY], [0..S maxZ]
14:30:02 <dolio> glguy: Sorry about not answering your /msg, by the way. I never notice those.
14:30:10 <glguy> dolio: I assumed as much
14:30:16 <glguy> so I took to the channel :)
14:31:40 <lilac> glguy: combine that with logict if you like :)
14:32:26 * lilac worships at the church of knot tying with lazy naturals
14:42:41 <lysgaard> How would you define a expression in Haskell terms?
14:43:44 <Saizan> can you clarify?
14:45:05 <lysgaard> My compiler is asking saying that an do construct needs an expression at the end. So i was wondering, what _exactly_ defines an expression?
14:45:34 <copumpkin> oh, not a <- or a let
14:45:59 <tibbe_> we really need a better name than "iteratee" for the function `f` in `fold f z xs`
14:46:02 <tibbe_> any suggestions?
14:46:17 <lilac> catamorphette?
14:46:35 <copumpkin> I'd call it dogamorphism
14:46:37 <Philippa> the cons function?
14:46:42 <Philippa> (as in, replacement for cons)
14:46:50 <Philippa> similarly, z is the nil function
14:46:54 <c_wraith> accumulation function?
14:46:57 <jfoutz> who are you writing for? worker could be plausible
14:47:05 <tibbe_> iteratee is to hard to pronounce
14:47:05 <Philippa> I tend to actually write it fold cons nil xs, myself
14:47:22 <tibbe_> Accumulator? it sounds like a value
14:47:44 <tibbe_> I need it for a type alias: type ??? = a -> b -> a
14:47:46 <rocketman> yeah I do the same as Philippa
14:48:03 <tibbe_> I usually name it 'f' in the definition but that's not a good type name
14:48:31 <lysgaard> This is probably wery simple, but i don't get how to fix this error.. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7603#a7603
14:48:33 <c_wraith> You could call it a Visitor, and really confuse anyone looking at your code
14:48:34 <lilac> If I could write "let sum = foldr (:) [] where a:b = a + b; [] = 0" I probably would.
14:48:42 <rocketman> &  foldMaybe maybe nothing  etc
14:48:44 <lilac> but only once :)
14:49:14 <rocketman> oops I meant justa
14:49:16 <PeakerWork> lilac: why? :)
14:49:18 <lilac> tibbe_: reducer?
14:49:37 <tibbe_> lilac: yes that wouldn't be so bad, if fold was only called reduce...
14:49:38 <lilac> PeakerWork: i like the cuteness of it as a set of rewrite rules :)
14:49:49 <c_wraith> lysgaard:  It's not entirely clear what you mean to do there.
14:50:04 <c_wraith> I think you want a case statement or something.
14:50:08 <lilac> tibbe_: well then the natural adaptation would be 'folder'
14:50:24 <lysgaard> c_wraith: I'll do a rewrite, just a sec.
14:50:28 <tibbe_> lilac: hmm, good point
14:50:39 <tibbe_> lilac: except for the overloading
14:50:40 <lilac> foldr :: FoldingFunction a b -> b -> [a] -> b?
14:50:50 <tibbe_> combiner?
14:51:30 <jfoutz> c_wraith: add a return () to each of your do statements
14:51:55 <c_wraith> jfoutz:  That's not to me. :)
14:52:07 <jfoutz> ha. oops.
14:52:23 <jfoutz> i need a typechecker for my irc.
14:52:59 <lilac> jfoutz: add a return () to each of your do statements :: Advice -> Newbie
14:53:08 <lilac> jfoutz: type error unifying Newbie with c_wraith
14:53:31 <lysgaard> c_wraith: Done, take a look at it now. Clarified some things
14:53:33 <c_wraith> I'm...  all of one step up from Newbie.  Not that it's clear to me what one step up from that is. :)
14:54:31 <c_wraith> lysgaard:  I think that's actually an indentation error.
14:54:34 <lilac> lysgaard: i think the 'case' needs to be indented to line up with 'tag <-'
14:54:56 <c_wraith> That's one of the more annoying things in haskell.
14:55:50 <lysgaard> Haha, you guys where right, silly me :S
14:56:04 <c_wraith> To avoid that specific error, I usually start a new line immediately after a "do"
14:56:12 <lilac> i do quite like the idea of allowing | ... inside a do block :)
14:56:46 <lysgaard> lilac: Is the | possible?
14:57:17 <lilac> lysgaard: as a potential extension, yes. as an already-implemented extension, no, i don't think so
14:57:34 <Philippa> lilac: H98 guard, or the sort with lots of extra matching?
14:57:38 <lysgaard> I like the | char so much, cleanest conditions in any language
14:57:46 <lilac> Philippa: extra matching enabled by PatternGuards, i think
14:58:04 <lilac> Philippa: though i dislike the idea of <- inside a 'do' not being some kind of unwrapping
14:58:50 <lilac> do x <- | y < 10 = f y | otherwise = putStrLn "Too big" >> return 0
14:59:29 <Philippa> that's a substantial extra extension, no?
14:59:39 <Philippa> not just guards, but in effect multiple patterns
15:00:06 <lilac> shorthand for do x <- let tmp | y < 10 = f y | otherwise = putStrLn "Too big" >> return 0 in tmp
15:00:53 <lilac> and likewise do | x < 3 = putStrLn "Hello" | otherwise = putStrLn "World"
15:01:05 <lilac> shorthand for do let tmp | x < 3 = putStrLn "Hello" | otherwise = putStrLn "World" in tmp
15:03:08 <lilac> it's all sorts of ambiguous at the top level :-(
15:04:05 <CalJohn> i quite like the way erlang uses guards, it's a nice way of allowing branching anywhere.  i suppose it would be less useful in haskell, perhaps
15:04:31 <lilac> CalJohn: what's the Erlang way?
15:06:29 <CalJohn> lilac: you can basically branch on anything using the keyword "then"
15:06:45 <CalJohn> using it like a case statement is semi-common
15:18:37 <lilac> i'd like to add a GHC extension which transforms: "f ::~ [a] -> a; f = ..." into "f | False = undefined :: [a] -> a | otherwise = ..."
15:18:57 <lilac> is there a better syntax for that?
15:19:21 * lilac ponders ~:: and ::?
15:19:41 <dolio> Why?
15:19:41 <Badger> heh
15:19:51 <Badger> ~:: - is approximately of the type...
15:20:13 <lilac> dolio: so you don't need to give (potentially quite long) type class contexts
15:20:25 <lilac> Badger: that's the idea
15:21:14 <lilac> i think ~:: is my favourite of the three
15:21:14 <Badger> how curious
15:21:33 <dolio> I don't understand how this changes type-class contexts.
15:21:49 <lilac> @type f | False = undefined :: [a] -> a | otherwise = sum
15:21:50 <lambdabot> parse error on input `|'
15:22:01 <lilac> @type let f | False = undefined :: [a] -> a | otherwise = sum in f
15:22:02 <lambdabot> forall a. (Num a) => [a] -> a
15:22:18 <dolio> Oh, okay.
15:22:41 <sjanssen> lilac: why not infer the entire type?
15:22:57 <dolio> @type let f = sum in f
15:22:58 <lambdabot> forall a. (Num a) => [a] -> a
15:23:30 <lilac> sjanssen: for documentation, to get error messages in the right place, and to narrow down the type of something more general
15:23:32 <athos> @type let f | False = undefined | otherwise = sum in f
15:23:34 <lambdabot> forall a. (Num a) => [a] -> a
15:23:48 <lilac> @let f | False = undefined :: [a] -> Int | otherwise = sum in f
15:23:48 <lambdabot>   Parse error
15:23:49 <dolio> I was overlooking that it eliminated the type signature in the translation.
15:23:52 <lilac> @let let f | False = undefined :: [a] -> Int | otherwise = sum in f
15:23:53 <lambdabot>   Parse error
15:23:59 <lilac> @type let f | False = undefined :: [a] -> Int | otherwise = sum in f
15:24:00 <lambdabot> [Int] -> Int
15:24:04 <lilac> brain fail :(
15:24:50 <sjanssen> lilac: the translation is a bit more complicated if the function has arguments
15:24:50 <lilac> i guess it's technically a subtype annotation (the type of this is some supertype of this type)
15:26:06 <lilac> sjanssen: agreed. something like: "f ::~ [a] -> a; f x = ..." ~> "f | False = undefined :: [a] -> a | otherwise = let f x = ... in f"
15:42:03 <lysgaard> Is there a way to typecheck for a emyty ByteString, like [] typechecks for a empty String
15:43:19 <Saizan> typechecking?
15:43:39 <Saizan> in which way is [] typechecking?
15:44:17 <Saizan> ?type Data.ByteString.empty -- there's this
15:44:19 <lambdabot> BSC.ByteString
15:44:45 <lysgaard> Thanks =)
15:44:46 <pikhq> [] is not specifically an empty String. [] is an empty List of some type.
15:45:05 <Philippa> Saizan: I assume there's also equality?
15:45:18 <pikhq> @type []
15:45:19 <lambdabot> forall a. [a]
15:45:34 <Philippa> pikhq: you can infer that it /was/ an empty String from the context
15:45:39 <idnar> an empty list of /all/ types, surely?
15:45:45 <mike-burns> > [] :: [Char]
15:45:46 <lambdabot>   ""
15:45:50 <Philippa> you don't pattern match polytypes
15:46:05 <Philippa> lysgaard: it "pattern matches", "empty string" isn't a type as such
15:46:11 <Philippa> lysgaard: it's not subtyping like in OO
15:46:36 <lysgaard> Next Q: Is there a socket opperation that works like Network.Socket.sendTo but instead of a string takes a bytestring?
15:47:00 <pikhq> idnar: No, it is an empty list of /a/ type. That that type may not be defined within that function is beside the point. ;)
15:47:02 <lysgaard> Philippa: Yeah, I guess I'm mixing typecheck and patternmatch :S
15:47:50 <pikhq> lysgaard: Type checking prevents you from adding 2 to "fish".
15:47:56 <pikhq> Quite different from pattern matching. ;)
15:49:14 <lilac> > let null :: forall a. [a]; null = [] in (1:null, 'x':null) -- pikhq, it's an empty list of all types there
15:49:15 <lambdabot>   ([1],"x")
15:49:19 <Philippa> pikhq: actually, it'll only be an empty list once you've told it what type to be :-)
15:50:13 <pikhq> lilac: Nope, it's a list of a type. That the type it's of is polymorphic is a moot point. :P
15:50:19 * lilac thinks the semantic distinction between "empty list of all types" and "lambda from type to empty list of that type" is zero
15:50:42 <rocketman> semantic means nothing
15:51:04 <PeakerWork> rocketman: ??
15:51:15 <PeakerWork> rocketman: what do you mean?
15:51:22 <rocketman> semanticsemantic semantic semantic semantic semantic semantic
15:51:23 <pikhq> Saying it's an "list of all types" would mean ["foo", 2] would be a valid list. Which of course it isn't.
15:51:27 <rocketman> now it means less than nothing
15:51:44 <lilac> pikhq: ah, it's a parenthesizing problem. i mean, forall types T, it's a list of T.
15:52:17 <lilac> but it's also a list of (forall types T, T)
15:52:20 <pikhq> And i'm interpreting that to mean that it's a list of T, where T is a type.
15:52:37 <lilac> what it's not is a list of (exists type T, T), which is what you're inferring
15:52:55 <lilac> pikhq: but it is that. T is /a/ type, not /all/ types
15:53:41 <lilac> which is to say, i agree there are ways of interpreting 'an empty list of all types' which are true and ways which are false ;-)
15:54:31 <lysgaard> @hoogle ByteString -> String
15:54:31 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
15:54:31 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
15:54:31 <lambdabot> Prelude show :: Show a => a -> String
15:59:54 <Saizan> the difference between forall (a :: *). T a and \a::* -> T a always seems so arbitrary to me, it's like forall is only there to go from kind * -> * to *
16:01:26 <idnar> pikhq, lilac: okay, how about "an empty list of /any/ type"?
16:01:45 <idnar> "an empty list of some type" sounds like exists T. [T] to me
16:01:49 <pikhq> idnar: Valid phrasing.
16:06:16 <jeffwheeler> Woah, GHC 6.10.4 is in Debian Sid? I feel like an idiot for having compiled it myself last night, then. That's awesome!
16:07:02 <iago> jeffwheeler, why do you had to compile it?
16:07:06 <iago> there is a binary version
16:07:30 <jeffwheeler> iago: because the binary version for amd64 crashed, and I didn't feel like figuring out why
16:07:36 <jeffwheeler> iago: probably missing library dependencies
16:09:08 <iago> oh
16:10:28 <jeffwheeler> Wow, and the latest gtk2hs is all packaged nicely, too. Go Haskell-Debian!
16:10:43 <mike-burns> Whoa. I'm jealous.
16:11:09 <badsheepy> :O
16:12:11 <badsheepy> i gave up installing gtk2hs due to lazyness and ineptitude :(
16:12:13 <jeffwheeler> I wonder what the status in Karmic (Ubuntu) is.
16:12:25 <badsheepy> inaptitude somewould say :O
16:12:39 <jeffwheeler> badsheepy: hehe
16:13:05 <Berengal> Karmic will get 6.10.{3,4}
16:13:12 <Berengal> But by then 6.12 is out...
16:13:36 <jeffwheeler> Berengal: How quickly will the Sid packages reflect GHC/Hackage?
16:13:55 <Berengal> jeffwheeler: I don't know. I'm not really into pokemon...
16:13:55 <jeffwheeler> And can I try packaging some? I think having Yi on there would be neat.
16:14:09 <jeffwheeler> Berengal: I mean Debian Unstable (Sid)
16:14:10 <lilac> Berengal: 6.10.4's already in the Karmic repo, looks like
16:15:09 <Berengal> jeffwheeler: Yeah, I understood that, I just don't know much about debian packages at all. I use cabal for all my packaging needs
16:15:28 <solrize> so is there a standard way to rewrite expression trees until they stop simplifying?  like i want to simplify (Add [Lit 2, (Add [Lit 3, Lit 5])]) to (Add [Lit 2, Lit 3, Lit 5]).  so  i have a bunch of rewrite rules that each perform some simplification, and i want to run all these rules, then run them again and again til they stop finding anything to simplify.  does that even sound reasonable?  it's just for a parser for user-written expressions, no
16:15:28 <solrize> ancy algebra system or anything like that.
16:15:47 <jeffwheeler> Berengal: ah, okay :)
16:16:21 <lilac> solrize: http://en.wikipedia.org/wiki/Beta_normal_form
16:16:38 <solrize> lilac, interesting , thanks
16:18:46 <rocketman> 'standard' .. no
16:18:46 <maxote> can 6.12 use packages from 6.10.4 and viceversa?
16:19:09 <Berengal> maxote: All ghc packages are binary incompatible, even betweeen minor versions
16:19:13 <sjanssen> maxote: packages are compiled against a specifc version of GHC
16:19:17 <rocketman> Beta NF applicable here?
16:19:20 <rocketman> how?
16:19:25 <maxote> grrrr
16:19:39 <lilac> depends on exactly what form the rewrite rules take
16:20:02 <rocketman> I think if it's not beta reduction on typed terms that doesn't apply
16:20:19 <ccasin> if I am writing a library which is an FFI interface to a C library that reads and writes a standard format for crossword puzzles, where in the module namespace does it belong?
16:21:24 <ccasin> the module hierarchy is a mystery to me
16:22:12 <ccasin> codec (since it reads/writes a binary data format) and data (since it represents data) seem plausible to me
16:22:30 <ccasin> unless there is a special place for FFI modules
16:22:31 <rocketman> well?
16:22:38 <rocketman> I'm curious how it applies
16:22:51 <rocketman> or it's just something different that isn't really about it
16:24:38 <jeffwheeler> ccasin: I like Data
16:25:07 <lilac> rocketman: typed terms? beta normal form applies to the untyped lambda calculus too
16:25:36 <rocketman> lilac, istr solrize asking about termination
16:26:11 <rocketman> it's only when typed that that rewrite system is normalizing
16:26:38 <lilac> rocketman: i don't. "run again and again until nothing simplifies" doesn't imply totality
16:26:55 <rocketman> what?
16:27:20 <lilac> i'm not going to argue this with you; i don't see i'll gain anything from it.
16:27:34 <rocketman> I'm not trying to argue with you
16:27:55 <rocketman> I was asking if you liked beta normal form because it's related or just randomly
16:28:09 <rocketman> I don't see how it's related and wishing you'd tell me
16:28:10 <ccasin> jeffwheeler: thanks!
16:28:16 <rocketman> linked*
16:28:37 <lilac> i don't think that's true, but i'm going home now anyway
16:28:51 <rocketman> you don't think what is true?
16:29:16 <rocketman> you think I'm just trying to argue with you because I have a grudge against beta normal form?
16:29:50 <rocketman> I guess what I should do is just not ask you things because being curious is really rude or something
16:30:39 <rocketman> lilac: I'm not saying 'you are wrong' I'm asking 'why don't I see the link'
16:31:49 <rocketman> lilac, you're an ass though for just walking off like that
16:33:32 <benmachine> :o rudeness
16:33:36 <fixp> can infix constructors not have alphanumeric characters in them, for instance the constructor :U: is not legal in haskell?
16:33:54 <rocketman> benmachine: yeah I found it v. rude
16:34:13 <mike-burns> fixp: It must be all punctuation to use it infix without backticks.
16:34:19 <rocketman> fixp, no, you must use `U`
16:34:28 * benmachine gives rocketman and lilac both a hug
16:34:33 <fixp> i see thank you
16:39:59 <PeakerWork> one can represent existential types (only known at run-time) with Rank-2/Rank-N types, or only with ExistentialQuantification?  For example,  isn't  forall a. Cont r a   basically an existential/run-time-known-only type?
16:40:16 <Plouj> ok, which of you guys are in #opengl?
16:40:23 <Plouj> own up please :)
16:41:13 <Phyx-> hmm i remember someone talking about making ghc generate ARM code, anyone know how that turned out?
16:41:34 <Saizan> PeakerWork: right, (forall a. a -> r) -> r is the church encoding of existential types
16:41:58 <PeakerWork> Saizan: without all the "brain explosion" of ghc, right? :)
16:42:27 <PeakerWork> Saizan: without "exists a." escaping anywhere, that is
16:43:32 <Saizan> PeakerWork: oh, the typechecker will ensure that it won't escape in a way very similar to ExistentialQuantification, it's mostly a change of syntax at the term level
16:43:52 <Saizan> PeakerWork: you call the value with the continuation instead of using a case expression
16:43:57 <PeakerWork> Saizan: well, with ExistentialQuantification you have to worry about only using case, and not let, and various other stuff
16:44:46 <Saizan> PeakerWork: here you're forced to only pass the continuation, so i guess that might be seen as a plus
16:49:17 <Saizan> though the constructors help type inference and are probably more pratical if you're dealing with more than one existential value at a time
16:50:41 <mike-burns> Phyx-: Check out #haskell-iphone for people working on that. I think.
16:51:08 <PeakerWork> Saizan: just had a little argument with yairchu about whether ExistentialQuantification was needed in order to have non-known-types at compiletime, or whether Rank-2/Rank-N also have that effect
16:54:41 <Saizan> you win then :)
16:57:03 <Phyx-> mike-burns: ok, will do :) was thinking more ds myself then iphone though :P
17:00:39 <blueonyx>     let	myPath = myPath'	++ "/../" body <- readFile (myPath++"Test.hs")
17:00:52 <blueonyx> how can this be reduced to one line?
17:01:11 <blueonyx> oh no, its
17:01:11 <copumpkin> is there a semicolon in there?
17:01:13 <blueonyx> myPath' <- getCurrentDirectory
17:01:14 <copumpkin> seems like there must be
17:01:19 <blueonyx> letmyPath = myPath'++ "/../"
17:01:41 <dibblego> @type liftM2
17:01:42 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:01:56 <blueonyx> ah thanks
17:02:11 <dibblego> @type \k -> liftM2 k getCurrentDirectory (readFile "boo")
17:02:13 <lambdabot> Not in scope: `getCurrentDirectory'
17:02:14 <copumpkin> body <- readFile =<< (++"/../Test.hs") =<< getCurrentDirectory
17:02:38 <copumpkin> not sure if that'll actually work :P
17:02:45 <Saizan> body <- readFile . (++"/../Test.hs") =<< getCurrentDirectory
17:03:09 <copumpkin> oh yeah
17:06:01 <blueonyx> mh i just want the path, but  myPath <- (++ "/../") =<< getCurrentDirectory gives me Couldn't match expected type `[[Char]]' against inferred type `IO FilePath'
17:06:42 <Saizan> you want fmap there
17:06:56 <Saizan> myPath <- return . (++ "/../") =<< getCurrentDirectory
17:07:08 <Saizan> myPath <- fmap (++ "/../") getCurrentDirectory
17:07:15 <Saizan> those two are equivalent
17:07:34 <Saizan> the latter is generally preferred
17:07:49 <blueonyx> ah nice, thank you
17:08:14 <jfoutz> @src lift
17:08:14 <lambdabot> Source not found.
17:08:43 <Trinithis> @hoogle lift
17:08:43 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
17:08:43 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
17:08:43 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
17:08:56 <blueonyx> @src liftM
17:08:56 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:09:08 <LeoD> yea, liftM would work too here
17:09:17 <Trinithis> liftM == fmap
17:09:30 <Saizan> = <$>
17:09:33 <jfoutz> that's... neat or scary. not sure which.
17:09:38 <blueonyx> yea
17:09:51 <pikhq> liftM is fmap on the monads, and <$> is fmap on the applicative functors.
17:09:52 <pikhq> :)
17:10:02 <Saizan> <$> is fmap.
17:10:11 <LeoD> @src (<$>)
17:10:11 <lambdabot> f <$> a = fmap f a
17:10:24 <jfoutz> but if you just use fmap (or <$>) then you don't care?
17:10:30 <pikhq> Saizan: It is quite *literally* fmap on the applicative functors. :)
17:10:56 <blueonyx> but fmap is in the Prelude and <$> and liftM not :/
17:11:02 <Trinithis> @hoogle liftW
17:11:02 <lambdabot> No results found
17:11:07 <Saizan> pikhq: a bit misleading to say that.
17:11:23 <pikhq> @type (<$>)
17:11:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:11:46 <pikhq> No kidding; it's fmap on all the functors according to that.
17:12:06 <Saizan> yeah :)
17:12:31 <blueonyx> is there a less ugly way to get argv[0] than http://osdir.com/ml/glasgow-haskell-bugs@haskell.org/2009-04/msg00725.html ?
17:12:39 <Saizan> jfoutz: sometime you've to use liftM to not add a Functor context, because Functor is not a superclass of Monad
17:12:45 <pikhq> blueonyx: getProgName?
17:12:48 <kma> kell
17:13:01 <blueonyx> pikhq: there is the path missing
17:13:17 <pikhq> Mmm.
17:13:36 <jfoutz> Saizan: ahh. thanks.
17:14:08 <pikhq> Saizan: Which is itself quite silly. ;)
17:14:19 <LeoD> @type (<^)
17:14:20 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
17:14:25 <LeoD> where's that defined? :|
17:14:35 <LeoD> hoogle doesn't seem to know it
17:14:39 <pikhq> @hoogle (<^)
17:14:40 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
17:14:44 <dibblego> Control.Arrow iirc
17:14:51 <Saizan> infix-applicative iirc
17:14:57 <Saizan> ?hackage infix-applicative
17:14:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/infix-applicative
17:15:16 <Phyx-> @index (<^)
17:15:16 <lambdabot> bzzt
17:15:22 <Saizan> http://hackage.haskell.org/packages/archive/InfixApplicative/1.0.1/doc/html/Control-Applicative-Infix.html
17:15:27 <LeoD> ah, thanks
17:16:15 <Saizan> hayoo is nice when searching for identifier names
17:17:10 <Trinithis> What would I use to change text in a terminal?
17:17:43 <Trinithis> eg: for a terminal game
17:18:37 <Saizan> yi uses vty for its terminal UI
17:18:45 <Saizan> ?hackage vty
17:18:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vty
17:19:02 <jfoutz> vti rules!
17:19:03 <Trinithis> what is ncurses?
17:19:48 <Trinithis> Saizan: thdx
17:19:50 <Saizan> ncurses is a C library for terminal UIs, there's an haskell binding for it too
17:20:29 <Trinithis> ok
17:20:47 <fixp> is there no way to get Data.Map k v to take hetrogenous v? i have to make my own Map type i guess. am i missing something?
17:21:00 <jeffwheeler> Saizan: but the Gtk/Pango UI is so much more fun ;)
17:21:41 <bd_> fixp: How hetergenous? The usual way is to pick a v that contains whatever types you need - eg, data FooType = HoldsBar Bar | HoldsBaz Baz | HoldsQuux Quux
17:21:47 <bd_> fixp: then do Map k FooType
17:21:59 <fixp> hmm
17:22:17 <sjanssen> fixp: heterogenous collections are not idiomatic in Haskell
17:22:51 <fixp> sjanssen: although you can get somewhere with existensial types and type classes right?
17:23:01 <Saizan> jeffwheeler: is it? i never use graphic UIs for editors
17:23:16 <sjanssen> they're also not really possible -- any heterogenous collection will really be homogenous with some wrappers
17:23:17 <bd_> fixp: I suppose the real question is, what are you trying to do? Truly heterogenous collections are hardly ever seen in any language - how do you know if you have the right type, when you do a lookup?
17:23:17 <jeffwheeler> Saizan: for the first few minutes, until it becomes unbearably slow
17:23:39 <sjanssen> fixp: you can do that, but existentials are often more hassle than they're worth
17:23:40 <jeffwheeler> Don't tell, though.
17:23:44 <jfoutz> fixp: you can never go back. if you erase 1 down to something that's showable, you can print it, but never turn it back into a number.
17:24:02 <fixp> jfoutz: yes ive thought of that
17:24:34 <bd_> fixp: again, what are you really trying to do, that makes you think you need a heterogenous collection? There's probably a better, simpler way.y
17:26:59 <fixp> yeh was writing a relational algebra library (sorta). i was wondering if i could have hetrogenous attribute types.
17:27:42 <fixp> now the problem is getting tuple elements to have the type that correponds to the attribute type
17:28:12 <fixp> but yeh. ill have to think about this a little more it seems
17:28:35 <bd_> if all else fails there's Dynamic
17:28:40 <bd_> but avoid that at all costs
17:28:49 <bd_> as it brings up the question of what you do if you get the wrong type out
17:29:07 <fixp> bd_ heh, yes
17:29:12 <Saizan> also HList or variations on that, or a mix of the two :)
17:29:13 <jfoutz> fixp: one thing that's great about the algebraic representation is the ability to enforce mutualy exlusive constraits, or paired constraints.
17:30:25 <fixp> i was using a Map from Attributes to values to represent a Tuple in a relation, which is why I asked about Maps
17:31:28 <jfoutz> data Values = V (x,y,z)
17:31:50 <rocketman> what's x y and z
17:32:20 <jfoutz> we'll see when fixp answers :)
17:32:59 <fixp> jfouts: that's not what i had in mind. my notion of tuple is completely different from the Haskell tuple type
17:33:24 <fixp> its a tuple in a relation, and i have no idea how big this relation is going to be
17:33:39 <fixp> so i need at least a list for each tuple
17:35:11 <fixp> my initial implementation had "type Relation = [Map Attribute Value]" where type Attribute = String, type Value = String
17:35:12 <Saizan> fixp: you could look at the haskelldb package, it's designed as a richly typeful interface to relational databases, so it deals with these problems
17:35:13 <jfoutz> hrm. [("case1",[(1,1),(2,2)]), ("case2",[(4,4)])] but, not (String,[(Int,Int)])?
17:36:25 <fixp> Saizan: thanks saizan
17:44:56 <fixp> ah they use phantom types in haskellDB for the attributes :). i was gonna do that
17:47:36 <amckinley> hey, easy newbie question: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7607
17:47:37 <wolf1oo> i'm kinda new to haskell, but hit a wall with something I am trying to do. how would you go about using getLine a variable number of times?
17:48:21 <amckinley> im trying to pluck elements out of a list based on the constructor used to create them
17:49:20 <amckinley> what i wrote^^ works, but seems stupid. is there a better way to pattern match?
17:49:53 <Berengal> amckinley: Make a function 'isDnsPath (DnsPath _) = True; isDnsPath _ = false'
17:49:53 <Gracenotes> amckinley: if you want to end up with a list of Strings, the most straightforward way would probably be with the list comprehension trick, [ s | DnsPath s <- list ]
17:50:12 <Gracenotes> if you want a list of Flags, then.. filter function ^^
17:50:14 <Berengal> ... or use listcomprehension
17:50:38 <amckinley> Berengal: thats the same thing im doing, but with functions instead of lambdas :) isnt there a shortcut for writing those functions?
17:50:57 <Gracenotes> wolf1oo: variable number? So when do you decide how many there are..?
17:50:59 <amckinley> Gracenotes: oh, thats pretty cool :)
17:51:01 <Berengal> amckinley: The difference is your lambda will crash the program when it gets something that's not a DnsPath
17:51:03 <Axman6> amckinley: take is missing a parameter btw. it needs an Int
17:51:14 <amckinley> Axman6: whoops, thanks
17:51:17 <wolf1oo> Gracenotes: it decides from a previous getLine
17:51:38 <amckinley> Berengal: whoops, yeah, pattern match exception
17:51:58 <Gracenotes> ah, I see. Well, if you have an integer value, replicateM repeats a certain action a given number of times
17:52:08 <Gracenotes> @type replicateM
17:52:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:52:25 <Berengal> amckinley: And no, there's not really any easier way to write that function, except there may be some TH function lying around...
17:52:28 <Gracenotes> if you're dealing with IO and Strings, then it's: Int -> IO String -> IO [String]
17:52:33 <wolf1oo> i tried this but wasn't sure of its "legality": take n (repeat getLine)
17:53:09 <wolf1oo> hold on i'll paste a link to it, cause i also have to perform a function on each getLine
17:53:12 <Berengal> wolf1oo: It's not illegal to do that, but you need to sequence it afterwards
17:53:18 <Gracenotes> wolf1oo: replicateM effectively does that, but in a way such that the order of everything is preserved
17:53:22 <Berengal> Otherwise it's just a list...
17:53:31 <wolf1oo> Gracenotes: okay thanks i'll try that
17:53:36 <Gracenotes> and, well, so it fits with the Haskell IO scheme
17:53:46 <Gracenotes> it's imported from Control.Monad
17:54:22 <wolf1oo> well thats the thing, this is supposed to take a certain number of lines of numbers as input and return as http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Int where the internal lists are each line
17:54:34 <amckinley> Berengal: is there at least any way i can parameterize that function, so i dont have to write one for every type constructor?
17:55:42 <Berengal> amckinley: Afraid not...
17:56:01 <Berengal> Again, you might want to look into template haskell
17:56:10 <wolf1oo> whoops i meant [ [ Int ] ]
17:58:30 <Gracenotes> wolf1oo: here's a (useless) example case: do { putStrLn "How many lines to input?"; ans <- getLine; allLines <- replicateM (read ans) getLine; putStrLn ("You typed " ++ (show . length . concat $ allLines) ++ " characters.") }
17:58:37 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/new
17:58:42 <Berengal> Whoops
17:58:47 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7608#a7608
17:58:51 <Berengal> wolf1oo: ^^
17:58:58 <Berengal> Something like that works
17:59:37 <wolf1oo> okay
17:59:41 <wolf1oo> thats about what i just wrote haha
18:03:12 <Gracenotes> replicateM 0 action = return []; replicateM num action = do { result <- action; others <- replicateM (num-1) action; return (result:others) }
18:04:16 <dolio> replicateM n m = foldN (liftM2 (:) m) (return []) n
18:05:52 <rocketman> foldN o/
18:06:27 <Gracenotes> true that.
18:06:36 <LeoD> @type foldN
18:06:38 <lambdabot> Not in scope: `foldN'
18:06:43 <rocketman> foldN :: Awesome
18:06:52 <dolio> foldN :: (a -> a) -> a -> Natural -> a
18:06:52 <LeoD> @type foldM
18:06:53 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
18:08:18 <dolio> @yow!
18:08:18 <lambdabot> I am NOT a nut....
18:18:13 <gwern> so, I have a list of a..z, and I'd like to get every unique possible set of 10 (say); how would I go about this?
18:20:20 <aavogt> > replicateM 10 ['a'..'z']
18:20:21 <lambdabot>   ["aaaaaaaaaa","aaaaaaaaab","aaaaaaaaac","aaaaaaaaad","aaaaaaaaae","aaaaaaaa...
18:20:24 <gwern> this isn't quite the same thing as permutations... I suppose I could try generating every permutation of the master set, doing a 'take 10' on each, and then doing a sort/nub
18:20:29 <gwern> but that seems kind of inefficient
18:20:33 <gwern> even with laziness
18:20:40 <aavogt> > replicateM 2 ['a'..'z']
18:20:41 <lambdabot>   ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao"...
18:20:57 * jeffwheeler was just blown away
18:21:03 <gwern> > replicateM 3 [1, 5, 10, 3, 1, 11, 6]
18:21:04 <lambdabot>   [[1,1,1],[1,1,5],[1,1,10],[1,1,3],[1,1,1],[1,1,11],[1,1,6],[1,5,1],[1,5,5],...
18:21:12 <gwern> > replicateM 2 [1, 5, 10, 3, 1, 11, 6]
18:21:13 <lambdabot>   [[1,1],[1,5],[1,10],[1,3],[1,1],[1,11],[1,6],[5,1],[5,5],[5,10],[5,3],[5,1]...
18:21:22 <jeffwheeler> @type replicateM
18:21:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:21:25 <dolio> > let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) select xs ; get10 = runStateT . replicateM 10 (StateT select) in get10
18:21:26 <lambdabot>   Couldn't match expected type `[(d, [t])]'
18:21:34 <dolio> > let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) select xs ; get10 = runStateT . replicateM 10 (StateT select) in get10 ['a'..'z']
18:21:34 <gwern> > replicateM 2 $ nub $ sort [1, 5, 10, 3, 1, 11, 6]
18:21:36 <lambdabot>   Couldn't match expected type `[(d, [t])]'
18:21:36 <lambdabot>   [[1,1],[1,3],[1,5],[1,6],[1,10],[1,11],[3,1],[3,3],[3,5],[3,6],[3,10],[3,11...
18:21:50 <dolio> > let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) (select xs) ; get10 = runStateT . replicateM 10 (StateT select) in get10 ['a'..'z']
18:21:52 <lambdabot>   Couldn't match expected type `a -> a1'
18:21:58 <aavogt> > replicateM 3 ['a'..'c']
18:21:59 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
18:22:20 <Saizan> dolio: no composition
18:22:46 <gwern> what is dolio's supposed to do, anyway?
18:23:24 <Saizan> give you a set, i.e. without repetitions
18:23:33 <Saizan> let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) (select xs) ; get10 = runStateT . replicateM 10 (StateT  select) in get10 ['a'..'z']
18:23:43 <Saizan> > let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) (select xs) ; get10 = runStateT $ replicateM 10 (StateT  select) in get10 ['a'..'z']
18:23:51 <dolio> > let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) (select xs) ; get10 = evalStateT $ replicateM 10 (StateT select) in get10 ['a'..'z']
18:23:55 <lambdabot>   [("abcdefghij","klmnopqrstuvwxyz"),("abcdefghik","jlmnopqrstuvwxyz"),("abcd...
18:23:59 <lambdabot>   ["abcdefghij","abcdefghik","abcdefghil","abcdefghim","abcdefghin","abcdefgh...
18:24:11 <gwern> Saizan: wouldn't it be easier to nub the input? at least, I don't think I'm seeing any dupes that way
18:24:33 <Saizan> > replicateM 2 "abc"
18:24:34 <lambdabot>   ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
18:24:41 <Saizan> "aa" kind of repetition
18:25:10 <gwern> oh. hm. might still be easier to map a nub...
18:25:25 <Saizan> you'll get less elements
18:25:38 <Saizan> also, it's not like select is a complicated function..
18:26:21 <Saizan> though i'm not sure how lazy that get10 is
18:26:51 <dolio> > let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) (select xs) ; get10 = evalStateT $ replicateM 10 (StateT select) in get10 [1..]
18:26:52 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,11],[1,2,3,4,5,6,7,8,9,12],[1,2,...
18:27:01 <gwern>  let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) (select xs) ; get10 = evalStateT $ replicateM 10 (StateT select) in head $ get10 ['a'..'z', undefined]
18:27:13 <Saizan> pretty lazy :)
18:27:22 <gwern> > let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) (select xs) ; get10 = evalStateT $ replicateM 10 (StateT select) in head $ get10 ['a'..'z', undefined]
18:27:23 <lambdabot>   <no location info>: parse error on input `,'
18:27:37 <gwern> > let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) (select xs) ; get10 = evalStateT $ replicateM 10 (StateT select) in head $ get10 (['a'..'z'] ++ [undefined])
18:27:39 <lambdabot>   "abcdefghij"
18:29:28 <aavogt> @type evalStateT
18:29:29 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
18:29:46 <shepheb> anyone know of a Haskell library that'll do shell-style splitting up commands into words with quoting and so on?
18:30:37 <solrize> parsec?
18:30:55 <gwern> shepheb: if you just want a String -> String which does shell escape, I vaguely recall HSH having something along those liens
18:31:45 <shepheb> gwern: nah, String -> [String]
18:32:22 <shepheb> that'll turn foo "bar baz" qu'ux' into ["foo","bar baz", "quux"]
18:33:32 <dolio> Anyhow, you can do...
18:33:48 <dolio> > filter (ap (==) nub) . replicateM 10 $ ['a'..'z']
18:33:54 <lambdabot>   mueval-core: Prelude.read: no parse
18:33:54 <lambdabot>  mueval: ExitFailure 1
18:33:56 <dolio> But that's a lot of extra work.
18:34:00 <gwern> qu'ux'?
18:34:38 <gwern> f'tgahn ry'leh...
18:34:38 <aavogt> so like getArgs
18:36:29 <dolio> > filter (ap (==) nub) . replicateM 6 $ ['a'..'z']
18:36:31 <lambdabot>   ["abcdef","abcdeg","abcdeh","abcdei","abcdej","abcdek","abcdel","abcdem","a...
18:36:40 <dolio> > filter (ap (==) nub) . replicateM 8 $ ['a'..'z']
18:36:45 <lambdabot>   mueval-core: Prelude.read: no parse
18:36:45 <lambdabot>  mueval: ExitFailure 1
18:36:56 <dolio> That's failing because it's not fast enough. :)
18:38:32 <dolio> For 7, to find the first admissable element, you need to throw out around 6! elements, I think.
18:39:16 <dolio> Go through everything that begins with "aa", then "abb", then "abcc", etc.
18:40:13 <Trinithis> > permutation [1..3]
18:40:14 <lambdabot>   Not in scope: `permutation'
18:40:29 <Trinithis> > permutations [1..3]
18:40:31 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
18:41:58 <dolio> You're looking for n`choose`k elements by filtering through n^k possibilities.
18:42:51 <gwern> n`choose`k? this a standard big O?
18:43:28 <dolio> > let fact n = product [1..n] ; choose n k = fact n `div` (fact k * fact (n - k)) ; density n k = (n^k) `div` (n `choose` k) in density 26 10
18:43:29 <lambdabot>   26576456
18:44:08 <dolio> n `choose` k is the number of ways of choosing k elements from an n-element set.
18:45:07 <Saizan> the good old binomial coefficient
18:45:17 <dolio> That too.
18:45:31 <gwern> I am but a simple programmer; what's the big o of n`choose`k?
18:46:05 <inimino> Oleg had a nice implementation of that using a lazy Pascal's triangle
18:46:24 <dolio> Anyhow, as you can see, for choosing 10 letters from a 26-letter set by filtering out of replicateM 10 ['a'..'z'], you're throwing away 26 million values for every one you keep.
18:46:26 <rocketman> Oleg is a wizzzard
18:46:37 <fhsanches> gwern, I'm not a native speaker, but I believe it's the first one, in chOose.
18:47:10 <Trinithis> choose I would think has the same complexity of factorial
18:47:14 <gwern> hm. surely it's not O(n)? that seems implausibly efficient even to me
18:47:57 <bremner> gwern:  no, not O(n) more like O(n^k), but a bit smaller iirc
18:48:02 <Trinithis> nCr = n! / (r! (n - k)!)
18:48:52 <c_wraith> bremner, that can't be right, since nCk = nC(n-k)
18:49:05 <dolio> > let fact n = product [1..n] ; choose n k = fact n `div` (fact k * fact (n - k)) ; density n k = (n^k) `div` (n `choose` k) in map (choose 26) [1..]
18:49:06 <lambdabot>   [26,325,2600,14950,65780,230230,657800,1562275,3124550,5311735,7726160,9657...
18:49:09 * bremner is too sleepy to work it out.
18:49:28 <Trinithis> choose is linear or better
18:49:58 <dolio> > let fact n = product [1..n] ; choose n k = fact n `div` (fact k * fact (n - k)) ; density n k = (n^k) `div` (n `choose` k) in ap (zipWith (flip div)) tail $ map (choose 26) [1..]
18:49:59 <lambdabot>   [12,8,5,4,3,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,* Exception: divide b...
18:50:15 <bremner> Trinithis: eh? to compute it, or the growth of the function
18:50:23 <Trinithis> computer
18:50:25 <Trinithis> copute*
18:50:29 <Trinithis> achk
18:50:40 <bremner> oh, well, only if your input is unary
18:51:34 <dolio> > let fact n = product [1..n] ; choose n k = fact n `div` (fact k * fact (n - k)) ; density n k = (n^k) `div` (n `choose` k) in map (flip choose 10) [1..]
18:51:35 <lambdabot>   [0,0,0,0,0,0,0,0,0,1,11,66,286,1001,3003,8008,19448,43758,92378,184756,3527...
18:51:48 <Trinithis> http://en.wikipedia.org/wiki/Factorial#Rate_of_growth
18:52:30 <c_wraith> the algorithm is going to have to be in terms of M
18:52:45 <c_wraith> (which is the complexity of integer multiplication)
18:53:34 <c_wraith> which just means the whole thing is a mess.
18:54:27 <Saizan> toTC :: (Ord a, Read a, Show a, Typeable a, Ord t, Read t, Show t, Typeable t) => a -> t -> DynamicC TargetCxt <- now i'd like typeclass aliases
18:54:45 <c_wraith> it means there will be terms like log (log (log n)))
18:54:52 <dolio> Well, for fixed k, nCk ~ n!/(n-k)!.
18:55:21 <dolio> Which is n*(n-1)*(n-2)*...*(n-k+1).
18:55:27 <dolio> Which is roughly n^k?
18:55:44 <dolio> O(n^k)
18:56:38 <bremner> well when k=n/2 is of course when the whole thing is maximized
18:57:03 <dolio> Maximized for a given n.
18:57:11 <bremner> jah :)
18:57:37 <dolio> k isn't increasing with n in gwern's algorithm, though.
18:57:42 <dolio> Presumably.
18:57:51 <gwern> k is fixed, yah
18:58:05 <gwern> set at startup and never changed; so far anyway
18:58:29 <Trinithis> what are you even coding?
18:58:31 <dolio> Anyhow, the moral is that using select is O(n^k) just like using the filter solution, but the latter does O(n^k) more work, or something like that. :)
18:58:40 <gwern> Trinithis: http://jtauber.com/blog/2008/02/10/a_new_kind_of_graded_reader/
18:58:41 <dolio> So complexity classes are useless. :)
18:59:39 <gwern> Trinithis: the idea is to take a list of words the user knows, and search a corpus, looking for 10, say, words which will turn the most sentences into fully-translatable sentences, and then the student/user learns those 10, re-runs the algorithms with those 10 added to the list, and so on
19:00:09 <Trinithis> huh
19:00:20 <gwern> right now I'm up to the bit where I compare the list of known words to the possible permutations
19:01:17 <gwern> which leads to the problem that if I have [a, b, c d], and [d, b, a, c], and I want a True, how do I do that (equality under permutation)? I could sort both and do a == or a null $ \\, or maybe do a 'length x == union x y'
19:02:12 <gwern> can't help but feel maybe somewhere I ought to be working with sets and not lists
19:02:24 <Trinithis> I was just thinking of that
19:02:34 <Trinithis> what about binary search trees?
19:02:44 <cjs> There's no way to make a function that could reasonably accept either a Fractional or an Integral and do something with them, is there?
19:03:10 <gwern> cjs: sure there is
19:03:22 <gwern> I think. hm
19:03:25 <cjs> Really? How? It seems if I make a type class, that doesn't help.
19:03:40 <gwern> my current code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7612 if anyone is curious
19:03:48 <cjs> I would still have to create an instance for every member of those classes, wouldn't I?
19:06:04 <Trinithis> and you are stuck on generatePossibilities?
19:06:30 <gwern> Trinithis: no, that seems fine
19:07:02 <gwern> I'm working on how to combine pcorpus and possiblewords, and extract the sublist of possiblewords with the highest score
19:17:39 <Phyx-> i still don't understand why ghc (sometimes) reports "foreign export stdcall foo :: CInt -> CInt
19:17:42 <Phyx-> " as invalid
19:20:48 <gwern> @src maximum
19:20:48 <lambdabot> maximum [] = undefined
19:20:48 <lambdabot> maximum xs = foldl1 max xs
19:20:53 <gwern> @src max
19:20:53 <lambdabot> max x y = if x <= y then y else x
19:21:13 <gwern> > (2,'b') < (3,'c')
19:21:14 <lambdabot>   True
19:23:48 <keseldude> ?src Complex
19:23:48 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
19:23:51 <Phyx-> dons: well i'll be, making haskell libs really isn't half bad as I thought
19:24:59 <keseldude> What are the exclamation points doing in that data definition?
19:25:23 <gwern> bang marks; make it strict
19:25:26 <Phyx-> keseldude: makes it strict
19:25:31 <keseldude> ah
19:36:58 <ccasin> I'm having trouble getting bindings generated by c2hs to compile
19:37:18 <ccasin> well, that's not true - the bindings compile fine, but when I compile a module that uses them, I get undefined reference linker errors
19:37:37 <ccasin> even though I've explicitly included the path to the library in the ghc command
19:37:43 <ccasin> any thoughts on what might be going wrong?
19:37:51 <ccasin> (I'm sure it's something silly on my end)
19:50:22 <zoheb> So I am trying to learn about monad transformers starting with this post http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html
19:50:43 <zoheb> And I wrote some test code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7614#a7614
19:51:04 <zoheb> here test3 and test4 have different types
19:51:32 <zoheb> inspite of the fact that their body is identical because of the way they are invoked
19:53:12 <zoheb> Can anyone point me to simple examples not involving Monads that show why types cannot be inferred without a corresponding invocation
19:53:44 <zoheb> basically I am trying to understand what language feature is being used by Monad Transformers
19:53:45 <Phyx-> hmm seems the dll generated by ghc is invalid
19:54:17 <Phyx-> "An attempt was made to load a program with an incorrect format. (Exception from HRESULT: 0x8007000B)"
19:54:48 <jfoutz> zoheb: (\x -> x) ?
19:55:37 <zoheb> No, thats different
19:55:44 <Cale> zoheb: test3 should get a polymorphic type
19:55:47 <zoheb> \x->x compiles
19:56:07 <zoheb> whereas my test3 fn does not compile unless there is a go fn
19:56:10 <Cale> zoheb: Probably the monomorphism restriction applies
19:56:32 <Cale> Try adding {-# LANGUAGE NoMonomorphismRestriction #-} to the top of the file
19:56:48 <nick-m> has anyone been able to successfully get the haskell plugin for e-texteditor from svn recently?
19:56:55 <zoheb>  am trying this out in ghci btw
19:57:41 <zoheb> yes that fixed that!
19:58:16 <Cale> test3
19:58:16 <Cale>   :: (MonadState [Char] m,
19:58:16 <Cale>       MonadTrans t,
19:58:16 <Cale>       MonadState s (t m),
19:58:16 <Cale>       Num s) =>
19:58:16 <Cale>      t m (s, [Char])
19:58:36 <zoheb> Thanks Cale!
19:58:51 <Cale> You could also just add this type signature
19:59:03 <Cale> (but it's admittedly somewhat complicated)
19:59:06 <zoheb> thx
19:59:52 <Cale> The MR is really silly, I almost always end up turning it off, and I don't think I've ever written a program where it helped.
20:02:13 <cornmaze> hello all, I am trying to write a regular expression parser in haskell
20:02:21 <cornmaze> my code is at: http://pastebin.com/m7f8d9ff5
20:02:34 <cornmaze> i am getting type errors on line 18
20:02:46 <lpsmith> cale:  i find the MR much more helpful in GHCi than the language itself
20:03:08 <cornmaze> the error is: Couldn't match expected type `[(RE, String)]'
20:03:08 <cornmaze>            against inferred type `Parser RE'
20:03:14 <lpsmith> and more painful too... :-/
20:03:58 <cornmaze> i don't know what to do to fix this, anyone have any ideas
20:04:25 <Cale> cornmaze: The problem is the  chparse +++ cparse +++ sparse  is a Parser
20:04:34 <Cale> when it seems that it ought to be a list
20:04:42 <Cale> (like [] is)
20:05:24 <Cale> cornmaze: Are you sure that you don't just want  reparse = chparse +++ cparse +++ sparse  ?
20:06:19 <cornmaze> Cale, i thought that since each parser in chparse +++ cparse +++ sparse should return a list, these would be evaluated to list
20:06:38 <Cale> (+++) :: Parser a -> Parser a -> Parser a
20:06:43 <cornmaze> Cale, i mean, the types would be considered list
20:06:50 <Cale> So whatever it is, it's got to be a Parser a and not a list
20:06:56 <zoheb> No they would just be Parser a
20:07:01 <Cale> It turns out to be a Parser RE
20:07:11 <Phyx-> oh, it's generating 32bits dll
20:07:19 <Cale> Since each of chparse, cparse and sparse are Parser RE's
20:07:33 <cornmaze> Cale, i can't replace the reparse with what you suggested because it must terminate when the input ends
20:07:43 <Cale> cornmaze: hm?
20:07:54 <Phyx-> can ghc generate 64bit shared libs?
20:08:01 <zoheb> what you need to do is pass inp to chparse
20:08:06 <Cale> cornmaze: All that the current code says is that if the regular expression is completely empty, then it should fail to parse
20:08:21 <zoheb> and coax it into a list and that should work
20:08:40 <Cale> cornmaze: you can make it typecheck by having
20:09:13 <Cale> other -> parse (chparse +++ cparse +++ sparse) other
20:10:31 <cornmaze> Cale, thanks that fixed my type error
20:10:55 <Cale> Perhaps what you *really* want is  reparse = return EmptyString +++ chparse +++ cparse +++ sparse
20:11:00 <Cale> er, no
20:11:26 <Cale> mm... you'd want a way to check for the empty input
20:11:28 <cornmaze> Cale, yea that was my idea at first but i spoke to my professor about it and it creates some illegal cases
20:11:59 <Cale> oh well, your current code is close
20:12:12 <cornmaze> Cale, lol thanks :S
20:12:12 <Cale> [] -> [(EmptyString,"")]
20:12:26 <Cale> (inside the 'case inp of')
20:12:47 <Cale> You probably don't want the parse to fail when the regexp is empty like that
20:13:10 <Cale> However, a nicer way would be to have a way to check that the input is empty
20:13:54 <Cale> eof = P (\inp -> case inp of [] -> [((),[])]; (x:xs) -> [])
20:14:21 <Cale> eof :: Parser () -- it succeeds only when there are no characters left
20:14:40 <Cale> Then you could write it as:
20:14:59 <Cale> reparse = (eof >> return EmptyString) +++ chparse +++ cparse +++ sparse
20:15:37 <cornmaze> Cale, thanks that is awesome
20:15:44 <Cale> In turn, it would be possible to break eof down into simpler parser combinators...
20:16:40 <Cale> lookAhead :: Parser String; lookAhead = P (\inp -> [(inp,inp)])
20:16:52 <Cale> guard :: Bool -> Parser ()
20:17:00 <Cale> guard False = failure
20:17:05 <Cale> guard True = return ()
20:17:35 <cornmaze> Cale, I made those changes you suggested and the first type error is gone, however, the basic parsers are of type Parser Char and I'm getting errors when I try to use one of these parsers inside of any Parser RE
20:18:08 <cornmaze> Do you know how to make them compatible?
20:18:14 <Cale> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
20:18:26 <Cale> (>>) :: Parser a -> Parser b -> Parser b
20:19:18 <cornmaze> so
20:19:27 <atreus> Quick question.  Just installed the Haskell Platform.  cabal update gives this error: "cabal: .: openFile: inappropriate type (is a directory)"
20:19:29 <Cale> well, in do-notation, this is reflected by the fact that the type of the do-block as a whole is the type of the last parser in it
20:19:32 <atreus> anyone know a fix?
20:19:33 <cornmaze> Cale, so i need a function from (a -> Parser b)?
20:20:06 <Cale> cornmaze: In do-notation,  do { v <- x; <stmts> }  is translated into  x >>= (\v -> do { <stmts> })
20:20:14 <chessguy> @quote
20:20:14 <lambdabot> blip says: im just kidding
20:20:26 <Cale> atreus: odd...
20:21:47 <atreus> Cale:  friend had the exact same isue.  Both on Ubuntu 9.04.  Using GHC 6.10.4.  And the newest 64 bit version of the platform
20:21:52 <Cale> cornmaze: So, basically, it amounts to being that if you have   v <- x   and x :: Parser Char, then v :: Char, and the remainder of the do-block can be Parser RE if that's what you want.
20:22:23 <Cale> atreus: Oh, interesting, I didn't know there was a Haskell Platform release for Ubuntu
20:22:50 <atreus> Cale: There's not.  It was an install from source.
20:23:00 <Cale> ah
20:24:02 <Cale> Then... maybe report a bug. But if you're just trying to get set up...
20:24:08 <Cale> Does GHC work okay otherwise?
20:24:35 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz
20:25:08 <Cale> there's a bootstrap.sh inside that tarball which you should be able to run to get a working cabal-install. If it fails, let me know, and I'll see what I can do.
20:25:50 -Mirel-(n=geek@79.116.188.129)- www.videoporns.net - FREE Porn Videos!
20:25:50 <Mirel-> www.videoporns.net - FREE Porn Videos!
20:25:57 --- mode: ChanServ set +o Cale
20:26:01 --- mode: Cale set +b *!*@79.116.188.129
20:26:01 --- kick: Mirel- was kicked by Cale (Cale)
20:26:01 <SamB> oh no!
20:26:05 <SamB> is it a bot or NOT?
20:26:08 <Phyx-> hahaha
20:26:09 <Tigran> Quick question about case expressions...
20:26:10 <cornmaze> Cale, so my error is with chparse and the last parser of the first do-block is a Parser Char.  Why is it that even though Char is a member of RE, it still fails?
20:26:14 --- mode: Cale set -oo Cale chr1s
20:26:18 <Tigran> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7617#a7617 Assuming I have something like that...
20:26:20 <Phyx-> SamB: why, are you tempted? :P
20:26:36 * SamB feigns inability to tell due to it's simultaneous use of PRIVMSG and NOTICE
20:26:48 <Tigran> If x is `[]', will it pick the first branch of the case without evaluating `bar x'?
20:27:00 <Cale> cornmaze: eh? A value of type Char is not an RE
20:27:06 <Tigran> Or does it need to evaluate both before selecting which case branch to use?
20:27:31 <Cale> cornmaze: However, your RE type (confusingly enough) has a constructor called Char which takes a Char as a parameter and makes it into an RE
20:27:49 <Cale> cornmaze: You must apply that constructor if you want an RE
20:27:59 <Cale> So, if x :: Char, then  Char x :: RE
20:28:25 <cornmaze> Cale, ah thanks...I only wrote half the code so I wasn't sure what that meant
20:28:56 <Cale> Tigran: it should only evaluate x
20:29:08 <Tigran> Cale: Excellent, thanks.
20:29:12 <Cale> Tigran: it won't need to evaluate bar x until ys is used
20:29:38 <Cale> (and it certainly will not evaluate that bar x in the first branch)
20:29:58 <Tigran> The same applies if ys is a pattern too? Such as "Just n"?
20:29:59 <Cale> cornmaze: btw, in Haskell, the usual layout for if-then-else is:
20:30:01 <Cale> if foo
20:30:03 <Cale>    then bar
20:30:06 <Cale>    else quux
20:30:18 <Phyx-> :O
20:30:21 <Phyx-> i never use it like that
20:30:21 <Cale> The important thing being that 'then' and 'else' line up
20:30:21 <cornmaze> Cale, thanks I am really new to this
20:30:51 <Phyx-> i usually put if and then on the same line but line up else to then
20:31:06 <Cale> Phyx-: oh, yes, that's fine too
20:31:24 <Cale> It's just:
20:31:29 <Cale> if foo then
20:31:31 <Cale>   bar
20:31:34 <Cale> else quux
20:31:38 <Cale> Which creates problems
20:31:43 <Phyx-> hehehe
20:31:54 <atreus> Cale: regarding the cabal prob.  GHC seems to work fine.  did the bootstrap.  Cabal still says "cabal list
20:31:55 <atreus> cabal: I: openFile: does not exist (No such file or directory)"
20:32:00 <uman> I keep forgetting whitespace is significant in haskell
20:32:06 <uman> strange
20:32:41 <Phyx-> does ghc translate Int to CInt when you export a function? And also, I assume CInt is always 32bits long and if Int is used it's platform dependend?
20:32:42 <Cale> atreus: That is really strange. :/
20:33:12 <Cale> atreus: did you cabal update first?
20:33:39 <Cale> Phyx-: mmm... you mean foreign export?
20:33:55 <atreus> Cale: it fails there too.  Hence the list.  Weirder yet, it fails differently per user.  As a normal user: "cabal list
20:33:55 <atreus> cabal: I: openFile: does not exist (No such file or directory)
20:33:55 <atreus> "
20:33:57 <dolio> CInt is somehow guaranteed to be compatible with C, and Int technically isn't.
20:34:00 <Cale> Phyx-: I'm pretty sure that it will, but it'd be safer to use fromIntegral to convert it first
20:34:03 <atreus> as root:sudo cabal list
20:34:03 <atreus> cabal: ?: openFile: does not exist (No such file or directory)
20:34:13 <dolio> Despite the fact that in GHC, I think the declaration is "newtype CInt = CInt Int" or something of the sort.
20:34:18 <atreus> Cale: notice one says "I" and the other "?"
20:34:28 <Cale> atreus: yes, that is absolutely bizarre
20:34:41 <Cale> atreus: why it would even try to open files with those names is beyond me :)
20:34:51 <Cale> I suppose I can try to look at the source.
20:35:09 * Cale wonders if dcoutts_ is around
20:36:01 <cornmaze> Cale, so I'd like to do something like this: Char character, but I realize character is of type Parser Char, do you know what i can do to fix that/
20:36:32 <Cale> cornmaze: do c <- character; return (Char c)
20:36:50 <Cale> cornmaze: If you wrote   instance Functor Parser where fmap = liftM
20:37:10 <Cale> then you would write  fmap Char character
20:37:20 <Cale> (of course, you can also use liftM directly)
20:38:12 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
20:38:19 <Cale> So in your case, it would have type:
20:38:27 <Cale> fmap :: (a -> b) -> Parser a -> Parser b
20:38:34 <Cale> and:
20:38:39 <Cale> Char :: Char -> RE
20:38:55 <Cale> So  fmap Char :: Parser Char -> Parser RE
20:38:58 <Trinithis> Anyone know of any tutorials for using Haskell to connect with the internet?
20:39:16 <Cale> Trinithis: There's at least one IRC bot writing tutorial
20:39:17 <gwern> Trinithis: that's a hopelessly general topic
20:39:26 <Trinithis> aha
20:39:27 <gwern> 'does anyone know any tutorials for making haskell do useful stuff'
20:39:33 <Cale> Trinithis: I suppose it depends on what sort of connecting with the internet you want to do :)
20:39:38 <jfoutz> "roll your own irc bot"
20:39:41 <Trinithis> Like spiders
20:39:49 <Cale> Web spiders?
20:39:53 <Trinithis> yes
20:40:16 <Cale> I suppose you'd want to use the HTTP package and Network.Browser
20:40:19 <Cale> http://hackage.haskell.org/package/HTTP
20:40:32 <gwern> hm. my program has been running for >20 minutes now on a small text file. I guess I've discovered why exponential tasks are bad :)
20:40:37 <rovar> Trinithis: there is a nice sockets tutorial in Haskell.. uses a quasi actor model.. lemme find
20:40:54 <Cale> It shouldn't be necessary to use sockets directly for that
20:41:10 <Phyx-> Cale: yeah, foreign export, sorry, left for a sec
20:41:14 <cornmaze> Cale, thanks, it is coming along
20:41:16 <Trinithis> thx
20:41:30 <rovar> http://sequence.complete.org/node/258
20:41:43 <Cale> Trinithis: Then, once you have the pages, you can parse them with one of the HTML parsing libraries -- maybe TagSoup would work well if you're just groping through for URLs.
20:41:45 <Phyx-> Cale: ah ok, i'll do that
20:41:59 <Trinithis> cool
20:42:57 <Trinithis> rovar: Cool link
20:43:27 <Cale> Trinithis: actually you probably won't even require the complexity of Network.Browser (though it is good if the site you're trying to browse requires cookies and such)
20:43:40 <Trinithis> ok
20:44:15 <Cale> fmap getResponseBody . simpleHTTP . getRequest $ "http://www.haskell.org/"
20:44:56 <Cale> oh, hmm
20:45:27 <sm> rss2irc is a nice simple example
20:45:41 <Cale> join . fmap getResponseBody . simpleHTTP . getRequest $ "http://www.haskell.org/"
20:45:47 <Cale> so...
20:46:23 <Cale> simpleHTTP . getRequest $ "http://www.haskell.org/" >>= getResponseBody
20:46:58 <Cale> seems to work :)
20:47:04 <Trinithis> ok
20:48:19 <Phyx-> according to the latest ghc docs, "ghc .shared -o .... MyDef.def" should work, but instead ghc is trying to use MyDef.def as the target...
20:48:44 <Cale> (I hadn't expected getResponseBody to require the IO monad...)
20:49:34 <mmorrow> (getResponseBody <=< simpleHTTP . getRequest)
20:49:38 <mmorrow> (<=<)++
20:50:28 <Phyx-> @hoogle Marshalling
20:50:28 <lambdabot> No results found
20:50:32 <Phyx-> hm
20:50:39 <Phyx-> @where Foreign
20:50:40 <lambdabot> I know nothing about foreign.
20:51:00 <mmorrow> let firefox = let x = x; y = undefined; z = length [0..] in x `seq` y `seq` z `seq` (getResponseBody <=< simpleHTTP . getRequest)
20:52:40 <Cale> heh
20:53:02 <mmorrow> should've added a (let two = mapM_ forkIO [two,two]) to that for good measure..
20:53:05 <impl> win 27
20:53:08 <impl> oops :)
20:53:57 <Berengal> You trying to say firefox is slow?
20:54:09 <mmorrow> and crashy and memory hogging?
20:54:16 <Berengal> And those
20:54:18 <mmorrow> not at all ;)
20:54:24 <Phyx-> You would be correct on all :P
20:54:26 * Phyx- hides
20:54:33 <Berengal> Yeah, my firefox only uses 500 mb ram!
20:54:37 <Phyx-> @index ForeignPtr
20:54:38 <lambdabot> Foreign.ForeignPtr, Foreign
20:54:52 <Ytinasni> Berengal: you're lucky. i get up to 2GB on a regular basis.
20:55:17 <Cale> mine has 207 MB resident atm, and 528 MB virtual memory
20:55:49 <mmorrow> i think it's conal that call's firefox crashing it "garbage collecting"
20:56:00 <Phyx-> lol
20:56:53 <mmorrow> void gc(void){*(void*)0;}
20:57:33 <mmorrow> oops
20:57:36 <dufflebunk> gah, FF and its annoying 2 minutes sprees of allocating and deallocating drive me nuts at work
20:57:37 <mmorrow> void gc(void){*(void**)0;}
20:57:46 <Ytinasni> well, that's one way of doing GC......
20:57:51 <erikc> Chrome, Safari and IE8 all wipe the floor with Firefox these days
20:57:52 <Phyx-> Unacceptable result type in foreign declaration: ForeignPtr SimpleType <-- I though this would be correct
20:57:57 <Ytinasni> all the garbage goes away, right? right? :D
20:58:20 <Berengal> Firefox used to be good, but the last month it's become real crappy for me
20:58:46 <hzap> it's been crashing a lot lately for me
20:59:10 <Berengal> It's not crashing, it just eats lots of memory
20:59:21 <Berengal> And it's become slow
20:59:27 <erikc> maybe they need to do a full rewrite <badum-ching>
20:59:38 <Berengal> hehe
20:59:47 <lispy> or maybe they should start contributing to Chrome (but really none of this is good #haskell talk ;)
20:59:52 <hzap> it doesn't eat too much memory for me :) but just crash crash crash
21:00:07 <Berengal> hzap: Probably why it's not eating too much memory ;)
21:00:08 <lispy> some of the crashing has been flash in my experience
21:00:23 <lispy> but, this is better discussed in an off topic place like #haskell-blah
21:00:23 <hzap> i.e. the 'y' in mmorrow's expression there
21:00:57 * Cale is still waiting for Chrome to have extensions and Linux support before he will use it.
21:01:07 <Phyx-> lispy: flash cauzes 90% of all crashes in any browser
21:01:12 <Cale> But it does seem interesting otherwise.
21:01:18 <lispy> Cale: yes, the next stable release has both of those as features
21:02:04 <Berengal> When do we get a browser written in haskell?
21:02:13 <Cale> I'm too used to having a decent in-browser ad-blocker at this point to go back to using privoxy.
21:02:28 <Ytinasni> Berengal: when you write one :)
21:02:53 <lispy> Berengal: to me the interesting bit isn't the browser in haskell it's replacing javascript with statically pure code
21:03:02 <lispy> Berengal: maybe allow ST if you must
21:03:22 <Berengal> Hmmm, converting html to glade.xml files and displaying those?
21:03:32 <Berengal> lispy: Oh, yes, javascript is fun in haskell
21:03:52 <Berengal> I need to do some more haskell web programming. The little I've done has been fun...
21:04:00 <Berengal> Perhaps I should write that hsp quasiquoter I wanted...
21:04:04 <mmorrow> NoScript++
21:04:14 <mmorrow> vimperator++++
21:04:26 <mmorrow> Berengal: do it!
21:04:39 <lispy> Part of why google created V8 (chrome's js engine) is because they want to build bigger more interest apps in js, but none of the existing implementations were any good.
21:04:52 <lispy> Soon they will reach more theoretical bounds because of the design of js
21:05:05 <hzap> haskell JS interpreter?
21:06:44 <lispy> I don't think it's interesting to build on js, I think it is interesting to replace it
21:07:09 <SamB> lispy: theoretical bounds ?
21:07:11 <erikc> lispy: then they'll have to bring back all the static typing ecmascript4 proposals
21:07:26 <SamB> wouldn't you be able to do at least as well as Self ?
21:07:37 <lispy> I'm not familiar with Self
21:07:57 <SamB> it's another prototype-based language
21:08:04 <SamB> a bit more smalltalky
21:08:04 <cjs> Hm. Seems to me you could just compile a better language to JS, and optimize the interpreter to deal with the "compiled" output.
21:08:26 <Berengal> cjs: Might as well output base-64 bytecode
21:08:27 <lispy> you still fight inefficiencies built into JS
21:08:34 <lispy> I mean, V8 produces machine code JIT style
21:08:43 <SamB> with the right JIT and inlining, you can do wonders
21:08:44 <lispy> and it "memoizes" the prototypes
21:09:09 <lispy> So they have dealt with a few of the performace issues, but not all
21:09:22 <cjs> Byte-code would be better, yes.
21:09:25 <lispy> But, what about the software engineering tasks of ensuring maintainability and correctness?
21:09:26 <Berengal> It's not too hard to make up situations where the compilers die though
21:09:37 <Berengal> And have to revert to slow interpreting
21:09:55 <SamB> lispy: eh, I don't think JS is that bad if you have decent APIs
21:10:32 <Berengal> The trouble with JS is that it removed a whole bunch of non-js-aware tools
21:10:42 <Berengal> removes*
21:10:45 <mmorrow> you could always interp/JIT haskell in-browser..
21:10:49 <SamB> Berengal: removes how?
21:11:09 <SamB> mmorrow: doesn't sound very extensible
21:11:16 <mmorrow> SamB: why not?
21:11:22 <Berengal> SamB: Simple things like scripts, for example
21:11:22 <lispy> Yeah, a variant of Haskell that forbids IO (much like lambdabot) and perhaps strict, would work well for the web
21:11:36 <erikc> diff monads for diff security levels
21:11:37 <mmorrow> SamB: (clearly you wouldn't be using ghc..)
21:12:09 <mmorrow> well, you could i suppose
21:12:12 <SamB> lispy: so how would you change things?
21:12:39 <lispy> SamB: add back the possibility of static analysis :)
21:12:50 <mmorrow> but if that was a "thing" like JS, the compiler/interp would be a very different beast than ghc currently is, is what i mean
21:13:06 <Berengal> action="someFunction:: Event -> Document -> Document" ?
21:13:08 <SamB> lispy: I mean, how would your script accomplish anything?
21:13:31 <pikhq> Doesn't Google's JS API do something crazy like compiling Java to Javascript or something?
21:13:31 <lispy> SamB: well, calling the browser would be in a special monad that only supports specific things
21:13:38 <mmorrow> SamB: (State DOM a)
21:13:46 <lispy> pikhq: that's a different tool
21:13:52 <lispy> pikhq: I forgot the name of that
21:14:12 <SamB> I'm not seeing how this is an improvement over JS :-)
21:14:14 <jfoutz> Google web toolkit. java -> javascript
21:14:42 <Berengal> Compiling java to javascript makes no sense to me. Javascript is a much nicer language than java
21:16:28 <jfoutz> well, you have this java running in some webserver, and you need a way to talk to the client. they do a bunch of cool tricks to ... say convert code like new Button("do stuff"); into a thing that will be rendered to html on a bunch of pages.
21:16:53 <mmorrow> SamB: um, because the syntax doesn't suck, correctness (wrt whatever) is (more) statically checkable, the types would allow you to compile it to hard code more efficiently, you would still have "eval", ...
21:17:38 <mmorrow> how many js compilers/interpreters (that aren't toys) are written in js?
21:18:01 <SamB> dunno.
21:18:07 <mmorrow> (and suppose there are N, how many of those generate hard-code or JIT..)
21:18:11 <SamB> how many Haskell compilers that aren't toys are written in Haskell ?
21:18:13 <Berengal> I'm willing to say "none"
21:18:25 <mmorrow> SamB: 5+?
21:18:29 <pikhq> SamB: I'm willing to say at least 1.
21:18:38 <mmorrow> err, yeah - hbc
21:18:38 <SamB> pikhq: I'd say at least 2
21:18:44 <pikhq> (whether or not there are more depends on your definition of "toy")
21:18:47 <SamB> is hbc written in Haskell ?
21:18:49 <mmorrow> ghc, nhc, yhc, jhc
21:18:52 <mmorrow> no, lml
21:18:57 <SamB> mmorrow: jhc is toy still
21:19:15 <SamB> and I think [ny]hc only counts as one
21:20:12 <Berengal> What's uhc written in?
21:20:17 <mmorrow> SamB: it can generate C code which could r00t your box, then run a webserver (if you were reeeeally careful to write it in such a way that you didn't use any patterns where it gobbles all you mem)
21:20:31 <mmorrow> i'd call that not toy
21:21:16 <SamB> mmorrow: that's toy
21:21:36 <SamB> I mean, it's not going to be a toy forever, probably ...
21:21:43 <SamB> but it's not grown beyond that stage *yet*
21:22:33 <SamB> anyway, I'll admit to 2 or 3, depending on how many [ny]hc counts as ;-)
21:22:33 <mmorrow> SamB: so you define "toy" by "degree to which it currently works perfectly", rather than the amount of code/effort/seriousness?
21:23:07 <SamB> mmorrow: more along the lines of whether or not it's something I would seriously consider using for an actual use
21:23:26 <SamB> and not just because I wanted to play with it
21:23:28 <mmorrow> i'd call e.g. this a "toy" http://mxr.mozilla.org/mozilla/source/js/narcissus/
21:23:52 <Berengal> I think of a toy as something that's interesting in itself. If you compile with jhc for the sake of compiling with jhc, not for the sake of compiling your program, it's a toy
21:24:17 <mmorrow> and this www-users.cs.york.ac.uk/~mfn/hhi/hhi.pdf
21:24:28 <mmorrow> (toy is not pejorative in any way here)
21:24:41 <Berengal> I like toys very much :)
21:24:46 <SamB> I'm not meaning it to be pejorative exactly
21:24:50 <lispy> right, and real applications can start as toys under this def'n
21:25:05 <SamB> but it is a somewhat negative thing in JHC's case
21:25:12 <SamB> because it should be more than a toy
21:25:15 <SamB> ;-)
21:25:27 <mmorrow> i define "toy"ness to be the intended seriousness that a program is intended to be viewed with
21:25:39 <cjs> What was the thingie (or was there one) that would let me override a generic version of a method taking a member of a typeclass with certain specific versions for certain instances of that typeclass, for efficiency?
21:25:48 <SamB> mmorrow: well, it also has to do with how far along it is, I think
21:26:23 <SamB> that is, it also relates to the seriousness with which you CAN view it
21:26:42 <SamB> I can't seriously consider JHC as a contender yet
21:26:44 <mmorrow> SamB: imagine a 100-developer-strong army being paid full-time to work around the clock on <insert program>, and it's day one :)
21:26:46 <lispy> (all trolling disclaimers on; eg., I don't mean to troll but this question is probably flame bait)  Someone told me the other day that in their opinion haskell is decent at making libraries and sucks at making large apps.  And when I look at hackage and the haskell landscape.  Mostly I see libraries and not a lot of apps, which in a way backs that up.  Thoughts?
21:27:14 <SamB> mmorrow: they would barely have begun the briefing
21:27:15 <lispy> cjs: type specialization?  Sounds like a ghc-ism
21:27:21 <SamB> they would have NO program
21:27:27 <cjs> lispy: Yes, I'm thinking it is. I'm a ghc-kinda-guy. :-)
21:27:39 <Berengal> lispy: Applications in haskell, at least the ones I've seen, consist of a datatype or two and 50 lines gluing together hackage libraries
21:27:43 <mmorrow> SamB: but they surely will, or someone's ass is getting shitcanned!
21:27:44 <lispy> cjs: or do you mean the jhc supercompilation (or was it superoptimizaiton, it was super something)
21:28:00 <mmorrow> SamB: everyone has their serious-face on
21:28:10 <SamB> mmorrow: yeah, the dummy who's idea it was to hire a team of 100 to start with
21:28:14 <SamB> they should have started smaller
21:28:15 <mmorrow> SamB: heh
21:28:17 <cjs> lispy: I've got a largish app, and I'm having a bit of difficulty with it, but it's my first Haskell app, and it's still easier than java.
21:28:23 <mmorrow> SamB: they should've used haskell
21:28:25 <SamB> so they could figure out what to do
21:28:37 <SamB> then brought in more people to work on it
21:28:55 <Cale> lispy: I think the reason there are few large applications is that the Haskell community is not so large as to support many of them.
21:28:56 <SamB> (they could have already hired these people, but shouldn't have expected them to help with that project from the beginning)
21:29:07 <cjs> lispy: I suspect one reason you don't see a lot of large open source Haskell apps is because open source apps outside of C, C++, Java and the scripting languages tend to be pretty unpopular, maybe because they're a bit of a pain to build.
21:29:10 <Cale> lispy: Though that might be changing.
21:29:27 <SamB> also, who wants a large app in Haskell?
21:29:43 <pikhq> I want a Haskell OS.
21:29:45 <Berengal> Most large apps are simply libraries anyway
21:29:45 <SamB> I mean, often a small app will do, right?
21:29:57 <SamB> yeah, and a bunch of libraries ;-)
21:30:01 <Berengal> What constitutes a large app anyway?
21:30:09 <solrize> well, who wants large apps at all?  i can think of some large apps that i'd want, for which haskell seems tempting from a distance, but doesn't turn out to work so well up close
21:30:11 <SamB> well, GHC is large
21:30:15 <SamB> mozilla is large
21:30:22 <solrize> e.g. happs state sounded like a great idea but turns out to suck
21:30:28 <dufflebunk> Berengal: open office 3 is large (to me)
21:30:37 <cjs> lispy: I'm not familiar with the JHC stuff, but I suspect it may have difficulty optimizing this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7619#a7619
21:30:39 <SamB> OOo is WAY too large
21:30:47 <SamB> might as well just by MS Office, seriously!
21:31:05 <lispy> I can't imagine a browser written in all haskell.  I would be very concerned about space leaks.
21:31:06 * SamB is thinking of memory usage in this case
21:31:14 <cjs> The problem is that microsecondsPerSecond comes out a double.
21:31:15 <SamB> lispy: as well you should be
21:31:28 <SamB> lispy: they leak badly enough when written in strict languages, after all
21:31:53 <lispy> cjs: supposedly jhc can resolve all type class uses at compile time and then not pass dictionaries
21:31:55 <Berengal> Garbage collection is really nice to have though
21:32:03 <Berengal> How many browsers are written in managed languages?
21:32:19 <SamB> lispy: that's assuming it doesn't crap out on your typeclasses period
21:32:29 <lispy> SamB: minor detail :)
21:32:31 <solrize> what's a managed language?
21:32:31 <SamB> don't try using Control.Category
21:32:36 <solrize> you mean one with gc?
21:32:39 <SamB> it won't work ;-P
21:32:41 <solrize> there were some written in java, that sucked
21:32:43 <lispy> solrize: just means has GC usually
21:32:45 <jfoutz> lispy: i think some of the leak problems are due to the *lack* of garbage collection.
21:32:55 <SamB> HotJava was written in Java, I assume
21:33:05 <jfoutz> and no leaks :)
21:33:13 <kingdj> Berengal: there's a browser inside emacs
21:33:26 <solrize> yeah, true, written in lisp
21:33:32 <solrize> and i think there's a browser in CL
21:33:38 <SamB> well, I think many of the leaks in Mozilla are actually related to overzealous caching
21:33:39 <Berengal> kingdj: There's a <anything> inside emacs
21:33:46 <drhodes> python had grail
21:33:46 <cjs> lispy: Sure, but how does that help in this case? I've got a divide in there that would have to entirely go away in the Int64 case.
21:34:21 <SamB> that is, I think most of the "leaked" memory is not really leaked
21:34:27 <lispy> solrize: closure is the CL browser
21:34:29 <jfoutz> I think mozilla's problems come from memory fragmentation.
21:34:30 <cjs> Hm, though if it could figure out at compiletime that denominator returns 1 for all Int64s, then it would see that it's a divide by one....
21:34:44 <SamB> jfoutz: ah, yeah, that surely does not help either
21:35:21 <SamB> oh, you folks do realize that Mozilla browsers are arguably written in JS?
21:35:32 <drhodes> the interface
21:35:44 <SamB> well, large parts are
21:35:45 <lispy> jfoutz: yeah, a lot of them do, and also that for a very long time they didn't detect cycles in their GC of javascript so loading extensions would cause huge chunks of memory to be retained
21:35:51 <SamB> and who knows which parts the space leaks are in
21:36:14 <SamB> lispy: oh, that's pretty damn dumb!
21:36:24 <lispy> I don't think they use boost or any time of smart pointer in their code either
21:37:03 <SamB> I mean, I could write a webpage that would OOM mozilla if it was that simple!
21:37:29 <cjs> lispy: Ah, it's ghc's SPECIALIZE pragma that I was looking for.
21:37:43 <Berengal> SamB: Saves you the trouble of browser compatability
21:37:53 <lispy> cjs: isn't that what I hinted at? (admittedly, I totally forgot what it was called :)
21:38:04 <cjs> Yes, it was.
21:38:23 <cjs> However, I thought it was probably there, I just didn't know what it was called. :-)
21:39:34 <lispy> cjs: I'm just teasing.  I'm happy you found it
21:47:24 <crutcher> hey, does anyone know the source of the "cabal: 	: openFile: does not exist (No such file or directory)" errors?
21:47:39 <crutcher> with the latest install of ghc and the platform on linux?
21:49:32 <badsheepy> i got around that.. by installing 6.10.3 instead:/
21:49:45 <crutcher> really? that ... sucks.
21:50:17 <dufflebunk> crutcher: I'd try running it with strace on linux to see what it's failing to open
21:53:10 <cjs> lispy: Actually, specialize doesn't do the trick; that just does the "do it statically rather than using the dictionary" thing, from the looks of it. Looks like I need to write my own rewrite rule.
21:53:46 <crutcher> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7621#a7621
21:53:53 <lispy> cjs: oh, I thought you wanted to get rid of the dictionary
21:54:00 <lispy> cjs: what would your rewrite rule do?
21:54:04 <crutcher> it reads my config file, and then the next thing it tries is to open ":"
21:54:14 <lispy> cjs: you know about div right?
21:54:17 <crutcher> the config file was generated by cabal
21:54:17 <lispy> :t div
21:54:19 <lambdabot> forall a. (Integral a) => a -> a -> a
21:54:22 <cjs> Get rid of the conversion of an Int64 to a Double only to multiply it and go back again.
21:54:37 <cjs> Hm. Oh, yeah, div. :-)
21:54:56 <lispy> cjs: just specialize that div to Int64 and you should be there :)
21:55:07 <lispy> :t divRem
21:55:08 <lambdabot> Not in scope: `divRem'
21:55:11 <lispy> :t divMod
21:55:12 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
21:55:19 <lispy> There is some div that gives you the remainder
21:55:37 <lispy> > 13 `divMod` 2
21:55:38 <cjs> Yeah. I guess the rounding gets a bit more complex that way....
21:55:39 <lambdabot>   (6,1)
21:57:56 <lispy> cjs: you could also use rational division
21:58:09 <lispy> ?hoogle Rational a => a -> a -> a
21:58:10 <lambdabot> Warning: Unknown class Rational
21:58:10 <lambdabot> Prelude asTypeOf :: a -> a -> a
21:58:10 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
21:58:29 <lispy> ?hoogle Rational -> Rational -> Rational
21:58:29 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
21:58:29 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
21:58:29 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
21:58:36 <cjs> lispy: You mean like approxRational?
21:58:53 <lispy> cjs: there is a form of division for the rational type
21:59:02 <lispy> it's exact
21:59:14 <lispy> :t (/)
21:59:15 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:59:30 <lispy> > (4#1) / (3#2)
21:59:32 <lambdabot>   Couldn't match expected type `t -> a'
21:59:38 <cjs> Hm. I dug around a bit, and realized I still don't know the number-related stuff that well.
21:59:52 <lispy> ?instances Fractional
21:59:52 <lambdabot> Double, Float
21:59:53 <cjs> Maybe you want '%' instead of '#' there?
22:00:02 <lispy> > (4%1) / (3%2)
22:00:03 <lambdabot>   8 % 3
22:01:34 <Trinithis> @ty (#)
22:01:36 <lambdabot> parse error on input `)'
22:01:36 <cjs> Darn, should I be using Fractional instead of Real there?
22:01:49 <lispy> Depends on what you want
22:01:57 <cjs> Ah, right, I think the issue was rounding.
22:02:05 <lispy> floor?
22:02:17 <lispy> round is banker's rounding
22:02:30 <lispy> which assumes that your fractional bits are in a uniform distribution
22:02:50 <cjs> banker's is fine; I can live with 3.5 going either way, so long as 3.51 goes up.
22:03:04 <cjs> Or hmm...I wonder if I do want floor....
22:03:18 <cjs> But either way, that takes me to Real, doesn't it?
22:04:41 <lispy> 1) if you accept real, why bother with rational? 2) why bother with real?
22:05:07 <lispy> I don't really know what you're doing
22:05:49 <lispy> it seems that instead of using toRational, you could just multiply your seconds by the microsecondsPerSecond
22:06:10 <lispy> toRational has to do something similar
22:06:25 <lispy> But because it will use arbitrary size Integer, I would assume the performance could be bad
22:06:39 <lispy> (it has to do a gcd in there as well)
22:06:44 <lispy> (but gcd is fast)
22:08:33 <cjs> lispy: I was just trying to accept as many constants as reasonably possible, including Int and Double.
22:08:59 <cjs> As I said, my knowledge of the numeric typeclass structure is pretty crappy, so I'm rather flailing here.
22:09:10 * glguy starts a libcap binding http://github.com/glguy/linux-capabilities/tree/master
22:09:44 <lispy> cjs: the details of you using rational are internal no the definiton
22:09:45 <glguy> I saw a blog post at archlinux.me/brain0
22:09:59 <glguy> might be need to see more of this level of fine permissions detail being used
22:10:37 <lispy> cjs: (UTime t) `addSecs` secs = UTime $ t + round (secs * microsecondsPerSecond)
22:10:54 <glguy> neat*
22:11:31 <lispy> cjs: as I understand your code, that should be equivalant
22:11:39 <lispy> cjs: but, I think it uses fewer math operations
22:13:07 <cjs> lispy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7619#a7623
22:13:42 <cjs> I believe the issue is that microsecondsPerSecond when used that way would sometimes need to be a double, and other times an Int64.
22:14:01 <lispy> cjs: what is the type of microscondsPerSecond?
22:14:26 <lispy> oh it's just Num
22:14:31 <lispy> you'll want to fix tat
22:14:45 <cjs> I took out the type signature. If I type it, say, Double, I get back, "Couldn't match expected type `a' against inferred type `Double'"
22:15:53 <lispy> and what are the instances of Real?
22:16:06 <lispy> :t (*)
22:16:08 <lambdabot> forall a. (Num a) => a -> a -> a
22:16:13 <glguy> ?instances Real
22:16:14 <lambdabot> Double, Float, Int, Integer
22:16:37 <lispy> glguy: cool, I typed the earlier and lambdabot gave me an obviously incomplete answer
22:17:27 <lispy> :t round
22:17:29 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
22:18:06 <lispy> cjs: so I think you could do microsecondsPerSecond :: RealFlac and be okay
22:18:27 <lispy> and maybe change a to be RealFrac
22:18:31 <lispy> ?instances RealFrac
22:18:32 <lambdabot> Double, Float
22:19:06 <lispy> :t Real a => a -> Double
22:19:07 <lambdabot> parse error on input `=>'
22:19:11 <lispy> ?hoogle Real a => a -> Double
22:19:12 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
22:19:12 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
22:19:12 <lambdabot> Prelude id :: a -> a
22:19:41 <lispy> cjs: this is kind of a weird thing due to the classes not playing nicely, but I need to crash.
22:19:45 <lispy> good luck
22:19:53 <cjs> lispy: Thanks. You've been a help.
22:20:23 <cjs> Though I don't see how I can make it RealFrac since that's a type class....
22:20:42 <lispy> I meant replace Real with RealFrac
22:20:48 <lispy> But you lose int
22:20:49 <cjs> Oh, I see.
22:20:51 <cjs> Right.
22:21:16 <cjs> That's why I was trying to avoid. I think I'm probably correct that rewrite rules are the only way to do this.
22:21:16 <lispy> ?hoogle (Num t, Real r) => t -> r
22:21:16 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:21:16 <lambdabot> Foreign.Marshal.Utils toBool :: Num a => a -> Bool
22:21:16 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:22:09 <lispy> I suspect your problem is that the prelude doesn't give you a way to convert from Num to Real
22:22:59 <cjs> Hm. Should it? I need to diagram this whole thing out on the whiteboard again.
22:25:34 <lispy> The prelude numeric classes are a sore spot
22:25:45 <lispy> Num wants to be a ring but it has junk in it
22:26:13 <lispy> and because type classes are open,  you have to consider that 1 can be converted to any type
22:26:32 <lispy> now think how you would get an arbitrary type to be Real
22:26:45 <lispy> :t fromIntegral
22:26:46 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:26:51 <cjs> Ah, so it's not just that I'm dumb and confused.
22:27:00 <lispy> :t toIntegral
22:27:01 <lambdabot> Not in scope: `toIntegral'
22:27:32 <lispy> :t 1
22:27:33 <lambdabot> forall t. (Num t) => t
22:27:39 <crutcher> where is the haskell-platform discussed?
22:28:54 <lispy> cjs: oh, now I see the purpose of toRational
22:29:27 <cjs> To get you to fractional, right?
22:29:35 <lispy> well to Rational
22:29:39 <lispy> which is I guess what Real is
22:29:43 <lispy> That's really confusing
22:30:20 <cjs> I'm confused. I'd worked this out at some point, but I've forgotten about it.
22:30:36 <lispy> use :i in ghci
22:30:41 <lispy> :i Real
22:30:48 <lispy> that will tell you what Real defines
22:30:54 <lispy> just follow the types
22:31:06 <cjs> Anyway, I'm going to bail too; I need to get some darn code running today and what I've got is good enough to be able to run, anyway.
22:31:15 <lispy> yea
22:31:32 <cjs> lispy: Yeah, I did. Actually, I've been using the haddock more, and and also the Hudak book has a diagram and partial listing of the interfaces.
22:31:49 <bryanedds> hi all
22:32:05 <cjs> Anyway, I look forward to having another go at this later.
22:32:06 <bryanedds> does haskell have something similar to eiffel's design by contract?
22:32:43 <cjs> bryanedds: You can often use the type system to prove certain things for which you'd use contracts in Eiffel, so in that sense it's got something like it that's stronger.
22:33:00 <lispy> bryanedds: well, there are run-time assertions, and quickcheck/smallcheck to cover run-time stuff.  And types can be used to require proofs at compile time.
22:34:07 <bryanedds> design by contract is really just an advanced static typing system, correct?
22:34:08 <lispy> bryanedds: you'll want to learn the curry-howard isomorphism in order to understand how types can be used as proofs
22:34:32 * bryanedds googles
22:34:33 <lispy> I don't know enough about design by contract to say; and I shoul be leaving :)
22:34:35 <cjs> bryanedds: If I recall correctly, no; design-by-contract was not actually static.
22:35:05 <lispy> I thought design by contract was about making your assumptions explicit, and hence checkable
22:35:07 <Cale> bryanedds: yes. Types are just properties for which the code itself can serve as a machine-checkable proof.
22:35:30 <cjs> It was static in the sense that things that inherit had to adhere to the contracts, but the actual checks were dynamic. (Again, IIRC.)
22:35:36 <Cale> ah
22:36:05 <cjs> They were basically just fancy assertions, it seemed to me.
22:37:04 <bryanedds> so the program has to be run in order to be proven
22:37:14 <atreus_> Cale:  Just FYI regarding the cabal "file not found" thing.  The issue lies in GHC 6.10.4.  Downgrading to 6.10.3 and reinstalling the Haskell Platform fixed everything
22:38:10 <bryanedds> My interest in haskell has been piqued after reading 'the masterminds of programming
22:38:39 <bryanedds> I was most impressed by the Haskell and Eiffel parts
22:38:53 <Cale> atreus_: Oh, very interesting. I'll be sure to let others know when it comes up.
22:39:23 <cjs> bryanedds: Actually, you can't prove a program via running it. You can only show that it didn't go wrong in that particular run.
22:39:51 <SubStack> @pl (\x y -> fst x == fst y)
22:39:52 <lambdabot> (. fst) . (==) . fst
22:39:52 <cjs> Hm. I've not read the Eiffel one; I should check it out. Yeah, the Haskell one was great. If you want to gag, read the Python one.
22:39:58 <Cale> cjs: Well, you can prove it correct by running it enough times, if there are only finitely many possible inputs :)
22:40:01 <sohum> I have a list [(a -> b,c -> d)] and a list [(a,c)]. What's the haskelly way to combine the two?
22:40:15 <Cale> (but that is uncommon)
22:40:26 <lispy> Cale: and very likely an uninteresting program :)
22:40:45 <Cale> :t zipWith (\(f,g) (x,y) -> (f x, g y))
22:40:46 <lambdabot> forall t t1 t2 t3. [(t -> t2, t1 -> t3)] -> [(t, t1)] -> [(t2, t3)]
22:40:58 <lispy> ?pl zipWith (\(f,g) (x,y) -> (f x, g y))
22:40:58 <lambdabot> zipWith (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)))
22:41:02 <lispy> clearly
22:41:08 <Cale> heh
22:41:22 <bryanedds> I'm no longer impressed with python and much less so with ruby
22:41:38 <cjs> Cale: Hm. Yes. I see you are correct here. I look forward to you trying it so I can see your results. :-)
22:41:46 <bryanedds> it's one thing to throw away static typing and immutability, but to throw away both!
22:41:52 <sohum> actually, I'd settle for [(a -> b,c -> d)] -> a -> c
22:42:05 <bryanedds> *static typing or immutability
22:42:22 <cjs> Actually, in the case of something like Ruby or Python, if you're throwing away Java's static typing, that's a move forward.
22:42:37 <Cale> sohum: that type would be impossible
22:43:03 <lispy> bryanedds: those languages are very permissive and I expect that initially there will be a lot of enthusiasm, but eventually I hope for some backlash where people realize how easy it is to write bad code
22:43:08 <bryanedds> not sure what you mean by java's static typing
22:43:09 <sohum> oh, whoops, forgot the result type
22:43:22 <sohum> [(a -> b,c -> d)] -> a -> c -> [(b,d)]
22:43:58 <lispy> :t map
22:44:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:44:06 <lispy> :t repeat
22:44:07 <lambdabot> forall a. a -> [a]
22:44:14 <lispy> sohum: those are hints :)
22:44:16 <dolio> @type sequence . map (uncurry (***))
22:44:17 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Monad (a (b, b')), Arrow a) => [(a b c, a b' c')] -> a (b, b') [(c, c')]
22:44:18 <Cale> ah, in that case, applyPairs ps x y = map (\(f,g) -> (f x, g y)) ps
22:44:35 <lispy> (although, you may not want map)
22:44:45 <dolio> @type curry . sequence . map (uncurry (***))
22:44:46 <lambdabot> forall b c b' c'. [(b -> c, b' -> c')] -> b -> b' -> [(c, c')]
22:45:09 <sohum> aha!
22:45:35 <sohum> what's the monad sequence is dealing in?
22:45:37 <cjs> lispy: You're not going to see that backlash. People *want* to be able to write incorrect code.
22:45:42 <Cale> sohum: (->) e
22:45:50 <sohum> ...huh
22:45:55 <Cale> sohum: That is, functions whose domain is a fixed type e
22:46:14 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
22:46:15 <lambdabot>   ("hello","olleh","HELLO")
22:46:26 <cjs> Dijkstra has been railing about this for decades, and look how far he got.
22:46:30 <Cale> > sequence [id, reverse, map toUpper] "hello"
22:46:31 <lambdabot>   ["hello","olleh","HELLO"]
22:46:45 <Cale> It's the same as:
22:46:45 <bryanedds> the problem in our modern software is too much state thrown around like it's nothing
22:47:04 <sohum> I clearly need to understand the Arrow generality a lot better
22:47:07 <Cale> > map (\f -> f "hello") [id, reverse, map toUpper]
22:47:08 <lambdabot>   ["hello","olleh","HELLO"]
22:47:13 <bryanedds> as if there's no drawback to the statefulness
22:47:23 <Cale> Oh, and Arrow is just being used for (***) here
22:47:41 <dolio> Yeah, it's just using '(f *** g) (x, y) = (f x, g y)'.
22:47:44 <lispy> cjs: perhaps, but I try to be optimistic :)
22:47:48 <lispy> good night all
22:48:00 <cjs> lispy: You will grow up to be a bitter old man. :-)
22:48:04 <Cale> bryanedds: I agree
22:48:35 <bryanedds> I have a C program with > 1000 global variables sitting in front of me
22:48:44 <dolio> Whoa.
22:48:48 <sohum> wow, that's shiny
22:49:06 <dolio> Was it ported from BASIC?
22:49:11 <bryanedds> nope
22:49:28 <bryanedds> just written by someone who never learned the cost of statefulness
22:49:41 <bryanedds> it's hard to teach these values too
22:49:42 <SubStack> haskell makes it hard enough to write correct programs, to say little of incorrect ones!
22:49:52 <Cale> SubStack: oh? :)
22:50:06 <Cale> SubStack: If you write correct programs to begin with, it's usually little hassle :)
22:50:14 <SubStack> Cale: if only!
22:50:15 <uman> bryanedds: I get it, you're complaining because you have to use C
22:50:30 <bryanedds> well, it's just an example :)
22:50:33 <SubStack> but then I'd need to know what it is exactly that I'm trying to do
22:50:51 <bryanedds> Most of my work is C# and I am in love with every functional feature I get
22:50:58 <uman> bryanedds: seriously though, are you counting things like struct instances and arrays as one variable each, or many?
22:51:08 <bryanedds> there are no structs nor arrays :)
22:51:12 * SubStack is getting into the habit of defining his functions with = undefined to figure out the types first
22:51:15 <Cale> SubStack: Sitting in front of a computer probably won't help with that. Go outside and stare at the clouds a while, then come back :)
22:51:15 <dolio> Oh man.
22:51:18 <uman> bryanedds: god damn
22:51:23 <bryanedds> lol
22:51:27 <bryanedds> a real winner :)
22:51:35 <bryanedds> there are a few matrices
22:51:45 <bryanedds> but they're no structs :)
22:51:59 <uman> bryanedds: did he reimplement a bunch of functions because he doesn't know the standard library?
22:52:03 <uman> that's a common idiom in C
22:52:11 <uman> just today I saw a reimplementation of strcpy
22:52:16 <cjs> Cale: I think that SubStack means he works out the type signatures before writing the functions, and he's just setting the definition to 'undefined' so that he can use the compiler to type-check what he's doing.
22:52:20 <cjs> I do that all the time.
22:52:34 <bryanedds> the matrix operations are actually inlined ad hoc in the functions that  they are used
22:52:37 <Cale> cjs: Oh, I do that sometimes too, that's not what I was responding to.
22:52:54 <bryanedds> as well as with the vector operations
22:52:55 <SubStack> yes, I was leading into it and being intentionally vague
22:52:59 <Cale> "<SubStack> but then I'd need to know what it is exactly that I'm trying to do"
22:53:04 <bryanedds> it is a remarkably bad piece of software :)
22:53:08 <cjs> Oh, I see. I was outside staring and the clouds rather than paying attention to the earlier conversation. :-)
22:53:30 <Cale> If you don't know what program you're trying to write, you'll have larger problems than the type system getting in your way. :)
22:53:36 <SubStack> in reality, I just figured out some hairy bits pretty elegantly ;)
22:54:04 * cjs really wants postfix functions. *Sigh*.
22:54:04 <uman> heh, earlier I told someone in ##c: "If you want lazy thinking, go to ##VB.NET"
22:54:06 <SubStack> I like to write very bottom-up programs
22:54:18 <uman> somebody told me "uman: I thought all the people who appreciated laziness were in #haskell..."
22:54:21 <uman> :D
22:55:07 <SubStack> uman: it's also a perl virtue
22:55:09 <SubStack> see perl6
22:55:48 <bryanedds> so are there any other functional languages at peer with haskell?
22:56:22 <solrize> whats that mean ?
22:57:02 <bryanedds> I want to learn the best functional languages
22:57:18 <SubStack> > cycle "the best "
22:57:20 <lambdabot>   "the best the best the best the best the best the best the best the best th...
22:57:33 <bryanedds> I learned a bit of lisp and love its macro capability
22:57:51 <cjs> You might find ML's parameterized modules interesting.
22:58:22 * SubStack never did dig into lisp much
22:58:29 <SubStack> I ought to try those 99 problems some time
22:58:31 <aavogt> > let (!) = product . enumFromTo (1::Integer) in (100!)
22:58:33 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
22:59:55 <erikc> bryanedds: you might like f# since it sounds like you already do a lot on .net
23:00:37 <bryanedds> I just haven't heard anyone recommend f#
23:01:50 <copumpkin> bryanedds: you need to read more lisp mailing lists and look for jdh trolling
23:03:01 <leadnose> :D
23:03:27 <bryanedds> I'm also not terribly keen on F#'s impurity
23:03:39 <copumpkin> need moar harrop
23:04:31 <erikc> the impurity is the cost of playing nice on the CLR, the price you pay for access to a ton of libraries ready to go
23:04:54 <copumpkin> omg erikc is a flying frog in disguise :)
23:04:57 <erikc> haha
23:05:41 <erikc> copumpkin: i prefer haskell, especially cause its concepts are simpler and cleaner
23:06:45 <cjs> No way, he would have flamed the heck out of us for our hash table implementation by now.
23:09:08 <erikc> but f# as a total package, with a good ide / debugger, language interop and tons of libs already accessible, is pretty hot, hopefully it will be a fp gateway drug for a lot of programmers
23:09:16 <bryanedds> and in other news, C++ gets lambda some time in 201x
23:09:26 <Cale> 20x6
23:09:30 <Cale> ;)
23:09:34 <bryanedds> heh
23:09:41 <bryanedds> I just can't use C++ anymore
23:09:47 <bryanedds> I can't bring myself to do it
23:10:00 <Beelsebob> erikc: I don't think so, the feeling from the .net community appears to be "why would we used F#... C# has 99% of the functional features anyway"
23:10:28 <bryanedds> the problem with C# imo is a lack of immutability constructs
23:10:39 <bryanedds> not even a const on methods
23:11:20 <bryanedds> until we have some good immutability constructs, C# is going to have an impedence mismatch with its advanced functional features
23:11:32 <SubStack> bryanedds: likewise about c++
23:11:43 <bryanedds> Anders said he was working hard on the problem tho
23:12:12 <bryanedds> sorry, the C# design team (not just anders)
23:12:18 <SubStack> I took a graphics course at university here and did all my simulation homework with hopengl
23:13:01 <erikc> Beelsebob: yea, that could certainly happen, what i've liked mainly about f# so far versus c# is a lot less typing
23:13:32 * SamB_XP_ assumes erikc means the kind you do with a keyboard, not with a judgement
23:13:43 <erikc> heh, yes :)
23:14:09 <Beelsebob> well, F# does have a lot less typing than Haskell
23:14:25 <Beelsebob> >.>
23:14:27 <Beelsebob> but I'm not sure I enjoy that
23:14:34 <dolio> F# doesn't even have first class modules. That's like the point of ML. :)
23:14:59 <SamB_XP_> dolio: so in ML can I have a list of modules?
23:15:12 <bryanedds> on the other hand, I don't think C# should or could match the purity of a functional languages
23:15:35 <Beelsebob> bryanedds: sure -- but nor does F#
23:15:42 <dolio> SamB_XP_: I don't think so. But I didn't coin the phrase.
23:16:22 <bryanedds> hopefully in adding all these functional features C# doesn't have an identity crisis (cough, C++, cough)
23:16:41 <SamB_XP_> bryanedds: C++'s functional features are accidental, though
23:16:55 <bryanedds> true
23:17:00 <SamB_XP_> ... and in the template system, I think ;-P
23:18:23 <bryanedds> I wish I had a project for which I needed haskell
23:18:23 <SubStack> make one
23:18:48 <bryanedds> wouldn't really do that; I let the project drive the language choice, not the other way around
23:19:01 <Cale> bryanedds: to learn the language initially, it's probably not a bad idea to just play around with it as a toy for a while anyway. It's different enough from mainstream languages that it can take some getting used to.
23:19:19 <SubStack> can't really know where something is going to be applicable without some experience
23:20:13 <SubStack> also the code I wrote last summer I would be ashamed to write now
23:20:47 <SubStack> although that much is true of any new language
23:20:53 <dancor> doesn't it seem like @quote should prefer quotes that haven't gotten airtime recently
23:21:19 <dancor> @quote quote
23:21:19 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
23:21:20 <dancor> @quote quote
23:21:20 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
23:21:50 <SubStack> @quote endofunctors
23:21:50 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
23:22:17 <uman> @quote dancor
23:22:17 <lambdabot> No quotes match.
23:22:25 <dancor> :V
23:22:41 <uman> what the hell is the "stereo" quote?
23:22:43 <uman> now I'm intrigued
23:22:45 <dancor> @quote uman
23:22:45 <lambdabot> uman says: so you can pass functions around as objects... this sounds like JavaScript
23:22:45 <uman> @quote stereo
23:22:45 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
23:22:55 <uman> x_x
23:23:02 <dancor> see we don't know if we've seen all stereo quotes
23:23:07 <uman> @quote stereo
23:23:07 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
23:23:10 <uman> @quote stereo
23:23:10 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
23:23:11 <dancor> we would upon repeat using a last-seen-first alg
23:23:13 <uman> @quote stereo
23:23:14 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
23:23:17 <dancor> errr.. least recently seen
23:23:29 <SubStack> amusing
23:23:40 <uman> SubStack: do you know what the stereo quote is?
23:23:46 <SubStack> no idea
23:23:58 <uman> lame
23:24:24 <dolio> That was it.
23:24:45 <uman> dolio: what was?
23:24:50 <dancor> who's on first
23:25:00 <dolio> The one by Anonycale.
23:25:01 <dancor> > who `on` first
23:25:03 <lambdabot>   Not in scope: `who'
23:25:10 <copumpkin> I wonder who Anonycale might be
23:25:15 <SubStack> http://tunes.org/~nef//logs/haskell/07.09.24 apparently
23:25:16 <copumpkin> sounds very anonymous, yet strangely familiar
23:25:29 <SubStack> at 02:39:31
23:26:42 <dolio> @fact hsu
23:26:43 <lambdabot> I know nothing about hsu
23:27:01 <dolio> The haskell secret underground strikes again.
23:27:09 <uman> dolio: I dun get it
23:27:25 <SubStack> so it does exist
23:27:39 <SubStack> OR DOES IT?
23:27:40 <dolio> That used to print "I know nothing about the haskell secret underground".
23:27:53 <copumpkin> lol
23:28:17 <copumpkin> @fact+ moo is the sound a cow makes
23:28:17 <lambdabot> I know nothing about moo
23:28:21 <dolio> But the fact database got deleted a while ago.
23:28:30 <uman> @quote ubuntu
23:28:30 <lambdabot> ricky_clarkson says: Ubuntu, an ancient African word meaning "I can't configure Debian".
23:28:47 <uman> ricky_clarkson++
23:29:53 <SubStack> debian is very popular in the channels I frequent
23:30:01 <SubStack> I wonder how much of this is due to self-selection
23:31:10 <bryanedds> hehe, wonder if C# will ever get F#'s 'lazy' specifier :)
23:31:14 <SubStack> and how much is due to confirmation bias, being a debian user myself
23:34:04 <uman> well fuck you all, and by that I mean everyone on irc
23:34:04 <Gilly> Funny, I'm just wondering what would be the preferred way to install GHC on Debian. The packages in lenny aren't exactly bleeding edge.
23:34:11 <uman> no offense, but you lot have kept me up *again*
23:34:23 <uman> Gilly: apt-get remove ghc
23:34:31 <uman> Gilly: download and compile from source
23:34:56 <mauke> I'd like to see you compile ghc without ghc
23:35:06 <uman> mauke: uh
23:35:22 <bryanedds> interesting article - http://msdn.microsoft.com/en-us/vcsharp/bb870976.aspx
23:35:34 <Gilly> Doesn't GHC's build system make/get one before actually building?
23:36:01 <uman> mauke: I've done it
23:36:25 <mauke> uman: via unregisterized C or something?
23:36:44 <uman> mauke: I don't remember
23:36:59 <uman> but even if I'm wrong, just reverse the steps
23:37:11 <Cale> Don't compile GHC from source, it's a waste of time to do that.
23:37:28 <Cale> Get the binary. After all, you'll need a working GHC binary to compile GHC.
23:37:41 <Cale> Gilly: yes
23:38:30 <Gilly> meh :) alright - I guess there is no debian source for 6.10.3 so I'll just get one of those general amd64 binaries...
23:38:36 <Cale> yeah
23:38:43 <uman> well goodbye all
23:38:52 <Gilly> g'night
23:52:49 <mbuf> how can I do this in haskell? -- two servers, say running on 14400, 14401; A client connects to 14400 port with 'hello' message which is then received by any client that connects to 14401 server;
23:53:19 <mbuf> in other words, how can I pass a message from one TCP server to another?
23:54:40 <Cale> Use a Control.Concurrent.Chan perhaps
23:55:29 <mbuf> Cale, can the two servers run in parallel, or should I do something like start the 14401 server only after a message is received from the 14400 server?
23:55:56 <Cale> It seems natural to run them concurrently in separate threads.
23:56:52 <mbuf> Cale, i see;
23:58:16 <Cale> mbuf: I think you basically have to anyway, since accept will block until it gets a connection.
23:59:06 <Cale> Though I suppose if you wanted to hold 14401 users up until a matching 14400 user finishes, you wouldn't need threads.
