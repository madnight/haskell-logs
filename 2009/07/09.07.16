00:24:02 <void9> i want more than Debug.Trace.  Hat looks good, and shows an update in October, but warns me it's out of date.  HOOD's current release is from year 2000.  what should i do?
00:35:29 * void9 stares at Debug.Trace
00:41:59 <mjrosenb> void9: is there anything in particular that you want?
01:14:28 <cizra> I can't insert literal escape characters into Haskell strings )=
01:14:33 <cizra>     lexical error in string/character literal at character '\ESC'
01:16:03 <malcolmw_> > '\ESC'
01:16:05 <lambdabot>   '\ESC'
01:17:00 <malcolmw_> >" \ESCd"
01:17:32 <malcolmw_> > " \ESCd"
01:17:34 <lambdabot>   " \ESCd"
01:20:06 <cizra> > show "\ESC[2J"
01:20:08 <lambdabot>   "\"\\ESC[2J\""
01:20:23 <cizra> meh. Can I somehow make lambdabot print them literally?
01:22:05 <mjrosenb> cizra: nope
01:22:30 <mjrosenb> cizra: printing arbitrary strings is probably a bad thing
01:23:16 <mjrosenb> particularly since there are 2 bots in the channel
01:23:45 <cizra> o yes
01:24:21 * mjrosenb tries to remember lunabot's trigger
01:24:27 <mjrosenb> , 2+2
01:24:31 <lunabot>  4
01:24:38 <mjrosenb> yay!
01:25:17 <mjrosenb> so > putStrLn ", putStrLn ..."
01:25:53 <cizra> Hmm. I want to have a function that, depending on the arguments, either calculates a value or asks the user for it. Its type must be IO something, right?
01:26:05 * mjrosenb does not know if he has ever written a quine in haskell
01:26:12 <mjrosenb> cizra: yes
01:26:28 <cizra> Even if it uses another function to do the IO?
01:26:31 <cizra> .. right?
01:27:31 <mjrosenb> cizra: can its evauluation result in IO happening?
01:27:59 <cizra> A relevant question. Indirectly, yes, because it might call it.
01:28:16 <thoughtpolice> then yes, it needs to be in IO
01:30:09 * cizra is writing a tic-tac-toe game with an AI
01:30:11 <quicksilver> > text ", putStrLn \"Hi\""
01:30:13 <lambdabot>   , putStrLn "Hi"
01:30:21 <cizra> The AI currently picks random valid moves, hehe
01:30:25 <quicksilver> mjrosenb: you can, but it inserts an extra initial space :)
01:30:55 <cizra> > text "\ESC[2J"
01:30:57 <lambdabot>   [2J
01:31:50 <cizra> > text "I'm a \ESC[41;mcommie"
01:31:51 <lambdabot>   I'm a [41;mcommie
01:32:10 <cizra> mehh.
01:33:36 <yitz> @users
01:33:36 <lambdabot> Maximum users seen in #haskell: 658, currently: 577 (87.7%), active: 9 (1.6%)
01:36:34 <mjrosenb> quicksilver: strange, last time i tried it, lambdabot just printed out <IO>
01:36:38 <mjrosenb> or something similar
01:43:23 <quicksilver> mjrosenb: Yes. I didn't execute an IO action.
01:43:28 <quicksilver> mjrosenb: "text" isn't an IO action.
01:43:31 <quicksilver> :t text
01:43:32 <lambdabot> String -> Doc
01:43:53 <quicksilver> it's a pretty printer to a type with a certain Show instance
01:44:37 <mjrosenb> oh wow
01:44:43 <mjrosenb> i did not even notice that
02:04:48 <yitz> > text "foo" $+$ text "bar"
02:04:49 <lambdabot>   foo
02:04:50 <lambdabot>  bar
02:05:30 <soupdragon> heh
02:06:46 <yitz> > text "foo" $+$ nest 1 (text "bar")
02:06:48 <lambdabot>   foo
02:06:48 <lambdabot>   bar
02:12:57 <yitz> @ask Cale Why does text "foo\nbar" indent three spaces on the first line and two on the second in \bot?
02:12:57 <lambdabot> Consider it noted.
02:22:09 <Le-Chuck_ITA> Hi there
02:22:17 <Le-Chuck_ITA> I was an haskell addict once and want to get back
02:22:39 <Le-Chuck_ITA> But I don't remember some basics that need experience to be known, e.g. how do I get this library? http://hackage.haskell.org/packages/archive/HFuse/0.2.1/doc/html/System-Fuse.html
02:22:48 <Le-Chuck_ITA> what is "hackage"?
02:25:15 <Le-Chuck_ITA> well I might as well have googled for it :)
02:25:20 <Le-Chuck_ITA> http://hackage.haskell.org/packages/hackage.html
02:25:24 <klugez> Le-Chuck_ITA: http://hackage.haskell.org/package/HFuse - Hackage is the package repository from where you can also install packages with cabal install.
02:25:59 <Le-Chuck_ITA> klugez: but in general how does one organise a project that uses these libraries? Just use cabal?
02:26:07 <Le-Chuck_ITA> assume that the user is using cabal I mean?
02:26:34 <klugez> I think so.
02:35:54 <Le-Chuck_ITA> hmm anybody knows how to install cabal in ubuntu karmic? the package libghc6-parsec2-dev can't be installed, and the package libghc6-parsec3-dev is not recognised by cabal as "parsec"
02:36:51 <anborn> I'm trying to package a StateT transformer into a newtype (http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2988#a2988). I was able to make the resulting type an instance of Monad, but I can't seem to find a way to declare it a MonadState. Any suggestion?
02:37:28 <doserj> (>>=) = (>>=) is not what you want...
02:39:16 <Peaker> anborn: you can use:  deriving Monad   on a newtype that wraps a Monad
02:39:30 <anborn> @Peaker: tried that
02:39:31 <lambdabot> Unknown command, try @list
02:39:42 <Peaker> anborn: You might need a language flag: GeneralizedNewTypeDeriving
02:39:44 <anborn> automatic deriving doesn't work
02:43:59 <Peaker> anborn: indeed, weird. I did remember StateT was derivable
02:44:36 <Peaker> oh, I see, its the (Board a) there
02:44:36 <anborn> Peaker: from what I see automatic deriving would work if I had defined the following: newtype BoardT s m a ...
02:45:12 <anborn> Peaker: what I'm trying to do here, in fact, is to make a "specialized" version of StateT
02:45:16 <Peaker> anborn: anborn you can't use (Board a) as the State
02:45:45 <Peaker> anborn: you can't use the same "a" of the monad -- because (>>=) needs to be able to keep the same state, but change the result type of the monad
02:45:55 <Peaker> anborn: that's why the newtype-deriving fails
02:47:15 <anborn> Peaker: I see... So you suggest I use a "free" type variable?
02:47:35 <Peaker> anborn: either another type variable, or a fixed type
02:50:06 <Le-Chuck_ITA> Ok I need a bit of help. I try to install cabal, but I need parsec. I tried to install all the dependencies manually using runhaskell Setup configure --user, everything is ok (HTTP, zlib, network) but parsec is not seen by cabal
02:50:08 <Le-Chuck_ITA> I have it
02:50:13 <Le-Chuck_ITA> it is parsec-3.0
02:50:18 <Le-Chuck_ITA> perhaps an older version is required?
02:51:20 <anborn> Peaker: thanks, it works ;-)
02:51:59 <Peaker> anborn: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2988#a2989 -- with MonadState
02:52:03 <doserj> Le-Chuck_ITA: you probably need a parsec-2.x version, yes
02:52:21 <Le-Chuck_ITA> doserj: and do you know how do I uninstall 3.0? by brutally removing the directory from ~/.cabal?
02:52:36 <Le-Chuck_ITA> btw cabal is bootstrapping now
02:52:50 <doserj> ghc-pkg hide should be enough
02:52:59 <Le-Chuck_ITA> doserj: but the files will stay there then?
02:53:13 <Le-Chuck_ITA> doserj: my ubuntu has no garbage collector :)
02:53:17 <doserj> yes. you can also ghc-pkg unregister and delete the files
02:54:38 <Le-Chuck_ITA> doserj: thanks
02:55:11 <Le-Chuck_ITA> doserj: ok now network and http depend on parsec 3.0
02:55:21 <Le-Chuck_ITA> I think I have made a mess and will need to restart or leave things as they are :)
02:55:45 <doserj> you can also try http://hackage.haskell.org/platform/
02:56:58 <Le-Chuck_ITA> doserj: whoa. Did somebody try to get that packaged in major distributions?
02:57:10 <Le-Chuck_ITA> I mean in their repositories?
03:01:09 <doserj> Le-Chuck_ITA: I guess various distribution teams are working on that
03:01:33 <soupdragon> What I do get annoyed about is the use of spaces for indentation. I see absolutely no reason not to use the actual tab character (\t, 0x09) for all indenting purposes. Spaces are to be used to align relevant statements that belong at the same tab depth. The advantage of this method is that it does not matter how wide you like your tabs. You set the tab width in your favorite editor (another common point of contention) to whatever you like, and anyone
03:01:33 <soupdragon> who looks at your code sets the tab width to whatever they like. No issues.
03:02:02 <quicksilver> soupdragon: I agree entirely. I am repeatedly surprised that no popular editor supports this paradism.
03:02:10 <gornfan> that doesn't really work with haskell because haskell is not indentation-based
03:02:21 <gornfan> haskell is about making things line up
03:05:35 <cizra> Is there a safe version of read?
03:05:41 <cizra> > read "lala" :: Int
03:05:42 <lambdabot>   * Exception: Prelude.read: no parse
03:05:51 <cizra> I'd like to get a maybe or something.
03:06:03 <gornfan> cizra: reads
03:06:18 <cizra> > :t reads
03:06:20 <lambdabot>   <no location info>: parse error on input `:'
03:06:24 <cizra> :t reads
03:06:26 <lambdabot> forall a. (Read a) => String -> [(a, String)]
03:06:50 <cizra> > reads "lala" :: Int
03:06:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:07:11 <cizra> Instead of asking dumb questions, /me googles for a change.
03:08:06 <doserj> > reads "lala" :: [(Int,String)]
03:08:07 <lambdabot>   []
03:09:30 <desp> Is there a way to tell GHCI to look for modules in a certain directory?
03:11:46 <doserj> -i<dir1,dir2,...dirn>
03:20:46 <athos>  /j #netbsd
03:20:51 <athos> oops!
03:27:10 <athos> @hoogle a -> a
03:27:11 <lambdabot> Prelude id :: a -> a
03:27:12 <lambdabot> Data.Function id :: a -> a
03:27:12 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
03:30:55 <ray> schemes everywhere
03:56:39 <xenoblitz> hi people I am trying to cabal install the opengl library on hackage but I am getting an error: Setup.hs: sh: runGenProcess: does not exist (No such file or directory) ... any ideas what I could be doing wrong?
03:57:32 <xenoblitz> ps I am using a windows machine
03:57:43 <snurble> xenoblitz, You're on windows? It expects 'sh' to be there so it can run a script
03:57:47 <fasta> Does dons have a secretary or did he just write some crawler to submit every known link containing "Haskell" to haskell.reddit.com?
03:58:11 <snurble> I had the same problem, I used MSYS, worked fine there
03:59:10 <xenoblitz> snurble: sorry for not understanding... so I have to install MSYS?
03:59:22 <snurble> That was my workaround
03:59:53 <xenoblitz> snurble: ah now I understand - I need sh
03:59:56 <fasta> xenoblitz: you have to install something that can understand sh or you must execute sh manually ;)
03:59:58 <snurble> So, install MSYS, run cabal install opengl from there
04:00:01 <xenoblitz> weird this never happened before to me
04:00:20 <xenoblitz> fasta: thanks :)
04:00:29 <xenoblitz> snurble: thanks will do :)
04:05:50 <xenoblitz> snurble: installed msys but error still appears
04:05:55 <xenoblitz> hmmm
04:06:09 <xenoblitz> snurble: ah nevermind, mistake on my part
04:07:56 <Saizan> xenoblitz: there should also be an haskell platform windows installer that includes opengl
04:08:22 <Saizan> http://hackage.haskell.org/platform/
04:09:04 <xenoblitz> saizan: thanks :) will try it out
04:13:46 <Vanadium> Is there a way to rewrite (++) <$> getLine <*> getLine so that it looks as if I am using (++) in infix style?
04:14:37 <lilac> Vanadium: getLine <^(++)^> getLine
04:14:46 <Vanadium> Awesome, thanks
04:14:53 <ehamberg> cool smiley
04:15:03 <lilac> @hackage InfixApplicative
04:15:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/InfixApplicative
04:15:09 <koala_man> ehamberg!
04:15:10 <lilac> Vanadium: ^^ in that package
04:15:16 <ehamberg> koala_man!
04:15:17 <Vanadium> Ah
04:16:03 <lilac> Vanadium: (<^) = flip (<$>); (^>) = (<*>)
04:16:09 <StevenTyler> What is Haskell used for?
04:16:28 <gornfan> StevenTyler: writing programs
04:16:34 <gornfan> hanging around
04:16:41 <Vanadium> StevenTyler: To slay your enemies, see them driven before you, and hear the lamentations of their women
04:16:43 <lilac> @wiki Haskell in industry
04:16:43 <gornfan> having a bud
04:16:44 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
04:16:48 <lilac> StevenTyler: there's a list there ^^
04:16:53 <StevenTyler> I see
04:16:59 <StevenTyler> ok thanks
04:17:16 <koala_man> ehamberg: skjera
04:17:27 <lilac> StevenTyler: plus it's used as a testbed for research into lazy evaluation
04:18:02 <StevenTyler> I would be interested in learning why those people choose Haskell over C++/Java/Python
04:18:15 * StevenTyler looks up lazy evaluation
04:18:38 <lilac> @go Why Functional Programming Matters
04:18:40 <lambdabot> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
04:18:40 <lambdabot> Title: Why Functional Programming Matters
04:18:42 <PeakerWork> StevenTyler: Stronger type system. Type-classes. Laziness.
04:18:45 <gornfan> C++ is a cruel joke. Java is no fun. Python is too clumsy.
04:19:11 <lilac> @wiki Why Haskell matters
04:19:12 <lambdabot> http://www.haskell.org/haskellwiki/Why_Haskell_matters
04:19:13 <PeakerWork> StevenTyler: Monad Transformers make Haskell the best imperative language :-)
04:19:22 <Vanadium> Using lazy evaluation in C++ is probably rather cumversome.
04:19:24 <PeakerWork> And the other features make Haskell one of the best Functional Languages :)
04:19:28 <ehamberg> koala_man: solskogen!
04:19:31 <StevenTyler> Aha!
04:19:47 <koala_man> awesome
04:19:51 <lilac> PeakerWork: i'm not sure i can agree that haskell is the best imperative language
04:20:01 <PeakerWork> StevenTyler: In Haskell, you can read the types of API functions, and often you don't need documentation - the type tells the whole story. I haven't seen this before seeing it in Haskell
04:20:14 <soupdragon> SML
04:20:14 <PeakerWork> lilac: Not when you need predictable operational semantics...
04:20:20 <soupdragon> Ocaml
04:20:25 <PeakerWork> lilac: but when you don't -- what imperative language would you prefer?
04:20:28 <koala_man> ehamberg: will there be any haskell demos?
04:20:29 <lilac> PeakerWork: /defined/ operational semantics would be nice ;-)
04:20:56 <ehamberg> koala_man: doesn't look like it. there was one at breakpoint, though. "freedom from state" or something. :)
04:21:04 <StevenTyler> I should learn Haskell, it's a whole different programming paradigm.
04:21:32 <PeakerWork> StevenTyler: a whole set of different paradigms :)
04:21:35 <cizra> StevenTyler: These are all good answers, but they don't cover my reason: geekiness! I'm happy to learn something that twists my brain and makes me different from the masses. Call me an ego lover if you wish, but it's fun!
04:22:03 <PeakerWork> lilac: what imperative language do you use when you need to know how its going to run?
04:22:10 <lilac> PeakerWork: haskell doesn't let me create a record and then update a single field in that record
04:22:16 <StevenTyler> cizra, I know man. If someone told me they know Haskell, they would earn instant respect from me,
04:22:24 <lilac> PeakerWork: i use c++ for that, with a compiler whose behaviour i understand ;-)
04:22:33 <PeakerWork> lilac: operationally, no, semantically, sure
04:22:34 <cizra> PeakerWork: bitc, of course (=
04:22:36 <ManateeLazyCat> If i want to get common part of two string, how to do it?
04:22:47 <gornfan> lilac: no such thing :-)
04:22:47 * StevenTyler goes to download Haskell
04:22:53 <StevenTyler> I hope it's free like Python
04:23:00 <ManateeLazyCat> If i want to get common part of two string, how to do it?
04:23:02 <PeakerWork> lilac: say its a tuple, just   modify (first (*2))   to update your record..
04:23:12 <cizra> StevenTyler: Are you using Linux?
04:23:14 <PeakerWork> ManateeLazyCat: please don't repeat, your question was visible before
04:23:16 <lilac> PeakerWork: haskell's a great high-level imperative language, but not a great low-level imperative language, is i guess my feeling
04:23:30 <PeakerWork> lilac: I agree. I'm not sure C++ is a great low-level language, though
04:23:30 <StevenTyler> I am on Win
04:23:32 <dobblego> > "abc" `intersect` "bdaf"
04:23:33 <lambdabot>   "ab"
04:23:58 <lilac> PeakerWork: and when i'm working with several gigabyte datasets, i can't afford to copy a structure to change one member, etc
04:23:59 <gornfan> StevenTyler: haskell is not a product or program
04:24:05 <StevenTyler> what is it?
04:24:12 <gornfan> a language
04:24:20 <StevenTyler> where can I get a compiler?
04:24:23 <cizra> StevenTyler: GHC is the thing you want
04:24:26 <dobblego> @where ghc
04:24:26 <lambdabot> http://haskell.org/ghc
04:24:28 <doserj> http://hackage.haskell.org/platform/2009.2.0.1/HaskellPlatform-2009.2.0.1-setup.exe
04:24:30 <StevenTyler> ok thanks
04:24:32 <ManateeLazyCat> dobblego: Not that.
04:24:55 <dobblego> ManateeLazyCat, then what?
04:25:13 <lilac> PeakerWork: c++ has its shortcomings, but once you've invested the effort to learn it's quirks, it's not too bad
04:25:39 <gornfan> (yes, it is)
04:25:43 <ManateeLazyCat> dobblego: Example, i input two string "/home/example/text" and "/download/example/text" return "/example/text"
04:25:52 <lilac> s/'//
04:26:08 <ManateeLazyCat> dobblego: I want return common part of two string from END
04:26:37 <ManateeLazyCat> dobblego: If last character is different in two string, return null
04:26:42 <dobblego> ManateeLazyCat, you can't use your imagination to go that bit further?
04:26:44 <lilac> gornfan: i've seen a lot of people claim that, without presenting a better alternative
04:27:06 <ManateeLazyCat> dobblego: Yep, i just want to know have an exist function in haskell library.
04:27:14 <lilac> it's not that c++ is good, it's that most low-level imperative languages are worse
04:27:14 <ManateeLazyCat> Before i implement it.
04:27:27 <ManateeLazyCat> dobblego: I don't want do repeat work.
04:27:40 <Beelsebob> ManateeLazyCat: is isSuffixOf what you're looking for?
04:27:43 <loremi> Which is/should be "faster" w.r.t. common list processing operation (a is Double): [(a,a,a)] or [T a], where data T a = T a a a  or T ({-# UNPACK #-}?) !a !a !a ?
04:27:47 <soupdragon> most low-level imperative languages
04:27:48 <gornfan> lilac: I use C
04:27:52 <Beelsebob> > "abc" `isSuffixOf` "jamabc"
04:27:53 <lambdabot>   True
04:27:56 <soupdragon> what are some of them?
04:27:57 <dobblego> ManateeLazyCat, split, reverse, zip, takeWhile
04:28:03 <ManateeLazyCat> benmachine: Yep, that's i want.
04:28:06 <soupdragon> I can't think of many
04:28:19 <ManateeLazyCat> Beelsebob: That's i want thanks
04:28:26 <Beelsebob> :)
04:28:34 <PeakerWork> lilac: I think implementation inheritance is a mistake, the lack of type-classes and horrible syntax makes templates unusable, and the way templates are implemented also pretty horrible
04:28:42 <ManateeLazyCat> dobblego: I know how to implement it, but why not use exist code?
04:28:55 <lilac> soupdragon: assemblers, pascal, c, c++, cobol, fortran, ...?
04:28:57 <PeakerWork> lilac: The language is much bigger than it has to be.  I even prefer C, though I'd prefer something like C that had type-classes even more
04:29:00 <dobblego> ManateeLazyCat, you're making very little sense, I give up
04:29:00 <soupdragon> ok
04:29:06 <lilac> soupdragon: plus d, which i've heard good things about
04:29:24 <PeakerWork> C + parameterized-types + type-classes, and maybe even (+ purity), but I'm not sure that would work, or require GC
04:29:24 <StevenTyler> what's Darcs? How is it different from GHC?
04:29:47 <gornfan> StevenTyler: darcs is a source control system
04:29:55 <StevenTyler> Like SVN?
04:29:59 <gornfan> yeah
04:30:01 <PeakerWork> StevenTyler: yeah, but very different :)
04:30:08 <StevenTyler> ok
04:30:11 <gornfan> you might as well ask for the difference between cvs and gcc
04:30:17 <StevenTyler> Is it specific for Haskell?
04:30:29 <MyCatVerbs> Nah. I use it for C code myself.
04:30:31 <gornfan> no, it's just written in haskell
04:30:38 <lilac> PeakerWork: implementation inheritance is extremely useful in practice. type-classes are coming (concepts). templates /are/ usable and used in practice.
04:30:55 <StevenTyler> CVS is a versioning system, and GCC is the GNU C Compiler, if I am not wrong
04:31:08 <lilac> PeakerWork: this is a common pattern in C++. it's full of things which are theoretical abominations but very useful in practice (until they bite you)
04:31:19 <StevenTyler> Or are they different in Haskell context?
04:31:26 * ManateeLazyCat I will try to ask in IRC for exist code, even i know how to implement it. Avoid repeat work.
04:31:33 <cizra> StevenTyler: no, it was just an example of nonsensical association
04:31:45 <cizra> StevenTyler: CVS and GCC are as unrelated as DARCS and GHC.
04:32:04 <StevenTyler> Oh I see.
04:33:55 <PeakerWork> lilac: "useful in practice" == used in practice, but I think every case of its use is probably wrong and could have benefited from a better mechanism.  Concepts don't seem to have all the power of type-classes, but that's just from skimming the article comparing some type-classes with concepts.   Templates are only written by "C++ gurus", and those who aren't relate C++ templates to clumsy syntax and prefer not to use them when
04:33:55 <PeakerWork> possible, at least from my experience..
04:34:26 <PeakerWork> lilac: The C++ template syntax is a great obstacle to its actual use.  It makes rather trivial things appear very complex
04:36:12 <Associat0r> PeakerWork:  o then I must be a C++ guru
04:37:04 <lilac> PeakerWork: i think all you're saying is that c++ is hard when you don't know what you're doing. that i definitely agree with.
04:37:13 <PeakerWork> Associat0r: I would venture to guess that more than 50 or 70 percent of C++ users use templates (reluctantly?) but almost never actually write them
04:37:42 <PeakerWork> lilac: Also the retarded implementation of checked exceptions, the fact templates are implemented as macros, and implementation inheritance make me shun the language compeltely
04:37:53 <quicksilver> I would echo PeakerWork's guess. I bet the proportion of C++ coders who implement their own templates is less than 1%.
04:38:30 <kalven> I belong to a select few, it seems.
04:38:34 <PeakerWork> C with classes was the wrong project, it should have been   C with type-classes :)
04:38:36 <lilac> quicksilver: depends who you classify as a c++ coder, but i think PeakerWork's guess matches my experience
04:38:47 <PeakerWork> kalven: you're in #haskell, of course you do :)
04:39:06 <quicksilver> kalven: I would expect this channel to be rather non-representative of C++ coders as a whole ;)
04:39:10 <PeakerWork> I doubt that any user of Haskell never writes parameterized types, though
04:39:11 <lilac> PeakerWork: checked exceptions are a mistake in any language.
04:39:37 <PeakerWork> lilac: I disagree, I think if they can be inferred (ala the exception monad) or "optional" then they are great
04:40:08 <lilac> PeakerWork: anything which encourages "catch the exception and throw it away because you can't do anything else and otherwise your code doesn't compile" sounds, well, stupid to me
04:40:26 <PeakerWork> lilac: You might as well say Haskell encourages using unsafeCoerce so it would compile
04:40:45 <PeakerWork> lilac: You have to get the types to match, and part of the type is what exceptions you might raise
04:40:57 <lilac> PeakerWork: the problem comes with implementing an interface you don't control
04:41:11 <lilac> PeakerWork: where that interface says "you can't throw checked exceptions"
04:41:31 <PeakerWork> lilac: If the interface has a parametrized monad, where the monad type is allowed to contain an open checked exception specification, doesn't that solve the problem?
04:41:35 <lilac> which means your code must catch them all, even if it has no place doing so
04:42:12 <lilac> PeakerWork: even in haskell i suspect that requires nontrivial type hackery
04:42:21 <PeakerWork> lilac: The problems you mention are solvable, they don't mean checked exceptions don't have value -- they just mean that like static types -- if you want to be flexible you have to have a powerful type system and use it wisely
04:42:47 <PeakerWork> lilac: In fact, I think checked exceptions are very much like strong static types -- if you get them wrong, they are more a hinderance than a useful thing
04:42:57 <PeakerWork> but if you get them right...
04:43:00 <lilac> PeakerWork: I'll believe checked exceptions can work when someone shows me a language where they work.
04:43:37 <lilac> PeakerWork: but in c++ at least exception specifications are now deprecated (iirc). so that's not really an argument against c++ :)
04:44:39 <lilac> PeakerWork: also templates-via-code-generation is exactly what you want in a lot of cases for high performance and low memory usage
04:44:39 <PeakerWork> lilac: it was a retarded behavior, glad they deprecate it :)
04:44:43 <lilac> PeakerWork: agreed :)
04:44:48 <PeakerWork> lilac: http://hackage.haskell.org/package/control-monad-exception <-- have you seen this?
04:46:19 <lilac> PeakerWork: ok, so how do you define a typeclass method with an open checked exception specification using that?
04:47:08 <lilac> you want some arbitrary set of exceptions, so you're already into multi-parameter type classes, HList and much more
04:48:43 <lilac> or i suppose you could allow the method to be wrapped in an arbitrary monad
04:49:02 <lilac> in either case, it doesn't sound like this would scale well if you had multiple methods with different exception specifications
04:49:46 <PeakerWork> lilac: brb
04:50:05 <lilac> PeakerWork: you want to take this to -blah?
04:52:43 <Saizan> PeakerWork: have you written code using control-monad-exception?
04:53:44 <BONUS> regarding haskell, i don't see the advantage of using exceptions as opposed to taking advantage of types like Maybe and Either
04:53:49 <Saizan> the fact that l is kept polymorphic seems to imply that you have to add a type annotation at the toplevel enumerating all the exceptions
04:54:09 <BONUS> and/or using monad transformers for error handling
04:54:36 <PeakerWork> Saizan: nope, I've just been impressed by its docS :)
04:54:52 <Saizan> ErrorT is already a lot like exceptions, though by itself it doesn't give you much granularity
04:55:17 <BONUS> yup, only ErrorT doesn't require you to use IO
04:56:12 <Saizan> the package above doesn't either, though Control.Exception does
04:56:15 <PeakerWork> Saizan: if you want to create an interface/type-class that's allowed to raise any exceptions with EM, maybe you could just be polymorphic to any m, including (forall l. EM l)  and (forall l. OnlyThrowsThis l => EM l)
04:56:15 <BONUS> i mean well if you're using it over IO, then yeah, but i like it better than IO exceptions because it's kind of more explicit
05:09:38 <mmmulani> how do I convert an int to a fractional?
05:09:50 <RayNbow> :t fromIntegral
05:09:51 <lambdabot> forall a b. (Integral a, Num b) => a -> b
05:10:22 <mmmulani> ahh thanks
05:10:44 <RayNbow> so Int is in the Integral class, and Fractional is in the Num class
05:10:51 <mmmulani> ohhhh
05:11:03 <RayNbow> erm
05:11:10 <RayNbow> *Fractional is a subclass of the Num class
05:11:18 <RayNbow> to be more precise
05:14:39 <ivanm> RayNbow: as is Integral ;-)
05:16:56 <povman> does anyone know of a fixed point arithmetic library?
05:17:12 <quicksilver> Data.Fixed?
05:17:23 <quicksilver> it's in the standard library set with ghc last I checked.
05:17:29 <povman> sorry - i mean fixed point and fixed size
05:17:33 <povman> i want it to be fast
05:18:37 <quicksilver> no.
05:21:41 <ivanm> povman: what, Doubles aren't fast enough for you?
05:21:47 <otulp> Fortran :)
05:21:52 <ivanm> heh
05:22:01 <quicksilver> well maybe he wants more accurate than double, while still fast :)
05:22:05 * ivanm didn't know fortran was a library...
05:22:06 <povman> ivanm: They're not predictable enough
05:22:11 <ivanm> quicksilver: heh
05:22:14 <quicksilver> although if you are careful you can actually use double as a fixed point type.
05:22:14 <ivanm> povman: in what way?
05:22:21 <quicksilver> povman: they are predictable if you are careful.
05:22:23 <ivanm> quicksilver: that's what I was going to suggest
05:22:37 <ivanm> perform your roundings/etc. after each operation if you want
05:22:39 <ivanm> maybe newtype Double
05:23:12 <povman> hrm
05:23:15 <ivanm> or, if you want to keep the number of digits as part of the value, then data FixedPoint = FP Int Double
05:23:26 <ivanm> and create custom instances of Num, etc.
05:23:40 <ivanm> or else use Rational
05:24:04 <quicksilver> rational isn't fast :)
05:24:08 <ivanm> or even use some Ints or something
05:24:11 <ivanm> quicksilver: oh, yeah ;-)
05:24:15 <ivanm> Ratio Int ?
05:24:23 <quicksilver> ratio int is broken
05:24:30 <ivanm> quicksilver: in what way?
05:24:33 <povman> the main problem with ratios is they're not Floating
05:24:40 <quicksilver> it's rather easy to overflow the denominator and get rubbish
05:24:44 <ivanm> ahhhh
05:25:05 <povman> Maybe doubles are fine
05:25:27 <povman> albeit they're 64 bits and my computer is 32
05:26:27 <ivanm> povman: so?
05:26:37 <ivanm> note that there's also Floats, but they're nowhere near as efficient...
05:26:56 <povman> ivanm: why not?
05:27:10 <ivanm> because there hasn't been as much work done on them IIRC
05:27:16 <ivanm> since everyone uses Doubles anyway ;-)
05:27:52 <povman> work? I thought they were machine native types
05:28:08 <ivanm> povman: well, the Haskell usage of them
05:28:10 <ivanm> *shrug*
05:32:25 <povman> Ok. It looks like Double is way accurate enough for my purposes, and I can use rounding, and it's not so bad if it's 64 bits
05:33:19 <bsdemon> how to construct Word8 from Char?
05:33:56 <povman> bsdemon: use ord
05:33:59 <bsdemon> sorry for my dummy question, i am very new to Haskell
05:34:26 <povman> bsdemon: Why are you using Word8?
05:34:42 <ski> @type ord
05:34:44 <lambdabot> Char -> Int
05:34:53 <bsdemon> For testing purposes I want to construct ByteString from String
05:35:01 <quicksilver> bsdemon: pack
05:35:23 <bsdemon> quicksilver, thanks!
05:35:32 <quicksilver> povman: double is higher precision than your 32-bit int.
05:35:38 <bsdemon> Are there any introducing tutorial on ByteStrings?
05:35:51 <povman> quicksilver: it's also twice as wide
05:36:04 <quicksilver> that's true :)
05:36:12 <quicksilver> they have 52 bits of mantissa I think.
05:36:28 <povman> quicksilver: but this is probably nitpicking, since i'm going to be doing a number of sqrts on them
05:36:41 <bsdemon> hmm I can use pack only with Data.ByteString.Char
05:36:42 <quicksilver> povman: but I wasn't sure what the significance of your comment 'my computer is 32' was supposed to be.
05:37:00 <quicksilver> bsdemon: the different bytestrings have slightly different types for 'pack'
05:37:03 <quicksilver> Word8 or Char8
05:37:03 <Botje> @hoogle pack
05:37:04 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
05:37:04 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
05:37:04 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
05:37:10 <quicksilver> because that's what they're intended to represent
05:37:35 <bsdemon> are there any difference in using them?
05:37:43 <povman> quicksilver: wherefore i thought that the hardware could do arithmetic with single precision twice as fast as double precision
05:37:54 <quicksilver> povman: definitely not.
05:38:08 <Vanadium> Is the .Char8 ByteString a different bytestring from the regular one?
05:38:09 <quicksilver> povman: double precision arithmetic is much faster. 4x faster, perhaps.
05:38:13 <quicksilver> Vanadium: not not really
05:38:16 <quicksilver> it just pretends to be.
05:38:30 <povman> quicksilver: good grief! I don't understand the arithmetic processor then
05:38:54 <quicksilver> povman: your computer has a special FPU for floating point.
05:39:04 <quicksilver> it is designed for 64-bit or 80-bit floating point operations
05:39:09 <quicksilver> (depending exactly what chip you have)
05:39:18 <Kashyap> type Point = (Integer,Integer)  line :: Point -> Point -> [Point] line p1 p2         | x1 /= x2 = [(x1,y1)] ++ line (newX,newY) (x2,y2)         | otherwise = [p1]   where     ((x1,y1),(x2,y2)) = reorderPoints p1 p2     newX = x1 + 1     newY = newX * slope     slope = ((y2-y1)/(x2-x1))  reorderPoints :: Point -> Point -> (Point,Point) reorderPoints p1@(x1,y1) p2@(x2,y2)         | x1 < x2 = (p1,p2)         | otherwise = (p2,p1)
05:39:59 <Kashyap> Oops ... sorry ... I am having a problem with converting fraction to integer
05:40:10 <Kashyap> slope = ((y2-y1)/(x2-x1))
05:40:20 <povman> quicksilver: Thankyou :) Maybe I should read more about standard architectures
05:40:27 <Kashyap> I get this error - No instance for (Fractional Integer)
05:40:36 <quicksilver> Kashyap: you can't use / on integers.
05:40:45 <quicksilver> Kashyap: either use `div` for integers
05:40:56 <quicksilver> or convert to a fractional format (and possibly convert back afterwards)
05:40:59 <dsturnbull> anyone know what the problem is here? http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=5673
05:40:59 <Kashyap> but div ignores the fractional part right?
05:41:04 <quicksilver> right.
05:41:10 <quicksilver> it has to doesn't it, to work on intergers :)
05:41:11 <dsturnbull> (trying to use cabal, missing base pkg)
05:41:34 <Kashyap> yeah ... but what if I want the result to be fractional
05:41:40 <quicksilver> dsturnbull: I'm not sure, but I think that means you have incompatible libraies.
05:41:49 <quicksilver> Kashyap: "< quicksilver> or convert to a fractional format"
05:42:04 <Vanadium> So... Char/Char8 represents characters and Word8 is an integral type?
05:42:09 <quicksilver> you can use fromIntegeral to convert from an integer to a fractional format.
05:42:14 <Vanadium> Why are we using Word8 for ByteStrings in the first place?
05:42:18 <Kashyap> you mean, I should convert the operands of / to fractional?
05:42:29 <quicksilver> Vanadium: because they are strings of *bytes*
05:42:33 <Kashyap> okay ... got it ... thanks quicksilver
05:42:36 <quicksilver> Vanadium: (not characters)
05:42:45 <quicksilver> Vanadium: and Word8 is a byte ;)
05:43:11 <Vanadium> Okay, so using them for text files is morally wrong?
05:43:39 <quicksilver> well you clearly have encoding issues to think about.
05:43:53 <quicksilver> if your text files are 7-bit clean anyway; then sure, that's why there is a Char8 version of bytestring.
05:47:34 <Vanadium> Oh, I figured text meant utf8
05:47:45 <quicksilver> it doesn't, though, does it?
05:47:51 <quicksilver> text means text, and utf8 means utf8.
05:48:16 <quicksilver> If you do indeed have a utf8 file, then accessing it as a bytestring might be useful, but it might be confusing
05:48:25 <quicksilver> you don't have a one-character-to-byte correspondance
05:49:16 <Vanadium> I am somewhat used to having utf8 strings as char* in C, anyway :3
05:49:29 <Vanadium> So I assume the prefered method would be to use regular Strings for UTF-8?
05:50:23 <quicksilver> well, that depends what your objetives are.
05:50:35 <quicksilver> it would certainly be odd to have a String which was UTF8-encoded.
05:50:48 <quicksilver> Strings are no supposed to be encoded at all - they are unicode.
05:51:19 <anders^^> is the record style for data declarations not supported by haskell98?
05:51:32 <quicksilver> on the other hand, Strings have a rather high memory overhead, so you might seek a more "compact" alternative
05:51:55 <quicksilver> there isn't a standard packed representation (except UArray Char) but there are various things on hackage.
05:52:07 <quicksilver> anders^^: h98 has record style data declarations.
05:52:12 <quicksilver> anders^^: what made you think it didn't.
05:52:35 <Vanadium> quicksilver: I meant to decode it and then store the result in a String
05:52:49 <anders^^> quicksilver: well I get confused every time i try to read the syntax in the h98 report
05:52:58 <quicksilver> Vanadium: that's one way, then, yes ;)
05:54:27 <quicksilver> anders^^: constr -> con atype atype atype | atype conop atype | con { fielddecl, fielddecl, fielddecl
05:54:28 <anders^^> quicksilver: hehe after a quick search I found it in the report ;)
05:54:33 <quicksilver> anders^^: 4.2.1
05:54:37 <ManateeLazyCat> Beelsebob: What's function you told me just now? I forgot it....
05:54:41 <quicksilver> (my excertp simplified for ease of typing)
05:54:43 <anders^^> quicksilver: yes looking now ;) thanks
05:54:53 <ManateeLazyCat> Beelsebob: Find common part of two string from end.
05:55:03 <ManateeLazyCat> Thanks!
05:55:25 <dsturnbull> quicksilver: how could i check for incompatible libs? i'm on ubuntu hardy, installed ghc6 deb, and ran bootstrap.sh on cabal-install-0.6.3
05:56:12 <quicksilver> dsturnbull: it looks like you have some libs compiled against base-4.1 and some against base-4.0
05:56:15 <quicksilver> perhaps
05:56:46 <doserj> doesn't hardy still have ghc-6.8.x?
05:56:46 <dsturnbull> ah right. so probably the mtl and parsec debs?
05:56:52 <dsturnbull> yes
05:56:53 <ManateeLazyCat> Beelsebob: I remember it, is isSuffixOf
05:57:02 <dsturnbull> 6.8.2
05:57:41 <doserj> so where did you get base-4.x, anyways?
05:57:53 <dsturnbull> shrug
05:58:10 <dsturnbull> ghc -v:
05:58:12 <dsturnbull> wired-in package base mapped to base-3.0.1.0
06:00:11 <doserj> dsturnbull: what you are trying to install requires base-4.x, which is only available in ghc-6.10.x. I don't understand that error message, though.
06:02:21 <doserj> ahh, base is also available on hackage, but of course not installable...
06:03:18 <dsturnbull> i'll grab 6.10
06:06:50 <dsturnbull> doh, launchpad.net is slow as a wet week
06:07:23 <fasta> dsturnbull: not as slow as Haskell.org
06:07:54 <fasta> I have been unable to get more than 60kB/s from it.
06:10:09 <dsturnbull> 22.1KB/s from launchpad.net right now
06:10:27 <dsturnbull> getting pretty sick of ubuntu being so outdated
06:11:29 <fasta> dsturnbull: ubuntu is not outdated, your selected repository might be.
06:11:44 <fasta> dsturnbull: karmic is quite up to date.
06:12:00 <damkor> hi
06:12:36 <damkor> I'm getting  an "internal error" in ghc 6.10.3 for arm, and I'm wondering what to do
06:13:20 <damkor> the complete message is: "main: internal error: adjustor creation not supported on this platform \n (GHC version 6.10.3 for arm_unknown_linux)"
06:13:59 <damkor> should I really report that bug?
06:17:18 <benmachine> it annoys me that unlines . lines /= id
06:17:31 <benmachine> well, it doesn't annoy me very much
06:17:34 <benmachine> but a little bit!
06:17:38 <mauke> can't really be avoided
06:18:12 <benmachine> bet it can
06:18:35 <benmachine> just depends on what you consider a line
06:18:37 <mauke> but at what price?
06:19:16 <benmachine> well, probably at a price greater than the cost of me shutting up and writing my own functions
06:19:33 <mauke> heh
06:20:01 <benmachine> I just have a lot of functions that operate on lines, so they lines the string, fiddle with the list, and unlines it again
06:20:12 <benmachine> and after I do this a few times I find I have a bunch of newlines onthe end
06:20:24 <povman> then you need unnewlines
06:20:49 <ivanm> benmachine: unlines' = init . unlines
06:21:05 <ivanm> that gets rid of the extra newline unlines keeps putting on the end
06:21:09 <yottis> how about some function mapLines :: String -> (String -> String) -> String that remembers the line separators when joining the lines again?
06:21:12 * ivanm often finds that annoying as well
06:21:15 <benmachine> ivanm: I did unlines' = intercalate '\n' to more or less the same effect
06:21:26 <ray> doesn't that get rid of legitimate newlines at the end too?
06:21:27 <ivanm> yottis: how would it "remember" the line seperators?
06:21:37 <ivanm> @type intercalcate
06:21:39 <lambdabot> Not in scope: `intercalcate'
06:21:41 <mauke> unlines doesn't add extra newlines
06:21:45 <ivanm> @hoogle intercalcate
06:21:46 <lambdabot> No results found
06:21:47 <mauke> it simply terminates each line
06:21:53 <benmachine> > unlines . lines "foo"
06:21:55 <ivanm> mauke: and often that's not wanted
06:21:55 <lambdabot>   Couldn't match expected type `a -> [GHC.Base.String]'
06:21:59 <benmachine> whoops
06:22:01 <benmachine> > unlines . lines $ "foo"
06:22:02 <ivanm> > unlines $ lines "foo"
06:22:03 <mauke> HERESY
06:22:04 <lambdabot>   "foo\n"
06:22:04 <lambdabot>   "foo\n"
06:22:11 <ivanm> mauke: ^^
06:22:21 <quicksilver> damkor: I believe that is a known issue, not a bug
06:22:28 <mauke> yeah, "foo" isn't really a line to begin with
06:22:33 <mauke> maybe lines "foo" should be []
06:22:47 <benmachine> that'd be even worse
06:23:00 <benmachine> but I see your point
06:23:04 <damkor> quicksilver: I see. Do you know if there are any plans to solve it?
06:23:04 <yottis> read until something that can be considered a line separator, apply and return the output of given function to the string, read and output lineseparator, loop
06:23:07 <yottis> ~
06:23:19 <benmachine> if all my lines started ending with newlines they'd probably finish in a sensible state
06:23:24 <ivanm> mauke: well, I often do lines on things like "foo\nbar"
06:23:41 <ivanm> so you're saying that lines "foo\nbar" should equal ["foo"] ?
06:23:41 <quicksilver> damkor: the current vogue for smartphones has invigorated interest in the ARM port, but I don't think it's an overnight fix
06:23:55 <mauke> ivanm: yeah, but I'm not serious
06:24:33 <quicksilver> lines "foo\nbar" should equal error " BZZZT DANGER WARNING DANGER : Last line of input does not have a newline. SELF DESTRUCT INITIATED"
06:24:40 <damkor> quicksilver: that's exactly my situation. I'm trying to develop an app for freerunner using gtk, and only very simple things work.
06:24:46 <benmachine> unlines . lines $ "foo\n"
06:24:47 <ivanm> mauke: ssshhh! how can I rail at you unceasingly if you're not serious!?!?!? :p
06:25:00 <benmachine> > unlines . lines $ "foo\n"
06:25:01 <lambdabot>   "foo\n"
06:25:02 <ivanm> quicksilver: nah, shouldn't have the space after the opening quote
06:25:03 <ivanm> ;-)
06:25:10 <quicksilver> damkor: I think this issue is related to there not being a native code gen for ARM
06:25:20 <quicksilver> damkor: you could hop over to #ghc and see if someone is awake there.
06:25:32 <damkor> quicksilver. sure, thanks
06:28:11 <Gwern-away> @seen shachaf
06:28:12 <lambdabot> shachaf is in #haskell-iphone, #concatenative, ##logic, #haskell, #xmonad, #haskell-blah, #perl6, #scala and #haskell-in-depth. I last heard shachaf speak 3h 15m 52s ago.
06:28:19 <Gwern-away> @tell shachaf http://community.haskell.org/~gwern/static/Culture%20is%20not%20about%20esthetics.html
06:28:20 <lambdabot> Consider it noted.
06:31:06 <anborn> is it possible to provide an implementation for a function with the following signature: (ServerPartT IO a -> ServerPartT IO a) -> StateT s (ServerPartT IO) a -> StateT s (ServerPartT IO) a  ?
06:32:53 <PeakerWork> const id? :-)
06:33:43 <Gwern-away> anborn: you'd be better off  with the happs ml
06:33:48 <PeakerWork> @hoogle runStateT
06:33:49 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
06:33:49 <lambdabot> Control.Monad.State.Strict runStateT :: StateT s m a -> s -> m (a, s)
06:34:36 <quicksilver> anborn: yes
06:34:43 <anborn> Gwern-away: my question is not specific to ServerPartT, though. You can substitute any other transformer in its place
06:35:11 <Berengal> Looks tantalizingly close to fmap..
06:35:14 <quicksilver>  :t \f act -> StateT $ \s -> f (runStateT act s)
06:35:19 <quicksilver> :t \f act -> StateT $ \s -> f (runStateT act s)
06:35:23 <lambdabot> forall s (m :: * -> *) a (m1 :: * -> *) a1. (m1 (a1, s) -> m (a, s)) -> StateT s m1 a1 -> StateT s m a
06:35:48 <quicksilver> that's almost a strict generalisation of what you asked for.
06:35:54 <quicksilver> the only twist is that your first two "a"s become (a,s)
06:36:03 <quicksilver> which is, I think, fundamental to what's happening here.
06:36:40 <anborn> quicksilver: thanks, just need a bit to absorbe that ;-)
06:36:42 <PeakerWork> :t \f act -> StateT $ \s -> (f &&& id) (runStateT act s)
06:36:43 <lambdabot>     Occurs check: cannot construct the infinite type: s = (a, s)
06:36:44 <lambdabot>       Expected type: (a1, s)
06:36:44 <lambdabot>       Inferred type: (a1, (a, s))
06:37:08 <PeakerWork> :t \f act -> StateT $ \s -> (fmap (f &&& id)) (runStateT act s)
06:37:09 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a1, a)
06:37:10 <lambdabot>       Expected type: m a
06:37:10 <lambdabot>       Inferred type: m (a1, a)
06:38:02 <PeakerWork> @type let inStateT f = StateT . f . runStateT in inStateT
06:38:03 <lambdabot> forall s (m :: * -> *) a s1 (m1 :: * -> *) a1. ((s -> m (a, s)) -> s1 -> m1 (a1, s1)) -> StateT s m a -> StateT s1 m1 a1
06:41:22 <benmachine> @hoogle [a -> a]
06:41:23 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
06:41:23 <lambdabot> Data.Generics.Aliases unGQ :: GenericQ' r -> GenericQ r
06:41:23 <lambdabot> Control.Parallel.Strategies sPar :: a -> Strategy b
06:41:40 <benmachine> that's not quite what I had in mind
06:42:27 <PeakerWork> benmachine: what do you want there? that type must be isomorphic to a number (list length), as  (a -> a) is necessarily id
06:43:18 <Beelsebob> hmm, anyone know how to get parsec to parse any of "seconds", "second", "secs", "sec" or "s", and default to the longest
06:43:26 <Beelsebob> (i.e. consume as much of "seconds" as it can)
06:43:32 <benmachine> PeakerWork: well, I'm really looking for a way of applying a function n times to some input
06:43:53 <PeakerWork> benmachine: iterate
06:44:07 <PeakerWork> @type \f n -> take n . iterate f
06:44:09 <lambdabot> forall a. (a -> a) -> Int -> a -> [a]
06:44:15 <PeakerWork> @type \f n -> (!!n) . iterate f
06:44:17 <lambdabot> forall a. (a -> a) -> Int -> a -> a
06:44:41 <benmachine> hmm I guess that is what I was looking for
06:44:46 <PeakerWork> > let iterN f n = (!!n) . iterate f   in   iterN (*2) 3 1
06:44:48 <lambdabot>   8
06:44:49 <mauke> char 's' >> optional (string "ec" >> optional (char 's' <|> (string "ond" >> optional (char 's'))))
06:44:53 <benmachine> now the question is
06:45:17 <Beelsebob> mauke: ah, nice idea
06:45:19 <doserj> Beelsebob: the naive way is: choice . map (try.string) $ ["seconds", "second", "secs", "sec", "s"]
06:45:22 <benmachine> is take i . iterate (' ':) $ string more or less efficient than (replicate i ' ') ++ string
06:45:31 <benmachine> er not take i
06:45:35 <benmachine> but !!i
06:45:43 <Beelsebob> doserj: without the try in there, it grabs "s"
06:45:49 <Beelsebob> is the try critical?
06:46:09 <Berengal> Beelsebob: If it fails on 's' it hasn't consumed any input
06:46:11 <Beelsebob> (to have it be done in the right order)
06:46:19 <Beelsebob> Berengal: it doesn't fail
06:46:38 <Beelsebob> choice . map string $ ["seconds", "second", .....] succeeds
06:46:41 <Beelsebob> and consumes only "s"
06:47:17 <Berengal> Ah, right
06:47:21 <PeakerWork> benmachine: they are both same O(), the iterate one may be more efficient because it doesn't need to replicate the list twice
06:47:37 <Berengal> Beelsebob: Which input was it getting?
06:47:44 <Beelsebob> Berengal: seconds
06:48:09 <benmachine> PeakerWork: okay, thanks
06:48:54 <Berengal> Beelsebob: Parses "seconds" on my box...
06:48:59 <quicksilver> Beelsebob: instead of parsec, use a parser with a non-broken, compositional design.
06:49:02 <Beelsebob> odd
06:49:06 <PeakerWork> benmachine: actually, if i is very large, the iterate one may also save a lot of memory.  But that's in theory. I'm not sure how exactly the functions will behave resource-wise, in practice
06:49:09 <Beelsebob> quicksilver: you got any of those handy?
06:49:16 <quicksilver> Beelsebob: polyparse? readp?
06:49:20 <PeakerWork> quicksilver: I thought parsec's point was to be compositional
06:49:31 <mauke> wasn't readp the one with no error messages?
06:49:39 <quicksilver> then you just write "seconds" <|> "second" <|> "secs" ...
06:49:44 <quicksilver> PeakerWork: if it was, then epic fail.
06:49:56 <quicksilver> I think it's point was to be fast
06:50:05 <mauke> seconds|second|secs|sec|s
06:50:07 <mauke> just use a regex :-)
06:50:11 <quicksilver> (by making backtracking explicit)
06:50:19 <quicksilver> but I think that's a daft argument.
06:50:29 <quicksilver> People who *actually* care about being fast use parser generators.
06:50:39 <quicksilver> parser combinators should be convenient to use and compositional.
06:50:52 <quicksilver> and I've not heard that polyparse is slow.
06:51:02 <mauke> s(?:ec(?:ond)?s?)?
06:51:07 <PeakerWork> mauke: s(ec((onds?)|s?)  :)
06:51:17 <mauke> BEATET
06:51:53 <Berengal> parsec's included in the platform at least
06:53:20 <doserj> so is happy :)
06:53:35 <Berengal> I like EDSLs
06:54:05 <PeakerWork> is EDSL=DSEL? People often write DSEL?
06:54:05 <quicksilver> yes, I like parser combinators very much and parsec is very good in many ways.
06:54:16 <quicksilver> I just disagree strongly with this design decision.
06:54:27 <quicksilver> and Beelsebob's question happened to illustrate it very clearly.
06:54:28 <SamB> mauke: isn't there a function to optimize that regex?
06:54:39 <mauke> SamB: yes, and it's built into perl
06:54:57 <Berengal> I use parsec for most of my parsing needs. I recently had a look at polyparse, and it looks better/easier to use, but I still used parsec for my latest parser...
06:55:01 <mauke> it should automatically left-factor and trieify it
06:55:33 <Berengal> However, now I've found I need a stack-trace monad thingy, for parsing recursive datastructures
06:56:30 <mauke> as soon as my brain is working again, I can think about teleporting values, and then I might get good error messages in a readp-style parser
06:57:06 * Berengal wants first-class patterns
06:57:23 <mauke> wasn't there a library for that?
06:57:44 <Berengal> What, for pattern matching/instanciation?
06:57:59 <PeakerWork> mauke: Perl regexps are implemented Non-deterministically, even in the majority of cases where a deterministic automata could work
06:58:07 <SamB> instantiation
06:58:10 <SamB> with a t
06:58:17 <PeakerWork> Hard to say that Perl "optimizes regexps" in that sense
06:58:29 <benmachine> oh yeah
06:58:37 <benmachine> there was that article about
06:58:41 <Berengal> SamB: Okay, but the question still stands. Something like that would be neat
06:58:48 <benmachine> 'a?' x 30 . 'a' x 30
06:58:54 <SamB> PeakerWork: I heard that the rand call was in the hash code
06:59:06 <benmachine> against 'a' x 30
06:59:12 <SamB> Berengal: obviously my spelling correction does not invalidate the desire ;-)
06:59:56 <PeakerWork> SamB: the rand call?
07:00:13 <PeakerWork> SamB: I mean its exponential rather than linear
07:00:44 <SamB> PeakerWork: yeah, figured out what you meant but decided to mis-interpret you anyway for amusement value ;-)
07:02:15 <PeakerWork> http://swtch.com/~rsc/regexp/regexp1.html
07:02:19 <benmachine> http://swtch.com/~rsc/regexp/regexp1.html I like the graphs
07:03:01 <PeakerWork> sad: "The regular expression implementations used by today's popular tools are significantly slower than the ones used in many of those thirty-year-old Unix tools. "
07:03:26 <SamB> I like the JSON-spec-style diagrams ;-)
07:05:13 * SamB wonders what's with the big jump in GNU grep's cost graph for a?^na^n matching a^n
07:05:30 <SamB> or, wait, is that TCL's graph?
07:05:31 <benmachine> it mentions it in the article somewhere
07:05:42 <benmachine> something about a default cache size, iirc
07:08:50 <benmachine> okay now I can't find it and suspect I am imagining things
07:16:13 <SamB> the prize for deciding N=NP is only a measly $million USD?
07:16:24 <SamB> er.
07:16:27 <SamB> P=NP
07:16:43 <Botje> well, that and international bragging rights.
07:16:44 <Valodim> nope
07:16:48 <Valodim> that's the money you get right away
07:16:59 <Botje> it's probably worth a turing _AND_ a nobel prize
07:17:07 <Valodim> but if you solve that, you'll never have to worry about getting a job or research funds again in your life
07:17:25 <EvilTerran> you could probably sell the secret for more than $1M to some mafia or something ;)
07:17:38 <Valodim> the theoretical computer science mafia?
07:17:49 <EvilTerran> i mean, if you find a constructive proof that P=NP
07:18:05 <Botje> or P/=NP..
07:18:21 <quicksilver> Botje: there are no nobel prizes for mathematics because nobel's wife had a fling with a mathematician and he hated them ;)
07:18:24 <SamB> EvilTerran: you think the mafia can use that to decrypt stuff cheaper?
07:18:28 <mauke> I have found the solution
07:18:35 <EvilTerran> SamB, i was being fascetious
07:18:37 <EvilTerran> :P
07:18:41 <mauke> N=0 v P=1
07:18:52 * EvilTerran is personally rooting for either someone finding a nonconstructive proof (perhaps followed by a proof of nonconstructibility to really rub salt in the wound), or P=NP turning out to be independent of our existing axioms
07:18:57 <Botje> don't you mean ^ :)
07:18:59 <SamB> mauke: lol
07:19:13 <Berengal> > let p = 1; np = 1 in p == np
07:19:15 <lambdabot>   True
07:19:19 <Berengal> \o/
07:19:31 <djahandarie> \o/
07:20:08 <yottis> some details left out as an exercise
07:21:18 <StevenTyler> \o/`
07:22:06 <Berengal> > let p = np; np = p in p == np
07:22:11 <lambdabot>   mueval-core: Prelude.read: no parse
07:22:12 <lambdabot>  mueval: ExitFailure 1
07:22:23 <StevenTyler> how about 1 == 0?
07:22:41 <Berengal> > let 1 = 0 in 1 == 0
07:22:43 <lambdabot>   False
07:22:56 <Berengal> ... what?
07:23:05 <djahandarie> Fail
07:23:20 <Valodim> The answer is: No, Haskell can't do that!
07:23:21 <djahandarie> It should adhear to the whole church numeral things so we should be able to redefine them, amirite?
07:23:32 <SamB> well, this explains why minesweeper is so hard to automate properly ;-)
07:24:50 * SamB never would have guessed that you can convert boolean logic circuits to minesweeper configurations
07:25:15 * SamB assumes that the "mines left" counter is discounted in this whole thing?
07:25:39 * SamB is reading http://www.claymath.org/Popular_Lectures/Minesweeper/ if you didn't figure that out ;-)
07:31:11 <lilac> SamB: i think once you start considering it, it's pretty clear that you can build certain logic gates in minesweeper
07:31:57 <SamB> lilac: yeah, but I never started ;-)
07:32:12 <SamB> it's not the obvious thing to think about
07:32:59 <lilac> i've certainly had moments in minesweeper games when i've written down some boolean equations and set about solving them
07:33:46 <lilac> but yeah, i'd never wondered if it was np-complete :)
07:34:07 <densem> Hi
07:34:27 <lilac> presumably part of the proof is that all boolean expressions have an only-polynomially-larger representation as a planar graph
07:34:33 <lilac> i find that pretty interesting
07:34:35 <Axman6> hi densem
07:34:45 <Cale> lilac: Have you seen the Haskell minesweeper implementation on hackage?
07:34:45 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
07:34:56 <lilac> Cale: no
07:35:02 <quicksilver> Cale: does it solve minesweeper at compiletime using typeclasses?
07:35:23 <Cale> It's fun. If there is any way in which something won't be a bomb when you click, it won't be a bomb. (You are always lucky.)
07:35:38 <quicksilver> runtime computer games are so 20th century. compile time computer games are the way forward.
07:35:38 <lilac> haha, brilliant
07:35:41 <quicksilver> that's clever.
07:35:45 <Cale> But if it's necessarily a bomb, then you die of necessity
07:35:59 <lilac> quantum immortality minesweeper
07:36:47 <ray> i would like that, because sometimes you're forced to guess
07:36:49 <lilac> a friend of mine is working on the opposite approach to hangman -- it picks answers to maximize the minimum number of guesses to a word
07:36:50 <Vanadium> Cale: Does that not rather trivialise it?
07:36:52 <ray> unless you're not and i just suck
07:36:59 <ray> i have not worked out the math
07:37:01 <Cale> Vanadium: No, it just makes it not-unfair.
07:37:09 <lilac> it makes it always possible to win
07:37:31 <Cale> Vanadium: You never have to worry about the cases where you are forced to guess.
07:37:39 <ray> what cale and lilac say imply that you are in fact sometimes forced to guess
07:37:42 <ray> i would like to see a proof :)
07:37:56 <benmachine> you are forced to guess sometimes
07:38:05 <benmachine> I read an article about it
07:38:08 <Vanadium> ray: I thought that was supposed to be the challenge
07:38:13 <Cale> ray: Most large games of minesweeper end up with at least one position in the endgame where you have to guess.
07:38:16 <benmachine> if you're clever you can skew the odds in your favour but they're still odds
07:38:22 <lilac> the very first move is always a guess
07:38:27 <ray> i've noticed having to guess, but that doesn't mean i'm not just stupid
07:38:29 <lilac> but in this version the very first move is always not a mine
07:38:38 <benmachine> yeah but the very first move is often rigged in your favour
07:38:40 <ray> yeah, even boring minesweepers seem to make the first move always not a mine
07:38:51 <ray> the one cale mentioned seems less boring
07:39:00 <osfameron> WinNT minesweeper allowed the first move to be a mine
07:39:05 <Berengal> Haha, "Sorry, you died of necessity"
07:39:05 <benmachine> ouch
07:39:28 <lilac> @hackage minesweeper
07:39:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/minesweeper
07:40:16 <benmachine> hmm
07:40:25 <benmachine> cabal: cannot configure minesweeper-0.4.1. It requires cairo >=0.10, glade
07:40:25 <benmachine> -any and gtk >=0.10
07:40:38 <benmachine> apparently none of those exist
07:41:01 <doserj> gtk2hs has to be installed by hand, still
07:42:11 <Beelsebob> is there a threadDelay that takes something bigger than an Int, or works in something less precise than s?
07:42:24 <Beelsebob> because only being able to delay for at most 2k seconds is a bit annoying
07:42:40 <Axman6> you coud write one using threaddelay
07:42:49 <Beelsebob> could
07:42:56 <Beelsebob> but it would have to spin
07:42:59 <Beelsebob> which is a bit lame
07:43:02 <Axman6> l's are so 90's
07:43:20 <quicksilver> Cale: and often one or two positions at the very beginning.
07:43:36 <quicksilver> (before you've collected a useful amount of information)
07:43:40 <Cale> quicksilver: right
07:44:02 <quicksilver> my boss is a minesweeper fiend. He can play out a large minesweeper in a minute or so.
07:44:07 <quicksilver> and very seldom makes unforced errors.
07:44:14 <quicksilver> he generally does it during meetings and phone calls :P
07:51:16 <Berengal> http://hackety.org/potion/
07:51:56 <ray> i grind video games during phone calls
07:56:06 * edwardk waves hello.,
07:56:15 * wmealing waves
07:56:59 <edwardk> Anything earth shaking reach hackage when I wasn't looking?
07:57:24 <wmealing> i'm still new to the entire game
07:57:29 <Botje> a program that solves P=NP in the type system
07:57:30 <wmealing> so i couldnt tell the difference
07:57:31 <Berengal> edwardk: Someone solved P=NP in the type system
07:57:37 <edwardk> botje: oleg again? damn it
07:57:47 <Berengal> Hehehe...
07:58:03 <ray> wake me up when they solve C++ grammar in the type system
07:58:05 <wmealing> potion looks interesting.
07:58:28 <ray> it looks like it might be fun to implement in itself
07:58:35 <wmealing> heh
07:58:55 <mreh> did anyone who watched those haskell video lectures on LtU ever make an index of all the subjects covered?
07:59:09 <Berengal> I like the guy who's making it. He seems to have such fun programming
07:59:15 <edwardk> wmealing: add = (a, b): a + b . add (2, 4) inspect -- crash. wake me when it can do a toy example ;)
07:59:29 <wmealing> edwardk: that good eh /
07:59:46 * wmealing would like to watch some video video on haskell
08:00:10 <Botje> ~ video killed the type system star ~
08:00:13 <wmealing> am going through the book, but something for the train on my ipod would be ncie.
08:00:31 * wmealing searches the tubes
08:00:34 <Berengal> http://www.haskell.org/haskellwiki/Video_presentations
08:00:35 <mreh> wmealing: http://lambda-the-ultimate.org/node/1303
08:00:41 <mreh> mine are better
08:01:12 <wmealing> thankya
08:01:40 <mreh> while you watch them, you write a table of contents
08:02:14 <Axman6> wmealing: i highly recommend anything by simon peyton jones. he's so fun to watch
08:06:16 <Berengal> I need to learn how to package stuff
08:06:24 * Berengal creates Acme.Time.Now
08:06:41 <wmealing> there is a lot to watch, thanks guys ! :)
08:07:19 <Axman6> wmealing: the data parallel haskell (or nested parallel something or other...) SPJ video is pretty cool imo
08:08:24 <Axman6> nested data parallelism i think
08:17:21 <wmealing> he's very excitable, seems like a nice guy, even if he is from MS
08:17:27 <quicksilver> he's not from MS
08:17:32 <quicksilver> he's from academia
08:17:39 <wmealing> ok
08:17:39 <quicksilver> MS just offered to pay his salary.
08:17:43 <wmealing> i see
08:18:12 <quicksilver> he was head of comp sci at glasgow uni
08:18:24 <quicksilver> I dont' recall if he did anythign between that and the MS job.
08:18:45 <lilac> why doesn't the cabal-install bootstrap.sh download and install the parsec and network packages?
08:18:49 <quicksilver> MSR cambridge pay (a rather small number of) lucky people to do fulltime salaried research with no teaching obligations :)
08:18:53 <quicksilver> it's a nice gig if you can get it.
08:19:11 <Axman6> sounds like lots of fun
08:20:49 <Axman6> actually, i want to teach
08:20:59 <Axman6> i would really like to become a lecturer
08:21:45 <rovar> of what?
08:22:05 <benmachine> does lecturing actually count as teaching
08:22:18 <rovar> it depends on whether or not the recipients are learning
08:24:41 <quicksilver> lecturing is fun; but the day-to-day business of lecturing, which includes marking, preparing notes, writing exams, etc, seriously impedes your research.
08:25:17 <quicksilver> and universities also divvy up administrative responsibility between their lecturers and the junior ones get the time consuming donkey work. Impeding your research even more.
08:25:47 <ray> it's almost like a university is a big research-impeding machine
08:25:48 <Axman6> i like teaching
08:25:58 <quicksilver> so do I.
08:26:07 <roconnor> > 1.1656 * 14299.68
08:26:08 <quicksilver> but I like research more.
08:26:09 <lambdabot>   16667.707008
08:26:16 <quicksilver> so I became a perl programmer.
08:26:19 <quicksilver> ;)
08:26:25 <Axman6> well, i'm not old enough to know if i like research yet :P
08:26:48 <ray> you've probably already wasted too much of your life not doing research
08:27:14 <Axman6> at 19?
08:27:17 <ray> i sure hope you're under 12
08:27:21 <ray> yeah, life gone, sorry
08:27:22 <ray> :(
08:27:24 <Axman6> heh
08:27:25 * wmealing laughs
08:27:47 * quicksilver always assumed Axman6 was born in 2006, hence the choice of nickname.
08:28:24 <Axman6> well, nice to know you thought i was a child prodigy
08:28:41 <rovar> i assumed he liked guitars and axman[1-5] were taken
08:28:49 <hzap> yeah, Haskell is easy! 3 year olds can learn it
08:29:10 <Axman6> i do indeed like guitars, but that's not where the name's from. it comes from my real name
08:29:38 <ray> Axman Hatchetsson
08:29:52 <mauke> Alex Mason
08:30:05 <benmachine> 6
08:30:06 <Beelsebob> Has anyone put ghc/Haskell Platform on Open Solaris any time recently?
08:30:16 <rovar> lol @ ray
08:30:34 <rovar> Beelsebob: I attempted to put it on Solaris
08:30:37 <rovar> i gave up
08:30:40 <Beelsebob> bugger :/
08:30:52 * Beelsebob has a couple of haskell programs he wants to run on his solaris box
08:30:54 <tromp> so why the 6?
08:31:15 <Axman6> axman@hotmail.com was taken
08:31:25 <Axman6> and 6 was a number i liked at the time
08:31:46 * Axman6 should register Axman3! as well
08:32:15 <mauke> preflex: nickr Axman
08:32:15 <preflex>  Axman_
08:32:30 <Axman6> eh?
08:32:34 <mauke> this is how you generate alt nicks :-)
08:32:43 <byorgey> it's like nickl but right-associative
08:32:51 <Axman6> heh
08:33:22 <rovar> preflex: nickr rovar
08:33:23 <preflex>  rovar_
08:33:38 <benmachine> preflex: nickr ben_
08:33:39 <preflex>  be_n
08:33:46 <benmachine> interesting
08:34:05 <mauke> preflex: nickr b_en
08:34:05 <preflex>  beo
08:34:10 <Axman6> preflex: nicr ___
08:34:13 <lilac> preflex: nickr 23j_4
08:34:14 <preflex>  23_j4
08:34:15 <Axman6> O.O
08:34:27 <Beelsebob> preflex: nickr ___
08:34:27 <Raynes> O.O
08:34:28 <preflex>  a__
08:34:29 <Axman6> preflex: nickr ___
08:34:30 <preflex>  a__
08:34:33 <Axman6> ah, heh
08:34:36 <rovar> preflex: (nickr . nickr . nickr) rovar
08:34:38 <Beelsebob> yes, Beelsebob'd you Axman6
08:34:50 <Axman6> i said it first
08:34:50 <rovar> preflex, hang out with lambdabot more
08:34:57 <Beelsebob> ribbish
08:35:05 <lilac> preflex: nickr nickr
08:35:06 <preflex>  nickr_
08:35:06 <Beelsebob> I even got my response back before you said it Axman6
08:35:08 <Axman6> you're rubbish!
08:35:13 <Axman6> :P
08:35:23 <mauke> anyway, this is what preflex does when its preferred nick is not available
08:35:33 <Axman6> i said mine, then  you did, then Raynes spoke, then both responses came back
08:36:10 <Beelsebob> I said mine, then raynes spoke, then mine came back, then you said yours, then yours came bac
08:36:32 <benmachine> agreed
08:36:40 <lilac> this is why multithreading is dangerous, kiddies!
08:36:44 <Beelsebob> >.>
08:36:46 <Beelsebob> <.<
08:36:58 * Axman6 concedes victory and breaks a clich
08:37:01 <quicksilver> IRC servers can be used to demonstrate the "paradoxs" of special relativity.
08:37:07 <Beelsebob> haha
08:37:18 <Beelsebob> Axman6: you reinforced a clich -- I'm always right :P
08:37:25 <rovar> heh
08:37:27 <quicksilver> unlike most network protocols IRC doesn't impose a global timeline
08:37:31 <Axman6> i still win
08:37:34 <quicksilver> it allows people local timelines which can vary
08:37:34 <Beelsebob> hehe
08:37:36 <quicksilver> it's quite interesting.
08:37:46 <Axman6> indeed
08:38:40 <Axman6> oh man, that was freaky. my CPU was using 6.66 watts, and it was 66C >_<
08:38:52 * SamB wonders what it would take for games to support that too ...
08:39:25 <Beelsebob> oops
08:39:29 <EvilTerran> SamB, FPSs with lag compensation can have a certain amount of relativity between players
08:40:17 * Beelsebob always wanted an FPS where the speed of light was somewhere between the speed you walked/ran at, and the speed you could drive vehicles at
08:40:20 * EvilTerran has caught a rocket with his face and had the guy behind him explode instead because i wasn't in the way from the firer's perspective
08:40:26 <Axman6> a friend of mine reckons that in TF2, if someone's lagging, their target area just increases, so people who shot them don't feel bad when they jerk away from the bullet
08:40:29 <Beelsebob> so you could break the light barrier, and become invisible to anyone you were going towards
08:40:52 <SamB> Beelsebob: that sounds crazy
08:40:55 <Beelsebob> >.>
08:41:03 <Axman6> or away from... sort of
08:41:04 <Beelsebob> (ofc, they would become invisible to you too)
08:41:04 * SamB wants pictures
08:41:09 <Axman6> Beelsebob: have you seen Braid?
08:41:17 <Beelsebob> Axman6: yes, its awesome and win
08:41:27 <EvilTerran> braid++
08:41:34 <Axman6> yeah, fucking epicly awesome game
08:41:37 <SamB> Beelsebob: presumably you'd have to drive based on dead reckoning of where stuff is ;-)
08:41:41 <Axman6> so well done
08:41:55 <benmachine> Beelsebob: they wouldn't be invisible to you
08:41:56 <SamB> I mean, you wouldn't be able to see anything at all
08:42:03 <Beelsebob> ben_w_: no, stuff behind you would
08:42:04 <Beelsebob> >.<
08:42:05 <benmachine> aside from the fact they'd be blueshifted up to gamma rays :x
08:42:09 <benmachine> Beelsebob: true
08:42:15 <Beelsebob> so yeh, you could drive normally
08:42:20 <Beelsebob> for a given definition of normal
08:42:24 <benmachine> heh
08:42:26 <SamB> I mean, you wouldn't be able to see stuff BEFORE you hit it
08:42:29 <Axman6> things look further away the faster you travel
08:42:37 * Beelsebob nods
08:42:40 <benmachine> are we talking about
08:42:42 <Beelsebob> but they also travel towards you faster
08:42:47 <benmachine> light slowed by its passage through air
08:42:55 <benmachine> as it is already, but hugely exaggerated
08:43:01 <koala_man> Beelsebob: but then with a 50ms lag you'd miss by 15000km
08:43:03 <Axman6> we got shown fucked up simulation videos of relativistic space travel in physics
08:43:05 <benmachine> or an actual value of c that was around 30 mph
08:43:08 <SamB> you'd need a computerized reconstruction of the terrain + projection of where stuff is
08:43:09 <Beelsebob> koala_man: rofl
08:43:24 <Axman6> you can turn saturns rings inside out if you fly through them as high speed >_<
08:43:44 <Beelsebob> SamB: that or raytrace it, and make the rays only progress a small amount each frame
08:44:17 <benmachine> Beelsebob: that sounds um
08:44:26 <benmachine> challenging
08:44:33 <Beelsebob> indeed
08:44:38 <SamB> Beelsebob: I'm talking about how it would have to work for you to be able to see where you're going
08:44:58 <Beelsebob> oh, I see
08:45:06 <Beelsebob> I thought you were trying to figure out how to render it
08:45:10 <SamB> now, the time dilation aspect would be a bit ... tricky
08:45:14 <Beelsebob> (it's not as easy as it first seems)
08:45:24 <SamB> Beelsebob: I know that's not easy
08:45:27 <Beelsebob> >.>
08:45:28 <benmachine> SamB: hence my question about whether it was c or the refractive index of air that you change
08:45:29 <SamB> but *that* has been done before
08:45:31 <benmachine> the latter is much easier
08:45:46 <Beelsebob> c
08:45:50 <Beelsebob> not the refractive index
08:45:50 <benmachine> oh
08:46:08 <Beelsebob> so yeh, time dialation would be... difficult
08:46:09 <SamB> how does the physics work then, though?
08:46:14 <Beelsebob> yeh, was just thinking that
08:46:17 <benmachine> so these cars are tachyons?
08:46:22 <Beelsebob> it would have to be a different refractive index, wouldn't it
08:47:00 <Beelsebob> the biggest problem is simply someone going faster than light -- and instantly getting infinite lag -- because their actions should have happened in the past, if you modify c
08:47:06 <SamB> only tiny particles can actually go FTL, and then only with small probability, correct?
08:47:23 <benmachine> I was under the impression that nothing could cross the light barrier
08:47:37 <SamB> well, where "can" really just means "with non-miniscule probability"
08:47:40 <Beelsebob> I was under the impression that we had not yet observed anything crossing the light barrier
08:47:48 <Berengal> leksah kicks ass at cabal
08:48:13 <SamB> I was under the impression that subatomic particles often crossed the light barrier -- that is, going backwards in time
08:48:27 <SamB> showing up as antimatter
08:48:52 <benmachine> SamB: that's not something I've ever heard but I never had a formal physics education at anything near that level
08:49:04 <Beelsebob> I've never heard of that either
08:49:09 <Beelsebob> but also, no formal physics
08:49:14 <SamB> benmachine: I wouldn't exactly claim that this was from formal education
08:49:45 <benmachine> SamB: afaik antimatter doesn't go backwards in time
08:52:25 * EvilTerran is reminded of http://www.photon.at/~werner/bh/index.en.html
08:59:23 <benmachine> netsplits obstruct physics discussions :(
09:00:24 <mauke> @localtime
09:00:28 <lambdabot> Local time for mauke is none of your concern
09:01:03 <mauke> @localtime
09:01:06 <lambdabot> Local time for mauke is approximately 18:01
09:01:30 <bgs100> @localtime
09:01:32 <lambdabot> Local time for bgs100 is Thu Jul 16 12:01:31
09:01:35 <mauke> <3 irssi scripting
09:01:39 <bgs100> :o
09:02:31 <benmachine> @localtime
09:02:34 <lambdabot> Local time for benmachine is Thu Jul 16 17:02:33 2009
09:05:18 <bgs100> @localtime-reply
09:05:19 <lambdabot> Plugin `localtime' failed with: Prelude.last: empty list
09:12:46 <Javagod> How can I tell if a list is infinite or not?
09:13:04 <tromp_> u cant
09:13:25 <tromp_> unless u can see the end:)
09:13:38 <tromp_> it's the halting problem
09:13:57 <quicksilver> you can tell if it is finite, but you can never tell if it isn't.
09:13:58 <Javagod> like i want to write a function that crashes immediately on an infinite list instead of running forever
09:14:04 <quicksilver> can't be done.
09:14:23 <Javagod> why's that?
09:14:34 <tromp_> it's worse than halting problem, cause u dont know what generates the list:(
09:14:42 <quicksilver> because infinite lists don't have a little flag at the beginning saying "I'm infinite"
09:14:49 <nvoorhies> you can't do it for all infinite lists
09:14:55 <quicksilver> at the begining all they have is a signpost saying "this way if you dare"
09:15:11 <quicksilver> there is now way to find out where the end is except to walk the path.
09:15:13 <Javagod> oh ok so no 'isInfinite' function?
09:15:16 <nvoorhies> You could do it for some kinds of infinite lists, but you're probably not interested in that
09:15:17 <quicksilver> right.
09:16:00 <Javagod> but length crashes immediately on an infinite list
09:16:07 <Javagod> > length [1..]
09:16:12 <lambdabot>   mueval-core: Prelude.read: no parse
09:16:12 <lambdabot>  mueval: ExitFailure 1
09:16:19 <quicksilver> no it doesnt ;)
09:16:27 <michie1> you could define "Infinite" as "having more than 5 elements".  That'd catch 100% of all Infinite lists.
09:16:27 <quicksilver> mueval has a timeout.
09:17:04 <byorgey> haha michie1
09:17:06 <Javagod> but how does length crash immeditely when i give it an infinite list?
09:17:11 <quicksilver> Javagod: it doesn't.
09:17:26 <Javagod> oh
09:17:35 <byorgey> Javagod: try running it in ghci on your own computer =)
09:17:45 <quicksilver> mueval crashes after 5 seconds, or some arbitrary time.
09:17:55 <quicksilver> but it would do that equally for finite lists which happened to be long enough
09:18:03 <Javagod> oh ok
09:18:06 <quicksilver> > length [1..1000000]
09:18:08 <lambdabot>   1000000
09:18:10 <quicksilver> > length [1..100000000]
09:18:15 <lambdabot>   mueval-core: Prelude.read: no parse
09:18:15 <lambdabot>  mueval: ExitFailure 1
09:18:18 <quicksilver> there you go ;)
09:18:28 <Javagod> but shouldn't length [1..] return Infinite?
09:18:35 <quicksilver> in an ideal world yes.
09:18:42 <quicksilver> but in this world, it's impossible.
09:18:44 <Javagod> > 1/0
09:18:45 <lambdabot>   Infinity
09:18:52 <Javagod> yea Infinity
09:19:07 <tromp_> no, it cant return Infinity
09:19:13 <tromp_> genericLength maybe...
09:19:22 <tromp_> which is not limited to returning Int
09:19:37 <quicksilver> doesn't solve the problem that it's impossible.
09:19:47 <Javagod> > (1::Int) / (0::Int)
09:19:47 <quicksilver> infinite length is not an observable property of haskell lists.
09:19:48 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
09:19:49 <lambdabot>    arising from a use o...
09:20:03 <byorgey> it would be possible if [1..] generated some sort of special list representation which included an 'infinite' bit
09:20:06 <byorgey> but it doesn't.
09:20:14 <doserj> genericLength returning a Peano Natural actually does return infinity, but you cannot check that it does :)
09:20:54 <tromp_> that's cause Penao is just like [()]
09:20:59 <quicksilver> true, you can return infinite representations of infinity
09:21:03 <Javagod> :t genericLength
09:21:05 <lambdabot> forall b i. (Num i) => [b] -> i
09:21:08 <quicksilver> but that somehow doesn't solve the problem ;)
09:21:19 <doserj> yeah :)
09:21:22 <Berengal> I believe Natural is more efficient than [()], but they're the same in concept
09:21:26 <Javagod> > genericLength [1..]
09:21:28 <lambdabot>   * Exception: stack overflow
09:21:44 <Berengal> > genericLength [1..] > 23
09:21:47 <lambdabot>   * Exception: stack overflow
09:22:11 <tromp_> they're isomorhpic, Zero==[], Succ== ():
09:22:16 <Berengal> > genericLength [1..] > (23 :: Natural)
09:22:18 <lambdabot>   True
09:22:33 <quicksilver> tromp_: yes, we know ;)
09:22:48 <tromp_> so equally efficient...
09:22:51 <Javagod> > length [1..] > (23 :: Natural)
09:22:53 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:23:08 <quicksilver> tromp_: but I don't think that's the implementation in LB
09:23:13 <Berengal> @index Natural
09:23:14 <lambdabot> bzzt
09:23:41 <quicksilver> tromp_: I think the LB one is binary encoded?
09:23:57 <tromp_> uhm, what's LB?
09:24:01 <Berengal> lambdabot
09:24:01 <quicksilver> lambdabot
09:24:15 <Berengal> Which implementation does \b use anyway?
09:24:21 <tromp_> oh, dunno how lambdabot implements things
09:24:36 <quicksilver> tromp_: it is possible to have Natural with much better efficiency, at any rate
09:24:40 <quicksilver> I thought LB was using http://hackage.haskell.org/package/nat
09:24:47 <quicksilver> but the type name isn't right, on reflection
09:24:49 <quicksilver> so I'm not sure.
09:25:05 <Berengal> Yeah, nat is the only package I can find too
09:25:19 <tromp_> Natural is Integer without the sign complexity
09:25:32 <Berengal> http://hackage.haskell.org/packages/archive/nat/0.2/doc/html/Data-Number-Nat1.html
09:25:37 <quicksilver> tromp_: not it's not.
09:25:39 <Berengal> That's the implementation in the nat package
09:25:43 <quicksilver> tromp_: Integer doesn't have a lazy >
09:26:03 <Berengal> Integer is just an infinite number of constructors...
09:26:18 <Berengal> Well, -ish
09:26:22 <Berengal> (It could be)
09:26:51 <Berengal> > 5 - 6 :: Natural
09:26:53 <lambdabot>   * Exception: Natural: (-)
09:27:08 <Berengal> > 5 - 1 :: Natural
09:27:10 <lambdabot>   4
09:27:16 <quicksilver> I wish there was a lamdabot interface to its packages and important
09:27:18 <quicksilver> imports.
09:27:26 <quicksilver> so you could ask it where its Natural comes from.
09:27:56 <Berengal> Yeah, it'd be nice to be able to see the \b environment
09:27:59 <tromp_> > 99999999999999999999999999999999::Natural
09:28:04 <lambdabot>   * Exception: stack overflow
09:28:09 <Berengal> > 999999999999999999999999999999999999
09:28:11 <lambdabot>   999999999999999999999999999999999999
09:28:32 <tromp_> hmm, different indeed
09:28:49 <Berengal> > 999999999999999999999999999999999999 > (999999999999999999999999999999999998 :: Natural)
09:28:55 <lambdabot>   mueval-core: Prelude.read: no parse
09:28:55 <lambdabot>  mueval: ExitFailure 1
09:29:12 <Berengal> Least that doesn't seem to smash the stack
09:29:36 <Phillemann> Can a data type or its constructor have the same name as the module it's in?
09:29:45 <quicksilver> Phillemann: certainly.
09:29:49 <Phillemann> Ah, good.
09:29:57 <quicksilver> modules are in a totally different namespace
09:30:57 <pikhq> > 1 > (9999999999999999999999999999999999999999999999999999 :: Natural)
09:30:58 <lambdabot>   False
09:31:04 <pikhq> Whoo.
09:31:20 <Phillemann> quicksilver: But you can write something like Module.Submodule.Type, where Submodule could also be a type constructor. :>
09:31:37 <quicksilver> Phillemann: there is no ambiguity.
09:31:52 <Phillemann> Allright then. :)
09:31:59 <quicksilver> Phillemann: in "A.B.C", in identifier context, "C" is a constructor, and "A.B" is a module.
09:32:09 <quicksilver> Phillemann: in type context, "C" is a type, and "A.B" is a module.
09:32:16 <quicksilver> Phillemann: and in module context "A.B.C" is a module ;)
09:32:26 <quicksilver> it's consistent and not ambiguous. It is, possibly, confusing.
09:32:27 <quicksilver> :)
09:32:43 <Phillemann> Not much, though. Thanks for the explanation.
09:33:08 <Berengal> We need better unicode support, and keyboards that can type them
09:33:19 <pikhq> Need more compose keys.
09:33:33 <pikhq> We could start by having a space cadet keyboard.
09:33:49 <Berengal> I'd prefer different layouts, and LCD keys...
09:34:17 <quicksilver> Berengal: http://www.artlebedev.com/everything/optimus/
09:34:21 <pikhq> Only if it's also a space cadet keyboard. :P
09:34:32 <Berengal> quicksilver: I know, I want, but I don't have :/
09:35:27 <Phillemann> Also, the question is if this keyboard can be configured from Linux
09:36:16 <Berengal> Optimus can't :(
09:36:48 <Phillemann> :/
09:37:04 <Berengal> Isthere achance itwill support Linux? Maybe sometime.
09:37:12 <Berengal> (quote from the FAQ)
09:39:10 <Phillemann> Well, at least it's frequently asked. :)
09:39:32 <ray> > text "thread killed"
09:39:34 <lambdabot>   thread killed
09:39:40 * Berengal contemplates sending them an email
09:39:54 <ray> but was the thread killed? we'll never know
09:40:07 <quicksilver> I'm sure if they released a little documentation on their USB protocol someone would write a driver for free.
09:40:17 <quicksilver> or possibly in return for a free keyboard :)
09:40:34 <SamB> quicksilver: who are you kidding?
09:40:36 <SamB> free!
09:41:12 <Berengal> If I knew how to write linux drivers and had decent documentation, I'd buy a keyboard just to write the drivers
09:41:21 <Phillemann> Or his money back, since you need a keyboard to write that driver.
09:41:28 <SamB> but they probably wouldn't turn down free units of future models to add support for
09:43:53 <koala_man> maybe you already have that keyboard, you've just never looked down at it before
09:44:15 <LeoD> @type text
09:44:16 <lambdabot> String -> Doc
09:44:17 <Berengal> No, I'm pretty sure I've got an Eclipse II
09:55:40 <Berengal> Hmm, http://optimus.artlebedev.com/maximus/OptimusProtocolV1.1.pdf
09:56:52 <djahandarie> Berengal, what about it?
09:57:03 <djahandarie> Oh
09:57:04 <djahandarie> lol
09:57:10 <djahandarie> Missed the conversation up there
09:59:18 <djahandarie> I couldn't possibly see why they'd make it so it would be hard to mount on Linux. Did they create a pseduo-file-system as an API to something else? Or do those files actually exist on top of a weird unsupported file system?
10:01:39 <Berengal> It seems it actually does run on linux, but it requires some minor shell magic to actually use properly
10:02:03 <Berengal> There's no programs to properly interface with it
10:21:33 <hackagebot> acme-now 1.0.0 - An interface to the philosophical and metaphysical "now" (SjurGjoesteinKarevoll)
10:22:07 <BONUS_> lol
10:22:19 <Berengal> :)
10:23:00 <conal> @hackage acme-now
10:23:01 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/acme-now
10:23:55 <Elly> heh, nice
10:24:24 * Berengal needed to learn packaging and also wanted to start the Acme hierarchy
10:24:39 <conal> oh, hrmf: now = unsafePerformIO getCurrentTime
10:24:46 <sm> Berengal: you made me look. That is a very silly package :)
10:25:00 <Berengal> conal: It's unchanging!
10:25:09 <Berengal> See Parmenides for proof
10:25:11 <roconnor> 1- (11.09/11.34)
10:25:34 <Elly> Berengal: the correct thing to do here is to define data Time = Now, then support getting the current time, deltas between times, etc. etc.
10:25:54 <Elly> the implementation will still be just as simple, but it will support all the stuff standard time things can do
10:26:23 <Berengal> Elly: Patches welcome
10:26:51 <Elly> unfortunately, my job has the same policy, and they're paying me :P
10:26:54 <conal> Berengal: http://conal.net/blog/posts/notions-of-purity-in-haskell/
10:27:09 <conal> Berengal: especially principle #2
10:27:18 <conal> Berengal: but, whatever.  have fun.
10:28:12 <Elly> conal: that's what Acme is for, as a namespace :P
10:28:23 <mauke> http://www.perlmonks.org/?node_id=275049
10:28:39 <mauke> this perl module is actually pure
10:28:48 <Elly> indeed!
10:28:49 <conal> Elly: Acme is for what?
10:28:54 <Elly> conal: silliness
10:28:57 <conal> oh
10:28:59 <Elly> see the linked perlmonks code
10:29:19 <Berengal> conal: I agree with you, but I also argue that any bugs resulting from the use of my package is either an error by the user, or an bug in GHC, for failing to take into account the unchanging nature of the universe
10:29:21 <conal> Elly: oh, as in Roadrunner & Coyote?
10:29:25 <Elly> yep!
10:29:35 <Berengal> a bug*
10:30:39 <conal> Berengal: got it!  the bug is in IO values.  they don't always return the same value, thus violating the unchanging-universe principle.
10:31:45 <conal> btw, i personally do believe in an unchanging universe.
10:32:01 <Berengal> conal: Not IO values per se, (actions in State have the same property: get doesn't always return the same value), but it's a bug in the Data.Time module that the time values are in IO ;)
10:32:04 <conal> i guess that's why functional programming works of rme.
10:32:34 <sm> fp - the eternal now!
10:32:44 <conal> amen!
10:33:20 <conal> Berengal: another Data.Time bug is that there's more than one time value.
10:34:14 <Berengal> conal: Indeed. I could've used "data Time = Now" as Elly suggested, but I wanted my library to interoperate nicely with the functionality already present (and I didn't think of it)
10:34:27 <mauke> does Data.Time allow for 4 simultaneous days in a 24 hour rotation?
10:34:41 <mauke> is it educated stupid?
10:35:02 <conal> "data Time = Now".  Nice!
10:35:28 <BONUS> time is a lie anyway. fyi.
10:36:15 <cizra> Time is an illusion. Lunchtime doubly so.
10:36:21 <BONUS> haha
10:36:29 * mauke writes Data.Time.Cube
10:36:34 <Phillemann> Is there a function which executes two (blocking) IO actions and returns if one of them returns? I want to do: either (hWaitForInput h) (takeMVar lock)
10:36:43 <Berengal> unamb?
10:36:55 <Berengal> Or was that for pure values?
10:37:10 <conal> unamb is pure.  there's also amb & race in Data.Unamb
10:37:35 <conal> @hackage unamb
10:37:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unamb
10:37:38 <conal> Phillemann: ^^
10:37:41 <sm> it may be, but if you have the urge to create effects in the physical world.. gotta work with it, right ?
10:38:06 <conal> sm: or seek therapy
10:38:24 <conal> or meditate until the urge passes
10:38:43 <mauke> I will meditate and then destroy you!
10:39:38 <Phillemann> Hmmm, race has the signature "IO a -> IO a -> IO a", "IO a -> IO b -> Either a b" would be better...but I guess I can wrap that somehow. :)
10:39:44 <sm> conal: it's a puzzle to me. If you rest in the now without urges, why do I see you apparently doing a lot of stuff ?
10:39:55 <conal> Phillemann: yeah.  fmap Left & fmap Right
10:40:27 <sm> s/you/me, anyone/
10:40:36 <conal> race (fmap Left ioa) (fmap Right iob)
10:40:48 <Phillemann> Ah, great.
10:40:50 <Phillemann> Thanks then :)
10:41:13 <lilac> tromp_, quicksilver: lambdabot uses the 'numbers' package for its Natural
10:41:14 <conal> :)
10:41:26 <benmachine> Berengal: I'm looking at acme-now.cabal
10:41:26 <benmachine> build-depends: base >=4.1 && <5, time <=1.1.3 && <1.2
10:41:38 <lilac> and it really is just 'data Natural = Z | S Natural'
10:42:25 <wjt> it'd be nice to have a function to try to take from n MVars simultaneously
10:42:29 <wjt> kind of like select()
10:42:40 <Berengal> benmachine: It would seem I forgot to save my very latest .cabal
10:42:52 <lilac> wjt: one could presumably write such a thing fairly easily
10:42:57 <Berengal> A little strange I wasn't warned about that...
10:43:15 <sinelaw> conal, thanks for the quick reply :)
10:44:02 <wjt> lilac: i guess you'd write it with n threads blocking on each MVar a, and writing to an MVar (MVar a, a) which the main thread listens on
10:44:15 <lilac> wjt: something like that, yeah
10:45:17 <lilac> wjt: although i'd generalize it to an arbitrary IO action, probably
10:45:35 <lilac> wjt: and then it's pretty much just foldM race
10:46:09 <lilac> (although it'd probably be cleaner to do it the other way around, race a b = select [a,b])
10:46:40 <lilac> or at least more efficient
10:47:39 <hackagebot> acme-now 1.0.0.1 - An interface to the philosophical and metaphysical "now" (SjurGjoesteinKarevoll)
10:48:29 <lilac> @hackage acme-now
10:48:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/acme-now
10:49:13 <sm> that's good that you can look up package urls. Someone should update lambdabot to use the shorter ones
10:49:35 <lilac> haha, that package is brilliant
10:49:56 <yitz> @. hackage faq
10:49:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/The answer is: Yes! Haskell can do that.
10:50:49 <pikhq> @. is brilliant.
10:50:49 <lambdabot> Plugin `compose' failed with: Unknown command: "is"
10:51:01 <yitz> ahh, nothing like the composition operator in Haskell
10:51:02 <lilac>  @@ is better
10:51:26 <pikhq> What's @@ do?
10:53:07 <yitz> @@ doesn't appear to do anything at all
10:53:08 <lambdabot>  doesn't appear to do anything at all
10:53:30 <mauke> @@ a @yow b
10:53:31 <lambdabot>  a My mind is making ashtrays in Dayton ...
10:53:47 <lilac> @@ @djinn @type id :: @type ($)
10:53:50 <lambdabot>  f a = a
10:53:59 <Vanadium> What
10:54:34 <lilac> that's the same as @djinn forall a b. (a -> b) -> a -> b
10:54:40 <hydo> http://gist.github.com/148557  <- Can anyone clue me in to why this would be throwing non-exhaustive pattern exceptions.
10:54:51 <lilac> because @type id :: @type ($) is the same as @type id :: (a -> b) -> a -> b, and...
10:55:02 <lilac> @@ does recursive @ expansion
10:55:03 <lambdabot> Plugin `compose' failed with: Unknown command: ""
10:55:28 <lilac> hydo: what happens when the second argument is []?
10:55:34 <benmachine> @@ @unpl @pl \x -> x + 4
10:55:34 <lambdabot>  (\ a -> 4 + a)
10:55:36 <hydo> oh
10:55:40 <benmachine> neat
10:56:04 <hydo> lilac: Thank you!  how did I forget something so basic.  ugh.
10:56:05 <yitz> lilac: right-to-left?
10:56:34 <lilac> yitz: yes, i think so
10:57:39 <themroc-> hmmm forall isnt defined in standard haskell, right?
10:58:44 <PeakerWork> themroc-: not in Haskell98, but lots of extensions enable that syntax
10:59:41 <themroc-> but it can be easily implemented with map, no?
11:00:07 <mauke> 
11:00:31 <hzap> you guys seem to be talking about completely different things
11:01:01 <PeakerWork> themroc-: the syntax? what do you mean?
11:01:25 <themroc-> im coming from oop and use forall alot and wanted to use it in haskell once and realised it doesnt exist
11:01:36 <themroc-> but found map, which is close to forall :p
11:01:42 <mauke> map has nothing to do with forall
11:01:47 <Berengal> forall is not "for each"
11:01:49 <mauke> there is no forall in oop
11:02:01 <Berengal> It's universal quantification of a type variable
11:02:34 <Berengal> mauke: Well, there is Object (and generics, or simply lack of static types, depending on the language)
11:02:41 <themroc-> ehm forall in c#?
11:02:48 <mauke> c# is not oop
11:02:57 <themroc-> hum
11:03:32 <hzap> themroc-: what's forall in c#? I don't remember such a thing
11:03:51 <themroc-> forall (element x in listofxes) bla
11:04:09 <hzap> isn't that foreach?
11:04:09 <themroc-> x becomes every element of the list
11:04:10 <LeoD> you mean foreach
11:04:13 <themroc-> omg
11:04:18 <themroc-> <- brainsmashed
11:04:34 <themroc-> sorry guys :(
11:04:41 <hzap> haskell has forM
11:04:44 <PeakerWork> themroc-: "forall" is a "universal quantifier" on types
11:05:00 <lilac> themroc-: forall exists in the type fragment of haskell, not the value fragment. it's a universal quantifier for type variables.
11:05:17 <Vanadium> universal quantifier does not actually mean anything to an OOP programmer, hth
11:05:18 <themroc-> i see
11:05:33 <densem> * warning : total noob question * what's the difference between forall a in A as predicate over a, and foreach listElem in List / predicate over listElem
11:05:50 <smorg> c# has quantifiers eh?
11:06:42 <yitz> @hoogle for
11:06:42 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
11:06:43 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
11:06:43 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
11:06:52 <Berengal> densem: foreach is a looping construct, while forall is a quantifier in logic
11:08:09 <densem> yeah , I grasp the subtlety a tiny bit , but isn't the foreach meaning of life is to forget about the list structure and think in terms of "sets" ?
11:09:12 <themroc-> ahh now i know what you mean
11:09:17 <smorg> That would be stateful. Like bash/python: for <value> in <domain> .....
11:09:19 <yitz> densem: forall is used to define a set of types, it is used to typecheck at compile time. "foreach" iterates over a structure at runtime
11:09:20 <themroc-> the upside down A
11:09:22 <Berengal> densem: Depends on which language you're looking at. They do share some similarities thuogh, yes
11:09:36 <themroc-> i had logic
11:10:04 <yitz> 
11:17:16 <conal> i had logic but i eated it
11:19:05 <PeakerWork> conal: hey, are you well-versed in dependent types? Have you toyed with Agda/Epigram/etc?
11:19:20 <Beelsebob> do we have any library able to read a date/time string into a sensible value?
11:19:31 <PeakerWork> @hoogle parseTime
11:19:32 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
11:19:32 <lambdabot> Data.Time.Format class ParseTime t
11:19:59 <Beelsebob> that needs me to give it the format the time is in
11:20:08 <Beelsebob> I was hoping for one that would make a guess at the format from the input
11:20:30 <densem> yitz : Okay for the compile time meaning vs runtime computations, I think I'm still far away from those topics *reading the haskellwiki entry*
11:23:09 <yitz> densem: ok :) I find that I don't need "forall" very often in practice.
11:23:56 <yitz> densem: if you've done OOP in the past, you're probably best off ignoring forall until you're really comfortable with FP :)
11:25:02 <densem> you almost caught me ^^
11:25:15 <monochrom> "foreach i ... print(i)" vs "forall i... i>0" is the same question as "print(i)" vs "i>0".
11:25:38 <smorg> If you ever use prolog, it only has universal quantification. Used all the time.
11:25:46 <densem> i didnt talk about instruction over a set of value
11:26:02 <densem> just list of a + foreach -> list of something else
11:26:20 <Taejo> :t filterM
11:26:22 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:26:27 <monochrom> So you have "foreach i... i>0" ?
11:26:46 <densem> yeah something like that
11:26:54 <cizra> Can I  have scope-local types?
11:27:07 <monochrom> Which language is it?
11:27:34 <densem> sorry, i didnt meant a linguistic construct
11:27:45 <densem> just the way i use foreach statements in java or such
11:27:47 <yitz> cizra: only at the module level
11:28:07 <cizra> yitz: oh.. Thanks
11:28:08 <densem> set -> foreach + predicate -> other set
11:28:11 <monochrom> But java's foreach is "foreach i ... print(i)" rather than "foreach i ... i>0".
11:28:26 <Dridus> densem: map for doing something to each list element, mapM or mapM_ for performing an action on each element in a list
11:28:43 <densem> yeah, foreach i .. resultList.add i
11:28:52 <lilac> Beelsebob: how could that work? given "01/02/03", is that Jan 02 2003? or Feb 01 2003? or something else? seems like it needs at least a clue as to the user's locale
11:28:53 <Dridus> densem: and then about a million other functions for various other awesome processing of lists and other structures
11:29:17 <yitz> lilac: there are ambiguous cases, but often you can get it right.
11:29:20 <monochrom> Then I have already said, it's the same question as "print(i)" vs "i>0".
11:29:34 <Beelsebob> lilac: in this case I wouldn't mind the function being in IO and asking the OS which way round it is
11:29:35 <densem> Dridus : thanks, I was just doing the noobie about the distinction about the meaning of foreach over lists and forall
11:29:46 <lilac> yitz: if it can't get the /common/ cases right (mm/dd/yy vs dd/mm/yy) then i don't care if it gets more difficult cases right! :)
11:30:06 <Dridus> densem: haha yeah, don't pay attention to forall for now, it's for the type system as other people have mentioned
11:30:11 <monochrom> But perhaps no one likes my reductionism.
11:30:29 <Dridus> monochrom: I like your reductionism
11:31:02 <lilac> Beelsebob: ah, right. you could spawn 'at -v' then kill it after it prints its interpretation of the time :)
11:31:06 <yitz> lilac: I don't know Beelsebob's use case. But, for example, you might want parse the "Date" header in mail messages that violate the RFC and do whatever they feel like.
11:31:15 <densem> monochrom : i see what you mean, but i still beg to differ ^^; cause my use of for loops isnt about doing something at each value, but to jump for types to other types ( imperatively yes )
11:31:29 <densem> *from
11:31:41 <yitz> lilac: those probably won't be nn/nn/nn, but will have various month name, time, year, day of week thingies in some unspecified order.
11:32:11 <PeakerWork> densem: there's a fundamental difference between a   all (map (>0) container)  (a "pure" foreach)   and a  foreach item: print(item)         the latter "combines" actions in a loop into a larger action
11:32:23 <monochrom> What is "jump for types to other types"? Sorry I have never heard of i.
11:33:01 <lilac> yitz: yeah, that could be handy. maybe just do it like reads, String -> [(Date, String)]
11:33:14 <densem> sorry, typo here, i meant from type to type, A -> B
11:33:17 <yitz> lilac: yeah
11:33:33 <hzap> densem: then that's just map
11:34:39 <monochrom> I guess I don't know *whose* "foreach" we're talking about. One minute it's Java's foreach. Another minute it's someone else's new invention.
11:34:58 <yitz> Beelsebob: wait, I think darcs has something like that. for --match 'date ...'
11:35:00 <densem> nevermind, sorry for being blurry
11:35:09 <PeakerWork> densem: the foreach here can be divided into 2 parts:  Applying a pure computation on each element, that may result in a new type.  That runs independently on each element so cannot do things like "print" (as prints/actions have to be ordered)
11:35:10 <Beelsebob> yitz: hmm, good point
11:35:16 <monochrom> The general correct answer is: you give it semantics, then you see its difference with other things.
11:35:47 <yitz> Beelsebob: it also supports things like "yesterday", "last year"
11:35:49 * lilac wonders if 'at's time parsing is in a library somewhere -- it's very good
11:35:56 <PeakerWork> densem: The second thing a foreach can do is "accumulate" some value over the whole list, or "fold" the list into a value.  e.g: Summing a list (pure computation)  or  "Summing" a bunch of little actions like "print"  into one big action that prints all of the values (Also a pure computation, because it just builds a big action, it doesn't yet print anything!)
11:36:30 <lilac> 'at' allows '3pm tomorrow' and 'teatime next Tuesday'
11:36:51 <PeakerWork> densem: so,  Haskell has the first kind of foreach via "map".  the latter kind is via "foldr/foldl/etc".
11:36:55 <PeakerWork> @src sequence
11:36:55 <lambdabot> sequence []     = return []
11:36:56 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:36:56 <lambdabot> --OR
11:36:56 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
11:37:01 <PeakerWork> @src sequence_
11:37:01 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
11:37:05 <Berengal> foldr is all you need...
11:37:21 <densem> PeakerWork : folding filtering mapping morphisms I think I do understand, I was just wondering how `forall` fit on top of that
11:37:26 * lilac builds a NAND gate out of foldr then laughs maniacally
11:37:31 <PeakerWork> Berengal: yeah, because foldr is allowed NOT to accumulate, map is still a rather interesting special case of foldr
11:37:46 <PeakerWork> densem: I thought we were talking about foreach in other languages VS Haskell
11:37:55 <lilac> densem: it really doesn't. forall is something quite different
11:38:02 <PeakerWork> dancor: I think one of the keys to understanding Haskell's various loops is understanding sequence_
11:38:11 <PeakerWork> oops
11:38:14 <PeakerWork> densem: ^^
11:38:15 <yitz> lilac: traditional at is actually somewhat limited, see the man page
11:38:32 <lilac> yitz: yeah, a lot of that is gnu extensions, but they're /nice/ :)
11:38:38 <Berengal> map f = foldr ((:).f) []; filter p = foldr (\x -> if p x then (x:) else id) []
11:38:54 <yitz> PeakerWork: everything rather interesting is a special case of foldr
11:39:02 <lilac> even foldl ;-)
11:39:09 <pikhq> densem: forall is like the words "For all" in, say, the phrase "For all x, x < 2". Except only as a type notation.
11:39:10 <Berengal> reduce = foldr
11:39:38 <PeakerWork> yitz: yeah, an "accumulating fold" can do everything
11:39:39 <densem> So it's just some kind of type constraint
11:40:14 <densem> like if i had a constructor to create a type T asserting that any value it yield will have that property ( in you case being a number less than 2 ) ?
11:40:35 <PeakerWork> I'm trying to illustrate to densem what non-accumulating folds can do (can be parallelized on the whole list!), and what accumulating folds can do (probably depend on the computation on former elements), and how those relate to action-loops (e.g print example)
11:40:35 <desp> I'm having fun with the Haskell type system.
11:40:36 <mornfall> Is there like ... iterate until fixpoint?
11:40:36 <Berengal> It's a type uncontraint :)
11:40:47 <PeakerWork> densem: I wasn't talking about types here
11:40:51 <densem> and the haskell system look that up before running ?
11:40:54 <desp> Is it possible to write a "map" type function?
11:41:11 <densem> haha damn I'm so unprecise
11:41:43 <yitz> > fix ((1:) . map (+1))
11:41:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:42:10 <yitz> mornfall: ^^
11:42:30 <mornfall> yitz: module?
11:42:31 <pikhq> desp: A 'map' function like what? map?
11:42:37 <yitz> @hoogle fix
11:42:38 <lambdabot> Data.Function fix :: (a -> a) -> a
11:42:38 * cizra is trying to write an AI playing tic-tac-toe. Phear my soon-to-be creation taking over the world!
11:42:38 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
11:42:38 <lambdabot> module Control.Monad.Fix
11:42:49 <mornfall> Oh, Ok.
11:43:01 <mornfall> Thanks. :)
11:43:17 <pikhq> @src fix
11:43:18 <lambdabot> fix f = let x = f x in x
11:43:38 <mornfall> I now realise that fix is not going to be the most efficient implementation ever, anyway.
11:43:57 <mornfall> But maybe I can fix that later.
11:44:00 <yitz> mornfall: it might be efficient, but no one will be able to read it.
11:44:11 <yitz> mornfall: fix that later?
11:44:48 <pikhq> > fix (\_ -> 1)
11:44:50 <lambdabot>   1
11:45:12 <mornfall> yitz: Well, it's for live object marking. ;)
11:45:28 <PeakerWork> > let fix f = result where result = fix result in fix (1:)
11:45:29 <lilac> > let foldl f x xs = foldr (flip (.) . flip f) id xs x in foldl f x [1,2,3,4,5]
11:45:29 <mornfall> I'm not sure there's a better application for fix...
11:45:30 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
11:45:31 <lambdabot>    arising from a use ...
11:45:31 <lambdabot>   f (f (f (f (f x 1) 2) 3) 4) 5
11:45:37 <desp> A "map" function operating on types.
11:45:37 <desp> @hoogle asTypeOf
11:45:38 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:45:40 <PeakerWork> > let fix f = result where result = f result in fix (1:)
11:45:42 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:45:43 <lilac> @quote lilac fix
11:45:44 <lambdabot> lilac says: fix f = fix where fix = f fix
11:45:48 <PeakerWork> I like "where" better than "let"
11:46:09 <lilac> i like palindromic better than non-palindromic
11:46:46 <yitz> > let f g x | x<2 = 1 | otherwise = x * g (x - 1); factorial = fix f in factorial 6
11:46:48 <lambdabot>   720
11:47:24 <mornfall> Umm. And a monadic Data.Map map? (I'm all clear today, for sure.)
11:47:24 <Berengal> let iters = iterate f ?start; isFixed = zipWith (==) iters (tail iters) in fst . head . dropWhile (not.snd) . zip iters $ isFixed
11:48:15 <mornfall> @hoogle (a -> m b) -> Map k a -> m (Map k b)
11:48:15 <lambdabot> Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
11:48:16 <lambdabot> Data.Map updateMax :: (a -> Maybe a) -> Map k a -> Map k a
11:48:16 <lambdabot> Data.Map updateMin :: (a -> Maybe a) -> Map k a -> Map k a
11:48:20 <mornfall> Pff.
11:48:20 <void9> > pl \x y -> flip (-) 100 (foldl (+) x y)
11:48:22 <lambdabot>   <no location info>: parse error on input `\'
11:48:36 <void9> > pl \x y -> flip (-) 100 (foldl (+) x y)
11:48:38 <lambdabot>   <no location info>: parse error on input `\'
11:48:39 <pikhq> yitz: I think that's the nicest definition of factorial I've seen. :)
11:49:07 <yitz> lilac: i like palindromic betteb cimordnilap ekil i
11:49:40 <void9> > pl \x y -> x y
11:49:42 <lambdabot>   <no location info>: parse error on input `\'
11:49:42 <yitz> pikhq: heh. that's how they do it in the lambda calculus.
11:49:43 <pikhq> void9: You may want this:
11:49:58 <pikhq> @pl \x y -> flip (-) 100 (foldl (+) x y)
11:49:58 <lambdabot> (subtract 100 .) . foldl (+)
11:50:04 <void9> :)
11:50:12 <pikhq> yitz: Hmm.
11:50:16 <LeoD> mornfall: i think Map is an instance of Traversable
11:50:18 <yitz> pikhq: you may enjoy unlambda
11:50:42 <pikhq> yitz: I've not done much coding in it, but I'm aware of it.
11:51:19 <mornfall> LeoD: That's starting to sound involved... :|
11:51:33 * cizra kisses list comprehensions
11:51:56 <LeoD> mornfall: nah you'd just import Data.Traversable and use its mapM on your map
11:53:29 <mornfall> LeoD: Ok, thanks, will try.
11:53:41 <smorg> I swear I learn more reading what people paste here than reading books.
11:54:06 <yitz> smorg: anyway, it's more fun than books
11:58:05 <lilac> hah, i love this minesweeper, especially setting it to 90 mines and then appearing telepathic
12:03:28 <Fairweather>  for some reason the definition of fix above crashes ghc on fix (0*)
12:03:55 <yitz> Fairweather: which definition? which ghc?
12:04:04 <copumpkin> need to run fix error to fix your errors!
12:04:30 <yitz> > fix error
12:04:32 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:04:59 <Fairweather> yitz: fix f = let x = fix x in x
12:05:17 <copumpkin> looks like fix is broken, maybe we need to fix (const (fix error)) first
12:05:20 <Fairweather> the other definition (fix f = f (fix f))
12:05:38 <Fairweather> gives stack overflow just fine
12:05:56 <copumpkin> :P
12:06:11 <yitz> Fairweather: notice that the first one doesn't use f
12:06:34 <void9> @pl \x y -> f (g x y)
12:06:34 <lambdabot> (f .) . g
12:07:03 <Fairweather> um, sorry, it's "let x = f x in x"
12:07:12 <yitz> > let fix _ = let x = fix x in x in fix (0*)
12:07:14 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
12:07:14 <lambdabot>    arising from a use of `...
12:07:41 <mornfall> @src fix
12:07:42 <lambdabot> fix f = let x = f x in x
12:07:45 <mornfall> : - )
12:07:48 <mornfall> (once again)
12:08:06 <mornfall> How does mfix work, anyway?
12:08:58 <mornfall> @src mfix
12:08:58 <lambdabot> Source not found. Take a stress pill and think things over.
12:09:03 <Beelsebob> @hoogle ClockTime -> ClockTime -> Integer
12:09:04 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
12:09:04 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
12:09:04 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:09:06 <Beelsebob> hmm
12:09:07 <Beelsebob> :/
12:09:13 <Beelsebob> no way to get the number of seconds between two times?
12:09:28 <monochrom> * is so eager that 0*undefined is still undefined.
12:09:54 <monochrom> I mean unless you write your own Num and you define your own * to be lazy.
12:10:10 <Fairweather> I see
12:10:18 <pikhq> @src [] mfix
12:10:19 <lambdabot> mfix f = case fix (f . head) of
12:10:19 <lambdabot>            []    -> []
12:10:19 <lambdabot>            (x:_) -> x : mfix (tail . f)
12:10:28 <pikhq> I'm pretty sure that's a per-instance function. ;)
12:10:30 <CosmicRay_> lemmih: do you maintain fastcgi?
12:11:46 <monochrom> http://www.haskell.org/haskellwiki/MonadFix  explains mfix
12:12:12 <monochrom> Oh I'm so procastinating a section on the mfix laws.
12:12:27 <Berengal> Beelsebob: diffTime?
12:12:27 <mornfall> I already found some docs, thanks. :)
12:12:35 <void9> @unpl (f .)
12:12:36 <lambdabot> (\ a d -> f (a d))
12:12:38 <Beelsebob> @type diffTime
12:12:38 <yitz> @google Value Recursion in Monadic Computations
12:12:39 <lambdabot> Not in scope: `diffTime'
12:12:41 <lambdabot> http://citeseer.ist.psu.edu/590305.html
12:12:42 <mornfall> I just now realised that the original "fix" answer was wroooong. :)
12:12:45 <Beelsebob> @hoogle diffTime
12:12:45 <lambdabot> Data.Time.Clock data DiffTime
12:12:45 <lambdabot> Data.Time.Clock data NominalDiffTime
12:12:45 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
12:12:49 <mornfall> And let me completely astray.
12:12:59 <mornfall> I said "iterate until fixed point"...
12:13:06 <mornfall> :t iterate
12:13:08 <lambdabot> forall a. (a -> a) -> a -> [a]
12:13:19 <mornfall> @hoogle (a -> a) -> a -> a
12:13:20 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
12:13:20 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
12:13:20 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
12:13:30 <mornfall> Pff.
12:13:42 <Berengal> mornfall: let iters = iterate f ?start; isFixed = zipWith (==) iters (tail iters) in fst . head . dropWhile (not.snd) . zip iters $ isFixed
12:13:53 <mornfall> Berengal: Ouch.
12:14:02 <Beelsebob> Berengal: where's it defined?
12:14:09 <CosmicRay_> argh.
12:14:19 <CosmicRay_> programs/fastcgi-3001.0.2$ ./setup build
12:14:20 <CosmicRay_> Preprocessing library fastcgi-3001.0.2...
12:14:20 <CosmicRay_> Building fastcgi-3001.0.2...
12:14:20 <CosmicRay_> Binary: Int64 truncated to fit in 32 bit Int
12:14:20 <CosmicRay_> ghc: panic! (the 'impossible' happened)
12:14:20 <CosmicRay_>   (GHC version 6.10.3 for i386-unknown-linux):
12:14:22 <CosmicRay_>         Prelude.chr: bad argument
12:14:24 <CosmicRay_> known?
12:14:31 <mornfall> CosmicRay_: Purge .hi files.
12:14:35 <mornfall> CosmicRay_: Known. :)
12:14:54 <Berengal> Beelsebob: Sorry, diffUTCTime, in Data.Time
12:14:59 <Oejet> Beelsebob: In the "time" package on Hackage.
12:15:10 <CosmicRay_> mornfall: ok, I feel really silly not noticing that now.
12:15:11 <CosmicRay_> thanks.
12:15:24 <mornfall> Np.
12:15:28 <mornfall> I feel silly about fix.
12:15:33 <monochrom> This is why I dislike "have you heard of fixed points in real analysis?" when explaining fix and mfix.
12:15:36 <mornfall> Anyway, I better crash to bed or something. Goodnight. :)
12:16:01 <Beelsebob> Berengal: I see no way in that API to construct a UTCTime given y/m/d h:m:s
12:16:31 <CosmicRay_> Beelsebob: convertible has some handy functions to convert.
12:16:59 <yitz> > let stable (x:xs@(x':_)) | x == x' = x | otherwise = stable xs in stable . iterate ((+1).(/3)) $ 10
12:17:01 <lambdabot>   1.5
12:17:07 <Berengal> data UTCTime = UTCTime :: Day -> DiffTime -> UTCTime, Fields: utctDay utctDayTime
12:17:13 <yitz> mornfall: ^^
12:17:16 <CosmicRay_> Beelsebob: also not that UTCTime is an instance of FormatTime
12:17:20 <monochrom> It is even shallower than "empty set is empty, empty list is empty, both is empty!"
12:17:50 <CosmicRay_> instance Convertible ZonedTime UTCTime where
12:17:50 <CosmicRay_>     safeConvert = return . zonedTimeToUTC
12:18:11 <CosmicRay_> so you can build up a zoned time and use zonedTimeToUTC
12:18:36 <CosmicRay_> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-LocalTime.html
12:18:41 <Oejet> CosmicRay_: No online docs for "convertible"?
12:19:04 <monochrom> We need a new meme of the form "xxx is like yyy except xxx has nothing to do with yyy".
12:19:23 <CosmicRay_> Oejet: http://hackage.haskell.org/packages/archive/convertible/latest/doc/html/Data-Convertible.html
12:19:38 <yitz> The datetime package is an easier to use wrapper for many common cases
12:20:04 <monochrom> Example: CPO fixed point is like metric space fixed point except CPO fixed point has nothing to do with metric space fixed point.
12:20:27 <Berengal> fixed point is like fixed point except fixed points have nothing to do with fixed points
12:20:48 <Oejet> CosmicRay_: Thanks. How could I have found that?
12:20:52 <yitz> @hackage datetime
12:20:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/datetime
12:21:00 <CosmicRay_> Oejet: looking at older versions on the hackage page.
12:21:24 <CosmicRay_> Oejet: apparently the hackage server couldn't build current versions.  sigh.  date instances subtly changing between versions are biting me again.
12:23:40 <Oejet> CosmicRay_: Stupid type system! :)
12:24:23 <CosmicRay_> Oejet: yeah, totally!  I mean, nobody would even SEE that on a production system until after it's been live for at least 6 months!
12:24:33 <CosmicRay_> Oejet: and by then they'd have contracted it out to India anyhow!
12:25:02 <CosmicRay_> <-- extra snarky today, evidentally.  perhaps it's because my nick has been hijacked.  sigh.
12:25:27 <medfly> it wouldn't be hijacked if it was yours
12:25:52 <jatqceer> Anyone using scion in emacs?
12:25:58 <CosmicRay_> medfly: ahh, but that is where you are wrong.  apparently on freenode, they delete nickserv registrations if you don't identify to nickserv every 60 days, even if you actively use it.
12:26:02 <CosmicRay_> medfly: I didn't realize this.
12:26:22 <CosmicRay_> medfly: because they didn't do it when I registered cosmicray back when this network was known as linpeople
12:26:29 <jatqceer> I can't make scion-server to work with emacs
12:26:32 <void9> i have a trace template.  i would like to stick the currentFunctionName in the template.  can i do so from Template Haskell?
12:26:36 <CosmicRay_> medfly: and I only identified when I needed to protect my nick, which was rare.
12:29:17 <Oejet> Beelsebob: Did you find it out, what you wanted to find out? I'd like to know how you solved it, since I am a bit confused about Time-stuff.
12:29:27 <RayNbow> CosmicRay_: you didn't register your nick through NickServ?
12:29:41 <Beelsebob> Oejet: no -- the Time APIs seem to be a bit underpowered to do what I want
12:29:50 <Beelsebob> I would need to write a crap load of extra code
12:30:00 <CosmicRay_> RayNbow: I did.   but see what I said about it getting deleted.
12:30:14 <CosmicRay_> RayNbow: they delete nicks that haven't identified to nickserv in 60 days.
12:30:32 <CosmicRay_> RayNbow: even though I was active within that time period, I only identify when I need to prevent a hijack, which is rare.
12:30:44 <cizra> Is there a standard function that removes duplicates from a list?
12:30:46 <RayNbow> hmm
12:30:47 <CosmicRay_> RayNbow: they didn't have that policy when I registered my nick with nickserv, and didn't notify me of the change, so I didn't know.
12:30:53 <Apocalisp> cizra: nub
12:31:00 <cizra> Apocalisp: thanks!
12:31:08 <Apocalisp> cizra: Warning, it's slow.
12:31:14 <RayNbow> would they also delete nicks if you managed to stay online for 60 days?
12:31:22 <cizra> Apocalisp: n*log(n)?
12:31:22 <CosmicRay_> evidentally yes
12:31:32 <Apocalisp> @src nub
12:31:32 <lambdabot> nub = nubBy (==)
12:31:34 <RayNbow> even if you identified at the start of that session?
12:31:35 <cizra> Apocalisp: oops, no, n^2
12:31:37 <Apocalisp> @src nubBy
12:31:37 <lambdabot> nubBy eq []             =  []
12:31:37 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:31:38 <CosmicRay_> RayNbow: this is yet another example of why I have long favored moving this channel to OFTC
12:31:53 <Oejet> Beelsebob: Today in fact, I wanted to convert a (year, month, day, hour, min, sec) to seconds after the epoch...I did not find any useful function for that.
12:32:22 <Apocalisp> cizra: Yup, n*n
12:32:30 <Beelsebob> Oejet: what I'm trying to do atm is convert things like "tomorrow at 15:35" into seconds-from-now
12:32:44 <Beelsebob> which, even after you've parsed that usefully, seems to be near impossible
12:33:03 <desp> I'm trying to generalize a zip on types to a zipWith on types.  I'm not sure how to do that.  Here's what I mean: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7085#a7085
12:33:52 <desp> Oleg appears to utilize a higher-order function on types in http://okmij.org/ftp/Haskell/PeanoArithm.lhs (Inv)
12:33:53 <Oejet> Beelsebob: Would "seconds-from-now" not be changing all the time?!
12:34:04 <desp> But he dismisses it as "trivial", while for me it's anything but. :)
12:34:06 <cizra> Apocalisp: It could be reduced to NlogN for Ords.
12:34:16 <Beelsebob> Oejet: no, I only need it once, and plus or minus 1 second is good enough
12:34:40 <Apocalisp> cizra: Bingo. Sort, then fold.
12:36:04 <pikhq> @hoogle RealFrac a -> Num a
12:36:05 <lambdabot> Warning: Unknown type RealFrac
12:36:05 <lambdabot> Prelude id :: a -> a
12:36:05 <lambdabot> Data.Function id :: a -> a
12:36:15 <soupdragon> oh man
12:36:20 <Oejet> Beelsebob: If there were a function to (parse and) convert a date into seconds-since-epoch, then it would just be the difference.
12:36:47 <Beelsebob> Oejet: quite
12:37:55 <Deewiant> @hoogle (RealFrac a, Num b) => a -> b
12:37:56 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
12:37:56 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
12:37:56 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
12:38:45 <yitz> Beelsebob: in the datetime package, it's just subtract `on` toSeconds
12:38:57 <deech> Hi all, what is the best way to "show" a type? GHCI won't let me "derive Show" on "type X = ..." as it will with "data A = A ...". Do I have to hand-roll a print function?
12:39:19 <Oejet> CosmicRay_: Did you write all those instances of conversion from some "number" type to some other "number" type by hand?!
12:39:28 <Petrosian> deech: You don't need to
12:39:37 <Petrosian> deech: `type' just creates a synonym
12:39:39 <CosmicRay_> Oejet: no, there was some magic initially ;-)
12:39:54 <Petrosian> deech: The instance for Show that exists on the type your using still applies
12:40:38 <Oejet> CosmicRay_: How did you do the "Convertible POSIXTime Int" instance, which to me is not very obvious?
12:40:39 <Petrosian> deech: so `type Filename= String' for example, would use the Show instance for String when showing a Filename, assuming it has one
12:41:02 <CosmicRay_> instance Convertible POSIXTime Integer where
12:41:02 <CosmicRay_>     safeConvert = return . truncate
12:41:13 <CosmicRay_> oh you wanted int
12:41:18 <CosmicRay_> instance Convertible POSIXTime Int where
12:41:18 <CosmicRay_>     safeConvert = boundedConversion (return . truncate)
12:41:22 <CosmicRay_> but really it's the same thing
12:41:36 <deech> petrosian, I currently have a type X = TVar ..., and running show on X gets me a compile error.
12:41:47 <CosmicRay_> boundedConversion is a Convertible thing that checks to make sure the result would fit within the bounds for the destination type, and raises an exception if not (instead of returning garbage)
12:41:50 <Oejet> CosmicRay_: Hm...that does not make me any wiser. :)
12:41:57 <CosmicRay_> truncate?
12:41:57 <Petrosian> deech: TVar probably doesn't have an instance of Show in that case
12:42:10 <deech> petrosian, ooh I need to stick it in an atomically don't I!
12:42:11 <CosmicRay_> truncate is a generic function:  Prelude> :t truncate
12:42:11 <CosmicRay_> truncate :: (RealFrac a, Integral b) => a -> b
12:42:24 <CosmicRay_> so presumably POSIXTime is an instance of RealFrac
12:42:36 <Oejet> CosmicRay_: It is!
12:42:40 <hzap> deech: there isn't really a good way to show a TVar
12:42:49 <CosmicRay_> Oejet: see also floor, round, etc.
12:42:54 <CosmicRay_> any could be used to do this.
12:43:12 <CosmicRay_> but the point of convertible is that when you don't care about the difference, you don't have to remember it ;-)
12:43:31 <deech> unsafePerformIO it is!
12:44:33 <Petrosian> deech: I've never worked with TVar, but presummably you need to use readTVar and atomically to print it
12:44:35 <Oejet> CosmicRay_: I did not know about "convertible", and I did not think about "floor" at first, so it took some searching to find that conversion.
12:44:47 <Petrosian> deech: judging by the documentation, that is
12:44:50 <deech> or unsafeIOToSTM
12:44:51 <Dridus> deech: you can't unsafePerformIO . atomically, BTW
12:45:05 <CosmicRay_> Oejet: me too.
12:45:19 <CosmicRay_> Oejet: that's why I put it in convertible ;-)
12:45:25 <CosmicRay_> convertible is typesafe casting :-)
12:45:55 <hzap> deech: if you really want a Show instance, you'll have to print out some dummy string for the TVar's contents
12:46:36 <Oejet> Beelsebob: Do you know how to convert to and from seconds-since-epoch?
12:47:31 <Beelsebob> it was mentioned up channel a bit
12:50:09 <desp> All right, got it. :)
12:54:59 <CosmicRay_> Oejet: A lot of these questions can be answered by reading the source to Data/Convertible/Instances/Time.hs even if you don't use Convertible
12:55:21 <shachaf> @seen gwern
12:55:22 <lambdabot> I saw gwern leaving #darcs, #xmonad and #haskell 9h 13m 49s ago, and .
13:01:23 <Lemonator> so I'm trying to build lambdabot.
13:01:40 <Lemonator> besides the number of seemingly useless dependencies,
13:01:54 <Lemonator> I have a compiling problem that I do not know how to fix.
13:02:01 <Lemonator> Plugin/Undo.hs:11:7:
13:02:01 <Lemonator>     Could not find module `Data.Generics':
13:02:20 <Lemonator> But when I fire up ghci and do > import Data.Generics
13:02:25 <Lemonator> the module loads fine.
13:02:30 <Lemonator> what could be the problem here?
13:03:27 <twanvl> maybe the package it is in is not listed in the cabal file
13:04:02 <dons> 6.10.3 is out, btw, http://www.reddit.com/r/programming/comments/91vk0/ghc_version_6104_is_now_out/
13:05:51 <CosmicRay_> dons: BTW, I heard there's an RWH app for the iphone.  I don't have an iphone and didn't even know about the app.  any idea what it does?
13:06:06 <HugoDaniel> dons: didnt 6.10.3 already been released ?
13:06:12 <beutdeuce_> i keep getting a unification would give inifinite type error
13:06:14 <CosmicRay_> and oh joy, just as debian is finally getting 6.10.3 fixed, heh
13:06:16 <dons> CosmicRay_: from what I hear, it is a bundled reader + ebook
13:06:20 <CosmicRay_> an
13:06:21 <dons> CosmicRay_: tied to the iphone
13:06:34 <dons> (so less portable than say, the .pdf, but works out of the box on the iphone)
13:06:35 <Lemonator>      it is a member of the hidden package `syb-0.1.0.0'
13:06:43 <Lemonator> what's that mean?
13:06:49 <Lemonator> can I "unhide" packages, then?
13:06:54 <void9> @pl \x -> (-) (abs x) 100
13:06:54 <dons> Lemonator: syb is a missing dependency in the .cabal file
13:06:55 <lambdabot> subtract 100 . abs
13:08:25 <Lemonator> Jesus H. Christ.
13:11:55 <jeffwheeler> Lemonator: if you have the source, you can just edit the .cabal file and add it
13:12:01 <Lemonator> I did.
13:12:07 <Lemonator> Now there's a type error.
13:12:17 <jeffwheeler> What package is this?
13:12:23 <Lemonator> Plugin/Dict/DictLookup.hs:33:4:
13:12:23 <Lemonator>     Ambiguous type variable `e' in the constraint:
13:12:23 <Lemonator>       `GHC.Exception.Exception e'
13:12:35 <CosmicRay_> dons: ah, thanks
13:14:26 <tommd> Lemonator: That package was made for a different version of ghc than you currently use.  The Exception mechanism was altered from 6.8 to 6.10.
13:14:54 <tommd> Not all packages have caught up yet.
13:14:56 <Lemonator> oh, thanks.
13:15:12 <themroc-> hmm how would a version of map look like that takes one element and a list of functions, applies all functions to the element and returns a list of every result?
13:15:17 <Lemonator> does this mean I actually have to downgrade to 6.8 to build lambdabot?
13:15:20 <themroc-> or better: how would look such a list?
13:15:49 <benmachine> Lemonator: pretty sure I didn't have to
13:15:52 <benmachine> did have to jump through a few hoops though >_>
13:15:58 <tommd> Lemonator: Or fix lambdabot (probably not trivial, but not too bad if you understand the exception changes)
13:15:59 <benmachine> wait I can't remember
13:16:06 <hzap> > map ($ "blah") [show . length, id, (++ "blah")]
13:16:08 <lambdabot>   ["4","blah","blahblah"]
13:16:14 <Gracenotes> hm. I may as well get over my incompatibility fears and update my linux kernel
13:16:16 <benmachine> it's possible that some of it I compiled a long time ago
13:16:17 <Lemonator> I've never used exceptions in Haskell before.
13:16:24 <paolino> Lemonator: you can correct the import statement
13:16:32 <tommd> @lambdabot Who maintains you
13:16:32 <lambdabot> Unknown command, try @list
13:16:39 <tommd> @vixen Who maintains lambdabot
13:16:40 <lambdabot> you remind me of that actor, whatshisname
13:16:48 <paolino> import Control.OldException
13:16:58 <themroc-> hzap hmm that looks simple
13:17:05 <hzap> themroc-: it is
13:17:15 <themroc-> so i can have a list of functions, as simple as that
13:17:39 <Lemonator> k
13:17:42 <hzap> themroc-: yes, they're first class values so you can do all those things
13:17:48 <themroc-> nice
13:18:01 <conal> PeakerWork: just noticed your question on dependent types.  i've not used Agda/Epigram/etc.  i developed a higher-order unification algorithm for dependent types for my dissertation.
13:18:39 <themroc-> is there a reason why simple functions like (+) or (-) have no show instance?
13:18:52 <Lemonator> now it's compiling, thanks paolino
13:18:53 <hzap> what can you show them as?
13:18:59 <themroc-> i mean if you can handle em like en element of a list, it would make sense, no?
13:19:10 <conal> themroc-: yes.  equal functions would have to have equal shows.
13:19:26 <themroc-> > (+)
13:19:27 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
13:19:28 <lambdabot>    arising from a use...
13:19:44 <conal> themroc-: i.e., x == y ==> f x == f y, including f == show
13:19:50 <jeffwheeler>  themroc-: every function can be used as an element in a list
13:20:14 <Lemonator> Oh boy.
13:20:16 <Lemonator> Plugin/Url.hs:51:18:
13:20:16 <Lemonator>     Couldn't match expected type `Maybe ([Char], Integer) -> IO a'
13:20:16 <Lemonator>            against inferred type `Lambdabot.Url.WebReq (Maybe String)'
13:20:27 <themroc-> ok thy
13:20:29 <themroc-> thx
13:20:51 <benmachine> Lemonator: how are you installing?
13:20:59 <Lemonator> building using cabal
13:21:02 <themroc-> and $ in the example is used as a function sign or as parameter sign?
13:21:04 <benmachine> oh
13:21:06 <Lemonator> runhaskell configure, build, install
13:21:10 <benmachine> pass
13:21:16 <hzap> themroc-: it's an operator section
13:21:43 <hzap> themroc-: just like (+ 5)
13:21:48 <benmachine> Lemonator: maybe there's some parameter by which you can disable plugins that don't build?
13:22:00 <Lemonator> That would be awesome.
13:22:05 <Lemonator> But I don't know.
13:22:07 <paolino> Lemonator: which is the caller ?
13:22:08 <void9> @pl \x -> f x x
13:22:09 <lambdabot> join f
13:22:45 <jeffwheeler> Lemonator: cabal install -f-plugin?
13:22:47 <Lemonator> In the second argument of `($)', namely
13:22:47 <Lemonator>         `urlPageTitle url (proxy config)'
13:23:03 <jeffwheeler> Lemonator: where 'plugin' is some flag in the cabal file?
13:23:45 <jeffwheeler> @type join
13:23:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:23:49 <themroc-> hm
13:26:06 <paolino> Lemonator: what is the first arg of ($) ?
13:26:11 <Lemonator> io
13:26:46 * paolino can't find sources online
13:27:41 <themroc-> hmhm i dont understand that map yet fully
13:27:41 <void9> @pl \x -> f x x x
13:27:42 <lambdabot> join (join f)
13:28:05 <jeffwheeler> @src ($)
13:28:05 <lambdabot> f $ x = f x
13:28:21 <jeffwheeler> paolino: It's just the function to which you want to apply the argument
13:28:36 <themroc-> yeah i know $ from functions
13:28:57 <themroc-> to denote that the following is being taken as one parameter
13:28:59 <Phillemann> Hmm, isn't there a function to convert a TimeDiff to seconds? o_O
13:29:11 <themroc-> like mod 3 $ 4 + 5 + 6
13:29:36 <hzap> themroc-: you are familiar with other operator sections?
13:29:40 <jeffwheeler> themroc-: I was responding to paolino's question
13:29:48 <themroc-> [22:21:13] <hzap> themroc-: it's an operator section
13:30:04 <themroc-> jeffwheeler i dont know
13:30:11 <themroc-> maybe but not under the name
13:30:41 <jeffwheeler> themroc-: did you mean to direct that at hzap?
13:31:07 <themroc-> im talking about map ($ "blah") [show . length, id, (++ "blah")]
13:31:18 <themroc-> i dont understand the $
13:31:24 <themroc-> i mean i understand how it works basically
13:31:46 <Vanadium> themroc-: ($ x) is basically \f -> f x
13:31:49 <mauke> ($ "blah") is \f -> f $ "blah"
13:31:56 <hzap> themroc-: ($ "blah") = \f -> f $ "blah"
13:32:03 <themroc-> hehe :p
13:32:03 <void9> is there a non-monadic point-free way to duplicate an arg?
13:32:18 <themroc-> \f is new to me
13:32:24 <mauke> zomg
13:32:24 <Vanadium> $ is just function application, if you only give the second argument, you still need to give the function
13:32:28 <mauke> back to basics
13:32:36 <hzap> themroc-: do you understand things like (* 5)?
13:32:37 <Vanadium> Oh, \a b c -> dosomethingwith a b c is just notation for an anoymous function
13:32:40 <mauke> \PARAMETER -> BODY
13:32:45 <mauke> that's how you write a function
13:33:02 <themroc-> ah ok
13:33:16 <Lemonator> k, fixed it.
13:33:26 <void9> @pl \x traceShow x x
13:33:27 <lambdabot> (line 1, column 17):
13:33:27 <lambdabot> unexpected end of input
13:33:27 <lambdabot> expecting pattern or "->"
13:33:32 <themroc-> \ never showed up in winhugs so far for me
13:33:40 <void9> @pl \x -> traceShow x x
13:33:41 <lambdabot> join traceShow
13:33:51 <Vanadium> So what we were saying is: ($ "blah") is a function that takes a function f as its argument and returns f blah
13:33:59 <jeffwheeler> void9: what's wrong with join?
13:34:07 <Vanadium> Because $ is a function call operator
13:34:55 <void9> Prelude Control.Monad Debug.Trace> (join traceShow)("a")
13:34:55 <void9>  
13:34:55 <void9> <interactive>:1:1:
13:34:55 <void9>     No instance for (Monad ((->) [Char]))
13:34:58 <void9>       arising from a use of `join' at <interactive>:1:1-14
13:35:03 <void9>     Possible fix: add an instance declaration for (Monad ((->) [Char]))
13:35:03 <paolino> Lemonator: that is strangely looking as an error inside lambdabot, not related to ghc version
13:35:05 <void9>     In the expression: (join traceShow) ("a")
13:35:08 <void9>     In the definition of `it': it = (join traceShow) ("a")
13:35:12 <void9>  
13:35:21 <Lemonator> paolino, I modified the source code.
13:35:25 <jeffwheeler> > replicate 3 3
13:35:25 <lambdabot>   [3,3,3]
13:35:31 <jeffwheeler> >(join replicate) 3
13:35:35 <jeffwheeler> > (join replicate) 3
13:35:36 <lambdabot>   [3,3,3]
13:35:44 <hzap> void9: import Control.Monad.Instances
13:35:54 <pikhq> That map example... do {x <- show . length, y <- id, return x:y:(++ "blah")} "blah" -- is it just me, or is the function monad version slightly easier to get?
13:36:41 <void9> hzap: executes now.  thx
13:37:17 <Lemonator> Plugin/Log.hs:168:30:
13:37:17 <Lemonator>     Couldn't match expected type `ModuleT (M.Map a b) LB b'
13:37:17 <Lemonator>            against inferred type `Maybe b'
13:37:20 <shachaf> pikhq: Than what?
13:37:20 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
13:37:21 <themroc-> ok hzap i guess i understood it now
13:37:25 <Lemonator> Now this one seems harder.
13:37:37 <pikhq> Actually, no.
13:37:50 <pikhq> shachaf: map ($ "blah") [show . length, id, (++"blah")]
13:39:16 <shachaf> pikhq: Well, for one, what you wrote isn't valid syntax. :-)
13:40:04 <Lemonator> What the hell is ModuleT?
13:40:21 <shachaf> pikhq: do {x <- show . length; y <- id; z <- (++ "blah"); return $ [x,y,z]} $ "blah"
13:40:57 <shachaf> I don't see why that is simpler -- ($ "blah") is pretty apparent, no?
13:41:25 <Lemonator> @src modulet
13:41:26 <lambdabot> Source not found. Wrong!  You cheating scum!
13:41:46 <pikhq> shachaf: Like I said, "actually, no".
13:41:56 <pikhq> Not simpler, just more monadic.
13:42:09 <shachaf> pikhq: Ah.
13:42:33 <ray> monadic?!
13:42:43 <pikhq> ray: Has moar monads.
13:42:53 <ray> what is this monad thing
13:43:17 <paolino> Lemonator, it is in LBState
13:43:23 <monochrom> this monad thing is the best thing since lambda calculus
13:43:44 <ray> i don't think the function monad is as useful as the function applicative
13:43:48 <paolino> Lemonator it's Log type
13:43:51 <pikhq> > ($"blah")=<<[show.length,id,(++"blah")] -- Now there's something that's straight-up confusing. :P
13:43:53 <lambdabot>   "4blahblahblah"
13:44:10 <pikhq> ... Not to mention completely and utterly not what I meant for it to be.
13:44:19 <ray> what you meant was probably less cool
13:44:25 <pikhq> True.
13:44:29 <Phillemann> If I write: function a = a >> a; and I call it with "function getChar" then getChar will only be executed once. How can I prevent that?
13:44:44 <Lemonator> paolino, is there an easy way to convert from a Maybe?
13:44:47 <shachaf> > sequence [show . length, id, (++"blah")] "blah"
13:44:47 <Dridus> Phillemann: it should be executed twice
13:44:49 <lambdabot>   ["4","blah","blahblah"]
13:45:02 <Phillemann> Dridus: Oh, you're right, hmmmm.
13:45:19 <pikhq> shachaf: I believe that's the least-stupid one yet.
13:45:22 <Phillemann> Ah, getChar is not line based
13:45:38 <shachaf> pikhq: Hum? Even though sequence is nice, I think ($ "blah") is clearer.
13:45:58 <pikhq> Eh.
13:46:11 <pikhq> Least stupid usage of the function monad, at least.
13:46:19 <hzap> I actually like using the Applicative function instance sometimes
13:46:32 <ray> the applicative is great
13:47:03 <ray> it's like a nuclear powered chipping wedge
13:49:23 <Dridus> Phillemann: do you mean to use head <$> getLine perhaps?
13:50:01 <Phillemann> Dridus: No, getChar is just fine, I just didn't expect it to not need a return after the character.
13:50:32 * shachaf wonders why an unsafe function like head is so standard.
13:50:36 <Phillemann> If you do "char c; std::cin >> c;" in C++ you have to type in a complete line
13:51:05 <ray> safeHead for head
13:51:23 <Vanadium> Phillemann: You can probably reset the terminal buffering behaviour.
13:51:38 <pikhq> shachaf: head? Unsafe? It's referentially transparent! ... Fine, so it doesn't work right on [].
13:51:53 <shachaf> pikhq: It works as well as it can.
13:51:56 <Dridus> shachaf: oops, good call. headMay <$> getLine
13:52:04 <ray> it does what it can for its type
13:52:05 <shachaf> But its type is ridiculous.
13:52:16 <Vanadium> You would probably want to avoid using head and do more pattern matching instead?
13:52:19 <pikhq> :t head
13:52:21 <lambdabot> forall a. [a] -> a
13:52:33 <ray> pattern matching is often better
13:52:35 <shachaf> Vanadium: Indeed -- though [a] -> Maybe a would work also.
13:52:43 <ray> you get these nice non-exhaustive pattern errors
13:52:44 <monochrom> This is why I support GHC to use the same default line buffering behave as C and C++ on Unix.
13:52:45 <Vanadium> @type maybe
13:52:46 <shachaf> And would let you use various maybe-getting functions.
13:52:47 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:52:49 <Vanadium> ^ or something like that
13:52:50 <Dridus> ray: I find it doesn't play as nice with point-free though
13:53:01 <monochrom> s/behave/behaviour/
13:53:04 <hzap> shachaf: now people will just use fromJust . head
13:53:06 <ray> sometimes you want pointless, sometimes you want points
13:53:17 <Dridus> ray: oh true, of course
13:53:29 <shachaf> hzap: fromJust is well-known as a dangerous thing, though.
13:53:43 <ray> head' :: [a] -> a is ok
13:53:55 * pikhq is randomly of the opinion that head [] should = []. :P
13:53:57 <shachaf> Or at least it should be -- when people do that, they are actively ignoring the possibility of Nothing.
13:54:02 <Vanadium> hzap: They should use maybe . head~
13:54:08 <shachaf> pikhq: That wouldn't work, y'know.
13:54:15 <pikhq> shachaf: Why not?
13:54:17 <hzap> shachaf: so it doesn't really change anything - case list of [] -> ...; (x:xs) -> ... becomes case (head list) of Nothing -> ... ; Just ...
13:54:18 <ray> yeah, that's not how lists are :P
13:54:19 <Dridus> pikhq: head :: [a] -> a
13:54:20 <shachaf> @ty head
13:54:22 <lambdabot> forall a. [a] -> a
13:54:26 <pikhq> Ah, yes.
13:54:37 <pikhq> That would work just fine for tail.
13:54:37 <shachaf> pikhq: For tail it would "work" -- but it would just be ugly.
13:54:50 <pikhq> But for head, well.
13:54:51 <Dridus> but maybe you're on to something, maybe it should be Monoid a => [a] -> a and give you mempty ;-)
13:55:02 <shachaf> hzap: Yep -- except Maybe is made for that sort of thing, unlike [].
13:55:05 * Dridus ducks
13:55:11 <shachaf> So you have all sorts of functions that get a Maybe argument.
13:55:17 <pikhq> Dridus: That seems nicer, at least.
13:55:19 <ray> well, that's another function entirely
13:55:21 <shachaf> (For instance, maybe. :-) )
13:55:25 <monochrom> MonadZero m => [a] -> m a
13:55:29 <pikhq> Assuming you only want it to work on lists of monoids. ;)
13:55:35 <Dridus> pikhq: haha big assumption
13:55:51 <hzap> shachaf: true. we have the maybe function
13:56:32 <hzap> is MonadPlus basically a Monad + Monoid?
13:56:52 <ray> it's.. kinda like Monoid for things with kind * -> *
13:56:57 <shachaf> @ty mappend
13:56:59 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:57:02 <monochrom> No, MonadPlus is not Monad + Monoid
13:57:08 <shachaf> @ty mplus
13:57:10 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
13:57:31 <hzap> damn kind mismatches
13:57:32 <monochrom> But no one believes me. Nevermind.
13:57:38 <ray> an important restriction is that these things have to be Monads first
13:57:54 <shachaf> monochrom: Of course we believe you!
13:58:04 <ray> if you want a Monoid you should probably use Monoid
13:58:24 <shachaf> @ty (mzero, mempty)
13:58:25 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m, Monoid a1) => (m a, a1)
13:58:26 <void9> @pl \x -> Debug.Trace.trace (show x) x
13:58:27 <lambdabot> Debug.Trace.trace =<< show
13:58:40 <ray> instance Monoid (Thingy a) where...
13:58:44 <dons> showTrace
13:59:25 <void9> dons: showTrace will return x after show.  i want to return raw x.
14:01:04 <dons> ah
14:01:13 <void9> oopsi might be wrong.
14:03:51 <monochrom> traceShow x x = (trace . show) x x = trace (show x) x
14:05:49 <monochrom> tradeShow x x = show x ++ " has every feature you want! And I'll give you a discount. Anyway to win a free t-shirt please sit through the following slide show for " ++ show x
14:05:51 <Phillemann> Hm, or does getChar only outside of ghci wait for a newline?
14:06:36 <Vanadium> Phillemann: ghci obviously has to turn off linebuffering so it can provide readline/editing of the code input line
14:06:41 <monochrom> ghci likely puts stdin into another mode because of readline or editline.
14:06:49 <Phillemann> Ah, okay
14:08:50 <tommd> There was once a reasonable wiki for Atom (http://funhdl.org/wiki/doku.php), but its gone now.  This leaves just the haddock, a couple blogs, and the patch-tag page for atom.  Does anyone know of another good resource?
14:12:07 * pikhq discovers that C# has monads, and giggles some more
14:12:47 * JHVH still can't figure out what a monad is
14:12:58 <Wild_Cat> C# has monads? Where?
14:13:09 <monochrom> Is that the Linq part?
14:13:19 <Raevel> @hoogle m a -> m b -> m (a, b)
14:13:20 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
14:13:20 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
14:13:20 <lambdabot> Language.Haskell.TH strictType :: Q Strict -> TypeQ -> StrictTypeQ
14:13:20 <pikhq> LINQ.
14:13:49 <Wild_Cat> isn't Linq a simple SQL dialect with compiler awareness?
14:14:14 <pikhq> No. LINQ is monad comprehensions.
14:14:48 <Vanadium> LINQ is an embedded language that looks like SQL and is for generic queries~
14:15:10 <pikhq> http://blogs.msdn.com/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx <- Implementation of the Identity, Maybe, and Continuation monads, and demonstrates the use of the builtin list (IEnumerable) monad.
14:15:18 <Lemonator> Man, that took a while,
14:15:19 <Wild_Cat> yeah, it's a query language. I kinda fail to see how it's a monad.
14:15:24 <Lemonator> but now I fixed that.
14:15:26 <Wild_Cat> ...and WTF is going on with Wikipedia?
14:15:31 <pikhq> It's syntactic sugar for monad comprehensions.
14:15:34 <Lemonator> Plugin/IRC.hs:136:14: Not in scope: `ioErrors'
14:15:46 <Lemonator> I'm starting to hate the lambdabot maintainers.
14:15:50 <shachaf> Wild_Cat: ?
14:15:58 <dons> Lemonator: where are you trying to build this from?
14:16:03 <Lemonator> hackage.
14:16:05 <dons> Lemonator: not just: cabal install lambdabot ?
14:16:15 <Lemonator> It's the same thing, is it not?
14:16:17 <Wild_Cat> shachaf: http://en.wikipedia.org/wiki/Main_Page -- the layout is all messed up!
14:16:18 <Lemonator> get the tarball,
14:16:22 <Lemonator> tar svf
14:16:22 <pikhq> SelectMany = >>=, ToX = return.
14:16:22 <dons> or do you have some kind of older ghc?
14:16:33 <dons> Lemonator: note: lambdabot has no maintainers.
14:16:39 <Lemonator> running ghc 6.10 over here.
14:16:46 * dons tries cabal install
14:16:51 <Wild_Cat> the logo is gone, the search/go/index/whatever column on the left is gone too... The bloody thing looks like the C2 wiki!
14:17:22 <shachaf> Wild_Cat: Huh, it was fine before you made me get rid of my CSS cache. :-(
14:17:36 <dons> Lemonator: cabal install will resolve dependencies for you, in a better way
14:17:48 <Lemonator> dependencies are fulfilled.
14:17:52 <Lemonator> These are errors in the source code.
14:17:55 <dons> yep
14:17:58 <monochrom> Hahaha, you have no one to hate. :)
14:18:03 <dons> :)
14:18:10 <dons> ok. now building...
14:18:12 <dons> let's see...
14:18:28 <dons> 14/81 ... 23/81 ...
14:19:48 <dons> 40/81 .. go go go
14:19:54 <dons> 56/81
14:19:59 <dons> 81/81!
14:20:03 <dons> Linking dist/build/lambdabot/lambdabot ...
14:20:03 <dons> Installing executable(s) in /home/dons/.cabal/bin
14:20:06 <dons> works. :)
14:20:17 <dons> Lemonator: cabal update ; cabal install lambdabot
14:20:35 <Lemonator> what the
14:20:50 <dons> yeah, builds out of the box with clever cabal install resolver of constraitns
14:21:19 <benmachine> dons: does it work though?
14:21:23 <dons> seems to
14:21:25 <Lemonator> this is building 4.2.2.1 with ghc 6.10
14:21:26 <Lemonator> ?
14:21:28 <dons> at least on the commandline
14:21:30 <benmachine> took me a few extra libraries to make my lambdabot actually useful
14:21:47 <benmachine> can't actually remember now which ones they were >_>
14:21:57 <Lemonator> I don't understand.
14:22:07 <Lemonator> There are type errors in the source code,
14:22:19 <Lemonator> yet you compiled it fine.
14:23:27 <dons> they're only type errors because the wrong versions of libraries are used.
14:23:34 <dons> i.e. base 4 instead of base 3, etc.
14:23:40 <dons> cabal-install knows to use the right versions of things.
14:23:48 <dons> runhaskell Setup.hs is less forgiving
14:24:04 <dons> in this case, the lambdabot.cabal file has an ambiguous dependency specification.
14:24:22 <dons> runhaskell will use the /latest/ version of libs, cabal-install will use the version most likely to work.
14:24:29 <dons> hence the different result.
14:24:30 <tommd> Aside from needing the readline library, it just worked for me too via cabal.
14:31:17 <Lemonator> No matter.
14:31:23 <Lemonator> I've gotten it to build now.
14:34:18 <Lemonator> Great.
14:34:20 <Lemonator> Linking errors.
14:36:22 <Lemonator> NOW it works.
14:37:03 <benmachine> woo
14:37:11 <monochrom> john woo
14:37:15 <Lemonator> hm.
14:37:20 <Lemonator> how do I get it on IRC, though?
14:39:52 <beutdeuce_> how do u loop in haskell?
14:40:03 <monochrom> Write a recursion.
14:40:14 <mike-burns> Use `map'.
14:40:23 <Beelsebob> well, it seems to be building
14:40:25 <monochrom> Or use a suitable library function.
14:40:30 <Beelsebob> lets see if I magically get ghc on solaris to work
14:41:16 <mike-burns> beutdeuce_: If you can be more specific about what you're looping over and what you're doing to the data in this loop, we can provide a more useful answer.
14:41:29 <beutdeuce_> mike-burns: pasting it
14:42:11 <SubStack> [5..8], we don't want to iterate
14:42:20 <mike-burns> Heh.
14:43:20 <tromp_> here's a loop:
14:43:23 <tromp_> > sum [0..9]
14:43:25 <lambdabot>   45
14:43:32 <Beelsebob> wow, this is compiling slowly
14:43:50 <beutdeuce_> k guys, need help here => http://haskell.pastebin.com/m1aadc6b6 . I appreciate any guidance :)
14:44:23 <Beelsebob> beutdeuce_: you probably want scanl
14:44:39 <beutdeuce_> Beelsebob:  not sure what that is :P
14:44:40 <Beelsebob> that will allow you to create a list, where each element is the product of all the elements up to that index in the other list
14:44:47 <Beelsebob> @type scanl
14:44:49 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
14:44:57 <tromp_> you dont want to try divide by 1
14:44:58 <beutdeuce_> hmm
14:45:04 <Beelsebob> > scanl (*) 1 [1,2,3,4,5,6,7,8,9]
14:45:06 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880]
14:45:32 <tromp_> or by x
14:46:10 <monochrom> The filtering doesn't take forever. The product takes forever.
14:46:16 <SubStack> isPrime returns a non-boolean! to think!
14:46:18 <tromp_> also, isXxxx functions should return Bool
14:46:43 <beutdeuce_> SubStack: thats cause the context i'm using it is more effiiceient with returning the actualy number that is prime
14:46:48 <Cale> Hello all :)
14:47:09 <beutdeuce_> Beelsebob: scanl gives me, "Cannot infer instance"
14:47:12 <Cale> beutdeuce_: faster than having isPrime produce a Bool and then just  filter isPrime ?
14:47:17 <tromp_> hi Cale
14:47:18 <monochrom> And of course here "takes forever" means "not emitting the next item in the list soon" as you intend.
14:47:20 <Beelsebob> beutdeuce_: what instance can't it infer?
14:47:22 <mike-burns> beutdeuce_: It's hard for me to figure out what you're trying to do here. What do you want to use isPrime for?
14:47:23 <SubStack> beutdeuce_: efficiency is hard to tell in functional languages
14:47:55 <mike-burns> Oh I should read the description.
14:48:00 <Cale> It's not that efficiency is actually that hard to tell as that it doesn't work the same way as in strict and imperative languages :)
14:48:33 <medfly> hello Cale :)
14:48:34 <monochrom> efficiency is hard to tell in OOP languages
14:48:38 <Cale> medfly: hello
14:48:50 <mike-burns> In any language you should use a profiler to figure out your speed issues.
14:48:50 <Cale> monochrom: I suppose that can be true as well :)
14:49:00 <monochrom> Oh actually, very easy to tell. "inefficienct". always give that answer. easy and correct. always.  <duck>
14:49:02 <Gracenotes> but, strictness analysis isn't a walk in the park either
14:49:26 <monochrom> Programming isn't a walk in the park.
14:49:29 <mike-burns> Oh, you want the prime factors of 600851475143?
14:49:43 <monochrom> Programming is a flight in the dark.
14:50:13 <monochrom> Programming is a swim in the lark.
14:50:47 <Gracenotes> GHC is melting in the dark
14:50:52 <Gracenotes> all the sweet green lambdas running down
14:51:25 <beutdeuce_> k guys, updated my problem => http://haskell.pastebin.com/m5d829f5d , should be clearer now
14:51:31 <MyCatVerbs> Gracenotes: lay off the mushroom pie.
14:51:46 <mike-burns> :t scanl
14:51:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
14:51:59 <Gracenotes> someone left the monads out in the rain
14:52:12 <Cale> beutdeuce_: If I was writing this, I would first get a list of all the primes. Then I would probably write a function which given a number and a list of remaining primes, tries to divide the first of those primes out. If it's a divisor, then it's the first element of the list of prime factors and the tail recurses with the list of possible primes unchanged. If not, then the result is the same as if that prime had not
14:52:13 <Cale> been in the list of possible remaining primes.
14:52:34 <Lemonator> my lambdabot seems broken.
14:52:36 <Lemonator> fd:9: hClose: resource vanished (Broken pipe)
14:52:46 <beutdeuce_> :info scanl
14:52:57 <Gracenotes> that means it probably has trouble accessing an executable
14:53:00 <benmachine> Lemonator: what are you trying to do?
14:53:10 <Lemonator> simply evaluate an expression
14:53:12 <Lemonator> > 1 + 1
14:53:13 <lambdabot>   2
14:53:18 <Cale> (and of course, I didn't mention it, but in the case where the divisor comes out, we recurse on the divided version of course)
14:53:31 <Twey> Maybe mueval isn't where it's expected to be?
14:53:56 <benmachine> I don't think mueval is a dependency of lambdabot
14:53:56 <tromp_> and we stop if the remainder is less than the lead prime squared
14:54:26 <benmachine> which sort of makes sense except it has no real documentation either so the only way you find out is by asking here
14:54:35 <tromp_> > group "hello"
14:54:36 <lambdabot>   ["h","e","ll","o"]
14:55:35 <beutdeuce_> > (\x -> x+1) 1
14:55:37 <lambdabot>   2
14:56:13 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; factors 1 _ = []; factors n (p:ps) | r == 0 = p : factors q (p:ps) | otherwise = factors n ps where (q,r) = divMod n p in factors 600851475143 primes
14:56:15 <lambdabot>   [71,839,1471,6857]
14:56:37 <Cale> (sorry that's all squished onto one line :)
14:56:45 <medfly> this being a one liner is ridiculous :)
14:56:57 <tromp_> > product [71,839,1471,6857]
14:56:58 <lambdabot>   600851475143
14:57:16 <MyCatVerbs> beutdeuce_: I believe your type error is fixed if you write (scanl (*) (filter (isFactor 600851475143) . filter (isPrime) $ [1..]) 1).
14:57:34 <Cale> > scanl (*) 1 [71,839,1471,6857]
14:57:35 <lambdabot>   [1,71,59569,87625999,600851475143]
14:58:57 <Cale> beutdeuce_: anyway, the idea of that code is basically just how I explained: it gets a list of all the primes, then consumes that as it factors the number
15:00:08 <beutdeuce_> Cale: thanks!
15:00:35 <Cale> beutdeuce_: If you want to look more carefully, I'll paste it on hpaste and format it properly
15:00:42 <beutdeuce_> that  would be great
15:04:02 <Lemonator> GAH
15:04:24 <Lemonator> lambdabot throws exceptions, but how to I track them back to the calling function during runtime?
15:05:27 <Gracenotes> you use the stack trace!
15:05:30 <Gracenotes> oh wait! never mind!
15:05:41 <Cale> beutdeuce_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7095#a7095
15:05:52 <beutdeuce_> Cale: thanks :)
15:06:53 <Cale> beutdeuce_: Even if it's not the absolute most efficient version of the infinite list of primes, I like this version for the pretty mutual recursion.
15:07:33 <beutdeuce_> Cale: and its much better than what i had :)
15:09:43 <monochrom> > scanl (*) z [a,b]
15:09:45 <lambdabot>   [z,z * a,z * a * b]
15:09:53 <monochrom> <3 Expr
15:10:09 <monochrom> > scanl1 (*) [a,b]
15:10:11 <lambdabot>   [a,a * b]
15:10:16 <monochrom> maybe even better
15:10:24 <Cale> beutdeuce_: As for the original question about looping in Haskell, most of our loops are in some way replaced with lists (or functions operating on lists)
15:11:08 <beutdeuce_> Cale: , yeah, i think i'm beginning to understand how Haskell implements its own solutions
15:11:10 <Cale> beutdeuce_: These functions may or may not be explicitly recursive (though if you drill deep enough into their definition you will generally find a recursive function)
15:12:02 <Lemonator> dons, you still here?
15:12:06 <Lemonator> anyway
15:12:16 <Lemonator> I'm now using cabal install,
15:12:18 <Lemonator> but
15:12:19 <Lemonator> Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)
15:12:49 <Lemonator> Is that an ncurses problem?
15:12:56 <dons> ghci, actually.
15:13:04 <dons> ncurses.so is a linker script on some systems
15:13:17 <dons> you have to replace it with a symlink to ncursesw.so
15:13:30 <dons> rather than a linker script that loads ncursesw.so
15:13:37 * dons doesn't know why ncurses is a dependency of lambdabot
15:13:52 <Cale> heh, that's kind of funny
15:14:09 <pikhq> The question is why readline is a dependency of lambdabot. ;)
15:14:26 <beutdeuce_> is there a haskell function that takes a  number at turns it into a list of digits?
15:14:36 <beutdeuce_> and*
15:14:52 <mauke> beutdeuce_: show
15:14:54 <Cale> Well, you can do the cheesy thing with map digitToInt . show
15:15:09 <Cale> but you could also do something like:
15:15:22 <beutdeuce_> > show 1337
15:15:24 <lambdabot>   "1337"
15:15:30 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 33827190754
15:15:32 <lambdabot>   [4,5,7,0,9,1,7,2,8,3,3]
15:15:47 <tromp_> they differ for 0
15:16:04 <Cale> right, 0 has no digits with that one I just wrote
15:16:09 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 0
15:16:11 <lambdabot>   []
15:16:17 <beutdeuce_> cool
15:16:42 <Cale> > iterate (`div` 10) $ 33827190754
15:16:44 <lambdabot>   [33827190754,3382719075,338271907,33827190,3382719,338271,33827,3382,338,33...
15:16:49 <Cale> > iterate (`div` 10) $ 33824
15:16:51 <lambdabot>   [33824,3382,338,33,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:17:01 <Lemonator> <OceanSpray> > 1 + 1
15:17:01 <Lemonator> <Lemonidas>  Terminated
15:17:01 <tromp_> and digits come out in reverse
15:17:03 <Cale> > takeWhile (/= 0) . iterate (`div` 10) $ 33824
15:17:03 <beutdeuce_> > [1..]
15:17:04 <lambdabot>   [33824,3382,338,33,3]
15:17:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:17:17 <beutdeuce_> ah, so it stops :P
15:17:36 <Cale> beutdeuce_: It just stops printing, the list goes on forever of course :)
15:17:46 <beutdeuce_> is there a way to do geometric sequences with ranges?
15:18:00 <Cale> Nope, only arithmetic ones
15:18:08 <beutdeuce_> k
15:18:10 <tromp_> use iterate
15:18:17 <Cale> > iterate (*2) 1
15:18:19 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
15:18:28 <Cale> > iterate (*r) a
15:18:29 <Lemonator> benmachine, what extra libraries did your lambdabot need?
15:18:30 <lambdabot>   [a,a * r,a * r * r,a * r * r * r,a * r * r * r * r,a * r * r * r * r * r,a ...
15:18:48 <mauke> > iterate (r*) a
15:18:50 <lambdabot>   [a,r * a,r * (r * a),r * (r * (r * a)),r * (r * (r * (r * a))),r * (r * (r ...
15:19:00 <Vanadium> What is the type of (r*), a?
15:19:07 <Cale> :t r
15:19:09 <lambdabot> Expr
15:19:17 <benmachine> Lemonator: I don't remember, but I can check
15:19:22 <Cale> Vanadium: It's from the SimpleReflect library
15:19:22 <Lemonator> thanks.
15:19:24 <benmachine> Lemonator: to start with, do you have mueval?
15:19:26 <Vanadium> Hm
15:19:37 <pikhq> > iterate (head . show . (`div` 10)) 33824
15:19:39 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
15:19:39 <lambdabot>    arising from a use of...
15:19:40 <beutdeuce_> > [ iterate (*2) x | x <- [1..]]
15:19:42 <lambdabot>   [[1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072...
15:19:47 <Lemonator> benmachine, I don't think so.
15:19:48 <pikhq> That was dumb and useless.
15:19:55 <pikhq> > show 33824 -- XD
15:19:56 <lambdabot>   "33824"
15:20:05 <benmachine> Lemonator: you need that for >, so cabal install it
15:20:11 <Lemonator> done.
15:20:14 <Cale> Vanadium: Basically, it's an instance of Num (and lots of other classes) which has values that just show as particular strings
15:20:24 <Vanadium> > iterate show ""
15:20:26 <lambdabot>   ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\...
15:20:42 <pikhq> That's quite silly.
15:20:48 <Cale> > fix show
15:20:50 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
15:20:57 <Vanadium> Woah
15:21:00 <benmachine> Lemonator: it should give  amore helpful error message at this point
15:21:09 <benmachine> also, does cabal keep logs do you know?
15:21:12 <lpsmith> > iterate f x
15:21:13 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
15:21:14 <Lemonator> <OceanSpray> > 1 + 1
15:21:14 <Lemonator> <DeliciousCurry>  Terminated
15:21:23 <lpsmith> when did that happen?
15:21:36 <Lemonator> benmachine, is there some extra configuration needed to have lambdabot know the existence of mueval?
15:21:36 <Cale> lpsmith: Oh, right, it used to require a type signature didn't it?
15:21:41 <Cale> lpsmith: I don't know.
15:21:56 <Cale> I certainly didn't consciously try to fix it ;)
15:22:02 <benmachine> Lemonator: not that I recall, but I guess it has to be on $PATH
15:22:24 <Cale> > foldr f z [a,b,c,d,e]
15:22:25 <lpsmith> I meant the symbolic manipulation-like features
15:22:25 <lambdabot>   f a (f b (f c (f d (f e z))))
15:22:31 <Cale> lpsmith: Oh, long ago
15:22:43 <lpsmith> sweet
15:22:45 <Cale> http://hackage.haskell.org/package/simple-reflect
15:22:48 <beutdeuce_> how can i make this work, map (read :: Int) "111", so it would return [1,1,1]
15:22:55 <Cale> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
15:28:03 <Gracenotes> > map digitToInt "111" -- beutdeuce_
15:28:05 <lambdabot>   [1,1,1]
15:28:12 <beutdeuce_> thnx
15:30:32 <Lemonator> benmachine, have you ever encountered this error?
15:30:32 <Lemonator> <OceanSpray> > 1 + 1
15:30:32 <Lemonator> <DeliciousCurry>   Could not find module `Control.Arrow.Transformer.All':
15:30:32 <Lemonator> <DeliciousCurry>    Use -v to see a l...
15:31:11 <benmachine> Lemonator: I had a lot of module not found errors
15:31:15 <Lemonator> ah.
15:31:25 <benmachine> you have two choices I think
15:31:33 <benmachine> what I did was google each name and install the package that came up
15:31:37 <benmachine> but you could also
15:31:45 <benmachine> (I don't know if this works but I expect it will)
15:32:07 <benmachine> edit ~/.lambdabot/State/L.hs
15:32:14 <benmachine> and remove the imports that aren't found
15:32:34 <kw317> I've installed mersenne-random package via cabal install and now when I try to compile any example code, ghc fails with unresolved symbols
15:33:24 <kw317> do I need to do anything special to link against packages acquired using cabal?
15:37:23 <Beelsebob> woot, ghc-inplace running, looks like this *may* actually work
15:40:20 <beutdeuce_> Gracenotes: it says there is no such thing as 'digitToInt'
15:40:31 <Gracenotes> you need to import Data.Char
15:40:34 <benmachine> @index digitToInt
15:40:35 <lambdabot> Data.Char
15:40:43 <beutdeuce_> Gracenotes: k
15:43:50 <cypher> hmm.. can't get this mersenne-random package to work :/
15:44:53 <Gracenotes> cypher: oh. I installed that once. forgot if I had any problems :\
15:45:16 <Gracenotes> cypher: but, do note from the documentation that you can only set up one generator per process
15:45:29 <Gracenotes> it's pretty fast
15:45:53 <cypher> in general you'd expect that after cabal-installing a package there won't be anything special required to link against it?
15:46:08 <beutdeuce_> > :info Map
15:46:10 <lambdabot>   <no location info>: parse error on input `:'
15:49:19 <davidL> how do you make lambdabot print a type's Eq's instance, for example?
15:49:45 <beutdeuce_> > [1000.9999]
15:49:47 <lambdabot>   [1000.9999]
15:49:54 <beutdeuce_> > [1000..9999]
15:49:56 <lambdabot>   [1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014...
15:50:05 <mauke> @src Char (==)
15:50:06 <lambdabot> (C# c1) == (C# c2) = c1 `eqChar#` c2
15:50:06 <lambdabot> (C# c1) /= (C# c2) = c1 `neChar#` c2
15:51:16 <davidL> thanks mauke
15:53:18 <davidL> @src Char succ
15:53:19 <lambdabot> Source not found. Where did you learn to type?
15:58:24 <fnord123> > print "Hello world"
15:58:26 <lambdabot>   <IO ()>
15:59:06 <Cale> davidL: The coverage is sketchy. It basically has its own text file of definitions.
15:59:33 <davidL> Cale: yeah, someone needs to copy and paste more definitions :)
15:59:36 <beutdeuce_> Cale, is itnot possible to divide every element of one list by every element f another?
15:59:38 <Cale> davidL: And some of the definitions are adjusted to be easy to read rather than the actual definitions.
16:00:06 <Cale> beutdeuce_: It is certainly possible. You want integer division, or fractional division?
16:00:15 <beutdeuce_> Integer
16:00:29 <Cale> > [div x y | x <- [10,20,30], y <- [4,5]]
16:00:31 <lambdabot>   [2,2,5,4,7,6]
16:00:54 <beutdeuce_> ah, right. Forgot about list compehensions
16:02:05 <beutdeuce_> Cale: what if  want to know what two elements from their respectful lists produced a certain result?
16:02:14 <kyagrd> > quickCheck (\x -> x==x)
16:02:16 <lambdabot>   Not in scope: `quickCheck'
16:02:44 <benmachine> > [(x, y, div x y) | x <- [10,20,30], y <- [4,5]]
16:02:45 <Cale> beutdeuce_: hmm... I'm not sure if I understand exactly what you mean here.
16:02:46 <benmachine> <_<
16:02:46 <lambdabot>   [(10,4,2),(10,5,2),(20,4,5),(20,5,4),(30,4,7),(30,5,6)]
16:03:35 <kyagrd> > Test.QuickCheck.quickCheck (\x -> x==x)
16:03:36 <lambdabot>   Not in scope: `Test.QuickCheck.quickCheck'
16:03:47 <beutdeuce_> Cale: lets say i want to see what element was it in the x list that has two 2-digit products in the y list
16:04:37 <kyagrd> > maybe
16:04:39 <lambdabot>   Overlapping instances for GHC.Show.Show
16:04:39 <lambdabot>                              (b -> ...
16:05:05 <Cale> > [(x1,x2) | x1 <- [2..9], x2 <- [2..9], y <- [14,18,21], x1 * x2 == y]
16:05:07 <lambdabot>   [(2,7),(2,9),(3,6),(3,7),(6,3),(7,2),(7,3),(9,2)]
16:05:10 <Cale> Like that?
16:05:31 <Cale> I'm having a hard time interpreting what you're saying :)
16:05:37 <beutdeuce_> thats fine, thanks
16:13:57 <beutdeuce_> > testingOut :: (Num a) => a -> Bool ; testingOut x = if x > 0 then True else False
16:13:58 <lambdabot>   <no location info>: parse error on input `;'
16:19:48 <beutdeuce_> Cale, lol, i need help optimizing a function i wrote to solve problem 4 of projecteurler ;P
16:20:11 <Cale> beutdeuce_: sure
16:20:17 <beutdeuce_> hO as i hpaste it
16:21:25 <beutdeuce_> Cale: k => http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7098#a7098
16:22:25 <beutdeuce_> Cale: updated => http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7099#a7099
16:22:27 <desp> $type (1 -)
16:22:32 <desp> @type (1 -)
16:22:33 <lambdabot> forall t. (Num t) => t -> t
16:22:38 <desp> @type (- 1)
16:22:39 <lambdabot> forall a. (Num a) => a
16:22:58 <Cale> isPal x = li == reverse li where li = show x
16:23:04 <desp> What's the right syntax for the (- 1) function?
16:23:09 <desp> @type flip (1 -)
16:23:15 <benmachine> desp: subtract 1 I think
16:23:17 <lambdabot> forall b c. (Num (b -> c)) => b -> (b -> c) -> c
16:23:26 <benmachine> > subtract 1 4
16:23:28 <lambdabot>   3
16:23:56 <Beelsebob> Hmm
16:24:08 <benmachine> @type flip (-) 1
16:24:09 <lambdabot> forall a. (Num a) => a -> a
16:24:13 <benmachine> or that
16:24:14 <Cale> beutdeuce_: Also, that's a pretty slow way to construct the possible palindromes...
16:24:14 <desp> Right.
16:24:18 <benmachine> @src subtract
16:24:19 <lambdabot> subtract x y = y - x
16:24:25 <Beelsebob> sudo make install of ghc seems to have forgotten to install any libraries
16:24:41 <beutdeuce_> Cale: i'll be glad to be enlightened of a quicker way ;)
16:24:50 <Beelsebob>  /opt/ghc/lib/ghc-6.10.4/./package.conf:
16:24:50 <Beelsebob>     {ghc-6.10.4}, {haddock-2.4.2}, rts-1.0
16:24:58 <Beelsebob> anyone got any idea what could have happened there?
16:24:59 <Cale> beutdeuce_: But also, checking if each product is one of that long list of palindromes is *way* slower than just checking if it's a palindrome.
16:25:28 <Berengal> beutdeuce_: map (\s -> s ++ reverse s) . map show $ [999,998..100]
16:25:49 <Berengal> > map (\s -> s ++ reverse s) . map show $ [999,998..100]
16:25:51 <lambdabot>   ["999999","998899","997799","996699","995599","994499","993399","992299","9...
16:26:04 <Berengal> All 6-digit palindromes in descending order
16:26:22 <benmachine> Cale is right though
16:26:29 <benmachine> a list of palindromes is not really that helpful
16:26:48 <Berengal> Yes it is, you just need to filter out the ones that aren't the product of two three-digit numbers
16:26:53 <Badger> > isPalindrome
16:26:54 <lambdabot>   Not in scope: `isPalindrome'
16:26:57 <Badger> aw
16:27:05 <Badger> I was sure someone had defined that
16:27:23 <beutdeuce_> Badger: u could define something to lambdabot?
16:27:33 <benmachine> Berengal: much easier to start with the products and work out which are palindromes than to start with palindromes and work out which are products
16:27:45 <Cale> beutdeuce_: first of all, let's start by generating the *large* products first
16:27:50 <Badger> I could not.
16:27:52 <Cale> req = [999,998..100]
16:27:52 <benmachine> (dang, my solution for that problem is so lazy, and not in the fun way)
16:27:58 <Badger> oh
16:28:01 <benmachine> Badger: couldn't you
16:28:03 <Berengal> benmachine: Easier as in easier to program, maybe, but much slower
16:28:05 <benmachine> ?
16:28:07 <Badger> or maybe you mean can one
16:28:10 <Badger> in which case yes
16:28:22 <Cale> and then, of course, we want to pick the second number to be no larger than the first one we pick, to ensure we don't waste any work
16:28:26 <benmachine> @let isPalindrome x = show x == reverse (show x)
16:28:27 <lambdabot>  Defined.
16:28:27 <Cale> head [(x1,x2) | (x1:xs) <- tails req, x2 <- (x1:xs), isPal (x1*x2)]
16:28:46 <hackagebot> cabal2arch 0.5.3 - Create Arch Linux packages from Cabal packages (DonaldStewart)
16:28:48 <Cale> > let req = [999,998..100] in head [(x1,x2) | (x1:xs) <- tails req, x2 <- (x1:xs), isPalindrome (x1*x2)]
16:28:50 <lambdabot>   (995,583)
16:29:01 <benmachine> Berengal: how do you work out if something is or is not the product of three-digit numbers?
16:29:12 <Berengal> @paste
16:29:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:29:30 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7100#a7100
16:29:40 <Berengal> Happens to be in python I'm afraid
16:29:55 <Cale> beutdeuce_: see how that works?
16:29:58 <benmachine> divisors(n)?
16:30:04 <Berengal> Also, not sure why I used yield there
16:30:07 <beutdeuce_> yeah, i'm going to try to reason it out now
16:30:13 <Cale> > tails [1,2,3,4,5]
16:30:15 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
16:30:23 <benmachine> Berengal: finding divisors for stuff is slow
16:30:37 <Berengal> benmachine: But still faster than iterating through possible products
16:30:38 <benmachine> hmm you may be right though
16:30:38 <Cale> > [(x,y) | (x:xs) <- tails [1..5], y <- (x:xs)]
16:30:40 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4...
16:30:44 <benmachine> Berengal: I dunno
16:30:47 <Cale> > [(x,y) | (x:xs) <- tails [1..3], y <- (x:xs)]
16:30:49 <lambdabot>   [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
16:30:59 <benmachine> if we were talking about very large numbers I bet iterating over products'd be faster
16:31:07 <Berengal> benmachine: I tested this in python. It was the fastest by far out of three different algorithms
16:31:13 <Cale> beutdeuce_: this makes sure that we don't generate both (x,y) and (y,x)
16:31:18 <benmachine> Berengal: fair enough
16:31:27 <Berengal> The ones iterating over products fail for 4 digits...
16:31:36 <Berengal> (where fail == takes a very long time)
16:31:46 <benmachine> are you iterating over products in order?
16:31:51 <beutdeuce_> Cale: i dont understand why you chose to use tails
16:32:00 <Cale> beutdeuce_: because...
16:32:02 <beutdeuce_> > tails [1..10]
16:32:03 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
16:32:15 <Cale> > [(x,y) | x <- [1..3], y <- [1..3]]
16:32:17 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
16:32:20 * benmachine tries to remember if there is an easy way to establish the ordering of products without calculating their result
16:32:27 <Cale> See how this has both 1*2 and 2*1?
16:32:27 <benmachine> I think there is
16:32:35 <Berengal> benmachine: One of them was the classic 'for x in range(100, 1000) for y in range(x, 1000)' algorithm
16:32:37 <beutdeuce_> yes
16:32:38 <Cale> er, (1,2) and (2,1) rather
16:32:41 <benmachine> in which case you can take the first palindrome
16:33:22 <Berengal> Anyway, divisors is almost amortized constant-time
16:33:23 <Cale> beutdeuce_: If we instead pick a nonempty tail of the list, taking our first choice to be the first element of that tail, and then pick an element from the tail, instead of the whole list, we won't generate duplicates like that
16:34:30 <Cale> So for example, if our list was [1,2,3,4,5], we might choose the tail [3,4,5] in which case our first element is 3, and the possibilities for the second choice are [3,4,5]
16:34:41 <Beelsebob> ghc's install script is playing silly buggers... if I export my LD_LIBRARY_PATH as /opt/csw/lib, then libraries/ifBuildable/ifBuildable runs correctly from my shell, but the install script doesn't seem to respect my LD_LIBRARY_PATH... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7101#a7101
16:34:47 <Beelsebob> anyone got any idea how to get it to respect it?
16:35:36 <beutdeuce_> i see, thanks
16:35:39 <beutdeuce_> very helpful
16:35:49 <beutdeuce_> do u need to import something for tails?
16:35:54 <Cale> Data.List
16:35:58 <beutdeuce_> k
16:36:55 <Cale> It's important to note that tails is an extremely efficient function
16:37:34 <Cale> This is because of the way that lists are structured, all the tails of the list are nested inside one another, so it takes a constant amount of time to get each one.
16:37:45 <beutdeuce_> hmm, so why did u take the head if the greatest value is the last tail
16:37:55 <beutdeuce_> or the second to last rather
16:38:07 <Cale> note that I defined req = [999,998...100]
16:38:15 <beutdeuce_> nvm
16:38:17 <beutdeuce_> :P
16:38:30 <Cale> largest should be first, so that we can find it quickly
16:38:41 <beutdeuce_> yep
16:39:20 <Cale> Lists have faster access to the beginning (just as how the corresponding loop in an imperative language will find the answer more quickly if you arrange it to count down)
16:39:29 <beutdeuce_> hmm, why use tails at all? why not just use req if the head of the tails will be the same as the initial lsit?
16:39:31 <beutdeuce_> list*
16:40:06 <Cale> Because we don't want to make our second choice larger than our first
16:41:28 <beutdeuce_> right
16:41:30 <beutdeuce_> wow
16:41:35 <beutdeuce_> tails is very very effiicient then
16:44:42 <Cale> tails [] = [[]]
16:44:53 <Cale> tails (x:xs) = (x:xs) : tails xs
16:45:37 <beutdeuce_> yep, as simple as that
16:45:44 <Cale> Since : is a constructor, the evaluation stops immediately if all we need is the first tail of the list, and only if we pattern match on the tail of the list of tails will it recurse.
16:45:57 <Cale> So it's O(1) for each element of the list.
16:46:41 <jeffwheeler> @type guard
16:46:42 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:46:49 * jeffwheeler didn't realize it had to be a MonadPlus
16:47:19 <Cale> and it doesn't have to copy the list, it just puts the list directly as the first element of the result, and xs is directly part of the structure of the original list, so when it recurses, still no copying :)
16:48:19 <sjanssen> more specifically: for a list of length N, tails allocates exactly N cons cells if the result is fully evaluated
16:48:41 <meanburrito920_> does anyone know how to generate haskell tags for emacs?
16:48:50 <beutdeuce_> > :t isPalindrome
16:48:52 <lambdabot>   <no location info>: parse error on input `:'
16:49:31 <Berengal> > let isPalindrome = (==) <*> reverse in isPalindrome "123321"
16:49:32 <lambdabot>   True
16:51:57 <beutdeuce_> how would you defined isPalindrome using lambda
16:52:00 <beutdeuce_> \x
16:52:12 <Berengal> \x -> x == reverse x
16:53:13 <aavogt> @type (==) `ap` reverse
16:53:15 <lambdabot> forall a. (Eq a) => [a] -> Bool
16:53:51 <benmachine> these methods assume x is a string
16:54:06 <Berengal> They assume it's a list
16:54:19 <Berengal> A list of Eqs
16:54:19 <Vanadium> > fail "foo" :: Either String a
16:54:21 <lambdabot>   Left "foo"
16:54:21 <benmachine> well, yes
16:54:27 <Badger> :t isPalindrome
16:54:29 <lambdabot> forall a. (Show a) => a -> Bool
16:54:31 <beutdeuce_> > (\x -> x == reverse x) 1331
16:54:32 <lambdabot>   No instance for (GHC.Num.Num [a])
16:54:32 <lambdabot>    arising from the literal `1331' at <in...
16:54:54 <Badger> > (\x -> x == reverse x) "1331"
16:54:56 <lambdabot>   True
16:54:58 <benmachine> > (\x -> x == reverse x) (show 1331)
16:55:00 <lambdabot>   True
16:55:54 <Berengal> Imho, only lists (or similar structures) can be palindromic, so it only makes sense to define isPalindrome for them
16:56:45 <beutdeuce_> unresolved top-level overloading?
16:57:12 <benmachine> Berengal: well, depends on your purpose; in this case we wanted to know if numbers were palindromic
16:57:30 <mle> interestingly, show is much faster than unfoldr on something doing divmods.  Probably all of the Maybe machinery.
16:57:31 <benmachine> and didn't really much care about other lists
16:57:43 <Berengal> benmachine: Indeed, but what is a palindromic number? is 5 palindromic?
16:58:00 <benmachine> Berengal: what you say it is :P
16:58:04 <sjanssen> mle: naive division is not the smartest way to convert to decimal
16:58:26 <sjanssen> Integer's Show instance is quite clever, especially for large numbers
16:58:34 <mle> sjanssen: well, now I'm less naive, at least.
16:59:11 <pikhq> @src Integer show
16:59:11 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:01:00 <pikhq> Berengal: Rather, we want to know if the decimal representation of a number is palindromic.
17:01:00 <beutdeuce_> > head [(x1,x2) | x1 <- [999,998..1], x2 <- tails x1, (\x y -> show(x*y) == reverse show(x*y)) x1 x2]
17:01:02 <lambdabot>   Couldn't match expected type `[a]'
17:01:08 <beutdeuce_> why didnt that work?
17:01:44 <jeffwheeler> @pl \a -> f . (:[])
17:01:44 <lambdabot> const (f . return)
17:02:07 <jeffwheeler> That so won't work, if 'f' is 'return' and polymorphic
17:02:30 <jeffwheeler> Err
17:02:43 <jeffwheeler> @pl \a -> f (:[a])
17:02:44 <lambdabot> f . flip (:) . return
17:02:49 <jeffwheeler> @pl \a -> f (:a[])
17:02:50 <lambdabot> f . flip (:) . ($ [])
17:02:59 <jeffwheeler> One of these . . .
17:03:03 <jeffwheeler> @pl \a -> f (a:[])
17:03:04 <lambdabot> f . return
17:03:48 <beutdeuce_> Why doesnt that work? => head [(x1,x2) | x1 <- [999,998..1], x2 <- tails x1, (\x y -> show(x*y) == reverse show(x*y)) x1 x2]
17:03:49 <benmachine> jeffwheeler: what are you doing and why won't f == return work?
17:04:20 <benmachine> @type tails
17:04:21 <lambdabot> forall a. [a] -> [[a]]
17:04:24 <pikhq> beutdeuce_: Type failure, of course.
17:04:35 <jeffwheeler> benmachine: Trying to return something after creating a singleton list with it
17:04:42 <BONUS> :t const (return . return)
17:04:43 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) b. (Monad m, Monad m1) => b -> a -> m (m1 a)
17:05:10 <benmachine> jeffwheeler: the two returns are in different contexts
17:05:15 <BONUS> i don't see why it wouldn't work
17:05:18 <benmachine> so they will do different things
17:05:28 <jeffwheeler> benmachine: hmm, I guess so. I'll try that.
17:05:28 <benmachine> one will put it in a list, the other will put it in
17:05:35 <benmachine> whatever
17:05:42 <BONUS> but the @pl is kinda wrong though, return is more polymorphic than (:[])
17:05:54 <Cale> beutdeuce_: x1 is a number, not a list, so tails can't be applied to it
17:06:16 <jeffwheeler> Indeed, return . return . show is just what I needed. Thanks. :)
17:06:30 <beutdeuce_> > head [(x1,x2) | x1 <- [999,998..1], x2 <- tails [999,998..1], (\x y -> show (x*y) == reverse show(x*y)) x1 x2]
17:06:31 <lambdabot>   Couldn't match expected type `[a]'
17:06:44 <beutdeuce_> hmm, what was the problem now?
17:06:49 <benmachine> beutdeuce_: x2 is a list
17:06:55 <jeffwheeler> Then again . . . maybe > return [show x] was better anyways
17:07:36 <benmachine> beutdeuce_: because tails returns a list of lists, x2 becomes a list and then can't go into your function
17:07:40 <benmachine> p.s.
17:08:23 <benmachine> (\x y -> show (x*y) == reverse show (x*y)) x1 x2 may as well be show (x1*x2) == reverse show (x1*x2)
17:08:35 <benmachine> no need to create a lambda and then apply it to something
17:09:16 <BONUS> reverse (show $ x1*x2)
17:10:00 <pikhq> And, of course, that may as well be (==) `ap` reverse $ show (x1*x2) -- but that's beside the point.
17:11:55 --- mode: irc.freenode.net set +o Igloo
17:12:54 <beutdeuce> what in the world happened?
17:13:07 <benmachine> an IRC server failed
17:13:11 <beutdeuce> ah
17:13:14 <benmachine> very briefly
17:13:16 <benmachine> well
17:13:23 <benmachine> strictly speaking, a link between servers failed
17:13:36 <benmachine> buuut it doesn't matter
17:13:38 <benmachine> it happens sometimes
17:13:44 <benmachine> it's usually solved quickly
17:13:49 <benmachine> there's nothing you can do about it
17:13:55 <beutdeuce> k
17:15:16 <beutdeuce> whats wrong with this:
17:15:17 <beutdeuce> head [(x1,x2) | x1 <- [999,998..100], x2 <- tails [999,998..100], (\x y -> show (x*y) == reverse (show(x*y))) x1 x2]
17:16:03 <Berengal> The lambda is unneccessary
17:16:15 <benmachine> beutdeuce: tails returns a list of lists, so x2 is getting a list
17:16:30 <beutdeuce> ah
17:16:34 <beutdeuce> hmm
17:17:13 <beutdeuce> > head [(x1,x2) | x1 <- [999,998..100], x2 <- [999,998..100], (\x y -> show (x*y) == reverse (show(x*y))) x1 x2]
17:17:15 <lambdabot>   (995,583)
17:17:18 <beutdeuce> yay!
17:17:39 <beutdeuce> Cale, why is there a need for tails in this example? was probably as quick as using tails
17:17:43 <Cale> beutdeuce: Right, that works too, but takes slightly longer than my version.
17:17:45 <Gracenotes> @type (==) <*> reverse
17:17:47 <lambdabot> forall a. (Eq a) => [a] -> Bool
17:17:48 <beutdeuce> hmm
17:17:55 <beutdeuce> > time head [(x1,x2) | x1 <- [999,998..100], x2 <- [999,998..100], (\x y -> show (x*y) == reverse (show(x*y))) x1 x2]
17:17:56 <lambdabot>   Not in scope: `time'
17:18:20 <beutdeuce> i forgot, lol, time is a clojure thing, does Haskell have an equivalent?
17:18:20 <Cale> beutdeuce: actually, since the example found is so large, probably it doesn't make much of a difference
17:18:21 <Twey>  head [ (x1, x2) | x1 <- [999, 998 .. 100], x2 <- [999, 998 .. 100], show (x1 * x2) == reverse . show $ x1 * x2 ]
17:18:28 <Twey> > head [ (x1, x2) | x1 <- [999, 998 .. 100], x2 <- [999, 998 .. 100], show (x1 * x2) == reverse . show $ x1 * x2 ]
17:18:29 <lambdabot>   Couldn't match expected type `GHC.Base.String'
17:18:34 <Twey> Ack
17:19:00 <Petrosian> beutdeuce: In GHCi you can :set +s
17:19:06 <Cale> beutdeuce: Not a convenient one in the libraries that lambdabot has, but if it did, it would be IO anyway, so lambdabot would refuse to carry it out.
17:19:09 <Twey> Oh, right
17:19:10 <Gracenotes> no! timing is effectful! thus eevvilll!
17:19:10 <Petrosian> beutdeuce: It'll give time and memory usage
17:19:17 <beutdeuce> k
17:19:26 <Twey> > head [ (x1, x2) | x1 <- [999, 998 .. 100], x2 <- [999, 998 .. 100], show (x1 * x2) == (reverse . show $ x1 * x2) ]
17:19:28 <lambdabot>   (995,583)
17:19:29 <BONUS> although stuff in ghci will run slower than it would compiled
17:19:34 <Cale> Actually not really memory usage. Total allocation.
17:19:34 <Berengal> > head [(x, y) | x <- [999, 998 ..100], y <- [999, 998 .. x], show (x*y) == reverse . show $ x*y]
17:19:36 <lambdabot>   Couldn't match expected type `GHC.Base.String'
17:19:47 <Twey> Why can't \b give more useful parts of error messages?
17:19:58 <Gracenotes> what? a bell? ;o
17:20:00 <Twey> Berengal: $ scopes over the ==
17:20:04 <Berengal> > head [(x, y) | x <- [999, 998 ..100], y <- [999, 998 .. x], show (x*y) == (reverse . show $ x*y)]
17:20:05 <lambdabot>   (924,962)
17:20:09 <Berengal> Twey: I know, I keep forgetting...
17:20:15 <Berengal> 924*962
17:20:19 <Berengal> > 924*962
17:20:21 <lambdabot>   888888
17:20:25 <Berengal> Heey
17:20:30 <Twey> Berengal: Yeah, I did too.  :-P
17:20:31 <Gracenotes> hey hey hey!
17:20:37 <Twey> Hay... loft?
17:20:40 <Gracenotes> ($) consumes all
17:20:50 <Berengal> Gracenotes: Actually, :: consumes all
17:21:02 <Gracenotes> actually, spaces consume all!
17:21:08 <Twey> No, the brackets do!
17:21:12 <Twey> Gracenotes: No they don't :-P
17:21:14 <Gracenotes> no, EOF does!
17:21:16 <Petrosian> EOF consumes all
17:21:18 <mle> Berengal: that isn't the answer though...
17:21:18 <Petrosian> snap.
17:21:30 <Twey> Hahaha
17:21:37 * benmachine is reminded of the moon in majora's mask
17:21:39 <Gracenotes> Twey: spaces bind the most closely, so they consume everything... eventually
17:21:44 <Cale> > maximum [(x1*x2,x1,x2) | (x1:xs) <- tails req, x2 <- (x1:xs), isPal (x1*x2)]
17:21:46 <lambdabot>   Not in scope: `req'Not in scope: `isPal'
17:21:49 <Cale> oh, right ;)
17:21:53 <Berengal> mle: I know, I don't know how to iterate through the factors such that the product is always increasing/decreasing
17:22:02 <Cale> @let isPal x = xs == reverse xs where xs = show x
17:22:04 <lambdabot>  Defined.
17:22:18 <Cale> > let req = [999,998..100] in maximum [(x1*x2,x1,x2) | (x1:xs) <- tails req, x2 <- (x1:xs), isPal (x1*x2)]
17:22:21 <lambdabot>   (906609,993,913)
17:22:26 <Twey> Gracenotes: Hahaha
17:22:38 <Twey> I don't think that's got anything to do with how closely they bind
17:22:41 <Twey> Anyway, it's not true
17:23:05 <Twey> > let f = (*5) in 3 + 4`f`5
17:23:07 <lambdabot>   No instance for (GHC.Num.Num (t1 -> t))
17:23:07 <lambdabot>    arising from a use of `GHC.Num.*...
17:23:15 <Twey> D'oh
17:23:24 <benmachine> Berengal: I'm pretty sure I can write down the list, don't know how to generate it yet though
17:23:32 <Gracenotes> space is metonymy for function application! *ducks*
17:23:37 <Twey> > let f = (*5) in f$3 + 4
17:23:38 <lambdabot>   35
17:23:38 <benmachine> (I can write it down without calculating the products, I mean)
17:23:41 <Twey> There we go.
17:24:01 <Twey> Gracenotes: :-P  Metonymy is error!
17:24:11 <Berengal> benmachine: You're probably doing some kind of differentiation in your head when doing it by hand
17:24:20 <benmachine> Berengal: I don't think so
17:24:35 <Cale> beutdeuce: It's possible that that's the number you wanted to compute
17:24:37 <Cale> > let req = [999,998..100] in maximum [(x1*x2,x1,x2) | (x1:xs) <- tails req, x2 <- (x1:xs), isPal (x1*x2)]
17:24:40 <lambdabot>   (906609,993,913)
17:24:44 <lpsmith> >  foldl (+) 0 [a,b,c,d,e]
17:24:46 <lambdabot>   0 + a + b + c + d + e
17:24:50 <benmachine> you just need to keep in mind a few rules like (x-1)*(x+1) < x*x
17:24:53 <Cale> (I haven't really looked at the problem description)
17:24:57 <beutdeuce> nicw
17:25:00 <beutdeuce> brb, food
17:25:24 <benmachine> well, I guess that IS crude differentiation of a sort
17:25:29 <benmachine> but that doesn't mean it's hard
17:25:47 * benmachine gets a pen and paper
17:26:26 <Berengal> benmachine: Yeah, not neccessarily calculus type differentiation, but you need to know at which point decreasing the first factor would produce a larger product than decreasing the second (assuming you decrease the second by default)
17:27:01 <benmachine> Berengal: I am baselessly hypothesising that it's not difficult to establish when this is the case
17:28:10 <lpsmith> what problem are we discussing?
17:28:48 <benmachine> lpsmith: ordering the products of two lists of integers without first working out what those products are
17:29:00 <lpsmith> ahh
17:29:12 <benmachine> by the products of lists, I mean
17:29:25 <benmachine> [ x * y | x <- list, y <- list ]
17:29:26 <lpsmith> cartesian product,  I got you
17:29:27 <copumpkin> liftA2 (*) list list2
17:31:35 <Twey> zipWith (*) list list2
17:31:48 <copumpkin> :o
17:31:52 <Twey> Is liftA2 for applicatives?
17:31:59 <copumpkin> yup, but those behave differently
17:32:08 <copumpkin> unless you use the ZipList applicative
17:32:13 <Twey> Gah
17:32:17 <Twey> That's so confusing
17:32:21 <Twey> When I see A I think arrows
17:32:25 <Gracenotes> ziplist.. coming to save the day... yeah..
17:32:26 <copumpkin> lol
17:32:40 <lpsmith> There are two ways to turn a list into an applicative ;-)
17:33:12 <Berengal> There are probably more..
17:33:15 <Twey> How does one use ZipList, again?
17:33:24 <Berengal> Twey: getZipList and ZipList
17:33:30 <Twey> :t getZipList
17:33:30 <Gracenotes> @type liftA2 (*) `on` ZipList
17:33:31 <lambdabot> forall a. ZipList a -> [a]
17:33:32 <lambdabot> forall a. (Num a) => [a] -> [a] -> ZipList a
17:33:40 <Twey> Er
17:33:46 <Twey> Isn't that backwards?
17:33:49 <copumpkin> > liftA2 (,) (ZipList [1..3]) (ZipList [1..4])
17:33:50 <lambdabot>   No instance for (GHC.Show.Show
17:33:50 <lambdabot>                     (Control.Applicative.Zip...
17:33:52 <Twey> Oh
17:33:53 <Twey> Right
17:33:58 <Twey> :t ZipList
17:33:59 <lambdabot> forall a. [a] -> ZipList a
17:34:03 <copumpkin> > getZipList $ liftA2 (,) (ZipList [1..3]) (ZipList [1..4])
17:34:05 <lambdabot>   [(1,1),(2,2),(3,3)]
17:34:12 <Gracenotes> yes, not derived. ZipList is not as great as it could be.
17:34:13 <Twey> GADTs, huh
17:34:20 <copumpkin> ?
17:34:23 <copumpkin> nope
17:34:34 <Berengal> newtype ZipList a = ZipList [a]
17:34:35 <Twey> forall a. [a] -> ZipList a on a constructor?
17:34:47 <copumpkin> :t Dual
17:34:47 <Gracenotes> @type Just
17:34:49 <lambdabot> forall a. a -> Dual a
17:34:49 <lambdabot> forall a. a -> Maybe a
17:34:50 <Twey> Berengal: Er, that's infinitely recursive
17:35:02 <Berengal> Twey: No
17:35:11 <Twey> copumpkin: That doesn't perform extraction, though
17:35:14 <Gracenotes> hmm.. newtypes have constructors
17:35:21 <copumpkin> Twey: nope, but it's the same thing
17:35:28 <Berengal> Gracenotes: "constuctors"
17:35:29 <benmachine> bah
17:35:36 <Twey> copumpkin: How do you write the type of ZipList without GADTs?
17:35:38 <copumpkin> Twey: for the newtype the LHS is the type constructor and the RHS is the data constructor, with different namepaces
17:35:42 <benmachine> I had a pattern with multiplications that lasted for the first 15
17:35:44 <copumpkin> Twey: what Berengal wrote
17:35:47 <benmachine> and then the 16th broke :(
17:35:49 <Twey> o.@
17:35:57 <Twey> Oh
17:36:00 <Twey> I see
17:36:03 <Berengal> Twey: You need a coffee, it would seem :P
17:36:04 <Twey> Oh!
17:36:05 <Twey> Sorry
17:36:06 <Twey> Yeah
17:36:07 <copumpkin> Twey is having a bad haskell day :)
17:36:08 <Gracenotes> !!
17:36:10 <Twey> Something of that nature
17:36:24 <benmachine> coffee at 1:36 is a bad idea
17:36:24 <copumpkin> need moar zygohistomoprhic prepromorphisms kthx
17:36:25 <Gracenotes> forsooth
17:36:42 * Twey laughs.
17:36:45 <Twey> benmachine: Nah
17:36:52 <Twey> I'm currently nocturnal
17:36:54 <copumpkin> @localtime Twey
17:36:56 <lambdabot> Local time for Twey is Fri Jul 17 01:36:54 2009
17:37:00 <copumpkin> zomg
17:37:07 <benmachine> I am trying to avoid being so
17:37:18 <benmachine> and not doing particularly well as you might note
17:37:47 * Berengal spontaneously became nocturnal a few days ago and lost two days at work
17:41:52 <Gracenotes> if my sleep is left unchecked I may go into nocturnal mode
17:42:31 <Gracenotes> recently my sleep hours were about 12 PM - 8 PM
17:42:38 <Gracenotes> currently, normal.
17:43:34 <beutdeuce> > head [(x1,x2) | x1 <- [999,998..100], x2 <- tails [999,998..100], show(x1*x2) == reverse(show(x1*x2))]
17:43:35 <lambdabot>   No instance for (GHC.Num.Num [t])
17:43:36 <lambdabot>    arising from the literal `999' at <int...
17:43:49 <beutdeuce> head [(x1,x2) | x1 <- [999,998..100], x2 <- [999,998..100], show(x1*x2) == reverse(show(x1*x2))]
17:43:55 <beutdeuce> > head [(x1,x2) | x1 <- [999,998..100], x2 <- tails [999,998..100], show(x1*x2) == reverse(show(x1*x2))]
17:43:57 <lambdabot>   No instance for (GHC.Num.Num [t])
17:43:57 <lambdabot>    arising from the literal `999' at <int...
17:44:04 <beutdeuce> lol
17:44:13 <beutdeuce> > head [(x1,x2) | x1 <- [999,998..100], x2 <- [999,998..100], show(x1*x2) == reverse(show(x1*x2))]
17:44:14 <lambdabot>   (995,583)
17:44:41 <beutdeuce> > product (995,583)
17:44:43 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(t, t1)'
17:44:56 <Twey> benmachine, Berengal: Yeah, I know how that goes :-\
17:45:06 <beutdeuce> > product [995,583]
17:45:07 <lambdabot>   580085
17:45:19 <benmachine> beutdeuce: head is not what you want
17:45:26 <benmachine> you want the maximum of that list, not the first element
17:45:37 <beutdeuce> o, right
17:45:44 <beutdeuce> > maximum [(x1,x2) | x1 <- [999,998..100], x2 <- [999,998..100], show(x1*x2) == reverse(show(x1*x2))]
17:45:48 <lambdabot>   (995,583)
17:46:06 <beutdeuce> well, the head is the maximum, cause the largest values are in the first element
17:46:39 <al23> Hi! Slightly off-topic: does anybody know what happened with developements in graph reduction hardware? Are there any practical implementations?
17:47:05 <beutdeuce> huh, surprisingly, that is not the right answer
17:47:24 <Berengal> > maximum [(x1 * x2) | x1 <- [999,998..100], x2 <- [999,998..100], show(x1*x2) == reverse(show(x1*x2))]
17:47:28 <lambdabot>   906609
17:48:39 <beutdeuce> hmm, wonder why mine didnt work
17:49:22 <benmachine> beutdeuce: the largest values for x1 are in the first element
17:49:47 <Berengal> It has to do with the Ord instance for pairs
17:49:52 <benmachine> beutdeuce: your tuples are (999,999) (999,998) (999,997)... but 998*998 is bigger than 999*997
17:50:39 <beutdeuce> ah, that is why Cale used tails
17:51:24 <beutdeuce> bbl
17:57:08 <benmachine> @src Monad
17:57:08 <lambdabot> class  Monad m  where
17:57:08 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
17:57:08 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
17:57:08 <lambdabot>     return      :: a -> m a
17:57:08 <lambdabot>     fail        :: String -> m a
18:00:22 <QinGW>  what is the meaning of `list comprehensive?
18:01:17 <Zao> "list comprehension"?
18:01:45 <Zao> > [(x,y) | x <- [0..2], y <- "lol"]
18:01:46 <lambdabot>   [(0,'l'),(0,'o'),(0,'l'),(1,'l'),(1,'o'),(1,'l'),(2,'l'),(2,'o'),(2,'l')]
18:03:49 <QinGW> Zao: just permutation?
18:05:04 <Zao> QinGW: You can also put predicates in there.
18:05:07 <benmachine> > [x | x <- [0..10], odd x]
18:05:09 <lambdabot>   [1,3,5,7,9]
18:05:13 <al23> QinGW, no. Just a way to construct a list. Like set comprehension.
18:06:04 <Zao> http://www.haskell.org/haskellwiki/List_comprehension
18:07:04 <QinGW> benmachine: It looks like filter?
18:07:27 <QinGW> Thanks all.
18:08:49 <Zao> > do { x <- [0..10] ; guard (even x) ; return x }
18:08:50 <lambdabot>   [0,2,4,6,8,10]
18:11:05 <QinGW> hi all, Which aspect knowlegde is good for learning haskell? I feel it is difficult to in.
18:16:07 <al23> So, anybody aware of the graph reduction hardware? Was it actually implemented? I don't see any relevant papers since the mid-90's :-(
18:16:19 <drhodes> QinGW: have you seen the `Real World Haskell` book at: http://book.realworldhaskell.org/read/index.html ?
18:16:40 <Cale> al23: you might be interested in the reduceron
18:16:54 <Cale> al23: which is an FPGA implementation of graph reduction
18:17:51 <Cale> http://www.cs.york.ac.uk/fp/reduceron/
18:17:53 <QinGW> drhodes: Nope, I am reading programing in haskell now, thanks, if it is good I will get it.
18:17:54 <al23> QinGW: I found "The Haskell Road to Logic, Maths and Programming" very useful.
18:18:05 <al23> Cale: thanks.
18:19:09 <al23> Cale: Is it just a virtual machine?
18:19:38 <Cale> no, it's an actual fpga configuration
18:20:13 <QinGW> al23: I will google them for detail, someone will delicious,ha
18:20:26 <jeffwheeler> Is a Bag just a Set that can have duplicate elements?
18:20:34 <Cale> jeffwheeler: yes
18:20:39 * jeffwheeler wins
18:21:28 <EvilTerran> Bag a ~= Map a Nat
18:22:32 <EvilTerran> (a -> Nat) would probably be a better characterisation, actually
18:23:23 <Cale> al23: the initial results were fairly promising. Apparently they got naive code on a 92MHz FPGA to run only 5x slower than ghc -O2 code on a 2.8 GHz machine :)
18:24:24 <Cale> (I'm not sure what the actual benchmark itself was)
18:24:32 <gwern> 'The ancient greek philosopher Parmenides provided a proof that change is impossible. It therefore stands to reason that there is only one moment in time, and it never changes. This library provides an interface to that moment, allowing it to be used in computations. '
18:24:37 <gwern> -_-
18:24:40 <jeffwheeler> It's odd how the GHC modules aren't in logical namespaces. I'd expect Bag to be in Data.Bag, or at least GHC.Bag, but it's just Bag.
18:24:47 <jeffwheeler> That's true for a lot of GHC things . . .
18:25:52 <copumpkin> hierarchical module names are an extension
18:26:05 <copumpkin> not sure if GHC wants to use extensions in its own source code
18:26:08 <copumpkin> but maybe?
18:26:29 <Cale> GHC does use extensions, doesn't it?
18:26:40 <jeffwheeler> gwern: it really should have a more amusing source: http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/src/Acme-Time-Now.html#now
18:26:48 <Cale> I don't think GHC can be compiled by anything but GHC right now, anyway
18:26:56 <copumpkin> ah :)
18:27:05 <copumpkin> well there goes that explanation then :P
18:27:30 <gwern> jeffwheeler: needs a witty quote from the pre-socratics
18:27:46 <jeffwheeler> gwern: definitely
18:27:57 <Cale> However, GHC development started *way* before hierarchical namespaces.
18:27:58 <gwern> perhaps, "Fools. For their thoughts are not far-reaching,\u000Awho expect that there comes to be what previously was not,\u000Aor that anything perishes & is completely destroyed."
18:29:31 <al23> Cale: There was a bunch of such projects even in 80's, but, unfortunately, every paper I've seen says nothing about practical usage...
18:30:04 <gwern> al23: commodity archs always win in the long run
18:30:32 <jrick> Cale: are you in charge of lambdabot?
18:30:43 <Cale> jrick: I just run it on lispy's machine
18:30:55 <beutdeuce> back :)
18:31:00 <Cale> jrick: If you want it to join a channel, I can probably help with that :)
18:31:01 <jrick> Cale: it is possible to have lambdabot join #colemak?
18:31:03 <Cale> sure
18:31:10 <Cale> lambdabot: @join #colemak
18:31:14 <jrick> ok, thanks
18:31:19 <jrick> @join #colemak
18:31:19 <lambdabot> Not enough privileges
18:32:04 <jrick> thanks Cale
18:36:49 <beutdeuce> > maximum [x1*x2 | x1 <- [999,998..100], x2 <- [999,998..100], show(x1*x2) == reverse(show(x1*x2))]
18:36:53 <lambdabot>   906609
18:37:08 <beutdeuce> hmm, ghci doesnt want to load that
18:38:18 <beutdeuce> what was that :set trick again that displayed running time and memory usage?
18:39:54 <Petrosian> beutdeuce: :set +s
18:39:59 <beutdeuce> yeah, thnx
18:43:58 <beutdeuce> why doesnt it work when i try to --make " main = maximum [x1*x2 | x1 <- [999,998..100], x2 <- [999,998..100], show(x1*x2) == reverse(show(x1*x2))]" ?
18:47:39 <beutdeuce> Cale, do you have any idea why i cant --make, "main = maximum [x1*x2 | x1 <- [999,998..100], x2 <- [999,998..100], show(x1*x2) == reverse(show(x1*x2))]" ?" ?
18:47:59 <ivanm> does anyone know if 6.10.4 has fixed the "ghc-pkg check" bug?
18:48:47 <tromp_> main must be type IO ()
18:49:09 <tromp_> do main = print $ maximum ...
18:49:16 <beutdeuce> i see
18:49:18 <beutdeuce> what does $ mean?
18:49:25 <ivanm> beutdeuce: function application
18:49:28 <ivanm> @src ($)
18:49:28 <lambdabot> f $ x = f x
18:49:37 <ivanm> beutdeuce: f $ g x == f (g x)
18:49:44 <tromp_> just alternative to putting () around the rest
18:49:46 <beutdeuce> ah, so u wouldnt have to wrap parens?
18:49:49 <ivanm> yup
18:49:51 <beutdeuce> k
18:49:55 <beutdeuce> cool
18:50:13 <tromp_> f (g (h x)) = f $ g $ h x
18:50:25 <tromp_> or, f . g . h $ x
18:50:33 <ivanm> or f . g $ h x
18:50:35 <tromp_> is the idiomatic way
18:50:45 <beutdeuce> what does '.' signify?
18:50:50 <Cale_> (.) is function composition
18:50:53 <beutdeuce> ah
18:50:55 <Cale_> (f . g) x = f (g x)
18:50:55 <beutdeuce> right
18:51:12 <Cale_> It's a nicer operation than $ because (f . g) . h = f . (g . h)
18:51:13 <beutdeuce> say, program runs "much" faster when compiled
18:51:35 <Cale_> Indeed. Compiling with optimisations is pretty much necessary if you care about performance.
18:51:36 <ivanm> beutdeuce: yup
18:51:51 <beutdeuce> Cale_:  with optimizations?
18:51:54 <ivanm> Cale_: and most people do ;-)
18:52:01 <ivanm> beutdeuce: ghc -O2 --make Main.hs
18:52:02 <Cale_> beutdeuce: -O2
18:52:13 <beutdeuce> o.0 what does that mean?
18:52:41 <Cale_> beutdeuce: It signifies that the compiler is supposed to take many different various steps to simplify the code
18:53:00 <ivanm> beutdeuce: you can go higher in some compilers, but it leads to possible bugs
18:53:19 <ivanm> e.g. gcc has -03 (anything > 3 is the same as 3), but it isn't recommende
18:53:22 <ivanm> *recommended
18:53:47 <Cale> In GHC, I'm pretty sure -O2 is the highest setting at the moment. It used to be that -O3 did nothing at all, but now it's clipped to 2.
18:54:06 <ivanm> yeah, I don't recall an -O3
18:55:06 <beutdeuce> hmm, doesnt seem to be much (*any) of a difference with the palindrome program: optimized = 0.268s, regular = 0.268s
18:55:38 <Petrosian> It's a pretty small program
18:56:05 <ivanm> and presumably not much you can do to optimise it
18:56:13 <ivanm> since you're in effect manually walking a list I presume
18:57:19 <pikhq> An optimizer can't make better algorithms for you, it can only make the algorithm you chose do steps faster.
18:57:39 <ivanm> pikhq: sometimes in ways you didn't expect
18:57:48 <pikhq> ivanm: Well, yes.
18:58:08 <ivanm> wasn't it roconnor that had the issue where he tried translating Python code into haskell, and found that it was faster than he wanted/expected due to optmisations?
18:58:16 <ivanm> (IIRC he was using the Writer monad...)
18:58:25 <Cale> It can sometimes, in GHC. Turning on optimisations means rewrite rules get switched on, and rewrite rules can change the asymptotic complexity of your program.
18:58:47 <beutdeuce> actually nvm, it never compiled the regular version, just re-linked because ghc saw the .hi files already, once i re-compiled correctly: http://i3.photobucket.com/albums/y75/gmaster1440/Picture1-11.png. The funny thing is that system time remains the same. Why is that?
18:59:11 <ivanm> beutdeuce: IIRC, system time == kernel time
18:59:16 <ivanm> which you can usually ignore
18:59:30 <dobblego> @type (null .) . drop
18:59:32 <lambdabot> forall a. Int -> [a] -> Bool
19:00:02 <beutdeuce> so, -O2 proved to be a tenth second faster for palindrome program
19:07:29 <pikhq> Cale: Huh.
19:08:57 <mle> beutdeuce: try going to 4 digits.
19:09:22 <ManateeLazyCat> Hi all, today i install GHC-6.10.4 on my Ubuntu 9.04 (CPU is AMD64), but i got error "error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory" when i run command ghci
19:09:24 <ManateeLazyCat> How to fix it? Thanks!
19:09:31 <beutdeuce> mle: i'm currently trying to find the 10001st prime :)
19:09:39 <mle> ahh
19:10:06 <Cale> ManateeLazyCat: Wasn't that the library which one version of the GHC binary included and the other didn't?
19:11:02 <ManateeLazyCat> Cale: sudo aptitude install haskell-utils perl gcc libgmp3-dev libc6 libgmp3c2 libncurses5 libreadline5 libreadline5-dev libedit2 libedit-dev libx11-dev libxext-dev libxt-dev libxinerama-dev -y
19:11:11 <Zao> tinfo is from ncurses, isn't it?
19:11:28 <Cale>     *
19:11:28 <Cale>       Generic i386 Linux. This is a complete build, including interactive system, profiling libraries and documentation.
19:11:28 <Cale>           o ghc-6.10.4-i386-unknown-linux-n.tar.bz2 (72 MB)
19:11:28 <Cale>     * Generic i386 Linux. You need to have a file /lib/libtinfo.so.5 to use this bindist. This is a complete build, including interactive system, profiling libraries and documentation.
19:11:28 <Cale>           o ghc-6.10.4-i386-unknown-linux.tar.bz2 (74 MB)
19:11:49 <jrick> @fact haskell
19:11:49 <lambdabot> I know nothing about haskell
19:11:53 <Cale> If you don't have libtinfo.so.5, you should pick the first one :)
19:12:10 <Cale> (from http://haskell.org/ghc/download_ghc_6_10_4.html)
19:12:54 <ManateeLazyCat> Cale: Oh, god, i download second version
19:13:15 <ManateeLazyCat> Cale: Sorry for noise, i download firs tone.
19:13:41 <ManateeLazyCat> Thanks.
19:13:45 <Cale> no problem
19:20:57 <beutdeuce> there has to be a quicker way to calculate the 10001th prime other than, [ x | x <- 1..], isPrime x == True] !! 10000
19:21:27 <pikhq> Uh, duh?
19:21:29 <copumpkin> lol
19:21:36 <copumpkin> == True is generally a bad sign, first of all
19:21:59 <beutdeuce> lol, yeah
19:22:04 <copumpkin> but yeah
19:22:12 <copumpkin> there are better ways :P
19:22:26 <Berengal> primes = 2:[n | n <- [3,5..], isPrime n]; isPrime n = n == head (factorize n)
19:22:50 <copumpkin> lol
19:22:52 <Berengal> factorize is a little more involved...
19:22:57 <Berengal> (but not much)
19:23:00 <beutdeuce> o.0
19:23:24 <pikhq> Especially if you do it in terms of primes. ;)
19:23:30 <copumpkin> not sure that's very efficient either :P
19:23:42 <pikhq> (and yes, that works just fine)
19:23:44 <mike-burns> But to get the 10001th prime you still have to go through all of that list.
19:24:01 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7108#a7108
19:24:16 <Berengal> Not incredibly efficient, but it's beautiful
19:24:26 <copumpkin> seems like it's an unfold
19:24:42 <davidL> > (!!10001) $ nubBy (\x y -> mod x y == 0) [2..]
19:24:44 <pikhq> mike-burns: Sadly, the most efficient way of getting the 10001th prime involves calculating the other 10000. ;)
19:24:47 <lambdabot>   mueval-core: Prelude.read: no parse
19:24:48 <lambdabot>  mueval: ExitFailure 1
19:25:14 <mike-burns> pikhq: Yeah I realized that just as I hit enter. It's past my bedtime.
19:25:18 <Berengal> The sieve of O'Neill works nicely, and it's beautiful code as well
19:25:23 <copumpkin> yeah
19:25:30 <copumpkin> but its priority queue is apparently broken :P
19:25:31 <pikhq> davidL: Nice try at least. ;)
19:25:41 <davidL> :)
19:25:43 <ivanm> there's at least two packages on hackage IIRC that have a prime sieve function...
19:25:47 <Berengal> copumpkin: It's the thought that matters
19:25:53 <copumpkin> yeah :)
19:26:50 <beutdeuce> lol :D => http://www04.wolframalpha.com/input/?i=10001th+prime
19:27:30 <mike-burns> Ah, so the fastest way to get the 10001th prime is to scrape HTML.
19:27:41 <copumpkin> lol
19:27:43 <Cale> MathLink!
19:28:08 <Berengal> mike-burns: The fastest way is to download a list of primes in advance
19:29:53 <ivanm> Berengal: no, you need to hard-code all possible primes into your program
19:30:18 <Berengal> ivanm: That's what #include is for
19:30:31 <ivanm> ahhhh
19:30:37 <ivanm> well, you still need to have it in C code
19:30:43 <Berengal> awk
19:30:54 <jmcarthur> suddenly this isn't sounding so fast
19:31:00 <ivanm> is that "awk the tool" or "awk the sound of surprise"? :p
19:31:06 <ivanm> jmcarthur: oh, it will be fast to run...
19:31:07 <Berengal> The tool :)
19:31:17 <jmcarthur> not so fast to write
19:31:21 <ivanm> might take you a while (*cough* forever *cough*) to write ;-)
19:31:57 <Berengal> wget www.someprimesite.org/primes -o primes && awk 'magic' primes
19:33:38 <mike-burns> My favorite way to optimise something: tell the client she doesn't need that feature.
19:33:58 <mike-burns> 2 is as good of a prime as you'll ever need.
19:34:06 <ivanm> mike-burns: what happens if the client is male?
19:34:13 <SubStack> singular they people!
19:34:25 <mike-burns> Bah, "they" isn't singular!
19:34:35 <SubStack> it can be semantically singular
19:34:43 <SubStack> and grammatically plural
19:35:00 <mike-burns> ivanm: Ask to speak to his wife/girlfriend/sister, and tell her to tell him that he doesn't need that feature.
19:35:03 <ivanm> "tell them..."
19:35:05 <ivanm> ;-)
19:35:17 <ivanm> mike-burns: heh
19:35:33 <ivanm> and then the wife/girlfriend/sister/random says "wuh?"
19:35:37 <Berengal> Primes are much simpler if you consider 1 to be a prime as well. Everything is divided by 1, so only 1 is prime, alternatively, 1 is prime, n+1 is prime if n is prime, works for 2 and 3 so proof by induction ;)
19:35:44 <ivanm> because they have no idea what that person is talking about ;-)
19:35:52 <mike-burns> Ha.
19:35:52 <ivanm> Berengal: heh
19:36:10 <SubStack> I blame the prescriptivist grammarians for discouraging the perfectly acceptable singular use of they/their/them
19:37:27 <Cale> A more interesting question is whether we want to consider 0 to be prime. It does make sense to do so for integral domains, because <0> is then a prime ideal.
19:40:37 <Cale> (but usually, 0 is excluded from being a prime element as well)
19:42:11 <beutdeuce> YES!!! I'M SO HAPPY BECAUSE I WAS ABLE TO SUCCESSFULLY IMPLEMENT CALE's TAILS TECHNIQUE IN A PROBLEM!
19:42:21 <beutdeuce> sorry about the caps, just happy :)
19:44:14 * wmealing_ cheers
19:44:38 <beutdeuce> if you're interested => http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7111#a7111 :)
19:45:53 <beutdeuce> if you think u got a better solution, tell me ;)
19:49:22 <davidL> Cale's tails
19:49:36 <Cale> heh
19:49:36 <beutdeuce> :)
19:51:06 <PhilMikeHunt> hello
19:51:16 <PhilMikeHunt> is this the channel for homework help?
19:51:23 <Zao> Depends.
19:51:30 <PhilMikeHunt> on?
19:51:41 <Zao> On whether you have concrete questions about some aspect of it.
19:51:46 <mike-burns> On if the homework is relevant to Haskell.
19:51:48 <Zao> Or just want someone to do it for you.
19:51:50 <PhilMikeHunt> oh ok
19:51:54 <Berengal> It's for homework help, amongs other things, but help doesn't mean we'll do it for you
19:52:21 <PhilMikeHunt> ok i just need some ideas for my thesis.
19:52:35 <PhilMikeHunt> does anyone know much of Picasso's "Guernica"?
19:52:52 <PhilMikeHunt> its for a research paper i'm working on
19:53:20 <Berengal> I know of it, but I doubt it has anything to do with Haskell...
19:53:30 <divs> beutdeuce, i'm not sure what you consider a "better" solution, but if you mean "faster", then use addition instead of multiplication, and preprocess the input by deleting 0s.  it won't make much of a difference for that number, but for a million digit number it could
19:53:39 <PhilMikeHunt> oh what is haskell?
19:53:49 <jmcarthur> a programming language
19:54:07 <PhilMikeHunt> oh sorry i thought this was for all subjects
19:54:25 <divs> although honestly if you have a million digit number then the largest product is probably 9^5 lol
19:55:06 <beutdeuce> divs: :)
19:55:30 <Berengal> Does the greatest product also mean the greatest sum?
19:55:45 <divs> assuming strictly positive integers
19:55:52 <Berengal> They're not
19:55:59 <beutdeuce> Berengal: there are 0's
19:56:09 <divs> well i also said pre-process the string and delete 0s :P
19:56:26 <Berengal> Ah, right. It'd mean splitting at 0
19:56:29 <divs> because anything with a 0 obviously isn't going to be the greatest product
19:57:44 <divs> if you want something fun, try solving the same problem with no arithmetic other than comparison
19:58:13 <beutdeuce> o.0
19:58:34 <beutdeuce> too bad you're not allowed to overload typeclasses in the standard :P
20:02:00 <Cale> Well, you sort of can, it's just bloody inconvenient to do it.
20:02:18 <Cale> (don't import the Prelude)
20:10:15 <Twey> Cale: I don't think that counts as overloading :-P
20:11:22 <Cale> fair enough :)
20:13:09 <beutdeuce> >  [[a,b,c] | a <- [100..], b <- [100..], c <- [100..], a+b+c == 1000]
20:13:12 * Cale is surprised at the number of people who will argue that computing a hash for a hashtable can be done in O(1) time, that is, independent of the size of the hashtable.
20:13:14 <lambdabot>   mueval-core: Prelude.read: no parse
20:13:15 <lambdabot>  mueval: ExitFailure 1
20:13:20 <beutdeuce> ?
20:13:37 <Cale> beutdeuce: sorry about the crap error message, that means it timed out
20:13:43 <beutdeuce> oh
20:13:44 <beutdeuce> k
20:13:52 <beutdeuce> hmm, why didnt it list some values?
20:14:50 <Cale> Well, there's only one, and then it takes forever to find another.
20:14:57 <Cale> > head [[a,b,c] | a <- [100..], b <- [100..], c <- [100..], a+b+c == 1000]
20:14:59 <lambdabot>   [100,100,800]
20:14:59 <beutdeuce> why is there only one?
20:15:01 <Berengal> Cale: Depends on what you mean by "computing the hash". Finding the index in a hashtable is a two-step process
20:15:08 <Cale> Because you never get to b = 101
20:15:14 <beutdeuce> o
20:15:26 <Cale> (because there are infinitely many c values to go through first)
20:15:39 <beutdeuce> i thought Haskell is lazy when it comes to stuff like that
20:15:55 <monochrom> lazy is different from smart
20:16:05 <monochrom> you assumed smart.
20:16:10 <Cale> It's lazy, but it's not clever enough to diagonalise automatically. It can't tell whether a list is infinite or not in general.
20:16:31 <beutdeuce> learn yourself a haskell gave an example where he used an infinite list in a comprehension and said it was lazy so thats why it worked
20:16:39 <Cale> Yeah, one infinite list is fine
20:16:47 <Cale> two becomes problemative
20:16:52 <Cale> problematic*
20:17:00 <monochrom> filter (< 0) [100..] takes forever and emits nothing, despite your wish.
20:17:01 <Berengal> One infinite list is only fine if it's the first list
20:17:10 <beutdeuce> ah, what if you take Haskell's parallel library into account?
20:17:29 <Berengal> beutdeuce: It still wouldn't know what order to insert things in
20:17:38 <Cale> > [100..] >>- \a -> [100..] >>- \b -> [100..] >>- \c -> guard (a + b + c == 1000) >> return [a,b,c]
20:17:40 <lambdabot>   [[100,100,800],[101,100,799],[100,101,799],[102,100,798]* Exception: stack ...
20:17:48 <Cale> heh
20:18:02 <Cale> Curious stack overflow there... hmm
20:18:09 <Berengal> @type (>>-)
20:18:09 <heatsink> Are those arrows?
20:18:10 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
20:18:15 <Berengal> Ooo
20:18:39 <beutdeuce> > [[a,b,c] | a <- [500..1000], b <- [500..1000], c <- [500..1000], a+b+c == 1000]
20:18:44 <Cale> It's like >>= but fair.
20:18:45 <lambdabot>   mueval-core: Prelude.read: no parse
20:18:45 <lambdabot>  mueval: ExitFailure 1
20:18:51 <beutdeuce> ? why did that time out?
20:18:52 <aavogt> is there a difference between monadlogic and the omega one?
20:18:59 <Twey> MonadLogic?
20:18:59 <Berengal> Cale: Ah, right, I think I skimmed a paper about that...
20:19:07 <Twey> Fair how?
20:19:11 <aavogt> Twey: the one cale used
20:19:15 <Cale> beutdeuce: because it's still got to go through a hell of a lot of possibilities
20:19:22 <Twey> Oh, yeah, I saw that
20:19:26 <Berengal> 500^3
20:19:31 <Berengal> > 500^3
20:19:33 <Cale> > 500^3
20:19:33 <lambdabot>   125000000
20:19:35 <lambdabot>   125000000
20:19:38 <Twey> Fair as in it takes one value from each in turn rather than in order?
20:19:49 <Twey> @src [] (>>-)
20:19:49 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:19:53 <Twey> :(
20:20:01 <monochrom> You should learn lazy evaluation properly first.
20:20:24 <beutdeuce> > [[a,b,c] | a <- [500..600], b <- [500..600], c <- [500..600], a+b+c == 1000]
20:20:28 <lambdabot>   []
20:20:30 <beutdeuce> ?
20:20:57 <Twey> 500+500+500 = 1500
20:20:57 <monochrom> 500+500+500=?
20:20:59 <Petrosian> 500+500+500 > 1000
20:21:14 <beutdeuce> ... no thats not what its doing
20:21:20 <Twey> Yup
20:21:36 <beutdeuce> oh right,...idiot
20:21:44 <Twey> Therefore, there's no combination of three values between 500 and 600 that are equal to 1000
20:21:49 <Twey> :)
20:22:11 <beutdeuce> yep
20:22:12 <Cale> > [[a,b,c] | a <- [1..1000], b <- [1..1000-a-1], let c = 1000 - a - b]
20:22:14 <lambdabot>   [[1,1,998],[1,2,997],[1,3,996],[1,4,995],[1,5,994],[1,6,993],[1,7,992],[1,8...
20:22:32 <Cale> er
20:22:57 <Cale> that should probably be a <- [1..1000-2]
20:23:10 <Twey> *nod*
20:23:32 <Twey> Hey, I didn't know you could embed lets into LCs.
20:23:32 <beutdeuce> dam, i'm trying to find a pythagorean triplet where a+b+c=100
20:23:45 <beutdeuce> a+b+c=1000*
20:24:14 <beutdeuce> no help yet though
20:24:16 <beutdeuce> still trying
20:24:19 <Berengal> > [(a,b,c) | a <- [1..1000], b <- [a..1000], let c = 1000 - (a+b), a^2+b^2 == c^2]
20:24:24 <lambdabot>   [(200,375,425)]
20:24:33 <Twey> Erm
20:24:36 <Twey> Hmn
20:24:45 <Berengal> Huh, it worked
20:24:58 <monochrom> Don't use the computer for brute-force search. It's terrible on the computer.
20:25:05 <Twey> Psht
20:25:14 <Twey> I use the list monad for brute-force search all the time :-P
20:25:34 <Twey> @let pythagorean (a, b, c) = a ^ 2 + b ^ 2 == c ^ 2
20:25:35 <lambdabot>  Defined.
20:25:43 <Twey> > pythagorean (200, 375, 425)
20:25:44 <lambdabot>   True
20:26:03 <monochrom> My first instinct would be the same as Berengal's code. At least there is no point trying more c's than those.
20:26:04 <beutdeuce> i hate you guys :), i'm still trying my own
20:26:04 <Berengal> > pythagorean (3,4,5)
20:26:07 <lambdabot>   True
20:26:44 <Berengal> monochrom: My first instinct as well. My second would be to limit a < 333 and b < 666
20:27:16 <inimino> Berengal: wouldn't it have found it by then anyway?
20:27:19 <Twey> > [ r | let r = (a, b, c), a <- [1 .. 98], b <- [1 .. 98], c <- [1 .. 98], pythagorean r, a + b + c == 100 ]
20:27:24 <lambdabot>   mueval-core: Prelude.read: no parse
20:27:24 <lambdabot>  mueval: ExitFailure 1
20:27:30 <Twey> Darn, too slow :-P
20:27:44 <monochrom> I detest most people's way of playing Project Euler. They think doing it will learn them both unfamiliar math and unfamiliar language at the same time. Clearly it's a lose-lose situation.
20:28:01 <Berengal> inimino: Yes, but I wouldn't know that unless I'd tried, at which point any further optimization would be useless
20:28:10 <Berengal> (Not that it was useful in the first place)
20:28:50 <Berengal> Twey: That works?
20:28:54 <Twey> Sure
20:28:55 <Twey> Slowly
20:28:58 <inimino> Berengal: ah, you mean if you didn't know if there was a solution, sure
20:29:13 <Berengal> Twey: I mean the let appearing before a b and c are defined
20:29:22 <Twey> Oh, no, it apparently doesn't
20:29:32 <Twey> It has to go afterward
20:29:41 <Berengal> list comprehensions /= mfix
20:29:47 <Twey> Yeah :)
20:30:05 <Twey> Hm
20:30:07 <Twey> [ r | a <- [1 .. 98], b <- [1 .. 98], c <- [1 .. 98], let r = (a, b, c), pythagorean r, a + b + c == 100 ]
20:30:11 <Twey>  returns []
20:30:17 <Berengal> monochrom: I use PE for learning new languages. I already know the math for the first 50-60-ish problems
20:30:26 <monochrom> Yes that works.
20:30:46 <Twey> I can usually pick up necessary maths of WP
20:30:48 <Twey> off**
20:31:04 <Berengal> Anyway, I used haskell to learn the math behind those PE problems, at the same time I was learning haskell
20:31:15 <Berengal> Haskell + PE was clearly a win-win for me
20:32:01 <monochrom> That's anecdotal. This channel witnesses way more failures than successes on this.
20:32:32 <monochrom> Quitting school worked for Bill Gates, too.
20:32:43 <inimino> "That's anecdotal.  <anecdote>"
20:32:58 <mike-burns> That was his point?
20:32:58 <Twey> Hahaha
20:33:08 <Berengal> I think a general knowledge of programming and HS math is good enough to get past the first 20 problems...
20:34:40 <jdrake> What is the easiest explanation of why (do x <- id; y <- reverse; return (x, y))  has the type [a] -> ([a], [a]). The 'return' is an easy way to see the ([a], [a]), but I am failing to see the initial parameter.
20:35:17 <copumpkin> you're using the function monad
20:35:31 <performance> after reading some posts recently about implementing hammurabi the game in haskell, i made this ..  http://www.reddit.com/r/programming/comments/91x7d/project_hammurabi/
20:35:32 <copumpkin> :t liftM2 (,) id reverse
20:35:33 <lambdabot> forall a. [a] -> ([a], [a])
20:35:40 <copumpkin> > liftM2 (,) id reverse [1..5]
20:35:41 <Berengal> jdrake: id has type (Monad m) => m a, and it has type (a -> a), indicating you're in the function monad
20:35:41 <lambdabot>   ([1,2,3,4,5],[5,4,3,2,1])
20:35:59 <performance> comments from interested folks here would be very very welcome :)
20:36:27 <jdrake> What precisely is the function monad?
20:36:59 <copumpkin> > fmap (+1) (+2) 4
20:37:01 <lambdabot>   7
20:37:16 <copumpkin> its functor is basically composing
20:37:22 <jdrake> oh no, not fmap again :p
20:37:32 <Berengal> (.) = fmap
20:37:40 <ray> fmap = (.)
20:37:42 <pjb3> how do you get the value from a Just?
20:37:48 <copumpkin> > (+1) `fmap` (+2) 4
20:37:49 <lambdabot>   No instance for (GHC.Num.Num (f a))
20:37:50 <lambdabot>    arising from the literal `2' at <int...
20:37:52 <copumpkin> > (+1) `fmap` (+2) $ 4
20:37:53 <lambdabot>   7
20:37:58 <monochrom> use pattern matching to get the value from a Just
20:37:58 <Berengal> f >>= g = \x -> g (f x) x
20:38:03 <pjb3> > (Just 4) + 5
20:38:03 <mike-burns> jdrake: Back to your original question, it might make more sense to you if you re-write it using >>= .
20:38:05 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
20:38:05 <lambdabot>    arising from the lite...
20:38:19 <copumpkin> > fmap (+5) (Just 4)
20:38:20 <lambdabot>   Just 9
20:38:34 <copumpkin> > fromJust (Just 4) + 5 -- but I don't recommend it
20:38:36 <lambdabot>   9
20:38:36 <Berengal> pjb3: Pattern match on it, use fromMaybe or maybe (or fromJust, but it's risky), or simply don't
20:38:38 <mike-burns> pjb3: fromjust
20:38:45 <ray> > liftA2 (+) (Just 4) (Just 5)
20:38:47 <lambdabot>   Just 9
20:39:00 <Berengal> > fmap (+3) (Just 4)
20:39:02 <lambdabot>   Just 7
20:39:12 <monochrom> There is some analogy between fromJust and unsafePerformIO
20:39:13 <jdrake> hmm, i must remember >>=
20:39:32 <Berengal> jdrake: >>= in the function monad is S from combinator calculus
20:39:32 <Petrosian> > do { x<- Just 1; return $ x + 4 }
20:39:34 <lambdabot>   Just 5
20:39:39 <Berengal> return is K'
20:39:45 <copumpkin> Berengal: not sure that'll help him :P
20:39:53 <ray> fromJust is bad stuff
20:39:54 <jdrake> Berengal: I do regular calculus
20:40:15 <copumpkin> thar be many calculi
20:40:21 <Berengal> http://en.wikipedia.org/wiki/SKI_combinator_calculus
20:40:45 <ray> i assume regular calculus has something to do with regular grammars
20:40:45 <pjb3> so if fromJust is considered bad form, how do you normally work with a Maybe value returned from a function?
20:41:05 <Petrosian> > (+) <$> Just 1 <*> Just 2
20:41:07 <lambdabot>   Just 3
20:41:24 <mike-burns> pjb3: The Maybe monad, typically.
20:41:25 <Berengal> pjb3: case maybeFunction foo of Nothing -> default; Just bar -> bar
20:41:27 <performance> ahha apply to the rescue
20:41:29 <ray> typically, case
20:41:31 <jdrake> pjb3: The whole point of Maybe, is that it might fail...
20:41:34 <ray> or pattern matching
20:41:35 <Petrosian> pjb3: Maybe if you can paste the context, we can give you better advice
20:41:41 <ray> fromJust isn't just bad form :P
20:41:55 <Berengal> @type maybe
20:41:57 <ray> if you're sure that you can't have a Nothing, why are you using Maybe a in the first place?
20:41:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:42:04 <monochrom> "Maybe if you can paste the context" <-- pun! :)
20:42:04 <beutdeuce> > :t tails
20:42:06 <lambdabot>   <no location info>: parse error on input `:'
20:42:07 <pjb3> Berengal: I think that's what was looking for
20:42:13 <beutdeuce> @type tails
20:42:15 <jdrake> :t (>>=)
20:42:15 <lambdabot> forall a. [a] -> [[a]]
20:42:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:42:44 <jdrake> :t (<-)
20:42:46 <lambdabot> parse error on input `<-'
20:43:08 <pjb3> So here's a noob question that's sure to piss everyone off :)
20:43:13 <ray> :t maybe mempty
20:43:15 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> Maybe a1 -> a
20:43:20 <mike-burns> We like noob questions, in general.
20:43:25 <copumpkin> pjb3: we don't get pissed off :)
20:43:25 <pjb3> Isn't returning a Maybe from a function like a Checked Exception in Java?
20:43:30 <jdrake> pjb3: Haskell has the most friendly developer community in existance.
20:43:31 <copumpkin> some of us get pissed on though
20:43:47 <jdrake> What is a checked exception
20:43:50 <ray> you may have to explain what a checked exception is
20:43:56 <copumpkin> pjb3: it's more like returning an object from a function, acknowledging the object could be null
20:44:06 <monochrom> "like" is very flexible. Yes.
20:44:22 <jdrake> :t return
20:44:24 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:44:26 <ray> it's like a container of radioactive waste
20:44:29 <pjb3> A checked exception in Java is an exception that you have to deal with
20:44:36 <pjb3> so if a method is
20:44:43 <ray> i don't think it's like an exception at all
20:44:44 <pjb3> has a signature like this
20:44:59 <mike-burns> I can see the similarities. But try to think of this as something else.
20:45:00 <copumpkin> in the sense that it forces you to deal with it, I guess it is
20:45:00 <Twey> You don't have to deal with a Maybe
20:45:03 <ray> it may take over some things that you do with exceptions
20:45:11 <Twey> It's just usually stupid not to :-P
20:45:18 <pjb3> String getData() throws IOException
20:45:24 <copumpkin> you do have to deal with it, it's just that fromJust is a cheap way of dealing with it
20:45:46 <Twey> There are unsafe things like fromJust or non-exhaustive pattern matching to just assume it's filled
20:45:52 <monochrom> A PhD thesis attacks exceptions and says you should use Maybe. So I answered yes. "like" means they solve the same problem. doesn't mean same solution, of course.
20:46:13 <jdrake> Aren't exceptions supposed to be *exceptional* not regular course of the day stuff?
20:46:27 <pjb3> That means if you call getData, you either have to explictly do it in a try/catch block or put throws IOException in the signature of your method
20:46:28 <mike-burns> jdrake: You still should handle them.
20:46:44 <Twey> jdrake: Semantically
20:46:49 <Petrosian> There's Control.Exception, whether or not that's what he's after on the otherhand..
20:46:55 <Twey> That's how they're usually used in Haskell
20:46:57 <beutdeuce> shouldnt tails be 'tails [] = [] ; tails (x:xs) = (x:xs) : tails xs', so the last element wouldnt be an empty [], rather the last element of the original list?
20:46:57 <jdrake> I am coming from Objective C and C
20:47:21 <Petrosian> @ty throw
20:47:23 <lambdabot> Not in scope: `throw'
20:47:24 <Twey> Maybe is used for something that is expected to fail sometimes, and exceptions are used for things that, all things as they should be, will never fail
20:47:31 <Petrosian> @ty Control.Exception.throw
20:47:32 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
20:47:45 <Twey> Weird that throw isn't in scope
20:47:47 <Twey> Why is that?
20:49:12 <monochrom> > tail [a]
20:49:13 <jdrake> I have something like data Gene = Number Int, Plus, Minus, etc.  is it possible to make Plus and Minus be grouped in such a way that I can group some of those as Operators but still have them distinct types in themselves?
20:49:14 <lambdabot>   []
20:49:46 <monochrom> I like [] as the tail of [a]. Therefore I like [ ... , [] ] as the answer of, say, tails [c,b,a].
20:51:39 <Petrosian> I guess they don't want people using LB to throw exceptions
20:51:52 <monochrom> Not sure if this helps. data Gene = Number Int | OperatorCase Operator; data Operator = Plus | Minus.
20:51:54 <Petrosian> > Control.Exception.throw (ExitFailure 1)
20:51:55 <lambdabot>   Not in scope: `Control.Exception.throw'Not in scope: data constructor `Exit...
20:52:19 <jdrake> monochrom: I think it might
20:52:26 <Petrosian> @ty Control.Exception.throw (System.Exit.ExitFailure 1)
20:52:28 <lambdabot> forall a. a
20:54:37 <iammisc> what does thread blocked indefinitely mean?
20:54:46 <Zao> It's blocked forever.
20:54:56 <copumpkin> ceiling cat thinks ur stuck
20:55:01 <Zao> Waiting on something that never will occur.
20:55:12 <beutdeuce> can Haskell create an nxn list?
20:55:17 <copumpkin> nxn list?
20:55:20 <beutdeuce> NxN
20:55:22 <beutdeuce> 20x20
20:55:24 <Zao> Lists are single-linked one-dimensional.
20:55:30 <Zao> It does have assorted Arrays.
20:55:36 <copumpkin> > replicate 20 (replicate 20 ())
20:55:37 <lambdabot>   [[(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()],[(),(),(),()...
20:55:38 <copumpkin> :P
20:55:38 <Zao> Which have arbitrary Ix types.
20:55:38 <beutdeuce> can Haskell have a 20x20 data structure?
20:55:45 <Zao> See "Array"
20:55:53 <beutdeuce> @type Array
20:55:54 <lambdabot> Not in scope: data constructor `Array'
20:56:00 <Zao> http://www.haskell.org/tutorial/arrays.html
20:56:05 <beutdeuce> k thanks
20:56:33 <Zao> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays
20:59:23 <jdrake> Does anyone know of a thing for vim to assist with Haskell formatting, such as wrapping to = when doing a list of data types
20:59:49 <Zao> I assume you're using http://projects.haskell.org/haskellmode-vim/ ?
21:00:10 <jdrake> I am not using anything
21:00:15 <jdrake> I am trying to learn vim :p
21:00:18 <Zao> Ah. Take a look at that then.
21:00:40 <jdrake> EEEEEEKKKKK, a vba extension scares me, remembering of visual basic for applications
21:01:04 <Zao> A sane reaction.
21:01:53 <jdrake> I once was trying to use vba to create a set of labels (16*6) with a resistor colour code on them, it drove me nuts and it was easier to just make the bloody thing from scratch :p
21:05:55 <kniu> hey guys
21:06:10 <kniu> how do I disable URL info for lambdabot?
21:06:34 <dancor> kniu: i locally edited my lambdabot that we run at work
21:07:12 <kniu> surely you can write something in a config file?
21:07:22 <dancor> it wasn't fine-grained enough for me
21:07:27 <dancor> but i remember some option
21:09:14 <kniu> oh?
21:09:58 <dancor> @url-off
21:09:59 <lambdabot> Unknown command, try @list
21:11:49 <dancor> url-off works in local lambdabot
21:12:06 <dancor> it disables everything in Plugin/Url.hs
21:12:32 <dancor> my mod added an ignoreUrlRegexes option to config
21:13:20 <SamB> dancor: well, this one doesn't appear to allow it at all
21:13:31 <SamB> URL processing, I mean
21:13:36 <dancor> SamB: this one what
21:13:54 <SamB> lambdabot
21:14:03 <dancor> @bot
21:14:04 <lunabot>  :)
21:14:04 <lambdabot> :)
21:14:10 <dancor> http://www.google.com
21:14:20 <dancor> @url-on
21:14:21 <lambdabot> Unknown command, try @list
21:14:22 <dancor> http://www.google.com
21:14:26 <dancor> idk
21:14:53 <SamB> I expect it was disabled in a quite harsh manner
21:14:57 <SamB> @help url
21:14:58 <lambdabot> url <key>. Return element associated with key
21:15:08 <dancor> i think an admin has run url-off
21:15:44 <SamB> I think Cale may have edited something in the source tree ;-)
21:19:50 <dancor> what is the status of opensource speech recognition
21:20:15 * ivanm has no idea
21:20:19 <dancor> i tried to get sphinx to work a while back
21:20:36 <SamB> dancor: we've gotten it to the point where it gets bored during long speeches
21:20:44 <SamB> it doesn't have a clue what they're about, though
21:21:02 <dancor> @vixen Are you bored?
21:21:03 <lambdabot> yup, i'm always a little bored. except when i'm having fun
21:23:24 <ivanm> @vixen are you having fun yet?
21:23:24 <lambdabot> you're fun too
21:23:24 <ivanm> :p
21:25:49 <davidL> @. vixen quote
21:25:50 <lambdabot> you got, huh?
21:33:54 <ivanm> @. . elite vixen quote
21:33:55 <lambdabot> Plugin `compose' failed with: Unknown command: "\\/IXeN"
21:34:08 <ivanm> how do you do multiple quote compositions?
21:34:14 <ivanm> @. (. elite vixen) quote
21:34:14 <lambdabot> Plugin `compose' failed with: Unknown command: "(."
21:34:19 <ivanm> @. (elite . vixen) quote
21:34:20 <lambdabot> Plugin `compose' failed with: Unknown command: "(elite"
21:34:33 <ivanm> s/quote/plugin/
21:34:35 <Saizan> @. elite . vixen quote
21:34:36 <lambdabot> Of C0Ur5E i cAn
21:34:46 <ivanm> ahhhh
21:34:53 <ivanm> @. elite . vixen yow
21:34:54 <lambdabot> |eT'$ Don't t4LK 48Out 7hat
21:35:15 <Saizan> ?type (.) ?elite (.) ?vixen ?quote
21:35:17 <lambdabot> forall b c a t t1. (?quote::t, ?vixen::b -> c, ?elite::((a -> b) -> a -> c) -> t -> t1) => t1
21:38:12 * SamB had no idea you could get free usenet access just by going over ipv6...
21:38:35 * ivanm had no idea anyone would still want usenet access
21:39:05 <SamB> ivanm: why do you think they still sell it?
21:39:29 <ivanm> true
21:39:31 <mike-burns> How do you get free usenet via IPv6?
21:39:40 <ivanm> nostalgia? :p
21:39:53 <SamB> https://www.sixxs.net/misc/coolstuff/
21:40:04 <SamB> ivanm: I was thinking people used it to get porn
21:40:06 <ivanm> mike-burns: they fall over backwards, astounded that you actually have a cool piece of technology and the arcane knowledge required to use it
21:40:19 <ivanm> SamB: porn and other stuff torrents are now used for...
21:41:17 <SamB> ivanm: I think they use everything for porn
21:41:43 <ivanm> heh
21:46:14 <ivanm> does anyone know of a way I can un-escape a String containing explicit escapes?
21:46:37 <Cale> There's the cheap way: put quotes around it and use read
21:46:42 <ivanm> e.g. so that (show . unescape) == id
21:46:46 <dancor> ivanm: like \n and \t?  you can do that with simple recursion
21:46:53 <Cale> oh, then just read
21:47:01 <ivanm> Cale: hmmmm...
21:47:19 <ivanm> seems to work, thanks
21:47:41 <ivanm> dancor: I meant that I have a String, which might have actual quotes and escaped quotes in it
21:47:44 <Cale> > read "\"hello\\tworld\"" :: String
21:47:45 <lambdabot>   "hello\tworld"
21:47:52 <ivanm> Cale: yeah, something like that
21:48:16 <Cale> The quotes are required for read.
21:48:21 <Cale> > read "hello" :: String
21:48:23 <lambdabot>   "* Exception: Prelude.read: no parse
21:48:42 <davidL> w 25
21:48:50 <ivanm> yeah, I know that I'll be parsing it with quotes
22:24:08 <blackh> Hey Haskellers - Is there a clever way of making Data.IntMap work with newtypes of Int?
22:24:16 <ivanm> yes.... don't ;-)
22:24:19 <meanburrito920_> is anyone in here familiar with an UnboundVar monad? It appears in "Write yourself a scheme" and is causing strange problems but I cant seem to find any documentation on it
22:24:19 <Twey> No
22:24:21 <Twey> Haha
22:25:07 <Twey> meanburrito920_: I don't think that's a monad
22:25:31 <meanburrito920_> Twey: in that case, what is it?
22:25:36 <Twey> It's one of the constructors of LispError
22:25:40 <Twey> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Error_Checking_and_Exceptions
22:25:48 <Twey> UnboundVar String String
22:26:02 <meanburrito920_> Twey: oops. lemme check, i probably forgot to create the constructor :/
22:26:38 <meanburrito920_> indeed that was the issue :)
22:26:39 <meanburrito920_> thanks
22:26:54 <Twey> Welcome :)
22:28:25 <meanburrito920_> actually, wait. its saying the constructor for UnboundVar isn't in scope, when I can see that it is.
22:28:51 <blackh> It doesn't look like anyone has done it (a type-safety wrapper for Data.IntMap that works with any newtype of Int). How strange. I'll just have to write it myself.
22:29:34 <meanburrito920_> oh nevermind, it was just an old error message
22:30:00 <jeffwheeler> Wow, how did I miss GHC 6.10.4. Clearly putting haskell mailing lists in a separate folder isn't working.
22:33:17 <ivanm> jeffwheeler: I only know about it because of reddit... >_>
22:34:26 <Woof> I only know about it because of jeffwheeler
22:35:50 <jeffwheeler> I think I may have installed GHC the first time in 32-bit without realizing it.
22:47:14 <jeffwheeler> Uh oh. /usr/local/lib/ghc-6.10.4/ghc: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory
22:47:22 <jeffwheeler> (First time trying GHC 6.10.4.)
22:47:42 <Zao> jeffwheeler: You need libtinfo (duh). It's part of ncurses I believe.
22:48:02 <jeffwheeler> Zao: it seemed much scarier before you said that. ;_
22:48:05 <jeffwheeler> Err, ;)
22:48:08 * ivanm doesn't have it...
22:48:14 <ivanm> is it a new dep for 6.10.4 ?
22:48:40 <mike-burns> There's a coversation way in the scrollback about this. If you downloaded a binary then you downloaded the wrong one.
22:48:53 <jeffwheeler> I downloaded the source.
22:48:57 <mike-burns> I got nothin'.
22:49:55 <jeffwheeler> Wait . . . ignore me.
22:50:00 * jeffwheeler goes to hide for a bit
22:53:36 <jeffwheeler> Doh, crap. Now that I am trying to install the correct version, it tries to use the ghc that is my path, the broken one.
22:54:22 <ivanm> why does ghc need ncurses?
22:54:50 <jeffwheeler> I think it only does for the extralibs.
22:54:55 <ivanm> ahhhh
22:55:00 <ivanm> which extralib needs it?
22:55:03 <jeffwheeler> No idea
22:55:21 <jeffwheeler> . . . but now my machine is pissed at me
22:55:32 <ivanm> heh
22:55:33 <mike-burns> You can pass like --target-ghc or something.
22:55:38 <mike-burns> If you still have the old one.
22:57:56 <jeffwheeler> Oh, I do. Yay. But --target-ghc isn't known by ./configure.
22:58:16 <jeffwheeler> Oh, it's --with-ghc.
22:58:28 <jeffwheeler> And that works; thank you.
23:03:56 <uman> hello, I've installed the "parsec" package from hackage
23:04:04 <uman> but when I try to install other packages it claims I haven't installed parsec
23:04:16 <uman> (I'm doing this in order to install xmobar)
23:05:03 <blackh> uman: What are the versions? (parsec has two major versions.)
23:05:06 <jeffwheeler> uman: You might be installing the wrong version; try installing 3 if you're on 2
23:05:15 <uman> I've installed 3
23:05:32 <jeffwheeler> uman: then try cabal install parsec < 3
23:05:37 <jeffwheeler> Or, something like that . . .
23:05:52 <uman> jeffwheeler: eh, I'm trying to install cabal-install actually
23:05:56 <uman> jeffwheeler: it depends on parsec :(
23:06:06 <jeffwheeler> I see . . .
23:06:44 <jeffwheeler> uman: I suppose you can download the tarball from hackage and do runhaskell Setup install in there
23:06:58 <uman> okay... I should get parsec 2 for sure though?
23:07:31 * sjanssen hates the naming style used in the probability package on hackage
23:07:43 <jeffwheeler> uman: what is the error, specifically?
23:07:46 <sjanssen> Numeric.Probability.Simulation.C, seriously?
23:08:18 <ivanm> sjanssen: well, if that's what it uses then it is seriously...
23:10:11 <sjanssen> Henning Thielemann really likes to promote these lame style choices :(
23:10:28 <Cale> sjanssen: We need someone who follows Henning around and cleans up his notational messes.
23:10:47 <Cale> He produces so much good code and then sabotages it.
23:11:00 <uman> ah, installing parsec 2 seemed to work
23:11:04 <uman> now I need to install "network"
23:11:05 <uman> ugh
23:11:24 <uman> I think I will reformat and install debian soon... "apt-get" is a lot nicer than compiling everything from source
23:11:25 <sjanssen> Cale: I imagine this would offend him
23:11:30 <Cale> Probably.
23:13:32 <sjanssen> and ProbabilityMonads from hackage doesn't build
23:19:09 <quicksilver> lilac: Ouch. Hackage has two pacakges called 'Numbers' and 'numbers'.
23:19:25 <quicksilver> dcoutts: that doesn't seem good. Hackage has packages with names which differ only in capitalisation
23:24:32 <Zao> "who would ever run a case ignorant platform?"
23:25:07 <quicksilver> quite apart from the problems with case ignorant platforms
23:25:14 <quicksilver> I just think it is confusing for human beings.
23:31:44 <ivanm> @seen dcoutts
23:31:45 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow, #haskell-soc and #haskell-iphone. I last heard dcoutts speak 2d 9h 50m 24s ago.
23:31:55 <ivanm> quicksilver: why are you suddenly talking to dcoutts when he hasn't been here for 2 days?
23:34:44 <wmealing_> paged up
23:34:50 <tommd1> @seen dcoutts_
23:34:51 <lambdabot> I saw dcoutts_ leaving #haskell-overflow, #gentoo-haskell and #ghc 2d 12h 55m 41s ago, and .
23:34:56 <tommd1> Humm, ok then.
23:43:39 <jeffwheeler> @type sequence
23:43:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:44:26 <jeffwheeler> @type seq
23:44:27 <lambdabot> forall a t. a -> t -> t
23:44:49 <jeffwheeler> > undefined `seq` 1
23:44:50 <lambdabot>   * Exception: Prelude.undefined
23:44:56 <jeffwheeler> > 2 `seq` 1
23:44:57 <lambdabot>   1
23:45:05 <jeffwheeler> @src seq
23:45:05 <lambdabot> Source not found. Just try something else.
23:45:15 <Cale> seq is a primitive
23:45:29 <jeffwheeler> It just evaluates the first argument and evaluates to the second argument?
23:45:30 <Cale> But for many specific types it could be implemented using case
23:45:36 <Cale> right
23:45:52 <jeffwheeler> @src sequence
23:45:53 <Cale> It evaluates the first argument into weak head-normal form
23:45:53 <lambdabot> sequence []     = return []
23:45:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:45:53 <lambdabot> --OR
23:45:53 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:46:01 <jeffwheeler> Are those two even related?
23:46:05 <Cale> sequence is completely unrelated to seq
23:46:09 <jeffwheeler> Oh
23:46:31 <jeffwheeler> @type $!
23:46:32 <lambdabot> parse error on input `$!'
23:46:36 <jeffwheeler> @type ($!)
23:46:37 <lambdabot> forall a b. (a -> b) -> a -> b
23:47:29 <jeffwheeler> @type iterate
23:47:30 <lambdabot> forall a. (a -> a) -> a -> [a]
23:47:47 <jeffwheeler> > iterate ((+5) $!) 1
23:47:48 <lambdabot>   [1,6,11,16,21,26,31,36,41,46,51,56,61,66,71,76,81,86,91,96,101,106,111,116,...
23:48:23 <Cale> That doesn't really help, since (+5) is already a strict function
23:48:28 <jeffwheeler> Yeah . . .
23:48:37 <jeffwheeler> I'm trying to think of an example where it would do something.
23:48:53 <jeffwheeler> I'm thinking there should be a way to timeout on processing an infinite list.
23:49:07 <Cale> Not without IO of course.
23:49:16 <jeffwheeler> > map (+5) $! [1..]
23:49:17 <lambdabot>   [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,...
23:49:21 <jeffwheeler> Oh?
23:49:29 <jeffwheeler> (I figured that example wouldn't work . . .)
23:49:44 <Cale> [1..] evaluates into weak head normal form in one step
23:49:52 <Cale> It reduces to 1 : [2..]
23:50:09 <Cale> Which is a constructor, so you're done.
23:50:32 <jeffwheeler> Oh, so the strict evaluation would still just stop immediately.
23:50:36 <jeffwheeler> Hmm . . .
23:52:04 <jeffwheeler> > let iterate' f x = x : (iterate' f $! f x) in iterate' (+5) 1
23:52:06 <lambdabot>   [1,6,11,16,21,26,31,36,41,46,51,56,61,66,71,76,81,86,91,96,101,106,111,116,...
23:52:27 <jeffwheeler> (The definition is from -cafe)
23:52:56 <jeffwheeler> > last $! [1..]
23:53:02 <lambdabot>   mueval-core: Prelude.read: no parse
23:53:02 <lambdabot>  mueval: ExitFailure 1
23:53:10 <Cale> right, it does some good there
23:53:21 <jeffwheeler> > last [1..]
23:53:26 <lambdabot>   mueval-core: Prelude.read: no parse
23:53:27 <lambdabot>  mueval: ExitFailure 1
23:53:38 <Cale> Basically, it ensures that if you get the millionth element of the list without computing the others, you won't get a stack overflow.
23:54:08 <Cale> Because normally, that element would start out looking like f (f (f (f (f ... (f x) ...))))
23:54:09 <jeffwheeler> Hmm? Because it throws away the others as it goes?
23:54:14 <jeffwheeler> I see.
23:54:25 <Cale> But it forces the evaluation to occur as you walk down the list.
23:54:31 <Cale> (as !! walks down the list)
23:54:33 <jeffwheeler> Why can't lambdabot parse it? There's no special syntax on the latter one . . .
23:54:53 <Cale> oh, that error is bad, it just means that the computation timed out
23:55:02 <Cale> Obviously, [1..] has no last element
23:55:03 <jeffwheeler> Oh. That _is_ a bad error. :P
23:56:31 <jeffwheeler> > last $! [1..100000]
23:56:32 <lambdabot>   100000
23:56:37 <jeffwheeler> > last [1..100000]
23:56:38 <lambdabot>   100000
23:56:45 <Cale> last is also a strict function
23:56:46 <jeffwheeler> > last [1..10000000]
23:56:48 <lambdabot>   10000000
23:56:53 <jeffwheeler> Oh, so it doesn't matter anyways?
23:56:55 <Cale> It immediately pattern matches the list it's given.
23:57:01 <Cale> @src last
23:57:01 <lambdabot> last [x]    = x
23:57:01 <lambdabot> last (_:xs) = last xs
23:57:01 <lambdabot> last []     = undefined
23:57:14 <Cale> In order to tell if the list matches [x], you have to evaluate it.
23:57:35 <Cale> (at least as far as the tail of the first cons)
23:58:04 <jeffwheeler> Oh, so I'm foiled again.
23:58:05 <Cale> But let's look at the normal iterate function
23:58:16 <Cale> iterate f x = x : iterate f (f x)
23:58:26 <Cale> iterate is not strict in either of its parameters
23:58:42 <jeffwheeler> Because it doesn't pattern-match either of them.
23:58:46 <Cale> right
23:59:02 <Cale> It does not need to inspect either f or x to produce a result, which will always be a cons, applied to two expressions: x and iterate f (f x)
23:59:12 <jeffwheeler> So both are left unevaluated . . .
23:59:15 <Cale> right
23:59:17 <jeffwheeler> that makes sense.
23:59:31 <Cale> now let's focus on the tail of the iterate
23:59:35 <Cale> iterate f (f x)
23:59:51 <Cale> --> f x : iterate f (f (f x))
23:59:54 <Cale> still no evaluation
