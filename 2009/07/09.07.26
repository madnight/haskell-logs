00:00:35 <d4> still Ambiguous type variable, but with Possible cause: the monomorphism restriction
00:00:39 <Gracenotes> it might be troublesome for functions that return a typeclassy type.. it certainly could be done, but at some level the bloat might get excessive
00:00:47 <Cale> aha, yeah, turn the MR off by adding the line
00:00:58 <Cale> {-# LANGUAGE NoMonomorphismRestriction #-}
00:01:21 <d4> OK, compiled
00:01:24 <Cale> The MR requires pattern-bound variables to be monomorphic -- so it would have to resolve the t
00:01:44 <Cale> (well, not-typeclass-polymorphic)
00:02:07 <d4> typeclasses seem tricky
00:02:28 <Cale> d4: Well, there are some sort of tricky corner cases
00:02:45 <Cale> d4: But it shouldn't be *too* hard to see why you really need to know the type t here.
00:02:58 <d4> :(
00:03:00 <Cale> (in the case where we had  contains :: (Eq t) => [t] -> [t] -> Bool
00:03:02 <Cale> )
00:03:20 <Cale> The reason is that there's no more chance after that point to decide which implementation of (==) to use
00:03:47 <Cale> It doesn't matter whether contains actually makes use of (==) or (/=), what matters is that the type says that it's allowed to
00:04:03 <d4> mmm
00:04:17 <d4> laziness
00:04:40 <d4> err... maybe that's not relevant
00:04:45 <Cale> Nothing to do with laziness really
00:05:00 <d4> type checking isn't lazy
00:05:01 <d4> ;)
00:05:37 <Cale> The type of contains says "I'm allowed to depend on the implementation of Eq for t, and might do something different based on what that instance is.
00:06:15 <Cale> But when you apply contains to two parameters for which t is still unknown and unresolved, t no longer appears in the type of the result
00:06:16 <dolio> Gracenotes: foo :: (Show a) => Int -> a -> String ; foo 0 a = show a ; foo (n+1) a = foo n (a,a) ; main = getArgs >>= \(i:_) -> putStrLn (foo (read i) ())
00:06:40 <Cale> So the compiler has no information about what instance of Eq is desired, and complains
00:07:00 <d4> Cale: I think I see...
00:07:02 <dolio> Gracenotes: That uses dictionaries based on runtime input.
00:07:27 <d4> but it's still a bit abstruse to me
00:08:01 <d4> so the best thing to do is just give a type instance to one of the empty lists
00:08:06 <Gracenotes> cute function
00:08:46 <Cale> d4: Well, it's made harder to explain by the fact that you didn't actually make use of (==)
00:08:51 <d4> that way the type checker can rest assured there will be a typeclass dictionary for the interpreter to use at evaluation time (even though it will turn out not to use it)
00:08:54 <Cale> d4: and that's not the inferred type of contains
00:09:18 <d4> Cale: well I get the same error if I use ==, naturally
00:09:25 <Cale> d4: naturally
00:09:37 <Cale> d4: But then we can say why it is that it's failing a little more easily
00:09:40 <d4> I was just shortening up the code for pasting
00:09:59 <Cale> d4: Because what code is it actually going to use to implement (==) in that case?
00:10:05 <copumpkin> > let (∨) = (+) in 5 ∨ 7
00:10:07 <lambdabot>   12
00:10:25 <Cale> The code for (==) is defined by each of the instances of Eq differently
00:10:28 <d4> Cale: but it always has an instance except when given the empty lists
00:10:38 <Cale> That is, it might produce different results depending on which instance is selected
00:10:46 <d4> Cale: and when given empty lists, it never uses (==)
00:10:52 <Cale> d4: The problem isn't really that the lists are empty
00:10:52 <d4> that's the irony
00:11:02 <Cale> d4: It's that the lists' types are undetermined
00:11:10 <d4> it's that the empty lists... yes, what you said
00:11:17 <Cale> If you used   contains ([] :: [Integer]) []
00:11:21 <Cale> then it would be fine :)
00:11:33 <d4> Cale: yes, but it's tacky-ish
00:11:47 <d4> here I have an empty list---of Integers, say
00:11:51 <d4> heh
00:12:12 <Cale> d4: Well, otherwise, how is it going to know which implementation of (==) to use?
00:12:17 <d4> but it allows the code to compile, so I've done it
00:12:22 <d4> just wanted to understand better
00:12:52 <d4> Cale: I know, the type checker can't tell the interpreter won't need (==)
00:13:11 <d4> but still ... it won't ... I promise :P
00:13:27 <Cale> d4: Well, yeah, I suppose there's the issue that the instance of Eq for [a] doesn't use the (==) for a in the case that the lists are empty
00:13:55 <d4> I'm not surprised ;)
00:13:58 <Cale> So it doesn't *really* depend on the instance of Eq for a in that case
00:14:10 <Cale> But the type still *says* that it does.
00:14:21 <d4> Cale: yeah... it's kind of a special case
00:14:27 <d4> but an annoying one, to me
00:14:45 <d4> nullary tycons probably deserve some special rules
00:14:55 <Cale> Just like how if you have a function that has a parameter, and you know that given the other parameters you've passed, the function won't happen to use it, doesn't absolve you of passing that parameter.
00:15:41 <d4> Cale: but nothing is claiming to be doing "inference" there ;)
00:15:55 <copumpkin> Cale: what's the Natural package you use in lambdabot?
00:16:23 <sjanssen> d4: by the way, your example probably works if you turn on -fextended-defaulting
00:16:24 <Cale> copumpkin: That *I* use?
00:16:44 <Cale> copumpkin: Oh, is there a Natural package imported?
00:16:44 <copumpkin> Cale: I didn't see it in my installation of lambdabot from darcs, so I assumed you'd added it
00:16:50 <sjanssen> copumpkin: 'numbers'
00:17:00 <copumpkin> > genericLength [(1 :: Natural)..] > 5
00:17:01 <Cale> yeah, there's a numbers package
00:17:02 <lambdabot>   * Exception: stack overflow
00:17:02 <copumpkin> sjanssen: thanks
00:17:02 <sjanssen> oh, Natural?  Dunno about that one
00:17:08 <copumpkin> hrm
00:17:15 <copumpkin> could've sworn that worked last time :P
00:17:47 <d4> sjanssen: -fextended-defaulting is a cmdline switch?
00:18:05 <Cale> d4: yeah
00:18:29 <d4> hmm
00:18:34 <d4> ghc: unrecognised flags: -fextended-defaulting
00:18:41 <Cale> you could also {-# LANGUAGE ExtendedDefaultRules #-}
00:18:45 <copumpkin> oh yeh, hackage has Numbers and numbers
00:18:58 <Cale> (and that is the right name, I checked that one ;)
00:19:04 <d4> that does it
00:19:06 <d4> :P
00:19:14 <d4> so eh
00:19:26 <d4> I'm not sure whether to ask how that changes the behavior of the type checker ...
00:19:51 <d4> but I *would* read about it given the opportunity
00:20:16 <d4> oh... I guess it
00:20:21 <d4> picks an instance for me
00:20:28 <d4> I wonder which one
00:20:46 <d4> but I don't need to know, which is perfect
00:21:45 <Cale> d4: () usually
00:21:53 <mmorrow> , typeOf []
00:21:55 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
00:22:08 <mmorrow> , [] == []
00:22:10 <lunabot>  True
00:22:22 <Cale> mmorrow: that's... kind of funny :)
00:22:25 <d4> Cale: ah, figures
00:22:35 <mmorrow> i'm trying to think of a sentence that describes what's happening
00:22:44 <d4> () seems to be the don't-care of first resort
00:23:17 <ivanm> mmorrow: why, what's happening? :p
00:23:37 <mmorrow> ivanm: err, s/what's happening/why "typeOf []" doesn't work, but "[] == []" does/
00:23:49 <ivanm> heh
00:23:59 <ivanm> where's typeOf from? TH?
00:24:06 <mmorrow> , 'typeOf
00:24:08 <lunabot>  Data.Typeable.typeOf
00:24:30 <mmorrow> , src ''Typeable
00:24:34 <lunabot>  class Typeable a where
00:24:34 <lunabot>          typeOf :: a -> TypeRep
00:24:52 <mmorrow> , src ''TypeRep
00:24:55 <lunabot>  data TypeRep = TypeRep !Key TyCon ([TypeRep])
00:26:08 <Cale> mmorrow: Do the extended default rules mention the Prelude typeclasses?
00:26:09 <ivanm> ahhh
00:26:10 * mmorrow can't think of why "typeOf []" doesn't work and "[] == []" does, although it kind of "makes sense"
00:26:15 <mmorrow> Cale: ooh, maybe
00:26:28 <ivanm> , typeOf id
00:26:30 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
00:26:37 <kyagrd> typeOf does not work on polymorphic types
00:26:38 <ivanm> mmorrow: maybe typeOf doesn't like polymorphism?
00:26:44 <mmorrow> ivanm: Typeable doesn't do polymorphism :(
00:26:51 <mmorrow> ahh
00:26:54 <ivanm> mmorrow: yeah, looks like it :(
00:26:55 <mmorrow> i think that may be it
00:26:55 <kyagrd> There was a discussion on this in haskell mailing list
00:27:27 <mmorrow> (the fact that a polymorphic `a' in [a] isn't allowed with Typeable, but it is for Eq
00:28:02 <mmorrow> , sizeOf []
00:28:03 <lunabot>  luna: Not in scope: `sizeOf'
00:28:37 <mmorrow> that one is ok with polymorphism actually
00:28:44 <ivanm> , typeOf [] :: [Int]
00:28:45 <lunabot>  luna: Couldn't match expected type `[GHC.Types.Int]'
00:28:46 <Cale> mmorrow: It's not really okay for Eq either though
00:28:47 <ivanm> heh
00:28:49 <mmorrow> hmm, so i guess Typeable is the special case here then
00:28:52 <Cale> mmorrow: It's just defaulted to ()
00:29:00 <mmorrow> Cale: ah
00:29:17 <mmorrow> Cale: how do you go about getting Typeable to default to ()?
00:29:29 <mmorrow> a "default ()" decl in the module or something?
00:29:42 * mmorrow has never actually used a "default" declaration before
00:29:52 <kyagrd> Oleg and Lennart's discussion http://www.mail-archive.com/haskell-cafe@haskell.org/msg56901.html
00:30:26 <mmorrow> , typ "\\x -> x"
00:30:29 <lunabot>  "forall t_aa0k. t_aa0k -> t_aa0k"
00:30:38 <mmorrow> , [$tyQ| \x -> x|]
00:30:41 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (VarT a))
00:30:52 <copumpkin> wow, this is getting pretty huge (and useless, but I'm learning me some algebra along the way at least): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7528#a7528
00:30:54 <dolio> , [$ty| either Right Left |]
00:30:57 <lunabot>  forall a a . Either a a -> Either a a
00:30:59 <mmorrow> dolio: hehe
00:31:10 <mmorrow> dolio: i still haven't reported that yet..
00:31:16 <kyagrd> Oleg's code on the mailing list has has some bugs though, when I tried. The bug is discuussed here at the end of the paper http://kyagrd.dyndns.org/wiki/SparseBitmapsForPatternMatchCoverage
00:31:32 <mmorrow> kyagrd: ooh, that sparse bitmaps paper is really neat
00:31:56 <kyagrd> mmorrow: thanks
00:32:11 <mmorrow> kyagrd: (i take it you're the author :)
00:35:44 <Axman6> :t either Right Right
00:35:46 <lambdabot> forall a a1. Either a a -> Either a1 a
00:35:49 <mmorrow> hmm, but i still don't understand something here with Typeable. so is the fact that "typeOf []" says "ambiguous `a' .." on account of (lack of) defaulting for Typeable?
00:35:53 <Axman6> :t either
00:35:54 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:36:06 <mmorrow> , typ "either Right Left"
00:36:08 <lunabot>  "forall a a. Data.Either.Either a a -> Data.Either.Either a a"
00:36:27 * mmorrow has no idea why ghc-api says that
00:36:53 <mmorrow> i thought that (the function that "typ" uses) was the same function used by ghci..
00:37:00 <mmorrow> apparently not
00:39:40 <mmorrow> , typ "either Left Right"
00:39:43 <lunabot>  "forall a b. Data.Either.Either a b -> Data.Either.Either a b"
00:39:45 <ray> copumpkin: nice failgebras
00:39:53 <copumpkin> ray: thanks :P
00:39:57 <copumpkin> I'm good at failing
00:40:05 <mmorrow> , typ "let f = either Right Left in f . f"
00:40:08 <lunabot>  "forall a a. Data.Either.Either a a -> Data.Either.Either a a"
00:40:12 <dolio> , typ either Right
00:40:14 <lunabot>  luna: Couldn't match expected type `GHC.Base.String'
00:40:27 <dolio> , typ "either Right"
00:40:30 <lunabot>  "forall a a b.\n(b -> Data.Either.Either a a)\n-> Data.Either.Either a b\...
00:40:33 <mmorrow> , [$ty| (ty,tyQ) |]
00:40:36 <lunabot>  (QuasiQuoter, QuasiQuoter)
00:40:36 <mmorrow> err
00:40:50 <mmorrow> , [$ty| ([$ty|42|],[$tyQ|42|]) |]
00:40:52 <lunabot>  luna: parse error on input `|]'
00:40:56 <mmorrow> , [$ty| ([$ty|42\|],[$tyQ|42\|]) |]
00:40:59 <lunabot>  (Doc, Type)
00:41:10 <ray> copumpkin: needs more euclidean domains and fields
00:41:23 <Cale> copumpkin: Just for purposes of humour, you should add a separate failX :: String -> t function to each of those typeclasses
00:41:36 <mmorrow> dolio: :o
00:41:48 <Cale> Because maybe you're writing some Group operations and you need to fail?
00:41:50 <Cale> ;)
00:42:05 <copumpkin> ray: I'm adding more instances right now but I'm reluctant to add any really useful ones (i.e., only the ones I can be exact on like Integer, Natural, CReal, Bool)
00:42:21 <copumpkin> Cale: hah, maybe I will :P
00:42:33 <mmorrow> , [$ty| \f -> either Right f |]
00:42:36 <lunabot>  forall a b b . (a -> Either b b) -> Either b a -> Either b b
00:42:47 <copumpkin> then when I finish my GHC extension for class synonyms I'll be able to get rid of some of that ugliness (although the ugly design will be harder to get rid of)
00:42:47 <mmorrow> , [$ty| either Right |]
00:42:50 <lunabot>  forall a b b . (a -> Either b b) -> Either b a -> Either b b
00:43:03 <mmorrow> , [$ty| let f = either in f Right |]
00:43:06 <lunabot>  forall a b b . (a -> Either b b) -> Either b a -> Either b b
00:43:15 <dolio> You should get around to reporting that to wherever it's relevant some time. :)
00:43:24 <mmorrow> dolio: yeah
00:44:47 <mmorrow> (hscTcExpr is what it's using)
00:44:55 <kyagrd> mmorrow: Is this $ty quasiquoter some library on Hackage?
00:45:29 <mmorrow> kyagrd: no, although i have it in a repo (along with lunabot/etc (90% cleaned up..))
00:45:39 <mmorrow> kyagrd: http://moonpatio.com/repos/lunabot/
00:45:58 <mmorrow> the "ty" QQ etc is in a not-yet-cleaned-up module though..
00:46:12 <mmorrow> http://moonpatio.com/repos/lunabot/Luna/Bot/Lib/Eval.hs
00:46:37 <mmorrow> (the Lib/ dir is the bit that's to-organize and is filled with random things)
00:47:43 <mmorrow> might as well move the ty/etc to the organize area before i forget
00:47:46 * mmorrow does that
00:49:00 <kyagrd> Oh ... is it calls ghc and get the type string and then make ghc parse that again through TH? wow
00:49:08 <mmorrow> hehe, exactly
00:49:36 <mmorrow> the tyvars are really ugly straight from ghc (in most cases)
00:50:01 <mmorrow> , typ "\\x -> x"
00:50:03 <lunabot>  "forall t_aa0k. t_aa0k -> t_aa0k"
00:50:58 <mmorrow> kyagrd: the neat thing about the eval function that lunabot uses, is that it has the module that it's defined in in scope
00:51:03 <mmorrow> so it can see itself
00:51:32 <mmorrow> and the bot's evaluator prog actually uses the same eval function to eval Strings coming in over the network as well
00:51:40 <mmorrow> , eval "eval \"42\""
00:51:40 <Daimonic> @src flip
00:51:41 <lambdabot> flip f x y = f y x
00:51:43 <lunabot>  <<Dynamic>>
00:51:58 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"") :: Integer
00:52:01 <lunabot>  42
00:53:27 <Beelsebob> wow, I really didn't expect this blog post to be successful on reddit programming
00:53:48 <Beelsebob> it's fast catching my "don't use monads for everything" post
00:56:39 <dolio> What post?
00:57:07 <Beelsebob> our rediscovery of exponentiation types and them being nice
00:58:38 <Beelsebob> it's got an amusing trail of comments saying "this isn't programming, it's maths" and "programming *is* maths you numnut" after it
00:58:45 <dolio> Ah.
01:03:29 <dolio> There's lots of other fun type math out there.
01:03:34 * Beelsebob nods
01:03:49 <dolio> A^n/n! is unordered n-tuples of As.
01:03:51 <Beelsebob> I think, after seeing the pile of references that came out of that post I need a book on category theory
01:03:59 * Beelsebob nods
01:04:26 <dolio> Bool = 2, Nat = e, or something like that.
01:04:32 <Beelsebob> ah, also, that's the critical thing that makes A^B *not* just a B sized tuple of As
01:04:37 <Beelsebob> but a B indexed one instead
01:05:19 <Beelsebob> something nice we observed is that if you fix the value of B in A^B, then B's type becomes 1, and it demonstrates that beta-reduction does indeed produce the right type
01:05:42 <dolio> Although Nat = e is kind of a weird argument, since it doesn't have e elements.
01:05:59 <dolio> I'd have to think about how you get there.
01:06:28 <Beelsebob> yeh, that is odd -- we were trying to figure out what e^A meant at one point
01:06:41 <Beelsebob> but we needed a definition of what division of types meant
01:06:44 <Beelsebob> to do a taylor expansion
01:06:58 <sjanssen> what does division of types mean?
01:07:02 <dolio> Oh right. That's probably it.
01:07:03 <Beelsebob> no idea
01:07:19 <dolio> e^x = 1 + x + x^2/2! + ...
01:07:28 <Beelsebob> if you can tell me, I'd love to know
01:07:30 * Beelsebob nods
01:07:46 <dolio> So e^A the sum of all unordered n-tuples of As.
01:07:50 <dolio> Which are bags of As.
01:08:07 <dolio> But bags of As can be represented as A -> Nat.
01:08:17 <Beelsebob> ahahaha, that's awesome
01:08:24 <Beelsebob> but wait... that ignores division
01:08:25 <Beelsebob> why?
01:08:37 <dolio> Division doesn't always make sense.
01:08:49 <dolio> At least, as far as I can work out.
01:08:53 <Beelsebob> so we just ignore it?
01:09:02 <dolio> But you don't need arbitrary division for e. It happens to be the right kind of division.
01:09:46 <dolio> T^n/n! is a well-defined type, and that's all e uses.
01:10:02 <Beelsebob> is it? Why?
01:10:15 <mmorrow> kyagrd: just pushed a patch to that repo that adds the ty/tyQ QQs to the "clean" area
01:10:22 <dolio> T^n/n! is unordered n-tuples, I said above.
01:10:41 <Beelsebob> but... T^n is unordered n-tuples, isn't it?
01:10:50 <dolio> T^n is ordered n-tuples.
01:10:58 <Beelsebob> oh, duh, yes
01:11:05 <Beelsebob> ahhhhhhh, *ping* light on
01:11:30 <Beelsebob> so how does one get to T^n/n! being unordered n-tuples?
01:11:56 <dolio> Then you note that there are n! ways of arranging the elements, so you get T^n = n!*(T^n/n!).
01:12:15 <dolio> Where n! is the type with n! members, allowing you to specify which permutation you want.
01:12:28 * Beelsebob nods, but why should it be that, and not something else that coincidentally also has n! elements to take out
01:12:44 <Beelsebob> ah, hmm
01:13:05 <mmorrow> standalone deriving is really a lifesaver
01:13:12 <Beelsebob> okay, I think I can accept that roughly
01:13:15 <copumpkin> ray: here's more http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7528#a7529
01:13:43 <copumpkin> so much boiletplate though :P
01:14:12 <dolio> I think you can do T^n/n, too, but I have to think about what that means for a bit.
01:14:33 <ray> it's all boilerplate!
01:14:36 <ray> and a little that isn't
01:14:46 <copumpkin> ray: yup :P
01:15:04 <copumpkin> ray: with the added problem that I don't think I can actually use any of the nonboiletplate code anyway :P
01:15:21 <copumpkin> I believe I've written uncallable functions, which may be a problem
01:15:34 <copumpkin> of course, this wasn't meant to be practical, but uncallable functions aren't that fun
01:15:59 <ray> they are neither fun nor practical
01:16:37 <copumpkin> I think I'm going to have to go with mmorrow's implicit parameters to get around my uncallable functions and get back to more impracticality
01:17:12 <Taggnostr2> is ghc -O source.hs the right way to compile an haskell program in an executable?
01:17:24 <copumpkin> use --make too
01:17:35 <Beelsebob> and drop the .hs on the name of the source
01:18:17 <copumpkin> *Main> :t undefined + undefined
01:18:17 <copumpkin> undefined + undefined :: (Semiring plus times a) => a
01:18:23 <copumpkin> see, that's not a good type signature to have
01:18:23 <Taggnostr2> it worked with the .hs too
01:18:24 <mmorrow> copumpkin: ooh nice, i'm interested to see how that turns out
01:18:33 <Taggnostr2> but thanks anyway
01:20:42 <Beelsebob> cheers dolio -- yet more to think about
01:20:56 <Beelsebob> anyone have a recommendation for a good book on category theory then?
01:21:14 <Cale> Beelsebob: Awodey
01:22:04 <Beelsebob> cheers cale :)
01:22:34 <copumpkin> just to make sure
01:22:40 <copumpkin> there's no way for me to call that function, right?
01:22:47 <copumpkin> (+) :: (Semiring plus times a) => a -> a -> a
01:22:47 <dolio> Cale: You remember if T^n/n has a meaning, and what it is? I'm drawing a blank.
01:22:54 <copumpkin> without a fundep on a
01:22:58 <copumpkin> which I'd prefer not to have
01:24:29 <copumpkin> or is there some subtle way of telling it what plus and times to use there?
01:25:37 <mmorrow> copumpkin: i think if you indicate the plus/times somehow it'd work
01:25:46 <copumpkin> yeah but how?
01:25:53 <copumpkin> a type annotation won't do it
01:25:59 <mmorrow> an explicit annotation or equivalent
01:26:02 <mmorrow> oh?
01:26:05 <copumpkin> it seems like there's no way for me to write it in?
01:26:39 <copumpkin> those plus and times are "hidden behind the typeclass" as far as I can figure out
01:26:47 <mmorrow> undefined + undefined :: Semiring MyPlus MyTimes a => a {- ? -}
01:26:56 <copumpkin> oh I can do that?
01:26:59 <mmorrow> sure
01:27:02 <copumpkin> ah cool
01:27:16 <mmorrow> (i think)
01:29:08 <copumpkin> mmorrow: doesn't seem to
01:29:14 <mmorrow> grr
01:29:32 <mmorrow> what about if you give the `a' a monomorphic type?
01:29:45 <copumpkin> how would I even write that?
01:29:50 <mmorrow> or s/monomorphic/something more that `forall a. a'
01:29:57 <copumpkin> I tried Semiring Plus Times a, a ~ Integer => a
01:30:02 <copumpkin> but it didn't like that
01:30:06 <mmorrow> oh dang
01:30:10 <mmorrow> what did it say?
01:30:34 <copumpkin> exact same error, it couldn't find an instance for Semiring plus times Integer (note the lowercase plus and times cause that's what I called the type variables)
01:30:49 <mmorrow> hmm, maybe
01:31:03 <copumpkin> I could add a fundep but that'd feel wrong
01:31:24 <mmorrow> foo :: (Semiring plus times a) => plus -> times -> a -> a; foo _ _ a = a
01:31:29 <mmorrow> or something
01:31:40 <mmorrow> (i dunno the kinds of plus/times..)
01:31:46 <copumpkin> let me try that
01:32:14 <mmorrow> foo (undefined::Plus) (undefined::Times) -- maybe
01:32:27 <dufflebunk> did haskell.org just go down?
01:32:55 <copumpkin> mmorrow: aha, that worked
01:32:59 <mmorrow> copumpkin: the implicit params thing seems like it'd be really nice for this actually
01:33:00 <mmorrow> nice!
01:33:05 <copumpkin> mmorrow: yeah, definitely :P
01:33:11 <copumpkin> mmorrow: this works but is fugly :P
01:33:15 <mmorrow> heh, yeah
01:33:22 <copumpkin> implicit params would make it marginally more practical
01:33:27 <Beelsebob> dufflebunk: http://downforeveryoneorjustme.com/haskell.org
01:33:47 <copumpkin> oh damn
01:33:49 <copumpkin> it didn't work
01:33:53 <copumpkin> I thought it did
01:34:02 <mmorrow> :(
01:34:16 <mmorrow> yeah, i think classes are just not a good fit here
01:34:25 <copumpkin> I'm going to try something else a sec
01:34:36 <dufflebunk> Beelsebob: ooo, that's handy
01:35:22 <mmorrow> copumpkin: well, you could use a GADT here and i'm pretty certain that would work
01:35:31 <copumpkin> hmm
01:35:50 <mmorrow> data Plus a where Plus0 :: Plus Plus0; Plus1 :: Plus Plus1; ...
01:35:53 <mmorrow> same for times
01:35:56 <mmorrow> then
01:36:16 <copumpkin> what's the Plus0 type?
01:36:34 <mmorrow> it'd be one of the "plus"es that theres an instance for
01:37:26 <mmorrow> data SemiRingD a where SemiRingD :: (SemiRing plus times a) => Plus plus -> Times times -> SemiRingD a
01:37:28 <mmorrow> maybe
01:37:35 <mmorrow> oh, and finally
01:37:43 <dufflebunk> Bah, looks like putS with CDoubles is really really slow.
01:37:45 <copumpkin> oh I see
01:37:53 <mmorrow> foo :: Semiring a -> a -> ... err, i dunno
01:38:03 <copumpkin> I see
01:38:04 <mmorrow> copumpkin: yeah, somehow weasel the info in there
01:38:08 <copumpkin> or actually
01:38:24 <copumpkin> I could reify the dictionaries into GADTs :o
01:38:27 <mmorrow> totally
01:38:37 <copumpkin> I guess that's more or less what you suggest
01:38:45 <mmorrow> that too (which may defugly stuff as well)
01:38:51 <mmorrow> copumpkin: yeah. more or less
01:39:06 <mmorrow> but there's a bunch of ways you could do it design-wise
01:39:13 <copumpkin> yeah
01:39:24 <copumpkin> the only sure thing is that this isn't the right one :P
01:39:30 <mmorrow> heh
01:39:37 <copumpkin> (I tried a couple of other approaches and still was unable to even call that function)
01:40:03 <copumpkin> so I guess that shows that there is such a thing in haskell as an uncallable function?
01:41:33 <copumpkin> it'd be nice if there were some moderately elegant "backdoor" into the typeclass to type dictionary translation
01:43:11 <copumpkin> ah well, bedtime
01:44:11 <copumpkin> mmorrow: btw a quick question
01:44:33 <daed> is haskell.org working for anyone else?
01:44:36 <mmorrow> yeah that would be neat if there was some sort of backdoor
01:44:38 <mmorrow> copumpkin: ?
01:45:09 <copumpkin> mmorrow: how would one change the value of an implicit parameter for different calls?
01:45:18 <dufflebunk> daed: < Beelsebob> dufflebunk: http://downforeveryoneorjustme.com/haskell.org
01:45:19 <mmorrow> hmm
01:45:22 <copumpkin> and would such a change be possible to wrap up in a "bracket"-like function?
01:45:34 <daed> :(
01:46:26 <mmorrow> , let ?f = (+1) in let go n = if n < 10 then n : go ($f n) else let ?f = (*100) in [?f n] in go 0
01:46:27 <lunabot>  luna: No instance for (Luna.SimpleReflect.FromExpr
01:46:34 <mmorrow> , let ?f = (+1) in let go n = if n < 10 then n : go (?f n) else let ?f = (*100) in [?f n] in go 0
01:46:36 <lunabot>  [0,1,2,3,4,5,6,7,8,9,1000]
01:46:43 <copumpkin> ah, nice
01:46:48 <mmorrow> i think you can just do that maybe
01:47:07 <mmorrow> but i'm not sure about it persisting into the next call (?)
01:48:22 <mmorrow> , let ?f = (+1) in let go n = if n < 10 then (let ?f = ?f . ?f in n : go (?f n)) else [n] in go 0
01:48:23 <copumpkin> > let ?f = (+1); bracket f g = (let ?f = f in g) in bracket (*100) (?f 100)
01:48:24 <lunabot>  [0,2,4,6,8,10]
01:48:25 <lambdabot>   <no location info>: parse error on input `bracket'
01:48:45 <mmorrow> err, that didn't work (?)
01:49:08 <mmorrow> , let ?f = (+1) in let go n = if n < 10 then (let ?f = ?f . (+1) in n : go (?f n)) else [n] in go 0
01:49:10 <lunabot>  [0,2,4,6,8,10]
01:49:15 <copumpkin> it was mine that failed
01:49:37 <mmorrow> mine didn't do what i thought it would either
01:49:53 <mmorrow> , let ?f = (+1) in let go n = if n < 10 then (let ?f = undefined in n : go (?f n)) else [n] in go 0
01:49:54 <lunabot>  luna: Prelude.undefined
01:50:08 <mmorrow> , let ?f = (+1) in let go n = if ?f n < 10 then (let ?f = undefined in n : go (n + 1)) else [n] in go 0
01:50:10 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
01:50:14 <mmorrow> hmm
01:50:48 <mmorrow> so i guess re-defining ?f doesn't persist into the eval of "go"
01:51:23 <mmorrow> , let ?f = (+1) in let go n = if ?f n < 10 then (let go2 = let ?f = undefined in go in n : go2 (n + 1)) else [n] in go 0
01:51:25 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
01:51:42 <mmorrow> hmm
01:52:04 <copumpkin> sad :/
01:52:11 <mmorrow> maybe it captures ?f when it builds the closure for "go"
01:52:17 <copumpkin> probably
01:52:18 <mmorrow> or something
01:52:59 <mathijs> Hi all, is there a way to compare for equality by reference instead of by value? I have a tree from which I want to cut of a branch at a certain point. In this case, I need to compare the tree-structure itself instead of its payload.
01:53:15 <copumpkin> mmorrow: ah well, I'm sure it'll be useful somehow
01:53:27 <copumpkin> @hoogle stablename
01:53:27 <lambdabot> module System.Mem.StableName
01:53:28 <lambdabot> System.Mem.StableName data StableName a
01:53:28 <lambdabot> System.Mem.StableName hashStableName :: StableName a -> Int
01:53:49 <mmorrow> copumpkin: i think it may work differently if it's not all in a single expression too
01:53:58 <copumpkin> ah, that may be true
01:54:21 <abbe> any ideas, anyone about the error at http://pastebin.com/d560c0a3b . try to build ghc 6.10.4.
01:54:49 <mmorrow> mathijs: use StableName, hashStableName, and some trickery, or use a different tree rep
01:54:52 <copumpkin> cabal install haskeline
01:54:56 <copumpkin> anyway, bedtime
01:55:01 <mmorrow> night
01:55:07 <abbe> copumpkin, you can see in that paste that i've installed it.
01:55:18 <abbe> copumpkin, output of ghc-pkg.
01:55:36 <mathijs> copumpkin, mmorrow: thanks, I'll look into that
01:56:06 <mmorrow> mathijs: this pkg may be of interest here:
01:56:11 <mmorrow> @hackage data-reify
01:56:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-reify
01:56:40 <mmorrow> (the idea behind that pkg is what you're looking to do)
01:57:55 <mathijs> sounds about right indeed. thanks
01:58:00 <mmorrow> np
01:58:16 <mmorrow> mathijs: the associated paper is interesting too
02:01:56 <mathijs> reading that... thing is, I'm a bit scared of it having IO. I can see the reason why, but on the other hand, it's a bit strange that if I say: treeA = Node 3 [Node 4 [], Node 5 []]; treeB = Node 1 [treeA]; there is no non-IO way of recognizing treeA is in treeB
02:03:33 <Deewiant> It's not that strange; whether it's treeA or a different (Node 3 [Node 4 [], Node 5 []]) is essentially of no matter to a pure function
02:06:01 <mathijs> looking at it that way... sure... in that case I could also just check if the entire tree matches. But if there are 2 similar branches, it would be impossible to determin which one to delete... Maybe it's easier (in my case) to just change the payload to become (identifier, realpayload)
02:06:23 <mmorrow> or use an explicit graph rep
02:06:30 <mmorrow> Map a (Set a)
02:06:55 <mmorrow> IntSet Int... or IntSet Node, where data Node = Node {nodeId :: Int, ...}
02:07:01 <mmorrow> err
02:07:16 <mmorrow> Node = Node {nodeId :: Int, nodeSuccs :: [Int], ...}
02:07:28 <mmorrow> (or s/[Int]/IntSet/)
02:08:43 <mathijs> I get it... in that case (Map a (Set a)) I pull out my identifier to the structure itself (where it belongs since I want to target structure parts)
02:09:07 <mmorrow> treeA = 3; treeB = 1; graph = [(3,[4,5]),(1,[3])]
02:09:20 <mmorrow> mathijs: exactly
02:09:36 <mmorrow> , vacuum (fix (\x -> (x:)))
02:09:38 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = [a] -> t
02:09:57 <mmorrow> , vacuum (fix (0:))
02:09:59 <lunabot>  [(0,[1,0]),(1,[])]
02:10:06 <mmorrow> a loop
02:10:28 <mmorrow> , vacuum (let x = () in (x,x))
02:10:30 <lunabot>  [(0,[1,1]),(1,[])]
02:10:42 <mmorrow> , vacuum ((),())
02:10:45 <lunabot>  [(0,[1,1]),(1,[])]
02:10:48 <mmorrow> err
02:10:53 <mmorrow> , vacuum (1+1,1+1)
02:10:56 <lunabot>  [(0,[1,2]),(1,[]),(2,[])]
02:10:57 <mmorrow> , vacuum (let x = 1+1 in (x,x))
02:11:00 <lunabot>  [(0,[1,1]),(1,[])]
02:11:17 <Peaker> what does vacuum do?
02:11:28 <mmorrow> (vacuum is using "unsafe" means to get that info)
02:11:29 <mathijs> it makes you choke
02:12:01 <mmorrow> Peaker: this "vacuum" function gives you an adjacency-list rep of the heap subgraph reachable from the value it gets passed
02:12:35 <mmorrow> each Int in reps a pointer (And literals are omitted)
02:12:39 <mmorrow> , vacuum 1
02:12:41 <Axman6> , vacuum (let x = 1 in ((x,x),(x,x)))
02:12:42 <mmorrow> , vacuum 2
02:12:42 <lunabot>  [(0,[])]
02:12:44 <lunabot>  [(0,[1,2]),(1,[3,3]),(2,[3,3]),(3,[])]
02:12:44 <lunabot>  [(0,[])]
02:13:03 <Axman6> , vacuum (let x = 1+2*3 in ((x,x),(x,x)))
02:13:06 <lunabot>  [(0,[1,2]),(1,[3,3]),(2,[3,3]),(3,[])]
02:13:20 <mmorrow> and the ghc primitive that vacuum uses to get at this info doesn't give any info about applications/partial apps, so e.g.
02:13:26 <mmorrow> , vacuum (const 42)
02:13:28 <lunabot>  [(0,[])]
02:13:43 <mmorrow> that really has a pointer to 42 and a ptr to const
02:13:52 <mmorrow> , closureType (const 42)
02:13:54 <lunabot>  AP
02:13:58 <mmorrow> , closureType $! (const 42)
02:14:01 <lunabot>  PAP
02:14:57 <Peaker> ah - maybe it could stringify what thing each element is
02:15:54 <mmorrow> Peaker: the real version of vacuum gives all that info
02:16:22 <mmorrow> (this is just a stripped-down version in the bot)
02:18:19 <mmorrow> Peaker: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7531#a7531
02:18:50 <mmorrow> Peaker: and totally, so cool prettyprinting would be neat
02:18:55 <mmorrow> s/so/some/
02:19:56 <mathijs> another thing: is anyone aware of an example (or project) using the 'reactive' library for socket/network programming? preferably a recent one since reactive is quite a moving target
02:22:10 <Peaker> Is Baughn or anyone still working on Reactive, trying to fix the joinE and other serious bug?
02:24:58 <mathijs> last I read (on the mailing list) they walked into a serious ghc bug so they got stuck... no word on fixing ghc or anything :(
02:27:37 <Peaker> mathijs: the one where threads don't always allocate and therefore don't always cooperate?
02:28:32 <mathijs> but let me rephrase my question: I'm working on a simple collaboration application. it involves multiple users connecting via sockets and modifying a shared state. I did something in ruby, but thought a more functional approach might be nice (since it's all message-passing and modifying concrete structures). I'm currently designing how it should work in haskell...
02:29:59 <mathijs> but I found that (using channels) it's mostly IO and State brought together and quite some locking and low-level concurrency management... So I'm very interested in FRP. I don't care about which library, but I found reactive to be the only one that doesn't solely focus on UIs
02:31:33 <mathijs> Peaker: looking it up now... I think it had to do with threads indeed. The examples I tried all got one thread running like hell (1 core on 100%), eating up memory, while nothing seemed to happen
02:32:31 <Peaker> mathijs: I think Reactive is not really ready for anything real yet because of those serious bugs.  What problems did IO/State bring exactly? What about STM?
02:32:51 <mathijs> http://www.haskell.org/pipermail/reactive/2009-June/000305.html
02:34:36 <mathijs> Peaker: no problems (as I didn't implement anything yet, just thought out the basics). I just get the feeling I'm not using functional programming the way I should when it's all IO do-blocks.
02:35:39 <Peaker> mathijs: Right, but what if its mostly pure code, with just a bit of IO thrown in between? :)
02:36:32 <mathijs> Peaker: STM sounds OK, didn't really look into that apart from reading the chapter in RWH.  Maybe that's the way to go. I was just hoping some FRP stuff might give me the feeling I'm defining stuff again, instead of just "programming" :)
02:38:57 <Peaker> mathijs: FRP is indeed awesome, I just don't think there's a good FRP library with nice semantics (such as reactive) that actually works yet
02:39:47 <mathijs> Peaker: bits of IO are OK I guess. I just don't like the "in between" part. But it's probably because I'm designing the communication + state updating stuff first. Ofcourse there's IO in there. But IO (and certainly multithreaded stuff) are a bit error-prone.
02:40:39 <mathijs> Peaker: ok, so better just keep all my IO stuff in one place... and maybe in the future migrate that stuff to a FRP lib? and look into STM in the mean time?
02:43:31 <Peaker> mathijs: Yeah. STM can be nice if you want dead-lock-free development and composable transactions
03:04:52 <ceal> using the getLine function, only string input is possible rt? how can i typecast it to Num or something?
03:05:06 <Ke> read
03:05:35 <ceal> Ke:i have combed lyah for it; no luck
03:05:37 <ivanm> @hoogle (Read a) => IO a
03:05:37 <lambdabot> Prelude readLn :: Read a => IO a
03:05:37 <lambdabot> System.IO readLn :: Read a => IO a
03:05:37 <lambdabot> Prelude readIO :: Read a => String -> IO a
03:05:51 <ivanm> ceal: readLn, read, reads, etc.
03:06:09 <ceal> Ke:sorry i misread it
03:06:27 <ceal> thanks guys
03:06:59 <Ke> =o)
03:07:25 <Ke> crem_: read and show are a pair of string-a conversions
03:08:03 <ivanm> of course, if you're doing anything non-trivial, you should use a parsing lib
03:08:05 <jorick> hello everyone, i'd like to (help) write a haskell program that works a bit like the games on http://en.wikipedia.org/wiki/Programming_game . I don't feel like doing this alone however, but I'm not sure how to best go about finding interested people and getting them together.
03:08:08 <Ke> where a is appropriate type with required conve4rsions
03:08:09 <Axman6> ceal: there's no casting in haskell...
03:08:41 <ceal> axman6: well i knew only getLine function to get an input
03:08:55 <jorick> anyone ever done something like that who has some tips? :)
03:08:56 <Axman6> @src readLn
03:08:56 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
03:09:04 <ceal> axman6: so i was searching on how to convert the string to another type
03:09:06 <ivanm> Axman6: yeah, we just grab random people off the street to play the roles needed in Haskell, The Movie :p
03:09:27 <ceal> ivanm::)
03:09:29 <ivanm> ceal: Ke and I have already told you a few
03:09:29 <Axman6> Improv programming!
03:09:36 <ivanm> Axman6: heh
03:09:50 <ceal> yeah; i was talking about before you guys did
03:10:13 <ivanm> ahhh
03:10:25 <ivanm> sorry, misread what you said ;-)
03:20:57 <Peaker> @type readIO
03:20:59 <lambdabot> forall a. (Read a) => String -> IO a
03:21:06 <Peaker> @src readIO
03:21:07 <lambdabot> Source not found.
03:21:27 <Peaker> IO exception instead of pure exception?
03:21:48 <ivanm> yeah, I think so
03:21:49 <Peaker> @instances MonadError
03:21:50 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
03:22:02 <ivanm> @index readIO
03:22:03 <lambdabot> System.IO, Prelude
03:22:20 <Peaker> IO is a horrible monad to use for throwing exceptions..
03:22:41 <Deewiant> I tend to use Either String even in IO
03:22:42 <Peaker> And besides, it could just use the horrible "fail" if its there :-P
03:23:06 <Peaker> I dislike String as error.  The Exception Monad with checked exceptions sounds great
03:23:41 <Deewiant> Well, depends whether you need to handle the errors or just report them ;-)
03:23:41 <ivanm> Peaker: what do you mean "String as error"?
03:23:54 <stalker_> @seen conal
03:23:54 <lambdabot> I saw conal leaving #haskell, #ghc, #haskell-in-depth, #haskell-iphone and #haskell-blah 5h 15m 10s ago, and .
03:23:54 <Deewiant> ivanm: Either String vs. Either Exception
03:24:00 <ivanm> ahhh
03:42:36 <ceal> i tried to use readLn but it keep saying <variable> not in scope
03:43:38 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3091#a3091
03:44:27 <ceal> i have also included the error in it; if you dont see it just refresh
03:45:27 <Beelsebob> ceal: the variable m is not created anywhere
03:45:34 <Beelsebob> at a guess, what you meant was m <- readLn
03:45:56 <Beelsebob> note btw, that show does not do what you think – it just stringifys a value
03:46:00 <Beelsebob> > show "jam"
03:46:01 <lambdabot>   "\"jam\""
03:46:18 <Beelsebob> if you want to put a line of text on the screen you want putStrLn
03:50:06 <nomeata> Hi. Any hackage admin/developer around?
03:50:36 <Axman6> i've got a few hackage packages...
03:52:12 <ceal> i got an error after changing it to putStrLn
03:52:15 <ceal> i entered 23
03:52:26 <Axman6> what's the code now?
03:52:28 <ceal> and got the error "a.out: user error (Prelude.readIO: no parse)"
03:52:33 <ceal> just a sec
03:52:51 <Axman6> well, it doesn't know what type of thing you're trying to read in
03:52:52 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3093#a3093
03:53:07 <ceal> how do i specify that?
03:53:26 <Axman6> what you want is: main = do {m <- readLn :: IO Integer; print m}
03:53:42 <EvilTerran> or "main = do m <- readLn; putStrLn (m :: Integer)"
03:53:52 <Axman6> um...
03:53:55 <Axman6> :t putStrLn
03:53:56 <lambdabot> String -> IO ()
03:54:02 <ceal> EvilTerran: i want to read an integer
03:54:05 <ceal> not print one
03:54:21 <EvilTerran> ceal, it seems you're doing both here
03:54:26 <ceal> ?
03:54:32 <Axman6> ceal: what's the show there for then?
03:54:35 <EvilTerran> that's what putStrLn does
03:54:44 <Beelsebob> well putStrLn prints a string
03:54:50 <Beelsebob> print prints any showable value
03:54:56 <ceal> ok
03:55:19 <EvilTerran> ceal, anyway, the point of my comment there was that you can write (m :: Integer) somewhere instead of just writing m to force m to be of type Integer
03:55:26 <blueonyx> :t readLn
03:55:28 <lambdabot> forall a. (Read a) => IO a
03:55:51 <EvilTerran> ceal, and type inference will make sure that type applies everywhere
03:55:58 <ceal> EvilTerran: Oh!! I completely missed the point
03:56:07 <ceal> thanks
03:57:16 <ceal> thanks a lot guys
03:57:42 <ceal> oh and one more thing; what is haskell mainly used for?
03:58:07 <Tordmor> mainly for programming I guess
03:58:21 <ceal> application development?
04:00:27 <Philonous1> http://hackage.haskell.org/packages/archive/pkg-list.html -- might give you some clues about what's being done with haskell
04:13:47 <meder> stupid q, but why can haskell support huge numbers while other languages cant
04:14:01 <meder> well
04:14:08 <meder> in terms of i think some languages abbreviate it
04:14:13 <meder> ^e or whatever it is
04:14:32 <lpsmith> There isn't any real reason why other languages can't support arbitrary precision ints
04:14:48 <meder> if i asked a core java developer, what would he say? :p
04:14:53 <meder> or should i do that now in #java? heh.
04:14:55 <Axman6> meder: ghc uses the gmp library under the hood, which is a C library
04:15:00 <meder> oh
04:15:03 <lpsmith> although it gets tricky in a language that doesn't support garbage collection
04:15:30 <sioraiocht> lpsmith: it's not impossible, though, but arbitrary precision libraries are non-trivial
04:15:37 <sioraiocht> libgmp can be a nightmare
04:16:02 <meder> Axman6: and what does that infer?
04:16:08 <sioraiocht> it depends on a lot of mathematical and hardware tricks to be "fast"
04:16:08 <lpsmith> in those cases, I'm not sure how you can have "nice" addition operators,  etc,  as you have to bake some kind of memory management into the interface
04:16:09 * meder isn't familiar with C
04:16:19 <Axman6> well, any language that can interface with C can use gmp
04:16:36 <Axman6> does Ruby have arbitrary sized integers?
04:16:47 <Zao> python has them at least.
04:17:00 <sioraiocht> Zao: natively? or using a BigNum lib?
04:17:09 <meder> what's so special about gmp
04:17:13 <lpsmith> It's not all that difficult to write arbitrary precision routines in C,  it's just the algorithms to make it go fast are fairly involved
04:17:16 <sioraiocht> meder: it's just wnat's out there
04:17:23 <sioraiocht> lpsmith: aye
04:17:31 <Deewiant> Axman6: Yes, it does
04:17:45 <lpsmith> but if you don't care about performance so much,  then it's not terribly difficult
04:17:45 <sioraiocht> meder: fast numerical analysis is hard, nobody wants to reinvent the wheel
04:17:50 <meder> oh
04:17:54 <Zao> sioraiocht: Beats me, but they call it "long"
04:18:15 <sioraiocht> lpsmith: well yes, you can use simple BCD naively, if you want =p
04:18:25 <lpsmith> of course,  it is hard to have a simple (+) :: Integer -> Integer -> Integer with out some form of automatic memory management :-)
04:18:25 <Deewiant> meder: Java has huge numbers too, see java.util.BigInteger
04:19:00 <lpsmith> Why BCD?  Any radix works...
04:20:53 <Zao> Seems like Python 3.0 merges int/long to just long.
04:21:02 <Zao> I'd reckon it's custom.
04:21:24 <nibro> @seen JaffaCake
04:21:25 <lambdabot> JaffaCake is in #haskell-iphone, #haskell and #ghc. I don't know when JaffaCake last spoke.
04:27:59 <ryo_hazuki> how can i convert a MaybeInt to an Integer?
04:28:15 <lpsmith> :t maybe
04:28:16 <Axman6> :t maybe
04:28:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:28:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:28:19 <Axman6> damnit
04:28:20 <Axman6> heh
04:28:24 <EvilTerran> ryo_hazuki, what do you want as a result if the Maybe Int is Nothing?
04:28:59 <EvilTerran> ?type maybe 0 fromIntegral
04:29:00 <Axman6> :t maybe (-1) fromIntegral (x :: Maybe Int)
04:29:00 <lambdabot> forall t a. (Num t, Integral a) => Maybe a -> t
04:29:01 <lambdabot>     Couldn't match expected type `Maybe Int'
04:29:02 <lambdabot>            against inferred type `Expr'
04:29:02 <lambdabot>     In the third argument of `maybe', namely `(x :: Maybe Int)'
04:29:18 <lpsmith> ryo_hazuki:  depending on what you are doing,  either 0 or 1 is often the best choice
04:29:42 <lpsmith> :t maybe 0 . fmap fromIntegral
04:29:44 <lambdabot> forall t a a1. (Num t, Integral a1) => (a -> a1) -> Maybe a -> t
04:29:49 <Philonous1> :t fromJust
04:29:49 <lpsmith> or
04:29:50 <lambdabot> forall a. Maybe a -> a
04:29:57 <lpsmith> fromJust is bad
04:29:59 <ryo_hazuki> x `elemIndex` xs + 5 for example... thats what i wanna do. and 'nothing' will never happen
04:30:14 <lpsmith> :t fromIntegral . maybe 0
04:30:14 <EvilTerran> depending on circumstance, (error "That should never be Nothing!") or equivalent may be in order
04:30:15 <lambdabot> forall b t a. (Integral (Maybe a -> t), Num b, Num t) => (a -> t) -> b
04:30:30 <EvilTerran> (note "may")
04:30:54 <lpsmith> err
04:30:56 <Philonous1> I wonder, does fromJust Nothing automatically raise an exception, or does it fail (in the monad sense), because if it is the latter it actually makes sense to use it.
04:31:14 <EvilTerran> ryo_hazuki, (maybe (error "some description of what the user did wrong") fromIntegral) should do what you want, then
04:31:17 <lpsmith> @pl  \x -> maybe 0 (fmap (fromIntegral x))
04:31:17 <lambdabot> maybe 0 . fmap . fromIntegral
04:31:19 <Axman6> > fromJust othing
04:31:20 <lambdabot>   Not in scope: `othing'
04:31:23 <Axman6> > fromJust Nothing
04:31:25 <lambdabot>   * Exception: Maybe.fromJust: Nothing
04:31:26 <lpsmith> @pl  \x -> maybe 0 (fmap fromIntegral x)
04:31:26 <lambdabot> maybe 0 . fmap fromIntegral
04:31:34 <lpsmith> :t maybe 0 . fmap fromIntegral
04:31:36 <lambdabot> forall t a a1. (Num t, Integral a1) => (a -> a1) -> Maybe a -> t
04:31:43 <lpsmith> that's not right
04:31:49 <Deewiant> Philonous1: Given that it returns "a" outside a Monad, it can't really do anything except call error
04:32:09 <Philonous1> Deewiant: Makes sense.
04:32:19 <Deewiant> ?ty maybe 0 id . fmap fromIntegral
04:32:21 <lambdabot> forall a a1. (Num a, Integral a1) => Maybe a1 -> a
04:32:25 <Deewiant> lpsmith: That what you were after?
04:32:26 <lpsmith> @pl  \x -> maybe 0 id (fmap fromIntegral x)
04:32:26 <lambdabot> maybe 0 id . fmap fromIntegral
04:32:31 <lpsmith> yeah
04:32:39 <ray> fail can at least return Nothing
04:32:45 <Deewiant> Alternatively use fromMaybe instead of maybe
04:32:45 <EvilTerran> ryo_hazuki, although calling error's only appropriate if any case when the error call would be evaluated is analogous to a case where you'd dump a message to stderr and exit() in C
04:33:00 <EvilTerran> ie, catastrophic failure
04:33:01 <Deewiant> error can be caught in IO
04:33:08 <Deewiant> (With GHC)
04:33:25 <ryo_hazuki> i've read 'fromJust is bad' ... why?
04:33:34 <ryo_hazuki> lpsmith
04:33:40 <lpsmith> :t maybe 0 fromIntegral
04:33:42 <lambdabot> forall t a. (Num t, Integral a) => Maybe a -> t
04:33:43 <EvilTerran> ryo_hazuki, because it calls "error" if its parameter is Nothing
04:33:50 <ryo_hazuki> oh ok
04:33:52 <lpsmith> yep
04:34:00 <EvilTerran> ryo_hazuki, but with a generic error message, because there's nowhere to provide it with a better one
04:34:10 <lpsmith> there we go.  Brain fart there for a minute
04:34:10 <EvilTerran> Deewiant, but you shouldn't do error handling that way, unless you're going to be running code you don't trust
04:34:25 <EvilTerran> (to not call error)
04:34:36 <Deewiant> Why not?
04:34:40 <EvilTerran> (or pattern-match fail, or use undefined, or ...)
04:35:13 <Deewiant> I mean, I realize it's not exactly the best way of doing it but why should it be avoided
04:36:16 <EvilTerran> from a theoretic point of view, because it makes nontermination and error distinguishable, and they're both _|_
04:36:28 <ray> also because it's easy to do it better
04:36:39 <EvilTerran> also, it can be hard to predict when "error" will be invoked
04:36:43 <EvilTerran> because of laziness
04:37:37 <EvilTerran> other methods encode the fact that an exception may be thrown in the type of the risky expression
04:38:08 <EvilTerran> which is nice - compile-time, machine-interpretable documentation is always good
04:38:24 <EvilTerran> but anything can call "error"
04:38:33 <Deewiant> Yep, that's the main point in my opinion
04:39:23 <ray> why have this nice type system and not even use it
04:44:12 <EvilTerran> "try (evaluate x)" only catches errors that occur between x's evaluation state beforehand and its reduction to WHNF, not before or after
04:45:17 <EvilTerran> so evaluating it too much beforehand or hiding errors in places that don't get forced en route to WHNF can get errors in x thrown outside the try
04:46:12 <EvilTerran> Deewiant, i consider that to be a big problem, too
04:46:39 <Deewiant> Well, it just means that you need to be careful whenever you're thinking about catching error
04:46:41 <EvilTerran> mainly, though, it's because i prefer my code to be total, and any domain partiality should be represented in the types
05:04:00 <ivanm> jauaor: what's wrong with "araujo"? :p
05:04:13 <jauaor> argh
05:04:21 * jauaor trying to avoid ivanm with this new nick
05:04:23 <ivanm> heh
05:04:43 <jauaor> :D
05:05:35 <ivanm> jauaor: go help smorg in #gentoo-haskell with himerge
05:05:47 <jauaor> that reminds me
05:05:51 <jauaor> himerge++
05:05:53 <jauaor> :D
05:06:02 <smorg> :)
05:06:03 <ivanm> @slap jauaor
05:06:03 * lambdabot moulds jauaor into a delicous cookie, and places it in her oven
05:42:44 <soupdragon> > 1+1
05:42:46 <lambdabot>   2
05:43:12 <Peaker> > "1"++"1"
05:43:14 <lambdabot>   "11"
05:43:27 <agapoulitsas> > factor 23443
05:43:29 <lambdabot>   Not in scope: `factor'
05:43:30 <Peaker> > read "1" + read "1"
05:43:31 <lambdabot>   2
05:44:34 <amaron> Cale: remember I mentioned about executing compiled haskell binary on other linux box? I it didn't work. I've run into 'timer_create' problem during execution.
05:44:44 <Peaker> > let inRead = (show .) . (. read) in inRead (+1) "1"
05:44:46 <lambdabot>   "2"
05:44:50 <ray> > "1" `mappend` "1"
05:44:52 <lambdabot>   "11"
05:46:59 <canvon> > sum (repeat 2 1)
05:47:00 <lambdabot>   Couldn't match expected type `t -> [a]'
05:47:31 <canvon> > sum (replicate 2 1)
05:47:32 <lambdabot>   2
05:48:25 <EvilTerran> > let factor = go 2; go i n | (i > n) = [] | (n `mod` i == 0) = i : go i (n `div` i) | otherwise = go (i+1) n in factor 23443
05:48:26 <lambdabot>   [7,17,197]
05:49:18 <Peaker> > sum . replicate 2 $ 1
05:49:19 <lambdabot>   2
05:49:35 <Peaker> > replicateM 2 [1]
05:49:36 <EvilTerran> > [i | i <- [1..23343], 23343 `mod` i == 0]
05:49:36 <lambdabot>   [[1,1]]
05:49:37 <lambdabot>   [1,3,31,93,251,753,7781,23343]
05:49:51 <EvilTerran> ...
05:50:42 <canvon> > [i | i <- [1..23443], 23443 `mod` i == 0]
05:50:43 <lambdabot>   [1,7,17,119,197,1379,3349,23443]
05:51:07 <EvilTerran> ah, mis-type. that explains it.
05:51:12 <canvon> :)
05:51:47 <Peaker> > [i | let f = 23443, i <- [1..f], f `mod` i == 0]
05:51:48 <lambdabot>   [1,7,17,119,197,1379,3349,23443]
05:52:56 <Peaker> > \f -> filter (\i -> f `mod` i == 0) (enumFromTo 1 f) $ 23443
05:52:57 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
05:53:48 <Peaker> > (\f -> filter (\i -> f `mod` i == 0) (enumFromTo 1 f)) 23443
05:53:50 <lambdabot>   [1,7,17,119,197,1379,3349,23443]
05:53:57 <Peaker> @pl (\f -> filter (\i -> f `mod` i == 0) (enumFromTo 1 f))
05:53:58 <lambdabot> ap (filter . flip flip 0 . ((==) .) . mod) (enumFromTo 1)
05:54:11 <Peaker> @type flip flip 0
05:54:13 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
05:54:33 <Peaker> ??
05:54:38 <lpsmith> see,  I like a relatively point-free approach,  but a totally pointless approach does seem pointless to me
05:54:59 <Peaker> lpsmith: @pl sometimes gives stupid points-free solutions
05:55:11 <lpsmith> what's the ??
05:55:11 <Peaker> @let result = (.) ; arg = flip (.)
05:55:13 <lambdabot>  Defined.
05:55:28 <Peaker> @let both :: (a -> b) -> (a, a) -> (b, b);  both = join (***)
05:55:29 <lambdabot>  Defined.
05:55:39 <lpsmith> @def join
05:55:40 <lambdabot> Maybe you meant: bf let
05:55:49 <lpsmith> :t join
05:55:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:55:51 <Peaker> > let t = (both . result) (*2) (const 1, const 2) in both ($0) t
05:55:52 <lambdabot>   (2,4)
05:55:55 <lpsmith> @src jion
05:55:55 <lambdabot> Source not found. You untyped fool!
05:56:00 <lpsmith> oh right
05:56:51 <Peaker> @pl \(f, g) -> ((*2) . f, (*2) . g))
05:56:52 <lambdabot> (line 1, column 32):
05:56:52 <lambdabot> unexpected ")"
05:56:52 <lambdabot> expecting variable, "(", operator or end of input
05:56:58 <Peaker> @pl \(f, g) -> ((*2) . f, (*2) . g)
05:56:59 <lambdabot> ((2 *) .) *** ((2 *) .)
05:57:09 <Peaker> not so bad, but usually @pl does worse :)
05:57:26 <Peaker> @pl \(f, g) -> (\x -> 2 * f x, \x -> 2 * g x)
05:57:26 <lambdabot> ((2 *) .) *** ((2 *) .)
05:57:36 <ray> @pl knows (***)? fancy
05:57:36 <lambdabot> knows (***) ? fancy
05:57:40 <ray> ahem
05:57:41 <Peaker> :)
05:57:50 <lpsmith> see,  I find that one rather readable
05:57:58 <lpsmith> in the point-free style
05:58:02 <Peaker> if @pl used  result/arg for unary  (.) and used  both, it would be even more readable
05:58:27 <Peaker> (both . result) (*2)   is still nicer than the above ;)
05:58:49 <Peaker> my point is that @pl should not always be taken as the representative of how points-free looks like, because it doesn't always know how to make it nice
05:58:54 <LeoD> @pl \f g x -> (f x, g x)
05:58:54 <lambdabot> liftM2 (,)
05:59:01 <Peaker> @let each = map
05:59:03 <lambdabot>  Defined.
05:59:19 <Peaker> > (each . first . second) (+100) [((1,2),3), ((4,5),6)]
05:59:20 <lambdabot>   [((1,102),3),((4,105),6)]
06:00:21 <Peaker> @pl map (\((x, y), z) -> ((x, 100+y), z)) [((1,2),3), ((4,5),6)]
06:00:22 <lambdabot> [((1, 102), 3), ((4, 105), 6)]
06:00:35 <Peaker> didn't know @pl applied when it could
06:00:38 <Peaker> @pl map (\((x, y), z) -> ((x, 100+y), z))
06:00:38 <lambdabot> map (uncurry (uncurry (((,) .) . (. (100 +)) . (,))))
06:00:53 <Peaker> lpsmith: Now, you'd say this @pl shows you really prefer the points-ful one, right?
06:01:04 <Peaker> where in fact, the most readable is probably: (each . first . second) (+100)
06:01:37 <Peaker> @pl is only good at proving that points-free is always possible, but not necessarily finding the nicest form
06:01:38 <lambdabot> (line 1, column 60):
06:01:38 <lambdabot> unexpected ","
06:01:38 <lambdabot> expecting variable, "(", operator, "+", "-" or end of input
06:01:59 <ray> we should change @pl to @peaker-lovely
06:02:58 <Peaker> How 'bout these names?  s/map/each, s/fmap/inside, result, arg, both, etc?
06:03:15 <soupdragon> no
06:03:27 <Peaker> good for SEC use :)
06:05:24 <nomeata> Hi. How do I properly parse a Data.Version.Version value?
06:05:36 <nomeata> There is parseVersion :: ReadP Version, but I don’t know how to use it correctly
06:10:52 <Saizan> ?hoogle readP_to_S
06:10:52 <lambdabot> Text.ParserCombinators.ReadP readP_to_S :: ReadP a -> ReadS a
06:10:57 <Saizan> nomeata:  ^^^
06:11:19 <nomeata> I found that a bit strange to use. Anyways, Cabal has simpleParse, which is what I want
06:17:33 <lpsmith> Peaker:  in that case, yeah
06:17:48 <lpsmith> Hmm... I'm trying to install GLUT on hackage on Ubuntu
06:18:13 <lpsmith> it compiles, but then it can't find the library... but I have freeglut3 and freeglut3-dev installed.  :-(
06:18:21 <lpsmith> any ideas?
06:18:41 <Peaker> lpsmith: yeah, there's a bug that omits a -l option from the ldflags in the installed cabal package of glut
06:19:02 <lpsmith> ahh, thanks,  -lGLUT?
06:19:06 <lpsmith> or something else?
06:19:44 <Peaker> lpsmith: edit your ~/.ghc/*/package.conf
06:19:58 <Peaker> lpsmith: find the definition   InstalledPackageInfo {package = PackageIdentifier {pkgName = PackageName "GLUT" ...
06:20:26 <Peaker> lpsmith: what is the ldOptions in that line?
06:21:08 <lpsmith> ldOptions? don't see anything like that
06:22:21 <Peaker> lpsmith: did you find that package info line?
06:22:39 <Peaker> lpsmith: its a very long line
06:23:05 <Peaker> lpsmith: in mine, I have: ldOptions = ["-lglut","-lSM","-lICE","-lXmu","-lXi","-lGLU","-lGL","-lm"]
06:23:49 <lpsmith> ok, found it
06:24:09 <lpsmith> doesn't look like there is anything there
06:24:24 <lpsmith> as in, ldOptions = []
06:25:05 <badsheepy> uh, i never did any of that to install glut :o
06:25:25 <lpsmith> it installed fine, but it doesn't work
06:25:29 <badsheepy> on ubuntu i mean, making it at least slightly relevent
06:25:30 <badsheepy> hehe
06:25:30 <lpsmith> it's not finding the library for some reason
06:27:40 <Peaker> lpsmith: replace the empty list with my list and try to relink
06:27:44 <nomeata> dons: Hi. I think you’ll like this: http://hackage.haskell.org/trac/hackage/ticket/570
06:27:49 <Peaker> lpsmith: the ldOptions being empty is why it didn't find the library
06:28:10 <Peaker> lpsmith: iirc, I reported this bug and it has to do with the configure phase of the GLUT package failing to find Xmu and instead of failing the build, writing an empty ld options
06:28:25 <ryo_hazuki> programming excercises in german [hope there will be more haskell solutions soon] => http://www.hackerboard.de/board.php?boardid=46
06:28:25 <hackagebot> interpolatedstring-perl6 0.1 - QuasiQuoter for Perl6-style multi-line interpolated strings. (AudreyTang)
06:28:41 <lpsmith> sweet, it's working now,  thanks
06:28:49 <lpsmith> @karma+ Peaker
06:28:50 <lambdabot> Peaker's karma raised to 3.
06:29:39 <lpsmith> ahh, yes
06:29:52 <lpsmith> I did discover I was missing the libxmu headers
06:30:59 <Cale> <medfly> I like to assume no errors = I'm good  <medfly> but PHP likes to assume wrong syntax = fix it = don't report errors  <Lede> that sucks :/  <Lede> isnt there a flag for pedantic mode  <medfly> it's "stop using PHP, you idiot"
06:32:24 <lpsmith> heh,  PHP won't get any love from me.
06:32:47 <lpsmith> At least Perl6 looks like it's going to move the language into a level of respectability
06:33:09 <ray> you're just saying that because someone implemented it in haskell
06:33:21 <lpsmith> no
06:33:39 <lpsmith> I'm saying that because it sounds like they really have worked to clean up the language quite a lot
06:33:54 <Cale> ray: I think there's a good amount of Haskell's principles which rubbed off on members of the perl community too.
06:34:04 <lpsmith> Am I going to go out and learn Perl6?  I dunno.
06:34:39 <Cale> I'm sure it will still be perlish, but by implementing something like that in Haskell, you probably discover many of the more egregious things early.
06:35:34 <ray> i think it has to be cleaner by default :)
06:36:14 <lpsmith> I don't particularly care for Perl, but I must admit,  CPAN is amazing
06:36:32 <ray> cpan the program has only ever given me headaches
06:36:38 <ray> cpan the selection of libraries is pretty great
06:36:58 <lpsmith> heh
06:37:09 <lpsmith> I was referring to the latter :-)
06:40:36 <Baughn> Peaker: I'm working on reactive, sure. Kind of - I'm trying to implement it using an entirely different approach.
06:40:52 <Peaker> Baughn: what approach?
06:41:32 <Baughn> Peaker: The main problem with reactive is the time comparisons, right?
06:41:41 <Baughn> Peaker: That's why it needs unamb and all that stuff.
06:42:00 <Peaker> Baughn: one of the problems, not sure its the entire story..
06:42:09 <Peaker> Baughn: anyway, its a big problem, go on :)
06:42:11 <Baughn> Well, it's the largest one at least
06:42:39 <lpsmith> heh, I'm playing with reactive now in fact
06:42:44 <Baughn> Peaker: So.. how should I put it. Information-flow-wise, unamb gathers information from two sources and presents it as one
06:42:55 <lpsmith> There is an animation I've been intending to write for some time now
06:43:00 <Baughn> That's its raison-d-etre
06:43:09 <Baughn> But that's unneccessary if there's only one source to begin with
06:43:11 <lpsmith> any suggestions on how to get started?
06:43:21 <Peaker> Baughn: when is that?
06:43:57 <Baughn> Peaker: Um.. I think that's the wrong way to put it. Fine. Let me just tell you what I'm doing, then. :P
06:46:23 <Baughn> That is, observers basically. When a new time is derived from an old one (eg. using min), the constructor (min) alters MVars in the parent times, inserting weak pointers to the new time
06:46:41 <Peaker> Baughn: with unsafePerformIO?
06:46:49 <Baughn> I've renamed it to "io".
06:47:03 <Baughn> I'm sure this is safe.. probably...
06:47:07 <Peaker> heh
06:47:16 <soupdragon> why don't you implement it in C
06:47:18 <Peaker> I think "unsafePerformIO" should scream out of the code
06:47:24 <soupdragon> instead of using haskell
06:47:24 <Baughn> soupdragon: Wouldn't make a difference
06:47:38 <Peaker> soupdragon: C doesn't have polymorphic types?
06:47:47 <Baughn> soupdragon: Arguably, I should be implementing this inside the RTS code
06:48:01 <Baughn> I'm not sure what the correct primitives are yet, though
06:48:06 <Peaker> soupdragon: can one implement a polymorphic Haskell API with C?
06:48:07 <soupdragon> yeah RTS
06:55:29 <Baughn> Peaker: Caught an interrupt. Anyhow. Then, when the actual numeric time is finally known (by calling an IO ()), this procedure will walk the tree of all times derived from this root, filling in their values as appropriate.
06:55:48 <colpsmith> Is there a way to express 2D vector graphics with FieldTrip?
06:56:09 <Peaker> Baughn: I see. how far into that idea are you?
06:56:11 <Baughn> Peaker: When their values are already known, it compares. If they aren't, that can only mean they are later than the newly known one.
06:56:22 <Baughn> Peaker: I'm at the "debugging GHC" stage
06:56:59 <Baughn> Well, that's basically push-based FRP. I recover the push-pull efficiency by using weak pointers.
06:57:52 <Peaker> Baughn: Yeah, I wanted to try that approach too, I think you must use unsafePerformIO for the efficient push approach, even if you only need to support Functor instance on events
06:58:09 <Baughn> Peaker: In this particular case, unsafePerformIO executing more than once is /perfectly safe/, but it does add some inefficiency. It also happens a lot; I'm trying to figure out why.
06:59:13 <Baughn> The only thing unsafePerformIO does is add a note to the parent times that when they're known, they need to visit this child too (by pushing a value to a list in an MVar)
06:59:31 <Baughn> (Unless they're already known, of course)
07:01:04 <pejo> Baughn, is the reason you're using unsafePerformIO efficiency in the first place?
07:04:25 <Baughn> pejo: No. It's because I need to make the (pure) creation of new times alter older ones (its parents), in order to make the fill-in function for their parents also affect the new one.
07:05:22 <Cale> Well, ultimately it's about performance, because you could simulate any mutation using pure datastructures ;)
07:05:44 <Baughn> I.. don't think so
07:06:25 <Elly> I do
07:06:30 <Baughn> The original time /needs/ references to the newer ones
07:06:39 <Baughn> But they didn't exist at the time it was created, so how can it?
07:06:43 <Baughn> (Unless I use uPIO)
07:06:52 <Elly> there is no reason you cannot do that with a pure data structure
07:07:04 <raboof> when i do 'import Network.HTTP', what should i pass to ghc to compile my .hs?
07:07:15 <pejo> raboof, --make
07:08:18 <MarcWeber> nominolo_: I'd like to ask scion to automatically add some ghc flags when loading a file component. Until now I added --packages: a,b making my mapping add -package a -package b to the compilation flags. Which way do you prefer to implement this in scion?
07:08:26 <Cale> Baughn: You could use a Data.Map to represent that mapping, and update it.
07:08:27 <raboof> pejo: cool, seems to work
07:08:48 <MarcWeber> Using client only solutions? Using a config file? Using a special command: AddFlagsFromFile parsing these comments on demand?
07:09:12 <Baughn> Cale: Which would create a new Map in addition to the old one. How do I swap out the reference in the original time, then?
07:09:44 <Cale> Baughn: Basically, you'd be threading the current Map through the computation.
07:10:23 <Baughn> Cale: I can't do that. Not and still instance Functor, anyhow.
07:11:39 <Baughn> Cale: If you can suggest a way to do this and still keep the same API as in reactive (types and all), I'm all for it. :)
07:12:29 <Cale> Can I see more about the types?
07:12:52 <Cale> I just mean that since you can theoretically accomplish any impure computation whatsoever using a Data.Map to simulate the memory of a machine, it ought to be possible to remove any actual mutation you're doing from any impure computation, by threading a representation of the heap along.
07:13:02 <Peaker> Cale: Do you know the Reactive API?
07:13:11 <Cale> Peaker: yes, roughly
07:13:27 <Peaker> Cale: this isn't meant to represent destructive writes, but events from the outside world
07:14:02 <Cale> (I'm assuming that you might have to change the implementations of the types)
07:14:14 <Peaker> Cale: semantically:  Event a = [(Time, a)] (sorted)   and    Behavior a = (Time -> a)    Monoid of Events merges Events, and both are Functors, Behavior is a Monad.  You want the implementation to be push based
07:14:36 <Cale> Peaker: right.
07:15:13 <Peaker> Cale: so if  keyPresses :: Event Key   you want a bunch of "fmap" calls on it or mappends on it to create an a dependency graph that causes a key press event coming from some IO thread to propagate through this graph and update only those who need an update, efficiently
07:15:42 <Cale> "<Baughn> pejo: No. It's because I need to make the (pure) creation of new times alter older ones (its parents), in order to make the fill-in function for their parents also affect the new one." -- which type is this referring to?
07:15:57 <Baughn> Cale: Time.
07:17:05 <Cale> Baughn: Is it not possible to *explicitly* represent that graph somewhere?
07:17:24 <Cale> (the one that Peaker is referring to)
07:18:02 <Baughn> Cale: Semantically, that's an integer type with nanosecond precision, with the interesting property that its value may not be known at the time of its creation but, if so, it's known to be at or later than the present time according to a clock, which is used by its instance of Ord in order to complete compare calls before both values are known.
07:18:18 <Peaker> Baughn: semantically, you shouldn't care what Time is, no?
07:18:38 <Baughn> Cale: ..thinking
07:18:47 <Cale> That is, use a Map Vertex (Set Vertex) or something to represent the dependency graph arcs, and some explicit representation of the heap
07:18:58 <Baughn> Peaker: Sometimes you want the actual raw value, but usually you're right.
07:20:17 <Baughn> Peaker: I figure most operations can be done via the AffineSpace instance
07:20:59 <Cale> I have this feeling that all the recent approaches to FRP have been way too "implicit" in their implementation approach, basically hoping that GHC will compile things in such a way that dependencies are handled sanely.
07:21:00 <Peaker> Baughn: I don't know AffineSpace..
07:21:30 <Peaker> Cale: Yampa uses arrows to build this dependency graph explicitly, but each "node' in the graph is actually exposed to the frame rate and is written imperatively
07:21:30 * Baughn feels that his approach is quite explicit
07:21:46 <Baughn> Peaker: http://en.wikipedia.org/wiki/Affine_space
07:22:08 <Baughn> Peaker: "an affine space is what is left of a vector space after you've forgotten which point is the origin."
07:22:27 <Baughn> Which makes sense for times, since there is no actual origin for time
07:22:33 <Cale> Peaker: Right, and that works, but it's ugly. What I think we want is something which compiles a Reactive-like interface into a Yampa-like one, perhaps.
07:22:35 <Peaker> Cale: Basically, maybe you could say that you'd like a library implementing the Reactive API to break referential transparency, but only for caching/performance (not changing denotational semantics), so that two Events which are functions of the same Event value, would know that they share an input, so that the input is only computed once
07:22:38 <nominolo_> MarcWeber: where does --package: a,b come from?
07:22:39 <Baughn> ..unless we use the big bang for that
07:23:12 <Peaker> Cale: Also, Yampa is probably less efficient because of the tupling of the arrows, having to update more nodes in the graph upon input updates (if only to re-tuple them)
07:23:46 <Cale> (or something even lower-level perhaps)
07:24:01 <MarcWeber> nominolo_: It looks like this: I add it to each small single file project  http://dpaste.com/71602/
07:25:06 <MarcWeber> It's both: documentation and hints how to setup ghc.. I'm adding a cmdLoadSettingsFromFile. So this feature will be optional
07:25:35 <Cale> Do you think it's crazy to try to represent the dependency graph in a way which is actually explicit rather than leaving it up to GHC's implementation of lazy evaluation?
07:26:19 <Peaker> Cale: where does lazy evaluation help generate the graph here?
07:27:21 <Cale> Peaker: values are being treated as pointers, and the graph is being constructed implicitly (at least in my understanding of what's going on, which is admittedly somewhat shaky)
07:28:04 <nominolo_> MarcWeber: ok, so you could use a {-# OPTIONS_SCION #-} pragma, but I would personally prefer a separate file. .scion_config or ./scion/config (both)
07:28:29 <Cale> and you're trying to have it so that when some value is demanded, its evaluation causes demand for the appropriate other values in the dependency graph
07:28:38 <Peaker> Cale: I think the graph here is constructed implicitly by having unsafePerformIO calls on MVar reads of the dependency, which forms the reverse-arrow (as putMVar will send it to the observer)
07:28:39 <nominolo_> I don't think putting this stuff into the file is a good idea
07:28:59 <Peaker> Cale: Instead of causing demand, there's an MVar registration, iiuc
07:29:00 <MarcWeber> nominolo_: What's bad about it?
07:29:20 <nominolo_> MarcWeber: it litters the file with things only certain users need.
07:29:51 <nominolo_> and it's more difficult to have private settings
07:29:55 <Cale> Peaker: but the reason for unsafePerformIO is basically to change the implementation of the evaluation of a value to do something more complicated (basically, to force evaluation of other nodes in the graph)
07:30:06 <nominolo_> i.e., differint users might want to specify different things there
07:30:21 <MarcWeber> nominolo_: Thinking about split base etc you're right
07:30:50 <Peaker> Cale: that's not how I understand it (but I may also misunderstand)
07:31:00 <nominolo_> for one-file projects you could have per-file sections in the config file
07:31:06 <MarcWeber> nominolo_: By the way: Can scion run cabal build (to create executables) ?
07:31:23 <Peaker> Cale: what you're describing is a Pull model, where demand propagates through the graph.  In this case, we're talking about a push-based graph, which propagates inputs, not demand for inputs
07:31:23 <nominolo_> it doesn't at the moment, but it could.
07:31:59 <Peaker> Cale: the difficulty is in letting pure build up of Events and such somehow build a non-pure mutable graph of who-to-update-when-input-arrives
07:32:59 <Cale> Peaker: okay, then in that case, your unsafePerformIO will be there to cause the evaluation of a value to propagate information to its dependents in the graph, rather than demand to its dependencies
07:33:39 <Cale> Peaker: But the idea is the same -- you're changing GHC's evaluation model and letting the graph remain implicit, rather than explicitly representing it as a value in any one place.
07:34:38 <Cale> If I asked you to draw a picture of the dependency graph, you'd have to go chasing MVars all over
07:34:50 <Peaker> and I can only give you a graph in IO
07:35:07 <Cale> It's not as easy as taking your Map Vertex (Set Vertex) out and passing it off to graphviz ;)
07:36:20 <MarcWeber> nominolo_: Fine. I'll use the .scion-config file.
07:36:30 <Peaker> and its not clear how to fix that, Cale, as the graph is dynamic, based on runtime inputs
07:36:48 <Peaker> Cale: I think Yampa solves it with a lot of API complexity, whereas Reactive is relatively very simple
07:36:50 <MarcWeber> nominolo_: Anyway: Can you help me setting up emacs? I'd like to fix passing the array in some way.
07:37:11 <Cale> Peaker: Well, the computation as a whole is going to be running in IO anyway, in the end.
07:38:27 <Peaker> Cale: how would you change the Reactive API to have the graph be more explicit?
07:38:39 <Cale> the outward API shouldn't change.
07:39:25 <nominolo_> MarcWeber: what's the problem exactly with the array stuff?
07:39:26 <Cale> The way I see it working is that your reactive combinators build up an IO computation which captures input, inspects this explicit graph and decides what to compute.
07:39:59 <Peaker> Cale: so how do you get pure code like  (fmap (*2) someInput, fmap (*3) someInput) to build a graph where both of these events come out from the same node?
07:40:34 <Peaker> Cale: you basically want aggressive CSE here, where it attaches common subexpressions to the same graph nodes, somehow
07:41:22 <MarcWeber> nominolo_: I didn't like passing the configure flags as space separated string. So I changed that passing a JS Array now.
07:41:30 <Cale> Well, someInput will be one of the Reactive types, so it will contain an explicit representation of which graph vertex it corresponds to (an Int maybe)
07:41:48 <Peaker> Cale: otherwise all possible routes through your graph, all the way to the input, are duplicated, such that instead of A,B <- E  C,D <- F   E,F <- G       you get:  A<-E<-G, B<-E<-G, C<-F<-G, D<-F<-G
07:42:16 <MarcWeber> nominolo_: Maye I should fix the server that it accepts both: Arrays and Strings
07:42:29 <Peaker> Cale: ah, ok, that's a different approach, so maybe what I said last doesn't apply
07:42:56 <nominolo_> MarcWeber: yes, I did this for dictionaries, i.e., null is treated as {}
07:42:57 <Cale> Let's think about doing this in the State monad, say, and try to determine what our State type would be
07:43:54 <Cale> I suppose we'd have the graph itself, the next free vertex, and a mapping from the graph nodes to known values
07:44:25 <Cale> (I foresee the need an unsafeCoerce in here somewhere, but it should be one which is provably safe ;)
07:45:31 <Cale> anyway, my hope is that by explicitly representing what depends on what, there will be less fighting with GHC over the precise operational semantics of evaluation.
07:45:47 <hackagebot> interpolatedstring-perl6 0.2 - QuasiQuoter for Perl6-style multi-line interpolated strings with "q", "qq" and "qc" support. (AudreyTang)
07:45:59 <Cale> (which is a problem that any program which intends to use unsafePerformIO would face)
07:46:04 <Saizan_> Peaker: you can do the CSE at "runtime" with hash consing and other memoization-like techniques
07:46:44 <nominolo_> MarcWeber: though, be careful about ambiguities between null -> {} and null -> []
07:46:49 <Saizan_> (just a small comment i don't want to fork the discussion)
07:47:35 <Peaker> Saizan_: what is hash-consing?
07:48:05 <Peaker> Cale: can you try to implement of Event/Behavior that way?  if you make progress with that approach it may help a great dela
07:48:21 <MarcWeber> nominolo_: That's why I was looking for an encodeAsArry in json.el. But I didn't find it
07:49:06 <nominolo_> ok, so extra args is still sent as a string
07:49:13 <mauke> AFAIK hash consing = memoized constructors
07:49:18 <Saizan_> yeah
07:49:33 <Saizan_> so all equal values are reference-equal too
07:53:29 <desp> "Couldn't match expected type `xs5 :+: xs5' against inferred type `xs3 :+: xs4'"
07:53:39 <Peaker> Cale: are you implementing an example? :)
07:53:51 <desp> Am I missing some language extension?
07:54:49 <hackagebot> interpolatedstring-perl6 0.3 - QuasiQuoter for Perl6-style multi-line interpolated strings with "q", "qq" and "qc" support. (AudreyTang)
07:54:52 <Saizan_> desp: that's little context :) but i guess those variables are quantified?
07:55:34 <desp> Saizan_: one moment, trying to extract the problematic code from the rest.
07:58:29 <desp> Saizan_: oh, never mind.  That was a really silly error.
07:59:24 <Saizan_> Peaker: i'm talking about something like this: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.99.8046
07:59:42 <Baughn> ..upgrading arch's ghc package broke xmonad. Of course. Is there some script to fix this mess?
08:00:07 <Saizan_> "cabal install xmonad" ?
08:00:46 <nominolo_> MarcWeber: BTW, Please try to write proper commit messages.  They should at least be full sentences, and start with a capital letter.
08:01:11 <Zao> ${VCS} ci -m ''
08:01:22 <nominolo_> And things like "ugly vim hack" should come with a short explaination of the problem.
08:01:55 <Baughn> Saizan_: Unfortunately, I also installed xmonad via pacman.
08:02:28 <MarcWeber> nominolo_: I told you that I should tidy up those commits, didn't I ?
08:02:50 <nominolo_> Ah, so I'm not meant to pull this yet?
08:03:21 <MarcWeber> nominolo_: I broke Emacs. So no. Not yet
08:03:34 <MarcWeber> nominolo_: But I'd be glad if you could have a look at the configuration idea..
08:04:09 <MarcWeber> See Utils.hs -> writeSampleConfig
08:06:00 <nominolo_> ok.  I'll take a look.  BTW, don't move the Scion stuff to lib/Scion/Utils.hs; the library shouldn't depend on JSON
08:06:32 <nominolo_> I think the library also has some bogus dependencies, ATM.
08:07:01 <MarcWeber> nominolo_: The idea was to make the lib read the config and use json to format its contents
08:07:12 <MarcWeber> That's why I added JSON as dependency
08:07:13 <nominolo_> ah, just saw that.  hm
08:07:32 <MarcWeber> At least that's easy to read, write by humans, the server and the clients
08:07:49 <MarcWeber> And I'll add another line type now:             ,"{\"file\":\"my-quick-test.hs\", \"flags\":[\"-package\", \"parsec\"]}"
08:08:04 <MarcWeber> Then I'm happy.
08:08:33 <nominolo_> ok, why prefix with a "type"?
08:08:44 <Cale> Peaker: I haven't.
08:08:58 <Cale> Peaker: But perhaps I might :)
08:09:11 <nominolo_> why not "build-config":{"name":"debug", "dist-dir":..., "extra-args":...} ?
08:09:36 <nominolo_> oh, might have to be an array of configs
08:09:44 <Le-Chuck_ITA> heya, do you have advice on a channel where they know what a coalgebra is and also want to talk about that?
08:10:24 <MarcWeber> nominolo_: I'd like to keep it as simple as possible. Using one JSON object is not easy to read by humans. That's why used one JSON object per line.
08:10:32 <MarcWeber> Your proposal can't be parsed, can it?
08:10:58 <Axman6> Le-Chuck_ITA: looks like you're in the right place (or #haskell-blah or #haskell-in-depth )
08:11:11 <nominolo_> MarcWeber: right needs outer { }
08:12:02 <Le-Chuck_ITA> Axman6: let me try :) Whenever I see "minimal model" I think of coalgebras. Now I am studying Kleene algebras and I see that there exists a minimisation procedure. So... is this related to some final coalgebra semantics?
08:12:23 <Le-Chuck_ITA> I see the initial algebra semantics as a semiring with an additional operator
08:12:35 <nominolo_> MarcWeber: well, I think that format needs a bit more thought.  In any case, configurations should have names, for easy reference.
08:13:42 <nominolo_> MarcWeber: also, having to cram everything into a line is not too human-friendly.  Better be a bit more lenient.
08:16:15 <MarcWeber> nominolo_: do you prefer yaml ?
08:16:45 <nominolo_> MarcWeber: I think it would be more human friendly, but it's another dependency, so I'm not sure
08:16:50 <MarcWeber> nominolo_: It's not perfect yet. I know. But scion isn't either. so I think it's fine for now. We can replace it later anyway.
08:17:02 <nominolo_> Yeah, keep json for now
08:36:09 <nominolo_> MarcWeber: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7540#a7540
08:36:34 <d4> oh yes, what a great morning! I see in e-mail I have a Business Proposal from MR SONG LILE
08:36:55 <Le-Chuck_ITA> d4: you too, so we are competing!
08:37:33 <mike-burns> When I type `fst3' into Hayoo I see 10 identical results. So I don't have to redefine this simple function again, which do you recommend I use?
08:37:35 <d4> Le-Chuck_ITA: don't even think about plying me for info
08:38:03 <MarcWeber> nominolo_  Thanks!
08:38:06 <Le-Chuck_ITA> MR LILE prefers me to you, that's a matter of fact, so I'll win
08:38:15 <d4> Good Day, Greetings of the day to you,although you may be skeptical
08:39:09 <d4> nevertheless I have a business proposition
08:39:24 <nominolo_> great, now people put their initials into module names ... *sigh*
08:39:55 <Le-Chuck_ITA> d4: I had dinner with MR LILE and his wife
08:40:09 <mike-burns> Initials in module names? That's awful.
08:40:42 <nominolo_> mike-burns: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utility-ht
08:40:59 <d4> I'll take MR LILE's children to the local theme parks once we have a common understanding and mutual cooperation in the execution of the modalities
08:42:12 <d4> mutual cooperation in the execution of the modalities ... sounds like Haskell after all
08:42:56 <Le-Chuck_ITA> a specification language for haskell maybe :)
08:42:58 <Peaker> nominolo_: where?
08:43:08 <nominolo_> Peaker: see link above
08:45:43 <mike-burns> nominolo_: Also Yet Another Utility Package. Those should be patches instead!
08:45:58 <Peaker> nominolo_: that's the worst package name, ever
08:46:04 <nominolo_> MarcWeber: basically, I added more flexibility in how to pass the extra args
08:46:56 <nominolo_> yeah, but the library submission process is a bit tedious, so for such small utilities it may not seem worth the trouble
08:47:15 <nominolo_> OTOH, now everyone has a fst3 definition
08:47:32 <mike-burns> I just grabbed MissingH for my fst3.
08:47:36 <mae> how can i duplicate a handle?
08:48:17 <nominolo_> mae: System.Posix.IO.  	 dup
08:48:31 <nominolo_> http://hackage.haskell.org/packages/archive/unix/2.3.2.0/doc/html/System-Posix-IO.html#v:dup
08:49:02 <nominolo_> and the related handleToFd/fdToHandle
08:49:18 <mauke> warning: handleToFd destroys the handle
08:50:01 <nominolo_> oh noes
08:51:33 <mike-burns> I just typed 'thd3' and remembered something I wondered when I first learned Haskell: why didn't we call the functions `first' and `second'?
08:51:48 <Peaker> thd3?
08:51:50 <mauke> too long
08:52:06 <Deewiant> Peaker: (a,b,c) -> c
08:52:17 <mike-burns> Peaker: By analogy from fst3 and snd3.
08:52:34 <Peaker> N-tuples are one of Haskell's major design mistakes IMO
08:52:39 <Deewiant> IMO it should be called trd3
08:53:04 <mauke> preflex: 6st 1 2 3
08:53:04 <preflex>  1st 2rd 3th
08:53:12 <mauke> fst srd tth
08:53:16 <Deewiant> >_<
08:53:17 <mike-burns> IMO it should be called `third3'. Or `thirdFrom3Tuple', as a reminder that it's a hack.
08:54:00 <vav> mauke: hehe
08:54:51 <conal> anyone here use GLUT on os x?
08:55:02 <conal> (in haskell)
08:55:02 <Peaker> just avoid N-tuples and use 2-tuples inside 2-tuples? or some similar data-type?
08:55:07 <Peaker> yairchu: you there?
08:55:15 <yairchu> yep
08:55:21 <yairchu> conal: it works
08:55:39 <conal> yairchu: do you run glut programs from within ghci?
08:55:55 <yairchu> conal: no. and runhaskell doesn't work as well
08:56:06 <yairchu> but ghc --make or cabal build both work
08:56:11 <yairchu> for usage example cabal install DefendTheKing
08:56:14 <conal> yairchu: runhaskell doesn't work in osx?
08:56:22 <yairchu> it does. but not with glut
08:56:31 <conal> oh, crap.
08:57:09 <yairchu> you tested using runhaskell? :/
08:57:30 <conal> yairchu: i test & experiment within ghci sessions.
08:57:40 <conal> works fine on linux. even windows, i think
08:57:58 <shapr> Good morning #haskell!
08:58:01 <soupdragon> conal, ghc --make  is fine for glut
08:58:08 <soupdragon> hey shapr
08:58:13 <byorgey> good morning shapr!
08:58:13 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
08:58:16 <yairchu> shapr: good afternoon
08:58:36 <conal> soupdragon: yeah.  works fine for me also.  except the loss of quick experimentation.
08:58:54 <byorgey> @seen ivanm
08:58:54 <lambdabot> I saw ivanm leaving #gentoo-haskell, #bfpg, #xmonad and #haskell 53m 50s ago, and .
08:59:47 <conal> is there more known about glut failing under ghci in os x?
09:00:23 <conal> and do any of the glut alternatives work with ghci (in osx)?
09:00:27 <mae> nominolo: thanks
09:00:52 <yairchu> GLFW fails entirely unless you run mkbndl after build
09:00:57 <Saizan_> maybe it's a matter of passing the right flags to ghci?
09:01:24 <shapr> Good morning soupdragon, byorgey, yairchu!
09:01:24 <yairchu> but glut is good because it's part of the haskell platform..
09:01:27 * shapr boings cheerfully
09:02:11 <conal> i'd like to find out whether glut+ghci+osx is fixable or not.
09:02:44 <conal> a repl is worth a lot to me
09:02:58 <steinrs> is there a practical difference between currying and partial application in a language like Haskell where all functions take only one arg anyway?
09:03:37 <conal> i think ghci is --threaded.  maybe relevant?
09:04:09 <Saizan_> ghci uses the -threaded runtime, yeah, you could try ghc --make -threaded to see if that works
09:04:22 <conal> Saizan_: that's what i'm thinking also.
09:04:25 <Saizan_> steinrs: well, they are different concepts anyway
09:04:40 <steinrs> i'm aware of that
09:04:42 <yairchu> ok. I just did ":l defend.hs"; "main". my window shows up without a proper frame and it doesn't respond to events
09:04:47 <byorgey> @tell ivanm you should be able to generate graphs in a future version of the library, I just have to get around to implementing cartesian and hadamard products first.  I'm not sure about latin squares, I'd have to think about how to express those in the species algebra.
09:04:47 <lambdabot> Consider it noted.
09:04:49 <steinrs> but does it matter
09:05:07 <Saizan_> matter for what?
09:05:27 <yairchu> ghc --make -threaded works fine for me
09:07:45 <Saizan_> at a first approximation it does matter for ghc if you write a function like "foo x y = .." or "foo x = \y -> .." but inlining and other optimization can change that, not sure if that's what you're asking though
09:09:00 <Saizan_> http://www.haskell.org/haskellwiki/GHC:FAQ#When_can_I_rely_on_full_laziness.3F
09:10:42 <yairchu> conal: ghci -threaded acts the same as ghci
09:11:35 <Saizan_> the -threaded flag doesn't matter for ghci
09:12:03 <conal> yairchu: i think ghci is threaded by default.  i wonder if there's a flag to change to non-threaded.
09:12:29 <conal> yairchu: did you also pass in runtime threading flags?
09:12:39 <yairchu> no
09:12:54 <yairchu> I'll try that
09:12:58 <yairchu> +RTS what?
09:13:03 <conal> i forget
09:13:12 <conal> maybe N2
09:14:15 <yairchu> yes. it works fine
09:14:43 <conal> yairchu: thanks.
09:15:33 <yairchu> thank you for FRP :)
09:15:45 <conal> :) !
09:16:23 <mun> hi
09:16:41 <mun> for the code at http://pastebin.com/m11a43686 should runParser in line 7 be a function?
09:17:10 <conal> just sent a note to the hopengl list
09:17:54 <Cale> mun: that is strangely indented...
09:18:51 <mun> Cale: sorry i just pasted the code.
09:19:00 <Cale> http://pastebin.com/mf8d0eab
09:19:02 <mun> the code i'm trying to understand.
09:19:16 <Cale> runParser is indeed a function
09:19:30 <mun> Cale: thanks
09:19:54 <conal> Beelsebob: ping
09:20:13 <Beelsebob> pong
09:20:56 <conal> Beelsebob: you do 3d programming in haskell on the mac.  have you run into this problem with ghci + glut + osx?
09:21:11 <Beelsebob> which problem's that?
09:21:17 <conal> Beelsebob: missing title bar and other random breakage
09:21:23 <Beelsebob> ohhhhh
09:21:30 <conal> yeah?
09:21:30 <Beelsebob> yes, that's because glut expects to be in a .app bundle
09:21:47 <Beelsebob> I wrote mkbndl specifically because of that
09:21:53 <Beelsebob> unfortunately, something appears non-working about that atm
09:21:55 <Beelsebob> not sure what
09:21:57 <badsheepy> glut hasno title bar etc on my ubuntu if i turnon the fancy effects thing
09:22:36 <conal> Beelsebob: what's your mkbndl, and did it work with ghci?
09:22:47 <Beelsebob> it doesn't work with ghci, no
09:22:59 <conal> Beelsebob: :(
09:23:13 <Beelsebob> I don't remember getting glut going with ghci ever
09:23:15 <Beelsebob> :9
09:23:15 <Beelsebob> :(
09:23:27 <conal> rats.
09:23:45 <conal> Beelsebob: what about alternatives to glut?  any work with osx & ghci?
09:23:49 <Beelsebob> sorry, I should have given you a heads up on that -- I rarely use ghci though, so it didn't pop into my head
09:24:01 <Beelsebob> uh, you might try using glfw, no idea if that'll work
09:24:20 <Beelsebob> I suspect all OpenGL stuff is expected to be called from within a .app
09:24:58 <conal> Beelsebob: what might a solution look like that would get ghci, opengl, and osx working together?
09:25:31 <conal> Beelsebob: including tweeking something in ghci and/or opengl
09:25:35 <Beelsebob> it's possible that it might involve making a special ghci app that displays a terminal for you
09:25:43 <Beelsebob> but I have no idea if that would work
09:25:46 <vav> conal: wonder if short of a real solution you could use hint to get more flexibility from compiled test programs.
09:26:09 <conal> vav: hey -- nice idea.  thanks.
09:26:11 <Beelsebob> conal: fwiw, bugreport.apple.com -- make sure they know it's a problem, it ocasionally works
09:26:31 <conal> Beelsebob: thx.  do you think apple would care?
09:26:43 <Beelsebob> they do tend to care about bug reports, yes
09:26:51 <Beelsebob> sometimes you get back "sorry, it works the way we want it to" though
09:26:57 <conal> k
09:26:57 <Beelsebob> but you do usually get back something
09:27:49 <conal> at this point, i might be too ignorant of the mac ecosystem to articulate a bug report.
09:28:36 <Beelsebob> "GLUT does not work inside an interpretter that's not a .app bundle" with steps to reproduce including download an interpretter like ghci perhaps?
09:29:45 <conal> Beelsebob: thx.  and that description in terms of an interpreter leads me to wonder about other languages, like scheme and python
09:30:12 <jmcarthur> i bet it works for python, but i have no particular reason to think so
09:30:35 <conal> jmcarthur: i bet it does also, because python is popular and so is 3d.
09:30:42 <jmcarthur> conal: btw, it does not work for GLFW or SDL, either
09:30:50 <soupdragon> glut doesn't need .app
09:30:56 <conal> jmcarthur: glad to know.
09:31:34 <Beelsebob> conal: quite
09:32:43 <jmcarthur> conal: maybe you could look into writing some bindings that can initialize the cocoa stuff within haskell or something. i don't know how feasible that is, but i'm pretty sure the reason it doesn't work in ghci is due to the absence of some cocoa thing
09:32:57 <Beelsebob> jmcarthur: it's entirely feasable
09:32:59 <Beelsebob> HoC does that
09:33:06 <Beelsebob> but it's very hard to compile
09:33:12 <jmcarthur> Beelsebob: it does that *within* haskell, or does it write a main wrapper?
09:33:18 <Beelsebob> but I don't think it's to do with cocoa
09:33:22 <jmcarthur> Beelsebob: i wrote a wrapper for the sdl stuff
09:33:32 <Beelsebob> in that glut can work from carbon code
09:33:44 <Beelsebob> as long as it's in a .app wrapper
09:33:45 <jmcarthur> ah hmm
09:34:01 <Beelsebob> in fact, cocoa has a much easier way of setting up GL windows
09:34:08 <Beelsebob> with a much more flexible event handling mechanism
09:34:16 <jmcarthur> yeah
09:34:23 <jmcarthur> too bad it isn't cross platform
09:34:29 <Beelsebob> yeh
09:34:34 <Beelsebob> well, cocotron is trying to fix that
09:35:02 <jmcarthur> is cocotron a new gnustep?
09:35:07 * Beelsebob nods
09:35:10 <jmcarthur> nice
09:35:58 <jmcarthur> Beelsebob: awe, cocotron requires xcode :(
09:35:59 <conal> Beelsebob: vav suggested using hint to get some of the benefit of ghci .  do you think glut & hint would get along on os x?
09:36:15 * Beelsebob doesn't know what hint is
09:36:20 <conal> @hackage hint
09:36:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint
09:36:28 <mun> does anyone know why is the indentation here wrong? http://pastebin.com/mb1cce99
09:36:31 <conal> (a haskell interpreter)
09:36:46 <Beelsebob> oh cool
09:36:54 <Beelsebob> I would hope that will solve the problems
09:37:01 <Beelsebob> at least partially
09:37:12 <Igloo> mun: You're missing a "do" after the second "else"
09:37:13 <mauke> mun: try indenting 'then' and 'else' more than 'if'
09:37:18 <jmcarthur> conal: would be neat to just use that as a "in-game console" or whatever term would be appropriate for the application at hand
09:37:37 <Igloo> mun: Also, the "lift"s are more indented than the following statments
09:37:39 <conal> jmcarthur: yeah.
09:37:45 <jmcarthur> hit the magic debug keystrokes and you get a haskell prompt!
09:37:59 <LeoD> wow, i need to do that in my game
09:38:33 <Gargoose> hi, anyone there?
09:38:33 <conal> i don't yet know what an .app is (brand-new to mac) and where things break down with ghci.  could the problem be solved by wrapping up ghci itself as an .app?
09:38:51 <jmcarthur> conal: woah, that is definitely out of the box...
09:38:55 <jmcarthur> i have no idea
09:39:29 <Beelsebob> conal: a bundle is a folder that disguises itself as a file in OS X -- it contains usually a binary of some sort, and some other resources needed for the binary
09:39:29 <jmcarthur> isn't ghci just a shell script that runs ghc with particular arguments?
09:39:32 <Beelsebob> a .app is a bundle
09:39:35 <Gargoose> Hi all, I'm trying to use haskell to produce a list of prime numbers between two integers. Can I use a guard list comprehension with 2 conditions?
09:39:40 <Beelsebob> which specifically contains an application
09:39:54 <Beelsebob> it's plausable that you could create a ghci .app bundle
09:40:01 <Beelsebob> but I don't know if it would launch terminal or what
09:40:04 <mun> emacs's tab doesn't let me indent then more than if
09:40:04 <mun> should tab be used?
09:40:23 <gwern> Gargoose: I think you can
09:40:48 <Gargoose> how would I write that please? The book I'm using only shows examples with one conidion
09:40:59 <Gargoose> *condition
09:41:13 <mun> emacs's tab doesn't let me indent then more than if
09:41:14 <jmcarthur> [... | ..., ...]
09:41:15 <mun> should tab be used?
09:41:17 <Tigran> > [ (x,y) | x <- [1..5], y <- [1..5], x == 3, y == 2 ]
09:41:18 <lambdabot>   [(3,2)]
09:41:27 <jmcarthur> mun: i consider that a bug in haskell-mode
09:41:35 <jmcarthur> mun: just add some extra spaces to fix the indentation
09:41:38 <Gargoose> Thankyou
09:41:45 <gwern> > [x | y==0, isEven y, y <- [1..]] -- silly
09:41:46 <lambdabot>   Not in scope: `isEven'
09:41:57 <gwern> @hoogle even
09:41:57 <lambdabot> package event-list
09:41:58 <lambdabot> package codec-libevent
09:41:58 <lambdabot> package control-event
09:42:03 <gwern> @hoogle isEven
09:42:04 <lambdabot> No results found
09:42:09 <gwern> @hoogle isOdd
09:42:09 <lambdabot> No results found
09:42:10 <jmcarthur> :t even
09:42:13 <lambdabot> forall a. (Integral a) => a -> Bool
09:42:19 * gwern shrugs. I thought there were functions of those names...
09:42:20 <Gargoose> :D bye
09:42:32 <jmcarthur> > [x | y==0, even y, y <- [1..]]
09:42:33 <lambdabot>   []
09:42:57 <gwern> jmcarthur: probably need to change the x
09:43:08 <gwern> I never can remember the list comp syntax since I don't find it very clear
09:43:12 <jmcarthur> still wouldn't work
09:43:15 <jmcarthur> > [y | y==0, even y, y <- [1..]]
09:43:16 <lambdabot>   []
09:43:33 <mun> emacs's tab doesn't let me indent then more than if
09:43:34 <jmcarthur> the y==0 will never intersect with the y<-[1..]
09:43:35 <mun> should tab be used?
09:43:54 <nomeata> @seen dons
09:43:55 <lambdabot> dons is in #haskell-hacphi, #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 17h 25m 6s ago.
09:43:55 <gwern> mun: I always just added a space, iirc
09:43:57 <jmcarthur> <jmcarthur> mun: i consider that a bug in haskell-mode <jmcarthur> mun: just add some extra spaces to fix the indentation
09:43:58 <Beelsebob> conal: a nice way to find out what a .app is is to take anything in /Applications, right click and select "Show Package Contents"
09:44:44 <conal> Beelsebob: thx.  i'll poke around.
09:44:51 <mun> jmcarthur: but then everything after it will need to be space-indented rather than tab, right?
09:45:23 <conal> Beelsebob: i mostly like os x so far.
09:45:29 <Beelsebob> :)
09:46:22 <conal> Beelsebob: do you use firefox?
09:46:29 <Beelsebob> conal: not on OS X, no
09:46:39 <Beelsebob> I find it's slower than Safari, less acurate and integrates less well
09:47:10 <conal> oh.  glad to hear.  i didnt' give safari much of a try.
09:47:43 <Beelsebob> it misses some really nice stuff from OS X, like the intgrated spell checking that you get in nearly every app
09:47:55 <Beelsebob> being able to resize text input feilds
09:48:04 <Beelsebob> nice font rendering
09:48:26 <Beelsebob> and has a few behavioral oddities (though, I guess that's a trade off to anyone who's used to linux)
09:48:44 <mun> i've reindented the code, but i now get a parse error in pattern in line 18. does anyone know why? http://pastebin.com/m10aa2e8c
09:49:40 <Beelsebob> mun: well, you don't need the do on teh line before for a start
09:49:55 <Beelsebob> but on line 15, you're lacking an in
09:50:06 <Beelsebob> oh wait, that's a do block
09:50:11 <Beelsebob> it just doesn't look like one
09:50:58 <mun> Beelsebob: should line 14 be further indented?
09:51:11 <Beelsebob> mun: no, that's fine
09:51:23 <Beelsebob> mun: make very sure you have no tabs in the file
09:51:25 <Beelsebob> only spaces
09:51:38 <mun> ooh
09:51:49 <Beelsebob> the compiler will take any tab to be 8 spaces
09:51:54 <Beelsebob> which can get *very* confusing
09:52:09 <mun> Beelsebob: so indentations shouldn' be done with tab, even in emacs?
09:52:13 <chr1s> shapr: you suck bigtime
09:52:17 <Beelsebob> dunno what emacs does
09:52:29 <Beelsebob> my editor replaces all tabs with spaces
09:52:29 <chr1s> HASKELL SUCKS!!!!11one
09:52:40 <chr1s> I like LISP way more.
09:52:44 <mun> i see
09:52:55 <chr1s> typechecking is for people who can't code.
09:52:58 --- mode: ChanServ set +o shapr
09:53:03 <shapr> chr1s: :-P
09:53:03 <inimino> tab for indentation is evil in any language
09:53:13 <timonator> lisp does have amb, does haskell have something similar?
09:53:37 <shapr> chr1s: The downside is that someone  else might kick you :-P
09:53:38 <Beelsebob> timonator: what does amb do?
09:53:42 --- mode: shapr set -o shapr
09:54:25 <gwern> Beelsebob: ambiguous choice; it's a race condition based on which of the 2 arguments evaluates first
09:54:36 <Beelsebob> gwern: the same as conal's amb then :)
09:54:45 <gwern> Beelsebob: important to FRP, for some reason. conal and others've spent a ton of time on it
09:54:56 <Beelsebob> gwern: no, I meant in the case of LISP
09:54:56 <gwern> Beelsebob: well, it was... mccarthy? who first described amb in a lisp
09:54:57 <timonator> Beelsebob: it tries returning all arguments one at a time and if it runs out, it causes the previous amb to return the next argument
09:55:07 <kpreid> > liftM2 (*) [1,2,3] [1,10,100]
09:55:08 <lambdabot>   [1,10,100,2,20,200,3,30,300]
09:55:22 <Beelsebob> timonator: that sounds a lot like amb as defined by conal
09:55:28 <Beelsebob> except that that does them in parallel
09:55:31 <kpreid> The list monad is good enough, often
09:55:31 <timonator> maybe it is
09:55:38 <Beelsebob> (you're not guarenteed the order of choice)
09:55:41 <Baughn> List applicative. ;_;
09:55:52 <kpreid> It does have the 'retry' effect if you think about evaluating each list element until you find one you like
09:56:17 <kpreid> Baughn: I haven't learned these newfangled things.
09:56:23 <hackagebot> interpolatedstring-perl6 0.4 - QuasiQuoter for Perl6-style multi-line interpolated strings with "q", "qq" and "qc" support. (AudreyTang)
09:56:29 <timonator> how do i use it? say if i wanted to solve some combinatoric puzzle with logic
09:56:34 <Baughn> > liftA2 (*) [1..3] [1,10,100]
09:56:36 <lambdabot>   [1,10,100,2,20,200,3,30,300]
09:57:09 <Beelsebob> > [1..3] <^(*)^> [1,10,100]
09:57:11 <lambdabot>   [1,10,100,2,20,200,3,30,300]
09:57:44 <kpreid> timonator: just write monadic/applicative code
09:57:54 <LeoD> @type <^
09:57:58 <lambdabot> parse error on input `<^'
09:58:01 <Baughn> > (*) <$> [1,2,3] <*> [1,10,100]
09:58:02 <lambdabot>   [1,10,100,2,20,200,3,30,300]
09:58:03 <LeoD> @type (<^)
09:58:04 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
09:58:05 <Beelsebob> @type (<^)
09:58:06 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
09:58:20 <LeoD> i almost thought <^(*)^> was one operator
09:58:25 <mun> Beelsebob: should there be a do in line 20? http://pastebin.com/m10aa2e8c
09:58:31 <Beelsebob> that's the idea of it LeoD
09:58:36 <LeoD> :)
09:58:38 <Beelsebob> it's a lifted other perator
09:58:40 <Beelsebob> operator*
09:58:52 <Beelsebob> mun: yes
09:59:38 * kpreid thinks tricks like that are nasty because it might parse unexpectedly in the presence of other infixes
10:00:02 <mun> Beelsebob: i see. but the original looks like this: http://pastebin.com/m5cb0ec49 how come there's no do in line  21?
10:00:03 <Beelsebob> kpreid: depends how well you specify the fixity
10:00:23 <Beelsebob> mun: because the second line is not part of the same do block
10:00:32 <Beelsebob> it's part of the block specified in the if one scope up
10:00:55 <mun> Beelsebob: which second line?
10:01:10 <Beelsebob>  lift $ putIfVerbose opts 1 $ "Analyzing library " ++ http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:show ln
10:01:21 <Beelsebob> that's part of a scope higher up than in your source
10:01:41 <kpreid> timonator: here's an example of "try stuff and reject some": http://rosettacode.org/wiki/Amb#Haskell (I would avoid writing the 'amb' they do, but other than that it's pretty straightforward)
10:02:08 <mun> Beelsebob: i see. but how do you tell?
10:02:18 <Beelsebob> mun: the indentation level
10:02:20 <timonator> cool, thanks a lot!
10:02:30 <Beelsebob> it's indented the same as the line above
10:02:32 <Beelsebob> so it's in the same scope
10:02:34 <Beelsebob> "line" above
10:02:38 <mun> i see
10:02:39 <mun> thanks
10:03:09 <timonator> kpreid: so instead of amb i would write id?
10:03:27 <kpreid> no, don't write anything
10:03:29 <kpreid> x <- [...]
10:03:40 <Baughn> kpreid: Hum. That definition of amb is wrong, though
10:03:40 <timonator> oh
10:03:48 <Baughn> kpreid: Note the "nondeterministically" in the problem description
10:04:14 <gwern> if amb = id, I think you can tell
10:04:24 <kpreid> Baughn: different use of 'nondeterministically'
10:04:25 <hackagebot> press 0.1.1 - Text template library targeted at the web / HTML generation (BrandonBickford)
10:04:57 <gwern> you could pass it 'amb undefined 1' etc; the correct amb would spit out 1, but an implementation like 'amb a b = a' would fail
10:05:06 <timonator> kpreid: what would i write instead of "amb []"?
10:05:10 <kpreid> timonator: []
10:05:23 <timonator> hm, ok
10:06:00 <timonator> i suppose that question illustrates just how much i know about haskell
10:06:28 <gwern> @check \x -> x == id x
10:06:29 <lambdabot>   "OK, passed 500 tests."
10:06:49 <vav> timonator: http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes -- might be interesting too if I get what you're wanting to do
10:06:51 <kpreid> you could also write mzero if you're feeling general
10:07:07 <kpreid> (for lists, mzero = [])
10:07:25 <hackagebot> hack-contrib-press 0.1.1 - Hack helper that renders Press templates (BrandonBickford)
10:08:13 <Baughn> @check \a b -> a == b
10:08:14 <lambdabot>   "OK, passed 500 tests."
10:08:35 <kpreid> Wot?
10:08:47 <soupdragon> unit testing saves the day
10:08:48 <kpreid> Did it default to ()?
10:08:52 <Baughn> It defaults to (). So gwern's test isn't all that interesting..
10:09:14 <kpreid> clearly quickcheck needs to generate more than one type :-)
10:09:31 <Cale> timonator: maybe [[]]
10:09:31 <benmachine> @check \a -> a == ()
10:09:32 <lambdabot>   "OK, passed 500 tests."
10:09:36 <benmachine> >_>
10:09:50 <Cale> timonator: if that was meant to be a value which is unambiguously the empty list
10:09:50 <benmachine> everything is equal to ()
10:09:55 <kpreid> Cale: er, no.
10:09:56 <Baughn> benmachine: That one's predictable. There you /fixed/ the type by using (), so it would've done that regardless.
10:10:02 <Baughn> benmachine: The () type has only a single value
10:10:08 <benmachine> ah, true I guess
10:10:09 <Baughn> @check \a b -> (a::Int) == b
10:10:10 <lambdabot>   "Falsifiable, after 0 tests:\n0\n-1\n"
10:10:25 <kpreid> @check \a -> length a < 1000
10:10:26 <Cale> timonator: in the list monad,  return v = [v]  and  xs >>= f = concat (map f xs)
10:10:27 <lambdabot>   "OK, passed 500 tests."
10:10:29 <benmachine> how can it be falsifiable after 0 tests
10:10:42 <Baughn> Off by one error.
10:10:49 <Baughn> It only counts /passed/ tests, for some reason
10:10:49 <benmachine> I suppose so
10:10:53 <kpreid> benmachine: it did zero tests, and then it falsified it with one test :-)
10:11:00 <benmachine> kpreid: oh, true
10:11:04 <Cale> timonator: this more or less simulates nondeterminism where multiple results are just handled as lists of the results involved
10:11:08 <Baughn> Well, it still performed one test though
10:11:14 <benmachine> Falsifiable after 0 tests, with 1 test
10:11:32 <Cale> timonator: the lists being lazy, the possibilities are traversed in a depth-first matter.
10:11:50 <Cale> > [1,2,3] >>= \x -> [4,5] >>= \y -> return (x,y)
10:11:52 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
10:12:03 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
10:12:05 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
10:12:29 <Cale> manner*
10:13:07 <Cale> > do x <- [1..]; y <- [4,5]; return (x,y)
10:13:08 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5),(4,4),(4,5),(5,4),(5,5),(6,4),(6,5),(7...
10:13:20 <Cale> > do y <- [4,5]; x <- [1..]; return (x,y)
10:13:20 <pikhq> timonator: It can, of course, be used for other things, but it's most readable when simulating non-determinism. ;)
10:13:21 <lambdabot>   [(1,4),(2,4),(3,4),(4,4),(5,4),(6,4),(7,4),(8,4),(9,4),(10,4),(11,4),(12,4)...
10:13:29 <Beelsebob> > [1..] <^(,)^> [4,5]
10:13:31 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5),(4,4),(4,5),(5,4),(5,5),(6,4),(6,5),(7...
10:13:33 <Beelsebob> >>
10:13:40 <pikhq> Beelsebob: o.O
10:13:47 <pikhq> @src <^(,)^>
10:13:48 <lambdabot> Source not found. It can only be attributed to human error.
10:13:54 <Beelsebob> @src (<^)
10:13:54 <lambdabot> Source not found. There are some things that I just don't know.
10:14:03 <mike-burns> Is <^(,)^> called the demon operator?
10:14:03 <Beelsebob> it's in infixApplicative
10:14:06 <Beelsebob> no
10:14:06 <Cale> Beelsebob: Cute, but...
10:14:08 <pikhq> @src (<^(,)^>)
10:14:08 <lambdabot> Source not found. Maybe if you used more than just two fingers...
10:14:13 <Beelsebob> pikhq: it's 3 operators
10:14:15 <Beelsebob> (<^)
10:14:17 <Beelsebob> (,)
10:14:19 <Beelsebob> and (^>)
10:14:21 <pikhq> Okay.
10:14:25 <pikhq> That's just freakish.
10:14:28 <Beelsebob> hehe
10:14:33 * pikhq mutters at Applicative
10:14:37 <Beelsebob> not as freakish as the flying pig...
10:14:42 <Beelsebob> <^(++)^>
10:14:48 <Cale> The applicative operators can be confusing when abused.
10:15:23 <pikhq> Cale: I wasn't even aware of those applicative operators.
10:15:36 * Beelsebob doesn't find them at all confusing
10:15:43 <timonator> why is the monads chain (that is what it's called, right?) op defined as (>>=) :: Choice a -> (a -> Choice b) -> Choice b and not (>>=) :: Choice a -> (Choice a ...?
10:15:44 <Beelsebob> the only one is after all "apply"
10:15:50 <Beelsebob> which is something very natural for us
10:16:06 <pikhq> timonator: It's not defined as that.
10:16:14 <copumpkin> timonator: it's called bind
10:16:23 <Cale> timonator: you're a scheme user right?
10:16:34 <pikhq> timonator: It's defined as (>>=) :: (Monad m) => m a -> (a -> m b) => m b. ;)
10:17:00 * Cale has a hard time keeping track of what languages other people are familiar with ;)
10:17:01 <timonator> Cale: nope :-?
10:17:12 <Petrosian> pikhq: I think you meant (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
10:17:27 <pikhq> Petrosian: Yes, there was a typo.
10:17:36 <Cale> timonator: Okay, so basically, the reason that the function on the right of >>= takes a plain value is that the value passed to that function is the choice which was made
10:17:52 <Cale> timonator: and >>= itself tries all the possible choices
10:18:03 <pikhq> foo >>= bar -- is the same as do x <- foo; bar x
10:18:29 <Petrosian> foo >>= \x -> bar x
10:18:33 <Cale> I think the more relevant thing to say here is that  xs >>= f  is the same as  concat (map f xs)
10:19:08 <Cale> Or  [w | v <- xs; w <- f v], perhaps, if you're familiar with list comprehensions.
10:19:14 <pikhq> Petrosian: If the whole action is just "foo >>= bar", then it doesn't matter if a name gets bound to it. ;)
10:19:33 <Cale> (we're specifically talking about the list monad here)
10:19:56 <Petrosian> I was pointing out that it wasn't the same as what you'd written in the line comment
10:19:59 <pikhq> Cale: Oh; good to know.
10:20:04 <pikhq> Petrosian: Fair enough.
10:20:26 <Petrosian> @undo do { x <- foo ; bar x }
10:20:26 <lambdabot> foo >>= \ x -> bar x
10:23:56 <Cale> timonator: does that make any sense?
10:24:37 <timonator> sorry, i was on the phone for a sec
10:24:59 <Cale> timonator: Supposing that Choice was an abstract type, you would really not want >>= to be Choice a -> (Choice a -> Choice b) -> Choice b, since that would mean that you had no way to observe what was inside a Choice at all.
10:25:16 <Cale> (well, unless you had some other function available which did that)
10:25:28 <timonator> Cale: is the implementation of >>= any different from the prelude version?
10:25:48 <Cale> timonator: >>= is the Prelude bind in my discussion above
10:25:52 <timonator> well, apart from the choice type restriction
10:26:08 <Cale> well, I messed with its type there as you suggested
10:26:25 <Cale> >>= for lists is defined as (or equivalently to)  xs >>= f = concat (map f xs)
10:26:28 <vav> Cale: I think timonator is talking about tutorial http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes
10:26:37 <Cale> ah...
10:26:38 <timonator> ah, no, i meant the one on that site, yes
10:26:48 <Cale> er, I would have to read it, one sec
10:26:48 <Petrosian> timonator: At risk of causing more confusion here, you can think of the function (a -> Choice b) being passed in as being applied inside the `Choice a' passed as the first argument
10:27:47 <Cale> I kind of think that the way this tutorial is handling things is less clear than just using lists
10:27:49 <Petrosian> And at the risk of being accussed of being misleading, the resulting `Choice (Choice b)' is then flattened out into a simple `Choice b', the return type
10:27:49 <timonator> god, getting used to a new keyboard layout is quite the handycap
10:28:24 <tingi> how can we count the number of distinct substrings ? someone told me it has to do with suffix arrays.  i don't know why total - sum of LCP gives the answer ?
10:29:01 <timonator> oh i think now i have an idea how to understand this
10:29:12 <Cale> timonator: it's easier just to think about:
10:29:18 <Cale> (>>=) :: [a] -> (a -> [b]) -> [b]
10:29:50 <Cale> That is, replace each occurrence of Choice a with [a]
10:30:13 <timonator> the [] makes it backtrack - so to speak - by just returning an empty list that is added to the result set
10:31:03 <Cale> timonator: more or less -- the function on the right of >>= produces a list of results for each of the inputs in the list on the left
10:31:11 <desp> With -Wall, I'm getting the following warning:  "Warning: Imported from `TypeNat' but not used: type constructor or class `S'"  -- but I *am* using S
10:31:20 <Cale> if that list is empty, it's like you've skipped over that input
10:31:31 <desp> S is an empty data declaration, "data S a"
10:31:40 <desp> Might that confuse GHC?
10:31:45 <Cale> (or like you've backtracked and are trying a different one)
10:32:06 <Cale> desp: -Wall sucks
10:32:13 <timonator> ok - why does their guard function return () and not []?
10:32:13 <Cale> (unfortunately)
10:32:34 <Cale> desp: It warns about a lot of spurious things that you needn't worry about normally
10:32:34 <desp> Cale: is there anything you could recommend instead?
10:32:44 <Cale> desp: I just don't use -Wall at all.
10:32:54 <Cale> timonator: return x = [x]
10:33:16 <Cale> timonator: and  guard True = [()]; guard False = []
10:33:25 <copumpkin> @type (join .) . fmap
10:33:26 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
10:33:55 <timonator> hmm
10:33:56 <Cale> timonator: basically, if the guard condition is true, then you return a single unique result
10:34:31 <Cale> The rest of the computation will be a (constant) function which maps over that result, producing a list of results
10:34:43 <Cale> and then those will all get concatenated
10:34:45 <timonator> i don't really understand where return gets called
10:34:52 <Cale> well
10:34:59 <Cale> guard True = return (); guard False = []
10:35:07 <Cale> Is the same thing
10:35:29 <timonator> uh
10:35:43 <Cale> because
10:35:46 <Cale> return x = [x]
10:35:53 <Cale> for the list monad
10:36:08 <Cale> oh, and  mzero = []  for the list monad
10:36:22 <timonator> where do we tell ghc that we are using the list monad?
10:36:33 <Cale> By using a list somewhere.
10:36:46 <timonator> somewhere?
10:37:04 <Cale> Yes, type inference causes the type of >>= to get pinned down
10:37:14 <Cale> and the type of >>= determines its implementation
10:37:22 <timonator> ok
10:37:38 <Cale> Or, we can explicitly say in the type that we're using the list monad
10:37:51 <timonator> and >>= is what i get whenever i type myfnc = do ...?
10:37:58 <Cale> right...
10:38:03 <Cale> the translation is:
10:38:28 <Cale> do { x } = x  -- single statement do-block base case :)
10:38:44 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
10:38:51 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
10:39:10 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
10:39:11 <timonator> wait, >> ?
10:39:14 <Cale> ah
10:39:32 <benmachine> @src (>>)
10:39:32 <Cale> x >> y = x >>= (\k -> y)
10:39:32 <lambdabot> m >> k      = m >>= \_ -> k
10:39:56 <Cale> So basically, ignore the result of x, and do the same thing regardless
10:40:18 <Cale> in the list monad, it's a little uncommon, except after guards :)
10:40:43 <Cale> > do x <- [1,2,3]; y <- [4,5,6]; guard (x*y == 8); return (x,y)
10:40:44 <lambdabot>   [(2,4)]
10:40:53 <Cale> > [1,2,3] >>= \x -> do y <- [4,5,6]; guard (x*y == 8); return (x,y)
10:40:54 <lambdabot>   [(2,4)]
10:41:02 <Cale> > [1,2,3] >>= \x -> [4,5,6] >>= \y -> guard (x*y == 8); return (x,y)
10:41:04 <lambdabot>   <no location info>: parse error on input `;'
10:41:06 <Cale> > [1,2,3] >>= \x -> [4,5,6] >>= \y -> do guard (x*y == 8); return (x,y)
10:41:08 <lambdabot>   [(2,4)]
10:41:16 <Cale> > [1,2,3] >>= \x -> [4,5,6] >>= \y -> guard (x*y == 8) >> return (x,y)
10:41:18 <lambdabot>   [(2,4)]
10:41:40 <Cale> Let's look at >>
10:41:45 <Cale> > [1,2,3] >> [4,5]
10:41:46 <lambdabot>   [4,5,4,5,4,5]
10:41:51 --- mode: ChanServ set +o chr1s
10:41:54 <Cale> > [()] >> [4,5]
10:41:56 <lambdabot>   [4,5]
10:41:59 <Cale> > [] >> [4,5]
10:42:00 <lambdabot>   []
10:44:04 <timonator> i'm not entirely sure why those 2 last ones differ
10:44:33 <timonator> i thought the first value is ignored?
10:44:56 <hzap> > [(), ()] >> [4, 5]
10:44:57 <lambdabot>   [4,5,4,5]
10:45:04 <PaMuKi> good evening guys
10:45:46 <PaMuKi> 1:2:[]
10:45:49 <timonator> oh, so it ignores the value, not the amount
10:46:10 <Badger> oh that's interested
10:46:12 <Badger> er
10:46:14 <Badger> interesting
10:47:47 <Badger> > [(),()] >> [(),()] >> [1,2]
10:47:48 <lambdabot>   [1,2,1,2,1,2,1,2]
10:47:56 <Badger> > [(),(),()] >> [(),()] >> [1,2]
10:47:58 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2]
10:48:15 <Badger> @src >>
10:48:15 <lambdabot> m >> k      = m >>= \_ -> k
11:17:21 <copumpkin> I'd never heard this word to describe it: http://en.wikipedia.org/wiki/Tacit_programming
11:17:45 <dufflebunk> Anyone know why show is so fscking slow with Doubles?
11:18:10 <inimino> copumpkin: I just heard that term a couple days ago for the first time
11:18:25 <inimino> (also on IRC)
11:18:36 <gwern> dufflebunk: I think it's just a slow instance. if you want fast double serialization you're supposed to go to data.binary
11:18:37 <copumpkin> I was just browsing around lattice stuff on wikipedia
11:18:38 <copumpkin> and found that
11:18:49 <copumpkin> (through pointless topology)
11:19:45 <maxote> is there any new improvement of GHC about CPU or memory?
11:19:55 <copumpkin>  /amsg ?
11:22:28 <dufflebunk> gwern: I'll take a look at Data.Binary. It is a slow instance, 61% of the time is being taken running show on a CDouble.
11:24:50 <dufflebunk> Does DATa.Binary.encode actually create a normal human readable text representation, or is it still a binary representation?
11:25:37 <Saizan_> binary, in general
11:26:30 <pitekus_> I have a program where Data.Binary.encode is slower than show. Can that be right?
11:28:10 <Saizan_> i think that'd be considered a bug in the Binary instance
11:28:59 <Saizan_> maybe it's a problem of laziness? the Binary instance for lists is quite strict since it writes the length first
11:29:09 <pitekus_> It'd have to be Map or IntMap
11:29:26 <pitekus_> how likely is there a bug in such common containers...
11:29:26 <Saizan_> so for long lists you'd want to switch to a chunked format instead
11:29:54 <pitekus_> Saizan_: what is chunked format?
11:30:22 <Saizan_> well, you're not the first i've heard complaining about the performance of Binary's Map/IntMap serialization
11:30:57 <pitekus_> ah
11:31:00 <Saizan_> pitekus_: e.g. split the list in fixed size chunks and write those lazily
11:31:32 <Saizan_> so you don't have to force the whole list at once to determine the length
11:32:03 <pitekus_> Saizan_: is forcing the list what's costing some much?
11:32:06 <Saizan_> and you also don't have to check if there's more elements every one element
11:33:14 <Saizan_> pitekus_: depends on the length and the elements, it might use a lot more memory than necessary
11:34:17 <pitekus_> Saizan_: so i'd have to define a custom binary instance to change that?
11:35:10 <Saizan_> pitekus_: yeah, not necessarily an instance, but custom Get and Put actions
11:35:45 <Saizan_> pitekus_: however i've never experienced the problem in first person, but i think you can find what i'm talking about in haskell-cafe@ archives
11:36:15 <pitekus_> ok thanks
11:37:42 <Ke> so why is making main IO Int valid, but having no effect on the return value
11:38:18 <Ke> hmm
11:40:23 <eflister> could i get some help understanding typefamilies?  i've read the wiki page and thought i sort of understood, but can't get an example working with multiparamtypeclasses.
11:40:31 <Saizan_> Ke: you need to use System.Exit to deal with the return value
11:40:31 <eflister> here's my example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7545
11:40:49 <dufflebunk> gwern: Doesn't look like Data.Binary does what I need. I have a CDouble from a FFI and I want to print it to the screen. The only IO Binary has is encodeFile which takes a FilePath.
11:42:35 <eflister> the idea is to use an associated family to express that two arguments to a class method will be the same type, so it will be safe to provide a default implementaiton.
11:43:23 <eflister> i can at least get the associated type to compile, but can't get the method to see the instance.
11:44:11 <Saizan_> eflister: don't you mean data R r a :: * ?
11:44:35 <eflister> and i believe it should be possible to use an associated synonym, so i don't need an extra constructor all over the place.  but i can't get that version to compile (my attempt doesn't seem to convince the compiler that the two arguments will have the same type).
11:44:53 <hackagebot> haskell-src-exts 1.1.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
11:45:02 <eflister> Saizan_: it compiles as is, and doesn't with just *
11:48:33 <Saizan_> eflister: the real problem using type instead of data there is that since m3 doesn't mention the 'r' and 'a' parameters except as arguments of a type synonym, there would be no way to pick an instance when using it
11:49:05 <Saizan_> eflister: because type synonym families are not injuctive
11:50:09 <Saizan_> eflister: so you could have both type R2 X Y = Bool and type R2 X1 Y1 = Bool, and when using "m3 True True" you wouldn't know which instance to use
11:50:51 <Saizan_> eflister: with data families you don't have that problem, because each one has its own constructor
11:51:55 <Saizan_> eflister: m4 has the same problem, but only for 'a'
11:52:10 <Saizan_> eflister: because it mentions r as result
11:53:24 <Saizan_> eflister: this also relates to your problems in the definition of main
11:54:29 <eflister> Saizan_: the idea was to use R2 in m3's type signature to require the two parameter types to match.  is that what you mean by injective?  i'm trying to figure out how that relates.
11:55:36 <Saizan_> eflister: i'm saying that by R2 a b = R2 c d you can't conclude a = c /\ b = d
11:56:16 <Saizan_> and that means that you can't decide which instance to use when using m3 or m4
11:57:54 <eflister> Saizan_: yeah that's exactly what i was trying to do -- what's the preferred way to express this?
11:58:18 <Saizan_> eflister: data families work in this case
11:59:26 <eflister> Saizan_: yeah, that version compiles (except the main :).  how do i fix it, and is there any way to avoid having those RInt constructors all over the place?
11:59:48 <Saizan_> though you need "data R r a" so that both class parameters appear as indices for the data family
11:59:54 <Saizan_> that'll fix the main too
12:00:07 <MarcWeber> nominolo_: Another question: scion is using two logging system. Which one to keep ?
12:00:46 <nominolo_> MarcWeber: I know of HSlooger and what's the other?
12:03:13 <MarcWeber> nominolo_: message in Sessien/Type.hs used by backgroundTypeCheckFile
12:03:28 <MarcWeber> It's about those "Could not find file in module graph." messages
12:03:44 <nominolo_> ah, that's debug logging, mostly
12:04:14 <MarcWeber> nominolo_: hslogger as well.
12:04:14 <nominolo_> Honestly, I don't like HSlogger very much
12:04:21 <MarcWeber> And debug logging is important
12:04:37 <nominolo_> yes, but we shouldn't define new logging functions per file
12:04:46 <copumpkin> :t unsafeLaunchSubmarine
12:04:47 <lambdabot> Doc
12:04:48 <MarcWeber> nominolo_: Alll I want is beeing able to trace everything to a file. Wether I'm using hslogger or something else I don't mind.
12:04:59 <nominolo_> why trace everything to a file?
12:05:06 <copumpkin> > unsafeLaunchSubmarine
12:05:07 <lambdabot>   http://www.cnn.com/2009/WORLD/asiapcf/07/26/india.nuclear.submarine/index.h...
12:05:30 <MarcWeber> nominolo_: The idea is to add the module where a message originates automatically. That's why its convinient to define local hslogger functions. What's bad about that style ?
12:05:57 <MarcWeber> nominolo_: Because I'm running scion_server in background. I hit F4 which runs make && pkill -9 && restart
12:06:00 <nominolo_> MarcWeber: I had a strange error due to hslogger not dealing with the string the preprocessor used
12:06:13 <MarcWeber> So I don't see stdout by default.
12:06:27 <eflister> Saizan_: i pasted a revision, can't get it to compile, what am i missing?  (thx for helping btw!) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7545#a7546
12:06:31 <Gargoose> jmcarthur: Further to your earlier advice, I got the two conditions to work perfectly. Thanks again.
12:06:48 <nominolo_> MarcWeber: and I don't like these redefinitions of the logging functions in every file
12:06:48 <MarcWeber> I've seen that workaround commit telling that you've had problems. There is even a template haskell function to derive those functions now
12:07:06 <nominolo_> no, template haskell is even worse
12:07:22 <MarcWeber> nominolo_: How do you tell the logging function about its location ?
12:07:39 <MarcWeber> in the scion case it doesn't matter because we depend on ghc anyway
12:08:05 <nominolo_> there have been requests to don't hardcode this too much
12:08:53 <MarcWeber> nominolo_: Maybe we should depend on cpphs ? :-)
12:10:12 <MarcWeber> nominolo_: So shall I remove hslogger but add another logging target "file" ?
12:11:43 <nominolo_> MarcWeber: perhaps use a preprocessor macro
12:11:54 <nominolo_> not happy about that either, but well
12:12:17 <MarcWeber> nominolo_: But we agree that having two logging systems is worse than having one?
12:12:25 <nominolo_> yes
12:12:31 <nominolo_> just use hslogger
12:18:58 <eflister> Saizan_: still there?  :)
12:21:25 <gwern> 'LanguageKit has supported just-in-time (JIT) compiling for a while, but in my last commit I added support for just-too-late (JTL) compiling too. The idea behind JIT compilation is that you only generate the executable code just before it's called. With JTL compilation, we generate it afterwards.'
12:21:53 <Baughn> Um..
12:22:08 <gwern> (he goes on to explain how this is actually useful in a profiling kind of way)
12:22:13 <gwern> http://etoileos.com/news/archive/2009/07/23/2218/
12:23:19 <Baughn> That's interesting. Does it also switch to the JTL-compiled version while it's running the first time around?
12:23:30 <Baughn> Hm, guess it doesn't say.
12:23:52 <gwern> seems to imply that the switch only occurs the second time
12:24:11 <gwern> replacing the executable on the fly would probably be a bit difficult
12:24:33 <Baughn> You need that anyway if you're going to do things like dynamic optimization, though
12:25:18 <Saizan_> eflister: can you annotate it with the error?
12:26:50 <lysgaard> How would i go on to write a word to a bytestring, should be quite straight forward?
12:27:22 <eflister> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7545#a7547
12:27:37 <eflister> Saizan: does the code look like what you were suggesting?
12:27:54 <eflister> Saizan_: btw, how do i get those nice small hpaste urls instead of these ugly ones?  :)
12:28:25 <Saizan_> eflister: yes, except for "data R Int W = RInt W" you missed the W there
12:28:46 <Saizan_> you've "data R Int W = RInt" instead i mean
12:28:50 <eflister> Saizaon: but that doesn't match type *
12:28:55 <Baughn> lysgaard: Do you mean, alter an existing bytestring?
12:29:12 <Saizan_> eflister: * is a kind, and that definition does match that kind
12:29:26 <Baughn> lysgaard: ..perhaps I should ask why you want to. What algorithm are you implementing, exactly?
12:29:26 <dons> nomeata: very interesting!
12:29:33 <Saizan_> eflister: what you have inside the value doesn't matter for the kind, only which type parameters you take
12:29:42 <lysgaard> Baughn: I want "f  :: (Word160 -> ByteString)"
12:29:43 <dons> i was just thinking such a thiing, so that users can use their native packages in preference
12:30:03 <Baughn> lysgaard: Ah. Actually, that looks like a good match for Data.Binary.encode.
12:30:13 <Badger> @src encode
12:30:13 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:30:16 <lysgaard> Baughn: I'm sending a large hash digest over network
12:30:17 <Badger> Curses.
12:30:25 <Baughn> lysgaard: Yep, Data.Binary.encode is the way to go.
12:30:41 <eflister> Saizan_: yer right, that fixed it -- i swear i tried that and got told i was passing too many parameters to RInt!
12:30:45 <lysgaard> Baughn: Thanks =)
12:31:05 <Baughn> lysgaard: You can use encode to produce a bytestring, and if you happen to want to embed one value inside another, its builder monad makes that much more efficient than concatenating bytestrings would be. (Even lazy bytestrings, as they are)
12:31:15 <Baughn> lysgaard: Oh, that's the binary pacakge on hackage, btw
12:31:24 <lysgaard> Is it just me or is hayoo bad at type searches? like "[a] -> Bool"
12:31:57 <Saizan_> eflister: however maybe this whole class could be expressed more nicely with functional dependencies, do you know how those work?
12:32:21 <Badger> @hoogle [a] -> Bool
12:32:22 <lambdabot> Prelude null :: [a] -> Bool
12:32:22 <lambdabot> Data.List null :: [a] -> Bool
12:32:22 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
12:32:40 <Badger> lysgaard: who needs hayoo when you've got lambdabot? :P
12:33:07 <Baughn> Badger: Also, encode wouldn't have source; it's a typeclass method.
12:33:11 <lysgaard> Badger: Can it do typesearches?
12:33:21 <Badger> lysgaard: see above
12:33:23 <eflister> Saizan_: nope, from the type families wiki i got the impression that families are preferred to dependencies and are strictly more expressive.  but i'd be happy to hear about better ways to do this (i'm only on my 2nd week of haskell)
12:33:23 <soupdragon> who needs Badger when you got mushroom mushroom its a snake -_-
12:33:26 <Baughn> Wait. No, it isn't.
12:33:38 <Heffalump> eflister: they're also unfinished  :-(
12:33:40 <Badger> er
12:33:42 <Baughn> Badger: "encode = runPut . put" ;)
12:33:46 <Badger> @hoogle encode
12:33:46 <lambdabot> package Encode
12:33:46 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
12:33:46 <lambdabot> package bencode
12:34:05 <Badger> heh
12:34:08 <wolverian> is Yi actively developed? I was wondering if it was yet in the shape for me to write extensions for, but I don't think it has much documentation towards that, at least
12:34:17 <eflister> Saizan_: i am kind of surprised that haskell makes this problem this ugly -- i especially hate all those extra constructors!
12:34:18 <Baughn> *put* is the method, which makes considerably more sense.
12:34:31 <Badger> @hoogle put
12:34:31 <lambdabot> Control.Monad.State.Class put :: MonadState s m => s -> m ()
12:34:31 <lambdabot> Prelude putChar :: Char -> IO ()
12:34:31 <lambdabot> System.IO putChar :: Char -> IO ()
12:34:48 <Baughn> Badger: But hoogle is not going to find a function outside the standard library
12:35:25 <Badger> encode is hackage Data.Binary?
12:35:29 <Baughn> Yes
12:35:35 <Badger> ah
12:36:00 <Saizan_> eflister: it'd look like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7545#a7548
12:36:33 <Saizan_> eflister: well, maybe from an higher level there's a better way to express this whole thing, but it's not easy to tell from the mangled code :)
12:36:45 <soupdragon> yeah
12:36:56 <soupdragon> most times someone is asking how do I fix this mess
12:37:09 <lysgaard> Badger: How would i search for a function to make a lazy bytestring into a strict one?
12:37:12 <soupdragon> and there is no good answer
12:37:26 <Baughn> lysgaard: That's concat . unpack
12:37:31 <soupdragon> if you ask, what actually is it you want to do.. they forgot
12:37:39 <Baughn> lysgaard: unpack turns the lazy bytestring into a list of strict ones, concat.. concatenates them.
12:37:44 <Saizan_> eflister: however i've got to go, but you'll probably find someone else to help, or i'll be back tomorrow :)
12:37:54 <soupdragon> and all that matters is making some bizarre contraption work
12:37:56 <Baughn> lysgaard: But since you're sending them over the network /anyway/, there's really no need to do that. Just write the lazy ones to your handle.
12:38:27 <eflister> Saizan_: cool, thx a lot for the help!
12:38:31 <eflister> Saizan_+
12:38:41 <eflister> Saizan_ +
12:38:52 <eflister> damnit how is that supposed tow ork?
12:39:11 <eflister> Saizan_ ++
12:39:20 <EvilTerran> ?karma Saizan_
12:39:21 <lambdabot> Saizan_ has a karma of 4
12:39:28 <EvilTerran> ?karma Saizan
12:39:28 <lambdabot> Saizan has a karma of 6
12:39:32 <EvilTerran> Saizan++
12:39:58 <nomeata> dons: One might even include this information in the index as provided by hackage so that cabal install could inform the user about packages available via the distribution
12:40:00 <lysgaard> Baughn: There's another problem preventing using lazy. I'm usig bencode lib since i'm sending quite complex data over the network, and it prevents me from using lazy
12:40:04 <nomeata> i.e. before it installs a dependency
12:40:17 <dons> nomeata: yes, we definitely need a public cross-distribution map of packages
12:40:34 <dons> that will be the way to ensure the same standard for packaging across systems
12:40:45 <dons> nomeata: thanks for providing the patch. this looks very promising.
12:40:50 <Baughn> lysgaard: Oh, I see. BEncode actually fills the same niche as Binary; you could replace it with Binary if you like.
12:41:20 <nomeata> dons: The format is very simple so that other distros can easily provide the lists as well, and the code itself is layed out for multiple repositories to track
12:41:36 <nomeata> dons: who is maintaining the hackage scripts, btw?
12:41:53 <Baughn> lysgaard: IMO, Data.Binary has a much broader set of supported types, as well as better efficiency. The downside, of course, is that it doesn't actually implement bencoding.
12:42:26 <Baughn> lysgaard: ..but if you're stuffing a Word160 in there, you're already stepping outside of what bencode supports anyway.
12:42:30 * nomeata → dinner
12:42:54 <dons> nomeata: ross paterson
12:42:59 <dons> yes, the format looks good
12:43:06 <nomeata> dons: is he on IRC sometimes?
12:43:19 <lysgaard> Baughn: Yeah, but I'm trying to use bencode, sinc i need tu use a understandable protocoll
12:43:20 <dons> no. he's on the libraries@ list, and his email is on the hackage page
12:43:44 <Baughn> lysgaard: Understandable to whom?
12:43:56 <nomeata> dons: ok, so I can’t nag him easily :-). But I assume he’ll read the bug report.
12:45:43 <dons> yep. and i'll raise it too
12:46:05 <gwern> hoogle does those
12:46:07 <Baughn> lysgaard: The bencode library is just broken, though. You want to pass a 160-bit integer; the protocol can do that. You should ask the author to switch Int for Integer in the BInt implementation. :)
12:46:44 <gwern> as far as I am aware, hayoo is specialized to regular search engine name matching, while hoogle specializes in types and transformations
12:47:00 <lysgaard> Baughn: Coul i hack it to work?
12:47:32 <gwern> wolverian: yi is actively developed, yes
12:47:36 <Baughn> lysgaard: I don't see why not
12:47:47 <Baughn> (It's probably a pretty simple patch)
12:48:16 <EvilTerran> TacticalLongcat, ...
12:48:37 <TacticalLongcat> EvilTerran: you don't have nick changes hidden? :)
12:49:07 <dufflebunk> Anyone know if there's a faster implementation of Double -> String? Double's implementation of Show is super crazy slow.
12:49:21 <EvilTerran> TacticalLongcat, er, no. i'm glad, too, seeing as it's helped you bring some bonus surrealism into my evening :)
12:49:41 <TacticalLongcat> http://ninxmz.org/images/420.thrashbarg.net/raising_the_longcat_on_iwo_jima.jpg
12:49:52 <copumpkin> lol
12:49:55 <wolverian> gwern: thanks.
12:50:00 <wolverian> is there a yi channel?
12:50:09 * copumpkin isn't even sure what to think of TacticalLongcat
12:50:52 <copumpkin> @remember acticalLongcat
12:50:53 <lambdabot> Incorrect arguments to quote
12:51:31 <osfameron> is that Einstein's radio?
12:52:01 <gwern> wolverian: yes, but it's not too active
12:55:44 <hackagebot> elerea 1.0.0 - A minimalistic FRP library (GergelyPatai)
12:57:43 <yitz> @seen chris
12:57:44 <lambdabot> I haven't seen chris.
12:58:26 <yitz> @bots
12:58:26 <lambdabot> :)
12:58:27 <lunabot>  :)
12:58:36 <dons> dufflebunk: can you call sprintf ?
12:58:45 <hackagebot> jmacro 0.1.1 - QuasiQuotation library for programmatic generation of Javascript code. (GershomBazerman)
12:58:45 <hackagebot> elerea-examples 1.0.0 - Example applications for Elerea (GergelyPatai)
12:58:47 <yitz> @seen chr1s
12:58:47 <lambdabot> chr1s is in #haskell-hacphi, #haskell.dut and #haskell. I last heard chr1s speak 3h 5m 52s ago.
13:00:14 <conal> any gtk2hs users here?  i'm having a ./configure failure with --enable-opengl: "Another gtk2hs package that gtkglext depends on is not being built."
13:02:05 <dufflebunk> dons: from C? I may have to do that, but I'd rather not.
13:02:40 <dons> you need a textual representation?
13:02:54 <yitz> conal: Try to get configure to call cabal configure with --verbose=3
13:03:28 <dons> probably you'll end up having to rewrite that part of sprintf anyway
13:03:45 <dons> dufflebunk: oh, check the bytestring-show library
13:03:53 <dufflebunk> Yeah, I'm printing the double to the screen (actually a CDouble)
13:04:21 <dons> http://hackage.haskell.org/packages/archive/bytestring-show/0.3.2/doc/html/Text-Show-ByteString.html
13:04:28 <dons> go via bytestrings, anyway
13:04:39 <conal> yitz: sadly, gtk2hs isn't a cabal project
13:04:46 <yitz> oh right
13:05:02 <dufflebunk> Thanks, I'll give that a try.
13:06:36 <yitz> conal: but still, there's got to be some way to get configure to tell you more about exactly what's missing
13:07:31 <lysgaard> Baughn: Yay! I made it. Got it hacked =)
13:07:38 <conal> yitz: i hope so.
13:07:57 <conal> does anyone have lhs2tex working on os x?
13:08:10 <conal> cabal install lhs2tex fails for me
13:08:32 <Baughn> lysgaard: You never did mention what's on the other end, though
13:08:36 <jmcarthur> i did back in the day, but it's been quite a while
13:08:43 <yitz> conal: batting 1000 today I see
13:08:51 <desp> Can someone tell me why are these type family instances conflicting?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7551
13:09:09 <conal> yitz: yeah :(
13:09:29 <jmcarthur> i don't recall having problems with lhs2tex on os x in the past, although i doubt that information is useful
13:09:39 <conal> maybe my mactex installation failed silently.
13:10:05 <sjanssen> desp: (Foo b) unifies with b
13:10:10 <brad_larsen> I have a question about defining instances for GADTs.
13:10:11 <brad_larsen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7553#a7553
13:10:28 <brad_larsen> How can one define an Eq instance for that GADT?
13:10:29 <desp> sjanssen: but, but, but I thought type families were supposed to be functions on types.
13:10:43 <sjanssen> desp: with restrictions
13:10:46 <desp> :(
13:10:58 <sjanssen> desp: they're open world, so there can't be overlapping patterns
13:11:40 <desp> sjanssen: so is there a way to say -- "this instance is for Foo b"; "this instance is for everything else"?
13:12:02 <gwern> conal: well, gtk2hs is a cabalized project, it just can't be installed with cabal...
13:12:03 <sjanssen> desp: I'm not familiar with such a thing
13:12:27 <lysgaard> Baughn: I'm trying to make a kademila network. It's a DHT p2p protocoll. Quite cool. I wan't it to be as easy to program clientl for it as possible, therefore i want to use a light weigth, simple protocoll.
13:12:32 <desp> sjanssen: do you see a reason why this should be disallowed?  I don't see how the open world would pose a problem here.
13:13:14 <conal> gwern: i see no .cabal file in gtk2hs-0.10.1
13:13:27 <gwern> conal: it's generated at install time
13:13:32 <TacticalLongcat> is has some subdirs with .cabal files
13:13:37 <conal> gwern: oh.  by ./configure?
13:13:49 <gwern> interrupt make, and poke around; lots of cabal files and cpp directives
13:13:53 <TacticalLongcat> but apparently the ultimate control is by make, not cabal
13:14:02 <Baughn> lysgaard: I'd still go with Data.Binary, then, if you aren't talking to any actual existing clients.
13:14:30 <lysgaard> Baughn: Well, maybe you're rigth
13:14:31 <Baughn> lysgaard: The difference in bandwidth use can be quite dramatic
13:14:39 <Baughn> lysgaard: And you can always switch it out later if you want to
13:14:48 <lysgaard> Baughn: True
13:15:45 <Baughn> lysgaard: One gotcha: Data.Binary.decode is a lazy function; it'll throw parse errors somewhere else in your code if you're getting bad data. This is not a problem for academic networks, but if you want it to actually be used, you should use the strict variant - binary-strict.
13:16:02 <lysgaard> Baughn: But i still want to have a good protocoll. How. I need to send (Map String a)
13:16:04 <Baughn> lysgaard: (IIRC it lacks the encode/decode function definitions, but those are really simple and can just be copied over)
13:16:27 <gwern> Baughn: you mean, the obsolete unmaintained binary-strict package?
13:16:32 <Baughn> gwern: Oh dear
13:16:42 <Baughn> Obsolete? Obsoleted by what?
13:17:16 <gwern> no, just obsolete. it's a partial conversion of a old binary release, iirc
13:17:27 <yitz> desp: that's a general restriction of the Haskell 98 class system. You have to start fuzzifying with stuff like XOverlappingInstances to get around it. Most people don't like doing that.
13:17:29 <Baughn> It can't be obsolete if there isn't an alternative. ;_;
13:17:55 <Baughn> lysgaard: I was going to say, Data.Binary already has an instance for Maps. All you need to do is call encode on it.
13:17:56 * gwern thinks things can be obsolete without alternatives
13:18:16 <Baughn> We really, /really/ need better organization of hackage, too
13:18:22 * conal too.  a space opens up for a new thing to be born.
13:18:23 <Baughn> Someone should make an SoC proposal for that
13:18:38 <gwern> Baughn: how would you better organize it?
13:18:43 <lysgaard> Baughn: You kidding, nice =)
13:19:02 <sjanssen> desp: the "b" instance might be in one module, while the "Foo b" instance is in another
13:19:31 <Baughn> gwern: Lots of ways. By popularity, by number of packages depending on it, by an explicit rating, by time since last use..
13:19:34 <sjanssen> desp: code might use the "b" instance with no knowledge of the "Foo b" instance
13:20:21 <Baughn> gwern: With the ability to sort by any one axis, and hide packages along another
13:20:34 <yitz> Baughn: it would be nice if someone wrote up some guidelines for the tags, too
13:20:44 <gwern> hm. call me crazy but those might already be in the new hackage server
13:20:45 <Baughn> And, of course, an explicit "this package is obsolete" tag
13:20:59 <Baughn> gwern: Then we need a better interface to it. :P
13:21:15 <gwern> yitz: guidelines? man, next you'll be demanding that tags not form a directed graph but a tree
13:21:22 <gwern> don't harsh our groove man
13:21:54 <yitz> gwern: they form a directed graph?
13:22:21 <rovar> a balanced tree, no less
13:22:35 <gwern> sure; each package is a point, which links to a number of tags
13:22:42 <rovar> That would be moderately humorous.
13:22:49 <Rotaerk> hmm, I'm coding in F# right now... The way I've been coding, every module is self-contained, and dependencies are either abstracted or setup as a project reference
13:22:52 <gwern> but no tag links to package points, or packages to packages
13:23:05 <Rotaerk> I can't think of any reason NOT to give each module its own project/assembly
13:23:14 <Rotaerk> i.e. why would I ever group more than one module together
13:24:39 <dufflebunk> dons: Is this the right usage: printDouble a = Data.ByteString.Lazy.putStr $ Data.Binary.Put.runPut $ Text.Show.ByteString.showpFFloat (Just 7) a  ?
13:25:38 <BMeph> They invented the term "bit-rotted" just for SW that's obsolete without being obsolesced
13:25:51 <dons> dufflebunk: what's the type of showpFFloat?
13:25:53 <dons> it should be in the Put monad
13:26:12 <dufflebunk> showpFFloat :: RealFloat a => Maybe Int -> a -> Put
13:26:17 <dons> looks good
13:26:30 <dons> you'll want to common up many showp's inside a single runPut for performance
13:26:36 <dons> serialise the whole thing from one runPut
13:27:13 <dufflebunk> Using that ends up slower than just putStr (show a).
13:27:34 <dufflebunk> But I'll see what happens if I convert all the numbers in one Put
13:27:53 <dons> you should ideally have only one putStr and one runPut for the entire transaction
13:30:28 <dons> i'm not sure the performance of bytestring-show though (maybe it is serialising via show ?)
13:30:29 <rovar> dufflebunk,  what is your intention? To serialize a specific text representation of a float?  If so, then I'm not sure that the Data.Binary is necessary at all
13:30:32 <dons> talk to dolio
13:30:44 <rovar> or the put monad
13:32:00 <dufflebunk> rovar: yeah, just dumping the human readable representation of a CDouble to the screen. Show is super slow... taking up about 60% of the time.
13:32:12 <rovar> if it is, you should make a put/get instance of your float for your protocol. Then this whole process is implicit with put/get MyFloat
13:32:57 <rovar> ah.. i wonder what the float to string algo looks like.
13:35:00 <dufflebunk> rovar: I think it's done by the formatRealFloat function in Numeric
13:42:37 <lysgaard> Baughn: You where right. Binary _wastly_ simplifies my code. As you said, I can always implement a language agnostic protocol later ;)
13:48:03 <brad_larsen> I'm having trouble defining instances for GADTs.  Can anyone enlighten me?
13:48:06 <brad_larsen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7553#a7553
13:49:47 <sjanssen> brad_larsen: I think the Num a context might be introducing a type variable that shadows the other
13:50:07 <sjanssen> brad_larsen: so the types in the two Plus constructors might not be the same
13:50:45 <brad_larsen> sjanssen: even if I remove that I get the those errors
13:50:54 <brad_larsen> sjanssen: the Num context
13:51:46 <sjanssen> brad_larsen: oh, the IsEq pattern is an issue as well
13:52:34 <brad_larsen> sjanssen: yes, if i comment that line out, the instance is accepted.  but then it's not the instance I want.
13:52:38 <sjanssen> brad_larsen: there the types in the two IsEq constructors can definitely be different
13:54:15 <brad_larsen> sjanssen: two IsEq constructors?  isn't it just a single IsEq constructor, with two args?
13:55:01 <sjanssen> brad_larsen: I mean the two values on either side of (==) in "  IsEq e1 e2 == IsEq e3 e4 = e1 == e3 && e2 == e4
13:56:00 <sjanssen> brad_larsen: e1 and e3 are not necessarily the same type
13:56:15 <maxote> is there anyone who understand the procedure to generate propositional logic models from first order predicate logic?
13:57:25 <brad_larsen> sjanssen: how does that work?  (==) has type Eq a => a -> a -> Bool, so (==) for (Exp a) should have type (Exp a -> Exp a -> Bool), no?
13:58:10 <brad_larsen> i'm not understanding gadts, i guess
13:58:22 <soupdragon> what is there to not understant
13:58:24 <sjanssen> brad_larsen: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7553#a7554
13:58:37 <mun> hi
13:59:16 <sjanssen> brad_larsen: by the way, I was wrong about Plus being a problem earlier, but right about IsEq
13:59:23 <mun> i'm looking at some code http://pastebin.com/m4acb6bd4 how come 'in' doesn't come after 'let' in line 5?
13:59:54 <sjanssen> brad_larsen: so the GADT in my paste is equivalent to yours, but more clearly shows that you're introducing a new type variable in IsEq
14:00:27 <jmcarthur> mun: 'let' in a line of do notation does not require 'in'
14:00:28 <soupdragon> mun that is so complicated
14:00:51 <sjanssen> mun: do syntax has a shortcut for let: "do let x = y; foo" is the same as "let x = y in do foo"
14:01:13 <mun> i see
14:01:14 <mun> thanks
14:04:30 <brad_larsen> sjanssen: so the 'a' i had before, appearing in IsEq, was different from the 'a' introduced in the data definition.  that makes sense.
14:04:55 <brad_larsen> sjanssen: so is there any way to write an instance for such a GADT?
14:05:21 <sjanssen> brad_larsen: I don't see a way to do it as written
14:06:07 <soupdragon> IsEq needs Eq on b
14:07:48 <sjanssen> soupdragon: won't help
14:08:33 <brad_larsen> any suggestions on changes that will allow instances to be written?
14:08:35 <soupdragon> oh yeah, that's true
14:08:54 <sjanssen> brad_larsen: don't use a GADT?
14:09:04 <brad_larsen> i want a gadt for simple expressions
14:09:23 <sjanssen> is it even very useful to compare expressions for equality?
14:09:24 <brad_larsen> for type-safe eval
14:09:35 <brad_larsen> well, the same issue pops up trying to write a show instance
14:09:51 <soupdragon> brad_larsen: what is the bigger picture?
14:10:03 <soupdragon> brad_larsen: like what is the full language and what is it used for?
14:10:35 <brad_larsen> embedded dsl for an array mini-language, vaguely like fortran 90 array expressions
14:11:02 <sjanssen> brad_larsen: oh, a Show instance shouldn't be so hard
14:11:15 <brad_larsen> i was hoping to use gadts for improved type safety
14:11:24 <sjanssen> brad_larsen: that will just require adding Show contexts on your type variables in the data decl
14:11:36 <brad_larsen> so that type-incorrect expressions in the edsl will be rejected by ghc
14:11:39 <soupdragon> brad_larsen, you can use GADTs
14:12:08 <soupdragon> brad_larsen, do you have a desc. of the language?
14:12:51 <brad_larsen> not written down properly.  still prototyping.  But:
14:13:04 <brad_larsen> there are scalar literals, and 1d array literals
14:13:14 <brad_larsen> variables for both scalars and arrays
14:13:22 <brad_larsen> array slices
14:13:47 <soupdragon> variables are part of the DSL or would you be able to use haskell variables?
14:14:15 <brad_larsen> some primitive operatiosn on array types, e.g., mapArray which maps a function to each element in an array
14:14:49 <brad_larsen> variables as part of the DSL
14:15:10 <soupdragon> so do yuo have lambda in the language?
14:15:24 <brad_larsen> although i'd like the embedding to be such that haskell lambdas can be used to construct functions in the dsl
14:15:36 <brad_larsen> of a sort.  hang on
14:16:23 <brad_larsen> ``GPU Kernels as Data-Parallel Array Computations in Haskell'' is somewhat similar to what I'm thinking
14:16:25 <brad_larsen> http://www.cse.unsw.edu.au/~chak/papers/gpugen.pdf
14:17:06 <brad_larsen> but rather than doing on-line compilation and linking into a haskell program, I want to do offline compilation of an array dsl to optimized CUDA
14:17:14 <brad_larsen> generate a bunch of CUDA procedures
14:17:27 <brad_larsen> which would then be used in a larger C++ aplication
14:18:08 <soupdragon> ah you can start making a CUDA GADT
14:18:34 <brad_larsen> yes, i've had some false starts.
14:18:53 <brad_larsen> i'm new at the edsl thing.  :-)
14:19:21 <brad_larsen> i could come up with something that works, sort of, but would have clunky syntax, and would have potential for programming errors
14:19:32 <brad_larsen> e.g., use of unbound variables in the dsl
14:19:59 <brad_larsen> hence, i'd like to make the embedding as natural as possible
14:20:17 <brad_larsen> using syntax overloading, e.g., the Num typeclass
14:20:35 <brad_larsen> and doing some type family magic or other magic to be able to use Haskell lambdas for lambdas in the dsl
14:21:11 <brad_larsen> i have made some gadt attempts, but don't get far, then want to be able to show expressions in the dsl I'm designing
14:21:25 <brad_larsen> but then run into these problems for defining instances for gadts
14:22:32 <brad_larsen> the language will have lambda, but only first-order edsl programs will be able to be compiled into CUDA code.
14:22:46 <brad_larsen> i think i'm in a bit over my head. ;-)
14:23:28 <soupdragon> no no
14:28:23 <slava> brad_larsen: how do you compile recursion?
14:28:40 <brad_larsen> recursion is not supported
14:28:49 <brad_larsen> in the dsl
14:29:20 <etpace> How can I write a function that lists all the items of a tree using : instead of ++?
14:29:41 <brad_larsen> CUDA doesn't support recursion in GPU kernels
14:29:47 <slava> yeah, that's why I asked
14:30:08 <timonator> then why not use continuations?
14:30:15 <pikhq> And CUDA strongly discourages branching.
14:30:23 <timonator> :-(
14:30:30 <brad_larsen> heh
14:31:00 <pikhq> (if threads take multiple branches, it executes one branch, and then the other)
14:32:22 <NEEDMOAR> Is there any function list, that given an equivalence relation, let's say f::a -> a -> Bool, it takes a list xs::[a] and returns a list ys::[[a]] where each element of ys is a list grouping by the equivalence relation?
14:32:32 <slava> :t nubBy
14:32:34 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
14:32:37 <MarcWeber> nominolo_: Why do you think using template haskell to generate those logging functions is bad? I think its good because it removes redundancy.
14:32:39 <slava> :t groupBy
14:32:40 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
14:32:45 <p_l> pikhq: afaik that's due to multiple threads sharing one execution unit (i.e. the thread is actually changed into one vector execution unit)
14:32:47 <slava> NEEDMOAR: there you go
14:33:21 <NEEDMOAR> slava: but groupBy groups only adjacent elements.
14:33:26 <nominolo_> MarcWeber: TH is complete opaque to a large number of tools and nonportable and difficult to implement
14:33:29 <pikhq> p_l: It's not *quite* vector execution, but it's pretty similar, yeah.
14:33:45 <slava> NEEDMOAR: oh, I Don't know then
14:34:33 <nominolo_> MarcWeber: it can also quite significantly slow down background compilation
14:34:44 <mmorrow> otoh, you can of course use TH to generate code, /prettyprint it/, then stick it in a module
14:34:57 <mmorrow> which i actually prefer when generating non-trivial amounts of code
14:35:03 <MarcWeber> nominolo_: Ok. You're right about both points.
14:35:07 <nominolo_> mmorrow: yes, but in this case the use case is per-file
14:35:08 <mmorrow> (that way you get to look at it too!)
14:35:50 <mmorrow> nominolo_: hmm
14:35:53 <nominolo_> mmorrow: yes, there are relatively benighn uses
14:36:27 <nominolo_> but i'd prefer it to be contained.  Custom instance generation is a good use case.
14:36:37 <sjanssen> NEEDMOAR: it should be easy to do with partition and unfoldr
14:37:15 <mmorrow> nominolo_: are you saying this as a haskell programmer, a tool author, or both?
14:37:41 <nominolo_> mostly as a tool author
14:37:50 <shapr> Yay pix from Hac-phi! http://picasaweb.google.com/shae.erisson
14:38:05 <mmorrow> nominolo_: what sort of "gotchas" have you run into with TH (out of interest)?
14:38:06 <Axman6> anyone else read http://haskell.org/papers/NSWC/jfp.ps before?
14:38:09 <copumpkin> wow, nice commando jacket
14:38:19 <mmorrow> nominolo_: (wrt scion/etc)
14:39:01 <nominolo_> mmorrow: well, slowdown mostly.  And I don't know how it hurts refactoring.  I guess we need to make some assumptions about what can happen in TH and what cannot
14:39:24 <nominolo_> I.e., a set of assumptions for "safe" refactoring
14:39:55 <mmorrow> nominolo_: yeah, that's another reason i like to generate code and prettyprint... if you're using reify a lot and generating a lot of code, the TH could take a loooong time
14:40:19 <nominolo_> mmorrow: there're some crazy packages on Hackage
14:40:34 <shapr> copumpkin: Surprisingly, most people can't stand that jacket.
14:40:48 <nominolo_> I think "typelevel" used to generate 10,000 constants in one module
14:40:59 <nominolo_> type-level constants
14:41:14 <mmorrow> nominolo_: hmm, would the refactoring code being able to eval/expand splices in the code-to-be-refactored help at all with things? (or is this beside the point(s)?)
14:41:32 <nominolo_> takes >2GB to compile and the haddock docs take forever to load in a browser
14:41:44 <mmorrow> heh
14:42:00 <nominolo_> mmorrow: well, for analysis it could look inside, for transformations you'd have to change the generating function
14:42:11 <brad_larsen> nominolo_:  i tried loading that page once on my cell phone.  bad idea.
14:42:57 <nominolo_> brad_larsen: yep, it even brings a desktop system to its knees
14:42:57 <mmorrow> nominolo_: hmm, have you seen andyjgill's HERA?
14:42:59 <NEEDMOAR> sjanssen: thanks.
14:43:09 <nominolo_> mmorrow: no.  have a link?
14:43:15 <mmorrow> nominolo_: it's really neat (although "non trivial" to get built)
14:43:29 <nominolo_> heh, so is HaRe :)
14:43:40 <mmorrow> well it's here http://code.haskell.org/HERA/
14:43:49 <mmorrow> i have some screenshots too
14:44:35 <mmorrow> http://code.haskell.org/~morrow/code/images/hera_0.png
14:44:37 <mmorrow> http://code.haskell.org/~morrow/code/images/hera_1.png
14:45:19 <mmorrow> so it transforms haskell code using the TH ast, and provides a mini-webserver + ajax ui to the user
14:45:56 <nominolo_> is that core?  or full AST?
14:46:18 <mmorrow> so you sit there in the browser, highlight subtrees of the current working code, then select some combo of transformations, and finally apply that/those to the selected sub-tree with the given strategy
14:46:26 <mmorrow> nominolo_: that's pretty-printed TH
14:46:42 <mmorrow> (with the default TH prettyprinter)
14:47:28 <nominolo_> interesting.  is that for prototyping optimisations?
14:47:50 <nominolo_> or does it try all the transformations you provide?
14:48:06 <mmorrow> nominolo_: ah, there's also a wiki page + paper. that probably says it better than i can.
14:48:29 <mmorrow> http://haskell.org/haskellwiki/Hera
14:49:10 <mmorrow> http://www.ittc.ku.edu/~andygill/paper.php?label=IntroHERA06
15:00:19 <conal> has anyone here gotten gtk2hs to work on os x?
15:00:30 <Axman6> i have in the past
15:00:42 <conal> Axman6: which gtk did you use?
15:00:43 <Axman6> probably too long ago to be any help though :(
15:00:47 <conal> k
15:00:48 <Rotaerk> ugh, just found out that while F# removes inherent nullability from reference types, you can still set them to null from other languages that do impose nullability on reference types... thus breaking any non-null assumptions made by the F# code
15:01:00 <Axman6> dons: you around?
15:01:44 <dons> yo
15:01:49 <copumpkin> Rotaerk: ew
15:02:38 <rovar> Rotaerk, that makes sense F# is just a clever means of manipulating CIL.
15:03:04 <Berengal> Nulls were a pretty shitty idea
15:03:51 <Rotaerk> oh well, if you set it to null it just causes a runtime exception rather than a compile-time error
15:04:00 <Rotaerk> not my problem
15:04:17 <Rotaerk> as long as it works nicely within F#
15:05:03 <Axman6> dons: i was wondering... i know galois do a lot of talks about various things, and i was wondering if you had any insight into possibly getting someone to go and do one at google as a tech talk or something. You guys seem to do a lot of talks i'd like to see, and since you're a company that actually uses haskell in industry, i think a talk detailing the experiences would be great...
15:05:33 <nominolo_> conal: yup
15:05:44 <dons> http://www.galois.com/blog/2009/04/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galois/ like that?
15:05:47 <nominolo_> conal: which version?
15:06:17 <Axman6> looks perfect :)
15:06:40 <nominolo_> I have gtk-0.10.0 working
15:07:23 <dons> Axman6: i'd be happy to give that talk elsewhere. So far only the London HUG has seen it
15:07:45 <uman> haskell is good at blowing my mind
15:08:10 <conal> nominolo_: 0.10.1
15:08:24 <conal> nominolo_: which gtk did you use?
15:09:53 <nominolo_> conal: the OS X native framework
15:10:02 <Axman6> dons: want to come to ANU and do it? :P
15:10:15 <nominolo_> http://www.gtk-osx.org/
15:10:49 <conal> nominolo_: terrific.  that's what i'm trying, without success.
15:11:11 <dons> Axman6: mmm.. interesting. I'll prob. be back in .au later in the year. Could visit my sister in canberra.
15:11:23 <nominolo_> conal: hm, what's the trouble?
15:11:32 <Axman6> dons: anyway, the reason imentioned making it a google tech talk is that it'll help get the word out that you can build large systems in haskell etc
15:11:50 <dons> yes, good idea. i think we have some contacts that could make that happen. i'll see.
15:12:06 <conal> nominolo_: when i ./configure, i get "The development files for the glib-2.x library were not found.".
15:12:18 <conal> nominolo_: do i need to install glib2-devel from macports also?
15:12:47 <Axman6> dons: well that'd be great. if you are coming back, i could get you in touch with Clem Baker-Finch, and i'm sure he could organise something (i think i'll be seeing him today so i can see if he'd be interested)
15:13:27 <dons> yeah, I know Clem.
15:13:29 <nominolo_> conal: I think I used the flags from the wiki: env PKG_CONFIG_PATH=/Library/Frameworks/Cairo.framework/Resources/dev/lib/pkgconfig:\
15:13:32 <nominolo_>      /Library/Frameworks/GLib.framework/Resources/dev/lib/pkgconfig:\
15:13:35 <nominolo_>      /Library/Frameworks/Gtk.framework/Resources/dev/lib/pkgconfig ./configure --disable-gio
15:13:37 <dons> I'm sure he'd be keen.
15:13:57 <Axman6> ok
15:13:58 <dons> Axman6: we're hiring too. I wonder if I should send some flyers to put up round the .au schools
15:14:12 <Axman6> soulds like a good idea
15:14:16 <conal> nominolo_: what wiki?  sounds important for me to know about.
15:14:19 * dons notes this down.
15:14:26 <Axman6> (i'd be interested if i weren't only a second year ;))
15:14:37 <nominolo_> conal: the all-knowing Haskell wiki! --> http://www.haskell.org/haskellwiki/Gtk2Hs
15:14:40 <nominolo_> ;)
15:14:50 <conal> nominolo_: oh!! :)
15:15:00 <Axman6> right, i have to be off, i've got a lecture at 9am (45 mins from now)
15:15:09 <conal> nominolo_: i forgot about those instructions.
15:15:19 <Axman6> glad to hear that you're interested dons :)
15:15:21 <Axman6> o/
15:15:46 <Phyx-> @info FunPtr
15:15:46 <lambdabot> FunPtr
15:16:01 <mmorrow> @src FunPtr
15:16:02 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:16:07 <Phyx-> @hoogle FunPtr --info
15:16:07 <lambdabot> Foreign.Ptr data FunPtr a
15:16:07 <lambdabot>  
15:16:07 <lambdabot> A value of type FunPtr a is a pointer to a function callable from foreign code. The type a will normally be a foreign type, a function type with zero or more arguments where
15:16:20 <nominolo_> conal: the OSX-native version of gtk is not fully functional yet, I think.  But cairo and pango work, so it's good enough for me.
15:16:50 <nominolo_> conal: oh, and they only have the clearlooks theme.  Don't know about menus or the Mac-keys
15:17:24 <mmorrow> Phyx-: it just wraps an Addr# in a newtype with a phantom type param
15:17:24 <conal> nominolo_: oh -- what about opengl?  that's the piece i need most of all.
15:17:27 <mmorrow> just like Ptr
15:17:37 <mmorrow> newtype (Fun)Ptr a = (Fun)Ptr Addr#
15:17:40 <nominolo_> conal: hm, haven't tried
15:17:47 <mmorrow> err
15:17:50 <conal> nominolo_: i'll give it a go.
15:17:51 <mmorrow> s/newtype/data/
15:18:00 <mmorrow> (since Addr# is unboxed)
15:18:12 <Phyx-> mmorrow: ah ok
15:20:18 <nominolo_> conal: there also was a recent blog-post on /r/haskell about how to use OpenGL with Gtk (apparently there are many possibilities to combine them, but most of them lead to segfaults)
15:20:55 <Daimonic> hey, my selectionSort implementation with unfold keeps giving me an inifinity loop on lists > 1
15:20:56 <Daimonic> http://codepad.org/V2373Z5I
15:21:08 <nominolo_> conal: ah, no, it was pango + openGL.  http://just-bottom.blogspot.com/2009/07/using-pango-fonts-on-opengl-canvas.html
15:21:13 <Daimonic> any idea? I wrote the steps down but I don't find the error
15:21:48 <conal> nominolo_: thx!  complex terrain
15:22:38 <nominolo_> yes.  big, complex, unsafe C-API
15:24:14 <nominolo_> Daimonic: try inserting some calls to trace
15:24:27 <Daimonic> what's that?
15:25:02 <nominolo_> it prints a string when the expression it is wrapped around is evaluated
15:25:28 <nominolo_> eg., trace "foo" (length [1..10])
15:25:49 <nominolo_> defined in Debug.Trace
15:25:58 <Daimonic> ok!
15:26:51 * moonpatrol throws some love out at haskell
15:27:43 <nominolo_> Daimonic: you have to be a bit careful about printing stuff, because printing forces evaluation and thus defeats laziness
15:28:07 <TacticalLongcat> yay, free love!
15:28:54 <moonpatrol> TacticalLongcat: free love to anyone with an awesome nick like that.
15:30:55 <TacticalLongcat> thanks
15:31:04 <Phyx-> @hoohle bracket --info
15:31:04 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
15:31:04 <lambdabot>  
15:31:04 <lambdabot> When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use bracket, because bracket will install the necessary exception handler to release
15:31:04 <lambdabot> the resource in the event that an exception is raised during the computation. If an exception is raised, then bracket will re-raise the exception (after performing the release).
15:31:22 <Phyx-> handy
15:31:53 <Daimonic> :t unfold
15:31:54 <lambdabot> Not in scope: `unfold'
15:32:09 <Phyx-> @type unfold
15:32:11 <lambdabot> Not in scope: `unfold'
15:32:22 <Phyx-> @type unfoldr
15:32:24 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
15:32:26 <nominolo_> conal: ok, it seems my gtk2hs was installed without opengl support
15:32:44 <nominolo_> "Could not find module `Graphics.UI.Gtk.OpenGL'"
15:32:57 <Phyx-> Daimonic: might you have meant gunfold ?
15:33:12 <Daimonic> :t gunfold
15:33:14 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall b r. (Data b) => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
15:33:14 <conal> nominolo_: thx for checking.  i'm installing gtkglext from macports now, as suggested by gtk2hs ./configure
15:33:18 <Daimonic> no
15:33:32 <conal> thank gods for the one wifi cafe in this county.
15:33:50 <nominolo_> heh.  traveling?
15:33:54 <Daimonic> Gibbons J., Jones G.: The Under-Appreciated Unfold
15:34:04 <conal> nominolo_: no.  i live here.
15:34:32 <nominolo_> conal: but you have no internet at home/work?
15:34:49 <conal> nominolo_: i live in the woods, with only satellite internet.  slow, bandwidth-limited, and high-latency.
15:35:02 <nominolo_> I see
15:35:39 <conal> we're working toward getting an antenna reflector installed on the mountain/hill-top above us.  if we can, we may get earth-based fast internet.
15:35:50 <nominolo_> so you're a vampire then :)
15:35:57 <nominolo_> one that sparcles in the light
15:36:05 <nominolo_> er, sparkle*
15:36:20 <conal> ??
15:36:35 <nominolo_> sorry, Twilight reference.  Don't watch it.  It's awful.
15:36:50 <conal> oh, okay. :)
15:37:12 <Adamant> conal - you in UK or US right now?
15:37:15 <nominolo_> ah damn, my macbook is falling aport
15:37:37 <MarcWeber> nominolo_: Ok. You can have another look at the commits now. I tried tidying them up
15:37:45 <conal> Adamant: US.  in California.  soon will be in seattle for a few weeks and then ICFP in scottland
15:37:57 <desp> ld warning: atom sorting error for _TypeList_ZCZCZC_closure_tbl and _TypeList_Nil_closure_tbl in ./TypeList.o
15:38:04 <desp> Has anyone seen similar errors?
15:38:09 <desp> warnings*
15:38:19 <nominolo_> desp: did you add --make?
15:38:29 <Adamant> yeah, should have checked your host first, but even then, I couldn't remember if England had a Stockton or if Comcast had networks in the UK
15:38:32 <desp> nominolo_: yes.
15:38:43 <desp> nominolo_: it links successfully, just spewing warnings.
15:38:57 <nominolo_> ah, macos?
15:39:01 <desp> Yes.
15:39:07 <nominolo_> that's not a problem
15:39:14 <nominolo_> it's the Leopard linker
15:39:20 <nominolo_> igore them
15:39:23 <desp> OK, thanks.
15:40:21 <Daimonic> nominolo: Ah, guess I found it. He evaluates minimum xs, before he runs the function and so he tries to delete something which is not anymore in the list, which doesnt let end the function
15:40:22 <Daimonic> terrible
15:46:08 <Daimonic> I have no idea how to fix this
15:49:59 <nominolo_> Daimonic: you are deleting the minimum from the *input* list not from the *argument list*
15:50:50 <nominolo_> Daimonic: unfoldSelectionSort xs = unfold (==[]) minimum delMin xs
15:50:50 <nominolo_>    where delMin ys = delete (minimum ys) ys
15:51:00 <nominolo_> :t unfoldr
15:51:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
15:51:34 <nominolo_> it would be more efficient with unfoldr, since you wouldn't need to compute the minimum twice
15:52:12 <Daimonic> well, that's true :)
15:52:23 <Daimonic> however they gave us this unfold implementation
15:52:30 <nominolo_> ah
15:53:46 <Daimonic> but this works now great, thanks. Anyway, I have no idea why I did not give him a function instead of arguments ...
15:53:49 <nominolo_> anyway, does the solution make sens to you?
15:54:29 <Daimonic> yeah absolute, I am just a little bit fuzzy with myself, but this might be the time :)
15:54:29 <nominolo_> sense*
15:54:40 <nominolo_> @localtime Daimonic
15:54:52 <nominolo_> @botsnack?
15:54:52 <lambdabot> :)
15:54:53 <lunabot>  :)
15:54:56 <Daimonic> :D
16:01:36 <dons> Progress report for the Haskell Platform. Haskell on Windows is hot! The Debian push is on. http://is.gd/1O0Ar
16:02:17 <jmcarthur> what might be some things i can google for previous explorations of types of the form: data Foo a = Foo a | Bar (Foo a) ?
16:02:41 <tommd> awesome
16:03:02 <jmcarthur> i think it's been used as futures before, but i know i have seen it under other names before
16:05:17 <conal> nominolo_: do you know how well native gtk+ and macports gtk+ mix?  i'm port-installing gtkglext, as directed by gtk2hs ./configure (for --enable-opengl).
16:07:19 <nominolo_> conal: I don't know, but I would assume they don't
16:07:36 <conal> oh, urg.
16:09:26 <jekor> Does anyone know of a guide/resources for dealing with the new extensible exceptions in ghc 6.10 with old code (such as Network.CGI)?
16:11:15 <jekor> or even just for dealing with the new exceptions in general. I'm running into Ambiguous type variable `e' in the constraint: `Exception e' all over the place.
16:11:48 <nominolo_> jekor: yes, you need type annotations to specify which exception to use
16:12:07 <nominolo_> you will need to use the ScopedTypeVariables language extension
16:12:57 <jekor> Thanks. Any pointers on which exceptions to use? I'm a little confused by SomeException being the root of the exception tree but ...other exceptions exist outside of the hierarchy?
16:13:28 <nominolo_> for network, you probably want to catch IOException or IOError, I forget which
16:13:41 <nominolo_> SomeException will probably also catch ^C events and such
16:14:02 <nominolo_> so, you shouldn't do a catch-all
16:14:51 <jekor> Hmm...I've seen that advice (don't catch all), but I want to make sure I don't miss any (the CGI program should continue running through all other exceptions).
16:15:12 <jekor> I will poke around with these new terms. Thanks.
16:17:21 <Daimonic> @src insert
16:17:21 <lambdabot> insert e ls = insertBy (compare) e ls
16:17:31 <Daimonic> @src insertby
16:17:32 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:17:35 <Daimonic> @src insertBy
16:17:35 <lambdabot> insertBy _   x [] = [x]
16:17:36 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
16:17:36 <lambdabot>                                  GT -> y : insertBy cmp x ys'
16:17:36 <lambdabot>                                  _  -> x : ys
16:19:15 <conal> where does the old-style Exception module live now?
16:20:07 <conal> i'm trying to get lhs2tex to build.  the latest hackage version uses the old exception interface.
16:22:24 <jekor> Control.OldException?
16:23:32 <Rotaerk> using F# libraries from C# is a PITA hehe
16:24:17 <maxote> for solving predicative FOL problems, is CASC competition a good site for looking for programs?
16:24:30 <Rotaerk> to pass a function to a high-order function from C#, I have to make a class that implements the FastFunc class
16:29:04 <Berengal> Rotaerk: Don't do that then?
16:29:22 <rovar> sounds like a java thing?
16:29:35 <rovar> you wish to pass a function? make it a class with an execute method
16:29:59 <Rotaerk> rovar, that's what FastFunc is basically; I just have to derive it and implement that method
16:30:09 <Berengal> Objects are poor closures...
16:30:13 <hzap> so F# functions don't translate into C# delegates...
16:30:22 <Rotaerk> hzap, nope -_-
16:30:30 <hzap> Rotaerk: :(
16:30:40 <Rotaerk> maybe that'll change in the new .NET version or something
16:30:41 <rovar> i wonder if there is a way to automate the creation of such things via macros. does c# have macros yet?
16:30:52 <dibblego> C# uses System.Func
16:31:10 <Rotaerk> rovar, nope; for that people usually use code-gen tools
16:31:55 <hzap> i guess it's like manually executed macro expansion
16:32:50 * Berengal wonders if it's possible to generate java code from haskell
16:33:24 <rovar> there is talk of generating jvm bytecode, which would be more useful than polluting the world with more Java code. IMHO
16:33:56 <Berengal> Not if I have to write Java
16:34:02 <Berengal> Although yes, I agree
16:34:06 <slava> you can generate .class files from any language
16:34:10 <slava> java has libraries to make it easy though
16:34:46 <Berengal> Hopefully a tenfold increase in productivity makes up for unreadable code ;)
16:35:10 <Berengal> (Especially when I at least have no trouble maintaining it)
16:35:49 <Rotaerk> http://rotaerk.pastebin.com/d567820bc
16:36:07 <Baughn> Berengal: I'm pretty sure you'd be fired for submitting haskell-based java code. ^^;
16:36:13 <Rotaerk> all that just to create:  fun x y -> new MultiHeightGrid (...)
16:36:43 <Berengal> Baughn: Perhaps not the worst thing that could happen...
16:36:57 <hzap> Rotaerk: ouch
16:37:21 <Rotaerk> heh
16:37:40 <Rotaerk> while .NET makes interop possible, it certainly doesn't guarantee it'll be easy
16:38:41 <Berengal> Interop seldom is.
16:38:54 <rovar> it is easier to call c# from f# though, ya?
16:39:02 <Rotaerk> yep
16:39:49 <Berengal> Most interop I've seen is a one-way thing.
16:40:10 <Rotaerk> I think I'll overload that constructor and make one that's easier to use from C#
16:40:49 <Saizan_> are HOFs easy in F#?
16:41:02 <Rotaerk> yea
16:41:08 <hzap> it's ocaml
16:41:19 <Berengal> I imagine HOFs are easy in any functional language
16:41:31 <Berengal> It's sort of implied in the definition of "functional"
16:41:36 <Saizan_> and can you call a F# HOF from C#?
16:50:09 <Rotaerk> Saizan_, yes that's what I was doing
16:50:46 <w1zard> Can I do math on impure data?
16:50:48 <Rotaerk> Saizan_, except functions passed as parameters are of type FastFunc, which is just an abstract type, so I have to create a class that implements it in order to call the HOF
16:52:01 <hzap> so trying to call F# from C# basically throws you back into Java-land ...
16:53:42 <zong_sharo> does hsql is the only chioce for haskell database programming?
16:53:54 <copumpkin> no
16:54:27 <copumpkin> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database
16:55:01 <zong_sharo> hdbc fails to compile, takustn and haskelldb both semi-dead and lacks documentation
16:55:14 <rovar> zong_sharo, assuming you mean relational databases/sql?
16:55:21 <zong_sharo> rovar: yep
16:55:51 <zong_sharo> anydbm/berkeleydb/couchdb/berkeleydbxml/sparql - irrevelant
16:58:17 <zong_sharo> *sigh*
16:58:46 <moonpatrol> le sigh
16:59:17 <moonpatrol> you could be totally awesome and pick up one of those defunct projects...
16:59:22 <desp> -optl -w
17:00:31 <zong_sharo> these days even php got more advanced rdbm api
17:01:11 <copumpkin> heh
17:08:23 <Berengal> Some things are just too awesome: http://steampunkworkshop.com/images/ain29-watch-five-pound-note.jpg
17:10:02 <moonpatrol> Berengal: only if it were truly steam powered...
17:11:01 <Berengal> moonpatrol: Well, there's water cooling...
17:27:43 <Phyx-> hmm, why is making a haskell dll still such a pain
17:31:58 <Cale> zong_sharo: uhh... are you sure that haskelldb is dead?
17:32:14 <Cale> zong_sharo: I'm pretty sure that's not the case
17:34:20 <Cale> zong_sharo: and haskelldb has support for all the drivers supported by hdbc and hsql, which include mysql, odbc, postgresql, sqlite and sqlite3.
17:34:51 <dons> Phyx-: thankfully, it has gotten much much easier
17:35:24 <Phyx-> dons: i'm about to give it another go, first time since 6.8
17:36:11 <dons> the IHG has funded Well-Typed to make DLL building much simpler.    here's part of the story, http://blog.well-typed.com/2009/05/buildings-plugins-as-haskell-shared-libs/
17:36:35 <Cale> zong_sharo: Why is hdbc failing to compile? It compiles for me.
17:36:38 <dons> you can read more about it here, http://blog.well-typed.com/2009/04/first-round-of-ihg-development-work/
17:37:34 <Phyx-> dons: ah ok, cool thanks, i'll start reading the right away
17:37:58 <Phyx-> i want to access the ghc lexers from outside haskell, thought to make a haskell module that uses the ghc api and expose some functions
17:38:14 <dons> cool
17:47:14 <nominolo_> Phyx-: the token stream is already availble from the GHC API
17:47:18 <Cale> zong_sharo: If you're interested, I did find one dependency wibble that I had to make in order to get haskelldb-hsql to build under ghc-6.10.3
17:47:44 <Cale> zong_sharo: It just wasn't listing old-time in its dep list, so I added that, and it built fine
17:47:56 <nominolo_> oh, I ok, you probably know that
17:49:39 <Phyx-> nominolo_: yeah I know, I just need it outside Haskell itself
17:50:13 <Cale> zong_sharo: Also, it seems to work. I can connect to my local mediawiki database in MySQL and query it just fine.
17:57:46 <Phyx-> @hoogle stdcall
17:57:47 <lambdabot> Language.Haskell.TH StdCall :: Callconv
17:57:47 <lambdabot> Language.Haskell.TH.Syntax StdCall :: Callconv
17:57:47 <lambdabot> Language.Haskell.TH stdCall :: Callconv
17:59:57 <Phyx-> hmm
18:00:04 <Phyx-> why is ghc saying this is invalid: foreign export stdcall foo :: CInt -> CInt
18:00:22 <copumpkin> what's the error?
18:00:38 <Phyx-> Demo.hs:5:0: Invalid type signature
18:00:39 <Phyx-> ghc.exe: panic! (the 'impossible' happened)
18:00:43 <copumpkin> lol
18:00:53 <copumpkin> @ghc
18:00:53 <lambdabot> ghc says: Type signature given for an expression
18:01:23 <Phyx-> (GHC version 6.10.4 for i386-unknown-mingw32): link: GHC not built to link this way: LinkDynLib
18:01:29 <Phyx-> hmm do i need to build ghc myself?
18:01:39 <copumpkin> maybe ccall?
18:01:44 <copumpkin> instead of stdcall?
18:01:49 <copumpkin> never done foreign exports myself
18:02:00 <Phyx-> same
18:02:03 <Phyx-> error
18:02:09 <Phyx-> but i need stdcall, windows
18:05:20 <Phyx-> hrm.. and suddenly it accepts it
18:05:21 <Phyx-> odd
18:06:18 <Phyx-> i suppose the current version of ghc doesn't allowed dynamic libs to be build under windows? -shared fails
18:08:20 <hackagebot> TBC 0.0.1 - Testing By Convention (PeterGammie)
18:09:27 <Phyx-> hrm, same bug as http://hackage.haskell.org/trac/ghc/ticket/3114
18:09:41 <Phyx-> hasn't even been assigned yet, lol
18:09:50 <Phyx-> milestone 6.12 :O
18:21:13 <Axman6> dons: still around?
18:29:57 <Axman6> anyone know of some package that allows you to develop your own numeric types, that are arbitrarilly bounded? like in Ada you'd say type MyInt : Integer range 1..1483;, and it can be checked at run time that the values are in that range
18:30:31 <Axman6> i was thinking of trying to write my own class for it, but it'd be nice if someone else had done it before
18:30:59 <SamB> Axman6: well, obviously the syntax is going to be worse ;-P
18:30:59 <Cale> Shouldn't need as much as a class, just a datatype should do.
18:31:00 <dolio> At run time or compile time?
18:31:10 <Cale> (and some instances for things like Num)
18:31:13 <SamB> Cale: you need classes to handle the type-level arithmatic
18:31:23 <Cale> SamB: What type-level arithmetic?
18:31:36 <SamB> Cale: presumably you'll at least need to store numbers in types
18:31:40 <Cale> If you're only checking at runtime...
18:31:43 <SamB> and get them out again
18:32:15 <Cale> ah, I suppose if you want to put the bounds into the types and have them show up in the values
18:32:26 <Cale> It seems like a waste of typesystem hackery to do that though.
18:32:37 <dibblego> is there a library to copy a directory excluding some files?
18:32:39 <SamB> how is it wasteful?
18:32:54 <SamB> the hackery is, after-all, reusable
18:33:03 <SamB> you would presumably just use a library that provided it
18:33:07 <Cale> Easier just to write a function which applies bounds to a given number, and then have numeric operations that propagate the bounds.
18:33:35 <SamB> bah, you aren't ambitious enough in your laziness!
18:33:37 <Cale> (and ensure that results lie inside the bounds)
18:34:15 <Axman6> Cale: well, the reason i was proposing a class was so that you'd say something like type MyInt = Integer, and then instanced AdaBounded MyInt where isInRange x = x `elem` [1..148284] for example
18:34:59 <Cale> Axman6: That'd have to be a newtype at least.
18:35:21 <Cale> Axman6: and you'd only be able to apply one set of bounds to any given type of number then...
18:37:03 <Cale> Axman6: Since you're doing checking at runtime and not compile time, it doesn't make so much sense to put the information about the bounds into the type. Well... it *would* let you check that bounds propagate cleanly.
18:37:39 <dolio> @type inRange
18:37:41 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
18:37:51 <Cale> I was thinking something more along the lines of   data WithBounds a = WB (a,a) a
18:38:57 <Cale> The only tricky part is what to do when you perform arithmetic on these things: do you check that the bounds match? Do you let them shrink? Do you recalculate them somehow based on the operation?
18:39:11 <dolio> Doesn't Ada do some static checking as well?
18:39:47 <dolio> Like if you try to use a literal outside the bounds, it complains?
18:40:03 <dolio> That's a little more painful to mimic.
18:42:39 <Axman6> yeah it should do
18:43:56 <Axman6> also, i did realise how close my idea was to the Ix class
18:44:42 <Cale> I think taking the max of the lower bounds and the min of the upper bounds is probably what you want to do when you do arithmetic. This has the property that the bounds are preserved when they match, and any results of arithmetic operations have to lie in the the intersection of the bounds of the operands.
18:44:47 <Axman6> Cale: well, the point would be that all members of the same type would have the same bounds, so those problems would not occur
18:45:04 <Cale> You know about the Bounded class, yeah?
18:45:09 <Axman6> yeah
18:45:35 <Axman6> but it's not easy to write your own bounded type, say a type which only has the values 7..1823
18:45:36 <Cale> Bounded and Ord give you a way to write isInRange
18:46:32 <dolio> Well, it is pretty easy, it's just got lots of boilerplate.
18:46:41 <Axman6> yeah
18:46:58 <dolio> newtype SevenToEighteenTwentythree = STET Int ; <instances go here>
18:48:16 <dolio> When Conor gets his fancy type-level numeric in, someone can write a type that lets you have a type 'Range {7} {1823}'.
18:48:58 <dolio> Writing type-level 1823 is currently a pain, though.
18:49:27 <dolio> > showIntAtBase 2 intToDigit 1823 ""
18:49:29 <lambdabot>   "11100011111"
18:50:13 <FliP^2eH> Wait
18:50:15 <FliP^2eH> Wait wait wait
18:50:22 <monochrom> Hmm, no HWN yet.
18:50:23 <FliP^2eH> There IS a showIntAtBase function?
18:50:29 <FliP^2eH> Why did I write my own?
18:50:30 <FliP^2eH> ADAKD!
18:50:30 <Axman6> :o
18:50:34 <dolio> Yeah. I think it's in Numeric.
18:50:35 <Axman6> ha
18:50:37 <Axman6> @index 11100011111
18:50:38 <lambdabot> bzzt
18:50:39 <Axman6> uh
18:50:41 <monochrom> Numeric.showIntAtBase
18:50:47 <FliP^2eH> pain :: Head -> Wall
18:50:49 <Axman6> @index showIntAtBase
18:50:49 <lambdabot> Numeric
18:50:53 <Axman6> indeed
18:51:07 <FliP^2eH> And showIntFromBase?
18:51:10 <FliP^2eH> Rerversed?
18:51:14 <dolio> Numeric's a weird module.
18:51:18 <monochrom> pain :: (Monad m) => Head -> IO Wall
18:51:21 <Axman6> @index showIntFromBase
18:51:22 <lambdabot> bzzt
18:51:28 <Axman6> @hoogle showIntFromBase
18:51:28 <lambdabot> No results found
18:51:32 <FliP^2eH> > shotIntAtBase 16 128
18:51:34 <lambdabot>   Not in scope: `shotIntAtBase'
18:51:36 <FliP^2eH> > showIntAtBase 16 128
18:51:38 <d4> does anyone recall
18:51:38 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Char))
18:51:38 <lambdabot>    arising ...
18:51:38 <Axman6> @hoogle fromBase
18:51:38 <lambdabot> No results found
18:51:44 <Cale> :t readInt
18:51:46 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
18:51:46 <FliP^2eH> > showIntAtBase 16 intToDigit 128
18:51:47 <lambdabot>   Overlapping instances for GHC.Show.Show
18:51:48 <lambdabot>                              (GHC.B...
18:51:48 <FliP^2eH> > showIntAtBase 16 intToDigit 128 ""
18:51:50 <lambdabot>   "80"
18:51:50 <FliP^2eH> :Q
18:52:00 <FliP^2eH> > intToDigit 128 ""
18:52:01 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
18:52:04 <dolio> It's all showing/reading numbers, which could go in other modules.
18:52:04 <FliP^2eH> Hm.
18:52:06 <d4> what it is called when a function is defined without binding its parameter(s) in the definition?
18:52:17 <FliP^2eH> High order?
18:52:18 <monochrom> pointfree
18:52:20 <Cale> d4: points-free
18:52:23 <d4> monochrom: thx
18:52:23 <FliP^2eH> :(
18:52:28 <d4> & Cale
18:52:32 <Cale> (or pointfree, yeah)
18:52:42 <FliP^2eH> @faq Can Haskell recreate cowsay?
18:52:42 <lambdabot> The answer is: Yes! Haskell can do that.
18:52:46 <FliP^2eH> :D
18:52:51 <d4> http://www.haskell.org/haskellwiki/Pointfree
18:53:17 <FliP^2eH> And what was higher order functions?
18:53:29 <oklopol> FliP^2eH: functions that manipulate other functions
18:53:37 <oklopol> either take them as parameters or return them
18:53:43 <FliP^2eH> Like map?
18:53:47 <oklopol> like map.
18:53:53 <Axman6> heh
18:53:57 <FliP^2eH> Okay :)
18:54:07 <d4> compose is my favorite HOF
18:54:19 <d4> (.)
18:54:51 <FlipCrunchBang> Hmm
18:55:05 <FlipCrunchBang> Irssi takes some getting used too
18:55:07 * Axman6 heard haskell described as a HOT language today in a lecture... and now i can't remember what HOT stood for :(
18:55:13 <Cale> Yeah, I think that's a good way to tell how much a language is intended to be a functional language: how nice a syntax does it give to function composition?
18:55:20 <Axman6> FlipCrunchBang: it's the only way to go
18:55:23 <pikhq> Ah, functions of functions.
18:55:24 <dolio> Higher orderer typed.
18:55:31 <Cale> XChat is pretty nice though, too.
18:55:31 <dolio> Order, even.
18:55:41 <Axman6> dolio: yeah i thought it was that, but it didn't quite sound right
18:55:51 <Cale> irssi is good if you want to run your irc client in screen or over ssh
18:56:01 <FlipCrunchBang> Window Management is strange for someone who only used window managers like Windows or GNOME
18:56:04 <FlipCrunchBang> ;)
18:56:05 * jaredj is using it right now
18:56:08 <Axman6> 11:56 Irssi uptime: 46d 12h 17m 26s
18:56:24 <benmachine> I think for something so universally used by such a large array of geeks, irssi is surprisingly rough around the edges
18:56:28 <benmachine> it's really good
18:56:32 <Axman6> it would have been over 200 days, but mum turned off the power in the house for some reason :(
18:56:34 <benmachine> but I'd expect really really good :P
18:56:38 <monochrom> geeks like it rough
18:56:45 <FlipCrunchBang> I want to pipe cowsay to irssi
18:56:46 <FlipCrunchBang> ;<
18:56:53 <Axman6> geeks can accept rough software
18:56:58 <jaredj> benmachine: irc clients usually are, in my experience
18:57:10 <Phyx-> xchat was nice, till they started charging for windows versions
18:57:15 <Phyx-> irssi ftw!
18:57:15 <jaredj> buh?
18:57:18 * brad_larsen wishes ghc had better support for overriding literals.
18:57:20 <d4> FlipCrunchBang: I don't find the irssi defaults very accommodating
18:57:29 <brad_larsen> fromInteger is part of Num.  :-(
18:57:33 <pikhq> FlipCrunchBang: /exec -o cowsay foo
18:57:39 <FlipCrunchBang> :D
18:57:40 <d4> for instance, a new window for every channel and every query
18:57:51 <d4> seems excessive, at least as a default
18:57:57 <monochrom> fromIntegral is part of nothing
18:57:57 <jaredj> predictable though
18:57:59 <benmachine> seems logical to me
18:58:02 <Cale> Hey! That page lists swing as something discovered via @pl
18:58:05 <Cale> which is a lie
18:58:11 <monochrom> But nevermind.
18:58:17 <brad_larsen> the Num typeclass
18:58:18 <FliP^2eH> Ahh
18:58:18 <Axman6> d4: how else would you do it?
18:58:21 <Cale> I wrote the swing combinator by hand.
18:58:25 <FliP^2eH> My irssi is stuck in some channel window :D
18:58:32 <FliP^2eH> I haven't yet figured out how to switch windows
18:58:33 <dolio> swing?
18:58:39 <FliP^2eH> I never figured it out :(
18:58:40 <jaredj> FliP^2eH: Alt + unmbers
18:58:41 <d4> Axman6: I like to get direct PRIVMSGs in the current window
18:58:43 <Phyx-> d4: how else would you want it?
18:58:48 <FlipCrunchBang> Ahh!
18:58:52 <d4> rather than having some other window appear out of view
18:58:55 <Axman6> FlipCrunchBang: either alt-number or esc-number (if you're on OS X)
18:58:57 <jaredj> or Esc, number if you can't Alt
18:59:07 <FlipCrunchBang> What would happen if there's more than 9 windows?
18:59:16 <d4> I came up with the old ircII variants like EPIC
18:59:17 <Phyx-> FlipCrunchBang: /window
18:59:19 <Axman6> d4: so... how would you reply? i don't want to have to write /msg foo glsdkfgj srh ksr hksrthkl
18:59:21 <Phyx-> FlipCrunchBang: /window <num>
18:59:21 <FlipCrunchBang> Okay :)
18:59:25 <FlipCrunchBang> Thanks!
18:59:40 <Axman6> FlipCrunchBang: you go onto letters, starting at q and going through to p
18:59:41 <Phyx-> or ctrl+n and ctrl+p for next and previous window respectfully
18:59:41 <d4> Axman6: I'd rather type /m nick than have to switch windows back and forth
18:59:48 <Axman6> 1234567890qwertyuiop
18:59:48 <brad_larsen> I want to override integer literals for an AST type, w/o having to implement all the other Num ops.
18:59:56 <d4> Axman6: you can tab-complete the nick anyway
19:00:14 <Axman6> brad_larsen: instance Num Foo where  (+) = undefined
19:00:21 <benmachine> Axman6: I think by default alt-p is pageup
19:00:24 <d4> Axman6: I'd open a separate window if I expected a long exclusive conversation, but I don't want one for one-off PRIVMSGs
19:00:25 <Axman6> d4: it's still a pain for actual conversations
19:00:38 <Axman6> there's probably a way you can do all this anyway
19:00:40 <brad_larsen> Axman6: yeah, but that seems error-prone.
19:00:47 <jaredj> benmachine: w000t, i couldn't page up because my terminal program took PgUp
19:00:55 <monochrom> I see the agony.
19:00:57 <d4> Axman6: yes, irssi can be configured that way
19:00:58 <jaredj> benmachine: you have made my day
19:01:06 <benmachine> jaredj: umm make sure you can page down too
19:01:12 <jaredj> Alt-n
19:01:14 <d4> I just like the way ircII was set up by default better
19:01:25 <benmachine> jaredj: also, OS X's terminal responds to shift-pageup
19:01:36 <jaredj> oh heh this isn't osx
19:01:44 <benmachine> yes but maybe yours does as well
19:02:12 <jaredj> this is kermit running on dos on a 486 laptop through a serial port to a gumstix, to my linux box through wifi via ssh, in a screen
19:02:39 <d4> jaredj: kermit on dos on a 486
19:02:42 <d4> wow
19:02:46 <jaredj> 16 gray scales babyee
19:03:01 <monochrom> (I am surprised you don't go through several layers of virtualization in-between.)
19:03:01 <d4> I'm trying to remember if I ever saw a 486 laptop
19:03:04 <jaredj> i have to export TERM=vt100 so it doesn't try to use them and make the text invisible
19:03:12 <d4> that thing must be bulky as hell
19:03:24 <jaredj> well - maybe 6 pounds
19:03:31 <d4> not so bad
19:03:40 <jaredj> it's a toshiba satellite t1910
19:03:49 <jaredj> with Ctrl where CapsLock goes :)
19:04:01 <jaredj> makes life challenging when i go back to work and CapsLock is there
19:04:23 <d4> jaredj: just remap it
19:04:33 <d4> I can't stand having Caps Lock next to the A key
19:04:41 <d4> such a waste of prime home-row space
19:04:44 <jaredj> at work capslock is Mod3, my xmonad hotkey modifier
19:04:50 <MarcWeber> nominolo_: Can you use to typecheck scion itself ?
19:05:22 <jaredj> d4: with ctrl in the corner, you can use your left pinky knuckle to press it
19:05:33 <jaredj> even easier than using your pinky finger
19:05:37 <d4> jaredj: if you're double-jointed I guess
19:06:14 <jaredj> wha? i'm not
19:06:21 <jaredj> just kinda tilt your hand
19:06:24 <d4> I see the keys on your Toshiba are less flat than modern laptops
19:06:28 <jaredj> yes
19:06:30 <jaredj> mehehehe
19:06:37 <jaredj> but alt is in the corner
19:06:40 <d4> cute mouse ball too
19:06:57 <d4> ... in this photo anyway: http://www.michaelminn.com/linux/toshiba1910/toshiba1910.jpg
19:07:05 <jaredj> *shrug* can't view ;P
19:07:09 <jaredj> text only
19:07:12 <d4> oh yeah
19:07:35 <jaredj> it's kind of an eye opener
19:07:44 <monochrom> There are ascii art renderers.
19:07:53 <d4> monochrom: I was just about to say
19:08:24 <jaredj> wuell... k yeah
19:08:25 <monochrom> Someone should implement yet another one and put it on hackage.
19:08:31 <d4> monochrom, jaredj: aalib is the one I remember
19:08:32 <jaredj> hmm i need to get one
19:08:36 <jaredj> with zooming
19:08:38 <monochrom> Yes! aalib.
19:08:59 <mmorrow> haha, aalib was (is?) sweet
19:09:35 <mmorrow> you could watch movies in ascii iirc
19:09:50 <mmorrow> * can watch
19:10:03 <monochrom> You can tell vlc to play a movie through aalib. You can use TH to tell GHC to do that whenever it builds your project.
19:10:13 <mmorrow> :o
19:10:20 <FlipCrunchBang> :)
19:10:21 <mmorrow> vlc &
19:10:27 <d4> I recall playing some kind of first-person shooter in aalib
19:10:31 <d4> either Doom or Quake
19:10:33 <jaredj> they had doom i think
19:10:34 <monochrom> "Please enjoy this complimentary movie while you wait for the build..."
19:10:43 <dibblego> @hoogle Int -> Integer
19:10:43 <lambdabot> Prelude toEnum :: Enum a => Int -> a
19:10:43 <lambdabot> Data.Bits bit :: Bits a => Int -> a
19:10:43 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
19:10:56 <jaredj> i think aptitude used to have a tetris you could play while your packages downloaded
19:11:02 <monochrom> Since TH is so IO-monad capable. :)
19:11:05 <Baughn> monochrom: Make it one of those dive-into-black-hole movies. :3
19:11:09 <brad_larsen> jaredj:  still does
19:11:13 <Baughn> That seems fitting for haskell
19:11:18 <jaredj> bahaha
19:11:26 <mmorrow> monochrom: haha, nice
19:11:33 <brad_larsen> too bad i have fast internet.  no chance to play.
19:11:35 <monochrom> Neato.
19:12:42 <zong_sharo> Cale: tutorials, tutorials, tutorials
19:12:43 <mmorrow> a movie rendered in ascii initiated by TH *during* compilation would probably be one of the funniest things i'd seen in a while
19:13:09 <mmorrow> or doom
19:13:33 <jaredj> TH, eh, takes a while?
19:13:36 <d4> "two HTML 'screenshots' of ttyquake which he created by hand. No, really. He typed in all those little characters while reading from jpeg screenshots"
19:13:48 <Badger> heh
19:13:56 <d4> http://webpages.mr.net/bobz/ttyquake/
19:14:58 <mmorrow> jaredj: if you're doing lots (like > 100) "reify"s and building something huge it can
19:15:12 <MarcWeber> @tell nominolo_ You can pull now. both cabal and file component projects can be typechecked by scion now. I still don't know how to do this with the special scion repo itself though
19:15:12 <lambdabot> Consider it noted.
19:15:17 <brad_larsen> is there any way to overload the if/then/else haskell syntax to have type other than Bool -> a -> a?
19:15:34 <mmorrow> each reify has to lookup info about a Name in wherever ghc squirrels it away
19:16:00 <MarcWeber> brad_larsen: Which type are you thinking about?
19:16:09 <jaredj> d4, at 19200bps cacaview is real slow
19:16:10 <mmorrow> , $(lift =<< reify ''Either)
19:16:13 <lunabot>  TyConI (DataD [] Data.Either.Either [a_1627417455,b_1627417456] [NormalC ...
19:16:16 <mmorrow> , ppDoc $(lift =<< reify ''Either)
19:16:18 <lunabot>  data Either a_0 b_1 = Left a_0 | Right b_1
19:16:32 <mmorrow> , $(lift =<< reify ''IO)
19:16:33 <lunabot>  TyConI (NewtypeD [] GHC.IOBase.IO [a_1627415782] (NormalC GHC.IOBase.IO [...
19:16:36 <mmorrow> , ppDoc $(lift =<< reify ''IO)
19:16:38 <lunabot>  newtype IO a_0 = IO (State# RealWorld ->
19:16:38 <lunabot>                       (#,#) (State# RealWorld) a_0)
19:16:51 <brad_larsen> MarkWeber:  I'm trying to embed a DSL nicely.  would be good to re-use if/then/else for conditionals in the DSL.
19:17:35 <brad_larsen> MarkWeber:  there's the IsString class for overloaded string literals.  Maybe there could be a similar IsBoolean class?
19:17:41 <conal> brad_larsen: sadly not.
19:18:11 <conal> brad_larsen: however, that change is consistent with other recent changes to ghc's dialect of haskell.
19:18:18 <brad_larsen> is that because of implementation difficulties?
19:18:31 <brad_larsen> i woudln't be surprised if there were difficult questions I'm not thinking of.
19:18:33 <conal> brad_larsen: i doubt it
19:19:08 <conal> brad_larsen: one question is what type to give the generalized if function.
19:19:29 <conal> brad_larsen: i offered one answer in the Boolean package.
19:19:50 <conal> brad_larsen: some other folks want to do something similar for the same reason as you & i do.
19:19:53 <brad_larsen> if I had a datatype Exp a with a Cond constructor, Cond :: Exp Bool -> Exp a -> Exp a, id' like to be able to use if/then/else as an alternative syntax for Cond.
19:19:57 <conal> namely deep dsl embeddings.
19:19:59 <MarcWeber> I love it :-) I love it *yeah* I even have tags for those infix ops such as <+> now ! *jump*
19:20:23 <brad_larsen> yes, I've read a bit.  lennart augustsson was doing similar things.
19:21:26 <conal> brad_larsen: also Sebastiaan Visser and (i think) Andy Gill
19:21:28 <d4> jaredj: I think it's great you're defying the GUI hegemony, BTW ;)
19:22:20 <MarcWeber> brad_larsen: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7560#a7560 line 47 ?
19:22:36 <MarcWeber> it's from utility-ht
19:23:26 <brad_larsen> MarkWeber:  yes, I've written things like that before.  It's just not perfect.  I want a nearly seamless embedding.  ;-)
19:24:05 <Axman6> "Abstract subprograms are equivalent to ending a C++ function declaration with ``= 0''." uh... you can do that in C++? wtf is that?
19:24:30 <MarcWeber> brad_larsen: patch haskell-src and use those here like documents..
19:24:47 <brad_larsen> axman6:  abstract function.  subclasses must implement.
19:24:49 <Axman6> s/?$/?!
19:24:50 <MarcWeber> Then you have [..|  your code |] or such where your code can be multiple lines long.
19:25:35 <Axman6> brad_larsen: possibly the most retarded syntax i've ever seen for abstract interfaces
19:25:41 <MarcWeber> brad_larsen: Maybe create a ticket. >>=, do can be overloaded
19:25:44 <brad_larsen> Axman6:  I don't disagree
19:25:46 <jaredj> d4: heh thx. makes it hard to do plan9 or inferno stuff though: they both assume graphics for most interesting things
19:25:56 <jaredj> e.g. editing anything
19:26:18 <brad_larsen> MarcWeber: umm, haven't done any ghc hacking.  Can you point me to the place to make a ticket for that?
19:26:34 <MarcWeber> brad_larsen: google for trac and ghc
19:26:38 <brad_larsen> kk
19:27:01 <MarcWeber> brad_larsen: At the top you'll find a link "Register"
19:27:16 <MarcWeber> brad_larsen: You know about >>= overloading?
19:27:26 <MarcWeber> Maybe you can add that as reference how it could be done?
19:27:27 <d4> jaredj: plan9, wow, is that still going?
19:27:27 <brad_larsen> MarcWeber: yes.
19:27:31 <d4> what's inferno?
19:27:56 <brad_larsen> trac database is locked :-(
19:28:32 <brad_larsen> hmm, guess it worked.
19:28:48 <jaredj> d4: inferno is kind of like plan 9, but with a virtual machine and bytecode, like java but not horrible
19:28:58 <MarcWeber> brad_larsen: Which DSL are you working on?
19:29:31 <d4> like java but not horrible -- sort of a mind-bender, that
19:29:44 <jaredj> d4: and lots of cutesy names. the language is Limbo, the virtual machine is Dis, the network protocol is Styx....
19:29:58 <d4> jaredj: ah, as in Dante
19:30:03 <jaredj> quite.
19:30:33 <d4> I sold my copy of La Divina Commedia
19:30:39 <pikhq> jaredj: Isn't Java but not horrible, uh... Smalltalk?
19:30:44 <d4> too many books
19:31:37 <d4> jaredj: at UCSD we're almost to the point undergrads see no programming languages other than Java
19:31:39 <jaredj> pikhq: limbo is a bit like smalltalk, but not so uppity: it doesn't try to be the os
19:31:51 <jaredj> d4: ah :(
19:32:04 <pikhq> jaredj: Bah.
19:32:10 <d4> evidently there's a pretty explicit goal to remove everything but Java from the lower division at least
19:32:17 <d4> what blows my mind is
19:32:31 <d4> the operating-systems course being taught right now is using Java
19:32:49 <jaredj> !
19:32:53 <MarcWeber> d4: Anyway: there is one thing I'm missing from Java: stack traces you can put into log files..
19:33:10 <MarcWeber> You don't havet this feature in haskell
19:33:27 <d4> MarcWeber: hmm... Java exceptions come with stack traces...
19:33:28 <jaredj> "stack traces" varies in haskell..
19:34:02 <BMeph> MarcWeber: Stack traces in general aren't as useful for Haskell as they are in other languages. :)
19:34:18 <MarcWeber> jaredj: Yeah. But If you see a null pointer exception in a Java log you have an idea why it happened. You've no clue in haskell..
19:34:19 <d4> oh. I think I misinterpreted the phrase "missing from Java"
19:34:44 <pikhq> MarcWeber: I don't think it is possible to have a clue why a null pointer is coming up in Haskell.
19:34:47 <MarcWeber> d4: Probably I used the wrong words. I'm tired and should go to bed..
19:34:50 <pikhq> ;p
19:35:08 <jaredj> MarcWeber: understood; i'm just saying "stack" is different, mostly because Haskell's lazy
19:35:28 <jaredj> i used some ghci debugging a couple weeks ago
19:35:36 <jaredj> i set a breakpoint and asked about the stack
19:35:39 <jaredj> it blew my mind
19:35:48 <MarcWeber> jaredj: I said to put into logs. Do you want to run production systems using ghci ??
19:36:06 <d4> MarcWeber: ah, it's late where you are
19:36:25 <d4> 088.80.200.63
19:36:30 <d4> oops
19:36:33 <d4> 04:36
19:36:33 <jaredj> gesundheit
19:36:42 <d4> jaredj: heh
19:37:15 <jaredj> 04:36 ogh sleep man sleep
19:37:35 <MarcWeber> I had to fix scion + vim.. :)
19:37:45 <brad_larsen> MarcWeber: I am working on an M.S. thesis, creating an array mini-language EDSL in Haskell, which will be optimized and compiled into CUDA code to run on a GPU.
19:37:53 <d4> http://www.eecs.berkeley.edu/~kubitron/courses/cs162-F05/Nachos/walk/walk.html
19:37:56 <jaredj> oo
19:38:05 <brad_larsen> MarcWeber: It's somewhat similar to http://www.cse.unsw.edu.au/~chak/papers/gpugen.pdf
19:38:36 <brad_larsen> MarcWeber: but I'm focusing more on optimization, and not worrying about on-line compilation, or use of the GPU from haskell.  Generated CUDA code will be used in C++ apps.
19:38:59 <MarcWeber> brad_larsen: I guess this is going to rock..
19:39:26 <Axman6> brad_larsen: any reason you're targeting CUDA and not OpenCL, which will work on far more machines?
19:39:33 <jmcarthur> huh, google's recursion joke is also an example of lazy evaluation
19:39:46 <Axman6> (sounds like a very interesting project nonetheless)
19:40:11 <brad_larsen> MarcWeber: I hope it will rock.  I'm in a bit over my head, I think.  Trying to get a nice embedding of the dsl---maybe worrying about that too much.
19:40:40 <Axman6> brad_larsen: hack something ugly that works, then make it pretty ;)
19:40:44 <d4> jmcarthur: good observation
19:40:47 <brad_larsen> Axman6:  CUDA is here now and has publicly available implementation; OpenCL you still need NDAs to get at.
19:40:57 <brad_larsen> Axman6: at least working implementations
19:41:00 <Axman6> fair point
19:41:21 <brad_larsen> Although if OpenCL pans out, that would be a nice backend.
19:41:24 <Axman6> you could always produce the code and wait... but i can see how that would not be very fun or enlightening
19:41:31 <brad_larsen> target Cell & GPUs with one back-end
19:41:40 <Axman6> it's got lots of support, so hopefully it will
19:41:51 <Axman6> (all the GPU and major CPU makers are backing it)
19:42:08 <brad_larsen> I wonder how architecture-agnostic it will be in terms of performance
19:42:13 <jmcarthur> brad_larsen: sounds similar to stuff conal is working on
19:42:17 <brad_larsen> I looked at the spec a whiel ago, and it looks very similar to CUDA.
19:42:54 <brad_larsen> s/performance/efficiency
19:43:23 <brad_larsen> will an openCL program be roughly as efficient on Cell as it is on GPU?
19:43:37 <Axman6> yeah, they're very similar
19:43:59 <Axman6> well, that depends an a lot of things... and no one would really know just yet
19:43:59 <brad_larsen> in my limited experience, Cell is nastier to program.
19:44:14 <brad_larsen> although CUDA is pretty nasty :-)
19:44:51 <Axman6> heh
19:45:05 <Axman6> bleh, need to get back to this Ada tutorial -_-
19:55:09 <dufflebunk> Can Control.Exception.bracket change the order of stuff getting printed to the screen?
19:55:44 <dufflebunk> If I don't use it, then things get printed in the expected order. But if I do use it, the putStr in the bracket happen before the stuff that should have preceeded it.
19:56:13 <dufflebunk> Ah, nm. Not quite what was happening
19:57:11 <dufflebunk> I had the arguments backwards
19:57:18 <jaredj> is there some sort of remedial parsec tutorial?
19:58:45 <jaredj> i thought i got it but i need to 'try' again
19:58:53 <monochrom> haha
19:58:56 <Saizan_> eheh
19:59:11 <Saizan_> use ReadP or polyparse :)
19:59:20 <monochrom> @remember jaredj [on parsec] i thought i got it but i need to 'try' again
19:59:20 <lambdabot> Done.
19:59:28 <jaredj> :)
19:59:35 <Saizan_> or even uu-parsinglib
19:59:39 <jaredj> ??
19:59:54 <kingdj> monochrom, try http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
20:01:30 <Saizan_> jaredj: those are other parsing combinator libraries that don't default to committing after the first match
20:02:18 * BMeph waits for the uu_hakusho tutorial...
20:02:19 <jaredj> many thanks
20:02:30 <Saizan_> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html <- this is the parsec tutorial, btw
20:02:50 <jaredj> i think my problem is there are too many layers between me and parsec
20:03:07 <monochrom> I must record this as the greatest example of freenode-style addressing.
20:03:17 <jaredj> i'm using tagsoup-parsec and i think it's eating the tags preemptively
20:03:42 <jaredj> but when i read the source it all seems so simple
20:04:12 <Saizan_> what do you mean by preemptively?
20:05:09 <jaredj> i mean, i think if i try openTag "FOO", it's still consuming something
20:06:09 <jaredj> in other languages, when i don't understand things, i put in print statements
20:06:24 <jaredj> in haskell, heretofore, i've understood most things
20:06:39 <jaredj> now, *paf* a wall.
20:06:57 <jaredj> that was unsatisfying. perhaps *gonk*
20:07:13 <monochrom> Debug.Trace.trace may help you.
20:08:30 <monochrom> But is “try (openTag "FOO")” supposed to consume? I think it is. I mean it should consume if successful.
20:08:39 <Saizan_> yeah
20:08:48 <monochrom> If you find it consume if fail, that's another story.
20:10:45 <TacticalLongcat> nice. "real" quotation marks to distinguish meta/object
20:11:20 <monochrom> It definitely works better than "try (openTag "FOO")" :)
20:12:01 <jaredj> monochrom, what did you say?
20:12:02 <TacticalLongcat> ≫ stringE "foo" ≪
20:12:16 <gwern> '    * 114,790 downloads of the Windows installer (!!)
20:12:17 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
20:12:17 <gwern>     * 2,790 installs of the generic unix source tarball (complementing the packages provided on each distro).
20:12:29 <gwern> poor windows users; they must be really hard off
20:12:33 <gwern> @messages
20:12:33 <lambdabot> Wraithan said 2h 33s ago: I pinged you email for an account on the haskell wiki so I could add my config and screenshot to the collection.
20:12:53 <araujo> bit offtopic question, just collecting some suggestions if possible ... anyone knows a good domain registrant?
20:12:55 * Axman6 did not know about @messages
20:13:00 <Berengal> Wow, 114k windows downloads?
20:13:03 <monochrom> source tarball isn't exactly a popular venue
20:13:09 <Berengal> I wonder how many there are on linux then...
20:13:22 <Axman6> araujo: nearlyfreespeech.net
20:13:33 <araujo> Axman6, thanks, i check it out
20:13:39 * Berengal installs from source because he's on ubuntu
20:13:41 <monochrom> jaredj: I said that try... is still supposed to consume when successful.
20:13:44 <Axman6> they're damn cheap, for both registration and hosting
20:13:48 <TacticalLongcat> is there any real point to using the source tarball instead of the binary one on linux..?
20:13:53 <dons> gwern: yeah,  I think the Windows users really are hard up.
20:14:02 <dons> TacticalLongcat: you would only use it if your distro didn't bundle ghc
20:14:27 <gwern> I wonder whether those downloads are for haskellers who happen to be using windows, or windows users who'd like to be haskellers
20:14:28 <Adamant> or you don't trust ghc binaries but do trust the code
20:14:30 <Adamant> etc.
20:14:31 <Berengal> dons: You're forgetting the generic minary
20:14:33 <BMeph> But...ubuntu bundling is teh suck. :\
20:14:37 <dons> or if you wanted to reproduce exactly the spec of the platform
20:14:47 <gwern> if the latter I may be mistaken in denigrating the value of windows support
20:14:51 <TacticalLongcat> dons: debian does bundle ghc, but I prefer the tarballs. I was just wondering about building yourself vs. binary
20:14:59 <araujo> Axman6, i can see :)
20:15:07 <dons> gwern: it is certainly very important to provide windows installers
20:15:09 <Adamant> gwern: there are some fairly smart people who develop on Windows.
20:15:15 <Berengal> gwern: I started haskell on windows
20:15:15 <monochrom> Hmm, minary. I like that new word. :)
20:15:18 <dons> they're historically around 50% of ghc downloads.
20:15:21 <dons> maybe more.
20:15:35 <Adamant> gwern: mostly because they're in the MS ecosystem somehow for work reasons
20:15:50 <Berengal> I was in the MS ecosystem for gaming reasons...
20:15:59 <Adamant> lol, that happens too.
20:16:10 <Adamant> people doing 3D work.
20:16:11 <monochrom> I use virtual machines to screw both ecosystems.
20:16:15 <gwern> the poor people. my linux hobbyist position prejudices me at times
20:16:40 <Berengal> I'd love to get linux at work...
20:16:44 <Adamant> gwern: you gotta eat. MS money is as green as anyone else's.
20:16:59 <lolcat420> Are there implementations of specific sort algorithms in hackage? Insertion/Heap/Shell/etc ?
20:17:00 <gwern> their shit smells as sweet, as the saying goes?
20:17:00 <Berengal> I might get solaris though
20:17:09 <Adamant> and it's not like Apple and Red Hat aren't also evil.
20:17:16 <monochrom> But anyway, I use binary dist if available.
20:17:29 <jaredj> monochrom: that's the sort of thing i want to know but don't. can you elaborate?
20:18:38 <monochrom> For example “try (string "hello")”. If you use it, and the input stream is at "hello" right now, consumption will happen, since it's a success.
20:19:05 <gwern> lolcat420: at a guess, the edison packages might have some
20:19:23 <lolcat420> gwern: thanks
20:19:47 <gwern> lolcat420: but most sorts over generic lists are easy to write
20:19:53 <monochrom> try is meaningful only when you use it like “try x <|> y” where you expect a possibility of failure and falling back to y.
20:20:03 <jaredj> monochrom: i do expect that
20:20:04 <gwern> it's sorts over things like Seq that're more challenging
20:20:46 <TacticalLongcat> @src Seq
20:20:46 <lambdabot> Source not found.
20:20:51 <BMeph> gwern: Doesn't Seq auto-balance? :)
20:20:52 <monochrom> OK, if you do “try (string "hello")” and the input stream is at "hi", should be no consumption.
20:20:58 <TacticalLongcat> @src Data.Sequence.Seq
20:21:03 <lambdabot> Source not found. :(
20:21:11 <jaredj> agree. but in between me and the stream is tagsoup-parsec
20:21:33 <TacticalLongcat> .. or was it Seq.Sequence
20:21:39 <jaredj> and i think it may be consuming a Tag whether it's the one I want or not
20:21:43 <monochrom> I think so far there is no difference.
20:22:46 <monochrom> Because you're doing “try (tagsoup_function_here)”. try being outer has overriding power.
20:23:12 <jaredj> i.e. i say try {do openTag "THIS"; other} <|> try {do openTag "THAT"; bla}
20:23:46 <jaredj> and i think the first parser consumes a tag, finds out it's not THIS, and fails - but then the other one fails too because the tag's already gone
20:23:47 <shapr> @yow !
20:23:47 <lambdabot> Should I start with the time I SWITCHED personalities with a BEATNIK
20:23:47 <lambdabot> hair stylist or my failure to refer five TEENAGERS to a good OCULIST?
20:24:26 <monochrom> something else in the context may be the cause.
20:24:41 <Axman6> whoever wrote @yow was pretty messed up...
20:24:57 <dolio> @go zippy the pinhead
20:24:58 <lambdabot> http://www.zippythepinhead.com/
20:24:58 <lambdabot> Title: Zippy the Pinhead
20:25:31 * jaredj gets a drink
20:28:34 <dolio> I can't believe I'm hearing MUSIC without th' use of EAR BUDS!
20:29:27 <Berengal> I want to play rock band, but it's 5:30 AM
20:36:30 <Axman6> o/
20:37:12 <maclinlarsen> oops, im not very good on a mac still
20:37:30 <maclinlarsen> i was trying to do a backslash :(
20:37:53 <Axman6> heh. what'd you do instead?
20:39:05 <maclinlarsen> part the channel
20:39:45 <maclinlarsen> it was shift + alt + 7 to do a backslash, i do shift + cmd + 7
20:39:51 <maclinlarsen> did*
20:40:22 <jaredj> readline has C-x e to pop up an editor on the line being edited
20:40:39 <jaredj> ghci doesn't appear to have this. does it have it and i don't know?
20:44:02 <aavogt> jaredj: which version of ghc do you have? (since about 6.10.2, ghc doesn't use readline at all)
20:45:02 <maclinlarsen> Axman6: have you ever done assembly?
20:45:38 <Axman6> a little. the only stuff i've done is asm for a virtual machine my uni uses, and SPARC (<3)
20:45:39 <jaredj> aavogt: i think that's my point
20:45:54 <jaredj> aavogt: ghci isn't showing me all the coolness i've come to know and love in bash
20:47:41 <maclinlarsen> i heard it was like masochism for programmers
20:48:36 <monochrom> readline is the coolness behind, but licensing problems is a barrier. many ghc users don't want to be locked into the GPL, that's all.
20:49:09 <Saizan_> jaredj: trac.haskell.org/haskeline has an user guide, maybe you can find what you need
20:49:25 <jaredj> Saizan_: many thanks
20:49:43 <jaredj> monochrom: *nod*
20:55:29 <jaredj> agh!!
20:55:37 <Axman6> :O
20:55:45 <jaredj> Saizan_: yes, that documentation says about what i expected
20:55:59 <jaredj> i.e., line editing is there, but cool features - meh
20:56:07 <jaredj> for example, readline has a kill buffer
20:56:45 <jaredj> all the stuff i've deleted i can put back with C-y
20:56:54 <jaredj> i just found out haskeline does not have that
20:57:48 <Berengal> Then fix it? :)
20:57:53 <jaredj> hehe
20:57:56 <jaredj> i should
20:58:04 <jaredj> is haskeline from scratch?
20:58:20 <jaredj> was there some editline in there at one point, and then it got replaced by haskeline, or something?
20:58:31 <Berengal> IIRC ghc still has readline support. You just have to recompile it yourself with the correct flags set
20:58:38 <jaredj> ah
20:59:31 <Berengal> 6.10.2 used editline, which was crap to say the least
20:59:38 <Phyx-> agreed
20:59:57 <Berengal> And before that it used readline
21:02:39 <abuiles> Hi guys, I have been facing an error, which Is not really meaningful , and when I google it, I just get like 2 results.....  maybe someone knows something about it ? is this one http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3094#a3094  thanks in advance
21:03:33 <Berengal> abuiles: ghc-pkg remove network && cabal install network
21:03:38 <Berengal> That's my suggestion at least
21:03:45 <Berengal> (perhaps clear out the folder as well)
21:04:30 <Phyx-> lol, love the "Sorry." at the end :P
21:04:40 <monochrom> I love the whilst.
21:05:18 <Phyx-> :P
21:08:21 <DiaperDrake> Tired of Niggggers and their monkeyshines?  Recognize that the shitskin Homo Erecti are wrecking civilization?  Then discuss the politics of dealing with the feral Negro Beast with us at Chimpout.com!  http://www.chimpout.com/forum
21:08:56 <d4> oh no, a monad
21:09:42 <Phyx-> wow... now that's random spam
21:10:31 <pikhq> I do believe that that needs to be stuck in the list monad and guarded against.
21:10:39 <Axman6> oh damn, i thought this was #macosx where i have ops :(
21:10:43 <Axman6> @where ops
21:10:44 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
21:10:44 <lambdabot> mauke
21:11:54 --- mode: ChanServ set +o dibblego
21:11:58 --- kick: DiaperDrake was kicked by dibblego (dibblego)
21:12:03 --- mode: dibblego set -o dibblego
21:12:10 <hackagebot> bindings-common 0.2 - Low-level library bindings, base package. (MauricioAntunes)
21:12:22 <Axman6> ta dibblego :)
21:12:38 * Axman6 just kicked him from #macosx too
21:16:11 <hackagebot> bindings-posix 0.0.1 - Check bindings-common package for directions. (MauricioAntunes)
21:17:16 <hackagebot> bindings-libusb 0.0.5 - Check bindings-common package for directions. (MauricioAntunes)
21:18:57 <abuiles> Berengal : Thanks ! That worked out !
21:21:10 <BMeph> Someone needs to tell those chimpout.com folks that "there are no niggers on teh intarwebz"... ;p
21:21:27 <Elly> I have a better plan
21:22:02 <Phyx-> which is?
21:22:18 <d4> hmm
21:22:27 <Elly> we continue to entirely ignore the transparent trolling attempt :P
21:22:28 <d4> I don't know if I believe lambdabot here
21:22:36 <d4> @pl \f a -> zip a $ map f a
21:22:37 <lambdabot> ap zip . map
21:22:46 <Phyx-> hmm I don't feel like coding...
21:23:01 <Phyx-> @type ap
21:23:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:23:03 <monochrom> @type ap zip . map
21:23:04 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
21:23:20 <d4> the type looks good
21:23:23 <Axman6> :t (&&&)
21:23:24 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
21:23:25 * pikhq notes that ap is crazy
21:23:44 <Axman6> :t (id &&& (f :: a -> b))
21:23:45 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
21:23:45 <lambdabot>       from the context ()
21:23:45 <lambdabot>       arising from a use of `f' at <interactive>:1:9
21:23:47 <allbery_b> ap is fine, it's the monads t works with that can be crazy
21:23:53 <d4> Axman6: wtf
21:23:54 <Axman6> :t (id &&& (undefined :: a -> b))
21:23:55 <lambdabot> forall b b1. b -> (b, b1)
21:23:57 <Phyx-> pikhq: why? if you look at the type, what ap itself does is not so crazy
21:24:04 <Axman6> :t map (id &&& (undefined :: a -> b))
21:24:06 <lambdabot> forall a b. [a] -> [(a, b)]
21:24:12 <pikhq> Phyx-: That it is S on the monads is crazy.
21:24:23 <Axman6> :t foo f = map (id &&& f)
21:24:24 <lambdabot> parse error on input `='
21:24:32 <Axman6> :t let foo f = map (id &&& f) in foo
21:24:34 <lambdabot> forall a c'. (a -> c') -> [a] -> [(a, c')]
21:25:00 * BMeph thinks ap is super sexy and wants to have its babies...metaphorically speaking. :)
21:25:20 <dmwit> :t map . (id &&&)
21:25:20 <pikhq> @pl \f -> map (id && f)
21:25:21 <lambdabot> map . (id &&)
21:25:21 <lambdabot> forall a c'. (a -> c') -> [a] -> [(a, c')]
21:25:27 <dmwit> too slow!
21:25:37 <d4> ... did I
21:25:52 <d4> just mention something everybody here is already familiar with
21:26:04 <Phyx-> lol
21:26:23 <dmwit> Nah, those people are just that crazy smart. ;-)
21:26:25 <pikhq> d4: I take it you're not familiar with the S combinator.
21:26:28 <Phyx-> what does @pl use? pointfree or pointless?
21:26:35 <d4> pikhq: I am not.
21:26:36 <Axman6> d4: did you just call me crazy smart?
21:26:41 <dmwit> Phyx-: eh?
21:26:47 <Axman6> uh, dmwit, not d4
21:26:52 <Phyx-> Axman6: no, he just called you a person
21:26:56 <Axman6> god damn, that's like the third time today
21:26:58 <pikhq> s x y z = x z (y z)
21:26:59 <Phyx-> dmwit: which library i mean
21:27:48 <d4> pikhq: oh, is this a lambda-calculus thing?
21:27:50 <d4> I see
21:27:58 <d4> perhaps it's vaguely familiar
21:28:08 <pikhq> It's a combinatorial calculus thing.
21:28:27 <pikhq> Anyways, ap for the function monad is S.
21:28:43 <pikhq> It just happens to be a function on all the monads, not just the function monad.
21:28:58 <pikhq> @src ap
21:28:58 <lambdabot> ap = liftM2 id
21:30:00 <d4> oh
21:30:46 * Phyx- doesn't feel like coding on a sunday night, go figure
21:31:27 * Elly feels most like coding then :)
21:32:20 <BMeph> d4: CL, not LC. ;)
21:32:38 <d4> well at any rate the original expression does what I expect
21:32:42 <d4> in ghci: (\f a -> zip a $ map f a) (*2) [1,2,3]
21:33:03 <d4> but the other doesn't: (ap zip . map) (*2) [1,2,3]
21:33:28 <pikhq> > (\f a -> zip a $ map f a) (*2) [1,2,3]
21:33:29 <lambdabot>   [(1,2),(2,4),(3,6)]
21:33:37 <pikhq> > (ap zip . map) (*2) [1,2,3]
21:33:38 <lambdabot>   [(1,2),(2,4),(3,6)]
21:33:42 <d4> wha
21:33:44 <Phyx-> lol
21:33:49 <pikhq> PEBKAC.
21:33:50 <d4> I get "No instance for (Monad ((->) [a]))"
21:34:00 <Axman6> > map . (id &&&) (*2) $ [1..6]
21:34:01 <lambdabot>   Couldn't match expected type `a -> b'
21:34:07 <Axman6> hmm
21:34:09 <copumpkin> :o
21:34:22 <copumpkin> it's bad when a -> b is your expected type
21:34:23 <BMeph> pikhq: Correct - all signs point to a PEBKAC error. ;)
21:34:35 <d4> pikhq: not AFAIK
21:34:41 <Axman6> :t map . (id &&&) (*2)
21:34:42 <lambdabot>     Couldn't match expected type `a -> b'
21:34:42 <lambdabot>            against inferred type `(a1, c')'
21:34:42 <lambdabot>     In the second argument of `(.)', namely `(id &&&) (* 2)'
21:34:44 <davidL> > map (id *** (*2)) [1,2,3]
21:34:46 <lambdabot>   No instance for (GHC.Num.Num (b, b'))
21:34:46 <lambdabot>    arising from the literal `1' at <i...
21:34:46 <Axman6> :t map . (id &&&)
21:34:48 <lambdabot> forall a c'. (a -> c') -> [a] -> [(a, c')]
21:35:03 <davidL> > map (id &&& (*2)) [1,2,3]
21:35:05 <lambdabot>   [(1,2),(2,4),(3,6)]
21:35:11 <copumpkin> I much prefer it when a -> c is the expected type
21:35:13 <Axman6> :t map . (id &&&) (*2) $ [1..10]
21:35:14 <lambdabot>     Couldn't match expected type `a -> b'
21:35:14 <lambdabot>            against inferred type `(a1, c')'
21:35:14 <lambdabot>     In the second argument of `(.)', namely `(id &&&) (* 2)'
21:35:21 <Axman6> huh
21:35:24 <d4> um. what possible mistake could I have made ...
21:35:29 <copumpkin> I want forall a b. a -> b to be the expected type
21:35:36 <d4> is there anything else that needs to be imported besides Monad?
21:35:42 <Saizan_> d4: you need to import Control.Monad.Instances
21:35:44 <BMeph> :t (map . (id &&&)) (*2) $ [1..10]
21:35:45 <lambdabot> forall a. (Num a, Enum a) => [(a, a)]
21:35:52 <d4> Saizan_: gah. thanks
21:36:07 <d4> PEBDAU
21:36:20 <BMeph> d4: Control.onad.Reader works, too - and is fewer letters! ;p
21:36:28 <BMeph> Er, *.Monad
21:36:38 <d4> BMeph: one letter too few there eh
21:36:58 <BMeph> d4: Yep, thus the correction. ;)
21:37:16 <d4> thx, yes, that's all it needed
21:37:37 <Axman6> huh, my bank's SSL cert is being rejected by my browser... sais the issuer is wrong (the cert says it's verisign)
21:37:58 <d4> hrmph. how would I have known that without asking?
21:38:10 <BMeph> Axman6: It's a trap! Kill it!!! ;p
21:38:11 <d4> the documentation I see doesn't mention Control.Monad.Reader
21:38:31 <coco> how can apply a function n times (f (f (f ... n))) ?
21:38:37 <Axman6> well, there's no way i'm entering my password, that's for sure :P
21:38:53 <conal> @type iterate
21:38:55 <lambdabot> forall a. (a -> a) -> a -> [a]
21:39:04 <conal> coco: use iterate and !!
21:39:31 <copumpkin> beware though!
21:39:37 <conal> yeah?
21:39:44 <conal> oh, yeah.
21:39:51 <copumpkin> you can get stack overflows if you're not careful
21:40:00 <BMeph> foldr (.) id? :)
21:40:30 <BMeph> Better yet, foldr (.) id . replicate? :)
21:40:40 <conal> that's a nice one also
21:40:49 <copumpkin> zomg
21:40:55 <copumpkin> @type foldr (.) id . replicate
21:40:57 <lambdabot>     Couldn't match expected type `[a -> a]'
21:40:57 <lambdabot>            against inferred type `a1 -> [a1]'
21:40:57 <lambdabot>     In the second argument of `(.)', namely `replicate'
21:41:01 <copumpkin> aw
21:41:11 <conal> use SECs!
21:41:12 <d4> Axman6: thanks for the &&& queries back there ... I didn't see what you were doing at first, but scrolling back I get it now ;)
21:41:15 <BMeph> Sorry, co-pump.
21:41:19 <copumpkin> :'(
21:41:30 <Petrosian> @type foldr (.) id . replicate 5
21:41:31 <lambdabot> forall a. (a -> a) -> a -> a
21:41:32 <conal> @type (fmap.fmap) (foldr (.) id) replicate
21:41:32 <BMeph> :t (foldr (.) id .). replicate? :)
21:41:33 <lambdabot> forall a. Int -> (a -> a) -> a -> a
21:41:34 <lambdabot> parse error on input `:'
21:41:35 <BMeph> :t (foldr (.) id .). replicate
21:41:37 <lambdabot> forall a. Int -> (a -> a) -> a -> a
21:41:50 <BMeph> copumpkin: Better? ;)
21:41:59 <conal> or result.result if you have result defined.
21:42:00 <copumpkin> that's more like it
21:42:04 <conal> @where SEC
21:42:04 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
21:42:27 * jmcarthur has been spending way too much time in TypeCompose and category-extras
21:42:47 <conal> jmcarthur: the cure: spend more time in DeepArrow ;)
21:42:48 <copumpkin> jmcarthur: beware, many have ventured into that dark land, and few have ever returned
21:42:52 <jmcarthur> it's almost like i can barely remember how to define a data type and instances from scratch!
21:43:13 <conal> jmcarthur: best forgotten, along with goto.
21:43:26 <copumpkin> and comefrom
21:43:34 <jmcarthur> great way to confuse my C programmer coworkers
21:43:36 <conal> i like conor's phrase: "data structures are data without structure"
21:43:41 <BMeph> Heh-heh: okmij.net, conal.net, comonad.reader, and sigfpe.blogspot.com; the four horsemen of the Haskell Apocalypse. ;p
21:43:54 <conal> BMeph: !
21:44:21 <ray> hasknarok
21:44:22 <jmcarthur> BMeph: but can you label which is which?
21:44:32 <byorgey> conal: what does that quote mean?
21:44:40 <BMeph> jmcarthur: They'd be confused by 'Segmentation fault' is not a valid control mechanism." ;)
21:44:57 <byorgey> @remember BMeph okmij.net, conal.net, comonad.reader, and sigfpe.blogspot.com; the four horsemen of the Haskell Apocalypse.
21:44:57 <lambdabot> Good to know.
21:45:17 <conal> byorgey: i think conor is playing with two meanings of "structure" -- the latter being algebraic structure.
21:45:20 <d4> OK, now how do I find out what I need to import to get the &&& operator
21:45:34 <d4> (combinator)
21:45:37 <byorgey> conal: ah, ok, I get it =)
21:45:50 <byorgey> @index (&&&)
21:45:50 <lambdabot> Control.Arrow
21:45:52 <conal> i also like conor's sound bite "types don't just contain data -- they explain data"
21:45:57 <byorgey> d4: like that =)
21:46:18 <d4> byorgey: thanks... so I need access to lambdabot?
21:46:24 <d4> byorgey: I mean
21:46:39 <d4> that's a pretty easy way to find it as long as I'm on the chan
21:46:42 <BMeph> d4: No, just access to IRC. Lambdabot access is trivial after that. ;)
21:46:42 <conal> so, i guess a data structure is data without explanation.
21:46:51 <d4> BMeph: yeah
21:46:52 <vav> @hayoo
21:46:53 <lambdabot> Unknown command, try @list
21:46:55 <byorgey> d4: lambdabot is often helpful for finding things.  you can also use Hoogle: haskell.org/hoogle
21:47:38 <d4> excellent
21:47:44 <vav> @where hayoo
21:47:44 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
21:48:00 <vav> d4: that's another useful haskell search indexing more libs
21:48:11 <jmcarthur> the only problem i have with type composition is when there are missing or multiple-choice instances
21:48:22 <d4> vav: thanks for that too
21:48:23 <jmcarthur> but that is just a preliminary library problem
21:48:25 <Phyx-> d4: hoogle is also available as a library offline, cabal install hoogle
21:49:02 <Phyx-> i find hoogle does better than hayoo on type searches
21:49:08 <d4> I haven't tried cabal yet... I wonder whether/how it would work where I installed GHC...
21:49:11 <vav> yeah, definitely
21:49:55 <Phyx-> @where cabal
21:49:56 <lambdabot> http://www.haskell.org/cabal
21:50:38 <d4> I should probably install these things on my own machine instead of the school's, since this stuff is not really for my class ;)
21:52:49 <erikc> conal: i'm fond of 'unstructured data is an oxymoron'
21:55:23 <d4> oh god
21:55:25 <d4> @pl \m n -> n `mod` m == 0
21:55:25 <lambdabot> flip flip 0 . ((==) .) . flip mod
21:55:30 <Axman6> ha
21:55:49 <Axman6> @pl mon n m == 0
21:55:50 <lambdabot> mon n m == 0
21:56:06 <Axman6> @pl \n m -> mod n m == 0
21:56:06 <lambdabot> flip flip 0 . ((==) .) . mod
21:56:37 <Axman6> :t (==) `on`
21:56:38 <lambdabot> parse error (possibly incorrect indentation)
21:56:43 <Axman6> :t ((==) `on`)
21:56:45 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
21:56:48 <d4> I'm almost tempted to try to understand that expression
21:57:08 <Axman6> don't do it! it violates Axman's rule of clear code!
21:57:25 <BMeph> equating == on (==)
21:57:31 <d4> the rule is not to try to understand unclear code?
21:57:37 <BMeph> Er, equating = on (==)
21:57:53 <Phyx-> @hoogle on --info
21:57:54 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
21:57:54 <lambdabot>  
21:57:54 <lambdabot> (*) `on` f = \x y -> f x * f y.
21:57:58 <d4> I would have to ignore all the monad tutorials
21:58:06 <aavogt> can pl be taught to apply 'on' and arrow stuff to fit in with the rest of #haskell?
21:58:22 <Petrosian> @pl \(a,b) -> ([a],b)
21:58:22 <lambdabot> first return
21:58:33 <Petrosian> It can give it a go
21:58:51 <aavogt> @pl \(a,b) -> (a+3,b-2)
21:58:52 <lambdabot> (3 +) *** subtract 2
21:59:03 <Saizan_> oh, i didn't know it knew how to use first
22:00:55 <andelf> it is in Control.Arrow, has type (Arrow a) => a b c -> a (b, d) (c, d)
22:01:03 <d4> I'm guessing *** is in Control.Arrow
22:01:04 <BMeph> Saizan_: You knew it could use (***)? :)
22:01:14 <Petrosian> @ty (***)
22:01:15 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:01:17 <d4> yep
22:01:39 <BMeph> "All signs point to 'Yes'." ;)
22:02:11 <byorgey> > ((+1) *** (*5)) (2,4)
22:02:12 <lambdabot>   (3,20)
22:02:31 <andelf> as function  a -> b is just an (Arrow (->) a b), so just treat it as a high order function in simple use.
22:03:55 <andelf> in `first return`, you can treat it as  first :: (a -> b) -> ((a,c) -> (b,c))
22:04:39 <andelf> so here return :: a -> [a], apply them all, you get the \(a,b) -> ([a],b)
22:28:24 --- mode: irc.freenode.net set +o ChanServ
22:58:34 <cjs> Hm. anybody have any thoughts on fixing this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7565#a7565
22:59:17 <copumpkin> why are you using guards there?
22:59:22 <copumpkin> where pattern matches would be sufficient?
22:59:31 <cjs> Would they?
22:59:44 <copumpkin> it can't figure whether  guards cover everything
22:59:50 <cjs> I started out with that, but had trouble with the syntax; perhaps you can show me.
22:59:50 <copumpkin> because you can do arbitrary computation in them
23:00:08 <mauke> matches Bid _ = xprice >= yprice
23:00:15 <mauke> matches Offer _ = xprice <= yprice
23:00:28 <copumpkin> you need to pull those out though
23:00:30 <cjs> Ah, extract another function for the where clause that does that?
23:01:31 <mauke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7565#a7566 (untested)
23:02:01 <copumpkin> I don't think that'll work
23:02:43 <copumpkin> well, first of all the original code won't compile :P
23:02:50 <copumpkin> cause I think you renamed Direction to Side
23:02:56 <copumpkin> (cjs)
23:03:12 <cjs> Oh, yeah, I did do that. Oops....
23:03:17 <mauke> er, whoops
23:03:19 <copumpkin> but it'd have to be case xquote of Quote _ Bid _ _
23:03:23 <mauke> I mean case xdir
23:04:03 <mauke> it compiles with that
23:04:13 <cjs> Actually, I hadn't realized I don't need ydir, either; handling a bid/offer pair was a later addition.
23:07:54 <dons> dufflebunk: so did you solve the float printing issue?
23:08:30 <dons> i can hack together a few C-based bytestring printing functions for primitive types, if you need, but you can probably roll them yourself
23:11:21 <dons> peteg, blackdog, Error: This package requires Cabal version: >=1.7
23:11:22 <dons> wtf?
23:19:50 <dufflebunk> dons: No, I decided that using the int version of the library was sufficient and it's about 4x faster on the haskell side.
23:20:40 <dbbddbdb> http://www.realworldhaskell.org/blog/ Error establishing a database connection ?
23:21:29 <dons> dufflebunk: the int version of which lib?
23:21:33 <dons> bytestring-show? show?
23:21:45 <dons> bos: ^^ rwh site down
23:21:51 <dons> as is defun2009, actually
23:21:52 <dufflebunk> No, the lib I'm wiriting the FFI for
23:21:53 <ray> the important part, book.realworldhaskell.org, still works
23:21:55 <dbbddbdb> I wanted to report an unfinished sentence in http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html (That residual string will</p>)
23:22:10 <dons> dbbddbdb: thanks!
23:23:14 <dufflebunk> It's a lib from work. The C library is all long internally anyways, and the float stuff has all sorts of rounding changes. So I'm not too concerned with the performance of floats. I was mostly worried that it being so slow meant I was doing something wrong.
23:26:00 <dons> serialising can be a bottleneck, esp if [Char] is involved
23:26:05 <slava> hi dons
23:27:03 <dons> heya slava. 'sup?
23:27:16 <slava> implementing register coalescing, its pretty tricky
23:27:41 <dons> ooh. interesting.
23:27:48 <dons> will you have benchmarks after the fact?
23:28:10 <slava> sure
23:30:16 <dufflebunk> dons: Yeah, that's what I'm seeing now. But the performance is good enough for now. For the stuff I do correctness is more important than speed, so long as it's in the ballpark of C speed.
23:30:41 <copumpkin> if I have a MPTC without functional dependencies and a method in it that doesn't involve some of the type variables covered by the MPTC, is there any way of calling that method?
23:30:50 <dons> k. sounds like there's a need to look over the perf. of the bytestring-show lib though
23:30:52 <copumpkin> it feels like there must be some way to say "hey, use this instance"
23:31:33 <dolio> copumpkin: No.
23:31:41 <copumpkin> no dirty nasty hacks?
23:31:52 <dolio> Functional dependencies. :)
23:31:56 <copumpkin> lol
23:33:05 <dons> copumpkin: you have to make it global somehow
23:33:18 <copumpkin> how do you mean?
23:33:47 <dolio> You can add a parameter that just gets ignored, but specifies the type somehow.
23:33:55 <copumpkin> class Moo a b where moo :: a -> a is the kind of situation I'm talking about
23:33:58 <copumpkin> hmm
23:34:22 <dons> well, you need coherence. it has to typecheck the same in every combination
23:34:29 <dons> oh, interesting.
23:34:49 <dons> so b is unused, and you have multiple 'bs'?
23:34:57 <copumpkin> maybe I can use implicit parameters to make this not entirely ugly, without going all the way to mmorrow's solution with no typeclasses
23:35:20 <copumpkin> dons: well there isn't a good reason to have a dependency other than the fact that I have no way to specify which instance I want to use
23:35:24 <dons> mm
23:35:35 <copumpkin> but I'm going to see if I can get it to behave the way I want it to with implicit parameters
23:35:44 <dons> seems like a job for phantom type parameters?
23:35:55 <copumpkin> hmm
23:37:07 * copumpkin ponders some
23:37:21 <dolio> Making it "moo :: b -> a -> a" is a common solution, but it's not ideal.
23:37:30 <copumpkin> yeah
23:38:04 <dons> or you squash it somehow, adding, say, | a -> b
23:38:27 <slava> dons: it eliminates 2 redundant copies in a trivial counted loop :)
23:38:42 <slava> other than loop inversion or unrolling, the body is optimal now
23:38:46 <dons> slava: that's a good result
23:38:50 <hackagebot> hTensor 0.1.1 - Multidimensional arrays and simple tensor computations. (AlbertoRuiz)
23:39:11 <slava> dons: the C++ code I was using as a base is pretty messy in places. working with complex data structures is a pain in C++, and intent is often obscured
23:39:31 <slava> tons of STL iterator code just vaporized and became usages of higher order functions
23:39:36 <dons> mmm
23:39:51 <slava> I'm not sure if the authors of the paper wrote the LLVM pass too. It differs from the paper in several places
23:39:58 <copumpkin> well I can get it working with implicit parameters
23:39:59 <slava> I wish more academics would publish code along with their papers
23:40:03 <copumpkin> obviously I guess
23:40:06 <copumpkin> slava: me too
23:40:29 <dons> there should be githubs associated with conferences
23:40:41 <dons> and you have to check your code in, and it gets published concurrently with the actual paper
23:40:52 <slava> dons: that would be awesome
23:41:15 <dons> it would change computer science  research as we know it :)
23:41:15 <ray> clearly their papers should be literate haskell
23:41:28 <dons> yeah, i bet literate style would be more popular
23:41:44 <SubStack> I agree very much.
23:42:13 <dons> i hope as the younger generation of researchers move into influential positions, we'll see more and more 'open' conferences, where code + content is truly open
23:42:19 <SubStack> an early draft of this thing I'm working on now was literate haskell
23:42:27 <dons> i don't think the ACM lock will last in its form
23:42:28 <SubStack> I expect later ones will be too
23:42:43 <dufflebunk> In the follow line, how would I get rid of the lamda? mapM (\ i -> oneAttr pFeat csAttr csS1 csS2 i >>= (return.snd)) [1..x]
23:42:44 * SubStack is pretty young ;)
23:43:20 * ray is 4
23:43:55 <SubStack> publishing this thing in the journal of experimental linguistics would be pretty neat
23:44:36 <SubStack> an open access online journal
23:44:43 <copumpkin> can anyone think of examples where there's more than one interesting two-operation algebraic structure on a given set?
23:45:19 * dufflebunk doesn't know what a two-operation algebraic structure is
23:47:26 <slava> copumpkin: any non-commutative ring has an 'opposite ring' structure where a*b = ba
23:47:27 <ray> one with two operations
23:47:35 <ray> like a ring
23:47:58 <slava> any matrix algebra has a lie algebra structure with [a,b] = ab - ba
23:48:04 <slava> there are tons of examples
23:48:08 <copumpkin> damn :)
23:48:09 <copumpkin> ok
23:48:30 <copumpkin> was hoping I could get away with a fundep where one clearly does not belong
23:48:37 <copumpkin> :P
23:48:38 <slava> or here's a silly one
23:48:47 <slava> the reals and complexes are isomorphic as sets (same cardinality)
23:49:36 <colpsmith> that's a very weak isomorphism :)
23:49:44 <slava> so if i is this isomorphism R --> C, you can define a ring structure on C that's not the standard one
23:49:54 <slava> a +' b = i^-1(i(a) + i(b)) etc
23:50:44 <copumpkin> here's a related question
23:50:52 <colpsmith> wait, there is a ring isomorphism between R and C?
23:50:55 <copumpkin> if I fix the set and one of the binary operations
23:51:07 <slava> no there isn't
23:51:10 <slava> there's a set isomorphism
23:51:14 <colpsmith> that's what I thought
23:51:38 <copumpkin> is there more than one other binary operation that would still maintain the structure?
23:53:27 <dufflebunk> ah ha, I needed >=> rather than >>=
23:53:48 <copumpkin> zomg kleisli's space ship
23:55:41 <copumpkin> (I'm trying if I can introduce any functional dependencies at all in my classes for two-operation algebraic structures, where the classes have type variables for the two operations and the set)
23:55:57 <copumpkin> *I'm trying to figure out
