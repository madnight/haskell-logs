00:09:19 <dancor> uh oh three dan*'s
00:09:41 <dancor> the danularity is near..
00:12:22 <dankna> wow
00:12:29 <dankna> and we all have nicks matching dan...
00:27:15 <etpace_> > head $ dropWhile (>1.6) $ (map (*0.3) [0..10])
00:27:16 <lambdabot>   0.0
00:27:46 <etpace_> > head $ dropWhile (<1.6) $ (map (*0.3) [0..10])
00:27:48 <lambdabot>   1.7999999999999998
00:28:17 <etpace_> While that gets a number "close" to 1.6, is there a way I can find the closest number to 1.6 out of all numbers in a list?
00:28:43 <opqdonut> multiple ways
00:29:44 <etpace_> How so?
00:30:10 <opqdonut> > let (smaller,bigger) break (>1.6) (map (*0.3) [0..10]) in (last smaller,head bigger)
00:30:11 <lambdabot>   <no location info>: parse error on input `in'
00:30:18 <opqdonut> > let (smaller,bigger) = break (>1.6) (map (*0.3) [0..10]) in (last smaller,head bigger)
00:30:20 <lambdabot>   (1.5,1.7999999999999998)
00:30:21 <opqdonut> oops :)
00:30:25 <rocketman> etpace,  head . sortBy (distance 1.6)
00:30:28 <opqdonut> you could do that and then compare which one is closer
00:30:36 <opqdonut> rocketman's is good too
00:30:45 <etpace_> distance seems handy
00:31:22 <opqdonut> the approach you want to use will depend on whether the list of values is a) infinite b) sorted
00:31:42 <rocketman> Something to bear in mind is that it the number that's 'just right' it doesn't have to sort the whole list
00:31:43 <opqdonut> for finite and unsorted, go with rocketman's. for sorted and possibly infinite, go with mine
00:32:01 <opqdonut> :t distance
00:32:04 <lambdabot> Not in scope: `distance'
00:32:17 <opqdonut> rocketman: it generally will have to sort the whole list
00:32:27 <opqdonut> or was prelude's sort some sort of selection sort
00:32:45 <rocketman> by sortBy I don't mean prelude sortBy
00:32:57 <rocketman> any sortBy that works is fine
00:34:07 <madhadron> @src hGetLine
00:34:07 <lambdabot> Source not found.
00:34:12 <opqdonut> a sorting algorithm won't generally be able to produce the smallest element before the whole list has been sorted
00:35:12 <Saizan> Prelude's sort is a lazy enough merge sort
00:35:15 <rocketman> with lazyness me might have something like   0 : insert 1 (insert 4 (insert 3 []))
00:36:14 <opqdonut> of course
00:52:08 <maartenm> triangles = map triangle [1..]
00:52:22 <maartenm> triangle 1 = 1
00:52:42 <maartenm> triangle n = n + triangle(n-1)
00:53:20 <maartenm> will haskell use dynamic recursion here? ('optimization')
00:53:26 <maartenm> and how would I do this with iterate?
00:53:44 <maartenm> if I do triangles = iterate triangle 1 , I get [1,1,1,...] of course
00:53:59 <sjanssen> maartenm: 'triangle n' will take O(n) steps (the answer is no)
00:54:02 <Twey> 1) no
00:54:09 <maartenm> ok
00:54:16 <Twey> 2) You need to keep track of the position
00:54:35 <Twey> So, try using a tuple of (n, t)
00:55:16 <maartenm> ok I'll try
00:55:33 <Twey> > iterate (\(n, t) -> (n + 1, n + t)) (1, 1)
00:55:34 <lambdabot>   [(1,1),(2,2),(3,4),(4,7),(5,11),(6,16),(7,22),(8,29),(9,37),(10,46),(11,56)...
00:55:40 <Twey> Hmm
00:55:41 <sjanssen> > let triangles = 0 : zipWith (+) triangles [1 ..] in triangles
00:55:42 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
00:55:46 <Twey> Not quite right
00:55:50 <Twey> Ah, there we have it :)
00:55:54 <maartenm> urgh.. so beautiful
00:55:54 <doserj> > scanl (+) 0 [1..]
00:55:56 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
00:56:05 <Twey> Nice!
00:56:05 <maartenm> ok, this place is depressing
00:56:16 <sjanssen> doserj: knew I was forgetting a better solution
00:56:17 <maartenm> but I should've known that
00:56:53 <maartenm> ok, so scanl does the optimization I need too
00:57:02 <maartenm> 'head' optimization, can one call it that?
00:57:30 <Twey> maartenm: Lists are optimised, functions aren't
00:57:38 <Saizan> a simple form of dynamic programming?
00:57:41 <sjanssen> > [n * (n+1) `div` 2 | n <- [0 ..]] -- best solution :)
00:57:42 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
00:57:47 <Twey> Any ‘value’ (function of no arguments)
00:57:58 <Twey> sjanssen: How is it better than doserj's?
00:58:01 <Twey> Oh
00:58:04 <Twey> More efficient :-P
00:58:20 <sjanssen> Twey: I'm not a fan of that "lists are optimised" statement
00:58:42 <Twey> Why's that?
00:59:02 <sjanssen> maartenm: the difference between these solutions is that GHC will remember top level values\
00:59:36 <maartenm> ok, but not because of caching, but because it has to
00:59:41 <sjanssen> maartenm: but it won't memoize the results of functions applied to values
00:59:44 <maartenm> because in my first attempt I tried to abuse caching
00:59:50 <maartenm> ah, ok
01:00:00 <sjanssen> maartenm: Haskell implementations aren't strictly required to do this, but they all do in practice
01:00:11 <sjanssen> also, in practice, no implementation memoizes functions
01:01:43 <sjanssen> Twey: that statement is simultaneously too specific and too general
01:02:16 <sjanssen> functions have all sorts of optimizations applied to them, and the sharing we're observing here applies to all values, not just lists
01:02:24 <Twey> It was a specific case
01:02:31 <Twey> I did state the more general case later
01:02:40 <Twey> Ah, that's a fair criticism.
01:02:58 <Twey> (the former, not the latter — I mentioned that)
01:03:51 <sjanssen> and now I'm wondering if the `div` solution I gave is really better.  Will GHC turn that division into a shift?
01:05:05 <doserj> probably not for Integers :)
01:06:39 <maartenm> ok, so now I have:   triangles = scanl (+) 0 [1..]
01:06:56 <maartenm> but, what is the most elegant way to add a piece of extra information to each triangle in a tuple
01:07:11 <Twey> maartenm: map it
01:07:22 <maartenm> or lambda?
01:07:25 <Twey> Or zip, rather
01:07:34 <maartenm> isn't lambda more elegant?
01:07:38 <Twey> triangles = zip [0..] $ scanl (+) 0 [1..]
01:07:45 <Twey> No
01:07:54 <maartenm> instead fo the (+) I mean..
01:08:09 <Twey> Depends on the information
01:08:15 <maartenm> calculated on the triangles
01:08:34 <Saizan> i'd use a map
01:08:51 <Twey> Yeah
01:08:53 <maartenm> #nonsensecode    triangles = scanl (\x -> (x, ndivisors n)) 0 [1..]
01:09:00 <maartenm> I on't know how to do that
01:09:02 <maartenm> ok
01:09:05 <maartenm> a map it is then
01:09:10 <Twey> What is ‘n’?
01:09:16 <maartenm> sorry
01:09:17 <maartenm> ndivisors x
01:09:20 <Twey> Oh
01:09:25 <Twey> I'd go with the map
01:09:29 <maartenm> ok
01:09:34 <Twey> Lambdas are rarely pretty
01:09:51 <maartenm> but map sounds so O(n^2)
01:10:01 <maartenm> because ndivisors takes O(n)
01:10:07 <Twey> It gets optimised
01:10:09 <maartenm> ah
01:10:17 <Saizan> map won't add to the complexity
01:10:34 <Saizan> it just applies a function to any value
01:10:59 <Saizan> so doing it in the lambda or with a separate map doesn't change anything but constant factors
01:11:17 <Saizan> and those should get optimized by fusion
01:11:27 <maartenm> ok
01:13:37 <ManateeLazyCat> Have an exsit function that match "find :: (a -> Bool) -> Seq a -> Maybe Int"?
01:13:57 <maartenm> btw is there a more elegant way to filter on tuples, than this?:     filter (\x -> fst x > 5) list
01:14:18 <dibblego> @type find
01:14:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
01:14:21 <dibblego> @type findIndex
01:14:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
01:14:46 <dibblego> filter ((>5) . fst) list
01:15:25 <maartenm> ok, of course..
01:16:32 <maartenm> damn you, euler 11
01:16:36 <maartenm> still takes way too long
01:17:56 <boml> I would like to find the first element in a list that satisfies a predicate. What is the correct way to go about this?
01:18:02 <Jedai> what's euler 11 ?
01:18:05 <dibblego> boml, find
01:18:14 <dibblego> > find even [1,3,5,4,7,8]
01:18:16 <lambdabot>   Just 4
01:18:19 <Jedai> maartenm: I mean what does this Euler problem ask
01:18:45 <maartenm> http://projecteuler.net/index.php?section=problems&id=12
01:19:00 <maartenm> it's easy enough, but I need a better 'divisors n' algorithm
01:19:00 <boml> dibblego: obviously. I just looked in the prelude. and it wasn't there...
01:19:04 <maartenm> or ndivisors n
01:19:13 <maartenm> but I'd liek to do that myself
01:19:14 <dibblego> boml, it is exported by Data.List
01:19:58 <Jedai> maartenm: We can suggest algorithm, though ?
01:20:08 <maartenm> well I know to look up until sqrt(n)
01:20:19 <maartenm> and then find the rest of the divisors with n/divisor
01:20:29 <maartenm> but I'm struggling a bit to get it in Haskell (only my second day with the language)
01:20:50 <boml> dibblego: yep. thx.
01:20:52 <Jedai> maartenm: in your case you don't _need_ to find the rest of the divisors, you just need to count them
01:21:18 <maartenm> hm, yes.. so 2*ndivisors - 1
01:21:48 <Dae> maartenm: euler is a nice way to learn haskell, a lot of the problems can be done really elegantly
01:25:08 <Dae> maartenm: it's a fairly small problem so your algorithm doesn't have to be that elegant
01:26:23 <ManateeLazyCat> Have an exsit function that match "find :: (a -> Bool) -> Seq a -> Maybe Int"?
01:26:33 <ManateeLazyCat> I want search some value in Sequence
01:26:55 <ManateeLazyCat> Or how to transform Sequence to List?
01:27:10 <ManateeLazyCat> I haven't saw `toList` function in Data.Sequence
01:27:35 <maartenm> well I've already gone down a lot in elegance, for the past 4 problems.. I want to make this one pretty
01:27:42 <dibblego> @pl (. Data.Foldable.toList) . find
01:27:43 <lambdabot> (. Data.Foldable.toList) . find
01:27:49 <dibblego> @type (. Data.Foldable.toList) . find
01:27:50 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => (a -> Bool) -> t a -> Maybe a
01:27:55 <dibblego> ManateeLazyCat, ^^
01:28:07 <Saizan> thre's also a Data.Foldable.find
01:28:07 <dibblego> @type (. Data.Foldable.toList) . findIndex
01:28:09 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => (a -> Bool) -> t a -> Maybe Int
01:28:49 <Saizan> ManateeLazyCat: Data.Foldable and Data.Traversable export many functions that are useful with Seq
01:29:29 <ManateeLazyCat> Saizan: Thanks! :)
01:29:40 <maartenm> dammit
01:29:46 <maartenm> now my ndivisors algorithm is this:
01:29:54 <maartenm>  n = 2 * (length $ filter (divides n) [1..isqrt(n)]) - 1
01:29:59 <maartenm> and it still takes too damn long
01:30:45 <ManateeLazyCat> Saizan: What's Foldable? Can you explain details?
01:31:06 <dibblego> Data.Foldable
01:31:48 <ManateeLazyCat> dibblego: Yep, i know, can you introduce Data.Foldable?
01:32:51 <Jedai> ManateeLazyCat: it's a typeclass for things that can have a foldr
01:33:06 <Jedai> ManateeLazyCat: or can be folded in general rather
01:33:16 <sjanssen> maartenm: you might take a less brute-force approach to the problem
01:33:43 <ManateeLazyCat> Jedai: Thanks, i see.
01:33:43 <maartenm> yeah but I can't use pen and paper at work :)
01:34:04 <maartenm> I can only pretend to be programming something
01:34:08 <maartenm> but yeah
01:34:11 <maartenm> needs some more analysis..
01:34:17 <Jedai> maartenm: Here, the rather naive approach perform in less than a second compiled
01:34:44 <maartenm> well I'm using hugs interactively
01:34:45 <sjanssen> maartenm: I'd start with the fact that triangular numbers are n * (n + 1) / 2, and that you can easily generate the number of divisors from the prime factorization
01:34:47 <maartenm> but still
01:35:09 <sjanssen> maartenm: oh.  Never use Hugs if you need speed
01:35:43 <doserj> my naive solution needs ~10sec in ghci :)
01:36:04 <Jedai> maartenm: Using Hugs and complaining about the speed isn't a good idea
01:36:35 <ManateeLazyCat> @type (. Data.Foldable.find) (a -> Bool) (Seq a)
01:36:36 <lambdabot> Pattern syntax in expression context: a -> Bool
01:36:36 <lambdabot> Not in scope: data constructor `Seq'
01:36:53 <ManateeLazyCat> @type (. Data.Foldable.find) (a -> Bool) (Data.Sequence.Seq a)
01:36:54 <lambdabot> Pattern syntax in expression context: a -> Bool
01:36:55 <lambdabot>     Not in scope: data constructor `Data.Sequence.Seq'
01:37:11 <Jedai> maartenm: just use GHC and GHCi if you want a REPL
01:37:21 <maartenm> ah, ok
01:37:24 <maartenm> it matters that much?
01:37:42 <maartenm> so when something takes minutes to run, it can mean hugs is at fault insetad of my algorithmic complexity?
01:37:47 <Jedai> maartenm: Hugs is a fine pedagogic tool to learn basic Haskell...
01:38:16 <ManateeLazyCat> @type (. Data.Foldable.find) (== 1) (Data.Sequence.Seq a)
01:38:17 <Jedai> maartenm: Well... without seeing your code I can't be sure
01:38:17 <lambdabot>     Not in scope: data constructor `Data.Sequence.Seq'
01:38:32 <Jedai> maartenm: but Hugs is pretty slow, for sure
01:38:33 <maartenm> triangles = map (\x -> x * (x+1) `div`  2) [1..]
01:38:43 <maartenm> ndivisors n = 2 * (length $ filter (divides n) [1..isqrt(n)]) - 1
01:38:52 <maartenm> euler12 = head $ filter (\x -> snd x > 500) (map (\x -> (x, ndivisors x)) triangles)
01:39:02 <doserj> maartenm: well your ndivisors is definitely too naive, still
01:39:02 <maartenm> (is now running for 5 minutes)
01:39:16 <doserj> maartenm: even for ghci
01:39:16 <maartenm> ok, I need the sieve of atkins then?
01:39:30 <ManateeLazyCat> dibblego: So i can use Data.Foldable.find to search Data.Sequence, and not need transform to list.
01:39:41 <Jedai> doserj: it is wrong but "too naive" ? I do almost the same thing and it works fine here
01:39:46 <maartenm> I feel like 18 again
01:40:06 <Jedai> maartenm: Nope, your ndivisors should be fine
01:40:33 <ManateeLazyCat> dibblego: NO, i think i still need transform to list, because i need get index
01:40:40 <Jedai> maartenm: except when it's wrong
01:40:45 <maartenm> heh
01:41:18 <maartenm> btw  divides n b = (n `mod` b == 0)
01:41:25 <Jedai> maartenm: think about the case where isqrt(n) *isqrt(n) /= n
01:41:47 <maartenm> ah then the -1 is silly
01:44:31 <Jedai> maartenm: by the way, your triangles is pretty inefficient, I don't think it has much weight in your problem but it could still be better
01:45:56 <maartenm> ok I rewrote the ndivisors with an if statement
01:46:09 <maartenm> I feel like an idiot but how else would I do that
01:46:26 <Jedai> maartenm: also, head . filter is like find but unsafe (safe in this case though)
01:46:30 <maartenm> ndivisors n = 2 * (length $ filter (divides n) [1..isqrt(n)]) - isSquare   (where iSquare is 1 if n is a square)
01:46:57 <Jedai> maartenm: why would you like to do it otherwise ? if _expressions_ are fine from time to time
01:47:07 <maartenm> I just don't udnerstand why it's so slow, you know
01:47:18 <maartenm> triangles!!50000
01:47:25 <maartenm> is very fast to give me a result
01:47:29 <yitz> maartenm: you can compute ndivisors from the exponents in the prime factorization
01:47:33 <Jedai> maartenm: Well Hugs is pretty slow
01:48:09 <doserj> Jedai: you really get <1sec with that nDivisors algorithm?
01:48:24 <Jedai> doserj: written in direct recursion sure
01:48:35 <Jedai> doserj: and compiled with -Oé
01:48:43 <Jedai> *-O2
01:48:44 <maartenm> (with the new ndivision I'm already waiting 2 minutes in hugs)
01:48:57 <yitz> ndivisors = sum . map ((+1) . length) . group . primeFactors
01:49:46 <Jedai> yitz: my primeFactors returned pairs (I think I used it in this problem but I'm not sure)
01:49:52 <doserj> yitz: s/sum/product/ I think
01:50:03 <yitz> oops, right doserj :)
01:50:08 <maartenm> I'll try that then.. although I'm starting to doubt that ndivisors is the problem
01:50:12 <doserj> that#s essentially what I did
01:50:23 <yitz> Jedai: yeah, that works too
01:50:24 <Jedai> maartenm: Nope, Hugs is the problem !!! ;)
01:50:34 <boml> why is the index function in ghc docs so slow? can I speed it up somehow?
01:51:42 <maartenm> I'll get ghc just to be sure
01:52:56 <Dae> maartenm: also, you're compiling it and not interpreting, right?
01:53:10 <Jedai> Dae: He's using Hugs...
01:53:43 <Jedai> Dae: Not exactly the right tool to work on Euler problems in Haskell :)
01:53:55 <maartenm> yeah I didn't know it was that bad
01:54:00 <Dae> well, most of the euler problems can be done with ghci
01:54:09 <maartenm> I'm used with working with interprative languages (Ruby, f.i.)
01:54:28 <maartenm> so I didn't expect hugs to be too slow or anything
01:54:41 <maartenm> but I'm getting ghc.. the problem is probably me and not hugs
01:54:42 <Dae> maartenm: well...ruby is somewhere between 50 and 100 times slower than ghc haskell....
01:54:58 <maartenm> 1.8 probably is, yeah
01:55:23 <Jedai> maartenm: even 1.9 is still massively slower than Haskell compiled by GHC
01:55:39 <maartenm> iirc, even C is slower than haskell at most benchmarked problems
01:55:51 <maartenm> anyway, I don't like Ruby for its speed :)
01:56:21 <maartenm> much like I don't like the ;ountains of Portugal for their cocktails
01:56:28 <maartenm> *mountains
01:56:34 <Jedai> maartenm: that's a little bit of an exageration, it would be more just to say that you can write extremely fast Haskell, though not always idiomatic
01:56:48 <Dae> the new ruby is faster?
01:57:01 <maartenm> it's JIT compiled
01:57:05 <maartenm> *much* faster
01:57:10 <maxote> Pnuts is a lot faster than JRuby
01:57:10 <Dae> would be
01:57:27 <Jedai> Dae: 1.9 is much much faster than 1.8 (and not only thanks to JIT)
01:58:07 <Dae> but C is usually faster than haskell, by a factor 2 or so if you don't go out of your way to optimize the haskell code
01:58:22 <Dae> (and end up defeating the point of writing haskell)
01:59:02 <PeakerWork> Dae: I think its more than a factor of 2 if you write idiomatic Haskell on a uniprocessor, but maybe that's just my experience
01:59:17 <maartenm> running it in ghci now...
01:59:18 <Jedai> On the other hand, C code is often much longer than equivalent idiomatic Haskell code
01:59:48 <Dae> maartenm: you'll want to compile that one
02:00:36 <Jedai> probably
02:00:45 <maartenm> yeah, apparently
02:00:54 <maartenm> winhugs crashed on the problem, btw
02:01:18 <Jedai> maartenm: Do you know that there's a Winghci now ?
02:01:19 <maartenm> I'll be 80 once I get to Proj. Euler # 200
02:01:25 <maartenm> no
02:01:42 <boml> how do I use find if the predicate returns IO Bool ?
02:01:53 <Dae> maartenm: well, around 40 they get really really boring to be honest
02:02:00 <Dae> they're fun till then
02:02:03 <Jedai> boml: Well you can't use it directly
02:02:20 <maartenm> I wish douglas hofstadter (sp?) would make a problem book like these
02:02:22 <Jedai> boml: You'll have to work in the IO monad
02:02:35 <boml> Jedai: is there such a thing as findM ?
02:02:43 <Dae> Jedai: yeah, my point was that if you want to do really fast haskell, like the shootout stuff, then  you might as well write C
02:03:04 <Jedai> boml: not really, You can easily write it yourself though
02:03:04 <lowlycoder> is there anyway to get real world haskell in texinfo format? (rather than HTML format)
02:03:23 <Jedai> boml: there's a filterM
02:03:49 <xenoblitz> hi to all, has anyone tinkered with Conal's Fran any time recently? Is there a way I can install it somehow or at least can someone tell me whether a piece of code I need to use an example is correct?
02:03:52 <Jedai> boml: but it's probably not the way to go (it would compute the whole filtered list)
02:04:12 <Dae> lowlycoder: there's a way to get it in print if that helps?
02:04:39 <boml> Jedai: i want to apply the doesDirectoryExist to all my drives until i get true.
02:05:12 <Dae> maartenm: is it working?
02:05:18 <Jedai> Dae: That's not completely true either, though you can't always get the best of both worlds, advanced optimisation can have surprising results from time to time (read Dons blog a little bit to see examples)
02:05:31 <lowlycoder> Dae: nah, i just like reading man pages
02:05:52 <Jedai> boml: Well, write yourself a findM
02:05:52 <maartenm> well
02:06:11 <maartenm> I'm trying to find where the hell that windows installer put my ghc bin
02:06:21 <boml> Jedai: that's what I will have to do.
02:06:41 <Jedai> maartenm: in GHCi, my version finished in less than a minute, though nothing very impressive
02:06:41 <PeakerWork> @type (>=>)
02:06:43 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
02:06:43 <Dae> Jedai: ohh I am.... I'm a sucker for MOAR speed. I do numerics in haskell so I have to be.
02:07:14 <Dae> maartenm: C:\ghc probably
02:07:25 <maartenm> yep, thanks
02:07:41 <yitz> @hoogle findM
02:07:41 <lambdabot> Data.IntSet findMax :: IntSet -> Int
02:07:41 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
02:07:41 <lambdabot> Data.Set findMax :: Set a -> a
02:07:54 <yitz> I guess not
02:08:06 <yitz> you can write it though
02:08:37 <maartenm> compile errors..
02:08:46 <Daimonic> Hail Haskell'ians
02:08:46 <maartenm> main expects IO?
02:08:49 <maartenm> it's my first compile
02:08:58 <Botje> yes.
02:09:02 <Botje> main has to have the type IO ()
02:09:08 <maartenm> I'll read the doc
02:09:11 <Botje> although people have reported IO a works too
02:09:21 <Botje> not sure if that's a bug and if it got fixed
02:09:24 <Daimonic> I am looking for, how the haskell prelude has implemented multiplication
02:09:56 <yitz> Daimonic: it's a primitive, implemented by each compiler however it wants
02:10:18 <yitz> Daimonic: (for the basic built-in numeric types)
02:10:42 <Jedai> Botje: it's just a relaxation of the standard
02:11:14 <Jedai> Botje: it's sometimes useful in small script where you recurse on main
02:11:26 <Dae> marteen:
02:11:30 <Dae> main = do
02:11:30 <Dae> putStrLn $ show answer
02:11:33 <Daimonic> yitz: The point is, I was wondering why optimized factorial is alot slower than Wolfram Mathematica
02:11:44 <Daimonic> optimized means, accumulating pattern + seq
02:11:45 <yitz> Daimonic: optimized?
02:11:46 <Dae> where answer is your function doing all the stuff
02:11:46 <Jedai> Dae: putStrLn . show == print
02:11:49 <Twey> putStrLn . show = print
02:11:58 <Twey> :)
02:12:08 <Dae> I can has print??
02:12:17 <yitz> Daimonic: on what type?
02:12:22 <Daimonic> Int
02:12:24 <Twey> Botje: I thought IO a was a deliberate feature
02:12:26 <Jedai> Daimonic: show the code
02:12:30 <Daimonic> ok
02:12:35 * Dae has been using putStrLn $ show for more than a year now
02:12:54 <yitz> Daimonic: there are only a few numbers you can take factorial of over Int
02:13:03 <maartenm> ok
02:13:08 <yitz> Daimonic: I was thinking Integer or Double
02:13:11 <maartenm> I compiled it, Dae (and Jedai)
02:13:21 <maartenm> it's been running for nearly a minute
02:13:30 <maartenm> well, it ran for 40s
02:13:33 <Jedai> maartenm: with optimization ? -O2
02:13:58 <Jedai> maartenm: that's pretty important
02:14:17 <maartenm> it says 'compilation is NOT required' ?
02:14:32 <Jedai> maartenm: just delete the .o
02:14:39 <maartenm> ah it makes an .o too
02:14:40 <maartenm> ok
02:14:50 <Saizan> or -fforce-recomp
02:14:55 <Jedai> maartenm: it won't recompile something that's already compiled
02:15:10 <yitz> > last . takeWhile (<= fromIntegral (maxBound ::Int)) . map (foldl' (*) 1 . enumFromTo 2) $ [2..]
02:15:11 <lambdabot>   2432902008176640000
02:15:16 <Jedai> Saizan: I never remember this option... ^^
02:15:30 <maartenm> hmm
02:15:36 <maartenm> it takes slightly shorter with optimization
02:15:38 <yitz> > (+ 1) . length . takeWhile (<= fromIntegral (maxBound ::Int)) . map (foldl' (*) 1 . enumFromTo 2) $ [2..]
02:15:40 <lambdabot>   20
02:15:46 <Jedai> maartenm: how long ?
02:15:50 <maartenm> 30s
02:16:00 <maartenm> I don't know what's wrong..
02:16:10 <Daimonic> http://codepad.org/MnhvRVst
02:16:11 <maartenm> you haev the same ndivisors?
02:16:16 <Jedai> maartenm: to have an exact time, launch your executable with the following option "+RTS -sstderr"
02:16:23 <Daimonic> yitz, Jedai
02:16:42 <yitz> > log $ fromIntegral (maxBound :: Int)
02:16:44 <lambdabot>   43.66827237527655
02:17:01 <yitz> > (/ log 2) . log $ fromIntegral (maxBound :: Int)
02:17:02 <lambdabot>   63.0
02:17:20 <Dae> maartenm: could you paste your code on hpaste.org?
02:17:25 <maartenm> yeah I will
02:17:35 <Jedai> Daimonic: You should put a, not n before the seq
02:17:41 <maartenm> (76576500,576)2,222,596,500 bytes allocated in the heap
02:17:49 <maartenm> Total time   19.08s  ( 19.06s elapsed)
02:18:02 <Jedai> Daimonic: but anyway that's a linear algorithm, I doubt Mathematica use a linear algorithm for his factorial...
02:18:25 <Jedai> maartenm: How "productive" does he say he is ?
02:18:54 <maartenm> 95.6%
02:18:59 <yitz> Daimonic: you want a `seq`, not n `seq`
02:19:04 <Daimonic> oh
02:19:07 <maartenm> of totaul user, 96% of total elapsed
02:19:09 <Daimonic> yeah right
02:19:15 <Daimonic> sorry, I made the code new, because I deleted it
02:19:18 <yitz> Daimonic: but that's not how you'd usually write it in Haskell
02:19:20 <Daimonic> I had a anyway
02:19:24 <Daimonic> not?
02:19:27 <Jedai> maartenm: interesting... your triangles number are Int, not Integer I hope ?
02:20:04 <maartenm> Dae: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6608#a6608
02:20:04 <maartenm> oops
02:20:04 <maartenm> my triangles are Integers
02:20:05 <maartenm> because I'm on a 32-bit machine
02:20:05 <Jedai> Daimonic: I would write fact n = product [2..n]
02:20:09 <yitz> > let fac n = foldl' (*) 1 [2..n] in fac 20
02:20:10 <lambdabot>   2432902008176640000
02:20:36 <Jedai> maartenm: that's not because you're on a 32-bit machine, it's just the default defaulting for compiled programs
02:20:44 <maartenm> no I mean
02:20:46 <yitz> Jedai: product is broken, it uses foldl instead of foldl'
02:20:48 <maartenm> Icoded Integer into everything
02:20:59 <Jedai> maartenm: just add a ":: [Int]" signature to your triangles
02:21:06 <Jedai> maartenm: it should be much faster
02:21:19 <yitz> Jedai: although in most cases you won't overflow the stack anyway because you can't take the factorial of big numbers anyway.
02:21:27 <Jedai> yitz: once compiled GHC optimize it
02:21:36 <etpace_> > map (1.6-) [1, 1.1, 1.2, 1.3]
02:21:38 <lambdabot>   [0.6000000000000001,0.5,0.40000000000000013,0.30000000000000004]
02:22:08 <yitz> Jedai: well, yeah, if you compile, and if you use -O2. Better to be in the habit not to rely on it.
02:22:10 <Daimonic> its now slower than before
02:22:12 <Jedai> yitz: Right, but it's very simple and clear (and fast if not for this stupid foldl)
02:22:22 <yitz> Jedai: yeah
02:22:43 <Jedai> Daimonic: what code are you using
02:22:45 <Dae> maartenm: and change the signature in ndivisors to Int -> Int
02:23:23 <dainanaki> @src guard
02:23:23 <lambdabot> guard True  =  return ()
02:23:23 <lambdabot> guard False =  mzero
02:23:28 <Jedai> Daimonic: anyway, if you want a fast factorial, you shouldn't be using linear algorithms, I can guarantee you that Mathematica doesn't
02:24:03 <Dae> maartenm: also, you're using a ton of needless lambdas. Instead of (\x -> mod x 2 == 0) you can just write (mod x 2 == 0)
02:24:17 <Dae> doesn't change anything, just syntax
02:24:25 <maartenm> oh, tat's syntactic sugar?
02:24:34 <maartenm> I mean, the x is recognized?
02:24:46 <maartenm> does it use the entire alphabet that way?
02:24:54 <Jedai> maartenm: I think Dae is slighly confused
02:25:09 <maartenm> btw, Jedai
02:25:12 <maartenm> it runs in 1.75 s now
02:25:13 <maartenm> with Int
02:25:16 <yitz> maartenm: (== 0) . (`mod` 2)
02:25:18 <etpace_> > let (smaller, bigger) = break (\(e, y) -> y >= 1.6) $ zip [0..] $ map (*0.3) [1..10] in head . sortBy (\(e, y) (e', y') -> y > y') $ map (\(e, y) -> (e, 1.6 - y)) [last smaller, head bigger]
02:25:20 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
02:25:25 <Jedai> ((== 0) . (`mod` 2))
02:25:41 <Jedai> maartenm: seems much more reasonnable
02:25:43 <etpace_> How can I get that to work? I guess its my sorting that's not doing it well
02:26:04 <Jedai> maartenm: I trust that 1.75s is fast enough for you ?
02:26:45 <Dae> sorry, mental blunder there
02:26:55 <Jedai> maartenm: My naive version run in 0.5s, with intelligent algorithm we can probably make this almost instantaneous
02:26:56 <maartenm> well, tbh, I hardcoded Integer
02:26:59 <yitz> etpace_: compare y y'
02:27:10 <yitz> @type compare
02:27:11 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
02:27:12 <maartenm> because some euler problems ran against Hugs' ceiling for Int numbers
02:27:14 <yitz> @type (>)
02:27:15 <lambdabot> forall a. (Ord a) => a -> a -> Bool
02:27:21 <etpace_> > let (smaller, bigger) = break (\(e, y) -> y >= 1.6) $ zip [0..] $ map (*0.3) [1..10] in head . sortBy (\(e, y) (e', y') -> compare y y') $ map (\(e, y) -> (e, 1.6 - y)) [last smaller, head bigger]
02:27:21 <maartenm> so I don't really feel satisfied
02:27:22 <lambdabot>   (5,-0.19999999999999973)
02:27:33 <etpace_> thanks
02:27:33 <maartenm> but at least I know that I need to use the Sieve of Atkin
02:27:43 <maartenm> instead of the naive ndvisiros
02:27:55 <wmealing_> when I read chat here, i feel like a moron.
02:28:05 <Daimonic> first of all this foldl algorithm for factorial was slower, second: it crashed my Lenovo Thinkpad
02:28:12 <Daimonic> damn you! :D
02:28:26 <yitz> maartenm: I don't think you need the sieve of Atkins for any Euler problem less than about 100 or 150
02:28:30 <Jedai> maartenm: You should try with Int and if it don't work, try Integer
02:28:44 <Daimonic> I was on battery mode
02:28:47 <Jedai> maartenm: and avoid hardcoding your functions for one or the other
02:28:50 <maartenm> ok I'll start problem #13
02:29:34 <Jedai> maartenm: with Integer my version takes 2.7s by the way
02:29:52 <maartenm> hmm, but I used Integer *everywhere*
02:30:02 <Jedai> maartenm: me too :)
02:30:07 <maartenm> that's odd
02:30:29 <veryalias> I am trying to install hmatrix-static, but it needs happy >= 1.17, but when I try to install happy 1.18.4 it does not show up as registered with "cabal -v list happy".
02:30:45 <maartenm> well my computer at work is three years old, pentium IV 3.0 Ghz, 4Gb Ram.. but still
02:30:49 <Jedai> maartenm: maybe not for the divisors count though... (I mean it must go to a little bit more than 500)
02:31:04 <maartenm> yeah I used it for the divisors count too
02:31:13 <Jedai> maartenm: but you version used length, so it used Int
02:31:22 <Jedai> maartenm: Nope, you used Int
02:31:29 <maartenm> hmm, yeah you're right
02:31:50 <boml> how do I case match on an (IO True) ?
02:31:57 <doserj> veryalias: happy is an executable, not a library. cabal list only cares about libraries
02:32:31 <doserj> boml: you don't.
02:32:42 <maartenm> hmm
02:32:53 <maartenm> Jedai: I just noticed it gave a different solution when I starte dusing Int
02:32:59 <doserj> boml: you run the IO action, and match on the result
02:32:59 <dcoutts> veryalias: make sure happy is on your path and it'll all be ok
02:33:03 <maartenm> I haven't actually checked the solution yet o.O
02:33:16 <boml> doserj: I cannot match on IO Bool ?
02:33:33 <Jedai> boml: either you bind the bool to a variable and then you case match on the result, or you use a combinator like guard, when or ifM (ifM isn't in the standard library)
02:33:33 <yitz> @remember dcoutts make sure happy is on your path and it'll all be ok
02:33:33 <lambdabot> Okay.
02:33:44 <opqdonut> @quote happy
02:33:45 <lambdabot> Korollary says: Can't you pretend that you've never heard of any of this and keep hacking happy java?
02:33:47 <boml> ok. thx guys
02:33:53 <dcoutts> :-)
02:35:22 <Jedai> maartenm: that's pretty strange... maybe there's still something wrong in your code ?
02:35:30 <Dae> largest downside of haskell is that it gives you physical pain to write java afterwards....
02:35:40 <maartenm> well, the solution with Integer was correct, apparently
02:35:47 <Jedai> maartenm: I get the same solution in both case
02:35:49 <araujo> Haskell makes you hate others language way too easy
02:35:52 <maartenm> the one with string-replace "Integer -> Int" wasn't
02:36:27 <Jedai> maartenm: and given the size of the solution and intermediary, there's absolutely no reason that using Int would change anything
02:36:47 <Jedai> maartenm: could you paste your code somewhere
02:36:53 <Jedai> @where hpaste
02:36:53 <lambdabot> http://hpaste.org/
02:37:04 <maartenm> well I alerady pasted my Integer solution there
02:37:20 <maartenm> <maartenm> Dae: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6608#a6608
02:37:24 <maartenm> and now my Int solution:
02:37:50 <maartenm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6612#a6612
02:38:06 <veryalias> dcoutts: thanks! thank you also doserj
02:38:19 <maartenm> don't mind the mess, we're spring-cleaning
02:38:31 <PeakerWork> I want a syntactic feature in Haskell:   an assign operator that can only assign into simple names (no pattern matches), and gives this name as a string arg to the RHS expression
02:39:42 <quicksilver> BZZZT warning, alpha-conversion violation detected
02:40:05 <PeakerWork> foo ?= blah bleh --> foo = blah bleh "foo"       and     foo ?<- blah bleh        foo <- blah bleh "foo"
02:40:23 <quicksilver> (although 'deriving Show' already violates alpha-conversion for constructors and the other derivings break various equational laws)
02:40:44 <PeakerWork> I want it so I can use Haskell as a "preprocessor" for a C-like language, and only semi-clumsily write C programs that look like:   main ?= Defun ....
02:40:53 <opqdonut> quicksilver: how come it violates alpha-conversion?
02:41:26 <Ferdirand> because changing the symbol name changes its semantics then ?
02:41:32 <PeakerWork> quicksilver: its a syntax-level thing so I can't see how it breaks anything.. that "foo" is already there in the code, its just not wrapped in quotes :)
02:42:27 <quicksilver> PeakerWork: alpha conversion says you can rename variables without changing semantics.
02:42:48 <quicksilver> foo ?<- putStrLn
02:42:54 <quicksilver> if I rename foo, the semantics change.
02:43:04 <Jedai> maartenm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6608#a6613
02:44:25 <PeakerWork> quicksilver: I think it is useful -- e.g above
02:44:39 <maartenm> yeah, I'll just skip forward to problem #13
02:44:51 <quicksilver> I didn't say it wasn't useful.
02:44:58 <quicksilver> I said it violated alpha-conversion.
02:45:10 <quicksilver> All kinds of things break equational rules but we should be honest about the cost.
02:45:18 <PeakerWork> quicksilver: why is alpha-conversion important?
02:45:42 <PeakerWork> I mean, you still get its benefits easily (Just expand the ?= macro..)
02:46:13 <quicksilver> optimisers rearrange code
02:46:22 <PeakerWork> quicksilver: they still can
02:46:23 <quicksilver> sometimes they have to rename variables to avoid shadowing
02:46:31 <quicksilver> that's why alpha conversion is important, basicaly.
02:46:43 <PeakerWork> quicksilver: then nothing is lost, because the post-macro code still retains alpha conversion
02:46:44 <quicksilver> so, yes, you'd have to expand that macro first.
02:46:49 <quicksilver> In that respect, it's like TH.
02:46:52 <quicksilver> (so why not use TH?)
02:46:58 <PeakerWork> I don't know, can TH do that?
02:47:12 <PeakerWork> Can TH define a new macro and then use it by name anywhere?
02:47:15 <etpace_> Do thinks like type Foo = (Num a) => [[a]]
02:49:49 <lowlycoder> is yi stilla ctively developed?
02:49:51 <Jedai> etpace_: ???
02:49:52 <etpace_> like that work*
02:50:12 <PeakerWork> I guess I'd need another macro:  ?\argc argv -> ...   to extract to:   ("argc", \argc -> ("argv", \argv -> ....   or:  ?\argc argv   to a ([String], func)
02:50:24 <Jedai> etpace_: try and you'll see (it don't work)
02:50:51 <Saizan> you can write $(giveName [d| main = putStrLn |])
02:51:05 <Saizan> and get it splice to main = putStrLn "main"
02:52:51 <Jedai> etpace_: or rather it works, but I don't think it does what you want, what do you want exactly
02:53:06 <boml> how do i get bitwise not in haskell?
02:53:18 <Saizan> boml: see Data.Bits
02:53:53 <etpace_> I'm getting a lot of problems with Integers and division and so on
02:54:20 <PeakerWork> Saizan: too much syntactic overhead
02:54:50 <etpace_> http://codepad.org/d7eT16hX I don't really understand this error message, can anyone help me?
02:54:59 <PeakerWork> Saizan: I want to create a C-like DSL where you build C-like AST's in Haskell. I want it to be bidirectionally FFI'able with C, so I need the names. Getting readable C code output is a plus too
02:55:34 <PeakerWork> Saizan: Then, I think that with such a language (Haskell preprocessing + C output) I can shift more and more of the logic to the Haskell side, and get a pretty powerful language with C-like operational semantics
02:56:06 <PeakerWork> Saizan: e.g: What C++ tries to do, except much more extensible. I want to first try to add to this language C typeclasses for example.  But for this to be usable, I can't pay huge TH syntactic overhead or use stringy-names everywhere
02:56:56 <Saizan> etpace_: what's the type of getY?
02:57:43 <etpace_> hm
02:57:52 <etpace_> (Num a) => a -> Integer?
03:00:45 <etpace_> I'm not really sure how to handle numbers well, because of the limitations of division etc
03:02:19 <yitz> @type toInteger
03:02:21 <lambdabot> forall a. (Integral a) => a -> Integer
03:02:44 <Saizan> etpace_: you have map stepY [0..(height-1)]
03:02:59 <Saizan> etpace_: but stepY looks like a number, not a function, to me
03:03:10 <yitz> @tyoe round
03:03:11 <Saizan> etpace_: so maybe you want map (+stepY) there?
03:03:12 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:03:30 <Saizan> etpace_: it's not a problem with division in this case.
03:07:22 <yitz> how about [0, stepY .. height - 1]
03:08:25 <maartenm> I keep getting amazed at those J solutions for the euler problems
03:08:30 <Jedai> PeakerWork: preprocessor ?
03:09:47 <Dae> maartenm: sadly J is what you'd call a "write only" language
03:09:49 <Jedai> maartenm: They are pretty amazing... On the other hand I wouldn't want to have to debug a J program written in this style
03:10:25 <maartenm> yeah but it's cool to show off to someone with it
03:11:18 <Jedai> maartenm: I noted that you did all your euler work in the same file, I suggest you create a module or two to put common functions you'll need in the Project and make a file by problem, that would be much easier to work with
03:11:40 <maartenm> yeah I usually just delete the things I don't need
03:11:57 <PeakerWork> Jedai: not exactly a preprocessor in the C sense.  Basically you can build a C program like:  main = Defun "main" ("argc", "argv") $ \argc argv -> Block [ ... ]
03:12:01 <maartenm> I did Problem #13 in Ruby too, I don't understand IO in Haskell yet
03:12:03 <Jedai> maartenm: especially when you've already done 50+ problems...
03:12:31 <PeakerWork> Jedai: I think with a bit of syntactic hackery in Haskell, you can get rid of most of the cumbersomeness, and be almost as short as normal C.  Then, you get to "generate" C code from Haskell really easily
03:12:49 <PeakerWork> Jedai: then, you put the C AST generators in a Reader monad of a build configuration, and you get the functionality of #ifdef's/etc
03:15:13 <etpace_> ah, should be *stepY Saizan
03:15:29 <etpace_> How could I decrypt that from the error message? I was looking for problems in results
03:17:48 <Jedai> maartenm: main = do s <- getContents; print (take 10 s)
03:18:12 <Jedai> oops, nope
03:19:28 <Jedai> main = interact (take 10 . show . sum . map (read :: String -> Integer) . lines)
03:20:14 <Saizan> etpace_: the error messages about infinite types are not very helpful in general, to find it i've moved getY outside of plotF, commented out plotF and seen that stepY was given a functional type
03:21:24 <Dae> I don't think you need the specific type signature for read Jedai?
03:22:02 <Twey> Nope — the context makes it clear
03:22:28 <Twey> :t sum . map read
03:22:29 <lambdabot> forall a. (Num a, Read a) => [String] -> a
03:22:31 <quicksilver> context + defaulting.
03:22:54 <quicksilver> context narrows it to Num + Read, defaulting rules make that Integer
03:23:17 <maartenm> Jedai: thanks
03:23:18 <Dae> quicksilver: defaulting rules are hardcoded, no? you can't make your own?
03:23:43 <osfameron> can you use zippers on cyclic graphs?
03:23:50 <maartenm> what is 'interact'?
03:23:51 <Jedai> quicksilver: I guess but frankly I never remember the default too clearly, I prefer to make it clear which type I want
03:24:02 <osfameron> or rather, on graphs where nodes may be pointed to by multiple paths?
03:24:06 <Jedai> Dae: you can change them in GHC
03:24:27 <Jedai> maartenm: interact take a function of type (String -> String)
03:24:28 <quicksilver> Dae: you can change them
03:24:32 <Dae> maartenm: if you want to read from a file you can also do like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6616#a6616
03:24:35 <quicksilver> "default" is a very rarely used keyword.
03:24:42 <Dae> ohh
03:25:00 <Jedai> maartenm: it reads the stdin, apply the function parameter on it and print the result on stdout
03:25:22 <Jedai> maartenm: Pretty nice to make small scripts
03:25:32 <quicksilver> Dae: http://www.haskell.org/onlinereport/decls.html#sect4.3.4
03:26:15 <etpace_> Saizan: loading seems to work, but actually running plotF gives me a : Ambiguous type variable 'a' in the constraints: Fractional a
03:27:40 <Dae> quicksilver: thank you :)
03:28:30 <quicksilver> default is one of these compromise things that I don't think fits all that well into the stnadard
03:28:33 <quicksilver> but there you go
03:28:38 <quicksilver> you have to make compromises to get a document out the door
03:29:43 <Saizan> etpace_: i'd add a more restrictive signature than the one inferred
03:29:43 <maartenm> damn, problem #14 is hard
03:30:08 <maartenm> I know how to do it.. it's hard to write down the solution functionally
03:30:18 <Saizan> etpace_: oh, you also have the problem that a parameter is bot Integral and Fractional
03:30:31 <fasta> osfameron: IIRC, that's a bit like what FGL. I don't see why you would want to do that, though.
03:30:41 <fasta> osfameron: + does
03:30:45 <Dae> maartenm: recursion is your friend here
03:30:47 <Jedai> maartenm: IIRC the naive solution works fast enough
03:30:49 <osfameron> fasta: FGL ?
03:30:57 <fasta> osfameron: functional graph library
03:31:02 <maartenm> ah
03:31:10 <maartenm> I thought I'd had to store all the intermediate chain lengths
03:31:13 <maartenm> per starting number
03:31:21 <osfameron> fasta: thanks, I'll have a look
03:31:29 <fasta> osfameron: FGL is not worth your time.
03:31:33 <Jedai> maartenm: though at the time I used a bit of dynamic programming to get a really fast answer
03:31:34 <osfameron> ah :-)
03:31:34 <maartenm> and then prune prematurely with a sort of minmax strategy
03:31:51 <Jedai> maartenm: .... too complicated !
03:32:05 <Dae> Jedai: ohh? how did you do it? I just bruted it
03:32:21 <osfameron> fasta: an obvious example would be a game grid, where each cell is pointed at by 2 other nodes
03:32:32 <fasta> osfameron: you should only use functional graphs when there is a real need.
03:32:45 <fasta> osfameron: I don't know of any problem where one needs functional graphs.
03:32:59 <Jedai> Dae: I used an immutable array to avoid having to recurse below 1_000_000
03:33:24 <fasta> osfameron: some compiler authors claim that using zipper (trees) for some problems was a good idea.
03:34:06 <osfameron> yeah.  I was just thinking about possible problems - I'll see if they actually come up and worry about them then :D
03:34:10 <Dae> Jedai: right, ofcourse. Elegant
03:34:21 <yitz> Jedai: you don't need an array, a Data.Map works just fine here
03:34:38 <Dae> array is faster?
03:34:50 <Jedai> yitz: I don't see why you would want to use a Map rather than an array here
03:35:16 <yitz> Jedai: an array messes up your code. it's usually premature optimization
03:35:24 <etpace_> http://codepad.org/nSLpYDTH I've tried to clear up the type signatures on my function, but I'm getting this error: what does it mean?
03:35:31 <Jedai> yitz: I strongly disagree
03:35:58 <yitz> Jedai: I have never needed an array for any of the Euler problems
03:36:18 <fasta> yitz: Euler problems are designed to run in a few minutes.
03:36:18 <Jedai> yitz: I'm speaking about using an immutable lazy array to do dynamic programming with minimal modification of your original recursive code
03:36:40 <fasta> yitz: a log n factor does not show there.
03:36:41 <Jedai> yitz: You may not have needed them but they're sometimes an elegant solution
03:36:49 <yitz> Jedai: why write code that is hard-coded to use built-in imperative hardware when it's not needed?
03:37:04 <fasta> arrays are not imperative
03:37:10 <Jedai> yitz: That has nothing to do with imperative style
03:37:36 <mle> data structures are a critical part of the algorithm and cannot be ignored as an "optimization"
03:37:37 <fasta> STArrays might be.
03:37:53 <Jedai> yitz: my way of using arrays in Haskell is not imperative at all, in fact it's very hard to do the same in an imperative language
03:38:17 <yitz> Jedai: well, I guess you could imagine that the arrays are internally implemented with trees or something. but why not just use the trees directly?
03:38:55 <Jedai> yitz: array are sequence that are good at random access, the best in fact and bad at mutation and extension, so that's how I use them
03:39:23 <quicksilver> immutable arrays are a perfectly reasonable functional construct
03:39:28 <quicksilver> there is no reason to denigrate them.
03:39:34 <Jedai> yitz: As long as you don't modify the arrays once created, I really don't see why you would ever implement them with a tree
03:39:54 <EvilTerran> using an array over a map also statically enforces the fact that you're using a contigous block of indices
03:39:55 <doserj> etpace_: 2 things: First, at some point, you have to say what the concrete type of a should be, Second, there actually is no such type (that is both Fractional and Integral)
03:39:57 <Jedai> yitz: tree aren't as good for random access or creation time as immutable arrays
03:39:59 <quicksilver> when you have a "full" "rectangular" block of data, an immutable array is exactly right.
03:40:21 <quicksilver> I used it for a 3D grid of boolens when implementing marching cubes, for example.
03:40:37 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6617#a6617   why do I get "Cannot justify constraints in explicitly typed binding "?
03:40:42 <quicksilver> it's rather nice you can index into them using enum-like-types too
03:40:48 <yitz> mle: trees are a good data structure. random-access are not - they are O(n) access. Unless you are building on the assumption that you are using underlying imperative hardware.
03:40:51 <quicksilver> (4,4,TopLeft)
03:41:09 <quicksilver> yitz: "random-access are not" ? what do you mean?
03:41:11 <fasta> I just love how Emacs takes 40 seconds to move the cursor in a 3M line buffer.
03:41:23 <doserj> maartenm: because your explicit type signature is wrong
03:41:44 <fasta> OTOH, Yi probably cannot even handle 3M lines, or can it?
03:41:46 <yitz> are not a good data structure, they're inefficient. unless you hard-code the use of special hardware.
03:41:57 <maartenm> I tried (Int, Int) -> (Int, Int) first
03:42:08 <quicksilver> yitz: "random-access" is not a data structure
03:42:12 <quicksilver> yitz: what are you talking about?
03:42:28 <maartenm> that made it say: Instance of Fractional Int required for definition of collatz
03:42:33 <quicksilver> if you mean "immutable arrays" then they *are* a good structure, and that makes no hardware assumptions.
03:42:33 <maartenm> I don't udnerstand!
03:42:43 <quicksilver> it simple assumes the complexities of immutable arrays.
03:42:51 <quicksilver> which are known, in all existing haskell implementations.
03:42:56 <fasta> quicksilver: he means that the API of immutable arrays don't have efficient update methods for some cases.
03:43:01 <fasta> quicksilver: something you already know
03:43:06 <quicksilver> if he does mean that, then sure.
03:43:08 <maartenm> oh, sorry
03:43:12 <maartenm> sorry, I need to use div
03:43:13 <yitz> quicksilver: sorry I mean arrays that support random-access by an index
03:43:14 <quicksilver> I thought we were talking about read-only access though.
03:43:22 <fasta> quicksilver: I mean, that's my guess of what he meant.
03:43:29 <quicksilver> yitz: random access arrays exist, are fast, and make no hardware assumptions.
03:43:35 <etpace_> ok, thanks doserj
03:43:40 <yitz> quicksilver: yes, using trees.
03:43:48 <yitz> Data.Map
03:43:48 <quicksilver> yitz: Data.Array is here, it is supported on all useful haskell implementations, and has O(1) indexing
03:43:53 <quicksilver> yitz: and it does not use trees.
03:44:02 <fasta> I think he is now referring to how it works on the hardware level.
03:44:02 <quicksilver> yitz: what is the purpose of denying the existence of Data.Array?
03:44:09 <yitz> quicksilver: no, it's O(n)
03:44:17 <quicksilver> Data.Array does not have O(n) indexing.
03:44:20 <quicksilver> what are you talking about?
03:44:41 * quicksilver counts to ten and moderates his tone.
03:44:47 <quicksilver> I apologise, my tone is unacceptable.
03:44:54 <quicksilver> But I genuinely cannot understand what you are trying to say.
03:45:11 <yitz> quicksilver: unless implemented either with trees, or by using hardware
03:45:46 <Jedai> quicksilver: He's trying to explain that the hardware shouldn't matter and that somehow tree are more "hardware independent"... Given that tree needs pointer and that you must assume something on pointer (that they're O(1) access) I think the argument is pretty bad
03:45:51 <yitz> quicksilver: your tone is fine :)
03:45:55 <maartenm> I have another question
03:45:59 <doserj> (+) :: Int -> Int -> Int is O(n), unless using hardware...
03:46:06 <maartenm> I understand find and I understand maximum.. but how do I combine them as such?:
03:46:09 <quicksilver> as doserj says.
03:46:17 <quicksilver> I am interested in actual haskell implementations.
03:46:18 <maartenm> 'find me the tuple for which the snd is the maximum of all the tuples"
03:46:32 <quicksilver> All the haskell implementations wtih which people do real work, implement Data.Array with constant time index.
03:46:45 <quicksilver> Also, all haskell implementations which implement trees, do so by pointer following.
03:46:48 <fasta> maartenm: maximumBy
03:46:54 <quicksilver> So they only exist because of O(1) pointer lookup
03:46:59 <quicksilver> (as Jedai suggests)
03:47:04 <maartenm> faste: thanks, I'll look into that one
03:47:26 <fasta> maartenm: also, there exists tab completion for nick names.
03:47:27 <Dae> maartenm: it's in Data.List
03:47:51 <yitz> Jedai: there is no assumption about pointers. any direct implementation of the Haskell data types will yield O(log n) access to a tree. It is impossible for array to do better than that, without assumptions about the hardware.
03:48:38 <maartenm> err.. how do I include a module?
03:48:39 <Jedai> yitz: what exactly is a "direct implementation" without hardware under it ?
03:48:47 <Jedai> maartenm: import ModuleName
03:49:02 <Jedai> maartenm: one of your own ?
03:49:02 <maartenm> does it allow pythonesque inclusions?
03:49:17 <maartenm> no, one of the libraries (Data.List)
03:49:22 <Jedai> maartenm: import Module (foo, bar)
03:49:38 <maartenm> foo bar are functions, ok
03:49:39 <Jedai> maartenm: import qualified Module as M
03:49:46 <maartenm> even better than python then :)
03:49:55 <Dae> maartenm: if you do not use (foo, bar) it will just import everything
03:49:57 <Jedai> maartenm: foo and bar could be types or things like that too
03:49:58 <yitz> Jedai: an implementation that provides the required semantics in any straightforward way
03:50:43 <Cale> Actually, if you look at the hardware implementation of memory, you'll probably find that it is actually (at least) log time to look up elements in it as well.
03:50:50 <Jedai> yitz: sorry but that's a little bit too metaphysic to my taste as a definition :)
03:51:19 <Cale> (you can't even inspect all the bits of your address otherwise)
03:51:42 <yitz> Jedai: it's not metaphysic, the semantics are clearly defined in the Report. And there is no requirement to use pointers.
03:52:00 <Dae> Cale: but the log is for the total amount of memory, not the size of the data structure?
03:52:38 <Cale> Dae: Well, one or the other. If you have a big enough data structure, you will eventually need to buy more memory :)
03:52:56 <yitz> The nice thing about Haskell is that you can abstract away completely from the underlying hardware.
03:53:00 <Jedai> yitz: well the semantics of Data.Array are clearly defined too and if you allow yourself to do "ideal" implementation, I really don't see why you won't admit to an "ideal" implementation of Data.Array that respects the complexity
03:53:00 <Cale> But yeah, basically the amount of memory
03:53:02 <Ferdirand> ah, i think i get yitz's point
03:53:11 <Saizan> Cale: that argument always seems like changing the kind of operations you're counting to me, chasing log n pointers vs. decoding a log n address, they are not comparable on most hardware i'd think
03:53:20 <Dae> Cale: heh, ok. I think I'll go on claiming arrays have O(1) access time
03:53:35 <yitz> In the future, as things become more and more distributed and parallel, your algorithm still won't look silly.
03:54:04 <yitz> Of course, Array is very practical, and I use it when that optimization is helpful. But it's an optimization.
03:54:23 <Cale> Dae: That's fine, but the argument you're using is that there's really a finite amount of memory, and log(n) is small enough to ignore. :)
03:55:01 <Cale> My usual thinking is that if you're going to ignore one log(n), why not another? :)
03:55:17 <Jedai> yitz: I really don't see why tree would be more adapted to our future distributed world, if to follow a pointer you have to go to another machine, your "independance" to the hardware will be shaken too
03:55:17 <yitz> quicksilver: so I'm not arguing with you of course. but do you get my point?
03:55:22 <Cale> Well, it becomes part of the constant factor involved in the operation.
03:55:31 <yitz> what's a pointer?
03:55:51 <etpace_> > safeHead []
03:55:53 <lambdabot>   Not in scope: `safeHead'
03:56:00 <etpace_> where is safehead?
03:56:06 <yitz> @hoogle safeHead
03:56:06 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
03:56:44 <doserj> > listToMaybe []
03:56:46 <lambdabot>   Nothing
03:56:52 <Jedai> yitz: you insist on ignoring anything hardware related, fine... give us a formal frame for our thinking then
03:57:05 <maartenm> I don't udnerstand the first argument of maximumBy
03:57:14 <Jedai> :t maximumBy
03:57:15 <maartenm> I thought it was an (a -> a -> Int) ?
03:57:15 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
03:57:27 <Cale> :t maximumBy
03:57:29 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
03:57:30 <Cale> ah
03:57:31 <maartenm> but what is Ordening, (-1,0,+1)?
03:57:36 <Jedai> maartenm: Ordering is LT | EQ | GT
03:57:40 <yitz> Jedai: I don't insist on it - I just claim that for Haskell that is the default, and building on hardware assumptions is an optimization.
03:57:41 <Ferdirand> :t comparing
03:57:43 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
03:57:43 <maartenm> oh
03:57:51 <maartenm> where is comparing located?
03:57:56 <maartenm> it's not in Data.List
03:57:57 <Gracenotes> Data.Ord
03:58:01 <maartenm> ok
03:58:11 <Jedai> yitz: in Haskell the immutable arrays have a random access in O(1)
03:58:22 <Ferdirand> :t maximumBy (comparing snd)
03:58:24 <maartenm> so, 'comparing snd' builds an argument I cna use in maximumBy
03:58:24 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
03:58:24 <yitz> Jedai: in practice - it means avoid IO, ST and Array until they are really needed.
03:58:33 <Gracenotes> (comparing blah) is the same as (compare `on` blah), if you use on from Data.Function
03:58:50 <Jedai> yitz: I agree on IO and ST but disagree on immutable arrays
03:59:06 <Cale> Immutable arrays have very suboptimal times for anything but lookup though.
03:59:11 <yitz> So yeah, if the difference in speed between Array and Map is the best way to solve your problem, go ahead. You'll find that almost never happens though.
03:59:24 <Cale> If you only need to do lots of lookups, they're good.
03:59:31 <Gracenotes> and using a UArray can improve lookup times further for some fixed-size elements
03:59:41 <yitz> Gracenotes: right
03:59:52 <Jedai> Cale: Sure, which is why you should use them when it's appropriate, and only then
04:00:16 <maartenm>   Failed to load interface for `Data.Ord':       Could not find module `Data.Ord':
04:00:19 <maartenm> it's in hugs
04:00:23 <maartenm> but not in ghc
04:00:24 <Jedai> Cale: but they have a semantic more precise than Map, and in practice better preformance on Lookup
04:00:36 <maartenm> is that typical or do I have a faulty installation/environment?
04:00:36 <Jedai> maartenm: Forget Hugs please :)
04:00:43 <maartenm> yeah I'm ditching hugs
04:00:49 <Jedai> maartenm: it's not maintained since years
04:00:51 <maartenm> but ghc won't compile now
04:00:56 <fasta> maartenm: and for looking up stuff, install the documentation.
04:01:02 <Jedai> maartenm: use --make
04:01:04 <Cale> Jedai: eh? Is Map's semantics not precise?
04:01:34 <yitz> he means it's explicitly read-only
04:01:34 <Jedai> maartenm: if you use --make it will search for the right package where to find the module you imported
04:02:04 <maartenm> Could not find module `Data.Ord':   locations searched:     Data/Ord.hs     Data/Ord.lhs
04:02:13 <Cale> maartenm: Which GHC?
04:02:16 <maartenm> it's not looking into its own lib folder
04:02:32 <maartenm> v6.4.2 (for windows..)
04:02:34 <Jedai> Cale: maybe "restrained" would be a better description, for instance Array indexes are in a bloc given an Enum instance
04:02:40 <Cale> maartenm: Ah, there you go.
04:02:48 <Cale> maartenm: 6.4 is years old now.
04:03:06 <yitz> but every Map is also immutable. Why does the fact that they are easier to transform make their semantics any less precise?
04:03:24 <Jedai> maartenm: how the hell did you end up with 6.4 ? it's at least 3 years old, if not more...
04:03:25 <maartenm> oops
04:03:27 <maartenm> sorry
04:03:30 <maartenm> google gave it to me
04:03:35 <yitz> get the Haskell Platform
04:04:02 <Cale> Version 6.4.2 (released 19 April 2006) :)
04:04:12 <maartenm> yes I'm downloading, sorry
04:04:30 <yitz> maartenm: hmm. what search term did you use in Google?
04:04:40 <yitz> @google ghc
04:04:41 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
04:04:44 <maartenm> well I'd have to say the haskell site could use some SEO
04:04:46 <yitz> ach
04:04:53 <maartenm> because I just typed "ghc windows"
04:05:02 <maartenm> and it pointed me to the official site, the 6.4.2 download link
04:05:03 <Cale> yitz: I wonder what's up with that.
04:05:05 <Jedai> maartenm: http://hackage.haskell.org/platform/
04:05:06 <yitz> @google ghc windows
04:05:07 <lambdabot> http://www.haskell.org/ghc/download_ghc_642.html
04:05:08 <lambdabot> Title: GHC: Download version 6.4.2
04:05:16 <yitz> oh myu
04:05:30 <yitz> how do we fix that?
04:05:30 <Cale> random network failure?
04:05:33 <fasta> Windows must be popular
04:05:35 <Cale> @google ghc
04:05:36 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
04:05:40 <Cale> hmm
04:05:45 <Cale> seems consistent
04:05:58 <yitz> Cale: I'm more worried about the google result than the \bot failure :)
04:06:09 <fasta> @google windows msi ghc
04:06:11 <lambdabot> http://www.haskell.org/ghc/download_ghc_64.html
04:06:11 <lambdabot> Title: GHC: Download version 6.4
04:06:28 <fasta> Google stock drops instantly.
04:06:28 <maartenm> yeah I think many newbies liek me have died in the fields
04:06:56 <yitz> fasta: unfortunately, it's the Haskell stock that drops, not the Google stock
04:06:58 <fasta> http://haskell.org/ghc/dist/6.10.3/ghc-6.10.3-i386-windows.exe
04:07:16 <yitz> it should point to the haskell platform
04:07:34 <portnov> @google haskell platform
04:07:36 <lambdabot> http://hackage.haskell.org/platform/
04:07:36 <lambdabot> Title: Haskell Platform Download (Beta)
04:07:46 <portnov> that? :)
04:07:53 <yitz> yeah :)
04:08:02 <fasta> @google get haskell
04:08:03 <lambdabot> http://www.haskell.org/haskellwiki/Implementations
04:08:04 <lambdabot> Title: Implementations - HaskellWiki
04:08:12 <yitz> ok, not too bad
04:08:30 <ikegami__> Google had said "We ignore the meta keyword, but parse the meta-description."
04:08:43 <fasta> @google what is the best Haskell implemenation?
04:08:44 <lambdabot> No Result Found.
04:08:58 <ikegami__> Yes, we know
04:09:00 <fasta> @google what is the best Haskell implementation?
04:09:01 <lambdabot> No Result Found.
04:09:26 <yitz> @wolfram what is the best Haskell implementation?
04:09:27 <lambdabot> Unknown command, try @list
04:10:29 <maartenm> when you input Haskell in wolfram, it thinks it's a human name
04:10:30 <maartenm> is it?
04:10:36 <maartenm> there are children called Haskell?
04:10:53 <yitz> maartenm: haskell is named after haskell curry
04:11:02 <yitz> a mathematician
04:11:07 <maartenm> most common age: 74 years
04:11:19 <maartenm> ah, ok
04:12:01 <portnov> moreover, there is famous mathematican called Haskell :)
04:24:22 <Jedai> maartenm: the most naive approach I tried for problem 14 took 7s compiled with optimization
04:26:13 <maartenm> mine is just this simple thing: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6618#a6618
04:26:33 <maartenm> but it causes stack overflow in Hugs (yeah I know I will not utter thw rod anymore)
04:26:43 <maartenm> waiting for Platform to install..
04:27:58 <Twey> maartenm: Yes, it is a human name
04:28:06 <Twey> It's also the name of a tribe of Americans
04:30:43 <Jedai> maartenm: something you should take the habit of not doing anymore is writing your function in uncurried form
04:31:12 <Jedai> maartenm: in other word, your collatz shouldn't take a tuple argument
04:31:30 <maartenm> yes I was strugglign with that
04:31:34 <maartenm> I need a helper funciton?
04:31:43 <maartenm> collatz', which takes two arguments?
04:31:47 <Jedai> maartenm: collatz :: Int -> Int -> Int
04:32:01 <maartenm> ah, ok
04:32:11 <Jedai> collatz 1 c = c
04:32:19 <maartenm> what are the side-effects of using tuples?
04:32:26 <Jedai> collatz n c = if even n then ... else ...
04:32:30 <maartenm> I use the tuples so I can calculate the maximum chain lenght, btw
04:32:58 <yitz> Twey: it'
04:33:04 <Jedai> maartenm: tuples are bad, but especially in the argument
04:33:32 <maartenm> but how do I get the chain length stored, otherwise?
04:33:39 <yitz> Twey: it's not the name of a tribe. It's the name of a University that is associated somehow with some tribe(s), not sure the exact relationship
04:33:50 <Twey> It's okay if the two together represent a single datum
04:33:54 <Jedai> maartenm: constructing tuples, destructing them and so on consume resources, even worse it can induce lazyness trouble
04:34:18 <Jedai> maartenm: I suggest that collatz returns the chain length only
04:34:18 <Twey> Like, distance :: (Int, Int) -> (Int, Int) -> Int
04:34:23 <Twey> yitz: Oh, right
04:34:28 <maartenm> but then I can't use it recursively
04:34:47 <Jedai> maartenm: of course you can, why not ?
04:35:08 <maartenm> because collatz n depends on collatz (n-1)
04:35:22 <maartenm> hmm
04:35:27 <maartenm> ok, you're right I think
04:35:31 <Jedai> collatz n c = if even n then collatz (n `div` 2) (c+1) else collatz (3*n + 1) (c+1)
04:35:37 <Twey> maartenm: A common pattern is func param = func' param1 param2 param3 param4... where func' = ...
04:35:45 <maartenm> yes , helper functions
04:35:52 <maartenm> ok
04:36:02 <Jedai> Twey: well he don't need it here
04:36:05 <maartenm> and then the check to find the largest chain finds the index
04:36:07 <Twey> Aye
04:36:21 <maartenm> of the largest chain.. and that index is the starting point
04:36:31 <maartenm> that's kind of lucky, though
04:36:37 <Jedai> maartenm: Why ?
04:36:57 <maartenm> well, I can imagine where in other problems, you wouldn't be able to do this
04:37:14 <maartenm> I need 'map collatz [1..]'
04:37:26 <Jedai> map (\x -> (x, collatz x 0))
04:37:27 <maartenm> which is, now, a lis tof values (sinc etuples are bad)
04:37:46 <maartenm> yeah, I'm not talking about the mapping
04:37:47 <maartenm> I just mean
04:37:56 <maartenm> when I want to examine the results for [1..]
04:38:00 <Jedai> maartenm: tuples are bad, sure, in fact you don't need the map
04:38:25 <Twey> Tuples aren't bad.  They're just not appropriate here.
04:38:32 <maartenm> in this case, we're lucky since the index of the largest chain, is the answer to the question
04:38:44 <Jedai> Twey: it's a simplification ;)
04:38:53 <Jedai> maartenm: you don't have to be lucky and rely on the index
04:39:00 <maartenm> no?
04:39:00 <Twey> Jedai: It's a dangerous simplification — I've seen that one go wrong a bunch of times
04:39:11 <Jedai> Twey: You may be right
04:39:21 <Twey> ‘But So-And-So said that Feature X is bad and I musntn't use it!’
04:39:31 <Twey> s/musntn't/mustn't/
04:39:33 <Jedai> maartenm: why don't you compare directly onthe length of the collatz chain ?
04:39:50 <maartenm> you'd store the chains in  alist?
04:39:57 <maartenm> I'm not following
04:40:44 <Jedai> maartenm: look, you have maximumBy, comparing and collatz n 0 evaluates to the length of the collatz chain from n
04:40:59 <Jedai> maartenm: You don't need a map, or tuples anywhere
04:41:06 <maartenm> yes, ok
04:41:12 <maartenm> it just seemed lucky, in this case
04:41:31 <maartenm> I just would like to know if tuples would be needed when the result's interpretation would be more complex
04:42:24 <Jedai> maartenm: Ok, I retract my affirmation, tuples aren't bad by themselves, but you shouldn't use them as argument just to have one argument
04:42:34 <maartenm> okay
04:42:35 <maartenm> btw
04:42:40 <maartenm> my solution didn't finish when compiled
04:42:44 <maartenm> it also ran into stack overflow
04:42:46 <Jedai> maartenm: here your collatz took a tuple where it should just have taken two arguments
04:42:47 <maartenm> I'll try yours now
04:48:07 <maartenm> hmm
04:48:19 <maartenm> Jedai: this is my attempt thanks to your help:  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6619#a6619
04:48:24 <maartenm> but it sill gives a stack overflow
04:50:01 <doserj> maartenm: make collatz strict in c
04:50:40 <EvilRanter> surely some kind of memoisation is necessary to make this problem tractable?
04:50:48 <doserj> I would guess so
04:51:03 <maartenm> Jedai said it could be done brutely
04:51:35 <maartenm> doserj: I don't understand, I shoudl write collatz in c?
04:51:54 <Dae> maartenm: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6619#a6620
04:52:09 <Dae> you want to evaluate the c's
04:52:12 <doserj> "strict in c" means that you should evaluate c at some point (not translate it to C, of course)
04:52:26 <maartenm> ah, ok
04:52:31 <maartenm> so it is not pure anymore there?
04:52:39 <doserj> it is still pure
04:52:42 <Dae> no it's still pure, only not lazy
04:52:43 <EvilRanter> it's still pure
04:53:02 <maartenm> how does that work?
04:53:41 <maartenm> I mean, is there a table now in runtime where it stores these values, with a *collatz(n) pointer?
04:53:46 <EvilTerran> no
04:53:54 <EvilTerran> ?src ($!)
04:53:55 <lambdabot> f $! x = x `seq` f x
04:54:03 <EvilTerran> ?type seq
04:54:05 <lambdabot> forall a t. a -> t -> t
04:54:27 <doserj> maartenm: it doesn't do any memoization, but it could get rid of the stack overflow
04:54:39 <EvilTerran> maartenm, (x`seq`y) is defined in the report to be undefined if x is, and otherwise be y
04:55:27 <doserj> in practise this means, whenever y is needed, first evaluate x
04:55:29 <EvilTerran> maartenm, this means that the runtime can evaluate x before continuing on to y, thus making the code less lazy, and avoiding some space leaks
04:55:38 <maartenm> I still get q stqck overfloz though
04:55:47 <maartenm> ok; so this is just the orde rof the qrgu,ents
04:55:49 <maartenm> oops
04:55:54 <Dae> maartenm: even after using the $! I added?
04:56:36 <maartenm> I ,eqn; like function(foo(i++), bar(i++,j++)) this is undefined in C:: but in hqskell you cqn control it
04:56:38 <maartenm> cool
04:56:40 <maartenm> Dae: yes
04:56:45 <maartenm> unless..
04:56:56 <maartenm> I need to del *.o and platform no longe rcomplains about that
04:57:11 <maartenm> no
04:58:16 <Saizan> btw, using a so expensive function as argument to maximumBy doesn't look quite right
04:58:24 <maartenm> I think that's th eproblem really
04:58:33 <maartenm> collatz 1000000 0   runs in milliseconds
04:58:48 <maartenm> it seems like the problem is the searcg
04:59:13 <Saizan> maartenm: fst . maximumBy (comparing snd) . map (\x -> (x,collatz x 0)) $ [1..1000000]
05:00:52 <maartenm> Saizan: also stack overflow
05:01:02 <doserj> yeah, the maximumBy is too lazy
05:01:19 <Saizan> ?
05:01:37 <maartenm> I need something like maximum and then tracking the index of the found result?
05:03:20 <maartenm> man..
05:03:21 <maartenm> length (map (\z -> collatz z 0) [1..1000000])
05:03:25 <maartenm> this finishes in no time
05:03:32 <maartenm> maximum (map (\z -> collatz z 0) [1..1000000]) --> ERROR - C stack overflow
05:03:40 <maartenm> what's happening here?
05:04:09 <doserj> > length (map (\z -> undefined) [1..1000000])
05:04:10 <lambdabot>   1000000
05:04:12 <EvilTerran> maartenm, you can work out the length of the list without evaluating any of the elements
05:06:25 <maartenm> it's almost as if one value in [1..1000000] causes collatz to diverge infinitely
05:06:33 <Saizan> are we sure that the collatz definition is right?
05:06:34 <maartenm> but I don't think I just disproved the collatz conjecture
05:07:26 <maartenm> it looks right
05:07:32 <Jedai> maartenm: compile with optimization
05:07:32 <maartenm> and it tests fine for some sample values
05:07:56 <Jedai> maartenm: maximum or maximumBy is just a little bit too lazy by default
05:08:30 <maartenm> it's running.. doesn't choke anymore at least
05:08:49 <Jedai> maartenm: you can use "foldl1' max" instead of maximum to be strict
05:09:46 <Saizan> ah, you weren't testing with optimizations?
05:09:55 <maartenm> no, sorry
05:10:00 <maartenm> I still think it's odd
05:10:03 <maartenm> that maximum is so slow
05:10:11 <maartenm> (execution hasn't finished yet)
05:10:33 <maartenm> collatz is O(log n)
05:10:41 <maartenm> why would this take so long?
05:10:51 <Jedai> maartenm: it shouldn't take too long
05:11:06 <Jedai> maartenm: could you paste your final code ?
05:11:09 <Saizan> maximumBy is O(n)
05:11:53 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6621#a6621
05:11:57 <maartenm> I use euler14 there
05:12:13 <doserj> well, that is clearly slow
05:12:40 <doserj> test14 should be substantially faster
05:13:26 <doserj> comparing (\x -> collatz x 0) means that you calculate collatz for each comparison
05:13:41 <maartenm> os, so that's  ^ 2
05:13:52 <maartenm> I trusted haskell would take care of me
05:14:00 <maartenm> I'll try test14 now
05:15:07 <maartenm> also takes a long time
05:15:19 <Jedai> doserj: well it should just take time*2
05:15:32 <maartenm> no, time ^ 2
05:15:43 <Jedai> doserj: it's not like for sort where the comparison is done much more often
05:15:50 <maartenm> it isn't?
05:16:00 <maartenm> ah, of course it isn't
05:16:05 <maartenm> it can prune
05:16:17 <maartenm> either way, test14 doesn't execute timely either
05:16:31 <maartenm> I'm officially very bad at haskell
05:16:34 <Jedai> maartenm: not really "prune" I would say... it's just a linear traversal
05:17:20 <doserj> Jedai: a bit more than just (*2), though. it tends to recalculate the expensive calls :)
05:18:08 <Jedai> doserj: ? there just 2 times more call to the argument of comparing, at most it will be 2*time
05:18:19 <maartenm> last (map (\z -> collatz z 0) [1..1000000])  actually calculates the whole list, right?
05:18:23 <Saizan> maartenm: are you making an executable with main = print test14 or just running test14 at the ghci prompt?
05:18:27 <maartenm> this executes in under a minute
05:18:36 <maartenm> Saizan: running main with putsStr show test14
05:18:37 <Saizan> maartenm: no, only the last element
05:18:47 <maartenm> ok
05:19:46 <doserj> Jedai: but most of the repeated calls will be to the current maximum
05:20:31 <Jedai> doserj: right :)
05:20:32 <Jedai> doserj: I didn't think about that
05:21:07 <maartenm> this is my final code:  http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6622#a6622
05:21:17 <maartenm> it has been running for 15 minutes without result..
05:21:48 <doserj> maartenm: time to memoize collatz
05:21:58 <maartenm> ok, I'll try
05:22:10 <maartenm> so with memoize, I guess you mean put it into a dynamic form
05:22:14 <maartenm> instead of simple recursion?
05:23:25 <Jedai> maartenm: that's really strange....
05:24:58 <Jedai> maartenm: ok, I found the problem...
05:25:15 <maartenm> yeah, you did?
05:25:18 <Jedai> maartenm: the collatz sequence goes beyond the Int limit
05:25:33 <maartenm> and enter the pool of slow Integers?
05:25:40 <Jedai> maartenm: collatz should be Integer -> Int -> Int
05:25:58 <Jedai> maartenm: Nope, if you use Int, you enter an infinite loop somewhere
05:26:15 <maartenm> whoa, really?
05:26:24 <maartenm> because it doesn't throw it?
05:26:32 <maartenm> and cuts off the integer to 0xFFFF?
05:26:40 <maartenm> can you make sure your executable doesn't do that?
05:26:54 <Jedai> maartenm: That's Int arithmetic
05:27:12 <Jedai> maartenm: it doesn't just "cut off"
05:27:22 <maartenm> yeah ok, I understand
05:27:46 <Jedai> maartenm: int is like Z/2G or something
05:28:03 <Jedai> maartenm: it's not Z at all
05:28:40 <Jedai> maartenm: use Integer instead of Int and your program should run fast enough (5s here)
05:29:19 <maartenm> ok, it finishes now
05:29:28 <maartenm> I'll still try to write memoized_collatz as an exercise
05:36:39 <maartenm> heh, at least it's better than some other participants: "Not being very clued up on this issue, I decided to attempt a brute force solution. Starting with 500,001 and counting upwards, every odd number was tested. It took 29 hours to find the solution."
05:38:42 <fasta> Is there any kind of issue with using ghci with a C library where you basically call a function which initializes the C library multiple times?
05:39:20 <dankna> I don't believe the C library has an "initialized" state, though I may be naive
05:40:02 <fasta> so main = do initializeC; a<-doSomethingInCLibrary;doSomethingHaskelly a  and then evaluating main two times.
05:40:15 <fasta> Because I get different results when I do that.
05:40:25 <fasta> If I just run it once with ghc I get the correct result.
05:40:32 <Botje> fasta: your initializeC should remember if it was called already, of course
05:40:51 <fasta> Botje: I don't see why that would be "of course".
05:40:57 <dankna> true - just don't call initializeC more than once.  I was about to say that I can't possibly give a general answer, I'd need to see your code.
05:41:13 <fasta> Botje: initialization should initialize the library, regardless of what state it is in.
05:41:24 <Botje> fasta: calling initializeC more than once is an error, imo
05:41:29 <dankna> I also just realized that I don't know whether you mean THE C library, which is libc, or AN arbitrary library in C
05:41:40 <fasta> an arbitrary library in C.
05:41:48 <dankna> oh, that's a very different question from what I assumed
05:41:48 <Botje> so you should throw an error on the second time or just silently ignore it
05:41:49 <gwern> spam on the wiki. bleh.
05:41:55 <dankna> spam is bleh indeed
05:42:20 <gwern> fasta: I recollect that ghci can crash if you do initialize stuff more than once; iric, it was something to do with GUIs
05:42:26 <Botje> if initializeC resets some global state, you should account for that  i think
05:43:06 <dankna> basically, either the underlying C library can handle being initialized twice, in which case you should be okay, or it can't, in which case if you insist that initializeC should be idempotent you'll have to implement the idempotence yourself with a flag
05:43:51 <dankna> I don't see any other options.  but I'm not sure that you've fully explained why you're reluctant to do it the second way.
05:43:52 <fasta> Well, then I guess it's just a weak point in the C library and I will implement the idempotence later.
05:44:07 <dankna> yeah, that's my guess, not knowing anything at all about what library this is :)
05:44:15 <fasta> dankna: it's the devil library.
05:44:19 <dankna> haha, noted
05:44:57 <fasta> dankna:  http://openil.sourceforge.net/
05:45:04 <dankna> oh!  you were being literal
05:45:06 <dankna> okay
05:45:12 <fasta> dankna: yes, I was.
05:45:19 <dankna> you must have been the one who mentioned this the other day then
05:45:38 <fasta> Mentioned what?
05:45:47 <dankna> somebody mentioned DevIL
05:46:04 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6623#a6623
05:46:10 <maartenm> Instance of Num (Int -> Int) required for definition of memoized_collatz
05:46:13 <maartenm> I don't udnerstand this
05:46:17 <fasta> dankna: oh, maybe. DevIL is at least quite fast.
05:46:28 <dankna> well that's good
05:46:36 <Botje> that's ghc-speak for "you called that function with an argument too little"
05:46:54 <maartenm> oops
05:46:55 <fasta> Doing the transformation in Haskell took about 5 minutes. In DevIL it was close to a few seconds.
05:46:56 <doserj> maartenm: look at the then and else branches
05:47:06 <Botje> maartenm: memoized_collatz takes two arguments, you're only passing it one on lines 16 and 17
05:47:07 <maartenm> yes
05:47:27 <fasta> I didn't try the pointer arithmetic Haskell that is of course also possible.
05:47:28 <doserj> ah, ignore me
05:47:55 <dankna> ghc has such creative error messages
05:48:04 <dankna> even missing commas manifest as type errors
05:48:05 <dankna> well
05:48:15 <dankna> not creative in the sense that some human put creativity into them
05:48:26 <dankna> they are the products of its own machine mind, and are fascinating as specimens
05:48:45 <maartenm> I'm doing something wrong here
05:48:51 <maartenm> memoized_collatz should be Int -> Int
05:49:02 <dankna> well, you declared it as Int -> Int -> Int
05:49:10 <maartenm> that's wrong, isn't it?
05:49:13 <maartenm> Ic an;t memoize that way
05:49:18 <maartenm> at least not with a simple list
05:49:19 <Botje> also note that your fetching element 1000000 from a list will take a lot of time
05:50:16 <Jedai> maartenm: A list isn't a very good memoization support in this case
05:50:37 <maartenm> so I nee d amatrix
05:50:41 <Jedai> maartenm: You could use it, but random access in a list is O(n)
05:50:48 <Jedai> maartenm: not a matrix
05:50:49 <Botje> maartenm: start with Data.Map
05:50:59 <Botje> it has a slightly less awkward usage
05:51:01 <maartenm> ok, I'll look into it
05:54:01 <maartenm> euler #15 has a rather odd problem phrasing
05:54:24 <Botje> not really
05:56:12 <maartenm> well why can't you do (0,0) - right -> down -> left -> down -> right -> right
05:56:18 <maartenm> that's not exactly "backtracking"
05:56:52 <Botje> that's what they mean by not backtracking
05:56:53 <maartenm> but it's probably just me
05:56:54 <lilac> maartenm: you should probably use Array rather than [] for memoized_collatz
05:57:12 <Botje> you can't go left - right or any combination thereof
05:57:25 <lilac> is euler#15 the 'how many paths' one?
05:57:30 <maartenm> so you can;t go left or up
05:57:36 <Jedai> lilac: Yes
05:57:44 <lilac> you can do that one with a pen and paper faster than with a computer program, iirc
05:57:44 <Jedai> maartenm: Right :)
05:58:24 <Botje> my haskell solution is pretty elegant
05:58:28 <lilac> how many paths are there to and from each point on the diagonal?
05:58:30 <Botje> but yes, pen & paper is infinitely faster
05:58:31 <maartenm> this way is much more environmentally responsible
05:58:56 <maartenm> this will be another fun haskell exercise
05:59:08 <maartenm> at least, for me.. for you it will probably mean answering dumb questions
05:59:15 <lilac> every gram of paper is one gram of carbon that's not in the air ;-)
05:59:41 <idnar> I want a tablet and stylus or something
05:59:50 <idnar> doing math on a keyboard is just painful
06:00:11 <maartenm> it's odd that there still aren't any good "scratchpad" apps yet
06:00:26 <maartenm> like, mathematica/matlab quality apps with image recognition
06:00:40 <dankna> not odd to me - it seems like a really hard problem - but frustrating
06:02:33 <bremner> I saw a pretty impressive talk by a guy from the University of Western Ontario about handwriting for math. I think it was an interface to Maple.
06:02:52 <dankna> oh?
06:04:19 <maartenm> just imagine, writing a differential equation with 'f' in the margin..
06:04:32 <maartenm> and afterwards, you erase f with your hand, and write it anew
06:04:41 <maartenm> and in th emargin, you see the equation's result change
06:05:09 <dankna> that'd be very nice indeed
06:05:29 <dankna> while we are dreaming, I always wanted one for data-structure visualization.  primarily pedagogical purposes.
06:05:47 <dankna> you could trace through a lot more examples in the same amount of time if you had some assistance in drawing them all out.
06:07:31 <Dae> maartenm: did you get the euler problem 14 working, or do you want tips?
06:07:44 <maartenm> I'm strugglign with memoization
06:08:11 <maartenm> but I'll try Problem #15 first (although it's a bit to easy to learn anything with, I'll try to do it with enums for DOWN and RIGHT)
06:08:35 <maartenm> I think I know how to do the memoization, but I find it hard to read the Haskell API for Data.Map
06:08:47 <Dae> maartenm: it can be done without memoization
06:08:56 <maartenm> I did it wihtout memoization
06:09:09 <maartenm> it finished in about 10 seconds, with a lot of help from this channel
06:10:13 <Dae> ohh? what was your final code?
06:11:35 <PeakerWork> how do I enable mdo notation in ghc?
06:11:51 <maartenm> Dae: test14 of this piece: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6621#a6624
06:12:18 <maartenm> basically, none of the code is mine anymore
06:12:38 <fasta> PeakerWork: man ghc?
06:12:46 <fasta> PeakerWork: /mdo
06:12:53 <PeakerWork> thanks
06:17:56 <lilac> @hoogle (i, i) -> (i -> e) -> Array i e
06:17:57 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
06:17:57 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
06:17:57 <lambdabot> Data.Array.Base mapIndices :: (MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)
06:20:17 <PeakerWork> mdo { print x ; x <- return 1 ; return () } -- wouldn't this be expected to work?
06:20:29 <PeakerWork> how does mdo use mfix exactly?
06:21:15 <idnar> @undo mdo { print x ; x <- return 1 ; return () }
06:21:15 <lambdabot>  Parse error at "x" (column 13)
06:21:34 <PeakerWork> @unmdo
06:21:34 <lambdabot> ()
06:21:45 <PeakerWork> @unmdo mdo { print x ; x <- return 1 ; return () }
06:21:45 <lambdabot>  Parse error at "x" (column 13)
06:21:51 <idnar> I think that spell-corrects to @undo
06:22:10 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6625#a6625
06:22:17 <maartenm> my attempt at #15 is failure
06:22:29 <maartenm> ah, nevermind
06:22:36 <maartenm> I see my error
06:24:09 <doserj> problem 15 is really a simple math problem, not a programming exercise
06:24:18 <maartenm> no but it's fun to learn haskell with
06:24:45 <quicksilver> PeakerWork: yes, that ought to work
06:25:42 <PeakerWork> quicksilver: it generates <<LOOP>>
06:26:51 <quicksilver> oh, I see, I thought you meant it gave a compile error.
06:27:48 <lilac> PeakerWork: mfix (\x -> print x >> return 1) >> return ()
06:29:10 <PeakerWork> lilac: I don't know how MonadFix of IO works, is that supposed to work?
06:29:48 <PeakerWork> I guess not, because it could be anything, not just "return 1" there
06:30:30 <jelly12gen> hi , i am trying to do some nice getOpts with haskell  but it fails with this error http://dpaste.com/64094/
06:30:33 <jelly12gen> exam.hs:49:42: Not in scope: `set'
06:30:45 <jelly12gen> oh and it's not really an exam :P
06:30:47 <etpace_> Hmm, running my code causes it to hang (for a long time, i'm not sure if itll finish) -- whats the best way to debug this?
06:31:18 <Jedai> etpace_: try using the ghci debugger
06:31:50 <Jedai> etpace_: do you know where it hangs or do you suspect a large amount of code ?
06:32:11 <etpace_> I know the function where it hangs, but thats about it
06:32:25 <dschoepe> etpace_: Apart from the ghci debugger, you could also use Debug.Trace.trace to find the exact step that causes it to hang
06:32:42 <etpace_> Yeah, I'm trying to :step though it now, and I'm not really sure what I'm looking at
06:34:02 <etpace_> Ok, well gdb just hanged when stepping through
06:34:13 <etpace_> gdp? i meant ghc debugger
06:34:21 <dschoepe> Well, my suggestion was much more primitive. You could just place some `trace "starting to do foo"' in your code and see which get printed. Not very clean, but it works :)
06:34:36 <jelly12gen> ok i am having trouble with an example code of argument_handling http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Argument_handling
06:34:51 <jelly12gen> it just says " not in scope 'set'
06:34:58 <jelly12gen> so i guess i might want to import it ?
06:35:20 <lilac> PeakerWork: i would be surprised if it worked, but on the other hand i would hope it worked for lazy ST
06:36:46 <dschoepe> jelly12gen: set might be defined later in the tutorial
06:36:46 <jelly12gen> or does someone has a nice example of passing , reconizing arguments?
06:36:56 <dschoepe> there's a definition of set in a where clause at the end
06:37:16 <jelly12gen> taht set Dollars
06:37:23 <dschoepe> yes
06:37:28 <jelly12gen> hmm
06:37:42 <dschoepe> Be careful to get the indentation right
06:37:51 <jelly12gen> identition is right here
06:38:02 <jelly12gen> i am making my program wich is a bit different
06:38:14 <jelly12gen> i get the data Flag and flags part
06:38:21 <jelly12gen> not yet the parse one
06:42:11 <dschoepe> jelly12gen: This is useful for understanding the code: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Console-GetOpt.html#v:getOpt
06:42:44 <jelly12gen> i am building a todolist editor already build one ,but that had ugly argument handling
06:42:59 <jelly12gen> http://github.com/jelly/TodoList/blob/1f376ee340c8f34dc1d0626abfdc5a2e7290dc59/todo.hs
06:43:02 <PeakerWork> lilac: lazy State you mean? What's lazy ST?
06:43:03 <jelly12gen> if you are interested
06:43:34 <maartenm> is there a known procedure for *unique* permutations?
06:44:08 <quicksilver> PeakerWork: there is a lazy version of ST.
06:44:14 <quicksilver> I can't quite describe how it differs.
06:44:33 <quicksilver> it is something that I've been meaning to understand for a while
06:45:06 <PeakerWork> quicksilver: what is lazy in lazy ST exactly?  What's thunked?
06:45:23 <lilac> PeakerWork: Control.Monad.ST.Lazy. as i understand it, it performs enough of the "side-effects" to compute the value you force, and no others
06:46:15 <lilac> you have some state value threaded through the ST computation, and that is only evaluated to the point necessary to get your result
06:46:48 <PeakerWork> lilac: the "state value" is all the STRef/STArrays it has, conceptually?
06:47:17 <lilac> PeakerWork: a mapping from those to their values, yes
06:48:01 <PeakerWork> lilac: though not implementable as an actual State monad due to the polymorphism of the map's values
06:48:37 <lilac> PeakerWork: you might be able to implement it via State using existentials and sufficiently much cunning, perhaps
06:49:08 <lilac> but it's certainly not obvious to me whether that's doable
06:52:04 <jelly12gen> is there any other way of passing cli arguments nicely?
06:52:06 <PeakerWork> maybe with unsafeCoerce
06:52:54 <fasta> jelly12gen: which way are you using now?
06:53:19 <PeakerWork> jelly12gen: http://leiffrenzel.de/papers/commandline-options-in-haskell.html
06:53:28 <jelly12gen> PeakerWork: saw that one
06:53:37 <jelly12gen> but i want only -a "lalala"
06:54:32 <jelly12gen> ok that is a bit unclear
06:54:37 <dschoepe> jelly12gen: Well, getOpt allows you to do that quite elegantly
06:54:59 <jelly12gen> dschoepe: well so far i have this http://dpaste.com/64094/
06:55:50 <anteaterNethack> hi.  the example in http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Expr.html#v:buildExpressionParser seems horribly out of date.  at least it does not compile easily.  does anybody use Text.Parsec.Expr.buildExpressionParser any longer?
06:55:58 <dschoepe> jelly12gen: You probably don't want to use NoArg for flags that need, say, a filename
06:56:10 <jelly12gen> dschoepe: nah i know
06:57:31 <jelly12gen> dschoepe: i actually still don't get that nub(concatMap set args)
06:57:36 <hackagebot> serial 0.2.5 - POSIX serial port wrapper (FrederickRoss)
06:58:12 <jelly12gen> most of the time it's like if i understand the parsing + the ReqArg i just need it to call an function + args an i got it
06:58:17 <dschoepe> jelly12gen: set returns a number of options to be set, nub removes duplicates from a list and concatMap is just concat . map
06:58:57 <jelly12gen> dschoepe: so this is for calling the program with ./example -aaa $FILE -v "add"
06:58:58 <dschoepe> So nub (concatMap set args), sets some internal options for each argument and concats those into a single list
06:59:01 <lilac> "concatMap f" is "concat . map f". "concatMap" is not "concat . map".
06:59:24 <dschoepe> yes, I was wrong
06:59:26 <copumpkin> (concat .) . map
06:59:33 <BONUS> gah beaten!
06:59:33 <lilac> @@ @pl @src concatMap
06:59:33 <lambdabot>  (line 1, column 1):
06:59:34 <lambdabot> unexpected end of input
06:59:34 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
06:59:46 <jelly12gen> then it so it maps set to all args
06:59:52 <jelly12gen> @set
06:59:54 <lambdabot>  Defined.
07:00:59 <lilac> hmm. had that @pl worked, it would just have said concatMap = (=<<) ;-/
07:02:11 <copumpkin> I'm not sure why @src's output doesn't compose nicely
07:02:23 <copumpkin> or rather, @src doesn't compose nicely :)
07:03:56 <dschoepe> Would it be better to implement src, pl, etc. as haskell functions that could be called via "> src "concatMap""? It might increase composability.
07:04:26 <copumpkin> they'd have to be TH or take strings
07:04:37 <BONUS> or have IO String results
07:04:41 <SamB_XP> @src concatMap
07:04:42 <lambdabot> concatMap f = foldr ((++) . f) []
07:04:47 <BONUS> if they would look into their own haddock or something
07:05:05 <jelly12gen> @src set
07:05:05 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:05:17 <copumpkin> I dunno, that'd be relatively safe to unsafePerformIO
07:05:24 <copumpkin> assuming no FS failure or changes behind your back :P
07:05:32 <SamB_XP> @. pl src concatMap
07:05:32 <lambdabot> (line 1, column 1):
07:05:32 <lambdabot> unexpected end of input
07:05:32 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
07:05:42 <BONUS> maybe, but i'm somewhat of a purity purist :)
07:05:52 <SamB_XP> what's wrong there ?
07:06:10 <copumpkin> SamB_XP: the @src doesn't play nicely with other plugins
07:06:23 <BONUS> i also resent that the System.Info functions are "pure"
07:06:29 <SamB_XP> copumpkin: how does it do that ?
07:06:29 <BONUS> :t os
07:06:30 <lambdabot> Not in scope: `os'
07:06:35 <BONUS> :t System.Info.os
07:06:36 <lambdabot> String
07:06:42 <BONUS> it should be IO String imo
07:07:05 <copumpkin> BONUS: ah, I agree there. It really depends how far you intend to take the notion of purity :P
07:07:33 <BONUS> yeah hehe it's a preference thing
07:07:46 <SamB_XP> I expect some Haskell implementations will have to return bogus results there
07:08:06 <SamB_XP> or just leave the module out entirely
07:08:49 <quicksilver> lilac: I believe you can implement STRef in State using Typeable (and, thus, only for Typeable types)
07:09:19 <copumpkin> BONUS: but I'd be all for it :) it'd make me feel better about getting a "distributed haskell" (à la erlang) project going
07:09:24 <quicksilver> well Typeable + unsafeCoerce, yes, ala Dynamic.
07:13:52 <quicksilver> lilac: I think it's interesting to speculate "why" we need unsafeCoerce for this. Where is the hole in the language?
07:14:40 <nanothief> I always thought of purity as applying for a single run of the program. In that case, System.Info has the right type. Is there any advantage to having purity extend beyond that?
07:14:48 <Saizan> quicksilver: where this == typed heap like for ST?
07:16:59 <quicksilver> Saizan: yes.
07:17:07 <quicksilver> nanothief: Yes.
07:17:23 <quicksilver> nanothief: think of application servers, supercompilation, distributed computing
07:18:12 <nanothief> quicksilver, yeah I suppose you're right
07:18:26 <quicksilver> I mean, I'm not going to pretend it's the most important thing in the world.
07:18:46 <lilac> quicksilver: i think the problem is that either we store type 'a' inside a container which knows 'a' (such as inside the STRef itself) or we have a proof obligation that the types match when we later want to use it
07:18:47 <quicksilver> but that type missing 'IO' is certainly immoral, pernicious, and evil.
07:19:19 <quicksilver> lilac: Sure, but why can't I create fresh containers of type 'a'?
07:19:27 <quicksilver> why can't I write my own newSTRef ?
07:19:56 <lilac> quicksilver: the same problem applies recursively, doesn't it? your container type involves 'a'
07:20:10 <lilac> how are you going to prove to the type system that it's ok?
07:21:10 <quicksilver> well "[]" can construct a list of any type 'a'
07:21:15 <quicksilver> why is this fundamentally different?
07:21:37 <lilac> the list elements are stored with the list, so the proof that they're the right type is implicit
07:21:47 <quicksilver> I disagree.
07:21:51 <lilac> the STRef values are stored with the state, not with the STRef
07:21:57 <quicksilver> The proof that they're the right type is contained in the type of [] and :
07:22:05 <lilac> right
07:22:11 <quicksilver> I don't see why I can't do something similar with Refs
07:22:28 <lilac> we're not storing the state in the STRef though
07:22:39 <lilac> we're storing it in a different type which /doesn't even mention 'a'/
07:23:15 <quicksilver> I can make a polymorphic heap constructor, though.
07:23:33 <quicksilver> data Heap = Empty | Cons (Cell a) Heap
07:23:59 <quicksilver> I'm not being gratuitously stupid, I do know this doesn't work.
07:24:08 <quicksilver> But I don't know what the *deep* reasons for it are. Only the shallow ones.
07:24:18 <EvilTerran> I think you could make something ST-like to work with a bit of olegian trickery
07:24:50 <lilac> quicksilver: must there /be/ a deep reason? you can implement your own newSTRef in terms of the ST monad
07:24:52 <quicksilver> EvilTerran: if you can do it without unsafeCoerce I would like to see it.
07:25:16 <EvilTerran> with the monad type having something HList-esque for the different types referenced
07:25:26 <quicksilver> oh yes, you can certainly do that
07:25:31 <quicksilver> although it's not a monad any more
07:25:37 <Saizan> quicksilver: i think the problem is that you've to somehow reify the identity of each ref to the type level
07:25:41 <quicksilver> since its type changes across the bind operator.
07:25:50 <lilac> that's not the goal, though. i think we want typed keys into an untyped container
07:25:52 <quicksilver> it's a generalised monad or some kind.
07:26:10 <EvilTerran> hmm...
07:26:12 <lilac> the typing on the keys should be the proof that the value in the container is the right type
07:26:31 <Saizan> quicksilver: so that you can prove things like forall (ref1 :: R a, ref2 :: R b), ref1 = ref2 ==> a = b
07:27:20 <quicksilver> Saizan: but on the other hand, ST works.
07:27:22 <EvilTerran> quicksilver, i think it might be possible as an actual monad; haven't worked out the details, though
07:27:26 <EvilTerran> requires trickeryt.
07:27:33 <quicksilver> I mean, its implementation cheats, perhaps.
07:27:45 <quicksilver> but our type system is sufficient to keep ST 'safe' once implemented.
07:27:50 <quicksilver> so why isn't it sufficient to implement it?
07:29:27 * EvilTerran ponders... is it possible, using polymorphic recursion, to make an ST action that uses an infinite number types "a" in "STRef r a"?
07:30:13 <quicksilver> makeDeepTuple s = do { r <- newSTRef s; makeDeepTuple (0,s); }
07:30:15 <quicksilver> EvilTerran: yes.
07:30:24 <EvilTerran> well, that kills my idea dead
07:30:29 <EvilTerran> even with generalized monads
07:31:33 <EvilTerran> you can't make an HList with all types STRef'd in an ST action, in general
07:33:20 <lilac> Re ST, I'd like to see a solution to this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6628#a6628
07:34:11 <mauke> wait, empty is a static value?
07:34:21 <EvilTerran> lilac, you'd at least need u'p'IO to implement newKey
07:34:40 <mauke> ah, wait
07:34:44 <Saizan> lilac: can i use unsafeCoerce?
07:34:48 <EvilTerran> seeing as you'd need some kind of global variable
07:35:16 <lilac> EvilTerran: newKey is :: IO (Key a)
07:35:33 <Saizan> EvilTerran: you could be evil and use a newtyped IORef () as key
07:35:39 <SamB_XP> EvilTerran: that's a wierd way to spell it
07:35:49 <SamB_XP> or weird, I guess
07:35:50 <lilac> Saizan: i think unsafeCoerce is cheating too
07:36:02 <SamB_XP> I never understood why you spell weird that way ...
07:37:15 <Twey> They just wanted it to be autological
07:37:15 <lilac> EvilTerran: ok, yes, sorry, i missed why you'd need unsafePeformIO there.
07:38:30 <lilac> I think it's impossible anyway, since whatever you do inside 'get' cannot depend on /a/, and the type system can't tell that newKey won't return equivalent keys for different types 'a'
07:38:49 <Saizan> uhm
07:38:55 <EvilTerran> SamB_XP, if i had tab-completion for words other than nicks, i'd've written it in full; i'm just lazy and fond of contracting words on irc
07:38:58 <lilac> so if newKey returned the 'same' key for different types then you could implement unsafeCoerce with this
07:39:13 <Saizan> you could hide a typelevel Nat inside the Key and use that to index..
07:39:56 <EvilTerran> Saizan, but how the heck would you increment such a key?@
07:40:08 <EvilTerran> (in newRef, i mean)
07:40:15 <lilac> Saizan: there may be uncountably many types potentially stored in Container
07:40:19 <Saizan> oj, right
07:40:35 <lilac> (obviously only finitely many types actually stored, though)
07:40:40 <Saizan> you'd need Container to make a nre Ref
07:40:48 <quicksilver> I seriously doubt it may be uncountable
07:40:48 <Saizan> *new
07:40:59 <EvilTerran> lilac, er, any collection of types is fundamentally countable, surely, seeing as they're expressible as words of a finite alphabet
07:41:11 <Saizan> lilac: you can create types at runtime, more or less
07:41:39 <quicksilver> btu, it certainly draws from an infinite set
07:42:10 * EvilTerran likes that almost all infinities involved in computer science are countable. it makes things a lot easier.
07:43:50 <doserj> *almost* all?
07:43:57 <EvilTerran> lilac, would (taking Saizan's comment) making "newKey :: Container -> (Container, Key a)" do?
07:44:42 <EvilTerran> doserj, there's uncountably many turing-acceptance problems, for instance
07:44:56 <lilac> EvilTerran: i've been considering that, but then you have the problem of using a Key in a container which didn't create it
07:45:14 <EvilTerran> (and countably many turing-acceptors; shortest proof of the existence of undecidable problems _evar_ :P)
07:45:21 <maartenm> map (read :: Int) (show 512)
07:45:25 <maartenm> what's wrong with this?
07:45:30 <EvilTerran> ?type read
07:45:32 <lambdabot> forall a. (Read a) => String -> a
07:45:33 <quicksilver> read doesn't have type it
07:45:35 <maartenm> I thought it would output [5,1,2]
07:45:36 <quicksilver> Int.
07:45:42 <EvilTerran> maartenm, "String -> a" doesn't unify with "Int"
07:45:46 <quicksilver> it could have type (String -> Int) perhaps.
07:45:51 <lilac> EvilTerran: right, it can't be uncountable, silly me
07:45:52 <EvilTerran> > map (read :: String -> Int) (show 512)
07:45:54 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:46:11 <EvilTerran> ^ maartenm, and there's the next problem
07:46:11 <maartenm> ok..
07:46:16 <maartenm> but
07:46:25 <maartenm> read "512" :: Int      works, right
07:46:26 <maartenm> so
07:46:29 <lilac> > map digitToInt (show 512)
07:46:31 <lambdabot>   [5,1,2]
07:46:33 <maartenm> map (\x -> (read x ::Int)) (show 512)
07:46:40 <maartenm> shoudl work too?
07:46:48 <BONUS> > (read :: String -> Int) (show 512)
07:46:49 <EvilTerran> maartenm, not quite; String /= Char
07:46:49 <lambdabot>   512
07:47:04 <EvilTerran> > map (\x -> read [x] :: Int) "512" -- maartenm
07:47:05 <lambdabot>   [5,1,2]
07:47:16 <lilac> but seriously, use digitToInt ;-)
07:47:19 <maartenm> ok, I see
07:47:30 <maartenm> where is digitToInt located
07:47:37 <maartenm> can lambdabot do that?
07:47:38 <EvilTerran> maartenm, the other problem is that, when you map over a String, which is a [Char], the function you pass to map must take a Char, not a [Char]
07:47:51 <EvilTerran> because of the type of map
07:47:56 <EvilTerran> ?index digitToInt
07:47:57 <lambdabot> Data.Char
07:48:13 <EvilTerran> ?docs Data.Char
07:48:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
07:48:29 <boml> can i pattern match on a string starting with e.g. "hello"?
07:48:52 <EvilTerran> boml, unfortunately, only by writing the pattern as ('h':'e':'l':'l':'o':xs)
07:48:58 <hackagebot> OpenVG 0.2 - OpenVG (shivag-0.2.1) binding (StephenTetley)
07:49:00 <EvilTerran> boml, it may be nicer to use stripPrefix
07:49:07 <EvilTerran> ?hoogle stripPrefix
07:49:08 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
07:49:14 <Shurique> (take 5 -> "hello")
07:49:24 <doserj> @hoogle isPrefixOf
07:49:24 <BONUS> use guards imo
07:49:25 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
07:49:25 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
07:49:25 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
07:49:45 <EvilTerran> > map (stripPrefix "foo") ["foobar", "barfoo", "foo", "fo", "", "bazfoobar"]
07:49:47 <lambdabot>   [Just "bar",Nothing,Just "",Nothing,Nothing,Nothing]
07:49:52 <BONUS> foo xs | "hello" `isPrefixOf` xs = ... | otherwise = ...
07:50:28 <EvilTerran> stripPrefix being explicitly intended for precisely this purpose
07:50:36 <boml> EvilTerran: thx
07:50:36 <lilac> , let foo (stripPrefix "hello" -> Just xs) = "goodbye" ++ xs; foo _ = "huh?" in foo "hello world"
07:50:47 <lunabot>  "goodbye world"
07:50:56 <EvilTerran> with -XViewPatterns, the patten (stripPrefix "foo" -> Just rest) would suit
07:50:57 <lilac> , let foo (stripPrefix "hello" -> Just xs) = "goodbye" ++ xs; foo _ = "huh?" in foo "bonjour le monde"
07:50:59 <lunabot>  "huh?"
07:51:18 <EvilTerran> with -XPatternGuards, you could write "foo xs | Just rest <- stripPrefix "foo" xs"
07:51:20 <EvilTerran> etc etc
07:51:56 <lilac> would those compile to the same core as the explicit pattern match?
07:52:16 <EvilTerran> lilac, going back to your Container example, we seem to be wandering back towards the same interface as ST, seeing as we'd need something like its existential parameter to stop people using references in the wrong collection
07:52:56 <EvilTerran> i don't think stripPrefix would necessarily inline fully, as it's recursive
07:53:11 <EvilTerran> but it'd be premature optimisation to use the explicit pattern-match just for that
07:54:34 <lilac> EvilTerran: yeah, i've pretty much come to the same conclusion.
07:55:06 <Twey> Why can't you inline a recursive function?
07:55:11 <EvilTerran> might be possible to make it inline when its first parameter is constant with some cleverly-written RULES
07:55:14 <Twey> In assembly it's just a jump
07:55:19 <EvilTerran> (constant and finite, rather)
07:55:46 <EvilTerran> Twey, i think it's that, when you start inlining recursive stuff, proving the termination of your inlining algorithm gets a lot harder
07:56:00 * SamB_XP wonders how expensive nucleic-acid-reading hardware is
07:56:05 <quicksilver> well, not particularly if you just inline the entire body
07:56:14 <quicksilver> btu that's also fairly useless.
07:56:28 <quicksilver> since the body is of the form (fix $ ....)
07:56:43 <quicksilver> which is not likely to conveniently optimise against nearby things.
07:57:01 <quicksilver> the point of inlining is to enable further optimisations etc
07:57:04 <maartenm> what's the haskell equivalent of split?   split (' ') "alpha beta gamma" = ["alpha", "beta", "gamma"]
07:57:18 <EvilTerran> > words "  foo  bar  baz  "
07:57:19 <lambdabot>   ["foo","bar","baz"]
07:57:19 <MyCatVerbs> maartenm: for that specifically, words.
07:57:30 <anteaterNethack> look at http://hackage.haskell.org/package/split-0.1.1
07:57:39 <anteaterNethack> for more general splits.
07:57:48 <anteaterNethack> (words only splits on spaces.)
07:57:49 <EvilTerran> maartenm, for more general stuff, the "split" package has some nicely general splitting combinators
07:57:57 <maartenm> ok, thanks
07:57:59 <MyCatVerbs> For splitting on a regular expression, you'll need one of the regular expression libraries. There's a libpcre binding hanging around somewhere, amongst others.
07:58:08 <SamB_XP> quicksilver: yeah, if the fix was optimizable it should have been optimized already by that point
07:58:09 <maartenm> pity that's not in the standard libs
07:58:09 <EvilTerran> maartenm, but, in the Prelude, "words" and "lines" do the two common cases
07:58:18 <anteaterNethack> oh, use a real parser (Text.Parsec) if the problem gets any more complicated.
07:58:23 <maartenm> I really like the regular expression splitting in ruby
07:58:41 <EvilTerran> the haskell mindset seems to clash with the regex mindset slightly
07:58:55 <SamB_XP> hmm ... though what if the fix'd function had a constructor application in it?
07:59:11 <rocketman> I think ruby learned it from perl
07:59:12 <SamB_XP> I mean, returned a constructor application
07:59:20 <SamB_XP> EvilTerran: in which ways?
07:59:28 <SamB_XP> we love regexen!
07:59:29 <EvilTerran> SamB_XP, in that we go for words and combinators over symbols and strings
07:59:36 <boml> can I quickly pull out the Just value from a Maybe without having to define a new function?
07:59:53 <SamB_XP> we love them so much we use the normal Haskell syntax to express them
07:59:53 <saml> boml, yes
07:59:55 <EvilTerran> boml, you can pattern-match it
08:00:05 <saml> > case (Just 1) of (Just 1) -> True
08:00:07 <lambdabot>   True
08:00:19 <saml> > case (Just 1) of (Just a) -> a
08:00:20 <lambdabot>   1
08:00:27 <quicksilver> SamB_XP: I think that might the case that you use the 'go' idiom
08:00:40 <quicksilver> SamB_XP: (to make the constructor of the recursive call visible)
08:00:46 <EvilTerran> SamB_XP, also the matter of regexen etc tending to be less typesafe than combinators
08:00:53 <quicksilver> or is that just to make the inlining visible for rules?
08:00:55 <quicksilver> I dunno ;)
08:01:00 <saml> write a goto monad and blog since php and javascript have goto
08:01:05 <SamB_XP> quicksilver: hmm, I was just pondering whether there was anything the compiler might do in that case
08:01:33 <EvilTerran> saml, there's the Cont monad, that's pretty close to gotos :P
08:01:48 <SamB_XP> javascript has goto?
08:01:51 <SamB_XP> crazy shit
08:01:59 <EvilTerran> i don't think js has goto...
08:02:01 <SamB_XP> is it local-only?
08:02:39 <saml> http://www.summerofgoto.com/ :P
08:02:51 * Woof <3 Goto
08:03:09 <jmelesky> javascripy has a labelled continue, but no goto to my knowledge
08:03:51 * timonator <3 PHP
08:04:08 <timonator> haha, right?
08:04:12 <Vq^> it has loops, they are evil too
08:04:13 <jmelesky> ah. a goto library. python has one of those, too: http://entrian.com/goto/
08:04:19 * Woof </3 PHP
08:05:15 <rocketman> goto is a gimmick, we have more expressive constructs
08:05:30 <saml> so haskell needs goto too to be enterprise ready
08:05:52 <jmelesky> goto doesn't sound lazy enough
08:06:01 <saml> there was Basic thingy from augustss
08:06:02 <jmelesky> haskell clearly needs comefrom instead
08:06:17 <maartenm> heh
08:06:32 <EvilTerran> you could probably implement either goto or comefrom with Cont
08:07:00 <EvilTerran> although you may need MonadFix for forward jumps
08:07:15 <EvilTerran> ?type callCC (modify . (:))
08:07:16 <lambdabot> forall (m :: * -> *) b. (MonadState [() -> m b] m, MonadCont m) => m ()
08:07:34 <saml> http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html GOSUB
08:07:42 <timonator> comefrom is actually clever!
08:08:37 <copumpkin> GOSUB GOSUB GADGET BASIC
08:09:26 <doserj> comefrom is nowadays called aspect-oriented programming, isn't it?
08:09:35 <jmelesky> heh
08:10:18 <Twey> Haha
08:10:59 <quicksilver> copumpkin++
08:11:11 <copumpkin> :)
08:11:46 * Woof <3 BASIC
08:11:55 <boml> > case stripPrefix "foo" "foobar" of (Just x) -> x
08:11:57 <lambdabot>   "bar"
08:12:14 * EvilTerran ponders if forward jumps would also be possible with using an EtatsT to hold the continuations
08:12:25 <EvilTerran> probably not...
08:12:52 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6630#a6630
08:13:06 <maartenm> why do I get a type complaint?  Instance of Num [Char]
08:13:15 <maartenm> ( Instance of Num [Char] required for definition of numToHL)
08:13:23 <quicksilver> maartenm: becuase you're trying to use + ons trings.
08:13:25 <copumpkin> how hard would it be to make a "reverse monad" that sequences its wrapped monad backwards?
08:13:25 <quicksilver> on strings.
08:13:29 <maartenm> ok
08:13:33 <quicksilver> copumpkin: impossible.
08:13:40 <copumpkin> I guess that makes sense
08:13:42 <quicksilver> copumpkin: although you can do it for applicative.
08:13:44 <maartenm> very confusing that I get the complaint on line 8
08:14:13 <copumpkin> ah cool
08:14:15 <maartenm> ok works fine with ++
08:14:20 <copumpkin> that makes sense
08:14:32 <quicksilver> maartenm: don't use hugs.
08:14:41 <maartenm> yeah, sorry
08:14:41 <quicksilver> if you use ghci, you get the error on line 12.
08:14:45 <maartenm> I just can't help it
08:14:47 <quicksilver> which is where it is.
08:14:48 <maartenm> it's so fuzzy and warm
08:14:52 <quicksilver> :)
08:15:02 <maartenm> I'll try winghci
08:15:12 <maartenm> ghci doesn't allow copy-pasting, f.i.
08:15:24 <quicksilver> yes it does.
08:15:33 <maartenm> mine doesn't.. when I paste, it pastes one character
08:15:34 <boml> maartenm: it's being fixed as we speak
08:15:42 <maartenm> ah, ok
08:15:50 <quicksilver> that sounds like a bug in the terminal program anyway?
08:15:52 <boml> maartenm: next ghc
08:16:12 <boml> search for paste in the bug database
08:16:53 <Vq^> quicksilver: maybe the Microsoft Windows version implements its own terminal...
08:17:26 <badsheepy> my terminal did the 1 character pasting thing for a while, till i rebooted once
08:17:36 <quicksilver> sonuds like a reason to run ghci in winemacs
08:17:39 <quicksilver> or whatever it's called.
08:17:43 <badsheepy> cant say if it repeated itself, cause i gave up and installed linux :o
08:18:55 <maartenm> yeah I'll try emacs integration
08:19:18 <maartenm> sadly, I'm at work where I have to use windows
08:19:30 <Zao> maartenm: That's a perk.
08:20:01 <maartenm> I suddenly realize I've been talking here for the past 8 hours
08:22:27 <defun> how do I get a module to export instance declarations?
08:22:43 <EvilTerran> instances are global, you don't have to export them explicitly
08:23:00 <EvilTerran> (see mtl's Conrol.Monad.Instances, which exports nothing, but defines instances)
08:23:34 <defun> cool. How do I get a module to exclude functions that are not used outside the module (i.e. they are only used in the instance declarations)?
08:23:59 <defun> an empty list?
08:24:11 <defun> like module X () where import...
08:24:20 <EvilTerran> module Foo () where -- exports no names
08:24:58 <defun> thanks.
08:40:00 <fasta> What does ALWAYS mean in ghc core output?
08:40:15 <fasta> Or is the ghc core documented somewhere completely?
08:43:59 <fasta> Wow, if you get rid of all the overloading, core becomes readable.
08:44:58 <delusion42> Can someone help me with my parsec eof woes? :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6631#a6631
08:48:28 <doserj> delusion42: I guess that you have whitespace after the last pcx/ptx/whatever?
08:49:05 <delusion42> doserj: actually, i think it's '}' and then EOF immediately.
08:49:10 <fasta> Although, it seems it does not optimize 0.5*x + 1.5*x to just one multiplication, or is this incorrect in general?
08:49:51 <fasta> In fact, it's not +, but ,.
08:49:55 <delusion42> doserj: so i'd expect the 'eat' in the manyTill action to not ever be executed due to eof being encountered.
08:50:31 <maartenm> aaargh, #17 of euler is so silly.. I could swear I have it right
08:50:38 <maartenm> and yet I get the red cross of shame
08:50:55 <doserj> delusion42: does 'many (eat >> (pcx <|> ..))' work?
08:51:22 <delusion42> with no explicit check for eof? nope, same result -- it's what i tried first
08:51:56 <pikhq> I just *had* to do project #3 in the single most naive way possible.
08:53:26 <delusion42> doserj: wow, wierd: many (eat >> (pcx <|> ...) >>= \vs -> do eat ; return vs) does work, however.
08:53:30 <pikhq> Generate the list of primes via a naive sieve, then use a list comprehension to filter out the numbers that it's not divisible by... Nice looking, but absurdly slow.
08:54:08 <boml> how can i put an icon into an exe with ghc?
08:55:11 <doserj> delusion42: many (eat >> (pcx <|> ...) >> eat) should work, too then (though it's a bit silly :)
08:55:33 <doserj> ah, no
08:55:47 <delusion42> yeah, a little different
08:55:56 <delusion42> but still, i'm not clear why the latter 'eat is needed here.
08:56:09 <delusion42> doserj: oh well, it works. thanks for peeking at it. ;P
08:56:15 <Vq^> boml: isn't it better to have it outside of the program?
08:56:34 <doserj> delusion42: aah, eat succeeds on empty input, that's your problem...
08:56:51 <boml> Vq^: outside is fine. as long as the exe has an icon when I look at it in the file explorer
08:56:57 <delusion42> doserj: aaah, you're right. good catch.
08:57:09 <pikhq> Vq^: Windows. They link icons into the program by routine.
08:57:40 <pikhq> boml: It's some trick with the linker, but I'm not sure what. *Should* be the same was what you'd do for other programs, though.
08:57:49 <Vq^> pikhq: it's added to the binary in the linking process?!?
08:58:05 <pikhq> Vq^: Yes.
08:58:12 <Vq^> oh
08:58:18 <lilac> maartenm: did you include the 'and's?
08:58:32 * pikhq holds out a vomit bag for Vq^.
08:58:43 <lilac> maartenm: and the 'u's in fourty-four?
08:59:01 <maartenm> oh crap
08:59:02 <Vq^> boml: it is Windows you are talking about?
08:59:05 <fasta> Still, GHC core is horrible to look at. All kinds of useless suffixes.
08:59:10 <maartenm> didn't know about fourty-four
08:59:20 <boml> Vq^: yepp good ol windoze. you gotta love it.
08:59:21 <maartenm> I thought it was forty-four
08:59:32 <Vq^> pikhq: well, it's more silly than vomit inducing...
08:59:35 <maartenm> I ran the whole thing through a spell checker, but after I split everything in words
09:00:23 <maartenm> but no, it is forty-four
09:00:35 <Vq^> boml: ah, sorry. i don't have a clue then
09:00:43 <boml> sadness.
09:01:05 <lilac> maartenm: i think 'forty' is more correct, but you never know with project euler :)
09:02:02 <lilac> maartenm: are you actually generating the words or just counting the letters?
09:02:07 <maartenm> I found my error
09:02:11 <SamB> lilac: one hopes you know after you get a checkmark
09:02:14 <maartenm> I forgot the number thirteen -_-
09:02:22 <lilac> SamB: one hopes ;-)
09:02:23 <SamB> maartenm: forgot how?
09:02:29 <EvilTerran> D:
09:02:31 <maartenm> wait I'll show you the code
09:02:39 <lilac> maartenm: ["eleven","twelve","fourteen", ...] ?
09:02:47 <maartenm> yes
09:02:52 <lilac> oops! :)
09:02:55 <maartenm> rather ironically, the number thirteen was missing
09:03:05 <maartenm> now I get the correct result
09:03:06 <SamB> hehehe
09:03:47 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6632#a6632   ugliest haskell code I've written today, though
09:03:51 * SamB wonders how stupid it would be to use Inform in solving that
09:04:12 <Vq^> isn't that the same floor level that is missing in some foreign countries? :)
09:04:27 <SamB> Vq^: foreign to who?
09:04:45 <SamB> in case you forgot, I don't even know what country you're *in*
09:05:11 <SamB> though I might be able to guess if I remembered (ever knew?) where telia was
09:05:12 <Vq^> SamB: :)
09:05:35 <SamB> but, yes, some buildings "skip" that floor
09:06:10 * Vq^ finds that hilarious
09:06:12 <SamB> though in fact they sometimes do actually have one, but just use it for facilities
09:06:42 <quicksilver> "Dilip Rangnekar of Otis Elevators estimates that 85% of the buildings with elevators did not have a floor named the 13th floor"
09:06:44 <SamB> like, you know, air conditioning, heating, resonance-cancellers
09:06:45 <quicksilver> so there you go.
09:06:49 <badsheepy> some more multicultural ones skip other numbers also
09:06:54 <badsheepy> 8 i think?
09:07:32 <badsheepy> and more! :d
09:07:33 <SamB> possibly space missions will in future skip "13" ;-)
09:07:46 <Vq^> badsheepy: thats ridiculous
09:08:04 <SamB> Vq^: not for hospitals it isn't
09:08:04 <lilac> quicksilver: what proportion of the buildings with elevators have a floor named the 14th floor?
09:08:08 <maartenm> we already skipped the version number "13" for our major software release
09:08:13 <Vq^> SamB: how so?
09:08:15 <maartenm> because our american customer did not want it
09:08:15 <lilac> quicksilver: might it be less than 15%? :)
09:08:25 <fasta> Some organizations skip 13, but actually there is a top-secret facility located at floor 13.
09:08:41 <SamB> Vq^: if you have superstitious patients, you really don't want to have them on a floor numbered with what they think is an unlucky or death-related number, do you?
09:09:00 <SamB> it's kind of *bad* for their health, you know?
09:09:00 <quicksilver> the 13th floor is where they grow the lambdas from seed
09:09:02 <quicksilver> and train them.
09:09:18 <badsheepy> oh, its 4 thats unlucky in asian languages cause it sounds like the word for death
09:09:33 <badsheepy> also 14 :o
09:10:19 <Vq^> SamB: it's still ridiculous
09:10:33 <pikhq> badsheepy: In Japanese, only one of the two readings for 4 sounds like that.
09:10:48 <badsheepy> how many do you need before it gets a bad rep :p
09:10:48 <SamB> Vq^: the placebo effect is ridiculous, you say?
09:11:08 <Vq^> SamB: no, i didn't say that
09:11:14 <pikhq> They're a bit more likely to use the native Japanese "yon" instead of "shi", from Chinese, since "shi" sounds quite a bit like "shinu"...
09:11:57 <maartenm> thanks for all the help people, see you tomorrow, most likely
09:12:00 <Vq^> SamB: it's silly that enough people are superstitious to begin with
09:12:03 <SamB> Vq^: well, it's still kind of funny, yes, when your relative didn't just die from partly because of superstitious beliefs they might have about the floor they were on.
09:12:25 <SamB> and if the number actually sounds like death, it might make even a non-superstitious person think about death too much
09:12:49 <Vq^> SamB: you really think so?
09:13:47 <pikhq> Vq^: It's at least a more sensible superstition than the number 13.
09:14:06 <SamB> Vq^: yes, I do
09:14:13 <SamB> that's the way brains work
09:14:20 <SamB> like it or not
09:14:25 <Vq^> pikhq: a tiny bit, yes
09:14:41 <monochrom> Oh! The great number 4. :)
09:14:50 <monochrom> 4444444444444
09:15:25 <SamB> I'm not saying that the non-superstitious person would suddenly become superstitious, just that they might free-associate a bit much sometimes...
09:15:29 <lilac> > repeat 4
09:15:31 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
09:15:34 <lilac> oh noes!
09:15:44 <pikhq> > cycle "4"
09:15:45 <monochrom> I actually designate 4 to be my lucky number or random number of choice. It is because my classmates in highschool gave me the nickname "4 seconds".
09:15:46 <lambdabot>   "44444444444444444444444444444444444444444444444444444444444444444444444444...
09:15:49 <pikhq> OH NOES!
09:16:35 <lilac> > cycle "no! "
09:16:37 <lambdabot>   "no! no! no! no! no! no! no! no! no! no! no! no! no! no! no! no! no! no! no...
09:16:41 <lilac> oh no!s
09:16:43 <tromp> do u like connect 4?
09:17:05 <monochrom> My favourite random TCP/IP port number for testing is 9413 "90% probability of dying".
09:17:47 <monochrom> Another one is 5354 "not live not dead"
09:17:50 <SamB> monochrom: what ?
09:17:55 <Vq^> why not just use binary code in hospital then?
09:17:58 <SamB> is this i ching or some such nonsense?
09:18:07 <Vq^> i've never heard that 0 or 1 should be "unlucky"
09:18:22 <SamB> Vq^: too hard to remember numbers in binary
09:18:29 <monochrom> "this" = ?  "this" = my choice?  "this" = the meaning of 9413?
09:18:30 <SamB> they have too many digits
09:18:39 <lilac> isAlive Vq^ = 0 | 1
09:18:44 <SamB> monochrom: the way you get those meanings from those numbers
09:19:09 <monochrom> Plain Chinese pun.
09:19:33 <SamB> monochrom: ah
09:19:33 <Vq^> SamB: base 10 then, but with some cute cuddly animals as digits
09:19:39 <lilac> monochrom: probably not the best audience for that :)
09:19:44 <Vq^> now that wouldn't be silly :)
09:19:50 <SamB> Vq^: ala megaman 7 passwords ?
09:20:01 <titto> wu shen wu si  = wu san wu si = 5354 in chinese
09:20:16 <Vq^> SamB: never played megaoid man 7
09:20:21 <monochrom> You've just heard 4=death, 3=live.  Now just look at 9 as 90% and 1 as 10%.
09:20:25 <SamB> Vq^: megoid?
09:20:40 <Vq^> SamB: mega
09:20:53 <Vq^> SamB: were they cute?
09:20:58 <SamB> Vq^: well, okay, not exactly
09:21:08 <Vq^> wont do then... :P
09:21:10 <SamB> well, except Roll I guess
09:21:31 <SamB> well, Rock is cute in a little-kid cute sorta way ...
09:21:41 <monochrom> Chinese colloquia doesn't talk about how many percents i.e. x/100, it talks about x/10 instead. We don't say 90 percent, we say 9 somethingelse.
09:21:52 <SamB> ... but not with his helmet on!
09:22:03 <titto> in chinese 3 sounds like the word for 'alive' and 4 as the word for "dead" and "5" as "not" so 5354 = "not alive not dead"
09:22:32 <monochrom> And Chinese is a concatenative language!
09:22:33 <SamB> monochrom: 9 perdec?
09:22:42 <monochrom> Yeah.
09:23:35 <hzap> yeah sometimes chinese ads will say "6.5 perdecs off!", with the correct translation of "perdec" of course
09:24:48 <boml> guys. it's really simple to embedd an icon. It's just a matter of setting the path and then compiling the icon.rc file with windres.exe. Finally use ghc to get the icon.o file into the exe.
09:25:13 <titto> why is Chinese a concatenative language?
09:25:31 <monochrom> (because Chinese makes sense)
09:25:42 <hzap> what is a concatenative language anyways?
09:26:08 <pikhq> Concatenate words to create new words.
09:26:20 <pikhq> (I assume)
09:27:27 <hzap> it doesn't feel any more concatenative than english to me then...
09:27:33 <ray> you mean like german?
09:27:47 <Ferdirand> Awesome. I just learned that some aboriginal languages use native binary counting.
09:27:59 <pikhq> Awesome.
09:28:08 <centrinia> Which ones?
09:28:10 <SamB> and some places they say "your northwest leg"
09:28:14 <ray> a natural next step from native unary
09:28:21 <SamB> instead of "your right leg" or "your left leg"
09:28:46 <monochrom> "not live not dead" is an error in English, you have to put a conjunctive or at least a punctuation there. In Chinese you may just concatenate. You may add a conjunctive but it's not fun.
09:29:06 <SamB> monochrom: so ... that's even worse than the others
09:29:12 <SamB> since it means you'll become a zombie
09:29:21 <SamB> or other undead thing
09:29:27 <lilac> SamB: which one is the northwest leg? does it depend which way you're facing?
09:29:49 <SamB> lilac: yes, obviously
09:29:55 <monochrom> Yeah I like testing my socket programs with 5354. :)
09:30:13 <lilac> SamB: what if it's night-time and i can't see the sun? how do i know which leg you mean? ;-)
09:30:19 <hzap> monochrom: but you still don't just randomly concatenate as you wish, there's still a syntax
09:30:31 <lilac> *stars
09:30:32 <SamB> I hate that services are offered on sockets with those little tiny numbers
09:30:57 <paolino> hi, what is the english definition of iteratee
09:30:59 <SamB> I think it'd make more sense if connecting to a service involved sending a short textual service name
09:31:06 <lilac> SamB: i tried to run an ssh server using graham's number as the port, but things didn't work out so well
09:31:11 <SamB> like, "http:1"
09:31:20 <lilac> SamB: isn't that what DNSSD is about?
09:31:25 <SamB> dunno!
09:31:35 <quicksilver> yes, it is.
09:31:53 <quicksilver> although it still uses well-known ports for well-known services afaik
09:32:05 <monochrom> That's what "web services" are doing! Send a short textual service description out.
09:32:09 <SamB> does that involve the services telling DNSSD what port they're on when they come up?
09:32:23 <SamB> (and how does DNSSD know if they're still up?)
09:32:24 <pikhq> lilac: I prefer Munroe's number.]
09:32:24 <quicksilver> it involves multicast and everybody shouting all at once
09:32:26 <quicksilver> I think.
09:32:36 <SamB> monochrom: that's not what I'm talking about
09:32:46 <SamB> quicksilver: that doesn't sound like it either
09:33:14 <SamB> I'm thinking, like, there would be no TCP "SYN" packet
09:33:46 <SamB> because you wouldn't know what port number to send it to yet
09:34:23 <paolino> it looks like an haskell world word, iteratee
09:34:35 <lilac> unless you're ditching IP, you'd need at least one well-known port to do service discovery on, right?
09:34:38 <monochrom> There is an isomorphism between "no port specified" and "everyone just use port 5354".
09:35:08 <Ferdirand> this service is DNS or mDNS, afaik
09:44:00 <Taejo> @instances Functor
09:44:01 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:44:27 <Taejo> are there any interesting Functors that aren't Applicatives?
09:44:40 <Taejo> I know ZipList is Applicative but not Monad
09:45:46 <EvilTerran> (a,) is a Functor, but not an Applicative without some way of combining the "a"s
09:46:50 <quicksilver> EvilTerran: not just that, some way to fabricate an 'a' out of nowhere.
09:46:55 <Taejo> EvilTerran: ah, right. Don't know why I thought it was
09:46:57 <lilac> "Map a" is a Functor, but not an applicative
09:46:59 <EvilTerran> true
09:47:00 <quicksilver> IMO that's the harder problem.
09:47:32 <quicksilver> to combine two you could just discard the first, for example.
09:47:34 <lilac> what do you call a Functor with <*> but no pure
09:47:41 <quicksilver> but inventing one out of nowhere is trickier.
09:48:02 <Taejo> quicksilver: no, <*> has a commutativity law
09:48:07 <quicksilver> lilac: I don't call it anything until someone convinces me it's useful.
09:48:08 <Taejo> so you can't drop one
09:48:23 <quicksilver> Taejo: does it? what form does it take?
09:48:26 <monochrom> unpure applicative :)
09:48:39 <lilac> quicksilver: you have <$> and <*>, which cover the major uses of Applicative
09:49:06 <lilac> quicksilver: but i assume you mean, when does it arise?
09:49:06 <Taejo> quicksilver: u <*> pure y = pure ($ y) <*> u
09:49:10 <monochrom> It's pretty hard to lack pure.
09:49:24 <quicksilver> Taejo: that's not commutativity.
09:49:27 <lilac> "(,) a" has no pure but you could define <*> if you wanted
09:49:36 <quicksilver> Taejo: that's how it works with pure.
09:49:40 <quicksilver> Taejo: which is what I said :)
09:49:56 <quicksilver> Taejo: "not just that, some way to fabricate an 'a' out of nowhere"
09:50:29 <Taejo> quicksilver: well it involves pure and <*> but I've always seen it as more related to <*> -- I guess because pure is usually trivial
09:50:50 <lilac> likewise, i could imagine a <*> for Data.Map, but you couldn't really define pure
09:50:54 <quicksilver> I disagree.
09:50:57 <quicksilver> pure is key ;)
09:50:57 <jeffwheeler> @hoogle modify
09:50:58 <lambdabot> Control.Monad.State.Class modify :: MonadState s m => (s -> s) -> m ()
09:50:58 <lambdabot> System.IO.Error modifyIOError :: (IOError -> IOError) -> IO a -> IO a
09:50:58 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
09:51:04 <lilac> quicksilver: why?
09:51:10 <Taejo> quicksilver: yeah, I'm moving over to your side
09:51:18 <quicksilver> well (a,) is a good example.
09:51:21 <lilac> quicksilver: i don't think i've ever used pure, but i've used <*> a fair bit
09:51:28 <quicksilver> it's pure that's hard to define.
09:51:36 <paolino> last question about iteratee: is there a chance to reuse ReadS function to make an Iteratee ?
09:51:38 <quicksilver> lilac: but you've used <$> I'm sure
09:51:49 <quicksilver> lilac: f <$> is (pure f) <*>
09:52:05 <lilac> quicksilver: that's a law, not the definition. <$> = fmap
09:52:18 <quicksilver> the law is how <$> and <*> inter-relate
09:52:27 <quicksilver> which is the same thing as how pure and <*> inter-relate
09:52:34 <quicksilver> which is the same thing as saying pure is the important bit.
09:52:49 <lilac> how can the bit i don't use be the important bit?
09:52:54 * quicksilver shrugs.
09:52:58 <quicksilver> join is the important bit of monad.
09:53:03 <quicksilver> and that's the bit we don't use.
09:53:10 <quicksilver> (in typical idiomatic haskell)
09:53:19 <lilac> we can define a join for every monad
09:53:31 <lilac> we can't define a pure for every Functor with a useful <*>
09:53:47 <quicksilver> <*> isn't useful unless it inter-relates correctly with <$>
09:53:59 <quicksilver> as soon as it inter-relates correctly with <$> you have defined pure
09:54:04 <quicksilver> albeit in a round-about way.
09:54:12 <lilac> quicksilver: in the case of Data.Map, if we could construct a map which mapped everything to a given value, we'd have a pure
09:54:23 <quicksilver> agreed.
09:54:32 <lilac> but that value doesn't exist in our domain. that doesn't mean <*> becomes less useful
09:54:48 <lilac> if anything, <*> becomes more useful because it means we can partially fake it
09:55:03 <quicksilver> what is [(a,(+1))] <*> [(b,5)] ?
09:55:10 <quicksilver> where a /= b
09:55:13 <Taejo> there are many restrictions you could put on a to make (Map a) applicative
09:55:25 <lilac> quicksilver: clearly there are two different answers and the choice is arbitrary
09:55:25 <Taejo> monoid would do it
09:55:39 <Taejo> (or would monoid do it
09:55:42 <quicksilver> lilac: which answer do you suggest?
09:55:49 <quicksilver> lilac: do they both obey the <$>/<*> law?
09:56:10 <quicksilver> in fact, what two answers do you mean?
09:56:12 <monochrom> You have to write new laws if you don't have pure. The old laws mention pure.
09:56:25 <quicksilver> indeed.
09:56:42 <lilac> quicksilver: actually, [(a,(+1))] <*> [(b,5)] is a type error because (a,(+1)) isn't a function
09:56:58 <quicksilver> monochrom: which is no coincidence, because pure is the important bit ;)
09:57:04 <lilac> quicksilver: but assuming you meant (a, (+1)) <*> (b, 5)...
09:57:16 <quicksilver> lilac: no, those were Data.Maps
09:57:25 <quicksilver> lilac: (represented as lists for brevity)
09:57:42 <lilac> quicksilver: yeah, i don't think i thought out that example very well ;-)
09:57:45 <quicksilver> Map Key (Int -> Int) and Map Key Int respectively.
09:58:05 <quicksilver> there is another choice for pure, for Data.Map
09:58:08 <quicksilver> pure x = empty
09:58:23 <quicksilver> and probably <*> only works on matching pairs
09:58:28 <quicksilver> and throws the rest away
09:58:36 <quicksilver> <*> = intersectionWith ($)
09:58:39 <lilac> quicksilver: yes, that Applicative instance would seem to work
09:58:51 <quicksilver> I haven't checked it it obeys the laws
09:59:02 <quicksilver> but if it does, it follows immediately from my choice of "pure"
09:59:08 <quicksilver> pure is, once again, the important bit.
09:59:18 <quicksilver> Of course it's subjective what the "important bit" of an instance is.
09:59:33 <quicksilver> But equally obviously quicksilver's opinion is right :)
10:00:25 <monochrom> I know how to define importance.
10:00:33 <Taejo> <quicksilver> pure x = empty -- violates pure id <*> = v
10:00:47 <Taejo> I mean pure id <*> = id
10:00:50 <Taejo> ack
10:00:57 <Taejo> I mean (pure id <*>) = id
10:03:56 <doserj> conal would probably say that Map k a ~ PartialFunctions k a, and pure should essentially be const x
10:04:48 <monochrom> It's a bit hard to represent const x as a Map.
10:04:56 <Taejo> instance (Bounded k, Enum k) => Applicative (Map k) ?
10:05:09 <monochrom> Indeed Map k a ~ FinitePartialFunctions k a  is more right.
10:05:10 <Taejo> obviously add an ord constraint
10:05:43 <Taejo> you can also do something closer to [] if you have (Monoid k, Ord k)
10:07:20 <Taejo> pure = singleton mempty; fs <*> xs = fromList . zipWith (mappend &&& ($)) (toList fs) (toList xs)
10:07:26 <Taejo> I think that's Applicative
10:09:32 <Taejo> that doesn't take much advantage of the Map structure tho: it might as well be [] ((,) a)
10:14:25 <doserj> Taejo: that's very sensitive to the output order of Data.Map.toList (you mean zipWith (mappend *** ($)), I guess)
10:14:42 <lilac> quicksilver: i think my point stands. the hypothetical pure = everywhere i suggested works to make an applicative
10:14:52 <lilac> quicksilver: the fact that we can't implement it in haskell doesn't seem relevant
10:15:08 <lilac> quicksilver: or rather, not with the standard Data.Map implementation
10:15:26 <Taejo> doserj: I always confuse &&& with ***, and I should have used toAscList (which is actually equal to toList, I believe, but you are correct)
10:16:51 <lilac> quicksilver: likewise for "(,) a", we could imagine "pure x = (undefined, x)" giving rise to "(_, f) <*> (a, x) = (a, f x)", but we don't want to define that 'pure'
10:16:52 <doserj> Taejo: it is just pretty random which elements get combined with each other
10:17:16 <lilac> quicksilver: that example's not particularly compelling, but i think the Data.Map one is
10:19:19 <Taejo> doserj: yeah, I meant some kind of cross-product
10:19:25 <Taejo> :(
10:20:27 <Taejo> [(k1 `mappend` k2, f $ v) | (k1, f) <- toList fs, (k2, v) <- toList xs]
10:20:45 <Taejo> @undo [(k1 `mappend` k2, f $ v) | (k1, f) <- toList fs, (k2, v) <- toList xs]
10:20:46 <lambdabot> concatMap (\ (k1, f) -> concatMap (\ (k2, v) -> [(k1 `mappend` k2, f $ v)]) toList xs) toList fs
10:20:58 <Taejo> @pl concatMap (\ (k1, f) -> concatMap (\ (k2, v) -> [(k1 `mappend` k2, f $ v)]) toList xs) toList fs
10:20:59 <lambdabot> xs fs
10:21:15 <Taejo> @pl \xs fs -> concatMap (\ (k1, f) -> concatMap (\ (k2, v) -> [(k1 `mappend` k2, f $ v)]) toList xs) toList fs
10:21:18 <lambdabot> (toList >>=) . (`ap` snd) . (. fst) . flip (flip . flip flip toList . ((=<<) .) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip [] . ((flip . ((flip . ((:) .)) .)) .) . flip . (((.) .
10:21:18 <lambdabot> (,)) .) . mappend)
10:21:25 <Taejo> hell's bells
10:21:36 <Taejo> @pl \xs fs -> concatMap (\ (k1, f) -> concatMap (\ (k2, v) -> [(k1 `mappend` k2, f $ v)]) xs) fs
10:21:39 <lambdabot> (=<<) . (`ap` snd) . (. fst) . flip (flip . ((=<<) .) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip [] . ((flip . ((flip . ((:) .)) .)) .) . flip . (((.) . (,)) .) . mappend)
10:21:57 <doserj> Taejo: that's the standard Applicative composition for [] and (,) a, I guess?
10:22:33 <Taejo> doserj: (,) a isn't applicative
10:22:47 <Taejo> well, it is for monad a
10:22:49 <Taejo> *monoid a
10:22:55 <Taejo> so yea
10:22:57 <doserj> that's what I meant
10:23:12 <Taejo> d'oh
10:23:23 <Taejo> forgot that compositions of applicatives is applicative
10:37:59 <Taejo> can a type be a Functor in two different ways? my intuition says no, but how would I prove it?
10:42:42 <skorpan> hi. i'm trying to make use of the MPD monad from libmpd together with State(T) and IO, but i can't figure out how that would work... http://hackage.haskell.org/packages/archive/libmpd/0.3.1/doc/html/src/Network-MPD-Core.html#MPD
10:43:08 <skorpan> i feel like i need a MPDT or something, but maybe i'm mistaken?
10:44:19 <lilac> Taejo: no, it can't. i think you can prove it with parametricity
10:44:32 <skorpan> hm... MPD is an instance of MonadIO, so it sort of has IO "built-in", does that help me?
10:45:21 <Taejo> lilac: I think so too. Unfortunately my knowledge of parametricity is limited to the online free-theorem prover which doesn't seem to handle higher-kinded types
10:45:48 <Taejo> or rather, type variables of kind * -> *
10:47:08 <lilac> Taejo: suppose there exist f, x with fmap f x /= fmap' f x. parametricity implies they're different for all f, including id. contradiction.
10:47:44 <lilac> Taejo: that's a bit hand-wavey, but i think it's something like that
10:50:18 <Taejo> lilac: do you know of a good tutorial or introductory paper on parametricity?
10:50:38 <Heffalump> have you read Theorems for Free?
10:51:42 <Taejo> Heffalump: nope
10:51:50 <Taejo> I'll take a look
10:54:39 <skorpan> solved my earlier problem...
10:55:22 <lilac> skorpan: MPD is MonadIO so you don't need IO in the stack
10:55:27 <lilac> is that the solution?
10:55:55 <skorpan> lilac: i was just confused...
10:56:09 <skorpan> but as you say, it's MonadIO, so IO is included for free (!!!)
11:04:51 <drhodes> f "abc" "123" "abracadabra"  ???  (f 'c' '3' (f 'b' '2' (f 'a' '1' "abracadabra")))
11:05:13 <Saizan> PROFIT?
11:05:25 <drhodes> I was thinking mapAccum would do this, but there are two args.
11:05:54 <Saizan> it seems a foldr over the zipped lists
11:06:23 <skorpan> :t zipWith2
11:06:25 <lambdabot> Not in scope: `zipWith2'
11:06:25 <skorpan> :t zipWith3
11:06:27 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
11:06:28 <Saizan> > foldr (uncurry f) "abracadabra" $ zip "abc" "123"
11:06:30 <lambdabot>   No instance for (SimpleReflect.FromExpr [GHC.Types.Char])
11:06:30 <lambdabot>    arising from a...
11:06:38 <drhodes> yeah I started with zip and fold, but then I started losing it.
11:06:43 <augustss> foldr (uncurry f) ... (zip ... ...)
11:06:46 <Saizan> > foldr (\(a,b) c -> f a b c) "abracadabra" $ zip "abc" "123"
11:06:47 <lambdabot>   No instance for (SimpleReflect.FromExpr [GHC.Types.Char])
11:06:47 <lambdabot>    arising from a...
11:07:06 <Saizan> well that, given a proper f
11:07:22 <drhodes> ok, thanks guys :)
11:07:24 <skorpan> i was thinking zipWith3?
11:07:29 <skorpan> instead of uncurrying
11:07:36 <skorpan> hm, maybe not
11:08:17 <Saizan> ah, it seems you want foldl, actually
11:11:02 <drhodes> worked like a charm, thanks again.
11:21:01 <brian6> i want to define some types representing nonnegative integers that fit in n bits. n won't be greater than 32. for example, one value is 7 bit. is there something better to do than smart constructors?
11:22:38 <monochrom> Word8 and smart constructors.
11:22:59 <rocketman> brian (Bool, (Bool, ...))
11:23:17 <maartenm> does anyone know if there's a channel for J?
11:23:24 <maartenm> I kinda want to learn that language
11:23:30 <brian6> rocketman: i was thinking about stuff like that, but wouldn't it be really awkward to use?
11:23:58 <rocketman> no
11:24:41 <rocketman> type Bit = Bool  makes it a bit nicer
11:26:31 <brian6> rocketman: so do i make Bits7 and make it an instance of Num?
11:26:40 <brian6> or what.
11:26:58 <rocketman> if you want
11:27:19 <rocketman> I wouldn't touch Num
11:28:22 <brian6> rocketman: i'm just not getting how i get from, e.g., 42, to Bits7.
11:28:55 <rocketman> write a new function
11:29:21 <brian6> rocketman: well, if i was going to use smart constructors, i'd not even make Bits7.
11:29:34 <rocketman> okay
11:29:47 <rocketman> I don't use smart constructors
11:31:07 <pcc1> I presume that it is not safe to free memory allocated by C malloc using Foreign.Marshal.Alloc.free
11:31:31 <pcc1> so if I would like to free this memory I should wrap the C free function, correct?
11:31:57 <rocketman> is your assumption correct?
11:32:04 <Twey> Er, I think free is just C free()
11:32:29 <pcc1> but is it guaranteed  to be that way?  nothing in the FFI spec says so
11:33:23 <Twey> I'm 85% sure
11:33:29 <Twey> I recall reading something on it the other day
11:33:36 <skorpan> 85% eh?
11:34:56 <aconbere> is there a ghc command to clean up the ho, hi, etc. files created?
11:35:49 <brian6> pcc1: did some c function malloc and return it to you?
11:36:16 <monochrom> There is no ghc command to clean up ho, hi, etc.
11:36:22 <pcc1> brian6: yes
11:36:29 <aconbere> monochrom: thanks :)
11:36:55 <brian6> pcc1: there's some pretty relevant seeming stuff in rwh ch17, 'let the garbage collector do the work'.
11:37:35 <zloog> Hi, I think i have a lazy IO problem. My IO code is wrapped up in an ErrorT monad. Is the liftIO command for that lazy? And if so is there a way i can force it to be strict?
11:38:40 <monochrom> Not lazy.
11:39:31 <zloog> monochrom: Oh thanks, well now I'm back to square 0. :)
11:39:55 <Saizan> zloog: buffering?
11:40:52 <monochrom> Buffering is so lame. GHC is doing nothing different from most Unix and C platforms.
11:41:08 <zloog> Saizan: Well I'm getting problems when i close the handle.I thought this was all strict.  I dont know if that is a buffering problem or not.
11:42:24 <Saizan> zloog: are you writing or reading on it? i.e. can you give more details of what are you seeing vs. what you'd expect?
11:42:34 <pcc1> brian6: thanks for that.  the book doesn't seem to address the C vs Haskell issue, which leads me to believe that their use of finalizerFree may be technically wrong in this context
11:43:16 <zloog> Saizan: Unfortunately its a pretty large module and everything is happening in IO. Its network reads and writes
11:43:59 <zloog> Saizan: Is it possible that this function would have lazyness issues? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6637#a6637
11:44:02 <brian6> pcc1: elaborate please? the context of that stuff was bindings for pcre.
11:45:10 <Saizan> zloog: readUntilDot?
11:45:45 <zloog> Saizan: Its an NNTP reader, the responses come one line at a time and end with '.' on a line by itself
11:45:52 <Saizan> zloog: however i don't think so, IO is not lazy in the effects unless you end up calling unsafeInterleaveIO like hGetContents does
11:46:12 <zloog> Saizan: So otherwise everything should be strict by default?
11:46:38 <Saizan> zloog: right.
11:47:06 <Saizan> zloog: that function will return the [ByteString] all at once when its done reading it
11:47:25 <zloog> Saizan: Cool, do you know of any other scenarios where everything would work fine unless i try to close the handle after doing the read?
11:47:26 <pcc1> what I am saying is that since the FFI spec does not guarantee that C free is called, even if a particular implementation (e.g. GHC) uses it, this means that the code is not portable to other implementations
11:47:36 <zloog> read/writes
11:48:19 <Saizan> zloog: how is it failing?
11:48:27 <Saizan> do you get an exception?
11:48:27 <Jedai> zloog: if you use lazy read functions
11:48:42 <Jedai> zloog: like hGetContents, readFile, ...
11:49:11 <zloog> Jedai: nope, only handle io happens using strict bytestrings
11:49:12 <Jedai> zloog: you should make sure you read everything of interest to you before you close
11:49:28 <zloog> Jedai: Unless liftIO is lazy it should be
11:49:51 <Jedai> zloog: then you have another problem (liftIO isn't "lazy", it wouldn't make sense)
11:49:57 <zloog> Saizan: let me get an example of the crash
11:51:20 <Saizan> are there more than one thread working with this handle?
11:51:29 <Saizan> *is
11:53:11 <Saizan> i've to go, bbl
11:54:53 <zloog> Saizan: No, the app is multithreaded but only one should be using it at a time
11:56:59 <zloog> Saizan: Thanks for your help, i dont have the up to date source with me here so ill have to work on it later
12:00:47 <portnov> @index doesFileExist
12:00:48 <lambdabot> System.Directory, Distribution.Compat.Directory
12:11:35 <skorpan> are n+k patterns going anywhere any time soon?
12:11:43 <rocketman> no
12:11:45 <skorpan> cool
12:14:36 <ray> are n/k patterns coming anywhere any time soon?
12:16:47 <rocketman> no
12:16:54 <etpace_> http://codepad.org/bqJ15NKb this loops infinitely, and I can't find out why with the ghci debugger -- any tips?
12:16:58 <dolio> n+k is probably on the outs for Haskell', but I'm not sure I'd label that "soon".
12:17:40 <rocketman> etpace it's very very complicated you should try to simplify it
12:17:49 <skorpan> n+k sounds like such a cool idea at first, but then it just gets messy
12:18:00 <etpace_> break up the functions rocketman?
12:18:05 <rocketman> yes
12:18:16 <skorpan> @pl \x y z w -> renderBS (setBold attr) $ oneLine' x y z w
12:18:16 <lambdabot> (((renderBS (setBold attr) .) .) .) . oneLine'
12:18:33 <skorpan> @pl \x -> renderBS (setBold attr) $ oneLine' x
12:18:33 <lambdabot> renderBS (setBold attr) . oneLine'
12:18:40 <skorpan> :(
12:18:52 <etpace_> they're quite interlinked rocketman, so I'd end up having to pass additional arguments, I take it thats just a thing I'll have to do?
12:19:09 <Philippa> dolio: I thought I saw removing them on the Haskell 2010 list too?
12:19:50 <dolio> I've been away for a couple weeks. I'm still catching up. :)
12:20:33 <rocketman> etpace it will help, you might find new data on the way
12:20:57 <rocketman> @whese Haskell2010
12:20:58 <lambdabot> I know nothing about haskell2010.
12:21:07 * rocketman same
12:22:25 <dolio> There's a thread on the H' list about it.
12:22:46 <dolio> Remove n+k is listed in the list of probably-accepted proposals.
12:24:13 <rocketman> is H' an ego thing?
12:24:49 <rocketman> I thought they were just speccing the various extensions
12:27:50 <Philippa> rocketman: no, but it's a thing that's allowed to break compatibility and should consider doing so for a number of reasons
12:28:06 <Philippa> it's gained a small degree of scope creep, sure
12:37:48 <largos> what module is the System data constructor defined in?
12:37:54 <largos> (Hoogle doesn't seem to be helping here :( )
12:38:21 <skorpan> it's a data constructor?
12:38:32 <largos> apparently
12:39:06 <largos> I'm trying to following Dagit's quickcheck + cabal instructions here: http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
12:39:34 <`Zerax`> @index System
12:39:35 <lambdabot> bzzt
12:39:52 <skorpan> that's weird
12:40:00 <skorpan> i can't even imagine that type-checking
12:40:05 <skorpan> but then again, i know nothing
12:40:09 <skorpan> I'M FROM BARCELONA
12:40:10 <largos> Hoogle doesn't seem to find System.Cmd either...
12:40:19 <skorpan> http://www.haskell.org/ghc/docs/latest/html/libraries/
12:40:43 <skorpan> System is not defined in System.Cmd nor System.Exit afaics
12:41:28 <dcoutts> largos, skorpan: I suspect it's a typo and should be 'system'
12:41:37 <skorpan> dcoutts: probably, yes
12:41:52 <`Zerax`> system :: String -> IO ExitCode
12:42:08 <largos> ah...
12:42:14 <`Zerax`> System and System.Cmd are modules
12:42:21 <skorpan> but am i right in my assumption that if System is a data constructor, that code can never type-check?
12:42:24 <skorpan> just curious now :P
12:44:12 <largos> well, it's still not typechecking :) (inferred type is ExitCode, expected is () )
12:44:46 <skorpan> @index system
12:44:47 <lambdabot> System.Cmd
12:44:52 <skorpan> :t System.Cmd.system
12:44:54 <lambdabot> String -> IO GHC.IOBase.ExitCode
12:44:55 <troutwine> I can't seem to use haskell-tyrant without -XOverloadedStrings: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6638#a6638
12:44:58 <troutwine> Ideas?
12:45:15 <skorpan> largos: are you *sure*? :|
12:45:47 <largos> skorpan: well, it's in the full context that problems arise: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6639#a6639
12:46:01 <largos> and no, with Haskell, I'm never sure ;)
12:46:13 <skorpan> ah well
12:46:25 <skorpan> runTests wants () i suppose
12:46:31 <brian6> troutwine: tyrant seems to want lazy bytestrings.
12:46:38 <mauke> >> return ()
12:47:00 <skorpan> or "ignore" or "void" ;)
12:47:14 <mauke> >> def
12:47:31 <largos> ah, thanks :)
12:47:55 <jeffwheeler> I've had a lot of success writing the DSL I mentioned last night: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6641#a6641
12:48:28 <jeffwheeler> But I can't seem to find a way to simplify the definition of 'triple'; especially with the Terms (as in, sample2), it gets pretty complicated fairly fast.
12:48:48 <portnov> !
12:49:16 <jeffwheeler> I would a expect a typeclass could solve something like that, but I haven't been having any luck with that; I was playing with something around the 'triple2' definition a bit below.
12:49:30 <largos> heh, debugging template haskell is a pain in the ass.
12:49:43 <skorpan> mauke: was "def" ever suggested on the mailing list?
12:49:56 <skorpan> largos: not with some unsafePerformIO it isn't ;P
12:50:13 <skorpan> oh, template haskell
12:50:14 <skorpan> well, yes
12:50:26 <mauke> skorpan: not as far as I know
12:50:28 <troutwine> brian6: Of course.
12:51:25 <largos> I didn't know an 'Unterminated end-of-line comment' was *possible*
12:51:52 <mauke> it's easy if your line doesn't end
12:52:05 <inimino> perhaps in a file not ending in EOL
12:52:20 <largos> ah! thanks
12:52:52 <mauke> in which case your text editor sucks
12:53:03 <natthew3> What is the best way to do strict IO with Data.Binary?
12:53:08 <natthew3> I
12:53:09 <largos> mauke: why is that?
12:53:21 <mauke> largos: because apparently it doesn't properly terminate its lines
12:53:59 <largos> mauke: I'm using emacs -- and I had a file that ended with a loc. which I had commented out
12:54:12 <mauke> yeah, another reason I hate emacs
12:54:43 <mauke> (setq require-final-newline t)  ; I think
12:54:45 <inimino> does emacs not add \n when saving?
12:54:50 <mauke> not by default
12:54:50 <inimino> I find that surprising
12:54:51 <SamB> largos: which compiler?
12:54:53 <inimino> huh
12:55:00 <SamB> mauke: it doesn't?
12:55:04 <skorpan> not since 23 iirc
12:55:07 <mauke> SamB: no, it doesn't
12:55:10 <SamB> huh, I could have sworn that was the default
12:55:12 <skorpan> but that's a silly reason to hate emacs...
12:55:12 <largos> SamB: ghc 6.10.1
12:55:14 <SamB> 23 is out now?
12:55:19 <SamB> largos: huh
12:55:29 <skorpan> SamB: no, it's not :)
12:55:36 <jmelesky> emacs can be used to edit binary files, so it's not surprising that it doesn't default to adding a text token at the end of a file
12:55:46 <largos> I'm using 23.0.91.1
12:55:56 <skorpan> GNU Emacs 23.1.50.4 (i686-pc-linux-gnu, GTK+ Version 2.16.2) of 2009-07-02 on stalin
12:55:58 <ray> it's surprising that it doesn't do it for *text files*
12:56:03 <SamB> jmelesky: only in specialized modes
12:56:14 <ray> you named your compuer after the author of emacs?
12:56:19 <skorpan> ray: i think it's perfectly reasonable... imagine not being able to remove a trailing newline.
12:56:46 <skorpan> ray: you don't want to know the names of the other computer ;P
12:56:56 <jmelesky> SamB: if you just open a binary, you'll still be able to edit it raw -- you needn't enter binary-mode to do it
12:57:08 <SamB> ray: I guess this computer rants a lot about dynamic linking ?
12:57:30 <ray> dynamic linking = gulag
12:57:44 <mauke> skorpan: why would you ever want to remove the last newline?
12:57:47 <jmelesky> i'm not suggesting this is a good idea, but if you suffer from a "real programmers don't use modes" problem, you can go for it
12:57:58 <mauke> that is, why would you want to deliberately create a crippled text file?
12:58:16 <skorpan> mauke: i'm just saying that i can understand the reasoning behind the choice that was made, i'm not saying i agree with it
12:58:20 <largos> mauke: *some* (crappy) apps I've used break on files with 0-len. lines
12:58:21 <SamB> jmelesky: what the heck is binary-mode?
12:58:22 * SamB uses hexl
12:58:47 <largos> mauke: (just to say that on occasion it's been necessary)
12:58:47 * mauke uses vim -- because the defaults are almost sane there
13:00:04 <jmelesky> SamB: sorry. binary-overwrite-mode. though that doesn't seem to be the one i was thinking of
13:00:08 <monochrom> Computers rant about dynamic linking?
13:00:12 <jmelesky> it's been a while since i've done binary editing in emacs
13:00:19 * jmelesky knocks on wood
13:00:27 <monochrom> Give your computer a blog account so it can rant about dynamic linking.
13:00:44 <SamB> monochrom: why else call it rms?
13:02:57 <jmelesky> has anyone here used HPDF at all?
13:19:39 <hackagebot> Agda 2.2.4 - A dependently typed functional programming language and proof assistant (NilsAndersDanielsson)
13:19:39 <hackagebot> Agda-executable 2.2.4 - Command-line program for type-checking and compiling Agda programs (NilsAndersDanielsson)
13:20:18 <grahamhutton> Make sure to register for ICFP in Edinburgh if you haven't already: early registration/accommodation deadline is fast approaching: http://www.cs.nott.ac.uk/~gmh/icfp09.html
13:21:18 <grahamhutton> Lots of great talks and events for the keen FPer!
13:21:30 <tomh-> heh i got your book -.-
13:21:48 <grahamhutton> tomh :-)
13:22:17 * sm too.. thanks grahamhutton !
13:22:17 <grahamhutton> And not to mention all the fun of Edinburgh during the the festival period.
13:22:23 <grahamhutton> <end of advert>
13:22:53 <tomh-> only haskell book i could understand well...so far :)
13:27:27 <grahamhutton> tomh: Korean version out imminently, and Japanese version later this year!
13:27:33 <Phillemann> I open a connection to a server A, forkIO a Haskell thread and use 'accept' there (the main thread then reads and writes data from/to A). The accept, however, seems to be forgotten. What am I doing wrong?
13:30:01 <ryo_hazuki> whats wrong with this signature? i'm getting a parse error on ','
13:30:04 <ryo_hazuki> function :: (Integral a) => [[a,a,a]]
13:30:15 <Phillemann> Haskell seems to do strange stuff, it select()s rather randomly, not taking all my sockets into account.
13:30:19 <tomh-> hehe nice, grahamhutton: are you planning to do a advanced book on haskell too?
13:30:22 <opqdonut> ryo_hazuki: [a,a,a] is not a type
13:30:32 <Heffalump> Phillemann: what do you do with the fd from the accept?
13:30:35 <opqdonut> (a,a,a) would be (a tuple of three a)
13:30:48 <opqdonut> [x,x,x] would be a value of type [a]if x were a value of type a
13:30:55 <grahamhutton> tomh: already covered by others...
13:31:11 <Phillemann> Heffalump: I'm doing: (h,_,_) <- liftIO $ accept s, contents <- liftIO $ hGetContents h
13:31:22 <Phillemann> Imagine the comme being a newline ;)
13:31:25 <grahamhutton> tomh: but I would like to do a "semantics for the masses" kind of book.
13:31:27 <Phillemann> *comma
13:31:40 <ray> a semicolon replaces a newline
13:31:43 <ryo_hazuki> ah crap... hehe
13:31:46 <ryo_hazuki> now i saw the mistake
13:31:50 <ryo_hazuki> thx mate =)
13:31:57 <SamB_XP> grahamhutton: who wrote an advanced book?
13:32:10 <Heffalump> and then doing what with contents?
13:32:22 <Heffalump> and this is all inside a forkIO presumably?
13:32:35 <grahamhutton> RWH, SOE, fun of programming.
13:32:37 <ryo_hazuki> nn everyone...
13:32:38 <Phillemann> I parse it and eventually send it to the server A.
13:32:45 <Phillemann> Heffalump: Yes.
13:32:47 <SamB_XP> grahamhutton: SOE was not advanced
13:32:59 <grahamhutton> it was as far I some people were concerned!
13:33:06 <SamB_XP> well, okay
13:33:10 <Heffalump> I don't know what could be wrong then, though I did find a bug in the way GHC does select recently that was fixed on HEAD
13:33:14 <Heffalump> I'll look out the bug number
13:33:17 <ray> RWH is borderline
13:33:19 <SamB_XP> but I found it a bit boring ... and didn't you write that ?
13:33:29 <etpace_> I'm having troubles with number types, I need to pass numbers to normal functions like splitAt, take etc, but I also need to be able to preform non-intger division, what would be the best type for this?
13:33:39 <grahamhutton> SOE was Paul Hudak.
13:33:41 <SamB_XP> oh.
13:33:44 <SamB_XP> what did you write?
13:33:47 <tomh-> grahamhutton: ok, well, i liked the concise style of your first book, so a book about the more advanced topics in like 100 pages would be nice i think :)
13:33:49 <Phillemann> Heffalump: Okay
13:33:50 <grahamhutton> Programming in Haskell.
13:34:02 <ray> the seasoned haskeller?
13:34:10 * SamB_XP lent his copy of SoE to a friend and thinks he never got around to getting it back
13:35:47 <tomh-> soe?
13:36:13 <ehird> Is there an interface to gnuplot or something?
13:36:18 <ehird> Or any other nice graphingabilities.
13:36:22 <grahamhutton> Haskell School of Expression.
13:37:13 <ehird> But that's a book, not a plotting library :P
13:38:11 <amuck_> ehird: Hackage has a gnuplot library
13:38:12 <Renderwahn> it you stash hundrets of hsoe books you get a graphics library :)
13:38:27 <ehird> awesome, it's like coupons but more expensive!
13:38:32 <etpace_> http://codepad.org/7F6XdErF can anyone help explain this error?
13:39:10 <ehird> hmm there's HPlot, Chart and nguplot
13:39:15 <Tsion> has anyone ever seen something like this:
13:39:15 <Tsion> $ ghc-pkg check                                                                                                         [1]
13:39:15 <Tsion> There are problems in package rts-1.0:
13:39:15 <Tsion>   include-dirs: PAPI_INCLUDE_DIR doesn't exist or isn't a directory
13:39:55 <Tsion> and it has a huge list of packages it says are broken because of that
13:40:01 <Saizan> Tsion: http://www.nabble.com/ghc-pkg-check-problem-in-6.10.2-td22846037.html
13:40:24 <Tsion> I'm on 6.10.3
13:40:33 <ehird> With the Cabal flags executePipe and executeShell you can switch to more convenient but probably less portable ways of running gnuplot.
13:40:34 <ehird> wonder what that means.
13:40:45 <ehird> (gnuplot package)
13:41:18 <tommd> etpace_: (1) What interpreter is that?  (2) Your main needs to be of type IO
13:41:29 <Tsion> Saizan: Thanks, that fixed it
13:41:31 <tommd> etpace_: And there's some other issue with your use of Fractional... hummm
13:41:44 <Saizan> etpace_: and using tuples as fractional numbers doesn't work out well
13:41:45 <etpace_> I think that's Hugs tommd, and do I need to explicitly declare my main type?
13:41:49 <Heffalump> Phillemann: 3316
13:42:03 <Saizan> etpace_: you need to use e.g. print
13:42:09 <etpace_> aha
13:42:12 <ehird> etpace_: may i kindly suggest not using hugs?
13:42:20 <tommd> etpace_: Oh, 'zip' is returning a tuple
13:42:26 <etpace_> I'm not using hugs, codepad is
13:42:28 <tommd> etpace_: Didn't even see it.  Tuples aren't fractionals.
13:42:49 <tommd> etpace_:  Then in the future paste the error _you_ get, not the web sites.
13:43:04 <ehird> ah.
13:43:06 <etpace_> But I don't think I specify the tuple to be a fractional? I said ySamples and y should be
13:43:15 <ehird> tommd: no no no
13:43:17 <ehird> tommd: codepad executes code
13:43:22 <ehird> y'see?
13:43:25 <ehird> and reports what it does
13:43:35 <ehird> not an error in the site
13:43:36 <tommd> ehird: Yes, I understand - just saying he should paste his copy of the error, that's all.
13:43:39 <ehird> ah
13:43:52 <etpace_> Copy/pasting from windows cmd is a bit awkward
13:44:03 <ehird> install cygwin/urxvt ;)
13:44:04 <ehird> *:)
13:44:05 <tommd> etpace_: Its simple.  "zip" returns something of type (a,b) and that is not a fractional.
13:44:13 <tommd> etpace_: Not sure what you want there, but that isn't it.
13:44:58 <etpace_> ah i see
13:45:16 <etpace_> thanks
13:45:20 <etpace_> I zip [0..] twice
13:45:46 <tommd> Yeah, I'm talking about the error on line 6, in main.  As you probably just saw.
13:46:19 <tommd> Fixing that and making the line :: IO a should bring you closer to your goal.
13:47:01 <etpace_> well that function works, which means my infinite loop is elsewhere..
13:47:06 <Phillemann> Heffalump: Ok, my code works perfectly if I replace forkIO by forkOS. So it might be the issue you're talking about.
13:48:00 <tommd> etpace_: funny, when I eliminate the 'zip' in main it doesn't loop for me.
13:48:09 <tommd> It terminates after printing '7'.
13:48:28 <etpace_> Yeah, I mean -- my loop is elsewhere in my code :P
13:49:20 <Heffalump> is this with the threaded runtime?
13:49:43 <Phillemann> Heffalump: I had to enable -threaded when linking, yes.
13:50:15 <Heffalump> and with forkIO it still didn't work?
13:50:36 <Phillemann> Heffalump: Still? You mean with -threaded?
13:50:53 <etpace_> When I try to specify the type signature of my functions, I usually get a plethora of errors -- letting GHC decide I do not. My program isn't correct, but it doesn't seem to error -- could me explicitly typing the functions and trying to debug from there help solve this?
13:50:54 <Phillemann> I though -threaded only added -lpthread or something.
13:51:02 <Heffalump> no, it uses a different runtime
13:51:07 <Heffalump> that can run on multiple OS threads
13:51:41 <Heffalump> you said that your program was broken initially, call that state X.
13:51:47 <Heffalump> was that using -threaded or not?
13:51:49 <tommd> You might want to use -fforce-recomp if that flag is the only change to your code on this recompilation.
13:52:31 <bos> you don't need to recompile source files if you're using -theraded.
13:52:39 <bos> just a relink will do the trick.
13:52:47 <Heffalump> my guess is that -threaded with forkIO would work
13:52:55 <Phillemann> Heffalump: Well initially I wasn't using -threaded. Now I see it works, whether I use forkOS or forkIO.
13:53:04 <Heffalump> right
13:53:19 <tommd> etpace_: That implies the function you wrote does not have the type you think it does.  So you should explicitly type it and then look to see why the function does not match.
13:53:21 <Phillemann> So...what does this mean? :>
13:53:53 <tommd> etpace_:  Its that or perhaps you had a typo in the type signature you wrote.
13:54:00 <ehird> gwern: \bot left #esoteric a while ago when it crashed i think, is there a chance we could get it back? we keep trying to do > haskell by mistake :-)
13:54:34 <Heffalump> Phillemann: it means you were bitten by the bug, I think.
13:55:10 <Phillemann> Heffalump: I'll see if there is a ghc ebuild which pulls from the scm so I can make sure
13:55:33 <Heffalump> or go back to an old GHC that doesn't have the bug
13:55:41 <Heffalump> I identified where it was introduced in my report I think
13:58:48 <ldlework> Why are haskell packages so hard to install.
13:58:51 <etpace_> Int falls under (Num a), right?
13:59:05 <Saizan> etpace_: right
13:59:13 <dankna> @remember lucca where 1+1 is a potentially hugely long computation, or potentially an Infinite computation
13:59:13 <lambdabot> I will remember.
13:59:29 <Saizan> ldlework: depends on the maintainer and your platform :)
13:59:41 <jmelesky> idlework: can you be more specific? i haven't had many problems with cabal
13:59:45 <tommd> Idlework: They aren't for me.  Do you use cabal-install?
14:00:44 <etpace_> Couldn't match expected type 'a' against inferred type 'Int'. 'a' is a rigid type variable bound by ... -- My type variable is: plotF :; (Num a) => (a -> a) -> a -> a -> Int -> Int -> Grid, any ideas?
14:00:50 <tommd> Idlework: I assume you are talking about xmonad as you asked there first.  If that's correct then the best thing to do is use the XMonad that comes with your distro.  If you have a defective distro then building it isn't that bad so long as you have cabal-install.
14:01:26 <tommd> etpace_: Can't help based on signature alone.
14:02:23 <Heffalump> anyone know where ICFP '10 will be?
14:03:47 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6645#a6645 is the code -- it's quite ghastly, but it runs (incorrectly) without me explicitly typing it, so the code is wrong somewhere
14:04:17 <tommd> Could you explicity type and paste the error / code.
14:04:23 <Saizan> etpace_: if you declare your type to be polymorphic it has to be, you can use plotF with a = Int from the outside, but not from the inside
14:04:34 <rocketman> etpace well I think yo ushould split up plotF as much as possible
14:04:59 <etpace_> i took out getClosestY, I don't think I can split it up much more rocketMan, the rest are just simple arithmetic
14:05:07 <etpace_> I did tommd
14:05:10 <rocketman> simpler :)
14:05:34 <tommd> yeah, nm
14:06:39 <etpace_> I'm not sure what type I need then Saizan, I'll try to split up my code more so I can fit more type signatures in there
14:08:36 <ldlework> Can anyone help me get cabal installed?
14:08:37 <tommd> etpace_: I don't see how you'd expect this to work.  Consider: "xSamples = map (\x -> (x*stepX) + minX) [0..width]"  The mapping is given a function ":: Num a => a -> a" while the list must be :: [Int] because width is an Int.  You probably ment for there to be a fromIntegral in there some where?
14:08:40 <rocketman> etpace, I wouldn't bother to write one type signature
14:08:40 <ldlework> I'm on ubuntu
14:09:00 <dcoutts> ldlework: http://haskell.org/cabal/download.html
14:09:11 <tommd> Idlework: apt-get install cabal-install or some such should do it.  If all else fails, go to the cabal home page, dowload cabal-install and run the 'bootstrap.sh' file.
14:09:28 <etpace_> I think I do tommd, thanks
14:09:50 <ldlework> tommd, dcoutts, it relies on parsec and network neither of which came with my haskell
14:10:18 <tommd> Idlework: there should be a package like ghc6-lib-parsec or some such.  You can do an apt search for it.
14:10:23 <tommd> Same with network.
14:11:20 <tommd> But that should be handled if you found cabal-install in the Ubuntu repositories.  So I guess you're using the link from dcoutts?  Thats fine too, but things are typically easier if someone has already packaged it for you.
14:12:00 <dcoutts> tommd: there's no debian package afaik
14:12:15 <tommd> Idlework, dcoutts: its called "libghc6-parsec-dev"
14:12:25 <tommd> According to the Ubuntu site search - I don't run ubuntu.
14:12:33 <dcoutts> tommd: there's no debian package for cabal-install I mean
14:12:36 <tommd> See "http://packages.ubuntu.com/search?keywords=parsec&searchon=names&suite=jaunty&section=all"
14:12:38 <tommd> Oh, yeah, ok.
14:13:37 <tommd> Well, off to class.
14:13:38 <tommd> Later
14:14:15 <ldlework> win
14:19:01 <etpace_> Are Fractional a also Num a?
14:19:25 <Saizan> yes
14:20:45 <etpace_> Then what's with: Could not deduce (Fractional a) from the context (Num a) arising from the use of `/'. if Fractional a is also a Num a, wouldn't me declaring (Num a) => mean that it's ok for a to be fractional also?
14:21:27 <Saizan> no, it's the opposite
14:21:41 <Saizan> if you declare Fractional a then you can deduce Num a
14:22:01 <etpace_> Aha
14:24:04 <etpace_> ah brilliant, it works!
14:24:18 <etpace_> it seems it was incorrect before because of some integer/fractional errors
14:30:52 <Vulpyne> Hrm... Isn't fromIntegral supposed to work to convert something to network byte order for a PortNum?
14:32:56 <SamB_XP> Vulpyne: and it does
14:33:15 <Vulpyne> It doesn't for me. :(
14:33:16 <SamB_XP> but you don't see it that way, because the Show instance converts it back before passing it on
14:33:18 * dixie realised that coding in haskell save money - small screen is enough for reading haskell code since it is dense
14:33:33 <Vulpyne> I'm actually trying to send packets out, and it was sending to the same port it was showing when I printed it out.
14:34:26 <SamB_XP> Vulpyne: well, you must have been bypassing it's fromIntegral somehow
14:34:45 <SamB_XP> or rather it's fromInteger
14:35:22 <Vulpyne> I was doing something similar to blah = PortNum $ fromIntegral (read somestring) and then plugging that into a SockAddr that I later on pass to sendTo.
14:35:31 <SamB_XP> Vulpyne: skip the PortNum
14:36:02 <Vulpyne> Ohhhh, magic!
14:36:04 <SamB_XP> that completely bypasses the instance that does the hton
14:36:05 <Vulpyne> Thank you.
14:36:17 <SamB_XP> I know, 'cause I've done that too ;-)
14:36:31 <Vulpyne> I never would have figured that out.
14:37:10 <jeffwheeler> Are integer literals interpreted slightly differently in GHC vs. GHCi? In GHC, I'm getting ambiguous type problems, but it seems to work fine in GHC.
14:37:25 <SamB_XP> jeffwheeler: you skipped an i
14:37:28 <SamB_XP> and I'm not sure where
14:37:38 <jeffwheeler> What?
14:37:44 <Cale> jeffwheeler: There's a bit more defaulting in ghci
14:37:46 <SamB_XP> In GHC, I'm getting ambiguous type problems, but it seems to work fine in GHC.
14:37:51 <jeffwheeler> Oh, GHCi on the last one
14:37:54 <jeffwheeler> yeah :)
14:37:54 <SamB_XP> ah.
14:38:11 <jeffwheeler> It's when passing an integer literal to a function with only a typeclass constraints
14:38:11 <SamB_XP> yeah, that would be the extended defaulting that GHCi does by default
14:38:22 <SamB_XP> probably
14:38:28 <jleedev> simple example in ghci: "let f = (+)" works
14:38:28 <jeffwheeler> Yeah . . . I like that. ;)
14:38:37 <SamB_XP> there's a way to enable it for source too
14:38:45 <jeffwheeler> But is that the right way to solve my problem?
14:38:52 <SamB_XP> dunno!
14:38:59 <Cale> jeffwheeler: If the typeclass constraint was only Num and prelude classes, there would be defaulting. If the typeclass constraint contains non-prelude classes then for some silly reason it doesn't default.
14:39:03 <jackdaw> hi, can anyone suggest some existing haskell code/project suitable for perusal by a beginner? I've read quiet a few tutorials and done exercises, but i feel like seeing some "real" work would be very helpful. like reading the linux kernel
14:39:15 <SamB_XP> jeffwheeler: yes, which is really really silly
14:39:33 <SamB_XP> at least it ought to allow you to declare a class as participating, like say Bits ...
14:39:40 <jeffwheeler> Cale: I'll share my code; it's a non-prelude class
14:39:52 <jmelesky> jackdaw: i think reading the linux kernel would be a horrible exercise for a beginning haskeller
14:40:01 <jeffwheeler> If I try adding a Num instance for that class, it proposes UndicedableInstances, which I assume is bad. :)
14:40:06 <Twey> Haha
14:40:12 <jackdaw> jmelesky: hehe i meant interms of it was quite informative to see some production c code, for klearning c
14:40:38 <jeffwheeler> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6647#a6647
14:40:44 <jeffwheeler> Specifically, line 45.
14:41:07 <SamB_XP> jackdaw: well, you could look at hackage and see if anything catches your eye
14:41:09 <jeffwheeler> Trying: qshow $ (Variable 0) .<. 20 works great in GHCi, of course
14:41:11 <jmelesky> jackdaw: i haven't looked at it myself, but much praise has been sent in the general direction of xmonad, and there have been a few talks on its architecture, so that might be a place to look
14:41:40 <jackdaw> jmelesky: yes that's a good idea, something with a clearly defined function&goal
14:41:43 <SamB_XP> the linux kernel is actually a really bad place to learn C, too
14:41:45 <jeffwheeler> I'd like to change line#141 to Num, but apparently I'm not supposed to.
14:41:49 <SamB_XP> because they use so many extensions
14:42:08 <SamB_XP> not all of which are clearly extensions
14:42:32 <jackdaw> SamB_XP: agree, i got ahold of one of the very first iterations which was smaller and more tractable
14:42:34 <jensen> jackdaw: if you need a project; take a look at some of the previous ICFP contests..
14:43:00 <SamB_XP> jensen: which of those are actually Haskell-friendly?
14:43:02 <jackdaw> jensen: ooooh that is not something i've looked at in a long time, thanks
14:44:25 <jackdaw> well the 09 one looks right up my street, a celestial-mechanics problem. top banana
14:44:32 <jeffwheeler> I think, in the sample above, having a VarOrTermLike instance for ExpressionLike would be useful too (and easy to implement), but I'm not sure how to avoid hitting on UndecidableInstances, again.
14:44:38 <Cale> jeffwheeler: Oh, that really is ambiguous...
14:45:02 <Cale> jeffwheeler: There's no telling which instances of ExpressionLike might also be instances of Num.
14:45:18 <jeffwheeler> Oh, I get it.
14:45:20 <jeffwheeler> Hmm . . .
14:45:31 <jensen> SamB_XP: well, some of the exercises would do alright I think. I've previously done a compiler for some of the languages proposed in the 2006 version.
14:45:44 <SamB_XP> whoops
14:46:16 <jackdaw> i suppose working through project-euler again wouldn't hurt
14:46:16 <SamB_XP> jackdaw: http://boundvariable.org/ was my favorite so far, but a lot of the stuff involves writing code in insane languages without necessarily any clear way to use Haskell
14:46:36 <jensen> SamB_XP: agreed, that was good.
14:46:54 <jackdaw> SamB_XP: i actually read that problem before and really wanted to do it, should take some time off from school and just crank these out
14:46:54 <Cale> jeffwheeler: If .<. was monomorphic, it would be easier in that way, but at this point, you probably don't want that. You could just try turning on extended defaulting with {-# LANGUAGE ExtendedDefaultRules #-}
14:47:06 <SamB_XP> though I did write a typechecker for one of the languages because the provided implementation took far too long and too much RAM just to check my types ;-)
14:47:11 <pikhq> jackdaw: Project Euler is pretty good, yeah.
14:47:13 <jensen> jackdaw: you could do the UM in Haskell,
14:47:20 <jeffwheeler> Cale: that solution just mimics the way GHCi works, right?
14:47:28 <jackdaw> jensen: o
14:47:30 <SamB_XP> jensen: wouldn't recommend it
14:47:32 <jeffwheeler> Cale: And it only affects how Num works?
14:47:34 <jackdaw> jensen: sorry, i don't know what UM is
14:47:46 <pikhq> Also, check out Hackage, do some random algorithms (maybe the sorting algorithms?), just play around.
14:47:49 <jensen> SamB_XP: probably not,
14:47:56 <Cale> jeffwheeler: It just resolves ambiguous types more aggressively.
14:48:00 <SamB_XP> they still don't seem to have fixed the shift inlining problem that contest turned up
14:48:08 <jensen> jackdaw: just some machine architecture specified in the boundvariable contest
14:48:22 * Cale finds the documentation for it...
14:48:23 <jeffwheeler> Cale: oh, so then the VarOrTermLike instance might be possible, too?
14:48:23 <jackdaw> jensen: oh ok thanks
14:48:30 <jensen> SamB_XP: sorry, havent heard about that?
14:49:27 <SamB_XP> jensen: there's some inlining that doesn't get done because of an if x# ># 0# somewhere, basically
14:49:49 <jackdaw> has anyone worked through "Write yourself a scheme in 48 hours"
14:49:56 <SamB_XP> because GHC is too stupid to tell whether or not the call actually fixes x#'s value or not
14:50:07 <SamB_XP> er. oops. too many "or nots"
14:50:14 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
14:51:11 <jeffwheeler> Cale: thank you
14:51:12 <SamB_XP> jensen: I guess you can get around that by using `div` instead of shifting, though
14:51:53 <jensen> for bitwise shifting?
14:51:54 <SamB_XP> what'd you write your UM in?
14:52:11 <SamB_XP> jensen: yes, it turns out faster as long as you use -fvia-C
14:52:22 <SamB_XP> dunno about -fasm
14:52:30 <jensen> Haskell, experienced no problems actually
14:52:39 <jensen> (none that was not caused by me)
14:52:42 <SamB_XP> maybe you have a faster computer than I do ;-)
14:52:49 <SamB_XP> or did, anyway
14:53:18 <SamB_XP> did you get anywhere in the adventure game, though?
14:53:23 <jensen> think it turned out some 15 times slower than the C version though. :)
14:53:39 <SamB_XP> jensen: well, that's probably a good part of why
14:53:43 <jensen> Did'nt look at that,
14:54:06 <SamB_XP> now, granted, my way of allocating array numbers in my Haskell code was probably pretty lousy ...
14:54:33 <jensen> hehe
14:54:48 <SamB_XP> but I ended up just using C and raw pointers for those
14:55:04 <SamB_XP> well, more-or-less raw
14:56:15 <SamB_XP> I might have ended up offsetting them by address at which the UM code was loaded, once someone tipped me off to the fact that replacing the code array was only used in the SFX archive, not the actual codex
14:56:45 <jensen> were you signed up for the contest?
14:57:00 <jensen> .. / participating?
14:57:07 <SamB_XP> hmm, I think I signed up, but only to get a decryption code
14:57:23 <SamB_XP> not because I was seriously expecting to get anywhere during the contest period
14:59:19 <SamB_XP> now, having upgraded the computer in my main computer ...
14:59:29 <SamB_XP> (that's a component, right?)
14:59:42 <pikhq> SamB_XP: No.
14:59:55 <SamB_XP> pikhq: well, how would you put it?
15:00:00 <pikhq> Not unless your computer consists of a bunch of people with slide rules.
15:00:05 <pikhq> Processor?
15:00:17 <SamB_XP> I moved my hard drives and ethernet cards from one box to another
15:03:45 <monochrom> My professor is my processor.
15:04:20 <SamB_XP> ... oh, anyway, having done that, maybe I could get a bit further in the game ;-)
15:04:38 <monochrom> I upgraded his slide rule yesterday. He can now do 5 digits.
15:05:09 <SamB_XP> monochrom: wow, must be a huge slide rule!
15:05:43 <monochrom> Yeah! 10 metres long!
15:11:33 <monochrom> monochrom's law: slide rule length doubles every 18 months.
15:15:51 <SamB_XP> wouldn't it make more sense to miniaturize them ?
15:16:36 <pikhq> SamB_XP: Only if you miniaturize professors.
15:18:02 <monochrom> We're working on that, too.
15:23:46 <largos> ? (Integral a, Fractional b) => a -> a -> b
15:24:10 <largos> hm... I need to read up on my bot syntax, it seems :)
15:24:26 <monochrom> @hoogle (Integral a, Fractional b) => a -> a -> b
15:24:27 <lambdabot> Prelude div :: Integral a => a -> a -> a
15:24:28 <lambdabot> Prelude gcd :: Integral a => a -> a -> a
15:24:28 <lambdabot> Prelude lcm :: Integral a => a -> a -> a
15:24:41 <largos> ah, thanks
15:24:41 <monochrom> I can't think of a better match either.
15:24:52 <monochrom> @hoogle (Integral a, Fractional b) => a -> b -> b
15:24:54 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
15:24:54 <lambdabot> Control.Parallel par :: a -> b -> b
15:24:54 <lambdabot> Control.Parallel pseq :: a -> b -> b
15:25:02 <monochrom> That may be better.
15:25:18 <largos> I was hoping for division of Ints that generates a Fractional
15:25:39 <monochrom> Unfortunately no. Insert lots of fromIntegral on your own.
15:25:46 <roconnor> @type \a b -> (fromIntegral a) / (fromIntegral b)
15:25:48 <lambdabot> forall a b a1. (Integral a, Fractional b, Integral a1) => a -> a1 -> b
15:26:14 <roconnor> @type (%)
15:26:15 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
15:26:57 <largos> oh, interesting.  I'd assumed that was mod.
15:40:04 <deech> Hi all, I am trying to understand how to use mconcat. I have a simple zipper tree implementation at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6650#a6650. My use of mconcat (mconcat [left,left,left]) has a valid type signature, but I can't seem to pass in a Zipper correctly. What am I doing wrong?
15:42:28 <ski> what is `Top' for ?
15:42:44 <deech> ski: I just realized that Top is never used.
15:43:40 <deech> ski: The navigation function themselves seem to work, so 'left testTree' and 'left testTree >>= left' works fine.
15:43:42 <monochrom> What is the type of mconcat?
15:43:48 <monochrom> @type mconcat
15:43:49 <lambdabot> forall a. (Monoid a) => [a] -> a
15:44:26 <monochrom> So we need "Zipper a -> Maybe (Zipper a)" to be an instance of Monoid? I think it isn't, at least it isn't now.
15:44:44 <troutwine> Anyone know how to install profiling versions of libraries with cabal-install? I've got library-profiling enabled in .cabal/config, but that didn't seem to work.
15:44:45 <ski> i'm not sure why deech is wanting to use `mconcat' at all
15:45:40 <dcoutts> troutwine: it'll work for all new packages you install
15:46:10 <dcoutts> troutwine: though you might need to go back and re-install some previously installed packages so they get rebuilt with profiling
15:46:17 <deech> ski: I just basically want to write [left,left,left] in a list and work through them, would foldr (\z f -> fmap f z) testTree [left,left,left] be a better way?
15:46:37 <troutwine> dcoutts: I reinstalled a couple of the packages I needed profiling versions for to no avail, it seems.
15:46:42 <roconnor> deech: it seems you need to make a data type data Foo a = Foo (a -> Maybe a), and then make Foo a an instance of monoid, and then wrap your left, etc. functions
15:46:52 <ski> EndoKleisli ?
15:47:04 <roconnor> ski: perhaps
15:47:23 <largos> hrm... is Test.QuickCheck.generate still around in ghc 6.10?
15:47:26 <roconnor> ski: makes sense: A monad is just a monoid in the category of endofunctors.  What's the problem?
15:47:26 <dcoutts> troutwine: I guess you need to explain what you're doing exactly, eg with a log of the command you ran and the failure
15:47:28 <dcoutts> @hpaste
15:47:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:47:49 <troutwine> dcoutts: Sure thing. One moment.
15:47:59 <largos> I've added the module in ghci, but it still can't find generate (I get 'not in scope')
15:48:17 <roconnor> We should totally make an EndoKleisli class.  It would make deech very happy here.
15:48:58 <troutwine> dcoutts: Blast it, nevermind. I had library-profiling commented out. Today is my day for silly mistakes.
15:49:12 <dcoutts> troutwine: np
15:50:01 <dcoutts> troutwine: it's actually a relatively common mistake, we added a comment to the top of the config file to try and make it clearer than -- is comment syntax so fewer people would trip up over it.
15:50:27 <ski> roconnor : `class' ?
15:50:34 <troutwine> dcoutts: Good call. The comment along the top is what tipped me off, eventually.
15:51:00 <Cale> largos: unGen looks similar in function.
15:51:05 <roconnor> ski, sorry. newtype
15:52:06 <ski> @let composeM :: Monad m => [a -> m a] -> (a -> m a); composeM = foldr (>=>) return
15:52:07 <lambdabot>  Defined.
15:52:10 <roconnor> ski_: or do we just make (arrow a a) a monoid?
15:52:20 <ski> deech : how about that `composeM' ?
15:52:32 <largos> Cale: Data.Generic.Aliases.unGen?
15:52:45 <largos> it doesn't have the same type...
15:52:49 <largos> generate :: Int -> StdGen -> Gen a -> a
15:52:50 <Cale> largos: Test.QuickCheck.Gen.unGen
15:52:51 <monochrom> O hai Cale. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2951#a2952 may give you a heart attack re: how to have some global variable without unsafePerformIO but with another backdoor :)
15:53:05 <largos> ah... gah... why am I having so many hoogle issues today/
15:53:34 <ski> deech : try `composeM [right,left,right] testTree'
15:53:44 <roconnor> @seen edwardk
15:53:44 <lambdabot> I saw edwardk leaving #haskell-blah 11h 7m 37s ago, and .
15:53:45 <monochrom> @type composeM
15:53:46 <lambdabot> forall a (m :: * -> *). (Monad m) => [a -> m a] -> a -> m a
15:53:54 <Cale> monochrom: nice
15:53:55 <monochrom> Ah!
15:54:10 <largos> Cale: where did you find that?
15:54:33 <dons> monochrom: hahah
15:54:44 <Cale> largos: In the QuickCheck documentation on Hackage
15:55:00 <dons> monochrom: yeah, handlers are magically globally allocated
15:55:05 <deech> ski: I'm trying it right now.
15:55:11 <Cale> http://hackage.haskell.org/package/QuickCheck-2.1.0.1
15:55:11 <largos> oh! Hoogle is linking to the 1.1.0.0 version of Quickcheck!
15:55:24 <largos> thanks!
15:55:33 <ski> deech : you'll need to put that definition above of `composeM' into a module, of course
15:56:04 <ski> hm
15:56:29 <ski> deech : though maybe you wanted to use `(<=<)' instead of `(>=>)' .. i'm not sure
15:56:37 <dons> monochrom: signal handlers are weird
15:56:45 <dons> these strange async threads that are forked based on events
15:56:51 <dons> a little bit of reactivity wired into the runtime
15:57:05 <Cale> QuickCheck's version numbering scheme is just a little bit funny. 1.0, then 1.1.0.0 (two 0's?) then 1.2.0.0, then just 2.1, and then 2.1.0.1, because 2.2 or 2.1.1 would be too large a change ;)
15:57:33 <deech> ski: Wow that worked. And I think I finally understand how Kleisli arrows work! Thanks!
15:58:15 <ski> deech : with `(>=>)', the operations in the list are performed "from the left to the right"; with `(<=<)', in the other direction
15:58:44 <Cale> (<=<) is most like traditional composition.
15:58:49 <ski> *nod*
15:59:17 <ski> (and that's what i would expect, given the name `composeM')
15:59:32 <deech> neato!
16:00:03 <pikhq> Cale: It must be approaching some number.
16:00:48 <roconnor> newtype EndoArrow a x = EndoArrow { runEndoArrow :: a x x};  instance (Arrow a) => Monoid (EndoArrow a x) where mempty = EndoArrow pure; ...
16:07:39 <roconnor> @hoogle f o -> o
16:07:39 <lambdabot> Data.Monoid getDual :: Dual a -> a
16:07:39 <lambdabot> Foreign unsafePerformIO :: IO a -> a
16:07:39 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
16:07:58 <roconnor> @hoogle crush
16:07:58 <lambdabot> No results found
16:10:28 <deech> seems like Hayoo just went down.
16:11:41 <roconnor> composeM = runKleisli . runEndoArrow . foldMapDefault (EndoArrow . Kleisli)
16:12:39 <roconnor> composeM = runKleisli . runEndoArrow . foldMap (EndoArrow . Kleisli)
16:12:47 <mike-burns> ... how can new programmers possibly find Haskell intimidating!
16:13:02 <roconnor> :D
16:13:13 <monochrom> Everything is intimidating.
16:13:35 <deech> roconnor: holy crap! Can you help me unpack that?
16:13:41 <roconnor> yes
16:13:47 <monochrom> Remember how your were a kid and they made you memorize [ x*y | x<-[1..9], y<-[1..9] ] ?  It was intimidating!
16:14:09 <monochrom> Remember how you were a kid and they made you memorize ['a'..'z']? It was intimidating!
16:14:48 <roconnor> I think Conor McBride would write : composeM = (EndoArrow . Kleisli) `ily` foldMap
16:15:09 <monochrom> Yo Dawg we heard you liek intimidation so we put intimidation in Haskell so you can have haskell with intimidation!
16:15:09 <roconnor> deech: what do you want to know?
16:15:17 <monochrom> ily ?!!
16:15:48 <roconnor> monochrom: http://strictlypositive.org/Idiom.pdf  page 9, exercise 8
16:16:00 <ski> @type foldMap
16:16:01 <lambdabot> Not in scope: `foldMap'
16:16:35 <deech> foldMap take functions that return a Monoid and combined it.
16:16:49 <deech> Aside from that every word in there is new to me.
16:17:07 <roconnor> deech: let's start with foldMap
16:17:25 <roconnor> deech: because all the other functions are just wrappers and unwrappers, and have no functionality
16:17:36 <roconnor> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html#v%3AfoldMap
16:17:43 <roconnor> foldMap :: Monoid m => (a -> m) -> t a -> m
16:17:51 <roconnor> Map each element of the structure to a monoid, and combine the results.
16:18:04 <roconnor> oh and where (Foldable t)
16:18:11 <deech> I would have expected 't a' to be a list.
16:18:12 <roconnor> foldMap is one of Foldable's methods
16:18:20 <roconnor> [] is an instance of foldable
16:18:36 <roconnor> but this code is generic over all foldable structures.
16:18:51 <deech> so any recursive data structure?
16:19:01 <roconnor> not any, but lots
16:19:22 <roconnor> basically anything that can define a foldr
16:19:33 <roconnor> Foldable, Minimal complete definition: foldMap or foldr.
16:19:52 <Twey> :t foldMap
16:19:54 <lambdabot> Not in scope: `foldMap'
16:20:04 <Twey> Oh, up there.
16:20:06 <deech> So we are taking each of my functions and taking on EndoArrow and Kleisi, so 'left' becomes 'EndoArrow Kleisi left', right?
16:20:24 <roconnor> deech: you need more ()'s but yes
16:20:50 <ski> EndoArrow (Kleisi Maybe) (Zipper a)
16:21:16 <roconnor> ski shows what type this will be.
16:21:30 <roconnor> in your case
16:21:54 <deech> And Maybe is foldable.
16:22:07 <roconnor> deech: [] is foldable
16:22:23 <roconnor> foldMap :: Monoid m => (a -> m) -> t a -> m
16:22:36 <roconnor> in this case "m" is what  ski said
16:22:42 <roconnor> "t" will be []
16:22:43 <ski>   foldMap (EndoArrow . Kleisli) :: [EndoArrow (Kleisi Maybe) (Zipper a)] -> EndoArrow (Kleisi Maybe) (Zipper a)
16:22:46 <ski> here
16:22:53 <ski> er
16:23:03 <roconnor> and "a" will be (Zipper a -> Maybe (Zipper a))
16:23:04 <ski>   foldMap (EndoArrow . Kleisli) :: [Zipper a -> Maybe (Zipper a)] -> EndoArrow (Kleisi Maybe) (Zipper a)
16:23:53 <deech> oh wow, and runEndo removes the EndoArrow and runKleisi removes the Kleisi.
16:23:54 <roconnor> deech: keep in mind that EndoArrow is sort of something I made up here.  But it really ought to be implemented somewhere.
16:24:09 <ski> the `EndoArrow . Kleisli' wraps each `Zipper a -> Maybe (Zipper a)' into an `EndoArrow (Kleisi Maybe) (Zipper a)'
16:24:37 <roconnor> deech: you could implement EndoArrow yourself.  It isn't too hard.
16:24:38 <ski> then `foldMap' combines those using the `instance Monoid (EndoArrow (Kleisi Maybe) (Zipper a))', into a single `EndoArrow (Kleisi Maybe) (Zipper a)'
16:25:48 <deech> And the runKleisi and runEndoArrow just remove the constructors.
16:25:49 <ski> and all that `Monoid' instance is doing is chaining the functions up, using monadic composition
16:25:53 <ski> yes
16:26:03 <deech> clever.
16:26:34 <deech> I guess this gets around the difficulty of composeM only accepting functions that take one argument.
16:26:36 <roconnor> what is arrow compositoin?
16:26:53 <roconnor> >>>  or <<< ?
16:26:56 <roconnor> hmm
16:27:00 <ski> both
16:27:04 <deech> both, right?
16:27:13 <nominolo> @pl (\s (_,bi) -> addLCASet s (bindBinder bi))
16:27:14 <lambdabot> (. snd) . (. bindBinder) . addLCASet
16:27:26 <nominolo> ugh
16:27:32 <ski> deech : what difficulty with "composeM only accepting functions that take one argument" ?
16:27:51 <ski> (deech : i don't see that working before, and i don't see that working now either ..)
16:28:33 <ski> roconnor : anyway, i'd expect `<<<' to be used
16:28:36 <roconnor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6653#a6653
16:28:44 * ski wonders what is used in `Endo'
16:28:47 <deech> Since composeM is of type [a -> m a] -> a -> m a, doesn't the initial list only take functions that take one argument? So if I had (a -> a -> m a) this would be rejected by the typechecker.
16:29:31 <ski> > mconcat [Endo (* 2),Endo (+ 3)] `appEndo` 10
16:29:32 <lambdabot>   26
16:29:39 <roconnor> hmm, you may actually want composeM = runKleisli . runEndoArrow . getDual . foldMap (Dual . EndoArrow . Kleisli)
16:29:57 <ski> roconnor : why ?
16:30:24 <roconnor> I don't know which way deech wants to compose
16:30:33 <ski> deech : sure .. i still don't see a problem
16:30:46 <deech> roconnor: left to right.
16:31:12 <deech> ski: it's not a problem, it fact it's perfect. I was just trying to understand it.
16:31:27 * ski would prefer the name `composeM' being used for "right-to-left" composition
16:33:03 <roconnor> deech: Endo(morphism) are function like things that take one argument and return one argument of the same type.
16:33:30 <ski> deech : so you want `composeThem [left,right] testTree' to yield `Just (Leaf 2)' ?
16:33:51 <roconnor> actually, we should be able to generalize Arrow to Category
16:33:57 <ski> (where `composeThem' is your preferred composition direction, here ..)
16:34:48 <deech> ski: Actually a tuple (<thread of journey>, Just (Leaf 2))
16:34:58 <ski> er, right
16:35:06 * ski forgot about that, for the while
16:35:28 <ski> (though the `Just' should be the outer constructor ..)
16:35:54 <roconnor> EndoCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6653#a6654
16:36:05 <deech> ski: You're right, brain fart. This is what it should be: Just ([(RightTurn,Leaf 1),(LeftTurn,Bin (Bin (Leaf 3) (Leaf 4)) (Bin (Leaf 5) (Leaf 6)))],Leaf 2)
16:36:12 <roconnor> oops missed one arrow
16:36:50 <ski> deech : yes
16:36:59 <ski> hm
16:37:10 <ski> actually, no
16:37:19 <roconnor> EndoCategory: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6653#a6655
16:37:46 <ski> deech : since your `right' is run last, you'd get `(LeftTurn,..)' at the top of the list
16:38:17 <roconnor> someone make a library proposal out of that!
16:38:26 <ski> no
16:38:28 <ski> i'm confused
16:38:50 <manos2312> is there anybody to know anything about haskell and opengl ?
16:39:12 <ski> deech : disregard what i said. i wasn't thinking clearly
16:39:50 <deech> ski: So reading my thread from right to left it says that I've from root, I've made a LeftTurn and then a RightTurn.
16:40:01 <ski> roconnor : we want `<<<' in analogy of `.' for `Endo'
16:40:20 <roconnor> yep
16:40:25 <ski> deech : yes
16:40:26 <roconnor> I just checked
16:40:36 <roconnor> ski: does that mean deech wants to use Dual?
16:40:50 * ski also checked .. some 50 lines up
16:41:13 * roconnor doesn't use opengl :(
16:41:14 <ski> that or `reverse'
16:41:28 <roconnor> reverse is bad
16:41:33 <ski> yes
16:41:53 <ski> but is using `Dual' better ?
16:41:57 <roconnor> he could also use BackwardsApplicative []
16:42:09 <roconnor> ski:  I think Dual has better complexity
16:42:23 <roconnor> or potentially better complexity
16:43:02 <roconnor> except BackwardsApplicative doesn't exist
16:43:40 <deech> roconnor: is reverse bad because it traverses the entire list?
16:44:08 <roconnor> ya, it will hold the entire list in memory to grab the tail.
16:44:35 <roconnor> Dual will just do composition on the other side and foldMap will remain a nice consumer.
16:44:51 <roconnor> or at least as nice as it usually is
16:45:17 <roconnor> Actually, using BackwardsApplicative []  feels more correct than using dual.
16:45:38 <roconnor> The real problem is that our lists in Haskell go the wrong way
16:46:24 <roconnor> composeM = runKleisli . runEndoArrow . foldMap (EndoArrow . Kleisli)
16:47:29 <roconnor> deepsFunction = composeM . BackwardsTraverse
16:47:38 <deech> gtg, thanks so much for the education!
16:51:22 <manos2312> Hi !! I need help , i am trying to build frag (an open gl game) but it has problem with build-depends
16:51:46 <manos2312> i ubuntu
16:51:47 <roconnor> @hackage frag
16:51:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/frag
16:51:51 <ski> iiuc
16:51:52 <manos2312> i use ubuntu
16:51:58 <ski>   composeM (f:fs) a = case composeM fs a of Nothing -> Nothing; Just a' -> f a'
16:52:00 <ski>   dualComposeM (f:fs) a = case f a of Nothing -> Nothing; Just a' -> composeM fs a'
16:52:52 <roconnor> manos2312: what sort of dependency errors?
16:53:03 <ski> so using `Dual (EndoCat (Kleisli Maybe) (Zipper a))' would here not travers the whole list before being able to do something
16:53:24 <manos2312> Setup: frag.cabal:86: Parse of field 'build-depends' failed:
16:53:38 <dons> oh, how old is your cabal?
16:53:41 <roconnor> ouch!
16:53:44 <dons> ghc-pkg list Cabal
16:54:07 <dons> $ cabal install frag
16:54:08 <dons>  works here.
16:54:14 <manos2312> ghc-pkg list Cabal
16:54:22 <manos2312> sorry
16:54:23 <manos2312> :D
16:54:43 <roconnor> ski_: potentially.  I believe it would short circut when hitting Maybe.
16:54:45 <manos2312>    Cabal-1.2.3.0
16:55:04 <roconnor> ski_: hitting Nothing I mean
16:55:15 <dons> try updating to Cabal 1.6.x
16:55:23 <dons> you can do that via the Haskell Platform.
16:55:34 <dons> and you'll get a more modern GHC as well.
16:55:52 <manos2312> how ?
16:56:10 <manos2312> aptitude install cabal ?
16:56:24 <roconnor> cabal install cabal ?
16:56:34 <dons> probably manos2312 doesn't have 'cabal-install'
16:56:42 <roconnor> oh
16:56:48 <manos2312> yeah i dont
16:56:57 <dons> you'll really want to install ghc-6.10.3 first, then http://hackage.haskell.org/platform/
16:56:57 <manos2312> now i know
16:57:00 <ski> roconnor : talking about the `composeM' or the `dualComposeM' case above ?
16:57:00 <dons> to be up to date.
16:57:37 <roconnor> ski: dualComposeM, applied in deech's particular application
16:57:59 <manos2312> aaa!! it does not have for ubuntu
16:58:05 <ski> (yes, that's what `dualComposeM' was meant to be .. i.e. deech's particular application)
16:58:13 <manos2312> it does not matter i guess
16:58:30 <roconnor> ski: this can be tested if you implement it and trying (dualComposeM (const Nothing:undefined) 5)
16:58:44 <ski> (roconnor : and evaluating `f a' here counts as "doing something" :)
17:02:05 <manos2312> @hackage ghc
17:02:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghc
17:02:17 <roconnor> @hackage manos2312
17:02:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/manos2312
17:02:27 <manos2312> :D
17:02:53 <manos2312> where can i find the latest ghc for ubuntu ?
17:05:18 <manos2312> roconnor: i found
17:05:22 <manos2312> thnx !!
17:10:19 <manos2312> roconnor: i dont understand , what kind of linux do u have ?
17:11:23 <roconnor> I have ubuntu 9.04
17:11:37 <roconnor> I installed cabal manually
17:11:42 <roconnor> to get the lastest
17:12:14 <roconnor> $ ghc-pkg list Cabal
17:12:16 <roconnor> /usr/lib/ghc-6.8.2/package.conf:
17:12:17 <roconnor>     Cabal-1.2.3.0
17:12:19 <roconnor> /home/roconnor/.ghc/i386-linux-6.8.2/package.conf:
17:12:20 <roconnor>     Cabal-1.6.0.1
17:12:34 <dcoutts> @arr!
17:12:34 <lambdabot> Keelhaul the swabs!
17:12:46 <manos2312> @hackage cabal
17:12:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal
17:13:14 <dcoutts> oh someone needs to update the @hackage command, there's a new shorter url scheme
17:13:27 <dcoutts> gwern: would you be the person to do that? ^^
17:13:28 <manos2312> ok cool
17:13:37 <manos2312> i am going to install it manually as well
17:13:38 <roconnor> manos2312: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
17:13:42 <monochrom> I use ubuntu 9.04 too and I install ghc manually too, no debs, ghc debs lag too much.
17:14:37 <roconnor> manos2312: wait, that is the wrong link
17:14:44 <manos2312> ok
17:15:04 <mjrosenb> hey anyone know about darcs? #darcs seems to be dead
17:15:11 <roconnor> manos2312: http://www.haskell.org/cabal/download.html
17:16:00 <roconnor> manos2312: download that and follow the README in the archive
17:16:16 <manos2312> ok
17:16:24 <roconnor> it is as easy as installing a cabal package manually
17:16:38 <manos2312> w8 , first install new gch ?
17:16:43 <roconnor> manos2312: you can do it either as user or roor
17:16:44 <manos2312> or new cabal ?
17:17:12 <roconnor> manos2312: I'm still using Ubuntu 9.04's ghc FWIW
17:17:30 <manos2312> a ok
17:17:32 <manos2312> cool
17:17:55 <roconnor> some of my code runs faster when compiled with this old GHC :P
17:19:02 <roconnor> manos2312: probably installing it as root would be better
17:19:05 <roconnor> even though I did user
17:19:22 <roconnor> hmm
17:19:24 <roconnor> hard to say
17:19:24 <monochrom> Heh I'm afraid of ghc 6.10.x, I'm still at 6.8.2, perhaps I can now use the debs. :)
17:20:44 <manos2312> hmm... no 6.10.x then
17:21:02 <roconnor> I'm using 6.8.2
17:42:44 <gwern> dcoutts: what's the new prefix?
17:44:08 <dcoutts> gwern: eg http://hackage.haskell.org/package/Cabal
17:44:09 <manos2312> roconnor : did u install frag ?
17:53:46 <heatsink> Hmm
17:53:52 <heatsink> I have a data type with like ten constructors
17:54:07 <heatsink> I want to write a fold, but it will be unwieldy
17:58:00 <gwern> dcoutts: it's pushed but who knows when it'll be updated
17:58:08 <dcoutts> gwern: great
18:03:17 <hackagebot> happstack-state 0.3.4 - Event-based distributed state. (MatthewElder)
18:05:01 <troutwine> I've a server program that's leaking memory at about 10MB per hour. Profiling shows HXT to be the biggest allocator, but I'm not sure if that's where the memory is leaking.
18:05:13 <troutwine> How do I go about finding which bits of my program are holding onto memory?
18:05:29 <heatsink> troutwine, normally by compiling and running with profiling
18:06:04 <heatsink> The GC gets instrumented to keep track of what objects are live, and it saves a record when the program exists.
18:06:20 <heatsink> *exits
18:06:31 <heatsink> although existence is a necessary precondition
18:06:54 <heatsink> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
18:07:17 <troutwine> heatsink: Hmm... I've done all of that. I'm still not sure what's going on.
18:07:48 <dilinger> yay, this month's boston HUG meeting is in cambridge rather than out in the sticks
18:08:01 <heatsink> Retainer profiling is sometimes useful for figuring out what's keeping the data alive...
18:08:29 <heatsink> Aside from different profiler options, I don't know of much you can do
18:08:43 <heatsink> that tools will help with, anyway
18:09:19 <troutwine> heatsink: Ah, I'd overlooked retainer profiling. I'll have a go with that.
18:14:20 <hackagebot> happstack-data 0.3.3 - Happstack data manipulation libraries (MatthewElder)
18:14:35 * shapr boings cheerfully
18:15:15 <mae> shapr: boing
18:16:26 <Nafai> Hey shapr!
18:16:32 <shapr> hiya!
18:16:37 <shapr> y0 mae, how's code?
18:16:45 <shapr> mae: Are you really older than me?
18:17:03 <mae> shapr: hmm good i guess :)
18:17:13 <mae> shapr: i am not sure, how old are you? :)
18:17:22 <mae> I am 25
18:17:42 <shapr> Oh, I'm 37
18:17:50 <shapr> I'm OLD!
18:17:57 <shapr> At least, it feels like it after Capoeira class.
18:17:59 <shapr> Anyway....
18:27:37 <mae> lol
18:27:41 <mae> my friend kingsley did that
18:34:43 <roconnor> I can't tell if Backwards is on Foldable, or Traversable, or both.  Probably both.
18:34:58 <Gracenotes> backwards? some sort of function?
18:34:59 <roconnor> might as well throw in ApplicativeFunctor too.
18:35:14 <Gracenotes> newtyped something or another?
18:35:19 <roconnor> Gracenotes: it makes a new Traversable/Foldable that goes the other way
18:35:23 <roconnor> newtyped
18:35:28 <roconnor> I think
18:35:35 <roconnor> I haven't really worked it out
18:35:43 <Gracenotes> ah, I see
18:35:59 <Gracenotes> should look something like the foldr implementation of foldl, I'd guess
18:36:19 <Gracenotes> but Foldable does have both foldr and foldl
18:37:18 <roconnor> Gracenotes: so for traversable, you take the original instance and then sandwitch the backwards applicative functor in with traverse
18:37:34 <Gracenotes> ooh o_o
18:37:39 <jeffwheeler> The examples in Network.HTTP all seem to use fmap (take 100) when reading the body, like here: http://hackage.haskell.org/packages/archive/HTTP/4000.0.7/doc/html/Network-HTTP.html
18:37:47 <jeffwheeler> Is that to do some sort of chunk-etization
18:38:04 <roconnor> Gracenotes: and for Foldable you do the same thing except with the dual monoid and foldMap
18:38:05 <jeffwheeler> It seems to work fine without it, too
18:38:29 <roconnor> Gracenotes: which makes a case for calling Backwards Dual instead
18:38:33 <Gracenotes> well, what type does simpleHTTP return
18:39:11 <roconnor> or perhaps DualApplicative and BackwardsFoldable and BackwardsTraversable
18:39:13 <Gracenotes> an IO (Result (Response ty)).
18:39:21 <jeffwheeler> Gracenotes: yeah
18:39:40 <jeffwheeler> Gracenotes: and that's exactly what getResponseBody accepts
18:39:42 <Gracenotes> Result = Either ConnError a, Response = some complicated datatype
18:40:02 <Gracenotes> oh, right. I wish they'd use =<< here :)
18:41:28 <Gracenotes> jeffwheeler: the fmap is IO. >_>
18:42:05 * Gracenotes almost thinks liftM is clearer than fmap in many cases
18:42:21 <jeffwheeler> Gracenotes: huh?
18:42:25 <Gracenotes> so it takes 100 characters from the HStream, which in this case is a String, inferred by the take
18:42:47 <jeffwheeler> And so it only ever the first hundred bytes from the connection?
18:42:50 <Gracenotes> although take also works for ByteStrings if you hide the one from prelude
18:43:10 <jeffwheeler> Err, so it only ever loads
18:43:11 <Gracenotes> .. I'm guessing. I'm not sure how lazy it is.
18:43:25 <jeffwheeler> Alright, that makes sense; thanks
18:46:47 <eflister> noob has a question
18:47:10 <jeffwheeler> eflister: just ask :)
18:47:21 <eflister> i'm trying to combine Bounded and Enum to a 'Loop' class
18:49:41 <aavogt> eflister: what kind of instance did you try to write?
18:50:58 <troutwine> I've a program that's segfaulting when I run it with +RTS -hc. I'm using GHC 6.10.3 and doing no FFI trickery.
18:51:25 <troutwine> Why would this be happening, I guess?
18:56:31 <eflister_> hmm, is this a bad place to ask?  is there a mailing list?
18:56:42 <pikhq> Don't ask to ask, just ask.
18:57:01 <eflister_> i asked above -- i haven't seen any traffic for several mins
18:57:28 <eflister_> does it matter what server i'm on?  (irc.freenode.net)
18:57:34 <aavogt> no
18:57:41 <pikhq> It's just quiet ATM.
18:57:48 <eflister_> oh ok, thx
18:58:38 <aavogt> so you tried to write a non-Haskell '98 instance:  instance (Enum a, Bounded a) => Loop a where ...?
18:58:51 <eflister_> class (Eq a, Bounded a, Enum a) => Loop a where
18:59:10 <eflister_> and then things like WeekDay would be an instance
18:59:43 <aavogt> that can work given enough extensions (-XUndecidableInstances I think)
19:00:10 <eflister_> it works if i replace maxBound with a specific constructor, like G
19:00:30 <eflister_> hmm, ok i'll try that -- but can you help me understand why it's a problem?
19:01:00 <eflister_> i haven't dived into extensions yet -- my intuition is that it's sort of cheating
19:01:13 <aavogt> as far as I know, the instance you are trying to write is not legal Haskell 98
19:01:19 <rocketman> not at all
19:01:35 <aavogt> but let me try and see how far I get
19:01:53 <eflister_> i'm using the latest ghc -- what isn't legal about it?  can you not define classes in terms of other classes?
19:02:38 <jix> eflister: almost any bigger haskell program uses some extensions or at least uses them indirectly AFAIK
19:02:49 <roconnor> @src Dual
19:02:49 <lambdabot> Source not found. stty: unknown mode: doofus
19:02:57 <roconnor> @src getDual
19:02:58 <lambdabot> Source not found. I feel much better now.
19:04:20 <smitty1e> Is there anywhere a simple haskell example of putting two integers in state monads and adding them?
19:04:21 <lambdabot> smitty1e: You have 1 new message. '/msg lambdabot @messages' to read it.
19:04:22 <aavogt> eflister_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6659#a6659
19:05:08 <aavogt> @type runState
19:05:09 <lambdabot> forall s a. State s a -> s -> (a, s)
19:05:15 <aavogt> @type execState
19:05:17 <lambdabot> forall s a. State s a -> s -> s
19:05:50 <aavogt> > fst $ runState $ liftM2 (+) (return 1) (return 3)
19:05:51 <lambdabot>   Couldn't match expected type `(a, b)'
19:06:04 <eflister_> yeah succ is easy to write -- to write shortest, you need to refer to fromEnum maxBound
19:06:04 <aavogt> > fst $ runState undefined $ liftM2 (+) (return 1) (return 3)
19:06:05 <lambdabot>   Add a type signature
19:06:22 <aavogt> > fst $ runState 20 $ liftM2 (+) (return 1) (return 3)
19:06:24 <lambdabot>   Add a type signature
19:06:34 <aavogt> > fst $ runState (20::Int) $ liftM2 (+) (return 1) (return 3)
19:06:36 <lambdabot>   Couldn't match expected type `Control.Monad.State.Lazy.State a a1'
19:06:52 <aavogt> hmm, its flipped
19:07:00 <aavogt> > fst $ flip runState (20::Int) $ liftM2 (+) (return 1) (return 3)
19:07:02 <lambdabot>   4
19:07:29 <aavogt> smitty1e: I get the feeling that you aren't looking for that ^^
19:07:53 <aavogt> eflister_: so which methods are causing problems?
19:08:26 <smitty1e> aavogt: I'm reading all these Monad tutorials, and I just need to see some trivial math example to figure out where the keywords go.
19:08:36 <eflister_> aavogt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6659#a6660
19:10:05 <roconnor> @type appEndo
19:10:06 <lambdabot> forall a. Endo a -> a -> a
19:10:15 <aavogt> smitty1e: what I pasted does not use the the State part at all: it just lifts the value into the Monad, combines two such values, and then gets the value
19:10:47 <aavogt> > fromEnum maxBound
19:10:49 <lambdabot>   Add a type signature
19:10:56 <aavogt> @type fromEnum
19:10:58 <lambdabot> forall a. (Enum a) => a -> Int
19:11:25 <aavogt> @type enumDiff
19:11:26 <lambdabot> Not in scope: `enumDiff'
19:11:34 <aavogt> eflister_: where is enumDiff defined?
19:12:31 <aavogt> @type put
19:12:33 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
19:13:11 <eflister_> aavogt: sorry, added it http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6659#a6661
19:14:18 <aavogt> > flip runState 0 $ do { modify (+1); x <- (return 1); modify (+x) }
19:14:20 <lambdabot>   ((),2)
19:14:45 <aavogt> > flip runState 0 $ do { modify (+1); x <- (return 1); modify (+x); return "unrelated content?" }
19:14:46 <lambdabot>   ("unrelated content?",2)
19:14:58 <roconnor> > let fold = foldl . flip in fold (:) [] [1,2,3]
19:15:00 <lambdabot>   [3,2,1]
19:15:29 <monochrom> Suppose we write two functions f,g and they both use an auxiliary function aux, how to make aux local to f,g and not top-level?
19:16:32 <rocketman> (f,g) = (f',g') where
19:16:38 <rocketman>  f' = ...
19:16:43 <rocketman>  g' = ...
19:16:48 <rocketman>  aux = ...
19:16:53 <monochrom> I was hoping I don't need to do that. :)
19:17:01 <rocketman> sorry
19:17:04 <aavogt> separate modules
19:17:31 <monochrom> OTOH there is little wrong with making aux top-level if I make its name obscure.
19:17:45 <aavogt> so that that the top level isn't a bad place to put things, since there won't be many there
19:18:10 <aavogt> or find a better name for it :)
19:23:01 <aavogt> eflister_:             biggest = fromEnum (maxBound `asTypeOf` a)
19:23:17 <SamB_XP> monochrom: first off, f and g are HORRIBLE names for functions
19:23:26 <aavogt> @type asTypeOf
19:23:27 <lambdabot> forall a. a -> a -> a
19:23:30 <rocketman> heh
19:23:34 <aavogt> @src asTypeOf
19:23:35 <lambdabot> asTypeOf = const
19:24:03 <SamB_XP> monochrom: secondly, I would have expected you to know that there is no nice way by now
19:24:05 <monochrom> f,g are meta-variables for function names.
19:24:30 <aavogt> asTypeOf discards the second argument, which is only passed to fix the type of the first argument
19:24:30 <SamB_XP> though you could do tricks involving (f, g) = (f', g') where
19:24:34 <rocketman> (f and g are HORRIBLE meta-names for functions)
19:24:35 <smitty1e> OK, this nearly works http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6662#a6662
19:25:02 <smitty1e> It's a horrible thing, but I just need my foot in the door with the syntax.
19:25:21 <smitty1e> Quite the intellectual greased pig, the concept. ;)
19:25:28 <eflister_> aavogt: that worked, thx!!1
19:26:18 <smitty1e> It's just taking 9.3 from the Gentle Introduction and using Int instead of S.
19:26:29 <smitty1e> All I want to do is add the two pieces of state.
19:26:51 <roconnor> @src Functor
19:26:51 <lambdabot> class  Functor f  where
19:26:51 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
19:27:14 <aavogt>                    return y + z
19:27:21 <aavogt> should be return (y+z)
19:28:00 <monochrom> smitty1e I have annotated.
19:28:24 <monochrom> Yikes, that's still wrong.
19:28:52 <eflister_> i even see why it was necessary now.
19:29:24 <monochrom> Newer annotation now.
19:30:32 <smitty1e> monochrom: the last line is giving me errors.
19:30:36 <aavogt> monochrom: or should it have taken the Ints out of the state as originally done?
19:31:40 <aavogt> smitty1e: construct SM values out of pure values with 'return', not the SM construtor on its own
19:31:46 <monochrom> More annotation, this one is for main.
19:33:57 <smitty1e> Thanks, compined and ran, returning a tuple (9,0) from the runSM.  But I feel about 17 times better about this stuff for your help.
19:35:13 <aavogt> given your initial definition of addThem (with the parentheses fixed), would it have yielded 0?
19:36:17 <aavogt> currently you aren't doing anything with the state
19:36:47 <aavogt> in Main that is
19:37:53 <smitty1e> aavogt: Having the thing compiled and working, I need to updateSM and re-addThem.
19:38:29 <smitty1e> I suggest that something tasteless and stupid like this is highly useful for communicating the ideas from a bottom-up sort of way.
19:40:16 <monochrom> Yes, I do that too to learn things.
19:40:26 <aavogt> seeing and understanding the implementation is not required to be able to use Monad though
19:40:42 <SamB_XP> aavogt: implementation of what?
19:40:52 <aavogt> SamB_XP: the various instances
19:41:09 <smitty1e> Now, I need a and b in main to be actual SM instances, don't I, to updateSM and then addThem again?
19:43:18 <Cale> btw, addThem = liftM2 (+)
19:43:21 <roconnor> doh, I don't have Control.Category
19:43:34 <monochrom> a and b are already SM instances. You can of course rewrite them to do more interesting things.
19:43:47 <hackagebot> sendfile 0.3 - A portable sendfile library (MatthewElder)
19:44:14 <Cale> Also, I noticed a little slip in terminology in the comment there... addThem doesn't take two *monads*, it takes two SM computations.
19:44:28 <smitty1e> monochrom: They are not mere Int values getting typecast at the addThem call?
19:44:30 <Cale> SM, at the type level, is itself a monad.
19:44:49 <Cale> smitty1e: That's what return does
19:44:55 <Cale> return :: (Monad m) => a -> m a
19:45:14 <Cale> return v produces a computation which "does nothing" and produces v as its result.
19:45:18 <monochrom> "return 4" is not an Int.
19:45:24 <mmorrow> @type return return
19:45:26 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 (a -> m a)
19:45:29 <Cale> In this case, our monad m is SM
19:45:36 <Cale> So return :: Int -> SM Int
19:46:05 <monochrom> I may agree that "return 4" is not very specifically SM Int either, except that the context confines it.
19:46:40 <aavogt> I think that it is a point of confusion that SM contains an Int state, as well as an Int value (in the code posted).
19:46:51 <Cale> It's possible to write >>= in what I consider to be a more readable way if you make use of your runSM in the definition.
19:46:54 <monochrom> a = updateSM (+1) >> return 4   <--- try this for fun
19:47:46 <mae> when does hackage attempt package builds? (and haddock) it seems like the lag time is pretty long right now.
19:48:49 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6662#a6666
19:48:53 <aavogt> mae: that came up on the haskell mailing list. I think it was something like 4 times daily that haddocks would be built on hackage
19:49:12 <aavogt> or is it worse than that now?
19:49:19 <monochrom> We have reached 6666, so it seems. (Another number superstition!)
19:49:22 <Cale> Er, oops
19:49:29 <Cale> I missed a )
19:49:35 <roconnor> ski_: I tried it out
19:49:42 <roconnor> > composeM (const Nothing:undefined) 5
19:49:43 <roconnor> *** Exception: Prelude.undefined
19:49:43 <lambdabot>   Nothing
19:49:47 <roconnor> > dualComposeM (const Nothing:undefined) 5
19:49:48 <lambdabot>   Not in scope: `dualComposeM'
19:49:49 <roconnor> Nothing
19:50:04 <monochrom> deComposeM
19:50:08 <roconnor>  composeM (Reverse (const Nothing:undefined)) 5
19:50:09 <roconnor> Nothing
19:50:27 <roconnor>  composeM (reverse (const Nothing:undefined)) 5
19:50:29 <roconnor> *** Exception: Prelude.undefined
19:52:03 <roconnor> wow
19:52:08 <roconnor> Reverse is a really good name
19:52:27 <smitty1e> OK, I'd like to update the state of one of my monads and re-add, but the updateSM seems mystical.
19:52:29 <jeffwheeler> Is there any guarantee that filterElements and similar functions in the xml package will preserve the order of the elements?
19:52:47 <jeffwheeler> (http://hackage.haskell.org/packages/archive/xml/1.3.4/doc/html/Text-XML-Light-Proc.html#v%3AfilterElements)
19:52:52 <Cale> smitty1e: Perhaps I'll take you through the construction of the state monad step-by-step.
19:52:56 <aavogt> is there a replacement Prelude with things like Monad / Applicative hierarchy fixed, sequence = sequenceA, list functions generalized to Foldable?
19:53:10 <jeffwheeler> Or, does even findChildren guarantee that the order is preserved?
19:53:17 <Cale> smitty1e: But to avoid noise, let's go through it in #haskell-overflow :)
19:53:23 <smitty1e> OK.
19:54:22 <SamB_XP> jeffwheeler: why wouldn't they, given that you can't end up with them returning both an element and any of it's children?
19:54:33 <roconnor> hmm, for some reason this thesaurus lists "reverse" as an antonym for "reverse" ... it is boggling my mind.
19:54:48 <roconnor> I don't know if it is wrong or right
19:54:53 <monochrom> hahahaha
19:54:55 <jeffwheeler> SamB_XP: I would expect that they would, but I didn't want to be surprised later. :)
19:54:56 <SamB_XP> roconnor: I think it's some kind of sick joke
19:55:07 <SamB_XP> either that, or a typo
19:55:18 <SamB_XP> but then, sometimes the LANGUAGE seems like some kind of sick joke ...
19:55:22 <monochrom> I think it's a sick joke. :)
19:55:24 <aavogt> is it a synonym of itself?
19:55:31 <roconnor> which is a better word for unreversing, "forward" or "forwards" ... (or "reverse") ?
19:55:50 <monochrom> Sickly, unreversing is reversing.
19:55:54 <aavogt> @wn synonym
19:55:58 <lambdabot> *** "synonym" wn "WordNet (r) 2.0"
19:55:58 <lambdabot> synonym
19:55:58 <lambdabot>      n : two words that can be interchanged in a context are said to
19:55:58 <lambdabot>          be synonymous relative to that context [syn: {equivalent
19:55:58 <lambdabot>          word}]
19:56:12 <SamB_XP> monochrom: oh, maybe THAT's why they listed reverse as an antonym of reverese?
19:56:25 <roconnor> SamB_XP: exactly why it boggles my mind
19:56:34 <monochrom> Yes, it may be a sick pun, and I'm convinced enough.
19:56:52 <roconnor> forward or forwards?
19:57:04 <monochrom> I haven't seen forwards for a while.
19:57:05 <SamB_XP> So, anyway, reverse sure seems self-dual
19:57:12 <roconnor> or is this a British/American English thing?
19:57:30 <SamB_XP> roconnor: I don't know. I just use whichever!
19:57:51 <SamB_XP> but I think the opposite of forwards is backwards or "in reverse"
19:57:54 <SamB_XP> not "reverse"
19:58:09 <monochrom> That is also right.
19:58:11 <roconnor> hmm
19:58:19 <roconnor> maybe I should rename this InReverse
19:58:21 <monochrom> English is sick.
19:58:32 <roconnor> or perhaps Backwards
19:58:50 <SamB_XP> I recently heard someone propose that english is like that because we got bored with talking right
19:58:51 <mauke> "original" is its own antonym, sort of
19:58:57 <monochrom> forwards-backwards are clear.
19:59:12 <mauke> on the other hand, "flammable" and "inflammable" are synonyms
19:59:20 <monochrom> hahahaha
19:59:21 <SamB_XP> mauke: who knew!
19:59:22 <roconnor> ya
19:59:26 <roconnor> renaming it to Backwards
19:59:59 * SamB_XP loves referencing simpsons episodes he's never even seen
20:00:24 <roconnor> Backwards: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6669#a6669
20:00:31 <Zao> coreverse
20:00:45 <monochrom> I have forgotten all episodes I have seen, and there are only like 5 of them.
20:01:04 <SamB_XP> monochrom: didn't that show run for like 25 years?
20:01:15 <SamB_XP> there had better have been more than 5 episodes
20:01:33 <roconnor> SamB_XP: isn't the series still running?
20:01:37 <aavogt> English is ambiguous
20:01:52 <SamB_XP> I thought they'd ended it finally?
20:01:55 <monochrom> A combination of many factors led to me not watching it almost ever.
20:01:59 <mxc> nope, still running
20:02:08 <SamB_XP> I'm not saying it's not still on
20:02:11 <SamB_XP> of course it's still on
20:02:12 <wmealing_> cmon, there is profit to be made
20:02:12 <mae> aavogt: re haddock builds - do you know if they are retried if they fail at first? ie after deps get updated for instance
20:02:21 <SamB_XP> assuming anything is on -- I can only assume that that's the case
20:02:34 <SamB_XP> since for some reason we can't get anything on TV anymore
20:02:44 <monochrom> One factor is I grew up in Hong Kong. Another factor is I watch little TV. Another factor is I watch Chinese channels more.
20:02:44 <mxc> regarding the Text.JSON library, would there be much speed boost from moving it to bytestrings instead of strings?
20:03:05 <aavogt> mae: sorry, I have no idea whether that is the case.
20:03:07 <SamB_XP> monochrom: I was making a stupid joke
20:03:10 <mxc> monocrhom - its on AXN Asia, i think
20:03:18 <SamB_XP> monochrom: not being amazed at how few you'd seen
20:03:23 <monochrom> I have never heard of AXN Asia.
20:03:40 <SamB_XP> so ... can anyone guess why we don't get TV no more?
20:03:42 <mxc> theyt dont get it in HK?
20:03:44 <aavogt> given the number of failed builds I've come across, I would guess that none are retried
20:03:54 <SamB_XP> except that one channel with the really boring show repeating over and over and over ...
20:03:59 <mxc> i thought it was all over asia, we get in in singapore, they have it in japan, thailand, malaysia, indonesia
20:04:14 <monochrom> I don't know about now. I know there was no Simpsons in HK when I left in 1991 or something.
20:04:36 <monochrom> No one there would care anyway.
20:09:38 <roconnor> @src foldl
20:09:39 <lambdabot> foldl f z []     = z
20:09:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:24:23 <mike-burns> http://www.wsu.edu/~brians/errors/forward.html - in case anyone cares about "forward" vs "forwards".
20:25:46 <roconnor> thx
20:27:14 <mxc> anyone know why (connectTo "localhost" $ PortNumber 7878) would fail with connection refused when telnet localhost 7878 works fine?
20:31:56 <mae> mxc, what makes you think its not working? are you getting an exception or error?
20:32:32 <monochrom> connectTo works fine for me. I just tried using it to talk to an "nc -l -p 9413".
20:33:00 <monochrom> (Should I try 5354 too? :) )
20:33:36 <mxc> weird
20:33:43 <mxc> it works with 127.0.0.1 but not localhost
20:34:06 <mike-burns> What's your /etc/hosts look like?
20:34:47 <monochrom> "connection refused" is very refused. :)
20:34:49 <SamB_XP> or c:\windows\system32\drivers\etc\hosts or wherever the heck they keep the thing
20:35:15 <monochrom> Oh, Windows? My experiment was on Linux, maybe irrelevant to you.
20:35:30 <mxc> MacBookPro-2:Downloads mxcantor$ cat /etc/hosts
20:35:31 <mxc> 127.0.0.1	localhost
20:35:31 <mxc> 255.255.255.255	broadcasthost
20:35:48 <mxc> ok, something was lost in the copy pasting
20:36:00 <SamB_XP> hey, I was just pointing out that not EVERYBODY uses *nix
20:36:05 <mxc> but if the /etc/hosts was off, shoudln't telnet localhost also fail?
20:36:17 <SamB_XP> mxc: who knows?
20:36:17 <mxc> samb_xp , ndm would be happy to see that
20:36:19 <monochrom> Thanks SamB_XP.
20:36:41 <SamB_XP> but I hope everybody still has /etc/hosts in one place or another
20:37:32 <monochrom> I even forgot that this Linux session is running inside a VirtualBox inside Windows heh.
20:37:46 <SamB_XP> is it, now?
20:37:48 <SamB_XP> heh
20:38:11 <mike-burns> connectTo does a `getHostByName'. Odd that this doesn't work.
20:38:27 <mxc> oh well
20:38:33 <mxc> i'll look into it more later
20:39:29 <roconnor> ooh tmap :: (Monad m, MonadT t) => (forall x. m x -> m x) -> t m a -> t m a
20:39:31 <monochrom> Does connectTo "127.0.0.1" ... work?
20:39:31 <mike-burns> mxc: Maybe connectTo is trying IPv6 but telnet is using IPv4.
20:39:47 <mxc> monocrhom yeah, that was teh fix
20:39:47 <mike-burns> You don't have ::1 defined in /etc/hosts.
20:39:52 <mxc> mike-burns could be it
20:40:33 <monochrom> Ah my Ubuntu has a "::1 ip6-localhost ip6-loopback" line.
20:40:59 <mxc> actually, i do have it defined, i jsut left it out of the copy/paste since i didn't think it was relevant...  my bad
20:41:03 <mike-burns> Ah.
20:41:08 <mxc> ::1 is defined as localhost
20:41:15 <mike-burns> Well I'm out of ideas.
20:41:36 <monochrom> Two localhost lines may be confusing. Unless it's what Apple put there.
20:42:04 <mike-burns> My FreeBSD has separate lines for ::1 and 127.0.0.1 .
20:44:22 <mxc> its exactly what apple put there
20:45:15 * SamB_XP didn't know they were still updating Shockwave ...
20:45:46 <mxc> i need to use these java APIs..  pretty sloppy but the best i've come up with so far is to have a separate java process and to encode data as JSON to go back and forth
20:46:05 <SamB_XP> mxc: well, that's a heck of a lot better than a lot of other options
20:46:09 <SamB_XP> JSON is nice and simple
20:46:19 <mxc> its very simple
20:46:28 <SamB_XP> and it has a nice and short page about it, too!
20:46:39 <SamB_XP> I mean, the homepage is what, two pages long?
20:46:54 <SamB_XP> and the entire specification is on it
20:46:56 <mxc> for what, JSON?
20:46:59 <mxc> yeah
20:46:59 <SamB_XP> yeah
20:47:03 <mxc> its really simple
20:47:25 <monochrom> Nice.
20:47:34 <mxc> although, there isn't really a spec for encoding java objects as JSON and the haskell "spec" is pretty much  just the single implementation
20:48:22 <mxc> it aint pretty but i "implemented" union types in java by having a class were each data constructor in the union is just a field in the class and which ever field isn't null is "the value"
20:48:36 <SamB_XP> mxc: doesn't it beat XML-RPC, though?
20:48:46 <mxc> oh god yes
20:49:14 <mxc> although, if a java programmers (as in myself, 5 years ago) saw my code, he/she would shit themselves
20:49:31 <mae> lol
20:49:34 <mxc> but its short and simple enough that its kind of "ok" to be sloppy
20:49:51 <mae> kill the old "self" that is ridden with far-fetched ideals
20:49:56 <SamB_XP> I've never actually used either of them, but I've used things that encode the same class of data as JSON
20:50:00 <mxc> since all it does is basically marshall/unmarshall objects <-> json and call functions
20:50:50 <SamB_XP> like that encoding bittorent uses for it's .torrent files, or banana
20:51:03 <pragma_> banana?
20:51:17 <pragma_> fo-fana?
20:51:24 <SamB_XP> it's a Twisted thing
20:52:17 <roconnor> Perhaps I should rename "newtype EndoCategory a x = EndoCategory (a x x)" to be simply "newtype W a x = W (a x x)"
20:52:50 <mike-burns> roconnor: How would that help?
20:52:52 <roconnor> similarly rename DualCategory to C
20:53:03 <roconnor> rename Const to K
20:53:13 <roconnor> and TypeCompose to B
20:53:20 <SamB_XP> I think they used to use it with something called Jelly to support something called PB, but I might be a bit confused
20:53:24 <BackInAcTion> where is a haskell programming language book that is online?
20:53:33 <BackInAcTion> I forgot what mine was....
20:53:37 <SamB_XP> @go real world haskell
20:53:38 <lambdabot> http://www.realworldhaskell.org/
20:53:39 <lambdabot> Title: Real World Haskell
20:53:44 <SamB_XP> BackInAcTion: how's that?
20:53:45 <BackInAcTion> there we go
20:54:18 <roconnor> mike-burns: the one letter combinator names are shorter.
20:54:25 <mike-burns> roconnor: Ah, good call.
20:54:33 <roconnor> and can easily be reused
20:54:42 <roconnor> actually the second reason is more important
20:54:43 <SamB_XP> roconnor: don't forget S, K, and I
20:55:29 <monochrom> I, Robot  <duck>
20:56:04 <SamB_XP> monochrom: what about S and K?
20:56:15 <roconnor> SamB_XP: I said K, I is clear ... and um type S f g x = B (B (B W) C) (B B)
20:56:33 <roconnor> SamB_XP: I said K, I is clear ... and um type S = B (B (B W) C) (B B)
20:56:43 <roconnor> does type work on higher kinds ?
20:57:02 <SamB_XP> roconnor: it's not polymorphic in kinds
20:57:22 <roconnor> aw
20:57:26 <SamB_XP> but having no "a" after isn't going to kill you if the kind is obvious
20:57:29 <monochrom> An I for An I
20:57:41 <roconnor> SamB_XP: that probably goes for data types too I guess
20:58:05 <SamB_XP> roconnor: the kind system doesn't have quantification, to my consternation when debugging JHC (and LHC, before they switched to GHC as frontend)
20:58:09 <roconnor> these type combinators are less useful than I thought.
20:58:25 <roconnor> @wn consternation
20:58:28 <lambdabot> *** "consternation" wn "WordNet (r) 2.0"
20:58:28 <lambdabot> consternation
20:58:28 <lambdabot>      n : fear resulting from the awareness of danger [syn: {alarm}, {dismay}]
20:58:41 <SamB_XP> I might be misusing the word slightly
20:58:46 <SamB_XP> though then again maybe not
20:58:49 <BackInAcTion> SamB_XP: perfect!
20:59:15 <roconnor> @kind Indentity
20:59:17 <lambdabot>     Not in scope: type constructor or class `Indentity'
20:59:21 <roconnor> @kind Identity
20:59:22 <lambdabot> * -> *
20:59:26 <roconnor> @kind Identity Maybe
20:59:27 <lambdabot>     `Maybe' is not applied to enough type arguments
20:59:27 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
20:59:39 <roconnor> stupid kind system
20:59:42 <SamB_XP> since I was always afraid that there was something wrong lurking in there still -- some instance where the kind inference was ignoring some pieces of the code
20:59:54 <SamB_XP> which would cause things to come out * when they shouldn't
21:02:27 * BackInAcTion loves Haskell
21:02:35 <BackInAcTion> I'm using XMonad
21:06:32 <roconnor> > 2 + 170 + 6.7 + 170 + 6 + 60 + 2
21:06:34 <lambdabot>   416.7
21:06:51 <dainanaki> hello all, I'm trying to download the Pickler Combinator paper from research.microsoft.com, but nothing loads
21:07:07 <dainanaki> is anyone else having trouble accessing the research.microsoft website?
21:07:32 <SamB_XP> dainanaki: tried citeseer?
21:08:59 <dainanaki> thanks!
21:13:46 <dainanaki> I'm looking to do some independent research into functional programming languages, but I am just a second-year university student. Is there any research out there that I could contribute to even though I'm not too far along yet?
21:14:10 <mmorrow> dainanaki: do things that interest you
21:14:12 <hackagebot> nikepub 1.1 - Command line utility publishes Nike+ runs on blogs and Twitter (UweHoffmann)
21:14:31 <mmorrow> dainanaki: whether that's pre-existing or not i think is secondary
21:14:59 <dainanaki> Yeah, I don't have a good feel for what's out there that I could be interested in.
21:17:08 <mmorrow> well, clearly functional programming languages interest you, so that narrows it down :)
21:17:26 <dainanaki> I'm just interested in functional programming in general, but I'm not really sure where I can go from that.
21:18:02 <mmorrow> are you more interested in their implementation, or some sort of theory that could be behind some given one
21:18:05 <mmorrow> ?
21:18:10 <mmorrow> (or both)
21:19:28 <mmorrow> do you wonder about how garbage collectors work? do you want to derive the typing rules for a hypothetical language for fun? do you want to ..
21:19:35 <dainanaki> Well both. I've been reading the Typeclassopedia and the category theory is pretty interesting, but I'm also interested in how the construction of imperative language compilers differs from functional languages.
21:19:52 <dainanaki> Hey!
21:19:57 <dainanaki> Thanks :)
21:19:58 <mmorrow> :)
21:20:28 <__marius__> if i'm using a 3rd-party library that you give a closure to that in turn dispatches that in the IO monad, is there any way to get access from there to a StateT? (ie. via runStateT (liftIO code) state)) it seems that the type of the dispatched closures precludes this?
21:22:14 <aavogt> collectGarbage? = randomIO >>= free
21:22:32 <dainanaki> How can I get a hold of SPJ's book since his microsoft page is down?
21:22:55 <roconnor> __marius__: types?
21:23:42 <__marius__> roconnor: (concretely, this is Network.Shed.Httpd)
21:23:44 <__marius__> dispatch :: Httpd.Request -> IO Httpd.Response
21:23:50 <aavogt> dainanaki: internet archive?
21:24:25 <__marius__> you call initServer,
21:24:25 <__marius__> initServer :: Int -> (Request -> IO Response) -> IO Server
21:24:38 <dainanaki> aavogt: Yes, but I'm having trouble finding it archived anywhere. I was kinda hoping for a specific link...
21:24:48 * SamB thinks he had a torrent of it
21:25:24 <mmorrow> dainanaki: i have a copy of a smiliar thing by him here http://moonpatio.com/repos/implem_functlang.pdf
21:25:41 <mmorrow> (i think i've got a pdf of that book somewhere...)
21:25:45 <aavogt> this one is up: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
21:26:14 <mmorrow> dainanaki: ah yeah, also i've got this pdf, which is a "manuscript copy" of the book by the same name http://moonpatio.com/repos/Linkers_and_Loaders.pdf
21:27:04 <mmorrow> and this is a masters thesis by someone who explored making yhc's stack-based (bytecode) vm into a register-based one http://moonpatio.com/repos/ans104_project.pdf
21:27:12 <mmorrow> </toc>
21:27:22 * SamB offers dainanaki a copy of this tarball related to SPJ's book
21:28:01 <dainanaki> SamB, does the tarball contain the pdf version?>
21:28:15 <SamB> dainanaki: no, but you might be able to build thatfrom the tarball.
21:28:29 <dainanaki> thanks, I'll check it out
21:29:11 <dainanaki> erm, so how do I compile a book.
21:29:28 <SamB> dainanaki: well, you could look in the README
21:29:59 <dainanaki> ah sorry, I meant that as a joke. The idea of compiling a book struck me as funny.
21:30:18 <aavogt> as if using functional languages wasn't difficult enough, we have to address their implementations: I can haz graph reduction?
21:30:24 <SamB> they do it with anthologies all the time ;-)
21:30:51 <mmorrow> harhar
21:32:36 <dainanaki> I haven't even taken compiler design, so it should be interesting to see if I can piece together a haskell-type thing.
21:35:23 <SamB> #       Imatexplementing Functional Languages                   #
21:35:26 <SamB> ... okay ...
21:35:35 <SamB> that's an interesting comment (from the Makefile)
21:35:59 <dainanaki> so I don't think I even have a Tex environment installed
21:36:01 <dainanaki> whew
21:36:08 <monochrom> Implementing in LaTeX? LaTeX in Implementing?
21:36:54 <pragma_> ImPlEmEnTiNg
21:37:18 <hackagebot> nikepub 1.1.1 - Command line utility publishes Nike+ runs on blogs and Twitter (UweHoffmann)
21:37:45 <monochrom> "Today I lost another 3.4 ounce!"
21:38:51 <roconnor> greenrd says ``libraries (presumably including the Prelude) are now within the purview of the libraries@haskell.org mailing list.''
21:38:55 <roconnor> is this true?
21:39:05 <roconnor> can we change the Prelude however we please?
21:39:21 <kniu> yo, I just got another crazy idea.
21:39:44 <SamB> you know, one of the students at my school told me about how he used the source code of the assembly-language teachers text book that the assembly teacher has publicly-readable in his home directory instead of actually buying the book ;-)
21:39:45 <idnar> haha
21:39:58 <SamB> but I don't think he knew it was the source code, or how to build it
21:40:04 <kniu> You know how we declare constructors along with their datatype?
21:40:18 <kniu> What if we make every new datatype initially empty,
21:40:24 <SamB> or what software it was for
21:40:38 <kniu> and instead, create constructors on the fly for it as we go, GADT style?
21:40:55 <roconnor> kniu: I like my closed data types
21:40:59 <SamB> kniu: what, *open* datatypes?
21:41:14 <SamB> those are really crazy
21:41:14 <troutwine> Purview is a good word.
21:41:35 <kniu> roconnor, SamB, exactly.
21:41:48 <idnar> troutwine: pay-per-view
21:41:56 <SamB> roconnor: apparantly, haskell' isn't allowed to specify Prelude
21:42:06 <monochrom> It would dwarf Knuth's "web", "weave", "tangle".
21:42:11 <SamB> they're only allowed to specify a few things
21:42:14 <SamB> like seq
21:42:16 <SamB> and []
21:42:18 <roconnor> SamB, huh?
21:42:23 <kulakowski> troutwine: Yes.
21:42:31 <SamB> well, that's what I heard ;-)
21:42:32 * roconnor is confused
21:42:40 <roconnor> but that makes no sense
21:42:53 <mmorrow> what does "allowed" mean?
21:42:56 <monochrom> Perhaps it means the Haskell' committee is not allowed to change Prelude.
21:42:57 <SamB> apparantly Prelude is now indeed under the jurisdiction of libraries@
21:42:58 <roconnor> or do you mean they are removing the Prelude from the report?
21:43:05 <kniu> C programmers write #include <stdlib.h> for pretty much every program they write.
21:43:22 <kniu> I don't think it's too much to ask for Haskell programmers to have to write import Prelude if they really need it.
21:43:31 <mmorrow> ah, so implicit {-# LANGUAGE NoImplicitPrelude #-}
21:43:42 <SamB> hmm. Could be!
21:43:51 <SamB> hopefully they do specify LANGUAGE soon ;-)
21:43:55 <idnar> will we have "LANGUAGE NoImplicitNoImplicitPrelude" then?
21:44:07 <mmorrow> oh snap!
21:44:12 <SamB> idnar: LANGUAGE ImplicitPrelude
21:44:13 <aavogt> Explicit
21:44:22 <kniu> that would be crazy, but hilarious if somebody actually implemented that.
21:44:34 <SamB> though it'd make more sense to put in a .cabal file
21:44:35 <idnar> SamB: haha
21:44:45 <SamB> kniu: I think GHC already does implement that
21:44:55 <kniu> LANGUAGE NoImplicitNoImplicitPrelude?
21:45:05 <SamB> no, LANGUAGE ImplicitPrelude
21:45:09 <kniu> oh, that.
21:45:12 <SamB> or NoNoImplicitPrelude
21:45:15 <SamB> not sure which ;-)
21:45:27 <monochrom> {-# LANGUAGE This file contains explicit language. Please view with discretion. #-}
21:45:41 <SamB> lol
21:45:54 <kniu> I don't even know why a prelude is needed.
21:45:55 <idnar> {-# LANGUAGE SEX NUDITY POLITICS VIOLENCE #-}
21:45:57 <SamB> {-# LANGUAGE NC-17 #-}
21:46:03 <pikhq> kniu: Y'know, you don't *have* to write #include <stdlib.h>.
21:46:11 <pikhq> You can just hope everything magically works as ints.
21:46:12 <pikhq> ;)
21:46:14 <kniu> import Data.List; import Control.Monad; should be enough.
21:46:26 <idnar> pikhq: {-# LANGUAGE ImplicitPrototypes #-} :P
21:46:26 <roconnor> Presumably this Prelude thing is documented somewhere, cause it make no sense to me at the moment
21:46:29 <SamB> pikhq: I was going to agree, and say you could just not use anything from it ;-)
21:46:35 <kniu> pikhq, of course.
21:46:42 <roconnor> if the Haskell language changes, the Prelude probably has to change too.
21:46:50 <kniu> why not just use C as a glorified Turing machine?
21:47:02 <SamB> roconnor: oh, yeah, probably
21:47:07 <idnar> I bet the Linux kernel doesn't include stdlib.h very often
21:47:14 <kniu> move your pointers around and manipulate bytes as needed.
21:47:19 <SamB> but I think that's now libraries@'s job
21:47:25 <pikhq> kniu: I'm a Brainfuck programmer.
21:47:33 <pikhq> I do in fact do just that from time to time.
21:47:34 <pikhq> ;p
21:47:42 <SamB> you know how outdated and silly-looking the Haskell 98 libraries look now?
21:47:51 <mmorrow> , [$bf|.+[.+]|] "" {- the one one-liner i know -}
21:47:55 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
21:48:07 <mmorrow> i had `reverse' down at one point, but forgot it
21:48:10 <kniu> the hell just happened?
21:48:15 <mmorrow> brainfuck!
21:48:20 <kulakowski> haha
21:48:24 <idnar> your brain just got fucked
21:48:24 <kniu> My brain does feel fucked.
21:48:28 <pikhq> , [$bf|,[.,]|] [\NUL..]
21:48:29 <lunabot>  luna: parse error on input `NUL..'
21:48:29 <idnar> if you'll excuse my french
21:48:30 <bos31337> the prelude isn't so bad.
21:48:38 <pikhq> , [$bf|,[.,]|] ['\NUL'..]
21:48:39 <pikhq> ?
21:48:40 <lunabot>  ""
21:48:51 <pikhq> Ah, right.
21:48:53 <pikhq> , [$bf|,[.,]|] ['\SOH'..]
21:48:54 <lunabot>  "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN...
21:48:57 <mmorrow> wee
21:49:14 <jeffwheeler> > repeat 100 '+'
21:49:16 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> t'
21:49:23 <jeffwheeler> @type repeat
21:49:24 <lambdabot> forall a. a -> [a]
21:49:25 <pikhq> mmorrow: Reverse? ,[>,]<[.<]
21:49:28 <jeffwheeler> @type replicate
21:49:29 <aavogt> > id ['\SOH' .. ]
21:49:30 <lambdabot> forall a. Int -> a -> [a]
21:49:31 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\E...
21:49:37 <SamB> pikhq: stupid-ass EOF=0 in BF
21:49:37 <jeffwheeler> > replicate 100 '+'
21:49:37 <mmorrow> ooh, that looks possibly familiar
21:49:38 <lambdabot>   "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
21:49:39 <kniu> > repeat '+'
21:49:40 <lambdabot>   "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
21:49:48 <jeffwheeler> Grr, I want exactly one-hundred!
21:49:51 <kniu> @src replicate
21:49:51 <lambdabot> replicate n x = take n (repeat x)
21:49:55 <SamB> should be =-1 like in sane languages ;-P
21:49:59 <kniu> exactly what I expected.
21:50:03 <mmorrow> , [$bf|,[>,]<[.<]|] "asdf\0"
21:50:05 <lunabot>  "fdsa"
21:50:06 <idnar> jeffwheeler: it's over 9000?
21:50:08 <jeffwheeler> Yeah, but lambdabot cuts me off. :(
21:50:14 <mmorrow> pikhq: totally!
21:50:19 <pikhq> SamB: EOF is actually implementation-defined behavior.
21:50:33 <monochrom> -1 on sane platforms
21:50:37 <pikhq> 0, -1, and no-change the three most common behaviors.
21:50:47 <jeffwheeler> , [$bf|++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.|]
21:50:48 <lunabot>  luna: No instance for (GHC.Show.Show
21:50:55 <jeffwheeler> , [$bf|++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.|] ""
21:50:57 <lunabot>  "d"
21:50:59 <kniu> for god's sake, people.
21:50:59 <jeffwheeler> Yay!
21:51:02 <SamB> :t [$bf|,[.,]|]
21:51:03 <lambdabot> parse error on input `,'
21:51:14 <mmorrow> , [$ty| bf |]
21:51:16 <kniu> Use the predefined macro so that you don't need to know the value of EOF.
21:51:17 <lunabot>  QuasiQuoter
21:51:18 <jeffwheeler> It's been ages since I've played with bf.
21:51:18 <pikhq> > ord 'd'
21:51:20 <lambdabot>   100
21:51:25 <mmorrow> , [$ty| [$bf|.+\|] |]
21:51:28 <lunabot>  String -> String
21:51:40 <idnar> kniu: haha
21:51:40 <SamB> aww nuts
21:51:46 <pikhq> , [$bf|+++++[>++<-]>.|] ""
21:51:48 <lunabot>  "\n"
21:51:50 <SamB> , a + c
21:51:53 <lunabot>  a + c
21:51:56 <mmorrow> this bf QQ is in haskell-src-meta btw
21:51:57 <pikhq> Fail.
21:51:59 <SamB> , x * a
21:52:01 <lunabot>  x * a
21:52:28 <mmorrow> http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.4/doc/html/src/Language-Haskell-Meta-QQ-BF.html
21:52:45 * SamB was hoping to be able to pass some Exprs into [$bf|,[.,]|]
21:53:02 <mmorrow> SamB: that should be easy enough to implem
21:53:10 <mmorrow> i've got a SKI one where you can do that
21:53:13 <jeffwheeler> mmorrow: that's amazing
21:53:22 <roconnor> ``
21:53:24 <roconnor> I don't like using RULES for optimizations that actually change the
21:53:24 <pikhq> , [$bf|+++++[>++<-]>[<+++++>-]<.|] ""
21:53:25 <roconnor> computational or space complexity of code.
21:53:26 <SamB> well, you'd have to generalize the type of the produced function
21:53:26 <lunabot>  "2"
21:53:28 <mmorrow> , [$ski|S[(,)][Just][42]|]
21:53:29 <roconnor> says John M
21:53:31 <lunabot>  (42,Just 42)
21:53:32 <pikhq> Anyways.
21:53:32 <roconnor> ya
21:53:36 <SamB> roconnor: crazy shit
21:53:39 <roconnor> I hate map id being changed to id
21:53:47 <roconnor> that totally sucks. :P
21:53:49 <SamB> roconnor: you do ?
21:53:56 <mmorrow> , let x = [0..9] in [$ski|S[(,)][Just][x]|]
21:53:58 <lunabot>  ([0,1,2,3,4,5,6,7,8,9],Just [0,1,2,3,4,5,6,7,8,9])
21:54:03 <roconnor> SamB: not really
21:54:13 <mmorrow> , let x = [0..9] in [$here|[0..9] is $([0..9]) and $x|]
21:54:15 <lunabot>  "[0..9] is [0,1,2,3,4,5,6,7,8,9] and $x"
21:54:20 <mmorrow> , let x = [0..9] in [$here|[0..9] is $([0..9]) and $(x)|]
21:54:23 <lunabot>  "[0..9] is [0,1,2,3,4,5,6,7,8,9] and [0,1,2,3,4,5,6,7,8,9]"
21:54:32 <SamB> roconnor: I personally think essentially that is essential for newtype deriving to be implemented safely
21:54:43 <mmorrow> (that one is the "HsHere" module, and ski is in "SKI")
21:54:44 <roconnor> SamB: yes
21:54:57 <SamB> roconnor: are you subscribed to that bug too?
21:55:17 <roconnor> I'm subscribed to libraries
21:55:45 <SamB> ... is libraries subscribed to that bug?
21:56:03 <roconnor> it seems john mailed libraries
21:56:36 <SamB> I'm talking about the newtype deriving => inconsistant FC(x) axioms bug
21:57:02 <roconnor> I'm talking about proposal #3335: make some Applicative functions into methods
21:57:17 <SamB> http://hackage.haskell.org/trac/ghc/ticket/1496
21:58:21 <roconnor> oh ya
21:59:03 <SamB> Title: Newtypes and type families combine to produce inconsistent FC(X) axiom sets - GHC - Trac
21:59:37 <SamB> hmm. I'm not a very good lambdabot replacement.
21:59:50 <SamB> I forgot the #1496 () part
22:09:57 <jeffwheeler> Is there a data structure like [[a]], but has named columns? Something like a relational database . . .
22:10:00 <monochrom> @botattack
22:10:01 <lunabot>  :)
22:10:01 <lambdabot> Unknown command, try @list
22:10:21 <monochrom> @botsattack
22:10:22 <lunabot>  :)
22:10:22 <lambdabot> Unknown command, try @list
22:12:01 <jeffwheeler> Right now, [[a]] seems to do, but I suspect there's a better structure on Hackage, that supports some work on columns.
22:12:54 <mmorrow> jeffwheeler: Map name [a]
22:13:15 <jeffwheeler> mmorrow: but they make sense as rows, too
22:13:30 <jeffwheeler> mmorrow: wouldn't that make it a pain to capture rows?
22:13:31 <mmorrow> but at any one time, you can only have one
22:13:40 <mmorrow> (with [[a]] and Map foo [a])
22:14:00 <mmorrow> (one representation that is ==> collection of rows, collection of cols)
22:14:24 <mmorrow> too bad computers don't have 2D memory
22:14:24 <jeffwheeler> Yeah, that's why I'm not totally happy with [[a]]. It's not tough to get columns from that, though; it seems more difficult to go the other way.
22:14:29 <mmorrow> (or even 3D!)
22:14:35 <mmorrow> 4D?
22:14:38 <jeffwheeler> Hmm, yeah.
22:14:54 <mmorrow> @transpose
22:14:55 <lambdabot> Unknown command, try @list
22:14:58 <mmorrow> @type transpose
22:15:00 <lambdabot> forall a. [[a]] -> [[a]]
22:16:28 <roconnor> @type traverse
22:16:29 <lambdabot> Not in scope: `traverse'
22:16:30 <mmorrow> i think one thing people are trying to do is to make the grid of cells in FPGAs be 3D instead of 2D
22:16:35 <mmorrow> (that would be cool)
22:16:43 <mmorrow> it's already cool that they're 2D
22:16:55 <mmorrow> (well, 1D in this context would be pretty useless)
22:17:44 <mmorrow> (3D wrt to both logically and spatially)
22:18:06 <mmorrow> hmm, i'm not sure if how those two are interdependent
22:18:26 <mmorrow> like, if they were'nt, you could have (logically) 4D memory
22:18:39 <mmorrow> s/4D/ND/, N > 0
22:19:06 <mmorrow> which would necessarily be spatially ND, N < 4
22:19:12 <jeffwheeler> It seems that most of the packages in the Data category on Hackage belong in the Data Structures package (including my own).
22:19:53 * mmorrow googles FPGA stuff
22:20:57 <mgsloan> that would be ridiculously awesome.
22:21:25 <roconnor> jeffwheeler: map (a,b) c ?
22:21:28 <mgsloan> I think it's been done before with a 3d mesh of very low power chips
22:21:31 <roconnor> Map (a,b) c
22:22:03 <mmorrow> "fft on a 3D FPGA" www.cag.csail.mit.edu/scale/papers/e_basha-sm.pdf
22:22:08 <jeffwheeler> roconnor: I don't think I understand. Have the key include both the row and column?
22:23:22 <roconnor> ya,  but it doesn't seem as nice as I thought
22:23:28 <mmorrow> mgsloan: yeah, that would be pretty cool for sure. the jump from 2D to 3D is the next most-interesting one after 1to2D in general
22:23:37 <mmorrow> (i'd venture to say)
22:24:04 <mmorrow> e.g. two points to a circle to a sphere ..
22:24:15 <jeffwheeler> I guess I'll stick with [[a]] for now; thanks for the help, though, y'all
22:24:20 <roconnor> jeffwheeler: I can't find the functions in data map that I want
22:24:27 <monochrom> Doing spatial 3D is hard. But nice.
22:25:06 <monochrom> So, are we going to ride Moore's law for a few more years because of this? :)
22:25:11 <kulakowski> mmorrow: that intuition can be sort of justified by looking at some topological problems which are trivial in 1/2 dimensions, easy/tractible in 'high' dimensions, and hardest in 3/4 dimensions
22:25:12 <roconnor> jeffwheeler: oh!
22:25:53 <mmorrow> kulakowski: exactly what i was basing that on
22:26:14 <roconnor> jeffwheeler: rows x = mapKeysWith (++) fst (map return x)
22:26:23 <roconnor> jeffwheeler: cols x = mapKeysWith (++) snd (map return x)
22:26:32 * jeffwheeler plays with that
22:27:45 <roconnor> this seems to generalize to higher dimensions easily :)
22:28:09 * jeffwheeler is still working on implementing it, to see it work
22:28:51 <roconnor> jeffwheeler: rows x = mapKeysWith mplus fst (map return x)
22:28:53 <roconnor> :P
22:29:02 <jeffwheeler> roconnor: hehe
22:29:33 <roconnor> btw my map there is Data.Map.map, not Data.List.map
22:29:36 <jeffwheeler> I've got to, uh, well, figure out what the heck mapKeysWith is
22:29:47 <roconnor> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3AmapKeysWith
22:29:50 <idnar> Mapmap
22:29:53 <jeffwheeler> Yeah, I'm reading it now. :)
22:30:51 <mmorrow> kulakowski: (well that's what i was basing the two-three-dim part on, my justification for one-two-dim being the most interesting on account of e.g. 1D is pretty boring, and all the things that change going up one dim i'd say is pretty large relative to other increments of 1)
22:31:26 <roconnor> jeffwheeler: hmm, maybe this is no good.  You lose the labels for the entries of the rows
22:32:20 <mmorrow> heh, has anyone read "lineland"?
22:32:27 <jeffwheeler> Maybe I should simply provide a function to transpose and put into a Map, to g et the columns?
22:32:28 <mmorrow> great book
22:32:30 <monochrom> hahahahahaha does it exist?
22:32:50 <mmorrow> oops
22:32:51 <roconnor> jeffwheeler: rows x = mapKeysWith (++) fst (mapWithKey (\k a -> [(k,a)]) x)
22:32:54 <mmorrow> flatland
22:32:56 <mmorrow> :)
22:33:06 <roconnor> er
22:33:07 <mmorrow> monochrom: impossible!
22:33:15 <roconnor> jeffwheeler: rows x = mapKeysWith (++) fst (mapWithKey (\k a -> [(snd k,a)]) x)
22:33:24 <monochrom> yeah flatland is cool. just wonder what could possibly be written about lineland, there is too little to talk about.
22:33:46 <lament> monochrom: a very, very thick book called ANKOS
22:34:11 <roconnor> mmorrow: I seem to recall line land is discussed in flatland
22:34:34 <mmorrow> roconnor: yeah, me to iirc (but i don't recall what's said about it)
22:34:38 <roconnor> I remember the king's eyes in lineland
22:34:47 <roconnor> but he could only see a dot
22:35:02 <roconnor> (because this was illustrated)
22:35:42 <monochrom> "ANKOS - Anadolu Üniversite Kütüphaneleri Konsorsiyumu"  is google's first hit for me
22:36:09 <roconnor> http://www.itjungle.com/tfh/tfh030308-story04-fig04.jpg
22:36:10 <monochrom> and the third hit. therefore I didn't read the second hit at all
22:36:17 <roconnor> "My view of lineland"
22:36:44 <kulakowski> mmorrow: There's also things like Poincares conjecture for each dimension. n=1 is trivial, n=2 is classically known, n>3 proved in 1961, and n=3 made perelman famous.
22:37:40 <roconnor> kulakowski: I heard someone from China really solved n=3 using Perelman's "lemma" :)
22:38:24 <mmorrow> kulakowski: hehe, i remember the prof i had for PDE was all upset when perelman's proof came out, he was saying (half seriously) "we work for years on this, and them some guy that lives in his mother's basement goes and proves it!" :)
22:38:54 * jeffwheeler thinks the "Packages" page on Hackage should have a more obvious URI, like http://hackage.haskell.org/packages
22:39:01 <jeffwheeler> I always have to go through the homepage
22:39:05 <kulakowski> roconnor: Yes, but I didn't say Perelman proved it, I said it made him famous, you can't even name any of the (not all Chinese) guys who filled in the gaps.
22:39:06 <monochrom> That's the advantage of living in one's mother's basement.
22:39:23 <roconnor> :)
22:40:03 <monochrom> And remember to eat all the vegetables as mom designates.
22:40:48 <roconnor> @pl rows x = mapKeysWith (++) fst (mapWithKey (\k a -> [(snd k,a)]) x)
22:40:48 <lambdabot> rows = mapKeysWith (++) fst . mapWithKey (flip flip [] . ((:) .) . (,) . snd)
22:41:04 <roconnor> ah flip flip
22:41:14 <roconnor> is there anything you cannot permute?
22:41:14 <jeffwheeler> haha
22:41:25 * kulakowski wonders what they did with the money he refused.
22:41:42 * jeffwheeler has no idea what y'all are talking about
22:41:47 <monochrom> flip flip little elephant who can fly.
22:42:08 <roconnor> @type flip flip []
22:42:09 <lambdabot> forall a c a1. (a -> [a1] -> c) -> a -> c
22:42:29 <jeffwheeler> Why a c a1, not a b c?
22:42:47 <jeffwheeler> Or at least a c b?
22:42:49 <roconnor> @type flip
22:42:51 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
22:42:55 <roconnor> @type []
22:42:56 <lambdabot> forall a. [a]
22:43:05 <monochrom> it's a black art.
22:43:20 <roconnor> one `a' from flip one `a' from `[a]'
22:43:20 <Cale> Hmm... if I have a subset of the plane, I can represent it as a function Point -> Bool. Now let's suppose that I want to be able to decide if two (assumed compact or locally compact) subsets of the plane have any points in common. Is there a nice coalgebraic representation we can use so that deciding if any two of our sets intersect is easy?
22:43:33 <portnov> :t flip flip flip
22:43:34 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
22:43:44 <portnov> >_<
22:44:00 <roconnor> Cale: intersection of compact subsets of the plane is nonconstructive
22:44:17 <Cale> roconnor: Just deciding or constructing?
22:44:31 <roconnor> specifically deciding if the intersection is non-empty
22:44:43 <roconnor> which is a prerequisite to the cosntruction
22:45:02 <Cale> interesting
22:45:26 <roconnor> actually, if you know about where all the non-empty components are, then I think you might be able to construct the intersection
22:45:31 <roconnor> not sure about that
22:46:11 <roconnor> but I think so, because it is where the components become empty where the discontinuity occurs
22:48:09 <roconnor> Cale: compact subsets are not represented by Point -> Bool
22:48:27 <roconnor> there are only two such continuous functions
22:48:37 <Cale> I would have thought there might be some protocol where the two compact sets communicate finite covering sets of discs to each other until a point can be found where they are both True.
22:48:58 <roconnor> Cale: intersecting is probably semi decidable
22:49:00 <roconnor> in the way you suggest
22:49:09 * roconnor thinks
22:49:21 <roconnor> hmm
22:49:32 <roconnor> I guess if they overlap alot  you can tell
22:49:53 <roconnor> if they don't overlap then must be far apart then you can tell.
22:50:06 <roconnor> but if they just touch, you can never tell
22:50:26 <Cale> You mean in a single point?
22:50:51 <roconnor> intuitively I'd say something of measure 0
22:50:55 <Cale> I suppose that is a bit of a problem, points are compact :)
22:51:06 <roconnor> but mixing topology and measure theory probably isn't right.
22:51:23 <mmorrow> there's always the metric topology ;)
22:51:32 <roconnor> but say two square touch on an edge
22:51:40 <Cale> right
22:51:43 <roconnor> and other such things
22:52:04 <Vq^> Cale: use a larger point :o)
22:52:28 <roconnor> Cale: oh, and the constructive union of two point isn't constructively compact either :P
22:52:51 <Cale> The undecidable case is probably where the intersection has empty interior.
22:53:00 <roconnor> Cale: that sounds better
22:53:46 <roconnor> but you can always take the completion of the union of two points to get a compact set. :)
22:53:56 <roconnor> which is what we do,
22:54:00 <roconnor> or at least it is what I do.
22:54:20 <Cale> hmm...
22:54:34 <roconnor> the problem with two points is as follows
22:54:44 <Cale> Is the reason that you can't tell if they were the same point?
22:54:50 <roconnor> consider {a,b} where a \in R and b \in R
22:54:56 <roconnor> suppose {a,b} were compact
22:55:01 <roconnor> then it would be complete
22:55:11 <roconnor> so then max a b would be in {a,b}
22:55:22 <Cale> right
22:55:36 <roconnor> but (max a b) \in {a,b}  means (max a b) = a or (max a b) = b
22:55:46 <roconnor> which is equivalent to (a <= b) or (b <= a)
22:56:01 <roconnor> which is well know to be undecideable, and hence unconstructable
22:56:36 <roconnor> clousre({a,b}) is compact, and (max a b) is a member of that set.
22:58:06 * roconnor goes to sleep
23:00:42 <Pseudonym> Cale, I think it's official.  The associativity of ($) will never be fixed.
23:00:59 <Cale> Pseudonym: eh?
23:01:04 <Cale> Pseudonym: What makes it official?
23:01:08 <Pseudonym> Now that Haskell' is Haskell 2010.
23:01:22 <Cale> Pseudonym: Standards would be the wrong place to change something like that.
23:01:30 <idnar> Pseudonym: isn't it up to libraries@ now? :P
23:01:33 <Cale> Change first, then standardise.
23:01:56 <Pseudonym> Change what?
23:02:00 <Cale> anything.
23:02:01 <Pseudonym> The Prelude?
23:02:03 <Cale> Yeah.
23:02:09 <Pseudonym> That means breaking the standard.
23:02:14 <Pseudonym> Chicken, meet egg.
23:02:29 <Cale> Right, but it doesn't mean you have to drop compatibility with the standard entirely.
23:02:38 <Cale> You just need a different version of the base package.
23:02:46 * SubStack is getting out of bounds errors, pesky things
23:02:49 <Cale> We already have a haskell98 package.
23:03:12 <SubStack> old mailing list postings mention some "-xc" thing to enable stack traces that doesn't seem to exist
23:03:35 <Cale> SubStack: You have to compile with profiling on, and then pass the commandline args +RTS -xc
23:03:41 <SubStack> ah
23:03:46 <Cale> You'll get a cost-centre trace.
23:03:54 <SubStack> it's one of those RTS things, I see
23:03:56 <sjanssen> Cale: we can change some things in the libraries in this way, but not other things
23:04:06 <sjanssen> classes and methods, for example
23:04:29 <Pseudonym> I'll believe it when numeric-prelude is adopted.
23:04:36 <Cale> Well, the main problem is perhaps things like changing the definition of Monad
23:04:54 <Cale> (because then the do-notation translation might have to change)
23:05:12 <jeffwheeler> Like removing fail?
23:05:16 <Cale> jeffwheeler: yeah
23:05:49 <Cale> Though I think perhaps fail is useful enough to be in a separate class.
23:05:59 <Cale> So that would work.
23:06:16 <sjanssen> there are still problems
23:06:24 <Pseudonym> A more relevant example is class (Functor m) => Monad m
23:06:35 <Cale> Well, things will have to be careful about what version of base they use.
23:06:42 <Pseudonym> Which is, I think, more highly desired than moving fail.
23:06:47 <mmorrow> ghc can derive functor now btw
23:06:54 <mmorrow> -XDerivingFunctor
23:06:56 <mmorrow> in head
23:07:01 <Cale> mmorrow: interesting
23:07:04 <sjanssen> the Haskell 98 version of Monad would not be compatible with the new version, meaning that Haskell '98 packages and modern packages would live in entirely different universes
23:07:20 <mmorrow> Cale: yeah, i haven't tried it yet though (i actually just forgot about that until now)
23:07:32 <sjanssen> eg. we'd need mtl-h98 and mtl-new
23:07:39 <Cale> sjanssen: Well, it would be mostly pretty easy to update the cabal and rebuild them.
23:08:25 <mmorrow> i think the sides of this discussion are the people that want to make breaking changes, and the people that don't
23:08:42 <sjanssen> Cale: if we've got to update every package, seems like there's no point in having a compatibility package at all
23:09:39 <Cale> sjanssen: Well, it can be there for people who want to write books and ensure that code included will continue to work according to a particular standard.
23:09:41 <mmorrow> i think if the standard is broken at all, it should be all the way
23:10:04 <Cale> Which is really the main reason for a standard in the first place.
23:10:18 <Pseudonym> Methinks that the "right answer" is to come up with a consortium to propose a standard set of breaking changes.
23:10:21 <Cale> I think we should standardise things which have been implemented, and experiment in the implementation.
23:10:32 <Pseudonym> Just as an experiment to see how broken the batch of changes would make extant code.
23:10:47 <sjanssen> I think the way forward is the opposite of what Cale suggests
23:11:02 <Pseudonym> The problem is, I think there are a couple of language extensions that I'd want before doing that.
23:11:06 <Pseudonym> Like typeclass aliases.
23:11:31 <sjanssen> create a base-next package, which is allowed to contain breaking changes frequently, and discourage applications from depending on it
23:11:44 <sjanssen> then after a couple years, make base-next into the new standard
23:12:15 <mmorrow> why discourage applications from depending on it?
23:12:21 <mmorrow> shouldn't it be the opposite!
23:12:46 <Pseudonym> I guess that applications would naturally be discouraged from depending on it because of the frequent breaking changes.
23:12:55 <Cale> sjanssen: That's... more or less what I'm proposing, apart from base-next <-> base and base <-> previous-standard
23:12:56 <mmorrow> ah, i missed the "frequent" part
23:13:14 <mmorrow> this is why i think that incremental breaking changes are bad
23:13:54 <sjanssen> Cale: I think the difference is important.  We can't afford massive changes to the default setting every GHC release (every year or so)
23:14:19 <Pseudonym> How did other languages handle breaking changes?
23:14:25 <Pseudonym> Perl 4 -> Perl 5, for example.
23:14:53 <Cale> Python has "from future import"
23:15:09 <sjanssen> Python is supporting both their old 2.x series and 3 simultaneously
23:15:21 <mauke> what got broken in perl4 -> perl5?
23:15:58 <sjanssen> this would be feasible if there was one big change, but probably not if the changes were incremental
23:16:17 <Pseudonym> mauke: The package system, mostly, IIRC.
23:16:23 <Pseudonym> Otherwise it was mostly additions.
23:16:31 <mauke> perl4 had packages ... wait, what do you mean?
23:16:42 <Pseudonym> perl 5 didn't have "bless".
23:16:44 <Pseudonym> Or references.
23:16:47 <Pseudonym> Sorry, perl 4.
23:16:52 <mauke> yeah, ok
23:17:01 <Cale> I think that for any standard, it should be possible for about a decade maybe to get a compliant implementation of that standard, but that implementation defaults should change much more quickly (I don't mind having to tweak things a bit every GHC release, though I suspect the Prelude would cool off pretty quickly.)
23:17:02 <mauke> but that didn't break anything, it's just additions
23:17:13 <quicksilver> stuff did break perl4->perl5, though.
23:17:18 <Pseudonym> See, here's the other thing.
23:17:22 <quicksilver> I know, because I had to fix stuff.
23:17:30 <quicksilver> I can't remember the details since it was a few years ago :)
23:17:45 <Pseudonym> If you're going to make a big incompatible change to Haskell, you'd also want to do things like put in a decent module system, no?
23:17:56 <Cale> Maybe. :)
23:18:11 <sjanssen> Cale: how many users does your Haskell code have? :)
23:18:20 <Cale> sjanssen: mostly one :)
23:18:27 <mmorrow> Pseudonym: that would be ideal
23:18:39 <Pseudonym> So it's a bigger job than just rewriting base.
23:19:11 <sjanssen> Cale: xmonad is pretty small, but I'd rather not have the annoyances of fixing and releasing xmonad that often
23:19:29 <Cale> sjanssen: xmonad does releases more often than every 6 months, doesn't it?
23:20:04 <sjanssen> Cale: we're on a slower schedule than that lately (kind of slacking off)
23:20:21 <mauke> ooh, there's a list of differences in perldoc perltrap
23:20:37 <mmorrow> Pseudonym: an ML-like module system, dependent types
23:20:44 <mmorrow> Pseudonym: ooh, and inline Cmm too! ;)
23:20:58 <sjanssen> Cale: it's not just the work of updating to the latest GHC, we also need to support at least one previous version
23:21:13 <Cale> also, I expect that aside from the first wave or two, the changes would start to slow down and "converge", at least until more fundamental discoveries are made :)
23:21:45 <mmorrow> that would be swell if TH was included in the spec as well
23:22:22 <Cale> mmorrow: Things like TH make the notion of a modular standard important :)
23:22:57 <mmorrow> Cale: (TH would be part of the core language is what i'm thinking ;)
23:23:18 <Cale> It would have to be a lot simpler for that to be acceptable.
23:23:46 <hackagebot> nikepub 1.1.2 - Command line utility publishes Nike+ runs on blogs and Twitter (UweHoffmann)
23:24:21 <mmorrow> Cale: it would also need to be able to handle 100% of the standard language, which includes bot modules and itself.
23:24:28 <mmorrow> s/bot/both/
23:24:36 <mmorrow> neither of which it handles
23:25:06 <quicksilver> mmorrow: if TH could handle itself, wouldn't that effectively make it staged?
23:25:11 <quicksilver> which is a more substantial endeavour.
23:25:18 <mmorrow> quicksilver: very substantial for sure
23:25:26 <Cale> Isn't it already staged somewhat?
23:25:33 <mmorrow> quicksilver: (it would need to have an
23:25:38 <mmorrow> , eval "[|42|]"
23:25:39 <kulakowski> I think there'll be a social aspect to this. I think if you say "Here's a shiny new Haskell' but it's not ready yet" a bunch of people will use it anyway and then cry when stuff breaks every 12 hours, even if you tell them it's going to happen.
23:25:41 <lunabot>  <<Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp>>
23:25:46 <mmorrow> )
23:26:00 * quicksilver nods
23:26:15 <Pistahh> hello
23:26:21 <Cale> hello
23:26:40 <Pistahh> I'm (relatively) new to haskell & cabal. Now I want to do a change in a package installed by cabal. Is there a "best practice" how to do that?
23:27:01 <ivanm> what kind of change do you want to do?
23:27:20 <Pistahh> A tiny functionality is missing, I want to add it
23:27:30 <Pseudonym> TH, I think, needs to be general enough for deriving (Show) to be implementable in it.
23:27:45 <ivanm> Pistahh: so you want to add a function to a library?
23:27:49 <Pseudonym> Yes, yes, I know, SYB.
23:27:53 <Pistahh> ivanm: basically yes
23:28:11 <ivanm> Pistahh: you should first contact the maintainer (if you have a code patch, include that)
23:28:18 <mmorrow> Pseudonym: you can implement deriving Show in it now
23:28:42 <mmorrow> Data.Derive does Eq,Ord,Read,Show,Binary,Arbitrary,and like 10 others
23:29:07 <Pistahh> ivanm: the package is atm installed by cabal. So how to do the change locally? remove the package, download source, implement there or is there a "proper" way for changing packages installed by cabal?
23:29:29 <ivanm> Pistahh: you want to make a local change to the installed version?
23:29:56 <Pseudonym> Well, then, that's what needs to be standardised.
23:29:57 <ivanm> and by cabal, do you mean cabal-install (or did you do runhaskell Setup.[l]hs * ?)
23:30:10 <Pseudonym> And base-tng should use that.
23:30:22 <Pistahh> ivanm: first of all I want that the cabal-install-ed package do not clash with my local version
23:30:41 <ivanm> Pistahh: it will clash unless your local version has a different name
23:31:01 <Pistahh> ivanm: so is it better if I just remove the installed version temporarily?
23:31:24 <ivanm> well, cabal-install will most likely remove it when you install your own version
23:31:51 <Pistahh> ivanm: but to do the development & testing do I have to install it every time I change something?
23:32:08 <ivanm> if you want to use it elsewhere, yes
23:32:52 <Pistahh> ivanm: as a first step I just want to do the development, using it elsewhere is a later story
23:33:01 <ivanm> right
23:33:10 <Pistahh> ivanm: I just want to minimize the change->compile->test cycle amap
23:33:26 <ivanm> no real way to minimize it AFAIK
23:33:46 <ivanm> change the code, run "cabal install" in that directory (might need to do cabal clean && cabal install), then use it
23:36:52 <Pistahh> roger, thx
23:41:59 <portnov> @pl \(x,_,_) -> x
23:41:59 <lambdabot> (line 1, column 6):
23:41:59 <lambdabot> unexpected ","
23:41:59 <lambdabot> expecting operator or ")"
23:41:59 <lambdabot> ambiguous use of a non associative operator
23:45:58 <jeffwheeler> You broke lambdabot!
23:46:11 <mauke> pl only knows 2-tuples
23:46:31 <jeffwheeler> it would seem so
23:46:48 <ivanm> and there's also no nice function that I know of equivalent to fst for 3-tuples
23:47:09 <kulakowski> I was going to say, is that mostly because there aren't easy equivalents of fst/snd for n-tuples?
23:47:30 <ivanm> kulakowski: probably because of that, yes
23:52:33 <dainanaki> seems like it would be nice to implement tuple functions using template haskell for variable-sized tuples
23:52:52 <dainanaki> should be fairly simple I would think?
23:52:53 <ivanm> the type sig might be a bit weird...
23:53:01 <ivanm> then again, I"ve never touched TH
23:53:06 <dainanaki> me neither.
23:58:36 <wmealing_> background information: long time vim user.. wondering which IDE is suited for a beginner in haskell, specifically something that will help / assist me in making less newbie mistakes while learning
