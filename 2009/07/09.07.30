00:02:32 <wmealing_> dibblego, good luck
00:15:21 <holmak> For anyone who was around while we interrogated dibblego, it looks like http://www.haskell.org/haskellwiki/OOP_vs_type_classes covers a lot of what he was trying to explain, such as implicitly-passed dictionaries.
00:18:44 <dontbelieve> Does ada have any scripting capabilities?
00:18:59 <kniu> wrong channel?
00:19:00 <rocketman> dontbelieve, consult http://www.amazon.com/Complete-Idiots-Guide-Programming-Basics/dp/0028642864
00:19:03 <copumpkin> dontbelieve: beats me, this isn't #ada
00:19:26 <kniu> I'm getting the following error when using cabal build
00:19:40 <kniu>     Could not find module `Control.OldException':
00:19:41 <kniu>       it is a member of the hidden package `base'
00:19:41 <kniu>       Use -v to see a list of the files searched for.
00:19:46 <dontbelieve> lol sorry about thaqt
00:19:47 <dontbelieve> that
00:19:55 <kniu> how do I make the `base' package NOT hidden?
00:36:26 <hydo> I'm trying to parse json (in this case, twitter messages) and I'm using Text.JSON.  I can get it parsed just fine but my question is: the blob that I get back from decodeStrict looks like "[JSObject (JSONObject {fromJSObject = ..."  Is there an easier way to get down to what I want than writing a set of functions to act as a sieve on each level of this?
00:36:58 <hydo> That seems very... un-haskellish
00:39:53 <voker57_> why, writing a set of functions is very haskellish
00:40:51 <voker57_> but something like XPath would really come in handy here. shouldn't be hard to write...
00:41:54 <copumpkin> xpath combinators!
00:41:59 <hydo> Oh, xpath... yes, that would be nice.  I'm afraid, at least for myself, it would be hard to write at this point.  I'm still getting stuck on things like this :/
00:47:46 <Cynner>  http://www.lostworlds.lv/go.php?1139723800
00:49:14 <copumpkin> is that latvia?
00:49:25 <copumpkin> a latvian spam rpg!
00:49:39 <rocketman> btw
00:49:50 <rocketman> what's the fun/game in these spam web games?
00:50:04 <copumpkin> sneaky ploy to get your users to advertise you
00:50:04 <rocketman> I mean why the hell does anyone "play" them
00:50:14 <rocketman> I know that side of it
00:50:26 <rocketman> but why do these kids actually want to
00:50:39 <copumpkin> well they usually involve "zomg my gf she cheated on me, you need to get 1000 points to see pic 1 and 1000000000000000000000000 points to see the last pic where she's finally naked"
00:51:03 <rocketman> I guess it's different each game? I got the impression with mybrute the more people that 'fight' your playre the stronger you get
00:51:05 <copumpkin> and I guess in the less pornographic ones, there's a scoreboard
00:51:26 <copumpkin> and as soon as someone puts a ranking up, people want to rise to the top of it, even if being at the top just means you spammed the most people
00:52:12 <copumpkin> so I'd reduce it down to those two factors :P horny men and the need to be at the top of any ranking
00:52:28 <Ferdirand> someone should make such a game where you earn points by classifying spam the more accurately possible
00:53:06 <copumpkin> that's sort of like what von ahn's work is
00:53:08 <int-e> in this particular case (an MMORPG, apparently), perhaps you can earn in-game money or items.
00:53:28 <copumpkin> http://www.gwap.com/gwap/ and http://en.wikipedia.org/wiki/Luis_von_Ahn
01:16:17 <ivanm> @. elite yow
01:16:17 <lambdabot> liphE I$ 4 P0Pu|Ari+y (onTE5t! I'/\/\ rephR35|-|iNGLy (AndiD!!
01:17:04 <etpace> Is there a function to change a number to binary, and vice-versa
01:17:17 <ivanm> @hoogle binary
01:17:17 <lambdabot> package binary
01:17:18 <lambdabot> package binary-search
01:17:18 <lambdabot> package binary-strict
01:17:38 <ivanm> hmmm, binary is for binary files...
01:17:43 <wgsilkie> etpace: What do you mean?
01:18:01 <ivanm> wgsilkie: binary representation of numbers I presume
01:18:07 <wgsilkie> A number is a number, regardless of how it is represented.
01:18:13 <ivanm> @hoogle Bit
01:18:13 <lambdabot> Data.Bits bit :: Bits a => Int -> a
01:18:13 <lambdabot> module Data.Bits
01:18:13 <lambdabot> Data.Bits class Num a => Bits a
01:18:17 <ivanm> etpace: ^^
01:18:22 <ivanm> @instances Bits
01:18:23 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
01:18:29 <wgsilkie> etpace: What are you trying to do?
01:18:30 <ivanm> @instances-importing Data.Bits Bits
01:18:31 <lambdabot> Int, Integer
01:18:35 <etpace> For bitshifts I guess -- there's just a solution to josephs problem that I've got no idea how it works
01:18:38 <ivanm> > bits 2 :: Int
01:18:39 <mux> binary is more than just about representing number, it's about binary serialization of arbitrary data structure
01:18:40 <lambdabot>   Not in scope: `bits'
01:18:46 <ivanm> > bit 2 :: Int
01:18:47 <lambdabot>   4
01:18:53 <ivanm> hmmmmm...
01:19:05 <ivanm> > bit 5 :: Int
01:19:07 <mux> @src Get
01:19:07 <lambdabot>   32
01:19:07 <lambdabot> Source not found.
01:19:15 <ivanm> looks like bit x = 2^x
01:20:29 <ivanm> @src bit
01:20:30 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:20:33 <Valodim> ..makes sense, huh
01:20:37 <ivanm> @src Data.Bit.bit
01:20:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
01:21:19 <Valodim> bit = (rotateLeft 1) -- or something like that
01:22:19 <ivanm> > bit (-1) :: Int
01:22:21 <lambdabot>   0
01:23:01 <doserj> > bit 10::Word8
01:23:02 <lambdabot>   0
01:23:21 <Valodim> > bit 5 :: String
01:23:22 <lambdabot>   No instance for (Data.Bits.Bits GHC.Base.String)
01:23:22 <lambdabot>    arising from a use of `...
01:23:30 <Valodim> aw, no 00010000
01:32:11 <Taggnostr> can I do import Foo (bar) and then bar x y = bar x*1000 y or do I have to rename the bar I imported from Foo?
01:32:44 <voker57_> you'll have to call Foo's bar as Foo.bar
01:32:54 <voker57_> to distinguish it from your bar
01:33:04 <Taggnostr> ok, thanks
01:33:08 <voker57_> which will be Main.bar if that's not some module
01:33:39 <Taggnostr> and if I imported it from Foo.Baz, is it enough to do Baz.bar?
01:34:05 <ivanm> no
01:34:19 <ivanm> Taggnostr: you can do this: import Foo.Baz as Baz
01:34:31 <ivanm> though usually the "as _" is only used with qualified imports
01:34:37 <ivanm> which, if you have a name clash, you should probably do
01:34:57 <Taggnostr> right now I have import Foo.Baz (bar)
01:35:23 <ivanm> Taggnostr: if you want your own bar function, then you should use: import qualified Foo.Baz as Baz
01:35:26 <ivanm> and then use Baz.bar
01:35:36 <Taggnostr> ok
01:38:13 <Taggnostr> it works!
01:40:19 <Taggnostr> if I do module MyModule where import Foo (bar), will bar be available when I import MyModule?
01:40:44 <ivanm> no
01:40:53 <ivanm> not unless you explicitly export it
01:41:54 <Taggnostr> ok
01:47:34 <Taggnostr> and can I use a program as a module too?
01:48:29 <Taggnostr> that is, I have a program with a function and some lines of code to read the input from stdin, call that function and print the result
01:48:42 <Taggnostr> now I want to use that function from another program too
01:49:00 <Taggnostr> do I have to move it in a third file and import it in both?
02:03:22 <Taggnostr> if I have a function that accepts only one arg I can do foo . bar . func $ arg, how can I do the same if func accepts two args?
02:04:32 <stanv> how to say that  type `a' must be from `Num' and `Ord' classes.
02:04:33 <stanv> ?
02:04:52 <stanv> (Num a -> Ord a) => .. ?
02:04:57 <mux> (Num a, Ord a) => ...
02:05:05 <stanv> thanks
02:05:24 <mux> you're welcome
02:06:09 <Taggnostr> foo . bar . func arg1 $ arg2 seems to work, is it ok?
02:06:22 <mux> you could also write foo . bar $ func arg1 arg2
02:06:29 <mux> or foo . bar . func $ arg1
02:06:36 <Gilly> Taggnostr: it depends on what you want to do - if bar takes just 1 argument then it's ok
02:06:50 <mux> the latter is slightly more heavier on the eye, but emphasizes function composition slightly more
02:07:13 <Taggnostr> foo . bar $ func arg1 arg2 seems ok
02:07:22 <mux> that's what I do
02:07:50 <Taggnostr> but I'm still getting an error, let me parse it
02:07:56 <Gracenotes> if arg2 is, say, a list, and "func arg1", "bar", and "foo" all modify the list, I'd tend to use the latter
02:08:24 <Gracenotes> I mean, former. with the func arg1 $ arg2. however, if arg2 is a different datatype and func arg1 arg2 is a list, I'd use $ func arg1 arg2
02:08:45 <Gracenotes> ...no real reason, it just seems to make more sense >_>
02:08:54 <Taggnostr> ok, it compiled
02:20:44 <WorkyBob> @hoogle (Monad m) => m a -> (c -> m b) -> c -> m a
02:20:45 <lambdabot> Distribution.PackageDescription withLib :: PackageDescription -> a -> (Library -> IO a) -> IO a
02:36:41 <ivanm> WorkyBob: so, is that the function you were looking for? :p
02:37:02 <WorkyBob> nope
02:37:32 <WorkyBob> I was hoping that there was an operator x <?< f that was equal to const x <=< f
02:37:40 <ivanm> @hoogle (<=<)
02:37:41 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
02:37:57 <ivanm> WorkyBob: just const x <=< f ? :p
02:38:03 <ivanm> define your own operator?
02:38:07 <WorkyBob> yep
02:38:08 <WorkyBob> did do
02:38:13 <WorkyBob> just wondered if it was built in
02:38:23 <WorkyBob> const x =<< f is after all defined
02:38:31 <WorkyBob> (well actually it isn't that way round, but *shrug*)
02:38:57 <WorkyBob> <* is a suitable stand in
02:50:50 <jpcooper> hello
02:51:35 <jpcooper> if a handle is set to use line buffering, then is content sent when a \n is found, or is it sent when something is added to a new line?
02:51:56 <WorkyBob> when a \n is found
02:52:18 <WorkyBob> so you can edit the line in the terminal, until you press enter
02:53:00 <jpcooper> I thought so
02:53:21 <jpcooper> so if I do putStrLn h "hello", then "hello" will be sent immediately?
02:53:27 <WorkyBob> yes
02:53:47 <WorkyBob> but if you putStr "hello" it won't appear until something sends a newline
02:54:35 <jpcooper> right
02:54:37 <jpcooper> thanks
02:58:34 <mornfall> Hm. How would I go about catching exceptions in a StateT ... IO?
02:59:04 <WorkyBob> @hoogle catch
02:59:05 <lambdabot> package catch
02:59:05 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
02:59:05 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
02:59:25 <WorkyBob> like that :)
03:00:00 <mornfall> That's a type error, right?
03:00:08 <WorkyBob> huh?
03:01:13 <mornfall> Couldn't match expected IO a against inferred (StateT ...).
03:01:25 <mornfall> When trying to catch.
03:02:30 <quicksilver> you can liftIO it.
03:02:44 <quicksilver> but you won't be able to do StateT stuff in the internals
03:02:48 <quicksilver> which may be uncomfortable.
03:03:13 <mornfall> Well, the whole point is to let a StateT thing run and catch exceptions from it.
03:03:30 <int-e> but can't be helped, because at the point the exception happens you simply can't access the state (unless you pass it around explicitely).
03:03:37 <mornfall> I mean, I guess I could liftIO it and then re-create the StateT, but that loses the StateT state, right?
03:03:39 <astrobunny> hello
03:03:50 <astrobunny> i'm looking for a bit of help
03:03:53 <mornfall> int-e: I don't care about the handler, I only care about the computation.
03:04:07 <quicksilver> (runStateT foo) `catch` (oops somethiing went wrong)
03:04:08 <mornfall> The handler is just \_ -> return ().
03:04:12 <astrobunny> let a x = do return x + 2
03:04:15 <quicksilver> if you don't need state in the handler.
03:04:16 <astrobunny> how do i use a?
03:04:20 <mornfall> quicksilver: Right, but the outside of catch is a StateT foo.
03:04:41 <soupdragon> astrobunny
03:04:48 <soupdragon> let a x = do return (x + 2)
03:05:07 <int-e> mornfall: if the handler runs, what is the final state? maybe you can get the behaviour you want from a ReaderT (IORef a) instead of StateT a.
03:05:24 <astrobunny> ahhhh
03:05:35 <quicksilver> do s <- get; (a,s') <- runStateT subaction s `catch` (\_ -> return (errorvalue, errorstate))
03:05:37 <astrobunny> let a x = do return x + 2 <- what did this mean?
03:05:39 <quicksilver> mornfall: like that ^^
03:05:43 <soupdragon> that means ERROR
03:05:50 <Cynner>  http://www.lostworlds.lv/go.php?1139723800
03:05:51 <quicksilver> astrobunny: (return x) + 2
03:05:53 <soupdragon> let a x = do ((return x) + 2)
03:05:53 --- mode: ChanServ set +o quicksilver
03:05:54 <astrobunny> but ghci took it quite gracefully
03:06:01 <mornfall> quicksilver: Ahw. But that may actuall work, yes.
03:06:16 <quicksilver> mornfall: I missed the "put s'" at the end
03:06:26 <astrobunny> its even a :: a -> m a
03:06:29 <quicksilver> astrobunny: it looks like, possibly, return doesn't mean what you think it means.
03:06:40 <quicksilver> let a x = x + 2 ?
03:06:48 <astrobunny> yeah. i'm not very clear about return.
03:06:53 <astrobunny> i'm trying to experiment here
03:06:57 <astrobunny> to learn how to use it
03:07:02 <astrobunny> monads and stuff
03:07:03 <int-e> quicksilver: you also need a lift(IO?) there, around the runStateT
03:07:06 <soupdragon> astrobunny, btw, you don't need 'do' at all
03:07:08 <astrobunny> so i'm just exploring a bit
03:07:18 <astrobunny> well, i know i don't need it
03:07:18 <soupdragon> just let a x = return (x + 2)
03:07:18 <doserj> return doesn't, (and variables aren't...)
03:07:24 <mornfall> astrobunny: return is first and foremost not a control flow construct. That's a little confusing at the start.
03:07:31 <quicksilver> int-e: yes, true.
03:07:31 <astrobunny> im just looking for a simple case to use a monad
03:07:40 <astrobunny> ok...
03:07:57 <astrobunny> hmm
03:08:06 <astrobunny> so what is return?
03:08:42 <int-e> @type return
03:08:43 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
03:09:21 <astrobunny> um...
03:09:37 <doserj> 'return x' is the computation that, when run, returns x with no side-effect
03:09:48 <doserj> now, what 'computation' and 'side-effect' means, depends on the monad
03:10:11 <astrobunny> so return takes anything and returns a monad that does a computation on a?
03:11:12 <int-e> it just returns a computation, in a monad. the monad determines the kind of computations that you can do.
03:11:37 <astrobunny> oh...
03:11:52 * astrobunny still wonders how to use it
03:12:07 <doserj> for example, in the Maybe monad, the computations have the side-effect that they can fail to produce a value
03:12:34 <int-e> > return 1 :: Maybe Int
03:12:35 <lambdabot>   Just 1
03:13:06 <doserj> now, when you run this computation (by binding with <- in do-notation), you simple get the 1
03:14:13 <astrobunny> hmmmm
03:14:33 <astrobunny> so return returns a computation in a monad
03:14:43 <mornfall> quicksilver, int-e, thanks, it seems to typecheck now at last : - )
03:14:47 <astrobunny> and i'm still wondering about <-
03:14:55 <astrobunny> i just did x + 2 <- return 5
03:14:58 <astrobunny> and i got 3
03:15:06 <mornfall> That's about right. ;)
03:15:07 * astrobunny is royally confused
03:15:12 <mornfall> That's the "+ pattern".
03:15:15 <mornfall> Avoid it.
03:15:19 <soupdragon> astroobunny :/
03:15:19 <soupdragon> ast
03:15:21 <mornfall> (The left-hand side of <- is a pattern...)
03:15:34 <soupdragon> mornfall the + pattern is fine
03:15:35 <astrobunny> pattern
03:15:58 <astrobunny> oh. you mean i was actually asking what x+2 was to equal 5?
03:15:58 <mornfall> Just x <- somethingThatsNeverNothing
03:16:24 <int-e> > do Just x <- Nothing; return 42
03:16:25 <lambdabot>   Nothing
03:16:27 <int-e> (scnr)
03:16:49 <mornfall> int-e: Well, that's because you never look into x... : - P
03:16:58 <mornfall> > do Just x <- Nothing; return x
03:16:59 <lambdabot>   Nothing
03:17:03 <mornfall> Huh.
03:17:27 <int-e> 'is' is the wrong verb - it should be 'results in' or something like that.
03:17:30 <mornfall> Err.
03:17:30 <mornfall> Maybe's a monad...
03:17:30 <mornfall> That's evil.
03:17:37 <doserj> astrobunny: yes. the pattern x+2 is matched against the value 5, and haskell is clever enough to figure out what x is
03:17:41 <int-e> > do Just x <- Just Nothing; return x -- that's what you meant
03:17:42 <lambdabot>   Nothing
03:17:42 <mornfall> int-e: Yeah, returns.
03:17:48 <int-e> uhm
03:17:54 <mornfall> > do Just x <- return Nothing; return x
03:17:55 <int-e> but we forgot about fail :-(
03:17:56 <lambdabot>   No instance for (GHC.Show.Show (m a))
03:17:56 <lambdabot>    arising from a use of `M4636463143...
03:18:02 <mornfall> Wow!
03:18:14 <mornfall> Lambdabot FAIL.
03:18:26 <int-e> @undo do Just x <- y; return x
03:18:26 <lambdabot> y >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
03:18:41 <astrobunny> eh ok..
03:18:42 <astrobunny> ahhh
03:18:46 <astrobunny> pattern matching!
03:18:51 <astrobunny> so thats what they were talking about
03:18:53 <astrobunny> ahhhhh
03:18:57 * astrobunny stares in wonder
03:19:01 <doserj> astrobunny: this only works because so-called n+k patterns (where k is a constant) are built-in into the language, it won't work with *,/, etc.
03:19:09 <astrobunny> oh
03:19:22 <int-e> mornfall: fwiw, I forgot about the fail as well.
03:19:42 <mornfall> : - )
03:19:55 <astrobunny> ok so how do i use a monad to describe a computation?
03:20:00 <mornfall> That's because we invented a contrived example. They sometimes explode. :)
03:20:20 <doserj> astrobunny: http://www.haskell.org/haskellwiki/Monads_as_computation may help
03:20:25 <astrobunny> ive been reading all these articles and i sorta know whats going on
03:20:30 <astrobunny> but i have no idea how to use it yet
03:20:41 <astrobunny> like, none of them show you how to use it properly
03:20:43 <mornfall> Matter of practice.
03:20:45 <int-e> > do Just x <- Right Nothing; return x :: Either String Int
03:20:46 <lambdabot>   Left "Pattern match failure in do expression at <interactive>:1:124-127"
03:20:48 <astrobunny> i just get these errors in ghci
03:21:01 <int-e> @src Either fail
03:21:02 <lambdabot> fail msg      = Left (strMsg msg)
03:21:08 <Baughn> astrobunny: Oh, and it should be mentioned that n+k patterns are considered Horrible
03:21:14 <int-e> @src String strMsg
03:21:14 <lambdabot> Source not found. It can only be attributed to human error.
03:21:15 <Baughn> astrobunny: They're also deprecated by view patterns.
03:21:20 <astrobunny> oh ok
03:21:36 <astrobunny> well im just trying to write a state monad
03:21:46 <astrobunny> but i have no idea how bind and return work together
03:22:20 <Baughn> astrobunny: Read the typeclassopedia. :)
03:22:24 <mornfall> BOOH!
03:22:51 <Baughn> astrobunny: return actually has nothing to do with monads. Bind does, but it's useful to know the correct hierarchy.
03:22:52 <astrobunny> typeclassopedia o.o
03:23:18 <Baughn> astrobunny: It goes Functor -> Applicative -> Monad. return belongs to Applicative.
03:23:32 <galdor> does somebody know what is the status of the epoll/kqueue work on ghc ?
03:23:44 <astrobunny> i understand bind takes a monad and a function that returns a monad and returns a monad
03:23:50 <galdor> not having these is a total show stopper for server programming
03:23:52 <astrobunny> which is really weird and contrived to me
03:24:17 <astrobunny> its like it takes a computation and another computation and..
03:24:17 <astrobunny> oh
03:24:26 <astrobunny> it links the two computeations together?
03:24:36 <koala_man> yes
03:24:36 <astrobunny> but how...?
03:24:36 <mornfall> astrobunny: Sequences them, even.
03:24:45 <ray> sequence is a better word
03:24:49 <astrobunny> so say i have a computation : x+2
03:24:50 <ray> glorious delayed stereo
03:24:55 <astrobunny> and i want to sequence that to x+3
03:25:01 <Baughn> astrobunny: This is what the typeclassopedia explains. TBH, bind - while useful for the do syntax - is not really a primitive operation.
03:25:01 <astrobunny> how do i do that?
03:25:05 <mornfall> x+2 is not really a computation, now, is it?
03:25:18 <astrobunny> um... its adding x to 2
03:25:22 <Baughn> It is, but that sort of sequencing is just fmap
03:25:23 <astrobunny> so its a computation...right?
03:25:25 <koala_man> astrobunny: \x -> x+2  you mean?
03:25:29 <astrobunny> ah yes
03:25:29 <Baughn> Eg. function concatenation in this case
03:25:32 <astrobunny> \x -> x+2
03:25:36 <Baughn> astrobunny: Also, monads aren't really about computation
03:25:40 <astrobunny> eh?
03:25:49 <Baughn> astrobunny: ..they aren't really about /anything/.
03:25:50 <doserj> astrobunny: in the state monad, the computations are functions that depend on state, an can change the state.
03:25:52 <ray> monads are a structure
03:25:58 <ray> er, monad is a type of structure
03:25:59 <Baughn> astrobunny: A monad is an applicative functor that also has a join operation
03:26:08 <ray> i propose that the plural of monad be stricken from the language
03:26:14 <astrobunny> oh its a functor
03:26:17 <doserj> astrobunny: so the computations have type 's -> (a,s)', where s is the type of state
03:26:17 <astrobunny> so
03:26:25 <Baughn> astrobunny: The way it works is, you first develop a data structure, then notice that it's a functor/applicative/monad, then instance those.
03:26:30 <astrobunny> whats this 'join'
03:26:33 <Baughn> astrobunny: It's just a particular kind of structure.
03:26:36 <ray> :t join
03:26:36 <Baughn> @type join
03:26:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:26:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:26:49 <mornfall> Poor astrobunny.
03:26:51 <astrobunny> Not in scope:
03:26:54 <mornfall> You're overwhelming him.
03:26:56 <astrobunny> hmmm
03:27:02 <ray> it's in Control.Monad
03:27:15 <astrobunny> its ok. i know how the state monad works... well the principle at least
03:27:17 <mornfall> Join is a monadic concat. ;)
03:27:19 <Baughn> astrobunny: I keep telling you, read the typeclassopedia. :)
03:27:22 <astrobunny> like its a function that calls itself
03:27:30 <ray> typeclassopedia is good
03:27:33 <ray> byorgey++
03:27:47 <astrobunny> with a new state argument
03:27:51 <astrobunny> mmm
03:28:01 <mornfall> Baughn: You don't need to know anything about Applicative to use monadic computations sucessfully.
03:28:12 <mornfall> And I suspect that's what astrobunny is trying to do. :)
03:28:23 <Baughn> astrobunny: join :: m (m a) -> m a. join is also the difference between a monad and an applicative; monads have join, applicatives don't.
03:28:50 <Baughn> astrobunny: In other words, there is an operation on nested monads (of the same type) that can un-nest them.
03:28:55 <Baughn> astrobunny: That's it. That's all there is.
03:29:06 <astrobunny> nested monads...
03:29:11 <astrobunny> i'm lost
03:29:15 <astrobunny> so a monad that contains a monad
03:29:22 <Baughn> astrobunny: ..there's also fmap (functor) and pure/return and ap (applicative), all of which work on monads too, but they don't /belong/ to the monad
03:29:34 <Baughn> astrobunny: Right. Consider the list monad, to be simple.
03:29:41 <astrobunny> huh
03:29:41 <Baughn> astrobunny: You have join :: [[a]] -> [a].
03:29:48 <Baughn> Pretty obvious what that is. :)
03:29:51 <astrobunny> Oh
03:29:54 <astrobunny> a list is a monad
03:29:57 <astrobunny> ?
03:30:00 <mornfall> Yes, it is.
03:30:01 <astrobunny> that sounded stupid
03:30:02 <astrobunny> oh
03:30:04 <astrobunny> really?
03:30:06 <astrobunny> :x
03:30:07 <mapreduce> > let f x = f x in f 5
03:30:10 <Baughn> In the IO monad, join :: IO (IO a) -> IO a just executes the outer IO function, then the inner one
03:30:12 <lambdabot>   mueval-core: Prelude.read: no parse
03:30:12 <lambdabot>  mueval: ExitFailure 1
03:30:22 <mapreduce> Wha?
03:30:23 <mornfall> Yes, [a] is an instance of Monad a.
03:30:23 <int-e> > replicateM 3 "01" -- guess what this does ;-)
03:30:24 <lambdabot>   ["000","001","010","011","100","101","110","111"]
03:30:24 <soupdragon> hm IO (IO a)
03:30:25 <Baughn> In the state monad.. well, same thing really
03:30:45 <soupdragon> like    print "X" >> return (print "Y" >> return ())
03:30:57 <astrobunny> whats that?
03:31:03 <soupdragon> joins into  print "X" >> print "Y" >> return () ?
03:31:14 <int-e> soupdragon: yep
03:31:23 <Baughn> astrobunny: And.. I could proceed to explain fmap, return/pure and ap, but it's really better if you read the typeclassopedia; it does a better job.
03:31:35 <Baughn> astrobunny: How about you do that, then come back when you have questions?
03:31:40 <mornfall> Nesting IO is not the most intuitive of things ever.
03:31:53 <ray> IO is not the most intuitive of things
03:32:05 <astrobunny> i don't even know half of the terms you mentioned
03:32:06 <astrobunny> but ok
03:32:10 <astrobunny> i'll read
03:32:18 <mornfall> ray: Well, if you take a ballistic approach to monadic IO, it will mostly work out. ;)
03:32:26 <int-e> mornfall: if you understand that pure functions can return IO actions, you shouldn't have much trouble with that either
03:32:36 <Baughn> astrobunny: That's fine. THey get explained.
03:32:42 <mornfall> I.e. treat do-notation like a simple imperative language may be a good start.
03:33:19 <ray> yeah, but if you want to explain Monad, IO doesn't make for a good example
03:33:24 <mornfall> int-e: Of course, I even use IO foo values.
03:33:25 <int-e> hmm. what could I use instead of "return" there? "evaluate to" is unwieldy.
03:34:02 <mornfall> Well, return is a little overloaded. ;)
03:34:08 <mornfall> But they do return a value.
03:34:31 <mornfall> Especially if you think of pure as a computation in the Identity monad for a while. ;)
03:34:59 <mornfall> Btw., is there a strict identity monad?
03:35:15 <Peaker> ray: why not?
03:35:15 <mornfall> I could use one for testing...
03:35:34 <Peaker> ray: I guess its harder to see the how it works with IO
03:35:36 <ray> peaker: because you can't say very much that's interesting
03:35:45 <int-e> mornfall: no. there's no 'lever' for adding strictness, so to say - strictness is always relative to some other value.
03:35:47 <ray> you basically have to wave your hands and say magic
03:35:52 <ray> which is not good for explaining
03:35:54 <Peaker> ray: :)
03:36:24 <mornfall> int-e: Well, an Identity-like monad where sequencing is strict in the left operand.
03:36:28 <soupdragon> you could make an Identity that seq's in it's bind
03:36:30 <int-e> mornfall: hmm. I guess you could define  x >>= f as x `seq` f x. mmmm.
03:36:58 <mornfall> That may make sense. :)
03:37:36 <mornfall> They don't ship one in mtl tho. I'll have to make my own I guess.
03:37:58 <int-e> mornfall: so I was wrong, but I'm not sure whether that monad would be useful.
03:38:04 <int-e> or how.
03:38:12 <Peaker> int-e: what, a strictness identity monad?
03:38:25 <int-e> Peaker: yes
03:38:46 <Peaker> I dislike seq though, rnf makes more sense IMO
03:39:14 <Peaker> I think WHNF doesn't have any meaningful semantics -- what can you say about a reduction to WHNF of a polymorphic value?
03:39:40 <Peaker> Not much -- as "forcing it 1 level deep" is a pretty arbitrary/meaningless level of deepness
03:40:02 <doserj> well, seq should have the type Seq a => a -> b ->, of course
03:40:05 <soupdragon> it's not _|_
03:40:14 <Peaker> forcing it as much as possible makes more sense IMO (at least if the rnf class instance also applies rnf on the results of functions)
03:40:54 <mornfall> int-e: For QCing things that will eventually run in IO.
03:41:02 <mornfall> I just fell into that trap the other day. :)
03:42:06 <mornfall> "works for QC, diverges for real code... wtf? oh, wtf!"
03:42:14 <int-e> mornfall: of course it's not a monad anymore then, return undefined >> f is not the same as f then.
03:42:31 <mornfall> Hm.
03:42:50 <mornfall> What is what IO does, really?
03:43:02 <mornfall> It does *some* extra forcing, compared to Identity.
03:43:37 <int-e> if all you use is bind and return, there's no extra forcing.
03:43:55 <mornfall> Hmm.
03:44:20 <Peaker> IO doesn't really force computations (except as those are needed for side effects), it just "forces" the side effects, which is really just executing, not forcing
03:46:34 <lilac> astrobunny: this might help you (or maybe not): metafoo.co.uk/practical-monads.txt
03:47:19 <m3ga> what are expressions like '[ 1 .. 10 ]' called?
03:47:44 <koala_man> list comprehension?
03:47:50 <mornfall> Nah.
03:47:56 <ski> enumeration
03:48:00 <mornfall> Better. :)
03:48:18 <doserj> arithmetic sequence
03:48:21 <mornfall> Comprehensions are more like [ x | x <- ... ].
03:48:27 <m3ga> i thought it would be some sort of generator
03:48:30 <mornfall> (I'd say ellipsis for the former, I guess.)
03:48:50 <m3ga> arithmetic sequence is good
03:49:12 <koala_man> ah, doesn't it apply to [1,3..] and such?
03:49:16 <doserj> it's what the report calls it
03:50:31 <quicksilver> Peaker: WHNF has a very meaningful semantics.
03:50:34 <quicksilver> Peaker: just not a very useful one.
03:50:38 <quicksilver> Peaker: (not to split hairs ;)
03:50:56 <quicksilver> Peaker: "seq" checks if something is _|_. That's quite semantically precise. It's just not that useful.
03:50:58 <Peaker> quicksilver: I think its not even meaningful if you don't know the type of value you're WHNF'ing
03:51:42 <Peaker> quicksilver: ah, ok, I see. I think the difference between _|_ and some slightly-more-defined value is not only not useful, but not really as meaningful as its made out to be in textbooks, but maybe I'm just missing some stuff :)
03:51:44 * astrobunny read the monads in C article
03:51:46 * astrobunny slaps heae
03:51:48 * ski doubts whether WHNF is really that sensible for coinductive datatypes
03:51:50 * astrobunny slaps head
03:51:54 <astrobunny> OH
03:51:56 <astrobunny> so monads
03:52:01 <astrobunny> are just structures!
03:52:12 <ski> with a `return'
03:52:15 <ski> and a `join'
03:52:20 <ski> (and of course an `fmap')
03:52:32 <astrobunny> i dont know that much yet
03:52:33 <astrobunny> but
03:52:36 <astrobunny> OH....
03:52:41 <Ycros> astrobunny: there's a monads in C article?
03:52:56 <astrobunny> http://www.reddit.com/r/programming/tb/1761q
03:53:03 <burp> omg
03:53:05 <astrobunny> I SEE
03:53:18 <astrobunny> wait hold on
03:53:18 <astrobunny> but
03:53:20 <astrobunny> why....
03:53:24 <jpcooper> @hoogle m a -> m [a]
03:53:24 <astrobunny> oh wait
03:53:24 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
03:53:24 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
03:53:24 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
03:53:26 <astrobunny> ohhh
03:53:27 <astrobunny> hmmm
03:53:34 <astrobunny> no... wait... that..
03:54:42 <ski> (Baughn : .. i'd say every monad gives rise to a notion of computation :)
03:56:25 <ray> yes, it's just structure
03:56:36 <ray> haskellers are a bit like mathematicians
03:56:42 <ray> finding structure in things
03:57:06 <ray> then studying the structure instead of the things
03:57:58 <astrobunny> ok
03:57:58 <astrobunny> so
03:57:59 <astrobunny> why
03:58:10 <astrobunny> Just 4 >>= return \x Just x doesn't work?
03:58:20 <astrobunny> it goes parse error
03:58:32 <ray> lambda expressions are like \x -> x
03:58:38 <astrobunny> oh woops
03:58:42 <Beelsebob> because that's not the syntax for a lambda expression
03:58:49 <Beelsebob> and you probaly meant \x -> return (Just x)
03:58:55 <Beelsebob> in fact, you probably don't want the Just in there
03:58:59 <Beelsebob> return adds that if you're in the maybe monad
03:59:04 <ray> yeah
03:59:09 <ray> in maybe, return = Just
03:59:12 <lilac> @@ @hoogle @type (listToMaybe .) . drop
03:59:13 <ray> you want one or the other there
03:59:13 <lambdabot>  Prelude (!!) :: [a] -> Int -> a
03:59:13 <lambdabot> Data.List (!!) :: [a] -> Int -> a
03:59:13 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
03:59:14 <Beelsebob> > Just 4 >>= \x -> return x
03:59:15 <lambdabot>   Just 4
03:59:31 <ray> @do Just 4 >>= \x -> return x
03:59:31 <lambdabot> Just 4 >>= \x -> return x not available
03:59:37 <ray> hrm
03:59:52 <Beelsebob> > Just 4 >>= return
03:59:54 <lambdabot>   Just 4
03:59:58 <Beelsebob> > Just 4
03:59:59 <lambdabot>   Just 4
04:00:14 <athos> > do { x <- Just 4; return x }
04:00:15 <jpcooper> @type sequence . repeat
04:00:16 <lambdabot>   Just 4
04:00:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
04:00:28 <jpcooper> @hoogle m a -> m [a]
04:00:28 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
04:00:28 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
04:00:28 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
04:01:19 <astrobunny> I SEE!
04:01:27 <astrobunny> ahhhh
04:01:51 <astrobunny> OH
04:01:58 <astrobunny> so its
04:02:00 <astrobunny> that simple
04:02:09 <Baughn> astrobunny: If you understand Functor, Applicative is easy. If you understand Applicative, Monad is easy.
04:02:09 <astrobunny> its just a computation
04:02:19 <ray> haskell is easy
04:02:20 <astrobunny> whats applicative?
04:02:21 <Peaker> for what monads is (sequence . repeat) well defined?
04:02:28 <ray> :t (<*>)
04:02:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:02:30 <Peaker> One is Identity
04:02:33 <Baughn> astrobunny: ..and you didn't read the typeclassopedia at all, did you? ;_;
04:02:36 <doserj> Baughn: I don't see how Applicative helps in understanding Monad
04:02:48 <Peaker> I mean, for what monads is it not bottom?
04:02:52 <astrobunny> i did. i just started reading it
04:02:53 <ray> you can go from fmap to pure to join
04:02:59 <astrobunny> i havent come across applicative
04:03:06 <ray> ap is an interesting and useful digression
04:03:06 <Baughn> doserj: By insulation. It's easier to understand them a little at a time, and you don't need to understand monad to understand applicative
04:03:14 <Baughn> astrobunny: Then that's fine. You'll get there soon. :)
04:03:55 <ray> or if you know category theory you can skip it all and just talk about the category Hask
04:03:59 <Peaker> astrobunny: Applicative is like a Monad, except it doesn't have bind/join, so you can combine/sequence effects but not ones chosen based on previous monadic results (you have to choose which effects to sequence independently of the monadic action results)
04:04:01 <doserj> Baughn: but what exactly is the "little at a time" that Applicative provides? pure?
04:04:10 <Baughn> doserj: pure and ap
04:04:33 <ray> it's debatable whether ap fits in that logical sequence, though
04:04:50 <Peaker> basically, the difference between Applicative and Monad, as I see it, is the inability to look at monadic results for choosing which effects to sequence.  But you can sequence effects/combine results
04:05:11 <lilac> i think a good progression is Functor, Pointed, Applicative, Monad
04:05:19 <osfameron> Pointed?
04:05:22 <astrobunny> i'm looking at functor
04:05:23 <ray> just like the typeclassopedia, zomg
04:05:28 <lilac> Pointed = Functor + pure/return
04:05:38 <astrobunny> fmap takes a function and a functor and returns a functor
04:05:45 <astrobunny> where do i get the other functor
04:05:48 <Peaker> so if I use IO Monad, I can do:  getLine >>= \line -> if line == "123" then launchMissiles else print "Hello"
04:05:55 <ray> astrobunny: well, if you add some parentheses
04:06:00 <Beelsebob> lilac: Pointed doesn't need functor does it?
04:06:04 <ray> (a -> b) -> (f a -> f b)
04:06:15 <Peaker> If I use the IO Applicative, getLine result cannot be used to choose between launchMissiles and print "Hello"
04:06:23 <ray> so it takes a function from a to b, and returns a function from f a to f b
04:06:36 <astrobunny> huh?
04:06:47 <ray> you know map for lists?
04:06:49 <astrobunny> parentheses?
04:06:51 <astrobunny> yeah
04:07:12 <doserj> Beelsebob: Applicative is the generalization of Functor to functions of multiple arguments. Pointed is the generalization to zero arguments...
04:07:16 <ray> map f takes that function f and turns it from a function on values to a function on lists
04:07:19 <Baughn> > pure id `ap` [1..5]
04:07:20 <lambdabot>   [1,2,3,4,5]
04:07:32 <Peaker> fmap can be seen as a binary function:  (a -> b)   and  f a  ... yielding f b.   Or as a unary function:  (a -> b)  yielding  (f a -> f b)
04:07:34 <ray> fmap is that, but for more than just lists
04:07:41 <astrobunny> yep i know that about map
04:07:42 <astrobunny> but fmap
04:07:48 <Beelsebob> doserj: but does it need to be?
04:07:50 <astrobunny> oh
04:07:51 <Peaker> astrobunny: for lists, fmap = map
04:07:52 <astrobunny> so it takes
04:07:57 <astrobunny> a g and a f
04:07:59 <Baughn> astrobunny: You can reasonably think of fmap as map generalized to arbitrary structures
04:07:59 <lilac> Beelsebob: without Functor, Pointed has no laws, so it's much less meaningful
04:07:59 <astrobunny> and makes a gf?
04:08:10 <Peaker> astrobunny: where do you see a g and f?
04:08:12 <astrobunny> um
04:08:15 <astrobunny> takes a function
04:08:18 <Beelsebob> lilac: ah, yeh
04:08:19 <astrobunny> g
04:08:21 <Baughn> astrobunny: fmap takes a structure, and a function, and applies the function to every element in the structure
04:08:37 <astrobunny> so what is this structure?
04:08:42 <Baughn> Any structure.
04:08:51 <Baughn> Well, any structure with a Functor instance.
04:08:58 <Baughn> astrobunny: On functions, for example, the "elements" it applies the functions to are the return values of the function - so that's function composition, eg. (.).
04:09:11 <Peaker> I wouldn't say it has to be "every element" -- it has to be every element it has that is parametrized by that type
04:10:11 <Peaker> it has change the "a" in "f a" to a "b", whatever that means for that particular type
04:10:17 <jpcooper> how can I make the main thread wait for a kill signal?
04:10:25 <astrobunny> ok
04:10:30 <astrobunny> so where do i get an f a
04:10:35 <Baughn> jpcooper: Define "signal"
04:10:40 <Peaker> astrobunny: [a] is actually syntax sugar for [] a   where f=[]
04:10:43 <Baughn> astrobunny: That depends entirely on the particular type
04:10:48 <jpcooper> well I'm not quite sure how kills work in Linux
04:10:56 <astrobunny> oh
04:10:56 <Peaker> astrobunny: so one f a  would be [Int], where f=[] and a=Int
04:10:58 <astrobunny> i see
04:11:02 <astrobunny> so [] is a functor too
04:11:06 <Peaker> astrobunny: Yep!
04:11:14 <jpcooper> I'm presuming that every programme waits for a kill signal and does certain things on receiving it
04:11:19 <Peaker> astrobunny: Another f a would be IO a  where f = IO
04:11:44 <Peaker> astrobunny: important to notice the "kinds" here
04:11:46 <Baughn> astrobunny: It goes Functor -> Applicative -> Monad. Monad is a subclass of Applicative which is a subclass of Functor, so anything that's a Monad is also a Functor and an Applicative.
04:11:53 <Baughn> astrobunny: *Warning: Haskell does not actually enforce this
04:12:04 <Peaker> astrobunny: do you know what "kinds" are?
04:12:22 <Baughn> jpcooper: Do you mean unix signals?
04:12:30 <astrobunny> kinds?
04:12:32 <astrobunny> uh
04:12:33 <astrobunny> no
04:12:34 <Peaker> astrobunny: Yeah, the types of types
04:12:39 <astrobunny> type classes?
04:12:50 <jpcooper> Baughn, is killing done in another way than unix signals?
04:12:50 <astrobunny> like Int is a Num?
04:13:11 <Baughn> jpcooper: It depends. Umh, maybe if you explain exactly what you are trying to do?
04:13:13 <Peaker> astrobunny: the Kind of simple types like  Int or String  is *.  The kind of [Int] and (Maybe a) is *,  but the kind of [] and Maybe   is (* -> *)  (They are type constructors that can make a simple type, if you give them a simple type)
04:13:19 <Peaker> astrobunny: no, not type classes
04:13:31 <astrobunny> wut... whats a *
04:13:32 <jpcooper> Baughn, I'd like my main thread to wait for a kill signal and do certain things on receiving it
04:13:41 <Peaker> astrobunny: a * is a "simple type". Only "simple types" actually have values
04:13:41 <Baughn> jpcooper: What sends the signal?
04:13:50 <Baughn> jpcooper: Should your thread be doing anything while it's waiting?
04:13:50 <astrobunny> ah.
04:13:53 <jpcooper> kill
04:13:58 <jpcooper> yes it should
04:14:02 <ray> other kinds are type constructors that are applied to other types
04:14:03 <Peaker> astrobunny: [Int] is a "list of int", its an actual type that has values
04:14:19 <Baughn> jpcooper: kill, as in /bin/kill?
04:14:28 <Peaker> astrobunny: on the other hand [] is a "list", until its applied to a particular type (i.e: [] Int) its not yet a simple type, but a "type constructor" of kind (* -> *) and does not have values
04:14:30 <jpcooper> yes
04:14:35 <Baughn> jpcooper: That's a unix signal, then. You just have to install a signal handler.
04:14:46 <astrobunny> type constructor
04:15:04 <jpcooper> Baughn, could you tell me where to start for this?
04:15:21 <Baughn> jpcooper: System.Posix.Signals
04:15:22 <ray> the way typeclasses are related to kinds is that instances of a class have to have a certain kind
04:15:24 <Peaker> astrobunny: Maybe and [] are "type constructors" that have to be applied to a type to become simple types you can use.  You can't have a function  Maybe -> Int, but you can have a function Maybe a -> Int
04:15:24 <jpcooper> thanks
04:15:50 <ray> instances of Functor have to have kind (* -> *), so Maybe or [] or IO can be instances of Functor, but, say, Int can't
04:15:56 <Peaker> astrobunny: (Maybe a) is said to "apply" the Maybe type with the "a" type as an argument
04:16:15 <Peaker> astrobunny: following all this type constructor stuff, and the kind notation of * and (* -> *) ?
04:16:29 <astrobunny> *_*
04:16:46 <Peaker> astrobunny: waiting for ack to continue explaining :)
04:17:09 <astrobunny> um ok. so lemme get this straight. type constructors can instatiate types which in turn can be used to store values?
04:17:40 <Peaker> astrobunny: Roughly yes, but the terminology you used is very non-standard :)
04:17:40 <astrobunny> so a type constructor is really just a generalization of types?
04:17:53 <Peaker> astrobunny: Its like a type-level function
04:17:54 <EvilTerran> it's a parameterised type
04:18:24 <Peaker> astrobunny: you apply it with type arguments, and get a "parametrized type"
04:18:44 <astrobunny> so kinds need to be instatiated from type constructors of kinds like Maybe and []?
04:18:51 <Peaker> astrobunny: That's how we can have just one list type constructor, but still have lists of ints, lists of strings, and any homogenous list type we'd like
04:19:27 <astrobunny> ah yes. like templates
04:19:29 <astrobunny> in c++
04:19:30 <Peaker> astrobunny: kinds don't need to be "instantiated", types need to be applied all their type arguments to result in simple types, because only simple types have values. simple types have kind *
04:19:35 <EvilTerran> astrobunny, er, kinds are to types what types are to values, i wouldn't tend to talk about instantiating kinds
04:20:02 <EvilTerran> astrobunny, yes, parameterised types are remarkably similar to C++ templates, only semantically a lot tidier.
04:20:07 <ray> yeah, like in c++ you can have vector<int> or vector<char> or i don't actually know c++ syntax
04:20:12 <ray> but something like that
04:20:15 <astrobunny> oh so like, 5 is a type of Int and Int is a kind of Maybe?
04:20:24 <Peaker> astrobunny: Int is a kind of *
04:20:30 <ray> * is the kind of Int, rather
04:20:31 <astrobunny> Int is a kind of *
04:20:32 <astrobunny> ahhh
04:20:34 <astrobunny> wha?
04:20:41 <Peaker> astrobunny: 5 :: Int,  Int :: *
04:20:43 <ray> just like Int is the type of 5
04:20:46 <int-e> haha.
04:20:54 <astrobunny> oh Int is a kind of *
04:21:00 <ray> i hope you don't highlight on Int, int-e
04:21:01 <Peaker> astrobunny: Int is not a kind, its a type
04:21:01 <int-e> Int# is a kind of #? :-)
04:21:04 <astrobunny> so what other kinds are there besides * ?
04:21:17 <int-e> ray: I don't.
04:21:30 <ray> well, you can have *, and you can have functions between other kinds
04:21:31 <Peaker> astrobunny: There's *,  (* -> *),  ((* -> *) -> *) or any combination of * and (->) like that you can imagine :)
04:21:39 <astrobunny> ah yes. so 5 is of type Int and Int is of kind *
04:21:41 <astrobunny> got that
04:21:43 <EvilTerran> exactly!
04:21:48 <Peaker> astrobunny: Yep!
04:21:55 <idnar> there's also #, ?, and ??
04:21:59 <int-e> ray: but if I did, I'd only have myself to blame. :-)
04:22:03 <astrobunny> oh so kind is like the top of the food chain?
04:22:03 <ray> true
04:22:07 <Peaker> idnar: please don't add unnecessary non-Haskell98 confusions :)
04:22:08 <int-e> @kind (->)
04:22:09 <lambdabot> ?? -> ? -> *
04:22:15 <astrobunny> uh
04:22:16 <Peaker> you're just confusing
04:22:17 <int-e> idnar: and (#)
04:22:21 <ray> yeah, it's explainable enough using only *
04:22:22 <Peaker> don't mention # and ? and ?? please
04:22:34 <idnar> well, he did ask :P
04:22:46 <idnar> astrobunny: Peaker is right, though, don't worry about those
04:22:46 <astrobunny> oh so there are others
04:22:50 <astrobunny> but i dont need to know about them
04:22:51 <astrobunny> ok
04:22:52 <int-e> right, stick to * and everyone will be happy. Except for dons, dcoutts, and all the other performance hackers I forgot.
04:23:02 <idnar> they're only relevant if you're doing very funky stuff
04:23:05 <ray> you only need to know about * and (->)
04:23:13 <ray> to understand kinds
04:23:41 <astrobunny> hmm im looking at haskell because of its laziness. i wanted to do something that i haven't yet been able to succeed at doing in C without making a mess of things
04:23:47 <Peaker> astrobunny: so, Int :: *, so it can have values.  But   [] :: * -> *       so [] cannot have values.  But   [] Int   takes the [] and gives it the Int type as an argument, so if you had *->* and gave it a *, you get the * result, which is the type [Int]
04:24:17 <astrobunny> ah. i see
04:24:23 <astrobunny> so [] :: * -> *
04:24:27 <astrobunny> that actually made sense
04:24:30 <Twey> Why are the kinds of the arguments to (->) different?
04:24:42 <Twey> Aren't they both *?
04:24:43 <Peaker> astrobunny: So [] is like a compile-time, type-level "function" in the sense you "apply" it to type arguments, to get a parameterized type (Where the type is [] and the parameter is which type is in the list)
04:24:51 <int-e> Twey: because functions can have unboxed arguments and unboxed tuple results.
04:24:56 <astrobunny> yeah. i was wanting to ask that question
04:24:56 <Twey> Aha
04:24:58 <astrobunny> thanks
04:25:15 <astrobunny> so people can metaprogram in haskell?
04:25:16 <Twey> Hm, but they shouldn't be different, should they?
04:25:30 <Twey> Anything that can go out can go in, and vice versa?
04:25:37 <Peaker> astrobunny: This kind system is too limited for real metaprogramming.  There are other ways to metaprogram that are powerful, but don't worry about that yet
04:25:40 <int-e> Twey: you can't pass in unboxed tuples
04:25:42 <astrobunny> ok
04:25:46 <Twey> Really?  Huh.
04:25:58 <Twey> Well, okay.  :)
04:26:10 <Peaker> astrobunny: anyway, so about type-classess...
04:26:13 <int-e> Twey: it's not necessary - you can just as well pass in all the values as separate arguments
04:26:25 <Twey> Aye
04:26:28 <int-e> Twey: and presumably it would make the compiler more complicated
04:26:31 <Twey> Just seems a fairly arbitrary restriction
04:26:35 <Twey> Presumably so
04:26:36 <Peaker> astrobunny: Each instance of a type class is a type of a certain kind.  Each type-class determines the kind of _all_ its instances (which must have the same kind)
04:26:46 <saml> > runQ [| 1 |] >>= print
04:26:47 <lambdabot>   <no location info>: parse error on input `|'
04:26:48 <astrobunny> ah.
04:26:51 <Peaker> astrobunny: So do you know the Eq class, for example?
04:26:54 <astrobunny> um
04:26:55 <astrobunny> no
04:27:02 <saml> how can I make [|  |]  work for template haskell?
04:27:02 <Peaker> astrobunny: Do you know the Num class?
04:27:05 <astrobunny> not in scope
04:27:08 <astrobunny> Num?
04:27:08 <ray> :t (==)
04:27:09 <lambdabot> forall a. (Eq a) => a -> a -> Bool
04:27:09 <astrobunny> yes
04:27:11 <astrobunny> Int
04:27:19 <astrobunny> is part of it
04:27:20 <astrobunny> i think
04:27:27 <Peaker> astrobunny: Lets define the Eq class from scratch then
04:27:27 <ray> all numeric types
04:27:38 <Peaker> astrobunny: class Eq e where (==) :: e -> e -> Bool
04:28:00 <astrobunny> um ok
04:28:00 <astrobunny> so
04:28:01 <Peaker> astrobunny: this means:  the type "e" is an instance of Eq, if there is an implementation of the (==) method, of the type e -> e -> Bool
04:28:08 <Twey> saml: I don't think \b does TH...
04:28:15 <Twey> Security reasons maybe
04:28:31 <saml> Twey, what is \b ?
04:28:34 <int-e> saml: you have to enable the TemplateHaskell language extension
04:28:34 <Peaker> astrobunny: now, as you see, "e" is used as a type of *values* there, right? as both arguments of the (==) function are of type "e", and are values, "e" has values, which means its a simple type, which means e's kind must be *
04:28:34 <saml> bot?
04:28:42 <ray> \ = lambda; b = bot
04:28:49 <int-e> saml: in ghci, you can use  :set -XTemplateHaskell
04:28:53 <Peaker> astrobunny: so    only types of kind *   can be instances of the class Eq
04:28:54 <saml> int-e, i have {-# LANGUAGE TemplateHaskell #-}  and imported the file
04:29:04 <Peaker> astrobunny: Int can be an instance of Eq,  but [] cannot be an instance of Eq
04:29:25 <Peaker> astrobunny: Maybe Int can be an instance of Eq, but Maybe itself has kind * -> * so it cannot be
04:29:37 <Peaker> astrobunny: following?
04:29:38 <saml> int-e, thanks. i think pragma isn't enough
04:29:55 <astrobunny> uhhh
04:29:56 <astrobunny> so
04:29:59 <astrobunny> its like
04:30:09 <astrobunny> um
04:30:28 <astrobunny> how do you get "e" is a type of *values*?
04:30:48 <astrobunny> class Eq e where (==) :: e -> e -> Bool <- just tells me that e must be a Eq
04:31:04 <Peaker> astrobunny: It also tells you "e" is the type of the arguments of (==), right?
04:31:15 <astrobunny> yep
04:31:20 <Peaker> astrobunny: (==) is an ordinary value function, so its arguments are values
04:31:31 <int-e> you could have  class Eq1 eq where (===) :: Eq a => eq a -> eq a -> Bool  and make [] and Maybe instances of that class. (For clarity, eq has kind * -> * here)
04:31:31 <astrobunny> so if it is an argument to a function it must be *?
04:31:32 <Peaker> astrobunny: so the "e"s that appear there must be values
04:31:37 <Peaker> astrobunny: Yep
04:31:42 <astrobunny> ah got it
04:31:59 <astrobunny> ok. so the compiler will infer that Eq must be a * then
04:32:05 <Peaker> astrobunny: exactly
04:32:05 <astrobunny> that means Int falls under that category too
04:32:16 <Peaker> astrobunny: if we look at Functor again:  class Functor f where fmap :: (a -> b) -> f a -> fb
04:32:20 <Peaker> "f b" there
04:32:32 <Peaker> astrobunny: so see how "f" is not used as a type of values there, but rather "f a" is?
04:32:37 <astrobunny> f is'nt a *
04:32:41 <Peaker> astrobunny: exactly
04:32:42 <astrobunny> but a * -> (
04:32:44 <astrobunny> but a * -> *
04:32:46 <Peaker> astrobunny: Yep!
04:32:50 <astrobunny> ahhhhh
04:32:54 <astrobunny> i see!
04:32:59 <Peaker> astrobunny: so the compiler understands that Functor instances must be of kind  * -> *, and not *
04:33:07 <astrobunny> so f i s a type constructor
04:33:19 <Peaker> astrobunny: yep, like [] or Maybe,  and not like Int or [Int] or Maybe a
04:33:31 <astrobunny> and Functor is... the type class?
04:33:37 <Peaker> astrobunny: yes, and the "f" is the instance
04:34:01 <int-e> @kind StateT
04:34:02 <lambdabot> * -> (* -> *) -> * -> *
04:34:04 <astrobunny> ahhhh so how would i go about making an instance of a Functor?
04:34:10 <Peaker> astrobunny: so any instance of functor f, must have this fmap function defined.  For example, [] is an instance of functor, so it must have   fmap :: (a -> b) -> [] a -> [] b  defined
04:34:19 <ray> for example: instance Functor [] where fmap = map
04:34:38 <ray> instance Functor [] where
04:34:41 <ray>   fmap = map
04:34:49 <ray> ^^ that's how you'd write it
04:35:12 <ToRA> any ghci experts know if it's possible to do something like :browse | grep 'Foo' without leaving ghci?
04:35:15 <Peaker> astrobunny: that's how you define [] is an instance of Functor, you show how fmap for f=[] is implemented, and your implementation must have the right type when putting [] in place of "f" there
04:35:16 <ray> of course that one's already in the standard library :)
04:35:50 <Peaker> astrobunny: and indeed, the type of map is (a -> b) -> [a] -> [b]   so it matches:   (a -> b) -> [] a -> [] b  (I put [] instead of f there)
04:35:52 <ray> map :: (a -> b) -> [] a -> [] b -- if you desugar [a] to [] a
04:36:04 <astrobunny> ahhhhh
04:36:26 <osfameron> eeeek!  I haven't got a haskell on this ubuntu laptop - what's the best thing to install these days "the haskell platform" ?
04:36:52 <Ke> APT?
04:36:53 <ray> the platform tarball is probably good, unless you want 6.10.4
04:36:57 * astrobunny wonders if there are any more functors out there
04:36:58 <ray> no apt :)
04:37:05 <ray> unless you want 6.8
04:37:07 <Peaker> astrobunny: also, you should notice that in Haskell:  a -> b -> c    ===   a -> (b -> c)   (the -> operator is "right associative") so you can read the type of fmap as both:  (a -> b) -> f a -> f b   or as  (a -> b) -> (f a -> f b)
04:37:08 <astrobunny> besides []
04:37:13 <ray> astrobunny: tons
04:37:16 <osfameron> yeah, the repo only has 6.8
04:37:27 <ray> i'd go with the platform
04:37:38 <astrobunny> oh yeah... currying
04:37:50 <astrobunny> comes naturally in haskell
04:37:56 <ray> we call applying fmap to a function "lifting" it
04:38:20 <osfameron> there's not a link for ubuntu under http://hackage.haskell.org/platform/ - should I use the Debian one, or the source installer?
04:38:26 <ray> you lift it so that it works on values in the functor
04:38:27 <Peaker> astrobunny: yeah, that allows for 2 philosophical viewpoints on fmap as a function that "lifts" a normal (a->b) function to be (f a -> f b) instead. Or the other outlook, which says that given (a -> b) and (f a), it can make an (f b). But both are really the same thing
04:38:35 <mapreduce> osfameron: I'd guess the Debian one would be ok.
04:38:46 <mapreduce> Why is there not a binary .tgz anyhoo?
04:39:00 <ray> so if you have (*2), the function that multiplies a number by 2
04:39:01 <osfameron> how do you download it?
04:39:05 <ray> :t fmap (*2)
04:39:06 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
04:39:13 <astrobunny> Oh....
04:39:14 <osfameron> the debian link takes me to http://wiki.debian.org/Haskell/Platform
04:39:18 <ray> that works on lists
04:39:22 <ray> it also works on Maybes
04:39:27 <ray> > fmap (*2) Just 4
04:39:36 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
04:39:37 <ray> > fmap (*2) (Just 4)
04:39:38 <lambdabot>    arising from the lite...
04:39:39 * astrobunny is a bit lost
04:39:40 <lambdabot>   Just 8
04:39:46 <mapreduce> osfameron: packages.debian.og ?
04:39:47 <mapreduce> org*
04:39:49 <osfameron> "batteries included... if you can find them, bwahahahahaha"
04:39:51 <ray> > fmap (*2) Nothing
04:39:53 <lambdabot>   Nothing
04:39:54 <astrobunny> ok so lifting... by lifting it means turning a function into a functor function?
04:39:59 <ray> yes
04:40:00 <mapreduce> Old batteries included.
04:40:00 <Peaker> astrobunny: yep
04:40:07 <int-e> ToRA: there is http://www.haskell.org/pipermail/haskell-cafe/2007-September/032260.html but it's quite crazy.
04:40:12 <astrobunny> like a function that operates on functors instead of values
04:40:18 <ray> right
04:40:24 <astrobunny> ok. so how do you apply a functor
04:40:25 <ray> well, values in the functor instead of regular values
04:40:32 <osfameron> mapreduce: any particular page?  it's not linked to from the platform page and I don't know the twisty structure of debian at all...
04:40:41 <mapreduce> osfameron: I'm interested to see how you get on; then I'll do the same on my Asus EEE if it works ok.
04:40:53 <ray> you apply a functor to the type, like a becomes [] a (or [a])
04:40:53 <Peaker> astrobunny: what do you mean "apply a functor"?
04:41:03 <astrobunny> so i'm guessing this functor is a something that is useful somehow right?
04:41:04 <osfameron> mapreduce: nope, I'm already about to give up tbh
04:41:13 <Peaker> astrobunny: you mean take a functor like [] and apply it to Int to make something like [Int] ?
04:41:13 <astrobunny> like []
04:41:23 <ray> yes, a very large number of types are Functors
04:41:26 <osfameron> mapreduce: and I can't even apt-get ghc and then use the *source* tarball, because the source tarball requires 6.10
04:41:30 <ToRA> int-e: ah yeah, I remember that. Thanks
04:41:34 <astrobunny> can i have another example of a functor?
04:41:34 <Peaker> astrobunny: Well, each particular functor instance is useful in its own right, and the Functor type-class is useful in that you can write code that works for all functors
04:41:38 * osfameron cries
04:41:52 <mapreduce> Does the source tarball not include a bootstrap binary of some kind?
04:42:01 <Peaker> astrobunny: [] and Maybe and "ordinary functions of some input type" are all functors
04:42:08 <osfameron> dunno.  The pages says "Note: the source tarball requires that you already have ghc-6.10.3 (or 6.10.4) installed."
04:42:10 <astrobunny> oh Maybe is a functor too
04:42:34 <Peaker> astrobunny: what would the type of fmap for Maybe be?
04:42:34 <astrobunny> i wonder which module Maybe is in
04:42:45 <Peaker> astrobunny: its defined in the Prelude
04:42:52 <astrobunny> (a->b) -> (Maybe a-> Maybe b)
04:42:58 <Peaker> astrobunny: Prelude is the module that's automatically imported
04:43:04 <ray> right
04:43:06 <Peaker> astrobunny: So, how would you implement this fmap for Maybes?
04:43:16 <astrobunny> yeah but :t Maybe gives you Not in scope
04:43:17 <astrobunny> um
04:43:20 * osfameron submits a but on platform bug tracker
04:43:36 <Peaker> astrobunny: :t   is used for values, not types.  Maybe is a type (type constructor, more accurately)
04:43:46 <ray> if you want the kind, use :k
04:43:50 <Peaker> astrobunny: you can use :k Maybe instead
04:43:58 <int-e> Peaker: ask the resident genie ,-)
04:44:08 <astrobunny> hmm...
04:44:09 <Peaker> int-e: what? :)
04:44:12 <astrobunny> how do i implement it
04:44:22 <mapreduce> osfameron: http://packages.debian.org/search?keywords=ghc&searchon=names&suite=unstable&section=all
04:44:27 <Peaker> astrobunny: yeah, try to implement:  fmap :: (a -> b) -> Maybe a -> Maybe b
04:44:29 <int-e> Peaker: I mean @djinn
04:44:37 <mapreduce> I think you'll need to run the same search with 'cabal' too.
04:44:37 <Peaker> int-e: oh, lets not ruin it for astrobunny  :)
04:45:03 <astrobunny> instance Functor Maybe where fmap = \x -> Maybe x?
04:45:09 <astrobunny> i don't really know. just shooting
04:45:34 <ray> well, there's a few different cases you have to consider
04:45:46 <osfameron> mapreduce: that's ghc6 though, rather than the platform?  And (being an ubuntu point-and-drool type) I don't know what to do with that results page ;-P  But ty, I'll have a look later.  First of all I'll whine on bug tracker.
04:45:50 <astrobunny> i would make an x a maybe x
04:46:11 <Peaker> astrobunny: well, do you know how to write functions with pattern matching?
04:46:11 <int-e> astrobunny: what type would fmap have, for Maybe?
04:46:19 <Peaker> int-e: he already answered that
04:46:37 <astrobunny> Peaker: pattern matching...? no
04:46:39 <int-e> Peaker: hmm. but then his attempt makes little sense to me
04:47:04 <astrobunny> well, i did x + 2 <- return 5... that was as far as i got with pattern matching
04:47:05 <Peaker> astrobunny: fmap :: (a -> b) -> Maybe a -> Maybe b      we have 2 args here, so we can write something like:  fmap func maybeArg = ...   right?
04:47:20 <astrobunny> ah yes.
04:47:29 <Peaker> astrobunny: that way, "func" gets the (a -> b)  and maybeArg gets the (Maybe a) value
04:47:43 <ray> now, a Maybe a value is either Just (some value of type a) or it's Nothing
04:47:55 <Peaker> @src Maybe
04:47:56 <lambdabot> data Maybe a = Nothing | Just a
04:48:03 <Peaker> astrobunny: this is how Maybe is defined ^^
04:48:13 <ray> pattern matching means you can define your functions by writing something like fmap func (Just a) = ...
04:48:19 <ray> and also fmap func Nothing = ...
04:48:24 <Peaker> astrobunny: so now:  fmap func maybeArg = case maybeArg of Nothing -> ......   Just x -> ........
04:48:48 <Peaker> astrobunny: and there's syntax sugar so you can instead write:   fmap func Nothing = ........  ; fmap func (Just x) = ..........
04:49:05 <Peaker> astrobunny: following that?
04:49:24 <astrobunny> um... not really.
04:49:27 <astrobunny> lemme think
04:49:29 <astrobunny> dont tell me yet
04:49:49 <Peaker> astrobunny: well, first, do you understand what the possible values of  Maybe Bool  are for example? Can you enumerate them?
04:49:57 <mapreduce> osfameron: I'd love you to get some useful result from that, as I generally point-and-drool too.
04:50:09 <astrobunny> um... Maybe Bool = Nothing | Just Bool?
04:50:12 <mapreduce> My interest in funking with .deb files has expired.
04:50:18 <Peaker> astrobunny: yes, so enumerate all possible values
04:50:24 * osfameron submits http://trac.haskell.org/haskell-platform/ticket/79
04:50:28 <astrobunny> all possible values?
04:50:34 <Peaker> astrobunny: yes, of Maybe Bool
04:50:43 <Peaker> astrobunny: Nothing is one of the values. What other values?
04:50:44 <astrobunny> oh ok
04:50:50 <astrobunny> Nothing | Just True | Just False
04:51:11 <Peaker> astrobunny: yes, these are the values.  Now, when given a (Maybe Bool) you can pattern-match against these values to say how to handle these cases
04:51:39 <Peaker> astrobunny: you can say:   case myMaybeBool of Nothing -> "I got a Nothing!" ; Just _ -> "I got a Just, don't care about the bool"
04:51:57 <Peaker> astrobunny: or you can say:   case myMaybeBool of Nothing -> "Nothing!"  ;  Just True -> "True!" ; Just False -> "False!"
04:52:21 <Peaker> astrobunny: that case statement would convert a value of type Maybe Bool to a String
04:52:39 <astrobunny> gmm
04:52:40 <astrobunny> hmm
04:52:41 <astrobunny> so
04:52:54 <mapreduce> osfameron: Great, now I've got three tracs to follow - work's, Scala's and Haskell's. :)
04:53:08 <astrobunny> fmap f Nothing = "Nothing"?
04:53:14 <Peaker> astrobunny: In general, pattern-matching is used to see which "data constructor" you got in a value.  The "Data constructors" of a type are enumerated with | in the definition of a type.
04:53:17 <astrobunny> no wait that doesnt work
04:53:29 <Peaker> astrobunny: What type should   fmap f Nothing  return?
04:53:34 <astrobunny> um
04:53:36 <astrobunny> Nothing
04:53:40 <astrobunny> eh
04:53:40 <astrobunny> um
04:53:43 <Peaker> astrobunny: Nothing is a value, not a tye
04:53:44 <astrobunny> no it should return
04:54:27 <osfameron> mapreduce: hehe
04:54:29 <astrobunny> Maybe Nothing?
04:54:32 <ray> but you are correct that it should return Nothing
04:54:36 <ray> that's just not a type
04:54:50 <ray> its type is Maybe a
04:54:55 <astrobunny> it should return a Maybe a
04:55:10 <astrobunny> o.o?
04:55:26 <Peaker> astrobunny: what's the type of fmap for f=Maybe again?
04:55:46 <astrobunny> fmap :: (a->b) -> (Maybe a -> Maybe b)
04:55:57 <astrobunny> so fmap f a should return Maybe b
04:56:19 <astrobunny> so fmap f Nothing should return Maybe b
04:57:05 <astrobunny> so fmap f Nothing = Nothing?
04:57:15 <ray> yes
04:57:21 <Peaker> astrobunny: yes. So the "f" in your equation is the (a->b)  and the  "Nothing" there matches the Maybe a.  And the Nothing on the right-side matches the Maybe b
04:57:37 <astrobunny> ahhh ok
04:57:46 <Peaker> astrobunny: so your fmap can now correctly handle the Nothing input -- but there are other possible inputs to handle!
04:57:53 <astrobunny> yeah Just a
04:57:59 <Peaker> astrobunny: Ok, so write its handling too :)
04:58:45 <astrobunny> so fmap f a = Maybe (f a)?
04:58:52 <astrobunny> eh sorry.
04:59:05 <astrobunny> so fmap f a = Just (f a)?
04:59:28 <int-e> that would have type  fmap :: (a -> b) -> a -> Maybe b
04:59:38 <astrobunny> hmm
04:59:48 <ray> yeah, just fix your left hand side
05:00:46 <astrobunny> so fmap f (Just a) = Just (f a)?
05:00:51 <int-e> yes
05:00:56 <astrobunny> i don't know how to constrain a
05:00:57 <astrobunny> oh
05:01:04 <astrobunny> you can do that?
05:01:17 <ray> yes
05:01:23 <int-e> it's the same as  fmap f Nothing = Nothing -- pattern matching
05:02:00 <astrobunny> Oh....
05:02:07 <int-e> or, if you will, fmap f (Nothing) = Nothing
05:02:23 <astrobunny> oh so thats like a type constraint
05:02:28 <astrobunny> like saying a MUST be a Just
05:02:33 <astrobunny> um well
05:03:13 <int-e> not really - (Just a) matches values of type (Maybe x) where x is the type of a.
05:03:18 <lysgaard> I have an application that has some globel values that have to be accesible and changeable everywhere. What is the way to go. State monad or something?
05:03:21 <ray> it doesn't match Nothing
05:03:38 <ray> astrobunny: so those two equations together define fmap for Maybe
05:04:25 <int-e> which is the same as in expressions: if  a :: x  then  Just a :: Maybe x. The restriction is really on the values, not on the type.
05:05:03 <Peaker> astrobunny: since Maybe has 2 data constructors:
05:05:05 <Peaker> @src Maybe
05:05:05 <lambdabot> data Maybe a = Nothing | Just a
05:05:11 <astrobunny> oh.
05:05:14 <Peaker> astrobunny: You need just 2 equations to match all of them and define fmap fully
05:05:24 <astrobunny> so both Nothing and Just 2 make a Maybe
05:05:51 <Peaker> astrobunny: You need both to handle all cases of a (Maybe a), but any particular (Maybe a) value can only be one of them
05:06:08 <Peaker> astrobunny: a value can't be (Just 5) and Nothing, it can be Just x OR Nothing
05:06:16 <astrobunny> OR yes
05:06:25 <astrobunny> right...
05:06:32 <astrobunny> so Just 5 is a maybe, so is Nothing
05:06:42 <Peaker> astrobunny: a function that handles an argument of type (Maybe a) has to handle both Nothing and (Just x) cases to be a "total" function that handles its entire set of possible arguments (called a "domain")
05:08:07 <Peaker> astrobunny: if it handles only the Nothing case and forgets to handle the Just case, then it is a "partial" rather than "total" function, because it neglects to handle some of its "domain". Following that?
05:08:30 <dolio> Why are all those words in quotes? :)
05:08:40 <Peaker> dolio: to emphasize what new words I'm teaching here :)
05:08:41 <astrobunny> ah. so its like an interface basically. if you derive from that interface you need to implement its functions to handle everything that interface expects
05:09:22 <ray> yeah, typeclasses are similar to interfaces
05:09:22 <ski> ty for the little chat
05:09:26 <ski> ECHAN
05:09:38 <ray> the name "class" can be confusing if you come from object oriented languages, because they're not like those kind of classes
05:09:53 <astrobunny> ah
05:09:55 <ray> they are more like interfaces
05:10:00 <astrobunny> ahhhh i see.
05:10:08 <Ferdirand> are we talking about typeclasses here ?
05:10:14 <ray> yes
05:10:14 <Baughn> Interfaces are like simple type-classes, rather. Type-classes can do a lot that interfaces can't.
05:10:21 <ray> yeah, typeclasses are powerful
05:10:24 <astrobunny> oooh...
05:10:44 <Baughn> A simple example would be the Eq instance for lists
05:11:01 <Baughn> It says "instance Eq a => Eq [a]", eg. "If a is an instance of Eq, then so is [a]"
05:11:11 <Baughn> You can't do that with interfaces. :)
05:11:42 <astrobunny> wha?
05:11:45 <ski> (not even with Java 1.5 ?)
05:11:50 <astrobunny> if a is an instance of Eq then so is a?
05:11:57 <Baughn> ski: I don't know
05:12:01 <ray> then so is [a]
05:12:03 <astrobunny> OH.
05:12:11 * ski doesn't recall exactly what kinds of polymorphisms are allowed
05:12:24 <Peaker> astrobunny: don't think about the totality vs partiality thing as an "interface like thing". Think about it as a function that will simply FAIL to return a value for some possible inputs it may have
05:12:30 <Peaker> astrobunny: do you know the function "head", for example?
05:12:31 <Baughn> ski: Even if you can, it'd be easy to pull out something slightly more esoteric instead. ;)
05:12:42 <ray> well, totality of functions is a seperate issue
05:12:43 <astrobunny> yes i know head
05:12:45 <ski> Baughn : probably, yes
05:12:51 <Peaker> astrobunny: Is "head" a total function?
05:13:01 <astrobunny> total?
05:13:06 <astrobunny> you mean
05:13:13 <Baughn> ski: I am absolutely certain that multi-parameter type-classes don't fit java, for one.
05:13:21 <astrobunny> can it take all the params that a list can take?
05:13:24 <Peaker> astrobunny: yeah, as I defined earlier, total means that it has a result for every possible input
05:13:25 <ski> (maybe `<A> class List<A implements Eq> implements Eq {..}' or something .. i'm not sure)
05:13:34 <astrobunny> ah
05:13:35 <astrobunny> i think so
05:13:35 <Baughn> astrobunny: A total function always returns a value for any set of inputs
05:13:52 <Baughn> astrobunny: So what's "head []"?
05:13:52 <Peaker> astrobunny: does head correctly handle all possible lists?
05:14:03 <Peaker> astrobunny: head :: [a] -> a     -- it needs to return an "a" for **any** [a]
05:14:07 <astrobunny> eh it doesn't do head []
05:14:12 <astrobunny> because it doesnt make sense
05:14:14 <ray> right, so it's not total
05:14:16 <ray> it's partial
05:14:23 <astrobunny> right. so its not total
05:14:24 <astrobunny> but
05:14:25 <Peaker> astrobunny: a possible value for [a] is [] -- and head cannot return a value in this case. So "head" is a partial function, not a total one
05:14:28 <astrobunny> [] isn't a *
05:14:33 <ray> [] isn't
05:14:33 <Baughn> astrobunny: It is, actually
05:14:34 <ray> [a] is
05:14:40 <Peaker> astrobunny: head is not [] -> a    its [a] -> a
05:14:41 <astrobunny> eh?
05:14:44 <ray> for any a
05:14:51 <Peaker> Baughn: [] isn't *  its *->*
05:14:57 <Peaker> @kind []
05:14:59 <lambdabot> * -> *
05:15:00 <Baughn> astrobunny: Or.. [] does double duty. It's both the name of the list type constructor (kind * -> *) and the empty list (kind *)
05:15:04 <ray> @kind [a]
05:15:05 <lambdabot> Not in scope: type variable `a'
05:15:09 <astrobunny> so head is a [] a -> a
05:15:11 <Peaker> Baughn: [] the value has a type, not a kind
05:15:17 <Peaker> @kind Nothing
05:15:18 <lambdabot>     Not in scope: type constructor or class `Nothing'
05:15:19 <astrobunny> so its total right? because thats what it is
05:15:32 <Baughn> Peaker: Bit of a shortcut. Any value has a type, which has a kind.
05:15:37 <ray> [] the type and [] the value are different
05:15:45 <ray> [] the value is an empty list
05:15:46 <Peaker> astrobunny:  head is   [] a -> a  yes, but  one possible value of [] a   is [] (note the latter [] is the *value* [], not the type [])
05:15:53 <astrobunny> AH.
05:16:01 <Baughn> Peaker: Oh, and did you get a chance to look at my Time.hs?
05:16:02 <astrobunny> yes yes of course
05:16:15 <Peaker> astrobunny: so there is a possible input that matches the type of ([] a) for head, but that head cannot handle
05:16:15 <astrobunny> so [] :: [a] is like [] Nothing
05:16:32 <Peaker> astrobunny: [] :: [a]   is true,  not sure what you mean by [] Nothing :)
05:16:36 <astrobunny> um
05:16:37 <astrobunny> like
05:16:40 <Peaker> Baughn: not yet
05:16:40 <Baughn> astrobunny: [] :: [a] is like Nothing :: Maybe a
05:16:43 <Peaker> Baughn: will do though!
05:16:43 <astrobunny> [] is a special case of [a]
05:16:56 <Peaker> astrobunny: Yes, [] is a special case of [a]  like Nothing is a special case of Maybe a
05:16:58 <Baughn> RIght
05:17:11 <Peaker> Baughn: I had gmail trouble trying to open my mails, actually
05:17:19 <Peaker> Baughn: firefox or gmail are misbehaving
05:17:40 <astrobunny> mmmm
05:17:40 <ray> if you wanted head to be total, its type couldn't be [a] -> a
05:17:46 <ray> because there's no way to return an a if all you have is []
05:17:51 <Baughn> It could be [] -> Maybe a
05:17:54 <astrobunny> you could return Nothing
05:17:56 <astrobunny> oh yes
05:17:59 <astrobunny> that's right
05:18:01 <Baughn> Or Default a => [a] -> a
05:18:03 <astrobunny> and Maybe a isn't an a
05:18:08 <ray> right
05:18:21 <ray> totalHead :: [a] -> Maybe a
05:18:23 <ray> would work
05:18:40 <Baughn> ANyway, head can't be total because there's no way for it to produce an a given an empty list, when it has absolutely no information about the type a
05:18:52 <Baughn> If it knew that it was an instance of Default, for example, it could.
05:18:54 <Peaker> astrobunny: btw, it took me like 6 months of learning Haskell to finally learn what partial/total functions were, so you're making lots of progress :)
05:19:04 <Baughn> Or Bounded, or.. anything that lets you construct a value given only the type, I guess
05:19:08 <ray> or Monoid
05:19:16 <gwern> @hoogle [[a]] -> [a]
05:19:17 <lambdabot> Prelude concat :: [[a]] -> [a]
05:19:17 <lambdabot> Data.List concat :: [[a]] -> [a]
05:19:17 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
05:19:21 <Baughn> Though "head [] = maxBound" would be a bit silly. :P
05:19:26 <ray> monoidalTotalHead :: Monoid a => [a] -> a
05:19:28 <ray> makes sense
05:19:44 <Peaker> ray: nah, then use a Zero class, not a Monoid class
05:19:57 <ray> maxbound would be silly, mempty would
05:20:04 <ray> not
05:20:17 <Peaker> ray: slightly better, yes, but still kind of arbitrary because of lack of mappend use
05:20:19 <Baughn> Peaker: Monoid /is/ a zero class
05:20:39 <Baughn> Pity it doesn't subclass Zero or some such
05:20:41 <ray> you could argue for splitting them
05:20:43 <Peaker> Baughn: I mean: class Zero z where zero :: z    class Zero m => Monoid m where plus :: m -> m -> m
05:20:52 <Baughn> Peaker: Right, that would make sense
05:20:54 <ray> sometimes i think typeclasses should only have one method each myself
05:20:55 <ray> :)
05:20:59 <Peaker> Baughn: and then use the Zero constraint, not the overly-restrictive Monoid constraint for that function
05:21:00 <ray> if that!
05:21:06 <astrobunny> hehe
05:21:13 <astrobunny> well
05:21:16 <Baughn> ray: Not /always/. The Ord type-class, at least, makes sense.
05:21:18 <astrobunny> ive been reading a lot actually
05:21:22 <ray> baughn: compare
05:21:29 <ray> the other ones are just convenience methods
05:21:35 <astrobunny> but in this conversation cleared up in a few hours what i spent weeks reading about
05:21:36 <Baughn> ray: Sure, but sometimes you want to implement the others explicitly, for performance
05:21:42 <astrobunny> like monads, functors and types
05:21:48 <gwern> hm, how to get the common prefix of the lists in a list...
05:21:48 <astrobunny> thanks a lot.
05:22:01 <ray> that is what #haskell is here for
05:22:04 <Baughn> ray: Same with join and >>= for monads.. though I could do without >>= in the class. ;_;
05:22:09 <astrobunny> i used to read and then die trying in ghci
05:22:11 <Peaker> Baughn: The Ord type-class needs only the (<) method, it can have the others as an "optimization" (silly IMO) with defaults. So you could change the constraint to be one-non-default method per class, as many default methods as you want
05:22:13 <astrobunny> wondering what was going on
05:22:14 <ray> >>= is fine - as a convenience method :)
05:22:28 <ray> join should be the "real" one
05:22:34 <astrobunny> xD
05:22:38 <Baughn> Peaker: IIRC, every Ord function is implemented in terms of the others, including compare
05:22:43 <Peaker> (>>=) may be a good optimization method default
05:22:43 <Baughn> So you can pick whichever you like
05:22:51 <ray> but you should also be able to define them in terms of >>= and =<< and a bunch of other ones
05:22:53 <Peaker> Baughn: yeah, it only takes one Ord function to define everything
05:22:55 <ray> default methods = good
05:23:10 <ray> also fmap should be renamed map and (.) should be a convenience method equivalent to it
05:23:10 <Baughn> Peaker: I like compare, though. It's so obviously the simplest way to do it.
05:23:21 <Peaker> Baughn: I like it because its the least arbitrary choice
05:23:38 <Peaker> Baughn: yay, you used github! :)  Is it because of my suggestion?
05:23:54 <int-e> @type (Control.Category..)
05:23:55 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
05:24:12 <Baughn> Peaker: Nah, it's because I've learned to like it while developing DF.
05:24:35 <Peaker> Baughn: DF?
05:24:41 <Baughn> Peaker: Dwarf Fortress
05:24:51 <Peaker> Baughn: what's that?
05:24:55 <int-e> ray: I disagree for (.), because there are at least two incompatible possible generalizations. I don't like the Control.Category one either, for the same reason.
05:25:05 <Baughn> Peaker: http://tvtropes.org/pmwiki/pmwiki.php/Main/DwarfFortress
05:25:17 <Philippa> Baughn: heh, you bastard!
05:25:23 <Philippa> I'm not sure which is the bigger timewaster...
05:25:59 <int-e> tvtropes is fine UNLESS YOU FOLLOW THE LINKS. don't do that ;-)
05:26:14 <Baughn> ..but.. this looks interesting.
05:26:16 <Baughn> *click*
05:26:20 <ray> dwarf fortress, on the other hand
05:26:31 <EvilTerran> Baughn, you've developed DF? i didn't realise it was open-source
05:26:39 <Baughn> EvilTerran: Only part of it.
05:26:44 <EvilTerran> ahh
05:26:52 <Baughn> Basically the UI
05:27:05 <Peaker> Baughn: you don't like @pl for:
05:27:08 <Baughn> Hm.. no, basically the rendering engine/main loop
05:27:10 <Peaker> @pl  show time = "ITime " ++ show (unITime time)
05:27:10 <lambdabot> show = fix ((("ITime " ++) .) . (. unITime))
05:27:16 <Peaker> oops
05:27:27 <Peaker> show = ("ITime " ++) . show . unITime
05:27:43 <dolio> tv tropes has jumped the shark, apparently.
05:27:48 <Baughn> Peaker: Eh. At the time, I was too busy trying to make it work to make it pretty.
05:27:49 <gwern> Baughn: so it's you we have to blame for DF's UI...
05:27:57 <Baughn> gwern: No, I've been /fixing/ it! ;_;
05:28:01 <Peaker> > 'b':'l':'a':'h':... is probably trivially optimizable from "blah"++
05:28:02 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:28:13 <Baughn> Peaker: The latter is invalid syntax
05:28:42 <gwern> dolio: tv tropes didn't jump the shark. it pickde it up, held a staring contest with its manic dead-black eyes, and analyzed it down to its constituent memes
05:28:52 <Peaker> Baughn: ?
05:29:12 <Baughn> Peaker: It's in a pattern-match. ++ is not actually a constructor, so it isn't valid.
05:29:21 <Baughn> Peaker: If I could use view-patterns, it'd look much nicer.
05:29:21 <Peaker> Baughn: oh, didn't see that :)
05:29:47 <Peaker> Baughn: Strings need pattern-match syntax like they have literal syntax
05:29:52 <Peaker> No need for the whole deal
05:30:01 <Baughn> We /have/ the whole deal, though. :P
05:30:08 <Baughn> They just need to fix the view-pattern warning bug.
05:30:29 <int-e> > let f "foo" = "bar"; f _ = "baz" in mao f ["foo", "fooo"]
05:30:30 <lambdabot>   Not in scope: `mao'
05:30:41 <int-e> > let f "foo" = "bar"; f _ = "baz" in map f ["foo", "fooo"]
05:30:42 <lambdabot>   ["bar","baz"]
05:31:11 <Baughn> int-e: Right, but the syntax I'd need is 'f ("foo " ++ str) = str'
05:31:15 <jpcooper> I'm trying to install fastcgi in cywgin with cabal install. It is not seeing fcgiapp.h or the fcgi library even after giving cabal the --extra-include-dirs and --extra-lib-dirs arguments. What can be done about this?
05:31:34 <Baughn> int-e: ..or 'f (stripPrefix "foo" -> str) = str'
05:31:44 <int-e> Baughn: I know. But that's not literal syntax (it was aimed at Peaker not you)
05:31:45 <gwern> jpcooper: what is to be done? assemble a bourgeois revolutionary elite, and execute the capitalist pigdogs
05:32:06 <int-e> Baughn: probably (stripPrefix "foo" -> Just str)?
05:32:25 <Baughn> int-e: I'm fine with throwing an error if it fails.
05:32:31 <Baughn> > read "x" :: Int
05:32:32 <lambdabot>   * Exception: Prelude.read: no parse
05:32:43 <Baughn> Though perhaps not that error
05:32:55 <jpcooper> gwern, I've tried that
05:34:06 <int-e> Baughn: that would be less useful, I think - how would you match several distinct prefixes then?
05:34:25 <Baughn> int-e: Oh, I just meant for this particular case.
05:35:30 <gwern> jpcooper: really? it may be difficult for the hackage devs to replicate your bug report then
05:37:00 <jpcooper> ./cabal.exe --extra-include-dirs=/usr/include/  --extra-lib-dirs=/usr/lib install fastcgi
05:37:02 <jpcooper> that is what I use
05:37:22 <jpcooper> could it be that it has libfcgi.dll.a and libfcgi.a in /usr/lib and that's not what cabal is looking for?
05:37:30 <jpcooper> I mean, it still doesn't see fcgiapp.h in /usr/include
05:37:56 <gwern> > inits ["foo", "foobar", "fooi"]
05:37:57 <lambdabot>   [[],["foo"],["foo","foobar"],["foo","foobar","fooi"]]
05:38:10 <gwern> > concat $ inits ["foo", "foobar", "fooi"]
05:38:12 <lambdabot>   ["foo","foo","foobar","foo","foobar","fooi"]
05:38:20 <gwern> > nub $ sort $ concat $ inits ["foo", "foobar", "fooi"]
05:38:21 <lambdabot>   ["foo","foobar","fooi"]
05:38:26 <gwern> > head $ nub $ sort $ concat $ inits ["foo", "foobar", "fooi"]
05:38:27 <lambdabot>   "foo"
05:38:40 <Peaker> inits is ~O(concat(xs)^2) right?
05:38:58 <int-e> Peaker: s/concat/length ... yes
05:38:59 <ski> > nub . sort $ ["foo", "foobar", "fooi"]
05:38:59 <Peaker> (unless there's a large variance in the lengths of elements in xs, then its more complicated than that
05:39:00 <lambdabot>   ["foo","foobar","fooi"]
05:39:12 <gwern> > let x =  ["foo", "foobar", "fooi"]  in let i = head $ nub $ sort $ concat $ inits x in map (isPrefixOf i) x
05:39:13 <lambdabot>   [True,True,True]
05:39:16 <Peaker> @type inits
05:39:17 <lambdabot> forall a. [a] -> [[a]]
05:39:24 <Peaker> int-e: oh, silly me :)
05:39:46 <Peaker> yeah, simple O(length ^ 2), brain fart :)
05:39:47 <gwern> hm. I'd @check my common-prefix function except I don't have another implementation to test against :)
05:40:08 <gwern> ski: just nub sort wouldn't always get me the common prefix
05:40:31 <gwern> > nub $ sort ["fooi", "foobar", "fooqux"]
05:40:32 <lambdabot>   ["foobar","fooi","fooqux"]
05:40:37 <ivanm> Peaker: in time or space?
05:40:43 <gwern> obviously "foobar" isn't the common prefix...
05:40:45 <ivanm> in time, wouldn't it be O(n) ?
05:40:55 <ivanm> @src inits
05:40:55 <lambdabot> inits []     =  [[]]
05:40:55 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
05:41:06 <Peaker> @src init
05:41:06 <lambdabot> init [x]    = []
05:41:06 <lambdabot> init (x:xs) = x : init xs
05:41:06 <lambdabot> init []     = undefined
05:41:25 <ivanm> Peaker: inits never uses init
05:41:35 <ski> > nub . sort . concat . inits $ ["fooi", "foobar", "fooqux"]
05:41:37 <lambdabot>   ["foobar","fooi","fooqux"]
05:41:40 <ivanm> it's just either the element is in or it's not
05:41:57 <ivanm> ski: wouldn't sort . nub be slightly more efficient than nub . sort?
05:42:02 <gwern> > let x =  ["foo", "foobar", "fooi"]  in head $ nub $ sort $ concat $ init x
05:42:03 <lambdabot>   'a'
05:42:11 <int-e> > let comm (x:xs) (y:ys) | x == y = x : comm xs ys; comm _ _ = [] in foldl1 comm ["fooi", "foobar", "fooqux"]
05:42:13 <lambdabot>   "foo"
05:42:25 * ski 's just comparing `nub . sort . concat . inits' to `nub . sort'
05:42:31 <gwern> @check \x -> nub $ sort x == sort $ nub x
05:42:32 <ivanm> ahhh
05:42:33 <lambdabot>   Couldn't match expected type `[a]'
05:42:52 <ivanm> heh
05:43:05 <ivanm> what has higher precedence? == or $?
05:43:10 <Peaker> Why is it using [[]] ++   instead of [] :   there?
05:43:12 <int-e> ivanm: ==
05:43:15 <ski> @check \xs -> (nub . sort . concat . inits $ xs) == (nub . sort $ xs :: [Int])
05:43:18 <lambdabot>   "OK, passed 500 tests."
05:43:27 <ivanm> Peaker: adds the empty list to the front
05:43:32 <ivanm> oh, wait, yeah
05:43:34 <ivanm> you're right
05:43:41 <ivanm> Peaker: this doesn't of course mean ghc does that
05:43:53 <Peaker> ivanm: of course, just for readability's sake
05:44:03 <ivanm> *nod*
05:44:10 <Peaker> ivanm: still, inits takes a list of length N, and generates N+1 lists of lengths 0..N  so the sum of the lengths of lists being created is O(N^2) (with no sharing), so it can't do this with less than O(N^2) work
05:44:23 <Peaker> ivanm: unlike tails, which can share the lists
05:44:28 <ivanm> Peaker: :o
05:44:39 <ivanm> it does a single traversal...
05:44:44 <ivanm> how is that O(n^2)?
05:44:54 <Peaker> ivanm: each traversal does an O(N) map
05:45:05 <ivanm> Peaker: ahhh, true, forgot about that bit :s
05:45:08 <ivanm> @src tails
05:45:08 <lambdabot> tails []         = [[]]
05:45:08 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
05:46:18 <ivanm> hmmm... tails uses tail-call recursing ;-)
05:46:24 <ivanm> *recursion
05:46:59 <int-e> ivanm: not really. the tail of the result of tails is produced lazily.
05:47:01 <Peaker> its not a tail-call, because tails xs is not being returned, its cons'd to xxs first
05:47:14 <ivanm> int-e: ssssh, you're ruining my brief attempt at humour!
05:47:15 <ivanm> ;-)
05:47:26 <dolio> tails uses guarded corecursion.
05:47:45 <int-e> ivanm: I believe I made up for it by talking about the tail of tails.
05:48:00 <ivanm> true
05:48:02 <ivanm> :D
05:48:10 <Peaker> btw, what relationship does Reactive have to Comonads?  I see how Reactive is a CoMonad, but that type isn't even exported.  Behavior doesn't seem like a CoMonad, and Event doesn't either
05:48:47 <ivanm> Peaker: so if reactive is a comonad, is coreactive a monad? :p
05:49:01 * ivanm is tired, and when /me is tired he starts making stupid jokes
05:50:27 <Peaker> If types had cotypes that could be an interesting assertion :)
05:50:55 <dolio> Behavior and Event seem unlikely to be comonads.
05:51:24 <dolio> As abstract types, at least.
05:51:36 <ski> (obviously a `cotype' should be the continuation of a type ..)
05:51:42 <Peaker> is there any other sense in which they can be CoMonads?
05:52:05 <Peaker> ski: type error, perhaps you meant:  ski `obviously` ...? :)
05:52:39 <Peaker> The discussion type system at work
05:52:53 <dolio> Well, if they're really implemented as something like 'Time -> a', and you can make up and combine Times, then they are comonads.
05:52:54 <ski> (you may insert irony quotes around "obviously", if you wish)
05:53:02 <Peaker> ski: its backquotes to make it infix
05:53:09 <Peaker> ski: and you are the first argument
05:53:20 <Peaker> ski: obviously is a binary, not unary function :)
05:53:31 <ski> who's having an argument with me ?
05:53:52 <gwern> this whole argument is nonsense upon stilts
05:54:05 <ski> dolio : if there is a "zero" time, no ?
05:54:08 <Peaker> ski: I just mean that for it to be obvious, you need certain knowledge/mindset that you may have, and others not.. "obviousness" is not inherent to things, its a relationship between you and some knowledge
05:54:23 <ski> gwern : ty :)
05:54:48 <Peaker> ski: Oooh,  "I mean the first argument" as in the first parameter to the "obvious" function :)
05:55:04 <dolio> ski: Yeah. I'm not sure how you combine absolute times as (for instance) a monoid, though. 0, max?
05:55:09 <Peaker> Correction: I meant "the first argument"
05:55:46 <Peaker> Arrg.. mixing discussion and type terminology :)
05:55:55 <quicksilver> dolio: minus infinity, max, yes.
05:55:59 <roconnor> persumable absolute times form an affine space rather than a vector space
05:56:03 <roconnor> presumably
05:56:31 <quicksilver> dolio: behaviour is a comonad
05:56:38 <quicksilver> dolio: if you take time to be relative.
05:56:56 <quicksilver> dolio: sorry I htink I might be miles behind you :)
05:57:13 <gwern> > "foo" // "foobar"
05:57:14 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
05:57:21 <gwern> :T (//)
05:57:23 <gwern> :t (//)
05:57:25 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
05:57:28 <gwern> :t (\\)
05:57:30 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
05:57:33 <gwern> bleh
05:57:35 <int-e> > "foo" \\ "foobar"
05:57:36 <lambdabot>   ""
05:57:37 <gwern> > "foo" \\ "foobar"
05:57:39 <lambdabot>   ""
05:57:44 <gwern> > "foobar" \\ "foo"
05:57:46 <lambdabot>   "bar"
05:57:51 <dolio> quicksilver: I haven't thought about it much. extract seems weird to me with relative time, though.
05:57:57 <gwern> why is an array function given a desirable name like // anyway
05:58:10 <int-e> > array (0,3) 42 // [(0,23),(1,666)]
05:58:11 <lambdabot>   No instance for (GHC.Num.Num [(t, e)])
05:58:11 <lambdabot>    arising from the literal `42' at ...
05:58:25 <dolio> quicksilver: Since I kind of expect a Behavior to vary with real program time in some way, so observation would be impure.
05:58:29 <roconnor> I'm not sure I'd call // desireable. :P
05:58:46 <int-e> gwern: it's reminiscent of context substitution in operational semantics.
05:58:48 <gwern> roconnor: there aren't that many operator names
05:59:03 <roconnor> $%@#
05:59:04 <dolio> But that's likely because I haven't thought about it. :)
05:59:15 <quicksilver> dolio: extract gives you the value of the behaviour 'now'
05:59:21 <quicksilver> dolio: thats why you need relative time.
05:59:34 <quicksilver> dolio: however, 'cojoin' is natural enough for relative or absolute time.
05:59:51 <quicksilver> dolio: and cojoin turns out to be essential for efficiency with some implementations.
05:59:53 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7742#a7742 <-- if anyone was wondering what I've been working on
06:00:32 <quicksilver> dolio: I personally don't like the idea of relative time. Its only virtue seems to be making behaviour a comonad :)
06:00:38 <quicksilver> dolio: but cojoin is definitely useful.
06:00:51 <dolio> quicksilver: Yeah, but I mean 'now' has to be the same time always, or else you violate referential transparency, no?
06:01:27 <ski> dolio : how about `(Time,Time -> a)', then ?
06:01:52 <dolio> Yeah, that'd probably work better.
06:01:59 <ski> (aka state-in-context)
06:02:57 <dolio> Right.
06:05:14 <dolio> What's cojoin for state-in-context, though. It doesn't require monoids, as I recall.
06:05:23 <gwern> amazing. there are 29 different reasonable questions to test the present conjugation of a single verb
06:05:28 <gwern> bloody natural languages!
06:05:42 * int-e wonders about the relation to data Lens s a = Lens { focus :: s -> (a, a -> s) }
06:06:01 <ski>   split :: (s,s -> a) -> (s,s -> (s,s -> a))
06:06:19 <Cale> gwern: Questions?
06:06:25 <ski>   split (s0,sa) = (s0,\s1 -> (s1,\s2 -> sa s2))
06:06:28 <dolio> @djinn (s, s -> a) -> (s, s -> (s, s -> a))
06:06:29 <lambdabot> f (a, b) = (a, \ c -> (c, \ _ -> b a))
06:06:31 <gwern> Cale: see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7742#a7743
06:06:39 <dolio> @yow!
06:06:39 <lambdabot> I want you to MEMORIZE the collected poems of EDNA ST VINCENT MILLAY
06:06:39 <lambdabot> ... BACKWARDS!!
06:06:48 <gwern> Cale: each generated line is a single good flashcard question; there are 29 lines, so...
06:06:48 <ski> `djinn's answer is not the correct one
06:07:00 <int-e> ski: thanks.
06:07:06 * ski thought `djinn' tried to be relevant, if possible
06:07:09 <gwern> Cale: q/a, tab-separated, to be specific
06:07:42 <dolio> Should be (a, \c -> (c, \d -> b d))?
06:07:51 <ski> yes
06:08:33 <Cale> gwern: Ah, I thought you meant something like 29 questions you'd have to ask in order to decide which conjugation to use.
06:08:46 <Cale> gwern: Which seemed kind of unlikely ;)
06:09:04 <gwern> well, if you can't answer all 29 questions, then you don't know how to use that verb...
06:09:41 <gwern> but the mental overhead in some languages is amazing; in french, each word needs something like 2 bits of metadata because of gender and exceptions to gender rules
06:09:45 <ski> probably `Lens'es should satisfy `forall lens. uncurry (flip id) . focus lens = id'
06:10:02 <gwern> some languages have >10 genders, which means each word needs 3 or 4 bits of data. I pity the poor speakers
06:10:04 <quicksilver> dolio: no, 'now' doesn't have the same time always.
06:10:08 <Cale> Well, maybe true, but there are regularities to how conjugation happens. English is kind of bad in that regard, but French at least is quite regular.
06:10:15 <quicksilver> dolio: instead a behaviour has a built-in notion of current time
06:10:26 <quicksilver> dolio: and you can get later ones using the cojoin.
06:10:50 <quicksilver> ski: djinn makes some attempt to be relevant but I don't know what the axoims are.
06:10:52 <gwern> Cale: yeah, I don't mind conjugating as much as gender
06:10:58 <gwern> gender is jsut stupid
06:11:03 <quicksilver> @djinn (a,a) -> (a,a)
06:11:03 <lambdabot> f a = a
06:11:12 <quicksilver> @djinn a -> a -> (a,a)
06:11:13 <lambdabot> f a b = (b, a)
06:11:27 <saml> that's weird
06:11:31 <dolio> quicksilver: You mean it's not my old-school 'Time -> a'?
06:11:33 <ski> (quicksilver : the axioms of `djinn' or of relevant/relevance logic ?)
06:11:47 <Cale> gwern: I heard that there are no new feminine nouns in French at least.
06:12:17 <gwern> the funny thing is, I read a study on language log that young french can't even agree on the gender of more than a small fraction of nouns
06:12:22 <gwern> which is just the icing on the cake
06:12:43 <quicksilver> dolio: it is more like (Time,Time -> a) as you suggested.
06:12:48 <quicksilver> dolio: but obviously it's abstract.
06:12:56 <quicksilver> dolio: it doesn't have to be thought of that way
06:13:02 <quicksilver> dolio: it could be that 'now' is always '0'
06:13:09 <quicksilver> dolio: and the Time gets adjusted magically somehow.
06:13:26 <quicksilver> ski: the axioms djinn uses; I don't believe it is any of the well-known relevant logics.
06:13:46 <saml> ghci doesn't paste well on windows cmd.exe it only pastes the first character.  and ghcii.sh on rxvt (msys) does not do tab completion
06:13:57 <dolio> quicksilver: Okay. My original point was that thinking of things in terms of the old specifics, Behavior doesn't seem like it'd make sense as a comonad. But as I said, I haven't kept up on things.
06:13:58 <lysgaard> Where do i find commenting/documentig guidelines so that my code is haddock compitable?
06:15:37 <stanv> howto replicate some object to infinite list (any element have same value). list must be endless.
06:15:41 <stanv> ?
06:16:00 <quicksilver> stanv: repeat
06:16:08 <ray> > repeat 42
06:16:09 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
06:16:25 <mux> > fix (42:)
06:16:26 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
06:16:32 <vav> lysgaard: http://www.haskell.org/haddock/doc/html/index.html
06:16:43 <elbar> > cycle "abcd"
06:16:44 <lambdabot>   "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdab...
06:16:49 <ray> > fix cycle
06:16:54 <lambdabot>   mueval-core: Prelude.read: no parse
06:16:55 <lambdabot>  mueval: ExitFailure 1
06:16:56 <mux> > fix ("abcd" ++)
06:16:58 <lambdabot>   "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdab...
06:17:00 <stanv> oh! thanks!
06:17:03 <stanv> :))) stop ^)
06:17:04 <stanv> :))
06:17:14 <mux> fix is such a great obfuscation tool
06:17:50 <stanv> i need olny one decision :)
06:17:52 <ray> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 9
06:17:53 <lambdabot>   362880
06:18:04 <elbar> > let l = "abcd" : l
06:18:05 <lambdabot>   not an expression: `let l = "abcd" : l'
06:18:11 <mux> > fix ((1:) . scanl (+) 1)
06:18:12 <elbar> grrr ;)
06:18:12 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:19:07 <int-e> > zipWith take [1..] . transpose . iterate (scanl (+) 0) $ repeat 1
06:19:08 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
06:19:54 <quicksilver> dolio: I don't think it's a good comonad but I do think that cojoin is very useful. And for Events too.
06:20:01 <Cale> stanv: Go with repeat then, since it's meant for that :)
06:20:27 <saml> what's that sequence int-e ?
06:20:34 <lysgaard> vav: Thanks
06:20:41 <int-e> saml: Pascal's triangle.
06:20:44 <quicksilver> int-e's triangle
06:20:47 <quicksilver> pascal stole it.
06:20:56 <int-e> I'm not that old.
06:21:17 <quicksilver> pascal had a time machine!
06:21:19 --- mode: quicksilver set -o quicksilver
06:21:37 * saml vaguely remembers that for factoring out polynomials or something
06:21:41 <Cale> saml: The kth element of the nth row is the number of k-element subsets of a set of n things.
06:22:05 <Cale> and yeah, it's also the coefficient of x^k in (x+1)^n
06:22:19 <Cale> (or x^k y^(n-k) in (x+y)^n)
06:22:52 <Apocalisp> gwern: Don't be ridiculous. Gender is awesome.
06:23:33 <ray> yes he is
06:24:08 <Apocalisp> The more types the better, I say.
06:24:36 <Cale> Apocalisp: But if the types don't actually convey meaningful information...
06:25:03 <Apocalisp> It's a disambiguation tool.
06:25:16 <Cale> I suppose there are cases where the gender helps to disambiguate pronoun references.
06:25:39 <Apocalisp> You can rely on syntax instead, but this is even more awkward in many languages.
06:26:16 <Cale> Or you can be like Japanese and leave the pronouns out altogether and hope that everyone is smart enough to get what you're saying ;)
06:26:50 <Apocalisp> heh
06:27:00 <Apocalisp> Japanese is the LISP of natural languages.
06:28:29 <mux> uso da
06:28:31 <ray> only in that it scares people who don't speak it
06:28:33 <Cale> Well... that's not entirely true, they do have pronouns, but where it's obvious what's being referred to, they just leave things out.
06:28:37 <mux> japanese isn't prefix :-)
06:32:06 <Ke> I finnish you can have one word sentences with only the predicate verb
06:32:15 <Cale> Japanese is like that too.
06:32:21 <Ke> In
06:32:36 <mmorrow> is english the sh preprocessed with CPP?
06:32:53 <Cale> You only need the verb, or the adjective, or a noun in the case of a declarative.
06:33:17 <saml> english has defmacro, acronyms
06:33:27 <saml> LOL expands to lord of lords
06:33:41 <saml> context sensitive macro expantion of english
06:34:27 <mmorrow> echo `eval $(cat $0 | cpp)`
06:34:50 <Cale> The other thing I like is that all verb/adjective terminated sentences in Japanese have the capacity to function as adjectives.
06:36:20 <Apocalisp> higher-order adjectives
06:45:58 <Cale>  (dinner)  (object marker)  (negative, past of eat)  (person)  (topic marker)  (movie)  (contextual noun marker)  (past of see)  (bank)  (location marker)  (past of go) -- The person who didn't eat dinner went to the bank seen in the movie.
06:48:15 <lilac> > (if True then 1 else 0 +) 42
06:48:19 <lambdabot>   <no location info>: parse error on input `)'
06:48:29 <lilac> ^^ it makes me sad that that doesn't work
06:48:33 <Cale> > ((if True then 1 else 0) +) 42
06:48:34 <lambdabot>   43
06:49:43 <lilac> i guess if uses the 'extend as far to the right as possible' rule like lambda?
06:49:45 <lilac> > (\x -> x + 1 .) id 1
06:49:46 <lambdabot>   <no location info>: parse error on input `)'
06:51:04 <Cale> 
06:51:12 <Cale> clearly the opposite of lisp ;)
06:51:37 <lysgaard> Let's say i have file 'a' wich imports file 'b' wich imports file 'c'. Is 'c' exported fuctions visible to 'a' as they are to 'b'?
06:52:05 <Cale> lysgaard: Only if b re-exports c
06:52:58 <lysgaard> Cale: Ah, is there anywhere i can read about how the export, import deriviating etc works in a simple manner?
06:53:13 <Cale> lysgaard: It B has  module C  in its export list, then it re-exports everything that it imported from C.
06:54:01 <Cale> It might not be the easiest explanation, but http://haskell.org/onlinereport/modules.html
06:54:42 <Cale> Probably even just looking at the examples there is a reasonable enough way to get the idea of how it works.
06:55:03 <lysgaard> Cale: I usualy just use the "module xys where" on top, what does that do instead of explicitly listing everything?
06:55:56 <Cale> If the export list is omitted, all values, types and classes defined in the module are exported, but not those that are imported.
06:56:39 <gwern> Apocalisp: you mean japanese is like lisp, because there are 4 different languages in which to write it, including all the half-baked identifiers stolen from ALGOL and APL?
06:57:07 <Cale> Huh?
06:57:25 <Cale> I suppose there's ...
06:58:18 <Cale> oh, and the Okinawan dialect/language...
06:58:41 <Cale> But it seems there are way more dialects of English :)
06:58:55 <gwern> Cale: we just have the one alphabet
06:59:24 <lysgaard> Cale: Thanks
06:59:36 <kfish> 
07:00:28 <Twey> Hahaha
07:00:44 <Cale> :)
07:01:31 <Twey> I like the analysis of Japanese as backwards-Lisp.  :-P
07:02:40 <lilac> Cale: i assumed gwern meant katakana, hirigana, romanji
07:03:09 <Cale> lilac: I suppose I was thrown off by "4 different languages"
07:03:10 <Twey> Kanzi, more likely... ro-mazi is not a Japanese writing system, per se
07:03:38 <Cale> Japanese is really just one language. It's just that the characters used to write it can be classified into groups.
07:04:14 <lilac> so it's more like the different serializations of html5 :)
07:04:48 <Cale> You can't write it properly without using characters from kanji, hiragana and katakana.
07:05:13 <Cale> In fact, most verbs have both a kanji part and a hiragana tail.
07:05:31 <SamB_XP> Cale: and, it seems, from the latin alphabet ;-)
07:05:34 <Cale> (so even within a single word, there are characters of different types)
07:06:40 <Cale> SamB_XP: I like how my IME will convert  into Skype automatically ;)
07:06:43 <maltem> Btw is is true that at subway stations or similar, names are written in hiragana only if that was easier to implement?
07:08:30 <Cale> maltem: hmm... 'if'?
07:10:13 <maltem> whatever :) I cannot find googleable pictures supporting this
07:12:15 <vav> me is hoogle/haskell fail. ?Prettier way to: \h h' x -> hPutStrLn h x >> hPutStrLn h' x
07:14:34 <seydar> purplepenguins: what's grey
07:14:44 <Philippa> vav: I doubt there is one
07:14:45 <seydar> a melted penguin!
07:15:27 <Philippa> possibly mapM (\h -> hPutStrLn h x) [h, h']
07:15:38 <vav> Philippa: thx, @pl is certainly hideous. will stop wasting time.
07:15:56 <Philippa> you could @pl the \h -> bit
07:16:45 <vav> yeah, actually that's helpful for cases where it's more than two handles anyway
07:18:52 <SamB_XP> @pl mapM (\h -> hPutStrLn h x) [h, h']
07:18:52 <lambdabot> mapM (flip hPutStrLn x) [h, h']
07:19:55 <SamB_XP> why not "mapM (`hPutStrLn` x) [h, h']" ;-P
07:21:11 <Philippa> heh
07:21:24 <vav> SamB_XP: oh no, another styleWarz
07:21:28 <Philippa> that's definitely one of those things that's easier with syntax highlighting
07:21:35 <doserj> > length "hPutStrLn h x >> hPutStrLn h' x" - length "mapM_ (`hPutStrLn` x) [h, h']"
07:21:36 <lambdabot>   2
07:22:19 <SamB_XP> Philippa: eh?
07:23:17 <Philippa> makes it easier to spot the ` ` and thus that it's a section
07:24:49 * SamB_XP is glad Philippa undestands what he means whan he says "eh?" :-) 
07:25:11 <Twey> Heh
07:43:59 <Rotaerk> for 600 people this channel sure is quiet
07:45:09 <Peaker> how many are explicitly marked as away?
07:45:11 <cjb> Rotaerk: you're assuming they 600 people aren't mostly in a small number of timezones :)
07:45:27 <Peaker> @users
07:45:27 <lambdabot> Maximum users seen in #haskell: 661, currently: 601 (90.9%), active: 16 (2.7%)
07:45:33 <Peaker> how is "active" defined?
07:45:47 <Peaker> why did #haskell stop growing?
07:46:00 <Saizan_> so many questions..
07:46:06 <defun> my friend asked me what would be the practical benefits of having a pure-haskell libcurl-clone, instead of just bindings to the libcurl. I couldn't provide an answer. Please help.
07:46:29 <Peaker> defun: you could unsafePerformIO libcurl bindings if it really is semantically pure
07:46:52 <Peaker> defun: if it isn't semantically pure, then the usual why-semantic-purity-is-better answer:  Because you get nicer types that tell the whole or more of the story
07:46:54 <Saizan_> pure-haskell in the sense of implemented in haskell i think
07:47:03 <Peaker> oh
07:47:04 <blackdog_> defun: it'd minimise external dependencies, i suppose, but that's a pretty weak defence
07:47:16 <defun> Saizan_: yes.
07:47:28 <Peaker> defun: if its implemented in Haskell, it can probably be extended more easily, maybe even allowing uses we can't foresee now
07:47:30 <Saizan_> defun: you could maybe give a nicer haskell API
07:47:55 <Peaker> It might be more efficient, if the bindings need to marshal/unmarshal a lot of stuff
07:48:26 <stanv> i need foo 2 "anylist" = ["an","yl","is","t]. what is the name of foo ?
07:48:33 <blackdog> btw, anyone seen App::Persistent, the perl module? rather cute little use of haskell for the client
07:48:33 <defun> thanks. what's preventing devs from implementing curl in haskell, as an experiment?
07:48:56 <blackdog> defun: more interesting projects? :)
07:48:58 <ttmrichter> defun: Time?  Energy?
07:49:09 <defun> good points...
07:50:41 <ski> > (\n -> unfoldr (\xs -> guard (not . null $ xs) >> Just (splitAt n xs))) 2 "anylist"
07:50:42 <lambdabot>   ["an","yl","is","t"]
07:50:50 <byorgey> stanv: it's named 'chunk', but it's not in the standard libraries, you can find it in the 'split' module on Hackage
07:50:54 <Berengal> Rock band is awesome. Java sucks. Haskell needs to become mainstream fast so I don't lose my sanity
07:51:10 <blackdog> http://blog.jrock.us/articles/App%3A%3APersistent.pod if anyone's interested
07:51:13 <ttmrichter> Berengal: once languages become mainstream, the suction starts.
07:51:53 <Berengal> ttmrichter: Some mainstream languages suck more than others. Based on that observation, I must disagree with you
07:52:51 <CalJohn> Berengal: yes, languages that "go mainstream" by educating rather than pandering tend to do well, i find
07:53:03 <jrockway> blackdog: the haskell part of that turned out very well
07:53:05 <jfoutz> some had a lower initial value of suck
07:53:09 <jrockway> it went together quickly and is quite concise
07:53:14 <jrockway> and of course starts up very quickly :)
07:53:43 <blackdog> jrockway: yeah, i had a look through the source. nice idea, was thinking of stealing it for ruby
07:54:01 <jrockway> yeah, you should
07:54:08 <jrockway> the more things that speak the same protocol, the better
07:54:21 <ski> (Peaker : or not include `IO' in the result type at all ..)
07:54:30 <jrockway> then it won't be just the weird perl people that do this, it's everyone ;)
07:54:41 <blackdog> i had a similar problem in haskell, except that justloading code is usually fast as - what i really need is to be able to compute a bunch of data once and then have every process afterwards have access to it
07:54:51 <blackdog> jrockway: yeah, absolutel
07:54:51 <blackdog> y
07:55:37 <blackdog> i guess one common way around the problem is just to set it up as a web service instead
07:56:30 <jrockway> yeah
07:56:38 <jrockway> but that is not always the best thing for command-line apps
07:57:04 <blackdog> yeah. good's the enemy of the best and all that.
07:57:52 <Peaker> jrockway: I like "The less entities that speak a protocol, the better", and "The more people speak the same API, the better" :)  So that you can retain an API and upgrade the protocol seamlessly
07:57:54 <blackdog> i think the PTY approach is much better long term, though. fixed network port sort of gives me the heebie-jeebies
07:58:40 <defun> btw, can quickcheck work on FFI functions? (i.e. functions imported from C, etc.)
07:58:53 <blackdog> defun: yes
07:59:40 <Berengal> "Sort of like writing your application in Haskell instead of Perl.  Both are programming languages, but Haskell is not a drop-in replacement that makes Perl scripts faster;"
08:00:02 <Berengal> I like the underlying indication that perl == haskell
08:00:04 <blackdog> can't find it now, but there was a guy testing a bunch of networking function in C using quickcheck
08:00:18 <ski> defun : iirc, Hughes found lack of full specification in some man page for `fseek', that way
08:00:28 <Berengal> (Up to a certain degree)
08:00:50 <ski> (or maybe it was just a lack in the encoding of that specification into preconditions with QC .. don't remember exactly)
08:01:01 <jrockway> they are superficially similar; you write "code" and "run" it and get "results"
08:01:05 <jrockway> that is about how similar moose and mouse are
08:01:16 <jrockway> they have a "has" keyword, and deal with objects, and stuff
08:02:07 <jrockway> (i think non-perl people are missing a lot of the moose/mouse background; moose is an object system, mouse is a syntax clone that starts up faster, and a lot of people think they are "the same" because the syntax looks similar.  that is not correct.)
15:04:14 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
15:04:14 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
15:04:38 <jfoutz> 18:04  * roconnor could imagine an Int turning to Integer causing constant
15:05:16 <jfoutz> gah, mouse strangeness. sorry about that.
15:05:52 <ketil> it's the read causing this - I've profiled it to see that it's an array (i.e. ByteString) taking all the space.
15:06:15 <MyCatVerbs> roconnor: What do you mean "could"? It's practically guaranteed. Mwhahahahahah. :3
15:06:20 <ketil> So it's not an Int(eger) thing, at least.
15:07:07 <ketil> Any way to check the types of exported functions from a library module?
15:07:09 <pvdbrand> roconner: I also replied to the reddit question, I managed to down-vote my own post to 0 points :)
15:07:14 <ketil> There's some ghc option, no?
15:07:41 <dmwit> ketil: :browse in ghci?
15:07:49 <roconnor> ketil: ghic :browse module
15:07:52 <roconnor> ghci
15:08:08 <dmwit> ketil: Or just :m + module, then :t functionName if :browse is too verbose.
15:09:44 <ketil> Hm, yes.  ghc -Wall doesn't indicate any type signatures missing, so I can't see how this could happen.
15:09:50 <ketil> This is an oldish ghc, btw, 6.8.2 as supplied with Ubuntu.
15:09:56 <ketil> Maybe I should check the bug list...
15:10:05 <Cale> ketil: mm... that is quite old, yeah.
15:10:24 <Cale> ketil: Can I have a copy of the code? Would I be able to try it?
15:10:27 <ketil> It'll be better in 9.10.
15:11:03 <ketil> Sure thing.  It's in the bioinformatics library - darcs gettable from http://malde.org/~ketil/biohaskell/biolib/
15:11:35 <ketil> The application in question is part of 'flower', I can push it to somewhere nearby.
15:11:44 <ketil> You'll need an SFF file, but I can put that too somewhere.
15:12:28 <ketil> I can also try to make a more minimal test case, but it's late here, so that will have to happen later...
15:12:43 <ketil> Still interested, and I'll push the repos?
15:14:00 <Cale> ketil: Well, I'd be interested in looking at it. Not sure if I'll be able to work out what's going on
15:14:47 <ketil> Okay, I'll publish the pieces, and promise to fax you a beer if you work it out :-)
15:17:30 <ketil> Cale: darcs get http://malde.org/~ketil/biohaskell/biolib-unstable and  http://malde.org/~ketil/biohaskell/flower
15:17:59 <ketil> Cale: the last patch in biolib is the critical one - without it, I get the leak
15:19:00 <ketil> Cale: test file at malde.org:~ketil/test.sff
15:19:47 <eflister> i have f :: a -> b -> IO (Either c d)
15:19:47 <eflister> x :: Maybe a for the first arg, and y :: b for the second one.
15:19:48 <eflister> i want a Maybe IO (Either c d) out the other end.  "liftM2 f x $ return y" almost works, but layers on an extra IO instead of Maybe.
15:19:48 <eflister> this is the right side of a <- in a do block of an IO () -- does that matter?
15:20:15 <ketil> Cale: Command line to test: fselect "And (Func GT len 200) (Func GT k2 0.7)" test.sff
15:20:32 <dmwit> eflister: Check out fmap.
15:20:45 <eflister> k
15:20:53 <ketil> Cale: the upload of the test file will take a short while, 20 minutes or so.
15:21:08 <dmwit> eflister: (In particular, with the "Functor f" context fixed to "f = Maybe".)
15:21:37 <Cale> ketil: Oh, is the test.sff that I got incomplete?
15:21:47 <mauke> :t let f :: a -> b -> IO (Either c d); f = undefined in fmap (\x' -> f x' ?y) ?x
15:21:48 <lambdabot> forall a b c d (f :: * -> *). (?y::b, ?x::f a, Functor f) => f (IO (Either c d))
15:22:12 <ketil> Cale: Probably.  it doesn't have to be complete, though, but rsync it a bit until you've got a sizable chunk of data.
15:22:52 <ketil> The program (fselect) should run in constant space, for me it's less than 5MB (according to top).  When it leaks, it grows linearly with time.
15:23:41 <ketil> Cale: you manage to build okay?  There's a bunch of dependencies for biolib.
15:27:34 <Cale> hmm, the bio library itself builds okay...
15:27:39 <Cale> ah
15:27:43 <Cale> I see :)
15:27:47 <ketil> Tell me!
15:27:52 <ketil> What?
15:28:08 <Cale> I just somehow missed the fact there were other repos to pull :)
15:28:09 <ketil> Spit it out man!
15:28:17 <ketil> Hm?
15:28:19 <ketil> Oh.
15:28:32 <Cale> (was wondering why I didn't find any binaries)
15:28:51 <ketil> Heh.  You'll also need 'flower', but it only depends on bio.
15:28:57 <ketil> Or .. mostly, at any rate.
15:29:15 <eflister> dmwit: ok my guess didn't work: fmap (liftM f x) y -- the thing is i don't know how to get at the 1st arg of f
15:30:59 <dmwit> ?djinn ((a -> b) -> (f a -> f b)) -> (a -> b -> g c) -> (a -> b -> f (g c))
15:30:59 <lambdabot> -- f cannot be realized.
15:31:07 <dmwit> oops
15:31:13 <dmwit> Got some type-variable aliasing, there. =P
15:31:27 <copumpkin> :o
15:31:33 <dmwit> ?djinn ((a -> b) -> (f a -> f b)) -> (i -> j -> g k) -> (i -> j -> f (g k))
15:31:34 <lambdabot> -- f cannot be realized.
15:32:37 <benmachine> @djinn a -> m a
15:32:37 <lambdabot> -- f cannot be realized.
15:34:13 <lilac> @djinn (a -> f a) -> (forall f. f a -> f b) -> a -> g b
15:34:14 <lambdabot> -- f cannot be realized.
15:34:24 <lilac> lies!
15:34:39 <axzs> sometimes Prelude gives not that general functions as I'd like to. I mean: (++) is less general than mappend, and map is less general than fmap. Should I try to get used to typing x `mappend` y or may I redefine those functions without danger?
15:34:59 <ketil> Cale: 40% now (test.sff), should be sufficient I think.
15:35:02 <axzs> I personally find typing `mappend` bit ugly
15:35:17 <skorpan> axzs: there has been lots of discussion about an alias for mappend on the haskell-cafe mailing list
15:35:23 <dmwit> ?djinn ((a -> b) -> (f a -> f b)) -> (f (c -> d) -> f c -> f d) -> (f i -> j -> k) -> (f i -> j -> f k)
15:35:23 <lambdabot> -- f cannot be realized.
15:35:41 <lilac> axzs: "import Prelude hiding ((++), map); (++) = mappend" is pretty safe
15:35:48 <lilac> the biggest danger is confusing people reading your code
15:35:52 <axzs> Thanks. Same with fmap?
15:36:18 <lilac> to be honest, i'd import Control.Applicative and consistenty use <$> since i think it's nicer than both map and fmap as a name
15:36:22 <dmwit> eflister: Yep, you're right, it's a weird thing that you're trying to do. =)
15:36:41 <dmwit> axzs: If you're redefining things, maybe you should go all the way and define (.) = fmap. ;-)
15:37:10 <lilac> i find that (.) as function composition is too deeply wired in my brain for that to work but ymmv :)
15:37:21 <dmwit> eflister: In particular, when should your new function return Nothing, and when should it return Just?
15:37:27 <axzs> Thanks. (.) is fmap for (a->)?
15:37:42 <dmwit> eflister: If the answer is "it should match the first argument", then does that mean you are only passing "Just" arguments to your underlying function?
15:37:42 <eflister> dmwit: really?  exactly according to the first arg.
15:38:02 <dmwit> eflister: If so, why does your underlying function take a Maybe at all?  You know you only pass Just's, so the ability to take a Nothing isn't helpful.
15:38:03 <benmachine> > toUpper `fmap` head $ "blah"
15:38:05 <lambdabot>   'B'
15:38:15 <dmwit> axzs: right
15:38:21 <axzs> thanks
15:38:26 <Cale> ketil: Which file is it where you comment stuff out?
15:38:34 <skorpan> axzs: are you going to use fmap instead of (.)?
15:38:44 <ketil> Cale: sorry: Bio.Sequence.SFF
15:38:50 <eflister> dmwit: well i'm using an api that has f as described, and the first arg is the result of some query that may fail.
15:39:11 <eflister> dmwit: i don't want to have to special case the failure, and just use the Maybe monad to worry about it for me
15:39:15 <ketil> Cale: at the bottom, functionality for the (completely unused) recoverSFF function.
15:39:21 <ketil> Or so I thought.
15:39:35 <axzs> Rather not, I think this would make things less readable
15:39:55 <dmwit> eflister: You can do that: (a >> f a b), where f :: Maybe a -> b -> IO (Either c, d).
15:40:02 <dmwit> eflister: But I still argue it's a weird thing to do.
15:40:04 <dmwit> err
15:40:09 <dmwit> a >> return (f a b)
15:40:47 <dmwit> You're using the Maybe monad, but not binding anything!  That's weird.
15:40:57 <Cale> ketil: btw, return . f =<< x  is fmap f x
15:41:01 <dmwit> ...and you're using the thing you don't bind, but not as a monad.
15:41:34 <Cale> ketil: So commenting out recoverSFF should make it use more memory?
15:41:44 <ketil> Cale: I know.  I fall back to the old ways occasionally.
15:42:17 <ketil> Cale: the commenting should already be in the last patch, just unpull it to trigger the memory leak.
15:42:33 <eflister> dmwit: aren't i binding the first arg, but not the second?  that's what i meant by "can't get at the first arg"
15:42:42 <eflister> dmwit: i'm new at this so i kind of don't know what's going on
15:43:14 <eflister> dmwit: i thought i was being Monadic by letting the Maybe behavior work for me
15:43:31 <axzs> (a->) is Yoneda functor, isn't it?
15:43:56 <dmwit> eflister: What I don't understand is why you want this, I guess.
15:44:13 <dmwit> If your library function is already capable of handling your Maybe for you, why do you want to add your own layer of Maybe-handling?
15:44:23 <Cale> axzs: Nope, just the covariant Hom functor.
15:44:36 <luite> is there a package that makes it easy to visualize and manipulate the results of haskell functions? for example 2d/3d plots with sliders to manipulate parameters.
15:44:57 <eflister> dmwit: what doesn't make sense about what i said -- "i want to call f with an arg (plus something else), but if that arg was Nothing, then just give me Nothing"
15:45:05 <copumpkin> luite: not that I know of, but I'd like one
15:45:26 <dmwit> eflister: The thing that doesn't make sense about it is that "f" already handles Nothing.
15:45:38 <dmwit> It's perfectly possible to do what you ask (see above).
15:45:52 <dmwit> I'm just concerned that it is a code smell -- there may be something you don't understand about the function "f".
15:46:05 <Cale> The Yoneda functor goes C -> Set^(C^op)
15:46:11 <luite> copumpkin: ideally, I'd like one that makes it possible to export it to some web-format (for example svg with javascript), so that I can use it on a blog to illustrate things
15:46:13 <dmwit> Smells do not always point to rotten code... sometimes they point to delicious cheese. =)
15:46:27 <copumpkin> luite: that would be very very nice :P
15:46:28 <eflister> dmwit: how is f handling Maybe?  it makes an "EIther" but that's for a different kind of failure that is local to f, not its first arg
15:46:42 <axzs> Cale: you're right. thanks
15:46:43 <eflister> :dmwit, you mean the a >> return (f a b)?  i'll try that
15:46:48 <dmwit> eflister: You told me "f :: Maybe a -> b -> IO (Either c d)", i.e. it handles arguments with a Maybe type.
15:47:15 <eflister> dmwit: where are you looking?  my OP doesn't have a leading maybe, right?
15:47:30 <erikc> luite: conal's eros stuff would fit that niche, not sure what the state of it is
15:47:30 <erikc> http://conal.net/papers/Eros/
15:47:39 <dmwit> 18:19 < eflister> i have f :: a -> b -> IO (Either c d)
15:47:39 <dmwit> 18:19 < eflister> x :: Maybe a for the first arg, and y :: b for the second one.
15:47:59 <eflister> dmwit: oh all i meant by that was that "f takes an a for the first arg, but i have a Maybe a to give it"
15:48:04 <dmwit> Oh!
15:48:09 <dmwit> Well, that's much more reasonable. =)
15:48:13 <eflister> :)
15:48:23 <dmwit> then yeah, you want fmap
15:48:55 <dmwit> ?djinn ((a -> b) -> (f a -> f b)) -> (i -> j -> k) -> (f i -> j -> f k)
15:48:55 <lambdabot> -- f cannot be realized.
15:49:00 <dmwit> Oh, come on.
15:49:03 <dmwit> That's so realizable.
15:49:08 <copumpkin> does djinn even do type constructors?
15:49:16 <dmwit> um
15:49:18 <ketil> Cale: get anywhere?
15:49:21 <eflister> dmwit: ok, but my guess fmap (liftM f x) y didn't work
15:49:30 * ketil is about to call it a day.
15:49:39 <dmwit> ?djinn Maybe a -> Maybe a
15:49:39 <lambdabot> f a = a
15:49:40 <dmwit> copumpkin: yes
15:49:45 <copumpkin> ah cool
15:49:48 <dmwit> ?djinn a -> Maybe a
15:49:48 <lambdabot> f = Just
15:50:07 <dmwit> :t \f a b -> fmap (flip f b) a
15:50:08 <lambdabot> forall a b c (f :: * -> *). (Functor f) => (a -> b -> c) -> f a -> b -> f c
15:50:20 <mauke> ?djinn ((a -> b) -> (f a -> f b)) -> (a -> j -> b) -> (f a -> j -> f b)
15:50:21 <lambdabot> f a b c d = a (\ e -> b e d) c
15:50:26 <luite> erikc: ah, that could be useful, but I personally don't need all those compositions to be visual too
15:50:53 <eflister> dmwit: oh maybe a flip would help me
15:51:24 <Cale> ketil: So you're saying that recoverSFF is unused?
15:51:48 <ketil> Yes.  Feel free to remove it entirely.
15:52:02 <lilac> @djinn Maybe a -> b -> (a -> b -> IO (Either c d)) -> Maybe (IO (Either c d))
15:52:03 <lambdabot> Error: Undefined type IO
15:52:06 <lilac> :(
15:52:16 <lilac> @djinn Maybe a -> b -> (a -> b -> io (Either c d)) -> Maybe (io (Either c d))
15:52:17 <lambdabot> f a b c =
15:52:17 <lambdabot>     case a of
15:52:17 <lambdabot>     Nothing -> Nothing
15:52:17 <lambdabot>     Just d -> Just (c d b)
15:52:40 <ketil> It's commenting in the last page or so that causes trouble.  I'm very curious if this happens with a newer GHC as well.  Or if it's at all reproducible.
15:53:06 <eflister> dmwit:  fmap ((flip f) y) x gave me exactly the same problem i had before :)
15:53:44 <dmwit> ?
15:54:10 <eflister> lilac: isn't the idea of monads to not write that kind of code every time one uses a Maybe
15:54:20 <eflister> dmwit: it put on an IO instead of a Maybe
15:54:43 <eflister> dmwit: which i feel like might be because i'm in the do of an IO () (my main, actually)
15:54:57 <dmwit> Yes, almost certainly.
15:54:59 <Baughn> eflister: @djinn isn't very clever about these things
15:55:11 <dmwit> eflister: You can never get out of IO, once you're in it, you know.
15:55:25 <eflister> dmwit: can one have a Maybe on the outside of an IO tho?
15:55:31 <dmwit> Baughn: djinn did alright, it was my stupid input that was wrong.
15:55:35 <Baughn> Or alternately, you can get out but never back in. Depends on your perspective.
15:55:36 <dmwit> eflister: Sure, why not?
15:55:46 * Baughn discretely hides unsafePerformIO
15:55:51 <lilac> @type let f :: Int -> Double -> IO (Either c d); x :: Maybe Int; y :: Double; f = undefined; x = undefined; y = undefined in f <$> x <*> pure y
15:55:53 <lambdabot> forall c d. Maybe (IO (Either c d))
15:55:58 <dmwit> eflister: It represents either a description of an IO action, or no such description. =)
15:56:03 <Cale> ketil: Okay, seems I'll have to wait for test.sff to completely finish before trying it properly. I get fselect: too few bytes. Failed reading at byte position 2113656
15:56:14 * benmachine continuously hides unsafeCoerce
15:56:21 <Cale> ketil: oh, hmm
15:56:33 <Cale> er, sorry, that was the wrong test.sff file
15:56:36 <Cale> one sec ;)
15:56:38 <Baughn> benmachine: unsafePerformIO is /ever/ so useful when you know what it does, though. :3
15:56:46 <lilac> @@ @pl @djinn Maybe a -> b -> (a -> b -> io (Either c d)) -> Maybe (io (Either c d))
15:56:47 <lambdabot>  (line 1, column 37):
15:56:47 <lambdabot> unexpected ">" or "-"
15:56:47 <lambdabot> expecting variable, "(", operator or end of input
15:56:52 <benmachine> Baughn: I don't doubt it
15:56:53 <Cale> fselect: too few bytes. Failed reading at byte position 48575448  now ;)
15:57:04 <lilac> :( @pl doesn't do case analysis i guess
15:57:07 * inimino hums Welcome to the Monad California
15:57:09 <ketil> Cale, that's the expected error on a truncated file.  I hope your machine is slow enough to tell the memory usage.
15:57:15 <eflister> dmwit: ok, that's what i'm trying to do.  :)  why did my fmap attempt and liftM attempt always give me IO's on the outside instead of Maybes?
15:57:26 <Cale> ketil: It gives that error immediately.
15:57:54 <ketil> Cale: hm.  That's pretty quick.
15:58:00 <dmwit> eflister: Each line of a do-block is a monadic action of the same monad.
15:58:05 <lilac> eflister: i don't think you'll get this much nicer than either 'f <$> x <*> pure y' or 'do a <- x; return (f a y)'
15:58:10 <Cale> Well, it's almost finished downloading
15:58:19 <ketil> This is a small file, and I was hoping it would be sufficient.  I can push a larger one, but that will obviously take longer.
15:58:19 <dmwit> eflister: You can see why from the type of (>>=), on which do-blocks are built:
15:58:21 <dmwit> :t (>>=)
15:58:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:58:30 <Cale> er, ah, has it not finished uploading
15:58:31 <Cale> ?
15:58:34 <dmwit> eflister: The three occurrences of "m" here are constrained to be equal.
15:58:51 <ketil> Cale: 20 secs left
15:59:02 <Cale> ah, wget thought that it was done because it had read the old size on the server
15:59:05 <Boney> win 1
15:59:11 <Boney> (wrong window)
15:59:11 <eflister> dmwit: yeah, that's why i suspected that's where it was coming from.  but it's on the right side of a <-
15:59:21 <Cale> okay, I'll continue when you're finished that
15:59:26 <ketil> Cale: sorry. Done now, but it might be too fast anyway?
15:59:44 <eflister> dmwit: and i have other things on the right side of a <-, (like Maybes for instance), and they are ok
15:59:47 <dmwit> eflister: (x <- foo) is shorthand for (foo >>= \x ->), roughly.
15:59:58 <dmwit> eflister: Not in the same block, you don't.
16:00:21 <Cale> maybe... with the slightly larger file now it takes about half a second to report the error
16:00:55 <eflister> dmwit: oh yeah, they have IO on the outside.  hmmm
16:01:08 <ketil> Cale: this takes at least 40 seconds on my machine. (still running)
16:01:41 <Cale> I don't have anything special, just a P4 2.4 GHz uniprocessor machine.
16:01:44 <ketil> ./FSelect "And (Func GT len 100) (Func GT k2 0.5)" test.sff
16:02:01 <eflister> dmwit: so i need to flip my Maybe and IO with Data.Traversable.mapM maybe?  i got some help earlier today here on the previous line of code, which had that problem.  :b
16:02:08 <ketil> file is 88MB
16:02:19 <Cale> cale@zaphod:~/flower$ time fselect "And (Func GT len 200) (Func GT k2 0.7)" test.sff
16:02:19 <Cale> fselect: too few bytes. Failed reading at byte position 60333360
16:02:19 <Cale> real	0m1.082s
16:02:20 <Cale> user	0m0.608s
16:02:22 <Cale> sys	0m0.228s
16:02:34 <dmwit> eflister: umm... that's a weird thing to want to do
16:02:53 <dmwit> And probably just plain not possible.
16:03:09 <Cale> ketil: Try upgrading to 6.10.3 or 6.10.4
16:03:31 <Cale> Oh, btw, this is with everything commented out still.
16:03:32 <ketil> Cale: how can you read 60MB in less than a second?  And you shouldn't get the error anymore either.
16:03:36 <eflister> dmwit: i think part of it has to do with this api -- it's a super early "release" of some bindings to a foreign library that is advertised to not be well designed
16:03:44 <lilac> dmwit: case m of Nothing -> return Nothing; Just x -> Just <$> x
16:03:44 <Cale> ketil: I'm still downloading
16:03:46 <ketil> Cale: did you get a file called "selected.sff"?
16:03:55 <Cale> ketil: yep
16:04:02 <Cale> ketil: It is empty though.
16:04:03 <ketil> size?
16:04:03 <dmwit> lilac: switch the other way
16:04:13 <dmwit> lilac: from (IO (Maybe a)) to (Maybe (IO a))
16:04:27 <ketil> Try to change the command line to what I posted above
16:04:34 <lilac> dmwit: that's not what I thought eflister wanted, but yeah, that's not possible :)
16:04:35 <ketil> 100 and 0.5 for the parameters
16:04:40 <dmwit> lilac: I look forward to your case analysis on the IO type. ;-)
16:04:55 <Cale> ah, okay, that's taking longer
16:05:14 <lilac> dmwit: doesn't eflister have a Maybe (IO (Either c d)) from this 'f' function, and want an IO (Maybe (Either c d))?
16:05:15 <ketil> Memory usage?
16:05:27 <dmwit> lilac: nope
16:05:49 <Cale> ~6 MB virtual / 4 MB resident
16:06:17 <Cale> and seems constant
16:06:24 <ketil> Cale: that's good (and expected).  If you comment back in (unpull the top patch) in bio?
16:06:34 <eflister> dmwit and lilac: i have IO Either, and want Maybe IO Either.  it was possible with Data.Traversable.mapM.
16:07:04 <Cale> * comment out recover functionality - otherwise FSelect leaks memory! -- this one, yeah?
16:07:18 <copumpkin> eflister: what would the Maybe represent there?
16:07:21 <ketil> Cale: how d'you guess?
16:07:25 <ketil> :-)
16:07:41 <lilac> eflister: that's just "return"
16:07:57 <mauke> that's Just
16:08:02 <lilac> eflister: but it sounds pretty pointless; you might be better off with 'let' in your do block
16:08:47 <lilac> eflister: you said "this is the right side of a <- in a do block of an IO ()" -- are we still talking about the same thing?
16:09:03 <lilac> if so, you want IO on the outside
16:09:38 <eflister> dmwit and lilac: in the other case, i had f :: a -> IO b and g :: IO (Maybe a).  and i wanted IO (Maybe b).  yeah, IO still on the outside.  :(  sorry!
16:10:06 <copumpkin> a -> IO b :o
16:10:30 <dmwit> I assume he's using a and b to stand in for particular monomorphic types (or perhaps ad-hoc polymorphic).
16:10:37 <eflister> and the soln was Data.Traversable.mapM f =<< g
16:10:43 <Cale> ketil: Okay, I'm certainly seeing this memory usage going up
16:11:41 <ketil> Cale: great.  Or, rather...well, at least, it confirms that I'm not the only one seeing things...
16:12:13 <Cale> After a minute or so of CPU time, it's past 100 MB of virtual and 82 MB of resident memory
16:13:46 <Cale> okay, it finished in 2 minutes or so, with about 150 MB of memory resident.
16:13:52 <ketil> Cale: right.  It seems to be unable to discard the read SFF file contents - at least, that's my current explanation.
16:14:36 <ketil> The structure (SFF h rs) is a header h and rs is the list of blocks, which is filtered by the program.
16:15:24 <ketil> So IMO, it writes the header, and then only needs to hold onto one r at a time to consider writing or discarding it.
16:16:15 <axzs> skorpan: I thought more about (.) = fmap, and although this is correct, there's a reason not to: there wouldn't be any way to express functoriality law fmap (f . g) = fmap f . fmap g
16:16:47 <copumpkin> it'd also get nasty with overloaded strings
16:21:13 <mauke> (.) (f . g) = (f .) . (g .)
16:22:33 <Cale> axzs: It becomes  (f . g) . x = f . (g . x)
16:23:17 <ketil> Cale: I have to get some sleep now.  Let me know if you have any insights - if nothing else, email me your GHC version, and I'll post to the list tomorrow to see if anybody else have any ideas.
16:23:23 <Cale> I'm using 6.10.3
16:23:53 <ketil> Okay.  Good night!
16:27:16 <Cale> I naturally see more optimiser steps from ghc-core when run on the uncommented version
16:27:16 <Cale> But it's hard to tell exactly where they're happening.
16:27:16 <axzs> Oh, right. I meant, we first define a category and composition, and then define a functor. So logically, (.) is defined before fmap. On the other side, it's a special case of it.
16:27:16 <Cale> right
16:27:16 <Cale> Unless you do something funny to be able to define a category and functor without mentioning composition somehow :)
16:27:16 <Cale> (It would have to be a rather strange-looking definition!)
16:27:16 <axzs> doesn't seem even possible :)
16:28:01 <Cale> Well, there are formalisations of categories which are purely axiomatic and don't use sets, and I think some get away with not mentioning arrows at all.
16:28:25 <Cale> (Instead taking commuting triangles to be the fundamental thing)
16:29:13 <SamB_XP> Cale: why would they meantion Arrows?
16:29:24 <Cale> Not Hughes' arrows
16:29:35 * SamB_XP knew that
16:31:40 <axzs> Btw, categories are monoids in the monoidal category (Graph, x, id).
16:31:57 <axzs> however, this won't help
16:34:52 <FunctorSalad_> axzs: I don't quite understand that notation
16:35:08 <FunctorSalad_> products of graphs as the monoidal product?
16:36:09 <dino-> I'm having haddock doc build failure for MissingH v1.1.0 but I don't get why the comment is being rejected.
16:36:35 <dino-> I'll get a paste together..
16:38:15 <FunctorSalad_> Cale: there is ECTS (elementary theory of the cat. of sets)
16:38:43 <FunctorSalad_> the first-order theory of a well-pointed topos with a natural number object
16:39:41 <dino-> Can anyone see why this is failing? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7763
16:40:06 <dino-> Haddock build error on MissingH 1.1.0 source, right out of Hackage.
16:40:15 <FunctorSalad_> (but this is not one of the approaches that use only commuting triangles which you mention)
16:40:49 <axzs> FunctorSalad_: I've written that unclear and not precise, sorry. Let's fix some object O, and consider all graphs with O as vertex set. Define product of two graphs A and B as a graph where arrows are pairs of composable arrows - first from A, second from B.
16:41:15 <aavogt> -- more a more
16:41:17 <aavogt> -- automated solution.
16:42:01 <axzs> FunctorSalad_: and the identity graph, with O as the edge set. This is a monoidal category. A monoid object in there is a category whose objects are O.
16:42:36 <axzs> FunctorSalad_: so, in some sense, categories are monoids over graphs, just like normal monoids are monoids over sets, or rings are monoids over abelian groups.
16:44:23 <axzs> ...commutative monoids are monoids over monoids, monads are monoids over category of endofunctors, algebras are monoids over vector spaces.
16:44:48 <FunctorSalad_> axzs: ok, with that product it makes sense :)
16:44:51 * copumpkin gets haemonoids
16:51:31 <dino-> Oh wow, I bet it's that you can't do the -- ^ style haddock in the guts of a type definition with keyword type.
16:52:03 <vav> dino-: I think it's because of the Either constructor, has to be a record type for -- ^ comments with constructors iirc
16:52:53 <FunctorSalad_> dino-: not in args of non-record-style constructors either IIRC
16:52:56 <vav> oh, it's using [] too I guess
16:53:03 <eflister> dmwit and lilac: ok, i got it: Data.Traversable.mapM ((flip f) y) =<< x
16:53:17 <dino-> It's actually a function type.
16:53:28 <eflister> dmwit and lilac: did you guys have something simpler in mind?
16:53:37 <dino-> I'm like the first person to have built the docs for this in months, looks like!
16:54:10 <eflister> dmwit and lilac and copumpkin: yeah i should have been using capital A and B!  sorry!
16:55:08 <eflister> dmwit and lilac and copumpkin: does  ad-hoc polymorphism refer to implementing classes?
16:55:21 <dmwit> yes
16:56:39 <CalJohn> What is a good way to learn the Core language that GHC uses?
16:56:47 <eflister> dmwit: whoops i meant "instancing" not "implementing" i think
16:57:03 <copumpkin> CalJohn: write some simple haskell you understand and see what it translates to?
16:57:43 <CalJohn> well, i've been doing that a bit, but it's quite hard to learn properly that way.  Is there any definition aroud?
16:58:59 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html#id468571
16:59:50 <copumpkin> who's WDP?
17:00:12 <dino-> Ok, I reported to Cosmic. vav, FunctorSalad_ thanks
17:24:46 <athos> i use ghc 6.10.4 for a few days now, and i ran into some problems concerning control.monad
17:24:49 <athos>       it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
17:24:50 <Saizan_> CalJohn: there are some papers about it
17:24:54 <athos> oops
17:24:59 <athos>    Could not find module `Control.Monad.Reader':
17:24:59 <athos>       it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
17:25:01 <CalJohn> Saizan_: yes, have found them now
17:25:10 <athos> how to resolve that kind of error?
17:25:31 <Saizan_> athos: you can ghc-pkg hide one of the two packages
17:25:35 <athos> i mean, obviously i have to unregister one of those packages. two questions here: firstly, how?, secondly, which?
17:25:37 <Saizan_> athos: or pass -hide-package
17:25:55 <Saizan_> you don't need to unregister, just hide
17:26:25 <Saizan_> and, well, the more popular is still mtl i guess, so you should hide monads-fd probably :)
17:26:37 <athos> ok
17:26:38 <Saizan_> "ghc-pkg hide monads-fd"
17:26:39 <athos> thank you
17:27:07 <athos> hehe
17:27:14 <athos> same for transformers and mtl
17:27:21 <athos> i guess i'll hide transformers here, too
17:27:26 <Saizan_> right
17:28:04 <Saizan_> you can always change/override the choice later anyway
17:28:10 <athos> i see
17:28:58 <Saizan_> or you can make a .cabal file for your package, cabal always hide all the packages except for the ones listed in build-depends
17:34:36 <eflister> ok, if one needs an IO A, but one has an IO Maybe (Either A B), how to lift into both Maybe and Either?   (Data.Traversable.mapM f) =<< x gets me the Maybe, but i am still stuck on the Either.
17:35:15 <Cale> eflister: You mean IO (Maybe (Either A B)) ?
17:35:39 <eflister> Cale: yeah
17:35:43 <Cale> eflister: You'll have to deal with all the error cases, and come up with an appropriate value of type A for each
17:35:55 <Cale> (or else throw an exception in the IO monad)
17:36:06 <eflister> Cale: i'm trying to let the monads do their work
17:36:33 <Cale> Except that there are 3 separate monads here, you need to do something to fit them together.
17:37:02 <eflister> Cale: eg, if the Either layer weren't there, then the code would work -- i just want to do the same thing one more level down
17:37:12 <Cale> Using Maybe as a monad doesn't absolve you of the need to work out what to do with an eventual Nothing result.
17:37:45 <eflister> Cale: doesn't the default Maybe behavior Nothingize any function that gets a Nothing passed in?  isn't that the idea of lifting/monads?
17:37:47 <pikhq> eflister: There's a decent chance you need to rethink your code.
17:37:50 <Cale> What if running the IO (Maybe (Either A B)) gives the result Nothing?
17:38:10 <eflister> Cale: IO Nothing
17:38:11 <Cale> what result will the IO A action that you're after have?
17:38:16 <Cale> IO Nothing?
17:38:26 <eflister> Cale: well i'm new at this, i'm not sure how to write it
17:38:31 <Cale> You seem to have confused something at the type level and something at the value level.
17:38:40 <benmachine> I think we are all fairly confused
17:38:44 <Cale> There's  return Nothing
17:38:51 <benmachine> eflister: maybe if you could pastebin a bit of context it would help
17:38:52 <Cale> :: IO (Maybe t)
17:38:56 <pikhq> Nothing is not a type, it's a value of type Maybe a, anyways.
17:39:24 <eflister> Cale: but i thought the idea was to not rewrite f :: a -> b to have Maybe behavior every time, just lift f into Maybe
17:39:36 <Cale> eflister: I don't understand what you mean.
17:39:47 <Cale> eflister: use liftM/fmap?
17:40:08 <eflister> Cale and pikhq: one doesn't have to specify that f Nothing = Nothing, just liftM f.  yeah.
17:40:28 <Cale> Sure,  fmap f :: Maybe a -> Maybe b  if that's what you want.
17:40:46 <Cale> eflister: What is the type of the function you're after?
17:40:51 <eflister> Cale: right -- now i just need to do that for two levels -- the Maybe level and then an Either level inside that
17:41:00 <Cale> I thought it was  IO (Maybe (Either A B)) -> IO A
17:41:26 <Cale> In order to get something of that type, you need a function  Maybe (Either A B) -> A
17:41:26 <eflister> Cale: right -- the other trick is doing it all inside IO.  the Data.Traversable.mapM does that.
17:41:43 <Cale> fmap does that too
17:42:11 <Cale> If f :: Maybe (Either A B) -> A, then fmap f :: IO (Maybe (Either A B)) -> IO A
17:42:24 <eflister> Cale: hmm, maybe.  the mapM was helping with flipping some ordering of the nesting.
17:42:46 <Cale> I think that's kind of a confusing way to reason about it.
17:42:53 <Cale> What are you actually doing?
17:43:15 <copumpkin> @type \f -> Data.Traversable.mapM f (Just 5)
17:43:16 <lambdabot> forall a (m :: * -> *) b. (Num a, Monad m) => (a -> m b) -> m (Maybe b)
17:43:26 <copumpkin> hm
17:44:02 <aall23> Hi! (Slightly off-topic, sorry.) How do I typeset a nifty ++ in LaTeX?
17:44:28 <eflister> Cale:  :)  ok, so there is a binding to PortMidi out there.  i ask for a default device and get a Maybe Device.  then i use that to open a stream and get an Either Stream Error.
17:44:30 <Cale> aall23: Perhaps stick a \! or two in between two + symbols
17:45:00 <Cale> eflister: You should deal with any possible errors as they occur. Use case expressions to specify what should happen.
17:45:34 <aall23> Cale: \o/ +\!\!+
17:45:44 <aall23> Cale: Thanks!
17:45:45 <eflister> Cale: then i want to write to the stream.  i really like the idea of letting the monads abstract away the error cases rather than special case them and write the same "case Nothing = Nothing" code all the time.
17:45:48 <Cale> aall23: No problem
17:45:49 <dmwit> aall23: You may also be interested in lhs2tex.
17:46:00 <eflister> Cale: it's worked up to now
17:46:14 <eflister> Cale: i'll make a paste bin
17:46:48 <Cale> eflister: Yeah, the problem is that they're not all the same monad. You'll need Maybe Device -> IO Device if you want to produce an IO exception. That's doable.
17:47:06 <Cale> maybeToIO :: Maybe t -> IO t
17:47:33 <copumpkin> :t maybe fail return
17:47:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe (m a) -> String -> m a
17:47:46 <copumpkin> hrm, nope
17:48:12 <dmwit> :t maybe (fail "blah") return
17:48:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
17:51:15 <seydar> greetings: i love haskell
17:51:29 <eflister> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7764
17:51:49 <eflister> Cale: line 48 is where i'm currently dealing with the Maybe (Either)
17:51:58 <Cale> :t maybe (ioError (userError "Nothing")) return
17:52:00 <lambdabot> forall a. Maybe a -> IO a
17:52:18 <Cale> (Note that I don't actually recommend doing that)
17:52:40 <Cale> whoa...
17:52:58 <Cale> f =<< return x  is the same thing as  f x
17:53:21 <eflister> Cale: i was trying to undo my <- 's
17:53:25 <copumpkin> and thus, Cale's identity was born
17:53:34 <Cale> It's just one of the monad laws.
17:53:58 <copumpkin> I prefer my version
17:55:02 <benmachine> that is a long do-block :o
17:55:29 <Cale> benmachine: It's mostly prints though
17:55:39 <benmachine> not that there's anything particularly wrong with long do-blocks I guess
17:56:04 <Cale> eflister: What's the type of stream?
17:56:54 <eflister> Cale: ok i got rid of my =<< return's :0
17:58:14 <Cale> What type are you using T.mapM at?
17:58:49 <eflister> Cale: um, i think it is  IO (Maybe (Either PMStream PMError))
17:59:45 <eflister> Cale: so what would be sweet is for that to just Nothing or PMError as appropriate (tho the api breaks the convention of having error values on the Left)
18:00:09 <benmachine> @hoogle Either a b -> Either b a
18:00:09 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
18:00:09 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
18:00:09 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
18:00:51 * benmachine doubts that is what he was looking for
18:03:06 <Cale> eflister: and PMStream is somehow an instance of Data.Traversable?
18:03:22 <Cale> er, oh
18:03:57 <Cale> You mean stream is still an IO action somehow? No, that can't be right, maybe it's Maybe (Either PMStream PMError)
18:06:12 <Cale> But still, you'll have to unravel the PMStream at some point if you want to do anything with it. It's better to get the errors out of the way up front by using case, I think. It's possible to design some combinator to act on the PMStream underneath those potential errors, but as soon as you want an actual result, you're going to have to specify what you'd like to do about the error case.
18:06:21 <eflister> Cale: the print stream statement works, and prints Just (Left 0x013059c0)
18:06:36 <Cale> okay, so it's Maybe (Either ...)
18:06:56 <Cale> What I would do is immediately unwrap the Maybe and Either.
18:07:47 <eflister> Cale: that makes sense, but how about  we figure out how to make the combinator just to help me learn?  :)
18:08:09 <Cale> Well, we could write it by hand if nothing else:
18:09:12 <Cale> myLift :: (a -> b) -> Maybe (Either a t) -> Maybe (Either b t)
18:09:42 <benmachine> liftLeft?
18:09:46 <Cale> Well, it's an fmap together with something which lifts a function to act on the left part of an Either
18:10:31 <Cale> liftLeft :: (a -> b) -> Either a t -> Either b t
18:10:41 <Cale> liftLeft f (Left x) = Left (f x)
18:10:49 <Cale> liftLeft f (Right y) = Right y
18:10:58 * benmachine reckons there should be a standard library function \x -> case x of Left a -> Right a; Right b -> Left b
18:11:12 <Cale> (this would be fmap if only it were the right portion we were acting on)
18:11:36 <dmwit> :t either Right Left
18:11:37 <Cale> I suppose there's either Right Left
18:11:37 <lambdabot> forall a a1. Either a a1 -> Either a1 a
18:11:38 <dmwit> benmachine: ?
18:11:57 <Cale> :t either Right Left . fmap . either Right Left
18:11:58 <lambdabot>     Couldn't match expected type `a -> b'
18:11:58 <lambdabot>            against inferred type `Either a2 a1'
18:11:58 <lambdabot>     In the second argument of `(.)', namely `either Right Left'
18:12:05 <Cale> :t \f -> either Right Left . fmap f . either Right Left
18:12:06 <lambdabot> forall b a a1. (a -> b) -> Either a a1 -> Either b a1
18:12:21 <dmwit> :t \f -> either (Left . f) Right
18:12:23 <lambdabot> forall b b1 a. (a -> b) -> Either a b1 -> Either b b1
18:12:23 <benmachine> dmwit: i.e. Either a b -> Either b a
18:12:33 <dmwit> benmachine: Yep, exactly.
18:12:37 <benmachine> maybe there is and I've just not heard of it
18:12:53 <dmwit> benmachine: The implementation is so short (see what I wrote above) it's hardly worth it.
18:13:03 <dmwit> :t left
18:13:05 <Cale> :t \f -> fmap (either (Left . f) Right)
18:13:05 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
18:13:06 <lambdabot> forall b b1 a (f :: * -> *). (Functor f) => (a -> b) -> f (Either a b1) -> f (Either b b1)
18:13:10 <benmachine> dmwit: oh I missed that
18:13:43 <Cale> So that  myLift :: (a -> b) -> Maybe (Either a t) -> Maybe (Either b t)
18:13:44 <dmwit> liftLeft = left -- ;-)
18:13:48 <Cale> can be implemented that way
18:14:10 <Cale> dmwit: I knew there had to be something ;)
18:14:11 <dmwit> :t fmap left :: (a -> b) -> Maybe (Either a t) -> Maybe (Either b t)
18:14:12 <Gracenotes> D:
18:14:12 <lambdabot>     Couldn't match expected type `Maybe (Either b t)'
18:14:12 <lambdabot>            against inferred type `a (Either b1 d) (Either c d)'
18:14:12 <lambdabot>     In the first argument of `fmap', namely `left'
18:14:22 <dmwit> oops
18:14:24 <dmwit> :t fmap . left :: (a -> b) -> Maybe (Either a t) -> Maybe (Either b t)
18:14:26 <lambdabot> forall a b t. (a -> b) -> Maybe (Either a t) -> Maybe (Either b t)
18:15:07 <benmachine> @index left
18:15:07 <lambdabot> Control.Arrow
18:15:28 <Cale> So you could go about applying fmap . left to all your functions and deferring handling those errors until later, but it's an awkward mess still
18:15:46 <Cale> Better just to get hold of the genuine values early on.
18:15:59 <eflister> Cale: where is left defined?
18:16:03 <Cale> and report accurate error messages about what went wrong
18:16:05 <Cale> Control.Arrow
18:16:13 <Cale> (oddly enough :)
18:16:18 <benmachine> so it's probably time I learnt about Arrows
18:16:24 * benmachine pokes on the wiki
18:16:35 <Cale> We're (ab)using it here in a trivial way
18:16:56 <Cale> We're using the (->) Arrow instance, which is all nice trivial definitions.
18:17:32 <Cale> Wherever you see (a b c) in the types, just replace that mentally with (b -> c)
18:17:53 <Cale> and the types practically tell you what the functions should do for that case
18:18:08 <Gracenotes> hm.. which data structures would have three or more type parameters...
18:18:24 <benmachine> complicated ones, I expect
18:18:29 <Cale> :k RWST
18:18:31 <Gracenotes> maybe a double map
18:18:31 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
18:18:37 <Gracenotes> not data structure >_>
18:18:51 <dmwit> A priority queue might.
18:18:54 <Gracenotes> like, mapping state to letter to state
18:19:02 <Gracenotes> for automatons... hm..
18:19:35 <Gracenotes> priority queue, eh, I wouldn't have expected that. When would it have more than one?
18:19:40 <Cale> PSQ only has two parameters though
18:19:45 <Cale> http://hackage.haskell.org/packages/archive/PSQueue/1.1/doc/html/Data-PSQueue.html
18:19:47 <dmwit> Well, it certainly has at least key and value.
18:20:05 <dmwit> But, yeah, not really three.
18:20:27 <eflister> Cale: hrm, so that line should be " c <- fmap . left $ stream "?  that's not working...
18:20:32 <Gracenotes> ah, that sort of priority queue
18:21:01 <dmwit> I implemented an automaton once that had arguments for state, alphabet, and monad.
18:21:18 <dmwit> Instantiating the monad to Identity gave DFAs and [] gave NFAs.
18:21:28 <Cale> eflister: no, you have to apply fmap . left to functions which act on stream
18:21:37 <Cale> (before applying them to stream itself)
18:22:04 <Cale> eflister: Like, if you had some transformation PMStream -> PMStream you wanted to apply
18:22:37 <Cale> eflister: Then applying fmap . left to it would give a transformation Maybe (Either PMStream t) -> Maybe (Either PMStream t)
18:22:56 <Saizan_> what about newtype wrapping that type so you can make it a monad?
18:23:43 <idnar> uhm, why isn't that fmap . right?
18:24:04 <Cale> idnar: because the PortMidi library uses the wrong convention
18:24:15 <idnar> oh, okay
18:24:23 <Cale> Saizan_: You could do that, but already, it would be smarter, I think, to pick a richer error monad and project the errors into it more sensibly
18:24:33 <dmwit> With the other convention, it would be fmap fmap fmap!
18:24:57 <eflister> Cale: ok, close :: PMStream -> IO PMError
18:25:09 <idnar> dmwit: fmap fmap return, surely?
18:25:51 <idnar> @type fmap fmap fmap :: (a -> b) -> Maybe (Either a t) -> Maybe (Either b t)
18:25:51 <dmwit> idnar: I don't think so...
18:25:53 <lambdabot>     Couldn't match expected type `b' against inferred type `a'
18:25:53 <lambdabot>       `b' is a rigid type variable bound by
18:25:53 <lambdabot>           an expression type signature at <interactive>:1:24
18:26:00 <dmwit> idnar: Remember: the other convention.
18:26:15 <idnar> dmwit: how do you get from "right" to "fmap"?
18:26:19 <dmwit> :t fmap fmap fmap :: (i -> o) -> Maybe (Either a i) -> Maybe (Either a o)
18:26:21 <lambdabot> forall i o a. (i -> o) -> Maybe (Either a i) -> Maybe (Either a o)
18:26:32 <dmwit> idnar: fmap = right
18:26:36 <dmwit> for the Either monad
18:26:42 * idnar scratches his head
18:26:43 <dmwit> s/monad/functor/   whateeeever
18:26:55 <idnar> @type right
18:26:56 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
18:27:00 <idnar> OH
18:27:05 <idnar> right, not Right
18:27:09 <dmwit> =)
18:27:13 <idnar> temporary insanity there
18:27:39 <eflister> Cale: but     c <- ((fmap . left ) close)  stream   wraps in IO instead of Maybe
18:27:45 <eflister> Cale: which makes sense
18:28:40 <JamesSanders> I'm trying to build a template system (for html and such), is there already something like that, if not what parsing lib would be best for something like this.
18:29:04 <JamesSanders> I'm thinking of sometthing like the template system used by Django
18:29:29 <Cale> eflister: Well... you're writing an IO action.
18:29:43 <Cale> eflister: So the action on each line has to be an IO action too.
18:29:46 <eflister> Cale: yeah i have to do this all inside the IO wrapper
18:29:54 <Cale> Well, you don't have to.
18:30:02 <eflister> Cale: ok... :)
18:30:18 <Cale> as soon as you can get away from doing any I/O, and have a pure processing task
18:30:35 <Cale> But if most of the PortMidi library is in IO, you're a bit out of luck.
18:31:17 <eflister> Cale: definitely -- but the whole point of PortMidi is to send some bytes out of some ports :)
18:31:46 <JamesSanders> hmm maybe I should have given hackage a look before asking my question
18:32:02 <eflister> Cale: i'm just writing the skeleton at this point for getting the data out of the machine -- and to think monadically.  :)  the functional part is easy.  :b
18:32:05 <Cale> JamesSanders: yeah, there's some stuff on there
18:32:41 <codebliss> @pl \a b c d -> (,,) (mod a $ (+1) b) ((/) b a) (foldl (&&) True $ map even [c..d])
18:32:41 <lambdabot> flip flip (((foldl (&&) True . map even) .) . enumFromTo) . (((.) . (.)) .) . ap (ap . ((,,) .) . (. (1 +)) . mod) (flip (/))
18:32:51 <eflister> Cale: note that everything we're doing here is contingent on real world problems (no midi device available, some sort of stream error, etc)
18:33:07 <Cale> eflister: Well, there are places where using a given monad is beneficial. If you have lots of functions to chain together which give Maybe results at each step, then yes, the Maybe monad is appropriate.
18:33:27 <Saizan_> JamesSanders: HStringTemplate and HSP are the ones i know of
18:33:30 <Cale> eflister: But here, you have different representations of failure, which don't compose nicely.
18:33:58 <eflister> Cale: i just read the "let the monad do the work" chapter in RWH so i was excited to at least figure out how to take advantage of it
18:34:04 <Cale> eflister: and you don't really want to hang on to them for very long either -- it would be better to print the error message as soon as possible, and get hold of an actual value in the remaining case
18:34:05 <Saizan_> JamesSanders: there's also the xhtml package, but it's more an edsl to build html than a template system
18:34:34 <eflister> Cale: do you see any way to do what you're suggesting without writing explicit tests for Nothing and Right, etc?
18:34:52 <Cale> Well, I'm suggesting using case expressions which pattern match.
18:35:00 <Cale> So, not really ;)
18:35:15 <eflister> Cale: i'll probably switch to that.  but this is good for my brain.  :)
18:35:33 <codebliss> @pl \a b c -> (a + b,if even a then b `mod` c else b ^ c)
18:35:34 <lambdabot> ap (ap . (((.) . (,)) .) . (+)) ((`ap` (^)) . (ap .) . (. mod) . (.) . if' . even)
18:35:56 <Cale> You could use maybe and either, possibly, but for something like this, where the part inside one of the cases is going to be very large (the rest of the computation), it doesn't help to use those.
18:36:01 <Cale> :t maybe
18:36:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:36:04 <Cale> :t either
18:36:06 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:36:12 <Cale> @src maybe
18:36:13 <lambdabot> maybe n _ Nothing  = n
18:36:13 <lambdabot> maybe _ f (Just x) = f x
18:36:17 <Cale> @src either
18:36:17 <lambdabot> either f _ (Left x)     =  f x
18:36:18 <lambdabot> either _ g (Right y)    =  g y
18:36:36 <Saizan_> @djinn Maybe (Either a b) -> Either (Maybe a) (Maybe b)
18:36:36 <lambdabot> f a =
18:36:36 <lambdabot>     case a of
18:36:36 <lambdabot>     Nothing -> Left Nothing
18:36:36 <lambdabot>     Just b -> case b of
18:36:36 <lambdabot>               Left c -> Left (Just c)
18:36:38 <lambdabot>               Right d -> Right (Just d)
18:36:52 <eflister> Cale: i think there's a way to finish that line inside the IO monad, right?  what am i missing?  this is where i start throwing Data.Traversable.mapM at it without really understanding.
18:37:15 <Cale> which line?
18:38:17 <eflister> Cale: line 48 was the one we were fixing
18:38:36 <eflister> Cale: you're suggesting something along the lines of     c <-  ((fmap . left ) close)  stream
18:39:03 <eflister> Cale: but that wraps w/IO instead of Maybe, as we expect
18:39:11 <Cale> See, the funny thing is that you're not even sure if you've opened the stream
18:39:15 <eflister> Cale: i think we need another layer of fmap to get the Maybe?
18:39:25 <eflister> Cale: to me that's the *cool* part.  :)
18:39:36 <Cale> Well, I guess.
18:39:43 <eflister> Cale: no special cases
18:39:57 <eflister> Cale: that's why i got into this language :)
18:41:53 <Cale> mmm... but this approach will lead to very awkward error handling where you get to the end and either you're not sure where the error originally occurred, or your types are so damn complicated that everything up to that point has become a horrible mess
18:42:38 <Cale> I suppose there are sensible approaches to this.
18:43:10 <Cale> one would be to use the IO monad's built-in exception mechanism
18:43:38 <eflister> Cale: i definitely agree with what you're saying -- like i said, i'm using it to try to understand how to "let the monad do the work"
18:43:41 <Cale> and turn the Maybe and Either errors into exceptions
18:44:00 <Cale> where the IO monad can take care of propagating the error
18:44:10 <eflister> Cale: when i go to write error messages this approach will not be good
18:44:46 <eflister> Cale: i might go with maybe and either to see what that was like
18:45:51 <dolio> :t maybe (Left Nothing) (fmap Just)
18:45:52 <lambdabot> forall a a1. Maybe (Either (Maybe a) a1) -> Either (Maybe a) (Maybe a1)
18:46:22 <eflister> Cale: but right now i want to figure out how to get this Maybe inside that IO.  :)
18:46:49 <dolio> :t maybe (Left Nothing) (Just +++ Just)
18:46:50 <lambdabot> forall a b'. Maybe (Either a b') -> Either (Maybe a) (Maybe b')
18:47:32 <Cale> :t maybe (throw DivideByZero) return
18:47:33 <dmwit> You leftist!
18:47:34 <lambdabot> Not in scope: `throw'
18:47:34 <lambdabot> Not in scope: data constructor `DivideByZero'
18:47:46 <Cale> :t maybe (Control.Exception.throw Control.Exception.DivideByZero) return
18:47:48 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe a -> m a
18:47:55 <dmwit> I'm a rightist sneech.
18:48:01 <Cale> oh
18:48:04 <Cale> :t maybe (Control.Exception.throwIO Control.Exception.DivideByZero) return
18:48:06 <lambdabot> forall a. Maybe a -> IO a
18:48:28 <dmwit> ?unmtl StateT s (Either e) a
18:48:28 <lambdabot> s -> Either e (a, s)
18:48:38 <Cale> So, anyway, that sort of thing would work even with your own exception type:
18:49:37 <Cale> data NoOutputDevice = NoOutputDevice deriving (Show, Typeable)
18:49:45 <Cale> instance Exception NoOutputDevice
18:49:49 <eflister> Cale: yeah i like it -- tho i had the feeling that exceptions were not haskellish.  (i haven't gotten to the error handling chapter yet tho)
18:50:11 <Cale> and then in the midst of an IO block where you have something that gives a Maybe result...
18:50:11 <eflister> Cale: but of course Sound.PortMidi defines all the relevant errors, so i wouldn't want to write my own
18:50:35 <pikhq> Exceptions are inherently monadic.
18:50:38 <Cale> d <- maybe (throwIO NoOutputDevice) return =<< getDefaultOutputDeviceID
18:50:45 <pikhq> And monads are exceptionally Haskellish.
18:50:49 <Cale> Well, yeah, probably.
18:51:08 <Cale> eflister: We have almost too many ways of handling exceptions.
18:51:29 <eflister> Cale: as written, they'd pop out as "Just (Right InvalidDeviceId)" or something, which is pretty straightforward
18:51:39 <Cale> eflister: Compounded with the fact that there are old and new exception libraries floating around :)
18:52:12 <Cale> eflister: Right, but it's just a value, and won't be carried forward automatically in any way like you want.
18:52:51 <Cale> So you'll constantly be putting machinery in place to thread it along.
18:53:26 <eflister> Cale: my understanding is it would propagate through any attempts to use it and prevent, shortcircuiting the non-error code, and pop out the other side?
18:53:38 <Cale> eflister: not automatically, no
18:53:41 <eflister> Cale: that seems like what it would do now.  but i definitely see your point that i'm manually threading it, and that's bad.
18:54:02 <Cale> eflister: Unless you were writing code in the Maybe monad, where it would be somewhat more automatic.
18:54:12 <Cale> (but then you can't do any I/O)
18:54:46 <eflister> Cale: i mean automatic in terms of i don't have to do the pattern matching against Nothing, Left, etc
18:54:47 <Cale> (or the Either monad, but the PortMidi stuff is set up wrong for that)
18:55:02 <Cale> Well, something is doing that pattern matching
18:55:45 <Cale> You can write combinators which sort of help deal with threading it along, but it's not so automatic as what that chapter of RWH is talking about.
18:56:16 <eflister> Cale: right, but it's the standard thing that everyone does with a Maybe or Either, so i want to let the default behavior do the work.  i know you know what i mean and i keep repeating myself.  what insight am i missing about how to be haskellish?  :)
18:56:20 <Cale> (where *all* of the threading-along of errors is handled by >>= alone, in the specific monad)
18:56:59 <Cale> You could, if you want, construct an even larger monad, probably using a monad transformer like ErrorT
18:57:01 <eflister> Cale: i definitely have the sense that the api design pushes me into this manual threading situation
18:57:38 <Cale> Currently, your variables like stream have types which indicate all the errors that might happen.
18:57:41 <eflister> Cale: the author just got back to me today with a redesign but i haven't looked at it yet -- i am interested in the mental gymnastics of learning how to get this Maybe in this IO before i switch to the better way.
18:58:29 <Cale> If you keep going this way, the types of your variables would get more and more complicated and they would get harder and harder to use every time you used them in some other function which possibly failed.
18:58:35 <eflister> Cale: that's a good insight -- it's crazy to nest your type in all the errors you may have experienced
18:59:07 <eflister> Cale: but at the same time i thought a haskeller wouldn't go around writing "f Nothing = Nothing"
18:59:15 <eflister> Cale: there must be a middle ground
19:00:31 <Cale> eflister: Well, if there were any justice in the world, stream :: PMStream, yeah?
19:00:43 <seydar> +1 for the subjunctive!
19:01:20 <Cale> and if there were an error along the way, the computation as a whole would have aborted by that point, and it would be someone else's problem to deal with it
19:01:44 <eflister> Cale: sure, but how to not rewrite default Maybe behavior?  actually in this case, there's not much possibility of passing the objects around and operating on them.  they'll be consuming functional data.
19:02:03 <Cale> eflister: So the idea is to encode the potential errors in the type of the computation as a whole, and not in the types of the individual values.
19:03:02 <eflister> Cale: so collapse Maybe (Either A B) into Either A B...  but how do that without writing f Nothing = Right MyError
19:03:18 <eflister> Cale: i guess i wouldn't mind writing that, since it's not default Maybe behavior
19:03:19 <Cale> eflister: Since you're in the middle of writing 'main', the way to make errors into somebody else's problem is to throw exceptions. The IO monad has an exception mechanism built into it, and will abort the remainder of a computation, passing the exception along to whatever eventually catches it.
19:04:07 <Cale> This is similar, though more intricate, to having a computation produce Nothing in the Maybe monad, or Left e in the Either monad.
19:04:33 <eflister> Cale: you've convinced me.  :)  and i stlll have to get to the error chapter of RWH.
19:05:04 <eflister> Cale: i get the feeling though that you are in principle opposed to my mental exercise of getting this Maybe into this IO right here.  :b
19:05:26 <dmwit> ?index comparing
19:05:26 <lambdabot> bzzt
19:05:33 <dmwit> :t comparing
19:05:34 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
19:05:39 <dmwit> :t Data.Ord.comparing
19:05:41 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
19:06:22 <Cale> eflister: Well, you can do this by writing appropriate combinators and making use of them (or chancing on combinators which are already in the libraries and accomplish the liftings you need), but it'll just get more and more complicated as you go on.
19:07:57 <eflister> Cale: agreed.  the thing i want to feel as second nature is what to do when i see i need a      m a -> m (n a)
19:08:00 <pikhq> eflister: His point is that you're thinking about things wrong, and if you get the though process right, you shall achieve enlightenment.
19:08:03 <Cale> eflister: Even just with these two errors, it's already complicated enough that it takes conscious thought to work out just what functions are needed to make this work. I think you're going to need the equivalent of mapM for Either, but on the left component, so perhaps if you wanted to be sneaky, you could use either Right Left to swap the components, and then do it.
19:08:28 <pikhq> Thought, even.
19:09:00 <Cale> Mind, it's made extra hard by the fact that the Either is swapped around unconventionally.
19:09:21 <ozy`> @pl \l r -> l ++ t r
19:09:21 <lambdabot> (. t) . (++)
19:09:29 <ozy`> @pl \l r -> t l ++ r
19:09:30 <lambdabot> (++) . t
19:09:45 <Cale> eflister: Do you know what mapM does in general?
19:09:53 <Cale> eflister: It's more obvious for lists.
19:10:18 <eflister> Cale: lookin at it now -- made sense when i was reading about it, but don't see the application here...
19:10:23 <ozy`> @pl \t -> t . foldl1 ((++) . t)
19:10:24 <lambdabot> ap (.) (foldl1 . ((++) .))
19:10:31 <Cale> eflister: The mapM for lists takes a function from values to actions to be done, and a list of values, and performs the action corresponding to each of them, collecting a list of the results.
19:10:52 <pikhq> ozy`: Ah, the ap combinator.
19:11:05 <Cale> That is, it's essentially a foreach loop over the list elements
19:11:11 <Cale> eflister: For Maybe, it's the same as lists of length 0 or 1
19:11:42 <Cale> eflister: Same goes for Either, basically, though it applies to the Right component, not the Left.
19:12:04 <Cale> (Left is like the empty list, Right is like the list with one element)
19:12:14 <eflister> Cale: actually, thinking of lists as a monad, it seems more like    m a -> n (m a), rather than   m a -> m (n a)
19:12:46 <Cale> mapM :: (a -> m b) -> [a] -> m [b]
19:13:17 <eflister> Cale: wouldn't it be more like our problem if the output were [m b]
19:13:28 <Cale> You don't want  Maybe (IO b)
19:13:55 <eflister> Cale: ah, right
19:14:28 <JamesSanders> its odd how most the haskell html libs add newlines inside html tags
19:14:34 <Vanadium> What is the deal why are diffarrays so slow >:C
19:15:33 <Cale> Vanadium: Because even if you do use the arrays in a single threaded manner, they still have to update the pointer in the previous array and write a reverse change table.
19:15:50 <Vanadium> Okay, that is why I figured.
19:15:54 <Zao> JamesSanders: It's a nice way of avoiding accidental meaning of whitespace.
19:15:57 <Cale> Vanadium: So you pay a heavy constant factor for that O(1)
19:16:00 <Zao> JamesSanders: <textarea> is a fun one.
19:16:10 <Vanadium> I hoped it could do all that with a huge amount of laziness
19:16:38 <Saizan_> you might get better results by sticking to UArrays
19:17:00 <Vanadium> For my toy program, I actually went back to lists and changed the structure slightly.
19:17:22 <Cale> Actually, I've found DiffArrays to perform surprisingly well in cases where I *did* have to go back and look at previous versions, just not so regularly.
19:17:49 <Cale> But it depends a great deal on the exact access pattern whether it works out for you.
19:18:26 <JamesSanders> Zao: yeah I guess I can see how that makes sense now
19:18:40 <Cale> Or there's always Data.Map/Data.IntMap
19:19:07 <Vanadium> I had really hoped that, say, ghc would be able to detect that no one holds another reference to the array and would just rewrite the whole thing into straight modifications
19:20:50 <Saizan_> mmorrow: ping?
19:23:54 <seydar> mmorrow: do you have a blog?
19:25:12 <copumpkin> zomg a seydar
19:28:57 <seydar> copumpkin: you on campus?
19:30:01 <gwern> seydar = cider?
19:30:03 <gwern> Mmm....
19:32:00 <nicoDividido> hi
19:32:39 <seydar> gwern: seydar = most awesome cleric i ever played in D&D 3.x
19:32:40 <nicoDividido> what is the purpose of +++ in ParseLib
19:33:03 <seydar> gwern: pronounced like "seder" plate during passover
19:33:16 <gwern> his god was yahweh?
19:33:32 <Zao> nicoDividido: Probably something like http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html#v:+++
19:34:46 <hackagebot> nntp 0.0.2 - Library to connect to an NNTP Server (MaciejPiechotka)
19:35:49 <nicoDividido> don't know
19:36:24 <nicoDividido> code3 :: Parser
19:36:24 <nicoDividido> code3 = do char '!'
19:36:24 <nicoDividido>            d <- digit
19:36:24 <nicoDividido>            char 's'
19:36:24 <nicoDividido>            do s <- many (do char 's')
19:36:25 <nicoDividido>               return "Suc"
19:36:27 <nicoDividido>           +++ do char '%'
19:36:29 <nicoDividido>                  d <- char 's' digit
19:36:31 <nicoDividido>                  do s <- many (do digit)
19:36:32 <dmwit> ack
19:36:33 <nicoDividido>                     return "Suc"
19:36:47 <dmwit> In the future, please use hpaste. =)
19:36:51 <dmwit> ?hpaste
19:36:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:37:02 <nicoDividido> sorry
19:37:44 <dmwit> +++ is likely the "choice" operator, though I can't know for sure.
19:37:48 <dmwit> Isn't there documentation?
19:38:24 <nicoDividido> I've found ParseLib.hs code, but I can't understand it
19:38:26 <seydar> the HWN is the awesomest piece of fine literature evah
19:38:57 <nicoDividido> http://www.fi.muni.cz/usr/skarvada/vyuka/IA014/ParseLib.hs
19:39:16 <dmwit> +++ does, indeed, seem to be the choice operator.
19:39:28 <dmwit> Actually, it's a bit more specific than that.
19:39:40 <dmwit> It acts as the *first* parse success of either of its operands.
19:40:04 <dmwit> So if either of them happen to have multiple successes, only one will propogate through a +++.
19:40:28 <nicoDividido> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7766#a7766
19:40:50 <dmwit> yep
19:41:05 <jaredj_> The types with the curly braces and named members - those are officially 'record types' right?
19:41:13 <dmwit> yes
19:41:19 <jaredj_> kthx
19:41:23 <eflister> Cale: hm, trying to play w/ mapM.  to come up with a toy (a -> m b) i was trying to use an fmap.  can't get it to work, but seems like there should be a way to do it:  mapM (fmap odd) [Right 5, Right 2, Left 7]
19:41:49 <dmwit> That looks like a normal map.
19:42:00 <dmwit> > map (fmap odd) [Right 5, Right 2, Left "foobar"]
19:42:02 <lambdabot>   [Right True,Right False,Left "foobar"]
19:42:04 <seydar> copumpkin: what ah ye doing this summah?
19:42:09 <nicoDividido> which of them will propagate through +++?
19:42:22 <dmwit> nicoDividido: yes
19:42:23 <eflister> dmwit: so it is...
19:42:24 <dmwit> ;-)
19:42:27 <nicoDividido> if both, the first?
19:42:31 <dmwit> nicoDividido: Right.
19:42:50 <dmwit> nicoDividido: And even more: if the first succeeds several ways, only its first success.
19:43:31 <seydar> i have a question about dons
19:43:39 <seydar> this isn't the reverend, right?
19:44:05 <eflister> dmwit: what's a good toy (a -> m b) i can use to get the hang of using mapM's on Eithers?  i can't think of one for some reason...
19:44:06 <seydar> i can't find anyone else on google
19:44:41 <nicoDividido> and what happen if this fails and it is inside another monad
19:45:19 <seydar> i'd like my last statements to be retracted from the record of the logs please
19:45:38 <dmwit> > let f x | x > 0 = Right (product [1..x]) | otherwise = Left "can't factorial a negative" in mapM f [Left "already had an error", Right 3, Right (-5)]
19:45:39 <lambdabot>   No instances for (GHC.Enum.Enum
19:45:39 <lambdabot>                      (Data.Either.Either [G...
19:45:43 <ozy`> seydar: redacted?
19:46:31 <dmwit> :t mapM
19:46:32 <seydar> ozy`: CAN IT BE DONE
19:46:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:46:41 <ozy`> seydar: \O_o/
19:47:19 <dmwit> oh, right
19:47:28 <dmwit> > let f x | x > 0 = Right (product [1..x]) | otherwise = Left "can't factorial a negative" in mapM f [3, 4, 5]
19:47:29 <lambdabot>   Right [6,24,120]
19:47:31 <dmwit> > let f x | x > 0 = Right (product [1..x]) | otherwise = Left "can't factorial a negative" in mapM f [3, 4, -5]
19:47:33 <lambdabot>   Left "can't factorial a negative"
19:48:15 <jaredj_> @faq CAN HASKELL REDACT IRC LOGS?
19:48:15 <lambdabot> The answer is: Yes! Haskell can do that.
19:48:20 <dmwit> seydar: Congratulations, you will forevermore look like an idiot on tunes.org.
19:49:54 <seydar> fml
19:51:29 <wmealing_> thats nothing, i can look like an idiot anywhere.
19:51:37 * mle t mapM
19:51:47 <mle> aah, great, need a colon
19:52:20 <dmwit> Yes, a colon, and less /me. ;-)
19:52:41 <dmwit> ...and in privmsg, :t doesn't work; only ?type.
19:52:41 <mle> my : does /me at the beginning of a line.  ...long story.
19:52:54 <dmwit> Ah, that seems handy everywhere but here.
19:53:01 <mle> just so
19:53:29 <Ytinasni> ?type id
19:53:31 <lambdabot> forall a. a -> a
19:53:34 <Ytinasni> :D
19:53:39 <mle> well that works.
19:54:00 <dmwit> ?ty id -- slightly shorter
19:54:02 <lambdabot> forall a. a -> a
19:54:58 <bd_> :t id
19:55:00 <lambdabot> forall a. a -> a
19:55:38 <eflister> dmwit and Cale: thanks for your help -- i still don't have it but gotta take a break.
19:55:40 <eflister> Cale++
19:55:43 <eflister> dmwit++
19:57:53 <Gracenotes> !botsnack
19:57:59 <seydar> fare thee well e'erybody
19:58:03 <seydar> > botsnack
19:58:05 <lambdabot>   Not in scope: `botsnack'
19:58:29 <seydar> > let botsnack = putStrLn "thank you e'erybody" in botsnack
19:58:31 <lambdabot>   <IO ()>
19:58:36 <seydar> > let botsnack = "thank you e'erybody" in botsnack
19:58:37 <lambdabot>   "thank you e'erybody"
19:59:02 <seydar> > let botsnack = "thx 3vrbdy" in botsnack
19:59:03 <lambdabot>   "thx 3vrbdy"
20:00:05 <jmcarthur> @botsnack
20:00:05 <lambdabot> :)
20:00:05 <lunabot>  :)
20:03:25 <jaredj_> two bots eh. so if i have Text.OFX1 which imports Text.OFX1.Foo, how do i get my Zaxx module that imports Text.OFX1 to see everything in Text.OFX1.Foo as well?
20:04:22 <dmwit> import Text.OFX1; import Text.OFX1.Foo
20:04:38 <dmwit> Or, you may choose to export Text.OFX1.Foo from Text.OFX1 if you like.
20:04:54 <jaredj_> that's what i think i want to do
20:04:56 <dmwit> module Text.OFX1 (Text.OFX1.Foo, etc etc) where; import Text.OFX1.Foo
20:05:06 <jaredj_> oh ok cool.
20:05:11 <dmwit> err
20:05:21 <jaredj_> yes i'm factoring things out into multiple files you see
20:05:22 <dmwit> module Text.OFX1 (module Text.OFX1.Foo, etc etc) where ...
20:06:40 <jaredj_> i would ask for advice about the factoring but it's easier to show an example and ask whether it's good i think
20:10:45 <Vanadium> If I explicitly import [qualified] Prelude [...], does it override an implicit unqualified import, or how does it work?
20:11:19 <ozy`> Vanadium: that is exactly what it does
20:11:44 <Vanadium> Thank you
20:14:27 <shapr> blackdog: y0
20:14:46 <blackdog>  heya shapr
20:15:05 <shapr> Haven't had a chance to check TBC yet, but I'm keeping it in mind.
20:15:11 <blackdog> thanks mate
20:15:19 <blackdog> think i'm giving a talk on it at fp-syd in august
20:15:31 <blackdog> maybe pete too, if i can convince him to come out in public :)
20:15:49 <shapr> cool
20:15:55 <dmwit> blarg
20:15:59 <shapr> You showing up at the next Boston Area Haskell User's Group?
20:17:19 <ozy`> shapr: when is that?
20:20:43 <blackdog> if it's the one in boston, i can't make it :)
20:20:52 <shapr> too bad
20:20:58 <shapr> ozy`: Um, next coupla weeks?
20:21:22 <shapr> I forget.
20:24:31 <copumpkin> @tell edwardk need moar edwardk
20:24:31 <lambdabot> Consider it noted.
20:26:56 <Saizan_> copumpkin: did you get some edwardk recently?
20:27:08 <copumpkin> no, but I've wanted to
20:27:09 <nicoDividido> does many matches 0 or more
20:27:14 <nicoDividido> or one or more
20:27:15 <nicoDividido> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7769#a7769
20:28:20 <nicoDividido> in ParseLib
20:30:57 <copumpkin> nicoDividido: looks like many is 0 or more
20:31:01 <copumpkin> and many1 is 1 or more
20:33:08 <gwern> copumpkin: as we are haskellers, there's a little edwardk in us all
20:33:21 <copumpkin> :)
20:33:30 <shapr> I got five days of edwardk this past weekend at hac phi.
20:33:38 <nicoDividido> but many is made from many1...
20:33:40 <copumpkin> damn you depleted him
20:33:47 <shapr> No, I think I got depleted actually.
20:33:53 <copumpkin> nicoDividido: yeah and many1 is made from many :P
20:33:54 <shapr> I'm still exhausted.
20:33:56 <Badger> Five days in a weekend?
20:34:08 <nicoDividido> this is going to blow my mind
20:34:11 <jmcarthur> wow, i didn't read up high enough and took that entirely out of context
20:34:20 <copumpkin> :P
20:34:45 <jmcarthur> wow, actually, reading up higher didn't make it any better
20:35:55 <nicoDividido> now I got it, in many1 is different because it assigned directly p to x, so at least the head of the list should match
20:36:20 <nicoDividido> what is the meaning of force?
20:36:44 <copumpkin> use the force, luke
20:37:20 <shapr> jmcarthur: Mentally!
20:37:23 <nicoDividido> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7769#a7770
20:37:32 <shapr> jmcarthur: Dude, edwardk had like a 26 hour coding binge.
20:37:51 <shapr> He started at 3am, while I was trying to sleep.
20:38:20 <Badger> what did he achieve?
20:39:07 <Saizan_> nicoDividido: it seems force forces the given parser to have at least one result
20:39:09 <copumpkin> moar monoidz
20:39:38 <shapr> Badger: Much of kata was implemented.
20:39:51 <Badger> woo
20:40:19 <shapr> I'm hoping for an alpha release soon.
20:40:21 * copumpkin badgers Badger
20:40:23 <gwern> what is kata?
20:40:37 * Badger transforms copumpkin 
20:40:42 <nicoDividido> so the meaning of many then is, you put nothing, 1 or many characters X
20:40:58 <Phyx-> man, someone just said Haskell's syntax is ugly compared to OCaml....
20:41:00 <nicoDividido> if you put character Y, then it would brake the monad flow
20:41:03 <nicoDividido> right?
20:41:07 <copumpkin> Phyx-: ZOMG
20:41:13 <shapr> Phyx-: Did you laugh at them?
20:41:26 <gwern> Phyx-: be sure to ask them about how to add some numbers]
20:41:37 <shapr> gwern: Kata is edwardk's lazy, pure, functional, mostly untyped language.
20:41:38 <Phyx-> shapr worse, i tried to talk some common sense into them :(
20:41:39 <Phyx-> failed
20:41:44 <shapr> Phyx-: Yeah, I can see that.
20:42:20 <gwern> shapr: wait, untyped? why?
20:42:31 <gwern> also, isn't that just a variant on scheme? :)
20:42:47 <Saizan_> nicoDividido: well if p parses X then "many p" will return an empty list if you give it Y as argument
20:43:50 <nicoDividido> that's ok, I have to go to sleep
20:43:57 <nicoDividido> bye guys
20:44:02 <nicoDividido> take care
20:44:11 <ozy`> shapr: where can I see this language?
20:44:36 <ozy`> (since edwardk doesn't seem to be here)
20:45:11 <shapr> It's not released yet.
20:45:20 <shapr> gwern: Nah, scheme isn't lazy & pure.
20:45:52 <Nafai> Isn't it hard to have a pure, mostly-untyped language?
20:45:54 <jaredj_> so no one's seen it, you just kata glimpse?
20:45:59 <shapr> hah
20:46:03 <ozy`> scheme would have been lazy in a parallel universe where everything you see on Doctor Who actually exists
20:46:04 <shapr> Actually, I'm working on the pretty printer.
20:46:19 <shapr> Nafai: Yeah, usually. But Kata is a bit different...
20:46:19 <ozy`> but it still wouldn't have been pure
20:46:40 <Nafai> I guess it's hard to think of a "pure" language and not associate it with the other characteristics of Haskell
20:48:26 <Saizan_> Nafai: just don't put any primitives for doing IO and you're set :)
20:48:38 <pikhq> Nafai: Define "untyped".
20:48:53 <pikhq> Untyped, as in the untyped lambda calculus?
20:49:02 <pikhq> That's trivial.
20:49:14 <Nafai> Saizan_: Sweet, the ultimate space-heater language.
20:50:00 <Saizan_> Nafai: nah, you can still evaluate expressions in a REPL
20:51:26 <copumpkin> shapr: is the syntax clean?
21:15:10 <edwardk1> dumb question, er, where is the call for system(3) in Haskell? or do i just need to make a cheesy ffi binding?
21:16:03 <ozy`> er, is there one?
21:16:07 <edwardk> no idea =)
21:16:07 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
21:16:14 <copumpkin> zomg
21:16:29 <monochrom> System.Process should have something like system(3) IIRC
21:16:45 <copumpkin> shell?
21:16:56 <copumpkin> hmm maybe not
21:17:05 <ozy`> rawSystem?
21:17:11 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html#v%3Asystem
21:17:17 <edwardk> there it is
21:17:36 <monochrom> It even has the desired name :)
21:17:42 <copumpkin> @hoogle system
21:17:42 <lambdabot> System.Cmd system :: String -> IO ExitCode
21:17:42 <lambdabot> module Distribution.System
21:17:42 <lambdabot> package system-inotify
21:17:50 <copumpkin> System.Cmd? :o
21:17:53 <edwardk> hoogle et al couldn't seem to find it
21:17:54 <copumpkin> never come across that
21:18:00 <edwardk> strange
21:18:16 <monochrom> In the old hierachy it was Process.system
21:19:17 <bmoll8> hey guys; I was looking for a good comparison online of haskell and matlab; I will need to learn a programming language suitable for approximating solutions to pdes, and wanted to see which one would be better to pick up
21:19:51 <edwardk> now to get all my dependencies to play nice ;)
21:20:08 <ozy`> bmoll8: well, haskell is general purpose, and matlab isn't, IIRC
21:20:10 <copumpkin> edwardk: when do we get to a see a sample of your secret language?
21:20:23 <edwardk> copumpkin: re why i haven't been around much i've been off working on my kata compiler again. put together a nice little monoidal lexer
21:20:57 <edwardk> copumpkin: its not very secret i've been shouting the secrets here on channel forever ;)
21:20:57 <copumpkin> the kata compiler should be called morphism
21:21:01 <copumpkin> :P
21:21:07 <copumpkin> what does it look like? :D
21:21:17 <edwardk> <- went boring and the executable is currently er... 'kata' ;)
21:21:25 <edwardk> the syntax or the compiler? =)
21:21:29 <copumpkin> syntax :P
21:21:33 <edwardk> hah
21:21:44 <edwardk> lemme see if i still have a link to an old sample file of it
21:22:47 <bmoll8> ozy`: what do you mean by general purpose
21:23:11 <bmoll8> ozy`: ultimately I am trying to avoid losing time; for example, I am a lover of freebsd--it is possible to use as a desktop, but after some pain
21:23:31 <copumpkin> bmoll8: if you strive for elegance and are thinking of matlab, look elsewhere ;)
21:23:47 <copumpkin> it's succinct when working with matrix and vector operations
21:23:50 <copumpkin> the rest feels like a hack
21:23:51 <bmoll8> I am striving to have all necessary libraries to code what I need to code
21:23:52 <ozy`> bmoll8: haskell is suited for writing basically any arbitrary program.
21:23:57 <edwardk> copumpkin: http://comonad.com/Category.ks-old has a syntax fragment, but its a bit dated. there has been some linguistic drift in the meantime, but not much
21:24:12 <bmoll8> ozy`: i am looking to find solutions to pde's numerically
21:24:40 <ozy`> bmoll8: what's a PDE?
21:24:43 <bmoll8> from what I can tell on the haskell website, libraries seem to be scarce for mathematicians outside of logic and similar fields
21:24:44 <copumpkin> edwardk: unifies = rewrite rules?
21:24:50 <bmoll8> ozy`: partial differential equation
21:24:58 <ozy`> bmoll8: ah, gotcha
21:25:04 <edwardk> in particular the syntax for the ensures pragmas is nicer, forall f. id . f = f has become f -> id . f = f
21:25:10 <edwardk> yeah
21:25:12 <edwardk> er
21:25:13 <edwardk> no
21:25:17 <edwardk> ensures = rewrite rules
21:25:34 <edwardk> unifies actually says attempting to define the two things differently is a compile time error
21:25:55 <edwardk> i.e. you can't even try to make an optimized endofunctor with domain /= codomain
21:26:06 <wmealing_> eww, matlab indexing is 1 based.
21:27:01 <davidL> w 25
21:27:20 <copumpkin> edwardk: interesting
21:27:26 <copumpkin> wmealing_: yeah :/
21:28:42 <edwardk> copumpkin: basically giving up types meant giving up typeclasses so classes act like module signatures, and objects get used like modules. traits (the adjectives you see named in class definitions) are applicable to subclasses and provide context-sensitive meaning, all class definitions that match get applied, so it favors deep class hierarchies with small extensions at each layer.
21:29:08 <ozy`> edwardk: is "epic" a keyword with a not-terribly-intuitive meaning (for someone who doesn't know category theory)?
21:29:20 <copumpkin> ozy`: an epic morphism!
21:29:37 <copumpkin> edwardk: why'd you go with no types?
21:29:39 <monochrom> epic success
21:29:53 <edwardk> ozy`: it is an adjective (trait) being applied to the class. it has no intrinsic meaning other than what is given in that definition
21:30:04 <edwardk> copumpkin: the category of small categories can be a category. ;)
21:30:05 <copumpkin> class optimized monad : pointed functor
21:30:13 <copumpkin> optimized?
21:30:30 <edwardk> see the definition for optimized functor, it tells the functor about its domain and codomain.
21:30:47 <copumpkin> oh
21:30:59 <copumpkin> so you optionally give it some typing information?
21:31:10 <edwardk> an optimized monad inherits optimized endofunctor, so it knows that both of those are unified with a single category named carrier, and opens it privately so the definitions can locally use . and id unqualified
21:31:28 <edwardk> more like i give it a field that you can use to get to that information.
21:31:56 <copumpkin> ah
21:32:23 * copumpkin taglia riomare1 con un grissino
21:32:54 <edwardk> an optimized functor can express the rewrite rules for the functor laws... but this is somewhat in tension with defining the category of small category as a category with objects as functors. the identity functor doesn't 'know' its domain/codomain as implemented, because that would require id to take a subscript indicating the object it is being applied to like in normal category theory
21:33:31 <edwardk> to avoid id picking up arguments, and me having to plumb insane #s of bull!@#*( arguments to every method in the category theory library, i separated functor from optimized functor
21:34:28 <copumpkin> :o
21:34:31 <edwardk> so you can have applicative functors, and even a category of applicative functors, but if you want to do nice rewrite rules for them you really want an optimized applicative functor
21:34:47 <edwardk> so on and so forth
21:35:28 <edwardk> there are types, they just don't prove you don't get stuck... merely that you've defined everything you said you'd define and that you have no contradictory unresolved definitions that you inherited when making your object
21:35:53 <edwardk> so i typecheck 'new' object construction/marking data types with class information, but i don't check method dispatch
21:36:18 <edwardk> and you trade in module qualification for newtype noise
21:37:17 <edwardk> currently it lives as a quasiquoter in haskell, so you can antiquote out to haskell to do hygienic macro expansion, etc.
21:37:41 <edwardk> (stealing a trick from sclv for the hygiene)
21:38:08 <copumpkin> ah
21:39:08 <edwardk> right now i'm ripping apart a lot of the surface of things to try to plug in a new monoidal lexing framework that recognizes the layout rules, and balances parens, etc. which lets me run most of the parsing in parallel. its not really NEEDED, but since i plan on giving another talk on monoidal parsing soon, i thought it'd be a nice showcase
21:39:17 <edwardk> parsing a haskell like language in parallel with layout, etc.
21:39:55 <copumpkin> I see :)
21:40:27 <edwardk> a nice side effect of this style of parser is it makes error resumption nice and if i'm careful about it can make refactoring browsing easy to work on, etc. the lexer can unlex to the original source file at each stage so its easy to verify, etc.
21:40:41 <copumpkin> ooh
21:40:42 <edwardk> (modulo spacing at the ends of lines and having expanded tabs)
21:41:11 <dmwit> Out of curiosity, how often does parsing take a significant part of compilation/interpretation time?
21:41:21 <edwardk> dmwit: it doesn't really ;)
21:41:27 <dmwit> okay =)
21:41:39 <copumpkin> but it's nice to have it be fast for syntax highlighting in text editors :P
21:41:39 <dmwit> Good thing you're parallelizing it, then. ;-)
21:41:40 <edwardk> but the key is that by recognizing that structure i can _reparse_ instantaneously
21:41:47 <dmwit> right
21:41:54 <edwardk> parallelism is a side effect
21:42:06 <dmwit> Oh, right, the point isn't for compilation/interpretation.
21:42:06 <dmwit> duh
21:42:14 <edwardk> its for editing/refactoring/etc
21:42:17 <dmwit> I remember asking myself this last weekend and answering it this way. =P
21:42:26 <edwardk> all the other things a modern compiler is expected to do these days
21:42:37 <edwardk> so i want to see if i can make the framework that supports those things nicely
21:42:52 <edwardk> i.e. partial typechecking/inference even in the presence of major syntax errors, etc.
21:43:24 <edwardk> which i can do because by pre-separating out the 'skeleton' of the grammar in the lexer, i can nicely find statements, and see what statements are affected
21:43:36 <edwardk> plus all source position information is stored relatively
21:43:50 <edwardk> so i don't need to 'relocate' errors on editing, they just reflow
21:44:11 <edwardk> its not perfect i'll admit i've been using a bunch of adhoc mechanisms
21:45:31 <copumpkin> edwardk: would this work only for context-free languages?
21:46:03 <edwardk> no, because only the skeleton needs to be parsed context free. once it is the rest of it can be parsed with a monadic parser ala parsec.
21:46:17 <edwardk> but you can apply those to local fragments, etc.
21:46:50 <edwardk> commonly you can match a pretty solid context-free skeleton for practical languages.. because they want nice error productions
21:47:06 <copumpkin> sounds nice :)
21:47:13 <edwardk> it doesn't have a clean metatheory, but i have the parsimony stuff for the cleaner version
21:47:25 <edwardk> this was mostly me just deciding to hack my current obsessions together ;)
21:48:40 <copumpkin> hah
21:49:37 <copumpkin> edwardk: so I had a question for you... ;)
21:49:52 <edwardk> copumpkin: http://comonad.com/LexerSample.hs covers everything before the bitonic merge of layout and dyck language superstructure
21:50:04 <edwardk> for more you'll have to come to the talk in August ;)
21:50:06 <edwardk> shoot
21:50:11 <copumpkin> zomg you hardcoded the tab width
21:50:17 <edwardk> hah
21:50:18 <edwardk> <- evil
21:50:25 <copumpkin> I will come in august, I promise :P
21:50:41 <edwardk> i did think about doing a prepass to hunt for a vim modeline and setting it that way ;)
21:51:27 <copumpkin> edwardk: I've brought this up before, but was wondering if you saw any magic recursion beauty in http://en.wikipedia.org/wiki/Belief_propagation :P it's a reasonably simple concept but I've been trying to think of a nice way to express it
21:52:19 <copumpkin> pretty much all pseudocode and implementaitons I've seen for it are massively stateful
21:52:23 <edwardk> graphs are generally a bad sign for the use of pretty recursive combinators ;)
21:52:29 <copumpkin> ah
21:52:53 <edwardk> sclv: are you around?
21:53:36 <edwardk> @tell sclv the jmacro hoas-template-haskell hack is awesome! i'm using it er... everywhere now
21:53:36 <lambdabot> Consider it noted.
21:55:35 <copumpkin> there must be a good way to deal elegantly with graphs
21:55:46 * copumpkin goes back to pondering
21:56:17 <dmwit> Well, there's Data.Graph.
21:56:20 <edwardk> jmacro quasiquotes have access to javascript variables as haskell variables because they translate in and out of hoas during the template haskell expansion. i need to do the same thing but its trickier for kata because my lexical scoping rules aren't the same as haskell's (classes bring lots of stuff into scope from superclass definitions, etc.) so i have to do the first pass of compilation/typechecking before i can
21:56:21 <edwardk> yeah
21:56:21 <dmwit> But it's not particularly elegant.
21:56:36 <copumpkin> dmwit: yeah :/ I've played with it and it doesn't feel quite right
21:56:42 <copumpkin> same with fgl
21:56:54 <dmwit> Yep, it's the brute-force approach to API design, somehow.
21:57:11 <edwardk> it does 'just work' though, so there is something to be said for that
21:57:34 <dmwit> Also, I was disappointed that I couldn't do edge-labelled graphs at all.
21:57:44 <copumpkin> yeah
22:44:42 <Cynner>   http://www.lostworlds.lv/go.php?1139723800
22:45:38 <edwardk> @seen bos
22:45:39 <lambdabot> I saw bos leaving #ghc, #haskell and #haskell-in-depth 42m 17s ago, and .
22:45:44 <copumpkin> lost worlds is ex-soviet russia
22:45:46 <copumpkin> but the game still plays you
22:46:03 <wmealing_> life seems to play me.
22:47:14 <edwardk> hrmm. i have a horrible hack in mind and i'm trying to figure out the best way to express it
22:48:43 <edwardk> i have a lot of cases when i am parsing a source file monoidally where i wind up appending/consing back together neighboring chunks of the same Text string. I'm trying to figure out if there is a clean way I can glue them together by hacking access to Data.Text.Internal or Data.Text.Array
22:48:57 <edwardk> and then just merge their offsets/length
22:49:03 <copumpkin> ooh you're using Data.Text
22:49:10 <edwardk> if they reference the same ByteArray#
22:50:19 <edwardk> that will let me do O(1) appends for most of my append operations since most of my tokens don't straddle the boundaries of my little text chunks that i feed into the fingertree
22:50:35 <copumpkin> that seems reasonable
22:50:41 <copumpkin> unsafeAppend :P
22:50:54 <edwardk> the other option is i can just make a left to right 'Text' lexer than does the right thing with the slicing operations
22:51:03 <edwardk> and then it'll just use the monoid from there
22:51:07 <copumpkin> edwardk: he just tweeted something :P you could try to fit your question into a tweet
22:51:12 <edwardk> hah
22:51:40 <edwardk> i think the 'correct' answer is to slice up a Text in a more intelligent fashion than I do now
22:52:20 <dufft> hello people please help a noob! i ran into error running one of the first examples from YAHT http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3121#a3121 what am i doing wrong?
22:52:45 <edwardk> then most of my text fragments will share their representation with the small fragments of the initial source file and i don't need any hacked internals
22:53:52 <copumpkin> dufft: use ghc --make
22:53:54 <copumpkin> not just ghc
22:55:25 <dufft> copumpkin, thanks!
22:58:25 <edwardk> gah, because of surrogate pairs Data.Text actually doesn't have a fast slice operation =(
22:58:36 <bmoll8> hey guys...just getting into haskell. I have been impressed so far by the number of math libraries that seem to exist. Is there any language out there with as wide a variety of mathematics libraries?
22:59:06 <edwardk> bmoll8: probably not, unless you count C/Fortran ;)
23:00:14 <bmoll8> edwardk: c doesn't seem to have that many, other than cmath
23:00:21 <copumpkin> edwardk: convert it all to UCS4 first ;)
23:00:30 <bmoll8> edwardk: what other math library is there for c?
23:00:55 <dmwit> gmp?
23:01:01 <edwardk> bmoll8: depends on what you want to do but yacas, octave, gsl, gmp, etc.come to mind
23:01:18 <dmwit> mathematica
23:01:21 <edwardk> and there is all the blas/etc stuff
23:01:28 <copumpkin> don't forget PBC ;)
23:01:38 <copumpkin> (my adopted pet library)
23:01:48 <edwardk> hrmm i think i can fix my Text parser by abusing groupBy
23:02:09 <leeda> are a lot of haskell coders mathematicians?
23:02:28 <edwardk> hah this groupBy is one of the cases where groupOn would be noticably more efficient. luqui would be so proud.
23:02:41 <edwardk> leeda: some of us, but by no means all
23:02:42 <copumpkin> leeda: I think it tends to attract people who are into pure math, but I doubt many are actually mathematicians
23:03:01 <leeda> ah ok
23:03:22 <edwardk> i pretend to understand math, but i've been a programming geek for too long to ever be a real mathematician
23:04:12 <wmealing_> edwardk, you're over 12 ?
23:04:18 <wmealing_> waaay past your prime.
23:04:21 <bmoll8> edwardk: octave seems to be what I needed
23:04:30 <copumpkin> edwardk is over 9000!!!
23:04:34 <bmoll8> edwardk: has support for differential equations:)--does Haskell have anything like this?
23:04:39 <copumpkin> bmoll8: oh no
23:04:40 * wmealing_ crushes an electronic device in his hand
23:04:46 <copumpkin> edwardk: octave is just matlab
23:04:52 <copumpkin> I mean
23:04:54 <copumpkin> bmoll8:
23:05:08 <edwardk> wmealing_: =)
23:05:08 <wmealing_> bmoll8, i hear people complain that "octave is not like matlab"
23:05:21 <wmealing_> bmoll8, i dont know enough.. tbh.. just a heads up
23:05:53 <wmealing_> has anyone here written any web code in haskell, i'm trying to make a decision on which webframework to play with.
23:05:54 <bmoll8> but wait...octave provides c++ classes
23:06:17 <edwardk> bmoll8: yeah there are a number of little libraries for it, not sure that there is any one that i would use. sclv has a nice little library and unpublish(ed/able?) paper about it that really uses Haskell nicely
23:06:41 <SamB_XP> I was pretty sure octave was exactly like matlab -- except probably with less libraries ;-P
23:06:51 <edwardk> wmealing_: mmmdonuts did a nice presentation on using GitIt for general purpose web programming =)
23:07:00 <SamB_XP> and, you know, less primitives probably as well ;-)
23:07:33 <wmealing_> edwardk, was the talk/presentation recorded anywhere ?
23:07:40 <edwardk> er but it isn't available online, basically he just hacked away at some of the superstructure for it so he could use the machinery
23:08:02 <wmealing_> ok
23:09:11 <bmoll8> edwardk: little libraries for haskell?
23:10:03 <edwardk> mmmdonuts = Anton von Straton (sp?) gave the talk at Hac Phi, nothing there was recorded though =(
23:10:43 <edwardk> bmoll8: yeah none of the names come to mind because they are all toy examples =)
23:11:08 <bmoll8> it seems like I have no choice but to use matlab then
23:11:15 <bmoll8> sad, since I am really liking haskell
23:11:32 <bmoll8> my favorite programming language so far
23:11:46 <edwardk> bmoll8: keep at it and you'll find more uses for it =)
23:12:32 <bmoll8> meh---I need to find approximate solutions to partial differential equations; don't know if haskell will enable me to do this swifty
23:12:35 <bmoll8> *swiftly
23:13:49 <edwardk> bmoll8: i'd say not without actually knowing a lot of the mathematical machinery behind what you are doing
23:15:04 <edwardk> http://hackage.haskell.org/package/lazysplines was sclv's nice little library, see some of the examples, but i don't know how well it would map onto your problem domain
23:16:54 <copumpkin> nice documentation
23:17:22 <edwardk> like i said, he has a paper
23:17:31 <edwardk> but you'd have to ask him for it i think
23:17:40 <copumpkin> aha, it's similar to doug mcilroy's stuff
23:17:49 <edwardk> not familiar with it
23:17:53 <copumpkin> aha it even cites him
23:18:19 <copumpkin> http://www.cs.dartmouth.edu/~doug/powser.html
23:20:09 <edwardk> aww no instance of Arbitrary for Text
23:21:22 <edwardk> just feeding a string
23:32:07 <copumpkin> it feels like I can bring monoids into this
23:43:09 <bmoll8> is anyone here using haskell for scientific computing?
23:44:26 <blackh> bmoll8: tangentially
23:45:06 <blackh> bmoll8: I do data logging for work and I have been using Haskell to prototype some of it.
23:46:13 <copumpkin> yup, definitely some monoids at play in here, even though the paper never mentions them
23:53:39 <cjs> bmoll8: why do you ask?
23:54:10 <cjs> Lots of people use Haskell for financial stuff, which shares some similar characteristics, I think.
23:55:35 <edwardk> somehow i can't tell if copumpkin is baiting me or he really thinks he can ;)
23:55:45 <copumpkin> no, I really think I can :P
23:56:21 <copumpkin> reading a paper on a generalization of the technique and while it doesn't mention monoids, it's called the "sum-product" algorithm and supposedly works on any semiring
23:56:28 <mercury^> Does docon 2.11 work with ghc 6.10?
23:56:28 <copumpkin> which just means we get two monoids instead o' one :P
23:56:30 <hackagebot> network-fancy 0.1.1 - Networking support with a cleaner API (TaruKarttunen)
23:57:10 <edwardk> yeah
23:57:50 * copumpkin keeps playing with it
23:57:52 <edwardk> had fun at hac-phi we got to talk about differentiable rings, and monoid modules over rings, etc.
23:58:04 * copumpkin really needs to take more math
23:58:11 <edwardk> byorgey has a slick little library for combinatorial species
23:58:50 <edwardk> nice. thanks to kowey's post i got cabal test working. it just found way too many bugs for me to be happy, but er... i guess that makes me happy
23:59:08 <copumpkin> you doing hpc too?
23:59:16 <copumpkin> (program coverage, not high-performanc computing)
23:59:25 <edwardk> nah, test-framework, etc.
23:59:29 <edwardk> hpc will come later
23:59:33 * copumpkin chews on that E
23:59:39 * copumpkin spits it out
23:59:47 <copumpkin> ah
