00:00:21 <mbuf> Cale, I don't need to hold the 14400 users; they can send the message and quit;
00:00:28 <athos> so why's there still no cabal-install uninstall?
00:00:36 <athos> is it hard to get right?
00:00:37 <mbuf> Cale, clients connecting to 14401 will simply read the message;
00:00:54 <Cale> athos: I don't think it should be particularly hard, but nobody has done it.
00:02:39 <mbuf> Cale, so without threads, I will somehow need to pass the message sent by client connecting to 14400 to the server running on 14401; in which case, I need to differentiate it from a client who is simply trying to read the message;
00:03:18 <jrockway> is there a (System.IO) Handle -> (System.Posix) Fd conversion function anywhere?
00:03:26 <jrockway> i hate having 0/1/2 hard-coded for stdin/out/err
00:03:37 <Cale> Without threads, you have to alternate between accepting connections in 14400 and 14401
00:03:40 <Cale> on*
00:04:28 <jeffwheeler> athos: there is unregister, though
00:05:09 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html#v%3AhandleToFd
00:05:25 <Cale> jrockway: There is that ^^
00:06:05 <jrockway> perfect, not sure why I didn't notice that
00:06:06 <jrockway> thanks :)
00:06:09 <athos> jeffwheeler: then my cabal seems to be outdated :)
00:06:29 <jeffwheeler> athos: oh, my mistake; that's on ghc-pkg
00:06:33 <mbuf> Cale, I think using threads is better in this context; will look at http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
00:06:36 <mbuf> Cale, thanks
00:06:47 <jeffwheeler> athos: it hides it from cabal, though
00:06:56 <athos> ok
00:07:56 <Cale> mbuf: absolutely, yeah
00:08:20 <Cale> mbuf: I suppose I could also write it for you as an example if you like
00:09:17 <mbuf> Cale, appreciate that!
00:34:45 <slacks21> evening all. would anyone happen to know how to go about testing for whether a list in haskell is finite?
00:35:00 <dancor> is makeTokenParser the fastest place to start to make a php lexer
00:35:11 <Cale> mbuf: here you go: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7629#a7629
00:35:33 <koala_man> slacks21: hmm.. solve the halting problem?
00:35:38 <slacks21> lol
00:35:44 <Cale> mbuf: It only accepts one writer at a time, but multiple readers, even if there's no message yet.
00:35:52 <slacks21> Sorry, still a bit new to CS major
00:36:09 <Cale> mbuf: After the writer finishes setting the message, another writer can come along and reset it to something else.
00:36:39 <Cale> slacks21: You can apply length to it. If you get an answer, then it's finite. Otherwise, it's an infinite loop.
00:37:23 <Cale> slacks21: There's no practical way of telling between very long lists and infinite ones.
00:37:37 <slacks21> yeah, realizing that fairly quickly
00:38:41 <slacks21> this should prove an interesting assignment then  : )
00:39:24 <pcc1> is it safe to have an Ord instance that defines a partial order?
00:39:27 <Cale> mbuf: How is that?
00:39:36 <mbuf> Cale, checking
00:39:37 <Cale> pcc1: Many things assume that the order is total.
00:40:48 <mbuf> Cale, another writer to reset the message will not be required, as the server can keep accepting input messages
00:40:49 <Cale> mbuf: Readers who connect before the first message gets written will just wait until a writer connects and sets the message.
00:41:06 <Cale> hm?
00:41:41 <Cale> mbuf: ah, is the idea to broadcast a sequence of messages?
00:42:02 <Cale> (have one writer connect and talk to all the readers)
00:42:14 <mbuf> Cale, the 14400 server will keep receiving messages; and anyone reading on 14401 will get the responses
00:42:24 <Cale> mbuf: okay
00:42:42 <mbuf> Cale, yes, one writer connect, and talk to a single reader that connects to 14401;
00:42:47 <Cale> In that case then, Chan really is appropriate
00:43:01 <mbuf> Cale, i see;
00:43:27 <mbuf> Cale, but, that will be a subset of what you have written?
00:43:38 <mbuf> Cale, in this case, many readers can read the message;
00:51:44 <thaldyron> Can someone tell me the difference between "mapReader f m" and "fmap f m" ?
00:51:53 <slacks21> anyone know what the haskell equiv. to andmap is?
00:52:11 <Cale> mbuf: but there's only one message
00:52:20 <Cale> slacks21: What does andmap do?
00:52:57 <slacks21> hmm... kind of what it sounds.  maps a predicate across a list and returns true if they are all true
00:52:59 <mbuf> Cale, not necessarily; 14400 gets messages continuously, and dumps them to 14401, so a reader will read from 14401
00:52:59 <slacks21> false otherwise
00:53:14 <Gilly> slacks21: all
00:53:14 <Cale> slacks21: all
00:53:17 <slacks21> okay
00:53:18 <slacks21> thanks
00:53:26 <Cale> > all even [2,4,6,8,10]
00:53:28 <lambdabot>   True
00:53:33 <slacks21> cool
00:53:33 <Cale> > all even [2,4,6,8,9]
00:53:35 <lambdabot>   False
00:53:48 <Cale> there's also 'any'
00:54:09 <slacks21> so && and || are always binary
00:54:25 <slacks21> or can they be curried somehow... still a bit hazy on how that works
00:55:03 <oklopol> they can be curried, you can partially apply one of them to return a function waiting for the other boolean
00:55:12 <Gilly> > (&&) True False
00:55:14 <lambdabot>   False
00:55:18 <oklopol> also hi gilly
00:55:28 <Gilly> > (True &&) False
00:55:29 <lambdabot>   False
00:55:36 <Gilly> hey oklopol :)
00:55:39 <slacks21> oh thanks
00:56:02 <oklopol> slacks21: also
00:56:05 <oklopol> > (&& True) False
00:56:06 <lambdabot>   False
00:56:19 <oklopol> i mean as an example of infix currying, kinda useless in this context :P
00:56:29 <oklopol> waits for the left argument
00:56:30 <Cale> mbuf: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7629#a7631
00:56:45 <mbuf> Cale, checking
00:56:49 <slacks21> ; )  Thanks
00:57:36 <mbuf> Cale, how do I test it? ghci> load File.hs; ghci> main
00:57:42 <Cale> mbuf: yep
00:57:48 <Cale> mbuf: That'll start the server
00:58:03 <Cale> mbuf: Then you should be able to telnet to each of the ports
00:58:13 <mbuf> Cale, ok, hold on;
00:58:39 <Cale> oh, peekSampleVar isn't needed anymore
00:59:45 <mbuf> Cale, nice!
01:00:23 <Cale> mbuf: Also, it's not technically necessary to be using Data.ByteString
01:00:24 <mbuf> Cale, thanks, it works! which material do you recommend for Haskell newbies?
01:01:13 <Cale> (It's just that before, I was using hGetContents, which I wanted to be strict.)
01:01:19 <mbuf> Cale, I have tried realworldhaskell and learnyouhaskell; they were useful for a start;
01:01:43 <mbuf> Cale, ok
01:02:23 <mbuf> Cale, and instead of calling writer socket writeMsg, you use 'forever'
01:02:46 <Cale> mbuf: yeah, since I went to the trouble of importing Control.Monad to use it
01:02:58 <jeffwheeler> @source forever
01:02:58 <lambdabot> forever not available
01:02:59 <Cale> mbuf: it amounts to the same thing though
01:03:04 <mbuf> Cale, ok
01:03:09 <Cale> forever x = x >> forever x
01:03:22 <jeffwheeler> Cale: thanks
01:03:30 <Cale> @src forever
01:03:30 <lambdabot> Source not found. The more you drive -- the dumber you get.
01:03:33 <Cale> hmm
01:03:39 <Deewiant> forever = fix $ ap (>>)
01:03:41 <Jedai> forever x = sequence_ (cycle [x])
01:03:55 <jeffwheeler> Jedai: that's the definition I was thinking
01:04:03 <Deewiant> forever = sequence_ . repeat
01:04:16 <jeffwheeler> @type sequence_
01:04:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
01:04:18 <jeffwheeler> @type sequenceM
01:04:20 <lambdabot> Not in scope: `sequenceM'
01:04:24 <jeffwheeler> @type sequence
01:04:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:04:40 <Jedai> jeffwheeler: it's funny but the primitive recursive one is clearer and probably more efficient
01:04:58 <Jedai> jeffwheeler: though I guess with a bit of inlining the code would be the same
01:04:59 <Deewiant> ?src sequence_
01:04:59 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
01:05:12 * mux finds sequence_ . repeat to be the most elegant way to write it
01:05:44 * Jedai too
01:11:01 <loverdos> @djinn a -> b -> a
01:11:02 <lambdabot> f a _ = a
01:11:27 <benmachine> @pl f a _ = a
01:11:28 <lambdabot> f = const
01:14:08 <ray> @. pl djinn a -> b -> a
01:14:09 <lambdabot> f = const
01:18:48 <jeffwheeler> @. pl djinn a -> b -> c -> (a, b)
01:18:48 <lambdabot> f = (const .) . (,)
01:19:01 <jeffwheeler> @. pl djinn a -> b -> c -> (a, b, c)
01:19:01 <lambdabot> f = (,,)
01:20:05 <jeffwheeler> @. djinn type fmap
01:20:07 <lambdabot> Cannot parse command
01:20:10 <jeffwheeler> @type fmap
01:20:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:20:26 <jeffwheeler> @type head
01:20:27 <lambdabot> forall a. [a] -> a
01:20:32 <jeffwheeler> @. djinn type head
01:20:33 <lambdabot> Error: Undefined type []
01:21:47 <jeffwheeler> @type ($)
01:21:48 <lambdabot> forall a b. (a -> b) -> a -> b
01:21:51 <jeffwheeler> @. djinn type ($)
01:21:53 <lambdabot> f a = a
01:23:35 <jeffwheeler> @. djinn type (+)
01:23:36 <lambdabot> Error: Class not found: Num
01:24:16 <jeffwheeler> It's tough to think of functions that have no dependencies like that.
01:24:40 <jeffwheeler> No lists, no numbers, no monads, no functors, etc.
01:24:50 <jeffwheeler> What else is there?
01:26:07 <ray> @. djinn type fst
01:26:08 <lambdabot> f (a, _) = a
01:26:32 <mbuf> Cale, what is wrong with this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7632#a7632 just trying to format the message 'msg' before displaying it
01:30:06 <WorkyBob> has anyone tried building a shared library on OS X using ghc?
01:30:21 <WorkyBob> I'm hitting it moaning about the haskell library object files being compiled without position independant code
01:32:38 <kfish> mbuf, BS.hPutStr takes a ByteString, not a String
01:36:59 <QinGW> what?
01:37:51 <QinGW> Sorry,wrong#.
01:51:12 <mbuf|away> kfish, I see
01:53:05 <agapoulitsas> haskell tutorial page 138
01:53:07 <agapoulitsas> "This is because you cannotmake instances out of non-fully-applied type synonyms."
01:53:14 <agapoulitsas> what does this mean?
01:53:48 <quicksilver> agapoulitsas: which part of it don't you understand?
01:54:02 <quicksilver> type Foo a b = Either a b -- this is a type synonym
01:54:45 <agapoulitsas> non-fully applied?
01:55:29 <Pistahh> @src forever
01:55:30 <lambdabot> Source not found. My brain just exploded
01:56:05 <Cale> agapoulitsas: As in not applied to all of its parameters
01:56:20 <quicksilver> agapoulitsas: well "Foo a" would be not fully applied.
01:56:51 <agapoulitsas> ok
01:56:59 <Cale> agapoulitsas: If you, say, tried to write an instance of Functor for (Foo a), even though you might expect Foo a to expand to Either a and writing an instance of Functor for Either a is okay, that doesn't work. (At least not without extensions)
01:57:16 <Cale> (and in general not at all)
01:57:21 <Gilly> Any particular reason why "Download GHC" link in the www.haskell.org frontpage links to GHC version 6.10.3 and not 6.10.4 ?
01:57:36 <ivanm> Gilly: because no-one has updated it yet? :p
01:57:46 <ivanm> Gilly: or maybe they're waiting for the H-P release that contains .4 ...
01:58:28 <Gilly> I expected the former :)
01:59:33 <ivanm> Gilly: yeah, it probably is
02:04:44 <Feuerbach> In gtk2hs, is it possible to catch every keypress and depending on which key is pressed send that keypress to one of the widgets? E.g. I want letters to go into an input field but arrows go to a treeview.
02:05:31 <Feuerbach> The problem is, events are handled in order from childs to parents...
02:09:58 <Pistahh> Feuerbach: why do you want to make a UI that is unusual for users?
02:10:48 <ivanm> Pistahh: because he doesn't like them? :p
02:10:51 <Saizan> it might be nicer to use :)
02:11:10 <Feuerbach> Pistahh: I want to make UI convenient for myself
02:14:05 <jpcooper> hello
02:14:21 <jpcooper> does anyone know how to install fastcgi on windows with cabal?
02:14:31 <jpcooper> cabal install fastcgi tries to use "sh"
02:15:02 <ivanm> jpcooper: you probably need cygwin or msys
02:15:14 <jpcooper> yes, I might give it a try with cygwin
02:20:25 <noes> About concrete representation, is the haskell Integer type always a bigint or does it handle fixnum with bigint promotion at overflow?
02:20:57 <Ytinasni> @src Integer
02:20:57 <lambdabot> data Integer = S# Int#
02:20:57 <lambdabot>              | J# Int# ByteArray#
02:21:21 <Ytinasni> looks like fixnum with overflow.
02:22:32 <quicksilver> right.
02:22:44 <quicksilver> it stores small numbers more efficiently
02:22:56 <quicksilver> althought it's still not as fast as plain Int, of course.
02:22:57 <noes> is the suffix # a marker that it is a implementation internal primitive type?
02:23:01 <quicksilver> yes.
02:23:09 <quicksilver> it means it's GHC internals
02:24:54 <chrisbrown> @src Int
02:24:54 <lambdabot> data Int = I# Int#
02:26:18 <ivanm> @src (#)
02:26:18 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:26:19 <ivanm> :p
02:33:09 <agapoulitsas> @src mapTreeM
02:33:09 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:34:15 <agapoulitsas> @bots
02:34:15 <lambdabot> :)
02:34:16 <lunabot>  :)
02:34:25 <noes> Ytinasni, quicksilver thank you.
02:35:39 <mbuf> how can I fix this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7632#a7632
02:35:57 <mbuf> I need to format the msg before it is .hPutStr
02:36:08 <mbuf> BS.hPutStr hdl msg, works though
02:37:31 <ivanm> mbuf: don't use ++
02:38:54 <tibbe> mbuf: if you want better performance out of it I would use the network-bytestring package
02:38:55 <mbuf> ivanm, how should it be done?
02:39:29 <mbuf> tibbe, this is only for testing;
02:39:36 <tibbe> mbuf: ah
02:39:51 <tibbe> mbuf: I would use it anyway since it uses ByteStrings rather than Strings :)
02:40:11 <mbuf> tibbe, ok
02:40:40 * ivanm hasn't used bytestring that much
02:41:01 <mbuf> just wondering if I had to fix this, what I ought to do;
02:41:37 <solrize> @oeis 3, 3, 5, 4, 4, 3, 5, 5, 4, 3, 6
02:41:38 <lambdabot>  Number of letters in the English name of n, excluding spaces and hyphens.
02:41:38 <lambdabot>  [4,3,3,5,4,4,3,5,5,4,3,6,6,8,8,7,7,9,8,8,6,9,9,11,10,10,9,11,11,10,6,9,9,11,...
02:41:39 <ivanm> mbuf: have a look at  Data.ByteString.Char8
02:42:02 <mbuf> ivanm, ok
02:42:06 <bryanedds> @print 5 :)
02:42:06 <lambdabot> Not enough privileges
02:42:09 <bryanedds> aww
02:42:12 <chrisbrown> mbuf: is it not to do with the associativity of (++) ?
02:42:36 <mbuf> chrisbrown, BS.hPutStr hdl msg, works though
02:42:39 <teapot> @ (2+2)
02:42:41 <chrisbrown> try BS.hPutStr hdl $ ((head $ words msg) ++ " OK\r\n")
02:42:45 <Ytinasni> chrisbrown: no, $ has the lowest precedence.
02:42:49 <cjs> mbuf: BTW, you can also just use the standard strict bytestring routines that read from handles.
02:42:56 <tibbe> mbuf: you can use pack from ByteString.Char8
02:43:00 <Ytinasni> and the error confirms the correct parse happens)
02:43:02 <tibbe> mbuf: sorry, I mean unpack
02:43:06 <hackagebot> cautious-file 0.1.4 - Ways to write a file cautiously, to reduce the chances of problems such as data loss due to crashes or power failures (RobinGreen)
02:43:07 <mbuf> tibbe, I was going through http://agentzh.blogspot.com/2008/06/optimizing-haskell-code-from-string-to.html
02:43:44 <tibbe> mbuf: OK
02:43:55 <tibbe> so ByteStrings are not faster Strings
02:44:08 <tibbe> they are semantically distinct types
02:44:13 <tibbe> Test is fast String
02:44:18 <tibbe> Text*
02:44:29 <tibbe> ByteString is faster [Word8]
02:44:51 <tibbe> Going from ByteString <-> String required specifying an encoding
02:45:05 * cjs lives and dies by ByteStrings.
02:45:26 <mbuf> chrisbrown, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7632#a7636
02:45:48 <chrisbrown> mbuf: yeah, sorry - I was just being dense
02:45:49 <mbuf> chrisbrown, do I need to give any definition?
02:46:05 <mbuf> chrisbrown, ok
02:46:14 <chrisbrown> mbuf: but you say BS.hPutStr hdl msg works?
02:46:20 <mbuf> chrisbrown, yes
02:46:25 <tibbe> mbuf, BS.hPutStr hdl $ C.pack $ ((head $ words msg) ++ " OK\r\n")
02:46:48 <cjs> mbuf: Do you basically want to use ByteStrings for everything? I.e., replace 'x ++ "OK"' with 'BS.concat [x, pack "OK"]'?
02:48:09 <cjs> mbuf: Actually, it looks to me, unless you're doing some other interesting stuff with your imports, msg is a string, so maybe you just want to be using hPutStr instead of BSD.hPutStr there.
02:48:14 <mbuf> tibbe, and 'import qualified Data.ByteString.Char8 as C' I suppose
02:49:14 <mbuf> cjs, will try
02:49:52 <agentzh> mbuf: oh! :D
02:52:02 <mbuf> cjs, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7637#a7637
02:52:12 <agentzh> mbuf: was just wondering who mentioned my nick here ;)
02:52:57 <cjs> mbuf: BTW, there's not much point in moving some stuff to ByteString if you're going to end up moving things back and forth all the time. When you do it, you want to do everything, or most everything. The OverloadedStrings feature can be helpful for this, BTW.
02:53:47 <mbuf> cjs, as a newbie, I don't quite understand everything that you people say, but, atleast some things make sense :)
02:54:02 <cjs> mbuf: Right, for what you're doing there, just use strings for everything.
02:55:07 <cjs> BTW, There's generally no need to import both the ByteString and ByteString.Char8 versions of something. They're almost identical, except that conversion routines for the one consider a byte to be a Word8, and for the other a byte converts to/from a Char8.
02:55:08 <agentzh> mbuf: cjs is talking about the GHC option -XOverloadedStrings
02:55:28 <mbuf> cjs, sorry, forgot to remove it;
02:55:38 <cjs> Yeah. Though I generally use the "{-# LANGUAGE OverloadedStrings #-}" pragma.
02:56:07 <agentzh> cjs: heh
02:56:11 * agentzh too.
02:56:36 <cjs> Grrr. My simulator is growing to a half gig over the course of a six hour run. I must still have subtle space leaks somewhere.
02:57:05 * cjs wants a magically-fix-space-leaks wand.
02:57:11 <mbuf> cjs, it works! just removed BS, and using only putStrLn, hPutStr
02:57:19 <cjs> mbuf: Right!
02:57:30 <mbuf> cjs, chrisbrown tibbe thanks!
02:58:32 <chrisbrown> mbuf: np, although  didn't really help much!
02:59:30 <mbuf> other than realworldhaskell, learnyouhaskell, is there any material that you people recommend to learn haskell? or how did you go about learning it?
03:00:14 <Cale> mbuf: After you know the basics, there are a lot of interesting papers, especially those by Simon Peyton Jones
03:00:31 <chrisbrown> mbuf: I seriously recommed Thompson's text: Haskell, the craft of functional programming
03:00:33 <Cale> mbuf: and of course, the documentation for the various libraries
03:00:46 <cjs> mbuf: I found Graham Hutton's text to be excellent.
03:01:07 <mbuf> functional programming is fun;
03:01:18 <cjs> Chapter 8 of that and the All About Monads tutorial, and you're set for MonadLand.
03:01:28 <ivanm> chrisbrown: seconded
03:02:40 * mbuf notes down everything
03:02:40 <chrisbrown> mbuf: going back to your example. msg is a String right?
03:02:47 <mbuf> chrisbrown, yes
03:02:53 <chrisbrown> ((head $ words msg) ++ " OK\r\n") is also a string
03:02:59 <mbuf> chrisbrown, right
03:03:02 <chrisbrown> so why doesn't that plug into where msg was
03:03:08 <Cale> I have a few tutorials about monads and other things that people seem to like :)
03:03:18 <mbuf> chrisbrown, :t reader, was expecting (Chan ByteString)
03:03:36 <Peaker> Cale: hey, did you try your FRP implementation approach?
03:03:39 <Ytinasni> cale: where are those?
03:03:43 <Cale> Peaker: nope
03:03:56 <cjs> My God. There's a "Monad tutorials timeline" page on haskellwiki.
03:04:03 <chrisbrown> mbuf: I'm confused, perhaps it's still too early in the morning
03:04:06 <jpcooper> ivanm, I've installed libfcgi and its dev package, but cabal seems not to be able to see it. Have you installed fastcgi yourself?
03:04:20 <chrisbrown> they are both strings, I don't get it...
03:04:48 <Peaker> Cale: I tried a bit, but I've run into identity problems.  I had (Event a) be represented by a graph, and fmap on it create a new graph with an Fmap node.  The problem is merging these graphs when mappending two events requires identities in order to not duplicate all graph processing nodes (identifying the processing nodes, i.e: Fmaps, arre the same)
03:04:58 <Cale> Ytinasni: There's http://www.haskell.org/haskellwiki/Introduction_to_IO which is not about monads, but a very quick intro to how to do IO specifically, then there's http://www.haskell.org/haskellwiki/Monads_as_Computation and http://www.haskell.org/haskellwiki/Monads_as_Containers
03:05:03 <maxote> maybe Haskell a matlab replacement?
03:05:21 <Cale> Ytinasni: http://cale.yi.org/index.php/Main_Page and some other things linked from here
03:05:29 <ivanm> jpcooper: nope ;-)
03:05:35 <jpcooper> bugger
03:05:36 <ivanm> and I don't use windows
03:05:47 <Peaker> Cale: It seems like the creation of an Event with fmap, mappend, etc, needs to happen within some Unique monad, and not be pure like it is, in order to allow sharing
03:06:09 <Peaker> Cale: (Or use unsafePerformIO and the uniqueness of the pointers GHC creates for the pointer values)
03:06:34 <chrisbrown> mbuf: ah, I see  :)
03:07:03 <Cale> Peaker: hmm... will (State Graph a) not work?
03:07:25 <Peaker> Cale: You mean Event a = that?
03:07:27 <Cale> Peaker: or is that not the problem?
03:07:36 <Cale> Peaker: Well... I wonder...
03:07:53 <Peaker> Cale: if Event a = that, then you have a bunch of State computations happening in parallel, and you back the same problem of merging them
03:08:08 <Peaker> Cale: If the Reactive API is changed so that all the primitives are in State rather than pure, its like putting them in Unique
03:08:11 <Cale> Peaker: There must be some way to rig things so that there's an explicit representation of how everything is to be wired up at some point.
03:08:55 <mbuf> BRB
03:08:55 <Peaker> s/back/have
03:09:22 <Cale> Peaker: I certainly wouldn't want to *expose* the fact that they're in some monad.
03:09:41 <Peaker> Cale: The problem is not a functionality one, but a performance one -- how to do CSE between different pure constructions of (Event a), without breaking referential transparency
03:10:12 <Cale> Peaker: how different are we talking about?
03:10:15 <Peaker> Cale: you could do the explicit graph representation, but you would have to duplicate all the computational paths that build Events when merging them, because you'd have no way to know that the paths are identical and can be merged
03:10:40 <Peaker> Cale: Well, they even share the same thunk to build -- but no Eq instance to be able to comprae
03:11:04 <Cale> Maybe I don't know what's going on there...
03:11:04 <Peaker> Cale: I mean,  can you tell that:  someEvent = fmap (*2) otherEvent == someEvent later when you try to merge graphs?
03:11:37 <Cale> Peaker: isn't the idea that each Event is uniquely identifiable somehow?
03:11:45 <Cale> (and Behaviour too)
03:12:01 <Peaker> Cale: That would indeed solve the problem, but how do you uniquely identify the result of  fmap (*2) on an event?
03:12:56 <quicksilver> Peaker: can you really convince yourself that this is an essential problem?
03:13:13 <quicksilver> Peaker: after all, "fmap (*2) list" works fine with sharing
03:13:19 <Peaker> quicksilver: If I want to implement Reactive's API without unsafePerformIO, or changing the operations to be in some Unique monad or so? Yeah
03:13:23 <quicksilver> why is "fmap (*2) ev" necessarily worse?
03:13:39 <quicksilver> I'm asking a naive question deliberately - I've had some of the same problems you describe
03:13:46 <quicksilver> but I've never *convinced* myself it was impossible.
03:14:04 <Peaker> quicksilver: well, Cale suggested the approach of representing an Event with an explicit graph of the relationships between Events and such
03:14:15 <Cale> The problem isn't multiple places where someEvent gets used, surely...
03:14:22 <Peaker> quicksilver: I tried doing that, and got stuck already after fmap/mappend
03:14:29 <Cale> hmm
03:14:41 <Feuerbach> is there any SQL-accessing library with monadic interface? Like ReaderT Connection IO for HDBC
03:14:43 <Cale> Peaker: It would be interesting to see how it looks
03:16:03 <Peaker> quicksilver: with pure lists, the thunk of the list represents the list's result/value, so it is only computed once when the pure value is shared.  You get CSE from name-sharing.   If Event is used to represent not the actual content of the event data, but the relationship graph, then you don't get this CSE
03:16:34 <Cale> Peaker: oh, it's supposed to keep track of not just the relationships, but the values too.
03:16:40 <Peaker> quicksilver: if Event is used to represent the actual data, which is inputted impurely, then I think an unsafePerformIO should be hiding somewhere
03:17:01 <Cale> Peaker: The idea is basically to take 100% control of the way that evaluation happens.
03:17:34 <Saizan_> i think you should write an interpreter for an FRP language first
03:17:42 <Cale> Imagine that you're writing an interpreter for a language where the Reactive things are first class.
03:17:49 <Saizan_> and then transform it away
03:17:55 <Cale> yeah
03:18:02 <quicksilver> Peaker: I'm not sure, but I'm too busy with real work today to give it the attention it deserves. I will be interested in your conclusions.
03:18:36 <Cale> I just think that relying on GHC to get the evaluation order right, and/or using unsafePerformIO to hijack GHC's evaluation mechanism and twist it into the right shape is worrisome.
03:19:17 <Peaker> Cale: I am not certain, but am pretty sure that to get an efficient/sharing implementation, you need to change (perhaps slightly) Data.Reactive's API or use unsafePerformIO
03:19:47 <Cale> Peaker: I'm pretty sure that no program ever really needs to use unsafePerformIO
03:20:15 <Peaker> Cale: Even if there's a very specific API and operational semantics you want it to adhere to?
03:20:18 <Cale> You should be able to get within a logarithmic factor in terms of performance without doing mutation.
03:20:50 <quicksilver> Cale: it's not unsafePeformIO for mutation, in this case. It's unsafePerformIO to get a side effect evaluated only once, and the value cached.
03:20:52 <Peaker> Cale: its about CSE, though, not about fast mutation
03:20:57 <Cale> Peaker: What if the Event and Behaviour were GADTs with all the operations on them being constructors?
03:21:23 <Cale> quicksilver: right, but the same idea applies. Mutation is just more general.
03:21:38 <Peaker> Cale: I've not used GADTs much, I don't see how that helps (But maybe that's my lack of GADT experience)
03:22:08 <Peaker> Cale: I see how GADTs help you with richer type-safety, but how does it help you get CSE when sharing pure values?
03:22:11 <Cale> Peaker: Well, basically, imagine that instead of actually doing anything, all the Event and Behaviour APIs just built an abstract syntax representation of what needed to be done
03:22:42 <quicksilver> that is something not entirely unlike my solution, cale.
03:22:45 <Cale> Don't you think it should be possible to compile that abstract syntax into a program which carries out everything efficiently?
03:23:06 <Peaker> Cale: Yeah, that's what I imagined, with the explicit graph representation.  The problem is merging these graphs such that CSE merges graph nodes who happen to be the same pure value/thunk
03:24:18 <Cale> ah, is the problem essentially that the syntax is higher order, so you have no way to compare nodes in it?
03:24:33 <Peaker> Cale: I think so, but I'm not sure I fully understand that
03:24:37 <Cale> Yeah, perhaps I see it now.
03:24:40 <pastah> @src unzip
03:24:40 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
03:24:47 <pastah> what does the '~' do?
03:25:09 <pastah> super-cons?
03:25:14 <Peaker> Cale: if Event could be compared (==) to another Event, there'd be no problem
03:25:20 <Cale> pastah: It says that the pattern automatically matches and it's only checked if it matches when one of the variables in it is used
03:25:20 <Peaker> Cale: but its a Functor
03:25:44 <Ytinasni> pastah: it means that if the pattern-match fails, the error gets delayed until you use one of as or bs.
03:25:47 <Cale> pastah: So only when as or bs is demanded will the second parameter to the function be evaluated
03:26:13 <Cale> Peaker: The problem is that you can't compare the (*2)
03:26:18 <Peaker> Cale: yeah
03:26:24 <benmachine> as/bs are always demanded though aren't they?
03:26:34 <benmachine> so what's the benefit of ~ there
03:26:37 <pastah> Cale, Ytinasni: doesn't that happend automagically with laziness?
03:26:46 <Cale> benmachine: they are not always demanded
03:26:51 <Ytinasni> pastah: no, pattern-matching is strict.
03:27:11 <pastah> so that induces lazy pattern matching
03:27:14 <pastah> cool :)
03:27:21 <pastah> (or is it?)
03:27:40 <benmachine> > let f ~(x:xs) = x in f []
03:27:42 <lambdabot>   * Exception: <interactive>:1:137-149: Irrefutable pattern failed for patter...
03:27:49 <Peaker> Cale: if the Event doesn't describe a graph, but itself is a node in the graph, I don't need to compare, I just let the GHC sharing mechanism get me CSE by being careful to re-use names when creating Event graphs.  But then the graph is not really explicit in structure, and allowing external inputs to know which Events to update again requires unsafePerformIO or such
03:28:05 <Ytinasni> pastah: useful, but it makes adding an error later interesting.
03:28:15 <pastah> haha
03:31:35 <Cale> Peaker: So yeah, this is really starting to look to me like it needs direct language support to do properly.
03:32:18 <Cale> Peaker: Otherwise, you have no way to really inspect and be sure that the function is the same. However, GHC does provide a StableName mechanism you might be able to try...
03:33:18 <Cale> I think using that, you could avoid unsafePerformIO, though the end result would of course be in IO.
03:33:58 <Peaker> what's StableName?
03:34:03 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
03:34:18 <Cale> You know what's really stupid about it though? StableName isn't an instance of Ord
03:34:43 <Ytinasni> Cale: why would there be?
03:34:58 <Peaker> Cale: Might as well put all the Reactive API in the Unique monad, no?
03:35:06 <Peaker> Cale: Its probably because of the GC
03:35:22 <Peaker> though it could probably use a global counter to have Ord
03:35:59 <Peaker> I guess one can always use the Unique monad instead of StableName, no?
03:37:14 <Cale> mm... I suppose
03:38:48 <Paczesiowa> why bar isn't memoized in: foo :: Int -> Int; foo n = let bar = repeat id !! 9999999999999 in bar n ?
03:38:48 <lambdabot> Paczesiowa: You have 1 new message. '/msg lambdabot @messages' to read it.
03:39:17 <quicksilver> Paczesiowa: it will be, sometimes.
03:39:47 <quicksilver> Paczesiowa: if you want to guarantee it, try foo = let bar = repeat id !! 999 in \n -> bar n
03:40:01 <quicksilver> otherwise you are relying on the "let bar" being lifted out of that scope
03:40:12 <quicksilver> which it should be, AFAIK, if optimisations are on, since it doesn't depend on n.
03:40:34 <Paczesiowa> it's not with O2
03:40:43 <lilac> Paczesiowa: as for why, it presumably isn't memoized because that would be a space leak
03:40:58 <quicksilver> I'm surprised.
03:41:06 <lilac> Paczesiowa: consider: foo :: Int -> Int; foo n = let bar = repeat id in (bar !! 99999999999999) n
03:41:16 <quicksilver> I thought GHC did lift non-dependent definitions, even though they are a space leak.
03:41:31 * lilac imagines a non-sharing version of repeat here
03:42:09 <lilac> quicksilver: i've definitely seen it do so in ghc-core; i guess it must have some heuristics for when that's a good idea?
03:42:56 <Cale> Peaker: My idea of using StableNames is that you could presumably apply makeStableName even to two functions and have a reasonable shot at getting the same StableName, though this appears to be false, sadly...
03:43:12 <Paczesiowa> oh, I forgot this, it is memoized in the following:  foo n = let bar = repeat 0 !! 9999999999999 in bar + n
03:43:18 <Cale> Peaker: I mean, apply it twice to the same function.
03:43:24 <Gwern-away> about http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7612#a7639 - is there any more idiomatic way than 'listeq xs ys = and $ map (\n -> n `elem` xs) ys'? (Or maybe more performant?)
03:43:29 <Paczesiowa> and I want to know what's so special about if (compared to 0)
03:43:47 <Gwern-away> (this function is figuring out whether ys is a subset of xs)
03:44:09 <Paczesiowa> @pl (\n -> n `elem` xs)
03:44:09 <lambdabot> (`elem` xs)
03:44:10 <lilac> Gwern-away: all (`elem` xs) ys
03:44:34 <Gwern-away> hm. hlint told me that too
03:45:02 <lilac> though if xs :: Ord a => [a], i'd sort the lists first
03:45:13 <lilac> and then use a better algorithm :)
03:45:14 <quicksilver> Gwern-away: listeq might be a bad name :)
03:45:24 <quicksilver> @hoogle subset
03:45:24 <lambdabot> Data.IntSet isProperSubsetOf :: IntSet -> IntSet -> Bool
03:45:24 <lambdabot> Data.Set isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
03:45:24 <lambdabot> Data.IntSet isSubsetOf :: IntSet -> IntSet -> Bool
03:45:36 <Gwern-away> quicksilver: probably
03:45:45 <Gwern-away> guess I'll just call it 'subset'. no clashes there
03:46:49 <Gwern-away> quicksilver: using data.set will have to wait until the program is finished and I can benchmark; it's possible that setting up sets is more work than the presumably more efficient subset functions are worth
03:47:16 <Gwern-away> as it is, the bottleneck seems to be generatePossibilities
03:48:45 <quicksilver> O(n^2) algorithms are generally OK as long as they fit in your processor cache
03:48:48 <quicksilver> to generalise wildly.
03:48:54 <quicksilver> for short lists, your listeq should be fine.
03:49:48 <lilac> if length ys is always much less than length xs, then your algorithm is better than the sorting one anyway.
03:50:41 <Gwern-away> ys is going to be short, but xs might get long
03:51:10 <quicksilver> lilac: that depends how often you have to sort in practice ;)
03:51:23 <quicksilver> lilac: if one or both of the lists is used multiple times for multiple calls, but you only have to sort them once...
03:51:31 <Gwern-away> well, as a classical european vampire, lilac finds himself sorting things all the time
03:51:34 <Gwern-away> a dreadful nuisance
03:52:50 <lilac> quicksilver: agreed :) i was still thinking of a function :: Ord a => [a] -> [a] -> Bool
03:53:13 <lilac> ( and assuming the compiler wouldn't aggressively inline and CSE away the sorts :) )
03:53:40 <lilac> Gwern-away: i'm afraid that reference is too obscure for me :)
03:54:05 <Gwern-away> lilac: classical european vampires ie pre bram stoker could be kept away by putting a pile of sand in front of your door
03:54:20 <Gwern-away> they would obssessively stop to count and sort the grains, and wouldn't finish before dawn
03:54:42 <dolio> All vampires had OCD?
03:54:47 <Gwern-away> used to, yeah
03:54:51 <dolio> Bummer.
03:55:02 <Gwern-away> of course, now they're just obssessed with their hair and keeping virginity pledges
03:55:06 <Gwern-away> kind of a come down
03:55:23 * quicksilver flicks back a curl.
03:55:35 <dolio> That's extra tough, since they can't use mirrors.
03:56:42 <Gwern-away> I've never heard whether vampires are supposed to be seeable by electronics, so maybe they just cameras
03:57:45 <dolio> They were in the Bloodlines computer game. At least, I had to use magic stealth powers to avoid being seen by them.
03:59:18 <dolio> I think they changed that in the new ruleset, though, although I could be misremembering.
03:59:26 <dolio> Now their face is automatically blurred or something.
04:00:14 <Gwern-away> @src all
04:00:14 <lambdabot> all p =  and . map p
04:00:28 <Gwern-away> mm. that map probably wasn't worth parallelizing anyway
04:00:38 <dolio> So you're safe from identification as long as you keep your distinctive back tattoo hidden.
04:14:26 <boyscared> must be tough being a vampire, keeping up with all the rules
04:14:39 <boyscared> vampire lawyers probably do well though
04:14:59 <iago> some yet done monad to generate unique identifiers (yep, I know it is easy to do with a State monad)?
04:15:52 <Peaker> @hoogle Unique
04:15:53 <lambdabot> module Data.Unique
04:15:53 <lambdabot> Data.Unique data Unique
04:15:53 <lambdabot> Data.Unique hashUnique :: Unique -> Int
04:16:33 <quicksilver> data.unique isn't a monad. It runs in IO.
04:16:40 <iago> yep
04:16:53 <iago> I discard it
04:17:17 <Peaker> http://www.haskell.org/haskellwiki/New_monads/MonadUnique
04:18:27 <Peaker> also: http://hackage.haskell.org/packages/archive/value-supply/0.5/doc/html/Data-Supply.html
04:18:44 <Gwern-away> ouch. on a 234 word text file, it's using 80% of my laptop's ram
04:18:46 <iago> I was seeing Data.Supply
04:18:57 <iago> although seems that it lacks of  a monad instance
04:19:01 <Gwern-away> obviously I'm doing something wrong here
04:19:29 <iago> thanks pe
04:19:34 <iago> thanks Peaker
04:20:47 <Gwern-away> (at least it seems lazy enough to keep memory usage at 80% and not kill everything/itself by asking for more)
04:23:52 <MyCatVerbs> Gwern-away: what does this proble-er, program do?
04:24:20 <ray> supply comonad?
04:24:56 <Gwern-away> takes a text file, splits it up into sentences, takes a list of known words, and figures out what selection of 10 words taken from the sentences, plus the known words, will match the most sentences
04:25:58 <Gwern-away> MyCatVerbs: eg, if our sentences are "foo bar baz", "foo bar", "bar foo foo bar", and we know "foo", we'd like it to spit out "bar because then we can understand 2 sentences; we already know foo, and  "baz" would only translate 1 sentence
04:26:58 <Gwern-away> thing is, for any reasonably long text of more than 3 sentences with more than 3 or 4 words, there are a *lot* of possiblities
04:27:21 <MyCatVerbs> Gwern-away: hrmn. Looks like vertex set cover backwards. :)
04:27:33 * MyCatVerbs tries to remember.
04:27:37 * Gwern-away has no idea what that means, so I will pretend to agree
04:29:23 <MyCatVerbs> There *is* a well studied problem in complexity theory that sounds quite like that. You have an undirected graph. The problem is to find the minimum number of nodes that need to be marked in order that every edge is touching at least one colourful node.
04:30:08 <MyCatVerbs> Can't remember what the proper name for that problem is, but I think that what you're talking about here could be modelled as a generalised version of that, where sentences are edges between arbitrarily many different nodes, and words are nodes. :)
04:31:19 <MyCatVerbs> (Though I suppose most mathematicians would stare at me blankly if I suggested giving every edge in a graph arbitrarily many ends. ~_^)
04:31:57 <Gwern-away> MyCatVerbs: hm. and how would one deal with the words one already knows?
04:32:10 <Gwern-away> would one remove them from the graph and then find the minimal nodes?
04:32:19 <Gwern-away> more importantly, is there a haskell library for this? :)
04:32:28 <MyCatVerbs> Gwern-away: I think so and I don't think so, respectively.
04:33:00 <MyCatVerbs> I think you can just throw out sentences that have any of the known words in them, because they're *always* matched so not a problem.
04:33:47 <Gwern-away> but then that would give you the minimum number of nodes/words to fill a completely unknwon sentence; we want to learn as little as possible to understand a new sentence
04:34:28 <MyCatVerbs> Sorry, you need *all* words in a sentence to be matched in order to match that sentence? I thought it was one-or-more.
04:34:59 <Gwern-away> MyCatVerbs: my moustache is only noggleswracked on mondays, othe sfine
04:35:08 <Gwern-away> *other days it is fine
04:38:57 <Gwern-away> MyCatVerbs: so if it isn't the vertex cover problem, then what is it? I buy that this is a graph problem, but I know little about it
04:38:58 <Peaker> Gwern-away: for each unknown word, you want a count of sentences it appears in, and then choose by the maximal count, no?
04:39:00 <maxote> The four horsemen Charles Nutter, Thomas Enebo, Nick Sieger and Ola Bini had abandoned the JRuby project to improve the support of the Ruby on Rails, the Sun's Kenai-based project.
04:39:16 <Peaker> I'm not sure I see why it is a graph problem?
04:39:36 <Peaker> oh, sorry, now I read it right :)
04:39:49 <Gwern-away> Peaker: no, I don't think that would work. what if one word appears in each and every sentence, but each and every sentence is missing some other word too?
04:39:56 <Gwern-away> or something like that I guess
04:40:42 <Peaker> Gwern-away: what's the thing you're trying to maximize?
04:41:03 <Peaker> Gwern-away: I mean, you want the minimal number of words, and maximal number of sentences, but how do you choose between pairs?
04:41:22 <Peaker> (2 words, 1000 sentences VS 3 words, 1500 sentences)
04:42:14 <Peaker> Gwern-away: ah, you want the best 10 words?
04:42:23 * Peaker backread a wall of text :)
04:42:46 <Gwern-away> for x words, maximize the number of sentences containing only those x words or words from a fixed list of words one already knows
04:42:58 <Gwern-away> if that's clearer
04:43:37 <Peaker> known words can be deleted in sentences, as well as sentences that remain empty, they're not interesting, right?
04:43:50 <Gwern-away> seems reasonable, yes
04:44:52 <Peaker> seems like a case for dynamic programming, because the naive recursion probably has tons of shared computations
04:45:15 <Gwern-away> oh noes dynamic programming another thing I don't know
04:45:43 <Peaker> Gwern-away: its a simple concept -- you "reverse" the recursion up-side-down, and start computing bottom up, rather than top down, so that lots of shared computations on the bottom are only performed once
04:45:59 <Gwern-away> (bleh, it's runnign for 40 minutes now)
04:46:07 <Peaker> Gwern-away: for example,  computing fibonacci bottom up is "dynamic programming" of the naive recursion
04:46:49 <Gwern-away> Peaker: maybe you could look at the hpaste and tell me how a DP solution would look
04:46:54 <Gwern-away> that's not a hugely clear explanation to me
04:48:06 <MyCatVerbs> Peaker: it's a graph problem because everything is a graph problem, if you fight it hard enough. ;)
04:48:28 <dibblego> certainly sounds like a DPA to me
04:48:45 <MyCatVerbs> Peaker: it's just that I mistook it for a really straightforward graph problem at first because I misunderstood what it meant to match a sentence. :)
04:49:19 <Daimonic> @src show
04:49:19 <lambdabot> show x = shows x ""
04:49:25 <Daimonic> @src shows
04:49:26 <lambdabot> Source not found. It can only be attributed to human error.
04:49:41 <MyCatVerbs> Daimonic: shows is a method of the Show typeclass.
04:49:47 <Peaker> Gwern-away: fib 0 = 1 ; fib 1 = 1 ; fib x = fib (x-1) + fib(x-2)           is a recursive, top-down computation.    fibs = 0 : 1 : zipWith (+) fibs (tail fibs)     is the "Dynamic programming" bottom-up computation of the same values
04:49:56 <Daimonic> ah okay
04:50:07 <MyCatVerbs> IIRC the default is (shows = showsPrec 0).
04:50:08 <Peaker> Gwern-away: so Recursions go top-down, and often repeat computing the same "downs".  "Dynamic programming" goes bottom up, thus not recomputing stuff
04:50:13 <benmachine> @pl \g f (x,y) -> f x y
04:50:14 <lambdabot> const ((`ap` snd) . (. fst))
04:50:16 <MyCatVerbs> And showsPrec is... horrible. ;)
04:50:35 <Peaker> Gwern-away: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3097#a3097 ?
04:51:13 <Peaker> Gwern-away: is that an accurate description?
04:59:16 <rocketman> > 1+1
04:59:17 <lambdabot>   2
05:14:25 <gwern> Peaker: I think that description is right
05:16:19 * gwern hopes Peaker has found a description of a magical algorithm that will run in log n time :)
05:16:30 <Peaker> gwern: heh what's it for?
05:16:48 <gwern> Peaker: check the URL; the original guy is optimizing learning of New Testament Greek
05:16:58 <gwern> I figure it'd work as well for french
05:17:51 <Peaker> gwern: ok, what options can we rule out?  Its no use deleting columns if all the rows they delete in don't become empty, so after deleting a column, we can focus on deleting only stuff that appears in those rows, and ignore everything else, right?
05:18:46 <gwern> Peaker: what if there is no single word that will empty a row, just 2 or 3?
05:18:56 <gwern> your first clause would seem to be wrong
05:20:25 <Peaker> gwern: let me rephrase
05:21:04 <Peaker> Its no use deleting columns if all the rows they delete in don't EVENTUALLY become empty, so after deleting columns, we can focus on deleting only stuff that appears in rows affected by those columns, and ignore everything else.  When we delete those, we expand our affected group
05:21:43 <Peaker> note "all" and "eventually" in there.  If you delete a column and _all_ the rows that were affected will remain non-empty at the end, this column deletion was a waste
05:21:58 <Peaker> not sure it can save a lot of work or not
05:22:14 <gwern> ok... I think I see, but how does one know that a row will be non-empty at the end without actually running through everything?
05:22:38 <Peaker> gwern: well, the order of deletions doesn't matter, so you know you will be deleting words from the rows involved, so you can start with them
05:22:58 <Peaker> gwern: the "next word to delete" you try is only one from the set that affects the rows already affected by any of your deletions
05:23:45 <gwern> how would we do that? shrink the master table every word we try?
05:24:06 <Peaker> I'm not sure yet :)
05:26:51 <Peaker> gwern: yairchu is an algorithms champ :)
05:27:00 <gwern> @seen yairchu
05:27:01 <lambdabot> yairchu is in #haskell. I don't know when yairchu last spoke.
05:27:08 <yairchu> just now
05:27:08 <gwern> doesn't bode well
05:27:09 <yairchu> :)
05:27:12 <Peaker> yairchu: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3097#a3097
05:27:39 <gwern> he's like dons! eery
05:27:50 <Peaker> yairchu: given N, find some N columns to delete that make most empty rows
05:28:13 <yairchu> hmm
05:28:27 <gwern> yairchu: if that isn't clear, scrollback and you'll find a number of descriptions of varying rigor & clarity
05:28:39 <yairchu> heh. I think I got it
05:28:45 <yairchu> doesn't look easy though
05:29:04 <gwern> some incompelte code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7612#a7639
05:29:19 <gwern> (I have the full version on my laptop, but it crashed just before I pasted it)
05:29:24 <WorkyBob> what's the difference between peekCString and peekCAString?
05:29:35 <gwern> yairchu: yeah, the original programmer is solving it via simulated annealing
05:29:36 <Peaker> yairchu: its not a riddle, its a real problem - gwern was trying to optimize language learning (what words do I need to learn to fully understand maximal number of sentences?)
05:29:56 <yairchu> one thing that came to my mind
05:30:25 <yairchu> nm that doesn't work :)
05:31:13 <Pistahh> WorkyBob:
05:31:15 <Pistahh> peekCString    :: CString -> IO String
05:31:15 <Pistahh> peekCString = peekCAString
05:31:16 <Peaker> A heuristic could probably assign a value on each square, that is higher based on the more stuff on the same columns, and less stuff in the same row, and then you could choose the "best" at each iteration.. if you want a heuristic
05:31:36 <gwern> yairchu: well, your wrong suggestion can't be any slower than my current version - which ran over night on a 74 sentence text file and still was nowhere close to done
05:31:49 <WorkyBob> Pistahh: hmm, so why the differing names?
05:31:51 <WorkyBob> what does the A stand for?
05:32:19 <Pistahh> WorkyBob: no idea
05:33:35 <rocketman> gwern: delete ll columns
05:33:37 <rocketman> all a
05:33:52 <Peaker> gwern: are you interested in a heuristic approximation of a solution?
05:34:19 <gwern> Peaker: well, I'd like to boast about an ideal solution and I figured it'd be easier to program than a heuristic one
05:34:36 <Peaker> gwern: I think my simple heuristic might have good results
05:34:42 <gwern> but on a large corpus heuristics are probably the difference between usable and unusable
05:34:58 <yairchu> and N is really big (ie exponentials algos are out of the question?)
05:35:03 <yairchu> ?
05:35:48 <gwern> yairchu: I'm not actually sure. the original guy is running it on the entire New Testament, but I don't know whether it might not work just as well for single books, say
05:36:01 <yairchu> N as in the number of deleted letters
05:36:11 <yairchu> I guess it's limited by the alphabet?
05:36:30 <Ytinasni> it's deleted words (in a sentence)
05:36:36 <yairchu> oh
05:36:42 <yairchu> got it
05:37:16 <WorkyBob> What's the oposite of -package
05:37:24 <WorkyBob> i.e. how do I ask ghc to specifically hide a package
05:37:32 <gwern> WorkyBob: -hide-something, I think
05:37:44 <gwern> could go with -hide-all to replicate the cabal experience, iirc
05:38:26 <WorkyBob> yeh, I'm pondering if what I want to do can be done with cabal anyway
05:38:40 <dschoepe> WorkyBob: ghc-pkg hide foo?
05:38:43 <WorkyBob> do I need a custom Setup.hs if I want to play with compiling sources to object code and then running ar on them?
05:39:03 <WorkyBob> i.e. I'm trying to build a C library with a bunch of haskelly stuff in it
05:57:00 <mlesniak> I'm reading the QuickCheck manual form http://www.cs.chalmers.se/~rjmh/QuickCheck/manual.html, but some functions are outdated. Anyone knows where I can find functions like verboseCheck, now?
05:57:26 <saml> @doc verboseCheck
05:57:26 <lambdabot> verboseCheck not available
05:57:35 <mlesniak> (Hayoo couldn't help either)
05:57:48 <saml> verboseCheck = check verbose
05:57:58 <saml> check :: Testable a => Config -> a -> IO ()
05:58:22 <saml> so verbose must be a Config!
05:58:38 <saml> and you pass a Testable to verboseCheck, and run it in IO monad i guess
05:58:48 <saml> let's see what is Testable
05:58:53 <mlesniak> saml: Hmm, right but the Args on http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.1/doc/html/Test-QuickCheck.html do not seem to have a config option (anymore?) ?
06:00:12 <saml> i don't even have verboseCheck when I imported Test.QuickCheck
06:00:27 <saml> QuickCheck-2.1.0.1
06:00:35 <mlesniak> saml: Yes, that's what I mean ;) And I don't have something equivalent atm
06:01:05 <saml> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Debug-QuickCheck.html   this is 1.2.0
06:01:16 <saml> 2.1.0.1 > 1.2.0 i think
06:01:34 <saml> i'm guessing verboseCheck is old stuff
06:01:52 <mlesniak> Yes, but I guessed 2.1 should have another function instead verboseCheck, Condition properties just don't seem so convenient :)
06:01:52 <saml> maybe use quickCheck
06:01:54 <ivanm> saml: most people still use 1.*
06:02:03 <saml> i still need to find what is Testable
06:02:17 <mlesniak> ivanm: Any specific reason why?
06:02:29 <ivanm> saml: as in what Testable is, or what data structures are instances of Testable?
06:02:35 <saml> > quickCheck True
06:02:36 <lambdabot>   Not in scope: `quickCheck'
06:02:46 <Phyx-> @check
06:02:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:02:54 <ivanm> mlesniak: don't know tbh; I think it's because they're more used to 1.*, and there were significant changes with 2.*
06:03:05 <ivanm> @instances Testable
06:03:06 <lambdabot> Couldn't find class `Testable'. Try @instances-importing
06:03:28 <mlesniak> ivanm: Yes, fighting with those changes now because nearly all I find is for 1.*
06:03:38 <ivanm> yeah
06:03:47 <ivanm> @seen dibblego
06:03:47 <lambdabot> dibblego is in #functionaljava, #scala and #haskell. I last heard dibblego speak 1h 15m 19s ago.
06:04:19 <saml> mlesniak, what do you want to test?
06:04:49 <saml> @check ((\s -> s == s) :: [Char] -> Bool)
06:04:50 <lambdabot>   "OK, passed 500 tests."
06:05:03 <saml> i'm reading http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
06:05:18 <ivanm> saml: wow, Char's equality instance is correct! :p
06:05:25 <mlesniak> saml: Yes, read that too, but it's outdated too ;)
06:05:39 <mlesniak> e.g. config is replaced by Args
06:05:40 <saml> haha i see verboseCheck
06:05:41 <Paczesiowa> ivanm: *seems:)
06:05:43 <Axman6> :t \x -> x x
06:05:44 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
06:05:44 <lambdabot>     Probable cause: `x' is applied to too many arguments
06:05:44 <lambdabot>     In the expression: x x
06:05:47 <ivanm> Paczesiowa: true
06:05:59 <ivanm> or, to make it more relevant, True ;-)
06:06:05 <Axman6> :t (\x -> x x) id
06:06:07 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
06:06:07 <lambdabot>     Probable cause: `x' is applied to too many arguments
06:06:07 <lambdabot>     In the expression: x x
06:06:27 <ivanm> Axman6: Haskell /= Lambda Calculus
06:06:35 <Axman6> yeah :\
06:07:03 <Peaker> gwern: semi-quick approximation http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3097#a3098
06:07:08 <Axman6> a friend of mine is doing a course with lambda calculus (one of the courses i'm doing atm uses it too), and i say some stuff like that
06:07:11 <Peaker> gwern: can be made a lot quicker
06:07:55 <Paczesiowa> :t \(x::forall a. a -> a) -> x x
06:07:57 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
06:10:57 <saml> >  (\(x::forall a. a -> a) -> x x) id
06:10:59 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:10:59 <lambdabot>    arising from a use of `...
06:11:13 <saml> >  (\(x::forall a. a -> a) -> x x) id 1
06:11:14 <lambdabot>   1
06:11:19 <saml> >  (\(x::forall a. a -> a) -> x x) succ 1
06:11:20 <lambdabot>   Could not deduce (GHC.Enum.Enum a) from the context ()
06:11:21 <lambdabot>    arising from a us...
06:12:39 <benmachine> you can't apply succ to itself
06:12:58 <ivanm> well, succ isn't an instance of Ord, is it?
06:13:02 <ivanm> @type succ
06:13:03 <lambdabot> forall a. (Enum a) => a -> a
06:13:09 <ivanm> s/Ord/Enum/
06:13:13 <benmachine> mm
06:13:33 <Plouj> hi
06:14:07 <Plouj> how do I work with ByteStrings? Do I have to pack data all the time to pass it to ByteString functions? How can I use IsInfixOf?
06:15:04 <ivanm> Plouj: see Data.ByteString.Char8
06:18:02 <tibbe> Plouj: if you want to do text processing rather than binary processing I suggest the text library
06:18:05 <tibbe> @hackage text
06:18:05 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text
06:18:31 <Plouj> actually, I just want something really basic reading of lines into tuples
06:18:40 <Plouj> maybe I don't even need ByteString at alll
06:19:06 <tibbe> Plouj: if performance doesn't matter then use String
06:19:54 <Plouj> I guess
06:19:54 <Peaker> @let readm = listToMaybe . fst . filter (all isSpace . snd) . read
06:19:55 <lambdabot>  Couldn't match expected type `(a, b)'
06:20:10 <Peaker> @let readm = fmap fst . listToMaybe . filter (all isSpace . snd) . read
06:20:12 <lambdabot>  Defined.
06:20:13 <Plouj> but it sucks that my code will have to change significantly depending on what representation I choose
06:20:21 <Peaker> > readm "(1,2,3)" :: (Int, Int, Int)
06:20:23 <lambdabot>   Couldn't match expected type `(GHC.Types.Int,
06:20:25 <Peaker> > readm "(1,2,3)" :: Maybe (Int, Int, Int)
06:20:26 <lambdabot>   * Exception: Prelude.read: no parse
06:20:32 <Peaker> oops
06:20:36 <Peaker> @undef
06:20:39 <tibbe> Plouj: that significantly?
06:20:42 <Peaker> @let readm = fmap fst . listToMaybe . filter (all isSpace . snd) . reads
06:20:43 <lambdabot>  Defined.
06:20:46 <Peaker> > readm "(1,2,3)" :: Maybe (Int, Int, Int)
06:20:47 <lambdabot>   Just (1,2,3)
06:20:54 <Peaker> > readm "(1,2,3)  " :: Maybe (Int, Int, Int)
06:20:54 <tibbe> Plouj: why?
06:20:55 <lambdabot>   Just (1,2,3)
06:20:58 <Peaker> > readm "(1,2,3)  4" :: Maybe (Int, Int, Int)
06:20:59 <lambdabot>   Nothing
06:21:00 <tibbe> Plouj: the interface is almost the same?
06:21:35 <Peaker> > map readm . lines $ "(1, 2, 3)\n(4,5,6)" :: [(Int, Int, Int)]
06:21:36 <lambdabot>   Couldn't match expected type `(GHC.Types.Int,
06:21:55 <Peaker> > (map readm . lines $ "(1, 2, 3)\n(4,5,6)") :: [(Int, Int, Int)]
06:21:56 <lambdabot>   Couldn't match expected type `(GHC.Types.Int,
06:22:15 <Axman6> :t map readm
06:22:16 <lambdabot> forall a. (Read a) => [String] -> [Maybe a]
06:23:00 <yairchu> :t mapMaybe readm
06:23:01 <lambdabot> forall b. (Read b) => [String] -> [b]
06:23:30 <Peaker> > sequence . map readm . lines $ "(1, 2, 3)\n(4,5,6)" :: Maybe [(Int, Int, Int)]
06:23:32 <lambdabot>   Just [(1,2,3),(4,5,6)]
06:23:43 <Peaker> Plouj: like that?
06:23:52 <benmachine> has anyone written an IRC client in haskell?
06:24:03 <Peaker> benmachine: you, one month from now :)
06:24:14 <Peaker> the best way to predict the future is to make it
06:24:14 <benmachine> Peaker: :D
06:24:24 <benmachine> but I wanted to make sure I wasn't reinventing any wheels
06:24:25 <ray> lambadbot is actually written in F# so no
06:24:54 <yairchu> google: http://www.haskell.org/hircules/
06:25:20 <benmachine> oic
06:25:27 <benmachine> google would've been a good idea, yes
06:26:06 <benmachine> thankyou
06:26:52 * benmachine is thinking of doing an ncurses one
06:27:12 <benmachine> actually, I bet just a plain IRC module would be quite nice
06:27:32 <Peaker> benmachine: can you make the GUI frontend detached enough that it could be either ncurses or anything else?
06:27:41 <Peaker> benmachine: that doesn't have color count limitations like ncurses, etc?
06:28:00 <saml> geordi might be written in hasekll
06:28:20 <benmachine> Peaker: well my new plan is to make a module for tracking IRC connections, and then make a client that sits ncurses on top of that
06:28:45 <benmachine> this plan is only minorly hampered by my being useless at haskell
06:28:46 <Peaker> benmachine: ircd would be that module, if it had facilities for remembering list of channels joined, history, etc
06:28:49 <benmachine> but you know :P
06:29:01 <Peaker> benmachine: #haskell always glad to help
06:29:07 <benmachine> ircd?
06:29:35 * benmachine can't find a haskell ircd
06:30:03 <Peaker> benmachine: the irc daemon
06:30:05 <Peaker> benmachine: the server
06:30:24 <saml> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/irc
06:30:27 <Peaker> benmachine: if the IRC server was fully-featured enough, all clients would be thinner, and you could migrate your IRC client state from one host to another
06:30:44 <saml> use that with Network.Socket ?
06:30:47 <Peaker> benmachine: basically it only entails keeping a list of joined channels and their history, it seems
06:31:10 <benmachine> Peaker: hmm
06:31:20 <benmachine> I don't see exactly how clients would be thinner
06:31:57 <Peaker> benmachine: they wouldn't have to keep histories if they could query the irc server for them, or the channel listing
06:31:57 <saml> /join #geordi  this bot is written in haskell
06:32:11 <Peaker> benmachine: well, I guess they would not necessarily be thinner (as they'd like to cache all of this)
06:32:13 <benmachine> saml: yeah I'm not talking about bots though :)
06:32:33 <Paczesiowa> http://quassel-irc.org
06:32:40 <benmachine> Peaker: shovelling histories over the network could be a little intensive couldn't it?
06:32:43 <Paczesiowa> maybe just write another frontend?
06:32:54 <benmachine> well I suppose that depends on what you need
06:33:02 <Peaker> benmachine: but at least they could maintain state when you re-connect not having to destroy your IRC chat state
06:33:02 <Peaker> benmachine: not if its done lazily/on-demand
06:33:38 <Peaker> benmachine: consider if /away was the norm, when you "disconnect", and you get all the messages that were meant for you kept in a special message log that is available when you re-connect, etc
06:33:57 <Peaker> benmachine: I guess #haskell would have tens of thousands of offline users in it :)
06:34:05 <Peaker> or maybe not
06:34:11 <benmachine> and we'd be logging for every one of them :o
06:34:17 <benmachine> well we'd log once of course
06:34:27 * benmachine shrugs
06:34:35 <Saizan_> that's basically what jabber does, right?
06:34:58 <Saizan_> (+ xml bloat i guess)
06:35:15 <Peaker> Saizan_: and not for large channels?
06:35:47 <Saizan_> Peaker: i've never used it much, i didn't know there was an exception for large channels
06:36:18 <Peaker> Saizan_: I thought jabber didn't have the notion of a channel, only peer-to-peer messaging
06:36:33 <Saizan_> Peaker: it does have channels, ime
06:36:44 <Badger> Skype does that.
06:37:05 <Badger> It automatically sends you everything that was said in text whilst you were gone
06:37:13 <gwern> Peaker: I'll have to look at that later
06:37:17 <jacobian> When debugging in ghci, is there a way to get strings to be pretty printed rather than printed as lists?
06:37:44 <Peaker> Prelude> "hello"
06:37:44 <Peaker> "hello"
06:37:52 <Peaker> jacobian: oh, you mean the interactive debugger
06:37:57 <jacobian> Yeah, sorry
06:38:02 <Peaker> my bad :)
06:38:04 <gwern> Peaker: but the basic idea is to remove one column at a time?
06:38:14 <Peaker> gwern: yeah, remove the heuristically best column
06:38:35 <Peaker> gwern: the one that removes the largest sum of fraction-from-its-row
06:38:38 <gwern> hm, but why is [] the best answer? :)
06:38:47 <Peaker> gwern: when n=0
06:39:00 <Cthulhon|WORK> Peaker: Maybe this theoretical message keeping could be opted into when the sender sends the message to avoid the bloat of tracking thousands of users' data at once for no reason.  And we could just embed it into existing ircds as a service.  A service that takes memos.  We could call it memoserv.Hey, wait a minute...
06:39:06 <gwern> oh, I see. it's the list monad idea - list of successes
06:39:32 <hackagebot> haskell-src-exts 1.1.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
06:39:59 <gwern> Peaker: i'll see how scalable that is when I get back
06:40:05 <gwern> but it looks pretty good
06:40:21 <gwern> did yairchu have any suggestions while I was asleep?
06:40:37 <Peaker> gwern: my thingie recomputes the fractions after each go, it can be made a lot faster, but its like N^3 now
06:40:53 <Peaker> gwern: nope, he had a nice simpler description of the problem though
06:41:07 <Peaker> gwern: <yairchu> given many sets. find a set of N items that is superset to as many of these sets
06:42:25 <gwern> hm. I was thinking identical sets, but I guess a superset can be identical to a subset
06:42:29 <gwern> but that is a nice description
06:43:26 <Peaker> maybe with that description, there's some CS paper to be found :)
06:44:07 <gwern> Peaker: I'm sure there is
06:44:37 <gwern> but I take it you mean by the recalculated fraction ' 1 `fidiv` Set.size words' ?
06:45:25 <Peaker> gwern: that's the heuristic
06:45:29 <yairchu> gwern: back. you were thinking identical sets? as in one of the given sets?
06:45:49 <gwern> vaguely yeah. didn't go anywwhere
06:45:58 <Phyx-> does anyone know a good resource on how to send haskell datatypes back and forth to C without using hsc2hs?
06:45:59 <yairchu> that's very solvable
06:46:03 <yairchu> just try all of them
06:46:08 <gwern> @hoogle (a,b) -> (b,a)
06:46:09 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
06:46:09 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
06:46:09 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
06:46:29 <Peaker> yairchu: of size<=N
06:46:47 <gwern> yairchu: right now I'm trying to understand Peaker's approximation. it's different enough from my code that I feel kind of blank
06:47:54 <Peaker> gwern: basically, each item in the 2d-table is 1/(amount of items in that row),  the column whose sum is the biggest seems most attractive to delete, because it would fill larger portions of more rows
06:48:43 <Peaker> gwern: so if one column has 1/3 of one row, 1/1 of another row, its better than a column that has 3 items that would cover 1/4 of a row each, as an example
06:49:17 <Peaker> so when you delete that first column, that 1/3 row has 2 blanks left to delete, and another row is fully covered
06:49:29 <benmachine> my haddock is complaining that it doesn't have the same version of ghc as I do, but cabal offers no upgrade
06:49:51 <benmachine> (haddock --ghc-version is 6.10.3 ghc --version is 6.10.4)
06:50:03 <benmachine> how do I en-newen it?
06:50:17 <Saizan_> benmachine: cabal install haddock
06:50:17 <gwern> benmachine: do a force reinstall
06:50:18 <Peaker> the approximation can go bad if it makes you try to satisfy lots of lots of rows that are far from satisfaction (and then failing to satisfy any), rather than choosing a column that would satisfy a few rows, but really satisfy them
06:50:37 <Saizan_> benmachine: --reinstall if needed
06:50:39 * benmachine --reinstall
06:50:56 <gwern> Peaker: so it focuses on rows which are *almost* done, in other words?
06:51:16 <gwern> (ack, I've got to go. I'll be back in a while)
06:51:24 <Peaker> gwern: it focuses on *columns* which may contain lots of blanks in rows that are not close enough to done to actually cover
06:51:42 <Peaker> (so it may make a lot "progress" towards covering rows, but not actually cover any)
06:51:51 <Peaker> as the approximation tries to make "progress" rather than actually fully cover rows
06:51:53 <benmachine> okay that worked, thanks guys
07:04:48 <benmachine> the Network.IRC package contains no interface to the network whatsoever >_>
07:05:01 * benmachine would have called it Network.Protocol.IRC or something
07:07:59 <Peaker> benmachine: sounds like good design
07:08:22 <benmachine> Peaker: well it's not actually a networking package though is it
07:08:27 <benmachine> it's actually just a parser
07:08:35 <Peaker> modularity is a great thing :)
07:09:04 <benmachine> I never said it wasn't
07:09:38 <WorkyBob> benmachine: the hierarchy in Haskell is at best suggestive
07:10:03 <benmachine> what is it at worst :P
07:10:05 <WorkyBob> Control.(*) could equally well be called Data.$1, and vice versa for example
07:10:16 <WorkyBob> at worst, it's a bunch of rubbish
07:10:45 <benmachine> heh fair enough
07:19:06 <mbuf> In http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7629#a7629, if I want the 'writer' handle 'hdl' to operate in ReadWriteMode, what should I include?
07:19:48 <mbuf> I have seen this usage, "do connhdl <- socketToHandle connsock ReadWriteMode"
07:33:22 <harlekin> @pl (\(c:cs) -> f c:cs)
07:33:22 <lambdabot> ap ((:) . f . head) tail
07:33:57 <harlekin> I am looking for a function I can use to capitalize a word (String). Is there something there which is less obscure?
07:34:05 <harlekin> @pl (\(c:cs) -> toUpper c:cs)
07:34:05 <lambdabot> ap ((:) . toUpper . head) tail
07:34:58 <LeoD> map toUpper
07:35:22 <LeoD> @type map
07:35:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:35:29 <harlekin> I only want to capitalize a word. Not to yell at. :)
07:35:40 <LeoD> ohh, sorry
07:35:42 <LeoD> :)
07:35:47 <harlekin> s/at/it/
07:38:37 <doserj> > liftM2 (:) (toUpper.head) tail $ "hello"
07:38:39 <lambdabot>   "Hello"
07:39:05 <doserj> (using the evil (->) a monad)
07:39:39 <doserj> I don't think (\(c:cs) -> toUpper c:cs) is so obscure, though
07:40:17 <pikhq> Hush. The (->) monad isn't evil.
07:40:20 <LeoD> less obscure than using the (->) monad imo ;)
07:40:22 <pikhq> 'Tis quite nice.
07:40:50 <pikhq> Though it can, of course, get out of hand pretty quickly.
07:41:54 <pikhq> > ap ((:) . toUpper . head) tail $ "hello" -- Note, though, that it is probably quite a bit easier to read using the S combinator.
07:41:56 <lambdabot>   "Hello"
07:44:03 <harlekin> doserj, I don't think neither. But I assumed there was already something there that applies a function to the head of a list.
07:45:28 <nick-m> morning.
07:46:13 <Phyx-> morning
07:46:49 <nick-m> I have one quick question. Has anyone tried using the TextMate Haskell plugins for the E-TextEditor on windows? Some of the scripts are in applescript.
07:50:34 <jmcarthur_work> the (->) a monad is neither evil nor obscure :P
07:52:48 * osfameron finds (->) very confusing
07:53:19 <osfameron> but I'm sure it is friendly when you get to know it
07:53:45 <Phyx-> osfameron: how so?
07:54:04 <quicksilver> its confusing insofar as you don't realise you're using it
07:54:16 <quicksilver> that's the main hurdle I thinkk.
07:54:29 <jmcarthur_work> all it means that that a final hidden argument is applied before the Applicative application or the Monadic bind
07:54:30 <quicksilver> or don't realise somene else is using it, perhaps.
07:55:04 <jmcarthur_work> i dunno, i think a reasonable type signature is enough to avoid confusion
07:55:16 <jmcarthur_work> and of course don't try to use it deeply within a larger function
07:55:48 <Phyx-> hmm how does one construct a Ptr? i can't see any function that does so
07:56:50 <Vanadium> Phyx-: Maybe alloca, more or less
07:56:57 <Phyx-> ah
07:56:59 <Phyx-> @alloca
07:57:00 <lambdabot> Unknown command, try @list
07:57:07 <Phyx-> @hoogle alloca
07:57:07 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
07:57:07 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
07:57:07 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
07:57:17 <quicksilver> Phyx-: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Foreign-Marshal-Alloc.html
07:57:21 <quicksilver> for example.
07:57:39 <quicksilver> although actually I think most often I use 'withArray'
07:57:45 <Phyx-> ah ok, i was looking in Foreign.Ptr
07:58:01 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Foreign-Marshal-Array.html
07:58:19 <Phyx-> quicksilver: cool, thanks :)
07:58:21 <quicksilver> it goes without saying that normally you don't want to :)
07:58:56 <Phyx-> well, using Ptr is the only way to get haskell datatypes to C isn't it?
08:00:50 <quicksilver> Phyx-: certainly not the only way.
08:01:36 <Phyx-> quicksilver: oh, hmm what other ways are there?
08:02:22 <harlekin> @pl (\(a,b) -> a:b)
08:02:22 <lambdabot> uncurry (:)
08:02:26 <harlekin> -.-"
08:03:03 <BONUS> how correct would it be to say that a linear map is a catamorphism between vector spaces
08:04:20 <quicksilver> Phyx-: marshal the data to C types in some natural way. Or some un-natural way if you prefer.
08:05:42 <Phyx-> quicksilver: right, using Storable correct?
08:07:13 <quicksilver> Phyx-: well using Storable is mostly used with Ptr.
08:07:45 <quicksilver> Phyx-: what I meant is : data Foo = Foo Int String; OK, I will represent a Foo as an 'int' and a 'char*'.
08:07:54 <quicksilver> over the FFI as CInt and CString.
08:08:14 <Phyx-> right
08:09:21 <Phyx-> i could do that, but that would be alot more work for a large datastructure I presume
08:12:48 <eipi> trying to setup ghc-6.10.4 on a lenny
08:13:19 <eipi> and when installing some packages, it just hangs during the linking
08:13:38 <Phyx-> @hoogle a -> Ptr a -> Ptr a
08:13:38 <lambdabot> Foreign.Ptr alignPtr :: Ptr a -> Int -> Ptr a
08:13:39 <lambdabot> Prelude asTypeOf :: a -> a -> a
08:13:39 <lambdabot> Foreign.Marshal.Array advancePtr :: Storable a => Ptr a -> Int -> Ptr a
08:14:39 <eipi> I've been installing first HTTP and zlib without problem (with runghc Setup.hs configure, build, install), but it hangs when linking for cabal-install
08:14:46 <eipi> any clue why?
08:15:23 <QP> hey guys, can I ask about a problem I'm having? It's to do with lazyness and socket handles...
08:15:52 <osfameron> get a socket button instead, if you're too lazy to turn the handle.
08:16:13 <QP> basically, I've written a function :: Handle -> Handle -> IO ()
08:16:34 <QP> that should take input from the first handle and output to the second
08:16:48 <QP> it works great with stdin stdout
08:17:25 <BONUS> let me guess - it's IO lazy?
08:17:39 <QP> but with a socket handle --- as both input and output --- it doesn't work
08:17:50 <Vanadium> Is there a predefined function that is just flip fmap?
08:17:50 <Saizan_> QP: i think it's more about buffering than lazy IO
08:17:53 <QP> I think it's too lazy, yeah
08:18:18 <Saizan_> QP: can you paste the code? normal IO read/write actions aren't lazy at all
08:18:20 <QP> Saizan_: you mean i need to set NoBuffering
08:18:25 <QP> ?
08:18:31 <Saizan_> QP: or use hFlush
08:18:32 <BONUS> or just flush it appropriately
08:18:33 <pikhq> Vanadium: No, but you can just use it infix. (<$> foo). :P
08:18:34 <BONUS> gah
08:18:42 <QP> I haven't done that---good shout!
08:19:04 <Vanadium> pikhq: Hm, I suppose that will work
08:19:06 <QP> I'll get back to you when I've tried that
08:19:56 <Saizan_> the only lazy IO in the standard libraries comes from hGetContents
08:19:56 <BONUS> :t let result = (.) in (result.result) and map
08:19:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:20:21 <BONUS> man how come i never thought of (.) as unary like first and second
08:20:23 <Saizan_> in the other cases side effects get completed before the action returns
08:20:35 <QP> Saizan_: that's why i thought it was lazyness, i read a blog entry on getContents
08:20:48 <QP> I see now
08:21:01 <Vanadium> ... though (<$> get) (,,) <$> getFoo <*> getBar <*> getBaz is probably a bad pattern to get used to anyway
08:21:50 <QP> Saizan_: thanks for your help, that is now working
08:22:04 <Saizan_> QP: np :)
08:22:04 <Vanadium> Pretend I had another $ there
08:22:57 <Saizan_> Vanadium: why not <*> get at the end? or something like that
08:23:00 <mikesteele81> hGetContents caught me off guard yesterday.  I wanted to pull the contents of a file into a string then close the buffer, but ended up doing all my work in one place instead.
08:23:03 <quicksilver> Saizan_: readFile
08:23:13 <quicksilver> Saizan_: (which is possibly even worse as it can leak file descriptors)
08:23:40 <Vanadium> Saizan_: I kind of wanted to aovid wrapping more parentheses around everything
08:27:27 <Saizan_> ?src readFile
08:27:28 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
08:27:36 <Saizan_> in my defense :)
08:31:42 <Beelsebob> shame about openFile's argument order
08:31:54 <Beelsebob> readFile = hGetContents <=< openFile ReadMode would be much nicer
08:32:37 <pikhq> readFile = hGetContents <=< (flip openFile) ReadMode
08:32:46 <Beelsebob> well sure -- but that's ugly
08:32:50 * lilac thinks hGetContents should be called unsafeHGetContents
08:34:05 <chrisbrown> Beelsebob: you need a <=<* operator, to flip the arguments of its RHS expression :)
08:34:50 <Beelsebob> chrisbrown: tbh, in this case, I think openFile's arguments are in the wrong order -- I can't think of any reason you'd want to pass the Read/Write mode after determining which file you're working on
08:35:03 <chrisbrown> Beelsebob: I agree
08:35:13 <Beelsebob> but a openRFile = openFile ReadMode would be very useful for example
08:45:35 <athos> ghc: panic! (the 'impossible' happened)
08:45:37 <athos> hah :)
08:49:13 <blueonyx> where are ghandle, gfinally and friends defined?
08:49:43 <Saizan_> g?
08:50:00 <blueonyx> yea
08:50:02 <LeoD> Control.Exception i think
08:50:40 * blueonyx is digging through the guts of GHC ;D
08:50:57 <Saizan_> inside ghc then, probably
08:51:20 <blueonyx> there are 2 screens of import lines :/
08:51:24 <Saizan_> http://hackage.haskell.org/packages/archive/ghc/6.10.2/doc/html/Exception.html#v:ghandle
08:51:37 <Saizan_> hayoo ftw
08:52:09 <blueonyx> ah thanks
09:00:29 <seanmcl> Is there a way to do anonymous function pattern matching in Haskell?  E.g., as in SML: fn [] => 1 | x::xs => 2, or Ocaml: function [] -> 1 | x::xs -> 2
09:01:40 <Peaker> seanmcl: You can use pattern-matchers like maybe or foldr
09:01:49 <Peaker> seanmcl: or case
09:02:17 <seanmcl> ok, just wondering if there was something like \[] -> 1 | c:cs -> 2
09:02:42 <dino-> and pattern match in lambdas
09:02:47 <dino-> > (\(x:ys) -> x) ["foo", "bar"]
09:02:48 <lambdabot>   "foo"
09:05:12 <dino-> Oh, I see what you're saying
09:06:34 <Peaker> @type foldr (\x y -> 2) 1
09:06:35 <lambdabot> forall a b. (Num b) => [a] -> b
09:06:42 <Peaker> > foldr (\x y -> 2) 1 []
09:06:44 <lambdabot>   1
09:06:44 <Peaker> > foldr (\x y -> 2) 1 [1,2,3]
09:06:46 <lambdabot>   2
09:06:56 <Peaker> seanmcl: functions that pattern-match for you
09:07:22 <Saizan_> lambdas with multiple alternatives would be nice
09:07:44 <Saizan_> but noone has gone and implemented them as a language extension :)
09:07:50 <defun> Hi, I am trying to make this program loop and print data to the terminal. It is looping but not printing data. What am I doing wrong? (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7645#a7645)
09:08:07 <Peaker> I think that requiring a little name/documentation on stuff is not a bad thing :)
09:08:08 <seanmcl> ok, thanks!  I like the fold trick.
09:08:24 <Beelsebob> defun: well, for one, asSeconds doesn't need to be in a monad at all
09:08:28 <Peaker> seanmcl: its not exactly a "trick",  foldr is a function that pattern-matches for you, and calls the appropriate function
09:08:33 <Peaker> @src maybe
09:08:33 <lambdabot> maybe n _ Nothing  = n
09:08:33 <lambdabot> maybe _ f (Just x) = f x
09:08:47 <defun> one sec.
09:08:58 <Peaker> seanmcl: same thing for "maybe".  Its the "catamorphism" of the data-type, i.e: a function that takes a handler for each possible pattern-match
09:09:25 <Beelsebob> defun: also, you're just spinlooping -- it's plausable that you just miss that time... You want to use timers/sleep the thread instead
09:09:49 <Beelsebob> also, defun -- what's initial?
09:09:53 <seanmcl> didn't mean 'trick' as a pejorative
09:10:04 <defun> Beelsebob: if I remove the 'return' then I get an error: (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7646#a7646)
09:10:26 <defun> Beelsebob: initial is the initial time. new is the new time.
09:10:40 <defun> how do I sleep the thread?
09:10:43 <defun> use timers?
09:11:25 <Beelsebob> defun: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7645#a7647
09:11:36 <Beelsebob> oops, that should be threadDelay, not threadWait
09:11:59 <defun> wow. that's cool.
09:12:30 <defun> what's the diff between thread delay and tthreadWait?
09:12:41 <Beelsebob> threadWait doesn't exist
09:12:42 <Beelsebob> >.>
09:12:48 <defun> oh...
09:13:06 <Peaker> defun: also, you're avoiding do notation?
09:13:47 <Beelsebob> personally I'd probably write it as timeLoop <* threadDelay 2000000 <* print . asSeconds =<< getClocTime
09:14:26 <Peaker> defun, Beelsebob: It seems the original program just calls getClockTime twice in roughly the same time, it will get roughly the same second
09:14:36 <mux> epigram 2 sounds promising
09:15:02 <Beelsebob> Peaker: sure -- but it never updates initial, in fact, it never defines it
09:15:11 <Beelsebob> oh, yes it does
09:15:15 <Beelsebob> yeh I see what you're saying
09:15:31 <Saizan_> i'd write "forever $ do print . asSeconds =<< getClockTime; threadDelay 2000000"
09:15:32 <Beelsebob> it doesn't ever print because it's always asking for the time twice within really quick succussion
09:15:45 <Beelsebob> Saizan_: yeh, that's neater
09:15:56 <Beelsebob> though I wouldn't use the do -- just to keep the order consistant
09:16:12 <Peaker> The problem with that kind of loop is that its not every 2 seconds, its every 2+little
09:16:37 <Peaker> you want to catch the time before looping, and then sleep until the next initialTime + 2*whole number
09:17:05 <Saizan_> Beelsebob: if you split it over 2 lines it reads nicely
09:17:11 <Beelsebob> true
09:17:17 <Beelsebob> Peaker: true
09:17:22 <Beelsebob> that's easily fixed though
09:17:59 <Peaker> I like forever on a MaybeT, so you can break
09:19:52 <Saizan_> no need to break here, it seems :)
09:20:03 <Saizan_> also, in IO you can just throw an exception to break
09:20:40 <defun> threadDelay not in scope,  it seems...
09:21:40 <defun> Peaker: yes I am avoiding do, for the moment. Just want to see which way of usng monads suites me better...
09:21:44 <Saizan_> ?hoogle threadDelay
09:21:44 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
09:21:51 <defun> ah. thanks.
09:22:26 <Peaker> defun: basically, there's a huge concensus going for do notation over explicit >>= \blah -> ..  like these, but its a great way to get comfortable with monads at first
09:23:09 * mux likes >> and >>= when you only have 2 or 3 actions to deal with
09:23:28 <Peaker> I like >> and >>= when no backslashes are required :)
09:23:31 * Twey nods.
09:23:34 <LeoD> i think it's nice to use >>= as long as you can do it without any lambdas
09:24:01 <Twey> Don't underestimate fmap, either, though.
09:24:11 <pikhq> I use >>= much like I would use a UNIX pipeline.
09:24:15 <MyCatVerbs> I like >>= when I'm tired and my head hurts. >> is for puny humans incapable of typing \_.
09:24:32 <ray> i like >=>
09:24:35 <pikhq> getContents >>= putStr -- Now, that? That seems quite nice.
09:24:40 <MyCatVerbs> :t (>=>)
09:24:42 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:24:45 <pikhq> ray: That too is quite nice.
09:24:58 <MyCatVerbs> ray: meh, it's just Kleisli arrow composition. :/
09:25:10 <MyCatVerbs> Er hang on I mean no.
09:25:10 <ray> what could be better than kleisli arrow composition?
09:25:18 <MyCatVerbs> ray: yay, it's Kleisli arrow composition! ^_^
09:25:19 <pikhq> MyCatVerbs: And that's quite nice.
09:25:31 <LeoD> never had any use for it :|
09:25:39 <LeoD> i hope that will happen some day
09:26:15 <Peaker> pikhq: fmap is more akin to a pipeline than >>=, no?
09:26:43 <Peaker> pikhq: (.) or fmap, as (>>=) chooses an action based on previous inputs, and UNIX pipes can't do that
09:27:18 <pikhq> Peaker: >>= is still quite a bit like a pipeline, when you're discussing the IO monad.
09:27:22 <MyCatVerbs> Peaker: I would pick (>>>) and (<<<) rather than fmap, seeing as they're somewhat more general. :)
09:27:53 <mux> <$> is my fmap of choice
09:28:00 <Peaker> MyCatVerbs: I don't know if (>>>) is more general than fmap..
09:28:14 <mux> I use fmap if I don't want to depend on Control.Applicative
09:28:22 <Peaker> MyCatVerbs: what if something is a Functor and not a Monad,  then you have fmap, but not Kleisli >>> ?
09:28:23 <mux> and I never use liftM
09:28:32 <ray> (.) is my fmap, i depend on no-implicit-prelude
09:28:37 <mux> heh.
09:28:38 <Peaker> mux: liftM allows your function to be   Monad m => .. rather than (Monad m, Functor m) => ...
09:28:54 <mux> Peaker: yeah, I just never had a use for it (yet)
09:29:10 <Saizan_> it's funny how "more general" is so ambiguous
09:29:20 <MyCatVerbs> Peaker: you have a point. I'm not sure that there are things that are Functors but not Monads, and which you cannot create a reasonable Arrow instance for anyway, though?
09:29:34 * pikhq wishes that Monads were a subset of the Functors
09:29:47 <Peaker> MyCatVerbs: I'm pretty sure there are Functors that aren't even Applicatives
09:30:18 <MyCatVerbs> Peaker: I can't think of any offhand, can you? And it's the last bit that I'm using for wiggle room. ;)
09:30:22 <pikhq> There's also some Monads that aren't Functors, I'm sure. (even though all monads are functors)
09:30:23 <mux> it seems you use either one you want in practice, at least 95% of the time I'd say
09:30:29 <MyCatVerbs> Peaker: but, bleh, fine. (>>>) is strictly more powerful than (.), is that I'm really aiming for, anyways.
09:30:45 <Peaker> MyCatVerbs: pikhq vice versa?
09:30:46 <Peaker> oops
09:30:49 <Peaker> pikhq: vice versa?
09:30:59 <pikhq> Peaker: Note vice versa.
09:31:08 <pikhq> The monads are a strict subset of the functors.
09:31:14 <Peaker> pikhq: "There's also some monads that aren't Functors" part
09:31:39 <pikhq> Peaker: There's some Monads that aren't Functors, and there are some Functors that aren't Monads, yes.
09:31:53 <pikhq> Of course, there are no monads that aren't functors.
09:33:08 <Peaker> pikhq: are you distinguishing Monads from monads?
09:33:17 <pikhq> Peaker: Yes.
09:33:28 <Peaker> pikhq: oh, you mean people who messed up and didn't define their Functor instances?
09:33:36 <pikhq> Correct.
09:33:52 <Peaker> well, usually when people say "Its a Functor" they mean it is denotationally/in theory one
09:34:08 <pikhq> A Monad is a type defined as such. A monad is a type that satisfies the monad laws.
09:34:19 <pikhq> Minor difference. ;)
09:35:05 <Peaker> pikhq: never heard that distinction
09:35:34 <pikhq> It's only useful when you're discussing Monads that aren't monads or don't have Functor instances.
09:35:41 <pikhq> So it doesn't come up much. ;)
09:37:25 <Peaker> anyway, what's a functor that isn't a monad?
09:38:00 <Berengal> Peaker: (,) e
09:38:54 <Peaker> MyCatVerbs: so fmap can apply to (,) e  (if e is not a Monoid) but (>>>) cannot use a Kleisly arrow here
09:40:01 <saml> how do you reald kleisly?
09:40:21 <azathoth99> are monads like nads?
09:40:22 <glguy> Kleisli
09:40:23 <saml> clayz lee?
09:40:53 <idnar> I assumed it was more like "clize lee"
09:41:28 <Asztal> @hoogle #
09:41:28 <lambdabot> No results found
09:41:30 <saml> no one ever really heard Kleisli coming out of human's mouth
09:42:01 <idnar> haha
09:42:04 <jmcarthur_work> Berengal, (,) e is a monad if e is a monoid
09:42:15 <Berengal> jmcarthur_work: Yes, but not forall e.
09:42:19 <jmcarthur_work> right
09:42:44 <jmcarthur_work> oh, it has been addressed already anyway
09:42:46 <Gwern-away> benmachine: at its worst, the haskell module hierarchy is lewd and lascivious
09:42:48 <jmcarthur_work> nevermind me :)
09:44:12 <lilac> fwiw, "data X a = One a | Two a a" is a functor but not an applicative functor, iirc
09:45:56 <Phillemann> If I want to express (>>=) in terms of join and fmap, would that be: a >>= f = join . (fmap f a)?
09:46:53 <doserj> close
09:47:35 <azathoth99> lewd!
09:47:37 <saml> :t (>>=)
09:47:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:47:50 <byorgey_> Phillemann: (fmap f a) :: m (m b)  -- it isn't a function so it doesn't make sense to use function composition . there
09:48:17 <saml> @pl (\a b -> a >>= b)
09:48:17 <lambdabot> (>>=)
09:48:38 <Phillemann> Hmmm
09:49:15 <Phillemann> So $ instead of .
09:49:31 <byorgey> Phillemann: right, or just a space =)
09:49:32 <pikhq> saml: (\a b -> f a b) is “f” for all f.
09:49:46 <Phillemann> byorgey: Of course. ;)
09:49:56 <byorgey> oh, I see, you meant $ and drop the parens, sure
09:53:09 <deech> Hi all, are there any good resources on implicit parameters in GHC? I
09:53:09 <deech>         have already John Hughes' paper and the GHC manual.
09:53:15 <Phillemann> Ah, and "join a" is just: join a = a >>= id
09:56:05 <doserj> Phillemann: next exercise, write join and >>= in terms of >=> (and vice-versa) :)
09:56:18 <byorgey> awwww, I finally got my code to compile after 2 hours and it just gets stuck in an infinite loop =(
09:56:46 <byorgey> deech: probably not.  no one really ever uses them.
09:58:35 <Phillemann> doserj: I'll try ;)
09:58:49 <Gwern-away> deech: and they shouldn't really ever use them either
09:58:57 <deech> So for a global variable, using an IORef and unsafePerformIO is recommended?
09:59:03 <Gwern-away> if you learn them, learn them so you can remove their usage in whatever library you're reading
09:59:22 <athos> if i fetch something from darcs
09:59:42 <athos> like yi, and it reports me that there are like 15 missing dependencies, is it still possible to use cabal-install to fetch dependencies automatically?
09:59:50 <deech> I am trying to share resources among threads *without* using STM or MVars.
09:59:57 <Gwern-away> athos: don't see why not
10:00:16 <athos> Gwern-away: how can i accomplish that?
10:00:27 <Gwern-away> 'cabal install' in the dir?
10:00:48 <Gwern-away> cabal install works both with a local directory and with just a package-name-to-fetch-remotely
10:00:50 <athos> hah, nvm :)
10:00:55 <athos> i did cabal configure
10:00:56 <athos> ;-)
10:01:10 <athos> thank you anyways Gwern-away
10:01:17 <pikhq> deech: You are almost certainly doing the wrong thing.
10:01:31 <pikhq> Revise your thought process.
10:04:00 <deech> pikhq, ok how does one share mutable resources among multiple threads in Haskell? Basically I am trying to understand how STM and MVars are designes. Currently GHC hides most of the interesting implementation in low-level C code.
10:06:59 <Saizan_> well, you use MVars or STM :)
10:07:14 <Saizan_> on STM there are a few papers that talk about the implementation too
10:07:17 <glguy> or if you don't care about consistency, IORefs :)
10:09:05 <Gwern-away> @pl getBest x = unlines · head  · process x
10:09:06 <lambdabot> (line 1, column 22):
10:09:06 <lambdabot> unexpected "\183"
10:09:06 <lambdabot> expecting variable, "(", operator or end of input
10:09:15 <Gwern-away> @pl getBest x = unlines . head  . process x
10:09:15 <lambdabot> getBest = ((unlines . head) .) . process
10:10:58 <pikhq> glguy: He was suggesting IORefs and unsafePerformIO.
10:11:08 <pikhq> Which is, well, NO NO NO NO and also NO.
10:12:17 <Saizan_> pikhq: well, if you truly need a global variable there's no other way
10:12:23 <lilac> Gwern-away: getBest = fmap fmap fmap (fmap unlines head) process
10:12:26 <Saizan_> pikhq: and it's a quite standard hack
10:12:37 <Gwern-away> @quote fmap.*fmap.*fmap
10:12:37 <lambdabot> No quotes match. That's something I cannot allow to happen.
10:12:50 <Saizan_> pikhq: my usual point is that you should avoid global variables :)
10:13:09 * Gwern-away looks furtively at some code using unsafePerformIO. *fmap fmap fmap fmap*...
10:16:08 <pikhq> Saizan_: My point is not that that's not how you do global variables. My point is that if you're needing global variables, you're doing it wrong. ;)
10:16:47 <dcoutts> there's no such thing as a global variable! :-)
10:17:14 <pikhq> dcoutts: Unfortunately, there exists unsafePerformIO.
10:17:25 <copumpkin> hah, I like the unsafePerformIO + newIORef thing :P
10:17:34 <copumpkin> although I've never actually used it
10:18:48 <dcoutts> that's not "global". It's scoped by the package instance, which is a sub-scope of process and linker scope.
10:19:42 <dcoutts> pikhq: my point is not that you cannot use the unsafePerformIO + newIORef trick, but that it does not give you a global variable, because there's no such thing, there is always a scope.
10:19:59 <pikhq> dcoutts: Fair enough.
10:20:03 <dcoutts> often it turns out to be a linker scope
10:20:07 <glguy> There is always the ability to fmap read (readFile "myglobal")  and (writeFile "myglobal" . show) :-D
10:20:21 <Gwern-away> o.0 my program has some odd results
10:20:24 <dcoutts> glguy: right, that's file system namespace scope
10:20:41 <Gwern-away> apparently one of the most useful words to understand Frank Herbert's _DUne Genesis_ is... 'Stalin'
10:21:00 <dcoutts> glguy: if you go for a remote file over http say, then it's DNS resolver + ip scope :-)
10:21:04 <glguy> dcoutts: ah, you are contesting "global" variable in the sense that it isn't one variable for all of man kind?
10:21:20 <glguy> We have "global warming", but why not "global mutable references"??
10:21:28 <glguy> like, wikipedia!
10:21:37 <dcoutts> glguy: heh :-)
10:21:48 <Saizan_> well, global should at least be process-global
10:21:54 <pikhq> Clearly, there needs to be a toggleLight function that turns on and off the Sun.
10:22:01 <glguy> we'll need a new package "very-much-global" that stores serialized data on wikipedia
10:22:07 <dcoutts> glguy: my point is, it tends to encourage fuzzy thinking by not considering what the real scope actually is
10:22:34 <pikhq> And a getLight that results in an IO Bool
10:23:11 <azathoth99> well this haskell thing: are you really more productive? or is ti novelty? what apps exists? do you guys use haskell for all kinda internal apps in your comapny? eat own dog food?
10:23:26 <dcoutts> Saizan_: then the unsafePerformIO trick is not enough, that's not process scope, it's rather narrower
10:23:32 <azathoth99> for smalltalk 80 they used their own stuff i read at xerox
10:23:36 <azathoth99> made them make it good
10:24:18 <dcoutts> azathoth99: yeah, most Haskell tools are written in Haskell
10:24:27 <pikhq> azathoth99: You realise that most all of the Haskell tools are written in Haskell, right?
10:24:27 <lilac> weihsiu: getBest = fmap (fmap fmap fmap fmap) fmap fmap fmap fmap (fmap fmap fmap fmap) fmap fmap fmap fmap unlines head process
10:24:34 <Gwern-away> except for ghc, which famously is written in perl
10:24:43 <dcoutts> @slap Gwern-away
10:24:43 * lambdabot karate-chops Gwern-away into two equally sized halves
10:24:44 <lilac> Gwern-away: tab completion fail ^^  weihsiu: sorry! :)
10:25:05 <Saizan_> dcoutts: yeah, and you also get the other problem: it's hard to have two instances of something that uses the unsafePerformIO trick, so it's both unsafe and annoying :)
10:25:06 <Gwern-away> lilac: does - does that monstrosity actually type the same?
10:25:11 <lilac> yup
10:25:24 <dcoutts> Saizan_: yup :-)
10:25:25 <azathoth99> hm
10:25:27 <azathoth99> ok
10:25:32 <Gwern-away> fmap truly is strange. how many of those are basically 'id'?
10:25:45 <Gwern-away> azathoth99: great! so you can sign the haskeller contract over there, in blood
10:25:45 <hackagebot> AERN-Real 0.10.0 - arbitrary precision interval arithmetic for approximating exact real numbers (MichalKonecny)
10:25:52 <Gwern-away> and remember ,the term is for 10 billion years
10:25:57 <azathoth99> what am I signing up for?
10:26:02 <azathoth99> whos blood?
10:26:04 <Gwern-away> Hask Org
10:26:10 <Gwern-away> we have our own ship and everything
10:26:24 <Gwern-away> (a space ship, natch. with alien technology)
10:26:27 <pikhq> You are obligated to induce the singularity and create immortality.
10:26:48 <pikhq> And do 20 Hail Xenus daily.
10:26:53 <iago> does someone finds this useful http://www.moonpatio.org/fastcgi/hpaste.fcgi/view?id=3099 ? yet defined elsewhere?
10:27:15 <Gwern-away> pikhq: and 5 Our Wadlers
10:27:24 <Gwern-away> @hoogle m a -> (a -> Bool) -> m a
10:27:25 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
10:27:25 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
10:27:25 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
10:27:49 <iago> I asked hoogle too, before ask here ;P
10:28:00 <soupdragon>   r <- p
10:28:01 <soupdragon>   guard (pred r)
10:28:06 <dcoutts> azathoth99: if you're not familiar with Haskell, best place to start is at haskell.org main page
10:28:09 <soupdragon> guard . pred . p
10:28:10 <soupdragon> I think
10:28:16 <soupdragon> if you allow (.) = fmap
10:28:39 <soupdragon> then again, we do not have r so can't return it
10:29:27 <glguy> Should "theStdGen" have a NOINLINE pragma in the "random" package?
10:29:37 <azathoth99> hm
10:29:51 <azathoth99> would soeone be insane to build a socail network on haskell and linux?
10:30:10 <iago>   name <- identifier
10:30:10 <iago>   ...
10:30:10 <iago>   identifier `satisfying` (== name)
10:30:12 <iago> seems clearer
10:30:29 <dcoutts> azathoth99: there's a bunch of libs for building web apps, eg happstack
10:30:34 <jmcarthur_work> you have to be insane to build a social network on *any* language and platform ;)
10:30:40 <Gwern-away> azathoth99: I think the insanity there is building a social network, not what tech he picked
10:33:30 <Gwern-away> Peaker: I must say, the improvement in memory usage and runtime is pretty impressive
10:34:02 <Peaker> Gwern-away: are the results any good?
10:34:16 <Gwern-away> Peaker: I'm not sure of the correctness results I'm getting running on _Dune_, but they seem reasonably plausible...
10:35:12 <Peaker> Gwern-away: cool
10:35:41 <Gwern-away> Peaker: you can see my monstrosity at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3097#a3100
10:35:59 <Gwern-away> 37 seconds to run on _Dune_ isn't too bad at all
10:36:09 <Gwern-away> (this is with -N2)
10:37:15 <Gwern-away> Peaker: here's what I mean by the results seeming both odd and plausible: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3097#a3101
10:38:01 <Gwern-away> I mean, 'Reevaluation' shows up twice; why is it so high in the list?
10:38:03 <McManiaC> where does haddock look for the files to link the data types?
10:38:05 <Peaker> Gwern-away: without re-generating the whole ranking table/etc it can be far faster, probably around O(N logN)
10:38:08 <Gwern-away> *twice in _Dune_
10:38:18 <MyCatVerbs> Peaker: (,) e -- has a nice arrow.
10:38:26 <Peaker> MyCatVerbs: what is it?
10:38:38 <MyCatVerbs> A trivial one, even. :)
10:38:40 <Peaker> Gwern-away: Reevaluation? :)
10:38:46 <Peaker> Predestination?
10:39:01 <Peaker> do these words appear more than once anywhere? :)
10:39:18 <Peaker> Gwern-away: where's "the"?
10:39:28 <Gwern-away> Peaker: the is in the known words list
10:39:42 <Gwern-away> I wonder if I messed up the filter for knownwords...
10:39:48 <Peaker> Gwern-away: ah
10:39:53 <MyCatVerbs> Peaker: sure. It's just Control.Arrow.second. :)
10:40:04 <Peaker> Gwern-away: Reevaluation seems infrequent
10:40:31 <Peaker> MyCatVerbs: what's the arrow's (>>>)?
10:40:52 <Peaker> MyCatVerbs: I don't see how "second" defines an arrow?
10:41:00 <Gwern-away> hm ' filterKnown [["foo","quux"],["bar"]] ["foo"] ~> [["quux"],["bar"]]' which looks right
10:41:25 <Gwern-away> so it wasn't that it was ignoring any sentence with a known word in it, as I feared
10:41:52 <Peaker> Gwern-away: (not . null) is nicer than (/= []) imo :)
10:42:06 <Gwern-away> i was in a hurry
10:42:19 <Peaker> Gwern-away: also if you reverse filterKnown's args you can use (.) instead of $ and not mention corpus
10:42:36 <MyCatVerbs> newtype Secondy e a b = S { unS :: (e,a) -> (e,b) }; instance Arrow (Secondy e) where { arr f = S (\(e,a) ->(e,f a)); (S f) >>> (S g) = S (f >>> g); }  -- I think.
10:42:51 <Peaker> Gwern-away: there's also notElem, I think
10:43:07 <MyCatVerbs> Peaker: is an Arrow. Needs a newtype to make it clear. But it's trivial.
10:43:13 <Gwern-away> @hoogle notElem
10:43:14 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
10:43:14 <lambdabot> Data.ByteString notElem :: Word8 -> ByteString -> Bool
10:43:14 <lambdabot> Data.Foldable notElem :: (Foldable t, Eq a) => a -> t a -> Bool
10:43:28 <Peaker> > ["hello"] \\ "l"
10:43:29 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:43:32 <MyCatVerbs> Peaker: it's just how Arrow notation translates to stuff things into the snd of a tuple, really. :)
10:43:33 <Peaker> > ["hello"] \\ 'l'
10:43:34 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
10:43:39 <Peaker> > "hello" \\ 'l'
10:43:40 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:43:47 <MyCatVerbs> > "hello" \\ "l"
10:43:49 <lambdabot>   "helo"
10:43:50 <trofi> :t (\\)
10:43:51 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:43:55 <MyCatVerbs> Faiiiiiil. :)
10:43:58 <Peaker> ;)
10:44:01 <Peaker> > "hello" \\ "l"
10:44:03 <lambdabot>   "helo"
10:44:09 <MyCatVerbs> > "hello" \\ "ll"
10:44:10 <lambdabot>   "heo"
10:44:12 <Gwern-away> 'flip notElem $ known' isn't that much better
10:44:30 <Peaker> Gwern-away: (`notElem` known)
10:44:33 <Peaker> Gwern-away: why $ there?
10:44:34 <MyCatVerbs> The obvious solution is stop using lists as sets! The list-as-set functions suck! Use sets as sets!
10:45:04 <Gwern-away> because . doesnt compil
10:45:04 <Peaker> Gwern-away: filter (not . null) . (map . filter) (`notElem` known)
10:46:06 <MrBlueSky> Noob question: Can a compiled haskell program run on a computer that doesn't have the Haskell Platform installed?
10:46:06 <azathoth99> can you have sets of strings?
10:46:09 <Peaker> Gwern-away: I mean why $ as opposed to nothing?  flip notElem $ known = flip notElem known = (`notElem` known)
10:46:16 <Peaker> azathoth99: sure
10:46:25 <azathoth99> wow so then programmign becomes liek math?
10:46:27 <Peaker> MrBlueSky: yeah
10:46:33 <azathoth99> my web page a set of strings with html
10:46:39 <azathoth99> coool!!
10:46:41 <Gwern-away> azathoth99: sure. that's one of the haskell signatures
10:46:41 <pikhq> > nubBy (=='l') "hello"
10:46:43 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> GHC.Bool.Bool'
10:46:50 <Peaker> azathoth99: Most languages that have sets allow strings to be in them :)
10:46:58 <Gwern-away> azathoth99: messing around with definitions and derivations; haskell allows refactoring on crack
10:46:58 <azathoth99> ok now what about errors? say a file gets half downloaded?
10:47:05 <azathoth99> can haskel recover?
10:47:07 <azathoth99> prbly jsut use checksum right?
10:47:16 <azathoth99> but can it restart the transfer that faield halfway?
10:47:21 <azathoth99> liek rsync ?
10:47:25 <Gwern-away> depends on the library, I suppose
10:47:37 <Gwern-away> 'Can C just restart the failed transfer halfway?'
10:47:38 <Peaker> azathoth99: that's less of a language question, more of a library thing
10:47:55 <pikhq> azathoth99: Depends on the library. Worst-case scenario, you'd need to implement your own HTTP library that supported HTTP partial transfers.
10:48:10 <azathoth99> actaulyl Im stuckin unix file mindset, it would be jsut transferring oen set to antoher on another box, and having that box check to see if set same?
10:48:13 <azathoth99> WOW
10:48:34 <Gwern-away> Peaker: it's too bad that I don't see any obvious way to parallelize it; the pmaps don't do much
10:48:36 <azathoth99> and i bet haskell FAST for checking sets
10:48:50 <azathoth99> holy crap its brilliant if it works
10:48:53 <pikhq> Haskell is can be quite fast for a lot of things.
10:49:01 <pikhq> s/ is //
10:49:14 <Gwern-away> I don't actually know; has anyone benchmarked data.set?
10:49:40 <Peaker> Gwern-away: I think to speed up my thing you just need to avoid recomputing ranks -- and instead maintain a Map (k, v) Rank  that you update..
10:49:52 <Peaker> Gwern-away: Oh, also, I sort and then take the first result, you can change that to use minimum instead
10:49:53 <Gwern-away> Peaker: that is, by swaping all your maps for pmaps, I see it sometimes hits 200% but mostly it's at 100
10:50:16 <Gwern-away> oops. turns out that all of Frank Herbert's novels as a single input is too much for it :)
10:51:57 <Gwern-away> @hoogle minimum
10:51:58 <lambdabot> Prelude minimum :: Ord a => [a] -> a
10:51:58 <lambdabot> Data.ByteString minimum :: ByteString -> Word8
10:51:58 <lambdabot> Data.Foldable minimum :: (Foldable t, Ord a) => t a -> a
10:52:14 <Raevel> OH MY
10:52:15 <Raevel> ghc: panic! (the 'impossible' happened)
10:52:38 <Gwern-away> :t sortBy (flip compare)
10:52:40 <lambdabot> forall a. (Ord a) => [a] -> [a]
10:53:24 <Peaker> Gwern-away: descending sort
10:54:49 <pikhq> > sortBy (flip compare) [1..10]
10:54:51 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
10:55:11 <pikhq> So, just the same as reverse . sort, except for laziness.
10:56:16 <maltem> Raevel, that's how using non-perfect extensions tends to manifest itself
10:56:58 <Raevel> maltem: also if forgetting the # in #-}
10:57:01 <Raevel> (-:
10:57:13 <maltem> uh :)
10:58:01 <Suttonian> I'd like to output some data aligned in columns to the console, what is the best way to do that
10:59:03 <Suttonian> are there any standard functions or functions part of ghc that would help?
11:00:46 <saml> let me find out
11:00:50 <benmachine> looks like my ncurses library has a fair few useful things that aren't in hscurses
11:00:52 <Gwern-away> ok, that's very weird. some of those apparently harmless changes made memory usage on dune genesis go from 0.0% of ram to 80%
11:02:00 <saml> > printf "%s7" "hello"
11:02:02 <lambdabot>   Add a type signature
11:02:12 <saml> > printf "%s7" ("hi" :: String)
11:02:13 <lambdabot>   Add a type signature
11:02:21 <Gwern-away> @hoogle parmap
11:02:22 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
11:02:59 <soupdragon> > printf "%s7" (("hi" :: String) :: String)
11:03:01 <lambdabot>   Add a type signature
11:03:01 <saml> > printf "10%s" ("hi" :: String)
11:03:03 <lambdabot>   Add a type signature
11:03:09 <soupdragon> > printf "%s7" ((("hi" :: String) :: String) :: String)
11:03:10 <Gwern-away> ...it was the parmap in 'process
11:03:10 <lambdabot>   Add a type signature
11:03:13 <benmachine> > (printf :10%s" "hi) :: String
11:03:14 <lambdabot>   Not in scope: `hi'
11:03:18 <benmachine> same difference
11:03:19 <soupdragon> lol
11:03:22 <benmachine> > (printf :10%s" "hi") :: String
11:03:23 <lambdabot>   <no location info>:
11:03:23 <lambdabot>      lexical error in string/character literal at end o...
11:03:24 <saml> Suttonian, use printf?
11:03:26 <soupdragon> lol
11:03:27 <benmachine> waat
11:03:34 <soupdragon> > printf "%s7" ((("hi" :: String) :: String) :: String) :: String
11:03:34 <benmachine> > (printf "10%s" "hi") :: String
11:03:36 <lambdabot>   "hi7"
11:03:36 <lambdabot>   "10hi"
11:03:37 <Gwern-away> wow. I suppose I should figure out why switching from 'map' to 'parmap rnf' can cause memory usage to go from 0.0 to >80%
11:03:48 <benmachine> it's onlt the printf itself that needs annotating
11:03:56 <Suttonian> I'll try that, thanks saml.
11:03:57 <Gwern-away> see guys this is the sort of thing which makes people say space behavior is unpredictable in haskell :)
11:04:00 <soupdragon> > (printf "%s7" ((("hi" :: String) :: String) :: String) :: String) :: String
11:04:01 <lambdabot>   "hi7"
11:04:08 <mdiin> I'm trying to package zlib, HTTP, and cabal-install for Slackware. I have succeeded (I think) in installing both zlib and HTTP, yet cabal-install fails to compile with a "could not find module Codec.Compression.GZip". ghc-pkg list lists zlib as installed. Any idea what might have gone wrong?
11:04:12 <tommd> Gwern-away: Read the recent multicore paper from Marlow
11:04:15 <benmachine> > printf "%s7" "hi" :: String
11:04:16 <lambdabot>   "hi7"
11:04:18 <saml> > (printf "%10s" "hi") :: String -- just like this
11:04:19 <lambdabot>   "        hi"
11:04:29 <tommd> Gwern-away: There is one leak where sparks aren't collected - you might be hitting that.
11:04:59 <Gwern-away> tommd: seems plausible. what is the leak?
11:05:44 <tommd> gwern-away: Don't recall off hand - I'm looking for the paper.
11:06:56 <tommd> Gwern-away: http://www.haskell.org/~simonmar/papers/multicore-ghc.pdf  (section 7)
11:14:46 <defun> Hi. I've not strayed away from Haskell 98 (much). I'm just curious about the GHC extention that implements GADTs. Why would I want to use them in place of the 'normal' ADTs?
11:15:07 <azathoth99> sets sets sets
11:15:40 <azathoth99> sets are like tables with more than 2 dimensions?
11:16:08 <Gwern-away> no; sets are like bags
11:16:13 <Gwern-away> unique entries with no ordering
11:16:18 <tommd> Sets are just that - a bunch of elements and you can test for membership.
11:16:27 <Saizan_> defun: with gadts you can have more guarantees from the type system
11:17:12 <defun> Saizan: would you advise using them over ADTs all the time?
11:17:24 <defun> *Saizan_:
11:17:58 <Lemmih> defun: No, he wouldn't.
11:18:02 <Gwern-away> Peaker: I'm going to bed now; if you want to make that Map efficiency change, my latest version is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3097#a3102 right now I'm running it on the full novel _Dune_, but it's taking a while and I guess the exponential thing has hit it
11:18:05 <soupdragon> defun: every ADT can be written as a GADT.. not vice versa (you may knew this already)
11:18:32 <soupdragon> defun: it's just usually the ADT def. is shorter so that's usually used
11:18:39 <Peaker> Gwern-away: maybe you can use github?
11:18:50 <soupdragon> defun: the GADTs that can't be written as ADTs are where the fun comes in though
11:18:55 <Peaker> Gwern-away: easy to create branches/revisions that way :) Not sure I'll have time to contribute anything though
11:18:58 <FunctorSal> btw stalonederiving for GADTs is in head =)
11:19:07 <soupdragon> defun: do you know about them?
11:19:09 <FunctorSal> ping conal
11:19:17 <FunctorSal> (IIRC you were interested in that)
11:19:19 <conal> FunctorSal: hey there
11:19:32 <conal> oh, hm.
11:19:44 <defun> soupdragon: I see. That makes more sense. Are there any apps/libs that use GADTs. I would like to look at some examples...
11:19:55 <conal> when did deriving for GADTs go in?
11:20:02 <Saizan_> defun: this is a nice example http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html
11:20:12 <defun> thanks :)
11:20:21 <conal> deriving for gadts is great news!
11:20:29 <tommd> What? When?
11:20:32 <FunctorSal> conal: http://hackage.haskell.org/trac/ghc/ticket/3012
11:20:50 <conal> FunctorSal: thx
11:21:45 <tommd> That deserves a blog entry
11:22:18 * FunctorSal doesn't have a blog :-(
11:22:58 * RayNbow doesn't have a blog either...
11:23:03 <Saizan_> it looks like it's quite restricted though
11:23:19 <djahandarie> I don't have the patience to write anything on a blog
11:23:21 <FunctorSal> Saizan_: it's not like in the ticket apparently
11:23:29 * RayNbow is tempted to write his own blog software if he decided to start his own blog...
11:23:33 <FunctorSal> Saizan_: it's unrestricted, but it's the user's fault if it doesn't typecheck
11:23:46 <badsheepy> then you could blog about writing a blog on your blog..
11:24:17 <shepheb> yo dawg
11:24:19 <RayNbow> my cheap webhost account only supports crappy languages like PHP though...
11:24:35 <RayNbow> so... is there a Haskell2PHP compiler? :p
11:25:01 <djahandarie> That would be annoying to write
11:25:05 <Saizan_> FunctorSal: well, it also depends on how hard it tries to write correct code :)
11:26:50 <RayNbow> Saizan_: writing code in PHP is hard... regardless of correctness ;)
11:29:18 <dons> so you want to target the PHP runtime from Haskell?
11:29:28 <dons> there's a Javascript compiler...
11:29:43 <RayNbow> dons: HS2JS?
11:29:56 <RayNbow> which compiler? yhc?
11:32:11 <saml> > let toPHP "putStr" = "<? echo" in toPHP "putStr"
11:32:13 <lambdabot>   "<? echo"
11:32:19 <saml> you can implement the rest
11:32:49 <soupdragon> data PHP = PHP String
11:33:08 <soupdragon> there's the data type for PHP calculus
11:33:25 <soupdragon> no worries about variable binding or any of that nonsense!
11:35:02 <saml> is GADT about general AST for all languages?
11:35:08 <soupdragon> no
11:35:20 <soupdragon> GADT is about equality of types
11:35:27 <saml> is there a such thing? AST for all possible languages
11:35:33 <soupdragon> no
11:36:57 <dons> lambda calculus :)
11:37:00 <tibbe> dons: I'm trying to read data from a file with know, fixed size fields. How would you do it. Is there anything that doesn't involve lazy I/O?
11:37:15 <tibbe> dons: i.e. I want something like BufferedFile.readIn64
11:37:21 <dons> Data.Binary strictly?
11:37:25 <dons> just force the result?
11:37:42 <tibbe> dons: I'm seeking back and forth in the file so turning it into a stream doesn't work
11:37:44 <dons> oh
11:37:59 <FunctorSal> "PHP calculus" hehehe ( soupdragon )
11:37:59 <dons> hmm. i don't think we have a nice 'seek' abstraction
11:38:06 <tibbe> dons: the file is an on-disk sorted map
11:38:19 <tibbe> dons: we lack a nice file abstraction!
11:38:38 <tibbe> I feel like Handles try to do to much and are hard to extend
11:38:51 <dons> mmm
11:39:10 <tibbe> we need some more low level components to compose
11:39:26 <tibbe> like Java's InputStream, BufferedInputStream, et al
11:40:40 <Saizan_> argh
11:40:48 <Saizan_> don't remind me of those!
11:41:26 <Saizan_> however i think JaffaCake was working on some way to extend Handles while implementing the unicode-io?
11:42:13 <Saizan_> i remember something like that floating around in #ghc at least
11:42:25 <djahandarie> Haskell is so Lazy I figure it's for me
11:43:09 <tibbe> dons: hmm, what do you think about a Buffer type that's constructed by wrapping a bytestring and the could be used to e.g. getInt which would read an Int using some byte order and increase an internal offset?
11:44:10 <erikc> Data.Binary has a monad for that
11:44:35 <byorgey> doesn't ByteString already use an internal offset into a buffer?
11:45:14 <erikc> Need to find the nearest coffee shop? There's a monad for that.
11:46:11 <deech> Can someone recommend a site that allows me to create a programming (Haskell) related blog? For example one that doesn't truncate or cut out weird characters.
11:46:17 <tibbe_> byorgey: it does
11:46:19 <tibbe_> erikc: which one?
11:47:00 <Gilly> deech: I think quite many people have their haskell blogs on wordpress.com
11:47:40 <erikc> tibbe: the Get monad in Data.Binary
11:48:51 <tibbe_> erikc: can you feed it from a file?
11:49:02 <tibbe_> erikc: I believe you have to resort to lazy I/O
11:53:52 <deech> thanks!
11:55:55 <byorgey> wordpress.org is OK.  better than blogger at least.  but it has its annoyances too.
11:57:13 <byorgey> well, wordpress.org is a fantastic blogging platform *in general*, I meant it has annoyances in terms of publishing Haskell code on it.
11:57:48 <byorgey> also, s/\.org/\.com/  =P
12:00:09 <Suttonian> My wordpress blog was injected with spam...my host needs to update their cpanels wordpress
12:00:51 <shepheb> wordpress has LaTeX, and that pretty much sold it for me.
12:01:00 <shepheb> actually, I moved from Blogger because of that.
12:01:37 * RayNbow wonders if there are good syntax highlighters for WP...
12:01:48 <byorgey> true, the LaTeX support is very nice, especially for more theoretical Haskell-ish things
12:01:54 <RayNbow> I once tried one that couldn't handle '''Python multiline comments well'''
12:03:04 <luite> byorgey: which LaTeX plugin do you use?
12:03:41 <byorgey> luite: well, my Haskell blog is hosted on wordpress.com, so I use whichever one is installed by default there
12:04:16 <byorgey> but I do have another self-hosted wordpress blog where I have LatexRender installed
12:04:24 <byorgey> dunno if that's the same one used on wordpress.com
12:06:06 <Beelsebob> hmm, I may have discovered a way of DoSing Wolfram alpha >.>
12:06:06 <luite> byorgey: thanks, will have a look. I'd like to have something that works with xy-pic and tikz
12:06:12 <Beelsebob> http://www38.wolframalpha.com/input/?i=prime+factors+of+23456789209847120934871098732401873408174234298769876087098709872346237861
12:06:16 <Beelsebob> <.<
12:06:55 <RayNbow> hmm
12:06:56 <RayNbow> http://www38.wolframalpha.com/input/?i=prime+factors+of+1
12:07:02 <RayNbow> 1 is a prime number?
12:07:03 <Saizan_> works fine here
12:07:48 <luite> I currently have some plugin that fetches an image from a mathtex.cgi script, but that breaks with long tikz scripts that exceed the max URL length
12:07:56 <Beelsebob> Saizan_: it just takes ages to compute
12:08:05 <Rotaerk> raynbow, there exist no other integer by which it is divisible other than 1 and itself (1)
12:08:09 <Rotaerk> so yes, it's prime
12:08:09 <Beelsebob> get enough people doing it and I'm sure it'll piss them off ;)
12:08:21 <Beelsebob> Rotaerk: by the normal definition, 1 is not prime
12:08:30 <Beelsebob> primes have exactly 2 integer factors
12:08:35 <LeoD> it should cache those computations, no?
12:08:44 <Beelsebob> LeoD: you'd expect that
12:08:46 <Rotaerk> really?
12:08:47 <Beelsebob> but it takes a while every time
12:08:49 <Beelsebob> Rotaerk: yep
12:08:53 <ray> 1 is not generally considered prime
12:08:59 <Beelsebob> Rotaerk: the primes start 2,3,5....
12:09:03 <Rotaerk> ah
12:09:07 <LeoD> Beelsebob: i got the answer almost immediately
12:09:25 <Beelsebob> LeoD: hmm, odd
12:09:36 <Beelsebob> maybe my connection is being coincidentally spacky at the same time as typing in large numbers
12:09:40 <RayNbow> http://www38.wolframalpha.com/input/?i=prime+factors+of+0 <-- :X
12:09:40 <LeoD> maybe it caches only after N requests :p
12:09:52 <Beelsebob> could be
12:10:05 <Beelsebob> RayNbow: awesome
12:11:21 <RayNbow> every integer ought to be divisible by a prime number, right? :p
12:11:35 <RayNbow> > map (`div` 0) [1..]
12:11:36 <lambdabot>   [* Exception: divide by zero
12:11:41 <Beelsebob> also... it can't deal with base 16...
12:11:45 <Beelsebob> http://www38.wolframalpha.com/input/?i=prime+factors+of+0x5f3d1a8b335c913dac34
12:11:53 <Beelsebob> all base 16 numbers are prime acording to it
12:12:04 * RayNbow wonders if there exists an integer that is div by 0 :p
12:12:52 <Twey> > 0 / 0
12:12:53 <lambdabot>   NaN
12:13:06 <Twey> It is if you count NaN as a result :-P
12:13:12 <ray> yes, all integers are divisible by zero
12:13:19 <Twey> > NaN
12:13:20 <lambdabot>   Not in scope: data constructor `NaN'
12:13:23 <Twey> This bothers me
12:13:41 <Twey> NaN and the Infinities should be directly instantiable
12:13:47 <ray> yes they should
12:13:53 <ray> wait, no they shouldn't, we shouldn't have floats
12:13:54 <BONUS> @seen conal
12:13:55 <lambdabot> conal is in #haskell, #ghc, #haskell-in-depth, #haskell-iphone and #haskell-blah. I last heard conal speak 37m 45s ago.
12:13:57 <RayNbow> http://www38.wolframalpha.com/input/?i=the+smallest+possible+integer+not+definable+by+a+given+number+of+words <-- it cannot solve the Berry paradox...
12:13:59 <Deewiant> Or at least provided in the Prelude in some way other than "x / 0" :-P
12:14:04 <ray> but given that we do, yes they should
12:14:14 <RayNbow> > 0/0 == 0/0
12:14:15 <maltem> > 3 `mod` 0 -- I think this came up on -cafe lately
12:14:16 <lambdabot>   False
12:14:17 <lambdabot>   * Exception: divide by zero
12:17:02 <soupdragon> @let nan = 0/0
12:17:03 <lambdabot>  Defined.
12:17:09 <soupdragon> :(
12:17:16 <soupdragon> that's not really good enough
12:17:21 <conal> BONUS: hi
12:17:26 <soupdragon> there's lots of NaNs
12:24:10 <andrewe> hi
12:24:22 <Lemmih> hey
12:24:48 <andrewe> Does someone know other uses of filterM than building a list of sublists?
12:25:41 <soupdragon> :t filterM
12:25:42 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:25:58 <soupdragon> that's the use for m = []
12:26:06 <andrewe> I know.
12:26:14 <soupdragon> I bet you do
12:26:21 <andrewe> :-P
12:26:43 * pikhq would like to see that used in the function monad
12:26:48 <andrewe> I have to admit that I still am afraid of advanced monad usage.
12:27:11 <Saizan_> it's not uncommon in IO
12:27:23 <soupdragon> > filterM (==) "foobar" 'o'
12:27:24 <lambdabot>   "oo"
12:27:24 <ray> there's no such thing as advanced monad usage
12:27:27 <soupdragon> > filterM (/=) "foobar" 'o'
12:27:28 <Saizan_> e.g. if you've a [FilePath] and want to filter only the lists
12:27:28 <lambdabot>   "fbar"
12:27:30 <ray> monads are too easy for that
12:27:34 <ray> don't be scared
12:27:47 <Saizan_> *only the directiories
12:27:49 <Badger> @src filterM
12:27:49 <lambdabot> Source not found. Take a stress pill and think things over.
12:27:55 <Badger> curses
12:28:07 <ray> @unpl filterM
12:28:07 <lambdabot> filterM
12:28:09 <pikhq> soupdragon: Sure, obvious.
12:28:41 <andrewe> thanks, ray
12:28:42 <Peaker> > filterM (const id) [const 1, const 2, const 3] True
12:28:42 <pikhq> "f" is pointless "f" for all named functions f.
12:28:43 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
12:28:43 <lambdabot>    arising from a use of `...
12:28:44 <pikhq> ;)
12:29:01 <Peaker> @type filterM (const id) [const 1, const 2, const 3]
12:29:02 <lambdabot> forall t b. (Num t) => Bool -> [b -> t]
12:29:03 <pikhq> Erm. That was odd.
12:29:05 <andrewe> still have to wrap my mind around soupdragon's example
12:29:21 <ray> pikhq: that was unpl
12:29:22 <Peaker> > filterM (const id) [1, 2, 3] True
12:29:23 <lambdabot>   [1,2,3]
12:29:28 <Peaker> > filterM (const id) [1, 2, 3] False
12:29:30 <lambdabot>   []
12:29:30 <pikhq> ray: Yeah... XD
12:29:41 <ray> @unpl ap
12:29:41 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
12:29:44 <Peaker> pikhq: here, filterM on the function monad
12:29:51 <ray> it works there at least
12:30:05 <pikhq> Peaker: Sure, obvious usage is obvious. XD
12:30:08 <Peaker> pikhq: not very useful, because its basically like filter, except the predicate function is parametrized by an extra arg
12:30:12 <Peaker> pikhq: heh
12:30:39 <Peaker> pikhq: the reader monad is a non interesting one, not sequencing any effect at all
12:30:48 <pikhq> Peaker: Fun one, though.
12:31:32 <tibbe__> dons: it turns out the GHC has most of what I want in its internal libraries, we should really expose more of the low-level I/O stuff. it doesn't really scale to include everything in ghc
12:31:52 <Peaker> andrewe: in IO its more obvious why its useful
12:31:54 <fxr> oh back
12:32:59 <andrewe> Peaker: I will think about that
12:33:30 <Peaker> @. pl undo (\x -> do print x ; (=="yes") `fmap` getLine)
12:33:30 <lambdabot> (>> ("yes" ==) `fmap` getLine) . print
12:33:53 <Peaker> filterM (\x -> do print x ; (=="yes") `fmap` getLine) [1,2,3]
12:34:03 <Peaker> andrewe: see this example ?
12:34:08 <BONUS> oh hey conal
12:34:31 <tibbe__> @src ByteString
12:34:32 <lambdabot> Source not found. Just try something else.
12:34:43 <conal> BONUS: 'sup?
12:34:43 <tibbe__> @src Data.ByteString
12:34:44 <lambdabot> Source not found. It can only be attributed to human error.
12:34:49 <tibbe__> @source bytestring
12:34:49 <lambdabot> bytestring not available
12:34:53 <BONUS> just wanted to say i read about the semantic editor combinators, i never thought of (.) as a unary function, really amazing. have you ever thought of proposing result = (.) to be included in the libraries?
12:35:22 <Gracenotes> result and argument?
12:35:29 <BONUS> yeah
12:35:29 <conal> BONUS: i'd really like result as a method of the DeepArrow class.
12:35:34 <Peaker> BONUS: I urge all Haskellers to read conal's SECs post :)
12:35:37 <sm> g'day all. Is there something more portable than threadDelay for sleeping ?
12:35:44 <andrewe> Peaker: I don't understand it :-(
12:35:50 <conal> BONUS: i'm glad you got the bit about (.) as unary
12:35:53 <shepheb> Peaker: got a link?
12:35:58 <Peaker> @where SEC
12:35:58 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
12:36:03 <Peaker> shepheb: ^^
12:36:07 <sioraiocht> I have a question about the IRC bot tutorial.  I have an error from using "catch":http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7689#a7689
12:36:24 <conal> BONUS: i think the mere choie of infix notation keeps people from seeing how wonderful composable compose is.
12:36:26 <BONUS> it's really cool that while you usually think of composition as right to left, composition chains of SECs can be read left to right as going deeper into the structure, navigating it
12:36:33 <Gracenotes> and don't miss conal's post of tips and tricks for the jewish lambda calculus, "semitic editor combinators"
12:36:34 <sioraiocht> it gives me the error
12:36:42 <sioraiocht> Ambiguous type variable `b' in the constraint:
12:36:42 <sioraiocht>       `Exception b'
12:36:43 <sioraiocht>         arising from a use of `catch' at Apertibot.hs:23:19-63
12:37:00 <sioraiocht> can anyone explain why?
12:37:13 <conal> BONUS: :) !  i love that.  once i noticed this SEC thing, i wondered why it isn't taught to all functional programmers from the start.
12:37:38 <ray> gracenotes: the lamed calculus
12:37:42 <Peaker> andrewe: lets try something simpler:  prompt x = do { print $ "Do you want " ++ show x ; result <- getLine ; return (result == "yes") }
12:37:47 <Gracenotes> hehe
12:37:53 <Peaker> andrewe: do you understand this function?
12:38:06 <andrewe> Peaker: it's getting clearer now that I have run it in ghci.
12:38:10 <BONUS> one of those cool things that are so basic and yet so interesting
12:38:19 <BONUS> that most people never notice them
12:38:21 <conal> BONUS: there's an unwritten sequel to the SEC post about how it all generalizes beyond functions, and that doing so gives a really nice compositional way to "edit" types, code, GUIs, etc.
12:38:30 <Twey> conal++
12:38:34 <Twey> For SECs :)
12:38:37 <conal> aww :)
12:38:44 <Peaker> andrewe: prompt asks the user if he accepts the given x
12:38:45 <BONUS> yeah, i thought about that too
12:38:51 <Gracenotes> ray: S is לx y. x.. or should I say ש
12:38:56 <conal> generalized SECs are the basis of tangible functional programming
12:39:06 <Peaker> Gracenotes: Hebrew letters?
12:39:20 <BONUS> it's good for changing a function to operate inside any data structure
12:39:26 <andrewe> Peaker: that seems to be a valid use of filterM, thank you for the example
12:39:28 <Peaker> conal: I'm missing the generality of SECs in Lens, and the getters in SECs
12:39:31 <BONUS> i kind of see parallels with zippers there, i wonder if there's anything to that
12:39:34 <ray> gracenotes: but right to left
12:40:04 <Gracenotes> although actually that would be the ק combinator
12:40:05 <conal> Peaker: yeah.  there's some sorting out to do with these overlapping tools.
12:40:29 <Gracenotes> ray: of course
12:41:01 <andrewe> Peaker: s/valid/useful
12:41:11 <Gracenotes> god it's been a while since I've used the alphabet
12:41:33 <BONUS> conal: have you read about functional references?
12:41:39 <conal> BONUS: yeah.
12:41:42 <Peaker> conal: I wonder if Accessors that are as type-general as SECs are possible in Haskell's type system
12:41:54 <BONUS> i think they go nicely with these combinators
12:42:08 <Peaker> @type (first, fst)
12:42:08 <BONUS> they're composable in the same way
12:42:09 <lambdabot> forall (a :: * -> * -> *) b c d a1 b1. (Arrow a) => (a b c -> a (b, d) (c, d), (a1, b1) -> a1)
12:44:01 <BONUS> sometimes i just use fmap as result
12:44:11 <conal> BONUS: me too -- often.
12:44:34 <conal> BONUS: that's where the (fmap.fmap.fmap.fmap) idiom came from.
12:45:04 <Twey> conal: I'd really like SECs with failure :(
12:45:11 * Twey craves
12:45:22 <conal> desire == suffering ;)
12:45:22 <Peaker> BONUS: but functional references have less general types.  Their setter cannot change the type of the element
12:45:40 <conal> Twey: please say more about SECs with failure
12:45:50 <BONUS> Peaker: yeah, the setter and getter are not so useful, i was thinking more about the update
12:45:54 <BONUS> update function
12:46:16 <Twey> conal: I wish I could.  I've given them some thought, but I've yet to come up with anything.
12:46:36 <Peaker> BONUS: If you try adding a getter to SEC, it becomes uncomposable, unless you restrict the types, I think, but I haven't played with it much
12:46:37 <conal> Twey: how about your motivation?
12:46:49 <BONUS> if you have a functional reference t that references a field in some ADT, you can then do like (second.result.update t) (*2) (1,\x -> adt goes here)
12:51:34 <maxote> can the next version of Haskell execute a problem and divide it to 100 subproblems to run parallely in 100 processes? is there not a version of ANDORRA Prolog for Haskell?
12:51:38 <Twey> conal: I was attempting to do something similar to SECs on a long string of Data.Map lookups
12:52:49 <conal> Twey: oh.  yeah.  now i get it.
12:53:25 <conal> Twey: a nice generalization of first & second
12:53:32 <Twey> *nod*
12:53:42 <andrewe> what are SECs?
12:53:43 <jmcarthur_work> maybe with a Maybe kleisli rather than (->)?
12:53:43 <Twey> It would be pretty awesome if my poor brain could make something that worked.  :)
12:53:50 <jmcarthur_work> <<< rather than .
12:53:51 <jmcarthur_work> i dunno
12:53:56 <jmcarthur_work> just throwing out something related
12:53:58 <byorgey> jmcarthur_work: that's what came to my mind too
12:54:04 <Twey> jmcarthur_work: Except that that doesn't tell us where we failed
12:54:09 <byorgey> andrewe: "Semantic Editor Combinators"
12:54:22 <byorgey> andrewe: just google for that phrase
12:54:23 <andrewe> Thanks, Brent.
12:54:26 <jmcarthur_work> Twey, Maybe doesn't generally tell us where we failed anyway. could use Error maybe
12:54:32 <Twey> Aye
12:54:38 <Twey> I ended up using Either Error
12:54:59 <conal> (<<<) is one generalization of (.).  'result' in DeepArrow is a different generalization.  it's more like first & second and what i needed for tangible functional programming.
12:55:10 <byorgey> andrewe: have we met?  (not that my real name is a secret =)
12:55:41 <andrewe> sorry, byorgey, only on this channel
12:56:17 <byorgey> ah, ok, just curious since you said 'Brent' instead of 'byorgey' (which you are welcome to do).  perhaps we will meet someday. =)
12:56:24 <andrewe> btw, where do haskell programmers meet each other? any conferences?
12:56:51 <ray> haskell programmers give each other HUGs
12:57:04 <byorgey> at conferences, or local user groups, or Hackathons such as the one I just hosted last weekend
12:57:17 <cwraith> Haskathons?
12:57:24 <andrewe> I read something on your blog yesterday, so, that's probably the reason for using your real name
12:57:34 <byorgey> ah, I see
12:58:31 <andrewe> byorgey: where was it?
12:58:42 <byorgey> actually, I was pleasantly surprised to hear someone use my first name instead of my nick.
12:58:42 <seanmcl> For ghci experts:  When I say :set prompt "$ " say, this works fine.  Until I do a multiline command by typing :{, when the list of open modules comes back.  Any way to suppress this 'secondary prompt' too?
12:58:51 * byorgey goes to update irssi to highlight on 'Brent' as well as 'byorgey'
12:58:55 <fxr> maxote: a mapreduce implementation is already exists. take a look at holumbus-mapreduce package
12:58:58 <byorgey> andrewe: in Philadelphia, at U Penn
12:59:06 <Peaker> conal: DeepArrow does not have arr (despite being in its type), right?
12:59:42 <andrewe> Brent: does the highlighting work? ;-)
12:59:49 <conal> Peaker: kind of.  DeepArrow is designed in anticipation that its instances don't have arr.
13:00:17 <conal> Peaker: it has methods that could be trivially defined via arr if arr existed.
13:00:40 <conal> wiring arr into Arrow appears to have been a mistake
13:00:42 <Peaker> yeah
13:00:51 <Peaker> conal: maybe it could subclass Control.Category instead?
13:01:01 <byorgey> andrewe: I haven't reloaded my config yet =)
13:01:26 <conal> Peaker: it builds onto first & second
13:01:39 <conal> and &&& and ***
13:01:43 <andrewe> byorgey: i see
13:01:53 <byorgey> andrewe: ok, try it now
13:01:54 <Peaker> conal: Class aliases could help redefine all that backwards-compatibly, while factoring arr out of there, probably
13:02:36 <Peaker> conal: but maybe DeepArrow could just redefine those things on top of Category, it already defines a lot of extensions, having those 4 methods in there would make sense I think, because you need those other methods if you give up arr
13:03:07 <Peaker> conal: without arr, you suddenly need dup and fst, etc
13:03:34 <conal> Peaker: yeah.  it may be that Arrow derives more easily from DeepArrow than vice versa
13:04:16 <conal> i also wonder if arrow notation can be desugared into combinators rather than lots of uses of arr as now.
13:04:34 <conal> not that TFP needs arrow notation.
13:04:36 <Peaker> conal: Given the insanities @pl can overcome, probably :-)
13:04:45 <conal> :)
13:05:48 <andrewe> Brent: test
13:06:02 <byorgey> andrewe: it works, thanks! =)
13:06:49 <Baughn> conal: Right now, I could hug whomever invented unsafePerformIO.
13:06:56 <Baughn> I'm pretty sure I've cracked Time.
13:07:47 <Baughn> Umh. I wonder what happens if... uh oh
13:08:01 * conal imagines a crack in Time
13:08:03 * maltem watches the clock anticipating
13:08:03 <jmcarthur_work> Baughn, sounds like your code would make baby jesus cry
13:08:16 <conal> lol
13:08:28 <Baughn> jmcarthur_work: That's deliberate.
13:09:48 <p_l> jmcarthur_work: I'm strongly suspecting that some future version of Haskell standard will include unsafeRaiseBaughn
13:10:20 <fxr> I'm feelin' high level of energy
13:11:05 <Baughn> conal: Oh, but I wanted to ask. Having (a::Time) < (b::Time) return an answer when the first of a or b occurs works because of the (in this case simple) relation between their value and the point at which they get defined.
13:11:33 <jmcarthur_work> Baughn, have you a public repo?
13:11:38 <Baughn> conal: How well does reactive support changing that relation, eg. altering the time? How well should it?
13:11:51 <Baughn> jmcarthur_work: I will, once I've got this working. I'm at my fifth possible implementation now.
13:11:53 <andrewe> byorgey: see you, good bye
13:11:59 <jmcarthur_work> Baughn, i hear ya
13:12:05 <Baughn> jmcarthur_work: THis one is the simplest yet, which is a good sign
13:12:11 <jmcarthur_work> Baughn, do let me know when you have something up
13:12:29 <byorgey> andrewe: bye
13:12:33 <jmcarthur_work> Baughn, is this an implementation of Reactive, or is it new semantics?
13:12:53 <Peaker> Baughn: dude, open up a github repo in like 2 minutes and put stuff there, people can experiment with you :)
13:13:00 <conal> Baughn: i expect a < b to unblock when either becomes *known*.
13:13:07 <conal> Baughn: which might not correspond to either time
13:13:14 <Baughn> jmcarthur_work: I haven't decided yet. There are apparently issues with the Reactive semantics, but I've been too busy trying to make the low-level Time code work to really figure those out.
13:13:33 <Baughn> conal: That may not always be possible
13:13:58 <Baughn> conal: Consider the case when a = 10, and is learned at 10, but b = 8 and is learned at 11
13:14:19 <jmcarthur_work> Baughn, oh you are making a distinction between occurrence and observation?
13:14:26 <conal> Baughn: oh yeah.  you're right.  i didn't say what i meant.
13:14:42 <Baughn> jmcarthur_work: I am, in order to be able to handle things like combining event times with the Sum monoid
13:14:50 <jmcarthur_work> ah!
13:14:57 <Baughn> jmcarthur_work: ..well, supporting affine-space transformations is easy
13:15:11 <Baughn> I'm just wondering how much it'd be worth to support /arbitrary/ ones, eg. anything but + and -
13:16:01 <djahandarie> Man, I'm at work right now, and literally the whole UConn internet goes down and I'm the one that ends up fixing it... CAS, kerberos, DNS, LDAP, and all the services relying on them, which is literally every service that requires authentication or DNS lookups. :P
13:16:16 <p_l> Baughn: I'm getting scared of FRP, you know? Cells sound like easy-peasy nothing-to-debug compared to this :-O
13:16:17 <djahandarie> And I'm the $15/hr student worker
13:16:36 <Baughn> p_l: I'm pretty sure it's a CR15 at least
13:17:02 <Baughn> p_l: ..hell, even epic-level haskell hackers such as conal have trouble with it
13:17:04 <p_l> CR15...hmm... in which nomenclature
13:17:10 <Baughn> D&D
13:17:38 <erikc> haha
13:18:59 <p_l> Baughn: can I give it 40 Knuths? ;P
13:19:45 <conal> oh pretty -- my new emacs italicizes the body of \emph{...} in latex mode.
13:20:13 <fxr> conal: wanna try auctex?
13:20:35 <p_l> Baughn: cause it sounds like it's a project that is dangerously close to 50 on Knuth's scale of exercise difficulty
13:20:36 <conal> fxr: what's it like?
13:20:56 <Baughn> p_l: Hm. I don't quite remember the rating scheme, but..
13:20:59 <monochrom> conal: actually I have seen it for quite a few years
13:21:00 <pikhq> 50? Heartattack.
13:21:01 * Baughn checks
13:21:17 <Baughn> Umh
13:21:19 <p_l> Baughn: 50 = PhD at good university for doing this one
13:21:23 <Baughn> p_l: No. It's a 50.
13:21:25 <fxr> conal: it's like http://www.gnu.org/software/auctex/
13:21:32 <p_l> haha
13:21:37 <monochrom> IIRC Fermat's Last Theorem was level 50.
13:21:46 <Baughn> 50 has quite a bit of range, though
13:21:50 <conal> fxr: thx.  i just switched to a mac, and i'm using Carbon Emacs
13:21:52 <Baughn> It just needs to be "unsolved, but many have tried"
13:22:04 <Baughn> I wouldn't rate my approach as a perfect solution, though
13:22:06 <monochrom> But Fermat's Last Theorem is solved.
13:22:10 <byorgey> by definition it's sort of hard to know in advance how hard a 50 will be.
13:22:18 <pikhq> monochrom: Wasn't at time of publication.
13:22:25 <benmachine> monochrom: it got downgraded to 45
13:22:26 <monochrom> I think 50 is pretty easy.
13:22:27 <benmachine> I think
13:22:29 <ray> unsolved, and the corpses of those who tried litter the ground around the problem
13:22:42 <Baughn> p_l: Well, overall.. I'd say 42-45 or so.
13:22:47 <conal> woot!  lhs2tex and beamer class work together
13:22:56 <ray> @seen edwardk
13:22:56 <lambdabot> I saw edwardk leaving #haskell-hacphi 1d 21h 54m 24s ago, and .
13:22:59 <monochrom> That's neat. <3 beamer.
13:23:04 <Baughn> p_l: Mainly because it's probably that most students /wouldn't/ find a solution, whereas at 40 most should
13:23:20 <monochrom> Heh 40 = can google? :)
13:23:29 <Baughn> Hardly. :P
13:23:40 <Baughn> 40 is "quite difficult or lengthy", but in any case a term project
13:24:00 <Baughn> FRP? Well, how long has the community been chewing on that now?
13:24:09 <p_l> 40 is enough to land on your CV and in some journal ;-)
13:24:11 <monochrom> Rating problem difficult is level 50.
13:24:18 <monochrom> s/difficult/difficulty/
13:24:25 * Baughn grins
13:24:47 <shepheb> also, the more popular the book becomes, the easier the exercises become by virtue of Google.
13:24:55 <jeffwheeler> GHC 6.6 is still used on c.h.o?
13:25:33 <jeffwheeler> And is there any difference between code.haskell.org and community.haskell.org? They seem to be the exact same machine.
13:26:14 <p_l> shepheb: Knuth's scale is based on amount of work necessary to finish it. Low-level stuff can be googled. Hi-level is the type where you spend months getting the answer :D
13:26:57 * Baughn has indeed been chewing on this one problem since march
13:27:06 <tommd> jeffwheeler:
13:27:06 <tommd> [tommd@Mavlo openembedded]$ host code.haskell.org
13:27:06 <tommd> code.haskell.org is an alias for community.haskell.org.
13:27:06 <tommd> community.haskell.org has address 72.249.126.23
13:27:31 <jeffwheeler> tommd: ha, I guess that solves that
13:27:37 <jeffwheeler> tommd: thanks
13:27:40 <tommd> yep
13:27:43 <Baughn> ..darn it.
13:27:54 <Baughn> Oh well, nothing appropriate use of block inside unsafePerformIO can't cute.
13:28:00 <Baughn> er..
13:28:22 * Baughn is speared by a tentacle. Drat.
13:29:49 <Beelsebob> tentacoo wape \o/
13:29:52 <Beelsebob> >.>
13:30:21 <Baughn> ..it might be fine.
13:30:31 <Baughn> Yes. Yes indeed.
13:30:39 <shepheb> the set of Google keywords returning #haskell logs just got far less classy
13:30:41 <jmcarthur_work> it builds, it must work
13:30:42 * glguy suspects that Beelsebob needs to lock his terminal when he is away so his little brother doesn't play with his session
13:30:42 * Baughn laughs maniacally, then prepares sushi
13:30:45 <byorgey> code.haskell.org isn't really intended for compiling haskell code.
13:31:15 <conal> Beelsebob: take your meds!
13:31:26 <Beelsebob> lol
13:31:33 <conal> Beelsebob: or fewer of them ;)
13:31:39 <Beelsebob> that was worth it just to see everyone's reactions
13:31:45 <Beelsebob> >.>
13:38:35 <fxr> a lot of ppl downloaded haskell platform for windows. Am I alone (using linux and opensolaris) or is this an illusion held by robots?
13:38:51 <cjb> if you're using linux, you don't need to download a platform binary
13:38:54 <cjb> you type "apt-get install ghc"
13:39:12 <ray> if you're using a system where you would type that, you are better off downloading the platform
13:39:16 <cjb> and some other stuff.  the practise of downloading an entire platform is thought of as icky and bloaty under Linux, for the most part.
13:39:26 <fxr> cjb: oh that gives me no more than ghc-6.8
13:39:40 <cjb> ouch :)
13:39:41 <erikc> i use haskell platform on linux
13:39:46 <erikc> and osx and windows
13:40:08 <fxr> I'm downloading latest release and install it manually on my debian
13:40:09 <cjb> but you get the idea.  I assert that more people using haskell on Linux are using distro packages than the platform binaries, so the figures are skewed.
13:40:19 <cjb> in contract, on Windows they don't have a distro package to get.
13:40:33 <fxr> yeah
13:41:04 <fxr> but we need to install cabal-install manually, su the haskell-platform can be a better choice
13:41:19 <fxr> (this installation includes cabal-install deps)
13:41:26 <Ke> manual installation makes baby panda cry
13:41:51 <Ke> (unless you package it properly before installing)
13:42:18 <periodic> Yup, I just replaced the ghc package with manual builds for two linux boxes.
13:42:25 <resistor> hello folks
13:42:32 <periodic> Debian is rather slow at getting updated packages in upstream, it seems.
13:43:11 <dino-> Does the platform install API docs, or can be instructed to do so? I've been using Arch lately and so installing a lot from the AUR, where I have to hack the PKGBUILD manually to get docs built/installed. But cabal-install is nice in that it has switches and conf to make it so.
13:43:22 <monochrom> I think most linux users are just too lazy to build haskell platform from source. They just wait for a binary dist. I'm one of them at least. :)
13:43:38 <ray> understandable
13:43:46 <periodic> just goes to show you how far linux has come.
13:44:06 * p_l clubs baby pandas with GHC
13:44:07 <resistor> can i ask a beginner-ish question?
13:44:16 <dibblego> resistor, go for it
13:44:19 <hackagebot> hsparql 0.1.1 - A SPARQL query generator and DSL, and a client to query a SPARQL server. (JeffWheeler)
13:44:47 <resistor> so, i have a function with the type signature myfunc :: [Foo] -> [Foo]
13:44:59 <resistor> and i want to compose it with itself to a fixed point
13:45:19 <resistor> i.e. until the returned value stops changing
13:45:43 <periodic> oooh... there's a combinator for this, I'm sure.
13:45:46 <Peaker> resistor: you could do it infinitely, with fix
13:45:53 <dibblego> @type iterate -- ?
13:45:54 <Peaker> resistor: rather than "until it stops changing"
13:45:55 <lambdabot> forall a. (a -> a) -> a -> [a]
13:46:04 <Peaker> @type fix
13:46:05 <lambdabot> forall a. (a -> a) -> a
13:46:07 <resistor> Peaker: i saw that, but i couldn't figure out how to use fix for it
13:46:12 <Peaker> fix myfunc
13:46:28 <resistor> Peaker: well, i need to get the final value out
13:46:38 <cwraith> fix only works in some special cases
13:46:44 <resistor> so having the infinite composition isn't especially useful
13:46:51 <resistor> iterate looks more like what i'm looking for
13:47:04 <fxr> resistor: do you mind call/cc?
13:47:17 <resistor> fxr: i don't know what those are
13:47:23 <Peaker> resistor: fix lets you get the final value out because of laziness - as long as your function can "refine" a bottom (add some define-ness to an undefined value)
13:47:31 <jeffwheeler> The first link in Downloadable documentation is broken on GHC's site: http://www.haskell.org/ghc/documentation.html
13:47:52 <fxr> resistor: a non local exit using call/cc gives your return value back to you.
13:48:24 <resistor> Peaker: i don't follow
13:48:42 <soupdragon> you can use an infinite composition to 'fix' a recursion
13:49:00 <resistor> right, i'm familiar with fix in an abstract sense from lambda calculus
13:49:00 <Peaker> resistor: lets look at (1:)
13:49:06 <resistor> i'm not clear at how to use it here :-)
13:49:31 <Peaker> resistor: (1:) is a function, that even when given an undefined value, returns a semi-defined-value, a data-constructor with a head which is defined, and a tail which is as defined as given
13:49:54 <bd_> 1:undefined is perfectly well-defined :)
13:49:57 <Peaker> resistor: so if you give _|_ to (1:) you get non-_|_, in that sense, (1:) "refined" its input from bottom to non-bottom
13:50:16 <resistor> ok
13:50:22 <Peaker> resistor: functions that "refine" their inputs can be used with fix
13:50:41 <Peaker> resistor: Basically functions that build some kind of partial output, regardless of their input, such as (1:)
13:50:48 <Peaker> > fix (1:)
13:50:48 <periodic> @type (_|_)
13:50:50 <lambdabot> parse error on input `|'
13:50:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:50:53 <resistor> i don't think that's applicable in my case
13:51:03 <Peaker> periodic: _|_ is just "bottom", the least-defined value of any type
13:51:13 <Peaker> resistor: what does your function [Foo]->[Foo] do?
13:51:20 <Beelsebob> fxr: I'm using OpenSolaris too
13:51:25 <Beelsebob> (and OS X)
13:51:32 <resistor> i can elaborate a little more.  i'm trying to write a (simple) minimax implementation for a checkers like game
13:51:32 <periodic> Peaker: Okay, I think I understand that.  I've been seeing it pop up a few places.
13:51:41 <resistor> Foo is a gamestate
13:51:45 <fxr> Beelsebob: glad to hear that
13:51:49 <resistor> myfunc is generateJumps
13:52:01 <Peaker> resistor: why is it [Foo] -> [Foo] and not Foo -> [Foo] ?
13:52:01 <ray> > let fac = fix (\f n -> if n == 0 then 1 else n * f (n-1)) in fac 5
13:52:02 <Beelsebob> fxr: getting ghc going on it is not the easiest task in the world, is it
13:52:03 <Beelsebob> >.>
13:52:03 <lambdabot>   120
13:52:07 <resistor> so, given a set of possible game states, generate all possible game states that are a single jump away
13:52:13 <resistor> because it needs to iterate!
13:52:21 <resistor> because you can do double jumps
13:52:25 <periodic> Beelsebob: I'd be tempted to use Opensolaris.  I've been avoiding it due to having to set up my desktop again and not being sure how well GHC and XMonad would be to set up.
13:52:35 <fxr> Beelsebob: it's so easy, I installed a previous version and compiled new one with it.
13:52:46 <Peaker> resistor: can't you chain these up with concatMap?
13:53:17 <resistor> Peaker: it starts with a single-element list (the current game state), and yields the list of all game states that are a single jump away.  then it iterates on that, to yield all game states that are one or two jumps away, etc.
13:53:19 <Ke> periodic: and Oracle will kill it soon and fold all the code into linux!
13:53:40 <resistor> or, at least, that's the desired end function
13:53:57 * jeffwheeler wonders what will happen to ZFS, if Oracle does that :P
13:53:59 <fxr> Ke: are you paranoid?
13:54:11 <Peaker> > let f x = [x+1, x+2] ; in concatMap f . concatMap f $ [1,2]
13:54:11 <periodic> Ke: That would be nice, but it will take quite a while for some things to get stable in Linux.
13:54:12 <lambdabot>   [3,4,4,5,4,5,5,6]
13:54:13 <Ke> fxr: nope, optimistic
13:54:30 <Peaker> resistor: in this case, f :: a -> [a]  and I use it to iterate one jump or two jumps away from my initial list of [1,2]
13:54:32 <fxr> Ke: that make sense
13:54:34 <kynky> sell it to apple and push ocfs ?
13:55:17 <Peaker> resistor: so you can have:   possibleMoves :: GameState -> [GameState]   which is definitely applicable to [GameState] via map.  The result is [[GameState]] of course, but you can concat on that, which is concat . map f which is concatMap f
13:55:36 <resistor> right.  i have the function that, given a list of states <= n jumps out, generates the list at <= n+1 jumps out
13:56:00 <periodic> Ke: I'd love to have linux adopt SMF, but I doubt that will ever happen.  Linux will just grab ZFS and DTrace and be on its way.
13:56:12 <fxr> whenever I see a concatMap, I search for a functor instance
13:56:14 <resistor> Peaker: i just want to iterate that function until it converges to a fixed value
13:56:21 <kynky> linux will have btrfs
13:56:44 <Peaker> resistor: So lets solve this separately
13:56:45 <jmcarthur_work> be nice to see Hammer on linux some day, too
13:57:01 <periodic> kynky: That's still far from production ready.  Still looks like at least two years before I'd use it on real data.
13:57:01 <resistor> Peaker: i already have the function you described about
13:57:04 <conal> jmcarthur_work: Hammer?
13:57:12 <Peaker> resistor: you could   iterate f someInput    to get an infinite list of applications, but you want to stop when you encounter the same thing twice, right?
13:57:13 <resistor> the problem is that i don't just want the states that are one jump out, or two jumps out
13:57:15 <fxr> jmcarthur_work: that's so far due to the dragonbsd kernel
13:57:22 <jmcarthur_work> conal, Dragonfly BSD's default file system
13:57:27 <resistor> but the list of all states that are acceptable by any finite number of jumps from the current state
13:57:34 <resistor> right :-)
13:57:37 <Peaker> resistor: I think maybe you have a function that does  concatMap simplerFunction  rather than having simplerFunction, but that's for later
13:57:41 <Phyx-> hi, Can anyone help me out on how to implement the poke method of the storage class?
13:57:43 <resistor> *accessible
13:57:46 <jmcarthur_work> conal, it's kind of ZFS-like
13:57:50 <Phyx-> I don't know how to modify the ptr with the new value
13:57:51 <kynky> periodic, but how long wil zfs take to get in kernel (not fuse) if oracle was bing nice
13:57:55 <Peaker> resistor: so how do truncate a list when an element repeats?
13:58:10 <resistor> Peaker: i don't know :-)
13:58:15 <periodic> kynky: Probably the same.  Hence why i'm using Solaris now.
13:58:38 <periodic> kynky: Then I can migrate to Linux at my leisure once it supports ZFS.
13:59:16 <fxr> periodic: migrate to linux?
13:59:26 <Peaker> > let truncateWhenDuplicate (x:y:xs) = if x == y then [x] else x:truncateWhenDuplicate (y:xs) ; truncateWhenDuplicate xs = xs   in   truncateWhenDuplicate [1,2,3,4,3,2,1,1,2,3,4]
13:59:27 <periodic> kynky: Plus, if ZFS gets opened up to the Linux community I wouldn't be surprised if development of Btrfs slows down.
13:59:27 <lambdabot>   [1,2,3,4,3,2,1]
13:59:31 <fxr> periodic: what is the problem with osol?
13:59:37 <Peaker> resistor: that's the naive/straightforward recursion
13:59:45 <periodic> fxr: (I probably wouldn't.  Don't tell him.  I like OSol for servers)
13:59:52 <kynky> well have opensolaris as file server, db server etc, can always use linux + opensolaris, or just go all out opensolaris (solaris kernel + gnu user land)
14:00:07 <fxr> periodic: what is the problem with it's desktop?
14:00:31 <periodic> fxr: Ease of setup.
14:00:37 <kynky> zfs ries tobe many tings, but its power is simplicity, youcan do a lot with lvm (evms) + dm raid
14:00:42 <Peaker> > let truncDup = concat . takeWhile (null . tail) . group in  truncDup [1,2,3,4,3,2,1,1,2,3]
14:00:43 <lambdabot>   [1,2,3,4,3,2]
14:00:56 <Peaker> resistor: oops, this doesn't keep our element
14:01:01 <periodic> fxr: I can't move my users who are used to using synaptic to get everything to OSol where half their programs will need to be compiled.
14:01:21 <fxr> periodic: yeah that's a big problem
14:01:35 <periodic> kynky: The last time I tried LVM it lacked a lot of the nexted-filesystem control that I wanted.
14:02:01 <fxr> periodic: but they sure can use VirtualBox in a couple of months
14:02:19 <periodic> fxr: VirtualBox to run Linux on top of OSol?
14:02:45 <fxr> periodic: that is called migration :)
14:03:13 <periodic> I'm actually trying to figure out a good virtualization software that will run on OSol so I can consolidate some servers closer to our storage.  But that's not really a #haskell question.
14:03:23 <Peaker> @let truncBy f (x:y:xs) = if f x y then [x] else x:truncBy (y:xs) ; truncBy xs = xs
14:03:24 <lambdabot>   arity mismatch for 'truncBy'
14:03:33 <Peaker> @let truncBy f (x:y:xs) = if f x y then [x] else x:truncBy f (y:xs)
14:03:34 <lambdabot>  Defined.
14:03:35 <kynky> well sun made opensolaris and virtualbox ....
14:03:39 <Peaker> resistor: see this function?
14:03:52 <fxr> periodic: sure, take a look at comsat implementation in opensolaris kernel...it'll give you some ideas.
14:03:58 <resistor> Peaker: my current solution is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3103#a3104
14:04:05 <Beelsebob> periodic: zfs is already open to the linux comunity
14:04:12 <periodic> As far as I can tell from Sun, it should all be done with zones, but I'm warry.
14:04:18 <kynky> if in linux and cpu supported, then kvm, but that isnt the situation, i use virtualbox in linux as my cpu doesnt support kvm
14:04:25 <Beelsebob> they're just too damned stuck up to take it
14:04:31 <kynky> zfs in fuse isnt n option
14:04:37 <resistor> Peaker: i was hoping there was a nicer way
14:04:47 <kynky> to Beelsebob
14:04:50 <Beelsebob> kynky: I was more referring to the fact that it's available under an open source license
14:04:55 <periodic> Beelsebob: ZFS in fuse doesn't have full performance and it still has the chance of losing data with RaidZ.
14:04:58 <Trinithis> What is [::] ? It shows up under Control.Monad.Instances in hoogle
14:05:01 <Peaker> conal: Do you have a blog entry or such about why you prefer modeling continuous values as such, and not as the discrete sequences often used in implementations?
14:05:06 <kynky> its gpl2 compatible ?
14:05:09 <periodic> Beelsebob: but it's a license that isn't compatible with the linux kernel.  They can't put it in the kernel if they want to.
14:05:10 <Beelsebob> kynky: who cares
14:05:18 <Beelsebob> kynky: the GPL isn't the be all and end all of licenses
14:05:31 <Beelsebob> periodic: sure they can -- they just can't distribute the two together
14:05:36 <kynky> Beelsebob, never said it was, but a license is a license
14:05:47 <conal> Peaker: no, not specifically.  i touch on reasons in a few places
14:05:56 <Ke> periodic: note that btrfs is developed by oracle
14:06:15 <Beelsebob> Ke: which may have interesting effects now that sun is oracle
14:06:18 <kynky> ext3 -> ext4 -> btrfs
14:06:22 <Ke> yes
14:06:26 <Beelsebob> also... why did they name btrfs butter face?
14:06:38 <Ke> xfs->xfs->...
14:06:43 <kynky> perogatives
14:07:08 <kynky> xfs is really good, but i would pair xfs with ups
14:07:22 <Peaker> resistor: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3103#a3105
14:07:25 <Beelsebob> zfs is nice for exactly that reason
14:07:26 <conal> Peaker: the same reasons for both time & space
14:07:28 <dmwit> Beelsebob: That was a joke, right?
14:07:29 <Beelsebob> always consistant on disk state
14:07:34 <periodic> Beelsebob: Actually, if you wrote the ZFS code for the Linux kernel I don't think you could distribute it at all.
14:07:44 <Beelsebob> dmwit: yes, but honestly, why did they make it so easy to make jokes about
14:07:48 <dmwit> okay then... hehehe =)
14:08:00 <Beelsebob> periodic: sure you could -- you would just have to distribute a patch seperately from the kernel tree
14:08:11 <Beelsebob> periodic: this is something I learned while figuring out why I hate the GPL
14:08:17 <Peaker> conal: I'm trying to convince yairchu a continuous Behavior is worth modeling in FRP, rather than just Reactives (which he currently uses in place of both Events and Reactives and Behaviors)
14:08:23 <dmwit> Trinithis: Sounds like a bug.
14:08:26 <Beelsebob> (stupid super restrictive license)
14:08:29 <Trinithis> ok
14:08:39 <periodic> Beelsebob: The way I heard it explained, it went deeper than that.  But I hate trying to understand licenses...
14:08:41 <kynky> ms view point, although they have recently backtracked on that too
14:08:42 <dmwit> Trinithis: how do you make it show up?
14:08:56 <Trinithis> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Instances.html
14:09:02 <Trinithis> scroll to the Instances section
14:09:06 <kynky> bsd3 is friendlier
14:09:06 <periodic> It will be interesting to see how ZFS and Btrfs end up working out now that they are basically the same thing being developed by the same company.
14:09:09 <Beelsebob> periodic: the condition that stops it being GPL compatible is that sun don't want anyone to fork zfs -- the want patches contributed back to them...
14:09:23 <Trinithis> right under Functor IO
14:09:26 <Beelsebob> so... what you do is you create a linux patch
14:09:28 <Beelsebob> you contribute it back to sun
14:09:30 <Beelsebob> and you distribute the patch
14:09:37 <Beelsebob> that doesn't involve distributing any gpl code
14:09:44 <Beelsebob> so you aren't in violation of the GPL
14:09:50 <periodic> Beelsebob: I thought it was that if you wrote it to work with the Linux kernel the GPL would require you release ZFS under the GPL, which the CDDL prohibits.
14:09:57 <yairchu> Peaker: I'm not saying Behaviors aren't worth modeling. but I consider Events the "kernel" and Behaviors as a nice addition
14:10:07 <Beelsebob> periodic: no -- that's only if you distribute it with the GPL stuff
14:10:12 <conal> Peaker: convincing might be hard.  if yairchu can drop his (?) computer-habituated preconceptions, i think he'd come to the same conclusion as i.
14:10:19 <Beelsebob> if you distribute it with none of linux attached, you're in the clear
14:10:22 <dmwit> Trinithis: That is a weird one.  Maybe file a bug with the haddock folks?
14:10:26 <Beelsebob> (i.e. distribute it as a patch)
14:10:35 <periodic> Beeslebob: I see.
14:10:39 <Trinithis> not sure how
14:10:58 <conal> Peaker: it'll help if yairchu is used to thinking about composability.  also if he can relate time & space.
14:11:12 <periodic> periodic: I'd google for an in-depth explanation, but right now my system is so bogged down with IO (recovering a disk) that Firefox is barely responding.
14:11:29 <Peaker> conal: sure he can. I think he's currently using an implementation-driven approach, though
14:11:45 <Peaker> conal: Basically trying to write whatever parts necessary to implement a game
14:12:02 <kynky> Beelsebob, thats the trick they used for zfs-fuse, but wont work as soon as you compile it
14:12:22 <yairchu> Peaker: because I can't trust myself to know that my ideas are complete without putting them to the test
14:12:26 <Peaker> conal: rather than a top-down semantic design, which turns out much more difficult to implement
14:12:29 <conal> Peaker: he'll have to step back and look at the big picture. if he doesn't want to do that, then drop it.
14:12:33 <dmwit> Trinithis: err...
14:12:40 <kynky> actually, that doesnt matter, it would rely on gpl2 linux kernel code
14:12:43 <dmwit> Trinithis: This is their advertised Trac: http://trac.haskell.org/haddock/
14:12:55 <dmwit> Trinithis: But given their intro text, I don't think they take it very seriously. =P
14:13:02 <Peaker> yairchu: the interface is easy to show the completion of -- just show you can implement your Events on top of conal's and vice versa
14:13:03 <Trinithis> haha
14:13:25 <yairchu> Peaker: but who's to say my Events are good enough? :)
14:13:36 <Beelsebob> kynky: nope, as I said, you have to distribute a patch
14:13:51 <Beelsebob> kynky: shame the GPL is so horribly restrictive :(
14:13:56 <Peaker> yairchu: well, you could try to write the game in Reactive without seeing it run :-)
14:14:19 <Peaker> conal: ok, thanks for the tips
14:14:28 <kynky> Beelsebob, on purpose, look what apple did to bsd :) they made promises too, then they broke them
14:14:30 <conal> Beelsebob: the GPL isn't restrictive.  no license is restrictive.
14:14:52 <conal> Beelsebob: since licenses only *grant* rights.
14:14:56 <kynky> look what happened when wine was bsd, they moved to gpl after a famous incident
14:14:57 <Beelsebob> kynky: which promise did they break? -- also the BSD explicitly says you can take it and run with it (which apple didn't do)
14:15:02 <Beelsebob> conal: that's a nice way to look at it
14:15:06 <yairchu> Peaker: I can't do stuff without seeing them run. It took me many attempts to implement polygon triangulation right and as my font editor shows I still sometime get it wrong
14:15:08 <Phyx-> Berengal: are you around sir?
14:15:13 <kynky> opendarwin project
14:15:14 <Beelsebob> kynky: what did happen when wine was bsd?
14:15:14 <conal> Beelsebob: a recent realization for me.
14:15:26 <Beelsebob> kynky: what about opendarwin?
14:15:31 <conal> and it's one reason i don't like the "license" cabal field.
14:15:41 <Peaker> yairchu: I see.  Did you look at FieldTrip btw? Maybe it does what you're doing?
14:15:42 <conal> it imposes non-composability.
14:15:45 <jmcarthur_work> conal, but you could still say that the gpl is not as permissive as <some more permissive license>, of course
14:15:54 <conal> jmcarthur_work: exactly!
14:16:02 <Peaker> conal: in what way?
14:16:08 <kynky> when  wine was bsd it got forked by someone who old the product for profit
14:16:15 <yairchu> Peaker: I looked at the tut but maybe I should take a better look at it and what it does :)
14:16:17 <conal> i want people to think of licenses as composable, not monolithic.
14:16:22 <kynky> old=sold
14:16:26 <Beelsebob> kynky: why is this a bad thing?
14:16:32 <Beelsebob> the BSD license explicitly says you can do this
14:16:34 <Peaker> conal: in what way does the field impose non-composability, that is?
14:16:37 <Beelsebob> that's what being open is about
14:16:46 <jmcarthur_work> i at one point thought it would be neat to have a "legalese calculus" of some sort
14:16:51 <jmcarthur_work> then i decided that would be boring ;)
14:16:52 <conal> Peaker: in that (a) "license" is singular and (b) there are no license combinators.
14:16:58 <Beelsebob> conal: something I'd been thinking on was actually using darcs and some meta data to be able to anotate patches with what the author grants
14:17:06 <Phyx-> does anyone here have experience with FFI and Storage?
14:17:08 <kynky> well the ppl who did the work for free, got no money, some company made money out of it, and so they gpl'd ther future workl
14:17:09 <Beelsebob> so that you could say things like "I want all the patches available under BSD"
14:17:18 <jmcarthur_work> Beelsebob, i love that!
14:17:20 <conal> Beelsebob: neat.
14:17:30 <Peaker> Beelsebob: the BSD vs. GPL amounts to whether you think of modifications of your code as derivative works that are still a form of your code or not.  If you do, and don't want to see your code being distributed in closed/restricting form to users, then you prefer the GPL
14:17:44 <p_l> kynky: due to BSD-like licensing, wine had two different companies investing in it, pushing back stuff that wasn't directly their "market"
14:17:46 <Peaker> conal: ah, cool idea :-)
14:17:59 <Beelsebob> kynky: the odd thing about that -- if their code was that great, then anyone could grab it and compile it
14:18:06 <Beelsebob> so why would anyone buy the 3rd party product?
14:18:16 <kynky> Beelsebob, i understand that, i have nothing against bsd or gpl, but they thougt they got hard done by, and were protecting themselves
14:18:16 <Beelsebob> (unless they actually somehow added value to it)
14:18:19 <Ke> p_l: only transgaming wasn't really developing wine
14:18:35 <Ke> (or that's the rumour)
14:18:37 <Peaker> Beelsebob: the problem is, when they add value to it, they may be *subtracting* value from the original product (e.g via net effect)
14:18:37 <yairchu> Phyx-: what's the question?
14:18:37 <conal> Peaker: so "license" reinforces the misunderstanding that licenses can possibly be restrictive.
14:18:38 <Beelsebob> kynky: well yeh, that's fair enough -- I just think that they were wrong to feel hard done by
14:18:39 <dcoutts> conal: aye, I was thinking of that. eg some people dual license using GPL || BSD or GPL && BSD. Neither really make sense imho since they equal GPL or BSD.
14:18:56 <Beelsebob> Peaker: how do they subtract value from the original?
14:18:56 <p_l> Ke: there's CodeWeavers which afaik sponsors a lot of Wine development. and iirc transgaming got cut off due to changes in licensing
14:19:01 <Peaker> Beelsebob: so they're not distributing the difference/added value to users, but the whole thing, in closed form
14:19:19 <Peaker> Beelsebob: net effect brings all of the users of the original product to them -- all of the documentation writers, forums, etc
14:19:25 <Beelsebob> Peaker: yes, but the original is still available
14:19:27 <Beelsebob> so effectively they are distributing the difference only
14:19:29 <hackagebot> AERN-Real 0.10.0.1 - arbitrary precision interval arithmetic for approximating exact real numbers (MichalKonecny)
14:19:30 <Peaker> Beelsebob: but its now worthless
14:19:33 <sioraiocht> has anyone used the Network.IRC library/
14:19:42 <Peaker> Beelsebob: so everyone is pretty much forced to use a closed source thing
14:19:44 <Ke> p_l: the licence was changed, because they didn't contribute, afaik
14:19:46 <conal> dcoutts: boolean ops might not fit.  since licenses are not boolean.
14:19:48 <Beelsebob> Peaker: well fair enough to them -- if they added so much value that all the users went to them, then they did something *very* valuable
14:19:51 <kynky> lgpl in particuar is annoying in haskell, because of linking, where other languages dont have that problem, but hopefully ghc 6.12 will solve that niggle
14:19:59 <Beelsebob> if all the users suddenly found it that much better, then go for it
14:20:01 <Phyx-> yairchu: I'm trying to implement an example http://phyx.pastebin.com/d1234267d
14:20:01 <Peaker> Beelsebob: They may have added much value with very little development
14:20:05 <conal> dcoutts: or maybe there's a boolean perspective i'm missing
14:20:07 <Beelsebob> Peaker: so?
14:20:11 <sioraiocht> it seems that it hasn't been updated since last year, but I don't know if that's because it "works" or because it was abandoned
14:20:14 <dcoutts> conal: most dual licensing says "both" or "either"
14:20:17 <Beelsebob> lots of great, valuable ideas take very little development
14:20:18 <Peaker> Beelsebob: you may have been 99% there, but they added 1% marketing, and now your code is closed for everyone in practice using it
14:20:21 <jmcarthur_work> i'm still caught up on the license-per-patch idea. i think that is just an excellent idea
14:20:26 <p_l> kynky: not only with GHC... that's why there's LLGPL (aka Lisp Lesser GNU Public License)
14:20:29 <Peaker> Beelsebob: you don't have a marketing machine to compete with them
14:20:30 <Beelsebob> Peaker: except that your code is not closed
14:20:34 <conal> dcoutts: meaning what?
14:20:36 <Beelsebob> you can never close BSD'd code
14:20:45 <Peaker> Beelsebob: but the form of the code which is *in use* is closed. People who use it have no freedom
14:20:54 <jmcarthur_work> i've always thought that it would be better to be able to grant permissions on a per patch basis as opposed to a per project basis
14:20:55 <Peaker> Beelsebob: they can't switch back to the open one
14:21:00 <jmcarthur_work> would prevent things like forking and such
14:21:07 <Beelsebob> Peaker: and evidently that freedom is not worth as much as what the 3rd party added -- otherwise they would still be using the open one
14:21:09 <Peaker> Beelsebob: so everyone is stuck with a closed thing, thanks to the BSD :(
14:21:10 <conal> jmcarthur_work: nice idea
14:21:19 <Beelsebob> Peaker: and why can't they switch back to the open one?
14:21:24 <fxr> god bless we're talkin bout the differences between public licenses
14:21:28 <Beelsebob> oh wait... beacuse someone added value to it
14:21:39 <Peaker> Beelsebob: because their friends are in the "skype" network, rather than the open one it was based on
14:21:42 <yairchu> Phyx-: I don't think you should make your FFI types actually contain Haskelly values..
14:21:51 <Peaker> Beelsebob: the value is only in the amount of users, nothing else
14:21:51 <dcoutts> conal: that the author grants you license under the conjunction of the terms of the two given licenses, or under the disjunction. In the first you must comply with both licenses. With the second you get to pick which one to accept under.
14:21:53 <Saizan_> jmcarthur_work: that looks like it'd be horrible in practice if you've patches that logically depend on one another and are of different licenses
14:21:55 <p_l> Peaker: that's something different, IMHO
14:22:05 <Saizan_> jmcarthur_work: it also makes the package harder to distribute
14:22:06 <Beelsebob> Peaker: okay, so to the average user, wrapping it up in a freindly way was worth more than openness -- that's good
14:22:08 <yairchu> Phyx-: but I never made an instance of Storable myself, though
14:22:13 <Beelsebob> that means that the one that's more useful survives
14:22:15 <Ke> fxr: licences are like homepages, you have got to have your own to be credible
14:22:20 <Beelsebob> and if the open one becomes usable, then we all win :)
14:22:21 <jmcarthur_work> Saizan_, it certainly can get hairy, but i think it is at least a step in the right direction
14:22:22 <kynky> well if you own all the code, you can do what you want, i.e. mysql, if its lsubmitted by loads of users under gpl license, then harder to change license i.e. linux kernel
14:22:39 <Phyx-> yairchu: well, it works sort off, the exception gets displayed on the other side
14:22:46 <Peaker> Beelsebob: Its a tragedy of the commons -- if people gain all the advantages of the free one from the closed one, plus a few, they'll switch to the closed one (the freedom they lose is not completely lost, people will make patches to the free and they will be incorporated.) Once enough users migrate, the free one dies
14:22:47 <dcoutts> conal: eg you get the conjunction if you import BSD code into a GPL project.
14:22:53 <Phyx-> yairchu: most examples of it i've seen uses hsc2hs
14:23:02 <conal> dcoutts: might be hard to make precise.  but perhaps worth trying.
14:23:12 <dcoutts> conal: but you usually pick the disjunction if you choose to distribute under a dual license
14:23:26 <yairchu> Phyx-: at least I suppose "value" shouldn't be lazy (should add a bang there I think)
14:23:31 <fxr> Ke: nope licenses are social contracts between ppl
14:23:38 <Beelsebob> Peaker: so the free one should fight for survival harder -- all this says is that evolution is showing that openness is not a great fittness criteria on it's own -- it also actually has to be good software
14:23:50 <Peaker> Beelsebob: For example, Windows has gained a lot of popularity by incorporating BSD code. This popularity took away people from contributing to BSD, but those who migrated to Windows didn't lose the freedom directly. Eventually, BSD has little/no development behind it, and everyone is stuck with a closed Windows
14:23:53 <kynky> licenses are messy imho, when using multiple pieces of software with differing licensees  at same time
14:23:56 <Phyx-> yairchu: true
14:23:58 <conal> dcoutts: anyway, a first step could be generalizing license to licenses.  meaning take your pick.
14:24:01 <mapreduce> Does the Haskell Platform have distro-independent binaries?
14:24:13 <Phyx-> yairchu: but i'm at a loss of how to actually manipulate the Ptr value
14:24:14 <dcoutts> conal: but that's crucial, if it means conjunction of disjunction
14:24:21 <mapreduce> .tgz etc., to extract and use.
14:24:23 <jmcarthur_work> Saizan_, i might be attracted to the idea simply because it mutilates the idea of "derivative work" ;)
14:24:25 <Beelsebob> Peaker: I'd love to see your evidence that BSD became less popular because windows had BSD code in it
14:24:27 <dcoutts> conal: is a list sufficiently expressive?
14:24:36 <Phyx-> yairchu: conceptionally i understand what Storage does, but I have no idea how to change the Ptr
14:24:52 <dcoutts> conal: most the other lists in .cabal files mean "all of" not "any of"
14:25:35 <conal> dcoutts: i offer you *all* of these licenses.  you accept which ones(s) you want
14:25:50 <dcoutts> conal: so that's || in the syntax I gave earlier
14:25:56 <kynky> some developers may move to bsd to linux development,, as they may think that their work cant as easily get ripped off, but for a purist i guess that wont matter, all im say is that its a matter of opinion
14:26:03 <conal> dcoutts: i offer you *all* of these modules.  you accept which ones(s) you want.
14:26:20 <kynky> i liked public domain, but that doesnt get used
14:26:21 <conal> dcoutts: you could call it "||" or "&&".
14:26:37 <dcoutts> conal: yes, it depends if you look at is an an offer or a label
14:26:57 <dcoutts> at is/at it
14:27:07 <yairchu> Phyx-: what do you mean by change the Ptr?
14:27:08 <kynky> also if you use gpl license, and some1 rips of your project, you get help from EFF etc, if you made up your own license you dont get the big protection
14:27:10 <conal> dcoutts: hm.  what other word could you use in place of "label" there.
14:27:16 <conal> dcoutts: offers have labels too
14:27:41 <fxr> conal: tag?
14:28:05 <conal> fxr: i'm looking for a replacement to what dcoutts means here by "label"
14:28:09 <Phyx-> yairchu:  the poke method is supposed to update the provided Ptr value with the given value
14:28:11 <conal> fxr: tag is like label
14:28:11 <yairchu> Phyx-: if it's to implement poke etc you can use pokeByteOff etc
14:28:18 <Phyx-> ah ok
14:28:56 <conal> dcoutts: to clear up whether we want conjunction or disjunction or what, i think we'll have to delve *into* contracts, and find boolean connectives and atomic propositions there.
14:29:04 <yairchu> @hoogle Storable a => Ptr b -> Int -> a -> IO ()
14:29:05 <lambdabot> Foreign.Storable pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
14:29:05 <lambdabot> Foreign.Storable pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
14:29:05 <lambdabot> System.IO hPutBuf :: Handle -> Ptr a -> Int -> IO ()
14:29:06 <conal> dcoutts: in particular, i think implication will be crucial.
14:29:12 <dcoutts> conal: terms, as in terms you must accept if you want to copy the code
14:29:14 <p_l> can't we just publish everything under WTFPL?
14:29:43 <dcoutts> conal: or perhaps obligations
14:29:51 <yairchu> Phyx-: some FFI helper funcs you might wish for exist and could be found using hoogle
14:29:52 <conal> dcoutts: that's what i suspected.  you're focusing on what's requested, while i'm focusing on what's offered.
14:30:03 <conal> dcoutts: that's why your "or" is my "and"
14:30:10 <dcoutts> conal: right
14:30:15 <Phyx-> yairchu: are they all in Foreign?
14:30:19 <conal> :)
14:30:32 * conal gets back to work
14:30:57 <dcoutts> conal: so you can see why I decided it wasn't a quick and easy extension :-)
14:31:15 <yairchu> Phyx-: I guess that the answer is yes
14:31:59 <Phyx-> well, it compiled
14:32:03 <Phyx-> time to see it it works
14:35:38 <conal> dcoutts: yeah.
14:36:07 <Phyx-> yairchu: lol, i used pokeByteOff and I got an Out of memory exception
14:36:08 <Phyx-> lol
14:36:15 <conal> dcoutts: i think the offer/rights perspective will work out better than the request/obligations perspective.  here's why:
14:36:43 <yairchu> Phyx-: how did you create the object? with malloc?
14:36:44 <conal> when there are obligations, then what's offered is conditional.  as in A => B
14:37:19 <conal> two conditional contracts would be *conjoined* as in (A => B) && (C -> D).
14:37:25 <Phyx-> yairchu: ah, you can't use pokeByteOff to define poke as you said, since  pokeByteOff ptr off = poke (ptr `plusPtr` off)
14:37:27 <dcoutts> conal: the reason I was looking at it that way is because all the other info in the .cabal file is inactive, declarative info about the package, not active stuff coming from the package.
14:37:28 <conal> (A => B) && (C => D).
14:38:06 <conal> if B == D, then (A => B) && (C => D) == (A => B) && (C => B) == (A || C) => B
14:38:09 <Phyx-> pokeElemOff might be the one you meant though
14:38:20 <resistor> Peaker: i think i found a "simpler" solution
14:38:27 <resistor> @type head . head . dropWhile ((== 1) . length) . List.group . iterate f
14:38:28 <lambdabot> forall a. (Eq a, Show a, SimpleReflect.FromExpr a) => a -> a
14:38:34 <yairchu> Phyx-: all depends on what you are actually trying to do.. (I'm lacking context)
14:38:37 <conal> dcoutts: i'm not getting your active/inactive dichotomy
14:38:48 <resistor> Peaker: that should be a "fixed point" function
14:39:10 <Peaker> resistor: that's what I called findFixFrom there
14:39:13 <Peaker> resistor: in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3103#a3105
14:39:22 <dcoutts> conal: reading a .cabal file it does not read like a written offer from the author, it's a passive description
14:39:25 <conal> dcoutts: iiuc, you were considering the special case of B == D
14:39:55 <resistor> Peaker: right
14:39:57 <conal> dcoutts: i guess that distinction makes more sense in your head than in mine.
14:40:16 <resistor> i was just seeing if i could write it without implementing  truncFrom ourselves
14:40:18 <conal> dcoutts: i see a passive description of an offer
14:40:29 <dcoutts> conal: there's no "I", no active agent
14:40:31 <conal> just as *everything* in math/FP is "passive"
14:40:33 <Phyx-> yairchu: i'm trying to figure out how it all works, i just want to be able to send and read that sample datatype in C
14:40:50 <resistor> erm, truncBy
14:41:11 <conal> dcoutts: just as there needn't be an "I" in a contract
14:41:11 <dcoutts> conal: where as a copyright license reads as a condition offer of rights from an individual
14:41:34 <dcoutts> conal: but it very clearly sets out the parties
14:41:35 <conal> dcoutts: perhaps only accidentally so, not fundamentally so.
14:42:13 <benmachine> @src span
14:42:13 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:42:16 <conal> dcoutts: regardless, i think your notion of "active" vs "passive" is an artifact of your perspective.
14:42:36 <conal> dcoutts: rather than an inherent property
14:42:39 <Phyx-> yairchu: i can read simple primitive values, but now i want to be able to do the same with haskell datatypes
14:42:41 <yairchu> Phyx-: ok. so I think the way you get a Ptr to a Storable created is with malloc or from a foreign function. then you can peek and poke, etc
14:42:56 <fxr> @seen dan doel
14:42:56 <lambdabot> dan is in #friendly-coders. I don't know when dan last spoke.
14:43:05 <conal> dcoutts: so i'd want to put it aside in a design.
14:43:32 <yairchu> Phyx-: I'm not sure there is anything guaranteed about the memory layout of Haskell datatypes..
14:43:36 <mapreduce> ghc-6.10.4-i386-unknown-linux-n.tar.bz2
14:43:45 <mapreduce> Is there supposed to be a ghc binary in that?
14:43:54 <conal> dcoutts: i don't mean to invalidate your perspective.  just to point out that it's only one perspective.
14:43:56 <dcoutts> conal: we'd have to think of something that isn't ambiguous to the reader, as && and || appears to be because of this perspective issue
14:44:06 <fxr> anybody knows Dan Doel?
14:44:18 <Phyx-> yairchu: new also creates a new Ptr using a Storable, there in lies the problem, i need to define storable. lol, can't find any reference online on how to do it without the use of hsc2hs
14:44:46 <conal> dcoutts: they're fuzzy only because our model of a contract/license is fuzzy. clarifying the latter clarifies the former.
14:45:10 <dcoutts> Phyx-: that's because hsc2hs (or c2hs) are the most sensible tools, you do not want to do it by hand since it's platform-dependent
14:45:11 <fxr> Phyx-: I used storable in hlibev package. take a look, it may help.
14:45:23 <conal> dcoutts: and i've pointed out why i suspect the positive/offer model will turn out more composably than the negative/request model.
14:45:52 <conal> using "positive" & "negative" in the logical/type-theoretic sense, not a value judgment
14:46:02 <Phyx-> dcoutts: sure, but for learning purposes isn't it good to do it without?
14:46:08 <dcoutts> conal: that's fine, I just mean that we cannot then end up with syntax like && || since people who've not thought about it / not read the user guide will likely get it wrong.
14:46:08 <Phyx-> fxr: cool, i'll check it out
14:46:23 <conal> dcoutts: good point!
14:46:24 <dcoutts> Phyx-: I wouldn't think so
14:46:35 <Phyx-> lol
14:46:40 <conal> dcoutts: thx for clarifying
14:46:55 <dcoutts> Phyx-: you can look at the output of hsc2hs if you want to see what the "real" code is
14:47:03 <Phyx-> true
14:47:10 <Phyx-> I did try using hsc2hs before
14:47:15 <Phyx-> but got a gcc error
14:47:31 <Phyx-> need to install cygwin
14:47:40 <dcoutts> Phyx-: suggesting people do it by hand is just leading them into the land of segfaults
14:48:19 <Phyx-> lol
14:48:22 <conal> yairchu: sorry for talking past you earlier.  didn't realize at first that you were in the room.
14:48:35 <fxr> I wonder why Control.Monad.CC.Seq is not a monad instance...
14:48:37 <yairchu> conal: it's ok :)
14:49:48 <conal> yairchu: :)
14:49:52 <conal> yairchu: my summary: as much as you care about simple semantics & composability, you'll inevitably be attracted to continuous time & space.  as much as you want operational transparency, you'll lean toward discrete (and imperative).
14:50:32 <conal> yairchu: and i wouldn't want Peaker to try arguing you into the continuous direction.  you'll really grok the decision only if it comes from inside yourself.
14:50:59 <conal> "You can never learn anything that is not a part of yourself." - Louis Kahn
14:51:19 <yairchu> conal: I like this point :) but doesn't it mean it's unteachable?
14:51:41 <conal> yairchu: it means everything of consequence is unteachable.
14:51:52 <conal> yairchu: from the *outside*
14:52:28 <conal> yairchu: that's why i don't believe in teachers, only guides/facilitators
14:52:57 <yairchu> interesting (and probably correct) viewpoint
14:53:44 <conal> (most children are creative geniuses until they go to school.)
14:54:11 <fxr> that's true
14:54:18 <chupush> depends on the school
14:54:27 <chupush> well, the method *behind* the school
14:54:31 <conal> chupush: very much
14:55:36 <idnar> conal: what about mentors?
14:55:53 <chupush> wouldn't that fit "guides/facilitators"?
14:56:01 <conal> for me, yes.
14:56:13 <idnar> I think there's a difference, but I'm not sure I can actually articulate it
14:56:41 <chupush> well, mentor means "an experienced & trusted advisor" per Apple's dict
14:56:43 <conal> for me, "mentor" more clearly captures the role i mean than "guides/facilitators"
14:57:29 <conal> what i like in "mentor" is the focus on helping the mentee to develop themselves.  may be my own personal association with the word.  i love mentoring in that sense.
14:57:36 <chupush> hence it would seem to denote something more personal than guide/facilitator, since there is the notion of trust
14:57:47 <conal> yeah.  nice.
15:02:41 <jmcarthur_work> i'm very much a fan of the Socratic method
15:03:04 <jmcarthur_work> unlearning is way more important than learning
15:03:19 <jmcarthur_work> and you learn more ;)
15:04:05 <conal> jmcarthur_work: that's why you & i get along so well. :)
15:04:39 * copumpkin tries to disprove the socratic method socratically
15:04:43 <copumpkin> so why do you like the socratic method?
15:05:00 <jmcarthur_work> copumpkin, is this a serious go?
15:05:04 <copumpkin> no :P
15:05:11 <copumpkin> I'm just in a stupid mood
15:05:12 <jmcarthur_work> just checking :)
15:06:09 <monochrom> I am unlearning the Socratic method.
15:06:25 <chupush> mm, dialectics...
15:06:40 <Saizan_> monochrom: really?
15:06:48 <monochrom> No. Joke.
15:07:22 <chupush> That would be a bit like stopping the game...
15:08:03 * Saizan_ is not a fan of socrates
15:08:23 <chupush> Saizan_: a Nietzschean?
15:08:44 <jeffwheeler> I'm trying to learn GADTs, and so I've started rewriting a bit of code using them: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7695#a7695
15:08:57 <jeffwheeler> I'm wondering whether I'm using GADTs logically, though.
15:09:10 <timonator> nietzsche-chan?
15:09:19 <jeffwheeler> Does it make sense to use the empty data decl's above my GADT, or is there another solution?
15:09:28 <Saizan_> chupush: more like that, yeah :)
15:09:38 <chupush> The Dawn & what not
15:09:51 <chupush> "How to Philosophize with a Hammer"
15:11:04 <Saizan_> jeffwheeler: it depends on what you want to do with it
15:11:45 <soupdragon> why is it people only use GADTs for ASTs??
15:12:00 <copumpkin> soupdragon: I don't!
15:12:10 <soupdragon> jeffwheeler, (empty data decl's are fine)
15:12:21 <Saizan_> for ASTs it's quite easy to decide the types?:)
15:12:26 <soupdragon> do you use them for something else?
15:12:35 <jeffwheeler> Saizan_: I'm going to put it into a state monad, and the syntax is going to look like this: http://community.haskell.org/~jeffwheeler/hsparql/tests/DBPedia.hs
15:12:38 <monochrom> Because those who use something else for ASTs have no question to ask here.
15:13:01 <copumpkin> I used them for those composable folds for a while, but then went back to a non-GADT for them
15:13:12 <jeffwheeler> monochrom: hence my original solution, http://community.haskell.org/~jeffwheeler/hsparql/Database/HSparql/QueryGenerator.hs :)
15:13:48 <jeffwheeler> Somebody suggested that using GADTs may make the DSL more beautiful; I thought I'd learn what they are, and give it a shot
15:15:26 <Saizan_> it's not easy to digest that much code on the spot :)
15:15:51 <jeffwheeler> Saizan_: sorry about that; I just meant to say that my previous solution wasn't using GADTs :)
15:15:54 <jeffwheeler> No more
15:16:30 <Saizan_> i'm not sure about prettier, but a gadt can make it more typeful if you need that
15:16:33 <jeffwheeler> The 'simple' function in the test file demonstrates the syntax I've built, though
15:17:12 <Saizan_> i.e. what are the types of triple, var and prefix currently?
15:17:19 <jeffwheeler> Hmm, it is fairly "typeful" (hehe), but I think the main problem resided in TermLike, in my previous version. At one point, I had to include an "error"
15:18:10 <jeffwheeler> Saizan_: Pattern, Var, and Prefix
15:18:15 <jeffwheeler> err
15:18:23 <jeffwheeler> well, there are types that each results in
15:18:52 <jeffwheeler> The function 'var' itself adds a variable to the state, and then returns a Variable
15:19:10 <jeffwheeler> (It's on line 93)
15:19:28 <Saizan_> ah, so what you have now as a single GADT is a collection of different datatypes in the original code?
15:19:45 <jeffwheeler> Saizan_: yes, I think so
15:20:53 <jeffwheeler> Also, I assumed the State monad was the most logical way to build a DSL like that. Is that correct?
15:21:10 <jeffwheeler> As it progresses, each function will write variables and such to the state
15:21:30 <jeffwheeler> And then it can build a query string from the final state
15:25:08 <Saizan_> there are different approaches, e.g. Text.Html doesn't use a monad at all
15:25:50 <skorpan> i read somewhere, i think in "polish parsers" that online parsers cannot be monadic
15:25:54 <skorpan> is this true? if so, why?
15:26:03 <soupdragon> what does 'online' mean?
15:26:21 <skorpan> hm, i'm not sure if i remember it correctly, might have been incremental
15:26:26 <skorpan> or maybe they meant incremental by online
15:26:29 <Saizan_> online usually means that they return the result lazily
15:26:51 <Saizan_> i.e. they don't need to read the full input before starting to produce something
15:27:11 <Saizan_> skorpan: there's uu-parsinglib which is an online parser that's monadic
15:27:27 <conal> Saizan_: isn't it applicative?
15:27:38 <Saizan_> conal: both :)
15:27:50 <skorpan> then are you sure the monadic version is online?
15:28:01 <conal> iiuc, the uu folks realized that the monadic interface thwarted analysis.  so they used something equivalent to Applicative.
15:28:11 <jeffwheeler> Saizan_: I think I've run into the same problem I ran into the first time, now with GADTs
15:28:19 <Saizan_> yup the monadic version is online
15:28:19 <jeffwheeler> Saizan_: again, with: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7695#a7695
15:28:20 <conal> the same problem motivated the Arrow interface.
15:28:38 <conal> might be unrelated to the online issue
15:28:49 <jeffwheeler> Saizan_: Triple should accept Term Variable and Term Literal's, but, say, not Term Prefix's.
15:28:52 <Saizan_> skorpan: they use a clever implementation to make the monadic interface online too
15:29:50 <jeffwheeler> This is what motivated the VarOrTerm mess in the previous non-GADT code.
15:30:16 <Saizan_> conal: it's not completely unrelated, but they managed to overcome the problems of supporting a monadic interface for online parsing
15:30:36 <conal> cool
15:31:42 <Saizan_> jeffwheeler: well there are various approaches to that
15:32:50 <Saizan_> jeffwheeler: one might just to add another parameter to Term that will be the same for all the values that can be accepted by Triple
15:33:08 <jeffwheeler> Saizan_: oh, like the safe list examples
15:33:25 <Saizan_> jeffwheeler: yeah, similar
15:34:07 <jeffwheeler> I'll give that a shot; thanks
15:35:10 <jamesSanders> anyone know where lambdabot keeps its channel logs?
15:35:28 <Saizan_> it doesn't keep channel logs, iirc
15:36:07 <monochrom> If you want logs of this channel (as opposed to want to configure lambdabot to log things), the channel topic has a url.
15:36:39 <jamesSanders> how are logs kept for this channel?
15:39:22 <Saizan_> say hi to clog
15:39:38 <jamesSanders> clog: hi
15:39:43 <iago> hello, what do you think, parsec or attribute grammars ;P in general
15:39:55 <Saizan_> well, not literally, but that's the bot :)
15:40:10 <mike-burns> jamesSanders: http://tunes.org/~nef/logs/haskell/
15:41:24 <jamesSanders> what kind of bot is it?
15:41:38 <copumpkin> sounds like it'll clog the channel
15:41:44 <copumpkin> do we want a clogged channel?
15:42:12 <jeffwheeler> Saizan_: that seemed to help a bunch; thanks a ton
15:42:41 <jamesSanders> or maybe I should say is the source code available for clog somewhere ?
15:42:59 <Berengal> I was doing some javascript at work today (of which I do very little in general), when I suddenly noticed the warning netbeans was giving me for the current function: "This function is free of side effects"
15:43:10 <dons> warning!!
15:43:17 <dons> really?
15:43:17 <Berengal> Warning indeed!!
15:43:21 <Berengal> Really
15:43:24 <dons> its doing effect analysis?
15:43:37 * dons googles
15:43:45 <Berengal> It was very basic because it stopped complaining when I assigned it to a var
15:44:00 <dons> oh, the entire function returned no result?
15:44:02 <Saizan_> jeffwheeler: np, it'd be nicer if we could say something like Triple :: Term (Literal | Var) -> .. but we don't have row types :\
15:44:07 <dons> but also had no side effects?
15:44:17 <kniu> @pl
15:44:18 <lambdabot> (line 1, column 1):
15:44:18 <lambdabot> unexpected end of input
15:44:18 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:44:20 <kniu> @pl (\a -> \b -> return (f a b))
15:44:20 <lambdabot> (return .) . f
15:44:22 <Berengal> Well, I had just written out the DOM traversing
15:44:31 <dons> Berengal: what's the exact error message? i couldn't google the above one.
15:44:36 <Berengal> lots of parentNode.childNodes[2]
15:44:53 <Berengal> dons: I can't remember the exact wording I'm afraid
15:45:40 <jeffwheeler> dons: "Code has no side effects"
15:45:44 <Berengal> You can a) fire up netbeans (6.7) and check for yourself, or b) wait 8 hours until I'm back at work
15:45:54 <Berengal> Or c) someone else knows
15:46:06 <jeffwheeler> I think, anyways, from some Googling
15:46:21 <Berengal> You're probably correct
15:46:39 <sioraiocht> is using hGetContents on a network stream a bad idea?
15:47:05 <Saizan_> i'd think so
15:47:20 <Saizan_> unless it's a throwaway script
15:47:20 <sioraiocht> Saizan_: were you speaking to me?
15:47:25 <sioraiocht> no, heh
15:47:25 <Saizan_> sioraiocht: yes
15:47:27 <sioraiocht> oh
15:47:27 <sioraiocht> heh
15:47:32 <sioraiocht> Saizan_: okay, thought so
15:47:48 <translated> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <transfers> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <Guest61136> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <korj> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <qvq> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <annoyed> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <selftorture> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <yoo> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <blocking> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <flavors> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <binding> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <buffers> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:48 <reproducing> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:49 <loses> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:49 <placefiller> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:49 <rapidly> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:49 <domestos> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:49 <bureaucratese> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:49 <pending> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:49 <gcos> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:49 <multiplehierarch> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:49 <wigan> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:49 <sioraiocht> Saizan_: no, I am just annoyed with hGetLine removing \n
15:47:50 <adapted> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:50 <unnecessary> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:50 <grasped> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:50 <iterative> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:47:52 --- mode: ChanServ set +o dons
15:47:53 <clothes> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:48:02 <dons> oh man
15:48:02 <fruitfully> http://www.xroxy.com/xorum/about62913.html @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
15:48:05 <copumpkin> @where ops
15:48:06 <sioraiocht> well don't like suck
15:48:06 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
15:48:06 <lambdabot> mauke
15:48:07 --- mode: ChanServ set +o Saizan
15:48:10 <dons> hang on guys, nothing we can do
15:48:11 <timonator> heh, party!
15:48:20 --- mode: tomaw` set +R
15:48:36 <Peaker> hmm.. Botnet?
15:48:42 <sioraiocht> i would think so
15:48:44 <mike-burns> Feels botnet-ish.
15:48:46 --- mode: Saizan set -o Saizan
15:48:46 <dons> so many k lines
15:49:01 <Peaker> one from Israel, and from other countries
15:49:09 <inimino> heh
15:49:18 <inimino> maybe it's performance art
15:49:23 <sioraiocht> Saizan: my problem is that I keep having to reappend "\n" to the end of all "hGetLine" calls because Network.IRC.Parse won't parse them otherwise
15:50:02 <sioraiocht> Saizan: is there a better way? or should I just deal.  IRC messages aren't that long..."
15:50:13 <Saizan> ?src hGetLine
15:50:14 <lambdabot> Source not found. I am sorry.
15:50:41 <allbery_b> tomaw++
15:51:03 <Saizan> sioraiocht: i guess you could write your custom hGetLine if you find it's a problem
15:51:18 <sioraiocht> Saizan: that sounds like more work that it's worth =p
15:51:31 <Saizan> sioraiocht: yeah :)
15:52:04 <Saizan> sioraiocht: and if you find you need performance you should probably switch to bytestrings instead :)
15:52:11 <sioraiocht> Saizan: or text
15:52:19 <Berengal> sioraiocht: Find the implementation of hGetLine. I'm almost entirely sure it's very small and uses some reuseable isLineEnding function
15:52:19 <sioraiocht> since i would prefer unicode support? =p
15:52:34 <sioraiocht> Berengal: k, thanks =)
15:52:37 <Saizan> oh, you're one of the authors too, right?:)
15:52:46 <sioraiocht> Saizan: well, I wrote the original
15:53:05 <sioraiocht> bos was about 10,000,000 times more keen than I or dcoutts was to get it released
15:53:15 <sioraiocht> so any improvements are pretty much him, afaik
15:53:28 <Saizan> it's pretty nice
15:53:34 * blackh is a 'text' fan
15:53:37 <sioraiocht> thanks!
15:53:57 <sioraiocht> unfortunately, when it stopped having academic merit, I had to move on, for now
15:54:43 <sioraiocht> although I have something else I hope to release at the end of this year wrt to string processing
15:55:04 <Saizan> (what's the equivalent of darcs pull -a for git?)
15:55:36 <benmachine> git pull?
15:55:51 <bremner> Saizan: what does -a mean for darcs?
15:56:08 <Saizan> bremner: all the patches
15:56:18 <Raynes> all
15:56:29 <bremner> then yeah, I guess just git pull
15:56:29 <Berengal> all unpulled
15:56:54 <Raynes> git pull pulls everything.
15:56:55 <bremner> I don't think get has a concept of fetching less than that
15:57:10 <Saizan> ok :)
15:57:10 <bremner> although it will not merge every branch
15:57:26 <Raynes> git fetch will get but not merge.
15:57:36 <sioraiocht> hrm, that's a lot of code to move to change one line
15:58:06 <wolf1oo> question: why doesn't (reverse (someIOlist)) work?
15:58:29 <sioraiocht> wolf1oo: I assume the type of IOlist is IO [a]?
15:58:44 <Saizan> wolf1oo: because someIOlist is not a list, it's an action that will produce a list
15:58:53 <wolf1oo> sioraiocht: its actually, to be exact IO [ [ Int ] ]
15:59:11 <sioraiocht> wolf1oo: you want someIOList >>= return . reverse
15:59:14 <Saizan> wolf1oo: you can "extract" the resulting list with do notation, or you can use fmap reverse to lift reverse inside of it
15:59:20 <Saizan> ?type fmap reverse
15:59:21 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f [a]
15:59:29 <sioraiocht> oh yeah, IO is a functor too
15:59:31 <sioraiocht> just kidding
15:59:36 <monochrom> Should I harp my control-inversion thingie? :)
15:59:46 <wolf1oo> okay thanks a bunch
15:59:46 <sioraiocht> monochrom: ?
15:59:55 <pikhq> @instances Functor
15:59:56 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:00:00 <sioraiocht> wolf1oo: either solution will work, Saizan's is prettier, though
16:00:05 --- mode: tomaw` set -R
16:00:06 <pikhq> sioraiocht: Whaddya mean, just kidding?
16:00:08 <Saizan> monochrom: i was thinking of you while writing my answer :)
16:00:27 <monochrom> "don't take data out of IO. insert your algorithm into IO."  A corporate way to say fmap reverse, I guess.
16:00:28 <sioraiocht> pikhq: my solution seems needless complicated =)
16:00:35 <pikhq> Ah.
16:00:48 <sioraiocht> monochrom: so true..
16:01:06 <sioraiocht> monochrom: but that's everyone's sadness when first programming with monads, they just want to escape them
16:01:37 <monochrom> Same sadness with every beginning actor. Told "don't call us, we'll call you". Oh the agony.
16:01:50 <sioraiocht> LOL
16:03:15 <monochrom> There is some self-selection that implies programmers are more likely to be control freaks. They have a hard time accepting control-inversion.
16:04:23 <monochrom> I am a religious person. I gave up control a long time ago. Suddenly all these recursion, lazy evaluation, callbacks, higher-order functions become so natural.
16:04:45 <sioraiocht> So, what is the purpose of Buffered I/O?
16:04:49 <sioraiocht> I never see examples that use it =/
16:05:12 <Saizan> decent performance?
16:05:19 <pikhq> Performance.
16:05:27 <sioraiocht> Saizan: what's the downside?
16:05:28 <pikhq> (most I/O is implicitly buffered)
16:05:32 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/7c314856b2c99ffc
16:05:58 <Saizan> sioraiocht: with no buffering you get a system call for every character, that's not going to perform well
16:06:08 <monochrom> err that url is irrelevant.
16:06:22 <sioraiocht> Saizan: ah, okay.  Why use unbuffered, then?
16:06:45 <Saizan> sioraiocht: when you're doing a CLI for example
16:07:13 <sioraiocht> because of responsiveness?
16:07:16 <Saizan> yeah
16:07:21 <sioraiocht> okay
16:07:29 <sioraiocht> and what about network i/o?
16:07:57 <hackagebot> AERN-RnToRm 0.5 - polynomial function enclosures (PFEs) approximating exact real functions (MichalKonecny)
16:08:25 <sioraiocht> Saizan: just to provide the context, i'm mostly wondering about this in the context of System.IO, choosing different buffering modes
16:08:33 <Saizan> i think that should be buffered, with a flush after you've finished writing the current package
16:08:38 <sioraiocht> okay
16:08:48 <sioraiocht> dons IRC bot example uses nobuffering, I was wondering why
16:09:09 <monochrom> Found it. http://groups.google.com/group/comp.lang.functional/msg/f2b477068bfc05aa
16:09:16 <solrize> @pl \x->[x]
16:09:16 <lambdabot> return
16:09:24 <Saizan> i'm not so expert on this either
16:09:39 <Saizan> anyone wants to differ?:)
16:09:47 <sioraiocht> =)
16:11:02 <al23> Does anybody know why `cabal install time` fails?
16:11:55 <soupdragon> I don't know
16:12:10 <Saizan> al23: can you paste the log with the error on a pastebin?
16:12:17 <solrize> @hoogle a -> [a]
16:12:17 <al23> Resolving dependencies...
16:12:17 <al23> cabal: cannot configure time-1.1.4. It requires base ==4.*
16:12:17 <al23> For the dependency on base ==4.* there are these packages: base-4.0.0.0 and
16:12:17 <al23> base-4.1.0.0. However none of them are available.
16:12:17 <lambdabot> Prelude repeat :: a -> [a]
16:12:17 <lambdabot> Data.List repeat :: a -> [a]
16:12:17 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
16:12:21 <freeone3000> I'm attempting to run http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3108#a3108 . ghc compiles it, however, on run, I get "test: Prelude.(!!): index too large". Why?
16:12:22 <al23> base-4.0.0.0 was excluded because of the top level dependency base -any
16:12:23 <al23> base-4.1.0.0 was excluded because of the top level dependency base -any
16:12:54 <Saizan> al23: ghc version?
16:13:05 <dcoutts> al23: it's not well presented but it means that it wants an installed version of base.
16:13:20 <al23> 6.8.2
16:13:25 <aavogt> @src (!!)
16:13:25 <lambdabot> xs     !! n | n < 0 = undefined
16:13:25 <lambdabot> []     !! _         = undefined
16:13:25 <lambdabot> (x:_)  !! 0         = x
16:13:25 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:13:36 <dcoutts> al23: and you can't upgrade base, it comes with ghc. So if you need base 4 then you need a later ghc, specifically 6.10.x
16:13:46 <blackh> freeone3000: If you want the 2nd element, you need to use !! 1
16:14:19 <freeone3000> blackh: Oh. That's the error for array out of bounds. Thanks.
16:15:03 <al23> dcoutts, thanks. (Actually, I thought I upgraded this system to 6.10...)
16:15:46 <soupdragon> why bother with  ] undefined?
16:15:49 <soupdragon> why bother with  = undefined?
16:16:08 <Peaker> soupdragon: to make it clear what cases form the exhaustive match
16:16:21 <Peaker> soupdragon: Useful in @src, perhaps less so in real code where a Warning might do that
16:16:40 <soupdragon> it shouldn't be exaustive though
16:16:52 <soupdragon> the whole point of !! is that it's partial
16:16:55 <Peaker> soupdragon: Well, its nice that @src shows which cases aren't covered
16:17:03 <Saizan> > [] !! 1
16:17:04 <lambdabot>   * Exception: Prelude.(!!): index too large
16:17:22 <Saizan> you actually get a somewhat informative exception in real code :)
16:19:00 <hackagebot> AERN-RnToRm-Plot 0.2 - GL plotting of polynomial function enclosures (PFEs) (MichalKonecny)
16:21:01 <Baughn> Shouldn't be a better way to pattern-match on the beginning of a string than "f ('a':'b':'c':restOfStr) = ..." ?
16:21:16 <soupdragon> Baughn: no better way,
16:21:23 <Baughn> Bother.
16:21:34 <soupdragon> well you can use a view pattern or somemthing like parsec
16:22:27 <Baughn> View patterns are still broken if you like warnings, unfortunately
16:22:43 <Baughn> And bringing in parsec to parse all of "(ITime " ++ str) ?
16:22:56 <soupdragon> :(
16:25:21 <freeone3000> I'm trying to figure out what the original code did for http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3108#a3109  (the second one). The first one complains the index is too large, as does the second, but it apparently did *something*. The input's of the proper type, and if none of the keys match it prints nothing as it should.
16:26:20 <freeone3000> Does !! do something special for strings, or what am I missing?
16:26:38 <dufflebunk> freeone3000: a String is the same as [Char] isn't it?
16:26:43 <freeone3000> Since !! asks for the 3rd index, and after filter(), there should be 3.
16:27:00 <freeone3000> dufflebunk: Yes?
16:27:01 <aavogt> > let f x = case splitAt 4 x of ("abcd",y) -> y in map toUpper $ f "abcdefg"
16:27:02 <lambdabot>   "EFG"
16:27:20 <aavogt> Baughn: split
16:27:41 <aavogt> At and case aren't that ugly
16:27:42 <Baughn> aavogt: Sorry, I can't handle the warning-brokenness of view-patterns.
16:28:05 <Baughn> Anyway, I already wrote the :-based one.
16:28:16 <freeone3000> It can't be asking for the third parameter of the inner arrays, since those're (String,String), decidedly. Tuples?
16:29:10 <freeone3000> If I'm reading it right, the second paste should print "hello.jpg". Why does it error instead?
16:30:58 <Baughn> conal: It appears to be working. But I can't help but notice that I'm writing multithreaded spaghetti code.
16:31:16 <Baughn> conal: At least it should be properly insulated, and it's a fairly small module
16:31:31 <dufflebunk> freeone3000: keys is the same as fst, btw. The serializeIndexes is doing: map (\x->x!!2) ["a", "b", "c"]
16:31:58 <dufflebunk> The filter is returning the /key/ not the value
16:32:31 <freeone3000> Thanks for that... But it should still return "c", yeh?
16:32:54 <aavogt> > map (!!0) ["abc","def"]
16:32:55 <lambdabot>   "ad"
16:33:01 <aavogt> > (!!0) ["abc","def"]
16:33:03 <lambdabot>   "abc"
16:33:06 <freeone3000> Oh.
16:33:17 <freeone3000> It returns the second *character* of each array key.
16:33:27 <freeone3000> Third, rather.
16:33:40 <freeone3000> Thanks. I'm going to figure out this thing yet.
16:37:31 <dufflebunk> Yay! I was actually able to answer someone else's question!
16:37:52 <Trinithis> you mean first character?
16:38:16 <freeone3000> No, the second paste. x!!2. Tested and confirmed.
16:38:24 <Trinithis> oh i didnt see taht
16:38:29 <Trinithis> > map head ["abc", "gef"]
16:38:31 <lambdabot>   "ag"
16:39:08 <Trinithis> @src (!!)
16:39:08 <lambdabot> xs     !! n | n < 0 = undefined
16:39:08 <lambdabot> []     !! _         = undefined
16:39:08 <lambdabot> (x:_)  !! 0         = x
16:39:08 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:40:04 <Trinithis> Is xs !! n equivalent to (head . drop (n-1))
16:40:12 <Trinithis> Is xs !! n equivalent to (head . drop n)
16:40:19 <Baughn> @hoogle (a,b) -> (b,a)
16:40:20 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
16:40:20 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
16:40:20 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
16:40:28 <benmachine> it'd give different error messages, Trinithis
16:40:33 <benmachine> but otherwise the same I guess
16:40:36 <Trinithis> ok
16:41:06 <mike-burns> Is `xs !! n == (head . drop (n-1))' the kind of thing you could use QuickCheck for?
16:41:26 <Trinithis> sure... but it should be n not n-1
16:41:32 <soupdragon> & xs
16:41:51 <benmachine> @check \xs n -> xs !! n == head (drop (n - 1) xs)
16:41:53 <lambdabot>   "* Exception: Prelude.(!!): index too large
16:41:56 <benmachine> :o
16:41:59 <mike-burns> Heh.
16:42:16 <aavogt> @check error "yes" == undefined
16:42:18 <lambdabot>   "* Exception: yes
16:42:20 <freeone3000> And when a [String] is converted to a String, Haskell just concatonates the parts, right?
16:42:36 <Botje> you don't "convert" them
16:42:41 <benmachine> :t concat
16:42:43 <lambdabot> forall a. [[a]] -> [a]
16:42:54 <Botje> the function you use to combine [String] into String determins what happens to the string
16:43:01 <benmachine> there are lots of ways to merge strings
16:43:08 <Trinithis> @check \xs n -> xs `genericIndex` n == head (drop n xs)
16:43:10 <lambdabot>   "* Exception: List.genericIndex: index too large.
16:43:15 <Botje> "map fst" is also a function of type  [String] -> String
16:43:34 <freeone3000> The function definition is [(String,String)]->String. The result of map (\x = x !! 2) $ ["abc","def"] is a [String].
16:43:48 <freeone3000> >map(\x = x !! 2) $ ["abc", "def"]
16:43:52 <benmachine> @check \xs n -> length xs <= n || xs !! n == head (drop (n - 1) xs)
16:43:54 <lambdabot>   "* Exception: Prelude.(!!): negative index
16:44:01 <benmachine> ¬_¬
16:44:13 <Trinithis> > map(\x = x !! 2) $ ["abc", "def"]
16:44:15 <lambdabot>   <no location info>: parse error on input `='
16:44:20 <benmachine> @check \xs n -> n >= 0 || length xs <= n || xs !! n == head (drop (n - 1) xs)
16:44:22 <lambdabot>   "* Exception: Prelude.(!!): negative index
16:44:23 <Trinithis> > map(\x -> x !! 2) $ ["abc", "def"]
16:44:26 <lambdabot>   "cf"
16:44:28 <benmachine> bah.
16:44:35 <Peaker> @pl map(\x -> x !! 2) $ ["abc", "def"]
16:44:36 <lambdabot> ["abc" !! 2, "def" !! 2]
16:44:37 <dufflebunk> freeone3000: map (\x = x !! 2) $ ["abc","def"] --> ['c', 'f'] == "cf"
16:44:41 <Peaker> heh
16:44:48 <freeone3000> Huh? Why?
16:44:54 <Peaker> @pl \x -> x!!2
16:44:56 <lambdabot> (!! 2)
16:45:14 <aavogt> > @type String
16:45:16 <Trinithis> > ['a', 'b'] == "ab"
16:45:16 <lambdabot>   <no location info>: parse error on input `@'
16:45:19 <lambdabot>   True
16:45:21 <aavogt> @type String
16:45:24 <lambdabot> Not in scope: data constructor `String'
16:45:28 <benmachine> @info String
16:45:28 <lambdabot> String
16:45:33 <benmachine> nice info there.
16:45:42 <aavogt> well, its [Char]
16:45:46 <dufflebunk> freeone3000: it's running x!!2 on each element of ["abc", "def"], which gives you ['c', 'f']. "abc"!!2 = 'c'
16:45:55 <freeone3000> Oh. Because !! gets a char, which returns an array of chars... Okay. Thanks.
16:46:12 <Peaker> freeone3000: list, not array
16:46:23 <Peaker> freeone3000: listofchar!!index -> char
16:46:31 <Peaker> benmachine: why did that @check fail?
16:46:46 <Peaker> benmachine: oh, you had reversed conditions
16:46:53 <benmachine> hm?
16:46:53 <Trinithis> @check True == True
16:46:55 <lambdabot>   "OK, passed 500 tests."
16:47:01 <benmachine> @check True
16:47:03 <lambdabot>   "OK, passed 500 tests."
16:47:04 <Peaker> benmachine: length xs > n || ...  not the other way around
16:47:21 <Peaker> benmachine: because the negative case is exactly the one your pre-condition didn't catch, so it went on to the !!
16:47:32 <benmachine> Peaker: so then I put in n >= 0
16:47:41 <Peaker> benmachine: it should be n < 0  ||
16:47:47 <Peaker> benmachine: not n > 0 ||
16:47:47 <benmachine> @check \xs n -> n < 0 || length xs <= n || xs !! n == head (drop (n - 1) xs)
16:47:48 <benmachine> oh yeah
16:47:49 <lambdabot>   "OK, passed 500 tests."
16:47:54 <benmachine> good point
16:48:04 <Peaker> and the negativity case wasn't necessary
16:48:09 <Peaker> the length case guarantees its not negative anyway
16:48:27 <benmachine> @check \xs n -> length xs <= n || xs !! n == head (drop (n - 1) xs)
16:48:30 <lambdabot>   "* Exception: Prelude.(!!): negative index
16:48:33 <Peaker> @check \xs n -> length xs >= n || xs !! n == head (drop (n - 1) xs)
16:48:33 <Trinithis> @check (\xs n -> xs !! n == head (drop n xs)) :: [Int] -> Int -> Bool
16:48:36 <lambdabot>   "* Exception: Prelude.(!!): index too large
16:48:37 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]
16:48:53 <benmachine> Peaker: no because the length check you *do* want that way around
16:48:59 <Peaker> @check \xs n -> length xs <= n || xs !! n == head (drop (n - 1) xs)
16:49:01 <lambdabot>   "* Exception: Prelude.(!!): negative index
16:49:02 <benmachine> because it's got to catch the case of n-too-large
16:49:02 <Peaker> benmachine: oops, right
16:49:14 <Peaker> @check \xs n -> n < 0 || length xs <= n || xs !! n == head (drop (n - 1) xs)
16:49:16 <lambdabot>   "OK, passed 500 tests."
16:49:20 <aavogt> @hoogle catch
16:49:21 <lambdabot> package catch
16:49:21 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
16:49:21 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
16:49:33 <Peaker> @check \xs n -> n < 0 || length xs <= n || (xs !! n :: Int) == head (drop (n - 1) xs)
16:49:35 <lambdabot>   "Falsifiable, after 3 tests:\n[-1,0,2]\n2\n"
16:50:03 <Peaker> @check \xs n -> n < 0 || length xs <= n || (xs !! n :: Int) == head (drop n xs)
16:50:06 <lambdabot>   "OK, passed 500 tests."
16:50:11 <Peaker> benmachine: there it is :)
16:50:19 <benmachine> what's the typesig for?
16:50:22 <Peaker> benmachine: once you add ::Int, it doesn't quickcheck with the silly default of ()
16:50:30 <benmachine> I see
16:50:32 <Peaker> benmachine: default type in the list is () -- everything compares equal
16:50:38 <benmachine> is () an Ord though
16:50:43 <Peaker> > () < ()
16:50:46 <lambdabot>   False
16:50:49 <benmachine> oh
16:50:49 <Peaker> Yep
16:50:57 <benmachine> ah but drop will force n won't it
16:51:06 <benmachine> @type drop
16:51:10 <lambdabot> forall a. Int -> [a] -> [a]
16:51:14 <Peaker> benmachine: it will skip n () and encounter another ()
16:51:21 <Peaker> benmachine: () always == ()
16:51:38 <Peaker> (x :: ()) == (y :: ())  always = True
16:51:41 <benmachine> Peaker: I'm saying that using n as a parameter to drop will ensure n is an integer
16:51:42 <aavogt> @check (==)
16:51:44 <lambdabot>   "OK, passed 500 tests."
16:51:45 <Peaker> (well, or _|_)
16:51:50 <benmachine> and that xs is a list
16:52:01 <benmachine> we don't mind if xs is a list of ()s because the theorem works anyway
16:52:02 <Peaker> @check (==) :: Int -> Int -> Bool
16:52:04 <lambdabot>   Couldn't match expected type `GHC.Types.Int
16:52:10 <Peaker> @check ((==) :: Int -> Int -> Bool)
16:52:12 <lambdabot>   "Falsifiable, after 0 tests:\n2\n-2\n"
16:52:13 <Trinithis> @check \xs n -> let n' = suchThat n (\n -> n >=0 && n < length xs) in (xs !! n :: Int) == head (drop n xs)
16:52:14 <lambdabot>   Not in scope: `suchThat'
16:52:30 <Peaker> benmachine: but when you used drop (n-1) instead of drop n  which was wrong, it worked when it shouldn't have
16:52:39 <benmachine> I never used (n-1) :P
16:52:41 <Peaker> benmachine: you don't have false negative but you do have false positive because of () == () when it shouldn't
16:52:47 <Peaker> <benmachine> @check \xs n -> n < 0 || length xs <= n || xs !! n == head (drop (n - 1) xs)
16:52:52 <benmachine> oh
16:52:55 <benmachine> so I did
16:52:58 <benmachine> silly me
16:53:05 <benmachine> but what are you saying is the ()?
16:53:16 <benmachine> n?
16:53:26 <Peaker> @check \xs n -> n < 0 || length xs <= n || (xs !! n) == head (drop (n - 1) xs)
16:53:28 <lambdabot>   "OK, passed 500 tests."
16:53:31 <Peaker> benmachine: this is wrong, but its saying OK
16:53:37 <Peaker> benmachine: because its comparing () == ()
16:53:41 <benmachine> oh
16:53:48 <Peaker> if you tell it list of Int instead of list of (), it will find the error
16:53:50 <benmachine> I see what you mean now
16:53:55 <Peaker> @check \xs n -> n < 0 || length xs <= n || (xs !! n :: Int) == head (drop n xs)
16:53:56 <benmachine> we need to make sure the list elements are difference
16:53:59 <lambdabot>   "OK, passed 500 tests."
16:53:59 <benmachine> different
16:54:01 <Peaker> yep
16:54:07 <benmachine> k
16:54:27 <Peaker> @check \xs n -> n < 0 || length xs <= n || (xs !! n :: Int) == head (drop (n-1) xs)
16:54:30 <lambdabot>   "Falsifiable, after 2 tests:\n[2,-2]\n1\n"
16:54:44 <benmachine> I was so busy trying to fix the exceptions I forgot what it was that I was proving
16:54:56 <Trinithis> @ty suchThat
16:54:58 <lambdabot> forall a. Gen a -> (a -> Bool) -> Gen a
16:55:03 <Peaker> @hoogle (===>)
16:55:04 <lambdabot> No results found
16:55:05 <Peaker> @hoogle (==>)
16:55:06 <lambdabot> Test.QuickCheck (==>) :: Testable a => Bool -> a -> Property
16:55:29 <Peaker> @check \xs n -> n < 0 ==> length xs <= n ==> (xs !! n :: Int) == head (drop n xs)
16:55:30 <lambdabot>   Not in scope: `==>'Precedence parsing error
16:55:31 <lambdabot>      cannot mix `GHC.Classes.<'...
16:55:56 <Peaker> @check \xs n -> (n < 0) ==> (length xs <= n) ==> ((xs !! n :: Int) == head (drop n xs))
16:55:58 <lambdabot>   Not in scope: `==>'Not in scope: `==>'
16:56:08 <Peaker> hmm.. missing import
17:04:14 <kyagrd> I'm wondering why product is so slow.
17:04:48 <kyagrd> It takes about 35 seconds to compute product [1..100000] with compiled GHC 6.10.4 binary.
17:05:16 <kyagrd> However, when I hand code the factorial function using accumulators and strict application it only takes about 6 seconds.
17:05:38 <slacks21> wow
17:05:40 <slacks21> crazy
17:05:46 <MyCatVerbs> @src product
17:05:47 <lambdabot> product = foldl (*) 1
17:05:57 <badsheepy> took like a second when i tried it in 10.3 just now :o
17:05:58 <kyagrd> It's not foldl' ???
17:05:59 <MyCatVerbs> Look ma, no foldl'.
17:06:08 <MyCatVerbs> Yeppers.
17:06:12 <slacks21> lol
17:06:18 <kyagrd> WTF -_-
17:06:32 <MyCatVerbs> kyagrd: Please try foldl' (*) [1..100000] ? :)
17:06:41 <mike-burns> @src foldl'
17:06:41 <lambdabot> foldl' f a []     = a
17:06:41 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:06:53 <MyCatVerbs> And then, for great justice, you might want to try the UArr version.
17:07:32 <Baughn> kyagrd: 2 seconds here, with -O2. 16 without any -O.
17:07:39 <Baughn> kyagrd: ..about what you'd expect.
17:08:24 <kyagrd> Yeah foldl' is pretty much what I expected
17:08:44 <kyagrd> I thought product and sum was using foldl'
17:08:49 <kyagrd> @src sum
17:08:50 <lambdabot> sum = foldl (+) 0
17:08:52 <MyCatVerbs> fold1U (*) . enumFromToU 1 $ 100000
17:08:52 <kyagrd> grrr
17:09:11 <Baughn> kyagrd: They only use foldl' when using -O2, pretty much.
17:09:12 <MyCatVerbs> kyagrd: there's a rewrite rule that transforms them to foldl', but IIRC it only fires on the Int versions.
17:09:28 <Baughn> kyagrd: In some, very weird cases, foldl' and foldl are not semantically equivalent
17:09:30 <MyCatVerbs> kyagrd: You won't be seeing that rule in action because you're having to multiply Integers instead.
17:10:07 <Saizan__> Peaker: are there any example uses of generator? i can't find much in the repo, something like hGetContents would be nice
17:11:47 <slacks21> does someone happen to know what the haskell equiv. to a scheme predicate such as (number? foo) would be?
17:12:04 <Peaker> Saizan__: yairchu took over that. We've discovered that the primary use case we had in mind (replacing Iteratee) was broken since you could still fork the generation. I think all the useful stuff became a ListT
17:12:10 <ivanm> slacks21: is foo a String?
17:12:13 <Peaker> Saizan__: A proper ListT, hopefully, in a package yairchu called List
17:12:14 <Baughn> slacks21: Num a => a in a type signature
17:12:25 <slacks21> but if I want a case statement
17:12:25 <mike-burns> slacks21: foo :: (Num a) => a
17:12:25 <MyCatVerbs> slacks21: \_ -> True :: (Num a) => a -> Bool. ;)
17:12:29 <Peaker> Saizan__: But I haven't followed it in a while, so I'm not entirely sure what's now in the generator package
17:12:37 <ivanm> but otherwise, if foo is of any type then AFAIK it isn't possible to have a generic isNumber function
17:12:38 <CalJohn> slacks21: typically you use types/pattern matching to do that kind of thing
17:12:47 <Baughn> slacks21: There is no need for the system to check what type a value is at runtime; that's decided at compile-time
17:12:52 <MyCatVerbs> slacks21: There isn't one. Haskell is statically typed, so you already know whether or not something is a number at compile-time.
17:12:52 <CalJohn> slacks21: for example, null? would be pattern matching on []
17:13:03 <mike-burns> slacks21: Can you explain more what you're trying to achieve? Maybe post some code?
17:13:12 <slacks21> yeah, thanks for all the responses
17:13:16 <Peaker> Saizan__: A ListT is kinda useful for this stuff but doesn't have the nice guarantees that an Iteratee has.  I think its possible to fix generator though without going all continuation-ish like iteratee
17:13:18 <Baughn> ..for once, a harmonious choir
17:13:26 <slacks21> was just considering them all carefully.  to paste bin... brb
17:13:33 <ray> answered in glorious 5.1
17:13:41 <Saizan__> Peaker: if properly packaged continuations don't scare me at all :)
17:13:45 <Baughn> Who's the .1?
17:14:02 <ray> lambdabot
17:14:05 <Saizan__> Peaker: however, what do you mean by forking the generation?
17:14:17 <ivanm> Baughn: in glorious symphony? :p
17:14:36 <ivanm> > cycle "bass "
17:14:37 <Peaker> Saizan__: Well, ListT itself can be used to generate lists with side effects in between elements (unlike mtl's LIstT, there's a monadic action around each cons, not just around the whole list)
17:14:38 <lambdabot>   "bass bass bass bass bass bass bass bass bass bass bass bass bass bass bass...
17:14:49 <ivanm> ;-)
17:14:58 <ivanm> see? lambdabot is indeed the .1 ...
17:15:03 * Baughn caught a bass once
17:15:13 <Peaker> Saizan__: but there's a problem, you can execute/bind the ListT actions as many times as you'd like, so a generator that reads a file for example, cannot guarantee that the file reading actions are run exactly once in between the opening and closing of the file, like iteratee can
17:15:14 <MyCatVerbs> ivanm: Shouldn't that be (cycle "DOOF! ") insteaD?
17:15:19 <ivanm> Baughn: and did you eat it?
17:15:20 <MyCatVerbs> Er, instead.
17:15:27 <ivanm> MyCatVerbs: nah, this isn't metal ;-)
17:15:27 <Saizan__> Peaker: i see
17:15:34 <Baughn> ivanm: Of course
17:15:37 <Peaker> Saizan__: so generator was supposed to capture the notion of iterating a ListT from beginning to end, with a StateT on the current ListT node
17:15:44 <slacks21> I guess this is what I'm after:  http://pastebin.com/m762d2116
17:15:44 <Peaker> Saizan__: (ConsumerT was that StateT)
17:15:46 <ivanm> Baughn: and was it delicious?
17:16:05 <ivanm> slacks21: depends on what type x is
17:16:08 <slacks21> sorry for my less than adequate description.  Still really new to haskell
17:16:09 <Peaker> Saizan__: But ConsumerT had methods that let you be exposed to the actions underneath, which again let you re-bind the action multiple times/etc, which made the generator lose control again
17:16:10 <ivanm> and what your predicate is
17:16:18 <mike-burns> slacks21: You can do that depending on the predicate, but the type of x is checked at compile type.
17:16:19 <slacks21> oka.y... say I just want a number?
17:16:19 <Baughn> ivanm: I bassked in its delicioty.
17:16:20 <mike-burns> time
17:16:21 <Raevel> this was a neat peasant multiplication: sum . map snd . filter (odd . fst) . iterate ((`div` 2) *** (* 2))
17:16:33 <ivanm> slacks21: note that in haskell, you don't generally do "is it of type foo", because the type system already tells you that
17:16:39 <Saizan__> Peaker: k
17:16:45 <ivanm> as people said above
17:16:52 <mike-burns> slacks21: foo :: (Num a) => a -> YourResultType
17:16:53 <Lemmih> slacks21: You can have my number '32'. It is slightly used.
17:16:58 <ray> in haskell, a predicate like even makes sense, but not one like number
17:17:05 <ivanm> Lemmih: how much do you want for it?
17:17:05 <ray> haskell has a type system
17:17:14 <Peaker> Saizan__: Producer was basically a ListT that doesn't expose the data constructors (so you can't iterate/fork it yourself)
17:17:19 <ivanm> ray: technically, all programming languages do ;-)
17:17:23 <slacks21> so if I want to just return some function contingent about whether the variable is of a certain type.
17:17:29 <ray> well, yeah, i use it in the haskell sense
17:17:31 <slacks21> okay, I see what you're all saying
17:17:32 <MyCatVerbs> slacks21: It sounds like you really, really want to start with a from-the-bottom-up tutorial on Haskell. I'm impressed that you went and learned Scheme, but there are a Hell of a lot of differences beyond just the syntax. :)
17:17:38 <MyCatVerbs> @where lyah
17:17:38 <lambdabot> www.learnyouahaskell.com
17:17:46 <ray> compared to haskell, scheme doesn't have a type system
17:17:57 <ray> just some language chauvinism :)
17:18:00 <slacks21> lol
17:18:01 <MyCatVerbs> slacks21: I strongly recommend reading LYAH. Learn You A Haskell - For Great Good! ^_^
17:18:13 <ivanm> slacks21: one option is to define a new class, and for different instantiating types the class function returns a different value
17:18:15 <slacks21> oh sweet, yeah, I'll definitely check that out
17:18:15 <ray> yeah everyone likes lyah
17:18:16 <MyCatVerbs> ray: It does too! It's just that it applies to values, not to bindings. :)
17:18:18 <ivanm> but IMHO, that's probably messy
17:18:18 <Baughn> @type do forkIO foo; bar
17:18:19 <lambdabot> Not in scope: `forkIO'
17:18:19 <lambdabot> Not in scope: `foo'
17:18:19 <lambdabot> Not in scope: `bar'
17:18:23 <ivanm> ray: heh
17:18:28 <ivanm> ray: I don't like LYAH
17:18:30 <Baughn> Right. Umh..
17:18:33 <Baughn> @type (>>)
17:18:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
17:18:56 <CalJohn> MyCatVerbs: "impressed he went and learned scheme" <- that is a strange way of talking about it
17:18:58 <Baughn> ..oh. Doh.
17:19:16 <ivanm> CalJohn: most people automatically go "ugghhh, parentheses"
17:19:21 <MyCatVerbs> CalJohn: It's 1am and I'm a strange person.
17:19:29 <Lemmih> ivanm: I'm willing to trade it for the smallest uninteresting number.
17:19:31 <MyCatVerbs> CalJohn: and not many people do actually ever learn Scheme.
17:19:36 * pikhq notes that, compared to Haskell, Scheme is imperative
17:19:37 <ivanm> Lemmih: heh
17:19:39 * ivanm passes
17:19:44 * Berengal doesn't see parenthesis, only ASTs
17:19:54 <ray> compared to haskell, scheme is practically fortran
17:19:54 <MyCatVerbs> Lemmih: but that would be interesting for that reason al-head explode.
17:20:07 <CalJohn> MyCatVerbs: most people don't actually ever learn haskell either...i am quite confused :)
17:20:11 <MyCatVerbs> ray: Now that's just brazen conjecture.
17:20:22 <slacks21> yeah, I've definitely been impressed by the type inference some of the interesting things you can do with lazy evaluation.  All sort of interesting things that you come across less in Lisp and a lot of other languages.  Although the list comprehension and interactions makes me feel at home
17:20:25 <pikhq> ray: Except that Scheme has much nicer metaprogramming.
17:20:25 <aavogt> @index forkIO
17:20:25 <lambdabot> Control.Concurrent
17:20:34 <slacks21> thanks again all for your help.  Time for some reading
17:20:36 <MyCatVerbs> CalJohn: it's... fewer. Or more. I don't know. Whatever.
17:20:40 <Berengal> <3 lists
17:20:46 <MyCatVerbs> CalJohn: quit poking me! ;-;
17:21:15 <ivanm> > cycle "poke MyCatVerbs; "
17:21:16 <lambdabot>   "poke MyCatVerbs; poke MyCatVerbs; poke MyCatVerbs; poke MyCatVerbs; poke M...
17:21:19 <ivanm> ;-)
17:21:20 <CalJohn> I think a lot more people get exposed to scheme than haskell.  at least, outside of the UK
17:21:31 <ivanm> CalJohn: nowadays it's Python :(
17:21:41 <mike-burns> ivanm: At MIT, you mean.
17:21:47 <Berengal> Could be worse than python. At least it's got first class functions
17:21:51 <MyCatVerbs> AIEEE.
17:21:57 <mike-burns> ivanm: "Outside the UK" includes more schools than just MIT.
17:21:59 <ray> python has second class first class functions
17:21:59 <slacks21> I wonder why that is.  Seems like a really powerful language
17:22:02 <CalJohn> it is python in general, though, not just in mass tech colleges
17:22:12 <thoughtpolice> ray: yeah, isn't lambda crippled too?
17:22:14 <ivanm> mike-burns: all the unis here in Brisbane which switched to teaching scheme with SICP a few years ago are now switching the Python AFAIK
17:22:16 <al23> mike-burns, now it's Python, even in MIT :-)
17:22:16 <CalJohn> thoughtpolice: YES!
17:22:22 <thoughtpolice> i mean, i'm not complaining. i don't mind python all that much
17:22:25 <solrize> is there a 254 char limit on lines going into ghci ?
17:22:29 <thoughtpolice> different tools and all
17:22:30 <CalJohn> thoughtpolice: sorry, that has just always been my bugbear about python
17:22:33 <ray> haskell is just as scary as lisp to most people, but it's not because of parentheses
17:22:44 <thoughtpolice> but runtime errors based on incorrect types just pisses me off :(
17:22:47 <ivanm> solrize: I would first query why you have lines that are 254 chars long ;-)
17:22:49 <Peaker> thoughtpolice: lambda is just crippled syntax, it has named functions that are not crippled
17:22:52 <pikhq> ray: Monads.
17:22:52 <mike-burns> LISP isn't scary because of the parens either; it's just a convenient scapegoat.
17:23:06 <pikhq> That's the #1 scary thing.
17:23:10 <CalJohn> people who piss and moan about parens are shitty thinkers anyway
17:23:13 <pikhq> Purely functional is #2.
17:23:15 <ray> if you're going to have runtime type errors, why do you even have types
17:23:17 <mike-burns> pikhq: What about monads are scary?
17:23:30 <ray> monads are easy
17:23:31 <Berengal> mike-burns: The name
17:23:33 <ray> and scary
17:23:35 <pikhq> mike-burns: The word itself is scary to noobs.
17:23:35 <ray> but easy!
17:23:38 <Peaker> Python is nice, in that when you have a vague vision of how it should work, and don't care too much about ideal design, you can really quickly whip something up that seems to wrok
17:23:46 <benmachine> I'm a bit stuck with this ncurses application: I'm trying to update the screen either when the user presses a key (getch returns) or some data arrives on an MVar
17:23:51 <CalJohn> ray: presumably because it's better never to add 3 and "foo" than do so, even at runtime
17:23:53 <pikhq> "ZOMG SOMETHING IVE NEVER HEARD OF!"
17:23:55 <benmachine> whichever is sooner
17:24:08 <benmachine> but the getch call is unsafe, so I gather it won't get on nicely with threads
17:24:09 <mike-burns> Okay, I admit that I was frightened by the name "monad", and not because I hadn't heard of it before. Quite the opposite.
17:24:12 <Berengal> At least python has strong typing
17:24:26 <kyagrd> Python is dynamically typed
17:24:31 <pikhq> Berengal: That's duck typing.
17:24:38 <kyagrd> By no means "Strong" typing
17:24:40 <benmachine> Berengal: sort of. l = [1,2]; l = l[0] is entirely reasonable in python
17:24:45 <benmachine> (which I hate)
17:24:54 <ray> duck typing is sorta like, everything is a typeclass constrained type variable
17:25:03 <Berengal> benmachine: Yeah, but that's dynamic typing, not weak typing
17:25:19 <mike-burns> I had no idea "strong typing" had an agreed-upon definition.
17:25:21 <al23> pikhq: actually, there are a lot of complicated concepts in Haskell while Scheme is a quite tiny language.
17:25:32 <kyagrd> python is a lisp without macros, perenthesis, and a good compiler. if one wants to find any relation to lisp
17:25:37 <pikhq> al23: True.
17:25:38 <ray> haskell isn't that big as a language either
17:25:43 <ray> bigger than scheme, i suppose
17:25:51 <CalJohn> kyagrd: python has a good compiler?  it doesn't even have a good interpreter
17:25:55 <benmachine> anyway can anyone comment on my ncurses problem where I need a blocking call to not block but it blocks
17:25:55 <mike-burns> C# is bigger than Scheme; doesn't make it scarier.
17:25:57 <kyagrd> ray: GHC is BIG
17:25:59 <pikhq> al23: Though most of the complicated concepts is the libraries.
17:26:08 <kyagrd> CalJohn: I said "without" :)
17:26:12 <ray> monad is a typeclass
17:26:16 <Berengal> Dynamic typing makes a bit more sense to me in imperative languages. Types follow values, not names. The same is true for haskell, but since you can't rebind you can't change the type of a name anyway
17:26:16 <ray> not a magical language keyword
17:26:22 <ray> the only magic is do notation
17:26:23 <mike-burns> benmachine: I would except I don't know a solution or anything useful to say.
17:26:52 <CalJohn> kyagrd: ah, :p  even so, i would say "Common Lisp" instead of "Lisp".  Scheme is actually rather nice, except with limited typing
17:26:57 <benmachine> mike-burns: your sentiment is much appreciated
17:27:09 <pikhq> ray: And that can do something completely different if you futz with the prelude to make >>= and friends do something weird. :P
17:27:14 <Peaker> mike-burns: sure C# is scarier than Scheme
17:27:17 <ray> yes
17:27:21 <benmachine> (I didn't want to seem pushy; it's just a hard problem and it's getting drowned in all this pesky interesting-conversation stuff)
17:27:26 <ray> i am no stranger to rewriting prelude
17:27:51 <pikhq> mike-burns: C# is not scary, it's just far larger than any sensible language deserves to be.
17:28:03 <Berengal> benmachine: forkIO/timeout not cutting it?
17:28:13 <ivanm> pikhq: is it the language or the included libs that are too large?
17:28:20 <shepheb> C# is hardly the first to go against the wall when the revolution comes
17:28:27 <benmachine> Berengal: well, I've been told it won't cut it because it's an unsafe foreign call
17:28:33 <Peaker> benmachine: why do you need it not to block?
17:28:34 <benmachine> but I haven't actually made sure yet
17:28:35 * ivanm has heard that C# and other .Net languages are great solely because they come with such large standard libraries
17:28:37 <pikhq> ivanm: Libraries, mostly.
17:28:38 <mike-burns> pikhq: Not sure how to measure such a thing. I'm continuously finding ways to refactor my Haskell code using something in a standard library, for example.
17:28:42 <ivanm> pikhq: *nod*
17:28:50 <Berengal> benmachine: What about forkOS?
17:28:50 <benmachine> Peaker: well, it's a net application that I want to accept data from the network and the user
17:28:59 <pikhq> And how very absurd the organization is.
17:29:04 <Peaker> benmachine: Usually you do that with IO threads
17:29:16 <benmachine> okay I'll try some more things and get back to you
17:29:40 <Peaker> benmachine: You can basically use a little thread as an adapter from a blocking to a non-blocking interface, though
17:29:44 <pikhq> I.Do.Not.Think.That.This.Is.A.Good.Organizational.Method.write();
17:29:47 <CalJohn> How likely is it that the prelude will get "fixed" eventually?
17:29:51 <mike-burns> pikhq: That's syntax.
17:30:09 <pikhq> mike-burns: The class hierarchy is syntax?
17:30:15 <Peaker> benmachine: create a thread to execute your thingie and put the result in an mvar, try to read the mvar, if its not complete, you can ignore it and poll it later
17:30:26 <mike-burns> pikhq: The reason it's a pain to write isn't because of the hierarchy, it's because of the syntax.
17:30:39 <pikhq> mike-burns: Oh, okay.
17:30:47 <pikhq> The hierarchy can make it hard to reason about, though.
17:30:50 <benmachine> Peaker: what I'm worried about is that the thingy is an unsafe foreign call
17:31:09 <benmachine> which I've heard (but admittedly not tested) blocks all threads
17:31:09 <Peaker> pikhq: names, namespaces and hierarchies of namespaces are essentially a syntactic thing, as part of the syntax/encoding of the code's graph into a tree and later into text
17:31:27 <pikhq> Peaker: Libraries are syntax?
17:31:42 <Peaker> pikhq: They are encoded with syntax, into source files
17:31:52 <Peaker> pikhq: They are also found/imported with syntax
17:31:53 <pikhq> Yes, that doesn't make it syntax.
17:32:05 <mike-burns> pikhq: I've never heard of a class heirarchy causing difficulty reasoning about code. Can you elaborate? (I don't mean this sarcastically; I'm really interested.)
17:32:16 <kyagrd> Syntax is important though.  Haskell's success is partly due to its syntax. Don't need much garbage like define or let in every definition
17:32:22 <Peaker> pikhq: I see code as an abstract syntax graph, and I see syntax as a 2-layered beast -- one translates ASG->AST (that's where namespaces+names come in), and the next phase translates AST -> Text
17:32:45 <Peaker> benmachine: You can call it forkOS instead of forkIO
17:32:57 <kyagrd> Nobody would want to use whitespace or unlambda langauge for serious programming.
17:32:59 <Peaker> benmachine: (which creates a real OS thread, rather than a cooperative one)
17:33:09 <pikhq> mike-burns: Hrm. Actually, it's not so much the class hierarchy that causes any difficulties, now that I try to type out my thoughts.
17:33:18 <mike-burns> kyagrd: Unless there were Visual Studio support for it ...
17:33:18 <benmachine> Peaker: thanks, I'll have a look
17:33:53 <monochrom> Visual Studio support for whitespace would be funny!
17:33:53 <mike-burns> pikhq: Most OO programmers don't have a "reason about code" mindset, which may be why most OO programming languages are awkward to reason about.
17:34:04 <pikhq> It's the slavish devotion to objects even where they make no sense that does it. Also, the wankish usage of, say, factories of factories of objects. (I hope that specifically isn't in .Net)
17:34:20 <kyagrd> OO languages were invented for simulation not for reasoning in the first place.
17:34:32 <mike-burns> pikhq: Lots of factories is also in Java. Not so much in Smalltalk or Ruby.
17:34:47 <pikhq> mike-burns: Yeah, that's very much a Java/.Net-ism.
17:35:01 <monochrom> You have to reason about your simulator.
17:35:03 <CalJohn> factories are more important when you can do less at runtime
17:35:15 <CalJohn> (like in java and, i assume .net languages)
17:35:21 <mike-burns> Factories are also important when the syntax is heavy.
17:35:47 <mike-burns> Much of the time a factory is used simply as a shortcut instead of as anything GoF talks about.
17:35:51 <pikhq> And Smalltalk, well... Smalltalk is in a minority of "objects everywhere" languages that did it by making a good language.
17:36:50 <pikhq> Rather than just taking a well-known design concept and making it have objects.
17:37:16 <pikhq> (see: C->C++, Perl->Perl, etc.)
17:37:48 <mike-burns> Java is only related to C++ via syntax; the semantics, especially at first, were based on Smalltalk.
17:39:08 <mike-burns> But I do agree with whoever was making the claim that Haskell isn't much harder than Scheme to learn.
17:39:52 <CalJohn> i think it is much harder to learn.  there are far more concepts involved
17:40:09 <pikhq> Java always seemed more like "Let's take C, take out the memory management, shove in Smalltalk objects, and let a lot of crazy people write libraries for it." to me.
17:40:31 <mike-burns> But most of the concepts are just tricks that you could also do in Scheme, but they happen to come with Haskell.
17:41:21 <Axman6> CalJohn: i disagree
17:41:38 <solrize> there's a paper by hinze somewhere, that explains basically all of GoF patterns in terms of haskell generics
17:41:46 <mike-burns> Also, Scheme has macros which are quite challenging to think about. Part of that is syntactic.
17:42:06 <mike-burns> solrize: That sounds awesome. Going to try to search for that now but if you have some pointer that'd be useful.
17:42:36 <solrize> mike-burns i think i have it bookmarked on another computer, i can look for it sometime later
17:42:58 <solrize> http://www.google.com/search?q=hinze+"gang+of+four"+patterns+generics
17:42:59 <solrize> hah
17:43:10 <CalJohn> i don't know if any of you have ever read the little schemer, but that book teaches almost all of the concepts required for learning scheme in about 150 pages of dialogue.  i don't think that is possible with haskell - there is so much more
17:43:34 <mike-burns> CalJohn: But Cale does that every night here!
17:44:12 <dibblego> CalJohn, you could teach all those same concepts with Haskell in 100 pages
17:44:30 <solrize> http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/hodgp.pdf
17:44:51 <mike-burns> CalJohn: I disagree that it teaches that much, too. There are a lot of useful concepts in everyday programming that it doesn't even come close to caring about. Testing, for example. A Haskell version would involve QuickCheck.
17:44:51 <solrize> hah, i guess it's not by hinze after all :)
17:44:57 <MyCatVerbs> dibblego: Sure, if you cut all the dialogue and the margins and everything. :)
17:45:10 <mike-burns> solrize: Thanks a bunch.
17:45:11 <CalJohn> types, monads, lazy evalutation, referential transparency as a requirement
17:45:25 <CalJohn> ^ all those are extra on top of what scheme requires
17:45:37 <CalJohn> and that's just what i can think of off the top of my head
17:45:45 <sjanssen> CalJohn: you don't need to teach referential transparency -- you just skip teaching mutability
17:46:02 <mike-burns> CalJohn: Types are kinda covered in the Little Schemer, IIRC, but it takes longer because they're dynamic.
17:46:09 <mike-burns> And monads are easy.
17:46:12 <MyCatVerbs> dibblego: I bet if you wrote a formal spec of Haskell's syntax and semantics, with all of the side-effectful operations explained in terms of POSIX syscalls or something, you'd probably pack it into a few dozen pages easily. Just... not really what you'd call bedtime reading material. :)
17:46:15 <CalJohn> mike-burns: yeah, but testing is kind of a difficult issue - it's an engineering issue, not a pure compsci one
17:46:27 <solrize> http://lambda-the-ultimate.org/node/1360  discussion thread about that paper
17:46:27 <Axman6> CalJohn: al those concepts, except monads are trivial imo
17:46:31 <CalJohn> sjanssen: referential transparency is more than that
17:46:40 <pikhq> MyCatVerbs: I beg to differ.
17:46:50 <ivanm> dibblego: someone was asking last night why people use QC 1.* rather than 2.*; since I know you do that (and because I"m curious about this as well), why?
17:46:53 <pikhq> Of course, I'm not someone to ask about "bedtime reading material".
17:47:00 <mike-burns> solrize: Wow, thanks again!
17:47:07 <CalJohn> i think monads are trivial too (i don't know why people find them non-intuitive), but seeing the implications aren't
17:47:08 <dibblego> ivanm, because I haven't upgraded the package
17:47:09 <pikhq> I learned C from the libc documentation and a vague knowledge of the syntax.
17:47:15 <sjanssen> CalJohn: I don't see why you need to teach it in an introductory book.  Besides, how is referential transparency complicated enough to add length to a book?
17:47:15 <ivanm> dibblego: heh
17:47:16 <MyCatVerbs> pikhq: Well. Depends on whether you want material that is enjoyable to read just before going to bed, or...
17:47:22 <ivanm> dibblego: heh, that's one reason I suppose ;-)
17:47:23 <MyCatVerbs> pikhq: ...material that will cause you to sleep soundly? =D
17:47:38 <pikhq> MyCatVerbs: It would be quite enjoyable.
17:47:49 <CalJohn> sjanssen: because haskell needs you to think about it
17:48:02 <ivanm> pikhq: I've found that enjoyable material _stops_ you from getting to sleep...
17:48:04 <CalJohn> i'm a little surprised that you guys think haskell is simpler than scheme
17:48:05 <sjanssen> CalJohn: I thought the point of purity is that you never have to think about purity
17:48:24 <pikhq> ivanm: True enough.
17:48:28 <dibblego> CalJohn, I'm surprised that you're surprised
17:48:29 <Axman6> CalJohn: do you find referencial transparency to be a difficult topic? it seems trivial to me for anyone who's ever used functions in maths
17:49:12 <sjanssen> CalJohn: erm, point of purity is that you never have to think about referential transparency
17:49:22 <mike-burns> CalJohn: I think it's just slightly harder than Scheme.
17:49:22 <CalJohn> Axman6: no, i don't (do you?  i don't see the point of that question...).  i think it has implications for how you teach people about things like IO/non-determinism
17:49:39 <ivanm> sjanssen: unless you're writting an FFI wrapper or something to another lib?
17:49:44 <sjanssen> CalJohn: ah, so you meant to say IO in your list :)
17:50:04 <mike-burns> CalJohn: The Little MLer teaches types plus most of the Little Schemer in the same size book, approx.
17:50:42 <CalJohn> mike-burns: i haven't read that one.  i would like to, but i'm not willing to buy that book
17:51:29 <ivanm> CalJohn: see, there's these magical places called "libraries" where you can find a wide variety of books you can read and usually even take home for a while, often for _free_...
17:51:30 <ivanm> ;-)
17:51:30 <CalJohn> (and since it is summer, the library is not down the road anymore)
17:51:52 <ivanm> dammit, you pre-empted my attempt at humour! :@
17:51:59 <mike-burns> Libraries are still around? I thought they were replaced by BitTorrent.
17:51:59 <CalJohn> ivanm: my parents live in a sink town, and it is summer.  there are no academic libraries here :(
17:52:09 <ivanm> CalJohn: "sink town"?
17:52:15 <ivanm> it's a town that revolves around sinks?
17:52:19 <mike-burns> A town that speciailizes in sinks?
17:52:21 <mike-burns> ha.
17:52:23 <CalJohn> heh
17:52:25 <ivanm> (as in "mining town", etc.)
17:52:35 <ivanm> mike-burns: nah, hard-copy books are still useful
17:52:46 <ivanm> especially if they're _old_ hardcopy books that no-one has torrented yet
17:52:59 <CalJohn> mike-burns: there are lots of books you can't find on bittorrent.  the little schemer is an example
17:53:07 <ivanm> (and they happen to be the only source of an obscure paper that everyone references but the internet doesn't seem to contain)
17:53:16 <ivanm> @go torrent "little schemer"
17:53:17 <lambdabot> No Result Found.
17:53:20 <ivanm> hmmm...
17:53:38 <ivanm> CalJohn: if it wasn't for the fact that I'm meant to be doing stuff, I would take up your challenge in earnest!
17:54:10 <al23> ivan: I think almost every good / classic old book is available from the web.
17:54:29 <CalJohn> @google "little schemer" filetype:torrent
17:54:29 <lambdabot> No Result Found.
17:54:36 <CalJohn> ivanm: proof? :)
17:54:42 <ivanm> al23: even old, old looks-like-it-was-written-on-a-typewriter mathematics text from the 30s or something?
17:55:00 <ivanm> CalJohn: could be in the hidden internet (that is, google doesn't index it)...
17:55:16 <mike-burns> ivanm: I just checked the hidden Internet and didn't find any Little books.
17:55:19 <CalJohn> ivanm: hmm, i am in on a few of those dark caverns, and i never saw it
17:55:22 <ivanm> heh
17:55:59 <CalJohn> though, if you know of any pointers to hidden internets i might not know about, maybe you could pm me?
17:56:16 <ivanm> CalJohn: the only torrenting one I know of is demonoid
17:57:02 <ivanm> (and most of the rest would probably get you arrested for liking little children a little too much...)
17:57:16 <al23> ivanm: no one needs texts from the 30s. I think Springer reprints good old textbooks, but many of them are really interesting only for historical reasons.
17:57:26 <ivanm> al23: I did once
17:57:46 <ivanm> for a paper that everyone referenced in similar texts that I needed for my own report
17:58:16 <sjanssen> Demonoid has The Little Schemer and The Seasoned Schemer (not that I condone that sort of thing)
17:59:26 <vav> hehe, in Colorado library alliance system (self serve interlibrary loan) there is one Little Schemer and three Little MLer, two of which are electronically accessible.
17:59:29 <mike-burns> sjanssen: Does it have The Little MLer?
17:59:35 <sjanssen> mike-burns: no
18:00:22 <CalJohn> vav: i go to university near a copyright library
18:00:25 <monochrom> 1 little, 2 little, 3 little schemers, 5 little, 8 little, 13 little schemers.
18:00:28 <ivanm> sjanssen: putting aside whether you condone it or not, have you ever availed yourself of it? :p
18:00:33 <CalJohn> vav: it is a nice service to have on your doorstep
18:00:33 <ivanm> CalJohn: "copyright library"?
18:00:49 <vav> ivanm: shall I apply for a visitors library card for you? ;-)
18:01:01 <ivanm> monochrom: I think you're missing another "1" at the front there...
18:01:04 <sjanssen> ivanm: never for a book
18:01:15 <CalJohn> ivanm: it has all the books that have ever been pressed in my country since 1900
18:01:24 <ivanm> vav: nah, tried reading the little schemer; didn't think much of it
18:01:31 <ivanm> CalJohn: :o
18:01:33 <CalJohn> ivanm: ie: all the books ever in copyright
18:01:54 <ivanm> CalJohn: you're saying that all books that have ever been in copyright where published at one point or another in the UK?
18:02:02 <ivanm> even foreign language ones?
18:02:13 <ivanm> and how about little home-brew custom books?
18:02:15 <monochrom> ivanm: that would not have the surprise effect of suddenly going to 5,8,13.
18:02:20 <ivanm> e.g. print-on-demand from amazon or something
18:02:28 <ivanm> monochrom: true
18:02:40 <ivanm> took me a while to work out why you missed 4...
18:02:55 <CalJohn> ivanm: i've thought about it, and i don't really know how small you have to be not to be in there
18:03:43 <CalJohn> ivanm: a much bigger deal is that not all the computer science/maths books i am interested in have been pressed in the UK
18:03:51 <CalJohn> but even that is a fairly small deal
18:04:02 <ivanm> but they're still in copyright...
18:04:15 <CalJohn> yeah, but they have to be pressed here
18:04:22 <ivanm> *nod*
18:05:00 <CalJohn> the mit press, prentice hall and oxford + cambridge, springer and so on are available
18:05:16 <CalJohn> i think addison-wes and oreilly are the only absent ones
18:07:10 <al23> I think AW and O'Reilly are not really about CS / math.
18:07:40 <byorgey> AW is.
18:08:07 <CalJohn> yes.  i don't care much though, because the university library covers them pretty thoroughly
18:08:07 <byorgey> they publish a bunch of math textbooks.  Also all of Knuth's stuff.
18:10:11 <Gracenotes> mooooooooooooooooooo
18:10:11 <pikhq> O'Reilly is about documentation.
18:10:19 <pikhq> Useful, but not all that CS-y.
18:11:05 <al23> byorgey: oops. You're right. But there is a lot of uninteresting stuff as well...
18:11:12 <byorgey> surely =)
18:12:08 <benmachine> ho hum. my threaded ncurses/network application is having results best described as "mixed"
18:12:36 <benmachine> @hoogle IO a -> IO b -> IO (Either a b)
18:12:36 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
18:12:36 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
18:12:36 <lambdabot> Text.Parsec.Prim runParserT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)
18:12:45 <benmachine> hm
18:12:56 <benmachine> .t
18:12:58 <gogonkt> now at #haskell
18:12:58 <benmachine> er
18:13:42 <benmachine> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3110#a3110 <-- I get a sense of deja vu after writing this, is it a library function?
18:13:49 <benmachine> if not, is it absolutely insane?
18:14:10 <benmachine> well, if so as well I suppose
18:14:37 <dolio> I don't recall seeing it, although conal's unamb is based on a similar primitive.
18:15:05 <benmachine> good enough for me, how about the latter?
18:16:00 <benmachine> readMVar is atomic, right? as in, I can't interrupt it between reading and writing
18:16:26 <dolio> That's sort of the point of MVars. :)
18:16:39 <benmachine> something's blocking and I don't know what
18:16:51 <benmachine> probably I'm not taking something I should
18:16:54 <MyCatVerbs> readMVar does getMVar then putMVar.
18:16:59 <MyCatVerbs> It's not atomic.
18:17:12 <dolio> Oh.
18:17:24 <benmachine> MyCatVerbs: so if I killed the thread in between the two, I'd have an empty MVar?
18:17:27 <MyCatVerbs> Er, at least I believe it does. I should check, though.
18:17:39 <dolio> Why not just use the one that just takes the value out?
18:18:03 <MyCatVerbs> In theory yes. Also, something else could putMVar between the getMVar and the putMVar, causing the putMVar to block. That would be a very amusing (and hard to trigger) race condition, though.
18:18:10 <benmachine> dolio: because if the left one wins I don't know whether the right one took the value out or not
18:18:22 <benmachine> well
18:18:25 <MyCatVerbs> If you have a reliable deadlock bug then it is unlikely to be anything so... arcane.
18:18:26 <benmachine> more to the point, I drop a value
18:18:57 <Philonous> readMVar blocks exceptions, so you can't just kill the thread, but what can happen is that some other thread writes the MVar in between, sou it can block
18:18:59 <dolio> I thought MVars block if they're full.
18:19:02 <benmachine> MyCatVerbs: mm, but I may as well fix an unreliable bug on my way to the reliable one
18:19:10 <dolio> When you try to put them, that is.
18:19:14 <Axman6> benmachine: yep
18:19:17 <dolio> And block on empty when tryint to take them.
18:19:28 * dolio hasn't used MVars much.
18:19:31 <benmachine> Philonous: ah, does that mean the thread-kill fails entirely?
18:19:35 <benmachine> dolio: sounds about right
18:19:43 <MyCatVerbs> benmachine: Or maybe you want to throw the design out the window and start again from Hoare's CSP. ;)
18:19:45 <benmachine> or is it just deferred until post-read
18:20:07 <copumpkin> another email from magicloud magiclouds!
18:20:08 <Philonous> benmachine: No, it just gets delayed until the readMVar finishes
18:20:13 <benmachine> this is all a bit messy
18:20:30 <benmachine> Philonous: okay
18:20:52 * benmachine biases the race so that right always wins
18:20:58 <Philonous> benmachine: Exceptions are guaranteed to be delivered, except when the thread is killed in the meantime
18:21:04 <MyCatVerbs> benmachine: IMO most of the time the issue stems from too-low-level primitives - locks instead of semaphores, semaphores instead of barriers, etc. There are lots of algorithms for which it's easier to implement higher level concurrency abstractions first, then work in terms of those, than to write straight off.
18:21:14 <sjanssen> Philonous: readMVar blocks, but takeMVar and putMVar implicitly unblock exceptions
18:21:31 <sjanssen> Philonous: ultimately meaning threads can be killed in a readMVar
18:21:38 <benmachine> hmm, maybe my block is nothing to do with any of it
18:22:12 <Philonous> sjanssen: oh, good to know.
18:22:51 <Philonous> sjanssen: Of course, otherwise there would be no way to kill a thread blocking on a takeMVar.
18:24:51 <sjanssen> Philonous: right.  Most operations that can delay indefinitely unblock exceptions
18:27:23 <Philonous> Though there really should be a primitive for reading MVars atomically without emptying them.
18:28:39 <sjanssen> Philonous: it could be achieved with two MVars (the real MVar and a mutex)
18:29:20 <Gaap> hi
18:29:51 <sjanssen> hello
18:30:06 <Gaap> how are u?
18:31:07 <benmachine> eternally confused
18:31:10 <Philonous> sjanssen: You'd have to rewrite all the primitives and one mutex is not enough to avoid race conditions, is it?
18:31:37 <Gaap> another geek room?
18:33:04 <byorgey> Gaap: the best!
18:33:52 <Gaap> offcourse
18:33:55 <sjanssen> Philonous: I think you could just guard all operations with take and put on the mutex, and appropriate 'finally' blocks to avoid exceptions
18:33:56 <Gaap> I am tthe best
18:34:08 <Gaap> byorgey
18:34:42 <sjanssen> Philonous: the mutex would prevent any other thread from putting the MVar while another thread is reading it
18:35:38 <Philonous> sjanssen: Right, I was thinking about regular shared variables without guarantees. just bracketing with putMVar and takeMVar should be enought
18:44:57 <x196b> Why doesn't   foldl' (liftM2 (+)) (Just 0) (repeat (Just 1)) run in constant space?
18:45:30 <Saizan> x196b: foldl on an infinite list will never return
18:45:35 <Saizan> x196b: you want foldr
18:45:48 <Gracenotes> also, foldl' only uses seq.. I think you need something more powerful
18:45:53 <copumpkin> well that one in particular will never return anyway
18:45:55 <sjanssen> x196b: you're only forcing the Maybe, not the number inside
18:46:03 <Gracenotes> ^^ this
18:46:13 <Gracenotes> like some rnf-ing or somelike
18:46:14 <Phyx> Saizan well.. you were right, using hsc2hs was much easier, and the resulting code isn't really that spectaculair :P
18:46:42 <Saizan> Phyx: are you sure that was for me?:)
18:47:03 <Saizan> copumpkin: true
18:47:36 <Gracenotes> > scanl (liftM2 (+)) (Just 0) (repeat (Just 1))
18:47:37 <lambdabot>   [Just 0,Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just...
18:47:55 <Phyx> Saizan i think so.... lol
18:48:51 <Gracenotes> those are some intermediate results, and the final result would be the "last" member of that infinite list.. which doesn't exist
18:50:03 * Phyx hates cryptic errors
18:51:03 <Gwern-away> :t map . map . map
18:51:06 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
18:51:18 <Gwern-away> @hoogle (a -> b) -> [[[a]]]
18:51:19 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
18:51:49 <Gwern-away> @hoogle (a -> b) -> [[a]]
18:51:50 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
18:51:50 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
18:51:50 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
18:52:43 <x196b> is there a concise way to force the number inside?
18:53:53 <Philonous> @hoogle rnf -- x196b reduce to (head) normal form
18:53:53 <lambdabot> Parse error:
18:53:53 <lambdabot>   --count=20 "rnf -- x196b reduce to (head) normal form"
18:53:53 <lambdabot>                  ^
18:53:58 <Philonous> @hoogle rnf
18:53:58 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
18:54:36 <mmorrow> , foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [0..1000000]
18:54:39 <lunabot>  Stack space overflow: current size 8388608 bytes.
18:54:39 <lunabot>  Use `+RTS -Ksize' to increase it.
18:54:44 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..1000000]
18:54:46 <lunabot>  (500000500000,500000500000)
18:57:49 <mmorrow> x196b: foldl' only forces the top-level
18:58:27 <mmorrow> x196b: which in your case in the Maybe constructor, not the (possible) number inside
18:58:33 <mmorrow> s/in/is/
18:59:10 <Gwern-away> @check \x -> sort x == sortBy (flip compare) x
18:59:11 <lambdabot>   "OK, passed 500 tests."
18:59:17 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..]
18:59:20 <monochrom> Perhaps foldl' is not general enough.
18:59:23 <lunabot>  Killed.
18:59:31 <mmorrow> constant space
18:59:52 <monochrom> Instead of calling seq, it should let you specify your favourite evaluation function.
19:00:28 <mmorrow> monochrom: hmm, that's an idea
19:00:57 <Saizan> seq is enough strictness to let you define as much evaluation you want in the folding function though
19:01:08 <mmorrow> yeah true
19:01:25 <melangeau> hey, newbie q
19:01:50 <Saizan> ask :)
19:01:56 <melangeau> trying to translate from ocaml, working thru the 99 qs
19:02:10 <melangeau> let f lst = case lst of { [] -> [] ; [_] -> [] ; [x,y] -> x ; x : xs -> f xs }
19:02:19 <melangeau> why does ghci expect [[]]?
19:02:49 <melangeau> sorry, [[a]]
19:02:59 <mmorrow> because you do
19:03:02 <mmorrow> [x,y] -> x
19:03:12 <Saizan> ?type let f lst = case lst of { [] -> [] ; [_] -> [] ; [x,y] -> x ; x : xs -> f xs } in f
19:03:13 <lambdabot> forall a. [[a]] -> [a]
19:03:30 <copumpkin> [x, y] -> x AND [] -> []
19:03:33 <monochrom> I guess liftM2 (+) is still too much thunk.
19:03:39 <mmorrow> yeah, what pumpkin said
19:03:44 <melangeau> ah
19:03:59 <melangeau> I see
19:04:17 <melangeau> ghci expects element but get list explicitly
19:04:21 <melangeau> so assumes x is list?
19:04:41 <mmorrow> melangeau: yeah, it has to since you're implying that "x" and "[]" have the same type
19:04:54 <melangeau> hmm
19:04:54 <jimmyjazz14> from the type def of Month seen here http://www.haskell.org/ghc/dist/current/docs/libraries/old-time/System-Time.html#t%3AMonth , how do I get an Integer for the month?
19:05:06 <x196b> looks like bang patterns did the trick
19:05:22 <Saizan> ?type fromEnum
19:05:23 <lambdabot> forall a. (Enum a) => a -> Int
19:05:28 <x196b> going to have to read up on Control.Parallel.Strategies
19:05:36 <Saizan> jimmyjazz14: with that ^^^
19:06:04 <mmorrow> ?type let f lst = case lst of { [] -> [] ; [_] -> [] ; [x,y] -> [x] ; x : xs -> f xs } in f
19:06:06 <lambdabot> forall a. [a] -> [a]
19:06:17 <jimmyjazz14> Saizan: ah I thought that might be it, thanks!
19:06:18 <Gwern-away> @src fromListWith
19:06:18 <lambdabot> Source not found. I feel much better now.
19:06:20 <melangeau> ah, ok
19:06:33 <x196b> thanks everyone
19:06:44 <melangeau> unit doesn't work for 'a, apparently
19:06:47 <melangeau> either
19:07:11 <Saizan> there's no 'a in haskell
19:07:20 <mmorrow> @type undefined
19:07:21 <lambdabot> forall a. a
19:07:23 <mmorrow> , undefined
19:07:25 <lunabot>  luna: Prelude.undefined
19:07:33 <melangeau> ok
19:07:38 <Saizan> [] is specifically the empty list
19:08:05 <Axman6> melangeau: what's 'a supposed to be?
19:08:18 <melangeau> from ocaml
19:08:25 <mmorrow> (i assumed "forall a. a" (?))
19:08:40 <melangeau> kinda 'not decided'
19:08:41 <melangeau> yet
19:08:54 <melangeau> as in, the type can be checked, but isn't already known
19:09:12 <melangeau> you'll have to forgive my fuzzy explanations
19:09:22 <melangeau> so
19:09:47 <Saizan> ah, i though the ' in front of a variable made it a type on which you can use equality and such
19:10:10 <melangeau> on paper it would be an alpha
19:10:18 <melangeau> conventionally
19:10:22 <melangeau> just a way to distinguish
19:10:33 <melangeau> from the char 'a', I guess
19:10:44 <monochrom> Generally, Haskell type a->b is OCaml type 'a->'b
19:10:57 <melangeau> ok
19:11:17 <copumpkin> what's the ' for in ocaml?
19:11:20 <monochrom> Another one: Haskell type MyType a -> b is OCaml type 'a MyType -> b
19:11:41 <mmorrow> copumpkin: sml (and ocaml i guess) tyvars are prefixed with '
19:11:46 <melangeau> http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html
19:11:51 <melangeau> ^ example use
19:11:59 <monochrom> Finally, it is OK in OCaml to use lower case for type names such as int, 'a list
19:12:12 <monochrom> (Since you already have ' for type variables.)
19:12:18 <blackh> By rights it should be camel case
19:12:50 <melangeau> monochrom: ty
19:13:27 * Saizan was totally wrong then
19:14:14 <melangeau> does anyone know where the list of haskell math problems is?
19:14:27 <melangeau> I've seen it but forgotten the name
19:14:49 <copumpkin> I haven't heard of it
19:14:58 <copumpkin> what kind of math problems?
19:14:58 <melangeau> hmm
19:15:15 <Gwern-away> euler
19:15:17 <mmorrow> (project euler you mean?)
19:15:22 <melangeau> that's it!
19:15:24 <melangeau> thx
19:15:34 <Axman6> it's hot haskell problems
19:15:38 <copumpkin> I'd like some "make your own dependent types in haskell" problems like those in ryan ingram's email to -cafe
19:15:40 <Axman6> it's programmig problems
19:15:44 <copumpkin> that's fun
19:16:10 <mmorrow> copumpkin: have you ever seen haskell code that cayenne produces? ;)
19:16:58 <copumpkin> mmorrow: nope :P not sure I want to?
19:16:58 <Gwern-away> @hoogle Map k a -> Map a k
19:16:59 <copumpkin> :P
19:16:59 <lambdabot> Data.Map mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
19:16:59 <lambdabot> Data.Map map :: (a -> b) -> Map k a -> Map k b
19:16:59 <lambdabot> Data.Map mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
19:17:28 <mmorrow> copumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=47
19:17:44 <mmorrow> copumpkin: (cast x = unsafeCoerce# x)
19:17:45 <Gwern-away> @hoogle (a -> a -> a) -> [(a, k)] -> Map.Map a k
19:17:46 <lambdabot> Parse error:
19:17:46 <lambdabot>   --count=20 "(a -> a -> a) -> [(a, k)] -> Map.Map a k"
19:17:46 <lambdabot>                                              ^
19:17:53 <Gwern-away> @hoogle (a -> a -> a) -> [(a, k)] -> Map a k
19:17:53 <lambdabot> Data.Map fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
19:17:53 <lambdabot> Data.Map fromAscListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
19:17:53 <lambdabot> Data.Array.Base accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
19:17:54 <copumpkin> mmorrow: hah
19:18:01 <mmorrow> :)
19:18:05 <copumpkin> mmorrow: I'm talking more about writing your own dependentish haskell :P
19:18:10 <copumpkin> like in the email
19:18:14 <Gwern-away> @hoogle (k -> k -> k) -> [(a, k)] -> Map a k
19:18:14 <lambdabot> Data.Map fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
19:18:14 <lambdabot> Data.Map fromAscListWith :: Eq k => (a -> a -> a) -> [(k, a)] -> Map k a
19:18:14 <lambdabot> Data.Array.Base accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
19:18:27 <Gwern-away> dammit that's not the same thing at all
19:19:26 <Saizan> what do you mean?
19:20:09 <Axman6> Gwern-away: ... it's exactly the same thing...
19:20:43 <copumpkin> mmorrow: (http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html)
19:20:50 <Gracenotes> one could also probably write (Ord k, Monoid k) => [(k, a)] -> Map k a
19:20:53 <Gwern-away> right now I have map swap . toList . fromListWith (+) on a [(Rational, v)
19:21:11 <Gracenotes> .. not like that would be terribly useful
19:21:29 <Gwern-away> I'd like to drop the swap, but I can't seem to get the + to be run on the *other* half of the tuple
19:21:34 <Gracenotes> oh wow, that was a forceful sneeze just now
19:21:40 <Gwern-away> so I could switch to (v, Rational)
19:36:17 <monochrom> Hmm, no HWN yet.
19:37:09 <mae> monochrom: i knows!
19:38:05 <Gwern-away> @hoogle Map.Map k (Set.Set v) ->  [(Rational, v)]
19:38:05 <lambdabot> Parse error:
19:38:05 <lambdabot>   --count=20 "Map.Map k (Set.Set v) ->  [(Rational, v)]"
19:38:05 <lambdabot>                 ^
19:38:13 <Gwern-away> @hoogle Map k (Set v) ->  [(Rational, v)]
19:38:14 <lambdabot> No results found
19:38:20 <Gwern-away> @hoogle Map k (Set v) ->  [v]
19:38:20 <lambdabot> No results found
19:42:20 <Gwern-away> @hoogle (a -> a -> a) -> [(k, a)] -> [(k, a)]
19:42:20 <lambdabot> Data.Array.Base accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
19:42:20 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
19:42:20 <lambdabot> Data.Array.Base unsafeAccum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(Int, e')] -> a i e
19:43:10 <Axman6> this is really cool: http://b4winckler.wordpress.com/2009/07/28/inverse-functions-in-haskell/
19:44:52 <monochrom> Oh, bisection.
20:10:24 <copumpkin> hmm, say I have a list of events with associated times at which they occurred... what's the quickest way from a list of events to a nice chart of time and rate of events
20:18:09 <Gwern-away> copumpkin: I'd say for a chart, sort the list by the time, and then recurse down the list with a chart-sideeffecting function; for the rate of events; do 'sum lst / length lst'?
20:18:50 <copumpkin> not sure of a nice way to draw in haskell... maybe I'll just use the gnuplot module
20:20:11 <x196b> gtk2hs?
20:21:28 <ivanm> copumpkin: the chart library
20:23:38 <copumpkin> oh that one's painful
20:23:56 <copumpkin> means installing gtk2hs
20:24:03 <ivanm> and?
20:24:07 <ivanm> what's so hard about that?
20:24:13 <copumpkin> it's painful on mac os
20:24:15 <vav> copumpkin: diagrams maybe. don't think that needs gtk2hs
20:24:38 <copumpkin> it requires cairo
20:24:56 <ivanm> ahhh, you're one of those mac-lovers...
20:25:02 <copumpkin> lol
20:26:57 <Nafai> Things are just much easier on Linux
20:28:25 <mmorrow> copumpkin: are you looking to do dynamically changing graphs that you view at runtime and then disappear, or do you want to make static images or something?
20:28:37 <copumpkin> just static
20:28:51 <mmorrow> ah. i'd just output the data to a file then
20:28:55 <mmorrow> x y z
20:28:57 <mmorrow> or something
20:29:00 <x196b> compiling gnome libraries is easier on linux anyway :P
20:29:01 <mmorrow> then use whatever
20:29:08 <mmorrow> (R makes really pretty graphs)
20:29:30 <mmorrow> but R also is painful unless you already know it (and even then it's still painful :)
20:29:55 <mmorrow> if R is out, then i'd just use gnuplot
20:30:15 <PeteG42> hello
20:30:19 <mmorrow> (and if gnuplot is out, then i'd use plotutils)
20:30:24 <PeteG42> does anyone have the keys to the haskell wiki?
20:30:28 <PeteG42> i'd like an account
20:30:33 * mmorrow wants one too
20:34:13 <mmorrow> copumpkin: blow your mind http://addictedtor.free.fr/graphiques/
20:34:19 <mmorrow> (R graphics)
20:37:05 <erikc> R is fun
20:38:14 <vav> http://www.flickr.com/photos/ethanhein/sets/72157603224965246 -- moar fun with beautymous data
20:39:14 <mmorrow> ooh nice
20:40:58 <Saizan> the voronoi tree maps are pretty :O
20:41:41 <vav> there's also a networks section in the Science and Math category with some more neat ones.
20:43:55 <mmorrow> haha http://www.flickr.com/photos/ethanhein/2441691520/in/set-72157603224965246/
20:44:15 <mmorrow> that's pretty funny
20:48:27 <mae> damn damn damn
20:48:31 <mae> i wish i could have gone to hac phi
20:48:33 <mae> damn the man
20:58:03 <tommd> mae: Where are you located?
21:00:50 <smartypants> Hello humans.
21:04:22 <gwern> @hpaste2
21:04:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:04:35 <gwern> @where hpaste2
21:04:35 <lambdabot> http://hpaste.org/
21:05:08 <mae> tommd: bakersfield, ca
21:05:19 <vav> gwern did you see the wiki account requests above?
21:05:22 <gwern> no
21:05:45 <vav> PeteG42 left already, and mmorrow
21:05:58 <PeteG42> back now though
21:06:00 <PeteG42> :-)
21:06:07 <PeteG42> gwern, i'll email you
21:08:32 <pikhq> EMACS IS NIGH!
21:09:15 <SamB> pikhq: yeah, I know, 23 is real soon now ...
21:09:23 <Apocalisp> Vim is nigher
21:09:24 <pikhq> :D
21:09:25 <SamB> but hasn't it been that way all summer?
21:09:36 <gwern> http://farm3.static.flickr.com/2637/3765805976_e7134e3521_o.png <-- argh, my englishey sense is tingling!
21:09:44 <SamB> Apocalisp: I betcha vim has releases a bit more often ;-P
21:14:54 <conal> @seen luqui
21:14:55 <lambdabot> I saw luqui leaving #haskell 6m 14d 22h 44m 13s ago, and .
21:15:00 <conal> wow
21:15:12 <conal> what's become of our luqui?
21:15:14 <gwern> who says lambdabot has no uptime? :)
21:16:07 <copumpkin> lol
21:16:18 <copumpkin> @seen wli
21:16:18 <lambdabot> wli is in #haskell-blah and #haskell. I don't know when wli last spoke.
21:17:40 <thoughtpolice> :(
21:21:58 <pikhq> SamB: Barring any calamities, it releases tomorrow.
21:22:36 <SamB_XP_> pikhq: I thought it was releasing calamities or not?
21:22:43 <SamB_XP_> personally, I think I may wish to wait for 23.2
21:23:38 <Trinithis> > fmap (+666) (1, 0)
21:23:39 <lambdabot>   (1,666)
21:23:41 <SamB_XP_> on the plus side, they will have no more excuses not to switch to bzr immediately after the release ;-P
21:23:53 <Trinithis> > fmap (+666) (1, 1, 0)
21:23:55 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t t1))
21:23:55 <lambdabot>    arising from a use of `GH...
21:25:10 <pikhq> Trinithis: Shouldn't be hard to make a functor instance for that, but "not hard" doesn't mean you should.
21:25:30 <copumpkin> make a trifunctor for it
21:25:38 <jmcarthur> ugh
21:25:39 <Trinithis> lol
21:25:54 <SamB_XP_> copumpkin: what are the methods called on TriFunctor?
21:26:06 <Vanadium> fffmap if they know anything
21:26:27 <SamB_XP_> oh, right ;-)
21:26:35 <copumpkin> instance Trifunctor (,,) where trimap :: (a -> b) -> (c -> d) -> (e -> f) -> (a, c, e) -> (b, d, f)
21:26:44 <Trinithis> fffmap f g h (a, b, c) == spiritual revelation
21:27:10 <dolio> False
21:27:11 <copumpkin> I guess that's a bit of a mix between instance and class :P
21:27:30 <copumpkin> trimap f g h (a, b, c) = (f a, g b, h c)
21:27:34 <Trinithis> it cant be false... its a fact
21:27:37 <dolio> True
21:27:51 <dolio> Oh, wait, that's just one =
21:28:12 * dolio fails at being lambdabot.
21:29:03 <SamB_XP_> > (a, b, c)
21:29:04 <lambdabot>   (a,b,c)
21:29:28 <SamB_XP_> > fffmap (+1) (+2) (+3) (a, b, c)
21:29:29 <lambdabot>   Not in scope: `fffmap'
21:31:01 <a_coder> are there any good haskell decompilers?
21:31:17 <dolio> Hah.
21:31:56 <Trinithis> you could use fffmap to decompile into haskell
21:32:12 <Trinithis> jk
21:32:21 <a_coder> do you normally decompile the .out or .hi?
21:32:49 <SamB_XP_> a_coder: we usually can't even understand the assembly code!
21:33:21 <a_coder> SamB_XP_, what do you mean by that
21:33:41 <pikhq> Have you *seen* the resulting assembly?
21:33:42 <SamB_XP_> a_coder: have you ever looked at any of it?
21:33:44 <pikhq> (or even the resulting C)
21:33:51 <a_coder> no why
21:34:04 <a_coder> what does it look like
21:34:13 <SamB_XP_> a_coder: it's hard to describe!
21:34:21 <pikhq> Particularly good Malbolge.
21:34:43 <a_coder> does that mean you can't decompile it?
21:34:45 <SamB_XP_> I think unlambda is easier to read
21:35:01 <SamB_XP_> a_coder: well, we don't care to try
21:35:37 <SamB_XP_> it's not like anyone distributes Haskell libraries in binary form or anything!
21:36:22 <pikhq> Lets just say that closures in assembly are not the easiest thing to understand.
21:36:38 <jfoutz> how do i tell cabal-install to pass -pgml ld_classic to ghc?
21:36:39 <SamB_XP_> I would vastly prefer to write an ELisp decompiler ;-)
21:36:49 <SamB_XP_> it would probably even be more useful
21:37:14 <SamB_XP_> jfoutz: did you installed gold?
21:37:17 <SamB_XP_> and it's not working?
21:37:34 <jfoutz> i was trying to get SDL working
21:37:36 <Vanadium> If I had a decompiler spitting out haskell code, I would probably just write everything in C and have the decompiler do the work for me instead of actually learning haskell
21:37:52 <jfoutz> ... installed gold?
21:37:57 <SamB_XP_> Vanadium: wouldn't that be more work?
21:38:02 <a_coder> haskell.. compiles to c?
21:38:13 <dolio> Some compilers do.
21:38:16 <SamB_XP_> jfoutz: the new LD
21:38:33 <Vanadium> SamB_XP_: Haskell is hard to read!
21:38:41 <mae> does anyone have an opinion of greencard? :)
21:38:57 <SamB_XP_> mae: I forget!
21:39:06 <SamB_XP_> mae: does it still work?
21:39:24 <a_coder> what do the .hi files do?
21:39:52 <SamB_XP_> a_coder: they tell GHC about types and inlinings
21:40:11 <SamB_XP_> and calling conventions
21:40:26 <a_coder> ok
21:42:00 * pikhq observes that GHC does not make small binaries
21:42:37 <SamB_XP_> pikhq: linking all of the used library modules into the binary directly will do that ;-)
21:43:04 <Vanadium> I am having a hard time figuring out how indentation works. Is there a neat summary somewhere?
21:43:50 <pikhq> SamB_XP_: So I'd imagine.
21:43:58 <pikhq> Isn't this why man invented dynamic linking? :P
21:44:08 <a_coder> how do infinite lists and stuff unique to haskell compile to C?
21:44:17 <pikhq> a_coder: Crazily.
21:44:37 <dolio> @go offside rule haskell
21:44:38 <lambdabot> http://en.wikipedia.org/wiki/Off-side_rule
21:44:38 <lambdabot> Title: Off-side rule - Wikipedia, the free encyclopedia
21:44:39 <jfoutz> SamB_XP_: it's the apple linker. i was getting a bunch of "atom sorting error for...blah" when linking. poking around, it looks like the default linker dosn't support -read_only_relocs ... not sure exactly how cabal-install is calling the SDL compile though.
21:44:44 <cjs> pikhq: Also, keep in mind that there's a full thread-enabled runtime included as well.
21:44:54 <SamB_XP_> dolio: isn't that name ancient and outmoded??
21:44:55 <pikhq> cjs: Ah, yeah.
21:45:11 <jfoutz> SamB_XP_: so i don't know if that's relavant. seemed like it was worth trying the classic linker though.
21:45:33 <cjs> However, what's-their-faces are doing work to get dynamic linking working properly, which I think may include dynamically linking the runtime, too. That would bring ghc's binaries down to something more competitive with C.
21:45:44 <dolio> I don't know. Is it?
21:46:34 <SamB_XP_> dolio: I thought it was called the "layout rule" now?
21:47:15 <dolio> "Layout" is the word people use for indentation-specific syntax, I guess.
21:47:46 <dolio> "Off-side rule" is the name for a certain sort of layout, I'd say, probably.
21:48:23 <dolio> Although it's difficult to think of a sort that wouldn't qualify, since indentation seems pretty natural.
21:50:37 <Vanadium> I feel smarter now. Thank you.
21:55:29 <dolio> Or maybe, layout is a set of rules for how indentation figures into syntax, and the off-side rule is one such rule.
21:55:36 <dolio> Something along those lines.
21:56:37 <Berengal> I'm helping someone understand lazyness and how a lazy language can help you the programmer be lazy. I think I already can hear the creaking as his mind bends, and it's just a matter of time until *snap* it's broken
22:00:49 <cjs> Off-side rule? I thought that was for football.
22:01:21 <dolio> That's why I had to include the word "haskell" in the search.
22:01:44 <cjs> So, can anybody think of some clever way that I could tweak a Haskell program that reads data files to, more or less transparently, be able to read gzipped versions of those files as well, without changing how the rest of the program uses its handles?
22:01:45 <dolio> Apparently google thinks football is more popular than haskell.
22:01:53 <Trinithis> fail
22:02:03 <Trinithis> google should be a monad
22:02:14 <cjs> Try wikipedia.
22:02:38 <sjanssen> cjs: I don't see a convenient way if you insist on using Handle
22:02:57 <cjs> Darn. I was hoping that that wasn't the case.
22:03:20 <cjs> That's one of the nice things about OO languages; you can usually just substitute a subclass in this sort of case.
22:03:24 <sjanssen> of course you could do crazy stuff like forking a process that unzips and writes to a pipe
22:03:49 <cjs> I think I'd rather just modify ghc's libraries, frankly.
22:04:10 <kfish> cjs, does the rest of the program use IO randomly, or does it just eg. operate on a ByteString ?
22:04:13 <sjanssen> would it really be so hard for your code to use a layer of abstraction?
22:04:20 <cjs> Mostly on just ByteString.
22:04:54 <dolio> If it's on bytestrings, then you can use zlib.
22:05:20 <cjs> sjanssen: Probably not all that hard, but it's a reasonable amount of work. I read and write a reasonable number of different files.
22:07:32 <cjs> Hm. And not only would I have to put a layer between everything that reads and writes files, but also then do my own buffering; most of my files are read as blocks of various lengths.
22:07:53 <cjs> Oh, wait, I could use zlib on a lazy ByteString.
22:08:02 <cjs> So nobody's written a library to do this, eh?
22:08:10 <dolio> It's called zlib.
22:08:13 <kfish> http://hackage.haskell.org/packages/archive/zlib/0.5.0.0/doc/html/Codec-Compression-Zlib.html
22:08:15 <dolio> @hackage zlib
22:08:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
22:08:50 <mae_phone> I think you could also use zlib to open a handle with implicit compression added as a filter
22:09:21 <dolio> Well, with the C zlib, maybe. Not with that haskell one.
22:09:39 <mae_phone> you could write the ffi call ;)
22:09:45 <dolio> Yeah.
22:11:06 <mae_phone> Sorry my head has been swirling in posix land for the last few weeks
22:11:11 <cjs> Yeah, that zlib feature is in a lot of the scripting language zlibs; that's exactly what I was looking for.
22:16:05 <jfoutz> you could do a socketpair and turn the read side into a handle
22:19:49 <cjs> Hm. That's probably not so great for performance, though.
22:21:30 * jfoutz ponders the speed of kernel memory
22:22:27 <gwern> hey, you know how if you repeat a word to yourself enough times it turns into gibberish noise?
22:22:30 <mae_phone> man the people on ##c right now are bickering over the diff between int *a and int a[2].. Oh so dry...
22:22:32 <gwern> turns out it's called [[Semantic satiation]]
22:22:39 <gwern> true fact!
22:22:51 <jfoutz> mae_phone: ask them about 2[a]
22:23:36 <shepheb> so apparently convertible-1.0.5 is broken on Windows because UTCTime and POSIXTime don't have Typeable instances
22:23:41 <SamB_XP_> jfoutz: I'm pretty sure that "int 2[a];" isn't a valid declaration
22:23:49 <shepheb> that means HDBC is broken on Windows, and also that I am sad.
22:24:16 <SamB_XP_> shepheb: report a GHC bug?
22:25:21 <jfoutz> ah, right. i totally skipped over the declarations and read it as derefs.
22:25:47 <shepheb> SamB_XP_: long-term sure. short-term I'm going with locally tweaking the convertible source to include a fix, I'm building a standalone binary.
22:26:14 <shepheb> but I don't know how to write a Typeable instance, and I can't find any actual definitions of them that aren't macros in Data/Typeable.hs itself.
22:26:26 <mae_phone> I thought c## people would be smart, instead I think now that c is the new assembly, and thes people are baremetal freaks ;)
22:26:45 <SamB_XP_> shepheb: you should be able to use those macros
22:26:56 <SamB_XP_> shepheb: but I won't guarentee that you'll be able to
22:27:26 <shepheb> can one Hoogle for instances?
22:27:38 <tommd> @hoogle Binary
22:27:38 <lambdabot> package binary
22:27:38 <lambdabot> package binary-search
22:27:38 <lambdabot> package binary-strict
22:27:49 <shepheb> I mean, somewhere someone implemented a Typeable instance for those types
22:27:53 <tommd> @hoogle Num
22:27:54 <lambdabot> Prelude class (Eq a, Show a) => Num a
22:27:54 <lambdabot> package numbers
22:27:54 <lambdabot> Data.Array.Base numElements :: (IArray a e, Ix i) => a i e -> Int
22:29:24 <SamB_XP_> shepheb: you want something like typeOf a = tyConApp (mkTyCon "Path.To.Module.Type") []
22:29:50 <vav> shepheb: I think it's actually that the time constraint in cabal file is wrong, needs newer dependency. iirc someone on linux had same problem recently
22:30:18 <SamB_XP_> vav: oh!
22:30:34 <SamB_XP_> man, there are so many people around here I don't know :-(
22:30:48 <vav> i.e. newer time has Typeable instances
22:31:27 <shepheb> vav: \o/
22:31:40 <shepheb> I tweaked the .cabal to require time >= 1.1.4 and it worked
22:32:24 <shepheb> vav: was the bug reported to John Goerzen?
22:32:41 <vav> probably not
22:33:05 <glguy_> are there any functions in a library on hackage somewhere for finding an elements multiplicative order?
22:33:19 <glguy_> (of modulo *n*)
22:34:38 <jmcarthur> i think the biggest problem with expressing algorithms in haskell is if you know how you would write the same algorithm in an imperative language
22:35:04 <jmcarthur> it makes it harder to find the actual concepts behind the algorithm and express them directly
22:35:28 <jmcarthur> i think this every time i see some algorithm that a beginner translated from C
22:38:11 <mae> yep
22:38:46 <mae> although map and filter were a no brainer for me to dump any forms of manual iteration
22:38:53 <mae> esp coming from ruby
22:39:08 <mae> its like trading in your hand plow for a skip loader
22:39:16 <copumpkin> but if you get to scanl
22:39:18 <mae> gee, that will make my job easier
22:39:28 <copumpkin> they're slightly more involved forms of recursion
22:39:58 <copumpkin> does scanl correspond to one of edwardk's fancy *morphism words?
22:40:52 <cjs> Hm. What sorts of things does one use scanl for?
22:41:10 <copumpkin> > scanl1 (+) [1,3..]
22:41:11 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
22:41:26 <copumpkin> scanl (+) a [b, c, d] :: [Expr]
22:41:33 <copumpkin> > scanl (+) a [b, c, d] :: [Expr]
22:41:34 <lambdabot>   [a,a + b,a + b + c,a + b + c + d]
22:42:18 <cjs> I know how it works, I'm wondering about a real-life usage example. I.e., why do you need that list of numbers?
22:43:21 <mae> cjs: i was wondering the same thing
22:43:33 <vav> cjs: one example from an xmonad layout is `ys = map ((height -) . subtract hoffset) . scanl1 (+) . map (hsingle +) $ hs'
22:43:35 <Berengal> I've used it, but I can't remember what for...
22:43:44 <mae> the irony is that usually you don't have the epiphany of going "oh yeah i could have used x" until way after you have implemented your working, production-ready code :)
22:44:55 <cjs> vav: Ah. Cool.
22:45:47 <Gilly> Can anyone recommend good texts on Internet about Category theory and its application to functional programming?
22:48:02 <Berengal> hylo = cata . ana, right?
22:48:33 <dolio> Cale: What's the link to Awodey's Category Theory?
22:48:40 <dolio> Berengal: Yes.
22:48:43 <Gracenotes> as it applies to functional programming, the categories tend to be of types..
22:48:54 <Berengal> So what's ana . cata ?
22:49:56 <copumpkin> Berengal: meta I think?
22:49:57 <copumpkin> or para?
22:50:02 <copumpkin> something like that
22:50:04 <copumpkin> :P
22:50:58 <Berengal> From edwardk's homepage, it's meta.
22:51:02 <Berengal> I need to learn this stuff...
22:52:39 <dolio> I think there's more than one meta in the literature.
22:52:44 <dolio> People weren't communicating. :)
22:53:06 <Berengal> Yeah, there were two metas on his page, one of them looked like ana . cata
22:53:15 <dolio> Yeah, that's definitely one.
22:53:17 <drbean> http://www.andrew.cmu.edu/user/awodey/
22:53:21 <dolio> I don't remember what hte other is.
22:53:43 <Berengal> Would something like 'toArray . Map.toList' be a metamorphism?
22:54:05 <dolio> drbean: Does that have a free download of his book? It didn't look promising to me.
22:54:08 <dolio> You can get it somewhere.
22:57:12 <dolio> Anyhow, that book's better for basics.
22:57:38 <dolio> Once you get some of it under your belt, Basic Category Theory for Computer Scientists explains in the latter parts some of the connection with functional programming.
22:57:54 <dolio> And it's relatively cheap.
22:58:32 <cjs> So we were talking about vampires earlier, but nobody seems to talk about werewolves on this channel.
22:58:43 <cjs> Is that due to the metamorphism restriction?
22:58:54 <copumpkin> :o
22:58:59 <blackdog> play him off, keyboard cat.
23:00:19 <dcolish> not sure if this is the right channel, but does anyone else have issues in ghci with emacs history (C-p, C-n) bindings?
23:00:39 <cjs> Are you using 10.2 or 10.3?
23:00:45 <cjs> (And yes, this is the right channel.)
23:00:49 <dcolish> 10.3
23:01:01 <cjs> Ah. Switch back to 10.2, and file bug reports about Haskelline.
23:01:06 <dolio> Yeah, they don't seem to work with the new haskelline stuff.
23:01:36 <cjs> 10.2 used readline; 10.3 uses Haskeline. The author is quite responsive; I've gotten a whole bunch of vi mode fixes in for the next release.
23:01:37 <dcolish> k, i tried to rebind the commands anyway and it still failed
23:02:02 <cjs> In the meantime, you might just want to switch back to 10.2; there weren't any other significant changes that I recall.
23:02:31 <dcolish> sure thats easy enough, i just pulled in the package from arch
23:02:50 <dolio> They're still gone in 6.10.4, too.
23:03:14 <cjs> Speaking of metaporphism, this is pretty cool: http://web.engr.oregonstate.edu/~erwig/meta/
23:04:53 <hackagebot> np-extras 0.2 - NumericPrelude extras (BrentYorgey)
23:06:53 <troutwine> I'm attempting an implementation of an Expression Problem solution, but I'm in a bit over my head. Can someone set me on the right course? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7708#a7708
23:06:54 <hackagebot> species 0.2 - Computational combinatorial species (BrentYorgey)
23:11:58 <byorgey> troutwine: (:+:) needs to be higher-order. right now what you have is isomorphic to Either, but it needs to express the sum of two type constructors, rather than two types
23:12:12 <byorgey> i.e. it should be  data (f :+: g) a = Inl (f a) | Inr (g a)
23:13:21 <troutwine> Ah, thanks byorgey. (Heh, I understood that. Lovely.)
23:13:36 <byorgey> good =)
23:24:09 <dcolish> dolio: i got the rebindings sorted and it works fine on 10.4
23:24:21 <dcolish> in fact there is nothing in the defaults under the wiki that claim they would work
23:26:34 <dolio> Oh, nice. I'll have to fool with it.
23:26:58 <ceal> http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=3112#a3112
23:27:14 <ceal> how can i take such an input and store it as a list?
23:27:46 <dcolish> dolio: although honestly, if you claim emacs keybindings you need to support ^p ^n
23:28:46 <dcolish> where do i file a bug/feature ?
23:29:08 * dcolish realizes the lmgtfyness of the question
23:30:15 <wmealing_> not always a dumb question, quite often it depends on the source of the bug, and who is paying attention.
23:30:59 <dcolish> well i guess its a requirements/spec bug not really an impementation bug
23:31:20 <wmealing_> I have just briefly looked into it, but not sure the state of the various requirements for the question but wondering if someone else did.
23:31:55 <wmealing_> haskell on android (which isnt java, but is the dalvik vm, java like in syntax), which implementation would be the best to start looking at.
23:32:00 <dcolish> oh looks like its ticket #95
23:32:53 <wmealing_> I was thinking something like http://www.haskell.org/pipermail/glasgow-haskell-users/2001-December/002740.html  could be nice too
23:34:25 <dcolish> sorry thought you were talking to me before
23:35:04 <wmealing_> dcolish, i was.
23:37:27 <wmealing_> its ok, i am mid investigation.
23:37:37 <wmealing_> so my thought process probably was not so clear.
23:38:37 <dcolish> no worries
23:39:15 <dcolish> fwiw, that jvm bridge is kinda old
23:40:52 <kyagrd> How do I terminate a process without making it a zombie? I'm using System.Process and even if I terminate the process with terminateProcess in ghci, I can still see them with ps command in Z+ defunct state.
23:41:18 <kyagrd> They only go away when I exit ghci.
23:41:57 <glguy_> you clean up zombies by "wait"ing on them
23:45:48 <tommd> kyagrd: Kenny?
23:46:32 <kyagrd> tommd: I'm http://kyagrd.dyndns.org/
23:47:16 <tommd> Oh, well - hello there!
23:47:36 <kyagrd> glguy_: Thanks, terminateProcess doesn't clean up ... even if I terminated I should wait hmm
23:50:39 <mmorrow> kyagrd: terminateProcess is iirc not (kill -KILL), but (kill -"< 9") for some reason
23:50:56 <mmorrow> (i don't recall exactly what sig it sends, just that it's not -9)
23:51:26 <mmorrow> this caused problems (was this ever fixed/worked around?) in lambdabot for example
23:51:44 <mmorrow> > fix id
23:51:48 <mmorrow> caused a zombie
23:51:49 <lambdabot>   mueval-core: Prelude.read: no parse
23:51:49 <lambdabot>  mueval: ExitFailure 1
23:52:24 <kyagrd> @t fix
23:52:24 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:52:27 * mmorrow wonders if there's a zombie spinning away now..
23:52:39 <mmorrow> @type fix
23:52:41 <lambdabot> forall a. (a -> a) -> a
23:52:49 <mmorrow> @type let fix f = let x = f x in x in fix
23:52:51 <lambdabot> forall t. (t -> t) -> t
23:53:30 <kyagrd> @where fix
23:53:30 <lambdabot> I know nothing about fix.
23:53:38 <mmorrow> Data.Function
23:53:43 <Berengal> > text "braaaains"
23:53:45 <lambdabot>   braaaains
23:54:01 <kyagrd> oh, I always get confused with lambdabot command
23:54:02 <kyagrd> @help
23:54:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:54:10 <Berengal> @src fix
23:54:10 <lambdabot> fix f = let x = f x in x
23:54:13 <mmorrow> @hoogle fix
23:54:14 <lambdabot> Data.Function fix :: (a -> a) -> a
23:54:14 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
23:54:14 <lambdabot> module Control.Monad.Fix
23:54:22 <kyagrd> @list
23:54:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:54:39 <mmorrow> why does mtl insist on re-exporting the entire std lib?
23:55:09 <Berengal> Why do we have more than one transformer library at all?
23:55:09 <kyagrd> It's also annoying that mtl clashes with transformers library
23:55:23 <dolio> fix was in Control.Monad.Fix before it was anywhere else.
23:56:24 <jeffwheeler> @help should just link to the COMMANDS page; no point in the extra command
23:56:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:56:51 <kyagrd> @help help
23:56:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:57:06 <jeffwheeler> @help list
23:57:07 <lambdabot> list [module|command]
23:57:07 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
23:57:16 <jeffwheeler> @help pl
23:57:16 <lambdabot> pointless <expr>. Play with pointfree code.
23:57:46 <dcolish> wmealing_: http://docs.codehaus.org/display/JASKELL/Home these guys did jruby as well
23:58:03 <mmorrow> dolio: ok. but that's not the only thing it re-exports..
23:58:06 <mmorrow> :)
23:58:33 <jeffwheeler> Haskell is a scripting language?
23:58:52 <dcolish> no jaskell is, i guess they dropped the ball a little on this one
23:59:27 <kyagrd> jeffwheeler: Well, the word for calling haskell source file is haskell "script".
23:59:55 <kyagrd> I don't know why but Haskell books seem to use that word.
