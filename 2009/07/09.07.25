00:00:26 <Ytinasni> adu: the "digits of pi" versioning system?
00:00:44 <adu> Ytinasni: yeah.... makes for really long versions tho
00:02:46 <jeffwheeler> Hey, the 'unsubscribe' feature in Gmail works with the Haskell mailing lists. Neat. (Not that I am, I just wanted to find the feature.)
00:02:56 <ivanm> adu: doesn't metapost use e?
00:03:01 <JamesSanders> I am using readFile to get the contents of a file but for some odd reason I occationally get "openFile: resource busy (file is locked)"
00:03:13 <JamesSanders> when trying to read or write to the same file
00:03:13 <adu> ivanm: you mean metafont?
00:03:20 <ivanm> jeffwheeler: how did you really test it? by unsubscribing and then re-subscribing? :p
00:03:21 <ivanm> adu: yeah
00:03:34 <jeffwheeler> ivanm: no, by observing that the feature appeared for that list :P
00:03:43 <jeffwheeler> ivanm: I didn't test it so much as find it :P
00:04:01 <ivanm> heh
00:04:08 <ivanm> so you don't actually know if it works or not? :p
00:04:10 <jeffwheeler> Apparently it works based on some mail headers.
00:04:19 <jeffwheeler> ivanm: no, you're right
00:04:58 <jeffwheeler> On a side note, I think it'd be awesome to install Haskell in this: http://en.wikipedia.org/wiki/Microsoft_Windows_Services_for_UNIX
00:11:05 <kyagrd> ray: thanks
00:20:15 <Saizan> JamesSanders: that can happen if you don't read the whole file before starting to write, since the handle won't be closed
00:20:53 <Saizan> JamesSanders: readFile is quite peculiar since it uses lazy IO
00:22:07 <Saizan> JamesSanders: if you can afford to read the whole file in memory at once it might be easier to use Data.ByteString.readFile with Data.ByteString.Char8.unpack
00:22:27 <Saizan> ?type fmap Data.ByteString.Char8.unpack .  Data.ByteString.readFile
00:22:28 <lambdabot> FilePath -> IO [Char]
00:26:15 <gwern> :t log
00:26:16 <lambdabot> forall a. (Floating a) => a -> a
00:26:28 <gwern> hm. is that log2 or log10?
00:26:32 <gwern> > log 100
00:26:33 <lambdabot>   4.605170185988092
00:26:48 <elbar> > log 10
00:26:49 <lambdabot>   2.302585092994046
00:27:16 <Saizan> > log (exp 1)
00:27:17 <lambdabot>   1.0
00:28:03 <elbar> aka ln ;)
00:28:24 <Saizan> @check \x -> log (exp x) == (x :: Double)
00:28:25 <lambdabot>   "Falsifiable, after 14 tests:\n0.25\n"
00:28:41 <Saizan> > log (exp 0.25)
00:28:42 <lambdabot>   0.24999999999999992
00:28:48 <Saizan> booh
00:30:17 <gwern> darn these finite machines we must work on!
00:32:16 <Saizan> > 0.25
00:32:18 <lambdabot>   0.25
00:32:47 <Saizan> ii guess exp 0.25 is not exactly representable
00:33:00 <Saizan> > exp 0.25
00:33:01 <lambdabot>   1.2840254166877414
00:33:31 <gwern> @check \x -> log (exp x) == (x :: CReal)
00:33:32 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary Data.Number.CReal.CReal)
00:33:32 <lambdabot>    aris...
00:34:11 <gwern> hm. I suppose that does make sense...
00:34:35 <gwern> > let x = 0.25 :: CReal in log (exp x) == x
00:34:36 <lambdabot>   True
00:34:55 <gwern> > let x = 0.0001 :: CReal in log (exp x) == x
00:34:57 <lambdabot>   True
00:35:10 <gwern> I should look at how CReal is implemented sometime
00:35:10 <Saizan> > log 1.2840254166877416
00:35:11 <lambdabot>   0.2500000000000001
00:35:16 <gwern> @quote CReal
00:35:16 <lambdabot> gwern says: *ponders Haskell nerdcore: 'I'm all about exact math, yo; I eat CReal for breakfast'*
00:35:23 <Saizan> > log 1.2840254166877415
00:35:24 <lambdabot>   0.24999999999999992
00:35:30 * adu <3 math
00:43:42 <koala_man> which library can I use to load and save images, and scale/crop/rotate/compose them?
00:49:22 <Saizan> koala_man: the imagemagick bindings?
00:53:07 <koala_man> Saizan: where do I get those?
01:17:24 <Berengal> Type classes are actually quite nifty
01:17:47 <Oejet> koala_man: What file types are you interested in?
01:21:41 <Saizan_> koala_man: on hackage
01:22:06 <Saizan_> koala_man: http://hackage.haskell.org/package/hsmagick
01:28:31 <koala_man> thanks
01:56:31 <thomastc> with GHC, is it possible to compile a single module, without also compiling its dependencies? like C, basically?
01:56:41 <thomastc> I would think not, type inference and all
01:56:42 <pejo> thomastc, -c
01:56:46 <thomastc> but just want to make sure
01:57:02 <thomastc> pejo: that requires that the dependencies already have .hi files
01:58:41 <pejo> thomastc, ok, in that case I don't know.
01:59:11 <thomastc> reason I'm asking, I was wondering if Haskell builds can be done in parallel
01:59:38 <thomastc> having a shiny new quadcore machine ;)
02:02:11 <pejo> thomastc, is there a specific package you want to build in parallel, or is this for your own projects?
02:02:47 <pejo> Because most projects are either small enough to not be worth parallelising or you can locate leaves in the dependency tree that you can compile concurrently.
02:03:09 <gwern> thomastc: not yet
02:03:21 <gwern> the parallel make is supposed to make it into cabal this year, I hear
02:04:46 <thomastc> pejo: it's for a build system actually... but mostly out of curiosity, not really for implementing
02:08:10 <Oejet> thomastc: Perhaps you can use the -M option?
02:10:46 <thomastc> Oejet: oh, that looks useful, thanks!
02:27:33 * ManateeLazyCat pasted "my code" at http://paste2.org/get/341398
02:27:38 <ManateeLazyCat> In above code, "forall a b . (PageBuffer a, PageMode b) => " is right code? Thanks!
02:28:47 <Saizan> ManateeLazyCat: you need to enable ExistentialQuantification for that
02:28:55 <hackagebot> network-multicast 0.0.5 - Simple multicast library (AudreyTang)
02:29:37 <ManateeLazyCat> Saizan: I have do that.
02:29:45 <ManateeLazyCat> Saizan: But i occur another problem.
02:30:10 <Saizan> ManateeLazyCat: do you know how existential types work?
02:31:17 <ManateeLazyCat> Saizan: I have function like this "pageApplyBuffer :: (forall a . PageBuffer a => a -> b) -> Page -> b", but when i run "  pBuffer <- pageApplyBuffer (\x -> do pb <- pageBufferClone x return pb) page" , I got error "Inferred type is less polymorphic than expected Quantified type variable `a' escapes"
02:33:00 <Saizan> ManateeLazyCat: what's the type of pageBufferClone?
02:33:20 <ManateeLazyCat> pageBufferClone                     :: a -> IO a
02:33:51 * ManateeLazyCat pasted "PageBuffer" at http://paste2.org/get/341400
02:33:54 <Saizan> that's your problem
02:33:59 <ManateeLazyCat> Saizan: Above is my PageBuffer.hs
02:34:28 <Saizan> the function you pass to pageApplyBuffer can't have the 'a' type in its result
02:34:39 <Saizan> otherwise the existential leaks
02:36:27 <Saizan> you've to wrap that pb into another existential type
02:36:50 <Ytinasni> perhaps the type you want is this?  pageApplyBuffer :: PageBuffer a => (a -> b) -> Page -> b
02:37:21 <Ytinasni> it doesn't look like you actually use the existential.
02:37:38 <Saizan> Ytinasni: see the Page definition
02:37:59 <ManateeLazyCat> Ytinasni: I must use `forall`
02:38:14 * ManateeLazyCat pasted "Page define" at http://paste2.org/get/341404
02:40:31 <ManateeLazyCat> Saizan: I can't understand "you've to wrap that pb into another existential type"?
02:41:34 <Ytinasni> you can't return an `IO a` where a is `forall a . PageBuffer a`
02:42:20 <Saizan> ManateeLazyCat: you can define a type like data AnyPageBuffer = forall a. PageBuffer a => AnyPB a
02:42:27 <Ytinasni> you need a specific type - data Wrap = (forall a . PageBuffer a) => Wrap a
02:42:34 <Saizan> ManateeLazyCat: and return AnyPB pb instead of just pb
02:43:45 <Saizan> or you can pattern match on Page at the start of the function definition here and let the existentially quantified variable scope over the whole body
02:56:59 <ManateeLazyCat> Thanks all for help! I need brb for understand above.
03:07:13 <yar_> is hsw still maintained?
03:07:17 <yar_> hws
03:07:32 <yar_> seems quite cool attack on the web problem
03:27:18 <augustss> woo woo!  I built a Haskell app (not my own yet) and downloaded to the iPhone.
03:29:08 <Saizan> woo :O
03:30:00 <Axman6> augustss: impressions?
03:30:36 <augustss> Signing up for iPhone development and dealing with certificates etc was the hardest part.
03:31:47 <augustss> And figuring out how to replace Stephen Blackheath's developer id and provisioning with my own in his app so I could download it.
03:33:08 <Axman6> heh, nice
03:34:29 <ivanm> @seen byorgey
03:34:30 <lambdabot> I saw byorgey leaving #haskell-hacphi 6h 50m 8s ago, and .
03:39:28 <Heffalump> would a Haskell app ever be accepted in the app store?
03:40:35 <Saizan> Heffalump: why not?
03:40:50 <Heffalump> I thought they all had to be Obj-C
03:41:08 <nvoorhies> They have rules against running interpreters that can accept arbitrary code, but they don't really care about the implementation language
03:41:30 <Heffalump> ah, ok
03:41:47 <ivanm> Heffalump: of course, there might be some completely arbitrary reason why they don't allow it...
03:41:50 <nvoorhies> they just look at the binary and what it links against (to check for api forward compat) and make sure it can't run arbitrary other code, basically
03:41:52 <ivanm> or allow it and then pull it...
03:41:54 <ivanm> ;-)
03:42:05 <ivanm> nvoorhies: and other random rules? ;p
03:42:28 <nvoorhies> They're not all that random, in my experience, but I've heard horror stories
03:43:05 * ivanm hasn't had anything to do with the app store except read about horror stories
03:43:28 <ivanm> well, that and wonder wtf is with all these random people suddenly developing all these random applications, and the stupid people that fork over their money for them :s
03:43:57 <nvoorhies> They generally try to keep anything off there that would confuse people UI-wise and so on, along with things that do dangerous things security wise or link to undocumented apis, etc
03:44:15 <nvoorhies> and the big variable seems to be how easily confused the reviewer is
03:45:26 <nvoorhies> For me at least, I'm willing to toss half a cup of coffee's worth of money at some people that created a cool game or something somewhat useful
03:45:40 <ivanm> nvoorhies: a "farting" app? really?
03:46:12 <nvoorhies> I've never bought a farting app, but I can see the rationale for paying 99 cents to play a prank on a friend
03:46:40 <nvoorhies> and half a cup of coffee times a few million potential pranksters pays for a lot of coffee
03:47:34 <nvoorhies> I think the dynamics of how the things achieve visibility tends to cater to a small number of big sellers at any given time too
03:48:29 <ivanm> nvoorhies: I've read that some developers are pissed because their apps get rejected, possibly because some people keep releasing new ones to make sure they're on the front page, thus creating too many apps for reviewers to check in time
03:48:35 <nvoorhies> since there's almost no effort to find one of the top 25 sellers, and a lot more to find something that's not too popular in a category
03:49:09 <nvoorhies> Yeah, I don't blame them.  The lag time is a week at best
03:49:54 <nvoorhies> I'm kinda curious why they don't hire an army of art students to vett the things within a couple days of submission
03:50:29 <nvoorhies> since it seems like the more new apps come in, the more money they're likely to make
03:51:05 <ivanm> heh
03:51:22 <kynky> new users helps too, but things are bad when spammed with too much useless stuff
03:51:24 <Saizan> maybe they are afraid of making too much money
03:51:34 <Heffalump> because art students are clueless about the actual operation of computers? (gross generalisation)
03:51:55 <nvoorhies> Well, art students would do an a-ok job at testing for confusing UIs I bet
03:52:08 <Heffalump> sure
03:52:13 <nvoorhies> and the sorta layout rules-ish things apple cares about.  The look and feel and whatever
03:52:16 <Heffalump> but that's only half the job
03:52:36 <kynky> i think old people and children should test ui
03:52:41 <nvoorhies> A lot of the rest could be automated, though
03:53:29 <kynky> definately not the programmers who created it
03:54:14 <pejo> kynky, if your target audience is Heffalump, I'm sure there are other constraints on the UI. He might be perfectly happy with vi.
03:55:03 <kynky> well the customer should get what he paid for :)
04:40:25 <hackagebot> hTensor 0.1.0 - Multidimensional arrays and simple tensor computations. (AlbertoRuiz)
05:09:06 <stacycurl> Does anyone have experience of using System.Plugins ?
05:11:21 <stacycurl> I keep getting an error: unknown symbol
05:11:34 <stacycurl> 'base_GHCziBase_unpackCStringzh_closure'
05:11:48 <mauke> hmm, that's kind of worrying
05:12:20 <Oejet> stacycurl: Are you compiling with --make?
05:12:30 <stacycurl> It looks like a few libraries have given up on using the Plugins lib, I'm reading a Yi paper about it, but Yi no longer uses the lib
05:12:31 <stacycurl> Yep
05:12:58 <stacycurl> Everything works fine in ghci
05:13:29 <stacycurl> Could this be something to do with my version of plugins not being in sync with ghc ?
05:16:53 <malosh> Hi. It seems that my version of haddock accepts to document only the first \begin{code}...\end{code} of my lhs file. Am I missing something ?
05:17:44 <ivanm> which version?
05:17:59 <malosh> 2.4.2
05:18:27 <malosh> (latest stable, I think)
05:18:31 <ivanm> hmmm, nothing that I know of
05:24:32 <stacycurl> Hmm, thought this channel would be a tad more active, with so many users
05:24:48 <leod> it usually is :)
05:25:16 <BONUS> it's just this uneventful time of the day :]
05:25:28 <stacycurl> Maybe because it's the weekend too
05:25:40 <BONUS> and the summer
05:26:29 <daed> bonus; thanks for learnyouahaskell, great site
05:26:33 <BONUS> hey thanks :)
05:26:42 <BONUS> working on finishing it over the summer
05:26:49 <daed> although i'm only 80% through it so far
05:27:22 <daed> did you even draw the pictures? :P
05:27:40 <pejo> BONUS, how do you define finished?
05:27:44 <BONUS> yup yup
05:27:46 <ray> forget you a haskell for great evil!
05:27:51 <daed> lol ray
05:28:03 <BONUS> pejo: well i just settled on an arbitrary limit of stuff i want to write about
05:28:16 <BONUS> i'm going to include a chapters about monads, monad transformers, and zippers
05:28:28 <daed> ah awesome, i'm still not comfortable with monads
05:28:28 <ray> <3 zippers
05:28:34 <BONUS> haha
05:28:35 <ray> you should include arrows
05:28:37 <daed> still not entirely sure what they are
05:28:44 <ray> and category-extras
05:29:02 <daed> is Maybe a monad?
05:29:03 <BONUS> yeah i thought about including arrows but then i don't know how much you could write about them, like really
05:29:22 <BONUS> because people usually just use the combinators for the (->) instance and other arrow instances are rarely used
05:29:26 <BONUS> daed: sure is
05:29:32 <leod> well the arrow syntactic sugar has always been a bit confusing for me
05:29:38 <ray> kleisli arrows get some use
05:29:48 <ray> if you mean proc i have no idea about that either
05:29:54 <leod> and arrows seem to have great use for FRP
05:29:54 <ray> i just know the combinators
05:30:08 <BONUS> yeah the syntax is kindo f confusing and i want to include mainly the H98 stuff
05:30:20 <BONUS> the arrow syntax seems prone to change
05:30:34 <ray> i'm sure you've left h98 already without realising it
05:30:44 <BONUS> yeah i am too :D
05:30:51 <Oejet> daed: Try to look up the Monad instance of Maybe: http://www.haskell.org/ghc/dist/current/docs/libraries/base/src/Data-Maybe.html#Maybe
05:30:51 <BONUS> specially with the libraries
05:30:57 <ray> well, if you import any hierarchical modules
05:30:59 <ray> :)
05:31:04 <BONUS> yeah, but like syntax-wise
05:31:30 <ray> @src Maybe (>>=)
05:31:30 <lambdabot> (Just x) >>= k      = k x
05:31:30 <lambdabot> Nothing  >>= _      = Nothing
05:31:50 <daed> what's the point of "Just"?
05:31:50 <ray> it's an easy monad
05:32:04 <mauke> daed: being not Nothing
05:32:19 <Gracenotes> in Scala, the Maybe type is called "optional"
05:32:25 <BONUS> daed: if something is a Maybe value, it could either be there or not be there
05:32:27 <BONUS> you maybe have it
05:32:29 <stacycurl> daed: I'd recommend getting familiar with a bunch of monad instances, like Maybe, [], and let them sink in before moving to the Monad abstraction itself
05:32:40 <BONUS> that's why it can be Nothing or Just something
05:33:27 <Gracenotes> for example, a safe-division function for x/y might return Nothing if y is zero, but Just (x/y) otherwise..
05:33:30 <mauke> box :: Maybe Cat
05:33:37 <Gracenotes> maru
05:33:39 <Gracenotes> !
05:33:40 <pejo> daed, it's a very useful way to signal failure
05:33:42 <BONUS> also find
05:33:44 <ray> @src Identity (>>=)
05:33:44 <lambdabot> m >>= k  = k (runIdentity m)
05:33:47 <stacycurl> if you want to represent the possible absense of something you cannot use 'null' in haskell, and have to use something like Maybe instead
05:33:48 <BONUS> > find (==5) [1,2,3,4,5,6]
05:33:50 <lambdabot>   Just 5
05:33:53 <BONUS> > find (==5) [1,2,3,4]
05:33:55 <lambdabot>   Nothing
05:34:07 <Gracenotes> the int division function in the library just throws an error..
05:34:13 <daed> it's interesting to me that Just is a -> Maybe a
05:34:27 <BONUS> yeah, that it is
05:34:29 <Gracenotes> a constructor
05:34:35 <stacycurl> todaysCatch :: Fish -- Can hold 1 and only 1 fish
05:34:42 <BONUS> because it takes a normal value and represents it as a value that might have failed (but didn't)
05:34:43 <ray> it is a function, but it's also a data constructor, so you can pattern match on it
05:34:48 <daed> ahh
05:35:03 <stacycurl> todaysCatch :: Maybe Fish -- can hold 1 fish (Just Pike), or none (Nothing)
05:35:29 <ray> > map Just [1..10]
05:35:30 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
05:36:17 <ray> > let f (Just x) = x; f Nothing = 0 in map f (map Just [1..10])
05:36:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
05:36:29 <ray> tada
05:36:55 <BONUS> another way to think of Maybe is that it's like a list that is empty or has only one element
05:37:19 <BONUS> if you just limited yourself to using empty lists and singleton lists, [] and Maybe would be pretty much equivalent
05:37:48 <daed> ahh
05:37:51 <ray> @src [] (>>=)
05:37:51 <lambdabot> xs >>= f     = concatMap f xs
05:37:54 <daed> makes a lot more sense now
05:37:58 <stacycurl> I like to think of them as type safe nulls
05:38:09 <daed> stacycurl; that's exactly what i was thinking
05:38:09 <ManateeLazyCat> Saizan_: Sorry, i still can't understand, you said "the function you pass to pageApplyBuffer can't have the 'a' type in its result [17:34:30]", but it can't work if i change function pageBufferClone to "pageBufferClone :: c -> IO c"
05:38:12 <daed> but it sounded crude :)
05:38:24 <daed> my brain wants to associate it with nullable types
05:38:29 <daed> but i know it's still way different
05:38:39 <mauke> that's pretty much what it is
05:39:19 <daed> seems better though, you get safety
05:39:29 <stacycurl> I've seen them implemented in Java (badly of course because of no pattern matching)
05:40:08 <ray> if you need to be able to attach information to your failure, you can use Either
05:40:29 <ray> if you've used errno in C, you will appreciate how much nicer that is
05:40:44 <daed> i avoid C error handling like the plague generally
05:40:45 * ManateeLazyCat pasted "my code" at http://paste2.org/get/341500
05:40:48 <ManateeLazyCat> Saizan_: Above is my code, i can't pass function `pageClone`.
05:41:41 <stacycurl> dead: not just saftey, you get to compose computations that use them, that's where the monad stuff comes in
05:42:06 <eu-prleu-peupeu> hi
05:42:10 <BONUS> yo
05:42:17 <eu-prleu-peupeu> hey bonus :D
05:42:22 <eu-prleu-peupeu> i really like your twitter
05:42:27 <BONUS> hey thanks :]
05:42:46 <ray> zomg twitter
05:43:05 <BONUS> ManateeLazyCat: if you pass a function to pageApplyBuffer, that function has to basically be one from your PageBuffer class
05:43:08 <ivanm> zomg zomg
05:43:33 <BONUS> because it has to work on all (hence the forall) types that are part of the PageBuffer class
05:43:41 <BONUS> well it can also be const something
05:45:31 <ray> learn you a zygohistmorphic prepromorphism for great confusing newbies
05:45:37 <BONUS> haha
05:46:04 <daed> Used when you really need both semi-mutual recursion and history and to repeatedly apply a natural transformation as you get deeper into the functor
05:46:04 <ManateeLazyCat> BONUS: Saizan_ commend me use "data AnyPageBuffer = forall a . PageBuffer a => AnyPB a" to fix, but i failed.
05:46:06 <daed> wow, you weren't kidding
05:47:04 <BONUS> ManateeLazyCat: what's your problem here exactly, if you don't mind reiterating for me
05:47:11 <mornfall> Is there a way to trigger a profile dump from a running +RTS -P process?
05:47:22 <mornfall> (Or is there a way to run it so that it dumps from time to time?)
05:47:32 <mauke> http://haskell.org/haskellwiki/Real_World#haskell
05:47:59 <ManateeLazyCat> BONUS: I just have a bit confusion
05:48:15 <daed> hahaha
05:49:00 <daed> chapter 9 rules :)
05:49:23 <BONUS> hehe
05:50:05 <BONUS> basically if you have a type that's like data AnyPageBuffer = forall a. PageBuffer a => AnyPB a, it means that the AnyPB constructor takes a value of any type that's in the PageBuffer typeclass
05:50:17 <BONUS> but once you have it inside the AnyPageBuffer, you don't know which type that is
05:50:32 <BONUS> because it isn't like Maybe a where the a tells you that
05:50:56 <BONUS> so if you want to extract the value that you put in it, you can't just use it normally, because you don't know what type it is
05:51:10 <BONUS> you just know that it's part of the PageBuffer class, so you can just use the PageBuffer methods on that value
05:51:25 <stacycurl> The type parameter isn't on the left hand side, so it's inaccessible, right ?
05:51:47 <ray> data Anything = forall a. ZOMG a; zomgHeterogenousList :: [Anything]
05:51:50 <BONUS> yeah. it can't be instantiated by the program
05:52:03 <yuck> oh why's there so few haskell jobs out there?
05:52:45 <ManateeLazyCat> BONUS: Have a fix that not use AnyPB? That's looks more complicated
05:52:52 <stacycurl> Learn Scala or F#, they'll get you a lesser FP fix
05:53:40 <daed> FP?
05:53:45 <stacycurl> functional programming
05:53:56 <BONUS> ManateeLazyCat: well looking at the code from here, i can't see exactly why you would need that, because the Page type can hold any existential values just like AnyPageBuffer et al. can
05:53:57 <ray> i don't want functional programming
05:55:03 <leod> it's too bad you always need to use pattern matching to unwrap the value when using existentials, it's a bit tedious
05:55:28 <yuck> hey guys.. why's there no haskell jobs on the market?
05:55:39 <daed> i'm sure there are
05:55:44 <mornfall> Wasn't like Galois hiring recently?
05:56:04 <ManateeLazyCat> BONUS: Because i don't know what exactly type of `pageBuffer` or `pageMode` unless program run, so i add class `pageBuffer` or `pageMode` for dynamic binding.
05:56:05 <mornfall> But, I'm more interested in an answer to my question than in job market.... :-\
05:56:07 <yuck> i mean how many people get paid to write haskell?
05:56:25 <daed> yuck; i could use haskell where i work and get paid for it
05:56:29 <daed> if i knew how to efficiently code in it :)
05:56:46 <yuck> but you don't?
05:56:47 <BONUS> yeah, you don't know, you just know that what typeclasses they'll be in, so you can use the typeclass functions on them
05:56:53 <stacycurl> It's a pity Haskell isn't well supported on the JVM or CLR
05:56:57 <BONUS> that's what the functions pageApplyBuffer and pageApplyMode are for
05:56:58 <BONUS> brb
05:57:03 <daed> i don't, yuck, because it's faster for me to write other things.. i'm just a haskell noob.
05:57:23 <ManateeLazyCat> BONUS: Haven't fix?
05:57:53 <yuck> any idea how many people use haskell?
05:58:03 <Philonous1> @users
05:58:03 <lambdabot> Maximum users seen in #haskell: 658, currently: 581 (88.3%), active: 16 (2.8%)
05:58:29 <daed> yuck; are you evaluating it or something?
05:58:31 <stacycurl> 16 active users :(
05:58:46 <yuck> daed; i'm just wondering
05:59:10 <yuck> couldn't google it so i'm here
05:59:30 <daed> ah. there's a section on real world applications in the wiki i think
05:59:47 <daed> i live in chicago, and i know there are trading firms and quants that use it for market analysis and such
06:00:22 <yuck> so then how many people use haskell.. 10k, 100k, 1m?
06:00:22 <Philonous> I think haskell has a rather small but prolific community. Not so much power in numbers.
06:00:41 <yuck> i've been seeing it everywhere
06:00:55 <daed> it's prolific definitely, i see it everywhere, i can't escape it :P
06:01:35 <benmachine> I'm telling everyone who cares enough to listen about it
06:01:56 <benmachine> (that isn't too many people though >_>)
06:03:02 <stacycurl> I think Haskell has shot itself in the foot for not getting on the JVM/CLR bandwagon, ruby is being used in the enterprise now via JRuby
06:03:22 <stacycurl> Haskell won't be because of easier alternatives like F# and Scala.
06:03:37 <ManateeLazyCat> yuck: Now problem is not how many people use Haskell, problem is "do you want join us for expand Haskell community?", I don't care how many people use it now, i just care it make my life easier, i believe Haskell will be a popular language someday.
06:04:05 <Vanadium> stacycurl: I shudder to think how Haskell interfacing with the CLR base class library would look like
06:04:15 <pejo> yuck, some of the places that do use haskell don't talk about it. Others publish experience reports at ICFP/CUFP and similiar places.
06:04:17 <yuck> stacycurl; does JVM/CLR really affect a language's popularity?
06:05:08 <stacycurl> Vanadium: probably awfully, no tail call optimisation, but then I think the JVM/CLR have been changed to better support dynamic languages _after_ these languages were ported to those platforms
06:05:21 <pejo> yuck, you can use all of .NET libraries in F#, that's an advantage.
06:05:42 <daed> huge advantage
06:05:42 <stacycurl> yuck: Yes, enterprises can keep their platforms and easily achieve multi language interop
06:06:34 <daed> how different is F# from ocaml?
06:06:38 <pejo> Vanadium, is your question the same as "How would subtyping look in Haskell"?
06:06:44 <yuck> but would it be possible to interface haskell with .NET .. because of the pure functional stuff and etc?
06:07:22 <Vanadium> pejo: Maybe, but, uh, I do not really want to think about how exactly to map .NET types to Haskell
06:07:31 <pejo> yuck, Sigbjörn Finne has a .NET-bridge, it's available on Hackage iirc. There's nothing preventing anyone from making a .NET-backend for GHC, if they were inclined to do so.
06:08:35 <stacycurl> Maybe when GHC is more modular, I gather that's why the LambdaVM (which allows ghc to output bytecode) got out of sync.
06:08:48 <yuck> pejo, then why is it that nobody really uses that sort of thing to compile to JVM/CLR?
06:09:36 <pejo> yuck, because the people interested in having Haskell for .NET aren't interested in writing compilers, I'm guessing.
06:11:22 <Ferdirand>  
06:11:24 <Ferdirand> oops
06:13:41 <stacycurl> Another advantage to having haskell on the jvm is that it allows incremental and integrated adoption. You could achieve incremental adoption but using Haskell for the odd but of scripting, but that wouldn't be integrated
06:13:42 <Oejet> stacycurl: So JVM/CLR is loosely speaking the OS of enterprises?
06:14:04 <arjanb> another reason is that for them the benefit of using haskell instead of scala or F# is not big enough
06:14:14 <daed> yeah that's true arjanb
06:14:32 <stacycurl> Oejet: yeah, i think so, they don't just allow for easier integration, but they also significantly affect deployment and maintenance.
06:15:11 <ray> if you hire haskell programmers they might start using zygohistomorphic prepromorphisms everywhere
06:15:27 <yuck> is haskell still a sort of 'experimental language'?
06:15:41 <stacycurl> Depends who you ask
06:15:54 <ray> i don't think it's very experimental
06:16:13 <pejo> yuck, there is a language standard.
06:16:51 <stacycurl> There's lots of experiementation being done using Haskell as a basis, but then there's a stable core (Haskell98)
06:17:50 <Berengal> A language standard that's pretty outdated only 6 years after its final revision
06:18:32 <yuck> is it outdated?
06:19:13 <stacycurl> It hasn't been superceded by anything that has the same ends.
06:19:17 <Berengal> Well, it does serve as a stable foundation, but there are dozens of extensions to it
06:19:25 <Berengal> And we're getting a new one
06:19:30 <ray> nobody actually writes haskell 98
06:19:42 <ray> even something as simple as hierarchical module names is outside it
06:20:12 <pejo> The GNU people have had dozens of extensions to C as well. I don't think people were claiming that C was experimental just because of that.
06:20:12 <Berengal> ray: I did say it's last revision though, which includes hierarchical modules and ffi
06:20:22 <ray> i thought it just had ffi
06:20:45 <ray> it's not experimental, just the standard isn't everything
06:21:37 <Berengal> Unless I've been misinformed, the hierarchical module revision was being worked on before the h98 had gotten properly out the door
06:21:47 <yuck> but um.. there's like 3 haskell jobs listed and on the same site maybe 7k c# jobs?
06:22:05 <stacycurl> You can pick and choose which extensions to haskell 98 you want, choosing more stable one or recent experiemental ones.
06:22:38 <stacycurl> So you usage can rely on as many 'experimental' language features as you want.
06:23:34 <pejo> yuck, yes, the market for Haskell programmers is smaller than for C# programmers.
06:23:36 <bremner> yuck: so it seems learning c# is a good bet if you want to get an entry level programming job
06:23:38 <Berengal> It's a good thing we're getting haskell' soon-ish though. I'm starting to get tired of writing NoMonomorphismRestriction all the time
06:24:24 <bremner> yuck: I hear there are about the same number of Java jobs.
06:24:39 <yuck> pejo, yes but haskell is ranked very high in many discussion boards, i'm surprised that there's so few jobs
06:25:07 <Botje> Haskell works actively to maintain it's stigma as a research language :)
06:25:09 <stacycurl> Something I've never understood is why Haskell cannot be homoiconic and move most of the language features into userspace.
06:25:11 <Botje> *its
06:25:37 <Berengal> stacycurl: lazy lisp?
06:25:54 <Saizan_> .NET or the JVM might not be viable backends for haskell performance-wise, btw
06:25:54 <stacycurl> Berengal: or smalltalk
06:27:12 <stacycurl> Saizan_: Those platforms weren't seen as good choices for dynamic languages either, but when those languages were available the platforms were changed to better support them.
06:27:16 <pejo> stacycurl, "userspace"? Do you want to supply your own typechecker?
06:27:56 <Saizan_> stacycurl: you've clojure on the JVM but still no TCO, afaik
06:28:03 <Berengal> stacycurl: JRuby is faster than Ruby 1.8 by miles
06:28:22 <stacycurl> pejo: I guess, homoiconic languages tend to have a very minimal core, but then they have minimal or no static semantics
06:30:34 <pejo> stacycurl, which gives rise to the possibility of the same program having multiple meanings, depending on userspace. I think people in general want more guaranteed semantics, not less.
06:31:16 <stacycurl> pejo: Well I could same the same about which language extensions a project uses
06:35:29 <Saizan_> stacycurl: you don't get multiple different meanings by switching extensions
06:35:30 <stacycurl> I just find it hard to believe that: 1) There are that many fundamental language elements, 2) Syntactic sugar cannot be moved to userland
06:36:49 <pejo> stacycurl, the core language of GHC is sufficient to support a large range of things. But it's hardly what I would like to write programs in.
06:37:31 <athos> @src reduce
06:37:31 <lambdabot> reduce _ 0 = undefined
06:37:31 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
06:37:31 <lambdabot>     where d = gcd x y
06:37:32 <stacycurl> pejo: Nor I, I would want the support of lots of userland syntactic sugar
06:37:39 <athos> @type reduce
06:37:40 <lambdabot> Expr -> Expr
06:37:57 <athos> two different reduces, eh?
06:38:02 <Saizan_> yeah
06:38:07 <leod> @type (:%)
06:38:09 <lambdabot> Not in scope: data constructor `:%'
06:38:31 <Saizan_> @type (%)
06:38:32 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
06:41:46 <soupdragon> stacycurl: if it was homoiconic, what would the data be?
06:42:52 <soupdragon> stacycurl: I mean in lisp it's lists, in prolog it's terms, but haskell?
06:43:10 <stacycurl> I don't know
06:43:39 <soupdragon> stacycurl: I can't think of a good one either, maybe this is why
06:44:45 <soupdragon> stacycurl: (although there's no reason we can't have user defined bracketing operators.. but we still don't)
06:45:31 <Saizan_> btw, can you have custom bracketing operators in prolog?
06:45:40 <Saizan_> other than { }
06:46:15 <soupdragon> only {} and []
06:50:08 <stacycurl> Is there more than one way to perform dynamic code loading ? I searched xmonad and yi for usages of System.Plugins (because I can't get it to work), but they don't have any
06:50:44 <stacycurl> I also thought that since yi has dropped System.Plugins there might be a new better way
06:50:50 <Saizan_> those two don't load code dynamically
06:51:04 <stacycurl> Hmm, Yi used to
06:51:04 <leod> does lambdabot?
06:51:16 <Saizan_> no
06:51:16 <ivanm> lambdabot uses mueval IIRC
06:51:22 <ivanm> @hackage mueval
06:51:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval
06:51:56 <Saizan_> that's not what i'd call dynamic code loading, since the code is not linked into the lambdabot process
06:52:15 <Saizan_> however you can use the ghc-api directly, or hint as a wrapper over it
06:52:31 <stacycurl> no ? I'm reading a paper by dons & chakravarty (Dynamic Application From The Ground Up) which references Yi
06:52:36 <Saizan_> the ghc-api is what ghci uses basically
06:53:32 <Saizan_> stacycurl: yeah yi probably used to
06:53:53 <stacycurl> Is ghc-api a better choice than System.Plugins ?
06:55:09 <leod> lambdabot seems to use System.Plugins.Load to load modules
06:57:32 <stacycurl> leod: Hmm, I can't find such a reference, I've just grepped the code (I'm searching for _any_ working example I can base my stuff on).
06:58:00 <malosh> the ghc api seems to have no way to marshal the result, though. Am I wrong ?
06:58:33 <leod> stacycurl: in Boot.hs
07:00:31 <stacycurl> leod: version 4.2.2.1 ?
07:01:24 <Saizan_> malosh: marshal?
07:02:10 <malosh> yes, write it in a dynamic library to reuse it later without having to recompile. marshal.
07:02:15 <leod> stacycurl: in the darcs repo
07:03:39 <leod> stacycurl: http://code.haskell.org/lambdabot
07:03:46 <stacycurl> Ok, I'll grab a copy
07:10:58 <stacycurl> ls
07:11:04 <stacycurl> oops, wrong window
07:47:37 <Igloo> Does anyone know if JHC supports the monomorphism restriction?
07:47:59 <Igloo> And if so, if it has a way to turn it off?
07:52:29 <daf> is there a way to tell cabal not to install an executable?
07:52:38 <daf> my package has some example programs that I'd like built but not installed
07:53:18 <daf> dcoutts: ^^^
07:54:02 <Igloo> I don't think there is
07:55:31 <daf> that was my impressoin too
08:14:58 <kartoo> I want to write a function to find the number of trailing zeros in a number. I'm new to functional programming.  There are no loops in haskell. how should approach this?
08:15:19 <Renderwahn> recursion
08:15:20 <QP> recursion
08:15:25 <straw> recursion
08:15:26 <QP> recursion
08:15:30 <Renderwahn> recursion
08:15:38 <BONUS> hehe. nah
08:15:40 <cjb>   recursion
08:15:47 <cjb>     recursion
08:16:00 <BONUS> the way i'd do it is to think about transforming the data i have to the data i want by applying functions
08:16:20 <BONUS> first i'd take something like 24000 and apply show to it, to get a string
08:16:25 <BONUS> > show 24000
08:16:26 <lambdabot>   "24000"
08:16:33 <BONUS> then i'd reverse it
08:16:53 <BONUS> and then there's the handy function takeWhile, which takes the elements of a list while something is true
08:17:09 <BONUS> > takeWhile (=='0') (reverse "24000")
08:17:10 <lambdabot>   "000"
08:17:17 <BONUS> > length (takeWhile (=='0') (reverse "24000"))
08:17:18 <lambdabot>   3
08:17:39 <QP> now, this *is* using recursion, it's just hidden in the takeWhile function
08:17:41 <BONUS> > length (takeWhile (=='0') (reverse (show 24000))) -- once you're done with that, you can pretify the code a bit
08:17:42 <lambdabot>   3
08:17:56 <BONUS> QP: yeah but pretty much everything in haskell uses recursion, that's kind of like saying "use code"
08:18:19 <QP> yeah, but I wanted to make it clear
08:18:27 <BONUS> > length . takeWhile (=='0') . reverse . show $ 24000
08:18:28 <lambdabot>   3
08:18:54 <QP> also, justify our little "recursion" shower earlier...
08:18:59 <kartoo> BONUS:  I get it now. Thanks. I forgot that string is a [char] in haskell :)
08:21:09 <raxas> there is no need for silly slow conversion to string, you can just divide a number by ten
08:22:04 <BONUS> i wouldn't worry about speed
08:22:08 <BONUS> premature optimization and all that :)
08:23:57 <Deewiant> > let zeroes x = fst $ until ((/= 0) . (`mod` 10) . snd) ((+1) *** (`div` 10)) (0,x) in zeroes 24000
08:23:58 <lambdabot>   3
08:24:35 <Berengal> > length . unfoldr (\n -> let (x,y) = divMod n 10 in if y /= 0 then Nothing else Just (y,x)) $ 24000
08:24:37 <lambdabot>   3
08:26:03 <BONUS> > length . unfoldr (\n -> let (x,y) = divMod n 10 in guard (y == 0) >> Just (y,x))
08:26:03 <kartoo> Deewiant: Berengal: I guess I need to lookup a haskell tut to understand those. Still not very comfortable. Thanks for the solutions
08:26:04 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Types.Int)
08:26:04 <lambdabot>    arising fro...
08:26:38 <Deewiant> > length . unfoldr (\n -> let (x,y) = divMod n 10 in guard (y == 0) >> Just (y,x)) $ 24000
08:26:39 <lambdabot>   3
08:26:40 <BONUS> forgot $ 24000
08:26:44 <Deewiant> Yep
08:27:31 <Berengal> kartoo: Interestingly enough, converting to string is usually pretty fast. The only issue is reversing the string if it's really long, but unless you've got a few hundred thousand digits in your number that's not going to be much of a problem
08:27:51 <BONUS> yeah also reverse has O(n) space complexity
08:28:29 <BONUS> but don't see why you would need to do this on numbers with a few hundred k digits
08:28:51 <Deewiant> > length . unfoldr ((((>>) . guard . (0 ==) . snd) <*> (Just . (snd &&& fst))) . flip divMod 10) $ 24000
08:28:52 <lambdabot>   3
08:29:16 <BONUS> haha
08:29:36 <kartoo> BONUS: oh! ok
08:29:42 <Berengal> I think the usual benchmarks show string conversion is usually the fastest way to go with summing digits and other digit manipulation
08:29:48 <pikhq> Deewiant: That is quite likely very scary to noobs. ;)
08:29:55 <Berengal> Deewiant: @pl much?
08:30:04 <Deewiant> Berengal: Just once. :-P
08:30:09 <pikhq> Nice work, though.
08:30:09 <Deewiant> ?pl \n -> let x = divMod n 10 in guard (snd x == 0) >> Just (snd x,fst x)
08:30:10 <Berengal> :P
08:30:10 <lambdabot> ap ((>>) . guard . (0 ==) . snd) (Just . liftM2 (,) snd fst) . fix . const . flip divMod 10
08:30:25 <Deewiant> liftM2 (,) -> (&&&), fix . const -> id, ap -> <*>
08:30:25 * Axman6 glares at Deewiant for his bad code
08:30:35 <pikhq> Close, at least.
08:30:37 <Deewiant> I really don't get why ?pl generates fix . const
08:30:55 <pikhq> Axman6: Oh, I think it's beautiful. In much the same way that obfuscated C is beautiful, though.
08:31:04 <BONUS> fix . const === id, right?
08:31:07 <Deewiant> Axman6: Yeah, I prefer my earlier solution :-P
08:31:09 <Deewiant> BONUS: Yep
08:31:16 <Axman6> i think obfuscated code is terrible
08:31:33 <Deewiant> I can forgive it for liftM2 (,) instead of (&&&), but fix . const is just confusing
08:31:36 <vav> http://www.willamette.edu/~fruehr/haskell/evolution.html -- Evolution of a Haskell Programmer
08:31:47 <BONUS> i love it when i can make point-free code that's readable but i won't go out of my way to make it point free
08:31:52 <Axman6> to me, good code is readable, and doesn't take more mental jumps than are necessary to make the code do its job
08:32:05 <BONUS> i won't use flip et al.
08:32:08 <Berengal> I'm a bit too used to pointless code I'm afraid...
08:32:24 <BONUS> sometimes i use (f .) . g, to this i plead guilty
08:32:37 <Berengal> (f .) . g is so useful though
08:32:49 <Berengal> But I've stopped using it because it looks ugly
08:32:49 * jmcarthur does (result.result) or (fmap.fmap)
08:33:13 <Deewiant> I just define f .: g = \x y -> f (g x y) and use that
08:33:33 <BONUS> what's that thing with the result function again
08:33:36 <BONUS> what's that
08:33:36 <Axman6> BONUS: i'm with you
08:33:59 <Axman6> Deewiant: good idea
08:34:08 <jmcarthur> BONUS: http://conal.net/blog/posts/semantic-editor-combinators/
08:34:17 <BONUS> much obliged
08:34:51 <Deewiant> I haven't figured out a good name for foo f g = \x y -> f x (g y), though
08:35:14 <Berengal> Z?
08:35:20 <Berengal> It sort of looks like S
08:35:22 <jmcarthur> @pl foo f g = \x y -> f x (g y)
08:35:22 <lambdabot> foo = flip . ((.) .)
08:35:25 <jmcarthur> yucky
08:35:25 <Deewiant> Something infix like .:
08:35:37 <jmcarthur> yeah i was thinking it was similar to S, too
08:35:40 <Deewiant> I used .:. in list-tries because I was using it loads to unpack newtypes
08:35:44 <pikhq> Maybe ÃŸ.
08:35:59 <Deewiant> But .:. doesn't really say much
08:36:05 <jmcarthur> @pl  \x y -> f x (g y)
08:36:05 <lambdabot> (. g) . f
08:36:06 <Deewiant> @pl foo = \x y -> f x (g y)
08:36:07 <lambdabot> foo = (. g) . f
08:36:11 <Berengal> It says "dot dotdot dot"
08:36:15 <jmcarthur> yeah i copied too much the first time
08:36:15 <Deewiant> :-)
08:36:18 <BONUS> *djinn (r -> a -> b) -> (r -> a) -> r -> b
08:36:19 <Axman6> heh, i thought i had a bug on my screen... i was just my mouse -_-
08:36:20 <BONUS> ?djinn (r -> a -> b) -> (r -> a) -> r -> b
08:36:20 <lambdabot> f a b c = a c (b c)
08:36:58 <mlesniak> I've some multithreaded IO code and like to do some benchmarks at more or less arbitarry positions. What is the best way to do this? Thought about using WriterT with sth. like [(UTCTime, String)] but doing all the liftIO just does not feel "right". Better ideas?
08:37:11 <kartoo> I tried to get the factorial of 100000 and it causes stack overflow. How should I deal with large numbers?
08:37:24 <mlesniak> kartoo: +RTS -K1G -RTS
08:37:30 <jmcarthur> kartoo: what's the algorithm?
08:37:34 <mlesniak> (as additional programm options) ;)
08:37:48 <Nafai> Hi shapr
08:37:53 <jmcarthur> kartoo: mlesniak's answer would be an immediate fix at the expense of lots of memory ;)
08:37:55 <Nafai> How's Hac Phi?
08:38:00 <kartoo> fact 0 = 1   and fact x = x*fact(x-1)
08:38:01 <mlesniak> jmcarthur: Yes, right :)
08:38:05 <Axman6> kartoo: i doubt the problem is large numbers. care to share your code?
08:38:24 <Axman6> ah yes, you got a stack overflow because you built up a very large thunk kartoo
08:38:29 <kartoo> >fact 0 = 1
08:38:31 <jmcarthur> kartoo: that has some really bad stack behavior
08:38:37 <kartoo> > fact 0 = 1
08:38:38 <lambdabot>   <no location info>: parse error on input `='
08:39:10 <kartoo> > fact x = x*fact(x-1)
08:39:11 <lambdabot>   <no location info>: parse error on input `='
08:39:17 <Berengal> > let fact 0 = 1; fact x = x * fact (x-1) in fact 50
08:39:18 <lambdabot>   30414093201713378043612608166064768844377641568960512000000000000
08:39:25 <Berengal> > let fact 0 = 1; fact x = x * fact (x-1) in fact 100
08:39:27 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
08:39:31 <Berengal> > let fact 0 = 1; fact x = x * fact (x-1) in fact 100000
08:39:36 <lambdabot>   mueval-core: Prelude.read: no parse
08:39:36 <lambdabot>  mueval: ExitFailure 1
08:39:46 <mlesniak> Berengal: Don't try to kill lambdabot ;)
08:39:47 <Axman6> > let fac n | n < 2 = 1; fac n = fac' n 1 where fac' 2 x = x; fac' n x = fac' (n-1) (x*n) in fac 100000
08:39:52 <lambdabot>   mueval-core: Prelude.read: no parse
08:39:53 <lambdabot>  mueval: ExitFailure 1
08:39:58 <Axman6> > let fac n | n < 2 = 1; fac n = fac' n 1 where fac' 2 x = x; fac' n x = fac' (n-1) (x*n) in fac 10
08:39:59 <lambdabot>   1814400
08:40:00 <Philonous> > foldl' (*) [1..100000]
08:40:02 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
08:40:02 <lambdabot>    arising from a us...
08:40:04 <Axman6> > let fac n | n < 2 = 1; fac n = fac' n 1 where fac' 2 x = x; fac' n x = fac' (n-1) (x*n) in fac 100
08:40:05 <lambdabot>   466631077219720763408496194281333502453579841321908107342964819476087999966...
08:40:11 <Axman6> > let fac n | n < 2 = 1; fac n = fac' n 1 where fac' 2 x = x; fac' n x = fac' (n-1) (x*n) in fac 1000
08:40:13 <lambdabot>   201193630038546886771851216961501992859687432105357316271899955214969256199...
08:40:32 <jmcarthur> fact 999 ==> 999 * fact 998 ==> 999 * (998 * fact 997) ==> 999 * (998 * (997 * fact 996))  -- see how it's just building up a bunch of values but not evaluating them or anything? that doesn't happen until the end
08:40:42 <benmachine> > foldl' (*) 1 [1..100000]
08:40:48 <lambdabot>   mueval-core: Prelude.read: no parse
08:40:48 <lambdabot>  mueval: ExitFailure 1
08:40:54 <jmcarthur> > product [1..10000]
08:40:55 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
08:41:07 <jmcarthur> > product [1..100000]
08:41:12 <lambdabot>   mueval-core: Prelude.read: no parse
08:41:12 <lambdabot>  mueval: ExitFailure 1
08:41:14 <jmcarthur> fine then
08:41:22 <benmachine> I guess 100000 is just too big
08:41:31 <Berengal> I think fact 100000 eats too much memory
08:41:35 <Axman6> kartoo: the version i provided there is tail recursive, which can be far better optimised than the version you have, which requires fac (n-1) to be evaluated fully before you can perform x* fac (n-1)
08:41:50 <shapr> Good morning #haskell!
08:41:51 <mlesniak> (as a side note: http://www18.wolframalpha.com/input/?i=100000! ) ;-)
08:41:58 <kartoo> isnt there any way to handle it efficiently?
08:41:59 <Axman6> g'day shapr
08:42:13 <jmcarthur> @src product
08:42:13 <lambdabot> product = foldl (*) 1
08:42:17 <shapr> G'day Axman6, how's code?
08:42:18 <jmcarthur> @src foldl'
08:42:18 <lambdabot> foldl' f a []     = a
08:42:19 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:42:23 <Berengal> Axman6: Tail recursive functions also have a way of building up thunks you know
08:42:31 <jmcarthur> kartoo: ^^ :)
08:42:32 <Axman6> i know
08:42:51 <Axman6> but, this is usually the best way to avoid these problems
08:43:40 <Axman6> shapr: meh, haven't written anything much for a while. and won't have much time for a while, need to learn Ada, and SQL for uni
08:43:41 <burp> > gamma $ 100000 - 1
08:43:43 <lambdabot>   Not in scope: `gamma'
08:43:59 <jmcarthur> ada at uni???
08:44:03 <Axman6> yep
08:44:25 <Axman6> for my Concurrent and Distributes Systems course
08:44:28 <Axman6> ed*
08:44:30 <kartoo> even ruby causes stack overflow :)
08:45:32 <benmachine> I think a 456-thousand digit number is going to be hard work for any system
08:45:57 <Axman6> kartoo: you see how your function builfs up something that looks like x*((x-1)*((x-2)*((x-3)*..(x-x))...))))?
08:46:10 <Berengal> benmachine: Not to mention the numbers needed to create that number
08:46:12 <Axman6> Berengal: you're not trying hard enough :P
08:46:15 <Axman6> uh, benmachine*
08:46:25 <jmcarthur> benmachine: well, there are more efficient algorithms even than a left fold
08:47:26 * benmachine runs reduce(lambda x, y: x * y, range(1,100000)) in python and watches it eat his CPU
08:47:41 <Axman6> heh
08:47:57 <daed> :o
08:47:58 <benmachine> hah I got an answer
08:48:06 <benmachine> it um
08:48:10 <benmachine> filled my entire terminal scrollback
08:48:40 <Berengal> benmachine: You should probably be glad it doesn't buffer infinitely
08:48:44 <Deewiant> Prelude Data.List> length . show $ foldl' (*) 1 [1..100000]
08:48:44 <Deewiant> 456574
08:48:46 * Berengal has had that problem
08:49:10 <Berengal> How much memory does such a number use?
08:49:36 <benmachine> I don't think it was actually a lot
08:50:13 <benmachine> 101% CPU but 0.3% MEM
08:50:59 <benmachine> Berengal: in python, 202K apparently
08:51:40 <benmachine> heh, working out the string representation of the thing takes pretty much as long as working out what it was in the first place
08:52:04 <jmcarthur> yeah, that's the way it basically has to be, afaik
08:52:29 <Axman6> wonder if logBase 10 would be any faster
08:53:02 <benmachine> it's a floating-point operation so it would probably be inaccurate on a number of this magnitude
08:53:57 <Axman6> indeed
08:54:37 <kartoo> ah! the foldl version works though it takes a long time
08:56:11 <Axman6> @src enumFromTo
08:56:12 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:56:21 <shapr> Axman6: Ada for uni?
08:56:28 <Axman6> yep
08:56:29 <benmachine> @src Int enumFromTo
08:56:29 <lambdabot> Source not found. :(
08:57:19 <jrib> hello, what are my options if I want to use haskell on a cluster?
08:58:21 <Axman6> you mean for distributed computing?
08:58:26 <jrib> Axman6: yes
08:59:09 <Axman6> http://www.iist.unu.edu/~vs/haskell/dhs/ is one of the first hits on google
09:00:28 <jrib> Axman6: I've found several options but many seem outdated so I was hoping for recommended solutions or personal experience
09:01:05 <Axman6> shouldn't be too hard to roll your own library if needed too. i was going to do just that the other day, using bytestrings and the Binary package for sending messages
09:09:25 <Berengal> Crap, I was on a roll, but I lost it
09:11:02 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7498#a7498
09:11:10 <Axman6> jrib: there's also all the holumbus stuff, which is i believe what powers hayoo
09:11:12 <Berengal> outmap works, but map doesn't typecheck :/
09:16:51 <Cale> That's an awfully strange couple of method type signatures for a class called List
10:05:04 <Petrosian> I have a question regarding Monad transformers
10:05:13 <Petrosian> Suppose I wanted non-deterministic state
10:05:36 <Petrosian> Could I achieve this easily with something like ListT and State?
10:05:54 <soupdragon> 'non-deterministic state' means nothing to me
10:06:13 <Petrosian> The intended usage is modelling an NFA
10:06:23 <Petrosian> If that helps
10:07:07 <Petrosian> That is, the state would be that of an automata
10:07:34 <Petrosian> And being an NFA, it could potentially be in several different states
10:08:38 <jorick> So couldn't you have the state of your NFA be a list of nodes?
10:08:50 <Petrosian> It's a contrived problem
10:08:55 <Deewiant> ?unmtl ListT State s a
10:08:56 <lambdabot> [s] -> (a, [s])
10:09:02 <Petrosian> With the goal of (finally) grokking monad transformers, essentially
10:09:31 <Petrosian> Since after a few years of hacking haskell, I've yet to bother really looking at them
10:09:42 <jorick> so you want to combine the state and the list monad ... in what way?
10:10:01 <Petrosian> Pretty much.
10:10:18 <soupdragon> Petrosian: do you have an example NFA?
10:10:24 <soupdragon> to implement
10:10:48 <Petrosian> Not to hand
10:11:03 <jorick> i don't think you'll need the state monad for that
10:11:50 <Petrosian> Tho', I'd imagine an obvious implementation would just be some data type representing a state and a mapping from symbols to other states
10:12:01 <Petrosian> data NfaState a = NfaState [(a, NfaState a)]
10:12:06 <Petrosian> As a first approximation
10:12:32 <jorick> epsilon transformations would be nice ...
10:12:45 <Philonous> Petrosian: Surely from state + symbol to another state?
10:12:47 <soupdragon> I don't mean in haskell
10:12:53 <soupdragon> just make up an NFA
10:13:08 <soupdragon> one that has some vauge meaningfulness though
10:13:15 <Philonous> Petrosian: Oh, never mind
10:13:17 <Petrosian> soupdragon: Oh, right, erm.
10:14:03 <Petrosian> Well, any would do really... something like this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7501#a7501
10:14:37 <Petrosian> It's fairly meaningless, but it has multiple transitions for a given symbol from certain states
10:14:48 <soupdragon> what about a meaningful one? :p
10:14:55 <Berengal> Which one accepts?
10:15:03 <soupdragon> maybe that's too much to ask
10:15:05 <Petrosian> Berengal: Which ever you fancy
10:15:56 <Petrosian> Having no real experience with Monad transformers, I've no idea if this is a reasonable (albeit contrived) application
10:16:12 <Petrosian> But it seemed like a reasonable thing to try, given my understanding on plain old monads
10:18:08 <Berengal> Using lists as nondeterministic computation is fine (and imho quite neat. Prolog is a basic datatype in haskell :P). Transforming a stateful computation to a nondeterministic stateful computation would indeed be a ListT State
10:18:09 <jorick> i'd represent my NFA as a Data.Map (state, maybe char) -> [state], then have the state of the NFA be [state] and nextState state (maybe char) = flatten map lookup NFA (state, char) ++ flatten map lookup NFA (state, Nothing)
10:18:24 <jorick> something like that ought to work
10:18:28 <Philonous> Petrosian: Doesn't showing one of those give an infinite loop as well as comparing for equality?
10:18:29 <Berengal> There might be better ways to model an nfa though
10:18:44 <Petrosian> Philonous: Indeed
10:19:02 <Berengal> Philonous: Comparing for equality gives a type error ;)
10:19:11 <Philonous> Berengal: That, too.
10:19:14 <Petrosian> Berengal: Right, thanks
10:19:28 <Petrosian> Berengal: The point isn't really to find a the best way to implement an NFA tho'
10:19:43 <Petrosian> As I said, it's a means to an end to learn transformers
10:20:00 <Berengal> Petrosian: Find a stateful algorithm. Make the problem have multiple solutions. Transform
10:20:18 <badsheepy> and roll out
10:20:20 <Berengal> And tada! nondeterministic stateful computation
10:20:30 <badsheepy> oh, my mistake:o
10:20:43 <Petrosian> Philonous: You wouldn't need to Eq or Show either really, just have a function eat the whole string of input symbols, and see if any of the states are a finishing state
10:20:59 <Petrosian> Philonous: Ahh, but the eq check...
10:21:14 <Petrosian> Could just have some trivial equality, give them all a name, and check the names are equal
10:21:52 <Berengal> Comparing unequal states will return
10:22:01 <Berengal> But equality isn't a total function anymore
10:22:04 <Petrosian> Yes, that'd work too
10:22:52 <jorick> Petrosian maybe check this out http://www.haskell.org/all_about_monads/html/xformerexamples.html#example24 (Here is a more interesting example: combining StateT with the List monad to produce a monad for stateful nondeterministic computations.)
10:22:55 <shapr> Yay Hac-phi! w00!
10:23:01 <Philonous> Berengal: No, it wouldn't necessarily. Suppose oyu have two distinct but isomorphic states
10:23:07 <Petrosian> Ahh, good find jorick!
10:23:08 <Petrosian> Thanks
10:23:55 <Petrosian> Tho', by the looks of it, I'd want it the other way around
10:24:27 <amaron> if you have to deploy your haskell app (ie. web app on other linux box without ghc) how would you handle different versions of used external .so libraries?
10:25:32 <Berengal> Petrosian: Implement Dijkstra's algorithm as a stateful computation and give it a graph where there's more than one shortest route
10:25:53 <Petrosian> Berengal: That's a nice problem
10:31:27 <Cale> amaron: Either hope that they are compatible, or if not, send the right .so files and set LD_LIBRARY_PATH
10:32:54 <amaron> Cale: see, so i have my own lib dir and LD_LIBRARY_PATH as env variable?
10:33:07 <amaron> *I see
10:35:01 <Cale> amaron: yeah
10:35:45 <amaron> Cale: cool, I think thats good enough for deploying anywhere, tnx
10:47:41 <Berengal> Isn't .so a problem only with dynamic linking?
10:52:41 <Rotaerk> hmm... can type classes do dynamic dispatch?
10:52:52 <Rotaerk> or do you have to use DU's and pattern matching for that
10:53:52 <Rotaerk> eh nm, I guess you couldn't have a list of numerics...
10:54:10 <Rotaerk> except for a specific type of numeric of course
10:54:12 <kpreid> Rotaerk: there is something sort of like that, existential types
10:54:20 <Rotaerk> ah
10:55:39 <kpreid> but consider this: if you have a 'list of any kind of number', you can't (a:b:_) -> a + b, because a and b might be different
10:55:56 <kpreid> (you can recover this by using the Typeable typeclass, though)
10:56:01 <kpreid> @type Data.Typeable.cast
10:56:02 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
10:56:29 <kpreid> cast returns Just its parameter iff the parameter is in fact of the result type
10:56:34 <kpreid> confused yet? :-)
10:57:11 <Rotaerk> ah :P
10:57:27 <kpreid> anyway, existential types are a powerful tool; they can make certain things work very well, but are best avoided if you don't actually need them
10:58:18 <Rotaerk> okay, cool
11:01:47 <Cale> Often existential types can be replaced with simple records of methods.
11:02:29 <Cale> It's actually a bit tricky to find something not-contrived where it's not easy to translate away the use of existentials.
11:03:41 <LeoD> for the game i'm writing, i have a typeclass Actor and an existential to be able to hold lists of Actors
11:05:59 <LeoD> though i guess the same could be done with records
11:06:15 <Cale> LeoD: Is there a reason not to just go with records of functions with similar types to the methods of the Actor class?
11:07:17 <kpreid> one could argue that existentials express intent better
11:07:35 <Philonous> Cale: If I have a record with several closures capturing a common variable, will that variable be shared?
11:07:36 <LeoD> well, every actor has different state
11:08:38 <Cale> Philonous: Not 100% sure what you're asking there. Things will be shared when they come from the same variable, yes.
11:09:28 <Cale> LeoD: Have you seen http://cale.yi.org/index.php/A_look_at_OO_from_Haskell ?
11:09:33 <LeoD> if i use records of functions, where do i store the actors' state?
11:09:47 <Cale> LeoD: In the parameters to the functions which construct those values.
11:10:06 <Cale> LeoD: and use recursion to update them :)
11:10:14 <LeoD> ah right, i think i've seen that... well i just don't see the advantage
11:10:22 <mike-burns> Has anyone gotten HDBC-sqlite3 to install under GHC 6.10? The convertible package (a dependency) is failing just like this: http://hackage.haskell.org/packages/archive/convertible/1.0.5/logs/failure/ghc-6.10
11:10:46 <LeoD> Cale: that might get a bit messy if i have some more state
11:10:47 <Cale> Well, if you've already done it one way, then there's probably little sense in changing it.
11:11:43 <LeoD> i mean, if i have more state, record updates are quite useful to have
11:11:44 <Cale> LeoD: In general, your state can have any type that you like, including perhaps some record type -- in general, it'll be whatever type of data the existential type variable would be used at :)
11:11:53 <LeoD> oh, right
11:13:01 <LeoD> the downside i see in using existentials is having to unwrap the value everytime you want to call a function
11:13:03 <Philonous> I guess the advantage is that you don't need the classes and instances.
11:13:23 <Associat0r> Rotaerk: http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP
11:13:29 <Cale> Philonous: and no extensions.
11:13:39 <shapr> Cale: We miss you at Hac-phi!
11:13:46 <shapr> We have at least one Canadian here.
11:13:50 <Cale> shapr: Where is it being held?
11:13:57 <Cale> shapr: I can't really travel.
11:13:58 <shapr> In Philadelphia
11:14:01 <shapr> Ah, too bad.
11:14:16 <Berengal> What's going at hac phi right now?
11:14:20 <mike-burns> Hacking.
11:15:29 <mike-burns> Well, half hacking, half conversations about things people should be hacking.
11:15:30 <gwern> oh, it's in progress?
11:15:34 <gwern> anything cool being worked on?
11:15:43 * Cale votes that the next one be called Hac 1/gamma
11:16:09 <Berengal> Cale: But where's 1/gammaville?
11:17:28 <Cale> phi ~= 1.61803,  1/gamma ~= 1.73245
11:17:32 <mike-burns> For those interested, byorgey has posted some pictures: http://byorgey.wordpress.com/2009/07/25/hac-%cf%86-day-2/
11:18:59 <gwern> mike-burns: oh noes, hac-phi is going to be a failure!
11:19:04 <gwern> there are no real beards there!
11:19:36 <mike-burns> gwern: Don't worry, people are still hacking academic apps for which they have no use.
11:19:39 <Cale> gwern: As long as they stay away from defining new languages, everything should be okay
11:19:56 <mike-burns> Hah. Two people are working on a new language.
11:19:59 <gwern> phew. but wait, they could be defining DSLs
11:20:11 <gwern> Cale: then we are doomed
11:20:17 <gwern> they'll create another perl and c++
11:23:27 <vav> mike-burns: I have convertible-1.0.5 but it's built with time-1.1.4 which does have Typeable *Time instances. Looks like constraint in cabal file is wrong, time-1.1.2.4 doesn't.
11:23:53 <mike-burns> vav: Cool, I'll try that.
11:26:18 <copumpkin> has anyone thought of whether a finger tree would work as an interval tree for some monoid?
11:26:30 <copumpkin> seems tough but maybe I'm thinking about it wrong
11:27:19 <eflister> MultiParamTypeClasses question.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7505#a7505
11:27:25 <Cale> copumpkin: the original paper considers that case, and yes, it works
11:27:29 <copumpkin> oh
11:27:34 <copumpkin> I'll go check it out
11:27:55 <mike-burns> vav: That got convertible installed; awesome, thanks.
11:29:00 <copumpkin> Cale: wow, that's cool
11:29:15 <Berengal> eflister: So, what's the problem?
11:29:20 <eflister> compiler won't accept it cuz there's no guarantee that m1's 2 arguments will get the same type back from m2.  how do i express this?
11:29:38 <copumpkin> ooh and the fingertree already supports it, nice
11:29:46 <copumpkin> (fingertree package)
11:29:58 <Cale> copumpkin: monoidally indexed trees are such a natural idea, I'm astounded that they seem to have been introduced along with fingertrees.
11:30:11 <gwern> hm. this is a random question but there are a lot of europeans here... I saw someone describe sweden's foreign student programs as so generous foreigners can basically study for free; how true is this generalization?
11:30:24 <Cale> It seems like the sort of thing which should have been around since the very start of computer science.
11:30:55 <Berengal> gwern: I don't know about sweden but in norway it's basically true
11:31:17 <gwern> Berengal: but I'm skeptical - if it's so great, why isn't it really popular?
11:31:26 <gwern> economists don't believe in free lunches :)
11:31:40 <Cale> gwern: You could ask the same about Haskell ;)
11:32:08 <Adamant> gwern: not a lot of Norwegian or Sweden universities have international cachet
11:32:12 <gwern> Cale: but we are getting more people...
11:32:14 <Adamant> *Sweidsh
11:32:16 <Cale> In my experience, most of the truly awesome things are very unpopular.
11:32:19 <Berengal> gwern: There might be limits to how many foreign students are granted education here
11:32:49 <gwern> hm. wonder if there's any cachet to just studying abroad
11:32:52 <Berengal> That said, half of my educators were foreign
11:33:06 <Philonous> Cale: Do you mean in computer science or in general?
11:33:15 <Cale> In general
11:33:37 <copumpkin> Cale: I remember asking about a relational db with an interval tree and edwardk told me GiST in postgres could do it if I wrote a few operations for it. That seems like a similar idea
11:33:56 <gwern> Berengal: educators where?
11:34:01 <Philonous> Cale: Care to give some examples?
11:34:15 <Berengal> gwern: U. of Bergen
11:34:26 <Cale> Philonous: Jazz music :)
11:34:55 <Cale> Philonous: mathematics
11:35:05 <Cale> (in general)
11:35:09 <Berengal> I wouldn't call mathematics unpopular
11:35:23 <copumpkin> Berengal: I would
11:35:27 <Cale> But it's only appreciated by much less than 1% of the population
11:35:31 <Berengal> Well, maybe "unpopular", but not "very"
11:36:00 <copumpkin> Cale: it's sad how socially acceptable (or even "cool") it is to say "I suck at math" and be complacent about it
11:36:07 <copumpkin> whoop,s I mean Berengal
11:36:07 <Cale> copumpkin: indeed
11:36:12 <copumpkin> or cale :)
11:36:19 <Berengal> Also, it sort of depends on what you define as math. I see people around me use it all the time, even the ones who "suck at math"
11:36:27 <gwern> Berengal: oh. that's interesting; where is norway getting its educators from? other european countries?
11:36:55 <Cale> Berengal: I mean proving theorems.
11:36:57 <Berengal> gwern: They've mostly been studends who happened to like it here
11:37:24 <Cale> (In my mind, if you're not proving theorems, you are not doing mathematics.)
11:37:25 <Berengal> gwern: I think only one of mine got his degrees outside of norway
11:37:27 <pozic> Proving theorems is the only way to demonstrate true understanding, imho. It is at least the only way to verify understanding.
11:37:37 <Berengal> Cale: Yes, that I can see
11:37:46 <Berengal> (And I agree)
11:37:58 <Berengal> ((But I "suck at proving theorems"))
11:37:59 <Cale> (there's plenty to mathematics which is not just proving theorems, but without that part, it's just not mathematics anymore)
11:38:43 <eflister> Berengal: any ideas on that MultiParamTypeClasses question?
11:39:07 <monochrom> That is easy to satisfy. Every time you "calculate" 43+5=48 you prove a little theorem.
11:40:04 <Cale> monochrom: I don't mean it in that sense either. What I really mean is theorems with at least one universal quantifier.
11:40:15 <Philonous> Cale: I don't think jazz is that unpopular. (And for that matter not that awesome, either ;) )
11:41:00 <Renderwahn> forall x 43+5=48
11:41:18 <Cale> Renderwahn: pff
11:41:22 <gwern> I get the impression that in america jazz is considered tapped out - too recondite and inwardly focused for the public; kind of like philosophy
11:41:55 <monochrom> I'm going to be naughty. 43, 5, 48 are GÃ¶del numbering of some universally quantified statements, and + is some non-trivial operator on them. So 43+5=48 is a non-trivial logical equivalence of some universally quantified statements.
11:42:21 <Cale> It requires the listener to have heard too much music beforehand to be popular.
11:42:54 <Cale> Like mathematics, you need a certain amount of context to understand it, which most people don't have.
11:43:15 <Cale> and that is probably the fundamental reason why all sufficiently awesome things are unpopular
11:43:16 <shapr> I agree with that. It took me a long time to appreciate jazz. Listening to the radio just does not prepare you.
11:43:18 <Renderwahn> it does? i wonder how i got hooked up on jazz? by listening to hours of heavy metal?
11:43:22 <SamB> They didn't played enough videogames?
11:43:32 <copumpkin> a lot of good "classical" music is the same way
11:43:41 <copumpkin> Renderwahn: exactly ;)
11:43:48 <slash_> Heh true.
11:43:49 <copumpkin> needs more system of a down
11:43:51 <Berengal> eflister: Ah, right
11:43:54 <shapr> copumpkin: We miss you at hac-phi!
11:44:14 <copumpkin> shapr: yeah, I'd have loved to come but I'm short on money now and couldn't make it :/
11:44:17 <gwern> Cale: I dunno. maybe merely good things can require an arduous apprenticeship, but why can't great things be popular and critically awesome? some of the greatest pieces of classical music are also the most popular
11:44:26 <soupdragon> what's going on at hac-phi?
11:44:35 <shapr> HASKELL CODE!
11:44:35 <copumpkin> soupdragon: much haskell hackage, apparently
11:44:43 <Cale> gwern: classical music as a whole is not as popular though.
11:44:43 <Berengal> eflister: I'm not entirely sure, but I think you need either scoped type variables or fucntional dependencies
11:44:49 <monochrom> Some of the greatest pieces of classical music are also the least popular.
11:44:56 <gwern> Cale: to take jazz specifically - you ever read reviews of _Cowboy Bebop_? people who've never heard jazz will rave about kanno's work, and she's very well received critically
11:44:59 <soupdragon> any new ideas
11:45:16 <monochrom> But I don't care about popularity.
11:45:28 <eflister> Berengal: thanks for looking at it.  i haven't delved into either of those before.
11:45:45 <soupdragon> whats jazz
11:45:54 <Berengal> eflister: Or type families... I prefer those
11:45:54 <Cale> soupdragon: It's a kind of music
11:46:06 <shapr> copumpkin: Dimitry Golubovsky just gave a talk about Haskell in the web browser: http://www.haskell.org/haskellwiki/Hac_%CF%86/Talks
11:46:14 <gwern> monochrom: don't care about instantaneous popularity; care about its derivative! as cicero wrote, time destroys the conceits of men, and preserves the good
11:46:17 <copumpkin> oh nice
11:46:28 <copumpkin> things like beethoven's grosse fuge never got popular
11:46:30 <copumpkin> sadly
11:47:19 <soupdragon> grosse
11:47:20 <jkff> Note: Nice too meet fans of academic music here :)
11:47:28 <monochrom> I don't see the connection between popularity derivatives and cicero's quote.
11:47:29 <jkff> *to meet
11:47:32 <copumpkin> groÃŸe I guess :P
11:47:46 <jkff> You gueÃŸ ?
11:47:56 <Cale> hehe
11:47:57 <copumpkin> hah
11:48:18 <Berengal> shapr: Was it taped?
11:48:20 <monochrom> In fact I observe that cicero's quote works, and it is the antithesis to popularity derivative.
11:48:27 <shapr> Nah, you missed it :-P
11:48:33 <Berengal> :(
11:48:35 <copumpkin> :(
11:48:37 <jkff> Did the discussion start with an analogy between the unpopularity of classical music and unpopularity of Haskell?
11:48:47 <gwern> monochrom: a popular thing whose velocity is largely negative is something to ignore; it is a thing of the moment - britney spears. but something like shakespeare, whose popularity is constant (or maybe modestly waning/waxing), is something to look into. time is an integral part of this analogy
11:48:48 <copumpkin> jkff: actually unpopularity of swedish education iirc
11:48:51 <shapr> But edwardk is about to talk about transparently parallel parsing with monoids now.
11:48:53 <Cale> jkff: It started with me commenting that most awesome things are unpopular.
11:48:54 * gwern snickers at my pun
11:48:55 <Philonous> jkff: No, but that's where it culminates
11:49:02 <copumpkin> shapr: make a video please!!!
11:49:12 <eflister> anyone have any ideas on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7505 before i go and study type families? (thx to Berengal for the pointers)
11:49:20 <shapr> I think my camera only holds 8 minutes or so.
11:49:31 <jkff> I see, and probably I must agree.
11:49:56 <monochrom> For example COBOL and PL/I were popular, Algol was unpopular. COBOL and PL/I were the conceits of men, Algol was the good. Now look at all modern programming languages, they are derivatives of Algol, not COBOL or PL/I.
11:50:12 <shapr> copumpkin: I could transcribe :-)
11:50:22 <jkff> However, it doesn't look like popular music is getting any more academic
11:50:25 <Berengal> shapr: No live feed either?
11:50:26 <monochrom> So, I care about unpopularity and its derivatives instead. The popular will die, no derivative left-over either.
11:50:27 <soupdragon> transparently parallel parsing with monoids oooooooo
11:50:36 <shapr> Berengal: Not unless you're in the room with us.
11:50:38 <copumpkin> shapr: :) nah, thanks though
11:50:38 <gwern> cobol's popularity is also waning, while algol's popularity was constant
11:50:46 <soupdragon> shapr shapr you should FEED it to us
11:50:46 <gwern> I think my theory works for them
11:50:53 <Berengal> shapr: I don't think I can get from Norway to there in such short a notice
11:50:59 <shapr> aww, too bad.
11:51:01 <shapr> Maybe next time.
11:51:04 <copumpkin> shapr: if you have a mac you can point your airport camera at him though
11:51:10 <copumpkin> ;)
11:51:12 <jkff> The difference is in that awesomeness is profitable in programming languages, whereas in classical music, it isn't
11:51:15 <shapr> I'll ask Ed to put his slides online.
11:51:31 <gwern> the question of how long to wait before assessing the derivative is an empirical question though
11:51:49 <Philonous> Cale: Seems to me that most "awesome" things are intellectually challenging. Than I can see why they are rather unpopular
11:51:58 <Philonous> Then*
11:52:01 <Cale> Philonous: right
11:52:01 <gwern> jkff: really? you think the world's greatest classical pianist is no more profitable than the 50th greatest?
11:52:17 <copumpkin> cause most people don't enjoy thinking?
11:52:30 <gwern> yo-yo ma seems to have done awright with being one of the greatest cellists around. he's also popular, incidentally
11:52:51 <benmachine> I can't imagine what such people do with their lives
11:53:01 <benmachine> probably very little
11:53:10 <gwern> turn on the tv. learn what they watch. mtv is a good choice
11:54:35 <monochrom> yo-yo ma is popular inside a niche but not popoulace popular. How many mp3 players contain yo-yo ma music?
11:55:00 <Berengal> I have no idea who yo-yo ma is
11:55:02 <copumpkin> well he also plays more popular stuff like astor piazzolla (who's awesome btw)
11:55:29 <Nafai> monochrom: True, but I would say he is the most well known of any cellist, even by people who don't have his music
11:55:32 <gwern> you seem to be redefining popular to mean popular among everyone
11:55:36 <sjanssen> gwern: Yo-Yo Ma is only popular because his name is "Yo-Yo Ma".  Very memorable, that name
11:56:00 <copumpkin> and things like bach's cello suite #1 prelude, which just about everyone knows and thinks about when they hear "cello"
11:56:16 <gwern> sjanssen: if success were that easy, every hollywood wannabe to change his/her name would be a superstar
11:56:20 <monochrom> Because almost the whole world population consumes music regularly.
11:56:26 <gwern> because superstardom is just how Max Power rolls, Marge!
11:56:31 <Cale> gwern: Well, popular among people who listen to any music whatsoever, which is almost everyone.
11:56:59 <monochrom> Suppose we talk about programming language popularity. Then we have to measure it over all programmers and all software projects.
11:57:21 <monochrom> And suppose we talk about music popularity. Then we should measure it over all music listeners.
11:59:00 <gwern> there's a lot of path dependency to programming languages; I think if we measured over people on linux with an inclination to FP, who don't *need* libraries and tools unavailable in haskell, and who aren't already reasonably satisfied with something else, we'd find we have more of the market than one would expect
12:00:46 <monochrom> Oh you can re-define anything to be niche-popular by defining a new niche.
12:01:07 <benmachine> heh
12:01:16 <benmachine> in the niche of haskell users, haskell does pretty well
12:01:20 <Cale> heh
12:01:36 <Cale> 100% popularity!
12:03:25 <gwern> where did I narrow the haskell niche down too much? our windows support is so painful that it's reasonable to say most everyone is on mac or linux, and someone who needs something not in haskell isn't any more likely to learn and use it than someone who's satisfied with a language they already know
12:04:00 <benmachine> you should never be satisfied with a language you already know if there's another one you don't
12:04:08 <benmachine> or maybe that's just me
12:04:28 <Cale> benmachine: There will always be another language you don't know.
12:04:34 <monochrom> Helene Grimaud is highly popular among people who have an inclination to CD-era female pianists whose given names start with H and whose family names start with G, 2nd letter R, 4th letter M, and last letter D. Oh look, I don't even have to narrow down the vowels!
12:04:49 <benmachine> Cale: true, I suppose
12:05:01 <Berengal> benmachine: I used to think that too, but after I learned haskell I've changed my mind
12:05:08 <Cale> benmachine: corollary: you should never be satisfied with any programming language
12:05:09 <benmachine> but I only know three languages and that is probably not enough
12:05:20 <benmachine> Cale: satisfaction == complacency :P
12:05:56 <gwern> monochrom: congratulations for demonstrating the absurdity of categories; maybe next you can demonstrate the infinite regresses of logic & proof, and how we can't be sure anything exists
12:06:18 <Berengal> At around 7-9 (reasonably different) languages you stop learning new things from new languages, and the differences become only syntax and libraries
12:06:41 <benmachine> actually three is probably generous in my favour
12:07:00 <monochrom> No, gwern, I'm saying that it is too easy to strike up a new innocent looking, seemingly non-narrow conditions and still end up with a very narrow restriction.
12:07:02 <benmachine> C and python are the only languages I've written for anything other than educational reasons or quick hacks
12:07:08 <monochrom> s/new/few/
12:07:22 <benmachine> (haskell the former, perl/bash/PHP the latter)
12:15:00 <seanmcl> For the emacs users out there, is there a way to get ghci to interrupt when it's printing a lot of output:  e.g. let loop x = x : loop x.  loop 5.  I'm not able to interrupt ghci using C-cC-c.  I end up having to kill the interactive buffer.
12:15:26 <copumpkin> are you using a post-6.10.1 version of ghc?
12:15:31 <seanmcl> yes
12:15:38 <seanmcl> GHCi, version 6.10.2: http://www.haskell.org/ghc/  :? for help
12:15:42 <copumpkin> hmm
12:16:00 <copumpkin> because I remember in 6.10.1 it wasn't possible to stop ghci even outside of emacs
12:16:17 <copumpkin> you had to ctrl+z and then kill
12:16:19 <seanmcl> I can stop a loop, e.g. let loop x = loop x
12:16:27 <copumpkin> ah
12:16:43 <seanmcl> but when it's dumping lots of useless output I can't
12:16:54 <Cale> Hmm, 6.10.2 is still on editline
12:17:19 <Cale> (so it has more in common with 6.10.1 than 6.10.3 with regard to input handling)
12:17:39 <seanmcl> should I upgrade to 6.10.3?
12:17:50 <Cale> Well, 6.10.4 at this point
12:17:54 <seanmcl> :)
12:17:59 <monochrom> kill_it = hit ctrl-c >> kill_it    <-- try this :)
12:18:01 <seanmcl> would you try it out
12:18:14 <Cale> I'll try it
12:18:45 <Cale> How do I get a ghci buffer in the first place?
12:18:55 <seanmcl> from a haskell file, C-cC-l
12:18:58 <seanmcl> or just M-x shell
12:18:59 <seanmcl> ghci
12:19:49 <Cale> hmm, seems that my installation of haskell-mode is broken
12:20:01 <seanmcl> that's ok
12:20:04 <seanmcl> just M-x shell
12:20:15 <seanmcl> doesn't seem to be a property of haskell-mode
12:20:21 <seanmcl> rather ghci+comint
12:20:36 <Cale> yeah, C-c C-c works
12:20:47 <seanmcl> for loop x = x : loop x?
12:20:56 <Cale> 1705,1706,17  C-c C-cInterrupted.
12:21:00 <seanmcl> great
12:21:04 <seanmcl> 6.10.4?
12:21:16 <Cale> 6.10.3 in this case, but 6.10.4 ought to be the same
12:21:22 <seanmcl> ok, thanks for your help
12:21:39 <Cale> 6.10.{1,2} were using editline, which was a piece of crap
12:21:46 <seanmcl> :)
12:21:57 <seanmcl> oh, nonsequiter
12:22:10 <seanmcl> I want to be able to parse \ in strings
12:22:26 <Cale> Parse in what sense?
12:22:28 <seanmcl> Is this possible with editline/whatever ghc is using now
12:22:38 <seanmcl> I want the user to be able to write P /\ Q ==> R
12:22:43 <seanmcl> for P & Q ==> R
12:22:52 <seanmcl> but I can't parse this as a string
12:23:08 <seanmcl> since ghci says '\ ' is not a valid character
12:23:17 <Berengal> seanmcl: '\\'
12:23:21 <seanmcl> now the user must write P /\\ Q
12:23:25 <Cale> If you write it in quotes, you have to escape the \
12:23:27 <seanmcl> Right, I want to avoid that
12:23:34 <Cale> The user shouldn't have to write it that way
12:23:36 <seanmcl> Just wondering if it's possible with editline hacking
12:23:38 <Cale> only the programmer
12:24:04 <Cale> If you use getLine, you'll see that it doesn't have that problem
12:24:05 <seanmcl> If I write my own commandline tool, I can parse P /\ Q
12:24:20 <Cale> You can also define /\ as an infix operator
12:24:35 <Cale> > let p /\ q = p^2 + q^2 in 5 /\ 7
12:24:37 <lambdabot>   74
12:24:39 <seanmcl> Oh, I see what you mean
12:24:50 <seanmcl> sorry, I explained poorly
12:25:07 <seanmcl> I'm translating an ocaml program that uses camlp4's quotations
12:25:21 <seanmcl> so a formula is <<P /\ Q ==> R>>
12:25:27 <seanmcl> These formulas get parsed by << >>
12:25:41 <seanmcl> I was hoping ot do the same in ghci using parse "P /\ Q ==> R"
12:25:47 <seanmcl> but this does not work as a string
12:25:51 <Cale> seanmcl: seems natural to translate it into a program which uses template Haskell and quasiquotations
12:26:00 <seanmcl> oh, that's what I need.  Great.
12:26:07 <Berengal> quasiquotes seems the way to go indeed
12:26:11 <seanmcl> I'll check it out.  Rather new at this.  Thanks.
12:28:16 <fixp> @hoogle (a -> b) -> (a -> b) -> a -> (b,b)
12:28:16 <lambdabot> No results found
12:28:33 <fixp> @hoogle [a] -> a
12:28:34 <lambdabot> Prelude head :: [a] -> a
12:28:34 <lambdabot> Prelude last :: [a] -> a
12:28:34 <lambdabot> Data.List head :: [a] -> a
12:28:50 <fixp> hmm so it does work...
12:29:08 <Berengal> @type (,) <*> ?f <*> ?g
12:29:09 <lambdabot>     Couldn't match expected type `a -> b'
12:29:09 <lambdabot>            against inferred type `(a1, a2)'
12:29:09 <lambdabot>     Probable cause: `(,)' is applied to too many arguments
12:29:14 <Berengal> :/
12:29:21 <Berengal> Ooops
12:29:26 <Berengal> @type (,) <$> ?f <*> ?g
12:29:27 <Cale> :t (***)
12:29:27 <lambdabot> forall a a1 (f :: * -> *). (?f::f a, Applicative f, ?g::f a1) => f (a, a1)
12:29:28 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:29:37 <Cale> :t (&&&)
12:29:38 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:29:53 <Cale> > (length &&& id) "hello"
12:29:54 <lambdabot>   (5,"hello")
12:32:24 <fixp> oh thanks Cale, ithnk &&& is what i was looking for
12:38:04 <ekiru> Is it possible in Haskell to create(perhaps using typeclasses?) a polymorphic function to convert between different types?
12:38:18 <Cale> :t fromIntegral
12:38:19 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:38:22 <Cale> yes
12:38:41 <Berengal> @hoogle unsafeCoerce
12:38:41 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:38:43 <Berengal> :P
12:38:53 <monochrom> class Convert a b where convert :: a->b
12:38:57 <Cale> unsafeCoerce doesn't really convert, it just switches the type system off
12:38:57 <Gracenotes> you could perhaps have Convertible a b where convert :: ... darn it
12:39:08 <monochrom> instance Convert (IO a) a where convert = unsafePerformIO :)
12:39:09 <Gracenotes> curse ye monochrom
12:39:11 <Gracenotes> !
12:39:35 <jimmyjazz14> is there an easy to do the following... (getModificationTime "./file1") > (getModificationTime "./file2")
12:39:42 <Cale> I don't understand why people are mentioning unsafe operations in this context.
12:39:44 <kpreid> jimmyjazz14: liftM2 (>)
12:39:46 <Gracenotes> but there are bound to be overlaps (there are multiple conversions), and you must specify each individual conversion, as in adhoc polymorphism
12:39:46 <shapr> copumpkin: Dude, you missed a really mind bending talk with edwardk
12:39:52 <kpreid> @type liftM2 (>)
12:39:54 <lambdabot> forall a1 (m :: * -> *). (Ord a1, Monad m) => m a1 -> m a1 -> m Bool
12:39:55 <copumpkin> shapr: keep rubbing it in :(
12:39:59 <copumpkin> :)
12:40:12 <copumpkin> isn't he going to be giving a similar talk at the next boston meetup though?
12:40:15 <Cale> shapr: what about?
12:40:35 <shapr> copumpkin: Yeah
12:40:45 <Gracenotes> if m is the function monad, the type is Ord a => (n -> a) -> (n -> a) -> n -> Bool
12:40:46 <shapr> Cale: Using monoids for parallel stuff.
12:41:09 <shapr> Specifically, parsing UTF8, parsing regexps, finding line numbers and column numbers, and lots more
12:41:10 <Gracenotes> although, actually, it is the IO monad. So then it would be Ord a => IO a -> IO a -> IO Bool
12:41:11 <jimmyjazz14> the result kpreid thanks I always forget about those liftM functions
12:41:13 <shapr> Slides should be online soon.
12:41:21 <kpreid> it's not the whole story though
12:41:32 <kpreid> that just gets you something that will take (getModificationTime ...) twice
12:41:39 <kpreid> It would be nice to avoid that part too
12:41:44 <kpreid> @type on
12:41:46 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:41:51 <jimmyjazz14> oh?
12:42:04 <kpreid> @type liftM2 (>) `on` getModificationTime
12:42:05 <lambdabot> Not in scope: `getModificationTime'
12:42:19 <kpreid> @type liftM2 (>) `on` System.Directory.getModificationTime
12:42:20 <lambdabot> FilePath -> FilePath -> IO Bool
12:42:24 <kpreid> there we go
12:42:32 <jimmyjazz14> oh nice!
12:43:12 <seanmcl> :Cale Upgrading to 6.10.4 worked.
12:43:14 <kpreid> on's purpose is to map over both arguments of a 2ary function such as a comparison
12:43:28 <ekiru> Thanks, everyone who answered my question.
12:43:39 <kpreid> and liftM2 (>) is > within a monad
12:43:48 <Cale> seanmcl: cool
12:45:15 <fixp> @pl \x -> x *** x
12:45:15 <lambdabot> join (***)
12:45:24 <fixp> @t join
12:45:25 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:45:34 <fixp> @type join
12:45:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:46:24 <Cale> fixp: in this case, the monad m is (->) t
12:46:40 <fixp> Cale: yep
12:46:43 <fixp> thanks
12:46:50 <Cale> So the type of join becomes  (t -> (t -> a)) -> (t -> a)
12:59:53 <jmillikin> Is there any way to declare that all data types of some instance are also valid for another instance? Something like "instance ClassA a => ClassB a where ..."
13:01:41 <glguy> You can, but it quickly leads to ambiguities
13:03:51 <Saizan_> an instance like that actually declares that any type is an instance of ClassB
13:04:12 <Saizan_> and then requires a ClassA constraint if you use that instance
13:04:42 <Saizan_> because the context is not used when doing instance resolution
13:05:03 <Saizan_> s/used/considered/
13:07:26 <Cale> jmillikin: It's really only possible to select instances based on the structure of the type and not what other instances are available, because you can never tell that an instance is *not* available.
13:07:44 <Cale> jmillikin: (only that it definitely is)
13:08:17 <Cale> A future module always might come along and add a new instance that you'd not planned for.
13:09:23 <Cale> So for that reason, instance ClassA a => ClassB a will behave like  instance ClassB a  with regard to instance selection, and overlap with everything.
13:12:25 <FunctorSalad> I guess it was deliberately decided not to add a full-blown backtracking search for instances..? (due to unpredictability?)
13:13:12 <Cale> Well... there are various ways to do instance selection, but separate compilation makes the approaches available somewhat limited.
13:13:46 <Cale> There are several switches to control the way that GHC selects instances.
13:14:38 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
13:16:34 <Cale> It's a surprisingly subtle issue.
13:17:22 <FunctorSalad> indeed
13:26:00 <lpsmith> isn't there a way to have darcs bundle up some patches in something easily sent by email,  but where you send the email?
13:26:30 <Saizan_> darcs send -O
13:26:42 <lpsmith> thanks
13:26:53 <lpsmith> I read the help, somehow missed it
13:26:59 <Cale> (or -o <filename> )
13:27:10 <heatsink> oh, I didn't know it would auto-generate file names
13:27:42 <heatsink> In writing a large program, I've fallen into the practice of defining a monad for each major stage of execution.  Is this typical?
13:28:22 <monochrom> I don't know "majar stage of execution". But moadic habit is usually OK.
13:28:56 <Berengal> In writing any program, I've fallen into the practice of using applicatives everywhere...
13:29:10 <copumpkin> applicative addiction can be cured
13:29:18 <Berengal> How?
13:29:31 <heatsink> Does it involve using a patch?
13:29:39 <copumpkin> not sure, but I need to keep telling myself that or I lose hope
13:30:33 <monochrom> applicative addiction can be cured by arrow addiction.
13:30:50 <Saizan_> not sure which is worse
13:31:04 <Berengal> Functions are applicative arrows...
13:31:10 <monochrom> Oh, it just procrastinates the real problem. :)
13:31:21 <heatsink> monochrom, my 'main' is sort of a pipeline with stages.
13:32:20 <monochrom> The idea is that you have finite life. If every switching wastes you another 5 years, you're in good shape.
13:37:41 <shapr> lambdabot: @users
13:37:42 <lambdabot> Maximum users seen in #haskell: 658, currently: 593 (90.1%), active: 16 (2.7%)
13:43:17 <hasenov> @hoogle (a -> b) a
13:43:17 <lambdabot> No results found
13:43:37 <hasenov> @hoogle (a -> b) [c]
13:43:38 <lambdabot> No results found
13:43:44 <copumpkin> huh?
13:43:48 <heatsink> That's a type application
13:43:48 <mmorrow> i think i've just found something that implicit params can give you that's both useful + no other way to do it
13:43:53 <mmorrow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7512
13:44:12 <mmorrow> you can use implicit params to get "classes where you get to control instance selection"
13:44:26 <mmorrow> with almost the same syntax as classes
13:44:40 <hasenov> @hoogle (a -> b) [a] [b]
13:44:40 <lambdabot> No results found
13:44:47 <copumpkin> hasenov: what are you looking for?
13:44:55 <copumpkin> mmorrow: that's cool
13:44:56 <mmorrow> the only difference being: s/Eq a =>/?eq::Eq a =>/
13:45:07 <hasenov> @hoogle (a -> b) -> [a] -> [b]
13:45:08 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
13:45:08 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
13:45:08 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
13:45:12 <mmorrow> copumpkin: totally, i think this might turn out to be really useful
13:45:37 <hasenov> copumpkin: hoogle test
14:03:54 <hackagebot> derive-gadt 0.1.1 - Instance deriving for (a subset of) GADTs. (MattMorrow)
14:04:16 <copumpkin> @hackage derive-gadt
14:04:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive-gadt
14:05:37 <mmorrow> just added a link to the haddocks, since the build fails on hackage
14:06:58 <mmorrow> copumpkin: i've been running it like this
14:07:00 <mmorrow> $ derive-gadt -a < GADTTest.hs | hstidy --out=decls
14:07:28 <mmorrow> running through hstidy just trades the TH prettyprinter for the haskell-src-exts one
14:07:45 <mmorrow> which may or may not be more desirable depending on the shape of the output code
14:08:11 <mmorrow> (derive-gadt and hstidy are both included in that pkg)
14:09:03 <mmorrow> i need to add an exact description of the class(es) of GADTs it handles, etc though ...
14:09:24 <mmorrow> (and what exactly it is that it's generating too)
14:09:46 <desp> "Inferred type is less polymorphic than expected; Quantified type variable `b' escapes"
14:10:04 <desp> But I do want it to escape...
14:10:20 <Cale> desp: Then you shouldn't be using higher rank types. ;)
14:10:39 <Saizan_> mmorrow: does hstidy preserve comments?
14:10:41 <mmorrow> desp: in this wrt GADTs?
14:11:02 <mmorrow> Saizan_: no unfortunately, but this is only because haskell-src-exts doesn't
14:11:12 <desp> Cale, mmorrow: http://pastie.textmate.org/558927
14:11:25 <mmorrow> Saizan_: but once that gets added to haskell-src-exts, hstidy will ;)
14:11:26 <desp> Cale, mmorrow: reifyTypeNat 1 (\(_ :: t) -> (undefined :: t :^: t))
14:11:58 <mmorrow> Saizan_: "$ ... | hstidy -e" is really handy i've found
14:12:11 <mmorrow> Saizan: e.g. "cat package.conf | hstidy -e"
14:12:19 <desp> I wanted to raise a type to a power given by a value.
14:12:33 <desp> And have the resulting type "escape".
14:12:46 <desp> I guess that's not possible?
14:12:52 <Saizan_> mmorrow: ooh, that's nice
14:13:34 <Cale> desp: ... I'm not sure what you mean by that...
14:13:39 <mmorrow> Saizan_: totally. this has given me a whole new appreciation for Show instances that are valid haskell syntax
14:13:49 <Cale> desp: You want to turn a number at runtime into a type? That's not possible.
14:13:51 <mmorrow> writeFile "asdf.hs" (show foo)
14:13:54 <heatsink> I think you have to box an escaping type as an existential, or pass it to a continuation.
14:13:54 <mmorrow> :q
14:14:00 <mmorrow> cat asdf.hs | hstidy -e
14:14:21 <Cale> desp: Types exist at compile-time only.
14:14:33 <desp> Cale: have you seen the source for reifyTypeNat?
14:14:42 <desp> Cale: it's straight out of Oleg's paper ;)
14:14:54 <Cale> desp: Is it correct?
14:15:19 <mmorrow> desp: that code compiles/loads fine for me in ghci
14:15:25 <desp> The code is correct.
14:15:42 <desp> As heatsink wrote above, the value gets turned into an existential, and passed to a continuation.
14:15:48 <mmorrow> desp: ah. what was the decl that caused the escaping var error?
14:15:58 <desp> heatsink: but I don't understand why you call that "escaping"; the type is boxed-in.
14:16:04 <Saizan_> you can create a type out of a value but you'll only be able to use it as an existential
14:16:09 <desp> mmorrow: reifyTypeNat 1 (\(_ :: t) -> (undefined :: t :^: t))
14:16:12 <mmorrow> ah
14:16:32 <soupdragon> huh
14:16:36 <desp> Saizan_: okay, so that answers my question.
14:16:40 <desp> Thanks.
14:16:42 <desp> :/
14:16:46 <soupdragon> ?
14:17:07 <Saizan_> unless you also create a witness that it's equal to another type, via a gadt
14:17:09 <desp> soupdragon: there's no escape!
14:17:14 <soupdragon> from what
14:17:20 <desp> soupdragon: pgup
14:17:36 <desp> Saizan_: do you have any examples?
14:17:39 <Saizan_> but still you'll get to use that withness only in the body of case expressions pattern matching on it
14:18:46 <soupdragon> what
14:19:29 <Saizan_> desp: if you define data Foo a where FooInt :: Foo Int; FooBool :: Foo Bool, a function of type forall r. Foo r -> r -> Something, can pattern match on the Foo argument to determine the type of the second argument
14:19:46 <mmorrow> desp: i think you're going to need a GADT here, then use case analysis on the cons in an existential context to recover the type
14:19:48 <mmorrow> (or something)
14:20:05 <mmorrow> yeah, what Saizan_ said
14:20:37 <Cale> desp: You can try to reflect it as a TypeNat, but you run into another problem
14:20:47 <soupdragon> desp okay ..
14:20:56 <Cale> desp: It's not possible to infer that TypeNat (t :^: t) from TypeNat t
14:21:03 <Saizan_> bar FooInt i = show (i + 1); bar FooInt b = show (not b)
14:21:22 <copumpkin> :^: is exponent?
14:21:26 <Saizan_> the second one is FooBool
14:21:27 <Cale> copumpkin: yes
14:21:42 <copumpkin> dammit, there go my dreams of type-level RSA
14:21:43 <desp> Saizan_: thank you.
14:21:56 <desp> copumpkin: what's the problem with that one? :)
14:21:58 <Cale> desp: After all, I could come along and write  instance TypeNat Char where reflectTypeNat c = ord c
14:22:10 <copumpkin> desp: I need the exponentiation! :(
14:22:12 <Cale> (or fromIntegral (ord c) rather)
14:22:15 <mmorrow> ... | hstidy -e | HsColour -tty | less -r
14:22:18 <mmorrow> is really nice too
14:22:29 <desp> copumpkin: but if you need purely type-to-type exponentiation, I already have that.
14:22:35 <mmorrow> (or s/-e/-whatever/ depending on what the code is..)
14:22:42 <Cale> desp: and then maybe do something else stupid like  type instance Char :^: Char = Bool
14:23:10 <desp> Cale: I'm not sure what's the problem.
14:23:44 <soupdragon> desp what are you doing
14:24:06 <desp> Cale: I thought GHC is able to use the type instances I have defined to translate :+:, :*:, :^: into the low-level S's and Z's.
14:24:12 <Cale> desp: The problem is that the type of the parameter to reifyTypeNat doesn't tell you that TypeNat (b :^: b) is the case, only that TypeNat b is
14:24:37 <Cale> desp: It's not guaranteed that b is actually made of S's and Z's.
14:24:50 <desp> soupdragon: http://varsztat.com/physics/Physics.hs
14:24:53 <Cale> b could be Char
14:25:05 <soupdragon> you're not gonna tell me ok
14:25:05 <Cale> (somewhat stupidly, but it's possible)
14:25:26 <desp> soupdragon: I'm doing physics with units verified by the type system
14:26:05 <desp> soupdragon: I thought showing you would be the best answer, don't be sad.
14:26:08 <Cale> desp: Does that make sense?
14:26:26 <soupdragon> desp "don't be sad"?
14:26:37 <soupdragon> desp don't be a daft prick
14:26:42 <Cale> desp: I could come along in a future module and write  instance TypeNat Char where reflectTypeNat _ = 42
14:26:53 <Cale> desp: and then  type instance Char :^: Char = Bool
14:27:02 <Cale> and not write an instance of TypeNat for Bool
14:27:24 <Cale> So there's nothing which guarantees that TypeNat (t :^: t) from the fact that TypeNat t
14:27:43 <desp> Cale: do you see a way to guarantee that?
14:27:57 <copumpkin> Cale: but you can avoid it with GADTs or that post on haskell-cafe
14:28:31 <desp> soupdragon: I didn't mean to offend you, sorry.
14:29:14 <desp> copumpkin: "that post"? :)
14:29:21 <Cale> soupdragon: in desp's defence, "<soupdragon> you're not gonna tell me ok" kind of sounds like you're sad about it.
14:29:34 <copumpkin> desp: can't remember it is
14:29:39 <copumpkin> class Nat n where
14:29:39 <copumpkin>   caseNat :: forall r. n -> (n ~ Z => r) -> (forall p. (n ~ S p, Nat p) => p -> r) -> r
14:29:45 <copumpkin> desp: that's the basic idea though
14:29:53 <copumpkin> you make a class that only S and Z can reasonably satisfy
14:30:21 <Cale> can *reasonably* satisfy
14:30:32 <Cale> But it doesn't mean that I can't write *stupid* instances ;)
14:30:34 <copumpkin> well yeah, you could caseNat = undefined
14:30:35 <copumpkin> lol
14:30:36 <copumpkin> yeah
14:30:41 <desp> Heh.
14:30:47 <copumpkin> but the GADT peano natural could work too
14:31:50 <soupdragon> Cale fed up of being jerked around when you try and talk to someone
14:31:57 <copumpkin> o.O
14:32:15 <Saizan_> the nice thing is that you can use the coercions provided as context there, just like a gadt
14:32:57 <Saizan_> though i'm not sure what advantage you get over just using a gadt..
14:33:00 <mauke> soupdragon: you are making me unhappy
14:33:05 <copumpkin> Saizan_: looks fancier
14:33:38 <soupdragon> mauke, it's not on purpose
14:33:41 * Saizan_ doesn't know if witnessNat is an advantage or not
14:36:04 <copumpkin> Saizan_: witnesses get you sent to jail, definitely not a good thing
14:36:10 <copumpkin> leave no witnesses, is how I roll
14:36:19 <Saizan_> hah :)
14:36:37 <desp> copumpkin: http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html -- this must be "that post" :)
14:37:03 <copumpkin> desp: yeah :) it's an awesome post, gave me hours of entertainment and of pestering Saizan_ to try to figure it out
14:37:11 <copumpkin> (the various exercises at the end)
14:37:16 <copumpkin> and I'm still not done :P
14:37:24 <desp> I think I'll try, as well.
14:38:12 <soupdragon> any point in 'peano integers at the type level' or this is all just fun?
14:38:55 <copumpkin> soupdragon: my interest in them was mostly for my own edification
14:39:23 <FunctorSalad> soupdragon: I wondered whether they would be useful for making data structures for protocols with fixed-size packets
14:39:27 <desp> soupdragon: type-level integers allow me to keep track of a value's physical dimensions.
14:39:28 <Saizan_> i guess desp uses them for dimensions of vectors?
14:39:28 <Alpounet> Hi guys. Are there manifold related packages ?
14:39:58 <desp> soupdragon: for example, type Meter = Quantity (One ::: Zero ::: Zero ::: Nil)
14:40:08 <desp> soupdragon: and type Newton = Quantity (One ::: One ::: MinusTwo ::: Nil)
14:40:51 <desp> Saizan_: I remember saying that you'd prefer modelling the physical dimensions separately from the units, right?
14:41:00 <Saizan_> desp: right
14:41:32 <desp> Saizan_: what would be the benefit?  I'm afraid it could complicate the usage of the resulting types.
14:42:08 <soupdragon> desp you wont be able to complete this in haskell, I'm wondering about practical caese
14:42:18 <soupdragon> cases*
14:42:29 <Saizan_> desp: well, i've never written much scientific code, but i guess you can keep track of what's Time vs. Space regarless if you're misuring either one in seconds/meters/feet ..
14:44:21 <Saizan_> units of measure don't uniquely determine a physical quantity, in principle
14:44:52 <copumpkin> ChilliX_: is there a fundamental reason TH-callable functions must be in an imported module and not in the one you use them in?
14:44:59 <Saizan_> but i guess you also have to make a tradeoff with what you can do with haskell :)
14:45:34 <FunctorSalad> copumpkin: IIRC the manual says that it would just be hard to implement rightly
14:45:51 <FunctorSalad> (you mean the "stage restriction", right?)
14:45:57 <copumpkin> FunctorSalad: I think that's what it's called
14:46:22 <copumpkin> FunctorSalad: that's sad, it'd be so nice to use it to get rid of even more boilerplate
14:46:25 <copumpkin> in a lightweight manner
14:47:03 <FunctorSalad> well, making a module "TH" isn't that heavyweight ;)
14:50:29 <mmorrow> copumpkin: that restriction just "makes things easier" (to implement)
14:50:38 <mmorrow> copumpkin: there's no fundamental limitation
14:50:56 <mmorrow> copumpkin: (although there'd probably be certain things that you (obviously) couldn't do)
14:51:29 <mmorrow> although i'm not sure what that'd be
14:52:29 <mmorrow> if TH had an `eval' function, the awesomeness level would increase by 100 i think
14:52:36 <Cale> Measuring things in feet is silly and should never happen ;)
14:52:41 <mmorrow> , evalQ [|42|]
14:52:46 <lunabot>  <<Integer>>
14:52:52 <mmorrow> , eval "[|42|]"
14:52:55 <lunabot>  <<Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp>>
14:53:11 <mmorrow> (clearly such a function is possible)
14:53:37 <Cale> , evalQ (eval "[|42|]")
14:53:38 <mmorrow> it's just that if you were to use the one in lunabot, you'd need to link to ghc..
14:53:38 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Q a'
14:53:48 <mmorrow> , [$ty| evalQ |]
14:53:52 <lunabot>  forall a . (Data a, Ppr a) => Q a -> Dynamic
14:54:15 <mmorrow> it prettyprints (and tidies) the (Q a), then runs `eval' on that
14:54:23 <Saizan_> Cale: but you can measure space in seconds :)
14:54:43 <mmorrow> the (Data a) constraint is there because of
14:54:45 <Cale> Saizan_: In light-seconds, sure.
14:54:48 <mmorrow> , [$ty| cleanNames |]
14:54:51 <lunabot>  forall a . Data a => a -> a
14:55:03 <mmorrow> , [$ty| ppDoc |]
14:55:06 <lunabot>  forall a . (Data a, Ppr a) => a -> Doc
14:55:38 <Saizan_> one thing that feels lacking in TH is the ability to embed any haskell value without "serializing" it to constructors
14:55:57 <mmorrow> , evalQ [|eval "42"|] {- ohh, did you mean this? -}
14:56:00 <lunabot>  <<Dynamic>>
14:56:00 <RayNbow> hmm...
14:56:05 <Cale> But, isn't that an obvious restriction anyway?
14:56:14 <Cale> TH is meant to generate Haskell code, isn't it?
14:56:20 <Saizan_> or maybe that'd be more appropriate for eval..
14:56:37 * RayNbow rebooted his router... yet managed to stay connected to Freenode? O_O
14:56:56 <mmorrow> Cale: yes, but ideally you could use code you've just generated to generate some more code ...
14:57:00 <Saizan_> RayNbow: packets can wait :)
14:57:05 <mmorrow> (and so on)
14:57:20 <RayNbow> Saizan_: yeah, but it still amazes me every time :p
14:57:53 <Cale> mmorrow: Oh, that sounds like something different...
14:58:58 <Cale> mmorrow: I just mean it seems relatively obvious that you can't take a Data.Map and stick it into the middle of some code without turning it into some code which reconstructs the Map.
14:59:13 <mmorrow> , evalQ [|eval "[|42|]"|]
14:59:16 <lunabot>  <<Dynamic>>
14:59:36 <mmorrow> Cale: ohh, i see what you mean. hmm.
14:59:59 <Cale> It would be interesting, I suppose, to allow arbitrary data embedded in the middle of Haskell code, but then we'd probably want to ditch textfiles altogether.
15:00:07 <hackagebot> jmacro 0.1 - QuasiQuotation library for programmatic generation of Javascript code. (GershomBazerman)
15:00:24 <mmorrow> Cale: err, i'm slightly confused now what we're talk about
15:00:34 <mmorrow> Saizan_: how do you mean exactly?
15:00:53 <mmorrow> Saizan_: (by "serializing")
15:01:18 <mmorrow> ooh, cool. js QQ
15:01:27 <mmorrow> @hackage jmacro
15:01:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/jmacro
15:01:51 <mmorrow> nice, it has its own parser too
15:02:42 <mmorrow> Saizan_: ahhh, i know exactly how you mean i think
15:03:06 <Saizan_> e.g. if i create a Data.Map and what to use it in the generated code i need to create a fromList [...] expression
15:03:08 <Cale> mmorrow: What I think Saizan means is that if you have TH code which gets hold of an Array or Map or function or some other datastructure at compile time, there's no way to generate code which binds that value to a variable at runtime without doing some work at compile time to turn it back into an expression which will evaluate to that value again.
15:03:12 <Cale> yes
15:03:39 <mmorrow> Saizan_: if you make Data.Map as instance of Lift, you can go to an ExpQ
15:03:40 <Saizan_> yeah, Cale said it best :)
15:04:10 <mmorrow> Saizan_: but unfortunately it's impossible to make a (useful) (?) instance of Lift for a function type
15:04:29 <mmorrow> Cale: ah, totally
15:04:42 <mmorrow> yeah i agree, that would be really nice
15:04:49 <Cale> I think the natural extension of this is not to keep source code in textual format at all. Once you start allowing arbitrary datastructures embedded in generated code, why not in the source file?
15:04:50 <Saizan_> mmorrow: right, though suppose i'm using the ghc-api to create such code at runtime, maybe multiple times, using lift there would be quite wasteful
15:05:13 <mmorrow> (so essentially, this is the same as saying that *any* haskell type automagically has instance of Lift)
15:05:29 <Cale> mmorrow: more or less, yeah
15:05:30 <mmorrow> lift (\x -> x) ====> [|\x -> x|]
15:05:40 <Saizan_> one way around this is to "lambdalift" the code you're generating, so you can pass the value as argument once you've the function
15:06:01 <Cale> mmorrow: Perhaps without necessarily having the ability to actually inspect the structure of the lifted result in a meaningful way.
15:06:23 <mmorrow> Cale: but i think that's an implication of this though (for better or for worse)
15:06:43 <mmorrow> , [|\x->x|]
15:06:45 <lunabot>  LamE [VarP x_0] (VarE x_0)
15:06:48 <mmorrow> which complicates things..
15:07:02 <mmorrow> lift id /= lift (\x->x)
15:07:06 <mmorrow> e.g.
15:07:22 <yitz> Cale: hmm, then Haskell basically becomes Lisp
15:07:35 <Cale> yitz: TH was basically supposed to do that anyway? :)
15:07:39 <mmorrow> yitz: essentially, yes. (but at compile-time only..)
15:07:52 <Cale> You still have typechecking.
15:08:01 <yitz> true
15:08:01 <mmorrow> well, at runtime too i guess, but then you'd need to be linked to ghc to splice..
15:08:12 <mmorrow> *and* spliced code is bytecode..
15:08:35 <mmorrow> err, not true.. the code that generates the code that will be spliced is compiled to and run as bytecode
15:09:05 <Cale> hmm, is there really no way to compile it properly?
15:09:16 <mmorrow> so i guess since (ghc) haskell is compiled, for it to /actually/ approach what lisp does it would need to dynamically generate/assemble/link machine code..
15:09:55 <mmorrow> Cale: there is a way for sure, but ghc would need to get an assembler..
15:09:56 <heatsink> To lift a recursively defined function, wouldn't you need the ability to test functions for (address) equality?
15:10:36 <mmorrow> heatsink: i'm not sure. i'd be very interested to pin down exactly what you'd need to do however.
15:11:21 <Cale> Well, the idea is that the code which generated that expression (which your value may contain references to) is already compiled, because it's running. So you just link with that, no?
15:11:23 <mmorrow> because surely this is possible, questions of feasibility aside
15:11:56 <mmorrow> Cale: TH code in a splice is run during typechecking/etc
15:12:03 <mmorrow> interleaved with ..
15:12:07 <mmorrow> is a better way to put it
15:12:22 <mmorrow> $(......) == $(......)
15:12:29 <mmorrow> being an example of why
15:13:04 <mmorrow> ... $(..... [|$(......) == $(......)|] ....) ....
15:13:16 <mmorrow> and so on
15:13:46 <Cale> mmorrow: right... I just mean, take all the code which is meant to run at compile-time, and stash it (or possibly a subset of it) in the final executable as well.
15:14:11 <Cale> mmorrow: So as to be able to resolve references to it in lifts of partially-evaluated expressions.
15:14:29 <JuanDaugherty> is darcs still the highest profile haskell app?
15:15:04 <soupdragon> yes
15:15:07 <JuanDaugherty> (asked this by mistake in #lisp)
15:15:15 <Cale> heh
15:15:25 <mmorrow> Cale: oh, i see what you mean, totally. so the only thing that's run as bytecode is code that needs to be run in order to compile a module in the first place
15:15:39 <Cale> mmorrow: Maybe not even that?
15:15:42 <JuanDaugherty> what is MultiDIm? someone mentioned it there but Google turned up nothing
15:15:46 <Cale> mmorrow: Can't that be compiled too?
15:16:16 <Cale> mmorrow: as long as there's not some kind of circular reference...
15:16:17 <mmorrow> Cale: well, and bytecode interpretation can arbitrarily weave in and out of compiled code too..
15:16:34 <Cale> mmorrow: I'm not 100% sure I see the reason for bytecode
15:16:37 <mmorrow> Cale: i'm not sure, but i'd like to find out
15:16:40 <Cale> (in the first place)
15:16:56 <Cale> Isn't it just because it takes less time to generate?
15:17:08 <Cale> (even though it runs slower in the end)
15:17:22 <JuanDaugherty> machine independence and speed are the usual suspects
15:17:32 <mmorrow> Cale: the other option would be to extract splices from the current module being compiled, pause compilation of that module, compile the splice code to machine code, run that, get code back, insert that into the paused module, then resume that
15:17:35 <mmorrow> or something
15:18:17 <Cale> JuanDaugherty: Never heard of multidim
15:18:36 <JuanDaugherty> yeah, I think it was a goog
15:18:41 <JuanDaugherty> *goof
15:18:44 <mmorrow> but TH code itself in a module (that's not used to produce that module in the first place) is of course compiled to machine code
15:19:13 <mmorrow> Cale: yeah, it'd be an interesting circular dance you'd have to do
15:19:34 <mmorrow> or maybe s/circular/staged/
15:20:01 <mmorrow> so like for instance,
15:20:14 <Cale> Just keep doing it until there are no splices left, and if you never reach that point, then compilation doesn't terminate?
15:20:16 <mmorrow> $(someFunctionInACompiledLib 42 :: ExpQ)
15:20:20 <mmorrow> the bytecode is just
15:20:33 <vav> JuanDaugherty: maybe the dimensional library? dimensional analysis stuff? http://hackage.haskell.org/packages/archive/pkg-list.html has misc. haskell stuff categorized.
15:20:34 <mmorrow> "apply someFunctionInACompiledLib to 42 and evaluate it"
15:20:40 <mmorrow> which immediately jumps into machine code
15:20:53 <Cale> yeah.
15:21:35 <Cale> But nothing says you couldn't first compile that expression into machine code
15:21:42 <mmorrow> totally
15:21:46 <Cale> It's just maybe more expensive than you'd like
15:22:05 <mmorrow> (and i agree with you, it would be awesome to s/bytecode/machine code/ here)
15:22:50 <Cale> mmorrow: Did you see my mathematica implementation of list comprehensions? :)
15:23:24 <mmorrow> if it was compiled to machine code instead of bytecode, and say you have a really time-intensive/whatever chunk of code that you want to stick into a splice, currently you'd have to put it in a compiled pkg, then just call it in a splice, rather than write it inline
15:23:24 <JuanDaugherty> vav, thx
15:23:30 <mmorrow> Cale: ooh, no
15:24:07 <Cale> FlatMap[f_, expr_] := Flatten[Map[f, expr], 1]
15:24:07 <Cale> SetAttributes[Comprehend, HoldAll]
15:24:07 <Cale> Comprehend[expr_] := {expr}
15:24:07 <Cale> Comprehend[expr_, {var_, xs_}, rest___] := FlatMap[Function[var, Comprehend[expr, rest]], xs]
15:24:07 <Cale> Comprehend[expr_, cond_, rest___] := If[cond, Comprehend[expr, rest], {}]
15:24:24 <Cale> Trivial ;)
15:24:28 <mmorrow> heh, cool
15:25:40 <Cale> Of course, it's possible to pick a nicer syntax than that for generators, but not one which shows up on IRC very nicely.
15:29:06 <Cale> SetAttributes[Comprehend, HoldAll]  just ensures that all the parameters to Comprehend are not evaluated before Comprehend gets to manipulate them. So there's nothing to worry about with regard to 'var' already being in scope, say.
15:42:51 <tokenblack> yo
15:43:08 <tokenblack> http://shootout.alioth.debian.org/u64q/benchmark.php?test=meteor&lang=ghc&id=5 0_o
15:43:25 <tokenblack> they did it wrong
15:51:36 <mmorrow> Cale: i don't know mathematica at all really. what does var do/is for there?
15:51:43 <dons> meteor.ghc-5.hs:143:15:
15:51:43 <dons>     Ambiguous occurrence `permutations'
15:51:43 <dons>     It could refer to either `Main.permutations', defined at meteor.ghc-5.hs:56:0
15:51:46 <dons>                           or `Data.List.permutations', imported from Data.List at meteor.ghc-5.hs:11:0-15
15:52:38 <mmorrow> permuting meteors sounds like risky business
15:53:08 <yitz> hiding permutations
15:53:25 <copumpkin> they added permutations to Data.Lits in 6.10
15:53:55 <Peaker> That's one of the reasons why I hate unqualified imports!
15:54:04 <Peaker> You can actually break code by adding new exports to modules
15:54:09 <dons> yep
15:54:24 <Peaker> I hate that Haskell encourages unqualified imports by having them have the most straightforward syntax
15:54:34 <Peaker> Python was smarter about this with: "from blah import *"
15:54:42 <yitz> Peaker: I agree. Some look at it the other way around - they hate adding new exports to standard libraries
15:54:42 <Peaker> (and discouraging it)
15:54:57 <Peaker> yitz: that's absurd :-)
15:55:51 <yitz> Peaker: I agree with your approach. But it's not exactly absurd.
15:56:23 <yitz> modules are Haskell's only namespace mechanism. So changing the export list is essentially changing an API.
15:56:43 <Peaker> yitz: well, preferring support for unqualified imports (which have several other horrible disadvantages) over the ability to add new backwards compatible additions to libraries? I find that absurd
15:56:53 <Peaker> yitz: In a backwards compatible way
15:57:00 <yitz> agreed
15:57:02 <mmorrow> hmmmm, iirc if a datatype has <=3 cons, then the con tag can fit entirely in the tag bits in a ptr, so then you don't have to follow the infoptr every time you case... maybe that program could be sped up by doing something other than
15:57:04 <mmorrow> data Direction = E | SE | SW | W | NW | NE
15:57:09 <mmorrow> (> 3 cons)
15:57:27 <mmorrow> err wait, 3 *bits*..
15:57:32 <mmorrow> , 2^3
15:57:33 <lunabot>  8
15:57:37 <mmorrow> n/m :)
15:57:47 <mmorrow> (3 bits on 64bit..)
15:58:06 <Cale> mmorrow: Function[var, ...] is like \var -> ...
15:58:22 <mmorrow> Cale: where is "var" used? (is it?)
15:58:49 <mmorrow> (that's the root of my confusion)
15:59:00 <Peaker> mmorrow: everything's 3-bit aligned?
15:59:19 <mmorrow> Peaker: infotables must be i suppose
15:59:25 <Cale> mmorrow: It's used as the parameter to Function, but it is held unevaluated. The intention is that it's a symbol.
15:59:59 <Cale> You might write something like  Comprehend[x + y, {x,{1,2,3}}, {y,{10,20}}]
16:00:07 <Cale> which would be the equivalent of
16:00:19 <Cale> > [x + y | x <- [1,2,3], y <- [10,20]]
16:00:20 <lambdabot>   [11,21,12,22,13,23]
16:00:52 <mmorrow> i don't see though anywhere where the "var" variable is used in the "lambda though" (am i looking at this the wrong way?)
16:00:59 <benmachine> Comprehend is a silly name for a function
16:01:05 <mmorrow> err, * "lambda" though
16:01:11 <benmachine> it should just return a string "hmm, yes, I see."
16:01:19 <Cale> benmachine: It's an implementation of list comprehensions
16:01:33 <mmorrow> benmachine: comprende?
16:01:44 <mmorrow> "hmm, yes i see" :)
16:01:44 <benmachine> >_>
16:01:48 <Cale> mmorrow: It is used eventually
16:01:57 <Cale> mmorrow: Probably elsewhere in the input to Comprehend
16:02:32 <mmorrow> Cale: ohh, so i guess there's dynamic scoping or something going on then?
16:02:55 <Cale> In a sense.
16:03:09 <Cale> Really it's just that the parameters to Comprehend are not evaluated at all.
16:03:30 <Cale> and so variables are not evaluated, they just stay whatever symbols they were
16:04:02 <mmorrow> hmm, i think i'm confused by something that's really obvious if you know mathematica
16:04:11 * mmorrow looks for a quick overview
16:04:16 <Cale> Mathematica's evaluation model is basically tree rewriting
16:04:40 <Cale> You directly write rules for rewriting expression trees into other expression trees.
16:04:42 <mmorrow> ok, i know how to ask:
16:04:44 <mmorrow> is
16:04:46 <mmorrow> FlatMap[Function[var, Comprehend[expr, rest]], xs]
16:05:03 <mmorrow> === flatMap (\var -> comprehend expr rest) xs
16:05:04 <mmorrow> ?
16:05:27 <Cale> yes
16:05:53 <mmorrow> so then FlatMap[Function[var, Comprehend[expr, rest]], xs] === flatMap (const (comprehend expr rest)) xs ?
16:06:05 <Cale> no
16:06:12 <mmorrow> ! that's my confusion
16:06:18 <Cale> because var might occur in expr
16:06:25 <mmorrow> ahh, i see now
16:06:27 <Cale> and it might occur in rest
16:06:36 <mmorrow> so we're symbolically manipulating representations here
16:06:39 <Cale> right
16:06:42 <mmorrow> ahh, ok
16:07:32 <Cale> (that's what the SetOptions thing let me do)
16:07:43 <Cale> Er, SetAttributes rather
16:08:36 <Cale> No evaluation at all is carried out on the parameters to Comprehend, so variables don't have a chance to be bound to their values.
16:08:45 <Cale> (if any)
16:10:34 <satsu> Hello
16:10:39 <Cale> hello
16:10:45 <satsu> Hows it going?
16:10:55 <Cale> good :)
16:11:06 <satsu> Thats good
16:11:18 <Cale> mmorrow: Mathematica has a really strange evaluation model, but it can be quite handy :)
16:11:24 <copumpkin> æ®ºäºº??
16:12:04 <tokenblack> dons, I heard that you are an haskell god
16:12:15 <copumpkin> lol
16:12:24 <Cale> å¯Ÿ
16:12:45 <satsu> I'm just starting to learn Haskell, could I hear a few suggestions from you people?
16:12:51 <Cale> satsu: sure thing
16:12:53 <copumpkin> sure thing!
16:12:55 <satsu> I've been browing books
16:12:55 <copumpkin> lol
16:13:16 <satsu> So yeah, about books to learn from?
16:13:22 <copumpkin> @where rwh
16:13:23 <lambdabot> is http://www.realworldhaskell.org/blog/
16:13:27 <copumpkin> @where lyah
16:13:27 <lambdabot> www.learnyouahaskell.com
16:13:28 <hackagebot> press 0.1.0 - Text templating language (BrandonBickford)
16:13:35 <Cale> @where wikibook
16:13:35 <lambdabot> http://en.wikibooks.org/wiki/Haskell
16:13:36 <copumpkin> (the latter isn't a book, but is a good online tutorial with cute pictures)
16:13:38 <tokenblack> lyah is sweet
16:13:40 <Cale> @where yaht
16:13:41 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
16:13:53 <SamB> @where gentle
16:13:53 <lambdabot> http://www.haskell.org/tutorial/
16:14:02 * SamB is a sadistic freak ;-P
16:14:08 <Cale> The 'gentle intro' isn't very gentle.
16:14:39 <Cale> Yeah, I'd recommend starting with Learn You a Haskell too, it seems fun :)
16:14:50 <satsu> Yeah, I got here from that site actually
16:14:58 <satsu> clicked a link and it sent me here
16:15:22 <Cale> :)
16:15:44 <Cale> satsu: If you have any questions about Haskell, don't hesitate to ask them here.
16:16:04 <satsu> Alright, sounds good
16:16:10 <satsu> thanks everybody
16:16:13 <gwern> @seen nomeata
16:16:14 <lambdabot> nomeata is in #xmonad, #haskell and #darcs. I don't know when nomeata last spoke.
16:16:25 <nomeata> Now you know
16:16:36 <satsu> http://www.realworldhaskell.org/blog/ seems to be down though
16:16:52 <nomeata> gwern: whatâ€™s up?
16:17:04 <gwern> nomeata: is darcswatch still running/working? the 2 patches outstanding for yi are just wrong, and I suspect more than one of the xmonadcontrib outstanding patches to be wrong
16:17:13 <Cale> http://book.realworldhaskell.org/read/
16:17:27 <nomeata> Last update Fri Jul 24 03:11:03 CEST 2009.
16:17:39 <nomeata> Thatâ€™s wrong I guess :-)
16:17:42 <Cale> @where+ rwh http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
16:17:43 <lambdabot> Nice!
16:17:49 <Cale> @where rwh
16:17:50 <lambdabot> http://www.realworldhaskell.org/blog/ read it online: http://book.realworldhaskell.org/read/
16:18:06 <Cale> satsu: Seems the actual book is still up
16:18:44 <satsu> Ah
16:18:44 <nomeata> gwern: if you want to have to remind me less often, you can add detection of stale locks to http://darcs.nomeata.de/darcswatch/src/LockRestart.hs :-)
16:18:46 <satsu> Thanks
16:18:53 <nomeata> (darcswatch lock removed and restarted it)
16:19:17 <nomeata> dons: ping
16:19:25 <satsu> Thanks again, i'll be back some time after I learn more
16:19:27 <gwern> I shouldn't know where to begin in it
16:19:44 * Cale struggles to get morrowind running stably under wine. Everything seems to work except that I get seemingly totally random crashes. :|
16:19:51 <ChilliX> copumpkin: Given that function defs in Haskell can be arbitrary recursive, it'd be hard to say which programs are even legal without that restriction
16:20:04 <mmorrow> jmacro looks nice
16:20:12 <nomeata> gwern: (I know, I guess I should do it myself)
16:20:18 * mmorrow will be using it for javascript from now on
16:20:53 <mmorrow> @where jmacro
16:20:54 <lambdabot> I know nothing about jmacro.
16:20:58 <mmorrow> @hackage jmacro
16:20:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/jmacro
16:21:31 <mmorrow> looks like it has the start of a typechecker too (and hygeinic names)
16:21:45 <mmorrow> *hygienic
16:22:47 <Peaker> does it let you build Javascript with combinators?
16:22:49 <nomeata> Anyone here bored and looking for a nice littel haskell programming task :-)
16:23:12 <mmorrow> nomeata: does it pay? :)
16:23:26 <mmorrow> Peaker: [$jmacro| function(x){return x;} |]
16:23:51 <nomeata> mmorrow: it pays by reducing boredom :-)
16:23:54 <mmorrow> Peaker: \x -> [$jmacro| function(x){return `(foo x)`;} |]
16:24:19 <mmorrow> Peaker: it looks also like it supports some limited making-js-syntax-non-sucky-ness
16:24:34 <mmorrow> Peaker: [$jmacro| function(x){return x;} |] === [$jmacro|\x -> x|]
16:24:41 <mmorrow> nomeata: :)
16:25:32 <hackagebot> hack-contrib-press 0.1.0 - Hack helper that renders Press templates (BrandonBickford)
16:25:56 <mmorrow> Peaker: hmm, not sure if [$jmacro|\x -> x|] literally works, but apparently something like that does
16:26:05 <mmorrow> Peaker: http://patch-tag.com/r/jmacro/pullrepo/Language/Javascript/JMacro.hs
16:26:08 <copumpkin> ChilliX: I see
16:26:54 <copumpkin> ChilliX: but why even try? it's my fault if I write f x = f x just as it's my fault if I lead to arbitrary recursion at compile time, isn't it?
16:27:27 <shapr> Is there any example code that uses parsec3 to parse a binary file format?
16:27:31 <mmorrow> Peaker: ooh, sweet. it does work: renderJs [$jmacro|var id = \x -> x|]
16:27:55 <gwern> copumpkin: why even try typechecking? it's my fault if I write 5 + "foo", isn't it?
16:28:25 <copumpkin> gwern: the difference is that TH already allows me to perform arbitrary computation at compile time
16:28:58 <nomeata> gwern: darcswatch is updated. Chan you check that everything is as expected?
16:29:17 <mmorrow> , [|show $(1 + 1)|]
16:29:19 <lunabot>  luna: No instance for (GHC.Num.Num Language.Haskell.TH.Lib.ExpQ)
16:29:37 <mmorrow> , [|show $(lift (1 + 1))|]
16:29:39 <lunabot>  AppE (VarE show) (LitE (IntegerL 2))
16:29:43 <mmorrow> err, bad example kinda
16:30:26 <gwern> nomeata: as I said, http://darcswatch.nomeata.de/repo_http:__code.haskell.org_yi.html is wrong
16:30:36 <gwern> that second unapplied patch isn't even for yi
16:30:53 <Peaker> mmorrow: ah, but you still write in JavaScript, with its semantics.. I was hoping I could write in a nicer Haskell-like language and have it compile to JS
16:31:06 <nomeata> gwern: ouch, how can that happen
16:31:11 <mmorrow> Peaker: there's a different package that does that
16:31:20 <gwern> nomeata: heck, I dunno. you wrote the thing
16:31:32 <mmorrow> Peaker: http://hackage.haskell.org/package/HJavaScript
16:31:48 <nomeata> gwern: Sorry, I was just thinking loudly
16:31:51 <mmorrow> Peaker: "a typed subset of JavaScript"
16:32:15 <mmorrow> Peaker: once you're done, you prettyprint to js
16:32:17 <Peaker> mmorrow: and also  http://www.haskell.org/haskellwiki/Yhc/Javascript  apparently
16:32:49 <mmorrow> Peaker: yeah, that too. but there it implements a graph-reduction runtime in js, then evals the compiled haskell on that
16:32:58 <mmorrow> so there's a performance hit
16:33:13 <mmorrow> (*but* you get to literally write in haskell..)
16:33:22 <nomeata> gwern: the patch mail has strange encodings in it (=20), and thus does match any repository: http://darcswatch.nomeata.de/user_alexey.skladnoy@gmail.com.html
16:33:33 <nomeata> gwern: Iâ€™ll just remove it from darcswatch
16:33:40 <mmorrow> Peaker: like, yhcjs is essentially s/asm/js/
16:33:53 <gwern> nomeata: what a remarkable versatile patch
16:34:03 <mmorrow> Peaker: err, that's a bad analogy actually
16:34:22 <mmorrow> Peaker: well, not that bad i guess
16:35:02 <Peaker> microcode+asm :)
16:35:22 <nomeata> gwern: it shares no history with any repository... but I guess this case should be treated differently. Iâ€™ll see if it occurs more often
16:36:23 <mike-burns> I've a gtk2hs question that's more like a GTK question: with an IconView, how do I get the selected items?
16:36:40 <mike-burns> Related questions: what can I do with a TreePath? What can I do with a TreeIter?
16:50:44 <mriou> is it possible to make an infinite list of random values from randomRIO ?
16:51:09 <skorpan> i don't see why not
16:51:43 <mriou> skorpan everything I try ends up being in an infinite loo[p
16:51:46 <mriou> loop sorry
16:51:55 <skorpan> oh, well...
16:52:05 <skorpan> i see why not now ;P
16:52:08 <skorpan> i don't know
16:52:49 <badsheepy> surely you need an infinite loop to make an infinite list :o
16:53:11 <skorpan> i assume the problem here is strictness
16:53:21 <mmorrow> @type \rng -> randomRs rng <$> newStdGen
16:53:23 <lambdabot> forall a. (Random a) => (a, a) -> IO [a]
16:53:38 <hackagebot> urldisp-happstack 0.1 - Simple, declarative, expressive URL routing -- on happstack. (SterlingClover)
16:53:51 <EvilTerran> the problem will be that you can't use the same StdGen for an infinite list and then other random numbers
16:53:56 <skorpan> > (randomRs rng <$> newStdGen) (1, 100)
16:53:58 <lambdabot>   Not in scope: `rng'
16:53:58 <EvilTerran> you'd have to split it or make a new one
16:54:01 <mriou> skorpan yes, otherwise repeat does the job
16:54:06 <skorpan> > (randomRs (1, 100) <$> newStdGen)
16:54:07 <lambdabot>   <IO [Integer]>
16:54:16 <skorpan> > unsafePerformIO $ (randomRs (1, 100) <$> newStdGen)
16:54:17 <lambdabot>   Not in scope: `unsafePerformIO'
16:54:18 <skorpan> :(
16:54:33 <mmorrow> @let randomRs' (a,b) = let go g = let (x,g') = randomR (a,b) in x `seq` x : go g' in go
16:54:35 <lambdabot>  Couldn't match expected type `(t, t1)'
16:54:37 <copumpkin> stack overflow in ghci
16:54:41 <copumpkin> mmorrow's versio
16:54:42 <copumpkin> n
16:54:52 <monochrom> unsafeInterleaveIO if you really want.
16:55:00 <Peaker> unsafe*IO <-- :-(
16:55:02 <mmorrow> @let randomRs' (a,b) = let go g = let (x,g') = randomR (a,b) g in x `seq` x : go g' in go
16:55:03 <lambdabot>  Defined.
16:55:14 <monochrom> But I would split.
16:55:29 <mriou> copumpkin the tricky thing with ghci is that it will try a show so you need to liftM a take
16:55:45 <mmorrow> or unsafeInterleaveIO
16:55:59 <mmorrow> well, maybe not verbatim
16:56:01 * mmorrow checks
16:56:43 <mmorrow> randomRs' (0,3) <$> newStdGen
16:56:47 <mmorrow> works fine
16:57:02 <mmorrow> (don't even need unsafeInterleaveIO)
16:57:43 <mriou> ah yes :)
16:57:53 <mriou> thanks mmorrow
16:57:53 <skorpan> @type randomRs'
16:57:55 <lambdabot> forall t t1. (RandomGen t1, Random t) => (t, t) -> t1 -> [t]
16:57:59 <mmorrow> mriou: np
16:58:01 <skorpan> @type randomRs
16:58:03 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
16:58:12 <skorpan> hm, que?
16:58:16 <skorpan> what's the difference?
16:58:17 <mmorrow>  @let randomRs' (a,b) = let go g = let (x,g') = randomR (a,b) g in x `seq` x : go g' in go
16:58:30 <mmorrow> (i just made that version to combat the stack overflow in ghci)
16:58:38 <monochrom> @type newStdGen
16:58:40 <lambdabot> IO StdGen
16:58:50 <mmorrow> @type mkStdGen <$> randomIO
16:58:52 <lambdabot> IO StdGen
16:59:08 <monochrom> Does newStdGen do a split to the internal global gen?
16:59:20 <mmorrow> monochrom: that sounds possible
16:59:28 <skorpan> what's this "split" that you're talking about?
16:59:36 <Berengal> newStdGen splits, getStdGen doesn't
16:59:47 * mmorrow never uses getStdGen
16:59:56 <monochrom> The docs says yes. It is what I would do.
17:00:18 <Berengal> getStdGen is only in case you want to know which random numbers you got out later
17:00:32 <Berengal> I think
17:00:50 <mmorrow> Berengal: ah, i usually provide my own StdGen in that case
17:01:03 <mmorrow> err, as a parameter to the function
17:01:10 <conal> haskell-on-osx question: how do people get ghci to find dynamic libraries installed via macports?
17:01:19 <Berengal> mmorrow: Yeah, that's probably best anyway. Who knows what might've called newStdGen inbetween your two gets?
17:01:43 <mmorrow> Berengal: yeah, i don't trust getStdGen really i guess
17:01:58 <mmorrow> Berengal: (not that there's any reason not too)
17:02:05 <monochrom> I don't know osx specifics. My unix experience suggests LD_LIBRARY_PATH generally for dynamic libraries.
17:02:05 <mmorrow> maybe there is
17:02:15 <Berengal> mmorrow: There is, it's in IO and depends on newStdGen
17:02:45 <Berengal> Classic case of mutable state easily biting you in the arse
17:03:05 <mmorrow> Berengal: i just prefer having a pure function that takes an StdGen as a param, and lets the caller worry about where to get one
17:03:27 <monochrom> Oppose State and Globalization!
17:03:44 <monochrom> You people are so anarchic.
17:03:48 <Berengal> mmorrow: Same. If you really want to you can wrap it in your own IO action later
17:06:44 <glguy> Usually you want "newStdGen" unless you are intentionally not updating the StdGen
17:07:07 <gwern> monochrom: how could we be, when we want a functional world order?
17:07:09 <glguy> getStdGen and setStdGen are just global variable accessors
17:07:30 <conal> monochrom: thx.
17:07:41 <monochrom> conal: so, it works? :)
17:07:50 <conal> monochrom: no.
17:07:57 <monochrom> Oops oh well.
17:08:07 <conal> monochrom: apparently in osx, it's called DYLD_LIBRARY_PATH.
17:08:23 <gwern> 'There were some interesting ideas, but the research didn't lead to practical results because Tecton was functional. We believed Backus's idea that we should liberate programming from the von Neumann style, and we didn't want to have side effects. That limited our ability to handle very many algorithms that require the notions of "state" and "side effects."
17:09:12 <glguy> functional == pure?
17:09:26 <conal> monochrom: but setting it hosed my machine.  so i learned there's something called DYLD_FALLBACK_LIBRARY_PATH to use instead.  and i ran into various remarks recommending against setting this kind of variable.
17:09:37 <gwern> 'I decided to use a dialect of Lisp called "Scheme" to build such a toolbox. Aaron and I developed a large library of components in Scheme demonstrating all kinds of programming techniques....I realized during this activity that side effects are important, because you cannot really do graph operations without side effects. You cannot replicate a graph every time you want to modify a vertex. Therefore, the insight at that time was that you can combine ...
17:09:43 <gwern> ... high-order techniques when building generic algorithms with disciplined use of side effects. Side effects are not necessarily bad; they are bad only when they are misused.
17:09:46 <monochrom> Hrm, the plot thickens. :)
17:10:03 <glguy> gwern: instead of flooding the channel, you could just provide a URL :)
17:10:18 * mmorrow 's scrollback is 5000 lines :)
17:10:24 <gwern> glguy: but then we couldn't be publicly amused at things like '"Scheme"'
17:10:33 <monochrom> <sarcasm>Ow, you should thank him for the effort of typing it all up.</sarcasm>
17:10:35 <gwern> but the ln is http://dobbscodetalk.com/index.php?option=com_myblog&show=Standards-Stepanov-Stroustrup-and-Stevens.html&Itemid=29
17:10:50 <mmorrow> copy/paste++
17:11:00 <gwern> monochrom: I am surrounded by ingrates and lesser minds, but such is my noble-heartedness that it does not bother me
17:12:59 <Berengal> I find templates magic because of their ability to confuse and confound others
17:13:16 <monochrom> I was joking. Please excuse me.
17:13:45 * gwern forgives monochrom. go in peace my son. 'even the fools have their own story'
17:13:57 <pikhq> State? Side effects? How very foolish.
17:14:08 <gwern> I'll admit, I don't really understand the c++ generic template stuff. as far as I can tell, isn't it a typeclass + an implementation, with some staticness added in?
17:14:12 <pikhq> Let there be IO. And there was IO. And it was good.
17:14:36 <pikhq> gwern: It is a lambda expression, actually.
17:14:54 <Berengal> Or a very powerful macro language
17:15:00 <pikhq> Evaluated at compile-time.
17:15:02 <Saizan> yeah, it's more like macros
17:15:05 <Peaker> gwern: it would be nice to correct him and explain why he has a logical leap there
17:15:22 <Saizan> since they use specialization for everything
17:15:47 <gwern> Saizan: what would that be in haskell terms?
17:16:10 <Peaker> gwern: A citation of "Functional Data Structures" would do, probably?
17:16:20 * pikhq isn't kidding when he says it *is* a lambda expression...
17:16:36 <monochrom> Scheme was motivated and invented before functional data structures.
17:16:39 <Berengal> Yeah, templates are functional
17:16:49 <gwern> Peaker: unlikely. you probably want the paper showing purity only entails a log slowdown in general or something
17:16:58 <Saizan> gwern: uhm, TH? you do have a functional language to generate code for you with templates :)
17:17:04 <pikhq> Very hard to use in that way, though.
17:17:13 <pikhq> (for C++, that is)
17:17:39 <gwern> Saizan: TH would map onto the templates in general; I mean the stl specfically
17:19:38 <Saizan> gwern: ah, sorry, i didn't have the full context, then it's a way to introduce parametric polymorphism, i guess?
17:20:16 <Saizan> which is the base of haskell, data List a = ..
17:20:21 <dolio> Templates are like what you'd get if you removed parametric polymorphisms from Haskell's type system, and then added it back in with a preprocessor that turns specially written code into monomorphic versions of said code.
17:21:19 <Saizan> dolio: and that preprocessor let you do a lot of ad-hoc things?:)
17:21:49 <monochrom> Type-level integer parameters.
17:22:02 <dolio> Yeah, it's a little more complex than my description.
17:24:21 <mriou> so why does that "stack overflow" in ghci? take 5 <$> randomRs (0,10) <$> newStdGen
17:26:20 <Saizan> it doesn't here
17:26:31 <Saizan> Prelude System.Random Control.Applicative> take 5 <$> randomRs (0,10) <$> newStdGen
17:26:34 <Saizan> [8,4,3,6,0]
17:26:35 <monochrom> It doesn't stack overflow on me. GHC 6.8.2.
17:26:48 <Saizan> 6.10.2 here
17:26:55 <dolio> It's possible to get the global gen in a state where it always stack overflows in ghci.
17:27:10 <dolio> By doing lots of newStdGen and the like and never looking at the results.
17:27:43 <Saizan> aw
17:27:45 <mriou> dolio that was my problem, I had to restart ghci
17:27:50 <mriou> weirdo
17:28:00 <Saizan> dolio: is there a ticket for that?
17:28:23 <Saizan> and, i guess it'd happen ina compiled program too?
17:28:29 <dolio> You can end up with the global ref storing something like "split (snd (split (snd (split snd (split ...", which will overflow when you try to evaluate it.
17:28:48 <monochrom> Then it is the same problem as scanl (+) 0 blahblah
17:29:52 <dolio> I'm not aware of any ticket for it, but there might be one.
17:29:55 <monochrom> scanl (+) 0 (repeat 0) !! 10000000  will stack overflow.  print (scanl (+) 0 (repeat 0)) won't.
17:30:05 <dolio> I'm not sure it's a big problem.
17:30:22 <skorpan> is there anything for parsing/writing ms excel files in haskell?
17:30:28 <Elly> monochrom: woah, that allocated memory fast :P
17:30:34 <Elly> and after the stack overflow ghci didn't let go of it
17:30:40 <monochrom> hehe
17:30:51 <Elly> I've not freed up that much memory that fast since I last quit firefox
17:31:00 <monochrom> hahahaha
17:31:30 <skorpan> how did people browse the web with 4 MB of RAM back then?
17:31:34 <monochrom> http://www.haskell.org/haskellwiki/Stack_overflow#Scans  explains why
17:31:58 <mriou> skorpan ever tried lynx? :)
17:32:09 <monochrom> Back then, Mosaic cached nothing, that's why.
17:32:34 <Berengal> Back then we didn't as much "surf" the web as wade a bit in it
17:32:38 <skorpan> i used IE 3.2 on an 8 MB computer
17:32:46 <monochrom> So you should really ask: how did people browse the web with 4MB memory, 40MB disk, 400 bps modem.
17:33:17 <monochrom> And the answer is: back then, scientists not artists designed web pages.
17:33:19 <skorpan> 400 bps?  surely they measured it in baud back then.
17:33:31 <monochrom> baud != bps
17:33:44 <skorpan> i know
17:33:56 <monochrom> But that's a minor point. I can say 400 baud too.
17:34:19 <skorpan> whatever
17:36:02 <monochrom> You let non-scientists upload web pages, and all at a sudden those people think it is cool to: (A) upload 10 megapixel pictures (there goes your 4MB memory); (B) upload 2MB-long html files just because they have redundant <font> tags (there goes your 4MB memory again).
17:36:23 <Zao> monochrom: Said pictures being BMP.
17:36:55 <inimino> animated GIFs
17:37:04 <Berengal> The web is a great idea that turned into a horrible mess
17:38:03 <skorpan> the main problem with the internet was the way too late arrival of CSS
17:38:09 <skorpan> I HAVE SPOKEN
17:38:11 <skorpan> good night
17:39:33 <monochrom> A page on a web forum these days can easily use 400KB to present you just 400 words worth of conversation. Look at its highly redundant html code. You can easily see yourself cutting it down to one tenth and still renders exactly the same.
17:39:53 <monochrom> (This is why I believe in newsgroup and disbelieve in web forums.)
17:40:29 <Berengal> Meh, I've got the bandwidth and memory to spare anyway
17:40:29 <monochrom> And I agree with skorpan.
17:41:17 <monochrom> I'm going to harp the "world hunger" argument. I don't know whether I stand by it. But it's fun. :)
17:41:52 <monochrom> There are lots of people deprived of bandwidth and memory. And here you are wasting them like there is no tomorrow!
17:41:59 <FunctorSalad> monochrom: huh? I don't see that many inappropriate 10 megapixel pictures
17:42:18 <monochrom> Hehe I'm exaggerating.
17:42:18 <pikhq> inimino: Just be glad you can't do animated BMPs.
17:42:26 <monochrom> hahahahaha
17:42:43 <FunctorSalad> if it's a nice picture I'm happy about high resolution
17:42:55 <inimino> pikhq: oh but you can
17:43:00 <inimino> pikhq: behold the mighty power of DHTML :)
17:43:14 * pikhq retches
17:43:18 <FunctorSalad> (I agree with the general point about bloat, but high-resolution pictures I don't count as part of it)
17:43:33 <gwern> monochrom: I know I should help the africans but I can't send them the bit of RAM i'm not using! :(
17:43:37 <gwern> it just won't pull out
17:44:52 <monochrom> I am reserved about the "world hunger" argument too.
17:46:26 <monochrom> So, do you now understand the stack overflow causes? :)
17:47:37 <monochrom> I suppose "newStdGen :: IO StdGen" the "IO" part gives people an expectation that thunks are reduced here-and-now and so shouldn't stack-overflow later on.
17:48:25 <monochrom> They probably are cool about split being lazy but an IO action shouldn't.
17:48:28 <mriou> monochrom: got it, thanks
17:49:01 <monochrom> I wrote that section on Scans. :)
17:49:34 <Saizan> monochrom: so you don't think it's a bug in System.Random that you can get such overflows out of it?
17:50:03 <monochrom> I don't mind either way.
17:51:10 <Saizan> lazily building up a slipt/snd thunk like that does no good i think, unless you've a very weird instance of RandomGen
17:55:22 <kpreid> I had a thunk accumulation problem recently: http://rosettacode.org/wiki/Active_object#Haskell -- and it was affecting the behavior a bit because the computation time wasn't spread as expected.
17:55:56 <kpreid> (the 'evaluate' is there to fix it)
17:56:15 <kpreid> (oh and feel free to improve that haskell code if you take a look...)
17:59:29 <Peaker> can hackage packages be removed if the name is decided to be bad or such?
17:59:44 <FunctorSalad> hehe
18:01:30 <lpsmith> Peaker:  no idea myself,  you'd have to email somebody in charge
18:02:10 <lpsmith> but I had a similar thought... well, not that though exactly,  more along the realization that I cannot change the package name once chosen :-)
18:02:29 <zmoazeni> Hi all. I have a bit of a newb question. I'm trying to understand Haskell types etc and I'm not sure why this is failing. Can someone point me in the right direction? http://gist.github.com/155366 (I'm wanting to have 2 functions with the same name. 1 for Integers and 1 for Strings that do slightly different things but return an Integer)
18:03:07 <dibblego> zmoazeni, class IntegerContrafunctor a where zing :: a -> Integer
18:03:17 <lpsmith> the problem is [Char]
18:03:20 <zmoazeni> yea
18:03:29 <dibblego> oh you want FlexibleInstances
18:03:33 <lpsmith> aye
18:03:35 <zmoazeni> I see that I can do [a], but then that'll take over for [1,2] too
18:04:09 <lpsmith> basically Haskell 98 requires the parameter to a typeclass to be a simple constructor
18:04:20 <zmoazeni> Oh I see, bummer
18:04:24 <lpsmith> [Char] == [] Char
18:04:40 <lpsmith> so it's the type char applied to the list type constructor
18:04:56 <lpsmith> But,  just add this line to the top of your file,  and it'll work:
18:05:05 <zmoazeni> Yea, I was hoping that the instance could be defined per "stuff in a list" and not "for all lists"
18:05:09 <lpsmith> {-# LANGUAGE FlexibleInstances #-}
18:05:13 <zmoazeni> oh
18:05:29 <lpsmith> that'll turn on a language extension and make it work :-)
18:05:53 <zmoazeni> Do I have to do something special for ghci to accept that?
18:06:17 <slava> is anyone aware of a formulation of uion-find which allows equivalence classes to be broken apart also?
18:07:18 <Cale> zmoazeni: You put it at the top of your file
18:07:45 <zmoazeni> bleh, I'm an idiot, misread that. Thanks Cale
18:07:59 <Cale> zmoazeni: For ghci, you can write :set -XFlexibleInstances but I'm not sure how long it applies for
18:08:21 <zmoazeni> FlexibleInstances hm? I'll google a bit for that, but are there many cons to using that?
18:08:31 <Cale> zmoazeni: Basically, Haskell98 is super restrictive, and almost every real Haskell program uses some extensions
18:08:46 <Cale> There are not many cons (if any at all) to using FlexibleInstances
18:09:06 <zmoazeni> Cale: Ah I see
18:09:26 <zmoazeni> I appreciate the help guys
18:09:40 <oklopol> ...a function that takes an equality predicate, and removes duplicated from list
18:09:52 <dibblego> oklopol, nubBy
18:10:02 <oklopol> hmm right
18:10:14 <oklopol> i remembered nub was just if they're next to each other
18:10:14 <Cale> Even hugs supports FlexibleInstances, I'm pretty sure.
18:10:26 <lpsmith> slava: hmm, not off the top of my head...
18:10:33 <Cale> nub is even if they're not
18:10:37 <Cale> > nub [1,2,1]
18:10:38 <lambdabot>   [1,2]
18:10:48 <Cale> > map head . group $ [1,2,1]
18:10:49 <lambdabot>   [1,2,1]
18:10:56 <Cale> > map head . group $ "mississippi"
18:10:57 <lambdabot>   "misisipi"
18:11:07 <Cale> > map head . group . sort $ "mississippi"
18:11:09 <lambdabot>   "imps"
18:11:19 <copumpkin> zomg secret message
18:11:42 <Cale> > nub $ "mississippi"
18:11:43 <lambdabot>   "misp"
18:12:03 <lpsmith> my version of nubSort is ever so slightly more efficient than "map head . group . sort"
18:12:24 <oklopol> err wasn't there a language extension for making something like (Int, String) an instance of a typeclass
18:12:32 <Cale> oklopol: yes, FlexibleInstances
18:12:39 <zmoazeni> Just so I'm not going in the wrong direction. Classes/Instances are the right approach to having the same function name applied to different types right? (e.g. "show" and "read")?
18:12:41 <lpsmith> http://hackage.haskell.org/package/data-ordlist
18:12:46 <Cale> zmoazeni: yes
18:12:55 <zmoazeni> Cale: thanks again
18:13:30 <oklopol> oh it's exactly that
18:13:37 <Cale> zmoazeni: But it's good not to go overboard -- sometimes just giving the functions different names is more natural, especially in the case where what they do is not really related.
18:14:03 <lpsmith> slava:  what do you want a reversable union-find,  if I may ask?
18:14:15 <Cale> reversible?
18:14:17 <zmoazeni> Cale: I gotcha
18:14:45 <lpsmith> something so you can take an equivalence class apart again...
18:15:21 <lpsmith> I suppose if all you want to do is undo a "union",  you could avoid path compression and make your task much easier
18:16:10 <lpsmith> but if you want to split an equivalence class in a new, arbitrary way...  hmm
18:18:49 <Cale> zomg the species package is awesome
18:19:04 <Cale> http://hackage.haskell.org/package/species
18:19:33 <slava> lpsmith: looks like the paper I'm reading requires that equivalence classes can be split into a singleton + the rest of the set
18:19:45 <mmorrow> slava: how do you mean "broken apart"?
18:19:58 * mmorrow just saw what you just said
18:20:05 <slava> mmorrow: so that one element is not equivalent to any of the others anymore
18:20:11 <slava> and this might be iterated several times
18:20:19 <oklopol> Cale: FlexibleInstances requires that thing not to be a type synonym though?
18:20:28 <slava> this is a register coalescing algorithm
18:20:36 <mmorrow> slava: and that split singleton becomes a new (one element) equiv class?
18:20:38 <Cale> oklopol: oh, possibly...
18:20:41 <oklopol> i guess i'm being told that directly by ghc, just seemed weird
18:20:42 <copumpkin> it'd be fun to have a fingertree-like disk-based balanced tree library
18:20:48 <copumpkin> on any measure
18:20:50 <oklopol> something about TypeSynonymInstances
18:21:02 <Cale> TypeSynonymInstances
18:21:03 <Cale> yes
18:21:08 <slava> mmorrow: yeah
18:21:22 <lpsmith> hmm... yeah,  just setting a single element back to itself might not work,  as other things might point to it
18:21:26 <slava> mmorrow: the algo optimistically assumes that all inputs to a phi node can be coalesced, then does some work to find ones which actually cannot, and those get split off
18:21:35 <lpsmith> (assuming the standard array-based implementation of union-find, of course)
18:22:04 <mmorrow> slava: interesting, do you have a link to this paper?
18:22:22 <slava> http://cseweb.ucsd.edu/classes/sp02/cse231/kenpldi.pdf
18:23:06 <oklopol> Cale: i would like to make ([Foo], [Int], [Int]) an instance of Eq, and now it's complaining about overlapping (i'm using OverlappingInstances as well); is that possible?
18:23:10 <oklopol> to do that is
18:25:12 <dibblego> oklopol, make Foo an instance of Eq and you're done
18:26:02 <oklopol> hmm right, it wasn't an instance of Eq, but i get the same error still
18:26:41 <dibblego> oklopol, make Foo an instance of Eq and nothing else
18:26:54 <oklopol> it's not an instance of anything else
18:26:55 <oklopol> ohh
18:27:01 <slava> mmorrow: oh, LLVM has an implementation of this paper
18:27:05 <oklopol> i want to make the instance definition myself
18:27:13 <oklopol> that's why overlapping is an issue
18:27:15 <dibblego> oklopol, then you'll have to newtype
18:27:46 <oklopol> even with FlexibleInstances?
18:28:04 <mmorrow> slava: hmm, i haven't implemented union-find ever, so i'm not familiar with all the details, but thinking about how i might implement it i don't see splitting an element into a new singleton equiv class as being problematic.. what am i missing?
18:28:20 <slava> mmorrow: I'm going to study the LLVM implementation, perhaps they don't use U-F at all
18:28:28 <slava> the paper just mentions using U-F but I don't see how...
18:28:41 <Saizan> with OverlappingInstances and FlexibleInstances you should be able to write one for ([Foo], [Int], [Int]) but that's not really good style
18:29:10 <lpsmith> mmorrow:  it's not too difficult,  basically you start with an array of type say, (UArray Int Int)
18:29:16 <FunctorSalad> yeah, real men use IncoherentInstances
18:29:24 <lpsmith> initialize every index to itself
18:29:45 <mmorrow> slava: (you've probably seen this maybe, but) this (short) paper is neat http://www.cs.princeton.edu/~appel/papers/ssafun.ps
18:29:53 <oklopol> i guess what i should do is to use a newtype
18:30:45 <lpsmith> (Basically, initialize it so each index is in it's own set)
18:30:53 <mmorrow> lpsmith: my first thought is data Disjoint a = Disjoint {elems :: Map a Int, merged  :: Map Int Int}
18:31:21 <mmorrow> then union is O(lg n), n := # if equiv classes
18:31:26 <Saizan> oklopol: or a record type perhaps, so you also have descriptive field names
18:31:56 <lpsmith> yeah,  I was thinking towards something like that
18:32:03 <oklopol> Saizan: makes pattern matching uglier doesn't it?
18:32:10 <oklopol> i mean, impossible
18:32:31 <Saizan> no, why?
18:32:33 <lpsmith> Union-find is definitely one of those algorithms that benefit from mutation though.
18:32:52 <mmorrow> s/Map/ST(U)Array/
18:33:00 <Saizan> it actually gives you more alternatives
18:33:02 <oklopol> well i just thought it did. if it does, then i could use it
18:33:16 <oklopol> but there's only one function that touches the internals
18:33:22 <lpsmith> I think somebody's come up with a convoluted persistent implementation that's asymptotically efficient,  but I dunno what the constant factors are like
18:33:23 <mmorrow> err, well you'd have to assign each `a' and Int id in that case i guess or something
18:33:23 <oklopol> so doesn't seem usefuls
18:33:25 <oklopol> *useful
18:34:11 <Saizan> data Point = Point { x,y :: Int }, then you can use patterns like "Point a b" "Point { x = a, y = b }" "Point { x = a }" "Point { y = y }" ..
18:34:26 <mmorrow> lpsmith: do you know off-hand what the complexity of the "standard" union-find algo is?
18:34:45 <oklopol> oh cool
18:34:51 <mmorrow> err, i guess for each of "union" and "find"
18:35:01 <oklopol> yeah, that is nice
18:35:26 <mmorrow> hmm, actually.. where does the complexity come in at all?
18:35:42 <lpsmith> well, with all the optimizations,  it's something like 1 / the ackermann function
18:35:48 <mmorrow> (or rather, what are the common things you do with these structures?)
18:35:51 <Saizan> a declaration like data Point = Point Int Int only gives you the "Potion a b" option instead
18:35:52 <lpsmith> or something related to the ackermann function
18:35:58 <Saizan> *Point
18:36:05 <FunctorSalad> it's the inverse of it's diagonal IIRC
18:36:30 <Saizan> (Point + option = Potion?)
18:36:36 <lpsmith> in short, very, very fast.   Practically a constant
18:36:38 <FunctorSalad> if you use both path compression and the other thing (I'm not sufficiently knowledgable :()
18:36:41 <oklopol> that was indeed an interesting typo
18:36:58 <FunctorSalad> *its diagonal :p
18:40:04 <lpsmith> FunctorSalad:  basically you use a technique analogous to AVL trees,  but simpler
18:40:07 <FunctorSalad> ah, the other thing is "The first way, called union by rank, is to always attach the smaller tree to the root of the larger tree, rather than vice versa.". see the wp article for more..
18:40:32 <mmorrow> lpsmith: ah right, iirc the lengauer-tarjan dominators algo is O(blah bla .. (1/ackerman) blah)
18:42:01 <dolio> 1/ackerman or inverse function of ackerman?
18:42:20 <mmorrow> oops, yeah "functional inverse of ackerman"
18:42:32 <FunctorSalad> These two techniques complement each other; applied together, the amortized time per operation is only O(Î±(n)), where Î±(n) is the inverse of the function f(n) = A(n,n), and A is the ... Ackermann function.
18:42:36 <FunctorSalad> (from wp)
18:42:57 <lpsmith> yeah, I originally misspoke.   Silly mathematicans and their notational ambiguities :-P
18:43:15 <copumpkin> it's surprising how the ackermann gets into that
18:43:24 <lpsmith> Even more practically constant than O(log (log n))!
18:43:37 <FunctorSalad> well, fraction notation doesn't make much sense for noncommutative things :p
18:43:48 * mmorrow took that from his printed out copy of www.emis.de/journals/.../GeorgiadisTarjanWerneck2006.10.1.pdf that happens to be in a folder next to him
18:43:58 <FunctorSalad> (you don't know how the numerator and the denomiator are interleaved)
18:44:26 <glguy> I feel like (msum . map return) comes up a lot. Is this defined somewhere common?
18:44:42 <mmorrow> FunctorSalad: i didn't even mean for (1/ack) to be (ack^-1), i was just not remembering what it was correctly
18:45:06 <Cale> glguy: It's not, but I usually call it something like option or choose
18:45:13 <bgs100> @src unwords
18:45:13 <lambdabot> unwords [] = ""
18:45:13 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
18:45:20 <FunctorSalad> sorry I was just being a smartdonkey or something
18:45:52 <Cale> d'oh, byorgey's species package is built on top of Henning Thielemann stuff...
18:46:06 <Cale> This might motivate me to fix Henning's messes.
18:46:09 <mmorrow> FunctorSalad: :) that's an amusing ambiguity though
18:46:27 <Cale> I really don't like qualified names at all.
18:46:46 <lpsmith> Well,  it's a notational ambiguity that leads to a mental ambiguity too :-P
18:46:55 <Saizan_> yeah, those packages are unusable
18:47:02 <lpsmith> Not so much when I'm thinking about it, but when recalling stuff from memory
18:47:10 <sjanssen> Cale: are you going to fork it?
18:47:25 <mmorrow> Cale: yeah, i hate when two modules conflict on the con names of e.g. an Exp datatype (which more often than not has like 40 constructors), and you need to write a translation function between the two..
18:47:26 <FunctorSalad> Cale: I suggested on #haskell-blah that maybe they would be more readable if the module name came after the local name? but it's too late to change it now anyway
18:47:27 <mmorrow> pain!
18:48:01 <lpsmith> cale, Saizan_:  what's messy about Henning's package?
18:48:12 <lpsmith> (I don't know,  I've never looked at it)
18:48:16 <mmorrow> foo (This.Var a `This.App` This.Asdf) = That.Var a `That.App` That.Jkl
18:48:19 <mmorrow> gah!
18:48:23 <dolio> It's written with an ML module system in mind, more or less.
18:48:43 <Saizan_> lpsmith: every type is called T, every class is called C ..
18:48:54 <Saizan_> lpsmith: using the module system to disambiguate
18:49:18 <mmorrow> dolio: if we had the ML module system, it would be much more palatable
18:49:27 <lpsmith> ahh...  I kind of like that, in some cases.   Modula-3 pioneered that idiom,   and it was beautiful in that context
18:49:37 <mmorrow> dolio: (i'm talking in general, not wrt Henning's code)
18:49:47 <Cale> lpsmith: He names every single class C and every type T
18:49:51 <Cale> yeah
18:49:57 <sjanssen> Cale: I wonder why he doesn't name every function f?
18:50:02 <Cale> sjanssen: heh
18:50:11 <sjanssen> it makes just as much sense
18:50:15 <Cale> exactly
18:50:20 <FunctorSalad> *grin*
18:50:38 <Cale> It's ridiculous, and given how good his packages are otherwise, it seems a total waste to sabotage them like that
18:50:41 <lpsmith> I disagree,  calling most types T often makes sense,  if you always import qualified
18:50:47 <lpsmith> which is probably the right default anyway
18:50:52 <Cale> lpsmith: No.
18:51:00 <lpsmith> Why not?
18:51:05 <Cale> lpsmith: Importing qualified is not the right default. It's inconvenient as hell.
18:51:15 <Saizan_> you don't have "one module per type" like you don't have "one function per type"
18:51:18 <Cale> I hate it enough that I have to do this with Data.Set and Data.Map
18:51:25 <Saizan_> err
18:51:28 <Cale> (which is something that I never used to have to do)
18:51:29 <FunctorSalad> the period really interrupts the flow of reading ;)
18:51:31 <Saizan_> "one module per function"
18:51:36 <Cale> Yeah, . means composition
18:51:53 <Cale> It makes it really annoying to read when there are qualified names mixed in everywhere.
18:51:54 <mmorrow> Data->Maybe->fromJust /* ? */
18:52:07 <Cale> Data|Maybe|fromJust perhaps
18:52:20 <FunctorSalad> Module.disambiguate(Data,Maybe)
18:52:21 <Cale> But I'd rather not have to write the qualification at all.
18:52:31 <Cale> Just design modules not to reuse names.
18:52:42 <sjanssen> Saizan_: yeah, I suppose that's true.  Though I think "one module per type" is not all that universal
18:52:48 <FunctorSalad> *Module.disambiguate(Data,Maybe,fromJust)
18:52:58 <lpsmith> Cale:  then why have modules?
18:53:00 <Cale> I mean, it's okay if once in a blue moon two modules accidentally export the same identifier and I need to qualify it
18:53:05 <Cale> lpsmith: hiding
18:53:17 <Cale> lpsmith: To hide the internal structure of things
18:53:35 <lpsmith> I mean,  the beauty of the idiom,  which I like,  is that you don't find yourself looking up names as often
18:54:00 <Saizan_> sjanssen: i think you got me wrong :) what i meant is that while "one module per type" might be common it's not the rule around which to design modules to me
18:54:10 <lpsmith> :t Data.Set.insert
18:54:12 <lambdabot> forall a. (Ord a) => a -> S.Set a -> S.Set a
18:54:14 <Cale> lpsmith: It would be more obvious where things came from if they had sane names to begin with.
18:54:23 <sjanssen> lpsmith: one argument for modules is that entering every piece of Haskell source code in the world into the same file :)
18:54:23 <lpsmith> :t Data.Set.member
18:54:25 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
18:54:42 <lpsmith> see,  IMO, that's a far more heinous problem with Data.Set
18:54:48 <sjanssen> lpsmith: erm, didn't finish that: ... into the same file is not possible for social reasons
18:54:56 <lpsmith> The right default type for accessors is S.Set a -> a -> Bool
18:54:58 <sjanssen> Saizan_: oh, agree entirely
18:55:01 <FunctorSalad> to find out where something came from, you just do :i in ghci
18:55:21 <sjanssen> lpsmith: why is that the right type?
18:55:30 <FunctorSalad> so I think that argument on haskellwiki (?) was a bit bogus
18:55:36 <lpsmith> S.Set a -> (a -> Bool)
18:55:49 <Cale> It used to be that many of the set functions explicitly had Set in their names so that you didn't have to use them qualified.
18:55:49 <lpsmith> it's a function from a set to it's characteristic function
18:55:51 <copumpkin> lpsmith: I agree
18:55:58 <Cale> and you didn't have to do something like
18:56:06 <Cale> import qualified Data.Set as Set
18:56:09 <lpsmith> it's generally more useful for partial application purposes
18:56:21 <Cale> import Data.Set (Set, union, member)
18:56:37 <copumpkin> I actually care more for Data.Map
18:56:48 * mmorrow wonders why "member" isn't called "elem" ??
18:56:51 <sjanssen> Cale: HowFM wellFM doFM youFM rememberFM yourFM historicalFM HaskellFM librariesFM ?FM
18:56:56 <lpsmith> I'm a little annoyed that the maintainer of Edison chose to modify all of Chris Okasaki's beautiful types to be somewhat more compliant to Data.Set and the rest
18:57:01 <Cale> sjanssen: See, I actually liked that
18:57:01 <FunctorSalad> lpsmith:  (`member` tehSet)
18:57:09 <sjanssen> Cale: bleh
18:57:12 <FunctorSalad> (to get the Ï‡)
18:57:17 <Cale> sjanssen: Since I didn't have to use two lines to import the damn thing every time.
18:57:43 <sjanssen> Cale: yeah, that's annoying.  I think the right thing is to sit down and actually write some abstract classes
18:57:47 <lpsmith> sjanssen:  InFM myFM caseFM,  veryFM wellFM ;-)
18:57:49 <mmorrow> lpsmith: i agree with you totally, but just not in this particular case (because (a `elem` set))
18:58:21 <Cale> http://www.haskell.org/ghc/docs/6.0/html/base/Data.FiniteMap.html :)
18:58:34 <Cale> I like how all the historical documentation still exists
18:58:44 <Cale> http://www.haskell.org/ghc/docs/
18:58:56 <sjanssen> @let timetravel = unwords . map (++"FM") . words
18:58:58 <lambdabot>  Defined.
18:59:10 <lpsmith> hehehe
18:59:42 <Saizan_> Set.insert is really a step above insertSet, though i don't see why that leads to Data.Set.T
19:00:12 <Saizan_> it's not like we're having Data.Set.TypeSet now
19:00:23 <Cale> http://www.haskell.org/ghc/docs/5.04/html/base/index.html
19:00:23 <lpsmith> I will bet you anything that Henning's written Modula-3 in a previous life
19:00:25 <FunctorSalad> ghc should just have a trainable AI to learn to guess what you mean :D
19:00:45 <FunctorSalad> then if you write setInsret (sic) often enough it will just work
19:00:45 <mmorrow> {-# LANGUAGE DoWTFIMean!!! #-}
19:01:09 <lpsmith> well,  with qualified names, would you rather write Set.Set all the time?   T is shorter,  and consistent
19:01:22 <Cale> FunctorSalad: take the type context and find the shortest edit distance to something which typechecks
19:01:29 <Zao> mmorrow: I prefer DoWtfIMeanCorrectly.
19:01:31 <Saizan_> i just import the type non-qualified, i'm fine with that :)
19:01:45 <mmorrow> lpsmith: that you can import a module multiple times in different ways is a lifesaver wrt that
19:01:50 <FunctorSalad> Cale: take all the info it can grab as context to guess which module you mean ;o
19:01:55 <lpsmith> hahaha
19:02:02 <lpsmith> or you could just  type Set = Set.T
19:02:03 <sjanssen> lpsmith: perhaps it could be made consistent, but it isn't currently consistent with the body of Haskell code
19:02:03 <Cale> FunctorSalad: actually that would be great
19:02:19 <lpsmith> sjanssen:  true that
19:02:32 <Saizan_> lpsmith: what if you define two types in the same module? T1 T2?
19:02:40 <lpsmith> Modula-3 was very consistent with that idiom, because qualified names was in the language from the beginning
19:02:44 <Cale> If it used the type system to try to decide which module to pick something from, and then maybe only generate a warning
19:03:11 <lpsmith> Saizan_:   then you give maybe one type T,  maybe,  and others short descriptive names
19:03:12 <Cale> (perhaps only with -Wall turned on)
19:03:33 <FunctorSalad> Cale: wouldn't that require a totally new typechecker? (since the typechecker depends on module choice too)
19:03:34 <karlw> Emacs refuses to recognize switch-to-haskell
19:03:55 <FunctorSalad> so it would be a non-straightforward optimisation
19:03:55 <Saizan_> lpsmith: that doesn't sound very consistent to me
19:04:05 <Cale> FunctorSalad: Well, it would guess each imported module in turn and see which ones typechecked.
19:04:20 <Cale> FunctorSalad: and if it's unique, then succeed
19:04:25 <mmorrow> Cale: what if more than one typechecks
19:04:26 <mmorrow> ah
19:04:31 <karlw> Does this mean I have to write it for ghci or something?
19:04:34 <lpsmith> it wasn't inconsistent... conventions aren't set in stone,  ultimately do what makes the most sense
19:05:09 <lpsmith> like,  if you have a Modula-3 module that implemented a particularly efficient Map from one type to another
19:05:17 <lpsmith> You might have Map.T for the map itself
19:05:17 <karlw> ... I'm using haskell-mode.deb on lenny
19:05:25 <lpsmith> Map.Key for the type of the key
19:05:32 <lpsmith> Map.Value, etc.
19:06:08 <Saizan_> Set.T being better (which i'm not really sure of) than Set.Set doesn't seem a good reason to special case the "main type of the module"
19:07:14 <Cale> Even if we demand uniqueness and not do something aggressive like take the first import which works, that'll still dramatically cut down on the number of explicit qualified named
19:07:16 <Cale> names*
19:07:17 <lpsmith> Well,  the key is to consider the module name as part of the name of the functions and types...
19:07:31 <lpsmith> You might have Vector.T,  Vector.add, etc
19:08:49 <Cale> Qualified names are even uglier in types than they are in terms... even when I'm forced to import something qualified, I'll import all the types and classes unqualified usually.
19:09:25 <oklopol> what should showList return exactly?
19:09:31 <Cale> :t showList
19:09:32 <lambdabot> forall a. (Show a) => [a] -> String -> String
19:09:43 <Cale> > showList [1,2,3] "apple"
19:09:45 <lambdabot>   "[1,2,3]apple"
19:09:56 <Cale> > showList "hello" "apple"
19:09:57 <lambdabot>   "\"hello\"apple"
19:09:58 <oklopol> hmm. then i wonder what i'm doing wrong.
19:10:15 <lpsmith> Cale:  or you could just use a type synonym instead of importing seperately;  it's not that much worse
19:10:16 <Cale> You normally shouldn't define showList yourself
19:10:47 <oklopol> i want a list of instructions to be printed as a piece of code
19:10:50 <Cale> lpsmith: That's true, but if I import separately, I can also import any infix operators while I'm at it.
19:11:15 <Cale> Qualified infix operators are just completely unacceptable under any circumstances.
19:11:38 <Cale> oklopol: define a separate function, don't overload Show
19:11:50 <Cale> oklopol: Well, this is just my suggestion.
19:12:06 <lpsmith> Cale:  but I am curious what kind of names you suggest to disambiguate Data.Set and Data.Map
19:12:07 <Cale> oklopol: Normally, people like show to give valid Haskell code for generating the value in question.
19:12:19 <oklopol> Cale: hmm true.
19:12:27 <lpsmith> I know I sure as heck don't want to go back to writingFM FMFM afterFM everythingFM
19:12:36 <Cale> lpsmith: Well, my original suggestion was just to stick Set or Map into the names as necessary
19:12:54 <lpsmith> you have exactly that!
19:12:56 <Cale> I actually liked the FM convention because it meant that I didn't have to use qualified names.
19:12:58 <lpsmith> right now! :-)
19:13:09 <lpsmith> Map.member
19:13:13 <lpsmith> Set.member
19:13:16 <Cale> Picking . as the separator was a mistake
19:13:20 <lpsmith> maybe
19:13:28 <Cale> A huge mistake which makes qualified names horrible.
19:13:52 <Cale> (.) is by far the infix operator which I use more than any other
19:13:54 <lpsmith> personally I'd like :,  but that's an even worse choice
19:14:01 <Cale> I would have chosen |
19:14:06 <lpsmith> ugh
19:14:20 <LeoD> member@Map :P
19:14:21 <FunctorSalad> maybe "/"
19:14:26 <lpsmith> That's kind of heavyweight
19:14:31 <FunctorSalad> like directory names
19:14:33 <lpsmith> maybe '
19:14:35 <Cale> Set|member
19:14:40 <lpsmith> Set'member
19:14:44 <lpsmith> I could get used to that
19:14:51 <FunctorSalad> Set/member
19:14:55 <Ytinasni> Set#member ?
19:15:29 <lpsmith> But honestly,  I am of the opinion that one should generally put spaces around your infix operators anyway :-P
19:15:35 <dibblego> September
19:15:48 <Cale> FunctorSalad: I suppose most of the cases where that's division would be unambiguous anyway
19:16:12 <Cale> lpsmith: The trouble is that even if you do that with . it still makes things annoying to look at
19:16:32 <Cale> If you have a composition chain with lots of qualified names in it
19:17:10 <Cale> You have to look a bit more carefully to tell which .'s are composition and which .'s are not.
19:18:15 <pikhq> I would choose qualifiedName Map member. Or Map`qualifiedName`membere, if you want to be infixy.
19:18:18 <pikhq> :P
19:18:26 <Cale> pikhq: lovely
19:18:28 <Cale> haha
19:18:51 <Cale> qualifiedName Data (qualifiedName Map member)
19:19:04 <Cale> ;)
19:19:17 <Cale> No, but now I really like this idea from FunctorSalad
19:20:29 <Cale> Where you can leave things unqualified if there is a unique imported module such that they would typecheck if qualified with that module.
19:20:46 <pikhq> That is a nice idea.
19:21:18 <lpsmith> Cale:  I don't have to think very hard on that one
19:21:29 <Cale> I think that would remove 99% of qualifications.
19:21:37 <lpsmith> But honestly,  most languages have weird corner-cases in their syntax
19:21:39 <Cale> and it's really nice for infix operators
19:21:49 <Saizan_> we could win some obfuscation contest with that, too
19:21:50 <lpsmith> int * x;   in C is actually ambiguous
19:22:08 <lpsmith> ehh
19:22:25 <lpsmith> Depends on where you want the disambiguation necessary
19:22:40 <lpsmith> and that also introduces ad-hoc overloading, in essence
19:22:43 <Cale> It would mean that I essentially never have to qualify anything from Data.Set or Map
19:22:51 <lpsmith> which certainly does *not* mesh well with Haskell's type system
19:23:04 <Saizan_> it's not really overloading
19:23:14 <lpsmith> yes it is
19:23:23 <pikhq> if(foo) if(bar) baz; else qux; -- Now *that's* ambiguous.
19:23:38 <Saizan_> it won't be part of the type system, at least
19:23:46 <oklopol> pikhq: no it isn't
19:24:11 <pikhq> oklopol: Wrong example?
19:24:21 <pikhq> Or just a poor one?
19:24:27 <lpsmith> foo * x;   in C is either a multiplication of foo and x where the result gets ingored
19:24:30 <Cale> lpsmith: It'll require exactly one of the module qualifications to typecheck, which I think makes things rather simple, typechecking-wise.
19:24:31 <oklopol> pikhq: how is it ambiguous? doesn't c++ just choose one of the interpretations
19:24:37 <lpsmith> or a variable declaration
19:24:39 <Cale> lpsmith: Since modules are already typechecked separately
19:24:54 <mmorrow> oklopol: ambiguous in that there is more than one choice
19:24:57 <oklopol> i thought it'd choose if(foo) {if ... else ...}
19:25:10 <oklopol> mmorrow: but i don't think there is, i think the order is specified.
19:25:14 <oklopol> i mean parsing
19:25:30 <Cale> lpsmith: isn't int a keyword?
19:25:47 <FunctorSalad> but foo isn't
19:25:51 <pikhq> Cale: Sure, but you can make arbitrary typedefs.
19:25:53 <lpsmith> Yeah, probably, that's why I moved to foo
19:25:55 <mmorrow> oklopol: ah sure, but i just mean that the fact that it needs to be specified means that it's an inherently ambiguous situation
19:25:55 <Cale> ah, right
19:26:02 <pikhq> typedef foo int; foo foo; foo * x;
19:26:18 <lpsmith> the way to parse "foo * x;" depends on whether or not there is a typedef
19:26:41 <oklopol> mmorrow: it's ambiguous to human eyes, because it's ambiguous in most natural languages, but there's nothing inherently ambiguous about it, methinks.
19:27:09 <mmorrow> oklopol: why? aren't both ways valid parses?
19:27:31 <pikhq> mmorrow: Ah, but "the spec says which one to choose!" makes it not ambiguous, he claims.
19:27:35 <Cale> lpsmith: So, while I agree that it's a little bit like ad-hoc overloading, it is such a weak form of ad-hoc overloading that the type system itself doesn't even need to know about it.
19:28:10 <Cale> (so I think that's okay)
19:28:20 <mmorrow> oklopol: yeah, i mean that it's ambiguous in the sense that, if there were no specified way of interpreting it, you wouldn't know how to interpret it
19:28:23 <oklopol> i may have a different definition of ambiguous. if your definition is "some languages might define this differently" or "natural languages leave this ambiguous", then yes, it's ambiguous
19:28:25 <pikhq> oklopol: That bit of ambiguity is one of the major reasons that C does not have a context-free grammar.
19:28:30 <lpsmith> Cale:  I don't think you are right
19:28:34 <Cale> lpsmith: hm?
19:28:38 <oklopol> mmorrow: i also wouldn't know what a+b means if it wasn't specified what it means.
19:28:48 <mmorrow> oklopol: what about (a + b * c)
19:28:57 <Cale> lpsmith: Remember that if it's actually ambiguous which module the thing comes from, it's an error just like it currently is.
19:28:57 <pikhq> oklopol, you're being dumb.
19:29:05 <pikhq> Stop it.
19:29:16 <mmorrow> the only reason you know what that means is that the fixity of (+) and (*) is specified
19:29:36 <Cale> lpsmith: So you just typecheck each of the possible modules which it came from, and if *exactly* one of them typechecks, you behave as if the name was qualified with that module.
19:29:41 <lpsmith> You said that you are using the type system to disambiguiate.... I have a little trouble with type theory on a few counts,  but I strongly suspect that the changes to the type system are much deeper and more profound than you think.
19:30:15 <Cale> lpsmith: Modules are typechecked separately
19:32:22 <Cale> lpsmith: You could also just try each possibility, compiling the whole module each time, and fill it in with those qualifications if there's a unique way to succeed
19:32:30 <Cale> But that would be far less efficient.
19:32:34 <lpsmith> you have mutually recursive functions...
19:32:50 <Cale> lpsmith: But not (generally) in separate modules
19:33:16 <Cale> Well, Haskell98 technically allows that, but GHC doesn't without lots of hackery.
19:35:27 <Cale> (hackery which is much worse than providing qualifications in the first place)
19:35:30 <FunctorSalad> .hs-boot
19:35:32 <FunctorSalad> ?
19:35:34 <Cale> yeah
19:44:23 <tavelram_> :t brackett
19:44:24 <tavelram_> :t bracket
19:44:24 <lambdabot> Not in scope: `brackett'
19:44:25 <lambdabot> Not in scope: `bracket'
19:45:21 <copumpkin> @hoogle bracket
19:45:21 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
19:45:21 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
19:45:21 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
19:45:52 <tavelram_> @src bracket
19:45:53 <lambdabot> bracket before after thing = block $ do
19:45:53 <lambdabot>     a <- before
19:45:53 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
19:45:53 <lambdabot>     after a
19:45:53 <lambdabot>     return r
19:46:15 <tavelram_> thing :)
19:46:38 <Saizan_> at worst it'd be like creating typeclasses and instances on the fly and force the generated contexts to be resolved inside the module
19:46:56 <copumpkin> that hoogle type is broken
19:46:58 <copumpkin> bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:47:06 <copumpkin> I thought it looked a little messed up
19:47:12 <tavelram_> indeed
19:47:23 <tavelram_> @src block
19:47:24 <lambdabot> Source not found. You untyped fool!
19:47:32 <tavelram_> @hoogle block
19:47:32 <lambdabot> Control.Exception block :: IO a -> IO a
19:47:32 <lambdabot> System.IO BlockBuffering :: Maybe Int -> BufferMode
19:47:32 <lambdabot> Control.Exception BlockedIndefinitely :: Exception
19:47:39 <tavelram_> :t block
19:47:41 <lambdabot> Not in scope: `block'
19:47:44 <tavelram_> nevermind then
19:47:57 <lpsmith> @let mfixish f = Cont (\k -> fix (\a -> runCont (f a) k))
19:47:59 <lambdabot>  Defined.
19:48:12 <lpsmith> anybody have an idea for a name for mfixish?
19:48:38 <lpsmith> @let mfixishT f = ContT (\k -> mfix (\a -> runContT (f a) k))
19:48:39 <lambdabot>  Defined.
20:11:43 <solidsnack> How many people have seen this bug? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7386
20:30:17 <dolio> > runState State { runState = \s -> (s,s) } 5
20:30:18 <lambdabot>   (5,5)
20:33:52 <dolio> > flip runState 5 $ const State { runState = \s -> (1,s) } State { runState = \s -> (2,s) }
20:33:53 <lambdabot>   (1,5)
20:34:16 <Axman6> > runState return 5
20:34:17 <lambdabot>   Couldn't match expected type `Control.Monad.State.Lazy.State s a'
20:34:38 <Axman6> > runState (return 5) 5
20:34:39 <lambdabot>   (5,5)
20:34:43 <Axman6> > runState (return 7) 5
20:34:44 <lambdabot>   (7,5)
20:34:49 <uman> Hi, after a bit of hiatus I'm trying to learn Haskell again.
20:34:57 <uman> I've got a question about a bit in LYAH
20:35:03 <Axman6> ask away
20:35:31 <uman> he writes: length' xs = sum [1 | _ <- xs], and follows it by the following text:
20:35:44 <uman> _ means that we don't care what we'll draw from the list anyway so instead of writing a variable name that we'll never use, we just write _. This function replaces every element of a list with 1 and then sums that up. This means that the resulting sum will be the length of our list.
20:36:17 <uman> this seems to imply that "_" has some special meaning, but couldn't we have just as easily written sum [1 | foo <- xs]
20:36:35 <bd_> yep.
20:36:52 <bd_> all _ means is to throw away the value, instead of putting it into a variable
20:37:10 <uman> okay
20:37:20 <uman> so _ is special... I can't name a variable _
20:37:47 <bd_> variables aren't allowed to start with _ in general in Haskell. Or in C for that matter.
20:38:11 <thoughtpolice> > let _wat = 1 + 1 in _wat
20:38:12 <lambdabot>   2
20:38:14 <bd_> oh.
20:38:17 <bd_> nevermind then!
20:38:30 <Axman6> uman: using _ means the compiler won't give warnings about unused variables
20:38:56 <uman> Axman6: okay, I see.
20:39:05 <Axman6> i think doing sum [1|_foo <- xs] won't give a warnig either
20:39:09 <Axman6> warning*
20:39:22 <thoughtpolice> uman: essentially, you can use _ anywhere you have a pattern match (like function arguments.) it simply tells the compiler not to bind that parameter to any variable, because it "doesn't matter"
20:39:41 <uman> that seems like something that wouldn't be useful very often
20:39:56 <uman> but the only programming paradigms I know are imperative and oo, so functional is completely new to me
20:40:01 <thoughtpolice> it's useful when you have functions which are defined as a set of pattern matches
20:40:06 <uman> so my speculations are likely wrong
20:40:10 <thoughtpolice> and you need a 'default case'
20:40:18 <thoughtpolice> @src head
20:40:18 <lambdabot> head (x:_) = x
20:40:19 <lambdabot> head []    = undefined
20:40:21 <uman> okay
20:41:18 <thoughtpolice> > let x = 1 in case x of { 2 -> "hi!"; 3 -> "bye!"; _ -> "go away" }
20:41:20 <lambdabot>   "go away"
20:41:21 <vav> it's makes it easier to understand code, too, esp with functions of many parameters f a _ _ d = .... you know that part of f's definition doesn't make any use of b or c
20:42:01 <uman> unrelated question, how long do you guys think I'll have to stick at learning haskell before I can do something useful with it?
20:42:18 <thoughtpolice> define 'useful' :)
20:42:34 <thoughtpolice> I spent a lot of time toying around, writing unix tools, little packet sniffers etc. and things began to click
20:42:37 <uman> helping me be more productive at work
20:42:38 <thoughtpolice> also lots of sitting in #haskell :)
20:42:51 <uman> where I use C# exclusively
20:43:02 <ray> 5 minutes :P
20:43:41 <thoughtpolice> there are a lot of good guarantees you can get from things like the type system/purity that can - in the slightly longer-run - can help productivity/stability a lot
20:43:47 <Axman6> uman: if you can use recursion effectively, you'll be doing well
20:44:16 <uman> actually I'll only be at my current job for three more weeks
20:44:29 <uman> but I will remain a "hobbyist programmer" subsequently
20:44:48 <Axman6> uman: also, if you can write pure functions in other languages, you'll help yourself a lot
20:45:11 <thoughtpolice> particularly, QuickCheck is awesome for pure stuff
20:45:23 <uman> mmm
20:45:34 <uman> personally I hate OOP, I would rather write C all day long than C#
20:45:53 <thoughtpolice> for a good example, see xmonad: there are hundreds of quickcheck properties, and you cannot even make a commit unless all properties pass.
20:46:19 <uman> (not because I write OOP in C# and dislike it, but becaues I like most .net programmers write pure imperative code that would be better suited for c)
20:46:31 <vav> uman: http://holistic-personal-development.com/2008/12/06/ten-thousand-hours -- so if to be useful is 10% of the way to master, 1000 hours. ;-)
20:46:35 <thoughtpolice> this means once you get a good amount of properties, you can actually do pretty drastic things to your code base - such as a complete rewrite. and if the properties still hold, you have very high confidence your changes are 'right'
20:47:38 <uman> anyone know how to copy text in PuTTY?
20:47:54 <uman> I'm on windows, ssh'd into a linux box running irc... I want to copy that link and paste it into my browser
20:47:59 <thoughtpolice> uman: just select with the mouse and ctrl-c ?
20:48:05 <uman> (sorry for the OT question, but I think someone here might know)
20:48:23 <ray> select it
20:48:30 <uman> thoughtpolice: doesn't work... I'll just type by hand
20:48:50 <ray> just select it
20:48:52 <thoughtpolice> uman: at least, IIRC. back when I essentially converted to linux, I was still using windows as my primary computer, so I would just SSH into my local VMware machine running linux with putty and fullscreen everything
20:49:02 <ray> to paste into putty, right click
20:49:08 <thoughtpolice> and that was, primarily, because you can copy and paste with putty
20:49:18 <thoughtpolice> but you cannot copy-paste between vmware/windows unless you have vmware tools
20:49:18 <purplepenguins> uman, right click and check the moenu for copy?
20:49:19 <ray> it tries to be like X in that way
20:49:22 <uman> 20:49 < thoughtpolice> uman: at least, IIRC. back when I essentially converted to linux, I was still using windows as my primary computer, so I would just SSH into my local VMware machine running linux with putty and fullscreen everything
20:49:29 <uman> eek, sorry, tried right-clicking
20:49:43 <uman> don't worry, I just typed the address by hand
20:49:58 <ray> be careful where you right click! i always keep single characters copied when i'm using putty just in case
20:50:19 <uman> why didn't they make it middle-click if they were going for similarity with X
20:50:19 <ray> i've had some bad experiences
20:50:38 <ray> can't really assume you have a middle button
20:50:55 <uman> actually, since PuTTY is a windows app, they should make it follow Windows copy/paste conventions, imo
20:51:16 <ray> the default setting is "compromise"
20:51:22 <thoughtpolice> I DO WOT I WANT
20:51:31 <ray> it can be changed to windows or xterm
20:51:42 <uman> ray: okay, I'll look into that
20:52:01 <ray> it can even be changed to select a box
20:52:13 <uman> later; right now I've got to get cracking on those 10k hours ;0
21:09:53 <uman> also, I think the tutorial is simply lying when it says you can't have a 1-tuple
21:10:47 <Zao> How'd you make and type one?
21:10:59 <Axman6> indeed it is, there's a OneTuple package on hackage
21:11:05 <Axman6> it was created as a joke ;)
21:11:16 <uman> hmm, I guess I'm confused...
21:12:06 <uman> oh, duh, I was typing ('a') and such... but I guess it just interprets that as a character surrounded by parentheses
21:12:13 <Axman6> yep
21:12:21 <uman> Prelude> :t ('a')
21:12:21 <uman> ('a') :: Char
21:12:28 <Axman6> a opne tuple would just be unnecessary indirection
21:12:32 <Zao> :t (Char)
21:12:34 <lambdabot> Not in scope: data constructor `Char'
21:12:42 <uman> Axman6: it said as much in the tutorial
21:12:51 <Axman6> heh :0
21:12:53 <Axman6> :)*
21:12:54 <vav> \x -> (Just x, Nothing) ?
21:13:04 <uman> I should stop assuming I'm smarter than BONUS
21:13:14 <uman> heh
21:13:18 <Zao> Methinks it's time to stop coding when you can't distinguish an expression from a type annotation.
21:13:26 <Zao> <-
21:14:02 <uman> I miss xmonad whenever I'm forced to use WIndows
21:14:30 <uman> actually having to go drag my rat and click on windows
21:14:48 <Axman6> oh man, Richard Feynman is fantastic
21:15:02 * uman read that as "Richard Stallman"
21:15:32 * Axman6 glares with disgust
21:15:56 <uman> hey, Stallman is a pretty great guy
21:16:02 <Axman6> no he's ot
21:16:05 <Axman6> not*
21:16:08 <uman> but there's a fine line between genius and loon
21:16:15 <uman> and he's well on the "loon" side
21:16:26 <uman> Axman6: the man gave us GNU
21:16:37 <Axman6> exactly. he's a horrible man
21:16:45 <uman> I mean I don't care for the "tomboy shouldn't be in Debian, boycott harry potter" ranting
21:17:15 <uman> Axman6: I'd be interested to know what problems you have with GNU
21:17:34 <Axman6> it's too restrictive
21:17:54 <dolio> Boycott Harry Potter?
21:18:08 <dufflebunk> woohoo! -O3 cuts the run tim down to 1/3
21:18:34 <dufflebunk> time, not tim. cutting tim down would be cruel.
21:18:36 <Axman6> dufflebunk: with ghc?
21:18:38 <dufflebunk> yeah
21:18:59 <Axman6> i've heard using -O3 isn't advisable, and doesn;t do much more than -O2
21:19:01 <ray> no dynamic linking please
21:19:43 <dolio> -O3 doesn't do anything more than -O2 for GHC.
21:19:54 <dolio> Unless you're talking -optc-O3 along with -fvia-c.
21:20:19 <uman> dolio: yes, Stallman asked that people not buy Harry Potter books
21:20:21 <uman> I forget why
21:20:31 <uman> maybe they talked about Linux without the GNU/, who knows
21:20:46 <dolio> Something about a Canadian DMCA, apparently.
21:20:47 <dufflebunk> nope, just -O3. -O2 seems to be the same speed.
21:21:01 <uman> Axman6: GNU was the first free Unix, I believe
21:21:11 <uman> I mean, I'm too young to remember any of it, but I believe I've read that
21:21:11 <ray> exactly
21:21:15 <ray> he's a horrible man
21:21:21 <Axman6> uman: i don't think that sentense makes any sense...
21:21:45 <uman> Axman6: gnu was the first free software implementation of unix
21:21:58 <uman> that assertion may be true and it may be false, but I fail to see how it's nonsensical
21:22:00 <dufflebunk> dolio: there is no Canadian DMCA
21:22:05 <Axman6> well it's not unix, it's a unix like system
21:22:11 <dufflebunk> although they do keep trying to make one
21:22:15 <uman> Axman6: you know that's what I mean
21:22:55 <uman> I'm using "unix" in the same way as I say "kleenex" and my parents say "xerox"
21:23:05 <dolio> dufflebunk: I think the point is that he wants to keep it that way, and the publisher behind Harry Potter was supporting something related.
21:23:25 <ray> it should be renamed 4BNIH for 4.3BSD Not Invented Here
21:23:39 <dolio> I just skimmed his rant.
21:24:23 <ray> but that's not the point - how is implementing a unix clone a good thing
21:24:34 <dufflebunk> Yay! 70% of the time is I/O bound, so only 30% is real work, and only 10% slower than pure C.
21:24:45 <ray> anyone who does that should be made into an immortal cyborg and placed into orbit for eternity
21:25:23 <uman> ray: well, because currently the only viable alternatives to Windows on the desktop are unix clones
21:25:30 <ray> dolio: the publisher told people who accidentally got early copies not to read them until the release date
21:25:36 <uman> I know that's not what Stallman ever had in mind, but it's a pretty good consequence of his work
21:25:37 <dolio> Heh.
21:25:43 <ray> uman: i am so not going there
21:25:46 <uman> I prefer not using Microsoft
21:25:49 <uman> ray: what do you mean?
21:25:58 <ray> if i do, you might end up in orbit..
21:26:03 <dolio> ray: That is pretty laughable.
21:26:08 <ray> yeah
21:26:35 <ray> stallman got mad i guess
21:26:55 <uman> ray: I can handle disagreement. Like I said, I'm too young to have much perspective on the history of computing, and the only systems I have ever used are DOS, Windows, Linux, and a bit of OS X and Solaris
21:26:56 <Axman6> dufflebunk: those are good numbers :) now, to make it faster than C ;)
21:27:05 <uman> ray: so I'm interested on hearing your perspective
21:27:23 <ray> uman: i mean, i can't handle unix apologists anymore
21:27:38 <Axman6> ray: what do you mean by that?
21:27:41 <ray> i'd just spew aimless hate at unix
21:27:51 <ray> it would be boring
21:27:56 <uman> ray: what operating systems do you prefer?
21:28:12 <ray> haskell machine
21:28:39 <uman> there's no such thing
21:28:48 <ray> that's not the haskell machine's fault
21:28:59 <gwern> yes it is
21:29:08 <gwern> it's less perfect for not existing
21:29:17 <ray> i'd say it's more perfect for not existing
21:29:24 <ray> like anything
21:29:37 <oklopol> it is perfect, therefore it must also have the property of existing.
21:29:57 <ray> once you try to reproduce the platonic ideal
21:30:31 <uman> the conversations in here are so much more fun than in ##c
21:31:02 <oklopol> i think i'll *see* for myself
21:31:15 <vav> http://programatica.cs.pdx.edu/House -- shadow of haskell machine on the cave wall
21:31:34 <Axman6> jesus, can't MS think of something by themselves for once? they're going to be opening stores like the Apple stores, with their own 'Guru bar's -_-
21:32:02 <ray> haskell machine stores will have cale bars
21:32:29 <Zao> Axman6: http://penny-arcade.com/comic/2009/7/20/
21:32:45 <Axman6> ray: heh :)
21:32:46 <vav> ray: that would be awesome, get tired and confused at work, just snack on a cave bar and halve your LOC
21:32:52 <vav> *cale
21:32:59 * BMeph is looking forward to the first release of Haiku
21:33:10 <uman> oklopol: *see* what I mean? Right now they seem to be language lawyering on the definition of the ?: operator
21:33:22 <Axman6> Zao: ha
21:33:33 <gwern> ray: cale bars? is that where all the food is made of reverse-oriented amino acids, so you can't actually digest it even though it's more elegant than the existing Food '98 standard?
21:34:02 <ray> you can digest it if you agree to a small surgical procedure
21:34:04 <oklopol> uman: first of all the details of parsing ?: are *hilarious*, second of all emphasizing "see" was my attempt at a terrible pun, because you said this channel was fun.
21:34:18 <oklopol> guess it would've made more sense if you had said funny i guess.
21:34:23 <oklopol> *-guess
21:35:03 <uman> mmm
21:35:44 <ray> too bad they can't just go @src ?:
21:35:49 * pikhq looks at ##c
21:36:10 <uman> haha
21:36:14 <uman> #Haskell invades ##c
21:37:41 <dolio> _?_:_ : {a : Set} -> Bool -> a -> a -> a ; True ? t : _ = t ; False ? _ : f = f -- almost real Agda.
21:38:06 <pikhq> Once I get my C metaprogramming junk working, might be fun to show it to them.
21:38:06 <Saizan> : is reserved?
21:38:29 <dufflebunk> Axman6: It mostly just a FFI I'm working on right now, so it's unlikely I can get it faster than the C version ;)
21:38:29 <dolio> Yeah.
21:38:42 <dolio> You could use some unicode that looks like : but isn't.
21:38:46 <Axman6> bah, not trying hard enough ;)
21:39:45 <uman> I've always wanted to introduce multiple variables with the same glyphs in my C# code
21:40:13 <pikhq> Error handling? Actually caring about malloc returning a null pointer? Screw that. %set oomHandler { fprintf(stderr, "Ayee! No memory!\n"); exit(EXIT_FAILURE); }
21:40:20 <pikhq> :P
21:40:32 <ray> this variable is named a with diaeresis, but this one is named a followed by combining diaeresis
21:40:56 <uman> I wonder if VS2008 supports unicode source files
21:42:08 <dufflebunk> Axman6: one problem is the library I'm interfacing with has a lot of functions that take structs directly (without being a pointer). Haskell's FFI can't handle that so I have to make wrappr functions, so there's some inefficiency right off the bat. But perhaps once it's all done I could redo the higher level call with pure haskell versions.
21:42:11 <Zao> uman: Yes.
21:42:21 <Zao> uman: Even does UTF-16.
21:42:34 <Axman6> sounds good
21:42:37 <Axman6> pure++
21:42:43 <Axman6> @karma pure
21:42:43 <lambdabot> pure has a karma of 1
21:42:47 <Axman6> @karma purity
21:42:48 <lambdabot> purity has a karma of 0
21:42:50 <Axman6> :(
21:42:52 <erikc> haskell's ffi can't do pass-by-value structs?
21:42:52 * dufflebunk pokes VS* in the eye for it's annoying line ending dialog
21:42:58 <ray> @karma pureÃ©
21:42:59 <lambdabot> pureÃ© has a karma of 0
21:43:23 <dufflebunk> erikc: Yeah, doesn't like it... at least the hsc2hs stuff I've read says it can't
21:43:24 <Zao> uman: http://www.acc.umu.se/~zao/save.png
21:43:24 * uman pokes VS* in the eye for being a memory hogging beast
21:43:47 * dufflebunk one ups uman's VS* with Net Beans
21:43:51 <Zao> uman: It even does UTF-7 :)
21:44:07 <ray> hah
21:44:10 <uman> hehe
21:44:28 <uman> They want to rewrite large swaths of VS in C#
21:44:41 <Zao> uman: 2010's UI is in WPF.
21:44:44 <uman> C# runs slow and I have FOUR GIGS of memory and a COre 2 Duo with 2.0 GHz
21:44:50 <uman> er
21:44:53 <dufflebunk> Zao: word perfect?
21:44:57 <uman> s/C#/VS2008/
21:44:57 <Zao> C# itself isn't that horrible. People targetting it are.
21:45:11 <uman> "VS2008 runs slow..."
21:45:19 <Zao> dufflebunk: Windows Presentation Fblargh. .NET tech with XML fluff for UIs.
21:45:23 <uman> I'm pretty sure moving much of it to a VM is not the answer
21:45:35 * erikc is using vs2010 beta right now to do WPF programming in c# and f#
21:45:41 <uman> dufflebunk: Microsoft's theft of XUL
21:45:49 <erikc> :)
21:45:50 <Zao> uman: Everything's ngen'd down to native anyway with C#.
21:46:16 <Zao> The problem isn't with the language or the libraries, it's with people who suck at using it.
21:46:27 <pikhq> C# has monad comprehensions. Can't be *too* bad.
21:46:37 <pikhq> Obviously, people using it suck.
21:46:44 <uman> Zao: most of those people use VB.NET instead
21:46:59 <pikhq> Overlap with the Visual Basic and *Windows* C coder sets.
21:47:08 <dibblego> pikhq, I once told that to someone who got upset it
21:47:17 <Zao> My 2008 currently has a working set of 60 megs and a virtual size of 380.
21:47:20 <Zao> That's nothing.
21:47:23 <pikhq> (C on Windows without some POSIX-like environment is insanity-producing)
21:47:32 <mgsloan> WPF is indeed shitty.  They should adopt silverlight's code base (which is a .net api over a native core)
21:47:48 <dolio> Acadamics in my practical language!?
21:47:53 <pikhq> They should scrap Win32 and adopt a saner low-level API.
21:48:00 <uman> Zao: I guess memory isn't the problem
21:48:09 <uman> all I know is it's as slow as hell
21:48:23 <mgsloan> (silverlight's api is almost totally compatible with WPF, but it's a subset0
21:48:26 <pikhq> (I suggest classic Mac OS. Has more potential. :P)
21:48:30 <Zao> uman: Grab the 2010 beta. 2008 will feel Haskell-fast then.
21:49:55 <uman> Zao: I tried it but it was too buggy to use
21:49:59 <uman> Zao: I'
21:50:25 <uman> I'll get it if they give away the final version for free to students like they do with VS200(8|5)
21:51:08 <mgsloan> I was at microsoft around the time they decided to do VS2010 like that.  everyone was groaning
21:51:19 <mgsloan> everyone knows it's a bad idea
21:51:33 <erikc> gotta prove out that WPF investment tho mang
21:51:38 <Zao> mgsloan: Top-side decision, eh?
21:51:53 <uman> mgsloan: what were you working on there?
21:51:57 <mgsloan> yup, that's how it seems
21:51:59 <mgsloan> silverlight :)
21:52:14 <uman> mgsloan: you worked on silverlight? Allow me to sincerely thank you.
21:52:30 <uman> Something that took me 2mo to do in ASP.NET AJAX I redid in one week with silverlight
21:52:41 <mgsloan> hehe, welcome! I didn't do a ton, but yeah, it turned out nicely I think
21:53:03 <pikhq> uman: Could you use something more portable, like a Navajo code talker?
21:53:20 <mgsloan> Anyway, It's a bad idea to eat your own dog food when your dog food is shit
21:53:33 * pikhq has a dislike for things which manage not to work with x86_64-pc-linux-gnu
21:53:43 <mgsloan> WPF does have a fairly pretty API
21:53:57 <joed> uman: Would you put it above say Flex or Laszlo?
21:54:29 <uman> pikhq: well, the business I work for can guarantee that it will always run in IE8 on Windows
21:54:57 <Zao> uman: Luxury.
21:54:58 <pikhq> uman: Not satisfactory! Windows must be nuked from orbit!
21:55:31 <pikhq> Well, actually, the kernel can stay. It's at least workable.
21:55:52 <pikhq> Just nuke the userspace.
21:55:55 <uman> I hate how monolithic Windows is
21:56:01 <pikhq> And shoot 3/4ths of the programmers.
21:56:11 <jmcarthur> the windows kernel is not monolithic
21:56:21 <uman> jmcarthur: not talking about the kernel
21:56:26 <pikhq> jmcarthur: It's one of the few portions of Windows that shows design.
21:56:30 <pikhq> Instead of accretion.
21:56:31 <jmcarthur> okay, no disagreement then
21:56:49 <uman> jmcarthur: in Linux, I can choose my favorite shell, my favorite window manager, my favorite web browser, etc.
21:56:54 <jmcarthur> windows itself is completely loaded down with legacy technology
21:57:05 <uman> I can boot into console if I want... not forced to startx
21:57:16 <uman> all of that is either more difficult or impossible in Windows
21:57:40 <jmcarthur> trying to get the various incantations to make my low-level-ish windows code to link properly is a nightmare
21:57:49 <uman> lack of modern package management is another gripe
21:58:05 <copumpkin> I'm looking at http://cdsmith.wordpress.com/2009/07/20/calculating-multiplicative-inverses-in-modular-arithmetic/ and am getting lots of divide by zero errors for what seems like reasonable input
21:58:42 <erikc> mgsloan: i quite like WPF so far, but it strikes me that a Lisp-like .net language would have been better for WPF dev, it's ridiculously dynamic anyway, and XAML and templating might as well be s-expressions
21:59:14 <uman> is F# lisp-like?
21:59:14 <mgsloan> yup
21:59:14 <pikhq> erikc: Microsoft suffers from not invented here syndrome, though.
21:59:32 <copumpkin> and the fact that people are prejudiced against s-expressions and lispy things
21:59:38 <mgsloan> F# is basically ocaml
21:59:38 <pikhq> uman: No, it's like Haskell with terrible syntax.
21:59:45 <uman> pikhq: okay
21:59:48 <mgsloan> in other words ocaml ;)
21:59:53 <pikhq> mgsloan: My point.
21:59:53 <pikhq> :P
22:00:10 <glguy> How is F# more like Haskell?
22:00:18 <copumpkin> F# is like Microsoft Active OCaml# 2009
22:00:21 <ray> copumpkin: me too
22:00:28 <dibblego> F# is just a shiny C#, nothing like Haskell
22:00:30 <mgsloan> yeah, XAML isn't very pretty.  It's a little better than doing everything in code though
22:00:33 <copumpkin> ray: divide by zero errors?
22:00:34 <ray> the first input i tried got divide by zero
22:00:41 <erikc> uman: nah, it's ML-like, i have my own little f# helper DSL for wpf development (since xaml and f# dont mix well), and my pure F# version of my WPF program is half the LOC than the XAML/C# version :)
22:01:10 <pikhq> Hrm. Actually, like Haskell without the monads or the lazy evaluation.
22:01:24 <pikhq> So, Haskell without what makes Haskell any good.
22:01:31 <pikhq> And with a worse syntax.
22:01:42 <Vanadium> Are you sure you might not be a bit biased?
22:01:44 <dibblego> or the purity, or the type system or ... so nothing like Haskell
22:01:47 <copumpkin> ray: oh I think something is backwards
22:01:55 <erikc> dibblego: i agree :\, if you limit your f# usage to only f#, it can be ML-like, if you want it to play nice with other .net languages, its just a better C#
22:01:57 <hzap> it's ocaml with sometimes duplicate features
22:02:00 <copumpkin>         where n = p - inverse p (q `mod` p)
22:02:02 <pikhq> dibblego: Has a vaguely similar type system.
22:02:13 <copumpkin> ray: I think that's meant to be inverse q (q `mod` p)
22:02:30 <copumpkin> it'd be odd to change the modulo
22:02:45 <pikhq> Vanadium: I'm biased against .Net, because so much of it is strictly worse than other languages.
22:02:56 <uman> .net isn't a language
22:03:06 <ray> .net is a platform
22:03:11 <hzap> better than Java imo
22:03:14 <pikhq> uman: Sorry, platforms.
22:03:16 <mgsloan> and I'd say C# is actually pretty sweet
22:03:16 <uman> maybe you mean "other sets of libraries" or "other frameworks"
22:03:23 <uman> pikhq: ok
22:03:24 <pikhq> hzap: ... That's damning with faint praise.
22:03:43 <copumpkin> ray: except now it generates negative numbers...
22:03:47 <uman> does Java have anonymous delegates?
22:03:56 <ray> copumpkin: well, i didn't read the article
22:03:57 <hzap> pikhq: not meaning to praise or damn anything
22:03:59 <ray> :P
22:04:01 <pikhq> Though I can at least understand why it's being raved about on Windows; the alternatives are getting stuff that's not well-known on that system running or... Coding in C *for Win32*.
22:04:02 <copumpkin> ray: ah :P
22:04:22 <ray> except to find out what p and q are
22:04:30 <dibblego> uman, yes but they are syntactically heavier -- you can download a language extension that alleviates it
22:04:38 <copumpkin> dammit
22:04:52 <pikhq> I think I'd take coding with a card punch over coding for the Win32 API, so.
22:05:01 <uman> pikhq: hear hear
22:05:07 <dibblego> uman, if you count Scala against F# or Nemerle, then Java takes the win in many respects
22:05:33 <copumpkin> I've heard some praise for nemerle
22:05:37 <copumpkin> but haven't looked too closely at it
22:06:58 * pikhq wishes to be able to beat some POSIX into Windows.
22:07:05 <ray> no!
22:07:08 <ray> you horrible man
22:07:17 <ray> or woman, whatever
22:07:22 <ray> horrible is the important part
22:07:30 <mgsloan> did fortress ever happen?  their design doc looked very interesting
22:07:42 <pikhq> ray: That's a practical desire.
22:07:50 <uman> pikhq: Cygwin?
22:07:57 <pikhq> Ideally, I'd like to see Plan 9 take over, and then for us to work on improving things further.
22:08:00 <erikc> mgsloan: "On 1 April 2008, the first version of the Fortress specification with a compliant implementation (Fortress 1.0) was released"
22:08:06 <pikhq> uman: No, I mean, instead of Win32.
22:08:10 <ray> that's terrible
22:08:11 <pikhq> Not hacked onto Win32.
22:08:24 <ray> things don't have to get that much worse before they can get better, you know
22:08:29 <mgsloan> erikc - guess so!  Just haven't heard much about it, so I guess it didn't make much of a splash
22:08:29 <ray> if they have to get worse at all
22:08:33 <pikhq> (by "improving", I of course mean something like House)
22:08:46 <pikhq> ray: ... Worse than *Windows*?
22:08:47 <erikc> mgsloan: wonder what Oracle will do with it
22:08:48 <uman> pikhq: start writing one
22:09:00 <mgsloan> who knows.. probably nothing :(
22:09:00 <pikhq> Is that possible? It's, like, evolved, not designed.
22:09:15 <pikhq> uman: Sophomore in CS. Gimme a couple years. :P
22:09:23 <ray> i'd love to work on a haskell machine, but i can't do it alone, and practically any possible coauthors would just want to make it unix
22:09:28 <uman> pikhq: okay :)
22:09:42 <bd_> pikhq: it'd make a good thesis :)
22:09:54 <uman> pikhq: how do you like studying CS? I'm about to start college in three weeks, and my math major requires a minor in some subject. I'm considering CS.
22:09:57 <ray> this could just be pessimism on my part
22:10:06 <pikhq> ray: I suggest UNIX as the best operating system in common use *right this instant*.
22:10:16 <ray> i can't agree with that
22:10:23 <uman> ray: what is, then?
22:10:23 <pikhq> Not because it's great, but because it is not exceptionally bad.
22:10:23 <oklopol> uman: i'm thinking switching to math from cs
22:10:24 <ray> i can agree that it's the worst
22:10:31 <pikhq> ... What do you think is any better?
22:10:47 <ray> i kinda liked dos 5.0
22:10:51 <Gracenotes> âƒâ€¿âƒ
22:10:58 <pikhq> I said "better".
22:10:59 <bd_> DOS is more of a bootloader than an OS, really
22:11:12 <Axman6> Gracenotes: well said
22:11:19 <bd_> an 'enhanced BIOS' if you will
22:11:35 <ray> see, if you were just going to say that if i didn't say something lunixy enough for you, why did you ask? :)
22:11:44 <uman> and a shell they didn't replace until Vista
22:11:51 <uman> ray: he said "in common use"
22:12:01 <pikhq> And also better.
22:12:06 <bd_> ray: well, I don't think an OS without a scheduler, and with access to only <1MB of memory natively, counts
22:12:18 <ray> well, it was the most recent os i was able to hack in
22:12:26 <ray> if we're going by that
22:12:37 <erikc> mgsloan: oh, the current version of fortress is a reference interpreter ... so ... many years from being viable if development was occurring today :)
22:12:56 <mgsloan> erikc: ahh, that'd explain it
22:13:01 <bd_> ray: *shrug* Linux or the BSDs will let you get as close to the hardware as you want. Write assembler running in ring0 if you like.
22:13:05 <mgsloan> Here I figured it was a java thing
22:13:29 <ray> if we're going by "good for general use", i have windows nt anything
22:13:35 <uman> pikhq: I've heard CS curricula are really lame, and filled with students who think there's a lot of money in it but aren't cut out for law or medicine
22:13:40 <uman> is that true in your experience?
22:13:47 <pikhq> No.
22:13:57 <uman> where do you go?
22:13:59 <pikhq> ray: ... Windows NT. A good OS.
22:14:03 <hzap> uman: I had a pretty good experience so far
22:14:06 <pikhq> ray: What the hell are you smoking?
22:14:22 <ray> pikhq: i'd appreciate it if you didn't say stuff like that
22:14:26 <bd_> uman: might depend on the school. I transferred from the university of maine at orono to umass amherst, and in general the CS students in the latter have seemed a lot more competent
22:14:31 <ray> i try to resist the urge to say "unix? good? keep off the crack"
22:14:32 <pikhq> uman: Missouri University of Science and Technology.
22:14:34 <uman> ray: you prefer, say, Vista, to modern Unix-like systems?
22:14:48 <ray> yes, except i think "modern unix" is a contradiction
22:14:49 <bd_> pikhq: actually, the NT API's not all bad, really. I wish Linux had something like overlapped IO, for example :)
22:14:53 <pikhq> ray: It's like suggesting a Model T with a V8 strapped on as a good OS.
22:15:03 <uman> ray: s/modern/recent/
22:15:11 <ray> then just "yes"
22:15:13 <pikhq> Erm. Actually, no, that was the Win95 line.
22:15:20 <impl> people, please. we all know the only decent operating system is z/OS.
22:15:23 <bd_> I don't like the low-level UI calls though, and the application development culture is rather ugly, though
22:15:28 <uman> impl: I prefer emacs
22:15:37 <impl> everything else are children's toys.
22:15:42 <impl> uman: hah :D
22:15:56 <pikhq> WinNT is more like a Toyota chassis with a Model T's interior. And engine.
22:15:57 <pikhq> :P
22:15:58 <ray> i prefer haskell, if you're allowing that
22:16:02 <Cale> At Waterloo, you can get a BMath in CS or a BCS. The BCS is the one which is intended to make it easier to double major with something else.
22:16:20 <uman> where is that
22:16:21 <Cale> (I did a BMath in pure mathematics, myself)
22:16:22 <uman> Canada?
22:16:23 <Cale> yeah
22:16:26 <Cale> Ontario
22:16:38 <uman> I get depresses when people start talking about canadian schools
22:16:48 <hzap> lol?
22:16:50 <pikhq> ray: The thing is, Windows NT is, aside from the kernel, *not designed*.
22:16:51 <joed> Why?
22:16:52 <pikhq> It has evolved.
22:17:15 <uman> I wanted to go to McGill really badly (more about wanting to live in Quebec than anything) and really thought I'd be able to, but my parents decided they didn't want to pay for it
22:17:22 <pikhq> That is not how a good OS is built.
22:17:28 <joed> Oh.
22:17:32 <uman> I don't mean to sound like a spoiled rich kid... they have every right not to spend extra money on me. They worked hard to earn it
22:17:34 <impl> pikhq: Well, most (all commonly-used?) operating systems are like that.
22:17:37 <Gracenotes> âŒ¤
22:17:39 <ray> the thing is, unix is not designed built blah blah blah 50 damn years
22:17:42 <impl> The Linux kernel's API changes on a whim
22:17:52 <ray> or in other words, "i can't respond to that"
22:17:59 <uman> but I was still all excited about it only to end up at Local State U.
22:18:52 <Cale> uman: Yeah, it can be *really* expensive if you're not Canadian.
22:18:54 <impl> uman: I got into UC Berkeley but couldn't afford it, either. I know how you feel.
22:18:57 <pikhq> ray: Okay, fine. It's a 64-bit extension to a 32-bit extension to a 16-bit OS for an 8-bit computer with a 4-bit processor written by a 2-bit company that doesn't know 1 bit about computing. :P
22:19:01 <joed> ray, BSD or ATT? Linux, sure, minix was a fun thing, buy your statement is kinga odd?
22:19:17 <uman> Cale: yeah, although it'd have been cheaper than going to CMU
22:19:38 <uman> or UIUC
22:19:44 <pikhq> Or, on a more serious note: "Hello, world!" is 150 lines of code.
22:19:44 <ray> i especially can't respond to half out of context remarks aimed at quarter remarks that i typed one eighth of into irc
22:19:50 <pikhq> That is a sin against mankind.
22:20:18 <erikc> pikhq: that's not true
22:20:21 * BMeph was accepted to Stanford, but the local uni gave him a scholarship
22:20:26 <ray> pikhq: i don't want you to get offended by this, but i really can't continue to respond to your ridiculous remarks
22:20:30 <uman> BMeph: Nice, I was rejected from them
22:20:30 <ray> it's not you, it's me
22:20:44 * impl too.
22:20:44 <pikhq> ray: You started it. Really, NT, good. :P
22:20:48 <uman> BMeph: best school I got into was CMU... I want to frame the acceptance letter in my UA dorm :P
22:20:50 <ray> have you used it?
22:20:56 <pikhq> Yes, I have.
22:21:03 <ray> i can understand if you don't want to give windows a chance because it's expensive
22:21:12 <pikhq> Have you administrated it?
22:21:12 <uman> who cares if Linux was based on an OS written in 1969
22:21:25 <uman> how is that a relevant argumen
22:21:41 <impl> Windows is based on Mac which is based on Xerox which is from like 1969 too.
22:21:42 <impl> so.
22:21:51 <joed> BMeph: nice, I'm swedish so that never was an issue, now I am looking hard to keep my daughters chances (By her own doing) to giving her maximum choice.....
22:22:14 <pikhq> It's little things like having basic toolkits (the MSI SDK, in this case) consist of an MSI which installs a bunch of MSIs in Program Files that gets to you.
22:22:24 <copumpkin> well, nowadays many of the richest colleges in the US will give you a free ride if they accept you and you can't afford it
22:22:26 <joed> impl: ? You mean the idea of a GUI>
22:22:26 <pikhq> (and no, there was no documentation of this)
22:22:42 <impl> joed: yeah, that was pretty central to Windows after DOS, wasn't it?
22:22:44 <BMeph> uman, impl: Just for more context, that was twenty-odd years ago. I still don't have a Bachelor's, though... :\
22:22:45 <uman> copumpkin: s/you/your parents/
22:23:01 <copumpkin> uman: whoever would normally pay and be in debt, which can be you, depending on your situation
22:23:06 <impl> BMeph: s'okay. Formal education is a joke these days more often than not.
22:23:23 <uman> copumpkin: well if you have rich but stingy parents, you're kind of screwed, no?
22:23:44 <groberts> What would be an appropriate type signature for for a function that is passed a list of strings and returns a float?
22:23:44 <ray> if your parents are rich, and you can't touch it, you're not really rich, are you?
22:23:48 <impl> BMeph: I gave up after a year.
22:23:53 <copumpkin> uman: depends how much you're willing to detach from them
22:24:00 <uman> ray: yes, but for the purposess of college financial aid you are...
22:24:27 <copumpkin> uman: if you aren't their dependent, their finances are none of their business
22:24:30 <pikhq> ray: It's assumed that crazy amounts of your parents income are going towards your college.
22:24:34 <copumpkin> but that usually involves big drama :)
22:24:39 <BMeph> impl: I'm still at it. I love to learn, but hate to write. A funny flaw for a computer guy... ;)
22:24:53 <pikhq> People making 40k are expected to hand out like 10k to college students. Funny...
22:24:57 <impl> BMeph: hah
22:25:05 <copumpkin> BMeph: did you look carefully at that cdsmith mod inverse function? it didn't seem to work (I saw you commented on the blog post)
22:25:13 <uman> I should stop complaining
22:25:18 <copumpkin> pikhq: not really
22:25:27 <pikhq> copumpkin: Their definition of 'dependent' just about means "younger than 21, was a dependent at the age of 18".
22:25:31 <pikhq> Craziness.
22:25:40 <copumpkin> pikhq: as I said, the richest colleges will give you a full ride if your family makes 70-80k or less a year
22:25:45 <uman> I have a friend who through combination of parents, scholarships, and financial aid, literally cannot afford to go to university
22:25:47 <BMeph> copumpkin: "carefully"? ah, no. ;)
22:25:48 <copumpkin> pikhq: and will give you significant financial aid up until around 120
22:25:56 <copumpkin> pikhq: not really
22:25:59 <pikhq> Sure. If you can get into the richest colleges.
22:26:10 <copumpkin> well we were talking about stanford a little while ago
22:26:19 <dufflebunk> Anyone have an example of the use of withMany? The first parameter is strange looking.
22:26:25 <joed> Like Harvard that blew their budget on stupid things?
22:26:26 <copumpkin> dufflebunk: what's that from?
22:26:38 <dufflebunk> on, nm, I know what it is.
22:26:39 <pikhq> If I were going to one of the richer colleges, I wouldn't have trouble getting financial aid.
22:26:47 <dufflebunk> copumpkin: Foreign.Marshal.Utils
22:26:52 <Gracenotes> @hoogle withMany
22:26:52 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
22:26:56 <copumpkin> :o
22:27:00 <copumpkin> wow :P
22:27:06 <uman> my dad hasn't told me how much he makes, but I think it's just under 150k
22:27:07 <dufflebunk> Yeah, I just need to with 'with' as the first param
22:27:08 <ray> nice type signature
22:27:13 <uman> so I'm basically fucked for fin. aid. no matter what
22:27:16 <dufflebunk> @hoogle with
22:27:16 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
22:27:17 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
22:27:17 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
22:27:23 <vav> :t sum . concat . map read -- groberts a is Float in your case
22:27:24 <lambdabot> forall a. (Num a, Read a) => [String] -> a
22:27:27 <uman> luckily I got a merit scholarship at U of A
22:27:32 <copumpkin> A?
22:27:34 <pikhq> uman: My parents make $50k or so, and I can't get like any financial aid.
22:27:38 <uman> copumpkin: rizona
22:27:42 <Gracenotes> withMany seems to be a map-like function..
22:27:44 <pikhq> ... Note that my parents are still paying off student loans.
22:27:47 <joed> uman: you  should punish him for being such a mediocre soul.
22:27:53 <vav> groberts:  [String] -> Float
22:27:58 <uman> joed: what in the world do you mean?
22:28:02 <uman> my father is a great guy
22:28:27 <joed> uman: I'm glad, it came across as a really dumb remark.
22:28:35 <copumpkin> BMeph: I can't get it to work nicely :(
22:28:51 <uman> joed: what did?
22:29:19 <impl> I think it's interesting that a lot of Europeans take a year off between high school and university and go on trips and stuff.
22:29:28 <impl> I wonder why that never caught on in the US.
22:29:30 <uman> impl: I think that's largely a UK thing
22:29:44 <impl> I know a lot of people in Sweden do it
22:29:47 <joed> uman: If he makes that he is in the x percentile, makes a good living and can provide for you, possibly not harvard and a new car at 16, but yes, he'd make a good 4 beedroom home and two cars as well as saving for your getting out of school.
22:30:13 <uman> joed: It's his money, not mine, he can spend it as he chooses
22:30:16 <impl> Norway as well, I think.
22:30:19 <BMeph> copumpkin: I'll check it out. Carefully. ;p
22:30:21 <joed> impl: Yeah, we also do a few trips in high school if we can.
22:30:34 <uman> joed: he worked very very hard all his life to get to that level
22:30:44 <impl> joed: I really, really like that model.
22:30:50 <impl> I think it gives you a nice perspective on things.
22:30:59 <joed> uman: Yep, my point exactly and yeah, we say the same thing.
22:31:19 <uman> joed: okay
22:31:19 <ray> empirically, going to college twists you into a linux user, so my kids are staying far away :P
22:31:30 <impl> ha.
22:31:49 <impl> IRC twisted me into a Linux user, so you'd better /quit. :D
22:32:06 <copumpkin> lol
22:32:11 <Vanadium> What are identifiers starting with a ?
22:32:18 <ray> irc made me realize what a cult i had bought into with linux
22:32:20 <pikhq> ray: I've been using GNU/Linux since middle school.
22:32:24 <ray> i guess it goes both ways
22:32:42 <ray> pikhq: and you call it gnu/linux, so you're pretty special
22:32:45 * BMeph dispairs of being a Unix hacker just to use IRC, and types: /wrists
22:32:49 <joed> impl: another thing we do on Phd/masters is usually at least one year abroad.
22:32:56 <impl> To be honest, I don't really like Linux. But it lets me get my work done.
22:33:09 <uman> joed: I have it better than a lot of teenagers. I have his old car and he pays the insurance... I am geting to go to uni AT ALL which is more than most can say... I'll be 20 in a month, starting university late because I spent a year in France
22:33:17 <pikhq> ray: I don't think it's a great OS, I think it's just the least sucky OS that lets me get my work done.
22:33:18 <impl> joed: Well, a lot of kids do take a semester to study abroad here, now that you mention it
22:33:22 <impl> I had forgotten about that
22:33:28 <uman> joed: so you are right, I cannot complain that poor me can't be paid for to go live in Quebec for 3 years
22:33:33 <ray> i used to not really like windows, but it let me get my work done, but i've grown pretty fond
22:33:36 <impl> Although it's not really travel, it's pretty sheltered.
22:33:49 <pikhq> Try programming in Win32 some time.
22:33:54 <ray> various "hey, that makes sense" moments
22:34:00 <uman> ray: what do you prefer about windows as opposed to Linux?
22:34:02 <pikhq> You will soon begin to wonder how anything works.
22:34:03 <impl> ray: I like Linux for the fact that I can bring up 5 different Web servers in a matter of seconds from a console.
22:34:06 <joed> uman: :) Thank you - I'm close to 40, with small kids of my own, seeing you say that makes me happy.
22:34:18 <impl> ray: It's just a means to an end for me.
22:34:30 <pikhq> (or learn how the Windows dynamic linking works. Read-write memory shared across all processes... *shudder*)
22:34:37 <ray> i like windows because i can bring up 3 different variations on solitaire in a matter of seconds?
22:34:43 <pikhq> s/linking/linker/
22:34:44 <ray> what a weird thing to say
22:34:51 <ray> (i hear it all the time by the way..)
22:35:06 <ray> (even said it myself, and i still don't know what it's supposed to mean)
22:35:09 <uman> ray: then what do you like better about it?
22:35:14 <impl> ray: Well, ... how long does it take you to launch five different Web servers on Windows?
22:35:24 <ray> i don't know, why would i ever do that on any system
22:35:37 <ray> you say that like it's not a non sequitur
22:35:50 <ray> uman: it's hard to explain succinctly
22:35:51 <impl> Because I need to make sure the code I write works on Apache, lighttpd, nginx, and Cherokee, for instance.
22:35:54 <ray> without relying on assumptions
22:36:01 <Gracenotes> ray: well I can have 82 types of solitaire in Linux
22:36:03 <Gracenotes> !!
22:36:06 <uman> I can bring up 100 tabs of porn in firefox in a matter of seconds
22:36:07 <uman> I win
22:36:08 <ray> !! indeed
22:36:15 <mmorrow> ray: i like linux because via the package manager i can install all known (open source) versions of solitaire in a matter of seconds :)
22:36:19 <Gracenotes> with my gnome aisleriot software
22:36:28 <mmorrow> then delete them when i finish playing
22:36:29 <impl> But it wasn't meant as a specific example so much as it was meant to say "I need this for my work and it lets me do it quickly."
22:36:32 <ray> lol
22:36:37 <impl> which is why I use it.
22:36:39 <Gracenotes> which has an insane number of varieties. half of them were probably invented just for the software.
22:37:28 <ray> it's almost like i didn't type "what a weird thing to say" up there
22:37:43 <Axman6> > 64^(200*150)
22:37:45 <lambdabot>   250737630039417060670211540379616592962552808551980856025609903075141228351...
22:38:04 <ray> if i didn't know better, i'd think you people thought i was seriously claiming that bringing up a bunch of solitaires is a killer feature of windows
22:38:31 <mmorrow> well, also using windows for "critical" tasks scares me
22:38:44 <uman> ray: do you like it from a user's perspective, or a programmer's, or an administrator's?
22:38:59 <ray> well, i use it
22:38:59 * BMeph went to U of A from '86 to '93
22:39:01 <joed> mmorrow: Yet it is often tried...
22:39:07 <uman> BMeph: Nice
22:39:11 <ray> these days i only program in haskell, without system specific things
22:39:15 <uman> BMeph: my father graduated in 1985
22:39:17 <mmorrow> joed: the horror! :)
22:39:19 <ray> just fun abstract stuff
22:39:33 <BMeph> copumpkin: Was it smith's version you couldn't get to work, or mine? :)
22:39:34 <ray> i've never administrated it
22:39:40 <copumpkin> BMeph: his
22:39:50 <ray> i've never administrated lunix for more than like 6 people either
22:39:52 <mmorrow> ray: my fav haskell prog of the week http://moonpatio.com/repos/ohhai.hs ;)
22:39:52 <uman> BMeph: what'd you study?
22:39:56 <copumpkin> BMeph: just curious what was wrong, really
22:40:11 <joed> ray: So - you have no clue one way or another?
22:40:14 <mmorrow> ffi++
22:40:19 <mmorrow> @karma ffi
22:40:19 <lambdabot> ffi has a karma of 2
22:40:22 <mmorrow> @karma FFI
22:40:22 <lambdabot> FFI has a karma of 2
22:40:29 <BMeph> copumpkin: Hm. It's woking (AFAICT) for me. What's messing up for you? :)
22:40:30 <ray> mmorrow: haha
22:40:45 <mmorrow> hax!
22:41:10 <uman> ray: which Windows do you use?
22:41:22 <ray> NT
22:41:32 <uman> which one
22:41:36 <ray> i maintain that the only useful distinction is between NT and 9x
22:41:45 <copumpkin> BMeph: damn
22:41:47 <uman> "NT" can mean anything for 3 to 6.1 (aka 7)
22:41:50 <copumpkin> it was broken a minute ago!
22:41:51 <copumpkin> I swear
22:41:52 <copumpkin> :P
22:41:54 <ray> vista
22:42:30 <mmorrow> isn't NT (the bare minimum for) posix?
22:42:46 <joed> Ray, those are all pretty dumb assumptions, you see XP as client and 200x somthing as server and NT on anything you cannoot migrate
22:44:13 <ray> uman: so, are you leading into something? just curiosu
22:44:30 <BMeph> copumpkin: ...but it works for you now? ;p
22:44:47 <copumpkin> yup :P
22:44:50 <ray> like magic
22:44:54 <uman> ray: no, I'm honestly amazed someone could prefer Vista to Linux, but what's great about computers is the choice ;)
22:45:12 <ray> have you used it?
22:45:31 <uman> ray: I use 7 and XP every day
22:45:38 <uman> and I'm on Vista right now
22:45:52 <BMeph> uman: Computer Engineering until 1990, then I changed to Math (CS was still a graduate-only program).
22:45:54 <ray> then i'm honestly amazed you can prefer linux
22:46:03 <ray> i use it for some things, but i keep it one atlantic ocean's length away
22:46:15 <uman> ray: what do you hate so much about LInux?
22:46:34 <erikc> i prefer Windows to Linux for developing games :)
22:46:45 <ray> linux? linux distributions? or uniaxish systems in general?
22:46:48 <SubStack> I hate how easy it is to use and install new software and libraries!
22:47:22 <uman> ray: well I use Debian 5.0.2 with XMonad. Tell me what you would hate about using that system, at any level
22:47:36 <impl> X is a piece of junk.
22:47:42 <ray> X is a piece of junk.
22:47:43 <uman> whether it is Linux-specific, Debian-specific, or Unix
22:47:43 <ray> :)
22:47:48 <SubStack> uman: me too! both of those things
22:47:52 <ray> but everyone knows that
22:47:59 <uman> <3 Xmonad
22:48:09 <uman> SubStack: nice :)
22:48:13 <impl> I would say 80% of my user-land hate for Linux comes from X and things that X does or is related to
22:48:17 <ray> i don't know what debian 5.0.2 is, is it stable or flaky or what
22:48:23 <uman> ray: stable
22:49:04 <inimino> debian with xmonad works well for me :-)
22:49:04 <SubStack> impl: do people still write things for X directly?
22:49:11 <ray> i have that on my vps
22:49:16 <SubStack> thought everyone was using toolkits like gtk and such
22:49:20 <SubStack> or opengl anyways
22:49:25 <SubStack> hopengl if you're extra special
22:49:39 <pikhq> SubStack: Very few people write things for X directly.
22:49:40 <impl> SubStack: Pretty much, but there are still things built directly on top of X that are heavily maintained.
22:49:54 <copumpkin> mmorrow: have you developed that idea of implicit parameters more? I really liked it
22:49:57 <pikhq> Most of those people are maintaining stuff that was written ages ago.
22:50:02 <ray> pretty much i'd only hate it if i had to use it on my actual computer, because x isn't fit for human use
22:50:16 <mmorrow> copumpkin: i haven't coded anything further with it, but it's been on my mind
22:50:17 <impl> pikhq: Someone has to maintain all of the layers that bridge between <your app> and X.
22:50:22 <ray> xmonad helps a bit
22:50:29 <ray> but in the end, it's still x
22:50:45 <ray> i don't have anything like IMEs that can hook into the text entry of everything
22:50:45 <impl> That said
22:50:49 <pikhq> impl: Nuke X. It's the only way. :P
22:50:57 <impl> Xorg has made so much progress since XFree86
22:50:58 <pikhq> ray: Windows has that too.
22:51:07 <copumpkin> mmorrow: I guess it's basically reifying the typeclass' dictionary into a concrete type and then passing that object implicitly
22:51:07 <ray> huh?
22:51:12 <pikhq> Only the hook can hook into everything.
22:51:28 <SubStack> Someone is great. They're always writing the bits that I'd really rather not implement myself.
22:51:29 <ray> i have no idea what you are talking about
22:51:40 <pikhq> (since DLLs have read-write memory shared across all the freaking processes. This is how most Windows viruses work...)
22:51:42 <mmorrow> copumpkin: totally, and you get the typeclass-no-passing-the-dict-around convenience via the implicit param
22:52:11 <ray> but the main problem with debian is the problem with linux distributions: it's a distribution of third party software
22:52:25 <ray> you should format and install freebsd
22:52:35 <uman> ray: what's wrong with that?
22:52:37 <impl> FreeBSD's gone down the shitter since 4.x.
22:52:41 <mmorrow> copumpkin: it's almost too perfect.. :)
22:52:56 <mike-burns> You should ask about the state of Haskell in #haskell-freebsd before you ditch Linux.
22:53:11 <copumpkin> mmorrow: I'm tempted to adapt my algebra classes to use that to distinguish between the two binary operations for rings etc.
22:53:18 * ray points out he uses haskell on windows
22:53:25 <copumpkin> but I think I like it like this
22:53:42 <pikhq> ray: Just look at the Win32 C API.
22:53:45 <mmorrow> copumpkin: i guess though that any optimizations that'd be done for calling a class method where the instance/type is known can't be done (?) in the implicit param case (??)
22:53:46 * copumpkin ponders
22:53:49 * ray looks
22:53:56 <impl> pikhq: There's always .NET if you don't like that.
22:54:00 <pikhq> If you manage to look at it without going temporarily blind, I will be amazed.
22:54:07 <copumpkin> mmorrow: I don't think it does that anyway, unless you say {-# SPECIALIZE ... #-}
22:54:12 <pikhq> impl: It is enlightening as to what is wrong with Windows, though.
22:54:14 <mmorrow> copumpkin: haha, my first thought for this was to use it for monoids..
22:54:22 <mike-burns> Oh did I jump in during an OS war? Nevermind, count me out.
22:54:27 * uman has a copy of the Petzold tome on his bookshelf
22:54:32 <mmorrow> copumpkin: hmm, that makes sense
22:54:40 <impl> pikhq: Well - no more than GCC extensions to POSIX are enlightening as to what is wrong with Linux.
22:54:52 <erikc> mike-burns: wise
22:55:01 <ray> pikhq: please point me directly to something terrifying
22:55:07 <mmorrow> copumpkin: i vaguely remember reading something about how under certain circumstances the dictionaries can be eliminated, but i don't recall exactly
22:55:09 <pikhq> ray: Gimme a bit.
22:55:11 <impl> pikhq: /usr/include/*.h are pretty downright scary.
22:55:13 <Warrigal> > "ã¤"
22:55:15 <lambdabot>   "\12388"
22:55:22 <impl> by 'GCC' I mean 'glibc', sorry
22:55:23 <pikhq> impl: Granted.
22:55:26 <ray> i promise to shriek like a little girl and switch to linux
22:55:53 <ray> i mean, i'll shriek like a little girl and claim to be switching to linux.. i really don't want to any more than you want to switch to windows
22:55:54 <uman> pikhq: he said he only has a user's perspective on Windows, so the state of the APIs is irrelevant
22:55:55 <Warrigal> > "\55296\56320"
22:55:57 <lambdabot>   "\55296\56320"
22:56:06 <kyagrd> > "ì•ˆê¸°ì˜"
22:56:07 <lambdabot>   "\50504\44592\50689"
22:56:23 <Warrigal> \55296 and \56320 aren't Unicode characters, I believe.
22:56:24 <mmorrow> impl: the crucial difference though is that GNUC is a /superset/ of C, whereas windows doesn't provide e.g. a superset of posix
22:56:27 <pikhq> Let's see if I can find something where the multiple calling conventions comes up.
22:56:47 <impl> mmorrow: glibc isn't POSIX-compliant
22:56:52 <ray> apis are relevant, uman
22:56:53 <mmorrow> mmorrow: :p
22:56:58 <mmorrow> impl: :o
22:56:59 <ray> why do you think i only care about pretty abstract haskell?
22:57:00 <mmorrow> i meant
22:57:03 <oklopol> i remember having this same flame war with pikhq a few years ago
22:57:11 <mmorrow> impl: what are the non-compliant things?
22:57:15 <oklopol> surprisingly enough, i'm still using windows, and he's still using linux
22:57:21 <ray> shocking
22:57:28 <ray> i like to have this flame war every now and then
22:57:31 <ray> and by like i mean hate
22:57:33 <mike-burns> I remember having an OS flame war when I was a teen. They haven't changed from the looks of it.
22:57:34 <pikhq> oklopol: My feelings for Windows then were mild distaste compared to now.
22:57:36 <ray> but it probably helps cleanse my system
22:58:10 <impl> mmorrow: I have no idea. I thought Windows had a POSIX layer too.
22:58:11 <oklopol> pikhq: i hate it more too, nowadays. now i hate all oses.
22:58:11 <hzap> which one is more flame-y, an OS flamewar or a programming language flamewar?
22:58:31 <impl> mmorrow: Neither one are certified by IEEE, though, so *shrug*
22:58:31 <oklopol> computers are for abstract programming.
22:58:37 <pikhq> hzap: OS. There are actually good programming languages in use. :P
22:58:39 <ray> haskell machine pls
22:58:43 <kyagrd> > System.IO.UTF8.print "ì•ˆê¸°ì˜"
22:58:44 <lambdabot>   Not in scope: `System.IO.UTF8.print'
22:58:48 <uman> hzap: anyone not using brainfuck is a tool
22:58:49 <kyagrd> grrrr
22:58:51 <Warrigal> > "\65534"
22:58:53 <lambdabot>   "\65534"
22:59:26 <mike-burns> hzap: They're both equally interesting, useful, and reasoned.
22:59:33 <impl> mmorrow: http://en.wikipedia.org/wiki/Interix
22:59:39 <hzap> pikhq: guess that was a fail question being in #haskell - maybe I should say a python vs ruby flamewar instead... :D
22:59:45 <Warrigal> Anyway, it's quite clear that Char doesn't have to represent an actual character, just something in the range of possible characters.
22:59:53 <pikhq> ray: While I'm googling, I'll just mention that there's 3 different boolean types with different semantics.
23:00:12 <SubStack> the IEEE is too busy bullying academics into handing over distribution rights to be too concerned about actual technical anything
23:00:23 <kyagrd> > Codec.Binary.UTF8.String.encode
23:00:24 <lambdabot>   Not in scope: `Codec.Binary.UTF8.String.encode'
23:00:26 <ray> in a python vs ruby flamewar, haskell wins
23:00:34 <Warrigal> > max :: Char
23:00:35 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
23:00:39 <impl> SubStack: no doubt. :)
23:00:41 <Warrigal> > maxBound :: Char
23:00:42 <d4> I have a question the Google searches aren't doing justice to
23:00:43 <lambdabot>   '\1114111'
23:00:45 <mmorrow> impl: :o (i wonder if it has mmap)
23:00:47 <mike-burns> ray: You mean the Haskell programmer shouts the loudest?
23:00:49 <oklopol> python is better because i know it.
23:01:01 <pikhq> ray: http://www.winprog.org/tutorial/simple_window.html Here's a trivial example.
23:01:02 * BMeph doesn't get the point in arguing "Ruby vs. Python"...
23:01:03 <mmorrow> (or pthreads)
23:01:05 <mmorrow> that would rock
23:01:16 <d4> I'd like to know how "ambiguous type variable" messages arise
23:01:20 <impl> mmorrow: it says it does.
23:01:24 <d4> ... what causes them
23:01:50 <d4> unfortunately all I can find are desperate mailing-list posts about specific problems
23:02:08 <d4> rather than systematic explanations
23:02:11 <mmorrow> impl: wow, if so then this should make a ton of progs windows-compat
23:02:25 * SubStack wants to argue javascript versus pascal
23:02:26 <pikhq> Note that the two functions in there have two different calling conventions.
23:02:29 <d4> any pointers?
23:02:55 <impl> d4: 0x00fb329a
23:03:08 <pikhq> d4: 0x00
23:03:10 <impl> mmorrow: Easier said than done.
23:03:28 <mmorrow> "Supports pthreads, shared libraries, DSOs, job control, signals, sockets, shared memory"
23:03:29 <impl> mmorrow: I'm not sure there are any non-trivial C programs that comply completely to POSIX.
23:03:30 <mmorrow> snap
23:03:38 <mmorrow> impl: heh
23:03:51 <kyagrd> > putStrLn "\236\149\136\234\184\176\236\152\129"
23:03:52 <lambdabot>   <IO ()>
23:04:06 <kyagrd> > putStrLn "hello, world"
23:04:08 <lambdabot>   <IO ()>
23:04:10 <inimino>     d4 | any pointers?
23:04:10 <erikc> mmorrow: i havent had a particularly good experience with unix subsystem, it's definitely second class
23:04:11 <inimino>   impl | d4: 0x00fb329a
23:04:19 <Warrigal> > putStrLn
23:04:21 <inimino> whoops
23:04:21 <lambdabot>   Overlapping instances for GHC.Show.Show
23:04:21 <lambdabot>                              (GHC.B...
23:04:28 <kyagrd> > return "ABC"
23:04:29 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
23:04:30 <lambdabot>    arising from a use ...
23:04:39 <kyagrd> > return "ABC" :: IO String
23:04:40 <lambdabot>   <IO [Char]>
23:04:47 <Warrigal> > putStrLn :: String -> IO ()
23:04:49 <lambdabot>   Overlapping instances for GHC.Show.Show
23:04:49 <lambdabot>                              (GHC.B...
23:04:56 <Warrigal> @type putStrLn
23:04:56 <kyagrd> > unsafePerformIO
23:04:58 <lambdabot> String -> IO ()
23:04:58 <lambdabot>   Not in scope: `unsafePerformIO'
23:05:14 <d4> impl, pikhq: I asked for pointers, not addresses
23:05:36 <meder> impl: wtf are you doing here
23:05:47 <impl> oh for fuck's sake
23:05:48 <mike-burns> d4: Unless I'm mistaken, that happens when the type system catches you using the wrong type.
23:05:58 <meder> impl: you're the person i least expected to be in #haskell
23:06:00 <meder> of all #phpeople
23:06:01 <kyagrd> By the way does template haskell extension in GHC still has splices only for expressions?
23:06:10 <d4> mike-burns: wrong type... hmm
23:06:10 <impl> meder: why is that? because I hate PHP with a passion?
23:06:13 <meder> heh
23:06:18 <impl> or because you're a bloody moron?
23:06:20 <meder> no, just.. :p
23:06:24 <kyagrd> By the way does template haskell extension in GHC still has splices only for expressions, and declarations? I mean
23:06:27 <SubStack> pretty sure 1/3 of the people in ##php hate php with a passion
23:06:29 <meder> i didn't think anyone from there liked Haskell
23:06:35 <meder> guess I was wrong
23:06:44 <meder> am I still banned?
23:06:51 <impl> I don't care. I'm not there anymore.
23:06:57 <meder> heh
23:06:57 <hzap> lame question: what does the ## mean?
23:06:59 <impl> SubStack: I'm from EFnet #php, not Freenode.
23:07:03 <SubStack> ah
23:07:12 <d4> mike-burns: doesn't using the wrong type usually result in something like "No instance for" ...
23:07:15 <impl> it's probably 3/4 of people there.
23:07:18 <meder> some channels are not primary channels and have an extra #
23:07:30 <impl> The extra # means the channel is not official.
23:07:34 <meder> yeah.
23:07:35 <impl> i.e., not supported by the project itself
23:07:41 <hzap> oh, thx
23:07:52 <meder> impl: how long you been doing Haskell
23:08:12 <impl> I don't really. I like the occasional math discussion in here.
23:08:27 <uman> impl: try #not-math
23:08:43 <mike-burns> d4: Ah yes, you are correct. I don't remember right now how to get the "ambiguous type variable" error, even though I saw it all day.
23:09:06 <impl> uman: *looks*
23:09:06 <meder> heh
23:09:21 <uman> impl: social chat for regulars in #math
23:09:52 <hzap> ambiguous type var errors can sometimes come up when you use a function polymorphic in its return type
23:10:12 <impl> uman: ah nice. I used to hang out of EFnet #math, but their bot keeps banning me because they have so many spam problems they get a billion false positives.
23:10:19 <impl> s/of/in/
23:10:25 <meder> efnet is bum
23:10:29 <vav> d4: http://learnyouahaskell.com/types-and-typeclasses -- has simple example. It can get a lot more complicated, but that's core of ambiguous type variable.
23:10:29 <impl> Shut up, meder.
23:10:34 <meder> impl: you're not an op around here are you
23:10:37 <impl> No.
23:10:41 <meder> or an ircop
23:10:47 <impl> Nope.
23:10:52 <sjanssen> impl, meder: is there going to be some sort of problem here?
23:10:56 <meder> ah, good. i don't have to hold back :)
23:10:58 <meder> j/k :p
23:11:12 * impl sighs
23:11:13 <meder> no, just haven't talked to an old friend in awhile
23:11:19 <ray> pikhq: i screamed like a little girl, but that was because i got caught on the small end of a netsplit :)
23:11:21 <sjanssen> oh, okay :)
23:11:59 <d4> vav: thanks! I'll take a look
23:12:00 <ray> it'll take more than nonstandardized calling conventions to scare me
23:12:17 <uman> I don't know how IRC works, but the fact that there are regular netsplits seems to be a pretty deep flaw
23:12:53 <d4> meanwhile here's the bit that's bothering me:
23:12:54 <d4> contains :: (Eq t) => [t] -> [t] -> Bool; contains = undefined; offendingExpression = [] `contains` []
23:13:01 <ray> the fact that it hasn't been reconnected yet is what worries me
23:13:12 <ray> well, i guess all the operators are asleep
23:13:43 <ray> uman: think of a graph of servers
23:13:57 <hzap> d4: it doesn't know which (Eq t) instance to use for the offendingExpression
23:14:09 <ray> an undirected acyclic graph
23:14:17 <d4> hzap: it has to know which instance? :P
23:14:26 <sjanssen> d4: the problem is that [] has type "forall a. a", you're not instantiating a so the compiler can't choose an instance
23:14:28 <uman> ray: yep, sounds flawed
23:14:41 <hzap> d4: each instance has different behaviour, so of course it needs to know
23:14:52 <d4> hmm
23:15:19 <d4> it seems like it just needs to know (Eq t) in order to determine the whole expression has type Bool
23:16:25 <sjanssen> d4: yes, it needs to know that the type is in Eq -- there is no instance for Eq that applies to every type
23:16:50 <d4> hzap, sjanssen: so that's why restricting it to (Num t) works
23:16:57 <d4> although that bugs the hell out of me
23:17:14 <sjanssen> d4: Num works because Haskell has a special case called "numeric defaulting"
23:17:40 <d4> ah, right
23:17:48 <d4> so it picks an instance of the Num class
23:17:59 <d4> which is automatically an instance of Eq
23:18:05 <hzap> d4: say you simply implement 'contains' as (==), and then write a silly Eq instance for some type that always returns False, and another one for another type that always returns True
23:18:54 <d4> hzap: ... is this a thought experiment, or a suggestion? ;)
23:18:59 <hzap> d4: then the value of offendingExpression obviously depends on the actual type of []
23:19:12 <d4> ah, the former
23:19:19 <hzap> d4: hypothetical silly scenario
23:19:31 <d4> OK, but in any case it's boolean
23:19:42 <d4> so the type checking shouldn't fail
23:19:59 <hzap> d4: if it typechecked, what should the value be?
23:20:26 <d4> hmm
23:22:06 <d4> hzap: suppose I implement contains like this
23:22:23 <d4> a `contains` b = all (`elem` a) $ nub b
23:22:51 <d4> now, a::[t] and b::[t]
23:23:04 <d4> clearly (Eq t) because of elem
23:23:39 <d4> but in the case of an empty list, clearly the value is True because of all
23:24:06 <copumpkin> multiparameter typeclasses are hard to work with
23:24:07 <d4> that is, when b==[]
23:24:08 <copumpkin> yet so tempting...
23:24:13 * ray drools
23:24:34 <sjanssen> d4: the compiler doesn't look that deeply into the code when type checking
23:24:40 <ray> mmmmm, multiparameter typeclassessssss
23:24:47 <copumpkin> yup
23:24:48 <uman> I want to fork learnyouahaskell.com
23:24:54 <hzap> d4: that happens to be true, but in general the compiler doesn't know that 'all' returns True on an empty list regardless of the predicate
23:24:56 <uman> and have all the same content, but without the humor
23:25:00 <ray> forget you a haskell for great evil!
23:25:00 <Cale> uman: fork it?
23:25:04 <Axman6> d4: (not . null) b && all (`elem` a) b?
23:25:12 <copumpkin> uman: humor?
23:25:18 <copumpkin> uman: it's cutesy
23:25:22 <Cale> oh
23:25:43 <ray> it's not why's guide
23:25:46 <d4> Axman6: oh, no, I want every list to contain the empty list ;)
23:25:47 <Cale> I didn't think it made that many jokes
23:25:51 <ray> where there's more cartoons than ruby
23:25:53 <uman> example programs that call you an emo if your BMI is less than 18.5, and such
23:26:05 <copumpkin> heh
23:26:20 <uman>    1. bmiTell :: (RealFloat a) => a -> String
23:26:20 <uman>    2. bmiTell bmi
23:26:20 <uman>    3.     | bmi <= 18.5 = "You're underweight, you emo, you!"
23:26:20 <uman>    4.     | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
23:26:23 <uman>    5.     | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"
23:26:25 <uman>    6.     | otherwise   = "You're a whale, congratulations!"
23:26:40 <d4> sjanssen: I think I know what you mean---type checking /= evaluating
23:27:12 <d4> sjanssen: maybe this is the kind of thing where I'd have to see the implementation to understand
23:27:23 <sjanssen> d4: yes, exactly.  You've got to draw a line somewhere, otherwise typechecking becomes unsolvable
23:27:41 <d4> sjanssen: speaking of unsolvable typechecking
23:27:49 <d4> I like this quotation
23:27:51 <d4> ...
23:27:56 <sjanssen> (unsolvable in the reduces-to-the-halting-problem sense)
23:28:24 <d4> "A type is any property of a program that we can establish without executing the program."
23:28:30 <sjanssen> d4: undefined = undefined -- is one valid definition
23:28:32 <d4> -- Shriram Krishnamurthi
23:28:42 * copumpkin is tempted to go even further from practicality with his algebra module
23:28:49 <ray> yes!
23:28:53 <ray> down with practicality
23:28:55 <d4> sjanssen: So I guess whether the program will halt or not is not a type? ;D
23:28:56 <copumpkin> :P
23:28:57 <sjanssen> undefined | False = undefined -- this was in a version of the Haskell report
23:29:03 <ray> practicality?
23:29:10 <ray> this. is. HAS KELL
23:29:50 <copumpkin> ray: well so far I've been using MPTC to "index" algebraic structures by the "set" (type) they operate on and the two operations (represented as types)
23:30:06 <copumpkin> but the one-operation structures are only "indexed" by the set
23:30:20 <sjanssen> d4: basically you can get into things like if program halts then well typed expression else not well typed
23:30:55 <hzap> d4: as far as the type checker is concerned, it doesn't really distinguish [] from [blah, blah, blah] - they're all lists (except that [] doesn't contain any information about its elemnt type)
23:31:43 --- mode: irc.freenode.net set +o ChanServ
23:32:32 --- mode: irc.freenode.net set +o ChanServ
23:32:32 <ray> learn you a category-extras for great zygohistomorphic prepromorphism
23:32:36 <d4> hzap: yes
23:32:42 <copumpkin> lol
23:33:20 * copumpkin tries to rethink what it would take to make this "rigorous" without making it unusable
23:33:39 <ray> formally prove its usability
23:33:46 <copumpkin> har har :P
23:33:50 <d4> hzap, sjanssen: under what conditions does the type checker need to determine an instance for a type variable?
23:34:06 <d4> sometimes it leaves type variables in the signature
23:35:45 <hzap> d4: having type variables is fine; the problem with that expression is that its type is 'Bool', which doesn't actually have any type variables in it that relates to the Eq instance it should use
23:36:13 <hzap> (well, what you think its type is)
23:36:54 <d4> but why does it need to pick an instance?
23:36:55 <abbe> hi everyone, i'm trying to compile ghc 6.10.4 using ghc 6.8.3 as bootstrap GHC. I'm getting following error, even after installing haskeline:
23:37:02 <abbe> cabal-bin: At least the following dependencies are missing:
23:37:03 <abbe> haskeline -any
23:37:05 <d4> the type of the expression is Bool, clearly. job done
23:37:07 <Cale> d4: Very roughly, it goes about generating equations saying which type variables are equal to which other type variables and fixed types, and then it tries to solve those equations. Things which are bound by let, where or are defined at the top level then have their type signatures generalised
23:37:17 <abbe> ^^ what is the purposse of -any ?
23:37:31 <uman> > 2 / 2 ^ 2
23:37:32 <lambdabot>   0.5
23:37:36 <edwardk> ray: =P
23:37:52 <hzap> d4: it needs to apply the 'contains' function, which requires picking an instance
23:38:01 <Cale> abbe: that's the version it will accept
23:38:17 <d4> Cale: I know a little about how type inference works... unification...
23:38:54 <d4> but I'm not clear why it needs an instance of Eq here
23:39:03 <Cale> d4: In which case exactly?
23:39:21 <d4> contains :: (Eq t) => [t] -> [t] -> Bool; contains = undefined; offendingExpression = [] `contains` []
23:39:45 <Cale> Oh, monomorphism restriction, blah.
23:39:51 <d4> really?
23:40:02 <sjanssen> Cale: no, that isn't the monomorphism restriction
23:40:04 <d4> usually the message will mention the monomorphism restriction
23:40:04 <hzap> Cale: it's not MR
23:40:14 <Cale> isn't it?
23:40:21 <d4> compile it
23:40:32 <abbe> Cale, you mean 'any' version will do ?
23:40:37 <Cale> abbe: yeah
23:40:41 <sjanssen> d4: first thing, once the compiler has determined the type for contains, it is opaque to the typechecker
23:40:46 <hzap> Cale: no, the would-be type of offendingExpr is 'Bool', not a polymorphic type
23:40:57 <abbe> okay, i've installed haskeline using 'runghc Setup.hs install' but it is not working
23:40:59 <Cale> contains.hs:1:86:
23:40:59 <Cale>     Ambiguous type variable `t' in the constraint:
23:40:59 <Cale>       `Eq t' arising from a use of `contains' at contains.hs:1:86-101
23:40:59 <Cale>     Probable fix: add a type signature that fixes these type variable(s)
23:41:15 <d4> Cale: yes
23:41:25 <sjanssen> d4: it doesn't know that it never actually uses the Eq instance, or what its behavior is on []
23:41:51 <Cale> oh, right, it's genuinely ambiguous
23:42:07 <Cale> There's no way that the type variable can be later resolved
23:43:35 <copumpkin> if you have two binary operations f and g and f distributes over g for a particular set a, does a choice of f imply g and vice versa?
23:43:36 <Cale> d4: It's because  offendingExpression, if it typechecked, would have the type Bool
23:43:37 <d4> Cale: why would the type variable need to be further resolved?
23:43:48 <Cale> d4: and Bool doesn't mention the t from the use of contains
23:44:04 <Cale> d4: and so there's no place to put the typeclass constraint
23:45:08 <Cale> That is, there's no way to treat the result of contains as polymorphic and defer the resolution of what type you're applying it at, and which typeclass dictionary it needs to be passed
23:46:20 <Cale> Does that make sense?
23:47:31 <d4> Cale: I'm still mulling it over. I don't know about typeclass dictionaries.
23:47:45 <Cale> d4: Well, they're kind of an implementation detail
23:47:59 <d4> I figured it would come down to implementation details.
23:48:00 <Cale> but whenever you see a type like  (FooClass a) => ... a ...
23:48:28 <Cale> Well, I'm explaining the reason that the type needs to be resolved there in terms of the implementation detail
23:49:05 <d4> Cale: I appreciate it and am doing my best to follow! ;D
23:49:07 <Cale> When you see a type like that, it's translated into a function type: FooClass a -> ... a ...  where FooClass a is some record of methods for the typeclass Foo
23:49:13 <Cale> FooClass*
23:49:42 <Gracenotes> this model makes multiparameter typeclasses not-so-difficult..
23:50:23 <Cale> d4: That is, typeclass polymorphic values are really functions of a dictionary of the implementations of each of the typeclass methods (it's just one extra pointer parameter really)
23:51:44 <d4> OK, so there's more than one typeclass dictionary for Eq?
23:51:52 <Cale> d4: One for each instance of Eq
23:52:19 <Cale> and some of them are functions, like the instance Eq a => Eq [a]
23:52:54 <Cale> Is implemented as a function from Eq dictionaries for some type a, to Eq dictionaries for [a]
23:54:59 <d4> alright
23:55:59 <Cale> d4: When typeclassed type variables are unified with monomorphic types, it has to supply an appropriate dictionary there
23:56:47 <d4> just in case, since it might be needed
23:57:21 <d4> the irony here is that the precise reason it can't determine the typeclass dictionary is because it won't be needed
23:57:32 <Cale> Well, because that thing is really a function, and won't have any value at all until a parameter of the right type is supplies
23:57:35 <Cale> supplied*
23:58:08 <d4> the whole offendingExpression is really a function?
23:58:08 <Gracenotes> hm... you could probably eliminate typeclasses with whole-program compilation
23:58:36 <d4> Gracenotes: was that to me?
23:58:46 <dolio> Not always.
23:58:49 <Gracenotes> er no, random comment.
23:58:52 <Cale> d4: It might have been, but there's no type variable to stick that class constraint on
23:59:08 <Cale> d4: try changing the type of contains to (Eq t) => [t] -> [t] -> t, say
23:59:20 <d4> hmm
23:59:25 <Cale> and you'll see that offendingExpression gets the type (Eq t) => t
23:59:46 <d4> eh
23:59:55 <d4> I get a somewhat different compile error
