00:00:31 <mmorrow> oh hai
00:00:46 * mmorrow passes out
00:00:53 <kayess> shachaf: You mean this S and K? http://en.wikipedia.org/wiki/SKI_combinator_calculus
00:00:59 <shachaf> Yep.
00:01:25 <soupdragon> I like the various X combinators
00:01:45 <mmorrow> , [$ski|SKI|]
00:01:47 <lunabot>  (S :$ K) :$ I
00:01:54 <kayess> I and K look simple enough. S will take a bit of time to get my head around :)
00:02:03 <mmorrow> , [$ski|S[(,)][Just][20000000000]|]
00:02:05 <lunabot>  (20000000000,Just 20000000000)
00:02:09 <soupdragon> we have  lambda calculus = span {S,K,I} = span {S,K} = span {X}
00:02:35 <shachaf> kayess: S is pretty simple.
00:02:42 <shachaf> @let s x y z = (x z) (y z)
00:02:43 <lambdabot>  Defined.
00:02:45 <shachaf> @let k x y = x
00:02:47 <lambdabot>  Defined.
00:03:01 <mmorrow> , [$ski|S[f::Expr->Expr->Expr][g::Expr->Expr][x::Expr]|]
00:03:03 <lunabot>  f x (g x)
00:03:07 <kayess> It certainly looks simpler in Haskell
00:03:36 <soupdragon> x z (y z) -- easier to read imo ... harder to remeber though
00:03:38 <mmorrow> @let s' f g x = f x (g x) -- :)
00:03:39 <lambdabot>  Defined.
00:03:57 <shachaf> mmorrow: Er... OK...
00:03:57 <mmorrow> n/m that's the same thing..
00:04:01 <mmorrow> :)
00:04:05 <soupdragon> @src (>>=) (->)
00:04:06 <lambdabot> Source not found. I feel much better now.
00:04:11 <soupdragon> @src (->) (>>=)
00:04:12 * mmorrow is not of clear mind atm
00:04:12 <lambdabot> f >>= k = \ r -> k (f r) r
00:04:21 <copumpkin> :o
00:04:22 <soupdragon> @src (->) (=<<)
00:04:22 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:04:34 <shachaf> K is also called const/return, and S is called ap.
00:04:36 <copumpkin> =<< isn't a method is it?
00:04:43 <mmorrow> @pl flip ( \ r -> k (f r) r)
00:04:44 <lambdabot> flip (k =<< f)
00:04:59 <mmorrow> um
00:05:04 <mmorrow> ah
00:05:12 <mmorrow> @pl flip ( \f k r -> k (f r) r)
00:05:13 <lambdabot> flip (flip flip id . (ap .) . flip (.))
00:05:17 <mmorrow> :o
00:05:21 * mmorrow quits
00:05:25 <copumpkin> lol
00:05:56 <kayess> I think I might be there then. Just got to work out how to express this lot
00:14:48 <mmorrow> y in haskell is just
00:15:25 <mmorrow> y f = let z x = f (unsafeCoerce x x); {-# NOINLINE z #-} in z z
00:15:30 <mmorrow> :)
00:15:33 <shachaf> Ew.
00:15:36 <shachaf> Does that work?
00:15:40 <mmorrow> very much so
00:15:51 <mmorrow> and it even has the more general (than fix) type
00:15:54 <mmorrow> (a -> b) -> b
00:16:08 <shachaf> Hmm.
00:16:23 <shachaf> @index unsafeCoerce
00:16:24 <lambdabot> bzzt
00:16:27 <mmorrow> (the compile code is much less efficient than fix though (as ghc produces it)
00:16:44 <mmorrow> Unsafe.Coerce
00:16:53 <mmorrow> (w/out the NOINLINE the simplifier loops)
00:17:27 <zong_sharo> (after reading some tf papers) theoretycally, type families and functional dependencies are equivalent in expressiveness. but does multiparapeter type classes without fd has some usefull applications which cannot be expressed in tf?
00:18:30 <shachaf> mmorrow: That y doesn't work right.
00:18:33 <shachaf> y (:[])
00:18:44 <shachaf> [()]
00:18:45 <Grey_Fox> does anyone know Hlist?
00:18:52 <mmorrow> , fix (:[])
00:18:53 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = [a]
00:19:19 <mmorrow> shachaf: that's the type defaulting to ()
00:19:27 <mmorrow> (on account of the unsafeCoerce)
00:19:36 <shachaf> Ah.
00:19:55 <mmorrow> if you give it the typesig you intend, it'd work (although i'm not sure the type sig you intend here is legal in haskell ..)
00:20:06 * shachaf wants to be able to "join (:[])".
00:20:12 <shachaf> Indeed, it wouldn't be.
00:20:58 <shachaf> Grey_Fox: Surely some people in here; you'll probably have more luck if you ask a question about it. :-)
00:21:22 <mmorrow> shachaf: with a newtype or two you should be able to express that though (although it may be noisy)
00:21:30 <Grey_Fox> just trying to understand the paper
00:21:44 <JN_> when I read the discourse in this room, I have no clue what people are talking about
00:21:52 <soupdragon> lol
00:22:09 <dobblego> is (.) . (.) in the standard library?
00:22:10 * shachaf wants a non-noisy "join (:[])".
00:22:13 <shachaf> Is that too much to ask?
00:22:21 <shachaf> dobblego: I don't think so.
00:22:23 <copumpkin> shachaf: me too! :P
00:22:34 <copumpkin> wasn't I just talking about that with you? or am I confused
00:22:38 <copumpkin> or was it not you
00:22:43 <mmorrow> , levels (fix (\x -> Node () [x,x]))
00:22:44 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
00:22:50 <mmorrow> , fmap length $ levels (fix (\x -> Node () [x,x]))
00:22:53 <lunabot>  luna: out of memory (requested 1048576 bytes)
00:22:56 <NoobFukaire> haha, dobblego, good one
00:22:59 <mmorrow> , fmap length . take 10 $ levels (fix (\x -> Node () [x,x]))
00:23:00 <lunabot>  [1,2,4,8,16,32,64,128,256,512]
00:23:12 <shachaf> NoobFukaire: ?
00:23:29 <copumpkin> dobblego: I don't believe so
00:23:37 --- mode: ChanServ set +o dobblego
00:23:41 --- mode: dobblego set +b *!n=tmccrary@*.col.wideopenwest.com
00:23:41 --- kick: NoobFukaire was kicked by dobblego (dobblego)
00:23:44 <copumpkin> lol
00:23:45 --- mode: dobblego set -o dobblego
00:23:56 <mmorrow> heh
00:24:02 <shachaf> dobblego: http://www.haskell.org/haskellwiki/Pointfree calls it "dot".
00:24:03 <dobblego> my stalker, sorry about that
00:24:13 <copumpkin> ooh, a stalker
00:24:15 <dobblego> shachaf, thanks
00:25:29 <shachaf> See? I want to be able to "join (.) (.)".
00:25:46 <Grey_Fox> does anyone know where the talk is for these slides? http://homepages.cwi.nl/~ralf/HList/slides.pdf
00:26:12 <copumpkin> oh I was talking about it with soupdragon
00:26:16 <shachaf> Grey_Fox: "the talk"?
00:28:12 * shachaf seems to remember that the paper made more sense than the slides in this case.
00:28:29 <shachaf> Though at any rate I did not investigate it completely.
00:28:38 <Grey_Fox> I figured there was some kind of lecture to accompany the slides
00:29:23 <shachaf> Nothing that I am aware of.
00:29:57 <Grey_Fox> ok
00:39:56 <portnov> @hoogle String -> [Word8]
00:39:57 <lambdabot> Prelude fail :: Monad m => String -> m a
00:39:57 <lambdabot> Control.Monad fail :: Monad m => String -> m a
00:39:57 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
00:54:10 <lpsmith> doesn't ghc have a command line option so that it will allow every function to be accessed from ghci,  whether exported or not?
00:54:31 <lpsmith> I seem to remember that, but I'm having trouble finding it in the flag reference
00:54:42 <dobblego> ooh that would be handy
00:56:26 <lpsmith> indeed
00:59:15 <Cale> lpsmith: That is the normal behaviour, isn't it?
00:59:42 <Cale> lpsmith: Or you mean with compiled modules?
01:00:00 <Cale> lpsmith: I suppose one thing you could do is comment out the module declaration (or just the export list)
01:01:26 <lpsmith> I mean compiled modules
01:01:39 <lpsmith> and yes,  commenting out the compiled module is what I did
01:47:12 <ivanm> mmorrow: ping!
01:48:44 <taruti> Is it possible to quasiquote declarations?
01:55:54 <ivanm> malcolmw_: you around?
01:58:14 <malcolmw_> ivanm: here
01:58:27 <ivanm> did lambdabot pass on my messages?
01:59:13 <malcolmw_> apparently not
01:59:20 <ivanm> heh
02:00:02 <ivanm> OK, in Data.Parse, what is the last parameter in parseInt (and the params for ParseDec, parseOct and parseHex) for?  They don't seem to be used... :s
02:02:01 <malcolmw_> the last param is the starting seed number
02:02:29 <ivanm> malcolmw_: I'm looking through the definition again, and it doesn't seem to be used at all...
02:02:59 <ivanm> nope, it isn't: I replaced the var name in the function definition with a _, and it didn't make a difference
02:03:16 <ivanm> (well, I also changed "go n" to "go ()" for parsing purposes)
02:03:25 <malcolmw_> e.g. if you parse a digit before realising that you need to continue to get a whole integer, there is no need to put the digit back into the stream before calling parseDec.  Just give the converted digit as a parameter.
02:03:59 <malcolmw_> parseInt .... n = go n  -- it is used right here
02:04:14 <ivanm> malcolmw_: but in the definition of go, it's called "acc", and acc isn't used
02:04:33 <malcolmw_> oh!
02:04:39 <malcolmw_> you are right!
02:04:39 <ivanm> exactly!
02:05:10 <ivanm> malcolmw_: also, the only time 0 isn't used as the last parameter is in parseLitChar
02:05:23 <malcolmw_> in that case, I suppose it must be a left-over from some previous version of the code
02:05:34 <ivanm> heh
02:05:52 <ivanm> I'm guessing you used to use it as the base case for the fold, before you switched to foldl1
02:06:24 <malcolmw_> ah, so now you are telling that the param _should_ be used, because otherwise there is a bug in parseLitChar
02:06:56 <ivanm> well, I'm not sure if it should be used or not
02:07:06 <ivanm> hence why I brought it to your attention ;-)
02:07:23 <malcolmw_> yes, well there is definitely something wrong, one way or the other
02:07:28 <ivanm> escape d | isDigit d = fmap chr $  parseDec (digitToInt d)
02:07:41 <ivanm> not sure what it's doing there
02:15:00 <malcolmw_> ivanm: looking back at the darcs history, the extra parameter to parseInt has never been used ever.
02:15:17 <ivanm> lol
02:15:30 <ivanm> malcolmw_: so it's a pre-release historical artifact?
02:15:51 <malcolmw_> perhaps only when I was writing the code, but before checking it in for the first time
02:16:21 <malcolmw_> but there is definitely a bug then in parseLitChar, which I shall fix now
02:22:58 <Cale> http://www.calculatedriskblog.com/2009/07/wells-fargo-sues-wells-fargo-wells.html -- ahaha
02:24:32 <ivanm> Cale: yeah, I saw that
02:24:39 <soupdragon> lol
02:25:32 <idnar> Cale: hahahaha
02:25:39 <malcolmw_> ivanm: bugfix patch pushed - I removed the excess unused argument, and fixed parseLitChar
02:25:52 <idnar> Cale: that just made my day :P
02:25:57 <dilinger> that would be funnier if i wasn't a US taxpayer :(
02:26:32 <ivanm> malcolmw_: you going to bother making a new release for this?
02:27:07 <malcolmw_> ivanm: would a new release be helpful?
02:27:25 <ivanm> malcolmw_: not really for me ;-)
02:27:45 <ivanm> just checking if I should be ready to make a new ebuild for gentoo ;-)
02:27:55 <Peaker> @type join (.) (.)
02:27:56 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
02:27:57 <lambdabot>     Probable cause: `join' is applied to too many arguments
02:27:57 <lambdabot>     In the expression: join (.) (.)
02:27:59 <Peaker> @type join (.)
02:28:01 <lambdabot> forall b. (b -> b) -> b -> b
02:28:03 <malcolmw_> ivanm: OK, I'll wait until some more bugfixes come in then
02:28:39 <ivanm> malcolmw_: also, do you use foldl in parseInt rather than foldl' to make it haskell98 compatible?
02:30:09 <malcolmw_> ivanm: I believe I just worked through the implementations of Read in the H98 Prelude and Numeric libraries, converting them as minimally as possible, so no rationale except "that is what H'98 did"
02:30:29 <ivanm> *nod*
02:30:37 <Peaker> dobblego: (.) . (.) shouldn't get its own function, did you read about conal's SEC's?
02:30:51 <dibblego> Peaker, no I didn't
02:30:56 <Peaker> @where SEC
02:30:57 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
02:31:16 <Peaker> dibblego: this explains how to use (.) . (.) and other combinators in a readable way
02:31:24 <dibblego> Peaker, thanks
02:32:12 <ivanm> malcolmw_: also, should parseFloat also work for floating-point numbers represented as integers?
02:32:18 <ivanm> e.g. 2 :: Double
02:32:20 <Peaker> I think every Haskell tutorial should point out some of conal's posts, including this one :)
02:34:22 <ivanm> Peaker: even really simple basic overview tutorials?
02:34:33 <ivanm> as in "this is known as a _list_" style ones?
02:34:36 <malcolmw_> ivanm: hmm, no I don't think so.
02:34:57 <ivanm> well, it doesn't ;-)
02:35:08 <malcolmw_> ivanm: do you think it should?
02:35:09 <ivanm> > read "2" :: Double
02:35:10 <lambdabot>   2.0
02:35:24 <malcolmw_> ah
02:35:26 <ivanm> malcolmw_: if you want it to match the behaviour or read, then probably yes it should
02:35:33 <Peaker> ivanm: eventually.. the SEC post doesn't take too much deep knowledge to understand, I think
02:35:57 <malcolmw_> OK, will do.
02:36:46 <ivanm> malcolmw_: might be as easy as having the Double/Float instance for Parse be "parseSigned (oneOf [parseDec, parseFloat])"
02:40:38 <malcolmw_> ivanm: no, it is even easier - parseFloat explicitly checks whether the fractional part is empty, in order to reject the parse if there is no exponent
02:40:46 <malcolmw_> ivanm: I'll just remove the check
02:41:04 --- mode: ChanServ set +o dobblego
02:41:07 <ivanm> *nod*
02:41:09 --- mode: ChanServ set +o dibblego
02:41:11 --- mode: dibblego set -b *!n=tmccrary@*.col.wideopenwest.com
02:41:16 --- mode: dibblego set -o dobblego
02:41:18 --- mode: dibblego set -o dibblego
02:45:05 <hackagebot> uniqueid 0.1.1 - Splittable Unique Identifier Supply (SebastianFischer)
02:46:18 <ivanm> ahhhh, a deprecation release
02:47:52 <ivanm> malcolmw_: so which check is removed? the `adjustErrBad` bit in frac <- ( ... ) ?
02:51:58 <malcolmw_> ivanm: if null frac then exponent else exponent `onFail` return 0  --becomes--> exponent `onFail` return 0
02:54:55 <ivanm> thanks malcolmw_
02:55:28 <malcolmw_> ivanm: it has been pushed to the repo
03:13:50 <RayNbow> @seen FunctorSalad_
03:13:51 <lambdabot> I saw FunctorSalad_ leaving #haskell-in-depth, #haskell-blah and #haskell 3h 37m 36s ago, and .
03:15:41 <Raevel> ,and . ? :-)
03:15:42 <lunabot>  luna: parse error on input `?'
03:16:54 <RayNbow> preflex: seen FunctorSalad_
03:16:54 <preflex>  FunctorSalad_ was last seen on #haskell 6 hours, 37 minutes and 5 seconds ago, saying: base change ftw
03:22:11 <maartenm> does anyone know an irc channel where Bach is discussed?
03:22:20 <maartenm> as in, J.S.Bach the composer
03:22:51 <pozic> #deadpeople?
03:22:53 <ivanm> #classics ?
03:23:00 <ivanm> *shrug*
03:24:28 <maartenm> well, maybe not on freenode
03:24:41 <maartenm> I wonder if there's a server wher epeople discuss classical music..
03:25:20 <ivanm> @go bach irc
03:25:21 <lambdabot> No Result Found.
03:25:21 <ivanm> ;-)
03:25:23 <joga> maybe some piano playing related channel...
03:25:47 <joga> #music ? ;)
03:26:09 <maartenm> yeah I did my homework
03:26:13 <maartenm> couldn't find anything
03:26:32 <joga> maybe you can start the channel yourself then
03:26:42 <maartenm> I have neither the time nor motivation to do that
03:27:56 * araujo would likely join such a channel if it existed one .... :)
03:28:15 * ivanm most likely wouldn't :p
03:28:31 <araujo> one more reason for me to join
03:28:33 <araujo> :D
03:28:41 <ivanm> @slap araujo
03:28:41 * lambdabot throws some pointy lambdas at araujo
03:28:44 <araujo> haha
03:29:04 <joga> maartenm, you don't need time, just /join #jsbach
03:29:10 <maartenm> heh
03:29:13 <joga> then idle until people come
03:29:15 <joga> ;)
03:29:18 <maartenm> ok, maybe this will be the start of something
03:29:40 <maartenm> my irc commands are rusty...
03:30:30 <kfish> fuguebot makes fugues
03:31:22 <maartenm> kfish: don't bring any ideas into my head
03:31:36 <ivanm> kfish: good ones?
03:31:40 <maartenm> *imagines a fugue generator using haskore.. not too difficult..
03:31:47 <maartenm> * could be done in a day or two..
03:32:04 <ivanm> maartenm: are you meaning to do "/me ..." ?
03:32:25 <maartenm> err, yeah
03:32:29 <maartenm> how do I make myself op again?
03:32:35 <maartenm> it's been 8 years or so since I frequented irc
03:32:52 <pozic> @google become op irc
03:32:55 <lambdabot> http://docs.dal.net/docs/operinfo.html
03:32:56 <lambdabot> Title: IRC Operators
03:33:26 <maartenm> yeah, on jsbach I mean.. it seems like freenode doesn't allow that?
03:34:17 <joga> maartenm: if you're the only one on the channel, you should be an op
03:34:30 <maartenm> it -o's me
03:34:32 <maartenm> ah, whatever
03:34:41 <joga> oh, have you registered to freenode?
03:34:41 <Cale> maartenm: It's registered by another user
03:34:48 <maartenm> Cale: ah, ok
03:35:02 <Cale> specifically, eisenach, Last used  : May 28 18:23:14 2008 (1 year, 6 weeks, 3 days, 16:11:05 ago)
03:35:22 <Cale> You should be able to ask a freenode operator to give you the channel if you want it.
03:35:25 <maartenm> @seen eisenach
03:35:26 <lambdabot> I haven't seen eisenach.
03:35:35 <ivanm> maartenm: that's only on channels lambdabot is on
03:35:39 <ivanm> do /whois eisenach
03:35:50 <ivanm> if that returns nothing, /whowas _
03:36:17 <maartenm> he never existed
03:36:28 <ivanm> means he hasn't been on in ages probably
03:37:44 <maartenm> how do you grep for channels again?
03:38:15 <Cale> maartenm: Depends on your client
03:38:39 <maartenm> I know /list but it doesn't accept wildcards
03:38:47 <maartenm> ah, ok.. will be my webchat client then
03:38:51 <maartenm> can't use irssi at work
03:52:00 <stepnem> maartenm: /msg alis help
03:52:02 <stepnem> doesn't depend on your client
04:13:43 <ivanm> are constructors allowed to contain digits?
04:14:01 <Saizan> yes
04:14:35 <ivanm> good-o
04:15:35 * osfameron is mostly hating computers
04:15:54 <LeoD> aw
04:17:14 <ivanm> osfameron: how come?
04:17:31 <osfameron> horrible unsanitary things :-)
04:17:54 <iago> haskell-src-exts recognizes source comments?
04:18:32 <iago> I'm seeing at Syntax module but I don't found nothing that suggest that, I only see support for pragmas
04:24:34 <ivanm> iago: IIRC, HSX strips out comments
04:24:40 <ivanm> but it's on the TODO list
04:25:05 <ivanm> it does, however, recognise {-# ... #-} definitional ones for pragmas, etc. (at least for extension definitions) though
04:25:47 <iago> is it in the TODO list of the current GSoC project?
04:26:00 <iago> I have to take a look
04:27:54 <ivanm> iago: no, I don't believe it's part of the GSoc
04:27:56 <ivanm> *GSoC
04:28:02 <ivanm> but he wants to do it in the future
04:28:40 <iago> :/
04:29:09 <jpcooper> what's the common way of sequencing something in the State monad over input and associating a result with each input?
04:29:43 <iago> well, or they do it soon or it's a good time to collaborate
04:29:57 <jpcooper> at the moment I've thought of using mapM over an infinite list of input, but how will I associate the input with the output?
04:30:58 <Saizan> mapM on an infinite list doesn't necessarily work out
04:31:25 <jpcooper> Saizan, what would you suggest?
04:31:57 <Saizan> jpcooper: what's your use-case, at an higher level?
04:32:36 <jpcooper> I've got a controller which takes input and returns output in the state monad
04:32:49 <jpcooper> and I've got a constant stream of input
04:32:59 <jpcooper> I want to return the output as a result for each datum of input
04:34:12 <Saizan> the input comes from IO?
04:34:16 <jpcooper> yes
04:34:43 <jpcooper> I thought of using MVars and passing those along with the input, but surely there's a more functional way?
04:34:48 <Saizan> i'd go for StateT s IO, probably
04:35:12 <jpcooper> well I kind of lied. I've got something like StateT A B Output
04:37:04 <Saizan> well, my general idea is that together with the result you'll return a continuation that accepts the rest of the input
04:37:21 <Saizan> but it also depends on the overall architecture of your program
04:37:43 <Saizan> threads and Control.Concurrent.Chan might be appropriate
04:37:54 <Saizan> , too
04:37:55 <lunabot>  luna: Not in scope: `too'
04:38:06 <jpcooper> I was thinking of Chan and getChanContents before
04:38:42 <jpcooper> what I really want is an easy way to sequence the state over the input and have it return output for every piece of input
04:39:11 <Saizan> what do you do with the output?
04:39:28 <jpcooper> return it to the person who gave the input
04:39:34 <jpcooper> ultimately I output it in CGI
04:40:45 <Saizan> then the simplest way is to probably put IO or the CGI monad at the bottom of your stack and just output it directly in the function you pass to mapM
04:41:00 <Saizan> though, doesn't CGI gives you a request at a time?
04:44:22 <jpcooper> oh I hadn't thought of putting CGI at the bottom
04:45:03 <jpcooper> Saizan, I was thinking of handling requests one at a time with fastcgi
04:47:52 <Saizan> jpcooper: are you using the fastcgi package?
04:48:01 <jpcooper> yes, I hope to be
04:48:10 <jpcooper> I was trying to come up with a design before I did anything
04:48:31 <desp> @djinn Monad m => (a -> m (b, b)) -> (b -> c) -> m (c, c)
04:48:31 <lambdabot> Error: Class not found: Monad
04:49:49 <jpcooper> @hoogle CGI
04:49:50 <lambdabot> package cgi
04:49:50 <lambdabot> package cgi-undecidable
04:49:50 <lambdabot> package fastcgi
04:50:11 <Saizan> jpcooper: then i think my suggestions won't work out :)
04:50:31 <jpcooper> I could lift the results into the CGI monad and output them
04:51:09 <Saizan> jpcooper: though the state won't easily survive between requests, unless you use an IORef or MVar to hold it
04:51:39 <jpcooper> Saizan, even with a CGI transformer?
04:52:09 <Saizan> jpcooper: runFastCGI wants CGIT IO CGIResult
04:52:29 <jpcooper> right
04:52:53 <jpcooper> and output returns a CGIResult
04:53:20 <dobblego> @type (liftM . join (***))
04:53:22 <lambdabot> forall (m :: * -> *) b c. (Monad m) => (b -> c) -> m (b, b) -> m (c, c)
04:53:57 <jpcooper> Saizan, I'm just trying to understand what the problem is here
04:54:25 <jpcooper> is it because I'll be combining the CGI monad with the StateT, or something?
04:55:05 <Saizan> kind of
04:55:36 <Saizan> runFastCGI gets an action in the CGI monad, that action gets rerun for every incoming request
04:56:00 <jpcooper> right
04:56:49 <Saizan> so, even if you can transform a StateT s CGI action into a CGI action with runState, the current state won't be automatically propagate to the next time runFastCGI reruns the action given
04:57:10 <Saizan> it'll restart with the initial state instead
04:57:42 <Saizan> a solution is to "tunnel" the state via a MVar
04:58:05 <Saizan> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html <- as described here
04:58:18 <jpcooper> thanks
04:58:20 <jpcooper> this is disappointing
04:59:30 <jpcooper> a question on terminology: what does the "base" and "bottom" monad mean?
04:59:33 <jpcooper> are they the same?
04:59:58 <Saizan> i'd tend to think so
05:01:20 <jpcooper> so in StateT A B C, is the base monad StateT?
05:01:57 <Saizan_> the base monad is B
05:02:04 <BONUS> StateT in itself isn't a monad, (StateT s m) is
05:02:05 <desp> @hoogle Monad m => m (a, a) -> (a -> b) -> m (b, b)
05:02:06 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
05:02:06 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
05:02:06 <lambdabot> Data.Array.Base mapIndices :: (MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)
05:02:37 <jpcooper> oh right
05:02:57 <jpcooper> yes thanks BONUS
05:03:16 <BONUS> i call m the underlying monad :)
05:03:28 <anders^^> is it possible to build the Unix package on windows, using cygwin? maybe this question belongs in #ghc?
05:03:59 <Saizan_> however in this case you could perform an inversion of control via threads, and get to work in any monad you want
05:06:46 <desp> @pl fromIntegral2 (a1, a2) = (fromIntegral a1, fromIntegral a2)
05:06:47 <lambdabot> fromIntegral2 = fromIntegral *** fromIntegral
05:07:28 <desp> @hoogle (***)
05:07:29 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:07:55 <jpcooper> @type map
05:07:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:08:08 <jpcooper> how is that legal with the monomorphism restriction?
05:09:00 <MyCatVerbs> Because map's type is given explicitly.
05:09:18 <MyCatVerbs> Also the MR is gone from HEAD GHC, I think?
05:09:27 <Saizan_> map has nothing to do with MR
05:09:51 <Saizan_> MR applies only where there are typeclass contexts
05:09:59 <MyCatVerbs> Ah, thanks Saizan_.
05:10:03 <jpcooper> so forall is legal haskell 98?
05:10:16 <BONUS> nope
05:10:20 <Saizan_> the forall keyword isn't legal haskell 98
05:10:46 <Saizan_> however all variables in haskell 98 types are implicitly universally quantified like that
05:14:15 <desp> Oops.
05:14:16 <desp> @pl (\_ _ -> return ())
05:14:17 <lambdabot> const (const (return ()))
05:14:39 <desp> Not much of an improvement there.
05:16:06 <idnar> const const const const mushroom mushroom
05:16:30 <fons> hi everyone
05:19:03 <fons_> Does anyone know about a Haskell implementaion of "Monadic i/o and UNIX shell programming" (http://okmij.org/ftp/Computation/monadic-shell.html ) ?
05:21:17 <fons_> I would like to use the sytactic sugar of the do notation to implement shell-&& as (>>) and shell-pipes as (>>=) being able to log the output of all processes in a file and be able to control errors during execution (i.e. stopping execution as soon as a process execution fails)
05:23:30 <Jedai> fons_: http://hackage.haskell.org/package/HSH
05:24:04 <Saizan_> HSH uses a custom operator (-|-) for pipes though
05:24:13 <Jedai> fons_: It's not exactly what you're talking about, but it offer a pretty expressive way to do shell-like command manipulation
05:24:50 <Jedai> Saizan_: True :)
05:25:59 <Saizan_> mostly for overloading though, i guess
05:26:02 <LeCamarade> Who is man developer of cabal?
05:26:05 <LeCamarade> *main*
05:26:25 * LeCamarade ducks from any feminist daggers that may have flown between message 0 and message 1.
05:26:49 <Jedai> LeCamarade: Cabal or cabal-install ?
05:27:05 <LeCamarade> Jedai, Both. :o)
05:27:39 <Saizan_> LeCamarade: dcoutts__
05:27:44 <fons_> Jedai, Saizan_, yes I've already seen that package and its pipe implementation can certainly be reused, I was thinking about wrapping HSH around an error monad, but I don't really know how to transform && and pipes into monadic syntactic sugar afterwards
05:28:56 <LeCamarade> @tell dcoutts__ I just wanted to make formal my own personal thanks for your work on Cabal. I'm just a grateful user. Pass this on to the rest of the team.
05:28:57 <lambdabot> Consider it noted.
05:29:04 <fons_> fons_: my main problem is that a monad is polymorphic in its type arguments by defintion (a constructor class) while the shell is more specific (it uses strings)
05:29:42 <Saizan_> fons_: i think you mostly need to wrapp shell commands into appropriate IO actions
05:30:14 <Saizan_> fons_: though maybe you'd need lazy IO to get the effect of pipes
05:31:06 <LeCamarade> ?hoogle irc
05:31:07 <lambdabot> package irc
05:31:07 <lambdabot> package ircbouncer
05:31:07 <lambdabot> package rss2irc
05:31:17 <LeCamarade> ?where irc
05:31:17 <lambdabot> I know nothing about irc.
05:31:36 <LeCamarade> lambdabot, Well, you're in an IRC channel, for starters.
05:31:44 <kynky> lol
05:31:55 <Saizan_> ssssh
05:31:56 <kynky> irc is a relatively soimple rfc
05:32:01 <Axman6> oh man, i9 just completely wiped my MBP by accident >_<
05:32:03 <Saizan_> we're trying to not make her realize.
05:32:31 <LeCamarade> ?where+ irc http://hackage.haskell.org/package/irc
05:32:32 <lambdabot> Okay.
05:32:33 <Axman6> well, wiped the partition table at least
05:32:33 <Saizan_> MBP?
05:32:38 <LeCamarade> ?where irc
05:32:38 <Maddas> Macbook Pro.
05:32:38 <lambdabot> http://hackage.haskell.org/package/irc
05:32:44 <Axman6> what Maddas  said
05:33:06 <Axman6> so lost both my OS X and windows partitions
05:33:08 <idnar> Axman6: http://www.cgsecurity.org/wiki/TestDisk
05:33:23 <Axman6> luckily, i have a backup of OS X and all i had in windows was games
05:33:55 <jpcooper> Axman6, I had one for five days and the RAM failed
05:34:00 <jpcooper> I decided to ask for my money back
05:34:03 <jpcooper> good luck with yours
05:34:14 <thoughtpolice> Axman6: i9?
05:34:23 <lpsmith> heh,  I just found a performance regression in the 6.10 series
05:35:15 <Axman6> idnar: that would have been quite helpful half an hour ago :P
05:35:27 <Axman6> reinstalling OS X at the moment
05:45:37 <maartenm> the euler problems are becoming boring..
05:45:45 <maartenm> are there other (better) haskell puzzles?
05:46:12 <Axman6> you could help me write this proxy server i'm working on if you like.,.. >_>
05:46:12 <maartenm> preferably with IO/sockets.. I remember when I learned ruby there was a ruby quiz with hundreds of questions
05:46:14 <maartenm> that was cool
05:46:32 <maartenm> axman6: no, sorry. you wouldn't want that anyway
05:46:36 <Axman6> heh
05:46:42 <lpsmith> maartenm:  have you tried some of the harder,  more recent problems?
05:46:49 <maartenm> lpsmith: heh, no
05:47:06 <maartenm> lpsmith: I have read them though.. maybe I should tackle one
05:47:18 <maartenm> lpsmith: but they all seemed 90% pen/paper
05:48:09 <lpsmith> meaning,  pen and paper for working out a program to solve them,  or actually solvable by pen and paper?
05:48:30 <lpsmith> Of the latter,  I've only run across a few that I could solve with pen and paper alone
05:48:35 <maartenm> well, I mean pen, paper, and a rather deep encyclopedic knowledge of mathematical theorems needed
05:48:46 <dschoepe> maartenm: hm, you could try to rewrite some application you find interesting(e.g. tetris).
05:48:47 <maartenm> and then a rather simple program needed
05:49:04 <maartenm> dschoepe: yeah maybe I should just write something useful..
05:49:13 <maartenm> I want to write a BPM detector in haskell
05:49:30 <maartenm> bpm :: IO(MP3) -> Int
05:49:37 <kynky> beats per minute?
05:49:40 <maartenm> yeah
05:49:56 <dschoepe> maartenm: more like "MP3 -> IO Int"
05:49:58 <lpsmith> maartenm:  you might try 202,  it looks hard, but it's not that bad once you see the trick.  It's beautiful. :-)
05:50:17 <kynky> guess will be fft work ? fast fourier transforms ?
05:50:29 <maartenm> yeah, I used to do a lot of projects in uni with that
05:50:32 <maartenm> tone detection and stuff
05:50:42 <maartenm> but I do hope there are some existing libs I could use
05:50:58 <maartenm> dschoepe: yeah, Euler did not teach me a lot about IO/impurity yet..
05:51:31 <lpsmith> maartenm is using that newfangled IO comonad :-P
05:51:43 <kynky> i know projectm has beat detection routines, but think that in c++
05:52:07 <maartenm> 202.. that was one I already read
05:52:12 <maartenm> it seemed completely crazy
05:52:54 <lpsmith> do you play pool at all?
05:52:56 <maartenm> when I saw it I was thinking of making a simulation in Blender.. but that woudl take too long to run :)
05:53:05 <EvilTerran> lpsmith, i thought it was the OI comonad :P
05:53:10 <maartenm> lpsmith: as a matter of fact I'm a 50 break at snooker
05:53:18 <tomh-> if you want hard haskell puzzles look on http://www.cs.uu.nl/wiki/bin/view/Afp/Assignments
05:53:33 <dschoepe> In my opinion projecteuler is much more useful as a math exercise than a programming exercise.
05:53:34 <lpsmith> I thought 202 was completely crazy until I thought about the way I line up my bankshots :)
05:54:44 <maartenm> using a "ghost" object ball?
05:54:55 <fasta> Is there any released version of GHC in which -fwarn-unused-imports returns the correct result?
05:54:56 <lambdabot> fasta: You have 1 new message. '/msg lambdabot @messages' to read it.
05:56:07 <lpsmith> maartenm:  maybe.  I'm not sure what you mean by that, but it could be my method.   Actually it sounds like the dual of my method.
05:56:19 <maartenm> hmm I guess it becomes a recursive problem then with a whole bunch of these triangles stacked togetehr in a honeygrate.. and then a bouncing path just becomes a straight line through that structure
05:59:25 <lpsmith> bingo
05:59:54 <maartenm> cool :)
06:01:26 <maartenm> althoguth I guess you can change "recusrive problem" with "geometric problem"
06:01:53 <maartenm> ok I'll try that one in haskell
06:02:27 <maartenm> tomh: those are nasty, they remind me too much of university
06:03:01 <lpsmith> fasta: what kind of problems are you having?
06:03:36 <fasta> lpsmith: I have import Foo(bar, baz, bam) and I use bam later in the source code. Yet, ghc reports that it is not used.
06:04:03 <fasta> lpsmith: I use bar and baz too, btw.
06:04:25 <tomh-> they are indeed nasty :P
06:06:39 <jpcooper> are there any current objections to existential types being standardised?
06:06:52 <quicksilver> fasta: do you also import bam from anywhere else?
06:07:05 <quicksilver> fasta: I recall this situation confuses the unused-imports warner.
06:07:18 <lpsmith> is bam shadowed maybe?
06:07:26 <quicksilver> (I also find that warning useless for that reason)
06:07:28 <fasta> quicksilver: I do import Foo qualified also.
06:07:35 <lpsmith> I'll admit I'm not a big fan of -Wall,  so I don't use it that much
06:07:56 <lpsmith> the shadowing warnings especially annoy me
06:08:03 <fasta> I think it's better to just remove the feature until it works.
06:09:13 <fasta> Maybe  * Major patch to fix reporting of unused imports fixed it.
06:09:33 <lpsmith> jpcooper:  I certainly don't object,  in fact I wish GHC had added existentials in arbitrary locations (as opposed to just datatypes)  years ago
06:09:47 <jpcooper> arbitrary locations?
06:10:00 <lpsmith> Now that UHC's available and has that,  maybe I can dust off some of my ideas with that
06:10:12 <PeakerWork> hey, http://en.wikipedia.org/wiki/Denotational_semantics   seems great
06:10:20 <fasta> jpcooper: probably, so that you don't need explicit existentials.
06:10:22 <lpsmith> yeah,  like  higher ranked types,  except with existentials
06:10:51 <jpcooper> okay
06:12:01 <idnar> @src all
06:12:01 <lambdabot> all p =  and . map p
06:12:08 <edwardk> lpsmith: I'd be even happy with them in newtypes
06:12:08 <ivanm> with the including C libraries in hackage packages discussion on -cafe... isn't in most cases that considered to be a Bad Idea if that's a C library likely to be included in a distribution?
06:12:40 <idnar> @src and
06:12:40 <lambdabot> and   =  foldr (&&) True
06:12:41 <Saizan_> would type checking keep being decidable with first-class existentials?
06:12:45 <ivanm> Gentoo devs continually have a fun time with upstream including other libraries in their source; and that's why songbird (or whatever the xul-based itunes clone is called) isn't available even in Ubuntu IIRC...
06:13:27 <edwardk> saizan: other haskell implementations have them like UHC
06:13:39 <lpsmith> edwardk:  I'm not sure having them in newtypes would work for what I had in mind... then again I'm not entirely sure if what I had in mind was a great idea either.  I'll have to try it out
06:13:47 <maartenm> lpsmith: did you use an infinite 'tree' of triangles, emitting from the origin point?
06:13:58 <maartenm> lsmith: or did you do a geometric approach
06:14:01 <quicksilver> does UHC have explicit syntax for unpacking the existential?
06:14:04 <quicksilver> what does it look like?
06:14:35 <SamB_XP> Utrecht Haskell Compiler?
06:14:42 <Saizan_> yup
06:14:44 <fasta> Is there a way to install Haskell + Cabal with one command that is "guaranteed" to work in the future?
06:14:59 <SamB_XP> yup Utrecht?
06:15:00 <lpsmith> maartenm:   I didn't really need much geometric code,  I just boiled it down to a number theory problem using pencil and paper
06:15:07 <PeakerWork> @let result = (<<<), arg = (>>>)
06:15:07 <lambdabot>   Parse error
06:15:09 <SamB_XP> I didn't even get to guess twice :-(
06:15:12 <PeakerWork> @let result = (<<<)
06:15:13 <lambdabot>  Defined.
06:15:19 <PeakerWork> @type (result . result) and map
06:15:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:15:42 <jpcooper> funny how Glasgow does bugger all for GHC anymore
06:15:43 <fasta> It appears that the only way to automate it would be to parse the http page and find the highest released version.
06:15:52 <jpcooper> I might make a racket about this
06:15:53 <PeakerWork> @type (id ~> id ~> and) map
06:15:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:15:59 <lpsmith> quicksilver:  I don't know yet,  I haven't really played with UHC and it's existentials yet
06:16:18 <lpsmith> I'm guessing  something like  a -> exists b.  (Foo b) => b
06:16:27 * Axman6 thinks ghc should be renamed to thc: The Haskell Compiler
06:16:32 <idnar> @type (~>)
06:16:32 * lpsmith goes off to read the docs
06:16:33 <lambdabot> forall (cat :: * -> * -> *) a b b1 c. (Control.Category.Category cat) => cat a b -> cat b1 c -> cat b b1 -> cat a c
06:18:15 <edwardk> lpsmith: the newtype case is the one that i want, just so i can restore parity for colimits and limits, codensity and density. it bugs me that the existential case picks up a superfluous bottom
06:18:16 <ivanm> Axman6: GHC /= Haskell
06:18:36 <edwardk> well, limits and colimits anyways
06:18:41 <ivanm> it's not like CPython == Python (for all extents and purposes)
06:18:44 <edwardk> the others require a tuple regardless
06:18:52 <lpsmith> Yeah,  my guess was correct about notation, it appears
06:19:05 <lpsmith> just like forall, except in arbitrary locations
06:20:12 <lpsmith> Existential types do not work with:  Class instances to be hidden together with the existential.
06:20:15 <lpsmith> hmm
06:20:25 <quicksilver> lpsmith: sure, but given an existential parameter, how do you get at the contents?
06:20:28 <lpsmith> maybe UHC can't quite do what I want, then.  I'm not sure
06:20:51 <lpsmith> exists a . a   is not a useful type
06:21:16 <lpsmith> You need either class instances or something like  exists a.  (a,  a -> b, a -> c)
06:21:52 <RayNbow> Peaker: why not introduce a flipped version of ($)?
06:22:44 <RayNbow> :t let ($::) = flip ($)   in   map $:: (id ~> id ~> and)
06:22:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:23:05 <RayNbow> ^ PeakerWork
06:23:44 <PeakerWork> RayNbow: that's what the original (~>) dude did
06:23:55 <RayNbow> yeah, but he used ($.) iirc
06:24:10 <Saizan_> both result and ~> don't really read well, find other names!
06:24:21 <PeakerWork> Saizan_: I think result reads well :)  like first, second, etc
06:24:30 <dobblego> whatever you call it, wrap it in <> and flip (<$>) while ya there
06:24:41 <PeakerWork> Saizan_: (result . first . arg) is a descriptive path in the type, imo
06:24:41 <lpsmith> I think somebody suggested (>$>),  maybe it was Simon Thompson in one of his books
06:25:49 <RayNbow> Saizan_: I like (~>) since it corresponds nicely with the original function's type signature
06:26:41 <Saizan_> PeakerWork: something like atResult would make more sense to me
06:26:54 <PeakerWork> Saizan_: what about first,second?
06:27:06 <PeakerWork> atFirst . atSecond . atResult ... not sure that reads better?
06:27:39 <PeakerWork> if   each = map      then:  (each . result . first)   is a pretty readable way to apply a function to the first of a result of each element..
06:28:09 <PeakerWork> If Haskell didn't have N-tuples, but only 2-tuples, then   first/second would be all you need for tuples, too
06:29:45 <RayNbow> > ((not.) ~> (map not) ~> or) map not [True,True]
06:29:47 <lambdabot>   False
06:32:21 <Saizan_> ?type ((not.) ~> (map not) ~> or)
06:32:25 <lambdabot> forall a. ((a -> Bool) -> [Bool] -> [Bool]) -> (a -> Bool) -> [Bool] -> Bool
06:33:14 <jkff> :t (~>)
06:33:16 <lambdabot> forall (cat :: * -> * -> *) a b b1 c. (Control.Category.Category cat) => cat a b -> cat b1 c -> cat b b1 -> cat a c
06:33:41 <jkff> Ouch.
06:34:14 <Saizan_> jkff: with cat = (->) it's simpler
06:34:50 <jkff> Yeah, I am just surprised that it has 3 arguments, not 2
06:35:00 <jkff> ...However, noone said it was going to be the composition.
06:35:07 <lpsmith> hackage is warning me that my package is using unallocated top-level names when I use the test upload,  is this really a big deal?
06:35:18 <jkff> Does this ~> have a name?
06:35:24 <Saizan_> lpsmith: not so much
06:39:33 <hackagebot> NumberSieves 0.0 - Number Theoretic Sieves:  primes, factorization, and Euler's Totient (LeonSmith)
06:45:52 <LeCamarade|Away> Hey, I just cabal installed the IRC library, but its modules don't show up ih GHCi. What fe do?
06:46:04 <Plouj-> ok, is this a real Haskell operator: "((.) . (.))" ?
06:46:24 <lpsmith> type  "import  IRC.Module.Name"
06:46:26 <saml> Plouj-, no
06:46:31 <LeCamarade|Away> Yes, it is. A variant on The Owl.
06:46:42 <saml> @type ((.) . (.))
06:46:43 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:46:50 <saml> Plouj-, i'm sorry. yess
06:46:51 <Twey> Plouj-: No, it's two operators, joined with a third
06:46:53 <lpsmith> or you could always prefix your function name with "IRC.Module.Name.foo"
06:47:11 <Plouj-> http://www.reddit.com/r/programming/comments/90g80/history_of_the_c_family_of_languages_funny/c0b0rqj :(
06:47:18 <saml> > ((.) . (.)) succ (+) 1 2
06:47:21 <lambdabot>   4
06:47:44 <lpsmith> @unpl ((.) . (.))
06:47:45 <lambdabot> (\ i b c f -> i (b c f))
06:49:06 <LeCamarade|Away> What is one to do, when one cabal install a library that fails to show up in imports?
06:50:07 <lpsmith> LeCamarade|Away:   can you be a bit more precise?
06:51:11 <Philonous1> Is unsafeInterleaveIO something that should be avoided? (I use it for "infinite" lists of MVars)
06:51:30 <iago> ivanm: well, in the gsoc abstract he saids that recognize comments is part of the project... although seeing his blog posts I'm not sure if it isn't a priority now :)
06:51:36 <hackagebot> HsOpenSSL 0.6.3 - (Incomplete) OpenSSL binding for Haskell (MasatakeDaimon)
06:52:34 <ivanm> Philonous1: unsafe* should be avoided unless you can guarantee purity
06:52:55 <LeCamarade> lpsmith, I did cabal install irc, and then in ghci :browse Network.IRC.Base doesn't work, because Network.IRC doesn't exist, yet that is what the irc package installs, supposedly.
06:53:21 <ivanm> :o I didn't know about :browse
06:53:57 <ivanm> LeCamarade: just checking, but did you run ghci as the same user that did cabal install?
06:54:06 <ivanm> LeCamarade: and does "ghc-pkg list irc" reveal anything?
06:55:11 <LeCamarade> Wait. I installed a root, and ran GHCi as non-root. Does it matter? Does it matter?
06:55:21 <ivanm> LeCamarade: hmmm.... that should work
06:55:39 <ivanm> LeCamarade: _unless_ for some reason it decided to install as a local user install for root...
06:55:42 <ivanm> rather than global
06:56:02 <LeCamarade> Wait. When I run it as root, it works.
06:56:13 <lpsmith> permission problem?
06:56:22 <lpsmith> also check if you have a /root/.cabal
06:56:25 <ivanm> LeCamarade: run "ghc-pkg list irc", and see if it's under the global or local list
06:56:31 <ivanm> if it's in the local list, then only root can see it
06:56:42 <ivanm> LeCamarade: use "cabal install --global" to install things globally
06:57:16 <LeCamarade> Thanks. I'll have to redo it for all packages I installed non-globally.
06:58:19 <LeCamarade> @karma+ ivanm
06:58:20 <lambdabot> ivanm's karma raised to 4.
06:58:23 <LeCamarade> @karma+ lpsmith
06:58:23 <lambdabot> lpsmith's karma raised to 2.
06:58:36 <ivanm> I have karma? :o
07:01:16 <ivanm> @ask mmorrow do you know how to make Doc have a blank line? $+$ space $+$ ?
07:01:17 <lambdabot> Consider it noted.
07:02:30 <jpcooper> say I'm using StateT A IO. Why is liftIO used over lift?
07:03:11 <ivanm> jpcooper: because it's a special version of lift designed to get into IO? *shrug*
07:03:22 <ivanm> @type liftIO
07:03:24 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
07:03:31 <jpcooper> @type lift
07:03:32 <ivanm> @src MonadIO
07:03:32 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
07:03:33 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:03:36 <lpsmith> lift should work as well
07:03:45 <jpcooper> okay
07:03:49 <ivanm> jpcooper: maybe because it's a different class that requires it? *shrug*
07:03:52 <kpreid> jpcooper: lift goes in one level of transformer. liftIO goes across as many levels as necessary to get to IO.
07:03:58 <quicksilver> jpcooper: because it works even if you are in FooT BarT BazT StateT IO
07:04:00 <jpcooper> thanks
07:04:07 <kpreid> you can use liftIO even in IO itself
07:04:16 <quicksilver> jpcooper: so it makes your code slightly more resilient to changes in your monad stack.
07:04:30 <quicksilver> Of course you should never use StateT A IO
07:04:36 <ivanm> kpreid: what happens if you have multiple levels of IO? :p
07:04:45 <Saizan_> ivanm: you can't.
07:04:47 <kpreid> ivanm: Gee, I don't see any parameter to IO
07:04:53 <quicksilver> you should use newtype JPCooperM = JPCooperM (StateT A IO)
07:04:54 <kpreid> (There is no IOT)
07:05:01 <ivanm> yeah, I realise that
07:05:12 <quicksilver> so that you can change your monad stack later without changing all your types.
07:05:24 <jpcooper> why newtype over type?
07:05:26 <jpcooper> is it just faster?
07:05:35 <kpreid> erm
07:05:35 * ivanm at first was mixed up between the monad type in the lifted monad the type of the monad)
07:05:48 <quicksilver> jpcooper: type doesn't actually make a new type.
07:05:56 <quicksilver> it's just a synonym.
07:05:57 <ivanm> jpcooper: newtype lets you have a safe way of seperating out specific values
07:05:59 <kpreid> type *and* newtype both have no effect on runtime efficiency
07:06:00 <ivanm> or provide new instances
07:06:08 <kpreid> type is just an alias
07:06:12 <jpcooper> okay
07:06:23 <kpreid> newtype is "give me a distinct type which happens to be implemented identically to this existing one"
07:06:33 <kpreid> e.g. newtype URL a = URL String
07:06:40 <kpreid> er, s/ a//
07:07:04 <ivanm> and then you can do: instance Show URL where show (URL s) = "<" ++ s ++ ">"
07:07:06 <ivanm> or something
07:07:23 <jpcooper> right
07:07:25 <ivanm> whereas you can't do that for type
07:07:32 <ivanm> type is just for readability/documentation purposes
07:07:37 <kpreid> or: newtype HTML = HTML String, and you have a function which replaces "<" with "&lt;" of type String -> HTML
07:10:23 <foo-nix> twanvl, I didn't see ANDQ yet, unfortunately.
07:22:00 <ivanm> @ask mmorrow also, do you know how to pretty-print "columns" of data so that they all line up neatly (without having to worry about knowing how long the maximum is and then nesting)?
07:22:00 <lambdabot> Consider it noted.
07:22:32 <quicksilver> isn't that what the horizontal composition operator is for?
07:23:18 <quicksilver> ivanm: I mean, <+>
07:23:58 <ivanm> quicksilver: doesn't seem to work for two multi-lined things :(
07:24:21 <ivanm> > (text "a" $$ text "c") <+> (text "b" $$ text "d")
07:24:23 <lambdabot>   Ambiguous occurrence `<+>'
07:24:24 <lambdabot>  It could refer to either `Control.Arrow.<+>', i...
07:24:44 <quicksilver> hmm.
07:24:47 <ivanm> > (text "a" $$ text "c") Text.PrettyPrint.<+> (text "b" $$ text "d")
07:24:49 <lambdabot>   Not in scope: `Text.PrettyPrint.<+>'
07:24:53 <quicksilver> yes, tested it in my ghci.
07:24:53 <ivanm> gah!
07:25:04 <quicksilver> I mean, yes it doesn't work - you are right.
07:25:09 <ivanm> heh
07:25:48 <quicksilver> I think Text.PrettyPrint is not fully two-dimensional.
07:25:58 <ivanm> yeah :(
07:26:05 <quicksilver> I think it's more about sensible line wrapping
07:26:09 <quicksilver> than full 2D layout
07:26:27 <quicksilver> maybe someone else who has actually used it knows better
07:26:39 <ivanm> hence why I @ask'd mmorrow ;-)
07:27:01 <ivanm> anyway, I just finished converting all 150 Graphviz attributes into a form my code generation routines can understand to put into the graphviz bindings...
07:27:08 <ivanm> and I've had enough for tonight
07:27:13 <ivanm> g'night all
07:27:15 <quicksilver> ivanm: http://hackage.haskell.org/package/pretty-ncols
07:27:56 <ivanm> quicksilver: ooohhhhh.....
07:27:56 <ivanm> thanks!
07:28:08 <quicksilver> the mere fact that package exists suggests we are right
07:28:13 <quicksilver> and plain prettyprint doesn't do this
07:28:59 <ivanm> heh, it pretty much does it the way I would have done it by hand if I could be bothered to do so ;-)
07:30:00 <quicksilver> nod
07:30:58 <ivanm> @tell mmorrow nvm about the column question, quicksilver just pointed out pretty-ncols to me which does that
07:30:59 <lambdabot> Consider it noted.
07:33:46 <byorgey> I can confirm that Text.PrettyPrint doesn't do 2D layout like that.  It's for pretty-printing a 1D stream of text.
07:33:56 <byorgey> I've banged my head against that in the past too.
07:34:58 <Elly> just because a package exists to do it does not mean it's a good idea
07:35:09 <Elly> the canonical example I use to back this statement up is Inline::ASM from CPAN
07:35:34 <quicksilver> byorgey: that's what I had begun to suspect.
07:35:39 <EvilTerran> Elly, :O
07:35:48 <EvilTerran> ?go cpan inline-asm
07:35:50 <lambdabot> http://search.cpan.org/dist/Inline-ASM/
07:35:50 <lambdabot> Title: Neil Watkiss / Inline-ASM - search.cpan.org
07:36:00 <quicksilver> Elly: or all of PHP?
07:36:45 <Elly> quicksilver: another good example
07:49:50 * SamB_XP realizes it probably wasn't a great idea to run X under GDB at the console ...
07:50:51 <Zao> Sounds about as fun as realizing that you just hit a breakpoint inside the nvidia driver.
07:50:55 <Zao> From an xterm :)
07:51:26 <Zao> It's at times like that you're happy you've got enough machines around to remote debug.
07:51:52 <SamB_XP> Zao: I don't think I'm *that* forgetful
07:52:56 <quicksilver> byorgey: I wonder if there is a market for a fairly set of 2D layout combinators.
07:53:08 <Zao> Fairly set?
07:53:25 <SamB_XP> hmm, I hope Xorg doesn't do too many intentional segfaults
07:53:25 <quicksilver> insert "simple"
07:53:37 <desp> Is it possible to write a generalized type class instance, such as  instance (Foo a) => Num a
07:53:40 <desp> ?
07:54:27 <Zao> quicksilver: What does it do?
07:54:32 <desp> Meaning that every instance of a belonging to class Foo should also be an instance of class Num.
07:54:56 <Zao> I've found myself having to hack up my own layout system more than once, but that has been in C++.
07:55:13 <EvilTerran> desp, not without -XUndecidableInstances, and -XOverlappingInstances if you want any other instances of Num (which you do)
07:55:45 <EvilTerran> quicksilver, i was wondering the same thing myself. box-model style textual layout or something.
07:56:34 <quicksilver> Zao: horizontal + vertical composition, render to a given width (and possibly page height)
07:56:41 <quicksilver> with defined behaviour on overfull lines/pages
07:56:43 <quicksilver> was my thinking
07:56:44 <fasta> Did anyone implement polygon shrinking?
07:56:53 <Zao> Ah, that kind of layout.
07:56:57 <Zao> I was stuck in UI thinking.
07:58:03 <maartenm> that Inline-ASM looks cool.. what's wrong with it? :)
08:00:28 * SamB decided to try just commenting the monitor frequency ranges out of his xorg.conf before trying any harder to figure out what was causing Xorg -configure to crash ...
08:00:37 * SamB found it to work
08:01:16 <SamB> (that was nothing to do with why it was crashing, though -- just why I wanted to run Xorg -configure in the first place)
08:21:59 <jpcooper> what's the easiest way to get a stream from a set of handles?
08:22:58 <quicksilver> reading them one after another in order or what?
08:23:22 <jpcooper> quicksilver, I thought there might be some kind of select thing
08:25:31 <quicksilver> jpcooper: there is.
08:25:38 <quicksilver> jpcooper: I was trying to understand your question.
08:25:39 <jpcooper> @hoogle select
08:25:40 <lambdabot> Text.XHtml.Frameset select :: Html -> Html
08:25:40 <lambdabot> Text.XHtml.Strict select :: Html -> Html
08:25:40 <lambdabot> Text.XHtml.Transitional select :: Html -> Html
08:25:42 <quicksilver> the "select thing" is threads.
08:26:08 <quicksilver> fork a thread for each handle, read from the handles and communicate result somehow - perhaps push it onto a Chan
08:26:22 <jpcooper> I could use mergeIO?
08:26:38 <jpcooper> yes never mind, I'll use a channel
08:31:22 <Baughn> @undo gccc c = do empty <- isEmptyChan c; if empty then [] else do v <- readChan c; vs <- gccc c; return (v:vs)
08:31:23 <lambdabot> gccc c = isEmptyChan c >>= \ empty -> if empty then [] else readChan c >>= \ v -> gccc c >>= \ vs -> return (v : vs)
08:31:27 <Baughn> @. pl undo gccc c = do empty <- isEmptyChan c; if empty then [] else do v <- readChan c; vs <- gccc c; return (v:vs)
08:31:28 <lambdabot> gccc = fix (liftM2 (>>=) isEmptyChan . (flip (flip if' []) .) . liftM2 (>>=) readChan . flip flip ((return .) . (:)) . (((.) . (>>=)) .))
08:31:37 <kaol> @hoogle (a -> Bool) -> (a -> Bool) -> Bool
08:31:38 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
08:31:38 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
08:31:38 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
08:31:51 <kaol> @type (||)
08:31:53 <lambdabot> Bool -> Bool -> Bool
08:32:19 <kaol> @hoogle (a -> Bool) -> (a -> Bool) -> (a -> Bool)
08:32:20 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
08:32:20 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
08:32:20 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
08:32:24 <Baughn> @type on (||)
08:32:25 <lambdabot> forall a. (a -> Bool) -> a -> a -> Bool
08:32:57 <EvilTerran> ?type liftA2 (||)
08:32:59 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
08:33:09 <saml> > let f <||> g = do { x <- get; return f x || g x; }
08:33:11 <lambdabot>   not an expression: `let f <||> g = do { x <- get; return f x || g x; }'
08:34:10 <saml> grrrr ghci doesn't do copy-paste well in windows cmd
08:34:14 <kaol> > (liftA2 (||) isDigit isAlpha) 'a'
08:34:15 <lambdabot>   True
08:34:16 <lambdabot> kaol: You have 1 new message. '/msg lambdabot @messages' to read it.
08:34:35 <EvilTerran> ?type \f g -> liftA2 (||) f g <$> get
08:34:37 <lambdabot> forall a (f :: * -> *). (MonadState a f, Functor f) => (a -> Bool) -> (a -> Bool) -> f Bool
08:34:45 <kaol> neat.
08:39:42 <SamB> okay, this is an interesting title:
08:39:58 <SamB> RFC970 On packet switches with infinite storage. J. Nagle.
08:52:18 <Baughn> Nothing like having a two-hundred-line program work the first time it compiles to make you appreciate haskell
08:52:25 * Baughn did spend half an hour debugging the compile, though
08:53:30 <SamB> isn't that the way it should work?
08:53:36 <HugoDaniel> hi
08:53:47 <Baughn> That's how haskell should work, yes, and that's how it works. It's neat.
08:54:05 <Baughn> HugoDaniel: Top o' the mornin' to you, my dear fellow
08:54:51 <Maddas> Baughn: Now if we can add another layer of static typing on the types, perhaps we can eliminate the half an hour of debugging the compile to only a few minutes of debugging the pre-compilation step! ;-)
08:55:06 <Maddas> s/eliminate/reduce/
08:55:14 <Vanadium> Maddas: hahaha
08:56:17 <pikhq> Do I sense a metatype system?
08:56:29 <Saizan_> nah, we want a stronger kind system
08:57:03 <Baughn> Nah, we want an infinite type hierarchy
08:57:16 <Baughn> With dependent typing at all levels
08:57:54 <bavardage> are there any predefined functions to group lists
08:58:01 <EvilTerran> there's... group!
08:58:03 <EvilTerran> ?type group
08:58:05 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
08:58:06 <bavardage> like [2,2,5,5,5] ---> [(2,3), (5,3)]
08:58:37 <EvilTerran> > map (head &&& length) . group $ [2,2,5,5,5,1,4,4,0,2,2]
08:58:39 <lambdabot>   [(2,2),(5,3),(1,1),(4,2),(0,1),(2,2)]
08:58:46 <bavardage> ooh, arrows eh?
08:59:04 <plumenator> I know that (++) appends two lists, what is the operator for inserting an element in the beginning(or end) of a list?
08:59:09 <Saizan_> (&&&) = \f g x -> (f x, g x) there
08:59:25 <bavardage> yop
08:59:26 <bavardage> ty
08:59:26 <pikhq> plumenator: (:)
08:59:32 <plumenator> (:) as in a:[a] doesn't seem to be an operator.
08:59:41 <Saizan_> it is
08:59:44 <Saizan_> ?type (:)
08:59:46 <lambdabot> forall a. a -> [a] -> [a]
08:59:59 <Saizan_> > 'a':"bc"
09:00:00 <lambdabot>   "abc"
09:00:07 <Axman6> plumenator: it's a function, and a constructor
09:00:13 <Baughn> plumenator: : is a function that prepends an element to a list. There is none to append one, as such
09:00:17 <Vanadium> Is it also an operator when it is used in pattern matching?
09:00:20 <Axman6> constructors are functions in haskell
09:00:21 <Vanadium> Or is it a constructor then?
09:00:29 <Saizan_> > 'a':'b':'c':[]
09:00:30 <lambdabot>   "abc"
09:00:31 <Baughn> plumenator: list ++ [a] will do it, but you should rarely actually do so. It needs to copy the entire list to do that.
09:00:47 <Saizan_> Vanadium: constructors can be operators or not
09:00:53 <Baughn> Vanadium: Constructors are functions, not all functions are constructors
09:01:05 <desp> How can I make the whole "class MyVector v" an instance of Num?
09:01:07 <EvilTerran> all operators are functions; all constructors are functions
09:01:07 <Baughn> You can only pattern-match on constructors. As it happens, : is a constructor
09:01:09 <Saizan_> Vanadium: contructors that are operators must start with :
09:01:10 <jkff> ':' is name of the Cons constructor. Since it is a constructor, it can be used both for pattern matching and as a function.
09:01:44 <jkff> desp: How about "instance (MyVector v) => Num v where ..." ?
09:02:39 <jkff> @users
09:02:40 <lambdabot> Maximum users seen in #haskell: 658, currently: 626 (95.1%), active: 18 (2.9%)
09:02:58 <jkff> Not bad
09:03:17 <EvilTerran> jkff / desp, the problem with that is that it'd be an undecidable instance, and it'd overlap all other Num instances
09:03:18 <mreh> do they discuss language parsing on freenode?
09:03:19 <plumenator> Hmm, how come hoogle doesn't return any results for "(:) :: a -> [a] -> [a]"?
09:03:28 <EvilTerran> ?hoogle (:)
09:03:29 <lambdabot> Parse error:
09:03:29 <lambdabot>   --count=20 (:)
09:03:29 <lambdabot>               ^
09:03:33 <EvilTerran> hm.
09:03:51 <jkff> EvilTerran: True.
09:04:14 <desp> EvilTerran: right, you mentioned that before.  I don't understand why would it be undecidable and what does that mean in practice, though.
09:04:53 <jkff> btw, I can't resist the temptation to boast: this semester I taught a course in functional programming, and a couple of days ago students rated the course 5.1 out of 5 (some rated it 5.5). I'm rather delighted that they liked functional programming so much :)
09:05:28 <mapreduce> I guess they're better at FP than maths then.
09:05:34 <desp> :)
09:05:42 <jkff> mapreduce: Why?
09:05:57 <mapreduce> Because 5.5 is invalid in an "out of 5" measurement.
09:06:16 <Vanadium> Would that end up being a type error?
09:06:33 <mapreduce> If you had a type that only accepted numbers less than or equal to 5, sure.
09:06:35 <desp> Is there a in-source flag for enabling undecidable instances?
09:06:44 <jkff> Well, they abused the lack of a typechecker, then :)
09:06:45 <EvilTerran> desp, basically, in an instance decleration, the context (to the left of the =>) has to be simpler than the head (to the right of the =>)
09:06:55 <jkff> After all, the course was based on Scheme rather than on Haskell
09:07:09 <mapreduce> jkff: Did set! make it in?
09:07:35 <jkff> mapreduce: It did, as it did into SICP. The course was based on SICP + many additions from areas not covered there
09:07:38 <EvilTerran> desp, this being a fairly primative way of ensuring that instance resoultion always terminates
09:07:49 <mapreduce> I used to teach but couldn't get out of Perl and Java before getting fed up and leaving.
09:07:54 <EvilTerran> desp, you can enable it with {-# LANGUAGE UndecidableInstances #-}
09:08:00 <mapreduce> jkff: Fair enough, sounds fun.
09:08:14 <desp> EvilTerran: thanks.
09:08:36 <desp> jkff: thank you as well.
09:12:11 <hackagebot> Hipmunk 5.0.0 - A Haskell binding for Chipmunk. (FelipeLessa)
09:12:17 <Baughn> ..oh, come on. Can't I write a /single/ program without uncovering a ghc bug? >_<
09:12:52 <wmealing> attempting to walk through some of the basics, I get this "Roygbiv.hs:1:0: The function `main' is not defined in module `Main' ".. Ive figured a work around  and thats to make a module called Main with a function called main..
09:12:58 <wmealing> is that the done thing ?
09:13:04 <Raynes> ..oh, come on. Can't anyone write a /single/ program without putting an H at the beginning of it? >_<
09:13:29 <wmealing> as I kind of expected the simple examples to work without the functions.. as RHW suggests.
09:13:31 <Baughn> wmealing: Rather than attempting to compile it, I'd suggest opening it in ghci.
09:13:36 <pikhq> Hrainfuck, anyone?
09:13:48 <wmealing> Baughn: oh.. I see.
09:13:50 <Baughn> wmealing: Making an executable is not going to work without a main
09:14:06 <wmealing> Baughn: righto.. that answers that question.
09:14:06 <Baughn> wmealing: Oh, and if speed is an issue, you can pass -fobject-code to ghci
09:14:12 <hackagebot> HipmunkPlayground 5.0.0 - A playground for testing Hipmunk. (FelipeLessa)
09:14:55 <wmealing> Baughn: nah.. this is just toying around.. defining main and Main are fine.. i just thought I was doing something wrong.
09:14:58 * wmealing tips his hat
09:16:17 <Twey> Raynes: HSure
09:16:44 <Twey> Baughn: Which bug did you uncover?
09:16:57 <Baughn> Twey: http://hackage.haskell.org/trac/ghc/ticket/3371#preview
09:17:51 <Twey> Oh, they implemented that?
09:17:55 <Twey> Someone will be happy
09:20:41 <Baughn> "ping: unknown host localhost" <-- Well.. this explains a lot...
09:23:00 <heavensrevenge> hello
09:23:33 <pikhq> > "Hello."
09:23:35 <lambdabot>   "Hello."
09:25:53 <mreh> are finite state machines far below the functional level of abstraction?#
09:26:33 <quicksilver> they're both aboved and below it, in a sense.
09:26:49 <quicksilver> A compiler might use an FSM to implement some parts of a functional language
09:27:02 <quicksilver> but, on the other hand, at the high level such things are perfectly valid programming techniques.
09:27:30 <mreh> i'm translating chord symbols into lists of notes
09:27:45 <mreh> easiest way is to use a fsm
09:28:00 <mreh> it's a pretty trivial grammar
09:29:34 <plumenator> Why can't Haskell have a "show" method for functions like in Python?
09:30:10 <jpcooper> plumenator, what is it like in Python?
09:30:12 <Vanadium> Probably because most of the time you do not want to show functions
09:30:20 <Vanadium> and would rather have the compiler point out the error
09:30:24 <saml> plumenator, there are so many different types of functions
09:30:28 <plumenator> Well, in Python everything has a show method.
09:30:33 <plumenator> Even classes.
09:30:37 <Beelsebob> plumenator: ecause it would break referential transparency
09:30:43 <saml> maybe instance Show  (->)
09:30:53 <Beelsebob> plumenator: if the same function is applied to the same arguments it should have the same result
09:31:00 <Beelsebob> but function equality can't be computed
09:31:11 <Beelsebob> so the best you can do is print the same thing for all functions
09:31:20 <saml> Showable != Readable right?
09:31:29 * Beelsebob nods
09:31:59 <doserj> Beelsebob: you can do better, like printing the type of the function
09:32:05 <Beelsebob> oh, true
09:32:07 <plumenator> Well, the output could jsut say its a function and print its type, maybe?
09:32:27 <saml> > show (+)
09:32:29 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
09:32:29 <lambdabot>    arising from a use...
09:32:32 <Beelsebob> plumenator: well, there's a show for functions that returns "<function>" somewhere
09:32:49 <tibbe__> Text.Show.Function
09:32:51 * themroc- <3 haskell
09:33:12 <bavardag1> it would be nice in GCHI for example
09:33:15 <bavardag1> just to print <function>
09:33:25 <plumenator> I ask this question because it is difficult to decipher the error message ghci displays when I supply less than enough arguments.
09:33:26 <jpcooper> what would the result be?
09:33:43 <Beelsebob> bavardag1: tbh, I prefer ghc telling me what the type of the function is in the exceptin
09:34:06 <bavardag1> perhaps then something like <function> [type signature]
09:34:10 <bavardag1> rather than some huge exception
09:34:15 <plumenator> yeah
09:34:43 <bavardag1> Prelude> map
09:34:44 <bavardag1> map :: (a -> b) -> [a] -> [b]
09:34:46 <bavardag1> like that
09:34:57 <plumenator> bavardag1: you read my mind.
09:35:07 <Beelsebob> bavardag1: it couldn't print map
09:35:16 <bavardag1> hmm?
09:35:28 <Beelsebob> well, I could then give an equal function
09:35:36 <Beelsebob> and it would give jam :: ...
09:35:38 <pikhq> :t map -- works in ghci
09:35:40 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:35:41 <Beelsebob> or spam :: ...
09:35:45 <Beelsebob> which breaks referential transparency
09:35:58 <bavardag1> hmmm
09:36:01 <bavardag1> I guess
09:36:15 <bavardag1> well no, GCHI could just, in the case of Show breaking
09:36:18 <Beelsebob> also, it would have to be very careful to always give the type in exactly the same form
09:36:19 <bavardag1> instead just show :t
09:36:23 <Beelsebob> no matter what input its given
09:36:37 <bavardag1> but for gchi, anything would be better than the current OMG
09:37:02 <bavardag1> maybe just condense it down
09:38:08 <plumenator> Beelsebob: I don't understand how referential transparency comes into the pucture here.
09:38:25 <Beelsebob> plumenator: referential transparency says that given the same arguments, I must get the same result
09:38:34 <Beelsebob> suppose I define spam = map
09:38:40 <Beelsebob> spam and map are equal
09:38:44 <plumenator> yeah
09:38:49 <plumenator> and they have the same type.
09:38:49 <Beelsebob> so applying show to spam, and to map must give the same result
09:39:00 <Beelsebob> but under the proposal above one would give "spam :: ..."
09:39:04 <Beelsebob> while the other would give "map :: ..."
09:39:13 <Beelsebob> so you can't name the function
09:39:17 <plumenator> Hmm.
09:39:32 <Beelsebob> you'd need to give "<function> :: ..." no matter what
09:39:50 <plumenator> I guess type is enough then.
09:40:40 <Saizan_> Beelsebob: well, for a tool/debugging purpouses i don't see a problem with breaking that
09:40:55 <Beelsebob> Saizan_: right
09:41:10 <Beelsebob> but I wouldn't want it in the Show instance
09:41:21 <plumenator> Python prints this: <function f at 0x7f60d579d5f0>
09:41:24 <Beelsebob> just in whatever tool was doing the debugging etc
09:42:55 <bavardage> Beelsebob: referential transparency is moot
09:42:59 <bavardage> this is not about Show
09:43:09 <Beelsebob> huh?
09:43:11 <bavardage> just as a sane default for gchi
09:43:16 <bavardage> *ghci
09:43:23 <Beelsebob> wut?
09:43:24 <jkff> Who needs referential transparency? instance Eq a where (==) = reallyUnsafePointerEq#
09:43:44 <bavardage> Beelsebob: so, when I'm hacking away in ghci and I forget a :t or something
09:43:54 <bavardage> instead of getting a 5 line exception NO INSTANCE FOR SHOW FOR (
09:44:06 <bavardage> (a->b) -> [a] -> [b]
09:44:17 <bavardage> [... another 5 lines]
09:44:20 <bavardage> I just get the type shown
09:44:27 <Beelsebob> well sure -- but that *is* to do with show
09:44:34 <Beelsebob> because ghci runs print $ your expression
09:44:38 <bavardage> yes ofc
09:44:42 <bavardage> but it can catch the exception
09:44:47 <bavardage> I'm not saying put it into the show instance
09:44:50 <Ferdirand> even if showing functions is questionable, it would be nice if the compiler could derive Show by itself for a record that contains functions
09:44:51 <jkff> bavardage: To my mind, consistency and predictability are way more important than conveniency of certain special cases.
09:44:55 <Beelsebob> having said that, what you asked for there is entirely acceptable as a Show instance
09:44:56 <dolio> You can't get show to produce (a -> b) -> [a] -> [b], though.
09:45:03 <bavardage> I'm not talking about Show :|
09:45:08 <jkff> ghci is consistent in that it always checks the type of an expression if you ask it to evaluate an expression.
09:45:15 * Beelsebob nods
09:45:16 <bavardage> I'm talking about nicer defaults for ghci
09:45:19 <bavardage> hmmm
09:45:23 <bavardage> maybe a command line switch
09:45:28 <jkff> Why the hell should it treat functions specially?
09:45:35 <jkff> T.i. different from other types
09:45:47 <bavardage> because it's ugly
09:45:52 <monochrom> Natural languages emphasize convenice of special cases.
09:45:56 <jkff> Being inconsistent is more ugly
09:46:05 <Beelsebob> indeed
09:46:20 <PeakerWork> Berengal: what is the case you're talking about?
09:46:25 <Beelsebob> personally I value ghci doing the same thing every time I type something in over getting a 1 line error instead of a 5 line one
09:46:37 <bavardage> but it will do the same thing :|
09:46:41 <bavardage> just catch the show failure
09:46:42 <Beelsebob> no it won't
09:46:44 <bavardage> and treat it more nicely
09:46:46 <Berengal> PeakerWork: What?
09:46:48 <Beelsebob> but it's not a show failure
09:46:51 <Beelsebob> show never gets run atm
09:46:56 <PeakerWork> oops
09:46:58 <Beelsebob> no code gets run
09:46:59 <bavardage> 'no instance for show for ...'
09:47:02 <bavardage> oic
09:47:03 <PeakerWork> bavardage: what is the case you're talking about?
09:47:05 <Beelsebob> bavardage: which is a type error
09:47:06 <PeakerWork> Berengal: wrong guy
09:47:09 <Beelsebob> not an excepttion
09:47:11 <Beelsebob> exception*
09:47:18 <jkff> Why should a type checking failure for the Show class should be treated separately from other type checking failures?
09:47:25 <bavardage> fine
09:47:27 * Berengal lost his zone :(
09:47:27 <bavardage> I see your point
09:47:33 <bavardage> it would still be nicer :P
09:47:52 <PeakerWork> bavardage: what would be nicer?
09:47:58 <bavardage> no 5 line error message
09:48:07 <bavardage> but I'm not going to convince anyone, so I concede
09:48:14 <Beelsebob> having said that... something ghci could do nicer....
09:48:21 <Beelsebob> is print a better error message for that type checker failure
09:48:23 <doserj> jkff: because it ia a pure accidental implementation detail that ghci type-checks (show x), when you input x
09:48:29 <Beelsebob> there's no need for it to be 5 lines long
09:48:43 <monochrom> ghci being a REPL kinds of make Show special, it's for the P part. a REL would not need to do this. :)
09:48:50 <bavardage> even just turning it into 'No instance for (Show ((a -> b) -> [a] -> [b]))'
09:49:00 <bavardage> just using only that line for an error message would suffice
09:49:01 <dolio> Actually, maybe I should mention that you probably can get show to produce something like "(a -> b) -> [a] -> [b]", but it involves overlapping and incoherent instances.
09:49:02 <PeakerWork> bavardage: what 5 line error message are you talking about?
09:49:08 <Beelsebob> bavardage: quite
09:49:16 <bavardage> i'll pastebin
09:49:21 <doserj> jkff: ghci already treats values of type IO a differently
09:49:26 <bavardage> http://pastebin.com/m7e4d77bf
09:49:27 <Beelsebob> Peaker: the one you get if you forget an argument and ask ghci to print a function
09:49:29 <bavardage> it's over 5 lines :P
09:49:29 <Beelsebob> > map
09:49:31 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> [a] -> [b])
09:49:31 <lambdabot>    arising...
09:49:50 <gwern> @remember RobertGreaye Some suggest the original English remained in Britain when the North Americas by the British settlers, leaving a pale imitation back in Britain. The truth is much stranger: the original English was actually smuggled out of Britain to the West Indies in a wardrobe
09:49:50 <lambdabot> It is forever etched in my memory.
09:49:57 <PeakerWork> Beelsebob: ah. It could have special case for printing stuff, as it does already special case actions vs non-actions
09:49:59 <gwern> @quote wardrobe
09:49:59 <lambdabot> RobertGreaye says: Some suggest the original English remained in Britain when the North Americas by the British settlers, leaving a pale imitation back in Britain. The truth is much stranger: the
09:50:00 <lambdabot> original English was actually smuggled out of Britain to the West Indies in a wardrobe
09:50:04 <jkff> doserj: The function of REPL is to evaluate and print, which is well-established and consistent across all REPLs for all languages around, so there's not much inconsistency here (although there is some). I also agree about IO: I would not object if for IO I had to tell ghci "runIO ..."
09:50:31 <Beelsebob> Peaker: quite
09:50:48 <jkff> Hm, probably not. runIO would not introduce any consistency
09:50:50 <doserj> the purpose of ghci is to be useful and convenient, not "to be a REPL"
09:50:53 <bavardage> right, off this tangent
09:51:07 <bavardage> what's a better way of doing this?
09:51:08 <bavardage> digits n = map (\c -> read (c:[])) $ show n
09:51:16 <bavardage> oh, digits :: Int -> [Int]
09:51:36 <EvilTerran> ?hoogle digitToInt
09:51:37 <lambdabot> Data.Char digitToInt :: Char -> Int
09:51:45 <bavardage> ooh
09:51:57 <Baughn> > digitToInt 'a'
09:51:58 <lambdabot>   10
09:52:37 <bavardage> so then just digits = map digitToInt . show
09:52:37 <PeakerWork> Beelsebob: ghci could have:  IO a -> execute action and recursively continue with the "a".   Show a => a  -> stringify it and print it.      Otherwise:  Print "Unshowable: <type of value>"
09:52:37 <Berengal> Haskell is a compiled language, ghci is there to aid with the creation of source code. It makes sense to me at least that ghci isn't completely faithful to the language to the benefit of conveniently checking things out
09:53:09 <PeakerWork> this would mean that IO (IO (IO a)) would execute multiple actions though :)
09:54:20 <Berengal> I'd in fact like ghci to partially compile a file despite errors in parts of it
09:54:51 <jkff> I'd like ghci to print the type derivation tree, but probably I wouldn't like reading the output if it did
09:55:16 <dschoepe> Berengal++
09:55:38 <dschoepe> It would be nice if ghci'd just skip out all the functions cause errors and all that depend on them
09:55:44 <dschoepe> *functions that
10:10:48 <plumenator> Why does inserting an element at the end of a list have to be expensive than inserting in the begginning?
10:10:59 <byorgey> plumenator: because lists are singly linked.
10:11:18 <byorgey> plumenator: if you want something that gives you efficient insertion at the beginning or the end, use a different data structure, like Data.Sequence
10:11:30 <plumenator> So, why not make them doubly linked internally?
10:11:57 <Saizan_> because doubly linked list are good structures only with mutation
10:12:12 <p_l> plumenator: also they take additional 4/8 bytes
10:12:23 <RayNbow> with singly linked lists you can share tails
10:12:30 <plumenator> Saizan_: I don't get it.
10:12:56 <PeakerWork> immutable doubly-linked lists with XORed pointers might still be useful for either-dir-iteration maybe? :)
10:13:08 <RayNbow> plumenator: adding an element to an immutable doubly linked list basically involves copying the whole list
10:13:09 <mightybyte> Is there a haskell function other than threadDelay that will allow me to delay with millisecond accuracy?  threadDelay seems to be inaccurate.
10:13:31 <Saizan_> plumenator: if i have let xs = [2..3], now i can make two other lists ys = 1:xs, zs = 0:xs without having to copy xs to maintain its immutability
10:13:45 <SamB> mightybyte: not really quite possible
10:14:09 <mightybyte> SamB: Really?  That seems strange.
10:14:12 <Saizan_> plumenator: if instead those were doubly linked lists, too add an element at the front i'd have to mutate the list referenced by xs, so to keep immutability i'd have to copy it
10:15:52 <SamB> mightybyte: wait a minute, I might be confused
10:16:38 <Saizan_> the OS won't go under a certain accuracy, not sure what the granularity is though
10:17:00 <Saizan_> (also, you're only guaranteed to wait at least that much)
10:17:09 <SamB> oh, and I was thinking of green threading
10:17:15 <plumenator> Saizan_: Oops, I think I meant circularly linked list.
10:17:27 <plumenator> Saizan_: not doubly linked.
10:17:35 <Saizan_> plumenator: same issue though
10:18:19 <plumenator> Form a C perspective the difference I see is that the pointers will be rearranged...
10:18:25 <plumenator> *From
10:19:26 <plumenator> Where as in a singly linked list the existing list gets referred to by a new pointer, that's all.
10:19:37 <Saizan_> exactly
10:19:47 <Saizan_> that's why it works well with immutability
10:20:03 <plumenator> I don't see why that is mutating, though.
10:20:05 <Saizan_> to add an element at the front you don't have to modify the existing list
10:20:18 <SamB> mightybyte: ah, yes, the RTS's schedular is only invoked when a heap check fails
10:20:23 <plumenator> The values are still the same.
10:20:43 <byorgey> with a doubly linked list, the first element "knows" that it is the first element
10:20:57 <byorgey> so if you add a new element on the front you have to change it so it now points to the new first element.
10:21:15 <byorgey> anything which pointed to the beginning of the old list will now be invalid.
10:21:34 <Saizan_> plumenator: try to implement in C a circularily linked list such that after let xs = [1..3]; ys = 1:xs; z = 2:xs; xs is still [1..3] and ys is still [1,1,2,3]
10:21:41 <SamB> the heap check fails when the smallish chunk of memory the RTS had been allocating out of runs out
10:21:47 <mightybyte> SamB: Hmmm, interesting.  Seems like there should be another way to wait.
10:22:11 <SamB> mightybyte: well, personally I was thinking that there ought to be a better way to invoke the schedular
10:22:18 <plumenator> Hmmm, I think I see it now. The user would have to manage all those invalid references.
10:22:41 <SamB> like, a way that allows it to be invoked when the time slice "interrupt" occurred
10:22:49 <byorgey> plumenator: right, or you would have to make a copy of a list before modifying it, so as not to invalidate any references to it.
10:23:07 <SamB> mightybyte: look at http://hackage.haskell.org/trac/ghc/ticket/367
10:23:17 <plumenator> Thanks, guys.
10:23:36 <SamB> I'm trying to keep information about this family of issues findable from there
10:23:39 <byorgey> plumenator: sure, good questions =)
10:24:10 <mightybyte> SamB: Ahh, that's interesting.
10:26:34 <ksf> is "Reduktio ad dementium lectoris" gramatically correct?
10:27:02 <Saizan_> isn't it reductio?
10:27:15 <ksf> dunno, could be
10:27:26 <mightybyte> SamB: I guess to get better resolution you need a busy wait.
10:27:26 <Saizan_> google says so
10:27:36 <ksf> yeah it's c.
10:28:49 <SamB> mightybyte: but what good would that do?
10:31:45 <iago> @src repeat
10:31:45 <lambdabot> repeat x = xs where xs = x : xs
10:32:59 <Arnar> just read HWN and realized I missed this place
10:33:08 <Arnar> you guys are awesome
10:33:10 <Arnar> that's all
10:33:39 <Berengal> Random factoid: "repeat foo" is the list with the smallest memory footprint
10:35:15 <mightybyte> SamB: Well, in the simple little utility that I'm trying to write, if it gives me better resolution then I'm happy.
10:35:47 <SamB> mightybyte: do you actually have more than one thread?
10:36:28 <mightybyte> SamB: no
10:36:45 <SamB> oh, what I said probably doesn't apply then ...
10:37:26 <mightybyte> Well, I was trying to print a line a specified number of times per second.
10:37:55 <mightybyte> So I had a line like "threadDelay (1000000 `div` rate)"
10:38:28 <mightybyte> It worked well for low rates, but couldn't do 1000 per second.
10:39:00 <Axman6> Arnar: you don't need to miss us, come back! ;)
10:39:02 <Berengal> Printing 1line/ms is cutting it close to what's possible
10:39:03 <SamB> oh, if you want to do something like that, you should use a technique that takes into account how much time actually ends up passing
10:39:17 <Berengal> depending on the console...
10:39:36 <mightybyte> SamB: Yes, I thought about that, but I didn't think it was significant enough to warrant the work.
10:39:47 <tommd> You could combine many print commands into a single syscall using a wrapper.
10:39:53 <mightybyte> SamB: Passing a rate of 10,000 gave the same results as passing a rate of 1,000.
10:39:55 <SamB> I think you can do well over that on the straight vanilla Linux console -- no framebuffer
10:40:21 <lilac> mightybyte: is 'repeat "foo"' smaller than even []?
10:40:26 <mightybyte> SamB: Well, I am actually writing to a file.
10:40:30 <SamB> of course, you have to keep it below refresh-rate * 25 or it will be impossible to READ them
10:40:32 <Berengal> loop (nextPrint:rest) = do{ now <- getCurrentTime; threadDelay (nextPrint - now); printLine; loop rest}
10:40:47 <lilac> s/mightybyte/Berengal/
10:40:53 <SamB> mightybyte: what the heck do you want to do something like that for anyway?
10:41:02 <SamB> mightybyte: why not just write dots or something?
10:41:07 <mightybyte> SamB: Rate testing some other software.
10:41:17 <Berengal> lilac: s/list/non-empty list/
10:41:56 <SamB> mightybyte: anyway, you need to keep track of how far off schedule you are, somehow
10:41:59 <Berengal> lilac: And if you've got one [] anywhere in your program, another foo:[] won't take more space than repeat foo
10:42:12 <SamB> if you really want accuracy
10:42:18 <pikhq> I'd imagine that repeat [] would take very little space.
10:42:21 <pikhq> ;)
10:42:26 <Arnar> Axman6: aw.. thanks :) -- diving into another hs project in a couple of days, so I'll be here for sure .9
10:42:26 <mightybyte> SamB: Yes, I understand that, but the fact that there was no difference between 10000 and 1000 suggests that it won't really help.
10:42:37 <SamB> mightybyte: ah
10:42:49 <Berengal> pikhq: Same as []:[]
10:42:50 <SamB> mightybyte: well, how low does your kernel go?
10:43:10 <pikhq> Berengal: Indeed. :)
10:43:16 <mightybyte> SamB: Not sure.
10:43:49 <Berengal> How low does linux go?
10:43:53 <SamB> boy there's a bunch of stuff in my /proc/timer_list ... wonder what it means?
10:44:02 <SamB> Berengal: it varies
10:44:04 <Berengal> I know windows does 20ms by default, but can be turned down to 1ms
10:44:09 <SamB> Berengal: there should be a way to query it
10:44:22 <SamB> if not an actual runtime setting
10:44:55 <mightybyte> SamB: Even when I put a hard-coded "threadDelay 1", it takes 40 seconds to print 1000 lines to a file.
10:44:56 <dons> there's got to be a haskell bomb to drop on this, http://www.reddit.com/r/programming/comments/90s9z/on_the_performance_of_recursive_generator_in/
10:45:02 <dons> Cale: ?
10:45:12 <mightybyte> SamB: When I comment out the threadDelay, it takes 0.017 seconds.
10:45:27 <SamB> mightybyte: anyway, you could round your wait length down to the nearest quantum
10:45:58 <Berengal> My timer_list says min_delta_ns 1000...
10:46:01 <mightybyte> SamB: I doubt that will help.  It appears that threadDelay is not capable of doing what I want.
10:46:03 <SamB> mightybyte: (in addition to tracking how far off schedule you are somehow)
10:46:22 <SamB> mightybyte: is it really that big a deal if you're a few ms early?
10:46:51 <mightybyte> SamB: No, which was the reason I didn't bother checking how far off schedule I was.
10:47:16 <tommd> threadDelay delays in 20 or 50 ms units - I can't recall which.
10:47:22 <mightybyte> SamB: Maybe I'll just try doing yields in a pseudo-busy wait.
10:47:23 <tommd> The ghc documentation says as much.
10:47:54 <tommd> Isn't there an FFI to pselect that will help you delay in more accurate measures of time?
10:47:56 <SamB> well, you have to keep in mind that these sorts of "wait" things are nearly always going to wait a bit longer than you wanted, for one reason or another
10:48:15 <SamB> your program isn't the only one running, after all
10:48:21 <mightybyte> Of course
10:48:33 <tommd> @hoogle pselect
10:48:33 <lambdabot> No results found
10:48:36 <SamB> so you have to live with the fact that you might be behind schedule
10:48:54 <SamB> but at the same time you don't want to get ahead of schedule
10:49:05 <SamB> at least, not more than a little bit
10:49:45 <SamB> ... I guess you could just go for "never ever be ahead of schedule" if the rate is what's important
10:52:43 <plumenator> Does tail call optimization make function composition efficient too?
10:53:31 <pikhq> How could it? There's no tail calls involved in .
10:53:55 <mauke> (.) f g x = f (g x)
10:53:57 <mauke> tail call to f
10:54:15 <pikhq> Sorry, no tail call recursion.
10:54:23 <SamB> plumenator: hmm, too many possibilities are dancing in my head
10:54:24 <copumpkin> it's more general than just self-calls
10:54:29 <SamB> plumenator: have a specific example ?
10:54:47 <Berengal> The answer is: lazy evaluation laughs at your preconceptions
10:54:52 <copumpkin> lol
10:54:56 <SamB> though I guess mauke has it the right answer, really
10:55:21 <SamB> yeah, lazy evaluation does make tail calls a good deal less desirable
10:55:42 <plumenator> Actually it just occured to me that in C we try to reduce the level of function calls to prevent the stack from overflowing.
10:55:43 <dons> that's true enough
10:55:45 <SamB> or, well, tail recursion, anyway
10:55:55 <SamB> since tail recursion has to be done NOW
10:55:57 <plumenator> But in FP we reuse functions all the time.
10:56:02 <copumpkin> but it does allow me to write "moo = putStrLn "moo" >> baa; baa = putStrLn "baa" >> moo" without worrying :P
10:56:04 <dons> well, function composition of fusible functions lets the compiler do some magics
10:56:13 <SamB> plumenator: who the heck does that?
10:56:50 <bavardage> SamB: plumenator
10:56:51 <Berengal> SamB: People who use loops instead of recursion
10:57:02 <SamB> plumenator: when does that even happen, unless you have a recursive (but not tail recursive) traversal algorithm?
10:57:03 <plumenator> SamB: who the heck does what? The C thing or FP thing?
10:57:21 <SamB> plumenator: C thing
10:57:46 <plumenator> Well, don't they?
10:57:47 <SamB> Berengal: well, that's not really so much an attempt to reduce function calls as because C has really crappy HOF support
10:57:50 <plumenator> :-D
10:57:57 <Berengal> It's not as prevailent in C as it is in Java and Python, actually
10:58:11 <SamB> hmm?
10:58:38 <Berengal> C compilers (usually) implement TCO, and C has a stack miles deep anyway, but Java and python do not optimize away tail-calls, and have a stack only about 1000 calls deep
10:58:42 <SamB> I mean, sure you want to keep going crazy with function calls in C, just like in Haskell you usually want to avoid using foldl ...
10:58:54 <SamB> s/keep going/keep from going/
10:59:54 <plumenator> Berengal: What about in embedded systems?
11:00:14 <SamB> Berengal: hmm. you'd think they'd just increase the stack size in the Python case
11:00:20 <Berengal> plumenator: If the compiler takes care of the TCO it doesn't matter
11:00:21 <SamB> it's variable
11:00:36 <SamB> ... it's really just there to keep you from hitting the limits of the C stack
11:00:49 <SamB> (and to catch haywire recursion early)
11:01:08 <plumenator> What if NONE of the function calls are tail calls?
11:01:09 <Berengal> SamB: You would, but that requires the user catching a stack overflow exception
11:01:20 <Berengal> Besides, function calls are expensive in python.
11:01:48 <Berengal> plumenator: Then it'd require stack no matter how you put it
11:02:08 <SamB> Berengal: it's best if you, like ken, don't think about that
11:02:33 <Berengal> SamB: Why use python when you can use haskell anyway?
11:02:33 <plumenator> So is it fair to say that the functional style uses the call stack way more than an imperative style?
11:02:34 <SamB> though unfortunately I can't get dmr to lie to you about it ;-)
11:02:50 <lilac> plumenator: lazy and strict evaluation use the stack in /very/ different ways
11:02:51 <Berengal> plumenator: No
11:02:53 <SamB> plumenator: no
11:03:08 <plumenator> Hmm, I'm confused.
11:03:09 <SamB> plumenator: if you say that, you'll make me hurt my head trying to figure out whether or not you are wrong
11:03:19 <SamB> and that really isn't fair to me
11:03:27 <plumenator> hehe
11:03:47 <plumenator> lilac: Can you elaborate?
11:03:48 <Berengal> plumenator: lazy languages only use the stack to reduce thunks
11:03:48 <SamB> I will say that we are perfectly happy with deep calltrees
11:03:59 <SamB> but the RTS doesn't usually track call trees
11:04:04 <Berengal> if you never create a thunk, you'll never use the stack
11:04:26 <tommd> @tell dcoutts You mention 'Digest Authentication' in hackage-server TODO.  Do you mean use an HMAC or salted hash to replace the 'crypt' call?  This would make it more portable but we would need to consider building an 'htpasswd' like tool if this is your intent.
11:04:27 <lambdabot> Consider it noted.
11:04:27 <SamB> (which is why profiling builds are so handy for debugging in Haskell)
11:05:01 * Berengal wonders what a stack trace would look like in haskell...
11:05:25 <dcoutts> tommd: I mean the HTTP digest authentication as specified in some HTTP RFC somewhere. It's the obvious step up from http basic auth.
11:05:25 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
11:05:39 <Berengal> *stack overflow*: print -> (+1) -> (+1) -> (+1) -> (+1) -> (+1) -> (+1) -> (+1)
11:05:41 <tommd> ok
11:05:47 <SamB> Berengal: a trace of the storage stack would tell you who demanded the value being computed
11:06:12 <dcoutts> tommd: http://en.wikipedia.org/wiki/Http_digest_authentication
11:06:22 * tommd looks
11:06:35 <lilac> plumenator: not in a small number of words ;-)
11:06:50 <plumenator> SamB: what is RTC?
11:07:02 <plumenator> lilac: some other time then. ;)
11:07:06 <tommd> dcoutts: This belongs in happstack.
11:07:09 <SamB> ... and they tend to look pretty ugly since GHC assigns unreadable names to the actual pieces of code ...
11:07:15 <tommd> dcoutts: Would that be agreeable to you?
11:07:24 <dcoutts> tommd: certainly
11:07:45 <SamB> plumenator: RTS. (did I say RTC?) It stands for Run Time System.
11:07:57 <plumenator> Okay
11:08:00 <tommd> dcoutts: Good, because I've been considering a hackathon and one of the guys would would help wants to make it happstack centric.
11:08:26 <tommd> This might end up being one of the tasks.
11:08:29 <SamB> Often (slightly ab)used to mean the execution model
11:08:31 <lilac> plumenator: (attempt at a short explanation): strict languages use the stack to manage the state of the computation creating a value, lazy languages use the stack to manage the state of the computation demanding a value
11:08:54 <dcoutts> tommd: great, similarly I think we made some improvements to the basic auth component that could be merged back into happstack
11:09:20 <plumenator> lilac: so my statement would be true for strict languages, then?
11:09:21 <tommd> I noticed one function was generalized a bit (not sure what the code in happstack looks like right now)
11:09:30 <tommd> I'll point it out to creighton.
11:09:42 <lilac> plumenator: that a functional style would use a deeper stack than an imperative style?
11:09:44 <Berengal> http://www.haskell.org/haskellwiki/Stack_overflow
11:09:48 <plumenator> yes
11:10:09 <SamB> plumenator: since the language-level call tree is irrelevant to actually computing the value, it isn't tracked in the normal execution model
11:10:10 <Berengal> Strict functional languages are usually written in a tail-recursive way
11:10:48 <SamB> but of course it's rather important for profiling, so it is tracked there
11:11:17 <lilac> plumenator: i wouldn't like to generalize, but i'd guess that strict functional programs tend to use more HOFs and the like, and avoid loops in favour of recursion, so probably have a deeper notional call stack (but many of those calls will be tail-calls)
11:12:01 <SamB> (though it's actually just tracked by passing around a stack of "cost centers" -- the profiling output is the only place to get the actual tree ;-)
11:12:25 <SamB> lilac: they don't avoid loops
11:12:43 <SamB> they just express them differently from C programmers
11:13:21 <lilac> SamB: that sounds more like a difference in definition of 'loop' than a disagreement?
11:14:31 <SamB> lilac: between me and who ?
11:14:36 <lilac> SamB: between you and me :)
11:15:29 <SamB> do you much prefer yours?
11:16:05 <lilac> i consider a definition of 'loop' which excludes tail recursion to be more common, so yes
11:16:33 <SamB> you like common things, eh?
11:16:58 <lilac> i like effective communication
11:18:12 <bgs100> > map toUpper "Hello, there"
11:18:14 <lambdabot>   "HELLO, THERE"
11:18:38 <SamB> how about we call those "mundane loops" or "explicit loop constructs" or something?
11:19:18 <Elly> I am not clear on the difference really
11:19:53 <SamB> yeah ... what is the difference again?
11:19:54 <lilac> ok. so to restate: functional programs (and languages) have a tendency to use implicit loop constructs such as recursion in favour of explicit loop constructs, resulting in a deeper notional call stack
11:20:46 <SamB> yeah
11:21:01 <SamB> usually via HOFs
11:21:48 <dons> well, they provide cheap function calls, and no penalty for tail recusion, so they certainly encourage recursive definitions.
11:21:48 <lilac> (however, decent implementations often transform implicit loop constructs into explicit loop constructs in some lower level language)
11:21:50 <SamB> ... but don'HOFs
11:21:55 <SamB> er. oops.
11:22:07 <SamB> ... but don't the HOFs make the recursion just an implementation detail?
11:22:29 <dons> named recursive forms have the advantage of being subject to inter-loop optimizations, such as fusion, without prior analysis, which is nice.
11:22:38 <lilac> SamB: that's rather the point of HOFs, i'd say. it doesn't matter how the recursion happens
11:22:48 <SamB> lilac: or that it's recursion
11:22:59 <lilac> SamB: yeah, typo/thinko ;-)
11:23:36 <SamB> for all you care, it's actually implemented using some "wierd explicit loop" construct -- it doesn't make an iota of difference as long as it does what it's supposed to do
11:23:54 <SamB> hmm.
11:24:03 <SamB> dunno why I put wierd in the quotes ...
11:24:27 <lilac> SamB: right. for all i care, foldr is a compiler primitive which means 'loop'
11:26:30 <SamB> hmm, if you had said foldl' it would have been less confusing ;-)
11:27:23 * SamB must be trying to think on too many levels at a time again...
11:32:03 <monochrom> Heh "notional stack". "notion" being as in "a notion in your mind [only]", "notional stack" = stack space in your mind needed to understand the recursive function? :)
11:33:13 <SamB> monochrom: I think he meant more along the lines of Python-equivalent
11:34:11 <SamB> Python being notorious for not doing TCO only because it would interfere with tracebacks
11:34:20 <elbar> pssst....dont mention his name, he is picky about that ;)
11:34:42 <endojelly> by the way, why is a simple string/list split by predicate or by equalness with an element not part of the standard library?
11:34:46 <endojelly> there's one for ByteStrings
11:34:52 <endojelly> splitBy :: (a -> Bool) -> [a] -> [[a]]
11:34:53 <endojelly> splitBy p = unfoldr split1
11:34:53 <endojelly>     where split1 [] = Nothing
11:34:53 <endojelly>           split1 line = let portion = takeWhile (not . p) line
11:34:53 <endojelly>                         in Just (portion, drop (length portion+1) line)
11:35:04 <endojelly> it's easy and used often enough
11:35:07 <travisbrady> SamB: what is TCO?
11:35:14 <dschoepe> endojelly: There's Data.List.Split
11:35:22 <dschoepe> (separate package)
11:35:24 <endojelly> dschoepe, there is? didn't know that, let me check
11:35:35 <SamB> travisbrady: tail call optimization
11:35:41 <endojelly> dschoepe, ah, so it's not part of the standard library?
11:36:02 <dschoepe> endojelly: the problem is that no one can agree on which of the many split variants is the "right one".
11:36:21 <endojelly> dschoepe, by API or by implementation?
11:36:41 <Saizan_> endojelly: API
11:36:46 <dschoepe> endojelly: http://haskell.org/haskellwiki/Data.List.Split
11:36:46 <travisbrady> SamB: ahh, thank you
11:36:57 <monochrom> Soon enough some people will demand split-by-substrings, splitBy :: ([a] -> Bool) -> [a] -> [[a]].
11:37:26 <endojelly> I seriously suggest deciding that, one way or the other, because not having a simple string/list split in the standard library is really embarrassing
11:37:28 <monochrom> Then after a while people will re-discover split-by-regex.
11:37:53 <monochrom> Alas, split-by-regex already exists, people will run out of new demands.
11:38:07 <bavardage> splitByRandomChance
11:38:08 * bavardage wants
11:38:15 <bavardage> you specify the probability of splitting
11:38:18 <bavardage> it may never split!
11:38:22 <endojelly> is there a problem in having split by element predicate and split by sublist predicate in e.g. Data.List and regex split in a regex package?
11:38:37 <MyCatVerbs> splitWishBone
11:39:35 <endojelly> and if someone really wants "split if the sum of the first half of left to and second half of right to the split is a prime number", THEN they may implement it themselves
11:39:57 <endojelly> but a simple character/substring or element/sublist split should reaaaally be there
11:40:29 <endojelly> I mean, come on.
11:41:27 <endojelly> (okay, I definitely spent a lot more time ranting about it than just using the implementation I just wrote in my program %) )
11:41:35 <monochrom> You should bring your fervor to the libraries mailing list.
11:42:00 <endojelly> I will if I think about it
11:42:16 <endojelly> plus, there's not even the "then implement it" argument, because apparently it is implemented
11:42:30 <Axman6> there's a list splitting package
11:43:08 <Saizan_> endojelly: right, make a proposal to libraries@haskell.org and put the effort to make it accepted :)
11:43:08 <endojelly> "yeah, here's a 10 lines program that does what you want, but oh, you have to install that package because at some point it's splitting a string into 3 parts."
11:43:25 <endojelly> Saizan_, yup, will do 8) (not today, however)
11:43:36 <Axman6> do you have a problem with packages?
11:44:23 <tommd> Sometimes, yes.  I have several modules with more lines of import statements than code.
11:44:48 <endojelly> Axman6, don't want to continue this further, because I'll just bring it to the mailing list, but let me restate: it's far too elemental to be part of an *extra* package. I'm not even sure if it shouldn't be part of the prelude.
11:45:03 <monochrom> My father likes to voice his oh-so-makes-sense opinion at the dining table. He never voices it to the elected official who should hear it.
11:45:19 <endojelly> monochrom, hint accepted 8)
11:45:37 <monochrom> Democracy does not work if everyone confined their opinion to the dining table.
11:45:37 <Axman6> haskell isn't a string processing language, which is the sort of language you'd find a thing like this there by default
11:46:19 <monochrom> No, don't take this as directed at you, endojelly. I just want to rant about my father.
11:46:35 <endojelly> Axman6, no seriously. splitting a list in its simplest form. 5 short lines of code, at most. you'll find much much more complicated things in the standard library.
11:46:36 <tommd> Most people do
11:49:33 <Twey> @src atan
11:49:34 <lambdabot> Source not found. My mind is going. I can feel it.
11:50:36 <Axman6> endojelly: you may think it's an elemental function, others may not, and it seems the designers of the language didn't. luckily, making packages, even small ones, is painless with things like hackage around.
11:50:59 <Axman6> and most people have no problem installing packages for things they need.
11:52:16 <monochrom> A lot of things got added to Data.List after lobbying. The Data.List you look at now is bigger than the one just 3 years ago.
11:56:09 <Berengal> In polyparse, is the "atomic" parser 'satisfy'?
12:16:11 <coreyoconnor> atomic parser?
12:16:21 <coreyoconnor> I've never used polyparse
12:16:35 <coreyoconnor> Is that the parser that is satisfied by any arbitrary atom?
12:16:59 <coreyoconnor> a single arbitrary atom
12:17:59 <quicksilver> I would guess it merely means a parser which is not expressed as the composition of other parsers
12:18:02 <quicksilver> but, that would be a guess.
12:21:25 <Berengal> Basically
12:21:41 <maltem_> I'd understand it as such. The two obvious choices for an atomic parser are satisfy or char
12:21:42 <Berengal> I mean, given char and a few combinators I can build any string parser I want
12:22:01 <Berengal> I couldn't find char, I guess it's one of the modules with human names...
12:22:10 <coreyoconnor> the PolyParse typeclass has oneOf' as a method
12:22:32 <dschoepe> How do I implement the following in reactive: I want to switch behaviors as soon as a value of type Behavior Bool turns True?
12:22:50 <coreyoconnor> which has a type that appears to take an array of (String, parser) pairs
12:23:19 <coreyoconnor> I suspect that all higher level abstractions are built off of that
12:38:51 <Cale> dschoepe: That is conceptually hard, because behaviours are functions of time. You can take something like a timer event and snapshot the behaviour on it, and then switch on that.
12:39:18 <copumpkin> does anyone in here have an email address for wli?
12:39:28 <hackagebot> ApplePush 0.1 - Library for Apple Push Notification Service (ChrisMoos)
12:39:30 <Cale> (but that might miss the first instance where the behaviour becomes True)
12:52:58 <malcolmw_> Berengal: the most basic parser in polyparse is really 'next', but 'satisfy' is pretty close to being the most basic too
12:53:56 <Berengal> malcolmw_: next being satisfy (const True)
12:54:28 <Berengal> Anyway, I think i'm starting to figure this out
12:55:00 <malcolmw_> Berengal: and satisfy p = next >>= \x -> if p x then x else reparse [x]
12:55:26 <Berengal> Indeed
12:57:25 <Berengal> Wait, no, that one can't return a value
12:58:10 <dschoepe> Cale: Hmm, do you have a another suggestion for implementing something like this: I want an object to rotate until it reaches a certain angle. I tried calculating the needed time for that in advance and used it with atTime but there might be other transformations where that is not possible.
13:01:41 <Cale> dschoepe: hmm... I suspect that as things get complicated, that's all you can do.
13:02:35 <Cale> dschoepe: In general you might want some kind of root-finding on behaviours which you know to be continuous, but I don't know how to do that (or if it's even possible)
13:03:49 <dschoepe> Hmm, I also encountered some timing problems with the pre-calculation approach, when using many objects, so I am looking for a way to get around that.
13:28:42 <portnov> @index MonadIO
13:28:43 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:42:37 <mauke> > abs minBound
13:42:39 <lambdabot>   Add a type signature
13:42:41 <mauke> > abs minBound :: Int
13:42:43 <lambdabot>   -9223372036854775808
13:43:05 <RayNbow> @seen Cale
13:43:06 <lambdabot> Cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard Cale speak 40m 30s ago.
13:43:55 <Cale> I'm here
13:43:59 <RayNbow> \o/
13:44:08 <monochrom> What is \o/?
13:44:13 <mauke> "yay"
13:44:19 <RayNbow> hands/arms in the air
13:44:46 <RayNbow> so it conveys the same meaning as what mauke said
13:45:17 <RayNbow> Cale: I'm kinda stuck on "bijective homomorphisms" between non-isomorphic posets
13:45:32 <RayNbow> FunctorSalad tried to help me, but it was kinda late last night :p
13:46:12 <Cale> okay
13:46:34 <monochrom> Like this? Let {x,y} use the flat order, {0,1} use the number order "<=", then bijective homomorphism from {x,y} to {0,1}.
13:47:19 <RayNbow> flat order?
13:47:23 <monochrom> (Silly witticism: It takes two elements to order. :) )
13:47:25 <Cale> Right. In order to be an isomorphism, it would have to have an inverse which was also a homomorphism, but the inverse is not.
13:47:34 <monochrom> Flat order means x,y incomparable.
13:48:10 <monochrom> I design it so "forall a,b. a<=b => f(a)<=f(b)" is vacuously true.
13:48:47 <monochrom> because a<=b almost never happens in {x,y} with the flat order.
13:49:15 <Cale> x <= x ;)
13:49:38 <Cale> (but thankfully, f(x) <= f(x) as well)
13:50:05 <monochrom> This is a smallest possible example because single-element posets don't break isomorphism.
13:50:26 * monochrom <3 smallest examples.
13:50:53 <RayNbow> hmm...
13:52:33 <RayNbow> a bijective homomorphism f from P={x,y} to Q={0,1} is f(x) = 0, f(y) = 1?
13:52:43 <monochrom> Yes.
13:53:19 * Elly wouldn't know a homomorphism if it fell on her :(
13:53:21 <RayNbow> ah right... I now really get what's written on page 6 of Awodey's book
13:53:28 <Elly> my category-theory chops are severely lacking
13:54:41 <RayNbow> "that is monotone, in the sense that for all a, a' in A,       a <=_A a'   implies    m(a) <=_B m(a')."
13:55:11 <RayNbow> but that definition doesn't say anything about unrelated as in A, since we don't care then :)
13:55:35 <monochrom> Vacuous implications are the best things since sliced bread.
13:56:09 <RayNbow> monochrom, Cale, thanks :)
13:56:38 <Cale> Elly: It means different things in different context. When talking about (partially) ordered sets, a homomorphism is a function from one set to the other which preserves the ordering of things: if x <= y then f(x) <= f(y).
13:56:42 <Cale> contexts*
13:56:55 <Elly> oh
13:57:03 <Elly> I've seen those in set theory, but they were called something else
13:57:23 <Cale> monotone functions?
13:57:56 <Cale> In general, 'homomorphism' is just a term for a function which preserves some kind of structure.
13:57:57 <Elly> order-preserving mappings, I think
13:59:00 <monochrom> Like "law-abiding citizen" depends on which country you talk about in the context. :)
13:59:03 <RayNbow> @karma Cale
13:59:04 <lambdabot> Cale has a karma of 19
13:59:09 <Cale> For example, if you have two rings, with 0, 1, negation, + and *, you'll want a homomorphism to have f(0) = 0, f(1) = 1, f(-x) = -f(x), f(x + y) = f(x) + f(y) and f(x*y) = f(x)*f(y)
13:59:18 <maxote> maxote++
13:59:19 * Elly -> home
13:59:30 <RayNbow> Cale++  -- not that this useful, since lambdabot keeps forgetting :p
13:59:34 <RayNbow> @karma Cale
13:59:34 <lambdabot> Cale has a karma of 20
13:59:42 <Cale> heh
13:59:57 <maxote> let's us to do ++ each other
14:00:14 <RayNbow> monochrom++
14:00:17 <RayNbow> @karma monochrom
14:00:18 <lambdabot> monochrom has a karma of 3
14:00:25 <maxote> RayNbow++
14:00:25 <RayNbow> monochrom has a long way to go :p
14:00:34 <monochrom> Verily forgetful @karma
14:00:35 <RayNbow> my karma's probably 1 now :P
14:01:01 <monochrom> It was near 10 some years ago.
14:01:15 <drhodes> allocating a karma point should detract from somewhere else,  isn't it conserved?
14:01:36 <monochrom> No, it's like money, always produced never conserved.
14:01:59 <drhodes> I see, like inflation.
14:02:03 <monochrom> Or you could say "it all comes from the sun" so I guess yeah, it's conserved, taken from the sun.
14:03:12 <monochrom> The sun gives you food, you eat food then bang on keyboard in #haskell, get more karma.
14:04:06 <monochrom> #haskell is a channel that converts solar energy to karma.
14:04:09 <inimino> @karma sun
14:04:09 <lambdabot> sun has a karma of 0
14:04:13 <inimino> so much for that theory
14:04:21 <Berengal> @karma
14:04:21 <lambdabot> You have a karma of 2
14:05:10 <monochrom> inimino that's as misunderstanding as asking "how much print money does the sun possess?"
14:05:49 <inimino> ah, but print money isn't conserved either
14:06:09 <monochrom> The sun gives you fuel and trees, you use those to print money notes. You convert solar energy to money, but the sun will still get none of it.
14:06:23 <benmachine> sun++
14:06:51 <RayNbow> @karma ++
14:06:52 <lambdabot> ++ has a karma of 3
14:06:59 <RayNbow> ++++
14:06:59 <benmachine> hah
14:07:01 <RayNbow> @karma ++
14:07:02 <lambdabot> ++ has a karma of 4
14:07:13 <monochrom> Well my point is you ask "@money sun" and the answer is still 0, and this still doesn't invalidate my theory!
14:07:34 <benmachine> not all our energy comes from the sun
14:07:56 <benmachine> not that this is particularly relevant
14:11:14 <Berengal> Can TH do IO?
14:11:25 <monochrom> Yes!
14:11:27 <thoughtpolice> i think so, yes
14:12:28 <monochrom> I used to go around exhalting "w00t you can use TH to make the compiler play an MP3 file while you wait for the build!"
14:12:40 <RayNbow> @where+ typeclassopedia Byorgey's Typeclassopedia in <http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf>
14:12:41 <lambdabot> It is forever etched in my memory.
14:12:45 <RayNbow> @where typeclassopedia
14:12:46 <lambdabot> Byorgey's Typeclassopedia in <http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf>
14:13:30 <monochrom> "You have chosen to build GHC. This will take about 2 hours. Please enjoy the following complimentary movie while you wait."
14:14:56 <Berengal> monochrom: I've had similar ideas
14:15:17 <Berengal> But weren't sure if I could actually implement them
14:16:15 <monochrom> If you included the movie in the source tarball, it would be huge.
14:17:19 <Berengal> Meh, source code is small compared to data. I figure, if you want a big program you should download a big tar to get it ;)
14:18:08 <Berengal> Would be a nifty package to start the Acme hierarchy with
14:23:47 <stulli> Im trying Haskell cgi-scripts but the output looks not well formatted. Is this normal? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6941#a6941
14:24:59 <hackagebot> BerkeleyDB 0.7.2 - Berkeley DB binding (StephenBlackheath)
14:25:02 <mauke> does it validate?
14:26:43 <stulli> Line 4, Column 3: document type does not allow element "body" here
14:26:55 <mauke> ok, missing <head> tag
14:27:16 <jmcarthur_work> ugh, ropes and finger trees seem to be uncommon in c++
14:27:30 <jmcarthur_work> in fact, i can't find a *single* use of finger trees in c++ on the internet
14:27:39 <jmcarthur_work> ropes have some implementations
14:30:32 <monochrom> c++ has fast and easy arrays. people have little incentive to use anything else in fact.
14:31:11 <jmcarthur_work> not so good for concatenation and splitting, though
14:31:33 <jmcarthur_work> besides the common policy to double or halve the allocated array size occasionally
14:31:42 <jmcarthur_work> but that just sucks
14:32:07 <jmcarthur_work> and for concatenation that can mean some pretty bad copying
14:32:33 <monochrom> I know programmers who don't care to implement another data structure and just use arrays throughout, including inserting something at the middle of an array.
14:32:40 <jmcarthur_work> yeah i know :(
14:33:17 <pikhq> monochrom: That is so rarely a good idea.
14:33:26 <jmcarthur_work> and i know i might likely be scolded for wasting time with some obscure data structure at work, too
14:33:51 <pikhq> Especially given that C++ has useful data structures in its standard library...
14:34:12 <jmcarthur_work> a few
14:34:17 <MyCatVerbs> jmcarthur_work: what's wrong with doubling array sizes while growing them? It gets you amortized O(1) append if you're using them as lists.
14:34:47 <jmcarthur_work> MyCatVerbs, this isn't just growing them though. if that was all i was doing, a deque would be perfect
14:35:02 <jmcarthur_work> concat /= append
14:35:35 <MyCatVerbs> jmcarthur_work: gah. Would anyone actually be crazy enough to do naïve concat that way?
14:35:50 <MyCatVerbs> No, hang on, that's fine too depending on a few details.
14:36:10 <jmcarthur_work> i could have O(1) concat with a nicer structure, but i get O(n) concat with deques and stuff, since i have to add one element at a time
14:36:17 <MyCatVerbs> If you want to destructively concat two arrays into one of them, realloc()ing to double the array size still gets you amortized O(n).
14:37:06 <MyCatVerbs> (Well, destroying the array that you concat into, anyway.)
14:37:36 <stulli> mauke: I added a header but it still doesnt validate. I added the output and Haskell code to hpaste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6941#a6943
14:37:37 <jmcarthur_work> well, that's the complexity even if it wasn't destructive
14:38:15 <MyCatVerbs> Jah. What do you need O(1) concatenation for, anyways?
14:38:56 <jmcarthur_work> dont' need it. optimization detail. i was just reaching for my usual tools, but they don't exist in this c++ world :\
14:40:09 <jmcarthur_work> and they say idiomatic haskell is slow...
14:40:30 <Berengal> stulli: You can't put a body inside a head...
14:41:00 <stulli> argh, thats whats happens when you do things in a rush...
14:41:55 <MyCatVerbs> Berengal: you can swallow minnows whole.
14:42:57 <drhodes> cruelty to animals!
14:43:11 <Berengal> <html><swallow><head><body><nom><nom><nom></nom></nom></nom></body></head></html>
14:44:48 <Peaker> such a horrible format has been forced upon the world
14:45:22 * Berengal is working on/planning on working on writing a sexpr→xml converter, to help ease the burder
14:45:29 <Berengal> burden
14:45:58 <Peaker> can't do the way back, because XML isn't just a tree, its a tree with multiple leaf types
14:46:16 <Peaker> or 1 node type (elements) and 2 leaf types (text, attributes)
14:46:18 <Cale> jmcarthur_work: Finger trees are a very new datastructure and they were in Haskell first.
14:46:22 <monochrom> (html ... (body (p "hello how are you?"))) ?
14:46:53 <monochrom> Ah attribute is a problem.
14:46:54 <Cale> jmcarthur_work: The paper introducing finger trees is from 2006. :)
14:47:14 <Cale> Attributes are stupid anyway.
14:47:15 <drhodes> there may be a way out: http://yaml.github.com/yaml-spec/
14:47:21 <monochrom> (html ... (body &onload="go()" (p "hello how are you?"))) ?
14:47:36 <Berengal> Peaker: Sure you can. (elem-name ((attr . val) (another-attr . another-val)) (child-elem ((foo . bar))) auto-closed-elem)
14:47:43 <Gracenotes> monochrom: HTLISP?
14:47:54 <monochrom> HTSEXP
14:47:56 <Cale> (body (&onload "go()") (p ...))
14:48:03 <\stro> hi
14:48:14 <\stro> I'm having some trouble with HXT picklers and xml ns
14:48:26 <Gracenotes> ah indeed... no particularly lispy things going on..
14:48:26 <Cale> hi
14:48:27 <\stro> any idea how I can handle them in picklers?
14:48:53 <\stro> in particular, I'm getting fully namespace-aware NTrees from Network.Protocol.XMPP
14:49:42 <Berengal> sexprs are more expressive than xml. You can't convert all sexprs to xml unless it's an xml designed to describe sexprs
14:50:24 <Cale> \stro: Isn't the HXT XmlTree datatype namespace aware to begin with?
14:50:31 <\stro> Cale: indeed
14:50:31 <Berengal> Anyway, I need a name for my converter library. I first thought of 'sexml', but then figured it might be misunderstood
14:50:36 <Berengal> On the other hand...
14:50:42 <\stro> but no xmlns traces in the pickler api
14:52:12 <monochrom> "sexprs are more expressive than xml" is just the Gödel-numbering tarpit.
14:52:57 <\stro> from reading the Network.Protocol.XMPP source, I'm now getting some ideas...
14:52:58 <jmcarthur_work> SexML
14:53:00 <Gracenotes> "expressive" is subjective! involving tarpits is totally a jerk move!
14:53:16 <monochrom> What do you suggest instead? Armpits?
14:53:44 <monochrom> Gödel's armpits are more consistent than you!
14:54:06 <maxote> is there anyone how to work the modern engine of the abstract machines of lazy functional languages? is it G-machine or is there another succesor with little improvements?
14:54:24 <Gracenotes> monochrom: I suppose that means that they have less repelling power
14:54:30 <monochrom> hehehe
15:12:18 <tew88> Is there somewhere I'm able to view the source for standard library functionality?
15:13:23 <Zao> Hoogle?
15:13:46 <Plouj-> if I want to use the glGenBuffers function like: glGenBuffers :: GLsizei -> Ptr GLuint -> IO ()
15:14:00 <Plouj-> how would I generate a Ptr GLuint type of thing to pass to it?
15:14:10 <\stro> Cale: in case you're still interested, I needed xpElemQN with Network.Protocol.XMPP.Util.mkQName
15:14:45 <sjanssen> @docs
15:14:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:15:04 <sjanssen> tew88: the docs for each function there have 'source' links
15:16:28 <tew88> Zao, sjanssen: Thanks. Got it.
15:20:21 <sgillespie> hello everyone
15:20:53 <sgillespie> I hope someone can help
15:20:59 <ColeSOAR> hi sgillespie
15:21:09 <sgillespie> lets say I start a ghci session
15:21:12 <sgillespie> I start with this
15:21:12 <ColeSOAR> I can't help.  I suck.
15:21:24 <sgillespie> let t = forkIO $ return ()
15:21:27 <Cale> okay
15:21:41 <sgillespie> now, t doesn't get evaluated until i try to print it or something
15:21:54 <sgillespie> thats okay
15:22:05 <Cale> Even if you were to evaluate t, it wouldn't execute it. You need to execute t in order to fork the new thread.
15:22:38 <Saizan> though evalutation and execution are a bit blurred at the prompt
15:22:43 <Cale> right
15:22:43 <sgillespie> repeated calls to t will fork a new thread each time
15:23:07 <Saizan> right
15:23:09 <sgillespie> but if i evaluate the special name it, it gives me the same ThreadId
15:23:10 <Cale> yep, t is equal to forking a new thread which immediately finishes
15:23:35 <Cale> Giving ghci an IO expression causes it to execute it.
15:23:41 <sgillespie> What if I want to just look at the result (namely the ThreadId)
15:23:46 <sgillespie> without executing it again
15:23:55 <Lemmih> sgillespie: t <- forkIO $ return ()
15:24:05 <Cale> Then you need to have kept that result somewhere
15:24:23 <sgillespie> interesting
15:24:36 <Saizan> with Lemmih's code 't' won't be an IO action that forks a thread, but the ThreadId returned by forking a thread
15:24:55 <Cale> Or, with your original  let t = forkIO $ return ()  you could use  v <- t
15:25:05 <Cale> which amounts to the same thing
15:25:13 <sgillespie> so then t is the action, v is the resut
15:25:18 <Cale> right
15:25:27 <sgillespie> hmm
15:25:29 <Cale> v <- t  means "run the action t, and name its result v"
15:25:44 <Cale> Normally, that would go on the inside of a do-block
15:25:55 <Cale> and the whole do-block itself would describe an action
15:26:02 <sgillespie> I don't understand how that works in ghci as if i'm inside a do block
15:26:27 <Cale> You mean, how ghci itself is written?
15:27:18 <sgillespie> I guess so, normally you think of do blocks getting transformed into >>=s and >>'s
15:27:26 <Cale> ghci explicitly parses that syntax, evaluates and then executes the action, and binds the variable
15:27:44 <sgillespie> ahh
15:27:46 <sgillespie> I see
15:28:26 <sgillespie> So out of curiousity, is there a way to bind the result instead of the action without using do?
15:29:01 <Cale> no
15:29:56 <Cale> Because in order to get the result, you have to execute the action, and evaluation is supposed to be pure and deterministic, so it can't depend on that.
15:30:22 <sgillespie> I see
15:30:33 <Cale> Well, there is technically a way to cheat, but it's not recommended that you ever do it.
15:31:01 <Cale> (and if you were to do it, you'd want to be certain that you don't care how many times the action gets run)
15:31:08 <Zao> unsafeShootOffLimbs
15:31:48 <Badger> unsafeShootOffLimbs :: IO Limbs -> Maybe Limbs
15:31:51 <Cale> Yeah, unsafePerformIO is the way to cheat, but you want to treat that with the same sort of gravity as modifying the compiler.
15:37:52 <Berengal> There wouldn't happen to be any soap packages around, would there?
15:38:37 <copumpkin> Berengal: I have a couple under my sink but it'd take a while to ship
15:38:54 <copumpkin> you're better off getting a pack from the local store
15:39:03 <Berengal> It's closed :(
15:39:38 <blackh> Berengal: I thought there was one. But maybe I was thinking of XML-RPC (the HaXR package).
15:56:47 <bavardage> HALP!
15:56:53 <bavardage> I'm trying to compile a program which uses parsec
15:56:55 <bavardage> it goes boom
15:56:56 <bavardage> undefined reference to `parsec
15:56:58 <bavardage> I get lots of this
15:57:09 <aavogt> compile with --make!
15:57:10 <bavardage> (.data+0x470): undefined reference to `parseczm2zi1zi0zi1_TextziParserCombinatorsziParsecziChar_a80_closure'
15:57:14 <bavardage> haha kk :D
15:57:22 <aavogt> ghc --make blech.hs
15:57:23 <bavardage> hah thanks
15:57:25 <bavardage> much better
15:57:31 <aavogt> no problem
16:05:50 <tromp> > 2^49
16:05:52 <lambdabot>   562949953421312
16:17:22 <sgillespie> why is it that nmap reports that a port is open after I call sClose sock?
16:18:16 <MyCatVerbs> Did you close the socket that you used bind() and listen() on, or the socket that you accept()ed from that one?
16:18:47 <sgillespie> I used listen from Network
16:19:00 <sgillespie> I mean, I closed the socket from Network.listen
16:19:19 <sgillespie> actually listenOn
16:20:08 <MyCatVerbs> Hrmn, strange. I don't know offhand, sorry.
16:25:11 <Plouj-> how do I construct a Ptr to a GLuit?
16:25:27 <Plouj-> in fact, how do I find what the possible constructors for Ptr are in this documentation: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html ?
16:28:12 <MyCatVerbs> Plouj-: you can get a Ptr to anything for which there is a Storable instance.
16:28:25 <benmachine> I downloaded and compiled frag and it immediately segfaulted
16:28:55 * benmachine ho hums
16:29:05 <mike-burns> benmachine: I think that means you immediately won the game.
16:29:22 <MyCatVerbs> Plouj-: you want to look up Foreign.Storable, and some of the functions in Foreign.Marshal (probably Foreign.Marshal.Alloc in particular).
16:29:32 <benmachine> superb.
16:29:38 <Plouj-> ugh
16:30:08 <Plouj-> MyCatVerbs: is that what I have to do when I want to call "glGenBuffers :: GLsizei -> Ptr GLuint -> IO ()" ?
16:30:11 <MyCatVerbs> You use the (Storable a) instance to peek and poke at (Ptr a)s.
16:30:47 <Plouj-> I need to pass a pointer to a GLuint to store the value of a generated buffer id.
16:30:55 <Plouj-> (according to the opengl api)
16:31:21 <MyCatVerbs> Yeah, sounds about right. BTW the easy way to get at arrays of primitives in both Haskell and C is to use Data.Array.Storable.
16:31:49 <eu-prleu-peupeu> hmm
16:32:47 <Plouj-> humm, I don't know how I would do that though
16:33:05 <Plouj-> in terms of writing the actual code
16:33:18 <MyCatVerbs> That way would give you something like, do { ra <- newArray (0,1023) 0; withStorableArray ra (\ptr -> glGenBuffers 1024 ptr); }
16:34:00 <MyCatVerbs> (the semicolons and {} get inserted for you by the layout rules when you indent your code, of course)
16:34:19 <Teja> Axeman6: Hello
16:34:25 <MyCatVerbs> (And by "of course", I actually mean "isn't that nifty?". Yes, yes it is.)
16:34:45 <Teja> Axman6: Hello
16:35:33 <Teja> need some help understanding a program, can you please help me
16:35:35 <MyCatVerbs> Plouj-: does that help any?
16:35:41 <Teja> can anybody help me?
16:35:54 <MyCatVerbs> Mellow greetings, Teja. What is your boggle?
16:35:56 <mike-burns> Teja: Post the code.
16:36:06 <MyCatVerbs> @where hpaste
16:36:07 <lambdabot> http://hpaste.org/
16:36:20 <Teja> mike-burns: http://book.realworldhaskell.org/read/functional-programming.html
16:36:41 <Teja> on exercises section, for exercise 2
16:37:00 <Teja> I want to write program for this
16:37:00 <Teja> splitWith :: (a -> Bool) -> [a] -> [[a]]
16:37:38 <Teja> I tried myself and tried understanding the programs there... but I am unable to understand properly
16:37:51 <Teja> can you plz help me?
16:37:59 <mike-burns> Sure can.
16:38:07 <MyCatVerbs> Teja: Ah. That is not too difficult once you understand passing functions.
16:38:13 <Plouj-> MyCatVerbs: wait a second, glGenBuffers maybe is supposed to "return" the pointer to me
16:38:20 <eu-prleu-peupeu> have you guys read that rant from that lisp zealot about haskell being bad ?
16:38:37 <Plouj-> MyCatVerbs: so maybe I have to do something like bufferID < glGenBuffers 1024
16:38:46 <Plouj-> erm, bufferID <- glGenBuffers 1024
16:38:54 <Teja> MyCatVerbs: any guidence will be greatly appreciated :-)
16:38:58 <MyCatVerbs> eu-prleu-peupeu: you mean all of them?
16:39:00 <mike-burns> Teja: So you know the type already. It might be useful to also have an example.
16:39:07 <MyCatVerbs> So let's start out with words' source.
16:39:10 <MyCatVerbs> @src words
16:39:11 <lambdabot> words s = case dropWhile isSpace s of
16:39:11 <lambdabot>     "" -> []
16:39:11 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:39:28 <Teja> ok
16:39:39 <MyCatVerbs> Notice the predicate isSpace there?
16:39:52 <Teja> yes
16:40:34 <MyCatVerbs> You want to write a function span which lets you supply any predicate you like.
16:41:16 <Teja> ok
16:41:21 <MyCatVerbs> So if you write "span predicate s = ...", and replace the occurrences of isSpace with predicate, then you'll have it.
16:41:45 <MyCatVerbs> Want me to talk you through how the definition of words works?
16:41:46 <Teja> ok, let me try it
16:41:54 <Teja> yes, sure
16:42:34 <MyCatVerbs> Okay, so. The first thing it does is (dropWhile isSpace), to get rid of leading spaces.
16:43:04 <Teja> yes
16:43:24 <MyCatVerbs> If the result of (dropWhile isSpace s) is the empty string, "", then there were no words in the string at all, so words just returns the empty list immediately.
16:43:37 <Teja> can I ask a dumb question??
16:43:43 <Vanadium> Teja: yes
16:44:00 <Teja> why is there no $ between dropWhile and isSpace?
16:44:01 <MyCatVerbs> There are no dumb que... okay, there are dumb questions. But I guarantee I've asked dumber than you can, even on purpose.
16:44:25 <Teja> hey sorry i got it
16:44:33 <Teja> i checked the sig of dropWhile
16:44:39 <Teja> go ahead
16:45:08 <MyCatVerbs> Because there's no need for it. (dropWhile $ isSpace) is exactly the same as (dropWhile isSpace).
16:45:24 <Teja> got it
16:45:52 <MyCatVerbs> The $ operator is actually just id, it just has really low precedence so that it tends to break expressions up (saving (us (from (needing (many parenthesis))))).
16:45:57 <Igloo> Teja: Do you mean in "dropWhile isSpace s"?
16:46:15 <Teja> ok
16:46:33 <Teja> Igloo: MyCatVerbs explained me that
16:46:56 <Igloo> If you mean in "dropWhile isSpace s" then it's not just that there's no need for it: it would be wrong
16:47:07 <Igloo> dropWhile isSpace s == (dropWhile isSpace) s
16:47:15 <Igloo> dropWhile $ isSpace s == dropWhile (isSpace s)
16:48:07 <Teja> actually when I see the type of dropWhile, it says it takes a predicate and a list
16:48:48 <Teja> applies the predicate on each element of the list and if returned true adds to one list and false to other list
16:48:58 <Teja> and returns the true list
16:49:03 <Teja> is that correct?
16:50:24 <MyCatVerbs> No. It applies the predicate to each element of the list. If the predicate returns false then it just drops the element and tests the next one. If the predicate returns true then it returns the whole remaining part of the list.
16:50:43 <MyCatVerbs> > dropWhile isSpace "   repent, silly humans!"
16:50:44 <lambdabot>   "repent, silly humans!"
16:51:08 <Teja> ok
16:52:00 <Teja> so my problem boils down to make two lists... one with true and other with false
16:52:08 <conal> what options are there in ghc-haskell for converting between Float & Double, besides fromRational.toRational ?
16:52:52 <Teja> splitWith odd [1,2,3,4] should return [[1,3], [2,4]]
16:52:58 <Teja> thats my goal
16:53:16 <noteventime> Teja: Data.List.partition
16:53:24 <MyCatVerbs> The "break" predicate takes a predicate and a list, and returns two lists. The first list is all of the elements up to and including the first one which doesn't satisfy the predicate.
16:53:54 <noteventime> Though partition returns a tuple
16:53:56 <Teja> ok
16:53:56 <MyCatVerbs> Er, I have that backwards. Sorry, it's late.
16:54:23 <Teja> Write a function splitWith that acts similarly to words, but takes a predicate and a list of any type, and splits its input list on every element for which the predicate returns False.
16:54:48 <MyCatVerbs> The first list is all of the elements up to, but not including, the first one which does satisfy the predicate. The second list is all of the elements after and including the first element which satisfies the predicate.
16:55:23 <Teja> ok
16:57:09 <MyCatVerbs> So words uses (break isSpace) in order to get a list of all the characters up to the next space - which, lo and behold, form a word!, and a string of all the characters left over after that.
16:57:36 <Teja> ok
16:57:58 <MyCatVerbs> It then recurses on the leftover list in order to get the rest of the words.
16:58:23 <Teja> ok... now I understood the problem correctly
16:58:27 <Teja> thanks for that
16:59:28 <Teja> ok, how should I approach doing that
16:59:32 <MyCatVerbs> No trouble. I get this nagging feeling that I probably have a vested interest in growing the Haskell community, but I'm not sure why. Yay for vaguely defined ulterior motives! ;D
16:59:36 <Teja> splitWith fn [] = []
16:59:46 <benmachine> if haskell's threads are not OS threads, does that mean that they won't use both my CPU cores?
17:00:00 <Teja> thats my first gaurd right?
17:00:01 <Philippa> MyCatVerbs: more people = more libs?
17:00:24 <Twey> Isn't break the function to be written?
17:00:27 <MyCatVerbs> benmachine: depends. If you compile with -threaded, and run with +RTS -N2 -RTS, then they will.
17:00:29 <Twey> I think using it might be cheating a little.
17:01:23 <Twey> @src words
17:01:24 <lambdabot> words s = case dropWhile isSpace s of
17:01:24 <lambdabot>     "" -> []
17:01:24 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:01:25 <benmachine> MyCatVerbs: sounds complicated
17:01:37 <MyCatVerbs> Or you can use -N4 or -N16 or -N1024 to have it run any number of threads you want.
17:02:00 <Teja> lambdabot: not so easy for me to understand
17:02:28 <MyCatVerbs> benmachine: it's not awfully complicated. You have 'n' Haskell threads, where n is some arbitrarily huge number.
17:02:40 <JackieJac> Hey guys, just started getting back into haskell. First time user of emacs. Got everything set up and was jsut testing something with ghci inside of emacs and got an error. How do I get my previous line? Up doesn't work
17:02:41 <benmachine> MyCatVerbs: how do you pass options at runtime?
17:02:51 <benmachine> or is that not what you meant
17:02:53 <noteventime> JackieJac: alt-p
17:02:58 <JackieJac> cheers
17:03:04 <MyCatVerbs> benmachine: you build your program with ghc --make Foo.hs -threaded, and then you run it with ./Foo +RTS -N2
17:03:18 <benmachine> o_O
17:03:20 <Philippa> benmachine: the thread count is a runtime option. Think of it like telling a JVM how many OS threads it's allowed
17:03:32 <MyCatVerbs> The runtime system will then spread your n Haskell threads over some k (expensive!) operating system threads.
17:03:57 <benmachine> does the program see those args?
17:04:03 <Igloo> conal: realToFrac
17:04:06 <Teja> splitWith fn s = case dropWhile fn s of
17:04:06 <Teja> 	[] -> []
17:04:06 <Teja> 	s' -> w : splitWith s'' where (w, s'') = break fn s'
17:04:12 <Philippa> no, it goes to the Run Time System rather than the program proper
17:04:19 <MyCatVerbs> benmachine: No, the run time system steals them. :)
17:04:19 <benmachine> oh
17:04:22 <Teja> its giving me an loading error
17:04:46 <MyCatVerbs> Teja: hpaste the error, please?
17:04:54 <benmachine> so if I wanted to invoke a hasekll program with +RTS in the arguments for some reason?
17:05:13 <noteventime> benmachine: There's something like --RTS
17:05:40 <Teja> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6948
17:05:52 <MyCatVerbs> Teja: oh, right. The problem is simple. You need to pass fn to the recursive call to splitWith.
17:05:52 <benmachine> that sounds like a really odd setup, but I guess it works
17:06:04 * benmachine makes a note
17:06:14 <noteventime> benmachine: Yes, after --RTS any other +RTS will be ignored and sent as normal arguments
17:06:17 <MyCatVerbs> So where you have w : splitWith s''... what you actually wanted to write was w : splitWith fn s''...
17:07:01 <Teja> nice... worked like a charm
17:07:03 <noteventime> benmachine: You can run ghc +RTS --help -RTS to get more information on arguments to the runtime system
17:07:09 <Teja> but not yet understood
17:07:23 <MyCatVerbs> Teja: it was complaining because splitWith wants to take a predicate as its first argument, but (splitWith s'') supplies it with a list instead.
17:07:41 <MyCatVerbs> Because s'' is a list. >>
17:07:45 <Teja> yeah, I was able to fix it and able to run it successfully
17:07:53 <MyCatVerbs> Philippa: ooh, the libraries thing is a good plan, I guess.
17:07:59 <Teja> but I need little help understanding it
17:08:19 <MyCatVerbs> Philippa: I still don't think it's the whole story for me, though.
17:08:21 <Teja> s' -> w : splitWith fn s'' where (w, s'') = break fn s'
17:08:30 <Teja> need help understanding it
17:08:49 <Philippa> MyCatVerbs: knowledgebase, likelihood of getting paid to code Haskell...
17:08:52 <MyCatVerbs> What bit are you having trouble with?
17:09:01 <Teja> i think i am getting it
17:09:21 <Guest39336> anyone around that uses grapefruit-frp?
17:09:21 <MyCatVerbs> Philippa: I think it's the latter bit in particular. Or, likelihood of getting paid to code comparatively as pleasant as Haskell.
17:09:30 <Teja> so we are using break to split the list when it returns false... is it correct?
17:09:59 <Teja> and adding the fist list to result list
17:10:17 <MyCatVerbs> You're using break to get the part of the list up to the first place that satisfies fn.
17:10:18 <Teja> and do it recursevily...
17:10:41 <MyCatVerbs> Philippa: like if Haskell went mainstream, then it'd blow the doors open for even crazier things to gain ground.
17:11:10 <SubStack> like lazy k!
17:11:19 <noteventime> MyCatVerbs: Or for the most boring things to become Haskell
17:11:43 <Teja> understand it completely
17:11:48 <MyCatVerbs> noteventime: That's more acceptable than the most boring things just staying as they are.
17:11:54 <Teja> thanks you very much guys....
17:11:54 <MyCatVerbs> Teja: yay! \o/
17:12:01 <noteventime> MyCatVerbs: True, I guess :)
17:12:08 <MyCatVerbs> Glad to hear you're getting on well. :)
17:12:39 <Teja> MyCatVerbs: You Rock man!! Thanks for your help and time... will keep you bugging with new problems :-)
17:14:36 <MyCatVerbs> Teja: okay, but be aware that I have to sleep some time. :)
17:15:59 <Teja> sure... will leave u some space... are in in EST??
17:16:50 <mike-burns> Teja: If you just ask a question in here someone will probably answer.
17:17:06 <Teja> yeah... I know that.. I am just kidding
17:17:07 <MyCatVerbs> Teja: hah! No, I'm in TAI. ;D
17:17:24 <MyCatVerbs> I mean, I'm in the UK. Out of curiosity, how did you run into Haskell?
17:18:11 <Teja> got some interest in Functional programming
17:18:17 <Teja> am a java/j2ee dev
17:18:42 <Teja> started with some scala... but I am going towards OOPS again
17:19:00 <MyCatVerbs> Teja: oh cool. I hope you're enjoying yourself with it. ^_^
17:19:00 <Teja> so thought of going towards a pure fn programming lang...
17:19:25 <Teja> yes, I really started loving it...
17:19:46 <Teja> its a big change in the way I think of programming
17:19:53 <Teja> but I a slowly getting it
17:20:07 <noteventime> Are there any introductions to TypeCompose, apart from the one on the wiki?
17:20:20 <Teja> and the community here is awesome..
17:20:36 <noteventime> Sounds like a really nifty library
17:22:24 <byorgey> noteventime: not that I know of, but its author, Conal Elliott, often hangs out here as 'conal'
17:22:32 <byorgey> so you can ask him questions about it
17:23:05 <byorgey> obviously that's not the same as a tutorial, but... =)
17:23:09 <noteventime> byorgey: I know, though it's not so much any specific question as just some general introduction
17:23:11 <MyCatVerbs> Teja: oh yeah. The only other programming language community I've seen thus far that is anywhere near as friendly as the one around Haskell is the Scheme community.
17:23:35 <byorgey> yeah
17:23:44 <MyCatVerbs> Teja: and I have no idea how on Earth they all manage to stay so cheerful. Why, they don't even have pattern matching on algebraic data types! ;D
17:24:10 <Teja> yes... now sometimes I feel like java is missing a lot
17:24:28 <noteventime> MyCatVerbs: Just think what they could do with $ ;)
17:24:50 <Teja> noteventime: :-)
17:25:04 <mightybyte> Anyone know how to fix the "ambiguous type variable" error here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6949
17:25:08 <noteventime> Scheme would suddenly look like scheme
17:26:14 <NHA_> anyone know of any tutorials on grapefruit-frp or something?
17:26:16 <MyCatVerbs> noteventime: hah!
17:26:43 <noteventime> MyCatVerbs: Opps, I meant Perl X-D
17:26:51 <hzap> except in scheme, you would use the ($) operator like ($ length '())
17:26:53 <jpcooper> mightybyte, I'm having a look
17:27:00 <mightybyte> jpcooper: Thanks
17:27:25 <jpcooper> you can't use type classes like that
17:27:26 <MyCatVerbs> NHA_: there's the wiki page, but I don't know of anything beyond that.
17:27:34 <jpcooper> mightybyte, the return type must be an actual type
17:27:48 <noteventime> I've been writing too much C to think for a while
17:27:59 <mightybyte> jpcooper: Hmmmm, I was wondering that, but wasn't quite sure.
17:28:13 <jpcooper> you might want to look into existential types
17:28:15 <byorgey> mightybyte: what is the type of showUnits ?
17:28:15 <MyCatVerbs> NHA_: note that the wiki page links to a couple of papers and talks, which are often quite helpful with these kinds of research-ey libraries.
17:28:20 <jpcooper> for your showunits thing
17:28:21 <MyCatVerbs> NHA_: http://www.haskell.org/haskellwiki/Grapefruit#Publications_and_talks specifically
17:28:28 <NHA_> ill check it out, thanks
17:28:30 <byorgey> jpcooper: that's not true.  For example, 'read' is typeclass-polymorphic in its return type
17:28:34 <byorgey> @type read
17:28:35 <lambdabot> forall a. (Read a) => String -> a
17:28:55 <MyCatVerbs> noteventime: I was just laughing because of the thought of Schemers using $ in the same way that Haskellers use it - to eliminate parenthesis. =D
17:28:56 <mightybyte> byorgey: It's right there in the definition of the Units class.
17:29:03 <jpcooper> byorgey, so he can turn existential types on and then write the definition with forall?
17:29:06 <byorgey> oh, sorry, missed it =)
17:29:26 <MyCatVerbs> Er, parentheses, even.
17:29:42 <hzap> mightybyte: ($ ($ ($ foldr +) 0) '(1 2 3 4 5)) :D
17:29:58 <mike-burns> Isn't that just (define $ apply) ?
17:30:19 <byorgey> mightybyte: the problem is that it really is ambiguous.  note that in the composition showUnits . uqUnits, the 'Units u => u' type drops out
17:30:40 <byorgey> but depending on what that intermediate type is, it could have a different behavior wrt 'showUnits'
17:30:43 <hzap> mike-burns: no, apply takes a list as the last argument
17:31:01 <byorgey> mightybyte: as another example, what should this evaluate to:   show (read "34")
17:31:05 <monochrom> mightybyte: Suppose I ask you about “show (read "3")”, do you know which intermediate type (returned by read and taken by show) is used? Your code is another incarnation of the same question.
17:31:12 <mike-burns> hzap: Ah, right.
17:31:14 <byorgey> mightybyte: it could be "34", but it could also be "34.0" -- it's ambiguous.
17:31:29 <mightybyte> byorgey: Ok, I get the concept, but it sure seems like there should be a way to do what I'm attempting.
17:31:56 <byorgey> mightybyte: what are you attempting?
17:32:02 <monochrom> Hmm is there a haskell wiki article on this?
17:32:26 <jpcooper> there is on existential types
17:32:35 <byorgey> mightybyte: I wonder if you actually want 'uqUnits' to return an existentially wrapped value.
17:32:35 <mightybyte> byorgey: Well, I have three different data types that represent different kinds of unit quantities.  i.e. Mass, Distance, Time
17:32:57 <mightybyte> byorgey: Possibly so.  I tried to do that, but I couldn't get the syntax right.
17:33:05 <noteventime> Neat, I've wanted to have something like Data.Bijection :)
17:33:06 <byorgey> mightybyte: i.e. should 'uqUnits' really be able to return a value which can have *any* Unit type, or should it return *some* Unit type but you don't know in advance what it will be?
17:33:09 <monochrom> Perhaps UnitQuantity "determines" Units.
17:34:23 <dibblego> @seen dons
17:34:23 <byorgey> mightybyte: if you want to go the existential wrapper route, you'll have to make a new wrapper data type
17:34:24 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 6h 11m 53s ago.
17:34:35 <dibblego> what is a good article that points out the problem with loops?
17:34:38 <mightybyte> byorgey: Ahh
17:35:04 <byorgey> something like  'data SomeUnit where SomeUnit :: Unit u => u -> SomeUnit
17:35:28 <byorgey> and then uqUnits can have the type a -> SomeUnit
17:35:38 <mightybyte> byorgey: Originally I had a single type: "data UnitQuantity q u...", with some type synonyms for the three specific ones.
17:35:59 <byorgey> and when you pattern-match on a SomeUnit value, you'll be able to use Unit methods on the value it contains
17:36:43 <mightybyte> byorgey: But I had just decided to refactor and use newtypes instead of type synonyms.  But then I started thinking that the double wrapper of "(.).(.) Distance UnitQuantity" was a bit verbose, so I was trying to eliminate UnitQuantity.
17:37:28 <mike-burns> dibblego: There's a problem with loops?
17:37:41 <dibblego> mike-burns, of course?
17:37:54 <mightybyte> byorgey: ...which is how I got to the code in that paste
17:38:16 <mike-burns> Oh okay.
17:38:26 <dibblego> mike-burns, pure languages do not have loops
17:38:35 <monochrom> Hahaha http://www.haskell.org/haskellwiki/Short_theorem_prover is gay. "lazily construct the list of all true statements" :)
17:38:51 <mike-burns> dibblego: Do you not consider recursion to be looping?
17:38:59 <dibblego> mike-burns, no
17:39:02 <mike-burns> Oh okay.
17:39:20 <pikhq> Then there are no loops in Haskell.
17:39:37 <mike-burns> Clearly. Don't know how we'll ever do something on every element of a list, though.
17:40:14 <dibblego> mike-burns, forM_/mapM_
17:42:04 <mike-burns> Anyway, I guess you're talking about `while' loops, in which case I haven't seen any article about the problem with it.
17:42:32 <mike-burns> But I'd guess any paper about the problem with mutation is a more generic case of the problem with `while' loops?
17:43:32 <monochrom> while loops have problems?
17:44:02 <mike-burns> They're soooo verbose.
17:44:05 <JackieJac> OK, so I have a function (to insert into a list) that takes two parameters. First is ([Char], String) and second is a list. I've got four cases here. [Char] has only one element or [Char] has several. Then of course empty and non-empty list. I haven't done haskell in so long, I'm not sure what the best way to handle it is. Especially the has only one element case
17:46:22 <JackieJac> I just need to see an exam[ple... I know it used |, but don't remember how!
17:46:26 <hzap> speaking of the mutating loops, I keep getting trapped by thinking that [ (lambda _ : x) for x in some_list ] in python is the same as the Haskell version
17:46:32 <mike-burns> f ([x], s) l = ... --- the has-one-element case.
17:47:28 <monochrom> and there is also f ([],s) l = ...
17:47:44 <monochrom> So, yes, nested pattern matching is possible.
17:49:05 <JackieJac> Thanks guys. It seems incredibly difficult to just look up these basics I've forgotten
17:49:31 <mike-burns> It's hard to search the Web for punctuation.
17:49:48 <SamB> mike-burns: to my continued annoyance, yes
17:49:58 <SamB> it is very hard to search the web for punctuation
18:07:15 <chadz> anyone do much scripting with haskell?
18:08:30 <Zao> As in?
18:09:50 <chadz> as in running commands via shell, interpreting whether they failed or not, capturing output, etc
18:09:55 <chadz> (shell scripting) i should say
18:10:25 <Zao> There's some HSH package.
18:10:44 <Zao> http://hackage.haskell.org/package/HSH http://hackage.haskell.org/package/HSHHelpers
18:12:18 <JackieJac> One of cases has two sub-cases, at which point I have(/n for new line): CASE = /n x==y = ... /n otherwise = ...
18:12:20 <JackieJac> Cool?
18:12:31 <JackieJac> Sorry, I'm writing on paper :(
18:16:04 <monochrom> Cool.
18:16:59 <sjanssen> JackieJac: you're missing several characters
18:21:37 <JackieJac> sjanssen: Please explain or just link to an example
18:21:52 <sjanssen> JackieJac: well, I'm not sure exactly what you're asking
18:22:19 <sjanssen> eg. f x | x == 1 = 10 \n | otherwise = 20
18:23:30 <JackieJac> The bars!
18:24:04 <JackieJac> Can't search for that, that's my problem. I've just forgotten all these specifics
18:24:57 <inimino> JackieJac: read some code, or the report
18:30:40 <sjanssen> JackieJac: I'm sure "haskell guards" would return some good results
18:36:06 <dilinger> hm
18:36:36 <dilinger> i was thinking about doing something like ShellEquivs
18:36:40 <JackieJac> Are they called guards? I didn't know that
18:36:48 <dilinger> too bad the shell equivalent that i need (openvt) isn't implemented
18:37:29 <lament> i actually get quite a lot of google hits for "haskell bars"
18:37:52 <lament> for example, "Haskell Bars, Taverns & Cocktail Lounges"
18:39:42 <monochrom> "Functional programming with bars, tarverns, pubs, and lounges"
18:41:05 <pcc1> I need to implement a generic traversal of a data structure which can only be done monadically (i.e. a monadic (specifically IO) operation needs to be carried out to extract the subterms).  is it possible to implement this using a Data instance and gmapM (I note that gmapM has a generic monad type)
18:44:10 <tavelram> Ive a bunch of IORefs that Id like to access in a hierarchial way, eg car.wheel.left - which i can do with like qualified modules, but is there a different way? Prefarably O(1), since the hierarchy is static, so I dont want to use Maps of Map or something.
18:51:15 <soupdragon> car_wheel_left
18:52:33 <JackieJac> Under the dewey decimal classification system, does it makes sense to add an entry 321 if 3 and 2 are non-existant parents?
18:53:46 <soupdragon> :Z
18:55:10 <ray> jackiejac: i don't understand
18:55:16 <ray> in a way, the answer is "no"
18:55:28 <JackieJac> That's what I think.
18:55:58 <ray> i think that's why the 92s exist
18:56:09 <ray> they couldn't subdivide it any more, or something
18:56:09 <JackieJac> Say you have an empty library and the first entry you want to add is 321
18:57:32 <JackieJac> 92s are for biographies
18:57:36 <ray> right
18:57:42 <JackieJac> They're just ordered by name
18:58:02 <ray> anyway, 321 exists
18:58:10 <ray> but 925 doesn't
18:58:13 <ray> as far as i know
19:00:19 <JackieJac> But say you have an empty library, using a custom DDC. The first book you want to add is categorised under 321. You haven't yet defined 300 and 320, but know 321... It doesn't make sense, yet that is what I'm supposed to code, thus creating empty, nameless categories
19:00:30 <ray> well
19:00:44 <ray> i just happen to like them, but have you considered a trie? :)
19:00:55 <JackieJac> trie?
19:01:17 <JackieJac> In another section I'm supposed to assume the entries being added do not yet exist...
19:01:25 <JackieJac> Yet I am creating them myself!
19:02:03 <ray> @go trie
19:02:04 <lambdabot> http://en.wikipedia.org/wiki/Trie
19:02:05 <lambdabot> Title: Trie - Wikipedia, the free encyclopedia
19:02:44 <NHA_> any grapefruit-frp users around?
19:03:21 <saml> let's say you want to model haskell's type. how would you do?  data Type = Int | Float | Char | Bool | () ?
19:03:35 <JackieJac> Ah, I see... I'm just going to code it and ignore the consequences
19:03:56 <ray> yeah, i'm not entirely sure what you're talking about is all
19:04:18 <soupdragon> saml, the syntax of? or a model of?
19:04:19 <tavelram> soupdragon, sorry, I need to be able to do things like, billsCar = car; billsCar.wheel.frontleft
19:04:35 <saml> soupdragon, model of, i think
19:04:42 <saml> to build syntax tree
19:04:51 <JackieJac> Thanks for trying though
19:05:03 <soupdragon> then you mean a syntax
19:05:08 <tavelram> yeah
19:05:10 <ray> but i'd use a trie for the dewey decimal system :P
19:05:17 <ray> tries are my second favorite data structure
19:05:19 <tavelram> oh
19:05:21 <saml> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/TypeType  hrm it has some
19:05:26 <soupdragon> saml, what about forall?
19:05:58 <saml> hrm.. it's too complicated
19:06:10 <sjanssen> saml: data Identifier = Var String | NotVar String; data Type = Application Type Type | Type Identifier
19:06:16 <soupdragon> it's not complicated
19:06:21 <thoughtpolice> saml: why not use haskell-src-exts ?
19:06:36 <soupdragon> Var String noooo :(
19:06:44 <copumpkin> lol
19:06:51 <saml> sjanssen, why NotVar String ?
19:07:15 <sjanssen> saml: because types can be added by the user
19:08:16 <saml> Type (Var "MyType")     and   Type (NotVar "BuiltinType")   ?
19:08:38 * thoughtpolice pokes copumpkin 
19:08:55 * copumpkin unpokes thoughtpolice
19:09:05 <saml> i think i don't understand what type is actually
19:09:21 <thoughtpolice> copumpkin: no 'copoke' ?
19:09:23 <thoughtpolice> :)
19:09:39 <copumpkin> :o
19:09:40 * ray pumpkins copoke
19:09:52 * copumpkin copokes ray and thoughtpolice
19:10:52 <saml> is type a predicate?  given x, if predicate-of-T x then x \in T else x \notin T
19:11:21 <Rotaerk_> amz, not if I have anything to say about it!
19:12:01 <copumpkin> thoughtpolice: what up?
19:12:06 <saml> darn. then i need to invent a language to describe predicat-of-*
19:12:10 <thoughtpolice> copumpkin: at work. :(
19:12:22 <soupdragon> saml, huh?
19:12:24 <copumpkin> aw
19:12:49 <beutdeuce> hey guys, got a question about an error
19:12:49 <thoughtpolice> copumpkin: off soon though. hopefully will have the ability to do *actual* work on GHC soon...
19:12:54 <copumpkin> yay
19:13:20 <thoughtpolice> copumpkin: I'm also thinking it would be +1 goodness if perhaps afterwords we could get shared lib support for OS X rolling
19:13:22 <beutdeuce> why doesn't this work:
19:13:23 <beutdeuce> myMean :: (Integral a, Fractional b) => [a] -> b
19:13:23 <beutdeuce> myMean [] = 0
19:13:34 <copumpkin> thoughtpolice: I'd love it!
19:13:36 <beutdeuce> myMean (x:xs) = div (sum (x:xs)) (length (x:xs))
19:14:15 <saml> that should be Int -> Int
19:14:26 <thoughtpolice> copumpkin: the iphone stuff would be awesome too, but I doubt it's going to be in shape in time for 6.12, but maybe
19:14:29 <saml> because length :: [a] -> Int
19:14:33 <thoughtpolice> copumpkin: plus I don't have an ADC license for the iphone lol
19:14:38 <copumpkin> :)
19:14:50 <beutdeuce> sam, i defined my own length
19:15:03 <thoughtpolice> copumpkin: I wish they would at least let you compile stuff and run the damn *simulator*
19:15:07 <thoughtpolice> but nooooo :(
19:15:10 <copumpkin> they do!
19:15:14 <thoughtpolice> ?!
19:15:15 <saml> beutdeuce, it might be nice if you paste your code on paste bin
19:15:15 <lambdabot> Maybe you meant: . ? @ v
19:15:25 <saml> @paste
19:15:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:15:27 <copumpkin> you just aren't allowed to run on the device
19:15:29 <thoughtpolice> copumpkin: last time I tried I couldn't compile any examples because they required some code signing license?
19:15:55 <copumpkin> thoughtpolice: the sim doesn't need a private key
19:16:10 <thoughtpolice> copumpkin: do you have to set it to a different build type or something?
19:16:14 <copumpkin> thoughtpolice: you might've needed to select the simulator target
19:16:23 <beutdeuce> saml, my problem => http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6954#a6954
19:16:23 <thoughtpolice> copumpkin: because I just started a blank cocoa iphone app in xcode and tried to hit 'compile' and it said 'no'
19:16:27 <thoughtpolice> copumpkin: ah
19:16:38 <copumpkin> thoughtpolice: it should already be an option, but you need to select it from the dropdown
19:17:12 <thoughtpolice> copumpkin: ah, sweet then.
19:17:32 <thoughtpolice> copumpkin: i'll have to pick up the latest xcode and the new iphone sdk then :) try some simulation-fun
19:17:38 <copumpkin> yup!
19:17:43 <thoughtpolice> copumpkin: did you see the remote debugging of iphone apps in real time w/ gambit scheme?
19:17:44 <saml> beutdeuce, div :: (Integral a) => a -> a -> a
19:17:56 <copumpkin> thoughtpolice: nope, where?
19:17:59 <beutdeuce> saml, yeah thought so, thnx
19:18:08 <thoughtpolice> copumpkin: it looks crazy awesome tbh. :) this is surely an old hat to lispers
19:18:27 <thoughtpolice> http://www.youtube.com/watch?v=Q7c0rU9Lv28
19:18:41 <soupdragon> saml, tell me about "to describe predicat-of-*"?
19:18:48 <thoughtpolice> copumpkin: ^^ writes an iphone app, runs it, it errors, and he connects a remote debugger and fixes it in real time all at once :)
19:19:07 <ray> yeah, lispers always go on about their remote realtime debugging
19:19:09 <ray> (i'm serious)
19:19:27 <saml> soupdragon, if I define a type to be a set of which predicat-of-a-type x is true, then i need a language or a way to describe/implement predicat-of-whatever
19:19:35 <copumpkin> amusingly, the mac os sandboxing language has lisp-like syntax
19:19:39 <thoughtpolice> ray: well, it certainly seems like a nice way to develop in a lot of instances. the iphone-ness is just awesome icing i guess
19:19:44 <copumpkin> and the iphone uses it too
19:19:44 <beutdeuce> saml The type signature for `div' lacks an accompanying binding
19:19:44 <beutdeuce>       (You cannot give a type signature for an imported value)
19:19:54 <thoughtpolice> ray: but I <3 HM types too much at this point
19:19:58 <ray> it is pretty cool
19:20:02 <thoughtpolice> THERE'S NO TURNING BACK >:(
19:20:04 <ray> i just wish it weren't tied to, you know, lisp
19:20:05 <soupdragon> saml, aha
19:20:10 <saml> beutdeuce, what are you trying to do?
19:20:23 <ray> haskell has etched types into my brain with a lightsaber
19:20:33 <SamB> ray: what is this remote realtime debugging
19:20:33 <beutdeuce> saml, make a mean function that returns a floating point value, so it doesnt truncate
19:20:38 <thoughtpolice> SamB: http://www.youtube.com/watch?v=Q7c0rU9Lv28
19:20:52 <thoughtpolice> ray: ditto.
19:20:52 <saml> beutdeuce, then use /  not div
19:20:52 <SamB> ray: my brain never really worked too well without types
19:20:56 <saml> > 1/2
19:20:57 <lambdabot>   0.5
19:20:58 <ray> samb: they rewrite running programs remotely by connecting to the lisp runtime
19:21:01 <saml> > 1 `div` 2
19:21:03 <lambdabot>   0
19:21:16 <beutdeuce> lol? lambdabot?
19:21:18 <Cale> beutdeuce: it sounds like you tried to give an explicit type signature for div
19:21:27 <beutdeuce> 2 `div` 1
19:21:28 <SamB> ray: why remotely? does that make a particular difference?
19:21:32 <Cale> beutdeuce: (which is a prelude function)
19:21:38 <ray> that just ups the coolness
19:21:47 <ray> they did it on some space rover once for example
19:21:59 <ray> i never heard the end of that one from lispers
19:22:20 <SamB> ray: oh, so fairly well even with high lag?
19:22:36 <p_l> ray: you meant Deep Space One?
19:22:36 <ray> i imagine most of the time was spent waiting, but it worked out in the end
19:22:40 <SamB> I'm just thinking ... what if they had crashed the debugging stub?
19:22:59 <p_l> SamB: it was all-or-nothing situation
19:23:03 <thoughtpolice> SamB: it's 'remote' because the iphone app runs in the simulator, but you have to connect from the outside
19:23:16 <ray> debug this lisp program or scrap the really expensive space probe
19:23:24 <ray> obvious choice
19:23:37 <p_l> SamB: if they didn't correct the error, a multi-bilion project would go to scrap
19:23:42 <SamB> yeah
19:23:49 <SamB> it still sounds pretty scary
19:23:57 <SamB> I wouldn't have wanted to be the one typing
19:24:13 <ray> lots of pressure and waiting for stuff to travel through space, i imagine
19:24:19 <Axman6> i wouldn't want to be hitting the go button...
19:24:19 <p_l> and iirc it wasn't something that could be found easily by automated testing (it was error in the way course corrections were calculated, afaik)
19:24:25 <ray> but once it's over, you are temporarily the coolest person on the planet!
19:24:38 <ray> until someone does it with a haskell space probe
19:24:40 <SamB> ray: yeah, but this is me I'm talking about
19:24:47 <SamB> I would have crashed the debugger
19:25:01 <SamB> er, debuggee, even
19:25:07 <thoughtpolice> I can see myself doing that as well
19:25:07 <Axman6> i wish BitC had a tutorial or something
19:25:07 <p_l> ray: JPL turned its back on Lisp (and other "weird" languages)
19:25:09 <saml> i notice that product [1..x]  gets more 0's at the end as x increase
19:25:13 <ray> pity
19:25:18 <thoughtpolice> "lol so guys, does this come out of my paycheck?! :("
19:25:19 <Axman6> seems like the sort of thing you'd use or this sort of stuff
19:25:49 <p_l> ray: the funny thing is that in reality it wasn't the lispers fault, but they got scrapped through office politics
19:26:00 <p_l> apparently C/C++ side had problems interfacing :D
19:26:19 <saml> how can I write a quick check to check if product [1..x] has always increasing number of 0's at the end. never decreasing. as x increases.
19:26:39 <saml> maybe it's a simple math proof :P
19:27:12 <Cale> saml: it is simple
19:27:30 <Cale> saml: the number of 0's at the end is the number of times which 10 divides it
19:27:42 <beutdeuce> anyone know how i can check standard library functions/data type definitions, not just types?
19:28:12 <p_l> ray: later they used Lisp to generate machine code for various small microcontrollers, including the ones in Mars Rover. Then Lisp got booted out
19:29:02 <Axman6> beutdeuce: 'check'?
19:29:22 <Cale> saml: and since if a divides c, then a divides bc, we have that if 10^k divides product [1..x], then it will divide product [1..(x+y)], for any positive integer y
19:29:29 <ray> i wonder when haskell will get an RTS that fancy
19:29:44 <SamB> ray: it's not just about a fancy RTS
19:29:50 <SamB> it would involve changing our way of run
19:30:15 <p_l> ray: I heard something about Haskell beginning as a CL program...
19:30:29 <beutdeuce> Axman6, i keep getting, "*** Exception: Module not part of module graph
19:30:43 <saml> Cale, yup
19:30:47 <Axman6> beutdeuce: when
19:30:52 <p_l> as in, one of the old implementations was classic lisp compiler (Haskell -> CL -> machine code)
19:30:52 <beutdeuce> "when i :check
19:31:22 <ray> every lisp program is a bug-ridden implementation of half of haskell, so that makes sense
19:31:35 <SamB> ray: half?
19:31:43 <ray> ok, 1/8
19:32:08 <SamB> is it the 1/8 that includes Foreign.* ?
19:32:35 <ray> it's the most boring eighth, whatever that is
19:32:36 <Axman6> p_l: CL?
19:32:40 <p_l> ehh... language wars again... instead of advocacy against either Haskell/Lisp/etc. let's bash Java... :P
19:32:45 <p_l> Axman6: Common Lisp
19:32:46 <ray> presumably common lisp
19:32:56 <Axman6> ah
19:33:01 <SamB> we aren't bashing haskell
19:33:17 <soupdragon> caml was first implemented in lisp
19:33:45 <soupdragon> Lazy-ml in caml (?)
19:33:47 <coreyoconnor> Using an existing language to bootstrap a compiler makes sense
19:34:13 <coreyoconnor> Take, for instance, the many compilers that output C then use a C compiler to produce the actual machine code
19:34:14 <soupdragon> and lazy-ml begat Haskell
19:34:17 <SamB> coreyoconnor: yeah, it's hard to get a nonexisting-language program to run
19:34:42 <p_l> SamB: you can start from assembly :D
19:34:51 <SamB> p_l: that exists too
19:34:57 <coreyoconnor> Course, on the theoretical level all compilers and transforming a program in one language to another
19:35:12 <coreyoconnor> machine code is just another language, but one to be interpretted by a CPU
19:35:23 <p_l> SamB: well, machine code is defined in a way that you don't really bootstrap...
19:35:29 <SamB> coreyoconnor: might be implemented by the CPU, true
19:36:17 <SamB> p_l: well ... you do, but sort-of in reverse
19:36:33 <soupdragon> and interpreters are compilers that output a monadic value
19:37:36 <coreyoconnor> soupdragon: So an executable on disk is just a serialized monadic value?
19:38:27 <soupdragon> no its program code: everything it
19:38:30 <soupdragon> no its program code: everything is**
19:38:31 <Cale> The fact that it's monadic isn't important though.
19:38:42 <monochrom> The Moggi tarpit? Everyone is a monad? Err Everything.
19:38:50 <soupdragon> hehe
19:38:51 <Cale> The fact that the IO monad is a monad isn't really that big of a deal.
19:39:07 <mike-burns> This has been a growing theme...
19:39:19 <monochrom> (Haha this "everything is a tarpit" is really useful!)
19:39:30 <monochrom> It's a growing meme too!
19:39:41 <ray> memes are a tarpit
19:39:45 <beutdeuce> is there a way to declare custom data types in ghci?
19:39:56 <Cale> The important thing about the way that IO is done in haskell is that we have values that represent the behaviour of the program.
19:39:56 <copumpkin> nope
19:40:02 <gwern> tarpits are a tarpit, but a white horse is not a horse
19:40:17 <ray> white horses are only white because they haven't sunk into the tar yet
19:40:18 <Cale> The fact that those values have some operations defined on them which make them into a monad is secondary.
19:40:22 <SamB> beutdeuce: :!cat module Foo where data Foo = Bar | Bas > Foo.hs
19:40:28 <monochrom> haha ray
19:40:29 <SamB> beutdeuce: :l Foo
19:40:36 <soupdragon> Cale (agreed)
19:41:00 <beutdeuce> SamB, thanx, what does !cat do?
19:41:14 <monochrom> SamB you're evil!
19:41:17 <SamB> Cale: yeah, I was just saying the other day that we'd likely be using some other abstraction for IO before everyone was a Haskell user ;-)
19:41:42 <soupdragon> although monad seems an unavoidably good fit
19:41:59 <SamB> beutdeuce: oh, that just runs a shell command to make a .hs file containing a module which declares your data type
19:42:19 <ray> it's an unavoidably good fit for lists too :P
19:42:21 <beutdeuce> SamB, oh! lol, the shell cat
19:42:24 <SamB> (i.e., you should really just use your text editor to make one ;-)
19:42:30 <gwern> :! shells out
19:42:34 <ray> that isn't what cat does, by the way
19:42:34 <beutdeuce> cool
19:42:38 <ray> but we know what you mean
19:42:38 <coreyoconnor> Partitioning the existing IO "monad" into multiple components would be useful. One component could be an implementation of all the monadic aspects of IO
19:42:50 <ray> (you meant echo)
19:42:51 <SamB> ray: oh, true
19:42:57 <SamB> I get them mixed up sometimes ;-)
19:43:00 <mike-burns> I wonder how much of the "monads are a good fit for IO" is related to Sapir-Whorf.
19:43:10 <SamB> beutdeuce: yeah, I meant echo ;-)
19:43:39 <ray> mike-burns: some people in here would say "all of it"
19:43:40 <SamB> oh, and you probably need to quote the Haskell code
19:43:54 <SamB> ray: not I
19:43:55 <soupdragon> mike-burns: I don't think it's related
19:44:20 <SamB> I'd say "what is Sapir-Whorf?"
19:44:24 <ray> i guess you have to use the term sapir-whorf loosely though
19:44:43 <ray> i think it's a vaguely similar concept to whatever io monad syndrome is
19:44:54 <mike-burns> We use "monad" loosely; might as well borrow terminology from linguistics loosely too.
19:44:56 <soupdragon> mike-burns: it seems quite optimal, in objective criteria
19:45:28 <Axman6> i few months ago, i thought it would be a good idea to split the IO monad into I and O monads (with an IO monad for when both were needed). seems to be the output could be thought of as pure. technically there's side effects, but only input can change the state/behaviour of the program
19:45:57 <copumpkin> Axman6: I think it should be split further than that
19:46:09 <Axman6> how so?
19:46:58 <gwern> can we really split input and output? I mean, just to read stdin, don't we have to do all sorts of buffering and requests and output stuff?
19:47:31 <soupdragon> you could index it,
19:47:55 <gwern> soupdragon: oh, and I just remembered a scheme question - is there any quasi-canonical implementation of functions specified by the standard, kinda like @src here?
19:48:17 <soupdragon> IO (SUDO ::: FileSystem ::: Nil) Monad
19:48:41 <Axman6> hmm, i guess output isn't really pure, like if you try to create a file twice, it might fail the second time. but getting the info that it failed would be input, so maybe it is sort of pure
19:49:01 <soupdragon> gwern yeah everything you need is in R5RS + SICP
19:49:38 <gwern> Axman6: any computation is impure anyway - consider that the computation might allocate enough memory that the OOM killer nails the process
19:49:49 <soupdragon> I and O transformers sounds weird though
19:49:51 <Axman6> true
19:50:33 <gwern> soupdragon: I mean I look at the standard for 'remainder', say, http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_idx_290 and it includes a lot of info but doesn't specify any implementation; and SICP just uses it
19:51:24 <soupdragon> gwern, yeah not everything can be decomposed in a sensible way
19:59:44 <gwern> hm. is opengl on hackage? (I mean for the buildbot)
20:00:15 <copumpkin> Saizan: still around?
20:00:46 <dibblego> has anyone bothered to refute "all these languages are turing complete so there is no point to Haskell!" ?
20:01:02 <SamB> dibblego: ... why?
20:01:17 <gwern> dibblego: perlis's turing tarpit epigram is the answer, I think
20:01:17 <copumpkin> I do it every so often in real life, but have never tried writing a single coherent essay about it
20:01:21 <dibblego> SamB, because I don't wish to single-handedly refute every myth out there
20:01:49 <SamB> dibblego: someone has refuted it for <insert reasonable language here>, surely?
20:02:07 <copumpkin> I bought whyhaskell.org a while back as a catch-all domain that would have a FAQ refuting the common misconceptions and so on
20:02:13 <SamB> I mean, you can't really get anywhere if you try to refute it for intercal, I expect ;-)
20:02:15 <soupdragon> nobody thinks that
20:02:22 <copumpkin> soupdragon: you'd be surprised
20:02:41 <copumpkin> or maybe people don't really think it but just fail at coming up with good arguments for their existing prejudices :)
20:02:56 <SamB> it's not worth putting in much effort to try to convince people who really think that otherwise
20:03:14 <SamB> just say "well, why care about what *you* use?"
20:03:18 <gwern> copumpkin: I'm afraid the name 'why' has already been taken by the rubyist
20:03:19 <mmorrow> dibblego: that question doesn't seem to me to be worth answering
20:03:19 <lambdabot> mmorrow: You have 3 new messages. '/msg lambdabot @messages' to read them.
20:03:34 <gwern> maybe we could have a who_the_lucky_gal
20:03:35 <copumpkin> gwern: hah :P he tends to put an underscore before it when it's ambiguous though
20:03:38 <copumpkin> lol
20:04:02 <SamB> gwern: that was "why bother refuting it"
20:04:03 <dibblego> mmorrow, agreed -- a stubborn person who claims to have an understanding of the advantages of functional programming insists on making it and insists on its relevance
20:04:07 <soupdragon> I am surprised you take someone seriously if they talk about "turing complete" wrt pragmatics
20:04:12 <SamB> not "I think someone named why did it"
20:04:15 <copumpkin> I guess brainfuck or unlambda are simple one-word responses to that question :)
20:04:19 <Cale> Why bother trying to get people who don't want to learn something new to use it?
20:04:40 <SamB> Cale: why bother refuting such a stupid argument?
20:04:45 <mmorrow> dibblego: tell them to re-implement all their shell scripts in C
20:04:54 <SamB> I suppose "unlambda" is a good one-worder
20:05:03 <copumpkin> I think brainfuck is more well known though
20:05:06 <gwern> or malbolge
20:05:07 <SamB> hmm.
20:05:09 <gwern> I like malbolge
20:05:10 <SamB> okay, so go both.
20:05:15 <SamB> gwern: is that one proven yet?
20:05:23 <gwern> SamB: I thought it was
20:05:26 <Cale> Is malbolge really Turing complete? I'm not sure.
20:05:28 <copumpkin> I think people tend to assume it is, but it's too tedious
20:05:47 <SamB> lets stick to ones where at least anyone who's heard of them is aware that it is provably turing complete
20:06:01 <copumpkin> lolcode ;)
20:06:31 <SamB> didn't they invent that just so they could make lolcats that actually ran?
20:06:51 <lpsmith> speaking of turing completeness... somebody's claimed to have disproven the church-turing thesis
20:07:21 <copumpkin> :o
20:07:31 <ray> that would be cool
20:07:32 <gwern> 'Malbolge is not Turing Complete, due to its memory limits. Several attempts have been made to create Turing Complete versions of Malbolge.'
20:07:43 <copumpkin> PLZ OPEN FILE "LOLCATS.TXT"?;AWSUM THX;VISIBLE FILE;O NOES
20:07:45 <ray> a step away from the von neumann machine? (or not)
20:07:47 <lpsmith> www.aemea.org
20:07:51 <soupdragon> lpsmith haha seriously?
20:08:04 <lpsmith> smells slightly crankish,  but also better than your average crank
20:08:11 <soupdragon> slightly!!
20:08:18 <copumpkin> now we need a panel of 20 scientists who claim he's correct!
20:08:18 <copumpkin> ;)
20:08:34 <copumpkin> I mean 22
20:08:52 <lpsmith> heh
20:08:55 <erisco> I am curious: there is a lot of debate on how to create the functional version of quick sort. If Haskell can interface with other languages, is it possible to write the quick sort in C and use it in Haskell like it was an ordinary function?
20:08:58 <mmorrow> preflex: zenc PLZ OPEN FILE "LOLCATS.TXT"?;AWSUM THX;VISIBLE FILE;O NOES
20:08:59 <preflex>  PLZZz20UOPENz20UFILEz20Uz22ULOLCATSziTXTz22Uz3fUz3bUAWSUMz20UTHXz3bUVISIBLEz20UFILEz3bUOz20UNOES
20:09:09 <copumpkin> erisco: sure thing, but not sure why you'd want to :)
20:09:24 <lpsmith> I haven't taken a close look at the "dynamic register machine" construction,  but it's not clear to me why it couldn't be emulated by a UTM
20:09:25 <ray> if you allow for simultaneous 4-day time cube, then disproving C-T is a simple corrolary
20:09:28 <copumpkin> does ELF have a maximum symbol length?
20:09:33 <roconnor> erisco: what do you mean by quicksort precisely
20:09:35 <copumpkin> ray: lol
20:09:37 <mmorrow> copumpkin: i don't think so
20:09:41 <gwern> ray: the man would just cover that result up
20:10:02 <mmorrow> copumpkin: since all the (char*) names are kept in a string section
20:10:16 <copumpkin> ah, so the symbol is just a pointer to the beginning of it?
20:10:24 <copumpkin> or an offset
20:10:26 <roconnor> erisco: in-place quicksort?
20:10:28 <erisco> roconnor, well, you said a functional quicksort would be a treesort, someone else made a parallel version
20:10:28 <mmorrow> copumpkin: an offset
20:10:54 <mmorrow> copumpkin: (a "name" in any other part of the file is just an offset)
20:10:57 <roconnor> erisco: good, you are well informed :)
20:10:58 <erisco> roconnor, but yes, the in-place quicksort that has the advantage of consuming very little memory, like the algorithm was defined for
20:11:16 <copumpkin> use ST!
20:11:39 <soupdragon> Turing Immortality problem  is the  loons way to say  halting problem?
20:11:48 <erisco> roconnor, and I am not really asking because the existing sort function isn't good enough, I am asking on a general case where Haskell may not be able to offer enough level of performance
20:11:49 <roconnor> soupdragon: what's that?
20:12:03 <soupdragon> (or negation of)
20:12:09 <copumpkin> erisco: if you want good sorting performance, check out uvector-algorithms
20:12:11 <erisco> roconnor, as to what the interfacing with other languages, like C, is like, and if it is sophisticated
20:12:13 <copumpkin> @hackage uvector-algorithms
20:12:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uvector-algorithms
20:12:28 <soupdragon> roconnor, wacky science lpsmith linked
20:12:39 <copumpkin> erisco: strict unboxed superfast sorting algorithms :)
20:13:00 <roconnor> erisco: well, first we should avoid comparing sorting (linked) list with sorting arrays
20:13:01 <Axman6> preflex: zenc zzzz
20:13:01 <Axman6> :(
20:13:01 <preflex>  zzzzzzzz
20:13:15 <erisco> roconnor, like one would take an interpreted language for its ease of rapid development but back it with C or C++ for the performance intensive parts where needed
20:13:27 <roconnor> erisco: as copumpkin points out, you can write Quicksort for STArrays easily in the ST monad.
20:13:35 <lpsmith> The Turing Immortality problem seems to have something to do with the halting problem,  but not exactly
20:13:40 * soupdragon sighs at interpreted language
20:13:43 <lpsmith> I mean, it's not the halting problem
20:13:52 <copumpkin> turing immorality problem ;)
20:13:58 <erisco> roconnor, that is that Lennart did no?
20:14:01 <copumpkin> sounds homophobic
20:14:08 <lpsmith> haha
20:14:33 <roconnor> erisco: I forget if Lennart used IO or ST.  Essentially the same thing I expect.
20:14:53 <lpsmith> I haven't spent much time on it, but it sounds as though the Immortality problem is legit
20:15:12 <lpsmith> And the guy does have a recent-ish Ph.D. from Northwestern
20:15:23 <mmorrow> @tell ivanm i'm not sure about the blank line in Doc. i usually do (text "\n") which feels like a hack
20:15:24 <lambdabot> Consider it noted.
20:15:33 <lpsmith> So... I'm skeptical, but I dunno
20:16:40 <roconnor> lpsmith: wtf? he disproves the C-T thesis?
20:16:45 <soupdragon> lpsmith: have you ever implemented a TM in LC? it's easy
20:17:08 <Pseudonym> For extra credit, implement a TM in Haskell's typeclass system.
20:17:17 <soupdragon> lpsmith: the converse is work but certainly trus
20:17:30 <gwern> roconnor: iirc, the CT thesis isn't really provable or disprovable
20:17:36 <roconnor> lpsmith: oh wait, he is using classical dynamics to solve the halting program.  I could believe that.
20:17:43 <Cale> It is easier to implement untyped lambda calculus in the type system
20:18:05 <soupdragon> gwern??
20:18:37 <soupdragon> wiki says: Informally the Church–Turing thesis states that if an algorithm (a procedure that terminates) exists then there is an equivalent Turing machine or applicable λ-function[15] for that algorithm. Today the thesis has near-universal acceptance.
20:18:44 <erisco> roconnor, I really just wanted an opinion on how useful interacting with C was for Haskel;
20:18:51 <lpsmith> well,  you can't really prove the C-T thesis without a great deal of research into how to formalize it
20:18:53 <erisco> roconnor, in terms of how well it can be done as of now
20:18:59 <roconnor> gwern: It is scientifically falsifiable.
20:19:00 <Cale> erisco: useful. There are lots of bindings to C libraries.
20:19:01 <copumpkin> erisco: it's easy and comparatively elegant
20:19:07 * soupdragon laughs at 'Today the thesis has near-universal acceptance'
20:19:08 <Cale> erisco: the FFI is really good.
20:19:17 <lpsmith> but you certainly can disprove it,  exhibit a new kind of machine that can do something that a TM can't
20:19:22 <roconnor> erisco: as other say, it is useful.
20:19:25 <Cale> erisco: C++ is harder, but that's C++'s fault.
20:19:37 <copumpkin> erisco: we still prefer to do things in pure haskell as it's possible to get almost the same performance, often a lot more elegantly
20:19:45 <copumpkin> :P
20:19:52 <Cale> (or even occasionally better performance)
20:19:56 <copumpkin> yeah!
20:20:10 <erisco> copumpkin, oh for sure, would love to use one language for everything too
20:20:13 <roconnor> soupdragon: why is that funny?
20:20:34 <soupdragon> pun on universal
20:20:57 <erisco> Cale, copumpkin, roconnor thanks for letting me know
20:21:05 <copumpkin> erisco: this is the first language I've tried where it is basically possible to have nice abstractions and crazy performance though :) only drawback right now is that we can't emit SIMD code yet
20:21:26 <Cale> soon, soon :)
20:21:27 <erisco> roconnor, hopefully I can use Haskell for something other than implementing a kick-ass Graham scan algo ;)
20:21:49 <gwern> mm... graham scanckers...
20:22:19 <soupdragon> it is an open question whether all quantum mechanical events are Turing-computable?
20:22:21 * Cale should give up and learn how to use OpenGL properly.
20:22:27 <soupdragon> weird
20:22:31 <erisco> copumpkin, it is refreshing to be able to not have to choose between good design and performance
20:22:35 * copumpkin is getting back to proving commutativity on naturals in haskell :P
20:22:57 <copumpkin> "proving"
20:23:04 <roconnor> Cale: don't give up1
20:23:05 <erisco> copumpkin, I just need to figure out where to use Haskell. I do web development more than anything. I'd be thrilled to try applying it eventually through fcgi
20:23:15 <pikhq> http://www.nijoruj.org/~as/2009/04/20/A-little-fun.html
20:23:29 <copumpkin> zomg it's thoughtpolice
20:23:31 <Cale> roconnor: hehe
20:23:33 <pikhq> Theorem prover for Haskell. Actual proving, not "proving". ;)
20:23:37 <roconnor> erisco: I use haskell to optimize portfolios
20:23:54 <erisco> roconnor, what do you mean? resume content?
20:24:13 <Adamant> fiscal
20:24:17 <Adamant> I assume
20:24:17 <roconnor> erisco: finacial portfolios, or rather pseduo-finacial portfolios
20:24:31 <erisco> roconnor, oh, haha, sorry... flew over my head there
20:24:56 <soupdragon> does it use haskell semantics or just go by equations{
20:24:56 <soupdragon> ?
20:24:56 <copumpkin> big moniez
20:25:18 <roconnor> big fake moniez!
20:26:38 <Cale> roconnor: are you paid in fake moniez to do it?
20:26:40 <roconnor> soupdragon: how is he using classical dynamics?  Point particles?
20:26:52 <lpsmith> copumpkin:  proving commutativity of Peano arithmetic or proving commutativity of the addition algorithm as taught in school?
20:27:00 <copumpkin> lpsmith: peano
20:27:04 <roconnor> Cale: I optimize my own fake portfolios for fake profit!!1!
20:27:25 <erisco> night all
20:28:44 <pikhq> soupdragon: It's a tiny hack that the authors of this theorem prover wrote up that compiles Haskell into their theorem prover's language.
20:29:21 <pikhq> It being a lazy, purely functional programming language with a similar type system, this is not all that hard to do.
20:29:30 <soupdragon> roconnor, I didn't give it the benefit of the doubt
20:30:20 <soupdragon> pikhq, oh cool does it deal with codata like infinite streams?
20:31:56 <roconnor> soupdragon: this looks ridiculous
20:32:05 <soupdragon> agreed :p
20:32:27 <roconnor> his machine appears to be trivially implementable by a TM
20:36:38 <roconnor> soupdragon: oh, he is a lisper
20:38:43 <lpsmith> roconnor:  agreed;  I really don't understand why his proposed machine can't be implemented on a TM;  it looks like it can
20:44:39 <JackieJac> Instead of using x:xs, can I decompose the x? So it says (Char String []):xs ? Currently getting a wrong indent error.
20:45:09 <Cale> (Char String []) is ... well, it's some type constructors
20:45:35 <Cale> JackieJac: you can pattern match on the x, but it has to be a proper pattern :)
20:52:16 <JackieJac> That's a proper pattern
20:52:28 <JackieJac> It's a data type I've defined
20:52:46 <inimino> erm
20:52:47 <copumpkin> ??
20:52:53 <copumpkin> Char String [] ??
20:53:09 <copumpkin> type String = [] Char
20:53:13 <inimino> pretty sure that's not a proper pattern, whatever else it may be
20:53:23 <copumpkin> that's the only time you'll see those three things together :P
20:54:07 <soupdragon> data Foo = String
20:54:25 <copumpkin> :k Char
20:54:27 <lambdabot> *
20:54:55 <copumpkin> @src Char
20:54:55 <lambdabot> data Char = C# Char#
20:55:03 <soupdragon> you can have things with the same name at different levels
20:55:14 <soupdragon> e.g. () []
20:55:39 <soupdragon> newtype Foo = Foo ...
20:55:56 <copumpkin> yeah, I guess :)
20:56:18 <deech> hi all, does anyone here use lhs2tex?
20:56:28 <JackieJac> (Node Char String [Nodes])
20:56:52 <JackieJac> That's my type
20:57:05 <copumpkin> what data constructors does it have?
20:57:18 <copumpkin> or is that it?
20:58:01 <JackieJac> data DN = Node Symbol Classfn DDC
20:58:20 <copumpkin> ah, so you need the Node constructor there
20:58:34 <JackieJac> type DDC = [DN]
20:58:51 <JackieJac> I have Node in there :(
20:59:15 <copumpkin> can we see the snippet of code? your original question didn't make much sense... :)
20:59:35 <JackieJac> insert ([x],name) (Node sym oname yys):ys
20:59:53 <JackieJac> I get a line indentation error even though it's at col 0.
21:00:03 <copumpkin> ah
21:00:13 <coCocoa|sleeping> JackieJac:  insert ([x],name) ((Node sym oname yys):ys)
21:00:14 <JackieJac> C:\Users\Matthew\coding\emacs\coursework.hs:91:0:
21:00:23 <copumpkin> lol
21:00:31 * copumpkin hacks into the machine and checks
21:00:53 <copumpkin> yup, it's what coCocoa|sleeping said ;)
21:01:02 <JackieJac> Same error
21:01:26 <JackieJac>     parse error (possibly incorrect indentation)
21:02:36 <JackieJac> Unis over, so it's not like you guys are helping me get good grades
21:02:53 <JackieJac> This is from second year, just wanted to do some Haskell again
21:03:45 <copumpkin> without more context, it's hard to say what indentation problems you may have
21:05:27 <JackieJac> Missing square bracket line above :(
21:08:48 <copumpkin> how hard is it to represent a complicated graph in a "tied knot" form?
21:11:41 <Apocalisp> copumpkin: tied knot?
21:12:11 <copumpkin> basically representing the entire graph directly in haskell rather than using some implied structure
21:12:23 <coCocoa> copumpkin: "complicated" == cyclic?
21:12:33 <copumpkin> yeah :P
21:13:40 <jdrake_> Can anyone recommend a good refresher on haskell? I am mainly interested in basic syntax/concept stuff.
21:14:03 <Apocalisp> @where lyahfgg
21:14:03 <lambdabot> I know nothing about lyahfgg.
21:14:19 <Apocalisp> @go Learn You a Haskell for Great Good
21:14:20 <lambdabot> http://learnyouahaskell.com/
21:14:20 <lambdabot> Title: Learn You a Haskell for Great Good!
21:14:21 <wmealing__> jdrake_, i'm finding learnyouhaskell useful
21:14:21 <Cale> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html -- this is a good quick syntax reference
21:14:35 <jdrake_> hilarious name
21:14:49 <vinicius> anyone managed to cabal install HStringTemplate-0.5 on Fedora 11? I get this error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6955#a6955
21:14:54 <Cale> (doesn't cover everything, but should be enough to jog your memory if you already know it)
21:15:18 <soupdragon> @where lyah
21:15:19 <lambdabot> www.learnyouahaskell.com
21:15:31 <wmealing__> it has pictures.
21:16:02 <Cale> http://learnyouahaskell.com/listmonster.png <-- epic
21:17:03 <Apocalisp> Yeah, but the tail also has a head
21:17:05 <jdrake_> Is this stuff fairly new?
21:17:32 <Apocalisp> yes
21:18:43 <coCocoa> edwardk: ping
21:20:35 <bgs100> Cale, Yay for Mario references :D
21:21:39 <soupdragon> I thought it was from Magic Roundabout
21:22:16 <soupdragon> nmm I wonder why I thought that
21:23:41 <bgs100> http://www.google.com/search?hl=en&q=mario+wiggler
21:31:56 <Cale> 花ちゃん is a much more cute name than Wiggler, I think. :)
21:33:06 <copumpkin> :o
21:38:40 <jdrake_> Ψαλε ισ βεττερ
21:43:23 <dino-> I'm working on something to be released for the first time in a couple of days and it really REALLY needs a man page. I'm wondering if cabal can install man pages.
21:46:00 <JackieJac> Can you debug Haskell with emacs? Step through?
21:47:10 <sjanssen> dino-: it can't by itself, but you can write a custom install hook
21:47:29 <coCocoa> JackieJac: "Stepping through" Haskell isn't as productive as it is with other companies.
21:47:59 <Cale> companies?
21:48:13 <JackieJac> Hmmm... I'm causing an error somewhere, but need to print the code and that would wake my girl up.
21:48:29 <Cale> JackieJac: hpaste?
21:48:33 <Cale> @paste
21:48:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:48:39 <dino-> sjanssen: ya, I will definitely have to do that then.
21:48:40 <coCocoa> Cale: Thanks - s/companies/languages/
21:48:56 <JackieJac> I want to try and fix it myself first. I just work better with paper.
21:49:04 <copumpkin> :o
21:49:12 <coCocoa> Note to self: don't IRC while you're chatting on the phone; cross-posting gets silly. ;)
21:49:13 <copumpkin> save the rainforests!
21:49:26 <soupdragon> LOL
21:49:39 <JackieJac> Debugging > rainforests
21:49:47 <soupdragon> @remember coCocoa "Stepping through" Haskell isn't as productive as it is with other companies.
21:49:48 <lambdabot> It is forever etched in my memory.
21:50:12 <coCocoa> soupdragon Gee, thanks. :\
21:50:13 <Cale> JackieJac: It's often possible to write down a Haskell expression on paper and reduce it step-by-step by hand. I wish that GHCi could do this.
21:50:31 <Cale> Following the steps that GHCi *actually* takes is less interesting though.
21:51:02 <Cale> You can use the ghci debugger. It's not perfect, but sometimes it's useful.
21:51:22 <coCocoa> Cale: It would be helpful to track down those infamous "No instance for Num [SpecialType]" errors. ;)
21:51:58 <Cale> huh?
21:52:12 <Cale> Typechecking is separate.
21:52:34 <Cale> (or at least, I think of it as separate)
21:52:41 * coCocoa makes a note to start making randon types with names like "Fingertips", "FromThePain", etc.
21:52:51 <JackieJac> Cale: I always code Haskell on paper first, then type and then if it fails, print it and debug.
21:53:03 <copumpkin> :o
21:53:17 * coCocoa would get a kick from a "No instance for Num FromThePain" error... >;)
21:53:44 <JackieJac> Haskell and Ocaml are the only language I do it with, likely because I'm not as comfortable with them.
21:54:05 <pikhq> JackieJac: I also do that with Brainfuck.
21:54:21 <coCocoa> JackieJac: I suspect that statement makes more sense with s/Haskell/C++/ ;)
21:54:45 <pikhq> For the simple reason that Brainfuck debuggers are terrible for the obvious reason that there's nothing more they can do than show you the entire state...
21:54:56 <Cale> coCocoa: what statement?
21:55:23 <coCocoa> pikhq: Well, besides Oleg (who does it in his head, if he doesn't just use a Scheme interpreter), who doesn't debug BF that way? ;)
21:56:16 <pikhq> coCocoa: I don't know.
21:56:26 <pikhq> People who don't write in Brainfuck, I guess.
21:56:37 <coCocoa> Cale: "<JackieJac> Cale: I always code Haskell on paper first, then type and then if it fails,print it and debug." -- that statement. ;)
21:57:06 <Cale> coCocoa: Seems natural to me :)
21:57:07 <JackieJac> Never heard of Brainfuck before. Looks tough
21:57:44 <Cale> coCocoa: though I'm more likely to just keep the first part in my head, I'll often scribble things down
21:57:45 <coCocoa> JackieJac: Naugh, it's like an intermediate language for C. ;p
21:57:57 <Cale> I always have a pad of blank paper in front of me
21:58:22 <soupdragon>  <JackieJac> Cale: I always code Haskell on paper first, then type and then if it fails, print it and debug.
21:58:22 <JackieJac> When I'm at home I use my whiteboard
21:58:28 <soupdragon> really??
21:58:31 <JackieJac> Yes
21:58:45 <coCocoa> Cale: I usually use paper to write down ideas, but once it's on the comp, I usually keep it there.
21:58:46 <soupdragon> why?
21:58:49 <JackieJac> Writing it out and visualising it that way helps me
21:59:04 <soupdragon> interesting
21:59:16 <coCocoa> JackieJac: Ooh, whiteboard! I'm jealous! :)
21:59:19 <JackieJac> The way you can annotate revisions help me clarify my idea
21:59:19 <Cale> coCocoa: ah, I don't have a printer, but I'll often write down an expression and start reducing it by hand
21:59:21 <dino-> I like to write code too, mostly working out small things. I keep a steno pad with me all the time. But I don't care so much for printing things out.
21:59:29 <dino-> ya, we use the whiteboard at home office a lot too
22:00:13 <JackieJac> Sometiems it gets a bit crazy when I start using all my colours... but it's still legible
22:01:17 <pikhq> Brainfuck's actually rather easy to write in.
22:01:32 <pikhq> Just helps to have a page pulled up of common Brainfuck boilerplate.
22:01:37 <pikhq> (like boolean logic)
22:02:10 <Cale> Y'know I was just thinking today that Mathematica has the only syntax highlighting I've seen which actually means something significant about the code.
22:02:22 <Cale> I wonder why it hasn't been done more.
22:02:42 <mike-burns> How do you mean?
22:02:47 <Cale> Colour variables one colour if they're unbound, and another when they get bound, for instance.
22:02:49 <mike-burns> (I haven't used it.)
22:02:57 <mike-burns> Oh. That's awesome.
22:03:46 <SamB> Cale: I'm guessing it's somewhat related to how rarely editors actually store programs as anything like what they mean?
22:03:52 <soupdragon> Cale probably just because writing parsers is a bit boring
22:03:59 <Cale> SamB: yeah
22:04:25 <SamB> Mathematica stores it's program texts as trees
22:04:37 <coCocoa> So, what would be the "-morphism" class of inits? :)
22:04:49 <SamB> a bit like TeXmacs, only it doesn't crash nearly so much and is more usable ;-)
22:07:00 <soupdragon> SamB, what about half written programs?
22:07:23 <SamB> soupdragon: they might be trees which are clearly missing some branches
22:07:47 <inimino> Cale: actually it's mainly because writing incremental parsers is hard and writing a lexer is easy
22:08:11 <Cale> inimino: yeah
22:08:15 <inimino> Cale: (and doing enough analysis to show anything meaningful about the code in real time is harder yet)
22:08:39 <SamB> iirc it annotates the visual representation of the function calll expression nodes with red marks when it can tell you're missing arguments
22:09:43 <SamB> I wouldn't claim it was a semantic editor, though
22:09:52 <SamB> just a structured one
22:10:31 <SamB> which makes rather heavy use of semantic[ish?] information
22:11:35 <SamB> it's rather like an extremely funny looking lisp
22:11:48 <SamB> actually
22:12:04 <Cale> It's what Lisp was originally intended to look like
22:12:12 <SamB> though it has thicker syntax
22:12:34 <Cale> Right, Lisp was going to have something called M-expressions which look very much like mathematica.
22:12:45 <SamB> when I say thicker, I mean it has more ... *stuff* in it, not that you have to write all that
22:13:06 <Cale> But then they got S-expressions and ended up going that way :)
22:15:00 <SamB> like, *your* expressions are represented by *other* expressions in the actaul file that Mathematica stores
22:16:12 <SamB> the other expressions basically saying what your expressions look like
22:18:44 <pikhq> Cale: "Going to have"?
22:18:51 <pikhq> No, Lisp originally had M-expressions.
22:19:03 <pikhq> And programmers wrote in straight S-expressions for God knows what reason.
22:19:09 <SamB> pikhq: in what implementation?
22:19:26 <pikhq> SamB: Implementation?
22:19:29 <pikhq> Lisp was never meant to be implemented!
22:19:36 <SamB> I was going to mention that next
22:19:49 <Cale> pikhq: *was* going to have
22:20:04 <pikhq> Cale: But it did in fact have it.
22:20:16 <lament> Lisp is divine, humans trying to implement it is heresy
22:20:19 <SamB> ... but why would anyone have bothered to specify M-expressions before implementing it?
22:20:28 <ray> lisp is blub
22:21:03 <SamB> I thought it wasn't intended to be implemented merely because it had, like, two features
22:21:14 <lament> in fact, the downfall of modern CS is largely due to the Original Lisp
22:21:43 <JackieJac> What does Counter Strike have to do with any of this ?????
22:21:43 <SamB> lament: yeah, I know, adam and eve and the snake ...
22:21:46 <pikhq> John McCarthy simply never bothered to *formally* specify M-expressions, or implement a way of translating them to S-expressions.
22:22:00 <SamB> pikhq: so it was all meatware
22:22:11 <SamB> that's worse than vapourware, you know!
22:22:13 <pikhq> SamB: At the time, Lisp itself was all meatware.
22:22:28 <SamB> pikhq: what? no semantics?
22:23:09 <pikhq> SamB: ... I said that wrong.
22:23:24 <SamB> I think pikhq is getting "M-expressions" and "formulas" mixed ;-)
22:24:20 <pikhq> "The project of defining M-expressions precisely and compiling them or at least translating them into S-expressions was neither finalized nor explicitly abandoned. It just receded into the indefinite future, and a new generation of programmers appeared who preferred internal notation to any FORTRAN-like or ALGOL-like notation that could be devised." -- John McCarthy
22:25:23 <lpsmith> nothing wrong with lisp... the first ML implementations were done in lisp,  the notion of laziness came out of the lisp community...
22:25:42 <SamB> yeah, they were even too lazy to implement M-expressions
22:25:54 <SamB> maybe they got a bit carred away, though ;-)
22:26:27 <mike-burns> There is no chin behind LISP's beard, only another fist.
22:26:42 <SamB> beard? fist?
22:26:43 <pikhq> The world would be a different place indeed if M-expressions were used.
22:26:46 <SamB> what was the first fist?
22:26:58 <lpsmith> Well, Morse thought that he was going to implement a mechanical encoder/decoder for morse code, but then discovered people could learn to listen to it fairly easily
22:27:08 <mike-burns> Oh, I thought we were talking about Chuck Norris. My mistake.
22:27:51 <SamB> mike-burns: lol, whut?
22:27:51 <lpsmith> And homoiconic syntax is a very nice thing.
22:28:25 <SamB> in Mathematica, you can use an icon to represent itself
22:28:34 <SamB> how's that for homoiconic?
22:28:41 <mike-burns> SamB: (I went to http://chucknorrisfacts.com/ and substituted "Chuck Norris" with "LISP". The stories we were telling sounded like these.)
22:28:55 <SamB> mike-burns: oh
22:29:37 <pikhq> lpsmith: I prefer a lack of syntax. FORTH FOREBER.
22:30:24 <lpsmith> heh,  I've toyed with forth,  never really mastered it though
22:30:35 <pikhq> I've not really done much with it.
22:30:50 <lpsmith> I did a fair bit of RPL programming
22:30:56 <pikhq> But I must humbly respect the sheer brilliance that is its interpreter/compiler design.
22:32:29 <SamB> pikhq: it certainly seems to excell at providing a usable environment in tight-memory situations
22:32:42 <pikhq> Indeed.
22:46:15 <lpsmith> So what do people here think of F#?
22:50:03 <Pseudonym> lpsmith: Mixed feelings.
22:50:37 <Pseudonym> But on the whole, apathy, since I can't use it.
22:51:17 <lpsmith> Pseudonym:  do you program .NET at all?  (I haven't yet)
22:52:55 <Pseudonym> Nope.
22:53:34 <lpsmith> Yeah, mixed feelings here too... On the one hand,  I'm excited that F# is going to be included with VS 2010,   but on the other hand, I'm a little annoyed that it seems that so often industry has to re-invent something before it's "acceptable",  without really adding that much to the reinvention
22:54:08 <lpsmith> Like,  instead of using any number of existing,  and perfectly fine,  64 bit architectures with existing code bases,  we had to go with x64
22:54:41 <Pseudonym> Well, that last one is kind of understandable.
22:54:55 <Pseudonym> Because of the legacy situation,.
22:54:56 <Zao> Itanic, anyone?
22:55:01 <wmealing__> no thanks.
22:55:20 <Pseudonym> While the first-generation Itanium had a poor implementation, IA64 is actually a pretty good design.
22:56:07 <Zao> Pseudonym: It's not like it matters when it can't run <insert killer app/game>.
22:56:36 <Pseudonym> Zao: Here in the world of bioinformatics, we don't care about <game>, and very little about <killer app>.
22:57:04 <Pseudonym> We'd rather be using a decent Itanium than BlueGene.
22:57:11 <Zao> Pseudonym: It's those two things that tend to drive advances though.
22:57:23 <Zao> Well, except big iron of course.
22:57:27 <Zao> Those always evolve in magical ways.
22:58:04 <wmealing__> magical, i thought money.. but i guess if you have enough money.. magic happens.
22:59:29 <copumpkin> hmm, what is the additional condition an integral domain has compared to a commutative ring?
22:59:51 <copumpkin> just that the identities must not be equal?
22:59:53 <shachaf> "Any sufficiently large amount of money is indistinguishable from magic"?
23:00:16 <Pseudonym> copumpkin: That and no zero divisors.
23:00:34 <Pseudonym> You need that to model divisibility.
23:00:38 <copumpkin> damn, I can't represent that easily in my typeclasses :)
23:00:44 <copumpkin> well, I guess I could
23:00:50 <Pseudonym> Can you represent commutativity?
23:00:51 <copumpkin> with some hand-wavey typeclasses
23:00:54 <Pseudonym> If not, don't worry.
23:00:57 <copumpkin> same way :P
23:01:03 <copumpkin> so I'll just keep adding that
23:02:09 <copumpkin> we should be allowed to leave out the 'where' for classes with no methods :P
23:03:34 <Pseudonym> You want typeclass aliases.
23:03:39 <copumpkin> I do :P
23:04:02 <copumpkin> that's precisely what I wanted to work on, and was building myself a nice algebraic hierarchy to compare against
23:04:35 <shachaf> copumpkin: You aren't allowed to leave that out?
23:04:58 <copumpkin> oh, I am!
23:05:00 <copumpkin> how spiffy!
23:05:09 <copumpkin> I could've sworn I'd tried before and it failed
23:05:24 <Pseudonym> Yeah, now that I think about it, you can.
23:05:27 <Pseudonym> You used to have to do:
23:05:35 <Pseudonym> instance (Super c) => Sub c where { }
23:05:50 <Pseudonym> But you needed -fallow-undecidable-instances for that to work.
23:05:59 <copumpkin> :o
23:06:03 <copumpkin> undecidable!
23:06:05 <mae> wow, haskell has more # of users than ruby-lang or rubyonrails
23:06:18 <mae> go fp!
23:06:23 <copumpkin> mae: damn right!
23:06:48 <mgsloan> someone toay was trying to tell me that python is a functional programming language, ugh
23:07:11 <ray> tell him to ask that guido guy
23:07:34 * shachaf has been doing a bit of Python recently, and functional things keep looking ugly. :-(
23:07:36 <ray> the one who hates functional programming
23:07:37 <shachaf> It's awful.
23:07:48 <shachaf> mae: Are you a long-time #ruby-lang-er? Your nick seems vaguely familiar from there, perhaps.
23:07:51 <wmealing__> to be honest, it had enough to get me started, looking deeper.
23:07:52 <copumpkin> he doesn't hate it, it's just that functional programming is "unpythonic" ;)
23:07:55 <wmealing__> has some of the basics.
23:08:10 <ray> lol
23:08:14 <ray> well that's true at least
23:08:34 <soupdragon> so will people stop using python soon?
23:08:41 <wmealing__> doubt it, too practical.
23:08:48 <ray> python? practical?
23:08:49 <Pseudonym> People are still using Bourne shell.
23:08:52 <wmealing__> sadly. yes
23:08:52 <conal> Igloo: thx for realToFrac
23:08:57 <Pseudonym> Hell, people are still using Cobol.
23:09:06 * wmealing__ shudders
23:09:10 <ray> people are still using unix
23:09:18 <Apocalisp> Pseudonym: Which shell do you use?
23:09:32 <Pseudonym> Apocalisp: bash, usually.
23:09:37 <Pseudonym> Which isn't the same as sh.
23:09:46 <Apocalisp> not quite, no
23:09:47 <inimino> ray: as opposed to?
23:09:52 * wmealing__ has fallen for zsh
23:09:56 <ray> uh, as opposed to not using unix
23:10:00 * shachaf would like a better shell than bash.
23:10:03 <shachaf> But it's so hard to switch.
23:10:10 <Pseudonym> I keep meaning to learn ksh, but to be honest, I don't see the advantage over Perl.
23:10:10 * kulakowski seconds zsh
23:10:17 <wmealing__> try out zsh, i bet most of your bash tricks work.
23:10:20 <Apocalisp> wmealing__: What's the thing with zsh?
23:10:31 <shachaf> Even in bash-compatibility mode things are slightly off.
23:10:49 <wmealing__> built in tcp/ftp functions.. nice things for me.
23:11:02 <Nafai> ray: Python is very practical, in that it lets you get things done quickly, especially because of the large number of libraries
23:11:05 <wmealing__> it has another trick pre_cmd that won it over for me, that allows you to execute something before each command.
23:11:20 <shachaf> Apocalisp: It does things bash doesn't.
23:11:25 <wmealing__> which in my case was creating a shell variable...
23:11:25 <Nafai> I used zsh for a while, but found I never used anything specific to it, so I switched back to bash
23:11:42 <wmealing__> so every shell had the same environment variable no matter where i changed it.
23:11:47 <inimino> ray: that's not an alternative if you need to use a computer
23:12:41 <ray> i don't know how to respond to that
23:13:11 <copumpkin> I want to be able to subtract properties(Field) from properties(IntegralDomain) :P
23:13:36 <copumpkin> someone needs to encode those in a nice machine-reasoning'able format
23:13:44 <shachaf> ray: What do you recommend that is the best compromise between usability and elegance?
23:14:15 <Apocalisp> I like Windows Powershell, me.
23:14:24 <ray> i don't compromise either when i'm using windows
23:14:30 <ray> actually, that's not true, i do compromise both
23:14:37 <ray> i ssh out to a unix box
23:14:37 <wmealing__> people still use windows ?
23:14:41 <shachaf> Ugh, Windows is your alternative?
23:14:46 * shachaf sticks with UNIX.
23:14:48 <wmealing__> i'm sure it boots, but its usable ?
23:14:55 <Apocalisp> not out of the box
23:15:04 <inimino> ew, Windows
23:15:09 <shachaf> ray: If you actually use UNIX, what's the point?
23:15:29 <Apocalisp> you have to know how to brush off the cooties and install the productivity iron
23:15:33 <ray> i'm consistently surprised at how tame the lynchings for using windows are in haskell channels
23:15:39 <Nafai> Windows is so freaking hard to use and maintain
23:15:49 <ray> i still get lynched, but it's like a friendly lynching
23:16:02 <Nafai> ray: I'm sure you have good reasons :)
23:16:08 <Apocalisp> Nafai: Hard to maintain? Nonsense. Reinstall every year or so :)
23:16:33 <Nafai> Apocalisp: Right, and manually check for and download and install updates for non system software, etc etc etc :)
23:17:09 <ray> nafai: i'm unemployed, and i *still* don't want to waste my time
23:17:15 <inimino> and configure your firewall, and install everything you need to use from various websites, etc, etc
23:17:49 <Nafai> ray: Right, which is why I run Linux.
23:17:54 <inimino> and then after all that work you're still on Windows
23:18:02 <Nafai> ray: It took my 5 hours the other afternoon to get my wife's XP machine up to date
23:18:03 <wmealing__> it truthfully doesn't matter
23:18:12 <Nafai> ray: It takes me minutes a day with Ubuntu
23:18:12 <wmealing__> xp's end of life
23:18:53 <ray> i spent years in the linux cult, by the way
23:19:10 <Apocalisp> Linux cultist, right here.
23:19:10 <ray> it was probably a good thing on the whole
23:19:24 <soupdragon> linux is a waste of time?
23:19:29 <ray> i'm now immune to cult brainwashing, and i have potentially useful arcane unix knowledge
23:19:46 <Nafai> I don't think I'm brainwashed
23:19:46 <inimino> that's probably why you get lynched :-)
23:19:50 <shachaf> ray: Immune, huh?
23:20:03 <Apocalisp> silverlight looks nice...
23:20:03 <inimino> Nafai: ah, but that's just what a brainwashed person would say
23:20:04 <ray> cults seem to be a once-a-lifetime thing
23:20:08 <Nafai> I'm just comparing my own experiences of running Linux vs. Mac OS X vs. Windows and found what works best for me and makes sense
23:20:29 <shachaf> ray: I have used Windows and occasionally continue to do so. I am fairly competent in it.
23:20:31 <Apocalisp> Oh no! I said that out loud. I couldn't... help... myself...
23:20:39 <shepheb> I suppose the cult experience ending in Windows is better than Kool-Aid, marginally.
23:20:52 <shachaf> It has some advantages, definitely. With that said, UNIX is still much more pleasant for me to spend time in.
23:21:11 <Pseudonym> Apocalisp: There are plenty of things that _look_ nice.
23:21:25 <wmealing__> when you get down and dirty, they suck! like hfs+ fsync()
23:21:59 * wmealing__ tells the voices to be quiet.
23:22:37 <shachaf> ray: When using Windows, I constantly have the annoying feeling that I can't mess with things.
23:22:51 <ray> is that because you're using it on someone else's computer?
23:22:56 <shachaf> Nope.
23:23:04 <wmealing__> I get the feeling i can't fix it, when it breaks.
23:23:05 <Pseudonym> I get the feeling that I'm not really in control.
23:23:06 <shachaf> Under appropriate UNIXes, if I feel like it, I can get almost anything working the way I want it to.
23:23:27 <shachaf> For what it's worth, this feeling has been strongest for me in Mac OS ~7. :-)
23:23:35 <Apocalisp> hah
23:23:36 <Apocalisp> same here
23:23:48 <shachaf> Or maybe a TI-83, though I did not investigate those thoroughly.
23:23:59 <soupdragon> I get the 'Program has performed an illegal operation'
23:24:01 <ray> i liked mac os 7 too, but not so much ti-83s
23:24:17 <ray> i had a better model calculator
23:24:22 * wmealing__ googled haskell operating systems for fun.. and there are two.
23:24:44 <Nafai> HP 48-G+ was a nice calculator
23:24:47 <inimino> House and ...
23:25:09 <cizra> wmealing__: IIRC there was a Haskell Machine, implemented in hardware
23:25:21 <holmak> is Hoogle down for anyone else?
23:25:33 <joga> the best I got was when I tried to fix vista home premium of my friend's, where both the internal and external sound card suddenly died. I knew the reason, and where to fix it, but when I got to the settings it told me that this version of vista is too cheap and you gotta have ultimate to mess with the settings
23:25:59 <joga> off to service it went then
23:26:02 <wmealing__> cizra, no kidding.
23:26:07 <shachaf> holmak: For me.
23:26:23 <wmealing__> cizra, url ?
23:26:37 <cizra> wmealing__: dunno
23:26:42 <Pseudonym> BTW, I think we're officially into #haskell-blah territory.
23:26:59 <shachaf> Pseudonym: That seems accurate. :-)
23:27:02 <Pseudonym> I don't mean to get all EFNet #math with you guys, but it's just a suggestion.
23:27:07 * coCocoa is saving himself for the Reduceron III...
23:27:59 <wmealing__> a little bit of off topic builds community.
23:29:18 <cizra> wmealing__: Something like this? http://www.cs.york.ac.uk/fp/reduceron/
23:31:21 <wmealing__> neat.
23:32:16 <cizra> It's not what I meant, though.
23:41:56 <mmorrow> copumpkin: you don't even have to write the "where" for instance
23:42:06 <copumpkin> ah nice
23:42:28 <mmorrow> class (Num a, Read a) => C a
23:42:34 <mmorrow> instance C Int
23:42:44 <copumpkin> cool
23:42:51 <copumpkin> haskellgrammar++
23:43:53 <Matt> JackieJac
23:43:54 <Matt> JackieJac
23:43:54 <Matt> JackieJac
23:44:27 * copumpkin is still trying to figure out how to get at the two operations for his two-operation classes :P
23:44:56 <copumpkin> oh I guess I'll have to do it the ugly way
23:46:40 <mmorrow> copumpkin: what do you mean?
23:46:50 <mmorrow> "how to get at the two operations for his two-operation classes"
23:46:51 <mmorrow> ?
23:47:19 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6957#a6957
23:47:31 <copumpkin> seems ugly :)
23:48:04 <copumpkin> also, not sure at what point to introduce names like those
23:48:06 <mmorrow> ah, yeah i've tried to do something like that before ending in quitting
23:48:28 <mmorrow> (and please please call in "Ring":)
23:48:38 <copumpkin> ?
23:48:42 <mmorrow> Rng make me think random number generator
23:48:45 <copumpkin> oh
23:49:05 <copumpkin> Rng is a real structure!
23:49:08 <copumpkin> it's not quite a ring
23:49:12 <mmorrow> oh
23:49:22 <copumpkin> http://en.wikipedia.org/wiki/Rng_(algebra)
23:49:37 <copumpkin> it's probably gratuituous to include it though :P
23:49:57 <mmorrow> weird, never heard of that before
23:50:38 <mmorrow> oh, ok
23:50:47 <mmorrow> "Many authors do not require rings to have a multiplicative identity"
23:50:55 <mmorrow> "so the concept discussed here is just what these authors call a ring."
23:51:41 <mmorrow> in this commutative algebra class i took it was fixed at the beginning that "all rings we talk about are commutative and with unity"
23:53:08 <mmorrow> copumpkin: i guess this just speaks to how useful class aliases would be
23:55:57 <copumpkin> yup :)
23:56:52 <copumpkin> my plan was to write a preprocessor à la she to implement simple context aliases and associated contexts
23:57:13 <copumpkin> and I wanted a use case so I wrote myself an epic set of algebraic typeclasses
23:57:32 <mmorrow> nice
23:58:00 <copumpkin> doing so makes me wish for some nice elegant way of editing grammars
23:58:09 <mmorrow> (also, "Rng" seems to be some particular author's creation, so i wouldn't use it..)
23:58:15 <copumpkin> fine fine :P
23:58:20 <mmorrow> heh
23:58:24 <copumpkin> I'd personally never heard of it until I saw it on wikipedia :)
23:58:31 <mmorrow> copumpkin: are you hacking haskell-src(-exts)?
23:58:40 <copumpkin> yeah, that was the plan
23:58:53 <copumpkin> just need to make some minor changes to support the syntax
23:59:05 <mmorrow> copumpkin: i hacked haskell-src for the input to my thing, and it was somewhat painful, but i'm glad i did it
