00:04:14 <Meady> guys im loosing creativity
00:04:20 <Meady> give me something intermediate to make
00:04:42 <Peaker> Meady: after I left the other day, did someone finish off explaining what a Monad is about?
00:05:15 <Meady> yeah
00:05:16 <Meady> well
00:05:22 <Meady> I had Cale explain the IO
00:05:43 <Meady> HOw we assign using >> but then we went over how we would write it with DO instead of >> and then have the compiler convert
00:06:35 <Peaker> Meady: well, did you understand that Monad can be seen as a generalization of the idea of a statement list in other languages?
00:07:17 <Cale> I mostly talked about IO specifically rather than monads, but I touched on some of how the fact that it's a monad is useful.
00:07:58 <Cale> http://www.reddit.com/r/reddit.com/comments/8wya7/moir%C3%A9_is_cool_gif/c0ap1j2 -- haha
00:10:53 <Meady> well i understood what you were saying about stacking statments
00:11:09 <Meady> do a small example then ask me to explain certain thing
00:11:10 <Meady> s
00:11:11 <Meady> ?
00:18:41 <Cale> Meady: Let's take a look at one of my favourite functions for monads, sequence. Perhaps you can try implementing it from a description (restricted to IO, if you're more comfortable that way)
00:19:19 <Cale> sequence takes a list of actions, and produces an action which when run, runs each of the actions that was in the list, collecting up and returning a list of the results.
00:20:11 <Cale> So, for example, if I write, oh...
00:20:53 <Meady> ok
00:20:54 <Cale> sequence [getLine, getLine, getLine]
00:21:05 <Meady> It will return [result of getline, same, same?
00:21:10 <Cale> then it will get three lines of text from the user, and give me a list of the results
00:21:20 <Meady> ok cool
00:21:24 <Cale> Since sequence is actually in the Prelude, you can try it :)
00:21:27 <Meady> Why would we use that?
00:21:36 <Meady> when we can just put it on next line
00:22:00 <Cale> Well, this means that if we can construct a list of the actions we want to perform, then we can perform them all.
00:22:07 <Cale> It's a sort of primordial loop.
00:22:10 <Peaker> Meady: sequence can be applied to a runtime-generated list of statements, not just a compile-time list of statements under a "do"
00:22:19 <dibblego> @type replicateM
00:22:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
00:22:28 <Cale> sequence [print n | n <- [1..10]]
00:22:31 <Cale> try that one :)
00:22:39 <Meady> but how often in programming do you generate custom functions during run time
00:22:48 <Cale> Meady: In Haskell, constantly.
00:23:03 <Cale> Functions are an important kind of data.
00:23:12 <Cale> (as are IO actions)
00:23:14 <Gracenotes> hmmm... partial application can create "custom" functions, in a sense
00:23:48 <Cale> Meady: this will give us a way to write many loop-like control structures as well
00:24:04 <Meady> hmm
00:24:06 <Cale> Meady: remember our function the other day for just running an action n times?
00:24:18 <Cale> Meady: Well, there's a list function called replicate
00:24:23 <Cale> > replicate 5 "hello"
00:24:24 <lambdabot>   ["hello","hello","hello","hello","hello"]
00:24:34 <Cale> It just makes a list of the same thing over and over
00:24:49 <Cale> So once we have sequence, we can write that other function:
00:24:59 <Cale> times n x = sequence (replicate n x)
00:25:15 <Cale> Or, as this is called in the library, replicateM
00:25:50 <Cale> Basically, to construct a loop, we just have to get a list of the things we want to do
00:26:01 <Cale> Or, for a more interesting example...
00:26:41 <Cale> a for-each loop available in many languages is a kind of loop where you give it a list of values, and it does some action for each of the values in the list in turn
00:27:16 <Raevel> my ghci ticket was fixed <3
00:27:19 <Cale> In a functional language, it's natural to represent "the thing it does with each of the values" as a function, from the value to the thing to do
00:28:02 <Cale> If we apply that function to each of the elements of our list, we get a list of the actions we want to do
00:28:02 <Peaker> @type runMaybeT . sequence
00:28:03 <lambdabot> Not in scope: `runMaybeT'
00:28:10 <Cale> and then sequence turns that list into a loop
00:28:11 <Peaker> lambdabot ought to import MaybeT
00:28:27 <Peaker> MaybeT is really useful (for loop termination support, etc)
00:28:43 <Peaker> EitherT could be nice too (ErrorT has irrelevant restrictions)
00:29:28 <Cale> Meady: did that all make sense?
00:29:46 <Cale> Meady: you're being quiet, so it's hard to tell if I'm saying things in a way that makes sense.
00:30:32 <JN> Look, it’s really quite simple. A monad is just a monoid in the category of endofunctors on Hask. See?
00:30:42 <Cale> JN: :)
00:30:51 <JN> Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *but* the apples are carried around anyway, and you just take what you need.
00:30:57 <copumpkin> :o
00:31:21 <copumpkin> not a unicorn? :(
00:31:26 <copumpkin> nobody likes my analogies
00:31:37 <flux> jn, thank you! that made it snap for me!
00:31:46 <JN> :)
00:32:00 <JN> I'm reading monad tutorials
00:32:05 <JN> those were a few gems
00:32:08 <Cale> copumpkin: maybe the apples are being carried by a drowning unicorn?
00:32:19 <copumpkin> maybe, but that doesn't use the unicorn's horns
00:32:21 <copumpkin> whereas mine does
00:32:32 <Peaker> The "box" analogy is really simple :-)
00:32:46 <Cale> copumpkin: well, that's easy, the unicorn stabs the apples with its horn
00:32:51 <copumpkin> aha
00:33:03 <copumpkin> but it's not nearly as rude as my one :(
00:33:16 <Gracenotes> hm... is there an applicative cat?
00:33:16 <Meady> Cale im just trying to enforce the concept
00:33:36 <Saizan> copumpkin++
00:33:44 <Gracenotes> monadic cat is getContents >>= putStr
00:33:48 <copumpkin> :P
00:33:58 <Cale> Meady: So supposing that we have sequence, we can write a for-each loop, would you like to see me do that?
00:33:59 <JN> I was reading the online haskell book and got tired of them mentioning monads every 3 paragraphs without daring to explain what it is.. as if it's some mystical concept that shouldn't be uttered.. and every 10th comment saying "well it's just monad this monad that.." get's tiring really quickly
00:34:15 <Gracenotes> given that the application in cat is effectful, I'm not sure applicative covers it
00:34:17 <maxote> JN, 3x3x3-1=26 containers provide apples and 1 container in the centre provides a nuclear trash.
00:34:41 <Meady> yeah ok
00:34:46 <Meady> Im 100% with you so far
00:34:49 <Cale> okay
00:34:51 <Meady> http://www.dixons.co.uk/product.php?sku=652743&camp_id=froogle#productInformationSection
00:34:55 <Meady> Guiys any opinion on that
00:35:04 <copumpkin> lol
00:35:12 <Mobsan> Good morning
00:35:41 <JN> so far, I like this one best: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html .. though too lazy/tired to read through it all right now
00:36:06 <maxote> can be a lazy language monadless?
00:36:06 <Gracenotes> hmmm... Advent... I have never heard of them...
00:36:10 <Cale> Meady: So, our for-each loop's type will be: forEach :: [a] -> (a -> IO b) -> IO [b]
00:36:10 <ivanm> @seen matthew-_:
00:36:10 <lambdabot> matthew-_: is in #haskell-blah, #ghc and #haskell. I don't know when matthew-_: last spoke.
00:36:22 <Saizan> JN: that's what made them click for me too
00:36:37 <ivanm> @tell matthew-_ someone just found a bug that had been in graphviz from its first ever release! :o
00:36:37 <lambdabot> Consider it noted.
00:36:47 <Cale> Meady: It takes a list of values (of type a), and a function which specifies what to do given a value of type a, having a result of type b
00:36:52 <Meady> ok with you
00:37:01 <ivanm> Cale: want to work on graph stuff now?
00:37:05 <Cale> and it gives an action which is going to run them all and produce a list of values of type b
00:37:11 <JN> I read that one after the winstanley (1999) piece.. they take a similar approach, but the former one is more approachable for me
00:37:16 <Cale> ivanm: okay, once I'm finished here :)
00:37:21 <ivanm> fair enough ;-)
00:37:23 <Gracenotes> maxote: yes, http://en.wikipedia.org/wiki/Clean_(programming_language)
00:37:42 <Gracenotes> it uses typing magic instead of monads to sequence things in IO
00:38:10 <Gracenotes> particularly http://en.wikipedia.org/wiki/Uniqueness_type
00:38:15 <ivanm> is there any other language that _explicitly_ uses monads?
00:38:24 <Cale> Meady: So...  forEach xs f =  ... map f xs ...  -- we can apply the function we have to each of the elements of the list, getting us a list of type [IO b]
00:38:42 <Cale> and then we apply sequence to that to get a complete loop
00:38:53 <Cale> Meady:  forEach xs f = sequence (map f xs)
00:39:28 <Cale> and that'll allow us to write something like:
00:39:51 <Gracenotes> hm... you can make monads in many other languages. f# has them called "workflows"
00:40:17 <Cale> forEach [1..5] $ \x -> do putStrLn (concat ["Enter line ", show x, ":"]); getLine
00:40:20 <JN> I barely know what a monad is (and will forget in about 15 minutes) .. :)
00:40:25 <ivanm> Gracenotes: yes, but do they explicitly use them for their IO, etc.?
00:40:34 <copumpkin> JN: do you understand functors or applicatives?
00:40:34 <ivanm> or just have it as a way of thinking about some of their functions, etc. ?
00:40:34 <Cale> JN: Did you read any of my tutorials?
00:41:05 <JN> cale:  not sure.. I didn't read very many.. brain tired. must rest.
00:41:26 <dancor> what's the best web framework if i'm afraid of being tied to MACID
00:41:43 <osfameron> MACID?
00:41:48 <dancor> in happs
00:41:55 <Gracenotes> ivanm: they are not required for IO, in theory and in practice. After all F# is strict.
00:41:58 <ivanm> Mega-Acid? ;-)
00:42:00 <Cale> JN: http://www.haskell.org/haskellwiki/Monads_as_Computation is one of them, which I think explains them in a reasonable way from a programming perspective
00:42:02 <Saizan> dancor: still happstack, you don't have to use MACID
00:42:03 <ivanm> Gracenotes: *nod*
00:42:33 <Gracenotes> although, I don't know F#, so no particulars u-u
00:42:34 <Cale> ivanm: no, except maybe for some Haskell derivative research languages
00:42:34 <JN> Cale:  thanks, I'll have a look at that later
00:42:36 <dancor> Saizan: even tho MACID is the primary selling point on the happstack website?
00:42:46 <ivanm> Cale: *nod*
00:43:23 <Cale> Meady: did you follow that?
00:43:32 <JN> copumpkin:  I think a functor is an objectified function that you can pass around like data.. don't know what applicative is
00:44:02 <copumpkin> JN: the functor is actually the type constructor I think
00:44:38 <JN> I don't get it
00:44:55 <osfameron> googling: happs macid  doesn't give all that much
00:44:57 <Cale> copumpkin: right... the type constructor equipped with fmap :)
00:45:02 * osfameron checks the happs website
00:45:20 <dancor> @remember putnam The programmer _is_ the code.
00:45:20 <lambdabot> I will remember.
00:45:28 <Cale> JN: Basically, when you refer to something as a monad, it implies that something is a type constructor.
00:45:34 <Cale> (or a functor)
00:45:35 <copumpkin> yeah, fmap is there to allow us to state that it's a homomorphism?
00:45:36 <osfameron> dancor: is that "HAppS-State â€” Global in memory Haskell state with ACID guarantees" ?
00:46:03 <Cale> copumpkin: Not only that, but it's half of the definition of what the functor is at the category theoretic level.
00:46:04 <dancor> osfameron: ya
00:46:14 <dancor> tho everything is happstack nowadays
00:46:31 <osfameron> dancor: are you forced to use it?  I mean, can you choose to use a different model?
00:46:33 <JN> cale:  as a newcomer to haskell, I'm put off by the circular definitions..  I'd like to see a single sentence that says in plain terms what a monad is, without saying the word monad. :)
00:46:42 <Cale> copumpkin: In category theory, a functor F gets applied both to objects of the category and to arrows in it, and fmap is our way of saying what it is that it's doing to the arrows :)
00:46:43 <JN> or monoid or anything that starts with mon
00:46:48 <copumpkin> yeah :)
00:46:52 <Cale> JN: okay
00:46:56 <copumpkin> that's what I meant, but I probably said it wrong :)
00:47:01 * osfameron is a bit scared of HAppS, guess I need to play with it... the website description is a little daunting though
00:47:03 <dancor> osfameron: i'm not forced to use it, i'm just wondering if there is something better if i'm eschewing what appears to be the main selling point of happstack
00:47:09 <shachaf> JN: A monad is something that satisfies the monad laws. :-)
00:47:15 <Cale> JN: Do you know what a combinator library is?
00:47:17 <JN> ha!
00:47:18 <shachaf> Oh, whoops.
00:47:27 <shachaf> I tried. :-(
00:47:29 <ivanm> Cale: a library of combinators?
00:47:31 <shachaf> But the laws are very simple.
00:47:35 <ivanm> a place where you can go to borrow combinators? ;-)
00:47:39 <Cale> JN: Or, failing that, an EDSL?
00:47:41 <shachaf> (And probably unhelpful here.)
00:47:53 <osfameron> ivanm: hehe
00:48:10 <osfameron> nothing about EDSL suggests it has to be monadic though, does it?
00:48:10 <dancor> maybe something more minimal and more scalable, idk
00:48:28 <Meady> ok cale whats the second arguument
00:48:31 <JN> cale:  I haven't heard of either of those.
00:48:35 <shachaf> JN: I think the best way to get an intuitive understanding here is to look at specific examples first and generalize later.
00:48:39 <Meady> foreach xs(list) f(function)?
00:48:51 <Cale> Meady: yeah
00:48:53 <Meady> map already does a loop and applies a function to each result
00:48:57 <Meady> why do for each aswell
00:49:24 <shachaf> That is, figure out what Maybe, State, [], and so on have in common. A monad is approximately that. :-)
00:49:41 <JN> question.  is Maybe a type or a monad
00:49:49 <Cale> JN: okay, basically, in functional programming, we like to write libraries which define some primitive objects, and then lots of interesting ways of combining those objects such that the end result is a library which looks a little like a programming language of its own.
00:49:51 <copumpkin> JN: it's a type constructor
00:49:54 <Meady> Cale that would be running a loop twice?
00:50:00 <shachaf> It's a type constructor. And also a monad.
00:50:01 <copumpkin> JN: and is an instance of monad
00:50:04 <Cale> JN: Maybe is a type constructor, which happens to be a monad.
00:50:09 <copumpkin> JN: among other things :)
00:50:27 <Cale> Meady: because map will just give you a list of actions
00:50:38 <JN> what makes Maybe a monad
00:50:41 <Cale> Meady: you need to sequence them together into a single action
00:50:46 <JN> is it the functions that are defined for that type?
00:50:52 <Cale> JN: yes
00:51:00 <shachaf> JN: instance Monad Maybe where ... -- that satisfies the monad laws. :-)
00:51:17 <Cale> JN: Basically, monads are type constructors with a particular interface of functions available.
00:51:34 <JN> ok.  so a monad is a type which has a few specific functions defined.. bind, return, .. something else
00:51:42 <Cale> JN: bind and return will do it
00:51:51 <Cale> and from those, you get lots of other interesting things
00:51:59 <shachaf> Or join/fmap/return. :-)
00:52:05 <copumpkin> JN: Monad is just another typeclass, btw (it has some associated syntax in haskell, but isn't special in any other way). It's like Eq or Num or Ord
00:52:14 <shachaf> (Which is in my opinion easier to understand think about at first.)
00:52:25 <copumpkin> yeah, I prefer the join/fmap/return view
00:52:25 <Cale> shachaf: I often agree with that :)
00:52:38 <Cale> I think it depends on which monad you're talking about :)
00:52:46 <JN> ok.  so is Monad just something that's defined on top of haskell, or is is it intrinsic to haskell implementation.  (I think that IO is probably dealt with specially, but ignoring that)
00:52:56 <shachaf> JN: Just defined on top.
00:53:03 <shachaf> It happens to be useful enough that there's some syntax sugar for it.
00:53:05 <taruti> Is it possible to have one flag imply an another with Cabal configurations?
00:53:10 <copumpkin> JN: it's defined normally in haskell, but as you say, IO does have special implementations of bind
00:53:11 <shachaf> And some basic things like IO are defined in terms of it.
00:53:14 <Cale> JN: ignoring the fact that IO happens to be a monad, and the fact that we have some syntax sugar, there's nothing built-in about it
00:53:19 <JN> copumpkin.. shachaf.  ok that's very helpful to know.  they should just come out and say that, instead of making it seem so mystical
00:53:32 <Cale> JN: there are a lot of really really bad monad tutorials
00:53:35 <shachaf> Yes! You should write a monad tutorial when you're through with all this!
00:53:40 <shachaf> A monad tutorial to end all monad tutorials!
00:53:42 <Cale> Noooo!
00:53:43 <JN> yeah.. and I'll say it's like a burrito
00:53:46 <Mobsan> Lol
00:54:06 <dancor> to bind them?
00:54:08 <copumpkin> JN: and if anyone knows about haskell they instantly think of monads as "zomg monads" and make it sound super crazy, when it really isn't that bad :)
00:54:59 <Cale> JN: Basically, because these libraries have a common interface, we can reuse certain functions that often end up having useful consequences
00:55:17 <shachaf> JN: Perhaps you should start with functors. Those are easy to understand. :-)
00:55:20 <shachaf> @src Functor
00:55:20 <lambdabot> class  Functor f  where
00:55:20 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
00:55:20 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]] -- here's what the 'sequence' function does in the list monad
00:55:21 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
00:55:32 <Cale> > sequence [Just 1, Just 2, Just 3]
00:55:33 <lambdabot>   Just [1,2,3]
00:55:40 <Cale> There it is in the Maybe monad
00:55:43 <Cale> > sequence [Just 1, Just 2, Nothing]
00:55:44 <lambdabot>   Nothing
00:55:53 <Cale> and you get Nothing if any of them are Nothing
00:55:59 <Peaker> Cale: perhaps you should use an example that fits in a line's width :)
00:56:04 <Cale> In the IO monad, it chains the actions together end to end.
00:56:18 <Cale> In a parsing monad, it would be the concatenation of parsers
00:56:30 <shachaf> > runWriter $ sequence [tell [1], tell [2]]
00:56:31 <lambdabot>   ([(),()],[1,2])
00:56:52 <Peaker> @type Control.Monad.Maybe.runMaybeT
00:56:53 <shachaf> JN: Monads are really *entirely* a generalization. If you only had one the typeclass wouldn't be useful.
00:56:53 <lambdabot> Couldn't find qualified module.
00:57:25 <shachaf> The useful/interesting thing about them is finding the things that are in common between, say, parsers and IO.
00:57:39 <shachaf> And then generalizing those into functions that can also be used on lists. :-)
00:57:50 <Peaker> shachaf: in that case you'd pass around the class as a functions dictionary :)
00:58:44 <shachaf> Peaker: The point is that it is perfectly conceivable that people would write sequence for, say, both [] and Maybe.
00:58:54 <shachaf> Without seeing that it's essentially the same function.
00:59:58 <Cale> JN: So yeah, basically the idea is that we've captured this one particular common style of library (a specific type of combinator library), and given a name to that style of library and defined a bunch of operations which work on any library which fits that pattern, and do possibly useful/interesting things.
01:00:32 <Cale> JN: Does that make any kind of vague sense, or is it gibberish?
01:00:47 <JN> cale:  that makes perfect sense, and I wonder why people don't explain it that way all the time
01:01:11 <ivanm> Cale: I'm heading off to dinner now, I'll be back later
01:01:16 <Cale> ivanm: ah, okay
01:01:20 <JN> dinner.. g'day mate
01:01:33 <Cale> JN: I don't know. A lot of the monad tutorials are written by beginners who suddenly get the idea, but aren't good at explaining it yet, but don't know this ;)
01:01:45 <Cale> alright, see you too
01:01:46 * shachaf really wishes IRC had some built-in multiuser editor.
01:03:02 <Cale> Another reason for it I suppose is that there are a lot of ways of explaining almost any abstraction, and the explanations which are relevant or understandable to different people are different :)
01:03:26 <shachaf> By the way, my personal advice for understanding monads is reimplementing them yourself. Some people may disagree, but I've often found that helpful.
01:03:40 <shachaf> How would you implement "state" in Haskell? Without monads?
01:04:03 <copumpkin> I'm by no means a CT person (and was even less of one at the time) but I found the simple "triple" explanation nicest
01:05:03 <shachaf> copumpkin: I am surely less of a CT person than you. :-) What is that?
01:05:42 <copumpkin> just the functor + two NTs definition
01:05:44 <hydo_> I'm trying to install happstack-data (assuming this is general cabal/ghc related which is why I'm not asking in #happs) and it keeps failing on an unknown symbol in syb-with-class.  I've gone so far as to completely delete ghc from my system, reinstall, set up cabal-install, and try to install it from cabal and darcs and I get the same error.
01:06:02 <JN> any reason why >>= is called bind?
01:06:02 <hydo_> Any idea what I can do to fix it
01:06:18 <shachaf> JN: Because of what it does. :-)
01:06:23 <copumpkin> JN: the haskell founders were into bondage
01:06:32 <JN> got it
01:06:59 <Peaker> Haskell is a B&D language, technically? :)
01:07:02 <shachaf> I would suggest that you start with Functor. Are you familiar with the type class?
01:07:22 <JN> is there a reference of haskell operators with their conventional pronunciations (i.e., >>= is called "bind")
01:07:35 <dibblego> no but that would be a darn good idea
01:07:51 <JN> I find myself not even being able to audibly read code.. it's quite awkward
01:07:52 <shachaf> Huh.
01:07:58 <shachaf> Er, "Ha".
01:08:02 <mgsloan> I'm going to make a functional language where the monad operators are BIND, TORTURE, and KILL
01:08:03 <shachaf> Everyone makes up their own pronunciations.
01:08:15 <JN> "f ..um.. .. greater-than-greater-than-equals ... m"
01:08:20 * copumpkin inches slowly away from mgsloan
01:08:22 <shachaf> It would be fun to compare sometime.
01:08:43 <shachaf> I still read "!!" as "not not".
01:08:55 <JN> shachaf:  I am not familiar with Functor
01:09:02 <copumpkin> I just want !!!
01:09:10 <copumpkin> > fmap (+1) (Just 5)
01:09:11 <lambdabot>   Just 6
01:09:14 <shachaf> JN: It's something which can be mapped over.
01:09:18 <copumpkin> > fmap (+1) Nothing
01:09:19 <lambdabot>   Nothing
01:09:21 <shachaf> @instances Functor
01:09:21 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
01:09:29 <shachaf> The obvious example is []:
01:09:34 <shachaf> > fmap (+1) [1,2,3]
01:09:35 <lambdabot>   [2,3,4]
01:09:43 <shachaf> But this also works on Maybe, as copumpkin showed.
01:09:56 <copumpkin> :t bimap
01:09:57 <lambdabot> Not in scope: `bimap'
01:10:04 <shachaf> > fmap (+1) (*2) 3 -- I shouldn't do this!
01:10:05 <lambdabot>   7
01:10:09 <mgsloan> fyi, Bind, Torture, and Kill is an industrial song by Suicide Commando
01:10:12 <shachaf> Ignore the above. :-)
01:11:09 <shachaf> This also works on, say, IO:
01:11:12 <shachaf> @ty getLine
01:11:13 <lambdabot> IO String
01:11:16 <shachaf> @ty fmap read getLine
01:11:17 <lambdabot> forall a. (Read a) => IO a
01:11:33 <shachaf> Anything which can "contain" a value (or values) that you can map over.
01:11:44 <shachaf> So fmap's type is:
01:11:46 <shachaf> @ty fmap
01:11:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:12:03 <shachaf> Does this much make sense?
01:12:15 <mgsloan> Kill would be join, because it "kills" one of the nestings ;)
01:13:01 <JN> what is @ty
01:13:05 <shachaf> @type
01:13:06 <lambdabot> on the commandline:
01:13:06 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
01:13:06 <lambdabot> <no location info>: not an expression: `'
01:14:02 <JN> confused by the output of @ty fmap.   not so good at reading those
01:14:11 <shachaf> Ignore the first part. :-)
01:14:32 <shachaf> It says: Assuming that f is a Functor, fmap gets a function from a to b and returns a function from f a to f b.
01:14:51 <shachaf> (Maybe is a Functor, so fmap can be :: (a -> b) -> Maybe a -> Maybe b.)
01:16:17 <shachaf> JN: Does that make sense?
01:16:21 <JN> ok. now it makes sense
01:16:30 * shachaf wonders if he is taking up too much room in the channel.
01:16:58 <Peaker> JN: perhaps the first confusing thing about the Functor class, if you understand classes like Eq, is that the type instance of the class is a type CONSTRUCTOR, and not a type.  "f" is always applied to one type to form a regular type that can be used in functions
01:17:36 <Peaker> so (a -> b) -> f a -> f b        "f" is a type-constructor or "type-level function" that takes "a" or "b" here, and creates a type like (Maybe a) or (Maybe b),  or [a] or [b]
01:17:41 <shachaf> Yes, "f" is like "Maybe"; it needs an argument.
01:21:11 <shachaf> JN: So does that make sense?
01:21:13 <JN> so what characterizes a functor.. what makes Maybe a functor
01:21:40 <dibblego> the ability to provide a (a -> b) -> Maybe a -> Maybe b function
01:21:47 <shachaf> Yep.
01:21:57 <shachaf> There are a couple of laws fmap need to satisfy to "count".
01:22:17 <athos> fmap (f . g) = fmap f . fmap g
01:22:21 <athos> or something like that
01:22:31 <shachaf> That's one, and fmap id = id.
01:22:35 <dibblego> yes and fmap id == id
01:22:41 <athos> ok :)
01:22:42 <shachaf> Both make sense. :-)
01:22:57 <shachaf> So now you know what a Functor is.
01:23:01 <shachaf> Every Monad is a Functor.
01:23:47 <dancor> which is the cooler client-side haskell: ycr2js or HSPClientSide?
01:25:05 <shachaf> JN: Does this make sense? (I hate to keep asking that, but no response at all might just mean that you've disappeared.)
01:25:35 <JN> it's all fuzzy for me right now.. actually it's late and my brain is just tired.. I appreciate the help
01:26:20 <copumpkin> JN: it basically just is the most meaningful definition of "mappable" :)
01:26:58 <copumpkin> you'd expect map f . map g on a list to be equivalent map (f . g)
01:27:12 <copumpkin> same on any other functor
01:31:05 <JN> how do you read <-
01:31:16 <JN> how do you pronounce: <-
01:31:26 <shachaf> "*grunt*"
01:31:38 <copumpkin> I've never really thought about it
01:31:41 <JN> how many different grunts do you have for haskell
01:31:44 <shachaf> (I seem to pronounce a lot of Haskell operators that way, oddly enough.)
01:31:50 <copumpkin> and never speak to anyone aloud about hakell
01:32:15 <shachaf> However, <- is essentially syntax sugar for >>=.
01:33:47 <shachaf> (To tell the truth, if I pronounced ">>=" to someone without thinking about it, I would probably say "bind-bind-equals".)
01:34:04 <copumpkin> :o
01:34:49 <shachaf> (I would also randomly pronounce things like "<" and "#" in Hebrew.)
01:36:02 * doserj reads "x <- blah" as "x from blah"
01:38:37 <Zao> shachaf: T_PAAMAYIM_NEKUDOTAYIM
01:38:46 <Zao> PHP's best error code.
01:38:59 <copumpkin> :o
01:41:41 <athos> @users
01:41:41 <lambdabot> Maximum users seen in #haskell: 658, currently: 577 (87.7%), active: 12 (2.1%)
01:41:51 <athos> oi
01:42:08 <athos> seems like we're in a down swing
01:42:44 <Raevel> :-(
01:46:33 <JN> time to sleep.. thanks for the help guys
01:47:02 <JN> good night :)
01:50:52 <Meady> Hey guys http://porg.es/blog/simple-socket-programming-with-haskell
01:50:57 <Meady> Anyone wana go through some stuff with me on that
01:51:07 <Peaker> I have a minute or two (not much more)
01:51:18 <Meady> input <- untilM   -- get input of 'c' or 's'
01:51:18 <Meady> 		(\x -> (not $ null x) && toLower (head x) `elem` "cs")
01:51:18 <Meady> 		(putStr "Client or server? " >> getLine)
01:51:26 <Meady> here, hes using two stules of coding :S
01:51:29 <Meady> style*\
01:51:35 <Peaker> I don't like that code because it uses hClose explicitly and not with bracket
01:51:54 <Meady> here, input <- IO assigns result to input, yet 2 lines down he uses >> instead?
01:52:19 <Peaker> its very common to mix do/>> styles
01:52:31 <Peaker> you use do when its nicer, and (>>) for trivial statement concats
01:52:34 <Peaker> (in a single line)
01:53:08 <Meady> Ok secdonly
01:53:15 <Meady> (\x -> (not $ null x) && toLower (head x) `elem` "cs")
01:53:17 <Meady> still dont get that
01:53:24 <Peaker> or (>>=) when no lambda is necessary
01:53:31 <Peaker> (e.g:  getLine >>= putStrLn  is common)
01:53:31 <Saizan> you can always replace "a >> b" with "do a; b" if that makes it easier to read
01:54:40 <Saizan> Meady: what confuses you about that?
01:54:49 <Peaker> Meady: "do" doesn't abstract or hide anything, its just a syntactic convenience, and used as such
01:54:55 <doserj> > (\x -> (not $ null x) && toLower (head x) `elem` "cs") "server"
01:54:56 <lambdabot>   True
01:54:56 <Meady> \x ->
01:54:59 <Meady> dont understnad that
01:54:59 <Saizan> ah
01:55:00 <doserj> > (\x -> (not $ null x) && toLower (head x) `elem` "cs") "???"
01:55:01 <lambdabot>   False
01:55:18 <Saizan> "\x -> ..." is called a lambda expression
01:55:31 <Saizan> it's used to make an anonymous function on the spot
01:55:57 <Saizan> it's the same as defining "foo x = ..." and then use foo there
01:56:46 <Saizan> > let inc x = x + 1 in inc 4
01:56:47 <lambdabot>   5
01:56:55 <Saizan> > (\x -> x + 1) 4
01:56:55 <lambdabot>   5
01:57:02 <Zao> > (\x y -> x * y + 3) 42 2
01:57:03 <lambdabot>   87
02:00:50 <Raevel> I'm going to use HTTP to download files and save them to disk, and I was wondering what size chunks i should use. My guess is that it won't matter since the HTTP connection will most likely be the bottle neck, but in general, any thoughts?
02:01:12 <dibblego> is JohnMacFarlane (author of Codec.Archive.Zip) here?
02:01:14 <Raevel> I hope that made sense.
02:01:37 <ivanm> Cale: I'm back, if you're still here
02:01:43 <ivanm> dibblego: I don't think so
02:05:51 <fbr> hello
02:06:58 <wmealing> hey
02:07:10 <wmealing> someone pointed me to a book here last week, something like "oh hai can i has haskell"
02:07:30 <dancor> wmealing: http://www.learnyouahaskell.com/
02:07:30 <dancor> ?
02:07:33 <wmealing> thanks it
02:07:34 <wmealing> thanks
02:07:41 <wmealing> ive ordered real world haskell
02:07:49 <wmealing> just waiting now
02:07:57 <dancor> nice
02:08:04 <wmealing> thought i'd get a bit of a head start
02:08:45 <Raevel> wmealing: seen http://book.realworldhaskell.org/read/ ?
02:09:14 <wmealing> same book ?
02:09:20 <Raevel> yep
02:09:29 <wmealing> ok, nice.
02:10:22 <wgsilkie> What's a breif way to create a 2*2 matrix filled with the same thing?
02:10:40 <wgsilkie> Sorry, not 2*2, just n^2.
02:10:53 <dancor> wgsilkie: matrix as in a list of lists?
02:11:01 <wgsilkie> dancor: Yes.
02:11:18 <mle> Haskell does have arrays.
02:11:33 <dancor> > let n = 2 in replicate n $ replicate n 5
02:11:34 <lambdabot>   [[5,5],[5,5]]
02:12:08 <copumpkin> :t listArray
02:12:10 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
02:12:11 <dancor> nByNLOL n = replicate n . replicate n
02:12:41 <wgsilkie> OK, got it.
02:12:41 <dancor> @pl \ n -> replicate n . replicate n
02:12:42 <lambdabot> liftM2 (.) replicate replicate
02:12:46 <copumpkin> > listArray ((0, 0), (4, 4)) (replicate 25 0)
02:12:47 <lambdabot>   array ((0,0),(4,4)) [((0,0),0),((0,1),0),((0,2),0),((0,3),0),((0,4),0),((1,...
02:13:51 <wgsilkie> If I need to change the elements in the matrix, a list would be better than an array, correct?
02:14:03 <copumpkin> they're both pretty bad
02:14:34 <wgsilkie> copumpkin: In what way?
02:14:37 <copumpkin> although list getts better the closer you get to "top left" corner
02:14:54 <dancor> in terms of speed
02:15:03 <wgsilkie> Oh, OK.
02:15:36 <wgsilkie> Then which would make more elegant code?
02:15:40 <wgsilkie> Lists?
02:15:57 <dancor> no array
02:16:02 <Saizan> depends on the use
02:16:03 <wgsilkie> Oh.
02:16:17 <copumpkin> if your array is sparse enough, I'd even suggest an IntMap
02:16:26 <copumpkin> but that gets complicated
02:16:28 <Saizan> even if it's not sparse
02:16:40 <copumpkin> for editability's sake, yeah
02:16:49 <Saizan> a Map (Int,Int) a too
02:17:11 <wgsilkie> Tidiness is more import than speed, for me.
02:17:44 <wgsilkie> I'll just use lists, and then optimize it later, if necessary.
02:17:44 <copumpkin> you'll find yourself with a nice extra linear factor unless you do that though
02:17:56 <copumpkin> but if your things are small enough, I guess it isn't a big deal
02:18:13 <wgsilkie> 80*24?
02:18:59 <Raevel> is HTTP's getResponseBody lazy?
02:21:51 <wgsilkie> > let matrix = \ x y -> replicate x . replicate y
02:21:52 <lambdabot>   not an expression: `let matrix = \ x y -> replicate x . replicate y'
02:22:40 <wgsilkie> > let matrix = replicate 4 . replicate 5
02:22:41 <lambdabot>   not an expression: `let matrix = replicate 4 . replicate 5'
02:22:49 <wgsilkie> @pl let matrix = replicate 4 . replicate 5
02:22:49 <lambdabot> (line 1, column 39):
02:22:49 <lambdabot> unexpected end of input
02:22:49 <lambdabot> expecting variable, "(", ".", "`", "!!", operator, ";" or "in"
02:23:00 <wgsilkie> @pl replicate 4 . replicate 5
02:23:00 <lambdabot> replicate 4 . replicate 5
02:23:29 <doserj> > let matrix = replicate 4 . replicate 5 in matrix 0
02:23:30 <lambdabot>   [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]
02:23:41 <quicksilver> @pl \x y -> replicate x . replicate y
02:23:41 <lambdabot> (. replicate) . (.) . replicate
02:24:23 <copumpkin> @pl \y x -> replicate x . replicate y
02:24:23 <lambdabot> flip ((.) . replicate) . replicate
02:25:10 <wgsilkie> doserj: Why does it have to be "in matrix 0" instead of just "in 0"?
02:26:01 <shachaf> Ha, join (.) (replicate n) doesn't work. Is there anything simple one can do about that?
02:26:05 <shachaf> Er.
02:26:14 <shachaf> Looks like I was scrolled up a bit.
02:26:49 <dibblego> what's the equivalent of "finally" for executing an IO action but running some action even if an exception occurs?
02:27:57 <jkff> bracket
02:28:21 <dibblego> @type bracket
02:28:22 <lambdabot> Not in scope: `bracket'
02:28:47 <jkff> :t Control.Exception.bracket
02:28:49 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:28:53 <dibblego> ta
02:28:54 <jkff> http://notes-on-haskell.blogspot.com/2007/03/design-patterns-in-haskell-bracket.html
02:29:10 <doserj> wgsilkie: you can do "... in 0", but that wouldn't use matrix, just type-check it.
02:29:33 <doserj> > let matrix = replicate 4 . replicate 5 in 0
02:29:34 <lambdabot>   0
02:30:48 <wgsilkie> doserj: How do I rewrite that as a function?
02:30:58 <wgsilkie> I'm failing miserably.
02:31:24 <doserj> wgsilkie: I am not sure what you are asking
02:32:39 <wgsilkie> doserj: I'm trying to write a function that takes x y item, and returns a x by y list filled with item.
02:32:43 <Saizan> "let X = E0 in E1" only puts X in scope when evaluating E1, it doesn't apply it to E1
02:33:10 <Saizan> wgsilkie: in a file you can just write "matrix x y = replicate x . replicate y"
02:33:30 <Saizan> because a module is made of declarations
02:33:38 <Saizan> while lambdabot here accepts only expressions
02:33:39 <doserj> > let matrix x y item = replicate x (replicate y item) in matrix 3 4 0
02:33:40 <lambdabot>   [[0,0,0,0],[0,0,0,0],[0,0,0,0]]
02:34:18 <Saizan> if you want to declare the matrix function for lambdabot you have to use the @let command
02:34:37 <wgsilkie> OK, thanks Saizan!
02:34:39 <wgsilkie> How do I print all the elements in a list?
02:34:52 <Peaker> wgsilkie: just show the list itself, it does that?
02:35:00 <Raevel> print myList
02:35:04 <Saizan> depends on the output format
02:35:05 <Peaker> @src [] show
02:35:05 <lambdabot> Source not found.
02:35:07 <Peaker> @src [] shows
02:35:07 <lambdabot> Source not found. That's something I cannot allow to happen.
02:35:16 <Peaker> yairchu: hey
02:35:17 <Saizan> but yeah, print list for the built-in one
02:35:30 <Peaker> mapM_ print list  -- to actually "print" each one
02:35:35 <Saizan> > show [1..5] -- it'll look like this
02:35:36 <lambdabot>   "[1,2,3,4,5]"
02:35:46 <Saizan> without the quotes
02:36:20 <wgsilkie> Oh, right, sorry.  I was getting confused with other errors.
02:42:33 <fbr> can I ask a question?
02:42:54 <fbr> I'd like to have different pattern matching triggering the same function?
02:43:09 <fbr> something like in C
02:43:15 <fbr> switch (...)
02:43:19 <fbr> case TOTO:
02:43:25 <fbr> case TTITI:
02:43:35 <fbr>    do_the_job();
02:43:41 <fbr> You see?
02:44:13 <fbr> so with a case in Haskell
02:45:06 <Saizan> there's no explicit support for that in the syntax
02:45:07 <Botje> use a helper function
02:45:10 <Botje> and a guard :)
02:45:29 <Botje> case foo of x | isFooCase x -> ...
02:45:51 <Saizan> yeah, or sometimes you can just get by with x | x `elem` [TOTO,TTITI] ->
02:45:52 <fbr> But with a guard, I will loose exhaistiveness checking of the compiler
02:45:59 <fbr> exhaustiveness
02:46:03 <Saizan> true
02:46:34 <Saizan> another option is to give a name to the body of the branch and use that in both case
02:46:38 <Saizan> *cases
02:47:19 <fbr> I see
02:47:24 <fbr> better idea then
02:47:33 <fbr> I would define my functions in the where clause
02:47:48 <fbr> and call them in different pattern matching
02:47:58 <fbr> There is less code duplication
02:48:08 <fbr> It would be nicer thant what I have
02:48:24 <fbr> And still exhaustiveness checking
02:48:28 <fbr> Thanks!
02:48:44 <fbr> Another question, how to declare several functions having the same type signature at once?
02:48:45 <fasta> fbr: you love \n?
02:49:12 <fbr> What do you mean?
02:49:51 <balor> To use the function fromList in Data.Set I "import Data.Set (Set)" and then call "fromList [a]"  but fromList is not in scope.  What's the correct way to call the function?
02:50:33 <fasta> balor: read the H98 report and you know it.
02:51:00 <fasta> balor: or just do import qualified Data.Set as Set and call Set.fromList
02:51:01 <Saizan> fbr: foo, bar :: <type>
02:51:16 <fbr> OK, I thought I tried this one
02:51:55 <Saizan> bavardage: import Data.Set (Set) imports only the type Set from that module
02:52:18 <fbr> balor: import Data.Set (Set, fromList), have you tried?
02:53:09 <balor> fbr: thanks, I now understand both the qualified import and the () notation.
02:53:55 <fbr> Thanks Saizan for your answer.
02:55:32 <Saizan> np
03:22:30 <fbr> ciao
03:30:05 <matthew-_> ivanm: pong!
03:30:05 <lambdabot> matthew-_: You have 1 new message. '/msg lambdabot @messages' to read it.
03:35:48 <fasta> What's foldM for Sets?
03:36:12 <fasta> (I don't care about the order of the operation)
03:36:56 <Peaker> @hoogle foldM
03:36:56 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
03:36:56 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
03:36:56 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:36:59 <ziman> Sets aren't monads
03:37:22 <fasta> ziman: I never said they were.
03:37:28 <Peaker> is there any example use of foldM?
03:38:06 <fasta> Instead of foldM foobar (toList set), I want to write foldMLookALIke foobar set
03:38:14 <ziman> i see, you're looking for an equivalent of foldM
03:38:15 <Peaker> fasta: toList first?
03:38:18 <fasta> Oh, with a null element.
03:38:32 <Peaker> @hoogle Data.Set.Set a -> [a]
03:38:32 <lambdabot> Parse error:
03:38:32 <lambdabot>   --count=20 "Data.Set.Set a -> [a]"
03:38:32 <lambdabot>                  ^
03:38:35 <Peaker> @hoogle Set a -> [a]
03:38:35 <lambdabot> Data.Set elems :: Set a -> [a]
03:38:35 <lambdabot> Data.Set toAscList :: Set a -> [a]
03:38:35 <lambdabot> Data.Set toList :: Set a -> [a]
03:38:41 <Peaker> elems == toList?
03:38:50 <Gracenotes> yes
03:38:57 <fasta> Peaker: I want to get rid of "toList" everywhere.
03:39:17 <Gracenotes> well.. it is functional programming.. don't be afraid to make functions :)
03:39:23 <fasta> If Haskell had a decent sequence interface then this would not be required.
03:39:33 <Gracenotes> D:
03:39:52 <Peaker> @let result = (.) ; arg = flip (.)
03:39:53 <lambdabot>  Defined.
03:39:57 <Peaker> @type arg
03:39:58 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
03:40:29 <Peaker> > (result . result . arg) Data.Set.toList foldM
03:40:30 <lambdabot>   Not in scope: `Data.Set.toList'
03:40:35 <Peaker> @type (result . result . arg) Data.Set.elems foldM
03:40:36 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> S.Set b -> m a
03:40:57 <Peaker> @let foldMSet = (result . result . arg) Data.Set.elems foldM
03:40:58 <lambdabot>  <local>:3:35: Not in scope: `Data.Set.elems'
03:41:13 <fasta> I guess the proper channel would be the libraries mailing list.
03:41:18 <Peaker> Data.Set is not imported?
03:41:29 <Peaker> fasta: all you're lacking is this one function?
03:41:31 <fasta> Python did it right, AFAIK, so did Factor.
03:41:33 <Peaker> fasta: maybe the RMonad has a Set instance?
03:41:45 <fasta> Peaker: no, I can write everything myself.
03:41:49 <Peaker> Because it can do restrictions...
03:42:03 <fasta> Peaker: the problem is that there is no decently designed sequence protocol in general.
03:42:18 <fasta> Peaker: there is Traversable, but it's not decent.
03:42:23 <Peaker> fasta: the sequence protocol is [] itself?
03:42:30 <Peaker> fasta: I mean, toList is the equivalent of __iter__
03:42:52 <Peaker> fasta: and for side-effecty stuff, me and a friend wrote Producer/Consumer
03:43:13 <fasta> Peaker: I doubt all of the toList operations are compiled away.
03:43:23 <Peaker> Traversable is not the equivalent of a sequence protocol, it does something Python doesn't have -- traversing something while retaining its structure
03:43:37 <Peaker> fasta: neither is __iter__ compiled away, what do you mean?
03:43:52 <fasta> Peaker: I mean that in Haskell you can compile it away.
03:44:15 <Peaker> fasta: how? You need to iterate sequentially, a binary search tree that is not sequential..
03:44:18 <Peaker> fasta: or you mean fusing the list?
03:44:33 <Peaker> fasta: I suppose inlining might fuse the list? I don't know much about ghc optimizations
03:44:41 <Peaker> it should be possible in theory
03:44:44 <Peaker> (and in practice :-)
03:44:49 <byorgey> fasta: maybe you've already looked at it, but have you seen the ListLike package on hackage?
03:44:50 <quicksilver> there should be no problem writing a Foldable instance for Sets
03:44:55 <quicksilver> isn't that all fasta wants?
03:45:12 <byorgey> Sets aren't already Foldable?
03:45:19 <iago> someone knows some model checking tool for haskell?
03:45:46 <fasta> quicksilver: in this case, yes. But there is no "unified" documented generic interface for everything.
03:46:08 <fasta> You basically need to scrape all the generic stuff together by yourself. It's not part of the language as such.
03:46:29 <fasta> Nor is there cabal install sane-generics.
03:46:48 <fasta> Anyway, end of rant :)
03:47:30 <Peaker> fasta: I used to think that too, until I realized Python's iterator protocol is just Haskell's lists, except lists can memoize more easily, and the other side of the same coin is that they also create temporary cons to look at & destroy, usually
03:48:10 <fasta> Peaker: I thought Python iterators worked the same as C++ ones, which is efficient.
03:48:34 <fasta> Peaker: they are not creating list nodes to iterate over an array in C++
03:48:50 <fasta> (and I highly doubt that's what they do in Python)
03:49:05 <Peaker> fasta: Python's iterators are more like a type-class:  class Iter i a where next :: i -> (i, a)  -- except it destructively updates i, instead
03:49:49 <Peaker> fasta: does the creation of list nodes bother you that much? Its what facilitates simple memoizing
03:50:15 <fasta> Peaker: Haskell is slow enough as it is. No need to introduce extra slowness.
03:52:08 <Peaker> @src Foldable
03:52:08 <lambdabot> Source not found. Where did you learn to type?
03:52:47 <Peaker> what's the difference between Foldable and Traversable?
03:53:14 <Peaker> oh, relationship to Applicative/Functor
03:53:36 <doserj> fold destroys the structure, traverse keeps it
03:55:01 <Peaker> keeps it, while also creating some applicative effect
03:55:37 <Peaker> (or just fmap, if you want, as it subclasses Functor too, cool)
03:59:31 <zhxk> hello, gentlemen, nice seeing you again, well, i know most of you are experts, well would you please advice me which pakage is good for connection proxy use?
04:00:06 <Peaker> zhxk: what kind of connection proxy?
04:00:24 <quicksilver> fasta: creating a list node is extremely cheap
04:00:38 <quicksilver> comparable in cost to any other way of traversing a complex structure
04:00:43 <quicksilver> it's just two pointers.
04:00:45 <nibro> @seen malcolmw
04:00:45 <lambdabot> malcolmw is in #ghc and #haskell. I don't know when malcolmw last spoke.
04:00:58 <quicksilver> most traversal techniques involve one or two pointers.
04:01:01 <Peaker> I'll note that newbie->knowledgable seemed to me like it'd take years and years when I first came in #haskell  -- and it seems to be between a few months and 2 years, depending on how intensively you're going at it :-)  Learning curve not as bad as it originally looks, and can be improved a lot too
04:01:02 <malcolmw> nibro: hello
04:01:15 <nibro> malcolmw: hello there :)
04:01:17 <etpace_> In LYAH, it says something like: let bigFirstname = map toUpper firstname, where firstname <- getLine, is the let needed? Cant I just do bigFirstname = map toUpper firstname?
04:01:23 <nibro> malcolmw: recall that conversation we had regarding cpphs?
04:01:28 <Peaker> quicksilver: it may induce GC where it wouldn't otherwise occur.. the GC cost of creating many list nodes may not be negligible
04:01:32 <malcolmw> nibro: yes
04:01:57 <quicksilver> Peaker: you haven't drunk enough koolaid. Drink more.
04:01:57 <nibro> malcolmw: well, as it turns out, I do have a bit of a problem with your policy for it
04:02:03 <etpace_> sorry, thats not "haskell" where, im just saying what firstname is
04:02:04 <fasta> quicksilver: if it is not needed, it should not be done.
04:02:05 <quicksilver> Peaker: GC has been proven to be cheaper than new/delete :P
04:02:09 <Peaker> etpace_: inside "do" blocks, you need "let" to say that you're now giving a name to a value, rather than "executing" a statement
04:02:21 <Peaker> quicksilver: :-)
04:02:21 <fasta> quicksilver: ah, right, "proven". :)
04:02:23 <malcolmw> nibro: you mean the licence?
04:02:25 <nibro> malcolmw: namely that while depending on cpphs in its current state, I couldn't hope to get haskell-src-exts to replace haskell-src in the haskell platform
04:02:27 <quicksilver> fasta: then you most code in assembly language, for no language on the planet meets the criterion you make.
04:02:38 <nibro> malcolmw: that and its dependency on the haskell98 package
04:02:45 <etpace_> what would be the result of bigFirstname = map toUpper firstname? would it just execute map toUpper firstname, and then do nothing with the result?
04:03:34 <malcolmw> nibro: how do you use cpphs - as a library? or an executable?
04:03:41 <fasta> quicksilver: (I know you are referring to some paper)
04:03:58 <quicksilver> fasta: well, I'm referring to folklore really.
04:04:07 <Raevel> etpace_: it would only execute map ... only if it is going to be used
04:04:11 <quicksilver> But what *is* true is that people overestimate the cost of GC and underestimate the cost of delete.
04:04:11 <fasta> quicksilver: ok, well now you know there is a paper too :)
04:04:12 <nibro> malcolmw: as a library, currently I only use the delit parts, but I'm hoping to integrate some of the CPP stuff as well
04:04:20 <quicksilver> there are multiple papers.
04:05:22 <malcolmw> nibro: so, since the unlit part came from an older version of the Haskell Report, I guess it is not really LGPL at all
04:05:45 <etpace_> is there any reason for you to do: firstname = functions? If it doesnt store it into firstname, and it's not anything to do with IO, it doesn't really do anything, right?
04:06:13 <malcolmw> nibro: will the advent of proper dynamic linking in ghc solve the licensing issue?
04:06:13 <nibro> malcolmw: is there any deeper dependency between the two parts, or could the delit part technically be split into a separate package then?
04:06:23 <Raevel> etpace_: clarity, brevity
04:06:25 <Saizan> etpace_: even if "functions" involved IO it wouldn't do anything
04:06:49 <Saizan> etpace_: it just gives a name to that expression, which you're probably going to use later
04:06:52 <malcolmw> nibro: I believe they are rather separate, so could indeed be different packages
04:06:53 <etpace_> yeah sorry, if it was IO youd need to do <-
04:06:53 <nibro> malcolmw: I'm rather unknowledgeable about licensing stuff, so I couldn't answer that
04:07:21 <Saizan> etpace_: you need <- only if you want that executed at that point
04:07:41 <nibro> malcolmw: I take it you have no real interest in getting the cpphs package into the platform?
04:07:55 <malcolmw> nibro: so the usual objection to the LGPL in Haskell-land is that a library is not separately upgradable, unless you have dynamic linking
04:08:05 <etpace_> hmm, I dont really understand the difference between let expr = .., and expr = ... then
04:08:06 <nibro> malcolmw: right
04:08:39 <Saizan> etpace_: "name = expr" is available at the toplevel in a file
04:08:49 <Saizan> etpace_: if you need a local definition you have to use let
04:08:56 <malcolmw> nibro: I would be happy for cpphs to be in the platform.  Do the organisers have strict licensing rules?
04:09:18 <Saizan> etpace_: otherwise there's no difference
04:09:21 <lilac> @seen gwern
04:09:21 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 6h 53m 31s ago.
04:09:48 <etpace_> name = expr is avaiable at top level if its within a do?
04:09:50 <myst> yeah, I know it's lame question but: is there an analog of Python's str.split() in Haskell?
04:09:58 <lilac> @tell gwern The ICFP binaries are available here: http://john.freml.in/icfp-contest-2009
04:09:59 <lambdabot> Consider it noted.
04:10:02 <nibro> malcolmw: I'm not sure how strict they are, but BSD is clearly prefered
04:10:04 <EvilTerran> etpace_, no, you have to use let in a do
04:10:12 <nibro> malcolmw: we can ask dcoutts about that :)
04:10:14 <EvilTerran> etpace_, but you can leave the "in" off "let" in a do-block
04:10:31 <nibro> malcolmw: but the dependency on haskell98 would still become a problem
04:10:47 <dcoutts> nibro, malcolmw: the libs list has not decided on licensing
04:11:07 <dcoutts> nibro, malcolmw: feel free to start that flamefest^H^Hdiscussion
04:11:08 <nibro> malcolmw: since the platform should be a self-contained set of prefered packages, and haskell98 isn't prefered
04:11:18 <Saizan> myst: see the split package on hackage
04:11:24 <balor> I've figured out that the old codebase I've acquired uses Set from haskell98 which is different from Data.Set, as the Data.Set functions are not defined on Set from haskell98. (a) Am I talking nonsense, and (b) if not, where can I find documentation for the haskell98 Set (not Data.Set)?
04:11:24 <dcoutts> nibro: haskell98 is certainly in the platform
04:11:51 <JaffaCake> but one day it might not be...
04:11:52 <nibro> dcoutts: huh? I looked for it on the package list
04:11:55 <Saizan> etpace_: by the toplevel i meant in a module, and you're not a do there
04:11:56 <dcoutts> nibro: so I see no problems with packages using it, any other decision should go via the libs list
04:11:59 <etpace_> I can only not use left in a do if I want to have something like expr = some io calls, for brevity?
04:12:03 <nibro> dcoutts: it *shouldn't* be!!! :-D
04:12:15 <dcoutts> nibro: it's a core lib, it must be
04:12:15 <etpace_> I mean expr = something inside a do Saizan
04:12:23 <nibro> dcoutts: *grumble* alright
04:12:36 <nibro> dcoutts, malcolmw: that's one problem less to worry about then
04:12:44 <JaffaCake> dcoutts: but it shouldn't be a core lib ;)
04:13:05 <nibro> malcolmw: want me to champion the addition of cpphs to the platform then?
04:13:16 <EvilTerran> balor, the type in Data.Set and the type in Set are equivalent, it's just Set is the haskell98 name, and Data.Set is the popular name
04:13:18 <Saizan> etpace_: you can't use "expr = something" in a do.
04:13:29 * EvilTerran would've expected them to be the same type, really
04:13:30 <malcolmw> nibro: OK, so for the moment, in the absence of decisions to throw out haskell98, or restrict licensing, cpphs is probably OK as is?
04:13:31 <Saizan> etpace_: you always have to use "let expr = something"
04:13:32 <nibro> malcolmw: I guess any licensing issues would be forced to be discussed then
04:13:37 <etpace_> ok, thanks
04:13:51 <nibro> malcolmw: if dcoutts says it is, then it surely is
04:14:02 <myst> Saizan, thanks
04:14:15 <JaffaCake> nibro: right, we'd have to discuss licensing, because it would be the first non-BSD component
04:14:52 <nibro> JaffaCake: indeed, so might as well get a concrete case to center the discussion on
04:15:10 <malcolmw> JaffaCake: dcoutts: do you think the dynamic linking thing will make allowing LGPL libraries easier?
04:15:12 <dcoutts> nibro, JaffaCake: a similar one would be c2hs, which is gpl
04:15:19 <EvilTerran> balor, haskell.org/onlinereport doesn't actually mention a module called Set, so i'm not entirely sure where you're getting it from in the first place
04:15:26 <EvilTerran> and my install of ghc doesn't have it, either
04:15:46 <dcoutts> malcolmw: yes, without needing the static linking exception to quiet the sticklers
04:15:46 <JaffaCake> malcolmw: perhaps you'd consider relicensing, for the platform?
04:15:48 <balor> EvilTerran: you have to "link" (using C terminoloigy I'm afraid) against haskell98
04:16:12 <balor> EvilTerran: A "Build-Depends haskell98" in Cabal
04:16:44 * JaffaCake would slightly prefer to keep the platform BSD-only
04:16:50 <dcoutts> personally I think a policy that allows libs to be used by proprietary software and allows programs (but not their code) to be used by proprietary software would be fine
04:16:58 <dcoutts> that'd allow LGPL libs and GPL progs
04:17:05 <Saizan> balor: http://hackage.haskell.org/package/haskell98-1.0.1.0 <- there's no Set in haskell98, it seems
04:17:22 <dcoutts> though we may have to stipulate the static linking exception for the LGPL
04:17:46 <malcolmw> JaffaCake: I'm happy to re-license in exchange for money, but where my software is free, I want it to remain free. :-)
04:17:52 <EvilTerran> balor, as i said, i don't see a Set module, even in haskell 98
04:18:02 <dcoutts> and it must be possible to use all libs in the platform simultaneously, so we cannot have incompatible free/open licenses
04:18:28 <balor> EvilTerran: If I remove the linkage the codebase complains about a missing List module.  Maybe set is a nub'ed list.
04:19:29 <JaffaCake> malcolmw: how much?  I think paying to make software more free is money well spent :)
04:19:50 <balor> EvilTerran: I'm being dumb.  Set is defined in my codebase. Sorry. n00b alert.
04:20:56 <nibro> JaffaCake, dcoutts: as a developer using the platform, I would be happy to know it was BSD only so that I didn't need to worry about how I use the different packages, but that seems like an utopic wish to me, as there will always be lib developers that really really want (L)GPL
04:21:07 <dcoutts> JaffaCake: we should justify these things in terms of practicalities I think
04:21:28 <Igloo> dcoutts: There's no reason why core libs have to be in the platform
04:21:49 <JaffaCake> dcoutts: quite, I agree with that
04:21:52 <dcoutts> Igloo: well there's no way in practise for them not to be
04:21:56 <dafra> hi, i cannot have Network.fastCGI installed on Windows XP. Cabal complains the fcgi library is missing. Where can I find it ?
04:22:35 <JaffaCake> dcoutts: many people have practical difficulties using (L)GPL software
04:22:54 <dcoutts> JaffaCake: eg if MSR employees cannot send patches for LGPL libs that's a practical issue, it's less so for non-core libs that have their own maintainers
04:23:17 <Igloo> dcoutts: Why not? The fact that they are always available doesn't mean they have to be defined to be part of the platform
04:23:20 <kynky> lgpl is annoying , unless it got linking excepton
04:23:31 <dcoutts> JaffaCake: do other people have such practical difficulties?
04:23:51 <JaffaCake> you should ask the Galois folks, but IIRC in the past they've expressed a preference for non-GPL
04:23:55 <dcoutts> Igloo: right, the fact that we'd be distributing them, saying "oh don't use that" doesn't really work
04:24:12 <dcoutts> JaffaCake: non-GPL is quite a different matter
04:24:24 <Igloo> dcoutts: Oh, right, for the binaries that include GHC that's true
04:24:42 <JaffaCake> dcoutts: in what way?
04:24:52 <dcoutts> JaffaCake: or did you mean non-LGPL ?
04:25:13 <JaffaCake> I'm not sure, you'd have to ask
04:25:53 <JaffaCake> in a commercial setting, it's often easier to just avoid (L)GPL if possible, because the legal situation is murky
04:26:00 <dcoutts> JaffaCake: it's plain that they cannot use GPL libs in their proprietary code, but using LGPL libs (especially with static linking exception) should be fine
04:26:03 <nibro> well, it should be rather obvious that some companies won't want to use LGPL for whatever reason
04:26:25 <nibro> for instance, there was that controversy a while back with that company doing declarative content generation in haskell, who might not use haskell at all due to the statically linked gmp
04:26:45 <dcoutts> sure, there's the static linking issue, that's a perfectly good practical reason
04:26:58 <dcoutts> so what about LGPL + static linking exception?
04:27:15 <dcoutts> are there still actual practical issues with that? I don't understand "murky"
04:28:04 <nibro> dcoutts: I would be very surprised if there weren't companies that would ban any LGPL, for just the fear of ligal problems, even if their reasons weren't fully thought through
04:28:12 <JaffaCake> dcoutts: but you understand the (L)GPL, for someone who doesn't understand it, deciding whether they're complying or not is expensive (time and money)
04:28:12 <nibro> *legal
04:28:55 <bremner> nibro: so, we should prioritize companies who are too lazy to understand the licenses of software they want to use?
04:28:59 <m4k3r> is there a library std where I can find a function that returns the time took by the execution of  another function?
04:29:24 * bremner stops the rant there
04:29:28 <balor> JaffaCake: It's not more expensive than deciding if you're complying with another licence really (ommiting the 2-clause BSD)
04:29:28 <m4k3r> sorry, I wrote so bad :Â°
04:29:42 <malcolmw> I don't think the LGPL is legally murky.  Companies need to spend money on licensing lawyers, no matter what.
04:30:38 <nibro> the fact remains that there *are* companies that avoid LGPL
04:30:44 <dcoutts> JaffaCake: people using BSD components also have to include the BSD copyright notice for all component, this is something we should provide so people do not have to go searching around
04:30:50 <balor> dcoutts: GNU Classpath AFAIK used to have LGPL + static linking exception...You may want to have a look at that.
04:30:50 <JaffaCake> it's much easier to determine whether you're complying with BSD than LGPL, although you can cache the decision and re-use it I suppose
04:30:53 <nibro> for good reasons or not, but that's a secondary issue
04:31:34 <dcoutts> JaffaCake: so we can spell it out: if you do not change the code, all you need to do is include this file with your prog (containing all the BSD and LGPL license notices)
04:31:35 <balor> JaffaCake: It depends on whether you're talking about the 3-clause BSD (old BSD) or the 2-clause (new BSD)
04:31:46 <balor> JaffaCake: It still has due diligence involved.
04:31:53 <dcoutts> balor: you mean old 4-clause and new 3-clause
04:31:53 <shambler> nibro: they avoid open source in general and dependency on external solutions
04:31:56 <JaffaCake> yes you need licensing lawyers, but I'm sure the default answer to "can I use this LGPL lib" will be "no" unless you pay them enough
04:32:03 <balor> dcoutts: yeah, d'oh.
04:32:07 <daf> I think making life easy for people who can't handle the LGPL should be more important than other goals like having a good platform
04:32:15 <daf> * I don't thiink
04:34:24 <JaffaCake> dcoutts: yes, spelling it out clearly would certainly be a good idea
04:34:41 <dcoutts> JaffaCake: since I think a lot of us are not even following the BSD conditions properly
04:34:50 <malcolmw> it may be possible to have an all-BSD platform, and an additional, optional, LGPL addon.  I rather expect that few BSD licensed libs depend on LGPL ones.
04:34:55 <dcoutts> JaffaCake: we do in source, but not binary typically
04:35:55 <nibro> malcolmw: my BSD-licenced haskell-src-exts depends on your LGPL-licenced cpphs (rightly or not...)
04:36:10 <malcolmw> nibro: ah yes, I just remembered that
04:37:00 <dcoutts> there's no technical problem with that
04:37:43 <quicksilver> but that's a purely source dependency.
04:37:51 <quicksilver> That's no different form depending on gcc (which is GPL) to compile.
04:38:01 <quicksilver> which we all used to, when via-C was the default.
04:38:26 <etpace_> Why must an if and an else inside a do, also be dos? (if preforming more than one line)
04:38:56 <malcolmw> so maybe an all-BSD platform, plus a LGPL+BSD-depending-on-LGPL extra section.
04:39:22 <malcolmw> quicksilver: no, hsx uses cpphs as a library, not simply as a build tool
04:39:59 <fasta> etpace_: because some collection of neurons decided that some years ago.
04:40:23 <quicksilver> malcolmw: I stand corrected :)
04:40:36 <fasta> etpace_: reasons might include not adding a special case.
04:40:44 <etpace_> aha, ok
04:40:48 <quicksilver> etpace_: they don't have to be.
04:40:48 <saml> do you know of a C++ parser preferably written in Haskell?
04:41:01 <quicksilver> etpace_: do blah; if blah then foo >> bar else baz >> bam;
04:41:22 <quicksilver> etpace_: the "inside" of a then clause or an else clause is "just" an expression.
04:41:34 <quicksilver> you can use all the different kinds of expression syntax you wish.
04:41:42 <quicksilver> it makes the languages simpler / more uniform.
04:43:25 <etpace_> ok, thanks
04:45:57 <shambler> "If we think about how the if/then/else construction works, it essentially takes three arguments: the condition, the \ldblquote then\rdblquote  branch, and the \ldblquote else\rdblquote  branch. The condition needs to have type Bool, and the two branches can have any type, provided that they have the same type. The type of the entire if/then/else constructionis then the type of the two branches."(c)yaht
04:47:27 <ivanm> hey matthew-_
04:48:03 <amaron> I'm learing usage of Control.Applicative and I've handled <$> and <*> (by reading examples on net) . Can anyone explain the usage of other operators  ( <$, <*, *>, <**> )?
04:48:32 <amaron> I saw their definitions, but I still don't get how to use them
04:49:27 <Saizan> > 1 <$ [1..5]
04:49:28 <lambdabot>   [1,1,1,1,1]
04:49:48 <Saizan> > 1 <$ Just 2
04:49:49 <lambdabot>   Just 1
04:50:59 <Saizan> "a *> b" is like "a >> b" from monad, it (produces an expression that) runs a, then b and returns the result of b
04:51:24 <Saizan> a <* b still runs a and then b, but it returns the result of a
04:52:14 <Peaker> I'd prefer $> over <$ :-)
04:52:19 <amaron> ok, <$  "wraps" first argument into functor of second one
04:52:32 <Peaker> @type (:->)
04:52:33 <lambdabot> Not in scope: data constructor `:->'
04:52:42 <Saizan> yeah, it replaces the values contained in the functor with the first argument
04:52:53 <amaron> ah, cool
04:53:16 <Peaker> while retaining the effect, of course, as the Functor interface cannot be used to change the effect
04:53:50 <amaron> I've used <$> and <*> in context of calling pure fucntion over arguments within Functors
04:54:16 <Peaker> Applicatives
04:54:25 <Saizan> f <$> a <*> b <*> c ?
04:54:34 <amaron> yes
04:55:01 <Peaker> @type \f x y -> f <$> x <*> y
04:55:02 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
04:55:07 <amaron> Peaker: yes, Applicatives (IO Monad actualy :))
04:55:09 <Saizan> yeah, every Applicative expression is an instance of that form
04:55:49 <amaron> so you could mix <*, *> and <$ in same context?
04:56:06 <amaron> (I'm still little bit blured)
04:56:10 <Saizan> yeah
04:56:17 <Saizan> they all work on applicatives
04:56:35 <Saizan> you may need some parentheses
04:56:43 <stevan> the three you just mentioned are pretty nice when doing parsing with combinators.
04:57:11 <amaron> and where does Alternative jumps in?
04:57:31 <amaron> *jump
04:57:43 <Saizan> when you use <|> and empty, which are like mplus and mzero, if you're familiar with them
04:58:32 <amaron> Saizan: I know what they are... but using them is still out of my reach
04:59:30 <Saizan> for IO empty raises an exception, and "a <|> b" executes b iff a raises an exception
04:59:59 <Saizan> for []  empty = []; (<|>) = (++)
05:00:13 <Saizan> so empty is generally associated with failure
05:00:16 <amaron> cool, it means some kind of exception handling
05:00:41 <Saizan> and <|> with recovering with that failure, or adding more "successes" as for list
05:01:42 <amaron> but there is no control regarding what kind of failure happened?
05:01:49 <Saizan> amaron: yeah, though if your applicative stores some information in the "exceptions" there are usually other interfaces to use
05:02:07 <Saizan> for IO you want to look at Control.Exception, for example
05:02:18 <Philonous1> @type (<|>)
05:02:19 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
05:02:38 <m3ga> any idea how to fix this? : http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2932#a2932
05:03:24 <Peaker> m3ga: why do you   "show r" and not show the contents of the Left there?
05:03:28 <Philonous1> Is (<|>) left- or right-biased?
05:03:35 <Saizan> ?hoogle finalizePackageDescription
05:03:35 <lambdabot> Distribution.PackageDescription.Configuration finalizePackageDescription :: Package pkg => FlagAssignment -> Maybe (PackageIndex pkg) -> OS -> Arch -> CompilerId -> [Dependency] -> GenericPackageDescr
05:03:35 <lambdabot> iption -> Either [Dependency] (PackageDescription, FlagAssignment)
05:03:40 <Philonous1> > [1,2,3] <|> [4,5,6]
05:03:41 <lambdabot>   [1,2,3,4,5,6]
05:03:45 <Philonous1> Oh
05:03:47 <Peaker> m3ga: also, that case is:  either (error . show) fst r
05:03:49 <amaron> Saizan: thank you, I decided to remove imperative like code in my work, so those operators are very useful
05:04:03 <Philonous1> > Just 3 <|> Just 5
05:04:04 <lambdabot>   Just 3
05:04:09 <Peaker> m3ga: anyway, what in this "do" block is in IO?
05:04:23 <Peaker> m3ga: is "finalizePackageDescription" a function or an action?
05:04:35 <Saizan> Peaker: it's a function
05:04:46 <Saizan> m3ga: you've to add a type annotation to that Nothing
05:04:52 <Peaker> so http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2932#a2932    shouldn't be a do block at all
05:05:28 <Saizan> true
05:05:53 <Peaker> m3ga: why is it a do block? None of these things are actions. Your "case" returns a string, which is [Char] so your do block is in the list monad, for no reason at all :)
05:06:03 <Peaker> oops, not a string, a PackageDescription whatever that is :)
05:06:07 <Peaker> is it a Monad?
05:06:16 <Saizan> no
05:06:41 <Saizan> ?hoogle PackageDescription
05:06:41 <lambdabot> module Distribution.PackageDescription
05:06:41 <lambdabot> Distribution.PackageDescription data PackageDescription
05:06:41 <lambdabot> Distribution.PackageDescription PackageDescription :: PackageIdentifier -> License -> FilePath -> String -> String -> String -> String -> [(CompilerFlavor, VersionRange)] -> String -> String ->
05:06:41 <lambdabot> String -> String -> String -> [(String, String)] -> [Dependency] -> VersionRange -> Maybe BuildType -> Maybe Library -> [Executable] -> [FilePath] -> FilePath -> [FilePath] -> [FilePath] -> PackageDes
05:06:42 <lambdabot> cription
05:07:11 <m3ga> Peaker: i'm a refugee from ocaml. it probably get a lot of stuff wrong :-)
05:07:23 <Peaker> m3ga: I annotated it with a new un-do version
05:08:33 <Peaker>  finalizePackageDescription sure takes a few arguments :(
05:08:53 <Saizan> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2932#a2934 <- that should typecheck
05:09:44 <Gracenotes> ooh. new maru video.
05:10:22 <Peaker> Surely some of those args in finalizePackageDescription could be grouped up into their own data type?
05:10:28 <Peaker> Linux + I386 for example
05:11:24 <Saizan> the last version should be the corret one :) i forgot a PackageIndex in the type
05:11:35 <Peaker> Compiler+Flags -> Compiler' ?   Linux + I386 -> Platform?      Then its just   Platform -> Compiler' -> PackageId -> PackageDescription
05:12:01 <Peaker> @hoogle finalizePackageDescription
05:12:01 <lambdabot> Distribution.PackageDescription.Configuration finalizePackageDescription :: Package pkg => FlagAssignment -> Maybe (PackageIndex pkg) -> OS -> Arch -> CompilerId -> [Dependency] -> GenericPackageDescr
05:12:01 <lambdabot> iption -> Either [Dependency] (PackageDescription, FlagAssignment)
05:12:26 <Saizan> Peaker: the flags are not for the compiler there
05:12:36 <Peaker> Saizan: oh, for whom are they?
05:13:00 <Peaker> This thing should be a Record - so you can fill it by name
05:13:05 <Saizan> Peaker: dependecy resolution, they are the flags in the .cabal files
05:13:20 <zhxk> Peaker:socks5,http,is ok
05:13:29 <Peaker> zhxk: ?
05:13:39 <zhxk> Peaker:proxy
05:14:17 <zhxk> i want a library to make my app path through proxys
05:14:43 <Saizan> zhxk: the HTTP library works with proxies
05:15:19 <zhxk> Saiza,really? so i can borrow some code from HTTP library?
05:16:03 <Saizan> or just use it if you're going via the http protocol?
05:16:33 <m3ga> Peaker, Saizan :  many thanks! working now
05:17:50 <Saizan> m3ga: you might want to rename packageId to packageIndex, just to keep the name consistent with the meaning of the argument :)
05:18:40 <zhxk> well, i want a library that can pass throgh most of common proxy server
05:18:57 <m3ga> Saizan: already have,  mainly because i got a warning  with -Wall :-)
05:20:15 <Peaker> -Wall warns you about bad names now? :)
05:20:27 <m3ga> shadowed names
05:21:00 <m3ga> ?hoogle packageId
05:21:00 <lambdabot> Distribution.Package packageId :: Package pkg => pkg -> PackageIdentifier
05:21:00 <lambdabot> Distribution.Package data PackageIdentifier
05:21:00 <lambdabot> Distribution.Package PackageIdentifier :: String -> Version -> PackageIdentifier
05:21:45 <koeien>  /join #math
05:21:50 <koeien> wups
05:25:25 <Botje> You are now in #math. You see here: a list of unsolved problems, and a box of crayons.
05:25:35 <quicksilver> There are no visible exits.
05:26:05 <ivanm> crayons?
05:26:23 <ivanm> surely a blackboard and chalk would suit better?
05:26:43 <ben> you are likely to be eaten by a grad student
05:27:04 <quicksilver> blackboard and chalk: item requires experience level 5
05:27:12 <ivanm> ben: for the nourishment or so that they can steal your ideas?
05:27:24 <ivanm> quicksilver: what do you need to do to obtain new experience levels?
05:27:25 <ben> Just out of spite
05:27:29 <ivanm> ahhhhh
05:27:34 <Botje> at least crayons have /some/ nutritional value
05:28:14 <ivanm> Botje: not to mention some toxic value
05:28:33 <Botje> but.. they let small children play with them!
05:28:44 <ivanm> your point being?
05:28:52 <Botje> perhaps they're only toxic if, say, your entire diet depends on them :]
05:28:53 <ivanm> they let small children play with dirt, after all...
05:29:10 <Botje> but dirt is nourishing and wholesome!
05:29:14 <Botje> and chock full of nutrients ;)
05:30:05 <Philonous> "And todays feature movie, a Banach-Tarksi coproduction 'Honey, I duplicated the kids' "
05:30:25 <doserj> You are in a maze of twisty little theorems, all alike
05:30:52 <koeien> Philonous: lol
05:40:06 <etpace_> :t return "test"
05:40:07 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
05:40:16 <etpace_> Is that the same as IO String?
05:40:34 <ben> :t return "test" :: IO String
05:40:35 <lambdabot> IO String
05:40:39 <ski> it can be
05:40:45 <LeoD> if m is IO, yea
05:44:03 <Zao> > return "test" :: [[Char]]
05:44:04 <lambdabot>   ["test"]
05:44:19 <Zao> > return "test" :: Maybe [Char]
05:44:20 <lambdabot>   Just "test"
05:44:43 <byorgey> > return "test" 3
05:44:44 <lambdabot>   "test"
05:45:14 <ben> Is that (-> r) being a monad?
05:45:36 <EvilTerran> ben, yes
05:45:36 <byorgey> ((->) r), yes =)
05:45:37 <ski> not `(-> r)', `(r ->)', which in haskell is written as `(->) r'
05:45:43 <EvilTerran> well, ((->) r), aka (r ->)
05:45:44 <ben> rrright
05:45:47 <EvilTerran> ?quote fugue
05:45:47 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
05:49:24 <Saizan> twice in a row
05:49:41 <hackagebot> MazesOfMonad 1.0.4 - Console-based Role Playing Game (JeanPhilippeMoresmau)
05:49:49 <ivanm> How does one use the ((->) r) monad?
05:50:52 <Ferdirand> mazes of monad ? sounds dreadful. I need it :D
05:50:53 <EvilTerran> ivanm, actions in (r ->) are functions that take r as a parameter, so it acts as a way of distributing an implicit parameter
05:51:17 <EvilTerran> > (do x <- (+1); y <- (*2); return (x,y)) 3
05:51:18 <lambdabot>   (4,6)
05:51:33 <ivanm> ahhh, about to ask how you create instances
05:51:38 <ivanm> which is what I really meant
05:51:57 <EvilTerran> the instance follows directly from the types
05:52:19 <ivanm> return (x,y) == \ z -> (z+1, z*2) ?
05:52:34 <EvilTerran> the whole thing = that lambda
05:52:40 <ivanm> well, yes
05:52:51 <Saizan> return = const
05:52:58 <ivanm> so it's kinda like the state monad in that you're creating an implicit function?
05:53:01 * quicksilver thinks the people who are +1'ing generalising (++) have little idea how much pain it will cause to replace an prelude operator with one of a different type - especially when that type is typeclass-polymorphic and we have a monomorphism restriction.
05:53:20 <byorgey> ivanm: right. it's exactly like the state monad, except you don't get a new state out.
05:53:24 <ivanm> quicksilver: this is to do with bos' proposal?
05:53:26 <quicksilver> ivanm: not sure in what since it's "implicit", but yes. It's a function.
05:53:29 <ivanm> byorgey: *nod*
05:53:34 <quicksilver> Yes. Although I prefer to call it my proposal ;)
05:54:05 <ivanm> quicksilver: well, with the state monad doesn't it doesn't actually look like a function, and neither does the ((->) r) monad
05:54:26 <ivanm> quicksilver: so your problem with the proposal is just the question on overloading (++)?
05:54:52 <quicksilver> ivanm: the state monad is a function wrapped in a newtype.
05:54:59 <quicksilver> the ((->) r) monad really is a function.
05:55:22 <quicksilver> > (reverse >> sort) $ "hello"
05:55:23 <lambdabot>   "ehllo"
05:55:43 <quicksilver> reverse really is a function. sort really is a function. (reverse >> sort) really is a function.
05:55:56 <Philonous> Does ghci provide some sort of timing function?
05:56:06 <quicksilver> Philonous: Yes. :set -s IIRC
05:56:28 <quicksilver> :set +s rather
05:57:29 <Philonous> Ah thanks
05:58:26 <ivanm> @type reverse >> sort
05:58:27 <lambdabot> forall a. (Ord a) => [a] -> [a]
05:58:53 <ivanm> quicksilver: using the same list (but ignoring the reversal)?
05:59:00 <quicksilver> yes.
05:59:07 <quicksilver> the reader monad is about always using the same parameter
05:59:15 <quicksilver> "the environment" it is sometimes called.
05:59:26 <quicksilver> using the same parameter for all your functions.
05:59:26 <ivanm> ((->) r) is the reader monad? :o
05:59:29 <quicksilver> yes.
05:59:40 <ivanm> but newtyped for Reader ?
05:59:45 <quicksilver> :t Reader
05:59:46 <lambdabot> forall r a. (r -> a) -> Reader r a
05:59:53 <quicksilver> :r runReader
06:00:00 <quicksilver> :t runReader
06:00:01 <lambdabot> forall r a. Reader r a -> r -> a
06:00:18 <ivanm> "run, reader, run, reader, run, run, run..." ;-)
06:00:21 <portnov> @index sort
06:00:21 <lambdabot> Data.List
06:00:23 <quicksilver> (which is a longwinded way of saying "Yes, Reader is just a newtype for ((->)r)
06:00:25 <zhxk> hello, i've been reading about http1.0,socks proxys
06:00:28 <ivanm> heh
06:00:51 <ivanm> quicksilver: anyway, with the monoid proposal... why is it that suddenly the latest thing seems to be is to create infix symbols for common functions?
06:00:58 <quicksilver> because it looks nicer.
06:01:06 <quicksilver> `mappend` is hideous.
06:01:14 <quicksilver> sufficiently hideous that I actually avoid using it.
06:01:33 <ivanm> IIRC, when I started using Haskell everyone was really using pointfree notation (and still are to a lower extent), whereas these symbols are the opposite...
06:01:39 <ivanm> quicksilver: why not use it prefix?
06:01:54 <portnov> :t (reverse >> sort)
06:01:55 <lambdabot> forall a. (Ord a) => [a] -> [a]
06:02:20 <quicksilver> ivanm: mappend (mappend (mappend a b) c) d) ?
06:02:28 <ivanm> ahhhhh
06:02:40 <ivanm> *shudder* you actually have monoids three levels deep? :s
06:02:55 <quicksilver> that's just analogous to doing 1 + 2 + 3 +4
06:03:01 <ivanm> oh, duh
06:03:03 <ivanm> forget that :s
06:03:07 <quicksilver> or "hi" ++ " " ++ "there" ++ " ivanm"
06:03:08 * ivanm misread the bracketing
06:03:28 <saml> > mappend (mappend (mappend a b) c) d)
06:03:29 <lambdabot>   <no location info>: parse error on input `)'
06:03:46 <saml> > mappend (mappend (mappend a b) c) d
06:03:47 <lambdabot>   No instance for (Data.Monoid.Monoid SimpleReflect.Expr)
06:03:47 <lambdabot>    arising from a u...
06:03:49 <ivanm> @pl \ a b c d -> mappend (mappend (mappend a b) c) d)
06:03:49 <lambdabot> (line 1, column 49):
06:03:49 <lambdabot> unexpected ")"
06:03:49 <lambdabot> expecting variable, "(", operator or end of input
06:03:59 <ivanm> @pl \ a b c d -> mappend (mappend (mappend a b) c) d
06:03:59 <lambdabot> (((mappend .) . mappend) .) . mappend
06:04:02 <ivanm> ;-)
06:04:26 <andrewsw> it looks like Language.Haskell.Exts is not in debian. Anyone know if I'm correct or just blind?
06:04:34 <WorkyBob> suppose you were to fromDynamic (toDynamic (f undefined)) where f is known to have type a -> B and be strict in its first argument, and B has a typeable instance; would you expect to get back Nothing, or Just undefined?
06:04:41 <ivanm> andrewsw: you mean the haskell-src-exts package?
06:04:49 <ski> @pl \a b c d -> mappend a (mappend b (mappend c d))
06:04:49 <lambdabot> (. ((. mappend) . (.) . mappend)) . (.) . (.) . mappend
06:04:56 <andrewsw> I tried that and it's not there.
06:04:57 <WorkyBob> and if the latter, how might I go about catching that undefined?
06:05:09 <ski> @pl \a b c d -> mappend (mappend a b) (mappend c d)
06:05:09 <lambdabot> flip flip mappend . (((.) . (.) . mappend) .) . mappend
06:05:12 <ivanm> quicksilver: anyway, with your objection... was that more because overloading ++ it clashes with the prelude, or because people associate ++ with lists?
06:05:15 <saml> andrewsw, it's not in HAskell Platform either
06:05:23 <saml> cabal install haskell-src-exts
06:05:28 <quicksilver> ivanm: quite simply that it will break a lot of old code.
06:05:30 <ivanm> saml: when it replaces haskell-src it presumably will be ;-)
06:05:32 <andrewsw> saml, thanks
06:05:38 <Ferdirand> maybe because the monomorphism restriction will cause much pain on existing code ?
06:05:42 <quicksilver> ivanm: if we were starting from scratch, I would have no objection to (++)
06:05:48 <ivanm> *nod*
06:05:51 <quicksilver> yes, as Ferdirand says.
06:05:52 <Ferdirand> ah, lag
06:05:53 <ivanm> how does the MR apply here?
06:06:03 <quicksilver> I'd still prefer +>, though.
06:06:10 <quicksilver> but my main *objection* to ++ is the breaking old code thing.
06:06:10 <ivanm> (so it is partially to do with H98)
06:06:19 <ivanm> because of lacking types?
06:06:20 <Ferdirand> ++ for mappend would be interesting
06:06:21 <quicksilver> :t foldr (++) []
06:06:22 <lambdabot> forall a. [[a]] -> [a]
06:06:27 <dcoutts_> quicksilver: you can experiment, build all of hackage using the alternative definition, see how much breaks.
06:06:30 <ivanm> so the compiler wouldn't be able to tell which monoid to use?
06:06:45 <quicksilver> ivanm: ^^ that type would become Monoid a => [m a] -> m a
06:06:58 <ivanm> *nod*
06:07:02 <quicksilver> ivanm: which woudl fall foul of the monomorphism restriction
06:07:20 <ski> @type foldr mappend []
06:07:21 <lambdabot> forall a. [[a]] -> [a]
06:07:29 <ivanm> in what way (I never could tell/remember what made ghc complain about the MR :s)?
06:08:21 <ivanm> quicksilver: actually, why would it become [m a] ? since you specify using [] as the base case...
06:08:43 <ivanm> if you said "foldr (++) mempty", that would cause the problem?
06:08:44 <Saizan> WorkyBob: Just undefined, assuming you're casting it back to B
06:09:05 <Saizan> WorkyBob: and you've to be in IO and use Control.Exception.catch and appropriate strictness
06:09:19 <jmcarthur> :t Data.Foldable.fold
06:09:20 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
06:09:44 <WorkyBob> Saizan: hmm, okay, I'll give that a twiddle and see if I can catch it
06:10:10 <jmcarthur> yeah it would just be Monoid a => [a] -> a
06:10:38 <ivanm> jmcarthur: why the monoid restriction?
06:10:44 <ivanm> as ski showed, it wouldn't be!
06:10:57 <Saizan> @type foldr mappend mempty
06:10:58 <lambdabot> forall a. (Monoid a) => [a] -> a
06:11:03 <ivanm> oh, you meant using mempty
06:11:07 <jmcarthur> @type foldr (++) mempty
06:11:07 <lambdabot> forall a. [[a]] -> [a]
06:11:11 <jmcarthur> right
06:11:11 <ivanm> whoops, forgot I typed that ;-)
06:11:32 <ivanm> @type Data.Foldable.foldr mappend mempty
06:11:33 <lambdabot> forall a (t :: * -> *). (Monoid a, Data.Foldable.Foldable t) => t a -> a
06:11:33 <ivanm> ;-)
06:11:44 <vininim> @type foldr (++) []
06:11:45 <lambdabot> forall a. [[a]] -> [a]
06:12:16 <zhxk> hello,gentlemen, who knows https 1.0, socks4/4a/5 proxry library?
06:13:15 <WorkyBob> saiam: so am I right in thinking that using catch (return $! Right $! fromDynamic d) (\e -> Left "spode") should be suitable?
06:15:19 <quicksilver> ivanm: I should have just said foldr (++)
06:15:36 <quicksilver> ivanm: which would have become Monoid m => [m] -> m -> m
06:15:38 <quicksilver> sorry.
06:15:40 <ivanm> right
06:15:44 <ivanm> that makes more sense ;-)
06:15:59 <quicksilver> WorkyBob: WARNING : attempt to catch pure exception detected. Alternate approach recommended.
06:15:59 <ivanm> and the MR rears its ugly head trying to work out which monoid instance you actually want?
06:16:10 <WorkyBob> quicksilver: oh?
06:16:32 <quicksilver> WorkyBob: consider using "cast" instead, which has a pure way to deal with type mismatch
06:16:40 <quicksilver> fromDynamic is for when you're really sure it's going to work
06:16:48 <quicksilver> (like fromJust)
06:16:49 <WorkyBob> it's not a type mismatch that's the issue
06:16:58 <ski> quicksilver : WorkyBob wants to catch an `undefined'
06:16:59 <WorkyBob> also fromDynamic returns a Maybe a
06:17:09 <quicksilver> oh, does he.
06:17:10 <WorkyBob> quicksilver: it's getting back Just undefined that I wanna catch
06:17:11 <ski> @type \d -> catch (return $! Right $! fromDynamic d) (\e -> Left "spode")
06:17:12 <lambdabot>     Couldn't match expected type `IO (Either a (Maybe a1))'
06:17:12 <lambdabot>            against inferred type `Either [Char] b'
06:17:12 <lambdabot>     In the expression: Left "spode"
06:17:14 <ski> @type \d -> catch (return $! Right $! fromDynamic d) (\e -> return (Left "spode"))
06:17:15 <lambdabot> forall a. (Typeable a) => Dynamic -> IO (Either [Char] (Maybe a))
06:17:29 <quicksilver> hmm
06:17:35 <quicksilver> apologies, I misunderstood.
06:17:36 <WorkyBob> yep, I had a couple of idiocies in there
06:17:43 <WorkyBob> but fixed, hopefully it'll catch it
06:17:59 <quicksilver> that sounds like a horrible thing to want to do ;)
06:18:04 <ivanm> idiocies like creating an undefined somewhere? ;-)
06:18:13 <ski> WorkyBob : but i think you might be happier with `try' ..
06:18:51 <WorkyBob> ivanm: unfortunately, I can't fix that -- the fromDynamic is the result of running dynCompileExpr on someone else's code
06:19:02 <ivanm> ahhhhh
06:19:06 <ivanm> (whatever that means :p )
06:19:14 <WorkyBob> I have someone else's haskell
06:19:18 <WorkyBob> I ask ghc to compile and run it
06:19:20 <WorkyBob> get back a Dynamic
06:19:24 <lilac> WorkyBob: presumably it's a real 'undefined' and not just a bottom you want to catch?
06:19:34 <WorkyBob> and want to catch them having written the progrm "main = undefined"
06:19:40 <lilac> because obviously catching a bottom in the general case is not computable
06:19:40 <WorkyBob> lilac: it is
06:19:49 * WorkyBob nods
06:19:55 <ski> @type \d -> Control.Exception.try (Data.Traversable.mapM Control.Exception.evaluate (fromDynamic d))
06:19:56 <lambdabot> forall a e. (Typeable a, GHC.Exception.Exception e) => Dynamic -> IO (Either e (Maybe a))
06:21:09 <ski> (you could probably use `traverse' instead of `mapM', there ..)
06:21:20 <ski> WorkyBob : how about that ?
06:23:11 <quicksilver> WorkyBob: why do you want to catch them having written main = undefined? I ask 80% out of curiousity and 20% because it might help motivate a good answer.
06:26:52 <WorkyBob> quicksilver: because the things I'm getting back are Meshes
06:26:57 <WorkyBob> which get handed to my renderer
06:27:05 <WorkyBob> and if they're undefined, my renderer crashes
06:27:13 <ski> why are they sometimes undefined ?
06:27:26 <WorkyBob> because someone else writes the program that generates them
06:27:41 <WorkyBob> (they could also be non-terminating, but I'm dealing with the "I know this is undefined" case atm)
06:28:00 <ski> and you can't talk that person into not generating those `undefined's ?
06:28:11 <WorkyBob> nope
06:28:13 <WorkyBob> that person could be anyone
06:28:15 <ski> (such as, e.g. giving an actual error)
06:28:20 <WorkyBob> well exactly
06:28:23 <WorkyBob> that's what I want to do
06:28:35 <WorkyBob> because them getting Prelude.undefined, and me exiting is not very useful
06:29:10 <ski> (and by error, i here mean some value in an error type, or at least a `Nothing')
06:29:21 <WorkyBob> exactly
06:29:43 <nibro_> WorkyBob: http://hackage.haskell.org/package/ChasingBottoms
06:29:49 <WorkyBob> so I'm trying to get from Prelude.undefined -> Left "oh god, something when wrong"
06:30:14 <WorkyBob> nibro: interesting
06:30:20 * WorkyBob goes staring
06:30:30 <ski> WorkyBob : what i'm wondering is why the creator of those meshes couldn't be expected to conform to this interface ?
06:30:59 <ski> (i.e. giving `Left "oh god, something when wrong"' directly, instead of having to go roundabout with `undefined')
06:31:00 <WorkyBob> ski: because they can write any program they like, and can reasonably expect the interpretter to not die when they write some programs
06:31:08 <WorkyBob> e.g. ghci does not exit if you ask it to evaluate undefined
06:31:28 <ski> ok, you want some kind of sandboxing, it seems
06:31:33 * WorkyBob nods
06:32:24 <Saizan> though you really want rnf, if the value is complex
06:32:25 <ski> i have no idea if there is any library for sandboxing ..
06:32:34 <WorkyBob> Saizan: *nod*
06:33:04 <quicksilver> WorkyBob: isn't it much more likely your users will managed to write infinite loops
06:33:10 <quicksilver> (or other uncatchable _|_s) ?
06:33:11 <WorkyBob> so isBottom (rnf d) should hopefully provide my answer
06:33:19 <nibro> WorkyBob: yep
06:33:27 <ski> WorkyBob *could* probably add some kind of timeout ..
06:33:27 <quicksilver> but, still, I can see you'd want to catch pure exceptions in that case.
06:33:32 <quicksilver> pattern match failures, etc.
06:33:39 <Axman6> WorkyBob: this sounds a lot like the halting problem to me...
06:33:39 <WorkyBob> quicksilver: it is, but that's a seperate issue â€“ I need to have some clever scheduling as *well* as catching pure exceptions
06:33:41 <quicksilver> ski: not with the GHC API, I don't think.
06:33:54 <ski> hm
06:34:02 <WorkyBob> Axman6: nope, not trying to solve the halting problem -- just catch errors when they're known to occur
06:34:06 <quicksilver> ski: the reason that lambdabot forks a separate process is that none of the GHC API based solutions provide a good timeout approach.
06:34:18 <WorkyBob> quicksilver: oh, that's interesting
06:34:27 <Saizan> well, the problem is that GHC threads are not preemptive enough
06:34:34 <WorkyBob> so the best approach is to fork a thread, and kill it when it takes too long, or when you have something else to do?
06:34:38 <quicksilver> to be fair, lambdabot is trying to be smart enough to defeat genuinely determined hackers.
06:34:39 <ski> i see .. i was assuming it was "enough" to create a new thread and kill it after a while
06:34:46 <Saizan> the GHC API gives you a lazy haskell value like the others
06:34:47 <ski> (i haven't tried anything like this on my own)
06:34:48 <WorkyBob> quicksilver: also, yeh, trying to do that too ;)
06:34:48 <quicksilver> not merely foolish users.
06:34:57 * WorkyBob notes that he should look at \bot's source
06:35:04 <quicksilver> it's a slightly different ballpark if you are writing a bot for a public channel.
06:35:11 <WorkyBob> actually, no I shouldn't -- it's GPL'd isn't it?
06:35:11 <quicksilver> I think it's sufficient to look at mueval, to see the fork stuff.
06:35:20 <nibro> > let x = 1:x in x
06:35:20 <quicksilver> looking at GPL'ed source won't taint you :P
06:35:23 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:35:31 <quicksilver> just don't copy-paste code from it.
06:35:34 <WorkyBob> quicksilver: no, but it should not be arguable that I copied it
06:35:55 <quicksilver> it's a real unix process fork(), though
06:36:00 <quicksilver> not just a haskell forkIO
06:36:04 * WorkyBob nods
06:36:12 <quicksilver> fork-and-exec, indeed.
06:36:17 <Saizan> WorkyBob: you can't catch a non-allocating loop like "fix id" that way, unless you compile with optimizations and get a <<loop>> exception
06:36:18 <ski> Saizan : oh, right .. istr reading a thread that doesn't allocate can refuse preeption ..
06:36:55 <WorkyBob> Saizan: interesting -- I was hoping that I could ask ghc-api to push evaluation on a few steps at a time in a tight loop, but it sounds like spawning a thread/process is a better plan
06:36:56 <Saizan> "that way" was with just an haskell thread
06:38:54 <quicksilver> WorkyBob: perhaps you can do that, with the new "debugger" GHC API
06:39:02 <quicksilver> it wasn't possible with the old API
06:39:04 <WorkyBob> quicksilver: *nod*
06:39:11 <quicksilver> but the debugger has some kind of evaluation step.
06:39:16 <quicksilver> I assume :)
06:39:20 <quicksilver> that might make it too slow, though.
06:41:28 <WorkyBob> okay, ChasingBottoms appeared to work
06:41:42 <WorkyBob> so now I only have the halting problem to solve conservatively
06:41:48 <WorkyBob> :)
06:41:52 <nibro> :)
06:41:58 <WorkyBob> cheers for that tip nibro
06:42:06 * WorkyBob checks what the "other license" is
06:43:11 <WorkyBob> oh, cool, MIT
06:43:13 <WorkyBob> that works :)
06:46:08 <quicksilver> WorkyBob: I note that chasingbottoms does have some timeout support
06:46:17 <quicksilver> presumably subject to the limitations already discussed about tight loops etc.
06:46:21 <quicksilver> but it might be good enough for you.
06:46:35 <WorkyBob> quicksilver: yeh, I don't quite want a timeout
06:46:52 <quicksilver> well it's a timeout to reach WHNF
06:46:55 <quicksilver> not a timeout to reach RNF
06:47:02 <etpace_> :t (.) (*2) (+)
06:47:03 <quicksilver> so in some sense, it's timeout to "Get started"
06:47:03 <lilac> does anyone else consider it evil that isBottom :: a -> Bool, not a -> IO Bool ?
06:47:04 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a -> a
06:47:20 <quicksilver> lilac: the entire library is pure unadulterated evil.
06:47:29 <quicksilver> lilac: however, it's jolly useful.
06:47:37 <WorkyBob> quicksilver: I want it to run until completion, or the user giving me a new program, so not enough
06:47:45 <quicksilver> WorkyBob: ah, ok.
06:47:53 <lilac> quicksilver: yeah :) but still, i'd rather write the unsafePerformIO which violates monotonicity myself
06:48:15 <quicksilver> it's cos quickcheck is the motivating tool
06:48:16 <quicksilver> IMO
06:48:22 <quicksilver> and quickcheck checks pure expressions.
06:49:15 <quicksilver> dcoutts_: why isn't their a cabal field for "source extensions required" ?
06:49:33 <lilac> *nod* but it might be cleaner to have the IO versions generally unavailable and the evil ones in a ChasingBottoms.Unsafe module
06:49:38 <quicksilver> by which I mean language pragmas.
06:49:41 <lilac> s/ un//
06:49:52 <Saizan> quicksilver: "extensions"
06:49:53 <dcoutts_> quicksilver: as opposed to those that are applied?
06:50:26 <quicksilver> Saizan: can I revise my quesiton to "Why am I blind?"
06:50:32 <quicksilver> dcoutts_: just ignore me ;)
06:50:55 <Saizan> :)
06:51:02 <quicksilver> although, more seriously, wouldn't it be nice if the hackage HTML page showed the extensions required?
06:51:12 <fasta> Why does one have to send an email to get a HackageDB account?
06:51:45 <fasta> That doesn't seem like a very Internet thing to do.
06:51:51 <quicksilver> lilac: off-hand I'm not convinced that even "isBottom :: a -> IO Bool" doesn't violate monotonicity.
06:52:15 <quicksilver> lilac: it certainly violates parametricity, which is a strong hint that it's going to violate monotonicity too.
06:53:32 <fasta> quicksilver: what is monotonicity in this context?
06:54:20 <quicksilver> fasta: that if a > b then f(a) > f(b)
06:54:27 <quicksilver> fasta: where ">" means 'more defined'
06:54:42 <etpace_> > (*5) . (+) 1 2
06:54:44 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
06:54:44 <lambdabot>    arising from the literal `1' at <...
06:54:49 <etpace_> > (*5) . (+) $ 1 2
06:54:50 <lambdabot>   Add a type signature
06:55:11 <etpace_> :t (*5) . (+)
06:55:12 <Saizan> > (*5) . (+) 1 $ 2
06:55:13 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a -> a
06:55:13 <lambdabot>   15
06:55:24 <etpace_> hmm
06:55:25 <lilac> quicksilver: yeah, i think you're right about that. on the other hand, it's not really worse than try
06:55:51 <quicksilver> lilac: agreed.
06:55:55 <etpace_> why doesnt 1 2 work? its a function that takes two Nums and returns a Num
06:56:05 <quicksilver> etpace_: it's not, though.
06:56:08 <etpace_> Hm
06:56:19 <quicksilver> etpace_: . composes two unary functions.
06:56:30 <quicksilver> (+), viewed as a unary function, takes one number and returns a function.
06:56:47 <quicksilver> then (*5) is applied in a context where it takes a *function* (not a number)
06:56:57 <quicksilver> leading GHC to infer the odd constraint the the function must, itself, be a number
06:57:03 <quicksilver> :t (*5) . (+)
06:57:04 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a -> a
06:57:07 <lilac> > (+) 1 2
06:57:09 <lambdabot>   3
06:57:13 <quicksilver> which is what "Num (a -> a)" in that type means.
06:57:18 <lilac> > (*5) $ (+) 1 2
06:57:19 <etpace_> aha
06:57:19 <lambdabot>   15
06:57:21 <quicksilver> it means "functions  a -> a are numbers"
06:57:28 <quicksilver> which is not, conventionally, true.
06:57:46 <lilac> there are at least two useful but confusing ways of making functions into numbers, though
06:57:55 <quicksilver> useful in some contexts, but not in this context :)
06:57:58 <quicksilver> I woudl argue.
06:58:00 <lilac> useful is perhaps too strong
06:58:24 <QtPlaty[HireMe]> Appart form church numarals what is the otherway?
06:58:35 <etpace_> I'm trying to understand it declared in point free, and I'm not sure
06:58:39 <etpace_> > (.) . (.) $ (*5) (+) 1 2
06:58:40 <lambdabot>   Overlapping instances for GHC.Show.Show
06:58:40 <lambdabot>                              ((a ->...
06:58:42 <lilac> QtPlaty[HireMe]: the one where '5 x' == '5 * x'
06:58:58 <etpace_> > (.) . (.) $ (*5) (+) $ 1 2
06:58:59 <lambdabot>   Add a type signature
06:59:02 <etpace_> hm
06:59:21 <etpace_> :t (.) . (.) $ (*5) (+)
06:59:22 <lambdabot> forall a b a1. (Num (b -> b -> b), Num b) => (a -> a1 -> b) -> a -> a1 -> b -> b
06:59:45 <skorpan> hi. i'm trying to figure out how to make a small popup menu for my tray icon in gtk2hs... any ideas on where i can read about such a thing?
06:59:55 <lilac> > ((.).(.)) (*5) (+) 1 2
06:59:56 <lambdabot>   15
07:00:45 <lilac> etpace_: function application binds tightest of all, so (.) . (.) $ (*5) (+) 1 2  == ((.) . (.)) ((*5) (+) 1 2)
07:02:14 <Axman6> hmm, i wonder if it would be possible to implement a Data.Binary instance for my AVar package...
07:02:26 <Axman6> that's an interesting idea...
07:02:27 <etpace_> lilac: That would become ((.) . ((*5) (+) 1) 2, right? I get confused from then on in
07:05:53 <fasta> quicksilver: I know what monotonicity is. The 'more defined' part however is not clear :) Parametricity also seems to be a popular word, it's just that nobody has taken the time to write the definition again, and finding the recursive transitive closure of the cite relation is not something I intend to do.
07:06:44 <fasta> quicksilver: to me it would seem that isBottom can only increase in information, which would mean it is monotone.
07:06:58 <quicksilver> fasta: 1 is more defined than _|_. (1,_|_) is more defined than (_|_,_|_). (_|_,2) is also more defined than (_|_,_|_) but (1,_|_) and (_|_,2) are incomparable.
07:07:12 <quicksilver> fasta: there is of course a formal definition but I feel that example probably makes it clear.
07:07:19 <fasta> quicksilver: right, ok. That's clear.
07:07:59 <boml> why is there an ugly perl.exe in my ghc installation?
07:08:43 <fasta> boml: evil mangler
07:08:57 <fasta> @google evil mangler
07:08:58 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
07:08:58 <lambdabot> Title: Commentary/EvilMangler - GHC - Trac
07:10:00 <quicksilver> fasta: in fact, isBottom doesn't precisely violate monotonicity, but it violates denotation in a subtle and related way.
07:10:19 <quicksilver> fasta: there must be some _|_ for which isBottom ( _|_ ) = _|_ (halting problem)
07:10:35 <quicksilver> and yet, for some other _|_, isBottom (_|_) = True
07:10:39 <fasta> quicksilver: why would that be the case?
07:10:44 <quicksilver> so isBottom isn't (denotationall) a function
07:10:46 <boml> fasta: is this to compicate reverse engineering?
07:10:48 <fasta> quicksilver: I can just see whether the code is still running, no?
07:10:53 <boml> complicate
07:11:00 <thoughtpolice> boml: no
07:11:14 <quicksilver> fasta: yes, but you can't tell for sure that it won't complete soon.
07:11:18 <fasta> boml: I have no idea, but I am pretty sure that they don't teach that on universities. ;)
07:11:30 <quicksilver> fasta: you could use a timeout, of course, but that would violate referential transparency.
07:11:40 <quicksilver> fasta: one way or another it's got to be denotationally wrong
07:11:47 <fasta> quicksilver: I thought the idea of isBottom was that you could poll it.
07:11:47 <quicksilver> to some extent you can choose your poison, of course.
07:12:00 <quicksilver> I don't think so, no. That would also be interesting.
07:12:06 <quicksilver> that's more like isEvaluated
07:12:12 <thoughtpolice> boml: it processes assembly code that is produced (indirectly) by GHC for things like tail calls, etc.
07:12:12 <quicksilver> (which is part of vacuum)
07:12:31 <boml> thoughtpolice: so it's for optimizing performance?
07:12:32 <quicksilver> or is it part of GHC internals, but used by vacuum.
07:12:40 <quicksilver> boml: it's a vital part of the compilation process.
07:12:47 <quicksilver> (but a deprecated one)
07:13:00 <quicksilver> GHC produces somethign which looks like C, but doesn't actually produce a working program.
07:13:09 <quicksilver> GCC compiles this to assembly which doesn't produce a working program.
07:13:19 <quicksilver> and then the evil mangler converts that to assembly which actually works.
07:13:32 <fasta> That is a good quote for HWN.
07:13:39 <Axman6> indeed
07:13:55 <boml> well use the best tool for the job i guess.
07:13:56 <thoughtpolice> luckily the evil mangler is only needed for -fvia-C
07:14:00 <fasta> Leaving out the final sentence and it would be a good joke.
07:14:04 <fasta> Leave*
07:14:41 <ben> How comes it does not produce a working program?
07:16:33 <thoughtpolice> ben: the EM has to remove things like function prologue/epilogue because GHC-created code does things like manage it's own stack (the actual stack is only used when calling into C code)
07:17:52 <boml> another question. I understand that most of ghc is written in haskell (except the evil mangler!). Are these .hs files included in the source distribution ghc-6.10.3-src.tar.bz2?
07:18:17 <thoughtpolice> yes
07:19:08 <quicksilver> thoughtpolice: doesn't the mangler also clean up some register use stuff?
07:19:11 <Axman6> boml: it'd be a little hard to compile witout them no?
07:19:37 <quicksilver> thoughtpolice: ISTR it's required to manage the way GHC keeps some registers global and uses some for function calls.
07:19:45 <thoughtpolice> quicksilver: i think so - it removes 'redundant' instructions and reorders things
07:19:57 <boml> Axman6: you got me there bro!
07:20:09 <quicksilver> thoughtpolice: peep hole optimisation of asm ftw.
07:20:24 <quicksilver> thoughtpolice: all this new fangled high level stuff is chicken feed.
07:20:31 <thoughtpolice> quicksilver: I thought that pinning registers when using -fvia-C was simply done with a 'register' declaration?
07:20:43 <thoughtpolice> i mean, that's how registers are pinned in the RTS
07:22:22 <quicksilver> thoughtpolice: ICBW.
07:22:38 <Axman6> > fromIntegral . fromEnum $ True
07:22:39 <lambdabot>   1
07:22:42 <Axman6> > fromIntegral . fromEnum $ False
07:22:43 <lambdabot>   0
07:23:08 <thoughtpolice> quicksilver: :)
07:23:12 <Axman6> the Data.Binary instance for Bool seems needlessly complicated...
07:23:25 <Badger> erk?
07:23:46 <Badger> upgrading SDL from 0.5.4 to 0.5.5 has broken it strangely
07:24:02 <Badger> ipl.hs:116:47:
07:24:02 <Badger>     Couldn't match expected type `SDL.SurfaceStruct'
07:24:02 <Badger>            against inferred type `SDL-0.5.4:Graphics.UI.SDL.Types.SurfaceStruct'
07:24:48 <doserj> Badger: did you recompile all dependant packages that were built using 0.5.4?
07:26:36 <thoughtpolice> quicksilver: oh, and the EM's instruction reordering is so it can put info tables for closures next to the closure code itself, in order to remove indirections etc when TABLES_NEXT_TO_CODE is on
07:26:40 <thoughtpolice> evil indeed :)
07:28:56 <Badger> ah
07:29:43 <Badger> doserj: I hadn't indeed. Thankyou :)
07:30:02 * edwardk waves hello.
07:30:17 <Axman6> o/
07:30:57 <edwardk> Is there a good overview of the Holumbus stuff somewhere?
07:32:22 <fasta> edwardk: I think there is a paper..
07:32:24 <edwardk> I'm trying to work my way through understanding what goes where to get it set up and see if its something I'd want to build on
07:35:37 <edwardk> I'm also curious if their controller can be replaced with a small paxos cluster to fix up what is seemingly a single point of failure.
07:40:11 <PeakerWork> yairchu: Why did you add yieldM? To save lifts?
07:44:34 <yestrael> ls
07:44:37 <yestrael> ls -all
07:44:47 <yestrael> exit
07:44:50 <yestrael> by
07:46:46 <PeakerWork> yestrael: new to IRC?
07:47:45 <lilac> yestrael: .   ..   -blah  -overflow
07:51:22 <edwardk> lilac: . .. _ru .se .ru .jp .it .dut .de .cz -books -blah -iphone -in-depth -freebsd -overflow
07:51:23 <edwardk> =)
07:52:24 <edwardk> not to mention non-concatenative #haskell channels like ghc, gentoo-haskell, etc in the parent 'directory' =)
08:00:37 <PeakerWork> @type forever
08:00:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
08:00:49 <PeakerWork> why not    m a -> m ()    ?
08:01:21 <edwardk> because it'll never finish, so you can have any type you want
08:01:47 <PeakerWork> IMO: its misleading -- much more stuff should have () than currently
08:01:48 <edwardk> b will unify with (), so you can pretend it has the less general type
08:01:54 <soupdragon> It's not misleading
08:02:33 <edwardk> PeakerWork: not sure I agree. I tend to like the most permissive type possible for things like that.
08:02:44 <quicksilver> I would prefer m (), so you have to make a concious decision to use in a context which really expects a 'b'
08:02:53 <PeakerWork> edwardk: I think any actual use of the "b" in forever is likely to be a mistake
08:02:55 <quicksilver> but, admittedly, you could apply the same argument to >> itself.
08:03:11 <edwardk> quicksilver: yeah
08:03:18 <PeakerWork> quicksilver: I basically see   (>>return ()) . forever -- which sparked this interest
08:03:24 * quicksilver nods
08:03:37 <SamB> I has an idea
08:03:45 <SamB> we could use m a -> m Void
08:04:02 <SamB> (same thing, really ;-)
08:04:12 <quicksilver> that would be even cleverer, yes :)
08:04:23 <SamB> (except you can't actually use that Void by mistake)
08:04:25 <edwardk> anal :: m a -> m Void; anal = fmap (const undefined)
08:04:27 <edwardk> er
08:04:33 <edwardk> anal :: Functor m => m a -> m Void
08:04:44 <PeakerWork> SamB: cool ;-)
08:04:44 <SamB> edwardk: without an undefined
08:05:06 <edwardk> for data Void, no?
08:05:20 <SamB> edwardk: we're discussing "forever"
08:05:21 <edwardk> anal = fmap (const "anal") =)
08:05:24 <bastl> is someone familiar with http://hackage.haskell.org/package/zipper ? how can i extract subexpressions using the zipper? i only get "locations" :-/
08:05:30 <edwardk> ah
08:05:48 <mansour> hello all, how can I create a list of fib and append the term to the end, starting from 1
08:06:01 <Claudius1aximus> > take 5 (iterate (\n -> 2 * n ^ 4) 2)
08:06:02 <lambdabot>   [2,32,2097152,38685626227668133590597632,4479489484355608421114884561136888...
08:06:04 <edwardk> i was talking about a general function that mapped any m a -> m Void -- so you can use it as a helper for when you want the more anal retentive type ;)
08:06:20 <SamB> edwardk: that's not safe
08:06:48 <lilac> mansour: append the term to the end? what do you mean?
08:07:16 <SamB> "Functor m => (forall a. m a) -> m Void" is, though
08:07:28 <edwardk> samb: sure it is, you can't ever use the value of type Void for anything (except admittedly seq'ing it) -- so actually I don't like the use of Void
08:07:53 <edwardk> samb: well, technically its safe, its just usable for more scenarios =)
08:07:55 <SamB> edwardk: the whole point of my type for "forever" is that there will never be a value of type Void
08:08:05 <jeffersonheard> what's wrong with this phrase in c2hs? gdalGetDataTypeSize = {#call pure GDALGetDataTypeSize as "_GDALGetDataTypeSize"#}
08:08:08 <mansour> I am looking to start from the first term and build up. I don't know if appending a term to the end of the fib list is the correct word
08:08:21 <jeffersonheard> Following the tutorial on c2hs's site, that should be legal
08:08:59 <SamB> edwardk: which is exactly what the "b" in "Monad m => m a -> m b" says, too, actually
08:09:00 <gwern> a `mappend` b \= b `mappend` a, right?
08:09:00 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
08:09:10 <gwern> @messages
08:09:10 <lambdabot> lilac said 3h 59m 11s ago: The ICFP binaries are available here: http://john.freml.in/icfp-contest-2009
08:09:11 <edwardk> samb: Sure.
08:09:27 <SamB> well, actually, saying that is only half the point
08:09:29 <edwardk> samb: the problem is of course is there is no canonical Void type to appeal to ;)
08:09:40 <edwardk> since you can make up Void and I can make up Null ;)
08:09:40 <SamB> the other half is to avoid accidentally writing code to use it
08:09:54 <SamB> edwardk: well ... we shall have to take a vote, then.
08:10:17 <edwardk> samb: i'd argue that that was done implicitly back whenever 'forever' was formalized =)
08:10:20 <quicksilver> gwern: in general, no.
08:10:29 <edwardk> so the bikeshed is already pink
08:10:31 <gwern> didn't think so
08:10:44 <gwern> edwardk: as long as the bikecon doesn't go to 1, we should be fine
08:10:54 <SamB> or rather, we shall have to ensure that the haskell' commitee is allowing the definition "data Void"
08:11:01 <lilac> gwern: it's not true in the free monoid (list)
08:11:15 <SamB> and then propose a module Data.Void for base
08:11:34 <lilac> i quite like the use of a free type variable to mean Void
08:11:54 <quicksilver> lilac: I don't, because it lets the type inferrer unify it.
08:12:10 <SamB> Data.Void would export Void(..) and two conversion functions
08:12:17 <quicksilver> s <- forever foo; putStrLn $ "But this can't happen" ++ s
08:12:28 <lilac> quicksilver: that fails either way
08:12:31 <edwardk> the main problem i have with data Void is the existence of 'seq', but I find it too useful to give up
08:12:38 <SamB> one of type (forall a. a) -> Void, the other of type Void -> a
08:12:58 <quicksilver> lilac: oh, sorry, did are we now talking about (forall b . m b) ?
08:13:00 <lilac> quicksilver: "foo v = do x <- forever v; return x" works for both too
08:13:00 <quicksilver> lilac: good :)
08:13:35 <SamB> it would be better if we could define Void as unlifted, though :-(
08:13:47 <quicksilver> SamB: how do you write the (forall a . a) -> Void one?
08:13:59 <edwardk> I only bothered to include the latter. http://comonad.com/haskell/category-extras/src/Data/Void.hs
08:14:09 <SamB> quicksilver: hmm. well, it's pretty easy in Coq
08:14:17 <lilac> are there any cases where 'forever :: m a -> m b' passes the typechecker where 'forever :: m a -> m Void' does not?
08:14:18 <SamB> maybe I'd just extract it to Haskell ;-P
08:14:31 <quicksilver> lilac: Yes. The one I gave.
08:14:36 <quicksilver> s <- forever foo; putStrLn $ "But this can't happen" ++ s
08:14:38 <lilac> quicksilver: no, that fails. no Show
08:14:39 <SamB> it'd probably involve unsafeCoerce :-(
08:14:44 <edwardk> lilac: sure, use it in one branch of an if or something
08:14:53 <quicksilver> lilac: it unifies "s" to String.
08:14:54 <lilac> quicksilver: actually i'm talking rubbish
08:15:06 <quicksilver> erm, "b" to string.
08:15:07 <quicksilver> ;)
08:15:22 <quicksilver> forever :: m a -> (forall b . m b)
08:15:22 <lilac> quicksilver: i was confusing (forall a. a) and (exists a. a)
08:15:24 <quicksilver> is more promising though.
08:15:36 <lilac> *nods*
08:15:39 <quicksilver> or is it.
08:15:41 <quicksilver> no it isn't.
08:15:46 <quicksilver> it's exactly the same thing.
08:15:47 <edwardk> quicksilver: but it lifts to the same thing
08:15:50 <quicksilver> bad logician!
08:15:55 * quicksilver thwaps quicksilver.
08:16:43 <lilac> it's the existential that you want
08:17:01 <jeffersonheard> oh.  the tutorial is wrong
08:17:10 <jeffersonheard> no quotes around hsids...
08:18:47 <edwardk> samb: you can define a haskell 98 'Void' type. newtype Void = Void Void -- still has only bottom as a member but avoids the empty data decl
08:19:06 <SamB> edwardk: kind of icky
08:19:12 <SamB> edwardk: but okay
08:19:15 <edwardk> samb: icky, but legal =)
08:19:21 <SamB> oh, but it doesn't have only bottom as a member
08:19:21 <lilac> edwardk: i'd argue that that type does not have bottom, since all its values are completely defined
08:19:27 <SamB> oh, newtype
08:19:29 <SamB> nevermind
08:19:30 <edwardk> samb: yeah
08:19:45 <edwardk> :
08:19:50 <SamB> at first I skipped that bit and assumed "data"
08:20:13 <lilac> reword: that type has only one value, whose top is its bottom, but has no undefined values
08:20:54 <lilac> presumably you wouldn't export the 'Void' data constructor?
08:21:00 <edwardk> lilac: many people have trie that argument but you can still define (undefined :: Void) or an infinite loop with type Void using newtype Void Void because there is no other way to get the rest of haskell's semantics without that having a bottom in it
08:21:25 <edwardk> lilac: you can export it all you want
08:21:35 <edwardk> you can't use it for anything novel
08:21:37 <lilac> edwardk: yes, the type's one inhabitant has a bottom (least-defined) representation, but it's not undefined
08:22:19 <lilac> exporting the data constructor seems to defeat the point, because people could still pattern match on it
08:22:33 <lilac> whereas it seems to exist to be a type which you can't do anything useful with
08:22:42 <edwardk> and? all you can do is pattern match and get the same thing
08:23:19 <quicksilver> lilac: let x = x in x is a member of that type as much as any other.
08:23:21 <edwardk> layering or stripping layers of Void is idempotent
08:23:30 <quicksilver> (or for that matter, let x = undefined in undefined)
08:23:46 <quicksilver> you can't define a haskell type which doesn't have _|_
08:23:53 <quicksilver> there's not syntax for removing the liftedness.
08:24:51 <lilac> quicksilver: yes, but 'undefined' and and 'let x = x in x' are in no way undefined in that type
08:24:59 <lilac> they're the same as 'fix Void' which is completely defined
08:25:28 <quicksilver> you seem to be using "undefined" in a peculiar sense which I don't understand.
08:25:36 <quicksilver> "let x = x in x" isn't undefined in Int, either.
08:25:56 <quicksilver> it's a valid complete Int expression, which happens to denote _|_
08:26:11 <edwardk> *Void> seq (error "Uhoh!" :: Void) () ==> *** Exception: Uhoh!
08:27:30 <lilac> edwardk: show (error "Uhoh!" :: Void) ==> "Void (Void (Void (...
08:27:32 <edwardk> Void unifies with a. it doesn't have a separate kind, so undefined :: a inhabits Void
08:28:01 <lilac> edwardk: quicksilver's right, i'm using 'defined' in a different sense than "a value distinct from bottom"
08:28:03 <edwardk> lilac: not according to that seq. I just saw my error by means of the implementation mechanism ;)
08:28:27 <lilac> edwardk: how could it not be?
08:28:35 <lilac> edwardk: fix Void clearly shows like that, and is the same value
08:28:57 <lilac> (i'm assuming a 'deriving (Show)' here btw)
08:29:19 <edwardk> oh you said 'show' not 'seq' i misparsed
08:29:23 <edwardk> sure
08:29:36 <edwardk> kk
08:30:08 <lilac> by 'fully defined' i mean that i can apply case analysis on the value until i'm blue in the face and i will not bottom out
08:31:22 <edwardk> sure because case analysis on a newtype isn't actually a case in the core language, its sugar for annotating the type equality between the newtype shell and the type it wraps
08:31:44 <lilac> i don't think explaining the 'why' via a specific implementation is useful, but i concur
08:32:20 <Saizan> data Void = Void !Void
08:32:35 <Axman6> >_<
08:32:42 <Axman6> i dislike that definition!
08:32:58 <lilac> Saizan: doesn't that type have two inhabitants?
08:32:59 <Axman6> my brain begins evaluating it... not fun
08:33:58 <Saizan> lilac: which two?
08:34:08 <edwardk> saizan: my goal was haskell 98 =)
08:34:08 <lilac> Saizan: undefined and fix Void
08:34:33 <Saizan> lilac: they are both _|_
08:34:47 <Saizan> edwardk: aren't strict fields haskell 98?
08:35:04 <Heffalump> yes
08:35:09 <lilac> Saizan: hah, yeah, good point :)
08:35:15 <edwardk> oh i guess they are
08:35:16 <edwardk> hrmm
08:35:28 <Axman6> oh man, i love SPJ
08:35:37 <edwardk> Axman6: ?
08:35:40 <lilac> Saizan: but case analysis on that type bottoms out whereas on the newtype it does not
08:35:49 <lilac> Saizan: that's essentially the difference i'm talking about
08:36:24 <Saizan> lilac: yeah, and you should do case analysis on Void, so i think i like mine better :)
08:36:24 <Axman6> edwardk: watching him doing a talk at erlang factory, and he was so disappointed when he found out that arbitrary IO was allowed in erlang
08:36:32 <Saizan> *shouldn't
08:36:33 <edwardk> hah
08:37:26 <lilac> Saizan: i think data Void; is better still, since you can't even /try/ to do case analysis
08:39:45 <edwardk> I use the 'data Void' definition myself out of ease of use
08:40:30 <jpcooper> does anyone here have experience with lighttpd and fastcgi with Haskell?
08:41:36 <edwardk> I like the newtype Void = Void Void definition because its Haskell 98 and operationally equivalent. Since the cases only exist as typing, not operationally. I don't like data Void = Void !Void because it defines a value type with an extra member and seems to have to jump through a couple of hoops to reach its bottom =)
08:42:19 <edwardk> regardless its all kinda silly
08:42:25 <jpcooper> whose all kinda silly?
08:42:59 <edwardk> jpcooper: erm the data Void discussion
08:46:22 <soupdragon> ?djinn Void -> a
08:46:22 <lambdabot> f = void
08:46:26 <soupdragon> @src void
08:46:26 <lambdabot> Source not found. It can only be attributed to human error.
08:47:23 <kosmikus> I think empty case analysis is still syntactically disallowed in Haskell. That's bad.
08:47:44 <soupdragon> :t \x -> case x of {}
08:47:47 <lambdabot> parse error on input `}'
08:47:49 <soupdragon> :O
08:47:49 <soupdragon> did I do that
08:50:14 <EvilTerran> ...
08:50:30 * EvilTerran notes that more than 512 people disappeared then reappeared there, from his POV
08:50:40 <EvilTerran> seeing as i have 1024 lines of scrollback, and it's all netsplit =/
08:50:50 <lilac> EvilTerran: you need a better IRC client :)
08:51:30 <EvilTerran> i think i should be able to add netsplit collapsing with an xchat plugin
08:52:49 <EvilTerran> might have to write a haskell xchat api first :P
09:01:23 <Axman6> @hoogle runTests
09:01:23 <lambdabot> Distribution.Simple runTests :: UserHooks -> Args -> Bool -> PackageDescription -> LocalBuildInfo -> IO ()
09:01:23 <lambdabot> Distribution.Simple.UserHooks runTests :: UserHooks -> Args -> Bool -> PackageDescription -> LocalBuildInfo -> IO ()
09:01:23 <lambdabot> Test.QuickCheck.Batch runTests :: String -> TestOptions -> [TestOptions -> IO TestResult] -> IO ()
09:01:53 <Axman6> huh, is there a reason i don't have Test.QuickCheck.Batch installed?
09:06:24 <Axman6> huh, i have both quickcheck 1.2 and 2.1...
09:06:33 <Axman6> and 1.2 is the one with Batch
09:10:58 <ski> possibly `EmptyDataDecls' should also enable `case <expr> of { }' ..
09:12:25 <Plouj> hi
09:12:28 * ski used operations with type `Foo -> M Void' to be clearly distinguish which operations wasn't supposed to return from those that were .. thereby removing possible bugs and achieving better structuring
09:12:38 <ski> hello there Plouj
09:13:58 <Plouj> ld is failing to link the simplest GLUT program: http://fpaste.org/paste/17050 Why?
09:14:20 <Plouj> I just installed GLUT with 'cabal install GLUT'
09:15:32 <Plouj> using ghc  6.10.3
09:15:52 <Zao> Plouj: ghc --make
09:16:03 <Zao> That links any relevant dependant libraries.
09:16:09 <Zao> Like say, glut :)
09:16:19 <Plouj> 'ghc --make -package GLUT main.hs -o main' ?
09:16:25 <Plouj> http://www.haskell.org/haskellwiki/OpenGLTutorial1 doesn't mention it
09:16:26 <Zao> ghc --make main   ought to do.
09:16:30 <thoughtpolice> --make will do everything for you
09:16:36 <Axman6> there's not need for -package when using --make
09:16:41 <thoughtpolice> but --make will only bring in the required libs if they're specified by the cabal package
09:16:47 <thoughtpolice> which, in the case of GLUT, I figure it would be
09:16:55 <thoughtpolice> if not you can try '-lGLUT' or something on the command line
09:16:58 <Plouj> ghc --make main fails in a similar fasion
09:17:03 <Zao> Hrm.
09:17:13 <jpcooper> when I run a programme with fastcgi which uses liftIO myThreadId, it hangs. But when I add some liftIO $ putStrLns between the lines, it works fine. Why should this be?
09:17:22 <Plouj> $ ghc --make -lGLUT main
09:17:22 <Plouj> Linking main ...
09:17:22 <Plouj> /usr/bin/ld: cannot find -lGLUT
09:17:23 <Plouj> collect2: ld returned 1 exit status
09:17:29 <jpcooper> that is, it hangs when I try to use it through lighttpd
09:17:44 <fasta> If you have two structures which share 4 fields, do you actually put those 4 fields in a separate structure and refer to them in the others?
09:17:52 <Zao> What platform is this?
09:17:59 <Plouj> x86_64 (Fedora 11)
09:18:06 <Zao> Same as me then, "worksforme"
09:18:30 <Zao> Your former invocation works too.
09:19:17 <Plouj> :(
09:19:34 <Zao> Got /usr/lib64/libglut.so* ?
09:19:44 <Plouj> yeah
09:19:45 <dafra> hi, I dont' manage to build the sqlite package on Windows. Anybody did it ?
09:19:50 <Axman6> Plouj: probably need to specify the path to the GLUT libraries
09:20:25 <Raevel> i'm doing writeChan ch =<< hGetContents h, but when i readChan all i get is "", is this some laziness issue?
09:20:32 <Plouj> Axman6: how would I do that?
09:20:34 <Zao> Plouj: Did you use the Haskell Platform or built your own?
09:20:42 <Axman6> not sure, man ghc
09:21:00 <Zao> -lglut then, as hippie platforms are case sensitive.
09:21:06 <Plouj> Zao: I'm using ghc from Fedora's repository, but I got GLUT with 'cabal install GLUT'
09:21:29 <Plouj> Zao: heh, that works!
09:21:37 <Plouj> 'ghc --make -lglut main'
09:21:49 <Zao> Plouj: Ah. I installed GHC from the reposes and GLUT through the Haskell Platform.
09:21:56 <Axman6> try -L/path/to/libs -I/path/to/includes
09:23:20 <doserj> Plouj: what does "ghc-pkg describe GLUT | grep ld-options" say?
09:23:35 <Plouj> doserj: just ld-options:
09:24:09 <Zao> ld-options: -lglut -lSM -lICE -lXmu -lXi -lGLU -lGL -lm
09:24:26 <Plouj> weird, mine is blank
09:24:35 <dafra> when i try to cabal install sqlite, I get "* Missing header file: sqlite3.6" ; i have tried to place sqlite3.h just about everywhere without success ...
09:24:42 * doserj gets the same as Zao
09:35:29 <Axman6> does anyone know what changes have been made with quickcheck 2.1? it seems very different to how it used to be, and i don't like it
09:35:51 <Axman6> (pretty much breaks the most useful parts of RWH's testing chapter)
09:40:04 <Axman6> > text "Chunk \"\STXa\t\STXa\t\STXa\t\STXa\t\STXa\b\" Empty"
09:40:05 <lambdabot>   Chunk "a        a        a        a        a" Empty
09:40:22 <Axman6> > ord '\STX'
09:40:23 <lambdabot>   2
09:45:34 <Baughn> I think you're looking for
09:45:41 <Baughn> \SOH
09:45:58 * Baughn wonders how to make \bot print that as the first byte
09:46:36 <Baughn> > text "foo"
09:46:37 <lambdabot>   foo
09:46:45 <Baughn> > text "\SOHfoo"
09:46:46 <lambdabot>   foo
09:47:11 <Axman6> Baughn: this is from a Data.Binary instance, so the actual chars aren't important
09:47:14 <Baughn> > text "\nfoo"
09:47:15 <lambdabot>   foo
09:47:31 <Baughn> Axman6: They are to me. I'm trying to make \bot dance on a pin. :/
09:47:45 <Axman6> heh
09:48:55 <Axman6> > text "test\ntest"
09:48:56 <lambdabot>   test
09:48:56 <lambdabot>  test
09:49:27 <Axman6> > text "test\n, putStrLn \"hello\""
09:49:28 <lambdabot>   test
09:49:28 <lambdabot>  , putStrLn "hello"
09:50:43 <Baughn> @echo foo
09:50:43 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "Baughn!n=svein@084202037181.customer.alfanett.no", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo foo"]}
09:50:43 <lambdabot> rest:"foo"
09:50:50 <Baughn> @commands
09:50:51 <lambdabot> Unknown command, try @list
09:50:53 <Baughn> @list
09:50:53 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:51:34 <Axman6> @echo echo
09:51:34 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "Axman6!n=Axman6@pdpc/supporter/student/Axman6", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo echo"]}
09:51:34 <lambdabot> rest:"echo"
09:52:45 <Baughn> @eval 42
09:54:33 <Baughn> > text "a\nb\n"
09:54:34 <lambdabot>   a
09:54:34 <lambdabot>  b
09:55:03 <Baughn> It adds a space as the first letter, no matter what. Meh.
09:55:06 <portnov> @index text
09:55:06 <lambdabot> Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.Html, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
10:17:35 <lilac> @echo off
10:17:35 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "lilac!n=tla@kde/lilachaze", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo off"]} rest:"off"
10:30:17 <Twey> lilac: Heheh
10:30:59 <dafra> hi, anybody using sqlite on Windows ?
10:31:38 <dafra> i fail to install it
10:31:42 <bonus> you mean with haskell/hdbc?
10:32:00 <dafra> i wanted tyakusen
10:32:06 <dafra> but i could switch to hdbc
10:32:21 <dafra> the problem is the sqlite package itself
10:32:43 <dafra> it complains for missing dependency, but i have downloaded sqlite C source
10:32:59 <BONUS> i just ticked off sqlite3 as a package in cygwin
10:33:08 <BONUS> and it works nicely
10:33:22 <dafra> i use mingw, not cygwin
10:33:24 <Cthulhon|WORK> @docs , "hax" --
10:33:24 <lambdabot> , "hax" -- not available
10:33:25 <lunabot>  luna: parse error (possibly incorrect indentation)
10:33:51 <Cthulhon|WORK> Getting any first byte you want from lambdabot is easy.
10:34:18 <Twey> It's *meant* to add a space
10:34:34 <Twey> I don't know why \b doesn't just use NOTICE
10:35:58 <ski> , () -- foo
10:35:59 <lunabot>  luna: parse error (possibly incorrect indentation)
10:36:03 <ski> , ()
10:36:05 <lunabot>  ()
10:36:16 <Cthulhon|WORK> @docs , let not = const "hax"; available = () in
10:36:16 <lambdabot> , let not = const "hax"; available = () in not available
10:36:18 <lunabot>  "hax"
10:36:30 <EvilTerran> hehe
10:42:11 <dons> ?yow
10:42:11 <lambdabot> I'm GLAD I remembered to XEROX all my UNDERSHIRTS!!
10:43:20 <BONUS> lol
10:50:38 <PeakerWork> Python's list comprehensions don't have "let" clauses, so I can use   blah <- [big expression]   instead :-)
10:53:18 <pchiusano> hello
10:54:40 <Axman6> o/ pchiusano
10:54:54 <BONUS> hey
11:09:04 * lilac tests
11:10:14 * Axman6 pokes lilac|telnet in the tubes
11:11:04 <PeakerWork> Axman6: hey, I just witnessed in my logs that about 1 year ago, you were just learning Haskell?  You've past through the learning curve pretty quickly :)  What languages have you come from?
11:11:24 <Axman6> HTML? :P
11:11:40 <Axman6> i'd dabbled in a few languages, but haskell is my first real language
11:11:59 <PeakerWork> Now you're strengthening the claim about having to unlearn imperative languages first :)
11:12:02 <Axman6> and it was probably 16 or so months ago that i started with haskell
11:12:35 <lilac|telnet> @docs ACTION is
11:12:35 <lambdabot> ACTION is not available
11:12:40 <lilac> woo
11:13:59 <lilac|telnet> @docs > 1 + 1 --
11:13:59 <lambdabot> > 1 + 1 -- not available
11:14:35 <Axman6> @docs , 1+1
11:14:35 <lambdabot> , 1+1 not available
11:14:36 <lunabot>  luna: Not in scope: `available'
11:14:39 <Axman6> @docs , 1+1 --
11:14:39 <lambdabot> , 1+1 -- not available
11:14:41 <lunabot>  luna: parse error (possibly incorrect indentation)
11:14:53 <Axman6> @docs , 1 + 1 --
11:14:53 <lambdabot> , 1 + 1 -- not available
11:14:54 <lunabot>  luna: parse error (possibly incorrect indentation)
11:15:09 <Axman6> bleh, no commending in luna
11:15:38 <Axman6> @docs , let available = True in
11:15:39 <lambdabot> , let available = True in not available
11:15:40 <lunabot>  False
11:16:29 <EvilTerran> is lunabot resistant to that kinda manipulation, though?
11:16:45 <Axman6> no, it's been done with luna too
11:16:45 <EvilTerran> if so, there should at least be no risk of an infinite loop
11:16:50 <EvilTerran> uhoh
11:16:59 <Axman6> people have got close :)
11:17:40 <EvilTerran> it guess it'd be an indirect quine
11:17:47 <jeffersonheard> question about c2hs {#get#} definitions?
11:18:24 <jeffersonheard> what's the return type of the base get definition?  the structure member i'm accessing char ** and I need to unmarshal that
11:18:25 <EvilTerran> "solve lunabot (lambdabot x) = x for x"
11:19:31 * lilac decides to stop trying rather than risking success
11:20:16 <Axman6> , test
11:20:17 <lunabot>  luna: Not in scope: `test'
11:20:30 * EvilTerran has managed to crash both bots before, anyway =/
11:20:31 <Axman6> , text "> True"
11:20:32 <lunabot>  > True
11:20:36 <Axman6> good good
11:20:42 <EvilTerran> , text "\n> ()"
11:20:44 <lunabot>  > ()
11:20:44 <Axman6> , text "\b> True"
11:20:45 <lunabot>  > True
11:20:50 <lilac|telnet> la
11:20:56 <EvilTerran> , text "foo\n> ()"
11:20:57 <lunabot>  foo
11:20:57 <lunabot>  > ()
11:21:00 <Axman6> , text "\b> True\n> False"
11:21:01 <lunabot>  > True
11:21:01 <lunabot>  > False
11:21:03 <Axman6> bah, heh
11:21:21 <burp> , text "\b> 1+1"
11:21:22 <lunabot>  > 1+1
11:21:24 <EvilTerran> i think lunabot might actually be safe, now
11:21:45 <EvilTerran> because all output goes through the output filtering for ",", if that's safe, everything will be
11:21:46 <Axman6> nah, there are other ways
11:21:59 <EvilTerran> while there doesn't seem to be centralised output sanitising in lambdabot
11:22:12 <Axman6> there probably should be...
11:23:51 <aavogt> > putStr "> error \"\""
11:23:53 <lambdabot>   <IO ()>
11:24:01 <aavogt> > "> error \"\""
11:24:02 <lambdabot>   "> error \"\""
11:24:30 <Axman6> lunabot: text "> True"
11:24:38 <Axman6> lunabot: , text "> True"
11:24:42 <Axman6> nope
11:25:32 <aavogt> > lunabot: , :: Expr
11:25:33 <lambdabot>   <no location info>: parse error on input `,'
11:25:56 <aavogt> > let (,) = [] in lunabot: , :: Expr
11:25:57 <lambdabot>   <no location info>: parse error on input `,'
11:26:05 <aavogt> > let (,) = [] in lunabot: (,) :: Expr
11:26:06 <lambdabot>   Not in scope: `lunabot'
11:26:48 <lilac> , text "foo"
11:26:50 <lunabot>  foo
11:26:51 <zebrafish> , text $ take 260 $ cycle "Do_long_strings_get_linebroken_without_a_space?__"
11:26:53 <lunabot>  Do_long_strings_get_linebroken_without_a_space?__Do_long_strings_get_line...
11:27:22 <lilac> , text "foo\rbar\nbaz"
11:27:23 <lunabot>  foobar
11:27:23 <lunabot>  baz
11:28:07 <aavogt> , text "maybe\n^H> True"
11:28:08 <lunabot>  maybe
11:28:08 <lunabot>  ^H> True
11:28:32 <lilac>  lambdabot: @docs foo
11:31:26 <lilac|telnet> @docs , let available = True in
11:31:26 <lambdabot> , let available = True in not available
11:31:30 <lunabot>  False
11:34:38 <Woof> Hm, you around, Cale?
11:34:54 <Axman6> @seen Cale
11:34:54 <lambdabot> Cale is in #haskell-in-depth, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 10h 31m 51s ago.
11:36:11 <Woof> I see : /
11:36:12 <Woof> Ty
12:07:47 <pchiusano> suppose I have data LabeledTree a b = LabeledTree a [(b, LabeledTree a b)]
12:08:41 <pchiusano> and suppose I have a [([b], a)], basically, a list of a's with a path
12:09:03 <pchiusano> can anyone think of a clean way of building the corresponding LabeledTree
12:09:25 <tromp> what a to put at internal nodes?
12:09:28 <LeoD> would it make sense to create a Num instance for Point2 (where Point2 = (Int, Int))?
12:09:48 <pchiusano> tromp: whatever is specified
12:09:50 <aavogt> pchiusano: write a function to insert a single element first?
12:10:03 <Axman6> LeoD: depends on the instance really
12:10:15 <tromp> nothing was specified
12:10:36 <tromp> what tree does [([b0,b1,b2],a0) give?
12:10:41 <aavogt> and then fold over that list to insert each one
12:11:41 <pchiusano> tromp: well, that is not well defined
12:12:34 <pchiusano> tromp: i am assuming that if there is a value at [b0,b1,b2], then there is one at [b0, b1] and at [b0]
12:12:52 <tromp> and at []
12:13:35 <pchiusano> aavogt: I like that idea, i think i just need to have the insert return a LabeledTree (Maybe a) b
12:14:15 <pchiusano> then after all the inserts, I can convert this to a Maybe (LabeledTree a b)
12:14:49 <pchiusano> assuming all the a's are defined
12:15:16 <aavogt> it is also an option to sort the input by the length of [b], which should result in a well defined labeledtree at each intermediate insertion
12:15:46 <aavogt> if it is possible to make a well defined one (ignoring duplicated paths of course)
12:16:29 <pchiusano> aavogt: that is true
12:16:39 <aavogt> @type sortBy (compare `on` (length . fst))
12:16:40 <lambdabot> forall a b. [([a], b)] -> [([a], b)]
12:17:29 <aavogt> @type foldM
12:17:30 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:17:35 <luqui> does anyone else share the feeling that all the *By's (taking a -> a -> Bool)  should be *On's (taking Ord b => a -> b)
12:17:55 <jeffersonheard> :t on
12:17:56 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:18:17 <Nereid_> @type on compare
12:18:18 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
12:18:19 <Nereid_> @type comparing
12:18:20 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:18:22 <pchiusano> aavogt and tromp: thanks for help
12:18:23 <Saizan> luqui: a -> a -> Ordering ?
12:18:28 <Botje> but GroupBy only needs Eq!
12:18:32 <luqui> Saizan, er yeah
12:18:54 <jeffersonheard> :t compare `on` fst
12:18:55 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
12:18:56 <luqui> okay, generally, map into a known typeclass instead of taking a function
12:20:18 <luqui> groupOn :: Eq b => (a -> b) -> [a] -> [[a]]; sortOn :: Ord b => (a -> b) -> [a] -> [a]; ...
12:20:44 <jeffersonheard> what package is "on" in?
12:20:47 <jeffersonheard> Data.Function?
12:20:49 <aavogt> yes
12:20:54 <luqui> in some sense, i feel like this imposes stronger preconditions than the other variants.
12:21:06 <luqui> since we typically associate instantiating typeclasses with needing to satisfy some laws
12:21:23 <luqui> but functions are total, fair game
12:22:41 <aavogt> luqui: I think your option is covered by mapping a newtype constructor over the list before using the regular nub, sort, group
12:23:11 <aavogt> no sense in manually passing a dictionary that contains a typeclass?
12:23:28 <Saizan> ?
12:23:53 <luqui> aavogt, yeah, with a custom newtype and its own instance, with its proof obligation for that instance
12:24:10 <luqui> the idea is that things like Int, [Int], Bool, etc. already have instances
12:24:15 <luqui> that are known to satisfy the laws
12:24:20 <luqui> map into one of those and you can't go wrong
12:24:43 <aavogt> Saizan: me?
12:26:46 <aavogt> @src foldM
12:26:46 <lambdabot> foldM _ a []     = return a
12:26:46 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:27:38 <aavogt> ah, I was looking for foldlM
12:31:26 <Woof> So
12:31:35 <Woof> How can I request lambdabot to join my channel?
12:32:01 <leithaus> anybody have experience with SBT under maven?
12:32:07 <Badger> ask someone like Cale
12:32:13 <kau> hello! does a library for image analysis exists? edge detection, sharpenise...
12:32:17 <Woof> Yeah I looked for him but he's not here : /
12:33:06 <aconbere> if I want to write a little program that takes each key input from my terminal one at a time in a stream, what should I be looking at?
12:33:23 <leithaus> i'm working with Szeiger's scala-query code and the latest drop appears to be dependent on sbt
12:33:29 <aconbere> getChar and getLine both seem to expect a return keypress before operating on the buffer
12:33:57 <leithaus> aconbere: hi there! switching from haskell to scala?
12:34:05 <pchiusano> leithaus: are you asking in wrong channel?
12:34:28 <leithaus> oops
12:34:31 <aconbere> heh
12:34:33 <leithaus> sry
12:34:34 <PeakerWork> aconbere: you're probably line-buffered
12:34:35 <Twey> aconbere: That depends on your buffering settings
12:34:42 <zloog> I have a record that contains a field "action :: forall b . MVar (MVar (Nntp b), (Handle -> Nntp b))". When i try to initialize the field with a newEmptyMVar, ghc says that the type is less polymorphic than expected and complains that the "Quantified type b is mentioned in the environment" Does anyone know what that means?
12:35:02 <Twey> aconbere: hSetBuffering stdin NoBuffering if you want to read individual characters
12:35:13 <Twey> (all three symbols defined in System.IO)
12:35:59 <PeakerWork> zloog: can you paste?
12:36:20 <aconbere> Twey: thanks, I just found the documentaion for setBuffering and was somewhat confused :)
12:36:43 <kosmikus> aconbere: depending on what you actually want to do, a library such as vty might also be useful
12:36:55 <PeakerWork> line-buffering is basically to allow line editing to be implemented by whatever?
12:37:08 <aconbere> kosmikus: yeah, I'm trying to start at a lower / simpler level than that.
12:37:20 <Cale> zloog: That looks like a somewhat impractical type...
12:38:08 <Cale> zloog: well... I suppose maybe you could put polymorphic values in... hmm
12:38:14 <zloog> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6426#a6426  thanks
12:38:19 <Woof> Cale, hello and welcome back : )
12:38:20 <jpcooper> I have two sources of data of different types. I would like to do a mapM over a lazy list with both of them included. What is the best way to interleave them so that there is no wait if there is a datum on either of the streams?
12:38:26 <Cale> Woof: hello
12:38:40 <djahandarie> What's the best way to get the lastest Haskell packages on my computer?
12:38:40 <jpcooper> I guess I could use Either
12:38:52 <Cale> zloog: the result of newEmptyMVar is lambda bound, and so it's monomorphic though...
12:38:55 <djahandarie> Because the ones that come with Debian are way too outdated to actually use
12:39:01 <zloog> the idea is that i can just put a function and a place to return its value into a box and have worker threads use rules to determine which ones to do with network connections available
12:39:25 <Cale> zloog: What does this b represent?
12:39:36 <kosmikus> djahandarie: install the Haskell Platform; then you have cabal-install, and can use that to install more packages if you want
12:39:42 <SamB> djahandarie: you aren't using stable, are you?
12:39:50 <monochrom> Yes, Haskell Platform.
12:39:57 <djahandarie> SamB, no, unstable, but it's still outdated
12:40:10 <monochrom> Haskell Platform bundles many useful libraries already.
12:40:17 <SamB> djahandarie: what's outdated, the packages?
12:40:20 <monochrom> Do not care about the debs.
12:40:21 <SamB> or the compiler?
12:40:41 <djahandarie> SamB, actually this box is testing
12:40:46 <djahandarie> Which would explain why
12:40:47 <Cale> zloog: What's the definition of the Nntp type?
12:41:09 <zloog> type Nntp = ErrorT NntpError IO
12:41:11 <djahandarie> SamB, IIRC you're the one who maintains a lot of them, right?
12:41:18 <SamB> djahandarie: no, kaol!
12:41:19 <SamB> heh
12:41:21 <luqui> jpcooper, if you're using lazy lists like *that*, is mergeIO what you're looking for
12:41:27 <SamB> Igloo used to do it
12:41:34 <jpcooper> thanks luqui
12:41:42 <aavogt> @type mergeIO
12:41:43 <lambdabot> Not in scope: `mergeIO'
12:41:44 <djahandarie> SamB, I just remember your name somewhere in conjunction with Haskell packages... lol
12:41:49 <Cale> zloog: oh, so why not just  MVar (MVar (Nntp ()), Handle -> Nntp ())
12:41:54 <jpcooper> @hoogle mergio
12:41:54 <lambdabot> No results found
12:41:59 <SamB> djahandarie: was probably complainaing about something ;-P
12:42:14 <Cale> zloog: after all, if it produces a result of any type at all, then it might as well produce ()
12:42:19 <luqui> @hoogle mergeIO
12:42:19 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
12:42:19 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
12:42:21 <zloog> Cale: If i did that i wouldnt be able to get the values out the nntp server
12:42:23 <Cale> (instead)
12:42:33 <Cale> zloog: You can't this way anyway.
12:42:42 <luqui> map Left over one list, map Right over the other.
12:42:55 <Cale> zloog: The type you've written says that action must be *completely* polymorphic in the choice of the type b
12:43:27 <Cale> zloog: That is, no matter what type of data you pick, the single Nntp action had better be able to produce it, or it's not polymorphic enough to go there.
12:44:00 <Cale> Which means that the Nntp action can't really produce a defined result, undefined is the only value which is in every type.
12:44:14 <olsner> maybe you could use data NNTPTask b = {...} (if it's relevant to allow different types for 'b')
12:44:29 <Cale> right
12:45:33 <aconbere> Twey: I'm probably doing something that doesn't make any sense in haskell, but here are my attempts to do a simple looping io program.
12:45:36 <aconbere> http://paste.pocoo.org/show/126168/
12:45:56 <aconbere> both of them wait until the loop exits before outputing anything
12:46:09 <zloog> Cale: Hrm,  and so the problem is there is nothing that can be put into the field action?
12:46:12 <ben> @pf \x -> x - y
12:46:12 <lambdabot> Maybe you meant: bf pl
12:46:15 <ben> guh
12:46:16 <ben> @pl \x -> x - y
12:46:16 <lambdabot> subtract y
12:46:55 <zloog> Cale: Because i wrote some code that can take the functions out of action, run them and put the values into the inner MVar
12:46:56 <Cale> aconbere: You can just set the buffering for stdin and stdout once in main
12:47:05 <monochrom> If you change putStr to putStrLn, you may be surprised.
12:47:09 <Cale> aconbere: probably there's output buffering if you're not seeing anything
12:47:18 <Cale> (probably LineBuffering)
12:47:22 <aconbere> oh!
12:47:27 <yitz> aconbere: for one thing, I think you forgot to print the character typed
12:47:33 <aconbere> yeah maybe I should set the stdout to NoBuffering as well
12:47:45 <aconbere> yitz: yeah I was just skipping that
12:47:50 <aconbere> :)
12:47:56 <zloog> Cale: And so things can be taken out but not put in due to the type?
12:48:03 <monochrom> Same story with C, Perl, Python. I wonder why people have so much trouble with Haskell in this grossly universal issue.
12:48:03 <zloog> Cale: Oh i see now, thanks
12:48:12 <Cale> zloog: Yeah, but due to the type, the only actions which can go in are ones which are completely polymorphic in their result type, and so are forced to produce undefined as their result.
12:48:39 <monochrom> â€œHi I'm doing printf("hello") I ain't see anythingâ€  I don't recall anyone asking this in a C channel.
12:49:11 <zloog> Cale: any recommendations on how to store up actions like that so that worker threads can run them without caring about the the actual type is?
12:49:23 <olsner> zloog: I think you could change taskQueue to MVar [forall b . NntpTask b] after changing NntpTask to take b as a type parameter, if you want to make the tasks polymorphic
12:49:30 <aconbere> Cale: thanks, it was totally output buffering :P
12:49:45 <Cale> zloog: If you want to be able to *use* the value, then you have to remember its type. The type represents permission to manipulate it.
12:50:07 <inimino> monochrom: perhaps it's more likely to be covered in introductory material for those languages
12:50:32 <Cale> zloog: If you know that there are certain very specific things you want to be able to do with the value, but you otherwise don't care what the type is, you could use an existential type.
12:50:54 <Cale> zloog: Or you could pass around a record consisting of those actions applied to the value.
12:51:22 <monochrom> Then when they pick up Haskell they should expect the same thing.
12:51:23 <Cale> zloog: Which is sort of the functional encoding of the OO way of doing things
12:51:32 <monochrom> Damn this English.
12:51:41 <inimino> or the ethereal nature of Haskell encourages people to forget such concerns
12:52:06 <inimino> monochrom: actually I've seen the same thing happen to newbies in C
12:52:08 <yitz> aconbere: hmm, I ran your code in ghci (the looping one) and it works fine
12:52:14 <monochrom> I mean, when they pick up Haskell, they already assume getChar is like getchar, doesn't do anything until you hit return, etc.
12:52:35 <zloog> Cale: Thanks, ill have to go back and rethink all this
12:52:59 <olsner> zloog: another way is to make nntptask private to your task-manager's module and change createNntpTask to take two functions (Handle -> Nntp b) and (b -> Nntp ()) - it feels icky to have the user manipulate an MVar in the returned NntpTask
12:53:45 <olsner> (which may or may not make sense depending on all the code outside the pasted snippet, I guess)
12:53:51 <RayNbow> @hoogle Category
12:53:51 <lambdabot> Distribution.InstalledPackageInfo category :: InstalledPackageInfo_ m -> String
12:53:51 <lambdabot> Distribution.PackageDescription category :: PackageDescription -> String
12:53:51 <lambdabot> package category-extras
12:55:01 <yitz> aconbere: I said ":m +IO", then "let getCharLoop = do hSetBuffering stdin NoBuffering; c <- getChar;" etc., all on one line separated by ;s. Then typed "getCharLoop".
12:58:43 <tristes_tigres> Hello
12:58:49 <zoheb_> I keep using the following pattern where I need to ignore the x in an IO(x) function  sumIOfn >>= \x -> return(), Is there any shorthand library fn that I can use that lets me do libfn $ sumIOfn
12:59:15 <Berengal> ()<$
12:59:17 <zoheb_> I could write it myself but I suspect it is already there
12:59:27 <Berengal> @type ()<$ getLine
12:59:28 <lambdabot> IO ()
12:59:32 <zoheb_> mzero or something
12:59:33 <aconbere> yitz: maybe ghci isn't linebuffered?
13:00:06 <dons> zoheb_: sometimes there's a 'void' defined
13:00:12 <dons> void a = a >> return ()
13:00:19 <dons> if you're trying to drop the result.
13:00:27 <tristes_tigres> returning to yesterday,s discussion of Num, can't it be mde an umbrella class, including subclasses like "ring" with + and =
13:00:29 <zoheb_> thanks dons
13:00:38 <RayNbow> hmm, it's a shame Category is a bit clumsy to use for Monoids... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6427
13:00:42 <jmcarthur_work> i've used () <$, but honestly it's pretty ugly
13:00:45 <yitz> dons: 'ignore' has been proposed for that
13:01:18 <tristes_tigres> That way existing programs won't break
13:01:40 <dons> we've been using 'void' in FFI code for > 5 years though
13:02:03 <jmcarthur_work> i love how haskellers go crazy if there is anything remotely resembling code duplication, even if it's just a >> return ()
13:02:07 <Berengal> Anything wrong with simply ignoring the result?
13:02:10 <ddvlad> hey, if i want to write a Read implementation, isn't implementing `read' enough?
13:02:14 <ddvlad> like so? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6428#a6428
13:03:17 <paolino> @src Read
13:03:17 <lambdabot> class Read a where
13:03:17 <lambdabot>   readsPrec    :: Int -> ReadS a
13:03:17 <lambdabot>   readList     :: ReadS [a]
13:03:17 <lambdabot>   readPrec     :: ReadPrec a
13:03:17 <lambdabot>   readListPrec :: ReadPrec [a]
13:03:23 <zloog> olsner: Thanks, I'll take a look at that as well. The real thing is that only one function actually creates actions for tasks and right now it just runs takeMVar and then returns that result.
13:04:05 <Berengal> jmcarthur_work: Indeed, it's awesome. Not always because of reduced duplication, but often for readability as well
13:04:06 <ddvlad> hmm... ReadS and ReadPrec are new to me. i'll go read up. thanks :)
13:04:25 <ddvlad> but, just for the record? didn't `read' use to be enough?
13:04:35 <jmcarthur_work> Berengal, while i agree, i suspect this is the reason that non-haskellers think haskell syntax is so hard to follow
13:04:52 <yitz> dons: there was a whole bikeshedding thread, no one mentioned void. It looks like gwern already pushed a patch for Control.Monad for ignore.
13:04:59 <paolino> @src read
13:05:00 <lambdabot> read s = either error id (readEither s)
13:05:09 <zoheb_> I guess >> return () is good enough, >>  was what I was looking for
13:05:12 <Berengal> jmcarthur_work: Haskell syntax is easy. What can be troublesome is all the various EDSL syntaxes
13:05:14 <jmcarthur_work> Berengal, they aren't used to entire functions being defined for such small, abstract things
13:05:30 <zoheb_> >>= \x -> looks grotesque
13:05:45 <dons> bizarre.
13:06:11 <yitz> @seen gwern
13:06:11 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 3h 28m 25s ago.
13:06:24 <dons> -- |Discard the return value of an 'IO' action
13:06:24 <dons> --
13:06:24 <dons> void     :: IO a -> IO ()
13:06:24 <dons> void act  = act >> return ()
13:06:33 <dons> in module Foreign.Marshal.Error
13:06:35 <gwern> yitz: I didn't push it
13:06:38 <gwern> I just submitted it
13:06:46 <yitz> gwern ah
13:06:46 <jmcarthur_work> that's an odd place for that function
13:06:52 <Berengal> jmcarthur_work: Yeah, 'withSnarfingGrorkle = foo' is probably a wtf in java...
13:06:56 <gwern> kind of annoyed no one has acted on it; the patch was all ready to go and no one has gainsayed it
13:07:01 <paolino> ddvlad: that code looks wrongly typed if (!!) is not rewritten by you
13:07:11 <dons> its useful for FFI stuff. generalizing it to m a -> m () would be sensible for Control.Moand
13:07:21 <dons> but it should have the same name. the name we've been using since the FFI reprot.
13:07:41 <Berengal> @hoogle m a -> m ()
13:07:42 <yitz> gwern is there a ticket?
13:07:42 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
13:07:42 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:07:42 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
13:07:48 <ddvlad> paolino: split returns a list of strings, i should have squeezed in some reads, you're right
13:07:50 <gwern> you could've complained months ago when I first starting bring it up
13:07:52 <gwern> yitz: yes
13:08:24 <yitz> do you have the number?
13:08:28 <gwern> no
13:08:31 <yitz> heh
13:10:04 <yitz> you posted the patch to the list as an attachment, no mention of the ticket number there.
13:10:29 <gwern> sure I didn't link the ticket in the thread?
13:12:05 <yitz> oh yeah there it is, 3292
13:12:17 <dons> ?bug
13:12:17 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
13:12:24 <gwern> http://hackage.haskell.org/trac/ghc/ticket/3292
13:12:43 <gwern> google turned it up quite easily. I guess google's coverage of haskell.org is better than I thought
13:12:56 <dons> i'll comment.
13:14:07 <tristes_tigres> is it possible to restrict an argument of a constructor to accept only non-empty list ?
13:14:13 <dons> yes.
13:14:43 <tristes_tigres> dons: using GADT ?
13:14:48 <dons> that's right.
13:14:49 <gwern> 'smart constructors' we call them, no?
13:14:56 <dons> no, you can do it statically
13:15:13 <balor> If I have type foo :: String -> String in a list, what's wrong with [(s1,s2)| foo s1 s2 <- l1] which just creates the same list of tuples from l1? I think I have the syntax wrong for getting a foo out of the list.
13:15:16 <dons> http://www.haskell.org/pipermail/xmonad/2007-May/000172.html
13:15:19 <dons> tristes_tigres: ^^
13:15:24 <dons> +(.:.) :: x -> List t x -> List NonEmpty x
13:15:24 <dons> +(.:.) = Cons
13:15:27 <dons> is the main thing
13:15:49 <tristes_tigres> dons: thnks? should have googled it myself, I guess
13:16:00 <yitz> gwern: if you post a comment to the ticket saying this proposal has passed please apply the patch, they'll do it.
13:16:06 <dons> balor: foo isn't a constructor
13:16:06 <yitz> just as well this time thought
13:16:10 <yitz> though
13:16:12 <dons> the thing on the lhs of <- has to be a pattern
13:16:13 <gwern> yitz: but how do I know when it has passed?
13:16:24 <dons> well. has there been consensus
13:16:26 <yitz> gwern: oh, you're supposed to set a time limit
13:16:30 <dons> you have to summarise the discussion on the ticket
13:16:36 <dons> and then propose a resolution
13:16:44 <yitz> @go haskell library submissions
13:16:45 <lambdabot> http://www.haskell.org/haskellwiki/Library_submissions
13:16:45 <lambdabot> Title: Library submissions - HaskellWiki
13:17:03 <yitz> there's the whole policy ^
13:17:07 <Woof> Ah, so Cale
13:17:08 <gwern> dons: so you want it with the name void instead
13:17:16 <dons> I think it has to be 'void', yes.
13:17:16 <Heffalump> is there a reverse application operation somewhere standard?
13:17:24 <dons> Heffalump: no! strangely!
13:17:24 <Woof> Is it possible to get lambdabot to join a channel of mine? If so, how? : )
13:17:28 <Heffalump> what's wrong with ignore?
13:17:31 <dons> Hudak had it in CoFP 15 years ago!
13:17:31 <tristes_tigres> but not wit just regular Haskel lists ?
13:17:40 <dons> Heffalump: we already have 'void' for this.
13:17:47 <dons> since the FFI came out.
13:17:53 <dons> apparently no one reads Foreign.* anymore
13:17:58 <Heffalump> I find void neither well-known nor intuitive
13:18:03 <gwern> yitz: so, if I cave into dons and rename it void, does that mean I have to gain consensus all over again? :)
13:18:08 <dons> Heffalump: void like C.
13:18:16 <Heffalump> but in C its a type, not a function
13:18:16 <dons> void foo() {}
13:18:23 <Heffalump> and if you void something, you actually undo its effects
13:18:25 <dons> indicating the result is ignored.
13:18:27 <Heffalump> not just throw away the result
13:18:36 <dons> ignore $ .. . however seems like it wouldn't evaluate its argument, to me.
13:18:38 <yitz> dons: you have to admit that ignore is a better name, especially for Monad m
13:18:38 <Heffalump> no, void indicates that there is no result. Quite different.
13:18:39 <dons> rather than discarding the result
13:18:47 <gwern> but void isn't supposed to *have* a result; here we have a result which we choose to ignore
13:18:47 <dons> shrgu.
13:18:49 <dons> bikesheds.
13:19:01 <Heffalump> you started it :-p
13:19:04 <gwern> yes, you see why I'm annoyed you brought it up
13:19:07 <dons> go look at how void $ .. is used in base already
13:19:17 <jmcarthur_work> i think both sound fine
13:19:21 <gwern> I should've just quietly set a deadline and had a fait accompli!
13:19:22 <dons> all the throwIf_ things are defined in terms of it. It's all over the FFI packages.
13:19:24 <Heffalump> F# uses ignore.
13:19:39 <yitz> now that invisibility technology is starting to come out, we can paint the bikeshed "ignore" or "void".
13:19:42 <dons> so you at least have to mention the existence of void. it has some bearing
13:19:55 <Twey> aconbere: No, that's perfectly reasonable
13:20:03 <gwern> dons: I don't see all that many uses of void in base
13:20:07 <Twey> (apart from the code duplication, of course)
13:20:12 <dons> no, its more common in FFI code
13:20:39 <gwern> there's, what, 5 usages?
13:20:55 <dons> yep. more than 0.
13:21:20 <dons> gwern: e.g. Curses.hsc uses it
13:21:45 <dons> I wonder if it is actually part of the FFI report
13:22:19 <yitz> gwern: sorry. it is sort of good that this came out though, it deserves at least thinking about.
13:22:50 <dons> yes, it is part of the standard.
13:22:54 <dons> section 5.10.2
13:22:58 <dons> Result Value Checks
13:23:12 <dons> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-350005.10
13:23:36 <dons> so no one reads the FFI addendum anymore it seems :)
13:23:37 <gwern> bleh
13:23:41 <sjanssen> void?
13:23:43 <gwern> fine, it'll be void and not ignore
13:23:43 <dons> yup
13:23:50 <sjanssen> void m = m >> return ()?
13:23:53 <dons> si.
13:24:04 <sjanssen> eh, not a big fan of that name
13:24:06 <gwern> sjanssen: but we can generalize that to functors!</edwardk>
13:24:08 <yitz> dons: it has always bothered me that the official home of such an important doc is in someone's personal web folder at unsw
13:24:15 <sjanssen> gwern: oh, I  remember now
13:24:18 <dons> yitz: interesting.
13:24:44 <sjanssen> gwern: is the actual proposal generalized as such?
13:24:45 <yitz> shouldn't it be hosted somewhere official on haskell.org?
13:24:50 <dons> it should, yes.
13:24:50 <gwern> yitz: just another way to avoid success
13:24:56 <yitz> hehe
13:24:57 <gwern> sjanssen: yeah. I figured why not
13:25:01 <burp> @hoogle ssl
13:25:02 <lambdabot> package hopenssl
13:25:02 <lambdabot> package HsOpenSSL
13:25:02 <lambdabot> Data.ByteString.Unsafe unsafePackAddressLen :: Int -> Addr# -> IO ByteString
13:25:11 <gwern> of course, my actual patch is now useless since we're naming it void and not ignore
13:25:41 <dons> probably you should reopen the discussion
13:25:57 <dons> in light of finding a relevant function in the base / standard
13:26:21 <dons> so its a slightly different proposal: should void be generalized and defined elsewhere? should it be renamed (harder).
13:26:32 <dons> or should it be ignored :)
13:26:50 <sjanssen> @hoogle void
13:26:50 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:26:54 <sjanssen> huh.
13:26:59 <dons> kids these days
13:27:12 <sjanssen> I had no idea that was there
13:27:18 <jmcarthur_work> being practical is overrated
13:27:22 * dons writes "The Underappreciated void" 
13:27:35 <Heffalump> so if the standard says IO a -> IO ()
13:27:40 <sjanssen> calling it 'ignore' might actually be seen as an upside -- no clashes with the existing name
13:27:44 <Heffalump> a library proposal to change the type would violate the standard
13:27:49 <jmcarthur_work> idealists made haskell in the first place ;)
13:27:53 <dons> yeah. you might merely redefine void = ignore
13:28:01 <gwern> when you look into the void's poetry, does it look back at you?
13:28:06 <dons> Heffalump: right. you can't change the type here.
13:28:15 <gwern> Heffalump: would defining void :: Functor f => f a -> f ()
13:28:19 <gwern> really break anything?
13:28:57 <Heffalump> gwern: I doubt it. But it's not what the standard says.
13:29:08 <jmcarthur_work> i could see it invoking that stupid monomorphism restriction or something, maybe
13:29:21 <Heffalump> and it could, if it was being used in some situation where the 'void' call was the only thing to constrain the type
13:29:44 <Heffalump> we need to be able to re-export symbols with more restricted types and not cause a name clash
13:29:52 <Heffalump> cf (&&&) and (***)
13:29:59 <jmcarthur_work> oh that would be cool
13:30:22 <Heffalump> though that would still mean Data.Tuple depending on Control.Arrow which might seem a bit weird
13:30:34 <gwern> so maybe we could define void in Control.Monad with the functor sig, and then have the FFI module import, define void = void, and specify a more restricted sig
13:30:43 <Heffalump> gwern: right, that would work
13:30:52 <Berengal> Every time I write a void function (in eager languages) I feel like I'm doing something wrong...
13:30:55 <Heffalump> and given that we're already stuck with the (IMO bad) name, seems simplest.
13:31:06 <yitz> so, dons has suggest that this proposal be voided.
13:31:26 <aavogt> which type would you get if both versions were in scope?
13:31:28 <sjanssen> gwern: why a Functor function in Control.Monad?
13:31:29 <gwern> actually, if we're leaving the original module alone, we could just make control.monad.ignore, and then do void = ignore
13:31:49 <gwern> sjanssen: edward said to me, why restrict the type to monad when functor would work just as well?
13:31:52 <jmcarthur_work> if only we could say: getLine > /dev/null    ;)
13:31:53 <sjanssen> aavogt: you'd get an overlapping names error
13:32:17 <gwern> and control.monad.ignore vs. FFI.void also means you don't clash if you import both, which is good
13:32:25 <Heffalump> why not put it in the Functor module?
13:32:46 <gwern> because no one would ever look there
13:32:49 <yitz> jmcarthur_work: let don't = return () in getLine >> don't
13:33:09 <Heffalump> but it does!
13:33:40 <yitz> Heffalump: hmm, indeed. I always liked that proposal until now.
13:33:52 <aavogt> why isn't there a module Control ?
13:34:03 <Heffalump> what would it do?
13:34:15 <jmcarthur_work> reexport EVERYTHING :P
13:34:19 <aavogt> yeah
13:34:21 <gwern> sounds dangerous
13:34:24 <balor> Given a list of items of homogenous type (Say foo :: String -> String). I can get the head of the list. But can I do something to the effect of (String, String) = head list?
13:34:25 <jmcarthur_work> i think that would be horrible
13:34:39 <yitz> it should be named LoseControl
13:34:42 <sjanssen> balor: what would the result do?
13:34:49 <gwern> balor: like \x -> (x,x)?
13:34:49 <Twey> balor: No, of course not
13:34:58 <Twey> String -> String is a function from String to String
13:35:04 <Twey> It doesn't actually contain two strings
13:35:11 <sjanssen> balor: if you want the first two elements let (x:y:_) = list
13:35:11 <Twey> You put in one string and another pops out
13:35:33 <balor> Methinks I need a more theoretical book.
13:35:37 <balor> Thanks for your time.
13:35:46 <Twey> Wait, which interpretation was correct?
13:36:00 <yitz> balor: which book are you using?
13:36:01 <michie1> speaking of books, do people here have recommendations?
13:36:14 <Twey> RWH
13:36:18 <opqdonut> foundations for programming languages is great
13:36:23 <balor> Twey: no idea.  I just want to get access to the strings in a thing (object?) of type foo.
13:36:28 <Woof> Damnit, Cale disappeared again : /
13:36:35 <Twey> (and SICP, but specifically for Haskell, RWH)
13:36:41 <Twey> Woof: He does that
13:36:47 <Twey> I think he eats and sleeps, or something
13:36:54 <Twey> He's a bit weird
13:36:56 <balor> RWH is a little too applied for me.
13:36:57 <Woof> Wow, people really do that? : /
13:37:02 <Woof> Yeah
13:37:08 <Twey> I know, it's shockin'
13:37:46 <jpcooper> @hoogle a -> Maybe a -> a
13:37:47 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
13:37:47 <lambdabot> Prelude asTypeOf :: a -> a -> a
13:37:47 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
13:38:01 <jmcarthur_work> discard getLine
13:38:24 <jmcarthur_work> i like discard more than ignore or void
13:38:36 <yitz> getLine >>= devNull
13:38:39 <jmcarthur_work> it sounds like something is still happening
13:39:04 <gwern> bikeshedding? in *my* #haskell?
13:39:07 <Meady> Guys is there a good socket library, doesnt seem to be much on the default one
13:39:18 <jmcarthur_work> bikeshedding is fun!
13:39:18 <Heffalump> discard is good
13:39:26 <yitz> Meady: what do you need?
13:40:06 <Meady> Just basic tcp/udp
13:40:20 <Meady> I wana maybe write a nice reliable UDP program myabe
13:40:22 <yitz> isn't the basic stuff there?
13:40:35 <Meady> Yeah not much docs on it tho
13:40:37 <luqui> yitz, that's cute
13:41:00 <sjanssen> yitz: of course, at that point, we should use >> return ()
13:41:07 <monochrom> IMO "Network" is very good.
13:41:13 <yitz> luqui: too platform specific though.
13:41:17 <Meady> okok
13:42:11 <yitz> Meady: people mainly complain that it's too low level, but if that's what you want, I think everything is pretty much there
13:42:12 <luqui> sjanssen, uh, isn't the whole point that (>>) :: m () -> m a -> m a
13:42:21 <sjanssen> luqui: I think that's dumb
13:42:53 <yitz> Meady: except that select-like stuff isn't exposed, you use haskell threads for that
13:43:10 <luqui> sjanssen, oh
13:43:19 <djahandarie> Hey all... I'm trying to use this example: http://darcs.haskell.org/http/test/get.hs with the latest HTTP library
13:43:27 <djahandarie> But it tells me ConnError is not defined
13:43:31 <sjanssen> luqui: it's never going to happen either, Haskell' isn't disruptive like that
13:43:38 <Meady> So instead of select-sockets, i use threading sockets to get the same asynchronous effect
13:43:40 <monochrom> If you want more low-level, Network.Socket is very good too. If you want UDP, just use those "send*" and "recv*" functions.
13:43:45 <jmcarthur_work> i see the appeal. it'd be nice for the type system to remind me that i might be forgetting to use an important return value
13:44:01 * Heffalump prefers fmap (const ()) to (>> return ())
13:44:03 <gwern> @hoogle void
13:44:03 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:44:07 <jmcarthur_work> frankly, i'm kind of disappointed that Haskell' isn't disruptive
13:44:25 <Heffalump> frankly, i'm kind of disappointed that Haskell' isn't released
13:44:27 <djahandarie> So I looked around and apparently ConnError is in Network.Stream, so imported that, but then it just told me that `Request' is not applied to enough type arguments
13:44:28 <sjanssen> I see ignore/void/whatever as a way to golf simple utility functions
13:44:28 <Meady> thanks monochrom
13:44:35 <jmcarthur_work> Heffalump, i just use () <$
13:44:43 <yitz> djahandarie: perhaps you're getting an older version? look at the output of ghc-pkg list
13:44:44 <Cale> Woof: I'm still around
13:44:44 <olsner> frankly, i'm kind of disappointed that Haskell' isn't cake
13:44:59 <djahandarie> yitz, nope, I made sure I'm on 4000.0.7
13:45:01 <Woof> Hi, Cale
13:45:09 <dons> Heffalump: yeah, fmap (const ()) is nice.
13:45:15 <Woof> I was wondering if it'd be possible to get lambdabot to join a channel of mine?
13:45:36 <luqui> fmap (const ()) rubs me the wrong way.  i don't have any idea why.
13:45:40 <olsner> or (const () <$>)
13:45:44 <luqui> maybe I like my fmaps to be linear?
13:45:53 <jmcarthur_work> == (() <$)
13:45:57 <Cale> I'm more disappointed by the general lack of willingness to break with the standard, rather than anything to do with the standards process.
13:46:10 <olsner> I think (>> return ()) makes it more clear what you're doing
13:46:16 <gwern> Woof: which channel?
13:46:24 <Cale> Woof: sure
13:46:42 <Cale> I agree that the best way to standardise things is to standardise what's implemented, but I think that if you do that, you have to be willing to be more experimental with your implementations.
13:46:48 <Woof> That one, gwern
13:46:49 <jmcarthur_work> olsner, i prefer the fmap version precisely because they abstract away what it's "doing" a bit better, IMO
13:46:55 <Woof> What is the procedure, Cale?
13:46:57 <jmcarthur_work> *fmap versions
13:47:03 <Cale> Woof: You tell me which channel.
13:47:04 <Meady> Cale with looping, if i want it to go on for ever, will it use 100%cpu unless i put a sleep in there?
13:47:18 <Woof> Wow how did you know, Cale?
13:47:21 <Cale> (I can't tell it to join without knowing)
13:47:21 <Woof> Ty!
13:47:28 <Cale> huh?
13:47:34 <Woof> Hm, it already did
13:47:38 <Woof> Maybe gwern did that?
13:47:41 <Cale> probably
13:47:42 <Woof> she*
13:47:56 <Cale> Woof: but if you want it to remain there, you still have to say :)
13:47:56 <Woof> Ty both : )
13:47:59 <Philonous> Meady: The idea is to block on a readMVar
13:48:02 <Woof> Ah
13:48:11 <Woof> That one
13:48:41 <gwern> Cale: probably best to see if that channel lasts before stc=icking it in the config
13:48:46 <yitz> Woof: it will be public, lambdabot announces a list of all channels it's joined to
13:49:07 <gwern> @seen lambdabot
13:49:07 <lambdabot> Yes, I'm here. I'm in #learnanycomputerlanguage, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #
13:49:07 <lambdabot> haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-iphone, #haskell-in-depth, #
13:49:07 <lambdabot> haskell-freebsd, #macosx, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #bfpg, #novalang, #darcs, #yi, #xmonad, #ghc, ##
13:49:07 <lambdabot> logic, #haskell-overflow and #haskell
13:49:09 <Woof> I don't mind at all, yitz, haha. Just didn't want to advertise
13:49:10 <olsner> (>> return ()) more clearly throws the old value away, I think, while the fmap (const ()) trick applies a function to the value - a function that just happens to produce nothing except throwing the value away and replacing ()
13:49:31 <Cale> I added it to the list :)
13:49:33 <monochrom> hahah friendly coders
13:49:41 <Philonous> Meady: You where concerned about how to poll information from thread, or did I misunderstand?
13:50:08 <Badger> Unicycling, eh?
13:50:44 <olsner> Badger: it's full of haskellers, swedes and pseudo-swedes like shapr
13:51:08 <Badger> What's a pseudo-swede? :P
13:51:28 <Zao> Export goods?
13:51:31 <olsner> something swede*ish*
13:51:39 <monochrom> hahaha
13:52:40 <Meady> Right got sockets working basic, need to know what to sent to retrieve http data
13:52:46 <Cale> Meady: generally, if you're doing anything at all in the loop
13:52:48 <Meady> i know server waits for certain data and then will reply with header
13:52:56 <Cale> Meady: and that operation doesn't block
13:54:16 <Meady> Yeah what do browsers first send to a webhost
13:54:17 <yitz> Meady: http is a bit complex because of keep-alive.
13:54:19 <Meady> GET isnt it?
13:54:26 <yitz> Meady: Get / HTTP/1.1
13:54:29 <yitz> GET
13:54:35 <Woof> Ty, Cale and gwern! : )
13:54:55 <Meady> ahh i see
13:54:59 <Meady> Just GET?
13:54:59 <Meady> or
13:55:00 <yitz> Meady: then you have to put in Location: url
13:55:09 <yitz> Meady: then a blank line
13:55:16 <copumpkin> :o
13:55:29 <yitz> Meady: try telnet url 80
13:55:55 <Meady> yeah
13:56:13 <Meady> http 1.1 not availiable is the response i got
13:56:16 <Meady> so socket is working :D
13:56:43 <Meady> whats different about  hGetLine compared to GetLine
13:56:50 <yitz> hmm, I got that wrong.
13:56:54 <kau> is there documentation/tutorials with haskell-src-ext?
13:57:23 <Twey> Meady: getLine = hGetLine stdin
13:57:37 <Meady> Ahh i see
13:57:45 <Meady> hGetLine allows for sockets or other input
13:57:50 <Twey> Ditto with the others
13:57:55 <Meady> right ok, guys next thing what would i wana do to add to clipboard
13:57:56 <Berengal> Hmm, google returned 503 for just GET. Is that correct?
13:58:01 <Meady> say i want to save something
13:58:02 <Twey> putStrLn = hPutStrLn stdout, &c.
13:58:09 <Meady> &c?
13:58:15 <Twey> Meady: That depends on what clipboard you're using
13:58:15 <Berengal> Isn't there some "You messed up" error code?
13:58:19 <olsner> heh, ghc -e 'Just (do it)'
13:58:21 <Meady> well windows
13:58:28 <Twey> If you're working with X, you probably want the X11 library
13:58:30 <Twey> Oh
13:58:40 <Twey> There's probably some Windows API call to do it
13:59:06 <zoheb_> Berengal thanks for the ()<$ tip
13:59:10 <Berengal> Windows API probably requires FFI though, no?
13:59:16 <Twey> From System.Win32
13:59:20 <zoheb_> I completely missed it when you wrote it earlier
13:59:24 <Twey> Berengal: No, there's a mapping to it in System.Win32
13:59:26 <kau> oh, my questions are not popular today ;)
13:59:34 <Twey> Or at least most of it
13:59:42 <Twey> kau: That's because they're indirect
13:59:50 <Meady> where would i find the api
13:59:58 <kau> what do you mean?
14:00:11 <Twey> Meady: On MSDN
14:00:24 <Twey> Info on the Haskell bindings is here: http://www.haskell.org/ghc/docs/6.8.3/html/libraries/Win32/System-Win32.html
14:00:28 <Twey> kau: Lojban joke, never mind :-P
14:00:59 <olsner> @ty (<$)
14:01:00 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
14:01:15 <zoheb_> @type ()<$
14:01:16 <lambdabot> parse error (possibly incorrect indentation)
14:01:24 <Berengal> > () <$ Just 5
14:01:25 <lambdabot>   Just ()
14:01:28 <zoheb_> @type (()<$)
14:01:29 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
14:01:54 <zoheb_> @type (<$)
14:01:55 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
14:01:59 <Berengal> (<$) = fmap . const
14:02:02 <jmcarthur_work> > '-' <$ "Hello, world!"
14:02:03 <lambdabot>   "-------------"
14:02:03 <pikhq> Twey: Lojban? Mi malÅatas lojbanon.  Sed, esperanto estas tre, tre bonega.
14:02:12 <Meady> Hmm no luck so far :s
14:02:27 <pikhq> ;p
14:03:02 <Twey> pikhq: Äˆu vi parolas LoÄµbanon?
14:03:12 <olsner> @ty ($>)
14:03:13 <lambdabot> Not in scope: `$>'
14:03:25 <Berengal> $> makes no sense...
14:03:28 <kau> Twey: your explaination is obscurer ;)
14:03:34 <aavogt> pikhq: what happens first, unconventional natural languages, or unconventional programming languages?
14:03:55 <olsner> neither does <$, to me
14:03:58 <Badger> Twey: please tell me you don't...
14:04:12 <Twey> Esperanto ne estas interesa, sed ja utila
14:04:15 <olsner> I was trying to figure out if it was part of some kind of pattern
14:04:23 <Twey> Badger: Don't what?
14:04:31 <Badger> Speak Lojban :P
14:04:36 <Twey> Oh
14:04:41 <Twey> I do
14:04:43 <Berengal> olsner: It does, from an applicative perspective. $> doesn't though, except maybe as flip <$
14:04:46 <pikhq> Twey: Ne. Kaj, mia esperanto ne estas bone.
14:05:03 <Twey> bona**
14:05:10 <Meady> Twey would you think there was a function to copy to windows cut/paste clipboard
14:05:18 <pikhq> (Mi pensas ke mi bezonas studadi...)
14:05:22 <jmcarthur_work> olsner, Berengal: some have said that <$ should be called $>, and <$ should be flip $>
14:05:31 <jmcarthur_work> the > side denoting the "special" side
14:05:45 <pikhq> Also, I had a very tough time convincing myself to not output Japanese there.
14:05:51 <aavogt> @type (*>)
14:05:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
14:05:55 <Badger> pikhq: do it!
14:06:01 <yitz> Meady: ok, sorry, it's not "Location:", it's "Host:"
14:06:03 <Berengal> jmcarthur_work: I disagree. It conflicts with the arrow pointing to the returned value in the other combinators
14:06:08 <pikhq> Badger: naze?
14:06:09 <Badger> Twey: but but... why? :P
14:06:14 <jmcarthur_work> they also said that <*> should have been <$>
14:06:20 <jmcarthur_work> and <$> should be called something else
14:06:29 <Berengal> jmcarthur_work: Following that logic, *> should be <*, <*> should be *, and <$> should be $
14:06:31 <pikhq> (gomen nasai; IME ga nai)
14:06:33 <jmcarthur_work> i disagree as well
14:06:43 <jmcarthur_work> :t (*>)
14:06:44 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
14:07:08 <Twey> pikhq: æ—¥æœ¬èªžã§ã‚‚ã„ã„ã€‚æ§‹ã‚ãªã„ã‚ˆã€‚ä»–ã®#haskellã®äººã€…ã¯çŸ¥ã‚‰ãªã„ã‘ã© :-P
14:07:09 <Berengal> What's their reasoning for <*> => <$> though?
14:07:23 <jmcarthur_work> $ is function application
14:07:33 <jmcarthur_work> it's inconsistent, it hink
14:07:35 <jmcarthur_work> *think
14:07:37 <jmcarthur_work> that proposal
14:07:56 * Twey frowns.
14:07:58 <Twey> :t ($)
14:07:59 <lambdabot> forall a b. (a -> b) -> a -> b
14:08:01 <Twey> :t (<$>)
14:08:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:08:07 <jmcarthur_work> actually, i think i misrepresented that proposal entirely
14:08:09 <Berengal> <$> is still closer to application...
14:08:11 <Twey> That's a fairly clear parallel
14:08:20 <pikhq> Twey: Wow, my kanji has gone to shit. "x wanaiyo." and "x no #haskell"...
14:08:28 <Berengal> @type (<*>)
14:08:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:08:31 <pikhq> Why am I forgetting that? It's only been a year since I was in Japanese class.
14:08:52 * pikhq needs to study on his free time. XD
14:09:50 <jmcarthur_work> i think the proposal was actually (<$>) = (Old.<*>) ; (*>) = Old.(<$) ; (<*) = flip (*>) .... and some other stuff like that
14:10:26 <jmcarthur_work> and ($>) = Old.fmap
14:10:43 <Meady> Sub ControlCopy(ByVal hWnd As Long)
14:10:44 <Meady>     SendMessage hWnd, WM_COPY, 0, ByVal 0&
14:10:44 <Meady> End Sub
14:10:51 <Meady> Thats the VB version, could be interesting
14:11:06 <kau> Twey, pikhq: thats impressive.
14:11:13 <Meady> whats equivilent of sendmessage in haskell
14:11:16 <Berengal> jmcarthur_work: Uh... yeah, not in favour
14:11:18 <Meady> Sending a message to OS
14:11:29 <Zao> Meady: Dig around in Win32.
14:11:42 <pikhq> kau: What, a bit of somewhat trivial Japanese & Esperanto?
14:11:46 <Zao> Note that it's platform dependent, as most other OSes doesn't do it that way.
14:11:58 <yitz> @hoogle Win32 message
14:11:59 <lambdabot> No results found
14:12:01 <kau> learning a constructed language isn't one my list ;)
14:12:21 <kau> wich is long and doesn't ever reduce...
14:12:25 <Twey> pikhq: Nihongo de mo ii.  Kamawanai yo.  Hoka no #haskell no hitobito ha siranai kedo.
14:12:42 <pikhq> Twey: arigatÅ.
14:12:54 <Twey> Dou itasimasite.
14:13:07 <jmcarthur_work> lojban is really cool, but i never spent more than like a few hours reading up on it, total
14:13:17 <jmcarthur_work> and that was a while ago
14:13:21 <Zao> Graphics.Win32.Window.sendMessage :: HWND -> WindowMessage -> WPARAM -> LPARAM -> IO LRESULT
14:13:29 <Zao> http://hackage.haskell.org/packages/archive/Win32/2.2.0.0/doc/html/Graphics-Win32-Window.html
14:13:34 <saml> that's one bautiful function
14:13:42 <jmcarthur_work> wow!
14:13:48 <Zao> saml: Abstracts excellently over several platforms :P
14:13:49 <kau> what it is for? i feel something philosophical behind lojban?
14:13:52 <jmcarthur_work> that makes me want to cry
14:14:31 <jmcarthur_work> kau, it's an experiment about a theory of how languages might make us think differently
14:14:43 <Meady> tyvm Zao
14:15:02 <kau> huh, the intelligence <-> language relationship?
14:15:11 <jmcarthur_work> kau, http://en.wikipedia.org/wiki/Linguistic_relativity
14:15:31 <yitz> @go whorf sapir
14:15:32 <lambdabot> http://en.wikipedia.org/wiki/Linguistic_relativity
14:15:32 <lambdabot> Title: Linguistic relativity - Wikipedia, the free encyclopedia
14:15:43 <jmcarthur_work> that
14:16:02 <dons> BONUS++ http://twitter.com/vdichev/statuses/2425319566
14:16:06 <Twey> It's not just an experiment
14:16:22 <Twey> It's a very handy language for any situation in which clarity is required
14:16:29 <jmcarthur_work> yes!
14:17:20 <jmcarthur_work> based on the bit that i know, i would consider learning it for notes, specifications, etc.
14:17:39 <jmcarthur_work> also for literary works, but that implies i would want to share it, but nobody knows lojban :(
14:19:06 <jmcarthur_work> i used to try using lojban's attitudinals in my online writings as a more formal kind of emoticon, but i think even that confused too many people
14:19:39 <Philonous> http://xkcd.com/191/
14:21:12 <ksf> any lambdabot surgeons here?
14:21:32 <ksf> I'm trying to figure out how to best add time-based callbacks
14:21:40 <Zao> jmcarthur_work: Makes about as much sense as using Python as pseudo code.
14:22:09 <Gracenotes> BLINDED BY THE LIGHT
14:22:16 <yitz> Philonous: and don't forget to read the mouse-hover
14:22:47 <Philonous> It's random gibberish
14:23:00 <ksf> Gracenotes, that, and the fact that lambdabot suffers from refactoring-induced shizophrenia.
14:23:12 <camio> How do you pronounce (>>)?
14:23:20 <ksf> bind-but-don't.
14:23:23 <ksf> then-do
14:23:25 <Gracenotes> "then" maybe
14:23:26 <Twey> Haha
14:23:28 <Twey> â€˜thenâ€™
14:23:29 <Zao> and-theeeeen
14:23:57 <Meady> guys i got it almost working, just need to get window handle
14:24:03 <ksf> I don't know how to pronouce it, but I think "no-pass bind"
14:24:03 <Meady> put <- sendMessage HWND wM_PASTE 0 Nothing
14:24:05 <Meady> HWND
14:24:06 <camio> :/
14:24:27 <Gracenotes> but with many names (like sequence, forever), it is better applied to IO
14:24:31 <Zao> You likely want to find FindWindow's Haskell cousin.
14:24:49 <Zao> Like say findWindow or findWindowEx :)
14:25:10 <Meady> Graphics.Win32.Window its in there
14:25:21 <Zao> Yup.
14:25:46 <Zao> The Win32 package is pretty much a haskellic mirror of the base bits from the Windows API.
14:26:01 <Meady> find window it is then
14:26:07 <Meady> really happy so far
14:26:14 <Meady> if i can get cut / paste going without actually cutting
14:26:19 <Meady> so instead of typing results i can just paste them
14:26:37 <Meady> getting a 17" laptop tomorrow to, instead of this 14.1
14:27:14 <Meady> not much haskell win32 dev is there
14:28:06 <Elly> I should hope not
14:28:33 <Zao> Meady: SendInput might fit your use case, but it's not in the package.
14:29:46 <Meady> SendInput?
14:30:47 <FunctorSalad> random idea... how about implementing categories through a class "class Compose bc ab ac | <fundeps> where (.) :: bc -> ab > ac"? Seems more flexible than requiring a binary type constructor
14:31:15 <FunctorSalad> (hmm... too bad edwardk isn't here... I'm sure he tried this ;))
14:31:37 <FunctorSalad> the fundeps are any-two-determine-the-other-one
14:32:01 <jmcarthur_work> FunctorSalad, dude that is an excellent idea
14:32:28 <jmcarthur_work> sounds like instance inflation though, maybe
14:32:56 <jmcarthur_work> i guess no worse than CFunctor, though
14:33:07 <FunctorSalad> :)
14:33:28 <FunctorSalad> the disadvantage is that you would have no way to express having an actual category
14:33:40 <FunctorSalad> (since you'd need some sort of quantification)
14:34:05 <FunctorSalad> not sure whether this matters in practice
14:35:20 <Meady> how is casting done again
14:35:29 <Meady> (LCPSTR) haskell string
14:35:38 <Meady> just define a function as returning LCPSTR?
14:36:13 <aavogt> are default class methods used when I specify a method that has incomplete patterns?
14:36:16 <Cale> Meady: What's LCPSTR? Is that a Haskell type?
14:36:30 <jmcarthur_work> Cale, windows stuff, i think
14:36:33 <sjanssen> Meady: Haskell doesn't have implicit (or explicit, really) casting like other languages
14:36:34 <Meady> ahh nvm
14:36:35 <Cale> aavogt: no
14:36:35 <jmcarthur_work> sounds like FFI
14:36:38 <Meady> i know how to do it
14:36:38 <Elly> windows: long pointer to constant string
14:36:46 <Elly> LPCSTR
14:36:59 <Meady> import System.Win32.Types
14:37:05 <jmcarthur_work> i hate hungarian notation
14:37:06 <sjanssen> Meady: the win32 package probably has some functions for working with that
14:37:11 <Meady> yah
14:37:13 <Meady> Thanks guys
14:37:21 <Zao> Meady: It also has friendly wrappers for just about all the functions.
14:37:28 <FunctorSalad> theres Data.Typable.Cast, but that'll only work if the thing is actually of the exact type you're casting to
14:37:37 <Zao> the c_OmgWtf functions are the raw FFI imports, the omgWtf ones are the friendly Haskell ones.
14:37:44 <FunctorSalad> .cast
14:37:54 <aavogt> Cale: thanks
14:38:17 <jmcarthur_work> unsafeCoerce! ;)
14:38:49 <Zao> jmcarthur_work: Making such jokes when beginners are present is suboptimal.
14:38:57 <Meady> hwnd <- getForegroundWindow
14:38:57 <Meady> 			sendMessage hwnd wM_PASTE 0 0
14:39:02 <Meady> Getting closer
14:39:05 <Zao> It may appear to "work".
14:39:30 <Zao> getForegroundWindow sounds rather brittle to me.
14:39:33 <jmcarthur_work> Zao, i think beginners usually have unsafe functions pounded out of their system on the first day, no?
14:39:34 <Cale> aha
14:39:43 <Cale> you can import Foreign.C.String
14:39:50 <Zao> Can't you use Spy++ to find the window title and class and use that?
14:39:56 <Cale> and then use peekCString and the other functions in that module
14:40:05 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html#t%3ACString
14:40:23 <Zao> jmcarthur_work: It annoys me to great depths that the first reply on -cafe to any "how do I get Int out of IO Int" is "unsafePerformIoLol"
14:40:30 <FunctorSalad> jmcarthur_work: ? I thought we just don't tell them
14:40:34 <Cale> Since according to the documentation for the Win32 package, type LPCSTR = LPSTR and type LPSTR = Ptr CChar
14:40:36 <Zao> As many beginners take the first reply they get and roll with it.
14:40:50 <jmcarthur_work> Zao, i agree. especially if there is no ;) to qualify it as a joke
14:40:59 <Meady> yeah getForground will be for now ill change it soon
14:41:18 <jmcarthur_work> FunctorSalad, how come beginners always seem to know about them then?
14:41:30 <Lemmih> Zao: What are you saying? Is unsafePerformIO not the correct way?
14:41:30 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
14:41:31 <FunctorSalad> :)
14:41:40 * Lemmih sneaks off to edit his code.
14:41:43 <FunctorSalad> didn't have that impression
14:42:29 <jmcarthur_work> i suspect that the first thing a lot of imperative programmers do when they sit down with haskell is see if the type system is so great by looking for unsafe functions
14:42:42 <FunctorSalad> btw is there anything wrong with unsafePerformIO . typeRepKey?
14:42:53 <FunctorSalad> I'd hope they don't change ;)
14:43:01 <jmcarthur_work> of course, these are blaring the word "unsafe," so they are easy to find, but also easy to rule out as commonly used
14:43:31 <jmcarthur_work> we have plenty of broken functions that don't prefix "unsafe" too, though
14:43:34 <FunctorSalad> ah, so we should use other words? periliousCoerce?
14:43:40 <jmcarthur_work> readFile and such
14:43:44 <FunctorSalad> (to thwart searching :))
14:43:58 <jmcarthur_work> ha
14:44:20 <jmcarthur_work> we even *encourage* lazy IO
14:44:40 <jmcarthur_work> and i believe it has also been demonstrated that seq can be used to break the type system
14:44:50 <Zao> jmcarthur_work: Which is all fine and dandy until platform FD limits bite you.
14:45:17 <jmcarthur_work> Zao, or you mistake an error for EOF, since you can't tell with readFile
14:45:24 <Zao> Or if you rely on release ordering.
14:46:23 * jmcarthur_work wonders what happens if you do readFile "foo" >>= writeFile "foo"
14:46:48 <dons> laziness happens upside your head
14:47:19 <FunctorSalad> jmcarthur_work: in which sense is seq supposed to break it?
14:47:29 <jleedev> Exception: foo: openFile: resource busy (file is locked)
14:47:33 <jleedev> that was unexpected
14:47:39 <Zao> Hasn't it been shown that seq allows for arbitrary coercing?
14:47:50 <jmcarthur_work> FunctorSalad, i forget. google could probably reveal it
14:47:51 <dons> coercing?
14:47:54 <FunctorSalad> (I know it complicates free theorems and makes Hask fail to be a category...)
14:47:56 <dons> as in type coercion?
14:48:06 <dons> that'd be kinda crappy
14:48:06 <jmcarthur_work> i think that is what was demonstrated once
14:48:14 <Meady> Just gota find the WM_Code to set text for the clipboard to copy
14:48:26 <dons> what's this? a rumour that you can write unsafeCoerce with seq?
14:48:46 <Cale> dons: lol
14:48:50 <dons> haskellers are a paranoid bunch.
14:49:07 <Cale> I think it's pretty easy to prove that you can't write unsafeCoerce with seq :)
14:49:25 <dons> that's the second time in two days I've heard this.
14:49:39 <dons> something like: complicates free theorems ==> you can write unsafeCoerce with it.
14:49:40 <Cale> after all, if you can write unsafeCoerce with seq, you should also be able to write it with const
14:49:47 <dons> :)
14:50:18 <Cale> Oh shit! The language has (\x y -> y), it's all over!
14:50:30 <dons> game over, man!
14:50:39 <dons> that 'x' could be anything!!
14:50:40 <dmwit> Meady: Why?
14:50:44 * Zao greps -cafe
14:51:04 <Meady> dmwit, you have to select the text before you can copy it
14:51:13 <Meady> WM_COPY copies selected text
14:51:28 <jmcarthur_work> oh, seq in tandem with unsafeInterleaveIO, perhaps, but that's using *two* unsafe functions
14:51:35 <dmwit> Meady: What are you talking about (I just got here)?
14:51:36 <jmcarthur_work> shouldn't even count
14:51:53 <Cale> jmcarthur_work: huh? Even with unsafeInterleaveIO, I don't see it.
14:51:58 <jmcarthur_work> actually, that still should not result in unsafeCoerce
14:51:58 <the_unamker> I got ghc
14:51:59 <Meady> No idea dmwit you just messaged me saying why
14:52:07 <jmcarthur_work> i don't know where this started
14:52:13 <Cale> jmcarthur_work: At the type level, unsafeInterleaveIO looks like id.
14:52:14 <the_unamker> 6.8.3
14:52:17 <jmcarthur_work> yes
14:52:26 <the_unamker> now what?
14:52:28 <the_unamker> lol
14:52:33 <dons> is that another rumour? that unsafeInterleaveIO lets you write unsafeCoerce #?
14:52:33 <dmwit> Meady: Right, I'm wondering what you're working on that requires you to be so low level on the clipboard.
14:52:37 <Cale> So if you could write unsafeCoerce with unsafeInterleaveIO and seq, then you could write it with id and const
14:52:41 <olsner> isn't unsafeInterleaveIO just as unsafe as unsafePerformIO?
14:52:41 <dmwit> Meady: i.e. big picture
14:52:48 <Cale> olsner: no
14:52:49 <Zao> I'm sorry, I may be confusin it with the http://haskell.cs.yale.edu/ghc/docs/6.8-latest/html/libraries/base/System-IO-Unsafe.html
14:52:49 <dons> olsner: no
14:52:56 <FunctorSalad> . o O ( also, you may go bind... )
14:52:59 <olsner> @ty unsafeInterleaveIO
14:53:00 <lambdabot> Not in scope: `unsafeInterleaveIO'
14:53:05 <Cale> olsner: In particular, you can't break the type system completely with unsafeInterleaveIO and IORefs.
14:53:23 <Cale> (while you can do this with unsafePerformIO and IORefs)
14:53:31 <Meady> i think its WM_SETTEXT
14:53:32 <Zao> Apparently my brain isn't sound at this time of day.
14:53:33 <olsner> right, I imagined it has having type IO a -> a rather than IO a -> IO a
14:53:50 <Gracenotes> @type (=<<) `asTypeOf` (<*>)
14:53:52 <lambdabot> forall a b. (a -> a -> b) -> (a -> a) -> a -> b
14:54:37 <Gracenotes> unsafeInterleaveIO a = return (unsafePerformIO a). or sumthin
14:54:51 <Cale> nope :)
14:54:58 <Gracenotes> close
14:55:08 <Cale> You also can't write unsafeCoerce with just unsafePerformIO
14:55:15 <Cale> You need polymorphic references of some type
14:55:36 <dons>   = IO ( \ s -> let
14:55:36 <dons>                    r = case m s of (# _, res #) -> res
14:55:36 <dons>                 in
14:55:36 <dons>                 (# s, r #))
14:55:44 <Gracenotes> hm. Well it is the default implementation in System.IO.Unsafe
14:55:47 <dons> is unsafeInterleaveIO :: IO a -> IO a
14:55:54 <Gracenotes> without the faculties of GHC/Hugs particulars
14:56:05 <dons> its unsafe, not unsafecoerce :)
14:56:10 <Gracenotes> but otherwise import GHC.IOBase (unsafePerformIO, unsafeInterleaveIO).
14:56:22 <Gracenotes> wha
14:56:41 <sjanssen> Gracenotes: return (unsafePerformIO x) is practically the same thing as the version involving RealWorld#
14:57:02 <Gracenotes> buh, so Cale is talking about unsafeCoerce?
14:57:13 <Cale> unsafeCoerce x = let r :: IORef a; r = unsafePerformIO (newIORef undefined) in unsafePerformIO (do writeIORef r x; readIORef r)
14:57:37 <jmcarthur_work> wow
14:58:13 <Gracenotes> $ cat /dev/zero > blah
14:58:16 <dmwit> Meady: Oh, are you working on some kind of "select-to-copy" emulation of *nix on Windows?
14:58:17 <Gracenotes> ^C
14:58:19 <Gracenotes> $ shred -zuv blah
14:58:25 <Gracenotes> .. because I'm feeling productive today
14:58:35 <dmwit> Meady: If so, may I strongly recommend that you use an existing system?  It turns out there are more strange issues with it than you might think.
14:59:03 <Cale> (the explicit type signature is not required, it's just the inferred type)
14:59:09 <dmwit> Meady: http://fy.chalmers.se/~appro/nt/TXMouse/ always works the way I want it to
15:00:20 <Zao> People click to focus apps? I tend to abuse Alt-Tab and Alt-Esc.
15:00:31 <jkramer> Ahoy
15:00:37 <olsner> Cale: how can the writeIORef and readIORef use different data types for the IORef?
15:00:43 <Cale> The reason that IORefs are normally safe is that you can't normally let-bind the construction of one of them. It's always an IO action which produces them, and to use the value you have to use >>= with a lambda. Lambdas have monomorphic parameters.
15:01:00 <Cale> olsner: The IORef is polymorphic
15:01:08 <Cale> r :: forall a. IORef a
15:01:12 <olsner> ah, right
15:01:20 <Cale> hmm...
15:01:44 <olsner> that's probably the third time I go from "wth" to "oh, I get it" in the exact same way about the unsafeCoerce/IORef trick
15:01:48 <jmcarthur_work> (do writeIORef r x; readIORef r) should make r have the same type, shouldn't it?
15:01:50 <jkramer> I'm having a little problem with Ints and Fracts
15:01:52 <jkramer> http://haskell.pastebin.com/m5c539632
15:02:02 <jmcarthur_work> oh, no
15:02:12 <jmcarthur_work> ugh, that's just weird
15:02:25 <jkramer> For some reasong ghc refuses to compile it because of some confusion with ints and fracts
15:02:31 <dmwit> jkramer: use `div` instead of (/) for Integrals
15:02:39 <jkramer> Ah, ok
15:02:49 <jkramer> Howver, shouldn't truncate force Int context?
15:02:59 <dmwit> jkramer: Not on its input. ;-)
15:03:27 <dmwit> jkramer: i.e. (n / 2) forces a constraint on n:
15:03:30 <dmwit> :t (/)
15:03:31 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:03:50 <jmcarthur_work> > let x :: Num a => a; x = 5 in (x :: Int, x :: Double)
15:03:51 <lambdabot>   (5,5.0)
15:03:55 <dmwit> jkramer: Since Int(eger) isn't a Fractional instance, you can't do (/) division on it.
15:04:06 <jmcarthur_work> sometimes i like the monomorphism restriction
15:04:11 <Cale> jmcarthur_work: There really must be a let.
15:04:12 <dmwit> jkramer: Likewise, since most Fractional instances aren't Integral instances, you can't do `mod` on them.
15:04:16 <jkramer> Ah, now I get it
15:04:28 <Cale> jmcarthur_work: It's nothing to do with the monomorphism restriction really.
15:04:37 <jkramer> So if I use fromIntegral first and afterwards truncate the result, it should work too, right?
15:04:42 <Cale> jmcarthur_work: But it is related to ML's value restriction, which is much more heavy-handed.
15:05:00 <dmwit> jkramer: Yep, that would be okay.
15:05:13 <jkramer> I'll use div anyway :)
15:05:15 <Cale> (things which are not explicitly functions cannot be polymorphic in any way)
15:05:22 <jkramer> Thanks
15:05:39 <Cale> Which is why in ML, you can't write things in points-free style if you want any polymorphism.
15:05:43 <dmwit> jkramer: But integer division is much more efficient than floating-point division (especially with a cast on each end).
15:06:14 <yitz> dmwit: not so clear on modern machines
15:06:46 <dmwit> yitz: oh, okay
15:06:59 <dmwit> But... can it actually be *faster* to convert twice and divide?
15:07:15 <dmwit> (fp divide, that is)
15:07:18 <yitz> dmwit: e.g. the standard Mersenne twister code now uses floats, with casts at each end, because it's faster
15:07:31 <dmwit> yow
15:07:59 <yitz> they can use more cache register and hardware parallelism
15:08:18 <Meady> got a problem with sendMessage() 4th argument is LPARAM, im doing it fine but with WM_SETTEXT its saying expected an int
15:08:56 <jmcarthur_work> Cale, it throws me off that (x :: Num a => a; x = 5) results in a different value for each type x is bound to but (let r :: IORef a; r = unsafePerformIO (newIORef undefined)) makes r point to the same data even with different types
15:09:23 <Cale> jmcarthur_work: it's not typeclass polymorphic
15:09:29 <sjanssen> jmcarthur_work: the difference is the class argument
15:09:32 <jmcarthur_work> oh
15:09:38 <dons> dcoutts: http://www.galois.com/~lerkok/techSeminarSlides/streamfusion.pdf  isabelle/holcf stream fusion equivalence proof method
15:09:43 <jmcarthur_work> i see now
15:09:51 <jmcarthur_work> x has a fromInteger in there
15:09:58 <Cale> yeah
15:10:10 <Cale> and the class dictionary is a hidden parameter to the resulting function
15:10:38 <Cale> But here, r really is just a single value.
15:11:21 <Cale> (with a parametrically polymorphic type)
15:11:31 <jmcarthur_work> it makes sense to me now
15:11:31 <dmwit> Meady: Did you see my link to TXMouse?
15:12:00 <jmcarthur_work> it's still pretty gross
15:12:20 <IamMilan> txmouse owns
15:12:54 <Meady> dmwit link me again friend
15:13:38 <IamMilan> i dont get how they could ever make it different in modern os'es
15:14:01 <FunctorSalad> link me sarah, link me again
15:14:28 <dmwit> http://fy.chalmers.se/~appro/nt/TXMouse/
15:14:33 <IamMilan> just want to input something into a windows thats lurking below your current want for one second without having to raise? -> sloppy focus is the cure
15:14:33 <dmwit> Meady: ^_^
15:14:55 <IamMilan> *current one
15:15:52 <IamMilan> ofcourse with xmonad that wouldnt be an issue ever :)
15:15:54 <dmwit> I hate window-managers that confuse focuse with z-order.
15:16:02 <dmwit> -focuse +focus
15:16:26 <Meady> Nice dmwit
15:16:38 <IamMilan> yes, but there is worse: the ones that dont let you change the default behaviour :)
15:16:55 <Meady> Expected type GHC.int.int32 got char
15:17:07 <dons> chr/ ord
15:17:09 <dons> :t chr
15:17:10 <lambdabot> Int -> Char
15:17:11 <dons> :t ord
15:17:12 <lambdabot> Char -> Int
15:17:16 <dons> :t fromIntegral
15:17:17 <lambdabot> forall a b. (Integral a, Num b) => a -> b
15:18:51 <dmwit> jkramer: Having just looked at your code for real, might I interest you in iterate?
15:19:17 <pikhq> :t chr . ord
15:19:18 <lambdabot> Char -> Char
15:19:26 <Cale> jmcarthur_work: Normally, type variables are not allowed to be instantiated with polymorphic types, but if they were, we could write unsafeCoerceIO without even needing unsafePerformIO
15:19:27 <pikhq> I invented the identity function! YAY!
15:19:31 <dmwit> > let collatz n | n `mod` 2 == 0 = n `div` 2 | otherwise = 3 * n + 1 in takeWhile (>1) . iterate collatz $ 32
15:19:31 <pikhq> :P
15:19:32 <lambdabot>   [32,16,8,4,2]
15:19:42 <dmwit> > let collatz n | n `mod` 2 == 0 = n `div` 2 | otherwise = 3 * n + 1 in takeWhile (>1) . iterate collatz $ 33
15:19:43 <lambdabot>   [33,100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2]
15:20:22 <Cale> jmcarthur_work: ordinarily, the a in (>>=) :: IO a -> (a -> IO b) -> IO b isn't allowed to be something like (forall t. IORef t)
15:20:23 <dmwit> > let collatz n | n `mod` 2 == 0 = n `div` 2 | otherwise = 3 * n + 1 in break (==1) . iterate collatz $ 33
15:20:24 <lambdabot>   ([33,100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,...
15:20:39 <jmcarthur_work> Cale, that must be why it's not allowed ;)
15:20:40 <dmwit> > let collatz n | n `mod` 2 == 0 = n `div` 2 | otherwise = 3 * n + 1 in fst . break (==1) . iterate collatz $ 5
15:20:41 <lambdabot>   [5,16,8,4,2]
15:20:51 <dmwit> gr
15:21:01 <dmwit> How to get that last 1 on there...
15:21:10 <dmwit> :t until
15:21:11 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
15:21:15 <Cale> jmcarthur_work: Well, perhaps it's part of the reason, but this is also what prevents us from writing  runST $ ...
15:21:54 <Cale> The type variables in $'s type must be instantiated with monomorphic types, and runST absolutely demands a polymorphic parameter.
15:22:06 <jmcarthur_work> Cale, forall a b . a -> a -> b is just not the same as (forall a . a) -> (forall a . a) -> (forall b . b) ... i definitely have no problem accepting this :)
15:22:25 <Cale> jmcarthur_work: Well, not just not the same
15:22:30 <Cale> jmcarthur_work: they don't unify
15:22:35 <jmcarthur_work> yeah, the $ is a bummer
15:22:38 <jmcarthur_work> right
15:22:46 <dmwit> bleh
15:23:10 <Meady> word :: String -> LPARAM
15:23:10 <Meady> word wor = wor
15:23:15 <Meady> That an ok way to convert?
15:23:16 <Cale> So work is ongoing to 'fix' this, and we might end up with something that makes IORefs technically unsafe ;)
15:23:34 <dmwit> Meady: Not unless you literally have "type LPARAM = String" somewhere.
15:23:43 <Meady> ah i see
15:23:47 <Meady> So i need soem form of conversion
15:23:56 <Meady> type LPARAM = LONG
15:24:07 <jmcarthur_work> Cale, what?!
15:24:46 <Meady> Any advice on converting String to Lparam
15:24:57 <Cale> jmcarthur_work: IORefs are right on the limit of type safety, and small enhancements to the type system can make them dangerous.
15:25:43 <jmcarthur_work> i tend to believe that weakening the type system is only occasionally an actual enhancement
15:25:43 <Cale> Normally, it wouldn't be so bad to permit polymorphic instantiation of type variables, I think. It just makes type inference really hard.
15:26:22 <Cale> Even so, the worst you'll get is  unsafeCoerceIO :: a -> IO b
15:26:33 <Cale> which we already can write with Ptrs
15:27:00 <jmcarthur_work> that isn't so bad, if that's the worst
15:27:05 <jmcarthur_work> IO has no semantics anyway
15:27:07 <Cale> well... perhaps only for storables :)
15:27:34 <jmcarthur_work> IO b could reset the universe without breaking the type system
15:27:52 <jmcarthur_work> anyway, time to go. thanks for the interesting conversation
15:28:32 <dmwit> What!  IO has no semantics?
15:28:34 <Meady> anyone?
15:28:40 <Cale> yeah, I don't agree about that :)
15:28:41 <dmwit> What was that whole "tackling the awkward squad" paper about, then?
15:28:43 <Meady> Casting String as LPARAM
15:28:48 <Cale> Meady: casting?
15:28:59 <dons> how is LPARAM constructed?
15:29:01 <Cale> Meady: what do you want to do?
15:29:06 <Meady> It doesnt really say dons
15:29:10 <Meady> just says its a type
15:29:14 <Meady> view source/
15:29:24 <Cale> LPARAM is the same as CLong?
15:29:43 <Meady> think so
15:29:44 <Meady> Its a long
15:29:47 <Meady> but windows's long
15:29:53 <dmwit> Cale: Looks like type LPARAM = LONG, type LONG = Int32
15:29:58 <Cale> ah yes
15:29:59 <dmwit> (according to hackage)
15:30:00 <dons> String sounds like the wrong type to be feeding in...
15:30:06 <dons> unless you want to read it.
15:30:18 <Cale> So, you want to parse the string as a number?
15:30:41 <Meady> well in C
15:30:43 <Meady> it would be
15:30:50 <Meady> (LPARAM)"Hello World"
15:31:02 <dons> what would that do?
15:31:15 <dons> cast the char * to ...
15:31:16 <Cale> Or you want to allocate a chunk of memory, write the bytes for the string into that memory, and then turn the pointer to that memory into an Int32...
15:31:33 <Cale> I think that's what the C code means.
15:31:54 <dons> so convert to a CString, castPtr ?
15:32:00 <dmwit> It's what the C code means, and the msdn documentation for LParam does seem to indicate it's basically a void *.
15:32:06 <Meady> maybe
15:32:08 <Meady> i dont know mate tbh
15:32:34 <Meady> http://hackage.haskell.org/packages/archive/Win32/2.2.0.0/doc/html/src/System-Win32-Types.html#LPARAM
15:32:50 <dons> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html
15:32:55 <dons> relevant to your interests.
15:33:00 <dons> newCString :: String -> IO CString
15:33:04 <Cale> withCString myString (\cs -> let n = fromIntegral (ptrToIntPtr cs) in ...)
15:33:11 <DavidInTx> (newbie question):  if I install something via "cabal install <module>", should I expect that module to be listed in ghc-pkg list ?
15:33:12 <Cale> n is the LPARAM value which you want there.
15:33:18 <dons> DavidInTx: yup
15:33:38 <dcoutts> DavidInTx: that "package" yes. Packages contain modules.
15:33:46 <Meady> CAle explain abit more please?
15:33:56 <Cale> You'll need to import Foreign.C.String and Foreign.Ptr
15:34:02 <Meady> ahh have you looked at source?
15:34:09 <dons> Meady: withCString converts a haskell string to a char * in C land
15:34:13 <Meady> ahh
15:34:13 <Meady> i see
15:34:14 <Meady> ok
15:34:19 <Cale> Meady: Haskell strings are not stored as contiguous bytes in memory.
15:34:33 <Meady> i didnt actually know that, why not
15:34:40 <Cale> Because they are lists
15:34:45 <Meady> yeah
15:34:48 <Meady> but a list is an array isnt it?
15:34:48 <Cale> (of 32-bit Char values)
15:34:50 <Cale> no
15:34:57 <Cale> A list is very very different from an array.
15:35:01 <dmwit> (linked) list
15:35:08 <Cale> The first clue is that lists can be infinite :)
15:36:03 <Peaker> How does withCString convert unicode stuff?
15:36:04 <Cale> A list is either the empty list [], or it is of the form (x : xs) where x is an element of the list, and xs is another list. In memory, (x:xs) looks like a structure with a pair of pointers pointing to x and xs
15:36:07 <Meady> could you explain what you wrote above?
15:36:13 <Meady> the CString function
15:36:18 <Cale> Meady: sure
15:36:22 <Meady> still not getting \func
15:36:28 <Cale> CString is a Haskell type for C style strings
15:36:33 <Meady> yeah
15:36:42 <Cale> withCString :: String -> (CString -> IO a) -> IO a
15:36:52 <halberd> Suppose P(x) is a set in type theory.  Is {x : P(x) true} a set in type theory? what is it called?
15:37:06 <Cale> It takes a normal Haskell String, and a function which given a CString, does some stuff
15:37:18 <yitz> Peaker: probably chops off higher-order bytes
15:37:21 <Meady> o lost :s
15:37:31 <Meady> takes a string, and outputs IO a
15:37:33 <Cale> and it manages the allocation of some memory for that CString and copying the characters of the Haskell string into that memory while that action runs
15:37:35 <Meady> whats happening in the middle
15:37:50 <yitz> @src withCString
15:37:50 <lambdabot> Source not found. There are some things that I just don't know.
15:38:09 <DavidInTx> concretely, I did a "cabal install haskeline", which I now see in /usr/local/lib/haskeline-0.6.1.6/ghc-6.10.3/System/Console/Haskeline, but I don't see that in ghc-pkg, nor  can I compile a program which imports System.Console.Haskeline
15:38:17 <kynky> for whatever size of memory u have, in that space you can fit moe element of an array than a list, assuming all elements have equal size
15:38:18 <Peaker> yitz: yucky
15:38:24 <yitz> yeah
15:38:41 <Peaker> withCStringUtf8
15:38:45 <Cale> So it allocates a large enough chunk of memory, copies the characters of the Haskell String into the CString, and then passes the function a pointer to the memory it allocated (as a CString value), and then runs the action. Once the action finishes, it deallocates the CString.
15:38:56 <DavidInTx> this probably indicates some problem with my haskell install, right?
15:39:08 <dmwit> halberd: It's called a set comprehension.
15:39:25 <dmwit> halberd: And yes, there's the axiom schema of comprehension that says it is, indeed, a set.
15:39:28 <Meady> ok so whats the function one mroe tiome
15:40:48 <dcoutts> DavidInTx: does ghc-pkg list haskeline say it's installed?
15:40:49 <Cale> Meady: simpler example, suppose we have  foo :: CString -> IO ()
15:40:59 <DavidInTx> no, it doesn't
15:41:00 <Cale> Meady: imported from C via the FFI
15:41:11 <Meady> aight
15:41:15 <dcoutts> DavidInTx: that's very odd
15:41:16 <Cale> Meady: So in C, we might have  void foo (char*)
15:41:25 <Meady> yep
15:41:30 <dcoutts> DavidInTx: did it report any error during install?
15:41:39 <halberd> thanks dmwit
15:41:46 <Cale> Meady: then   withCString "hello" (\cs -> foo cs)
15:41:48 <DavidInTx> no
15:41:57 <DavidInTx> ah, I think I found the problem
15:42:02 <Meady> withCString Does that mean using cs
15:42:05 <Cale> will turn the Haskell String "hello" into a CString while foo runs
15:42:10 <dcoutts> DavidInTx: multiple ghc installations?
15:42:15 <Cale> cs :: CString
15:42:16 <Cale> in that
15:42:19 <Meady> still dont get (\cs :S
15:42:28 <Cale> Do you understand lambdas?
15:42:31 <DavidInTx> when I log in as the user that I ran cabal install haskeline as,
15:42:36 <Cale> > (\x -> x*x) 5
15:42:37 <lambdabot>   25
15:42:37 <DavidInTx> I see it in ghc-pkg
15:42:45 <dcoutts> DavidInTx: right, default is per-user
15:42:52 <DavidInTx> ah, ok, thanks
15:42:57 <Meady> how did we know x was 5
15:43:08 <dancor> what would be a cool way to version-control a Set
15:43:30 <dancor> if you write the contents to a file in-order and use a normal VCS on that, you will get too many conflicts i think
15:43:34 <aavogt> > (\x -> x*x) 0
15:43:35 <lambdabot>   0
15:44:42 <Meady> > (\x -> x*x*x)
15:44:43 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
15:44:43 <lambdabot>    arising from a use of `...
15:44:54 <Cale> Meady: (\x -> x*x) means the function which takes a parameter x and gives x*x
15:45:10 <Cale> Meady: and we can use it like any other function by giving it a parameter
15:45:16 <Cale> > (\x -> x*x*x) 10
15:45:17 <lambdabot>   1000
15:45:18 <Meady> ahh i see
15:45:25 <Meady> okok
15:45:26 <dancor> @pl \ x -> x * x
15:45:26 <lambdabot> join (*)
15:45:31 <Cale> So we can write functions without having to give them names.
15:45:51 <dancor> @pl \ x -> x * x * x
15:45:51 <lambdabot> (*) =<< join (*)
15:46:07 <dancor> that's interesting
15:46:10 <Cale> This is probably the single most important thing your language must be able to do if you want to call it a functional language
15:46:15 <mike-burns> :t (\x -> x * x)
15:46:16 <lambdabot> forall a. (Num a) => a -> a
15:46:33 <Meady> ahh i see
15:46:38 <Peaker> Cale: why is giving functions a name such a big deal?
15:46:38 <Meady> so what was that function one more time Cale
15:46:38 <dancor> Cale: well what about just being able to pass around functions
15:46:50 <Cale> dancor: well, that's also very important :)
15:47:02 <Cale> Hmm, yeah, maybe that's a little more important.
15:47:03 <mike-burns> dancor: That's the other single most important thing.
15:47:12 <dancor> lol
15:47:28 <Cale> But if you're forced to give every function a name, you probably won't really write in a functional style all that often.
15:48:12 <dancor> also currying is pretty big, "functional programming" in php is a disaster because you need a new function if you want to make one argument constant etc
15:48:49 <dancor> even though php has lambdas!
15:49:48 <Meady> cale can you show me that function again?
15:49:54 <Cale> Meady: sure
15:50:04 <Cale> Meady:  withCString "hello" (\cs -> foo cs)
15:50:08 <Meady> i see
15:50:14 <Cale> actually that case is really simple
15:50:17 <Cale> so we could write
15:50:18 <Meady> so hello is passed to CS
15:50:21 <Cale> Meady:  withCString "hello" foo
15:50:25 <Cale> which is actually the same
15:50:31 <dancor> @pl \ cs -> foo cs
15:50:31 <lambdabot> foo
15:50:31 <Meady> whats foo?:
15:50:41 <Meady> that wont return my LPARAM:P
15:50:51 <Cale> Meady: remember, it had type CString -> IO ()
15:51:02 <Cale> Meady: I'm taking this one step at a time.
15:51:20 <Cale> Meady: this is what you do for C functions which have type  void foo (char *)
15:51:49 <yitz> Peaker: yeah, it basically does fromIntegral . ord to a Word8.
15:52:07 <Cale> But yours has type void foo (LPARAM), which is trickier. We need to turn that CString into a number.
15:52:07 <Meady> CString is a function?
15:52:11 <Cale> CString is a type
15:52:17 <Meady> was going to say
15:52:17 <Meady> ok
15:52:20 <Meady> so how do we go about that
15:52:23 <Cale> It's a type of pointers to CChar
15:52:29 <yitz> http://darcs.haskell.org/packages/base/Foreign/C/String.hs
15:52:32 <Cale> type CString = Ptr CChar
15:52:38 <Cale> as the documentation says :)
15:52:58 <Cale> So now all we need is a way to turn pointers into integers.
15:53:05 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html#t%3AIntPtr
15:53:22 <Meady> ahhi see
15:53:24 <Meady> let me work it out
15:53:26 <Meady> and tell me if i get it
15:53:34 <Cale> here is a type of pointer which is in the class Num and Integral
15:53:49 <Cale> and so we can use fromIntegral to convert it to other types of number
15:53:56 <Cale> (In particular, Int32)
15:54:15 <Cale> So we just have to turn our Ptr CChar into an IntPtr, and then into Int32
15:54:57 <Meady> What effort
15:55:15 <Cale> It's a sort of sickening contortion to go through, but the C library you're interfacing with isn't exactly pretty to begin with ;)
15:55:30 <Meady> hmm
15:55:49 <Cale> at least in the end, it's pretty short
15:55:57 <Cale> suppose you're trying to call:
15:56:05 <Cale> foo :: LPARAM -> IO ()
15:56:10 <Cale> then you just write
15:56:34 <Cale> withCString str (\cs -> foo (fromIntegral (ptrToIntPtr cs)))
15:56:35 <uzytkownik> @pl \f m -> arr (f *** id) <<< runPureInputT m
15:56:35 <lambdabot> (. runPureInputT) . (<<<) . arr . (*** id)
15:56:52 <Meady> word :: String -> IntPtr
15:56:52 <Meady> word wor = ptrToIntPtr wor::CString
15:56:53 <Meady> :S?
15:56:55 <Cale> You can even wrap foo up in that way, so that you can just use it with normal Strings
15:56:56 <Meady> anywhere near?
15:57:15 <Cale> uhhh
15:57:19 <Cale> word :: CString -> IntPtr
15:57:41 <Cale> But you already have ptrToIntPtr which does that
15:57:47 <Meady> word :: String -> IntPtr
15:57:47 <Meady> word wor = ptrToIntPtr newCString "Hello"
15:57:48 <Meady> even
15:58:01 <Cale> not quite :)
15:58:06 <Meady> wor even instead of hello
15:58:30 <Cale> you're also missing parens, but even then it's a type error
15:58:43 <Cale> newCString :: String -> IO CString
15:59:06 <Meady> Right ok
15:59:13 <Meady> But that wont return an IntPtr
16:00:54 <Cale> It'll also leak memory, since you'll need to free the pointers you construct.
16:01:08 <Meady> We want to return Int32
16:01:12 <Meady> not CString?
16:01:12 <Cale> This is why I wanted withCString, because that's careful to free the memory that it allocates.
16:01:48 <Cale> ptrToIntPtr and fromIntegral will get you from CString to Int32
16:02:05 <Meady> k
16:02:09 <Cale> If cs :: CString, then fromIntegral (ptrToIntPtr cs) :: Int32  (as a possibility)
16:02:49 <Cale> and you really want to use withCString to avoid forgetting to deallocate memory
16:03:21 <Meady> myLPARAM str = withCString str (fromIntegral (ptrToIntPtr cs))
16:03:41 <Cale> cs isn't in scope
16:03:54 <Meady> ok let me try again
16:03:58 <Cale> and if you wrote that on its own, you'd get a number, but it would be meaningless by the time you'd finished.
16:04:19 <Cale> withCString takes care of deallocating the CString after the action you pass it finishes
16:04:21 <Meady> well im still not understanding namless functions
16:04:32 <desp> Is it possible to somehow "load" a static library into GHCI?
16:04:47 <Meady> why you would want it nameless
16:05:01 <Cale> Meady: because there's no need to name it?
16:05:09 <Meady> ok
16:05:15 <Meady> myLPARAM str = withCString str (\cs -> foo (fromIntegral (ptrToIntPtr cs)))
16:05:16 <Cale> Meady: we just want to express what we're going to do with the CString
16:05:25 <Meady> So i understand cs = str?
16:05:25 <Cale> right.
16:05:34 <Cale> cs is the CString version of str
16:05:36 <erikc> desp: a static C library?
16:05:36 <lambdabot> erikc: You have 1 new message. '/msg lambdabot @messages' to read it.
16:05:59 <Meady> i dont get why we have foo tho
16:06:08 <Meady> foo is are nameless function?
16:06:15 <Cale> Meady: foo is just whatever it was you wanted to do with the LPARAM
16:06:26 <Meady> oh
16:06:35 <Meady> i wana have a function return the LPARAM from a String
16:06:39 <Meady> ideally a function thats
16:06:52 <Meady> :: String -> LPARAM, so i just type func "hello world"
16:07:02 <Cale> Meady: That's problematic though.
16:07:20 <Cale> Meady: Because memory has to be allocated for that converted string every time, and you must remember to deallocate it.
16:07:27 <Meady> Hmm
16:07:29 <Cale> (just like in C)
16:07:30 <Meady> Ok
16:07:31 <Meady> Yeah
16:07:37 <Meady> right ok
16:07:41 <Cale> So withCString takes care of it
16:07:42 <Meady> go though ur version one more time
16:07:42 <Meady> myLPARAM str = withCString str (\cs -> foo (fromIntegral (ptrToIntPtr cs)))
16:07:45 <inimino> @seen vixey
16:07:45 <lambdabot> I saw vixey leaving #haskell, #scala, #perl6 and ##logic 5m 15d 23h 6m 28s ago, and .
16:07:57 <Meady> str is passed as cs as a CString, which is then converted by a nameless function
16:08:00 <Cale> Well, myLPARAM is a poor name probably ;)
16:08:07 <Meady> cause foo is not in scope
16:08:17 <Cale> Meady: well, foo should be something in scope
16:08:23 <Cale> Probably something from the win32 api
16:08:28 <desp> erikc: yep
16:08:41 <Cale> Meady: What was it that you wanted to call?
16:08:43 <desp> erikc: I know this doesn't seem like a wise question, but maybe there's a hack :)
16:08:46 <Meady> Just a SendMessage
16:08:57 <Meady> so i could actually pass Foo aswell/
16:09:18 <Cale> okay, so  sendMessage :: HWND -> WindowMessage -> WPARAM -> LPARAM -> IO LRESULT Source
16:09:22 <Meady> yeah
16:09:34 <drhodes> functions which belong to a type class, do they have a more specific name than function?
16:09:48 <Cale> drhodes: typeclass polymorphic function?
16:10:09 <drhodes> no, has to be less than 8 charachers :)
16:10:14 <zebrafish> drhodes: I've heard "method", but I don't know how official that is
16:10:14 <Cale> drhodes: or you mean the methods of the class?
16:10:22 <Cale> It's the term that the report uses
16:10:28 <zebrafish> ah.
16:10:45 <erikc> desp: no easy way that i know of, the code in the static lib needs to have it's relocations resolved before it would be executable
16:10:53 <erikc> its
16:10:59 <Meady> 			withCString "hiii" (\cs -> sendMessage hwnd wM_SETTEXT 0 (fromIntegral (ptrToIntPtr cs)))
16:11:01 <desp> Right.
16:11:16 <Cale> Meady: seems good
16:12:12 <Meady> Doesnt actually work sadly
16:12:19 <Meady> withCString "hiii" (\cs -> sendMessage hwnd wM_SETTEXT 0 (fromIntegral (ptrToIntPtr cs)))
16:12:19 <Meady> 			sendMessage hwnd wM_COPY 0 0
16:12:24 <Meady> That should set selected text and then copy it
16:12:51 <Cale> okay
16:13:13 <Cale> I think I'd have to look at the win32 apis more carefully...
16:13:22 <Meady> Hmm
16:13:24 <Cale> Does it expect you to deallocate the string you pass it?
16:13:43 <Cale> (that is, does it go to the trouble of making its own copy of your string?)
16:15:15 <Meady> notsure
16:15:30 <Meady> if you close IE after copying text, it still pastes
16:16:25 <Cale> put the second message inside the withCString
16:16:40 <Cale> withCString "hiii" (\cs -> do sendMessage hwnd wM_SETTEXT 0 (fromIntegral (ptrToIntPtr cs)); sendMessage hwnd wM_COPY 0 0)
16:16:57 <Cale> actually, for prettiness sake:
16:17:02 <Cale> withCString "hiii" $ \cs -> do sendMessage hwnd wM_SETTEXT 0 (fromIntegral (ptrToIntPtr cs)); sendMessage hwnd wM_COPY 0 0
16:18:28 <dmwit> Cale, Meady: Yes, the Windows clipboard copies any text you send it.
16:18:42 <Cale> dmwit: But what about WM_SETTEXT?
16:18:58 <dmwit> Isn't that the clipboard message?
16:19:09 <Cale> It sets the text of a window
16:19:27 <dmwit> Oh, well, then I have no idea.
16:19:52 <Cale> Well, we could always try handing over responsibility for deallocating the string, and see if that works any better.
16:20:45 <Cale> Dealing with issues like this all the time makes me wonder how anyone manages to write real programs in C.
16:21:17 <Cale> The documentation doesn't even bother to say what the convention is.
16:21:49 <dons> Cale: human ingenunity.
16:22:37 <Cale> Meady: if you want a more practical library for writing gui apps that's at least been polished a little more, even though it was also originally a C library, try gtk2hs.
16:22:51 <Cale> It works in windows too, from what I understand.
16:22:59 <Meady> im not looking for gui tho thats the thing
16:23:02 <Meady> just copying text
16:23:04 <Cale> ah
16:23:12 <Cale> okay then :)
16:24:43 <Meady> a <- fromIntegral ptrToIntPtr newCString "hi"
16:25:49 <Meady> >a <- fromIntegral ptrToIntPtr newCString "hi"
16:25:55 <Meady> > a <- fromIntegral ptrToIntPtr newCString "hi"
16:25:56 <lambdabot>   not an expression: `a <- fromIntegral ptrToIntPtr newCString "hi"'
16:26:06 <Meady> Giving me problems
16:30:20 <dr_sureshhh> hi there
16:30:25 <dr_sureshhh> i need some help
16:31:12 <inimino> why does ghci not know that a string literal is a string?
16:31:19 <uzytkownik> @pl \x -> Kleisli (\y -> return (x,y))
16:31:19 <lambdabot> Kleisli . (return .) . (,)
16:31:22 <dr_sureshhh> how do i make(in haskell) something like this : let f = a !! x + b!!x where x >=0 x < 10?
16:31:42 <sjanssen> inimino: what do you mean?
16:32:12 <inimino> sjanssen: I mean if I open ghci and enter 'sort "abc"' it doesn't work
16:32:12 <hzap> dr_sureshhh: what's wrong with just f = (a !! x) + (b !! x)
16:32:44 <uzytkownik> @hoogle sort
16:32:44 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
16:32:44 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
16:32:44 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
16:32:44 <hzap> > sort "abc"
16:32:45 <lambdabot>   "abc"
16:32:46 <inimino> "No instance for (Data.String.IsString [a]) arising from the literal `"abc"' at <interactive>:1:5-9"
16:33:08 <dr_sureshhh> [hzap]: i want for all the list
16:33:15 <dr_sureshhh> [hzap]: sum lists
16:33:27 <hzap> @type sum
16:33:28 <lambdabot> forall a. (Num a) => [a] -> a
16:33:42 <hzap> dr_sureshhh: this sums lists
16:33:46 <dr_sureshhh> [a,b]+[c,d]=[a+c,b+d]
16:33:49 <sjanssen> inimino: hmm, have you turned on OverloadedStrings?  Or loaded a module in ghci that uses it?
16:33:53 <hzap> oh
16:34:09 <sjanssen> > "abc"
16:34:09 <lambdabot>   "abc"
16:34:11 <hzap> > zipWith (+) [1,2,3,4] [5,6,7,8]
16:34:12 <lambdabot>   [6,8,10,12]
16:34:23 <hzap> dr_sureshhh: are you looking for this?
16:34:29 <uzytkownik> @pl \m f -> PureInputT $ app <<< (first $ arr $ runPureInputT . f) <<< m
16:34:29 <lambdabot> (PureInputT .) . flip ((<<<) . (app <<<) . first . arr . (runPureInputT .))
16:34:41 <inimino> sjanssen: hm, maybe...
16:34:47 <dr_sureshhh> thanks hzap
16:34:52 <dr_sureshhh> zipWith works fine
16:34:59 <uzytkownik> @pl \m f -> PureInputT $ m >>> (first $ arr $ runPureInputT . f) >>> app
16:34:59 <lambdabot> (PureInputT .) . (. ((>>> app) . first . arr . (runPureInputT .))) . (>>>)
16:35:13 <sjanssen> inimino: it works for me in the default settings of ghci 6.8.2 and 6.10.1
16:35:24 <Peaker> > liftA2 (+) (ZipList [1..4]) (ZipList [5..8])
16:35:25 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
16:35:25 <lambdabot>    arising ...
16:35:31 <Peaker> > runZipList $ liftA2 (+) (ZipList [1..4]) (ZipList [5..8])
16:35:32 <lambdabot>   Not in scope: `runZipList'
16:35:35 <Peaker> > unZipList $ liftA2 (+) (ZipList [1..4]) (ZipList [5..8])
16:35:35 <lambdabot>   Not in scope: `unZipList'
16:35:40 <Peaker> @src ZipList
16:35:40 <lambdabot> Source not found. stty: unknown mode: doofus
16:35:41 <inimino> sjanssen: yes, -XOverloadedStrings is turned on
16:35:44 <inimino> sjanssen: I don't remember why I did that...
16:35:47 <Peaker> @hoogle ZipList a -> [a]
16:35:48 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
16:35:48 <lambdabot> Prelude repeat :: a -> [a]
16:35:48 <lambdabot> Data.List repeat :: a -> [a]
16:35:52 <Peaker> > getZipList $ liftA2 (+) (ZipList [1..4]) (ZipList [5..8])
16:35:53 <Badger> @src liftA2
16:35:53 <lambdabot> liftA2 f a b = f <$> a <*> b
16:35:53 <lambdabot>   [6,8,10,12]
16:35:57 <Peaker> yay ;-)
16:36:01 <Peaker> damn lack of Show instance, heh
16:36:40 <dr_sureshhh> hzap someother thing, can i overload operators?
16:36:41 <inimino> sjanssen: it works now, thanks :)
16:37:16 <hzap> dr_sureshhh: what are you trying to overload?
16:37:54 <dr_sureshhh> vectors
16:38:00 <dr_sureshhh> matrix
16:38:03 <dr_sureshhh> + - *
16:38:34 <hzap> dr_sureshhh: you can write a "instance Num Vector where ..."
16:38:41 <inimino> @hoogle &&&
16:38:41 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
16:40:33 <dr_sureshhh> thanks, 'll look for
16:43:47 <Meady> haskell officially sucks for windows programming
16:43:54 <Cale> Meady: sorry, I was away for a bit -- did you get that problem worked out with the parens?
16:44:14 <Meady> nop
16:44:23 <Meady> haskell just sucks for windows
16:44:26 <Cale> fromIntegral ptrToIntPtr newCString "hi" -- means: pass fromIntegral the three parameters ptrToIntPtr, newCString, and "hi"
16:44:37 <Cale> which isn't what you want
16:44:49 <Meady> fromIntegral (ptrToIntPtr (newCString "hi"))
16:44:56 <Cale> right
16:45:18 <Cale> well, then you have a different problem
16:45:21 <Meady> doesnt actually work
16:45:21 <Meady> lol
16:45:23 <Cale> right
16:45:33 <Cale> because newCString "hi" is not a CString
16:45:42 <Meady> doesnt that return a cstring?
16:45:45 <Cale> you need to run it
16:45:49 <Cale> it's an IO CString
16:45:57 <Meady> oki
16:46:07 <Cale> So either:
16:46:24 <Meady> a <- fromIntegral (ptrToIntPtr (\x <- newCString "hi"))
16:46:41 <Cale> do cs <- newCString "hi"; doSomethingWith (fromIntegral (ptrToIntPtr cs))
16:46:51 <Cale> Or:
16:47:16 <Cale> do n <- fmap (fromIntegral . ptrToIntPtr) (newCString "hi")
16:47:31 <Cale>    doSomethingWith n
16:48:15 <Cale> Meady: to be fair, I don't think C is any better for windows programming. (Having done a fair amount of that way back when)
16:49:25 <Meady> cs <- newCString "hello world"
16:49:25 <Meady> 			sendMessage hwnd wM_SETTEXT 0 (fromIntegral (ptrToIntPtr (cs)))
16:49:25 <Meady> 			
16:49:30 <Meady> works but doesnt paste anythign
16:49:33 <erikc> most windows programming should be done on .net these days, i'd suggest getting the vs2010 beta and using f#
16:49:36 <Cale> The Windows API has probably one of the worst kludginess to popularity ratios ever.
16:50:04 * erikc goes back to doing f# + wpf windows gui fun
16:50:05 <Cale> Meady: what is hwnd here?
16:50:11 <Meady> Window Handle
16:50:19 <Peaker> what is "inclusion polymorphism"?
16:50:19 <Cale> Meady: well, I realise that much ;)
16:50:21 <Meady> hwnd <- getForegroundWindow
16:50:48 * troutwine came down with brain fever after doing windows programming.
16:50:54 <Peaker> is WPF any good?
16:50:57 <gwern> @messages
16:50:57 <lambdabot> Lemmih said 2h 7m 20s ago: No, conjure is not being actively developed.
16:51:15 <gwern> tsk. Lemmih could at least update the page and apply my patches
16:52:03 <Cale> Meady: are you sure this is supposed to work? Are you really allowed to read arbitrary snippets of text out of other processes' windows on XP and Vista? I remember this sort of thing working on Win98, but I'd heard from someone that XP, being derived from NT, had a saner security model.
16:52:35 <idnar> Cale: I think you can do it as long as the process is running as the same user or privilege level or something like that
16:54:13 <Cale> I remember writing a program for windows 98 which just cycled through all the windows/controls/menus etc open on the desktop and set them enabled, so you could push buttons and such you normally couldn't. Apparently that much stopped working on XP.
16:54:29 <Cale> On win98 you could even change password textboxes into normal ones
16:54:37 <erikc> Peaker: i like it, it's sorta like an elisp for windows guis
16:54:49 <Cale> (and see what was filled in there if it was auto-filled)
16:54:51 <Meady> ok guys anyyone make anything with gtk2hs they fancy showing me
16:55:12 <erikc> Peaker: it's totally dynamically typed (and in many cases dynamically scoped)
16:55:16 <Meady> or are none of you fans of gui
16:55:19 <Cale> Meady: you could try installing nymphaea from cabal if you have gtk2hs installed
16:55:24 <Cale> It's just a simple gui
16:55:29 <Cale> But it's pretty enough :)
16:55:46 <dcoutts> I've got a similar lsystem one using Gtk2Hs + OpenGL
16:56:23 <monochrom> I am a fan of gui. Just look at how I use gui irc clients when all the other geeks are like "irsii in uwxyz-terminal".
16:56:25 <Peaker> erikc: yikes
16:56:38 <Peaker> Meady: I'm not a fan of wx/gtk/etc
16:56:45 <Meady> why not
16:56:46 <Cale> http://cale.yi.org/share/Screenshot-Nymphaea.png -- here's an old screenshot of it
16:57:01 <pikhq> monochrom: IRC is rather well suited to a terminal app.
16:57:22 <Meady> Guys gtk2hs isnt downloading on their site
16:57:29 <Meady> know any other mirrors from kent
16:57:39 <ray> pikhq: godwin's law!
16:57:42 <Peaker> pikhq: I like my many colors, alignment of nicks/messages to a line, widgets that show tabs of channels, etc
16:57:44 <Cale> dcoutts should know :)
16:57:45 <Meady> there we go
16:57:49 <Meady> used London mirror instread
16:57:52 <monochrom> Oh, the fun begins when they are like "my uwxyz-terminal doesn't do UTF-8 yet. What is that Greek letter you have just said again?
16:57:52 <Peaker> pikhq: I miss all those in "terminal apps"
16:57:53 <gwern> hm. scala is now faster than haskell on the great programming language shootout
16:57:54 <pikhq> ray: What of it?
16:57:55 <dcoutts> Meady: you mean sourceforge is being crap?
16:57:57 <gwern> when did that happen?
16:58:05 <Meady> Yeah dcoutts
16:58:19 <pikhq> Peaker: I've got many colors, can have alignment of nicks/messages to a line, widgets is a good point...
16:58:29 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
16:58:33 <erikc> Peaker: it has a pretty steep learning curve, but the combination of declarative layout, reactive programming and data binding is a really big improvement imo for gui development
16:58:37 <pikhq> monochrom: urxvt, you mean? Urxvt's primary feature is that it does Unicode. ;)
16:58:44 <dons> gwern: they started attacking it after a talk I gave in front of Martin Odersky two week sago
16:58:57 <monochrom> I don't know. I don't follow all those gazillions of terminal emulators.
16:58:59 <Peaker> erikc: why the dynamism?
16:59:00 <dons> we're still ahead though
16:59:08 <Peaker> pikhq: 16 is not many ;)
16:59:17 <gwern> dons: on the 4-core ubuntu one it looks like we're behind
16:59:23 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
16:59:31 <dons> 4 core ubuntu
16:59:40 <pikhq> Peaker: 32-bit color, actually.
16:59:44 <dons> and on 32 bit also ahead
16:59:51 <Cale> Meady: tried http://sourceforge.net/projects/gtk2hs/files/gtk2hs/gtk2hs-0.10.1-win32-installer.exe ?
17:00:07 <gwern> O was ;pplomg at http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=all&box=1
17:00:12 <gwern> *I was looking at
17:00:15 <dons> gwern: link? we appear to be ahead on all.
17:00:33 <pikhq> monochrom: There's urxvt, Gnome terminal, Kterm, and a bunch of retards without Unicode support.
17:00:34 <dcoutts> dons: btw, did you have any opinion on hiding bytestring's .Internal modules in the haddock docs?
17:00:39 <Cale> gwern: heh, that was an awesome typo
17:00:45 <pikhq> Or, really, anything more advanced than VT-100.
17:00:49 <inimino> gwern: QWERTY user :P
17:00:53 <dons> gwern: same data presented differently
17:00:56 <Cale> ppl omg!
17:01:00 <dons> dcoutts: hmm.
17:01:06 <dcoutts> dons: it should also mean that references to 'ByteString' go to the right re-exporting rather than direct to the .Internal modules where they're really defined
17:01:16 <dons> that's useful
17:01:19 <gwern> Cale: yeah, it's funny that with my fingers misaligned, 'was' still came out correctly
17:01:38 <dons> dcoutts: i'd be vaguely against changing the status quo, unless a good reason was had
17:01:57 <dcoutts> dons: people are accidentally using the .Internal modules, that's the problem
17:01:57 <Cale> gwern: well, clearly it was just your right hand :)
17:02:06 <dons> dcoutts: right, so hiding would be appropriate
17:02:08 <gwern> inimino: well, excuse me if I don't feel like sinking dozens of hours into learning a minority keyboard for minimal benefit which I will be able to use nowhere else!
17:02:17 <copumpkin> omg sourceforge redesign
17:02:20 <copumpkin> do they "get it" now?
17:02:33 <gwern> Cale: oh, you're right. 'I' and 'looking' were both right-hand words. huh
17:02:36 <copumpkin> whoops
17:02:44 <dons> i just wrote: sourceforget  into google by accident
17:02:45 <dcoutts> dons: yeah, it's cheap, it puts off the people who do not know better and doesn't prevent the people who know what they're doing from getting at the internal representations
17:02:45 <monochrom> You can use ncurse and funny letters to draw buttons, menus, lines, tabs... They just look blocky. But I guess you people have amazing 42" monitors and therefore your terminals are like 1024 characters x 768 characters.
17:02:54 <dons> dcoutts: seems good
17:03:00 <dcoutts> dons: ok, will push
17:03:06 <Peaker> pikhq: how do you get 32-bit color in a terminal app?
17:03:16 <Peaker> pikhq: ANSI color codes/vt100/etc have just 16 colors?
17:03:28 <gwern> dons: so is there any plan for warding off scala or are we just going to hope that the next ghc release will buy us some more speed?
17:03:32 <monochrom> All geeky behaviours are due to them having amazing 42" monitors.
17:03:39 <pikhq> Peaker: It's an extension that I don't remember the details of.
17:03:39 <dons> gwern: we could write faster programs :)
17:03:44 <dons> but yes, 6.12 will help.
17:03:46 <ehird> ?djinn (a -> b -> c) -> (a,b) -> c
17:03:46 <lambdabot> f a (b, c) = a b c
17:03:48 <pikhq> monochrom: Including my tiling window manager?
17:03:54 <dons> the jvm's not improving as fast as the rts is
17:03:55 <monochrom> Yes in particular.
17:04:23 <gwern> write faster programs? I was under the impression we had optimized them all pretty much as far as they'd go
17:04:29 * pikhq has a smallish monitor, but has a habit of making everything fullscreen.
17:04:42 <erikc> Peaker: dunno, i assume cause statically typing it would have been fairly intractable, the WPF executional model is an interpreter in itself that heavily relies on reflection
17:04:53 <ehird> Terminal apps are a horrible abomination :P
17:05:01 <dons> no, there's plenty of unexplored territory
17:05:09 <dons> esp. on quad core
17:05:12 <Meady> Right well this pretty much sucks now WinApi isnt so useful in haskell
17:05:39 <ehird> "Hurr, we have a text I/O interface. Ooh. Shiny colouuuurs. Hmmmmmmmm. Ooh, let's add some keyboard shortcuts! Tabs! Lists! Input fields! Squeeeeeee! ...err, isn't this just a GUI library with a bad backend?"
17:05:43 <pikhq> ehird: I'd be happier with non-terminal IRC if there were something akin to screen's "detach" feature for X.
17:05:56 <Cale> Meady: Yeah. I think a good but very large project would be to write a nice Haskell wrapper on top of it.
17:06:00 <ehird> pikhq: Meh, I'm speaking in theory
17:06:07 <ehird> All current UIs suck :)
17:06:08 <Cale> Meady: the Win32 bindings are extremely low-level.
17:06:20 <pikhq> (and happier still if there were a replacement for X0
17:06:27 <ehird> X0!
17:06:31 <Meady> sucks that i have to go back to python
17:06:36 <Cale> Meady: The Haskell community doesn't seem to have all that many windows users, compared to other operating systems
17:06:39 <pikhq> ehird: Absolutely. About the only bit of non-suck is the keyboard.
17:06:41 <ehird> Why do you have to go back to Python, Meady?
17:06:53 <ehird> pikhq: lolwat?
17:06:53 <Meady> Cause i like a well rounded set of libs
17:06:55 <Cale> Meady: Does what you're trying to do work in Python?
17:06:56 <ehird> Oh
17:06:57 <ehird> You mean about UIs
17:07:02 <ehird> Meady: Haskell has those...
17:07:05 <pikhq> ehird: Yes.
17:07:10 <Meady> I mean win32 api
17:07:18 <Meady> its a bit smoother with python
17:07:21 <ehird> pikhq: Dunno, I like my mouse. It's nice.
17:07:22 <pikhq> Meady: You don't want the Win32 API.
17:07:26 <ehird> Meady: Don't use that awful abomination.
17:07:29 * ehird hi5 pikhq
17:07:31 <pikhq> You *don't* want the Win32 API.
17:07:44 * pikhq hi5 ehird
17:07:47 <Meady> I know
17:07:51 <ehird> ~synergy~
17:07:51 <Meady> But linux for me is sucky
17:07:52 <Cale> There's also wxHaskell, which you could try
17:07:53 <Meady> Cause i like media
17:07:57 <ehird> Meady: ...........
17:07:58 <Cale> media?
17:08:01 <Meady> used WxWidgets before, wasnt a fan
17:08:08 <ehird> Meady: Okay, first, Linux has no problem with "media". Secondly, you can use Gtk on Windows.
17:08:08 <Meady> Well dual moitors for staters is a pain for X
17:08:08 <ehird> And Qt.
17:08:11 <ehird> And anything.
17:08:11 <Cale> Yeah, but WxHaskell is different :)
17:08:16 <ehird> erm, xinerama? This is off topic.
17:08:32 <troutwine> Increasingly.
17:08:39 <Cale> It's a binding to the WxWidgets library, but it has a different user interface, basically.
17:08:49 <ehird> But I can tell you that both Haskell and Linux don't have the problems you think :P
17:08:49 <Cale> Er by which I mean the API looks different
17:10:06 <Meady> Dual monitors was a right pain trust me
17:10:09 <pikhq> Isn't there also Qt bindings for Haskell?
17:10:15 <Meady> 945gm drivers are better with windows aswell
17:10:22 <ehird> pikhq: *Aren't
17:10:24 <ehird> And I believe so.
17:10:33 <pikhq> Aren't, yes.
17:10:40 <FunctorSalad> monochrom: konsole does utf-8, but one downside to terminals for stuff like irc is that they don't have proportional fonts
17:10:42 <Meady> Problem with opensource is people arnt motivated and arnt able to dedicate them selves to it because its free
17:11:12 <pikhq> Meady: You're an idiot and a troll.
17:11:20 <Meady> Sigh
17:11:20 <Meady> Ok
17:11:22 * pikhq takes away Meady's open source Python
17:11:24 <Cale> Meady: I'm not sure that's true. There's still plenty of motivation to make good software.
17:11:34 <Meady> Ok name something video editing wise
17:11:37 <aavogt> Meady: intel writes decent linux drivers, btw
17:11:40 <Meady> Photoshop cs3?
17:11:45 <Meady> cs4 now even
17:11:47 <m3ga> there are also a lot of people who do FOSS for a day job
17:11:53 <ehird> 01:11 pikhq: Meady: You're an idiot and a troll.      // be kind
17:11:55 <Meady> Im just saying, linux isnt for me
17:12:02 <Meady> Not trolling atall
17:12:02 <ehird> Had problems with linux != idiot, troll
17:12:08 <Cale> Meady: I've actually been happier with GIMP lately than Photoshop.
17:12:09 <ehird> Meady: I was quoting pikhq
17:12:11 <troutwine> Meady: I don't think anyone suggested that.
17:12:17 <Meady> Yeah sure
17:12:20 <ehird> Cale: you're obviously not a professional graphics designer then :p
17:12:23 <Meady> Well anyone here have dual monitors?
17:12:26 <Meady> Lol Ehird
17:12:30 <pikhq> ehird: "People aren't motivated and aren't able to dedicate themselves to it because its free" sorta is, though.
17:12:33 <ehird> Anyway, this is offtopic.
17:12:37 <Cale> ehird: Well, I don't have much need for print.
17:12:42 * erikc has dual monitors...but only uses them on osx and windows
17:12:44 <ehird> Cale: Nothing about that
17:12:52 <erikc> too many problems in linux :)
17:13:07 <FunctorSalad> I'd look at it this way... if open source has accomplished so much with very little funding, then what if there was public funding? seems like a classic prisoner's dilemma situation to me
17:13:15 <Cale> ehird: As far as pure photo editing goes, I think it's quite a lot nicer in some ways. Of course, Photoshop does things which GIMP can't as well.
17:13:23 <Meady> 100% agreed functorsalad
17:13:51 <Cale> Similarly, Inkscape is in some ways nicer than Illustrator.
17:14:00 <Cale> (not in all ways, but some)
17:14:01 <ehird> Laa laa off topic not the channel for it Haskell Haskell Haskell
17:14:06 <Meady> Okok
17:14:07 <Meady> my bad
17:14:09 <Meady> wasnt trying to troll
17:14:18 <gwern> FunctorSalad: the terminology usually is the 'freerider' problem; it's a little unnatural to call it the prisoner's dilemma
17:14:19 <Meady> anyways gtk2hs, glad compatable?
17:14:28 <gwern> glade?
17:14:29 <Cale> glade you mean?
17:14:32 <dcoutts> Meady: yep
17:14:36 <FunctorSalad> (#haskell-blah)
17:14:41 <gwern> Cale: doesn't nympheae use glade files?
17:14:44 <Cale> yes
17:14:47 <Cale> It does.
17:15:13 <Meady> ahh thats quite nice
17:15:24 <vyom> I am reading the Monad tutorial http://www.haskell.org/all_about_monads/html/laws.html and I cannot understand this piece of code http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2938#a2938 How does x:xs match against type Just [1,2,3]
17:15:51 <Cale> Meady: Yeah, throwing together a simple GUI with glade and using it in Haskell is really simple.
17:16:22 <jackdempsey> x matches to 1, xs to 2,3 ? (newb but thats my guess)
17:16:43 <hzap> vyom: the <- in the do block extracts the value inside the Maybe, which is then pattern matched with (x:xs)
17:17:13 <pikhq> vyom: It's not. x matches to Just [1,2,3], xs matches to [Nothing, Just [], Just [7..20]]
17:17:14 <FunctorSalad> gwern: (please join -blah if we are to take this further) hmm why? it seems to have a prisoners-dilemma like payoff table if defect=release free software, cooperate=release closed software
17:17:21 <Cale> Yeah, whenever you have something like  v <- x  in a do-block, then if x :: m a, then v :: a
17:17:23 <FunctorSalad> err
17:17:24 <pikhq> Oh, wait. Didn't see the do block.
17:17:25 <FunctorSalad> other way around
17:17:26 <pikhq> Never mind.
17:17:54 <Cale> Because the intent is that v <- x means to run the computation x, and name its result v
17:18:20 <vyom> jackdempsey:   (yes, newb) I dont understand how the list is extracted from Just [1,2,3]. I tried to do something like http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2939#a2939 doesnt work for me..
17:18:26 <gwern> FunctorSalad: specifically, funding FLOSS is more akin to the snowdrift dilemma, not prisoner's; in prisoner's, there's 3 levels of payoffs - defecting when they cooperate doesn't merely withhold a reward from them, but damage them
17:18:26 <Cale> So in this case, x = Just [1,2,3] is a computation which succeeds with result [1,2,3], and so (x:xs) is pattern matched with that
17:18:43 <Cale> vyom: did you read what I just said?
17:19:40 <Cale> vyom: It's because v <- x in the do-notation means to run x and name its *result* v. In the Maybe monad, "running" a Maybe t value just means to extract the value of type t, if any (and the whole computation produces Nothing if this fails)
17:19:50 <vyom> Cale: got it!
17:20:28 <vyom> Cale: thanks! Obviously I have a lot to learn
17:20:34 <Cale> No problem :)
17:21:06 <Cale> In the list monad, "running" a list means selecting an element of it, in all possible ways
17:21:11 <FunctorSalad> gwern: (I wasn't taking funding into account yet, just license) your are worse off if you release FLOSS and they release closed, since you don't get the money for selling the software :)
17:21:14 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
17:21:15 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
17:21:23 <FunctorSalad> (worse off compared to both parties releasing closed software)
17:21:27 <Cale> So we get a list of all possible ways of making those selections
17:21:40 <gwern> FunctorSalad: oh, I thought you were considering the case of 2 governments considering funding one particular floss project
17:22:13 <Cale> vyom: In the IO monad, running a computation of type IO t, just means to carry out the effects described by that value, and capture the result.
17:22:27 <Cale> So, for instance,  do x <- getLine; putStrLn x
17:22:31 <Cale> getLine :: IO String
17:22:34 <Cale> and so x :: String
17:22:43 <Cale> and refers to the String which the user typed
17:23:10 <Cale> and then the whole do-block is an IO computation which describes this composition of actions
17:23:21 <aavogt> > [Nothing] >>= (\(Just x) -> x)
17:23:22 <lambdabot>   * Exception: <interactive>:1:148-161: Non-exhaustive patterns in lambda
17:23:23 <Cale> (a single value)
17:23:53 <FunctorSalad> gwern: right, then in that case I'd agree
17:24:04 <aavogt> @undo do Just x <- [Nothing]; return x
17:24:04 <lambdabot> [Nothing] >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
17:24:08 <Cale> do-notation has a special rule for patterns which might fail to match. The current translation is ugly and uses something which really shouldn't be there, called fail
17:24:09 <gwern> FunctorSalad: ok, in the case of 2 projects which exhaust a field (no other competitors), then that does strike me as a prisoner's dilemma then; of course, from society's perspective, proprietary software is monopolistic and thus represents deadweight losses as the monooply will be employed to keep prices higher than the marginal cost
17:24:22 <Cale> (fail is fail ;)
17:24:30 <aavogt> well, it is convenient
17:24:38 <Cale> the old translation was safer and better
17:24:49 <Cale> It used to use mzero
17:25:11 <Cale> However, if we want string error messages in some cases, fail should belong to its own class.
17:25:31 <Gracenotes> undo :X
17:25:48 <Cale> This way, do-block-defined computations which might fail in pattern matching like that, get a different type automatically.
17:26:02 <Cale> and we'd have a convenient way to express that some computation may fail.
17:26:43 <Cale> But currently it's squashed into the Monad class, and many types of monad don't have a reasonable way to implement it, so they respond by just crashing the program
17:26:46 <Cale> which isn't very nice
17:27:30 <shapr> Badger: I'm a pseudo-swede!
17:27:43 <FunctorSalad> gwern: I didn't think that far, don't we just need the fact that copying will be artificially restricted? (to show that the all-cooperate case has higher total utility than the all-defect case)
17:28:32 * Cale takes shapr to cure his congestion. Oh wait, that's not right.
17:28:47 <gwern> FunctorSalad: no, you need stronger assumptions. what about freeware? you can copy it as you want, but in the real world floss > freeware
17:28:51 <shapr> whaat?
17:29:08 <gwern> you need to introduce assumptions about linus's law and transaction costs for fixing bugs & adding features
17:29:14 <Cale> I was pretending to confuse pseudoswede with pseudoephedrine
17:29:28 <FunctorSalad> :o
17:29:52 <shapr> oh right
17:29:52 <gwern> that's one involved joke
17:30:06 <Cale> Freeware is such a silly way to release something
17:30:21 <FunctorSalad> gwern: didn't think about the role of freeware yet
17:30:32 <Cale> Here's my program, you can use it and copy it all you want, but I won't give you the source code!
17:31:04 <gwern> FunctorSalad: I use freeware as a boundary case of proprietary stuff which doesn't limit copying; hoepfully it demonstrates you need to make assertions about the value of *modifying* the program
17:31:05 <dancor> i'm using Data.Binary which apparently uses Data.ByteString.Lazy.Internal.  I think my things should use just Data.ByteString tho.  is there an easy way to convert?
17:31:08 <Cale> What, are you embarrassed?
17:31:23 <Cale> dancor: hmm
17:31:35 <Meady> ffs
17:31:36 <Meady>  i make a form on glade
17:31:36 <Meady>  then click a control and it full screens it
17:31:38 <gwern> dancor: no. there isn't a strict version of data.binary. there are ways around it though
17:31:55 <dancor> gwern: i think they are both lazy
17:32:00 <idnar> Meady: you need to add some sizer boxes or whatever
17:32:08 <Cale> Meady: By default, controls fill the space that you put them in.
17:32:14 <Meady> ok
17:32:32 <Meady> Guess ill just use a 3x3 format
17:32:32 <FunctorSalad> dancor: there's a strict-binary pkg, but last time I looked it hadn't been updated in a while
17:32:38 <Cale> Meady: there are panel controls which express how things should be laid out, and make it possible to keep controls sanely sized when the window resizes
17:32:49 <FunctorSalad> said that it's still undecided whether it should be strict or lazy
17:33:29 <dancor> Cale: this strict/lazy uncertainty sure does remind me of C's which-side-of-the-api-should-manage-allocation issue ;)
17:33:32 <Cale> You can always convert strict bytestrings into lazy ones
17:34:07 <dancor> minus the segfaults
17:34:09 <Cale> and to some extent, vice-versa
17:34:16 <Cale> segfaults?
17:34:22 <gwern> Cale: NOOOO!!! that's so evil bytestring doesn't even provide convenient functions to do so!
17:34:30 <Cale> gwern: whaaaat?
17:35:15 <gwern> Cale: well, I remember once I was complainign how I had to keep redefining an unlazy :: bytestring -> bytestring function, and dons told me that there wasn't one so people wouldn't use it
17:35:26 <gwern> so they could rethink their life and why they wanted it
17:35:40 <dancor> i know why i want my life
17:35:46 <Cale> There's fromChunks and toChunks though
17:35:56 <Cale> in Data.ByteString.Lazy
17:36:07 <ehird> rethink their life XD
17:36:08 <Cale> it converts between the two types
17:36:27 <Cale> er, s/it converts/they convert/
17:36:33 <Zrs> Why don't I see more use of types in the standard Haskell libs? Is there some downside to defining, say, foldr as foldr :: (a -> Acc b -> b) -> Acc b -> [a] -> b where type Acc t = t? It seems like it would make it SO much more readable.
17:36:56 <Cale> Zrs: eh? Seems just to confuse things to me...
17:37:12 <Cale> Zrs: why aren't the other b's Acc'd?
17:37:16 <FunctorSalad> a type synonym? why not just call the var "acc" then?
17:37:30 <Cale> also, it doesn't agree with the way I think about foldr
17:37:31 <gwern> Cale: but they don't quite
17:37:32 <Zrs> Acc stands for accumulator.
17:37:48 <Cale> but foldr doesn't really accumulate as such
17:38:02 <idnar> accumulator goes with foldl, in my mind
17:38:08 <Cale> It just replaces all the conses with the function you provide, and replaces [] with the value you provide
17:38:09 <dancor> maybe the last b should be Acc b tho
17:38:26 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
17:38:38 <dancor> it's at least as accumulative as the Acc b that went into it ;)
17:38:50 <Zrs> Well, okay, ya'll have a point. But I guess my question is, types seem like a handy way to give variables in functions actual names.
17:38:57 <dancor> right
17:39:05 <dancor> and to give them different names
17:39:06 <Cale> Zrs: just giving them names is another way
17:39:27 <Cale> Zrs: foldr :: (val -> acc -> acc) -> acc -> [val] -> acc
17:39:29 <dancor> even if they must have the same type
17:40:00 <Cale> Zrs: we just usually opt for single letter names for whatever reason -- probably because the scope is so tiny.
17:40:20 <Cale> Generally we use names whose length increases with the size of the scope.
17:40:30 <Cale> (and perhaps the complexity of meaning)
17:40:37 <Zrs> The second and third arguments of the function passed to foldr have the same type, but totally different purpose though. And the declaration doesn't seem to state it.
17:40:45 <Cale> eh?
17:41:01 <Cale> the function passed to foldr only has two arguments
17:41:06 <dancor> Zrs: idk about this example, i'm sure there's a better one
17:41:08 <Cale> (a -> b -> b)
17:41:14 <Zrs> Argle, my bad.
17:41:38 <Zrs> Yeah, I guess when you look at it that way the two bs are very different even without names.
17:41:45 <Cale> yeah
17:41:50 <Cale> the second b is the result type
17:42:32 * dancor adds type annotation to his repertoire of haskell style that most ppl don't use
17:42:35 <Cale> http://cale.yi.org/index.php/Fold_Diagrams explains what I see in my head when using foldr and foldl
17:42:44 <gwern> @hoogle log
17:42:45 <lambdabot> Prelude log :: Floating a => a -> a
17:42:45 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
17:42:45 <lambdabot> package logfloat
17:43:05 <dancor> (zelda acquire item music)
17:43:10 <Zrs> Cale: thanks for that link :)
17:43:13 <Cale> They're a certain kind of structural replacement on lists
17:43:40 <Cale> You can create analogous structural replacement functions for other types, especially trees
17:43:54 <Cale> say,  data Tree a = Leaf | Branch a (Tree a) (Tree a)
17:43:56 <Cale> then
17:44:17 <Cale> treeFold l b = f where f Leaf = l; f (Branch x l r) = b x (f l) (f r)
17:44:43 <Cale> It gives a function for replacing each Leaf in the tree with l, and each Branch with b
17:44:47 <gwern> > 10e10
17:44:47 <lambdabot>   1.0e11
17:44:53 <gwern> > show 10e10
17:44:54 <lambdabot>   "1.0e11"
17:45:02 <Cale> and then you can use that to write all sorts of useful tree functions, like
17:45:20 <Cale> treeSum = treeFold 0 (\x l r -> x + l + r)
17:45:37 <Cale> treeFlip = treeFold Leaf (\x l r -> Branch x r l)
17:45:52 <Cale> treeDepth = treeFold 0 (\x l r -> 1 + max l r)
17:46:08 <Cale> and so on and so forth :)
17:46:35 <idnar> Cale: what would foldl look like for a tree?
17:46:50 <Cale> well, you'd have to decide how to interpret that, I suppose.
17:47:09 <Cale> hmm...
17:47:44 <Cale> It's hard because there will be many leaves near the bottom of the tree which we'd want to be near the top of the resulting expression, for a good analogy
17:48:00 <idnar> Cale: the reason I ask is that it always seemed to me like foldl is an oddball thing that's not really a generic concept
17:48:05 <Cale> yeah
17:48:11 <Cale> It's not as natural as foldr at all
17:48:15 <idnar> I've never been able to figure out what foldl would look like for not-a-ilst
17:48:30 <idnar> whereas "replace constructors" generalises trivially
17:48:34 <Cale> yeah
17:48:41 <idnar> in fact, isn't that what Church encoding is or whatever it's called?
17:48:44 <Cale> foldr is the real catamorphism :)
17:49:01 <Cale> Maybe r and l stand for 'real' and 'lame'
17:49:26 <Cale> Yeah, the Church encoding just encodes lists as functions of the constructor
17:49:28 <Cale> s
17:50:13 <Cale> So instead of  Cons 1 (Cons 2 (Cons 3 Nil))  you have  \nil cons -> cons 1 (cons 2 (cons 3 nil))
17:50:37 <Cale> and that's exactly what foldr does for you, more or less
17:51:01 <Cale> If we rearranged the parameters to foldr, that would be more apparent :)
17:51:57 <Cale> any value of any algebraic datatype can be Church encoded as a function by simply taking the constructors as parameters
17:53:23 <Cale> and so every algebraic datatype also has a natural catamorphism which just hands you that encoding
17:53:41 <Cale> I think we ought to have a case-like syntax for it in Haskell
17:53:50 <gwern> it's funny but the first time I saw 'catamorphism' I wondered what kind of catamite that was
17:55:11 <Cale> so that if I had that tree type above, I could write something like  sumTree = cata Leaf -> 0; Branch x l r -> x + l + r
17:58:11 <Cale> (and not have to explicitly define a fold for the type)
17:58:20 <Cale> and then we could write list folds like:
17:58:34 <Cale> sum = cata [] -> 0; (x:xs) -> x + xs
17:59:27 <FunctorSalad> catamorphism sounds so collapsitarian
17:59:34 <Cale> hehe
17:59:39 <idnar> kittymorphism
17:59:42 <Cale> well, I don't care what you call it
18:00:04 <idnar> Cale: that syntax seems pretty cool
18:00:07 <FunctorSalad> I think it means "downward shaping" or something similar?
18:00:27 <Cale> The cata is the same one as in catastrophe
18:00:38 <FunctorSalad> (from Greek: ÎºÎ±Ï„Î± = downwards or according to; morphism = form or shape)
18:00:43 <Cale> yeah
18:00:43 <monochrom> catamorphism is catastrophic.
18:00:45 <FunctorSalad> didn't think WP would have this
18:00:51 <aavogt> strophe -- verse?
18:01:04 <Cale> Maybe we could just use greek Îº to refer to it ;)
18:01:14 <FunctorSalad> now anamorphisms, those are great.
18:01:26 <Cale> But most people don't have that on their keyboards, so what's a good ascii equivalent...
18:01:31 <idnar> catastrophism is catamorphic
18:01:32 <Cale> |<
18:01:36 <monochrom> ana and the Îº
18:01:48 <idnar> Ä¸
18:01:52 <idnar> oh sweet, I can compose that
18:02:05 <araujo> hello
18:02:09 <Cale> hello
18:02:21 <Cale> idnar: compose?
18:02:27 <Cale> Oh, compose k k
18:02:40 <Cale> why should that even work, I wonder...
18:02:47 <Cale> compose l l doesn't give me lambda
18:03:33 <idnar> compose e e is É™
18:03:44 <Cale> Out of all the Greek letters, it seems that kappa is the only one I can get that way.
18:03:44 <ehird> > const . const
18:03:45 <idnar> rather... odd
18:03:45 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> b1 -> a)
18:03:45 <lambdabot>    arising from...
18:03:46 <Cale> Odd.
18:03:49 <ehird> :t const . const
18:03:50 <lambdabot> forall b a b1. a -> b -> b1 -> a
18:03:55 <ehird> Compose K K, you said?
18:03:57 <idnar> x x is Ã—
18:03:58 <ehird> ;-)
18:04:16 <Cale> ehird: hehe
18:04:17 <FunctorSalad> I don't think I have a compose key :-(
18:04:25 <Cale> I rebound Caps Lock to compose
18:04:28 <copumpkin> don't compose K K K
18:04:33 <Cale> Caps Lock is so stupid by comparison
18:04:37 <idnar> I use right-alt as compose
18:04:40 <ehird> > let k = const in k.k.k
18:04:41 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> b1 -> b2 -> a)
18:04:41 <lambdabot>    arisin...
18:04:42 <idnar> I have Caps Lock mapped to mod4
18:04:44 <ehird> :t let k = const in k.k.k
18:04:45 <lambdabot> forall b b1 a b2. a -> b -> b1 -> b2 -> a
18:04:46 <ehird> RACISTSKELL.
18:04:49 <idnar> er, to mod3 even
18:04:55 <ehird> It ignores all non-first-argument (whites)
18:04:56 <idnar> which doesn't have anything mapped to it by default
18:04:57 <ehird> *arguments
18:05:03 <idnar> I use mod3 for a lot of my ion3 keybindings
18:05:05 <ehird> (Note: analogy is tenuous)
18:05:20 <Twey> Cale: 02:05:03 <lingbot> U+0138 LATIN SMALL LETTER KRA (Ä¸)
18:05:26 <Cale> Twey: oh!
18:05:35 <Cale> What the heck is that then?
18:05:44 <Twey> http://en.wikipedia.org/wiki/Kra_(letter)
18:05:56 <idnar> oh, whoa
18:06:26 <idnar> ÎºÄ¸
18:06:30 <idnar> they're the same darn glyph in my font, anyhow
18:06:33 <Cale> yeah
18:06:35 <Cale> here too
18:06:42 <gwern> ditto
18:06:48 <idnar> "It is visually similar to a Latin small capital letter K and the Greek letter kappa Îº."
18:06:49 <Twey> I think they're slightly different for me
18:06:58 * ehird zooms in
18:07:02 <idnar> I guess "identical" counts as "visually similar"
18:07:02 <Twey> The angle on the latter seems a pixel or two higher up
18:07:15 <ehird> Lucida Grande decrees them similar but not identical.
18:07:31 <Twey> But that could be preconceptions at work :)
18:07:37 <idnar> The letter can be capitalized as ÎšÊ», but it is not encoded separately as a single letter because it is very similar to the Latin capital letter K followed by the six-shaped apostrophe (turned high comma Ê»).
18:07:38 <ehird> Indeed, I have proof:
18:07:41 <Cale> One of them is Photoshopped, I can tell from the pixels.
18:07:42 <ehird> http://imgur.com/7tiea.png
18:07:44 <ehird> They clearly differ.
18:07:53 <idnar> that's... really daft
18:07:57 <Twey> *nod*
18:08:06 <ehird> that nonencoding is stupid
18:08:07 <idnar> the lowercase letter looks really similar to kappa, but they included a separate codepoint for that
18:08:41 <FunctorSalad> the left one is missing a pixel on the top left of the top right
18:09:15 <Twey> FunctorSalad: That'd be an attempt at displaying a curve
18:09:26 <ehird> Yeah, it's very subtle
18:09:34 <FunctorSalad> woha you can zoom in indefinitely with KDE4
18:09:42 <ehird> But you can clearly see that the former is flaccid.
18:09:47 <Cale> Heh, here the only way I could tell the difference is if I was capable of seeing tiny tiny differences in colour under subpixel antialiasing.
18:09:49 <ehird> I can make a mega-zoom, I guess.
18:09:49 <FunctorSalad> it's a bit hard to see with subpixel rendering
18:10:04 <ehird> I'll make a gigantic one so subpixels are irrelevant.
18:10:17 <idnar> ã„…
18:10:32 <idnar> I don't have any antialiasing here
18:10:52 <ehird> 1 out of 1 Helveticas agree: the curve is there. http://imgur.com/tOgjd.png
18:10:57 <ehird> Helveticae.
18:11:14 <FunctorSalad> I think image magick lets you do image diffs somehow
18:11:26 <Cale> http://cale.yi.org/share/k.png
18:11:56 <Cale> oh, that's a good idea
18:12:28 <ehird> Cale: Now THAT'S low-res.
18:12:35 <ehird> What dpi is your screen, 72? ;-)
18:12:41 <idnar> haha
18:13:06 <FunctorSalad> 72 isn't absurdly little these days, is it?
18:13:15 <ehird> Uhh, yes it is
18:13:19 <ehird> Most computer monitors are 96dpi
18:13:34 <ehird> Some are 100dpi, some are 94dpi. Rare outliers from a begone age are ~84dpi-87dpi.
18:13:40 <ehird> 72dpi is 80s technology
18:13:41 <jmcarthur> uh, 96 dpi is absurd too
18:13:48 <jmcarthur> 96 is just the default setting on most OSes
18:13:56 <ehird> jmcarthur: 96dpi is the most common monitor res
18:13:59 <idnar> my current monitor is 87x83 dpi
18:14:04 <jmcarthur> wow
18:14:13 <jmcarthur> and here i thought the OS defaults we just outdated
18:14:15 <idnar> 22" 1680x1050
18:14:22 <FunctorSalad> my lappy has 113 I think
18:14:28 <jmcarthur> my current one is 129, and my work one is 149
18:14:39 <ehird> 24" 1920x1200 ~= 94dpi. 22" 1680x1050 ~= 90dpi
18:14:45 <FunctorSalad> 149? where do you get such a thing?
18:14:56 <idnar> jmcarthur: wow, that sounds nice (unless they're just tiny)
18:15:03 <jmcarthur> FunctorSalad: it's pretty small... 15.4" laptop with 1920x1200
18:15:10 <ehird> jmcarthur: Laptops have way higher dpi
18:15:13 <ehird> I'm talkin' bout desktops.
18:15:16 <Cale> http://cale.yi.org/share/k-diff.png
18:15:21 <jmcarthur> my 129 dpi one is also 15.4" though
18:15:21 <idnar> jmcarthur: nice
18:15:24 <FunctorSalad> (btw I meant absurd in the sense like one tenth ;))
18:15:28 <jmcarthur> just lower res, obviously
18:15:29 <idnar> jmcarthur: my laptop is only 1440x900
18:15:42 <ehird> 1920x1200 laptops aren't too common.
18:15:46 <ehird> Tend to be designer-oriented ones.
18:15:47 <jmcarthur> this one is 1680x1050
18:15:50 <ehird> Photographers too, etc.
18:15:56 <ehird> But anyway, laptops are high-dpi.
18:16:07 <jmcarthur> yeah, they tend to be
18:16:28 <Cale> http://cale.yi.org/share/k-diff-massive-gamma.png
18:16:31 <FunctorSalad> they should make higher-dpi panels too... you really notice the difference in the fonts
18:16:34 <ehird> The problem with super-high-res displays is all the pixel rubbish and images on the interwebs.
18:16:35 <jmcarthur> i haven't used a desktop as my primary computer in a while. i guess that is why i was confused
18:16:38 <ehird> FunctorSalad: Hell yeah.
18:16:45 <ehird> High enough dpi = no hinting required.
18:16:49 <ehird> BTW, you can buy displays of like 200dpi
18:17:07 <jmcarthur> i use a 22" secondary display at work too though, and it still has > 100 dpi, i think... perhaps i am very wrong
18:17:11 <ehird> Response time suffers, colours suffer and be prepared to have a nice graphics card set up.
18:17:11 <idnar> I rely quite a lot on decent hinting, since I don't use antialiasing
18:17:28 <jmcarthur> ehird: doesn't the iphone have something around 300 dpi or something crazy like that?
18:17:32 <ehird> jmcarthur: 160
18:17:35 <Cale> ehird: No hinting, or no antialiasing?
18:17:42 <jmcarthur> ah
18:17:46 <ehird> Cale: No hinting. we can stop antialiasing at like 600dpi.
18:17:47 <jmcarthur> nowehere near what i thought
18:17:50 <idnar> (that makes most fonts unusable, but that's better than all fonts being unusable :P)
18:17:51 <jmcarthur> i don't have one :P
18:18:10 <Cale> You would still want something that's something a bit akin to hinting, though that's not really an appropriate term.
18:18:14 <ehird> jmcarthur: I have one (ye olde 2007 one). Since you hold it near, you can see the individual pixels if you have good eyes and are using it up close.
18:18:23 <ehird> So it's not like some bastion of smoothness at the distance you use it at.
18:18:25 <ehird> Cale: nope
18:18:34 <Cale> Typefaces should vary in shape as their size changes.
18:18:36 <ehird> Cale: hinting is just distorting the font's shapes to fit in less pixels.
18:18:42 <Cale> right
18:18:43 <ehird> with high enough dpi, even tiny text is a lot of pixels
18:18:47 <jmcarthur> ehird: yeah, i figure, at that res. i just thought it was higher
18:18:48 <ehird> so we can have thin, crisp text
18:18:50 <ehird> without any morphing
18:19:06 <Cale> In fact, none of the font systems I know of, except for TeX's MetaFont actually does what I'm talking about.
18:19:16 <ehird> i get what you mean
18:19:21 <ehird> shall we move this to -blah?
18:19:36 <Cale> I'm done :)
18:19:48 <ehird> :-P
18:20:09 <mle> or implement metafont+tex in haskell...
18:20:18 <mle> ugh that'd be a mess.
18:20:24 <ehird> TeX is a mess.
18:20:30 <Cale> mle: actually, there is something a bit like that
18:20:42 <Cale> except that it was not TeX
18:24:12 <Cale> Oh, hmm, it seems lout was not written in Haskell, it's just the language is similar to Haskell in some ways.
18:24:36 <ehird> Lout is python :P
18:24:47 <Cale> Eh? Really?
18:25:02 <Cale> Wikipedia says that it's written in C.
18:25:31 <ehird> eh?
18:25:39 <ksf> tex isn't that bad, it's latex that's messy.
18:25:43 <ehird> Maybe Iâ€”
18:25:44 <ehird> I think Iâ€”
18:25:49 <ehird> Yes, maybe I was not thinking of lout.
18:25:56 <ksf> well, for a macro language, anyway.
18:26:03 <ehird> ksf: You are sentenced to ONE (1) reading of "THE TEX SOURCE CODE".
18:26:22 <ksf> I took an owe never to lay hands on pascal, ever again.
18:26:37 <ksf> s/owe/oath
18:26:40 <ehird> Wait â€” Maybe I'm wrong â€” Perhaps I was thinking of lout. Now why am I obsessed with these dashes.
18:26:41 <ksf> damn spelling.
18:26:53 <ehird> Yes. Yes I was.
18:27:22 <Cale> "Lout is written in strict ANSI C and should compile out-of-box on any Unix system with an ANSI C compiler. All that is required is to customize the Makefile to your machine, then run make lout, make prg2lout and then make install."
18:27:25 <ksf> something like tex would be cool for other things, too... proper html + gui rendering, just to name two.
18:27:43 <pikhq> "Customize the Makefile".
18:28:10 <pikhq> Would you happen to know where the author of Lout lives, and what the local laws on lethal weaponry are?
18:28:17 <ehird> pikhq: Not the place.
18:28:24 <ehird> You can murder me and him later, okay?
18:28:32 <pikhq> ehird: You're next.
18:28:37 <ehird> *Dammit*
18:28:51 <monochrom> I want Haskell.
18:29:10 <ehird> Haskell typesetting?
18:29:10 <pikhq> > [..10]
18:29:11 <lambdabot>   <no location info>: parse error on input `..'
18:29:15 <ehird> I'm not sure the syntax allows.
18:29:25 <Cale> Weird. The source code is split up into z01.c through to z52.c
18:29:32 <Cale> Way to name your source files.
18:29:33 <ksf> hbox, hfill, glyphs... shouldn't be too bad.
18:29:41 <inimino> pfft, editing a Makefile in nothing compared to the hassles of auto-*
18:29:49 <ksf> ...except reading the tex source to clone the layout algorithms, of course.
18:30:16 <pikhq> inimino: Says someone who has never had to do any non-trivial builds.
18:30:22 <ehird> Cale: It's obviously old.
18:30:29 <ksf> i've seen some decent html syntax... if in doubt, you can use a preprocessor, and if you don't want to, there's TH.
18:30:31 <ehird> inimino: You can safely ignore pikhq on this matter, he's an autohell fanboy.
18:30:44 <ehird> :p
18:30:47 <pikhq> ehird: No, I'm a hater of Make.
18:30:51 <monochrom> I thought TeX was not written in C.
18:30:52 <idnar> Cale: ouch :P
18:31:00 <inimino> pikhq: I beg to differ, having had plenty of experience with both
18:31:00 <ksf> monochrom, pascal.
18:31:01 <monochrom> Oh, Lout, nevermind.
18:31:02 <inimino> ehird: noted :)
18:31:10 <ehird> monochrom: Ye olde Pascal, translated to C for actual compiling purposes.
18:31:12 <pikhq> Autohell is slightly better than straight Make, in that it at least tries to do the right thing.
18:31:14 <ksf> iirc c wasn't invented back then.
18:31:23 <ehird> *compilation
18:31:39 <idnar> pikhq: it's a lot worse, in that it fails :P
18:31:51 <inimino> idnar: well put :)
18:31:58 <wli> It was, but it was not anywhere near as fashionable.
18:32:09 <pikhq> idnar: Whereas Make does the wrong thing consistently.
18:32:22 * pikhq sentences idnar and inimino to building IRAF.
18:32:31 <wli> Wrong thing like what?
18:32:31 <Cale> http://pastebin.com/m4f6b28f4 -- lovely code ;)
18:32:43 * ksf settled for omake, a custom dep resolver, and some coding standards (to allow dep chasing)
18:32:45 <ehird> pikhq: blaming the problem on the tool, not the use, since YYYY
18:33:10 <Cale> oh, wait, I've found something much better
18:33:17 <ehird> araujo: pretty
18:33:19 <ksf> ...if something doesn't provide a pkg-config interface these days, it's not worth using, anyway.
18:33:20 <ehird> er.
18:33:21 <ehird> Cale:
18:33:39 <Cale> http://pastebin.com/m7d0257d1 :)
18:33:41 <inimino> IRAF always seemed more than a little nuts to me, isn't that the one that's written in some crazy DSL?
18:34:10 <idnar>  /me rewrites IRAF in M4
18:34:13 * idnar rewrites IRAF in M4
18:34:16 <ehird> Cale: looks readable enough. it's a sequential process
18:34:19 <pikhq> IRAF is hell. You'll swear off all build systems for a bit after that.
18:34:27 <ehird> idnar: you forgot to run m4 on your irc line!
18:34:29 <pikhq> idnar: M4 is one of the languages it's written in.
18:34:37 <Cale> ehird: Well, when you think about what the equivalent Haskell code would look like...
18:34:38 <idnar> pikhq: excellent
18:34:42 <pikhq> And straight Make is *one of* the build systems it uses.
18:34:45 <idnar> pikhq: I'm already half done, then :P
18:34:51 <ehird> Cale: Much the same, just split into extra names.
18:35:03 <pikhq> (it also has Autohell and a Perl script and Cmake)
18:35:16 <pikhq> And it's written in M4, C, Fortran, and a DSL.
18:35:18 <Cale> ehird: oh, come on.
18:35:32 <Cale> ehird: It would be an algebraic datatype.
18:35:36 <ehird> /shrug
18:35:46 <pikhq> K&R C, to be specific.
18:35:49 <ehird> The basic process is ugly, you can't abstract that away.
18:36:11 <Cale> We seem to have done it well in Haskell.
18:36:25 <ehird> /shrug
18:36:28 <ehird> i only skimmed the code
18:37:43 <gwern> Cale: not if you listen to meachem and roundy
18:38:01 <gwern> according to them, we're living in a fantasy universe where in the end nothing will work right
18:38:08 <Cale> Huh?
18:38:30 <gwern> they think cabal is an evil dead-end
18:38:38 * Cale wonders what gwern is referring to...
18:38:42 <ehird> are we talking roundy the darcs guy?
18:38:49 <gwern> yes
18:38:58 <ehird> who's meachem? what are you talking about? sources? etc
18:39:01 <gwern> also creator of franchise, or, 'autotools in haskell'
18:39:08 <gwern> ehird: john meachem, jhc etc
18:39:09 <Cale> Isn't it just that he likes another system better?
18:39:12 <ehird> oh, right.
18:39:20 <ehird> gwern: uhh, talk about hyperbole
18:39:24 <ehird> gwern: you should work for fox news!
18:39:26 <Cale> But I'm not even talking about cabal...
18:39:41 <gwern> ehird: hyperbole? it's not too far off what he's said on the jhc ml
18:40:10 <Cale> Are you telling me the author of JHC doesn't believe in algebraic datatypes and parser combinators?
18:40:35 <gwern> weren't we discussing build systems?
18:40:38 <ehird> Cale: Absolutely not. he uses homeopathic coding.
18:40:52 <ehird> gwern: we, yes. cale, no.
18:40:53 <Twey> Hahahaha
18:41:08 <gwern> lies! I say Cale is cabbage, and I say to hell with it!
18:41:12 <Cale> gwern: oh, I was talking about code examples
18:41:19 <ehird> Homeopathic virus removal: Replace the instructions in the virus gradually with nops.
18:41:21 <Cale> stolen from lout's C code
18:41:26 <ehird> (The more you do this, the more effective it is.)
18:41:28 <ehird> Then, run the program.
18:41:39 <ehird> Tada! Your virus is gone. If it doesn't work, do it some more until your computer dies.
18:42:33 * pikhq rewires ehird's CPU; nop now = HCF.
18:42:50 <ksf> dd if=/dev/urandom of=/dev/kmem
18:42:59 <ehird> pikhq: It would have died anyway. Conventional virus removal is unnatural and toxic and would have only prolonged its pain.
18:43:12 <ehird> You shouldn't mess with the natural order of execution./
18:43:38 <ksf> (unplug your disks first, don't count on them being mounted ro...)
18:44:18 <pikhq> ksf: You could probably use your computer's execution as a RNG.
18:44:25 <ksf> if in doubt, remove your bios chip after booting, too.
18:44:49 <ehird> I want a new unix command to rival true and false: maybe. It returns either 0 or 1. I dunno lol
18:45:51 <ehird> @hoogle random
18:45:51 <lambdabot> package random
18:45:51 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
18:45:51 <lambdabot> module System.Random
18:45:56 <ksf> man 6 random
18:45:56 <ehird> meh
18:46:05 <ehird> ksf: shaddup
18:47:04 <ksf> hmmm... you're going to need an infinite sequence of "101010", too.
18:47:20 <ksf> is there a unix equivalent to "cycle"?
18:47:28 <ehird> yes(1)
18:47:33 <ehird> ksf: But nononononono, it should be random.
18:48:09 <ehird> ksf: yes "0
18:48:10 <ehird> 1"
18:48:14 <ehird> will do it
18:49:08 <ksf> uhmmmm...
18:49:24 <ksf> how do I get zsh to put a \n into the command line?
18:49:53 <ehird> By pressing your enter key in the middle of a string like I did.
18:50:05 * wli doesn't do any of the zsh prompt stupidity and instead uses typeset -x PS1='$ '
18:50:31 <ehird> wli: Thanks, that's totally irrelevant.
18:50:48 <ehird> [ehird:~] % typeset -x PS1='$ '
18:50:48 <ehird> $ yes "0
18:50:49 <ksf> oh, precommand and postcommand are cool.
18:50:49 <ehird> dquote> 1"
18:51:03 <wli> I guess there is the slight relevance that I use zsh, but anyhow.
18:51:08 <ksf> I want to see something different than "Shell" in my tabs...
18:51:30 <ksf> granted, with xmonad, it isn't displayed often, anyway.
18:52:04 <ksf> ehird, indeed
18:52:22 <pikhq> RPROMPT = hug.
18:52:31 <ksf> unix shells need anonymous files.
18:52:39 <ehird> ksf: they have 'em
18:52:42 <ehird> butt <(morebutt)
18:52:51 <pikhq> Called 'file descriptors'.
18:52:51 <ehird> â†’ butt /dev/stuff
18:52:51 <ehird> also fifos
18:52:53 <ksf> so you can for (;;) cat a "10"
18:52:56 <ehird> exec <> and the like
18:53:29 <pikhq> (for (;;) echo "10")|foo ?
18:53:39 <ksf> uh, yes.
18:53:49 <ksf> echo -n, though.
18:54:03 <pikhq> Perfectly legal bash and zsh.
18:54:17 <ehird> % (for (;;) echo "10")|foo
18:54:17 <ehird> zsh: parse error near `('
18:54:19 <ehird> No it's not :-P
18:54:33 <pikhq> ehird: Oh, right. For isn't. :P
18:55:15 <pikhq> (while true;do echo -n 10;done)|foo
18:55:26 <ksf> % (while true
18:55:26 <ksf> do
18:55:26 <ksf> echo "1
18:55:26 <ksf> 0"
18:55:26 <ksf> done
18:55:28 <ksf> ) |random
18:55:35 <ehird> echo <(cat)    # free filename, no questions asked!
18:55:54 <ehird> Heh.
18:56:04 <ehird> Who knew that "cat file" could prompt you for input where the file isn't your stdin or tty?
18:56:08 <pikhq> ehird: That's a zsh-ism.
18:56:14 <ehird> in /dev/fd, "cat 2" copies all my input :-)
18:56:17 <ehird> pikhq: and bashism.
18:56:27 <ehird> echo <(cat)
18:56:27 <ehird> /dev/fd/63
18:56:28 <ehird> â€”bash
18:56:34 <pikhq> Oh, bash also has it? Good.
18:56:53 * pikhq is getting /proc/self/fd/ for that. ;p
18:56:55 <copumpkin> hmm, I thought I was in #haskell
18:57:09 <idnar> ehird: /dev/fd/2 /is/ your tty, surely?
18:57:13 <ksf> you're in #cohaskell
18:57:14 <pikhq> copumpkin: Ãžou art.
18:57:20 <copumpkin> lol
18:57:38 <ehird> idnar: Oh. Duh.
18:57:38 <ehird> XD
18:57:46 <ehird> But it could also be a <(cat) FD.
18:58:08 <pikhq> cat <(cat) FTW.
18:59:29 <FunctorSalad> what do the parens do?
18:59:51 <ehird> FunctorSalad: It's a totally different thing.
19:00:07 <ehird> It makes a process and directs it to a new file descriptor, then passes a filename representation in place of its invocation.
19:00:17 <ehird> So you can do "cat <(foop) <(doop)".
19:00:24 <ehird> And it gives you the output from foop and doop concatenated.
19:00:46 <ehird> eg try "cat <(man cat) <(man ls)"
19:00:52 <FunctorSalad> wow that works :)
19:00:59 <FunctorSalad> never seen it.
19:01:59 <aavogt> @check \cat -> cat < (cat)
19:02:00 <lambdabot>   "Falsifiable, after 0 tests:\n()\n"
19:02:17 <ehird> Don't prove it can't work. It's upsetting.
19:02:37 <aavogt> heh, different languages
19:02:43 <ehird> :(
19:02:47 <gwern> beware, he only proved it can't work, he hasn't actually tried it
19:03:04 <gwern> or as I like to say, 'the problem with wikipedia is that it works in practice and not in theory'
19:04:13 <ehird> http://www.e-pig.org/epilogue/ â† Mm, I could do with some of this in ghc
19:04:15 <tommd> In theory, practice and theory are the same.  In practice they aren't.
19:04:29 <ehird> IN THEORY OVERUSED CLICHÃ‰ QUOTES THAT AREN'T FUNNY ANY MORE WILL STAY FUNNY FOREVER
19:04:35 <ehird> In practice they don't. :p
19:04:44 <idnar> gwern: the problem with wikipedia is that it doesn't work anymore :P
19:04:50 <idnar> err
19:04:52 <idnar> *doesn't work at all
19:05:09 <gwern> ehird: hold on, my knuth quote and my wikipedia quote are neither of them overused or cliche
19:05:22 <ehird> 03:02 gwern: beware, he only proved it can't work, he hasn't actually tried it 03:04 tommd: In theory, practice and theory are the same.  In practice they aren't.
19:05:25 <ehird> Both those are, the latter moreso.
19:05:27 <tommd> ehird: I never saw that outside of a course I took 7 years ago.  Your caps speak unspecific volumes about how wide spread it is though.
19:05:33 <gwern> idnar: indeed, it so doesn't work that most of the internets use it
19:05:36 <FunctorSalad> I'm confused. who said anything about something not working?
19:05:42 <ehird> tommd: I see it all the time in pretentious programmer circles ;-)
19:05:53 <aavogt> FunctorSalad: my @check
19:05:59 <gwern> I only see it in haskell circles though
19:06:07 <tommd> Humm, I guess EEs use quotes less.
19:07:27 <bremner> yeah, that is my experience with marking their assignments; they tend to just copy :-)
19:08:01 <Cale> In theory, theory and practice are different. In practice, they are differently different.
19:09:07 <idnar> the whole "in theory / in practice" thing always annoyed me
19:09:22 <ksf> SUP DAWG I PUT THEORY IN YOUR PRACTICE SO YOU CAN PRACTICE WHILE YOU THEORISE
19:09:22 <FunctorSalad> yeah, reality sucks
19:09:22 <idnar> because it's more like "in my messed up fantasy world" than "in theory"
19:09:26 <FunctorSalad> ;)
19:09:50 <gwern> @quote dawg
19:09:50 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
19:10:14 <gwern> @quote news
19:10:14 <lambdabot> newsham says: Newsham's Law: the more powerful the abstraction, the more unclear it is until you understand it :)
19:10:27 <gwern> @quote good.news
19:10:28 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
19:10:45 * gwern wonders where the heck that one is from!
19:10:48 <gwern> @quote good.news
19:10:48 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
19:11:43 <FunctorSalad> is this "sup dawg I herd you like x so we put y in your z so <some reflexive construction>" thing supposed to be a derivative of the xkcd coming where he accidentally in her base and stuff?
19:12:00 <ksf> nope, that's already a ref.
19:12:09 <FunctorSalad> (if so I'd critizise that it's lacking babbies)
19:12:10 <ksf> the original is based on pimp your ride.
19:12:15 <FunctorSalad> oh
19:12:15 <gwern> @quote futamura
19:12:15 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
19:12:33 <ksf> sup dawg i herd you like cooking so i put a kitchen in your car so you can cook while you drive.
19:12:39 <gwern> (now why did that one refuse to show up?)
19:12:46 <gwern> @quote sandtrout
19:12:46 <lambdabot> Cale says: I plan on forming a symbiotic relationship with sandtrout, which, as they merge with my body, will sustain me as I slowly turn into a sandworm, and make use of my billions of other
19:12:46 <lambdabot> memories and prescience to rule over everyone and everything for millenia.
19:12:47 <FunctorSalad> thanks ksf :)
19:12:58 <ksf> ...out of which some 4channer made sup dawg i herd you like driving so i put a car in your car so you can drive while you drive
19:12:59 <gwern> we better kill Cale before it's too late!
19:13:32 <idnar> -!- Cale is now known as Leto
19:15:52 <aavogt> gwern: is that SPJ quote from 'A taste of haskell' possibly?
19:15:54 <ksf> do I have to be concerned about the fact that #haskell degenerated into -blah mere hours after I reappeared after nearly a month of downtime?
19:16:15 <gwern> aavogt: it doesn't seem familiar, and the diction is all wrong for prepared slides
19:16:29 <gwern> ksf: why don't you experiment on #c and #perl?
19:17:31 <pikhq> ksf: It's a degenerate time of chat.
19:17:51 <ksf> gwern, for the same reasons the cern guys pretend to have broken their black hole generators?
19:18:24 <gwern> ...to avoid summoning in aliens who will turn the earth into a grungy dystopia?
19:18:32 * gwern doesn't follow
19:18:50 <ehird> ksf: are you serious
19:19:09 <ehird> Please tell me you're not serious.
19:19:22 <ksf> aliens sending viral nanobots via a blackhole-induced wormhole?
19:19:26 <gwern> SNAAACKKKKK!!!!
19:19:27 <ksf> sounds plausible.
19:19:42 <ehird> ksf: You're not serious. Revision. I hope you're not serious.
19:20:14 <ksf> ehird, do you happen to be located within 2 km of a cheese sandwich?
19:20:33 <FunctorSalad> uh-oh
19:21:08 <ehird> ksf: Probably.
19:21:30 <ksf> consider yourself a saviour
19:22:03 <ksf> if in doubt, prepare a cheese sandwich right now.
19:22:34 <Plouj> can someone change `ghc -package GLUT HelloWorld.hs -o HelloWorld` to `ghc --make -lglut HelloWorld` on this page: http://www.haskell.org/haskellwiki/OpenGLTutorial1 ?
19:22:46 <Plouj> oh, wait, I can do that
19:23:12 <ksf> cheddar, if possible.
19:23:41 <ksf> if not, we gotta repeat the routine some day, again.
19:26:31 <aavogt> @faq can Haskell express animorphisms?
19:26:31 <lambdabot> The answer is: Yes! Haskell can do that.
19:27:03 <pikhq> @faq Can Haskell solve the halting problem?
19:27:03 <lambdabot> The answer is: Yes! Haskell can do that.
19:27:24 <pikhq> :D
19:27:26 <Cale> animorphisms like Yakko, Wakko and Dot?
19:27:58 <monochrom> @faw can Haskell compile all those who don't compile themselves?
19:27:58 <lambdabot> The answer is: Yes! Haskell can do that.
19:28:05 <aavogt> like animorphs
19:30:26 <Twey> Cale: Hahaha
19:31:46 <aavogt> Cale: those too
19:32:00 <ksf> yakko = (>>=), wakko = (<*>)?
19:32:12 <Cale> clearly, dot = (.)
19:33:44 * Cale wonders if there are any GHC developers aroung looking for something to do ;)
19:33:49 <Cale> around*
19:34:30 <Cale> I wonder how hard it would be to add cata expressions.
19:35:11 <copumpkin> :o
19:36:41 <Cale> It would be a nice little piece of syntax to have...
19:37:10 <ksf> syntax is illusion.
19:37:26 <aavogt> what are they?
19:37:27 <cjs> Meta-syntax doubly so.
19:38:37 <monochrom> I think all GHC developers are busy preparing both 6.10.4 and 6.12
19:38:55 <ksf> and cheese sandwiches
19:38:56 <Cale> aavogt: basically, expressions which look a bit like case expressions (though without a scrutinee), where you specify how the constructors should get replaced, and it gives you the function that replaces those constructors throughout the datatype
19:39:13 <Cale> For instance, if we have
19:39:23 <Cale> data Tree a = Leaf | Branch a (Tree a) (Tree a)
19:39:26 <Cale> then you can write
19:39:42 <Cale> sumTree = cata Leaf -> 0; Branch x l r -> x + l + r
19:39:51 <Cale> sumTree :: (Num a) => Tree a -> a
19:40:17 <ksf> i've always wished for pattern matching inside lambdas.
19:40:25 <Cale> Basically, giving you a nice syntax for the fold over any algebraic datatype whose constructors are in scope
19:40:28 <copumpkin> can't you already do something like that with Data.Data and a function?
19:40:35 <copumpkin> (not sure)
19:40:47 <zeiris> :t cata
19:40:47 <lambdabot> Not in scope: `cata'
19:40:47 <Cale> er... hmm
19:40:58 <Cale> zeiris: it's a piece of syntax which I'm proposing
19:41:12 <monochrom> I have problem with â€œBranch x l r -> x + l + râ€. I'll just say it's like the spirit of Perl.
19:41:18 <Cale> monochrom: hm?
19:41:20 <ksf> (\x -> case x of ...) isn't really optimal
19:41:44 <aavogt> > (\(Just x) -> x) (Just 5) -- ksf, so multiple cases?
19:41:44 <Cale> monochrom: It's just specifying how Branch constructors get replaced recursively.
19:41:44 <monochrom> The spirit of Perl is "you know what I mean".
19:41:46 <lambdabot>   5
19:41:47 <copumpkin> ksf: oh, for multiple patterns?
19:41:57 <ksf> yeah.
19:42:00 <Cale> monochrom: It's not "you know what I mean", it's well-typed.
19:42:09 <ksf> if i'm not completely mistaken it's the same thing cale wants
19:42:17 <copumpkin> hmm
19:42:18 <idnar> Cale: shouldn't l be of type Tree a?
19:42:29 <Cale> It's also not the same as a case expression at all
19:42:31 <monochrom> Yes but l,r stands for both subtrees and numbers. Doubleplusungood.
19:42:32 <copumpkin> ksf: doesn't seem like it
19:42:40 <idnar> Cale: I mean, I know what you mean, but it looks like a pattern match
19:42:42 <Cale> idnar: Not unless the replacement is
19:42:57 <Cale> For instance...
19:42:59 <copumpkin> doubleplusungood! where's thoughtpolice?
19:43:08 <Cale> cata Leaf -> Leaf; Branch x l r -> Branch x l r
19:43:15 <Cale> Is another way to write the identity function
19:43:34 <Cale> as for lists:
19:43:43 <Cale> cata [] -> []; (x:xs) -> (x:xs)
19:43:51 <Cale> is the same as:
19:44:01 <aavogt> cata Leaf -> Leaf; Branch x l r -> Branch x r l -- which order does this flipping happen in?
19:44:07 <Cale> foldr (\x xs -> x:xs) []
19:44:18 <aavogt> top down, right?
19:44:25 <Cale> aavogt: Every single branch node is flipped
19:44:29 <Cale> The order doesn't matter.
19:44:51 <Cale> basically, if we have
19:45:12 <Cale> treeFold l b = f where f Leaf = l; f (Branch x l r) = b x (f l) (f r)
19:45:17 <Cale> then it's the same as writing
19:45:22 * ksf decides to call cale's version "catamorphic expressions" and his "cataexpressions"
19:45:30 <Cale> treeFold Leaf (\x l r -> Branch x r l)
19:45:38 <copumpkin> so isn't this like gfoldl with less noise?
19:45:44 <Cale> Uh, maybe?
19:46:06 <Cale> I don't think so, actually.
19:46:35 <copumpkin> I haven't actually used it :) it was a real question
19:46:39 <Cale> gfoldl just folds over immediate subterms, doesn't it?
19:46:39 <copumpkin> not a hint that you're doing it wrong
19:46:52 <copumpkin> it's just what I thought it did
19:47:00 <Cale> and it's irrespective of types (as long as they are Data)
19:47:04 <copumpkin> ah
19:47:24 <Cale> This folds only over the one algebraic datatype, and it does it thoroughly.
19:48:10 <Cale> Basically, it's the same thing as handing you the Church encoding of any datatype, combined with appropriate lambdas.
19:48:25 <copumpkin> it still seems like it would be nicer as a function rather than syntax, maybe with some autoderivble instance?
19:48:39 <Cale> The type of that function is too strange.
19:48:55 <copumpkin> it would have to take a tuple of functions or something
19:48:58 <copumpkin> which is kind of weird
19:49:18 <ksf> be careful to say such things, you're invoking oleg.
19:49:21 <copumpkin> lol
19:49:28 <Cale> First of all, the number of parameters would be equal to the number of constructors, and their types would be function types depending on the types of the constructors
19:49:28 <Twey> Haha
19:49:45 <pikhq> Oleg, oleg, oleg.
19:49:53 <copumpkin> Cale: yeah, that's why I was thinking of a tuple... seems like a multiparam typeclass with fundeps or something, but I haven't really thought it through
19:50:05 <aavogt> repeat "oleg"
19:50:13 <aavogt> > repeat "oleg"
19:50:14 <lambdabot>   ["oleg","oleg","oleg","oleg","oleg","oleg","oleg","oleg","oleg","oleg","ole...
19:50:19 <Twey> Noo
19:50:33 <pikhq> > intercalate (repeat "oleg")
19:50:34 <lambdabot>   Overlapping instances for GHC.Show.Show
19:50:34 <lambdabot>                              ([[[GH...
19:50:42 <pikhq> > intercalate (repeat "oleg") " "
19:50:43 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
19:50:47 <pikhq> Don't I feel dumb.
19:50:49 <copumpkin> if you say it 5 times and pat yourself on the head while rubbing your tummy, oleg will appear behind you
19:50:51 <Cale> Basically, I see this as a way to avoid the problem of people forgetting to implement folds on their datatypes.
19:51:04 <aavogt> @type unwords
19:51:05 <lambdabot> [String] -> String
19:51:07 <Cale> There are some subtleties though...
19:51:31 <Cale> data Tree a = Node a [Tree a]
19:51:42 <pikhq> > unwords . repeat "oleg"
19:51:43 <lambdabot>   Couldn't match expected type `a -> [GHC.Base.String]'
19:51:52 <pikhq> > unwords $ repeat "oleg"
19:51:53 <lambdabot>   "oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg...
19:51:58 <copumpkin> > cycle "oleg "
19:51:59 <lambdabot>   "oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg oleg...
19:52:01 <gwern> f'taghn ryleh olegthu!
19:52:12 * copumpkin doesn't speak welsh
19:52:12 <pikhq> copumpkin: Sure, sure.
19:52:18 <copumpkin> is that welsh?
19:52:18 <Cale> Here, the catamorphism has to map over the list.
19:52:30 <gwern> copumpkin: -_- you don't get it?
19:52:34 <pikhq> copumpkin: Not enough ws for vowels.
19:52:40 <copumpkin> pikhq: oh no!
19:52:43 <pikhq> gwern: Ia! Ia!
19:52:45 <copumpkin> gwern: I'm sorry :(
19:52:45 <gwern> and ys!
19:52:52 <Cale> Which I suppose is still not so hard to generate, given that we have catas for list. :)
19:53:00 <monochrom> "Ctr x y z -> f x y z" is clearly unclear and misleading.
19:53:04 <gwern> copumpkin: hie thee to a library. no self-respecting geek can long go without knowledge of the Cthulu mythos
19:53:16 <Cale> monochrom: How is it misleading?
19:53:23 <copumpkin> gwern: oh no! I'll check out the book(s?) ASAP!
19:53:27 <gwern> pikhq: the lambda of the black woods!
19:53:30 <aavogt> @index Cthulu
19:53:30 <lambdabot> bzzt
19:53:31 <Cale> monochrom: It expresses the graph replacement of Ctr with f
19:53:45 <gwern> copumpkin: book, probably. lovecraft's stories are a volume's worth
19:53:57 <Cale> Which is what catamorphisms like foldr and treeFold are doing.
19:54:23 <Cale> (and either and maybe)
19:55:30 <copumpkin> gwern: ack, sounds like a lot of reading! I only read picture books :(
19:55:38 <Cale> I think I'd want to allow eta-expansion of the patterns as well.
19:55:40 <copumpkin> and books with big letters
19:55:49 <gwern> that'd explain a lot
19:55:53 <pikhq> copumpkin: I'll loan you a few shelves.
19:56:00 <monochrom> @hpaste
19:56:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:56:05 <Cale> So that you could write things like  concat = cata [] -> []; (:) -> (++)
19:56:15 <pikhq> A couple should get you through the books I read in my *childhood*...
19:57:24 <copumpkin> my criterion for reading a book: not . any ((>6) . length) . words
19:57:26 <Cale> monochrom: It's only as misleading as naming the arguments to foldr x and xs is.
19:57:38 <Cale> er, the arguments to the function passed to foldr
19:58:01 * gwern is shocked at such anti-intellectualism in #haskell
19:58:04 <Cale> concat = foldr (\x xs -> x ++ xs) []
19:58:27 <monochrom> I don't write (\x xs -> x ++ xs). I write ((\x ys -> x ++ ys)
19:58:30 <gwern> perhaps we should ban copumpkin until he demonstrates remorse with a suitable action; such as reading The Decline and Fall of the Roman Empire
19:58:32 <copumpkin> gwern: keep up the shock and I'll lower that bound to 5
19:58:33 <ksf> finishing reading lotr and suddenly realising the sheer scope and epicness is an experience you shouldn't miss.
19:58:41 <pikhq> copumpkin: I last read a book fulfilling that criteria in kindergarten.
19:58:47 <copumpkin> pikhq: lol
19:58:48 <pikhq> 5? Scratch that.
19:58:57 <pikhq> I have yet to read such a book.
19:59:02 <Cale> monochrom: actually, I write neither, I just write (++) of course
19:59:26 <aavogt> > intersperse " " "well, you could read one like this"
19:59:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:59:33 <aavogt> > intersperse ' ' "well, you could read one like this"
19:59:34 <lambdabot>   "w e l l ,   y o u   c o u l d   r e a d   o n e   l i k e   t h i s"
19:59:36 <Cale> monochrom: But in a generalised notation, you have to specify somehow which constructor it is that you're replacing, so using a pattern is natural.
20:00:01 <pikhq> copumpkin: Or at a bare minimum reading Ender's Game.
20:00:07 <copumpkin> :)
20:00:23 <ksf> what about accessors vs constructors? accessors should come with predicates...
20:00:23 <copumpkin> reading is lame!
20:00:52 <Cale> copumpkin leaves reading books to pumpkin. copumpkin only writes books.
20:01:08 <gwern> @seen pumpkin
20:01:08 <lambdabot> I saw pumpkin leaving #ghc, #darcs, #haskell-blah, #haskell-in-depth and #haskell 1m 11h 19m 29s ago, and .
20:01:09 <monochrom> If you write "fold = cata Ctr x y z -> f x y z", it is unclear whether you mean fold (Ctr x y z) = f x (fold y) z, or fold (Ctr x y z) = f (fold x) y z, or fold (Ctr x y z) = f x y z.
20:01:19 * copumpkin killed pumpkin
20:01:29 <gwern> I rest my case, Your Honor.
20:01:48 <gwern> not only is he a murderer, but he's non-terminating!
20:01:50 <Cale> monochrom: it depends on the type of Ctr
20:02:03 <gwern> we might say he combines the worst of termination and non-termination
20:02:08 <Cale> monochrom: cata will always recurse
20:02:35 <ksf> Cale, what about mutual recursion?
20:02:43 <ksf> ...just descend into _any_ adt?
20:03:11 <monochrom> I know it is unclear to a computer.
20:03:14 <monochrom> err.
20:03:24 <mmorrow> , (not . any ((>6) . length) . words) "my criterion for reading a book: not . any ((>6) . length) . words"
20:03:25 <lunabot>  False
20:03:27 <Cale> ksf: Well, with mutual recursion you would need a way to specify what it does on the constructors of the other type, so not as I currently envision it.
20:03:35 <monochrom> I know it is clear to a computer. It is unclear to me. I don't want to always look at the types.
20:03:39 <Cale> monochrom: I don't think so. Charity has this feature.
20:03:43 <Cale> oh
20:03:46 <boyscared> question: i'm attempting to install djinn on freebsd, but the cabal cannot find readline.h (part of libedit). this is included in freebsd and readline.h exists at /usr/include/readline/readline.h. any ideas on how to get it pointing to the right place?
20:04:01 <Cale> monochrom: It would be clear to you if you had picked a type to start with
20:04:03 <mmorrow> with mutually recursive types you need to essentially have a fold for each SCC
20:04:30 <Cale> mmorrow: Not only that, you'd have to specify all the replacements for all the constructors for that SCC when using the fold
20:04:30 * copumpkin will be back later, need to learn how to read :)
20:04:37 <Cale> But perhaps that's okay.
20:04:38 <mmorrow> the tricky thing is what to do with stuff
20:04:43 <mmorrow> Cale: exactly, it's tricky
20:05:05 <Cale> However, I think things like  data Tree a = Node a [Tree a]  are easy enough.
20:05:07 <mmorrow> easier is the case of just mapping a type, rather than folding it
20:05:19 <monochrom> No. It would be clear to me if there were an IDE so I could hover to the line "Ctr x y z -> f x y z" and there would be a popup window saying "it really means f x y (fold z)".
20:05:24 <dibblego> is there a recursive directory copy in the standard library?
20:05:30 <Cale> You just need the natural map, which is of course possible if you can construct the natural cata
20:06:13 <Cale> monochrom: I don't really see it like that, I suppose.
20:06:35 <Cale> monochrom: I think of data structures as being trees/graphs with nodes labelled by constructors.
20:06:58 <Cale> monochrom: The rules inside the cata just say how to replace those nodes with other graphs.
20:07:12 <gwern> dibblego: don't think so; but there is 'Distribution.Simple.Utils copyDirectoryRecursiveVerbose'
20:07:26 <dibblego> gwern, great thanks
20:07:47 <gwern> assuming you don't mind using a cabal module for a directory thing
20:07:50 <monochrom> The problem is with x,y,z.
20:07:54 <gwern> and I think I saw similar functions in missingh once
20:08:05 <monochrom> If you go pointfree, it would be OK.
20:08:47 <monochrom> fold = cata Ctr -> f | Dtr -> g.  This says what you say, graph rewriting, Ctr replaced by f, etc.
20:09:23 <monochrom> Ctr x y z -> f x y z  this is the problem. What does z stand for?  Tell me only one answer, not two answers.
20:09:40 <Cale> It's exactly like you wrote above, only using lambdas
20:10:02 <Cale> cata Ctr -> (\x y z -> f x y z)
20:10:05 <Cale> is the same as
20:10:13 <Cale> cata Ctr x y z -> f x y z
20:10:50 <monochrom> Choose one: (A) z is the subgraph under that Ctr node before replacement.  (B) z is the subthunk after replacement.
20:11:01 <Cale> Always choose B
20:11:20 <monochrom> OK then "Ctr x y z" does not make sense.
20:11:25 <Cale> huh?
20:11:32 <Cale> It's just a way to avoid writing a lambda
20:12:07 <Cale> x y z are the subparts of the Ctr node after replacement
20:12:14 <monochrom> "Ctr x y z" only makes sense when z is the subgraph before replacement. If you say that z is the subthunk after replacement, it doesn't even have the right type to be a parameter of Ctr.
20:12:51 <Cale> Well, I'll admit that you can't always interpret that Ctr x y z as an expression.
20:12:56 <Cale> But it's not an expression.
20:14:22 <monochrom> The whole language encourages interpreting "Ctr x y z" as exactly that, an expression, with z a sensible subexpression of that. Now suddenly we make this little exception with this new syntax. This is crazy.
20:15:12 <Cale> I think it's a worthwhile concession.
20:16:13 <Cale> Since otherwise, you'll often want to put a lambda immediately after the ->, and the punctuation starts getting tedious
20:16:25 <Cale> Ctr -> \x y z -> ...
20:32:22 <dr_sureshhh> somebody knows how do i list already set variables?
20:32:49 <dr_sureshhh> at ghci
20:35:02 <shachaf> dr_sureshhh: :show bindings
20:37:41 <dr_sureshhh> [shachaf]: nice, can i remove them?
20:38:56 <shachaf> dr_sureshhh: Not that I know of.
20:39:06 <shachaf> I know no better than :help. :-)
20:39:15 <Twey> You can shadow them, though
20:41:23 <Cale> dr_sureshhh: iirc, reloading your file with :re clears them, but that might have changed
20:42:09 <shachaf> Well, that clears everything, like restarting ghci.
20:42:12 <shachaf> Not an individual binding.
20:42:51 <Cale> yeah
20:43:11 <Cale> you shouldn't really be defining things you want to keep there anyway :)
21:55:34 <kniu> I am confused by dependent types.
21:55:41 <Cale> kniu: what about them?
21:55:51 <kniu> On one hand, they are described as types that are indexed by values.
21:55:55 <Cale> (not that I'm an expert, but I might be able to explain something)
21:56:04 <Cale> right
21:56:19 <Cale> Just like our existing type constructors are indexed by other types
21:56:33 <kniu> By that definition, they're defined as (\x::T -> T') where T' mentions x.
21:56:38 <kniu> BUT
21:57:04 <kniu> then there are "dependent function types", which are NOT functions, but the TYPE of a function,
21:57:21 <kniu> only that they can use the value of an argument.
21:58:12 <kniu> by that definition, they're like (forall (x::T). T')
21:58:23 <kniu> where T' mentions x.
21:58:37 <kniu> which is it?
21:58:53 <SamB> kniu: some of each
21:59:01 <kniu> Epigram and Cayenne seem to be using that second notion.
21:59:18 <kniu> except cayenne still uses the arrow notation ((x::T) -> T')
21:59:27 <kniu> which confuses me even more.
21:59:33 <Cale> "Dependent function types are a generalization of function types: a dependent function type is a function type where the range of the function changes depending on the object to which the function is applied."
21:59:38 <SamB> I mean, the second notion incorporates the first
21:59:51 <kniu> really, it subsumes it?
21:59:58 <SamB> needs it, really
22:00:46 <SamB> notice how to use the value of that parameter to actually alter the return type, you're going to need to use that value as some sort of index, aren't you?
22:00:52 <kniu> yeah.
22:00:57 <kniu> so what you're saying is,
22:01:03 <Cale> The basic idea being that T' there contains occurrences of x which are substituted with the supplied value.
22:01:27 <kniu> those two notions are separate things, but they need each other to work right?
22:01:40 <SamB> well, the second one sure needs the first one
22:01:44 <SamB> I'm not sure about the other way
22:01:52 <Cale> hmmm
22:02:27 <Cale> Yeah, there are useful things you can do with dependent types without this
22:02:43 <Cale> like  append :: Vec n -> Vec m -> Vec (n+m)
22:03:15 <kniu> append :: forall (n :: Nat) (m :: Nat). Vec n -> Vec m -> Vec (n + m)
22:03:26 <Cale> indeed
22:03:49 <kniu> that means it still needs the second notion.
22:03:55 <Cale> hm?
22:04:03 <kniu> values of n and m must still be passed into append.
22:04:23 <Cale> Oh, I suppose you could look at it that way.
22:04:41 <Cale> They're not explicitly passed there.
22:04:49 <kniu> inferred, aye.
22:04:57 <kniu> Haskell likes to infer things.
22:05:09 <FunctorSalad> say you have a function f : T -> Type
22:05:12 <kniu> I still like to think that polymorphism is just hidden type passing.
22:05:18 <Cale> I don't usually think of quantifiers as being parameters.
22:05:23 <mmorrow> although iirc there's no "forall" in dependently typed langs (?)
22:05:31 <mmorrow> so you need to pass them explicitly
22:05:32 <SamB> mmorrow: sure there is
22:05:33 <FunctorSalad> then you can make the type of dependent functions "forall x, T x"
22:05:49 <mmorrow> SamB: really? i know agda doesn't do polymorphism
22:05:54 <Cale> Yeah, don't they use the notation Pi x. T' ?
22:06:01 <mmorrow> it just does it by passing the type in
22:06:04 <kniu> Pi, right.
22:06:06 <Cale> Or  Pi (x :: A). B
22:06:07 <SamB> mmorrow: oh, well, I didn't say it did what you'd like it to
22:06:10 <kniu> Epigram uses forall.
22:06:11 <FunctorSalad> oh sorry I mixed my notation up
22:06:12 <SamB> just that you can write it ;-P
22:06:19 <mmorrow> SamB: heh
22:06:20 <FunctorSalad> "forall x, f x"
22:06:40 <mmorrow> does that take `x' as a param though?
22:06:45 <SamB> mmorrow: to do what you want in Coq, you need to go and say which parameters it should infer
22:06:51 <FunctorSalad> vanilla function types are the special case where f is constant
22:06:54 <jmcarthur> mmorrow: A : Set -> blah  is about the same as  forall A . blah , isn't it?
22:06:55 <SamB> more-or-less
22:07:03 * SamB forgets how it figures out the defaults
22:07:20 <mmorrow> i'd think it would be:
22:07:42 <mmorrow> (forall a. a -> Int) ===> (a -> (x::a) -> Int)
22:07:59 <SamB> most of these languages have a way to allow you to not write all of the parameters
22:08:27 <SamB> usually by somehow establishing an agreement between you and the implementation about which ones you should pass explicitly, and which ones implicitly
22:08:35 <jmcarthur> mmorrow: and agda does do forall, btw. i think it's just sugar though. trying to look it up now
22:08:52 <kniu> mmorrow, why not just (forall (x :: a). Int)?
22:08:55 <SamB> and sometimes there are ways to override some of 'em on a call-by-call basis
22:08:57 <mmorrow> jmcarthur: i know that agda doesn't do polymorphism, i just don't know what "doesn't do" means
22:09:04 <FunctorSalad> the forall as in coq (depedent function type) doesn't have much to do with haskell's forall I'd say
22:09:15 <mmorrow> jmcarthur: (i.e. what is the relationship between `forall' and polymorphism?)
22:09:23 <SamB> FunctorSalad: yeah, it's more like forall in logic
22:09:29 <mmorrow> FunctorSalad: yeah, exactly
22:09:45 <SamB> and I'm not sure how often you need one and how often you just write it for style purposes
22:10:02 <FunctorSalad> "forall x : T, f x", where f :: T -> type, is just the type of functions that maps each x to an f x
22:10:06 <mmorrow> kniu: hmm, i'm not sure what that would mean (forall (x :: a). Int)
22:10:36 <SamB> most of these languages also have a mind-boggling number of ways to write an equivalent type
22:10:39 <kniu> Having just read through TaPl, I understand 'forall' as a kind of "arrow type".
22:10:41 <mmorrow> that seems to me that it's saying "for every value `x' of a fixed `a' ..."
22:10:55 <kniu> when the argument needs to be mentioned also in the type, you write forall.
22:11:00 <kniu> otherwise, just use ->
22:11:01 <mmorrow> rather than "for every type `a' ..."
22:11:01 <SamB> which may or may not result in the same implicit/explicit passing for each parameter
22:11:14 <FunctorSalad> kniu: yes. the arrow is the special case where the body of the forall doesn't actually depend on x
22:11:34 <Cale> I suppose you could treat a proof of a logical expression forall x. P(x) as being a sort of function from a value x to a proof of P(x). That's perhaps not really the right thing for classical logic, but it works for these intuitionist systems.
22:12:14 <FunctorSalad> for classical logic you just add the P \/ not(P) axiom
22:12:43 <SamB> kniu: ah, yeah, that's the rule JHC uses to determine if it should print Î x::a. b or just a -> b ...
22:12:49 <FunctorSalad> forall really is logical forall in the "elements of propositions types are proofs of the proposition" interpretation
22:12:55 <Cale> But are you really going to want every proof of forall x. P(x) to take that form? Hmm...
22:12:57 <FunctorSalad> *proposition types
22:13:06 <Cale> Maybe there's a nice way to translate every proof into that form.
22:13:19 <kniu> SamB, JHC does dependent types?
22:13:33 <SamB> kniu: in it's IR, yes
22:13:44 <kniu> interesting.
22:13:55 <SamB> perhaps not VERY dependant, but they're dependant enough to use that notation
22:13:58 <copumpkin> what does it use them for?
22:13:58 <FunctorSalad> Cale: I'm not sure but I don't see what the problem is
22:14:03 * meder tries to keep up with the conversation, has aways to go
22:14:22 <Cale> after all, it's common in classical logic to prove forall x. P(x) by proving not exists x. not P(x)
22:15:00 <FunctorSalad> hmm in coq "exists" is just an inductive type
22:15:35 <SamB> Cale: well, I think you can do that in constructive logics too
22:15:36 <SamB> mostly
22:16:00 <SamB> except you don't call it "not exists", you just prove that the type of x is uninhabited
22:16:03 <FunctorSalad> the constructor has type "forall (A:Type) (P:A -> Prop) (x:A) (prf:P x), exists A P"
22:16:45 <FunctorSalad> not sure how that plays with the classical axiom
22:17:33 * SamB heads to bed
22:17:40 <kniu> SamB, I'd like to know what JHC uses dependent types for,
22:17:42 <kniu> but good night.
22:17:48 <Cale> SamB: I was pretty sure this was one of the main differences between intuitionist and classical logics, that proof that it's not the case that something isn't true for all elements of a set isn't proof that it holds for one of them.
22:18:23 <SamB> kniu: I'm not fit to tell you at the moment ;-)
22:18:33 <Cale> (because you can't be sure which one it is)
22:19:15 <SamB> Cale: I don't think it's an issue when the set is empty
22:20:10 <Cale> Well, the empty set is a special case...
22:20:42 <mmorrow> !exists a. a `elem` /O
22:20:48 * SamB sends his camp paper patches to Igloo before actually heading to bed
22:20:50 <Cale> or maybe it's just that it's the other way around?
22:21:37 <Cale> Which direction of  not exists <-> forall not  no longer applies?
22:21:38 <SamB> Cale: well, it is not the case that "not (not x) -> x"
22:22:07 <SamB> that's all I can remember before sleeping
22:22:12 <copumpkin> it is not not not the case that "not (not x) -> x"? :P
22:23:19 <mmorrow> this is relevant here: http://moonpatio.com/images/Rieger-Nishimura.svg
22:23:22 <SamB> copumpkin: what I mean is that that rule of inference goes bye-bye when you flip the classical/constructive switch to constructive
22:23:31 <Cale> @djinn Not (Not (Not (Not (Not x) -> x)))
22:23:31 <lambdabot> -- f cannot be realized.
22:23:32 <copumpkin> :) I was just being silly
22:23:45 <SamB> oh, but we can infer my statement from yours still
22:24:05 <SamB> @djinn Not (Not (Not x)) -> Not x
22:24:05 <lambdabot> f a b = void (a (\ c -> c b))
22:24:14 <SamB> @djinn Not (Not x) -> x
22:24:14 <lambdabot> -- f cannot be realized.
22:24:23 <copumpkin> oh no!
22:24:25 <copumpkin> I fail at failing
22:24:25 <FunctorSalad> assume not(ex x. not P x). goal: forall x. P x. let x be in the domain. apply the classical axiom to P x to get P x \/ not(P x). from both we can prove P x
22:24:26 <SamB> how does djinn prove that f cannot be realized
22:24:32 <SamB> ?
22:24:36 <copumpkin> where fail at failing != succeeding
22:24:39 <Cale> @djinn Not (Not (Not (Not x))) -> Not (Not x)
22:24:39 <lambdabot> f a b = void (a (\ c -> void (c b)))
22:24:46 <FunctorSalad> ("anything from a contradiction" does hold in constructive logic)
22:25:09 <Cale> FunctorSalad: and in every categorical logic :)
22:25:23 <SamB> FunctorSalad: yeah, that's why proving that x's type is uninhabited suffices to prove forall x, P(x)
22:25:25 <FunctorSalad> (I mean, from either side of the disjunction we can prove P x)
22:26:02 <BMeph> Has anyone heard anything lately about Keith Hanna's PIVOTAL project?
22:26:05 <Cale> (at least, for some definitions of contradiction, I don't know about all of them...)
22:27:05 <FunctorSalad> Cale: what I'm trying to say is that if you assume the classical axiom in a system where proofs are programs, then you can prove forall x. P x from not (exists x. not (P x)) just fine
22:27:12 <FunctorSalad> but I'm tired too ;)
22:28:15 <FunctorSalad> the axiom would be an "oracle" that maps each P :: Prop to a proof for P \/ notP
22:29:18 <Cale> okay
22:31:27 <nainaide> any idea on learn monad 'little' step by 'little' step ? :)
22:31:51 <FunctorSalad> (btw I'm not an expert on this, I just made that argument up ;))
22:32:46 <Cale> If you have any logic where the |- relation can be used as the arrow for a Cartesian closed category, then a proof of P and (not P) is identified with an arrow 1 -> P x 0^P which after composition with the application map for the exponential object 0^P, we get an arrow 1 -> 0. This can then be composed with any of the unique maps 0 -> X to get a proof of X.
22:33:16 <Cale> So any categorical logic has that from a contradiction, anything follows.
22:33:37 <Cale> (fsvo "categorical logic")
22:34:24 <Cale> nainaide: hmm... probably the easiest way to learn monads is by learning a bunch of examples.
22:34:51 <BMeph> Cale: Your mileage may vary. Past performance does not guarantee future results. Void where prohibited...) ;)
22:34:53 <Twey> nainaide: Monads are values that represent a series of operations passing a datum between them.
22:35:01 <nainaide> Cale, good idea
22:35:17 <Cale> Twey: even lists?
22:35:29 <Cale> (also, monads are not values ;)
22:35:39 * Twey handwaves
22:35:46 <Twey> WRT lists: yes
22:36:04 <FunctorSalad> Cale: looks right. the analogous idea in coq is (I think) that a contradiction corresponds to the empty type, and you can do induction with zero things to prove for the empty type ;)
22:36:04 <Twey> They represent a series of chained operations on some datum
22:36:36 <FunctorSalad> *to prove something from the empty type
22:36:37 <Cale> FunctorSalad: Well, a contradiction corresponds to a proof of the empty type :)
22:36:46 <FunctorSalad> oh sorry, right
22:36:51 <Twey> The fact that those operations are then applied to multiple values in weird ways is not relevant to the initial representation
22:39:19 <Cale> nainaide: Basically, to say that something is a monad is to say that it's a type constructor together with a particular interface of operations. (Specifically return and >>=). So to find out how a given monad works, you should look at the type constructor, and the definitions for return and for >>= which make it into a monad, and then look at the surrounding API, since there will usually be many more interesting opera
22:39:20 <Cale> tions.
22:40:16 <Cale> You might also want to look at how the various functions in Control.Monad which work for all monads work for your monad.
22:40:40 <Cale> nainaide: Let's have a look at lists, and how they support the operations.
22:40:44 <nainaide> Cale, I spent a week in Monad, although I learned some basic concepts , still feel confuse.
22:41:09 <nainaide> expecially  on transformer.
22:41:24 <Cale> Well, yeah, I'd leave monad transformers alone for a while.
22:41:53 <Cale> They're a useful technique for constructing particular libraries, but you should be comfortable with monads in general first.
22:42:42 <nainaide> Cale, yes. first be comfortable with monads  for a while, then learn monad transformers
22:43:03 <Meady> Morning
22:43:14 <Cale> Monad transformers take one monad and turn it into another one, and take the special operations on the original monad, and turn them into operations on the new monad. So if you're not already comfortable with monads in general, it gets confusing quickly :)
22:43:22 <Twey> nainaide: I still strongly recommend http://haskell.org/haskellwiki/Monads_as_computation
22:43:40 <Cale> Yeah, I recommend that one too ;)
22:44:01 <Meady> My eyes hurt
22:44:11 <aavogt> I was mostly confused by parameter order (and what order the monad stack actually was), when I learned monad transformers
22:44:24 <BMeph> So, what's the dual to MonadZero? :)
22:44:51 <nainaide> Twey, thanks. I have finished the Part I and Part II of http://www.haskell.org/all_about_monads/html/index.html
22:44:54 <aavogt> MonadNegativeZero?
22:44:55 <Cale> There are a lot of confusing tutorials for monad transformers too... actually, I'm unhappy about every single one of them that I've seen.
22:45:01 <Cale> (in one way or another)
22:45:12 <BMeph> Er, the *comonadic dual, just to be explicit. :)
22:45:14 <nainaide> me too
22:45:34 <Cale> Most of them make the mistake of showing you what is exactly the wrong way to use monad transformers (not newtyping them)
22:46:04 <aavogt> written before newtype deriving became popular / implemented?
22:46:04 <Cale> and some of them start to confuse the notion of monad and monad transformer, and try to blur the lines, which I think is very wrong
22:46:09 <Cale> yeah, probably
22:46:39 <Cale> though, the automatic lifting instances in the mtl also blur the lines and make things hard to learn
22:46:45 <nainaide> sounds funny
22:47:00 <FunctorSalad> BMeph: MonadZero doesn't have anything to do with the monad structure, does it?
22:47:11 <Cale> ComonadOne ? ;)
22:47:27 <Cale> FunctorSalad: It does a little bit
22:47:33 <Cale> mzero >>= f = mzero
22:47:37 <Saizan> if you reverse the arrow you get cozero :: m a -> (), no?
22:48:02 <FunctorSalad> ah
22:48:58 <Saizan> and coplus :: m a -> (m a, m a) ?
22:49:04 <Cale> which is maybe related to why >>= is in some of the early papers referred to as 'multiplication'
22:49:14 <FunctorSalad> (const mzero) >=> arr = const mzero?
22:49:48 <copumpkin> ARR
22:49:53 <Cale> yeah
22:50:00 <FunctorSalad> copumpkin: lol
22:50:09 <FunctorSalad> but not the other way?
22:50:16 <FunctorSalad> (arr >=> const mzero)
22:50:38 <Cale> Well, x >>= const mzero = mzero is hard to support
22:50:57 <Cale> er, I could have written that x >> mzero
22:51:09 <Saizan> as in "doesn't hold for IO"
22:51:10 <Cale> but some monads support that notion of it
22:51:26 <Cale> I suppose it's possible to require it :)
22:51:27 <FunctorSalad> hmm ok, the mzero has to revert any effects
22:51:39 <FunctorSalad> would work for the list monad apparently
22:51:44 <Cale> yeah, and Maybe
22:51:56 <Cale> So it does work quite often.
22:52:42 <Cale> Things are slightly hazy about what MonadZero and MonadPlus really mean
22:52:49 <Saizan> it doesn't for Either though
22:53:02 <Cale> yeah...
22:53:48 <Cale> Whether Either and IO can really be considered proper MonadZeroes is a matter of possible debate. :)
22:54:24 <FunctorSalad> how is Either a MonadZero?
22:54:40 <FunctorSalad> the left type could be empty
22:54:44 <Saizan> using an Error e => context
22:54:49 <FunctorSalad> ah
22:54:54 <Saizan> ?src Error
22:54:54 <lambdabot> class Error a where
22:54:54 <lambdabot>     noMsg  :: a
22:54:54 <lambdabot>     strMsg :: String -> a
22:55:02 <luqui> boo Error context
22:55:10 <luqui> prevents composability of exceptions
22:56:57 <Cale> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg03267.html -- the message asking the question to whose answer was the big mistake ;)
22:57:23 <cjs> So if one installs monads-fd, one shoudl remove the mtl package?
22:57:30 <wmealing> using ghc, haskell compiles down to machine code.. right ?
22:57:35 <copumpkin> yeah
22:57:44 <Cale> cjs: hide, perhaps
22:57:49 <cjs> Ah.
22:57:55 <Cale> cjs: not remove. mtl is way too important
22:58:13 <wmealing>  copumpkin that was for me ?
22:58:19 <copumpkin> wmealing: yeah
22:58:23 <wmealing> thanks
22:58:32 <Cale> I wonder what the point of monads-fd is
22:58:38 <cjs> So "hide" means that things already linked against it will continue to use it, but newly compiled things using, e.g., Control.Monad.Error will link against monads-fd?
22:59:12 <Cale> cjs: yeah, the only way to get the mtl package then will be to explicitly list it in the dependencies or on the ghc commandline with a -package flag
22:59:36 <Cale> But... what is the point of monads-fd?
22:59:53 <cjs> Hm. It sounds as if one is just experimenting with monads-fd, one should hide that and use the -package flag to expose it only for the specific things that need it.
22:59:59 <Cale> It seems to repeat the mistakes that mtl has.
23:00:06 <Cale> yeah
23:01:00 <FunctorSalad> cjs: or use -XPackageImports
23:01:14 <FunctorSalad> import "monads-fd" Control.Monad.Something
23:01:33 <luqui> Cale, hmmm, Simon's defense is one of conal's dangerous speech patterns-- proof by lack of imagination:  "if we do it this way, then how ... ?"
23:01:40 <cjs> FunctorSalad: cool! Thanks.
23:01:51 <Cale> Oh, I think monads-fd is provided for compatibility with old versions of GHC?
23:02:26 <FunctorSalad> I don't see the big advantage of type families over fundeps...
23:02:48 <Cale> FunctorSalad: Mostly that type families interact with GADTs
23:02:51 <FunctorSalad> fundeps let you have injectivity without forcing you to make up new datatypes
23:03:07 <FunctorSalad> (and TH supports fundeps but not families, I think)
23:03:15 <Cale> You don't need new datatypes for type families either
23:03:42 <FunctorSalad> but for data families (which you need if you want injectivity)
23:03:46 <Cale> (just new type constructors)
23:03:54 <Cale> ah
23:03:59 <Cale> yes, I suppose
23:04:01 <FunctorSalad> hmm I don't see the GADT connection right now
23:06:35 <mmorrow> umm, what is an "EB"?
23:06:38 <mmorrow> context:
23:06:48 <mmorrow> "These sections plus the above can have a combined size of up to 16EB."
23:06:58 <Cale> Exabyte
23:07:00 <mmorrow> extrahugerthanterr-byte?
23:07:04 <mmorrow> Cale: ah nice
23:07:39 <mmorrow> haha
23:07:41 <mmorrow> "one quintillion bytes"
23:07:51 * mmorrow doesn't even know how many that is
23:08:04 <mmorrow> 1 EB = 1,000,000,000,000,000,000 B = 10^18 bytes
23:08:06 <mmorrow> apparently
23:08:08 <inimino> it's just one after petabyte
23:08:20 <FunctorSalad> @go 1 exabyte in byte
23:08:20 <Cale> An EB is to GB what GB is to B
23:08:21 <lambdabot> http://en.wikipedia.org/wiki/Exabyte
23:08:21 <lambdabot> Title: Exabyte - Wikipedia, the free encyclopedia
23:08:26 <FunctorSalad> meh
23:08:26 <Cale> basically
23:08:35 <mmorrow> > maxBound :: Int
23:08:36 <lambdabot>   9223372036854775807
23:09:00 <mmorrow> > maxBound - 1000000000000000000 :: Int
23:09:01 <lambdabot>   8223372036854775807
23:09:04 <mmorrow> wow
23:09:13 <copumpkin> big number is big
23:09:23 <Cale> big number is not that big
23:09:30 <FunctorSalad> 2^64 vs 2^60
23:09:38 <copumpkin> graham's big number is big
23:09:42 <inimino> KB, MB, GB, terabyte, petabyte, exabyte
23:09:42 <FunctorSalad> eh no that would be unsigned
23:09:50 <luqui> BB(6) is big
23:09:59 <Cale> luqui: which is bigger?
23:10:07 <RayNbow> say, is there a nice extension that makes type constructors polymorphic in their kind? (or at least allows two different kinds?) :p
23:10:08 <inimino> pfft, BB(graham's number) is big
23:10:15 <luqui> well BB(6) might not even exist in classical logic...
23:10:15 <copumpkin> fix (join ackermann)
23:10:17 <copumpkin> :P
23:10:21 <luqui> er constructive i mean
23:10:25 <copumpkin> what's BB?
23:10:31 <FunctorSalad> busy beaver
23:10:34 <copumpkin> oh :)
23:10:39 <mmorrow> heh, so the full context of that was
23:10:42 <inimino> busy beaver
23:10:42 <FunctorSalad> (busy beaver is very busy indeed)
23:10:43 <mmorrow> .lplt .ltext .lgot .lrodata .lrodata1 .ldata .ldata1 .lbss
23:10:43 <mmorrow>     These sections plus the above can have a combined size of up to 16EB.
23:10:45 <mmorrow> :o
23:10:53 <copumpkin> bigg!
23:11:02 <mmorrow> (x86_64)
23:11:09 <mmorrow> (elf)
23:11:27 <Cale> Way to limit.
23:11:35 <copumpkin> iterate (join ackermann) 1 seems like it'd be fun though
23:12:15 <FunctorSalad> it holds no sway over BB.
23:12:19 <copumpkin> :(
23:12:31 <FunctorSalad> (since it's still computable)
23:12:43 <copumpkin> :(
23:12:54 <Cale> luqui: What do you mean by 'not exist'? It's a finite number, isn't it?
23:13:14 <Cale> luqui: Don't all finite numbers constructively exist, since you can just write down enough S's :)
23:13:32 <FunctorSalad> (I learned that idiom from http://www.wisemouseboy.com/gallery2/d/3811-2/longcat_widedog_framed.jpg )
23:13:43 <Cale> hmm, maybe we can't prove that it's really the value of BB(6)?
23:13:48 <luqui> Cale, well, to show that BB(n) is a function, you need a decision procedure for the halting problem on turing machines of n states
23:14:08 <luqui> i.e. in constructive logic, it is unknown whether all 6-state turing machines either halt or don't
23:14:42 <luqui> s/function/number/
23:14:42 <inimino> luqui: why do you need that?
23:14:50 <Cale> Would be funny if it turned out false though ;)
23:15:10 <luqui> BB(n) is the max of the running time of all halting turing machines of n states.
23:15:17 <Cale> This one right here, it goes sideways?
23:15:29 <luqui> obviously well defined in classical logic when for every turing machine T, Halts(T) \/ ~Halts(T)
23:15:37 <FunctorSalad> if you know what BB(6) is, sure you can write it down in constructive logic. luqui is saying something a bit different
23:15:43 <luqui> try to formalize that in classical logic, where P \/ ~P implies a decision procedure.
23:15:55 <luqui> *constructive
23:15:55 <luqui> again
23:15:57 <luqui> stupid c's
23:16:41 <inimino> hm, ok, I guess I don't enough about constructive logic
23:16:52 <Cale> There are unfortunately quite a large number of 6 state Turing machines to check :)
23:17:03 <luqui> inimino, the key ingredient here is that if P \/ Q is provable, then P is provable or Q is provable.
23:17:07 <FunctorSalad> (I mean you could write the "literal" down. you might not be able to prove that it's really BB(6))
23:17:18 <Cale> FunctorSalad: right
23:17:20 <kulakowski> The difference is between writing down some integer n, and writing down a proof that n is the longest any 6 state turing machine can run and halt.
23:17:59 <Cale> It was just the particular phrasing "BB(6) might not exist" which caught me off guard
23:18:21 <luqui> well it might not....
23:18:30 <luqui> constructive logic is the logic of computation
23:18:33 <mmorrow> en garde!
23:18:46 <luqui> classical logic might say it exists, but gives no way to say what the number is
23:18:58 <luqui> so it might not be a *real* number
23:19:05 <luqui> (in the tangible sense)
23:19:11 <mmorrow> what does that mean?
23:19:25 <Cale> luqui: But my metamathematics is classical, which means that I automatically interpreted your statement as "SSS...S0 might not exist" where there are an appropriate number of S's ;)
23:19:25 <mmorrow> if it exists it exists, no?
23:19:33 <luqui> Cale, ahh
23:19:41 <inimino> yeah, what does it mean?
23:19:45 <inimino> and it does exist, no?
23:19:53 <luqui> well it depends on how you define exist
23:19:56 <FunctorSalad> it's a question on the informal level
23:20:12 <inimino> well, I guess most things do
23:20:20 <FunctorSalad> whether you think that classical logic adequately captures "truth"
23:20:20 <luqui> i'm not convinced it has any representation of the form SSSSSSS...SSSS0
23:20:33 <kulakowski> What does `exist' mean? What model of the naturals?
23:20:35 <mmorrow> there is no truth, only definitions
23:20:44 <Cale> mmorrow: hear hear!
23:20:55 <mmorrow> :)
23:20:57 <Cale> formalism ftw!
23:21:34 <luqui> one thing i know is, if *constructive* logic says it exists, then it has some representation of that form
23:21:37 * Cale extends formalism as a philosophy for everything.
23:21:41 <luqui> there is no such guarantee in the classical world
23:22:07 <mmorrow> well, a representation exists, you just don't know what it is
23:22:09 <luqui> well, there *might* not be any such guarantee
23:22:15 <Cale> luqui: aha, but in classical logic, we would say it has a representation of that form
23:22:23 <luqui> there is a guarantee in constructive, and only maybe there is in classical, depending on your beliefs
23:22:26 <Cale> luqui: because every natural number does, and it's a natural number
23:22:37 <FunctorSalad> well yes, if your informal semantics are "we can construct it" then constructive logic is the right logic ;) but if your semantics is just "truth" I think classical is fine
23:22:38 <Cale> ;)
23:22:39 <luqui> Cale, ah yeah, but you can't answer when I ask you what it is :-)
23:22:41 <inimino> and there is a guarantee, surely
23:22:48 <inimino> obviously every Turing machine will either halt, or not
23:22:55 <Cale> luqui: right.
23:23:12 <copumpkin> congratulations, you all have scared off 100 newbies in the past half hour :)
23:23:12 <luqui> as a consequence, i have lost trust in classical logic
23:23:13 <inimino> and obviously there are a finite number of them to try, so...
23:23:15 <kulakowski> inimino: intuitionists might take issue with that.
23:23:18 <luqui> maybe some brilliant mathematician will restore it someday
23:23:20 <Cale> luqui: Well, except by something glib like oh, it's "SSS...S0" where there are BB(6) S's.
23:23:30 <luqui> Cale, lol
23:24:11 <Cale> luqui: mathematics isn't necessarily always interested in constructing concrete representations like that though
23:24:34 <luqui> that's true.
23:24:37 <mmorrow> copumpkin: lol
23:24:41 <inimino> kulakowski: which part of it?
23:24:43 <luqui> i trust the consistency of classical logic
23:24:47 <Cale> It's kind of silly to consider *really* constructing BB(6) because, well, you'll run out of paper.
23:24:51 <luqui> so if you're trying to prove that something can't happen, i'll believe you
23:24:57 <copumpkin> :)
23:25:05 <luqui> ahh, ultrafinitism is it?  =)
23:25:13 <inimino> hehe
23:25:27 <kulakowski> inimino: the invoking the law of the excluded middle part.
23:25:28 <FunctorSalad> luqui: classical logic is an abstraction, like everything else in math... (or in our modelling of the world, for that matter)
23:25:40 <Cale> If you'll run out of paper constructing it, what do you care if it's really constructible or not? :)
23:25:43 <opqdonut> i think topology for instance makes a good case for classical logic
23:26:03 <luqui> opqdonut, I think topology makes a good case for constructive logic! :-)
23:26:08 <opqdonut> all these complement theorems correspond to one's geometrical intuition pretty well
23:26:31 <opqdonut> constructive topology doesn't let you leverage that intuition
23:26:41 <inimino> kulakowski: I guess, it's just hard for me to imagine someone seriously arguing that there are Turing machines that neither halt nor don't
23:26:46 <FunctorSalad> it might be cognitively economical to have fictious entities in your model if it makes the theory as a whole simpler.
23:27:00 <FunctorSalad> like opqdonut is saying, essentially
23:27:07 <Cale> I might be the odd one out in thinking this way, but I think all the examples of discontinuous real functions are cool, and I wouldn't want to give them up.
23:27:08 <luqui> the proofs of a given sentence are an open set, and you just map definition that around to get all of topology back
23:27:41 <inimino> (I guess I should study intuitionistic logic sometime)
23:27:49 <luqui> FunctorSalad, i agree.  eg. proof by contradiction is still a very useful way for me to think.
23:28:01 <opqdonut> luqui: indeed
23:28:02 <mmorrow> constructive logic is like embedding your entire mathematics inside a topology, whereas classical mathematics can look at your world from the outside and wonder what you're doing in there anyways
23:28:07 <kulakowski> inimino: it would be the sort of person that would argue that a Turning machine is not at all a machine and that your physical intuition has little to do with the number theoretic properties of certain functions
23:28:09 * Cale hugs his locally dense functions
23:28:30 <opqdonut> :D
23:28:33 <Cale> (which map every open interval to a dense set of reals)
23:28:40 <opqdonut> i can so picture that in my mind
23:29:02 <inimino> kulakowski: hm, ok
23:29:14 <Cale> Or how about we go whole hog and go with locally surjective :)
23:29:55 <FunctorSalad> IIRC grothendieck said something along the lines of that it's better to have a category good properties at the price of having some pathological objects
23:30:08 <FunctorSalad> *a category with
23:30:10 <Cale> yeah
23:30:13 <kulakowski> Grothendieck said almost exactly that.
23:30:59 <luqui> FunctorSalad, yeah, the lack of de morgan in constructive logic really bugs me
23:30:59 <copumpkin> 2:30 EST, when all the logic geeks come out to play
23:31:19 <FunctorSalad> 8:30 am in my case
23:31:31 <Cale> I'd agree with that. Of course, you can always use the Yoneda lemma to give you nicer objects, but use the Yoneda objects for long enough and you'll want them to be real.
23:31:37 <luqui> i just love busy beaver functions.  there are so many philosophical questions hiding in them.
23:31:41 <Adamant> WARRIORS^H^H^H^H^H^H^HLogic Geeksssssss!!!! COME OUT AND PLAY!
23:31:44 <copumpkin> FunctorSalad: I included the time zone specifically to stop people from correcting me!
23:32:08 <luqui> copumpkin, how fast are you going?
23:32:22 <copumpkin> how fast am I going?
23:32:22 <luqui> %-)
23:32:28 <FunctorSalad> luqui: btw I wasn't saying "classical is right, intuitionistic is wrong"... they both have their place
23:32:32 <copumpkin> :o
23:32:38 <luqui> FunctorSalad, absolutely
23:33:08 <Cale> You can only ask "which is more fun to use"? ;)
23:33:09 <luqui> really understanding both is important, so you know how to interpret mathematical statements
23:33:25 <kulakowski> Excluded middle is true in the `real world', whatever that is. In some toposes it makes sense, in some it doesn't.
23:33:42 <luqui> there you go again, using that word
23:33:44 * Cale doesn't believe in the real world.
23:33:48 <luqui> "true"
23:33:54 <luqui> (and "real world", ty cale :-)
23:34:19 * Cale wonders if his philosophy is spreading to others.
23:34:22 <idnar> kulakowski: what about the complex world?
23:34:45 <luqui> true or not, it's very pretty
23:34:53 * kulakowski stabs idnar 
23:35:12 <luqui> integers, rationals and reals can all bite me.  To me, we only have naturals and complexes :-)
23:36:00 <Cale> I think of "true" and "false" as labels which we arbitrarily attach to strings of symbols in our languages, usually in some coherent way. I don't really expect the universe to attach them for us though.
23:36:03 <copumpkin> complices?
23:36:05 <copumpkin> :P
23:36:16 <Saizan> i like the view of constructive logic as an extension of the classical one, adding computational value, not sure if i understand it properly though
23:36:22 <FunctorSalad> Cale: it's this nasty thing that demands attention when you have run out of food ;)
23:36:27 <dancor> cabal-install reinstalls network-2.2.1 every time i install anything
23:36:51 <dancor> i think it might be related to issues with parsec 2 vs 3
23:36:58 <Saizan> dancor: cabal --version ?
23:37:12 <Cale> FunctorSalad: well, okay, I trust in my subjective observations and senses, but I don't believe that there's an absolute truth to things, only our subjective ones.
23:37:19 <dancor> Saizan: cabal-install version 0.6.0
23:37:20 <dancor> using version 1.6.0.1 of the Cabal library
23:37:33 <Cale> and even my senses I don't always trust ;)
23:37:41 <inimino> Cale: probably something in that direction is a healthy view, but ...
23:37:44 <Saizan> dancor: try upgrading both cabal-install and Cabal
23:37:47 <dancor> ok
23:38:07 <Saizan> dancor: in the opposite order :)
23:38:43 <luqui> Cale, I agree in a different way.   Truth might be absolute, but things aren't, so there's the same conclusion.
23:38:50 <inimino> Cale: unless you state a connection of some kind between 'true' and the universe it seems quite incomplete
23:39:04 <Cale> I don't see a need for the scientific method to assume that there's an objective reality, and we've gotten quite far with the scientific method.
23:39:23 <Cale> (or we seem to have ;)
23:39:41 <inimino> heh
23:39:57 <luqui> man... that made me sound like a sleazy word-wrangling philosopher.  I take it back.
23:40:11 <Cale> We construct ways of predicting what we'll see, and we throw out the ones which don't seem to work and we keep the ones which do until they don't work anymore.
23:40:34 <dancor> actually upgrading cabal includes cabal-install apparently
23:40:44 <inimino> Cale: so you would define 'true' in terms of useful predictions, then
23:40:55 <Cale> inimino: in that context, yeah.
23:41:01 <luqui> I'll just stick to my religion: I have a personal relationship with our lord and savior, the untyped lambda calculus.
23:41:02 <inimino> s/useful/accurate/
23:41:03 <Cale> In mathematics, it has nothing to do with that, of course.
23:41:18 <Cale> useful is the right word
23:41:24 <copumpkin> @remember luqui I'll just stick to my religion: I have a personal relationship with our lord and savior, the untyped lambda calculus.
23:41:24 <lambdabot> Good to know.
23:41:35 <FunctorSalad> there are still some assumptions there though... for example, that the language in which you make the prediction has a meaning blah blah
23:41:38 <dancor> choosing axioms is still kind of like that
23:41:49 <Cale> FunctorSalad: Sure, lots of them.
23:41:56 <FunctorSalad> it's all a circular soup
23:41:57 <Saizan> dancor: oh, when i say "upgrading" i mean cabal install foo after a cabal update, "cabal upgrade" should never be used imo
23:42:14 <dancor> ya i've never used cabal upgrade
23:42:55 <Cale> FunctorSalad: We have systems of statements and truths, we have interpretations of those statements which guide our behaviour, and none of these things is in any way absolute, and we can always change it.
23:43:39 <Cale> The various notions of truth are human inventions, as far as I'm concerned
23:43:51 <FunctorSalad> Cale: yet some patterns seem a lot more persistent then others (of course this idea breaks down too if you go to the most skeptical level)
23:43:54 <Cale> and they are as good as they are useful to us, for any definition of useful that you'd like
23:43:56 <kulakowski> All logic and math is human invention.
23:44:22 <kulakowski> Or at least our expressions of it.
23:44:32 <FunctorSalad> Cale: maybe "objective" is more related to intra-personal vs. inter-personal, even if "persons" are just stuff in our model as well
23:44:54 <Cale> People were actually killed over the matter of whether the Earth goes around the Sun or if it's the other way around. Of course both are true, just usually not at the same time ;)
23:45:00 <dancor> if persons are just stuff it's my model not our model
23:45:03 <FunctorSalad> like we'd say it isn't objectively true that vanilla is the best flavour of ice cream or something
23:45:23 <FunctorSalad> the point is that it differs between persons, no matter whether there's a "real world" or not
23:45:28 <kulakowski> ugh. i was sure i actually read at least a quote of grothendieck about having nice categories, but it's the sort of thing that's about impossible to google for :/
23:45:47 <FunctorSalad> kulakowski: I think it was on Ronnie Brown's page
23:46:02 <Cale> FunctorSalad: yeah, you can redefine 'objective' to mean something more reasonable too.
23:46:26 <Cale> FunctorSalad: But I think the standard meaning is something a little more unreasonable than that :)
23:46:53 <Cale> objective = most humans agree on it
23:47:37 <FunctorSalad> dancor: but how do you know you're seperate from others? :D
23:48:39 <FunctorSalad> the distinction seems more like a survival device than a fundamental part of nature
23:49:12 <Cale> How do you know that you're not separate from yourself? :)
23:49:27 <Cale> Aren't we just big colony organisms?
23:49:43 <dancor> i think the general thinking these days is that the brain is pretty separate from itself
23:50:59 <luqui> that definition of objective rules out major changes in thought.  galileo's observations were objective by today's standards, but not by his time's...
23:51:02 <dancor> but that's a separate discussion
23:52:01 <FunctorSalad> I'd say "objective" comes in degrees, rather than being binary
23:52:56 <FunctorSalad> hmm that doesn't make much sense without a working definition of it
23:53:03 <dancor> i never really got the connection between ayn-rand/terrible-person objectivism and metaphysical objectivism
23:53:53 <Saizan> well, the working definition is the scientific method, no?
