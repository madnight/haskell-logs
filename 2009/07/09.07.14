00:00:04 <mmorrow> copumpkin: have you ever used happy before?
00:00:12 <mmorrow> (or yacc)
00:00:26 <copumpkin> I feel like there must be some hidden elegant way of editing grammars... we have composition working, but something like conal's semantic editors for selecting particular productions in a grammar and making small changes would be awesome
00:00:30 <copumpkin> not sure how it would work though :)
00:00:53 <copumpkin> mmorrow: never happy, but have done a fair amount with yacc and the other mainstream ones like bison and antlr
00:00:58 <mmorrow> copumpkin: it took me a while to figure out how LALR works, but once you do it's a breeze
00:01:06 <mmorrow> oh nice
00:01:20 <copumpkin> yeah, antlr wouldn't help me there :)
00:02:01 <mmorrow> the pita is when you have to make all these extra productions to not get shift/reduce errors
00:02:18 <copumpkin> well the changes I'm making are pretty minor really
00:02:26 <copumpkin> not sure I'd encounter any, but I haven't tried yet
00:02:52 <mmorrow> copumpkin: yeah, i tried to mess with haskell-src-exts a while ago before i knew how LALR worked, and like 2 changes did:
00:03:01 <mmorrow> about 8 shift/reduce errors ->
00:03:10 <copumpkin> ack :)
00:03:13 <copumpkin> what were you changing?
00:03:15 <mmorrow> 60 reduce/reduce, 190 shift/reduce
00:03:41 <mmorrow> i don't even remember, but it was clearly a braindead (wrt LALR) thing to do i guess :)
00:03:54 <copumpkin> :)
00:03:58 <soupdragon> on the bright side thats easier to debug than shift/reset errors
00:04:09 <copumpkin> we need edwardk's magic monoid parser library!
00:04:22 <copumpkin> PuffTheMagicMonoid
00:04:36 <mmorrow> happy can spit out this nice summary of all the rules and where exactly each conflict is too, which is nice
00:05:53 <copumpkin> cool
00:06:05 <copumpkin> I'm thinking of basically adding the syntax that BSP mentioned in his blog post about this
00:06:26 <copumpkin> http://blog.omega-prime.co.uk/?p=61 that one
00:06:50 <copumpkin> the one thing I won't attempt with a preprocessor is to allow creating instances of context synonyms
00:06:56 <copumpkin> which seems like the only hard bit of all this
00:07:34 <mmorrow> interesting
00:08:13 <mmorrow> yeah, with all this talk of preprocs lately, i want to write one too ;)
00:08:51 <copumpkin> it seems like a lightweight way to add features to the language :P
00:08:55 <copumpkin> I'm really liking she
00:09:29 <ski> Cale : istr PLT highlights differently, depending on binding status
00:18:59 <ivanm> mmorrow: yeah, that hack was the only thing I could really think of :s
00:19:15 <copumpkin> ivanm: ?
00:19:24 <Yrogirg> Hello! when I compile my program with -prof -auto-all option and then run it with +RTS -p it runs ~4 times faster than without profiling. What does it mean and what +RTS options can speed up computation? Any manual?
00:19:48 <ivanm> copumpkin: in response to a @tell
00:20:00 <copumpkin> ah :)
00:20:04 <ivanm> copumpkin: basically, it was that the only way to force a new line in PrettyPrint is text "\n"
00:20:12 <mmorrow> ivanm: ooh, i sucked it up and wrote a "prepunctuate" yesterday (it's trivial but i'll paste)
00:20:13 <copumpkin> ew :)
00:20:29 <ivanm> Yrogirg: ummmm..... that's weird...
00:20:33 <ivanm> which optimisation flags are you using?
00:20:58 <Yrogirg> O2 and compile via c with O2
00:21:02 <mmorrow> gah, i've been hacking around in so many different modules at once lately, i've started to forget where i wrote anything in particular..
00:21:05 <Yrogirg> ghc 6.8.2
00:21:13 <ivanm> mmorrow: heh
00:21:18 * mmorrow pulls out grep
00:21:28 <ivanm> Yrogirg: hmmmm... -O2 should pretty much do it all...
00:21:46 * ivanm normally uses ghc -O2 -funbox-strict-fields
00:21:58 <ivanm> Yrogirg: any particular reason for -fvia-C ?
00:22:25 <Yrogirg> ~10-20% faster
00:22:38 <ivanm> are you doing a lot of floating point calculations?
00:23:02 <Yrogirg> and -fexcess-precision to
00:23:11 <Yrogirg> yes, a lot
00:23:21 <mmorrow> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6959#a6959
00:23:46 <ivanm> Yrogirg: OK, that makes sense then
00:23:57 <ivanm> Yrogirg: which architecture are you using?
00:24:14 <Yrogirg> x86 pentium 4
00:24:24 <mmorrow> Yrogirg: it probably would be worth it to compare the asm
00:24:34 <ivanm> mmorrow: why do you have the [x] case for go?
00:25:03 <mmorrow> ivanm: oh crap, you're right
00:25:07 * ivanm ended up defining firstOthers f o [] = []; firstOthers f o (a:as) = f <> a : map ((<>) o) as
00:25:09 <mmorrow> err, wait i can't remember now
00:25:10 <ivanm> mmorrow: heh
00:25:25 <mae> any way around the FD_SETSIZE limit imposed by the io manager?
00:25:31 <mae> : \
00:25:38 <mmorrow> ivanm: yeah, that's a bug
00:25:39 <mae> i want more open files!
00:25:45 <ivanm> Yrogirg: how are you timing the runs?
00:26:23 <Yrogirg> just run it with time before the command
00:26:33 <ivanm> I liked this blog post: http://zedshaw.com/blog/2009-07-13.html
00:26:40 <ivanm> Yrogirg: and profiling was definitely faster?
00:26:50 <ivanm> it should take about twice as long... >_>
00:26:53 <Yrogirg> ~4 times
00:27:06 <mmorrow> mae: do you literally need more than 1024 fd's open at once, or are they just not getting closed because you're using e.g. hGetContents?
00:27:07 <ivanm> oh, I thought you said it was _faster_ with profiling?
00:27:17 <Yrogirg> yes faster 4 times
00:27:34 <mae> mmorrow: well i'm stress testing happstack + sendfile
00:27:35 <Yrogirg> ~2 min versus ~8 min
00:27:38 <mmorrow> mae: if the latter, that can be fixed by not using lazy IO *or* by forcing the entire result of each hGetContents
00:27:53 <mae> the performance  is excellent so far, but when i pump the concurrency up for the files, I run into that limit
00:28:05 <ivanm> Yrogirg: are you compiling with profiling support even when you're not profling?
00:28:12 <mae> i can push up the open file limit but yeah -- this is a limitation
00:28:24 <mmorrow> mae: iirc happs (not sure about happstack) used ByteString.Lazy.hGetContents on the Handle gotten from socketToHandle
00:28:48 <mae> mmorrow: yeah, but i'm talking about the dev version (I am working on the next version)
00:28:51 <mmorrow> not sure if that is relevant here though..
00:28:59 <mae> specifically for file serving
00:29:03 <Yrogirg> no. But now I'll try to compile with profiling but run without -p option
00:29:20 <mae> I mean, I could start sharing handles i guess
00:29:28 <mae> for the same file
00:29:32 <mae> but this is kind of a workaround
00:29:47 <mmorrow> mae: cool, bos/tibbe were/are? working on adding the ability to optionally use epoll/kqueue whatever to the IOManager, but i'm not sure the status of that
00:29:50 <ivanm> Yrogirg: how big is your code? can you paste it up somewhere so I can have a look?
00:30:24 <mmorrow> mae: that's the only solution to >1024 fd's open i think
00:30:27 <mae> mmorrow: yeah i talked to tibbe, so i guess i will settle with the hohumness of the io manager for now
00:30:33 <mae> i mean
00:30:52 <mmorrow> select()
00:30:53 <mae> 188 concurrent connections is doable with a 1.7mb file (on my local machine) without breaking a sweat
00:30:58 <mae> using httperf
00:31:10 <mae> and thats with letting the garbage collector close the handle
00:31:23 <mae> explicitly closing the handle doesn't seem to yield much better results
00:31:45 <mae> perhaps file handle sharing is worthit
00:31:45 <Yrogirg> it is really big. Molecular simulation program. May be it is important that I'm using concurrent haskell to have control on the execution (stop it when I need)
00:32:13 <mmorrow> mae: good luck, that'd be cool to hear about your results
00:32:17 <ivanm> Yrogirg: "concurrent haskell"? which concurrency stuff?
00:32:48 <mae> mmorrow: right, i mean the pragmatic approach would be to use lighty/nginx/apache for file serving :) but i want to be able to do that with similar perf right in haskell
00:33:09 <mmorrow> mae: for sure.
00:33:35 <copumpkin> fo shizzle
00:33:46 <ray> for shizzle
00:34:19 <Yrogirg> forkIO, newEmptyMVar to stop the programm by keypress and save some data to make possible to resume to computation later
00:34:19 <mae> even the results thus far seems to yield about a 500 percent performance increase over the native bytestring implementation (speaking of my sendfile lib)
00:34:26 <mae> this is with a 1.7 mb file
00:34:34 <mae> i imagine with a larger file it would be even more of a contrast
00:34:40 <mmorrow> mae: ooh, interesting
00:34:53 <mmorrow> mae: what does sendfile do?
00:35:01 <mmorrow> mmap cacheing or something?
00:35:05 <mae> mmorrow: it is a kernel-mode call
00:35:12 <mmorrow> ah, hmm
00:35:14 <mae> basically instead of buffering / copying the file in memory
00:35:20 <mae> the kernel sends directly from the handle to the socket
00:35:26 <mae> no extra copy necessary
00:35:27 <mmorrow> oh i see, cool
00:35:30 <mae> also helps with memory efficiency
00:35:42 <mae> invaluable for large files
00:36:07 <mae> but it also requires you to hand it a file descriptor
00:36:11 <Yrogirg> I've run the profiled compiled program without -p option and it still 4 times faster
00:36:16 <mae> hence the bottleneck of the open files
00:39:32 <ivanm> Yrogirg: re-compile it again without the profiling stuff, and check
00:39:42 <ivanm> with the same optimisations
00:39:55 <ivanm> it could be you had some files that were optimised and some that weren't... >_>
00:43:24 <kayess> Just wondering about these combinators again. It seems to me that the combinator names, S, K, B, Y etc. are all totally standardised, so it would seem reasonable to have a "combinator" library that just has these in it?
00:45:18 <mmorrow> kayess: they all exist (more or less) in some form already in various places, but sure that would be neat to have a SKI module
00:45:50 <ivanm> mmorrow: bugger, pretty-ncols only has asColumns... I want asRos :s
00:45:53 <ivanm> *asRows
00:46:14 <mmorrow> is pretty-ncols a hackage pkg?
00:46:39 <kayess> This is actually for a new language, but it's quite heavily influenced by Haskell
00:46:53 <mmorrow> ivanm: ah found it
00:47:06 <ivanm> dammit, and they make each column the same width, which I don't want :@
00:47:09 <ivanm> anyway... dinner time
00:47:31 <mmorrow> ivanm: looks like you have some hacking todo :)
00:47:43 <sjanssen> kayess: I think s, k, i etc. aren't particulary great names to use in an actual library
00:48:04 <mmorrow> kayess: also note that you have to use `fix' for `y'
00:48:24 <kayess> I've seen other names, like kestrel etc. Are those better function names then?
00:48:25 <mmorrow> (unless you want to start newtyping everything in sight)
00:48:51 <mmorrow> fix f = let x = f x in x
00:49:25 <kayess> That syntax always looks odd to me with those two = signs in there :)
00:49:38 <soupdragon> yeah
00:49:39 <sjanssen> kayess: I see two problems with the names: they aren't descriptive, and they're useful variable names
00:49:53 <sjanssen> eg. 'i' is the universal standard variable for any sort of index
00:50:11 <kayess> In the syntax of this lanugage (such as it is) they would look like "/lib/combinator/K" -- the language has no variables so there's no clash there :)
00:50:17 <kulakowski> a problem easily fixed by mandating pointfree style
00:50:24 <jkff> sjanssen: Although it is not nearly as ubiquitous in Haskell as in other languages :)
00:50:33 <sjanssen> kayess: ah, if you don't have variables ...
00:50:38 <kayess> It is sort of point free, but I'm not sure yet how well that will work in across everything
00:50:41 <sjanssen> the first point still stsands
00:51:11 <kayess> Each of them would always have the full "combinator/K" or "combinator/S" names
00:51:36 <sjanssen> "combinator/K" is still a meaningless name if you don't have the right education
00:51:40 <soupdragon> whats the language?
00:52:06 <soupdragon> everyone knows what K is
00:52:08 <kayess> It's called Urquell -- The two of us working on it suspect it's actually a joke, but it might just be useful in some contexts
00:52:34 <soupdragon> and the actual language?
00:52:56 <gfreeman> have you looked at unlambda?
00:52:59 <Yrogirg> ivanm: I've recompiled and without profiling it is slow (btw I always use -fforce-recomp). I'll archive the program and send it somehow to you to check. may be newer versions of ghc are more predictable.
00:53:38 <kayess> The language has no syntax -- it's all made up of URLs. Every program is a URL
00:54:06 <copumpkin> :o
00:54:30 <copumpkin> Yrogirg: why do you always use fforce-recomp?
00:54:35 <sjanssen> kayess: you may have come up with something more scary-sounding than XSLT!
00:55:11 <kayess> So, here is an addition expression: http://urquell-fn.appspot.com/lib/add/1/2/4
00:55:25 <copumpkin> omg
00:55:34 <kayess> This is an "add" function: http://urquell-fn.appspot.com/lib/fn/urquell-fn.appspot.com/lib/add/1
00:55:38 <kayess> Sorry, increment
00:55:42 <kayess> like (+) 1
00:56:00 <sjanssen> kayess: what is (1 + 2) * (3 + 4)?
00:56:13 <kayess> And you can apply that function like this: http://urquell-fn.appspot.com/lib/call/=1i5HOn/5
00:56:25 <copumpkin> seems like it'd be closer to factor than haskell
00:56:28 <kayess> So, you use the bind name to form sub-expressions
00:56:32 <copumpkin> oh
00:56:37 <kayess> It isn't stack based at all
00:56:43 <copumpkin> ah
00:57:28 <mmorrow> haha, i thought you were joking with the "everything is a url" :)
00:58:28 <gfreeman> but it can't be turing complete then -- url's have a maximum length
00:58:29 <kayess> This is the expression (1+2)*(3+4): http://urquell-fn.appspot.com/lib/mul/=Y+1Prg/=MN+9Fl
00:58:30 <Yrogirg> copumpkin: because I often used to change modules in use (e.g. the cell configuration (cube, rhombic dodecahedron), potential (Lennard-Jones truncated, truncated and shifted)). And sometimes no force recompiling in such cases lead to bad effects.
00:58:32 <kayess> Gives a value of 21
00:59:14 <kayess> I guess it should be possible to have it as turing complete as any other language with finite resources
01:00:10 <kayess> So I figure if I add the S, K and I combinators to the library then it ought to be turing complete in some sense at least
01:00:34 <gfreeman> Right, but if the program length is limited to the url... you see how that works.
01:00:41 <pragma_> where does MN and 9FI, etc, come from?
01:00:45 <kayess> For sure
01:00:59 <mmorrow> kayess: what about a program's input?
01:01:03 <kayess> But for the sorts of things that people might actually use it for, I don't thnik that really matters
01:01:06 <mmorrow> (or output)
01:01:17 <mmorrow> is there any concept of that?
01:01:20 <kayess> inputs are JSON fetched from some other URL. That's what the bind hash is
01:01:26 <kayess> And the outputs are JSON
01:01:38 <kayess> The binding code is a short form of the URL
01:01:44 <mmorrow> kayess: if you can write a brainfuck interp, you're turing complete..
01:02:18 <kayess> So, after each application of any of the combinators you'd get back a short hash that can be used in place of the longer URL. I think that probably takes care of the URL limit
01:02:39 <kayess> But I'm not sure. Would have to write them and play with them a bit
01:02:59 <mmorrow> it seems to me it'd be easier to write a compiler /from/ whatever (say ski) to this lang
01:03:12 <mmorrow> rather than try to write in it to begin with
01:03:36 <kayess> Could be. We're building a Google Wave robot that will act like an IDe for the language helping you to write it
01:03:45 <mmorrow> hehe, nice
01:04:06 <kayess> And I think most programs would just be a few expressions -- grab some JSON from a URL, manipulate it in a few ways and then return it
01:04:20 <kayess> Could be useful in AJAX and for making mashups etc.
01:04:45 <kayess> Or it could all be a silly joke. We're not sure yet :)
01:05:12 <gfreeman> So, I've got a question here, if anyone wants to give me a hand
01:05:14 <mmorrow> it seems to me that just encoding js into some form and sending it as http://..../?eval_this=SDDsw33523DAQdwda2
01:05:20 <sohum> Why am I getting an invalid type signature for (foo) :: (Num a) => a -> a -> a
01:05:27 <mmorrow> eval(decode)(input_stuff)
01:05:29 <mmorrow> oops
01:05:32 <kayess> That seems far too practical :)
01:05:41 <mmorrow> eval(decode('SDDsw33523DAQdwda2'))(input_stuff)
01:05:41 <copumpkin> alright, bedtime
01:05:44 <mmorrow> heh, true
01:05:46 <mmorrow> night
01:06:20 <doserj> sohum: remove the paranthese around foo
01:07:34 <gfreeman> okay, I'll just throw it out there: I seem to be writing "fmap (map read . words) getLine" pretty often, and performance seems to suffer for it. How can I do this better?
01:08:00 <mmorrow> gfreeman: maybe just (read . words)
01:08:24 <mmorrow> where the type of read is String -> [what you were reading before
01:08:25 <mmorrow> ]
01:08:26 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
01:08:56 <sjanssen> gfreeman: what type are you reading in?
01:09:12 <mmorrow> gfreeman: but `read' isn't really for "high performance" stuff though
01:09:33 <mmorrow> gfreeman: so if you really need speed you may want to look for other options
01:10:12 <gfreeman> usually I'm "read"ing Ints, and then doing a fold... so someone said ByteString?
01:11:09 <mmorrow> ByteString would be faster i'd say (if the input is big)
01:11:11 <sjanssen> gfreeman: yeah, ByteString has some fast read functions for Int
01:13:50 <gfreeman> okay, now I'm wondering why I've been ignoring ByteString for so long
01:14:09 <gfreeman> it looks like a good portion of the Prelude is rewritten in the module
01:17:05 <gfreeman> sjanssen: what are these functions for reading ints from ByteStrings?
01:17:26 <sohum> doserj: I want foo to be infix
01:17:56 <gfreeman> sohum: `foo`
01:18:17 <sohum> gfreeman: rephrase: I want to /define/ foo as infix
01:18:27 <doserj> sohum: alphanumeric identifiers are always prefix
01:18:35 <gfreeman> sohum: I don't think that would be valid syntax
01:19:40 <sohum> doserj: http://www.haskell.org/haskellwiki/Constructor says "You can declare a constructor (for both type and data) to be an infix operator"
01:20:25 <maartenm> is it possible to make guards that "fall through" to the next guard? suppose you have two guards which may be true
01:21:31 <doserj> sohum: I'm not sure what that sentence is actually trying to say.
01:21:35 <svqyqb> http://tinyurl.com/nkypfa
01:22:37 <sohum> doserj: I assumed it meant that you could do the same as defining functions to be infix
01:22:47 <ski> sohum : probably it is supposed to be saying that you can declare constructors which are infix operators
01:23:31 <mmorrow> lol
01:23:34 <mmorrow> "-- this function makes me want to kill wittle hewpless bunny wabbits"
01:23:52 <ski> (for data constructors that is either by using a symbolic name which starts with `:', or by wrapping the name in backticks .. for type constructors i'm not sure, but possibly it is the same rules)
01:25:19 <sohum> ski: what's this "starts with :" thing?
01:25:40 <ski>   data Foo = Int :+-*/ Bool
01:26:05 <ski> then `(:+-*/)' is a data constructor, with type `Int -> Bool -> Foo'
01:26:42 <sohum> including the initial :, I take it
01:26:46 <ski> yes
01:26:51 <sohum> huh. is there documentation on this?
01:27:04 <ski> cf. the apocryphal `data [] a = [] | a : [] a'
01:27:11 <doserj> infix type constructors are a ghc extension. data constructors are just functions, so they follow the same infix/prefix rules as other functions
01:27:18 <ski> i would imagine the Haskell Report mentions this somewhere ..
01:27:51 <sohum> doserj: you'd assume that, but trying to define them as infix as you can with normal functions doesn't work
01:28:24 <ski> sohum : elaborate on "define them as infix as you can with normal functions" ?
01:28:48 <sohum> ski: as in, (foo) :: Int -> Int -> Int
01:29:05 <ski> that in no way makes `foo' infix
01:29:22 <sohum> huh. you're right, it doesn't.
01:29:28 <sohum> why did I think it does?
01:29:32 <ski> > let (foo) :: Int; foo = 42 in foo
01:29:34 <lambdabot>   <no location info>: Invalid type signature
01:30:06 <ski> (it wasn't even valid syntax, as i assumed it wasn't)
01:30:13 <mmorrow> , 4 `elem` [0..9]
01:30:14 <sohum> it works with symbols, though
01:30:16 <lunabot>  True
01:30:20 <ski> no
01:30:29 <ski> it doesn't "work" with symbols
01:30:34 <mmorrow> , (+) 1 2
01:30:35 <lunabot>  3
01:30:38 <mmorrow> , + 1 2
01:30:39 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a))
01:30:44 <mmorrow> , 1 + 2
01:30:45 <lunabot>  3
01:30:47 <ski> symbolic identifiers are always infix
01:30:48 <mmorrow> , 1 `(+)` 2
01:30:49 <lunabot>  luna: parse error on input `('
01:30:54 <sohum> aaah
01:31:01 <ski> you turn them into an expression by wrapping in brackets
01:31:08 <mmorrow> (parens)
01:31:16 <sohum> right, that makes sense
01:31:23 <ski> and the `::' operator requires (more or less) an expression to the left
01:31:52 <ski> (round brackets, yes)
01:32:10 <shachaf> ski: An expression?
01:32:21 <ski> > 42 :: Int
01:32:23 <lambdabot>   42
01:32:35 <ski> (shachaf : also note the "(more or less)")
01:33:00 <mmorrow> , let <> :: Int; (<>) = 42
01:33:01 <lunabot>  luna: parse error on input `<>'
01:33:05 <mmorrow> , let <> :: Int; (<>) = 42 in (<>)
01:33:06 <lunabot>  luna: parse error on input `<>'
01:33:09 <shachaf> Oh, that ::.
01:33:10 <mmorrow> , let (<>) :: Int; (<>) = 42 in (<>)
01:33:11 <lunabot>  42
01:33:21 <shachaf> Er, /me was confused.
01:34:02 <mmorrow> *was* not *is*, right?
01:34:35 <shachaf> mmorrow: Yes, until you said that.
01:34:38 <ski> shachaf : there is a distinction between type ascription, and type signature .. but here i wanted to blur the distinction between expressions,patterns (and lhs of type signatures)
01:35:02 <shachaf> ski: Yes, I was thinking of one and not the other.
01:35:38 <mmorrow> shachaf: oh heh, you are the same color as sohum, and i didn't even notice the s/sohum/shachaf/ switch
01:35:42 <ski> (ergo, i wanted to blur the distinction between type ascription, and type signature)
01:36:30 * ski notes that everyone is colored white, except me
01:36:41 <shachaf> ski: I'm yellow, no?
01:36:49 <mmorrow> ski: wow, you xchat is borked ;)
01:36:55 <mmorrow> @quote xchat
01:36:55 <ski> well, everyone, most of the time :)
01:36:55 <lambdabot> xchat says: colorOf nick = let rcolors = [19, 20, 22, 24, 25, 26, 27, 28, 29]; n = sum (fmap (min 255 . ord) nick) in rcolors !! (n `mod` length rcolors)
01:37:06 <mmorrow> (that's from the newest xchat src)
01:37:16 <mmorrow> @let colorOf nick = let rcolors = [19, 20, 22, 24, 25, 26, 27, 28, 29]; n = sum (fmap (min 255 . ord) nick) in rcolors !! (n `mod` length rcolors)
01:37:17 <lambdabot>  Defined.
01:37:19 <shachaf> mmorrow: Xchat is written in Haskell?
01:37:28 <mmorrow> shachaf: i transcribed it from C
01:37:32 <shachaf> Aw. :-(
01:37:35 <mmorrow> heh
01:37:43 <mmorrow> > colorOf "shachaf"
01:37:44 <shachaf> Would almost have been enough to get me back from irssi.
01:37:45 <lambdabot>   28
01:37:48 <mmorrow> > colorOf "sohum"
01:37:50 <lambdabot>   28
01:37:54 <mmorrow> > colorOf "mmorrow"
01:37:56 <lambdabot>   25
01:38:04 <mmorrow> ski is yellow
01:38:07 <mmorrow> > colorOf "ski"
01:38:09 <lambdabot>   24
01:38:16 <mmorrow> what color am i?
01:38:31 <mmorrow> (you're always grey in xchat)
01:38:34 <elbar> grey, like everyone else too ;)
01:38:53 <elbar> irssi 4tw :P
01:39:22 <Peaker> xchat being in C is pretty annoying.  Making any minor change is overly complicated
01:39:25 <Yrogirg> ivanm: To sum up I've asked the question in haskell-cafe.
01:43:25 <mmorrow> PeakerWork: i used ircii before xchat, and although it was in C it was super-short and easy to mess with.
01:43:46 <mmorrow> (that was before i knew haskell though too, ..)
01:43:54 <mmorrow> someone should write a haskell irc client
01:43:57 <Peaker> mmorrow: I think C is pretty much guaranteed to be 5 times longer than equivalent Haskell or Python or such
01:44:04 <Peaker> usually more
01:44:05 * ski str Hircules
01:44:30 <mmorrow> Peaker: yeah, at the very minimum i'd say 2x as long
01:45:29 <Peaker> mmorrow: also depends on the mojo of the C/Haskell programmers, of course :)
01:45:29 <sayyestolife> I'd say about 9000x longer
01:45:48 <mmorrow> heh, true
01:46:18 <mmorrow> oh yeah, on this topic, so i built and was messing around with bitc the other day...
01:46:54 <Peaker> mmorrow: so, how is it?
01:47:21 <mmorrow> couldn't really figure out how exactly to build a stand-alone prog with "main" (the examples seemed to work, but i couldn't friggin figure out why when i tried to write a minimal one myself, i would get "not in scope bitc_main" ??)
01:47:43 <mmorrow> also, compiling any program takes like 10 seconds (i guess because it's whole-program??)
01:47:54 <mmorrow> i don't know what it could be doing, but it's definitely doing something
01:48:10 <Peaker> they're using rsync for source control? :)
01:48:34 <mmorrow> also, since i'm not very familiar with scheme syntax, it was slightly painful to figure out how to do anything non-trivial
01:49:00 <shachaf> mmorrow: If you use a GUI IRC client, does that mean that you disconnect from IRC when you turn off your computer?
01:49:10 <shachaf> (Please forgive the vague phrasing.)
01:49:44 <mmorrow> shachaf: yes, although i could use the gui client on a remote machine that's always on and vnc to it
01:50:16 <shachaf> mmorrow: And send every pixel over... It would be horribly slow.
01:50:31 <Peaker> or an IRC client can have a backend running whereever and a front end GUI..
01:50:35 <zsol> any guesses about which module is the function "on" in? Can't seem to find out its signature
01:50:38 <shachaf> Even irssi over ssh is noticeable.
01:50:42 <shachaf> Peaker: Yep, that's what I want.
01:50:43 <mmorrow> if you've got a decent internet connection vnc is definitely bearable
01:50:54 <Peaker> though if done right, the "backend" would be the IRC server itself
01:50:57 <shachaf> zsol: Data.Function.
01:50:59 <zsol> thanks
01:51:06 <Peaker> so the only thing that's "missing" is having history available from the ircd in the GUI
01:51:38 <zsol> awesome :]
01:51:44 <shachaf> Peaker: Well, sort of. There is more state than that, usually.
01:52:09 <Peaker> shachaf: well, a list of joined channels, their history, perhaps some commands history, what else?
01:52:23 <Peaker> shachaf: if you could query those from the ircd, it would seem to be complete?
01:52:34 <mmorrow> if you're writing the client/server yourself i don't see how any of this would be an issue..
01:52:39 <shachaf> Hum.
01:52:53 <shachaf> mmorrow: Peaker is saying that all the state should be stored on the ircd.
01:53:11 <shachaf> There are all sorts of client-specific settings, though.
01:53:24 <Peaker> you could serialize them into the user's data, e.g: via nickserv
01:53:26 <mmorrow> shachaf: sounds logical, then the client could just ask the server to give it some when it needs that bit
01:53:32 <Peaker> or maybe a new serv for this kind of stuff
01:53:41 <mmorrow> (you'd need to come up with some protocol for this though)
01:53:42 * shachaf thinks all software should be written this way.
01:53:48 <Peaker> mmorrow: a new serv like nickserv/etc
01:53:59 <mmorrow> hmm
01:54:12 <shachaf> In fact, we should all use NeWS!
01:54:19 <Peaker> shachaf: I think ideally, software and data would be migrated to where they best answer the demands of the user, in terms of performance and available
01:54:25 <Peaker> shachaf: (automatically)
01:55:59 <Peaker> how do I build haddock for packages from hackage? When I "cabal haddock" it complains that I miss docs from other packages
01:56:08 <Peaker> And you can't "cabal haddock <name of package>"
01:56:17 <Peaker> do I have to manually fetch each package?
01:56:36 <lpsmith> shachaf:  are you going to write a new news?
01:56:59 <lpsmith> A new gnu news?
01:57:14 <shachaf> lpsmith: Seems unlikely that that could work at this point.
01:57:24 <shachaf> But is it not much nicer than X?
01:57:42 <lpsmith> well, that's what they say.   Never used it myself.
01:58:05 * shachaf has not either.
01:58:37 <lpsmith> I don't like X though.  I hope Google OS offers a viable replacement for X on general linux systems,  and not just their browser-only thingy.
01:58:45 <doserj> Peaker: that should give only warnings, not errors
01:58:57 <Peaker> doserj: but I do want the docs of these packages
01:59:19 <doserj> Peaker: well, then you have to build them, I guess
02:00:36 <mmorrow> Peaker: but yeah, i really like the idea of bitc, but currently i couldn't use it for a project because (1) the scheme syntax, (2) it takes a really long time to compile, and (3) there aren't any docs that address practical issues like "how to compile a hello-world program"
02:00:57 <mmorrow> there's a full language spec though..
02:01:25 <Saizan> Peaker: even if you miss the docs for the deps it still builds the docs for the current package
02:02:20 <Saizan> Peaker: it just can't link the symbols imported back to their docs
02:02:28 <doserj> Peaker: you can set documentation: True in ~/.cabal/config, to build the documentation automatically during install
02:02:48 <Saizan> Peaker: oh, sorry, doserj already said that
02:03:12 <jakeplay> instead of (none `when` predicate), how do i make an arrow that can keep count of what it has applied?
02:04:13 <Saizan> jakeplay: you want to count how many elements satisfy the predicate?
02:04:35 <Peaker> Saizan: why isn't haddock docs installation just like lib/bin installation, into a common place?
02:04:42 <Peaker> doserj: oh, cool
02:04:52 <Saizan> Peaker: it is in a commond place
02:05:56 <jakeplay> Saizan, e.g. processing xml using hxt, i want to extract a template, clear out its value, repopulate and replicate and replace existing entries
02:07:00 <jakeplay> say if there are 3 <jars>, want to update with 5 <jar> from the cabinet
02:07:12 <jakeplay> updating the content of the jars
02:07:31 <Saizan> and?
02:08:14 <jakeplay> i have been using processChildren (none `when` hasName "jar") to clear out all the jars
02:08:41 * mmorrow just joined #bitc as a longshot... it doesn't exist
02:08:57 <Peaker> rsync still downloading bitc
02:09:01 <jakeplay> i have a new list say ["apple", "mango", "anchovies", "raison", "beef jerkey"]
02:09:03 <Peaker> I wish they used git or something
02:09:06 <Peaker> on github
02:09:10 <mmorrow> Peaker: heh, yeah rsync too :/
02:09:10 <taruti> hoogle is down?
02:09:49 <mmorrow> Peaker: that'd be cool if the compiler was rewritten in haskell too ... ;)
02:09:49 <jakeplay> was trying to use replaceChildren to extract a single entry of the previous <jar>s, and then map over the list
02:10:17 <mmorrow> (instead of C++)
02:10:50 <mmorrow> imo (now that i know haskell) C/C++ are way too low-level to be writing compilers in
02:11:12 <Peaker> mmorrow: How long have you known Haskell?
02:11:26 <jakeplay> so instead of (one `when` has "jar"), what would be the equivalent of (_first_ `when` hasName "jar")
02:11:40 <mmorrow> Peaker: hmm, i'd say just under two years now
02:12:09 <mmorrow> Peaker: (but i've been using it every day for about a year and a half..)
02:12:19 <Peaker> mmorrow: what are you using it with?
02:14:15 <mmorrow> Peaker: for the last 2+ years i've been doing "independent contractor" stuff with anyone that'd hire me, and ended up doing a ton of work for this one insurance company actually, and i switched to using haskell exclusively about a year+ ago. in the last few months though i haven't been doing too much of that work, but've been writing this interpreter almost exclusively
02:14:59 <mmorrow> so learning haskell well kinda became an immediate necessity you could say.. ;)
02:15:42 <Saizan> jakeplay: i think you rather want to collect all the jars in a list with listA (getChildren >>> hasName "jar"), so that you can get an equivalent number of them from your list to substituite
02:17:49 <jakeplay> Saizan: what baffles me is that when i go from a situation when i want to "substitute" a list of 3 with a list of 5
02:18:33 <jakeplay> sub 3->3 is straightforward, it feels like i am approaching the problem incorrectly
02:19:41 <jakeplay> hmmm, or do i consider 3->5 a function?
02:20:36 <Peaker> mmorrow: cool, interpreter of what?
02:20:58 <mmorrow> Peaker: the aim is to be able to support any lazy functional language
02:21:01 <Peaker> jakeplay: a list of Ints that all happen to be 3 you mean?
02:22:13 <jakeplay> Peaker: replacing a list of 3 items with a list of 5 items
02:22:18 <Saizan> jakeplay: ah, in that case "processChildren ((none `when` hasName "jar") <+> catA (map constA listOfNewJars))" maybe?
02:22:21 <mmorrow> Peaker: i'm aaaallmost got everything working, from input of a stripped-down haskell-like language through 4 stages of ASTs, and finally to bytecode that is interpreted by a C runtime (which is minimally working, i.e. interp/GC/etc)
02:22:28 <Saizan> jakeplay: i should test it to be sure
02:23:04 <Peaker> mmorrow: what's the ultimate goal?
02:23:17 <Peaker> mmorrow: what other lazy languages you need besides Haskell?
02:23:25 <jakeplay> Saizan: hmm, let me try
02:23:27 <mmorrow> Peaker: the first thing i want to do once i've finally got the friggin thing up-and-running, is to hook some code i've got that translates ghc's ext-core into the interpreters input syntax, so it can act as a backend
02:23:45 <mmorrow> Peaker: heh, they haven't been invented yet! :)
02:24:09 <Peaker> business or pleasure? :)
02:24:20 <sayyestolife> I'm even lazier than Haskell.. Does that count?
02:24:53 <mmorrow> Peaker: the ultimate goal is to have an interpreter/runtime that is independent of any particular language/compiler, that can freeze the entire state of the system and write it to a file/be resumed from a file/sent over the network/etc, and that's fast.
02:25:16 <Saizan> jakeplay: or "replaceChildren ((getChildren >>> (none `when` hasName "jar")) <+> catA (constL listOfNewJars))"
02:25:34 <mmorrow> Peaker: it started out as pleasure, but given the amount of work i've put into this, i'm thinking about possibilities for "business" too.
02:26:51 <Peaker> mmorrow: if you're willing to pay some overhead (i.e interpreter) maybe you're also willing to auto-profile stuff and JIT them as necessary, or do automatic CSE and memoizing based on profiling info, etc
02:27:00 * jakeplay looks at the api index again 
02:28:03 <mmorrow> Peaker: totally, i want to look into generating hard-code eventually too. i think they're are a ton of interesting things you could do with something like this
02:28:12 <mmorrow> s/they're/there're/
02:28:19 <mmorrow> gah, you know
02:28:21 <jakeplay> Saizan: let me try
02:28:26 <Peaker> mmorrow: ya
02:28:56 <mmorrow> (you know re: the incorrect correction to "they're")
02:30:04 <mmorrow> Peaker: are you thinking of some other system in particular when you mention JIT/automatic CSE/etc?
02:31:27 <Peaker> mmorrow: No, when I first learned about Haskell I was very frustrated that with all the high-levelness, the programmer still isn't freed from sharing/unsharing names, memoizing stuff, and figured heuristics+auto-profiling could do this reasonably. Maybe even non-heuristics, with regard to preserving some O() cap on time/space complexities
02:32:09 <jkff> Reminds me of how I thought that Prolog is a miraculous automatic theorem prover
02:32:13 <Peaker> mmorrow: the problem is that this profiling and heuristics probably have a constant hit. Though if it puts O() caps, it may be a good trade-off for unoptimized applications
02:32:36 <Peaker> jkff: its not? :-)
02:32:59 <mmorrow> interesting. yeah, i'm really interested in possibilities for runtime-codegen (in various forms, e.g. JIT or who knows).
02:33:05 <jkff> Turns out not :)
02:33:27 <mmorrow> heh
02:33:31 <mmorrow> No.
02:33:51 <jkff> I was very surprised when I learned about the unification with backtracking
02:34:06 <jkff> Ah, good old naive times!
02:35:06 <Peaker> If you study Godel first, there are less disappointments, probably :)
02:35:54 <Peaker> I heard of an alternative proof of Godel's theorem, where you prove there are Aleph(1) propositions, but only Aleph(0) proofs
02:36:07 <Peaker> Or something like that
02:36:09 <jkff> I knew about the undecidability stuff etc., and that's precisely what surprised me so much: I thought, "How can Prolog work at all?". Now I see that the reason is just that it doesn't have 2nd-order unification
02:36:57 <Peaker> I stopped studying Prolog when I learned about the cut/shortcut operators
02:37:01 <jkff> Interestingly, people whom I tell about Haskell seem to also think that is has some laziness magic inside; like, it "works out" which values are needed and which aren't, etc. Same thing with garbage collection for those who aren't familiar with it.
02:38:09 <desp> Does anyone have a copy of the Haskell materials by Jan Skibinski that were hosted on numeric-quest.com?
02:38:16 <Peaker> it does "work it out", it just turns out to be pretty simple :)
02:38:20 <kulakowski> Peaker: There are both countably many propositions and proofs, but I think you could make a proof/argument that any bijection between the two isn't computable/predicative etc.
02:38:25 <Peaker> well, actually it sometimes works it out incorrectly
02:38:27 <quicksilver> jkff: it does work out which values are needed and which aren't, in a sense; that's what GC does in a simplistic way.
02:38:55 <desp> The Wayback Machine gives me a Data Retrieval Failure.
02:39:14 <ski> (Peaker : you might be interested in Mercury, which doesn't have cut (nor side-effects) ..)
02:39:27 <Peaker> ski: thanks, will read about that
02:46:11 <Peaker> can an associated type have a higher kind than *?
02:46:24 <Peaker> this isn't working:
02:46:25 <Peaker> class (MonadPlus l, Monad (ListMonad l)) => List l where
02:46:26 <Peaker>   type ListMonad l :: * -> *
02:47:42 <jakeplay> Saizan: okay, it seems to work, though using getChildren, it loses the parent tag, i think i can fix it
02:47:50 <vinicius> :t type
02:47:52 <lambdabot> parse error on input `type'
02:48:06 <mmorrow> Peaker: maybe if you put "type ListMonad l a"
02:48:15 <Peaker> mmorrow: a is out of scope :(
02:48:19 <mmorrow> ohh, the l
02:48:22 <mmorrow> hmm
02:48:34 <mmorrow> err, i dunno
02:48:43 <Peaker> I'm trying to convert a fundep to a type family, but maybe its not possible in this case
02:49:26 <ivanm> mmorrow: I have a solution...
02:49:30 * ivanm just pastes it up
02:49:48 <soupdragon> what fundep?
02:50:16 <Saizan> Peaker: what error are you getting?
02:50:18 <ivanm> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6962#a6962
02:50:24 <Saizan> Peaker: maybe you need KindSignatures
02:50:44 <Saizan> Peaker: type families of higher kinds are supported
02:50:50 <ivanm> mmorrow: the main problem with it is the amount of whitespace at the end of each line
02:51:13 <mmorrow> ivanm: heh, nice
02:51:37 <mmorrow> ivanm: hmm, you could always (length . dropWhile isSpace . reverse . render)
02:51:42 <Peaker> Saizan: I'm used to getting warnings about the extensions I need, thanks
02:52:05 <soupdragon> @ Peaker
02:52:09 <ivanm> mmorrow: for docLen?
02:52:15 * ivanm stole that from pretty-ncols
02:52:23 <Saizan> Peaker: you could file a ticket for a better error message
02:52:26 <ski> s/\\d -> (d, docLen d)/id &&& docLen/
02:52:34 <Peaker> soupdragon: a monadic list class that had a list type and a monad type with l -> m
02:52:40 <mmorrow> ivanm: err, what are we talking about then?
02:52:43 <mmorrow> "the main problem with it is the amount of whitespace at the end of each line" ?
02:52:58 <mmorrow> (i don't think i'm understanding the context here correctly)
02:53:16 <Peaker> Saizan: good idea
02:53:17 <soupdragon> huh
02:53:49 <ivanm> mmorrow: I'm trying to work out what that length . dropWhile .... is for
02:55:53 <mmorrow> ivanm: your code reminds me vaguely of this code for rendering html tables i quickly hacked yesterday to generate tables for documenting various things  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6962#a6963
02:56:12 <soupdragon> why isn't l = m?
02:56:28 <mmorrow> the relevant part being representing tables as
02:56:36 <mmorrow> data TBody a = Rows [Row a] | Cols [Col a]
02:56:42 <mmorrow> until you finally need to render them
02:56:47 <ivanm> mmorrow: slightly improved version, in that there's less whitespace on the end http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6962#a6965
02:56:52 <mmorrow> err, and data Cell a = Cell Int Int a
02:56:59 <mmorrow> rowspan/colspan are the Ints
02:57:12 <ivanm> span?
02:57:48 <mmorrow> like how many rows/cols that single cell spans
02:58:08 <ivanm> ahhhhh
02:58:24 <ivanm> data {Row,Cell} a = ?
02:58:32 <soupdragon> Peaker
02:58:46 <mmorrow> newtype Row a = Row [Cell a]
02:58:48 <ivanm> mmorrow: oh, you've put it up there
02:58:50 <Peaker> soupdragon: let me paste
02:58:52 <mmorrow> newtype Col a = Col [Cell a]
02:58:53 <mmorrow> heh, yeah
02:59:25 <Peaker> soupdragon: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6966#a6966
02:59:29 <Peaker> soupdragon: sorry for late response
02:59:42 <mmorrow> ivanm: this being the output from "writeTest1" http://moonpatio.com/lem/tables.html
03:00:04 <ivanm> pretty...
03:00:05 <ski> (ivanm : what would `data {Row,Cell} a = ...' mean ?)
03:00:26 <Peaker> soupdragon: the idea is that the instances are:       List []  where ListMonad [] = Identity         and List (ListT m) where ListMonad (ListT m) = m
03:00:29 <ivanm> ski: well, probably shouldn't have used { }
03:00:30 <Peaker> soupdragon: so l /= m
03:00:34 <arnihermann> I'm having problems installing pandoc via cabal install pandoc on mac -- using Haskell Platform, version 2009.2.0.1 on mac leopaard
03:00:41 <Peaker> soupdragon: before it was   class List l m | l -> m where ..
03:00:47 <Peaker> soupdragon: trying to use this associated type instead
03:00:56 <arnihermann> with the error pandoc: ?: openFile: does not exist (No such file or directory), Error creating man/man1/pandoc.1
03:00:56 <ivanm> but I meant what does "data Row a = ..." and "data Col a = ..."
03:00:57 <soupdragon> okay
03:01:06 <arnihermann> and was wondering you guys could point me in the right direction maybe?
03:02:02 <mmorrow> ivanm: what i had in mind for (but haven't written yet) "type Nested a = TBody (Nest Cell TBody a)" is to
03:02:04 <ivanm> arnihermann: hmmmmm...
03:02:06 <ivanm> works here :s
03:02:23 <ivanm> arnihermann: I wouldn't be surprised if it's an OSX thing... >_>
03:02:37 <arnihermann> hehe
03:02:46 <arnihermann> could be
03:03:03 <mmorrow> ivanm: fold the tree bottom-up computing the actual width of each subtable, eventually arriving at a single table with all the trees of subtables of subtables of ... flattened
03:03:13 <soupdragon>         arising from a use of `return' at src/Data/List/Class.hs:206:6-11
03:03:19 <ivanm> mmorrow: hmmmm...
03:03:30 <soupdragon> line 206?         return $ case yi of
03:03:39 <mmorrow> ivanm: i think that bit would be relevant to what you're doing, since you *have* to flatten everything for Doc
03:03:40 <Peaker> soupdragon: yeah
03:03:44 <Peaker> soupdragon: With fundeps it had no problem, why is different with type families?
03:04:03 <Peaker> soupdragon: same code compiled just fine with the type: zip :: List l m => l a -> l b -> l (a, b)
03:04:17 <ivanm> mmorrow: *nod*
03:05:36 <ivanm> anyone know what the Htk package is?
03:05:47 <ivanm> Haddock's wikipedia page mentions it... >_>
03:05:54 * ivanm guesses bindings to tk of tcl fame
03:06:24 <ivanm> oh, wait, the haddock home page has a link
03:06:56 <ivanm> and it's dead
03:08:00 <ivanm> Anyone know if it's possible to have bold markup in haddock docs?
03:08:37 <Peaker> Type families seem to create much more complicated code than fundeps in this case :(
03:09:17 <Peaker> are fundeps supposed to ever be "phased out" in favor of type families?
03:10:28 <soupdragon> what happen with,
03:10:32 <soupdragon> return case yi of
03:10:33 <soupdragon> ?
03:10:49 <ivanm> soupdragon: returns the result of the case statement
03:10:59 <Peaker> soupdragon: I changed it to "undefined" in the mean time
03:11:03 <Peaker> soupdragon: Can't get it to work
03:13:16 <arnihermann> hacked the Setup.hs to not include generating the man files -- that did the trick
03:14:17 <ivanm> arnihermann: yeah, I just don't get why it didn't work...
03:14:27 <ivanm> I'd send an email off upstream about this
03:14:33 <arnihermann> ivanm: will do, thanks
03:15:17 <Saizan> Peaker: how do i get the other modules so that i can test this code?
03:16:04 <Peaker> Saizan: you can git clone from http://github.com/yairchu/generator/tree/master
03:16:21 <Peaker> Saizan: I think I gave up on converting it all to use type families, I think it ends up more complicated rather than simpler
03:18:44 <Peaker> Saizan: would be great to hear your feedback there in general
03:26:25 <bhrgunatha> Can anyone use hoogle? http://haskell.org/hoogle/?hoogle=lines
03:26:26 <bhrgunatha> > Internal Server Error
03:26:28 <bhrgunatha> > The server encountered an internal error or misconfiguration and was unable to complete your request.
03:26:28 <lambdabot>   Not in scope: data constructor `Internal'Not in scope: data constructor `Se...
03:26:29 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:26:42 <Saizan> Peaker: i think we've found a bug in the implementation of type families, if i take r0 and r1 out of the where i get a ghc panic
03:35:04 <Axman6> @hoogle lines
03:35:05 <lambdabot> Prelude lines :: String -> [String]
03:35:05 <lambdabot> Data.List lines :: String -> [String]
03:35:05 <lambdabot> Data.ByteString.Char8 lines :: ByteString -> [ByteString]
03:35:10 <Axman6> bhrgunatha: ^^ :)
03:38:07 <bhrgunatha> lambdabot & Axman6 : thanks
03:38:09 <bhrgunatha> I can't find any way of contacting anyone to let them know hoogle is down though.
03:38:10 <bhrgunatha> I can also use hayoo I guess.
03:38:26 <ivanm> bhrgunatha: hoogle is by neil mitchell
03:38:29 <Axman6> hayoo is pretty cool actually
03:38:40 <sinelaw> is it normal to give references for an abstract?
03:38:56 <ivanm> sinelaw: depends how big it is
03:39:01 <Axman6> i wouldn't call it abnormal
03:39:03 <ivanm> I"ve seen some _long_ abstracts...
03:39:09 <ivanm> but usually not
03:39:15 <ivanm> hmmmm.... is hoogle hosted on the haskell servers?
03:39:46 <sinelaw> i just want to give credit :)
03:39:50 <Axman6> sinelaw: i'd say that if you're expanding on someone else's work, then it's probably not a bad idea to reference them int he abstract
03:40:11 <sinelaw> i'm not even expanding, i'm just using it
03:40:28 <sinelaw> my first abstract :P
03:40:31 <Axman6> is it relevent to the content of the abstract?
03:40:35 <Axman6> ah :)
03:41:06 <Axman6> i've only written two or three
03:47:38 <lpsmith> hmm... why does shift throw away it's computation,  compared to callCC?
03:48:21 <ski> because it is supposed to ?
03:49:01 <lpsmith> heh, just wondering if there was a reason behind that design decision.
03:49:07 <lpsmith> err, continuation, not computation
03:49:31 <ski> the point of `shift' is to reify a delimited continuation as a function
03:49:51 <ski> it would be less expressive if it didn't reset the (local) current continuation
03:50:07 <ski> (e.g. it couldn't do some of the things it was invented for)
03:50:49 <lpsmith> like what?
03:50:58 <lpsmith> I mean, I'm pretty sure you are right
03:51:03 <lpsmith> but what?
03:51:30 <ski> control inversion, e.g.
03:51:54 <ski> (turning an internal iterator into an external one)
03:52:38 <ski> (the CPS-transformation rules written using shift/reset also comes to mind)
03:53:39 <ski> <http://community.schemewiki.org/?composable-continuations-tutorial> shows an example of control inversion
03:56:24 <ski> (specifically compare the implementation of `for-each->stream-maker' using `call-with-current-continuation' and `set!' with the one using `reset' and `shift')
03:56:42 <lpsmith> hmm
03:56:46 <lpsmith> thanks for the pointer :)
03:56:59 <lpsmith> I'll have to take a careful look at that later
03:57:40 <lpsmith> Although maybe you wouldn't lose much expressivity if "shift" didn't throw away the local continuation,  but you had callCC as well
04:03:07 <ski> (btw, there is a perhaps somewhat neater definition of `for-each->stream-maker' in the appendix of the 2009-03-28 post in <http://mumble.net/~campbell/blag.txt>)
04:04:59 <Peaker> Saizan: interesting :)
04:05:16 <ski> lpsmith : yes, it might be that one could reimplement the current `shift' if one had the variant `shift' you proposed, possibly together with `call-with-current-continuation' and/or `set!' ..
04:05:19 <Peaker> Saizan: would be great if you could create a forked branch with some changes. Do you know the github UI?
04:06:26 <lpsmith> ski:  I've looked at the implementation of shift and reset in terms of call/cc and set!,   though I must admit I don't understand it very well yet
04:06:36 <ski> lpsmith : .. so, what i meant to confer was that then one of the points of `shift' is to remove the local delimited continuation, so i'm not seeing the point of having that variant `shift'
04:07:07 <lpsmith> I'm not sure there is a point :-)  Just wondering out loud.
04:08:57 <ski> there was some paper that explained how a doubly CPS transformation on code using `shift' and `reset' looked like written in state-passing-style (i.e. what the `State s' monad is doing)
04:09:45 <ski> (hence the idea to use `set!')
04:12:00 <soupdragon> why does shift throw away it's computation -- it doesn't ...?
04:12:44 <ski> <lpsmith> err, continuation, not computation
04:12:45 <lpsmith> soupdragon:  continuation, not computation :-)
04:13:07 <soupdragon> what
04:13:23 <Saizan> Peaker: i never learned how to use git properly either :)
04:13:52 <ski>   (reset (* 10 (shift c 2)))  ; => 2
04:13:57 <Cale> What do you mean by 'throw away'?
04:14:03 <lpsmith> soupdragon:   if you  (call/cc (lambda (k) 42)),  it's equivalent to 42
04:14:34 <matthew-_> agh, how do I get the current number of milliseconds (or preferably picoseconds) since epoch?
04:14:47 <lpsmith> however if you (shift k 42),   it throws away the continuation up to the nearest enclosing reset
04:14:50 <Cale> lpsmith: You didn't use c though, isn't that what you're throwing away?
04:15:06 <Cale> er, oh, it was ski's code ;)
04:15:17 <soupdragon> why does a spider have 8 legs
04:15:27 <lpsmith> yeah,  and in this case "c" is equivalent to (lambda (x) (* 10 x))
04:15:28 <ivanm> matthew-_: that sounds dangerously OS-specific... >_>
04:15:31 <lpsmith> that bit gets thrown away
04:15:35 <matthew-_> ivanm: that I don't care about
04:15:41 <Cale> lpsmith: right, because it wasn't used in the body of the shift
04:15:57 <ivanm> matthew-_: fair enough then
04:16:01 <ivanm> @go haskell epoch
04:16:02 <lambdabot> No Result Found.
04:16:05 <ivanm> :(
04:16:06 <Saizan> Cale: callCC (\k -> return 42) >>= return . (+2) == return 44, reset $ shift (\k -> return 42) >>= return . (+2) == return 42
04:16:10 <soupdragon> (reset (* (shift c #t) (shift c #f)))
04:16:12 <lpsmith> but if you do  (* 10 (call/cc (lambda (k) 42)))
04:16:17 <lpsmith> then you get back 420
04:16:18 <matthew-_> ivanm: getPOSIXTime looks closeish
04:16:29 <lpsmith> even though you ignored k
04:16:38 <Saizan> Cale: i.e. callCC applies the current continuation when you return normally, while shift doesn't
04:16:44 <Cale> lpsmith: But shift is not the same thing as callCC
04:16:45 * ski wishes people would use `=' for semantical equality ..
04:16:46 <soupdragon> for 1000000! true or false?
04:16:55 <lpsmith> cale:  of course  :-)
04:17:06 <soupdragon> me too ski
04:17:07 <ivanm> matthew-_: do you actually care about the epoch?
04:17:08 <lpsmith> I'm just asking why that particular difference is a difference
04:17:09 <kynky> =,==,===
04:17:14 <ivanm> or just want to do a time difference?
04:17:33 <Cale> lpsmith: I'm still not sure what you mean by 'throw away' though... it's a bit like writing (\x y -> x) and asking why it throws away its second parameter
04:17:43 <lpsmith> they are related though,  you could tweak the notation to use (shift (lambda (k) ...))
04:17:48 <Cale> ... because you didn't use it ;)
04:18:02 <ivanm> matthew-_: see startOfTime in the DateTime package
04:18:07 <ivanm> on hackage, that is
04:18:19 <ski> Cale : presumably lpsmith is referring to the part of the current continuation that is removed
04:18:20 <matthew-_> ivanm: no, I just want a straight integer that I can plot against
04:18:27 <ivanm> do a diffSeconds with that and getCurrentTime
04:18:37 <ivanm> matthew-_: well, dateTime seems to do that
04:18:46 <soupdragon> lpsmith, I don't think it's a precise enough question to have any good answers
04:18:59 <ivanm> note that it basically just defines Epoch, rather than calculating it or using anything unix-y
04:19:00 <lpsmith> cale:  of course,  but somebody invented shift,  (either danvy or filinski,  I believe)  and the question is why did they make that choice
04:19:04 <ivanm> so it's probably cross-platform
04:19:44 <RayNbow> hmm, Erik Meijer is not quite positive on conal's FRAN in a channel9 vid...
04:20:02 <matthew-_> ivanm: actually, getCurrentTime with diffUTCTime is good enough
04:20:05 <lpsmith> soupdragon:  it's a pretty precise question,  just an open-ended one,  one that may or may not have a good answer
04:20:10 <matthew-_> cheers
04:20:14 <ivanm> matthew-_: whatever ;-)
04:20:22 <ivanm> or else there's the clock package...
04:20:26 <Cale> lpsmith: To be fair, I've never come up with a use for it myself, but the idea, I think, is to capture the region between the surrounding reset and call to shift, and define that as a function in the body of the shift.
04:20:33 * ivanm stops looking through time or date related packages on hackage
04:20:41 <soupdragon> lpsmith, it's like asking "why does a spider have 8 legs"
04:21:21 <Cale> lpsmith: So it's like a funny way to write a let-binding, sort of :)
04:21:49 <ski> (Cale : did you see the control inversion example ?)
04:21:53 <ivanm> matthew-_: anyway, I've just finished coding in (well, I'm writing a code generator) for all 150 graphviz attributes :s
04:22:13 <ivanm> make that 151, and IIRC I combined two of them so there's actually 152 :s
04:22:45 <soupdragon> there are lots of good uses for delimited continuations
04:22:55 <ski> Cale,lpsmith : another use i've seen is when you are generating code in a nqCPS way
04:23:03 <ivanm> soupdragon: spiders have 8 legs by definition? :p
04:23:33 <ski> ivanm : yes. in all possible worlds, spiders have 8 legs
04:24:21 <lpsmith> cale:  I've played around with shift a bit;  I have some interesting applications.   Actually,  I think my application has something to do with reset, not shift, but anyway...
04:24:41 <Cale> Isn't reset without shift kind of pointless?
04:24:57 <Cale> (It's just the identity map isn't it?)
04:25:44 <lpsmith> well... my application doesn't need fully delimited continuations, it's just that it works... better... with them
04:25:47 * ski saw a (very small) pattern-matching compiler example in MetaML, written in nqCPS .. incidentally, MetaML has `shift' and `reset', so i tried going back to DS .. worked like a charm :)
04:26:04 <soupdragon> DS ?
04:26:08 <ski> Direct Style
04:26:18 <soupdragon> ah yeah
04:26:40 <lpsmith> ski:  have you seen my paper yet?
04:26:41 <ski> (istr there being papers named "There and back again", or something similar)
04:26:50 <ski> lpsmith : i have not
04:27:03 <matthew-_> ivanm: lol, yeah, I took the more interesting subset ;)
04:27:11 <lpsmith> sounds like you'd enjoy it:   http://blog.melding-monads.com
04:27:17 <matthew-_> ivanm: I really couldn't be bothered to work out nice things for clustering
04:27:32 <ski> Cale : yes, `reset . return = return'
04:28:19 <ski> (or `reset . lift = lift', for a monad transformer)
04:28:24 <Guest61412> hi everybody,i need in my programm to disable firewalls,i can disable the windows firewall but i need more infos on other popular firewalls
04:28:33 <soupdragon> lol
04:28:44 <Axman6> ...
04:28:49 <Cale> Guest61412: Shouldn't you leave that up to your users?
04:28:51 <Axman6> you're kidding right?
04:29:04 <Cale> Guest61412: It's not good policy to go reconfiguring other people's firewalls.
04:29:10 <Guest61412> no i'm not lol
04:29:25 <Axman6> no firewall worth its salt would let you disable it
04:29:35 <Axman6> nor should they!
04:29:47 <lpsmith> ski:  basically it's a way of structuring corecursive queues using continuations.
04:30:19 * ski wonders whether `corecursive' is like `coinductive'
04:30:21 <Cale> Guest61412: If someone has ports which your application uses blocked, maybe it's for a reason. You should just leave it alone. Chances are the firewall software will alert the user of the configuration change that they'd need to make in order to use your program.
04:30:41 <soupdragon> ski, I don't think so
04:30:43 <soupdragon> (?)
04:31:01 <Guest61412> no normally i just configure the registry
04:31:17 <soupdragon> multi/mutually recursiv
04:31:18 <Guest61412> or put the program on the green list
04:31:20 <lpsmith> yes,  same relationship between corecursion and coinduction as there is between recursion and induction
04:31:34 <ski> that relationship being ?
04:31:43 <lpsmith> soupdragon:  corecursive /= mutually recursive
04:32:12 * soupdragon . o ( prefixing co )
04:32:13 <lpsmith> ski:  I don't think I can euclidate it
04:32:18 <soupdragon> lol
04:32:25 <soupdragon> euclidate ?
04:32:29 <Cale> Guest61412: Anyone concerned about the security of their machine will hate you for doing that -- it probably wouldn't be allowed if the system had a reasonable system of permissions.
04:32:35 * ski grins
04:32:59 <soupdragon> love that new word
04:33:15 <lpsmith> soupdragon:  fat fingers on the keyboard ;-)
04:33:24 <lpsmith> elucidate :)
04:33:39 <mbuf> any suggestions on an online book for newbies to get started with haskell (other than realworldhaskell.org and learnyouahaskell.com ?
04:33:40 * soupdragon is going to start using that
04:34:01 <ski> > ((==) `on` sort) "euclidate" "eludicate"
04:34:02 <Cale> mbuf: There is the wikibook and "Yet Another Haskell Tutorial"
04:34:03 <lambdabot>   True
04:34:04 <soupdragon> learnyouahaskell.com
04:34:08 <maartenm> euclidate: to promote a conjecture to an axiom just for the sake of simplicity?
04:34:16 <soupdragon> :p
04:34:20 <Guest61412> Cale: why not , i dont mind if someone disable my firewalls while he CAN
04:34:20 <Cale> soupdragon: he... just mentioned that one himself :)
04:34:38 <soupdragon> @remember maartenm euclidate: to promote a conjecture to an axiom just for the sake of simplicity
04:34:39 <lambdabot> Good to know.
04:34:57 <mbuf> Cale: ok
04:35:08 <Cale> mbuf: You can also ask lots of questions here of course :)
04:35:15 <ski> @src mapCont
04:35:16 <lambdabot> Source not found. It can only be attributed to human error.
04:35:18 <ski> bah
04:35:30 <soupdragon> mapCont -- eviy
04:35:37 <soupdragon> ;(
04:35:56 <lpsmith> mapCont f m= Cont (f . runCont m)
04:36:03 <ski> it's not obvious (to me) which of the alternative evident implementations they are using ..
04:36:06 <ski> ok, ty
04:36:44 <soupdragon> @src mapCont
04:36:44 <lambdabot> Source not found. I feel much better now.
04:36:56 <soupdragon> @src runCont
04:36:56 <lambdabot> Source not found. You type like i drive.
04:37:03 <lpsmith> @src Control.Monad.Cont.mapCont
04:37:03 <lambdabot> Source not found. Take a stress pill and think things over.
04:37:16 <Cale> Guest61412: Well, the normal way that things work is that your program tries to listen on a port normally, and if the firewall is meant to be configured by the user, it just asks the user at that point, no? If programs just reconfigure the firewall at will, then there would be little point in having it there. (In fact, it ought not to be easy/possible to do)
04:37:17 <lpsmith> hmm
04:37:31 <ski> lpsmith : possibly if you throw in state, you can express `mapCont'
04:38:10 <ski> (since, (undelimited) continuations + state = delimited continuations)
04:38:16 <lpsmith> runCont :: Cont r a -> (a -> r) -> r
04:38:29 <ski> @src Cont
04:38:30 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
04:38:37 <lpsmith> there we go
04:38:44 <lpsmith> @src callCC
04:38:45 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:38:48 <lpsmith> weird
04:39:17 <lpsmith> ski: what kind of state?
04:39:45 <lpsmith> I think you'd have to go back to scheme
04:39:55 <ski>   callCC reciever = Cont (\k -> reciever (\o -> Cont (\_ -> o)) `runCont` k)
04:40:14 <Cale> Guest61412: The purpose of the firewall is to limit the ways in which programs communicate over the internet. If the programs just reconfigure it to allow access, then there's no point in having the firewall in the first place, is there?
04:40:14 <lpsmith> in which case, yes,  you can express mapCont,  because it can be expressed in terms of shift and reset
04:40:15 <Guest61412> Cale:nothing is impossible,if the user can enable the connection by validing the yes,than this same procedure we can call
04:40:30 <Cale> Guest61412: Why not just let it ask the user?
04:41:08 <Guest61412> Cale:lol well of course,it's mine firewwal that i want to disable but other's,i'm rogramming a backdoor client
04:41:10 <dsturnbull> this program i'm modifying is getting stdin with hGetLine. i thought i could get an Integer by `m <- hGetLine stdin >>= readIO' but this generates a 'no parse' exception. how should i do this?
04:41:41 <ski> lpsmith : i was thinking maybe something like `StateT ? (Cont o)'
04:41:57 <lpsmith> I don't think you can express mapCont then
04:41:59 <Cale> Guest61412: So you're saying that you're willingly damaging the security of computers that aren't yours?
04:42:01 <Guest61412> Cale:it's already done with windows firewall there is no problem,but with some strong musled firewalls like BitDefender(i hate it by the way)...
04:42:38 <Cale> dsturnbull: You're mixing up do-notation and the desugared version of it
04:43:00 <dsturnbull> oic
04:43:01 <Cale> dsturnbull: you could write  hGetLine stdin >>= readIO
04:43:11 <Cale> oh!
04:43:14 <Cale> I see
04:43:23 <dsturnbull> yeah.. :P
04:43:25 <Cale> No, you're not, it's just the inferred type isn't what you want
04:43:39 <Guest61412> Cale:hhmm not damaging,just havinf fun
04:43:39 <lpsmith> ski: in fact,  I'm 95% certain that you can't
04:43:45 <Cale> m <- readIO =<< hGetLine stdin   is nicer, btw.
04:43:55 <Cale> but m has to be the right type
04:44:06 <Cale> dsturnbull: Where do you use m?
04:44:17 <ski> lpsmith : that might be .. but i'd like to know why
04:44:43 <Guest61412> Cale: i dont really use it to do mean things
04:45:03 <dsturnbull> Cale: your suggestion is a syntax error
04:45:07 <dsturnbull> it does look nicer
04:45:09 <Cale> Guest61412: Installing a backdoor seems like a pretty mean thing to do. :)
04:45:15 <lpsmith> the latest version of the paper has an argument why you can't... I'll stop short of calling it a proof because it uses a few steps that I'm not 100% sure of
04:45:24 <Cale> dsturnbull: inside a do-block?
04:45:28 <dsturnbull> yep
04:45:32 <Cale> :t readIO
04:45:34 <lambdabot> forall a. (Read a) => String -> IO a
04:46:00 <lpsmith> ski: basically I created a continuation monad that can express callCC, return, and (>>=),  but not mapCont
04:46:02 <Cale> :t do m <- readIO =<< hGetLine stdin; print (m^2)
04:46:03 <lambdabot> Not in scope: `hGetLine'
04:46:03 <lambdabot> Not in scope: `stdin'
04:46:08 <lpsmith> using higher-ranked types
04:46:14 <Cale> :t do m <- readIO =<< System.IO.hGetLine System.IO.stdin; print (m^2)
04:46:16 <lambdabot> IO ()
04:46:22 <Cale> not a syntax error.
04:46:50 <lpsmith> ski:  it's kind of trivial, really,  callCC,  (>>=) and return are all guaranteed to be tail-recursive
04:46:55 <lpsmith> while mapCont isn't
04:47:11 <Guest61412> Cale: you know what ur right,actually i tried it just two times,and it was just to retrieve infos,but i think it's just that satisfaction of making it,when i'll end i wont even use it,now i dont use it a lot
04:47:17 <ski> what do you mean by "tail-recursive", here ?
04:48:18 <ski> (do you mean that the internal continuation parameter is only called in tail position, up to "enclosing" `runCont' ?)
04:48:38 <dsturnbull> hoogle is down, what's the other one?
04:48:40 <dsturnbull> hahoo!?
04:48:47 <ski> @hoogle mapContT
04:48:47 <lpsmith> yes
04:48:47 <lambdabot> Control.Monad.Cont mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a
04:48:49 <lpsmith> I think so
04:49:14 <ski> iow, `runCont' (like `shift' and `reset') is true nqCPS
04:49:24 <ski> er, `mapCont', not `runCont'
04:49:42 <Cale> dsturnbull: hayoo
04:49:53 <lpsmith> ski:  nqCPS?
04:50:02 <ski> not-quite-CPS :)
04:50:16 <ski> when you're having CPS, "most of the time"
04:50:42 <Cale> dsturnbull: anyway, the important thing is that m gets used in a way which fixes its type to the type you want to parse
04:50:48 <dsturnbull> anyway, i'm using m like it should be a Maybe Integer
04:51:02 <Cale> dsturnbull: ah, then you'll have to parse a Maybe Integer
04:51:17 <Cale> dsturnbull: So is the input like "Just 42"
04:51:18 <Cale> ?
04:51:19 <lpsmith> ski:  something like that,  probably
04:51:42 <dsturnbull> ahh interesting
04:51:47 <dsturnbull> no, it was just the literal number
04:51:57 <ski> so, what's the higher-ranked type implementation ?
04:52:18 <ski> .. or should i just read the paper/source ?
04:54:47 <Cale> dsturnbull: So you want it to give Nothing when the parse fails, and Just x when it succeeds?
04:55:12 <solrize> @seen dolio
04:55:12 <lambdabot> I saw dolio leaving #ghc, #haskell-in-depth, #haskell-blah and #haskell 5h 50m 58s ago, and .
04:55:33 <dsturnbull> i'm ok with typing 'Just 42' in there :)
04:56:06 <lpsmith> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6970
04:56:19 <Cale> dsturnbull: okay :)
04:56:57 <lpsmith> only problem is that the excessively higher-ranked types imply that you can't ever leave the continuation monad
04:57:04 <lpsmith> so I cheated and used error
04:57:15 <lpsmith> but that shouldn't be relevant to the argument
04:57:28 <Cale> dsturnbull: In any case, the nice way to handle parse failures is that there's a function called reads, which gives a list of the parses (which is usually empty or one element)
04:57:33 <Cale> :t reads
04:57:35 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:58:04 <ski> lpsmith : that is one strange definition of `Cont' ..
04:58:30 <Cale> > reads "45" :: [(Integer, String)]
04:58:31 <lambdabot>   [(45,"")]
04:58:36 <Cale> > reads "45apple" :: [(Integer, String)]
04:58:38 <lambdabot>   [(45,"apple")]
04:58:38 <EvilTerran> lpsmith, you know you can have multiple extensions in one LANGUAGE if you separate them with commas?
04:58:53 <lpsmith> EvilTerran:  ah, no I didn't
04:59:19 <lpsmith> I'm not sure I'll use that feature anyway,  I kind of like the one language extension per line bit
05:00:12 * EvilTerran tends to write "{-# LANGUAGE\n    Foo\n    Bar\n    #-}"
05:00:14 <ski> (lpsmith : fwiw `(Cont c) >>= f = ...' could be simply `Cont c >>= f = ...')
05:01:20 <mreh> What's the best way I can represent a weighted graph in Haskell?
05:01:34 <lpsmith> anyway,  that demonstrates a working callCC, return, and (>>=) ,  but gives a type error for mapCont
05:02:11 <lpsmith> you can do  mapCont  :: (forall a.  a -> a) -> Cont m b -> Cont m b
05:02:33 <ski> could you use an exception monad to escape, instead of `error' ?
05:02:35 <lpsmith> but that's not useful
05:02:48 <lpsmith> I don't think so...
05:03:31 <soupdragon> (forall a.  a -> a) is only id or stuff with undefined
05:03:39 <ski> (i don't even see what type signature for `mapCont' your implementation gave a type error for)
05:03:42 <lpsmith> soupdragon:  yupp
05:04:06 <lpsmith> well,  download the code,  type in
05:04:15 <EvilTerran> mreh, Map NodeId (Map NodeId EdgeWeight) might do it, depending on what you want
05:04:16 <lpsmith> mapCont f m = Cont (f . runCont m)
05:04:19 <lpsmith> and you'll get a type error
05:04:35 <ski> yes .. but what type sugnature did you *expect* to see ?
05:04:57 <ski> i can't atm imagine any possible type signature for an `mapCont' for your `Cont' at all
05:07:17 <lpsmith> ski:  there,  I just updated the hpaste to have a mapCont that should compile
05:07:23 <lpsmith> with that definition
05:07:51 <mreh> EvilTerran, that seems a pretty logical way of doing it
05:08:15 <mreh> I'm analysing harmonic progressions
05:08:22 <Saizan> mreh: there's also the fgl lib
05:09:11 <lpsmith> ski:  basically mmorrow pointed out that his CPS State monad   newtype StateCPS st a =  StateCPS (forall r.  (a -> st -> r) -> st -> r)
05:09:24 <lpsmith> couldn't do mapCont due to parametericity
05:09:48 <lpsmith> some time ago,  but that can't do callCC either.
05:09:56 <lpsmith> So I modified it so it could do callCC
05:10:21 <lpsmith> note the definitions of callCC,  return, and (>>=) are perfectly normal, the only funky thing here is in the types
05:10:37 <ski> sorry, i'm obviously not explaning what i mean in a clear way
05:11:44 <ski> what i'm thinking is that without an intended type signature for `mapCont' for your `Cont', the question about whether one can implement `mapCont' is not meaningful
05:11:46 <Saizan> lpsmith: how do you run that Cont monad in the hpaste?
05:12:09 <lpsmith> Saizan:  you can't.  It's not useful code
05:12:42 <Saizan> lpsmith: ah, ok :)
05:12:56 <lpsmith> But I tentatively claim that it demonstrates that mapCont cannot be expressed in terms of callCC, return, and (>>=)
05:13:19 <ski> (i.e. since `mapCont' is not in a class, you have to say what type signature you want, if you're changing the kind of `Cont')
05:13:58 <ski> lpsmith : ok ?
05:14:55 <lpsmith> ski:  Ok,  I see what you are getting at.
05:16:10 * ski . o O ( `newtype Cont m a = Cont { runCont :: forall t r. MonadTrans t => (forall s. (a -> t m s)) -> t m r }' )
05:16:59 <ski> would that work, as well as allow a way to escape ?
05:17:12 <lpsmith> heh,  no idea
05:17:32 <ski> (you'd probably need to change the `MonadReader' instance, though)
05:17:37 <Deewiant> Given: data D = A | B | L [D] | LA [D], can I enforce in the type system that LA never contains B? E.g. LA [A, A] or LA [LA [A], L [A]] are fine, but LA [A, L [A, B]] isn't.
05:17:51 * RayNbow can see why A is contravariant and B is covariant in A -> B... but I cannot see that A is supposed to be covariant in (A -> B) -> C...
05:18:18 <RayNbow> (covar/contravar is always blowing my mind)
05:18:26 <ski> Deewiant : maybe with a GADT
05:18:45 <Saizan> RayNbow: write the Functor instance for "Cont r"
05:18:49 <Deewiant> ski: Yes, that's what I would have guessed, but I don't know much of anything about GADTs. :-)
05:18:54 <mreh> Is there an index for that series of German Haskell lectures online?
05:19:15 <mreh> they're conducted in english, but they're from a German university, linked from LtU
05:19:22 <Saizan> where Cont r a = (a -> r) -> r
05:19:54 <lpsmith> mreh:  I'm not recalling that specific post...
05:20:34 <ski> Deewiant : how about `L [B]' ?
05:20:41 <mreh> http://lambda-the-ultimate.org/node/1303
05:20:55 <Deewiant> ski: That's fine, as long as it's not in an LA.
05:20:55 <lpsmith> ski:   Ok,  I think I understand your complaint,  but I don't think it impacts my argument.   You can ask if the definition of mapCont makes any sense,  and the compiler says that it does not
05:21:06 <Deewiant> ski: Which, I think, is the tricky bit.
05:21:12 <ski> Deewiant : `LA [L [B]]', then ?
05:21:19 <Deewiant> Not fine.
05:21:23 <ski> ok
05:21:37 <ski>   data D :: * -> *
05:21:43 <ski>     where A :: D a
05:21:50 <ski>     B :: D ()
05:22:00 <ski>     L :: (forall a. [D a]) -> [D a]
05:22:04 <RayNbow> Saizan: ok, I'm going to open Notepad and play around with the types :)
05:22:09 <ski>     LA :: [D a] -> [D a]
05:22:16 <ski> Deewiant : that might work ..
05:22:25 <ski> (Deewiant : though it probably doesn't scale)
05:22:36 <lpsmith> mreh:  this it?  http://lambda-the-ultimate.org/node/1303
05:22:37 <Deewiant> Scale how
05:23:00 <ski> RayNbow : entering into the lhs of `->' reverses polarity
05:23:36 <RayNbow> ski: yeah, but that doesn't make it easier to actually understand what's going on :)
05:24:02 <ski> Deewiant : like if you wanted `A',`B',`C' constructors, where `LA' can only contain `A's, `LBC' only `B's and `C's, and `LAB' only `A's and `C'
05:24:07 <doserj> RayNbow: basically, a function of type (A->B)->C has to apply the given function to something of type A. therefore it has to "contain" this something of type A.
05:24:23 <ski> s
05:25:02 <ivanm> classes can sometimes be scary, how just how you use the result of something like read and it can automagically determine what class instance you're referring to... :s
05:25:07 <ski> lpsmith : yes .. but with higher-ranked types, things sometimes goes through with type signatures, but not without
05:25:17 <Deewiant> ski: I see, the number of type variables needed explodes
05:25:25 <Twey> What sort of pattern would you recommend for a series of lookups that should each fail with a different error?
05:25:56 <Deewiant> ski: But leaving that aside for the moment, your code doesn't compile: Malformed constructor result type: [D a]  In the definition of data constructor `L'
05:26:02 <Twey> I'm thinking an Either monad instance, but it seems a little odd (and there's all that stuff in Control.Monad.Instances that would royally bugger it up should I ever need that
05:26:05 <Twey> )
05:26:18 <quicksilver> Twey: I'd just use the instance from C.M.I
05:26:30 <quicksilver> Twey: the 'Error' constraint is not a big problem.
05:26:31 <Deewiant> GHC doesn't like the 'a' in the result of L and in LA
05:26:34 <Twey> In fact, how about modifications?
05:26:48 <ski> Deewiant : sorry, that's a typo ... the `[D a]' result type in `L' and `LA' should be just `D a'
05:26:57 <Twey> Something like Conal's ‘Semantic Editor Combinators’ but with failure
05:27:20 <Deewiant> ski: Ah yes, of course
05:27:28 <Deewiant> Even I should have known that much ;-)
05:27:57 <mreh> lpsmith: yah
05:28:25 <mreh> I can't remember where I left off in the series! looks like I'll have to go hunting
05:30:45 <RayNbow> Saizan, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6973#a6973 ?
05:30:53 <ski> (quicksilver : .. that `Error' constraint was quite irritating when i ran into it; i ended up making a `newtype'/new type)
05:31:11 <Deewiant> ski: Testing it, it seems you got it the other way around; LA can contain B, but not L
05:31:28 * RayNbow is not too happy about the names he used in that hpaste
05:31:36 <lpsmith> ski:  but if you can't even come up with a sensible type signature for mapCont for this monad,  doesn't that mean that you can't implement mapCont in terms of callCC?
05:32:40 <ski> lpsmith : i'd say the question of whether you can implement `mapCont' is meaningless .. which `mapCont' ? :)
05:32:51 <Deewiant> Now all I need to do is figure out why the heck this works :-P
05:34:30 <ski> lpsmith : it's like asking how to implement `callCC :: ((a -> Cont o b) -> Cont o a) -> Cont o a', if you change the standard `Cont' into `newtype Cont a = MkCont {runCont :: forall o. (a -> o) -> o}'
05:35:15 <lpsmith> ski:  not a problem in this case
05:35:18 <lpsmith> :t callCC
05:35:20 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
05:35:30 <ski> right
05:35:56 <lpsmith> but you can't implement callCC in that case either
05:36:00 <ski> because `callCC' is abstracted from a specific implementation with certain extra type parameters
05:36:12 <ski> (while `mapCont' and `mapContT' are not)
05:36:31 <lpsmith> well,  in an impure language,  callCC has type ((a -> b) -> a) -> a
05:37:01 * RayNbow wonders what covar/contravar actually means in a functional setting (without subtyping relations?)
05:38:04 <ski> (in the `callCC :: MonadCont m => ((a -> m o) -> m a) -> m a' case you have a valid type for `callCC' for the just above mentioned alternative `Cont' .. not so for the `mapCont' case)
05:38:12 <lpsmith> i'd say that each control operator we have been talking about has meaning independent of the types... it's not so hard to tweak the type accordingly
05:38:26 <ski> RayNbow : the direction you can `fmap'
05:39:10 <RayNbow> ski: ah right
05:39:34 <RayNbow> so if you can define an fmap :: (a -> b) -> f a -> f b, it's covar
05:39:55 <RayNbow> but if you can define a cfmap :: (a -> b) -> f b -> f a, it's contravar? :)
05:40:25 <ski> yes (assuming the laws are satisfied)
05:40:30 <RayNbow> of course
05:41:12 <PeakerWork> Saizan: git is nice, worth learning IMO
05:41:30 <lpsmith> ski:  for example,  if you generalize from Murthy types for continuations like the MTL uses,  and move to Filinksi types
05:41:39 <lpsmith> newtype C a b x = C { runC :: (x -> a) -> b }
05:42:22 <lpsmith> then ghc can tell you the type of the corresponding mapC
05:42:29 <lpsmith> mapC :: (b -> c) -> C a b x -> C a c x
05:42:34 <RayNbow> it's easier to think about it this way than to think of things like (A -> Apple) being a subtype of (A -> Fruit)
05:42:35 <ski> (lpsmith : if you have an untyped operational semantics in mind, then yes (to independent meaning))
05:43:51 <ski> RayNbow : e.g. if we had an `IOReadRef' that would be covariant, while `IOWriteRef' would be contravariant
05:45:07 * ski btw is not sure exactly why `mapCont' is the way it is ..
05:45:18 <RayNbow> ski: I'm familiar with that (but then with arrays/Lists/etc in an OO setting)
05:45:21 <lpsmith> how so? :)
05:45:27 <ski> (i think of it as a restricted variant of `shift')
05:45:58 <doserj> or: covariant in A ~ "provides" a value of type A vs. contravariant in A ~ requires a value of type A
05:47:00 <doserj> that also gives an intuition for the fmap directions
05:47:01 <lpsmith> ski:  I think you need both shift and reset to define mapCont,  just one or the other is insufficient.
05:47:06 <ski>   data IOReadRef a = forall x. MkIOReadRef (IORef x) (x -> a)  -- et.c.
05:49:13 <ski> lpsmith : hm .. actually i was thinking of a `mapCont oo ma = Cont (runCont ma . (oo .))' definition rather than `mapCont oo ma = Cont (oo . runCont ma)'
05:49:50 <ski> (just goes to show that i've not really played much with `mapCont' (nor the other `mapState', et.c.) at all)
05:50:14 <RayNbow> doserj: ah right... like for example Predicate b = (b -> Bool) is a ContraFunctor
05:50:32 <lpsmith> @unpl  f ma . (oo .)
05:50:33 <lambdabot> (\ d -> f ma (\ h -> oo (d h)))
05:50:41 <lpsmith> @unpl  oo . f ma
05:50:43 <lambdabot> (\ c -> oo (f ma c))
05:51:04 * ski wishes people would stop saying "CoFunctor and ContraFunctor" ..
05:52:03 <lpsmith> @src mapState
05:52:04 <lambdabot> Source not found. My mind is going. I can feel it.
05:52:08 <lpsmith> :t mapState
05:52:10 <lambdabot> forall a s b. ((a, s) -> (b, s)) -> State s a -> State s b
05:53:35 <ivanm> is there any way I can represent a hexadecimal digit (as in 0-9a-f)?
05:53:37 * ski wants something like `tmap :: (MonadFunctor t,Monad m,Monad n) => (forall x. m x -> n x) -> t m a -> t n a'
05:53:50 * lpsmith wonders why lambdabot isn't finding the sources...
05:53:52 <ivanm> rather than just using a Char or something
05:53:57 <lpsmith> @src sum
05:53:57 <lambdabot> sum = foldl (+) 0
05:54:03 <ivanm> lpsmith: lambdabot only has sources for those coded in
05:54:10 <ski> the definition of `mapState' is obvious
05:54:12 <ivanm> she doesn't parse GHC source or anything like that...
05:54:23 <lpsmith> ski: agreed
05:56:49 <lpsmith> well,  except for typeclasses (which isn't essential to my argument)  the meaning of a haskell program is independent of its type...
05:57:06 <lpsmith> hmm
05:57:11 <RayNbow> ski: is there a usecase for tmap?
05:57:24 <lpsmith> :t tmap
05:57:25 <lambdabot> Not in scope: `tmap'
05:57:33 <lpsmith> oh
05:57:34 <codolio> Doesn't one of the mtl replacement libraries have it?
05:57:55 <ski> RayNbow : it feels like something like it could replace and generalize some uses of `mapFooT'
05:58:47 <lpsmith> ski: what is monadFunctor?
05:59:08 <ski> the class having `tmap' as only member, and no superclasses
05:59:16 <lpsmith> ahh
06:00:58 <lpsmith> roconnor mentioned a similar type recently...
06:01:44 <ivanm> is there any way to convert a number to hexadecimal notation?
06:02:07 <mxweas> change of base formula :P
06:02:15 <mxweas> Or get a base 10 to base 16 calculator
06:02:21 <mxweas> I've seen some good ones for dashboard
06:02:23 <Ferdirand> to/fromDigits ?
06:02:27 <ivanm> mxweas: yeah, I was hoping for an inbuilt Haskell function
06:02:31 <ivanm> @hoogle toDigits
06:02:32 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
06:02:48 <ivanm> ahhh, showHex seems to come close
06:02:49 <mxweas> ivanm: I didn't realize I was in the haskell channel, sorry
06:02:54 <ivanm> mxweas: heh
06:02:54 <EvilTerran> showHex would do it
06:03:17 <mxweas> ivanm: It's 6am here :P my brain is still turning on
06:03:27 <ivanm> mxweas: heh
06:03:43 <ivanm> EvilTerran: yeah, but @hoogle only told me about parsec functions :s
06:03:49 <Ferdirand> funny, i was sure there was a toDigits somewhere with an arbitrary basis
06:04:19 <ivanm> Ferdirand: showIntAtBase?
06:04:29 <ivanm> @type showIntAtBase
06:04:31 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
06:04:31 <EvilTerran> > floatToDigits 16 65536
06:04:31 <lpsmith> Ferdirand:  I've written my own toDigits,  I use it to solve Project Euler problems
06:04:33 <lambdabot>   ([1],5)
06:04:48 <ivanm> > showHex 255
06:04:50 <lambdabot>   Overlapping instances for GHC.Show.Show
06:04:50 <lambdabot>                              (GHC.B...
06:04:57 <ivanm> @more
06:05:03 <ivanm> gah
06:05:10 <RayNbow> > showHex 255 "<--something here-->"
06:05:12 <lambdabot>   "ff<--something here-->"
06:05:14 <EvilTerran> showHex :: ... -> ReadS
06:05:18 <EvilTerran> er, ShowS
06:05:21 <ivanm> duh, forgot that it's ShowS
06:05:23 <Ferdirand> lpsmith: that's probably what i did too then :)
06:05:30 <EvilTerran> > showHex 255 " and a suffix"
06:05:33 <lambdabot>   "ff and a suffix"
06:06:31 * ivanm facepalms
06:06:42 <EvilTerran> ?
06:06:51 <ivanm> completely missed that matthew-_ was already using showHex in Data.GraphViz.Attributes for this :s
06:07:28 <lilac> > map (flip showHex " is delicious") [12648430, 48879, 61453]
06:07:29 <lambdabot>   ["c0ffee is delicious","beef is delicious","f00d is delicious"]
06:07:53 <ivanm> lilac: heh
06:08:10 <ivanm> though for the latter, I would say that only delicious food is delicious
06:08:11 <ivanm> ;-)
06:08:48 <RayNbow> lilac: but what about dead beaf and cafe babes? :p
06:08:48 <lilac> > intercalate " " $ map (flip showHex []) [12648430, 21, 61453]
06:08:50 <lambdabot>   "c0ffee 15 f00d"
06:08:51 <mookatt> if somebody could help me sort out an Xmonad config problem I'd be very grateful.  I'm trying to import the Xmonad.Config.Gnome module as per http://www.haskell.org/haskellwiki/Xmonad/Basic_Desktop_Environment_Integration but I keep getting an error that it can't find the module.  (I'm using Ubuntu Jaunty).  I have xmonad-contrib installed (the ubuntu package)
06:08:57 <RayNbow> *beef
06:09:09 <ivanm> mookatt: ask in #xmonad ?
06:09:27 <mookatt> thanks ivanm
06:17:47 <lilac> > tail $ foldr (\x f -> (' ':) . showHex x . f) id [65261,233811181,47806,2766,48879] []
06:17:49 <lambdabot>   "feed defaced babe ace beef"
06:18:22 <tromp> no use of dead?
06:18:52 <lilac> no, nor deaf, faded, acceeded, bedded, cab, cafe, etc ;-)
06:19:33 <badsheepy> or the ever important baa
06:19:43 <tromp> nah
06:19:46 <tromp> bah
06:20:15 <badsheepy> lets not get caught up in linguistics :o
06:21:27 <mreh> @wiki
06:21:27 <lambdabot> http://www.haskell.org/haskellwiki/
06:21:34 <mreh> @wikipedia
06:21:35 <lambdabot> Empty search.
06:21:42 <mreh> @wikipedia magic numbers
06:21:44 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=magic%2520numbers
06:40:42 <ivanm> @seen malcolmw_
06:40:43 <lambdabot> malcolmw_ is in #ghc and #haskell. I last heard malcolmw_ speak 4h 16m 15s ago.
06:40:53 <malcolmw_> hello ivanm
06:41:04 <lilac> @wikipedia double escaping
06:41:06 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=double%2520escaping
06:41:25 <ivanm> malcolmw_: wondering if you can help me with this: with the Lazy parser, I have "parse2Hex = exactly 2 (satisfy isHexDigit) >>= \ c -> let [(n, [])] = readHex c in return n"
06:42:06 <ivanm> then when I try to run it with many, no matter how many values I give it, it throws the following exception:
06:42:09 <ivanm> *** Exception: When expecting exactly 2 more itemsRan out of input (EOF)
06:42:17 <ivanm> am I doing something wrong?
06:42:42 <malcolmw_> ivanm: hmm, ooi why are you mixing parsing with readHex?
06:43:17 <ivanm> malcolmw_: because it provided a ready-made function to convert something like "ff" into 255
06:43:24 <ivanm> (and I'm editing code that's already using it)
06:43:42 <ivanm> malcolmw_: with Plain, it doesn't have a problem, just with Lazy :s
06:44:34 <malcolmw_> ah, yes, with Lazy, (exactly 2 p) will return a cons (:) immediately, without looking to see if there are any elements
06:45:01 <ivanm> malcolmw_: so since I only want 2, doing satisfy isHexDigit twice should be OK?
06:45:48 <malcolmw_> ivanm: yes, I think so
06:45:57 <ivanm> seems to work...
06:45:58 <ivanm> \o/
06:46:09 <ivanm> malcolmw_: OK, I'll stop tempting fate by using exactly then ;-)
06:46:32 <malcolmw_> satisfy will fail in a way that can be caught, whereas lazy exactly will not
06:46:40 <ivanm> *nod*
06:47:16 * malcolmw_ wonders whether he ought to change exactly back to its previous definition, where it tried to parse an element before building the cons
06:47:53 <demolithion> oh
06:47:58 <demolithion> fc
06:50:22 <Gwern-away> ' For instance, the big application that people typically expand their Emacs-fu with is using Emacs to read mail (see also Zawinski’s Law of Software Envelopment). I recommend trying Gnus. The several weeks you waste trying to figure out how to point Gnus at your mail server more than pays for itself by the amount you learn while driving yourself mad. '
06:50:30 <Gwern-away> wow, that was exactly my experience wih gnus
06:50:35 <ivanm> Gwern-away: ummmm..... what?
06:50:39 <ivanm> relevance?
06:50:52 <Gwern-away> erm... gnus is written in a FP lang?
06:51:05 <ivanm> Gwern-away: I thought lisp was multi-paradigm...
06:51:16 <ivanm> and besides, it didn't take me that long to get gnus pointed at my mail server
06:51:24 <Gwern-away> elisp is no more multi-paradigm than java is
06:51:31 <Twey> ‘Lisp’ isn't a language
06:51:33 <ivanm> (the fact that I have never bothered to finish configuring it is a different story :p )
06:51:39 <Twey> elisp is an imperative language
06:51:45 <Twey> (mostly)
06:51:57 <ivanm> Twey: find, "I thought languages in the Lisp family were multi-paradigm..."
06:52:02 <ivanm> *fine
06:52:05 <ivanm> happy now? :p
06:52:24 <ivanm> Twey: but yes, I agree that it is mainly imperative
06:52:27 <Twey> ivanm: There's not much in common between the Lisp family members except an S-expr–based syntax
06:52:38 <ivanm> true
06:52:39 <Twey> There are very few statements that apply to all of them
06:53:17 <Gwern-away> how about they all were never very popular? :)
06:53:48 <ivanm> Gwern-away: well, Lisp did have it's hey-dey in the AI community, etc. ...
06:54:08 <ivanm> Twey: hmmmm.... wouldn't the original "Lisp" have been called "Lisp"?
06:54:15 <ivanm> so there _is_ a language known as Lisp :p
06:54:17 <Gwern-away> no, the original was LISP
06:54:22 <quicksilver> it is generally said that lisp is a functional language
06:54:37 <quicksilver> even though it has imperative features.
06:54:38 <Gwern-away> lisp is all the decadent lower-case descendants from LISP 1.5
06:54:54 <quicksilver> I suspect this mostly relates to the fact you can pass functions + closures around.
06:55:13 <Twey> It's no more functional than Perl, then
06:55:20 * quicksilver shrugs
06:55:22 <Twey> elisp doesn't even have closures
06:55:23 <Gwern-away> perl is pretty functional
06:55:30 <quicksilver> there's no point arguing with me about the way words are used, Twey
06:55:30 <Gwern-away> isn't there a _Functional Perl_ book?
06:55:32 <nvoorhies> I thought it was case insensitive
06:55:35 <quicksilver> I'm simply stating a fact.
06:55:40 * ivanm wonders if Lisp languages would have been more popular if they stuck with M-expressions...
06:55:43 <Twey> Gwern-away: Yeah.  That's the point.
06:56:03 <Gwern-away> on the other hand, perl is pretty anything, so maybe perl is just a degenerate example anything
06:56:05 <Twey> It's possible, but the primary way the language is used (or intended to be used, for that matter)
06:56:17 <Twey> s/but/but not/
06:56:22 <ivanm> Gwern-away: yeah, you can treat Perl as a functional language, but it isn't a functional language ;-)
06:59:36 <hackagebot> HsOpenSSL 0.6.4 - (Incomplete) OpenSSL binding for Haskell (MasatakeDaimon)
07:05:52 <harlekin> > "foobar" =~~ ".+" :: Maybe String
07:05:54 <lambdabot>   Just "foobar"
07:06:20 <benmachine> @hoogle =~~
07:06:21 <lambdabot> No results found
07:06:27 <harlekin> > "São" =~~ ".+" :: Maybe String
07:06:28 <lambdabot>   Just "S\227o"
07:06:37 <benmachine> @index (=~~)
07:06:38 <lambdabot> bzzt
07:06:39 <harlekin> > "São" =~~ "[^<>]+" :: Maybe String
07:06:40 <lambdabot>   Just "S\227o"
07:06:47 <benmachine> lambdabot: pardon?
07:06:57 <harlekin> Oo Any suggestions why my program is failing at this example but lambdabot isn't?
07:07:26 <harlekin> In ghci that function yields Just "S".
07:07:37 <harlekin> Using Text.Regex.Posix.
07:09:24 <quicksilver> harlekin: maybe your terminal - or whatever you are running ghci in - is mangling the encoding of that char.
07:09:36 <lilac> @type (=~~)
07:09:38 <lambdabot> forall source1 source (m :: * -> *) target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
07:10:57 <harlekin> quicksilver, it's failing on a String (obtained by curl) either. (That's the real application.) So it's probably curl's fault?
07:11:02 <lilac> huh. the types of the regexp and the matched string are unrelated
07:14:59 <quicksilver> harlekin: you probably need to decode the curl response according to what encoding it arrives it
07:15:12 <quicksilver> see the 'encoding' pacakge for example
07:15:12 <harlekin> quicksilver, ah. Okay.
07:16:08 <quicksilver> (quite likely utf8 but if it's a web page, web pages can choose their own encoding)
07:16:42 <Vanadium> They should not be allowed to
07:16:59 <zsol> I'm sure I'm not the only one to bump into this, but given a tree like structure defined as: data Tree = Node Int [Tree]; is it possible to somehow define a Functor instance for it?
07:17:15 <soupdragon> zsol no
07:17:22 <mmorrow> you mean to map (Int -> Int)'s over it?
07:17:25 <zsol> yeah
07:17:45 <mmorrow> you just have to make a mapTree :: (Int -> Int) -> Tree -> Tree
07:18:00 <zsol> well I could do that
07:18:07 <soupdragon> zsol why you hard coded Int into it?
07:18:44 <zsol> soupdragon: it's a bit complicated, nothing would make sense in the actual code in place of that Int
07:19:10 <soupdragon> complicated? no it's not
07:19:34 <soupdragon> are you talking about something else?
07:19:46 <zsol> yeah this is only a simplified snippet :)
07:20:02 <quicksilver> zsol: experience says : make it "Tree a = Node a [Tree a]"
07:20:05 <soupdragon>  what is the real thing?
07:20:14 <quicksilver> even if you never expect to use anything other than Int there
07:20:24 <quicksilver> it makes the code cleaner
07:21:24 <leimy> Vacuum is pretty amazing
07:21:42 <zsol> soupdragon: it's around line 49 of http://github.com/zsol/visual-graphrewrite/blob/24084001fb36773ba03ddbba1587f208d02753d0/GraphRewrite/Internal/RewriteTypes.hs#L49
07:21:51 <leimy> especially with ubigraph.
07:22:09 <zsol> quicksilver: that's true, I have tried refactoring the whole code to use type variables but it got out of hand :)
07:22:31 <soupdragon> yeah, mmorrow was right
07:22:49 <mmorrow> leimy: :)
07:23:00 <mmorrow> leimy: yeah, ubigraph is pretty friggin cool
07:23:11 <soupdragon> there's nothing you can do here
07:23:15 <zsol> I would sleep better if it'd be a Functor :)
07:23:18 <leimy> Sometimes I like the static drawing of the dump
07:23:27 <soupdragon> It's not
07:23:37 <EvilTerran> zsol, the point of making it "Tree a" is that that'd make it a Functor
07:23:50 <mmorrow> quicksilver: have you worked on your force-directed opengl graph viewer any further? ;)
07:23:51 <zsol> EvilTerran: I get that
07:24:23 <EvilTerran> as Functor types, to use the "containers" analogy, must be parameterised over the type of the things they contain
07:24:48 <mmorrow> leimy: (if your os has pthreads (had to use them in this one place..:/)), i've got this (which i'll eventually get around to putting on hackage)  http://moonpatio.com/repos/vacuum-gl/
07:25:12 <leimy> there is a vacuum open GL already no?
07:25:14 <zsol> well, mapTree it is then.
07:25:17 <mmorrow> leimy: it ffi's directly to the graphviz C code to get images, then it displays them with opengl
07:25:18 <leimy> or is this one animated as well?
07:25:30 <mmorrow> leimy: if there is already, it's news to me :)
07:25:31 <quicksilver> mmorrow: nope
07:25:36 <mmorrow> leimy: not animated, no
07:25:52 <leimy> http://hackage.haskell.org/package/vacuum-opengl
07:25:58 <quicksilver> I'm sure it's not as clever as ubigraph
07:26:05 <mmorrow> leimy: :o
07:26:09 <quicksilver> but it works sufficiently well
07:26:21 <quicksilver> that I suspect it wouldn't be hard to polish if someone wanted to ;)
07:26:23 <leimy> vacuum-opengl requires you to start a server first too.
07:26:26 <mmorrow> leimy: ah, it looks like that one talks to graphviz over a pipe
07:26:51 <leimy> mmorrow: possibly... I was using it yesterday, seemed pretty good :-)
07:27:02 <mmorrow> very cool :)
07:27:13 * quicksilver watches in pity as Baughn gets "welcomed" by the good inhabitants of ##c++
07:28:04 <mmorrow> leimy: also, my vacuum-gl is a graph viewer in general also (but i'm not sure if the code in that repo reflects this, i need to push..)
07:28:09 <mmorrow> leimy: http://moonpatio.com/vacuum/gallery/neato_vac.png
07:28:38 <leimy> That's very cool
07:28:52 <mmorrow> http://moonpatio.com/vacuum/gallery/pejo_1.png
07:29:02 <mmorrow> leimy: yeah, the neato one is pretty sweet
07:29:06 <leimy> I've got a somewhat resource constrained system that I'm going to have to develop a rather complex service on.
07:29:12 <leimy> and in a fairly short bit of time.
07:29:20 <leimy> I've been considering haskell for it.
07:29:25 <zsol> I'm actually doing something very similar to this
07:29:37 <mmorrow> leimy: cool. what sort of service?
07:29:53 <soupdragon> zsol, visualization?
07:29:55 <leimy> It would have to take serial traffic from a TCP/IP port, and then wrap it appropriately into a T-PDO stream for a CAN bus.
07:29:55 <EvilTerran> hm... given "data Tree a = Leaf a | Tree a :&: Tree a", would "return = Leaf; join (Leaf t) = t; join (l :&: r) = join l :&: join r" be a valid monad?
07:30:02 <zsol> soupdragon: yeah
07:30:06 <zsol> graph visualization
07:30:15 <EvilTerran> (given the usual definition of fmap, and m >>= f = join (fmap f m)
07:30:16 <leimy> which is basically an ASCII encoding for socketCAN
07:30:23 <quicksilver> EvilTerran: yes.
07:30:27 <leimy> it's the same CAN bus stuff they use in high end vehicles :-)
07:30:35 <leimy> and BWM motorcycles
07:30:42 <leimy> er BMW :-)
07:30:43 <leimy> lol
07:30:53 <soupdragon> EvilTerran, yeah "syntax with binding is monadic"
07:31:01 <zsol> mmorrow: can you point me to the graph viewer code in your vacuum-gl?
07:31:03 <EvilTerran> quicksilver, is it a useful monad?
07:31:07 <leimy> Anyway a heap viewer would be handy in deciding if my Haskell code was worth a damn :-)
07:31:13 <quicksilver> dunno :)
07:31:15 <soupdragon> you may as well throw in Lam
07:31:19 <leimy> as data growth seems to be where laziness kicks our ass  in data sizes.
07:31:30 * EvilTerran thought someone may've already found a use for it
07:31:32 <soupdragon> @go PHOAS
07:31:34 <lambdabot> http://adam.chlipala.net/papers/PhoasICFP08/
07:31:34 <lambdabot> Title: Parametric Higher-Order Abstract Syntax for Mechanized Semantics
07:31:36 <mmorrow> zsol: http://moonpatio.com/repos/vacuum-gl/ (although i've updated that pkg a bit, i'll push to that repo in like 10 minutes)
07:31:40 <soupdragon> ^ Evil
07:31:51 <zsol> mmorrow: thanks, digging in :)
07:31:56 <mmorrow> leimy: interesting
07:31:58 <EvilTerran> soupdragon, ah, yet another way of dealing with syntax! i'll add it to my collection :)
07:32:01 <mmorrow> zsol: no problem :)
07:32:34 <mmorrow> leimy: ooh, also the current vacuum (that i haven't uploaded to hackage yet..gah) has a vacuumLazy that actually works..
07:33:00 <mmorrow> leimy: i vacuumLazy will be totally complimentary to vacuum (regular that forces everything)
07:33:03 <soupdragon> also Conors PhD
07:33:03 <soupdragon> data Tree a = Leaf a | Tree a :&: Tree a --> data Tree a = Var a | Tree a :$: Tree a
07:33:04 <Twey> I'm having some trouble figuring out how to abstract this away: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2977#a2977
07:33:06 <soupdragon> gotta catch em all!
07:33:15 <mmorrow> (vacuumLazy thanks to int-e)
07:33:57 <mmorrow> leimy: resource constrained how?
07:34:01 <Twey> It *looks* like I should be using Either's monad instance, but combined with the wrapping of the adjust function that's not really possible
07:34:12 * EvilTerran notes "m >>= f = join (fmap f m)" can provide additional intuition into how a certain monad behaves
07:35:14 <EvilTerran> for instance, in the case of this Tree monad, it makes it pretty clear that "m >>= f" replaces each Leaf of m with a new subtree acquired from pushing that Leaf through f.
07:35:19 <leimy> mmorrow: about 512MB of RAM total in the system, and other processes already using it up.  Not a very fast CPU either by todays standards
07:35:24 <leimy> but otherwise it's an x86 machine.
07:35:43 <mmorrow> leimy: hmmmm
07:35:49 <leimy> AMD Geode based
07:35:52 <leimy> it's a little board.
07:36:01 <mmorrow> leimy: i'd ask people's opinion in #ghc about this
07:36:23 <leimy> well I've been perusing the language shootout's memory usage statistics
07:36:38 <leimy> and sometimes Haskell isn't bad, and sometimes it's way bad compared to say C++
07:36:44 <hackagebot> control-monad-queue 0.0.9.2 - Reusable corecursive queues, via continuations. (LeonSmith)
07:36:55 <leimy> but there seems to be a bit of art to getting haskell to control memory utilization well.
07:37:11 <mmorrow> leimy: what are the consequences (if any) if something unexpected happens and the machine starts swapping?
07:37:21 <mmorrow> (like, no one dies hopefully, right? :)
07:37:21 <leimy> mmorrow: we have no swap man :-)
07:37:26 <leimy> it's a flash filesystem
07:37:27 <leimy> :-)
07:37:32 <mmorrow> ah
07:37:41 <leimy> I think the proc would just get OOM killed by linux
07:37:52 <leimy> and what would happen is a lot of folks would lose serial consoles :-)
07:38:05 <mmorrow> leimy: ah, hmm
07:38:11 <leimy> well to a point
07:38:42 <leimy> there's some backup.  The hardware I'd be talking to can keep a ring buffer of about 8k
07:39:04 <leimy> maybe more, we're still in design here. :-)
07:39:14 <leimy> I'm worried about deadlines, happy customers, and less fail!
07:39:24 <leimy> hence my turning to functional programming for the task :-)
07:39:38 <leimy> If I don't do it in Haskell it will probably get done in Erlang
07:39:51 <mmorrow> leimy: i'd totally do it in haskell, that is what you have to write can operate under those memory constraints
07:39:58 <mmorrow> *that is if what ..
07:40:02 <leimy> right
07:40:06 <Baughn> quicksilver: Eh, they're not /that/ bad.
07:40:18 <leimy> Well careful choice of data structures make Haskell a bit easier on the RAM :-)
07:40:23 <leimy> and careful choice of accessing those.
07:40:30 <leimy> Sometimes you've just got to be strict. :-)
07:40:47 <leimy> I think vacuum would help a bit there.
07:40:52 <leimy> in seeing the growth
07:41:10 <leimy> but it's a visualization, not a quantification... there's other ways to do that though :-)
07:41:11 <mmorrow> leimy: and since it seems like this would be a "stream processor", you shouldn't have to much in memory at any one point (?)
07:41:53 <leimy> well there's a little bit of book keeping to do.
07:42:07 <leimy> how many open connections, how much total bandwidth to support baud rates.  And baud limiting decisions
07:42:16 <leimy> There may not be much state at all actually :-)
07:42:30 <leimy> however, I will be very interested to see how that new hackage serial module is working before I decide too :-)
07:42:59 <mmorrow> leimy: this sounds interesting, i'd love to hear about what you end up deciding to do
07:42:59 <leimy> http://hackage.haskell.org/package/serial
07:43:07 <leimy> sadly... that package appears to be LGPL.
07:43:17 <leimy> and who knows how that works before Haskell has shared libs.
07:43:27 <mmorrow> leimy: do you have experience with haskell ffi?
07:43:35 <leimy> Just enough to be dangerous.
07:43:37 <mmorrow> leimy: it's really great
07:43:39 <mmorrow> leimy: hehe
07:43:46 <leimy> I really only need "write" and "read" and "open" and "close"
07:43:58 <leimy> Yeah the GHC FFI is particularly nice.
07:44:06 <leimy> I'd have to get intimate with it.
07:45:52 <leimy> anyway, it's just a thought right now.  I might get overruled on this idea. :-)
07:46:04 <leimy> May end up having to do it in C++ :-(
07:46:27 <leimy> the concern being that we just don't have enough Haskell programmers at the company (just me)
07:47:54 <inimino> leimy: what you do want to do with it that the LGPL would prevent?
07:47:57 <leimy> anyway, I have to write the design document for this system (high level only) today.
07:48:04 <leimy> inimino: distribute binaries without sources :-)
07:48:06 <mmorrow> leimy: good thing you won't need many people to write it, since it'll be super short an elegant, being in haskell and all ;)
07:48:16 <inimino> leimy: ah
07:48:28 <leimy> mmorrow: I think it's the "bus syndrome" issue the company is worried about.
07:48:40 <mmorrow> leimy: tell them you're invincible
07:48:46 <leimy> mmorrow: "but I'm immortal!"
07:48:47 * inimino is mildly disappointed people still feel the need to do that
07:48:47 <mmorrow> ;)
07:48:52 <mmorrow> leimy: yes that too!
07:50:06 <leimy> inimino: yeah me too, but it's totally not up to me :-(
07:50:41 <leimy> I find it disappointing people feel they need the GPL and it's variants to get source code for free
07:50:46 <leimy> BSD has proven that not to be the case
07:51:04 <leimy> GPL is "free source" via many restrictions.
07:51:11 <leimy> BSD is "free source" with nearly no restrictions.
07:51:27 <gery> dear Haskell community, i need your  help. I need a function which takes an integer n and a list l, and returns the list l "splitted" each n elements. For example f 2 [1,2,3,4,5,6] = [[1,2],[3,4],[5,6]]. Couldn't find it on hoogle. Anyone has an idea?
07:51:32 <leimy> I tend to like having more degrees of freedom when using code than restrictions just to get the source.
07:51:40 <Botje> gery: look at Data.List.Split
07:52:02 <leimy> gery: homework? :-)
07:52:07 <PeakerWork> leimy: are restrictions on restricting equal to restrictions on non-restricting things? I think not, so I don't find GPL "restricting" at all, it merely restricts those who restrict, no-one else :)
07:53:18 <PeakerWork> I think people who think open-source and closed-source should co-exist generally prefer BSD as "more free", and people that believe the very idea of closed-source goes against freedom itself feel that the GPL guarantees more freedom overall
07:53:19 <leimy> PeakerWork: That's a valid point.  However, I'm not writing a derivative work in my idea of derivative works... I'm just calling a library.  Technically the linux kernel itself is a giant shared lib.  And the GPL could be interpreted to disallow any non-GPL programs at all :-)
07:53:21 <gery> no, i'm writing a program to compute some algebraic topology stuff for my research. But I just learned Haskell a few days ago
07:53:23 <Raevel> well, restrictions on restricting is equally bad in some situations
07:53:50 <PeakerWork> leimy: Yeah, I found the legal difference between a syscall interface and an API very weird too
07:53:56 <leimy> yep
07:54:10 <PeakerWork> Raevel: depends on whether you accept those latter restrictions as valid in any situations or not
07:54:10 <leimy> So I think GPL people should write all their own OpenSSH replacements NOW!
07:54:22 <leimy> because the BSD isn't GPL, and the GPL says it must be GPL to interface GPL :-)
07:54:26 <PeakerWork> leimy: no need, you can just re-license an OpenSSH fork as GPL :)
07:54:43 <PeakerWork> leimy: I think the GPL is compatible with non-GPL opensource licenses
07:54:43 <leimy> PeakerWork: the author(s) of OpenSSH would not do it :-)
07:54:55 <gery> ok, i couldn't find Data.List.Split, but i found Data.List.SplitAt. It's not exactly what i want, but i guess i can adapt it
07:54:58 <leimy> PeakerWork: if that's the case I'll release my code as BSD and not give source.
07:55:08 <leimy> see it's a quagmire of bullshit after about 10 minutes of thinking about it.
07:55:12 <Japsu> leimy, there is a GNU implementation of SSH called lsh. :P
07:55:14 <Botje> split is a non-standard package
07:55:19 <leimy> Japsu: there you go :-)
07:55:32 <Japsu> (it was horrible when I tried it back in 2004)
07:55:35 <Botje> gery: http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
07:55:37 <leimy> There is YaSSL with an OpenSSL compatibility layer too.
07:55:44 <Botje> you'll have to install the split package for that, though
07:55:46 <inimino> leimy: that's not what the GPL says
07:55:51 <inimino> "the GPL says it must be GPL to interface GPL" I assume you know that's actually wrong
07:55:57 <PeakerWork> Data.List.Split uses a "list builder" instead of difference lists, anyone know why?
07:56:01 <gery> hmmm, ok. Thank you
07:56:02 <Botje> or you can just take a look at the source code and steal the code for chunk
07:56:09 <leimy> inimino: No I don't.  The GPL says that you have to make derivative works GPL.
07:56:17 <leimy> and it says "Calling a library is a derivative work
07:56:18 <leimy> "
07:56:22 <PeakerWork> gery: http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
07:56:25 <gery> that's what i'll do, Botje
07:56:27 <PeakerWork> oops, sorry, missed Botje
07:56:29 <leimy> so if the kernel is a giant shared lib... you have to make all your code GPL don't you?
07:56:36 <Botje> PeakerWork: reload and shoot again! :)
07:56:39 <PeakerWork> leimy: no, just open-source all of it :)
07:56:42 * leimy is not a lawyer, but did have 18 credits of philosophy in college :-)
07:56:49 <inimino> leimy: no and no
07:57:09 <PeakerWork> leimy: but the law distinguishes syscall API's from library API's. I see the reasoning about POSIX, but less-so about Linux-specific syscalls
07:57:14 <leimy> PeakerWork: I'll look for the "compatible free software license" clause in the GPL next time I'm bored enough to watch my fingernails grow.
07:57:19 <Zao> So if I call my library to reserve a book, what happens?
07:57:47 <leimy> PeakerWork:  oooh good point.  If I call "clone" am I in trouble?
07:57:50 <inimino> just don't spread FUD in the meantime, that's all I ask ;-)
07:58:10 <leimy> inimino: so explain to me what it is... since you know better.
07:58:15 <PeakerWork> leimy: again, no, sys-call interfaces somehow don't carry over GPL requirements like normal library API's do
07:58:26 <leimy> inimino: This isn't FUD, this is pretty much my understanding of the GPL.
07:58:27 <PeakerWork> leimy: I don't know why, but it is so
07:58:43 <Zao> The license applies, except where it doesn't as it would be inconvenient.
07:58:50 <PeakerWork> leimy: people "circumvent" the GPL by wrapping a library with a command line utility and calling it via system APIs
07:58:57 <inimino> leimy: are you genuinely confused about the kernel?
07:59:20 <leimy> inimino: no I'm confused about the GPL and how it applies to the kernel.
07:59:42 <Plouj-> http://simswyeth.com/blog/wp-content/uploads/fud.jpg
07:59:46 <inimino> leimy: anyway, there are plenty of documents explaining how this all works written by people much more intimately acquainted with the details than I
07:59:48 <leimy> also why someone would choose LGPL when they know there's no shared libraries in Haskell yet.
07:59:49 <inimino> leimy: the kernel is not a shared library.
08:00:02 <leimy> inimino: oh but in principle it is the "most shared" library.
08:00:10 <leimy> you know how kernels work right?
08:00:16 <leimy> it's just a different calling convention.
08:00:34 <Zao> leimy: Heavens forbid that one would want to make money on Haskell applications.
08:00:34 <leimy> Plouj-: awesome picture.
08:00:44 <kulakowski> leimy: I'm curious, how much of this has seen a courtroom, and how much is what the FSF lawyers say is true?
08:00:47 <inimino> leimy: if you think "in principle" has anything to do with the law, you're ever more confused than was at first apparent
08:00:55 <dschoepe> I'm still struggling with Reactive: I have a value of type Behavior Foo and a function Foo -> Behavior Bar. How do I "pipe" the result of the first function into the second(<*, *>, $> and the like should be useless, because I don't want to discard any results)?
08:00:57 <leimy> kulakowski: I have no idea... I'm not a lawyer :-)
08:01:03 <Twey> gery: Data.List.Split.chunk does exactly what you want
08:01:08 <leimy> I'm just very confused by the GPL, and I honestly think the FSF likes it that way.
08:01:20 <leimy> because then they can FUD you into GPLing everything :-)
08:01:23 <leimy> or sue your ass.
08:01:30 <soupdragon> inimino: Don't belittle
08:01:33 <pikhq> kulakowski: Not all that much; people have the tendency to settle out of court.
08:01:33 <leimy> Seems like the FUD goes both ways to me :-)
08:01:40 <pikhq> leimy: No strawmen, please.
08:01:47 <inimino> anyway, you can read about it if you want to be less uninformed than you are now, documents abound
08:01:57 <PeakerWork> dschoepe: unfortunately Behavior is not a Monad, so I don't think that you can
08:02:00 <leimy> inimino: the law is constantly re-evaluating itself.  As is the function of the judicial system.
08:02:02 <quicksilver> dschoepe: you can't, because we can't write the monad instance for Behaviour.
08:02:05 <inimino> soupdragon: purely honest advice :-)
08:02:17 <quicksilver> dschoepe: however, if you change your "Foo -> Behaviour Bar" into "Behaviour (Foo -> Bar)"
08:02:22 <kulakowski> Also this seems like #haskell-blah territory
08:02:23 <leimy> pikhq: Yeah fair enough that was a weak argument
08:02:25 <quicksilver> dschoepe: (which is normally just a simple reordering of the syntax)
08:02:27 <PeakerWork> quicksilver: why not, btw? Pull behaviors are easy. Push behaviors are possible,  Pull into push and push into pull I think are workable too
08:02:35 <dschoepe> quicksilver: Okay, I'll try.
08:02:37 <quicksilver> dschoepe: then you can just use <*>
08:03:05 <quicksilver> PeakerWork: I don't think there is a deep reason which applies to all possible reactive implementations
08:03:12 <leimy> inimino: Let me put it to you this way.  We used to discuss shared libraries a good deal in the Plan 9 circles.  It was decided that really one could compose a ton of stuff out of the primitives the plan 9 kernel provided because they were pretty well thought out.  And that the kernel really IS just a giant shared library.  That's what the community basically decided.
08:03:13 <quicksilver> PeakerWork: just, a reason which applies to conal's.
08:03:29 <dschoepe> Are the problems with writing a monad instance technical or is there some theoretical reason, that this isn't possible?
08:03:30 <soupdragon> inimino: telling someone that is asking for clarification "you're confused" seems mean to me
08:03:48 <quicksilver> Baughn: I can't imagine much worse without them actually geolocating your IP address and pissing through your letterbox
08:03:51 <PeakerWork> quicksilver: why is applicative easier than monad?  combining behaviors seems to be the difficult part, join just needs to "re-do" it at every outer behavior change?
08:03:54 <quicksilver> Baughn: but perhaps you're right ;)
08:04:08 <leimy> soupdragon: it's a very religious approach to describing something.  Don't give facts, just insist the questioning person is confused.
08:04:09 <quicksilver> PeakerWork: join can't work out which are the discrete parts of the behaviour
08:04:44 <PeakerWork> quicksilver: only when its a pull behavior, right? in which case you can just result in a pull behavior, so you don't need to?
08:04:47 <inimino> soupdragon: well, I get annoyed when people spread nonsense that they could easily clear up by doing a little reading
08:05:00 <leimy> inimino: A little reading?  You think I've not read the GPL?
08:05:07 <leimy> I've even got books on software licensing I've been over.
08:05:10 <leimy> I'm still confused.
08:05:20 <leimy> they cover the GPL, but they don't agree with other things I've read
08:05:20 <pikhq> leimy: ISTR that Linux itself is GPL with an exception allowing non-GPL-compatible software to interface with Linux through delineated common interfaces.
08:05:33 <leimy> pikhq: Ah! that would do it. :-)
08:05:42 <pikhq> (the syscall interface and a subset of the module API)
08:05:45 <desp> Does anyone have a copy of http://www.scannedinavian.org/cgi-bin/darcs.cgi/hlibs/physics/?c=browse (as featured on http://www.haskell.org/haskellwiki/DimensionalizedNumbers)?
08:05:47 <inimino> leimy: either you've not read it, or you've come to conclusions different from those the FSF has come to
08:05:49 <leimy> pikhq: much like the way some bits of GCC work?
08:05:57 <pikhq> leimy: Yeah.
08:06:02 <quicksilver> GPL discussions to -blah please
08:06:05 <leimy> pikhq: that actually explains a lot!
08:06:06 <pikhq> (and glibc)
08:06:11 <quicksilver> or, in fact, almost anywhere in cyberspace except here.
08:06:20 <leimy> quicksilver: agreed. :-)
08:06:28 <leimy> let's just knock it off and get back to Haskell love :-)
08:06:56 <Zao> map love haskell
08:07:31 <leimy> or
08:07:34 <PeakerWork> use fmap, Haskell is not necessary a list
08:07:38 <leimy> map (love haskell)
08:07:42 <leimy> in point fre stile
08:07:46 <leimy> er style
08:07:50 <leimy> and free :-)
08:07:50 <soupdragon> ???
08:07:53 <badsheepy> is there a way of making ghci always recompile with optimisations? i did -fobject-code and -set -O but its an order of magnitude slower than ghc -O
08:08:05 <pikhq> Use .; fmap should be called that.
08:08:11 <leimy> heh
08:08:19 <twanvl_> use <$>, fmap shouldn't be called .
08:08:37 <pikhq> twanvl_: But not all functors are applicative functors!
08:08:45 <PeakerWork> pikhq: not clear -- should (.) be in Functor or Category?
08:08:53 <PeakerWork> @type (<$>)
08:08:54 <pikhq> PeakerWork: Curses.
08:08:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:08:57 <dschoepe> quicksilver: Am I missing something or does this mean, I have to rewrite all the (y -> Behavior x) functions in my f :: Behavior (Foo -> Bar), as well?
08:09:06 <mmorrow> zsol: ok, pushed http://moonpatio.com/repos/vacuum-gl/
08:09:18 <pikhq> @src (<$>)
08:09:19 <lambdabot> f <$> a = fmap f a
08:09:26 <pikhq> Ah.
08:09:38 * pikhq is never using . or fmap again.
08:09:39 <pikhq> :P
08:10:36 <mmorrow> zsol: so the graph-viewing functions are (kinda been adding to this module as i've needed a particular input graph type, so it could use some cohesive design...) http://moonpatio.com/repos/vacuum-gl/haddocks/System-Vacuum-OpenGL.html
08:11:17 <mmorrow> zsol: and it's IMPORTANT that you only use one of these in any one prog/ghci session (OpenGL's fault) :)
08:12:59 <mmorrow> zsol: also the opengl viewer's controls could use some work as well
08:13:49 <mmorrow> (err, i guess what they are are undocumented, but they should be apparent from the code (sry ;))
08:14:11 * lilac poinders (.) for Functor plus ($) :: CoPointedWith b f => f a -> b -> a
08:14:34 <lilac> instance CoPointedWith Int [] where ($) = (!!)
08:16:14 <EvilTerran> lilac, or, with associated types, ($) :: f a -> Index f -> a ?
08:16:46 <mmorrow> hmm, actually the fact that you can use only one of those view* functions at any one time is my fault (should have them all wired to *the same* Q..)
08:16:47 <lilac> EvilTerran: i was wondering whether we need to restrict 'b' to a single type
08:16:53 <PeakerWork> pikhq: id and (.) are nicer in Control.Category than in the Prelude anyway
08:17:21 <EvilTerran> lilac, i guess you may want to have more than one "indexing" type for a "collection" type
08:17:34 <PeakerWork> Why are associated types considered better than fundeps? The code is typically longer, and the relationship is clear in the fundep?  Maybe instead of 1-letter type-variables we could use a descriptive name instead?
08:17:40 <lilac> i think in practice we usually only want one, so an associated type / fundep is probably fine
08:17:51 <EvilTerran> lilac, but, otoh, restricting it to only one would reduce the potential need for type sigs
08:18:02 <EvilTerran> and you can always newtype-wrap if you want more than one]
08:18:08 <Beelsebob> Peaker: I find AT code *much* clearer than fundep code
08:18:16 <PeakerWork> Beelsebob: why?
08:18:16 <quicksilver> dschoepe: possibly.
08:18:17 * EvilTerran prefers fundeps to AT's syntactically, but not semantically.
08:18:30 <Beelsebob> Peaker: it's much clearer which way round the definition goes
08:18:38 <quicksilver> PeakerWork: ATs are much more expressive.
08:18:44 <quicksilver> or, to be scrupulously accurate
08:18:56 <quicksilver> ATs enable you to express things *easily* which FDs make *very* fiddly.
08:18:56 <PeakerWork> class Blah a bleh | a -> bleh where            VS.   class Blah a where type Bleh a
08:19:02 <PeakerWork> quicksilver: example?
08:19:04 <dschoepe> quicksilver: So is the missing monad instance just a matter of someone figuring out how to do it, or is Behavior not really a monad?
08:19:15 <PeakerWork> dschoepe: former, not latter
08:19:17 <lilac> dschoepe: semantically it's a monad
08:19:22 <quicksilver> PeakerWork: anything more complex than class Foo a b | a -> b, really ;)
08:19:27 <dschoepe> Ah, okay. Thanks
08:19:32 <quicksilver> dschoepe: it's "obviously" a monad really.
08:19:38 <quicksilver> dschoepe: it's just implementation issues :(
08:19:41 <PeakerWork> quicksilver: well, type vs data is   a -> b   vs   a -> b, b -> a
08:19:50 <Beelsebob> Peaker: the latter I would say much more clearly says "this is about the type a, the Bleh a bit of it is just something we need to determine for the a"
08:19:56 <PeakerWork> quicksilver: All the ~ fiddling makes for really long code
08:19:58 <Beelsebob> while the first one says "this is something about a pair a bleh"
08:20:01 <Beelsebob> which is not true
08:20:04 <PeakerWork> quicksilver: as opposed to just mentioning the type variable
08:20:06 <quicksilver> dschoepe: since (Behaviour a) is really (Time -> a), in a sense.
08:20:09 <Beelsebob> bluh is not as important as a in that equation
08:20:22 <PeakerWork> Beelsebob: But its often not clear what is the "important" part
08:20:26 <quicksilver> dschoepe: ...and Time -> is certainly a monad.
08:20:27 <PeakerWork> Beelsebob: so that's not necessarily an advantage
08:20:31 <lilac> how do you do this with ATs? class Foo a b c | a b -> c, c -> b
08:20:35 <Beelsebob> quicksilver: fwiw, I do have a monad implementation for behaviors
08:20:38 <Beelsebob> but it's an ugly hack
08:20:41 <Beelsebob> and I think it space leaks
08:20:42 <dschoepe> Okay, that makes sense
08:20:57 <quicksilver> dschoepe: also note how this intuition justifies the switch from (a -> B b) to (B (a -> b))
08:21:02 <Beelsebob> Peaker: I've not come across that situation yet
08:21:07 <quicksilver> dschoepe: if B b is really (T -> b) then...
08:21:15 <quicksilver> dschoepe: (a -> T -> b) is the same type as (T -> a -> b)
08:21:27 <Beelsebob> Peaker: there's a one to many relationship
08:21:31 <dschoepe> Beelsebob: Cool, would you mind sharing it?
08:21:35 <quicksilver> so in principle it should always be easy to turn your (a -> B b) into B (a -> b)
08:21:38 <Beelsebob> that tells you which way round it must be
08:21:38 <dolio> lilac: That type of thing is ugly with ATs. But you can desugar it into them if you only want to use one or the other in the implementation.
08:21:49 <Beelsebob> dschoepe: it's rather too ugly and experimental for me to trust I think :/
08:22:02 <Beelsebob> dschoepe: it involved sampling at random in behaviours
08:22:03 <dschoepe> Beelsebob: I'm willing to test it though
08:22:07 <Beelsebob> (hence why I'm guessing the space leak)
08:22:48 <dschoepe> quicksilver: Thanks
08:22:59 <PeakerWork> Beelsebob: I tried to convert this fundep http://github.com/yairchu/generator/blob/73a518dd0a3a90ad14abff11a32332e5bc4efca2/src/Data/List/Class.hs   to an indexed type instead. It was pretty difficult, requires ~ in super-classes (which don't exist yet), requires a lot more code everywhere, and breaks the types of some stuff
08:23:06 <PeakerWork> Beelsebob: but its just a first attempt :)
08:27:08 <quicksilver> PeakerWork: isn't that just class List l where type MonadOfTheList :: * -> * ?
08:27:28 <PeakerWork> quicksilver: yeah, I tried doing that
08:27:50 <PeakerWork> quicksilver: didn't work very well, you can try too :)  Saizan says that it crashed ghc with an internal error
08:27:57 <dolio> Type families are also less likely to require undecidable instances, due to their termination checks.
08:29:00 <dolio> For instance, mtl no longer requires undecidable instances if you switch to associated types.
08:30:01 <quicksilver> PeakerWork: I don't have time to try, but if it does, that's a bug in GHC, not a failing of dependent types.
08:30:05 <quicksilver> !
08:30:09 <fraktil> Do many of you find that Project Euler helps you learn haskell or would you recommend practicing with different exercizes?
08:30:10 <quicksilver> s/dependent/associated/
08:30:12 <PeakerWork> quicksilver: of course, I said that as a btw
08:30:26 <PeakerWork> quicksilver: its not the only problem - it also somehow broke the type inference
08:30:32 <PeakerWork> quicksilver: or types of a function
08:30:41 <PeakerWork> quicksilver: I hoped I'd only have to change type signatures, not function bodies
08:30:46 <quicksilver> well, I believe it's the right answer.
08:30:51 <jkff> fraktil: It helps, although to a limited extent
08:30:55 <quicksilver> you may have to add MonadPlus signatures areound somewhere
08:31:01 <dschoepe> fraktil: For the basics it's useful imo, but later it's more about math than about programmming
08:31:11 <quicksilver> because I don't think you can add that into the associated type in any way
08:31:38 <PeakerWork> As for longer code,  if I had:  instance List m (ListT m a) => where ...   now I need:  instance (Monad m, ListMonad (ListT m a) ~ m) =>
08:31:56 <pikhq> fraktil: It only helps in that it's an excuse to code.
08:32:08 <PeakerWork> quicksilver: It wasn't missing contexts, it was ambiguous types
08:32:18 <PeakerWork> quicksilver: despite the relationship being the same afaiu
08:32:29 <pikhq> That *is* helpful, but not any more so than, say, running through Wikipedia's list of data types and sorting algorithms and writing all of them.
08:32:40 <PeakerWork> quicksilver: List l m | l -> m    vs  List l   and   type ListMonad l :: * -> *
08:33:01 <quicksilver> odd.
08:33:47 <PeakerWork> quicksilver: maybe that too was a ghc bug, it was around the same place with the internal errors. Saizan probably understands it better than I do
08:39:08 <dolio> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6981#a6981
08:39:39 <dolio> Which part didn't work?
08:40:11 <desp> Is it possible to define a new (*) function (as described in http://www.haskell.org/haskellwiki/Functional_dependencies ) and have it play nicely with the existing Num type class?
08:42:10 <quicksilver> dolio: ooh, I didn't know you were allowed to put class contexts for associated type families in the class head.
08:42:29 <quicksilver> dolio++ # associated-fu
08:43:14 <quicksilver> dolio: on that note, is this valid? : instance (a ~ b) => Monoid (a -> b) where mempty = id; mappend = (.);
08:44:00 <dolio> Not really sure.
08:44:12 <mmorrow> quicksilver: i know this is valid (dunno the relevance here though):
08:44:13 <dolio> Equality superconstraints are still unimplemented, right?
08:44:20 <quicksilver> dunno.
08:44:30 <quicksilver> it would be nice to be able to write that instance with the Endo newtype, that's all.
08:44:41 <mmorrow> data Foo a b where Foo :: (a ~ b) => Foo a b
08:44:49 <quicksilver> seems like the general explicit equality constraints language ought to permit it.
08:45:00 <mmorrow> (or some variation, the point being it's valid for GADT cons)
08:45:03 * quicksilver nods
08:45:10 <mmorrow> that makes me think it'd be valid for classes
08:45:27 <mmorrow> since you can essentially hide class constraints in constraints on GADT cons
08:46:29 <mmorrow> like data M k v where M :: (Ord k) => Map k v -> M k v; foo :: M k v -> ... {- no need for the Ord constraint -}
08:47:33 <quicksilver> mmorrow: yes, as long as that is the only constructor.
08:47:39 <quicksilver> it used to work for normal constructors in GHC too
08:47:40 <mmorrow> ah, true
08:47:48 <quicksilver> but that was a bug, because it was non-h98 compliant
08:47:56 <mmorrow> ah, interesting
08:47:56 <quicksilver> I know because I was the spoilsport who reported it ;)
08:48:01 <mmorrow> grrr
08:48:03 <mmorrow> :)
08:48:15 <quicksilver> h98 explicitly permits constraints on constructors and yet makes them useless
08:48:24 <quicksilver> (not giving back their constraing on pattern match)
08:48:30 <quicksilver> I think it is probably merely an oversight.
08:49:04 <mmorrow> or a conspiracy!
08:49:08 <quicksilver> still I quite like the idiom of leaving things parametric and only having constraints on those primitives which need it.
08:49:23 <mmorrow> yeah, true
08:49:29 <Baughn> Say, was there a "can't-derive-instances-on-GADTs" bug?
08:49:30 <quicksilver> surprisingly often I find an occasional use for the parametric version
08:49:40 <quicksilver> Baughn: yes
08:49:45 <mmorrow> Baughn: i think that's just a lack of it being implemented
08:49:48 <quicksilver> well it's not really a bug
08:49:52 <quicksilver> it's a known shortcoming ;)
08:50:08 <twanvl_> the h98 'stupid' contraints are on types, not on contructors, right
08:50:14 <Baughn> It's a bit odd, though. I don't quite see how GADTs make deriving harder
08:50:23 <Baughn> ..probably I don't understand them well enough. I should play around more.
08:50:47 <mmorrow> Baughn: because the type of the constructor doesn't need to have anything to do with the types it contains
08:50:50 <quicksilver> twanvl_: IIRC both are permitted.
08:50:58 <quicksilver> twanvl_: but neither is particularly useful.
08:52:29 <mmorrow> Baughn: but yeah, it's definitely possible
08:53:05 <mmorrow> Baughn: err, actually Read isn't possible for (all?) real GADTs
08:53:18 <mmorrow> because haskell would need dependent types for that
08:53:46 <mmorrow> err wait, maybe it is
08:53:48 <quicksilver> I"m not sure that's true.
08:53:53 <quicksilver> it's possible, it's just hard to make it useful.
08:53:58 <mmorrow> hmm
08:54:02 <quicksilver> you'd have to fix the type with context
08:54:12 <quicksilver> (read :: String -> Foo Int)
08:54:22 <quicksilver> and if the String didn't appear to have a constructor which was valid for ints
08:54:27 <quicksilver> that would have to be a runtime error
08:54:44 * quicksilver ponders more
08:54:52 * quicksilver 's brain asplode
08:54:53 <mmorrow> data Foo a :: A :: Tree Double -> Foo Int; B :: Foo (Foo ()) -> Foo Int
08:55:00 <mmorrow> yeah, mine just did too
08:55:59 <mmorrow> data Foo a :: A :: Foo a -> Foo (a,a) -- :o
08:56:11 * nlogax picks up the pieces and eats them, hoping to absorb the knowledge
08:56:11 <twanvl_> read :: String -> exists a. Foo a
08:56:33 <mmorrow> twanvl_: but then that's not `read' :(
08:56:51 <mmorrow> (and you'd need another datatype since GHC doesn't do exists :(
08:57:20 <mmorrow> (and you could never get the Foo a out of the existential box :(
08:57:28 <mmorrow> and mmorrow whines some more
08:57:42 <mmorrow> :)
09:00:25 <dolio> instance Read (Foo Int) where read ('A':' ':s) = A (read s) ; read ('B':' ':s) = B undefined ; read _ = undefined
09:00:46 <mmorrow> hmm, in the case where you have (data A a where One :: () -> A Int; Two :: Tree () -> A Int; Three :: a -> A a), you'd need try to parse an (), Tree (), or an Int
09:02:01 <mmorrow> which is guess isn't a problem
09:02:52 <mmorrow> yeah, ok i think Read is actually doable
09:03:09 <mmorrow> dolio: what are you saying by that?
09:03:19 <dolio> I'm saying you can write it.
09:03:24 <mmorrow> ah, ok
09:03:30 <dolio> Although the B case is questionable.
09:03:31 <mmorrow> hmm
09:03:40 <dolio> But there are no Foo (Foo ())s other than undefined.
09:03:46 <mmorrow> oh yeah, true
09:04:09 <dolio> So I just assumed that s appropriately encoded undefined. :)
09:06:29 <mmorrow> so the reason that i thought Read wouldn't be possible for GADTs, is that at one point i came across the situation where i needed to /parse/ an expression :: String (from some language) to a pre-defined GADT, and iirc *that* was what was impossible (without dependednt types) due to the structure of the GADT
09:07:08 <mmorrow> but yeah, since *you* determine the type of the result, not the value of the String, Read should work (in the cases where it works..)
09:07:15 <mmorrow> (?)
09:07:44 <dolio> You don't need GADTs to have a problem with strings determining the type of the result of read.
09:08:17 <dolio> read "5" doesn't figure out that its type should be Integer, for instance.
09:08:34 <mmorrow> yeah true, but i mean this particular situation was having a javascript parser that parsed to a non-GADT, and wanting to translate that datatype to a (real) GADT, and starting from a String..
09:09:03 <mmorrow> so "function(x){return x}" :: Exp (a->a)
09:09:37 <mmorrow> parse "function(x){return x}" ==> FunE ["x"] (ReturnS (VarE "x"))  (e.g.)
09:09:47 <mmorrow> (FunE being from the non-GADT)
09:09:55 <mmorrow> parse :: String -> JsExp
09:10:22 <mmorrow> and then the value of a particular JsExp would have to determine the type of the resulting GADT value
09:10:42 <mmorrow> (although i guess you could hide it with an existential, which i didn't think of at the time)
09:11:35 <iago> someone understand this?
09:11:36 <iago> Prelude> let (|<=|) = (<=)
09:11:36 <iago> Prelude> :t (|<=|)
09:11:36 <iago> (|<=|) :: () -> () -> Bool
09:11:36 <iago> Prelude> :t (<=)
09:11:36 <iago> (<=) :: (Ord a) => a -> a -> Bool
09:11:44 <mmorrow> the existential option seems pretty decent actually
09:11:55 <dolio> monomorphism restriction
09:12:01 <ski> iago : defaulting, plus DMR
09:12:01 <iago> ops
09:12:02 <iago> yeah
09:12:20 <iago> thanks
09:13:19 <mmorrow> data Exists ty = forall a. Exists (ty a); class ReadExists ty where readExists :: String -> Exists ty
09:13:29 <mmorrow> or something maybe
09:14:48 <quicksilver> mmorrow: clever. Does that work?
09:14:57 * mmorrow is trying it now :)
09:15:25 <soupdragon> ty has to be a tycon
09:15:47 <soupdragon> (not any * -> *, which sucks)
09:15:53 <quicksilver> soupdragon: which means the defn of Exists gets rejected?
09:15:59 <soupdragon> ni
09:16:01 <soupdragon> no*
09:16:02 <quicksilver> or only if you try to use it on a non-tycon?
09:16:53 <soupdragon> It's just you can't infer things like x -> x
09:17:35 * quicksilver nods
09:19:28 <lilac> mmorrow: isn't the problem with Read that you need overlapping instances? consider 'data T a where I :: Int -> T Int; A :: a -> T a'. we can write instances for 'Read (T Int)' and 'Read (T a)' but they overlap
09:19:51 <ski> well, `ty' can be any type expression, right .. it's just that you can't lambda abstract
09:31:52 <mmorrow> quicksilver: wow, it does work http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6983
09:32:08 <mmorrow> although i think that (ListE :: [Exp a] -> Exp [a]) could be a problem
09:32:47 <mmorrow> since you'd have to unpack the Exists that you parse for each elt of the list, but you have no way of ensuring they're all the same type
09:33:04 <mmorrow> i guess you'd have to do
09:33:20 <mmorrow> ListE :: [Exists Exp] -> Exp [???]
09:33:58 <mmorrow> lilac: yeah, that'd be a problem too
09:38:04 <mmorrow> well, for the ListE case, i guess you could parse the first Exp, then use a function (Exp a -> ReadP (Exp a)) to get the correct parser you need, then parse the rest of the list with that
09:38:36 <mmorrow> you may need unsafeCoerce though to be able to unpack all the Exists you get back and stick them in a list though (?)
09:39:17 <mmorrow> (even though you know that the parser that function gave you can only parse to (Exists e), where (e :: the correct type)
09:39:48 <Saizan> you don't need to pack them in Exists at all
09:39:56 <Saizan> you know which type you want
09:40:14 <mmorrow> Saizan: but you don't know which type you need until you parse the first expression
09:40:31 <Saizan> mmorrow: right, so?
09:40:36 <mmorrow> which can be an (Exp a), for any 'a'
09:40:44 <mmorrow>  ListE :: [Exp a] -> Exp [a]
09:40:51 <Saizan> mmorrow: you just need to pack into the Exits the whole list
09:40:53 <mmorrow> expP :: ReadP (Exists Exp)
09:41:14 <mmorrow> Saizan: right, but i can't because the ListE con knows nothing about Exists
09:41:30 <Saizan> i'm assuming you've a family of expPa :: ReadP (Exp a) for every useful a
09:41:33 <mmorrow> the Exists is only there for the ReadE class
09:41:40 <mmorrow> Saizan: no, just one
09:41:42 <mmorrow> for every type
09:41:52 <mmorrow> err, that was ambiguous
09:41:56 <Saizan> well, you can write those
09:42:05 <mmorrow> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6983
09:42:10 <Saizan> they are the branches of your expP
09:42:36 <mmorrow> Saizan: i'm trying to figure out how the write the parser for the ListE case here
09:42:48 <mmorrow> (it's parsing from a concrete syntax)
09:42:55 <conal> jmcarthur_work: ping
09:43:06 <jmcarthur_work> conal, pong
09:43:27 <conal> jml: "XML is like violence. If it isn't working, use more of it".  wow!  yours?
09:43:29 <mmorrow> "[(2,3),(99,112)]" ===> ListE [TupE (LitE 2,LitE 3),TupE (LitE 99,LitE 112)]
09:43:44 <mmorrow> :: Exp [(Int,Int)]
09:43:50 <Saizan> mmorrow: i know
09:43:52 <jmcarthur_work> conal, a coworker told it to me today, and he said he found it on somebody's slashdot signature or something
09:44:05 <mmorrow> Saizan: (just making sure everything is clear :)
09:44:24 <conal> jmcarthur_work: thanks for sharing it!  i didn't find it in a google search except for RT'ing you.
09:44:38 <jmcarthur_work> heh
09:45:03 <conal> jmcarthur_work: btw, have you read daniel quinn?  except for the xml part, it sounds very like him.
09:45:26 <jmcarthur_work> conal, i have not
09:46:04 <conal> jmcarthur_work: check him out.  my favorite is "the story of b".
09:46:44 <RayNbow> conal: have you seen http://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/ ? (Erik didn't seem to have a quite positive opinion on FRAN)
09:46:46 <conal> jmcarthur_work: few people make as much sense to me as daniel quinn.
09:47:14 <conal> RayNbow: no, i haven't.  it's on my download-when-in-civilization (high-speed internet) list.
09:47:20 <jmcarthur_work> conal, ah, i see that ishmael is formatted in socratic fashion. are the others in the trilogy also like that? i like the socratic method
09:47:40 <RayNbow> conal: ah, where are you now then?
09:47:42 <conal> jmcarthur_work: :)  yes.  i like that style also.
09:48:01 <RayNbow> (the HQ WMV is 1.3 GB, so that's a hefty download for smallband)
09:48:03 <conal> RayNbow: i live on 20 acres in the woods in north/central california.
09:48:03 <jmcarthur_work> conal, excellent. definitely going on my reading list then
09:48:28 <RayNbow> conal: ah
09:48:39 <conal> jmcarthur_work: cool.  let me know how it strikes you.
09:49:46 <inimino> for the record, the original source of that XML quote seems to be http://theses.nps.navy.mil/06Mar_Rauch.pdf
09:50:12 <conal> jml: oops -- i meant that message for jmcarthur_work
09:50:13 <inimino> (as referenced on xml-dev by the inimitable Len Bullard: http://www.stylusstudio.com/xmldev/200604/post60150.html)
09:54:14 <conal> inimino: thx.
09:54:27 <conal> google found this form in several places: "XML is like violence: if it doesn't solve your problem, you're not using enough of it."
09:55:03 <mmorrow> Saizan: got it! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6983#a6985
09:55:28 <mmorrow> Saizan: no unsafeCoerce needed, that makeP function works
09:55:38 <dons> conal: nice. :)
09:56:34 <mmorrow> Saizan: this is awesome, it's like GADT+Existentials == dependent types in a box
09:56:50 <mmorrow> kind of
10:00:34 <conal> Saizan: nice!  can you use the Read class instead of ReadE?  i.e., instance Read (Exists Exp) where ...
10:00:55 <mmorrow> conal: i think so
10:01:28 <mmorrow> yeah definitely, since i've got a ReadP (Exists Exp)
10:01:42 <conal> super
10:02:22 <conal> mmorrow: sry.  i got confused.  i see you wrote this code.  awesome!
10:02:29 <mmorrow> :)
10:03:19 <conal> mmorrow: mind if i steal & adapt your code?  i want Show & Read for a similar type.
10:03:27 <conal> mmorrow: with credit, of course.
10:03:32 <mmorrow> conal: not at all
10:03:36 <conal> :)
10:03:49 <Saizan> mmorrow: hah, i've defined essentially what you have as makeP with a typeclass
10:03:50 <dons> hmm. does anyone have an overview resource for graphics in haskell?
10:04:13 <mmorrow> Saizan: heh, interesting
10:04:15 <dons> i need a intro for developer at work starting a new project.
10:05:01 <conal> dons: i don't know of one.  there are several projects, present & past.
10:05:15 <tommd> Not that I have such a resource, but are you looking for windowing (GTK2HS) or graphics (GLUT)?
10:05:18 <dons> quite so. i need a sort of 'quick guide to what you should use'
10:05:19 <conal> dons: can you tell about the project?
10:05:28 <dons> 2D visualization, primarily
10:05:42 <dons> so i'm thinking jeff heard-style cairo canvases
10:05:42 <Saizan> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6983#a6986 <-
10:05:45 <tommd> GTK2HS tutorial certainly isn't bad - but he'll get through it quick
10:05:57 <tommd> And then you kind of scratch your head about how to get further.
10:06:01 <dons> so some graphviz, some cairo
10:06:15 <Zao> tommd: gtk2hs tends to require some previous gtk headwrangling.
10:06:31 <tommd> Zao: I didn't find it so bad, and I lack previous GTK experience.
10:06:37 <conal> dons: jefferson heard is very active in haskell-based visualization.
10:07:00 <mmorrow> Saizan: i love how pattern matching a GADT con gets you pretty much what instance selection gets you
10:07:16 <mmorrow> Saizan: modulo the closed/open difference
10:07:21 <hackagebot> ObjectName 1.0.0.0 - Explicitly handled object names (SvenPanne)
10:07:28 <conal> dons: there are a few basic directions that people take.  one axis is imperative/functional.  another is geometry/imagery.
10:07:48 <Saizan> mmorrow: yeah
10:09:24 <hackagebot> StateVar 1.0.0.0 - State variables (SvenPanne)
10:09:52 <conal> i guess sven is slicing & dicing HOpenGL
10:10:24 <hackagebot> OpenGLRaw 1.0.1.0 - A raw binding for the OpenGL graphics system (SvenPanne)
10:11:21 <tommd> Raw?  I think this is a hint that a higher-level library is going to be based on that package.
10:11:53 <dpro>  /join #jquery
10:11:57 <dpro> oops
10:12:25 <hackagebot> GLURaw 1.0.0.0 - A raw binding for the OpenGL graphics system (SvenPanne)
10:12:47 <bgs100> Could someone take a look at my code? It's 2 simple caesar cipher functions that only rotate if a character is in the alphabet and keep the case of the character. I have a few questions, as well.
10:12:52 <bgs100> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6988#a6988
10:13:11 <Taggnostr> how are the lists implemented in haskell? linked lists?
10:13:23 <sm> Heffalump, I found a way to fix that waitForProcess hang, after reading about lazy io in RWH - the putstr at http://gist.github.com/147064 line 6
10:13:24 <bgs100> Is there already a function for getting the x from a Just x?
10:13:41 <pikhq> Taggnostr: Linked lists via cons.
10:13:54 <Saizan> mmorrow: i wonder if there's a way to avoid the duplication between tupP and the second branch of expP
10:14:02 <paolino> bgs100 fromJust
10:14:10 <Vanadium> unsafePerformMaybe >:|
10:14:18 <Taggnostr> ok
10:14:23 <Tsion> paolino: what does that do if given a Nothing?
10:14:33 <paolino> UserError
10:14:40 <sm> the runInteractiveCommand would occasionally not be evaluated at all until I force it this way. Now, I wonder how to do it without ugly output
10:14:50 <bgs100> @hooge fromJust
10:14:51 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
10:15:04 <Tsion> @src fromJust
10:15:05 <lambdabot> fromJust Nothing  = undefined
10:15:05 <lambdabot> fromJust (Just x) = x
10:15:08 <bgs100> I typo'd, but that'll work :P
10:15:38 <bgs100> Thanks
10:18:18 <mmorrow> Saizan: i was wondering that too
10:19:24 <LeCamarade> Comrades, how to move from a fractional to an integer ?
10:19:42 <paolino> @hoogle floor
10:19:43 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
10:19:58 <LeCamarade> Ah, I remember.
10:20:05 <LeCamarade> @karma+ paolino
10:20:06 <lambdabot> paolino's karma raised to 1.
10:20:19 <mmorrow> Saizan: i guess if you make it into a ((a -> Exp c) -> (b -> Exp d) -> ReadP a -> ReadP b -> ReadP (c,d))
10:20:39 <LeCamarade> Actually, Prelude.round is what I wanted.
10:20:51 <paolino> @src round
10:20:52 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:21:11 <PeakerWork> dolio: sorry, I didn't notice you referred to me, no PeakerWork in name... :)  The base class/instance works, if you try to apply the change to the whole repo, you encounter many difficulties
10:21:17 <LeCamarade> ?src Prelude.round
10:21:17 <lambdabot> Source not found. Do you think like you type?
10:21:33 <PeakerWork> dolio: you can try it yourself on http://github.com/yairchu/generator/ -- its not that big
10:24:47 <tommd> Paolino: Beware that 'round' is round to even.
10:24:55 <tommd> > round 3.1
10:24:57 <lambdabot>   3
10:25:02 <tommd> > round 2.5
10:25:04 <lambdabot>   2
10:25:13 <tommd> > round 3.5
10:25:15 <LeCamarade> > round 2.5
10:25:15 <lambdabot>   4
10:25:16 <lambdabot>   2
10:25:19 <LeCamarade> > round 2.6
10:25:21 <lambdabot>   3
10:25:30 <LeCamarade> > round 3.5
10:25:31 <tommd> Notice how 2.5 goes to 2 while 3.5 goes to 4.
10:25:32 <LeCamarade> > round 3.6
10:25:32 <lambdabot>   4
10:25:34 <lambdabot>   4
10:25:56 <LeCamarade> tommd, I guess that's how it is done, traditionally (although I never could remember).
10:26:03 <tommd> It isn't taught much in the US, but is fairly common over the pond
10:26:18 <tommd> Not sure about other cultures.
10:26:21 * LeCamarade is over the pond.
10:26:51 <LeCamarade> I guess SPJ had to sneak something in one way or another.
10:26:53 <LeCamarade> :o)
10:26:53 <mmorrow> Saizan: hmm, it doesn't like passing a function that unpacks the Exists to tupP..
10:27:00 <pikhq> tommd: Round to *even*? That's bizarre.
10:27:13 <tommd> pikhq: Its to average out the rounding errors.
10:27:19 <paolino> > round 3.49
10:27:20 <pikhq> Ahah.
10:27:21 <lambdabot>   3
10:27:32 <tommd> pikhq: So if you round a huge set of numbers then sum them you will get closer than always rounding up from X.5
10:27:47 <pikhq> That's good to know.
10:28:46 <tromp> only if you assume some bias in the first fractional bit?!
10:28:54 <paolino> tommd: without a fair distribution ?
10:29:17 <tommd> paolino: Obviously it assumes some distribution - you can construct sequences of numbers where that isn't true.
10:29:41 <tromp> there may equally well be bias in the least whole bit
10:30:26 <tromp> maybe they should round to nearest multiple of 42...
10:30:44 <tommd> Most my data sets would be all zeros after rounding...
10:30:57 <tromp> i mean toward
10:31:13 <tromp> so 80.1 -> 81
10:32:01 <pikhq> Clearly it shoud all round to -oo, 0, and oo.
10:32:22 <conal> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6983#a6991
10:32:26 <Igloo> tromp: So what should 63 round to?
10:33:04 <conal> mmorrow: {-# LANGUAGE GADTs, ExistentialQuantification, FlexibleInstances, TypeOperators #-}
10:33:32 <leimy> Wow... I plugged ubimap into my simulator, it tracks a big Data.Map
10:33:41 <leimy> and just tried to visualize it... it's going crazy.
10:33:56 <leimy> well Vacuum-Ubimap
10:34:26 <conal> mmorrow: and generalize LitE to something like LitE :: (Read a, Show a) => a -> Exp a
10:34:48 <conal> mmorrow: that bit is probably tricky.  and very useful.
10:35:05 <mmorrow> conal: interesting
10:35:43 <leimy> oh i see... it's making nodes for every char in a string too.  Wow.
10:36:34 <Arnar> brillant bad-ass comment by augustss on reddit: http://www.reddit.com/r/haskell/comments/90zlp/when_how_and_why_did_you_learn_haskell_and_why_do/c0b2lit
10:36:52 <Arnar> I propose adding this to quotes of the week in the next HWN
10:37:02 <mmorrow> Saizan, conal: i just realized that the case of (e.g.) "[[],[1]]" is tricky (neither my nor Saizan's code works here), we need to keep trying to parse expressions until we get a non-(List []) to get at the type..
10:37:17 <mmorrow> which is a slight pita
10:37:31 <lilac> @remember augustss I learned Haskell in 1990 so I could write the first Haskell implementation.
10:37:32 <lambdabot> It is stored.
10:37:41 <lilac> Arnar: like that? :)
10:37:55 <pikhq> That's impressive.
10:38:10 <Arnar> lilac: ah.. yes :)
10:46:49 * edwardk waves hello.
10:47:55 <conal> edwardk: hi
10:48:38 <edwardk> conal: How fares Reactive?
10:49:44 <hackagebot> hack-frontend-monadcgi 0.0.2 - Allows programs written against MonadCGI to run with any hack handler. (MichaelSnoyman)
10:52:56 * MyCatVerbs thinks GADTs just "clicked" for him. Evidence in favour: he just started giggling.
10:53:54 <pikhq> MyCatVerbs: Sounds about right.
10:54:54 <mmorrow> Saizan,conal: oh noes, this is going to be a lot harder than i thought.. so say you have "[([],42),....]" ==> you have to refine the parser you're using for the rest of the list so that it parses Exps of type (Exp ([???],Int)), then the next expression you parse you have to keep refining this parser to eventually get rid of all the "???"'s, at which point you can finally parse the rest of the list
10:55:33 <edwardk> mmorrow: haskell macros?
10:55:43 <soupdragon> mmorrow: You're type inference at parse time???
10:55:52 <mmorrow> edwardk: Read'ing GADTs into an existential wrapper
10:56:10 <mmorrow> edwardk, soupdragon: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6983#a6985
10:56:16 <edwardk> not sure i have enough context to make that make sense... checking
10:56:28 <mmorrow> (that paste has mine and Saizan's version)
10:56:36 <soupdragon> sorry the existential wrapper can't hold all Haskell types
10:56:54 <mmorrow> the problems arise with
10:56:55 <mmorrow> readsE "[[],[1]]" :: [(Exists Exp, String)]
10:57:09 <mmorrow> soupdragon: it can hold the types i'm interested in
10:57:16 <mmorrow> soupdragon: in particular, GADTs
10:57:34 <conal> edwardk: reactive dev is mostly dormant afaik.  subtle laziness issues and/or ghc rts bugs.  maybe someone will get to the bottom of it.  i'm still focused on my functional->gpu compiler.
10:57:34 <mmorrow> (here, with one type param)
10:57:55 <edwardk> conal: ah fair enough
10:58:00 <soupdragon> <T> ::= Int | [<T>] | (<T>,<T>)
10:58:18 <edwardk> conal: did you see that gc using free theorem paper i linked to a while back?
10:58:22 <Saizan> mmorrow: so, we need to mix universal quantification in the middle :)
10:58:30 <conal> edwardk: yeah.  neat.
10:58:32 <mmorrow> T a := Int | [T a] | (T a, T b)
10:58:44 <soupdragon> bleh :p
10:58:48 <edwardk> conal: i keep thinking that that approach can be used to plug a bunch of the reactive-style space leaks
10:58:48 <mmorrow> Saizan: weee
10:59:03 <mmorrow> err,
10:59:12 <mmorrow> T (o :: *) := Int | [T a] | (T a, T b)
10:59:27 <mmorrow> (to emphasive that the o is not related to the `a')
10:59:40 <edwardk> conal: what gpgpu scheme did you ultimately choose to go with, anyways?
10:59:43 <mmorrow> err, neither are the two `a's that remain)
10:59:43 <conal> edwardk: could be.  i hope so.  i like elegant solutions to practical problems.
11:00:46 <conal> edwardk: none.  using glsl for now.  simpler than cuda.  i think simpler than opencl as well.  i'll probably step from there to opencl.
11:01:10 <edwardk> fair enough
11:01:19 <Heffalump> sm: does that mean that waitForProcess doesn't get multiplexed like IO does?
11:01:42 <mmorrow> soupdragon: err, i guess this is more the truth:
11:01:47 <mmorrow> T a := (Int :: T Int) | ([T b] :: T [b]) | ((T c, T d) :: T (c,d))
11:01:50 <edwardk> i'm waiting to see how well opencl takes off at the moment
11:02:05 <soupdragon> mmorrow, unless you want to do both at once,  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6983#a6994
11:02:16 <soupdragon> oop
11:02:28 <soupdragon> typecheck :: UnExp -> Maybe (Exists Exp)
11:02:39 <sully> @doc sort
11:02:39 <lambdabot> sort not available
11:02:41 <sm> Heffalump: I'm not sure.. kind of groping here
11:02:44 <lilac> MyCatVerbs: now you have me doubting whether I 'get' GADTs :-/
11:03:00 <mmorrow> soupdragon: hmm, that's an idea. separate the parsing from going to the GADT
11:03:09 <sully> @doc List.sort
11:03:09 <lambdabot> List.sort not available
11:03:12 <mmorrow> soupdragon: you wouldn't even need to make UnExp a GADT either
11:03:22 <soupdragon> it's a GADT
11:03:23 <sully> @src sort
11:03:23 <lambdabot> sort = sortBy compare
11:03:30 <sully> @doc sortBy
11:03:30 <lambdabot> sortBy not available
11:03:34 <sully> gah!
11:03:37 <mmorrow> soupdragon: but you wouldn't necessarily need it to be (i don't think)
11:03:47 <jmelesky> what does ! mean in a type signature? (eg. !Int !Int)
11:03:54 <lilac> jmelesky: strict field
11:04:01 <mmorrow> soupdragon: which would simplify pattern matching on it without type sigs (which ghc complains about for GADTs)
11:04:02 <jmelesky> lilac: thanks
11:04:05 <conal> edwardk: how are opencl implementation & adoption doing?
11:04:13 <soupdragon> you're right but I like the syntax..
11:04:18 <mmorrow> heh
11:04:36 <sm> Heffalump: I think it does not happen with a cmd that reads stdin, because in that case the hPutStr ih is enough to force it into action.
11:05:24 <mmorrow> soupdragon: yeah, that's a really good idea (separating parsing from "typechecking")
11:05:28 <soupdragon> I'm sad that we can't reflect the whole haskell types though
11:05:39 <sm> but if stdin is ignored, the hPutStr somehow never happens, the cmd is never started, waitForProcess happily sits there for ever
11:06:07 <edwardk> well, nvidia has an early access program running and committed to supporting it, AMD was on board from the beginning, so it sounds like it'll do well, but I haven't seen the Microsoft response yet
11:06:12 <soupdragon> it's because they don't trust us with lambda
11:06:35 <conal> mmorrow: i think lennart made that separation in a recent blog post.  i wondered if it's necessary.
11:06:40 <lilac> soupdragon: you want the lambda? you can't handle the lambda!
11:06:45 <soupdragon> haha
11:06:56 <sm> unfortunately I can't immediately pass the data to the code that consumes it, this is all creating an action that hunit will run "later". Printing some output was the only way I could think to force it
11:07:25 <Heffalump> sm: but hPutStr is in a different Haskell thread
11:07:34 <edwardk> It looks like it'll be September or so before apple ships an OS with it, so mainstream adoption won't be there until the end of the year. Its the cross-platform issues that bug me right now
11:07:37 <Heffalump> the best explanation is that waitForProcess locks up an OS thread
11:07:46 <Heffalump> -threaded fixed it, right?
11:07:51 <sm> no, not at all
11:07:56 <Heffalump> oh, ok
11:08:01 <Heffalump> what about -threaded and forkOS?
11:08:05 <Heffalump> oh, never mind
11:08:09 <mmorrow> conal: i think it'll make things a lot easier in some cases, like this ListE parsing one, since then you don't have to keep refining your parser at parse-time, but can just parse the expression untype-edly, then "check" it and return (Maybe (Exists Exp)), and if you get a Nothing back, you can just call pfail
11:08:14 <Heffalump> that wouldn't be enouh if you don't force the output, of course
11:08:16 <sm> I use -threaded every time, and it hasn't seemed to make a difference with or without
11:08:18 <Heffalump> ah, that's it
11:08:26 <Heffalump> how about forkIO the waitForProcess?
11:08:31 <sm> hmm
11:08:54 <sm> interesting, let me think about that and try it while I'm thinking :)
11:09:19 <Heffalump> why were you doing it, just to avoid orphans?
11:09:32 <soupdragon> btw
11:09:37 <soupdragon> mmorrow
11:09:39 <conal> mmorrow: i bet you're right about the separation simplifying things.
11:10:18 <conal> mmorrow: and i'm still curious about how well a purely typed parsing can work out.
11:10:46 <mmorrow> conal: i think it depends though, in cases where trouble like this with (ListE []) having an ambiguous type comes up, i think it would be easier to separate, but if nothing like that's an issue with a particular GADT, it'd probably be more direct to parse it directly
11:10:59 <sm> Heffalump: why was I doing what ?
11:11:01 <soupdragon> Exp and UnExp can be related by ornamenting
11:11:25 <Heffalump> waitForProcess
11:11:38 <soupdragon> (in Epigram.. )
11:12:14 <sm> oh, because I need the exit code. I'm testing that
11:13:05 <soupdragon> anyway I think these techniques are building blocks for a meta-impl. of deptypes
11:13:37 <soupdragon> (of the future)
11:13:40 <sm> Heffalump: hmm, so if I forkIO the waitForProcess, can I still get at the returned exit code ?
11:13:41 <Heffalump> ok, so you need to force the output before you can get the exit code. I think the other stuff like the readin of stdin and the hPutStr were just red herrings.
11:13:50 <sm> right
11:13:54 <Heffalump> shove it in an MVar
11:13:59 <PeakerWork> can ghc warn about overly restrictive class contexts?
11:14:01 <Heffalump> and wait on that later
11:14:07 <mmorrow> soupdragon: hmm, i'll have to read about this ornamenting
11:14:08 <sm> I see, ok
11:14:29 <Heffalump> or just waitForProcess later, really
11:14:32 <PeakerWork> e.g: if you define   (<$>) :: Applicative f => (a -> b) -> f a -> f b           you get a warning:  f is Applicative but only Functor is used
11:14:35 <soupdragon> mmorrow, you found the paper?
11:15:00 <mmorrow> oh no
11:15:31 <PeakerWork> would this be a good idea?
11:15:38 <soupdragon> http://personal.cis.strath.ac.uk/~conor/pub/
11:15:50 <mmorrow> soupdragon: nice, thx
11:16:26 <soupdragon> hmm
11:18:28 <jeffersonheard> wow...  this is annoying.  so...  no matter what I seem to do, resizing a GLDrawingArea doesn't resize the GL viewport...
11:18:38 <sm> Heffalump: maybe there is a way to do that. It's the runShellTest at http://joyful.com/repos/shelltestrunner/shelltestrunner.hs . Seems like I should be able to compose this in such a way that the test runner will force properly it at run time
11:18:41 <soupdragon> more fun!! http://strictlypositive.org/ObsCoin.pdf
11:18:43 <jeffersonheard> is there some way in gtk2hs that you're supposed to reconfigure the GL widget to fix the viewport?
11:18:59 <sm> good food for thought. I'll come back to this
11:19:01 <sm> thank you
11:19:09 <Heffalump> you could unsafeInterleaveIO the exit code but it's askin for trouble
11:19:21 <sm> ah no, steady on :)
11:20:13 <Heffalump> well, you can already get in trouble with the code you have by forcing the stdout data and the stderr data in a bad order
11:20:33 <Le-Chuck_ITA> Hi there, not precisely haskell but I am sure people here know about this :) There is an adjunction between the  category of algebras over a single-sorted signature and the category of sets
11:20:39 <sm> ack.. I don't see that ?
11:20:46 <anq> Hey. I am playing with Monad Transformers, and am currently thinking about whether more generality in the type signature ( foo :: (Num α, MonadIO μ, MonadReader [α] μ) => Int -> μ () ) is the better choice?
11:20:52 <anq> I could've said ( foo :: (Num α) => Int -> ReaderT [α] IO () ), too. Is there a way to decide sensibly how much generality to use?
11:20:57 <Le-Chuck_ITA> What's the corresponding adjunction for multi-sorted algebras? I'd say coproducts of the underlying sets of all sorts
11:21:05 <Heffalump> because the process will block if one of its output buffers fills up
11:21:13 <Le-Chuck_ITA> like the "category of elements" of a presheaf. Is this the correct functor?
11:21:13 <soupdragon> it's greek to me
11:21:21 <soupdragon> :D
11:22:00 <sm> so eg I try to force reading all of stdout.. but it blocks because stderr buffer has filled up and I haven't read that one yet ?
11:23:41 <Heffalump> yep
11:26:46 <LeCamarade> > 1.0 + 1.0
11:26:47 <lambdabot>   2.0
11:27:05 <sm> ouch, thanks
11:27:19 <LeCamarade> :t 1.0 + 1.0
11:27:20 <lambdabot> forall t. (Fractional t) => t
11:28:42 <sm> Heffalump: I could set NoBuffering, but I don't know if I can rely on that
11:29:12 <Heffalump> sm: how would that help?
11:29:20 <Heffalump> it's the buffers of the other process that matter
11:29:33 <Heffalump> and anyway, less buffering means more chance of a deadlock
11:29:39 <Heffalump> but at least it'd be more deterministic
11:29:42 <sm> hmm
11:29:53 <SamB> Heffalump: eh?
11:29:58 <Heffalump> I think the right answer is actually quite complicated.
11:30:17 <sm> I thought buffering was just a property of the channel, of which I am holding on end (the handle)
11:30:18 <SamB> I thought buffering was a common partial cause of deadlock?
11:30:43 <Heffalump> SamB: if you screw up at all with no buffering in this case, you'll get an immediate deadlock
11:30:44 <badsheepy> i thought stderr wasnt buffered :o
11:31:08 <Heffalump> sm: I think it's a property of the handle, but I could be wrong
11:31:47 <SamB> oh, you mean the pipe buffers in the kernel?
11:31:49 <Heffalump> well, the actual buffering I'm thinking of is what the OS does
11:31:50 <Heffalump> yes, those
11:32:34 <SamB> hmm, wouldn't it be wise to use two haskell threads, one to read from each pipe?
11:32:37 <Heffalump> yes
11:32:42 <Heffalump> I think the right answer is actually three Haskell threads
11:32:48 <Heffalump> the final one to waitForProcess
11:33:30 <Heffalump> hmm
11:33:42 * Heffalump wonders how to make a channel lazy
11:34:08 <sm> running a command and reliably collecting all the stdout, stderr and exit code is harder than I thought
11:34:36 <Heffalump> yes :-(
11:34:52 <SamB> it sure would be nice if you could have the kernel call *you*
11:34:54 <Heffalump> doing it strictly is ok, just forkIO for each bit and put the result in an MVar
11:35:01 <Heffalump> you can, that's what select does
11:35:24 <Heffalump> and that's what the GHC RTS does under the covers
11:35:56 <SamB> I mean, so you could get the stderr/stdout interleaved basically the same as the way the child process wrote to them
11:36:08 <Heffalump> you can do that by forkIO and writing to a channel
11:36:24 <Heffalump> you can never get them in exactly the same order the child wrote because the kernel will get in the way
11:36:51 <SamB> that's why I wish you could have the kernel call you basically right away
11:37:47 <HugoDaniel> hello
11:41:11 <Heffalump> if you want that level of coupling don't use stdout/stderr
11:44:19 <soupdragon> why is it called 'constructor class'?
11:45:14 <gbacon> dons: are slides for your SC08 talk available?
11:45:40 <sm> Heffalump: is http://gist.github.com/147064 something like what you mean, for a strict version forking everything ?
11:48:24 <sm> that appears to actually work, but still hangs if cmd does not read stdin
11:48:44 <Heffalump> sm: you can't use lazy IO either
11:48:53 <sm> oh, no hGetContents ?
11:48:58 <Heffalump> indeed :-(
11:49:02 <Heffalump> or use that, but force it in the thread
11:49:14 <Heffalump> e.g. using length
11:49:19 <edwardk> hrmm. thinking about hoas encodings for a minute. something like 'class Core r where app :: r -> r -> r; lam :: (r -> r) -> r' the best encoding for letrec i can come up with is letrec :: [r] -> ([r] -> r) -> r -- anything better come to mind?
11:49:21 <Heffalump> I don't know a nice way of doing a strict getContents
11:49:49 <soupdragon> but hoas is evil!!
11:49:56 <sm> me neither, or I would have tried it :/
11:50:06 <edwardk> i suppose a more anal rententive version would use a vector type that ensured that you had the same length list for both the list and the function
11:50:09 <edwardk> soupdragon: ?
11:50:19 <edwardk> soupdragon: the only exotic terms here are bottoms ;)
11:50:34 <edwardk> soupdragon: as long as you are polymorphic in the instance of core
11:50:34 <Heffalump> hGetContents oh >>= \x -> length x `seq` putMVar o x
11:50:36 <soupdragon> why letrec .. ? and not let
11:50:36 <Heffalump> for example
11:50:53 <edwardk> i have a let :: r -> (r -> r) -> r
11:50:53 <sm> yeah, that looks good
11:51:16 <edwardk> ugh
11:51:21 <edwardk> i typoed the letrec i think
11:51:41 <edwardk> i think it needs [[r] -> r] -> r
11:51:58 <Heffalump> I think the alternative to get interleaving is to use a Chan
11:52:16 <conal> edwardk: you might split letrec into let & rec.  and drop the lists, instead representing mutual recursion as a single recursion with tuples.
11:52:17 <Heffalump> which will use Left c for a stdout character and Right c for a stderr character
11:52:24 <edwardk> soupdragon: i could always get by with let and fix, but letrec captures the nature of haskell style bindings better i think
11:52:35 <Heffalump> then in each thread hGetContents h >>= mapM_ (putChan c . Left)
11:52:41 <Heffalump> (with appropriate modifications)
11:52:48 <edwardk> conal: yeah thought about it, but i wanted something closer to the GHC core
11:53:00 <soupdragon> [[r] -> r] -> r that's like being sucked through a wormhole
11:53:04 <edwardk> and it is an interesting exercise
11:53:51 <soupdragon> what about   #1=(Vector #1# -> r) -> r
11:54:11 <soupdragon> oops
11:54:20 <soupdragon> what about   #1=(Vector #1# n -> r) -> r
11:55:00 <soupdragon> like  #1=([#1#] -> r) -> r  but I wanted to fix the length
11:55:02 <edwardk> well, if i wanted to be anal retentive about it then yeah, it'd probably need to be Vec n (Vec n r -> r) -> r
11:55:28 <edwardk> for some suitable type Vec, where n is a natural
11:55:35 <soupdragon> the #_ notation saves a newtype
11:56:11 <Berengal> I have a possibly crazy idea for module namespacing: tagging
11:56:14 <edwardk> not sure i am parsing what you mean by #1=(...) there
11:56:26 <soupdragon> sorry
11:56:37 <edwardk> berengal: not so crazy but i haven;t figured out how to make it useful =)
11:57:01 <soupdragon> newtype Context r n = Context (Context r n -> r)
11:57:35 <soupdragon> newtype Context r n = Context (Vector (Context r n) n -> r)
11:58:34 <Berengal> edwardk: Which problems have you identified?
11:58:35 <edwardk> soupdragon but it doesn't need to be turtles all the way down. i can limit my recursion to one level deep, and should, for most cases. [[r] -> r] -> r -- when r is something like newtype Pretty = Pretty { runPretty :: [String] -> Int -> String } -- for a pretty printer with free variables and a current fixity
11:58:47 <loom2> what is the preferred way to reverse an UArrL
11:58:48 <loom2> ?
11:58:57 <edwardk> i definitely want to feed it a list of rs not a list of hyperfunctions
11:59:16 <loom2> hi, btw
11:59:49 <edwardk> berengal: the trickiest problem that came up was well, that tagging works well for finding the module in the first place, but doesn't make a good stable name for referring to it later if other people can arbitrarily tag their own modules
12:00:36 <edwardk> read [] as Vec n if it helps you keep your sanity and avoid more ill-formed terms ;)
12:00:42 <Berengal> edwardk: Free package tag?
12:00:53 <Berengal> It'd also get packages into the import list...
12:01:24 <edwardk> berengal: and what is the multiple provider resolution strategy?
12:01:55 <Berengal> edwardk: Imports fail if the tag/name intersection contains any number of modules other than one
12:02:38 <Berengal> if there's more than one module matching your tags, tag it with the package name as well
12:02:48 <LeoD> is there some existing template haskell which can generate code to serialize records to and from json (or some other format, i don't mind)?
12:02:56 <Berengal> e.g. import (package:foo)(Type)Foo
12:03:58 <jeffersonheard> wow -- this is kinda neat...  My screen just inverted itself.  All colors are reversed except for pixmaps.  What a weird bug
12:04:14 <Berengal> Can also help with the crazy Functionality.SubFunctionality.LibraryName.Subhierarchy.SubSubhierarchy.Module names
12:04:27 <Berengal> jeffersonheard: compiz?
12:04:52 * sm overlooks, painfully reinvents the last x in Heffalump's seq example
12:04:53 <jeffersonheard> Berengal, yes
12:05:04 <jeffwheeler> jeffersonheard: Ctrl-N?
12:05:14 <jeffersonheard> jeffwheeler...  why yes
12:05:18 * SamB wonders how well ZSNES works in xmonad
12:05:31 * jeffwheeler disabled that plugin
12:05:41 <jeffersonheard> wtf kind of "feature" is that???  How do I restore it, anyway?
12:05:56 <Berengal> jeffersonheard: Same button
12:05:56 <jeffersonheard> man... someone wrote lines of code to do that. that's special
12:05:58 <jeffwheeler> Isn't it ctrl+n again? It can be disabled through ccsm
12:06:10 <jeffwheeler> jeffersonheard: it's an accessibility feature
12:06:10 <Berengal> On my pc it's super-n
12:06:20 <jeffersonheard> ah yes
12:06:22 <jeffersonheard> super n
12:06:22 <sm> Heffalump: that seems to work better :)
12:06:44 <jeffwheeler> It's builtin to OS X, too. Albeit through a way more obscure keybinding .  ..
12:07:04 <jeffersonheard> fair enough I guess...
12:07:16 <Berengal> Scared the shit out of me when I first started using emacs...
12:07:38 <jeffersonheard> haha
12:07:52 <Berengal> Anyway, the code is probably like 10 lines in C or something...
12:08:22 <jeffersonheard> super + m inverts everything
12:09:13 <Twey> 20:07:52 < Berengal> Anyway, the code is probably like 10 lines in C or something...
12:09:27 <Twey> That may be the first time anyone has ever uttered those particular words
12:09:55 * Twey suspects it's just a trivial function, no more than 100LoC
12:10:32 <jeffwheeler> This should be easy to find.
12:11:05 <Berengal> Twey: I was about to say "hello world" is 10 lines in C (properly formatted), but it turns out it's 7
12:12:03 <Twey> Well, that's not so bad... only seven times longer than in a sane language >.>
12:12:06 <jeffwheeler> http://cgit.compiz-fusion.org/compiz/plugins/neg/tree/src/neg.cpp
12:12:14 <jeffersonheard> today is a day of strange bugs...  I still can't figure out why the GLDrawingArea resizes without the viewport resizing along with it
12:12:17 <jeffwheeler> only 500 lines :)
12:12:31 <jeffersonheard> hahaha.  that's the ++ part, jeffwheeler
12:12:38 <Twey> Plah
12:12:54 <Twey> No, most of it's pure procedural C-like
12:13:00 <Berengal> Java's on 9 lines...
12:13:27 <jeffwheeler> There's also the 100 line header file: http://cgit.compiz-fusion.org/compiz/plugins/neg/tree/src/neg.h
12:13:31 <Twey> What would that be in Haskell?  enable pixels = map invert pixels?
12:13:39 <pikhq> It's like 10 lines in assembly.
12:14:13 <Berengal> Twey: It'd be inlines
12:14:15 <Berengal> d*
12:14:24 <jeffwheeler> Twey: enable = map invert?
12:14:36 <Twey> Yup
12:14:42 <LeoD> if you can get that to run on the GPU
12:14:46 <jeffersonheard> Twey: to do it in the rendering hardware they way they do I think it'd be a lot longer
12:14:59 <jeffersonheard> Most of it's texture environment functions
12:15:10 <jeffersonheard> but even then I imagine with some careful currying you could get it down to under 100
12:15:13 <Twey> It would be done on the hardware in the background, wouldn't it?
12:15:20 <kw317> does anyone know what's the status of GPU.gen?
12:15:26 <jeffersonheard> Twey: no, it woudln't
12:15:47 <Twey> Why not?
12:16:01 <Berengal> jeffersonheard: It's not too unrealistic it might be compiled to run on the hardware in the near future
12:16:12 <jeffersonheard> Berengal: that's good to hear
12:16:20 <Twey> You could just do some unsafePerformIO in invert
12:16:36 <Twey> Or, heck, enable = mapM_ invert
12:17:20 <Berengal> Or some texture monoid/monad that runs on hardware...
12:17:28 <Twey> *nod*
12:17:33 <jeffersonheard> Twey: problem is that has to be compiled to a fragment shader and texture selection still has to happen.
12:17:39 * jeffwheeler is sad that Windows gets such better battery life on my new machine than Ubuntu
12:17:42 <jeffwheeler> like, by 2x
12:17:44 <VonGuard> hi there
12:17:54 <jeffersonheard> jeffwheeler, really?  does ubuntu run hotter as well?
12:17:59 <VonGuard> i am looking for some of the o'reilly haskell book authors to interview
12:18:12 <VonGuard> Don Stewart said he hangs here
12:18:13 <jeffwheeler> jeffersonheard: not by touch, at least
12:18:17 <Twey> jeffersonheard: I guess it would need a special monad, then
12:18:28 <mauke> preflex: seen dons
12:18:28 <preflex>  dons was last seen on #haskell 2 hours, 12 minutes and 27 seconds ago, saying: so some graphviz, some cairo
12:18:30 * Twey pings dons for VonGuard 
12:18:44 <VonGuard> thanks!
12:18:53 <mauke> preflex: seen bos
12:18:53 <preflex>  bos was last seen on #haskell 6 days, 22 hours, 26 minutes and 15 seconds ago, saying: just a relink will do the trick.
12:19:19 <jeffwheeler> preflex: uptime
12:19:25 <jeffwheeler> Or not.
12:19:35 <jeffwheeler> @uptime
12:19:35 <lambdabot> uptime: 7d 15h 3m 7s, longest uptime: 1m 10d 23h 44m 29s
12:19:41 <jeffwheeler> Wow!
12:20:38 <mauke> preflex doesn't keep track of its uptime (what's the point?)
12:21:24 <jeffwheeler> mauke: to impress me
12:21:32 <Botje> virtual penis size for virtual entities?
12:21:50 <mauke> preflex hangs too often for that :-(
12:22:05 <jeffwheeler> lambdabot seems to be getting more stable
12:23:10 <jeffersonheard> hrm...  this amost seems like a bug in gtk2hs and not my code.
12:23:24 <jeffersonheard> b/c the example that comes with it for opengl doesn't do resizing right either
12:24:17 <VonGuard> sok, i will idle for a little while to see if they show up
12:25:18 <mauke> preflex: seen CosmicRay
12:25:18 <preflex>  CosmicRay was last seen on #xmonad 35 days, 3 hours and 12 minutes ago, saying: Hi folks.  Can anybody tell me how I might go about debugging my mysterious amarok tray icon problem?
12:26:45 <sully> @src fix
12:26:45 <lambdabot> fix f = let x = f x in x
12:27:35 <sully> @doc fix
12:27:35 <lambdabot> fix not available
12:27:51 <SamB> lambdabot: for what bug?
12:28:06 <mauke> > fix error
12:28:08 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:28:47 <inimino> nice :)
12:29:43 <soupdragon> :t error
12:29:47 <lambdabot> forall a. [Char] -> a
12:30:00 <copumpkin> > fix (const fix) error
12:30:02 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:34:18 <edwardk> > fix error
12:34:20 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:34:28 <edwardk> definitely doesn't look fixed to me
12:34:34 <Vanadium> Hahaha
12:34:36 <idnar> edwardk: oh snap, I was just typing that
12:35:21 <mauke> wtf
12:36:19 <SamB> mauke: wtf what?
12:37:16 <copumpkin> wtf wtf
12:37:23 <copumpkin> > fix wtf
12:37:26 <lambdabot>   Not in scope: `wtf'
12:37:27 <ErhardtMundt> ftw wtf
12:37:36 <mauke> I type "> fix error". inimino, soupdragon and copumpkin react to it
12:37:42 <copumpkin> lol
12:37:53 <soupdragon> :t error
12:38:00 <lambdabot> forall a. [Char] -> a
12:38:07 <mauke> then edwardk repeats it, and idnar was about to do the same
12:38:08 <copumpkin> > fix wtf
12:38:11 <lambdabot>   "wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wtf wt...
12:38:17 <mauke> now soupdragon is repeating himself
12:38:21 <copumpkin> mauke: you're a trendsetter
12:38:36 <edwardk> mauke: i missed the conversation starter
12:38:50 <edwardk> > error (fix error)
12:38:51 <lambdabot>   * Exception: * Exception: * Exception: * Exception: * Exception: * Exceptio...
12:38:56 <burp> :t wtf
12:38:57 <lambdabot> [Char] -> [Char]
12:39:02 <burp> @src wtf
12:39:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:39:30 <SamB> > wtf
12:39:32 <lambdabot>   Overlapping instances for GHC.Show.Show
12:39:32 <lambdabot>                              ([GHC....
12:39:43 <SamB> @check wtf
12:39:45 <lambdabot>   Not in scope: `wtf'
12:40:02 <Vanadium> What are useful things to use fix for?
12:40:02 <SamB> > wtf x
12:40:04 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:40:09 <mauke> Vanadium: functions
12:40:10 <Vanadium> > fix fix
12:40:11 <SamB> > fix (1:)
12:40:12 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
12:40:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:43:14 <idnar> mauke: for the record, I was about to repeat edwardk's commentary, not his bot command
12:48:09 <mmorrow> , vacuum (fix (fix:))
12:48:14 <lunabot>  [(0,[1,0]),(1,[])]
12:48:41 <soupdragon> , fix vacuum
12:48:49 <mmorrow> noooes!
12:48:52 <Twey> I never did get an answer to this earlier: can anyone suggest a way to generalise/simplify/abstract http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2977#a2977 ?
12:48:53 <edwardk> hahahaha
12:49:04 <mmorrow> that one puts the evaluator into a tizzy
12:49:16 <soupdragon> Twey, you were right
12:49:27 <edwardk> then that sounds like more of a command for the developer than the bot ;)
12:49:27 <Twey> About what?
12:49:32 <soupdragon> Twey, use either monah
12:49:39 <Twey> Oh
12:49:49 <copumpkin> :)
12:49:51 <Twey> But the necessary wrapping of the function doesn't allow me to do that
12:49:53 <edwardk> , "Still here?"
12:49:54 <lunabot>  "Still here?"
12:49:54 <copumpkin> , "moo"
12:49:56 <lunabot>  "moo"
12:50:09 <soupdragon> Twey, I bet it can
12:50:24 <mmorrow> just the one instance of the eval prog that that initiated is still sitting there doing i forget what :)
12:50:31 * mmorrow looks
12:50:33 <Twey> I tried to and failed
12:50:41 <Twey> If it's possible, please let me know how :)
12:50:49 <copumpkin> mmorrow: there be dragons!
12:51:13 <mmorrow> like, one time i happened to ps aux | grep luna and there was an evaluator sitting there from a month and a half ago
12:51:17 <edwardk> mmorrow: cool, so when i get bored i should just spam ", fix vacuum" to lunabot?
12:51:35 * mmorrow makes a notes to fix this "bug" now that he's reveled it
12:51:41 <mmorrow> *revealed
12:52:47 <desp> Hm.
12:52:48 <mmorrow> ah yeah, it just sits there and does nothing
12:53:15 <mmorrow> which happens when the evaluator gets nothing back from ghc, which is my fault for not handling that case
12:53:22 <desp> I want to import Prelude hiding (*) and define an instance Num MyFoo with (*) = undefined
12:53:33 <desp> How can I do that?
12:53:34 <copumpkin> desp: ?
12:53:38 <copumpkin> why do you want to hide (*)?
12:53:46 <desp> Because I don't like it.
12:53:49 <lunabot>  Killed.
12:53:52 <copumpkin> hrm
12:53:53 <mmorrow> heh
12:54:06 <SamB_XP> desp: (Prelude.*) = undefined
12:54:09 <desp> Seriously, I want to overload (*) with multiple return types.
12:54:20 <copumpkin> desp: oh so you want to get rid of Num?
12:54:32 <desp> SamB_XP: I tried that, and GHC says: "Qualified name in function definition: Prelude.*
12:54:42 <SamB_XP> desp: oh, drat
12:54:51 <desp> Which is, to me, an astute observation.
12:54:52 <SamB_XP> desp: did you try (*) = undefined too ?
12:55:05 <desp> SamB_XP: yeah, it says: "*' is not a (visible) method of class `Num'"
12:55:22 <desp> SamB_XP: there's probably some way of doing it using a qualified import, which is what I'm hoping to find out here.
12:55:33 <desp> copumpkin: I want to get rid of (*) and avoid reimplementing the rest of Num.
12:55:37 <SamB_XP> desp: file a bug against Haskell
12:55:44 <copumpkin> ah
12:55:59 <SamB_XP> or GHC, if the report says that's okay
12:56:04 <desp> Huh.
12:56:12 <desp> So which one should work?
12:56:19 <SamB_XP> I don't know
12:56:24 <copumpkin> file a bug against the 98 report for having a shitty Num typeclass :P
12:56:24 <SamB_XP> but one of them sure ought to!
12:56:29 <desp> copumpkin: definitely.
12:56:33 <SamB_XP> copumpkin: that's not the point of this
12:56:37 <copumpkin> I know :)
12:56:38 <SamB_XP> everyone knows it has one of those
12:56:49 <SamB_XP> nobody has found an adequate solution
12:56:57 <SamB_XP> I mean, we have better hierarchies
12:57:04 <desp> SamB_XP: well, I've been browsing those replacement Preludes all day
12:57:11 <desp> And I kind of like the Basic algebra proposal
12:57:22 <desp> But I don't understand a lot of what it's doing (and why)
12:57:32 <desp> So I'm trying to write something much more simple, for my purposes.
12:58:01 <copumpkin> ah
12:58:22 <SamB_XP> arguably, GHC could just not follow the report if it actually forbids qualified names in method implementations
12:59:09 <desp> Is the syntax for qualified operator (Q.op)?
12:59:40 <SamB_XP> desp: GHC seems mostly okay with the syntax
12:59:40 <desp> I might see a hack around this...
12:59:58 <Twey> If it's called + and is in module Q, you can go a Q.+ b or (Q.+) a b
13:00:01 <SamB_XP> it just specifically doesn't want you to bind by using a qualified reference
13:00:03 <Twey> As with any normal operator
13:00:50 <SamB_XP> ... and either GHC is being stupid, or Haskell is
13:00:56 <SamB_XP> to forbid that for method implementations
13:01:09 <SamB_XP> ... there *might* be an extension you can turn on that will allow it?
13:01:14 <Twey> I think it's Haskell
13:01:20 <Twey> Instances are magic
13:01:37 <Twey> They don't have modules, really
13:01:41 <SamB_XP> oh ... I has an idea
13:01:55 <SamB_XP> you should import qualified Prelude and then use the "(*) = undefined"
13:01:55 <desp> All right.
13:02:00 <SamB_XP> that would probably do it
13:02:17 <SamB_XP> but still, it should use the qualified name :-(
13:02:54 * SamB_XP thinks JHC does it that way at the moment because the other way is harder
13:02:56 <jeffersonheard> can one use Gtk and SDL together?  I don't even know.  I can't get away from this GtkGLExt bug and it's tiring me out.
13:02:59 <Twey> So, anyone any ideas about abstracting this pattern away? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2977#a2977
13:03:15 <desp> SamB_XP: indeed, that works.
13:03:32 <desp> SamB_XP: I also figured out that defining my (*) in a separate module works well
13:03:43 <chturne> I'm really struggling with an exercise in "Haskell: The Craft of Functional Programming", would someone be so kind to have a peek? -> http://codepad.org/MaA0CYCM
13:03:45 <SamB_XP> desp: but seriously, you should probably mention that on the haskell-prime list
13:03:55 <desp> OK.
13:04:15 <jrockway> oh man, stackoverflow gives me a headache
13:04:29 <SamB_XP> jrockway: then stop using foldl
13:04:35 <jrockway> ;)
13:04:39 <jrockway> apparently RWH is not a good book because it does not cover list comprehensions extensively
13:04:53 <jrockway> so says someone who has never answered a haskell question there, and claims to be a C++ programmer
13:04:59 <jrockway> amusing, but also annoying
13:05:02 <SamB_XP> jrick: neither does K&R
13:05:03 <Vanadium> Pft
13:05:08 <SamB_XP> er. jrockway
13:05:10 <Vanadium> Give them some slack.
13:05:12 <jrick> :)
13:05:16 <Gracenotes> jrockway: list comprehensions are intuitive for starting out, but I find you pick up better habits shortly
13:05:17 <SamB_XP> too many damn people in this channel ;-P
13:05:26 * jeffersonheard tries to imagine what a C++ list comprehension would look like.
13:05:26 <Berengal> Twey: Maybe? Or perhaps an error-monoid thingymabob?
13:05:34 <Gracenotes> jrockway: 'better' in my opinion. I don't want to start a flame war :P
13:05:55 <jrockway> i don't think i use list comprehensions in any of my programs that are more than 1 line ;)
13:05:57 * jeffersonheard stops trying to imagine because he is finding himself too terrified by the thought of it
13:05:59 <SamB_XP> Gracenotes: I always forget about list comprehensions -- but not because I don't think they're good
13:06:09 <Vanadium> jeffersonheard: it would start with std::list_comprehension<T, V, U>(
13:06:11 <SamB_XP> jeffersonheard: lol
13:06:12 <desp> Funny.
13:06:17 <jrockway> here is the question in question: http://stackoverflow.com/questions/1126588/are-list-comprehensions-a-major-part-of-haskell
13:06:20 <jrockway> enjoy ;)
13:06:23 <Twey> Berengal: Maybe doesn't work because I need different errors for each stage
13:06:28 <FunctorSalad> uhm, list comprehensions are a bit more readable if you're going to use a lambda expression in the HOF anyways
13:06:49 <jeffersonheard> Vanadium, yes, and contain lots of uses of * that have nothing to do with pointer dereferencing
13:07:00 <desp> SamB_XP: http://pastie.textmate.org/private/ycio7sywpxjdpdulhjsq
13:07:13 <SamB_XP> FunctorSalad: yeah, maybe I remember them when I find myself reaching for map (\x -> ...)
13:07:18 <Vanadium> I imagine someone will come up with a way to simulate the x <- xs thing using the operato->
13:07:22 <Vanadium> operator*
13:07:25 <Twey> Berengal: Monads/monoids (at least any standard library ones I can find) don't work because I also need to alter what's passed to adjust/update
13:07:26 <desp> SamB_XP: the qualified import somehow makes (*) and (/) visible
13:07:43 <Gracenotes> SamB_XP: my first impulse there is to pointless-fy it :P
13:07:45 <Berengal> Twey: A tricksy conundrum indeed
13:07:50 <SamB_XP> desp: yeah, just importing them by *any* name is enough to make Haskell 98 happy
13:07:59 <SamB_XP> that is, any qualified name
13:08:05 <SamB_XP> oooh ... sweet color scheme
13:08:29 <desp> The syntax highlighting isn't perfect, though.
13:08:35 <desp> I need to get to it someday.
13:08:37 <PeakerWork> I'm reading "Why Dependent Types Matter" - and he uses a "parity" bit to decide where to insert new nodes to the tree - why not just swap the order of the sub-trees?
13:09:25 <Philippa> PeakerWork: that's actually slower to compare
13:09:56 <Gracenotes> oh!
13:10:35 <PeakerWork> Philippa: I don't think he needs to compare it though - he's just using the parity bit so insertions to the tree are balanced -- so instead of flipping the bit at each insertion, he could swap between left/right child and always insert to the left child
13:12:00 <Berengal> Twey: It does feel like a monad, but I don't know which one :/
13:12:15 <FunctorSalad> what does that have to do with dep types anyway?
13:12:21 <Twey> Berengal: Yeah :-\
13:12:28 <FunctorSalad> is the parity compile-time?
13:12:30 <PeakerWork> FunctorSalad: its just their merge-sort example that they iteratively improve
13:12:35 <Berengal> Twey: Try writing your own, maybe?
13:12:37 <Twey> Maybe I should write my own...
13:12:38 <Twey> Heh
13:12:40 <Twey> Great minds
13:12:47 <Berengal> MapLookupMonad
13:12:53 <Twey> Hehe
13:13:19 <Berengal> or 'instance Monad MapLookerUpper where [...]'
13:13:20 <PeakerWork> FunctorSalad: at this first step, they improved the general recursion of the call to sub-sorts into a structural recursion over a binary tree of dealings into halves, so they need to build a balanced tree of such dealings by inserting all the elements into it - which is where this parity is used
13:13:25 <Twey> You'd think it would exist already, though
13:13:32 <Twey> That's why I was confused
13:13:48 <PeakerWork> Why does "map lookup" need a monad?
13:14:27 <Twey> PeakerWork: It's not lookup but arbitrary-depth altering, with step-specific failures and transformations on the values
13:14:50 <Philippa> PeakerWork: Maybe will do nicely
13:15:00 <Philippa> it just wants fail
13:15:05 <Twey> Philippa: Not if you need a fail
13:15:05 <Twey> Yeah
13:15:16 <Twey> Either is ideal, but since Map uses Maybe for everything, it's not helpful
13:15:17 <RayNbow> FunctorSalad: I managed to understand that Poset/bijective homomorphism/isomorphism stuff :)
13:15:18 <Philippa> Twey: Maybe /is/ a monad with a fail :-)
13:15:28 <Twey> Philippa: Yeah, but only one fail
13:15:29 <Philippa> or do you mean, not if you care about the string?
13:15:38 <Berengal> Twey: ErrorT String Maybe?
13:15:40 <FunctorSalad> RayNbow: for great justice!
13:15:42 <PeakerWork> fail having a String is a catastrophe :-P
13:15:49 <SamB_XP> Maybe's fail is full of fail, you know?
13:15:52 <Twey> Not the fail function
13:16:07 <Twey> Berengal: Has the same issue as Either
13:16:09 <Twey> Hmm
13:16:20 <PeakerWork> Twey: Either (String, Record1)  --> surely you meant:  Either String Record1?
13:16:20 <Twey> Yeah
13:16:28 <Twey> PeakerWork: Yes, I did
13:16:40 <Twey> I did that a bunch of times on this, I don't know why
13:16:43 <Twey> Only for types
13:17:29 <FunctorSalad> RayNbow: FWIW, the one I had in mind was "order the codomain with the discrete ordering and the domain with any other ordering"
13:17:52 <PeakerWork> Twey: this doesn't seem right
13:17:58 <Twey> PeakerWork: How so?
13:18:06 <RayNbow> FunctorSalad: monochrom gave me two example posets
13:18:14 <PeakerWork> Twey: The number of arguments doesn't match the specified type
13:18:22 <PeakerWork> Twey: what part of this type-checks/compiles?
13:18:40 <Twey> PeakerWork: Probably none; I made it up out of whole cloth as an example
13:18:55 <Twey> The pattern's the point, not the obvious errors :-P
13:18:58 <PeakerWork> Twey: ah.  Map.update doesn't change the map type
13:19:22 <RayNbow> FunctorSalad: {x,y} with a flat order and {0,1} using the "normal" <=
13:19:23 <PeakerWork> Twey: so I don't see how you use it to move from Map Key Record2   to Map Key Record3   etc
13:19:24 <Twey> PeakerWork: *nod*
13:19:26 <SamB_XP> Twey: stop cutting paper dolls out of the cloth
13:19:28 <ketil> @botsnack
13:19:29 <lunabot>  :)
13:19:29 <lambdabot> :)
13:19:34 <SamB_XP> Twey: it's expensive!
13:19:51 <Twey> PeakerWork: Constructors are applied to the map at each stage
13:20:05 <PeakerWork> Twey: oh wait, you're keeping it in Record2, just confused there
13:20:17 <Twey> See Record1 and getMap2
13:20:19 <Twey> Yeah
13:20:21 <PeakerWork> Twey: I'm confused by getMap1 returning a map to Record2  :)
13:20:40 <Twey> Heh
13:20:45 <Twey> The map is 1
13:22:51 <PeakerWork> Twey: maybe start with something like:    guardInMap :: Ord k => k -> Map k v -> (v -> a) -> Either String a     guardInMap key map f = if key `member` map then Right $ f (map ! key) else Left "key not in map"
13:22:51 <hackagebot> generator 0.5 - A list monad transformer and related functions. (YairChuchem)
13:22:58 <PeakerWork> Twey: that's recurring
13:23:46 <desp> copumpkin: this is what I wanted to do: http://pastie.textmate.org/private/ovwoxislmv9qlimnapokna
13:24:04 <copumpkin> ah, I see
13:24:07 <PeakerWork> Twey: the rest here seems to be unpacking/applying a simple map updater function/packing
13:24:49 <PeakerWork> Twey: I think it seems easy to break into components and then it would be easier to think about how to generalize them. not sure where there's difficulty generalizing here
13:25:34 <PeakerWork> Better still:  guardInMap :: Ord k => k -> Map k v -> Either String v     guardInMap key map = if key `member` map then Right $ map ! key else Left "key not in map"   -- use fmap on it if you want
13:26:00 <PeakerWork> Twey: if you produce a compiling version I'll like to break it up into nice components...
13:26:55 <PeakerWork> Better still:  guardInMap key map = maybe (Left "key not in map") Right $ lookup key map
13:28:10 <Twey> PeakerWork: That one's not highly useful, since I have to alter all the way up the chain
13:28:18 <PeakerWork> maybeToEither :: l -> Maybe r -> Either l r  ;  maybeToEither l = maybe (Left l) Right        guardInMap key map = maybeToEither "key not in map" $ lookup key map
13:28:24 <Twey> That's the main problem
13:28:31 <PeakerWork> s/guardInMap/lookupEither
13:28:37 <PeakerWork> Twey: alter what?
13:28:51 <Twey> I can't just return the value, I have to embed a function in the next alter call
13:28:55 <Twey> The map
13:29:13 <PeakerWork> Twey: You can do it inside the unpacked computation, I think
13:29:31 <Twey> To alter a Datum, I have to alter three layers of maps and records
13:30:04 <kyagrd> Is there a zip frunction for Data.Array arrays?
13:31:46 <desp> In fact, I should overload abs for vectors as well.
13:32:33 <\stro> hi
13:32:42 <\stro> what's the hxt arrow runner without IO?
13:32:54 <hackagebot> yi 0.6.1 - The Haskell-Scriptable Editor (JeffWheeler)
13:32:59 <\stro> all the examples use runX
13:33:12 <jeffwheeler> Well, hi, hackagebot.
13:34:29 <sm> hackagebot is a bit too *focussed on the job* for conversation, alas
13:34:34 <CalJohn> Does Agda guarantee termination?
13:34:42 <sm> not like you, eh lambdabot ?
13:35:17 <jmcarthur_work> CalJohn, no, but it warns you about possible nontermination
13:35:35 <jbe> Is there a standard way to tell cabal to use both my CPUs?  Perhaps a setting in ~/.cabal/config ?
13:35:53 <CalJohn> jmcarthur_work: ok, thanks
13:35:54 <lambdabot> No, not like me.
13:36:00 <jbe> Maybe that's not cabal, but ghc.
13:36:40 <dcoutts> jbe: eg to build multiple packages in parallel? that's not implemented yet I'm afraid. Patches accepted :-)
13:37:11 <jbe> I was thinking: to compile multiple .hs files in parallel, like "make -j2" does.
13:38:16 <dcoutts> jbe: right, that's also not yet implemented, but on the long-term TODO list
13:39:38 <jbe> dcoutts: Gotcha.  I'll get my other core working on mersenne primes instead. :)
13:40:23 <dcoutts> jbe: aye, and it's only going to get worse. We've got a 64-thread machine but we're not using many cores while building stuff.
13:41:18 <dcoutts> (sparky.haskell.org is an 8-core, 64-thread UltraSPARC T2)
13:41:25 <uzytkownik> @pl \p1 p2 -> p1 >>= \v1 -> p2 >>= \v2 -> return (p1, p2)
13:41:25 <lambdabot> liftM2 (.) (>>=) ((const .) . ap (>>=) . ((const . return) .) . (,))
13:44:11 * sm laughs... I think there's more to lambdabot than meets the eye
13:45:29 <Twey> @vixen Are you scary?
13:45:32 <lambdabot> first you tell me.
13:45:51 <Badger> @vixen do you adore Twey?
13:45:52 <lambdabot> i do occassionally, i guess
13:45:52 <Twey> Definitely.
13:45:55 <Twey> Hahaha
13:46:16 <SamB_XP> @vixen do you think pitties are cute?
13:46:17 <lambdabot> i'd like to think i'm pretty
13:46:34 <desp> I have a problem with fundeps.
13:46:38 * SamB_XP didn't know lambdabot was actually a pitbull
13:46:57 <hackagebot> Control-Engine 1.0.0.0 - A parallel producer/consumer engine (thread pool) (ThomasDuBuisson)
13:47:20 <desp> http://pastie.textmate.org/private/tl417pa1l8pir1b3si1jna -- with this code, I can't work freely in ghci
13:47:48 <desp> For example, when I try:  let v = Vector 1 2 in v * 3
13:48:04 <desp> GHCI complains:  No instance for (Mul Vector t c)
13:48:53 <desp> Can I fix this so that I won't have to use explicit types everywhere?
13:49:17 <copumpkin> hmm
13:52:12 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7004 is failing miserably :(
13:56:34 <ichor_> desp, I would not think you can. I'm no expert on how GHC does type inference, but I think you are asking a bit too much of it. I've tried doing the same thing, but haven't found any solutions.
13:59:19 <copumpkin> oh, I just needed functional dependencies
14:00:30 <desp> ichor_: well, I added "a c -> b, b c -> a" to the fundeps, and now I only have to specify the result type.
14:01:14 <desp> ichor_: if I didn't make Vector an instance of Num, I could avoid numeric literals becoming Vectors, and then the inferencer would choose the right (*) by itself
14:01:22 <desp> ichor_: but then I would loose the bloody prefix (-)
14:01:27 <desp> lose*
14:01:43 <jeffwheeler> It seems oddly insecure that anybody can release any package.
14:02:05 <jeffwheeler> That is, you don't have to be a maintainer to update package X. You just have to have a Hackage account . . .
14:02:19 <copumpkin> it is :)
14:02:24 <copumpkin> but we haz epic trust!
14:02:31 <jeffwheeler> And so far, that's worked out well. :)
14:03:03 <ichor_> desp, ok :)
14:03:10 <desp> It's not. :)
14:07:02 <hackagebot> Control-Engine 1.0.0.1 - A parallel producer/consumer engine (thread pool) (ThomasDuBuisson)
14:14:55 <copumpkin> > (50000 :: Word16) ^ 2
14:14:56 <lambdabot>   63744
14:16:54 <tommd> > (65536 :: Word16) ^ 2
14:16:56 <lambdabot>   0
14:17:37 <copumpkin> zomg magick
14:17:45 <copumpkin> :)
14:18:53 <bgs100> @src reads
14:18:54 <lambdabot> reads = readsPrec minPrec
14:22:00 <lpsmith> (256 :: Word16)^2
14:22:10 <lpsmith> > (256 :: Word16)^2
14:22:12 <lambdabot>   0
14:22:24 <lpsmith> See, there you go, not an integral domain :-P
14:23:11 <copumpkin> lol
14:24:27 <desp> Is there any way to influence the type of numeric literals in GHCI?
14:24:37 <desp> It appears to be  (Num t) => t
14:25:26 <Botje> that's the most general number type, yes
14:25:42 <desp> Yeah, but I'm trying to replace Num ;)
14:25:46 <Botje> oh :p
14:25:49 <davidL> @type let x :: Int; x = 42 in x
14:25:51 <lambdabot> Int
14:26:06 <marsvolta> hello
14:26:12 <desp> davidL: yes, I know I can give the type explicitly, but is there a way to change the default?
14:26:16 <marsvolta> how to use shellcodes
14:26:16 <marsvolta> ?
14:26:31 <Botje> i think you'll have to tinker with GHC for that.
14:26:44 <Botje> marsvolta: what do you mean, shellcodes?
14:27:11 <marsvolta> do you know what is a shellcode?
14:27:24 <marsvolta> i want to know how to use ir
14:27:31 <Botje> why do you want to know?
14:27:45 <marsvolta> to hack servers
14:27:46 <copumpkin> desp: I think it just sitcks a fromIntegral on every literal, so maybe avoiding the implicit prelude and defining your own fromIntegral?
14:27:47 <marsvolta> lol
14:27:50 <copumpkin> marsvolta: no
14:28:02 <Botje> marsvolta: what makes you think Haskell is suitable for shellcodes?
14:28:04 <copumpkin> marsvolta: it's called being a scriptkiddi
14:28:22 <copumpkin> +e :)
14:28:24 <Botje> hack :: Shellcodea  -> IO (Maybe a)
14:28:29 <Botje> hack :: Shellcode a -> IO (Maybe a)
14:28:31 <Botje> i guess :
14:28:33 <marsvolta> i just want to get some informmation from the server of the mental institution i go to
14:28:34 <desp> copumpkin: I am, in fact, avoiding the prelude.
14:28:43 <desp> Huh.
14:28:45 <Botje> !ops
14:28:47 <copumpkin> marsvolta: anyway, no
14:28:56 <Zao> marsvolta: That's highly illegal.
14:29:02 <marsvolta> what is haskell
14:29:02 <Botje> marsvolta: yawn. troll fail. try better next time.
14:29:08 <Botje> or at least try to be more interesting.
14:29:11 <Zao> Additionally, kittens will attack you in your sleep now.
14:29:12 <copumpkin> @where ops
14:29:12 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:29:13 <lambdabot> mauke
14:29:25 <Botje> copumpkin: ah, that's what i was looking for, thanks :)
14:29:34 --- mode: ChanServ set +o Heffalump
14:29:42 <Botje> marsvolta: any parting words?
14:30:00 <marsvolta> what?
14:30:02 <Heffalump> *sigh*
14:30:04 <Botje> traditionally it's "HAHA ROFLMAO FAGGOTS!"
14:30:05 --- mode: ChanServ set +o Heffalump
14:30:10 <Botje> or "haha, haskell suxxxx!"
14:30:11 <copumpkin> Heffalump: nice :P
14:30:13 <desp> Heffalump: golf clap
14:30:18 <davidL> lol Heffalump
14:30:23 <allbery_b> *eyeroll*
14:30:41 <Heffalump> I really should learn to operate my own client
14:30:46 <jeffwheeler> Didn't read the thread, but thought of shellac, on Hackage.
14:31:17 <jeffwheeler> @where shellac
14:31:17 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/shellac/
14:31:48 --- mode: Heffalump set -o Heffalump
14:31:53 <desp> copumpkin: I'm confused
14:32:18 <desp> copumpkin: how can it stick a fromIntegral on every literal, if without the implicit Prelude it shouldn't know Num?
14:32:28 <copumpkin> not sure :)
14:32:31 <Heffalump> it gets the one in scope instead
14:32:34 <PeakerWork> @type \f -> sequence_ . fmap f
14:32:36 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m ()
14:32:43 * k0mpulsive really needs to learn haskell but is scared and knows nothing about it
14:32:43 <Heffalump> that's what NoImplicitPrelude means
14:32:46 <jeffwheeler> Anybody want to confirm that Yi builds successfully from Hackage? You'll need to install the Haskell Platform prior to cabal-insatlling it.
14:33:15 <PeakerWork> @type sequence
14:33:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:33:52 <lpsmith> jeffwheeler:  I will
14:34:03 <jeffwheeler> lpsmith: wonderful, thank you; what platform are you on?
14:34:24 <lpsmith> Ubuntu,  and I rolled my own cabal-install
14:34:31 <lpsmith> ghc-6.10.3
14:34:35 <desp> @hoogle (Integral i) => i -> Double
14:34:36 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
14:34:36 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
14:34:36 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
14:34:44 <jeffwheeler> lpsmith: if you haven't installed the Platform explicitly, then you'll need to `cabal install alex` first
14:34:58 <lpsmith> already done :-)
14:35:06 <jeffwheeler> lpsmith: wonderful :)
14:35:23 <desp> Heffalump: still confused
14:35:28 <lpsmith> so do you use yi as your regular editor?
14:35:38 <desp> Heffalump, copumpkin: http://pastie.textmate.org/546069
14:35:46 <jeffwheeler> lpsmith: about half-and-half, I'd say
14:35:55 <Heffalump> desp: with the standard implicit prelude behaviour, the desugaring of things like do notation, numeric literals etc binds to the symbols from the Prelude, no matter what's current in scope.
14:36:01 <desp> After loading this into GHCI, :t 1 gives (P.Num t) => t
14:36:03 <Heffalump> With NoImplicitPrelude, it binds to the currently in scope symbols
14:36:16 <lpsmith> jeffwheeler:  and what do you use most of the rest of the time?
14:36:22 <jeffwheeler> lpsmith: gvim
14:36:33 <Heffalump> ok, then I'm confused.
14:36:35 <desp> :)
14:36:38 <k0mpulsive> any of you use archlinux?
14:36:52 <jeffwheeler> @ask
14:36:53 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
14:36:56 <jeffwheeler> :(
14:37:01 <mike-burns> gtk2hs has this as part of its 'gmake install' step, and it's failing:   mv //usr/local/lib/gtk2hs/gstreamer.cabal{.tmp,};
14:37:06 <jeffwheeler> k0mpulsive: just ask your question :)
14:37:08 <mike-burns> Does it expect /bin/sh to be bash?
14:37:23 <Heffalump> desp: oh, duh
14:37:26 <desp> Aha!
14:37:29 <Heffalump> you need -XNoImplicitPrelude to GHC
14:37:37 <lpsmith> jeffwheeler:   yi looks fairly interesting, although I would really like to be able to process key-down and key-up events instead of keypresses
14:37:38 <Heffalump> the LANGUAGE pragma just affects the file you're loading
14:37:39 <Zao> gtk2hs' build system blows up if you have the wrong moon phase.
14:37:41 <Heffalump> not the interactive prompt
14:37:45 <desp> Right...
14:37:50 <k0mpulsive> i guess the first thing to do would be to find a good ubern00d intro/tutorial for getting started with haskell. then again, i have a feeling haskell and noobs don't go together.
14:37:50 <desp> And it's fromInteger, too
14:37:56 <mike-burns> Zao: I've noticed.
14:37:57 <jeffwheeler> lpsmith: hmm, I've never thought about that
14:38:00 <lpsmith> jeffwheeler:  although this is incompatible with the terminal interface
14:38:05 <Heffalump> oh, yeah
14:38:07 <Heffalump> :-)
14:38:08 <Zao> mike-burns: Be happy you're not trying to build it on Windows :)
14:38:14 <Heffalump> but you should get an error
14:38:19 <Heffalump> since there's no fromInteger in scope
14:38:22 <desp> Yep.
14:38:24 <desp> I got one now.
14:38:26 <desp> Thanks!
14:38:27 <jeffwheeler> lpsmith: oh? We use the standard vty library which has problems on some less common terminals; you might file a bug report there
14:38:41 <jeffwheeler> lpsmith: Else, you can try launching it with -fpango to use the Gtk interface, if you have that installed
14:38:53 <desp> Yay.
14:39:19 <jeffwheeler> lpsmith: also, I've never thought about processing on keypress/keyrelease. What'd be the reasoning for something like that?
14:39:36 <lpsmith> jeffwheeler:  that wouldn't be a bug,  it's a feature.    AFAIK  no terminal supports key-down and key-up events.
14:39:43 <zsol> is there any way to programmatically check if a symbol is a thunk (unevaluated)?
14:39:56 <jeffwheeler> lpsmith: oh, I thought you meant the vty interface was broken in your terminal
14:40:40 <Botje> isThunk x = x `seq` False -- ;)
14:40:54 <Botje> zsol: have you looked at the GHC.Internals package?
14:41:03 <zsol> yeah, I've come up with that one already
14:41:04 <zsol> :]
14:41:11 <zsol> GHC.Internals, hmm not yet
14:41:20 <zsol> will do
14:41:29 <Beelsebob> Botje: lol
14:41:36 <Beelsebob> that's genius
14:41:40 <lpsmith> jeffwheeler:  the ability to build a sane and humane user interface comes to mind.   Maybe I'd use it for key chording without the hopelessly modal UI of emacs :)
14:41:49 <Beelsebob> Botje: it's even referentially transparent
14:42:37 <Botje> :)
14:42:47 <lpsmith> jeffwheeler: edge-triggered processing is in general,  much more flexible than level-triggered processing
14:42:47 <zsol> Data.isEvaluated seems promising
14:43:11 <lpsmith> jeffwheeler:  compiles fine
14:43:19 <jeffwheeler> lpsmith: hmm, alright; I think JPB has long been trying to design a new, optimal keybinding, so he might be interested in something like that; you should post to yi-devel@googlegroups.com
14:43:22 <jeffwheeler> lpsmith: awesome!
14:43:26 <jeffwheeler> lpsmith: thanks, too
14:43:38 <kynky> lovely schmidtt triggers
14:52:21 <ceninan> hi! as a haskell-newb I was wondering if there's anything that's considered "best practices" syntax wise
14:52:29 <ceninan> when to use let over when, paranthesis over $ etc.
14:52:40 <ceninan> better to nip bad habits in the bud :)
14:53:03 <Petrosian> ceninan: I'd say it's mostly subjective
14:53:20 <mike-burns> ceninan: Outside of these idioms http://haskell.org/wikisnapshot/CommonHaskellIdioms.html I haven't seen anything documented, sadly.
14:53:35 <kynky> read other code on net, say in hackage ?
14:53:55 <mike-burns> ceninan: Your best bet is to read lots of code with more than one contributor. Xmonad, for example.
14:54:09 <jbe> ceninan: Hlint might help.
14:54:40 <yitz> ceninan: http://www.haskell.org/haskellwiki/Category:Style
14:54:41 <RayNbow> too many parentheses or $s might be an indication that you can write smaller functions and compose those
14:54:48 <yitz> but take them all with a grain of salt
14:54:51 <Raevel> lisp: (f (g (h x))), lean: f $ g $ h $ x, better: f . g . h $ x
14:55:33 <ceninan> thanks, cool! really helpful channel this :)
14:55:35 <kynky> sometimes its good to be explicit i thought, just for readability ?
14:55:36 <jmcarthur_work> of course, best: f . g . h
14:55:50 <jmcarthur_work> if you can help it
14:56:04 <mike-burns> Nah, the best is having the requirements change and being able to delete the whole thing.
14:56:15 <Berengal> mike-burns++
14:56:24 <ray> pointless style
14:56:31 <Berengal> Pointless isn't
14:56:39 <ray> the one true style
14:56:46 <Berengal> It hides the noise, emphasises the signal
14:56:54 <Petrosian> Ye, write the entire thing, then run it all through @pl
14:56:59 <ceninan> I'll try reading some code - that should help me understand the programming side a bit better too, thanks :)
14:57:09 <yitz> @pl \x -> (f (g (h x)))
14:57:10 <lambdabot> f . g . h
14:57:28 <yitz> ceninan: there you go
14:57:34 <ceninan> :o
14:57:35 <ceninan> cool
14:57:37 <ray> @pl \x y -> y x
14:57:38 <lambdabot> flip id
14:57:45 <jmcarthur_work> it's not always going to make pretty things though
14:57:46 <Berengal> @pl can sometimes be pointless though =\ like this -> bit
14:57:47 <lambdabot> can = const (const (const (const (const (const bit)))))
14:58:06 <jmcarthur_work> @pl \a b c d e f g -> d b a f g e
14:58:06 <lambdabot> ((const . ((flip . (flip .)) .)) .) . flip (flip . flip id)
14:58:27 <ray> that one reads like record scratching
14:58:34 <Berengal> @pl \q w e r t y u i o p -> t y p e w r i t e r
14:58:38 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) .
14:58:38 <lambdabot> ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip
14:58:38 <lambdabot> .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
14:58:38 <lambdabot> optimization suspended, use @pl-resume to continue.
14:58:42 <copumpkin> onoes
14:58:55 <ceninan> that's ugly :/
14:59:03 <RayNbow> @pl-resume
14:59:06 <Berengal> Well, so's my original function...
14:59:10 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . ((((flip .) .) .) .) . (((((flip .
14:59:10 <lambdabot> ) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (
14:59:10 <lambdabot> flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
14:59:10 <lambdabot> optimization suspended, use @pl-resume to continue.
14:59:12 <ceninan> I usually do naturally write in a quite pointless style - that's not considered too terse or anything then?
14:59:14 <pikhq> You could probably read that with some record scratching and make a decent rap song.
14:59:22 <dilinger> awesome
14:59:31 <ray> no, that is the record scratching
14:59:39 <ray> you have to rap over it
14:59:41 <jmcarthur_work> ceninan, again, it's subjective, but i think it's not too terse, and the compiler actually _likes_ it more, much of the time
14:59:43 <mike-burns> ceninan: The Haskell community has yet to catch on to the idea of something being "too terse".
14:59:45 <Berengal> ceninan: It can be taken too far. If you need arrows you're probably doing it wrong
14:59:57 <pikhq> ceninan: Pointless style is encouraged unless it makes it hard to read.
14:59:58 <ceninan> mike-burns: :)
14:59:59 <jmcarthur_work> Berengal, really?
15:00:03 <Berengal> Or applicative functions: isPrime = (==) <*> head . factorize
15:00:13 <ceninan> cool
15:00:16 <Berengal> jmcarthur_work: Depending on context, of course
15:00:23 <anq> Mh, I asked earlier today and no one answered, so I'll ask again now. :P Say, you have some monadic functions, with the monadic types based on monad transformers. Do you try to make the signatures more general or more concrete? What should I keep in mind when deciding about that?
15:00:24 <conal> ceninan: whichever style you choose will clarify your intent for some folks and obscure it for others.
15:00:25 <jmcarthur_work> i don't think the applicative and arrow stuff is hard to read
15:00:35 <jmcarthur_work> i regularly use them in my point free code
15:00:43 <ray> you just need to know the functions, that's all
15:00:52 <pikhq> jmcarthur_work: The arrow stuff is for me. ... Because I don't know the functions. ;)
15:01:07 <ceninan> conal: I guess I'll just write it the way I find readable then , thanks :)
15:01:09 <jmcarthur_work> meh, you guys need to learn them! :P
15:01:12 <Berengal> jmcarthur_work: Neither do I... Let me rephrase myself: If you need arrows or applicatives to *continue* writing in points-free style, you're doing it wrong
15:01:19 <Gracenotes> D:
15:01:21 <ceninan> and read some code like suggested earlier, to see how it's done in teams
15:01:21 <Saizan> anq: a bit too general, can you give some examples?
15:01:56 <jmcarthur_work> anq, i tend to prefer more general types when it makes sense
15:02:34 <anq> Yes, Saizan. The more general one: foo :: (Num α, MonadIO μ, MonadReader [α] μ) => Int -> μ ()  -- The more concrete one: foo :: (Num α) => Int -> ReaderT [α] IO ()
15:02:40 <jmcarthur_work> Berengal, i don't really understand the distinction there
15:03:38 <Berengal> jmcarthur_work: If you've got a points-free function already, but want to make it do even more, it's probably better to just add a few point, or probably even factor it out into several functions
15:04:03 <anq> jmcarthur_work, well, when does it make sense? That's basically what I want to understand. The choice between general and concrete signatures can't always be made arbitrarily.
15:04:18 <mmorrow_> aww, too bad marsvolta's gone http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2978 :)
15:04:21 <jmcarthur_work> Berengal, oh. i definitely think that composition should be preferred over extending existing functions, most of the time
15:05:21 <jmcarthur_work> anq, it may make sense to make it concrete if you don't want the client code to be able to use that function on other monads
15:06:28 <Berengal> jmcarthur_work: this function is already starting to become too composed already, and it doesn't involve any nasty tricks: divisors = init . tail . map head . group . sort . map product . filterM (const [True, False]) . factorize
15:06:40 <Philippa> point-free style still works best when you keep individual terms small and use lots of (named!) functions
15:06:55 <conal> anq: my leaning is toward as general as possible.  in the process, i often discover uses i didn't anticipate and wouldn't have discovered if i limited the type to my preconceived notions.
15:07:01 <jmcarthur_work> Berengal, what Philippa said. i think we are not in disagreement :)
15:07:25 <ceninan> well, the overall consensus seems to be to use a pointfree style
15:07:34 <desp> Wow.
15:07:38 <Philippa> I wouldn't say that
15:07:38 <Berengal> jmcarthur_work: Yeah, agreed. The point of pointless is to decrease the amount of code, not to increase the "space" available to put code in
15:07:47 <pikhq> ceninan: Use it when it makes sense.
15:07:51 <desp> I haven't used this many language extensions before.
15:07:59 * Philippa tends to a pointed style by default, with point-free when it's clearly saving a lot of noise
15:08:05 <PeakerWork> Berengal:   map head . group    deserves a name.  init . tail   can be named chop...
15:08:06 <Philippa> (fmap & relatives I like)
15:08:09 <conal> ceninan: john backus offered relevant advice in his turing award paper.
15:08:12 <desp> Heffalump, copumpkin: if you care -- http://pastie.textmate.org/private/ocgh73uvszxoucg8zbqlw
15:08:13 <conal> @where liberated
15:08:14 <lambdabot> http://www.stanford.edu/class/cs242/readings/backus.pdf
15:08:18 <ceninan> pikhq: oh of course - when it makes sense to _me_ ;)
15:08:19 <conal> ceninan: ^^
15:08:36 <Berengal> PeakerWork: sortNub = map head . group . sort; powerSet = filterM (const [True, False])
15:08:54 <Berengal> At least that's what I've got in my Hackertools module
15:09:02 <PeakerWork> yeah, that's better
15:09:03 <ceninan> conal: you know, I programmed a bit in J, so I've actually read it :)
15:09:04 <Philippa> also, the more parameters the function has, the less likely it is to make sense in pointless style
15:09:24 <jmcarthur_work> i tend to write in pointed style first, then refactor/rewrite in point free style. it makes it more readable to me (when I do it right!) and helps me check that i implemented the function i intended to
15:09:28 <anq> conal, aye. On jmcarthur_work's argument: I could wrap the general function up in an other function of a more concrete signature and export only that, no? So, there's the possibility of having both.
15:09:30 <Philippa> similarly if you've got piles of nested functions, the subfuncs may make most sense if they can see a named parameter to the outer function
15:09:45 <copumpkin> desp: I think {-# UNPACK #-} only works on the field next to it, but you could do -funbox-strict-fields
15:09:54 <PeakerWork> jmcarthur_work: so you write it in source form, and then encrypt it later :-)
15:10:05 <jmcarthur_work> PeakerWork, no, i *decrypt* it :P
15:10:07 <conal> anq: yes indeed.
15:10:09 <copumpkin> desp: also, I why do you need overlapping and undecidable instances? seems like you'd want to avoid that if possible
15:10:13 <jmcarthur_work> the original version is more of a brain dump
15:10:18 <conal> anq: what's motivating you to restrict the (exported) type?
15:10:18 <PeakerWork> jmcarthur_work: Kidding, I prefer points-free too, though sometimes it does take a bit more mind bending to read
15:10:24 <anq> Does the module system support anything like the restriction of a signature to something more concrete when exporting the function? Like, module Name ( foo :: Int -> Int ) where ..., where foo :: (Num α) => α -> α?
15:10:28 <Berengal> Nothing annoys me more than a function taking three parameters in the code and one hidden in pointless style...
15:10:28 <desp> copumpkin: these were forced upon me.
15:10:33 <Heffalump> anq: no
15:10:37 <Heffalump> but it might be nice if it did
15:10:48 <ceninan> ok, so there really isn't any consensus then :/
15:10:52 <Philippa> Berengal: I don't mind it in certain cases, but...
15:11:03 <desp> copumpkin: overlapping intances is needed for  instance (Vector v) => AddSub v
15:11:04 <PeakerWork> jmcarthur_work: The point-ful one is the easy way to pump stuff up so it matches the type or does what you want.  The refactoring to points-free tells you what structure you just discovered :)
15:11:07 <copumpkin> desp: I can see where the overlapping comes from (although you could avoid that by only making concrete instances)
15:11:11 <jmcarthur_work> Berengal, i don't mind if the type signature is parenthesized to reflect the number of parameters (showing that it returns a function)
15:11:11 <ceninan> which means I will write what I feel like, and if someone yells at me loud enough I might change it :D
15:11:13 <copumpkin> yeah
15:11:24 <jmcarthur_work> PeakerWork, exactly :_
15:11:26 <desp> copumpkin: yeah, and duplicate the code?
15:11:26 <jmcarthur_work> *:)
15:11:32 <Philippa> ceninan: one thing I think is fairly reliable is that just about everyone can at least read pointed style slowly - whereas dense pointless code causes incredible WTFage in people not used to it
15:11:44 <copumpkin> desp: it's still safer, but I guess :)
15:11:52 <copumpkin> where does undecidable come into play?
15:11:56 <desp> copumpkin: instance (Vector v) => AddSub v
15:12:00 <Berengal> Philippa, jmcarthur_work: Again, it depends on context, but in the majority of cases, if you've got more than two parameters, name them all
15:12:06 <desp> copumpkin: "Constraint is no smaller than the instance head"
15:12:23 <SamB_XP> copumpkin: that's when you implement a turing machine in the type system, I think
15:12:29 <PeakerWork> Philippa: Yeah, point-ful is more readable for the general populace, indeed an advantage. Points-free exposes some structure and potential for generality than point-ful does not always
15:12:30 <copumpkin> yeah
15:12:32 <Berengal> Haskell is great at allowing you to emphasise different things in code...
15:12:45 <desp> copumpkin: but I'm greatly confused by the IncoherentInstances requirement
15:13:00 <anq> conal, generality adds a new degree of freedom to the applicability of code. I wonder if a more general signature could lead to unanticipated errors.
15:13:04 <Philippa> PeakerWork: I think you can go a long way on the latter by keeping all your functions small regardless - YMMV, of course
15:13:08 <jmcarthur_work> Berengal, for example, foo :: (Foo -> Bar) -> ([Foo] -> [Bar]) ; foo = map bar  -- i find perfectly acceptable (even in more complicated cases) because the type signature reflects the number of parameters
15:13:13 <Philippa> Berengal: yes, very much so!
15:13:18 <jmcarthur_work> oops
15:13:20 <desp> copumpkin: that's needed for  instance (Vector v) => Abs v Scalar where abs v = sqrt (v * v)
15:13:24 <jmcarthur_work> rid the f
15:13:37 <jmcarthur_work> the "bar" i mean
15:13:52 <SamB_XP> anq: why not restrict the functions own type, then?
15:13:52 <jmcarthur_work> bad example :(
15:14:11 <ceninan> Philippa: that's a very good point
15:14:22 <jmcarthur_work> not even true to what i was trying to say, even.
15:14:40 <PeakerWork> maybe map should be called each, to be consistent with first/second
15:15:09 <anq> SamB_XP, well, because that generality might actually be useful. :P I am just thinking about cases in which more concreteness would be the way to go. And I can't think of any where generality, if treated right, might cause problems.
15:15:18 <PeakerWork> > let each = map in     (each . first) (*2) [(1,2),(5,6)]
15:15:20 <lambdabot>   [(2,2),(10,6)]
15:15:20 <Philippa> PeakerWork: in a functorless world...
15:15:43 <PeakerWork> Philippa: fmap can then be map, and then instance Functor [] where map = each :)
15:15:53 <conal> anq: and i guess restricting the type helps to quiet that worry, without having to examine it.
15:16:07 <Berengal> What also works is 'foo bar = \baz -> [...]'
15:16:29 <Philippa> anq: generally the answer is no so long as you keep track of all your invariants
15:16:43 <anq> Aye.
15:16:54 <mmorrow_> you can always use a module that's only purpose is to import functions qualified, restrict their type, then re-export the restricted-with-same-name version (that this is a hack aside)
15:17:44 <conal> anq: my leaning is to think it through & resolve the nagging doubts.
15:18:17 <Heffalump> conal: more concretely, restricted types make type inference work better, generally
15:18:18 <desp> Is it possible to enable -funbox-strict-fields on a per-file basis?
15:18:25 <mmorrow_> module Foo(takeI) where import qualified Prelude as P; take :: Int -> [Int] -> [Int]; take = P.take
15:18:27 <conal> Heffalump: sure does
15:18:31 <Heffalump> i.e. they reduce the number of type signatures required in client code
15:18:32 <mmorrow_> err, s/takeI/take/
15:18:44 <Heffalump> I think that's an important part of a well-designed library.
15:18:48 <dschoepe> Is the full source of the yampa-based space invaders implementation available somewhere? (http://www.haskell.org/yale/papers/haskell-workshop03/index.html )
15:19:02 <mmorrow_> desp: {-# OPTIONS_GHC -O2 -funbox-strict-fields #-}
15:19:09 <conal> and type specialization leads to easier to decode error messages.
15:19:26 <desp> mmorrow_: thanks.
15:19:38 <mmorrow> desp: np
15:19:40 <jmcarthur_work> surely if the generality makes it all the way to the library interface then it was found to not be too cluttered anyway
15:19:40 <conal> which i think is how the haskell 1.4 prelude became the haskell 98 prelude
15:20:02 <jmcarthur_work> i at least like the general version to be exposed, even if they are behind a separate import or something
15:20:03 <anq> conal, well, my main doubt is that, for example, certain structures are to obey a couple of laws which Haskell does not enforce. So, a violation of those laws could make the function misbehave. At that point I would have to trust the programmer who uses the library to make sure that the laws are met.
15:21:11 <Philippa> anq: well yes, ensuring that a library's types enforce its invariants to the best extent reasonably possible is a good thing
15:21:16 <conal> anq: great, thx.  that's a general problem with type class programming.  are you talking about some standard classes with their laws?  or adding some classes with associated laws?
15:21:18 <jmcarthur_work> anq, you could always have a type wrapper with a smart constructor to force the client code to check that precondition first, then just use that type concretely as the input type (but it could have polymorphic type parameters)
15:21:24 <Philippa> or are you worried about the general functions from another lib?
15:22:52 <jmcarthur_work> anq, typically, the internals of the data types with invariants should not be exposed to the client code anyway
15:23:24 <jmcarthur_work> otherwise i would say it is an abstraction leak
15:23:43 <conal> jmcarthur_work: i'm with you there.
15:24:33 <anq> conal, both. I mean, the same problem arises in every discussion about monads. If, for example, a MonadPlus instance doesn't satisfy mzero >>= f = mzero, then guard would misbehave, if I understand that piece of code correctly. That's true for adding new classes with laws. In those aspects, generality might be problematic.
15:25:18 <Philippa> anq: that's pretty much a Don't Do That Then - if you create an instance that doesn't meet the appropriate laws, all bets are off
15:25:18 <conal> anq: i agree with you.  that's what i meant about it being a general problem with type class programming.
15:25:28 <Philippa> the breakage is with the instance, not with generic functions that're doing their best
15:25:30 <anq> Aye.
15:26:00 <Philippa> (arguably also with Haskell itself, but if you really want to avoid that you have to code in something like Agda or Coq)
15:26:14 <conal> anq: that's my advice also.  rely on type class instances to satisfy laws, even though the compiler can't check them.
15:26:25 <anq> Alright.
15:26:26 <jmcarthur_work> if the instance is broken, all code is broken anyway
15:26:29 <VonGuard> bos? you awake?
15:26:34 <SamB_XP> you at least have to make your instance follow the laws in an obiwan kind of way
15:27:10 <conal> anq: without dependent types, type checking only gets us so far.  from there we have to be careful.
15:27:12 <jmcarthur_work> in fact, some follow the convention that if some law must be obeyed somewhere and it can't be hidden, it should at least be put in a type class
15:27:14 <Philippa> SamB_XP: yeah, I figure the monad laws're allowed a layer of embedding 'tween Haskell and the monad itself so long as the laws hold in that embedding
15:27:41 <Philippa> yeah, that at least requires you to explicitly declare membership
15:27:42 <SamB_XP> Philippa: I was thinking of quickCheck's Gen
15:39:01 <anq> Thanks for the answers. :)
15:43:58 <SamB_XP> anq: just wait until you figure out the questions!
15:48:46 <ceninan> hope you'll forgive me for going off-topic, but the conversation seems to have calmed down a bit: does anyone here use a non-standard (not in general use in your country) keyboard layout, and why (not)?
15:49:15 <Troll> I do
15:49:28 <Zao> ceninan: US International without dead keys, as opposed to sv_SE.
15:49:28 <ceninan> I've been thinking of making a switch, but don't really know to what and if it's really worth it (especially having to rebind Vi etc.)
15:49:30 <Troll> Because it has characters i use, such as λ
15:49:31 <Berengal> I've rebound some commonly used keys to some uncommonly used keys
15:49:48 <Zao> It's all for the non-letter glyphs. Letters are fine as they are.
15:49:53 <Troll> Mine's just gb with minor changes
15:49:55 <ceninan> Berengal: that sounds like a really good idea... ;)
15:49:57 <sm> is there a better way to write hGetContentsStrictlyAnd than http://gist.github.com/147264 ? Eg not just for String ?
15:50:15 <FauxFaux> I use colemak 'cos the idea that qwerty wasn't designed annoys me. ¬_¬
15:50:31 <Berengal> ceninan: I've got a non-english keyboard, so I made my own coding layout. No sense in pressing alt-gr+shift+num just to get brackets...
15:50:39 <SamB_XP> FauxFaux: it was designed!
15:50:54 <FauxFaux> Not according to any modern definition of designinating.
15:50:55 <SamB_XP> it was designed so that frequently paired letters wouldn't jam together
15:51:04 <ceninan> Berengal: no, coming from Sweden I recognize the problem
15:51:05 <Berengal> Also, moved punctuation to the home row
15:51:17 <ceninan> Berengal: programming langauges usually design around US-layout
15:51:35 <ceninan> which is tedious at best in many languages with extended character sets :/
15:51:41 <SamB_XP> i.e. wouldn't be too close together in location
15:51:48 <Berengal> Indeed. Anyway, switching layouts is a simple key away anyway
15:52:01 <FauxFaux> Colemak is great for that, only one symbol moved (p and ; (qwerty printings) are swapped).
15:52:10 <Zao> ceninan: http://keyboards.jargon-file.org/#us-gen "United States International Alternate"
15:52:34 <Zao> The best thing about it is that it's available on all sane platforms (reasonably fresh X.org and Windows)
15:52:50 <Berengal> One anoying thing is that ` is a dead-key on my default layout..
15:53:10 <ceninan> same here :)
15:53:57 <Berengal> Anyway, I need some greek letters on my third layer... I suddenly feel motivated to do that
15:54:00 <ceninan> well, yes, it's simple to switch, which is why I often program using the US layout
15:54:33 <ceninan> but the paranthesis is moved one step from in my native layout, which is _really_ annoying
15:55:01 <Zao> ceninan: So just drop regular swedish?
15:55:23 <Zao> US Intl has äåö on AltGr-qwp.
15:55:39 <ceninan> hmm, well, åäö are quite common letters in swedish
15:55:50 <ceninan> it would be a bit like dropping 'u' in english
15:56:42 <Zao> I haven't used the sv layout for almost a year now.
15:57:10 <ceninan> isn't that annoying when typing Swedish?
15:57:35 <uzytkownik> @pl \x y -> 10*x + y
15:57:35 <lambdabot> (+) . (10 *)
15:57:40 <Zao> Nah, I've gotten used to it.
15:57:57 <Zao> As a bonus, I've got all kinds of fun glyphs on AltGr.
15:58:13 <Vanadium> @pl \x y -> x >>= (>>= foo .y)
15:58:14 <lambdabot> (. ((=<<) . (foo .))) . (>>=)
15:58:14 <Zao> No lambda though, I suppose I should hack in some of the unicode syntax glyphs.
15:58:36 <ceninan> well, I find I have "fun" glyphs on Alt-Gr already
15:58:45 <ceninan> certainly not _usable_ though :p
15:59:55 <ceninan> so most people who change their keyboard layouts only rebind the special characters?
16:09:16 <uzytkownik> @hoogle -> m a -> m b -> m a
16:09:16 <lambdabot> Parse error:
16:09:17 <lambdabot>   --count=20 "-> m a -> m b -> m a"
16:09:17 <lambdabot>              ^
16:09:20 <uzytkownik> @hoogle m a -> m b -> m a
16:09:21 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
16:09:21 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
16:09:21 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
16:09:55 <FunctorSalad> ceninan: I have a german kb but use english layout due to better special character position, but use xmodmap to get my umlauts back
16:10:24 <FunctorSalad> (with AltGr)
16:10:43 <Vanadium> I am using a german keyboard and english keymap and xterm just binds umlauts to alt-d, v, | by default, so I am happy 90% of the time
16:13:36 <ceninan> thanks - this setup seems to be quite common
16:14:12 <ceninan> I'll probably try it, as learning a whole new layout does seem awfully tedious :)
16:15:06 <uzytkownik> @hoogle a -> Int
16:15:07 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
16:15:07 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
16:15:07 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
16:15:20 <uzytkownik> @hoogle a -> Int -> [a]
16:15:21 <lambdabot> Prelude replicate :: Int -> a -> [a]
16:15:21 <lambdabot> Data.List replicate :: Int -> a -> [a]
16:15:21 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
16:15:58 <uzytkownik> @hoogle [m a] -> m [a]
16:15:58 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
16:15:58 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
16:15:58 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
16:16:50 <discovercard>         Eight inches ... Nine, and still growing.  His erection was now
16:16:52 <discovercard> half as thick as his own wrist as -with a grunt of sexual ecstasy- he
16:16:52 <discovercard> began to spurt enormous quantities of cum into Christa's throat.
16:16:52 <discovercard> Greedily, she slurped and sucked on him as the tingle began to fade.  Drop
16:16:52 <discovercard> by drop, she tried to stem the stream, but enormous quantities spilled out
16:16:54 <discovercard> from around her mouth.  Nearly a minute passed, as Curt reached and
16:16:56 <discovercard> exceeded ten inches.  Still sucking down as much of his cum as she could,
16:16:58 <discovercard> Christa squeezed his balls tightly, as if wringing every drop out of him.
16:17:00 <discovercard> Spurting over her lips, face and hair, Curt's orgasm gradually subsided,
16:17:03 <discovercard> leaving him still shaking with pleasure.
16:17:06 <discovercard>         Gasping for air, Christa wiped her mouth on the back of her hand
16:17:08 <discovercard> and looked at Curt, stunned.  "That's ... that's some experiment!" she
16:17:11 <discovercard> gasped.
16:17:13 <discovercard>         Curt looked at his erection, amazed.  "I thought it had stopped
16:17:16 <discovercard> earlier...  My God, I'm huge!" Tentatively, he touched his engorged tip
16:17:18 <discovercard> and patted it with his finger tips.  It bobbed slightly as he stood up.
16:17:21 <Badger> you know
16:17:21 <discovercard>         Picking up a tape measure from the hall desk, Christa quickly came
16:17:23 <discovercard> over to Curt and measured him.  She let out a low whistle of appreciation
16:17:26 <discovercard> at his new length as she wrapped the tape measure around his shaft.  She
16:17:28 <discovercard> looked up at him...  "Curt, you've grown to eleven inches long and
16:17:29 <Badger> I can't remember who has ops in here.
16:17:31 <discovercard> five-and-a-half inches around." She did some quick mental math.  "Jesus,
16:17:33 <Botje> @where ops
16:17:34 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
16:17:34 <discovercard> Curt.  You're almost two inches thick!  What was in that stuff you
16:17:34 <lambdabot> mauke
16:17:36 <discovercard> experimented with?"
16:17:58 <discovercard>         Curt shrugged.  "A variety of organic compounds normally found in
16:17:58 <discovercard> DNA patterns associated with sexual development.  I mean, I had to also
16:17:58 <discovercard> add synthetic hormones and dissolve it all in an amino acid bath, but I
16:17:58 <discovercard> didn't expect this sort of reaction...  Earlier, it enlarged me quite a
16:17:58 <discovercard> bit ... over a fifty-percent increase.  This isn't that much of an
16:17:58 <discovercard> increase compared to the first growth spurt, but I never expected..."
16:17:58 <discovercard>         "Are you saying that you'll get bigger every time you climax?"
16:17:58 <discovercard>         The abrupt question brought Curt to a sudden stop.  In truth, he
16:17:59 <discovercard> had tried to tie the growth to hormonal and stress levels in the body and
16:18:02 <Badger> Botje: nice. :)
16:18:02 <discovercard> appropriate glands, but could it be true?  He shuddered to think about it.
16:18:05 <discovercard> Even if the percentage growth was less each time, he could be gargantuan
16:18:09 <discovercard> in a very short time...  True, he'd fantasized about elephantine
16:18:10 <discovercard> proportions and even beyond, but in Real Life...
16:18:12 <discovercard>         He looked at Christa, uncertain.  "I really don't know.  It wasn't
16:18:14 <Botje> sigh.
16:18:14 <discovercard> as big an increase as the last time, so it may be just residual effects.
16:18:16 <uzytkownik> Botje: Thanks god for ignore function ;)
16:18:16 <discovercard> Y'see, I was aiming for something around fourteen to sixteen inches..."
16:18:19 <discovercard> Christa looked at him stunned and with a half-smile.
16:18:20 <tommd> @kick discovercard
16:18:21 <lambdabot> Maybe you meant: dice dict kind
16:18:21 <discovercard>         "Not bad..." she murmured.  Brightening, she tapped his still-stiff
16:18:24 <discovercard> member, "I guess we'll have to test that theory ... get on the bed."
16:18:24 --- mode: ChanServ set +o Igloo
16:18:26 <discovercard>         Curt looked surprised.  "But ... but Christa.  I mean, what if I
16:18:27 <Botje> hey, silence.
16:18:29 <discovercard> *do keep getting bigger?  This could be a catastrophe!"
16:18:31 <discovercard>         With raised eyebrows and lick of her lips, Christa smiled.  "Tell
16:18:34 <discovercard> me about it..." Pressing her massive breasts against his chest, she slowly
16:18:34 --- mode: ChanServ set +o dons
16:18:36 <discovercard> rubbed her flesh over his, enticing him.  Seemingly, the compound had also
16:18:36 --- mode: dons set +b *!*n=ioerror@*.pools.spcsdns.net
16:18:36 --- kick: discovercard was kicked by dons (dons)
16:18:38 --- mode: Igloo set +b *!*@72-61-98-46.pools.spcsdns.net
16:18:46 --- mode: ChanServ set -o dons
16:18:53 <Botje> ban the whole ISP!
16:18:58 <Botje> better be safe than sorry!
16:18:59 <tommd> Thats the spirit
16:19:01 <Badger> kicked at the speed of dons
16:19:23 <Elly> what the heck was that :P
16:19:25 <mike-burns> Oh I was just getting into that story too.
16:19:28 <tommd> I often wonder if these irc spam-bots are testing the reaction time of the channels.
16:19:31 <Apocalisp> dons ninja kick to the... enormous manhood
16:19:46 <Vanadium> ban the isp, scorch the routers
16:19:52 <Vanadium> salt the tables
16:19:57 <Botje> nuke the site from orbit
16:20:06 <Badger> It's the only way to be sure.
16:20:10 <Apocalisp> and throw away the sysadmin!
16:20:10 <Botje> =]
16:23:42 <FunctorSalad> hmm does't seem like commercial spam (still off-topic spam and flood, mind you)
16:25:05 <kyagrd> Is there a haskell matrix library that has matrix inversion library function?
16:25:55 <kyagrd> I thought hmatrix would have had it, but it doesn't seem so. There's no function name like inverse inv ...
16:26:21 <FunctorSalad> kyagrd: AFAIK most algorithms solve A x = b for a single b
16:26:43 <FunctorSalad> you could get the inverse by plugging in the canonical unit vectors for b
16:26:56 <copumpkin> kyagrd: I'd be very surprised if it didn't have an inverse function though
16:26:58 <FunctorSalad> e.g. (1,0,0),(0,1,0),(0,0,1)
16:27:22 <copumpkin> http://hackage.haskell.org/packages/archive/hmatrix/0.5.2.2/doc/html/Numeric-LinearAlgebra-Algorithms.html#v%3Ainv
16:28:08 <desp> Ugh.
16:28:22 <FunctorSalad> (AFAIK inverse is usually overkill, but I'm not a numeric analyst ;))
16:28:32 <desp> http://pastie.textmate.org/private/cy8lezdn7ju9fsmg5b1lg
16:28:54 <FunctorSalad> you can also get the LR decomposition or something if you want to "prepare" A for solving many systems
16:28:58 <kyagrd> I was looking down in the Matirx module only :(
16:29:04 <desp> Why is "instance (Vector v s) => AddSub v" a duplicate of "instance (Scalar s) => AddSub s", according to GHC?
16:29:45 <kyagrd> copumpkin: Thanks!!!!
16:29:49 <copumpkin> :)
16:32:16 <Cale> desp: Because there's no way to tell that there won't be future instances of one or both of those classes.
16:32:32 <bakesz> hi guys!Is there a simple way to avoid the "*** Exception: Prelude.(!!): index too large" error?I mean some settings or things like this...(sory for my english)
16:32:41 <Cale> desp: Instance selection is carried out based on the structure of the type alone, and not on which classes are present or not.
16:32:57 <Zao> bakesz: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:genericIndex
16:33:06 <Cale> Zao: hm?
16:33:13 <dons> http://www.reddit.com/r/programming/comments/918hw/pythons_generators_embedded_into_haskell_via/  nice
16:33:19 <Zao> bakesz: The core question is though, what oddball code do you have that requires you to index with gigantic numbers?
16:33:26 <desp> Cale: but I thought Vector, being a two-parameter type class, has a different structure from Scalar, an one-parameter type class?
16:33:30 <srush> hey is there a way to make a function cast :: (Val a, Val b) => a -< b that has a different definition is a ~ b
16:33:36 <Cale> Zao: the problem is that he's giving an index which is larger than the largest index in the list
16:33:42 <Zao> Cale: Oh.
16:33:46 <dons> you should be very wary of indexing lists. its an O(n) operation.
16:33:52 <Zao> I assumed it was about the Prelude and it's love for Int.
16:33:59 <Zao> bakesz: Don't index out of bounds?
16:34:18 <Cale> Yeah, usually the solution is to try to avoid using !! altogether
16:34:18 <Zao> What is your use case for !!?
16:35:12 <Cale> desp: the issue is that 's' has the same structure as 's'
16:35:38 <Cale> desp: For purposes of selecting which instance applies at a given type, it's as if the class contexts on the instances are not there at all
16:36:04 <Cale> desp: So it's like you've written  "instance AddSub v" and "instance AddSub s"
16:36:21 <Cale> desp: and of course those overlap ;)
16:36:37 <bakesz> http://haskell.pastebin.com/d5503eca5 .here is the code.I try to make a list which contains that how much step is needed to reach 1 with "Collatz conjecture" steps
16:36:41 <desp> Cale: I see.
16:36:48 <desp> Cale: is there a way to do what I mean, then? :)
16:37:10 <copumpkin> write the individual instances?
16:37:25 <desp> Right...ugh.
16:37:37 <Cale> The reason that you can't select an instance based on the class context is that any future module might include another instance -- there's no way for GHC to know when it's compiling one module that a future module won't define a new instance of Vector or of Scalar, say
16:38:19 <Cale> So it has to assume that those are present.
16:38:53 <srush> I thought maybe type families could do it
16:39:48 <Cale> srush: maybe you're looking for the cast which is already in the libraries?
16:39:57 <Cale> :t Data.Typeable.cast
16:39:59 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
16:40:48 <srush> I'd like to write a function if a is the same as b
16:41:05 <srush> so do something hard if they are different
16:41:11 <Cale> If a and b are equal types (according to their instances of Typeable), then the result of cast x is Just x, and if not, then it's Nothing
16:41:42 <srush> cool that works
16:41:52 <srush> I wonder if there is a way to do it without a run time check
16:42:01 <srush> it seems like you should be able to tell by the types
16:42:15 <Cale> There might be a way
16:42:30 <Cale> I expect it to require some more extensions.
16:45:11 <FunctorSalad> srush: there's a package for static type equality on hackage
16:45:21 <FunctorSalad> @hackage type-equality
16:45:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-equality
16:45:26 <FunctorSalad> \o/
16:45:42 <hackagebot> shelltestrunner 0.4 - A tool for testing command-line programs. (SimonMichael)
16:45:55 <uzytkownik> @pl \s -> lift $ ($ s) =<< gets output
16:45:56 <lambdabot> lift . (gets output >>=) . flip id
16:46:39 <Cale> ah, you can do it with overlapping instances
16:47:19 <srush> huh
16:47:31 <Cale> http://hackage.haskell.org/package/type-equality-check
16:47:59 * SamB_XP for some reason wants to make a service called Dead
16:48:37 <srush> that's pretty neat
16:49:04 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7011#a7011
16:49:10 <Cale> srush: ^^
16:49:40 <Cale> (naturally, you'd replace foo with the function you were actually writing)
16:50:20 <Cale> Of course, this can be a pain to actually use, because you have to ensure that the parameters' types are completely nailed down
16:50:24 <srush> hmm, I thought I tried that
16:50:32 <srush> was getting incoherentinstances errors
16:51:23 <Cale> desp: Oh, btw, the usual solution to your problem is not to try to have the same syntax for scalar multiplication and algebraic multiplication. They're really different operations anyway.
16:53:11 <uzytkownik> @pl \c p -> nPutStrLn c >> parser2nntp p
16:53:12 <lambdabot> (. parser2nntp) . (>>) . nPutStrLn
17:12:49 <Berengal> What should I name a module converting sexprs to xml?
17:13:20 <pikhq> sexToUnsex
17:13:28 <copumpkin> lol
17:13:35 <Berengal> That's the function
17:13:47 <Berengal> (Already got that one nailed (pun intended))
17:14:41 <GlassOfWater> Greetings.
17:14:45 <Berengal> I'm thinking about where in the module hierarchy it fits
17:14:46 * copumpkin drinks GlassOfWater
17:14:51 <pikhq> > "Greetings."
17:14:53 <lambdabot>   "Greetings."
17:15:01 <copumpkin> > text "Greetings."
17:15:02 <lambdabot>   Greetings.
17:15:13 <GlassOfWater> Drink all you want.
17:15:19 <copumpkin> why thank you
17:15:25 * copumpkin drinks all he wants
17:15:28 <canvon> :t text
17:15:29 <lambdabot> String -> Doc
17:15:40 <canvon> @hoogle Doc
17:15:41 <lambdabot> Text.PrettyPrint.HughesPJ data Doc
17:15:41 <lambdabot> Language.Haskell.TH.PprLib type Doc = PprM Doc
17:15:43 <lambdabot> Distribution.Simple.InstallDirs docdir :: InstallDirs dir -> dir
17:15:50 <GlassOfWater> Will you haskellians respond to a simple question?
17:16:01 <GlassOfWater> What is the source of the words function?
17:16:04 <pikhq> GlassOfWater: Don't ask to ask, just ask.
17:16:05 <copumpkin> @src words
17:16:06 <monochrom> Don't prematurely classify questions as simple.
17:16:06 <lambdabot> words s = case dropWhile isSpace s of
17:16:06 <lambdabot>     "" -> []
17:16:06 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:16:06 <Berengal> @src words
17:16:07 <lambdabot> words s = case dropWhile isSpace s of
17:16:07 <lambdabot>     "" -> []
17:16:08 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:16:15 <copumpkin> tada!
17:16:20 <copumpkin> twice the source
17:16:20 <SamB_XP> monochrom: well, that *was* a simple one
17:16:22 <copumpkin> twice the love
17:16:24 <Philippa> @quote no more stereo
17:16:25 <lambdabot> No quotes for this person. You type like i drive.
17:16:34 <SamB_XP> @quote stereo
17:16:35 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
17:16:36 <GlassOfWater> ops, I meant unwords
17:16:38 <monochrom> "Hi simple question, how to prove or disprove P=NP? It's very simple!"
17:16:39 <SamB_XP> hahaha
17:16:39 <GlassOfWater> let me try this
17:16:46 <GlassOfWater> @src unwords
17:16:46 <lambdabot> unwords [] = ""
17:16:46 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
17:16:51 <GlassOfWater> uhm
17:16:53 <GlassOfWater> interesting
17:17:01 <pikhq> monochrom: Start by solving the halting problem.
17:17:05 <pikhq> Then get back to me.
17:17:07 <pikhq> ;)
17:17:15 <monochrom> That's simple.
17:17:17 <canvon> GlassOfWater: for the source of standard functions, you can also have a look at the standard prelude: http://www.haskell.org/onlinereport/standard-prelude.html#preludelist (words is defined in that section)
17:17:18 <SamB_XP> pikhq: does that actually lead to the answer ?
17:17:18 <Berengal> alternatively: unwords = concat . intersperse ' '
17:17:29 <pikhq> SamB_XP: ... Probably not.
17:17:45 <GlassOfWater> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#unwords
17:17:47 <SamB_XP> pikhq: can you prove that?
17:17:50 <GlassOfWater> I was looking there, canvon
17:17:54 <pikhq> SamB_XP: No.
17:17:56 <Berengal> @faq can haskell prove/disprove P=NP?
17:17:57 <lambdabot> The answer is: Yes! Haskell can do that.
17:18:02 <Berengal> :O
17:18:20 <benmachine> it just doesn't want to
17:18:20 <GlassOfWater> and there are two different unwords functions
17:18:26 <yairchu> @faq can haskell bababubu
17:18:27 <lambdabot> The answer is: Yes! Haskell can do that.
17:18:31 <benmachine> @src unwords
17:18:32 <lambdabot> unwords [] = ""
17:18:32 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
17:18:41 <benmachine> @src intersperse
17:18:41 <lambdabot> intersperse _   []     = []
17:18:41 <lambdabot> intersperse _   [x]    = [x]
17:18:41 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
17:18:49 <benmachine> oic
17:18:53 <benmachine> handy
17:18:54 <monochrom> @hackage P_Equals_NP
17:18:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/P_Equals_NP
17:18:55 <Berengal> @check unwords . words <*> concat . intersperse ' ' . words
17:18:56 <lambdabot>   Couldn't match expected type `a -> b'
17:19:16 <GlassOfWater> #ifdef USE_REPORT_PRELUDE
17:19:21 <SamB_XP> Beelsebob: hey, I was just asking if we could prove halts-p => decidable (P=NP)
17:19:23 <GlassOfWater> I see what they did there.
17:20:12 <SamB_XP> GlassOfWater: I wonder how many years ago someone last built it that way?
17:20:26 <idnar> what's the difference between those two definitions, besides efficiency?
17:20:41 <GlassOfWater> none
17:20:45 <GlassOfWater> I think
17:20:51 <SamB_XP> idnar: one of them is easier to read
17:20:52 <Berengal> @check (==) <$> unwords . words <*> intercalate " " . words
17:20:53 <lambdabot>   "OK, passed 500 tests."
17:21:08 <Berengal> I always mix up intercalate and intersperse
17:21:10 <copumpkin> need moar applicative
17:21:21 <benmachine> @index intersperse
17:21:22 <lambdabot> Data.List
17:21:22 <idnar> SamB_XP: well, I mean, is there a difference in strictness or something?
17:21:25 <monochrom> applicative needs to be wanted
17:21:37 <Berengal> @check (==) <$> (unwords <$> words) <*> (intercalate " " <$> words)
17:21:38 <SamB_XP> idnar: I think probably not
17:21:38 <lambdabot>   "OK, passed 500 tests."
17:21:47 <idnar> @type liftA2
17:21:48 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
17:21:54 <aavogt> {-partain:Char.-} ?
17:22:07 <GlassOfWater> aavogt: probably GHC magic
17:22:10 <aavogt> is that just a comment?
17:22:17 <SamB_XP> idnar: I think it's just in case something went horribly wrong with the Glasgow versions that they put it in #ifdefs
17:22:21 <GlassOfWater> means "to use Char.something"
17:22:41 <SamB_XP> aavogt: it's not a bona-fide pragma
17:22:48 <SamB_XP> GHC itself won't do anything for it
17:23:01 <SamB_XP> I can't say whether a script mightn't read it ...
17:23:38 <aavogt> interesting
17:23:43 <SamB_XP> it may easily just be a comment, though
17:23:50 <SamB_XP> a really hard to read comment
17:24:43 <SamB_XP> I would tend to blame GreatLord, except he's a ReactOS developer, not a GHC developer ...
17:26:06 <GlassOfWater> weird, you're right
17:26:24 <SamB_XP> GlassOfWater: hmm?
17:26:25 <GlassOfWater> they are already using import Data.Char(isSpace)
17:26:42 <GlassOfWater> what the hell is that thing, then?
17:27:47 <Berengal> I really can't say what to name my module. Text.Sexpr.Convert.XML? Markup.Sexpr.Convert.XML? Markup.Convert.Sexpr.XML? Control.Monad.No.Not.Really.Convert.XML?
17:28:26 <idnar> Unsafe.Coerce.Just.Kidding.Sexpr.XML
17:28:34 * Berengal wishes for tagging instead of a hierarchy now
17:28:51 <Pseudonym> Berengal, there's UIMA.
17:29:04 <aavogt> > sort "Markup.Sexpr.Convert.XML"
17:29:05 <lambdabot>   "...CLMMSXaeeknopprrrtuvx"
17:29:11 <GlassOfWater> SamB_XP: according to Google, one of the GHC devs is called Will Partain
17:29:24 <Pseudonym> Tag your modules instead of putting them in a hierarchy with UIMA.
17:29:38 <Pseudonym> What a dumb idea that is.
17:30:04 <SamB_XP> GlassOfWater: oh. that explains that, I guess?
17:30:09 <SamB_XP> Pseudonym: hmm?
17:30:16 <Berengal> Pseudonym: Yes, hmm?
17:31:41 <Berengal> Markup.Sexpr.Convertron
17:32:03 <idnar> ugh, I read "Sextron"
17:32:10 <idnar> I think I need more sleep
17:32:15 <SamB_XP> I think sotoo
17:32:20 <Berengal> The package's called SeXML...
17:32:30 <SamB_XP> there was neither S nor x in that...
17:32:34 <SamB_XP> Berengal: what the?
17:32:52 <idnar> SamB_XP: there was, it was just a few chars further back :P
17:33:19 * SamB_XP tries to decide whether or not that would make it NSFW
17:33:22 <Berengal> SamB_XP: sexpr→xml is boring, sexprml is just weird. It was either sexyml or sexml
17:33:49 <SamB_XP> Berengal: eww, sexprml
17:33:50 <copumpkin> sexml
17:33:57 <copumpkin> sxml
17:34:02 <SamB_XP> that gives me flashbacks to boundvariable.org
17:34:03 <Berengal> sxml might work...
17:34:11 <jeffwheeler> Is there a 64-bit Windows installer for GHC?
17:34:17 <copumpkin> noes
17:34:23 <jeffwheeler> :(
17:34:28 <SamB_XP> are there binaries?
17:34:59 <Berengal> I've gotten the platform installed on my XP 64, but I don't know if the software itself is 64 bit
17:35:29 <Zao> No, it's not.
17:35:41 <jeffwheeler> Yeah, I expect the GHC installer to work just fine . . . but that's lame.
17:35:51 <Zao> I don't believe that GHC is ported to 64-bit mingw either.
17:35:55 <jeffwheeler> I'm new to Windows software, though, so I don't know if this is common.
17:36:10 <Berengal> Most of my software is 32 bit still
17:36:18 <SamB_XP> jeffersonheard: it's common with GHC
17:36:34 <SamB_XP> er. jeffwheeler
17:36:39 <pikhq> ... 32-bit software?
17:36:42 <SamB_XP> there are too many people in here, I say
17:36:46 <copumpkin> thoughtpolice: yo yo
17:36:52 <pikhq> Oh, right. Windows doesn't do x86_64 that well.
17:37:00 <Zao> pikhq: Windows does alright.
17:37:03 <SamB_XP> pikhq: windows does fine
17:37:04 <Zao> As does VS.
17:37:12 <Zao> mingw on the other hand, is quite amusing to see struggle.
17:37:13 <pikhq> Okay, fine. I should specify.
17:37:16 <SamB_XP> it's GHC that doesn't port easily
17:37:19 <pikhq> Windows *software* doesn't.
17:37:35 <SamB_XP> and, yeah, a lot of people don't bother even when it would be easy
17:37:47 <SamB_XP> to be fair, some of them might be dead or out of bussiness
17:37:48 <uman> not sure if it was a 64-bit issue or a Windows 7 issue, but MS Paint on my laptop committed 2 GB of ram opening a 1 MB file
17:37:53 <idnar> SamB_XP: well, if you want to use more than 2GB of RAM...
17:38:02 <Zao> idnar: Or three, or four.
17:38:10 <Zao> Depending on moon phase, kernel and boot settings.
17:38:18 <Zao> And LARGEIMAGEAWARE flag in the PE.
17:38:20 <uman> some algorithm for decompressing TIFFs has a huge ass memory leak somewhere I guess
17:38:20 <idnar> Zao: I was talking about Windows, specifically
17:38:24 <Zao> idnar: On windows.
17:38:25 <SamB_XP> Zao: I don't think Windows offers a 4GB setting
17:38:29 <Berengal> I'm always at 4 GB ram, 0 bytes swap...
17:38:30 <SamB_XP> could be wrong
17:38:48 <Zao> SamB_XP: 64-bit Windows gives four gigs of address space to largeaddressaware applications.
17:38:48 <SamB_XP> idnar: Windows does definately offer a 3GB boot option/image flag
17:38:58 <Zao> PAE kernels give three or four, depending on moon phase.
17:39:10 <SamB_XP> Zao: oh, PAE
17:39:13 <Zao> It's rather complex, but you can get all four gigs of address space mapped in.
17:39:16 <idnar> SamB_XP: well, it's not the default
17:39:27 <idnar> SamB_XP: and it's probably not worth fiddling with that stuff, honestly
17:39:29 <uman> wait, what? 64-bit windows only gives apps 4gb of address space?
17:39:32 <pikhq> A proper 64-bit OS can give several exabytes to applications.
17:39:34 <Zao> uman: 32-bit apps.
17:39:42 <uman> Zao: ahhh, okay I misunderstood
17:39:44 <SamB_XP> pikhq: not 32-bit apps
17:39:48 <Zao> You can of course use AWE to map in windows of more memory.
17:40:04 <pikhq> uman: You have to pay extra for versions that do more than 8G. :P
17:40:05 <SamB_XP> Zao: how will an obsolete SB synthesizer help?
17:40:06 <Berengal> I thought 48 bit addresses were the common size these days...
17:40:13 * idnar giggles
17:40:19 <pragma_> 32-bit apps can only give somewhere between 2 and 3.125 gb or so
17:40:24 <pikhq> SamB_XP: There's hacks to access more than 4G in Windows and UNIX. (mapping it in and out of the address space)
17:40:28 <Zao> pragma_: Wrong.
17:40:29 <pikhq> Bit of a pain to do, but.
17:40:31 <pragma_> s/apps/oses/
17:40:54 <idnar> pikhq: what's the but?
17:41:00 <pikhq> pragma_: Except for PAE, which extends pointers in the page table to 36 bit.
17:41:06 <pikhq> idnar: But you can do it.
17:41:12 <idnar> pikhq: oh, well
17:41:15 <SamB_XP> oh, yeah, PAE is available without 64-bit
17:41:17 <idnar> pikhq: I'm just not sure why you'd want to :P
17:41:18 <SamB_XP> sometimes
17:41:20 <uman> pikhq: each app can only see 4gb though
17:41:23 <Zao> SamB_XP: Provided you have the right SKU.
17:41:23 <uman> if I'm not mistaken
17:41:25 <Berengal> I've got this great idea for extending the address space: segmented memory!
17:41:28 <SamB_XP> though 64-bit, iirc, requires it
17:41:35 <SamB_XP> Zao: right what?
17:41:41 <pikhq> uman: At a time.
17:41:44 <SamB_XP> don't you mean the right CPU?
17:42:00 <Zao> SamB_XP: AWE is Addressing Windowing Extension or something, the API you use to window memory.
17:42:03 <Zao> SamB_XP: No, SKU.
17:42:05 <SamB_XP> Berengal: that doesn't work
17:42:10 <Zao> PAE is disabled on most client Windowsen.
17:42:27 <Berengal> SamB_XP: It used to
17:42:32 <SamB_XP> Zao: oh, I'm talking CPU capabilities
17:42:41 <SamB_XP> Berengal: not on IA-32 it doesn't
17:42:41 <idnar> isn't PAE basically segmented memory all over again?
17:42:47 <SamB_XP> idnar: no ...
17:42:49 <Zao> idnar: No.
17:42:50 <pikhq> x86_32 still does segments.
17:42:52 <SamB_XP> it's paging
17:42:55 <Zao> idnar: It's an additional level of page tables.
17:43:04 <SamB_XP> with larger physical addreses supported
17:43:22 <pikhq> (386 made it so that segments could cover all of the address space, but it still has segments)
17:43:26 <idnar> that's pretty much the same thing from more than a few meters away, though
17:43:33 <SamB_XP> pikhq: yeah
17:43:39 <Zao> idnar: Non-kernel code doesn't care.
17:43:41 <SamB_XP> pikhq: so it doesn't expand the address space a bit
17:43:47 <uman> idnar: not really
17:43:48 <Zao> That's an fairly important distinction.
17:43:50 <idnar> ugh
17:43:53 <pikhq> SamB_XP: Right.
17:43:54 <idnar> I mean AWE, not PAE
17:43:54 <Zao> No far pointers, no segmentation pain.
17:43:54 <SamB_XP> and hence Berengal's idea doesn't work anymore
17:44:08 * idnar gives up and goes to bed
17:44:13 <uman> 'night
17:44:14 <pikhq> SamB_XP: Though it would be trivial to make it extend the address space.
17:44:28 <pikhq> Change the size of pointers in the *segment* table, et voila.
17:44:36 <pikhq> (and god, what a hack that would be)
17:44:40 <jeffwheeler> http://haskell.org/platform/ should redirect
17:44:42 <SamB_XP> idnar: that's a great deal closer to the truth, I guess, although I would invoke the terms "bank switching" and "overlays"
17:45:02 <joeyadams> Haskell newbie here:  in ghci, I did let fib(x) = if x<2 then 1 else fib(x-2)+fib(x-1) .  Why does fib(30) take so long? (around 2 seconds on my Core 2 Duo)
17:45:04 <Zao> The reason that you need the largeaddressaware flag in the first place is that many applications do naughty things to the high bit in pointers.
17:45:26 <SamB_XP> pikhq: IA-32's tend to get upset when the segment limit is past 2^32
17:45:34 <Berengal> joeyadams: Because that's a really bad algorithm
17:45:37 <SamB_XP> Zao: yeah
17:45:48 <pikhq> SamB_XP: That's because the segment pointer is 32-bit.
17:45:52 <joeyadams> Hmm.  Makes sense.
17:45:56 <SamB_XP> pikhq: not only that
17:46:00 <benmachine> joeyadams: well, each call to fib() spawns two more calls to fib()
17:46:07 <pikhq> Fine. Among other things.
17:46:08 <joeyadams> so it's a forkbomb :)
17:46:08 <Zao> Much like GHC does pointer tagging, I guess.
17:46:20 <benmachine> similar idea
17:46:24 <copumpkin> look at my failgebra! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7015#a7015
17:46:26 <jeffwheeler> joeyadams: somewhat tangential, but don't wrap the raguments in parentheses; it works, but it'll get you confused with more arguments
17:46:31 <Berengal> joeyadams: Except it doesn't fork, it just bombs
17:46:32 <jeffwheeler> * argument
17:46:39 <benmachine> yeah
17:46:40 <joeyadams> yeah
17:46:41 <SamB_XP> or like pre-32-bit RiscOS apps used to use the top few bits
17:46:51 <benmachine> I didn't really mean spawns
17:46:54 <SamB_XP> since they weren't yet used for addresses
17:46:58 <benmachine> I meant calls
17:47:04 <benmachine> calls two more calls
17:47:11 <Berengal> jeffwheeler: Always wrap your minuses!
17:47:15 <joeyadams> So someone needs to solve P=NP for that to be efficient :)
17:47:16 <benmachine> well, anyway, you know what I mean :OP
17:47:31 <benmachine> joeyadams: that algorithm is never going to be very efficient
17:47:36 <SamB_XP> wrap your arguments, by all means
17:47:46 <SamB_XP> but wrap each one in it's own parens
17:47:49 <jeffwheeler> Berengal: but when pattern matching, he'll try to use tuples by accident next :)
17:47:59 <pikhq> joeyadams: Here's a simple one for you: let fibs = 0:1:zipWith (+) fibs (tail fibs) -- ;)
17:48:17 <joeyadams> Why doesn't it keep track of the return values when it calculates them?  Wouldn't that be a huge optimization for Haskell in general?
17:48:32 <jeffwheeler> joeyadams: that's called memoization
17:48:32 <SamB_XP> joeyadams: it would take a lot of memory
17:48:40 <copumpkin> > fix ((0:) . scanl (+) 1)
17:48:41 <joeyadams> Yeah.
17:48:46 <SamB_XP> joeyadams: and involve looking at the entire argument, too
17:48:49 <SamB_XP> all at once
17:48:50 <Berengal> jeffwheeler: Could be worse, he could be confused by the horrible polymorphic - token. Is it negate? Is it subtract? Nobody knows!
17:48:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:49:13 <SamB_XP> joeyadams: not a good thing to do implicitly, especially not in a lazy language ;-)
17:49:48 <joeyadams> Just curious, is there a way to "turn on" memoization, or does that need to be done manually?
17:50:00 <SamB_XP> joeyadams: more-or-less manually
17:50:15 <ManateeLazyCat> How to use function `tryEC` and `catchEC` at http://hackage.haskell.org/packages/archive/HSH/2.0.2/doc/html/HSH-Command.html ?
17:50:17 <SamB_XP> there are some tools to supposedly simplify it, though
17:50:23 <SamB_XP> libraries, I mean
17:50:34 <Berengal> joeyadams: import Data.MemoTrie; fib = memo go where go n | n < 1 = 1 | otherwise = fib (n-1) + fib (n-2)
17:50:37 <copumpkin> nobody likes failgebra?
17:50:38 <jeffwheeler> joeyadams: it's possible via Template Haskell
17:51:00 <SamB_XP> jeffwheeler: that still counts as more-or-less manually
17:51:10 <jeffwheeler> SamB_XP: I suppose so
17:51:14 <pikhq> Berengal: That's a pretty silly thing to do. ;)
17:51:31 <Berengal> pikhq: For fib, yes...
17:51:38 <SamB_XP> jeffwheeler: there are some other tricks too, and I don't know if they are any less reliable than using TH
17:51:43 <pikhq> Well, yes.
17:55:55 <jeffwheeler> Hmm, bunches of permission denied errors.
17:56:21 <jeffwheeler> I suppose sudo doesn't work . . .
17:59:44 <joeyadams> <pikhq> joeyadams: Here's a simple one for you: let fibs = 0:1:zipWith (+) fibs (tail fibs) -- ;) --> Is there a way to subscript the array returned?  This obviously has infinite output :)
18:00:22 <joeyadams> Now I'd think if Haskell uses lazy evaluation, it would be fairly safe efficiency-wise to just chop the range of items I want out.
18:00:46 <jeffwheeler> > take 10 $ [1..100]
18:00:48 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:01:30 <pikhq> joeyadams: That is in fact a normal practice in Haskell.
18:01:35 <SamB_XP> joeyadams: note, however, that that "fibs" is what you call a CAF, and as such what you actually use will likely never be garbage collected
18:02:01 <jeffwheeler> SamB_XP: wait, why? CAF?
18:02:03 <SamB_XP> (CAF stands for Constant Applicative Form)
18:02:25 <joeyadams> you mean not Confederation of African Football? :)
18:02:39 <SamB_XP> joeyadams: in this case
18:03:02 <SamB_XP> does it look like a soccer federation to you?
18:04:28 * Berengal thinks soccer would be more interesting if it was more like the fibonacci numbers
18:04:45 <ManateeLazyCat> Which function is "(a, b) -> a" ? I forget it....
18:04:54 <idnar> ManateeLazyCat: fst
18:04:55 <Berengal> ManateeLazyCat: uncurry const?
18:04:55 <jeffwheeler> @hoogle (a, b) -> a
18:04:56 <lambdabot> Prelude fst :: (a, b) -> a
18:04:56 <lambdabot> Data.Tuple fst :: (a, b) -> a
18:04:56 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
18:05:08 <ManateeLazyCat> Oh, is fst
18:05:11 <ManateeLazyCat> Thanks
18:05:19 <joeyadams> Hehe, the reason I came here ultimately stemmed from me not wanting to do 5+8 in my head :D
18:05:20 <idnar> Confederation of African Fibonacciball?
18:05:42 <Berengal> > 5 + 8
18:05:44 <lambdabot>   13
18:05:45 <Berengal> :)
18:05:59 <copumpkin> uncurry const is cute
18:06:03 <joeyadams> > let 2+2 = 5
18:06:05 <lambdabot>   not an expression: `let 2+2 = 5'
18:06:20 <jeffwheeler> > let 2 + 2 = 5 in 2 + 2
18:06:21 <joeyadams> Umm, that's sort of common.  Bart Simpson said it.
18:06:22 <lambdabot>   5
18:06:50 <joeyadams> Not sure how that works :)
18:07:00 <idnar> it redefines (+)
18:07:08 <idnar> > let 2 + 2 = 5 in 2 + 3
18:07:10 <lambdabot>   * Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
18:07:24 <ManateeLazyCat> How to pick element from value that type is "(Either ExitCode a)"?
18:07:28 <joeyadams> let 2+x = 2-x in 2+2
18:07:32 <joeyadams> > let 2+x = 2-x in 2+2
18:07:34 <lambdabot>   0
18:08:01 <Berengal> > let zipWith _ [] ys = ys; zipWith _ xs [] = []; zipWith (+) (x:xs) (y:ys) = x + y:zipWith (+) xs ys in zipWith (*) [1..10] [2..11]
18:08:03 <lambdabot>   [2,6,12,20,30,42,56,72,90,110]
18:08:04 <joeyadams> So someone could redefine + at the beginning of their code and throw clarity out of the window just like that?
18:08:16 <pikhq> joeyadams: Sure.
18:08:20 <jeffwheeler> > let (+) = (*2) . (2-) in 2 + 3
18:08:22 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
18:08:22 <lambdabot>    arising from a use of `GHC.Num.-'...
18:08:28 <idnar> joeyadams: not exactly; namespaces and scope...
18:08:42 <jeffwheeler> > let (+) = (*) . (-) in 2 + 3
18:08:44 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
18:08:44 <lambdabot>    arising from a use of `GHC.Num.*'...
18:08:49 <jeffwheeler> > let (+) = (*2) . (-) in 2 + 3
18:08:50 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
18:08:50 <lambdabot>    arising from a use of `GHC.Num.*'...
18:08:53 <idnar> joeyadams: but yes, if you deliberately want to be obscure, you could do it
18:09:00 <idnar> that's always possible, though :P
18:09:13 <Berengal> > let (+) = (*) . (-2) in 2 + 3
18:09:13 <pikhq> > let (+) = (*) in 2 + 3
18:09:14 <lambdabot>   6
18:09:15 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
18:09:15 <lambdabot>    arising from the literal `2' at <...
18:09:22 * Berengal wins
18:09:36 <jeffwheeler> Err, huh?
18:09:59 <Berengal> No, wait, I didn't :(
18:10:10 <idnar> (-2) is negative two, not a (-) section :/
18:10:20 <joeyadams> let x*y = exp(log(x)+log(y)) in 12*12
18:10:26 <Vanadium> subtract 2 is the section you are looking for
18:10:27 <bgs100> > let (+) = (*) . (subtract 2) in 2 + 3
18:10:27 <Berengal> Stupid minus...
18:10:28 <lambdabot>   0
18:10:31 <joeyadams> > let x*y = exp(log(x)+log(y)) in 12*12 --maybe I'll stop forgetting the > one of these days
18:10:32 <lambdabot>   144.0
18:10:55 <idnar> um
18:11:20 <idnar> @type ((*) .)
18:11:21 <lambdabot> forall b a. (Num b) => (a -> b) -> a -> b -> b
18:12:46 * SamB_XP thinks his dog would enjoy working for canonical
18:15:00 <bakesz> another question:Is it possible and if yes,how can I make stack bigger?
18:18:04 <bakesz> please,can anybody help me?
18:18:44 <Zao> There's assorted switches you can pass to the RTS.
18:19:02 <Zao> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
18:19:23 <aavogt> A better option to address stack overflows, is to add some strictness
18:19:38 <aavogt> @quote laziness
18:19:38 <lambdabot> LarryWall says: We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris.
18:19:54 <aavogt> hmm
18:20:38 <aavogt> @src foldl'
18:20:38 <lambdabot> foldl' f a []     = a
18:20:38 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:21:07 <aavogt> bakesz: do you have the offending code?
18:21:14 <bnijk> does somebody have a simple haskell program that shows off most of the features of the language, for me to study
18:21:38 <pikhq> bnijk: ... Most of them?
18:21:47 <pikhq> There's too many.
18:22:06 <bnijk> key word "simple"
18:22:20 <bnijk> aka small
18:22:30 <pikhq> > fibs = 0:1:zipWith (+) fibs (tail fibs)
18:22:31 <lambdabot>   <no location info>: parse error on input `='
18:22:39 <pikhq> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
18:22:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:23:32 * aavogt thinks that copumpkin's earlier fibs with fix would be more impressive
18:23:43 <uman> SamB_XP: why's that?
18:24:14 <pikhq> aavogt: Yes, but I actually *remember* this one.
18:24:25 <pikhq> But fine.
18:24:36 <pikhq> > fix ((0:) . scanl (+) 1)
18:24:37 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:24:51 <bakesz> aavogt:here is my code:http://haskell.pastebin.com/d6152c388
18:25:04 <SamB_XP> uman: I think she would like their "eat your own dogfood" policies
18:25:14 <uman> oh, never heard of that
18:25:34 <aavogt> > length [0|x<-[1..1000000]]
18:25:36 <lambdabot>   1000000
18:29:47 <bakesz> aavogt:can you help me?
18:34:26 <leimy_> :t fix
18:34:27 <lambdabot> forall a. (a -> a) -> a
18:34:33 <leimy_> oh duh...
18:35:13 <aavogt> bakesz: compile with optimization?
18:36:12 <aavogt> the value of s is 153, and calculated pretty quickly here when I do that
18:36:49 <bnijk> ummmm
18:36:54 <copumpkin> it feels weird to me to have those fromPlus and toPlus methods in Semiring in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7015#a7015 can anyone suggest alternatives?
18:38:07 <FunctorSalad_> copumpkin: are you making an algebra lib?
18:39:03 <copumpkin> FunctorSalad_: playing with the idea, but mostly as a good use case and comparison for a context alias preprocessor I'm going to work with
18:39:08 <copumpkin> work on
18:39:42 <FunctorSalad_> why does the semiring have multiple params?
18:39:59 <copumpkin> ?
18:40:17 <copumpkin> I wasn't sure how else to represent the properties of the two operations
18:40:24 <bakesz> aavogt:it works with compile and "+RTS -K50" argument,and didnt work when tried in interactive mode.Thank you.
18:40:42 <FunctorSalad_> copumpkin: it seems it'd be way simpler to make two monoid classes
18:40:49 <FunctorSalad_> (one with additive notation, one with multiplicative)
18:41:12 <copumpkin> I thought of that but it felt kinda dirty
18:41:21 <copumpkin> for all the other non-ring structures
18:41:25 <copumpkin> I'd need two of everything
18:41:37 <copumpkin> not that this feels much cleaner
18:42:04 <FunctorSalad_> the code *using* it will be much dirtier with all the newtyping
18:42:10 <FunctorSalad_> IMHO
18:42:12 <copumpkin> but we already have something like this
18:42:13 <copumpkin> with Monoid
18:42:22 <FunctorSalad_> well yes, and it's bad ;)
18:42:33 <copumpkin> but there are loads of other kinds of Monoid instances
18:42:41 <copumpkin> do we need a new class for each of them?
18:42:43 <FunctorSalad_> symbols do matter, so I wouldn't consider it that wrong to make two monoids
18:43:19 <FunctorSalad_> do you mean other classes?
18:43:21 <bgs100> > let (+) = (1+) . (+) in 2 + 2
18:43:23 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> c
18:43:37 <copumpkin> @instances Monoid
18:43:38 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:43:42 <copumpkin> those ones
18:43:47 <copumpkin> the various "wrapper" monoid types
18:43:59 <aavogt> @src Ordering
18:44:00 <lambdabot> data Ordering = LT | EQ | GT
18:44:16 <aavogt> > LT `mplus` EQ
18:44:18 <lambdabot>   Couldn't match expected type `m a'
18:44:20 <copumpkin> Sum and Product are the ones we're talking about now, but it feels odd to create a class for each of them
18:44:24 <copumpkin> > LT `mappend` EQ
18:44:26 <lambdabot>   LT
18:44:42 <FunctorSalad_> copumpkin: I'd just make them an instance of multiplicative or additive, depending on the more common convention
18:44:49 <aavogt> > map (mappend LT) [LT .. ]
18:44:50 <copumpkin> hrm
18:44:51 <lambdabot>   [LT,LT,LT]
18:45:06 <FunctorSalad_> e.g. Endo should be multiplicative
18:45:12 <aavogt> > map (mappend EQ) [LT .. ]
18:45:13 <lambdabot>   [LT,EQ,GT]
18:45:19 <bnijk> haskell scares the shit out of me
18:45:23 <aavogt> > map (mappend GT) [LT .. ]
18:45:25 <lambdabot>   [GT,GT,GT]
18:45:26 <copumpkin> > join (liftA2 mappend) [LT, EQ, GT]
18:45:28 <lambdabot>   [LT,LT,LT,LT,EQ,GT,GT,GT,GT]
18:45:44 <FunctorSalad_> that's a very useful instance btw
18:45:54 <bgs100> > let x+y = x - (negate y) in 2 + 2
18:45:56 <lambdabot>   4
18:46:02 <FunctorSalad_> it is such that you get lexical ordering by msuming the letter comparisons.
18:46:08 <copumpkin> yup
18:46:28 <bgs100> > let x+y = x - (negate y) - -1 in 2 + 2
18:46:29 <lambdabot>   Precedence parsing error
18:46:30 <lambdabot>      cannot mix `GHC.Num.-' [infixl 6] and prefix ...
18:46:40 <SamB_XP> FunctorSalad_: that's kinda the point, yes ;-)
18:46:43 <bgs100> > let x+y = x - (negate y) - (-1) in 2 + 2
18:46:44 <lambdabot>   5
18:46:46 <jeffwheeler> > sort [LT, GT, EQ]
18:46:47 <lambdabot>   [LT,EQ,GT]
18:46:52 <FunctorSalad_> copumpkin: so I'd make the multiplicative monoid the default and use additive only in ring situations
18:47:08 <FunctorSalad_> (generic monoid mult is usually written \cdot or just juxtaposition)
18:47:21 <copumpkin> FunctorSalad_: hrm, it still feels odd to have two monoid classes with the same semantics, whose only difference is notation and behavior when used together
18:47:51 <bgs100> > let x+y = x - (-y) - (-1) in 2 + 2
18:47:52 <lambdabot>   5
18:47:54 <SamB_XP> copumpkin: it is odd
18:48:04 <aavogt> copumpkin: that way works too, but then I'm never sure which parameter varies first
18:48:12 <aavogt> > liftA2 (,) [1..3]
18:48:14 <SamB_XP> copumpkin: you should use Coq, where you could factor out the comon bit ;-)
18:48:14 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [(a, b)])
18:48:14 <lambdabot>    arising from a...
18:48:20 <zong_sharo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7018#a7018 <- i don't get it
18:48:21 <aavogt> > liftA2 (,) [1..3] [1..3[
18:48:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:48:23 <aavogt> > liftA2 (,) [1..3] [1..3]
18:48:25 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
18:48:25 <FunctorSalad_> it seems to be the same logic as newtypes, copumpkin
18:48:38 <FunctorSalad_> same thing but other name
18:48:52 <zong_sharo> how does "The concurrent computation is killed if the calling thread stops" guaranteed?
18:49:18 <SamB_XP> zong_sharo: it's probably not guarenteed
18:50:00 <SamB_XP> it's probably more of a "we'll kill it before it does too much useless computation, at least if you're using a cooperative implementation of Concurrent Haskell"
18:50:20 <zong_sharo> SamB_XP: huh?
18:50:43 <SamB_XP> zong_sharo: I bet it uses GHC's "deadlock killing" logic
18:50:54 <zong_sharo> wtf?
18:50:54 <SamB_XP> it kills threads that are clearly deadlocked
18:51:00 <SamB_XP> as determined by the garbage collector
18:51:05 <zong_sharo> aah
18:51:08 <copumpkin> FunctorSalad_: but then how do I express that addition distributes ofer multiplication?? :P fine, it's gratuituous
18:51:18 <copumpkin> gratuitous
18:51:27 <SamB_XP> not quite sure *how* it would use that
18:51:32 <SamB_XP> but that's my guess ;-)
18:51:34 <copumpkin> BUT
18:51:36 <FunctorSalad_> copumpkin: why is that a problem?
18:51:40 <zong_sharo> SamB_XP: okay
18:51:47 <zong_sharo> SamB_XP: thaks a lot
18:51:50 <FunctorSalad_> class (Add a , Mult a ) => Distributive ...
18:52:06 <copumpkin> the point wasn't the algebra library itself, but for me to give myself a huge set of typeclasses to simplify with context aliases
18:52:18 <copumpkin> FunctorSalad_: ah
18:52:23 <zong_sharo> how i can do something similiar in "clean" way?
18:52:48 <SamB_XP> zong_sharo: or I guess it could be using a thread that notices soon after the invoking thread dies ?
18:53:02 <FunctorSalad_> copumpkin: sounds like a worthwhile project :) beats using CPP ;)
18:53:08 <FunctorSalad_> (which I did sometimes)
18:53:11 <copumpkin> FunctorSalad_: ack :)
18:53:28 <zong_sharo> SamB_XP: how?
18:53:41 <copumpkin> FunctorSalad_: my goal is to make a preprocessor that implements most of what's in http://blog.omega-prime.co.uk/?p=61
18:53:46 <SamB_XP> zong_sharo: dunno! you could read the code if you want
18:53:56 <SamB_XP> but grab a barf bag, it might be ugly!
18:54:38 <bnijk> > map (++"Functor") salad
18:54:40 <lambdabot>   ["Salad_Functor","Salad_Functor","Salad_Functor","Salad_Functor","Salad_Fun...
18:54:45 <bnijk> ohhh yeah
18:54:50 <bnijk> > map ("Functor"++) salad
18:54:53 <lambdabot>   ["FunctorSalad_","FunctorSalad_","FunctorSalad_","FunctorSalad_","FunctorSa...
18:55:00 <aavogt> > salad
18:55:02 <lambdabot>   ["Salad_","Salad_","Salad_","Salad_","Salad_","Salad_","Salad_","Salad_","S...
18:55:21 <copumpkin> > scanl1 (++) salad
18:55:23 <lambdabot>   ["Salad_","Salad_Salad_","Salad_Salad_Salad_","Salad_Salad_Salad_Salad_","S...
18:55:25 <aavogt> > length salad
18:55:31 <lambdabot>   mueval-core: Prelude.read: no parse
18:55:31 <lambdabot>  mueval: ExitFailure 1
18:55:37 <bnijk> bwahaha
18:56:27 <bnijk> > map (reverse $ "Functor"++) salad
18:56:28 <lambdabot>   The operator `GHC.Base.++' [infixr 5] of a section
18:56:29 <lambdabot>      must have lower pre...
18:56:34 <bnijk> > map (reverse . "Functor"++) salad
18:56:35 <copumpkin> fail
18:56:35 <lambdabot>   Couldn't match expected type `a -> [a1]'
18:56:42 <aavogt> > fix fail
18:56:43 * bnijk is tired
18:56:44 <lambdabot>   ""
18:57:04 <aavogt> sections need parentheses, unfortunately
18:57:04 <copumpkin> > fix tail
18:57:10 <lambdabot>   mueval-core: Prelude.read: no parse
18:57:10 <lambdabot>  mueval: ExitFailure 1
18:57:17 <bnijk> > map (reverse ("Functor"++)) salad
18:57:18 <lambdabot>   Couldn't match expected type `[a]'
18:57:24 <bnijk> oh ho ho
18:57:54 <FunctorSalad_> copumpkin: sounds like something that should be in ghc (but I wouldn't know how to do that)
18:58:12 <monochrom> tail _|_ = _|_ so fix tail = _|_
18:58:21 <copumpkin> FunctorSalad_: yeah, it does, but starting with a preprocessor is easier than messing around inside GHC for now :)
18:58:34 <FunctorSalad_> definitely
19:03:17 <mmorrow> haha, uncurry const
19:03:22 <mmorrow> never though of that one
19:03:46 <jeffwheeler> Why is the default to use --global for cabal-install on Windows?
19:04:06 <Berengal> mmorrow: Do you read through the entire log for when you aren't here?
19:04:15 <bd_> :t uncurry const
19:04:17 <lambdabot> forall a b. (a, b) -> a
19:04:27 <mmorrow> Berengal: my xchat has like a 1000+ lines history
19:04:44 <mmorrow> and earlier sessions are in all black
19:05:12 <SamB_XP> mmorrow: hmm, that must be hard to read
19:05:15 <Berengal> When I sit down I contend myself with the last 30 or so
19:05:27 * SamB_XP 's xchat's have a black background ;-)
19:05:42 * mmorrow gives SamB_XP a flashlight
19:06:16 <SamB_XP> well, my previous session history on the Linux one (this one is too old to have that feature) is all in gray
19:08:37 <FunctorSalad_> mine has 100000 lines :P
19:08:59 <FunctorSalad_> but no persistance
19:09:03 <Berengal> Mine saves everything
19:09:12 <Berengal> But crashes every few days...
19:10:11 <Berengal> Hmmm, http://www.coboloncogs.org/INDEX.HTM
19:10:12 <mmorrow> just checked my preferences.. i've got 5000 lines
19:17:21 <jimmyjazz14> is there a reason one cannot do IO inside a state monad?
19:17:33 <pikhq> Because that's not the IO monad.
19:17:35 <Berengal> jimmyjazz14: Yes, you can only do IO inside the IO monad
19:18:19 <jimmyjazz14> hmm right
19:18:49 <jimmyjazz14> so what would be the solution if I need to update my state with something from IO?
19:20:00 <Berengal> Use IO
19:20:17 <Berengal> Or StateT
19:20:31 <pikhq> StateT IO would do it, I think.
19:21:19 <canvon> jimmyjazz14: replace "State s a" with "StateT s IO a", and use lift with the IO functions
19:21:30 <Berengal> You might not need IO though
19:28:10 <jimmyjazz14> canvon Berengal thanks that worked! what did I just do?
19:28:23 <Berengal> jimmyjazz14: Monad magic!
19:28:27 <Berengal> aka monad transformers
19:28:34 <Berengal> @where transformers
19:28:35 <lambdabot> I know nothing about transformers.
19:28:37 <Berengal> :(
19:28:46 <Berengal> It's on the wiki anyway...
19:28:51 * Berengal is lazy
19:29:40 <jimmyjazz14> ah yeah I remember reading a little about tranformers somewhere else; I should probably read up a little more on them.
19:36:28 <jimmyjazz14> I need to write a function that basically maintains a global state, its a function that read a config file from the disk and parses it and only reloads the config file from disk when the config modification time has changed
19:36:50 <jimmyjazz14> I was thinking something like a continuation might be what I am looking for
19:37:19 <Berengal> A config is usually kept in a Reader monad
19:37:35 <Berengal> And reloading it is usually a signal
19:38:12 <jimmyjazz14> Berengal: okay I don't know the reader monad yet I will look into it
19:38:33 <Berengal> jimmyjazz14: It's the same as the function monad, except with a newtype
19:38:33 <canvon> jimmyjazz14: (for understanding how the transformation worked, maybe compare the instances for Monad (State s) and Monad (StateT s m), and have a look at MonadTrans (StateT s). http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html )
19:39:02 <Raynes> jimmyjazz14: Picture the state monad, without being able to modify the state. Meet Reader.
20:07:52 <Javagod> anyone here
20:08:25 <QPlaty[HireMe]> Javagod: What is your question?
20:08:49 <Javagod> oh i got something like mapM print [1..10]
20:09:02 <Javagod> the last line of the output is screwed up
20:09:37 <Petrosian> Javagod: Is it something like [(), () ... ()] ?
20:09:39 <QPlaty[HireMe]> Javagod: What are you expecting?
20:09:52 <Petrosian> Or rather IO ()
20:10:15 <Javagod> yea i'm expecting 1 to 10 printed each on a new line right?
20:10:23 <aavogt> it does that
20:10:26 <aavogt> no?
20:10:33 <Javagod> but the last line is screwed up
20:10:42 <QPlaty[HireMe]> Javagod: What is the last line?
20:10:55 <Javagod> hmm works fine in hugs but not ghci
20:11:04 <Petrosian> Javagod: What is the last line?
20:12:11 <Javagod> it's [(),(),()...]
20:12:15 <aavogt> use mapM_
20:12:21 <Javagod> why what's wrong
20:12:34 <QPlaty[HireMe]> Javagod: Thats the return value of the mapM function.
20:12:40 <Petrosian> @ty mapM print [1..10]
20:12:42 <lambdabot> IO [()]
20:12:50 <dobblego> Javagod, mapM is returning you a list of actions -- not executing them
20:13:08 <dobblego> Javagod, similar to returning a List<Runnable>
20:13:09 <Javagod> oh how would i execute them then
20:13:15 <dobblego> Javagod, use mapM_
20:13:21 <Javagod> oh ok
20:13:23 <klugez> Javagod: Each of those prints returns a () and mapM returns a list of the applications. GHCI then prints the return value of the action after executing them.
20:14:30 <Javagod> oh why's it working differently on hugs and ghci?
20:14:42 <dobblego> it shouldn't
20:14:56 <QPlaty[HireMe]> @ty mapM_
20:14:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:15:12 <dobblego> mapM_ print [1..10]
20:15:13 <Petrosian> Hugs might not print the return value of an IO... or something
20:15:17 <Petrosian> Just don't use hugs!
20:15:31 <Javagod> on hugs the last line is just blank
20:15:40 <Javagod> on ghci it's [(),(),()..]
20:16:23 <canvon> Javagod: with another " >>= print" at the end, hugs should print that last line, too
20:16:44 <Javagod> i'm confused now
20:17:12 <Javagod> yea it does
20:17:27 <rstutsman> has anyone encountered treeStoreNew [] causing a segfault in gtk2hs 0.10.1?
20:17:33 <canvon> ghci is just trying to be friendly. it is showing you what was contained as the result of the final combined action
20:17:48 <Javagod> ah ok
20:17:55 <canvon> (it skips that, though, if that's just IO ())
20:18:55 <canvon> Javagod: instead of using mapM_ instead of mapM (the clean solution), you could put " >> return ()" at the end of the statement in ghci, just to see my point
20:19:18 <aavogt> x <- mapM print [1..10] -- doesn't print the bound variable
20:19:35 <Javagod> interesting naming conventions here
20:19:47 <Javagod> foldl, foldl1, foldl'
20:20:37 <aavogt> @type \f -> foldl f `ap` head
20:20:39 <lambdabot> forall b. ([[b]] -> b -> [[b]]) -> [[b]] -> [[b]]
20:21:02 <hzap> the map, mapM, mapM_ stuff felt really weird when I started
20:21:11 <aavogt> @type \f -> flip (foldl f) `ap` head
20:21:12 <lambdabot> forall b. (b -> b -> b) -> [b] -> b
20:21:32 <Javagod> yea is there no function overloading?
20:21:44 <Javagod> so maybe map and mapM can have the same name
20:22:05 <mike-burns> :t map
20:22:06 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:22:07 <mike-burns> :t mapM
20:22:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:22:15 <aavogt> @type map print [1..10]
20:22:17 <lambdabot> [IO ()]
20:22:20 <hzap> it can't figure out whether you want to "map print [1..10]" or "mapM print [1..10]" though
20:22:39 <Javagod> ;t mapM_
20:22:42 <Javagod> :t mapM_
20:22:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:23:03 <aavogt> surely such overloading is possible with the apropriate multi parameter type classes, and overlapping instances?
20:24:55 <SamB_XP> it *might* be possible to get it to dispatch on the return type, yes ...
20:25:02 <canvon> aavogt: what is "x <- mapM ..." outside do notation? as expected, it gives an error with do ("The last statement in a 'do' construct must be an expression"), but it just works without do
20:25:03 <SamB_XP> @type mapM
20:25:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:25:15 <SamB_XP> @type fmap
20:25:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:25:17 <QPlaty[HireMe]> SamB_XP: It is possable
20:25:20 <Javagod> but.. i can't have sum :: Integer -> Integer _and_ have sum :: Integer -> Integer -> Integer
20:25:22 <aavogt> canvon: do notation is allowed in ghci
20:25:31 <aavogt> without having to type any 'do'
20:25:49 <QPlaty[HireMe]> Javagod: That wouldn't be allowed.
20:25:59 <SamB_XP> QPlaty[HireMe]: I'm not quite sure how you'd do it here
20:26:00 <canvon> aavogt: i mean, "do x <- monadic" gives said error, "x <- monadic" executes the monadic action
20:26:17 <SamB_XP> but it would have something to do with noticing the extra "m" in the return type for mapM
20:26:21 <mjrosenb> Javagod: that's why you have sum :: [Integer] -> Integer
20:26:23 <mike-burns> canvon: ghci is inside an implicit do block.
20:26:27 <aavogt> canvon: yeah, I suggested the latter
20:26:39 <aavogt> or that is what I meant, at least
20:27:01 <aavogt> > sum []
20:27:02 <lambdabot>   0
20:27:42 <Javagod> how would i search for mapM_
20:27:47 <Javagod> google ignores the _
20:27:54 <mmorrow> @hoogle mapM_
20:27:54 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
20:27:54 <hzap> @hoogle mapM_
20:27:54 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
20:27:54 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
20:27:55 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
20:27:55 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
20:27:56 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
20:28:02 <Javagod> hoogle?
20:28:06 <hzap> yep
20:28:19 <mmorrow> Javagod: you want Control.Monad
20:28:33 <mike-burns> Javagod: http://haskell.org/hoogle/?hoogle=mapM_
20:28:36 <canvon> aavogt: it needs "_ <- ...", though, or it will print the [(), (), ...] too
20:28:53 <dobblego> Javagod, also, "mapM_" in double-quotes works for google
20:29:04 <Javagod> oh didn't know that
20:29:05 <mmorrow> i have this in my $HOME/.ghci
20:29:07 <canvon> i'm not exactly sure what expression ghci is evaluating / showing to me, then ;)
20:29:09 <Javagod> wait google doesn't ignore _
20:29:11 <mmorrow>  :set -fno-print-bind-result
20:29:16 <mmorrow> among other things
20:29:21 <Javagod> but it ignores just about all other punctuation
20:29:35 <aavogt> canvon: I don't need to do that, I think I have that flag that mmorrow mentioned though
20:31:03 <Javagod> where can i find the official documentaion for mapM and mapM_ and etc?
20:31:17 <mike-burns> Javagod: http://haskell.org/hoogle/?hoogle=mapM_
20:31:20 <mmorrow> http://www.haskell.org/ghc/dist/current/docs/libraries/
20:31:23 <Javagod> "mapM_ f is equivalent to sequence_ . map f." not much
20:31:23 <Zao> They should be defined in the report.
20:31:24 <mmorrow> is the official docs
20:31:33 <canvon> mmorrow: yes, that omits the last line, too
20:31:43 <canvon> (didn't know about it)
20:31:43 <Zao> http://www.haskell.org/onlinereport/
20:32:12 <mmorrow> Javagod: you can get to the official docs from the "Standard Libraries" link of http://haskell.org/
20:32:15 <mmorrow> s/of/on/
20:32:29 <Javagod> ok
20:32:48 <mmorrow> (admittedly it's somewhat hidden (imo))
20:32:57 <zachk> how would i coerce a Integer + Floating in ghci
20:33:15 <mmorrow> , fromIntegral (99::Int) + pi :: Double
20:33:18 <lunabot>  102.1415926535898
20:33:57 <mmorrow> if you have to use fromIntegral a lot, i usually make a local def "fi = fromIntegral" because it starts to get annoying fast writing that whole thing out
20:34:14 <mmorrow> you'd want to do:
20:34:19 <mmorrow> fi a = fromIntegral a
20:34:36 <mmorrow> though in ghci or else the monomorphism restriction will make it not polymorphic
20:34:53 <SamB_XP> I always call it fI
20:35:13 <mmorrow> SamB_XP: yuk
20:35:16 <mmorrow> :)
20:36:39 <SamB_XP> and you can always give it a type signature to kill the MR
20:36:41 <canvon> 05:26:23 < mike-burns> canvon: ghci is inside an implicit do block. <- i heard this before, but now i finally understand what is meant. so you can "foo <-" an IO value in ghci, and just play with it around as a pure value? great! :]
20:37:03 <mmorrow> heh, i remember when i first realized that
20:37:14 <mmorrow> i was like holy wtfomg!
20:37:19 <canvon> :D
20:37:26 * mjrosenb too
20:37:27 <Javagod> huh then can you have a function that takes IO String and gives you a String?
20:37:31 <SamB_XP> it also adds magic prints
20:37:37 <mjrosenb> Javagod: yes
20:37:42 <mjrosenb> Javagod: but not the way you want it to
20:37:52 <Javagod> oh?
20:38:28 <mjrosenb> Javagod: ioToNormal :: IO String -> String; ioToNormal x = "this is a string"
20:38:49 <mjrosenb> Javagod: you are probably looking for unsafePerformIO which i do not endorse
20:38:57 <Javagod> not really what i meant but..
20:39:09 <SamB_XP> yeah
20:39:13 <SamB_XP> you use it like this:
20:39:27 <SamB_XP> > unsafePerformIO launchMissles
20:39:28 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `launchMissles'
20:39:42 <SamB_XP> fortunately those functions aren't in scope here ;-)
20:39:49 <Javagod> > unsafePerformIO $ print "Hi"
20:39:51 <lambdabot>   Not in scope: `unsafePerformIO'
20:40:00 <dobblego> Javagod, a value of type IO String cannot be converted to String -- this is an essential part of a pure functional language
20:40:00 <mjrosenb> :t unsafePerformIO
20:40:02 <lambdabot> Not in scope: `unsafePerformIO'
20:40:08 <mjrosenb> Javagod: print does not return  a string
20:40:40 <mjrosenb> i should *really* be able to get the type of unsafePerformIO
20:40:47 <dobblego> Javagod, Erik Meijer once gave a conference talk where he said "currentTimeMillis() says it returns long -- this is a LIE"
20:41:06 <Javagod> huh?
20:41:13 <canvon> Javagod: normally a value cannot be pulled "outside" a monad, except (so to speak) temporarily for building another monadic value in the same monad, or by using a primitive that is specific to the monad at hand. with Maybe, that would be maybe, and with IO, it would be unsafePerformIO; but using the latter unwisely would break the very use of the IO monad: to sequence actions linearly, and ensure they are executed only once.
20:41:24 <canvon> (ups that line length got out of hand)
20:41:34 <SamB_XP> mjrosenb: there's a good reason for it not being in scope, you know
20:41:46 <Javagod> > import System.IO.Unsafe
20:41:48 <lambdabot>   <no location info>: parse error on input `import'
20:41:52 <SamB_XP> > unsafePerformIO $ readFile "/etc/passwd"
20:41:53 <lambdabot>   Not in scope: `unsafePerformIO'
20:42:02 <mjrosenb> SamB_XP: yes, but for purposes of :t, everything should be in scope
20:42:04 <dobblego> Javagod, I strongly implore you to ignore these unsafe* suggestions
20:42:17 <Javagod> what's wrong?
20:42:20 * SamB_XP actually managed to get a lambdabot to run that action once -- though someone else found the hole ;-)
20:42:28 <dobblego> Javagod, unsafe* is for advanced users
20:42:36 <SamB_XP> dobblego: to be fair, it wasn't a suggestion on my part
20:42:42 <holmak_> Does it even have legitimate uses?
20:42:44 <SamB_XP> I was attempting to point out the dangers
20:42:49 <SamB_XP> holmak_: of course
20:42:55 <Javagod> oh what's unsafe about unsafe?
20:42:58 <SamB_XP> holmak_: but they're fewish
20:43:00 <dobblego> SamB, sure, I don't think Javagod is ready to appreciate these dangers :)
20:43:03 <mike-burns> If I use unsafe* do I get to consider myself an advanced user?
20:43:06 <Javagod> idk
20:43:07 <SamB_XP> Javagod: everyingthing!
20:43:18 <SamB_XP> mike-burns: only if you don't get another burn
20:43:25 <Javagod> but.. it seems useful
20:43:28 <hzap> :t System.IO.Unsafe.unsafePerformIO
20:43:30 <lambdabot> forall a. IO a -> a
20:43:43 <dobblego> Javagod, please believe us -- you want to avoid it for now and for a very long time
20:43:46 <canvon> holmak_: one example of a legitimate use of unsafePerformIO is in Control.Exception.evaluate (or whereever evaluate is)
20:43:47 <holmak_> That is the signature of Madness
20:43:50 <Javagod> ok ok
20:44:03 <dobblego> (it should have never been mentioned -- sorry)
20:44:21 <mjrosenb> dobblego: i told him to not use it
20:44:24 <SamB_XP> Javagod: may I suggest instead writing x <- readFile "/etc/passwd"
20:44:28 <holmak_> I've noticed that folks on this channel love bringing up unsafe
20:44:33 <SamB_XP> mjrosenb: don't tell them the name either ;-)
20:44:46 <mike-burns> Javagod: The reason that unsafePerformIO is considered unsafe is because it breaks the type system. It's similar in spirit to having a proof where you divide by zero in the middle, and get away with it.
20:44:51 <mjrosenb> SamB_XP: my first suggestion was safe
20:44:55 <holmak_> Usually at the end of a discussion: "That's not possible...buuuut there's always unsafe* !"
20:45:03 <SamB_XP> holmak_: I try to avoid mentioning it's name when speaking to those who are still foolhardy enough to use it
20:45:12 <mmorrow> , id .==. id
20:45:15 <lunabot>  True
20:45:16 <holmak_> Haha, highly understandable
20:45:18 <canvon> holmak_: evaluate? i meant mapException
20:45:28 <Javagod> so then i can't randomly insert print statements everywhere to debug like you do in java?
20:45:29 <mjrosenb> mmorrow: what now?
20:45:32 <holmak_> @hoogle mapException
20:45:32 <lambdabot> Control.Exception mapException :: (Exception -> Exception) -> a -> a
20:45:34 <canvon> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Exception-Base.html#mapException
20:45:39 <dobblego> Javagod, you can take a value IO String and pass it a function (String -> something) and get back IO something
20:45:39 <SamB_XP> Javagod: oh, that's a valid usecase
20:45:44 <mmorrow> mjrosenb: just reallyUnsafePtrEquality# :)
20:45:49 <SamB_XP> Javagod: which is why we have it done for you already in Debug.Trace
20:46:10 <canvon> the comment says, "Notice that the usage of 'unsafePerformIO' is safe here." :')
20:46:10 <Berengal> unsafePerformIO is a hole into the compiler. Unless you feel comfortable hacking GHC you want to think twice or thrice about using it
20:46:28 <Javagod> ok i'll take a look
20:46:38 <mike-burns> Javagod: Maybe you want Debug.Trace for that.
20:46:44 * mjrosenb feels dirty when he uses Debug.Trace.
20:46:46 <SamB_XP> mike-burns: I just said that ;-)
20:46:49 <mike-burns> Oh someone already said that.
20:46:51 <mike-burns> Ha.
20:47:10 <Javagod> :t Debug.Trace.trace
20:47:12 <lambdabot> forall a. String -> a -> a
20:47:12 <holmak_> canvon: Ha, that is an excellent comment.
20:47:22 <holmak_> I will stay clear of unsafe*, myself.
20:47:34 * Berengal recently tried trace for the first time. It was far less helpful than the other debugging techniques
20:47:53 <Javagod> hmm seems awkward to use it
20:47:57 <mmorrow> , let x = id (); y = id () in x `seq` let z = x .==. y in z `seq` y `seq` (z, x .==. y)
20:47:59 <lunabot>  (False,True)
20:48:06 <SamB_XP> Javagod: it's tricky, yeah
20:48:09 <holmak_> Also, pure functions make debugging quite a bit easier...
20:48:28 <SamB_XP> but it's easier than using unsafePerformIO
20:48:59 <Javagod> then how do you normally debug haskell
20:49:08 <SamB_XP> you just do "trace "Hi!" (expression)"
20:49:12 <Berengal> The best debugging techniques I've found is messing around in ghci and simply staring at the code
20:49:21 <hzap> lol
20:49:23 <Javagod> seriously
20:49:30 <mike-burns> Seriously.
20:49:31 <SamB_XP> which prints "Hi" when it's value is demanded, then returns (expression)
20:49:46 <zachk> how do i do regular type signatures in ghci
20:49:53 <SamB_XP> Javagod: call functions in GHCi, see what they return
20:49:55 * mjrosenb usually writes vtrace x = trace x x
20:50:27 <Javagod> is there any way to step through code or anything?
20:50:28 <mjrosenb> Javagod: yeah, the command line is awesome, and since there's no globally modifiable state, it's really easy to test small snippets of code
20:50:29 <SamB_XP> Javagod: but in complicated programs (e.g. compilers) you'll likely encounter times when you want to trace
20:50:33 <hzap> although I have to say the "staring at the code" method sometimes works
20:50:49 <SamB_XP> Javagod: there is, but it's a bad fit
20:50:57 * mjrosenb watches ghc bootstrap itself
20:51:06 <mike-burns> If your functions are small, ghci is almost always exactly what you need.
20:51:11 <SamB_XP> Javagod: Haskell code walks REALLY oddly
20:51:16 <mmorrow> , let x = id (); !xt = closureType x; xt2 = closureType x; xt3 = closureType y in xt `seq` x `seq` xt2 `seq` (xt, xt2, xt3)
20:51:19 <lunabot>  (AP,Constr,Thunk 22)
20:51:31 <Berengal> Because of referential transparancy, you can often narrow the location of the bug to a few lines of code. At that point, staring at it long enough often produce results
20:51:39 <hzap> there's some debugging stuff in ghci
20:51:52 <Javagod> i mean you can't just test it piece by piece if A relies on B which relies on C which relies on A etc..
20:52:19 <Javagod> you have to step through it or something
20:52:28 <pstickne> Javagod:  unit tests are a really nice way to start...
20:52:28 <mmorrow> Javagod: there's no stack trace to speak of, so that changes things a bit
20:52:33 <SamB_XP> Javagod: yeah, if the problem only shows up deep in a recursion trace is often quite handy
20:52:38 <mike-burns> Javagod: Your functions are too large if it gets to that point.
20:52:40 <Berengal> Stepping through execution with a debugger is really a rather primitive way of debugging
20:52:46 <hzap> usually I use the tracer to find out what code is throwing "head []" exceptions, but usually not other code
20:52:53 <SamB_XP> mike-burns: he just mentioned a 3-step recursion
20:52:57 <SamB_XP> mike-burns: that happens a lot
20:53:08 <mike-burns> Fair enough.
20:53:21 <zachk> > let sqrtt n=((fromIntegral.round.sqrt) n)::Integer in sqrtt 37
20:53:23 <lambdabot>   6
20:54:10 <Javagod> seems really primative if all you can do is stare at the code
20:54:49 <SamB_XP> I often end up putting traces around a function body saying what function got called and with what arguments
20:55:05 <hzap> you could try using :trace and stuff in ghci, not guaranteed to be helpful though
20:55:22 <mjrosenb> Javagod: the number of places that it actually comes to that and it doesn't work well are few and far between
20:55:41 <Berengal> Javagod: I just fixed a bug that way. A parser didn't work, so I used ghci to narrow down exactly which sub-parser was responsible, then stared at it for 3 minutes
20:55:42 <SamB_XP> there's also quickCheck
20:55:52 <canvon> Javagod: most of the time, using your functions interactively in ghci (or reading the type error messages carefully if it won't even compile) will be a fun and efficient debugging method
20:56:04 <Javagod> oh that's interesting
20:56:24 <SamB_XP> Javagod: yeah, if you can, just use them in GHCi and try to figure out what arguments they break for
20:56:32 <Berengal> It was a recursive parser too, so most sub-parsers called the main parser at the bottom
20:56:45 <mike-burns> Or write Quickcheck or HUnit tests (as others have mentioned).
20:57:07 <SamB_XP> that tends to be a bit impractical if the problem is cropping up deep in the guts of a compiler, though
20:57:21 <canvon> Javagod: it's often useful to have a ghci permanently running, with your main source file (that imports/uses all the other source files) loaded. then you change something in the editor, and reload everything in ghci by just using ":r". then you read the compilation error message carefully, or simply test your changes interactively :)
20:57:26 <mmorrow> Javagod: the thing is that the gdb-like debugging way of doing things doesn't make any sense anymore applied to the way haskell code's evaluated, and no one has really come up with a "ooh, that's definitely how debugging this stuff should be done"
20:57:33 <SamB_XP> hard to build all the data you need ;-)
20:57:42 <Javagod> so what do you do when your function 'just doesn't work'
20:57:44 <Berengal> SamB_XP: Presumably compilers too have unittests
20:57:45 <Javagod> happens to me a lot
20:58:17 <mmorrow> Javagod: if the types don't save you, and it's sufficiently hidden, put you staring goggles on :)
20:58:27 <Javagod> >.<
20:58:29 <SamB_XP> Berengal: that can be hard for the same reason
20:58:43 <Javagod> lol
20:58:54 <aavogt> canvon: sounds like flymake
20:58:54 <canvon> Javagod: call it interactively, with some simple arguments
20:59:01 <canvon> aavogt: flymake?
20:59:26 <pstickne> unfortunately this kind of debugging works better on pure code :)
20:59:27 <Berengal> Javagod: Seriously, if your function 'just doesn't work' no amount of debugging tools can help you, because it's your logic that's wrong, not your implementation
20:59:32 <mmorrow> Javagod: but any bug like that would be a logic bug, which is just as hard (or harder) to find in say C
20:59:33 <SamB_XP> canvon: some emacs minor mode that runs make in the background and parses the error messages
20:59:34 <canvon> aavogt: oic..</google> i have to admit that i adhere to the church of VIM. :)
20:59:54 <canvon> (and GNU screen)
20:59:56 <aavogt> canvon: I'm in the same predicament
21:00:08 <SamB_XP> canvon: I don't see what screen has to do with it!
21:00:14 <SamB_XP> screen is nice
21:00:16 <mike-burns> Vim has :make that words decently with haskell.vim, last I looked.
21:00:21 <mike-burns> works
21:00:32 <canvon> SamB_XP: have VIM in one screen window, ghci in another. then just use ^A^A to switch between both, without need for mouse or an IDE
21:00:48 <aavogt> mike-burns: can it be done in the background?
21:00:57 * SamB_XP doesn't usually run ghci under emacs anyway
21:01:08 <mike-burns> aavogt: I don't think so.
21:01:53 * mjrosenb has two terminals open, one with emacs one with ghci
21:03:13 <Javagod> maybe you should try kate because it has a built in terminal
21:03:28 <SamB_XP> Javagod: so does emacs. what's your point?
21:03:49 <Javagod> i just find it easier to work with than emacs
21:03:49 <SamB_XP> actually, emacs has several ways to do that ;-)
21:04:16 <Berengal> Kate doesn't have haskell-mode
21:04:25 <SamB_XP> Javagod: I was just pointing out that that wasn't a particularly good reason to switch to kate from emacs ;-)
21:04:36 <SamB_XP> Berengal: hmm -- that's a problem?
21:04:40 <Javagod> well i don't use emacs so that's ok
21:04:55 <Berengal> SamB_XP: I like automatic type-inference...
21:05:15 <Berengal> (That's why I wrote it for Yi)
21:05:18 <Javagod> Berengal: what do you mean by haskell mode
21:05:26 * SamB_XP goes to bed
21:05:29 <Berengal> Javagod: The emacs mode
21:05:41 <Berengal> Major mode for editing haskell files
21:05:42 <Javagod> Berengal: haskell syntax highlighting?
21:06:02 <Berengal> Not just syntax, indenting, ghci-integration and stuf
21:06:20 <aavogt> inserting type signatures
21:06:33 <Berengal> Perhaps most importantly, yes
21:06:34 <Javagod> oh didn't know emacs supported that kind of stuff
21:07:02 <Berengal> Emacs is a freaking lisp interpreter with a built-in text-editor
21:07:08 <aavogt> @hoogle RWS
21:07:09 <lambdabot> module Control.Monad.RWS
21:07:09 <lambdabot> Control.Monad.RWS.Lazy newtype RWS r w s a
21:07:09 <lambdabot> Control.Monad.RWS.Lazy RWS :: r -> s -> (a, s, w) -> RWS r w s a
21:07:29 <aavogt> is that just Writer + State + Reader wrapped into one?
21:08:40 * mmorrow gets serious and goes to 3x3 2d tiled workspaces
21:09:44 <pikhq> Javagod: Emacs supports a *lot*.
21:09:55 <pikhq> It's a Lisp operating system with a decent text editor, you see.
21:09:55 <Berengal> How old is emacs anyway?
21:09:56 <pikhq> ;)
21:10:07 <Javagod> it's.. what?
21:10:10 <pikhq> Berengal: GNU Emacs, or Emacs in general?
21:10:11 <Berengal> I'm guessing it's the oldest IDE out there
21:10:24 <Berengal> pikhq: Emacs in general
21:10:49 <mmorrow> i heard emax was coded in dos with nothing but DEBUG
21:10:54 <pikhq> GNU Emacs is 25-some years old, Emacs in general is ... Hmm. When was TECO Emacs written, anyways? Sometime in the 70s.
21:11:07 <pikhq> mmorrow: It's older than DOS.
21:11:15 <mmorrow> ;)
21:11:30 <mjrosenb> pikhq: something like that
21:11:46 <Javagod> and.. you _still_ use it
21:11:49 <Berengal> So about 30-40 years...
21:12:05 <pikhq> 1976.
21:12:12 <pikhq> It's been 33 years.
21:12:23 <Berengal> Javagod: With more than 30 years development time behind it, it's starting to become a rather well-developed platform
21:12:40 <Javagod> must be really good then if people still use it after 30 years
21:12:54 <pikhq> It was written by RMS and Guy L. Steele.
21:13:07 <Berengal> It's changed over the years. 30 years ago it didn't have a web browser or irc client, for example
21:13:11 <pikhq> And it's really good at what it does.
21:13:19 <pikhq> Berengal: Or a Lisp interpreter.
21:13:36 <mike-burns> Smalltalk-76 was the first to have an IDE, according to Wikipedia. That's a tie; I can't think of an older IDE.
21:13:39 <Berengal> pikhq: Which is solve hanoi puzzles, one move a second
21:13:39 <Javagod> i dunno, never bothered to learn it
21:13:54 <Javagod> is it worth learning emacs for its haskell mode and stuff?
21:14:01 <Berengal> mike-burns: Is that IDE still alive?
21:14:03 <pikhq> Javagod: More than just that.
21:14:13 <pikhq> Berengal: Yes.
21:14:27 <pikhq> Smalltalk sees quite a bit of use still.
21:14:31 <mike-burns> Berengal: I don't know that the original ST-76 IDE is still alive, but the original Emacs probably isn't either.
21:14:33 <Berengal> Javagod: It's not hard to learn emacs, just somewhat unusual. Took me about 2 hours getting used to the new keybindings and stuff
21:14:49 <Berengal> But since then I've never looked back, and feel like a fish on land when working in CUA editors
21:15:04 <mjrosenb> Berengal: CUA?
21:15:06 <jao> pikhq: you mean James Gosling, not G L Steele, don't you? :)
21:15:09 <mike-burns> Javagod: As a vim user I have to plug vim here as the equally-powerful (in practical ways) editor that's slightly less old.
21:15:27 <Berengal> mike-burns: Depends on what you mean by original, but that's impossible to define anyway
21:15:38 <mike-burns> Right.
21:15:40 <aavogt> its haskell mode is less impressive
21:15:46 <Javagod> yea i use vim now and then.. but it's like a really difficult to use version of notepad
21:15:47 <pragma_> intuitive > original
21:16:04 <Javagod> i'm probably doing something wrong
21:16:05 <mike-burns> Javagod: I disagree.
21:16:16 <inimino> Javagod: there's a learning curve, is all
21:16:43 <Javagod> yea
21:16:50 <Berengal> mjrosenb: http://en.wikipedia.org/wiki/Common_User_Access
21:16:53 <inimino> Javagod: unlike notepad, there's actually something to learn, but once you do it's quite a productive environment
21:17:35 <pikhq> jao: No. Guy L. Steele and RMS cowrote TECO Emacs.
21:17:53 <mike-burns> With both vim and emacs a lot depends on your configuration. An unconfigured vim/emacs is just difficult to use.
21:18:10 <pikhq> mike-burns: I disagree.
21:18:23 <pikhq> My .emacs is two lines. :P
21:18:23 <mike-burns> pikhq: On which editor?
21:18:26 <mike-burns> Huh.
21:18:30 <Javagod> well i think the default gvim color scheme is difficult to read
21:18:33 * araujo finds emacs very simple to use with default settings
21:18:42 <pikhq> (normal-erase-is-backspace-mode 0)
21:18:42 <pikhq> (menu-bar-mode 0)
21:18:48 <Berengal> I too use mostly default settings...
21:19:15 <mike-burns> Javagod: :h colorscheme
21:19:42 <pikhq> Javagod: Emacs has a lot of stuff in it. The user manual is a couple hundred pages.
21:19:49 <jao> pikhq: oops, yes, you're right. sorry!
21:19:50 * pikhq tries to remember where he left that last
21:19:52 <araujo> I use vim for editing config files, and emacs for programming .. I just got used to this :P
21:20:24 * Berengal likes watching newbies try to learn emacs. It's so fun to watch them fumble for the arrow keys
21:20:34 <Javagod> don't really like spending time learning a text editor when notepad++ or kate is fine and haskell is more interesting
21:21:02 <pikhq> Javagod: It's worth it.
21:21:04 <araujo> notepad?, hah
21:21:14 <Javagod> probably
21:21:24 <Berengal> There's a pretty big difference between text-editors like notepad++ and kate, and full IDEs like emacs
21:21:35 <pikhq> (note: a lot of what's worth learning in the thing is the *freaking Lisp it's written in*. ;))
21:21:35 <mike-burns> Javagod: It's very worth using either emacs or vim, well.
21:21:37 <araujo> by far
21:21:58 <araujo> emacs and even vim could be considered whole languages and runtimes too
21:21:58 <Berengal> Granted, leksah is probably a better haskell-ide than emacs, but it's not as good a text-editor
21:22:02 <Javagod> how does emacs compare with like visual studio or eclipse?
21:22:37 <pikhq> From what I understand, it's comparable but significantly more flexible.
21:22:40 * araujo felt eclipse would come out in this conversation for some reason :)
21:22:44 <mike-burns> Eclipse is missing the IRC client, video editor, ...
21:23:02 <pikhq> mike-burns: Web browser?
21:23:05 <araujo> and the flexibility, configuration, ......
21:23:17 <coreyoconnor> tetris and AI psychologist
21:23:28 <pikhq> Email client? Lisp interpreter?
21:23:31 <Berengal> However, emacs is still a command-line program, so it's a rather different experience
21:23:35 <pikhq> Man, I forgot about doctor-mode.
21:23:37 <araujo> USENET reader
21:23:42 <Javagod> meh.. like asking gcc to send emails
21:23:48 <Javagod> why
21:23:51 <coreyoconnor> pikhq: And how does that make you feel?
21:23:53 <coreyoconnor> ;-)
21:24:00 <mike-burns> hahaha.
21:24:07 <araujo> Because Emacs is a programming environment
21:24:13 <Berengal> coreyoconnor: Is it because of your mother that you ;-)?
21:24:13 <araujo> That's why
21:24:22 <coreyoconnor> hehehe
21:24:34 <araujo> eclipse is just a plain ide to read reference manuals
21:24:38 <araujo> that's why
21:24:42 <coreyoconnor> I'm sure emacs can make an IRC bot out of doctor-mode
21:24:58 <pikhq> I seem to recall that someone did that a while back.
21:25:05 <Berengal> Eclipse is a pretty decent java IDE. Emacs is a pretty decent EVERYTHING editor, with built-in lisp
21:25:19 <mike-burns> Emacs is a complete OS with a decent editor.
21:25:23 <araujo> hah
21:25:28 <coreyoconnor> haha
21:25:37 <coreyoconnor> Eclipse is a great IDE for java
21:25:38 <Berengal> mike-burns: Lacks a kernel though
21:25:41 <araujo> if you ask me, emacs is the closer we have of a Lisp OS
21:26:01 <coreyoconnor> The core lisp evaluator ~= a kernel?
21:26:13 <Berengal> Does it run in real-mode?
21:26:28 <Berengal> Although I see your point
21:26:28 <pikhq> It can.
21:26:33 <araujo> I remember a project to boot Emacs from bare hardware too ... if you want to get that far
21:26:33 <Javagod> idk would you code faster in eclipse or in vim or emacs?
21:26:37 <pikhq> (the DOS port)
21:26:48 <mike-burns> (But again, I have to suggest that Javagod learn vim well. I want more vim users.)
21:27:24 <araujo> The question is, who code faster and is more productive .... an experienced Emacs user, or Eclipse user
21:27:27 <Berengal> Javagod: Yes, but eclipse might help you write less code by generating bits for you. I haven't tried emacs for java coding, so I can't say
21:27:32 <araujo> I bet all to the Emacs one
21:27:48 <pikhq> From what I understand, Emacs has a decent java-mode, too.
21:28:04 <araujo> I only know about eclipse for java
21:28:06 <pikhq> Berengal: Some modes actually fill in boilerplate, actually.
21:28:13 <pikhq> (rpm-mode is pretty awesome)
21:28:15 <araujo> it seems like it only works for it though
21:28:17 <Javagod> can't live without intellisense when coding java
21:28:30 <pikhq> Oh, right. Java.
21:28:38 * coreyoconnor zing!
21:28:39 <pikhq> The language that thinks more objects = better code.
21:28:41 <Berengal> Does it integrate well with the java enterprise stuff?
21:29:05 <coreyoconnor> eclipse does. Many enterprise Java tools are available as Eclipse add ons
21:29:19 <Berengal> I know eclipse does, but what about emacs?
21:29:22 <coreyoconnor> oh
21:29:24 <coreyoconnor> hm. Dunno!
21:29:32 <Apocalisp> No reason it couldn't
21:29:40 <mike-burns> I wonder how hard it'd be to make emacs understand an Eclipse add on.
21:29:50 <Apocalisp> famous last words
21:29:50 <Javagod> i like ide's to 1-click debug, export, etc
21:29:51 * araujo wonders what it is the fuss about editors filling bits of code for you
21:29:57 <Berengal> I use both eclipse and netbeans at work. Without them I'd be stuck doing boring repetetive tasks besides coding java, and I'd rather not
21:30:12 <Apocalisp> araujo: In Java, this is essential.
21:30:37 <pikhq> araujo: Bad programming languages.
21:30:38 <Berengal> araujo: Java's hello world is longer than c's
21:30:50 <mike-burns> vim has snippet support to handle boilerplate. I'm sure emacs does too. Does this suffice?
21:30:53 <araujo> Remember some students joke ... they used to use eclipse during teaching lessons, in the exam they just couldn't get through the code , they missed all the bits of code filled by the editor...
21:30:53 <coreyoconnor> Java is a contender for most verbose language
21:31:10 <pikhq> coreyoconnor: Most verbose *seriously used* language.
21:31:11 <araujo> now tell me how is that helpful?
21:31:12 <Berengal> mike-burns: Does it download wsdl's and generate java classes for you?
21:31:19 <Javagod> that isn't bad right
21:31:21 <Apocalisp> araujo: "\x ->" in Java is written: new F<SomeLongType, SomeLongerType>() { public SomeLongerType $(final SomeLongType x) { } }
21:31:21 <mmorrow> C's is long?
21:31:27 <araujo> and the worse thing is that everyone seems to be learning using these "IDE"
21:31:28 <mmorrow> main(){printf("OH HAI\n");}
21:31:29 <mike-burns> Berengal: I don't use Java, so no idea.
21:31:41 <Javagod> if being verbose was bad then wouldn't we all use APL or J or something?
21:31:48 <pikhq> mmorrow: Few lines if you include proper formatting and the header.
21:32:01 <coreyoconnor> mike-burns: Vim has snippets? Is this a plugin?
21:32:02 <mmorrow> pikhq: ah, but the linker will take care of printf for you :)
21:32:06 <mike-burns> coreyoconnor: Yes.
21:32:13 <mmorrow> pikhq: it'll just warn about it
21:32:14 <pikhq> Javagod: There's additional length for the sake of being easy to read and there's fucking crazy verbose.
21:32:15 <mmorrow> ;)
21:32:22 <pikhq> Java is fucking crazy verbose.
21:32:24 <araujo> Apocalisp, I really don't see any reason, really, and about long names, that's because java is a mess
21:32:28 <Javagod> true
21:32:36 <Berengal> mmorrow: 7 lines: 1) import 2) blank 3) declare main 4) { 5) printf 6) return 7) }
21:32:49 <araujo> so you need an IDE to organize that mess?, bad language
21:32:50 <pikhq> The only language I know of that is *more* verbose is an esoteric language called Objects R Kool.
21:33:16 <Javagod> easier to code java in eclipse than in vim because i don't have to type getters and setters, javadoc, etc?
21:33:23 <pikhq> And it's written in actual English.
21:33:32 <coreyoconnor> mike-burns: Do you recommend the snippetsEmu or snippets.vim plugin?
21:33:33 <mmorrow> Berengal: ah true, i really should return something
21:33:33 <araujo> that doesn't mean eclipse is better than vim
21:33:34 <pikhq> Javagod: THATS A REASON NOT TO CODE IN JAVA.
21:33:37 <araujo> if that's what you imply
21:33:41 <mike-burns> coreyoconnor: snippets.vim.
21:33:51 <mmorrow> main(){return printf("OH HAI\n") - 7;}
21:33:58 <Javagod> pikhq: aaw.. but i like java
21:33:58 <araujo> it just means java is a poor messy language
21:33:58 <mike-burns> coreyoconnor: But I also don't use it, I just know my coworker tried it for a few months.
21:34:09 <Berengal> Netbeans can actually generate code to send friggin emails automatically for you... It's like they don't even want me to type anymore
21:34:20 <Apocalisp> it is a poor messy language. I'd like to ditch it.
21:34:21 <pikhq> Javagod: Learn something better, like COBOL.
21:34:26 <coreyoconnor> mike-burns: Ah OK. snippetsEmu claims to emulate TextMate snippets. Which were quite well done IMO
21:34:59 <mike-burns> coreyoconnor: I've heard great things about TextMate's snippets. Worth trying, since it's easy to install/uninstall plugins.
21:35:06 <aavogt> what about the default C-n completion?
21:35:19 <Javagod> yea does anyone else use auto gui code generation..
21:35:33 <araujo> pikhq, hah
21:35:35 <pikhq> Javagod: I use languages that don't require it.
21:35:39 <coreyoconnor> mike-burns: But no modal modes like vim. :-( That's what led me to start hacking on Yi.
21:35:51 <Berengal> I use glade to generate GUI descriptors for me, but they're in XML...
21:36:12 * mmorrow is constantly writing code to generate code... it's very handy
21:36:15 <Javagod> arranging gui components by hand is painful in any language
21:36:16 <mike-burns> coreyoconnor: I glanced at Yi, but at this stage it'll take a lot to convince me to use something other than vim or emacs.
21:36:16 * araujo thinks languages requiring gui code generators are not really proper languages 
21:36:23 <araujo> Javagod, not really
21:36:35 <pikhq> mmorrow: Well, yes. That's just straight-up metaprogramming.
21:36:40 <araujo> Haskell makes it very simple
21:36:43 <pikhq> Javagod: Not really.
21:36:45 <Berengal> yi's become slow :(
21:36:49 <araujo> and many others languages too
21:36:54 <Javagod> haven't tried gui programming in haskell
21:36:55 <pikhq> Slightly tangental, Tcl also makes it very simple.
21:36:55 <mike-burns> I use Glade to make my GUI apps, even in Haskell.
21:37:01 <pikhq> And it did it nearly 20 years ago.
21:37:15 <coreyoconnor> mike-burns: Oh Yi isn't ready for prime time yet. Take for instance: I'm hacking on the terminal support layer of Yi instead of implementing snippets. hehe
21:37:20 <Cale> I think that using a GUI to draw your GUI seems reasonably natural :)
21:37:44 <pikhq> Cale: You've just not used many good GUI APIs. :P
21:37:49 <araujo> Cale, never found it flexible enough
21:37:49 <mike-burns> Storing the GUI as a separate XML (or whatever) file feels like a nice separation.
21:38:08 <erikc> yasnippets on emacs are a really good emulation of textmate snippets, particulary when you can run arbitrary elisp to determine the replacement text
21:38:12 <mmorrow> pikhq: exactly, and the more tools there are to help to do this, the more i could get done
21:38:32 <Berengal> The thing about storing the GUI as XML is that I sometimes need dynamically generated windows...
21:38:38 <araujo> mike-burns, that's one of the reasons , i don't like that separation model
21:38:43 <soupdragon> > (| (,) "foo" "bar" |)
21:38:44 <mmorrow> pikhq: i just mean that no matter what language you're using, code generation is awesome
21:38:45 <lambdabot>   <no location info>: parse error on input `|'
21:38:47 <pikhq> package require Tk;pack [label .t -text "Hello, world!"];# Mmm, imperative. :P
21:38:49 <soupdragon> , (| (,) "foo" "bar" |)
21:38:50 <lunabot>  luna: parse error on input `|'
21:38:53 <mmorrow> pikhq: in haskell though, it's just awesomer
21:38:54 <pikhq> mmorrow: 'Tis.
21:39:14 * mmorrow couldn't help throwing in that last comment
21:39:23 <Javagod> well except there's no visual studio for haskell
21:39:28 <soupdragon> no lambdabot has she
21:39:33 <mmorrow> , [$i| (,) "foo" "bar" |]
21:39:35 <Cale> pikhq: Well, no matter how good you make the text API (and don't get me wrong, having a nicely designed API is important), you're still manipulating something which is inherently visual.
21:39:36 <lunabot>  [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('...
21:39:46 <mmorrow> , [$i| (,,) "foo" "bar" [0..9]|]
21:39:49 <lunabot>  [('f','b',0),('f','b',1),('f','b',2),('f','b',3),('f','b',4),('f','b',5),...
21:39:50 <pikhq> Javagod: Because there's no need for it, because Haskell is a good language. ;)
21:40:19 <Berengal> Haskell only needs automatic type-inference, which ghci already provides
21:40:42 <mmorrow> , ppDoc <$> quoteExp i "(,,) \"foo\" \"bar\""
21:40:45 <mike-burns> Javagod: We abstract our boilerplate (or some would even say we scrap it), which means code generation is kinda useless for Haskell.
21:40:45 <lunabot>  ((,,) <$> "foo") <*> "bar"
21:40:50 <araujo> Cale, it's like painting , the painter doesn't need a painting to create other painting ... the most beautiful guis have been created straight from code
21:40:53 <mmorrow> , ppDoc <$> quoteExp i "(,,) \"foo\" \"bar\" [0..9]"
21:40:53 <Javagod> well.. it seems to be missing a good debugger
21:40:56 <lunabot>  (((,,) <$> "foo") <*> "bar") <*> [0..9]
21:41:06 <Berengal> Javagod: doesn't need one
21:41:10 <Berengal> ;)
21:41:32 <pikhq> Javagod: That's because nobody can think of anything that's better than some trace statements or just thinking about your code. ;p
21:41:35 <Cale> Depends on what you mean by 'debugger'
21:41:43 <mike-burns> Javagod: However, haskell-mode and haskell.vim provide shortcuts for inspecting code---inferring types for you, IntelliSense-like functionality, etc.
21:41:49 <araujo> Cale, it's because, believe it or not, whatever gui you are using to create a gui, this always impose a limitation on you in some way or another
21:42:01 <Cale> There's something which I would like to have that I might want to call a debugger, but which would not look very much like a traditional debugger at all.
21:42:02 <Berengal> Cale: A debugger is like a bugger, only de. Sort of like cobuggers, except they're different
21:42:12 <Javagod> yep.. if you don't have it then you don't need it
21:42:23 <coreyoconnor> haskell-mode is very useful.
21:42:31 <araujo> indeed
21:42:32 <coreyoconnor> err. Haskellmode for vim
21:42:57 <mike-burns> haskell.vim was one of many things that convinced me to switch to Haskell.
21:43:20 <Cale> araujo: There are parts of guis which are different, sure, but you should be able to leave a hole in the GUI and fill that in with code. Most of the construction of most GUIs is horribly repetitive boilerplate to construct what is essentially a drawing consisting of standard controls.
21:43:28 <Berengal> Speaking of GUIs, I'd like a GUI descriptor language in haskell...
21:43:54 <mike-burns> Berengal: Like Shoes, but for Haskell?
21:44:00 <Cale> Well, even if it's not really repetitive, it feels that way, because you'd like to just be able to draw it and be done with it.
21:44:12 <Berengal> mike-burns: Haven't tried that, but if it's what I'm thinking about then yes, otherwise no
21:44:31 <mike-burns> Berengal: The Ruby GUI DSL.
21:44:32 <Javagod> what about XAML and the .net stuff that describes guis?
21:44:38 <araujo> Cale, if you are talking to me about those standard DB admin guis , of course , go for something like that, it won't matter any way ... if you intend to design a visually different and innovative GUI, you will go better straight from code in my opinion
21:44:50 <pikhq> Javagod: *vomit*
21:44:51 <Berengal> mike-burns: It's a DSL, so I guess
21:45:20 <mike-burns> Berengal: http://shoooes.net/tutorial/ , to be clear.
21:45:23 <Javagod> no you drag stuff around and it's all there for you
21:45:34 <Javagod> you just have to hand tune some xml
21:45:45 <araujo> no way
21:45:46 <araujo> :P
21:45:47 <Berengal> mike-burns: Yep, looks like it.
21:46:05 <mike-burns> Berengal: Then I too would love something like that in Haskell.
21:46:15 <pikhq> Javagod: And XML sees still more misuse!
21:46:23 <Javagod> yep
21:46:25 * araujo agrees 
21:46:50 <erikc> XAML is reasonably good for its problem domain, it is basically a copy of Cocoa with a dash of elisp and reactive programming
21:46:54 <erikc> with xml instead of sexpressions
21:46:55 <erikc> shrug
21:46:56 <Javagod> shoes is interesting, what language is that
21:47:14 <Cale> Javagod: ruby
21:47:33 <Javagod> ah ok
21:48:10 <pikhq> Next person to use XML for something: is your task markup? If not, why are you using a markup language?
21:48:11 <pikhq> Thank you.
21:48:16 <Berengal> Reading the shoes page made me a little bit more insane. "Shoes. Shoes. Shooooooeeeees!!!!"
21:48:43 <mike-burns> Hah, the author of Shoes is a ... funny guy.
21:48:57 <Berengal> pikhq: I'm using it as a command-language for a half common-lisp implementation written in java
21:48:58 <Cale> araujo: Does every application really need that much innovation in terms of what basic widgets it's built from?
21:49:19 <Javagod> well then we create web pages with markup.. why not applications?
21:49:22 <pikhq> Berengal: YOU ARE THE SPAWN OF SATAN.
21:49:36 <pikhq> Javagod: Because that's not what markup is for.
21:50:02 <Berengal> pikhq: Well, not me personally... it's a project at work. The entire project has "IRONY" written on it, but I'm the only one who can see it :(
21:50:06 <erikc> Cale: if the app is providing some innovation in user interaction, then most likely yes
21:50:10 <pikhq> XML is designed around the assumption that your file is (roughly) 90% data and 10% tags.
21:50:14 <Berengal> (This is why I'm writing a sexpr -> xml converter)
21:50:20 <pikhq> Most XML usage is 10% data and 90% tags.
21:50:28 <pikhq> Berengal: Ah.
21:50:29 <Apocalisp> Everybody knows that you use Java for the business logic and XML for everything else.
21:50:29 <Cale> erikc: But how many apps really do that?
21:50:33 <Javagod> like positioning ui controls and stuff, probably markup and not code
21:50:53 <inimino> Cale: most apps worth using actually do that
21:51:03 <erikc> Cale: i'm tempted to say most of the great ones :)
21:51:03 <Cale> erikc: also, even if it is fairly innovative, the parts of it which are standard should be possible to draw from standard widgets.
21:51:09 <pikhq> All this GUI debate stuff is pointless, anyways: GUIs are trivial.
21:51:19 <Javagod> i don't think so
21:51:21 <mike-burns> Most apps I use don't have innovation in user interaction, so far as I can tell.
21:51:25 <Berengal> Apocalisp: Except when you use java to write an interpreter for xml, and use xml to describe the business logic
21:51:28 <mike-burns> pikhq: Tell that to a UX guy.
21:51:31 <pikhq> It's like debating which language is best for implementing the sieve of Eratosthenes or something.
21:51:46 <inimino> Cale: chances are if your app doesn't do that, your app shouldn't be an app at all, it should be a plugin to an app that does do that
21:51:53 <pikhq> mike-burns: Fine, GUI *coding* is trivial.
21:51:55 <Apocalisp> Berengal: Of course! And you know, you don't actually have to write that Java. You can write it in XML and generate the Java using JAXB!
21:51:55 <araujo> Cale, not every, but I just think those that are trying to do something unique , probably does .... besides, my man concern also is the separation introduced by many of these gui generators between the application language and whatever format/language that is using ... i find it less compact or uniform, and will make the application in some way depending upon such a generator
21:51:57 <erikc> 3d modelers, audio editors, IDEs/code editors, instant messengers, media player, web browsers
21:52:07 <erikc> ms office / iwork
21:52:08 <araujo> main*
21:52:12 <pikhq> GUI *design* is tricky, and that doesn't change from environment to environment.
21:52:17 <erikc> all have gui widgets outside the standard widget set, and they are way better for it
21:52:23 <Berengal> Apocalisp: With a decent sexpr->xml converter you could almost be writing lisp...
21:52:29 <pikhq> erikc: ... Better for it?
21:52:35 <pikhq> You sound like a Windows user.
21:52:44 <erikc> pikhq: i use mac linux and windows
21:52:53 <mmorrow> quick poll (being serious): how many people are on a 32bit OS vs. on a 64bit one?
21:52:53 <mike-burns> Custom widgets confuse me, to be honest.
21:52:58 <Berengal> 64
21:52:59 <mike-burns> mmorrow: 64bit.
21:53:03 <pikhq> The "every app should have its custom widget set" attitude is dumb.
21:53:04 <Apocalisp> Berengal: I replaced some XML in our app with S and reduced the startup memory footprint by 500 megs.
21:53:08 <pikhq> mmorrow: 64-bit.
21:53:29 <mmorrow> hmm, ok thx
21:53:40 <mmorrow> i wonder if the 64bitters are just more vocal.. :)
21:53:50 * mmorrow is on 64bit
21:54:06 <mike-burns> Most new machines are 64-bit.
21:54:30 <pikhq> mike-burns: And most new Windows installs are 32-bit.
21:54:31 <mmorrow> mike-burns: but would you say that most people running a unix variant on those install a 64bit one?
21:54:33 <Berengal> Apocalisp: Interesting. I'll have to add that annecdote in the "proof" category when trying to convince my coworkers my converter is actually unneeded
21:54:34 <pikhq> ;)
21:54:45 <pikhq> mmorrow: A UNIX variant? Certainly.
21:54:55 <mmorrow> hmm, ok.
21:54:57 <Apocalisp> Currently writing comonad comprehensions in Java, along with a sexpr-to-rose-tree parser.
21:55:00 <Apocalisp> muhaha
21:55:13 <mike-burns> mmorrow: The AMD64 download is usually listed above the i386 one.
21:55:25 <Berengal> I've only got monoids implemented yet...
21:55:55 <Cale> I think it should be possible to construct values with an editor which represent GUI components, and then manipulate those values and attach them to behaviour in order to construct a complete program. Ideally, the editor for your programming language would be aware of those values and be able to display them either as code or visually.
21:56:03 <araujo> Cale, Also, talking from experience ... the best GUI applications I have been working with are coded straight from code, and the worse ones are coded through an IDE or visual generator ... I won't say that this is related to my experience, but it's something I find interesting too
21:56:04 <Cale> (inline)
21:56:18 <Apocalisp> http://functionaljava.org. We've monads and comonads and kleisli arrows.
21:56:28 <Apocalisp> all implemented with copy/paste, naturally
21:56:38 <pikhq> Apocalisp: Now if you can just through out the Java.
21:56:40 <Javagod> wonderful library
21:56:41 <pikhq> s/through/throw/
21:56:43 <Berengal> Cale: Might be interesting to see if something happens with non-text languages
21:56:57 <araujo> Cale, subtext?
21:57:00 <Cale> One of the closest things to that ideal that's currently in existence would be mathematica.
21:57:04 <Cale> Not like subtext.
21:57:08 <Apocalisp> pikhq: Baby steps :)
21:57:31 <araujo> In subtext ... you are indeed programming with visual objects
21:57:44 <araujo> at least theoretically :P
21:58:00 <inimino> vaporware, but yes :)
21:58:18 <Cale> Yeah, but while it's a neat idea, subtext has problems in terms of how easy the code is to write and edit. You still need some textual representation I think.
21:59:08 <araujo> me too .. I wish they released something to test ...
21:59:36 <lpsmith> Cale:  have you written much with subtext?
21:59:39 <coreyoconnor> They are two different views onto how to represent a computation. Either way it's all just a collection of symbols
21:59:45 <araujo> I still can't imagine .. say .. an interpreter written on subtext :P
21:59:54 <Cale> lpsmith: no
22:00:02 <araujo> lpsmith, they don't release yet
22:00:04 <araujo> right?
22:00:27 <Cale> araujo: I think you could get a sort of clunky Subtext 1.
22:00:32 <lpsmith> araujo:  I don't know;  I've only heard of it
22:00:47 <inimino> it's a he, not a they, but he hasn't released anything but some screencasts
22:00:50 <jdrake> If I wanted to represent an arbitrary binary string (strictly 1 and 0) in such a way that consuming from the head is as easy as possible, or even better to consume 4 from the head is as easy as possibl, what would be the best data structure to use?
22:00:51 <inimino> (and he's working on something else now from what I understand)
22:01:15 <Cale> Yeah, the tables thing is interesting, at least for a specific type of program
22:01:27 <araujo> Cale, I have no idea, and hard to say without testing of looking at what they exactly have .....
22:02:24 <pikhq> jdrake: A list?
22:02:35 <jdrake> I was thinking of that possibility :p
22:02:50 <sjanssen> jdrake: the most convenient is probably [Bool], less convenient but fast might be ByteString with a bit index added on
22:03:15 <jdrake> Another thing that would be lovely to do is randomly be able to change an entry in the list.
22:03:18 <araujo> Cale, not even mention to implement a type system in subtext
22:03:19 <araujo> :)
22:03:25 <Cale> http://www.wolfram.com/products/mathematica/newin6/content/DynamicInteractivity/
22:03:28 <Cale> http://www.wolfram.com/products/mathematica/newin6/content/SymbolicInterfaceConstruction/
22:03:31 <Cale> some examples
22:03:55 <erikc> jdrake: i'd use the foreign interface and malloc a garbage collected hunk of bytes and use indexing and bit shifting ;)
22:04:13 <jdrake> erikc: sounds like a pain
22:04:21 <jdrake> This is for a simple program
22:04:26 <erikc> ah
22:04:34 <jdrake> I have been out of the game for about 6 months too
22:05:07 <araujo> Cale, is that like OpenCroquet?
22:05:19 <Cale> araujo: I'm not sure what that is.
22:05:40 <araujo> opencroquet.org
22:06:01 <araujo> it's ... a bunch of stuff ...
22:06:03 <araujo> :P
22:06:06 <Cale> araujo: It's basically one particular sort of functional reactive programming. It does make use of mutation a fair amount.
22:06:08 <sjanssen> erikc: why would you use that over ByteString or even IOUArray Bool?
22:06:41 <araujo> Cale, aha ... similar to OC at some degree ... this one is reactive OOP
22:07:26 <Cale> You can actually somewhat ignore the use of mutation if you're careful always to use DynamicModule which is a sort of binding form for dynamic variables.
22:07:34 <Cale> (behaviours, more or less)
22:08:01 <erikc> sjanssen: im just used to doing that kind of stuff in C, so it'd be more familiar to me, no other reason
22:08:19 <sjanssen> erikc: ah, you haven't been fully converted yet :)
22:08:20 <erikc> i was being an ass :)
22:08:53 <Cale> araujo: But yeah, this just seems so obviously the way to go, and clearly you'd want some kind of palette for laying things out, but they should then immediately be reflected as values in the language.
22:09:20 <Cale> (so you can use code to manipulate and construct things when they get complicated)
22:10:05 <araujo> Cale, I see, so you can manipulate visual objects all the way
22:10:14 <Cale> right
22:11:40 <araujo> Cale, so, you don't have a clear separation like say, MVC?
22:12:15 <dobblego> MVC provides a clear separation?
22:12:45 <erikc> Cale: as derided as xaml and wpf are in the non-windows world, they actually have a lot of the gui building functionality (i think) you are describing
22:12:51 <araujo> it does dobblego
22:13:02 <araujo> dobblego, very clear in languages like Smalltalk
22:13:13 <dobblego> araujo, I've never seen evidence for that -- quite the contrary
22:13:28 <araujo> if you think of MVC like those web frameworks around ..
22:13:37 <araujo> those are not the best examples
22:13:46 <Cale> araujo: Well, you can still clearly separate out the model. Often the view and controller will fit together into one piece.
22:14:19 <araujo> Cale, I can see that
22:20:23 <Cale> araujo: Though, you can take input from some controls, transform it, and display it elsewhere with other controls, but really, it's like the input values are just being updated everywhere simultaneously when the user changes them, and things get recomputed as necessary.
22:21:27 <araujo> hah, cool
22:23:32 <araujo> Cale, Also, and i have to ask you this, can you use this environment from other languages too? :)
22:25:29 <hackagebot> shelltestrunner 0.5 - A tool for testing command-line programs. (SimonMichael)
22:26:10 <Cale> araujo: Well... yes actually.
22:26:27 <Cale> I haven't tried it, but there's a Haskell binding
22:26:35 <Cale> http://hackage.haskell.org/package/mathlink
22:26:47 <araujo> hahaha nice
22:29:41 <jdrake> If I wanted to execute a certain function n times and collect the results in a list, what would be the most appropriate thing to use?
22:30:34 <Cale> jdrake: execute an IO action?
22:30:42 <jeffwheeler> jdrake: like, [f 1, f 2, f 3]?
22:30:43 <Cale> jdrake: or evaluate a function?
22:31:00 <Cale> functions will produce the same result every time you apply them to the same value
22:31:10 <jdrake> strictly speaking it is an action, specifically randomIO
22:31:14 <Cale> ah, okay
22:31:17 <Cale> replicateM
22:31:20 <Cale> :t replicateM
22:31:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
22:32:20 <Cale> You'll find it in Control.Monad. It's surprisingly easy to write by hand, which is something that is worth seeing or trying for yourself if you haven't seen it.
22:33:20 <jdrake> @src replicateM
22:33:20 <lambdabot> replicateM n x = sequence (replicate n x)
22:33:49 <aavogt> or use randoms
22:35:23 <jdrake> Before I go to bed, any suggestions for my surprisingly easy to make code? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2980#a2980       Style only, I am not actually doing the big stuff yet. This is my first haskell code in months.
22:35:37 <aavogt> @type randoms <$> newStdGen
22:35:38 <lambdabot> forall a. (Random a) => IO [a]
22:37:01 <jdrake> Is there any advantage to that over what I am doing now?
22:38:04 <Berengal> Sometimes haskell looks very much like perl...
22:38:16 <sbahra> Blasphemy.
22:38:27 <mjrosenb> wow ghc is slow when it is interpreted
22:38:35 <jdrake> Berengal: you might want to be silent, you might catch the attention of the people with the crosses and pitch forks.
22:38:38 <Berengal> readFile "foo" >>= putStrLn . (=~ "bar")
22:39:20 <Berengal> Or the general version: grep pat = putStrLn . (=~ pat) <=< readFile
22:39:39 <Gracenotes> Berengal: uh.. lines call somewhere?
22:39:49 <gfreeman> Berengal: You know, I bet you could pass that off to perl with people who aren't terribly familiar with it.
22:39:51 <Berengal> Gracenotes: Only if you care about lines
22:40:20 <mjrosenb> Berengal: even if it looks like perl, it is more consistent than perl and less likely to explode in random ways
22:40:29 <Gracenotes> perhaps so.. but I will now get a bagel with cream cheese
22:40:35 <jdrake> Have you guys heard of the 'comefrom' statement in a certain historical language?
22:40:41 <Berengal> INTERCAL?
22:40:44 <jdrake> yes
22:40:45 <mjrosenb> jdrake: yes
22:40:56 <jdrake> Well, somebody has done the unthinkable... http://entrian.com/goto/   Implemented it in python
22:41:11 <Berengal> jdrake: goto is just a library in haskell...
22:41:27 <jdrake> Does it work in similar ways as I would expect?
22:41:32 <jdrake> I would love goto :p
22:41:37 <soupdragon> haskell doesn't have goto
22:41:59 <Berengal> I think someone implemented goto in an assembly-describing monad...
22:42:24 <jdrake> If somebody implemented a comeFrom for haskell, I would respect that person most highly.
22:43:22 <gfreeman> Could I get some monad help,please?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7022#a7022
22:43:32 <Berengal> Looked something like 'do {foo <- label; mov AEX 4; cmp AEX BEX; jne bar; jmp foo; bar <- label; ret}'
22:43:42 <gfreeman> I'm trying to figure out how to represent this with monad transformers
22:44:38 <jdrake> Berengal: THat is disturbingly nice
22:44:58 <Cale> gfreeman: okay...
22:45:13 <Berengal> gfreeman: Looks like State to me, but I'm probably jumping the gun
22:45:37 <gfreeman> Berengal: It's not quite. It's something halfway between Reader, Writer, and State
22:46:04 <Berengal> gfreeman: ask makes it forget everything it's told...
22:46:10 <soupdragon> Reader + Writer = State  ??
22:46:34 <Berengal> soupdragon: ReaderT r (Writer w) a /= State anything a
22:46:34 <gfreeman> Berengal: So sue me. It's not a canonical ask. It's more like "get" but I don't want "put"
22:47:54 <Berengal> gfreeman: get doesn't forget either, and only writer requires a monoid.. anyway, I don't quite get what you want
22:48:48 <gfreeman> Perhaps I should give my motivation:
22:49:38 <gfreeman> I was working with matrices, and wanted a way to apply transformations to two matrices simultaneously.
22:49:53 <gfreeman> One would be user provided, the other from 'mempty'
22:50:01 <gfreeman> either zero or id, depending.
22:50:52 <gfreeman> So, through the calculation, you can query the state of the user supplied matrix, and at the end, you get the transformation of the 'mempty' matrix
22:51:42 <gfreeman> Does that make sense, or not?
22:51:55 <Berengal> Not to me, I'm terrible with matrices
22:52:28 <gfreeman> Regardless of them being matrices. Just think of them as Monoids.
22:53:11 <Berengal> Sounds like a StateT matrix (WriterT matrix) monad...
22:53:52 <Berengal> Wrap it in a newtype and make it so each transformation on the state is also carried out on the writer
22:54:27 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7023#a7023
22:54:38 <Cale> okay, so I started by getting it to compile.
22:54:47 <Cale> Turning it into a monad transformer after that is easier.
22:55:27 <mmorrow> @unmtl ReaderT r (Writer w) a
22:55:28 <lambdabot> r -> (a, w)
22:55:36 <mmorrow> @unmtl WriterT r (Reader w) a
22:55:36 <lambdabot> w -> (a, r)
22:55:44 <mmorrow> err
22:55:48 <mmorrow> @unmtl WriterT w (Reader r) a
22:55:48 <lambdabot> r -> (a, w)
22:55:57 <Cale> Indeed, we could build it using Reader and WriterT
22:56:09 <Berengal> @unmtl StateT m (Writer m) a
22:56:10 <lambdabot> m -> (a, m, m)
22:56:11 <mmorrow> my favorite equivalence is
22:56:19 <Berengal> Hmm, interesting
22:56:22 <mmorrow> @unmtl StateT s (Cont o) a
22:56:23 <lambdabot> s -> (a -> s -> o) -> o
22:56:33 <Cale> Berengal: it did something wrong there
22:56:36 <mmorrow> @unmtl ContT o (Reader s) a
22:56:37 <lambdabot> (a -> s -> o) -> s -> o
22:56:54 <Cale> Berengal: It collapsed a pair with a pair in it into a triple
22:56:56 <mmorrow> so a Reader inside a ContT is effectively a StateT Cont
22:57:25 <mmorrow> which surprised me
22:57:27 <Berengal> Cale: I noticed. They're "the same" though, if you were writing the entire thing as a single monad
22:57:30 <Cale> mmorrow: That is interesting
22:57:41 <Cale> Berengal: more or less, yes
23:00:44 <lpsmith> you could probably implement a comefrom monad
23:01:19 <gfreeman> So, StateT w Writer w should do it for me?
23:01:39 <gfreeman> I'm rather suspicious of that combination, actually.
23:02:36 <lpsmith> suspicious of what?
23:02:39 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7023#a7025 -- and there's the monad transformer version of it
23:02:46 <gfreeman> I don't think it would work.
23:02:46 <Cale> I wouldn't actually write it that way myself
23:02:58 <Cale> But I think it's instructive perhaps to look at how that translation goes
23:03:10 <Cale> (from the revision just above to the monad transformer version)
23:05:05 <strathhelp> anyone know of any tutorials or books that help teach math concepts through haskell?
23:05:14 <Cale> let becomes do, and you stick some returns in here and there :)
23:05:29 <Cale> strathhelp: There's Haskell Road
23:05:34 <gfreeman> Cale: That looks fine, but I'm not actually looking for a transformer. I'm trying to figure out how to do all this in three lines of code.
23:05:55 <Cale> http://homepages.cwi.nl/~jve/HR/HR.pdf
23:06:03 <Cale> gfreeman: ah, okay
23:07:46 <lpsmith> cale: sweet,  I didn't know the Haskell Road was available online
23:08:28 <Cale> lpsmith: It's always been sitting there, from before the book ever came out. The main website doesn't actually link to that pdf, but it's there.
23:08:51 <Cale> (it used to link to that pdf, before the book was published)
23:09:35 <lpsmith> sweet
23:09:46 <lpsmith> I own a copy,  I like the book
23:10:01 <lpsmith> Actually I bought a second copy and gave it away too
23:10:08 <strathhelp> cale: Thanks, just what i was looking for
23:10:28 <quicksilver> lpsmith++ # supporting haskell authors
23:11:20 <strathhelp> are there any issues with haskell road using hugs for its examples
23:13:37 <mjrosenb> hrmmhey, does anyone know how to tell cabal where an executable is located?
23:14:07 <mornfall> Ideally, set PATH.
23:14:28 <mjrosenb> yeah, i tried setting PATH when running ./configure
23:14:40 <mjrosenb> but that seems to not have influenced cabal
23:14:52 <mornfall> You have ./configure?
23:15:02 <mjrosenb> mornfall: ja
23:15:11 * mornfall confused
23:15:23 <mornfall> Cabal is supposed to run ./configure itself, no?
23:15:31 <mornfall> Like, PATH=... cabal configure
23:15:42 <mornfall> (or PATH=... runghc Setup configure)
23:15:42 <mjrosenb> mornfall: except make runs cabal
23:15:46 <mornfall> Icky.
23:15:48 <mornfall> Why?
23:16:01 <mjrosenb> mornfall: ask in #ghc
23:16:05 <mornfall> Oh, GHCp
23:16:09 <mornfall> -p
23:16:09 <lpsmith> strathhelp,  there shouldn't be any issues
23:16:27 <lpsmith> but honestly I haven't used hugs almost at all since ghci came out
23:16:27 <mornfall> Can you export the new PATH for whole shell, not just configure?
23:16:52 <mornfall> So make picks it up as well?
23:17:07 <mjrosenb> mornfall: have done that and i am re-making now
23:17:19 <mornfall> Ok.
23:23:12 <mjrosenb> well it knows about hsc2hs
23:23:24 <mjrosenb> unfortunately, that goes bye bye pretty quickly
23:23:35 <mjrosenb> hsc2hs: Main.hs:168:6-68: Irrefutable pattern failed for pattern (before, tpl : after)
23:36:27 <mmorrow> oh man, i just had a 15 minute epic trying to get rwbarton's "oldtype" squeezed through all the evals/quotes/hackery needed to be able to do
23:36:29 <mmorrow> , old [t| forall o x a. ContT o (Reader x) a |]
23:36:32 <lunabot>  forall a b c . (c -> b -> a) -> b -> a
23:36:41 <mmorrow> , old [t| forall o x a. StateT x (Cont o) a |]
23:36:44 <lunabot>  forall a b c . b -> ((,) c b -> a) -> a
23:36:59 <mmorrow> and this works for *any* combo of newtype, no matter how deep or from what package
23:37:35 <mmorrow> (if unwrapping the newtype is actually recursive, iirc he just doesn't unwrap that one or something)
23:38:06 <mmorrow> whoa, does @unmtl detuple that?
23:38:21 <mmorrow> err, this is monadLib, not sure if that's why
23:38:29 <mmorrow> , src ''StateT
23:38:32 <lunabot>  newtype StateT i m a = S (i -> m ((a, i)))
23:38:40 <mmorrow> , src ''Cont
23:38:43 <lunabot>  newtype Cont i a = C' {unC :: (ContT i Id a)}
23:39:02 <mmorrow> nice, his "oldtype" uwrapped two levels there
23:39:05 <mmorrow> , src ''ContT
23:39:08 <lunabot>  newtype ContT i m a = C ((a -> m i) -> m i)
23:39:18 <mmorrow> , [$ty| oldtype |]
23:39:21 <lunabot>  Type -> Q ((Type, [] Dec))
23:39:57 <mmorrow> , ppDoc . snd $ $(lift =<< oldtype =<< [t| forall o x a. StateT x (Cont o) a |])
23:40:00 <lunabot>  luna: Ambiguous type variable `t' in the constraints:
23:40:18 <mmorrow> , ppDoc $ (snd $(lift =<< oldtype =<< [t| forall o x a. StateT x (Cont o) a |]) :: [Dec])
23:40:21 <lunabot>  luna: no output
23:42:42 <mmorrow> http://github.com/rwbarton/oldtype/tree/master
23:43:32 <taruti> What is currently the best way to integrate hpc into a cabal package?
23:43:36 <mmorrow> now that this is convenient and all, i can't think of any newtype to do it on
23:43:46 <mmorrow> taruti: integrate it how?
23:44:50 <mjrosenb> what is hpc?
23:44:55 <taruti> mmorrow: in the best case get cabal to support it like it supports runnning tests
23:45:08 <mmorrow> taruti: so at install-time you mean?
23:45:14 <taruti> mjrosenb: http://projects.unsafeperformio.com/hpc/
23:45:17 * mjrosenb is having issues compiling ghc because hpc needs hsc2hs in order to install
23:45:22 <mmorrow> taruti: and it would generate the pretty html for the user?
23:45:30 <taruti> yes
23:45:45 <mjrosenb> ok, new question
23:45:56 <mjrosenb> how do i tell ghc to *not* build hpc
23:46:11 <mmorrow> taruti: hmm, possibly you could have a script/whatever that you run as a "test" that does all this
23:46:12 <mjrosenb> since i can't imagine it is needed for ghc to run properly
23:46:30 <mmorrow> mjrosenb: just install hsc2hs?
23:46:49 <mmorrow> mjrosenb: doesn't that come with ghc?
23:46:52 <taruti> mmorrow: things need to be compiled with -fhpc for that, so simply calling the test executable in a hook does not work
23:47:04 <mmorrow> taruti: ah, right.
23:47:13 <mjrosenb> mmorrow: yes, but i am attempting to bootstrap ghc
23:47:16 <jdrake> What would be the correct way of making this: (\x -> if (x == True) then '1' else '0')  so that it could be used with mapM?
23:47:19 <mjrosenb> so it does not exist yet
23:47:23 <mjrosenb> rather
23:47:32 <mjrosenb> it exists from a not-install build
23:47:40 <mjrosenb> but does not seem to function properly
23:47:58 <mmorrow> taruti: so then a brute force way i guess would be to have this script copy all the code into a tmp dir, build it all (again) with -fhpc, generate the html, rm -rf the tmp dir, mv the html to wherever
23:48:08 <mjrosenb> jdrake: \x -> return (...)
23:48:17 <jdrake> merci
23:48:30 <taruti> mmorrow: yes, if there is no simpler way of doing this. seems like an ugly hack.
23:49:05 <mmorrow> taruti: heh, yes, but nothing is uglier hack than no hack at all
23:49:46 <mmorrow> taruti: (if you put some effort into this, consider contributing a patch to cabal..)
23:51:18 <mmorrow> taruti: thinking about this, if cabal had this feature, it'd have to build all the code again to do it anyways (e.g. haddock has to re-typecheck all the code to generate the docs), so this hack wouldn't be too far from the truth wrt what cabal would need to do
23:51:38 <taruti> yes
23:51:51 <taruti> going via a Makefile seems simpler
23:51:57 <mmorrow> yeah totally
23:52:15 <mmorrow> it would be killer if cabal implemented some sort of Makefile system
23:52:27 <mmorrow> i've seen various ideas about this
23:53:32 <mmorrow> taruti: (also, you can get cabal to use a Makefile you have with a little work, you'd use build-type: Make, and then i forget what else)
23:54:11 <taruti> but that breaks things on windows (hpc is optional, all builds wanting make is not nice)
23:54:53 <taruti> I'll hack something up
23:55:34 <mmorrow> hehe, "but that breaks something on windows" is such a classic line :)
23:55:36 <jdrake> Is there a way to drop the monad off of a list like IO [Bool]?
23:56:31 <mmorrow> ooh, i'll use xyz lib specified in the portable operating system standard! everything'll work out and i'll get a pony!!.
23:56:40 <mmorrow> "but that breaks something on windows"
23:58:52 <mjrosenb> dear world:
23:59:02 <mjrosenb> can we please deprecate windows already?
23:59:08 <mjrosenb> love, mjrosenb
23:59:21 <mmorrow> mjrosenb: but that breaks something on windows
23:59:40 <gfreeman> mmorrow: that's why it's deprecated
23:59:41 <mjrosenb> mmorrow: but it'll be deprecated, so who cares?
23:59:52 <mmorrow> (not i :)
23:59:58 <mjrosenb> srcadi.'aonsetid4'3rcd
