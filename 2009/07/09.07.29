00:01:07 <dolio> Jaskell is a lot different than Haskell.
00:01:26 <thaldyron> Does anyone know a type class for types that have a string-convertable key? (something like: class Key a where key :: a -> String)
00:01:38 <kyagrd> @hoogle key
00:01:39 <lambdabot> Data.IntMap type Key = Int
00:01:39 <lambdabot> Text.XHtml.Frameset keyboard :: Html -> Html
00:01:39 <lambdabot> Text.XHtml.Strict keyboard :: Html -> Html
00:01:59 <dcolish> yeah LambdaVM looks much more complete
00:02:34 <jeffwheeler> Saizan: by the way, thanks again the help on GADTs earlier.
00:02:42 <kyagrd> @hoogle typehash
00:02:42 <lambdabot> No results found
00:02:45 <kyagrd> @hoogle type-hash
00:02:45 <lambdabot> keyword type
00:02:46 <lambdabot> Language.Haskell.TH data Type
00:02:46 <lambdabot> Language.Haskell.TH.Syntax data Type
00:02:52 <jeffwheeler> It's easy to forget just how nice #haskell is, until you go into other rooms.
00:03:07 <jeffwheeler> People just yell a lot elsewhere.
00:03:30 <wmealing_> dcolish, ok.
00:03:41 <vav> @type show -- thaldyron 'deriving Show'
00:03:42 <lambdabot> forall a. (Show a) => a -> String
00:04:03 <wmealing_> dcolish, its mainly just for playing around, would like something as close to haskell as possible
00:05:00 <dcolish> wmealing_: well maybe jaskell will be ok, but LambdaVM is a true java backend for ghc
00:05:45 <thaldyron> vav: mhm, I rather leave the Show instance for printing the whole value not just the key
00:06:10 <vav> thaldyron: what do you mean by key?
00:07:01 <vav> oh as in a Map or Either or State
00:07:04 <dcolish> wmealing_: NestedVM is pretty awesome too
00:07:11 <thaldyron> vav: something to index
00:07:26 <thaldyron> vav: like a user ID
00:08:26 <wmealing_> dcolish, i'll do some experiments tonight on what can run on the android phone.. guess i'll be learning pretty quickly.
00:08:48 <dcolish> how complete is the vm embedded in android?
00:10:31 <copumpkin> sometimes it'd be nice to have an unfoldl that didn't take a maybe
00:10:40 <copumpkin> I don't mind if it's infinite
00:10:42 <kyagrd> There are strange libraries on Hackage. One of them is acme-now, whose full source is http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/src/Acme-Time-Now.html#now
00:10:49 <copumpkin> :t unfoldl
00:10:50 <lambdabot> Not in scope: `unfoldl'
00:10:56 <copumpkin> :t unfoldr
00:10:57 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:11:01 <copumpkin> yeah, what I meant :P
00:11:17 <copumpkin> I guess that's basically iterate
00:11:40 <ceal> how can we take a list as an input?
00:11:58 <copumpkin> :t iterate
00:11:59 <lambdabot> forall a. (a -> a) -> a -> [a]
00:12:04 <mmorrow> kyagrd: that's actually more clever than it first seems though. because since the IO action will only run once, it can be evaluated any number of times and it will always have the value of the first point in time it was run
00:12:17 <mmorrow> so it forever freezes "now"
00:12:22 <copumpkin> ceal: ?
00:12:38 <Axman6> ceal: care to elaborate
00:12:41 <Axman6> ?
00:12:50 <ceal> using readLn :: IO Integer
00:13:00 <ceal> integer input is possible
00:13:03 <kyagrd> mmorrow: sure, but it was surprising that it was packaged up as a library :)
00:13:08 <Axman6> readLn :: IO [Integer]
00:13:10 <copumpkin> :t replicateM 10 readLn
00:13:11 <lambdabot> forall a. (Read a) => IO [a]
00:13:13 <mmorrow> kyagrd: heh
00:13:21 <ceal> Axman6: that didn't work
00:13:53 <Axman6> ceal: "didn't work'?
00:14:03 <Axman6> you need to explain your problems so we can help you ;)
00:15:02 <ceal> hold on let me try that again
00:15:20 <Axman6> it would help if you could share your code with us too
00:15:28 <blueonyx> hi, what should i throw if i just want to throw some exception?
00:15:42 <ceal> it worked what you said
00:15:43 <Axman6> SomeException maybe?
00:15:48 <ceal> <stumped>
00:15:55 <ceal> it didn't earlier
00:16:02 <Axman6> @instances Read
00:16:02 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
00:16:08 <ceal> let me try executing it
00:16:25 <Axman6> ceal: are you giving it something like "[1,2,3,4]" as input?
00:16:31 <ceal> no
00:16:38 <ceal> actually just typing in the numbers
00:16:46 <ceal> separated by a space
00:16:47 <Axman6> well, that's what you nead if you want read in a list
00:16:53 <Axman6> need*
00:17:01 <mmorrow> , (+) 1 2
00:17:04 <lunabot>  3
00:17:05 <mmorrow> , (+) [1,2]
00:17:06 <lunabot>  luna: No instance for (GHC.Show.Show ([t] -> [t]))
00:17:17 <mmorrow> @type [1,2]
00:17:18 <lambdabot> forall t. (Num t) => [t]
00:17:21 <mmorrow> @type 1 2
00:17:22 <lambdabot>     Ambiguous type variable `t' in the constraint:
00:17:22 <lambdabot>       `Num t' arising from the literal `2' at <interactive>:1:2
00:17:22 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
00:17:28 <mmorrow> gah
00:17:32 <ceal> ok'
00:17:49 <vav> > words "1 42 666"
00:17:51 <lambdabot>   ["1","42","666"]
00:17:58 <ceal> actually my doubt was a bit different but i thought it could be fixed by this one too
00:18:00 <ceal> http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=3112#a3112
00:18:00 * mmorrow is trying to say that 1 2 isn't a list, but some random typeclass keeps giving not the error msg i was trying to get
00:18:06 <solrize> Parsec.Token.makeTokenParser <-- java factory pattern heh heh, heh heh
00:18:07 <ceal> i need to take this kind of input
00:18:12 <Axman6> ceal: if you want to do what you're after, try using: map read . words `fmap` getLine
00:18:13 <ceal> and store it in a list
00:18:56 <kniu> @pl (\a -> \b -> f (g a) b)
00:18:56 <lambdabot> f . g
00:19:01 <kniu> huh.
00:19:03 <kniu> that was easy.
00:19:15 <kyagrd> ceal: or you can use parsec :)
00:19:19 <ceal> Axman6: but wont in still be the same as giving IO [Integer]
00:19:22 <ceal> map read . words `fmap` getLine
00:19:35 <ceal> kyagrd: what's that?
00:19:50 <kyagrd> @hoogle Parsec
00:19:51 <lambdabot> module Text.Parsec
00:19:51 <lambdabot> module Text.ParserCombinators.Parsec
00:19:51 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
00:19:55 <Axman6> ceal: no
00:19:58 <copumpkin> eww, not fmap used infixly!!
00:19:59 <copumpkin> <$> ftw
00:20:12 <ceal> Axman6: ?
00:20:14 <Axman6> > read "[1,2,3]" :: [Integer]
00:20:16 <lambdabot>   [1,2,3]
00:20:26 <Axman6> > read "1 2 3" :: [Integer]
00:20:26 <ceal> i get that
00:20:27 <lambdabot>   * Exception: Prelude.read: no parse
00:20:30 <kyagrd> > many
00:20:32 <lambdabot>   Overlapping instances for GHC.Show.Show (f a -> f [a])
00:20:32 <lambdabot>    arising from a us...
00:20:41 <kyagrd> @type many
00:20:42 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
00:20:48 <Axman6> > map read . words $ "1 2 3" :: [Integer]
00:20:49 <lambdabot>   [1,2,3]
00:21:08 <ceal> did you see the input what's it like?
00:21:19 <ceal> it's all inputs separated by a newlinie
00:21:23 <ceal> new line*
00:21:42 <kyagrd> words can handle newline since it uses Char.isSpace
00:21:50 <Axman6> in that case, you want something like: sequence readLn :: IO [Integer]
00:22:05 <Axman6> :t sequence ReadLn
00:22:06 <lambdabot> Not in scope: data constructor `ReadLn'
00:22:07 <Axman6> :t sequence readLn
00:22:09 <lambdabot>     Couldn't match expected type `[m a]' against inferred type `IO a1'
00:22:09 <lambdabot>     In the first argument of `sequence', namely `readLn'
00:22:09 <lambdabot>     In the expression: sequence readLn
00:22:10 <kyagrd> > words "1\n2\n\3"
00:22:11 <lambdabot>   ["1","2","\ETX"]
00:22:15 <Axman6> hmm
00:22:16 <kyagrd> > words "1\n2\n3"
00:22:17 <lambdabot>   ["1","2","3"]
00:22:28 <Axman6> urgh, of course
00:22:42 <Axman6> :t sequence (replicate readLn)
00:22:43 <lambdabot>     Couldn't match expected type `Int' against inferred type `IO a'
00:22:44 <lambdabot>     In the first argument of `replicate', namely `readLn'
00:22:44 <lambdabot>     In the first argument of `sequence', namely `(replicate readLn)'
00:22:51 <Axman6> :t sequence (repeat readLn)
00:22:53 <lambdabot> forall a. (Read a) => IO [a]
00:23:04 <Axman6> god damn, too far too many tries, heh
00:23:51 <ceal> lambdabot: does it also work when inputs are separated by a white space?
00:24:10 <Axman6> lambdabot is a bot, not a person
00:24:14 <Axman6> @bot
00:24:15 <lambdabot> :)
00:24:15 <lunabot>  :)
00:24:33 <ceal> oh!!
00:24:38 <gwern> @quote
00:24:39 <lambdabot> zeppterm says: haskell should have dynamic typing like scheme
00:24:53 <gwern> @quote
00:24:53 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
00:24:53 <lambdabot>  but then I look at some java code and I'm all happy again
00:24:54 <kyagrd> Wow lunabot also smiled!
00:26:20 <Axman6> ceal: there is also a function called interact which you may find useful
00:26:23 <Axman6> :t interact
00:26:24 <lambdabot> (String -> String) -> IO ()
00:26:26 <ceal> Axman6: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=3113#a3113
00:26:29 <ceal> didn't work
00:26:53 <Axman6> basically, it works like a terminal, taking a string as input, and printing the result of the provided function
00:27:15 <Axman6> ceal: yeah that's because that code was wrong ;)
00:27:19 <kyagrd> :t sequence readLn
00:27:20 <lambdabot>     Couldn't match expected type `[m a]' against inferred type `IO a1'
00:27:21 <lambdabot>     In the first argument of `sequence', namely `readLn'
00:27:21 <lambdabot>     In the expression: sequence readLn
00:27:36 <ceal> gotta run; have class in 2 minutes
00:27:43 <Axman6> it should probably be sequence (repeat readLn)
00:27:48 <ceal> hmmm
00:27:57 <ceal> that makes some sense; let me try that too
00:28:20 <Axman6> it should be ok, i think. i'm not sure how it'll actually work though
00:28:35 <ceal> is it like m <-sequence (repeat readLn) :: [IO Integer]?
00:28:55 <Axman6> no, IO [Integer], which makes m :: [Integer]
00:29:18 <ceal> is it like m <-sequence (repeat readLn) :: IO [Integer] right?
00:29:25 <Axman6> yep
00:29:32 <Axman6> which is what you wanted right?
00:29:45 <ceal> i made a typo; let me try that...
00:30:27 <Axman6> this may be a little weird to use though
00:30:45 <ceal> Axman6: how do i specify when to stop?
00:30:51 <Axman6> like, once you press the newline, it may or may not print that you've typed
00:31:27 <ceal> i got an error "user error (Prelude.readIO: no parse)"
00:31:35 <Axman6> yeah, sec
00:31:42 <kyagrd> you can't stop with repeat
00:32:06 <kyagrd> repeat generates infinte list :)
00:32:10 <ceal> so i need to have a counter?
00:32:24 <kyagrd> it depens on what you want
00:33:02 <kyagrd> whether you want to have fixed number of input or want keep getting input unless some special mark for ending input
00:33:13 <Axman6> http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=3113#a3114 will exit when you get an empty line
00:33:59 <ceal> Axman6: but i want the list as a whole and process it further...
00:34:05 * Gracenotes listens to tubular bells
00:34:06 <ceal> i have done what you just showed me
00:34:14 <Axman6> well, then don't exit in the then part
00:34:31 <ceal> but what you said only stores one input at a time in l
00:34:37 <ceal> i want all inputs in l
00:34:38 <Axman6> yeah
00:34:41 <Axman6> hang on
00:35:11 <ceal> just like taking an array in C++
00:35:56 <kniu> @src foldr
00:35:56 <lambdabot> foldr f z []     = z
00:35:57 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:36:05 <Axman6> :t sequence
00:36:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:36:07 <kniu> @src foldl
00:36:07 <lambdabot> foldl f z []     = z
00:36:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:36:44 <kniu> @src foldl1
00:36:44 <lambdabot> foldl1 f (x:xs) = foldl f x xs
00:36:44 <lambdabot> foldl1 _ []     = undefined
00:36:55 <kyagrd> @hoogle whileM
00:36:55 <lambdabot> No results found
00:37:00 <kyagrd> @hoogle untilM
00:37:00 <lambdabot> No results found
00:37:13 <kyagrd> @hoogle foldM
00:37:14 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
00:37:14 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
00:37:14 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
00:37:21 <ceal> kyagrd: did you run a search in hoogle?
00:37:25 * Axman6 should really pay attention to the databases lecture
00:37:25 <ceal> just asking?
00:37:42 <kyagrd> yes
00:43:00 <kniu> @pl (do l <- termin; r <- many1 (symbol "<" >> many1 def); foldl DefWhere l r)
00:43:00 <lambdabot> (line 1, column 16):
00:43:00 <lambdabot> unexpected ";"
00:43:00 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
00:43:14 <kniu> @pl do {l <- termin; r <- many1 (symbol "<" >> many1 def); foldl DefWhere l r}
00:43:14 <lambdabot> (line 1, column 4):
00:43:14 <lambdabot> unexpected "{"
00:43:14 <lambdabot> expecting variable, "(", operator or end of input
00:43:25 <kniu> huh.
00:44:05 <kniu> @pl termin >>= \l -> many1 (symbol "<" >> many1 def) >>= \r -> foldl DefWhere l r}
00:44:05 <lambdabot> (line 1, column 78):
00:44:06 <lambdabot> unexpected "}"
00:44:06 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
00:44:07 <kniu> @pl termin >>= \l -> many1 (symbol "<" >> many1 def) >>= \r -> foldl DefWhere l r
00:44:08 <lambdabot> (many1 (symbol "<" >> many1 def) >>=) . foldl DefWhere =<< termin
00:45:11 <kyagrd> @hayoo whileM
00:45:12 <lambdabot> Unknown command, try @list
00:45:17 <kyagrd> @hoogle whileM
00:45:17 <lambdabot> No results found
00:45:43 <kyagrd> Hoogle doesn't search for hackage?
00:46:00 <kyagrd> Hayoo finds whileM but not in Hoogle
00:47:44 <kyagrd> @hoogle+ whileM
01:10:39 <blueonyx> > throw "error"
01:10:41 <lambdabot>   Not in scope: `throw'
01:28:46 <hackagebot> AERN-RnToRm-Plot 0.2.0.1 - GL plotting of polynomial function enclosures (PFEs) (MichalKonecny)
01:34:35 <gwern> > (35000000 * 1200), (7000000000 * 30))
01:34:36 <lambdabot>   <no location info>: parse error on input `,'
01:34:42 <gwern> > ((35000000 * 1200), (7000000000 * 30))
01:34:44 <lambdabot>   (42000000000,210000000000)
01:34:52 <gwern> > (35000000 * 1200) < (7000000000 * 30)
01:34:53 <lambdabot>   True
01:42:53 <mbuf> Hi! what is the reason for this error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7710#a7710 (newbie here)
01:43:59 <ivanm> mbuf: where is PortNumber defined?
01:44:10 <ivanm> because wherever it is, you haven't imported it ;-)
01:44:16 <mbuf> ivanm, in Network module?
01:44:26 <dolio> I suspect it isn't exported, and you're supposed to just use numeric literals.
01:44:34 <ivanm> mbuf: in that case, you shouldn't filter it out of the import list
01:44:46 <ivanm> dolio: he has an explicit import of Network
01:44:53 <ivanm> importing only listenOn
01:45:00 <dolio> Oh.
01:45:10 <ivanm> @hoogle listenOn
01:45:10 <lambdabot> No results found
01:45:14 <mbuf> ivanm, dolio if I use only "import Network", I get ...
01:45:18 <ivanm> bah
01:45:36 <dolio> Ah, it is exported.
01:45:36 <mbuf> ivanm,  Ambiguous occurrence `accept'
01:45:37 <mbuf>     It could refer to either `Network.accept', imported from Network at SimpleChanServer.hs:6:0-13 or `Network.Socket.accept', imported from Network.Socket at SimpleChanServer.hs:13:0-20
01:45:42 <ivanm> mbuf: right
01:46:00 <ivanm> so what you do is you have "import Network (PortNumber(..), listenOn)"
01:50:08 <mbuf> ivanm, i see; see the revised change and error message 'Not in scope: data constructor 'PortNumber'' : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7710#a7711
01:50:29 <ivanm> mbuf: what's the type of lookOn
01:50:35 <ivanm> I mean listenOn
01:51:11 <mbuf> ivanm, listenOn :: PortID -> IO Socket
01:51:18 <mbuf> ivanm, http://cvs.haskell.org/Hugs/pages/libraries/network/Network.html#v%3AlistenOn
01:51:32 <ivanm> OK, so do this: "import Network (PortID(..), listenOn)"
01:51:36 <ivanm> oh, that won't work
01:51:39 <ivanm> since it's IO
01:52:12 <ivanm> oh, forget that last bit
01:52:15 * ivanm facepalms
01:52:20 <mbuf> ivanm, ok
01:56:01 <mbuf> let me give the big picture; I want to return the message sent by the sender to 14400 port; the following code works: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7712#a7712
01:56:28 <quicksilver> mbuf: don't use "Socket"
01:56:35 <mbuf> whatever is written to the 'writer' 14400 can be read by the 'reader' at 14401; but, I also want to send the string back to 14400
01:56:36 <quicksilver> unless you really really want to.
01:56:42 <mbuf> quicksilver, i see;
01:56:47 <quicksilver> are you trying to do UDP or TCP?
01:56:54 <mbuf> quicksilver, TCP
01:56:59 <quicksilver> right. Don't use Socket.
01:57:03 <quicksilver> Socket is the low-level interface.
01:57:08 <quicksilver> use the Handle-based interface
01:57:45 <mbuf> quicksilver, in the handle interface I can set ReadWriteMode; just not sure how to convert that code to handle-based interface
01:57:45 <quicksilver> ok, that's not *quite* true.
01:57:54 <quicksilver> readwritemode is the default
01:57:59 <quicksilver> there is no need to set anything.
01:58:14 <quicksilver> you do need to use Socket to call listenOn, it's true.
01:58:23 <quicksilver> but then you shuold just call 'accept' and after than you have a Handle.
01:58:27 <quicksilver> the Handle will be two-way.
01:58:31 <mbuf> quicksilver, i see;
01:59:08 <quicksilver> what I should have said is "don't use Network.Socket, just use the high-level functions in Network".
01:59:17 <mbuf> quicksilver, i see;
01:59:43 <quicksilver> generally you will need two threads per Handle
01:59:48 <quicksilver> one for reading, one for writing
01:59:56 <quicksilver> otherwise they risk blocking each other.
02:01:36 <mbuf> quicksilver, in 'writer socket writeMsg', in do, if I give something like 'hPutStr hdl $ (head $ words msg) ++ " ACK\r\n"', it doesn't get written to the client that wrote to 14400
02:03:45 <quicksilver> did you hFlush?
02:05:32 <mbuf> quicksilver, this is the updated code, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7712#a7713 ;
02:05:37 <mbuf> quicksilver, no didn't hFlush;
02:06:07 <quicksilver> well if you don't hFlush you won't see anything
02:06:13 <quicksilver> IO is buffered by default on unix-like systems.
02:06:19 <quicksilver> you could turn buffering off.
02:06:23 <quicksilver> (hSetBuffering)
02:06:46 <quicksilver> what is your client code, though?
02:06:52 <quicksilver> test using telnet as the client, perhaps.
02:06:59 <mbuf> quicksilver, using 'telnet localhost 14400'
02:07:07 <mbuf> quicksilver, reader will be 'telnet localhost 14401'
02:07:26 <quicksilver> good.
02:07:26 <mbuf> quicksilver, if I type in the opened session at 14400, it should return something to the client and the reader listening on 14401
02:07:38 <quicksilver> well add some hFlushes or turn off buffering.
02:07:45 <mbuf> quicksilver, ok
02:08:09 <quicksilver> also, your reader dups the channel every time through the loop
02:08:15 <quicksilver> that sounds like a mistake.
02:09:02 <mbuf> quicksilver, I want the reader to repeat it
02:10:15 <quicksilver> you don't want to call dupChan each time through the loop?
02:10:19 <quicksilver> do you know what dupChan is?
02:10:23 <quicksilver> it duplicates the Channel.
02:10:30 <quicksilver> I don't think you want to do that every time through the loop.
02:10:39 <quicksilver> you might want to duplicate it for each reader, if you have many, sure.
02:10:45 <mbuf> quicksilver, I set 'hSetBuffering hdl LineBuffering' and 'hPutStr hdl' works now!
02:10:50 <quicksilver> good
02:10:51 <mbuf> quicksilver, i see
02:10:54 <mbuf> quicksilver, thanks for your help!
02:12:05 <LoverCollapse> Enter text here... hello
02:12:11 <LoverCollapse> im new here
02:15:03 <blueonyx> > "haha\nha"
02:15:04 <lambdabot>   "haha\nha"
02:15:46 <blueonyx> which function convert "haha\nha" -> "\"haha\\nha\""?
02:15:52 <blueonyx> *can
02:17:16 <doserj> > show "haha\nha"
02:17:17 <lambdabot>   "\"haha\\nha\""
02:18:19 <blueonyx> omg, thanks
02:49:00 <mmorrow> preflex: seen mauke
02:49:00 <preflex>  mauke was last seen on ##c 3 hours, 8 minutes and 55 seconds ago, saying: that last restriction makes j = j + 1 valid
03:01:18 * mmorrow tries to keep up with the discussion
03:06:03 <dolio> It's bangin' in here.
03:06:10 <hackagebot> AERN-Real 0.10.0.2 - arbitrary precision interval arithmetic for approximating exact real numbers (MichalKonecny)
03:06:10 <hackagebot> AERN-RnToRm 0.5.0.1 - polynomial function enclosures (PFEs) approximating exact real functions (MichalKonecny)
03:07:10 <hackagebot> AERN-RnToRm-Plot 0.2.0.2 - GL plotting of polynomial function enclosures (PFEs) (MichalKonecny)
03:07:10 <hackagebot> AERN-Net 0.2.1.1 - Compositional lazy dataflow networks for exact real number computation (MichalKonecny)
03:21:04 <inad922> hello
03:21:32 <inad922> Could someone tell me if there is a standard way in haskell to do this -> http://pastebin.com/d2d40619d ?
03:21:58 <dibblego> inad922, zip
03:22:05 <dibblego> er zipWith
03:22:14 <inad922> thanks dibblego
03:22:46 <Yrogirg> Hello! I've started to write a GUI program with Gtk2Hs. I want to make it available in several languages (2). How do I do it? Any tutorials/books?
03:22:59 <dibblego> @type zipWith
03:23:00 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
03:23:39 <inad922> thanks Ive found it on the zvon reference page
03:24:12 <ivanm> has anyone managed to build the docs for pandoc?
03:24:24 <ivanm> for me, haddock just hangs without seeming to do anything... >_>
03:24:28 <inad922> Is there any standard way to extend this to arbitrary number of arguments? So something like zipWith*
03:24:53 <dibblego> inad922, using the ZipList instance of Applicative
03:25:23 <mmorrow> Yrogirg: you mean real languages?
03:25:58 <Yrogirg> mmorrow: yes, English and Russian gui's
03:26:49 <mmorrow> Yrogirg: (i'm not sure, but thought that that needed clarifying so maybe someone else could help :)
03:26:52 <inad922> thanks again dibblego
03:32:47 <Yrogirg> mmorrow: I don't understand you. I just want to store translated strings in .po files just like lots of programs do. But I don't know how exactly organise this. I want to use glade for gui drawing and poedit for easy translation, but I failed to find any tutorials on creating localisable programs in haskell.
03:33:46 <ivanm> if haddock takes a long time to build docs for a package, does that mean there's something wrong?
03:38:33 <Twey> Yrogirg: http://www.haskell.org/haskellwiki/Internationalization_of_Haskell_programs
03:47:09 <ivanm> Twey: that looks like it only translates on the level of words...
03:47:31 <ivanm> which IMHO probably doesn't work that well for anything more complex than "Hello World"...
03:47:38 <Twey> Ha?
03:47:48 <ivanm> Twey: the internationalization link
03:47:50 <Twey> It translates whole strings
03:48:02 <ivanm> if I understood what it did properly, it just translates each word
03:48:06 <Twey> You didn't :)
03:48:11 <ivanm> rather than making sure the sentence still makes grammatical sense
03:48:13 <ivanm> ahhh, OK
03:48:15 * ivanm reads again
03:48:29 <Twey> It translates the whole string
03:48:42 <ray> yeah that is very much not what it does
03:49:17 <dolio> It uses English strings as keys, with associated other-language values.
03:49:35 <ray> here is what's "fun": internationalizing a c++ program that uses those stupid << things
03:49:55 <Zao> ray: Thank the heavens for Boost.Format.
03:50:26 <ivanm> dolio: so does it always produce grammatically correct internationalised content, or just direct word translations?
03:50:31 <dolio> Yikes, unsafePerformIO.
03:50:34 <ray> well, curse the hells that something like that has a reason to exist too
03:50:36 <ray> but yeah
03:50:52 <dolio> ivanm: You manually create a file with all the relevant translations.
03:50:54 <ivanm> dolio: yeah :s
03:50:57 <dolio> As far as I can tell.
03:51:12 <ivanm> dolio: of the entire String?
03:51:23 <dolio> Yeah.
03:51:27 <ivanm> ahhh
03:51:41 <dolio> That's how people really internationalize programs, as far as I know.
03:51:55 <ivanm> I recall reading something once about internationalisation of PDA apps; the problem there is screen real estate :s
03:51:57 <dolio> I doubt there's any other way to get good translations, currently.
03:52:01 <ivanm> (note this was ~5 years ago...)
03:52:04 <ivanm> dolio: yes;
03:52:15 <ivanm> I misunderstood what the magic '_' function did ;-)
03:52:20 <Cale> It seems like it would be awkward to force the translations to keep the interpolated parameters in the same order in general.
03:52:45 <Cale> I think perhaps a more sophisticated kind of interpolation than printf might work out a little better.
03:53:04 <ivanm> Cale: yeah
03:53:29 <ivanm> though how would you do it? ;-)
03:53:48 <ray> name your format specifiers or something
03:55:19 <ivanm> ray: the order they get passed to printf might change
03:55:34 <ray> so name them
03:55:36 <ivanm> e.g. in language Foo, you might say "%s %d"; in language bar you might say "%d %s"
03:55:53 <Cale> Perhaps use an interpolator which takes a template and a Map String String
03:55:56 <ray> key them might be a better word
03:55:59 <ivanm> printf (translate "%s %d") string number <-- this mightn't work if using Bar
03:56:23 <dolio> You'd probably want to translate the string with the %d format specifiers in it.
03:56:25 <ivanm> Cale: even better: ensure that your translated text is hard-coded and doesn't have any user-based stuff ;-)
03:56:36 <ivanm> s/user/runtime
03:56:44 <ivanm> (or else have only one runtime value if you absolutely have to)
03:57:42 <Cale> Well... in general, I'm not sure if it can be avoided. I suppose in most applications it wouldn't be too hard.
03:57:57 <ivanm> yeah
04:03:07 <ray> cale: or an existential, because you can format more than just strings
04:17:50 <doserj> o
04:17:54 <doserj> ups
04:47:07 <mmorrow> rage! love tracking down "Maybe.fromJust: Nothing" errors with haddock
04:48:44 <dubhrosa> can anyone point me at a Haskell implementation of the algorithms in the Numerical Recipes book?
04:56:40 <Cale> dubhrosa: all of them?
04:57:01 <Cale> dubhrosa: I'm not sure such a project exists...
04:58:25 <Cale> dubhrosa: It does seem like an interesting thing to do.
04:59:26 <mmorrow> dcoutts_: ping
05:00:21 <mmorrow> dcoutts_: (re: how pandoc deals with inline html.. i think it translates the html into markdown, but i'm not positive yet)
05:04:04 <mmorrow> dcoutts_: (err, maybe not i'm not sure (it has this ability, but i'm not sure if it does this  automatically) (and not that this is even really relavant to anything now that i think about it :)
05:06:35 <dubhrosa> Yes, I'm learning Haskell, and thought it might be a nice project
05:07:52 <dubhrosa> or, if it already existed, a good way of learning how to do numerical stuff would be to read the code.
05:30:16 <ivanm> mmorrow: from what I've looked at pandoc, it converts everything into its internal state, and then converts it to an output state
05:30:25 <ivanm> but the internal state is very influenced by markdown
05:32:41 <mmorrow> ivanm: oh nice, that's even better
05:33:25 <ivanm> mmorrow: I use pandoc in my graphalyze lib; I'm thinking of rewriting its usage to use a pretty-printer style interface
05:35:42 <abbe> Igloo_, hi
05:36:44 <blueonyx> > catch (head []) (\_ -> putStrLn "haha")
05:36:45 <lambdabot>   <IO ()>
05:37:02 <blueonyx> > catch (head []) (\_ -> return "haha")
05:37:04 <lambdabot>   <IO [Char]>
05:37:36 <ivanm> mmorrow: the only thing is, neither of the pretty-printers have a "heading" or "title" attribute, so I'm not quite sure how I'm going to put that in... maybe have section :: Doc -> Doc -> Doc ...
05:38:39 <blueonyx> @src head
05:38:40 <lambdabot> head (x:_) = x
05:38:40 <lambdabot> head []    = undefined
05:39:38 <blueonyx> why does gcatch handle exceptions thrown with 'error' and catch does not? :(
05:40:13 <ivanm> @type catch
05:40:15 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
05:40:18 <ivanm> @hoogle gcatch
05:40:18 <lambdabot> No results found
05:40:27 <ivanm> blueonyx: never heard of gcatch
05:40:37 <ivanm> but my guess is that catch is not designed to ;-)
05:40:53 <blueonyx> gcatch cathes in any monad not just the IO one
05:41:05 <ivanm> blueonyx: error == unfixeable error, end of the world, etc.; exception == oops, you did something you're not meant to, you should fix this
05:41:12 <blueonyx> GHC.   gcatch  :: ( ExceptionMonad m, Exception e) => m a -> (e -> m a) -> m a
05:41:13 <ivanm> blueonyx: where is it found?
05:41:21 <ivanm> ahhh... it's an internal GHC implementation
05:41:23 <blueonyx> http://www.holumbus.org/hayoo/hayoo.html?query=gcatch
05:41:28 <BONUS> :t catchError
05:41:30 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
05:41:31 <ivanm> blueonyx: catch follows spec; gcatch probably shouldn't be used
05:41:44 <ivanm> as its an internal function that isn't stable
05:41:52 <ivanm> (as in it changes from release to release)
05:42:02 <ivanm> blueonyx: why do you want to catch an error?
05:43:16 <blueonyx> because 'error "haha"' is the easiest way i found to throw an exception with a simple String :/
05:43:28 <ivanm> blueonyx: well, you shouldn't ;-)
05:43:45 <Deewiant> ioError . userError $ "haha"
05:43:47 <ivanm> as I said before, error is meant more for end-of-the-world style problems
05:43:52 <ivanm> @type userError
05:43:53 <lambdabot> String -> IOError
05:43:58 <ivanm> @type ioError
05:43:59 <lambdabot> forall a. IOError -> IO a
05:44:24 <blueonyx> furthermore i has to make sure that all my output is valid JSON :/
05:44:32 <ivanm> Deewiant: though by the sounds of things, blueonyx isn't doing it in IO
05:44:45 <blueonyx> ivanm: i am
05:44:55 <ivanm> oh
05:44:56 <Deewiant> Throwing from pure code isn't nice
05:44:57 <ivanm> *shrug*
05:45:15 <ivanm> blueonyx: errors/exceptions aren't meant to be valid output ;-)
05:45:16 <Deewiant> Or rather, from code that returns a type that doesn't indicate that it might throw
05:46:01 <ivanm> blueonyx: is there any reason for using an error/exception over a Maybe/Either String monad value?
05:46:43 <blueonyx> the GHC package throws SourceErrors and stuff
05:46:54 <Gwern-away> just because they do it...
05:49:50 <ivanm> blueonyx: that's internal implementation stuff of the compiler
05:49:58 <ivanm> it isn't supported by anything except GHC-6.10.*
05:50:06 <ivanm> and even then it might change from version to version
05:50:18 <blueonyx> yea, i get haskell code as string from stdio
05:50:52 <blueonyx> http://www.haskell.org/haskellwiki/Error, snd paragraph is my case, but there is no solution linked/mentioned :/
05:51:23 <ivanm> blueonyx: use an exception
05:51:41 <ivanm> unless you actually are implementing a server and want soft-restart capabilities
05:51:49 <ivanm> (which IIUC is what that paragraph refers to)
05:52:11 <blueonyx> i am implementing a server and want soft-restart capabilities :)
05:52:23 <ivanm> in that case...
05:52:25 * ivanm has no idea
05:52:37 <ivanm> I'd still be tempted to use an exception
05:52:58 <ivanm> IIUC, the error bit is meant to be from the server running, not from generational bits
05:53:51 <blueonyx> i get source code, compile and run it. if compiling fails i have to catch these errors :/
05:54:44 <ivanm> hmmm...
05:54:45 <ivanm> *shrug*
06:01:53 <blueonyx> okay, i need ghandle, but then, what does http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3115#a3115 mean?
06:02:04 <blueonyx> or gcatch
06:04:21 <blueonyx> ah e::SomeException helps
06:04:24 <ivanm> blueonyx: see the documentation in the exceptions module
06:04:36 <blueonyx> thanks everyone
06:05:18 <dcoutts_> mmorrow: pong
06:05:29 <ivanm> blueonyx: does this look relevant to you? http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
06:06:28 <mmorrow> dcoutts_: hey, i'm just writing something in markdown and was reading the manual and saw that pandoc can convert html to markdown... which reminded me about the discussion a few days ago
06:06:50 <mmorrow> so i thought i'd mention it
06:07:20 <dcoutts_> mmorrow: though iirc, the pandoc AST has an explicit representation of html snippets
06:07:31 <ivanm> dcoutts_: yeah, I think it does
06:07:33 <mmorrow> dcoutts_: ah i see
06:07:39 <ivanm> since you can embed HTML in markdown
06:08:25 <mmorrow> ivanm: the discussion was about what pandoc does with inline html when the target isn't html,
06:08:28 <mmorrow> s/,//
06:08:42 <dcoutts_> mmorrow: since the main point would be for html bits that you cannot represent in markdown
06:08:56 <ivanm> mmorrow: ahhh
06:09:18 <mmorrow> dcoutts_: makes sense
06:09:23 <blueonyx> ivanm: maybe, but i dont get monads and their transformers yet
06:09:47 <ivanm> blueonyx: from the sounds of what you're doing, I think you should try to understand monads first ;-)
06:10:02 <ivanm> mmorrow, dcoutts_: are you discussing a haddock' or something?
06:10:38 <dcoutts_> ivanm: the issue of the markup format
06:10:45 <ivanm> *nod*
06:10:52 <ivanm> yeah, haddock's markup format is rather limiting
06:10:59 * ivanm wants bold markup, dammit!
06:12:32 <mmorrow> ivanm: conal suggested that haddock use markdown for all markup, via pandoc, and then the issues were: what about inline html (target isn't necessarily html)? the markdown would also have to be restricted given the context it appears in (e.g. no document headers/whatever in function description). etc
06:15:27 <ivanm> mmorrow: yeah, I probably wouldn't use pandoc directly
06:15:46 <ivanm> maybe fork parts of it off, unless conal wants alternate output formats
06:15:49 <mmorrow> ivanm: so then you'd just re-implement it?
06:15:58 <ivanm> probably
06:16:03 <mmorrow> ooh, it's also gpl too iirc
06:16:10 <ivanm> it is
06:16:15 <ivanm> IIRC, pandoc isn't that great at generating anything except HTML
06:16:16 <mmorrow> which haddock probably would have a problem with?
06:16:31 <ivanm> (that is, it's LaTeX output isn't that great; then again, you're limited by what markdown lets you represent)
06:16:34 <ivanm> mmorrow: I think so
06:16:34 <mmorrow> ivanm: i'm using it for latex/texi atm and it's pretty decent
06:16:43 <ivanm> haddock is BSD3
06:16:44 <mmorrow> yeah, it is limited though
06:16:51 <ivanm> texi?
06:16:55 <mmorrow> (what you can rep in markdown)
06:17:12 <saml> let's write this ultimate text transformation utility
06:17:25 <mmorrow> ivanm: http://johnmacfarlane.net/pandoc/example19.pdf
06:17:29 <ivanm> mmorrow: thing is, if you make it more complicated then you've just re-implemented latex/html
06:18:05 <ivanm> what is texi though?
06:18:18 <ivanm> markdown2pdf is just pdflatex run on latex output of pandoc IIRC
06:18:25 <mmorrow> ivanm: right, but the main appeal of this whole thing i think is that you can write something in a single simple format (markdown) and have a choice of output format
06:18:28 <ivanm> texi == texinfo ?
06:18:40 <ivanm> mmorrow: do we necessarily need/want multiple output formats?
06:18:46 <mmorrow> (and you sacrifice the full range of ability of any one format for the convenience)
06:18:56 <ivanm> then again, an all-in-one pdf reference might be nice at times (for printing, downloading, etc.)
06:18:58 <mmorrow> ivanm: yeah, texinfo
06:19:26 <abbe> hi ivanm
06:19:32 <abbe> hi Igloo
06:19:58 <ivanm> hey abbe
06:20:54 <ivanm> mmorrow: then again, is there any reason haddock can't be gpl and use pandoc?
06:21:01 <ivanm> after all, it's a stand-alone app
06:21:18 <mmorrow> it's included with ghc though (dunno the implications of this)
06:21:22 <ivanm> it _might_ have consequences for cabal{,-install} in that they call haddock, but that's about it AFAIK
06:21:28 <ivanm> mmorrow: true...
06:21:54 <ivanm> mmorrow: included == bundled ?
06:22:04 <ivanm> if so, that's a distribution problem rather than an implementation one
06:22:26 <ivanm> doesn't haddock come with ghc because it uses its parser atm?
06:22:50 <etpace> Can anyone explain what amortization is? I know what amortized analysis is, but I'm unsure why that wouldn't be (thought to be) incompatable with persistance
06:23:01 <pozic> Pandoc is not worth discussion until all the bugs are fixed.
06:23:29 <mmorrow> ivanm: hmm, i guess it's not actually (i thought it was in ghc/utils/
06:23:30 <mmorrow> )
06:23:31 <pozic> etpace: why would it be incompatible?
06:23:35 <pozic> etpace: it is not.
06:23:39 <ivanm> pozic: which bugs?
06:23:50 <pozic> ivanm: are you an active user of Pandoc?
06:23:52 <ivanm> mmorrow: it comes with ghc because cabal needs it and ghc uses cabal...
06:23:57 <ivanm> pozic: so-so
06:24:05 <etpace> "Until this research, it was widely believed that amortization
06:24:09 <etpace> was incompatible with persistence"
06:24:13 <ivanm> my graphalyze library used pandoc; and I'm going to be re-writing that bit of it
06:24:19 <pozic> etpace: who said that?
06:24:21 <etpace> I just don't really understand the use of amortization there
06:24:28 <etpace> as well as "amortized data structures"
06:24:30 <ivanm> isn't amortization to do with averaging of complexity?
06:24:35 <etpace> it's part of the introduction to functional data structures
06:24:36 <ivanm> if so, what does it have to do with persistance?
06:24:43 <etpace> yeah that's what I'm confused about
06:24:45 <pozic> etpace: written by who?
06:24:52 <pozic> etpace: I would say it is completely false.
06:24:53 <ivanm> etpace: amortized run/space costs I'm guessing (for data structures)
06:24:54 <etpace> Chris Okasaki
06:25:01 <ivanm> in that case, I doubt it's false
06:25:03 <ivanm> ;-)
06:25:09 <pozic> etpace: well, you should ask him where he got those ideas.
06:25:29 <pozic> etpace: many people did more advanced things than Okasaki.
06:25:35 <ivanm> etpace: I guess he means that people didn't think you could have data structures that are only good in an average sense without having impurity
06:25:40 <ivanm> pozic: :o
06:25:52 <pozic> I still do not understand why everyone points to Okasaki.
06:26:09 <pozic> Sure, he did his PhD on the topic, IIRC.
06:26:19 <pozic> And he wrote a book with the word functional in it.
06:26:34 <pozic> That doesn't mean he is the founder or anything like that.
06:26:36 <ivanm> because it is a pretty good work on functional data structures?
06:26:36 <etpace> So "amortized functional data structures" just refers to the amortized run/space costs of said data structures, not special versions or something
06:26:45 <ivanm> etpace: yeah, IIRC
06:26:48 <pozic> Nor that he wrote the most complicated data structures or solved a new problem.
06:26:52 <ivanm> it's been a while since I read okasaki's book
06:27:03 <etpace> I'll see if it comes up again and causes confusion
06:27:07 <pozic> I have never seen a data structure described by Okasaki that solved an open problem.
06:27:26 <ivanm> pozic: isn't it more that he categorised, etc. functional data structures?
06:27:31 <ivanm> and analysed them
06:27:48 <ivanm> rather than developing that much new himself (that is, he didn't develop new data structures)
06:27:58 <pozic> ivanm: doing a survey is not worthy of a PhD.
06:28:02 <pozic> ivanm: imo
06:28:11 <ivanm> pozic: *shrug*
06:28:16 <quicksilver> it is not, and okasaki woudln't have got one if that is all he had done.
06:28:18 <ivanm> maybe back then it was a bigger deal than it is now?
06:29:06 <pozic> I think he just noted that you could write some old data structures in a less powerful language.
06:29:20 <ivanm> pozic: "less powerful"?
06:29:21 <quicksilver> pozic: have you read his PhD?
06:29:35 <pozic> quicksilver: I did a few years ago.
06:29:39 <ivanm> and they might have been old, but they're still useful...
06:29:47 <pozic> quicksilver: I didn't find anything new, at least.
06:29:47 <quicksilver> then you appear to have forgotten what you read.
06:29:54 <pozic> quicksilver: that might be the case.
06:30:15 * mmorrow chuckles at pozic's flaimbait word choices :)
06:30:20 <quicksilver> at best, you're misremembering while at worse you're trolling.
06:30:25 <quicksilver> either way, please stop.
06:30:26 <ivanm> or else you already knew it from having already read texts based on okasaki's...
06:30:48 <jfoutz> i think restoring from a persisted version generally results in a unique state... where doing a bunch of operations can result in any of a bunch of different states, ammortization takes advantage of doing extra work now for a big payoff later, or putting off work for speed now... most of those bonuses depend on internal structure
06:32:23 <jfoutz> like a persisted/restored queue always having all it's elements in the front list, even though you may have already paid the cost to move them to the back list.
06:33:37 <pozic> quicksilver: what were the "new" things in his thesis? I looked at it again, and I come to the same conclusion.
06:33:52 <pozic> So, in fact there is nothing wrong with my memory.
06:33:57 <quicksilver> The complexity analyses were new; or most of them were.
06:34:09 <quicksilver> and I believe that some of the concrete structures were new, although I couldn't say which.
06:34:18 <quicksilver> I don't remember the state of the art as of 1996 that clearly.
06:35:06 <pozic> Clearly different people have different feelings regarding this.
06:36:53 <quicksilver> I note as an aside that it seems unlikely that CMU, a very well respected school of CS, would award a PhD for something which contains no novel contribution.
06:36:58 <ivanm> as I said, it was probably more the categorisation/analysis that was new
06:37:34 <hackagebot> control-monad-queue 0.1 - Reusable corecursive queues, via continuations. (LeonSmith)
06:37:51 <pozic> quicksilver: I know at least one other well respected institute which did exactly that, also in the context of functional programming.
06:38:03 <rocketman> I though PhD is just about doing some good reseach, you don't have to innovate
06:38:10 <pozic> It is simply not possible for everyone to come up with ground breaking stuff.
06:38:36 <rocketman> I mean like figuring out stuff yourself, rather than just sitting in class paying attention
06:38:43 <ivanm> rocketman: which uni on which topic?
06:38:44 <quicksilver> rocketman: novelty is a requirement on the rules of all PhD programs I have examined.
06:38:51 <ivanm> rocketman: you do have to come up with something new
06:38:52 <Axman6> i remember when i was a kid and i found out what you had to do to become a PhD. i thought i'd better get in quick before all the good topics were taken :P
06:38:59 <ivanm> Axman6: heh
06:39:03 <ivanm> yeah, seems that way sometimes
06:39:31 <Axman6> like, it seemed to me there must be so many people doing them, they'd soon have done everything
06:39:44 <Axman6> and... humanity stops learning...
06:39:50 <pozic> I think that in CS human creativity is getting less important and it is more about who has the biggest machine.
06:39:51 <lpsmith> pozic:  most of the data structures were available in imperative language,  but Okasaki's thesis was a significant advancement in the world of persistent, purely functional structures.
06:39:56 <quicksilver> "form a distinct contribution to the knowledge of the subject and afford
06:39:56 <quicksilver> evidence of originality by the discovery of new facts and/or by the exercise of
06:39:59 <quicksilver> independent critical power"
06:40:03 <quicksilver> (university of london)
06:40:04 <ivanm> Axman6: that's what physicists thought at the turn of the 20th century
06:40:16 <ivanm> and then that damn einstein guy invents quantum physics...
06:40:21 <Axman6> and what's happened since then? nothing
06:40:28 <pozic> lpsmith: can you name one non-trivial translation from an imperative data structure to a functional one?
06:40:31 <quicksilver> pozic: none of the CS I have ever done has had anything to do with who had the biggest machine.
06:40:38 <Axman6> quarks are just a phase
06:40:49 * Axman6 notes how close that is to being a nice pun
06:40:54 <ivanm> pozic: ummm, in most cases what does CS have to do with computing power?
06:41:00 <pozic> quicksilver: neither for me, I was saying something about the future.
06:41:03 <ivanm> Axman6: heh
06:41:14 <lpsmith> priority queues are not easily translated to functional languages.
06:41:19 <Axman6> pozic: linked list?
06:41:22 <jfoutz> pozic: a fifo queue
06:41:33 <jfoutz> pozic: a doubly linked list
06:41:39 <lpsmith> I think Okasaki's random-access lists were novel
06:41:41 <Axman6> wait, misunderstood the question
06:42:26 <lpsmith> Okasaki also came up with real-time persistent queues that were considerably simpler than previous implementations
06:43:36 <lpsmith> Union-find is an imperative data structure that doesn't translate well to functional languages
06:43:44 <lpsmith> Sieve of Eratosthenes.
06:43:57 <lpsmith> err,  Sieve of Eratosthenes is another
06:44:51 <pozic> lpsmith: by redefining what real-time means to most people.
06:44:55 <lpsmith> Honestly,  moving from imperative data structures to purely functional,  you are almost back at square one
06:45:21 <lpsmith> and how did Okasaki redefine real-time?
06:46:10 <pozic> lpsmith: AFAIK, these languages still assume GC systems. So, saying something is O(1) is an approximation.
06:47:25 <jfoutz> pozic: how exactly do you say something in big O notation isn't an approximation?
06:47:32 <pozic> Apparently, "Real-time queue operations in pure Lisp" redefined what real-time was.
06:47:46 <pozic> It has a nice ring to it, I will admit that.
06:48:06 <quicksilver> well, the GC problem is soluble in principle.
06:48:18 <quicksilver> the O(1) operation obviously only allocates bounded space.
06:48:27 <quicksilver> you can arrange for that bounded space to always be available.
06:48:34 <quicksilver> and you can then never need to run a GC during the operation.
06:48:47 <pozic> If you have a real-time system you can say exactly within how many time some operation or sequence of operations will work.
06:49:01 <mapreduce> @get-shapr
06:49:01 <lambdabot> shapr!!
06:49:13 <mapreduce> I see the bot is quite minimal.
06:49:35 <pozic> You don't say to whatever nuclear reactor exploitant "Oh, well, if the GC works fast enough, it should be about 20 ms".
06:49:37 <lpsmith> pozic:  the piece in the mutator is constant time;  it's very much relative to the language
06:49:42 <jfoutz> pozac ok, explain how long it will take malloc to find a free region of size n?
06:49:45 <pozic> There is either a number or there isn't.
06:50:16 <pozic> jfoutz: it is not my job to tell that.
06:50:54 <jfoutz> pozic, you can allocate the memory up front in C or in Lisp or in whatever. memory management is not O(1) in any language
06:51:08 <rocketman> the solution is obvious, don't use a computer to run a neuclear reactor
06:51:31 <rocketman> nuclear*
06:54:54 <pozic> jfoutz: if memory management overhead is not O(1), then the language implementation is a toy.
06:55:11 <jfoutz> pozic: malloc and free are not O(1)
06:55:21 <jfoutz> pozic: C is a toy?
06:55:23 <pozic> jfoutz: I am talking about amortized.
06:55:40 <quicksilver> pozic: amortized doesn't give you your real time guarantees.
06:55:44 <Axman6> malloc often doesn't do anything when you run it
06:55:46 <pozic> quicksilver: I know that.
06:55:52 <Axman6> though, i'm sure most of you already know that
06:55:58 <quicksilver> good GC is amortized O(1).
06:56:01 <rocketman> O(0)
06:56:01 <quicksilver> so what is your point?
06:56:17 <lpsmith> hahaha,  pozic, how long have you been doing FP?
06:56:34 <quicksilver> Axman6: at the very least it moves a pointer or counter. I don't think it can do nothing.
06:56:48 <pozic> lpsmith: out of arguments?
06:57:37 <lpsmith> no,  I'm not.  But you are demonstrating some general ignorance
06:57:53 <pozic> lpsmith: like what?
06:57:55 <Axman6> quicksilver: well, i terms of setting up the memory. it's got to do _something_ of course
06:58:23 <rocketman> lpsmith, I think he's trying to learn, he just phrases his questions in such a rude and obnoxious manner it's hard to tell
06:59:31 <pozic> rocketman: I was learning etpace that Okasaki is not the Origin.
06:59:51 <pozic> rocketman: I didn't learn anything new in this channel, since I got here.
06:59:53 <PeakerWork> jfoutz: MM can be O(1), use constant-sized-block freelists for everything, but then you don't have indexable dynamically sized blocks (but those are not that important most of the time)
07:00:02 <quicksilver> pozic: that's (a) arrogant and (b) not true.
07:00:08 <quicksilver> pozic: you have learnt stuff from me in particular.
07:00:15 <PeakerWork> jfoutz: Well, I guess if your allocation size is dynamic, it can be O(logN)
07:00:17 <quicksilver> and I certainly doubt you haven't also from others.
07:00:22 <pozic> quicksilver: yes, in the past, but in was referring to this session.
07:00:23 <Axman6> PeakerWork: your name isn't bulat by any chance is it?
07:00:40 <pozic> quicksilver: I*
07:00:48 <Axman6> uh, pozic, not PeakerWork
07:00:58 <rocketman> "your name isn't bulat" haha
07:01:22 <jfoutz> PeakerWork: i'm pretty sure that applies regardless of a malloc/free implementation or a fancy pants generational collector, right?
07:02:35 <jfoutz> PeakerWork: that is, even if i manage my memory by hand, if i don't know how much i need at startup time, i can't get O(1) allocation.
07:08:29 <pozic> jfoutz: O(1) amortized memory management is possible if reading and writing a single memory unit is O(1).
07:08:50 <lpsmith> pozic:  that's not real time ;-)
07:09:00 <pozic> lpsmith: I know that.
07:09:16 <rocketman> why must you say "I know that"
07:09:43 <pozic> rocketman: because otherwise I give people the illusion that they tell me something new.
07:09:53 <rocketman> that matters?
07:09:57 <pikhq> Oh, I can do O(1) allocation. malloc(INFINITY) ahoy!
07:10:04 <pozic> rocketman: probably not.
07:10:48 <Botje> my INFINITY can beat up your INFINITY
07:11:27 <jfoutz> pozic: the problem is the upper bound on runtime space. if you allocate n bytes, but require n+1 you must either, give up or reallocate. so, real time systems put an upper bound on memory a particular operation is allowed to use, like an 8k buffer for reading from disk. If you can say i will use at most x bytes, you don't need gc, you don't need malloc/free. if you can't put that bound on your operation, you don't get O(1) regardless of strate
07:12:03 <rocketman> what does all this O(n) theta(n) stuff mean for running programs on real computers?
07:12:29 <Zao> rocketman: It tells you about scaling expectations.
07:12:35 <lpsmith> rocketman:  it's a useful approximation
07:12:43 <pozic> Zao: I am pretty sure he knows that.
07:12:44 <lpsmith> Zao's answer is a bit more informative
07:12:48 <SamB> rocketman: will, if it's O(n^2) you don't want to run it with a big value of n ;-)
07:12:49 <Gabbie> As opposed to fake computers?
07:13:11 <SamB> Gabbie: well, I think he means as opposed to "in academic papers"
07:13:14 <etpace> But constants matter for a lot of programs, on real computers, right?
07:13:19 <rocketman> Gabbie, (theoretical models of computers)
07:13:42 <pozic> etpace: constants matter only to the users of computers.
07:14:21 <SamB> pozic: not quite!
07:14:31 <Axman6> SamB: can't think of many things you'd want to run with large n :P
07:14:34 <vorner> etpace: they matter, but O(1) with whatever constants are usually better than O(n!)
07:14:39 <rocketman> lpsmith, Zao,  but I think it's only meaningful when designing, I am not sure it has any use for after-the-fact analysis
07:14:39 <SamB> sometimes the programs crash if the constants are too high for the CPU
07:15:01 <SamB> rocketman: sure it does
07:15:49 <SamB> people often measure performance at different values of "n" and say "gee, that looks quadratic"
07:16:03 <SamB> and then they've got to debug it ...
07:16:07 <pozic> Axman6: your n is bigger than then n' people imagined 50 years ago.
07:16:36 <pozic> SamB: that's more like redesigning than debugging.
07:16:53 <SamB> pozic: not really
07:16:53 <pozic> the*
07:17:04 <SamB> these are complicated programs
07:17:17 <Axman6> it's a bug if you're after performance
07:17:34 <Axman6> of if you meant for the program to be logarithmic
07:18:19 <SamB> what they've got to do is first find a cause, then probably factor something out of a loop ...
07:18:24 <SamB> or something
07:19:49 <SamB> sometimes, this only results in it having a smaller quadratic coefficient ;-)
07:20:24 <SamB> but anyway, the program I was thinking of was bzr(1)
07:21:10 <lpsmith> mmm... slowsort.
07:21:37 <lpsmith> sort(xs,ys) :-  permutation(xs,ys),  issorted(ys).
07:22:11 <Axman6> isn't that bogosort?
07:22:26 <SamB> Axman6: why "bogo"
07:22:41 <Axman6> i've never done any formal study of sorting algos, but this is what i've been told is bogosort
07:22:44 <ray> because some nutcase called it that, but it's a bad sort
07:22:48 <Axman6> no idea, that's the name
07:22:53 <SamB> it is a bad sort ;-)
07:23:06 <harlekin> Is it possible to infer a Show class for a function? Like shoing the name of the function or name + types?
07:23:12 <lpsmith> Well, I dunno what it's called,   bogosort chooses permutations at random until it finds one that's sorted.
07:23:22 <SamB> I guess it's called bogosort because it doesn't so much sort as go one by one through all permutations of the input and check to see if they are sorted...
07:23:26 <ray> that's the name according to a nutcase
07:23:33 <SamB> lpsmith: that doesn't work at random!
07:23:59 <Axman6> http://en.wikipedia.org/wiki/Bogosort
07:24:01 <pozic> Bogosort is exactly what lpsmith says it is.
07:24:02 <lpsmith> That prolog-ish syntax is intended to determinstically choose permutations until it finds one that's sorted
07:24:02 <SamB> nondeterministic, maybe
07:24:03 <rocketman> permutationsort
07:24:10 <Raevel> harlekin: a function does not have a name
07:24:11 <Plouj> does anyone here do OpenGL programming? Which one do you prefer, the RawOpenGL binding or the HOpenGL one?
07:24:17 <ray> i have a better one
07:24:37 <SamB> ray: better name, or better OpenGL binding?
07:24:42 <ray> no, a better sort
07:24:43 <dschoepe> Plouj: reactive-fieldtrip is also an option
07:24:46 <ray> a worse sort i mean
07:24:50 <pikhq> I'm still fond of quantum bogosort.
07:25:02 <lpsmith> the expected running time of bogosort is comparable to permutation sort
07:25:05 <Plouj> which of the opengl libraries would be more suitable for interactive games?
07:25:15 <ray> load your array into memory, then wait until cosmic rays flip the right bits for it to be sorted
07:25:15 <Plouj> real-time interactive
07:25:20 <Axman6> pikhq: hmm, that would actually work wouldn't it..
07:25:23 <SamB> pikhq: do you mean quantum permutation sort ?
07:25:38 <SamB> pikhq: where you try all the permutations at ONCE?
07:25:45 <ray> yes
07:25:46 <pikhq> Plouj: The question is "which one do you like?"
07:25:49 <dschoepe> Plouj: I find reactive-fieldtrip quite nice to use, but it still has issues(no monad instance for Behavior)
07:26:01 <pikhq> SamB: Shuffle the list. Destroy the universe if the list is not sorted.
07:26:05 <Axman6> SamB: i can't wait for that day to come
07:26:38 <SamB> pikhq: that's highly impractical
07:27:03 <pikhq> SamB: That's the point.
07:27:04 <ray> i have a module with unsafeDestroyUniverse :: Void
07:27:20 <ray> trying to evaluate unsafeDestroyUniverse causes the universe to be destroyed
07:27:22 <Plouj> pikhq: well, I haven't used any of them (much) so I would like to know if I shouldn't bother with some because they are just not suitable for what I want to do.
07:27:43 <SamB> damn you, large hadron collider!
07:27:45 <ray> so it's semantically bottom
07:27:54 <ray> i think, i am not good with semantics
07:28:04 <pikhq> Plouj: They're both suitable, but HOpenGL is much nicer to use.
07:28:05 <SamB> I can't find the proper site saying how many times the world has been destroyed so far by evil masterminds!
07:28:14 <Axman6> > unsafeDestroyUniverse `seq` ()
07:28:16 <lambdabot>   Not in scope: `unsafeDestroyUniverse'
07:28:30 * Axman6 was slightly scared for a second there
07:28:49 <SamB> hmm,
07:28:50 <pikhq> > let unsafeDestroyUniverse = undefined in unsafeDestroyUniverse `seq` ()
07:28:51 <lambdabot>   * Exception: Prelude.undefined
07:28:59 <SamB> @go how to destroy the world
07:29:01 <lambdabot> http://qntm.org/destroy
07:29:01 <lambdabot> Title: How to destroy the Earth @ Things Of Interest
07:29:06 <SamB> okay, that works
07:29:12 <jfoutz> i think destroyUniverse is safe. if you evaluate it, you'll never know.
07:29:30 <ray> it has a side effect
07:29:38 <Deewiant> Not an observable one
07:29:39 <pikhq> No. destroyUniverse :: IO ()
07:29:40 <int-e> . o O ( safelyDestroyUniverse ?! )
07:29:40 <jfoutz> not that you can tell :)
07:29:43 <SamB> jfoutz: it should at least be in IO, though ;-)
07:29:43 <Axman6> Bozo sort is another sorting algorithm based on random numbers. If the list is not in order, it picks two items at random and swaps them, then checks to see if the list is sorted. The running time analysis of Bozo Sort is more difficult, but some estimates are found in H. Gruber's analysis of perversely awful randomized sorting algorithms.[1]
07:29:48 <Axman6> heh
07:29:55 <ray> safeDestroyUniverse :: IO Void?
07:30:30 <poe> atomically destroyUniverse
07:30:36 <SamB> ray: I wouldn't name it safeDestroyUniverse, but that's the type alright ;-)
07:30:45 <ray> it's type safe though
07:31:30 <SamB> anyway, if destroying *earth* is that hard, don't you think it might be a bit impractical to sort by destroying the universe if the list is not sorted?
07:31:55 <Axman6> so i found out how fork() works yesterday. mind = semi blown (because i did not expect that there would be anything that worked the way fork() does)
07:32:00 <pikhq> You only need to trick the universe into doing a devide by zero.
07:32:11 <SamB> Axman6: eh?
07:32:18 <pikhq> Axman6: What, you mean doing copy-on-write with the processes address space?
07:32:19 <SamB> Axman6: you mean how you use it?
07:32:38 <SamB> with the if on the return value to figure out if you're the parent or child?
07:33:17 <Axman6> well, how it works, in that you get an exact copy of the process calling it, with the only difference being that the two processes get differing return values from fork()
07:33:34 <pikhq> Right.
07:33:37 <SamB> Axman6: wait until you see vfork()!
07:33:42 <Axman6> >_<
07:33:50 <SamB> that'll really cook your noodle
07:34:10 <Axman6> see, i thought fork() would just launch another process, and maybe give you the pid of it
07:34:36 <ray> but then what would that process do?
07:34:53 <SamB> you must be thinking of spawn
07:34:59 <Axman6> yeah
07:35:05 <ray> if you launched a "codeless" process, it would have to just die
07:35:07 <pikhq> Axman6: That's implemented by fork() and then exec(), IIRC.
07:35:12 <Axman6> well, i'd never really heard of fork until yesterday
07:35:23 <Axman6> pikhq: yeah
07:35:23 <ray> yeah spawn is just fork and exec
07:35:32 <SamB> ray: not necessarily
07:35:41 <pikhq> Oh, right. Cygwin.
07:35:41 <SamB> it might be less than that
07:35:42 <Axman6> ray: well, i thought you'd give it a path to the program to run or something
07:35:52 <Axman6> which is what exec is
07:35:53 <Axman6> sort of
07:36:07 <SamB> yeah, if you think fork() is crazy wait until you see how it fails on Cygwin ;-)
07:36:14 <Axman6> heh
07:36:22 <Axman6> i don't plan on finding out any time soon ;)
07:36:28 <p_l> SamB: Cygwin implements fork() by doing some crazy shit with memory mapping
07:36:28 <ray> cygwin is.. yeah
07:36:30 <SamB> I say fails, because you'd never guess how it worked until you saw it fail
07:36:35 * Axman6 uses windows only as a wintendo
07:37:00 * ray uses luniax only as an irc client and web server
07:37:15 <SamB> luniax?
07:37:36 <pikhq> Okay, I just looked at the Cygwin fork.
07:37:44 <SamB> p_l: I've seen it fail, I know how it works ;-)
07:37:47 <pikhq> Holy *fuck* that's crazy.
07:37:52 <Axman6> link?
07:37:59 <Axman6> +explanation?
07:38:13 <pikhq> I... Is that implementing child processes *using POSIX threads*
07:38:37 <SamB> it attempts to create a new process running the same executable as the current process
07:38:37 <Axman6> i sure hope so
07:38:41 <ray> it's beautiful
07:38:49 <ray> they should have sent a poet
07:39:09 <SamB> then, if that works, it goes through and tries to load every DLL at the same place in memory as in the parent process ...
07:39:10 * p_l has fork() on windows but haven't checked how it works exactly
07:41:08 <Axman6> so when you run something in say bash, does it fork() it? or...
07:41:26 <pikhq> Spawns it.
07:41:46 <Axman6> duh, of course it doesn't fork it -_-
07:42:23 <pikhq> :(){ :|:& };: -- Now that, that forks it.
07:42:52 <Deewiant> Well, it would work just as well if it did a fork() followed by an exec
07:42:54 <Axman6> wtf is that? hungry monkey X-ray?
07:43:07 <Deewiant> That's a forkbomb
07:43:23 <SamB> whoa, apparantly someone destroyed the earth without me noticing!
07:43:24 <Deewiant> Defines a function called : which runs itself twice, then runs that
07:43:27 <Axman6> yeah, i figured that (i've seen a few, but never understood any)
07:43:29 <SamB> http://qntm.org/?destroy#sec2
07:43:35 <ray> the : is just for obfuscation
07:43:45 <pikhq> SamB: That was the LHC.
07:43:52 <ray> if you change all the :s to some sensible name suddenly it's not scary looking
07:44:07 <Axman6> Deewiant: ah i see, yeah that makes perfect sense :)
07:44:10 <pikhq> Axman6: They're all of the form main(){while(1)fork();}
07:44:36 <int-e> I prefer the version with extra spaces: : ( ) { : | : & } ; :
07:44:37 <Axman6> must find a system to test that on
07:44:55 <ray> any system
07:45:03 <ray> you do have sensible resource limits, of course
07:45:14 <ray> no system would be dumb enough to not set some by default
07:45:25 <int-e> ray: famous last words? :)
07:45:38 <Axman6> i'm not sure i'd trust OS X eough to do that
07:45:40 <Axman6> enough*
07:45:44 <ray> no, i'm just making a dig at every single uniax system out there
07:45:59 <ray> it's probably not a dig if it has such a wide range
07:46:02 <Axman6> could always do it i a vm...
07:46:14 <ray> could always set a hard process limit then do it
07:47:08 * Axman6 makes a small VM running arch, with no disk, and tests
07:47:25 <ray> well, overengineering can be fun too
07:47:36 <ray> but it does have its drawbacks
07:50:15 <Axman6> ha, looks like it's working
08:00:31 <pastah> "A chainsaw called 'catamorphism'"
08:00:48 * pastah is reading the morse code paper :)
08:01:02 <ray> chain banana
08:01:06 <pastah> haha
08:01:17 <Plouj> bah, reactive-fieldtrip uses glut....which is old and crappy
08:01:23 <Plouj> I'm all for SDL
08:01:38 <ray> well excuse me princess
08:02:38 <ray> oh, the other library is reactive-glut which you would probably like less :(
08:02:45 * Axman6 wonders what happened to the all knowing pozic
08:02:53 <dubhrosa> newbie question: how does haskell, and functional languages in general, cope with large, frequently updated data structures in a memory efficient manner?
08:02:54 <Plouj> plus it probably uses fixed-function OpenGL API
08:03:07 <rocketman> dubhrosa: good question :p
08:03:23 <Axman6> dubhrosa: cleaverly >_>
08:03:30 <PeakerWork> jfoutz: without having to support a fast realloc, OR without having to support O(1) indexing on realloc'd things, you can have O(1) allocation of static sizes, and O(logN) allocation of dynamic sizes
08:03:42 <PeakerWork> jfoutz: Using free lists for each 2^k size
08:03:42 <Axman6> cleverly eve
08:03:43 <Axman6> n
08:03:49 <PeakerWork> Axman6: no, my name is Eyal
08:04:02 <ray> cleaverly = using a cleaver to chop out inefficiency
08:04:16 <Axman6> what an interesting name, where's it from PeakerWork?
08:05:07 <PeakerWork> Axman6: Very common Israeli name
08:05:16 <Axman6> ah i see
08:05:18 <PeakerWork> Axman6: means "Strength" of something in Hebrew (but its an obscure/unknown meaning)
08:05:30 <Axman6> heh
08:05:39 <monochrom> dubhrosa: use tree-like data structures to ensure each update reconstructs only logarithmically many nodes.
08:09:36 <dubhrosa> monochrom: I'm not sure I understand you, is it like the graph's nodes are the leaf nodes of a tree and an update to the graph nodes translates into a localised update on a tree branch?
08:09:57 <monochrom> Yes.
08:10:27 <dubhrosa> is the tree constructed to suit the change or a-priori?
08:10:54 <monochrom> could be either
08:12:18 <dubhrosa> if it's a-priori then won't there be pathological cases where an update to 2 graph nodes will result in the root branch of the tree being dirtied (sorry if I'm not getting the obvious here...)
08:13:09 <SamB> dubhrosa: I thought the root would need replacing for *every* update!
08:13:29 <Axman6> indeed
08:13:55 <monochrom> This is why logarithmically many nodes are discarded and reconstructed.
08:13:58 <mmorrow> dubhrosa: IntMap/Map are what you would use for this if you're not using mutation
08:21:55 <mmorrow> dubhrosa: and in (Int)Maps, many of the values can be shared as well http://moonpatio.com/vacuum/gallery/sharing.png
08:23:52 <mmorrow> (the C# are char nodes)
08:24:12 <mmorrow> (which are machine ints)
08:24:20 <mmorrow> err, well
08:24:25 <mmorrow> data Char = C# Char#
08:24:33 <mmorrow> where Char# is 32bits
08:24:51 <SamB> > maxBound :: Char
08:24:52 <lambdabot>   '\1114111'
08:25:01 <Axman6> what's vacuum installed as? (is in :m +...)
08:25:03 <mmorrow> sizeOf (undefined::Char)
08:25:12 <mmorrow> Axman6: GHC.Vacuum
08:25:16 <Axman6> thanks
08:25:22 <SamB> > printf "0x%x" 1114111
08:25:23 <lambdabot>   Add a type signature
08:25:28 <SamB> > printf "0x%x" 1114111 :: String
08:25:29 <lambdabot>   "0x10ffff"
08:25:36 <mmorrow> Axman6: (i used this though for that "view" function: http://moonpatio.com/repos/vacuum-gl/)
08:25:54 <mmorrow> Axman6: there's another vacuum-opengl on hackage too
08:25:59 <mmorrow> (not by me)
08:26:06 <QP> Can I ask a quick question about good programming practice?
08:26:10 <Axman6> ok
08:26:14 <Axman6> QP: always
08:26:20 <QP> ok
08:27:04 <QP> i want to know, is it considered bad practice to use ioError and userError as a way of escaping from 'loops'?
08:27:22 <Botje> yes.
08:27:24 <QP> ie: have a function :: IO ()
08:27:31 <lysgaard> Where does one look for knowledge about using YI?
08:27:37 <dubhrosa> morrow: thanks, I'll take a longer look at this
08:27:43 <QP> ok, i had this suspicion... :-)
08:28:06 <QP> so what is the canonical idiom for that?
08:28:51 <Botje> you could just return () when there's nothing to be done
08:28:52 <mux> QP: as you would do with a pure function; you test for a condition, and don't recurse when it is met
08:29:15 <SamB> QP: or of course you could use ContT ...
08:29:24 <QP> ok... i guess
08:29:32 <QP> what's ContT?
08:29:39 <QP> Monad transformer...
08:29:48 <QP> but i've never seen Cont
08:29:48 <SamB> you don't want to do that unless mux's suggestion doesn't work out, trust me ;-)
08:29:53 <mmorrow> > runCont (callCC (\k -> forever (k 42))) id
08:29:55 <lambdabot>   42
08:30:22 <mmorrow> > runCont (callCC (\k -> let go = k 42 >> go in go)) id
08:30:24 <lambdabot>   42
08:30:37 <QP> whoooaa
08:31:00 <mmorrow> the "k" you get from callCC is similar to an exception conceptually
08:31:34 <lysgaard> Anybody using the YI editor?
08:31:37 <mmorrow> > runCont (do x <- callCC (\k -> k 42 >> return 999999999999); return (x+1)) id
08:31:38 <lambdabot>   43
08:31:54 <mmorrow> > runCont (do x <- callCC (\k -> k 42 >> k 999999999999); return (x+1)) id
08:31:56 <lambdabot>   43
08:32:05 <mmorrow> > runCont (do x <- callCC (\k -> return 42 >> return 999999999999); return (x+1)) id
08:32:06 <lambdabot>   1000000000000
08:32:19 <mmorrow> > runCont (do x <- callCC (\k -> return 42 >> k 999999999999); return (x+1)) id
08:32:20 <lambdabot>   1000000000000
08:32:24 <mmorrow> being the last case of that
08:32:48 <mmorrow> so if you call "k" as the last thing you do, it's just like "return"
08:33:21 <QP> I'm still not sure I understand what that is doing
08:33:46 <mmorrow> but you can also call it arbitrarily deep in the computation inside the function you pass callCC, and you can escape immediately and return from callCC as if the entire computation returned what you pass to "k"
08:34:15 <mmorrow> QP: understanding what exactly it's doing is really strange at first, but once you "see" it it's simple
08:34:28 <Axman6> mmorrow: hmm, your code doesn't like me, it's asking me for GLUT, OpenGL and vacuum >= 0.0.95, all of which i have installed
08:34:44 <mmorrow> hmm, what is the error?
08:34:56 <QP> so k is like: "escape with"?
08:35:05 <Axman6> Configuring vacuum-gl-0.0.2...
08:35:05 <Axman6> Setup.lhs: At least the following dependencies are missing:
08:35:05 <Axman6> GLUT -any, OpenGL -any, vacuum >=0.0.95
08:35:16 <mmorrow> (it also uses the graphviz C lib + pthreads (had to use pthreads to get around an unfortunate FILE* pipe thing))
08:35:23 <mmorrow> Axman6: hmm, weird
08:36:05 <mmorrow> Axman6: what it telling you that? cabal install, or runhaskell Setup.lhs ?
08:36:17 <Axman6> the latter
08:36:30 <Axman6> i missed the cable file...
08:36:43 <Axman6> ok, it's whinging about C libraries
08:36:45 <mmorrow> odd, lemme try to install it myself, maybe i broke it last time i pushed
08:36:49 <Axman6> (it = cabal)
08:37:11 <Axman6> ok, all good
08:37:12 <mmorrow> Axman6: ah, maybe you don't have graphviz-devel ?
08:37:17 <mmorrow> cool :)
08:37:25 <Axman6> i do, but needed to specify the location
08:37:31 <monochrom> I think Cont is unnecessary in most cases for merely "escape the loop". There is no loop, there is only recursion. Just don't recurse, and you already get out.
08:37:50 <Axman6> mmorrow: how do you use it?
08:37:57 <mmorrow> monochrom: yeah, i agree Cont is heavyweight for that
08:38:07 * Axman6 notices haddocks dir
08:38:08 <monochrom> f x = if x=0 then () else f (x-1)
08:38:15 <mmorrow> Axman6: view (let x = () in (x,x))
08:38:21 <monochrom> The then branch escapes. Just because it doesn't recurse.
08:38:40 <mmorrow> Axman6: the main interface is http://moonpatio.com/repos/vacuum-gl/haddocks/System-Vacuum-OpenGL.html
08:38:55 <mmorrow> Axman6: so that module is mainly for using it in ghci
08:39:04 <Axman6> :m +System.Vacuum.OpenGL says module `System.Vacuum.OpenGL' is not loaded
08:39:23 <mmorrow> Axman6: you can use "view" to view a vacuum-produced graph, or the other ones to view an arbitrary graph from wherever
08:39:28 <Axman6> and... bus error -_-
08:39:31 <mux> I've had this problem in the past when I was runnign ghci from within the same directory that holds the sources
08:39:40 <mmorrow> Axman6: what os are you on? osx?
08:39:42 <mux> it apparently tried to load the source files directly and failed
08:39:50 <Axman6> yeah, os x
08:39:55 <mux> then I changed the current directory and I was able to load the module
08:39:57 <mmorrow> Axman6: iirc freeglut doesn't work on osx, which that package makes essential use of :(
08:39:58 <Axman6> mmorrow: sounds about right
08:40:02 <PeakerWork> monochrom: what about using MaybeT?
08:40:09 <Axman6> i see
08:40:10 <PeakerWork> monochrom: to escape loops?
08:40:30 <mmorrow> Axman6: (it uses freeglut's extension that lets you not enter the mainLoop, and just poll for events)
08:40:47 <monochrom> Why do the people
08:40:51 <mmorrow> Axman6: dang, that's sucky that it doesn't work on osx
08:40:51 <monochrom> imagine a vain thing
08:41:30 <Axman6> Assertion failed: (bmfh.bfType == BMP_BF_TYPE), function readBMP, file c/bmp.c, line 205.
08:41:43 <Axman6> oh well
08:41:54 <Axman6> i can always get a vm working i guess
08:42:00 <Axman6> but it's time for sleep now. night all
08:42:01 <mmorrow> Axman6: arrrgh. yeah, that happened with thoughtpolice too. apparently the graphviz on osx doesn't produce 8bit .bmps
08:42:18 <mmorrow> Axman6: and that pkg's bmp reader only does that kind..
08:42:34 <mmorrow> Axman6: it works nicely on linux..
08:42:41 <mmorrow> Axman6: night, good luck :)
08:42:46 <Axman6> i'll try it on my thinkpad sometime
08:43:21 <mmorrow> Axman6: the other opengl package invokes graphviz with System.Process, so you may have more luck there
08:44:42 <Axman6> well, running the server caused a bus error too
08:44:47 <Axman6> anyway. sleep time
08:45:05 <mmorrow> Axman6: ooh, you can use this function though
08:45:07 <mmorrow> vacuumToFile :: FilePath -> GVFormat -> a -> IO ()
08:45:26 <mmorrow> "GVFormat" is a String giving any of the possible graphviz output formats
08:45:38 <Axman6> i see
08:45:40 <Axman6> how nice
08:45:44 <mmorrow> vacuumToFile "asdf.png" "png" [0..9]
08:46:01 <mmorrow> i know that definitely worked for thoughtpolice on osx
08:46:21 <mmorrow> (since it doesn't use the opengl part or the bmp reading part :)
08:46:31 <mmorrow> ooh, this too
08:46:33 <mmorrow> vacuumToByteString :: GVFormat -> a -> IO ByteString
08:46:40 <mmorrow> so you can get the raw data directly
08:47:14 <mmorrow> (the format depending on GCFormat... "png","bmp","pdf","dot","svg",...
08:47:32 <mmorrow> *GVFormat
08:48:15 <conal> quicksilver: ping
08:48:37 <Axman6> where's vacuumToFile?
08:48:44 <mmorrow> System.Vacuum.OpenGL.GLVacuum
08:48:57 <Deewiant> It's under OpenGL but goes to Graphviz?
08:49:04 <mmorrow> Axman6: (and vacuumToFile is equivalent to vacuumToByteString, then writing that ByteString to file...)
08:49:15 <Axman6> i see, how nice
08:49:23 <mmorrow> Deewiant: it ffi's to the graphviz C code
08:49:38 <Deewiant> Still doesn't have much to do with OpenGL
08:49:52 <mmorrow> Deewiant: um, so it's an opengl graph viewer :)
08:50:15 <Deewiant> Sure, but outputting a graphviz-rendered graph to file doesn't use OpenGL in any way :-P
08:50:21 <mmorrow> Deewiant: http://moonpatio.com/vacuum/gallery/sharing.png
08:50:25 <Axman6> mmorrow: oh damn, that's awesome
08:50:44 <Deewiant> If I wanted to output a vacuum graph to file I wouldn't look in a module called OpenGL :-P
08:51:01 <mmorrow> Deewiant: sure, but since it uses graphviz to get the image data which it then writes into graphics memory, it gets that functionality for free. so why not provide it.
08:51:33 <Deewiant> I'd provide it in a separate library or at least a separate module
08:51:34 <conal> Does anyone know to do 3D that works on os x and works under ghci without terminating ghci?
08:51:37 <mmorrow> Deewiant: yeah, that's true. i should split this pkg into the viewer part and the graphviz interfacing part.
08:52:06 <SamB> conal: is the latter possible ?
08:52:11 <Axman6> mmorrow: http://random.axman6.com/images/StringSet.png
08:52:12 <mmorrow> conal: i wish. it's really too bad that freeglut doesn't work on osx.
08:52:25 <mmorrow> Axman6: sweet!
08:52:37 <Axman6> had no idea such sharing existed :)
08:52:57 <Axman6> ok, sleep time! :P
08:53:04 <mmorrow> SamB: yeah, if you have freeglut
08:53:44 <mmorrow> SamB: via using "mainLoopEvent" instead of entering the "mainLoop"
08:54:00 <axzs> @pl \f xs -> and $ map f xs
08:54:00 <lambdabot> all
08:54:01 <mmorrow> then you can just forkIO a thread that sits on a Chan
08:54:58 <axzs> is it possible to force lambdabot not to use 'all'?
08:55:15 <Elly> why?
08:55:27 <axzs> i'm curious if all can be defined using and and map
08:55:33 <axzs> in pointless style
08:55:38 <doserj> @pl \f xs -> and_ $ map_ f xs
08:55:38 <lambdabot> (and_ .) . map_
08:55:42 <jmcarthur_work> @src all
08:55:42 <lambdabot> all p =  and . map p
08:55:54 <axzs> thanks
08:55:56 <jmcarthur_work> @@ @pl @src all
08:55:56 <lambdabot>  (line 1, column 1):
08:55:57 <lambdabot> unexpected end of input
08:55:57 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:56:08 <jmcarthur_work> @@ pl src all
08:56:08 <lambdabot>  pl src all
08:56:11 <jmcarthur_work> bleh
08:56:14 <jmcarthur_work> i forget again
08:56:19 <jmcarthur_work> @. @pl @src all
08:56:20 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
08:56:26 <jmcarthur_work> @. pl src all
08:56:26 <lambdabot> (line 1, column 1):
08:56:26 <lambdabot> unexpected end of input
08:56:26 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:56:33 <conal> SamB: i expect it is possible.
08:56:34 <jmcarthur_work> n/m, sorry
08:56:37 <Badger> @src all
08:56:37 <lambdabot> all p =  and . map p
08:56:48 <conal> SamB: (like most things)
08:56:56 <Badger> @pl f p - and . map p
08:56:57 <lambdabot> f p - all p
08:56:58 <Badger> er
08:57:03 <Badger> @pl f p = and . map p
08:57:04 <lambdabot> f = all
08:57:07 <jmcarthur_work> haha
08:57:07 <Badger> oh hurr
08:57:10 <conal> mmorrow: yeah -- too bad about freeglut not working on os x.  i didn't know until recently.
08:57:21 <SamB> conal: is it possible to get a matching set of GHC libraries on Debian without using stable?
08:57:39 <conal> SamB: i don't even understand the question.
08:57:58 <SamB> conal: hehehe
08:58:38 <conal> what i've found so far for ghci-friendly 3D is gtk2hs with gtkglext.
08:59:27 <conal> the big downside i'm aware of is that gtkglext isn't part of the native (os x) gtk+ framework, so i'm using the x11 version from macports.
09:00:11 <conal> which then doesn't work with my non-macports ghc.   so i've pulled in a huge amount of macports stuff and can't upgrade ghc whenever i want.
09:00:50 <mmorrow> conal: sounds wonderful
09:01:23 <jmcarthur_work> conal, this is why i'm doing much of my development in linux now instead of os x :\
09:01:25 <PeakerWork> conal: maybe you can fix the glut issues with OSX?
09:01:47 <PeakerWork> are there bugs filed, at least?
09:02:20 <conal> jmcarthur_work: yeah.  i get that.  i guess haskell is still fully & robustly supported only under linux.
09:02:33 <mmorrow> PeakerWork: i think Beelsebob knows the details (he's who told me that it doesn't work)
09:02:40 * jmcarthur_work cries
09:02:45 <conal> PeakerWork: probably not i.  maybe someone could.
09:02:46 <mmorrow> (freeglut under osx that is)
09:03:06 <mmorrow> he said it /was/ possible to build, but just really really hard for some reason
09:03:24 <mmorrow> (or that's what i recall he said at least)
09:05:08 <QP> Can I ask another question?
09:05:22 <mmorrow> you just did :)
09:05:29 <ezyang> (don't ask to ask)
09:05:41 <jfoutz> it looks like the built in apple glut added some freeglut functionality, for example glutWMCloseFunc()
09:05:53 <QP> I'm writing a basic irc client, and the one thing i can't figure out is how to create the interface
09:06:10 <QP> I'd rather it ran in the terminal
09:06:28 <jfoutz> QP: vty! it's cool.
09:06:29 <rocketman> QP, that's a bad idea
09:06:42 <mmorrow> @hackage vty
09:06:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vty
09:06:47 <QP> but then you get the problem of other people's text cutting in when you are writing...
09:07:11 <QP> is there a way of building a vim-like interface?
09:07:11 <conal> jfoutz: where are you seeing apple glut info?
09:07:12 <ezyang> Yeah, you want some sort of ncurses type library
09:07:22 <Axman6> mmorrow: any way to make the images bigger? onve the structures get larger, you can't zoom in, and the image is like 400px wide
09:07:31 <conal> jfoutz: that bit sounds like the magic i need.
09:07:46 <jfoutz> conal: this http://www.mail-archive.com/cl-opengl-devel@common-lisp.net/msg00279.html led me to this http://developer.apple.com/samplecode/glut/listing119.html
09:07:55 <mmorrow> Axman6: ah, right. lemme look, i don't recall exactly where i'm setting that..
09:08:05 <conal> jfoutz: thanks!
09:08:20 <jfoutz> you bet! i'd love those functions to work :)
09:08:39 <conal> cool.  everyone who wants a repl cares about this issue.
09:08:41 <mmorrow> Axman6: ah, grr. i'll push a patch
09:08:49 <Axman6> heh, ok
09:09:55 <jfoutz> QP, vty will do everything you want. there's also an ncurses binding that dons made for hmp3
09:10:10 <Axman6> mmorrow: lemme know when you've pushed it (unless this is somethig that'll take more than 10 mins)
09:11:07 <Axman6> s/10/5
09:13:31 <conal> anyone know how i can write to a Mac-formatted external drive (WD) from linux?
09:14:06 <Axman6> if it doesn't have journalling enables, linux should be able to handle it fine (might need to have something installed)
09:14:10 <Axman6> enabled*
09:14:20 <ray> mount it with some experimental fuse thing and be careful not to trip over any power cords
09:14:23 <hackagebot> GLUT 2.2.0.0 - A binding for the OpenGL Utility Toolkit (SvenPanne)
09:15:06 <dino-> Is this a fairly recent drive? What fs is typical for OSX? Just curious, I have no idea.
09:15:19 <ray> hfs+
09:15:20 <conal> okay.  thx.  sigh.  this transition to os x is a lot rougher than i expected. :/
09:15:21 <Ferdirand> conal: this maybe ? -> http://www.mars.org/home/rob/proj/hfs/
09:15:45 <Axman6> conal: if you're using linux, you're doing it wrong ;)
09:16:20 <conal> Ferdirand: thanks!
09:16:31 <hackagebot> Hieroglyph 3.8 - Purely functional 2D graphics for visualization. (JeffersonHeard)
09:16:31 <hackagebot> OpenGL 2.3.0.0 - A binding for the OpenGL graphics system (SvenPanne)
09:16:52 <Beelsebob> conal: don't use that
09:16:57 <Beelsebob> HFS /= HFS+
09:17:06 <conal> Beelsebob: oh.  oops.  thx.
09:17:27 <Beelsebob> there is a windows driver for HFS+ somewhere
09:17:33 <Beelsebob> not sure about linux
09:17:45 <ray> hfs is old school mac
09:17:47 <Beelsebob> what most people I know do is set up a small FAT32 partition
09:17:53 <Beelsebob> then almost all OSes can read it
09:17:58 <Axman6> linux hand;es hfs+, without journalling
09:18:48 <benmachine> I've never been able to write to my mac parition
09:18:53 <benmachine> can read from it easily enough though
09:20:36 <mmorrow> Axman6: ok, pushed
09:21:36 <Axman6> ok
09:21:41 <Axman6> what's the change?
09:22:41 <Axman6> where's vacuumTofile go?
09:22:45 <Axman6> 'd*
09:23:07 <conal> Is there another drive format i could use instead of HFS+ that would work well on both linux & os x?
09:23:07 <mmorrow> Axman6: ah, yeah i gave that one the chop since you can just write the ByteString to file
09:23:16 <mmorrow> Axman6: should i add that one back?
09:23:25 <Axman6> yus :P
09:23:29 <mmorrow> :)
09:23:31 <mmorrow> ok
09:23:36 <Axman6> it's a nice time saver
09:24:07 <Axman6> (avoids me having a 60 character long prompt by not importing the BS stuff)
09:26:04 <conal> Axman6: oh -- i see.  if i figure out how to turn off journaling from os x, i can write from linux.
09:26:13 <Axman6> yeah
09:26:24 <conal> what is journaling, btw?
09:26:28 <Axman6> it's pretty simple, just open disk utility. it's in the toolbar
09:26:53 <Axman6> it's a log of all actions that are to be performed. means the disk is never left in an inconsistent state
09:26:57 <conal> Axman6: thx.  still finding my way around this machine.
09:27:16 <Axman6> conal: feel free to join #macosx, we'll help you out :)
09:27:45 <conal> Axman6: oh. wow.  that's tremendous.  i've been looking for a support group!
09:27:56 <mmorrow> Axman6: ok, it's back :)
09:28:03 * Axman6 happens to be an op there too
09:28:09 <mmorrow> and there's *With version too
09:28:12 <ray> conal: you write stuff to a journal before writing to the real filesystem
09:28:46 <cdsmithus> This is going to sound silly.... I'm trying out Leksah, and finding that when I'm using it (and no other application) something seems to happen that causes my whole X session to shut down and boot me back out to a login prompt.  Anyone else had that happen?
09:28:48 <mmorrow> Axman6: (also handy is the ("dot" :: GVFormat))
09:28:54 <conal> ray: sounds useful.
09:29:17 <ray> modern filesystems tend to do it
09:29:18 <Axman6> yeah, a journal basically has all the info to perform a write, and once the write is complete, will be annotated with something that says the action was completed. so, actions either fully complete, or nothing is done at all
09:29:31 <Axman6> mmorrow: how do you use a .dot?
09:29:42 <mmorrow> cat foo.dot | dot -Tpng > foo.png
09:29:50 <mmorrow> cat foo.dot | dot -Tsvg > foo.svg
09:29:51 <mmorrow> etc
09:29:52 <conal> Axman6: very cool.  and i just turn it off before using with linux and then back on when i'm done with linux?
09:30:02 <Axman6> yep
09:30:10 <conal> Axman6: oops -- wrong window.
09:30:12 <PeakerWork> does OSX not support Ext3?
09:30:12 <benmachine> redundant cat :o
09:30:14 <conal> thx
09:30:15 <PeakerWork> or Ext4?
09:30:19 <Axman6> though, you'd be wise to keep it on where possible
09:30:23 <Axman6> PeakerWork: not natively
09:30:25 <mmorrow> benmachine: :)
09:30:25 <benmachine> dot -Tpng > foo.png < foo.dot # :P
09:30:43 <mmorrow> cat foo.dot | dot -Tcanon | tred | dot -Tsvg > foo.svg
09:30:48 <mmorrow> ;)
09:31:12 <mmorrow> (redundant dot that time though...)
09:31:29 <int-e> and cat!
09:31:32 <ray> people use cat as the id of unix, when it's really the (++) of unix
09:31:40 <mmorrow> no way jose!
09:31:46 <ray> and only degenerately the id of unix
09:31:47 <pikhq> ray: Variadic (++).
09:31:57 <idnar> ray: the problem is, there's no real id
09:31:59 <mmorrow> it's the "return" of unix
09:32:00 <axzs> concat
09:32:04 <Axman6> mmorrow: Error: renderer for StringSet.png is unavailable
09:32:05 <Axman6> :(
09:32:10 <Axman6> it was working before
09:32:12 <ray> well, unix isn't like haskell
09:32:17 <pikhq> idnar: Sure there is. <
09:32:23 <Axman6> using: vacuumToFile "StringSet.png" "png" (fromList [[a,b,c]| a <- "bac",b <- "ihj", c <- "yxz"])
09:32:25 <idnar> pikhq: that's not a command
09:32:35 <pikhq> idnar: It's an operator. ;)
09:32:40 <mmorrow> Axman6: wuh? does your graphviz support -Tpng ?
09:32:44 <int-e> mmorrow: I generally use < foo bar | baz > xyzzy
09:32:50 <idnar> pikhq: it's awkward for refactoring
09:32:54 <idnar> even if you stick it at the beginning
09:32:54 <Axman6> well, it used to... like half an hour ago
09:33:00 <int-e> mmorrow: I'll readily agree that it looks a bit awkward.
09:33:07 <Axman6> all i've done since then was update OpenGL and GLUT
09:33:08 <idnar> and since basically every shell command line is a throwaway...
09:33:18 <mmorrow> ray, int-e: http://okmij.org/ftp/Computation/monadic-shell.html
09:33:21 <idnar> er, I don't mean refactoring
09:33:51 <int-e> mmorrow: meh. done = true
09:33:56 <mmorrow> heh
09:34:43 <Axman6> i'm so cut, this was all working a few mins ago :(
09:35:07 <mmorrow> hmm, i can't think of how i could've broken it (??)
09:35:26 <Axman6> well i might have broken it by updating it
09:35:31 <mmorrow> Axman6: do you think this is vacuum-gl breaking it, or is graphviz somehow borked?
09:35:48 <mmorrow> Axman6: hmm, did you link to the same graphviz lib when you re-installed?
09:36:04 <Axman6> i believe so
09:36:41 <mmorrow> hmm, png works for me
09:37:34 <mmorrow> "Error: renderer for StringSet.png is unavailable"
09:37:41 <Axman6> it worked for me too
09:37:43 <mmorrow> that's definitely a graphviz-produced error
09:37:45 <Axman6> but now it doesn't
09:38:11 <mmorrow> since i'm sure i didn't write those words
09:38:18 <Axman6> yeah
09:38:32 <mmorrow> do other formats work?
09:38:36 <Axman6> > error "test"
09:38:38 <lambdabot>   * Exception: test
09:38:39 <Axman6> nope
09:38:42 <mmorrow> :o
09:38:54 <Axman6> jpeg and jpg, dot
09:38:56 <mmorrow> maybe ghc-pkg unregister, then re-build ?
09:39:12 <mmorrow> i guess something got borked during the reinstall
09:39:23 <mmorrow> and ./Setup clean too
09:39:26 <mmorrow> ooh, maybe that's it
09:40:14 <Axman6> hmm?
09:40:44 <mmorrow> did you ./Setup clean after you pulled?
09:41:11 <mmorrow> (dunno if that might be a factor or not, making a wild guess since C libs are involved)
09:41:14 <Axman6> i just tried that, and then doing a cabal install --reinstall --extra...
09:41:58 <mmorrow> i didn't bump the version number after the most recent update, maybe that's playing a part?
09:42:30 <Axman6> doesn't seem to be :\
09:43:19 <Axman6> i've tried reinstalling vacuum, graphviz, and i dunno what else i could try. but i really need to go to sleep. i'll talk to you tomorrow about it if you're around
09:43:26 * Axman6 is teh stumped
09:43:27 <mmorrow> i just bumped the version in case
09:43:36 <mmorrow> Axman6: heh, cool.
09:43:39 <mmorrow> night
09:43:44 <Axman6> o/
09:53:32 <axzs> Question on folds. As I understand foldl is as efficient as foldr, but the left one can be optimized, and the right one works on infinite lists - foldr (&&) True checks if the list has at least one False and doesn't return if given (repeat true).
09:54:15 <axzs> Is it possible to make both optimizations at once - a folding function which will both work in O(1) space, as foldl' does, and will work on infinite lists?
09:54:57 <mmorrow> axzs: it's usually (always?) the case that for a particular folding function, either foldl' is efficient and foldr is grossly inefficient or vice-versa
09:55:07 <mmorrow> foldr (++)
09:55:10 <mmorrow> foldl' (+)
09:55:25 <Berengal> foldr can be fused
09:55:42 <mmorrow> if there's a build
09:56:09 <Berengal> sumUpTo =  foldr (+) 0 . enumFromTo 1 is faster than sumUpTo = foldl' (+) 0 . enumFromTo 1
09:56:21 <Berengal> At least it produces fewer assembly instructions
09:56:30 <Berengal> (GHC -O2 obviously)
09:56:44 <mmorrow> > (foldr (+) 0 . enumFromTo 1) 1000000
09:56:46 <lambdabot>   * Exception: stack overflow
09:56:53 <mmorrow> > (foldl' (+) 0 . enumFromTo 1) 1000000
09:56:54 <lambdabot>   500000500000
09:57:05 <Berengal> I don't think lamdabot compiles with -O2
09:57:24 <mmorrow> i'm willing to bet that foldr isn't faster there :)
09:57:29 <mmorrow> even with -O2
09:58:18 <idnar> axzs: note that foldl and foldr are only equivalent if your function is associative
09:58:28 <axzs> Yes, I'm assuming that.
09:59:07 <mmorrow> axzs: an note that that's the case for foldl, not foldl'
09:59:07 <axzs> Suppose I've got a type ExtendedInteger = Number Integer | Infinity. I'd like to write a function, which will sum up a finite list, and given any infinite list, halt if it contains Infinity. is it possible to use a higher-order function like fold AND have O(1) space complexity?
09:59:09 <idnar> anyhow, I don't think you can have your cake and eat it too there
09:59:14 <idnar> unless maybe you distinguish data from codata
10:00:06 <mmorrow> foldl neither lets you abort early nor can it run in constant space
10:00:19 <mmorrow> it's pretty much the worst of both worlds :)
10:01:22 <mmorrow> Berengal: the foldr one blows the stack even with -O2
10:02:01 <mmorrow> foldr is just not what you want for Int(eger)
10:02:54 <Berengal> mmorrow: You might have to specialize on Int as well
10:03:04 <Trinithis> with associative functions, does it matter which you choose?
10:03:11 <mmorrow> ah, ok the bet is back on (about running time) :)
10:03:19 <Trinithis> like compose = foldr/foldl
10:04:00 <axzs> it matters only with infinite lists
10:04:04 <mmorrow> still blows teh stack
10:04:27 <Berengal> mmorrow: Yeah :/ I'm sure I got it to work some time
10:04:38 <mmorrow> (the only way that it couldn't is if ghc transformed the foldr into a foldl, which it can't because that doesn't preserve semantics)
10:04:47 <Berengal> I counted the instructions. There were about 5 of them
10:05:13 <mmorrow> Berengal: *(void**)0; is just one instr iirc ;)
10:05:27 <Berengal> It should fuse the fold and build
10:05:30 <mmorrow> zomg: jmp zomg
10:06:05 <mmorrow> Berengal: foldr has to traverse the *entire list* before it even can start summing the numbers
10:06:18 <mmorrow> foldl' starts summing immediately
10:06:30 <mmorrow> and the second it hits the end of the list, it's done
10:07:12 <Trinithis> > (foldl' (flip (.)) id $ replicate 100000 id) 6
10:07:13 <lambdabot>   6
10:07:18 <Trinithis> > (foldr (.) id $ replicate 100000 id) 6
10:07:20 <mmorrow> sumr(List *xs){if(!xs)return 0; return xs->head + sumr(xs->tail);}
10:07:20 <lambdabot>   6
10:07:25 <mmorrow> is what foldr (+) does
10:08:16 <mmorrow> sumr(List *xs){int acc  = 0; while(xs){acc += xs->head; xs = xs->tail;} return acc;}
10:08:20 <mmorrow> is what foldl' does
10:08:31 <mmorrow> oops, s/sumr/suml/ on that last one
10:08:58 <mmorrow> the reason for the stack overflow becomes apparent in the C version
10:09:00 <Trinithis> @ty sumr
10:09:01 <lambdabot> Not in scope: `sumr'
10:09:35 <mmorrow> (typedef struct list List; struct list {int head; List *tail;};)
10:09:42 <Berengal> mmorrow: With a fusion there is no list at all
10:10:39 <mmorrow> Berengal: that doesn't change that foldr needs to walk the entire thing before it can sum anything. the "list" just gets thrown onto the stack in the foldr (+) case
10:11:05 <jfoutz> axzs: foldl' (\acc val-> case val of {(Number x) -> x + acc;Infinity -> Infinity})
10:11:49 <axzs> Yes, but this doesn't work on an infinite list
10:12:18 <mmorrow> no it doesn't
10:12:26 <mmorrow> suml(List *xs){int acc  = 0; while(xs){acc += xs->head; xs = xs->tail;} return acc;}
10:12:39 <mmorrow> if xs is never NULL, then it'll spin forever
10:12:54 <jfoutz> axzs, i'm not sure i understand... if you have the 'infinity' element it quits early.
10:13:02 <axzs> I meant a list like [1..]
10:13:09 <mmorrow> the sumr C version actually doesn't work though reasoning-wise, since the recursive call isn't lazy there
10:13:21 <mmorrow> axzs: right, so do i
10:13:39 <mmorrow> axzs: oh, wasn't @me :)
10:14:18 <mmorrow> (but the sumr works reasoning-wise when reasoning about when the haskell version is /evaluated/)
10:14:24 <jfoutz> axzs i'm pretty sure you can, but only if the sequence converges, and if you give your sum function a hint about the generator.. depents on the sequence.
10:16:03 <axzs> I just wanted it to halt if the list contains Infinity; if given hints, the situation is much different. Checking it automatically is of course impossible
10:16:43 <jfoutz> axzs: the foldl' version will do what you want. you might want to look at 'seq'
10:17:13 <axzs> it doesn't halt on an infinite list
10:17:32 <idnar> it's impossible to detect an infinite list, surely?
10:17:41 <axzs> halting problem
10:17:48 <jfoutz> i misunderstood this phrase: I just wanted it to halt if the list contains Infinity;
10:18:24 <jfoutz> axzs: the foldl' version will halt on an infinite list if it contains Infinity
10:18:26 <axzs> I meant, it should stop if given a list like [1,1,Infinity,5,6,4,3,etc]
10:18:29 <axzs> yes
10:19:01 <jfoutz> yes, the foldl' is strict, it will not continue down the list when it encounters the 'bad' value
10:19:38 <axzs> I think I'm requiring too much. It isn't possible to do it O(1) space and work on infinite lists, unless doing some hack like halting manually with Infinity
10:20:00 <axzs> um sorry I misunderstood you!
10:20:57 <axzs> jfoutz, are you sure it does halt? foldl' (&&) True (repeat False)
10:21:03 <Phillemann> How can I express that if a type is an instance of my CustomTypeClass, it's automatically an instance of Ord? I tried "instance MilliTime a => Ord a where ..." but it tells me this is an illegal instance declaration. Do I need FlexibleTypeInstances (or what it was called)?
10:21:19 <Phillemann> s/MilliTime a/CustomTypeClass a/ :D
10:21:31 <jmcarthur_work> Phillemann, that would be overlapping instances, and bad practice
10:21:47 <jmcarthur_work> Phillemann, you could, however, say class Ord a => MilliTime a where
10:21:59 <jmcarthur_work> so that Ord is a requirement for instances of the type class
10:22:11 <idnar> jmcarthur_work: that sounds like the opposite of what you want, though
10:22:21 <jfoutz> axzs: i see... one sec. there are sematics that support doing that.
10:22:33 <lysgaard> Is it possible to listen to an UDP port, but at the same time send some packets from that port?
10:23:18 <jmcarthur_work> idnar, with a function defaultCompare, one could create the Ord instance very easily
10:23:29 <jmcarthur_work> where defaultCompare is defined in terms of MilliTime
10:23:40 <idnar> jmcarthur_work: but wouldn't you have to do that for every instance?
10:23:44 <jmcarthur_work> idnar, yes
10:24:13 <jmcarthur_work> idnar, the alternative is overlapping instances, though. i consider it a fair trade
10:24:18 <idnar> I would imagine the point of defining an instance MilliTime a => Ord a is to avoid that
10:24:46 <idnar> anyhow, I'm not particularly arguing in favour of overlapping instances
10:24:50 <jmcarthur_work> idnar, at the cost of not knowing whether the default or some other instance for Ord is used in practice
10:24:51 <idnar> I'm just not sure if there's any point in subclassing Ord
10:25:27 <Phillemann> I don't really understand what is overlapping here.
10:26:00 <jmcarthur_work> there's no telling if somebody will define their own Ord for some type that is also an instance of MilliTime and whether that would have the same semantics as the default
10:26:59 <jmcarthur_work> Phillemann, "instance MilliTime a => Ord a where" defines Ord for all types that are instances of MilliTime, some of which may already have instances for Ord
10:27:21 <Phillemann> jmcarthur_work: Ah, I see
10:27:28 <jmcarthur_work> Phillemann, the type system cannot guarantee that there is no existing instance, therefore it's overlapping
10:27:32 <v0|d> fxr: y00
10:28:03 <fxr> v0|d: sup
10:28:42 <jmcarthur_work> Phillemann, -XOverlappingInstances will allow you to do that, and it uses the most specific instance available if there are more than one for a given type
10:28:55 <fxr> I wonder why we didn't implemented core-server streams with cc-delcont?
10:29:04 <jmcarthur_work> Phillemann, but i prefer to make which instance is being used more explicit
10:30:22 <v0|d> fxr: oh pre-oleg times.
10:30:26 <Phillemann> jmcarthur_work: Well, I only use the ordering of the MilliTime types once in my code, so I think I'll just not use any Ord subclassing here. :)
10:30:28 <benmachine> lysgaard: you asked a question about listening from and sending to the same UDP port?
10:31:15 <jmcarthur_work> Phillemann, that sounds best
10:31:25 <benmachine> all sockets support both sending and receiving unless you deliberately disable them
10:32:25 <lilac> Phillemann: 'instance MilliTime a => Ord a' does /not/ mean that any type which has an instance of MilliTime has an instance of Ord
10:32:44 <lilac> Phillemann: it means that /all/ types have an instance of Ord, but if you use it, then you need an instance of MilliTime
10:34:34 <Phillemann> lilac: What do you mean, _all_ types?
10:34:38 <lysgaard> benmachine: Yes, you know something? It would realy make my day.
10:34:46 <jmcarthur_work> all of them
10:35:42 <benmachine> lysgaard: what exactly did you want to know? I didn't quite understand your question but the answe ris probably yes
10:38:15 <lysgaard> benmachine: Okay: I'm listening to an UDP port of number n. When i recieve a message, i parse it and want to send it from port n on my computer to whatewer port and ip the message came from. Then the other pc parses that message and responds sending the message back to port n... and it goes on =)
10:40:22 <lysgaard> benmachine: Right now, when I'm sending I'm using Network.Socket.sendTo, and it chooses a random port.
10:41:29 <benmachine> hmm
10:41:47 <benmachine> I know that in principle it's possible, I'm not yet sure how you'd do it in haskell though
10:42:21 <lysgaard> benmachine: Let's find out!
10:43:06 <benmachine> lysgaard: how are you receiving?
10:43:14 <lysgaard> benmachine: I'm working on a P2P (Kademlia) library, and i need the node communication to go over one port, to cut complexity
10:44:23 <lysgaard> benmachine: I can show you the whole sourcecode if you want, but It's quite big. I'm recieving form: Network.Socket.recvFrom
10:45:47 <dubhrosa> Monad tutorials.... you've given me the space-laser without first explaining that I'm an evil supervillian
10:45:50 <benmachine> lysgaard: well my instinct is that if you send with a socket with which you've called bindSocket, it should send from the bound address
10:46:10 * benmachine pokes about in Network
10:47:00 --- mode: ChanServ set -o dons
10:47:19 <dons> bos31337: would you like me to add anything re. Fedora to the platform page: http://hackage.haskell.org/platform/  2009.2.0.2 due out today
10:47:26 <kolmodin> dcoutts: parts of c2hs's test cases fails for me. Pointer.chs and Sizeof.chs
10:47:27 <lysgaard> benmachine: Yeah, I just realised that too, i think i have to reorganize some code
10:47:39 <bos31337> dons: i'll have to take a look in my Copious Spare Time (TM)
10:47:50 <dons> cheers
10:48:04 <CalJohn> @hoogle [a] -> Set a
10:48:04 <lambdabot> Data.Set fromDistinctAscList :: [a] -> Set a
10:48:04 <lambdabot> Data.Set fromList :: Ord a => [a] -> Set a
10:48:04 <lambdabot> Data.Set fromAscList :: Eq a => [a] -> Set a
10:48:41 <Gwern-away> ok, datastructure time! suppose I have a list which looks like [(1, "foo"), (1, "baz", (2, "foo"), (3, "foo")], and I want to extract the string whose Ints sum highest - "foo" in this case. currently I turn this into a map, then back to a list, then map swap to flip the String key to an Int key, and then run sortBy it
10:48:54 <Gwern-away> if that's the fastest way to do it, I no longer want to live in this rotten world
10:48:56 <benmachine> @pl g f (x, y) = f y x
10:48:56 <lambdabot> g = (`ap` snd) . (. fst) . flip
10:49:05 <benmachine> hrmph
10:49:19 <LeoD> isn't that ***?
10:49:22 <LeoD> @type (***)
10:49:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:49:47 <bos> Gwern-away: there's fastest-to-think-about and fastest-to-implement :-)
10:49:57 <bos> Gwern-away: and then fastest-to-perform
10:50:00 <copumpkin> LeoD: nope
10:50:13 <LeoD> oh sorry, didn't look closely enough
10:50:14 <copumpkin> it's flip uncurry f
10:50:17 <copumpkin> or something like that
10:50:20 <copumpkin> flip (uncurry f)
10:50:26 <ray> @unpl flip (uncurry f)
10:50:26 <lambdabot> (\ b c -> uncurry f c b)
10:50:32 <Gwern-away> bos: well, my current solution has a value of 0 for fastest-to-implement as it's already written, so clearly I can't be trying to optimize *that*
10:50:38 <fxr> @src  fix
10:50:38 <lambdabot> fix f = let x = f x in x
10:50:42 <benmachine> yeah I was thinking about uncurry
10:50:52 * ray smacks lambdabot over the head with a copumpkin
10:50:55 <copumpkin> lol
10:51:07 <Gwern-away> (my list is being generated by a list comp, so it'd be easy to make the string come first)
10:51:36 <benmachine> @unpl uncurry . flip
10:51:36 <lambdabot> (\ f -> uncurry (\ b c -> f c b))
10:52:07 <Gwern-away> this would be easy if there were some way to use the ints as keys, but I couldn't figure out how that could work, and Data.Map doesn't let you query for the maximum entry - just the maximum key
10:52:12 <Gwern-away> quite annoying
10:53:18 <seydar> is ghc's Garbage collector written in haskell?
10:53:24 <rocketman> no
10:53:25 <copumpkin> yeah
10:53:33 <copumpkin> yeah, rocketman's right
10:53:35 <copumpkin> ;)
10:53:39 <Gwern-away> haskell, where your answers are questioned in glorious stereo
10:53:39 <copumpkin> </fail>
10:54:13 <seydar> so
10:54:20 <seydar> it is NOT written in haskell
10:54:37 <copumpkin> yeah, the only part of GHC that's in c is its runtime
10:54:44 <copumpkin> and that includes the garbage collector
10:54:50 <seydar> ah
10:55:06 <seydar> COULD it be in haskell? if you used FFI to gain access to free and malloc?
10:55:57 <Gwern-away> sounds like a bootstrap problem - how's the FFI implemented then...
10:56:11 <ray> bootstrapping is easy
10:56:15 <copumpkin> well, not the current ghc haskell as that still expects a runtime :P but other compilers like LHC would eventually like to generate code with no runtime, I think
10:56:32 <Gwern-away> oh, if you want that, jhc's got your back :)
10:56:55 <Gwern-away> (viz not having a runtime)
10:57:03 <Ytinasni> seydar: i'm not sure what you mean; memory allocation in haskell doesn't use malloc/free
10:57:05 <seydar> maybe you could have a special part of FFI implemented so you can use pointers and stuff
10:57:38 <seydar> Ytinasni: I would like to see a GC for haskell written in haskell
10:57:46 * Gwern-away goes to bed now. if anyone has any ideas about my map issue, I'd like to know - I think it's a major bottleneck for my prog
10:57:48 <seydar> what needs to be done
10:58:07 <Ytinasni> but no; gc requires altering memory, which haskell can't do (except in IO, where it can do anything C can do, but that's hardly amazing)
10:58:26 <erikc> seydar: what garbage collects the garbage collector?
10:58:36 <copumpkin> lol
10:58:44 <idnar> erikc: it garbage collects itself, obviously
10:58:48 <copumpkin> WHO WATCHES THE WATCHMEN
10:58:49 <seydar> erikc: none, the GC would have to manage itself
10:58:49 <Botje> the garbage collector could just create a predictable amount of garbage :p
10:58:53 <Cale> huh?
10:58:56 <seydar> and i guess pretty much be written in C
10:59:03 <erikc> :)
10:59:12 <copumpkin> oh no, it's Anonycale
10:59:27 <seydar> look, i don't know much about GCs
10:59:36 <seydar> i'm just trying to see one in a nice pretty language
10:59:39 * seydar cries
10:59:43 <Cale> You could easily enough have a garbage collector for a simulated memory :)
11:00:00 <araujo> copumpkin, META-WATCHMEN ?
11:00:12 <Ytinasni> araujo: who watches the meta-watchmen?
11:00:25 <araujo> Ytinasni, METAMETAWATCHMEN
11:00:29 <Cale> Or yeah, a GC in terms of the FFI memory primitives.
11:01:04 <benmachine> the watchmen watch each other
11:01:05 <erikc> Cale: strict only, no partial applications
11:01:13 <erikc> which basically gives you...C :)
11:01:19 <Cale> erikc: ?
11:01:40 <Cale> strict? partial applications? I'm not sure what you're referring to :)
11:01:40 <erikc> even using only ffi memory primitives
11:01:47 <seydar> erikc: yea, but could it be done?
11:02:14 <Ytinasni> seydar: yes. i would look a lot worse than the equivalent C, though.
11:02:34 <Ytinasni> uh, "it would..."
11:02:35 <Cale> I'm not sure about that.
11:02:43 <erikc> Cale: to write haskell code that you know doesnt allocate memroy that needs to be gc'd
11:03:06 <Cale> erikc: I thought we were talking about writing a garbage collector in Haskell.
11:03:44 <seydar> Cale: to do the GC you need the weird haskell
11:03:51 <Ytinasni> erikc: that's not necessary, actually. all you need is that any memory you allocate during gc can't refer to "old" memory from before the gc.
11:04:03 <axzs> > show $ read "12" -- why this gives parse error, not ambiguous type variable, as read "12"?
11:04:05 <lambdabot>   "* Exception: Prelude.read: no parse
11:04:13 <Cale> seydar: 'weird'?
11:04:16 <Ytinasni> and allocations during the gc are gc'd /next/ gc.
11:04:41 <Cale> You could write the runtime system for your language in Haskell using the FFI to allocate chunks of memory manually, and write a garbage collector in Haskell.
11:04:42 <seydar> s/weird/super awesome
11:04:56 <dons> could you write a GC in the ST monad?
11:04:59 <mauke> "your language" is Haskell
11:05:24 <dons> you can write GCs in a region-based language, and I'd not be surprised if you could do regions with ST....
11:05:24 <Cale> mauke: "your language" being whatever language you're writing a compiler for.
11:05:36 <Asztal> axzs: I think it picks a default instance of the Read type class (probably (), the simplest type)
11:05:45 <Asztal> > show $ read "()"
11:05:46 <lambdabot>   "()"
11:05:47 <Cale> ... I suppose it might be Haskell if you're writing a Haskell compiler.
11:05:49 <Ytinasni> :t read "12"
11:05:50 <lambdabot> forall a. (Read a) => a
11:06:47 <seydar> Ytinasni: puhutko suomea?
11:07:01 <Cale> Or am I somehow missing the point of what we're trying to accomplish here?
11:07:16 <Ytinasni> seydar: sorry, i don't understand you.
11:07:16 <Cale> You want a garbage collected embedded language?
11:07:27 <seydar> ah, oh well. i asked if you spoke finnish
11:07:33 <ray> cale: he asked about ghc's garbage collector, and whether it was in haskell
11:07:34 <jpcooper> hello
11:07:34 <Cale> (which doesn't use Haskell's existing GC?)
11:07:45 <ray> then it got confusing
11:07:52 <jpcooper> what happens when one tries to read a line from a handle whose corresponding socket connection has closed?
11:08:13 <axzs> Asztal: thanks. And what are default instances? Is it always ()?
11:08:56 <ray> > read "12" :: Int
11:08:58 <lambdabot>   12
11:08:59 <seydar> Cale: then i asked what it would take to HAVE it written in haskell
11:10:04 <Cale> jpcooper: You get an exception
11:10:07 <Cale> *** Exception: <socket: 10>: hGetLine: end of file
11:10:08 <Asztal> axzs: Integral defaults to Integer, I think, or maybe Int.
11:10:20 <Asztal> does lambdabot use GHCI's extended defaulting rules?
11:10:20 <jpcooper> Cale, do you know what happens when writing?
11:10:28 <jpcooper> I guess I could just try this out
11:10:44 <Cale> jpcooper: apparently nothing.
11:10:49 <mauke> you gonna get killed
11:11:20 <jpcooper> chrisdone said something about SIGPIPE
11:11:30 <axzs> show . read has type  (Read a, Show a) => [Char] -> [Char] in hugs and [Char] -> [Char] in ghci
11:11:51 <copumpkin> axzs: hugs' signature makes little sense :P
11:11:58 <axzs> for me it does
11:12:03 <copumpkin> how can you constrain a variable that doesn't exist?
11:12:09 <Cale> jpcooper: Well, I'm just trying it in ghci, and nothing seems to happen when I write to the already-closed socket handle
11:12:25 <copumpkin> for all you know that a could be (x, (y, a, (z, w)))
11:12:55 <idnar> copumpkin: in what sense does it not exist?
11:12:58 <idnar> copumpkin: it's just unused
11:12:59 <axzs> copumpkin, as I understand, read is not just a function, it's a family of functions String -> a for all Read a (natural transformation)
11:13:03 <Cale> jpcooper: Trying to hClose an already-closed handle gives an exception though.
11:13:10 <Cale> (broken pipe)
11:13:18 <axzs> it isn't clear which a to choose
11:13:21 <copumpkin> idnar: well in teh sense that it doesn't make it into the final type signature, so you can't constrain it
11:13:22 <mauke> Cale: oh, you're using buffering
11:13:37 <Cale> ah, that might be it
11:13:37 <idnar> copumpkin: I'd say you can constrain it to whatever you like :P
11:13:43 <Ytinasni> idnar: it's not unused; that's the problem. it affects which read gets used.
11:13:48 <copumpkin> idnar: not if all you're given is f = read . show
11:14:16 <copumpkin> f's type signature is (Read a, Show a) => [Char] -> [Char] in hugs?
11:14:23 <copumpkin> how do I force a to be Int, for example
11:14:31 <idnar> copumpkin: how could the constraint ever be violated?
11:14:46 <jmcarthur_work> :t asTypeOf
11:14:47 <lambdabot> forall a. a -> a -> a
11:14:48 <axzs> I don't know. seems it's impossible
11:14:59 <jpcooper> http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html#10 <-- there's a bit about SIGPIPE at the end
11:15:00 <copumpkin> jmcarthur_work: that won't help?
11:15:14 <jmcarthur_work> copumpkin, it will if you slightly change the definition to use that and take another parameter
11:15:23 <copumpkin> jmcarthur_work: oh, well sure
11:15:37 <Cale> yes
11:15:52 <axzs> to be precise it's read . show :: (Show a, Read b) => a -> b
11:15:56 <Cale> With no buffering, I get an exception right away when writing to the closed handle
11:16:05 <jpcooper> thanks
11:16:07 <axzs> um nvmd
11:16:25 <Cale> I expect you'd probably get the exception once the buffer fills otherwise.
11:16:27 <copumpkin> axzs: oh whoops, yeah I had that backwards
11:16:54 <Cale> Prelude Network System.IO> (hdl, hn, port) <- accept =<< listenOn (PortNumber 50000) -- kind of nice that this sort of thing works right out of ghci ;)
11:17:43 <ray> imagine how great it'd be on a haskell machine
11:17:55 <Cale> ?
11:18:37 <Cale> ray: You mean like a Reduceron?
11:18:53 <jmcarthur_work> > flip asTypeOf <*> read . show $ 5
11:18:55 <lambdabot>   5
11:19:17 <jmcarthur_work> :t read . show
11:19:18 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
11:19:20 <jmcarthur_work> :t flip asTypeOf <*> read . show
11:19:22 <lambdabot> forall a. (Read a, Show a) => a -> a
11:20:11 <ray> cale: maybe, i don't know about that
11:20:19 <Cale> http://www.cs.york.ac.uk/fp/reduceron/
11:20:22 <Ytinasni> :t flip asTypeOf <*> show . read
11:20:23 <lambdabot> String -> String
11:20:31 <jmcarthur_work> nah, won't work for that
11:21:01 <jmcarthur_work> :t \x -> show . flip asTypeOf x . read
11:21:03 <lambdabot> forall b. (Show b, Read b) => b -> String -> String
11:21:36 <ray> yeah, something like that i guess
11:21:42 <jmcarthur_work> let showread x = show . flip asTypeOf x . read in showread 5 "7"
11:21:49 <jmcarthur_work> > let showread x = show . flip asTypeOf x . read in showread 5 "7"
11:21:50 <lambdabot>   "7"
11:22:05 <jmcarthur_work> > let showread x = show . flip asTypeOf x . read in showread 5 "Just 7" --fail
11:22:06 <lambdabot>   "* Exception: Prelude.read: no parse
11:22:39 <benmachine> > let showread x = show . flip asTypeOf x . read in showread 0.0 "7"
11:22:40 <lambdabot>   "7.0"
11:34:13 <jpcooper> is there any way to sleep other than threadDelay
11:34:34 <leadnose> what's wrong with it?
11:34:38 <Lemmih> jpcooper: What's wrong with threadDelay?
11:34:44 <lysgaard> Anyone know a refactorer for Haskell?
11:34:45 <jpcooper> just wondering
11:34:54 <lilac> lysgaard: i think there's something called hare
11:34:55 <Vulpyne> There's one called HARE.
11:35:04 <Vulpyne> But I don't think it works with the current version of GHC.
11:35:24 <Vulpyne> Maybe I should read my screen before typing. :)
11:35:38 <lilac> your information was more useful than mine :)
11:35:39 <Rotaerk> jpcooper, why suspect the existence of an alternative to something if you can't even point out an issue or shortcoming in the existing option?
11:35:41 <lysgaard> Then it's kinda worthless
11:35:45 <copumpkin> Lemmih: I was just wondering where you'd disappeared to!
11:36:26 <lilac> lysgaard: not necessarily. you would just need to have an old version of ghc installd, i guess
11:36:31 <jpcooper> okay guys. All I needed was "no"
11:36:45 <lilac> unless you're using features/extensions which aren't present in old GHCs?
11:37:56 <leadnose> jpcooper, today I was looking for threadDelay, and hayoo found *many* things called 'sleep', or something similar, perhaps one of those might be interesting?
11:38:05 <lilac> jpcooper: i suspect the answer is probably "yes", but it's hard for anyone to know what would be appropriate without knowing what your use case is
11:38:39 <Rotaerk> precisely why the shortcomings of threadDelay are important: they let you decide WHICH of the alternatives is good
11:38:39 <lysgaard> lilac: Nope, I've just got ghc 6.10 i think
11:38:47 <benmachine> so it turns out readMVar is much easier to block than I thought
11:38:53 <jpcooper> I was wondering whether there was something which took seconds rather than milliseconds
11:39:13 <jpcooper> I've had encounters with ones in other languages
11:39:16 <Lemmih> copumpkin: My code-fu has been weak lately. Reality has been too imposing.
11:39:23 <benmachine> (talking about the case where it is full beforehand)
11:39:24 <copumpkin> oh no!
11:39:45 <lilac> lysgaard: installing GHC 6.8 alongside 6.10 is pretty easy if i remember correctly, so that's one option
11:39:59 <Rotaerk> jpcooper, how about: threadDelay . (*) 1000
11:40:05 <Rotaerk> if that's the right syntax hmm
11:40:14 <Rotaerk> > threadDelay . (*) 1000
11:40:15 <lambdabot>   Not in scope: `threadDelay'
11:40:30 <rocketman> Rotaerk, that's fine
11:40:36 <lilac> Rotaerk: looks good, but i'd write it as threadDealy . (1000*)
11:40:41 <Rotaerk> ah
11:40:47 <lilac> then GHC would complain and i'd fix my typo
11:40:51 <jpcooper> Rotaerk, sorry, I meant microseconds
11:41:02 <jpcooper> but yes it's fine if there isn't something
11:41:06 <Rotaerk> jpcooper, oh, so you want a more precise timer then
11:41:12 <Rotaerk> that's what you should've said from the beginning :P
11:41:13 <Vulpyne> He wants a less precise timer. :)
11:41:17 <jpcooper> no I just want to delay by seconds. It really isn't so important
11:41:37 <Rotaerk> Vulpyne, micro is more precise than milli :P
11:42:07 <Vulpyne> Well, yeah. What I meant is he wants something he can just plug seconds into without having to multiply the milliseconds or whatever.
11:42:19 <Vulpyne> threadDelaySeconds = threadDelay . (*1000000)
11:42:27 <Vulpyne> Would work as a convenience function.
11:43:35 <lilac> jpcooper: maybe System.Posix.Unistd.nanosleep?
11:44:14 <jpcooper> lilac, I just want seconds. It's not important
11:45:00 * lilac spent too much time searching and not enough time reading :(
11:45:26 <Rotaerk> why'd you bring up microseconds then?
11:45:29 <Rotaerk> lol
11:45:40 <Rotaerk> ohhh nm
11:45:53 <lilac> you could fork off a call to sleep(1), or use System.Posix.Unistd.sleep :)
11:46:13 <jpcooper> Rotaerk, bloody hell
11:46:21 <jpcooper> threadDelay takes microseconds
11:46:25 <jpcooper> I was asking for an alternative
11:46:25 <Rotaerk> I misunderstood your correction from the beginning :P
11:46:27 <Rotaerk> yea
11:50:02 <jmcarthur_work> jpcooper, sleep = threadDelay . (/1000000)
11:50:21 <jmcarthur_work> err
11:50:25 <jmcarthur_work> jpcooper, sleep = threadDelay . (*1000000)
11:50:29 <jmcarthur_work> sorry
11:51:48 <jpcooper> I've got no sound coming from the subwoofer
11:53:45 <lysgaard> lilac: How do i install ghc-6.8.2 whitout clobbering everything up then?
11:54:27 <lilac> lysgaard: on windows or some unix-like system?
11:54:48 <lysgaard> lilac: arch linux ;)
11:55:26 <lilac> lysgaard: i believe you can download a source package and specify that it should install somewhere in your home dir
11:55:35 * mexisme is away: I'm busy
11:55:36 <lilac> but it's been a while since i've done it :)
11:56:15 <lysgaard> lilac: I really don't want to mess with something i don't understand. I'd hate to break my haskellinstall
11:57:10 <lpsmith> ugh,  programming primarily by side effects is evil.
11:57:12 <lilac> if your haskell install is a system one, then you should be fine as long as you don't run anything as root :)
11:57:44 <benmachine> lysgaard: I thought messing with things you didn't understand was the whole point of arch :P
11:57:44 <lpsmith> lysgaard:  installing ghc-6.8.2 shouldn't be a big deal,  they can happily co-exist
11:57:48 <dino-> lysgaard: And with Arch you can always just remove and reinstall 6.10.x with pacman to repair breakage.
11:57:49 <benmachine> at least, that's why I installed it
11:58:02 <rocketman> lpsmith, no it's not (!)
11:58:09 <lysgaard> benmachine: I understan! ... kinda :P
11:58:21 <benmachine> opinions differ
11:58:34 <dino-> Or really any Linux where you installed using the generic binary installer, that's fixable in the form of just make it install again.
11:58:53 <lpsmith> rocketman:  yes it is.   Unconstrained side effects are evil.
11:59:03 <lpsmith> I actually had a concrete instance in mind though
11:59:05 <idnar> lpsmith: just rotate your program 90 degrees, then they won't be "side" effects anymore :P
11:59:15 <rocketman> lpsmith, you don't mind nontermination though?
11:59:28 <ray> south effects
11:59:29 <lysgaard> lpsmith: Well, i goh a problem. Ghc-6.8.2 is built using libreadline.so.5, i need libreadline.so.6
11:59:38 <rocketman> and partiality, like (!!)
11:59:39 <lpsmith> rocketman:  nontermination doesn't have much to do with side-effects :-)
11:59:43 <rocketman> yes it does
11:59:45 <idnar> nontermination is a side effect, surely?
12:00:03 <dino-> lysgaard: Small word of advice though: If you use xmonad, backup your ~/.xmonad/xmonad-i386-linux binary just in case and avoid changing your xmonad conf until you have working ghc with xmonad libs back in place.
12:00:16 <pikhq> idnar: No.
12:00:23 <lpsmith> general recursion is a computational effect, it's not really a side effect.
12:00:28 <rocketman> idnar is right
12:00:47 <lysgaard> dino-: No prob, I use WMII
12:00:51 <jmcarthur_work> nontermination can certainly be treated as a side effect both practically and by a type system
12:01:00 <idnar> lpsmith: non-termination is a side-effect of the recursion
12:01:04 <pozic> Who has defined what an "effect" is?
12:01:05 <jmcarthur_work> it simply isn't treated as such in the haskell type system
12:01:13 <dino-> Also not a bad idea to work out care and feeding of >1 ghc in a VM first where you can boldly destroy things and roll back.
12:01:25 <lpsmith> but on that count,  neither lazy nor eager evaluation is more "pure" than the other.
12:01:38 <rocketman> lpsmith, agreed
12:01:52 <lpsmith> but that's not what I had in mind.
12:03:03 <lpsmith> Specifically,  TeX and the way it interacts with bibtex is evil
12:04:02 <lpsmith> I caught a fairly significant LaTeX error late in my Monad Reader article,   where I forgot to escape a %
12:04:08 <Rotaerk> a side effect is anything that breaks referential transparency
12:04:29 <lpsmith> And this commented out \cite{}.
12:04:40 <Rotaerk> so.. if it causes some change in state outside of itself or its return value depends on some state outside of itself, those are side effects
12:05:04 <lpsmith> And when I fixed this,  Wouter didn't rerun bibtex to update my bibliography.
12:05:13 <lpsmith> So the citation is missing.   Sigh.
12:05:52 <lpsmith> I have a [?] in my article that should refer to the CPR analysis paper by Glynn et al.
12:06:19 <Rotaerk> wait no, I guess return value being dependent on external state isn't a side effect, just makes the function impure
12:07:09 <jmcarthur_work> Rotaerk, i could have foo = 1, and i could have bar = sum $ iterate (/2) 1%2, but foo and bar don't have equivalent computations. their results are theoretically the same. it's a matter of whether you consider that a breakage of RT or not
12:07:11 <lpsmith> non-termination doesn't really break referential transparency
12:07:22 <dino-> lysgaard: I'm not sure, but perhaps you can install readline5 alongside 6 in Arch. There is a site with archived pkg.tar.gz files: http://arm.kh.nu  I see readline5 here: http://arm.kh.nu/core::2009-7-%202/os/i686/
12:08:13 <jmcarthur_work> well, i guess that doesn't strictly break RT anyway
12:08:43 <jmcarthur_work> foo and bar are different definitions, but RT means you can replace foo or bar with their results, not necessarily with each other
12:08:45 <lpsmith> jmcarthur_work:   That's a nice illustrative example of something,  but not of what you are trying to argue :-)
12:08:59 <jmcarthur_work> lpsmith, right, that's what my retraction is meant to say
12:09:02 <lysgaard> dino-: I'm not shure if I have the nerve to install another ghc version whitout knowing what I'm doing. Will the new version need all libraries for it recompiled for example?
12:10:02 <dino-> Yes, all the stuff registered, has to be done for each ghc.
12:10:32 <lpsmith> What does that illustrate though?   That sum isn't the same summation as in real analysis?
12:11:04 <jmcarthur_work> lpsmith, i'm not sure. if that's what it illustrates then i think it might be a demonstration of nontermination as a side effect
12:11:10 <lysgaard> dino-: That's to much just to get a refactorer working.
12:11:45 <lpsmith> nontermination is a computational effect, but not what I'd call a side effect.  hmm
12:11:56 <lysgaard> lilac: You know why hare needs ghc-6.8.2?
12:12:18 <Trinithis> to screw in a lightbulb?
12:12:23 * leadnose thinks that pretty much anything that needs the notion of 'time' is kind of hard 
12:12:24 <lpsmith> I wonder what Doron Zeilberger would say about infinite summation...  he's an hyper-constructive ultra-finitist.
12:13:27 <Rotaerk> yea, wikipedia agrees "Side effects due to the time taken for an operation to execute are usually ignored when discussing side effects and referential transparency"
12:14:50 <lpsmith> And I know he wouldn't outright deny the summation formula for geometric series...
12:19:47 <Rotaerk> I'd say nontermination isn't itself a side effect, but it IS an indication that either 1) the function is broken, or 2) the function's purpose is to indefinitely cause side effects
12:20:27 <lpsmith> Rotaerk:  there is the issue of infinite nonproductive loops versus corecursive loops
12:20:50 <Rotaerk> you could say that the time a *terminating* function takes is a side effect, but one that ALL function have and thus not worth mentioning except in certain cases
12:20:58 <lpsmith> Like,  a webserver loop is non-terminating,  but it *should* be productive
12:21:28 <Rotaerk> (i.e. when the purpose of the function is to wait... or when discussing performance)
12:22:02 <Rotaerk> "infinite nonproductive loop" i think would fit into 1 ... broken
12:22:10 <lpsmith> so does ackermann(20,20) terminate?
12:22:25 <Rotaerk> I don't know that function *shrug*
12:22:39 <LeoD> it does, doesn't it? :p
12:22:43 <LeoD> after a rather long time?
12:23:20 <lpsmith> Theoretically,  sort of.  Theoretically, we couldn't ever build a computer to compute that value given all the energy and entropy of the universe either
12:24:00 <Rotaerk> so nonterminating is too strict of a word for what matters
12:24:28 <ray> ackermann(20,20) is not equivalent to bottom
12:24:47 <Rotaerk> pure functions should be *efficient*, not just terminating
12:24:56 <lpsmith> ray:  for all practical intents and purposes,  it is :-)
12:25:03 <Rotaerk> nonterminating pure functions are ... infinitely inefficient
12:25:22 <ray> well, it's not ever going to be evaluated, but that's a different issue based on silly laws of physics and stuff
12:26:27 <pikhq> I'm pretty sure ackerman(x,y) terminates for all real x and y.
12:26:35 <ray> yeah
12:26:39 <pikhq> (but I am lacking a proof)
12:26:46 <FunctorSalad> lpsmith: yes, it does terminate.
12:26:48 <FunctorSalad> ;)
12:27:06 <ray> it doesn't physically terminate on any computer that could possibly exist, but that's totally irrelevant
12:27:08 <FunctorSalad> math is an abstraction, the universe is irrelevant
12:27:16 <lpsmith> FunctorSalad:  from a certain point of view, yes :)
12:27:52 <Rotaerk> it'd work on a turing machine, that's all that matters
12:28:12 <Rotaerk> since they're not bound by the petty restrictions of "physics" and all that real nonsense
12:28:32 <lpsmith> Rotaerk:  I've never seen or touched a turing machine,  have you?  ;-)
12:28:55 <FunctorSalad> to be fair, some areas of math *are* concerned with how long it takes
12:28:58 <fxr> lpsmith: you're using one, with a limited memory.
12:29:05 <FunctorSalad> (complexity theory, numerics ...)
12:29:14 <Rotaerk> I almost did. the flying spaghetti monster offered one to me
12:29:17 <pikhq> I've seen one. Shame that it had a finite tape and wasn't universal.
12:29:18 <lpsmith> fxr:  then it's not a turing machine.   It's a finite state automaton.
12:29:37 <FunctorSalad> it's a mental object just like "3" is
12:29:44 <FunctorSalad> I haven't ever touched a 3.
12:29:48 <pikhq> lpsmith: Some Turing machines are FSAs. Not all Turing machines are Turing-complete. Just the universal ones.
12:29:53 <pikhq> ;)
12:30:04 <lpsmith> Of course,  for all practical intents and purposes,  I *am* using a turing machine at the moment ;-)
12:30:09 <Rotaerk> I thought there was just one turing machine
12:30:23 <Rotaerk> i.e. if it doesn't have infinite tape then it's only an approximation to the turing machine
12:30:25 <pikhq> Rotaerk: No, it's a class of machines.
12:30:35 <lpsmith> Even though technically it's a finite automaton
12:30:53 <pikhq> Some of them are universal, which means they can emulate all the others.
12:31:07 <Rotaerk> k
12:31:15 <lpsmith> I mean,  I have 4GB of ram,  and 4 * 2^(2^32)  is a *very* large number
12:31:28 <FunctorSalad> there is no pure threeness in reality either
12:31:40 <FunctorSalad> it's just a useful mental model :)
12:32:18 <fxr> who knows...
12:32:25 <lpsmith> and of course,  if you want to count the size of my hard drive,  and the size of the internet as it can communicate with most other computers in the world as well...  Yes, practically it is a turing machine.
12:32:27 <monochrom> What is pure threeness? The number 3?
12:32:27 <fxr> it's our language
12:32:40 <FunctorSalad> if you have three sheep than a theory of sheep would be more accurate than mere natural numbers, but also more complex
12:32:44 <FunctorSalad> s/than/then
12:32:57 <monochrom> Yeah.
12:33:15 <monochrom> It's all caused by the lead in the plumbing.
12:33:56 <rocketman> what
12:34:04 <lpsmith> Yeah, I'm not grokking it.
12:34:20 <rocketman> pikhq: the proof is very easy
12:34:22 <FunctorSalad> lead?
12:34:27 <monochrom> hehe
12:34:30 <rocketman> of ack termination
12:35:01 <FunctorSalad> monochrom: pure threeness... the concept of having three elements I suppose
12:35:06 <Rotaerk> you could say pure threeness is the concept of three... which has many associations
12:35:07 <FunctorSalad> (this is not circular)
12:35:27 <Rotaerk> the algorithm for counting to three... the numeric symbol for three...
12:35:36 <monochrom> three elements is more concrete and complex than just using peano axioms.
12:35:42 <FunctorSalad> just a shorthand for "of having a bijection to these dots: . . . "
12:36:18 <FunctorSalad> monochrom: thought we were on the informal level
12:36:32 <FunctorSalad> peano arithmetic would just be one encoding
12:36:33 <monochrom> There is no need to stay informal.
12:37:40 <MrN> this channel...
12:37:43 <monochrom> There is no need to consider peano axioms to be formal either, if you want to stay informal.
12:38:00 <rocketman> lol
12:38:36 <MrN> you really notice that most people are mathematicians in here
12:38:36 <Rotaerk> it's really a pretty informal thing, threeness
12:38:50 <rocketman> MrN, uhh.. this isn't math
12:38:51 <Rotaerk> it's no different from the concept of "dog"
12:39:01 <rocketman> MrN, it's philosophy
12:39:08 <bremner> MrN: where by mathematicians, you mean nerds
12:39:12 <Rotaerk> X is a dog if it fits closely with the other things known to fit under the concept of "dog"
12:39:21 <FunctorSalad> Rotaerk: yes. IMHO the informal thing precedes peano arithmetic or other encodings
12:39:28 <MrN> bremner: the nerds in ##c++ don't talk like you guys
12:39:44 <monochrom> OK I see, if I think of several compositions of succssors, you can say it's on par with several dots.
12:39:49 <Rotaerk> FunctorSalad, agreed
12:39:56 <fxr> it is generally considered by computer scientists that everyhing that is computable is computable by a turing machine
12:40:17 <rocketman> computable means what?
12:40:22 <lpsmith> fxr:  sort of
12:40:39 <Rotaerk> rocketman, research computation/information theory
12:41:21 <tromp_> fxr means that computer scientist can't think of any other better notion of computable than computable by TM
12:41:21 <rocketman> Rotaerk, um wondering for a def. that isn't "computable: can be computed by a turing machine"
12:41:23 <FunctorSalad> I think it was a rhetorical question ;)
12:41:32 <lpsmith> A turing machine connected to a GPS receiver can compute things that a turing machine cannot...
12:41:54 <MrN> do people ever talk about _programming_ in here? :P (and that doesn't include experiments with point-free notation)
12:41:56 <Rotaerk> although there is an aspect of the mind that isn't computable
12:42:06 <rocketman> :(
12:42:12 <Rotaerk> particularly: qualitative experience that maps to the state of the mind
12:42:17 <FunctorSalad> rocketman: there is an informal level involved in computability, isn't it? namely encoding your objects to an input to a turing machine, and decoding the machine's output back
12:42:20 <lpsmith> MrN:  yes :)
12:42:29 <FunctorSalad> that notion of "coding" seems informal
12:42:47 <MrN> lpsmith: then my random sample of peeks at this channel apparently isn't big enough :P
12:42:53 <Rotaerk> you can encode the concept redness into a computational/informational... but the experiencial quality of being red cannot be captured
12:43:08 <monochrom> Haskell has solved programming. All that can be said programming is already said in tutorials and the haskell wiki. That is why we drift to meta topics.
12:43:09 <tromp_> we're only talking about computablility of functions from binary strings to binary strings
12:43:16 <FunctorSalad> fxr: that statement is known as the "Church-Turing thesis", btw (for googling)
12:43:42 <dubhrosa> MrN: I think everyone else here is actually a bot modelled on a 1st year comp sci student who read half of "Emperor's new mind"
12:43:44 <fxr> FunctorSalad: nice start
12:43:47 <Rotaerk> I think of it as ... my qualitative experiences are the informational model of my mind being rendered to some mysterious observer (which it seems appropriate, by tradition, to refer to as the soul)
12:43:54 <SamPointon> hi guys, having a TH problem: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3117#a3117 This is an effort to get around the stage restriction, and in the real code the 'Foo' type isn't so simple
12:44:01 * rocketman thinks that just because you are talking about philosophy doesn't mean you that it's ok to start talking nonsense
12:44:30 <Rotaerk> nonsense?
12:44:54 <MrN> dubhrosa: everyone else as in everybody except you?
12:45:19 <monochrom> Please don't be too mathematical about "everyone else"...
12:45:20 <FunctorSalad> now it's ethics? ;)
12:45:50 <Rotaerk> rocketman, I wasn't talking nonsense
12:45:59 <dubhrosa> MrN: and those wondering why so few people are discussing haskell... forgive me, I've just returned from a solipsists conference, I all had a great time
12:46:07 <rocketman> well can you define computable?
12:46:48 <MrN> i think SamPointon actually has a haskell question
12:46:51 <leadnose> there was this time when I stumbled upon "general abstract nonsense" in wikipedia...
12:46:59 <rocketman> MrN, feel free to answer it
12:47:08 <MrN> rocketman: i would if i knew sufficient haskell.
12:47:16 <rocketman> MrN, I looked at hdis paste and didn't know either
12:47:36 <fxr> rocketman: computable can best described relative to a given model of computation.
12:47:40 <FunctorSalad> leadnose: that generally refers to CT
12:48:15 <rocketman> fxr, that means the question was a circular one.. or a tautology
12:48:32 <Rotaerk> rocketman, there are many definitions of computation http://en.wikipedia.org/wiki/Theory_of_computation#Other_formal_definitions_of_computation
12:48:32 <leadnose> FunctorSalad, yeah, I found out that much :)
12:49:01 <rocketman> Rotaerk: Again that's all just saying "what a turing machine computes"
12:49:11 <Twey> @quote monochrom Haskell has solved programming. All that can be said programming is already said in tutorials and the haskell wiki. That is why we drift to meta topics.
12:49:11 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
12:49:17 <Twey> @remember monochrom Haskell has solved programming. All that can be said programming is already said in tutorials and the haskell wiki. That is why we drift to meta topics.
12:49:17 <lambdabot> Done.
12:49:28 <monochrom> hehe
12:49:37 <FunctorSalad> SamPointon: not sure what exactly you're trying to do, but generally one workaround is to use the syntax tree combinators rather than quotation
12:49:44 <rocketman> I have been trying to make sense of "it is generally considered by computer scientists that everyhing that is computable is computable by a turing machine"
12:49:58 <rocketman> I don't know what the first "computable" means
12:50:07 <monochrom> No one knows for sure. That is why.
12:50:10 <FunctorSalad> SamPointon: I never really looked into the "Lift" class though, maybe you can write an instance for Foo
12:50:17 <SamPointon> FunctorSalad: unacceptably horrific, the real code inside the quotation is quite a lot more complicated
12:50:21 <rocketman> okay so it's basically a nonsense statement
12:50:26 <tromp_> it means: computable in principle by  a human with infinite supply of paper and time
12:50:51 <Rotaerk> rocketman, http://en.wikipedia.org/wiki/Effectively_calculable
12:50:55 <SamPointon> FunctorSalad: yes, that's an option as well, but the documentation seems a little thin on the ground for it
12:50:57 <tromp_> well, arbitrary amount of time:)
12:51:37 <rocketman> that is the same thing rephrased
12:51:48 <Rotaerk> rocketman, no it isn't
12:52:03 <monochrom> Perhaps #haskell-blah?
12:52:34 <Rotaerk> rocketman, you're complaining that computability is defined as being "whatever a turing machine can compute", and thus "what's so special about a turing machine"
12:52:39 <fxr> rocketman: well you can easily compute sum of numbers [1..10] with a turing machine. An uncomputable function however is Turing's halting function. That concludes examples of computable and uncomputable.
12:52:58 <fxr> rocketman: but there are semi-computables also .
12:53:03 <rocketman> Rotaerk: I read that page as "there exists some algorithm that runs on a turing machine"
12:53:16 <rocketman> but am I mixing it up?
12:53:23 <FunctorSalad> SamPointon: couldn't you just put "Foo" where "foo" is now in the quotation? (depends on what the real situation is I guess)
12:53:30 <Rotaerk> rocketman, however in this case it's indicating that the term "computation" describes the process of following some algorithm or rule-set for deriving expressions from expressions.
12:53:47 <dons> someone organizing an SF FP meetup https://spreadsheets.google.com/viewform?formkey=dDFtWnQ3dzMzOGcxOGVoNFpFckM4dGc6MA
12:53:49 <rocketman> fxr, ty (have studied those two examples before btw)
12:53:54 <Gracenotes> Turing machine, according to CT thesis, can run any finite algorithm.
12:54:11 <Gracenotes> finitely described algorithm, that is, in terms of number of steps..
12:54:18 <fxr> Gracenotes: you mean mathematically harnessable?
12:54:22 <SamPointon> FunctorSalad: in the real code, it's a database schema, which is quite sensitive to DRY violations
12:54:40 <Rotaerk> rocketman, and a function is described as computable or "effectively calculable" if there exists a terminating algorithm for arriving at resolving that function
12:54:42 * rocketman is the only one that joined -blah ...
12:55:04 <monochrom> That's the problem. People don't care about #haskell-blah
12:55:09 <Gracenotes> unfortunately, attempts to formalize algorithm haven't succeeded too well, but I like to call it a series of steps manipulating symbols (alphabets), whether these symbols are numbers/letters/whatever
12:55:14 <FunctorSalad> monochrom: I do :-(
12:55:19 <rocketman> Rotaerk: yeah but algorithm has to run on something,  it runs on a turing machine -- we've got nowhere!
12:55:32 <Rotaerk> rocketman, no, algorithm doesn't have to run on something
12:55:37 <SamPointon> oh well, it's not a critical problem, just means I have to move more code into splices
12:55:42 <Gracenotes> fxr: perhaps.. I'm not familiar with the term
12:56:05 <Rotaerk> well no
12:56:07 <FunctorSalad> the CT-thesis says that the intuitive idea of computability is the same as what a turing machine can do, rocketman
12:56:13 <Rotaerk> rocketman, people can execute algorithms
12:56:15 <FunctorSalad> it's not a mathematical statement.
12:56:22 <rocketman> Rotaerk: then my algorithm can use an oracle to  tell halting problem?
12:56:29 <Rotaerk> an algorithm is just a sequence of steps... describable as a sequence of instructions
12:56:45 <Rotaerk> which something capable of interpreting and executing those instructions carries out
12:57:11 <fxr> Gracenotes: mathematically harnessable means a process P's input/output behavour is either deterministic or approximately deterministic with the chance/size of error able to be reduced to an arbitrary small amout
12:57:31 <rocketman> you must specify what steps are allowed, can I add? can I branch, loop? call upon a halting oracle?a
12:57:38 <fxr> Gracenotes: and has a finite matematical defn which can come to be known through science
12:57:46 <rocketman> this is why it seems circular to me
12:57:52 <Rotaerk> rocketman, anything something can do is a possible step
12:58:00 <fxr> rocketman: yeah I understand your thinkin
12:58:02 <rocketman> hehe
12:58:10 <rocketman> I guess "anything something can do" works
12:58:10 <Rotaerk> 1. collect pants, 2. ???, 3. profit!
12:58:15 <Rotaerk> an algorithm, sortof
12:58:19 <Rotaerk> underpants*
12:58:21 <FunctorSalad> rocketman: as I see it, the answer to the CT-thesis depends on whether you can get hold of a halting problem oracle in the real world
12:58:22 <rocketman> but I don't know it's a bit informal :p
12:58:23 <Gracenotes> fxr: perhaps, but something that can be proved equivalent to computability
12:58:45 <fxr> rocketman: you want applications but the topic is very theoretical.
12:58:54 <Rotaerk> rocketman, you can describe DNA as an algorithm
12:58:59 <Rotaerk> or a program
12:59:03 <FunctorSalad> rocketman: of course it's informal. it's the question of whether the formalism is adequate in the first place
12:59:07 <Rotaerk> describing how the mechanisms of the cell should behave
12:59:20 <Rotaerk> the cell effectively becomes a computer
13:00:12 <Rotaerk> well no, I guess a "computer" is a special kind of algorithm-executing machine
13:00:14 <fxr> Rotaerk: you're making very nice analogies
13:00:56 <Saizan_> that the definition of "effectively computable" is infomal is not controversial i guess, that's why you can't prove the CT-thesis
13:01:49 <Rotaerk> particularly a computer is a machine that executes instructions with the purpose of transforming data... or something along those lines
13:02:14 <Rotaerk> a human can, then, act as a computer, but it is also capable of other kinds of algorithms
13:02:16 <lpsmith> Saizan_:  I had an idea once,  that I thought might be able to lead to a formal statement reminscient of the CT thesis, and maybe a formal proof.   I forget what that idea was though...
13:02:33 <Rotaerk> a PC is also more than a computer, given that definition, as it can *move* data around too
13:02:41 <Rotaerk> *shrug* I'm just thinking "out loud"
13:03:47 <Saizan_> lpsmith: that's a shame :)
13:04:55 <monochrom> Hi I have a metaprogramming question. I don't mean templates, macros, stages kinds of metaprogramming. I mean a topic about and above programming, i.e., meta (programming) rather than (meta program)ming.
13:05:21 <Rotaerk> how meta-(metaprogramming) of you
13:05:45 <monochrom> So anyway here it is. Why is Haskell considered a functional programming language? What is functional programming language and how does Haskell satisfy the criteria?
13:05:47 <dons> this should have been in haskell http://www.rethinkdb.com/learn-more/#lock-free-concurrency
13:06:10 <MisterN> monochrom: ask wikipedia. duh.
13:06:10 <monochrom> </troll purpose="back to on-topic">
13:06:18 <dons> functions are the objects manipulated in such a language?
13:07:09 <lpsmith> Well, my own take is that there are functional programs and imperative programs.   Saying a language says more about how the community tends to use it than the language itself.
13:07:09 <dons> function abstraction, application and composition should have the shortest syntax :)
13:07:33 <lpsmith> err, saying a language is functional or imperative says more,  I mean
13:07:43 <dino-> I had been thinking that it has to do with having first-class functions. i.e. functions as data without resorting to pointers.
13:08:05 <lpsmith> But clearly,  some languages encourage functional programming,  while others make it totally impractical.
13:10:02 <lpsmith> dons, dino-:  what about functional languages that aren't higher order?   What are those in your terminologies?
13:10:11 <dons> first or zeroth-order support for FP
13:10:24 <jmcarthur_work> i'm also curious where this puts "denotational programming," as conal likes to say
13:10:40 <dino-> I had also noticed in the past how we don't really point at things in Haskell and say "that's a closure" or ever use that word at all. It's something more natural here.
13:10:46 <dons> it seems these days that pretty much every language claims to be functional
13:11:03 <dons> ruby and python, in particular. i see many claims of functional ruby.
13:11:25 <dons> dino-: everything's a closure :)
13:11:28 <MisterN> c++ is functional too.
13:11:34 <troutwine> The claims mostly center around "we can do nifty things with lists", it seems to me.
13:11:46 <jmcarthur_work> functional is a rather poor distinction to make with other languages, really
13:12:04 <dons> things with lists, or maybe function abstraction. sometimes closures.
13:12:27 <jfoutz> prolog can do nifty things with lists. and it's declarative.
13:12:45 <jmcarthur_work> i think the more interesting thing is not that functions are first class, but that functions are easily composable
13:13:27 <jmcarthur_work> and types, eventually, although we aren't quite there yet
13:13:58 <jmcarthur_work> that is not what makes it "functional" though, which is why i'm not sure about the term
13:14:15 <jmcarthur_work> i'm not sure about "denotational" either, as i am still not sure i fully understand the meaning of the word
13:14:30 <FunctorSalad> I guess FP means "these languages: lisp, MLs, haskell, ... and those similar to them"
13:14:45 <FunctorSalad> :)
13:16:04 <Rotaerk> functional languages are ones whose primary algorithm specification method is in terms of functional programming, but they can also support procedural code... procedural languages vice versa (C# is procedural but supports lambdas)
13:16:38 <Saizan_> so, how do you define functional programming?:)
13:17:08 <dino-> What are some examples of languages that are considered functional but aren't higher order? What lpsmith asked above.
13:17:19 <SamPointon> Saizan_: I knows it when I sees it!
13:17:19 <MisterN> FunctorSalad: this definition seems relatively good.
13:17:41 <Rotaerk> although I suppose it's not "algorithm specification method" so much as "expression paradigm"... procedural code is about describing algorithms for computing, and functional code is about describing expressions to be computed
13:17:45 <ski> dino- : iirc, Erlang was not higher-order at the beginning ..
13:20:57 <fxr> Functional programming is a style of programming that emphasizes the use of functions (in contrast to object-oriented programming, which emphasizes the use of objects). - editorial review of The haskell school of expression
13:21:27 <fxr> what a review :)
13:21:38 <Rotaerk> imo object oriented isn't comparable to FP, because it's not there to address the same problem
13:21:40 <Plouj> oumm
13:21:47 <Plouj> what the heck is going on with my setup:
13:22:10 <Plouj> http://fpaste.org/paste/20309
13:22:22 <Rotaerk> OO is better compared to a pattern matching and discriminated unions, common in but not restricted to functional programming languages
13:22:42 <Rotaerk> -a
13:22:55 <Saizan_> Plouj: tried running ghc-pkg check?
13:23:00 <monochrom> TXL is a first-order FPL.  http://en.wikipedia.org/wiki/TXL_(programming_language)
13:23:01 <Rotaerk> since they're opposing sides of the expression problem
13:23:15 <Plouj> Saizan_: it shows a crapola amount of missing files
13:23:37 <pragma_> so how'd he get the marshmallows in his butt then?
13:23:39 <Saizan_> Plouj: it seems you've deleted something that you shouldn't have!
13:23:46 <monochrom> dino-: please see my previous sentence
13:24:00 <pragma_> er, disregard
13:24:06 <Plouj> Saizan_: http://fpaste.org/paste/20310
13:24:11 <Plouj> Saizan_: is there a way to fix it?
13:25:12 <Saizan_> Plouj: reinstall the packages i guess
13:25:17 <ski> (Rotaerk : yes)
13:25:58 <Saizan_> Plouj: GLUT and OpenGL i mean
13:27:56 <burp> why does read throw exceptions? wouldn't it be better to return Maybe?
13:28:16 <augustss> burp: use reads
13:28:50 <augustss> burp: but yeah, there should be a version returning a Maybe
13:29:12 <ski> @type \s -> case reads s of [(a,"")] -> Just a; _ -> Nothing
13:29:14 <lambdabot> forall a. (Read a) => String -> Maybe a
13:29:24 <burp> ah reads.. fine :)
13:29:43 <Vulpyne> maybeRead x = case reads x of { [(y,"")] -> Just y; _ -> Nothing }
13:30:04 <burp> thanks
13:30:38 <Vulpyne> That'll return nothing if there's anything remaining after the part that could be parsed, you can change the "" to _ if you want it to just parse as much as it could.
13:30:39 <augustss> You might want to replace "" with something that allows trailing whitespace
13:30:42 <lpsmith> dino-:  Erlang was another example,  although it added higher-order functions at some point.   I forget when.
13:31:18 <jmcarthur_work> > read "5 "
13:31:19 <lambdabot>   * Exception: Prelude.read: no parse
13:31:23 <jmcarthur_work> > read "5"
13:31:24 <lambdabot>   * Exception: Prelude.read: no parse
13:31:28 <jmcarthur_work> > read "5" :: Int
13:31:29 <lambdabot>   5
13:31:30 <jmcarthur_work> > read "5 " :: Int
13:31:32 <lambdabot>   5
13:31:46 <jmcarthur_work> okay, i never paid attention to whether whitespace would confuse read or not
13:31:56 <lpsmith> > read " 5 " :: Int
13:31:58 <lambdabot>   5
13:32:13 <lpsmith> > read " 5 3 " :: Int
13:32:15 <lambdabot>   * Exception: Prelude.read: no parse
13:32:27 <Vulpyne> maybeRead x lax = case reads x of { [(y,rest)] -> if lax || all isSpace rest then Just y else Nothing; _ -> Nothing }
13:33:14 <benmachine> > reads "    4" :: [(String, String)]
13:33:15 <lambdabot>   []
13:33:16 <lpsmith> > read "()"
13:33:17 <lambdabot>   ()
13:33:20 <benmachine> er
13:33:24 <augustss> > reads "5 " :: [(Int, String)]
13:33:24 <benmachine> > reads "    4" :: [(Int, String)]
13:33:26 <lambdabot>   [(4,"")]
13:33:27 <lambdabot>   [(5," ")]
13:33:54 <Vulpyne> Huh, so it strips the preceding whitespace.
13:34:09 <augustss> yep
13:34:18 <lpsmith> >   reads  "    5" :: [(String, Int)]
13:34:19 <jmcarthur_work> > reads "5 4 3 2 1" :: [(Int, String)]
13:34:19 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:34:20 <lambdabot>   [(5," 4 3 2 1")]
13:35:25 <lpsmith> > reads "53 4" :: [(Int, String)]
13:35:26 <lambdabot>   [(53," 4")]
13:36:16 <jmcarthur_work> > reads "53.4" :: [(Int, String)]
13:36:17 <lambdabot>   []
13:36:29 <lpsmith> > reads "(53) 4" :: [(Int, String)]
13:36:31 <lambdabot>   [(53," 4")]
13:36:59 <pikhq> @src reads
13:36:59 <lambdabot> reads = readsPrec minPrec
13:37:05 <andrewe> hi all
13:37:12 <ski> @index minPrec
13:37:12 <lambdabot> Text.ParserCombinators.ReadPrec, Text.Read
13:37:13 <pikhq> I don't know why I though that would be helpful.
13:37:34 <augustss> it is helpful :)
13:37:50 <lpsmith> pikhq:  referring to the parens?
13:38:09 <pikhq> lpsmith: No, to the src for reads.
13:38:10 <andrewe> what's the deal with tail recursion? shouldn't it speed up execution?
13:38:37 <augustss> andrewe: depends on circumstances
13:38:46 <lpsmith> andrewe:  tail recursion works a bit differently in Haskell than say, Scheme
13:39:16 <andrewe> I implemented a faculty version without tail recursion and one with.
13:39:24 <lpsmith> andrewe:  not to mention that tail recursion is more about conserving stack space and being able to express iteration than speed, per se
13:39:31 <andrewe> And I was surprised that the recursive one is faster.
13:39:34 <monochrom> "tail recursion speeds up" is under an assumption about evaluation order that is broken here.
13:39:36 <augustss> andrewe: and did you compile with -O2?
13:39:41 <augustss> Or -O?
13:39:57 <andrewe> I tried both.
13:40:01 <fnord123> Are we comparing tail recursion vs. non tail recursion?
13:40:04 <ski> (presumably s/faculty/factorial/ ..)
13:40:12 <fnord123> or tail recursion vs. iteration?
13:40:14 <andrewe> ski: thanks
13:40:22 <lpsmith> andrewe:  though tail recursion is quite helpful for efficiently implementing finite state machines :-)
13:40:55 <fnord123> lpsmith: that's tail call optimization. tail call recusion is a special case of tco. :)
13:41:41 <Vulpyne> readz x = case reads x of { [(y,rest)] -> y:readz rest; _ -> [] }
13:42:05 <andrewe> fnord123: tail recursion vs. non-tail recursion
13:42:32 <lpsmith> fnord123:  true enough... though I never liked the phrase  "tail call optimization"... it makes people think a compiler rewrites something into a while loop before the machine code is generated, which is not really the case...
13:42:43 <jfoutz> andrewe: extra thunks in the tail recursive version?
13:42:55 <augustss> andrewe: what type does your function have?
13:43:58 <monochrom> Please don't paste the code. We don't want to see it.
13:44:07 <copumpkin> lol
13:44:20 <ski> lpsmith : "proper tail call" ?
13:44:29 <andrewe> fac 0 = 1
13:44:29 <andrewe> fac n = n * fac (n-1)
13:44:35 <fnord123> lpsmith: in the case of tail recursion, it is written as the assembly equivalent of a while loop.
13:44:37 <andrewe> recursive version
13:44:48 * jfoutz giggles
13:44:53 <lpsmith> ski:  "proper tail call handling"  is fine, though a bit more cumbersome :-)
13:45:04 <andrewe> fac' 0 a = a
13:45:04 <andrewe> fac' n acc = fac' (n-1) (n*acc)
13:45:18 <andrewe> fac n = fac' n 1
13:45:24 <SamPointon> andrewe: that's not strict, it builds up a huge thunk
13:45:40 <augustss> SamPointon: not with -O
13:45:42 <mmorrow> fac' is since it has to check for 0 every loop
13:45:42 <TheColonial> hey guys. is lambdabot's code available? is there some way of cloning him and using him for another language?
13:45:42 <andrewe> how do I make it strict
13:45:48 <fnord123> in any event, tail recursion is generally quicker as it omits the need to add a frame pointer and simply sets the argument registers and jumps to the first instruction of the next function as far as I'm aware; unless there's some other optimization that modern compilers are using these days
13:46:05 <mmorrow> err
13:46:07 <mmorrow> my bad
13:46:15 <augustss> andrewe: it's fine, the strictness analyzer does the right thing
13:46:22 <SamPointon> augustss: ah, alright. I can never remember just how much analysis GHC can and can't do with strictness and laziness
13:46:24 <Vulpyne> TheColonial: The code is available, but you'd probably have to do some work to make it work with another language.
13:46:33 <augustss> andrewe: try giving it type Int->Int
13:46:38 <mauke> fac' (n-1) $! (n*acc)
13:46:40 <monochrom> Hmm maybe I can understand the generated core code.
13:46:40 <hackagebot> hums 0.2.3 - Haskell UPnP Media Server (BardurArantsson)
13:46:48 <Vulpyne> TheColonial: http://www.haskell.org/haskellwiki/Lambdabot
13:46:53 <monochrom> Aw, Int is not very useful for factorials!
13:47:12 <TheColonial> Vulpyne: sure thing. I'm happy to do a bit of work :) It might not support actual language features, but referencematerial at least. thanks for the link!
13:47:29 <augustss> Doesn't matter if the type is Int.  The answer is not interesting, just the time :)
13:47:42 <augustss> If not Int, use Double
13:47:47 <monochrom> hahaha
13:48:15 <glguy> for large values you could do a bounds check and return Infinity quite quickly :)
13:48:56 <lpsmith> I've noticed that  (sum [1..10e7]  :: Double)  overflows the stack even if I compile -O2,  is this a bug?
13:49:03 <augustss> For the type Integer I would expect the two versions to be very similar since almost all time is spent in * for Integer
13:49:53 <andrewe> mauke: I don't understand that
13:49:54 <augustss> lpsmith: sounds bad
13:50:03 <mauke> > let fib n | n < 2 = 1 | otherwise = round . (*) (0.5 + sqrt 1.25) . fromIntegral . fib $ n - 1 in fib 12
13:50:05 <lambdabot>   233
13:50:05 <monochrom> The source code of sum is not very fast and not very susceptible to optimizations, IIRC
13:50:08 <mauke> > let fib n | n < 2 = 1 | otherwise = round . (*) (0.5 + sqrt 1.25) . fromIntegral . fib $ n - 1 in fib 11
13:50:10 <lambdabot>   144
13:50:32 <SamPointon> @src sum
13:50:32 <lambdabot> sum = foldl (+) 0
13:50:49 <jfoutz> hmm. yeah maybe add a ' in there.
13:50:52 <SamPointon> lpsmith: not surprising it blows the stack thne
13:51:05 <jfoutz> @src product
13:51:05 <lambdabot> product = foldl (*) 1
13:51:06 <augustss> monochrom: the sum functions should have specializations for base types, otherwise I think the ghc libraries are broken
13:51:31 <monochrom> Hmm, ghc -fext-core ...
13:51:32 <lpsmith> SamPointon:  well, the strictness analyzer should handle that case,  unless I'm missing something
13:51:52 <glguy> seems broken if sum is only useful on base types
13:52:31 <lpsmith> SamPointon:  Used with Int or Integer,  it'll overflow the stack unless you compile -O to turn on strictness analysis
13:52:35 <augustss> glguy: I don't consider it broken to be faster in some cases than to be fast in no cases
13:53:04 <glguy> augustss: It just seems to fix a symptom and not the problem
13:53:26 <glguy> if it stack overflows on some special types , and not others
13:53:26 <augustss> glguy: agreed
13:54:13 <glguy> SamPointon: ?src results are not necessarily what GHC's base uses
13:54:25 <dons> augustss: they have specializations for Int and Integer
13:54:30 <augustss> glguy: but i'm not sure the stack overflow can be avoided by any simple means and still preserve the semantics of sum.
13:54:33 <andrewe> mauke: thanks for the hint ($!)
13:54:37 <dons> but should have them for all primitive numeric types
13:54:44 <andrewe> good night
13:55:15 <Saizan_> augustss: or we could change them
13:55:24 <glguy> dons: but SPECIALIZATION is a hack if it is only available in the defining module
13:55:35 <dons> sum     l       = sum' l 0
13:55:35 <dons>   where
13:55:35 <dons>     sum' []     a = a
13:55:35 <dons>     sum' (x:xs) a = sum' xs (a+x)
13:55:42 <glguy> an ugly form of limited type-classes
13:55:57 <dons> is the implementation ghc uses. it then generates specialized, monomorphic versions at other types
13:56:03 <augustss> yeah, SPECIALIZE is a hack
13:56:21 <dons> better than minimum/maximum, which use rewrite rules
13:56:30 <dons> {-# RULES
13:56:30 <dons>   "minimumInt"     minimum = (strictMinimum :: [Int]     -> Int);
13:56:30 <dons>   "minimumInteger" minimum = (strictMinimum :: [Integer] -> Integer)
13:56:30 <dons>  #-}
13:56:39 <glguy> specializations are a different hacky than rewrite rules?
13:56:47 <dons> they're both hacky. :)
13:56:54 <dons> the other way is INLINE and worker/wrapper, then pray
13:57:12 <dons> all three techniques are used in Data.List currently
13:57:18 <augustss> It should all be specialized away by the compiler automatically
13:57:20 <glguy> well, isn't one option to have a typeclass with a default definition if you want to vary the implementation by type?
13:57:37 <augustss> it's know technology, just not applied in ghc
13:57:41 <glguy> so that it is relevant to user-defined types
13:57:46 <augustss> s/know/known/
13:57:47 * monochrom LOLs at the core code regarding the Num dictionary part. (tpl3::t -> t -> t) (tpl4::t -> t -> t) (tpl5::t -> t -> t) ...
13:57:52 <dons> ghc will get it if it is inlined
13:58:29 * monochrom tries Int now.
13:58:41 <dons> here's a reimplementation that only uses INLINE, iirc, http://code.haskell.org/~dons/code/stream-fusion/Data/List/Stream.hs
13:58:59 <augustss> Basically, I don't think there should be any polymorphism left in a well optimized program (except to deal with polymorphic recursion)
13:59:16 <dons> agreed.
13:59:21 <tommd> What ever happened to the restrictively licensed GHC-IPhone cross compiler code?  Is that still seeking upstreaming and promising a better license?
13:59:36 <dons> and I think GHC is actually acceptable now, just Data.List has left overs from an older time
13:59:45 <dons> it has ghosts of previous hacks
13:59:51 <copumpkin> lol
14:00:11 <glguy> having to specify the correct combinations of INLINE is only a little better
14:00:17 <augustss> dons: we're still waiting for the stream fusion version of the list functions...
14:00:21 <glguy> the {-# magic goes here #-} is unfortunate
14:00:24 <dons> well, its on hackage.
14:00:39 <dons> i'm not sure we'll ever redo the concatMap fusion code in GHC though
14:01:10 <dons> glguy: have you read "Secrets of the Glasgow Haskell Magic Compiler"?
14:01:17 <dons> oh, i mean, "Glasgow Haskell Inliner"
14:01:45 <glguy> nope
14:02:05 <tommd> dons: What do you think of Sept 25, 26, 27 for a hackathon?
14:02:10 <dons> mmm!
14:02:10 <Vulpyne> Isn't Data.Stream a drop-in replacement for Data.List?
14:02:16 <dons> Vulpyne: Data.List.Stream
14:02:22 <tommd> I'll reserve a room if there are no conflicts.
14:02:26 <dons> at PSU?
14:02:31 <tommd> Yep
14:02:35 <dons> checking around.. gimme 5 mins
14:02:53 <dons> Fri, Sat, Sun
14:03:05 <tommd> Yep - where you wanting a weekday?
14:03:11 <Vulpyne> Might it replace the default Data.List at some point?
14:03:12 <dons> nope, looks good.
14:03:16 <tommd> It doesn't matter to me - all days are the same.
14:03:18 <dons> let me just check withother galwegians
14:03:33 <dons> Vulpyne: back in a sec to explain. hang on.
14:03:41 <SamB> dons: and that word is supposedly related to galois?
14:03:44 <Vulpyne> No rush. :)
14:04:32 <dons> tommd: go for it. looks good
14:05:00 <tommd> dons: Great - I'll reserve rooms and equipment.  Expect to see some sort of announcement soon.
14:05:06 <dons> Vulpyne: so if it was just the library code, we'd be fine. stream-fusion on hackage is a drop in replacement. same API, same strictness semantics, better optimization.
14:05:11 <dons> Vulpyne: but that's not the full story.
14:05:12 <lpsmith> augustss:  how would that impact code size on typical programs?   I mean,  one could certainly craft pathological cases that would lead to substantial increases in code size...
14:05:20 <dons> ghc still has to desugar Enum and list comprehensions
14:05:31 <dons> and it does by generating build/foldr versions of the constructs
14:05:33 <dons> which don't fuse.
14:05:37 <Vulpyne> Ah.
14:05:47 <SamB> dons: you mean, they don't stream fuse
14:05:49 <dons> so to do that right, we have to hack GHC, and come up with a better formulation for concatMap fusion under streams
14:05:59 <dons> which needs the static argument transformation, amongst other things.
14:06:05 <lpsmith> well, maybe not quite pathological increases in code size...
14:06:11 <dons> i think possibly all the required bits are now in ghc though
14:06:24 <Vulpyne> Thanks for the information.
14:08:13 * lpsmith tries to think of a case where eliminating all polymorphism would lead to non-linear increases in code size...
14:08:30 <augustss> lpsmith: you could craft such examples, but for normal programs I would not be surprised if they shrink
14:11:31 <Baughn> @tell conal I think I've gotten it working. Looks working. I've got one AdditiveGroup instance for adoption, too (Int64); it's a poor little orphan right now.
14:11:31 <lambdabot> Consider it noted.
14:13:04 <Baughn> @tell conal ..well, it's basically identical to the ones you've got, so please just add AdditiveGroup instances for the Data.Int stuff?
14:13:05 <lambdabot> Consider it noted.
14:18:12 <Plouj> hey
14:18:19 <Plouj> what does !Keysym mean here: http://hackage.haskell.org/packages/archive/SDL/0.5.5/doc/html/Graphics-UI-SDL-Events.html#v%3AKeyDown ?
14:18:27 <Plouj> and how can I access it? :)
14:18:42 <mauke> pattern matching
14:19:51 <Vulpyne> The exclamation mark means it's strict.
14:19:59 <Baughn> Plouj: Keysym is a type. The bang means it's strict, eg. if the thunk that made the Event is forced, so is the one for the keysym.
14:20:25 <Plouj> umm
14:20:33 <Baughn> PeakerWork: Ping
14:20:44 <Plouj> I don't know what that means or how that helps me figure out what key caused the event
14:21:00 <mauke> have you considered learning basic haskell?
14:21:07 <Plouj> mauke: me?
14:21:10 <mauke> yes
14:21:11 <Vulpyne> When you get an Event, you can match on the type of event with something like: case event of { NoEvent -> whatever; (KeyDown ks) -> whatever }
14:21:17 <Plouj> mauke: I'm on chapter 7 or real world haskell.
14:21:34 <Vulpyne> Where ks would be the "Keysym" part of the KeyDown constructor.
14:21:48 <Plouj> Vulpyne: I see
14:22:15 <Vulpyne> As far as using it, you can ignore the exclamation part if that's what's confusing you.
14:23:01 <mauke> Plouj: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.pattern
14:24:09 <Plouj> mauke: humm, ok, I know how to do pattern matching, I think :)
14:30:42 <dons> tommd: so what do we call it HacPDX?
14:39:00 <kniu> @pl \x y -> return (foldl f x y)
14:39:01 <lambdabot> (return .) . foldl f
14:39:12 <kniu> @pl \x y -> (foldl f x y)
14:39:12 <lambdabot> foldl f
14:40:46 <monochrom> Hrm, -ddump-smpl is more readable than -fext-core !
14:42:36 <monochrom> Then again, the purpose of -fext-core is to be machine-readable instead.
14:46:08 <hydo> Is there an easier or, hell, a different way to figure out if a type that is defined as "x | XString String | XBool Bool etc." is an XString or XBool -besides- putting it through a case statement?  I'm speaking specifically about Text.RJson and it's JsonData type.
14:46:49 <monochrom> Using Int throughout, the recursion fac n a = fac (n-1) (n*a) gets optimized to the point Int# is used in the innermost code. Int# is directly machine int, not even "boxing" required by laziness, so it's going to be eager and stack-free.
14:46:50 <hydo> my case statements are mighty and I'm confident they fly in the face of "good haskell"
14:47:06 <bremner> hydo: write a pattern matching function?
14:47:28 <hydo> bremner: oh good god... thank you!  Not sure how I forgot about that again.
14:47:47 <bremner> isXString XString s = True and so on?
14:50:27 <tommd> dons: Haven't thought of a name.  HacPDX sounds as good as any, but I'll brainstorm a little.
14:52:02 <shepheb> tommd: what's the time frame here?
15:00:02 <mike-burns> Glancing through the backlog I think I see a discussion of another hackathon?
15:05:12 <dons> yeah, west coast this time
15:05:34 <davidL> dons: portland?
15:05:42 <mike-burns> Awesome. Hac Phi was so insanely great that it might be worth the long flight ...
15:06:20 <dons> hehe
15:06:23 <dons> davidL: yeah
15:06:30 <davidL> dons: when at?
15:06:45 <dons> late september. stay tuned for announcements
15:06:55 <davidL> excellent
15:07:07 <shepheb> argh! I fly back to Ontario at the end of August
15:07:18 <shepheb> there's always a Hackathon within range after I move away, apparently
15:07:32 <byorgey_> shepheb: that's how we decide where to hold them.  didn't someone tell you?
15:07:41 <ray> organize your own hackathon then!
15:10:30 <Baughn> conal: Ping
15:10:46 <conal> Baughn: hi
15:11:57 <Baughn> conal: Since \bot didn't say anything, I guess you've already got my message. I sent a mail to the reactive mailing-list, too; it's not nearly complete yet, but you might be entertained by looking at my approach.
15:12:23 <jmcarthur_work> if we had a hackathon in the southeast US i bet there would not be that many people that come :(
15:12:30 <jmcarthur_work> maybe if it was near the beach
15:12:53 <conal> Baughn: i'll look.  haven't checked my mail recently.
15:13:26 <LeoD> is Read really that slow (so i've heard)? if so, what library would you recommend to serialize and unserialize data?
15:13:40 <mike-burns> jmcarthur_work: I went to a conference at a Florida resort a year ago that was extremely relaxing and packed. Few people actually attended the conference though; it was mostly people networking outside in the pool.
15:14:23 <mike-burns> To be exact: the conference sold out of capacity and people showed, just no one went inside.
15:14:42 <erikc> LeoD: what are you serializing/unserializing?
15:14:47 <jmcarthur_work> mike-burns, i'm not sure whether to deem that a success or a failure. what would you say?
15:15:03 <LeoD> erikc: i'm writing a 2D rpg and somehow need to be able to save maps :)
15:15:15 <mike-burns> jmcarthur_work: I think it was a success; I met a ton of great people in that community as a result.
15:15:29 <mike-burns> jmcarthur_work: But it might not work for a hackfest.
15:16:34 <erikc> LeoD: i'd make an instance of Data.Binary
15:17:00 <tommd> shepheb: A couple days, perhaps.  Are you going to come?
15:17:18 <erikc> but only after I confirmed Read/Show werent fast enough
15:17:26 <tommd> AH, nevermind, I see the above.
15:18:31 <LeoD> erikc: well, Data.Binary is quite tedious to write instances for... if only there was some way to automatically derive them, as Read/Write :p
15:18:38 <LeoD> yea, i'll confirm that first :)
15:18:55 <shepheb> tommd: I meant the dates, not the time span. dons already answered late September. I'm flying back east at the end of August, so oh well.
15:19:06 <shepheb> I'll make one of them eventually!
15:19:55 <Baughn> LeoD: I have a feeling you know this, but there is
15:20:45 <LeoD> template haskell?
15:21:01 <tommd> @where th
15:21:02 <lambdabot> http://www.haskell.org/th
15:21:02 <Baughn> derive
15:21:20 <Baughn> LeoD: hackage://derive
15:22:01 <LeoD> oh, right..
15:26:29 <conal> i'd appreciate recommendations for formatting an external drive to be read & written from both linux and os x 10.5.7 .  probably more so linux than os x.
15:26:52 <ray> FAT
15:26:55 <jmcarthur_work> ugh
15:26:58 <benmachine> doesn't FAT suck
15:27:03 <benmachine> so I heard
15:27:30 <benmachine> http://en.wikipedia.org/wiki/Comparison_of_file_systems#OS_support
15:28:03 <ray> you want FAT, because everything can do it
15:28:08 <benmachine> unjournalled HFS+?
15:28:20 <ray> that is why usb sticks come preformatted FATwhatever
15:28:40 <Baughn> conal: Unjournalled HFS+
15:28:52 <Baughn> conal: Linux has a perfectly good HFS+ driver, so long as the journal is off
15:29:16 <conal> Baughn: i've been unable to get that working.  i turned off journaling, but still can't write in linux.
15:29:28 <Baughn> What does dmesg say?
15:30:02 <Baughn> conal: Actually - the journal is just a hidden file. Linux can't tell it's off.
15:30:10 <Baughn> conal: So you do have to mount with a force option
15:30:12 <conal> Baughn: in ubuntu, i right-click in the volume and see that create-folder is disabled
15:30:28 <dino-> OSX can't mount ext3 or something?
15:30:32 <Baughn> conal: Right.. check dmesg, seriously
15:30:51 <Baughn> dino-: OSX is quite impoverished when it comes to filesystems. Or drivers in general.
15:30:56 <dino-> (iow, something civilized)
15:31:04 <dino-> I see, that's a little sad.
15:31:12 <dino-> Apologies for the OT
15:31:20 <jmcarthur_work> i have not found that any OS really supports a lot of file systems
15:31:32 <jmcarthur_work> linux supports quite a few, especially with fuse, i suppose
15:31:46 <conal> Baughn: i see.  so hfs+ is much less convenient in linux than in os x.
15:31:51 <jmcarthur_work> but it never seems to fully support the exact one i need
15:32:02 <Baughn> conal: Only if you use GUI tools to mount it
15:32:16 <Baughn> jmcarthur_work: ..what filesystem would that be?
15:32:16 <conal> Baughn: yeah
15:32:42 <jmcarthur_work> Baughn, i've had issues with both HFS+ and NTFS before
15:32:56 <Baughn> jmcarthur_work: NTFS has patent issues, doesn't it?
15:33:10 <conal> wow -- that's a pretty grim table of file systems and compatibility
15:33:18 <jmcarthur_work> Baughn, doesn't change the fact that it sucks under linux
15:34:01 <Baughn> jmcarthur_work: Sure. Linux is /still/ better than any other OS at it.
15:34:16 <Baughn> conal: Well, you can always use VFAT
15:34:20 <Baughn> It stores files just fine
15:34:31 <conal> Baughn: what's vfat like?
15:34:36 <vav> Baughn: what kernel version are you on? thought linux hfsplus driver was read only in 2.6.28, but clearly could be wrong.
15:34:37 <ray> i heard it sucks
15:34:39 <ray> :)
15:34:42 <Baughn> conal: Bad.
15:35:04 <Baughn> conal: No unix permissions, no user/group ids, no device nodes, no fifos, no hardlinks, no symlinks, bad performance..
15:35:08 <ray> it's old, not very good, and can't handle files bigger than 4GB
15:35:10 <conal> ack. lose.
15:35:17 <ray> it's also readable and writable by everything :)
15:35:30 <conal> i really need serious suggestions.  i'm about to format my new drive.
15:35:31 <Baughn> It's the *only* thing that works everywhere, even
15:35:40 <Baughn> conal: That *was* a serious suggestion
15:35:53 <Baughn> conal: Anything else will only work with OS X and Linux, or only Windows and Linux, not all three
15:35:55 <dino-> Maybe ext2
15:36:00 <jmcarthur_work> conal, if you can keep a server running then a network share might be best :\
15:36:16 <Baughn> dino-: The osx ext2 driver crashed my computer last time I tried. Corrupted the filesystem, too. :/
15:36:22 <dino-> Baughn: bah
15:36:41 <conal> how about just os x & linux. forget windows.
15:36:50 <Baughn> HFS+ without journalling, then
15:37:05 <Baughn> You will have to mount it manually (or setup an fstab entry yourself), but otherwise it'll work fine
15:37:18 <Baughn> Of course, you should be using Arch, not Ubuntu. ;)
15:37:35 <conal> how about ntfs with macfuse?
15:37:37 <Baughn> conal: Actually, there /is/ a third option
15:37:43 <conal> yeah?
15:37:44 <Baughn> conal: ZFS
15:37:57 <p_l> Baughn: wait till it gets good recovery tools :D
15:38:03 <Baughn> Probably a good idea. :P
15:38:11 <jmcarthur_work> yeah, works under FUSE on both OSes, but it's not very production ready
15:38:16 <Baughn> And the linux ZFS driver seems to be abandoned
15:38:23 <Baughn> jmcarthur_work: No, Leopard has a native ZFS driver
15:38:39 <p_l> wasn't it read-only?
15:38:41 <jmcarthur_work> Baughn, oh yeah, forgot about that. still not really production ready though, isn't it?
15:38:49 <Baughn> jmcarthur_work: It's not well integrated with the bootloader and UI stuff yet, but it works fine as a filesystem
15:38:53 <mike-burns> How about using e.g. github to share the data between OSes? Or is that idea totally out of the question.
15:39:05 <Baughn> p_l: The one that ships is, but you can download a newer build
15:39:10 * p_l right now uses NTFS to share data, because he doesn't care about OSX
15:39:23 <Baughn> mike-burns: rsync to a network share. That's my approach,.
15:39:34 <Baughn> With sshfs
15:39:38 <p_l> also, why not ntfs-3g? it should compile
15:39:43 <p_l> Baughn: rsyncd?
15:39:59 <Baughn> p_l: rsyncd? No, just usual ssh-rsync.
15:40:00 * jmcarthur_work has been thinking about getting some low-power hardware and a few hard drives to run a file server w/ network share
15:40:05 <shapr> mapreduce: You called?
15:40:20 <p_l> Baughn: anyway, ntfs-3g should be usable under OSX with MacFuse
15:40:37 <p_l> and it has rather wide support for Unix-like fs
15:40:44 <conal> what's the "3g" in ntfs-3g?
15:40:50 <Baughn> jmcarthur_work: Get a core 2. There isn't much profit in using a weaker cpu, and you /will/ find uses for it.
15:40:57 <Baughn> jmcarthur_work: Especially if you also set it up as the firewall/router
15:41:04 <ray> ntfs-3g worked great for me on BSD
15:41:04 <p_l> conal: prolly "3rd generation"
15:41:09 <Baughn> conal: "Older"\
15:41:25 <Baughn> Current NTFS is.. v4, wasn't it?
15:41:32 <p_l> Baughn: 3.x
15:41:49 <Baughn> Hm. Yes, 3.1
15:42:19 <p_l> though I'm not sure about how versioning is applied to sub-volumes like "NTFS Log-Structured volume" or whatever it was called
15:42:24 <ray> if you can get hfs+ mounted on your linux, that's still best, because it's native for one of the systems in question
15:42:35 <ray> ntfs is native to neither
15:42:53 <Baughn> That, and you don't need fuse to mount hfs+ on linux
15:42:58 <Baughn> Performance of the hfsplus driver is quite good
15:42:59 <jmcarthur_work> Baughn, i don't really want to set up my file server as my first line of defense to the Internet...
15:43:04 <ray> yeah, not that fuse is bad
15:43:29 <p_l> jmcarthur_work: maybe get something with Arm, MIPS or PPC
15:43:52 <Baughn> jmcarthur_work: I don't think it's a problem for me, but that's mainly because the only exposed ports are ssh and http
15:44:05 <p_l> jmcarthur_work: without all the crap that many distros put in today, you'll probably find it completely over-powered :P
15:44:23 <jmcarthur_work> p_l, exactly
15:44:32 <Baughn> jmcarthur_work: Just isn't very much that can go wrong with a simple setup, if you keep on toes with your security updates
15:44:59 <jmcarthur_work> Baughn, i just like to be green, especially if it's actually cheaper than not ;)
15:45:06 <ray> don't go to all the trouble of using linux for some weird architecture, just use bsd
15:45:15 <jmcarthur_work> ray, that's the plan ;)
15:45:15 <Baughn> jmcarthur_work: Ah yes, greenness. :P
15:45:32 <Baughn> jmcarthur_work: Up here, that's no problem. We use electrical heating even in the middle of summer. ;_;
15:45:46 <p_l> "greenness" for me = 15MW pebble-bed nuclear reactor :3
15:46:07 <mapreduce> shapr: Just laughing at the get-shapr command. :)
15:46:07 * jmcarthur_work has been running AC almost nonstop for months
15:46:11 * Baughn prefers thorium reactors, mainly because the rock where he's sitting is several percent thorium
15:46:31 <p_l> Baughn: nothing stops you from using thorium in said reactor :D
15:46:48 <Baughn> p_l: I suppose not, but there are so many /other/ advantages to molten-salt reactors..
15:46:53 <shapr> mapreduce: Hey, it works... but sometimes there's a delay.
15:46:56 <Baughn> p_l: I'll admit that pebble-beds are great for districts
15:47:15 <conal> Baughn: is os x your main platform?
15:47:29 <p_l> Baughn: don't tell me you can't see any use for excess MWs of power? xD
15:48:00 <Baughn> p_l: MSRs get me that just fine, though. :P
15:48:15 <Baughn> They're also breeder reactors, so good efficiency. :3
15:48:28 <Baughn> conal: No. It was for a while, but then I learned to love xmonad, and hate Aqua.
15:48:54 <Baughn> conal: OS X just isn't comfortable, though. There are too many annoyances which I /can't touch/.
15:49:09 <conal> Baughn: that's what i'm finding also.
15:49:16 <ray> mac idiosyncracies are only not annoying if you "grew up" with them
15:49:28 <conal> i thought i could handle the switch, but i can't.
15:49:31 <Baughn> I'm pretty sure I'd find them annoying regardless
15:49:36 <idnar> ray: eh
15:49:46 <p_l> hmmm... it was supposed to be 4000 MW :P
15:49:47 <idnar> ray: they kinda threw all the old ones out, and replaced them with completely brand new ones
15:49:52 <Baughn> ray: I grew up with windows. This did not prevent me from ditching it at first opportunity.
15:50:05 * osfameron is thinking of running osx, with an ubuntu VM inside it
15:50:09 <ray> yeah, people do that sometimes
15:50:10 <conal> so i think i'll go back to linux.  which is why i want a file system that's dead simle for linux use.
15:50:12 <osfameron> that way I'd get working power managmemnt
15:50:28 <idnar> ray: I grew up with Macs (literally), but the last time I really used MacOS was circa System 7.5
15:50:30 <osfameron> (but a usable OS)
15:50:39 <idnar> ray: when I fiddle with someone's Mac now, I can't recognise anything
15:50:43 <ray> i haven't used an os x mac more than cursorily
15:50:52 <conal> besides the little oddities and the fighting between emacs & os x, haskell graphics doesn't work nearly as well on os x as in linux.
15:51:32 <jfoutz> haskell graphics makes me sad. how is it on windows?
15:52:19 <ray> workable, i suppose
15:52:25 <ray> i haven't tried much
15:52:36 <jfoutz> so, sort of like os x.
15:52:48 <nyingen> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3118#a3118
15:52:51 <ray> i wouldn't know
15:52:54 <nyingen> Any idea how this parsec error should be interpreted?
15:53:04 <nyingen> I feel like I need a type signature, but don't know what it must look like
15:53:33 <ray> windows haskell (and mac haskell) probably needs more testing
15:54:10 <jfoutz> ray: haskell itself has been great on osx. anything gui is real iffy though.
15:54:23 <copumpkin> yeah
15:54:40 <ray> i've encountered a few surprising dependencies on unix-whatever from hackage packages
15:54:43 <ppavelV6> not talking about graphics, GHC is quite good on OSX. It doesn't compile 64 bit though :(
15:54:47 <ray> i don't remember any specific ones
15:54:55 <ray> i should write this stuff down and report it, probably
15:55:48 <jmcarthur_work> i've not seen much bad about graphics on os x from ghc besides gui and running opengl stuff from ghci
15:56:02 <jmcarthur_work> it has mostly worked pretty well for me
15:56:18 <jmcarthur_work> oh, and having to write a c wrapper for main to use sdl
15:56:21 <ray> gtk2hs didn't want to play with the haskell platform either, and i could not find any info on how to register it myself
15:56:22 <ppavelV6> i'm not talking about graphics on Mac OSX because i didn't use it
15:56:43 <ppavelV6> i wrapped few functions from CoreGraphics when i need it
15:56:47 <glguy> Is 64-bit on OS X something that is in the works?
15:56:53 <glguy> low priority?
15:57:01 <jfoutz> jmcarthur_work: ohhhhh. i kept looking for some option to get SDL to do the right thing
15:57:20 <Baughn> glguy: Probably not going to happen while 64-bit code isn't fully supported by the OS X core libraries, at least
15:57:25 <jmcarthur_work> jfoutz, i've been meaning to share my work to the internet for a while now
15:57:28 <ppavelV6> glguy: i think it's somehow linked to 6.12
15:57:29 <copumpkin> glguy: thoughtpolice is working on it but I'm not sure of the status on it
15:57:37 <jmcarthur_work> i might throw something on the wiki or something
15:57:37 <copumpkin> glguy: I'd really like to see it for 6.12
15:57:41 <glguy> Baughn: so it will have to wait until 10.6 then?
15:57:59 <copumpkin> Baughn: huh?
15:58:03 <ppavelV6> Baughn: what core libraries on OSX do not fully support 64 bit
15:58:24 <Baughn> ppavelV6: It's been a while since last I use it.. there were a few, but mainly UI stuff.
15:58:48 <ppavelV6> Baughn: everything including Cocoa is 64 bit since Leopard.
15:58:58 <copumpkin> yeah
15:59:02 <copumpkin> everything is a fat binary
15:59:02 <Baughn> ppavelV6: Not *everything*. But I'm sorry, I don't recall the details.
15:59:07 <Baughn> You'll just have to trust me
15:59:11 <copumpkin> o.O
15:59:27 <ppavelV6> Baughn: i don't buy it, sorry :)
15:59:49 <glguy> ppavelV6: well, one of Snow Leopard's primary features is more complete 64-bit support
16:00:00 <copumpkin> yeah, things like finder still use carbon
16:00:04 <glguy> so there must be some 32-bit stuff in 10.5 for them to hang that as one of the big 4
16:00:10 <ppavelV6> glguy: Snow Leopard brings 64bit kernel
16:00:11 * Baughn leaves
16:00:12 <copumpkin> but that has no effect on whether we can compile things for 64-bit
16:00:24 <copumpkin> there's no obstacles preventing ghc 64bit on osx for example
16:00:46 <copumpkin> and there's already an unregistered build
16:01:23 <ray> so are there any obstacles to 64 bit ghc on windows?
16:01:39 <copumpkin> the lack of ghc hackers using windows I think
16:01:40 <copumpkin> :P
16:01:50 <ray> so no real obstacles :)
16:02:13 <ppavelV6> i hope OSX will be easier then Windows
16:02:13 <MisterN> ray: the lack of ghc hackers using windows probably has a reason, though.
16:03:21 <monochrom> Is it because we need someone to write a 64-bit runtime system for 64-bit Windows?
16:03:44 <ppavelV6> monochrom: "to port" will be better word probably
16:04:24 <jfoutz> jmcarthur_work: c wrapper that calls NSApplicationMain, then ... exec the built haskell application? not sure what to call...
16:04:51 <iago> there is some way to avoid GHC to consider a package? I have two packages with module names in conflict
16:04:55 <jfoutz> jmcarthur_work: a hpaste would be sweet :)
16:05:07 <jmcarthur_work> jfoutz, will have to wait until i get home
16:05:12 <jmcarthur_work> remind me later?
16:05:28 <iago> ops ok
16:05:31 <ppavelV6> FreeBSD still have only 6.8.3 :(
16:05:34 <iago> -hide-package
16:05:38 <jfoutz> jmcarthur_work: sure, i'm happy to... what sort of timeframe should i pester you?
16:05:59 <jmcarthur_work> a 2-3 hours from now might be okay
16:06:01 <ray> ppavelv6: no, it has the latest version
16:06:08 <ray> unless you mean ports
16:06:13 <jmcarthur_work> jfoutz, actually, email me: Jake.McArthur@gmail.com
16:06:22 <jmcarthur_work> i will be checking my mail later
16:06:24 <ppavelV6> ray: hm... where is it available?
16:06:30 <jfoutz> jmcarthur_work: ok. thanks, very much.
16:06:32 <ray> haskell.org/ghc
16:06:33 <jmcarthur_work> np
16:06:47 * ppavelV6 goes checking for FBSD version
16:07:44 <ppavelV6> ray:  Thank you!
16:07:56 <ray> no problem
16:08:30 <ray> i only learned the lesson about getting ghc binary distributions instead of packages from the system vendor in the past few months myself
16:12:13 <ppavelV6> ray: somebody went into the trouble of building binaries.
16:12:25 <ppavelV6> Jacula Modyun. Many thanks
16:12:39 <ray> yeah, some very nice person with lots of space cpu time i guess
16:12:46 <ray> spare*
16:12:48 <lpsmith> heh,  Dan Weinreb just sent me this link:  http://en.wikipedia.org/wiki/Captain_Haddock
16:13:04 <lpsmith> Possible mascot for Haddock?  I dunno.
16:13:29 <ray> i once made someone frown by telling them that haddock documentation was really generated from source files
16:13:59 <ppavelV6> haddock does not understand UTF-8 :(
16:14:13 <lpsmith> why did they not like that idea?
16:14:13 <ppavelV6> and is orthogonal with lhs/tex
16:14:44 <lpsmith> the UTF-8 issue is a bit more serious, I agree
16:14:53 <jfoutz> Lemmih: is there a darcs repository for SDL?
16:15:07 <ray> lpsmith: no, because it was decent documentation
16:16:56 <ppavelV6> lpsmith: no support for UTF-8 makes it useless for me :(
16:18:46 <ray> lpsmith: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7730
16:19:43 <ppavelV6> yeah, haddock makes really good job and documentation is really useful, but... sorry for wining :)
16:19:58 <ray> well, yeah, it should support utf8
16:20:10 <lpsmith> ray: hahaha
16:20:40 <lpsmith> ppavelV6:  I haven't had a burning need for UTF-8 in haddock,  but why do you need it?
16:21:35 <ppavelV6> lpsmith: because i'm russian :)
16:23:48 <maxote> ASCII encoding can't input know characters as lambda, alpha, beta, gamma, omega, etc.
16:24:02 <FunctorSalad> I think you can put utf8 in haddock, but only with some escaping?
16:24:03 <maxote>  /know/known/
16:24:55 <ppavelV6> lpsmith: comments in russian are ignored by haddock
16:25:09 <FunctorSalad> http://haskell.org/haddock/doc/html/ch03s08.html#id289840
16:25:30 <FunctorSalad> of course that's not nice for typing, but might work for automatic generation
16:25:51 <maxote> ppavelV6, if the comments were in russian, i wanted a simple translator of words to read it, xD
16:26:45 <ppavelV6> maxote: believe me or not there're other people who read russian and there's some text in russian that i'd like to put in comments :)
16:26:52 <ppavelV6> like quoting specs
16:27:23 <maxote> as babylon to translate words of worlwide language to your native language
16:27:43 <maxote> even if it's chinese, korean, russian, french, german, etc.
16:28:17 <ppavelV6> maxote: you're unrealistic :) i'd prefer to be fluent lojban speaker and have everybody speak it too but...
16:34:16 <jeffwheeler> Is Grapefruit dead? All the packages on Hackage are versioned 0.0.0.0
16:36:06 <ppavelV6> ray:  i've got 6.10.4 running under FreeBSD! Thanks again!
16:36:33 <ray> finally in the present :)
16:36:51 <ppavelV6> ray: yes :) nice feeling :)
16:37:16 <monochrom> How did you do it?
16:37:36 <monochrom> (Or have you already said how in the channel? I'll read scroll buffer.)
16:37:46 <ppavelV6> monochrom: downloaded it from http://www.haskell.org/ghc/dist/6.10.4/modyun/ghc-6.10.4-i386-jm0-freebsd7-boot.tar.bz2
16:38:25 <monochrom> Ah.
16:40:02 <monochrom> I cannot use ports or I don't want to use ports because the FreeBSD computer is not mine. A paid shell account.
16:40:56 <troutwine> Would someone be kind enough to explain my error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7731#a7731
16:41:12 <ppavelV6> monochrom:  it's a binary distribution. You have to specify the installation directory to configure and than run gmake instal
16:41:16 <ppavelV6> gmake install
16:42:01 <dolio> troutwine: Where's the 'b' coming from?
16:42:06 <ray> yeah, it should be installable without root, if they let you have enough disk
16:42:46 <Berengal> Is it bad that I was positively surprised by my coworker when he used a stack where a stack makes sense?
16:42:54 <dolio> troutwine: Perhaps you mean '[a] -> [b] -> [(Maybe a, Maybe b)]'?
16:43:34 <troutwine> dolio: Yes. That's a typo.
16:43:54 <ray> ah, i couldn't find it because the line numbers didn't match
16:43:57 <troutwine> Corrected in my current working copy.
16:44:40 <idnar> Berengal: he didn't use a hashmap?!
16:45:22 <Berengal> idnar: No, thank god, I don't think he knows how to properly override hashCode
16:46:49 <troutwine> To be on the safe side, I've corrected the typo. The current version is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7731#a7732
16:47:39 <dolio> Oh, right, well, (==) has type 'Ord a => a -> a -> Bool', and same for the other comparisons.
16:47:53 <dolio> You can't compare an 'a' to a 'b', you can only compare an 'a' to an 'a'.
16:48:03 <troutwine> Oh, damn. Of course.
16:48:06 <ray> Eq a
16:48:10 <lpsmith> ppavelV6:  I see your point :-)
16:48:24 <dolio> Yeah, Eq a for (==), Ord a for (<=) and (>=).
16:49:17 <ppavelV6> lpsmith: :)
16:50:28 <troutwine> Any suggestions, then, on how to proceed from my current point? I'm attempting to join two record types and update a field of one record.
16:51:04 * ppavelV6 needs some sleep
16:51:06 <ppavelV6> bye!
16:51:25 <dolio> Well, first of all, your functions have missing cases, which is probably not what you want.
16:51:35 <ray> my suggestion is that you not name your function "join", because there's an important library function named join
16:52:13 <troutwine> Yes, those are both problems. This is a rough draft.
16:52:23 <FunctorSalad> you can do a/b-heterogenous comparison by embedding into Either a b, for example
16:53:25 <monochrom> Haha I have to say "gmake install" to ensure it's GNU make.
16:53:28 <dolio> Anyhow, if you want to compare parts of two different records, you need two functions that select the part of the records you want to compare.
16:53:47 <ray> yes, shockingly, bsd uses bsd make :)
16:54:08 <dolio> So 'Ord c => [a] -> [b] -> (a -> c) -> (b -> c) -> [(Maybe a, Maybe b)]' or something like that.
16:54:18 <ray> i only do simple makefiles, so i'm not sure where they start being incompatible
16:54:43 <troutwine> Alright. Thanks for the suggestions and help.
16:58:23 <ski> troutwine : your `join' doesn't use `key'
16:59:18 <ski> also, you might consider using `compare' instead of `(==)',`(<=)' and `(>=)'
17:01:12 <monochrom> Oh neato, now I can haz ghc and ghci on FreeBSD too!
17:01:34 <monochrom> and line editing works :)
17:01:35 <ski> instead of defining `compare' for `Foo' and `Baz' in terms of `(<=)', why not define `(<=)' in terms of `(<=)' ?
17:01:43 <monochrom> (since it's yet another haskell lib)
17:18:20 <troutwine> ski: Thanks. On further consideration I should shove most of this into the database and let it worry over the details.
17:20:06 * ski idly wonders what "this" is referring to
17:22:32 <dolio> lern 2 C++ geeze!
17:59:39 <jfredett> hmm, is it possible to use Template Haskell to translate something like: `foo msg -> case msg of ...` to `foo $ \msg -> case msg of ...` -- eg, invent a little new syntax? It's just a little. :)
18:05:15 <sjanssen> jfredett: you might be able to do it with quasi quoting
18:06:26 <jfredett> hmm, I'm just mussing around trying to build an EDSL, augustss_'s BASIC EDSL seems to go about things a completely different way -- datatypes as AST, by the looks of it, maybe thats the way to go?
18:07:18 <jfredett> this is seeming more like a pain in the ass, if I try to do it w/ just functions. I'm trying to write a little Erlang style / Actor model thread EDSL. :)
18:08:29 <sjanssen> I don't see why $ is such a problem
18:09:43 <Saizan_> to bind a variable you're always going to use a lambda or case if you go augustss_'s style
18:10:09 <Saizan_> an haskell variable at least
18:10:13 <jfredett> it's not in general, but half the reason I'm writing this is because I hate the kludgyness of Erlang, so I'm trying to dodge any kludge.
18:10:59 <sjanssen> I don't really see $ as a kludge
18:12:12 <jfredett> it's really not, I suppose, but it's just -- I don't know, I was hoping to get right of the whole `$ \msg ->` entirely and end of with some thing like
18:12:54 <jfredett> receive \n Foo -> blah ...
18:13:29 <jfredett> that is, erlang's 'receive ... end.' syntax. :)
18:13:40 <jfredett> more or less.
18:14:00 <sjanssen> jfredett: it does make sense to attempt to avoid the case (frequently a problem in Haskell)
18:14:29 <sjanssen> if only we had some sort of lambda-case: foo $ case of Foo -> ...
18:14:53 <jfredett> I think I could just use augustss_'s method w/ datatypes and building an AST.
18:15:23 <sjanssen> jfredett: but you won't be able to use first class patterns in that case, right?
18:15:26 <jfredett> my plan is mostly just to hijack the state monad to do all the hard work, right now I'm just trying to get thread definition down in a way that looks nice.
18:15:54 <jfredett> sjanssen: hm?
18:16:14 <sjanssen> jfredett: you'll have to build an AST for patterns
18:16:17 <jfredett> I'm not sure I understand, whats a FC pattern? (I probably know, but maybe I don't)
18:16:34 <sjanssen> and functions if you want to use names bound in those patterns
18:16:37 <jfredett> oh... that wouldn't be good.
18:16:45 <sjanssen> jfredett: I shouldn't have said "first class", I meant "built in"
18:17:03 <jfredett> right-
18:17:05 <jfredett> thats bad.
18:17:25 <jfredett> this is harder than I thought it would be... :/
18:17:52 <jfredett> it'll be fun though- I'll be optimistic, time to learn about quasiquoting.
18:18:00 <sjanssen> with TH, you could do something like: foo [ [| \Foo -> blah |], [| \Bar -> blah2 |] ]
18:18:10 <sjanssen> that's an ugly hack, but it could actually work
18:18:50 <jfredett> I would sooner write erlang... that looks evil. :)
18:19:17 <sjanssen> or you could avoid TH and catch pattern match failure exceptions enabling: foo [ \Foo -> blah, \Bar -> blah2 ]
18:19:23 <sjanssen> this is more evil, but in a different way
18:21:01 <shapr> @yow !
18:21:02 <lambdabot> UH-OH!!  I think KEN is OVER-DUE on his R.V. PAYMENTS and HE'S having a
18:21:02 <lambdabot> NERVOUS BREAKDOWN too!!  Ha ha.
18:21:08 <jfredett> hey shapr.
18:21:59 <Saizan_> you could just have something like [$receive| ... |] with quasiquoting
18:22:00 <sjanssen> (ab)using do syntax and some funky exception Monad: msum [ do { Foo <- accept; blah }, do { Bar <- accept; blah2 } ]
18:22:20 <sjanssen> Saizan_: do you have to write your own Haskell parser for that?
18:22:25 <sjanssen> I've never really used QQ
18:23:00 <Saizan_> you're given a String, so yeah
18:23:28 <sjanssen> it'd be nice if QQ came with a plugin capable Haskell parser
18:23:30 <jfredett> ... that gets me back to the whole no built-in patterns thing though, no?
18:23:37 <sjanssen> jfredett: yeah, it does
18:23:57 <Saizan_> i wonder if plugin-capable parsers exist :)
18:24:20 <sjanssen> Saizan_: could be done in Parsec in a very ad-hoc way
18:24:57 <Saizan_> by plugin capable you mean that you should be able to extend the syntax, right?
18:25:07 <sjanssen> yeah
18:25:08 <jfredett> well, I think I'm hitting premature optimization in any case, I should just accept the `$ \` kludge and deal with it.
18:25:18 <jfredett> theres always version n+1
18:25:47 <sjanssen> pExpr = pVar <|> pStringLit <|> ... <|> userExprCallback
18:26:10 <jfredett> even just some kind of preprocessor -- thats all I'd really need
18:26:54 <jfredett> something like `syntax 'foo _ bar _ bas _' = quux` where the _'s are placeholders for variables that are passed to quux.
18:27:05 <jfredett> Coq has something like that, as does Agda
18:27:08 <Saizan_> yeah, quasiquoting is not much different than a preprocessor, you get to feed back a TH AST to ghc instead of a plain String though
18:27:19 <jfredett> with Notation and `if_then_else` stuff
18:27:58 <Saizan_> Agda only has mixfix operators iirc
18:28:11 <Saizan_> or can you also define new bind forms?
18:28:22 <Saizan_> i.e. syntax that brings variables in scope
18:28:39 <jfredett> i don't know -- it's been a while, ever since agda when emacs centric, I've been kind of turned off...
18:29:00 <jfredett> `Notation` in Coq is more along the lines of what I need
18:29:49 <jfredett> been a while since I did anything in Coq too -- sidebar, thats a really hard sentence to construct without making a double entendre.
18:30:04 <copumpkin> lol
18:30:11 <copumpkin> I just love coq
18:30:23 <jfredett> "been a while since I played with Coq" was what I was going to say, then I realized.
18:31:53 <mmorrow> , ppDoc <$> (let caseify lams = do xs <- sequence lams; let {(ps,es) = unzip [(p,e) | LamE [p] e <- xs]; omg = [|error "zomg"|]}; x <- newName "x"; return (LamE [VarP x] (CaseE (VarE x) (zipWith (\p e -> Match p (NormalB e) []) ps es)))         in caseify [[|\(Just x) -> Left (x,x)|],[|\Nothing -> Right [0..9]|]])
18:31:54 <lunabot>  \x_0 -> case x_0 of
18:31:54 <lunabot>              Just x_1 -> Left (x_1, x_1)
18:31:54 <lunabot>              Nothing -> Right [0..9]
18:32:17 <mmorrow> you can always arbitrarily transform the haskell AST with TH..
18:32:31 <mmorrow> oops, x_1
18:32:35 <mmorrow> oh, n/m
18:32:38 <badsheepy> i dont know what you just said, but im scared of it :O
18:32:39 <jfredett> ?
18:32:46 <jfredett> ibid.
18:32:49 <mmorrow>  caseify [[|\(Just x) -> Left (x,x)|],[|\Nothing -> Right [0..9]|]])
18:33:03 <jfredett> oooh
18:33:10 <mmorrow> ====> \x -> case x of Just y -> (y,y); Nothing -> Right [0..9]
18:33:37 <mmorrow> if that was formatted nicely it would look a lot less like a wall of noise
18:33:43 <jfredett> I guess what I want is to invent some new syntax, but I lack the powah.
18:34:07 <Berengal> quasiquoters?
18:34:08 <mmorrow> ah, if you want new (as in non-haskell) syntax, you'd need to use a quasiquoter
18:34:40 <mmorrow> and write your own parser (and then parse to whatever AST you choose, do stuff, then translate that to the TH ast)
18:34:53 <jfredett> yah, but apparently lose builtin functions or something.
18:35:06 <jfredett> mmorrow: is there a good qq tut for the unengrokened around?
18:35:09 <Berengal> You need to anti-quote...
18:35:46 <Saizan_> you don't need to lose anything..
18:35:55 <mmorrow> jfredett: there are some examples in the Language.Haskell.Meta.QQ.* namespace in http://hackage.haskell.org/package/haskell-src-meta
18:36:10 <Saizan_> the quasiquoting paper is easy to read, iirc
18:36:20 <mmorrow> jfredett: also, i'd run through hackage and wget all the QQs you find
18:36:27 <Berengal> Yeah, the quasiquoting paper was good
18:36:30 <jfredett> in a sense, I need to hijack the parser itself, so I can avoid tbe [$blah| foo |] stuff.
18:36:36 <Saizan_> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
18:36:56 <mmorrow> , [$ski|S[(,)][(*2)][444444]|]
18:37:02 <Saizan_> ah, if you don't want the brackets then you need your own preprocessor :)
18:37:03 <lunabot>  luna: A section must be enclosed in parentheses thus: (* 2)
18:37:13 <mmorrow> , [$ski|S[(,)][(\x->2*x)][444444]|]
18:37:15 <lunabot>  (444444,888888)
18:37:21 <mmorrow> , [$ski|S[(,)][(\x->2*x)]|]
18:37:24 <lunabot>  (S :$ (,)) :$ \x -> 2 * x
18:37:27 <sjanssen> mmorrow: how does [(,)] work?
18:37:47 <Berengal> I don't think the brackets are too bad
18:37:49 <mmorrow> in that QQ, anything in "[...]" is parsed as haskell, and everything outside is S,K, or I
18:37:51 <jfredett> yeh- Haskell needs a superpreprocessor. in addition to TH, a regular old String->String PP would be lovely.
18:38:06 <sjanssen> mmorrow: right, how do you get the [...] behavior? haskell-src?
18:38:14 <mmorrow> , let f = (\x -> (x,x)) in [$ski|S[(,)][f][42]|]
18:38:16 <lunabot>  (42,(42,42))
18:38:22 <Berengal> I'd rather have [$hsp| <module> |] than run the hsp preprocessor on any hsp pages I write...
18:38:36 <jfredett> something I can count on everyone having and know that it will work the way I expect... perhaps I should just write it... thats how TH used to work, no?
18:38:37 <mmorrow> sjanssen: in haskell-src-meta there's code that translates the haskell-src-exts AST to the TH ast
18:38:49 <sjanssen> mmorrow: ahh, I see
18:39:00 <mmorrow> sjanssen: and there're also instances of Lift for all the types in the TH AST
18:39:21 <mmorrow> which lets you lift meta does meta^2, and so on
18:39:23 <Saizan_> jfredett: i think TH always had brackets to quote code
18:39:59 <mmorrow> , $(let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 8 [|4|])
18:40:01 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\...
18:40:04 <mmorrow> , $(let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 3 [|4|])
18:40:05 <lunabot>  "\"\\\"4\\\"\""
18:40:28 <Saizan_> jfredett: it's not a big problem to install a preprocessor if it's on hackage :)
18:40:30 <mmorrow> splicing inside quotes is key for making effective use of TH
18:40:37 <sjanssen> so what jfreddet wants isn't really that difficult: [$receive | text |] becomes "\x -> case x of { text }" passed through haskell-src-exts
18:40:53 <sjanssen> not unreasonable syntax, IMO
18:40:56 <mmorrow> sjanssen: exactly, it wouldn't be that bad
18:41:16 <mmorrow> , let x = [0..4] in [$here| [0..4] is $([0..4]) and $(x) |]
18:41:19 <lunabot>  " [0..4] is [0,1,2,3,4] and [0,1,2,3,4] "
18:41:21 <sjanssen> mmorrow: oh, but you'd want receive blocks inside receive blocks, feasible?
18:42:28 <mmorrow> sjanssen: ooh, so that (general idea) i want to work out... haskell-src-exts parses both TH syn and QQ syn, but TH doesn't have a rep for itself, so you'd need to expand/splice/whatever the nested TH/QQ's manually
18:42:32 <Saizan_> if we had quasiquotation at the level of declarations you could quasiquote whole function definitions
18:42:47 <mmorrow> but, it depends on your parser.. e.g. if you're using ghc..
18:42:59 <Saizan_> you can already nest quasiquotation though
18:43:00 <mmorrow> , [$ty| [$ty| \x -> x \|] |]
18:43:02 <lunabot>  Doc
18:43:18 <mmorrow> , [$tyQ| ([$ty| \x -> x \|],ty,[0..9]) |]
18:43:21 <lunabot>  ForallT [a] [AppT (ConT Num) (VarT a),AppT (ConT Enum) (VarT a)] (AppT (A...
18:43:52 <mmorrow> (but that's technically "cheating" since it's ghc itself that's expanding those for "ty(Q)"
18:43:53 <mmorrow> )
18:44:21 <Saizan_> in [$ty| [$ty| \x -> x \|] |] the outer $ty gets the TH AST generated by the inner one prettyprinted as String?
18:44:54 <jfredett> actually, the [$recieve | |] syntax is growing on me.
18:45:27 <Saizan_> , [$ty| const [$ty| \x -> x \|] |]
18:45:30 <lunabot>  forall a . a -> Doc
18:45:36 <Saizan_> it seems so
18:45:42 <mmorrow> yes, the inner one passes the string to ghc, gets back a ghc-AST type, pprints that with ghc's prettyprinter, then parses it with haskell-src-exts, translates that to the TH AST, quotes /that/ again, splices it, and that process repeats one more time :P
18:45:46 <jfredett> I still wish i could get the syntax w/o the bars for cheap, but that isn't bad.
18:46:37 <copumpkin> wow
18:46:56 <monochrom> don't forget to rinse
18:47:00 <mmorrow> i'm slightly horrified looking at that all put into words :)
18:47:28 <monochrom> it is horrifying haha
18:48:15 <Saizan_> why quoting it again?
18:48:43 <mmorrow> at least the (String -> GHC-AST), (GHC-AST->String), (String -> haskell-src-exts), (haskell-src-exts -> TH), (TH -> TH) are all wrapped in their own functions, so that QQ doesn't have to literally implement all of that
18:49:33 <mmorrow> Saizan_: because it parses it as a type, but it needs to pass back an ExpQ to splice
18:49:45 <mmorrow> so it passes back a quoted Type ==> Exp
18:49:53 <mmorrow> hrm, actually wait i may be confusing myself
18:50:27 <Saizan_> doesn't it creates an ExpQ that corresponds to the Doc representation of the type?
18:50:45 <mmorrow> yeah, it does have to lift
18:51:04 <ibid> jfredett: ?
18:51:14 <mmorrow> it needs to pass back to ghc an ExpQ that represents the Doc, ohhh
18:51:14 <mmorrow> ok
18:51:16 <Saizan_> ah, so you get the TH AST, and quote the prettyprinting as Doc?
18:51:22 <mmorrow> Saizan_: here's the code
18:51:28 <mmorrow> http://moonpatio.com/repos/lunabot/Luna/Bot/Eval.hs
18:52:02 <mmorrow> so it does "ppDoc" inside a quote
18:52:13 <mmorrow> but tyQ actually has to lift the Type
18:52:18 <mmorrow> since it doesn't return Doc
18:52:33 <mmorrow> , [$tyQ| let fix f = let x = f x in x in fix |]
18:52:35 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (VarT a)) (VarT a)))...
18:52:43 <mmorrow> , [$ty| [$tyQ| let fix f = let x = f x in x in fix \|] |]
18:52:46 <lunabot>  Type
18:52:49 <mmorrow> , ppDoc [$tyQ| let fix f = let x = f x in x in fix |]
18:52:52 <lunabot>  forall a . (a -> a) -> a
18:53:01 <mmorrow> it gets pretty convoluted fast ..
18:53:25 <mmorrow> (and typ and typQ are at the top of http://moonpatio.com/repos/lunabot/Luna/Bot/Eval/GHC.hs)
18:54:27 <Saizan_> , [$ty| ppDoc |]
18:54:30 <lunabot>  forall a . (Data a, Ppr a) => a -> Doc
18:55:03 <Saizan_> i'd lift the result of calling ppDoc on Type, rather than lifting the Type to pass it to ppDoc in the quotation
18:55:04 <mmorrow> it's in haskell-src-meta.. a way i found to get TH to pprint as valid haskell with the TH prettyprinter
18:55:15 <Saizan_> if there's a Lift instance for Doc
18:55:54 <mmorrow> unfortunately the cons are hidden
18:56:05 <Saizan_> ah, ok then
18:56:37 <mmorrow> Saizan_: but totally that's exactly what's going on
18:59:16 <Saizan_> promoting a value from one stage to the next in that way looks so hacky :\
19:00:12 <mmorrow> yeah, when you can't get a Lift for a type you have to resort to hackery
19:00:49 <mmorrow> like e.g. for ByteString or something (have to unpack it, then quote the expression that when evaluated will repack it)
19:01:47 <mmorrow> well, that's the same situation but for a different reason i guess
19:02:06 <mmorrow> (the constructors aren't hidden, it's just that a ByteString is essentially just a pointer)
19:02:43 <mmorrow> although i guess you could slurp up the bytes and put them into an Addr# literal ;)
19:04:51 <Saizan_> let RULES do that :)
19:05:34 <igorgue> hi, when I try: "cabal install flickr" it shows:
19:05:35 <igorgue> http://paste2.org/p/347854
19:05:47 <igorgue> can anyone help me fix it?
19:05:59 <igorgue> I'm using Ubuntu 9.04
19:06:17 <Saizan_> igorgue: you need at least ghc-6.10
19:08:42 <igorgue> Saizan_: thanks
19:10:27 <Saizan_> igorgue: you can find generic binaries at http://haskell.org/ghc
19:11:26 <igorgue> Saizan_: yep, looking for a ppa then trying to get a generic bin over haskell.org
19:12:37 <igorgue> Saizan_: https://launchpad.net/~frej/+archive/ghc6.10 :)
19:20:11 <kniu> I've found that using the State monad instead of explicitly threading the state doesn't look as functional.
19:20:18 <kniu> am I doing something wrong/
19:20:38 <monochrom> It doesn't look as functional.
19:20:50 <Axman6> kniu: i think that's part of the point
19:20:57 <kniu> dang.
19:21:35 <monochrom> But it is tidier.
19:21:39 <kniu> I was hoping that something like "eval (App x y) env = apply (eval x env) (eval y env) env" could be rewritten like
19:21:54 <kniu> "eval (App x y) = apply (eval x) (eval y)"
19:22:08 <monochrom> Try Applicative.
19:22:14 <rocketman> kniu, maybe    eval (App x y) = eval x <$> eval y
19:22:22 <rocketman> yeah
19:23:08 <rocketman> (or more like  eval (App x y) = ($) <$> eval x <*> eval y,  I don't know)
19:23:27 <kniu> That just looks insane.
19:24:09 <Saizan_> "apply <$> eval x <*> eval y" looks insane?
19:24:19 <monochrom> liftM2 apply (eval x) (eval y)?
19:24:21 <Saizan_> you can also do liftM2 apply (eval x) (eval y)
19:24:42 <kniu> :t liftM2
19:24:44 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:24:59 <kniu> oh hey.
19:26:39 <monochrom> @type pure id <*> [False]
19:26:41 <lambdabot> [Bool]
19:27:02 <monochrom> @type pure (&) <*> [False] <*> [False]
19:27:04 <lambdabot> Not in scope: `&'
19:27:11 <monochrom> @type pure (&&) <*> [False] <*> [False]
19:27:12 <lambdabot> [Bool]
19:27:26 <monochrom> @type (&&)  <$> [False] <*> [False]
19:27:27 <lambdabot> [Bool]
19:27:38 <Gracenotes> hm... liftM2 apply `on` eval
19:27:48 <monochrom> Haha
19:28:00 <Gracenotes> the less explicit variables the better
19:28:03 <Gracenotes> :X
19:28:43 <Gracenotes> <dalek>Exterminate all points</dalek>
19:28:49 * Axman6 likes explicit variables
19:29:06 <monochrom> @type fmap (&&) [False] <*> [False]
19:29:08 <lambdabot> [Bool]
19:29:43 <monochrom> Exterminate all programmers.
19:29:49 <pikhq> Axman6: I hate variables.
19:29:51 <pikhq> Names, however? That I can deal with.
19:29:54 <pikhq> :P
19:29:54 * jfoutz ducks
19:30:08 <pikhq> (variables aren't variable. :D)
19:30:13 <rocketman> heh
19:31:01 <monochrom> "variable" is an imperative name.
19:31:20 <Vanadium> > fmap (&&) [False] <*> [False]
19:31:21 <lambdabot>   [False]
19:31:58 <monochrom> > fmap (,) [0,1,2] <*> [a,b,c]
19:31:59 <lambdabot>   [(0,a),(0,b),(0,c),(1,a),(1,b),(1,c),(2,a),(2,b),(2,c)]
19:32:18 <Vanadium> Can we get functions that work with n-tuples already :|
19:33:02 <roconnor> Vanadium: lists?
19:33:13 <monochrom> f <$> x <*> y <*> z <*> t  is a satisfactory alternative.
19:33:20 <Axman6> s/variables/arguments if that'll make everyone happy
19:33:28 <pikhq> Vanadium: NO N-TUPLES FOR THOU
19:34:11 <rocketman> Vanadium, what about using (-,(-,(-,()))) instead of (-,-,-)?
19:34:22 <monochrom> At some point you have to grow out of explicit arguments.
19:34:29 <Vanadium> :S
19:34:40 <rocketman> you don't like it?
19:35:03 <Vanadium> rocketman: You are just trying to talk me into lists here
19:35:08 <rocketman> no I am not
19:35:19 <rocketman> there are big differences from lists
19:35:34 <monochrom> For example all stories for functional I/O, even imperative I/O, requires hiding a few explicit arguments that stand for the outside world.
19:36:48 <Gracenotes> making specific datatypes can beat n-tuples.. sometimes...
19:37:48 <dbbddbdb> Are there any standard htonl functions to use with Network.Socket?
19:38:01 <SamB> @hoogle htonl
19:38:01 <lambdabot> No results found
19:38:06 <SamB> hmm
19:38:16 <SamB> dbbddbdb: what sort of use?
19:39:21 <dons> Gracenotes: almost always?
19:40:02 <Gracenotes> well, if n = 2 :P but yeah.
19:40:43 <copumpkin> zomg http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7734#a7734
19:40:51 <dbbddbdb> SamB: filling SockAddressInet manually on a LE machine
19:42:33 <SamB> dbbddbdb: how about fromIntegral :: Word16 -> PortNumber, fromIntegral :: Word32 -> HostAddress ?
19:42:45 <Gracenotes> hawt, copumpkin
19:42:54 <SamB> hmm, wait, latter not usefull...
19:43:12 <monochrom> HostAddress is a type HostAddress = Word32. You'll get id there.
19:43:26 <SamB> monochrom: I just noticed this, yes
19:44:36 * SamB wishes this would show the .hsc and not the result of processing the .hsc: http://www.haskell.org/ghc/docs/latest/html/libraries/network/src/Network-Socket-Internal.html#HostAddress
19:45:33 <FunctorSalad_> pikhq: should be "THEE" I think
19:47:16 <pikhq> FunctorSalad_: Actually, it hould be "EE".
19:47:21 <pikhq> So.
19:47:26 <monochrom> pee
19:47:31 <pikhq> Vanadium: NO N-TUPLES FOR EE.
19:50:22 <Gracenotes> pikhq: you seem to be declining recklessly!
19:50:45 <Gracenotes> (but correctly)
19:51:41 <copumpkin> unfortunately that Arrow class of mine doesn't allow me to define an IntMap instance
19:51:56 <pikhq> Gracenotes: Reckles declination is e bet ort.
19:52:50 <Gracenotes> actually it's "declenion", but no one can tell the difference
19:53:17 <pikhq> Good to know.
19:53:51 <Gracenotes> ..I'll try to pun less in the future
19:53:53 <Gracenotes> ;_;
19:54:10 <SamB> Gracenotes: that's a pun?
19:54:18 <pikhq> NO PUNS FOR EE
19:55:38 <Gracenotes> decline can mean both inflected pronouns and to fall
19:55:45 * SamB wonders how Corina fits into all of is
19:56:13 <pikhq> SamB: Why art ou capitaliing ""?
19:56:27 <SamB> pikhq: bad copy-paste-manship
19:56:37 <pikhq> Ahah.
19:56:42 <Gracenotes> that must be a  in your side
19:56:46 * SamB wonders how Corina fits into all of is
19:56:55 <SamB> oh, that does look batter
19:57:18 <kniu> sometimes, I want pattern matching to be tree-structured.
19:57:35 <kniu> it's tiring to retype the function name over and over again.
19:57:35 <SamB> kniu: but ... isn't it already ?
19:57:39 <SamB> oh, that
19:57:56 <Gracenotes> ah.. I see.
19:58:03 <SamB> s/batter/better/
19:58:35 <Gracenotes> case statement could do it, with some extra help (tuples, maybe)
19:58:37 <jfoutz> kniu: you could just case it
19:58:54 <kniu> to me, that looks even uglier.
19:59:08 <rocketman> kniu, I don't understand, can you show me what you mean?
19:59:19 <rocketman> on like
19:59:22 <rocketman> f X = ...
19:59:25 <rocketman> | Y = ...
19:59:25 <kniu> with only one match at a time, the case statements get nested really deep.
19:59:27 <rocketman> | Z = ...
19:59:50 <Gracenotes> kniu: hence the tuples' assistance mentioned. fortunately, though... there is copy/paste :)
20:02:29 <aavogt> kniu: do any matches involve Maybe?
20:02:44 <kniu> no.
20:02:49 <kniu> nor either.
20:04:17 <wgsilkie> I have read through several Haskell tutorials now, and I still don't quite understand functional programming.
20:04:34 <dons> have you written some small programs?
20:04:48 <kniu> Gentlemen of #haskell, have at 'im.
20:05:21 <wgsilkie> I understand most of the basic concepts, but I can't get my brain to think in terms of functional programming.
20:05:25 <monochrom> have you written your own tutorial?
20:05:28 <dons> have you looked at http://learnyouahaskell.com/ or "real world haskell"?
20:05:44 <dons> wgsilkie: where are you stuck? :)
20:06:19 <wgsilkie> I get stuck trying to approach problems.
20:06:33 <wgsilkie> With Haskell, that is.
20:07:00 <Axman6> monochrom: heh
20:07:11 <Axman6> wgsilkie: takes practise, like all languages
20:07:27 <wgsilkie> I could probably solve some really abstract mathematical problem, but I know Haskell isn't limited to that.
20:07:50 <bmoll8> I assume a fair number of haskell users are mathematicians, or mathematically inclined?
20:07:53 <wgsilkie> It would be nice if there were some exercises for beginners.
20:07:58 <Axman6> wgsilkie: my advice, go through some of learn you a haskell, and then try and solve some project euler problems
20:08:08 <dons> bmoll8: hmm. i don't think that's true. maybe a higher /proportion/ than in some languages.
20:08:16 <dons> or languages of similar maturity, certainly
20:08:30 <wgsilkie> Axman6: OK, sounds like a good idea.
20:08:35 <oklopol> monochrom: i actually got into functional programming by creating a few functional languages myself; not really even remotely similar to writing a tutorial but anyway
20:08:51 <bmoll8> dons: do you know of any irc forum on freenode that deals with grad school
20:08:57 <jfoutz> the euler problems are nice
20:09:01 <bmoll8> I googled it--and it directed me to the haskell chat room for some reason
20:09:15 <codebliss> @pl \a b -> map (+1) (filter a b)
20:09:15 <lambdabot> (map (1 +) .) . filter
20:09:17 <monochrom> haha
20:09:33 <dons> bmoll8: #haskell :)
20:09:48 <dons> we loves the precious grad studentssss....
20:10:07 <copumpkin> lol
20:10:09 <dons> they codes for us. precious
20:10:24 <bmoll8> they don't have the time, I assure you
20:10:30 <jmcarthur> we like to absorb grad students. they will never be seen again
20:10:31 <copumpkin> bmoll8: we make time :P
20:10:38 <dons> oh my i think we have the time ;)
20:10:51 <Axman6> yes indeed
20:10:55 <kingdj> wgsilkie: if you know some lisp or scheme, try "A Gentle Introduction to Haskell" at http://www.haskell.org/tutorial/index.html
20:11:00 <Axman6> i dont have a lecture for another 50 mins
20:11:11 <SamB> you just have to make sure they write their theses on appropriate topics
20:11:22 <bmoll8> I just sent something to my advisor that I busted my butt over; I got back some kind of reply that more or less told me to cut it in half--and wait for him to return so he could help me write the other half
20:11:28 <bmoll8> after that reply, I am more or less on vacation
20:11:35 <SamB> that leave, nay, force them plenty of time to write code
20:11:43 <wgsilkie> kingdj: The only functional language I know is Haskell.
20:11:47 <monochrom> "hi I'm considering ancient Babylonian language grad school, where can I discuss it?"  "go over to #haskell"
20:11:52 <bmoll8> wrote some c++ code, for kicks, and so on
20:11:55 * copumpkin feels really stupid after trying to fix a bug in a .hs file of his and :r-ing it in ghci repeatedly, and not being able to find the bug in the line it was claiming it was. Then I realized I had ghci on the wrong file (in the wrong project, no less)
20:13:02 <jmcarthur> bmoll8: for kicks to the balls?
20:13:08 <bmoll8> jmcarthur: hey, I like c
20:13:12 <Axman6> wgsilkie: have you been to the lyah tutorial?
20:13:13 <jmcarthur> you said c++
20:13:14 <Axman6> @where lyah
20:13:15 <lambdabot> www.learnyouahaskell.com
20:13:17 <bmoll8> yeah, typo
20:13:22 <monochrom> This is why I press ctrl-b ctrl-l in emacs haskell mode. It corresponds to :load. Explcit :load.
20:13:23 <bmoll8> i meant I like c++
20:13:26 <wgsilkie> Axman6: Yes.
20:13:33 <jmcarthur> i don't think i would say that too loudly in these parts ;)
20:13:36 <dons> bmoll8: what is your research area?
20:13:38 <bmoll8> jmcarthur: I more or less write my c++ code as if it were c
20:13:43 <bmoll8> dons: math
20:13:46 <jmcarthur> oh, that's acceptable then
20:13:47 <dons> bmoll8: #haskell is full of comp sci and math grad students.
20:13:49 <Axman6> wgsilkie: well get reading and typing ;)
20:13:52 <bmoll8> dons: specifically, analysis and pde's
20:13:53 <dons> oh , you might like #math too then.
20:14:00 <bmoll8> nonlinear pde's, to be exact
20:14:08 <dons> cool.
20:14:14 <Axman6> pde's?
20:14:19 <bmoll8> hey, thanks for the 'math' room
20:14:23 <dons> Cale et al : any recommendations for bmoll8 ?
20:14:28 <bmoll8> Axman6: yeah; partial differential equations
20:14:33 <Axman6> ah
20:14:39 <dons> bmoll8: oh, you should read the haskell4maths blogs
20:14:46 <wgsilkie> Axman6: Huh?  I said I read it.
20:14:49 * Axman6 managed to avoid all maths courses this semester.
20:14:56 <Axman6> wgsilkie: all of it?
20:14:56 <copumpkin> Axman6: intentionally?!?!?!!???
20:15:01 <dons> http://haskell.org/haskellwiki/Haskell_and_mathematics
20:15:16 <Axman6> yeah, i got sick of them last year. the rest of my courses are pretty mathy anyway
20:15:38 <dons> bmoll8: also, you could talk to byorgey. he's very math inclined, grad student, blogging about haskell + maths.
20:16:05 <byorgey> *POOF*! did someone mention haskell + maths? =)
20:16:06 <wgsilkie> Axman6: Most of it.
20:16:13 <dons> wow
20:16:13 <wgsilkie> And most of a few others.
20:16:16 <copumpkin> ooh another grad student!
20:16:17 <dons> it really does work!
20:16:23 <jfredett> Math? Haskell? I'm in.
20:16:29 <dons> bmoll8: hehehehahaha
20:16:37 <jfredett> thats like Chocolate and Peanut butter, bitches.
20:16:43 <dons> now we just need sigfpe and edwardk to turn up
20:16:56 <jfredett> edwardk is wicked smart.
20:16:57 <bmoll8> i don't even know why I chose this field; oh yeah, because nothing else was challenging enough
20:17:01 <monochrom> sigfpe is hard to summon
20:17:09 <dons> requires great magics
20:17:12 <jfredett> monochrom: he takes a special ritual.
20:17:14 <copumpkin> the magic incantation
20:17:19 <Axman6> wgsilkie: and you don't feel you could write anything useful in haskell? sounds like you need to try writing some stuff
20:17:23 <jfredett> monochrom: FPE's are touchy things.
20:17:23 <copumpkin> abracadabra, zygohistomorphic prepromorphism
20:17:26 <dons> bmoll8: well, it'll be fun. you should also learn haskell :)
20:17:32 <monochrom> hehehe
20:17:36 <copumpkin> damn, it didn't work
20:17:38 <bmoll8> I love what little I know of haskell
20:17:44 <bmoll8> functional programming just makes more sense
20:17:52 <dons> mechanized theorem proving might be fun for you too. Agda, Coq et al.
20:18:01 <copumpkin> you'd think all mathematicians would feel that way but then people go and use matlab
20:18:06 * copumpkin barfs at the thought
20:18:07 <rocketman> haha
20:18:12 <dons> Math <-> Haskell is just Curry-Howard, after all :)
20:18:13 <rocketman> yeah matlab
20:18:14 <bmoll8> copumpkin: takes less code to do what you want
20:18:25 <bmoll8> i use matlab actually; it's not all that bad
20:18:35 <copumpkin> bmoll8: I use it too, but don't enjoy it much at all
20:18:38 <Axman6> all the mathe packages like matlab and mathematica are pathetic -_-
20:18:41 <dons> to language designers, its kind of weird
20:18:41 <bmoll8> most code you deal with on a daily basis in my department is written in matlab
20:18:48 <bmoll8> I am a ruby lover, but I accept the fact that few use it
20:18:51 <Axman6> they should have asked a computer scientist to design the language
20:18:53 <jfredett> Matlab makes me want to die.
20:18:56 <bmoll8> it's a 'niche' language
20:18:57 <wgsilkie> Axman6: Well, I got a bit lost on some parts, but picked them up in other tutorials.  You're probably right. :)
20:18:58 <copumpkin> bmoll8: I also enjoy ruby :)
20:19:13 <Axman6> wgsilkie: project euler, gogogogo! :P
20:19:18 <bmoll8> in general, I like languages that are 'consistent' in syntax; python just seems like a mess
20:19:20 <jfredett> bmoll8: I just picked up ruby recently, it's fantastic
20:19:21 <dons> so who here is actually a math grad student, slumming in haskell land?
20:19:23 <byorgey> copumpkin: haha, at the hackathon we were just talking about summoning edwardk with that very incantation =)
20:19:26 <bmoll8> ME
20:19:30 <byorgey> well, without the 'abracadabra' part
20:19:32 <monochrom> I build a language abstraction layer in my mind.
20:19:42 <jfredett> it satifies my perl sensibilities, while avoiding the python culty feelings.
20:19:42 <copumpkin> byorgey: I was there in spirit, if not in person
20:19:42 <copumpkin> :D
20:19:44 * wgsilkie goes!........*POOF*
20:19:49 <monochrom> Since then I never wanted to die again.
20:19:51 <dons> i think roconnor is a math student
20:19:54 <jfredett> dons: I will be a math grad student, someday.
20:19:57 <dons> :)
20:20:00 <byorgey> copumpkin: apparently so!  yeah, we missed you
20:20:09 <copumpkin> :)
20:20:14 <dons> and there is a pretty short path to Erdos through the FP gurus
20:20:21 <bmoll8> If I get a job at Courant, this suffering will have all been worth it
20:20:27 <dons> via theorem proving. Plotkin et al
20:20:39 <bmoll8> jfredett: makes sure you do your research; grad school can be a grind
20:20:57 <jfredett> bmoll8: so I've heard.
20:21:01 <bmoll8> what are people here working on?
20:21:12 <bmoll8> math wise?
20:21:13 <jfredett> bmoll8: I have to take time to work with the little people first, to pay off debys.
20:21:16 <roconnor> I am a math/cs grad student
20:21:32 <dons> oh, that's a good point.
20:21:39 <jfredett> I just finished my second paper. so I've got two waiting for review in the Math College Journal. :)
20:21:49 <dons> some of the haskell comp sci people live in math departments
20:21:57 <jfredett> that was @ bmoll8's question. :)
20:22:04 <Axman6> so dons, what do you reckon are the chances there'd be a place for someone at galois in 5 years or so, with an interest in haskell, and concurrent/parallel systems, with high levels of correctness?
20:22:17 <dons> Axman6: the chance is very high, imo.
20:22:30 <Axman6> someone likely to graduate with an Engineering/IT degree
20:22:38 <roconnor> dons: did Galois fill their positions advertised this summer?
20:22:40 <dons> we're hiring 6+ haskellers this year, and expect to grow 10% or so for the next few years.
20:22:52 <dons> roconnor: not yet, still going
20:22:56 <bmoll8> hiring haskellers for what?
20:23:06 <bmoll8> I didn't know the language was being used widely outside of academia
20:23:09 <jfoutz> bmoll8: *laugh*
20:23:20 <dons> engineering, proofs, low level systems, web apps, kernels , compilers, ...
20:23:23 <roconnor> dons: McMaster university still hasn't gotten back to me.  They were supposed to last month. *grr*
20:23:24 <jfoutz> bmoll8: oh, sorry...
20:23:29 <Axman6> well, if you ever expand (back) to australia, put my name down :P
20:23:45 * roconnor watches is bank account dwindle
20:24:04 <bmoll8> roconnor: mine is already depleted
20:24:07 <dons> roconnor: we're still working through the queue. but from the original 2 positions, we now have 6 or 7.
20:24:50 <roconnor> dons: then I will take a lack of response from Galois as a good thing. :D  Or maybe they never got my application. :P
20:25:29 <byorgey> bmoll8: well, it's not exactly being used *widely*.  but it is being used outside of academia, increasingly so.
20:25:36 <dons> roconnor: yep, its a good thing.
20:25:50 <Axman6> bmoll8: i wouldn't say haskell is widely used, but comoanies like Galois use it a lot, for some very large projects for industry and govenrment
20:26:00 <roconnor> dons: thanks for the info.
20:26:03 <Axman6> (that just about sums it up right dons?)
20:26:17 <Axman6> companies*
20:26:24 <dons> yeah, i'd say it has niches where it is fairly likely to be found
20:26:44 <dons> we made the sdtimes http://www.sdtimes.com/blog/post/2009/07/27/Everyonee28099s-talking-about-Haskell.aspx this week
20:26:46 <Axman6> how's haskell for real time systems?
20:26:54 <dons> its used to /generate/ such code
20:27:05 * Saizan_ wonders if an undergrad has _any_ chances to get hired
20:27:10 <dons> and write provers for modelling such code
20:27:18 <jfoutz> facebook? was that just a rumor? i suspect quite a few test harnesses are written in haskell at all sorts of places.
20:27:33 <dons> some of the web companies use haskell here and there.
20:27:39 <copumpkin> Saizan_: well considering that I thought you were a grad or postgrad until you told me otherwise...
20:27:40 <copumpkin> :P
20:27:52 <bmoll8> from what I understand, languages are unable to displace c and c++ at a large number of firms due to the fact that the run time of compiled programs in other languages are slower. How is the Haskell code run time relative to c?
20:28:02 <Gwern-away> copumpkin: grad or postgrad is kind of the defaut assumption here...
20:28:18 <pikhq> bmoll8: Close.
20:28:20 <bmoll8> I am excluding interpreted languages altogether--programs in such languages are of course going to run slower
20:28:22 <Axman6> ok, someone need to explain to me what a grad student actually is. it's not a term that's used here, and i'm unsure of its meaning
20:28:29 <dons> bmoll8: C++ rules for performance in some scenarios, Fortran in others. Haskell's in the 1-3x slower for sequential code, but faster for parallel code.
20:28:30 <copumpkin> Gwern-away: not always
20:28:41 <pikhq> bmoll8: Some cases faster, some cases slower.
20:28:50 <dons> bmoll8: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all is our standard reference
20:28:52 <copumpkin> Axman6: working towards advanced degrees like master or doctoral ones
20:28:57 <pikhq> In most cases, Haskell is sufficiently fast.
20:29:07 <Axman6> i see
20:29:16 <roconnor> dons: why the question about math grad students?
20:29:17 <bmoll8> well, for things where milliseconds matter, such as trading on wall st...
20:29:19 <Saizan_> copumpkin: can i cite you on that in my resume?:)
20:29:23 <Axman6> bmoll8: if you know what you're doing, you can write very fast code
20:29:26 <dons> roconnor: bmoll8 was asking
20:29:32 <copumpkin> Saizan_: lol, sure
20:29:39 <roconnor> bmoll8: why the question about math grad students?
20:29:39 <Gwern-away> @quote graduate.student
20:29:50 <lambdabot> Who says: should I thank? My so-called ``colleagues,'' who laugh at me behind my back, all the while becoming famous on my work? My worthless graduate students, whose computer skills appear to be
20:29:50 <pikhq> bmoll8: The answer is "it depends".
20:29:51 <Axman6> bmoll8: there's at least one bank using haskell for... something... can't remember exactly what
20:29:52 <dons> bmoll8: well, there latency and scalability maybe be more important than all out sequential speed.
20:29:53 <lambdabot> limited to downloading bitmaps off of netnews?
20:30:06 <dons> Axman6: yeah, there's a few, actually. mostly for DSLs , tools, support code
20:30:12 <Axman6> yeah
20:30:24 <bmoll8> roconnor: wanted to get some advice about grad school
20:30:55 <roconnor> hmm, tricky
20:31:00 <Axman6> dons: i take it the idea of using haskell to produce code for real time stuff is that you can prove the code produced by haskell correct, and from that prove the produced code correct too?
20:31:13 <Gwern-away> @remember OlinShivers Who should I thank? My so-called ``colleagues,'' who laugh at me behind my back, all the while becoming famous on my work? My worthless graduate students, whose computer skills appear to be limited to downloading bitmaps off of netnews?
20:31:13 <lambdabot> It is forever etched in my memory.
20:31:18 <Gwern-away> @flush
20:31:18 <lambdabot> Not enough privileges
20:31:21 <roconnor> bmoll8: I dropped out of a PhD program Berkeley and then went to the netherlands.
20:31:30 <bmoll8> I went to Berkeley for undergrad
20:31:32 <gwern> @flush
20:31:42 <dons> Axman6: yeah, you'll typically model the code in a high level, verify it in some way or another, then extract the code you'll actually use
20:31:42 <bmoll8> I feel for the grad students there; my impression was that no one gave a crap about them
20:31:51 <bmoll8> in math, I mean
20:35:05 <gwern> @quote OlinShivers
20:35:05 <lambdabot> OlinShivers says: My God, no one could blame me -- no one! -- if I went off the edge and just lost it completely one day.
20:36:18 <roconnor> bmoll8: when were you an undergrad at berkeley?
20:36:27 <bmoll8> 2000-2004
20:36:45 <gwern> @quote OlinShivers
20:36:45 <lambdabot> OlinShivers says: As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
20:37:40 <dons> hehe
20:37:41 <gwern> too bad shivers is a scheme guy. we could use his mordant wit
20:38:05 <gwern> dons: oh, if you like that, you should track down the whole textfile that one is from
20:38:15 <a_coder> hey do you guys know that someone rated haskell as one of the worst languages ever: http://www.softwaredeveloper.com/features/ghosts-in-machine-071207/
20:38:55 <gwern> dons: http://www.ccs.neu.edu/home/shivers/autoweapons.html  'It's common knowledge that whenever you get two or more CS grad students together, the conversation will inevitably drift to the same topic: automatic weapons. Lately, we've noticed that whenever we attend a CS party, picnic, or bullsession, we always hear the same questions and discussions, usually from the younger grad students...'
20:39:08 <jvogel> hi what is dons' keyboard called on hi office?
20:39:15 <dons> yeah, its famous in grad student circles , gwern :)
20:39:21 <rocketman> "there are more user-friendly, functional language alternatives available (such as MATLAB)" ahahaha
20:39:42 <dons> jvogel: oh, that's a kinesis keyboard
20:39:45 <a_coder> lol
20:39:55 <SamB> rocketman: not exactly what I call user-friendly funcional programming
20:39:57 <jvogel> oh thx dons didnt realize you were here atm:p
20:40:07 <dons> :)
20:40:11 <Saizan_> that article is seriously contemplating brainfuck as a general purpouse language, is it for real or for fun?
20:40:16 <dons> http://www.kinesis-ergo.com/advantage.htm
20:40:23 <dons> Saizan_: surely not serious
20:40:39 <Axman6> dons: good keyboard?
20:41:15 * Axman6 doesn't touch type, so probably wouldn't get any advantages from it
20:41:19 <dons> yeah, very light to touch. many engineers here have them
20:41:37 <jvogel> dons: you feel it allows you to type more efficiently (faster) or is it just easier on the wrists>
20:41:55 <dons> easier on the wrists. galois got them to help prevent RSI in engineering staff
20:42:09 <pikhq> Axman6: Learn to touchtype.
20:42:15 <pikhq> You won't regret it.
20:42:48 <rocketman> you can change keyboard layout, if you want the easy way to learn to touchtype
20:43:00 <a_coder> that's dumb
20:43:21 <jfoutz> Axman6: get a cheap keyboard and spraypaint it.
20:43:22 <rocketman> a_coder, you think what I just said is dumb?
20:43:44 <a_coder> rocketman: yes, changing keyboard layout
20:43:45 <glguy> dons: is there a picture of your keyboard somewhere?
20:43:55 <glguy> did you do a deskshot?
20:43:57 <rocketman> a_coder, why
20:44:22 <Saizan_> isn't irc-ing enough to learn touchtyping?
20:45:01 <monochrom> That's like: isn't exams enough to learn functional programming?
20:45:01 <dons> glguy: yeah, hmm. xmonad gallery iirc. jvogel might be thinking of the famous 3 screen shot though, which was your desk?
20:45:40 <dons> jvogel: were you looking at http://haskell.org/sitewiki/images/a/aa/Screen-triplehead-galois.jpg ?
20:45:50 <glguy> yeah, i had the 3screen shot
20:45:54 <dons> glguy: i remember that office!
20:46:04 <a_coder> how.. do you type on that
20:46:10 <glguy> those keyboards are nice. the firmware is a little buggy, however
20:46:15 <dons> yeah
20:46:32 <rocketman> a_coder, you just declare what I say is dumb and you can't explain why? :p
20:47:01 <a_coder> rocketman: well maybe because you'll have to relearn everything when you go to another computer..
20:47:24 <rocketman> a_coder: ok (I don't think that is true)
20:47:52 <monochrom> I can't quite say "I build a keyboard abstraction layer in my mind" yet. :)
20:48:08 <jvogel> dons: yea
20:48:35 <a_coder> rocketman: why don't you get something like this: http://www.daskeyboard.com/images/front-view-ult-794x395.png
20:48:51 <dons> jvogel: that (famous :) photo is glguy's desk. we hacked up the first xmonad 3 head setup about 2 years ago
20:49:04 <rocketman> a_coder, I'd use it if someone gave me it but I'm not into keyboards much
20:49:07 <dons> it was late 2007 i guess?
20:49:30 <Axman6> me heads off to his formal methods for software engineering lecture
20:49:38 <a_coder> on second thought it'd be fun to rearrange the keyboard
20:49:46 <Axman6> yay for Clem + Proving code :)
20:49:49 <a_coder> maybe just to confuse a family member
20:50:20 <rocketman> a_coder: (I said I'm not a kbd geek.. but I'd still like one of those http://humblehacker.com/)
20:50:48 <glguy> dons: "hacked" is a good word for one window manager, 2 computers, and 3 monitors
20:51:08 <dons> :)
20:51:28 <a_coder> rocketman: that's interesting.. imagine trying to use vim with that.. or even ctrl-c/ctrl-v
20:51:36 <dons> the key thing is there was  indeed only one window manager :) and X.org was being cool
20:51:48 <rocketman> heh
20:52:11 <glguy> I wonder if anyone else had used that Xorg feature since we took that picture :)
20:52:44 <dons> mmmm
20:53:24 <dons> was one of the machines a mac?
20:53:40 <jvogel> those 3 monitors are spanned across 2 machines?
20:54:03 <dons> i've used 2 machines, 2 monitors, 1 X server when I had a mac and a linux box. but that was pre-2000
20:54:36 <dons> jvogel: yeah, one is plugged in to a dumb terminal (essentially) serving up windows via the master X server
20:54:47 <jfoutz> how do i get cabal to run a command like "ghc --make sv.o -no-hs-main Seven.hs
20:54:51 <jfoutz> ?
20:55:08 <dons> you make a cabal file that describes the library you're  trying to build
20:55:21 <jfoutz> ok, i've got that part.
20:55:21 <dons> where Seven.hs is the exposed module
20:55:31 <dons> and you need a boilerplate Setup.hs
20:55:41 <dons> (just grab it from the noop or pony package)
20:55:54 <dons> then "cabal build" should do the work
20:56:44 <Saizan_> dons: though that sv.o -no-hs-main seems unusual
20:57:05 <jfoutz> hrm, i should be more clear ghc --make sv.c -no-hs-main Seven.hs
20:57:20 <Saizan_> so the main comes from the .c file?
20:57:22 <jfoutz> i need a c main... because sdl on osx is sucky
20:57:25 <dons> oh, you want  to link sv.c and Seven.hs into a .o file?
20:57:36 <dons> oh, sv.c is the main module?
20:57:46 <jfoutz> yes and yes.
20:57:51 <dons> mmm
20:58:04 <dons> not sure if the main-is: syntax works for C files
20:58:06 <dons> dcoutts_: ?
20:58:13 <jfoutz> i have all the parts... if i could run a shell script i would be ok.
20:58:28 <dons> well, you can compile the .hs parts with cabal, then link in the C with a shell script
20:58:49 <dons> cabal build ; ghc --make sv.c dist/foo.o -o myexe
20:58:58 <Saizan_> you can override the build hook in Setup.hs script also
20:59:16 <wgsilkie> What's the most concise way to get the sum of the first (or last) n items in a list?
20:59:26 <jfoutz> hmm. build hook in setup.hs sounds promising. fwiw : rror: The 'Main-Is' field must specify a '.hs' or '.lhs'
20:59:44 <jfoutz> I'll give that a shot.
20:59:49 <Saizan_> wgsilkie: sum $ take n list
20:59:50 <monochrom> sum (take n xs) is the sum of the first n items.  last n items is more work.
20:59:53 <mike-burns> wgsilkie: My guess: sum $ take n
21:00:18 <mike-burns> Last would be: sum $ take n . reverse
21:00:19 <wgsilkie> Thanks, I'll try that.
21:01:37 <dons> takeLast n is a good exercise
21:02:11 <dons> write it such that it uses only one traversal, or constant space
21:02:30 <mike-burns> Right, there's the trick.
21:02:31 <wgsilkie> dons: What?
21:03:06 <dcoutts_> dons: no, main-is cannot be a .c file. There's an open ticket on that if someone is interested.
21:03:11 <dons> ok. thanks
21:05:07 <wgsilkie> Ask, I can't find it!  What does $ do to functions, exactly?  I forgot.
21:05:12 <wgsilkie> *Ack
21:05:18 <mike-burns> @src ($)
21:05:18 <lambdabot> f $ x = f x
21:05:53 <monochrom> Hmm one traversal!
21:06:00 * monochrom looks for knots to tie!
21:06:05 <mike-burns> wgsilkie: Think of it like a parentheses that lasts until the end of the expression.
21:06:09 <dons> monochrom: :)
21:06:40 <wgsilkie> Maybe my problem is trying to remember the technical details, *before* trying anything.
21:06:50 <wgsilkie> Is that a bad idea in Haskell?
21:06:55 <monochrom> dons please enjoy my proud creation http://www.haskell.org/haskellwiki/MonadFix  hehe
21:07:14 <dons> wgsilkie: it is very important to start with ghci fired up, and typing things in
21:07:16 <mike-burns> wgsilkie: Not totally sure, but I like to play around in ghci. Also learn to use lambdabot to have fun.
21:07:19 <dons> you learn programming by doing, not reading.
21:07:39 <dons> monochrom: ooh
21:07:45 <wgsilkie> OK.
21:08:03 <dons> hmm. that's quite a good article
21:08:20 * dons wishes these gems were more obvious. or the haskellwiki book was more comprehensive
21:09:05 <roconnor> monochrom: needs more time travel :P
21:09:26 <monochrom> The original mdo paper used Bird's repmin. Then I thought, min is boring, let's go sum. :)
21:09:47 <monochrom> Then I also thought, immutable tree is boring, let's destructive-update the numbers in the tree!
21:14:40 <pstickne_> monochrom:  yes, total mutability. :)
21:17:26 <jfoutz>  > (\n ls -> map fst $ filter snd $ zip ls (map (const False) (drop n ls) ++ repeat True )) [1..10]
21:17:38 <jfoutz> hrm.
21:17:46 <jfoutz> > (\n ls -> map fst $ filter snd $ zip ls (map (const False) (drop n ls) ++ repeat True )) [1..10]
21:17:47 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:18:19 <jfoutz> > (\n ls -> map fst $ filter snd $ zip ls (map (const False) (drop n ls) ++ repeat True )) 3 [1..10]
21:18:20 <lambdabot>   [8,9,10]
21:18:52 <jfoutz> i *think* it's one traversal, but i don't understand how fusion works.
21:21:41 * copumpkin wants kind polymorphism
21:22:07 * erikc wants air conditioning
21:22:52 * roconnor wants air polymorphism
21:23:06 * mike-burns wants kind conditioning
21:23:28 <mike-burns> Is an air polymorphism by analogy to an air guitar?
21:23:56 <monochrom> guitar polyphonism
21:27:48 <jfoutz> what is the ~?, as in repsum t = mfix (\ ~(u,s) -> do
21:28:35 <monochrom> name is "irrefutable pattern". operational semantics is laziness, don't do the pattern matching now, postpone as much as possible.
21:29:05 <copumpkin> hmm, now it works with IntMap too, but feels like a hack
21:29:06 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7734#a7738
21:30:06 <monochrom> normally when you hit a pattern matching site, thunks are evaluated so as to decide whether it is a match or mismatch. ~ postpones even that. It also has the effect of just assuming it is a match.
21:30:35 <jfoutz> monochrom: mfix is really neat.
21:31:09 <holmak> What happens if it isn't a match?
21:31:18 <monochrom> Program aborts.
21:31:37 <jfoutz> it's like crossing the streams. :)
21:31:42 <monochrom> I mean program aborts later on when the assumption is found to be wrong.
21:31:57 <holmak> So the programmer needs to be sure what will get passed in?
21:32:06 <monochrom> Yes.
21:32:31 <monochrom> > case Nothing of ~(Just _) -> "hello"
21:32:32 <holmak> Brings all the excitement and danger of dynamic programming to Haskell :P
21:32:32 <lambdabot>   "hello"
21:33:13 <monochrom> This one isn't busted because the code ends up never using anything from the pattern matching, so the pattern matching is postponed and then completely forgotten. No one ever noticed.
21:33:16 <Berengal> > case Nothing of ~(Just x) -> "hello" ++ x
21:33:18 <lambdabot>   "hello* Exception: <interactive>:1:133-173: Irrefutable pattern failed for ...
21:33:30 <holmak> good times
21:33:36 <holmak> what is the use case here?
21:33:56 <monochrom> Yes this one now is busted because using x causes the postponed pattern matching to happen eventually, then you're caught.
21:34:03 <holmak> Just so pattern matching doesn't kill lazy eval?
21:34:18 <monochrom> "case" is pattern matching expression.
21:34:37 <holmak> Yeah, I've got it -- I'm just curious where you would use it
21:34:40 <monochrom> Saves me from defining a function.
21:35:01 <roconnor> holmak: swap ~(x,y) = (y,x)
21:35:02 <monochrom> Exactly what you suspected. To make code more lazy.
21:35:17 <holmak> handy
21:35:19 <monochrom> To have pattern matching and still be lazy.
21:35:43 <monochrom> Best used for things like (x,y) where clearly nothing can go wrong.
21:35:44 <holmak> That would be unfortunate, if pattern matching stopped lazy evaluation
21:35:58 <holmak> Seeing as pattern matching is awesome
21:36:13 <Berengal> Pattern matching has to evaluate to see if the pattern matches...
21:36:21 <holmak> certainly
21:36:24 <holmak> though not here
21:36:28 <holmak> not eagerly
21:36:36 <Berengal> No, in this case we know the pattern matches already
21:36:38 <monochrom> In mfix (\ ~(x,y) -> ...) we need that extra laziness for the tuple.
21:36:45 <Berengal> That's why it's called irrefuteable
21:36:49 <holmak> Although... since the match can't fail, why pattern match?
21:36:50 <roconnor> > let swap (x,y) = (y,x) in let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap (foo z xs) in foo 0 [0..1000000]
21:36:51 <lambdabot>   * Exception: stack overflow
21:36:55 <roconnor> > let swap ~(x,y) = (y,x) in let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap (foo z xs) in foo 0 [0..1000000]
21:36:59 <lambdabot>   (0,500000500000)
21:37:01 <Berengal> We know it's not refuteable, so we don't have to check if it's refuted
21:37:30 <pikhq> holmak: To let you get at the internal values.
21:37:50 <holmak> Ok. I'm used to pattern matching being used to choose between options
21:37:55 <Berengal> It's for tying knots, mostly
21:38:21 <holmak> Oh no, is this used in that trick for making circular references?
21:38:24 <roconnor> holmak: pattern matching can also used be used to deconstruct records, especially tuples
21:38:28 <monochrom> Yeah here the patterns are just for naming things, so it's a good use of ~
21:38:59 <pikhq> Basically, don't use it for branching unless you like screwy stuff.
21:39:11 <holmak> I don't plan on using it any time soon
21:39:12 <pikhq> Like crossing the streams.
21:39:20 <holmak> But I will keep it in mind
21:39:22 <Berengal> I don't think you can use it for branching...
21:39:23 <monochrom> In tying-knots code, you usually don't see ~, just because you write "let" instead.
21:39:36 <monochrom> > let Just _ = Nothing in "hello"
21:39:37 <holmak> If I really need to crash my program, I'll pull out the ~
21:39:38 <lambdabot>   "hello"
21:39:59 <roconnor> monochrom is right.  let's implicitly use a ~ in front of the pattern
21:40:02 <pikhq> Berengal: Indeed, you can't... And if you try, it'll crash.
21:40:04 <pikhq> :)
21:40:05 <monochrom> When you write "let" instead of "case", you get implicit ~ already, so to speak.
21:40:27 <Berengal> pikhq: Either that, or you have some refutable patterns ahead of it, in which case it loses its semantics anyway
21:40:27 <Rotaerk> hm.. I need to generate a list of all pairs (x, y) for x from 1 to w and y from 1 to h
21:40:29 <holmak> > let (x, y) = (2, 3)
21:40:30 <lambdabot>   not an expression: `let (x, y) = (2, 3)'
21:40:33 <holmak> erm
21:40:49 <pikhq> > let (x, y) = (2, 3) in x + y
21:40:50 <lambdabot>   5
21:40:52 <monochrom> However, in \(x,y)->... , that is an eager pattern match, no good for tying-knots.
21:40:53 <Rotaerk> is there a convenient function for that
21:41:28 <holmak> Wait, when you say tying knots, that means making circular references?
21:41:45 <Berengal> > (\w h -> [(x, y) | x <- [1 .. w], y <- [1..h]) 3 3
21:41:46 <lambdabot>   <no location info>: parse error on input `)'
21:41:55 <Berengal> > (\w h -> [(x, y) | x <- [1 .. w], y <- [1..h]]) 3 3
21:41:57 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
21:41:59 <pikhq> > let w = 10; h = 5 in [(x,y) | x <- [1..w], y <- [1..h] ]
21:42:00 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
21:42:13 <Berengal> > range ((1,1),(3,3))
21:42:14 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
21:42:21 <monochrom> Yes, circular things, like "let (x,y) = f x 0 in blahblah"
21:42:27 <Rotaerk> ah cool, thanks
21:42:56 <monochrom> > (,) <$> [1..3] <*> [0..2]
21:42:57 <lambdabot>   [(1,0),(1,1),(1,2),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2)]
21:43:08 <jfoutz> @src range
21:43:08 <lambdabot> Source not found. You untyped fool!
21:43:13 <Rotaerk> heh
21:43:30 <holmak> I do not support the use of these spaceship <$> operators.
21:43:32 <pikhq> > liftA2 (,) [1..3] [0..2]
21:43:33 <lambdabot>   [(1,0),(1,1),(1,2),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2)]
21:43:40 <holmak> I'm pretty sure they exist only to confuse rookies :D
21:43:53 <monochrom> > (*) <$> [a..b] <*> [c..f]  :: [Expr]
21:43:54 <pikhq> So, there's a lot of ways to do it. :)
21:43:54 <lambdabot>   * Exception: not a number
21:44:11 <monochrom> > (*) <$> [a,b] <*> [c,d,e]  :: [Expr]
21:44:12 <lambdabot>   [a * c,a * d,a * e,b * c,b * d,b * e]
21:44:20 <Rotaerk> hmm now to find something similar in F#; may have to just implement it manually
21:44:30 <Berengal> > do {x <- [1..3]; y <- [1..3]; return (x,y)}
21:44:32 <pikhq> Rotaerk: Don't.
21:44:32 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
21:44:53 <pikhq> F# is like Haskell without everything that makes Haskell good. :P
21:45:09 <holmak> Heh, I was just trying to write something in F#.
21:45:22 <holmak> Then I realized it was unusable, and got on #Haskell.
21:45:39 <Rotaerk> oh I do like what know of haskell, but I want the .NET framework for what I'm doing
21:45:42 <pikhq> So, that's two uses of the applicative instance of list, a list comprehension, and a use-specific function.
21:45:50 <pikhq> Rotaerk: No you don't.
21:46:10 <pikhq> Oh, and the monad instance.
21:46:12 <Berengal> pikhq: And the monad instance
21:46:18 <holmak> @src Applicative
21:46:19 <lambdabot> class Functor f => Applicative f where
21:46:19 <lambdabot>     pure  :: a -> f a
21:46:19 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
21:46:29 <Berengal> (But the monad instance is identical to the applicative in this case since it doesn't use join)
21:46:46 <monochrom> I joined the Applicative bandwagon recently. :)
21:46:51 <holmak> And now my brain hurts, because you brought up monads :D
21:47:09 <pikhq> I do believe that "liftA2 (,)" is the nicest one.
21:47:13 <holmak> I need a sandwich, then I will look at Applicative again
21:47:22 <pikhq> holmak: Monads aren't hard.
21:47:24 <dibblego> monochrom, welcome :)
21:47:32 <Rotaerk> ahh, it does provide something like liftA2
21:47:46 <Rotaerk> called List.map2
21:47:46 <Berengal> > sequence [[1..3], [1..3]]
21:47:47 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
21:47:58 <pikhq> Oh, sure. Use sequence.
21:48:02 <dibblego> Rotaerk, F# provides a Bind method but it doesn't (can't) abstract on the type constructor
21:48:26 <Rotaerk> I haven't gotten into monads yet, but I do remember hearing someone complain about that before
21:48:45 <Rotaerk> I understand F# is more restrictive in terms of FP techniques but... it does give me access to XNA
21:48:55 <pikhq> Rotaerk: Eeeeew.
21:48:55 <dibblego> Rotaerk, not really to do with monads -- just that monads are one particular instance where F# fails (as do all .NET languages)
21:49:18 <Berengal> I found myself wanting dependent types in java yesterday...
21:49:23 <Berengal> Or at least indexed types
21:49:38 <Apocalisp> Hah. That's the least of Java's worries.
21:49:41 <pikhq> Berengal: I find myself wanting the Maybe monad in C all the freaking time.
21:49:43 <Berengal> It was painful, but then I remembered that java doesn't have a typesystem, it just pretends to
21:50:06 <Berengal> pikhq: It's called *
21:50:07 <mike-burns> pikhq: I find myself wanting the Maybe monad in everything I write all the freaking time.
21:50:16 <pikhq> mike-burns: Truth.
21:50:23 <pikhq> Berengal: Hahahah.
21:50:48 <Berengal> pikhq: In java it's implicit in everything :(
21:51:04 <holmak> pikhq: Ok, you got me. I just wanted a sandwich.
21:51:07 <pikhq> Berengal: It's much nicer when it's explicit. :(
21:51:11 <Berengal> Everything's in the maybe monad, and it doesn't have do notation
21:51:13 <mike-burns> Oh the description of XNA from Wikipedia (the first paragraph at least) looks really useful.
21:51:39 <pikhq> mike-burns: Sure, if you hate portability.
21:51:40 <Apocalisp> Berengal: It does too have do-notation, it's just reserved for a single monad called ;
21:51:48 <mike-burns> pikhq: I do happen to hate portability ...
21:52:10 <Berengal> Apocalisp: Okay, it has do-notation for ; (IO), but everything's in MaybeT ;
21:52:14 <pikhq> mike-burns: I sentence you to be hanged from the neck until dead.
21:52:20 <Rotaerk> I've got a pattern matching library I use in C#, which I have to use at work
21:52:35 <Rotaerk> not terrible syntax for a procedural language
21:52:37 <mike-burns> pikhq: "facilitates computer game development and management. XNA attempts to free game developers from writing "repetitive boilerplate code"[2] and bring different aspects of game production into a single system." - that sounds great.
21:52:49 <holmak> I have to side with XNA. Portability is nice, but fantastically designed libraries are awfully tempting.
21:53:04 <pikhq> mike-burns: It also restricts you to the Xbox and Windows.
21:53:20 <mike-burns> pikhq: Hey all I'm saying is that the first paragraph I read about it sounds awesome.
21:53:22 <holmak> Oh noes, 95% of market share
21:53:27 <Rotaerk> also, even if I didn't want to use XNA and DX instead, I've heard Haskell doesn't have D3D bindings
21:53:28 <hackagebot> hack-handler-evhttp 2009.7.29 - Hack EvHTTP (libevent) Handler (BrandonBickford)
21:53:41 <pikhq> holmak: Not for the Xbox.
21:53:49 <Rotaerk> not sure about that though
21:53:51 <pikhq> holmak: The Wii is the #1 console. ;)
21:53:54 <holmak> I don't even care about Xbox to be honest
21:53:55 <pikhq> And that's OpenGL.
21:54:03 <holmak> I like opengl and all
21:54:11 <Sam__> pikhq: it is???
21:54:12 <pikhq> Rotaerk: That's because OpenGL works as well and is portable.
21:54:21 <Sam__> that's so sane!
21:54:22 <pikhq> Sam__: Sales-wise, yes.
21:54:26 <Sam__> I would never have expected it
21:54:30 <pikhq> Oh, OpenGL?
21:54:34 <Sam__> yeah
21:54:52 <mike-burns> But what are your choices aside from XNA? Writing a bunch of code from scratch? (I ask this seriously; I know nothing about game development.)
21:54:56 <pikhq> Yeah, everything newer than the first 3D generation uses OpenGL *except* for Microsoft.
21:54:59 <pikhq> Which uses Direct3D.
21:55:15 <pikhq> mike-burns: Game developers are very finnicky with their engines.
21:55:21 <SamB_XP> PS2 uses OpenGL?
21:55:22 <jfoutz> everything but windows/xbox is opengl afaik. wii, ps3, iphone, ... everything
21:55:27 <pikhq> Yes, they tend to prefer writing a bunch of code from scratch.
21:55:29 <pikhq> SamB_XP: Yuh.
21:55:38 <SamB_XP> huh. never heard that before!
21:56:03 <holmak> OpenGL i'm ok with, but all the support libraries -- for sound, input, networking -- all sketchy
21:56:09 <mike-burns> pikhq: You may have it backward, though. For example, I don't write games because I'd have to write it from scratch---there's no framework for me to use.
21:56:10 <SamB_XP> so ... why doesn't microsoft try to sell DirectX more?
21:56:29 <pikhq> SamB_XP: Stop people from using Windows as much?
21:56:33 <pikhq> holmak: IMO, the best way to do it is SDL.
21:56:40 <holmak> Because D3D is an unspeakable horror.
21:56:42 <Rotaerk> XNA is my choice in any case, because I think it'll ease me into graphics, since it handles a lot of the lower level stuff
21:56:55 <holmak> I've used SDL. I just don't like it...
21:56:58 <SamB_XP> pikhq: I thought they just liked to have a base of code that they could adapt, rather than having to shoehorn their game into some provided library?
21:57:41 <pikhq> SamB_XP: Ideally, yeah. But often times it's easiest to just write code from scratch.
21:58:20 <SamB_XP> pikhq: well, I mean, they might start with something they used in the company's *last* game
21:58:32 <roconnor> what is SDL?
21:58:34 <pikhq> Well, yeah.
21:59:00 <mike-burns> Imagine if Haskell provided a solid alternative to XNA. It'd be easier to use and more open; it'd be one of Haskell's killer apps.
21:59:03 <pikhq> roconnor: The Simple DirectMedia Layer, a portable graphics, audio, mouse, and networking library.
22:00:02 <pikhq> roconnor: It provides basically everything but 3D graphics -- for that, it just provides portable OpenGL instantiation.
22:00:05 <pikhq> Runs on almost everything.
22:00:48 <SamB_XP> pikhq: what does it not run on?
22:00:52 <SamB_XP> Apple II?
22:01:11 <pikhq> SamB_XP: Fine, fine. Everything as capable as, oh, a 386 and up.
22:01:18 <jmcarthur> is there more than one known free monad?
22:01:24 <pikhq> (maybe even a 286 with a VGA adaptor)
22:01:49 <pikhq> (note: not all programs using it will have that wide of range)
22:02:16 <mmorrow> jmcarthur: there's a free group on n generators, for n `elem` [0..]
22:02:29 <SamB_XP> jmcarthur: I thought the free monad is just where you don't fix the monad?
22:02:39 <SamB_XP> i.e., the free monad is broken ;-P
22:02:44 <copumpkin> :o
22:02:45 <mmorrow> oh, you said "monAd"
22:02:46 <monochrom> hahahahaha
22:02:56 * mmorrow read monoid
22:03:13 <jmcarthur> mmorrow: yeah, you were confusing me there for a second
22:03:22 <jmcarthur> i was trying to relate groups to monads
22:04:06 <mmorrow> jmcarthur: the "free <insert whatever>" is really just the same root concept, for whatever value of "whatever"
22:04:10 <jmcarthur> SamB_XP: i think maybe i didn't get the joke. a pun on fix?
22:04:25 <SamB_XP> jmcarthur: not much of one
22:04:44 <jmcarthur> mmorrow: maybe i should rephrase the question a little
22:04:44 <monochrom> I fear that it is a pun on "free" and "fix" too.
22:04:48 <Apocalisp> There's no cofree lunch
22:04:49 <SamB_XP> that is, there's fix as in "hold constant" and fix as in "repair"
22:04:58 * rocketman can't understant "free ____"
22:05:16 <mmorrow> the integers are the free group on one generator
22:05:38 <mmorrow> (Z,Z) is it on two generators ....
22:05:40 <SamB_XP> mmorrow: how about on one powerline ?
22:05:43 <copumpkin> does mathematics have such a thing as free money? I'd be interested in studying it
22:05:48 <mmorrow> SamB: transformers!
22:06:00 <jmcarthur> mmorrow: for the same structure of the well-known free monad (Either a (f (Either a (f (Either ...)))), is there more than one possible monad instance?
22:06:02 <monochrom> You pun too much.
22:06:26 <jmcarthur> i think i might be making another one in my head
22:06:48 <SamB_XP> monochrom: you may not be punny enough
22:07:06 <copumpkin> haha, very punny
22:07:12 <SamB_XP> this may put you at risk for heart disease
22:07:36 <Saizan_> jmcarthur: how does it look like?
22:08:15 <monochrom> "monads for free with generators, transformers, powerlines, and bananas"
22:08:57 <SamB_XP> monochrom: where do catamorphisms come into all of that?
22:09:11 <monochrom> "Abstract: We program with monads for free....  go bananas."
22:09:18 * Saizan_ sees SamB_XP and monochrom competing for the best pun
22:10:03 <mike-burns> Puns don't so much come in degrees of "best"; more like "least worst".
22:10:15 <monochrom> Catamorphisms are written as a pair of bananas surrounding a morphism symbol.
22:10:16 <SamB_XP> mike-burns: best == most worst, maybe
22:10:55 <jmcarthur> Saizan_: eek, harder to explain in english than i thought it would be, probably due to lack of knowledge of mathematical terminology on my part
22:11:17 <jmcarthur> Saizan_: i think i will just write something up and maybe post to the mailing list or something, actually
22:11:28 <Saizan_> jmcarthur: how about in haskell? ah, ok :)
22:13:52 <monochrom> @karma c
22:13:53 <lambdabot> c has a karma of 1
22:19:20 <Trinithis> @karma lambdabot
22:19:20 <lambdabot> lambdabot has a karma of -2
22:19:33 <jmcarthur> Saizan_: okay, i was wrong-ish. my alternative monad instance will probably itself require that the functor be a monad, which isn't quite as interesting
22:21:38 <jmcarthur> i knew something had to be up when i couldn't find it on google
22:21:44 <kfish> @karma lambdabot
22:21:44 <lambdabot> lambdabot has a karma of 7
22:27:17 <SamB_XP> @karma SamB
22:27:17 <lambdabot> SamB has a karma of 1
22:27:30 <aavogt> @karma
22:27:30 <lambdabot> You have a karma of 3
22:34:03 <Berengal> Indexed types = System F omega?
22:35:24 * copumpkin 's blood boils
22:35:47 <copumpkin> http://flyingfrogblog.blogspot.com/2009/04/more-on-haskells-hash-table-problems.html [not safe for tempers]
22:36:06 <Berengal> troll alert!
22:39:53 <jmcarthur> i saw some book on F# he wrote in B&N the other day and scowled visibly enough that somebody noticed and asked what was wrong
22:40:01 <copumpkin> lol
22:54:44 <Rotaerk> http://codepad.org/OT2mkRBm  mmm F# code
22:54:46 <Rotaerk> *cough*
22:55:06 <Rotaerk> if it had "where" clauses that'd be nice
22:56:41 <jmcarthur> to an F# virgin like myself, that looks like it's not very good F# code. surely F# allows for more abstraction than *that*!
22:57:00 <Rotaerk> what do you mean
22:57:26 <jmcarthur> it doesn't look all that different from imperative C# code, to me
22:58:01 <Rotaerk> jmcarthur, well a lot of it is imperative; it's just a unit test
22:58:13 <jmcarthur> F# has for loops?!
22:58:20 <Gracenotes> it is... declarative as well!
22:58:27 <Rotaerk> it does have for loops
22:58:27 <erikc> jmcarthur yea
22:58:31 <copumpkin> I just saw jdh bragging about for loops in his blog
22:58:33 <copumpkin> so I assume so
22:58:35 * jmcarthur wonders if my lack of ML experience is showing
22:58:41 <Rotaerk> there might be a better way to do that, but I'm not that good with F# yet
22:58:57 <copumpkin> all those lets are distracting
22:59:02 <Rotaerk> agreed
22:59:29 <Rotaerk> you can't go without it though, in F# >_<
22:59:38 <Rotaerk> x = y is a *comparison* in F#
22:59:52 <jmcarthur> okay, F# officially weirds me out. it's like two worlds of programming that simply should not collide
23:00:21 <TheColonial> jmcarthur: so why shouldn't they collide? :)
23:00:41 <jmcarthur> that code sample makes me cry
23:00:55 <TheColonial> damn, i missed a code sample. can someone relink please?
23:01:11 <TheColonial> jmcarthur: that's not justification though :P
23:01:17 <jmcarthur> TheColonial: http://codepad.org/OT2mkRBm
23:01:21 <TheColonial> thank you!
23:01:31 <TheColonial> ouch!
23:01:38 <TheColonial> that's... rather intense :)
23:01:42 <Rotaerk> :P
23:01:48 <jmcarthur> i just hate it when there is such potential to really introduce people to real functional programming and it gets fudged up
23:01:48 <TheColonial> i mean that in a nice way !
23:02:00 <TheColonial> well it did start off as Ocaml for .NET
23:02:19 <TheColonial> so it was kinda on the right foot..
23:02:25 <TheColonial> the problem is the .NET framework really.
23:02:33 <copumpkin> dblhelix: hah
23:02:46 <Rotaerk> this particular code doesn't really benefit from making it FP instead of imperative
23:02:52 <Rotaerk> it's supposed to do nothing but cause side effects
23:03:02 <copumpkin> Rotaerk: you can abstract the side effects then :P
23:03:09 <erikc> once you have to interop with the rest of .net, there's not much hope
23:03:11 <Rotaerk> I haven't gotten into monads yet >_<
23:03:12 <jmcarthur> side-effecting code can still benefit from tons of abstraction
23:03:12 <copumpkin> when in doubt, just add more abstraction
23:03:18 <copumpkin> :P
23:03:23 <Rotaerk> it might be improvable, but not with my knowledge at this point
23:03:32 <TheColonial> abstraction is like violence: if it's not solving your problem, you're not using enough of it :D
23:03:34 <erikc> jmcarthur: http://paste.fac9.com/hpaste.fcgi/view?id=21
23:03:38 <dibblego> Rotaerk, there is almost always a benefit and especially in this case
23:03:48 <TheColonial> ah Tony! didn't see you there mate.
23:03:48 <copumpkin> omg pwnt
23:03:51 <dibblego> hello
23:03:57 <TheColonial> how are you?
23:04:03 <dibblego> pretty good
23:04:07 <TheColonial> good to hear.
23:04:12 <Rotaerk> I've just decided to take a break from learning FP and actually *make* something
23:04:15 <holmak> I disagree that interop necessarily kills abstraction; Clojure interops with Java, but provides its own awesome immutable data structures, so it is OK.
23:04:16 <jmcarthur> erikc: that makes me feel a little better, i think
23:04:20 <Rotaerk> I've spent too long in programming theory
23:04:25 <Rotaerk> without doing anything
23:04:33 <TheColonial> Rotaerk: the problem when learning F# is that it's too easy to remain in the "imperative" world...
23:04:48 <TheColonial> that code sample is very non-FP :)
23:04:50 <Rotaerk> TheColonial, the *good* thing about F# is that it can gradually phase you into FP
23:04:54 <TheColonial> I'm not being harsh :D
23:04:56 <dibblego> I wouldn't call F# "learning FP"
23:05:05 <TheColonial> dibblego: Aye, true.
23:05:08 <erikc> http://paste.fac9.com/hpaste.fcgi/view?id=28
23:05:10 <copumpkin> Rotaerk: it can, but most likely people picking it up won't have much incentive to go FP
23:05:11 <dibblego> more like "shinier imperative programming"
23:05:13 <holmak> I don't think they made a full set of libraries for F#, it seems to lean on the C# libs way to much
23:05:25 <holmak> which crosses the line from interop to dependence
23:05:30 <jmcarthur> eh
23:05:34 <Rotaerk> copumpkin, I actually picked it up simply as a more terse syntax comparable to C#, no interest in FP
23:05:43 <Rotaerk> but it's gradually sucking me in
23:05:49 <copumpkin> NO INTEREST IN FP!?!?!!??!!?!?
23:05:55 <TheColonial> holmak: The F# libraries were intended to leverage the .NET libraries that already exist... and fill the gaps where it didn't make sense. ('sense' is rather subjective :))
23:06:02 <erikc> the problem is if you want your f# module to be .net friendly, you need to doll up the outer interface into objects
23:06:08 <jmcarthur> :\
23:06:12 <Rotaerk> copumpkin, yep, at the time that i chose to use F#, I'd never looked into FP and didn't understand anything about its benefits
23:06:18 <copumpkin> ah
23:06:20 <TheColonial> erikc: aye indeed.
23:06:28 <copumpkin> :/
23:06:30 <copumpkin> :\
23:06:33 <copumpkin> :|
23:06:37 <erikc> TheColonial: hehe, and the funny part is a lot of stuff that was in the initial F# libraries have been subsumed into .NET4 as objects and remoevd from F#
23:06:39 <Rotaerk> and since then I've started learning some haskell
23:06:40 <jmcarthur> Fugly#
23:06:46 <copumpkin> jmcarthur: lol
23:06:57 <TheColonial> erikc: ha! yeah that's about right :)
23:07:10 <copumpkin> microsoft visual active ocaml++# 2010
23:07:14 <copumpkin> = F#
23:07:16 <Rotaerk> heh
23:07:28 <TheColonial> that's a little bit of a disservice to ocaml :)
23:07:41 <jmcarthur> ocaml is.... not so great either, IMO
23:07:45 <TheColonial> if you take F# code that doesn't interface with C#, and doesn't use the .NET framework... it's not that bad. but then it's basically ocaml.
23:08:13 <TheColonial> jmcarthur: i dont know it well enough to have an opinion :)
23:08:13 <jmcarthur> at least i have seen some decent idiomatic ocaml code. i haven't really been impressed with F# code yet
23:08:20 <TheColonial> fair enough.
23:08:29 <Rotaerk> you could like F# better; mine's rather... newbish
23:08:31 <jmcarthur> i promise i try really hard to be syntactically unbiased
23:08:40 <Rotaerk> here's other F# code:
23:08:44 <dibblego> F# is OCaml without the good bits
23:08:45 <jmcarthur> Rotaerk: yeah, i recognize that :)
23:09:03 <TheColonial> dibblego: aye i think you're right.
23:09:13 <copumpkin> Rotaerk: I see you're in #nemerle, how's that?
23:09:50 <Rotaerk> I actually know nothing about it :D
23:10:06 <Rotaerk> I was invited there for some reason, and just kind of stuck there
23:10:32 <holmak> I personally find OCaml syntax really unpalatable
23:10:47 <Rotaerk> http://codepad.org/1d9jnU8t
23:11:01 <holmak> In so many places they have the same constructs as Haskell, but seem to make arbitrary choices of symbols that make it much harder to read
23:11:16 <holmak> this is all IMO, of course
23:11:23 <holmak> very subjective thing, syntax
23:11:27 <Rotaerk> OO in F#
23:11:45 <TheColonial> holmak: certain pales in comparison to haskell syntax imho.
23:12:04 <TheColonial> F# OO is just awful, no matter how "good" it is.
23:12:25 <holmak> let me be clear, when i say syntax, i mean crazy lowlevel stuff like choice of : over :: for type annotation, etc
23:12:39 <holmak> semantics are a separate issue
23:13:04 <TheColonial> i see
23:13:43 <erikc> i basically want to clone the vs2010 f# integration for haskell
23:13:48 <copumpkin> I just don't like having to put more than the bare minimum syntax in for the most common operations
23:13:50 <holmak> So its a very subjective thing, that i like Haskell's $ operator, and so on
23:14:00 <copumpkin> such as creating a binding
23:14:19 <erikc> cause changing a bit of code and getting squigglies everywhere the types need fixing up is graet
23:14:30 <Rotaerk> TheColonial, it's beautiful compared to C# OO
23:14:36 <copumpkin> erikc: that's where leksah is going I think
23:14:42 <erikc> cool
23:14:46 <holmak> fantastic
23:14:47 <TheColonial> Rotaerk: hrm. not sure i agree with that. but each to their own :)
23:15:15 <holmak> my main objection is that the .NET language designers never seem to _not_ add a feature if they possibly can
23:15:44 <TheColonial> holmak: i think that's a great point. there are things coming in C# and .NET that scare me.
23:15:48 <holmak> So you end up with F# being functional, imperative, declarative, OO, who knows what else
23:15:53 <Rotaerk> heh, it's actually the syntax of F# classes that made me interested in it over C#
23:16:16 <TheColonial> the syntax of F# classes makes me not want to use it :) and hence i only do if i need to expose it to other .NET langs.
23:16:18 <Rotaerk> much less noise
23:16:23 <holmak> Yeah! C# was a solid Java-style OO languge (better than Java, I'd say), but they can't resist adding lambdas and things.
23:16:31 <holmak> Which just adds redundancy
23:17:00 <Rotaerk> holmak, err, lambdas are better than objects for encapsulating first class functions
23:17:01 <TheColonial> aye it does. but it's only syntactic sugar. things like the "dynamic" keyword are going to open up a whole raft of issues
23:17:10 <holmak> I don't want to write FP badly in C#; if I want FP, I'll go use a nice functional language
23:17:11 <Rotaerk> much less cumbersome to deal with
23:17:14 <TheColonial> Rotaerk: in .NET, lambdas are objects.
23:17:25 <Rotaerk> I mean syntactically
23:17:33 <Rotaerk> to create a class for every lambda would be a bit much
23:17:47 <Rotaerk> which is why the introduction of lambdas to C# is a blessing
23:17:56 <TheColonial> Rotaerk: agreed. but most of the time you could do the same with anonymous delegates
23:18:01 <holmak> It's a fair point. But just in general, there seems to be way too much redundancy in the language
23:18:10 <holmak> And they only add to it.
23:18:17 <Rotaerk> TheColonial, lambdas can do a little more than that, but yea, they're mostly syntax sugar for that.
23:18:24 <Rotaerk> (the little more being expression trees)
23:18:38 <Rotaerk> and type inference
23:18:41 <TheColonial> true.
23:18:41 <holmak> And I don't mean that in the "imperative languages have poor abstraction facilities" way
23:19:01 <Rotaerk> holmak, OO and FP aren't at odds.
23:19:11 <copumpkin> Rotaerk: they sort of are though
23:19:17 <TheColonial> Rotaerk: i reckon they are
23:19:22 <copumpkin> OO is about wrapping state in objects
23:19:22 <dibblego> OO does not exist :)
23:19:25 <TheColonial> objects imply state? no? FP implies no state.
23:19:39 <TheColonial> dibblego: dont burst the bubble :D
23:19:41 <copumpkin> yeah, first of all OO is ridiculously ill-defined :P
23:19:51 <copumpkin> but even by what seems to be common perception of it
23:19:58 <copumpkin> I'd say they're at odds
23:19:59 <holmak> C can be written in an OO style, for certain values of OO
23:20:18 <TheColonial> aye, but that's like saying "it's got pretty good breath.. for a dog."
23:20:19 <Rotaerk> OO as I understand it is defining an interface (operational model) and then extending it with arbitrary data models (subclasses)
23:20:29 <holmak> But I think they take it too far when they have F# syntax for writing classes just as you would in C#
23:20:33 <Rotaerk> it's implemented in Haskell as type classes
23:20:43 <holmak> Give me algebraic types and type classes!
23:20:46 <dibblego> Rotaerk, no, type-classes are something else altogether
23:21:02 <holmak> Type classes are a lot like interfaces
23:21:06 <Rotaerk> type classes are equivalent to interfaces
23:21:11 <dibblego> they are very much not like interfaces
23:21:13 <holmak> Slightly better though
23:21:21 <dibblego> *completely different*
23:21:22 <Rotaerk> they are more... flexible than interfaces
23:21:25 <copumpkin> Rotaerk: typeclasses are strictly more powerful than any interface mechanism I've heard of in an OO language
23:21:25 * TheColonial is staying outta this one :P
23:21:32 <holmak> How are they totally different?
23:21:32 * dibblego ughs and runs away
23:21:38 <copumpkin> lol
23:21:38 <Rotaerk> copumpkin, howso
23:21:50 <Rotaerk> the only difference I know of is that interfaces are more cumbersome to deal with
23:22:02 <Rotaerk> but they both reduce to: set of operations that are extendable by any number of data models
23:22:05 <dibblego> the newtype keyword is more closely related to an interface than the class keyword
23:22:24 <dibblego> type-classes implement implicit dictionary passing
23:22:32 <jmcarthur> IMO, OO is nothing more than message passing
23:22:35 <dibblego> C# 4.0 will have implicits (iirc?) which is more like type-classes
23:22:40 <jmcarthur> anything else, even interfaces, is just extra
23:22:43 <dibblego> interfaces have *nothing* to do with type-classes
23:23:08 <holmak> Really? I think of things like Show
23:23:17 <Rotaerk> dibblego, you say that but haven't explained how
23:23:21 <holmak> And consider how C# would have something like IShowable
23:23:32 <dibblego> Rotaerk, yes I have -- interfaces have nothing to do with implicit dictionary passing
23:23:39 <holmak> "Oh hey, it's an arbitrary type that I can turn into a string!"
23:23:45 <dibblego> newtype IShowable a = S (a -> String)
23:23:45 <Rotaerk> what's implicit dictionary passing?
23:23:49 <dibblego> that is more like interfaces
23:24:09 <dibblego> Rotaerk, there is no equivalent in C#/F# so I cannot answer the question in that context
23:24:23 <Rotaerk> okay, I'll learn more about that then
23:24:42 <erikc> the dictionary is carried with the object rather than a separate parameter, not sure why that is different
23:24:48 <dibblego> Scala implements type-classes with the implicit keyword
23:25:36 <Rotaerk> trying to find these 4.0 "implicits" you're talking about
23:25:45 <copumpkin> you could think of c++'s vtables as dictionaries of functions that get passed around through the "this" pointer that represents an object
23:25:51 <dibblego> maybe I imagined that
23:26:29 <TheColonial> dibblego: Quite poss. it's not ringing bells for me.
23:26:30 <holmak> I don't follow how newtype is like an interface; it is just an alias for a type signature
23:27:12 <dibblego> holmak, you have an instance i which implements it with function f, then let i = S f
23:27:25 <copumpkin> ugh this code I'm reading is so stateful
23:28:25 <copumpkin> dibblego: isn't that just explicitly creating a one-function dictionary like those used behind the scenes in typeclasses?
23:28:31 <holmak> Sure, but how does that analogy extend to interfaces of more than one function?
23:28:44 <dibblego> copumpkin, yes, the "behind the scene" part is critical
23:28:46 <holmak> also, http://www.haskell.org/haskellwiki/OOP_vs_type_classes#Type_classes_are_like_interfaces.2Fabstract_classes.2C_not_classes_itself
23:28:53 <copumpkin> ah
23:29:18 <dibblego> holmak, data IShowableReadable a = S (a -> String) (String -> a)
23:30:10 <holmak> Ok, I see that you can certainly use data/newtype to make interfaces
23:30:30 <holmak> But I don't see why type classes are *not* like interfaces
23:30:42 <Rotaerk> type classes and interfaces reduce to the same role/purpose in programming
23:30:45 <holmak> Certainly type classes are more powerful
23:30:51 <Rotaerk> they just do it in different ways
23:30:57 <dibblego> Rotaerk, repeating something that is not true, won't make it more true
23:30:59 <Rotaerk> type classes a bit more flexible
23:31:08 <copumpkin> Rotaerk: well, you use typeclasses for many things you wouldn't use for interfaces
23:31:19 <holmak> dibblego, can you explain?
23:31:30 <Rotaerk> copumpkin, like what?
23:31:56 <holmak> I feel like we are drowning out dibblego, dude isn't getting a chance to explain himself
23:32:04 <dibblego> holmak, here is one difference; a type-class must have at least one type parameter and at least one of those type parameters must appear on each function -- this is for specific reasons -- those reasons imply that type-classes have nothing to do with interfaces
23:32:07 <Rotaerk> true, *hushes*
23:32:34 <dibblego> if we suppose that some .NET language had implicit arguments
23:32:55 <holmak> I don't know what implicit arguments means
23:33:04 <holmak> Could you explain?
23:33:05 <dibblego> suppose your IShowable<A> interface
23:33:09 <holmak> k
23:33:49 <dibblego> if it were passed to function f, then at each call to f, then the compiler looks the appropriate implementation after inference for A (without ambiguity else error), then this is more like type-classes
23:34:36 <copumpkin> Rotaerk: take typeclasses that operate on type constructors, for example, or the Suitable typeclass used in rmonad
23:34:37 <dibblego> suppose pseudo-C#: void println<A>(A a)(implicit Showable<A> s) { Console.WriteLine(s.show(a)); }
23:34:48 <Rotaerk> oh right, type-classes don't do dynamic dispatch
23:34:48 <dibblego> then at the call site: println(7)
23:34:54 <Rotaerk> it's all compile time..
23:35:08 <dibblego> then the compiler resolves the Showable<Int> argument
23:35:47 <dibblego> and the compiler also enforces the fact that the A in IShowable<A> appears in all methods of IShowable
23:35:59 <dibblego> now you're talking about something like type-classes by bending interfaces
23:36:17 <TheColonial> there is an implicit keyword in C# which allows you to implement conversions between types, but this isn't a new language feature.
23:36:44 <dibblego> ah yeah maybe I was thinking of that
23:37:06 <copumpkin> Rotaerk: multiparameter typeclasses in particular can stray quite significantly from "interfaces"
23:37:15 <Rotaerk> ah
23:37:16 <copumpkin> but even single-parameter ones can be different
23:38:42 <holmak> dibblego: So is the difference purely in the fact that type classes are resolved at compile time?
23:39:08 <dibblego> holmak, they are "passed implicitly"
23:39:24 <dibblego> the difference is "they are not in any way similar to interfaces"
23:39:33 <dibblego> you may as well compare type-classes to turkeys
23:39:39 <dibblego> look they both start with 't'!
23:39:50 <Rotaerk> err, you can pass objects that implement interfaces implicitly into functions that expect that interface
23:39:56 <holmak> You are losing me
23:39:56 <Rotaerk> i.e. no explicit casting required
23:40:00 <holmak> Hold on
23:40:11 <TheColonial> Rotaerk: only if the class implicity implements the interface
23:40:11 <holmak> I appreciate the explanation, btw
23:40:20 <TheColonial> if it's an explicit implementation, then it has to be casted.
23:40:27 <holmak> What do you mean, passed implicitly?
23:40:40 <Rotaerk> TheColonial, hmm, actually I guess that depends on language
23:40:41 <Rotaerk> in C#, no
23:40:43 <Rotaerk> in F# yes
23:40:45 <dibblego> holmak, like the IShowable was when I called println(7)
23:41:24 <Rotaerk> oh wait nevermnd I see waht you mean
23:41:33 <TheColonial> Rotaerk: you're talkinga bout C# though? if you implement an interface explicitly in C#, you have to cast it. F# is a diff kettle of fish for sure. there's no such thing as explicitly implementing interfaces in F# i believe.
23:41:38 <TheColonial> Rotaerk: ok :)
23:41:41 <dibblego> yes nominal subtyping is a (terrible) way of implementing implicit type conversion
23:41:55 <Rotaerk> in F# all interface implementations are explicit
23:42:07 <Rotaerk> and in any case, this distinction only points out that type classes are less cumbersome tahn interfaces
23:42:13 <Rotaerk> but they still share the core purpose
23:42:17 <holmak> So if i have a Haskell function;
23:42:22 <dibblego> no, they are completely different for completely different purposes
23:42:25 <TheColonial> Rotaerk: are you sure? i'm going to have to check on that :)
23:42:28 <Rotaerk> that being the abstraction of data models from an operational model
23:42:33 <holmak> print :: Show a => a -> String
23:42:43 <dibblego> you cannot emulate the purpose of type-classes in any .NET language
23:42:56 <dibblego> the closest hack I've ever seen is the "singleton design pattern"
23:43:04 <holmak> I won't argue that type classes are more powerful that interfaces
23:43:04 <Rotaerk> how's singleton related?
23:43:08 <holmak> *aren't
23:43:18 <Rotaerk> singleton just means one global instance
23:43:19 <TheColonial> Rotaerk: yup. you're right. "In F# when you have a class which implements an interface that class makes use of explicit interface implementation."
23:43:19 <dibblego> holmak, their "power" cannot be compared -- they are very very different
23:43:20 <erikc> ghc isnt always able to elide dictionary passing / indirect jumping through the dictionary rigth? (that'd require whole program analysis)
23:43:21 <holmak> But I'm getting lost on your implicit passing bit
23:43:51 <holmak> So a C# function sig might be "void print(IShowable a)"
23:44:02 <dibblego> holmak, observe the type of the pretend println function -- it takes two arguments -- suppose an instance is passed implicitly at all call sites
23:44:39 <holmak> you are referring to your println you typed above?
23:44:44 <dibblego> holmak, yes
23:44:46 <holmak> k
23:45:16 <dibblego> holmak, if you were feeling particularly destructive, you might have a "singleton" that holds the IShowable for A and you look it up in the println method
23:45:54 <dibblego> (and remove the argument from the signature)
23:46:06 <Rotaerk> wait.. void println<A>(A a)(implicit Showable<A> s) { Console.WriteLine(s.show(a)); }
23:46:30 <holmak> So, is your println the hypothetical C# equivalent of a type class?
23:46:42 <holmak> err, using a type class?
23:46:46 <dibblego> holmak, it's very close yes
23:46:54 <holmak> Ok, just wanted to be sure
23:47:00 <Rotaerk> how's that different from:  void println(Showable s) { Console.WriteLine(s.show()); }  println(new A());
23:47:16 <Rotaerk> where A implements Showable
23:47:18 <dibblego> holmak, certainly if you said they were for the same purpose, I would not object as I do when you say type-classes and turkeys are for the same purpose
23:47:52 <holmak> Oh good, that was pretty much what I meant; but now you have me interested
23:48:17 <Rotaerk> I don't see the reason you're defining println that way.
23:48:58 <holmak> What Rotaerk said; I don't understand what you mean by the implicit arg
23:49:08 <Rotaerk> if A implements Showable, why are you passing the a instance *and* the showable interface to a into the function... dynamic dispatch handles the resolution of WHICH implementation of Showable to use
23:49:15 <dibblego> Rotaerk, in your case, the type A must be aware of Showable
23:49:22 <Rotaerk> it is
23:49:24 <holmak> Oh aha
23:49:34 <holmak> I think I know what you mean now
23:49:43 <Rotaerk> dibblego, oh are you talking about implementing interfaces without changing the class itself?
23:49:52 <Rotaerk> i.e. the adapter pattern
23:49:56 <holmak> So this is all about how you can "implement" a type class after a type has been defined?
23:50:06 <dibblego> with a type-class, the type A may exist for 50 years before the type-class implementation
23:50:17 <holmak> Ah, fantastic, I understand now
23:50:17 <Rotaerk> okay, that's done in OO with interfaces using adapters
23:50:20 <dibblego> holmak, that's part of it yes
23:50:35 <dibblego> no, it's an unsolved problem
23:50:54 <Rotaerk> i.e. make a new class:  ShowableA that takes an A into its ctor and implements Showable in terms of it
23:50:55 <dibblego> also, OO does not exist (it really doesn't) :)
23:51:19 <Rotaerk> I don't see how that's any different other than being more cumbersome
23:51:42 <dibblego> I'd like to give up now please :)
23:51:48 <Rotaerk> okay :P
23:51:50 <dibblego> (though someone really needs to put this myth to sleep)
23:51:57 <copumpkin> dibblego: I call for a blog post!
23:52:02 <Rotaerk> yea that
23:52:13 <holmak> Thanks for the patience, dibblego
23:52:30 <dibblego> RAR! well I have major surgery in a few hours so it won't be for a while at least
23:52:37 <holmak> I suspect you are trying to say something straightforward, but there is some kind of miscommunication
23:52:39 <copumpkin> ah :) good luck with that then
