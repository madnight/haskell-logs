00:21:11 <solrize> @seen cale
00:21:11 <lambdabot> cale is in #haskell, #haskell-overflow, #haskell-in-depth and #ghc. I don't know when cale last spoke.
00:22:04 <ivanm> preflex: seen Cale
00:22:04 <preflex>  Cale was last seen on #haskell 3 hours, 14 minutes and 53 seconds ago, saying: There's a new SPJ interview up on a Russian site. Really slow to load though.
00:26:37 <hackagebot> stb-truetype 0.1.1 - A wrapper around Sean Barrett's TrueType rasterizer library. (BalazsKomuves)
00:27:44 <altmattr> How can I take a function (defined by pattern matching in module A) and replace one or two of the pattern definitions from within another module B?  I want calling code to be able to switch modules to switch which version of the algorithm it works with.  I don't want to have to re-code all the functions in each module
00:28:15 <altmattr> or is this a job for some other mechanism?
00:30:10 <Beelsebob> altmattr: sounds like you need to write a more general function
00:30:22 <Beelsebob> possibly one that takes a couple of functions as input
00:30:24 <ivanm> or maybe a Class
00:30:34 <ivanm> but then it requires a different datatype
00:30:42 <ivanm> so you can use a dummy one, but that's rather dodgy IMHO
00:31:45 <Ytinasni> altmattr: do you need to change how the function in A works, or can you just make a new function in B that does what you want?
00:32:09 <altmattr> I will give you a bit more info
00:32:27 <altmattr> I am defining a type inference function over a relatively large expression language datatype
00:32:53 <altmattr> I have various extensions to the algorithm that are added in little-by-little
00:33:07 <altmattr> so using a simple version, you get a "type inference too simplistic for this function
00:33:13 <altmattr>  error every now and them
00:33:31 <altmattr> and those cases are filled in in the more complex version
00:33:49 <altmattr> There is already a lot of paramterisation going on, so I want to avoid adding anymore
00:34:15 <altmattr> plus the algorithm code is acting as a formal description of the algorith, so I don't want to clutter it with book-keeping
00:34:21 <altmattr> but I may have to by the sounds of it
00:34:33 <altmattr> or use a pre-processor?
00:35:34 <altmattr> oh - and I am a DRY fanatic, so no copy-paste!!!
00:43:03 <vav> altmattr: reluctant to speak since not very haskell savvy, but if you can use more applicative less pattern matching strategy something like http://conal.net/blog/posts/semantic-editor-combinators could be helpful
00:43:40 <altmattr> vav: never be shy in here, yours is by far the best suggestion so far :)
00:44:18 <vav> altmattr: well normally the gaping silence would have been filled by gurus galore
00:44:33 <altmattr> now I guess you are the guru :)
00:56:03 <Phillemann> What does the exception "Thread blocked indefinitely" mean?
01:01:07 <Cale> solrize: mm?
01:01:26 <Cale> solrize: What's up?
01:04:06 <Cale> Phillemann: It means that the thread is waiting for a condition to be true which the RTS is able to tell will never be true. For example, if it's waiting while trying to read an MVar, and no other thread has a reference to that MVar anymore.
01:04:48 <Phillemann> Cale: Ahhh, I see. It's good that Haskell catches this.
01:57:16 <solrize> cale ehh nothing important, i had a logic question
01:58:43 <solrize> also since you're talking about the RTS, i wonder if you (or anyone) happen to know how the thread switching timer works and also how semaphore waiting works
01:59:09 <Axman6> Cale: if you're there, i've got two questions. firstly, do you have a nice sentense that summarises what a monad is? (i'm asking you because i've learned you're the man to go to when you need something explained well ;)), and also, do you know an evilgeek? he's in #ada and says you went to school together :o
02:01:36 <quicksilver> solrize: I know somethign about those tings. I'm not sure how much detail you're asking for.
02:01:50 <solrize> quicksilver, generalities are sufficient ;)
02:01:59 <quicksilver> solrize: the non-threaded RTS does context switches at memory allocation, no interrupts.
02:02:34 <quicksilver> MVars are trivial in the non-threaded RTS case since nothing is concurrent.
02:02:39 * Axman6 found this nice definition on wikipedia for a monad "Monads allow the programmer to chain actions together to build a pipeline, in which each action is decorated with additional processing rules provided by the monad."
02:02:49 <solrize> yikes, that means all i/o is blocked during long computations if there if the compiler is smart enough to eliminate all allocation from something?
02:02:58 <quicksilver> yes, it does.
02:03:01 <solrize> so improved compiler optimization can make programs fail
02:03:11 <quicksilver> fortunately that doesn't happen often :)
02:03:15 <quicksilver> or, ever, really.
02:03:50 <solrize> yeah, for semaphores it's the threaded case that matters
02:04:22 <solrize> well i guess there could be shared memory semaphores with other processes
02:04:38 <quicksilver> I don't know how the threaded RTS implements MVars.
02:04:47 <quicksilver> JaffaCake is the man you need for that.
02:04:49 <solrize> axman6 that explanationis pretty good
02:04:54 <Axman6> yeah
02:05:38 <solrize> i saw something in the docs for parallel haskell about a 100 hz timer tick
02:05:52 <quicksilver> "A monad is a way of formalising the notion that a computation can have both a result and an effect"
02:05:52 <solrize> but wasn't sure about non-threaded
02:06:16 <quicksilver> the non-threaded RTS doesnt' context switch at *every* memory allocation, that would be stupid.
02:06:35 <quicksilver> it context switches if the current thread becomes blocked, or at least as often as some timer.
02:06:40 <Ke> solrize: I think most people use more than 100 ticks/s
02:06:42 <quicksilver> which you can set with the RTS switch -C
02:07:18 <Ke> (though I don't)
02:07:52 <Axman6> @src IO
02:07:53 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
02:08:37 * quicksilver would like that removed from @src.
02:09:51 <Axman6> well, it was useful for explaining to someone that monads are ot about side effects
02:10:32 <quicksilver> how does that explain that monads are not about side effects?
02:10:39 <quicksilver> how does it explain *anything* ?
02:10:49 <quicksilver> it's an opaque description in a subtle language which is not haskell.
02:11:23 <ivanm> quicksilver: so monads can only be explained properly in Haskell? ;-)
02:11:43 <Axman6> well, it showed that IO in ghc is defined as a function, like the state monad
02:12:08 <quicksilver> Axman6: but it's not.
02:12:16 <quicksilver> that -> isn't a function.
02:12:22 <quicksilver> ivanm: no, that's not my thesis.
02:12:37 <ivanm> sshhh!
02:12:43 <ivanm> you're ruining my thesis here! :p
02:12:49 <quicksilver> ivanm: my thesis is that the source of a type, which is written in a subtle non-haskell language is only useful to people who understand the subtleties of that language.
02:13:03 <quicksilver> since I don't understand the subtleties, I certainly can't use that as a basis for explaning anything.
02:13:07 <ivanm> hmmm...
02:13:20 <Axman6> how is that not a function?
02:13:21 <ivanm> it probably doesn't help that I came in half-way through this discussion... ;-)
02:13:33 <quicksilver> Axman6: because State# and RealWord are not types.
02:13:35 <quicksilver> Axman6: it's not haskell.
02:13:43 <Axman6> bah, details ;)
02:13:52 <quicksilver> Axman6: a function returns the same value every time you give it the same input.
02:14:04 <quicksilver> that's the defining characteristic of "function"
02:14:30 <quicksilver> whereas, the #-language which GHC uses actually has side-effects
02:14:34 <quicksilver> it's not a functional language anymore.
02:15:09 <Axman6> and i thought the point of the RealWorld part there was that the compiler looked at it as having changed every time it's used, so you do always get the same out put for the same input... but you can never get the same input again
02:15:34 <quicksilver> Axman6: what's the different between RealWorld and State# RealWorld?
02:15:53 * Axman6 it noticing that people seem to talk about other languages in #Ada much more than they talk about Ada
02:16:20 <Axman6> quicksilver:  i understand it's a hack, and not really haskell. it's an implementation detail, and i'm fine with that
02:17:44 <quicksilver> but as an implementation detail I'm not convinced it's a good basis for explanations.
02:17:47 <quicksilver> that's all.
02:18:30 <Axman6> argh, i can't get haskeline to upgrade. can't seem to find iconv, even when i tell it where it's installed
02:19:54 <Axman6> quicksilver: well, my point wasn;t that IO uses functions, it was that monads aren't about side effects. and i think i managed to make the point without the definition anyway :)
02:22:52 <solrize> Haskell gets some resistance due to the complexity of using monads to control side effects. Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?"
02:23:18 <quicksilver> Axman6: fair enough. I do tend to use the word "effect" for what monads are about, but you do have to recognise effect != side-effect.
02:23:30 <quicksilver> that could be considered a poor choice of words, therefore.
02:23:40 <Axman6> yeah
02:23:48 <Axman6> action might be more appropriate
02:24:11 <Axman6> though i never liked it when people tried to explain monads as actions, because i thought htf is a list an action?
02:24:29 <Vanadium> I figured monads for IO basically comes down to passing a whole lot of nested callbacks to the OS instead of requesting I/O from it
02:24:56 <Vanadium> That is not really accurate but it is more intuitive than the category theory thing~
02:25:52 <quicksilver> Axman6: I use an action for the whole thing.
02:26:00 <quicksilver> Axman6: an action has both a result and an effect.
02:26:34 <quicksilver> Axman6: For example, in this terminology you would say: the operator (>>) combines two actions, running the effects left to right. The result of the first action is discarded, the result of the second action is returned.
02:26:35 <Axman6> yeah, explaining it like that definitily implies a side effect
02:26:51 <quicksilver> well in a sense it *is* side.
02:26:54 <quicksilver> it's side to the result.
02:27:15 <quicksilver> it's not side in the specific, technical, sense of "side-effect caused by evaluation"
02:28:32 <Axman6> yeah
02:30:09 <quicksilver> but in the sense that a monadic computation produces a result and *also* does something else.
02:30:22 <quicksilver> that something else is a "side-effect" relative to the "main job" of producing a result.
02:33:34 <ivanm> does anyone know if cdsmith frequents this channel?
02:41:31 <quicksilver> ivanm: he is certainly seen here from time to time. I wouldn't say his presence is terribly frequent.
02:41:36 <EvilTerran> preflex: seen cdsmith
02:41:37 <preflex>  Sorry, I haven't seen cdsmith
02:41:45 <quicksilver> wow.
02:41:48 <ivanm> because I wanted to complain to him that he stole the idea for a blog post title! :p
02:41:56 <quicksilver> mauke: when was preflex's database reset?
02:42:09 <quicksilver> preflex: seen edwinb
02:42:09 <preflex>  edwinb was last seen on #haskell 31 days, 12 hours, 23 minutes and 17 seconds ago, saying: * edwinb might be from St Andrews or Edinburgh
02:42:37 <ivanm> so he himself doesn't know where he's from? :o
02:42:53 <Phillemann> In the notation "Data { field = field }", is the function "field :: Data -> Fieldtype" overriden in favor of the function "field :: Fieldtype"? If it's not, why is the notation not ambiguous?
02:43:42 <ivanm> Phillemann: you have a different function of type "field :: Fieldtype" ?
02:43:48 <ivanm> that isn't even a function, is it?
02:44:54 <Phillemann> ivanm: No, I mean when I create a record like this "Data { field :: Int }" then it creates a function "field :: Data -> Int" for me, doesn't it? So I can do: let x = Data 10; putStrLn $ field x
02:45:22 <ivanm> Phillemann: yes
02:45:35 <ivanm> Phillemann: actually, you can't... putStrLn requires a String ;-)
02:45:41 <ivanm> but you can do print $ field x
02:45:42 <ivanm> ;-)
02:45:45 <Phillemann> Hehe
02:46:06 <quicksilver> Phillemann: yes. That kind of shadowing is explicitly permitted, and not a warning.
02:46:19 <quicksilver> Phillemann: I mean - yes, you are shadowing field at a different type.
02:46:34 <Phillemann> quicksilver: Ahhhh, okay. :)
02:46:34 <quicksilver> personally I think it's poor style, precisely because it's shadowing at a different type which I think is ugly.
02:46:44 <quicksilver> Other people disagree with me quite strongly, including Cale here :)
02:47:05 <Phillemann> quicksilver: I think so too, that's why I was astounded that it's common practice.
02:47:42 <ivanm> quicksilver: what shadowing is happening here? the fact that field has been "defined" as only having type Int ?
02:48:07 <Cale> Axman6: mm... for a single sentence, it depends on the background of the person I'm talking to, and what kind of explanation I want to give, but as far as the average programmer is concerned, monads are a kind of library which supports a particular API (consisting of return and bind), so that a bunch of useful functions can be, and have been written to work in any monad (the stuff in Control.Monad, among other librari
02:48:07 <Cale> es).
02:48:56 <Axman6> heh, that's a pretty nice way of side stepping actually explaining what a monad is, well done :P
02:49:11 <WorkyBob> I don't think it is
02:49:16 <Cale> Axman6: Well, usually I'd follow that up with an actual explanation.
02:49:19 <WorkyBob> that *is* what a monad is
02:49:22 <WorkyBob> it's all the important parts of it
02:49:29 <WorkyBob> if all you want to do is write a program
02:49:37 <Axman6> in haskell, that's what a monad is
02:49:44 <Cale> Axman6: (about the type constructor and the types of return and bind, and the laws)
02:49:49 <WorkyBob> yeh... if all you want to do is write a program
02:49:57 <Vanadium> ... you might just be a programmer!
02:50:08 <Cale> If I was explaining to a mathematician, it would be a different story.
02:50:21 <steez> yo all
02:50:26 <Cale> yo
02:50:30 <Axman6> sup
02:50:41 <BONUS> i like this explanation: an applicative functor that allows for join :: m (m a) -> m a
02:50:57 <Cale> おっす
02:50:57 <WorkyBob> BONUS: yes, that is a nice explanation
02:51:08 <WorkyBob> it forces them to ask "what's an applicative functor"
02:51:08 <Vanadium> I still have no intuition what an applicative functor is
02:51:11 <WorkyBob> and learn all the APIs
02:51:12 <Vanadium> yes
02:51:13 <doserj> I like: a monad is what you need to compose effectful functions
02:51:16 <Cale> Useless to anyone who doesn't know what an applicative functor is ;)
02:51:22 <WorkyBob> rather than just what a monad is
02:51:32 <WorkyBob> Cale: no, very useful to them -- it causes them to go and learn the dependancy for a monad
02:51:35 <BONUS> well then you say that an applicative functor is a functor that supports pure and <*> :]
02:52:01 <WorkyBob> it means we get fewer people writing do x <- m; y <- m1; return f x y
02:52:05 <opqdonut> BONUS: try to give an intuition for join. it seems really weird to a newbie. something like "if we have a machine that produces a machine that returns a, we can think of this just as a machine that returns a"
02:52:07 <Vanadium> Pure ought to be the same as return in all cases, right?
02:52:15 <WorkyBob> Vanadium: it ought to be, yes
02:52:27 <WorkyBob> it isn't because applicatives weren't known about when the monad class was written
02:52:33 <BONUS> yeah, what i said about the explanations was mostly in jest. no one will really get it if you say: applicative with join
02:52:42 <quicksilver> opqdonut: If you have a computation which produces as its result another computation, you can simply run that result computation as well.
02:52:56 <Cale> WorkyBob: I don't see anything wrong with writing code like that. Sure it's liftM2 f m m1, but there's no harm in not learning the library all at once :)
02:52:58 <opqdonut> quicksilver: what i tried to say:)
02:53:04 <BONUS> i propose a bottom down approach, where you first teach someone Functor and its instances and intuition, then Applicative and the instances and the intuition
02:53:15 <opqdonut> bottom down :D
02:53:16 <quicksilver> "bottom down" ?
02:53:19 <quicksilver> is that like bums on seats?
02:53:21 <BONUS> lol
02:53:22 <WorkyBob> Cale: quite – but it's usually better to learn the dependancies *before* the head of the chain
02:53:38 <BONUS> what a mistake-a-to-make-a
02:53:44 <quicksilver> ivanm: "field :: Data -> Int" is shadowed by "field :: Int"
02:53:51 <dibblego> BONUS, I have found it works best (Functor first)
02:53:58 <Cale> Though I'm not certain I'd consider Applicative a dependency.
02:54:10 <Cale> Functor, perhaps, that's more fundamental.
02:54:14 <WorkyBob> Cale: it absoutely is, monads are "just" applicatives with join
02:54:29 <BONUS> if someone knows the intuition for Applicative and how it allows you to take advantage of the semantics of each applicative to use normal functions on values in contexts, monads aren't a big mental leap
02:54:30 <ray> monads are just functors with join and return
02:54:40 <Cale> ray: right
02:54:40 <WorkyBob> ray: which gets them ap as well ;)
02:54:53 <WorkyBob> so lets not miss out the stage in which we gain ap
02:54:54 <ray> but applicative is about ap
02:55:00 <WorkyBob> ray: exactly
02:55:03 <ray> now if you had Pointed
02:55:09 <WorkyBob> so monads are applicatives with join
02:55:19 <ray> monads are pointed functors with join
02:55:21 <Cale> Yeah, monads are pointed functors with join.
02:55:26 <Vanadium> ... pointed?
02:55:31 <WorkyBob> your statement is equivalent to "monads are nothing with join and return"
02:55:33 <Cale> Applicative just happens to get you pointed.
02:55:34 <BONUS> if you really get what (+) <$> [1,2,3] <*> [2,3] does, it's not hard to get what [1,2,3] >>= (\x -> [x+2,x+1]) will do
02:55:35 <WorkyBob> Vanadium: where pure should be
02:55:41 <BONUS> lol
02:55:53 <WorkyBob> Cale: equally, we get fmap from the monad operations
02:56:00 <WorkyBob> so monads don't depend on functors
02:56:11 <Cale> WorkyBob: the return and >>= formulation, sure
02:56:11 <ray> conceptually they totally do
02:56:27 <BONUS> Pointed is a typeclass that doesn't exist in the standard library but it should. it should be defined as class Functor f => Pointed f where pure :: a -> f a
02:56:28 <WorkyBob> Cale: so the dependancy on functors is the same as the dependancy on applicatives
02:56:33 <WorkyBob> functors are less experssive than monads
02:56:39 <WorkyBob> applicatives are less expressive than monads too
02:56:54 <dibblego> depend*e*ncy :)
02:56:56 <Cale> WorkyBob: this is true
02:57:16 <WorkyBob> so I guess "monads are just pointeds with join" would be the most true
02:57:28 <Cale> pointed functors
02:57:30 <WorkyBob> no
02:57:32 <WorkyBob> pointeds
02:57:37 <WorkyBob> you can derive functor from the monad operations
02:57:37 <Cale> eh?
02:57:47 <WorkyBob> in the same way as you can derive applicative from the monad operations
02:57:50 <ivanm> quicksilver: I thought record notation was a type of syntactic sugar where it was understood that all "functions" within data Foo = Foo { ... } had "Foo -> " prepended to their type
02:57:52 <Cale> Not from return and join alone, surely?
02:58:12 <BONUS> you need fmap for >>= if you have join
02:58:16 <Deewiant> ?src liftM
02:58:17 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:58:17 <WorkyBob> so you do
02:58:18 <WorkyBob> hmm
02:58:32 <ray> functors are important dude
02:58:32 <soupdragon> join and return don't give you fmap
02:58:37 <WorkyBob> so yeh, you do need fmap
02:58:56 <BONUS> but if you have class Functor f => Pointed f, it's ok to say that they're pointeds with join imo
02:59:00 <WorkyBob> so hmm...
02:59:00 <Axman6> liftM == fmap?
02:59:03 <Cale> Pointed functors are too inexpressive to bother explaining as a separate step though.
02:59:12 <BONUS> yeah
02:59:16 * WorkyBob ponders -- *must* monads have >>= in them?
02:59:17 <Cale> (that is, over what Functor already gives you)
02:59:28 <Vanadium> I cannot think of any functor right now that is not pointed :(
02:59:28 <Cale> WorkyBob: yes, effectively
02:59:31 <WorkyBob> is a monad a monad if it only has pure and join?
02:59:38 <Cale> WorkyBob: no
02:59:41 <WorkyBob> okay
02:59:43 <Cale> WorkyBob: It needs fmap too
02:59:45 <Vanadium> Just, const, (:[]), Right... :s
02:59:51 <Cale> fmap, return and join --> monad
02:59:57 * WorkyBob conceeds that applicative is not necessarily a dependency then
03:00:00 <BONUS> if a monad is a functor, then it doesn't have to have >>= imo, i mean you just do m >>= f = join (fmap f m)
03:00:02 <soupdragon> what if we didn't have typeclasses
03:00:02 <Cale> (in fact that's the original definition)
03:00:03 <WorkyBob> just a useful thing to have along the way
03:00:24 <Vanadium> BONUS: That also seems easier to wrap my head around
03:00:45 <opqdonut> soupdragon: then we'd pass function dictionaries around
03:00:51 <BONUS> also i like: you have a monad if return and kleisli composition form a monoid
03:00:54 <BONUS> what was the haiku again
03:01:02 <Cale> BONUS: itym a category
03:01:04 <ray> @quote haiku
03:01:05 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
03:01:05 <lambdabot> read
03:01:10 <Cale> It's not really a monoid
03:01:14 <opqdonut> type Monad a = Monad { return :: a -> m a, ... }
03:01:18 <Cale> It's a category, the Kleisli category
03:01:21 <BONUS> ah
03:01:24 <opqdonut> gah, Monad m
03:01:24 <soupdragon> theoretically you don't need >>=
03:01:25 <soupdragon> but to be practical, >>= is important
03:01:46 <Cale> return and <=< has the advantage that the laws are really easy to remember
03:01:51 <opqdonut> indeed
03:01:51 <ray> the return and >>= typeclass is only because >>= is what people actually use
03:01:54 <Cale> return <=< f = f
03:01:59 <Cale> f <=< return = f
03:02:06 <RayNbow> :t (>=>)
03:02:08 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
03:02:10 <opqdonut> and associativity
03:02:11 <RayNbow> :t (<=<)
03:02:12 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
03:02:15 <Cale> (f <=< g) <=< h = f <=< (g <=< h)
03:02:21 <BONUS> yeah
03:02:36 <WorkyBob> Cale: it also has the advantage that (<=<) is just a nicer operation all round
03:02:40 <BONUS> the laws are 10x prettier if you use <=< instead of >>=
03:02:49 <opqdonut> pretty nice with join also
03:02:50 <opqdonut> imo
03:02:58 <ray> >>= has an uglier type, it's true
03:03:03 * WorkyBob never understood why the API has >>= in it, and not =<<
03:03:26 <RayNbow> (>>=)'s type signature is okayish if you compare it to .NET's SelectMany's type signature :p
03:03:33 <RayNbow> in C# syntax :p
03:03:51 <ray> i'm comparing it to join's type
03:03:52 <BONUS> maybe cause it's closer to the parameter of a lambda when you do blah >>= (\x -> boo)
03:03:59 <Cale> Well, it would be good if lots of equivalent definitions were in the class definition with default definitions provided cyclically so that you could define any one of a number of minimal subsets
03:04:22 <ray> it would be good
03:04:27 <WorkyBob> that would be nice, yes
03:04:30 <Deewiant> ?ty flip (id >=>)
03:04:31 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
03:04:33 <WorkyBob> I usually find join very hard to think about
03:04:36 <WorkyBob> but =<< easy
03:04:50 <BONUS> i find them kind of the same
03:05:01 <BONUS> depends on the case
03:05:25 <Deewiant> Cale: I wouldn't be surprised if optimization were a reason to avoid that - dictionaries growing too big can be a problem
03:05:55 <Cale> Deewiant: hmm, I don't really see how... I suppose if you wanted to pass each of the functions separately as a parameter, but that's not what happens.
03:06:05 <BONUS> for instance, in the penalty monad, i find it hard to think about >>= without thinking of it as (join .) . flip fmap
03:06:52 <Deewiant> Cale: Hmm, I've just heard that it's better to have classes with few methods; I can't remember if I've heard any justification though :-)
03:07:34 <Cale> Anyway, if I'm explaining to a programmer who is starting out, I'm more likely to explain lots of examples of monads than I am to try to explain the general case.
03:07:41 <BONUS> yeah
03:08:04 <opqdonut> BONUS: penalty?
03:08:11 <Cale> Deewiant: Probably better for style reasons to have conceptually few methods, but it's okay to have lots of them if they're equivalent to one another.
03:08:34 <WorkyBob> if the type system worked a bit better one could do something like class MonadBind m where return' :: a -> m a; (=<<) :: (a -> m b) -> (m a -> m b); instance MonadBind m => Monad m where ....
03:08:44 <WorkyBob> but that would require the type checker to look at the contexts
03:08:55 <Cale> Deewiant: (and you provide default implementations so the instances only need to define one of them)
03:08:59 <Deewiant> Cale: I was thinking specifically in performance terms.
03:09:07 <Deewiant> But if you can't think of a reason, I'm fine with that. :-)
03:09:27 <Cale> Deewiant: Well, the whole class is just passing around one pointer to the dictionary.
03:09:28 <quicksilver> ivanm: perhaps, yes, but you're just talking about the declaration.
03:09:34 <quicksilver> ivanm: we're talking about pattern matching.
03:09:46 <Cale> Deewiant: no matter how many methods there might be
03:10:20 <Deewiant> Cale: Is there one global dictionary for the class or is it something that gets created when necessary
03:11:07 <quicksilver> WorkyBob: why >>= instead of =<<? because by default people write actions in left-to-right effect order.
03:11:17 <Deewiant> I'd guess it's global since there's nothing local in it, in which case it's fine
03:11:27 <quicksilver> WorkyBob: consider that parsers are one of the early motivating combinator libraries, and writing your grammar in reverse would be peculiar.
03:11:34 <WorkyBob> quicksilver: sure -- but we have do notation for doing that
03:11:43 <Deewiant> WorkyBob: We didn't originally
03:11:45 <WorkyBob> true
03:12:51 <edwinb> quicksilver: you were looking for me?
03:13:27 <Cale> Deewiant: Well, for each instance there is either a static bunch of methods packaged together in a record, or if the instance depends on the existence of other instances, a function.
03:13:35 <ray> workybob: you don't need to go to such trouble
03:13:47 <WorkyBob> ray: for?
03:13:55 <Cale> Deewiant: It's possible to write code which uses an unbounded number of instances at runtime
03:14:05 <quicksilver> edwinb: it's always nice to hear from you but, no, I was testing preflex :)
03:14:15 <edwinb> fair enough ;)
03:14:44 <edwinb> you also reminded me that I don't pay attention here enough...
03:14:47 <quicksilver> edwinb: you were just a good exampe of someone I didn't think had spoken for a while.
03:15:01 <ray> well, i guess if you don''t want to touch the definition of Monad you can do what you said
03:15:20 <Cale> For example, consider:  f :: (Show a) => Integer -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x)
03:15:34 <ray> i'm totally comfortable with touching it
03:16:04 <soupdragon> Cale,
03:16:32 <soupdragon> it is possible to run that code without an instance    Show a => Show (a,a,)  ?
03:16:39 <Cale> no
03:17:00 <soupdragon> it's only two instances then, zero and succ, no?
03:17:24 <Cale> soupdragon: Well, there's an instance for a, and then for (a,a) and then for ((a,a),(a,a))
03:17:27 <Cale> and so on
03:17:45 <Cale> But yes, they're really obtained from just two instances
03:18:15 <quicksilver> "instanceMaker :: ShowDict a -> ShowDict (a,a)"
03:18:24 <Cale> What I'm pointing out is that one of those is a function on instance dictionaries, yeah
03:18:29 <quicksilver> which can be invoked any number of times, clearly.
03:19:09 <quicksilver> I wonder if JHC's type-passing instead of dictionary passing actuall works out less efficient for this kind of case.
03:19:43 <Cale> let f :: (Show a) => Integer -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in [f n () | n <- [0..]]
03:19:46 <Cale> > let f :: (Show a) => Integer -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in [f n () | n <- [0..]]
03:19:47 <lambdabot>   ["()","((),())","(((),()),((),()))","((((),()),((),())),(((),()),((),())))"...
03:20:21 <EvilTerran> polymorphic recursion!
03:20:29 <Cale> indeed
03:21:01 * EvilTerran is reminded of data BalancedTree a = Leaf a | Branch (BalancedTree (a,a))
03:21:16 <Cale> Somehow I was thinking of the Cantor set.
03:22:16 <quicksilver> Cale: for your next trick, use polymorphic recursion to construct the Knuth up-arrow series  3^3, 3^^3, 3^^^3 as nested tuples of ().
03:22:27 <quicksilver> (as in the construction of Graham's number)
03:22:30 <opqdonut> :D
03:23:11 <EvilTerran> then express the ackermann function, likewise :P
03:23:51 <Cale> Can't I just do it using normal recursion and then that f? :)
03:25:51 <quicksilver> Cale: well, that would insert a (2^) at the beginning
03:26:16 <Cale> ah, you want the number of leaves to be right? hmm
03:30:08 <quicksilver> Cale: I was imagining the leaves in a shape which mirrors the construction
03:30:20 <quicksilver> Cale: groups of three of groups of three or something.
03:40:15 <sioraiocht> can someone expalin the term "sequence extension" to me?
03:40:28 <sioraiocht> sorry, *explain
03:41:09 <Ke> heh Sarha Palin did indeed just resign iirc ;o)
03:41:28 <Ke> Sarah
03:42:52 <Cale> sioraiocht: in what context?
03:43:31 <ivanm> Cale: in the context that sioraiocht wants to know :p
03:44:39 <sioraiocht> Cale, in this paper, it just says "Sequence extension is said to be completely monotonic on a preorder <= if both x<=y -> (a:x) <= (a:y) and x < y -> (a:x) < (a:y)
03:45:01 <sioraiocht> is sequence extension just being able to cons? =p
03:45:01 <Cale> ah, extending a sequence with a new element at the beginning
03:45:04 <Cale> yes
03:45:05 <sioraiocht> oh
03:45:10 <sioraiocht> It's just a term I have never heard before
03:45:15 <sioraiocht> and this paper is written in such poor english
03:45:22 <sioraiocht> I don't trust terms I am unfamiliar with
03:45:28 * sioraiocht is review it for a conference
03:45:31 <sioraiocht> *reviewing
03:49:08 <gaagaaga> Hi,
03:49:35 <gaagaaga> I am using HPC to test coverage of my program, and I found that empty tuple () is not covered
03:49:55 <gaagaaga> Can I achieve 100% coverage?
03:50:23 <ivanm> gaagaaga: I don't know anything about HPC, but in general AFAIK it's not possible to achieve 100% coverage
03:50:34 <ivanm> because you can never think of all possible things that can happen ;-)
03:50:44 <ivanm> also, "()"  is called "unit"
03:50:49 <ivanm> (and it isn't a tuple)
03:50:59 <Cale> ivanm: I call it the empty tuple as well
03:51:24 <Cale> (it is the unit with respect to tupling ;)
03:51:26 <ivanm> Cale: :o
03:51:37 <Vanadium> I always read tuple as two-ple and am surprised when people apply it to more than pairs :3
03:51:40 <ivanm> I thought "tuple" required at least two elements...
03:51:58 <ivanm> Vanadium: probably where it came from
03:52:07 <Cale> gaagaaga: It's obviously nothing to worry about.
03:52:19 <Cale> gaagaaga: If that's the only thing which your tests don't cover...
03:53:12 <Cale> gaagaaga: However, you might try to force the evaluation of that () somewhere.
03:53:44 <gaagaaga> Thanks
03:53:55 <gaagaaga> I am thinking is there any way to let HPC omit the ()
03:56:59 <Botje> woo, tuple sections
03:57:58 <ivanm> Botje: I'm still not sure in which GHC we'll be able to use them though :s
03:58:00 <Cale> gaagaaga: It really will show the () as covered if one of your tests forces it to evaluate that.
03:58:15 <Cale> (I just tried it)
03:58:33 <Cale> Printing the () suffices. Probably seq'ing it does as well.
03:59:15 <Cale> I suppose it's possible that it's inaccessible from where you're testing.
04:00:59 <lilac> Botje: are tuple sections implemented in GHC now?
04:01:07 * Botje votes for 6.10.5 :)
04:01:18 <Botje> http://www.haskell.org/pipermail/cvs-ghc/2009-July/049441.html
04:01:29 <Botje> spj announced it yesterday
04:01:32 <Botje> SimonPJ++
04:01:36 <Cale> kind of a funny feature :)
04:01:38 <Botje> (Max Bolinbroke)++
04:01:43 <lilac> microcelebration in honour of tuple sections! \o/
04:01:47 <Cale> But I suppose it's welcome.
04:02:16 <Cale> Watch, we'll have list sections within the week
04:02:23 <Cale> [1,,,2,3,,]
04:02:32 <ivanm> Cale: gah!
04:02:43 <Vanadium> I want [1..] to be a section
04:02:49 <lilac> ha!
04:02:53 <ivanm> Botje: I know it was announced, but when will it actually reach production?
04:02:56 <ivanm> Vanadium: :o
04:03:17 <lilac> Cale: list sections don't work so well, though. is [ ] a unary function or an empty list? :)
04:03:59 <altmattr> @seen vav
04:03:59 <lambdabot> vav is in #xmonad, #gentoo-haskell and #haskell. I last heard vav speak 3h 19m 42s ago.
04:04:24 <Botje> ivanm: no idea, but i'd like to have it Right Now(tm) :)
04:04:34 <ivanm> Botje: heh
04:05:08 <Cale> lilac: what about () ?
04:05:30 <lilac> Cale: there are no 1-tuples, so it's unambiguous imo
04:05:44 <Cale> True.
04:06:22 <lilac> some syntactic punning gives us id :: a -> (a) i suppose
04:07:05 <sayyestolife> in a pure language, what is the difference between a tuple and a list? I mean both are immutable?
04:07:09 <lilac> i think the GHC feature i'd like to see the most is type wildcards
04:07:10 <ivanm> lilac: sure there is
04:07:16 <ivanm> didn't someone produce a OneTuple library? :p
04:07:47 <lilac> sayyestolife: the length of a list is a runtime property; the length of a tuple is compile-time. lists are homogenous, tuples can be heterogenous
04:08:36 <sayyestolife> ah okay
04:08:39 <lilac> sayyestolife: conceptually, a list is an ordered collection of like things, whereas a tuple is a collection of a known set of unlike things
04:08:49 <sayyestolife> I see
04:10:04 <atom> which library should I use for basic linear algebra? (matrices, vectors)
04:10:35 <Cale> atom: There are a few choices on Hackage depending on what you want to do...
04:11:10 <Cale> hmatrix is probably the most extensive
04:11:13 <atom> Cale: I'm looking at the list of libs on haskell.org/.../Mathematics, and there are a couple of choices available
04:12:52 <atom> Cale: I just need NxM matrix multiplication, vector multiplication, resizing (adding vectors to the front) and component-wise addition.
04:13:13 <atom> oh, and vector dot product :)
04:14:03 <atom> And since I'm an utter beginner in haskell, it would be a bonus if it's not a chore to use.
04:17:38 <Cale> atom: While it's a big library, a small subset of hmatrix might satisfy you... mostly the Data.Packed.Matrix stuff, and Numeric.LinearAlgebra.Algorithms
04:18:21 <atom> I think it will do - the homepage seems nice and has a tut
04:18:42 <quicksilver> Cale: http://www.nabble.com/Re%3A-Data.Fixed.Fixed-constructor-p24642764.html
04:18:54 <quicksilver> Cale: am I making sense? Ashley just doesn't seem to see the point I'm making
04:19:03 <Cale> quicksilver: I'll have a look
04:19:30 <atom> Cale: thanks for the suggestion.
04:20:20 <Cale> quicksilver: er... what is this conversation about?
04:20:37 <quicksilver> Cale: whether the Data instance for Data.Fixed should expose the fact there is an integer "inside" it.
04:20:57 <quicksilver> as, for example, the derived instance would.
04:21:05 <Cale> uh, should there even be a Data instance of Fixed?
04:21:16 <quicksilver> that's also a reasonable question.
04:21:39 <quicksilver> I think you might reasonably used Fixed terms in a larger structure you would like to be an instance of Data.
04:21:48 <Cale> How the hell do you gfoldl over a fixed point number? ;)
04:21:51 <quicksilver> I just think Data should treat it as a primitive.
04:22:00 <quicksilver> Cale: same way you gfoldl over an Int.
04:22:03 <Cale> yeah, I suppose that's fine
04:22:10 <ivanm> what is Data.Fixed?
04:22:14 <quicksilver> or ().
04:22:19 <Cale> Yes, it should be treated exactly the same way as Int or Double
04:22:26 <Cale> (or Integer, for a better example)
04:23:49 <doserj> could someone also please fix the Enum instance for Data.Fixed?
04:24:22 <quicksilver> doserj: well, given that ashley is working on it I guess now is a good time to make requests :)
04:33:47 <lpsmith> hey
04:34:28 <lpsmith> I want to force two latex figures to be on the same page
04:34:31 <lpsmith> Any ideas?
04:35:25 <Beelsebob> lpsmith: there's a command to force latex to insert a figure page
04:35:27 <Beelsebob> that may help
04:35:36 * Beelsebob can't remember what it is though
04:37:14 <Taejo> use a placement argument of p for "figure *p*age"
04:38:47 <harlekin> @pl (\(a,b) -> a / b)
04:38:47 <lambdabot> uncurry (/)
04:38:59 <harlekin> Could've thought of that... O:
04:39:29 <McManiaC> hey guys, im missing Data.Generics from base lib, how can install it?
04:39:42 <quicksilver> it's in a pacakge called 'data' I think? or is it called 'generic's.
04:39:46 <quicksilver> it's not in base anymore.
04:39:50 <quicksilver> maybe it's called 'syb' ?
04:39:50 <dreixel> the package is called syb
04:40:06 <McManiaC> kay
04:41:02 <McManiaC> strange
04:41:27 <McManiaC>       it was found in multiple packages: base-3.0.3.1 syb
04:41:28 <hackagebot> derive-gadt 0.1.0 - Instance deriving for (a subset of) GADTs. (MattMorrow)
04:41:56 <dreixel> McManiaC: yes, base-4 removed many things, which were put into separate packages.
04:42:23 <mmorrow> preflex: seen conal
04:42:23 <preflex>  conal was last seen on #haskell 10 hours, 54 minutes and 12 seconds ago, saying: i'll also try CPATH.
04:42:30 <mmorrow> @tell conal http://hackage.haskell.org/package/derive-gadt
04:42:30 <lambdabot> Consider it noted.
04:45:43 <McManiaC> dreixel: how can i remove base-3.0.3.1?
04:46:07 <dreixel> McManiaC: I don't think you would want to do that...
04:46:33 <dreixel> when building a package, just specify that you depend on base >= 4 && < 5
04:49:16 <McManiaC> ah thx
05:09:04 <FliP^2eH> Words can't describe how awesome ZipList is
05:11:00 <ivanm> then don't bother trying ;-)
05:11:41 <BONUS> i like getting the diagonal of an infinite ziplist of infinite ziplists
05:11:44 <FliP^2eH> I was about to give up because I need to zip more than 10 elements
05:11:56 <BONUS> why O_O
05:12:27 <FliP^2eH> Why I need to zip more than 10 elements?
05:12:34 <BONUS> yeah
05:13:10 <FliP^2eH> Getting a reply from a server info query, that reply includes 10 lists with each user detail in each list
05:13:25 <FliP^2eH> So name!!0 and id!!0 belong together
05:13:44 <quicksilver> yes, sounds like a case for ZipLists to me :)
05:13:58 <Cale> You could also use lots of zipWith id (which amounts to the same thing)
05:14:06 <Woof> In fact, I like it so much I'll post here too
05:14:07 <FliP^2eH> It's one of those few moments where I'd LOVE to slap the developer in the face over TCP/IP :)
05:14:12 <Woof> Recursion: http://buttersafe.com/ : D
05:14:23 <quicksilver> mkUserInfo <$> ZipList a <*> ZipList b <*> .....
05:14:57 <mmorrow> , $(let explode 0 a = a; explode n a = let x = explode (n-1) a in [|($x,$x)|] in explode 3 [|()|])
05:14:59 <lunabot>  ((((),()),((),())),(((),()),((),())))
05:18:13 <Cale> > let (##) = zipWith id in map (,,,) [1..10] ## [11..20] ## [21..30] ## [31..40]
05:18:15 <lambdabot>   [(1,11,21,31),(2,12,22,32),(3,13,23,33),(4,14,24,34),(5,15,25,35),(6,16,26,...
05:18:40 <Cale> Less noise, for the cost of making a local definition
05:19:11 <Cale> (but it amounts to the same thing in the end)
05:19:23 <mmorrow> , (,,,) <$> [1..10] <*> [11..20] <*> [21..30] <*> [31..40]
05:19:25 <lunabot>  [(1,11,21,31),(1,11,21,32),(1,11,21,33),(1,11,21,34),(1,11,21,35),(1,11,2...
05:19:42 <mmorrow> heh, i love the (<$> + [<*>]) thing
05:19:44 <Cale> mmorrow: That gives you the Cartesian product of the lists of course.
05:19:50 <mmorrow> arg
05:19:58 * mmorrow didn't realize what you'd done
05:20:00 <BONUS> the map + zipWith id thing is pretty neat
05:20:37 <Cale> It's exactly the same as using <$> and <*> with ZipLists, without all the wrapping and unwrapping.
05:20:54 <BONUS> yeah
05:24:29 * byorgey would be most likely to define  z = ZipList  and then do  f <$> z [1..10] <*> z [11..20] <*> ...
05:25:03 <BONUS> you'd also have to do like unz = getZipList somewhere along the way
05:25:03 <byorgey> which cuts down on most of the noise.
05:25:18 <quicksilver> well, it makes the noise more sibilant, at least
05:25:20 <byorgey> perhaps, although you only have to call that once, so I wouldn't be as worried about it
05:25:26 <quicksilver> unz ... z ... z ... z ... z
05:25:36 <byorgey> more somnolent, maybe
05:25:40 <quicksilver> that too
05:25:48 <BONUS> lol
05:26:28 <FliP^2eH> Okay, I'm having a Word32 which is actually a floating point number
05:26:37 <FliP^2eH> How do I get that floating point as a number?
05:26:55 <mmorrow> , let infixr 1 ##; (##) = zipWith (:); a #! b = a ## fmap (:[]) b in [1..10] ## [11..20] ## [21..30] #! [31..40]
05:26:56 <lunabot>  [[1,11,21,31],[2,12,22,32],[3,13,23,33],[4,14,24,34],[5,15,25,35],[6,16,2...
05:26:57 <FliP^2eH> Like I would get an Int by doing fromIntegral
05:26:57 <byorgey> FliP^2eH: it's in IEEE format?
05:27:06 <FliP^2eH> I have no idea, sorry
05:27:12 <BONUS> probably
05:27:13 <FliP^2eH> It should be
05:27:21 <byorgey> FliP^2eH: unsafeCoerce ought to work, actually =)
05:27:32 <FliP^2eH> It's sent by a program written in Pascal
05:27:37 <quicksilver> FliP^2eH: where did you get it from?
05:27:42 <BONUS> probably IEEE
05:27:48 <quicksilver> how did it end up being a Word3?
05:27:50 <byorgey> otherwise, use the binary-ieee-754 package
05:27:58 <quicksilver> word32
05:28:14 <FliP^2eH> quicksilver: Reply from a server over the network, It's Word32 because I'm reading it with Data.Binary
05:28:19 <BONUS> is there an unsafeCoerce that's like a -> Maybe b
05:28:25 <BONUS> i know about cast, but it has a Typeable context
05:28:38 <quicksilver> BONUS: how could their possibly be?
05:28:44 <quicksilver> BONUS: there is no run-time type information.
05:28:52 <soupdragon> you must have the Typeable for it to know whether that can happen
05:28:59 <soupdragon> so there's no a -> Maybe b
05:29:06 <BONUS> hmm yeah i suppose you're right
05:29:12 <quicksilver> FliP^2eH: binary-ieee-754
05:29:21 <quicksilver> FliP^2eH: unsafeCoerce wouldn't be endian-safe :)
05:29:44 <FliP^2eH> Is that a differnt library?
05:30:05 <doserj> http://hackage.haskell.org/package/data-binary-ieee754 is the one
05:31:09 <FliP^2eH> :)
05:32:42 <mmorrow> , foldr (zipWith (:)) (repeat []) [[1..10],[11..20],[21..30],[31..40]]
05:32:44 <lunabot>  [[1,11,21,31],[2,12,22,32],[3,13,23,33],[4,14,24,34],[5,15,25,35],[6,16,2...
05:33:20 <mmorrow> , foldr interleave [] [[1..10],[11..20],[21..30],[31..40]]
05:33:21 <lunabot>  [1,11,2,21,3,12,4,31,5,13,6,22,7,14,8,32,9,15,10,23,16,33,17,24,18,34,19,...
05:35:37 <mmorrow> you could of course write out [stuctural-description-of-type,serialized-structure], then (do get' <- get; get')
05:35:40 <mmorrow> which is just
05:35:43 <mmorrow> join get
05:37:04 <mmorrow> but you'd either need an all-encompassing datatype or to get to an existential..
05:47:51 <sioraiocht> so, does mapAccumR perform a foldr and a map at the same time?
05:48:09 <sioraiocht> meaning the answer (acc,[y]) is the product of the fold and then the product ofthe map?
05:49:26 <shapr> @yow !
05:49:27 <lambdabot> The Osmonds!  You are all Osmonds!!  Throwing up on a freeway at dawn!!!
05:49:51 * shapr boings cheerfully
05:49:59 <shapr> Has anyone written a layout aware parser in Parsec?
05:51:18 <Baughn> @type mapAccumR
05:51:19 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:51:49 <Cale> sioraiocht: *sort of*
05:51:58 <sioraiocht> :(
05:52:03 <sioraiocht> @src mapAccumR
05:52:03 <lambdabot> Source not found. There are some things that I just don't know.
05:52:06 <Baughn> > mapAccumR (\acc x -> (x, x+acc)) 0 [0..4]
05:52:07 <lambdabot>   (0,[1,3,5,7,4])
05:52:33 <sioraiocht> ????
05:52:39 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
05:52:45 <Baughn> Yep, sure looks like it does
05:52:53 <soupdragon> shapr not me, I didn't do that
05:53:14 <soupdragon> shapr I had an idea how though but I never code it
05:53:29 <Cale> The difference is that the map has access to the remainder of the fold
05:54:19 <sioraiocht> huh
05:54:25 <sioraiocht> interesting
05:54:28 <sioraiocht> nice diagrams
05:54:55 <chrisbrown> cale: those diagrams are intriguing :)
05:56:16 <chrisbrown> Cale: are they automatically generated?
05:56:28 <Cale> No, I drew them by hand.
05:56:31 <araujo> morning
05:56:31 <lambdabot> araujo: You have 1 new message. '/msg lambdabot @messages' to read it.
05:56:35 <Cale> Using inkscape
05:57:38 <chrisbrown> they are quite effective at showing simple transformations
06:00:36 <Cale> chrisbrown: It's kind of how I picture functional programs as working almost all the time.
06:01:26 <Cale> Well, it's nice to just think of things in terms of values too, but expression graphs are the next more detailed step to understanding how things work.
06:01:46 <Zao> Functional programming, much like the internet, is made up of tubes.
06:02:45 <gwern> Cale: how close does the new vacuum stuff come to yer diagrams?
06:03:55 <Cale> gwern: Only close for datastructures, not for expressions.
06:04:12 <Cale> It can't inspect unevaluated expressions at all
06:04:20 <gwern> well, that does make sense
06:04:59 <gwern> what would it do, show what it 'would' evaluate as?
06:05:15 <Cale> Show function applications directly.
06:06:07 <Cale> So if you write  let x = 2 + 2 in x + x, you'd get a graph with a node for + with two arcs leading to another + node which had two arcs leading to a node labelled 2
06:06:27 <quicksilver> shapr: yes.
06:07:05 <Cale> gwern: It would also be nice to show lambdas directly, displaying parameters as differently-coloured arcs that point back up to the lambda itself.
06:07:05 <quicksilver> shapr: well, technically no. But I've written a layout aware processor (for a simpler language than haskell) in a parser combinator library which was like Parsec, although not Parsec.
06:07:12 <dikini1> how do you express that a type is a functor in several incompatible ways, it is the same type, but in different context different functor will matter
06:07:17 <chrisbrown> Cale: I find them intriguing how they show the inner workings of things. They could be very useful if gerenated automatically for teaching purposes, amongst other things
06:07:23 <quicksilver> shapr: I recommend you process the indentation in an independent first pass.
06:07:30 <Cale> dikini1: You could use newtypes and write instances for each
06:07:44 <Cale> chrisbrown: Absolutely
06:08:05 <Cale> chrisbrown: I think it would be really nice to have a way to watch the evaluation of a Haskell program like this.
06:08:10 <dikini1> Cale would I need to cast between them?
06:08:20 <Cale> chrisbrown: There is a language called Hops (unreleased at the moment) which does this.
06:08:26 <Cale> (but it's not quite like Haskell)
06:08:29 <Woof> Lol: http://www.google.com/search?q=recursion !!!
06:08:37 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/index.html
06:08:47 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
06:08:55 <quicksilver> Cale: I'm disappointed in you. Real Men generate diagrams procedurally by writing custom TeX macros :)
06:09:00 <Cale> dikini1: You'd need to explicitly apply a data constructor.
06:09:17 <dikini1> Cale: thanks
06:09:23 <Cale> quicksilver: I don't think the result would be as good actually.
06:09:39 <Cale> (though being able to do it automatically obviously would have other benefits)
06:09:54 <FliP^2eH> > if !True then "!True" else "True"
06:09:55 <lambdabot>   <no location info>: parse error on input `!'
06:09:58 <FliP^2eH> :D
06:10:03 <FliP^2eH> > if not True then "!True" else "True"
06:10:04 <lambdabot>   "True"
06:11:25 <quicksilver> Cale: pretty easy to do all of that except the fancy wavy arrow in the scanl diagrams.
06:11:55 <Cale> quicksilver: Using what? xypic?
06:12:13 <quicksilver> Cale: Yes, probably.
06:12:25 <quicksilver> Cale: paul taylor's diagrams is the other contender.
06:17:26 <nomeata> Hi. Is Erik de Castro Lopo here, or is he sometimes here?
06:17:32 <doserj> or tikz
06:19:30 <zai> ciaoooooo!!
06:20:36 <saml> i'm Erik de Castro Lopo
06:21:07 <zai> I'm Zaira
06:21:07 <doserj> http://www.texample.net/tikz/examples/interaction-nets/
06:21:57 <zai> ke fate???
06:22:31 <nomeata> saml: hi
06:22:40 <saml> hey
06:23:03 <nomeata> saml: I see that you uploaded haskell-bzip2 once to NEW, but it’s not there any more. Has it been rejected?
06:23:23 <nomeata> *haskell-bzlib that is
06:23:34 <saml> sorry. i lied. i'm not Erik.
06:23:35 * mux wonders if anyone used his bsd-sysctl package besides himself, and guesses not
06:23:51 <nomeata> saml: I don’t care as long as you do his work now :-)
06:24:06 <FliP^2eH> @faq Can Haskell create an error message SO POWERFUL it cannot even understand it itself?
06:24:06 <lambdabot> The answer is: Yes! Haskell can do that.
06:24:35 <mux> Can God overcook a pizza so much that even He cannot eat it?
06:25:28 <FliP^2eH> Noi
06:25:32 <FliP^2eH> Only jesus can do that
06:25:33 <ryo_hazuki> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7094
06:26:08 <FliP^2eH> :D
06:26:16 <FliP^2eH> I wrote my own split using Prelude.break
06:27:05 <ryo_hazuki> interesting idea =)
06:27:06 <mux> @tell dons did you have time to give bsd-sysctl a try on OpenBSD?
06:27:06 <lambdabot> Consider it noted.
06:27:31 <FliP^2eH> @hpaste
06:27:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:27:38 <Cale> ryo_hazuki: It's interesting that your string splitting function not only splits the string but also translates it.
06:27:40 <FliP^2eH> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7417#a7417
06:27:44 <FliP^2eH> Not as clean as yours
06:28:10 <FliP^2eH> Also turn "T,,T" to ["T,"","T"] if ',' is the separator
06:28:15 <mux> yeah, hello world -> hallo welt
06:28:21 <mux> kinda impressive, even for haskell ;-)
06:28:24 <ryo_hazuki> haha :)
06:28:42 <ryo_hazuki> true... didn't noticed that =D
06:29:29 <ryo_hazuki> are there any hints you would give me to optimize the small piece? =)
06:29:53 <Cale> ryo_hazuki: Just from a practical standpoint, it's probably worth noting that there is a split library on hackage with lots of useful string splitting functions
06:30:22 <ryo_hazuki> mhh, ok... one good point ;)
06:30:33 <Cale> One thing which is a little bit questionable in your program is that sx ++ [x]
06:30:52 <FliP^2eH> I noticed there are alot of germans around here
06:30:57 <FliP^2eH> Including me.
06:30:59 <ryo_hazuki> hehe
06:31:16 <Cale> It means that your splitting function will have quadratic complexity in the length of the longest segment
06:31:47 <Cale> xs ++ ys takes O(length xs) steps to evaluate
06:31:54 <ryo_hazuki> oh ok
06:32:18 <ryo_hazuki> is there a difference between xs ++ ys and xs : ys ?
06:32:35 <Cale> xs : ys adds xs as an element to the beginning of ys
06:32:44 <Cale> In general, only one of those two will typecheck
06:32:56 <Cale> > [1,2,3] : [[4,5],[6,7,8]]
06:32:57 <lambdabot>   [[1,2,3],[4,5],[6,7,8]]
06:33:04 <Cale> > [1,2,3] ++ [4,5,6,7,8]
06:33:05 <lambdabot>   [1,2,3,4,5,6,7,8]
06:33:18 <ryo_hazuki> ok
06:33:50 <Cale> : doesn't require any steps to evaluate (it's already considered to be evaluated)
06:33:53 <dhun> is there any offline documentation of the standard libraries available
06:34:10 <Plouj> wow, what does a (d, b) (d, c) mean in the type of Control.Arrow.second :: (Arrow a) => a b c -> a (d, b) (d, c) ?
06:34:26 <Cale> dhun: If you install ghc, I think it comes with documentation for the libraries that it comes with
06:34:28 <Botje> Plouj: think of the "a" as (->)
06:34:37 <dhun> ok will look for it
06:34:45 <Botje> Plouj: so second: (b -> c) -> (d, b) -> (d,c)
06:34:54 <Plouj> Botje: like second :: (Arrow a) => -> b c -> -> (d, b) (d, c) ?? heh
06:35:07 <Botje> myeah, -> is better inline ;
06:35:18 <Cale> file:///usr/local/share/doc/ghc/index.html
06:35:21 <Cale> on my machine
06:35:46 <Botje> dhun: if you run debian or ubuntu it's ghc6-doc or haskell-doc
06:35:59 <Plouj> Botje: oh, I see, why would a be ->?
06:36:07 <Botje> Plouj: that's _one_ of the instances for Arrow
06:36:10 <Botje> but it's the most widely used
06:36:15 <ryo_hazuki> if anyone has some sparetime left... http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3796
06:36:20 <FliP^2eH> :t getZipList
06:36:21 <lambdabot> forall a. ZipList a -> [a]
06:36:28 <Botje> @instances-importing Arrow
06:36:29 <lambdabot> (->), Kleisli m
06:36:39 <Plouj> Botje: I don't know what Arrow actually is or means
06:36:46 <Botje> Plouj: .. and the other one is Kleisli m, which is some weird contraption involving monads
06:36:52 <Plouj> Botje: I just saw it mentioned at the end of chapter 6 of RWH.
06:37:05 <Cale> dhun: If you have trouble opening up the documentation for libraries which are in 'ghc-mtl', go to /usr/local/share/doc/ghc/libraries  (or wherever it's installed on your system), and  ln -s mtl ghc-mtl
06:37:11 <Botje> Plouj: you don't really have to. Just think of "Arrow a => a b c" as "b -> c"
06:37:26 <FliP^2eH> > getZipList $ (\x y -> unwords [x, y]) <$> ZipList ["Marco", "Mister"] <*> ZipList ["Polo", "T"]
06:37:28 <lambdabot>   ["Marco Polo","Mister T"]
06:37:28 <Botje> literally: "an arrow from b to c"
06:37:31 <Cale> ryo_hazuki: I'll give it a shot
06:37:34 <FliP^2eH> I love ZipLists
06:37:38 <Plouj> Botje: ok
06:38:19 <dhun> ok found it
06:39:22 <Botje> ryo_hazuki: that looks like one of the project euler problems. if it is, can you give me the number?
06:39:27 <Botje> i'll see if I still have my solution
06:41:32 <FliP^2eH> > getZipList $ (\x y -> unwords [,]) <$> ZipList ["Marco", "Mister"] <*> ZipList ["Polo", "T"]
06:41:33 <lambdabot>   <no location info>: parse error on input `,'
06:41:46 <FliP^2eH> > getZipList $ unwords [,] <$> ZipList ["Marco", "Mister"] <*> ZipList ["Polo", "T"]
06:41:47 <lambdabot>   <no location info>: parse error on input `,'
06:41:50 <FliP^2eH> :(
06:41:55 <Botje> unwords [,] is a sntax error.
06:42:06 <FliP^2eH> > getZipList $ (,) <$> ZipList ["Marco", "Mister"] <*> ZipList ["Polo", "T"]
06:42:07 <lambdabot>   [("Marco","Polo"),("Mister","T")]
06:42:10 <Cale> ryo_hazuki: What is this actually computing?
06:42:13 <FliP^2eH> Why does it work in that case?
06:43:16 <Cale> ryo_hazuki: The mutation makes it very confusing to understand what is going on. I could give you a brutally literal translation, I suppose.
06:44:28 <Plouj> Botje: so, Control.Arrow.second is a function that applies a (b -> c) function to the second element of a tuple?
06:44:36 <Botje> yup
06:44:54 <Botje> of course the actual names of the type variables don't matter
06:45:20 <Plouj> Botje: right, but it just shows that it changes from some type b to some type c
06:45:44 <Plouj> I came up with this example: second show ([], 3)
06:46:09 <dino-> Hello
06:46:55 <Botje> Plouj: yup, you got it
06:48:37 <Phillemann> If I write: function = 300; then that's converted to function = fromInteger 300;?
06:48:41 <ryo_hazuki> Cale: its a pyramid of numbers with some empty fields.
06:48:51 <dino-> That was a mischannel, but it works here. Good morning #haskell!
06:48:52 <ryo_hazuki> the goal is to find x y z
06:49:05 <ryo_hazuki> kinda hard to explain...
06:49:18 <Botje> do you have the original assignment?
06:49:22 <Cale> ryo_hazuki: I think I get it
06:49:31 <Cale> ryo_hazuki: Had to actually run it by hand on paper ;)
06:49:36 <quicksilver> Phillemann: in some sense of "converted" yes.
06:49:47 <ryo_hazuki> hrhr
06:49:49 <ryo_hazuki> (;
06:49:54 <quicksilver> Phillemann: in another sense, no, it's not converted. That's just one way of describing what '300' means.
06:50:44 <Phillemann> quicksilver: The "other sense" is a bit more useful, I think.
06:50:57 <ryo_hazuki> one more condition for it: X,Y,Z >= 0 and Y = X + Z
06:51:15 <Cale> yep
06:51:18 <ryo_hazuki> anyways... food time =) bbl
06:51:22 <Cale> okay
06:54:01 <Cale> ryo_hazuki: Still here? It looks like a row of the pyramid is missing, I suppose it doesn't matter.
06:55:17 <centrinia> Cale, what does it do? :p
06:56:23 <Cale> centrinia: Basically, it adds adjacent entries in each row to get the next one. The 0's represent blanks that it's trying to fill, and it's trying to pick x, y, and z which cause the non-blank entries to match those in the pattern.
06:56:54 <Cale> lazy evaluation to the rescue -- we don't have to mix up the filling of the cells with testing if the pattern matches.
06:57:48 <Phillemann> If I want to establish a module hierarchy (a la Foo.Bar.Baz), is it enough to create a directory hierarchy (Foo/Bar/Baz.hs)?
06:59:45 <centrinia> Ah. So it finds x,y, and z such that [[x,11,y,4,x],[?,?,?,?],[4,?,?],[151]] satisfies the property that the next row is simply zipWith (+) row (tail row) ?
07:02:42 <Cale> centrinia: yes
07:04:49 <centrinia> Okay, I think something should be between [40,?,?] and [151]
07:05:05 <FliP^2eH> 1 MB of memory for a program that connects to a server and returns some server information
07:05:07 <FliP^2eH> Is that okay?
07:05:51 <Cale> centrinia: I would have thought so too.
07:06:05 <Cale> centrinia: I think the python program actually has a bug in it
07:06:33 <Cale> centrinia: It's not checking the last row, so it finds a solution despite the fact that nothing would otherwise match
07:07:04 <centrinia> Hmm, 4 = ((x+11) + (11+y)) + ((11+y) + (y+4)) :p
07:07:15 <Cale> oh well, adding a new blank row fixes it
07:07:28 <Baughn> FliP^2eH: It can probably be tuned. Check the output of +RTS -sstderr, see how much it actually /uses/.
07:07:34 <Cale> and the solution is correct
07:07:47 <FliP^2eH> Baughn: That is the output of RTS
07:08:07 <centrinia> Well, that is simply a linear system with three variables and two equations. :p
07:08:08 <Baughn> FliP^2eH: The default GC/heap settings allocate a fair bit of space right at the start
07:08:31 <Baughn> FliP^2eH: Well, but if you don't have memory crunch issues, 1MB should be fine
07:09:17 <centrinia> If you consider that (x,y,z) = (x',x'+z',z'), then it is simply a linear system with two variables and two equations. :p
07:10:07 <Baughn> FliP^2eH: Um. With -Sstderr, look at the maximum /live/ heap size
07:10:24 <FliP^2eH> 173,364 bytes maximum residency (1 sample(s))
07:11:14 <Baughn> Right.. I wonder if that includes garbage, or what
07:11:23 <Baughn> In any case, you can clearly tune it to take less memory if you want.
07:11:37 <FliP^2eH> How could I tune it?
07:11:59 <Baughn> Depends on how badly you want less memory usage
07:12:00 <WorkyBob> how the hell does one compile a program who's main is in a c file, but makes calls to FFI exported haskell?
07:12:15 <WorkyBob> ghc will only produce a .o file, no executable
07:12:27 <Baughn> FliP^2eH: Switching from 2 to 1 generations, reducing the allocation area, using the compacting collector.. all will reduce memory use
07:12:29 <Cale> ryo_hazuki: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3796#a7418
07:12:30 <WorkyBob> and using gcc requires chasing all sorts of library dependancies
07:12:31 <FliP^2eH> I don't really care about it right now, it'd be just interesting to know how to tune
07:12:44 <Baughn> FliP^2eH: There's a section on it in the GHC user guide
07:12:51 <Twey> WorkyBob: I think that's correct... the C file should be compiled with your favourite C compiler
07:12:56 <chrisbrown> WorkyBob: surely you compile the haskell library to .o then link against it using GCC?
07:13:04 <Twey> *nod*
07:13:05 <chrisbrown> via FFI?
07:13:23 <WorkyBob> all the googling out there suggests that ghc should be used for the linking, because otherwise you have to track down hundreds of libraries for the haskell rts
07:13:46 <WorkyBob> and that in fact, the hundreds of libraries needed are best found by using ghc in verbose mode
07:14:02 <WorkyBob> meanwhile, using gcc, I haven't suceeded in finding the apropriate libraries yet -- I'm still getting link errors, and can't find any more libraries to add in
07:14:35 <Baughn> Have you tried using ghc in verbose mode? ;)
07:14:54 <WorkyBob> I have... but ghc isn't linking anything
07:14:59 <WorkyBob> it's just producing object files
07:15:17 <WorkyBob> Main.main not exported; not linking
07:15:20 <Baughn> You need to provide a module Main
07:15:28 <WorkyBob> even though my main is in C land?
07:15:28 <Baughn> Even if it's just "main = return ()"
07:15:32 <WorkyBob> oh, okay
07:15:42 <Baughn> Well, it's just to figure out what functions to use, right?
07:16:00 <Baughn> WorkyBob: But GHC should be able to link with a C object file too.. I think...
07:16:18 <Baughn> s/functions to use/libraries to use/
07:16:43 <WorkyBob> still no binary produced
07:17:07 <WorkyBob> now I have a duplicate symbol, because both C land and Haskell land define main
07:17:20 <Cale> Heh, the problem with programming in Haskell all the time is that the part of my brain responsible for understanding imperative programs that do mutation has atrophied.
07:17:28 <Baughn> Well yeah, you don't /both/ provide a dummy main and the real one
07:17:39 <chrisbrown> WorkyBob: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
07:17:49 <WorkyBob> Baughn: right, but if I provide a real one in C land, ghc won't link anything
07:18:11 <Baughn> WorkyBob: I was going to look up the appropriate options, but see that link.
07:19:18 <WorkyBob> success
07:19:22 <WorkyBob> well googled chris
07:19:26 <WorkyBob> and cheers everyone :)
07:19:31 <chrisbrown> :)
07:19:42 <chrisbrown> google always has the answer
07:20:37 <shapr> Yes!
07:20:43 * shapr boings cheerfully
07:24:15 <klugez> How would you go about generalizing this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7419 ?
07:27:58 <chrisbrown> klugez: can you notice any commonalities between the three equations?
07:28:00 <Twey> :t sequence
07:28:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:28:12 <opqdonut> valuesCandidates n k m = do { let max = 2^n; a <- [m..max]; rest <- valuesCandidates n (k-1) a; return (a:rest) }
07:28:16 <opqdonut> klugez: ^
07:28:33 <Twey> Hmm
07:28:43 <opqdonut> klugez: you might want to factor that into two functions, valuesCandidates n = f n k n where ...
07:28:45 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7419#a7420
07:29:12 <opqdonut> ah, Cale's is practically the same
07:30:25 <ryo_hazuki> Cale: thanks... didn't think that it's that easy =)
07:30:33 <klugez> Alright, thanks opqdonut & Cale.
07:30:49 <Cale> ryo_hazuki: your python program has a bug in it btw. It's not checking the last row of the pyramid
07:31:07 <Cale> ryo_hazuki: If it did, the fact that the second last row is missing would be apparent :)
07:31:19 <klugez> chrisbrown: I can now after I was given the answer. :)
07:31:25 <opqdonut> there might be a spiffy foldM variant for that
07:31:27 <ryo_hazuki> oh ok
07:32:01 <chrisbrown> klugez: sorry - I was going to talk you through it, but was beaten to it :)
07:34:23 <Cale> chrisbrown: sorry about that :)
07:37:47 <Cale> ryo_hazuki: Something important to notice is that thanks to laziness, we can separate the generation of the new pyramid (from the first row) from the part which checks if the pyramid matches the pattern, without any harm to performance
07:38:26 <Cale> ryo_hazuki: It will only calculate the sums as it needs to in order to check if they match.
07:39:19 <Cale> ryo_hazuki: Trying to mix those two things together produces a program which is hard to understand and be sure that you have it right :)
07:39:36 <ryo_hazuki> true
07:41:26 <Berengal> Anyone up for a bit of type hackery?
07:44:53 <centrinia> klugez: Try this: f n = (map (1:) $ filter (\x -> and $ zipWith (<=) x (tail x)) (sequence (replicate (n-1) [2..2^n])))
07:45:08 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7422#a7422
07:46:23 <centrinia> ryo_hazuki: Have you tried to construct a set of linear equations instead?
07:46:51 <ryo_hazuki> yep... alerady solved it with pen and paper
07:47:05 <ryo_hazuki> and i thought it would be interesting to see a haskell solution on this one
07:49:35 <ryo_hazuki> which editor / ide do you use for writing haskell programs?
07:49:42 <cjb> emacs
07:49:46 <Berengal> irc
07:50:01 <ryo_hazuki> Berengal: cool =P
07:50:01 <Tordmor> vim
07:50:02 <Cale> ryo_hazuki: vim, myself
07:50:18 <ryo_hazuki> vim with any special addons/plugins?
07:50:23 <Tordmor> no
07:50:53 <Phillemann> ryo_hazuki: I set makeprg to ghc. :)
07:51:00 <Cale> Just the normal Haskell support that it comes with. I do make sure to turn on expandtab and smarttab
07:51:03 <Phillemann> Or just write a Makefile.
07:51:08 <skorpan> i do M-x butterfly
07:51:12 <Tordmor> :)
07:51:23 <Cale> expandtab in particular is super-important
07:51:34 <Cale> You really don't want tab characters in Haskell source files
07:51:37 <vav> ryo_hazuki: http://projects.haskell.org/haskellmode-vim with vim, but play with leksah and yi for ideas now that they're getting somewhat usable
07:51:41 <ryo_hazuki> true
07:51:57 <Berengal> tabs vs spaces is no religious war in haskell. It's not even a minor discussion
07:52:08 <ryo_hazuki> vav: thanks!
07:52:21 <Berengal> Actually, I pretty much use leksah and yi myself
07:52:45 <Berengal> I used to use emacs, but it's easier to hack yi
07:53:19 <badsheepy> installing leksah was a whole world of fail for me:(
07:53:28 <shapr> Why so?
07:54:12 <ryo_hazuki> =o
07:54:19 <badsheepy> ghc was out of date, 10.4 builds haskellplatform fine,but then cabaldoesnt work (that took a day of working out by itself)
07:54:51 <badsheepy> then when i did it with 10.3 it worked and i was full of glee and then realise glib doesnt exist :(
07:55:02 <Phillemann> gtk2hs wants gnome on Gentoo linux. o_O
07:55:05 <badsheepy> excuse my broken keyboard based illiteracy:p
07:55:25 * centrinia uses paper, pen, scanner, and OCR software as his preferred editor. :)
07:56:06 <copumpkin> :o
07:56:18 <vav> Phillemann: it's just a use flag for gtk2hs to enable proper gtksourceview support, doesn't require whole gnome setup
07:56:31 * Berengal wonders if latex -> ps -> ocr -> hs is possible
07:56:32 <Cale> centrinia: fixing the OCR's work with spacing must be fun :)
07:57:16 <Phillemann> vav: Ah, I just saw that not gtk2hs wants gnome but leksah wants it.
07:57:24 <vav> right
07:57:27 <ryo_hazuki> any colorschemas you can recommend for vim with haskell?
07:58:02 <LeoD> i'm using xoria256
07:58:03 * mux likes desert
08:08:06 <copumpkin> grr, http://hackage.haskell.org/packages/archive/algebra/0.0.0.1/doc/html/src/Data-Semigroup.html#Semigroup is annoying :P
08:09:43 <Deewiant> :-D
08:10:24 <Deewiant> That's... one hell of a package right there
08:10:26 <Deewiant> http://hackage.haskell.org/package/algebra
08:10:55 <Deewiant> I wonder what differs between 0.0.0.0 and 0.0.0.1
08:10:59 <liyang> Are there any Leksah developers here?
08:11:20 <quicksilver> copumpkin: why's that annoying?
08:11:21 <hamishmack> Yes
08:11:36 <Vanadium> If yes, oh come on at least start into the configuration screen when I give an incorrect candy path instead of just terminating
08:12:58 <liyang> hamishmack: wondering if there's a way to embed Vim within Leksah instead of simply supporting Vim keybindings. :3
08:13:08 <liyang> Or simply support it as an external editor...
08:13:20 <Rembane> liyang: You'll be creating a monster!
08:14:28 <centrinia> copumpkin: What do you expect from a semigroup specification? :p
08:14:30 <liyang> Rembane: I'm perfectly happy with Vim as my editor; other editors tend to drive me a bit insane. Not entirely happy with Safari as my documentation browser though.
08:15:04 <liyang> Rembane: weighing up the pros and cons, I'd still stick with Vim. D:
08:15:25 <liyang> Rembane: I wasn't at any point suggesting someone ought to implement Haskell scripting for Vim...
08:16:31 <copumpkin> quicksilver, centrinia: it's taking the very general algebra package name and seems to be abandonware with a total of maybe 5 lines of actual "code"
08:16:34 <copumpkin> (and that's just a typeclass)
08:17:14 <Rembane> liyang: A nice monster then? :)
08:18:22 <liyang> I mean, Vim supports embedding as a GTK+ socket... http://www.vim.org/htmldoc/gui_x11.html#gui-gtk-socketid
08:18:33 <quicksilver> copumpkin: yes, agreed.
08:18:43 <centrinia> copumpkin: Will you be happy if someone implemented monoids, groups, rings, and modules for it? :p
08:18:44 <quicksilver> copumpkin: I don't know what would motivate someone to upload that to hackage :)
08:19:32 <Cale> Hackage repository squatters ;)
08:19:38 <centrinia> Wow, algebra-0.0.0.1 only contains Data.Semigroup :(
08:19:48 <Cale> ahaha
08:19:52 <Vanadium> It is only 0.0.0.1, what do you expect :V
08:20:01 <Deewiant> It's also 4 months old which makes it somewhat more amusing
08:20:07 <centrinia> Well, they have to start somewhere. :p
08:20:19 <copumpkin> centrinia: I'm tempted to, that's why I noticed the name was taken
08:20:26 <Vanadium> Perhaps the author realised he only needs semigroups for his projects and stopped right there
08:20:26 * SamB is glad firefox seems to have some kind of pop-up throttling ... handy when gmail (or possibly an add-on) goes insane!
08:20:38 <copumpkin> bbl
08:21:02 <centrinia> Semigroups are enough for anyone. ;)
08:25:37 <hamishmack> liyang: I would like to see yi replace GtkSourceView in Leksah
08:26:15 <hamishmack> it would would not be easy though
08:26:27 <liyang> hamishmack: I don't see the point of yi other than as an academic exercise, to be entirely honest.
08:27:00 <liyang> I'm married to Vim, with kids and pets and all, and I'm not going to leave her.
08:27:07 <Saizan_> liyang: it's for those who like emacs/vim but hate elisp/vimscript
08:27:22 <centrinia> This is the only difference between algebra-0.0.0.0 and algebra-0.0.0.1: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7423#a7423
08:27:25 <liyang> Saizan_: maybe I should look into it. >_>
08:27:35 <liyang> (When I have a spare week or two.)
08:27:44 <Deewiant> centrinia: :-D
08:28:26 <cognominal> I agree witu Saizan_
08:28:27 <hamishmack> liyang: on most platforms (not Windows) Leksah will detect changes made to files
08:28:38 <hamishmack> you could extend this if you wish
08:28:51 <hamishmack> to add a auto reload option
08:30:01 <liyang> hamishmack: good plan. Right now I'm using it to write my .cabal files because I'm not familiar with the syntax and don't think I'd be interested to learn. :3
08:30:08 <hamishmack> Then you could use Leksah's module browser
08:30:50 <liyang> would be nice if I could hook custom commands up to double-clicking a file or something.
08:31:04 <hamishmack> I guess it would also be possible to set up some way to have leksah open files in vim when you browse to them
08:32:11 <liyang> vim --remote would do the job. :)
08:32:15 <hamishmack> Getting the Leksah autocomplete to show up on top of vim would be hard though
08:32:51 <liyang> hamishmack: eww... I hate autocomplete.
08:33:46 <hamishmack> currently leksah only checks the open files for modifications
08:35:16 <hamishmack> I don't really know what is available already in vim, so I am not sure which bits you would want from Leksah
08:35:52 <liyang> hamishmack: I'll put ``Leksah external editor support'' on my To Do list. No guarantees though.
08:36:00 <Phillemann> Hmmmm, to use the Haddock lookup feature, do I have to install ghc with the documentation? Or where is it taken from?
08:36:12 <Phillemann> ...in vi with haskellmode.
08:39:33 <hamishmack> liyang: That would be cool.  If we have to share you with your wife (Vim) we will :-)
08:40:24 <liyang> I do have a mistress (Emacs) on the side, mind you. Solely because of Agda. D:
08:40:38 <ryo_hazuki> good bye...
08:42:22 <soupdragon> yeah
08:42:35 <soupdragon> we must phase out emacs :)
08:42:52 <dikini1> what is the reason for the type system not to accept this - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7424#a7424
08:43:02 <soupdragon> what we need is an editor that will be the best for Coq & Agda & Epigram
08:43:13 <quicksilver> dikini1: the type of the thing stored in the B didn't change.
08:43:18 <lilac> cognominal: to be fair, this is version 0.0.0.1 of the algebra package :)
08:43:23 <dikini1> for some reason it doesn't accept that types a and b (f:: a->) could be the same
08:43:27 <lilac> s/cognominal/copumpkin/
08:43:41 <lilac> s/.*//
08:43:54 <quicksilver> dikini1: in general, a and b are not the same
08:43:56 <Botje> dikini1: fmap must hold for _ALL_ functions, not only the ones of type a -> a
08:44:03 <quicksilver> dikini1: and definition has to work in general.
08:45:23 <lilac> dikini1: you /could/ do this: data AA b a = A a | B b; instance Functor AA where fmap f (A a) = A (f a); fmap _ (B b) = B b
08:45:45 <lilac> [...] instance Functor AA b where [...] rather
08:46:16 <dikini1> lilac: not if I have far more clauses in the type - it will be an overkill
08:46:18 <quicksilver> which is precisely the functor instance of Either.
08:46:40 <quicksilver> dikini1: overkill, but correct. Whereas what you have at the moment is rubbish :)
08:46:49 <quicksilver> dikini1: what is your goal? What are you hoping for?
08:47:36 <lilac> dikini1: fmap takes AA a, and (a -> b), and gives you AA b. you simply can't construct an AA b with the B constructor and a value of type a, so there's no way what you're trying can work.
08:48:03 <dikini1> I want to apply the function to only one of the variants of a type, otherwise it should be id
08:48:27 <soupdragon> dikini1, that's not valid
08:49:11 <lilac> dikini1: imagine you had x :: AA Int, and you ran (fmap show x). what should that actually do?
08:49:30 <lilac> dikini1: clearly it produces a value :: AA String, so that's either A String or B String
08:50:04 <centrinia> dikini1: you could use multiple type variables.
08:50:58 <dikini1> well, in my mind I was looking for a definition which restricts f, to a->a, that is a == b
08:51:10 <quicksilver> that's not what Functor is.
08:51:19 <quicksilver> you could make
08:51:27 <dikini1> yes, it will restrict the valid functions, which as I understand now is against the definition
08:51:34 <quicksilver> class NotAFunctor f where notfmap :: (a -> a) -> f a -> f a
08:51:48 <lilac> dikini1: you can define an aamap which did that, but not an fmap
08:51:48 <quicksilver> if that happens to represent what you want :)
08:52:10 <centrinia> quicksilver: Isn't that an endofunctor? :p
08:52:38 <lilac> centrinia: no, an endofunctor is a functor from a category to itself (like from Hask to Hask)
08:52:54 <lilac> all haskell Functors are endofunctors on Hask
08:53:36 <quicksilver> dikini1: but, I'm not sure I'd make it a class.
08:53:46 <quicksilver> I'd probably just call it amap and write it on AA only.
08:53:56 <quicksilver> amap :: (a -> a) -> AA a -> AA a
08:54:07 <lilac> centrinia: you could argue it's a functor on a subcategory of Hask, containing only the endofunctions as arrows
08:54:12 <quicksilver> then again I don't know what you;re trying to do.
08:54:34 * lilac wonders if there's a name for that; category theory seems to be full of names for things :)
08:55:37 <a_guest> is 'Exception' a type or a typeclass?
08:55:55 <dikini1> I'm going to use different instances to encode different behaviours
08:56:00 <gwern> a_guest: depends on which version dinnae't?
08:56:01 <lilac> a_guest: depends on which version of GHC you're using, and which module's Exception you're talking about, I believe
08:56:02 <skorpan`> :t Exception
08:56:03 <lambdabot> Not in scope: data constructor `Exception'
08:56:19 <centrinia> @hoogle Exception
08:56:20 <lambdabot> module Control.Exception
08:56:20 <lambdabot> Control.Exception data Exception
08:56:20 <lambdabot> Control.Exception ArithException :: ArithException -> Exception
08:56:20 <dikini1> basically the type is encoding the states of a transition system
08:56:28 <dikini1> and there are different rulesets
08:56:33 <lilac> @hackage extensible-exceptions
08:56:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/extensible-exceptions
08:57:07 <a_guest> so which module has Exception as type?
08:57:08 <dikini1> in one of the states you should be able to apply the notamap f
08:57:13 <dikini1> :0
08:57:19 <lilac> a_guest: ^^ for portability, the extensible-exceptions package is probably what you want to be using
08:57:31 <dikini1> that is it will make a difference, in the others it is just an id
08:57:43 <a_guest> it seems that 'Control.Exception' has changed.
08:57:53 <lilac> a_guest: in GHC <= 6.8, Control.Exception has it as a type. in GHC >= 6.9, Control.Exception has it as a class
08:58:15 <gwern> I remember the first time I read about types. It's a nice & useful idea, I thought, but how complex could they possibly get?
08:58:23 <gwern> I remember I used to be pretty naive
08:58:53 <Berengal> gwern: Do you remember being naive, or do you look back at yourself and see yourself as naive?
08:59:16 <dikini> quicksilver, lilac thanks
08:59:17 <a_guest> ok. I try to compile quickcheck, but it will not compile, since quickcheck assumes 'Exception' in 'Control.Exception' to be a type.
08:59:39 <quicksilver> a_guest: change it to import Control.OldException
08:59:44 <Berengal> Anyway, I've got some complex types
08:59:46 <quicksilver> that's the compatibility package.
08:59:46 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7422#a7422
08:59:52 <quicksilver> or, alternatively, compile it against base-3 I guess
08:59:56 <Berengal> And I need some help with them
09:00:00 <gwern> Berengal: both, but not always about all the same things
09:00:01 <Berengal> Well, first, just naming
09:00:37 <soupdragon> data a ::: b where
09:00:37 <soupdragon>     (:::) :: a -> b -> a ::: b
09:01:04 <soupdragon> it's a pair!
09:01:26 <gwern> Berengal: for example, I recognize I was naive about the simplicity of types, but the memories don't feel naive; on the other hand, I can feel the naivete of my faith in science, but I don't think that's a naive belief to hold
09:01:36 <Rotaerk> a ::::::::::: b
09:02:15 <Berengal> In that file I've got a function 'map :: (List l)=> (forall a. a -> f a) -> l .> LAp f l'. What would I call a function with type (List l) => (forall a. f a -> g a) -> LAp f l -> LAp g l
09:02:19 <a_guest> quicksilver: thank you, now it worked!
09:02:23 <lilac> Berengal: call the types LilacsBrainAsplode[1-9]
09:03:09 <Berengal> Suggestions for implementation of MultiIndexMap also welcome
09:03:35 <lilac> Berengal: undefined
09:03:38 <soupdragon> :(
09:03:38 <quicksilver> Berengal: following lilac's suggestion I'm going to plump for OuchPleaseStop
09:03:38 <Berengal> lilac: They asploded my brain at least 15 times, and ghc's a few more than that
09:03:59 <quicksilver> Berengal: I guess friday afternoon was the wrong time for you to ask these questions :)
09:04:39 <Berengal> quicksilver: Hehe, I guess so too. Perhaps I shouldn't be worrying about this myself when I'm already down 8 hours of sleep
09:05:23 <Berengal> Anyway, loading this up in ghci, watching it typecheck and watching the (relatively) sane types of emptyPersonMap makes me happy
09:05:42 <opqdonut> Berengal: so what are you up to?
09:05:50 <Deewiant> Berengal: lmap?
09:06:30 <Berengal> opqdonut: The MultiIndexMap type on the bottom should give you a hint. I want a map with more than one key per value
09:07:00 <shapr> Yay hac-phi!
09:14:53 * Berengal is still fascinated by the fact that you can pattern match on (->) in type functions
09:15:22 <a_guest> do somebody know what happened to function  'check' in quickcheck library?
09:16:08 <Botje> @pl \(base, mul) = base * (succ $ fromEnum mul)
09:16:08 <lambdabot> (line 1, column 14):
09:16:08 <lambdabot> unexpected "="
09:16:08 <lambdabot> expecting operator, pattern or "->"
09:16:14 <Botje> @pl \(base, mul) -> base * (succ $ fromEnum mul)
09:16:14 <lambdabot> uncurry ((. (succ . fromEnum)) . (*))
09:16:15 <Botje> doh
09:16:25 <Botje> hmm. I was expecting something cleverer
09:16:52 <soupdragon> @pl \(base, mul) -> id base * (succ $ fromEnum mul)
09:16:52 <lambdabot> uncurry ((. (succ . fromEnum)) . (*))
09:17:21 <soupdragon> @pl \(base, mul) -> (*) (id base) ((succ . fromEnum) mul)
09:17:21 <lambdabot> uncurry ((. (succ . fromEnum)) . (*))
09:19:54 <soupdragon> :t liftA2 (*) (fst) (succ . fromEnum . snd)
09:19:55 <lambdabot> forall b. (Enum b) => (Int, b) -> Int
09:22:28 <Berengal> @type uncurry (*) . second ((+1) . fromEnum)
09:22:30 <lambdabot> forall b. (Enum b) => (Int, b) -> Int
09:26:40 <Phillemann> Hmmm, haddock-2.4.1 fails with "Ambiguous occurrence `funTyConName'"
09:41:44 <BONUS> what's the type of Cokleisli composition?
09:41:57 <BONUS> if there is such a thing
09:42:32 <dolio> Comonad w => (w b -> c) -> (w a -> b) -> (w a -> c)
09:42:42 <BONUS> yeah that's what i thought
09:42:49 <BONUS> but how would it be implemented then
09:43:19 <opqdonut> and it's implemented by turning w a into w w a, fmapping the w a -> b, doing cojoin again and fmapping the w b -> c
09:43:43 <jmcarthur_work> CoKleisli b . CoKleisli a = CoKleisli (b . fmap a . duplicate)
09:43:49 <BONUS> aaah so you need duplicate
09:43:50 <jmcarthur_work> from category-extras
09:43:58 <opqdonut> BONUS: of course
09:44:04 <opqdonut> since that
09:44:11 <opqdonut> 's what makes a functor a comonad
09:44:21 <BMeph> duplicate or extend, take your pick.
09:44:29 <opqdonut> i prefer cojoin
09:44:32 <BONUS> ah, what if you just have extend
09:44:34 <opqdonut> for some weird reason
09:45:05 <opqdonut> and yeah, my initial explanation was kinda off as you can probably work out
09:45:17 <opqdonut> one cojoin too much, leaves us with w c
09:45:25 <BONUS> ah right, i totally missed that duplicate can be implemented with =>>
09:45:25 <jmcarthur_work> duplicate = extend id
09:45:33 <BONUS> doh of course it makes sense
09:45:35 <opqdonut> i was thinking of =>> perhaps
09:45:37 <jmcarthur_work> extend f = fmap f . duplicate
09:48:38 <lilac> @pl \(base, mul) -> base + base * fromEnum mul
09:48:39 <lambdabot> uncurry (liftM2 (.) (+) ((. fromEnum) . (*)))
09:49:11 <lilac> @pl \(base, mul) -> base * (fromEnum (succ mul))
09:49:12 <lambdabot> uncurry ((. (fromEnum . succ)) . (*))
09:49:45 <BMeph> So, that goes straight to: CoKleisli b . CoKleisli a = CoKleisli (b . extend a), which is (another way to write/a simple transformation of) the associativity law for comonads.
09:56:15 <BMeph> extend f . extend g == extend (f . extend g) -- assoc for comonads
09:57:54 <BMeph> Well, back to ComicCon, see y'all tonight.
10:21:58 <oklopol> is there a function like maximum but one that's done on top of another function, like "element that has the greatest value in field x"?
10:22:04 <oklopol> i guess you can do that with monads directly
10:22:10 <BONUS> maximumBy?
10:22:26 <oklopol> i guess that's what you'd call it
10:22:32 <BONUS> > maximumBy (compare `on` snd) [(1,2),(3,19),(100,3)]
10:22:33 <lambdabot>   (3,19)
10:22:42 <BONUS> snd is the projection function here
10:22:52 <doserj> oklopol: it is in Data.List
10:22:59 <oklopol> oh, cool
10:23:11 <oklopol> second question, can you do that directly with monads?
10:23:22 <EvilTerran> why would it have anything to do with monads?
10:23:33 <BONUS> yeah that doesn't have anything to do with monads, sorry :)
10:23:43 <BONUS> that's like saying if you can walk 10 feet directly with a car
10:23:58 <oklopol> hmm. i guess you can generalize that without monads
10:24:06 <oklopol> pretty trivially
10:24:19 <BONUS> i mean i guess you could use a roundabout way to shoehorn monads into this
10:24:55 <inimino> the max monad? :)
10:25:26 <FunctorSalad> would seem to suffer from the same obstacle as the Set monad
10:25:30 <BONUS> you could use the state monad to keep track of which is the biggest element haha
10:25:47 <FunctorSalad> hmm oh right, the state parameter can be constrained
10:26:54 <BONUS> i wonder if the maximumBy and co. should be maximumOn, etc.
10:27:10 <BONUS> i kind of feel people always just use (compare `on` f) and ((==) `on` f)
10:28:08 <mauke> maximumBy (comparing snd)
10:28:11 <Saizan_> there's been a blog not long ago about that
10:30:45 <EvilTerran> BONUS, another advantage of *On over *By is that sortOn (at least) could use a Schwartzian transform
10:31:14 <BONUS> is that the perl thing
10:31:35 <FunctorSalad> (and "by" isn't really more general in this case anyway)
10:31:38 <EvilTerran> BONUS, named after the perl guy, yeah
10:33:38 <oklopol> where's `on`?
10:33:46 <Saizan_> Data.Function
10:34:26 <Saizan_> the nice thing is that you can implement both On and By out of maximum with just a few milliolegs
10:37:03 * shepheb wouldn't mind if Data.List had both *By and *On functions. If I had to choose exactly one, I'd go with On
10:37:39 <copumpkin> @hoogle ordlist
10:37:39 <lambdabot> Text.XHtml.Frameset ordList :: HTML a => [a] -> Html
10:37:39 <lambdabot> Text.XHtml.Strict ordList :: HTML a => [a] -> Html
10:37:39 <lambdabot> Text.XHtml.Transitional ordList :: HTML a => [a] -> Html
10:37:43 <copumpkin> @hackage ordlist
10:37:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ordlist
10:37:52 <copumpkin> whoops
10:37:53 <copumpkin> hmm
10:42:14 <vav> @hackage data-ordlist
10:42:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-ordlist
10:51:58 <shapr> Yay Hac-phi!
10:56:56 <burp> how can I modify a specific part of a file? I would like to "hSeek" to a position.. hPutStr something that overwrites the existing content there and hClose the file
10:57:06 <burp> when I do it in this order, the rest of the file is discarded
11:07:54 <Oejet> burp: Perhaps you could memory map the file (mmap)?
11:11:07 <burp> I will try
11:11:39 <Lauren5> I'm a new student to C programming
11:11:47 <Lauren5> can someone help me fix my source file
11:12:19 <Cale> Lauren5: This isn't really a channel about C programming... it's about programming in Haskell.
11:12:23 <Lauren5> oh
11:12:31 <Cale> Lauren5: But I suppose I could look at it.
11:12:35 <Lauren5> ok thanks :)
11:12:39 <Saizan_> burp: the usual way is to create a modified copy of the file and then move it over the previous, the copy can be either in memory or on disk
11:12:42 <Lauren5> http://pastie.org/557983
11:13:19 <copumpkin> Lauren5: it might a lot easier if you formatted and indented the code consistently
11:13:34 <soupdragon> Lauren5: why are you asking this here?
11:14:06 <Lauren5> I don't know, I was trying to look up chats about C programming, and this website was at the top of the results :(
11:14:11 <shapr> bizarre
11:14:14 <soupdragon> Lauren5: try ##c
11:14:24 <soupdragon> Lauren5: this one is a different language
11:14:25 <shapr> Last I heard, this channel is about the Haskell programming language.
11:14:40 <shepheb> or stackoverflow.com, depending on the scope ofthe question
11:14:42 <Cale> Guys, I already mentioned that it's about Haskell, you don't need to repeat it ;)
11:14:56 <dino-> Lauren5: Interesting though that it factored prominently in a search.
11:15:15 <Saizan_> we have programming in the topic
11:15:45 <jmcarthur_work> foo base power = product $ replicate power base -- fixed the code :)
11:16:22 <burp> Saizan_, seems iniefficient to me, to write the whole file again
11:17:06 <Cale> Lauren5: The main problem with this algorithm is that after multiplying the number by itself, you're replacing the original number with that result. So, for example, if you were computing 5^3, you'd multiply 5 by itself to get 25, but then your program multiplies 25 by 25 to get 625 (and then it goes even further to multiply 625 by itself)
11:17:06 <jmcarthur_work> @pl foo base power = product $ replicate power base
11:17:06 <lambdabot> foo = (product .) . flip replicate
11:17:33 <BONUS> we should really come up with a name for the (f .) . g pattern
11:17:34 <Cale> Lauren5: It's important to put the result somewhere other than where the original number is kept.
11:17:41 <Lauren5> oh
11:17:49 <axzs> Lauren5: also, add return 0
11:17:50 <jmcarthur_work> BONUS, (result.result) f g
11:17:54 <Lauren5> ok
11:17:55 <Lauren5> yea
11:18:02 <Lauren5> I had a feeling I screwed up my values
11:18:47 <jmcarthur_work> BONUS, where result = (.)
11:19:05 <jmcarthur_work> @pl \f g -> (f .) . g
11:19:05 <lambdabot> (.) . (.)
11:19:47 <BONUS> yeah
11:20:12 <Cale> Lauren5: However, you could also keep this squaring in place, if you were a bit more clever about what happens to the exponent on each step.
11:20:51 <Lauren5> ok
11:20:55 <Lauren5> ahhhgh
11:21:20 <jmcarthur_work> #haskell-blah or something at least? or /msg?
11:21:53 <dons> bos31337: interesting http://twitter.com/yoz/statuses/2821421900
11:21:55 <dons> how's oscon?
11:22:33 <Cale> Lauren5: But perhaps easier to just go with decreasing the exponent by 1 each time.
11:23:06 <Lauren5> yea..
11:23:16 <Lauren5> agh
11:23:23 <Cale> > let power x 0 = 1; power x y = x * power x (y-1) in power 5 3
11:23:25 <lambdabot>   125
11:23:32 <Lauren5> so where exactly should I place the result?
11:23:47 <Cale> Lauren5: define a new variable to place it in
11:23:53 <Lauren5> ok
11:24:47 <bos31337> dons: funny
11:24:51 <Cale> (you could also define a new function and use recursion, like my Haskell program there did)
11:25:02 <bos31337> oscon is the same as it is every year, only slightly smaller.
11:25:35 <bos31337> mostly the same people talking about mostly the same things. bit of a yawner.
11:25:50 <jmcarthur_work> Cale, if you encourage a c student to use recursion you might be giving somebody a bad grade :(
11:25:52 <dons> need to come back to pdx town
11:26:04 <Cale> jmcarthur_work: really?
11:26:07 <dons> where the sun is warm and the beer is strong and the lambdas grow on trees
11:26:21 <Cale> jmcarthur_work: I suppose there are a lot of bad C compilers.
11:26:27 <dino-> jmcarthur_work: Wow, I hope that's not really true!
11:26:36 <dino-> yeah
11:26:42 <jmcarthur_work> Cale, i've seen it. many c people think recursion is unreadable and bug prone
11:26:51 <jmcarthur_work> including some instructors
11:26:55 <dino-> no tail opt -> dino- cries
11:27:10 <hzap> my first non-silly C assignment involved a lot of recursion
11:27:14 <Cale> That's insane for something like this. This is very recursive.
11:27:23 <jmcarthur_work> i agree
11:27:26 <dino-> > let power p b = foldr (*) 1 $ replicate p b in power 3 2
11:27:27 <lambdabot>   8
11:27:43 <jmcarthur_work> i've gotten bad marks on test questions for using recursive solutions in c programs
11:27:53 <watermind> jmcarthur_work: ouch
11:27:54 <jmcarthur_work> and had to raise hell to get the grade back
11:28:01 <Cale> You'd want your program to reflect the mathematical statements that n^0 = 1 and that n^m = n * n^(m-1)
11:28:06 <hzap> (well, the next assignment was to rewrite it iteratively)
11:28:07 <dino-> > let power p b = foldr1 (*) $ replicate p b in power 4 5
11:28:08 <dons>  #haskell. a bit of an announcement, Galois is going to need to hire half a dozen more full time Haskell programmers over the next few months. Please think about whether you're interested.
11:28:08 <lambdabot>   625
11:28:27 <Cale> dons: hmm...
11:28:29 <dino-> dons: :O  half a dozen
11:28:35 <FunctorSalad> jmcarthur_work: a numerics TA also told me something to the effect that they don't like recursion around these parts ;) didn't get a bad grade though
11:28:35 <soupdragon> dons you have to live in a certain place?
11:28:46 <dons> almost certainly you'll have to move to Portland, OR.
11:28:47 <Lauren5> that's true
11:28:50 <mercury^> Cale: Hmm, I'm always one who doesn't like it when the solutions don't use the obvious better algorithm for things like powering.
11:29:03 <dons> we'll be sending out further hiring details soon, and recruiting at ICFP.
11:29:06 <Ke> are you sure  C compiler can handle such recursion typically
11:29:07 <Cale> dons: Interestingly enough, I have extended family in Portland.
11:29:17 <watermind> jmcarthur_work: sometimes certain recursive solutions are a "bad idea" because you are using to much memory
11:29:33 <Ke> unless it is probably such things shouldn't be encouraged
11:29:33 <dons> if you want more info, mail me (or IRC), and keep an eye out for the job announces soon
11:29:34 <Cale> mercury^: Well, you could use that too of course.
11:29:40 <jmcarthur_work> waterman, a bad compiler is not an excuse
11:29:45 <Cale> mercury^: But it doesn't change the desire to use recursion
11:29:45 <watermind> jmcarthur_work: that is if you have to calculate a factorial and your C solution is a foldr like solution it's pretty bad
11:29:49 <Ke> jmcarthur_work: yes it is
11:29:59 <watermind> jmcarthur_work: not talking about compiler
11:30:01 * dons wonders if we need "Haskell Certification" yet.
11:30:03 <Ke> jmcarthur_work: C is about pragmatism
11:30:17 <jmcarthur_work> waterman, there are recursive factorials that don't exhibit bad space behavior
11:30:31 <watermind> jmcarthur_work: I know, a foldl' one would be fine
11:30:48 <Cale> mercury^: There, you're using the fact that if m is even, then n^m = (n*n)^(m/2), and if m is odd, then you still have n^m = n * n^(m-1)
11:31:15 <watermind> jmcarthur_work: so my point is just that some instructors when faced with a foldr like recursive solution in C will simply say that a "Recursive solution is bad"
11:31:16 <Cale> = n * (n*n)^((m-1)/2) if you like ;)
11:31:26 <watermind> jmcarthur_work: even though it's just that concrete choice of recursion
11:31:34 <axzs> I'm attempting to install leksah, and cabal says: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3088. I'm rather new to packages, what to do?
11:31:39 <jmcarthur_work> waterman, sounds lazy :\
11:31:56 <watermind> jmcarthur_work: so in the fact example many instructures would just say, don't use recursion do it iteratively
11:32:02 <Zao> axzs: Install gtk2hs from the source tarball/distro/installer EXE.
11:32:12 <jmcarthur_work> waterman, i would take issue with those instructors
11:32:12 <watermind> jmcarthur_work: but of course the usual iterative solution is just like a foldl'
11:32:19 <Zao> axzs: gtk2hs is not in hackage, and thus cabal can't install it automagically.
11:32:23 <jmcarthur_work> as they are teaching things which are not true
11:32:31 <axzs> thanks
11:32:34 <Zao> http://www.haskell.org/gtk2hs/
11:32:47 <watermind> jmcarthur_work: I see your point... then again, for many students the recursive solution with an accumulator is over their heads
11:33:01 <jmcarthur_work> waterman, doesn't mean they should be discouraged from it
11:33:06 <watermind> jmcarthur_work: indeed
11:33:10 <Cale> There's nothing wrong with asking the student to take advantage of the associativity of multiplication, say, to improve space performance. But asking that it not be recursive is silly ;)
11:33:24 <watermind> Cale: yeap I agree
11:34:41 <watermind> Cale: all I'm saying is that I can see some instructors saying "you got a bad score because you used recursion" even though that's not exactly what they mean
11:34:42 <dansa> asking anything is silly
11:35:02 <dansa> the student has enough capacity to figure out what he needs for himself
11:35:21 <Lauren5> I've only learned C programming for about a week O_O
11:35:27 <dansa> even because if had not, it would be only by doing it on his own that he would acquire it
11:35:38 <dansa>               he
11:35:41 <Cale> Lauren5: right, this discussion has sort of moved off along a tangent :)
11:35:54 <dansa> which is where i jump in :)
11:36:03 <dansa> they call me a tangent surfer
11:36:07 <hzap> which tends to happen a lot in #haskell :D
11:36:20 <dansa> which is cool :)
11:36:52 <shepheb> every time #haskell tangents on something Haskell-related, a newbie's brain explodes.
11:36:52 <watermind> Lauren5: and how many segfauts did you get so far? :P
11:37:23 <Lauren5> I...don't even know what that is
11:37:26 <hzap> shepheb: good thing this is C-related then :)
11:37:46 <Cale> Lauren5: You'll find out when you learn about pointers. :)
11:37:56 <Lauren5> ok o_o.
11:38:25 <Lauren5> ahhhhhhhhhhhhhhhhhhh
11:38:27 <dansa> he might find out before that :)
11:38:39 <shepheb> hzap: think that will stop us?
11:39:29 <hzap> shepheb: ah, so it's you causing the explosion, not the discussion? :
11:40:19 <watermind> Cale: chances are she'll find out before she learn about them ;)
11:40:20 <Ke> my linux can only handle stack of 300 000 levels of recursion or so, it seems
11:40:25 <shepheb> hzap: just wait. perhaps the biggest splatter I suffered two years ago when I started learning came from a discussion that started on something unrelated to Haskell.
11:40:45 <Ke> also debugging iterative code might be nicer
11:41:24 * benmachine wonders whether gcc will typically optimise simple recursion into a loop
11:41:36 <watermind> Cale: most students I know find  out about segfault when they try to create functions to read values from an input
11:41:44 <jmcarthur_work> benmachine, pretty sure it does
11:41:45 <benmachine> debugging optimised code is *definitely* a pain in the bum
11:41:51 <jmcarthur_work> tail recursion, i mean
11:42:03 * jmcarthur_work never uses debuggers
11:42:10 <EvilTerran> Ke, surely haskell's control of side-effects dramatically reduces the interface of any component, making debugging substantially easier (in theory, at least)?
11:42:11 <Ke> jmcarthur_work: but you don't optimize for debugging
11:42:19 <jmcarthur_work> not as a rule. i simply never seem to find a good reason to
11:42:29 <Ke> EvilTerran: I doubt haskell uses recursion
11:42:35 <hzap> legend says that Haskellers hacked TCO into gcc :)
11:42:36 <jmcarthur_work> Ke, hey, i wasn't complaining
11:42:48 <Cale> watermind: Of course, it's a little irresponsible to tell someone about scanf without teaching about pointers first...
11:42:54 <hzap> no idea where i heard tha though
11:43:06 <hzap> that*
11:43:10 <EvilTerran> Ke, er, i'm not sure what you mean by that.
11:43:23 <watermind> Cale: I don't know... that means you'd have to intruduce them quite early on
11:43:34 <Lauren5> The people in ##c are comatose...
11:43:34 <mauke> it's a little irresponsible to tell someone about scanf without teaching them C first
11:43:43 <mauke> scanf is an advanced function
11:43:43 <benmachine> watermind: I reckon fgets + strtol would cover you early on
11:43:51 <Ke> EvilTerran: haskell is built in a manner in which making recursion iterative is easy, I think
11:44:08 <dino-> Lauren5: I think it's just that they're extremely busy tracking down memory leaks.
11:44:11 <benmachine> mauke: yeah, it has some nice things but if you don't know how to use it it will break in horrible ways
11:44:15 <Ke> EvilTerran: oterwise there would be no functional programming
11:44:17 <Lauren5> lol
11:44:34 <mauke> benmachine: the most important lesson is to not use it for user input
11:44:37 <mauke> after that it's not so bad
11:44:38 <hzap> my previous course did scanf really early, and just mentioned that "you need the & operator for it to work, it's magic"
11:44:54 <Lauren5> how long have you all done programming?
11:44:57 <dino-> I have to try to extend credit for that to whomever said something a couple of months ago here, about it's not their fault they're cranky... you get it
11:44:59 <benmachine> mauke: you can use it for user input
11:44:59 <EvilTerran> Ke, well, ghc-compiled haskell doesn't use the C stack for recursive expressions directly, if that's what you mean
11:45:08 <mauke> benmachine: yes, but you shouldn't
11:45:08 <benmachine> just check the return value and width-limit all your strings
11:45:10 <EvilTerran> Ke, but it still uses a stack of sorts, seeing as we can still get stack overflows
11:45:11 <Ke> EvilTerran: yes
11:45:17 <mauke> benmachine: that doesn't work
11:45:26 <Cale> Lauren5: Let's see... 17 years or so.
11:45:27 <jmcarthur_work> Lauren5, 16-ish years
11:45:35 <benmachine> doesn't work?
11:45:38 <Lauren5> woow
11:45:40 <mauke> Lauren5: 9 years maybe
11:45:51 <benmachine> (I've been doing programming for nearly two years I think?)
11:46:13 <EvilTerran> Lauren5, uh... about 10 years from when i first started copying listings out of the BASIC manual into my parents' BBC Micro
11:46:41 <benmachine> mauke: how doesn't it work?
11:46:53 <jmcarthur_work> Lauren5, 16 years might be stretching it though because i was 8 when i started. not sure if i should say the beginnings were really programming
11:46:56 <mauke> benmachine: scanf is not line based
11:47:01 <hzap> i'd also have 10 years if you count it from the first time I randomly played around coding in VB
11:47:16 <Cale> EvilTerran: BBC Micro in 1999?
11:47:21 <benmachine> mauke: hmm, but you could use a character class specification to stop at a newline?
11:47:21 <Lauren5> wow
11:47:23 <watermind> benmachine:how does that prevent segfaults??
11:47:42 <benmachine> wait
11:47:43 <dino-> jmcarthur_work: I was thinking that too. Strictly by that I could say 28 years. But it wasn't continuous.
11:47:55 <benmachine> how exactly do you segfault with scanf anyway? you provide all the pointers yourself
11:48:00 <mauke> benmachine: what if you ask for a number and the user types "1z43824"?
11:48:04 <jmcarthur_work> dino-, well, i was rather continuous, but i started at a necessarily slow pace
11:48:06 <watermind> benmachine: just mess up providing the pointers
11:48:18 <EvilTerran> Cale, well, it may've been a bit earlier than that, but around then. we've still got it in perfect working order, iirc.
11:48:25 <Cale> EvilTerran: cool
11:48:27 <hzap> but it never felt really awesomely fun until i started haskell
11:48:30 <watermind> benmachine: it happens with stupid user errors but it happens
11:48:32 <shapr> Berengal: You wrote Acme.Time.Now?
11:48:44 <dino-> jmcarthur_work: Sure, continuous is probably a bad word. It was interspersed with being a kid, different kinds of school, etc.
11:48:53 <benmachine> watermind: yeah I never said scanf was a good beginner's tool, just that it's not a bad tool altogether :)
11:49:14 <watermind> benmachine: yes it's pretty good... I agree
11:49:20 <mauke> it is a bad tool altogether
11:49:24 <benmachine> mauke: I see your point I guess. I don't think it's insurmountable, though
11:49:28 <mauke> benmachine: it is
11:49:39 <watermind> benmachine: it was just an example of how you can get segfaults doing simple things
11:49:43 <EvilTerran> mauke, is printf the problem, or is C the problem?
11:49:48 <mauke> EvilTerran: no
11:49:50 <mauke> it's scanf
11:50:02 <EvilTerran> er, s/print/scan/, brainographical error :P
11:50:17 <hzap> brainographical :D nice
11:50:18 <Ke> EvilTerran: but I hope you don't mean that if I tail recurse my list of 1000 000 units, I'd get stack overflow
11:50:32 <EvilTerran> Ke, not if you tail-recurse, no
11:50:39 <EvilTerran> (probably)
11:50:42 <EvilTerran> (depending on strictness)
11:51:29 <benmachine> mauke: okay I'll concede. what about getting a string from the user with fgets and then using sscanf? then with %n you can check if all the input was consumed
11:51:36 <EvilTerran> Ke, tail-recursion doesn't work quite so neatly as a concept in lazy languages as it does in eager ones
11:51:41 <dino-> btw, I like the mention of a Haskell Certification. Has anything like this been talked about? I think I need to read haskell-cafe more studiously.
11:51:42 <mauke> benmachine: that's fine
11:52:01 <benmachine> fair enough
11:52:19 <mauke> you wouldn't even have to check
11:52:43 <mauke> I'm fine with "1z43824" being interpreted as 1
11:52:46 <benmachine> oh
11:53:14 <benmachine> but your problem is that scanf would interpret it as 1 and leave z432824 in the input?
11:53:17 <mauke> but only reading 1 and leaving "z43824" for the next input operation is just asking for trouble
11:53:22 <mauke> yes
11:53:22 <benmachine> ah
11:53:33 <benmachine> yeah, that's pretty annoying
11:53:42 <mercury^> Cale: That's not the most efficient "simple" algorithm though.
11:53:44 <mauke> also, scanf doesn't let you react to someone just hitting enter at a prompt
11:54:00 <benmachine> doesn't that just return 0?
11:54:26 <mauke> I see you don't know enough about scanf yet. you probably shouldn't use it :-)
11:54:52 <mauke> scanf %d skips leading whitespace. \n is whitespace.
11:54:55 <benmachine> oh, yeah
11:55:00 <benmachine> k
11:55:11 <mauke> just another consequence of scanf not being line-based
11:55:14 <benmachine> you have successfully convinced me of the evils of scanf
11:55:44 <Ke> scanf is nice, if you use it properly
11:56:08 <mauke> the only real use for scanf I've seen so far is online programming contests
11:56:14 <benmachine> hah
11:56:16 <dons> byorgey: around?
11:56:17 <mauke> where you have very specific input constraints
11:56:27 <benmachine> Ke: so how do you respond to the problem of unconsumed input?
11:56:47 <Ke> hmm, unconsumed
11:56:49 <Ke> ?
11:56:57 <benmachine> I mean like if you do
11:56:59 <mauke> Ke: I see you don't know enough about scanf yet. you probably shouldn't use it :-)
11:57:12 <benmachine> scanf("%d"...) and the user inputs 1!
11:57:14 <Ke> mauke: just tell me?
11:57:16 * EvilTerran prefers to use a (potentially non-portable) console library over stdio, when he's writing a console interface
11:57:19 <benmachine> then the ! stays on the input queue
11:57:21 <mauke> Ke: tell you what?
11:57:26 <hzap> mauke: you sure like that line, don't you :D
11:57:37 <benmachine> I don't like it >_>
11:57:46 <Ke> hmm ok I meant fscanf
11:57:46 <EvilTerran> if i want to act on streams of text, sure, i'll use stdio
11:57:56 <benmachine> the proper response to not knowing enough about scanf is to learn enough about scanf
11:58:01 <mercury^> Ke: same deal, isn't it?
11:58:03 <benmachine> and then still not use it
11:58:05 <benmachine> as I have just done
11:58:10 <Ke> (there isn't really anything better in C?)
11:58:12 <benmachine> no fscanf is different
11:58:14 <EvilTerran> if i want to present an interactive interface, give me System.Console etc :)
11:58:35 <benmachine> or is it
11:58:37 <benmachine> it might be
11:58:39 <Ke> obviously for user input one uses something better
11:58:42 <benmachine> yeah
11:58:59 <benmachine> it is user input that we were talking about in discussion of scanf, I think
11:59:05 <EvilTerran> benmachine, well, fscanf is only going to be used on something you expect to be a non-interactive stream
11:59:15 <mercury^> benmachine: what does fscanf do different?
11:59:16 <Ke> but for input files I think you'll always get what you want or unexpected return value
11:59:34 <benmachine> mercury^: it does things more or less the same, but it has a different purpose
11:59:43 <EvilTerran> the main difficulty with scanf is people thinking they're clever using it to write interactive console programs
11:59:52 <benmachine> mercury^: with a user input funciton, you want to detect invalid input, discard it, and warn
12:00:04 <mercury^> Same with file parsing...
12:00:13 <benmachine> with a file input function, invalid input is going to be more or less a fatal error
12:00:24 <benmachine> because the file isn't going to change because you asked it to
12:00:32 <Ke> benmachine: my point exactly
12:00:50 <benmachine> Ke: yeah I think we agree with each other
12:01:08 <Ke> =o)
12:02:21 <Ke> just so used to scanf=fscanf=sscanf due to the manpage
12:02:28 <benmachine> heh
12:02:28 <mercury^> Ah, you think the problem is that the user cannot make corrections after the input stream is fudged?
12:02:49 <benmachine> mercury^: pretty much yeah
12:04:55 <mercury^> And clearing it is not an option because?
12:05:51 * lilac votes for keeping sscanf and vsscanf and banning the rest
12:06:17 <benmachine> mercury^: it is an option, it's just much more of a headache
12:06:38 <benmachine> than getting a line with fgets or whatever and parsing it with sscanf
12:08:41 <benmachine> is there a haskell interface to select() or do I just thread the hell out of everything? (pretty happy with how the latter is working for me so far)
12:09:04 <dolio> Threading uses select internally.
12:09:09 <monochrom> Thread the hell. Most are green threads, the guts use select anyway.
12:09:17 <benmachine> heh
12:09:33 <mauke> 10k threads, no problem
12:09:40 <benmachine> after trying to understand threading in C and python I have to say haskell's forkIO is nothing short of miraculous
12:09:43 <monochrom> green threads are pretty close to select.
12:09:50 <mmmulani> if I had a number a = "123" and b = "456" and wanted to produce c = "123456", would it be faster to use show, ++ and read vs multiplying a by 10^(digits of b)?
12:10:18 <benmachine> mmmulani: I think the latter woudl be faster
12:10:21 <monochrom> It helps that you don't think in terms of shared variables and locking.
12:10:24 <opqdonut> the multiplying would be netaer at least
12:10:32 <EvilTerran> mmmulani, write whichever looks nicer, and optimise later :)
12:10:35 <opqdonut> probably faster too
12:10:35 <mmmulani> ahahaha
12:10:37 <benmachine> monochrom: mvars aren't shared variables?
12:11:01 <mmmulani> how long does log take on a n digit number?
12:11:05 <benmachine> well I guess they're a different kind of thing
12:11:11 <monochrom> mvars are, but you use so few of them it's easy to reason out.
12:11:19 <mmmulani> (I was afraid it would take long because the numbers might get REALLY big)
12:11:59 <benmachine> is there a log that operates on very large Integers, might be a more pertinent question
12:12:03 <monochrom> mvars are weaker than shared variables. weaker means less tight coupling.
12:12:38 <lilac> mmmulani: how big is /really/ big?
12:12:45 <EvilTerran> benmachine, one big bonus is that you don't have to worry about another thread changing anything that isn't explicitly marked as mutable (by being an MVar or what-have-you)
12:13:03 <EvilTerran> everything being immutable by default makes concurrency a lot nicer on its own
12:13:05 <benmachine> indeed
12:13:31 <benmachine> FP is just better suited to concurrency, I think
12:13:32 <monochrom> Yes, what EvilTerran says is what I mean by "you don't think in terms of shared variables".
12:13:34 <lilac> mmmulani: i'd be pretty afraid of using log for Double on really big integers since for powers of 10 it might give an off-by-one error :)
12:14:17 <EvilTerran> mmmulani, i don't think there's an integer logarithm function in the standard libraries
12:14:29 <EvilTerran> mmmulani, but repeated division by ten may still be fast enough
12:15:13 <benmachine> mmmulani: if you think about it, read and show pretty much have to work out how many digits are in the number
12:15:13 <lilac> divide by 10, then 100, then 10000, etc. then go back down again
12:15:19 <EvilTerran> mmmulani, and repeated division by ten will have to be done internally by show anyway, so it shouldn't be any slower
12:15:29 <lilac> (if you care about how fast it is)
12:15:34 <benmachine> so doing that working yourself is probably going to be faster since you don't do all the other stuff they do
12:17:13 <lilac> > filter (\(a,b,c)->a) [(floor (logBase 10 (10^n)) /= n, n, logBase 10 (10^n)) | n <- [0..200]]
12:17:24 <lambdabot>   [(True,3,2.9999999999999996),(True,6,5.999999999999999),(True,9,8.999999999...
12:17:42 <soupdragon> who invented human speech?
12:17:55 <dino-> soupdragon: Why, humans did, of course, silly.
12:18:00 <lilac> soupdragon: i think it was chuck norris
12:18:05 <Rotaerk> soupdragon, jesus did
12:18:06 <dino-> heh
12:18:16 <Rotaerk> human speech began in 0 AD
12:18:24 <mauke> jews did human speech
12:18:42 <FunctorSalad> it was taught to us by the raptors...
12:18:43 <lilac> soupdragon: some guy called ug
12:18:43 <monochrom> Oleg invented type-level human speech.
12:18:49 <lilac> hah
12:19:04 <mauke> enki
12:19:14 <lilac> monochrom == win
12:19:27 <monochrom> hehe
12:19:35 <mmmulani> lilac: less than 10^20
12:19:37 <benmachine> soupdragon: um, why do you ask?
12:20:11 <benmachine> hmm
12:20:24 <lilac> mmmulani: that's not so big :)
12:20:29 <benmachine> mmmulani: how about, convert it to a float, log it, and then test to see if you were right
12:21:44 <mmmulani> benmachine: might try that
12:29:39 <lilac> > let digits = foldr (\n m k -> if k >= 10^n then m (k`div`10^n) + n else m k) (const 1) [16,8,4,2,1] in map digits [0,1,9,10,99,100,999,1000,9999,10000,123456789012345,12345678901234567890]
12:29:40 <lambdabot>   [1,1,1,2,2,3,3,4,4,5,15,20]
12:29:44 <lilac> mmmulani: ^^ you could use that
12:29:55 <lilac> good for up to 31 digits
12:30:59 <lilac> but really, "digits = length . show" is the way to go unless you know it's a bottleneck
12:32:04 * lilac wonders if GHC will unroll that CAF into a nice efficient function
12:34:34 <wabash> Hey, Just read somethin baout OCaml not being supported on SMP..... How bout Haskell? Does Haskell support SMP, hyperthreading, etc?
12:39:13 <mmmulani> lilac: thanks. I might switch from (logBase 10) to that
12:39:54 <opqdonut> wabash: it does, and quite well
12:39:59 <Oejet> wabash: http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html
12:40:12 <wabash> opqdonut: Oejet: ok, thanks.
12:40:16 <wabash> messages are async?
12:40:38 <opqdonut> also http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
12:41:07 <opqdonut> wabash: yes you can use for example MChans to sen asynchronous messages
12:41:34 <opqdonut> excuse me, Chans
12:41:40 <opqdonut> (from Control.Concurrent)
12:41:42 <opqdonut> nite
12:43:06 <Lauren5> Hello everyone
12:43:16 <Lauren5> I'm happy to announce that my program file is fixed thanks to your help
12:43:27 <Lauren5> ##C is still comatose...
12:43:31 <jmcarthur_work> haskell has some of the nicest smp support i have seen in any language
12:43:38 <Lauren5> :)
12:43:57 <Lauren5> bye everyone
12:44:55 <Oejet> wabash: The documentation for the different concurrency libraries: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
12:46:34 <jmcarthur_work> wabash, and that's not even counting the parallelism stuff
12:48:28 <jmcarthur_work> par, strategies, and nested data parallelism
12:49:59 <Kanito> omg, there worldly known programming languages and i know nothing about it
12:50:02 <Kanito> btw hello
12:50:35 * ekidd can't wait until NDP code can be transparently compiled to run on the GPU (or via OpenCL or something like that). :-)
12:50:37 <jmcarthur_work> hello
12:50:37 <Kanito> what kind of software you are writing? i wanna see examples
12:50:45 <Kanito> if its possible :}
12:50:50 <Oejet> wabash: Finally, if you'd like to implement those yourself, take a look at: http://www.haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency .
12:50:57 <jmcarthur_work> Kanito, http://hackage.haskell.org/packages/archive/pkg-list.html
12:51:25 <Kanito> thats deep :}
12:52:01 <Oejet> Kanito: Labas vakaras.
12:52:10 <jmcarthur_work> Kanito, haskell is basically a general purpose language :)
12:52:46 <Kanito> sveikas, nedraudia ia piktomis kalbomis kalbti? :}
12:52:57 <Kanito> they may complain about the lang :}
12:53:36 <mauke> that doesn't even look like a real language
12:54:13 <soupdragon> mauke, haskell is a real languale
12:55:09 <Oejet> Kanito: There are even commercial users: http://www.haskell.org/haskellwiki/Haskell_in_industry
12:58:53 <Kanito> a6 ivis neraunu kodl a nieko neinau apie tok dalyk
12:59:02 <Kanito> kaip atsiliklis jauiuos :)
13:00:13 <dansa> basically general purpose?
13:00:19 <dansa> why basically? :)
13:00:33 <dansa> i never understand these qualifications :)
13:05:07 <mmorrow> dcoutts, Saizan: ping
13:05:17 <jmcarthur_work> dansa, if your purpose is to make dijkstra cry then you shouldn't use haskell, therefore haskell is not general purpose
13:05:43 <benmachine> does weeping with joy count?
13:05:47 <jmcarthur_work> no
13:05:53 <mmorrow> dcoutts, Saizan: oh n/m i just solved my dilemma
13:06:29 <jmcarthur_work> @faq Can Haskell code make Dijkstra cry?
13:06:29 <lambdabot> The answer is: Yes! Haskell can do that.
13:06:31 <jmcarthur_work> dang
13:06:32 * Saizan_ pongs anyway
13:06:34 <jmcarthur_work> nevermind then
13:07:21 <Oejet> Kanito: You may write English. :)
13:08:26 <monochrom> Dijkstra never cries.
13:08:48 <monochrom> He would just look over your shoulder and disapprove. :)
13:08:51 <mmorrow> dcoutts, Saizan: actually i didn't
13:09:11 <FunctorSalad> did Dijkstra have opinions on the concepts in haskell? (purity, type system etc.)
13:09:17 <Saizan_> mmorrow: what's the problem?
13:09:22 <monochrom> No.
13:09:40 <dcoutts> mmorrow: :-)
13:09:40 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
13:09:51 <mmorrow> Saizan: hey. i'm trying to figuring out what the error messages in http://hackage.haskell.org/packages/archive/derive-gadt/0.1.0/logs/failure/ghc-6.10 are saying
13:09:57 <wabash> Ah, quick question. Does Haskell handle Kanji ok?
13:10:20 <monochrom> Yes.
13:10:27 <monochrom> (quick answer)
13:10:38 <Saizan> mmorrow: see the warning in the configure step
13:10:43 <dcoutts> wabash: the Char and String type do Unicode, IO in UTF-whatever is slightly more tricky.
13:11:13 <mmorrow> Saizan: it seems that the API of haskell-src-exts hasn't changed in a breaking way or anything between 1.0.0 and 1.0.1, is this because cabal is choosing to use haskell-src-exts-1.0.0 and the newest version is haskell-src-exts-1.0.1 ==> the types are being judged incompatible?
13:11:37 <dcoutts> mmorrow: doesn't matter if it's breaking or not
13:11:44 <dcoutts> mmorrow: they're simply different types
13:11:45 <FunctorSalad> utf8-prelude is a nice lightweight approach
13:12:05 <mmorrow> ahh, so then it's choosing 1.0.0 on account of haskell-src-meta wanting that...
13:12:07 <mmorrow> i see
13:12:22 <mmorrow> err, actually i don't see
13:12:33 <Saizan> it's using 1.0.1
13:12:34 <dcoutts> mmorrow: the hackage builder doesn't do anything smart in picking versions of deps, unlike say cabal-install which uses a constraint solver.
13:12:43 <Saizan> but it's haskell-src-meta is compiled against 1.0.0
13:12:55 <mmorrow> ahh, ok i see now.
13:13:22 <mmorrow> so i guess uploading a new version of haskell-src-meta will cause it to be rebuilt, thus fixing the build of derive-gadt?
13:13:31 <dcoutts> mmorrow: in this situation, cabal-install would probably choose to rebuild haskell-src-meta against haskell-src-1.0.1
13:13:55 <dcoutts> mmorrow: I don't think we should be uploading unchanged versions of packages just for the sake of the stupid hackage auto-builder
13:13:59 <mmorrow> dcoutts: i'm trying to figure out the path of least resistance to fix the build on hackage so the docs get built
13:14:14 <mmorrow> dcoutts: i dunno.. the docs are nice :)
13:14:47 * mmorrow could also just link to an external location holding the docs in the module header..
13:14:53 <Saizan> hack on the new hackage-server so that it can be finally used for hackage.haskell.org?:)
13:15:08 <mmorrow> :)
13:15:09 <dcoutts> mmorrow: if you're desperate you can ping Ross, or better do as Saizan suggests :-)
13:15:33 <mmorrow> i'll just link to them for now
13:15:56 <mmorrow> is the hackage-server being hacked on actively atm?
13:16:01 <dcoutts> yup
13:16:04 <mmorrow> ooh, cool
13:16:16 <dcoutts> and it'll be done quicker if you help :-)
13:16:18 <mmorrow> i should look at that again
13:16:25 <Saizan> is there a TODO list?
13:16:36 <dcoutts> Saizan: yes
13:16:49 <dcoutts> (in the TODO file)
13:17:02 * mmorrow darcs pulls
13:17:26 <dcoutts> two contributors have been working on users and authentication
13:17:41 <dcoutts> we need someone to finish the tarball serving
13:17:54 <dcoutts> I've got some prototype code for that if anyone is interested
13:18:26 * mmorrow is :)
13:19:17 <badsheepy> dcoutts: if you are interested, and remember mylittle problem, recompiling ghc 6.10.4 and platform still gave the same cabal errors, but when i did it with 6.10.3 it worked fine
13:20:18 <dcoutts> badsheepy: weirdy
13:20:42 <mmorrow> dcoutts: ah, also i came across a (year or so iirc) old post to haskell-cafe (iirc) about a make-like thing for cabal, i'm interested in that/related too
13:20:43 <dcoutts> badsheepy: post the details in a bug report, either against the platform or against cabal
13:21:27 <dcoutts> mmorrow: you mean the make-style framework stuff that Saizan did his GSoC project on?
13:21:44 <Saizan> mmorrow: that'd be http://code.haskell.org/hbuild
13:21:51 <mmorrow> dcoutts: hmmmm. possibly, but i think this message predated that
13:22:04 <mmorrow> Saizan: ah nice, i've gotta darcs pull that too.
13:22:11 <mmorrow> Saizan: any further work on hbuild?
13:22:27 <badsheepy> willdo,i was just going to re-build 6.10.4 to confirm first
13:22:57 * mmorrow tries to find the link to this message and the url of the darcs repo with a mock-up
13:23:03 <dcoutts> mmorrow: see http://haskell.org/~duncan/hackage-server/ for the fragments of prototype code for a component to serve the contents of unpacked tarballs, the core bit is a compact data structure mapping paths of files in the tarball to offsets within the tarball.
13:23:05 <QP> can I ask, where can I get the Network.Socket module from? It doesn't seem to be there.
13:23:59 <mmorrow> dcoutts: ah nice
13:24:32 <Saizan> mmorrow: currently it does little things like inferring build-depends and other-modules and extensions, i'm working on the serialization to allow any Typeable type to be used as target/repr
13:25:08 <Saizan> mmorrow: i focused more on the EDSL rather than actually implementing something in it so far
13:25:26 <dcoutts> mmorrow: the strategy is to decompress but not unpack the tarfile and to hold a compact dir index in memory. So serving the content should be really quick, and managing replacing a whole set of docs should be easy (just upload a new .tar.gz doc bundle)
13:25:35 <mmorrow> Saizan: interesting, how do you mean the "target/repr" ?
13:27:05 <mmorrow> dcoutts: ah nice, i think i might have some code related to that in a could-be-hack-converted-to-something-like-that, i'll look through it
13:28:11 <Saizan> mmorrow: that's a bit long :) but basically instead of using just files and typestamps to determine if there's something to do we associate a (cached) representation with each target (which need not be a file), and compare the cached representations of the deps with their current ones to see if we need to refresh the current target
13:28:22 <Saizan> mmorrow: it becomes a matter of memoizing functions
13:29:38 <mmorrow> hmm, cool
13:31:24 <mmorrow> do these reprs exclusively deal with dependencies?
13:31:54 <mmorrow> (not sure what else they'd deal with, but trying to get a feel for what they are)
13:32:59 <Saizan> ah, for example if the target is say "HSource Main" then the repr will probably be "File src/Main.hs <modtime>"
13:33:36 <Saizan> modtime is an approximation there, you could have an hash of the file or something like that
13:34:34 <Saizan> so, if e.g. the searchpath changes and you later find the module Main gets resolved to "src1/Main.hs" you know you need to rebuild it
13:34:48 <benmachine> isPrefixOf distresses me, because its name makes syntactic sense when not infix but is misleading
13:34:49 <mmorrow> so where does the Typeable come in? err, better question: how do you interpret an arbitrary (Typeable a => a) in some meaningful (wrt hbuild) way?
13:35:12 <benmachine> I wrote startswith and that has exactly the same problem only the other way around
13:35:14 <dansa> jmcarthur_work: i didnt get your comment at all :) dijkstra... haskell not general purpose? no idea; please, clarify?
13:35:32 <benmachine> and then I decided to tell you guys about it for some reason
13:36:20 <EvilTerran> benmachine, use a section?
13:36:30 <EvilTerran> benmachine, as in ("foo" `isPrefixOf`)
13:36:52 <mmorrow> Saizan: ohh, so they /user/ chooses a representation, and provides some means of working with that rep, and Typeable is just to allow for generic serialization?
13:36:55 * EvilTerran has written such things fairly frequently
13:37:06 <Saizan> mmorrow: right
13:37:23 <Saizan> mmorrow: the engine only cares about Ord and Eq for the target and repr types chosen
13:37:24 <benmachine> EvilTerran: I suppose so, but I guess I'm just annoyed that isPrefixOf "foo" doesn't at all do what you'd think
13:37:33 <mmorrow> Saizan: ah, i see
13:37:52 <EvilTerran> benmachine, or choose some meaningless symbolic name, |<-- or something, then there's no natural language interpretation at all :P
13:38:10 <benmachine> heh
13:38:13 <benmachine> that works
13:38:30 <Saizan> mmorrow: currently the build rules (which are the "user") use two big sum types to cover the needed cases, but that obviously won't scale
13:41:14 <chessguy_work> |<-- is more meaningless than >>= ?
13:41:50 <benmachine> a little
13:42:19 <chessguy_work> why?
13:42:24 <Rotaerk> |>->|
13:42:40 <mmorrow> Saizan: hmm, that seems like the perfect place to come up with some sort of mini-language or something that would be able to express any (within reason) combination/whatever of cases
13:42:52 <mmorrow> at least, that would be neat :)
13:43:08 <EvilTerran> chessguy_work, i'd say neither are particularly meaningful
13:43:20 <chessguy_work> agreed
13:43:43 <EvilTerran> both allude to some kind of directionality and/or ordering because of the arrow-like appearance, but that's it, really
13:44:09 <mmorrow> Saizan: although i'm not sure how good a fit something like that would be for this particular situation
13:44:40 <mmorrow> (not that i think it's a bad fit, but that i just don't know much about the situation currently)
13:44:47 <Saizan> mmorrow: well i'd like the user to be able to use the most natural types for his domain, rather than converting them to some fixed set of combinators, mostly to gain type safety
13:45:00 <chessguy_work> EvilTerran, my thoughts exactly
13:45:41 <mmorrow> Saizan: hmm, yeah that an interesting idea
13:46:10 <dhun> I wrote another obfuscate oneliner, but now I know about foldl an lambda,  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7477#a7477
13:46:18 <monochrom> Syntax is meaningless.
13:46:33 <mmorrow> Semantics is formless.
13:46:39 <monochrom> hehehe
13:46:41 <mmorrow> heh
13:50:16 <bresbo>         Eight inches ... Nine, and still growing.  His erection was now
13:50:18 <bresbo> half as thick as his own wrist as -with a grunt of sexual ecstasy- he
13:50:21 <bresbo> began to spurt enormous quantities of cum into Christa's throat.
13:50:24 <bresbo> Greedily, she slurped and sucked on him as the tingle began to fade.  Drop
13:50:25 --- mode: ChanServ set +o Saizan
13:50:26 <bresbo> by drop, she tried to stem the stream, but enormous quantities spilled out
13:50:29 <bresbo> from around her mouth.  Nearly a minute passed, as Curt reached and
13:50:29 --- mode: Saizan set +b *!*i=dan@67.102.103.*
13:50:29 --- kick: bresbo was kicked by Saizan (Saizan)
13:50:36 --- mode: Saizan set -o Saizan
13:50:58 <dino-> Anyone use cabal2rpm? Seems kind of old, I wonder if it works still.
13:51:23 <dhun> somehow I feel like mac guyver building a nuclear rocket from his swiss army knife
13:51:54 <mauke> what would macguyver need to build a stargate?
13:52:12 <FunctorSalad> that's the same spam as last time
13:52:12 <dhun> don't kniw
13:52:26 <copumpkin> mauke: a rubber band and a pushpin
13:53:30 <monochrom> No need. Just need friendship with the Pheonix Foundation.
13:55:12 <dino-> @help check
13:55:12 <lambdabot> check <expr>
13:55:13 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
13:56:29 <MyCatVerbs> Dammit, lambdabot.
13:56:41 <MyCatVerbs> You can't prove buggerall in three seconds. Best you can do is disprove things.
13:57:00 <copumpkin> disproving is just proving something else
13:58:03 <MyCatVerbs> Proving interesting things usually involves much longer inference chains than finding counterexamples.
13:59:00 <dino-> MyCatVerbs: It's a fun MacGuyver-like help text, though, you must admit.
14:01:02 <monochrom> counterexamples prove interesting things too.
14:04:55 <benmachine> lambdabot has a @help?
14:05:07 <benmachine> that'd've saved me so much time :(
14:05:22 <soupdragon> yeah loads
14:08:50 <c_wraith> @check \x -> fix (const x) == x
14:08:52 <lambdabot>   "OK, passed 500 tests."
14:09:16 <copumpkin> yay
14:09:18 <c_wraith> I wonder what arbitrary instance gets used for that.
14:09:24 <mauke> ()
14:09:26 <\z> what's a good data structure to use if I have 8m (Int, Int) pairs and I need to search on both halves?
14:10:19 <copumpkin> search on both halves?
14:10:27 <MarcWeber> nominolo|uni: If you have some time telling me how to setup using scion I may fix the array trouble I introduced earlier..
14:10:28 <copumpkin> not as an interval, right?
14:10:30 <c_wraith> mauke, I hope it's something slightly more interesting than that.  All 500 tests would be pretty boring for that. :)
14:10:33 <\z> left half of the tuple and right half of the tuple
14:10:56 <\z> copumpkin: no they're not intervals
14:11:18 <c_wraith> :t IntMap
14:11:19 <mauke> c_wraith: they are
14:11:19 <lambdabot> Not in scope: data constructor `IntMap'
14:11:25 <benmachine> it checks for () and then checks it again just to make sure
14:11:29 <copumpkin> \z: a couple of IntMaps I guess?
14:11:39 <\z> with 8 million+ entries for each?
14:11:42 <copumpkin> yup :P
14:11:46 <c_wraith> IntMap is efficient.
14:11:56 <c_wraith> But you'll need two, for bidirectional searching
14:12:02 <\z> ok, I'll try it out.
14:12:03 <\z> right.
14:12:05 <copumpkin> data LotsOfPairs = LotsOfPairs (IntMap Int) (IntMap Int)
14:13:21 <c_wraith> @check \(x::Int) -> fix (const x) == x
14:13:22 <lambdabot>   Parse error in pattern at "->" (column 11)
14:13:26 <c_wraith> drat
14:13:48 <c_wraith> I can never remember when that's legal, nor the correct syntax when it is.
14:14:12 <mauke> it's never legal
14:14:17 <benmachine> @check \x -> fix (const (x + 0)) == x
14:14:18 <benmachine> :P
14:14:18 <lambdabot>   "OK, passed 500 tests."
14:14:25 <mauke> @check \x -> fix (const (x :: Int)) == x
14:14:27 <lambdabot>   "OK, passed 500 tests."
14:14:31 <c_wraith> Well, "that" being "applying a type to a subexpression"
14:14:40 <mauke> that's always legal
14:15:12 <FunctorSalad> @check \x -> fix (const (x `asTypeOf` length "hello")) == x
14:15:12 <c_wraith> Oh.  everything between \ and -> is a pattern, rather than an expression?
14:15:13 <lambdabot>   "OK, passed 500 tests."
14:15:23 <FunctorSalad> c_wraith: yes
14:15:32 <c_wraith> That makes sense
14:15:46 <benmachine> @type asTypeOf
14:15:47 <lambdabot> forall a. a -> a -> a
14:15:57 <FunctorSalad> mauke: never legal? it is legal with some extension
14:16:00 <benmachine> @src asTypeOf
14:16:00 <lambdabot> asTypeOf = const
14:16:07 <benmachine> :o clever
14:16:10 <Saizan> ScopedTypeVariables currently
14:16:21 <FunctorSalad> it is const with the types constrained to be equal
14:16:58 <c_wraith> @src Arbitrary
14:16:58 <lambdabot> Source not found. You type like i drive.
14:17:23 <c_wraith> blah.  what's the command to get the typeclass definition?
14:17:33 <\z> what provides Data.IntMap?
14:17:42 <benmachine> @index IntMap
14:17:42 <lambdabot> Data.IntMap
14:17:45 <Deewiant> containers
14:17:45 <benmachine> oh
14:17:46 <\z> I built 6.10.4 yesterday with docs, and it's installed but the docs aren't
14:17:53 <FunctorSalad> \z: not sure, I think 'containers'
14:18:05 <monochrom> @pl \z -> z
14:18:05 <lambdabot> id
14:18:07 <monochrom> hehe
14:18:21 <FunctorSalad> hayoo confirms it http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=IntMap
14:18:36 <\z> great.  thanks.  that explains why it was missing from libraries/base.  :-)
14:18:56 <c_wraith> @src Arbitrary Integer
14:18:57 <lambdabot> Source not found. Do you think like you type?
14:19:03 <monochrom> I swear by extralibs (in the past) and Haskell Platform (in the future)
14:19:07 <c_wraith> Apparently, I do think that badly. :)
14:20:54 <Saizan> c_wraith: @src Class for the definition of the class, @src method Type for the implementation, though the database is manually filled and quite sparse
14:21:29 <c_wraith> @hoogle Arbitrary
14:21:29 <lambdabot> Test.QuickCheck class Arbitrary a
14:21:29 <lambdabot> Test.QuickCheck arbitrary :: Arbitrary a => Gen a
14:21:29 <lambdabot> Test.QuickCheck coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
14:21:49 <c_wraith> @src Test.QuickCheck.Arbitrary
14:21:49 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:23:07 <FunctorSalad> c_wraith: the standard instances are here http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.1/doc/html/src/Test-QuickCheck-Arbitrary.html
14:25:50 <c_wraith> (,,,,) is an operator I hadn't seen before.
14:26:02 <dons> is there a hac phi channel?
14:28:20 <copumpkin> #haskell-hacphi I think
14:28:22 <dino-> c_wraith: (,) is the tuple constructor. So you've got 4 of them being used together there.
14:28:27 <dino-> :t (,)
14:28:28 <lambdabot> forall a b. a -> b -> (a, b)
14:28:44 <copumpkin> :t ((,),(,))
14:28:45 <lambdabot> forall a b a1 b1. (a -> b -> (a, b), a1 -> b1 -> (a1, b1))
14:29:01 <copumpkin> :t (((,),(,)),((,),(,)))
14:29:03 <lambdabot> forall a b a1 b1 a2 b2 a3 b3. ((a -> b -> (a, b), a1 -> b1 -> (a1, b1)), (a2 -> b2 -> (a2, b2), a3 -> b3 -> (a3, b3)))
14:30:24 <c_wraith> Oh, it was clear enough what the operator does.  It just wasn't teribly clear it existed.  , is a bit strange, syntactically.
14:30:44 <Phillemann> How can I express something like: data Foo a b = Foo { field :: Num a => a }, so you can store arbitrary numeric types in the field "field"?
14:31:16 <mauke> I don't think there's a good way to do that
14:32:24 <Phillemann> Okay.
14:33:05 <mauke> put your class constraints on the functions, not the type
14:34:05 <hackagebot> peakachu 0.1 - An FRP library with a GLUT backend (YairChuchem)
14:34:58 <dons> mmm
14:42:16 <stepcut> my Haskell app is using 30+ MB of virtual memory, but only 7MB of RSS. Is there someway to get it to use less virtual memory?
14:42:43 <Heffalump> did it peak at 30MB resident at some point?
14:42:59 <FunctorSalad> mauke: data Foo = forall a. Num a => Foo { field :: a }
14:43:02 <Heffalump> if so, I think you have to ask GHC HQ to implement handing memory back to the OS
14:43:16 <stepcut> Heffalump: I asked for that years ago
14:43:44 <stepcut> Heffalump: I am wonder if it is ever actually using 30MB in the first place though -- looking through RTS flags now to see if there is something I can do about it
14:43:55 <inimino> s/ask/convince/
14:44:04 <stepcut> virtual memory usage is more interesting now that VPSes are common..
14:44:08 <hackagebot> maid 2009.7.25 - A simple static web server (JinjingWang)
14:44:13 <beutdeuce> Anybody heard of the factor stack-based language?
14:44:16 <Heffalump> stepcut: why's that?
14:44:47 <copumpkin> beutdeuce: yup
14:44:59 <Heffalump> at work we discovered that Excel OLE objects (like checkboxes) are a great way to run through virtual address space at a real rate
14:45:06 <FunctorSalad> err, my last line was supposed to be to Phillemann
14:45:06 <beutdeuce> copumpkin: any opinions?
14:45:22 <bremner> stack based = pain in the ass?
14:45:33 <copumpkin> beutdeuce: it looks nice :) I haven't played with it much but it requires adjusting how you think
14:46:06 <bremner> I guess some people feel the same way (PITA) about functional
14:46:07 <stepcut> Heffalump: low end VPSes tend to have limited ram quotas. Say 64MB, and from what I can find, it seems that virtual memory counts against your quota
14:46:17 <stepcut> Heffalump: I could be wrong though
14:46:17 <copumpkin> wow
14:46:18 <Phillemann> FunctorSalad: What if I have to fields which should be of type Num? Two foralls?
14:46:24 <beutdeuce> copumpkin: same, it seems to be quite useful for learning both functional and oop in an interactive manner.
14:46:36 <copumpkin> not sure I'd say you're learning either of those
14:46:38 <soupdragon> yes 100#
14:46:40 <copumpkin> it's sort of on its own
14:47:09 <beutdeuce> copumpkin: did u watch http://www.youtube.com/watch?v=f_0QlhYlS8g ?
14:47:52 <copumpkin> nope
14:48:16 <beutdeuce> copumpkin: i'd recommend watching it. It's quite lengthy, but it will probide you with a great insight on the language
14:51:10 <hackagebot> DefendTheKing 0.1 - A graphical demo. Will be a game (YairChuchem)
14:51:49 <FunctorSalad> Phillemann: depends on whether you want them to be the same type, or any two nums
14:52:19 <FunctorSalad> in the second case, "forall a b. (Num a, Num b) => Foo { f1::a; f2::b }"
14:52:25 <Saizan> beutdeuce: is most of that staging compiled away?
14:52:42 <Phillemann> FunctorSalad: Ah, ok. Thanks.
14:52:47 <beutdeuce> Saizan: Factor?
14:52:51 <copumpkin> why is it that people recommend not to put class constraints on types?
14:52:59 <copumpkin> and instead suggest putting them on the functions that operate on them?
14:53:05 <Saizan> beutdeuce: yes
14:53:14 <mauke> copumpkin: because class constraints on types don't work
14:53:17 <sjanssen> beutdeuce: by the way, why come to #haskell and ask about factor? :)
14:53:36 <beutdeuce> Saizan: staging as in multi-staged? As in a stack?
14:54:02 <copumpkin> mauke: hmm
14:54:03 <sjanssen> copumpkin: class contraints on types are only considered upon construction (the constructor becomes a function with those class constraints), they don't ever save you from writing the context explicitly
14:54:18 <beutdeuce> sjanssen: On functional terms, of course :)
14:54:20 <Saizan> beutdeuce: as in the code quotations that get manipulated and then run
14:54:27 <copumpkin> oh I see
14:54:46 <copumpkin> sjanssen: that seems like it could be fixed somehow? by having the type implicitly carry the constraint?
14:55:18 <sjanssen> copumpkin: yes, see GADT class constraints
14:55:29 <copumpkin> ah yeah
14:55:41 <beutdeuce> Saizan: could could consider it that way, though half or more is interpreted right off the bat
15:01:40 <pikhq> http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel-Strategies.html So, you parallelise things by telling them to be evaluated in parallel...
15:01:47 <pikhq> God, I love this language.
15:03:45 <dons> :)
15:03:54 <dons> "you parallelise things by telling them to be evaluated in parallel" --> how else??!
15:04:20 <pikhq> In other languages, by implementing absurdly complex thread handling systems.
15:04:36 <pikhq> It's like implementing an OS to run dc.
15:05:03 <dons> languages can make it too hard to parallelise declaratively.
15:05:14 <dons> if there's simply overuse of effects, you can safely drop `par` on things
15:06:19 <stepcut> ok, with, main = getLine >> return (), my app uses 5MB of virtual memory, but if I compile with the threaded RTS it jumps up to 20MB
15:07:29 <dons> mmm
15:07:30 <FunctorSalad> seems to be a nice example of the principle that "the more constrained a collection of objects is, the more you can reason about them" (here the object is code)
15:08:20 <stepcut> xesh
15:08:39 <FunctorSalad> (that's my objection to the idea that constraining side-effects is an overly bondaging idea)
15:11:15 <hackagebot> np-extras 0.1 - NumericPrelude extras (BrentYorgey)
15:20:08 <tommd> I'm unclear on something to do with the Haskell/Hackage PVP.
15:20:30 <dons> ok.
15:21:13 <tommd> If a package I depend on releases a new major version (A.B.C.D, and the A or B changed) and I update my package to be able to use the later version as the API changes were compatible, then does my package need to inflate in major version number?
15:21:46 <tommd> It seems absurd if so, because a single package increasing the A.B will result in all deps (directly or indirectly) to need a major version change.
15:22:07 <dons> does your package change its API?
15:22:19 <hackagebot> species 0.1 - Combinatorial species library (BrentYorgey)
15:22:31 <tommd> No, and now I'm less confused after typing this out.
15:22:32 <jmcarthur_work> ?hackage species
15:22:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/species
15:22:52 <dons> right, the it is equivalent to a bug fix, so just minor rev.
15:23:00 <tommd> I was thinking that other packages that could have used my old package might not be able to due to conflicting requirements (dimond dependency)
15:23:02 <dons> its all about what api you provide
15:23:19 <hackagebot> formlets 0.5 - Formlets implemented in Haskell (ChrisEidhof)
15:23:21 <tommd> But if I can still use the previous version then it should be ok.
15:23:26 <dons> oh, i don't think you need to consider the diamond situation
15:23:30 <dons> assume the userr rebuilds everything
15:24:40 <tommd> Well, if pureMD5 needs binary >= 0.5 all of a sudden (where previously it could have used 0.4.x) and Happs needs pureMD5 and binary 0.4 (can't use 0.5 for unknown reasons) then it makes sense to bump the major version of pureMD5.  But for right now that isn't the case - pureMD5 can use >= 0.4 && < 0.6
15:25:05 <tommd> Just for a trivial example.
15:25:18 <dons> oh, haps must be able to use 0.5
15:26:58 <Philonous> Is there a way to deal with projects consisting of multiple files in emacs? A plugin for example that finds the appropriate .cabal file and compiles the whole project?
15:28:52 <Saizan> Philonous: scion with its emacs client should do that
15:30:35 <Philonous> Thanks
15:37:01 <gwern> 'peakachu' oh good grief
15:37:39 <yairchu> gwern: sorry ?
15:38:30 <dons> its a good name
15:38:36 <yairchu> :)
15:39:01 <yairchu> while we're at it. try to run DefendTheKing and tell me what you think
15:39:07 <dons> we need a survey of haskell web frameworks. a lot of people think there is only happs.
15:39:17 <dons> yairchu: i  tried it. builds, but doesn't seem to render properly in xmonad :/
15:39:26 <dons> let me try again...
15:39:27 <yairchu> oh
15:39:28 <gwern> dons: I'll bet you like loli too
15:39:54 <yairchu> xmonad does something special?
15:39:59 <dons> mm. no?
15:40:04 <yairchu> :)
15:40:14 <FunctorSalad> new away nickname of peaker? ;)
15:40:29 <gwern> peakerchu would just be worse
15:40:34 <yairchu> FunctorSalad: he explained to me what FRP is. so kinda
15:40:37 <dons> let me make a video
15:40:38 <FunctorSalad> or a new package?
15:41:28 <yairchu> FunctorSalad: a new package
15:43:41 <gwern> yairchu: defendtheking looks nice, even if it isn't a very good chess program for letting me move twice and all
15:44:19 <yairchu> gwern: that's because it will be a chess variant. with no turns
15:44:27 <yairchu> :)
15:44:30 <gwern> how does that work, exactly?
15:44:36 <gwern> every game ends in a tie?
15:44:50 <sm> yairchu: just worked here (on mac), cool beans
15:44:52 <yairchu> no. I made it in Python a few years ago and it's very fun
15:45:10 <nlogax> the only winning move is not to play
15:45:11 <sm> I love this new just works era
15:45:24 <yairchu> after you move a piece you can't do anything for half a second. and can't move that piece for two seconds
15:45:38 <gwern> ah, so a speed chess variant
15:45:51 <yairchu> kind of. + there will also be fog-of-war
15:46:07 <benmachine> yairchu: pretty, but my mouse input lags a bit
15:46:16 <benmachine> if I move around suddenly the cursor takes a whil to catch up
15:46:56 <yairchu> benmachine: probably a bug of mine. or is it like that in other stuff in your comp as well?
15:47:24 <benmachine> yairchu: I've seen it once before, in a SDL program that I wrote for myself
15:47:30 <dons> tommd: what's the '  if flag(small_base)
15:47:30 <benmachine> I can't remember how I fixed it
15:47:30 <dons>     Build-Depends: base == 4.*, stm, concurrent, BoundedChan >= 1.0.0.2
15:47:31 <dons> '
15:47:36 <benmachine> or more accurately, if I fixed it
15:47:37 <dons> tommd: the 'concurrent' library?
15:48:00 <dons> containers? parallel? (Control.Concurrent is in base.)
15:48:53 <benmachine> I think it's just a case of mousemove events being generated more quickly than they are consumed
15:50:11 <benmachine> I could be imagining it, but I think the effect lessened when I stopped underclocking my CPU
15:50:25 <yairchu> why are you underclocking it?
15:50:40 <benmachine> because it extends my battery life and generates less CPU
15:50:50 <benmachine> er
15:50:52 <benmachine> generates less heat
15:50:59 <yairchu> does it make a big difference?
15:51:04 <benmachine> erm
15:51:11 <benmachine> not huge, but definitely noticeable
15:51:22 <yairchu> maybe I should try it sometime
15:51:25 <Vulpyne> A lot of modern CPUs can underclock automatically in low load conditions.
15:51:31 <benmachine> it was much easier that I expected it to be
15:51:45 <SamB> speedstep, is that called ?
15:51:53 <Vulpyne> Yeah, I think that's the Intel flavor.
15:52:22 <SamB> yeah, dynamic CPU underclocking is definately a good idea for laptops ;-)
15:53:02 <mercury^> It's a good idea for any computer.
15:55:03 <Vulpyne> There may be couple of examples where it's not so good, I recall that it used to cause FPS problems in some games. I don't know if that is still the case.
15:55:58 * RayNbow underclocks the CPU of the laptop he's now using because of heat issues
15:56:09 <RayNbow> or actually, cooling issues :p
15:56:30 <yairchu> unless you actually want it to heat
15:56:53 <Berengal> shapr: Yes
15:56:58 <benmachine> my sensors report something at being 70.5 degrees celsius
15:56:59 <RayNbow> running at 100% CPU at the highest frequency will cause the temperature rise and imminent shut down
15:57:05 <benmachine> temp7 is 70.5
15:57:13 <benmachine> I've not idea what temp7 is, though
15:57:16 <benmachine> *no
15:58:03 <benmachine> I wrote a script to write to the /proc files that controlled my fan
15:58:19 <benmachine> for when I thought it wasn't cooling as hard as it should be
15:58:22 * RayNbow guesses his laptop's full of dust and therefore the cooling fan cannot operate effectively
15:58:41 <Botje> don't guess, open it up :)
15:59:04 <benmachine> im in ur laptop, voidin ur warrantiez
15:59:22 <Badger> lololol
15:59:29 <Badger> sorry
15:59:32 <Badger> I just couldn't not
15:59:41 <benmachine> heh
15:59:45 <RayNbow> Botje: I have never opened up a laptop before :p
15:59:59 <benmachine> I'm considering opening mine
16:00:01 <Botje> all you need is a screwdriver :)
16:00:09 <Botje> and odds are good there's a howto guide on the internet
16:00:15 <RayNbow> Botje: there is
16:00:41 <Vulpyne> It's like self trepanation. Risky, messy, and you'll probably screw up something critical. :)
16:00:54 <Botje> hardly
16:01:14 <Botje> removing 5 cm³ of dust made a laptop run at 40° idle instead of 60°
16:01:17 <Botje> well worth it, imo
16:01:17 <Berengal> Meh, just turn it upside down, open it up, poke some glowy bits and see if it burns a marshmallow
16:01:30 <FunctorSalad> just wish I could hunt down whatever is causing brief disk accesses several times per minute on my laptop
16:02:04 <RayNbow> http://www.irisvista.com/tech/laptops/Toshiba-Tecra-S3/disassembly-instructions.htm <-- too many parts :p
16:02:34 <Vulpyne> Firefox?
16:02:36 <RayNbow> the only thing I ever removed from this laptop was the hard disk :p
16:02:48 <RayNbow> (for backup purposes)
16:03:06 <FunctorSalad> (I think it's mostly kjournald, but why does it need to journal all the time if nothing has changed on the HD?)
16:03:21 <ray> failfox causes brief cache misses several times per second :P
16:03:31 <FunctorSalad> hehe failfox
16:03:48 <RayNbow> :t fail "fox"
16:03:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
16:04:22 <FunctorSalad> ray: even when idling? :(
16:04:32 <ray> especially when idling
16:04:33 <FunctorSalad> or is there no such thing as an idle ff? ;)
16:04:50 <Vulpyne> I heart Opera.
16:05:00 <RayNbow> there is no such thing as idling on most systems
16:05:09 <pstickne> FunctorSalad:  there is ... 6% CPU :-)
16:05:13 <FunctorSalad> hehehe
16:05:35 * RayNbow wonders what his CPU usage was on his netbook running Arch, X, xmonad and xmobar...
16:05:49 <RayNbow> (I'm too lazy to check it right now :p)
16:06:37 <ray> cpu usage likes to drop as soon as you glance at it anyway
16:07:08 <benmachine> ray: there is such a thing as idling
16:07:19 <benmachine> you can idle at 100% cpu
16:07:28 <benmachine> it just means you're not doing anything *useful*
16:07:35 <ray> i am not the same person
16:07:47 <ray> that guy just added my distinctiveness to his own
16:07:53 <RayNbow> too many *ray*s in this channel :p
16:08:15 <ray> cosmicray, raynes
16:08:21 <benmachine> ray: sorry, I'm not used to typing more than three characters of people's names
16:08:28 * benmachine hugs his tab key
16:08:41 * ray ghcis his tab key
16:09:26 * RayNbow just thought of djinn-like tab-completion...
16:10:21 <ray> @djinn that guy who was talking about zygohistomorphic prepromorphisms earlier
16:10:22 <lambdabot> -- f cannot be realized.
16:10:56 <RayNbow> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms ?
16:11:32 <RayNbow> I still manage to misread Cofree as Coffee everytime I see it :p
16:12:05 <FunctorSalad> co:Free
16:12:53 <mmorrow_> @pl \www org -> www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
16:12:54 <lambdabot> flip flip Zygohistomorphic_prepromorphisms . ((/) .) . flip flip haskellwiki . ((/) .) . (. (haskell .)) . (.)
16:13:22 <benmachine> hah
16:13:54 <FunctorSalad>  "zygohistomorphic prepromorphism" doesn't sound like a term theorists would really use
16:14:08 <FunctorSalad> most important concepts get short names
16:14:34 <FunctorSalad> it's just FUD :p
16:15:49 <yairchu> you lost me at zygo
16:16:05 <yairchu> :)
16:16:37 <FunctorSalad> zygote \zy"gote\ (z[imac]"g[=o]t), n.
16:16:37 <FunctorSalad>      The cell resulting from the union of an ovum and a
16:16:37 <FunctorSalad>      spermatozoon, or (broadly) the developing new organism
16:16:37 <FunctorSalad>      arising from such a cell.
16:16:49 <Vulpyne> Zalgo!
16:16:53 <FunctorSalad> that's what I associate it with anyway
16:17:00 <FunctorSalad> maybe there's some other etymology
16:17:53 <Saizan> FunctorSalad: it's compound, zygo histo and prepro are all "used" prefixes
16:18:07 <FunctorSalad> Saizan: I meant just the zygo part
16:18:15 <RyanT50001> what's the easiest way to do HTML/XML templating in Haskell?
16:18:22 <RyanT50001> (i mostly just want to fill in fields)
16:19:17 <Saizan> RyanT50001: HStringTemplate or HSP
16:19:28 <RyanT50001> Saizan: cool, thanks
16:37:43 <RyanT50001> has anyone built the latest hsp-cgi from hackage?
16:38:03 <RyanT50001> i'm getting an error:
16:38:03 <RyanT50001> src/HSP/CGI/RunCGI.hs:24:14:
16:38:03 <RyanT50001>     Couldn't match expected type `Maybe XMLMetaData'
16:38:03 <RyanT50001>            against inferred type `HSP XML'
16:45:20 <Berengal> RyanT50001: I have, and I got that error as well. I had to fix the source
16:45:45 <RyanT50001> Berengal: do you have a patch handy?
16:46:36 <Berengal> RyanT50001: line 24: runHSP Nothing page (HSPEnv req gen) >>= return · cgiResponse · renderXML · snd
16:46:45 <RyanT50001> thanks
16:47:21 <Saizan> Berengal: did you mail the maintainers?
16:47:42 <Berengal> Saizan: No. I should've, but I'm lazy like that :(
16:48:10 <Berengal> RyanT50001: Seems you got some candy as well. The · should obviously be .
16:48:38 <RyanT50001> Berengal: right
16:54:31 <Plouj> hi
16:55:10 <Plouj> I'm importing System.IO (openFile, hPutStr, hClose) and I'm trying to figure out what else I need to import to be able to use WriteMode value to pass to openFile
16:55:41 <benmachine> Plouj: probably something like FileMode (WriteMode)
16:55:45 <benmachine> @type openFile
16:55:46 <lambdabot> Not in scope: `openFile'
16:55:51 <benmachine> oh ofc
16:56:03 <benmachine> @type System.IO.openFile
16:56:04 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
16:56:10 <benmachine> oh it's IOMode
16:56:32 <benmachine> Plouj: you can import data types too, and you put the constructors you want in brackets after them
16:56:53 <benmachine> like I have import System.IO(BufferMode (NoBuffering))
16:57:00 <benmachine> you can also do (..) I think for all constructors
16:57:06 <Plouj> benmachine: brackets around them?
16:57:12 <benmachine> Plouj: aroudn the constructors, yeah
16:57:20 <Plouj> so, (IOMode)?
16:57:41 <Plouj> I get a parse error
16:57:43 <shapr> Does test-framework work on Windows?
16:57:57 <Plouj> ort System.IO (openFile, hPutStrLn, hClose, (IOMode))
16:58:06 <Tigran> Plouj: import (IOMode (..))
16:58:08 <Plouj> oh
16:58:10 <Plouj> I see
16:58:43 <benmachine> yeah, IOMode is the type, WriteMode is a type constructor
16:58:50 <Plouj> yup
16:58:52 <Plouj> thanks
16:59:34 <Plouj> I'm actually learning more Haskell now that I stopped wasting time on working out every single excercize in Real World Haskell
17:00:12 <rovar> anyone able to cabal install leksah?
17:00:36 <rovar> i get a lot of "no available version" blah
17:00:54 <Saizan> benmachine: s/type constructor/data constructor/
17:01:06 <benmachine> Saizan: oh, k
17:01:09 <benmachine> oh yes of course
17:01:17 <benmachine> fair enough
17:02:03 <hamishmack> rovar: have you installed gtk2hs?
17:02:24 <rovar> hamishmack: is it not cabal installable?
17:02:41 <rovar> it would seem not
17:02:42 <hamishmack> sadly not yet
17:02:43 <shapr> The test-framework default runner complains on windows: *** Exception: getConsoleCursorInfo: invalid argument (The handle is invalid.)
17:02:54 <shapr> Any ideas what's wrong? I'm guessing Windows is the problem?
17:02:59 <RyanT50001> is there a way to create IOExceptions in the new system?
17:03:16 <hamishmack> make sure you have gtksourcview2 > 2.4 before you build gtk2hs
17:09:08 <rovar> wow. gtk2hs is big
17:09:19 <rovar> i guess that would make sense
17:10:58 <Cale> RyanT50001: no, but the idea is that you can create new exceptions of any type you like and throw those instead.
17:11:21 <RyanT50001> Cale: yeah, i'm just trying to figure out how to fix some old code (which isn't mine)
17:11:53 <Cale> oh, there's still mkIOError though
17:11:56 <Cale> in System.IO.Error
17:12:02 <RyanT50001> ah, ok; thanks
17:12:05 <Cale> :t System.IO.Error.mkIOError
17:12:06 <lambdabot> GHC.IOBase.IOErrorType -> String -> Maybe GHC.IOBase.Handle -> Maybe FilePath -> IOError
17:19:16 <rovar> on the + side, the build parallelizes quite well
17:19:33 <mmmulani> dammit, digits num = length (show num) is faster than using a logBase
17:19:50 <rovar> hahaha
17:20:10 <rovar> that uses regular lists too
17:20:13 <rovar> not bad
17:20:33 <rovar> i wonder if there is a point where it would be cheaper to use log
17:20:41 <benmachine> mmmulani: did you try with really big numbers?
17:20:53 <mmmulani> I used sum (map digits [1..100000]) to test
17:20:58 <benmachine> hmm
17:21:10 <benmachine> try again with [10^19..10^20] :P
17:21:27 <benmachine> actually that might take a ridiculous amount fo time
17:21:27 <mmmulani> ahah will try now
17:21:28 <benmachine> of
17:21:35 <mmmulani> hmm
17:21:41 <benmachine> but you know
17:21:45 <benmachine> take 100000 $
17:21:51 <rovar> :)
17:21:52 <benmachine> or something
17:22:04 <mmmulani> I'm trying 10^10 .. 10^11
17:23:07 <rovar> mmmulani: couldn't you just make a quick modification of the num to string algorithm to simply count iterations?
17:23:11 <mmmulani> it's been over a minute
17:23:26 <mmmulani> rovar: iterations of what?
17:23:58 <benmachine> mmmulani: well, it's got to convert the number digit by digit
17:24:16 <mmmulani> that's what I figure
17:24:31 <mmmulani> it would make sense to use an unfoldr, but I don't know how it's actualyl implemented
17:25:30 <rovar> a simple tail recursive algorithm that divides by 10 and  stores both an incremented counter and the remaining number
17:25:44 <rovar> then you're not making a list or using log
17:25:56 <mmmulani> hmm the show mention seems to be twice as fast
17:26:07 <benmachine> digits n = length . takeWhile (<n) $ iterate (*10) 1
17:26:08 <rovar> tail recursive function, i mean
17:26:21 <benmachine> ^'s what I would do personally
17:26:27 <mmmulani> I'm doing sum (take 10000000 (map digits [(10^10)..(10^11)]))
17:26:36 <rovar> that makes a list as well though
17:26:37 <Cale> There's no real harm in making a list.
17:26:39 <mmmulani> benmachine: ouuu interesting
17:27:00 <rovar> you're probably right. i suppose i should stop thinking like an asm coder
17:27:01 <mmmulani> you could actually make a log(n) algorithm for this to
17:27:08 <mmmulani> (where n is the number of digits)
17:27:11 <Cale> It's not as if that list will consume space, since each cons becomes garbage immediately after it is constructed
17:27:34 <Cale> (and GHC's GC is really good at dealing with short-lived values)
17:27:35 <benmachine> mmmulani: yeah but if your input's not massive it might not be worth the trouble
17:27:54 <SamB> yeah, garbage that short-lived will be essentially no trouble
17:27:59 <mmmulani> benmachine: ahah of course, it's kind of funny that we're looking at digits algorithms
17:28:13 <SamB> assuming you don't also generate a bunch of non-garbage heap values at the same time
17:28:17 <rovar> hen starting up leksah, does the dir xxx mean HOME ? or does it really mean xxx
17:28:27 <mmmulani> benmachine: also, you'll want to use (<= n) for when n = 10,100,100,etc
17:28:53 <benmachine> erm
17:29:02 <benmachine> yes that sounds about right
17:29:08 <mmmulani> benmachine: also, that was faster than the show method :P
17:29:14 <benmachine> \o/
17:32:43 <RyanT50001> how do i enable the HSP syntax extensions?
17:35:02 <Lemmih> RyanT50001: You use the trhsx preprocessor.
17:35:17 <RyanT50001> Lemmih: so is there any convenient way to run hsp files from the command line?
17:35:29 <thoughtpolice> you can give ghc an OPTIONS_GHC pragma
17:35:37 <thoughtpolice> that will run whatever you wish like trhsx etc.
17:35:37 <RyanT50001> thoughtpolice: ah
17:35:50 <RyanT50001> i was looking at LANGUAGE pragmas
17:35:52 <thoughtpolice> (well, you give it an option to control pre-processors, that is.)
17:36:27 <thoughtpolice> RyanT50001: something like {-# OPTIONS_GHC -F -pgmF trhsx #-} I think
17:36:41 <RyanT50001> ok, i'll try that; thanks
17:37:05 <rovar> damn you, gtk vs kde paste-buffer incompatibilities!
17:37:29 <Vanadium> So if Foo# is generally an unboxed Foo and (# , #) is an unboxed tuple, does that make {-# #-} an unboxed comment?
17:37:39 <Cale> ehehe
17:38:19 <Cale> {-# ... #-} is a compiler pragma
17:38:19 <rovar> Vanadium: yes. It requires no unboxing at runtime.
17:38:39 <Cale> Hmm, that makes me think that there ought to be a standard pragma for applying a preprocessor. That seems like something reasonable to semi-standardise, like LANGUAGE
17:39:32 <rovar> yes, so one could use python for metaprogramming instead of TH, if one so desired.
17:45:58 <rovar> http://www.flynnlives.com/media/video/0xendgame.aspx
17:46:16 <heatsink> Yay!
17:46:30 * heatsink found a bug in GHC
17:46:33 <rovar> !
17:47:54 <sclv> yay??
17:49:40 <pragma_> heatsink: Congratulations!  This is a joyuous occasion!
17:49:44 <heatsink> The fact that it hasn't been fixed yet means that I'm in new terroitory.
17:49:50 <heatsink> *territory
17:50:15 <benmachine> heatsink: either that, or everyone who has beaten you to this territory was lazy :P
17:50:23 <heatsink> heh
17:50:37 <pragma_> Or it is not a bug.
17:50:51 <heatsink> Plus there's this satisfaction of being able to figure out a problem and reduce it to a test case.
17:50:56 <pragma_> In which case, we are all devasated.
17:53:29 <Heffalump> what's the bug?
17:54:00 <SamB> heatsink: what does GHC say when you tickle it?
17:54:09 <heatsink> It appears that when type-checking record updates, GHC checks the first constructor that has all the fields being updated.
17:54:35 <SamB> ?
17:54:42 <heatsink> So you can write a type-changing record update, but fail to update all fields
17:54:55 <heatsink> Thereby casting a value to a different type, which will later crash the program.
17:55:00 <Heffalump> ick!
17:55:25 <SamB> there are far worse GHC bugs, I think
17:55:38 <Heffalump> really? This is a segfault in H98.
17:55:56 <Heffalump> I'd call that pretty bad.
17:55:57 <SamB> oh, that's an H98 feature?
17:56:07 <SamB> Well, at least it's just a failure to reject!
17:56:09 <Heffalump> well, record update is
17:56:24 <Heffalump> but that's precisely what the value of the type system is
17:56:28 <SamB> I mean, correct code is unaffected
17:56:46 <SamB> it's not inferring the wrong type for a type-correct program or anything ...
17:57:09 <SamB> I guess what I mean is that it should be pretty easy to fix
17:57:15 <SamB> and to work around
17:57:22 <Heffalump> yeah, ok
17:57:25 <heatsink> Well, that's true.
17:57:34 <SamB> and the workaround requires no nastiness in your code
17:57:34 <pragma_> Nonsense.  What you meant was, "If the user ain't using it right, then it serves 'em right!"
17:57:38 <SamB> doesn't make it ugly
18:00:19 <Saizan> heatsink: can you paste the code?
18:00:24 <heatsink> Sure
18:00:45 <heatsink> @hpaste
18:00:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:02:15 <heatsink> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=3089
18:03:23 <heatsink> I have 6.10.3.  Does the bug happen in 6.10.4?
18:05:04 <benmachine> oh hey there is a 6.10.4
18:05:05 * benmachine upgrades
18:05:36 <Igloo> heatsink: HEAD rejects it:
18:05:39 <Igloo>     Couldn't match expected type `[String]'
18:05:39 <Igloo>            against inferred type `Either String String'
18:06:11 <heatsink> ah, good.
18:06:16 <heatsink> No bug report then.
18:07:40 <heatsink> That's too bad.  I liked my fish puns.
18:07:41 <byorgey> benmachine: there's not much difference.
18:07:45 * jmcarthur feels encouraged to upgrade now
18:07:55 <byorgey> probably not worth it unless one of the particular bugs that was fixed was biting you.
18:08:36 <benmachine> byorgey: but now when I do ghc --version I can feel imperceptibly more smug
18:08:51 <monochrom> I am still at 6.8.2 haha.
18:08:55 <jmcarthur> ew
18:08:57 <jmcarthur> :P
18:08:59 <byorgey> whatever floats your boat, I guess =)
18:24:43 <JamesSanders> I have a State monad that carries around a record type (I guess thats what you would call it),  any way I want to update my State but I don't want to have to build a brand new record everytime, I just want to change a single  element.
18:25:11 <JamesSanders> guess I am thinking of something like struct in C
18:25:52 <heatsink> You can use record update syntax
18:26:04 <heatsink> do modify (\s -> s { myField = myField s + 1})
18:26:09 <bd_> modify $ \s -> s { FieldToChange = newValue }
18:26:12 <bd_> oh, too late
18:26:26 <heatsink> That modifies 'myFIeld' and leaves other fields the same.
18:26:47 <SamB> heatsink: it really seems like there ought to be a way to say that that builds up from (+ 1) :-(
18:27:02 <JamesSanders> ah nice, thanks
18:27:15 <Axman6> JamesSanders: being a functional language, you're going to end up making a copy every time you change it anyway
18:27:33 <Axman6> (the compiler may be smart enough to not do that though)
18:27:58 <SamB> at least, if it notices you're about to change something else too, it might consolidate the copies etc. ;-)
18:27:58 <monochrom> So <$> is fmap. That is good news. It means there is less to learn about Applicative. :)
18:28:08 <JamesSanders> Axman6: I realize that but I don't want to have to capture all the parts of the record just to update one part
18:28:41 <Axman6> ah, well then yes. that's exactly what record syntax is for
18:28:50 <JamesSanders> cool
18:29:09 <heatsink> SamB: it would be nice to have automatically generated field mutators
18:29:26 <SamB> I guess that's a job for derive ?
18:29:32 <JamesSanders> is there any other struct like date structure that works well in haskell?
18:29:42 <jmcarthur> heatsink: check out data-accessor
18:29:43 <SamB> what should they do when given a constructor without that field?
18:29:44 <SamB> nothing?
18:29:58 <FunctorSalad> Axman6: are you sure record update syntax has anything to do with performance?
18:30:08 <jmcarthur> heatsink: there is also a package that provides some templates to derive things, and some other convenience packages as well
18:30:28 <SamB> FunctorSalad: it doesn't!
18:30:33 <FunctorSalad> JamesSanders: building a new record with just one field changed wouldn't deep copy the thing; the unchanged fields would point to the old data
18:30:35 <Axman6> FunctorSalad: it's just sugar for deconctructing the old value and creating a new one no?
18:30:52 <SamB> FunctorSalad: that's not more efficient!
18:31:01 <SamB> well, oh, wait
18:31:02 <SamB> yes it is
18:31:17 <Axman6> JamesSanders: there's only data, type, and newtype objects in haskell
18:31:17 <monochrom> It is just second to mutation.
18:31:21 <FunctorSalad> more efficient than what?
18:31:26 <SamB> but the only way to go strictness-wise anyway
18:31:31 <Cale> JamesSanders: date structure?
18:31:53 <JamesSanders> er I meant data Cale
18:31:56 <Cale> ah
18:32:03 <monochrom> date Sweetie = ...
18:32:06 <Cale> JamesSanders: Just data, really.
18:32:38 <JamesSanders> data structure
18:33:12 <Cale> data is our replacement for C's struct
18:33:32 <heatsink> jmcarthur, that looks handy.
18:33:32 <Cale> (as well as being a tagged union, and allowing recursion, and type parameters)
18:33:56 <JamesSanders> Cale that is what I figured
18:34:14 <pikhq> (and being implicitly unmutable. :P)
18:34:26 <monochrom> date Blind = forall a. BlindDate (a -> Name) (a -> Gender) (a -> Where) (a -> When)
18:34:31 <Cale> Well, if you want mutability, you store IORefs or something :)
18:34:36 <pikhq> :)
18:34:44 <JamesSanders> is record syntax accepted as a good thing then?
18:35:00 <FunctorSalad> do you still get the overhead of copying n pointers when modifying one field of a record with n fields? or is that somehow optimised away too
18:35:06 <jmcarthur> JamesSanders: it has its problems, but is quite handy
18:35:21 <Cale> It's good when there's any expectation that in the future, there might be a different number of fields, or if there are more than just a few fields.
18:36:03 <Cale> It's also surprisingly handy in the case of there being just one field (you get the "unwrapper" function for free)
18:36:24 <Cale> I wouldn't use it for something like a binary tree datatype
18:36:31 <JamesSanders> a common worry I have is creating types and then changing them later, then having to go back and change all the functions I wrote that references them.
18:36:51 <Cale> JamesSanders: Indeed.
18:37:07 <FunctorSalad> JamesSanders: you don't have to work with the type directly... you could just make an abstract interface
18:37:39 <monochrom> I worry that I create an abstract interface and then have to change it.
18:37:41 <Cale> It's worth noting that it's possible to do the OO thing, and instead of a record of values, store a record of operations which are going to implicitly act on some values.
18:37:48 <JamesSanders> FunctorSalad: I guess that is kinda what record sytax does
18:37:58 <Cale> But then you have the dual worry about wanting more operations later.
18:38:40 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell -- something you may find interesting
18:38:45 <JamesSanders> Cale: example?
18:38:49 <JamesSanders> oh
18:39:43 <monochrom> In fact, my blind date is an example :)
18:40:00 * monochrom loves how his answers predate all the questions.
18:40:12 <Cale> of course, since the a always appears in parameter position there, you might as well discard it
18:40:38 <Rotaerk> Cale, doesn't load
18:40:43 <Cale> Rotaerk: oh...
18:40:43 <JamesSanders> I recently read this http://homepages.cwi.nl/~ralf/OOHaskell/
18:40:59 <Cale> JamesSanders: What I'm suggesting is *way* less fancy than that.
18:41:07 <monochrom> <monochrom> So, <$> is fmap, that's easy.  <asker> Hi I'm looking at Applicative, what is <$> in functor terms?
18:41:11 <Cale> JamesSanders: Just an often-overlooked simple approach
18:41:33 <Rotaerk> typeclasses provide all you need for OO
18:41:34 <JamesSanders> Cale: that is good because that paper seemed a little more work then I was hoping for
18:41:52 <Cale> Rotaerk: in fact, you hardly even need typeclasses
18:42:24 <Rotaerk> OO is basically just ... a fixed set of operations that can be implemented by an arbitrary number of data models
18:42:32 <Rotaerk> and that's precisely what typeclasses do
18:42:36 <Cale> hmm, the usual suspects for why my page wouldn't load aren't the issue.
18:42:45 <monochrom> oooo... you forgot inheritance
18:42:49 <Cale> my torrent finished a while back
18:42:55 <JamesSanders> Cale: loads for me
18:43:01 <Rotaerk> monochrom, that's what inheritance is for: implementing operations in terms of new data models
18:43:02 <Cale> monochrom: I am explcitly disregarding inheritance, yeah.
18:43:04 <FunctorSalad> monochrom: isn't your blind date missing an actual "a"?
18:43:21 <monochrom> subtyping
18:43:22 <Cale> Because I don't really think that inheritance is central to OO.
18:43:32 <Cale> (perhaps controversially)
18:43:47 <monochrom> It is a blind date, so the "a" is kept existential. :)
18:43:50 <JamesSanders> inheritance is often considered a bad thing in OO
18:44:01 <JamesSanders> depends on who you talk to though
18:44:15 <Rotaerk> inheritance is a mechanism through which you can implement an interface
18:44:17 <Cale> monochrom: The existential would be more interesting if there were at least one operation which had the a as a result type.
18:44:21 <FunctorSalad> *naive question* what's all the talk about extensible records about? why not just use the "has-a" way?
18:44:25 <Rotaerk> but it's hardly necessary
18:44:32 <jmcarthur> Cale: i'm quite vocal about that in some circles. i don't think inheritance is important to OO at all
18:44:32 <monochrom> Yeah, blind date is boring.
18:44:36 <Cale> monochrom: As it is, you'll never be able to apply those functions to anything but undefined.
18:44:50 <FunctorSalad> monochrom: I realise it's existential, but it doesn't contain an "a" to plug into the accessors in that record
18:45:09 <Rotaerk> the opposite of OO is pattern matching on discriminated unions
18:45:10 <oklopol> Rotaerk: they are also used for subtyping, for instance extending that interface
18:45:11 <monochrom> Ah, I see now.
18:45:25 <monochrom> date Blind = forall a. BlindDate a (a -> Name) (a -> Gender) (a -> Where) (a -> When)
18:45:29 <Cale> The nice thing about my little approach to OO there is that it automatically reduces to a normal algebraic approach when that would be more appropriate.
18:45:36 <Rotaerk> hmm, can type classes be implemented by other type classes?
18:45:59 <Cale> That is, if the only operations you need are ones which extract certain bits of information, it reduces to recording those bits of information (lazy evaluation being important here)
18:46:08 <Rotaerk> although really, the extensibility of the set of operations is another issue that OO doesn't address well anyway
18:46:48 <Cale> monochrom: That is isomorphic to data Blind = BlindDate Name Gender Where When -- often the existential is superfluous :)
18:46:50 <Rotaerk> while it might seem that inheritance lets you do interface extension, it's pretty broken
18:47:00 <FunctorSalad> date HaHaNoDateForYou = forall a b. BlindDate b (a -> Name) (a -> Gender) (a -> Where) (a -> When)
18:47:06 <monochrom> Blind dates are superfluous.
18:47:34 <Rotaerk> your mom's superfluous?
18:47:35 <Rotaerk> *cough*
18:47:43 <Axman6> o sap
18:47:47 <Axman6> snap too
18:47:55 <Cale> I've been thinking a bit about what the natural catamorphism on an "object" type like this would do.
18:48:09 <Cale> It seems like it might be closely related to how you'd extend the interface.
18:49:07 <Cale> You'd use the catamorphism to define exactly how to restructure one sort of object as another.
18:50:23 <heatsink> Why is the object containing methods called coalgebraic?
18:50:33 <Rotaerk> a few weeks ago I was thinking about the expression problem and came up with a language mechanism that solves it and is more powerful than type-classes as I understand them
18:50:53 <Rotaerk> they're like type-classes that can have their operation set extended just as easily
18:51:27 <Axman6> hey is the 8 queens problem supposed to be hard to do by hand?
18:51:43 <monochrom> Yeah.
18:51:46 <jcreigh> Rotaerk: hmm. I would be wary of declaring victory until it's been implemented. there may be some subltety lurking unthought-of...
18:51:51 <monochrom> It's easy to do by brain. :)
18:51:57 <Axman6> heh
18:51:58 <Rotaerk> yea
18:52:17 <Axman6> i wasn't thinking particularly hard, and did it on my 4th attempt :\
18:52:26 <monochrom> I haven't done it myself. I have written a program to do it for me.
18:53:03 <Rotaerk> well, it at least makes sense to me conceptually... I might try to implement it one of these days
18:53:25 <monochrom> Then again, Haskell is supposed to be hard too.
18:55:02 <Rotaerk> did I already explain the mechanism in here?
18:55:04 <Rotaerk> can't remember
18:57:54 <Cale> I wonder what the probability is that if you just make random valid decisions in trying to solve the n-queens problem that you won't hit a dead end.
18:58:57 <benmachine> what do you mean by decisions?
18:59:11 <Cale> benmachine: place queens in positions where they are not attacked
18:59:20 <monochrom> 1/8!
18:59:20 <benmachine> ah
18:59:35 <monochrom> I mean 1 - 1/8!
19:00:00 <benmachine> haha, for a moment I thought that you were just excited about the fact that it was 1/8
19:00:02 <Cale> monochrom: hmm
19:00:14 <monochrom> Not 1 - 1/8!. It answers a different question.
19:00:45 <monochrom> Yeah, I was excited about 1 - 1/8 instead. :)
19:01:10 <benmachine> wait now I am confused
19:01:16 <benmachine> well, never mind
19:01:36 <monochrom> I'm joking :)
19:03:01 <Cale> Yeah, I think it's considerably worse than (1 - 1/8!) ;)
19:03:35 <benmachine> is the n-queens fitting n queens onto an nxn board?
19:03:41 <Axman6> yeah
19:03:57 <benmachine> not solvable for n = 2 or n = 3?
19:04:03 <Axman6> yep
19:04:05 <saml> how does ghci's tab completion work?
19:04:09 <benmachine> is there an upper bound on n for it to be solvable?
19:04:16 <saml> how does it get possible functions?
19:04:33 <Axman6> saml: it'd just match on all function in scope i guess
19:04:36 <FunctorSalad> and why doesn't haskell-mode use it? :(
19:04:57 <saml> how can I get all the functions in scope?
19:05:07 <Axman6> it tab twice i think
19:05:08 <Cale> It matches on all names in scope
19:05:10 <Axman6> hit*
19:05:30 <Cale> (Including things like class names)
19:05:59 <saml> i mean, is there a module that provides such functionality or should i dig sourcecode of ghci?
19:06:29 <Cale> Maybe using the GHC API, but yeah, look at GHCi's sourcecode.
19:06:38 <saml> alright thanks
19:07:52 <Cale> It's not something that you can normally do. Compilation can be expected to destroy information such as what names are in scope. (Apart from exported things)
19:08:21 <FunctorSalad> haskell mode already loads your modules into ghci though
19:08:29 <FunctorSalad> so it would seem to be easy to add
19:09:00 <FunctorSalad> maybe add a ":complete" cmd to ghci?
19:09:39 <monochrom> bos is 31337 :)
19:09:31 <saml> i just want a simple ghci wrapper for windows that has tab completion
19:10:53 <thoughtpolice> saml: ghc since ghc-6.10.3 uses haskeline
19:11:04 <thoughtpolice> saml: which is like readline, but it works on windows/linux and is written in haskell
19:11:24 <saml> oh crap i didn't even tried to press Tab on windows
19:11:26 <saml> it works!
19:11:31 <saml> thanks
19:11:32 <Cale> hehe ;)
19:11:33 <thoughtpolice> saml: haskeline offers tab completion etc. on windows too - this is why GHC HQ decided to use it, because it's much better than readline and is more portable
19:11:41 <thoughtpolice> saml: yay :)
19:12:28 <monochrom> You just worried that pressing a wrong key would burn out some chips.
19:13:03 <monochrom> But I like burned out chips. They are tasty.
19:13:49 <monochrom> I like charcoaled meat and charcoaled chips and charcoaled vegetables.
19:14:21 <monochrom> And newbies.
19:21:15 <JamesSanders> weird to use 'put' in a StateT I had to use return
19:21:19 <JamesSanders> hm
19:21:50 <\}> dibblego
19:26:55 <Saizan> JamesSanders: mmh, there's something wrong there
19:29:44 <JamesSanders> Saizan: ah yeah I just realized I had a syntax error
19:30:24 <\}> dibblego
19:31:10 <dibblego> moss
19:31:29 <\}> dibblego
19:31:34 <\}> why are you not on #java
19:31:56 <dibblego> because the ROI is unviable
19:32:03 <Cale> ehehe
19:32:11 <\}> ROI?
19:32:12 <ben_w_> anybody know how to get vi mode in ghci like you could before with readline?
19:32:23 <dibblego> Return (education) on Investment (my effort)
19:32:40 <\}> you dont give up on us you hear
19:33:10 <dibblego> you can learn on your own initiative -- I've done enough hand holding
19:33:21 <Cale> ben_w_: I'm not sure that haskeline has a vi mode (yet)
19:33:43 <Saizan> ben_w_: http://trac.haskell.org/haskeline/wiki/UserPrefs
19:33:46 * Cale looks into it
19:34:00 <\}> we need hand holding
19:34:04 <\}> we need it
19:34:16 <\}> lets all join hands
19:34:30 * oklopol joins
19:34:45 <\}> kumbayaaaa my lord
19:34:49 <\}> kumbayaaaa
19:34:55 <\}> kumbayaaa my lord
19:35:02 <\}> kumbayaaa
19:35:04 <Cale> \}: *cough*
19:35:07 --- mode: ChanServ set +o monochrom
19:35:11 <monochrom> Please stop?
19:35:11 <ben_w_> Saizan: ah! thanks
19:35:12 <oklopol> bye
19:35:30 <Cale> oklopol: hello, er, bye?
19:35:37 <\}> oh no a cop, i said kumbaya and now im at risk of being banned
19:35:38 <dibblego> \}, I might remind you that this channel is not like #java with ~600 people who are unwilling to listen to noise
19:35:55 <oklopol> Cale: oh i just thought \} would be kicked.
19:36:01 <Cale> oklopol: ah
19:36:17 <\}> nobody in here has a sense of humor
19:36:22 <\}> definitely not my kind of people
19:36:23 <Cale> \}: yeah, it would be good if you could try to stay on Haskell-related topics here.
19:36:34 <dibblego> \}, we'd love to hear your funnies in #haskell-blah
19:36:41 <\}> no its ok
19:36:41 <oklopol> \}: i enjoy flood and nonsense, dunno about sense of humor.
19:36:44 <Cale> Humour is okay, but try to be more amusing than annoying. ;)
19:36:44 <\}> its not worth it
19:37:22 --- mode: monochrom set -o monochrom
19:39:19 <pikhq> Nice trollness.
19:44:50 <matsuura> Why are there so many trolls today?
19:45:14 <matsuura> it's like, almost every channel on freenode is full of trolls
19:51:02 <ray> please don't use the t-word!
19:51:25 <monochrom> types types types
19:51:48 <vav>   @. trolls users ~~> "median 2.86 % per day"
19:51:50 <ray> if you must insult someone, call them weakly typed or something
19:51:56 <ray> don't use the t-word
19:52:20 <matsuura> what, troll?
19:52:33 <matsuura> I think people are starting to call people trolls just because they're fucking stupid
19:52:37 <matsuura> and it's really pissing me off
19:52:47 <ray> that's as good a reason as any not to use that word, isn't it?
19:52:54 <matsuura> yes
19:53:04 <inimino> "troll" has never had a particularly well-defined meaning
19:53:05 <ray> say "that guy's so weakly typed, i could use him as a value in my python script!"
19:53:07 <matsuura> however, if they are a troll, you may point out that they are a troll
19:53:13 <inimino> heh
19:53:20 <matsuura> inimino: to deliberately upset those
19:53:28 <matsuura> they usually comes with tons of memes
19:53:31 <matsuura> so, easy spot
19:53:37 <matsuura> others, they're just fucking mean
19:53:38 <matsuura> >:(
19:53:50 <matsuura> and like, persist with it
19:53:55 <inimino> matsuura: the trouble is you can't really determine some else's motives
19:54:03 <matsuura> inimino: yes you can..
19:54:06 <matsuura> what is my motive atm?
19:54:12 <glguy> Doesn't Python have strong typing?
19:54:14 <inimino> matsuura: I have no idea
19:54:21 <matsuura> To express what trolls motives are
19:54:21 <matsuura> lol
19:54:35 <monochrom> I don't care motives. I detect observable annoyance. Who cares if you "mean no harm".
19:54:49 <matsuura> That's the thing, trolls do mean harm
19:54:55 <inimino> that's a goal, not a motive
19:55:00 <matsuura> hmm
19:55:05 <matsuura> mindblown
19:55:05 <Saizan> glguy: you mean the optional type declarations on arguments?
19:55:22 <dolio> He means it's not like C.
19:55:22 <glguy> Saizan: No, I mean that strong typing has to do with coersions
19:55:51 <Saizan> glguy: python has tagging, not typing
19:56:21 <ray> i probably should have said "you're so weakly typed i could cast you to void * and back again"
19:56:51 <glguy> or even unsafeCoerce#'d
19:56:56 <ray> that sounds similar to "i could kick you into next week, and when you reached next week i'd be there to kick you back in to last week" or something too
19:57:14 <glguy> It is OK for Haskell because we used the word "unsafe", right?
19:57:51 <Saizan> it's OK only when you prove it is :)
19:59:35 <dolio> Who are these people going around unsafeCoercing all the time in Haskell?
19:59:48 <dolio> In C, if you want something as basic as polymorphism, you use unsafeCoerce.
19:59:51 * Saizan looks at mmorrow
20:00:23 <pikhq> unsafeCoerce, in my mind, is a wart that Haskell offers for some additional flexibility when you *really* want it. This is kind of like C's ability to set pointers to constants.
20:00:34 <pikhq> (only more obviously unsafe)
20:00:54 <SamB> pikhq: wait, which did you say is more obviously unsafe?
20:01:01 <pikhq> SamB: unsafeCoerce.
20:01:06 <SamB> ... is it?
20:01:08 <pikhq> It has unsafe in the name, after all. ;)
20:01:16 <pikhq> It's more obvious that it *is* unsafe.
20:01:21 <monochrom> You can use it to crash programs.
20:01:50 <chessguy> and launch missiles?
20:01:56 <pikhq> int *foo = 0xFF; // You may skip over the *.
20:01:57 <SamB> wait, what do you mean by "set pointers to constants"?
20:02:06 <monochrom> unsafeCoerce (5 :: Int) :: IO (StateT Int IO Bool)
20:02:13 <pikhq> If you miss the *, you're wondering what the hell's going on.
20:02:23 <pikhq> SamB: int *foo = 255; // Perfectly valid C.
20:02:33 <SamB> pikhq: yeah, that's what I thought
20:02:41 <SamB> well, okay, so unsafe is a bit harder to miss ...
20:02:43 <RyanT50001> does anyone know why HSP inserts linefeeds before every tag-closing greater-than sign?
20:03:11 <pikhq> Not recommended outside of writing code writing to the VGA framebuffer. ;)
20:03:16 <monochrom> It is what Haddock does too.
20:03:34 <SamB> pikhq: or even then, really
20:04:03 <Saizan> RyanT50001: i think it's so it can indent without adding whitespace to the content
20:04:13 <monochrom> I think a few people in the Haskell community liked newlines before tag-closing >'s.
20:04:23 <RyanT50001> huh
20:04:26 <RyanT50001> is it legal XML?
20:04:29 <SamB> well, I mean, some of the code has to figure out where the framebuffer is, I suppose, and on the least-capable hardware that will involve hardcoding the addresses ...
20:04:48 <SamB> monochrom: because it works for all XML, I think
20:04:51 <SamB> RyanT50001: yeah!
20:05:17 <SamB> monochrom: regardless of how whitespace is treated by the applications that process it
20:05:22 <RyanT50001> hm
20:05:27 <RyanT50001> ok, i guess that's reasonable
20:05:29 <matsuura> SamB: hey, I know you! :O
20:05:31 <RyanT50001> it's super ugly, though
20:05:51 <monochrom> Ha, Haddock puts newlines at tag-openning >'s too.
20:05:58 <SamB> matsuura: what the hell? someone from #zsnes in *here*?
20:06:05 <SamB> besides me, I mean?
20:06:12 <matsuura> hells yeah ;)
20:06:45 <chessguy> oh wow, i didn't know it had a channel, or i'd've been there too
20:07:15 <SamB> heh
20:10:31 <SamB> matsuura: it's hard to tell trolls from idiots, really
20:10:49 <SamB> the difference is mostly that trolls do it on purpose to be disruptive!
20:10:55 <monochrom> And there is no need to tell the difference.
20:11:00 <SamB> true
20:11:08 <matsuura> SamB: true
20:11:26 <matsuura> monochrom: eh, sometimes
20:11:43 <matsuura> if someone comes here and starts asking noob questions, does that make them an idiot?
20:11:46 <matsuura> or a troll...?
20:11:48 <matsuura> :(
20:11:57 <Saizan> neither, just a noob :)
20:11:58 <SamB> I guess the easiest way to tell is if you can get them to stop being disruptive by asking nicely -- though it isn't totally fool-proof, obviously ;-)
20:12:09 <monochrom> Who says noob questions are bad?
20:12:14 <SamB> no, those are fine
20:12:21 <SamB> we like noobs
20:12:26 * SamB licks lips
20:12:40 <monochrom> You are thinking like that \} character. You are thinking "oh I'm going to be banned by saying ____".
20:12:43 <matsuura> SamB: ah yes
20:12:45 <matsuura> I like this
20:12:52 <matsuura> monochrom: people in #gentoo
20:12:53 <matsuura> lol
20:12:57 <matsuura> and #ubuntu
20:13:02 <matsuura> and #archlinux
20:13:02 <matsuura> etc
20:13:10 <matsuura> SamB: o_o
20:13:13 <Saizan> @quote tropical
20:13:13 <lambdabot> No quotes match. Wrong!  You cheating scum!
20:13:28 <Saizan> @quote island
20:13:28 <benmachine> okay so Control.Exception.Finally is confusing me
20:13:29 <lambdabot> ghc says: Unable to mmap( MAP_FIXED ) for Jump Islands
20:13:32 <SamB> matsuura: kidding ;-). it's ##c where the noobs get eaten for breakfast.
20:13:36 <SamB> well, a lot of 'em
20:13:40 <FunctorSalad> SamB: three-start Trolls and above will stop being disruptive when you ask nicely and fall back to more subtle tactics, or what? ;)
20:13:43 <FunctorSalad> *three-star
20:13:44 <matsuura> SamB: oh really
20:13:45 <monochrom> It was not what he said. It was how many times he said it. Consecutively 4 times. Anyone repeating anything 4 times within 15 seconds is annoying enough to be shoved out.
20:14:01 <monochrom> Like I said it's annoyance not motive not goal.
20:14:04 <SamB> but then, there's a lot of really dumb noobs going through ##c, so it's no surprise people get a bit bitter ...
20:14:09 <matsuura> lol
20:14:23 <matsuura> like, "can you compile this exploit for me?" ?
20:14:23 <SamB> FunctorSalad: dunno!
20:14:23 <matsuura> lol
20:14:30 <monochrom> You people are so simple-minded.
20:14:41 <Saizan> benmachine: how?
20:14:42 <SamB> matsuura: I think people ask for help with exploits now and then
20:14:59 <SamB> but usually it's just "plz help me to fix this segfault without actually bothering to understand C"
20:15:07 <benmachine> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3090#a3090 <-- this prints "writing finally" almost immediately, but the loop clearly hasn't terminated
20:15:24 <SamB> or something like that
20:15:44 <Saizan> benmachine: you got the arguments flipped
20:15:45 <benmachine> wait
20:15:46 <benmachine> yeah
20:15:49 <benmachine> that makes sense :P
20:15:52 * benmachine facepalm
20:16:17 <monochrom> haha
20:16:24 <SamB> on the bright side, that saves you hours of debugging and loads of hair ;-)
20:16:27 <ray> i like it better your way, benmachine
20:16:54 <glguy> line <- (takeMVar m >>= return . makeIRCline)  --  line <- makeIRCline `fmap` takeMVar m
20:17:12 <matsuura> SamB: hmm
20:17:24 <matsuura> SamB: in that case, can you help me with this one exploit?
20:17:27 <matsuura> it wont compile
20:17:31 <matsuura> I've tried so much!
20:17:32 <benmachine> glguy: I knew there was a simpler way of doing that
20:17:39 <SamB> matsuura: seriously ?
20:17:42 <benmachine> thanks
20:17:51 <matsuura> SamB: no
20:17:52 <SamB> needz more unsafeCoerce, maybe ;-P
20:18:10 <matsuura> SamB: don't worry.. I've taken CSIII, 6 times
20:18:18 <SamB> wow
20:18:22 <SamB> that sounds really painful
20:18:26 <matsuura> na, it was epic
20:18:35 <matsuura> I got an A each time
20:18:38 <SamB> oh
20:18:42 <SamB> why did you retake it?
20:18:53 <SamB> how did you avoid dying of boredom the *first* time?
20:18:59 * benmachine wonders if it would confuse people unduly if he redefined . as fmap
20:19:03 <monochrom> What is CSIII?
20:19:13 <SamB> benmachine: we're fairly used to that happening
20:19:16 <SamB> monochrom: CS III
20:19:18 <ray> benmachine: some of us would love it
20:19:27 <glguy> It won't confuse people if your audience is a portion of #haskell
20:19:30 <glguy> but don't do it otherwise
20:19:33 <ray> there's <$> for an infix fmap if you are skittish about redefining things
20:19:34 <SamB> benmachine: Cale did it before ;-)
20:19:43 <matsuura> but no.. it was a joke
20:19:58 <SamB> but now it's back to normal
20:20:10 <SamB> matsuura: CS III x 6, or the exploit?
20:20:15 <matsuura> both
20:20:19 <benmachine> ray: I just think it's cool how it still works as it did before
20:20:29 <benmachine> and now does a bunch of other things that have sort of the same meaning
20:20:30 <matsuura> I don't know the equiv of cs III
20:20:35 <ray> yes
20:20:36 <matsuura> maybe, CS 170
20:20:38 <SamB> matsuura: the CSIII x 6 joke wasn't funny, just unbelievable
20:20:40 <ray> i think (.) should be fmap
20:21:00 <matsuura> SamB: that's okay...
20:21:07 <matsuura> SamB: I thought I could try :(
20:21:16 <ray> and fmap should be map, also
20:21:31 <SamB> but maybe that's because I live in the US and basic CS classes are extremely boring
20:21:40 <SamB> to those of us who have any background, I mean
20:21:52 <matsuura> SamB: I take it, you're not familiar with CSIII?
20:21:53 <matsuura> :(
20:22:03 <matsuura> Should probably google it
20:22:08 <SamB> also I'm in college
20:22:14 <benmachine> ray: so we should get rid of the name fmap, and make map and . both what it used to be?
20:22:23 <ray> yes
20:22:28 <benmachine> a flawless plan
20:22:29 <matsuura> SamB: me too
20:22:36 <matsuura> SamB: http://www.google.com/search?q=computer+science+3&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:en-US:official&client=firefox-a
20:22:42 <monochrom> CS III, Calculus XIV, Copyright MMIX.
20:22:53 <SamB> monochrom: eeeeeek
20:22:57 <SamB> not that, anything but that
20:23:03 * SamB runs away from MMIX
20:24:17 <monochrom> I wonder what would happen if I used IE and kept that client=firefox-a part in the URL.
20:24:30 <matsuura> >_>
20:25:02 <ray> monochrom: either google believes you're firefox, or doesn't
20:25:06 <ray> either way it's wrong
20:25:06 <monochrom> Oh, and Haskell MMX
20:25:14 <inimino> something at Google would probably catch on fire
20:25:17 <SamB> heck, I'm going to open it in iceweasel
20:25:33 <SamB> inimino: not any more than *usual*
20:25:33 <monochrom> I love burned out chips. Did I tell you that? :)
20:25:52 <SamB> they presumably have a schedule for approximately how often things are expected to catch on fire ;-)
20:25:55 <inimino> monochrom: you mentioned that they were tasty
20:26:02 <monochrom> Yes! :)
20:26:14 <inimino> personally I find the magic smoke makes a kind of incense
20:26:34 <SamB> I think it smells awful
20:26:47 <SamB> at least from, er, was it LM-84 ?
20:26:55 <inimino> well, some incense does
20:26:56 <benmachine> so guys how do I best escape a non-printing ASCII character in a haskell string
20:27:09 <benmachine> also how do I stop writing haskell and get sleep instead
20:27:09 <monochrom> '\SOL' ?
20:27:28 <ray> > "\STX\BEL\ETX"
20:27:30 <lambdabot>   "\STX\a\ETX"
20:27:44 <ray> > text "\STX\BEL\ETX"
20:28:00 <benmachine> > map chr [0..127]
20:28:01 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
20:28:12 <monochrom> Damn, SOL is not a real name. It should be SOH.
20:28:15 <benmachine> I guess that makes sense
20:28:25 <glguy> > "\97"
20:28:27 <lambdabot>   "a"
20:28:28 <SamB> > '\SOL'
20:28:29 <lambdabot>   <no location info>:
20:28:29 <lambdabot>      lexical error in string/character literal at chara...
20:28:47 <ray> i guess SOL would be start of line if it existed
20:28:52 <glguy> > "\x61"
20:28:54 <lambdabot>   "a"
20:29:02 <Saizan> SOH = Start Of Header?
20:29:06 <ray> yes
20:29:42 <glguy> > "\o141" -- last example :)
20:29:43 <lambdabot>   "a"
20:29:47 <monochrom> "My friend said \BEL bought \DEL. I said that's \BS"
20:30:20 <monochrom> Too bad none of them look like LOL.
20:30:47 <oklopol> night
20:30:54 <benmachine> glguy: I liked \x61 except that
20:31:12 <benmachine> > "\x61fee"
20:31:13 <lambdabot>   "\401390"
20:31:31 <SamB> > "\o1411"
20:31:33 <lambdabot>   "\777"
20:31:35 <SamB> ouch
20:31:44 <ray> > '\SO' : "L"
20:31:45 <lambdabot>   "\SOL"
20:31:56 <benmachine> > length "\ffffffff"
20:31:56 <opqdonut> heh
20:31:57 <lambdabot>   8
20:32:02 <benmachine> wat
20:32:05 <hzap> > ord '\SO'
20:32:06 <benmachine> > length "\ffff"
20:32:06 <lambdabot>   14
20:32:07 <lambdabot>   4
20:32:15 <benmachine> now I am confused
20:32:23 <benmachine> > length "\xffffffff"
20:32:24 <lambdabot>   <no location info>:
20:32:24 <lambdabot>      lexical error in string/character literal at chara...
20:32:27 <benmachine> oh
20:32:33 <benmachine> > length "\xffff"
20:32:34 <lambdabot>   1
20:32:36 <benmachine> > length "\xfffff"
20:32:38 <lambdabot>   1
20:32:39 <ray> tee hee
20:32:41 <benmachine> > length "\xffffff"
20:32:42 <lambdabot>   <no location info>:
20:32:42 <lambdabot>      lexical error in string/character literal at chara...
20:32:43 <Cale> I think it's worth pointing out that the reason that (.) is not still fmap is just that the GHC API / hint doesn't seem to support importing modules hiding some names.
20:32:44 <opqdonut> :P
20:32:45 <benmachine> ah
20:32:51 <Cale> Otherwise, I'd have done it :)
20:32:51 <glguy> > "\o141\&1"
20:32:53 <lambdabot>   "a1"
20:32:59 <glguy> \& is ""
20:33:20 <glguy> (if you need to disambiguate)
20:33:27 <benmachine> :o clever
20:33:44 <dolio> > "l\&o\&l\&w\&u\&t\&!"
20:33:45 <lambdabot>   "lolwut!"
20:35:13 <glguy> > "I\      \ lol'ed"
20:35:14 <lambdabot>   "I lol'ed"
20:36:23 <glguy> > "\^D"
20:36:24 <lambdabot>   "\EOT"
20:36:41 <dolio> Huh, didn't know about that.
20:37:11 <pikhq> Handy.
20:37:14 <glguy> > "\^@"
20:37:15 <lambdabot>   "\NUL"
20:38:32 <RyanT50001> is there a library that shows ordinal numbers? e.g. f :: Integer -> String, where f 1 = "1st", f 2 = "2nd" ...
20:39:18 <dolio> preflex: 5st 1 2 3 4 5 6 7 8 9
20:39:35 <pikhq> RyanT50001: No, but it'd be trivial to write.
20:39:44 <pikhq> I leave this as an exercise for the reader.
20:39:57 <inimino> it's trivial for English
20:39:59 <dolio> preflex: 6st 1 2 3 4 5 6 7 8 9
20:40:00 <preflex>  1st 2rd 3th 4th 5th 6st 7rd 8th 9th
20:40:24 <RyanT50001> pikhq: it seems like this sort of thing should be done in a central location
20:40:28 <RyanT50001> dolio: what's preflex?
20:40:43 <dolio> mauke's bot (I think that's right).
20:40:54 <pikhq> RyanT50001: ...
20:41:04 <pikhq> It's trivial. Write a library and put it on hackage.
20:41:19 <RyanT50001> pikhq: yes, i'll do that, but i wanted to check, first, if it had already been done
20:41:29 <RyanT50001> i certainly don't want to contribute something redundant to hackage
20:41:33 <pikhq> Okay.
20:41:48 <benmachine> dolio: 2rd?
20:42:12 <dolio> preflex: help 5st
20:42:13 <preflex>  unknown command: 5st
20:42:19 <dolio> preflex: help 6st
20:42:20 <preflex>  6st NUMBER[...] - ordinalify
20:42:31 <benmachine> preflex: 6st 2
20:42:31 <preflex>  2rd
20:42:31 <RyanT50001> mauke: ping
20:42:32 <oklopol> is it completely wrong on purpose?
20:42:43 <benmachine> pass
20:42:47 <benmachine> it's right about 1st
20:42:48 <dolio> Anyhow, it's based on some code he or someone else found in some javascript.
20:42:55 <inimino> it really belongs in some kind of i18n library
20:43:11 <dolio> Which is obviously very wrong.
20:43:22 <RyanT50001> inimino: yeah, i agree
20:43:42 <oklopol> would you write 1000001st?
20:43:48 <benmachine> yes
20:43:53 <pikhq> Yeah.
20:44:02 <RyanT50001> yep; it only depends on the last digit
20:44:14 <oklopol> never really thought about that, kinda obvious
20:44:15 <oklopol> 11th
20:44:20 <RyanT50001> oh right!
20:44:22 <RyanT50001> 11th
20:44:27 <RyanT50001> that's different
20:44:29 <benmachine> well it's a language thing not a number thing
20:44:32 <RyanT50001> it depends on the last *sound*
20:44:34 <pikhq> Ah, yeah. 10-20 is bucks the pattern.
20:44:36 <benmachine> 12th but 22nd
20:44:55 <inimino> after 20 it is regular
20:44:57 <inimino> up to 20 is irregular
20:44:59 <benmachine> but I do think you'd say thousand and first
20:45:01 <hzap> 411th
20:45:09 <pikhq> benmachine: Certainly.
20:45:14 <oklopol> inimino: well no, not exactly
20:45:38 <oklopol> up to 100
20:45:47 <benmachine> 112th
20:45:55 <inimino> oklopol: no?
20:45:58 <benmachine> so it depends on the last two digits
20:46:08 <oklopol> inimino: last two... what benmachine said
20:46:27 <benmachine> it depends on the last digit unless the second-to-last is a 1, in which case it's th
20:47:23 <oklopol> 0th
20:47:47 <RyanT50001> soooo... this is why i think it should be centralized :P
20:48:00 <RyanT50001> is there any part of the module hierarchy for this sort of stuff?
20:48:13 <RyanT50001> NaturalLanguage.English.Ordinals ?
20:49:39 <dolio> You could put it under Numeric.
20:49:49 <dolio> Although nothing else is under there in the standard libraries.
20:50:00 <RyanT50001> dolio: mightn't it be better to start an i18n tree?
20:50:15 <dolio> It has similar functions, though. Showing and reading numbers.
20:50:33 <RyanT50001> dolio: true; should it be exported from both places?
20:50:46 <RyanT50001> Numeric.English and some i18n-based thing?
20:51:08 <RyanT50001> (i have ulterior motives for starting up some i18n stuff :P)
20:51:28 <RyanT50001> (but, seriously, we should take internationalization seriously)
20:51:38 <dolio> Well, if you want to do i18n, do that. :)
20:51:47 <RyanT50001> alright; i'll look around
20:51:55 <RyanT50001> see if anyone's done anything related
20:52:27 <Saizan> ?hackage i18n
20:52:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/i18n
20:52:55 <RyanT50001> nice
22:20:32 <tessier> http://usairsucks.org I just put this site up. They really screwed me over.
22:21:06 <gwern> > 0.66 * 103129321
22:21:07 <lambdabot>   6.806535186e7
22:35:36 <gwern> > (1,000,000,000 / 12) / 20
22:35:38 <lambdabot>   No instance for (GHC.Real.Fractional (t, t1, t2, t3))
22:35:38 <lambdabot>    arising from a use...
22:35:48 <gwern> > (1000000000 / 12) / 20
22:35:49 <lambdabot>   4166666.6666666665
22:36:21 <Beelsebob1> tessier: to be honest... I'm half way down, and it sounds like they didn't put a foot wrong - airlines have *mega* strict rules on when they can get people onto flights, and they're not dictated by the airline... If you want to complain, complain to your government
22:36:32 <gwern> > 103 / 4.2
22:36:33 <lambdabot>   24.523809523809522
22:36:49 <gwern> > (4.2 / 103) * 100
22:36:50 <lambdabot>   4.077669902912621
22:37:13 <Beelsebob1> tessier: also, it's completely not their fault that your wife didn't have her id... it's unfortunate, but nothing to do with them
22:39:08 <gwern> Beelsebob1: you know the ID thing is just for their profits, right?
22:39:18 <gwern> it has nothing to do with security
22:39:34 <Saizan> by reading the whole letter it seems there's no requirement for ID
22:39:38 <Beelsebob1> at least in the UK, that's not true
22:39:47 <Beelsebob1> dunno in the US
22:40:07 <gwern> in the US, you don't need an ID to get through security
22:40:23 * Beelsebob1 nods
22:40:31 <gwern> legally, if you don't show security ID, they can pat you down if they want, but you still get through
22:40:36 <Beelsebob1> okay, I'd assumed similar rules to the UK, in which case it sounds rather... sucky
22:40:49 <gwern> the reason the airlines force you to show ID is to prevent people from swapping tickets
22:40:51 <Beelsebob1> in the UK your boarding pass actually becomes an official identity document
22:41:09 <gwern> they'd rather you were forced to go to them, ask for a (partial) refund and pay their fees
22:41:23 * Beelsebob1 nods
22:42:13 <gwern> in isolation, it's just a small predatory move by the airline, but in that context...
22:42:17 <Beelsebob1> ah yes, I've just got to the bit where it's a case of "go use an airline that doesn't need ID"
22:42:19 <tessier> Beelsebob1: No, these are not government rules.
22:42:26 <tessier> Beelsebob1: You will note that I address that.
22:42:26 <gwern> standing on it is inflexible
22:42:46 <tessier> Beelsebob1: United, American Airlines, and Southwest all had no problem with the situation. She flew American with no ID.
22:42:55 <glguy> This might be better in #haskell-blah
22:42:57 <glguy> or similar
22:43:06 <Beelsebob1> it might indeed
22:43:10 <gwern> Beelsebob1: and while we're at it, we can wish for the Invisible Hand to bring us unicorn ponies
22:43:26 <JN> good evening
23:00:59 <JN> why do I get "empty 'do' construct"
23:01:47 <glguy> Can you paste the problematic code?
23:01:51 <glguy> (to a pastebin)
23:01:57 <mauke> because you used an empty do block
23:02:01 <JN> thanks mauke
23:02:16 <JN> do you have a pastebin to recommend
23:02:25 <mauke> yes
23:02:31 <JN> thanks again mauke
23:02:32 <glguy> http://hpaste.org/fastcgi/hpaste.fcgi/new
23:02:42 <mauke> /topic
23:03:04 <glguy> mauke: try typing that without a /say or a "/ "
23:03:04 <JN> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7485#a7485
23:03:25 <glguy> JN: indent to the right of the definition
23:03:26 <mauke> /
23:03:30 <mauke> glguy: /msg * /
23:03:47 <JN> what definition
23:04:03 <JN> to the right of the show' ?
23:04:09 <glguy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7485#a7486
23:04:11 <glguy> yes
23:04:25 <JN> haskell's a bit whacky with the indentation rules.. :/
23:04:26 <glguy> mauke: I meant by doing it without those commands you could actually see the topic :-p
23:04:42 <mauke> JN: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7485#a7487
23:04:58 <mauke> glguy: yes, which is why I gave him the command
23:05:06 <JN> thanks.. it compiles now
23:06:33 <mauke> JN: indentation is easier if you always start a new line after layout-inducing keywords (do, where, of, ...)
23:06:58 <JN> thanks
23:07:20 <glguy> did you map a list comprehension just to try out map?
23:07:50 <JN> I'm working on the 99 problems.. I didn't do anything for the sake of trying it. :)
23:07:58 <JN> if it's wrong, I'll figure it out
23:07:59 <mauke> table2 f = map show' [(a, b) | a <- [True, False], b <- [True, False]]
23:08:08 <mauke> table2 f = [show' (a, b) | a <- [True, False], b <- [True, False]]
23:08:19 <mauke> not wrong, just kind of redundant if you have a list comprehension anyway
23:08:38 <JN> I see
23:09:24 <mauke> table2 :: (Bool -> Bool -> String) -> [IO ()]
23:09:30 <mauke> probably not what you wanted
23:17:40 <JN> is there a command like putStrLn which writes a line with no string argument
23:18:17 <dibblego> @type putStrLn []
23:18:18 <lambdabot> IO ()
23:19:15 <JN> ok.  I guess that's equivalent to putStrLn "" ...
23:19:29 <gwern> or putStr "\n"?
23:19:54 <JN> I would have expected a putLine
23:21:29 <ray> putChar '\n'
23:22:28 <JN> would not be equivalent if putStrLn respects the platform line separator..
23:23:32 <mauke> JN: argh, not you too
23:23:44 <mauke> there is a portable newline abstraction
23:23:47 <mauke> it's called '\n'
23:23:56 <mauke> @src putStrLn
23:23:56 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
23:24:22 <mauke> similarly, in C++ cout << endl; is equivalent to cout << '\n' << flush;
23:24:26 <JN> not me too what
23:24:35 <ray> http://haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#putStrLn in case you don't trust @src
23:24:37 <mauke> having this misconception about '\n'
23:24:55 <JN> \n is a single character. right?
23:25:16 <mauke> yes
23:25:27 <JN> ok. and some platforms use multiple characters for end-of-line
23:25:31 <mauke> no
23:25:52 <mauke> '€' is a single character. right?
23:26:19 <JN> I suspect. I'm not european
23:26:31 <JN> I'm talking about codepoints.  \n == line feed
23:26:35 <mauke> no
23:26:38 <mauke> \n == newline
23:26:41 <SubStack> it's 3 bytes
23:26:50 <hansfbaier> mauke: In UTF-8 only ASCII are single
23:27:13 <hansfbaier> mauke: and identic to that, every thing else is multibyte
23:27:20 <mauke> hansfbaier: irrelevant
23:27:55 <JN> mauke.. I suggest you do a little research.
23:28:00 <hansfbaier> mauke: Yes, but true.
23:28:09 <mauke> JN: about what?
23:28:10 <JN> but I don't really need to get into a discussion right now.. I have dinner waiting. be back in a bet
23:28:46 <JN> mauke:  I may not know haskell, but I know a few things about programming.  there are distinct line feed and carriage return characters.  different platforms use different combinations of these characters to represent a "new line"
23:28:56 <JN> dinner time.. talk to you later
23:29:04 <Ytinasni> yes. and Haskell, as a platform, uses '\n'
23:29:36 <mauke> distinct line feed and carriage return characters is an ASCII thing. does Haskell require ASCII (it probably does)?
23:30:25 <ray> isn't haskell supposed to be unicode (the first 128 code points of which are equivalent to ascii)?
23:31:02 <Ytinasni> ray: so it has \r and \n, which is the point he was making.
23:31:48 <mauke> I'm thinking of C
23:32:13 <ray> does C require ASCII? i didn't think it did
23:32:18 <mauke> it doesn't
23:32:32 <mauke> it definitely doesn't require a linefeed; I wonder if it requires a carriage return
23:33:53 <ray> i don't know what crazy stuff they've been up to in more recent C standards
23:34:22 <mauke> I don't think that part changed in C99 :-)
23:34:58 <ray> all i know about c99 is that it has a useless boolean type
23:35:43 <mauke> it also has complex types
23:35:56 <Twey> It has a boolean type?
23:36:01 <mauke> yeah, _Bool
23:36:08 <Twey> Does anyone use it?
23:36:16 <Ytinasni> does anyone use c99?
23:36:18 <Ytinasni> :D
23:36:21 <erikc> i wish i could
23:36:31 <erikc> designated initializers are nice sugar
23:36:39 <pstickne> c99 allows variable declaration inside the initial conditions of a for :-)
23:37:21 <erikc> point v = { .y = 1, .z = 3, .x = 2}; // works great for tagged variant unions too
23:37:58 <erikc> c99 is in a tough spot on windows though since microsoft wont support it (no demand from customers)
23:48:47 <adu> is that record notation?
23:49:11 <Twey> adu: No, it's C99 initialisation notation
23:49:49 <adu> oh
23:49:49 <Twey> For a typedef struct { int x, y, z; } point;
23:49:59 <adu> i like C
23:50:13 <adu> i like Haskell more
23:50:35 <monochrom> I like Analytic Engine.
23:50:42 * Twey despises C
23:51:19 <adu> monochrom: to much extra Babbage
23:51:26 <Ytinasni> Twey: why?
23:52:10 <Twey> Ytinasni: Because it takes many KLoC to do anything vaguely useful, and requires one to continually fiddle with daft implementation details that are unrelated to the problem at hand
23:52:21 <Ytinasni> fair enough.
23:54:44 <monochrom> Heh
23:56:51 <hackagebot> graphviz 2999.1.0.2 - GraphViz bindings for Haskell. (IvanMiljenovic)
23:57:31 <adu> thats a big version
23:58:36 <kyagrd> What happend to http://www.realworldhaskell.org/ ???
23:58:46 <ivanm> adu: well, it was using dates
23:59:00 <ray> http://book.realworldhaskell.org/ still works
23:59:07 <ivanm> so when I wanted to switch to a "normal" versioning system, I had to start with something > 2009
23:59:17 <kyagrd> Error establishing a database connection on the real world haskell website (I was trying to recommend it ...)
23:59:18 <ivanm> adu: http has the same thing
23:59:37 <adu> i like TeX's versioning system :)
23:59:38 <ray> the contents of the book also still work
