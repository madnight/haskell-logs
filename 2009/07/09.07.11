00:01:58 <performance> well the task im trying to accomplish is: i have a few hundred cr2 files , i want to convert to jpeg, watermark and upload to flickr
00:02:34 <performance> retian my current folder structure, but i dont want to retain the jpeg locally..
00:05:52 <mmorrow_> performance: maybe just md5 each .jpg, upload it, and replace the each foo.jpg with foo.jpg.md5 locally
00:06:28 <copumpkin> you're just going to convert raw files to jpegs without touching them?
00:06:30 <copumpkin> :o
00:07:17 <copumpkin> failsplit
00:07:28 <performance> what is failsplit?
00:07:57 <performance> mmorrow_: why do that?
00:08:41 <elbar> i guess watermarking implies touching ;)
00:09:03 <mmorrow_> performance: i figure if you don't want to retain the images, but want to preserve the directory structure, might as well stick an md5 in as a placeholder for eac hfile
00:09:40 <performance> i can track the last file processed  in case the programs has to stop midway
00:09:47 <performance> but i dont see any other use for the md5
00:09:53 <mmorrow_> err, i just meant for the future
00:10:07 <mmorrow_> i dunno, just threw that out there, no real reason ;)
00:10:19 <mmorrow_> performance: what are you trying to do?
00:10:21 <performance> :D incidentally the formats page on graphicsmagick does not have CR2
00:11:40 <performance> although CR2 is almost just a tiff file
00:12:17 <copumpkin> except you don't get real image data
00:12:49 <mmorrow_> looks like there's some C code here http://www.cybercom.net/~dcoffin/dcraw/
00:13:20 <mmorrow_> dunno if that does "CR2"
00:13:33 <copumpkin> it should be pretty common
00:14:11 <mmorrow_> ooh, that C code is pleasant on the eyes too
00:15:06 <elbar> emerge media-gfx/dcraw ;)
00:17:59 <performance> yeah ufraw does cr2 . i use that to import to gimp
00:18:15 <performance> was reading up if graphicsmagick can also use it :)
00:19:37 <performance> mmorrow_: i like haskell but dont get to use it much.. so i conjured up this need. :)
00:20:42 <Figs> Is this the right way to do IO in Haskell?
00:20:43 <Figs> http://pastebin.com/d484e1460
00:20:44 <performance> this task can certainly be accomplished by using picasa and flickr uploader.  but no fun in not trying to do it myself :)
00:20:55 <JN> I'm reading a haskell tutorial.. they are talking about asymptotic performance of list, array, finitemap.  they say that "find" for array is O(1).  how is that implemented in haskell?  or is it compiler magic
00:21:24 <dainanaki> Hey folks, i'm a little stumped by the ((->) a) instance of the Applicative combinator (<*>). Could someone give me a practical usage example?
00:21:52 <mike-burns> uman, Cale: I HTMLized an edited log from last night's tutorial: http://mike-burns.com/project/all%20your%20haskell/
00:21:57 <performance> Figs: why do you have a return on line 8 ?
00:22:02 <mike-burns> (Since I said someone should do that.)
00:22:16 <Figs> I don't know.
00:22:25 <mmorrow_> performance: have you ever used Data.Binary?
00:22:27 <Cale> mike-burns: cool :)
00:22:31 <Figs> That wasn't supposed to be there O_o
00:22:46 <m4k3r> is there a difference between `quot` and `div` ?
00:22:47 <performance> mmorrow_: nope :(
00:23:23 <mmorrow_> performance: this might be the perfect time to learn.. since you've got a purpose you'll be motivated
00:23:23 <RayNbow> > "y" `elem` words "y n"
00:23:25 <lambdabot>   True
00:23:26 <RayNbow> > "n" `elem` words "y n"
00:23:28 <lambdabot>   True
00:23:34 <RayNbow> > "some random input" `elem` words "y n"
00:23:36 <lambdabot>   False
00:23:39 <RayNbow> ^ Figs
00:24:08 <Figs> RayNBbow: I want to give an error and loop until I get valid input (ie, the input is one of
00:24:12 <Figs> "y" or "n")
00:24:19 <coCocoa> > (-5) `quot` 4
00:24:20 <mmorrow_> performance: you can just implem the decoder (say to bmp, which is pretty simple of a fmt), then convert the .bmp to jpg with something else (since the cosine transform would probably be a total pita)
00:24:20 <lambdabot>   -1
00:24:22 <coCocoa> > (-5) `div` 4
00:24:24 <lambdabot>   -2
00:24:34 <coCocoa> m4k3r: ^^
00:25:08 <m4k3r> :o
00:25:56 <Figs> Should I do something like
00:26:30 <Figs> if response `elem` ["y", "n"] ...
00:26:31 <RayNbow> Figs: I'm suggesting that piece of code as an alternative for: or $ map (response ==) ["y", "n"]
00:26:52 <RayNbow> that also seems ok
00:27:00 <Figs> RayNbow: Got that now, thanks :)
00:27:17 <Figs> At first I thought you were suggesting it as a replacement for the whole block
00:27:57 <Figs> Would there be a better way of dealing with the "do return (response == "y") "
00:28:01 <Figs> after I test that?
00:28:24 <Figs> And why does it compile and (apparently) run with the extra return response? O_o
00:28:56 <m4k3r> coCocoa: i have no idea why outputs are different :\
00:31:24 <Cale> Figs: return is just a function, and it produces an action which does nothing except to return the given value
00:31:54 <Cale> Figs: If you run  return v  in the middle of a do-block, it does nothing and serves no purpose, but also doesn't harm anything.
00:32:19 <RayNbow> Figs: you can omit the 'do' in 'do return (response == "y")'
00:33:30 <performance> Cale: in a do block, the value of the last statement is the value of the funciton right?
00:33:48 <Cale> performance: the result of the last statement is the result of the action
00:34:47 <idnar> @type elem
00:34:49 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
00:34:56 <Cale> So that's what return is good for, it's useful as the last action in a do-block or chain of >> and >>= in order to produce a result which is different from whatever you happened to do last.
00:35:18 <performance> Figs: return in haskell is not the same as in C. it does not actually return control.
00:35:53 <Cale> Yeah, return in C is strange. It's like every function gets wrapped in callCC and return calls the continuation.
00:38:42 <Figs> performance: I just don't understand monads enough yet, and the IO monad especially to know what my do-notation code is translated to :)
00:39:20 <dankna> it's fairly simple.  consecutive lines are joined by >>=.
00:39:25 <performance> :) what a coincidence, Cale was the one to help me figure out monads :) abt two years ago
00:39:40 <JN> monad!!
00:39:47 <Raynes> Gonad!
00:39:56 <mike-burns> Mo ... nads?
00:40:06 <dainanaki> Nomads?
00:40:21 <performance> Figs: what ever you do, dont ever tell your slef that monads are difficult to understand.
00:40:37 <performance> despite all the jokes etc..
00:40:38 <mike-burns> Speaking of Cale talking about monads and coincidences, I just posted (and mentioned this) Cale's tutorial on Haskel starting with the IO monad from last night: http://mike-burns.com/project/all%20your%20haskell/
00:40:45 <RayNbow> btw Figs, why are you flushing stdout?
00:40:57 <Figs> My output wasn't showing up, so I tried that
00:41:01 <Figs> and it seemed to fix it
00:42:41 <performance> Figs: do you have an abstract algebra background ?
00:42:41 <Figs> If I don't flush stdout there, my prompt shows up only after I input data
00:43:21 <Figs> I'm about half-way through an undergrad college CS program
00:43:25 <RayNbow> Figs, you could also do this in your main: hSetBuffering stdout NoBuffering
00:43:35 <Figs> And I've done programming in various other languages over the last 8 years or so
00:43:43 <Raynes> Figs: You can also import IO and hSetBuffering stdout NoBuffering, for future reference.
00:43:44 <Figs> Though mostly imperative ones.
00:44:05 <Raynes> RayNbow: Beat me to it. :(
00:44:14 <RayNbow> :p
00:44:28 * RayNbow had to look it up though in some old program he wrote a while back :p
00:44:33 <performance> figs, well i just asked.  i havea  book but never got beyond the third chapter :D
00:44:35 <Raynes> Your name is similar to mine, but are your thoughts.
00:44:39 <Figs> Is that better than flushing here?
00:44:48 <Raynes> RayNbow: So did I... That's scary...
00:45:07 <Raynes> Figs: Works the same. It's fine if you only flush once, but if you need to flush several times, just NoBuffer it.
00:45:48 <JN> i only made it halfway through the online haskell book.. yawn
00:46:08 <Figs> I've been reading the "Gentle Introduction" on the haskell.org site
00:46:15 <Figs> Made it much further this time around.
00:46:30 <JN> now I'm giving yaht (yet another haskell tutorial) a try.
00:46:39 <RayNbow> Raynes: it starts to get scary, yeah... what's next? We share the same birthday? :p
00:46:57 <copumpkin> we need a yet another great haskell tutorial
00:46:57 <Raynes> RayNbow: February second? o_o
00:47:10 <RayNbow> ah, we found a difference... :)
00:47:11 <Figs> Could someone explain the State Monad from 9.3 here: http://www.haskell.org/tutorial/monads.html ?
00:47:13 <Raynes> Oh, thank God.
00:47:16 <RayNbow> <-- July 14th, 1985
00:48:00 <Raynes> RayNbow: Happy early birthday.
00:48:04 <copumpkin> yet another comfortable haskell tutorial?
00:48:18 <Figs> I have a very hard time following it with the variable names being like that...
00:48:47 <RayNbow> Raynes: thx :)
00:48:56 <shachaf> Figs: The State monad cannot be explained.
00:49:23 <shachaf> You must discover it for yourself.
00:49:42 <JN> shark bait woo-ha-ha
00:49:53 <performance> copumpkin: are you a fan of comonads?
00:49:59 <Figs> Can you at least tell me what the variable names stand for? :P
00:50:02 <shachaf> Figs: (Start by thinking of how you would implement state in Haskell, then try working it into a monad.)
00:50:06 <copumpkin> performance: I'm a fan of all duals
00:50:11 <copumpkin> performance: which zomg is everything!
00:50:13 <Figs> "fc2" is kind of hard to follow
00:50:16 <shachaf> Figs: That is my recommended approach.
00:50:33 <shachaf> Indeed -- so write the function yourself.
00:50:46 <shachaf> Do you understand the data-type?
00:51:00 <performance> well i dont understand comonads a whole lot. but i was reading somewhere that comonads are best to abstract/ represent causal systems
00:51:15 <Figs> data SM a = SM (S -> (a,S)), you mean?
00:51:22 <mike-burns> Figs raises a good point, and one that was on haskell-cafe a while ago IIRC: these tutorials would benefit from using long variable names when possible.
00:51:27 <shachaf> Well, in the normal State monad, S is polymorphic.
00:51:37 <dankna> mike-burns: concur, definitely
00:51:46 <shachaf> mike-burns: Well, not necessarily always longer.
00:51:52 <shachaf> Long enough -- "fc2" probably isn't. :-)
00:52:03 <mike-burns> Okay, not longer; more descriptive.
00:52:09 <performance> Figs: what helps is always trying to see how a given example satisfies the monad laws
00:52:15 <shachaf> But sometimes you can't do better than "a" when explaining something very general, which Haskell tutorials always tend to do.
00:52:54 <mike-burns> Schmidt: Sure; when "a" is the most descriptive then use it. But I'm still trying to figure out where "fc2" came from.
00:53:05 <JN> this tutorial just introduced _|_ and called it bottom.  I assume that's because it looks like an ass?
00:53:10 <copumpkin> JN: lol
00:53:21 <mike-burns> Hah.
00:53:33 <copumpkin> @remember JN this tutorial just introduced _|_ and called it bottom.  I assume that's because it looks like an ass?
00:53:34 <lambdabot> It is stored.
00:55:06 <mike-burns> Aha, "two `resourceful' computations, c1 and fc2 (a function producing c2)"
00:59:10 <Figs> shachaf: My understanding is that the data type (whatever you call that declaration...) is saying something along the lines of "for all types a, an SM for type a can be created using SM ___ where ___ is a function S -> (a, S)"  [whatever the hell S is.]
00:59:25 <Figs> Am I part way through understanding that, at least?
00:59:57 <shachaf> Figs: You understand it to the letter. :-)
01:00:05 <shachaf> Now try the spirit.
01:00:12 <shachaf> Why does that definition make any sense?
01:01:09 <dankna> because it's like implicit templates, kinda
01:01:47 <shachaf> Figs: The best way to make it make sense is to scrap it and start over.
01:01:57 <shachaf> You have nothing but functions; how do you do stateful things?
01:02:45 <Smokey`> (haskell noob) you can't, without a function which can in turn read/write state (eg: IO -_-)
01:03:03 <Figs> I'm assuming that it's storing some information in the tuple it returns
01:03:21 <Figs> presumably in some way dealing with modifying S?
01:03:43 <shachaf> Maybe ignore S. :-)
01:03:58 <shachaf> You have a bunch of functions that keep a Bool as state.
01:04:34 <shachaf> First imagine stateless functions -- they'd have types like Int -> Int -> Int and a -> [a] -> [a].
01:04:54 <shachaf> Now what do you do if you want each of these functions to work with "state"?
01:05:10 <JN> use a state monad
01:05:14 <JN> :D
01:05:15 <Smokey`> lol
01:05:26 <Figs> I'm not sure what state *means* in this sense.
01:05:44 <Figs> My impression is that you have to construct a new value representing the change
01:06:11 <Figs> I don't know whether by "state" you mean its history, or just whatever some value would be in in a mapping after the last computation
01:06:26 <shachaf> Figs: Well, Haskell has no real state, right?
01:06:32 <performance> Figs, lets say you have to update a counter
01:06:43 <shachaf> Ah, yes, a counter.
01:07:04 <shachaf> So you want every function in your program to count how many times a function has been called.
01:07:07 <performance> each time your function is called, it has to give me a number equal to the number of times that function was called
01:07:13 <shachaf> You need to store that value somewhere.
01:07:14 <Figs> Then I'd assume you'd want to pass along the mapping to your other functions.
01:07:15 <performance> :)
01:07:25 <copumpkin> what for?
01:07:32 <copumpkin> why not just use the profiling facilities?
01:07:39 <shachaf> copumpkin: Shush.
01:07:41 <copumpkin> lol
01:07:43 <JN> :)
01:07:57 <shachaf> So, first of all, you'd put that counter somewhere. Right?
01:07:58 <copumpkin> then myglobal = unsafePerformIO $ newIORef undefined
01:07:58 <copumpkin> :P
01:08:00 <performance> figs, lets start with this. write a function to return a number
01:08:06 * RayNbow co-smashes copumpkin :p
01:08:23 <RayNbow> stop co-confusing the new Haskell users :p
01:08:27 <copumpkin> lol
01:08:30 <Figs> foo = 1
01:08:33 <copumpkin> nfusing?
01:08:38 <RayNbow> :p
01:08:51 <performance> now in order to return the number of times it was called, you have to know how many times it was called before
01:08:55 <performance> and increment that
01:09:13 <Smokey`> sadly copumpkin's last myglobal remark makes more sense to me than the State monad :P
01:09:40 <copumpkin> use a Writer
01:09:48 <copumpkin> unless you need to read before the end
01:10:10 <Associat0r> Smokey`: hey
01:10:13 <Figs> foo_times n = n + 1    ?
01:10:20 <performance> but wait, [ in billy Mays' voice]  each time you call the function
01:11:00 <Smokey`> Associat0r: long time no see :)
01:11:10 <performance> figs,  so every time you call foo_times, you have to pass it the updated value explicityly
01:11:15 <performance> explicitly
01:11:23 <Associat0r> Smokey`: where have you been?
01:11:29 <performance> can you think of a way to make that not explicit?
01:11:38 <copumpkin> hmm?
01:11:52 <shachaf> performance: You are talking about State s (), which is not very useful.
01:12:39 <Figs> No, but I assume at some point it will involve the magical word 'monad' and the mystical functions >>=, >>, and return...? :)
01:12:48 <performance> :D
01:12:56 <shachaf> Figs: Eventually, but not quite yet, I think.
01:13:10 <performance> shachaf, im trying to get him thinking
01:13:14 <shachaf> First figure out how you work with "state" without monads.
01:13:19 <copumpkin> might be easier to see monads in terms of fmap and join
01:13:37 <performance> him or her
01:13:39 <shachaf> copumpkin: You are making things more complicated -- though in general I agree with you.
01:13:40 <copumpkin> and return
01:13:47 <copumpkin> how is fmap more complicated?
01:13:51 <Smokey`> Associat0r: I've been in this channel every day for the last few months?
01:13:54 <copumpkin> >>= has a terrifying type signature
01:14:02 <shachaf> copumpkin: Especially for Cont.
01:14:12 <copumpkin> join is nice and simple by comparison, and makes more or less intuitive sense
01:14:29 <Associat0r> Smokey`: so you're back into haskell
01:14:41 <shachaf> (This would be a neat opportunity to try out Etherpad, by the way; does anyone feel like doing that?)
01:14:46 <Associat0r> Smokey`: any projects you're working on?
01:14:50 * shachaf has not used it, and it might work well for this sort of thing.
01:15:00 <performance> figs, at this point, do you appreciate that if you want your pure function to handle state, you have to give pass the current state as input?
01:15:01 <Smokey`> Associat0r: no, not quite - I haven't touched haskell in about 2 years - stopped ever since I was unable to get any sort of decent performance out of it.  but I stay in here due to the interesting conversation :)
01:15:15 <Smokey`> Associat0r: same old, but less time now days (work work work)
01:15:18 <mike-burns> Figs: Monads are less magical than you may have heard.
01:15:26 <copumpkin> Smokey`: things have probably changed a lot performance-wise since then :)
01:15:54 <shachaf> mike-burns: Monads seem magical because people start from the general case instead of concrete cases.
01:15:57 <copumpkin> monads are the most over-hyped characteristic ever
01:16:04 <Figs> performance: I think I get that.
01:16:27 <shachaf> http://etherpad.com/5k733FGHJv if you would like to try.
01:16:33 <Associat0r> Smokey`: what kind of work now?
01:16:57 <Smokey`> Associat0r: I do a lot of GPGPU stuff for a company who writes face/eye tracking software
01:16:59 <JN> I think monads would be more approachable if they had a more down-to-earth name..  like, say, "ice cream"
01:17:36 <Associat0r> Smokey`: that's nice
01:17:38 <JN> I'm still stuck on the name
01:17:50 <mike-burns> Monads are basically comparable to a design pattern, and it'd probably be helpful to newcomers if tutorials treated them as such.
01:17:53 <Figs> Unfortunately for me, it's 1am here, and I will be hitting the hay soon. So I'm a bit slower than I otherwise would be.
01:18:12 <performance> hehe im on PDT too
01:18:22 <copumpkin> mike-burns: not sure I'd even say that
01:18:36 <Figs> I'd like to at least try to pound in some of it if possible so my subconscious can keep figuring it out as I sleep.
01:18:45 * shachaf is also -- 1 AM already?
01:19:00 <mike-burns> Heh, 4AM here. Yay weekends!
01:19:00 <Associat0r> Smokey`: are you gonna visit flipcode sometime?
01:19:15 <performance> ok now instead of just a number, think about a lot of content of different types which would be inconvenient to pass around every time
01:19:36 <copumpkin> performance: ?
01:19:53 <Smokey`> Associat0r: why? :P
01:19:55 <mike-burns> copumpkin: True enough; if I were writing a tutorial I doubt I'd mention monads until some section on typeclasses.
01:20:01 <performance> well im trying to motivate him to get to the bind operation :) and hide the stuff there :D
01:20:06 <Associat0r> Smokey`: why not?
01:20:19 <Associat0r> Smokey`: it's a nice channel right?
01:20:22 <Smokey`> last time I was in there, it was full of idlers and trolls :)
01:20:24 <copumpkin> oh :)
01:20:49 <Associat0r> Smokey`: how do you mean trolls?
01:20:52 <performance> but i didnt want to give that part away :D
01:20:59 * copumpkin crawls out from under his bridge
01:21:04 <performance> now you made me do it :( grr...
01:21:18 <Figs> performance: What you're basically trying to get me to figure out is how to implicitly pass the state around using the sequencing magic of monads, right?
01:21:27 <JN> mike-burns:  what annoyed me most about the online haskell book was that 20% of all user comments in the first 6 or so chapters referred to monads.. and the book content itself kept mentioning monads, without giving any clue as to what it was...  it builds up an impression that it's a mystical concept that's too hard for them to explain.
01:21:30 <Figs> I don't understand the sequencing magic.
01:21:36 <performance> bind. not sequence there is a small difference
01:21:38 <shachaf> Figs: No, ignore "monads".
01:21:46 <performance> which has a big impact :)
01:21:49 <JN> so, I'd rather see monads described in chapter 1 and dispense with it.  don't have to explain it fully
01:21:54 <copumpkin> Figs: I think the basic point is that you could reinvent the basic idea of monads easily if you stopped thinking of it as magic
01:22:11 <performance> forget about the term monad, just think about the problem at hand
01:22:20 <Smokey`> Associat0r: if I'm not mistaken the reason I left was because of some guy constantly picking on every word I said, not having anything constructive to say, and in general - no one in there really talked about anything relating to computer graphics / game dev / etc, it was more or less dead.
01:22:26 <Smokey`> Associat0r: besides you and nick (OnoSendai)
01:22:28 <shachaf> Just figure out how to put the state-passing work into separate functions so you don't have to worry all the time.
01:22:31 <mike-burns> JN: That's a good point too. Though I really wish there were less emphasis on the word "monad".
01:22:35 <performance> since youre studying CS any way i hope you find it stimulating to try and come up with solutions
01:23:17 <copumpkin> thoughtpolice: awake?
01:23:25 <Figs> What I'm trying to say is that I don't understand >>= and I don't understand how that translates to do notation. Can this be done without that?
01:23:37 <copumpkin> definitely
01:23:37 <shachaf> Figs: Yes -- you will reinvent it in the process.
01:23:45 <shachaf> Which is the best way to learn some things. :-)
01:23:53 <performance> well :) im trying to get you to come up with a need for >>=
01:24:06 <shachaf> (>>=) is just a shortcut for State, which can be used without it.
01:24:15 <shachaf> (Though it's not very pretty.)
01:24:21 <copumpkin> >=> mmm
01:24:23 <copumpkin> ;)
01:24:34 <lpsmith> mike-burns:  but monads are fun!
01:24:42 <lpsmith> :)
01:24:56 <copumpkin> they are
01:24:58 <Figs> hang on a sec
01:25:06 <Associat0r> Smokey`: well that might be true to some extent, but for the few people that are there, I'm impressed about how much knowledge is in that channel
01:25:12 <copumpkin> but I wish people wouldn't say "oh, haskell? never tried it but MONADS"
01:25:14 <performance> essentially when you say in english " i need a function  that  does xyz and xyz happens to be what bind does :) then its easy for you to understand the whole thing
01:25:24 <mike-burns> copumpkin: Right, exactly.
01:25:43 <copumpkin> monads are not what haskell is about, they just happen to be a nice abstraction that allows us to sequence things, and that our language lets us write elegantly
01:25:48 <thoughtpolice> copumpkin: ping
01:25:48 <shachaf> copumpkin: Wait, monads?
01:25:49 <mike-burns> Like when my coworkers discovered I know Haskell their first question was "so what's a monad?! Do you understand what it is?!"
01:25:51 * shachaf is out of here.
01:26:14 <performance> brb reading about flickrfs
01:26:21 * performance is reading about flickrfs
01:26:26 <copumpkin> thoughtpolice: was wondering how the ghcosx64 stuff was going, and whether your current version was up somewhere I could tinker on if you didn't already have it working
01:26:33 <copumpkin> shachaf: damn, I scared you off!
01:26:36 <shachaf> Figs: (Not coming to that editor?)
01:26:43 <copumpkin> shachaf: arrow! alternative! applicative! functor!
01:26:45 <Associat0r> Smokey`: I mean tell me a channel where you can have a meaningfull convo about games, haskell, FRP, esoteric languages, graphics etc
01:27:03 * shachaf vanishes in a puff of orange smoke.
01:27:10 <shachaf> Congratulations! You have gained 50 XP.
01:27:15 * copumpkin rubs hands in glee
01:27:33 <idnar> haha
01:27:47 <Figs> editor?
01:27:55 <shachaf> Figs: http://etherpad.com/5k733FGHJv
01:27:59 * shachaf would like to try it. :-)
01:28:15 <thoughtpolice> copumpkin: currently the issue is that part of the configuration (namely, the base package) doesn't pick up the fact it needs to be 64bit, so it determins that sizeof(long) = 4 and sizeof(long long) = 8, while the x86_64 ABI specifies sizeof(long) == sizeof(long long) == 8
01:28:27 <dibblego> geordi -- a C++ bot written in Haskell -- is it on hackage?
01:28:39 <copumpkin> thoughtpolice: oh, I think I'd fixed that in my version
01:28:49 <thoughtpolice> copumpkin: can you push patches?
01:28:56 <thoughtpolice> copumpkin: or email them to ghc-cvs? that would be awesome
01:29:08 <copumpkin> thoughtpolice: not sure if I still have it, I think I junked most of that stuff after igloo overtook my progress and did it all
01:29:19 <thoughtpolice> copumpkin: hm
01:29:20 <copumpkin> or so I thought
01:29:43 <thoughtpolice> copumpkin: I can work around it by simply saying 'export CFLAGS=-m64' before I run my build, but that makes the build in particular extremely painful
01:29:51 <thoughtpolice> and it's not really a solution anyway
01:29:54 <copumpkin> ah
01:30:23 <thoughtpolice> copumpkin: because hsc2hs picks up the CFLAGS env. variable, and will add -m64 to all compilations, including the ones it definitely does not need to add it to
01:30:38 <copumpkin> I see
01:31:31 <thoughtpolice> so yeah, you end up having to fix about 40 linker errs before you can even get stage1 to build and link iirc
01:31:44 <copumpkin> hm, what happened? you used to get to stage 2
01:33:20 <thoughtpolice> copumpkin: well, the iconv patches hit for the base i/o rewrite
01:33:28 <thoughtpolice> copumpkin: which is where the compiler is segfaulting as of current
01:33:35 <copumpkin> ah :/
01:33:39 <thoughtpolice> copumpkin: i'll have to check what darcs says about certain things
01:34:05 <thoughtpolice> particularly yeah, it should just 'do the right thing', but ./libraries/base/configure determines sizeof long == Int32 when it shouldbe Int64
01:34:17 <thoughtpolice> it causes a truncation problem, followed by a pointer dereference into a black hole
01:36:25 <Smokey`> Associat0r: I'll admit flipcode is very, very unique.  But that's no real reason to go back.  (I don't see why you want be to go back so badly :P)
01:37:02 <copumpkin> thoughtpolice: any chance of putting the current state of things up somewhere so I can see if I can get it working? or would that just overcomplicate it
01:37:17 <Associat0r> Smokey`: I just miss the old days
01:37:56 <Smokey`> :)
01:49:21 <thoughtpolice> copumpkin: I have a patch for integer-gmp that clears some stuff up (so you use the in-tree version so it can be built for x86_64) that I haven't posted yet, and maybe a few other changes lying around
01:49:36 <thoughtpolice> copumpkin: I don't plan on going anywhere really tomorrow, so I'll contact you and we can try to sort out these issues :)
01:49:47 <copumpkin> ok cool :)
01:52:46 <a_guest> In 'System.IO' there is 'openFile' and 'openBinaryFile'. What is the difference with these (what is the difference between text files and binary files)?
01:52:58 <copumpkin> it's a windows thing only afaik
01:53:28 <copumpkin> where windows will mangle things somehow unless you open something as binaru
01:53:47 <copumpkin> seems to me like you'd always ask windows to open something as binary
01:54:09 <copumpkin> or I would, if I used windows
01:55:28 <ColeSOAR> > [1..]
01:55:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:56:54 <povman> a_guest: In a text file, null character indicates EOF
01:57:10 <ColeSOAR> > primeList [] = []; primeList (x:xs) = x : primeList [a | a <- xs, a `mod` x /= 0]; primeList [2..]
01:57:12 <lambdabot>   <no location info>: parse error on input `='
01:57:37 <ColeSOAR> > let primeList [] = []
01:57:39 <lambdabot>   not an expression: `let primeList [] = []'
01:57:48 <ColeSOAR> :-(
01:58:53 <povman> Does/will ever haskell support ada-style subtypes?
02:00:04 <povman> i.e. compile time checks where currently only exceptions work
02:00:07 <ColeSOAR> no.  if haskell changed, it would no longer be haskell.  and that wouldn't be very functional of it.
02:00:13 <povman> what
02:00:23 <Beelsebob> huh?
02:00:23 <ColeSOAR> it must remain unchanged, or it would be behaving in an imperative way, contradictory to it's own precepts.
02:00:29 <povman> No
02:00:38 <Beelsebob> povman: what does an ada subtype do?
02:00:43 <Beelsebob> it's a long time since I've used ada
02:01:01 <ColeSOAR> if you say haskell = blah blah blah.  then it has to stay that way.  what do you think this is, C?
02:01:26 <povman> ColeSOAR: Go away, it was a reasonable question.
02:01:39 <povman> In Ada, you can define a type as a subset of another type, and the compiler can do more checks
02:01:55 <Beelsebob> oh, things like asking for the integers between 5 and 29
02:01:56 <Beelsebob> etc
02:02:01 <povman> Beelsebob: yes
02:02:12 <Beelsebob> in which case, it doesn't support them, no
02:02:15 <povman> Currently the only way to do that is wih exceptions
02:02:20 <Beelsebob> and I don't think there's even an extention to do it
02:02:26 <povman> :( sad face.
02:02:32 <Beelsebob> the problem I think is mostly instances
02:02:47 <Beelsebob> suppose you were to write data MyInts = Int{5-29} -- making up some syntax
02:02:54 <Beelsebob> the Num instance for Int no longer works
02:02:59 <Beelsebob> because you're not closed under addition
02:03:23 <Beelsebob> so as soon as you do that you ask the user to rewrite all the instances for the type
02:03:29 <mjrosenb> hey, is there any way to download the binary that one of the nightly builds produced?
02:04:12 <povman> Beelsebob: ah. I can see this now.
02:04:28 <Beelsebob> it would be nice to have that somehow though
02:05:03 <povman> It doesn't necessarily have to be _the same_ type though
02:05:11 <Beelsebob> true
02:05:13 <Saizan> povman: in theory you could probably implement them with phantom types and some type-level computations
02:08:15 <Saizan> or you can wait till haskell gets dependent types :)
02:08:44 <povman> Saizan: Whoa! I don't really understand those things, let alone how they could provide subtypes
02:08:48 <Associat0r> Saizan: when?
02:09:06 <mjrosenb> Saizan: is haskell actually going to get dependent types?
02:09:07 <povman> Unless you mean implementing type One; type Two; type Three etc
02:10:50 <Saizan> Associat0r, mjrosenb: i was mostly joking, but considering the trend of extensions it seems to go in that direction
02:11:01 <FunctorSalad_> 2010 is the year of dependent types on the desktop :D
02:12:56 <Saizan> povman: something like newtype Int a b = I (Prelude.Int), and then yeah, you'd specify ranges with types, like Int D1 (D1 (D5 0)) for the integers between 1 and 15
02:13:37 <Saizan> you'd need to redefine Num, because the types won't match
02:13:46 <povman> heh.
02:13:48 <povman> no.
02:14:01 <povman> That's a bit gross
02:14:29 <povman> p.s. would dependent types be good?
02:14:32 <Saizan> yeah, it's not so pretty
02:14:59 <Saizan> with dep. types you could just write Int 1 15 :)
02:15:19 <povman> That sounds neat, but is there a complication with having it in Haskell?
02:16:53 <povman> Hey, couldn't I do this with template haskell?
02:17:16 <povman> WHOA i so could!
02:17:30 <povman> and get conversion operators for free!
02:17:31 <povman> leet!
02:17:32 <FunctorSalad_> take a look at coq if you'd like to try dependent types
02:17:47 <Saizan> FunctorSalad_: coq has typeclasses too, right?
02:18:04 <FunctorSalad_> Saizan: yes, recently
02:18:05 <Saizan> though coq is more a proof assistant than a programming language
02:21:22 <portnov> @index foldM
02:21:22 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
02:23:21 <povman> So in essence, you provide the compiler with a way to check your code, and it will run it at compile time
02:23:28 <povman> ?
02:24:00 <povman> which isn't much different to writing compiler extensions or TH
02:25:30 <FunctorSalad_> the point is that types can depend on terms
02:25:51 <povman> But can't I write TH to generate a type based on parameters?
02:26:20 <FunctorSalad_> you can :)
02:26:53 <FunctorSalad_> but it is "outside the system"
02:27:43 <povman> What advantages come from being "inside the system"?
02:27:52 <povman> (in this situation)
02:28:31 <FunctorSalad_> haven't really thought about how TH relates to the type system
02:28:55 <astrolabe> I've been reading about coq recently, and there seems to be a massive amount to learn before you can do anything useful.
02:29:15 <astrolabe> (I use 'useful' in the loosest possible sense :)
02:29:46 <FunctorSalad_> astrolabe: I think you can just get going rather than reading the whole manual up-front
02:30:31 <astrolabe> FunctorSalad_: I'm reading coqart, but how could I just start when I don't know say, the syntax?
02:31:30 <FunctorSalad_> ok, you need the syntax :) but I mean once you have the basics, the interactive proof mode is nice for trying things
02:33:30 <astrolabe> FunctorSalad_: I'd like to ask you more, but I guess we should move to blah
02:34:10 <FunctorSalad_> ok
02:35:21 <povman> Well, for my purposes TH will do
02:35:33 <chrisdone> is there a unicode character for >>=?
02:36:09 <idnar> >>= isn't a real symbol, is it?
02:36:23 <chrisdone> I don't know. I see it in papers looking fancy
03:25:38 <a_guest> I use 'putStr' for prompting values in a interactive program. this doesn't seem to flush, to stdout. Should I flush manually, if so: how?
03:28:17 <hamishmack> a_guest: hFlush stdout
03:38:52 <Beelsebob> a_guest: also, hSetBuffering stdout NoBuffering
03:38:58 <Beelsebob> then you don't need to flush
03:39:31 <mmorrow_> if anyone's interested, i've got lunabot 91% organized and it's finally cabalified (albeit not quite a "turnkey" solution quite yet ;) http://moonpatio.com/repos/lunabot/
03:41:01 <mmorrow_> (all the various little "features" are buried in random places in Luna/Bot/Lib/* at the moment, that's the last bit of cleanup left)
03:41:35 <Raevel> any cool features?
03:42:23 <mmorrow_> it has eval, and uses QuasiQuoters/TemplateHaskell to implement to varying degrees some of the things lambdabot has implemented as plugins
03:42:34 <mmorrow_> , eval "eval \"42\""
03:42:43 <mmorrow_> and eval can see itself
03:42:46 <mmorrow_> oh noes
03:42:58 <mmorrow_> oh right, i forgot to rejoin it
03:43:44 <mmorrow_> (this lunabot is still the "old" original version though..)
03:43:52 <ColeSOAR> very noob question:  how do i apply a function to every element of a list?
03:43:54 <mmorrow_> ((there's basically no visible difference))
03:44:04 <Phillemann> Shouldn't "a `catch` (\_ -> return ())" ignore any exception that's thrown by 'a'?
03:44:13 <Raevel> ColeSOAR: map func list
03:44:19 <ColeSOAR> map!  lol
03:44:35 <ColeSOAR> i was trying to find a way to use zipWith and i'm like hey wait, i only have one list
03:44:48 <Raevel> :-)
03:45:30 <mmorrow_> , eval "eval \"42\""
03:45:34 <lunabot>  <<Dynamic>>
03:45:37 <mmorrow_> and
03:45:43 <mmorrow_> , src ''Maybe
03:45:46 <lunabot>  data Maybe a = Nothing | Just a
03:45:49 <mmorrow_> for :info
03:45:58 <mmorrow_> , [$bf|.+[.+]|]
03:46:01 <lunabot>  luna: No instance for (GHC.Show.Show
03:46:13 <mmorrow_> , [$ty| let fix f = let x = f x in x in fix |]
03:46:17 <lunabot>  forall a . (a -> a) -> a
03:46:35 <mmorrow_> , [$ty| (ty, [$tyQ| 42 \|]) |]
03:46:38 <lunabot>  (QuasiQuoter, Type)
03:47:27 <mmorrow_> , [$bf|.+[.+]|] ""
03:47:29 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
03:47:58 * mmorrow_ can't think of anything else
03:48:27 <mmorrow_> well, it's got vacuum too, and other various ghc-ish things to look at stuff
03:48:33 <mmorrow_> , vacuum (fix (0:))
03:48:36 <lunabot>  [(0,[1,0]),(1,[])]
03:48:45 <mmorrow_> , closureType $! (const 4)
03:48:47 <lunabot>  PAP
03:48:52 <mmorrow_> , closureType $! (1 + 1)
03:48:55 <lunabot>  Constr
03:49:13 <mmorrow_> , let !x = id () in closureType x
03:49:16 <lunabot>  Constr
03:49:35 <mmorrow_> , let xs = 0 : xs in closureType xs
03:49:38 <lunabot>  AP
03:50:51 <LeoD> @type vacuum
03:50:52 <lambdabot> Not in scope: `vacuum'
03:51:13 <mmorrow_> it's an adjacency list rep of the graph formed by heap closure and ptrs
03:51:27 <mmorrow_> http://moonpatio.com/vacuum/
03:51:47 <mmorrow_> , vacuum (fix (0:)) == vacuum (repeat 0)
03:51:50 <lunabot>  True
03:52:06 <mmorrow_> , vacuum (fix (\x -> Node () [x,x])
03:52:08 <lunabot>  luna: parse error (possibly incorrect indentation)
03:52:09 <mmorrow_> , vacuum (fix (\x -> Node () [x,x]))
03:52:11 <lunabot>  [(0,[1,2]),(1,[]),(2,[0,3]),(3,[0,4]),(4,[])]
03:52:35 <mmorrow_> , let x = 1 + 1 in vacuum (x,x)
03:52:37 <lunabot>  [(0,[1,1]),(1,[])]
03:52:42 <mmorrow_> , vacuum (1+1,1+1)
03:52:45 <lunabot>  [(0,[1,2]),(1,[]),(2,[])]
03:54:20 <mmorrow_> , [$ty| vacuum |]
03:54:23 <lunabot>  forall a . a -> [] ((Int, [] Int))
03:54:23 <mmorrow_> ;)
03:54:32 <mmorrow_> aww, prettyprinter fail..
03:55:19 <mmorrow_> ah! how could i forget
03:55:39 <mmorrow_> , [$pl| \a b c -> g (f a b) c |]
03:55:41 <lunabot>  (g .) . f
03:59:06 <Phillemann> I'm getting "address already in use" although I use Network.listenOn which, according to the documentation, sets ReuseAddr on the socket.
04:00:04 <Phillemann> This happens after I kill the (forkIO) thread which called the listenOn (and the accept). I call another listenOn on the same port immediately after that.
04:10:17 <eu-prleu-peupeu> :D
04:11:30 <ColeSOAR> i've got a list of tuples.  i want to only see the ones that have the 2nd value greater than 50
04:11:35 <ColeSOAR> go go haskells.
04:12:35 <Claudius1aximus> @type (filter, on, snd)
04:12:37 <lambdabot> forall a b c a1 a2 b1. ((a -> Bool) -> [a] -> [a], (b -> b -> c) -> (a1 -> b) -> a1 -> a1 -> c, (a2, b1) -> b1)
04:29:34 <list> does (,) have a name?
04:29:50 <Beelsebob> 2-tuple
04:29:55 <Beelsebob> is about as close as you can get
04:30:43 <Igloo> Or pair
04:31:10 <list> ah thanks
04:31:18 <Beelsebob> pair I don't like so much
04:31:19 <list> @pl (\p -> (getf p l, p))
04:31:19 <lambdabot> (,) =<< flip getf l
04:31:25 <Beelsebob> because it's inconsistant with (,,) and (,,,)
04:31:47 <Beelsebob> well, okay, you could also call them tripple and quadruple etc
04:32:08 <Beelsebob> but it gets awkward when you get to septdecdecle
04:32:12 <Beelsebob> etc
04:32:53 <Gracenotes> who says it has to be consistent :)
04:33:04 <Gracenotes> I like: pair, 3-tuple, 4-tuple, 5-tuple, etc.
04:33:30 <maltem> Larger tuples get awkward anyways
04:33:36 <Gracenotes> maybe s/3-tuple/triple/ depending on whim
04:39:47 <Beelsebob> Gracenotes: I say it does -- I like consistency :)
04:42:40 <Axman6> ok, so, suppose i wanted to write a proxy server app, where should i start to look for the http stuff?
04:42:56 <Botje> the HTTP lib?
04:43:22 <Axman6> sounds good to me
04:43:54 <LouisJB> hi, basic question, GHC for OSX, best to install via macports, the installer or it makes no difference?
04:45:27 <Axman6> i use macports, which also has a hs-cabal package which installs cabal-install
04:49:46 <LouisJB> great thanks, I've just kicked off that install now :)
04:50:06 <Axman6> might want to go make a cup of tea or three ;)
04:50:54 <eu-prleu-peupeu> what do you feel about F# ?
04:52:12 <maltem> Is building ghc from the git mirror repository currently supported? (I'm currently running sync-all and hoping)
04:53:47 <Axman6> i couldn't even check it out
04:54:33 <maltem> How so?
04:54:46 <Axman6> well, the checkout from the git repo kept failing
04:54:58 <maltem> hm, I fetched it from github initially
04:55:15 <maltem> Because it's way faster :)
04:56:11 <maltem> whoo, sync-all finished without an error, and really fast, considering it keeps calling darcs
04:59:37 <Raynes> F# is too FSharpy for me. :)
05:07:36 <thomastc> any idea why network-2.2.1.3 fails to build against a fairly recent GHC HEAD?
05:07:46 <thomastc> Network/Socket.hsc:1707:45: Not in scope: data constructor `System.Posix.Internals.Stream'
05:08:14 <thomastc> which is true, when I look at the GHC sources...
05:11:40 <thomastc> ah, got it, GHC.IO.Device, nvm
05:12:40 <Jedai> > deriv (\x -> sin x) 0
05:12:41 <lambdabot>   1.0
05:13:11 <Axman6> maltem: could you give me the address/command to fetch it from github my any chance?
05:14:14 <thomastc> hmm, many more errors now :(
05:14:16 <maltem> Axman6, git://github.com/ghc-hq/ghc.git
05:14:33 <Axman6> thanks
05:14:40 <ivanm> @seen sinelaw
05:14:40 <lambdabot> I saw sinelaw leaving #haskell 20h 37m 30s ago, and .
05:15:13 <thomastc> guess I'll just downgrade to stable ghc then
05:15:17 <maltem> Axman6, also, once you have it, you'll have to tweak the git remote setting to make sync-all happy
05:15:45 <maltem> git add remote official http://darcs.haskell.org/ghc.git
05:15:51 <Axman6> not sure what that means, but i'll be sure to ask when i run into problems ;)
05:16:03 <Axman6> ok, thanks
05:16:24 <maltem> and then
05:16:32 <maltem> git config branch.master.remote official
05:16:53 <Axman6> thanks :)
05:18:27 <maltem> Axman6, it means that the next time you git-fetch or git-pull, it will fetch from darcs.haskell.org. For some reason sync-all hasn't hardcoded darcs.haskell.org, but looks up this git setting
05:18:48 <maltem> I guess you could equally well edit sync-all
05:18:59 <Axman6> what's sync-all?
05:19:30 <maltem> The script in the ghc tree to fetch the libraries
05:19:42 <Axman6> ah ha
05:20:49 <maltem> There's also darcs-all, but that one looks up the name of darcs.haskell.org from the darcs setting, which will fail for obvious reasons
05:22:03 <Axman6> yeah
05:27:06 <mjrosenb> wait, why is ghc switching to git?
05:27:53 <maltem> mjrosenb, they aren't really
05:28:08 <maltem> mjrosenb, they just planned to, but now no one dares anymore
05:29:01 <Axman6> maltem: any idea about this?...
05:29:02 <Axman6> [Darwin] Axman:~/Haskell/ghc-head $ git add remote official http://darcs.haskell.org/ghc.git
05:29:04 <mjrosenb> maltem: that's good
05:29:05 <Axman6> fatal: pathspec 'remote' did not match any files
05:29:46 <maltem> Axman6, ah sorry, git remote add, not git add remote
05:29:53 <Axman6> ah, ta
05:35:44 <maltem> Hm, compiling ghc on a netbook is a little painful. Let's fetch some tea
05:37:22 <ColeSOAR> why are you guys so hard to understand?  is haskell for comp sci or math people only or something?
05:38:48 <ivanm> ColeSOAR: hmmm?
05:38:53 <ivanm> what makes us hard to understand?
05:39:05 <ColeSOAR> you guys just seem to talk about rll far out stuff when i look back
05:39:21 <ivanm> ColeSOAR: people do go on with more theoretic discussions at times
05:39:21 * maltem is sad. No one understands me!
05:39:24 <Axman6> rrl?
05:39:28 <Axman6> rll*
05:39:36 <ivanm> but we do come down off our lofty mountain tops when people ask a more basic question ;-)
05:39:41 <EvilTerran> yeah, we talk about weird theoretical stuff to pass the time, but you don't really need all that theoretical stuff to use haskell
05:39:46 <ivanm> Axman6: "really"?
05:40:06 <ivanm> EvilTerran: "to pass the time whilst waiting for more questions from new users"?
05:40:13 <Axman6> ColeSOAR: well, a lot of comp sci people use haskell, and it's a very mathematical language, so i guess...  but all languages can be hard to understand if you don't know what someone's talking about...
05:40:14 <Berengal> ivanm: I thought we lived in ivory towers, not mountains
05:40:30 <Axman6> C would be pretty damn hard if you didn't now what a variable was, let alone a pointer
05:40:40 <ivanm> Berengal: the ivory towers are up on the tops of the mountains
05:40:41 <ivanm> duh
05:40:41 <ivanm> ;-)
05:40:50 <ColeSOAR> i think that's the thing Axman6... a lot of the "stuff" in haskell is in real life, i.e. math or theoretical terms, so it doesn't sound as jargony.  it just sounds like i'm an idiot
05:40:53 <ivanm> Axman6: a what now?
05:40:53 <Berengal> Ah
05:40:59 <ivanm> what's this variable thingy you're talking about?
05:41:05 <ivanm> ;-)
05:41:07 <ColeSOAR> lol
05:41:15 <ivanm> ColeSOAR: if you just want to use it, then you don't need much math for haskell
05:41:15 <Axman6> ivanm: like an IORef :P
05:41:19 <jauaor> http://nopaste.info/72f3e0dd92.html
05:41:20 <jauaor> :D
05:41:28 <ivanm> if you want to get in-depth into how it works, etc. then you might have to
05:41:36 <Axman6> ColeSOAR: haskell's  not hard, andf it doesn't need a degree in maths to be useable
05:42:00 <ivanm> realistically, who really cares about the category theoretic basis of monads if you're writing a simple IO-based app?
05:42:14 <ivanm> Axman6: you mean my math degree is now useless!?!?!?! :o
05:42:16 <ivanm> :p
05:42:32 <Berengal> I actually find haskell's mathyness makes it easier than other languages
05:42:33 <Axman6> i've been using haskell for about 18 months now, and i still don't know what people are on about when they talk about category theory and stuff. it's all just a matter of practice
05:42:40 <Axman6> Berengal: me too
05:42:45 <Axman6> much less to think about
05:42:49 * ivanm three
05:42:57 <Axman6> ivanm: well and truly useless :P
05:43:03 <ivanm> :(
05:43:05 <Berengal> And I've only had one math course in uni...
05:43:10 * Axman6 got better marks than expected this semester :D
05:43:17 <ivanm> well, at least I didn't waste any time with any category theory courses...
05:43:18 <LambdaFred> @unpl nubBy(((>1) .) . gcd)
05:43:18 <lambdabot> nubBy (\ e h -> (gcd e h) > 1)
05:43:20 <ivanm> Axman6: :D
05:43:28 <ivanm> Berengal: out of how many courses?
05:43:42 <Axman6> two credits, one in a course i was just hoping for a pass, and HD's in both my comp courses :D
05:43:44 <ivanm> then again, most people doing an IT degree here only do the basic 1st year discrete math subject
05:43:46 <Berengal> ivanm: Eh... 7? 8?
05:44:00 <ivanm> just so they can learn basic boolean logic
05:44:09 <ivanm> actually, is there such a thing as non-basic boolean logic?
05:44:21 <ivanm> Axman6: what non-comp courses did you take?
05:44:26 <ivanm> Berengal: is that a year's worth?
05:44:42 <Axman6> engineering systems analysis (the one i thought i might fail), and electrical engineering
05:44:43 <Berengal> ivanm: Almost a year and a half
05:44:51 <ivanm> *nod*
05:44:58 <ivanm> Axman6: so you doing EE, IT or both?
05:45:04 <Axman6> i'm doing an Engineering/It double degree
05:45:12 <ivanm> *nod*
05:45:12 <Axman6> IT*
05:45:15 <Berengal> ivanm: I'm afraid my progression has been slower than anticipated, and now I've decided to take a year off
05:45:19 <Axman6> 5 years of fun :)
05:45:21 <ivanm> Berengal: how come?
05:45:32 <Axman6> actually, going to uni has made me want to become a lecturer :o
05:45:36 <ivanm> Axman6: well, it took me five years for my Sc/IT + Sc honours...
05:45:42 <ivanm> Axman6: me too
05:46:13 <Axman6> hmm, i should email one of my lecturers and see if he needs some more tutors
05:46:15 <Berengal> It was so incredibly boring. I learned all the CS material covered by the first year subjects in two weeks
05:46:29 <mjrosenb> hrmm, anyone know about bootstrapping ghc?
05:46:38 <Berengal> I've found I'm more of an autodidact
05:46:42 <ivanm> Axman6: I only ever tutored math subjects (including programming-based components, teaching *shudder* matlab *shudder*)
05:46:56 <Axman6> >_<
05:46:56 <ivanm> mjrosenb: well, I use the ebuild to do that... ;-)
05:47:15 <Axman6> wtf are all the maths software packages like mathematica, matlab etc so crappy?
05:47:21 <Saizan> IT = CS or is it something else?
05:47:25 <Axman6> they need nice syntax to begin with
05:47:31 <ivanm> Saizan: IT is more "realy world-y" than CS
05:47:32 <Axman6> Saizan: technically something else
05:47:41 <Axman6> i think i'd prefer CS though
05:47:51 <Saizan> mjrosenb: there's a guide on ghc's trac
05:47:52 <Axman6> but, needed an 98 UAI get into that, ha
05:48:05 <ivanm> Saizan: it's programming + project management + databases, whereas SE is usually just programming (and usually more rigorous than in IT)
05:48:16 <ivanm> Axman6: ANU has a CS degree still? :o
05:48:21 <Axman6> yep
05:48:23 <mjrosenb> Saizan: yes, unfortunately, it has the rather helpful line "You may also need to use make -k in order to ignore unimportant build failures in the RTS. "
05:48:24 <Axman6> CS Honours
05:48:32 <ivanm> at UQ, you have to do it as a major in either IT or Sci, though you don't have many pure CS courses to choose from :(
05:48:37 <ivanm> Axman6: oh, just honours
05:48:50 <Axman6> yeah, hence the 98 UAI restriction
05:49:04 * ivanm has no idea what UAIs are
05:49:08 <Axman6> i know a guy who got 99.94 UAI >_<
05:49:15 <Axman6> uni admissions index
05:49:54 <Saizan> hah, one day i'll understand US/UK/AU/something else? school system, assuming they are similar
05:50:48 <ivanm> Saizan: all states in AU have different systems ;-)
05:50:53 <LambdaFred> @src nubBy
05:50:53 <lambdabot> nubBy eq []             =  []
05:50:53 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:51:03 <ivanm> Saizan: hence my question to Axman6 ;-)
05:51:03 <mjrosenb> Saizan: i went to a us school, and i have no clue what these guys are talking about
05:51:08 <ColeSOAR> lol nubby
05:51:25 <ivanm> mjrosenb: we're from a land down under
05:51:27 <Axman6> i never understood why it was called nub
05:51:35 <EvilTerran> ?wn nub
05:51:38 <ivanm> Axman6: ancient egyptian word or something IIRC
05:51:41 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
05:51:42 <lambdabot> nub
05:51:42 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
05:51:42 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
05:51:42 <lambdabot>      3: the choicest or most essential or most vital part of some
05:51:43 <lambdabot> [5 @more lines]
05:51:45 <ColeSOAR> shouldn't that be a fold?
05:51:47 <Axman6> uniq or uniques would be easier to remember
05:51:49 <EvilTerran> @more
05:51:50 <lambdabot>         idea or experience; "the gist of the prosecutor's
05:51:50 <lambdabot>         argument"; "the heart and soul of the Republican Party";
05:51:50 <lambdabot>         "the nub of the story" [syn: {kernel}, {substance}, {core},
05:51:51 <lambdabot>          {center}, {essence}, {gist}, {heart}, {heart and soul}, {inwardness},
05:51:53 <lambdabot>          {marrow}, {meat}, {pith}, {sum}, {nitty-gritty}]
05:51:54 <ivanm> ColeSOAR: a fold is a way of reducing something
05:52:03 <EvilTerran> defn 3 is the relevant one, i think
05:52:07 <ivanm> actually, it's more to do with replacing constructors with values/functions
05:52:12 <ColeSOAR> oh yeah
05:52:13 <EvilTerran> "the choicest or most essential or most vital part of some idea or experience"
05:52:36 <ColeSOAR> it seems like that idiom is common enough to deserve its own functions too
05:52:43 * mjrosenb stabs adjustorCode and _adjustorCode
05:52:44 <ivanm> ColeSOAR: what, a fold?
05:52:47 <ivanm> there's heaps!
05:52:54 <ColeSOAR> no, building something recursively like that
05:53:07 <EvilTerran> unfold?
05:53:09 <ColeSOAR> using pattern matching, the : operator, and recursion
05:53:10 <ColeSOAR> lol
05:53:16 <ColeSOAR> yeah unfold!
05:53:19 <EvilTerran> ?type unfold
05:53:21 <lambdabot> Not in scope: `unfold'
05:53:22 <Axman6> :t unfoldl
05:53:24 <lambdabot> Not in scope: `unfoldl'
05:53:24 <EvilTerran> ?type unfoldr
05:53:26 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:53:27 <ColeSOAR> it makes more sense than fold, as a name
05:53:33 <ColeSOAR> the idea of unfolding makes fold make more sense to me
05:53:50 <Axman6> but it's folding a list up into a single value
05:54:05 <ivanm> mjrosenb: I've had a quick look through the ghc ebuild, and it doesn't seem to do much special for bootstrapping... >_>
05:54:06 <Axman6> i think of it like rolling up a sleeping bag
05:54:16 <EvilTerran> > unfoldr (\x -> if x > 1000 then Nothing else Just (x, 2*x)) 1
05:54:17 <Berengal> "reduce" could also work...
05:54:18 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
05:54:32 <Berengal> Hmmm, reduce/induce?
05:54:40 <ivanm> Berengal: though foldr and foldl sound better than reducer and reducel ;-)
05:54:48 <Berengal> ivanm: They sure do
05:54:53 * EvilTerran would've gone for fold/build, tbh
05:55:04 <ivanm> EvilTerran: build instead of unfold ?
05:55:09 <EvilTerran> yeah
05:55:21 <EvilTerran> altho istr build means something else in ghc terminology
05:55:31 <ivanm> @hoogle build
05:55:31 <lambdabot> Distribution.Simple.Build build :: PackageDescription -> LocalBuildInfo -> BuildFlags -> [PPSuffixHandler] -> IO ()
05:55:31 <lambdabot> Distribution.Simple.GHC build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
05:55:31 <lambdabot> Distribution.Simple.Hugs build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
05:55:39 <ivanm> *shrug* nothing obvious...
05:55:46 <Berengal> There should also be an alternative variant of unfoldr :: (b -> (a, b)) -> b -> [a]
05:55:50 <Berengal> For when you don't need Maybe
05:55:56 <ColeSOAR> reducer lol
05:56:13 <ColeSOAR> nubby reducer
05:56:38 <EvilTerran> ?type fmap fmap fmap
05:56:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:56:41 <mjrosenb> ivanm: this is ungeristerised bootstrapping, so i guess it is a different beast
05:56:50 <ivanm> mjrosenb: hmmm...
05:57:01 <Saizan> ?type GHC.Exts.build
05:57:03 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
05:57:17 <ivanm> Berengal: you do need Maybe
05:57:21 <ivanm> you have to know when to stop...
05:57:25 <ivanm> @src unfoldr
05:57:25 <lambdabot> unfoldr f b  = case f b of
05:57:26 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
05:57:26 <lambdabot>    Nothing        -> []
05:57:27 <Berengal> ivanm: You don't have to stop
05:57:30 <Berengal> Not always
05:57:34 <ivanm> Berengal: true
05:57:36 <EvilTerran> Saizan, ah, that's the "build" i was looking for. got something to do with fusion, doesn't it?
05:57:37 <ivanm> but usually you do
05:57:51 <Saizan> EvilTerran: yeah
05:57:54 <ivanm> EvilTerran: nuclear fusion? :p
05:58:00 <mjrosenb> gah
05:58:02 <ColeSOAR> jazz fusion?
05:58:15 <Saizan> EvilTerran: foldr f z (build g) = g f z
05:58:19 <EvilTerran> Berengal, so you're after "unfoldForever f = map fst . iterate (f . snd)" or something?
05:58:24 <mjrosenb> why is powerpc_HOST_ARCH set to 1 when i'm building this on amd64?
05:58:36 <Berengal> > unfoldr (\(x, y) -> Just (x, (y, x + y))) (0,1)
05:58:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:58:59 <Berengal> EvilTerran: Something similar, yes
05:59:04 <EvilTerran> ?type unfoldr . ((Just .).)
05:59:05 <lambdabot>     Couldn't match expected type `Maybe (a, b)'
05:59:05 <lambdabot>            against inferred type `a1 -> Maybe b1'
05:59:05 <lambdabot>     In the second argument of `(.)', namely `((Just .) .)'
05:59:07 <ColeSOAR> i dont know what it is, but it's beautiful
05:59:11 <LambdaFred> nubBy (\candidate prime -> candidate `mod` prime == 0) [2..]
05:59:16 <LambdaFred> > nubBy (\candidate prime -> candidate `mod` prime == 0) [2..]
05:59:17 <EvilTerran> ?type unfoldr . (Just .) -- did i get carried away there?
05:59:19 <lambdabot> forall b a. (b -> (a, b)) -> b -> [a]
05:59:19 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:59:57 <Saizan> mjrosenb: i think you want to ask such questions on #ghc (but not in weekends) or on ghc-users@
06:00:15 <LambdaFred> @pl nubBy (\candidate prime -> candidate `mod` prime == 0)
06:00:16 <lambdabot> nubBy (flip flip 0 . ((==) .) . mod)
06:01:02 <mjrosenb> Saizan: maybe i'll try the mailing list.  the only time i really have to muck around with this is on the weekend
06:01:07 <Axman6> flip flip 0, yet more proof that @pl and pointfree style is evil
06:01:14 <benmachine> @pl nubBy (\c p -> 0 == c `mod` p)
06:01:15 <lambdabot> nubBy (((0 ==) .) . mod)
06:01:20 <Berengal> @type flip flip 0
06:01:22 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
06:02:13 <Berengal> Ah, flip flip is the "other" way of making infix operators out of functions
06:02:19 <Berengal> > flip flip 8 mod 3
06:02:21 <lambdabot>   3
06:02:28 <benmachine> erm
06:02:31 <mjrosenb> does anyone happen to know if i can download a successfully built binary from one of the nightly builds?
06:02:48 <mjrosenb> Berengal: that seems to be backwards
06:02:57 <Berengal> mjrosenb: "other" means "speshul"
06:02:58 <benmachine> > 8 `mod` 3
06:03:00 <lambdabot>   2
06:03:09 <Berengal> > flip flip 3 mod 8
06:03:10 <lambdabot>   2
06:03:23 <soupdragon> > flip flip 8 (flip mod) 3
06:03:25 <lambdabot>   2
06:03:27 <Saizan> mjrosenb: see under developement snapshots http://www.haskell.org/ghc/download.html
06:03:34 <ColeSOAR> > flip flip 'u' elem "The brown fox gutted my arse"
06:03:36 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:03:46 <LambdaFred> @src gcd
06:03:47 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
06:03:47 <lambdabot> gcd x y = gcd' (abs x) (abs y)
06:03:47 <lambdabot>    where gcd' a 0  =  a
06:03:47 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
06:03:49 <Berengal> In the case of mod, this might be somewhat useful, since I usually want to curry the second argument
06:04:33 <mjrosenb> Saizan: there are builds listed in 'check build status' that are not listed in 'download snapshot distribution'.
06:04:51 <soupdragon> > flip (flip . flip) 8 mod 3
06:04:52 <lambdabot>   2
06:05:40 <LambdaFred> @pl \prime candidate -> gcd prime candidate > 1
06:05:40 <lambdabot> flip flip 1 . ((>) .) . gcd
06:05:52 <LambdaFred> @pl \prime candidate -> gcd candidate prime > 1
06:05:53 <lambdabot> flip flip 1 . ((>) .) . flip gcd
06:06:25 <Saizan> > flip id 8 mod 3
06:06:27 <lambdabot>   2
06:07:16 <mjrosenb> let inf = flip id in inf 8 mod 3
06:07:17 <benmachine> :T flip id
06:07:22 <mjrosenb> > let inf = flip id in inf 8 mod 3
06:07:23 <lambdabot>   2
06:07:32 <benmachine> :t flip id
06:07:33 <lambdabot> forall b c. b -> (b -> c) -> c
06:08:42 <soupdragon> :t [id,flip . flip]
06:08:43 <lambdabot> forall a b c. [(b -> a -> c) -> b -> a -> c]
06:08:50 <soupdragon> :t flip . flip
06:08:51 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
06:09:18 <mjrosenb> Saizan: noplace to get those tarballs?
06:09:53 <Saizan> mjrosenb: i don't know, sorry :)
06:11:07 <ColeSOAR> have any of you done any simulated annealing in haskell?
06:11:44 <Axman6> can't say i have
06:12:42 <mjrosenb> ColeSOAR: http://lisperati.com/haskell/
06:13:32 <Axman6> never seen that tutorial before
06:14:01 <mjrosenb> Axman6: i found it a while ago, mostly by some hilarious comic that he also made
06:14:12 <Axman6> heh, ok
06:14:25 <Axman6> looks quite similar to lyah in style
06:14:39 <ColeSOAR> wow i can learn simmulated annealing and haskell at the same time
06:14:49 <ColeSOAR> thank you very much mjrosenb
06:20:52 <osaunders> I've been trying Haskell out in GHCi. How can I compile files now? A hello world perhaps?
06:21:00 <Axman6> using ghc
06:21:26 <osaunders> I've got a file that just has 1 + 1
06:21:31 <osaunders> saved as addition.hs
06:21:42 <osaunders> $ ghc addition.hs
06:21:49 <osaunders> gives: addition.hs:1:12: parse error (possibly incorrect indentation)
06:22:02 <Vanadium> It probably ought to have main = print (1 + 1)
06:22:16 <Axman6> well that's not a properly formatted program, what do you expect the result of compiling that to me?
06:22:27 <Axman6> be*
06:22:36 <Vanadium> Also possibly ghc --make, but I am not quite sure about that
06:22:39 <osaunders> Vanadium: thanks :-)
06:22:40 <mjrosenb> Vanadium: main = print (1+1)
06:23:22 <Axman6> main = print 2
06:23:30 <Saizan> and yeah, use --make
06:23:31 <Axman6> main = putStrLn "2"
06:23:35 <Vanadium> Axman6: Micro-optimisations!
06:23:39 <osaunders> Why use make?
06:23:42 <ivanm> mmorrow_: you around?
06:23:49 <ivanm> osaunders: it actually creates the executable
06:23:55 <ivanm> rather than just the object files
06:24:00 <Saizan> osaunders: it'll be needed once you start using additional packages
06:24:04 <Axman6> osaunders: you don't need to use it there, but you will once you start including libraries. it just makes life easier
06:24:17 <ivanm> it will also pull in any other files (called modules in haskell speak) it needs in the same directory
06:24:33 <osaunders> OK, cool. Thanks guys.
06:24:48 <ivanm> it also gives it a better name than a.out ;-)
06:24:54 <osaunders> Without out make it produced a file a.out which was executable.
06:25:07 <osaunders> But with make I got one called addition
06:25:15 <ivanm> osaunders: your file was called addition.hs ?
06:25:29 <osaunders> Yeah
06:25:34 <Axman6> this code confuses me somewhat:
06:25:36 <Axman6> let readPoint :: String -> Point readPoint s | Just [x,y] <- matchRegex (mkRegex "([0-9.]+),([0-9.]+)") s = (read x,read y)
06:25:46 <Axman6> there's a new line after Point
06:26:10 <Axman6> is that usoing a guard on a pattern match?
06:26:14 <ivanm> that's a pretty weird way of doing it
06:26:18 <Axman6> yah
06:26:30 <osaunders> ivanm: $ diff a.out addition # says they are the same. But whatever, I'll use --make
06:26:35 <ivanm> Axman6: looks almost monadic :s
06:26:49 <ivanm> osaunders: for single file apps, it doesn't make a difference baring the name
06:26:58 <Axman6> somewhat elegant, but certainly not common
06:27:00 <ivanm> if you go to multi-file apps, --make is usually better
06:27:03 <Axman6> seems almost perlish
06:27:09 <ivanm> Axman6: does it use an extension?
06:27:18 <Axman6> doesn't seem to
06:27:25 <ivanm> because I don't recall ever seeing <- in a guard expression :s
06:28:15 <Axman6> me either
06:28:35 <Tobsan> is there a function behaving like a recursive splitAt? That is: splitUp :: Int -> [a] -> [[a]]
06:29:02 <Axman6> there's a library that provides that, and many more things...
06:29:09 <Tobsan> such that splitUp 2 [1..10] = [[1,2],[3,4],[5,6]..]
06:29:18 <ivanm> @ask mmorrow_ is there a way in prettyprint that you know of that I can have a function that given a multi-line Doc (or even just a [Doc]), I can have another Doc in front of it and indent the other one so that they don't overlap (e.g. I have a list spread over multiple lines, and I want to prepend (text "a = ") and indent the list)
06:29:18 <lambdabot> Consider it noted.
06:29:35 <soupdragon> Tobsan what do you use it for?
06:29:52 <Tobsan> soupdragon: currently, a sudoku solver
06:29:55 <ivanm> soupdragon: I've done soemthing like that when turning a list into a 2D "matrix"
06:29:58 <Tobsan> but I'm sure it could be useful
06:30:07 <ivanm> Tobsan: heh, have you seen the list of sudoku solvers on the wiki page?
06:30:24 <ivanm> the one by Bird there has a function that does that very thing IIRC...
06:30:33 <Tobsan> ivanm: aha!
06:30:36 * ivanm can't recall if it was already there or he hacked it in when he was playing with it...
06:30:41 <Tobsan> I better have a look then
06:30:52 <ivanm> Tobsan: is this just for personal interest?
06:31:04 <Tobsan> ivanm: yes
06:31:18 <osaunders> Is print not considered IO? I haven't learnt about monads yet but isn't print side-effecting?
06:31:35 <burp> :t print
06:31:36 <ivanm> osaunders: it is IO...
06:31:37 <lambdabot> forall a. (Show a) => a -> IO ()
06:31:37 <mjrosenb> osaunders: it is
06:31:48 <Axman6> :t print
06:31:49 <lambdabot> forall a. (Show a) => a -> IO ()
06:31:58 <ivanm> Axman6: didn't you see burp do that already?
06:32:05 <Axman6> yeah, just realised that
06:32:09 <ivanm> heh
06:32:13 <mjrosenb> :t print
06:32:14 <ivanm> read before hitting enter! :p
06:32:14 <lambdabot> forall a. (Show a) => a -> IO ()
06:32:16 <Tobsan> ivanm: aha, the "chop" function!
06:32:21 <ivanm> yeah, something like that
06:32:46 <Axman6> osaunders: have you seen do-notation before?
06:32:56 <osaunders> Axman6: no
06:33:27 <osaunders> I'm up to recursion in Learn a Haskell for Great Good.
06:33:47 <Axman6> righto. well, if you're interested, i've written a short tutorial on IO in haskell that you might find a good place to start with: http://random.axman6.com/blog/?page_id=70
06:34:45 <osaunders> Is do sequential?
06:34:48 <ivanm> Axman6: does the 6 actually mean anything in your nick?
06:34:53 <ivanm> osaunders: yes
06:35:02 <ivanm> Axman6: maybe let him finish one tutorial first ;-)
06:35:07 <osaunders> Ah OK.
06:35:09 <ivanm> even if it does have a questionable name... >_>
06:35:21 <osaunders> ivanm: Yeah :-) Although it would be nice to actually output stuff too.
06:35:36 <Axman6> axman@hotmail.com was taken when i was 12, and 6 was my favourite number at the time :P
06:35:43 <osaunders> lol
06:35:47 <Tobsan> Axman6: haha
06:35:48 <osaunders> Great reason xD
06:35:54 <ivanm> Axman6: and so you base your online identity from your hotmail address? :o
06:36:17 <Axman6> got a better way to do it? ;)
06:36:26 * ivanm tries to have nothing to do with his hotmail addy, though still has a couple of die-hard friends still using it for MSN
06:36:50 <ivanm> Axman6: well, since I can see some correspondence between your nick and your actual name, I can't use that rant on you... >_>
06:37:04 <osaunders> I was called ole for ages because when I was 5 I thought ole was a more sensible way of spelling my real name: Ollie.
06:37:13 <maltem> humph. my ghc build fails on backslashes when generating the manual
06:37:48 <ivanm> osaunders: because of course, all 5 year olds can spell properly and you should always listen to them... ;-)
06:38:22 <osaunders> ivanm: I guess I just thought it was cooler.
06:38:33 <osaunders> I certainly didn't think I could spell at that age.
06:38:50 * osaunders goes back to tutorial.
06:38:59 <ivanm> Axman6: well, I think your blog has been #haskell-ed... it doesn't want to load :s
06:39:09 <mxweas> /me test
06:39:11 <Axman6> :\
06:39:26 <ivanm> wait, it's just ff
06:39:33 <ivanm> opera loads it properly, but not ff :s
06:39:36 <Axman6> loads fine here, but they are having problems at the hosting company
06:39:39 <ivanm> @slap ff
06:39:40 <lambdabot> why on earth would I slap ff?
06:39:54 <Axman6> because it f'ing sucks!
06:40:17 <ivanm> Axman6: did you steal your blog name off someone else though?
06:40:27 <ivanm> IIRC ekidd used to have something like Data.Random as his title...
06:41:05 <mjrosenb> ivanm: the correct response is '/me pees on sully'
06:41:24 <mjrosenb> ivanm: better yet, go into #cslounge, and say that
06:41:36 <ivanm> wtf?
06:41:54 <ivanm> I usually urinate in a toilet, not on people...
06:43:29 <Axman6> ivanm: not that i know of, and i did try googling it before using it
06:44:53 <ivanm> nah, not him (his blog is called Random Hacks though)
06:45:02 <ivanm> maybe it was someone with a blog title of Random.IO ? *shrug*
06:45:03 <erisco> @src foldr
06:45:03 <lambdabot> foldr f z []     = z
06:45:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:45:16 <erisco> @src foldl
06:45:16 <lambdabot> foldl f z []     = z
06:45:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:45:19 <ivanm> s/z/y/g ;-)
06:45:26 <osaunders> What's comment in Haskell?
06:45:32 <Axman6> -- comment
06:45:33 <ivanm> osaunders: -- one line comment
06:45:35 <erisco> -- or {- and -}
06:45:39 <mjrosenb> ivanm: he's a friend who is spending the summer working for mozilla.
06:45:40 <ivanm> {- multi line -}
06:45:43 <Axman6> or {- commends for more than one line -}
06:45:46 <Axman6> t*
06:45:46 <osaunders> erisco: ty
06:45:48 <ivanm> mjrosenb: ahhh
06:45:51 <mjrosenb> ivanm: whenever firefox misbehaves, we blame him
06:45:54 <osaunders> Axman6: ty
06:45:54 <ivanm> heh
06:46:03 <mjrosenb> and that is the standard punishment
06:46:42 <mmorrow_> ivanm: i think you could do something like
06:46:43 <lambdabot> mmorrow_: You have 1 new message. '/msg lambdabot @messages' to read it.
06:47:23 <ivanm> mmorrow_: see, if only you had the decency to respond after I binged you, I wouldn't have to bother @ask'ing you ;-)
06:47:32 <mmorrow_> heh
06:47:45 <mjrosenb> ivanm: binged?
06:47:54 <mjrosenb> ivanm: is this some new-fangled euphamism?
06:47:57 <ivanm> *pinged
06:48:02 <mjrosenb> :-p
06:48:05 <ivanm> mjrosenb: it's an old-fangled type
06:48:07 <ivanm> *typo
06:48:12 <ivanm> just like that one was! ;-)
06:48:14 <mmorrow_> , (\pre labels -> pre $+$ nest 2 (vcat labels)) (text "a" <+> equals) [int 1, int 2]
06:48:16 <lunabot>  a =
06:48:16 <lunabot>    1
06:48:16 <lunabot>    2
06:48:26 <mmorrow_> you mean like that?
06:48:33 <osaunders> What's literate Haskell all about?
06:48:37 <mmorrow_> ($+$ + nest)
06:48:50 <Cale> osaunders: comments are the default, and you mark code lines
06:48:57 <Axman6> osaunders: basically makes the comments the main part of the code, and the code is special
06:49:02 <ivanm> osaunders: basically a way of focussing on the documentation rather than the code
06:49:12 <ivanm> osaunders: some people also use it to write papers with runnable code in them
06:49:14 <osaunders> This channel is so great.
06:49:22 <osaunders> Oh sweet.
06:49:29 <mjrosenb> osaunders: if yuo do it correctly, it'll also let you render you comments as latex
06:49:52 <osaunders> Also sweet.
06:49:52 <ivanm> mjrosenb: well, if you use kosmikus' app, which I can't remember the name of :s
06:49:55 <Axman6> i find the LaTeX version of literate haskell to be quote ugly
06:50:22 * mjrosenb is still attempting to install ghc on his desktop
06:50:25 <ivanm> mmorrow_: I was looking for a way of having the list on the RHS of the equal, but I suppose I can do it that way
06:50:33 <Axman6> mjrosenb: what OS?
06:50:34 * mjrosenb will worry about lhs later
06:50:34 <ivanm> Axman6: yeah, bird tracks ftw!
06:50:40 <mjrosenb> Axman6: linux
06:50:51 <Axman6> ivanm: indeed
06:50:53 <ivanm> lhs2tex, that's the one
06:50:59 <Axman6> makes for nicer blog posting too
06:51:02 <ivanm> yeah
06:51:04 <Igloo> linsur
06:51:31 <ivanm> my first document in lhs2tex, I thought it had to be in latex style... *shudder*
06:51:37 <Axman6> didn't even know you frequented this channel Igloo, thought you were a #ghc only worrior
06:51:55 <mjrosenb> Igloo: hey, was it you that did all the work for making ghc-6.11 unregisterisable again?
06:52:54 <Igloo> mjrosenb: Not sure what you mean exactly, but maybe
06:53:16 <Igloo> Axman6: I mostly only lurk here nowadays
06:53:31 <ivanm> Axman6: well, I can find 505 messages by him (not counting the last two) in my logs...
06:53:55 <mjrosenb> Igloo: so for a while, ungeristerised builds needed <ghc-6.8
06:53:58 <ivanm> containing almost 950000 lines in them though :s (so he isn't a high-level commenter... >_>)
06:54:24 <mjrosenb> Igloo: now the wiki has directions that will only work with >=ghc-6.11
06:54:26 <ivanm> that's only Igoo, not any underscore-appended version though ;-)
06:54:31 <Igloo> mjrosenb: Ah, you mean porting? Yes
06:54:38 <mmorrow_> , (\pre labels -> pre <+> vcat labels) (text "a" <+> equals) [int 1, int 2]
06:54:39 <lunabot>  a = 1
06:54:39 <lunabot>      2
06:54:50 <mjrosenb> Igloo: sweet
06:54:51 <mmorrow_> in that case you don't even need the nest
06:55:03 <Igloo> ivanm: 505 in how long?
06:55:06 <mjrosenb> i have a question about AdjustorAsm.S.
06:55:12 <mmorrow_> , (\pre labels -> pre <+> braces (vcat labels)) (text "a" <+> equals) [int 1, int 2]
06:55:13 <lunabot>  a = {1
06:55:13 <lunabot>       2}
06:55:27 <mmorrow_> , (\pre labels -> pre <+> (braces . punctuate semi) (vcat labels)) (text "a" <+> equals) [int 1, int 2]
06:55:28 <ivanm> Igloo: my logs are from Mar 26 last year; note that I'm not always online though ;-)
06:55:28 <lunabot>  luna: Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
06:55:32 <ivanm> and I only record when I'm online
06:55:42 <mmorrow_> , (\pre labels -> pre <+> (braces . vcat . punctuate semi) labels) (text "a" <+> equals) [int 1, int 2]
06:55:44 <lunabot>  a = {1;
06:55:44 <lunabot>       2}
06:56:02 <ivanm> mmorrow_: :o didn't know <+> would indent the whole thing like that... :D
06:56:12 <Igloo> mjrosenb: I don't know much about that, but doesn't libffi obsolete it?
06:56:21 <mmorrow_> ivanm: yeah, that probably the nicest part of the whole thing i think
06:56:56 <mjrosenb> Igloo: maybe? it's still trying to be built, and it seems to have some confusion about build arch / host arch
06:57:02 <ivanm> hmmmm..... now, if only puncutation had a flipped version, that did [d1, p <> d2, p <> d3, ... , p <> dn] ...
06:57:31 <mjrosenb> ivanm: flip!
06:57:42 <mmorrow_> ivanm: yeah i end up wanting variations on `punctuate' a bunch, but usually end up just using punctuate out of laziness
06:57:49 <ivanm> mjrosenb: flip doesn't really apply here...
06:57:51 <ivanm> mmorrow_: heh
06:57:51 <mjrosenb> :-p
06:57:53 <Igloo> mjrosenb: Ah, so you're trying to do a port and it's failing to build on the host machine?
06:58:05 <mjrosenb> Igloo: yeah.
06:58:27 <ivanm> OK, punctuate doesn't use a fancy fold or anything
06:58:29 <Igloo> mjrosenb: RTS build failures on the host aren't critical to the porting process, so you might need to use make -k and just ignore them
06:58:38 <Igloo> mjrosenb: What port are you doing?
06:58:54 <mjrosenb> Igloo: ppc64-unknown-linux
06:59:09 * ivanm heads off to the land of nod
06:59:16 <mjrosenb> Igloo: make -k still bails out after it's done getting a bunch of errors in rts
06:59:18 <Axman6> g'night ivanm
06:59:34 <mmorrow_> yeah punctuate and variations are a pita because you have to do them manually on account of those pesky border cases
06:59:41 <Igloo> mjrosenb: As long as it's made all the .hc files, that's not a problem
07:00:01 <mjrosenb> Igloo: does it actually need to go through the whole mess with the stage2, or can i just tar everything up right after the rts has completely failed to build?
07:00:15 <mmorrow_> night
07:00:31 <mjrosenb> mmorrow_: night
07:00:31 <Igloo> mjrosenb: It needs to compile the stage2 .hs files, so that .hc files are compiled, but it doesn't need to link stage2
07:01:05 <mjrosenb> Igloo: oh.  that should probably be a bit more clear on the wiki
07:01:25 <Igloo> mjrosenb: Happily, it's a wiki, so you can clarify it  :-)
07:03:13 <mjrosenb> Igloo: right after i get this to actually work
07:03:51 <mjrosenb> Igloo: as long as nobody is going to murder me, i'd love to replace <T>$ with something that bash will ignore
07:05:08 <Igloo> mjrosenb: Sounds good to me
07:07:06 <mjrosenb> Igloo: also, when i'm running stuff on the target machine for the second time, should i have a fresh tree?
07:07:44 <Igloo> mjrosenb: I don't think it matters
07:08:51 <mjrosenb> Igloo: ok, because a bunch of the random setup commands are duplicated
07:10:56 <Igloo> Personally I use a separate tree, just so I don't have to think about it  :-)
07:11:23 <mjrosenb> Igloo: that's what i'm doing
07:12:23 <erisco> @src reverse
07:12:24 <lambdabot> reverse = foldl (flip (:)) []
07:12:54 <Axman6> heh
07:13:04 <Axman6> i remember seeinf that definition for the first time
07:13:12 <Axman6> @unpl reverse = foldl (flip (:)) []
07:13:13 <lambdabot> reverse = foldl (\ b c -> (:) c b) []
07:25:27 <osaunders> How can I print without showing the quotes around a string?
07:25:39 <Vanadium> putStrLn?
07:27:03 <mjrosenb> or putStr if you don't want the newlines
07:27:13 <Axman6> @src print
07:27:14 <lambdabot> print x = putStrLn (show x)
07:27:44 <mjrosenb> >show "hello world"
07:27:53 <mjrosenb> > show "hello world"
07:27:54 <lambdabot>   "\"hello world\""
07:28:31 <osaunders> Thanks. I'm not getting it to work but I think that's my fault.
07:28:46 <Axman6> well feel free to share your problems with us
07:29:13 <Badger> Hello. My name is Badger, and I'm an alcoholic.
07:29:43 <osaunders> OK I've got this main = [ putStrLn x | x <- permutationsOf3 "abc" ] -- I think the problem is that main isn't getting the type it needs or something. The return of the list comprehension is a problem I think.
07:30:00 <Axman6> well yes
07:30:06 <Axman6> :t [ putStrLn x | x <- permutationsOf3 "abc" ]
07:30:06 <mjrosenb> Badger: Badger Badger Badger Badger Badger Badger
07:30:07 <lambdabot> Not in scope: `permutationsOf3'
07:30:15 <Axman6> :t [ putStrLn x | x <- id "abc" ]
07:30:17 <lambdabot>     Couldn't match expected type `String' against inferred type `Char'
07:30:17 <lambdabot>     In the first argument of `putStrLn', namely `x'
07:30:17 <lambdabot>     In the expression: putStrLn x
07:30:24 <Axman6> :t [ putStrLn x | x <- show "abc" ]
07:30:25 <lambdabot>     Couldn't match expected type `String' against inferred type `Char'
07:30:26 <lambdabot>     In the first argument of `putStrLn', namely `x'
07:30:26 <lambdabot>     In the expression: putStrLn x
07:30:28 <Axman6> urgh
07:30:49 <Axman6> :t [ putStrLn x | x <- map show "abc" ]
07:30:51 <lambdabot> [IO ()]
07:30:56 <Axman6> ok, that's better
07:30:57 <bgs100> Gr... this module won't import/load
07:31:04 <osaunders> Oh wow I just realised what lambdabot does!
07:31:11 <Axman6> heh
07:31:19 <Badger> > [putStrLn x|x <- map show "abc"]
07:31:20 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>]
07:31:25 <Axman6> osaunders: ghci does most of what lambdabot does too
07:31:34 <Axman6> Badger: how interesting...
07:31:38 <osaunders> Yeah but it's very cool just to have in channel like that.
07:31:49 <mjrosenb> osaunders: it unlambda-fies things.  a rather misleading name if you ask me
07:31:49 <Badger> Axman6: it is?
07:32:00 <Philonous> Is System.IO.(>>=) strict in it's left argument?
07:32:20 <Axman6> yeah, i just thought the <IO ()> stuff was output whenever IO was used
07:32:40 <Beelsebob> Philonous: no
07:33:48 <osaunders> Axman6: I need to learn about IO before I can understand what's going on here I think.
07:33:53 <Beelsebob> evidence: main = writeFile "jam.txt" =<< readFile "jam.txt" -- causes death in the form of jam.txt still being locked when you try to write into it
07:34:20 <Philonous> So in " return $! foo >== \_ -> bar" doesn't evaluate foo ?
07:34:35 <Axman6> osaunders: well, take a look at that tutorial of mine, and let me know what you think :)
07:34:36 <Philonous> I mean (>>= )
07:34:55 <Beelsebob> Philonous: it doesn't -- note, that is not the same as the action that it results in not having a sequencing effect
07:34:59 <osaunders> Axman6: In due course, I gladly will.
07:35:36 <Axman6> anyway, the problem you're having is that main needs to be of type IO a, but you're making its type [IO ()]
07:35:53 <Philonous> Beelsebob: So evaluationg the action would then also force foo?
07:36:13 <Beelsebob> Philonous: not necessarily  see the readFile >>= writeFile example
07:36:15 <Axman6> osaunders: it's written for complete beginners btw, people at about your stage of haskell learning, who are running into IO problems and have no idea why
07:36:28 <osaunders> Axman6: Hm, OK.
07:36:31 <Axman6> and it's only about 5-10 mintues long
07:36:42 <Beelsebob> Philonous: the result is that as much sequencing as necessary happens, but that the values inside the IO are still lazy
07:37:12 <Beelsebob> the side effects happen in order, but the value's computation does not
07:37:25 * Beelsebob notes that this is actually the bug with readFile -- the side effects are not sequenced
07:37:30 <Beelsebob> it's got nothing to do with IO being lazy
07:38:06 <Vanadium> Why are they not sequenced :C
07:38:19 <Philonous> How can I remedy this? I mean how can I force the evaluation of an expression in IO?
07:38:53 <Berengal> IO is strict
07:39:11 <Berengal> readFile is lazy, but that's not the default
07:39:15 <Saizan> Philonous: )do let x = expr; x `seq` return x) >>= \x -> here x is forced
07:39:16 <Berengal> It uses unsafeInterleaveIO
07:39:39 <Saizan> Berengal: it's strict in the side effects, but not necessarily in the values
07:40:17 <Beelsebob> @src interact
07:40:18 <lambdabot> interact f = do s <- getContents; putStr (f s)
07:40:18 <Saizan> (btw, there x is forced as far as its outermost constructor)
07:40:24 <Beelsebob> @src getContents
07:40:24 <lambdabot> getContents = hGetContents stdin
07:40:30 <Beelsebob> @src hGetContents
07:40:30 <lambdabot> Source not found. Just try something else.
07:40:41 <Berengal> Saizan: It's strict in that _|_ >>= foo = _|_
07:40:52 <Vanadium> Why does a <- readFile "foo" ; a `seq` writeFile "foo" a not work?
07:41:13 <Beelsebob> Vanadium: becauese all you're forcing with that seq is the first cons cell in the list
07:41:14 <Saizan> Berengal: sure, but return _|_ >>= foo = foo _|_
07:41:19 <Beelsebob> you need rnf, not seq
07:41:20 <Philonous> Saizan: That's equivalent to saying return $! foo >>= \_ -> ..., no?
07:41:24 <Vanadium> Oh, duh.
07:41:33 <Vanadium> I figure it would work if I used ByteStrings?
07:41:34 <Philonous> @src ($!)
07:41:35 <lambdabot> f $! x = x `seq` f x
07:41:38 <Vanadium> @src rnf
07:41:39 <lambdabot> Source not found. Where did you learn to type?
07:41:43 <Berengal> Saizan: return _|_ /= _|_
07:41:43 <Beelsebob> Vanadium: no, bytestrings also have structure
07:41:56 <Saizan> Philonous: do you mean (return $! foo) >>= \_ -> with that?
07:41:57 <maltem> strict bytestrings don't
07:42:13 <Philonous> Saizan: Indeed.
07:42:13 <Beelsebob> maltem: true true
07:42:19 <Vanadium> I have no idea what is going on anymore
07:42:22 <Saizan> Berengal: sure, but saying "IO is strict" is ambiguous
07:42:33 <Saizan> Philonous: yes, it's the same
07:42:48 <Berengal> Saizan: Yeah. Anyway, readFile, getContents etc. aren't strict in their side-effects either
07:43:45 <Saizan> Philonous: but "return $! (undefined:undefined)" is the same as "return (undefined:undefined)" because seq forces only the outermost constructor
07:43:53 <Saizan> Philonous: so maybe you want something more?
07:44:28 <Philonous> Actually I'm using return $! rnf foo.
07:44:52 <Saizan> ok, that should force foo completely
07:46:50 <Vanadium> ... what is rnf and where do I get it and is that really necessary to get this trivial readFile/writeFile thing working as naively expected? :C
07:47:13 <Saizan> rnf means "reduce to normal form"
07:47:22 <Saizan> i.e. evaluate completely
07:47:25 <maltem> Vanadium, I'd just use the strict bytestring variant of readFile to have it behave
07:47:32 <Saizan> you can find it in Control.Parallel.Strategies
07:48:05 <Vanadium> Oh god parallelism
07:48:20 <maltem> Vanadium, that is, Data.ByteString.readFile
07:48:30 <Saizan> well, that it's defined there is kind of accidental
07:48:40 <maltem> Vanadium, which will read the file all at once
07:49:38 <Saizan> Beelsebob: is there an instance where _|_ >>= f /= _|_? otherwise >>= is strict in it's left argument.
07:49:48 <Vanadium> So does ByteString use rnf internally?
07:50:19 <Saizan> no
07:50:21 <maltem> Vanadium, actually no, it does not the stupid stuff that Prelude.readFile does, and thus does not need rnf
07:50:41 <Vanadium> @src Data.ByteString.readFile
07:50:42 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:50:44 <Vanadium> >:[
07:50:58 <Vanadium> Where do I look up what exactly either of them do?
07:50:58 <Saizan> the strict ByteString variant, the lazy one does use unsafeInterleaveIO
07:51:00 <Berengal> Is there no strict version of readFile for String?
07:51:18 <Saizan> Berengal: no :\
07:51:29 <maltem> Berengal, unpack . readFile :)
07:51:40 <maltem> (strict in its side-effects)
07:51:41 <Vanadium> Oh, unsafeInterleaveIO actually explains it and makes more sense than it did when I first read the description.
07:51:43 <Saizan> Vanadium: http://haskell.org/ghc/docs/latest/html/libraries/index.html <- the docs here have source links
07:51:53 <Berengal> maltem: Probably the best solution anyway :)
07:53:59 <Vanadium> The rnf source is not exactly enlightening :3
07:54:19 <Vanadium> Sure expected it to be more magical.
07:54:48 <Saizan> Vanadium: rnf is a class method, you've to implement it specifically for each type
07:55:00 <Saizan> seq is compiler magic instead
07:55:06 <maltem> I feel a little like we should in general suggest strict bytestrings to newbies for doing I/O. Even in tutorials. It saves us from explaining the magics of interleaved I/O, which aren't really related to Haskell the language
07:55:57 <Saizan> maltem: easier solution: make readFile strict and offer another variant with a disclaimer :)
07:56:34 <maltem> yeah
07:56:48 <maltem> Prelude.readFile should really be non-magical
07:57:33 <Berengal> I am frequently torn between convenience, elegance and newbie-friendlyness...
07:57:34 <LambdaFred> > nubBy (((>1) . ) . gcd) [2..] !! 10001
07:57:40 <lambdabot>   mueval-core: Prelude.read: no parse
07:57:40 <lambdabot>  mueval: ExitFailure 1
07:57:45 <LambdaFred> > nubBy (((>1) . ) . gcd) [2..] !! 1001
07:57:51 <lambdabot>   mueval-core: Prelude.read: no parse
07:57:51 <lambdabot>  mueval: ExitFailure 1
07:57:52 <Berengal> I like readFile, it's nifty for short snippets
07:57:56 <LambdaFred> > nubBy (((>1) . ) . gcd) [2..] !! 101
07:57:58 <lambdabot>   557
07:58:02 <LambdaFred> lazy bot
07:58:16 <LambdaFred> > nubBy (((>1) . ) . gcd) [2..]
07:58:18 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:58:27 <Saizan> Berengal: well, we should really have both versions in System.IO
07:58:40 <Gracenotes> :ooo
07:59:06 <Berengal> Saizan: Yes, I agree. Prelude should be for those functions that are so prevailing they're almost keywords
07:59:15 * maltem realizes there's no ticket about this to find on the Haskell' wiki
08:00:38 <maltem> but isn't really motivated to submit one now either
08:07:21 <erisco> @src unlines
08:07:21 <lambdabot> unlines = concatMap (++ "\n")
08:07:31 <EvilTerran> > nubBy (((==0) .) . mod) [2..]
08:07:33 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:08:53 <mjrosenb> EvilTerran: uhh, wow.
08:09:53 <helmut> Hi. Is there an easy way to search for functions by type signature?
08:10:02 <EvilTerran> mjrosenb, hehehe
08:10:09 <mjrosenb> helmut: @hoogle a->a
08:10:12 <EvilTerran> helmut, there's hoogle, in all its various forms
08:10:32 <EvilTerran> ?where hoogle
08:10:33 <lambdabot> http://haskell.org/hoogle
08:10:37 <helmut> @hoogle (a -> b) -> (a -> c) -> a -> (b, c)
08:10:38 <lambdabot> No results found
08:10:44 <Vanadium> @hoogle IO a -> a
08:10:45 <lambdabot> Foreign unsafePerformIO :: IO a -> a
08:10:45 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
08:10:46 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
08:10:50 <helmut> cool. thanks!
08:11:04 <Vanadium> Why does that, in the web interface, list stuff with type IO a -> IO a? That is not nearly as exciting!
08:11:08 <EvilTerran> asking in #haskell is a good way to find things, as well
08:11:30 <EvilTerran> ?type (Control.Arrow.&&&) :: (a -> b) -> (a -> c) -> a -> (b, c) -- helmut
08:11:31 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
08:11:44 <EvilTerran> > (f &&& g) x :: (Expr, Expr)
08:11:45 <lambdabot>   (f x,g x)
08:11:49 <mjrosenb> @src nubBy
08:11:49 <lambdabot> nubBy eq []             =  []
08:11:50 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
08:11:57 <helmut> why didn't hoogle find that?
08:12:16 <EvilTerran> helmut, because i lied about its type; it's more general than that
08:12:35 <EvilTerran> helmut, (&&&) :: Arrow (~>) => (a ~> b) -> (b ~> c) -> (a ~> (b,c))
08:12:44 <helmut> uh.
08:12:52 <helmut> can I read on "~>"?
08:13:04 <Beelsebob> (->) is an instance of Arrow
08:13:05 <EvilTerran> helmut, ~> is just an infix type variable
08:13:13 <Beelsebob> so you can safely substitute ~> for ->
08:13:20 <Beelsebob> (other way round)
08:13:40 <idnar> it makes it easier to read the types than with a prefix type variable
08:13:43 <idnar> @type (&&&)
08:13:43 <helmut> is there some document to boot the understanding of those things?
08:13:44 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:13:50 <EvilTerran> ?where arrow
08:13:50 <lambdabot> I know nothing about arrow.
08:13:53 <EvilTerran> ?where arrows
08:13:53 <lambdabot> http://www.haskell.org/arrows/
08:13:57 <EvilTerran> ^
08:14:31 <helmut> this has a distinct smell of abstract nonsense
08:14:31 <Berengal> @djinn (a -> b -> c) -> b -> a -> c
08:14:32 <lambdabot> f a b c = a c b
08:15:14 <EvilTerran> helmut, that's true. the Control.Arrow module's functions seem to be usually only ever used for the (->) instance of Arrow
08:15:18 <EvilTerran> ie, as function combinators
08:15:35 <Berengal> They're nifty combinators though...
08:16:08 <EvilTerran> indeed. i'd be inclined to have the (->) versions in Data.Tuple or Control.Function
08:16:10 <idnar> EvilTerran: what other standard Arrow instances exist?
08:16:16 <idnar> @instances Arrow
08:16:17 <lambdabot> (->), Kleisli m
08:16:34 <EvilTerran> Monad m => Arrow (Kleisli m)
08:16:39 <EvilTerran> ,src ''Kleisli
08:16:40 <lunabot>  luna: Not in scope: type constructor or class `Kleisli'
08:16:45 <EvilTerran> ?src Kleisli
08:16:46 <lambdabot> Source not found. There are some things that I just don't know.
08:16:49 <idnar> maybe if there were some useful instances besides (->) ...
08:16:50 <Berengal> Keisli is just a newtype, no?
08:16:51 <EvilTerran> bah!
08:16:53 <idnar> Kleisli is pretty pointless on its own :P
08:17:01 <zsol> howcome GHC can't find a package even if ghc-pkg list shows it?
08:17:25 <EvilTerran> Berengal, yeah, newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
08:17:28 <Berengal> zsol: Most common cause: it's installed in the user repository, but ghc only looks in the global
08:17:28 <portnov1> btw, is there any `standart' theorem/declarations/.. that Hoare triples form an Arrow ?
08:17:40 <portnov1> I mean, in Haskell.
08:18:11 <zsol> Berengal: that's true, it's installed in the user repo
08:18:43 <idnar> anyway, it's not surprising that people only use them for (->); there's nothing else to use them for! :P
08:19:03 <Berengal> zsol: How are you using ghc? calling it directly? runhaskell Setup.lhs?
08:19:28 <portnov1> idnar: Hoare triples, for example :)
08:19:42 <EvilTerran> idnar, indeed. the presence of "arr" kinda limits their generality.
08:19:56 <EvilTerran> (but is very necessary for the syntactic sugar)
08:20:59 <idnar> portnov1: I mean in the standard libraries
08:21:16 <zsol> I was trying to use cabal
08:21:33 <zsol> then found out the exact command line cabal uses to invoke ghc
08:21:50 <zsol> it's calling it directly
08:23:49 <monochrom> I use Arrow for HXT.
08:24:13 <zsol> ah, seems cabal missed a -package option
08:26:05 <ski> (idnar : `\s a b -> (s,a) -> (s,b)', et.c.)
08:33:08 <Vanadium> What does "deriving ()" do?
08:33:18 <EvilTerran> precisely nothing
08:33:44 <EvilTerran> if there's nothing in the ()s
08:33:49 <Vanadium> Right.
08:34:07 <EvilTerran> it might hint that the author intended to derive some stuff later, but didn't get around to it
08:34:25 <EvilTerran> or had derived some stuff for debugging purposes, and then removed the derivations
08:34:28 <erisco> or to the contrary, that he did not want to derive anything at all
08:34:48 <EvilTerran> erisco, but then you'd probably just leave out the deriving clause
08:35:00 <mjrosenb> is there any way of making a new typeclass derivable?
08:35:03 <erisco> or you would signify that one should not be added
08:35:03 <idnar> yo dawg we heard you like deriving
08:35:09 <erisco> quite the ambiguous situation if you ask me
08:35:36 <erisco> perhaps a comment "-- this should not derive anything" would be best or "-- this is a placeholder"
08:35:36 <EvilTerran> mjrosenb, not directly, but there's a number of boilerplate-generating systems to achieve a similar goal
08:35:44 <mjrosenb> erisco: that it defaults to deriving nothing?
08:36:04 <erisco> mjrosenb, no, what the author intended by leaving an empty deriving list
08:36:19 <EvilTerran> deriving ({- intentionally left blank -})
08:36:20 <mjrosenb> erisco: oh yeah, that
08:37:22 <EvilTerran> mjrosenb, the most direct probably being writing a TH function to generate a splice with the instance definition, given the type
08:38:10 <EvilTerran> $(deriveFrobbable ''Frobnitz)
08:38:19 <erisco> EvilTerran, the wonders of commented code :D
08:38:36 <EvilTerran> > ({- nothing to see here -})
08:38:38 <lambdabot>   ()
08:38:45 <portnov1> >> My lection will be about lazy evaluation. [Waits 30 sec]. Any further questions?
08:39:41 <monochrom> @quote lecture
08:39:41 <lambdabot> Tac-Tics says: oerjan: I tried, but his zombie lectures were hard to follow
08:39:43 <jeffwheeler> I've never actually tried installing Haskell on Windows. Should I just run the platform installer on Vista?
08:40:20 <jeffwheeler> Or do I need cygwin or something?
08:40:24 <monochrom> . o O ( I just install ghc in linux in virtualbox in windows )
08:40:31 <jeffwheeler> I have no idea how anything on Windows works :P
08:40:45 * EvilTerran downloaded the ghc executable
08:40:54 <SamB_XP> jeffwheeler: do you think anyone else does?
08:40:59 <EvilTerran> that works fine, and doesn't need cygwin or any such nonsense
08:41:02 <portnov1> jeffwheeler: or does anything on windows work? )
08:41:08 <monochrom> I think you can just run the platform installer. You don't need cygwin, it is not cygwin-based.
08:41:22 <jeffwheeler> Well, I don't know. I'll find out in a few days, though, when I have to use Windows for the first time in years.
08:41:26 <monochrom> My command&conquer game on Windows works.
08:41:43 <SamB_XP> monochrom: I wants it
08:41:46 <monochrom> iTunes works too.
08:41:52 <jeffwheeler> No!
08:41:57 * SamB_XP 's DOS disks got scratched and stuff
08:41:57 <jeffwheeler> No!
08:42:10 <SamB_XP> jeffwheeler: you no likey C&C?
08:42:12 <monochrom> Actually it's just C&C First Decade, and I mainly just play Zero Hour anyway.
08:42:18 <jeffwheeler> No iTunes, SamB_XP!
08:42:26 <jeffwheeler> (And I always assumed the XP stood for Windows XP.)
08:42:36 <SamB_XP> monochrom: my disks were for the original C&C
08:42:46 <monochrom> You mean No iTunes, monochrom!
08:42:54 * EvilTerran has First Decade on his "do want" list
08:43:01 <SamB_XP> jeffwheeler: oh, sure ... this is the computer on which I basically use the browser and play music
08:43:08 <jeffwheeler> monochrom: no, I mean I needed another comma after "No"
08:43:29 <monochrom> Ah I see now. Nevermind.
08:44:24 <jeffwheeler> It's amazing how much punctuation matters . . .
08:44:40 <jeffwheeler> And people remove it way too much on this internet.
08:44:58 <SamB_XP> jeffwheeler: not so much remove as forget to include
08:45:14 <SamB_XP> if people went around removing it we'd really be in trouble ;-)
08:45:17 <jeffwheeler> SamB_XP: I guess the semantics are relevant here
09:02:06 <hackagebot> TernaryTrees 0.1.3.1 - Efficient pure ternary tree Sets and Maps (AlexMason)
09:43:11 <byorgey> \o/  exponential generating function composition works!!!
09:43:27 <EvilTerran> byorgey, hm?
09:43:28 <byorgey> I've been working on this for two days straight
09:43:51 <EvilTerran> what is it?
09:44:08 <byorgey> EvilTerran: well, it's part of a library I'm making for computing with combinatorial species
09:44:26 <byorgey> EvilTerran: exponential generating functions count labelled species, and species composition corresponds to egf composition
09:44:56 <dschoepe> What is the proper way to do IO in reactive-fieldtrip?
09:45:00 <byorgey> so I've been implementing egf composition, which took me on a fascinating detour through Faa di Bruno's formula and Bell polynomials
09:45:43 <byorgey> and I'm so excited that it finally works that I had to share =)
09:45:52 <EvilTerran> afraid you lost me around "species". i do appreciate a good fascinating detour, though, especially when it pays off :)
09:46:57 <byorgey> EvilTerran: hehe, no worries, look for some blog posts about it soon =)
09:47:40 <Saizan> byorgey: nice!
09:53:11 <maartenm> hi
09:53:17 <maartenm> I'm trying to install haskore 0.1.1
09:53:36 <maartenm> when I installed from hackage using cabal, it gave me 0.1 I think, withotu MIDI interface support?
09:54:07 <maartenm> http://darcs.haskell.org/haskore/haskore.cabal    <-  how do I install from this location using cabal, instead of from hackage?
09:54:44 <Saizan> maartenm: darcs get http://darcs.haskell.org/haskore/ && cd haskore && cabal install
09:54:58 <maartenm> ok, I need darcs then
09:54:59 <Saizan> maybe; darcs get --partial http://darcs.haskell.org/haskore/ && cd haskore && cabal install
09:55:04 <maartenm> thanks
09:55:08 <erisco> @src tails
09:55:08 <lambdabot> tails []         = [[]]
09:55:09 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
09:55:34 <erisco> so here is my question: is tails lazy?
09:55:38 <Axman6> yep
09:55:39 <Saizan> it is
09:55:53 <Saizan> > tails (1:2:3:undefined)
09:55:54 <lambdabot>   [[1,2,3* Exception: Prelude.undefined
09:56:10 <aavogt> > take 0 $ tails undefined
09:56:11 <lambdabot>   []
09:56:27 <erisco> so, when it does the pattern match, is xs effectively tail (xxs) ?
09:56:39 <Saizan> yes
09:56:42 <EvilTerran> > map (take 2) $ tails (1:2:3:4:undefined)
09:56:44 <lambdabot>   [[1,2],[2,3],[3,4],[4* Exception: Prelude.undefined
09:57:18 <ski> > tails undefined `seq` ()
09:57:20 <lambdabot>   * Exception: Prelude.undefined
09:57:23 <ski> > tails (undefined:undefined) `seq` ()
09:57:25 <lambdabot>   ()
09:57:28 <erisco> Saizan, er, I guess what I mean
09:57:37 <Saizan> well, it's the same as (tail xxs), but the pattern matching on : is not lazy if you're asking that
09:57:41 <erisco> does tails run, build up a thunk, and then that thunk is evaluated as needed?
09:57:59 <Saizan> tails doesn't "run"
09:58:05 <SamB_XP> erisco: tails doesn't run until the head of the value is demanded
09:58:14 <maartenm> when it comes to metaprogramming, is System.Eval.Haskell the way to go?  (I want to live code haskore things while music is being played)
09:58:23 <SamB_XP> that is, it doesn't run until your program needs to know if it's result list is empty or not
09:58:29 <erisco> SamB_XP, which causes tails to build the entire thunk?
09:59:02 <Saizan> what do you mean by entire thunk?
09:59:04 <Axman6> anyone know much about the curl package?
09:59:07 <ski> erisco : which causes `tail' to *force* the thunk
09:59:33 <Saizan> maartenm: it's not bad as a wrapper around the ghc-api
09:59:36 <SamB_XP> erisco: at that point, tails either bottoms out, returns an empty list, or returns a cons cell with the passed-in list as the first item and an application of tails to the tail of the passed-in list as the tail
10:00:06 <SamB_XP> that application is the thunk that it builds
10:00:16 <erisco> okay but what I am not getting is if, once any amount of the result is needed, tails computes the entire list
10:00:25 <erisco> or if it only computes the needed part
10:00:35 <SamB_XP> erisco: it only computes the first cons cell
10:00:38 <EvilTerran> only the needed part
10:00:41 <SamB_XP> or []
10:00:44 <SamB_XP> as the case may be
10:00:52 <maartenm> Saizan: also when you're depending on a larger complex API like haskore? Do you have to repeat your dependencies in your chunks of 'live' code?
10:01:02 <EvilTerran> tails [1..] = [1..] : tails (tail [1..]) = ...
10:01:03 <Berengal> erisco: 'tails [1,2,3]' returns '<[1,2,3]> : <tails [2,3]>', where I'm marking thunks with <>
10:01:09 <SamB_XP> or, of course, if the list it was passed was _|_, it returns _|_ instead of computing anything
10:01:10 <ski> > null (tails (undefined:undefined))
10:01:12 <lambdabot>   False
10:01:15 <erisco> so is that achieved by having tails build a thunk for the entire list?
10:01:20 <ski> erisco : see that example ^
10:01:25 <SamB_XP> erisco: no, for the tail of the list
10:01:43 <erisco> SamB_XP, I do not understand what you mean by "for the tail of the list"
10:01:56 <SamB_XP> > tails (1:undefined)
10:01:57 <lambdabot>   [[1* Exception: Prelude.undefined
10:02:16 <SamB_XP> > map head $ tails (1:undefined)
10:02:17 <lambdabot>   [1* Exception: Prelude.undefined
10:02:19 <Saizan> maartenm: you can setup an eval environment that has all the needed modules imported
10:02:49 <Berengal> When a thunk is forced, it only runs until it can return a constructor
10:03:28 <erisco> like, for example, if I do (take 1 (tails "foo")) does tails: A) evaluate only the first element "foo" B) build a thunk for the entire evaluation and just evaluate the needed thunks or C) evaluate the entire result and take 1 just lops off the first
10:03:36 <EvilTerran> erisco, an unevaluated thunk can be considered similar structurally to the expression it represents
10:04:07 <SamB_XP> erisco: *if* the passed-in list is non-empty, that is, a cons (:), it returns another cons, with the head being xxs and the tail being a thunk
10:04:27 <ski> erisco : if you do *what* with `take 1 (tails "foo")' ?
10:04:28 <SamB_XP> that thunk is simply another call to tails
10:04:40 <EvilTerran> erisco, you can approximate how evaluation will happen in reality by doing outermost evaluation by hand
10:04:41 <SamB_XP> on the tail of the original list
10:04:44 <erisco> ski, ask for the evaluation of it
10:04:45 <ski> erisco : print the whole of it ? force the top constructor ? ignore it ?
10:04:55 <EvilTerran> Cale's the resident expert in demo'ing such things
10:04:58 <ski> erisco : the evaluation of which part of it ?
10:05:01 <erisco> ski, if I go to ghci and type it in
10:05:05 <erisco> ski, the take 1
10:05:07 <Berengal> erisco: take 1 (tails "foo") will make tails create a cons, first element "foo", second element a thunk <tails "oo">, take 1 will then replace the second element (the thunk) with nil, and the thunk will be garbage collected
10:06:06 * SamB_XP was not aware that take did mutation
10:06:20 <ski>      take 1 (tails "foo")
10:06:23 <ski>   =  take 1 ("foo" : tails "oo")
10:06:26 <ski>   =  "foo" : take 0 (tails "oo")
10:06:27 <ski>   =  "foo" : []
10:06:44 <ski> erisco : that's more or less what happens
10:06:48 <Berengal> SamB_XP: For some definition of mutation, it does.
10:07:06 <SamB_XP> Berengal: I'm not talking about thunk updates!
10:07:50 <erisco> ski, and, so Haskell handles this all transparently and knows when to ask tails for more when you use it
10:08:04 * ski doesn't know what that means ..
10:08:13 <erisco> well I do :P
10:08:17 <Berengal> erisco: It knows when to force a thunk, yes
10:08:31 <Berengal> Which is: It needs to know what the constructor of the value it represents is
10:08:43 <ski> when `tail' needs to know whether its argument is a nil or a cons (for pattern-matching), then the argument is forced (until it is in that form)
10:08:50 <gwern> yo dawg i herd u liek laziness so i wrote 'force' and 'delay' so u can be lazy while ur lazy
10:08:58 <opqdonut> ...
10:09:11 <ski> (gwern : Scheme ?)
10:09:58 <gwern> I sometimes wonder - if one wrote force and delay in haskell, and wrote say take using it, would it compile down to the same code as without force and delay?
10:10:06 <gwern> I would think so, but without trying I don't know
10:10:15 <erisco> ski, okay, but that is forcing the arguments for tails, not forcing the evaluation of tails, no?
10:10:36 <ski> erisco : the argument being `tails "foo"', here
10:10:53 <ski> @src take
10:10:53 <lambdabot> take n _      | n <= 0 =  []
10:10:54 <lambdabot> take _ []              =  []
10:10:54 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
10:10:58 <erisco> ski, so you are saying that tails "foo" will force the evaluation of "foo" if it was not yet evaluated, but if you only ask for the head, tails will only report "foo" : <tails "oo"> yes?
10:11:25 <ski> `take' wants to know whether the second argument is empty or not (provided the first argument is positive, which `1' is)
10:11:30 <Axman6> asking for the head will return "foo"
10:12:00 <erisco> Axman6, head will report "foo", tails will report "foo" : <tails "oo"> yes?
10:12:11 <Axman6> yep
10:12:12 <ski> erisco : no, i'm talking about `take 1 (tails "foo")' forcing the evaluation of (part of) `tails "foo"', here
10:12:53 <ski> but yet, that will, in turn, force the argument of `tails', too
10:13:00 <ski> (s/yet/yes/)
10:13:21 <erisco> so, init . tails does not suffer at all compared to init on an already evaluated list, yes?
10:13:38 <erisco> being that it has to transverse it all and make a copy
10:14:07 <Saizan> tails doesn't make a copy
10:14:14 <erisco> did not say it did =\
10:14:20 <Berengal> tails does make a new list though
10:14:41 <erisco> I said if you use init on an already evaluated list, it has to transverse it and copy all but the last element
10:15:14 <Saizan> well, init does that regardless of the state of evaluation of the list
10:15:19 <erisco> but because tails is not yet evaluated, init leads the construction of the list, asking tails for each consecutive part, until the last element which it does not care about
10:15:45 <erisco> @src init
10:15:46 <lambdabot> init [x]    = []
10:15:46 <lambdabot> init (x:xs) = x : init xs
10:15:46 <lambdabot> init []     = undefined
10:15:48 <Saizan> erisco: only as far as the result of init is demanded though
10:15:59 <Berengal> init forces the entire spine of the input list, which means init . tails would also force its entire input list
10:16:14 <Saizan> Berengal: forces the entire spine?
10:16:28 <Saizan> > head $ init (1:undefined)
10:16:30 <lambdabot>   * Exception: Prelude.undefined
10:16:39 <Saizan> > head $ init (1:2:undefined)
10:16:41 <lambdabot>   1
10:16:54 <Berengal> Saizan: Assuming the entire result of 'init' is needed
10:17:11 <erisco> Berengal, the first time around it would be    init ("foo":<tails "oo">)   no?
10:17:16 <Saizan> ah, ok
10:17:19 <Berengal> I'm assuming all outer expressions are evaluated to rnf
10:17:33 <Axman6> @hoogle forM
10:17:34 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
10:17:34 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
10:17:34 <lambdabot> Text.XHtml.Frameset form :: Html -> Html
10:17:37 <Axman6> @hoogle forM_
10:17:38 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
10:17:38 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
10:17:41 <Berengal> erisco: Yes
10:18:27 <erisco> Berengal, so this is contrary to the usual case where a function creates a list, transversing over each element, then init in turn transverses each element and returns all but the last
10:18:51 <erisco> Berengal, instead, init transverses the list and asks tails for each part, so the transversing is only done once
10:18:55 <erisco> Berengal, yes?
10:19:28 <ski>      init (tails [0,1,2])
10:19:33 <ski>   =  init ([0,1,2] : tails [1,2])
10:19:33 <Berengal> erisco: Well, init can return elements lazily as well. It doesn't need to know the last element, just that the next element it's looking at isn't the last
10:19:38 <ski>   =  init ([0,1,2] : [1,2] : tails [2])
10:19:43 <ski>   =  [0,1,2] : init ([1,2] : tails [2])
10:19:48 <ski>   =  [0,1,2] : init ([1,2] : [2] : tails [])
10:19:54 <ski>   =  [0,1,2] : [1,2] : init ([2] : tails [])
10:19:56 <erisco> I don't think anyone is getting me at all
10:20:00 <ski>   =  [0,1,2] : [1,2] : init ([2] : [[]])
10:20:01 <ski>   =  [0,1,2] : [1,2] : [2] : []
10:20:26 <Berengal> erisco: Most functions only traverse a list once
10:20:40 <erisco> yes
10:21:01 <ski> so, yes, `init' and `tails' here "follow" each other, instead of necessarily keeping the whole intermediate list in memory at the a single time
10:22:06 <erisco> ends = tails "foo"; ends `seq` init ends
10:22:09 <erisco> this is what I am talking about
10:22:10 <ski> both `tails' and `init' only has to check a small part of the input to construct each part of the output
10:22:23 <ski> iow, they are incremental
10:22:34 <erisco> in that case, does tails not transverse its entire output list constructing it, then init transverses the list AGAIN and chops off the last element
10:22:48 <copumpkin> > map tails . inits $ [0..]
10:22:50 <lambdabot>   [[[]],[[0],[]],[[0,1],[1],[]],[[0,1,2],[1,2],[2],[]],[[0,1,2,3],[1,2,3],[2,...
10:22:56 <SamB> erisco: except without the "then"
10:22:56 <copumpkin> > map inits . tails $ [0..]
10:22:58 <lambdabot>   [[[],[0],[0,1],[0,1,2],[0,1,2,3],[0,1,2,3,4],[0,1,2,3,4,5],[0,1,2,3,4,5,6],...
10:23:13 <ski> erisco : could you rephrase your question ?
10:23:16 <erisco> and is this not _contrary_ to the case of init . tails "foo"
10:23:21 <aavogt> > inits $ tails [0..]
10:23:23 <lambdabot>   [[],[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,2...
10:23:32 <Axman6> huh, writeFile doesn't create the file? :S
10:23:48 <erisco> SamB, what do you mean without the "then"?
10:23:51 <Saizan> erisco: in both cases the list is traversed twice
10:23:57 <Axman6> how annoying. how do i create a file for use with Data.ByteString.Lazy.Char8? :\
10:24:15 <aavogt> Axman6: writeFile creates files for me
10:24:16 <ski> Saizan : rather, one list is traversed once, and another list is traversed once
10:24:23 <Saizan> ski: right
10:24:31 <Berengal> Axman6: writeFile does create on my box
10:24:34 <erisco> Saizan, so there is no loss in performance using seq?
10:24:36 <Saizan> tails traverses "foo" and init traverses the result of tails
10:24:44 <Berengal> Axman6: Prelude.writeFile that is
10:24:53 <Saizan> erisco: seq only forces the outermost constructor
10:24:55 <ski> erisco : what does `seq' have to do with your question ?
10:25:06 <Axman6> L8.writeFile complains about the file not existing
10:25:06 <erisco> everything
10:25:17 <ski> (and what is your question ?)
10:25:25 <Axman6> erisco: i think you're mis understanding what seq does
10:25:33 <Axman6> -<space>
10:25:46 <erisco> Axman6, does not not force the evaluation, when infix, of the left before executing the right?
10:25:59 <Axman6> well yes, but i
10:26:11 <Axman6> i'm not sure you understand what forcing the evaluation means
10:26:26 <Saizan> erisco: if you mean "fully evaluating tails "foo" and then applying init to the result is less efficient than (init (tails "foo"))?" then the answer is that it just uses O(n) more memory, i guess
10:26:27 <Berengal> erisco: in your example, seq doesn't do anything init doesn't do. In fact, the first thing init does is seq (because it pattern matches)
10:26:40 <ski> > (div 1 0) `seq` ()
10:26:41 <Axman6> i think seq on lists just makes sure that the list is either a cons or nil cell
10:26:42 <lambdabot>   * Exception: divide by zero
10:26:46 <ski> > [div 1 0,5] `seq` ()
10:26:48 <lambdabot>   ()
10:26:59 <erisco> I don't think anyone is still following my train of thought here :(
10:27:05 <Axman6> > [1,2,3,undefined] `seq` "hello"
10:27:07 <lambdabot>   "hello"
10:27:13 * ski does not
10:27:20 <Axman6> > [undefined,1,2,3,undefined] `seq` "hello"
10:27:22 <lambdabot>   "hello"
10:27:27 <Berengal> > let foo = [1, undefined] in foo `seq`length foo
10:27:29 <lambdabot>   2
10:27:30 <Saizan> erisco: maybe try to formulate the question all at once :)
10:27:57 <erisco> Saizan, you get what I mean, but is it just O(n) more memory or is it also computational time as well?
10:28:25 <erisco> Saizan, if I was to write a new function that was like tails but did not append the last element (an empty list)
10:28:31 <ski> erisco : "it" being ?
10:28:37 <erisco> Saizan, it would only transverse its input once
10:28:48 <Saizan> erisco: just memory, but using more memory can cause the GC to run more often etc..,
10:28:57 <Saizan> erisco: right, that would traverse it only once
10:29:08 <Saizan> though maybe init and tails fuse together?
10:29:28 <Berengal> There might be some fusion rules...
10:29:28 <ski> (they could .. but the nave graph reduction doesn't do that)
10:29:30 <Saizan> in that case you'd end up with a single traversal with (init (tail xs))
10:29:39 <erisco> Saizan, so my question is, does (init . tails) "foo" also transverse once
10:29:46 <copumpkin> stream fusion would fuse it I think
10:30:07 <Berengal> erisco: tails traverses "foo" once, init traverses 'tails "foo"' once
10:30:07 <ski> erisco : `"foo"' is traversed once. `tails "foo"' is traversed once, too
10:30:07 <erisco> Saizan, and according to the explanations, it does only transverse once, and init does the transversing and asks tails for the result of each part
10:30:18 <erisco> how is that possible??
10:30:26 <Saizan> erisco: ok, i'm not sure what the answer is, since there's an optimization called list fusion in ghc that could actually get that composition to be a single traversal
10:30:46 <copumpkin> actually I don't think stream fusion would be able to fuse them
10:30:48 <Saizan> erisco: the explanations said that it traverses twice.
10:31:03 <erisco> Saizan, that is not what the evaluation looks like from what you guys are saying
10:31:05 <Saizan> erisco: or rather, that the intermediate list is constructed.
10:31:07 * Berengal once got 'sum . enumFromTo 1 $ 1000000' down to five assembly instructions in haskell
10:31:26 <copumpkin> Berengal: you sure it wasn't sumU . enumFromToU 1 $ 1000000 ?
10:31:30 <erisco> from my understanding the explanations are now contradictory
10:31:32 <Saizan> erisco: that's just because the two traversals are interleaved, but they still happen both
10:31:56 <erisco> you said that tails was lazy and the only elements of the result list that would be evaluated are those that you ask for
10:31:57 <ski> erisco : no single list is traversed twice, here; but there's two traversals of different lists going on
10:31:58 <erisco> yes?
10:31:58 <copumpkin> Berengal: I can definitely believe that on x86_64 and uvector
10:31:59 <Berengal> copumpkin: Actually, it was 'foldr (+) 0 . enumFromTo 1 $ 1000000 :: Int'
10:32:04 <copumpkin> ah
10:32:11 <copumpkin> hrm
10:32:13 <Saizan> erisco: right
10:32:27 <erisco> Saizan, they happen at the same time though, they are both transversing it together
10:32:38 <erisco> Saizan, not one after another, which is exactly what I was trying to illustrate with seq
10:32:41 <Berengal> copumpkin: At least I think it was five.. I'm not good at reading assembly, and I was doing some printing as well, but it looked like it
10:32:51 <erisco> Saizan, is this not correct?
10:33:01 <Saizan> erisco: "together" is ambiguous
10:33:07 <uman> how can I exit ghci?
10:33:07 <ski> erisco : using `seq' will not make one traversal happen after another, if that's what you're thinking
10:33:09 * erisco smacks his head on the desk
10:33:12 <Axman6> uman: :q
10:33:17 <uman> Axman6: thank you
10:33:28 <Axman6> :help for help ;)
10:33:32 <ski> ^D
10:33:42 <Berengal> erisco: When doing lazy evaluation, temporal placement of evaluations is best left alone lest you lose your sanity
10:33:51 <Saizan> erisco: the two traversals are interleaved, yeah, though the overall (time) cost is the same as doing one and then the other
10:33:52 <erisco> ski, so if I used seq on (tails "foo") what is tails "foo" going to evaluate to?
10:34:09 <ski> erisco : `"foo" : tails "oo"'
10:34:13 <copumpkin> seq only grabs the first cell
10:34:23 <erisco> only the first?
10:34:26 <ski> yes
10:34:26 * erisco sighs
10:34:30 <copumpkin> > seq [1, undefined]
10:34:32 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
10:34:32 <lambdabot>    arising from a use of `...
10:34:36 <copumpkin> > seq [1, undefined] ()
10:34:38 <erisco> okay bad illustration then
10:34:38 <lambdabot>   ()
10:34:52 <erisco> but *pretend* that seq evaluated the whole list and you would get what I mean :P
10:34:54 <ski> erisco : maybe you wanted `deepSeq' ?
10:34:56 <copumpkin> > rnf [1, undefined] ()
10:34:58 <lambdabot>   Couldn't match expected type `() -> t'
10:35:01 <copumpkin> > rnf [1, undefined]
10:35:03 <lambdabot>   * Exception: Prelude.undefined
10:35:06 <erisco> ski, sure
10:35:23 <Saizan> erisco: does my last line make sense to you?
10:35:43 <ski> erisco : ok. then *where* do you want to place `deepSeq' (or `rnf') in `init (tails "foo")' ?
10:35:49 <erisco> Saizan, that 10*(3+4) is the same as 30+40, yes
10:36:13 <erisco> Saizan, but there *is* a difference of how the evaluation works, yes?
10:36:29 <Berengal> erisco: So what if there is?
10:37:16 <Saizan> erisco: yeah, let xxs = tails xs in xxs `deepSeq` init xxs and (init (tails xs)) are evaluated differently
10:37:17 <Berengal> As long as I'm getting the values I want, I don't really care how evaluation proceeds
10:37:25 <erisco> Berengal, init will evaluate the whole list, but not all functions will, and that is why I want to understand how it evalutes
10:37:39 <erisco> Berengal, I care =\
10:38:01 <ski> `init xs' will not evaluate the whole `xs'
10:38:09 <Berengal> erisco: It's more important to understand the semantics of _|_ than the order of evaluation
10:38:15 <ski> it depends on how much of the result of `init xs' is demanded
10:38:20 <copumpkin> > rnf . init . [1, 2, 3, undefined]
10:38:22 <lambdabot>   Couldn't match expected type `a -> [a1]'
10:38:27 <copumpkin> bah :P
10:38:31 <copumpkin> > rnf . init $ [1, 2, 3, undefined]
10:38:32 <erisco> ski, the *entire* result, that is what I am talking about
10:38:33 <lambdabot>   ()
10:38:48 <benmachine> @src rnf
10:38:49 <lambdabot> Source not found. Are you on drugs?
10:38:58 <Axman6> @src [] rnf
10:38:59 <lambdabot> Source not found. Take a stress pill and think things over.
10:39:05 <Axman6> ok :(
10:39:11 <erisco> ski, I am presuming the entire result of the function applied to tails is evaluated
10:39:15 <ski> > init [1,2,3,undefined]
10:39:16 <lambdabot>   [1,2,3]
10:39:52 <aavogt> > init $ [1,2,3] ++ undefined
10:39:53 <uman> hi, the tutorial I'm reading has an example of a function head'
10:39:54 <lambdabot>   [1,2* Exception: Prelude.undefined
10:39:56 <uman> defined as follows:
10:40:02 <uman> head' :: [a] -> a
10:40:12 <uman> head' [] = error "Can't call head on an empty list"
10:40:17 <uman> head' (x:_) = x
10:40:26 <erisco> Berengal, and, so, with the deepSeq it is transversed twice, without it is transversed once, but the same time is spent, so memory usage is the difference in this case
10:40:30 <uman> my question is why does that pattern in the last line have to be in parentheses?
10:40:31 <erisco> I mean Saizan ^^
10:40:36 <uman> Why couldn't head' x:_ = x work?
10:40:39 <ski> erisco : with `deepSeq', *where* ?
10:40:43 <erisco> Saizan, okay, I get that. thank
10:40:57 <ski> uman : because that means :  (head' x):_ = x
10:41:06 <ski> uman : because of operator precedence
10:41:14 <uman> ski: I see, thanks
10:41:18 <erisco> Berengal, ski, Saizan thank for the help. I think I understand my situation now :)
10:41:27 <Axman6> functions bind more tightly than anything else in haskell i believe
10:41:30 <Saizan> erisco: your insisting on there being only one traversal is a bit puzzling, but i hope it's just a communication mismatch :)
10:41:37 <Axman6> so the x is bound to head, not the (:)
10:41:44 <uman> Axman6: okay.
10:41:58 <ski> Axman6 : s/functions/function applications/ :)
10:42:15 * SamB throws sugar lamdbas at Axman6 
10:42:25 <SamB> see how they hold him?
10:42:34 <aavogt> record syntax beats it though
10:42:39 <ski> (Axman6 : also, there's a couple of exceptions to that)
10:42:42 <Axman6> it's almost 4AM here, don't expect me to function correctly in any way whatsoever
10:42:53 <Axman6> aavogt: yeah, i thought it might
10:43:12 <erisco> Saizan, well, it must be
10:44:03 <Berengal> erisco: We usually talk about strictness. init is strict in the spine of the list, which means that if another expression is strict on init, then it will also be strict on the list
10:44:17 <ski> > let foo ~ t @ Node {rootLabel = r,subForest = ts} = (t,r,ts) in foo (Node 42 [])
10:44:19 <lambdabot>   (Node {rootLabel = 42, subForest = []},42,[])
10:44:51 <benmachine> ~?
10:45:15 <ski> benmachine : irrefutable pattern
10:45:27 <Axman6> what's that mean?
10:45:32 <ski> > let foo (x,y) = () in foo undefined
10:45:34 <lambdabot>   * Exception: Prelude.undefined
10:45:36 <ski> > let foo ~ (x,y) = () in foo undefined
10:45:38 <lambdabot>   ()
10:45:40 <SamB> means you can't say "no, that doesn't match!"
10:45:49 <Axman6> heh
10:45:51 <ski> > let foo (x,y) = (3,x) in fst (foo undefined)
10:45:52 <lambdabot>   * Exception: Prelude.undefined
10:45:56 <ski> > let foo ~ (x,y) = (3,x) in fst (foo undefined)
10:45:58 <lambdabot>   3
10:46:10 <Berengal> Irrefutable patterns never fail, which means we don't have to evaluate them until we need the values bound by it
10:46:12 <Axman6> so i take it that let foo ~(Just x) = x wouldn't work?
10:46:35 <ski> > let foo ~(Just x) = (3,x) in fst (foo Nothing)
10:46:37 <lambdabot>   3
10:46:43 <ski> > let foo ~(Just x) = (3,x) in snd (foo Nothing)
10:46:45 <lambdabot>   * Exception: <interactive>:1:141-161: Irrefutable pattern failed for patter...
10:46:50 <Axman6> :O
10:46:52 <benmachine> handy!
10:46:55 * Axman6 likes this
10:47:16 <aavogt> @src maybe
10:47:16 <ski> this is sometimes hand when defining data structures in terms of themselves
10:47:16 <lambdabot> maybe n _ Nothing  = n
10:47:16 <lambdabot> maybe _ f (Just x) = f x
10:47:17 * SamB forgot what they're actually useful for
10:47:54 <ski> @src (->) (***)
10:47:55 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
10:47:59 <Berengal> I like it for things like 'do {~(command:arg:_) <- getArgs; if command == "foo" then foo arg else bar}'
10:48:49 <Saizan_> > foldr (\x (xs,ys) -> if even x then (x:xs,ys) else (xs,x:ys)) ([],[]) [1..1000]
10:48:50 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
10:48:56 <Saizan_> > foldr (\x (xs,ys) -> if even x then (x:xs,ys) else (xs,x:ys)) ([],[]) [1..100000]
10:48:59 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
10:49:10 <Saizan_> > foldr (\x (xs,ys) -> if even x then (x:xs,ys) else (xs,x:ys)) ([],[]) [1..10000000]
10:49:12 <lambdabot>   * Exception: stack overflow
10:49:18 <Saizan_> > foldr (\x ~(xs,ys) -> if even x then (x:xs,ys) else (xs,x:ys)) ([],[]) [1..10000000]
10:49:19 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
10:50:33 <ski> > (take 10 *** take 10) $ foldr (\x (xs,ys) -> if even x then (x:xs,ys) else (xs,x:ys)) ([],[]) [1..]
10:50:35 <lambdabot>   (* Exception: stack overflow
10:50:36 <ski> > (take 10 *** take 10) $ foldr (\x ~(xs,ys) -> if even x then (x:xs,ys) else (xs,x:ys)) ([],[]) [1..]
10:50:38 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20],[1,3,5,7,9,11,13,15,17,19])
10:51:03 <Saizan_> ski: oh, right :)
10:52:38 <Axman6> anyone familliar with the curl package?
10:52:41 * ski likes how there's an `(' output before the error, there ..
10:52:49 <Axman6> wondering if it's possible to use it multithreaded
10:54:15 <Axman6> also, on a slightly related note, if you use forkOS, and the thread ends, does the application still keep that thread running?
10:57:05 <Axman6> ski: can ~ be used in case statements? seems it would be useful
10:57:10 <ski> sure
10:58:00 <ski> > fst (case Just undefined of Nothing -> (0,1); Just ~(x,y) -> (42,x+7))
10:58:02 <lambdabot>   42
10:59:25 <Axman6> how nice
11:04:07 <copumpkin> if you weren't trying to explain typeclasses to a newbie, and wanted to give an accurate definition of what they are (including multiparam typeclasses), what would you say? I typically describe it as a statement about one or more types (or a relation between them in the case of MPTC), but it doesn't feel adequate
11:05:28 <Saizan_> a set of types that support some specified operations?
11:05:51 <copumpkin> they aren't even required to support operations though, you can have a typeclass with no methods
11:06:01 <ski> a kind of algebra over carriers of specified kind ?
11:06:40 <Saizan_> well 0 is a special case of the number of possible operations :)
11:06:45 <copumpkin> lol
11:07:01 <Saizan_> *possible number of operations
11:07:28 * ski wants necessary operations
11:07:47 <ray> i don't know, but you'd better not screw up, typeclasses are only one of the most important parts of haskell
11:08:20 <copumpkin> it feels to me like the methods are used to prove (or are corollaries to) the instance statement
11:08:31 <ski> (i suppose one'd have to add that given appropriate carriers, there can be at most one such algebra ..)
11:08:51 <copumpkin> if we had a Group typeclass and an AbelianGroup typeclass, the latter could have no real meaningful methods
11:09:03 <ski> yes, the operation signatures are axioms to prove
11:09:14 <ray> it could have a meaningful quickcheck property, but that's not part of the language
11:09:24 <Saizan_> copumpkin: that's only because you can't express Abelian as a method
11:09:26 <copumpkin> yeah, I wouldn't put quickcheck properties as methods
11:09:34 <copumpkin> Saizan_: yeah, in a stronger type system maybe
11:09:35 <Saizan_> copumpkin: but methods are part of the statement to me
11:09:44 <erisco> @src minimumBy
11:09:45 <lambdabot> Source not found. That's something I cannot allow to happen.
11:09:47 <soupdragon> copumpkin, I think my view is not accurate.. but I think of it as   (1) HM type inference  (2) run all the typeclasses collected as a logic program (it may fail or instantiate some things here)
11:10:04 <ray> clearly there's axioms that you can express as methods, which are methods, and ones you can't which seem to be called "laws"
11:10:18 <ski> `Group g' is the statment. the implementation of `unit' and `combination' is the proof of the statement
11:10:37 <copumpkin> yeah
11:10:46 <copumpkin> that makes sense
11:10:57 <Saizan_> IOW unit and combination are the meaning of Group g
11:11:05 <ski> (together with proofs of laws, if you include those)
11:11:07 <copumpkin> and if I did have an AbelianGroup statement, haskell would just have to take my word for it
11:11:12 <Saizan_> as in, how'd you define Group? or Monoid?
11:11:28 <copumpkin> well maybe Group would derive from Monoid and add some invertibility condition somehow
11:11:43 <ray> i forget how i wrote it when i wrote it
11:11:53 <ski> well, yes you'd probably want an `inverse' in `Group', too ..
11:12:10 <ray> class Monoid g => Group g where negate :: g -> g (-)    :: g -> g -> g a - b = a + (negate b)
11:12:20 <ray> hmm, irc client flattened that to one line
11:12:21 <ray> how ugly
11:12:22 <Saizan_> yeah, but my point was that a central part of the definition of Monoid is the existence of a binary operation and an unit for it, and those are the methods
11:12:27 <uman>  this tutorial says "otherwise is defined simply as otherwise = True"
11:12:28 <copumpkin> yeah
11:12:34 <copumpkin> @src otherwise
11:12:35 <lambdabot> otherwise = True
11:12:37 <uman> is that an oversimplification, or really the case?
11:12:39 <copumpkin> :)
11:12:40 <copumpkin> that's it
11:12:42 <uman> okay
11:12:54 <uman> why make a new word for something that already exists
11:13:00 <copumpkin> uman: it reads more nicely
11:13:04 <copumpkin> it isn't a keyword
11:13:07 <uman> oh
11:13:08 <ray> because programs are written primarily for humans and secondarily for computers
11:13:16 <copumpkin> > let otherwise = False in otherwise || otherwise
11:13:18 <lambdabot>   False
11:13:28 <ray> (this becomes more true as your language gets better)
11:13:37 <benmachine> heh
11:13:47 <benmachine> data Bool = False | True | MoreTrue
11:13:56 <uman> ray: eh, I'd argue that it's more like "better in certain domains"
11:13:58 <uman> certainly I wouldn't write a kernel in Haskell
11:14:02 <ski> (s/MoreTrue/FileNotFound/)
11:14:05 <uman> anywaym, don't have time to argue that point now, have to go
11:14:08 <ray> well, that's your problem, not haskell's
11:14:08 <uman> ski: :D
11:14:14 <copumpkin> so in Functor, the type constructor is what you're making the statement about and fmap is proving that you do indeed carry functions from outside the functor into it
11:14:38 <ski> yes
11:15:07 <copumpkin> ok
11:16:02 <ray> the type is sufficient for Functor, but for most classes you have to trust that the instance is sane (follows the "laws")
11:16:20 <idnar> ski: bwaha
11:16:45 <Saizan_> ray: you can write fmap implementations that don't follow the laws
11:16:48 <ray> actually if you count stuff like error the type is never sufficient
11:17:06 <Saizan_> though the statement is about the type anyway
11:17:25 <ski>   instance Functor [] where fmap _ _ = []
11:18:00 <copumpkin> lol
11:18:09 <idnar> nullmap
11:18:52 <soupdragon> hmmmmm my idea about typeclasses seems really wrong now I said it
11:19:22 <ski> soupdragon : your idea seemed more about instance resolution
11:19:37 <ski> (than what instances "mean", i.e.)
11:20:46 <ray> the thing is, you can actually verify the type, but you can't possibly verify the laws
11:21:24 <ray> you can use quickcheck to be reasonably sure your honest attempt to write an instance wasn't terribly flawed, but that's about it
11:21:42 <EvilTerran> well, within haskell, anyway
11:21:45 <ski> you can write an informal (or otherwise) proof yourself
11:22:08 <ray> yes, within haskell
11:22:10 <ski> (well, you can try, at least)
11:22:59 <monochrom> For things like State and Reader an automatic theorem prover is more than capable of proving for you.
11:23:01 * EvilTerran has idly pondered about some kind of system involving computer-verified laws and proofs written in comments
11:23:25 <monochrom> They are just tedious, not profound.
11:23:48 <maltem> Hey ghc people out there, the network package doesn't compile with ghc head. Do something about it :P
11:24:30 <monochrom> If your monad's correctness relies on existence of integer solutions to some multi-variate polynomial, of course that's profound.
11:24:51 <EvilTerran> monochrom, is there such a monad? O.o
11:25:00 <idnar> sounds like an awesome monad :D
11:25:01 <copumpkin> prove that there isn't ;)
11:25:10 <idnar> copumpkin: hahaha
11:25:14 <EvilTerran> idnar, instance Monad Awesome where ... ?
11:25:14 <monochrom> Indeed my point is in "real life" no one does profound things.
11:25:46 <ski> prove that if there was one, then the Limited Principle of Omniscience follows ..
11:25:51 <dankna> ... and that's why a theorem prover could do its job (leaving aside the question of whether it would be useful).
11:26:03 <dankna> because the things it would be asked to prove would not be particularly deep.
11:26:24 <monochrom> "oooh proving programs correct is so hard!"  But look at what you do in "real" code: linear arithmetic, linear inequalities, a bit of boolean algebra... Blatantly decidable, boring code.
11:26:58 <soupdragon> proving programs correct is so fun :p
11:27:08 <ray> the closest it gets to undecidability is c++ grammar? :)
11:27:15 <dankna> as I understand your argument, monochrom, doesn't that mean it's now your job to write a correctness prover? :)
11:27:16 <maltem> First step: Find a program that is correct
11:27:23 <monochrom> Most programmers are out of touch from what theorem provers can and cannot do for 20 years. Just 10 years ago things changed already.
11:27:42 <monochrom> Maybe out of touch for 40 years actually.
11:27:57 <ski> Zeroeth step : Find a proof that there is a correct program
11:28:04 <soupdragon> monochrom: are you aware of any good overviews?
11:28:18 <ski> First step then is just extracting the program
11:28:33 <monochrom> Generally most programmers are out of touch from anything for 20-40 years. They learned what was available when they're undergrad, then they basically locked it.
11:28:34 <soupdragon> step -1 : pick thde right logic
11:29:17 <monochrom> This is why for example today's 50yo's are like "recursion needs stack!"
11:29:27 <EvilTerran> ski, second step, verify the proof with the program, as it'll probably be a pathological example?
11:29:33 <monochrom> Recursion needed stack when they were undergrad. That is the only reason why.
11:29:53 <ski> EvilTerran : the verification is done by the proof assistant
11:30:34 <monochrom> This is why death is so beautiful. Old people die so their misknowledge is lost.
11:30:46 * EvilTerran just likes feeding programs into themselves to see what happens, is all.
11:31:15 <monochrom> Imagine if people didn't die. Today we would still be writing programs the way Charles Babbage wanted it because we would be all writing program under him!
11:31:28 <dankna> a dubious claim
11:31:32 <maltem> monochrom, I guess that is also why our algorithms prof writes in his slides things like, Recursion is not always bad: Tail recursion
11:31:47 <dschoepe> What is the proper way to do IO when using Reactive?
11:32:14 <idnar> monochrom: on the other hand, a lot of knowledge is lost too
11:32:27 <maltem> (although, really he's mixing recursion and naive algorithms there)
11:32:28 <soupdragon> maltem heheheheh
11:32:29 <idnar> monochrom: imagine if we didn't have to rediscover the same knowledge every 10 years!
11:32:29 <EvilTerran> maltem, ah, i remember slides like that
11:32:58 * ski wonders how much we know about how Lovelace or Babbage wanted to be writing programs
11:33:02 <soupdragon> oleg@o...
11:33:02 <soupdragon> Subject: 	GADTs in OCaml
11:33:17 * soupdragon puts on seatbelt
11:33:18 <monochrom> Anyway the correctness proof course I just taught some months ago is at http://www.cse.yorku.ca/course_archive/2008-09/W/3341/  and I introduced the use of PVS at http://www.cse.yorku.ca/course_archive/2008-09/W/3341/pvs-intro.html
11:33:22 <ski> (gotta love oleg :)
11:33:35 <idnar> soupdragon: hee hee
11:33:36 <EvilTerran> re-discovery of knowledge leads to new perspectives, and hence progress, though
11:33:39 <monochrom> PVS is more capable than I previously thought. I'm amazed.
11:33:57 <idnar> EvilTerran: sometimes
11:34:21 <idnar> EvilTerran: it's just depressing when it all-too-frequently leads to degradation of knoweldge
11:34:33 <EvilTerran> mmm
11:34:49 <idnar> EvilTerran: certainly, our understanding of things needs to progress in unison with our understanding of other things
11:35:03 <idnar> EvilTerran: but it seems like there's just so much that gets irrevocably lost over time, because we're unable to hang onto it properly
11:35:26 <monochrom> I wonder how much knowledge is invariant over change of time, culture, technology, ...
11:35:30 <idnar> I'm not sure that really has anything to do with people dying, for that matter
11:35:41 <idnar> it's just a failure to import the knowledge into new cultures / technologies / frameworks / etc.
11:35:51 <monochrom> "tail recursion is faster" is a piece of knowledge that I won't mind losing. It ain't true.
11:36:11 <ski> (.. faster than what ?)
11:36:19 <idnar> ski: it's over nine thousand!
11:36:27 <monochrom> If people don't die they become too influential. They block younger people from progressing.
11:36:30 <ski> idnar : sorry ?
11:36:41 <idnar> ski: nevermind, bad joke
11:36:51 * ski peers curiously at idnar
11:36:54 <idnar> ski: http://encyclopediadramatica.com/index.php/Over_9000
11:38:26 <Badger> idnar: oh grief, don't link that place :P
11:38:37 <plumenator> Is having read the first 6 chapters of BONUS's tutorial enough to begin web programming with Haskell?
11:38:39 * ski still doesn't understand what it means ..
11:38:40 <idnar> Badger: sorry :P
11:38:51 <ski> (assuming it has any meaning)
11:38:55 <Badger> ski: it's a meme
11:39:07 <ski> yes, and ?
11:39:25 <soupdragon> ski: it is like an advertisment I think
11:39:55 <Badger> ski: memes have no reasoning :P
11:40:02 <gwern> @quote nine.thousand
11:40:02 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
11:40:10 * gwern is shocked. be funnier people
11:40:17 <idnar> anyway, I have a tendency to blurt that response out when people refer to handwavy meaningless quantifications like "it's faster!"
11:40:18 <sinelaw> @quote lambdabot
11:40:19 <lambdabot> lambdabot says: [in #haskell] there are a lot of weirdos on here
11:44:16 <sinelaw> Anyone familiar with a short, clear, presentation of FRP for imperative-programming people?
11:44:16 <deech> Hi all, aside from using Haskell and Hoogle, is there anyway to get ghci to search for a function or module that hasn't been imported?
11:44:38 <monochrom> No.
11:44:46 <dschoepe> deech: Not in ghci, but there's also hayoo.
11:44:51 <dschoepe> @where hayoo
11:44:52 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:45:13 <deech> dschoepe, yes I meant hayoo, brain fart
11:46:01 <aavogt> can't hoogle be integrated into ghci?
11:46:02 <SamB> deech: do you have hoogle/hayoo set up to run under GHCi?
11:46:12 <SamB> aavogt: of course it can
11:46:17 <SamB> dunno how much work it is
11:46:25 <aavogt> that would be great to have
11:46:27 <SamB> but GOA showed us that it's possible ;-)
11:46:41 <SamB> though I expect GOA is bitrotted at the moment
11:47:09 <deech> samB: really? I have an emacs keyboard shortcut that does a Hayoo search,  but it is outside of GHCI.
11:47:15 <SamB> GOA == GHCi On Acid == GHCi with lambdabot tacked in
11:47:18 <soupdragon> why so much interest in PRP?
11:47:53 <monochrom> because everyone understands monads now. we need new challenges.
11:47:59 <soupdragon> hehe
11:48:02 <soupdragon> okay
11:48:12 <SamB> which is to say, it consists of some haskell modules and some .ghci macros to glue (presumably only an old version of) lambdabot into GHCi
11:48:29 <gwern> sinelaw: well, the shortest and clearest FRP is probably some commandline unix tools using 'interact' :)
11:48:40 <monochrom> It may be also about time we stepped into GUI programming with our usual elegance.
11:48:47 <deech> samb, is there some way other than goa to do it?
11:48:52 <SamB> deech: sure!
11:48:58 <sinelaw> gwern, huh?
11:49:10 <gwern> :type interact
11:49:19 <ski> @type interact
11:49:19 <gwern> @hoogle interact
11:49:19 <lambdabot> Prelude interact :: (String -> String) -> IO ()
11:49:20 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
11:49:20 <lambdabot> System.IO interact :: (String -> String) -> IO ()
11:49:20 <lambdabot> (String -> String) -> IO ()
11:50:00 <sinelaw> gwern, may i have an explanation in English? :)
11:50:03 <LeoD> interact is FRP?
11:50:09 <copumpkin> :t interact
11:50:11 <lambdabot> (String -> String) -> IO ()
11:50:15 <copumpkin> don't think so ;)
11:50:21 <gwern> sinelaw: that *is* english! but try (stdin -> stdout) -> IO ()
11:50:32 <soupdragon> you can tell from the type?
11:50:52 <gwern> interact is a very simple-minded FRP function
11:51:06 * SamB resolves to write some thing to stick in .ghci to integrate hoogle with GHCi, and add it to the haddock
11:51:24 <gwern> SamB: that's easy
11:51:26 * ski . o O ( cointeract :: IO a -> (String -> IO (a,String)) )
11:51:32 <gwern> now, integration with hlint, that was hard
11:51:42 <SamB> or, wait, there's something on the wiki
11:51:54 <SamB> http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration
11:52:14 <Fairweather> anyone want to answer a newb question
11:52:20 <gwern> I was mildly amazed that it was actually doable, to get the list of loaded modules, shell out to hlint, and report its results
11:52:21 <SamB> this seems kind of like a cop-out though
11:52:22 <Fairweather> :)
11:52:40 <SamB> I mean, running it as an external executable!
11:52:43 <Saizan_> Fairweather: this channel is here for that purpouse! just ask :)
11:52:45 <ski> just ask your question
11:52:51 <Fairweather> ok, one second
11:52:52 <gwern> I just hope ghci doesn't change ever, because there's no way I can debug my hlint ghci commands...
11:52:56 <SamB> it'd be so much cooler to run it *in* GHCi
11:53:07 <Fairweather> do I paste the code in a pastebin
11:53:08 <SamB> gwern: change ever how?
11:53:09 <gwern> SamB: what would it gain you?
11:53:12 <ski> @paste
11:53:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:53:18 <SamB> gwern: well, it would run faster on windows ?
11:53:22 <Fairweather> thanks
11:53:42 <gwern> SamB: oh, some ghci command could change semantics, or the multiple levels of interpretation could change subtly... honestly, just about anything could break it
11:54:11 <Fairweather> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6852#a6852
11:54:13 <SamB> gwern: I'm thinking the most likely issue you'll see is one of the abbreviations you might use will be broken
11:54:17 <SamB> think like :b
11:54:22 <SamB> used to mean :browse
11:54:31 <Fairweather> i'm reading the gentle guide
11:54:31 <gwern> no, I don't use abbreviations
11:54:38 <SamB> now it only does for, well, probably just me :-(
11:54:55 <gwern> SamB: for the complexity of what I mean, see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6853#a6853
11:55:05 <Fairweather> but I can't seem to make this work
11:55:10 * ski imagines a lambda-cat saying "gentle cat is gentle"
11:55:35 <gwern> that's not a lambdacat. that's a /b/ cat, or maybe /d/...
11:55:43 <ski> Fairweather : you want  [f x' y']  rather than  (f x' y')
11:55:43 <Fairweather> it looks ok to me...
11:55:58 <SamB> gwern: but it's a Gentle Introduction joke
11:56:03 <SamB> it doesn't make sense in that context
11:56:03 <Fairweather> oh :)
11:56:10 <Fairweather> thanks
11:56:14 <ski> do you see why ?
11:56:19 <gwern> oh, it makes sense, SamB. all the wrong kind of sense
11:56:33 <Fairweather> because f returns a single value?
11:56:56 <SamB> gwern: I mean, it would be a different joke in that context
11:57:04 <SamB> assuming you're talking about 4chan
11:57:04 <Fairweather> if that is so, I guess it's obvious
11:57:19 <SamB> most people are when they mention single letters between slashes
11:57:37 <ski> Fairweather : yes
11:57:56 <SamB> gwern: well, I can tell you one thing: those lines are way too long
11:58:07 <SamB> makes me wish GHCi worked like the python interpreter
11:58:33 <ski> Fairweather : y >>= ...  wants its right argument to be a function returning a list
11:58:38 <SamB> and kept reading lines until you completed the expression or let
11:58:56 <gwern> SamB: alas! our dried voices as we whisper together / are quiet and meaningless / as wind in dry grass
11:58:57 <SamB> or :define
11:59:04 <gwern> er, I mean, alas, ghci just works that way
11:59:12 <Fairweather> ski: i guess I should make some allowance for errors in a tutorial
11:59:20 <SamB> though now I think about it that would be way harder than doing it for straight-up expressions
11:59:34 <Fairweather> they might even make it more interesting :)
12:00:15 <SamB> AND would probably break this code, since they'd have to change :define's API so the command could say whether it had had enough input
12:01:04 <SamB> gwern: so I suppose the closest we could hope for would be here documents :-(
12:01:31 <EvilRanter> SamB, we do have :{ ... :} in ghci
12:01:50 <SamB> EvilRanter: that doesn't help you to actually get those newlines in there, though
12:02:23 <SamB> hmm ... your nick seems strangely familiar, and yet different
12:02:40 <SamB> EvilTerran?
12:02:47 <EvilRanter> yes
12:03:02 <EvilRanter> > sort "terran" == sort "ranter"
12:03:04 <lambdabot>   True
12:03:09 <SamB> heh
12:04:01 <EvilTerran> SamB, you mean newlines in strings, or something else?
12:04:22 <SamB> EvilTerran: did you see that horrific .ghci code that gwern pasted?
12:04:27 <EvilTerran> no
12:04:36 <EvilTerran> looking now
12:04:39 <SamB> the lines were several times as wide as my browser window
12:04:52 <SamB> or, well, >2x I think
12:09:22 <EvilTerran> SamB, ":{\nlet x =\n    1\n:}\nx" works for me in ghci; i don't know if they work the same way in .ghci files
12:10:30 <EvilTerran> but, if they do, surely they'd be suitable for splitting up those "let"s across multiple lines?
12:11:32 <EvilTerran> you could group all the lets together under a single ":{\nlet\n...\n:}"
12:14:08 <SamB> EvilTerran: oh
12:14:16 <SamB> I missed the :s
12:17:35 <EvilTerran> i get http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6853#a6855
12:18:49 * EvilTerran looks at "redir" there, and finally catches on to what ski was getting at with cointeract
12:19:07 <SamB> why do you put all of those in one let?
12:24:52 <monochrom> Whee, Data.Map seems to be superb for longest increasing subsequence.
12:25:41 <monochrom> Oh! I forgot there was a nice xkcd-induced dynamic programming problem too!
12:28:02 <deech> Trying to understand kinds. Is the kind of a type just the number of free variables in the type definition? So data A x y z = ... has kind * -> * -> *. Correct?
12:29:01 <deech> or * -> * -> * -> * rather.
12:29:07 <Saizan> with that much information A has kind k1 -> k2 -> k3 -> *
12:29:32 <Saizan> k1,k2,k3 depend on how x,y and z are used
12:29:47 <Saizan> e.g.
12:30:11 <Saizan> data A x y = A (x y) gives A :: (* -> *) -> * -> *
12:30:35 <Saizan> kinds are like types for types
12:30:53 <copumpkin> kindclasses!
12:31:55 <Berengal> Iteratee is starting to make sense...
12:32:29 <deech> Saizan, I don't understand, why the (* -> * )?
12:32:44 <Saizan> deech: because x is applied to another type
12:32:51 <Saizan> deech: so it must take a parameter
12:33:34 <Saizan> deech: that's what (x :: * -> *) says "x takes a type of kind * and returns a type of kind *"
12:33:41 <soupdragon> cointeract :: IO a -> (String -> IO (a,String))
12:33:45 <Saizan> deech: * is the kind of types of values
12:34:05 <deech> So x takes a concrete type and and produces a concrete type, hence (* -> *)
12:34:34 <deech> and the y is the concrete type that is applied to x so (* -> *) -> *
12:34:58 <aavogt> soupdragon: isn't that the same as  :: IO a -> String -> IO (a,String)
12:35:01 <deech> and type A is produced so (* -> *) -> * -> *. Is my logic correct?
12:35:38 <Saizan> yeah, except that calling types of kind * concrete is not standard terminology
12:35:47 <Saizan> they are sometimes referred as "proper types"
12:35:59 <Saizan> as opposed to type-constructors or type-functions
12:35:59 <soupdragon> aavogt, yes but the bracket is probably there for a reason
12:36:09 <deech> oh, learn you a haskell seems to refer to them as concrete.
12:36:34 <soupdragon> (that I dont know yet)
12:36:56 <Saizan> by concrete i usually understand "not a variable" in this context
12:36:57 <deech> ok, so now I know what "proper types" are!
12:37:39 <deech> saizan, "learn you a haskell" says that Int is a concrete type because its kind is *.
12:38:06 <Saizan> deech: which chapter?
12:38:23 <soupdragon> deech, is that a definition of 'concrete type'?
12:38:34 <Cale> I like the term concrete for types that have values.
12:38:45 <Cale> (thinking about it now)
12:38:48 <deech> saizan, http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo, 3rd paragraph
12:38:56 <soupdragon> Cale, undefind counts?
12:39:01 <Cale> yeah
12:39:14 <Saizan> yeah it's actually nice, but i never seen it used like that
12:39:54 <deech> soupdragon, I don't understand the distinction.
12:40:11 <Berengal> What's the status on ghc plugins?
12:40:15 <deech> soupdragon, are you asking if all things of kind * are concrete?
12:40:36 <soupdragon> no
12:41:14 <Saizan> however yeah, LYAH defines "concrete type" as "type with kind *"
12:41:53 <aavogt> I know what interact does, is there any intuition for what cointeract does?
12:42:20 <FunctorSal> *waits for someone to ask what cointeract is*
12:42:20 <soupdragon> aavogt, I can't figure it out
12:42:31 <aavogt> @type (flip ap .) . flip (,)
12:42:33 <lambdabot> forall b a a1. (Monad ((,) a)) => a1 -> a -> (a, a1 -> b) -> (a, b)
12:43:01 <Saizan> (is there a definition for cointeract?)
12:44:15 <aavogt> @type \x y -> fmap (\e -> (e,y)) x
12:44:17 <lambdabot> forall a t (f :: * -> *). (Functor f) => f a -> t -> f (a, t)
12:44:19 <FunctorSal> aavogt: is that supposed to have something to do with interact :: (String->String)->IO()?
12:44:46 <aavogt> FunctorSal: supposedly
12:45:14 <FunctorSal> (previous topic) how about "fully applied types"?
12:45:30 <FunctorSal> "concrete" is already overoverloaded
12:45:35 <FunctorSal> concrete category etc
12:45:37 <aavogt> @type \x y -> fmap (\e -> (e,y)) (x:: IO a)
12:45:39 <lambdabot>     Inferred type is less polymorphic than expected
12:45:39 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
12:45:39 <lambdabot>         x :: IO a (bound at <interactive>:1:1)
12:45:59 <aavogt> @type \x y -> fmap (\e -> (e,y)) (x `asTpeOf` (undefined :: IO a))
12:46:01 <lambdabot> Not in scope: `asTpeOf'
12:46:06 <Badger> Never seen that error before.
12:46:11 <aavogt> @type \x y -> fmap (\e -> (e,y)) (x `asTypeOf` (undefined :: IO a))
12:46:13 <lambdabot> forall t a. IO a -> t -> IO (a, t)
12:46:28 <aavogt> Badger: which one?
12:46:32 <Badger> less polymorphic
12:47:17 <aavogt> > "abc" :: [a]
12:47:19 <lambdabot>   Couldn't match expected type `a'
12:48:39 <aavogt> @type \x y -> fmap (\e -> (e,y)) x :: IO a -> String -> IO (a, String)
12:48:41 <lambdabot>     Couldn't match expected type `String -> IO (a, String)'
12:48:41 <lambdabot>            against inferred type `(a1, t)'
12:48:41 <lambdabot>     In the expression: (e, y)
12:48:41 <soupdragon> F "abc" `asTypeOf` (undefined :: [a])
12:48:45 <soupdragon> > "abc" `asTypeOf` (undefined :: [a])
12:48:46 <lambdabot>   "abc"
12:49:17 <aavogt> @src interact
12:49:18 <lambdabot> interact f = do s <- getContents; putStr (f s)
12:49:57 <Berengal> I assume cointeract gives you access to stdin and stdout in the IO action...
12:50:09 <Badger> @index cointeract
12:50:10 <lambdabot> bzzt
12:50:13 <jeffwheeler> Is there any convenient way to remove all the dependencies of a package?
12:50:26 <jeffwheeler> I'd like to test installing a package from scratch . . .
12:50:38 <aavogt> jeffwheeler: make a new .cabal
12:50:48 <jeffwheeler> aavogt: I suspected I might have to go that far; okay
12:51:13 * jeffwheeler thinks he should've made a backup copy before doing rm -rf
12:51:34 <FunctorSal> jeffwheeler: make a new user?
12:51:48 <Berengal> rm -rf .cabal won't remove the installed packages
12:51:51 <FunctorSal> (new OS user)
12:51:51 <jeffwheeler> FunctorSal: too late :)
12:52:00 <FunctorSal> oh no!
12:52:59 <aavogt> cabal install doesn't touch anything outside of .cabal and .ghc for user installs though?
12:53:25 <Berengal> Don't think so. At least I've been fine only manipulating those
12:55:40 <roconnor> is anyone here an audiophile?
12:56:06 <erisco> how do I define a data constructor for a Map? I am confused
12:56:20 <erisco> I get: Expected kind `?', but `Map' has kind `* -> * -> *'
12:56:42 <Berengal> erisco: Map already has them defined, but you can't import them
12:57:21 <erisco> Berengal,  I am making a new type constructor and one of the data constructors is supposed to be a Map, just like a data constructor might be a String
12:57:29 <aavogt> @type cos
12:57:30 <lambdabot> forall a. (Floating a) => a -> a
12:57:32 <aavogt> @type sin
12:57:34 <lambdabot> forall a. (Floating a) => a -> a
12:57:49 <Berengal> erisco: Got some preliminary code?
12:58:04 <Berengal> erisco: Also, String isn't a data constructor, it's a type
12:58:26 <aavogt> is that usage of co- the same as interact <-> cointeract, pumpkin <-> copumpkin?
12:58:27 <erisco> Berengal, yes, of course, but so is Map no?
12:58:48 <Berengal> erisco: Map is a type constructor. You need to apply two types to it to get a type
12:58:52 <erisco> Berengal, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6859#a6859
12:59:01 <Cale> erisco: Map is a type constructor which is supposed to take 2 types as parameters
12:59:06 <erisco> Berengal, duh...
12:59:08 <Berengal> Map Int String is a type, Map Foo Bar is another type, Map is a type constructor, Map Int is also a type constructor
12:59:22 <Cale> @kind Map
12:59:23 <maltem> roconnor, audiophile as in paid a couple of thousands for their stereo? not really
12:59:24 <lambdabot> Not in scope: type constructor or class `Map'
12:59:28 <Cale> sigh
12:59:31 <Cale> @kind M.Map
12:59:40 <lambdabot> * -> * -> *
12:59:42 <Berengal> JObject (Map JValue JValue)
12:59:46 <Cale> @kind M.Map String
12:59:47 <lambdabot> * -> *
12:59:51 <Cale> @kind M.Map String Integer
12:59:52 <lambdabot> *
12:59:59 <erisco> Berengal, Cale, it is working now, thanks
13:00:17 <roconnor> maltem: as in has a geeky interest in audio
13:01:41 <Berengal> roconnor: What do you need an audiophile for?
13:02:48 <roconnor> I have some reel to reel tapes I want to digitize.  I want to know what a reasonable sampling rate would be
13:03:28 <roconnor> I guess it would be the lowest usual wav rate
13:03:56 <mikm> Try asking/searching over at hydrogenaudio.  They are level-headed audiophiles (as opposed to the $10,000-speaker-cable sort)
13:05:05 <erisco> how do I construct a JObject now? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6860#a6860
13:05:18 <erisco> I have tried numerous things but every one errors saying it cannot match the type
13:05:18 <roconnor> mikm: thanks for the pointer!
13:05:24 <roconnor> mikm++
13:05:37 <Berengal> erisco: JString "Hello", or JNumber 5
13:05:45 <Berengal> etc
13:06:03 <erisco> Berengal, I want to know how to make a JObject, the rest I understand
13:06:14 <Berengal> erisco: That is a JObject
13:06:24 <Berengal> erisco: try :t JString
13:06:52 <erisco> Berengal, er, no, it is a JValue
13:07:00 <Berengal> Oh, right, sorry
13:07:12 <Berengal> JObject someMap
13:07:37 <Berengal> e.g JObject (fromList [("Key", JString "Value")])
13:07:50 <erisco> oh, there is no data constructor for Map?
13:07:50 <pikhq> mikm: Ah, yes. The guys that actually do A/B testing and realise that there's a point of diminishing returns with most equipment. :)
13:08:01 <mikm> Indeed
13:08:17 <Berengal> erisco: There are, but they're hidden. You can see what they are with :info Map, but you can't use them in code
13:08:34 <pikhq> roconnor: 44100 Hz or 48000 Hz, depending on whether you want it to be CDDA or DVD audio.
13:08:50 <erisco> Berengal, I see, so they are constructed from a list of pairs, okay. thanks
13:09:04 <pikhq> Both sampling rates are well above what's needed for all that is audible (by the Nyquist theorem)
13:09:25 <coCocoa> Interesting - "undefined" means that every monad can be treated as a comonad.
13:09:27 <roconnor> pikhq: but it is an old reel-to-reel.  I would have expected such a high sample rate to be a waste.
13:09:51 <pikhq> roconnor: Possibly, but there's no point in not sampling it as 44100.
13:10:03 <Berengal> erisco: You don't have to use a list of pairs. "foldr insert empty . unfoldr makeKeyValuePairs $ seed" works
13:10:17 <Berengal> Though actually, that's pretty much the same...
13:10:29 <pikhq> Especially if you're going to be compressing that.
13:10:29 <Berengal> (I think fromList = foldr insert empty)
13:10:43 <roconnor> pikhq: sampling lower than 44100 should save space.
13:10:46 <roconnor> ha
13:10:48 <roconnor> ah
13:11:01 <roconnor> I guess if I use Flac, then there won't be too much difference with a higher rate
13:11:03 <pikhq> If you store it as a .wav file, yes.
13:11:05 <pikhq> But who does that?
13:11:08 <roconnor> difference in size I mean
13:15:31 <EvilTerran> SamB, i put it all in one let to eliminate the punctuation noise of :} ... :{ between each definition
13:16:42 <roconnor> pikhq: ... now about my punchcards ...
13:17:30 <pikhq> roconnor: How good are you with ASCII or EBCDIC?
13:18:22 <roconnor> pikhq: I'm great with ASCII
13:18:42 <pikhq> Then open up a text editor and get a box of punch cards and get busy.
13:21:45 <roconnor>  pikhq sounds error prone :D
13:22:08 <roconnor> pikhq: actually the text is printed on the top of each card
13:24:46 <soupdragon> "Experience shows that scientific progress is best achieved by postponing discussion of such issues until the  underlying scientific issues have been resolved, and the tools are available for its wide-spread application."
13:25:14 <pikhq> Then get typing.
13:25:17 <pikhq> ;p
13:27:08 <Berengal> roconnor: get n small directional speakers and n small directional microphones. Put them so each speaker points at a corresponding microphone, use your new sonic scanner to scan the cards. If you lack enough input ports, make the speakers output a unique frequency, splice the microphones and FFT the result
13:27:20 <Berengal> unique frequency each*
13:31:58 <soupdragon> There will be a hierarchy of recognised levels of verification, ranging from avoidance
13:31:58 <soupdragon> of specific exceptions like buffer overflow, general structural integrity (or crash-
13:31:58 <soupdragon> proofing), continuity of service, security against intrusion, safety, partial functional
13:31:59 <soupdragon> correctness, and (at the highest level) total functional correctness
13:33:22 <soupdragon> there could bse a safe haskell thing, which gives safety level one
13:34:54 <sm> hey all.. why does this code hang if cmd does not read things from stdin ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6861#a6861
13:35:44 <Heffalump> because hPutStr blocks writing
13:35:54 <Heffalump> forkIO it
13:36:32 <sm> hmm.. when you say hPutStr blocks writing..
13:36:47 <sm> which writing exactly ?
13:37:56 <sm> oh hPutStr itself.. I see...
13:38:13 <performance> ne one used haskell flickr api?
13:38:58 <Heffalump> if you run it under forkIO, the Haskell RTS will take care of multiplexing the reads and writes
13:40:59 <Figs> Is there a way I can dispatch my function based on the types of my parameters?
13:41:07 <sm> Heffalump: just forkIO $ hPutStr ih i'  ? it doesn't seem to hel
13:41:08 <soupdragon> yes
13:41:09 <sm> p
13:41:27 <Figs> basically what I want to do is something like
13:41:30 <Heffalump> I think it should, unless you're running into a GHC bug
13:41:36 <sm> I'm just running with runhaskell.. does that include -threaded for me ?
13:41:36 <Heffalump> oh, actually, you probably are
13:41:37 <Figs> combine :: x -> y -> Maybe z
13:41:48 <Heffalump> you shouldn't need -threaded, but the GHC bug probably means you do need it
13:41:59 <Figs> Where x and y and z are some sorts of item types that I don't know all the details of yet
13:42:43 <sm> compiling with -threaded didn't help either. rats.
13:43:15 <Figs> So something like
13:43:36 <Figs> combine (Bucket empty) (Water) -> Just (Bucket Water)
13:44:10 <Figs> combine Bleach Ammonia -> Just PoisonGas
13:44:16 <Figs> combine _ _ -> Nothing
13:44:23 <soupdragon> Figs, huh
13:44:39 <Heffalump> sm: hmm, now I'm confused
13:45:24 <Heffalump> so the process does actually terminate, right?
13:45:49 <sm> Heffalump: I'm pretty certain it does.. I can run it by hand
13:45:52 <Berengal> class Combine x y where type Combined x y :: *; combine :: x -> y -> Combined x y
13:45:55 <sm> it generates some output and terminates
13:46:32 <Heffalump> what GHC version?
13:46:49 <Heffalump> http://hackage.haskell.org/trac/ghc/ticket/3316 is the bug I was talking about
13:47:09 <Figs> Berengal: what does "Combined x y :: *" mean?
13:47:20 <Figs> Combined xy is of type ... anything?
13:47:22 <Berengal> Figs: It's a type family
13:47:53 <Berengal> you write e.g. "instance Combine Bleach Ammonia; Combined Bleach Ammonia = PoisonGas; combine = foo"
13:48:02 <Philippa> Figs: of kind *, which means a type
13:48:08 <sm> Heffalump: 6.10.3
13:48:28 <Heffalump> can you try 6.8.2?
13:48:45 <Philippa> as opposed to * -> *, for example, which is the kind of Maybe
13:49:37 <sm> I can, one sec
13:49:57 <Berengal> Figs: http://www.haskell.org/haskellwiki/GHC/Type_families
13:50:04 <Cale> Berengal: you missed the keyword 'type' in your instance
13:50:21 <Berengal> Cale: yeah, my bad
13:50:22 <Philonous> Figs: It means you actually have 3 types, x, y and Combined, where Combined is determined by x and y.
13:50:46 <Cale> It is a bit annoying that we have to use the type keyword there.
13:50:53 * sm hugs cabal install -w ghc-6.8.2
13:51:01 <Philonous> i.e. whenever you want to make to types combineable (an instance of Combine), you provide the result type
13:51:03 <Cale> But syntactically, it looks the same as a pattern binding otherwise.
13:51:07 <erisco> I compiled a module that imported Data.Map into an object file successfully, when when I try to compile my Main module into an executable (and it imports the object file) the compiler complains about undefined references in the object file to Data.Map things (all the names are generated and don't seem to make much sense)
13:51:17 <sm> oops, too soon
13:51:20 <Cale> erisco: --make
13:51:47 <Cale> erisco: You should always add the flag --make to your ghc commandline, so that it figures out what -package flags to add for you
13:51:57 <Cale> erisco: Otherwise, I think you'd need -package containers
13:52:05 <erisco> Cale, okay, the book really sucked at explaining it right
13:52:14 <Berengal> --make is the magic "make it work" flag
13:52:27 <erisco> it compiled this time :) thanks
13:53:09 <Heffalump> sm: I usually just change my path, it seems to work properly then
13:54:01 <Cale> The other thing I like about --make is that you don't need -o
13:54:29 <Cale> Or even to specify the name of the file properly. ghc --make MyProgram
13:54:35 <Berengal> Sometimes I like to combine -main-is and -o when making several small executables...
13:55:48 <sm> Heffalump: I need to get some more packages installed with ghc 6.8.. I note that it works on linux with 6.10.3 though. I'm on a mac here
13:56:10 <Heffalump> oh, interesting
14:00:31 <zeppterm> hey guys
14:00:34 <sm> Heffalump: and building with 6.8 on the mac didn't help
14:00:48 <zeppterm> can you do virtual constructors in haskell classes?
14:03:25 <monochrom> Such as?
14:04:00 <aavogt> are they like default definitions in type classes?
14:04:29 <zeppterm> they are like virtual functions in c++
14:05:17 <zeppterm> also, how do i dereference pointers in haskell?
14:06:10 <sm> guess I'll report it
14:06:31 <Berengal> zeppterm: Haskell has no pointers, unless you're interfacing with c
14:07:08 <Cale> zeppterm: If you're using the FFI, see peek and poke in Foreign.Storable
14:07:22 <Cale> :t peek
14:07:24 <lambdabot> Not in scope: `peek'
14:07:28 <Cale> :t Foreign.Storable.peek
14:07:30 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
14:07:34 <Cale> :t Foreign.Storable.poke
14:07:36 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> a -> IO ()
14:07:57 <monochrom> Yay Cale is here!
14:08:18 <zeppterm> I need to call delete on something I allocated in C++
14:08:47 <sm> oops, out of battery
14:08:55 <sm> Heffalump: http://hackage.haskell.org/trac/ghc/ticket/3369 . Thanks for the help
14:09:00 <Cale> zeppterm: hmm... I'm not sure it would be so easy to deallocate it from the Haskell side properly, as delete is more complicated than just freeing memory in C++, isn't it?
14:09:16 <maltem> uh... you need to allocate it in C++, but deallocate from Haskell?
14:09:39 <Cale> zeppterm: You might have to write something on the C++ side in order to wrap the deletion.
14:11:10 <pikhq> Cale: delete is both freeing memory and calling deconstructors.
14:12:30 <pikhq> Bit tricky to get that right from Haskell.
14:13:37 <Cale> pikhq: right
14:13:56 <jeffwheeler> For what it's worth, deleting just .cabal without .ghc causes problems; deleting both works fine, though.
14:26:35 <mjrosenb> ghc is compiling
14:26:37 * mjrosenb bounces
14:26:47 <Badger> @quote
14:26:48 <lambdabot> dave_m says: < Bobstopper> Assuming the universe will eventually die of heat death, counting will cease when that happens. So if you start counting now, you'll probably find the largest number (so
14:26:48 <lambdabot> long as nobody else has found a larger one yet) < Cale> what about faster ways to produce larger numbers? < Bobstopper> not after the heat death you can't :P < dave_m> don't you tell me what I can't
14:26:48 <lambdabot> do after the heat death of the universe
14:26:54 <Badger> That'll keep you entertained!
14:27:07 <hoknamahn> hey guys is there a leksah channel?
14:27:31 <zeppterm> haskell should have dynamic typing like scheme
14:27:54 <pikhq> zeppterm: No.
14:28:08 <Cale> zeppterm: That would completely break half of its features
14:28:11 <RayNbow> @quote JN
14:28:13 <lambdabot> JN says: this tutorial just introduced _|_ and called it bottom.  I assume that's because it looks like an ass?
14:28:18 <Cale> zeppterm: You can't do typeclasses without types.
14:28:40 <pikhq> There goes the monads.
14:28:45 <Cale> zeppterm: and then monads are pretty hard to do nicely at all in a system without something like typeclass polymorphism, yeah
14:28:50 <Heffalump> Cale: you could in theory use dynamic types to do them
14:29:10 <Cale> Return type polymorphism is hard in a dynamically typed setting
14:29:14 <Cale> :t read
14:29:16 <lambdabot> forall a. (Read a) => String -> a
14:29:19 <pikhq> Heffalump: Including one-way monads like IO?
14:29:20 <Heffalump> agreed
14:29:52 <Heffalump> Cale: well, you could in theory pass the typing context around at runtime
14:30:52 <Cale> Heffalump: you mean make the programmer do it explicitly?
14:31:22 <soupdragon>  <Heffalump> Cale: well, you could in theory pass the typing context around at runtime
14:31:22 <mjrosenb> Igloo: ping?
14:31:27 <soupdragon> why?
14:31:32 <Igloo> mjrosenb: pong
14:31:33 <Heffalump> Cale: no
14:31:38 <Heffalump> the compiler could do that
14:31:46 <Cale> Without checking the types? :)
14:31:53 <Heffalump> soupdragon: if you wanted to make Haskell dynamically typed
14:32:03 <Heffalump> which we don't
14:32:48 <mjrosenb> Igloo: i've gotten to building ghc on the target, and it died because it did not know how to build Apply.o
14:33:01 <mjrosenb> Igloo: which is in the rts directory
14:33:10 <Cale> zeppterm: that said, there is Data.Dynamic if you really want/need it.
14:33:25 <Igloo> mjrosenb: Does rts/Apply.cmm exist?
14:33:35 <Igloo> mjrosenb: on the host, that is
14:33:37 <Cale> zeppterm: Or existential types, or just designing things sanely in the first place ;)
14:34:06 <mjrosenb> Igloo: yes, and it exists on the target as well
14:34:17 <Igloo> mjrosenb: What about rts/Apply.hc ?
14:34:21 <Cale> zeppterm: If you really feel the need for dynamic typing, chances are we can help you find a way not to need it anymore.
14:34:33 <FunctorSal> hehehehe
14:35:13 <mjrosenb> Igloo: yes, in both
14:35:42 <Cale> One thing which I wish more Haskell tutorials would incorporate (maybe I should talk to BONUS) is examples of the coalgebraic style of datatypes (of course they don't have to call it that)
14:36:00 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell -- I wrote this in order to explain it a bit :)
14:36:00 <soupdragon> what is that, Cale?
14:36:42 <Cale> soupdragon: Basically, using datatypes which store a record consisting of the operations you want to have on your data rather than a concrete description of its parameters.
14:37:23 <Cale> soupdragon: This is what I think is the essential core of object oriented programming.
14:37:37 <soupdragon> on yeah, nobody writes like that afaict.. except in that research paper
14:37:43 <Cale> While it's important for OO programmers to learn not to do everything that way, it's still an important technique.
14:37:51 <mjrosenb> Igloo: last time i tried this, i just manually compiled those files, but everything broke down shortly thereafter
14:38:21 <soupdragon> circle radius (ax,ay) (vx,vy) (x,y) = GameObject { .. }
14:38:29 <soupdragon> is that real code?
14:38:49 <soupdragon> nice!
14:39:00 <FunctorSal> -XRecordWildCards
14:39:43 <soupdragon> cool Cale
14:40:08 <soupdragon> turining peoples code inside out :)
14:41:26 <Igloo> mjrosenb: Hmm, I think the problem is that there are no rules in the BootingFromHc=YES case of rules/cmm-suffix-rules.mk for some reason
14:42:02 <Igloo> mjrosenb: You can probably just copy a rule or two from rules/hs-suffix-rules-srcdir.mk
14:43:10 <FunctorSal> "* desu is now known as mudkipzz"
14:43:21 <mudkipzz> ?
14:43:29 <FunctorSal> just saying :)
14:43:53 <FunctorSal> as has probably come to your attention, I do in fact like mudkips
14:43:58 <desu> o.o
14:44:03 <soupdragon> http://desudesudesu.net/
14:44:09 <desu> so, what i heard was right o.o
14:44:15 <soupdragon> main = putStr (cycle "desu ")
14:44:18 <jeffwheeler> Hmm, I can't seem to install darcs (on this Ubuntu system) from Cabal because I don't have the C library curl, on which it depends. I've got libcur3, which provides /usr/lib/libcurl.so.3 and .4, though
14:44:34 <jeffwheeler> and Darcs was installed a moment ago, and I haven't changed any packages since then
14:45:21 <jeffwheeler> Installing the curl package on Hackage results on the same problem as Darsc
14:45:29 <jeffwheeler> Wow, typos galore: libcurl3 and Darcs
14:46:02 <Saizan> jeffwheeler: you want the -dev version
14:46:03 <Cale> desu: 
14:46:36 <Gracenotes> halp, kanji. *cowers*
14:46:49 <mjrosenb> Igloo: $1/$2/build/%.$$($3_osuf) : $1/$2/build/%.hc includes/ghcautoconf.h includes/ghcplatform.h "$$(CC)" $$($1_$2_$3_ALL_CC_OPTS) -Iincludes -x c -c $$< -o $$@
14:46:55 <jeffwheeler> Saizan: I assumed the lib- version was the same thing, because there is no dev version; there's a -dbg and -gnutls version of the lib package, and a separate package that's just 'curl'
14:47:08 <mjrosenb> Cale: wait, i have unicode set up correctly?
14:47:18 <desu> Cale: nope :( i'm just a weaboo...
14:47:26 <Cale> mjrosenb: I don't know, do you?
14:48:37 <Saizan> jeffwheeler: http://packages.debian.org/lenny/libcurl4-openssl-dev ? i don't use a debian-like system currently, so i'm mostly guessing
14:48:42 <Badger> Cale: wait, you speak Japanese?
14:49:17 <Cale> Badger: I'm learning it.
14:49:44 * Badger wonders why this seems to be common.
14:50:08 <Gracenotes> Cale: oh, how far along? If you do already know some kanji after all..
14:50:09 <jeffwheeler> Saizan: hmm, I used the libcurl4-gnutls-dev package; I assumed that was wrong, because the other curl packages seemed to be curl3
14:50:31 <jeffwheeler> Saizan: and I picked -gnutls-dev over -openssl-dev because I already had one of the -gnutls packages installed; thanks for the help
14:50:35 <Cale> Well, I'm not sure why most people learn it (probably anime or something), but for me, it's because I was obsessed with symbols as a small child, and learned kana and a handful of kanji, and ever since then it's bothered me that I have an incomplete knowledge of Japanese.
14:51:25 <desu> <Cale> Well, I'm not sure why most people learn it (probably anime or something) <--- D: you're so right that it's scary D:
14:51:48 * mjrosenb does not understand the obsession with anime
14:52:29 <Cale> Gracenotes: I know about 1000 kanji now, and my comprehension isn't perfect, but watching some TV shows, it's getting pretty good (I understand maybe 75% of what's said without looking at the subtitles.)
14:52:44 <desu> mjrosenb: you would if you were a pimply fat teenaged geek who wouldn't get a girl even if he paid for one.
14:52:50 <Cale> Gracenotes: producing it is harder, but I can get by with a dictionary
14:53:09 <Cale> (and I know enough grammar to construct reasonable sentences most of the time)
14:53:11 <Gracenotes> Cale: nice; so you know the Japanese phonetics as well
14:53:18 <Gracenotes> of the kanji that is
14:53:30 <Cale> Well, I know the ones that I know.
14:53:53 <mjrosenb> desu: that was a pretty damned good description of me in high school
14:54:06 <Cale> I don't study the readings though, I just learn words which use the kanji.
14:54:07 <soupdragon> which obsession with anime?
14:54:21 <Gracenotes> it turned out that my college has a fairly large asian population, so I may as well learn some Chinese and Japanese.
14:54:34 <Gracenotes> just enough for basic parsing
14:54:49 <LeoD> does RecordWildCards not work with record updates?
14:54:49 <Cale> My problem is that it's a completely impractical language for me. I have nobody in real life around me who speaks it.
14:54:51 <Gracenotes> (only Japanese at the moment)
14:55:07 <Cale> So I'm mostly just learning it as an intellectual exercise.
14:55:19 <Cale> LeoD: um, how do you mean?
14:55:27 <Cale> LeoD: I don't think it gets in the way of that.
14:55:33 <Gracenotes> Cale: how many other languages do you know?
14:55:39 <soupdragon> Cale I guess that makes it hundreds of times harder
14:55:53 <Cale> Gracenotes: A tiny bit of French
14:56:23 <Gracenotes> I took Spanish for a few years in high school, but didn't think it too exciting; I am pretty enthused about learning Japanese now, and other languages later
14:56:23 <Cale> Gracenotes: Not really much beyond that.
14:56:27 <FunctorSal> desu: I don't get the connection
14:56:53 <FunctorSal> (that probably is because I hardly know anime :))
14:57:29 <desu> FunctorSal: the connection is that almost 50% of those into anime fit that description :|
14:58:00 <Gracenotes> maybe it was the boring routine of the classroom, but I am somewhat excited learning languages on my own now. Ironically (I think), the structure of the classroom might be needed to properly learn a language
14:58:13 <Cale> I started watching anime because I wanted to learn Japanese, rather than the other way around (well, there was one that I watched because I like to play go, but apart from that). But lately I've been more interested in live action TV shows anyway.
14:58:30 <soupdragon> ahaha the Go anime
14:58:32 <FunctorSal> desu: but why? are the stories such that someone in that position can relate to them?
14:59:13 <Saizan> Cale: i can't stand japanese actors.. they are so "fake"
14:59:29 <pikhq> FunctorSal: Mostly, they're obscure. A lot of them are in fact good, but it seems like a lot of the more obsessive anime nerds like the shittier anime...
14:59:29 <desu> FunctorSal: nope. just that anime is probably the kinda thing they _want_ to be or something :/
14:59:37 <pikhq> (because the shit is even more obscure)
14:59:43 <Gracenotes> hm. the korean alphabet looks pretty neat...
14:59:47 <desu> FunctorSal: or probably it gives them a way to release...
14:59:54 <Gracenotes> I've heard people say it's even better than the latin alphabet
15:00:02 <mjrosenb> Igloo: now its looking like nothing in utils/genprimopcode was built on the host machine
15:00:02 <desu> FunctorSal: dunno exactly :/
15:00:10 <pikhq> Gracenotes: That's because it was wholey inventewd by someone. ;)
15:00:19 <soupdragon> pikhq: well all the popular stuff has guns in it
15:00:23 <pikhq> Invented, even.
15:00:24 <Gracenotes> oh, really!
15:00:32 <Cale> Gracenotes: It is interesting. I should learn it. I started to figure it out from examining the menu at a Korean restaurant once. :)
15:00:37 <FunctorSal> (maybe this should be in -blah ;))
15:00:41 <Gracenotes> hah. says Wikipedia, "Numerous linguists have praised Hangul for its featural design, describing it as "remarkable," "the most perfect phonetic system devised," and "brilliant, so deliberately does it fit the language like a glove.""
15:00:45 <pikhq> soupdragon: The exceptionally popular stuff, yeah.
15:00:46 <soupdragon> pikhq: not everyone wants to watch guns going off for hours
15:01:46 <Saizan> FunctorSal: i think you may like Neon Genesis Evangelion, lots of introspection/psychology there, though maybe it's one of those things that only look deep
15:01:48 <mjrosenb> soupdragon: yeah, you need to actually see the bullets hitting something for half of the time
15:02:10 <FunctorSal> Saizan: I did watch that one :)
15:02:11 <Igloo> mjrosenb: Hmm, dunno why not, but "make inplace/bin/genprimopcode" should get it built
15:03:05 <mjrosenb> oh, whoops
15:03:21 <mjrosenb> i stopped when the rts died
15:03:34 * mjrosenb continues with everything that gets built after the rts
15:03:56 <mjrosenb> nope, that still does not exist
15:05:24 <mjrosenb> Igloo: inplace/bin/genprimopcode is up  to date, but there are no hc or cmm variants of the sources in utils/genprimopcode
15:05:38 <nvoorhies> Hangul's really nice.  It's not perfect, but it's better than any other alphabet I can think of.  It only takes a few days to learn if you cram, actually.
15:06:21 <Igloo> mjrosenb: Even buried somewhere in the dist subdirectory?
15:06:44 <Igloo> mjrosenb: It's only .hc you need, incidentally
15:06:59 <mjrosenb> ls utils/genprimopcode/dist/build/
15:06:59 <mjrosenb> Lexer.hi  Lexer.o  Main.hi  Main.o  Parser.hi  Parser.o  ParserM.hi  ParserM.o  Syntax.hi  Syntax.o  tmp
15:07:19 <mjrosenb> ls utils/genprimopcode/
15:07:20 <mjrosenb> Lexer.hs  Lexer.x.source  Main.hs  Makefile  Parser.hs  Parser.y.source  ParserM.hs  Syntax.hs  dist  ghc.mk
15:07:51 <mjrosenb> Igloo: i assumed as much
15:09:46 <Igloo> mjrosenb: Hmm, actually, maybe that's not meant to be built on the target
15:10:48 <mjrosenb> Igloo: well it is :(
15:12:02 <Igloo> I can't see anything in build.mk that would make it generate hc files, but I also can't see anything that would copy the generated files across
15:12:07 * Igloo is confused
15:22:15 <t345> say I want to process byte streams
15:22:25 <zeppterm> ~cxzsdsdaszz/join #csc
15:22:32 <mjrosenb> t345: i want to process byte streams
15:22:41 <t345> mjrosenb: ?
15:22:45 <zeppterm>  /win 2
15:22:46 <t345> hehe
15:22:54 <t345> 2nd try
15:23:33 <mjrosenb> Igloo: would manually generating them, and copying it over help?
15:23:36 <sm> hmm.. "thread blocked indefinitely"
15:23:38 <t345> can I use the type system for letting it take care of verification of the expected structure, size checks, decomposition and so on
15:24:21 <mjrosenb> t345: not without some really dark magic
15:24:22 <Igloo> mjrosenb: Putting a line similar to the "utils/ghc-pkg_dist-install_v_HC_OPTS += -keep-hc-files" line in mk/build.mk should generate them for you
15:24:24 <t345> I've only used bit-syntax in another popular language and after implementing some guards and more complex size checks asked myself how Haskell could be made to help
15:24:29 <t345> mjrosenb: hmm
15:26:12 <monochrom> Not "use type system to check" per se, but the "binary" package eases writing byte stream serializers and deserializers. Also eases reading the code. So simple there is obviously no error.
15:26:36 <mjrosenb> Igloo: that line is already there.
15:27:14 <Igloo> mjrosenb: right, but make a copy for genprimopcode rather than ghc-pkg
15:27:30 <mjrosenb> oh.. whoops
15:28:03 <mjrosenb> Igloo: can i just kill the dist directory?
15:28:12 <Igloo> mjrosenb: Yup
15:28:59 <Rotaerk> hmm I don't understand what groupBy does...
15:29:20 <mjrosenb> "/usr/bin/ghc"  -H32m -O -H32m     -i -iutils/genprimopcode/. -iutils/genprimopcode/dist/build -iutils/genprimopcode/dist/build/autogen -Iutils/genprimopcode/dist/build -Iutils/genprimopcode/dist/build/autogen           -odir utils/genprimopcode/dist/build -hidir utils/genprimopcode/dist/build -stubdir utils/genprimopcode/dist/build -hisuf hi -osuf  o -hcsuf hc -c utils/genprimopcode/./ParserM.hs -o utils/genprimopcode/dist/build/ParserM
15:29:26 <Rotaerk> @src groupBy
15:29:26 <lambdabot> groupBy _  []       =  []
15:29:26 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
15:29:26 <lambdabot>     where (ys,zs) = span (eq x) xs
15:29:39 <benmachine> :t groupBy
15:29:41 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:29:51 * mjrosenb notices a lack of -keep-hc-files
15:29:51 <monochrom> The doc has a mississippi example.
15:30:24 <monochrom> > group "aaaaaaabbbaaaacccccccbddddd"
15:30:26 <lambdabot>   ["aaaaaaa","bbb","aaaa","ccccccc","b","ddddd"]
15:30:31 <t345> mjrosenb: so how do I enter the dark side?
15:30:53 <Rotaerk> > groupBy (<) [1,2,3,3,2,1]
15:30:55 <lambdabot>   [[1,2,3,3,2],[1]]
15:31:01 <monochrom> groupBy is simply group except you provide a comparison operator to replace == , i.e., give your own equivalence relation.
15:31:02 <Rotaerk> that result doesn't make sense..
15:31:14 <mjrosenb> t345: you must go and kill every person who uses a dynamically typed language :-p
15:31:17 <monochrom> No, it doesn't make sense with non-equivalence-relations.
15:31:25 <Rotaerk> ah k
15:31:38 <monochrom> Anyway first understand group, then generalize == to an equivalence relation.
15:31:46 <Rotaerk> I understand now
15:32:00 <mjrosenb> >groupBy (\x y -> toLower x == toLower y) "aAaaAAaAbBBbBbbBbbAaaaaAAAacCCCcCCCccCC"
15:32:13 <monochrom> Yes that's a good example.
15:32:14 <mjrosenb> > groupBy (\x y -> toLower x == toLower y) "aAaaAAaAbBBbBbbBbbAaaaaAAAacCCCcCCCccCC"
15:32:16 <lambdabot>   ["aAaaAAaA","bBBbBbbBbb","AaaaaAAAa","cCCCcCCCccCC"]
15:32:21 <monochrom> Except it takes forever? :)
15:32:29 <hackagebot> happstack-helpers 0.30 - Convenience functions for Happstack. (CreightonHogg)
15:32:45 <mjrosenb> monochrom: it helps when you actually enter something that triggers lambdabot
15:32:56 <monochrom> @bots
15:32:56 <lambdabot> :)
15:32:56 <lunabot>  :)
15:35:11 <Gracenotes> groupBy compares using the first element of a group
15:35:27 <Gracenotes> although nubBy is more complicated.. it uses all previous elements
15:35:58 <mjrosenb> Gracenotes: oh, in that case the example with < makes a whole lot more sense
15:36:56 <Gracenotes> yes.. I thought they were the same at first, but you can see that nubBy's source is so much more confusing than groupBy's :)
15:37:30 <Gracenotes> at first glance, anyway, in terms of what's going on
15:37:57 <mjrosenb> Gracenotes: i was just referring to the fact that the last two elements were includeded in the first list
15:38:55 <Gracenotes> ah, right
15:39:30 <hackagebot> shelltestrunner 0.3 - A tool for testing command-line programs. (SimonMichael)
15:40:00 <Gracenotes> groupBy (<) makes something like a series of increasing elements
15:40:39 <Gracenotes> hm.. actually not increasing.. just higher than the first one >_>
15:41:45 <mjrosenb> Igloo: what exactly should the line be? i'm not too sure how the directory name is being mangled
15:42:16 <mjrosenb> Igloo: and it looks like everything i have tried has not had -keep-hc-files
15:42:31 * mjrosenb is getting ready to just run the commands by hand
15:43:06 <Cale> groupBy (<) breaks the list into groups such that 1) the first element of each group is less than the others in that group, and 2) the sequence of lengths of the selected groups is lexicographically maximal among all those choices meeting criteria 1.
15:43:07 <Berengal> Hmm, would it be possible to write a groupBy-ish function that allowed you to group a sequence into strictly increasing or decreasing subsequences?
15:43:24 <Berengal> But still worked like group when given (==)?
15:43:28 <Cale> yes
15:43:32 <dons> ?users
15:43:32 <lambdabot> Maximum users seen in #haskell: 658, currently: 591 (89.8%), active: 18 (3.0%)
15:43:37 <Cale> I think we should have both.
15:44:03 <Cale> and that the standard should specify the behaviour of groupBy and nubBy properly for non-equivalence relations
15:44:04 <bgs100> Add another active user :)
15:44:07 <bgs100> ?users
15:44:07 <lambdabot> Maximum users seen in #haskell: 658, currently: 590 (89.7%), active: 19 (3.2%)
15:44:11 <Igloo> mjrosenb: Did you say the dist directory was just "dist"? then "utils/genprimopcode_dist_v_HC_OPTS += -keep-hc-files"
15:44:41 <Cale> The implementations provided have useful behaviour in the non-equivalence-relation case, but they explicitly state that being an equivalence relation is a precondition (needlessly)
15:45:18 <Berengal> If they needed equivalence they should include Eq in the context...
15:45:27 <Cale> huh?
15:45:36 <Cale> That's what group and nub are for
15:45:39 <Cale> :t group
15:45:41 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
15:45:43 <Cale> :t groupBy
15:45:45 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:46:22 <mjrosenb> Igloo: yeah, that did not result in -keep-hc-files
15:46:32 <Cale> groupBy and nubBy are both very useful in the non-equivalence-relation case though, so stating that it must be an equivalence is silly.
15:46:55 <Cale> and now we have stupid problems like nubBy being broken in recent GHC's.
15:47:13 <Cale> (the parameters to the function parameter are swapped)
15:47:17 <Berengal> Cale: yeah, in a way my point. They don't have an Eq context <=> they don't need an equivalence-retaion
15:47:23 <Philonous> > groupBy (<) [1,3,4,3,4,5,1,1,5]
15:47:25 <lambdabot>   [[1,3,4,3,4,5],[1],[1,5]]
15:48:26 <Cale> > groupBy (comparing length) [[1],[1,1],[1,2],[1,2,1],[1,2,2],[2],[2,1],[2,1,1],[2,1,2]]
15:48:28 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
15:48:31 <Cale> er
15:48:37 <Cale> > groupBy ((==) `on` length) [[1],[1,1],[1,2],[1,2,1],[1,2,2],[2],[2,1],[2,1,1],[2,1,2]]
15:48:38 <lambdabot>   [[[1]],[[1,1],[1,2]],[[1,2,1],[1,2,2]],[[2]],[[2,1]],[[2,1,1],[2,1,2]]]
15:48:40 <Berengal> Anyway, I just had a weird idea: Giving people the ability to plug different parsers into e.g. GHC
15:49:07 <soupdragon> Berengal doesn't sound very useful
15:49:38 <Cale> Berengal: Do you know about the quasiquoter extension?
15:49:44 <soupdragon> Berengal, what would be nice is just rewriting the current parser so its hackable
15:49:44 <Berengal> soupdragon: Allows people to completely rework haskell's syntax
15:49:51 <Cale> (it sounds like what you want)
15:49:56 <Berengal> Cale: I know of it, but haven't used it
15:50:05 <soupdragon> Berengal whats the point in that?
15:50:25 <Cale> It basically lets you apply a different arbitrary parser to the source at any given point.
15:50:51 <Berengal> It'd allow you to use haskell as a back-end for any language, provided you can build a haskell AST out of it
15:51:00 <soupdragon> Cale well it has to go between those horreble brackets
15:51:08 <Berengal> Useful for things like hsp
15:51:25 <Cale> soupdragon: Well, it has to start with the bracket, anyway
15:51:42 <Cale> soupdragon: The parser has to decide for itself where to stop.
15:52:46 <sm> hackage-server code seems to parse package descriptions as haddock, but I see one big paragraph at http://hackage.haskell.org/package/shelltestrunner .. any idea why ?
15:54:20 <mjrosenb> Igloo: hrmm, just copying the .hc and .hi files over leads to a large number of undefined references
15:54:48 <mjrosenb> Igloo: it looks like the rts was not linked in
15:55:31 <rfmge_> when I install a package from cabal with --enable-library-profiling, will it run slower even when I'm not building my own program for profiling?
16:01:59 <thoughtpolice> rfmge_: no
16:02:17 <thoughtpolice> rfmge_: when you enable profiling support, it builds 2 versions of the library: one with profiling and one without
16:02:32 <thoughtpolice> which one is linked in depends on your compile-time options (that is, if you enable profiling)
16:02:50 <rfmge_> thoughtpolice: that's what I was hoping for, thanks
16:10:48 <Philonous> Data type declarations have an uncanny resemblance to formal grammers. It's like they have been especially designed for parsing.
16:14:12 <soupdragon> yes
16:14:27 <vinicius> Philonous: ya, happy+alex is way easier than yacc+lex
16:14:37 <soupdragon> :(
16:14:52 <SamB> I don't like the syntax of datatype definitions in Haskell much
16:15:20 <SamB> Haskell 2011 will probably have a better syntax added, though
16:15:33 <soupdragon> ??
16:15:39 <SamB> who knows -- maybe someone will get it in 2010
16:15:46 <SamB> soupdragon: oh, they cancelled Haskell'
16:15:54 <soupdragon> do you have an idea?
16:15:54 <SamB> they're now just going to do yearly releases
16:16:07 <SamB> oh, the new syntax would be the GADT-style syntax
16:16:14 <SamB> restricted to ordinary algebraic datatypes
16:16:24 <soupdragon> we already have that ..?
16:16:28 <Cale> In GHC
16:16:35 <SamB> not in the STANDARD, we don't
16:16:43 <soupdragon> who cares :p
16:16:48 <SamB> I care
16:16:52 <Cale> The standard doesn't really dictate what features we have though.
16:16:56 <Cale> GHC does.
16:17:01 <SamB> I really got confused by that old one
16:17:07 <Adamant> isn't ghc the de-facto standard? :P
16:17:09 <Cale> yeah
16:17:16 <SamB> Cale: well, if the standard mandates the syntax isn't it more likely to be used in the tutorials ?
16:17:18 <soupdragon> well if it gets GADTs into EHC I'm all for it
16:17:40 <Cale> SamB: well, it would help if GADTs was turned on by default, certainly :)
16:17:53 <SamB> I'm not saying full GADTs (yet)
16:17:59 <SamB> those aren't standard-ready
16:18:08 <SamB> just the restriction of their syntax to ADTs
16:18:30 <SamB> ... oh, and someone would need to get deriving to work with that, I think
16:18:34 <Cale> I think GADTs on their own are possibly ready. The interactions with MPTCs haven't been worked out though.
16:18:49 <SamB> Cale: they don't exist on their own
16:18:54 <FunctorSal> I don't like regular types in GADT syntax... more verbose
16:19:04 <SamB> FunctorSal: they're way more n00b-friendly
16:19:15 <FunctorSal> lots of unnecessary (->) ::
16:19:15 <soupdragon> yeah it's nice having both
16:19:18 <SamB> they actually make sense
16:19:22 <FunctorSal> and repetition of the type name
16:19:26 <SamB> the current syntax does NOT make sense
16:19:30 <Cale> At least, provided that those beginners are unfamiliar with context free grammars.
16:19:44 <SamB> Cale: eh?
16:19:46 <Cale> Anyone who's seen a context free grammar will probably feel reasonably comfortable :)
16:19:52 <Cale> At least, I was. :)
16:19:55 <SamB> do CFGs have those constructor names ?
16:20:07 <Cale> They don't, but those are terminal symbols :)
16:20:12 <FunctorSal> I thought lack of line noise is what we had over java ;)
16:20:20 <zebrafinch> Cale: when I first saw data declarations I was always confused about which things were constructors and which were types, especially when the same symbol appeared as both
16:20:26 <Cale> zebrafinch: yeah
16:20:29 <SamB> zebrafinch: the same
16:21:03 <SamB> this is why I am seeking the death of the current syntax
16:21:08 <soupdragon> nooo
16:21:34 <SamB> yes!
16:21:44 <Cale> Somehow I don't remember tripping on that one myself (though there were plenty of other things which I did), but I've seen enough people get confused by that.
16:21:48 * soupdragon better not tell SamB that Coq lets you use the old syntax (sort of)
16:22:00 <Cale> I don't think the current syntax should die.
16:22:06 <Cale> But the GADT syntax should be provided.
16:22:09 <FunctorSal> I found it illogical at the beginning too, but it's not exactly rocket science ;)
16:22:19 <SamB> soupdragon: have you been reading my mind or did I actually mention Coq ?
16:22:20 <FunctorSal> and as I said, saves typing
16:22:39 <SamB> well, personally I like typing
16:22:48 <SamB> as I assume you do
16:22:48 <Cale> FunctorSal: To be fair, it doesn't save that much typing.
16:23:01 <Cale> and if we're allowed to use commas, it wouldn't be too bad
16:23:02 <SamB> or you would be using Python or Perl or ... javascript?
16:23:10 <Cale> like, for an enumeration:
16:23:15 <SamB> hmm.
16:23:22 <Cale> data Colour where Red, Green, Blue :: Colour
16:23:40 <Cale> I don't think we should have to explicitly give the kind.
16:23:51 <Cale> Can't it be inferred?
16:23:52 <SamB> well, we could borrow more from coq
16:24:05 <Cale> I should be able to write
16:24:26 <Cale> data Tree where Leaf :: Tree a; Branch :: a -> Tree a -> Tree a -> Tree a
16:24:30 <FunctorSal> SamB: got the "type" pun now o_O
16:24:38 <FunctorSal> Typeable!
16:24:42 <SamB> kinds can't usually be inferred too well
16:24:47 <Cale> what?
16:24:51 <Cale> Really?
16:25:04 <SamB> mostly on account of not being polymorphic
16:25:05 <soupdragon> Cale, you prefer that to  data Tree a where  ?
16:25:12 <Cale> soupdragon: yeah
16:25:18 <SamB> soupdragon: oh, sure
16:25:25 <Cale> soupdragon: and of course, to data Tree :: * -> * where
16:25:37 * mux added FreeBSD support to Network.Socket.SendFile
16:25:40 <SamB> we shouldn't need to give the kind if we give a where
16:25:46 <FunctorSal> granted, "Tree a" doesn't make sense if the a is meaningless as in GADTs
16:25:58 <SamB> assuming we actually use all of our type arguments in a kind-demonstrating way
16:25:59 <Cale> soupdragon: The annoying bit with explicitly mentioning the parameter there is that it's meaningless in the GADT syntax.
16:26:04 <FunctorSal> (since it can be any variables in the constrs)
16:26:14 <SamB> it makes more sense to use the stars
16:26:18 <FunctorSal> yes
16:26:26 <SamB> which should be allowed anyway
16:26:28 <soupdragon> how about
16:26:35 <SamB> hmm, was that proposed yet?
16:26:35 <soupdragon> data Leaf :: Tree a; Branch :: a -> Tree a -> Tree a -> Tree a
16:26:47 <FunctorSal> SamB: in regular syntax the variable names is meaningful, isn't it?
16:27:06 <SamB> FunctorSal: well, I meant, it should be allowed at any type binding site
16:27:35 <SamB> or possibly anywhere in type expressions
16:27:39 <Philonous> data Foo a where Foo :: a -> Foo a still suffers from the problem that Types and Constructors look alike.
16:28:03 <Cale> Philonous: but at least they are kept apart by :: now :)
16:28:04 <SamB> Philonous: but at least they are on different sides of the ::
16:28:12 <SamB> like usual
16:28:27 <soupdragon> Cale I had another idea too
16:29:14 <soupdragon> hm it's bad though
16:32:20 <CalJohn> How do you get around the inability to derive typeclasses for GADTs?  Do you just have to live with it?
16:32:33 <dolio> codata Stream a = Head :: a & Tail :: Stream a
16:32:42 <SamB> CalJohn: hoping to get it fixed
16:33:02 <SamB> at least when it's not even a GADT
16:33:16 <CalJohn> SamB: any kind of timescale for that?
16:33:33 <SamB> not really
16:33:50 <Berengal> Isn't there any TH magic for doing it?
16:33:52 <SamB> it's likely to happen a lot sooner than we get a record system
16:33:57 <SamB> Berengal: oh, sure
16:34:16 <SamB> but that's not exactly something that's going to go into Haskell 201x ;-)
16:34:17 <soupdragon> Head (repeat x) = x
16:34:30 <soupdragon> Tail (repeat x) = repeat x
16:34:35 <Berengal> SamB: True
16:34:58 <SamB> huh? codata?
16:35:04 <CalJohn> Yeah, interesting that they are putting next to nothing in Haskell'
16:35:17 <SamB> they basically cancelled Haskell'
16:35:22 <SamB> it was taking too long
16:35:42 <SamB> or maybe I should say they decided to put it on the back burner
16:35:57 <monochrom> I want a multiset!
16:36:01 <SamB> I think that's the "Haskell 2" that was mentioned
16:36:23 <Berengal> Haskell 2 better be awesome...
16:36:24 <SamB> monochrom: oh, like a Data.Bag or something?
16:36:47 <monochrom> Yes
16:36:47 <tavelram> wtf, they cancelled haskell'?
16:36:49 <SamB> Berengal: oh, they wouldn't call it Haskell 2 if it weren't likely that it would be
16:37:19 <Berengal> SamB: I don't know, if I knew it was going to be awesome I'd name it Haskelltron 2000
16:37:23 <dmhouse> monochrom, SamB: email/wiki references?
16:38:10 <CalJohn> dmhouse: http://www.haskell.org/pipermail/haskell-prime/2009-July/002812.html
16:39:28 <SamB> dmhouse: http://thread.gmane.org/gmane.comp.lang.haskell.prime/2818
16:41:23 * monochrom imagines ways of hijacking Data.Set and Data.Map for bag purposes.
16:43:35 <Cale> Map a Integer is not bad
16:45:11 <MyCatVer1s> Map k [a] seems like the obvious solution if a happens to include extra fields that aren't considered in its Eq instance. 'Course it's prolly not a real good idea to define structures that act that way anyway, but what the heck.
16:46:36 <dmhouse> What's a bag? A set with quick `elem'?
16:46:54 <MyCatVer1s> dmhouse: IIRC in mathematics, a multi-set.
16:46:57 <Cale> dmhouse: A multiset
16:47:27 <Twey> A set without uniqueness
16:48:07 <Berengal> So in general, an unordered collection of arbitrary objects?
16:48:14 <Cale> Berengal: yeah
16:49:32 <Berengal> A multiset would be useful indeed...
16:50:28 <Cale> The easiest way I know of to implement polynomials in arbitrarily many indeterminates is to implement an arbitrary monoid ring, and then plug in multisets under union as the monoid :)
16:51:03 <ehird> Hey, who runs \bot these days? Cale? gwern? SPJ?
16:51:16 <Cale> ehird: I run it on lispy's machine.
16:51:29 <ehird> Calispy: \bot is killing threads for trivial stuff
16:51:31 <ehird> :t ap id
16:51:33 <Cale> SPJ doesn't use IRC, as far as I know
16:51:36 <Berengal> Cale: Such a comment has only two responses: 1) Wha?! 2) That's simple
16:51:38 <ehird> SPJ was a joke :-)
16:51:39 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
16:51:46 <ehird> Well, OK, it's just very slow.
16:51:57 <dmhouse> Berengal: everything is trivial once learnt.
16:52:02 <Cale> ehird: I can't help it if there are other things running on lispy's box :)
16:52:10 <ehird> I think it's unusually slow for that
16:52:13 <Berengal> dmhouse: True in mathematics, not everywhere else
16:52:15 <MyCatVer1s> ehird: there's a reason people call the language that \bot implements "Caleskell". ;)
16:52:17 <ehird> We _were_ bombarding it with complicated requests... :-)
16:52:21 <ehird> MyCatVer1s: used to.
16:52:22 <Cale> huh?
16:52:29 <ehird> i asked nowadays; and it's very usual nowadays afaik
16:52:30 <Cale> :t ap id
16:52:35 <Cale> :t (*)
16:52:35 <ehird> Cale: not that one
16:52:40 <ehird> just a few seconds ago it timed out on everything
16:52:40 <MyCatVer1s> > (+1) . [1,2,3]
16:52:45 <ehird> after we tried :t on some complex exprs
16:52:46 <lambdabot> thread killed
16:52:50 <ehird> see?
16:52:51 <lambdabot> thread killed
16:52:59 <Cale> I'll see if I can work out what's running
16:53:00 <ehird> i think it was coincidence tho
16:53:20 <Cale> If there are some runaway muevals, I'll kill them.
16:53:37 <Cale> There's a script which periodically cleans them up, but no need to wait for it
16:53:38 * Twey read that as a threat
16:54:04 <Berengal> Twey is a runaway mueval?
16:54:11 <Twey> Heh
16:54:32 <Cale> huh, there were about 5 or 6 ghc processes
16:54:39 <Cale> :t ap id
16:54:41 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
16:54:44 <Cale> :t (.)
16:54:46 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:54:47 <MyCatVer1s> > (+1) . [1,2,3]
16:54:51 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
16:55:00 <Cale> MyCatVer1s: That went away a long long time ago
16:55:03 <MyCatVer1s> Damn, (.) != fmap.
16:55:13 <Gracenotes> I like <$>
16:55:19 <Cale> MyCatVer1s: The GHC API sucks at importing modules qualified.
16:55:20 <Berengal> I like <$
16:55:28 <Twey> Berengal: There's a Data.MultiSet on Hackage.
16:55:39 <MyCatVerbs> Cale: ohhhhh. :/
16:55:41 <Cale> er, no
16:55:44 <Berengal> Twey: Nifty
16:55:49 <Cale> It's hiding that it doesn't support well
16:56:01 <Gracenotes> <$ .. it's not a bouquet of flowers, it's the functor version of const!
16:56:34 <Berengal> Gracenotes: And very useful when parsing. "AddOp <$ char '+'"
16:57:27 <Gracenotes> although I suppose (<*) is a better const than (<$) is, except functors are not otherwise so effectful..
16:57:31 <Twey> Someone suggested a definition of void = (() <$)
16:57:47 <meanburrito920_> what is the best library for working with http posts and gets?
16:57:57 <hzap> :t (() <$)
16:57:58 <Cale> Twey: I think functions like that are only desirable because of other API flaws.
16:57:59 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
16:58:07 <Cale> :t when
16:58:09 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:58:16 <Cale> :t Control.Concurrent.forkIO
16:58:18 <Twey> Cale: Such as?
16:58:18 <Gracenotes> eh, I'd prefer void = return ()
16:58:18 <lambdabot> IO () -> IO GHC.Conc.ThreadId
16:58:23 <Cale> Such as those two
16:58:41 <Twey> You'd argue that they should be -> m a?
16:58:43 <Cale> when :: (Monad m) => Bool -> m a -> m ()  would be better
16:58:52 <Twey> Couldn't it be m a -> m a?
16:58:52 <Baughn> meanburrito920_: Working with them.. in what way?
16:58:54 <Cale> no
16:59:03 <Cale> but it could be   Bool -> m a -> m (Maybe a)
16:59:10 <Twey> Ah, true
16:59:20 <Gracenotes> .half-eek.
16:59:25 <Twey> Gracenotes: No, that's not the point of it
16:59:27 <meanburrito920_> Baughn: as in using them in general.
16:59:40 <Gracenotes> Twey: choose a different name for it! I claim void! >:D
16:59:46 * Twey laughs.
16:59:49 <Baughn> meanburrito920_: Insufficient information. Are you after a client or a server?
16:59:50 <meanburrito920_> Baughn: such as, returning google results from a get, or whatever
16:59:55 <meanburrito920_> client
17:00:09 <Cale> When functions don't care about the type of part of their parameter, they should use a type variable.
17:00:12 <Baughn> meanburrito920_: Ah. Well, the http package's pretty much the de-facto standard.
17:00:15 <meanburrito920_> I saw some server stuff in hackage, but thats not really what i nead
17:00:30 <meanburrito920_> Baughn: is that in the standard lib?
17:00:45 <Baughn> meanburrito920_: It's in the haskell platform standard, if that's what you mean
17:01:01 <MyCatVerbs> meanburrito920_: for the sake of your sanity, I would strongly advise getting the curl bindings off Hackage.
17:01:19 <meanburrito920_> Baughn: I'm looking here: http://www.haskell.org/ghc/dist/current/docs/libraries/ and I dont see a http package
17:01:24 <MyCatVerbs> IMO they're rather more pleasant to work with than Network.HTTP.
17:01:51 <Baughn> meanburrito920_: That's just the GHC libraries, not the full platform
17:02:05 <MyCatVerbs> meanburrito920_: Network.HTTP. It's definitely bundled with every version of GHC later than 6.8, and I think even earlier than that, too.
17:02:06 <Baughn> meanburrito920_: http://hackage.haskell.org/platform/
17:02:29 <meanburrito920_> Baughn: I installed ghc from the debian repos. will that include the full platform packages?
17:02:37 <Baughn> meanburrito920_: No, debian is hopelessly behind.
17:02:51 <Baughn> meanburrito920_: Have they gotten to ghc 6.10 yet?
17:02:57 <meanburrito920_> Baughn: nope
17:02:58 <Berengal> Baughn: They will in Karmic
17:03:00 <meanburrito920_> 6.8
17:03:02 <meanburrito920_> :)
17:03:06 <Berengal> But by then 6.12 is out :/
17:03:11 <Baughn> Berengal: But by then we'll be.. right
17:03:29 * Berengal prefers rolling releases
17:04:18 <Berengal> meanburrito920_: I strongly suggest you get the haskell platform source and install that
17:04:27 <meanburrito920_> if only they kept the debs up to date... apt-get is so nice...
17:04:33 <meanburrito920_> Berengal: ok, I'll do that.
17:05:23 <Berengal> meanburrito920_: you might have to remove the deb versions of ghc to prevent conflicts (but you need it to build the platform)
17:05:34 <MyCatVerbs> meanburrito920_: oh, Ubuntu and AFAIK Debian like to be a pain in the arse by breaking GHC up into a billion different packages.
17:06:23 <Berengal> MyCatVerbs: Presumably because they've got the end-users in mind, not the developers
17:06:28 <meanburrito920_> MyCatVerbs: I've noticed that much :)
17:06:52 <meanburrito920_> does the haskell platform include ghc?
17:06:54 <MyCatVerbs> Berengal: generally I've had the same attitude myself (w00t for Arch), until I started using my machine for work, and suddenly can't upgrade it without imaging the disk or something first because Arch don't really guarantee to not break anything on any given afternoon.
17:07:11 <meanburrito920_> should i install the latest release of ghc first?
17:07:25 <Berengal> meanburrito920_: The platform comes with ghc
17:07:39 <meanburrito920_> Berengal: but depends on ghc...
17:07:58 <meanburrito920_> so i should make it locally, and then remove ghc, then make install?
17:08:01 <mike-burns> Note: the source tarball requires that you already have ghc-6.10.3 (or 6.10.4) installed.
17:08:08 <meanburrito920_> I have 6.8
17:08:12 <meanburrito920_> thats why i was asking
17:08:15 <aavogt> 6.10.4?
17:08:17 <Berengal> MyCatVerbs: Then don't use it for work :P Or dual boot... Although yes, I've had a couple bad afternoons trying to fix stuff myself, but the overall experience was better than with ubuntu
17:08:27 <MyCatVerbs> Berengal: maybe, but it seems a little silly. The libraries don't weigh in at all that much anyway, and they don't do the same thing to for example Python.
17:08:42 <Berengal> mike-burns: It does? I thought 6.8 was good enough
17:08:54 <mike-burns> Berengal: I'm just quoting the Web page.
17:09:10 <Berengal> MyCatVerbs: I know, but 1 MB is like a MILLION bytes!
17:09:11 <mike-burns> I've been trying to build it on FreeBSD for like four weeks now, so I don't know what's actually required.
17:09:14 <MyCatVerbs> Berengal: dual-boot seems like the most sensible option. It's a teensy bit late to set that up now, though.
17:10:01 * MyCatVerbs blinks.
17:10:14 <MyCatVerbs> I've build ghc from source on OpenBSD a couple times, it was never all that hard.
17:10:44 <Berengal> MyCatVerbs: I've been running ubuntu the last few months. It started out as an experiment, but I got stuck with it when my laptop stopped working. I'm not installing arch without a working internet connection
17:10:58 <mike-burns> I got ghc going yesterday (6.10.2, not .3 because of some AMD64/mmap-related bug), but now I'm fighting editline with Platform.
17:10:58 <pragma_> His cat verbs blinks.
17:11:11 <meanburrito920_> ouch. ghc is way larger than the haskell platform...
17:11:20 <MyCatVerbs> Berengal: oh Hells no, Arch without a fast internet connection would be Hellish.
17:11:25 <pikhq> Gentoo makes ghc rather nice, too. Granted, it takes a while to build, but hey: no effort needed.
17:11:36 <Berengal> mike-burns: editline and readline are binary-compatible, no? Can't you just replace the .so?
17:11:45 <Berengal> MyCatVerbs: I was thinking more about the wiki...
17:11:46 <mike-burns> Berengal: It's looking in the wrong path.
17:12:17 <MyCatVerbs> Berengal: I was thinking pacman and all the software that one invariably forgets to plunk down in the first place.
17:13:39 <Berengal> MyCatVerbs: That too. Also, I have no idea how I got yaourt working in the first place, and dread installing it a second time.
17:13:47 * Berengal has no idea how the ABS thingamabob works
17:13:59 <Berengal> Arch has a sexy logo though...
17:14:36 <meanburrito920_> what kind of development is being done to ghc? version numbers increasing like that suprises me, seeing as how they are just writing to thet 98 standard, correct?
17:14:48 <Baughn> meanburrito920_: Very, very incorrect
17:14:49 <Cale> meanburrito920_: That can't be possible... GHC is included in the Haskell Platform...
17:15:05 <Cale> meanburrito920_: GHC is *way* beyond Haskell98
17:15:12 <badsheepy> recursive singularity
17:15:21 <Cale> Haskell98 was less than what was implemented at the time that it was standardised.
17:15:22 <Berengal> meanburrito920_: GHC isn't a reference implementation. It's a petri dish of extensions
17:16:14 <Cale> meanburrito920_: The general way that things are done is that implementations go ahead and implement new things, and the things which work end up in a standard at some point hopefully. :)
17:17:14 <mike-burns> When I gmake Haskell Platform, once it gets to the editline package it gives me this error
17:17:15 <mike-burns> Readline.hsc:42:31: error: editline/readline.h: No such file or directory
17:17:28 <mike-burns> The file is in /usr/local/include/editline/readline.h . How do I tell it where that file is?
17:17:30 <Cale> It's been a while since Haskell was last standardised, so Haskell 98 is almost in a position of irrelevancy.
17:17:33 * EvilTerran was thinking, with -XFlexibleContexts, is there still need for MonadPlus/Alternative?
17:17:48 <osaunders> Are they working to standardise it again?
17:17:54 <osaunders> Or update the standards, I should say
17:17:55 <mike-burns> I configured with:  LDFLAGS="-L/usr/local/lib" CPPFLAGS="-I/usr/local/include" EDITLINE_LDFLAGS=-Wl,-rpath,/usr/local/lib ./configure --enable-unsupported-ghc-version
17:17:58 <Cale> osaunders: yeah
17:18:02 <EvilTerran> couldn't we just use (Monad m, Monoid (m a)) => ... instead of MonadPlus m => ... ?
17:18:04 <thoughtpolice> osaunders: yeah, recently
17:18:18 <thoughtpolice> osaunders: they hope to have a new revision out by 2010
17:18:28 <osaunders> But there aren't any problems associated with the lack of standard ATM right?
17:18:40 <osaunders> thoughtpolice: 2010,OK
17:19:00 <Baughn> EvilTerran: We could, I suppose. Is the MonadPlus instance always equal to the Monoid instance?
17:19:17 <thoughtpolice> i think I kind of agree with Psuedonym though - haskell' etc seemed to be started as a short-term fix and cleanup to haskell98. haskell' has been an initiative for like 3 years now, and there's so much code written in haskell now, it's unlikely a lot of fundamental things can change any further, even if for the better
17:19:43 <pikhq> osaunders: Languages go without a standard without too much harm quite often.
17:19:50 <EvilTerran> Baughn, I guess not always, such as Maybe
17:19:53 <osaunders> thoughtpolice: argh I hate that. Backwards compatability is bad news for progress.
17:20:02 <EvilTerran> Baughn, which is left-biased in MonadPlus, and Monoid a => Monoid Maybe a
17:20:07 <pikhq> Standards for a language are a nice thing to have, not some essential feature. (in general)
17:20:09 <osaunders> pikhq: Yeah I guess that's true.
17:20:22 <aavogt> > Just 1 `mplus` Just 2
17:20:24 <lambdabot>   Just 1
17:20:26 <osaunders> pikhq: As long as there's de facto reference implementations.
17:20:30 <aavogt> > Just 1 `mappend` Just 2
17:20:30 <Baughn> > ((+) <*> (*2)) 3
17:20:32 <lambdabot>   9
17:20:32 <lambdabot>   Add a type signature
17:20:34 <pikhq> osaunders: Well, of course.
17:20:47 <Berengal> Standards are nice make a common base, but it doesn't mean we shouldn't develop extensions
17:20:52 <Berengal> to make*
17:20:55 <osaunders> pikhq: I felt it was important to be said :-)
17:21:00 <EvilTerran> > [[1,2,3] <+> [4,5,6] | (<+>) <- [mplus, mappend]]
17:21:01 <lambdabot>   [[1,2,3,4,5,6],[1,2,3,4,5,6]]
17:21:06 <aavogt> > Just 1 `mappend` Just 2 :: Maybe Int
17:21:07 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
17:21:07 <lambdabot>    arising from a use of...
17:21:08 <Cale> thoughtpolice: I'm more optimistic about the possibility of change. I think the fact that packages are require to specify their base package version is a good start.
17:21:15 <Cale> required*
17:21:18 <EvilTerran> > [Just [1,2,3] <+> Just [4,5,6] | (<+>) <- [mplus, mappend]] -- er
17:21:20 <lambdabot>   [Just [1,2,3],Just [1,2,3,4,5,6]]
17:21:37 * Berengal wonders what Java would look like today if it had the same number of extensions h98 has
17:21:44 <thoughtpolice> Cale: I'm not sure where I stand on the whole thing, honestly
17:21:59 <Baughn> Berengal: ..I don't want to imagine it
17:22:13 <Baughn> Berengal: We can at least say this much, our extensions /fit/ better
17:22:24 <Axman6> @hoogle printf
17:22:25 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
17:22:25 <lambdabot> module Text.Printf
17:22:25 <lambdabot> package printf-mauke
17:22:28 <Cale> thoughtpolice: My hope is that we can have standards-conforming base packages (like the haskell98 package), and then have the default base be a bit more adventurous and flexible, to go along with the overall community spirit of welcoming language changes.
17:22:52 * pikhq notes that printf is... Crazy.
17:22:52 <thoughtpolice> Cale: personally though, I pretty much just look at 'GHC' as the current 'standard', even if I don't really want to - the extensions are too numerous and too helpful. i haven't really been keeping up with haskell' or the standardization process, because all the work seems to go towards GHC
17:23:07 * Baughn still has hope that someone'll propose making monad a subclass of applicative.. well, rather that we'd /do/ it
17:23:24 <Berengal> Baughn: Still, it seems a little strange to me. Java has way more popularity than Haskell, yet haskell has way more language development
17:23:28 * pikhq too, Baughn.
17:23:40 <Cale> thoughtpolice: This way, people who want to write books with example code which doesn't go out of date, or programs which are not going to be actively maintained can use the standard packages which won't change, and people who use Haskell on a more everyday basis can take advantage of new features and cleaner libraries.
17:23:54 <pikhq> Berengal: I'd say that Haskellers seem to have more experience with language development on average.
17:23:55 <osaunders> What parts of GHC are extensions anyway? (I'm a newbie)
17:24:09 <Cale> Language development is inversely proportional to popularity, normally.
17:24:11 <Berengal> pikhq: On average, but in total?
17:24:16 <thoughtpolice> Cale: so something like a 'base-haskell98' and a 'base-future-haskell' you can change between with e.g. a compile time option?
17:24:23 <thoughtpolice> Cale: truth :)
17:24:25 <Cale> thoughtpolice: Yes.
17:24:25 <Baughn> osaunders: Basically.. any language feature you have to turn on, or any package with a dot in its name. Those are all extensions.
17:24:26 <thoughtpolice> osaunders: tons of them
17:24:29 <Berengal> Cale: That seems like a bad way of doing things...
17:24:34 <Baughn> osaunders: s/package/module/
17:24:36 <Cale> Berengal: What does?
17:24:44 <Cale> Berengal: Using different versions of base?
17:24:53 <thoughtpolice> osaunders: some of them are not in haskell98, but are so tremendously useful you may wonder how people functioned without them :)
17:25:01 <Cale> I suppose you have to ask "what is the standard for?"
17:25:05 <Berengal> Cale: No, the inversely proportional relationship between language development and popularity
17:25:14 <Cale> Berengal: It's only natural.
17:25:25 <Berengal> Cale: Yes, but it's still a bad thing...
17:25:27 <Baughn> thoughtpolice: Oh, and ghc-10 already has base-3 and base-4 to switch between - remember>
17:25:30 <thoughtpolice> osaunders: if you have a ghc <= 6.8, I suggest you run 'ghc --supported-languages' and it will output the list of all possible extensions you can enable :)
17:25:43 <Cale> Berengal: The more users you have, the more users there are who have written code that they don't want to fix when you change things.
17:25:55 <Berengal> It means the most popular languages will also be the worst languages
17:25:58 <thoughtpolice> Baughn: yes, that did cause a bit of issue initially
17:25:58 <Cale> Yep
17:26:08 <osaunders> thoughtpolice: Wow, that's quite a list.
17:26:08 <Cale> That's why I want us to keep Haskell secret :)
17:26:13 <Baughn> thoughtpolice: Right, but now we've pretty much figured it out, and so base-5 could be even more revolutionary
17:26:15 <monochrom> Argh! I have an unintended ty-knot in my code! It's a bug!
17:26:28 <deech> Are 'if' statements supported in do notation?
17:26:31 <Cale> Be helpful to the people that come here, of course, but don't advertise :)
17:26:40 <meanburrito920_> the haskell platform is complaining it needs the OpenGL C libraries to compile. does anyone know what debian packages these libraries are in?
17:26:45 <Cale> deech: if expressions are supported, just like any other expressions
17:26:45 <Berengal> Cale: I'm afraid I've been advertizing :(
17:26:49 <osaunders> Cale: Haskell's difficulty helps
17:26:57 <Baughn> meanburrito920_: mesa-dev or so
17:27:21 <monochrom> Argh! I hate simulating bags by other things.
17:27:47 <Philonous> I don't think haskell is that difficult. C is difficult. C++ even more so. But haskell is actually quite straight forward.
17:27:53 <Cale> osaunders: Yeah, it's relatively different from other languages, not just a skin over some language they already know, so the users tend to be the people dedicated to trying something new, which is good.
17:28:02 <Berengal> monochrom: Someone told me: http://hackage.haskell.org/package/multiset
17:28:03 <deech> I've haven't been able to get it right like this code that fails to parse: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6867#a6867
17:28:12 <pikhq> Philonous: You must be a mathematician.
17:28:16 <osaunders> Right, not difficult, alien.
17:28:24 <Baughn> Philonous: You can say that because you understand it, but there's really no question that the learning cliff is steeper for haskell
17:28:26 <osaunders> Wait, alien is difficult
17:28:42 <Berengal> osaunders: Alien is difficult to get started with, not difficult in general
17:28:50 <Berengal> It's like a gatekeeper
17:28:54 <pikhq> Baughn: Cliff is the right term, yes.
17:29:01 <Cale> osaunders: Right, but it's no more difficult than your first programming language was, provided that you can forget what you already know about programming :)
17:29:02 <Berengal> Anyway, i find haskell to be easier than Java...
17:29:08 <osaunders> Berengal: I think it's a bit more blurry than that.
17:29:17 <pikhq> Berengal: Easier once you grok it, sure.
17:29:22 <pikhq> Berengal: It's the grokking that's hard.
17:29:36 <Cale> osaunders: Learning Haskell as a first programming language is in some ways easier than learning it after knowing lots of imperative and OO languages
17:29:49 <osaunders> I'm enjoying the experience of forgetting everything I know about programming :-) Sorta.
17:29:51 <meanburrito920_> Baughn: no such luck :(
17:30:01 <osaunders> Learning OO is super difficult.
17:30:12 <coCocoa> Learning Haskell is easier to me, because you expect the language to work differently right off the bat. Thus, there are fewer times when you're rudely surprised that it does/does not do something "differently". :)
17:30:13 <Cale> osaunders: Don't worry, the knowledge will still come in useful once you have a good foundation.
17:30:13 <osaunders> Considering how it appears much easier than it actually is.
17:30:15 <mike-burns> I just learned Haskell about a month ago. Wasn't that hard, really. I don't know it very well, but it wasn't some major struggle to write a GUI app with a DB backend.
17:30:18 <Axman6> OO's not hard if you're taught well
17:30:42 <Cale> mike-burns: Yeah, it's also easier if you just don't sweat about things and dive in, perhaps.
17:30:46 <osaunders> Axman6: True of anything
17:30:56 <Baughn> meanburrito920_: http://www.debian.org/distrib/packages#search_contents has it as being mesa-common-dev /or/ nvidia-glx-dev
17:31:12 <Cale> mike-burns: Trying to understand some of the details can be hard if you worry too much before just using them for a bit :)
17:31:16 <Baughn> meanburrito920_: However, you also need libglu1-mesa-dev
17:31:31 <Baughn> meanburrito920_: ..and freeglut3-dev
17:31:46 <osaunders> Axman6: I read your tutorial BTW. I grok it. TY
17:31:50 <Baughn> Good work splitting it, debian
17:31:55 <Axman6> oh good :)
17:31:58 <Cale> I think one of the reasons that OO is hard is that people are taught to use it for things where it's inappropriate.
17:32:10 <mike-burns> Cale: Totally. Like, as we discussed last night, how people get all worked up over monads instead of just using them.
17:32:24 <deech> One of my biggest learning difficulties with Haskell was the inability to know where you are in the execution at any given time. OO was difficult but at least you could do a System.Out.Println.
17:32:27 <osaunders> Cale: Where would you say it's inappropriate?
17:32:35 <Baughn> Indeed. The hardest thing for me to understand about monads was what they weren't that interesting.
17:32:46 <meanburrito920_> Baughn: awesome, that last one did it
17:32:49 * Baughn happily hugs the typeclassopedia
17:32:57 <aavogt> @quote trace
17:32:58 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
17:33:15 <Baughn> meanburrito920_: Well, it's three separate parts of opengl.. debian sure enjoys splitting things up.
17:33:33 <aavogt> deech: you can trace evaluation though
17:33:39 <deech> aavogt, yeah I know that now, but none of the tutorials, and indeed RWH bring it up early.
17:34:11 <Cale> osaunders: Well, it's easier to say where it *is* appropriate. It's appropriate when the ability to extend the types of values you're discussing is more important than being able to extend the set of operations on those data.
17:34:12 <pikhq> Baughn: It's 2 completely different libraries. In 3 packages. Distributed at random.
17:34:18 <pikhq> Baughn: They sure like making me wonder.
17:34:18 * bremner slits Baughn into libBaugh-helpful-dev libBaugh-snarky-dev and libBaugh-common
17:34:29 <bremner> err splits
17:34:46 <Baughn> pikhq: Sure. Two libraries. Developed by one group. Divided into three packages.
17:34:51 <Cale> osaunders: More specifically, it's really good at physical simulations of actual objects.
17:34:56 <pikhq> Baughn: Yup.
17:35:15 <pikhq> I'm not sure how that's even vaguely a good idea.
17:35:21 <Baughn> pikhq: I can see the reason for splitting them, really, but there ought to be an opengl-dev depending on all three
17:35:23 <pikhq> s/three/six/
17:35:34 <pikhq> There's also the binary packages. :P
17:35:41 <osaunders> Cale: If you're talking about OO in relation to FP I probably can't really comment because I'm not yet familiar with FP abstractions. But I always thought that OO what suited to everything. If learning FP challenges that (which I suspect it will) I'll be very happy.
17:35:46 <Philonous> I think learning haskell only seems so hard because you are forced to programm in a structured fashion right from the beginning, whereas in C or java you can get quite far by messing around with spaghetti code. I've found that doing things right in C is much harder, because it just doesn't have the powerful concepts that make haskell harder to learn.
17:35:53 <Cale> osaunders: But it's a technique which should really be advised about with caution, because typical OO practice is also capable of producing programs which are overcomplicated to understand and easy to get wrong.
17:36:10 <Baughn> pikhq: Because libGL is typically implemented by the GPU vendor, libGLU is a common utility library that pretty much works on all implementations, and libGLUT is typically developed by the windowing system vendor
17:36:13 <Cale> osaunders: Specifically the use of objects which maintain state.
17:36:37 <Baughn> pikhq: But that's not a very interesting division for a /developer/
17:36:49 <pikhq> Baughn: Right.
17:37:01 <meanburrito920_> building the haskell platform is throwing me an error: configure: error: editline not found, so this package cannot be built
17:37:02 <Cale> osaunders: State which mutates over time is something which you want to minimise in any system. Sometimes changes in state are important to model or deal with, but for most computations, they're the wrong thing.
17:37:17 <meanburrito920_> does anyone know if what could cause this?
17:37:28 <pikhq> meanburrito920_: No editline-dev?
17:37:43 <osaunders> Cale: You could argue that over-complication is due to the inadequacy of OO programming mechanisms. I suspect that if more OO languages had multiple dispatch and dispatch methods people would complain about OO sucking I whole lot less.
17:38:14 <meanburrito920_> pikhq: would that be a seperate build dependency? because configure didn't warn me about it...
17:38:40 <Cale> Does the Haskell platform really rely on editline? I thought we were finally rid of that crap.
17:38:41 <Philonous> osaunders: OO and fp don't exclude each other, as ocaml shows quite impressivly
17:38:42 <pikhq> meanburrito920_: Uh... Possibly?
17:38:47 <osaunders> Cale: But I do agree. I learnt PHP first, decided it sucked moved on to Ruby, found out that sucked less but still sucked. So here I am! I'm going to try Clojure next though.
17:38:47 * pikhq scratches his head
17:38:57 <mike-burns> osaunders, Cale: I do OO by day and FP at night, and I agree slightly more with osaunders here than Cale; in theory, OO is only good at some things and FP is only good at some things, but in practice the important part is whether the libraries and community are there---you can do anything in any language, rally.
17:39:05 <badsheepy> i always thought that design patterns book was a bit damning of oo programming: heres how you do this, but you cant abstract it any more in your language of choice, so you just have to make a new one each time
17:39:14 <Baughn> Cale: It does. It should use haskeline, but.. meh.
17:39:22 <Cale> mike-burns: Well, that is true as well.
17:39:43 <Cale> mike-burns: But I think that a lot of people end up writing OO programs which are much harder to maintain than they should be.
17:40:07 <Cale> badsheepy: Design patterns are indeed a sign of language deficiency.
17:40:13 <mike-burns> Cale: I bet that's true of imperative, declarative, and FP programs, too. There are a ton of terrible coders out there.
17:40:23 <Cale> If it's a pattern, you should be able to turn it into a library.
17:40:31 <Cale> If you can't, your language is not good enough.
17:40:45 <Berengal> "Design patterns" design patterns are anti-patterns. Some patterns are good
17:40:59 <Berengal> Like monads
17:41:04 <mike-burns> badsheepy: Compare, for example, the C++ Design Patterns (the original) to the Smalltalk-specific one. The ST one is smaller and typically relies on built-in libraries.
17:41:11 <Cale> Berengal: But monads are just a library. Control.Monad :)
17:41:13 <deech> cale, aren't design patterns in a broader sense the same as idioms? Haskell has idioms too.
17:41:21 <Cale> Berengal: (plus some language support :)
17:41:23 <Berengal> Cale: Yes, I know. It's awesome
17:41:24 <osaunders> pikhq and others: OO's problem is that abstraction mechanism aren't rich enough. Most people haven't heard of dispatch methods, I think that's a big problem because they allow you to do the really generic stuff and make complex compositions workable.
17:41:30 <mike-burns> Monads are totally a design pattern.
17:41:33 <Berengal> Cale: The language support is just sugar anyway...
17:41:46 <Axman6> hmm, anyone know about using Sockets in haskell? i'm not familliar with them, and what i thought i understood about them seems to be wrong. i've used listenOn to make a socket that listons on port 8080, and i can telnet to localhost:8080, but i can't seem to recv on the socket, because it thinks it's not connected (not sure what thet means)
17:41:53 <Cale> deech: The thing is, if you have to call them a design pattern rather than the name of some structure in your language, that's where things have gone wrong.
17:41:57 <pikhq> osaunders: Totally.
17:42:37 <osaunders> This is what I've come to believe anyway haven't thought about this a lot.
17:42:37 <pikhq> osaunders: If something makes things harder, it deserves abstraction. :P
17:42:42 <Cale> In Haskell, the concept of a monad is just reduced to a typeclass, and a library of operations.
17:42:45 <Baughn> Axman6: You need to accept on it. Any number of clients can connect to a listening socket, you know,
17:42:52 <osaunders> *having thought about this a lot
17:42:54 <Berengal> Axman6: hGetLine on the handle accept returns
17:42:58 <meanburrito920_> I wish it was more obvious what libraries associate with which debian packages...
17:43:02 <coCocoa> deech: I'm curious - what's your defn of "idiom"? :)
17:43:05 * osaunders hates when he says the exact opposite of what he means
17:43:08 <Axman6> ah, i see
17:43:23 <Baughn> Axman6: Also, I recommend the network-bytestring package
17:43:40 <pikhq> meanburrito920_: Well they couldn't make it easy, now could they?
17:43:51 <Axman6> Baughn: yeah, that's what i'm trying to use
17:44:09 <Axman6> must find out what accept is...
17:44:35 <Berengal> @type accept
17:44:36 <Cale> osaunders: One of OO's problems is that it tries to abstract away state in order to make it more manageable, but ultimately fails to eliminate it, and you're forced to reason about the way in which things are changing step-by-step. Getting things out of order produces bugs.
17:44:37 <lambdabot> Not in scope: `accept'
17:44:41 <Berengal> @hoogle accept
17:44:42 <lambdabot> No results found
17:44:45 <Berengal> :/
17:44:59 <Baughn> Axman6: You should know this already, but a TCP connection is globally (as in, across the internet) identified by a server-{ip,port} and client-{ip,port} quad. Though of course there's no concept of server or client in the protocol beyond initial setup.
17:45:11 <Cale> osaunders: But this isn't really an essential problem, and it's possible to do something which looks very much like OO in a pure way.
17:45:24 <Baughn> Axman6: Therefore, any number of client programs can connect to the same server port; they get different IPs or, if on the same machine, different ports
17:45:25 <FunctorSal> btw the "m a -> m ()" discussed on -cafe should be called "perform" obviously ;)
17:45:26 <mike-burns> Cale: You can write OO code in a very functional style, and I often do. This is more of a language issue than an OO issue.
17:45:40 <Baughn> Axman6: Therefore you need to pick out a particular client before you can get a handle
17:45:44 <meanburrito920_> pikhq: no, they certainly couldn't. fortunately, through trial and error (and installing half the dev libraries in the repos :) I managed to get it to install properly)
17:45:45 <osaunders> Cale: I agree with mike-burns. You're confusing OO with imperative.
17:45:48 <Axman6> Baughn: yeah, that much i do know, but i've never worked with sockets, so i didn't know how they related to all that :)
17:45:51 <Axman6> thanks heaps
17:46:00 <Baughn> Axman6: UDP, of course, does not work this way.
17:46:06 <Berengal> Cale: Very much agreed. Encapsulation is impossible in OO, or at least very painfull. If something has state, you can't really encapsulate it entirely. If you can, it's just a bunch of pure function and would probably be much easier to write as such
17:46:12 <osaunders> Cale: But yes, what you mentioned is absolutely a problem.
17:46:13 <Cale> osaunders: well, the main idea that OO puts forward is that objects respond to messages by updating their internal state
17:46:18 <Axman6> so accept produces a handle foe each conectiong made?
17:46:22 <Axman6> for*
17:46:25 <Baughn> Yes
17:46:35 <Cale> osaunders: So, to the extent that that is true, it's a problem.
17:46:41 <Axman6> ah ha, how handeh
17:47:00 <Baughn> Axman6: Oh, and I recommend you read some book on basic unix concepts.. The art of unix programming, say.
17:47:05 <pikhq> Cale: So, what you're saying is that OO tried to do monads, and fell far short? :P
17:47:16 <Cale> well, not monads exactly
17:47:24 <Axman6> i have a feeling i'll be learning about sockets and such this semester actually
17:47:31 <pikhq> Similar sort of abstracting away state, though.
17:47:37 <Baughn> The "encapsulated state" bit is covered in.. functors. Monads are two levels down from that. :P
17:47:38 <osaunders> Berengal: I think the crucial tenant of encapsulation is not data hiding. It's packaging things up in a bunch and giving it a certain responsibility.
17:47:50 <Cale> You could have objects which respond to messages with new versions of themselves, and that would fix this problem.
17:48:01 <pikhq> Baughn: Oh, you know what I mean.
17:48:25 <Baughn> pikhq: Perhaps. There's sufficient misunderstandings around about monads that you never quite know.
17:48:30 <Cale> Monads don't really abstract away state, but some monads let you describe operations on it.
17:48:38 <Berengal> osaunders: It's far too common that you can't really place the responsibility with one particular class though.
17:48:38 <Baughn> And making the basic monad function >>= instead of join was a bit of a misstep. ;_;
17:49:01 <pikhq> Baughn: I'm saying that it's trying to abstract away state just like certain monads allow you to.
17:49:09 <pikhq> And saying it poorly.
17:49:16 <FunctorSal> Baughn: in haskell?
17:49:25 <osaunders> Berengal: Ah ha! And that's where multiple dispatch comes in (refer to my previous comments, if you can be bothered)
17:49:30 <Baughn> FunctorSal: Sorry?
17:49:35 <Axman6> i have a fun semester coming up actually :) Concurrent & Distrib Sys, Relational Databases (not so fun, but oh well), Form Meth Software Engn (proofs etc, in haskell and prolog i think) and Signal Processing
17:49:35 <FunctorSal> it's shorter; with join you must implement liftM as well
17:49:39 <Berengal> osaunders: Yes, but which class does the dispatch belong to?
17:49:53 <FunctorSal> Baughn: (>>=) as elementary monad op
17:50:06 <Baughn> FunctorSal: Well yes, but there could be a Monad class with default implementations for join and >>= that refer to each other
17:50:15 <Cale> osaunders: absolutely, but as soon as you have objects talking to one another, all of a sudden the responsibilities get very hard to follow. Why does my object's private variable have this value? Well, it does because of the sequence of messages that my object received. Where did it get those messages from, and why were they sent?
17:50:15 <FunctorSal> yes
17:50:16 <Baughn> FunctorSal: You should already have fmap
17:50:18 <osaunders> Berengal: Actually I don't know. I still haven't had the opportunity to see how it really works because it's so rare in PLs. I've just discussed it a lot with someone who has.
17:50:40 <FunctorSal> Baughn: you can define Functor and Monad instances in the same file and put "fmap = liftM"
17:50:48 <pikhq> Baughn: Shame that not all Monads are Functors. :P
17:50:50 <FunctorSal> (having only defined return and >>=)
17:50:58 <Berengal> osaunders: None, of course, which just means the dispatches are a bunch of functions lying around everywhere
17:51:01 <Baughn> FunctorSal: You mean pure and >>=. And sure, you could.
17:51:27 <Baughn> FunctorSal: Absolutely nothing's stopping you from doing it that way around, but IMO explaining monads is still easier in terms of join than >>=
17:51:31 <mmorrow_> i always write the Functor instance for types before the Monad one, just because
17:51:36 <FunctorSal> oh wait, Functor isn't a superclass of Monad, so they needn't even be in the same file ;)
17:51:38 <osaunders> Berengal: Hm, interesting. I hadn't thought of it that way.
17:51:38 <Cale> All of a sudden you have this combinatorial explosion of things to examine in trying to decide how any given value got to being what it is, which is why debuggers are so popular, the average case is that you literally can't just sit there and think about it and figure it out.
17:51:54 <mike-burns> Cale: But as soon as you have functions passing data to each other it also becomes slightly confusing; you have to step through (in your mind at least) the function calls and types of the data.
17:52:05 <FunctorSal> Baughn: ah, explaining is a different matter of course
17:52:18 <Berengal> And then there's the abstraction leaks...
17:52:21 <Axman6> thanks a lot Baughn, you've given me the missing pieces i needed to get this stuff working
17:52:30 <Baughn> FunctorSal: I consider implementing something to be about equivalent to explaining it in temrs of thought
17:52:42 <Cale> mike-burns: This is true, but at least you have a reasonable place to stop, because you can be sure that each function will respond the same way when provided the same input.
17:52:53 <osaunders> Cale: Sounds like your saying because an object can have state it's responsibilities are merged with the other objects that interact with it. Otherwise I don't understand you.
17:53:00 <Cale> osaunders: yes
17:53:09 <mike-burns> Okay, I can get behind that.
17:53:12 <Cale> osaunders: and by their connections to other objects, to the rest of the system
17:53:18 <mike-burns> I definitely hate stateful OO.
17:53:39 <Baughn> Trying to maintain a mid-large program in C++, I can say one thing - I kept longing for Haskell, for one reason or another.
17:53:54 <Berengal> Non-stateful OO is the same as a module system...
17:53:57 <FunctorSal> maybe another way to put it is that state can hide flow of information from signatures?
17:53:59 <osaunders> Cale: In which case I'm afraid I don't agree.
17:54:03 <pikhq> Baughn: In C++? I keep longing for almost anything else.
17:54:11 <Baughn> Not least that code gets a lot clearer when you can just say "let zoomed x = foom $ bar (x+1) $ baz x" at need
17:54:23 <FunctorSal> with purity you can just look at the sig and see what goes in and out
17:54:37 <Cale> FunctorSal: right.
17:55:04 <osaunders> There may well be significant advantages to doing away with state or at least controlling it much more closely than most imperative languages currently do but I don't see state as the be-all enemy. Not right now yet. Like I said, I'm a Haskell novice still.
17:55:05 <Cale> If you don't look carefully at an object's implementation, you can't be sure what sending it a particular message will change elsewhere.
17:55:13 <mike-burns> Cale: What's your thoughts on Scheme, though? It also can mutate state without telling you.
17:55:14 <mmorrow_> @type (join .) . flip fmap
17:55:15 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
17:55:20 <Cale> and you can't be certain about what it might depend on in producing its result
17:55:21 <mmorrow_> @type flip ((join .) . flip)
17:55:22 <lambdabot> forall a a1 a2. a1 -> (a2 -> a1 -> a2 -> a) -> a2 -> a
17:55:27 <mmorrow_> @type flip ((join .) . fmap)
17:55:29 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
17:55:36 <mmorrow_> @type (join .) . flip fmap
17:55:38 <Cale> mike-burns: When people use scheme in an impure way, the same problems arise.
17:55:38 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
17:55:46 <Berengal> osaunders: State isn't evil, but it should only be used for what it's good at, and thrown away when not needed anymore
17:55:56 <Cale> mike-burns: Scheme at least has a culture of maintaining purity to some extent.
17:56:06 <Berengal> Monads do this, by encapsulating state in things like runStateT etc.
17:56:29 <Cale> I don't like the thought that monads are specifically for state
17:56:39 <osaunders> Cale: Well, yes, but the message name should help. It is certainly true that you want to minimise side-effects in imperative languages (a lot actually) but the idea of doing away with state entirely as reaction to this is still novel to me.
17:56:47 <pikhq> Cale: That's just a very nice use.
17:56:48 <Cale> But some things which *happen* to be monads are good at it :)
17:56:48 <Berengal> Cale: Not specifically, but it's something they're used for alot
17:56:50 <Axman6> is failure part of being a monad? i've never been sure
17:56:55 <Cale> Axman6: no
17:57:01 <Axman6> righto
17:57:06 <pikhq> They're mind-bogglingly useful outside of that, too. ;)
17:57:08 <Cale> Axman6: This is one of the annoying things about All About Monads
17:57:34 <FunctorSal> are you running with "monad" vs "Monad" here? ;)
17:57:38 <mmorrow_> you don't do away with state, you just maintain it explicitly by passing it around as params to functions
17:57:45 <FunctorSal> fail *is* a part of Monad
17:57:50 <Cale> osaunders: When you start to notice how much easier removing bugs from your code becomes, it's something which becomes more obvious :)
17:57:54 <Berengal> mmorrow_: Also a good alternative
17:58:05 <mmorrow_> then it becomes a matter of how to hide that fact so coding isn't hellish
17:58:17 <mmorrow_> the State monad being an example of this
17:58:39 <Cale> osaunders: In an OO system, if you want to test an object, you usually have to set up a fair amount of state around it, send the object a message, and then see not only its response, but maybe a bunch of stuff which it did elsewhere.
17:58:40 <mmorrow_> s/hide/a better word/
17:58:40 * Baughn is a mite annoyed at having to write "fail = error "can't fail""
17:59:02 <FunctorSal> hehe
17:59:09 <Berengal> I've got three perspectives on monads; monads as computations, monads as containers, and monads as macros
17:59:16 <Baughn> For one thing, it far too often makes me a liar..
17:59:17 <FunctorSal> fail at handling fail call
17:59:20 <Cale> osaunders: and the state of the other objects in the system can affect whether the bug appears or doesn't appear
17:59:20 <Berengal> I consider State to be a macro monad
17:59:23 <mike-burns> Berengal: Monad the Ultimate.
17:59:24 <Berengal> Well, sometimes...
17:59:28 <osaunders> Cale: I look forward :-)
17:59:35 <mmorrow_> Baughn: just write "fail = fail" ;)
17:59:47 <Baughn> mmorrow_: No, that'd fail.
17:59:49 <deech> Axman6, I have put up a simple echo server at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6868#a6869. Does this help you?
17:59:54 <pikhq> mike-burns: Man, that would be great. Monad the Ultimate Lambda. :P
17:59:56 <Badger> > fail
17:59:58 <Axman6> anyone happen to know of a nice way of processing http requests from a socket/handle? wondering if there's a library that'll read them into a nice haskellish form
17:59:58 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Base.String -> m a)
17:59:58 <lambdabot>    arising...
18:00:07 <FunctorSal> or "assert False undefined", that will print the loc at least
18:00:08 <mmorrow_> Baughn: no it wouldn't, it'd just keep trying to forever!
18:00:10 * Badger fails.
18:00:14 <Axman6> deech: it may do, i'll check it out :)
18:00:20 <Cale> osaunders: So it's really nice when you're debugging a pure function and you realise that even without looking at its implementation, this thing only exists to produce its result, and the only thing it can possibly depend on are its parameters.
18:00:28 <Badger> > fail "oh no!"
18:00:29 <lambdabot>   No instance for (GHC.Show.Show (m a))
18:00:30 <lambdabot>    arising from a use of `M1664600180...
18:00:31 <Baughn> deech: That's not "simple", and you don't need to /both/ set buffering and flush
18:00:36 <Cale> osaunders: Sure makes testing much easier to do :)
18:00:37 <mmorrow_> > fix error
18:00:39 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:00:50 <mike-burns> Cale: It depends on both its parameters and on other functions that it calls.
18:00:53 <Badger> @src fail
18:00:54 <lambdabot> fail s      = error s
18:00:56 <FunctorSal> > assert False undefined
18:00:58 <lambdabot>   Not in scope: `assert'
18:01:01 <FunctorSal> :p
18:01:01 <Badger> @src error
18:01:02 <lambdabot> error s = throw (ErrorCall s)
18:01:06 <Axman6> > fix fail
18:01:08 <lambdabot>   ""
18:01:08 <osaunders> Cale: I understand those words but until I experience it myself and it saves my bacon I don't thimk I'll fully appreciate the fuss.
18:01:08 <pikhq> mike-burns: Which is to say, it depends only on its parameters.
18:01:15 <Cale> mike-burns: But those functions are also pure
18:01:22 <Badger> > error "?"
18:01:24 <deech> baughn, didn't know that.
18:01:24 <lambdabot>   * Exception: ?
18:01:24 <Baughn> Cale: And then you realize it was written by me, and probably has unsafePerformIO and hidden state underneath.
18:01:30 <Badger> hm
18:01:30 <Cale> Baughn: haha
18:01:39 <pikhq> Baughn: HATE YOU SO MUCH. :P
18:01:41 <Badger> so why doesn't fail work, if it just calls error?
18:01:43 <Baughn> deech: That's kind of the purpose of hSetBuffering, really. It automatically flushes on \n.
18:01:56 <pikhq> Badger: Type failure.
18:02:02 <Badger> :t fail
18:02:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
18:02:04 <Badger> :t error
18:02:05 <lambdabot> forall a. [Char] -> a
18:02:11 <Baughn> Badger: If my monad doesn't have a sane fail implementation, then I want the compiler to error out if it hits any construct that could call fail.
18:02:11 <Badger> Ah.
18:02:20 <FunctorSal> remember "instance IsBool Int where toBool = unsafePerformIO randomIO"? ;)
18:02:21 <Cale> Baughn: At least I know who to come after with the ritual knife when this contract is broken.
18:02:28 <Berengal> Let's try to gather some statistics: When you encounter a bug in your program, how do you start squashing it? Fire up a debugger and step through the code, or stare at the code until the bug gives itself up?
18:02:39 <pikhq> FunctorSal: My dear Lord, that's evil.
18:02:47 <deech> baughn, cool. I'll remember that. By simple I meant that all it does is to echo the user input. Most of this code is from RWH and it took me a while to understand it.
18:02:50 * Berengal stares at the code. it usually works
18:02:53 <osaunders> Berengal: You know what, debuggers suck.
18:03:02 <Baughn> Berengal: Fire up editor, insert print statements and/or traces
18:03:09 <Baughn> Berengal: ..stare at output
18:03:32 <pikhq> Berengal: Depends on the language.
18:03:40 <mike-burns> Berengal: Typically I know what the bug is. If not, I stare at the code, then if that fails I use tracing/print-debugging.
18:03:44 <osaunders> Ruby has this command line debugger. Oh my god, what a waste of time that is.
18:04:05 <osaunders> I haven't got enough short-term memory to get any use out of that.
18:04:14 <osaunders> All the commands are single letter too.
18:04:14 * Axman6 quite likes Xcode's gdb interface, even if it is broken with DWARF stuff
18:04:16 <mike-burns> The Ruby debugger blows, for sure.
18:04:20 <pikhq> Berengal: Haskell? Stare at it. Tcl? puts statements. C++? cout statements or gdb. Brainfuck? Get out a pen and paper and think about it.
18:04:24 <badsheepy> in haskell i just keep feeding ghci random permutations of what it might like until it gives me what i want
18:04:24 <pikhq> Malbolge? Start over.
18:04:29 <pikhq> (:p)
18:04:40 <badsheepy> sometimes i win, sometimes it wins
18:04:52 <Berengal> Baughn: Really? print statements in the source? All I've needed is ghci and some test-data
18:04:54 <mike-burns> pikhq: Heh, I used the start over technique for Perl too.
18:04:58 <osaunders> pikhq: lol @ brainfuck
18:05:00 <FunctorSal> you could also write quickCheck tests
18:05:01 <Baughn> deech: Another problem I can immediately see, E.catch does not automatically re-throw the exception, and you should never have a catch-all that doesn't re-throw it afterwards
18:05:10 <pikhq> mike-burns: I only joke about the Malbolge. That's nearly impossible.
18:05:11 <Baughn> Berengal: Eh, I was thinking of C++ then, actually
18:05:14 <pikhq> osaunders: I wasn't joking about that.
18:05:16 <Baughn> Berengal: Dwarf fortress is a bitch. :/
18:05:26 <Badger> pikhq: I think what you do with brainfuck is self-explanatory. :P
18:05:40 <Berengal> Baughn: Ooo, DF, long time since I played that
18:05:40 <Baughn> deech: Though it's fine in this case, that's kind of random.
18:05:43 <Axman6> argh! i wish the http-server package had documentation >_<
18:05:47 <Cale> Berengal: Occasionally, Debug.Trace.trace can be useful in determining how evaluation proceeds.
18:05:53 <osaunders> pikhq: Oh, OK :-|
18:05:57 <Baughn> Berengal: I'm the main author of the 40dN series. Go try it. ;)
18:06:05 <Berengal> Cale: I believe you, but I've never needed it myself
18:06:05 <Cale> Berengal: or rescuing good test inputs for a function from the middle of a complicated program
18:06:08 * osaunders liking colloquy for irc
18:06:22 <FunctorSal> (though using QC can be hard if the proportion of interesting inputs to your function is very low :( )
18:06:24 <Cale> I tend to use the idiom:
18:06:27 * Axman6 dislikes colloquy
18:06:35 <Berengal> Baughn: I should. Thanks for reminding me
18:06:53 <osaunders> Axman6: Bah! Bah I say, to you........ bah!
18:07:08 <osaunders> :-P
18:07:11 <mmorrow_> Cale: yeah, trace is sometimes the only way to view a value buried deep in some complicated code where you've got a bug or something
18:07:11 <Baughn> deech: And in fact, for resources of that sort you should use bracket, not finally, to close them. Otherwise there's a race condition if you somehow catch an async exception between listenOn executing and the finally executing
18:07:12 <Cale> foo x y z | trace (unwords ["foo ",show x, show y, show z]) False = undefined
18:07:26 <Cale> adding something like that to the top of a function definition
18:07:31 <Baughn> deech: Oh yeah, and insted of locking log output with an MVar I'd use a Chan, but that's a stylistic choice.
18:07:33 <mike-burns> I'm new to testing with Haskell, but it seems to me that if there's a bug with a specific input perhaps a HUnit test makes more sense?
18:07:45 <Baughn> deech: ..so hang on, you say you didn't write this code?
18:07:47 <FunctorSal> Cale: that should be automatic..
18:07:55 <Cale> FunctorSal: hm?
18:08:09 <osaunders> Do people use HUnit much?
18:08:11 <mike-burns> Cale: Aha, I was looking for this presentation earlier: http://www.ccs.neu.edu/home/matthias/Presentations/ecoop2004.pdf
18:08:17 <FunctorSal> someone should write an automatic trace inserter with haskell-src-exts ;)
18:08:38 <osaunders> mike-burns: Ooh that looks cool.
18:08:46 <Cale> osaunders: In my experience, it's reasonable to just use QuickCheck with properties having no parameters mostly.
18:08:50 <mmorrow_> FunctorSal: where would it insert the traces? (around *every* subexpression?)
18:08:53 <deech> baughn, yes I wrote it but it follows Chapter 27 of RWH pretty closely : http://book.realworldhaskell.org/read/sockets-and-syslog.html
18:09:00 <mmorrow_> (that could be interesting actually...)
18:09:08 <Baughn> deech: And make currying work for you: Instead of passing in an explicit MVar, pass in (logHandle lock)
18:09:17 <mmorrow_>  /literally/ wrap every subsexpression in trace
18:09:27 <FunctorSal> mmorrow_: yeah. I think if you have "trace" around every subexp you don't really need to print the values
18:09:31 <FunctorSal> just the location
18:09:34 <Cale> I would really really love to have a way to watch the graph reduction of Haskell expressions take place step by step.
18:09:45 <osaunders> Cale: What's QuickCheck?
18:09:52 <mmorrow_> (1 + 1) * 2 ==>  trace (trace 1 + trace 1) + trace 2
18:10:05 <mmorrow_> (assuming trace was :: (Show a) => a -> a)
18:10:12 <Baughn> deech: Right, I see you added the exception-handling code I was criticizing. That's a relief.
18:10:14 <pikhq> > quickCheck (2+2 == 4)
18:10:16 <lambdabot>   Not in scope: `quickCheck'
18:10:22 <Cale> osaunders: It's a library which you give it a boolean function of some parameters, and it supplies random parameters of appropriate types, and checks to see if it fails for a few hundred inputs.
18:10:25 <Baughn> deech: A bit late to catch the error otherwise
18:10:27 * pikhq fails at QuickCheck.
18:10:32 <FunctorSal> , quickCheck (2+2==4)
18:10:33 <Berengal> @check (\a b -> a + b == b + a)
18:10:34 <lunabot>  luna: Not in scope: `quickCheck'
18:10:35 <lambdabot>   "OK, passed 500 tests."
18:10:44 <Cale> osaunders: and then if it does fail, it tries to shrink the testcase down to a simpler one which still fails.
18:10:54 <Vanadium> Berengal: What type does it use there?
18:10:56 <deech> baughn, hah :) !
18:11:02 <Berengal> Vanadium: Integer, I assume
18:11:03 <osaunders> Cale: How does it determine what failure is? Just an exception?
18:11:04 <FunctorSal> , quickCheck (\x y -> x+y==y+x)
18:11:05 <lunabot>  luna: Not in scope: `quickCheck'
18:11:10 <Vanadium> osaunders: returning false
18:11:10 <Cale> osaunders: producing False
18:11:10 <FunctorSal> @check (\x y -> x+y==y+x)
18:11:12 <lambdabot>   "OK, passed 500 tests."
18:11:15 <FunctorSal> yay
18:11:26 <Baughn> osaunders: So in non-haskell terms, it's a semi-automated fuzzer. Very, very handy.
18:11:27 <osaunders> OK
18:11:30 <deech> baughn, why is passing in (loghandle lock) a better choice?
18:11:32 <pikhq> @check (\x y -> x+y=x)
18:11:32 <lambdabot>   Parse error at "=x)" (column 13)
18:11:38 <pikhq> @check (\x y -> x+y==x)
18:11:39 <mmorrow_> @check \x -> x == (x+pi::Double)-pi
18:11:40 <lambdabot>   "Falsifiable, after 1 tests:\n0\n1\n"
18:11:41 <lambdabot>   "Falsifiable, after 4 tests:\n2.6666666666666665\n"
18:11:42 <Cale> osaunders: So for example, if you have a parser and a prettyprinter, you can usually test them very well by prettyprinting something and then parsing it again.
18:11:52 <Cale> osaunders: which ought to give the same result
18:11:59 <Baughn> deech: If you pass in the lock, then the function could misuse it by taking or putting it itself
18:12:14 <Axman6> > pi - pi
18:12:15 <lambdabot>   0.0
18:12:16 <mgsloan> @check (\x y -> x `div` y * y + x `mod` y == x * y)
18:12:18 <lambdabot>   "* Exception: divide by zero
18:12:19 <Baughn> deech: The /purpose/ of that lock, in this case, is to pass it to the logging function. That's the only legal action here.
18:12:22 <Berengal> @chekc (\a b -> a == b)
18:12:24 <lambdabot>   "OK, passed 500 tests."
18:12:28 <Baughn> deech: So you might as well do that in advance, and prevent a possible bug
18:12:37 <mmorrow_> > (2.6666666666666665 + pi) - pi :: Double
18:12:39 <lambdabot>   2.666666666666666
18:12:40 <deech> baughn, got it! Thanks!
18:12:44 <dibblego> @check (\x y -> y /= 0 ==> x `div` y * y + x `mod` y == x * y)
18:12:45 <mike-burns> Does anyone use QuickCheck for unit testing? Everything I see it for is something like functional testing.
18:12:46 <lambdabot>   Not in scope: `==>'Precedence parsing error
18:12:46 <lambdabot>      cannot mix `GHC.Classes./=...
18:13:11 <Baughn> deech: If there were multiple functions you might pass, I'd still prefer to wrap up the withMVar_ call with the lock and pass that in as a function instead
18:13:11 <dibblego> mike-burns, yes -- we try not to mix IO unnecessarily
18:13:20 <dibblego> @check (\x y -> y /= 0 ==> (x `div` y * y + x `mod` y == x * y))
18:13:21 <lambdabot>   Not in scope: `==>'
18:13:25 <Cale> :|
18:13:26 <FunctorSal> @check (\a1 a2 b1 b2 -> (a1*b1+a2*b2)^2 <= (a1^2 + a2^2)*(b1^2 + b2^2) )
18:13:27 <lambdabot>   "OK, passed 500 tests."
18:13:34 <FunctorSal> :)
18:13:36 <Baughn> deech: *multiple functions you might pass it to, I mean
18:13:43 <mmorrow_> > pi
18:13:43 <Cale> dibblego: I wonder why it's not in scope
18:13:44 <lambdabot>   3.141592653589793
18:13:50 <dibblego> Cale, I wonder too
18:13:53 <Axman6> > pi - pi == 0
18:13:55 <lambdabot>   True
18:14:00 <mike-burns> dibblego: I don't think I understand.
18:14:22 <dibblego> Cale, also, do you know why after my own lambdabot joins and it asked to evaluate an expression, it immediately gives "Terminated"?
18:14:32 <Cale> @check (\xs ys -> reverse (xs ++ ys) == reverse ys ++ reverse xs)
18:14:34 <lambdabot>   "OK, passed 500 tests."
18:14:42 <dibblego> mike-burns, QC is just unit testing done better
18:14:45 <Cale> dibblego: hmm, do you have mueval installed?
18:15:03 <dibblego> Cale, I hadn't
18:15:04 <mmorrow_> imo (reverse . reverse) == id
18:15:04 <osaunders> I like lambdabot
18:15:23 <Berengal> @check (\xs ys -> reverse (xs ++ ys) == xs ++ ys)
18:15:24 <lambdabot>   "OK, passed 500 tests."
18:15:26 * osaunders is going to read these slides now
18:15:33 <Cale> Berengal: grr
18:15:40 <mike-burns> dibblego: But it seems to typically be used on a level above unit testing; testing that two functions work together in a specific way.
18:15:53 <Berengal> () is an insane default...
18:15:57 <dibblego> mike-burns, that's exactly what unit testing does
18:15:58 <Cale> Berengal: I should find a way to turn off the flexible defaulting for @check
18:16:00 <mmorrow_> it's just a limitation of computers and time that causes it to "fail" to be id in the infinite case
18:16:00 <Baughn> mike-burns: Unit testing is a limit case of quickcheck. You can write a quickcheck function that does only one test, if you want.
18:16:26 <Cale> @check 5^2 == 25
18:16:27 <mike-burns> Baughn: Excellent.
18:16:27 <lambdabot>   "OK, passed 500 tests."
18:16:40 <dibblego> Cale, I had a hard time finding documentation for lambdabot e.g. the format for passwd.rc
18:16:41 <Cale> heh, also it appears that the version of QC that it's using is old, maybe
18:16:43 <Baughn> mike-burns: http://en.wikipedia.org/wiki/Fuzzer <-- Also, this.
18:16:53 <mike-burns> dibblego: Unit testing is to ensure that one function works in a specific way.
18:17:48 <dibblego> mike-burns, you can use QC to do that if you want -- it's just a bit pointless
18:17:55 <Berengal> mike-burns: It's used to test that certain properties hold, much like laws in mathematics
18:18:13 <FunctorSal> ? is it essential whether you cover one function or just two
18:18:16 <mmorrow_> but it doesn't ensure it
18:18:29 <mike-burns> I'm a test-driven developer, so I wouldn't consider testing functions in isolation to be pointless.
18:18:32 <mmorrow_> it can only answer questions negatively
18:18:35 <Berengal> It doesn't guarantee, but it proves it holds for at least some values
18:18:40 <FunctorSal> yes, it's not quickProve
18:18:43 <Axman6> @seen dons
18:18:44 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 2h 35m 12s ago.
18:19:01 <FunctorSal> but it often catches basic errors...
18:19:05 <mmorrow_> it's "QuickTellMeIfThisIsBroken"
18:19:15 <mmorrow_> but it can say that it works
18:19:17 <pikhq> FunctorSal: It's like scientific testing of functions. ;)
18:19:20 <Cale> mike-burns: If you want to *really* be test driven, then thinking about QuickCheck properties first is actually an extension of that mindset.
18:19:21 <mmorrow_> s/can/can'T/
18:19:48 <Baughn> mike-burns: Fuzzing is handy when you can verify the output of a function with much less code than it takes to compute it. Unit testing just reduces the verification to an equality check, and the allowed range of input values to a single point.
18:19:51 <Berengal> Of course, there's also proof-driven development...
18:19:56 <Cale> mike-burns: In that you're thinking about the relationships which your API functions ought to have with one another, instead of just in isolation.
18:19:57 <Axman6> anyone happen to know who 'IavorDiatchki' is/if they are on irc? I'd love for them to write some documentation for the http-server package, because it has a lot of stuff in it, and no haddock
18:20:11 <FunctorSal> mike-burns: I don't understand the difference here... isn't Cale's "reverse" example doing just that (testing that 'reverse' works in a specific way)?
18:20:25 <mike-burns> Cale: That's more like a functional test, or even an integration test, which I also write before the unit tests.
18:20:29 <Cale> @check (\xs ys -> reverse (xs :: [Integer] ++ ys) == reverse ys ++ reverse xs)
18:20:29 <lambdabot>   Parse error at "++" (column 37)
18:20:35 <Cale> @check (\xs ys -> reverse ((xs :: [Integer]) ++ ys) == reverse ys ++ reverse xs)
18:20:38 <lambdabot>   "OK, passed 500 tests."
18:21:04 <Cale> @check reverse [1,2,3,4,5] == [5,4,3,2,1]
18:21:06 <lambdabot>   "OK, passed 500 tests."
18:21:15 <dibblego> mike-burns, I recommend you reconsider calling yourself a "test-driven developer
18:21:18 <FunctorSal> I think that property even defines "reverse" :)
18:21:20 <mike-burns> dibblego: Okay.
18:21:21 <mmorrow_> well, it can tell you that it works if you can exhaustively cover the input space..
18:21:59 <Berengal> @check (\a b -> a == b)
18:22:00 <lambdabot>   "OK, passed 500 tests."
18:22:01 <FunctorSal> ok, not quite, it could still make [x] to something different than [x]
18:22:05 <Berengal> mmorrow_: Like that?
18:22:12 <FunctorSal> s/make/map/
18:22:22 <mike-burns> Cale: That last example is what I was looking for, awesome.
18:22:23 <zong_sharo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6870#a6870 <- i wanna get "wake up after N ms or earlier, if some data arrives" behaviour
18:22:32 <pikhq> > let reverse [] ys = ys;reverse xs [] = xs;reverse xs ys = reverse ys ++ reverse xs in reverse "foo"
18:22:32 <zong_sharo> is there some simpler ways to do it?
18:22:33 <lambdabot>   Couldn't match expected type `[a]'
18:23:08 <Cale> mike-burns: the bot is using an old quickCheck apparently too, as the newer one would realise that it doesn't have to do 500 tests :)
18:23:19 <mike-burns> Ha, didn't even notice at first.
18:23:58 <Cale> Prelude Test.QuickCheck> :t quickCheck
18:23:58 <Cale> quickCheck :: (Testable prop) => prop -> IO ()
18:24:05 <mike-burns> But my real question should have been (now that I know how to do it), why don't we do that in Haskell? What about the language or bugs that arise make it such that traditional unit testing isn't useful?
18:24:16 <mmorrow_> Berengal: if the type is (), then yes ;)
18:24:31 <Cale> mike-burns: Well, it is useful, but types do a lot of your work for you.
18:25:00 <Cale> mike-burns: Types in Haskell say a whole lot more than they do in most of the popular languages about what functions don't do.
18:25:03 <Cale> :t reverse
18:25:05 <lambdabot> forall a. [a] -> [a]
18:25:20 <Cale> The result of reverse cannot depend on the individual values of the elements of the list.
18:25:28 <FunctorSal> maybe a mature IDE would help. it's a bit annoying to keep track of your tests manually
18:25:33 <Cale> I can tell that from the type alone.
18:25:38 <Cale> :t map
18:25:39 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:25:51 <Rotaerk> @src seq
18:25:52 <lambdabot> Source not found. I feel much better now.
18:25:57 <FunctorSal> (ok, there is the quickCheck script)
18:26:07 <Rotaerk> hrm.
18:26:09 <Cale> Here, we can tell that the only elements of the list which is the result of map will be elements of the first list who have had the given function applied to them.
18:26:20 <Cale> Which is *almost* a complete definition of map
18:26:28 <Rotaerk> why doesn't it know about seq?
18:26:39 <dibblego> Cale, what is lambdabot's format for passwd.rc?
18:26:49 <Cale> (but not quite, because we could produce an empty list, or skip out or permute some elements, but we'd almost have to do it with malice to get it wrong)
18:27:04 <Cale> dibblego: let me check
18:27:16 <dibblego> Cale, thanks
18:27:25 <Cale> msg freenode:nickserv identify <password>
18:27:32 <dibblego> cheers
18:27:38 <FauxFaux> Is that "forall a b." a lambdabotism, or can you make ghci do it?  I guess it's not useful in the forall case.
18:27:48 <mike-burns> Cale: For example, say I need a function that takes a User and produces a String that contains HTML: either a link to the user's profile, or the string "Anonymous", based on some function like isAnonymous :: User -> Bool. Would that be a QC candidate? All I can picture is how to unit test it.
18:28:00 <Cale> FauxFaux: GHCi will print it if you have certain extensions switched on
18:28:23 <Cale> mike-burns: sure
18:29:02 <pikhq> mike-burns: Check that it's one of the two. Simple boolean expression.
18:29:11 <Cale> (\u -> isAnonymous u ==> foo u == "Anonymous")
18:29:34 <mike-burns> Oh that's sick. I like it.
18:29:39 <pikhq> That, too, is helpful.
18:29:47 <Berengal> The other side to quickCheck is the generators creating the random values
18:29:53 <Cale> (\u -> not (isAnonymous u) ==> isTag "a" (foo u))
18:30:18 <mike-burns> Perfect. This is the piece about QC that I've been missing.
18:31:04 <mike-burns> Oh wait. What if `\u -> not (isAnonymous u)' is never true. Does QC fail that line?
18:31:16 <Berengal> (\u -> if isAnonymous u then foo u == Anonymous else isTag "a" (foo u))
18:31:36 <Cale> mike-burns: Then it will tell you "I wasn't able to do any tests"
18:31:48 <mike-burns> Okay, great.
18:31:57 <Cale> (I forget the exact message, but it will warn you if it can't find enough tests that satisfy the condition)
18:32:09 <mike-burns> I gotta run, but this was super useful. Thanks a bunch Cale and everyone else.
18:32:12 <Cale> That's why you want to use ==> and not just a logical operator
18:32:14 <Berengal> mike-burns: try (\x -> even x ==> even x)
18:32:37 <mike-burns> @check (\x -> even x ==> even x)
18:32:38 <lambdabot>   Not in scope: `==>'
18:32:42 <mike-burns> Hm.
18:32:47 <mike-burns> Not sure how to use @check I think.
18:33:09 <Berengal> mike-burns: try it in ghci, @check is somewhat weird
18:33:18 <coCocoa> @qcheck
18:33:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:33:37 <coCocoa> @qcheck (\x -> even x ==> even x)
18:33:38 <lambdabot>   Not in scope: `==>'
18:33:38 <pikhq> @qcheck (\x -> even x ==> even x)
18:33:40 <lambdabot>   Not in scope: `==>'
18:33:43 <mike-burns> Ah okay. No time to figure that out now. See you guys later.
18:33:51 <coCocoa> pikhq: Jinx! ;)
18:36:33 <FunctorSal> @check (forAll (arbitrary `suchThat` even) (\x -> even x))
18:36:34 <lambdabot>   Not in scope: `forAll'Not in scope: `arbitrary'Not in scope: `suchThat'
18:36:43 <FunctorSal> oh no
18:37:07 <FunctorSal> @check (forAll (fmap (2*) arbitrary) (\x -> even x))
18:37:09 <lambdabot>   Not in scope: `forAll'Not in scope: `arbitrary'
18:37:37 <FunctorSal> shouldn't @check have all of QC in scope? ;)
18:40:25 <kniu> I don't know if this is the right place for this discussion,
18:40:31 <kniu> but I know of no other.
18:41:00 <kniu> It seems to me that row variables can be described in terms of functions on types.
18:41:43 <kniu> In fact, a record type can be seen as a type-level list,
18:41:54 <kniu> with each node storing a label and its associated type.
18:42:41 <kniu> then, the act of "extracting" a label/type pair with simple list operations is akin to using row-variables.
18:45:32 <hackagebot> happs-tutorial 0.9.0 - A Happstack Tutorial that is its own web 2.0-type demo. (CreightonHogg)
18:46:11 <Berengal> Nice, updated happs tutorial
18:48:15 <impl> win 49
18:48:18 <impl> oops.
18:48:47 <jcreigh> FOURTY NINE! Good God, man!
18:48:55 <jcreigh> Too much IRC. :)
19:19:45 <hackagebot> TernaryTrees 0.1.3.2 - Efficient pure ternary tree Sets and Maps (AlexMason)
19:19:54 <harlekin> @pl ((fmap foo) . bar)
19:19:54 <lambdabot> fmap foo . bar
19:20:03 <harlekin> @pl ((fmap foo 1 2) . bar)
19:20:03 <lambdabot> foo (1 2) . bar
19:20:37 <harlekin> @pl (\foo bar -> fmap foo . bar)
19:20:37 <lambdabot> (.) . fmap
19:20:57 <aavogt> > dateForm = let fi = fromIntegral; ii = inputInteger in liftM3 (\y m d -> fromGregorian y (fi m) (fi d)) <$> ii <*> ii <*> ii
19:20:58 <lambdabot>   <no location info>: parse error on input `='
19:21:38 <aavogt> hah
19:21:44 <aavogt> now I see my problem
19:21:46 <pikhq> :t fmap (fmap foo) bar
19:21:47 <lambdabot> Not in scope: `foo'
19:21:47 <lambdabot> Not in scope: `bar'
19:21:55 <pikhq> XD
19:22:07 <aavogt> ii should actually take an argument
19:24:16 <aavogt> so I don't need multiple levels of liftM3
19:25:04 <aavogt> the (a ->) monad is confusing when youre not aware of it being used
19:25:15 <Axman6> anyone know what i should use to parse a date of the form 'Sun, 12 Jul 2009 02:24:39 GMT' into some data datatype?
19:25:34 <pikhq> I'm going to be perfectly honest: I don't get the -> monad.
19:25:49 <Axman6> @src (->) (>>=)
19:25:50 <lambdabot> f >>= k = \ r -> k (f r) r
19:25:56 <Axman6> yeah, it's messed up :P
19:26:13 <Axman6> @src (->) return
19:26:14 <aavogt> @src (->) return
19:26:14 <lambdabot> return = const
19:26:14 <lambdabot> return = const
19:26:19 <aavogt> yeah
19:26:28 <aavogt> that one's simple
19:26:56 <aavogt> @src Reader (>>=)
19:26:56 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:27:05 <aavogt> @src (Reader a) (>>=)
19:27:05 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:27:30 <pikhq> So, uh... return = K, >>= = flip . s?
19:28:15 <pikhq> (where s and k are the combinators)
19:29:07 <aavogt> > let f = do { x <- (+1); y <- show . (x+); z <- id; return (x,y,z) } in f 3
19:29:09 <lambdabot>   (4,"7",3)
19:29:57 <pikhq> Ahah. I grok its use now.
19:31:33 <coCocoa> Cool. :)
19:31:48 <pikhq> That's pretty cool.
19:31:59 <coCocoa> @src (->) ap
19:32:00 <lambdabot> Source not found. My pet ferret can type better than you!
19:32:12 <aavogt> @src ap
19:32:12 <lambdabot> ap = liftM2 id
19:32:41 <aavogt> I think of ap as liftM2 ($) though
19:33:26 <coCocoa> Let's see if I can get it... ap f k = \e -> f e (k e) -- AKA 'ap' == S
19:33:40 <pikhq> coCocoa: On the functors.
19:33:54 <pikhq> Erm. Functions.
19:34:04 <aavogt> let f = (+1) >>= (+) in f 1 2
19:34:06 <coCocoa> pikhq: Well, yes. :)
19:34:10 <aavogt> > let f = (+1) >>= (+) in f 1 2
19:34:11 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
19:34:12 <lambdabot>    arising from a use of `GHC.Num.+'...
19:34:15 <aavogt> > let f = (+1) >>= (+) in f 1 2 3
19:34:17 <lambdabot>   No instance for (GHC.Num.Num (t -> t1 -> a))
19:34:17 <lambdabot>    arising from a use of `GHC....
19:34:19 <aavogt> > let f = (+1) >>= (+) in f 1
19:34:21 <lambdabot>   3
19:34:59 <aavogt> I guess I don't understand it that well either
19:35:28 <Axman6> bloody hell, trying to figure out how to work with dates and times in haskell is not easy at all
19:35:29 <coCocoa> f x = (x + 1) + x
19:35:39 <aavogt> exactly
19:35:42 <coCocoa> > let f = (+1) >>= (+) in f 11
19:35:44 <lambdabot>   23
19:35:46 <pikhq> Well, let's sugar that and make it make sense.
19:36:12 <pikhq> > let f = do x <- (+1); (+x) in f 11
19:36:14 <lambdabot>   23
19:36:29 <pikhq> That's pretty straightforward. And pretty cool.
19:36:46 <Axman6> that doesn't make it any clearer to me
19:36:53 <aavogt> it does here
19:36:57 <Axman6> @unpl (+1) >>= (+)
19:36:58 <lambdabot> ((\ a -> a + 1) >>= (+))
19:37:11 <coCocoa> pikhq: I'd s/(+1)/succ/ , but I'm not a purist about it, I just like to "go 4 teh lulz"
19:37:15 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
19:37:16 <Berengal> > join (+) 5
19:37:16 <lambdabot>   ("hello","olleh","HELLO")
19:37:17 <lambdabot>   10
19:37:30 <Berengal> @type join (,)
19:37:31 <lambdabot> forall a. a -> (a, a)
19:38:01 <pikhq> Axman6: Basically, you're getting a function applying multiple functions to a single argument.
19:38:03 <aavogt> > liftM3 (,,) id reverse (map toUpper) $ "hello?"
19:38:04 <lambdabot>   ("hello?","?olleh","HELLO?")
19:38:12 <Cale> Axman6: In the function monad, "executing" a function means applying it to the parameter to which the whole computation has been applied.
19:38:14 <Axman6> >_<
19:38:31 <coCocoa> Yeah, what Cale said. :)
19:38:51 <Cale> and what join f does is to execute f, then execute the result of that
19:38:58 <Berengal> The function monad is basically manipulating the return value of functions before they've gotten any arguments
19:39:04 <Cale> so  (join f) x = (f x) x
19:39:19 <coCocoa> Cale: Isn't that W? :)
19:39:33 <Cale> One of those, I'm sure :)
19:39:40 <aavogt> @type join . return
19:39:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
19:40:06 <coCocoa> (Assuming, that we are *still* talking about the Reader, AKA ((->) e), Monad.
19:40:20 <coCocoa> )
19:40:24 <Berengal> > let isPalindrome xs = (==) <*> reverse in (isPalindrome "abba", isPalindrome "aabb")
19:40:26 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> GHC.Bool.Bool)
19:40:26 <lambdabot>    arising f...
19:40:43 <Berengal> > let isPalindrome = (==) <*> reverse in (isPalindrome "abba", isPalindrome "aabb")
19:40:44 <lambdabot>   (True,False)
19:41:00 <Berengal> Going for a pointless style and the first thing I do is adding a point...
19:41:02 <Cale> The neat thing about the function monad is that as an applicative functor, the methods of applicative are exactly the K and S combinators
19:41:10 <pikhq> Berengal: Ah, yes. It's also an applicative. :D
19:41:12 <Cale> Or, a neat thing about it, anyway :)
19:41:25 <Cale> It does make Applicative seem a whole lot less arbitrary to look at it that way.
19:41:31 <Cale> (at least to me)
19:41:52 <Cale> Or perhaps, it makes the SK calculus seem less arbitrary, I can't decide ;)
19:41:54 <Berengal> I've become somewhat fond of the (a -> a -> Bool) <*> (a -> a) pattern...
19:42:02 <coCocoa> Cale: Funny, I just mentioned that about 'ap'/<*>, although I did specify the Monad form. :)
19:43:01 <ray> > liftA2 (*) signum abs $ 4444
19:43:03 <lambdabot>   4444
19:43:12 <ray> > liftA2 (*) signum abs $ -4576
19:43:14 <lambdabot>   -4576
19:43:18 <coCocoa> Now, if only we had a comonad/bifunctor tutorial, and had the modules used more regularly in GHC, it'd make things "interesting"... :)
19:43:19 <Berengal> > ((==).abs <*> negate) (-6)
19:43:21 <lambdabot>   True
19:44:29 <aavogt> coCocoa: a bifunctor is a comonad?
19:45:06 <pikhq> Given how he said it, I'd think (but am not sure) that a comonad is a bifunctor.
19:45:46 <Cale> ah, no :)
19:45:52 <hackagebot> TernaryTrees 0.1.3.3 - Efficient pure ternary tree Sets and Maps (AlexMason)
19:46:01 <Cale> A bifunctor is just a functor in each of two type parameters.
19:46:05 <ray> i think he means a tutorial about comonads and bifunctors
19:46:45 <gwern> @src sort
19:46:45 <lambdabot> sort = sortBy compare
19:46:49 <Cale> Comonad is the dual concept to monad in that it's what you get if you reverse all the arrows.
19:47:26 <gwern> @src insert
19:47:26 <Cale> So instead of return, you have extract :: w a -> a, and instead of join, you have split :: w a -> w (w a)
19:47:27 <lambdabot> insert e ls = insertBy (compare) e ls
19:47:49 <aavogt> @index fmap2
19:47:49 <lambdabot> bzzt
19:47:57 <ray> liftA2
19:48:01 <aavogt> @hoogle fmap2
19:48:01 <lambdabot> No results found
19:48:08 <aavogt> ok
19:48:23 <Cale> (or liftM2 if you only need it for a monad)
19:48:27 <pikhq> Cale: I think my brain is leaking out of my ears now.
19:48:32 <ray> you need at least Applicative for that
19:48:46 <Berengal> dual (getLine >>= \l -> putStrLn ("Hello" ++ l)) = putLine <<= \l -> getStrLn (l ++ "olleH")
19:49:16 <Cale> IO doesn't make a good comonad, because there's no function IO a -> a which makes any sense.
19:50:01 <pikhq> Cale: unsafePerformIO?
19:50:10 <aavogt> @where unlit
19:50:11 <lambdabot> I know nothing about unlit.
19:50:12 <Berengal> Cale: I wouldn't claim my previous comment made much sense either
19:50:15 <Cale> unsafePerformIO is never the answer ;)
19:50:29 <Cale> But, for example, infinite streams do, where extract gives you the first element of the stream, and split is 'tails' basically
19:50:29 <pikhq> True enough.
19:50:42 <Berengal> I forgot to reverse the lambda arrow and the backslash...
19:50:59 <Cale> Or, one which I rather like is that if m is any monoid, then functions m -> a form a comonad
19:51:09 * coCocoa now realizes he should have said "comonad/bifunctor tutorialS".
19:51:28 <ray> you could fit 'em into one tutorial though
19:51:34 <pikhq> Cale: SOPHOMORE CS STUDENT BRAIN HURT.
19:51:35 <Cale> with extract being "apply to mempty", and split f x y = f (x `mappend` y)
19:51:48 <ray> oh, that's cool
19:51:56 <Berengal> Cale: Any use-cases?
19:52:06 <Cale> Berengal: cellular automaton evaluation
19:52:07 <Vanadium> pikhq: non-CS student here, I have to wear a special helmet before entering the channel
19:52:20 <ray> shh, don't tell steve wolfram
19:52:29 * coCocoa really wishes that they'd named that verdammt function "mAppend".
19:52:49 <ray> is it german for map end?
19:52:50 * Berengal wishes they'd named it (++)
19:52:56 * Vanadium wishes it had been efb
19:52:56 <ray> ^
19:53:06 <ray> it will be someday
19:53:14 <Vanadium> I was going to say "a snazzy operator", but I suppose that works.
19:53:38 <Berengal> x `aSnazzyOperator` y
19:54:06 <ray> (+) would be better
19:54:06 * pikhq wishes they'd named fmap (.)
19:54:13 <Cale> "Everything in the universe is a comonad and I am so smart for figuring this out!" -- Stephen Wolfram, "Harnessing the 2012 energy of universal cellular automata"
19:54:37 <bremner> Cale: running title, "I am so smart"
19:54:44 <Adamant> lol
19:54:45 <ray> (++) is more of a mplus
19:55:15 <ray> and fmap should be named both map and (.)
19:55:19 <pikhq> bremner: Add a bit with him offering to pay a few thousand bucks to someone to figure out something that's interesting but mostly pointless.
19:55:22 <ray> i wrote this stuff down a while ago
19:55:26 <Cale> I think (++) should be mappend, myself
19:55:27 <soupdragon> wolfram doesn't say comonad.. ?
19:55:34 <pikhq> That eventually gets won by an undergrad.
19:55:38 <pikhq> soupdragon: Yet.
19:55:48 <Berengal> ray: Lists already use (++), but anyway, it doesn't really matter to me which operator it is as long as it's not some stupid long name
19:56:08 <Twey> > ("He" `mappend` "llo", "He" `mplus` "llo")
19:56:09 <ray> lists are a MonadPlus, and i don't care what's already in use :)
19:56:10 <lambdabot>   ("Hello","Hello")
19:56:10 <Cale> soupdragon: But the activity of cellular automata is naturally modelled by comonads.
19:56:13 <deech> Axman6, still here?
19:56:17 <Twey> Hmn, hmn.
19:56:22 <Axman6> yep
19:56:27 <Vanadium> MonadPlus sounds like half the way there to CeePlusPlus
19:56:29 <soupdragon> Cale yet to see an elegant impl. of that
19:56:33 * coCocoa immediately works on a package with the aStupidLongUnweildyName function...
19:56:33 <Vanadium> I am not sure how I feel about that
19:56:47 <Cale> soupdragon: Oh, I can throw one together if you like, or else there was a nice blog post.
19:56:52 <Berengal> ray: I don't really know what a MonadPlus actually _is_, there's so many different definitions
19:57:09 <soupdragon> you know a lot of real stuff are CAs though, like it explains snowflakes
19:57:22 <pikhq> Vanadium: MonadPlusPlus would be a Monad that implicitly mappends everything.
19:57:38 <soupdragon> just ignosing the 'I am so smart' & lack of referncer
19:57:40 <coCocoa> go sigfpe cellular
19:57:48 <coCocoa> @go sigfpe cellular
19:57:50 <lambdabot> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
19:57:50 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic
19:57:51 <pikhq> Sorry, mplus's everything.
19:57:54 <Cale> soupdragon: Basically the idea is that if you have a function which inspects the cells near the origin and decides what the next state for the origin should be, then applying split and then fmapping that function over the result gives one step of the CA
19:58:02 <deech> axman6, I modified my code with baughn's suggestions - if you still need to look at it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6868#a6873
19:58:07 <coCocoa> soupdragon: There ya go. :)
19:58:11 <soupdragon> Cale, which doesn't get slower each iteration?
19:58:16 <Axman6> thanks
19:58:43 <Cale> soupdragon: Well, that's something you can fix by memoisation, basically.
19:58:49 <ray> berengal: just a typeclass
19:58:53 <soupdragon> coCocoa: that code is a disaster algorithmically
19:59:17 <Cale> soupdragon: Conventionally, by defining an array whose elements are the results of evaluating each iteration.
19:59:19 <Berengal> Cale: Actually, that makes sense. I was just looking over some old GoL code I've got, and it does look like I'm splitting (lists in this case) a lot
19:59:28 <soupdragon> so to imlement comonads we need to use effects?
19:59:36 <Cale> soupdragon: no, not necessarily.
19:59:44 <coCocoa> soupdragon: I get those words individually, but I'm not following the argument. ould you elaborate, please? :)
19:59:45 <Cale> (arrays don't need effects)
19:59:52 <coCocoa> Er*Would
20:00:09 <ray> or could
20:01:03 <soupdragon> coCocoa: if you implement and run that it is 'correct' but too slow for use
20:01:16 <pikhq> soupdragon: Elegant, though.
20:01:32 <soupdragon> maybe I should say operationally, rther than algorithmically
20:01:44 <soupdragon> pikhq (I think it sucks)
20:02:07 <coCocoa> soupdragon: Ah, so by "a disaster algorithmically", you really mean "a disaster to implement". :)
20:02:15 <Cale> soupdragon: What's more important than the code itself is the mental model, but you can make it work just by using the function to compute a step in order to construct a new array from an old one.
20:02:34 <soupdragon> coCocoa its easy to implement, thats not what I meant
20:03:25 <Cale> soupdragon: It's only slow because he's doing nothing to cache the results of computing each step, in the 'test' function.
20:03:29 <ray> a disaster to optimize? it's not like speed matters in the real world, only to pointy-headed academics and people with OCD
20:03:40 <Cale> It's not a disaster to optimise!
20:03:59 <ray> it's not *even* a disaster to optimize, you mean
20:04:11 <Berengal> ray: pointy-headed academics don't care about speed, only complexity
20:04:33 <ray> well, ok, they're one level more abstract than that
20:04:37 <Cale> In this case, complexity wasn't even the concern, but it turns out not to be much of a problem.
20:04:40 <ray> just puts them farther from the real world
20:04:44 <Berengal> 'course they are...
20:04:55 <dolio> Who cares about complexity as long as it's provably terminating? :)
20:05:04 <Berengal> dolio: Fair point
20:05:05 <soupdragon> me!!
20:05:32 <ray> who cares about provably terminating as long as you can make a million dollars using the paul graham cookbook
20:05:35 <Berengal> I care about complexity only if I've gotten it lower than someone else's code
20:06:36 <soupdragon> Cale, how do you memo it?  I can't imagine just looking at test
20:06:49 <Berengal> "Your code is 150 lines, O(n^2) and a hundred times as slow as C for some input, but mine is 5 lines, O(log n), and twice as fast as C"
20:07:23 <Cale> soupdragon: Well, to be honest, this U type is not ideal. I'd prefer something like Integer -> a
20:07:23 <SamB_XP> ray: well, you usually at least want provable productivity
20:07:45 <soupdragon> okay
20:07:48 <Cale> Oh wait...
20:07:52 <ray> i want a provable million dollars!
20:08:03 <Cale> Is this actually slow if you run it?
20:09:33 <soupdragon> Cale, I dont have code but it used to be slow (it gets slower and slower each iteration.. looks like O(n^2))
20:09:48 <Cale> actually, this looks constant time per step
20:09:53 <Cale> er
20:10:04 <Cale> well, linear time, but constant if you take a bounded view
20:10:29 <Cale> The U datastructure is already ensuring that things are cached
20:11:04 <Cale> hmm
20:11:16 <Cale> Oh, perhaps I'm wrong because of what it's actually computing.
20:11:34 <soupdragon> maybe I better rewrite
20:11:47 <Cale> Just copy and paste the article into a .lhs file
20:12:21 <SamB_XP> what, it isn't already one ?
20:12:41 <Cale> Actually, you may be right, in that it has to look backward at more and more of the previous steps to compute the cells at the edges of the region you're viewing
20:12:49 <Cale> It's a natural consequence of being correct though.
20:14:01 <Cale> hmmm... well, perhaps it could be avoided if we explicitly represented the finite bounds of the input.
20:14:14 <soupdragon> oh this is doing a 1D CA, I bet it has linear complexity -- I was doing 2D (GoL)
20:15:07 <Cale> Did you use functions to represent the 2D space?
20:15:14 <Cale> If so, that was your problem :)
20:15:22 <soupdragon> I don't know
20:15:39 <Cale> If you use something like (Integer, Integer) -> Bool
20:16:04 <soupdragon> I think I used  data U2 x = U2 (U (U x))  but I shold test
20:16:09 <Cale> then it won't remember automatically the value which it evaluated to, and so each step will get slower and slower as you have to recompute all the previous ones
20:16:31 <Cale> But that's easy to avoid just by using something like an Array or Data.Map
20:19:03 <mmorrow_> quadtrees are cool
20:19:31 <mmorrow_> i've always wanted to do a life implem using them in some way
20:19:50 <mmorrow_> (iirc the hash-life thing uses them in some manner)
20:20:08 <mmorrow_> (but i wasn't thinking of implementing that in particular)
20:20:50 <coCocoa> Hmm...fingertrees? ;)
20:21:52 <mmorrow_> hmm, maybe they could be adapted (or used literally
20:21:54 <mmorrow_> ) somehow
20:24:11 <mmorrow_> yeah, thinking about it, you'd probably want a quad-tree that's inverted in the zipper sense, so that you have pointers to the live regions
20:30:05 <mmorrow_> hmm, maybe a queue of quadtrees each of which spans a disjoint live region
20:31:16 <monochrom> Who cares about the algorithm if you just want to prove that it exists.
20:33:01 <mmorrow_> monochrom: i guess then the importance shifts to the algorithm you use to come up with the proof of existence ;
20:33:24 <mmorrow_> )
20:33:25 <soupdragon> monochrom: yes we have the the choice
20:33:42 <monochrom> I am saying it in response to "who cares about complexity"
20:34:13 <mmorrow_> soupdragon: oh, what is this for?
20:34:58 <soupdragon> I'm just making a stupid joke about AoC don't listen to me :)
20:35:03 <mmorrow_> ah
20:35:04 <mmorrow_> :)
20:36:01 * mmorrow_ reads scrollback
20:37:17 <jeffwheeler> Do package dependencies make cabal only install the 'library' targets of each package?
20:37:39 <mmorrow_> jeffwheeler: how do you mean?
20:37:43 <jeffwheeler> I'm trying to depend on alex, and I'm having problems where it doesn't seem to work unless I do `cabal install alex` explicitly.
20:38:22 <jeffwheeler> Although it definitely needs more thorough testing for me to be certain quite what is happening
20:38:30 <mmorrow_> oh, not sure about cabal install and executables in deps
20:39:54 <mmorrow_> i think cabal regards alex at the same level as say gcc, so it probably wouldn't try to install it from hackage (?)
20:40:01 <FunctorSal> jeffwheeler: I think the alex executable is ran by cabal if your package has .x modules
20:40:28 <jeffwheeler> FunctorSal: it does; the package is Yi, by the way
20:40:30 <FunctorSal> IOW, I agree with mmorrow_ ;)
20:40:42 <jeffwheeler> FunctorSal: we've had this problem for ages, where you have to install alex first, but I was seeing if I could solve it
20:40:46 <jeffwheeler> or at least understand the problem
20:40:54 <FunctorSal> doesn't alex come with ghc?
20:40:58 <ColeSOAR> i didnt realize that some apps have lack of support for BSD somewhat
20:41:03 <jeffwheeler> Does it?
20:41:19 <mmorrow_> ColeSOAR: BSD what?
20:41:42 <FunctorSal> jeffwheeler: nevermind, it doesn't
20:41:51 <ColeSOAR> earlier ppl were saying they had trouble gettin GHC working on freebsd, openbsd, etc.
20:42:06 <mmorrow> ColeSOAR: ah
20:42:43 <mmorrow> ColeSOAR: i think it's probably because of the rts, and all the very low-level things it needs to do
20:42:43 <ColeSOAR> i assumed with those os's it would be about the same for installing things
20:42:51 <ColeSOAR> what's rts?
20:42:57 <mmorrow> runtime system
20:43:29 <ColeSOAR> i was thinking of switching to a bsd, but now im not so sure.  right now i have mint and it's been pretty annoying
20:43:47 <jeffwheeler> Apparently the only target in alex is the executable, anyways, so that must be what it's building: http://darcs.haskell.org/alex/alex.cabal
20:44:09 <mmorrow> ColeSOAR: ghc definitely works on free/open bsd though
20:45:24 <ColeSOAR> i don't really know what to expect.  i heard the file system is organized better, and the apps it comes with are more, fitting together
20:45:42 <jeffwheeler> So, the package seems to be installed --- the executable exists --- but it's then not added to GHC's db. That is, if I install it via a dependency in Yi, then ghc-pkg list doesn't include it after the failed Yi installation (which fails because of the missing alex).
20:46:11 <jeffwheeler> Yet, it always installs alex just fine as a dependency: it goes through all the complication steps, including copying to .cabal/bin/, and then starts to compile Yi.
20:46:37 <mmorrow> ColeSOAR: hmm, now that i think about it, the trouble probably would come from the ./configure step if at all
20:46:44 <soupdragon> I have a haskell question!
20:46:54 <jeffwheeler> soupdragon: You're in the right spot!
20:47:30 <monochrom> @vixen I have a haskell question!
20:47:31 <lambdabot> church is my favourite computer scientist.
20:47:33 <soupdragon> is it possible to go    foo = .... where open ModuleBar,   so that Module is open just for foo?
20:47:50 <monochrom> No.
20:47:50 <soupdragon> or ainything similar
20:47:56 <soupdragon> :(
20:48:12 <monochrom> Our module system is pretty rudimentary.
20:49:22 <soupdragon> so I should do,
20:49:49 <soupdragon> foo = .... where a = ModuleBar.a ; b = ModuleBar.b ; ...
20:50:18 <monochrom> If it is important to avoid using ModuleBar stuff in other lines of code.
20:50:22 * soupdragon could use #define to make it read better
20:50:52 <jeffwheeler> soupdragon: or a qualified import
20:50:59 <soupdragon> hm{
20:51:01 <soupdragon> hm?
20:51:11 <jeffwheeler> import qualified ModuleBar as MB
20:51:42 <monochrom> import ModuleBar as MB is more flexible.
20:51:46 * jeffwheeler wonders what keymap you're using, to has missed ? with {
20:51:59 <jeffwheeler> err, have
20:52:02 <jeffwheeler> I really should learn how to type
20:52:09 <jeffwheeler> and think thoughts before typing them
20:52:37 <FunctorSal> maybe we should solve the Map/Set/List/... name clash problem by having lots of small classes? like class ToList a
20:53:01 <FunctorSal> or "class ToList a fa | fa -> a" even ;)
20:53:04 <soupdragon> yeah sorry, I'm just picking up momentum with colemak so I make a few more mistakes than usual
20:53:09 <jeffwheeler> Don't we already have several ToList classes?
20:53:14 <FunctorSal> :O
20:53:17 <jeffwheeler> In foldable and such?
20:53:24 <FunctorSal> oh right, it's in Foldable
20:53:42 <Twey> jeffwheeler: ? is directly under { in Dvorak.
20:53:55 <jeffwheeler> Twey: that'd do it
20:53:59 <FunctorSal> but if you import Foldable you get even more clashes unless you deimport the other stuff ;)
20:54:02 <mmorrow> i like the "lots of little classes" idea in principle, but the second you need more than one instance for a type, everything goes to hell
20:54:12 <mmorrow> so i don't think classes are good for that
20:54:12 <jeffwheeler> FunctorSal: indeed :)
20:54:19 <mmorrow> (and we don't have anything else :(
20:54:59 <FunctorSal> how does it go to hell?
20:55:01 <jeffwheeler> And I think Traversable would have been a better example than Foldable, right?
20:55:08 <FunctorSal> if you don't have type inference available?
20:55:25 <mmorrow> FunctorSal: e.g. all the newtypes in Monoid
20:55:29 <FunctorSal> tbh I don't really get what Traversable has more than Foldable
20:55:57 * mmorrow avoids Traversable and Foldable altogether
20:56:22 <FunctorSal> the generic sequence / sequenceA seems pretty useful for one
20:56:56 <FunctorSal> I agree the Sum and Prod newtypes are a bit ugly
20:57:26 <FunctorSal> in the Monoid case it should be solved by having AdditiveMonoid but we discussed that ad nauseam didn't we :)
20:57:54 <mmorrow> or if we had ML-ish modules..
20:58:27 <FunctorSal> how would that solve Sum/Prod?
20:58:36 <mmorrow> you could write haskell modules as ML Functors
20:58:41 <FunctorSal> (I don't know ML modules except from coq)
20:59:50 <mmorrow> FunctorSal: i'll try to come up with/find an example of how i mean
21:03:04 <mmorrow> i forgot how handay vmware is (just reinstalled it on my new laptop after a few months without it)
21:12:18 <davidL> is code.haskell.org having problems?
21:13:41 <mmorrow> looks like it
21:13:49 <erisco> I'd agree
21:14:12 <ColeSOAR> maybe it's not them, maybe it's us.
21:16:54 <mmorrow> FunctorSal: i'm not sure how to express this in sml or something, but what i had in mind was basically equivalent to being able to choose the instance for a type of a particular class you import
21:17:07 <mmorrow> (so these wouldn't be type classes as haskell has them anymore)
21:17:37 <mmorrow> there'd be no automatic instance select, it'd all be explicit
21:18:42 <mmorrow> (but i'm not sure how to hack this idea into the ML module system, then give it an interface that mimics classes or something, since i don't know sml well enough)
21:19:44 <vinicius> uh.. forall x . p = ! exists x . !p , by de morgan, right?
21:20:36 <FunctorSal> mmorrow: isn't implicity (?) the whole point of typeclasses
21:20:48 <FunctorSal> otherwise you could just pass a dictionary record around
21:20:55 <mmorrow> vinicius: isn't that just just the contrapositive?
21:21:16 <mmorrow> FunctorSal: but the whole point of this though is to /not/ have to pass the dictionary around
21:22:52 <FunctorSal> I'd like a priority-based system, though someone said the details would be difficult to work out
21:23:28 <mmorrow> FunctorSal: yeah, i don't think classes should be changed (since they're inherently incompatible with this idea).
21:23:43 <FunctorSal> hmm and it may be a little weird if your program's behaviour changes if you import an extra module with a higher-priority instance :(
21:23:51 <mmorrow> this would have to be a completely new language construct
21:24:23 <vinicius> mmorrow: hm, no. I'm thinking quantified propositions, not types (don't know how it extrapolates to that)
21:24:57 <mmorrow> vinicius: err, i just meant:  (A implies B) <==> (not B implies not A)
21:25:05 <mmorrow> err, right n/m
21:25:41 <mmorrow> vinicius: in your notation, is `p' parameterized by `x' ? (obviously, so it's omitted?)
21:26:47 <mmorrow> hmm, this seems like it's just saying that a statement is equivalent to its contrapositive
21:27:10 <mmorrow> dunno if that needs proof in the system you're working within
21:27:22 <dolio> @djinn (a -> b) -> Not b -> Not a
21:27:23 <lambdabot> f a b c = b (a c)
21:27:45 <mmorrow> djinn++
21:28:14 <dolio> @djinn (Not b -> Not a) -> (a -> b)
21:28:15 <lambdabot> -- f cannot be realized.
21:28:26 <mmorrow> djinn--
21:28:29 <mmorrow> djinn++
21:28:51 <mmorrow> @djinn-env
21:28:52 <lambdabot> data () = ()
21:28:52 <lambdabot> data Either a b = Left a | Right b
21:28:52 <lambdabot> data Maybe a = Nothing | Just a
21:28:52 <lambdabot> data Bool = False | True
21:28:52 <lambdabot> data Void
21:28:54 <lambdabot> type Not x = x -> Void
21:28:56 <lambdabot> class Eq a where (==) :: a -> a -> Bool
21:28:58 <lambdabot> type Cont o a = (a -> o) -> o
21:29:23 <mmorrow> @djinn (Cont o b -> Cont o a) -> (a -> b)
21:29:23 <lambdabot> -- f cannot be realized.
21:29:51 <dolio> One of those 'Qx.P <-> ~Q'x.~P' doesn't work in intuitionistic logic, either.
21:29:55 <dolio> I forget which off hand, though.
21:32:04 <mmorrow> ahh yeah, so you need the interior of the closure
21:32:37 <mmorrow> err, ~~x := interior(closure x)
21:32:39 <dolio> Probably 'Not (exists x. Not P) -> forall x. P'.
21:33:37 <vinicius> oh, forgot about intuitonist logic. :)
21:33:43 <mmorrow> dolio: yeah that make sense
21:33:57 <vinicius> most of double negations have to be proven
21:34:19 <Axman6> anyone happen to know how to get the current time as a CalendarTime?
21:35:14 <mmorrow> Axman6: there's a Utils module in takusen that i found handy for (snagging code to) mess with old-time
21:36:17 <mmorrow> Axman6: (not that you necessarily need the stuff in that module, but it's nice because it has code that manually constructs the various datatypes in System.Time)
21:36:32 <Axman6> ok, thank
21:37:24 <kashifahmed69yah> hi
21:37:29 <kashifahmed69yah> how r u?
21:37:34 <kashifahmed69yah> whats about u?
21:37:47 <kashifahmed69yah> tina r u there?
21:37:50 <Axman6> you trying to troll or what? :\
21:38:01 <kashifahmed69yah> how r u?
21:38:12 <kashifahmed69yah> ?
21:38:17 <dolio> Wiki says you can do: 'x.(x)  x.(x)' 'x.(x)  x.(x)' 'x.(x)  x.(x)' 'x.(x)  x.(x)'
21:38:29 <kashifahmed69yah> asl plz?
21:38:35 <mmorrow> @vixen asl
21:38:35 <lambdabot> 19/f/California
21:38:37 <Axman6> mmorrow: bleh, i'm trying to write a proxy server, and i can't figure out a nice way of working with dates and times of expiries etc
21:38:38 <kashifahmed69yah> and where u from
21:38:38 <kashifahmed69yah> ?
21:38:49 <vinicius> awesome unicode
21:38:51 <mmorrow> @vixen and where u from?
21:38:52 <lambdabot> Huntington Beach California
21:39:02 <kashifahmed69yah> i am from pakistan
21:39:06 <kashifahmed69yah> and u?
21:39:11 <soupdragon> dolio, huh??
21:39:14 <mmorrow> kashifahmed69yah: please write your questions like so:
21:39:20 <mmorrow> @vixen a question here?
21:39:23 <kashifahmed69yah> whats up
21:39:23 <lambdabot> i'll hafta plead the fifth on that one.
21:39:23 <kashifahmed69yah> ?
21:39:23 <Axman6> kashifahmed69yah: have you come here to ask about haskell or not?
21:39:26 <soupdragon> lol
21:39:41 <vinicius> @vixen how is baby formed?
21:39:42 <lambdabot> how? it depends...
21:39:45 <kashifahmed69yah> can i see u?
21:39:46 <kashifahmed69yah> plz
21:39:47 <kashifahmed69yah> ?
21:39:58 <Axman6> kashifahmed69yah: do you know what haskell is?
21:40:04 <Axman6> can you hear me?
21:40:09 <Axman6> hellooo!
21:40:10 <mmorrow> a bot probably
21:40:11 <vinicius> kashifahmed69yah: try a POPL conference =P
21:40:14 <kashifahmed69yah> ya
21:40:17 <kashifahmed69yah> i am there
21:40:21 <kashifahmed69yah> what u say
21:40:26 <Axman6> do you know what haskell is...
21:40:27 <mmorrow> @where ops
21:40:28 <soupdragon> Axman69: don't be silly..
21:40:28 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
21:40:28 <lambdabot> mauke
21:40:38 <kashifahmed69yah> ok
21:40:42 <dolio> He's a character on Leave It to Beaver.
21:40:52 --- mode: ChanServ set +o shapr
21:40:52 <kashifahmed69yah> come to yahoo mesaanger
21:40:53 <kashifahmed69yah> ok
21:40:57 --- mode: ChanServ set +o allbery_b
21:41:06 --- kick: kashifahmed69yah was kicked by shapr (Kicked by shapr)
21:41:23 <allbery_b> hm, a bit slow again
21:41:31 --- mode: allbery_b set -o allbery_b
21:41:48 * Axman6 has never seen this allbery_b chap before :o
21:41:52 <bremner> allbery_b: next time kick shapr first :)
21:41:56 <shapr> :-P
21:42:01 <Axman6> heh
21:42:05 --- mode: shapr set -o shapr
21:42:08 <dolio> There's even a special command for that.
21:42:10 <allbery_b> I'm more often on the mailing list than here
21:42:19 <Axman6> rightio
21:42:30 <allbery_b> (I'm in ur lists messing up ur types :/ )
21:43:14 <mmorrow> im in ur loop uppin yer vars til all them var an 10
21:43:19 <Axman6> god damn. why is this all so difficult? all i want to do it have a date format that can be converted from a string like "Sun, 12 Jul 2009 04:27:14 GMT" and also be able to get the current time in that same type
21:43:33 <dolio> Someone needs to make some new lambdacats images.
21:43:55 <Axman6> someone needs to write a decent time library :(
21:44:14 <aavogt> > read "2009-07-12" :: Day
21:44:16 <lambdabot>   Not in scope: type constructor or class `Day'
21:44:20 <allbery_b> do it yourself and upload to hackage, it's how things get done
21:44:23 <aavogt> > read "2009-07-12" :: Data.Time.Day
21:44:24 <lambdabot>   Not in scope: type constructor or class `Data.Time.Day'
21:44:30 <dolio> Time? What's that? I'm a functional programmer.
21:44:35 <mmorrow> aww, wish i would of thought of that when the cat here walked into the kitchen the other day with a robin in its mouth still flapping it wings against the cats face
21:45:15 <dolio> That definitely sounds cute.
21:45:53 * bremner makes a note to avoid any dolio described "cute girls"
21:46:16 <mmorrow> Axman6: here's an httpDate function i've used http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6876#a6876
21:46:21 <aavogt> Axman6: parseTime from Data.Time (time-1.1.3) looks like it wouldn't be too bad
21:46:36 <mmorrow> dolio: the cat's cute though, would've overshadowed the carnage
21:47:29 <Axman6> mmorrow: looks somewhat useful, but i'd like to use something more like a CalandarTime type i think. something i can use compare on etc
21:47:58 <aavogt> @type CalendarTime
21:47:59 <Axman6> but i can use a lot of that code i think
21:47:59 <lambdabot> Not in scope: data constructor `CalendarTime'
21:48:00 <mmorrow> Axman6: there's TimeDiff for that
21:48:17 <Axman6> @hoogle DiffTime
21:48:18 <lambdabot> Data.Time.Clock data DiffTime
21:48:18 <lambdabot> Data.Time.Clock data NominalDiffTime
21:48:18 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
21:48:24 <Axman6> uh,
21:48:32 <Axman6> @hoogle TimeDiff
21:48:33 <lambdabot> No results found
21:48:34 <mmorrow> Axman6: (and you can always just grab the unix time from TOD and use that Integer)
21:48:49 <Axman6> yeah
21:49:05 <Axman6> i might not worry about time for now i think
21:49:43 <mmorrow> Axman6: err, epochTime if from System.Posix.Time btw
21:49:48 <mmorrow> s/if/is/
21:50:30 <mmorrow> hmm, actually looking at that function, i have no idea why i did it that way..
21:50:42 <Axman6> heh
21:50:49 <mmorrow> (why did i use epochTime at all??)
22:30:18 * ivanm is amazed at the silence...
22:31:02 <dolio> @yow!
22:31:03 <lambdabot> Like I always say -- nothing can beat the BRATWURST here in DUSSELDORF!!
22:31:12 <ivanm> @. @elite @yow
22:31:12 <lambdabot> Plugin `compose' failed with: Unknown command: "@elite"
22:31:17 <ivanm> @. elite yow
22:31:18 <lambdabot> DIdI ... Iz0rz +HaT 4 /\/\ARtIaN nAME, 0r, ArE WE IN izrAE1?
22:31:28 * ivanm can never recall if the used plugins need an @ or not
22:38:54 <soupdragon> does anyone have code that uses Network.HTTP on stdio/stdout?
22:42:30 <shachaf> ivanm: @ is only the prefix for talking to lambdabot.
22:42:38 <ivanm> yeah
22:42:38 <shachaf> Beyond that I don't think you need it.
22:42:54 <ivanm> I always realise it _after_ making the mistake of thinking it's part of the plugin name :s
22:43:21 <ColeSOAR> > show '@hello'
22:43:23 <lambdabot>   <no location info>:
22:43:23 <lambdabot>      lexical error in string/character literal at chara...
22:43:37 <ColeSOAR> > show "@hello"
22:43:39 <lambdabot>   "\"@hello\""
22:43:45 <Axman6> ' is for Char, not String
22:43:53 <inimino> just like C
22:43:55 <ColeSOAR> %|
22:44:07 <ivanm> and no, you can't get lambdabot to call lambdabot
22:44:11 <shachaf> So would "" be for [String]?
22:44:22 <shachaf> ivanm: You could last time I checked.
22:44:23 <aavogt> @type ""
22:44:24 <lambdabot> [Char]
22:44:27 <ivanm> shachaf: :o
22:44:32 <ivanm> all of lambdabot's responses are indented though...
22:44:46 <Axman6> @info , show 1
22:44:46 <lambdabot>  Parse error at "show" (column 3)
22:44:51 <Axman6> @docs , show 1
22:44:52 <lambdabot> , show 1 not available
22:44:53 <lunabot>  luna: Not in scope: `available'
22:44:57 <Axman6> @docs , show 1 --
22:44:57 <lambdabot> , show 1 -- not available
22:44:59 <lunabot>  luna: parse error (possibly incorrect indentation)
22:45:05 <ivanm> heh
22:45:08 <Woof> @info show 1
22:45:08 <lambdabot> show 1
22:45:19 <ivanm> how come @docs doesn't indent
22:45:19 <ivanm> ?
22:45:27 <Axman6> because it's broken
22:45:27 <ivanm> or @info?
22:45:32 <ivanm> @info @info --
22:45:32 <lambdabot>  Parse error at "@info" (column 1)
22:45:42 <ivanm> heh
22:45:43 <shachaf> ?where test
22:45:43 <lambdabot> ?test
22:45:55 <Axman6> ?test
22:45:56 <lambdabot> Maybe you meant: let list tell
22:46:05 <shachaf> However, lambdabot can't hear itself.
22:46:08 <shachaf> So you'd need two instances.
22:46:15 <tavelram> ?where where test
22:46:15 <lambdabot> ?where where
22:46:24 <ivanm> shachaf: ahhhh, so it's not just indentation to get the safety
22:47:03 <shachaf> ivanm: It's just plain IRC. :-)
22:47:10 <aavogt> , "> 2"
22:47:12 <shachaf> (Your client doesn't get messages that you send.)
22:47:14 <lunabot>  "> 2"
22:47:19 <ivanm> oh, it just shows them itself?
22:47:24 <shachaf> Yep.
22:47:27 <ivanm> so you don't think that no-one is listening to you? :p
22:47:53 <solrize> planet.haskell.org is down ?
22:48:07 <shachaf> solrize: I was about to ask the same about code.haskell.org.
22:48:22 <Woof> Given an array (of say, strings), how do I swap the third element and the fifth element?
22:48:41 <Axman6> carefully
22:48:43 <Axman6> >_>
22:48:49 <shachaf> Woof: When you say array do you mean array? :-)
22:49:00 <ivanm> Woof: use a temp variable
22:49:01 <Woof> Yes : D
22:49:11 <Axman6> xor it!
22:49:23 <shachaf> Woof: OK -- often that is not the case. :-)
22:49:25 <Axman6> a ^= b; b ^= a; a ^= b;
22:49:36 <ivanm> forget that, I'm thinking imperatively :s
22:49:37 <shachaf> Axman6: Hum? With strings?
22:49:42 <Woof> ivanm: Exactly
22:49:43 <Axman6> sure :P
22:49:54 <ivanm> Woof: you can replace/update a list of values at the same time...
22:50:08 <aavogt> @type (\\)
22:50:10 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
22:50:21 <aavogt> @type (//)
22:50:22 <soupdragon> ughhhh
22:50:22 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
22:50:26 <ivanm> @hoogle Array i e -> [(i,e)] -> Array i e
22:50:27 <lambdabot> Data.Array.Base (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
22:50:27 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
22:50:27 <lambdabot> Data.Array.Base unsafeReplace :: (IArray a e, Ix i) => a i e -> [(Int, e)] -> a i e
22:50:39 <ivanm> aavogt: gah, you beat me :@
22:50:55 <soupdragon> this simple thing turned into implementing a server
22:51:15 * ivanm wonders how unsafeReplace works... using the ord instance of the index type?
22:51:30 <ivanm> soupdragon: oh, so you weren't going "ughhh" at what lambdabot spat out...
22:52:28 <aavogt> ivanm: perhaps no bounds checking?
22:52:41 <shachaf> a // [(2, a ! 4), (4, a ! 2)] -- ?
22:52:43 <ivanm> aavogt: true
22:52:53 <ivanm> shachaf: that's what I would think you'd use
22:53:00 * shachaf has never used arrays in Haskell, actually.
22:53:12 <ivanm> shachaf: they're definitely more verbose than in C, etc.
22:53:35 <ivanm> of course, you should make sure that you're not overflowing the bounds, etc.
22:53:47 <ivanm> @type (!)
22:53:47 <Woof> Hm
22:53:48 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
22:53:57 <Woof> I meant how can I write a function for it
22:53:57 <ivanm> @hoogle Array i e -> i -> Maybe e
22:53:58 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
22:53:58 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
22:53:58 <lambdabot> Data.Array.Base unsafeAt :: (IArray a e, Ix i) => a i e -> Int -> e
22:54:05 <Woof> So I can do it in Scala without any impurity
22:54:13 <shachaf> @pl \a i1 i2 -> a // [(i1, a ! i2), (i2, a ! i1)]
22:54:14 <lambdabot> ap ((.) . (.) . (//)) (ap (ap . (liftM2 (:) .) . flip ((.) . (,)) . (!)) (flip flip [] . ((flip . ((:) .) . flip (,)) .) . (!)))
22:54:16 <shachaf> Mmm.
22:54:17 <ivanm> Woof: Haskell /= Scala ...
22:54:20 <Woof> I know
22:54:22 <ivanm> shachaf: heh
22:54:36 <ivanm> Woof: can you guarantee that the indices will always be write to avoid a run-time error?
22:54:40 <ivanm> if so, then something like this:
22:55:00 <Woof> Guaranteed : D
22:55:10 <aavogt> Woof: impurity?
22:55:25 <ivanm> swapThirdFifth a = a // [(3, a ! 5), (5, a ! 3)] -- depending on how you have your indexing and the root value
22:55:40 <shachaf> ivanm: Unless indexing starts from 0. :-)
22:55:43 <ivanm> i.e. this assumes that index 1 is the first element in the array
22:55:47 <ivanm> shachaf: hence my comment ;-)
22:55:52 <shachaf> Hence my timing.
22:55:59 <shachaf> Er, sorry.
22:56:02 <ivanm> heh
22:56:02 <Woof> "var array2 = array; array2(j) = array(k)" <~~~ That, aavogt
22:56:25 <ivanm> Woof: even so, you could do one swap at a time using a temp var
22:56:36 <ivanm> using a transformation function
22:56:38 * shachaf should go to sleep.
22:56:50 <ivanm> but AFAIK, using // is the only way of changing values in an array...
22:56:52 <ivanm> @time shachaf
22:56:56 <lambdabot> Local time for shachaf is Sun Jul 12 05:56:52 2009
22:57:00 <ivanm> shachaf: yes, you should
22:57:20 <shachaf> Oh, that's just my IRC client.
22:57:21 <Woof> ivanm: It is a transformation function that I'm trying to write, but I have to have the elements swapped while the array is generated. I can't create the array and then modify its elements
22:57:34 * shachaf is in pacific time -- 22:57.
22:57:39 <ivanm> shachaf: heh
22:57:41 <aavogt> @time ivanm
22:57:43 <lambdabot> Local time for ivanm is Sun Jul 12 15:57:42
22:57:48 <ivanm> Woof: hmmm? why can't you?
22:57:51 <Woof> dibblego hates seeing "var"s in the code x.x
22:58:00 <Woof> If I do that, he'll make me change it D :
22:58:04 <ivanm> heh
22:58:05 <Woof> And he's right, you know
22:58:08 <shachaf> @time aavogt
22:58:10 <mjrosenb> oh snap
22:58:11 <mjrosenb> ghc-stage2: <stderr>: hPutChar: invalid argument (Invalid or incomplete multibyte or wide character)
22:58:15 <ivanm> Woof: since I have no idea how scala works, I can't recommend a way of doing it
22:58:20 <Woof> Plus, this is #haskell
22:58:21 <ivanm> mjrosenb: heh
22:58:34 <Woof> ivanm: That's why I'm asking how you'd do it a pure functional language
22:58:36 <ivanm> Woof: but that _is_ a transformation function on the array
22:58:46 <ivanm> it's completely pure
22:58:52 <Woof> ivanm: Hm, but what's this // ?
22:58:59 <shachaf> @ty (//)
22:59:01 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
22:59:12 <aavogt> shachaf: hah, its 2 here
22:59:21 <ivanm> Woof: that's what aavogt and I found/mentioned before
22:59:24 <Woof> Many Haskell library functions have counterparts in Scala, but not all. But I was looking for an algorithm more than a library function
22:59:35 <ivanm> Woof: there is no real algorithm...
22:59:42 <Woof> Hm
22:59:52 <aavogt> @src (//)
22:59:52 <lambdabot> arr@(Array l u _) // ies = unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]
22:59:59 <ivanm> unless by "algorithm", you include "get the values in the two cells you want to swap, and thenn insert them back in to the new positions"
23:00:09 <Woof> I think I can think of a clumsy one
23:00:12 <aavogt> @src unsafeReplace
23:00:13 <lambdabot> Source not found. Take a stress pill and think things over.
23:00:16 <ivanm> aavogt: :o
23:00:54 <ivanm> aavogt: since the internals of Array aren't exported, it's a bit hard to tell what l and u are (though I assume they're the two bounds on the indices) :s
23:01:05 <aavogt> @type index
23:01:06 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
23:01:17 <ivanm> code.haskell is down :(
23:02:29 <mjrosenb> anyone know what that might mean?
23:02:42 * mjrosenb suspects that it is an endianness issue
23:03:35 <ivanm> mjrosenb: it means I'm glad I'm not trying to do what you're doing ;-)
23:04:00 <Woof> Hm, well
23:04:14 <Woof> Okay, I'll do it impurely and ask dibblego to show me when he gives me hell for it v.v
23:04:31 <aavogt> I'm not sure what you mean by doing it impurely
23:04:37 <Woof> Use vars
23:04:40 <aavogt> (//) ends up returning a new array
23:04:42 <Woof> Mutations
23:04:50 <Woof> Yeah but there's no // in Scala as far as I know
23:04:58 <Woof> I wanted a functional algorithm
23:05:02 <Woof> (Rather than a library function)
23:05:14 <ivanm> Woof: as I said, the only way is to have a pure way of updating an array
23:05:15 <mjrosenb> ivanm: thanks for the encouragement
23:05:18 <shachaf> Woof: Arrays are sort of magical. :-)
23:05:27 <ivanm> if scala doesn't have that, then you can't do it
23:05:33 <ivanm> mjrosenb: no worries, any time :p
23:09:09 <rfmge_> if I have the code '(lower,upper) = span ((<= middle) . nth dimension) points' do I get 'last lower' for free?
23:09:15 <rfmge_> or will it go through lower all over again
23:09:32 <jayzer> what's the recommended online resource/tutorial for a good introduction to haskell?
23:09:54 <jayzer> i'm spending most of my time learning python now, but i used xmonad and i'd like to understand the configuration a little better
23:09:58 <mjrosenb> jayzer: a gentle introduction
23:10:12 <jayzer> but i use*
23:10:37 <aavogt> rfmge_: I seriously doubt that last lower is going to avoid traversing the list
23:10:37 <jayzer> mjrosenb: gracias
23:10:44 <jayzer> somehow i don't think the introduction will be very gentle, though :P
23:10:47 <aavogt> @where lyah
23:10:47 <lambdabot> www.learnyouahaskell.com
23:11:00 <aavogt> jayzer: ^^ that one looks fun
23:12:03 <rfmge_> yeah, I'm thinking that too... I should probably try reading the core generated by ghc
23:12:33 <rfmge_> but it's probably easier just to write the function to get me the last element while im going through, instead of trying to make sense of the core code
23:12:52 <aavogt> @src span
23:12:53 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:13:04 <jayzer> i just can't get over the haskell syntax
23:13:09 <jayzer> i don't know anything about it
23:13:14 <jayzer> but it hurts my brain just at first glance
23:13:30 <rfmge_> I think span is a foldr
23:14:01 <rfmge_> nope, that's partition, sorry
23:14:28 <ivanm> partition is done "by hand", isn't it?
23:14:30 <ivanm> @src partition
23:14:31 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
23:14:31 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
23:14:31 <lambdabot>                               | otherwise = (ts, x:fs)
23:14:37 <ivanm> oh, it is a foldr :s
23:15:23 <aavogt> > span (const True) [1..10]
23:15:24 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[])
23:22:18 <aavogt> > let spn p = foldr (\x st -> case st of (Nothing,xs,[]) | p x -> (x:xs,[]) | otherwise -> (Just x,xs,[]); (a,b,c) -> (a,b,x:c)) (Nothing,[],[]) in spn (<=5) [1..10]
23:22:20 <lambdabot>   Couldn't match expected type `(Data.Maybe.Maybe t, [a], [t1])'
23:22:50 <aavogt> > let spn p = foldr (\x st -> case st of (Nothing,xs,[]) | p x -> (Nothing,x:xs,[]) | otherwise -> (Just x,xs,[]); (a,b,c) -> (a,b,x:c)) (Nothing,[],[]) in spn (<=5) [1..10]
23:22:52 <lambdabot>   (Just 10,[],[1,2,3,4,5,6,7,8,9])
23:23:04 <aavogt> > let spn p = foldr (\x st -> case st of (Nothing,xs,[]) | p x -> (Nothing,x:xs,[]) | otherwise -> (Just x,xs,[]); (a,b,c) -> (a,b,x:c)) (Nothing,[],[]) in spn (>=5) [1..10]
23:23:06 <lambdabot>   (Just 4,[5,6,7,8,9,10],[1,2,3])
23:25:17 <aavogt> > let brk p = foldr (\x st -> case st of ([],Nothing,xs) | p x -> ([],Nothing,x:xs) | otherwise -> ([],Just x,xs); (a,b,c) -> (x:a,b,c)) (Nothing,[],[]) in brk (>=5) [1..10]
23:25:19 <lambdabot>   Couldn't match expected type `[a]'
23:26:34 <rfmge_> aavogt: cool, thanks
23:27:01 <aavogt> > let brk p = foldr (\x st -> case st of ([],Nothing,xs) | p x -> ([],Nothing,x:xs) | otherwise -> ([],Just x,xs); (a,b,c) -> (x:a,b,c)) ([],Nothing,[]) in brk (>=5) [1..10]
23:27:03 <lambdabot>   ([1,2,3],Just 4,[5,6,7,8,9,10])
23:27:57 <aavogt> or, another option is to split the list like a zipper
23:28:27 <aavogt> > let brk p = foldr (\x st -> case st of ([],Nothing,xs) | p x -> ([],Nothing,x:xs) | otherwise -> ([],Just x,xs); (a,b,c) -> (x:a,b,c)) ([],Nothing,[]) in brk (>=20) [1..10]
23:28:29 <lambdabot>   ([1,2,3,4,5,6,7,8,9],Just 10,[])
23:28:42 <aavogt> > let brk p = foldr (\x st -> case st of ([],Nothing,xs) | p x -> ([],Nothing,x:xs) | otherwise -> ([],Just x,xs); (a,b,c) -> (x:a,b,c)) ([],Nothing,[]) in brk (<=20) [1..10]
23:28:44 <lambdabot>   ([],Nothing,[1,2,3,4,5,6,7,8,9,10])
23:29:25 <rfmge_> i need to maintain the order of the first half, if i use a zipper the front will be reversed
23:30:49 <aavogt> true, though say you needed the n'th element before the break, a zipper would make that more convenient
23:32:18 <aavogt> so if you need access to the first elements of the list, you have the original copy, before it got split
23:36:35 <Woof> array.zipWithIndex.map {case(p, q) => if(q==3) array(5) else if(q==5) array(3) else p}
23:36:45 <Woof> ^ There's a clumsy way of doing it in Scala
23:36:46 <soupdragon> wtf
23:36:54 <Woof> @ ivanm
23:40:53 <aavogt> @quote hax0r
23:40:54 <lambdabot> No quotes match. Just try something else.
23:41:46 <aavogt> Woof: that will traverse the whole array though?
23:41:50 <ivanm> Woof: ahhhh! ugly!
23:42:42 <aavogt> you can write (//) in Scala though
23:43:16 <Woof> aavogt: Yes, zipWithIndex traverses the whole array. There's zipWithIndex in Haskell too, right?
23:43:19 <Woof> @src zipWithIndex
23:43:20 <lambdabot> Source not found. I am sorry.
23:43:22 <Woof> @src zipWith
23:43:23 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:43:23 <lambdabot> zipWith _ _      _      = []
23:43:38 <Woof> Well zipWithIndex just zips with the index
23:43:39 <aavogt> @type zipWith ?f [1..]
23:43:40 <lambdabot> forall a b c. (?f::a -> b -> c, Num a, Enum a) => [b] -> [c]
23:44:08 <Woof> @src //
23:44:09 <lambdabot> arr@(Array l u _) // ies = unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]
23:45:29 <aavogt> @type zipWith ?f [1 :: Int ..]
23:45:31 <lambdabot> forall b c. (?f::Int -> b -> c) => [b] -> [c]
23:45:59 <aavogt> @type (//)
23:46:01 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
23:46:39 <aavogt> @hoogle (i -> e -> f) -> Array i e -> Array i f
23:46:40 <lambdabot> Data.Array.Base accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
23:46:40 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
23:46:40 <lambdabot> Data.Array.Base unsafeAccum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(Int, e')] -> a i e
23:48:18 <rfmge_> > let zipWithIndex f xs ys = let go (x:xs) (y:ys) (i:is) = f i x y : go xs ys is in zipWithIndex (\i x y -> (i, x+y)) [1,1,1] [2,2,2]
23:48:20 <lambdabot>   not an expression: `let zipWithIndex f xs ys = let go (x:xs) (y:ys) (i:is) ...
23:48:47 <Woof> @let
23:48:48 <lambdabot>  Defined.
23:49:47 <aavogt> @type zipWith3
23:49:48 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
23:50:04 <rfmge_> d'oh
23:56:36 <shachaf> Woof: Is there much point to using an array if you're going to do that?
23:58:40 <idnar> @pl \f xs ys -> zipWith3 f [0..] xs ys
23:58:40 <lambdabot> flip zipWith3 [0..]
23:58:54 <idnar> oh cute
23:58:55 <idnar> @type flip zipWith3 [0..]
23:58:56 <lambdabot> forall a b c d. (Num a, Enum a) => (a -> b -> c -> d) -> [b] -> [c] -> [d]
