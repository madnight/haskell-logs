00:00:02 <Cale> and then the tail of that
00:00:08 <Cale> iterate f (f (f x))
00:00:13 <jeffwheeler> And so, it quickly has x : f x : f (f x) : . . .
00:00:23 <Cale> --> f (f x) : iterate f (f (f (f x)))
00:00:25 <jeffwheeler> And it won't ever evaluate any of them until necessary.
00:00:28 <Cale> right
00:00:44 <Cale> and there's a certain amount of sharing going on here, which I haven't actually represented
00:00:52 <jeffwheeler> Sharing?
00:00:55 <Cale> yeah
00:01:42 <Cale> When you evaluate an expression using lazy evaluation, you reduce things outermost first, that is, you take the parameters and substitute them into the body of the function without evaluating --- however
00:02:18 <Cale> If a parameter occurs more than once in the body of the function, lazy evaluation says that any results of evaluating one of the copies are shared between the copies of that parameter in the body
00:02:35 <Cale> Let me give my standard example
00:02:37 <Cale> Suppose we have
00:02:41 <Cale> double x = x + x
00:02:43 <jeffwheeler> Which is how unsafePerformIO can break . . .
00:02:48 <Cale> and we want to evaluate:
00:02:52 <Cale> double (double 5)
00:03:00 <jeffwheeler> Because the value will be substituted several times.
00:03:02 <Cale> Under strict evaluation, we'd do:
00:03:05 <Cale> double (double 5)
00:03:08 <Cale> -> double (5 + 5)
00:03:11 <Cale> -> double 10
00:03:13 <Cale> -> 10 + 10
00:03:14 <Cale> -> 20
00:03:29 <Cale> Under plain outermost-first (normal order) evaluation
00:03:31 <Cale> double (double 5)
00:03:37 <Cale> -> double 5 + double 5
00:03:43 <Cale> -> (5 + 5) + double 5
00:03:46 <Cale> -> 10 + double 5
00:03:51 <Cale> -> 10 + (5 + 5)
00:03:54 <Cale> -> 10 + 10
00:03:55 <Cale> -> 20
00:04:06 <Cale> So yes, we waste work re-evaluating the parameter.
00:04:12 <jeffwheeler> Why wouldn't it skip the > 10 + (5 + 5) step?
00:04:24 <jeffwheeler> Doesn't it know that double 5 == 10?
00:04:59 <Cale> It's just reducing the outermost subexpression that is reducible.
00:05:04 <Cale> This isn't lazy evaluation yet :)
00:05:08 <Cale> lazy evaluation will remember
00:05:09 <jeffwheeler> Oh, I see.
00:05:18 <jeffwheeler> Okay
00:05:19 <Cale> I'm just showing why it's important
00:05:25 <jeffwheeler> Gotcha
00:05:42 <Cale> If you'll let me use (let ... in ...) to represent the sharing:
00:05:46 <Cale> double (double 5)
00:05:53 <Cale> -> let x = double 5 in x + x
00:05:59 <Cale> -> let x = 5 + 5 in x + x
00:06:04 <Cale> -> let x = 10 in x + x
00:06:07 <Cale> -> 10 + 10
00:06:08 <ivanm> gah! these requirements for graphviz attributes are sending me nuts!
00:06:09 <Cale> -> 20
00:06:51 <jeffwheeler> Cale: alright, once again, completely logical
00:07:14 <Cale> Srict evaluation always evaluates the parameters once, outermost-first evaluation evaluates each parameter zero or more times, lazy evaluation evaluates each parameter zero or one times.
00:07:19 <jeffwheeler> But I assume it doesn't do this for everything; it'd have to be caching a ton of stuff.
00:07:28 <ivanm> I have that a Color is s quoted string... but then, a list of Colors is a quoted String containing colon-delimited Colors
00:07:32 <Cale> It does it for everything.
00:07:41 <ivanm> so I have to escape the quotes already in there :s
00:08:12 <jeffwheeler> I figured it would sometimes GC variables, hmm . . .
00:08:22 <Cale> Well, that is, when you have any function and the parameter to the function occurs multiple times in the body, you can rely on work being shared between the copies.
00:08:33 <Cale> That's all
00:08:43 <Cale> It doesn't memoise the results of applying functions.
00:08:54 <jeffwheeler> I see. So, I know this is evil and all, but, say:
00:09:23 <jeffwheeler> let g = unsafePerformIO x in f g g
00:09:50 <jeffwheeler> That would only evaluate once, which is why the whole thing is dangerous.
00:09:59 <Cale> yes, if you wanted it to execute the IO twice, you're in trouble there
00:10:16 <jeffwheeler> (Then you'd use strict evaluation, like above?)
00:10:22 <mmorrow> ivanm: how is that going?
00:10:25 <jeffwheeler> (I have no idea why I used parentheses.)
00:10:33 <ivanm> mmorrow: it's a right royal PITA
00:10:41 <mmorrow> ivanm: heh
00:10:50 <Cale> Um, actually, that seems to me like you've written it in a form where it should only happen once in any case.
00:10:52 <ivanm> and I have someone that is desperate for me to make a release as he needs some attributes for his project :s
00:11:28 <jeffwheeler> Cale: I mean, to get it to get g to evaluate twice, you'd have to use seq or something strict.
00:11:40 <Cale> oh, you couldn't actually.
00:11:43 <mmorrow> ivanm: does this person need all the obscure corners of the graphviz language?
00:11:57 <ivanm> mmorrow: nah, not for what he needs
00:12:04 <ivanm> but I'm wanting to cover all the obscure corners :s
00:12:08 <ivanm> and the spec isn't that clear :s
00:12:14 <Cale> At least in GHC, g is a constant, and you can't even force it to evaluate more than once if you wanted to.
00:13:06 <Cale> This is because g is really a code pointer which after the code is executed once to evaluate g, that code pointer gets overwritten to a piece of code that immediately returns the result of the first evaluation.
00:13:14 <Cale> and I don't think there's a way around that
00:13:15 <mmorrow> ivanm: yeah, i guess just use dot to test what the parser accepts
00:13:18 <jeffwheeler> Or, I guess seq's arguments would have the same thing applied?
00:13:18 <jeffwheeler> Where both arguments are the same, so the values would still be substituted.
00:13:56 <mmorrow> ivanm: hmm, also you could look at graphviz's (probably yacc) parser too
00:14:00 <Cale> (if that makes any sense)
00:14:06 <ivanm> mmorrow: *shudder*
00:14:17 <mmorrow> ivanm: heh
00:14:21 <Cale> ...
00:14:30 * Cale wonders what happened to jeffwheeler
00:15:05 <mmorrow> ivanm: i had the trudge through part of it to figure out how to ffi to it for this opengl viewer.. it was painful, but less so than i thought it'd be
00:15:15 <ivanm> mmorrow: *nod*
00:15:27 <mmorrow> (i didn't have to look at the parser though)
00:15:37 <ivanm> mmorrow: what would I need to get you to use my bindings? ;-)
00:16:19 <jeffwheeler> Sorry, Cale. My internet died . . .
00:16:21 <mmorrow> ivanm: what do they do? (for this opengl thing, i don't actually use the dot language, but build graphs with the graphviz C api)
00:16:51 <Cale> jeffwheeler: ah
00:17:01 <Cale> jeffwheeler: Did you mean both arguments to seq are the same?
00:17:05 <ivanm> mmorrow: atm, it's FGL -> Dot, create Dot manually, parse Dot
00:17:10 <Cale> seq x x is always the same as x
00:17:18 <jeffwheeler> Yeah. You could do g `seq` g, but it'd be shared, right?
00:17:22 <ivanm> though once we have the graph class done, I'm wanting to switch it to graph -> Dot
00:17:31 <mmorrow> ivanm: ah, ok. hmm. have you seen andyjgill's dotgen?
00:17:37 <Cale> g `seq` g is the exact same thing as g
00:17:40 <ivanm> mmorrow: yeah, it isn't that great tbh
00:17:48 <jeffwheeler> Cale: because of the sharing?
00:17:48 <Cale> (only possibly a minute amount slower)
00:18:03 <ivanm> mmorrow: I now maintain graphviz because when I needed bindings, this one was the best and so I sent patches to matthew-_
00:18:10 <Cale> Well, I suppose because of the fact that once a value is evaluated, it remains evaluated.
00:18:12 <ivanm> hmmmm.... if I make Dot an instance of graph, does this mean that I can have Dot -> Dot ? :p
00:18:15 <mmorrow> ivanm: i look forward to checking it out for sure.
00:18:24 <Cale> There's no way to explicitly undo the evaluation of an expression.
00:18:37 <jeffwheeler> Cale: I suppose these ideas are sorta all tied together :)
00:19:36 <contrapumpkin> beware of the contrapumpkin
00:19:45 <Cale> Do you see why seq x x is the same as x? seq doesn't get to evaluate until something pattern matches or demands the evaluation of the expression (seq x x), but by that point, it would have demanded the evaluation of x anyway
00:20:28 <mmorrow> ivanm: err, i guess the question i meant to ask is.. what is the main goal of this graphviz code? (e.g. for converting FGL grpahs to .dot in particular, so FGL focused?, or is .dot the main focus and FGL a detail?)
00:20:45 <ivanm> mmorrow: atm, it's FGL focussed
00:20:55 <ivanm> in that the main way of creating Dot graphs is from FGL
00:21:20 <ivanm> I know of at least one person who is using it to create Dot graphs by hand (in doing so, he found a few bugs that cancelled them out when using FGL -> Dot)
00:21:30 <ivanm> in future, I hope to make it graph -> Dot, for any graph instance
00:21:34 <jeffwheeler> Cale: so, whatever evaluates seq will require 'x' to be evaluated? But since seq doesn't pattern match, it only requires it because it's the final result of the operation?
00:21:38 <jeffwheeler> Or . . . that made no sense.
00:21:59 <Cale> jeffwheeler: One way to look at it is that expressions, rather than being trees, are graphs, and evaluation is a process which transforms those graphs. Lazy evaluation means that all the copies of a variable in the body of a function end up being redirected at the expression for that argument.
00:22:08 <mmorrow> ivanm: the thing about dotgen that appeals to me is that it's not tied to any particular graphlib
00:22:13 <Cale> (the sharing part)
00:22:30 <ivanm> mmorrow: well, this _is_ why I proposed the generic graph class ;-)
00:22:39 <mmorrow> ivanm: iirc it just gives a monad for contructing a .dot
00:22:43 <ivanm> mmorrow: but you _can_ create Dot graphs by hand if you so wish
00:22:49 <ivanm> there is no monad for this as yet
00:23:06 <Cale> jeffwheeler: For Maybe values, seq x y behaves like  case x of Just v -> y; Nothing -> y
00:23:12 <mmorrow> ivanm: cool, i'm gonna check it out for sure :))
00:23:17 <contrapumpkin> I definitely support a generic graph lib!
00:23:18 <Cale> jeffwheeler: If that helps any :)
00:23:27 <jeffwheeler> > Just 5 `seq` Nothing
00:23:28 <ivanm> mmorrow: note that I'm in a _large_ rewrite atm
00:23:29 <lambdabot>   Nothing
00:23:36 <ivanm> check out the darcs for it if you want to see what I'm doing with it
00:23:37 <jeffwheeler> > Nothing `seq` Just 5
00:23:39 <lambdabot>   Just 5
00:23:53 <Cale> > (undefined :: Maybe Integer) `seq` "hello"
00:23:55 <lambdabot>   "* Exception: Prelude.undefined
00:24:00 <mmorrow> ivanm: are we talking about the graphviz stuff or the generic graph lib now?
00:24:17 <ivanm> mmorrow: graphviz
00:24:22 <mmorrow> ivanm: ah ok cool
00:24:28 <contrapumpkin> > seq (Just undefined) 5
00:24:29 <ivanm> Cale and I have done some stuff for the graph class, but it isn't up anywhere yet
00:24:29 <mmorrow> i'll do that
00:24:30 <lambdabot>   5
00:24:40 <Cale> ivanm: cool :)
00:24:46 <jeffwheeler> Cale: so it has to determine whether it's a Just v. Nothing, but then can just evaluate to the second argument
00:24:51 <contrapumpkin> damn iPhone has no backticks!!
00:24:52 <ivanm> Cale: what, you don't recall us doing it? :p
00:24:55 <Cale> jeffwheeler: right
00:25:14 <Cale> ivanm: oh, I misparsed that
00:25:22 <ivanm> heh
00:25:32 <Cale> ivanm: I mentally inserted a : after my name.
00:25:36 <ivanm> heh
00:26:53 <jeffwheeler> Wait, what does determining whether it is a Just v. Nothing mean in more generic terms?
00:27:04 <jeffwheeler> That's just partially evaluating it, one step.
00:27:44 <Cale> Evaluation up to determining the top-level constructor is called evaluation to 'weak head normal form'
00:27:52 <ivanm> where is intercalcate defined? @hoogle tells me nothing :s
00:27:59 <Cale> You'll see the abbreviation WHNF
00:28:06 <jeffwheeler> ivanm: Data.List?
00:28:06 <Cale> ivanm: Data.List
00:28:15 <ivanm> @type intercalcate
00:28:16 <lambdabot> Not in scope: `intercalcate'
00:28:19 <ivanm> ...
00:28:23 <jeffwheeler> @hoogle intercalate
00:28:24 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
00:28:24 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
00:28:24 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
00:28:25 <Cale> @type intercalate
00:28:27 <lambdabot> forall a. [a] -> [[a]] -> [a]
00:28:31 <Cale> typo
00:28:35 <ivanm> oh, yeah
00:28:36 <ivanm> :s
00:28:55 <jeffwheeler> So, seq just does WHNF evaluation on its first argument?
00:28:56 <ivanm> @hoogle a -> [[a]] -> [a]
00:28:57 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
00:28:58 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
00:28:58 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
00:29:41 <jeffwheeler> @type intercalate . return
00:29:43 <lambdabot> forall a. a -> [[a]] -> [a]
00:30:06 <Cale> jeffwheeler: yeah
00:30:19 <jeffwheeler> Isn't there some lambdabot module like djk-- that can do things like that?
00:30:26 <jeffwheeler> @commands
00:30:27 <lambdabot> Unknown command, try @list
00:30:29 <jeffwheeler> @list
00:30:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:30:49 <Cale> jeffwheeler: It ensures that its first argument is in WHNF before the value of its second argument is made available.
00:31:04 <jeffwheeler> And that's all seq does?
00:31:14 <mmorrow> jeffwheeler: yes
00:31:17 <Cale> Note that this is very subtly different from saying that it evaluates the first argument before the second.
00:31:34 <jeffwheeler> Yeah; that's why (Just undefined) `seq` 5 works.
00:31:48 <Cale> uh, I'm not even talking about the WHNF part
00:32:12 <Cale> GHC could evaluate the second argument first, and only then evaluate the first just before making the result available.
00:33:06 <gornfan> > (error "a" `seq` error "b") `seq` ()
00:33:07 <jeffwheeler> Just because it'll only evaluate it when it needs to, right?
00:33:08 <Cale> That is  seq y (seq x y)  is actually the same as  seq x y
00:33:08 <lambdabot>   * Exception: a
00:33:27 <Cale> (or at least it can be)
00:33:39 <jeffwheeler> Woah . . . what?
00:33:58 <jeffwheeler> Should that be seq x (seq x y)?
00:34:10 <Cale> It doesn't have to evaluate x first, it just has to make sure to evaluate it before the result of evaluating y is made available.
00:34:18 <Cale> no, though that's also the same
00:34:40 <Cale> So it technically may evaluate y first
00:34:49 <Cale> and then x, and then return y
00:35:11 <jeffwheeler> Oh, I see what you're getting at. The first argument to the first seq doesn't really matter, as long as it's evaluated it before it returns from the whole thing.
00:35:12 <mmorrow> Cale: hmm, i'd say that ==> y `seq` (x `seq` y) ==== (y `seq` x) `seq` y
00:35:54 <contrapumpkin> zomg associative seq :P
00:35:57 <Cale> jeffwheeler: I'm getting at the fact that it doesn't *really* sequence x and y
00:36:05 <jeffwheeler> Cale: yeah
00:36:24 <Cale> jeffwheeler: Just that it ensures that x is evaluated before whatever wanted to use y is able to do so.
00:36:32 <contrapumpkin> :t pseq
00:36:34 <lambdabot> forall a b. a -> b -> b
00:36:47 <Cale> pseq is the one which actually makes sure that x is evaluated before y
00:36:48 <jeffwheeler> I assume seq is short for sequence, right?
00:37:04 <Cale> yes, though it's a slightly inappropriate name
00:37:12 <Cale> (but not too inappropriate)
00:37:15 <jeffwheeler> Yeah, I can see how that's counter-intuitive.
00:37:34 <jeffwheeler> It sequences it to be evaluated prior to the total result, but not the second argument.
00:37:44 <Cale> right
00:37:45 <jeffwheeler> (The first 'it', being the first argument.)
00:38:31 <mmorrow> jeffwheeler: also note that you can essentially define seq with bangpatterns
00:38:37 <mmorrow> seq !a b = b
00:38:44 <ivanm> @type showList
00:38:46 <lambdabot> forall a. (Show a) => [a] -> String -> String
00:38:51 <ivanm> what's the String param for?
00:39:01 <jeffwheeler> @src showList
00:39:02 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
00:39:11 <Cale> ivanm: does saying that it should be called showsList help?
00:39:13 <ivanm> @src Char showList
00:39:13 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:39:15 <jeffwheeler> Does lambdabot really have to be so insulting?
00:39:20 <mmorrow> ivanm: to avoid O(n^2) with (++)
00:39:21 <Cale> > showList [1,2,3] "hello"
00:39:21 <jeffwheeler> It just adds insult to injury.
00:39:22 <lambdabot>   "[1,2,3]hello"
00:39:24 <ivanm> Cale: yeah, I was just thinking that...
00:39:25 <contrapumpkin> don't bang patterns just desugar to seq?
00:39:39 <ivanm> contrapumpkin: yeah, I think so
00:39:45 <Cale> jeffwheeler: The funny thing is that it's actually the one being stupid here ;)
00:39:47 <mmorrow> contrapumpkin: i'm not sure what the actual desugaring is, but i think so yeah
00:39:48 <ivanm> contrapumpkin: so how many variations on your base nick do you have now? :p
00:40:08 <jeffwheeler> Cale: by the way, thanks a ton for your awesome explanation :)
00:40:13 <mmorrow> , let !x = 1 + 1 in closureType x
00:40:16 <contrapumpkin> ivanm lots :P this one is my iPhone
00:40:18 <lunabot>  Constr
00:40:30 <Cale> ivanm: The point is so that if you're showing a lot of stuff at once, you don't end up with lots of (++)'s
00:40:35 <jeffwheeler> contrapumpkin: Colloquy?
00:40:35 <ivanm> Cale: yeah
00:40:44 <jeffwheeler> contrapumpkin: amazing app
00:40:50 <contrapumpkin> jeffwheeler: flowchat :)
00:40:51 <Cale> ivanm: but showList isn't really meant to be used directly
00:41:01 <jeffwheeler> contrapumpkin: :|
00:41:06 <contrapumpkin> lol
00:41:06 <ivanm> Cale: I want to define a custom one for a type to avoid having to newtype the list form
00:41:07 <mmorrow> contrapumpkin: there was one case where iirc the ! and using seq gave a different closureType or something, but i can't remember how to reproduce that
00:41:16 <ivanm> which is the only reason I care ;-)
00:41:21 <Cale> ah, okay :)
00:41:24 <contrapumpkin> mmorrow: interesting
00:41:33 <Cale> ivanm: You could also use overlapping instances.
00:41:42 <mmorrow> contrapumpkin: i'm pretty sure ! and seq are implemented differently in some way in ghc
00:41:44 <ivanm> Cale: *nod*
00:42:00 <mmorrow> contrapumpkin: but i think they're essentially the same when viewed from haskell
00:42:00 <ivanm> Cale: but one of my stated goals for graphviz is to _reduce_ the number of extensions, not use more :p
00:42:04 <Cale> But the hack is already there, might as well use it :)
00:42:07 <Cale> and that too
00:42:15 <contrapumpkin> mmorrow: only one way to find out! :D
00:42:16 <mmorrow> contrapumpkin: (hmm, or maybe ! and pseq are what are the same (?))
00:42:20 <ivanm> hmmm.... just trying to work out how to define it, that's all :s
00:42:26 <Cale> jeffwheeler: anyway....
00:42:30 <ivanm> since lambdabot doesn't know the one for String :s
00:42:39 <ivanm> I mean for Char
00:42:56 <contrapumpkin> mmorrow: maybe actually
00:43:05 <contrapumpkin> pseq just adds the lazy call
00:43:10 <Cale> jeffwheeler: when we evaluated iterate f (f x), I said it reduced to f x : iterate f (f (f x))
00:43:33 <jeffwheeler> But it really reduced to: let y = f x in y : iterate f (f y)
00:43:37 <contrapumpkin> I could see them doing that on constructors, but it's hard to tell
00:43:41 <Cale> jeffwheeler: But actually, if you want to represent the sharing properly, it's more like  let z = f x in z : iterate f (f z)
00:43:42 <mmorrow> contrapumpkin: to further complicate things, i think that seq and pseq are the same thing in ghc, although they need not be in another implementation
00:43:47 <Cale> yes
00:43:52 <jeffwheeler> Cale: :)
00:44:16 <jeffwheeler> Cale: once again, thanks for your awesome explanation
00:44:18 <Cale> jeffwheeler: But that doesn't at all help prevent the stack overflow -- let never does any evaluation
00:44:33 <Cale> Um, actually, though.
00:44:33 <contrapumpkin> failclient
00:44:35 <jeffwheeler> Cale: wait, even if it has pattern matching?
00:44:36 <Cale> In a way it does.
00:44:44 <ivanm> gah, the showList def for Char is ugly :s
00:44:57 <Cale> It helps prevent the stack overflow if you pattern match on each element as you're traversing the list.
00:44:58 <jeffwheeler> > let (Just m) = Just 5 in m
00:45:00 <lambdabot>   5
00:45:11 <jeffwheeler> Yeah . . .
00:45:16 <mmorrow> , let Just x = undefined in 42
00:45:17 <Cale> However, if you skip evaluating a long substring of the elements, you'll end up with a large expression.
00:45:18 <lunabot>  42
00:45:36 <mmorrow> , case undefined of Just x -> 42
00:45:38 <lunabot>  luna: Prelude.undefined
00:45:47 <mmorrow> , let !(Just x) = undefined in 42
00:45:49 <lunabot>  luna: Prelude.undefined
00:46:00 <jeffwheeler> mmorrow: but that's just laziness in action, right?
00:46:01 <Cale> But the stricter iterate' makes sure that you can't even traverse the list without forcing the elements into WHNF at least
00:46:18 <Cale> From there, it's f's responsibility to make sure that things are evaluated more if they need to be
00:46:21 <mmorrow> jeffwheeler: that's the current definition of "let" in action
00:46:34 <jeffwheeler> mmorrow: well, yeah :)
00:46:38 <Cale> let + bang-patterns = case
00:46:42 <mmorrow> jeffwheeler: there's actually a haskell' proposal to make let matches strict
00:46:47 <Cale> noooooooo
00:46:49 <mmorrow> by john hughes
00:46:55 <contrapumpkin> lol
00:47:07 <mmorrow> heh
00:47:11 <Cale> let is for putting things on the heap, if you want to evaluate, use case.
00:47:18 <contrapumpkin> I'm not a fan
00:47:38 <Cale> (or bang patterns)
00:47:52 <contrapumpkin> she bangs she bangs
00:48:00 <wmealing_> oh the way she moves.
00:48:11 <mmorrow> i'm a fan of allowing bangs in letrecs though
00:48:22 <Cale> John Hughes seems to have a lot of ideas which seem terrible to me with regard to patterns and polymorphism
00:48:26 <contrapumpkin> glad to see we have another Ricky Martin fan in here
00:48:33 <hackagebot> mmap 0.4.1 - Memory mapped files for POSIX and Windows (GracjanPolak)
00:48:58 <Cale> mmorrow: Yeah, that's okay, just to keep things consistent, and the only reasonable thing you can do is transform them into case expressions.
00:49:19 <Cale> mmorrow: I suppose you could also just ignore the bang altogether, but that's not so nice.
00:50:01 * jeffwheeler finds it weird how certain people in Haskell are famous, but rarely mentioned. Oleg, for example. I have no idea who he is, but everybody knows about him.
00:50:19 <ivanm> jeffwheeler: he has lots of crazy (and not so crazy) type-based ideas
00:50:20 <Rembane> Ninjagurus
00:50:26 <ivanm> e.g. the Basic monad :s
00:50:31 <jeffwheeler> Apparently he's good enough at Haskell to write crazy code, and everybody respects him.
00:50:36 <mmorrow> Cale: what do you mean by ignore the bang?
00:50:44 <Cale> jeffwheeler: You're not on the mailing list are you? :)
00:50:52 <contrapumpkin> ivanm wasn't that augustss?
00:50:55 <ivanm> mmorrow: s/!//g ? :p
00:50:57 <ivanm> contrapumpkin: oh, right
00:51:02 <mmorrow> gah, what's the url for the "proposals" grouped by "accepted/rejected/considering" ?
00:51:10 <jeffwheeler> Cale: I am
00:51:19 <jeffwheeler> Cale: although I hardly read every post
00:51:20 <Cale> mmorrow: I mean since it's a let, just ignore an outermost bang on a pattern binding.
00:51:34 <Cale> mmorrow: since it's really ~(pat) anyway
00:52:04 <mmorrow> Cale: i can't remember the exact details.. . trying to find thee link i'm thinking of
00:52:14 <Cale> > let f (~(!x)) y = y in f undefined
00:52:16 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
00:52:26 <contrapumpkin> aw
00:52:43 <Cale> Prelude> let f (~(!x)) y = y in f undefined 1
00:52:43 <Cale> 1
00:53:31 <mmorrow> ah, so
00:53:33 <Cale> Since pattern binding patterns all normally have ~ implicitly added to them, it would make sense for the outermost ! to have no effect.
00:53:35 <mmorrow> "A non-recursive bang-pattern binding is equivalent to a case expression:"
00:53:50 <Guest82532> hmmm why is (a $ b) (-) not working?
00:53:51 <mmorrow> so recursive bang pattern are something else altogether
00:53:58 <mmorrow> (and currently disallowed)
00:54:15 <mmorrow> but they /do/ make sense in certain instances
00:54:16 * jeffwheeler wonders a PPA for GHC might be a good idea
00:54:19 <Cale> But it seems kind of an odd case, since the ! has no effect there, and presumably the programmer wrote it for a reason, so it seems only natural that we translate it into a case for them.
00:54:29 <anders^^> Guest47473: you might want (-) a b or something instead
00:54:30 <jeffwheeler> s/wonders/wonders whether/g
00:54:37 <themroc---> hmm
00:54:41 <Cale> PPA?
00:54:51 <themroc---> im just playing around with ($ x) f
00:54:54 <mmorrow> ah i found it
00:54:56 <mmorrow> http://hackage.haskell.org/trac/haskell-prime/wiki/BangPatterns
00:54:57 <Nafai> jeffwheeler: The problem with that is you would have to also recompile all haskell packags as well for the new GHC
00:55:02 <jeffwheeler> Cale: Ubuntu system that can automatically build packages from source
00:55:05 <Nafai> Cale: Personal Package Archive
00:55:05 <mmorrow> starting with "Recursive let and where bindings ¶"
00:55:23 <jeffwheeler> Nafai: Yeah, I suppose so . . .
00:55:26 <Cale> mmorrow: yeah, recursion gets very strange
00:55:39 <jeffwheeler> And I think three's a more clever haskell-debian team or something working on better solutions.
00:55:40 <themroc---> ($ 3 1) (-) doesnt work too
00:55:45 <Cale> mmorrow: Of course, not so strange if you'd just gone with the naive translation ;)
00:55:55 <mmorrow> and then the john hughes strict let thing is under "A more radical proposal ¶"
00:56:00 <gornfan> themroc---: 3 1 doesn't make sense
00:56:04 <gornfan> themroc---: because 3 is not a function
00:56:13 <Cale> mmorrow: I hope nobody considers that seriously.
00:56:17 <themroc---> aive translation ;)
00:56:17 <themroc---> [09:55:51] <mmorrow> and then the john hughes strict let thing is under "A more rad
00:56:19 <themroc---> oops
00:56:26 <themroc---> (-) 3 1
00:56:28 <themroc---> that works :p
00:56:41 <anborn> Hi. I have a function like the following: run :: (a -> IO b) -> IO c. The first argument is an handler that will be (repeatedly) invoked by "run" to produce some effect. I'd like to add some state; I could wrap the "IO c" into a StateT transformer, but would it be possible to make such state visible to the handler function? I guess I'd need to change "run" to turn it into: run :: (a -> StateT IO b) -> StateT IO c; unfortunately I
00:56:56 <Cale> mmorrow: That would be really screwed up. I regularly use where clauses which define things that I don't necessarily want evaluated.
00:56:57 <contrapumpkin> @pl (\f -> f 3 1)
00:56:58 <lambdabot> flip ($ 3) 1
00:57:16 <contrapumpkin> @pl (\f -> f 3 1) (-)
00:57:17 <lambdabot> 2
00:57:24 <themroc---> hmm
00:57:27 <contrapumpkin> lol
00:57:31 <Cale> (however, my net connection is being screwy and I can't connect to that site atm)
00:57:32 <mmorrow> Cale: apparently the "haskell 98 semantics can be recovered by using a ~"
00:57:35 <contrapumpkin> not what I wanted
00:58:05 <Cale> mmorrow: Well, okay, that's natural, but that's actually what I would usually want anyway.
00:58:20 <Cale> mmorrow: I don't really understand why you'd want to make it strict.
00:58:41 <jeffwheeler> Nafai: on the other hand, that doesn't really cause any problems because cabal-install knows to reinstall all those packages
00:58:48 <Nafai> True
00:59:05 <mmorrow> Cale: i'm not sure the exact motivation, but i want figure that out
01:01:06 <Cale> actually, I'm not even 100% convinced that turning bang patterns inside let into case expressions is a good idea in the first place
01:01:23 <themroc---> how is $ being called? to look it up on google
01:01:55 <Cale> themroc---: I suppose it's another name for the identity function (or a specialisation of the identity function to functions)
01:02:09 <Cale> themroc---: or "function application"
01:02:21 <Cale> But I usually just call it $
01:02:32 <Cale> @src ($)
01:02:33 <lambdabot> f $ x = f x
01:02:41 <mmorrow> Cale: reading this page, i'm not sure at first glance what the current behavior is and what the proposed behavior is (re: turning bangs inside lets into case)
01:02:49 <Cale> There is not much to know about it except that it has really low operator precedence.
01:03:07 <themroc---> ok will look into that later
01:03:11 <Cale> So if you write something like   f . g . h $ x n m
01:03:12 <themroc---> off for exam now
01:03:16 <themroc---> back in 4 hours :p
01:03:21 <Cale> it means the same as (f . g . h) (x n m)
01:03:30 <Cale> So we use it to avoid parens
01:03:34 <jeffwheeler> I like calling ($) "function application"; definitely my favorite name
01:04:04 <Cale> mmorrow: I think perhaps it's a bad idea altogether. I don't see what's so wrong with forcing people to write case
01:04:35 <mmorrow> Cale: but that issue aside, there's also the issue of recursive bang patterns
01:04:40 <Cale> right
01:04:57 <mmorrow> which i don't fully understand all the details yet
01:05:45 <Cale> I think maybe we just should have stuck with the behaviour that it had when bang patterns were first introduced, which is easy to specify.
01:06:11 <Cale> and just ignore the issue that bangs on pattern bindings have no effect
01:06:29 <mmorrow> ah, hmm
01:06:41 <mmorrow> so that was the initial behavior?
01:06:45 <Cale> yes
01:06:52 <mmorrow> ah
01:07:02 <Cale> it changed in, I think the second version of GHC to support pattern bindings, whatever that was
01:07:53 <mmorrow> Cale: was this allowed initially?:
01:08:01 <mmorrow> foo (!x,y) = ...
01:08:02 <mmorrow> ?
01:08:07 <Cale> yes, I think so
01:08:33 <Cale> But I might be wrong.
01:08:50 <mmorrow> i find that use particularly handy
01:09:15 <mmorrow> foldl' (\(!a,!b) c -> ..) ..  being the canonical example
01:09:29 <mmorrow> (canonical in my mind ..)
01:09:44 <Cale> Translates to  foo (x,y) | x `seq` True = ...  right?
01:10:02 <mmorrow> + `seq` y `seq` True = ..
01:10:03 <mmorrow> yeah
01:10:07 <mmorrow> oh
01:10:10 <mmorrow> the first you mean
01:10:12 <mmorrow> yeah
01:10:13 <Cale> yes
01:10:58 <mmorrow> it really becomes useful in lambdas
01:12:30 <jeffwheeler> hpaste breaks if 'value' is ever used without it referring to the standard function
01:12:39 <jeffwheeler> Err, 'error'
01:14:24 <mmorrow> :o
01:14:31 <mmorrow> jeffwheeler: how do you mean?
01:14:56 <jeffwheeler> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7113#a7113
01:15:08 <jeffwheeler> mmorrow: scroll down a bit; that function is highlighted very strangely
01:15:21 <mmorrow> ohh, you mean the syntax highlighting
01:15:24 <jeffwheeler> mmorrow: even the name, preceding the type
01:15:29 <jeffwheeler> mmorrow: oh, yes
01:15:57 <mmorrow> jeffwheeler: it uses the python lib "pygments"
01:16:13 <jeffwheeler> mmorrow: oh, that lib is usually really great
01:16:15 <mmorrow> not sure off hand how to modify that
01:16:47 <mmorrow> yeah, i like how you have like 30 langs to choose from
01:17:03 <doserj> interesting, loadModule is also highlightes strangely, typecheckMoudle and parseModule aren't, however
01:19:18 <mmorrow> doserj: maybe it's the surrounding context that loadModule happens to be in there
01:19:54 <mmorrow> oh weird, i see it
01:19:56 <jeffwheeler> mmorrow: I'd wager it's highlighted differently because it's the first Module on the line
01:20:29 <mmorrow> the "module'" may have something to do with it also
01:20:42 <jeffwheeler> G'night all. I should have gone to bed hours ago.
01:20:46 <mmorrow> night
01:20:49 <doserj> mmorrow: might be
01:21:34 <mmorrow> doserj: ahh, i think it's finding module', then it highlights the first word starting with a n uppercase letter as the module name
01:21:59 <mmorrow> which just happens to be "Module" here
01:22:01 <doserj> well, that's simply broken...
01:22:04 <mmorrow> heh
01:23:29 <thoughtpolice> @src iterate
01:23:30 <lambdabot> iterate f x =  x : iterate f (f x)
01:24:07 <mmorrow> doserj: looks like that's it  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7116#a7116
01:24:29 <mmorrow> the fact that ' is a valid haskell ident char confuses it
01:24:46 <mmorrow> because it doesn't confuse "module9" for module
01:25:18 <Axman6> > iterate f x
01:25:20 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
01:26:32 <mmorrow> , let module = 42 in module
01:26:34 <lunabot>  luna: parse error on input `module'
01:26:40 <mmorrow> , let forall = 42 in forall
01:26:42 <lunabot>  42
01:26:59 <mmorrow> , let class = 42 in class
01:27:01 <lunabot>  luna: parse error on input `class'
01:27:22 <mmorrow> ah, "forall" isn't haskell98 iirc
01:28:01 <mmorrow> (technically there's no ambiguity using "class" or "module" there
01:28:02 <mmorrow> )
01:28:21 <mmorrow> although there would be if you tried to   name a top-level def "class" or "module"\
01:28:23 <quicksilver> ivanm: because dcoutts is a Cabal developer and he quite often reads his backlog, especially if you mention his name.
01:28:28 <gornfan> , let qualified = 42 in qualified
01:28:29 <lunabot>  42
01:28:40 <mmorrow> , let import = 42 in import
01:28:41 <lunabot>  luna: parse error on input `import'
01:28:51 <mmorrow> , let hiding = 42 in hiding
01:28:52 <lunabot>  42
01:29:20 <mmorrow> i guess any keyword that can start a line can't be allowed (without confusing restrictions)
01:30:01 <quicksilver> mmorrow: there's no ambiguity even with toplevel definitions called class and module, I don't think.
01:30:08 <quicksilver> but there is backtracking needed.
01:30:19 <quicksilver> and I think the haskell grammar is designed to limit the amount of backtracking.
01:30:22 <mmorrow> quicksilver: yeah, lookahead/bactracking
01:30:35 <dblhelix> someone know about a parser for PHP written in Haskell?
01:30:50 <mmorrow> dblhelix: if one existed, it'd probably be on hackage
01:31:15 <dblhelix> mmorrow: nothing there, that's why I asked ;-)
01:32:23 <mmorrow> dblhelix: if you end of having to write your own, maybe start with a parser for a similar lang that /is/ on hackage (or wherever)
01:34:13 <quicksilver> mmorrow: although it's not completely lookahead free, IIRC.
01:35:02 <mmorrow> quicksilver: the happy parser for haskell-src* and ghc's parser all do a bunch of nasty (imo:) hackery
01:35:20 <mmorrow> quicksilver: like e.g. parsing patterns as expressions initially
01:35:40 <mmorrow> but i think all that's a result of using an LALR parser
01:35:55 <mmorrow> err, LALR(1) (?)
01:36:09 * quicksilver nods
01:36:44 <mmorrow> i only just recently learned how those work btw, it was extremely enlightening (and happy all of a sudden became useable :)
01:37:04 <quicksilver> mmorrow: I am always suprised at all the hard work people put into making parsing fast.
01:37:13 <quicksilver> mmorrow: I find it almost never the bottleneck :)
01:37:19 <quicksilver> mmorrow: it certainly isn't in GHC, for example.
01:38:09 <mmorrow> quicksilver: the thing i like most about happy(or yacc, whatever) is that you statically know about any conflicts/etc
01:38:44 <mmorrow> quicksilver: whereas any non-trivial ReadP parser i've done has been pretty unreliable
01:39:09 <quicksilver> interesting point.
01:39:12 <mmorrow> (unreliable w.r.t. running time and/or random looping)
01:39:42 <quicksilver> I wrote a parser "combinator" library in lua which did left factoring and loop removal
01:39:58 <quicksilver> and built first token lookup tables, too
01:40:02 <mmorrow> ooh, interesting.
01:40:18 <quicksilver> it was never entirely bug-free but it worked well enough to parse lua
01:40:29 <quicksilver> I wanted to do syntax highlighting and tab completion.
01:40:54 <mmorrow> quicksilver: that'd be an interesting haskell lib ==> automatically left-factor/etc a grammar
01:41:13 <mmorrow> (or however you'd say that)
01:41:51 <mmorrow> heh, i was looking at the lua code a while ago and apparently it now uses a hand-written C parser for "speed" :)
01:42:14 <mmorrow> hand-written := not yacc
01:43:51 <soupdragon> you sometimes have to rewrite bits of lua in C for speed
01:44:33 <ivanm> quicksilver: yeah, I"ve noticed that he never answers a question unless it has his name on it...
01:45:16 <mmorrow> that reminds me, here's a plot (used R) of (lua version, lines of code) http://moonpatio.com/lua/lua_loc.png
01:45:48 <mmorrow> iirc i just used find+grep+wc -l for those LOC numbers..
01:45:52 <soupdragon> aww it's going up :(
01:46:43 <ivanm> anyone here noticed that the haskell-mode for emacs has very bad indenting support for {- ... -} style comments?
01:48:19 <quicksilver> hmm. I hadn't. But you're right.
01:48:26 <quicksilver> @seen kuribas
01:48:26 <lambdabot> I saw kuribas leaving #haskell 8d 9h 59m 14s ago, and .
01:48:48 <ivanm> quicksilver: not kuribas' (don't recall how well it worked, since I've since switched back)
01:49:24 * ivanm _really_ wishes kuribas bothered with a ChangeLog + versioning so I can see what new stuff he has and if it's worth trying out a new version
01:49:24 <quicksilver> It also doesn't work.
01:49:37 <quicksilver> I must admit I never use  {- comments
01:49:42 <quicksilver> which is how I noticed.
01:49:45 <ivanm> hmmm...
01:49:46 <quicksilver> never noticed.
01:49:47 <kulakowski> Yeah I just checked, it doesn't do anything for those comments.
01:49:53 <ivanm> quicksilver: how do you do long comments? lots of -- ?
01:49:57 <quicksilver> ivanm: yes.
01:50:04 <quicksilver> ivanm: which is trivially easy with M-;
01:50:12 <ivanm> though the normal mode doesn't work for multi-line haddock style comments using --
01:50:15 <quicksilver> and M-q reflows them.
01:50:19 <ivanm> (it doesn't wrap properly)
01:50:26 <ivanm> quicksilver: even haddock ones?
01:50:39 <quicksilver> dunno. Never used em ;)
01:51:02 <ivanm> quicksilver: you don't have documentation annotations in your code? :o
01:51:09 <ivanm> or do you mainly write apps rather than libs?
01:51:12 <quicksilver> Ah, there is one occasion I use {- -} comments. To make jokes about the monkey combinator.
01:51:24 <quicksilver> ivanm: I've never run haddock in my life. I don't know how it works.
01:51:33 <quicksilver> I just comment things that I feel are worthy of comment.
01:52:20 <ivanm> heh
01:52:31 <ivanm> quicksilver: so you don't have API docs for your code?
01:53:43 <quicksilver> no.
01:54:12 <quicksilver> well, I put comments on the APIs when it's not obvious to me what they do
01:54:20 <quicksilver> but not haddock comments.
01:54:30 <quicksilver> I'm not defending this practice or recommending it.
01:54:37 <quicksilver> I simply have never taken the time to learn haddock.
01:56:04 <quicksilver> I guess it just doesn't solve a problem I have.
01:56:14 <quicksilver> I'm a lazy learner - I learn by need.
01:56:31 <doserj> quicksilver: do other people use your code?
01:57:36 <quicksilver> no.
01:57:44 <anonymou`> hello
01:57:45 <ivanm> heh
01:57:48 <quicksilver> well occasionally I paste thing in hpaste which people are obviously welcome to use.
01:57:57 <quicksilver> and I've emailed code to haskell lists a couple of times.
01:58:01 <quicksilver> but basically, no.
01:58:32 <anonymou`> do someone know the difference between (id $! 1) and (seq 1 1) ?
01:58:54 <quicksilver> in the second case you have two different "1"s.
01:58:58 <quicksilver> that's the only different I can see.
01:59:10 <quicksilver> :t (id $! 1)
01:59:12 <lambdabot> forall a. (Num a) => a
01:59:13 <anonymou`> I'd like to force evaluation of an int in an accumulator in a recursive function
01:59:35 <quicksilver> f blah = blah `seq` recursive call to f
02:07:41 <anonymou`> What is the preprocessor directive to allow bang patterns?
02:07:46 <anonymou`> google is not mm
02:07:52 <anonymou`> my friend today
02:09:04 <soupdragon> anonymou: I don't think there is one
02:09:43 <anonymou`> something you put at the beginning of a source file
02:10:41 <doserj> {-# LANGUAGE BangPatterns #-}
02:12:32 <bsdemon> is there polymorphic function like chr? (Ord a) => a -> Char ?
02:13:01 <bsdemon> there is chr :: Int -> Char, but I need also Integer -> Char
02:13:28 <anonymou`> Thanks doserj!
02:15:26 <quicksilver> bsdemon: chr . fromIntegral
02:15:40 <bsdemon> thanks
02:16:53 <soupdragon> > instance Traversable Can where
02:16:53 <soupdragon> >   traverse f Set       = (|Set|)
02:16:53 <soupdragon> >   traverse f (Pi s t)  = (|Pi (f s) (f t)|)
02:16:57 <lambdabot>   <no location info>: parse error on input `='
02:16:57 <lambdabot>   <no location info>: parse error on input `instance'
02:16:57 <lambdabot>   <no location info>: parse error on input `='
02:17:24 <soupdragon> traverible is always that simple?
02:17:54 <soupdragon> :t fmapDefault
02:17:56 <lambdabot> Not in scope: `fmapDefault'
02:18:02 <soupdragon> @hoogle fmapDefault
02:18:03 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
02:19:05 <Axman6> soupdragon: what's the (|...|) stuff anout?
02:19:07 <Axman6> about*
02:19:28 <soupdragon> like  ... <$> ... <*> ... <*>
02:19:41 <Axman6> how so? :\
02:26:55 <anonymou`> is (eval x = seq x x) equivalent to (!x) ?n #haskell
02:27:42 <gornfan> eval = id
02:27:49 <anonymou`> is (eval x = seq x x) equivalent to (!x) ?
02:28:14 <quicksilver> anonymou`: no.
02:28:26 <quicksilver> anonymou`: eval does nothing.
02:28:40 <helmut> hi. can someone explain why all = foldr (&&) True?
02:29:01 <quicksilver> soupdragon: if you have (| and |) available then yes, traversable is always that simple I believe.
02:29:02 <helmut> I mean why is the semantic right to left and not the other way round?
02:29:22 <quicksilver> helmut: makes it lazy from left to right which is what people expect
02:29:37 <quicksilver> and it's also quicker since lists are designed to be used left to right
02:29:54 <helmut> I don't understand that yet.
02:29:59 <quicksilver> which part?
02:30:10 <anonymou`> I think the difference between foldr and foldl is that one is guaranteed to terminate while the other can work on infinite list
02:30:23 <quicksilver> that's not really the reason here.
02:30:34 <quicksilver> the reason for this choice is not to do with infinite lists.
02:30:47 <anonymou`> (ok, sorry)
02:30:58 <helmut> quicksilver: the part with the lazyness which turns the direction around. I have some idea shining very far...
02:31:23 <quicksilver> > all [False,undefined,undefined,undefined]
02:31:24 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
02:31:26 <helmut> quicksilver: I should probably just compute an example
02:31:42 <quicksilver> :t all
02:31:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:31:51 <quicksilver> @src all
02:31:51 <lambdabot> all p =  and . map p
02:31:58 <quicksilver> I think you meant "and" not "all"
02:32:04 <quicksilver> I always get those two confused, as well :)
02:32:19 <quicksilver> > all [False,undefined,undefined,undefined]
02:32:20 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
02:32:22 <quicksilver> > ndl [False,undefined,undefined,undefined]
02:32:23 <lambdabot>   Not in scope: `ndl'
02:32:25 <quicksilver> > and [False,undefined,undefined,undefined]
02:32:26 <lambdabot>   False
02:32:37 <helmut> ah. when I do all [False, undefined] it gets False && (undefined && True) via foldr. and sind False is False the rest is not evaluated. :-)
02:32:40 <helmut> great
02:32:44 <quicksilver> (sorry for the typo noise) - the point it, it short circuits on the first False.
02:32:53 <quicksilver> if you wrote it with foldl, it would short-circuit on the *last* False
02:32:58 <helmut> yes. I mixed all and and up.
02:33:11 <helmut> quicksilver: thanks!
02:33:12 <quicksilver> > foldl (flip (&&)) True [undefined,undefined,False]
02:33:13 <lambdabot>   False
02:33:24 <quicksilver> but, that's inherently a less efficient thing to do
02:33:37 <quicksilver> because it's got to traverse the list to the end to find that last False
02:33:54 <helmut> so one should almost always use foldr?
02:34:14 <quicksilver> so, given that short-circuiting is good, and we have a choice of which end to do it on, it makes most sense to have left-biased short circuiting.
02:34:30 <quicksilver> foldl' is typically used for strict things, like sum
02:34:47 <helmut> what does strict mean in this context?
02:34:49 <quicksilver> operations which definitely use every member of the list, and summarise to a single value.
02:34:57 <quicksilver> strict = definitely using every item in the list
02:35:01 <quicksilver> (in this context)
02:35:01 <helmut> ah. ok
02:35:19 <quicksilver> foldr is used either for lazy things, or for streaming things
02:35:36 <quicksilver> where streaming means, they produce partial output without needing all their input
02:35:52 <quicksilver> "map" streams, in this sense.
02:36:11 <helmut> does ghc (for instance) internally turn things like foldr (+) 0 into code that will not consume memory linearly with the size of the list being processed?
02:36:36 <helmut> err foldl was actually meant here
02:36:37 <helmut> sorry
02:37:00 <mmorrow> helmut: the strictness analyzer will usually catch this
02:37:07 <helmut> ah. ok.
02:37:23 <quicksilver> and foldl' (with the prime) is explicitly forcing
02:37:30 <quicksilver> so should work even if the strictness analyzer doesn't notice
02:37:31 <mmorrow> helmut: but e.g. in ghci the strictness analyzer isn't run over code that's being compiled to bytecode
02:37:36 <quicksilver> although only for one-level-deep strictness.
02:37:53 <mmorrow> helmut: so any code that relies on the strictness analyzer to work will break in ghci
02:38:07 <meder_> is it me or are amazon styles broken?
02:38:10 <meder_> amazon.com
02:38:12 <helmut> thanks!
02:39:18 <mmorrow> , foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [0..1000000]
02:39:21 <lunabot>  Stack space overflow: current size 8388608 bytes.
02:39:21 <lunabot>  Use `+RTS -Ksize' to increase it.
02:39:23 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..1000000]
02:39:26 <lunabot>  (500000500000,500000500000)
02:40:06 <helmut> this was kind of more enlightening than one lesson haskell course at my university.
02:40:10 <mmorrow> yeah, as quicksilver mentioned the strictness analyzer won't catch that
02:40:42 <helmut> these ! are still foreign to me, but I start to get some idea about them (and how I could use them to make a program work :-)
02:40:53 <mmorrow> they're just "bang patterns"
02:41:20 <mmorrow> , foldl' (\(a,b) c -> let a' = a+c; b' = b+c in a' `seq` b' `seq` (a',b')) (0,0) [0..1000000]
02:41:23 <lunabot>  (500000500000,500000500000)
02:41:24 <mmorrow> is the equivalent
02:41:53 <helmut> uhm. my ghc is broken. :-(
02:42:02 <mmorrow> :set -XBangPatterns
02:42:06 <mmorrow> probably
02:42:16 <helmut> ghc: panic! (the 'impossible' happened)\n  (GHC version 6.10.3 for x86_64-unknown-linux):\n        Prelude.chr: bad argument
02:42:16 <mmorrow> (or put that in you $HOME/.ghci)
02:42:16 <gornfan> , foldl' (\ab c -> case ab of (a,b) -> (a+c,b+c)) (0,0) [0..1000000]
02:42:19 <lunabot>  Stack space overflow: current size 8388608 bytes.
02:42:19 <lunabot>  Use `+RTS -Ksize' to increase it.
02:42:49 <mmorrow> , chr maxBound
02:42:51 <lunabot>  luna: Prelude.chr: bad argument
02:43:29 <mmorrow> , foldl' (\(a,b) c -> case a+c of a -> case b+c of b -> (a,b)) (0,0) [0..1000000]
02:43:32 <lunabot>  Stack space overflow: current size 8388608 bytes.
02:43:32 <lunabot>  Use `+RTS -Ksize' to increase it.
02:43:50 <mmorrow> you need seq
02:44:05 <quicksilver> haskell case is not core case :)
02:44:26 <helmut> what does ghc want to tell me with "the 'impossible' happened"?
02:44:26 <ivanm> and it isn't camel case? :p
02:45:06 <ivanm> helmut: something crashed, when they didn't think it would have crashed there
02:45:19 <ivanm> or they didn't think whatever caused it to crash was possible to happen
02:45:28 <helmut> should I report a bug if that file compiled cleanly before?
02:45:38 <helmut> (to my distributor?)
02:45:52 <Cale> helmut: Well, any 'the impossible happened' is a GHC bug.
02:46:02 <mmorrow> helmut: do you have unicode in your source file?
02:46:25 <mmorrow> helmut: (maybe that's a lexer bug?)
02:46:42 <helmut> mmorrow: at least not intentionally
02:47:00 <mmorrow> i dunno
02:47:09 <helmut> mmorrow: I can give you the source if you want. small file.
02:47:37 <mmorrow> @paste
02:47:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:48:28 <helmut> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7117#a7117
02:49:21 <helmut> mmorrow: this does actually not work for big files, because of a stack space overflow or too many filedescriptors, but since 6.10 it seems to no longer compiler
02:51:01 <bsdemon> How I can convert Char to utf-8 encoded ByteString?
02:51:03 <mmorrow> helmut: it builds for me with 6.10.1 and 6.10.3
02:51:13 <bsdemon> [Char]
02:51:15 <Cale> helmut: How should I run ghc to trigger the error?
02:51:29 <helmut> Cale: I just did ghc textsim.hs
02:51:44 <Cale> It seems to work for me. I'm still on 6.10.3 as well, but 32bit.
02:51:44 <helmut> the ghc6 is from debian sid on amd64
02:52:11 <Cale> Mine is the generic linux binary from the GHC website.
02:52:13 <helmut> looks like an ghc installation bug
02:52:17 <Cale> cale@zaphod:~$ ghc --make helmut
02:52:17 <Cale> [1 of 1] Compiling Main             ( helmut.hs, helmut.o )
02:52:17 <Cale> Linking helmut ...
02:52:17 <Cale> cale@zaphod:~$ ./helmut
02:52:17 <Cale> (0,Empty)
02:52:46 <helmut> uhm.
02:52:52 <helmut> I've got a shorter example.
02:53:54 <kowey> we've got 7 people listed for the Hack Day so far: http://www.haskell.org/haskellwiki/Hac7/Attendees
02:54:06 <helmut> note to self: though shalt always remove old *.hi files created by older ghc releases.
02:54:27 <helmut> i.e. after removing a leftover .hi file there is no problem anymore.
02:54:43 <Cale> ahh
02:54:54 <Cale> yeah, that can create problems
02:55:10 <Cale> I'm surprised that ghc doesn't stick a version number in there :)
02:55:43 <helmut> I'm surprised that it doesn't overwrite .hi files with newer sources.
02:56:16 <quicksilver> it does.
02:56:20 <Cale> Oh? It should update them if the timestamp on the .hs is newer
02:56:28 <quicksilver> or, it should.
02:57:10 <helmut> quicksilver: but does it still take old .hi files into consideration?
02:57:11 <Cale> Though I wonder what happens if a .hi file gets a timestamp accidentally set in the future
03:01:49 <anonymou`> Finally, I went to this solution to my problem: !nextLine = n + 1 in the where clause at the end of my function
03:02:09 <anonymou`> I then use nextLine as a parameter of the recursive call
03:02:40 <bsdemon> is there Natural data type
03:02:50 <ivanm> bsdemon: no
03:02:59 <soupdragon> yes & no
03:03:01 <ivanm> well, depends on what you mean by Natural
03:03:04 <bsdemon> I have a function, that works only with positive integer and I want this func to be total
03:03:06 <ivanm> you can use one of the Data.Word ones
03:03:13 <ivanm> IIRC, they're non-negative
03:03:50 <bsdemon> data Natural, instance Bounded Natural?
03:04:17 <ivanm> bsdemon: see Data.Word
03:04:39 <ivanm> or else newtype Integer or Int and base your operations on that
03:05:03 <bsdemon> ok
03:06:18 <bsdemon> and where I can read about unicode in haskell?
03:06:34 <bsdemon> and about encoding conversions
03:07:01 <bsdemon> It seems that Char can store unicode characters
03:07:11 <bsdemon> or am I wrong?
03:07:31 <quicksilver> you are right.
03:07:35 <quicksilver> Char stores unicode chars.
03:07:53 <quicksilver> but there is no built in way to choose an encoding for input/output.
03:08:02 <quicksilver> there are some packages on hackage for that, though.
03:08:09 <quicksilver> try 'encoding' or 'utf8-string'
03:08:21 <bsdemon> ok, will try, thanks
03:09:49 <bsdemon> are some of that packages will be included in future releases of GHC?
03:10:50 <quicksilver> Data.Text will be included with some future GHC
03:11:01 <quicksilver> and the standard lib is being reworked around unicode IO a bit better
03:11:49 <ivanm> quicksilver: won't 6.12 use utf-8 by default?
03:12:08 <doserj> it will use the current locale
03:13:12 <ivanm> doserj: *nod*
03:13:24 <ivanm> even if the current locale is set to some funky encoding? :p
03:46:09 <helmut> hi again. hoogle seems to not distinguish () and [], so I cannot use it for [a -> a] -> a -> a. Is there a function by that type?
03:47:03 <ClaudiusMaximus> :t foldr ($) id
03:47:05 <lambdabot> forall a. [(a -> a) -> a -> a] -> a -> a
03:47:16 <quicksilver> :t foldr (.) id
03:47:17 <lambdabot> forall a. [a -> a] -> a -> a
03:47:38 <quicksilver> I often think it should have a name.
03:48:21 <Beelsebob> afters?
03:48:36 <helmut> hmm. if we called it foldf then we could write foldr f z xs = foldf (map f xs) z
03:49:14 <soupdragon> I call it compose
03:49:37 <helmut> this wasn't a proposition for a name, just a usage example
03:50:15 <doserj> @type appEndo . mconcat . map Endo
03:50:16 <lambdabot> forall a. [a -> a] -> a -> a
03:50:48 <helmut> *g*
03:53:15 <RayNbow> :t appEndo . foldMap Endo
03:53:17 <lambdabot> Not in scope: `foldMap'
03:53:19 <RayNbow> :t appEndo . Data.Foldable.foldMap Endo
03:53:21 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
03:59:28 <ivanm> is there a ShowS version of unwords?
04:00:02 <quicksilver> pretty sure not
04:00:16 <ivanm> OK, then this showList will have to use ++ *shrug*
04:06:20 <EvilTerran> ah, it's show-related, the usage of it's probably IO-bound
04:09:56 <ivanm> is there a maybe equivalent for Bool? or should I just define if' ?
04:11:24 <Beelsebob> if' is it
04:11:40 * Beelsebob wonders why no one has put that in the prelude yet
04:11:41 <Beelsebob> >.<
04:12:16 * EvilTerran would reverse the arguments and call it "bool"
04:12:24 <ivanm> or that
04:12:27 * Beelsebob nods
04:13:53 * doserj would call it (?)
04:14:59 <mjrosenb> doserj: needs to take a list
04:15:04 <lilac> @type maybe ?no (const ?yes) . guard
04:15:06 <lambdabot> forall a. (?yes::a, ?no::a) => Bool -> a
04:15:08 <mjrosenb> doserj: so you can have foo ? baz : bar
04:15:10 <Phillemann> The paper about concurrent haskell mentions a CVar to model a producer/consumer situation. I cannot find this via hoogle. It it implemented somewhere or do I copy and paste it from the paper?
04:15:23 <doserj> mjrosenb: forr ? baz $ bar
04:15:33 <soupdragon> nooooo
04:15:33 * lilac likes foo <?> bar <:> baz
04:16:01 <EvilTerran> False ?? x = empty; True ?? x = pure x; Nothing ?! x = x; Just x ?! _ = x
04:16:26 <soupdragon> foo <?> bar <:> baz looks to me like  foo :: m Bool   bar, baz :: m a
04:16:35 <EvilTerran> (??) :: Alternative f => Bool -> a -> f a; (?!) :: Maybe a -> a -> a
04:16:37 <lilac> where (<?>) :: MonadPlus m => Bool -> a -> m a; (<:>) :: Maybe a -> a -> a
04:16:39 <mjrosenb> :t mapMaybe
04:16:40 <Saizan> Phillemann: maybe that's a MVar now?
04:16:40 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
04:16:51 * EvilTerran seems to have the same idea as lilac, then
04:16:59 * mjrosenb likes the name mapPartial better
04:17:29 * lilac prefers EvilTerran's Alternative-based formulation
04:17:38 <quicksilver> Phillemann: I think it is different from MVar but was ultimately replaced by MVar.
04:17:57 <lilac> i prefer <?> and <:> to ?? and ?!, but not enormously
04:18:21 <Phillemann> Ahhh, I just saw that putting a value in an mvar twice blocks instead of throwing an exception.
04:18:26 <pozic> Is there a way to tell CPP that I do not want to rewrite FooBar.head to FooBar.(\xs -> case xs of [] -> ...), but I do want to rewrite other non-qualified uses?
04:18:53 <Phillemann> Then MVar can be used instead of CVar, of course.
04:19:03 <quicksilver> I think not. CPP is a very simple minded token replacer based on C lexical syntax.
04:19:18 <soupdragon> dont you see what I mean lilac?
04:19:39 <lilac> pozic: you could use a RULES pragma to do the rewriting I think
04:20:05 <quicksilver> I agree with soupdragon.
04:20:09 <lilac> soupdragon: yeah, i do
04:20:21 <quicksilver> I'm conditioned to see <..> type combinators as working with Monads or similar.
04:20:31 <quicksilver> I prefer EvilTerran's names
04:20:35 <lilac> <?> does work with Monads or similar
04:20:47 <lilac> (but only on the RHS, like <$>)
04:20:52 <quicksilver> yes, but <:> doesnt, and <?> doesn't in the way I expect.
04:21:02 <soupdragon> I'm not being mean just saying what it looks like to me
04:21:04 <quicksilver> feel free to file a bug against my expectations ;)
04:22:20 <lilac> i think it's a reasonable point (at least for <:>). but ?? and ?! look a bit too much like cartoon punctuation rather than operators :)
04:22:23 * EvilTerran would be happy with other names, ?? and ?! are just the first that came to mind
04:22:47 <quicksilver> I also think <> are overused.
04:22:51 <EvilTerran> (p |?| x |:| y)? (p -?- x -:- y)?
04:22:51 <lilac> foo?? bar?! baz!!1
04:22:56 <quicksilver> It is permitted to have customer operators which don't use them ;)
04:23:05 <quicksilver> *custom
04:23:07 <quicksilver> (!)
04:23:17 <lilac> EvilTerran: are you allowed | in operators?
04:23:32 <lilac> > let (|?|) = (+) in 1 |?| 1
04:23:34 <lambdabot>   2
04:23:35 <EvilTerran> yes
04:23:37 <lilac> cool
04:23:41 <EvilTerran> see <|>
04:23:46 <EvilTerran> ||
04:23:48 <EvilTerran> etc :P
04:24:17 <lilac> of course, semantically a guard can't have an operator before or after it anyway, so it's unambiguous
04:24:23 <lilac> d'uh :)
04:25:49 <soupdragon> WTP
04:25:51 <soupdragon> WTF
04:26:08 <Dae> did gravity stop working in your city too?
04:26:28 <soupdragon> it's weirder than that
04:26:34 <lilac> i have a thunderstorm out of one window and blue skies out of the other, can anyone repro this bug?
04:27:50 <Dae> soupdragon: you found out that the GHC.Optimize  depends on GHC.dons?
04:28:32 <Dae> lilac: it's fixed in the repo version
04:28:47 <Dae> just dl and recompile
04:29:10 <lilac> Dae: thanks. though the problem's resolved itself now and the thunderstorm is on both sides :)
04:29:23 <lilac> i guess it was just a race condition
04:32:30 <benmachine> so what happens if you define an entirely-symbol function (that would normally be infix) of type a -> b (i.e. accepting only one argument)
04:32:55 <benmachine> I assume when you have more than two arguments it's just like a normal two-argument operator except it returns a function
04:33:12 <benmachine> but that's as far as my assumptions extend
04:33:37 <soupdragon> > let ($) = reverse in ("foo"$)
04:33:39 <lambdabot>   "oof"
04:33:39 <soupdragon> > let ($) = reverse in ($"foo")
04:33:41 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
04:34:32 <EvilTerran> > let (???) = (,,) in ("foo" ??? "bar") "baz"
04:34:33 <lambdabot>   ("foo","bar","baz")
04:34:43 <benmachine> > let ($) = reverse in "foo" $
04:34:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:34:46 <EvilTerran> > let (???) = Just in ("foo" ???)
04:34:47 <lambdabot>   Just "foo"
04:34:52 <soupdragon> > let ($) = reverse in ($) "foo"
04:34:53 <lambdabot>   "oof"
04:35:11 <benmachine> so basically a unary infix operator can only be used in a section?
04:35:14 <benmachine> which isn't really a section
04:35:29 <benmachine> I suppose you could do something like this
04:35:55 <benmachine> > let (!) = id in (+) id 2 3
04:35:56 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
04:35:56 <lambdabot>    arising from the literal `2' at <...
04:35:57 <benmachine> er
04:36:00 <benmachine> > let (!) = id in (+) ! 2 3
04:36:02 <lambdabot>   Add a type signature
04:36:06 <benmachine> bah
04:36:19 <benmachine> > let (!) = id in const ! 2 3
04:36:20 <lambdabot>   Add a type signature
04:36:27 <benmachine> maybe I don't want to :(
04:36:40 <EvilTerran> benmachine, according to the report, sections have to be at least binary functions
04:36:48 <soupdragon> > let (!) = id in (+) ! 2 3
04:36:50 <lambdabot>   Add a type signature
04:36:50 <soupdragon> > let (!) = id in (+) (!) 2 3
04:36:52 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
04:36:52 <lambdabot>    arising from the literal `2' at <...
04:37:03 <soupdragon> > let (!) = id in ((+) ! 2) 3
04:37:05 <lambdabot>   5
04:37:12 <EvilTerran> benmachine, and allowing (foo ???) where ??? is unary is a ghc quirk, iirc
04:37:34 <EvilTerran> > flip flip 2 (+) 3
04:37:36 <lambdabot>   5
04:37:43 <benmachine> EvilTerran: ah okay, so unary infix functions can't really be used at all?
04:37:52 <benmachine> not that the idea makes any sense in the first place
04:37:56 <benmachine> just curious how it was handle
04:37:57 <benmachine> d
04:38:23 <quicksilver> unary infix is a bit like postfix
04:38:43 <quicksilver> > let (!) = negate in (5!)
04:38:44 <lambdabot>   -5
04:38:51 <quicksilver> but it's a GHC extension to permit that.
04:38:55 <quicksilver> it's illegal h98 I think.
04:38:59 <benmachine> and you need the brackets
04:39:54 <quicksilver> depends what you think unary means ;)
04:40:01 <quicksilver> > let (!) = (reverse.) in show ! "hi"
04:40:02 <lambdabot>   "\"ih\""
04:41:02 <benmachine> interesting
04:41:16 <benmachine> is that legal by the standard?
04:41:31 <quicksilver> I don't know :)
04:41:46 <quicksilver> I imagine it is, since (!) typechecks as binary.
04:41:57 <benmachine> @type (reverse.)
04:41:59 <lambdabot> forall a a1. (a1 -> [a]) -> a1 -> [a]
04:42:04 <Phillemann> Is there something more elegant to apply "a -> IO ()" to a list of values and then "return ()" as the result than "foldM_ (\_ e -> action e) () values"?
04:42:10 <benmachine> oh so it does
04:42:22 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
04:42:42 <twanvl> ?type mapM_
04:42:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:42:47 <quicksilver> Phillemann: mapM_ action values
04:43:03 <Phillemann> Ah, great. Thanks.
04:51:14 <shachaf> Phillemann: Or perhaps forM_.
04:51:28 <shachaf> (Same thing, just flipped.)
04:51:53 <Phillemann> Doesn't matter here, the callback function is in another place, anyway.
04:52:23 <kulakowski> Not exactly a haskell question, but just read the stuff about postfix notation and wondered, what is notation like ||x|| for a norm called? Outfix?
04:52:31 <desp> Anyone else using GHC from MacPorts?
04:53:04 <Phillemann> kulakowski: I once read about "confix parsers" which parse those kinds of expressions.
04:54:01 <shachaf> kulakowski: http://interval.sourceforge.net/interval/scheme/giaeval/opparse.scm (an arbitrary link) seems to call it that.
04:54:37 <desp> Upgrading my MacPorts GHC seems to have broken my gtk2hs.
04:54:39 <desp> Does anyone else recognize this problem?
04:55:21 <Cale> kulakowski: I've heard it called 'surroundfix'
04:55:28 <EvilTerran> kulakowski, i've heard it called "outerfix" or "bracketfix"
04:55:28 <desp> I tried reinstalling gtk2hs, and now GHC is once again able to find the Gtk modules, but my gtk2hs-using program does not show any windows now.
04:55:32 <kulakowski> Ok thanks...googling it (confix) also finds things calling it circumfix if anyone cares
04:55:32 <EvilTerran> there doesn't seem to be a standard name for it
04:57:26 <kulakowski> Having it in Haskell would be sometimes be nice, if it good even be parsable, but I'm sure there's no room for the syntax for it
05:00:50 <Jacolyte> help? http://dpaste.com/68183/
05:02:59 <Jacolyte> err, sorry, that read should be a show instead.
05:03:22 <Saizan> there are two problems
05:03:28 <Saizan> ?type head
05:03:30 <lambdabot> forall a. [a] -> a
05:03:39 <Saizan> head works on lists, not on tuples
05:03:48 <EvilTerran> kulakowski, i've thought about that sort of thing before; i figured there'd be room in the syntax for things like [|| ... ||]
05:03:48 <Saizan> for tuples you've to use fst
05:03:53 <Saizan> ?ty fst
05:03:55 <lambdabot> forall a b. (a, b) -> a
05:04:11 <Saizan> also, (!!) starts counting from 0
05:04:27 <Saizan> so the second element is (tuples !! 1)
05:04:34 <benmachine> > [1, 2, 3] !! 2
05:04:35 <lambdabot>   3
05:05:17 <Jacolyte> Saizan: thank you very much, good sir
05:05:19 <Jacolyte> :)
05:05:34 <EvilTerran> kulakowski, in that you can't have [ followed by an operator, or ] preceeded by one, in h98
05:07:01 <EvilTerran> (eg:) [++ it ++] before after = before ++ it ++ after; ... foldr [++", "++] ...
05:07:45 <kulakowski> yeah I actually had started thinking about what syntax might work
05:09:52 <Jacolyte> one last question: is this the correct 'function definition'? (not sure if it's called that) exerciseThree :: [(a,b)] -> Int
05:10:06 <soupdragon> function definition is good
05:10:24 <Phillemann> Uhm, so to catch a specific exception I have to call catch ... (\(e :: SpecificExceptionType) -> ...), right? I ask because ghc complains it needs ScopedTypeVariables for that.
05:11:22 <Jacolyte> okay, so lastly, it was my intent that [(a,b)] would represent a list of tuples, but i get errors using this rather than letting haskell guess the types of the arguments.
05:12:45 <Laney> Is, or can there be, a way of subscribing to the changes made to the platform?
05:12:51 <Laney> RSS feed of darcs commits, for example
05:16:00 <Cale> Jacolyte: that means a list of pairs whose parts can have any types at all
05:16:19 <Cale> Jacolyte: (as opposed to some specific types)
05:17:13 <Cale> Jacolyte: Basically, the only lists of that type are things like [], [undefined], [(undefined, undefined)], [undefined, undefined, (undefined, undefined)] and so on.
05:18:09 <Cale> er
05:18:12 <Saizan> Jacolyte: that part is called "type signature" and since you say the result is Int, and you use the first element of one of the tuples as result, then the input list has to be [(Int,b)]
05:18:18 <lilac> Cale: did you see a phantom forall?
05:18:39 <Cale> oh, oops, I didn't finish reading the type
05:18:45 * Cale should sleep
05:18:51 <Cale> I've been up all night :P
05:18:53 <kulakowski> I had though something like {|xyz foo xyz|} where letters could be anything legal in an operator
05:19:07 <lilac> Cale: don't have nightmares with flying lambdas
05:19:13 <Cale> Oh, I just didn't see the first message at first, that's what it was
05:20:03 <Badger> \ . o O (*flap* *flap*)
05:20:35 <Saizan> s/flap/flip/g
05:20:37 <Cale> If [(a,b)] is the entire type signature for a list, you'll have the problem I described :)
05:20:54 <lilac> > intercalate " " $ replicate 12 "lambda" ++ replicate 2 "mushroom"
05:20:57 <lambdabot>   "lambda lambda lambda lambda lambda lambda lambda lambda lambda lambda lamb...
05:23:09 <Cale> Jacolyte: So, the real answer is that it shouldn't be Int
05:23:40 <Cale> Jacolyte: rather, exerciseThree :: [(a,b)] -> a, given the description in your paste
05:25:03 <Cale> There are other problems with that code: read is a function for turning a String into something else, so it can't be the right thing there. You probably want show. (or replace putStrLn and show with print)
05:25:12 <Kashyap> I am trying to write a graphics library in Haskell - basically a diagraming utility .... I started out with the line drawing algorithm ... line :: Point ->  Point -> [Point]
05:25:17 <Cale> and head is only for lists, not tuples
05:26:23 <Kashyap> Now the problem I am facing is that depending on whether (x2-x1) > (y2-y1) ... the we loop with the x values or y values
05:27:01 <Kashyap> Basically the same code gets repeated varying X or varying Y depending on whether dx is greater or dy is greater
05:27:35 <lilac> Kashyap: you might want to write the code for one case, then in the other case apply swap to the arguments, and map swap to the results, where swap (a, b) = (b, a)
05:27:40 <siorai> why does the mac GHC binary require xcode??
05:28:50 <quicksilver> siorai: it general development tools
05:28:50 <lilac> @type snd &&& fst
05:28:52 <Kashyap> okay ... I think I am beginning to get an idea .... Thanks Lilac
05:28:52 <lambdabot> forall a c. (a, c) -> (c, a)
05:28:59 <quicksilver> siorai: (which apple bundle with xcode)
05:29:16 <siorai> quicksilver: Oh, I suppose there's gcc for mac without it, for example
05:29:18 <siorai> -_-
05:29:31 <Badger> @src (&&&)
05:29:32 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
05:29:40 <Badger> yarr.
05:29:49 <lilac> @arr (&&&)
05:29:50 <lambdabot> Ahoy mateys
05:29:52 <quicksilver> siorai: gcc, linker, ar, that kind of thing.
05:30:07 <siorai> so irritating, I forgot about that
05:30:11 <quicksilver> siorai: modern ghc's don't actually need gcc itself, but some parts of the binutils toolchain are essential.
05:30:15 <Badger> @src arr
05:30:16 <lambdabot> Source not found. That's something I cannot allow to happen.
05:30:22 <lilac> @type arr
05:30:22 <siorai> I was about ot be all irate, now I'm just irate with apple
05:30:24 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
05:30:27 <siorai> xcode is such a MASSIVE installation
05:30:34 <quicksilver> true
05:30:41 <quicksilver> but a mac without it is just a paperweight
05:30:49 <lilac> Badger: (->) is an instance of Arrow, where arr = id
05:31:03 <quicksilver> an expensive but attractive paperweight.
05:31:08 <Cale> A paperweight with a beautiful screensaver
05:31:31 <Badger> Damn you Control.Arrow
05:31:42 <lilac> Badger: for (->), (>>>) is flip (.), and (f *** g) (a, b) = (f a, g b)
05:32:00 <kulakowski> I'm curious, how big is MASSIVE?
05:32:22 <lilac> Badger: so f &&& g = (flip .) (\b -> (b, b)) (\(a, b) -> (f a, g b)) = \b -> (f b, g b)
05:32:34 <quicksilver> kulakowski: the .dmg is about 1Gig IIRC
05:32:59 <lilac> @type (&&&) :: (a -> b) -> (a -> c) -> (a -> (b, c))
05:33:01 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
05:33:09 <lilac> @@ @djinn @type (&&&) :: (a -> b) -> (a -> c) -> (a -> (b, c))
05:33:11 <lambdabot>  f a b c = (a c, b c)
05:33:19 <quicksilver> ///Developer on this mac is 2G
05:33:31 <kulakowski> Oh I was gonna guess like 5. HUGE would have been 1, but MASSIVE just seems bigger.
05:33:52 <quicksilver> you should apply to make those SI units.
05:33:58 <Badger> lilac: dear lord. :P
05:34:04 <desp> I have a problem with linking a static library containing a main() function into my Haskell program.  The library's main() is getting called instead of my Haskell main().
05:34:20 <kulakowski> I'll make alteratives for the stupid kibi- ones
05:34:27 <lilac> Badger: for (->) the Control.Arrow stuff is pretty useful (esp. for working on pairs)
05:34:29 <desp> I am passing -lHSrts to GHC before -lmylibrary.
05:34:39 <lilac> @type first ?f
05:34:41 <lambdabot> forall (a :: * -> * -> *) b c d. (?f::a b c, Arrow a) => a (b, d) (c, d)
05:35:09 <lilac> @type first :: (a -> b) -> (a,c) -> (b,c)
05:35:11 <lambdabot> forall a b c. (a -> b) -> (a, c) -> (b, c)
05:36:17 <lilac> @type head [second, fmap]
05:36:19 <lambdabot> forall b c d. (b -> c) -> (d, b) -> (d, c)
05:36:52 <Manuel35465> Hi, I'm new to Scheme and started to read http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/First_Steps ... the first Programm doesnt work it says "erstespr: Prelude.(!!): index too large". can someone help me plz?
05:37:01 <EvilTerran> ?type second `asTypeOf` fmap
05:37:02 <lambdabot> forall b c d. (b -> c) -> (d, b) -> (d, c)
05:37:11 <EvilTerran> Manuel35465, uh... this is the Haskell channel, not the Scheme channel
05:37:33 <Cale> Manuel35465: That program doesn't check that you actually give it enough commandline arguments
05:37:38 <Manuel35465> the book ist about writing a scheme interpreter in haskell
05:37:42 <Cale> Manuel35465: But it expects one
05:38:03 <Badger> @src asTypeOf
05:38:04 <lambdabot> asTypeOf = const
05:38:11 <Cale> Manuel35465: args !! 0 would be the first element of the list args. If args is empty, then it's an error.
05:38:15 <Manuel35465> ah i understand, thx :)
05:38:33 <Manuel35465> i expected a prompt...
05:39:03 <Cale> Yeah, kind of a strange choice of first program.
05:39:07 <lilac> EvilTerran: Write Yourself a Scheme is a Haskell tutorial :)
05:39:22 <Cale> Rather than using getLine there
05:39:45 * lilac re-takes Reading What Others Have Already Written 101
05:39:52 <Badger> Learn Yourself a Haskell, Write Yourself a Scheme! (For Great Good!)
05:40:05 <lilac> Take off every zip!
05:40:21 * Cale considers coffee
05:40:26 <Cale> hmmm
05:40:33 <lilac> Cale: I think you mistyped 'sleep'?
05:40:41 <Cale> It's one or the other.
05:41:10 <desp> Has anyone tried linking a static library ocntaining a main() function with their Haskell program?
05:41:57 <lilac> desp: i don't imagine the linker would invite you to its summer parties if you did that
05:42:39 <desp> lilac: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html says in 4.10.7 to use -lHSrts and the linker should be happy.
05:42:43 <desp> But it's not.
05:43:40 <lilac> desp: is it complaining of multiple definitions of main?
05:43:46 <quicksilver> desp: I would have said a library exporting a symbol called 'main' was pretty broken. But I appreciate this doesn't help you.
05:44:00 <desp> lilac: no, it's using the main() from the library.
05:44:24 <Phillemann> Is there maybe a ghc extension so make this possible: data Record = Record { value :: Int }; valueSynonyme = value; Record 1337 { valueSynonyme = 31337 };? I have an association list (Name,Value) which should associate strings to the record elements.
05:44:25 <desp> quicksilver: :)
05:44:31 * lilac guesses ghc uses -z muldefs then :-/
05:45:05 <quicksilver> Phillemann: No.
05:45:24 <quicksilver> Phillemann: Why are you looking for a GHC extension though ? Why not just use a Data.Map from Names to Values?
05:45:44 <quicksilver> or if you're looking for a way to make field names first class, try lenses / functional references
05:46:10 <Phillemann> You mean a map instead of the Record?
05:46:46 <lilac> Phillemann: why do you want to rename the field?
05:47:47 <Phillemann> lilac: I don't want to rename the field. I've got a string containing "fieldvaluename: fieldvaluevalue" which I want to apply to a record.
05:48:11 <Phillemann> Like Record { name :: String,weight :: Int }; and a string "name: foobar\nweight:1337"
05:48:55 <lilac> Phillemann: do you want a function :: String -> Maybe Record?
05:50:28 <Phillemann> Not "Maybe". I want a function which converts pairs of type (String,String) to functions of type "Record -> Record", basically
05:50:31 <lilac> desp: (yes, i know, it's clutching at straws, but) have you tried putting the -l's the other way around from the way the doc suggests?
05:51:09 <lilac> Phillemann: can you give an example of the pair of strings and the function you'd want generated?
05:54:40 <Phillemann> lilac: Well, my current approach is as follows: data Record = Record { name :: String, ... }; list = [("name",\r v -> r { name = v }), ...]; apply :: [(String,String)] -> Record -> Record; apply p r = for each pair lookup fst list; apply snd to r
05:55:22 <Phillemann> Which isn't too bad I suppose
05:56:17 <quicksilver> Phillemann: yes, the boilerplate is a pain. record fields being selectors only isn't very clever :(
05:57:21 <desp> lilac: I've decided to rip the main() from the libraries.
05:57:23 <desp> :)
05:57:23 <lilac> can you generate the boilerplate with TH?
05:57:28 <lilac> hehe :)
05:59:11 <quicksilver> yes, you can.
05:59:21 <quicksilver> IIRC, Data.Accessor has some TH for this.
05:59:29 <quicksilver> although there were things I didn't like about D.A's design choices.
05:59:32 <quicksilver> it's got better, though.
05:59:34 <lilac> desp: i suppose it's /possible/ that 'main' isn't in libHSrts in your GHC for some reason.
05:59:50 <lilac> @index Data.Accessor
05:59:50 <lambdabot> bzzt
06:00:08 <lilac> @hackage data-accessor
06:00:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
06:00:31 <desp> lilac: since I'm doing this just for fun, I don't care either way, as long as it works in the end.  And now it does, after complicating my build process a little. :)
06:04:43 <uzytkownik> How to display a specific patch in darcs?
06:10:05 <Phillemann> @hoogle isPrefixOf
06:10:06 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
06:10:06 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
06:10:06 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
06:10:42 <yitz> uzytkownik: ask on #darcs
06:11:43 <yitz> uzytkownik: or the darcs users mailing list
06:12:13 <uzytkownik> yitz: I choose the first option. Thanks. And sorry for polluting #haskell.
06:12:43 <yitz> uzytkownik: not polluting at all. it's just not a simple answer, so makes more sense to discuss it there. good luck!
06:25:05 <uzytkownik> @hoogle (a -> m b) -> Maybe a -> m (Maybe b)
06:25:06 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
06:25:06 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:25:06 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
06:26:35 <uzytkownik> @hoogle (a -> m b) ->n a -> m (n b)
06:26:35 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:26:35 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
06:26:35 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
06:27:03 <virn> hi
06:44:46 <hzap> total silence in #haskell :D
06:46:39 <Vanadium> @src evaluate
06:46:39 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
06:47:04 <Vanadium> creepy.
06:47:51 <Vanadium> Why is that not like (return $!)?
06:50:43 <twanvl> > (return $! undefined) `seq` ()
06:50:45 <lambdabot>   Add a type signature
06:50:59 <twanvl> > (return $! undefined :: IO ()) `seq` ()
06:51:01 <lambdabot>   * Exception: Prelude.undefined
06:51:10 <twanvl> > (evaluate undefined :: IO ()) `seq` ()
06:51:12 <lambdabot>   Not in scope: `evaluate'
06:57:28 <EvilTerran> Vanadium, i think evaluate is stricter than (return $!)
06:58:45 <Saizan> uhm, i'd say the opposite
06:58:52 <EvilTerran> ah, yeah, it's the opposite
06:58:53 <Saizan> evaluate undefined /= undefined
06:59:11 <quicksilver> I think evaluate is subtle and should not be used unless you know exactly what it does and why you want it.
06:59:20 <EvilTerran> i was looking at that and thinking "that's not quite right"
06:59:41 <quicksilver> I recommend using `seq`, and using $! as long you appreciate it's just shorthand for seq and not anything more magic :)
06:59:56 <Cale> This new 'cheddar bay' kernel exploit sounds interesting :)
07:00:17 <EvilTerran> Vanadium, the point is that (evaluate x) forces x exactly when it's run as part of the main IO action
07:00:17 <EvilTerran> while (return $! x) will evaluate x at the whim of the evaluation order
07:00:53 <Saizan> uhm, that's not true either, iirc
07:01:25 <Saizan> ?type evaluate
07:01:27 <lambdabot> Not in scope: `evaluate'
07:02:24 <Cale> http://www.youtube.com/watch?v=UdkpJ13e6Z0&feature=response_watch :)
07:02:52 <Cale> (found from source linked to from http://lists.grok.org.uk/pipermail/full-disclosure/2009-July/069714.html)
07:04:05 <Saizan> evaluate is still strict on its argument, according to my #ghc logs, so it could be evaluated earlier
07:05:56 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2008-May/042367.html
07:06:16 <quicksilver> Saizan: ^^ explanation that neither the implementor, nor the documentors, understand what evaluate does.
07:06:20 <quicksilver> so I certainly dont' ;)
07:06:43 <EvilTerran> Saizan, how is it strict in its argument? the only use of its argument is wrapped in "IO $ \s ->"
07:07:17 <EvilTerran> and hence won't be evaluated until we have a value for s, ie during running of the IO action, surely?
07:08:56 <Saizan> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
07:10:25 <LeoD> does HOpenGL support windows?
07:10:31 <Saizan> uhm, i guess after you give the RealWorld# to main that argument gets filled and the strictness analyzer sees that a is used
07:10:40 <Cale> evaluate x is an IO action which when executed causes x to be evaluated into WHNF.
07:11:00 <quicksilver> LeoD: yes.
07:11:34 <Cale> I'm not sure there's an equational way to actually express that.
07:11:40 <quicksilver> whereas return $! x is an IO action which when merely *evaluated* (not executed) causes x to be put into WHNF.
07:11:51 <Cale> right
07:12:05 <Saizan> Cale: right, but that might also cause the optimizer to evaluate x even before
07:12:11 <quicksilver> of course, evaluation preceeds execution
07:12:30 <quicksilver> so certainly if you execute return $! x you do evaluate it first.
07:12:45 <LeoD> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7122#a7122 this is what i'm getting trying to build it
07:13:02 <Cale> Saizan: hmm... how much before?
07:13:43 <quicksilver> LeoD: "checking for gcc... no"
07:13:46 <quicksilver> LeoD: that looks bad.
07:13:47 <LeoD> ohh
07:14:23 <quicksilver> I'm not going to be able to help you much since I've never used windows, but I think you ned mingw or msys or one of those things.
07:14:32 <LeoD> yea i think so too
07:14:46 <Cale> That mailing list post makes use of the monad laws in the same breath as $!... I'm not sure that's actually sane.
07:14:55 <quicksilver> there used to be GHC binaries which included a prebuilt opengl package
07:15:04 <quicksilver> isn't there a window binary of the haskell platform, for example?
07:15:18 <ManateeLazyCat> I want to get intersect element in two list just from END direction,  don't including front or middle, someone can help me write this function "intersectFromEnd :: [a] -> [a] -> [a]", thanks!
07:15:31 <quicksilver> Cale: it's questionable whether it makes sense to use laws and seq together
07:15:47 <quicksilver> Cale: at least, you need so have some clear idea of what you think the "=" sign in your laws is supposed to mean.
07:16:12 <quicksilver> Cale: similarly, to give an equational definition of evaluate for IO, you need some notion of observational equality for IO actions, I imagine.
07:17:31 * ManateeLazyCat pasted "intersectFromEnd" at http://paste2.org/get/329893
07:17:34 <ManateeLazyCat> Above code can't work.
07:18:09 <quicksilver> ManateeLazyCat: because "last xs" is a single item
07:18:15 <quicksilver> ManateeLazyCat: so you can't use it on the right of ++
07:18:29 <quicksilver> try : intersectFromEnd (init xs) (init ys) ++ [last xs]
07:18:44 <ehird> And the FUD-o-matic chugs along some more: http://groups.google.com/group/comp.lang.lisp/msg/8bc0c2a94cec3226?hl=en
07:19:25 <ManateeLazyCat> quicksilver: Thanks i try.
07:19:46 <quicksilver> ehird: are we supposed to be surprised? :)
07:19:53 <ehird> quicksilver: Terribly. :)
07:20:52 * ManateeLazyCat pasted "intersectFromEnd" at http://paste2.org/get/329895
07:20:57 <ManateeLazyCat> quicksilver: Above code works
07:21:05 <ManateeLazyCat> quicksilver: Thanks a lot! :)
07:21:06 <ehird> Wow, Harrop owns http://haskell-news.blogspot.com/. It's like he's playing social limbo.
07:21:56 <ehird> "According to those results, users are currently running around 180 registered copies of xmonad, making it the second most popular program ever written in Haskell!"
07:22:05 <ehird> …
07:22:11 <quicksilver> yes, jdh is an interesting phenomenon.
07:22:11 <ehird> He doesn't even try to hide it, does he?
07:22:37 <Saizan> http://pastebin.com/mc28b7ac <- the trickyness of both unsafeInterleaveIO and evaluate in a single paste :)
07:22:45 <quicksilver> although having said he is interseting I will now appear to contradict myself by saying I am bored of him ;)
07:22:57 <FunctorSalad> I'll play devil's advocate... why is that statement wrong?
07:23:03 * ManateeLazyCat pasted "intersectFromEnd function clearer version" at http://paste2.org/get/329897
07:23:09 <ManateeLazyCat> Above is clearer version
07:23:18 <Saizan> "registered copies"?
07:23:18 <FunctorSalad> (ehird's quotation)
07:23:25 <FunctorSalad> oh
07:23:30 <ehird> FunctorSalad: i'm not sure where i'd ever begin to start.
07:23:34 <ehird> *even
07:23:40 <ivanm> yay! all the graphviz attributes are done!
07:23:42 <ivanm> (I hope...)
07:23:54 <FunctorSalad> I read "done" as "gone" there ;)
07:24:23 <quicksilver> Saizan: debian package popularity contest, perhaps?
07:24:33 <ehird> http://haskell-news.blogspot.com/2009/03/xmonad-popularity.html
07:24:37 <quicksilver> ManateeLazyCat: I definitely think that's easier to read, yes.
07:24:59 <ehird> ManateeLazyCat: your first condition could be
07:25:03 <ehird> intersectFromEnd [] [] = []
07:25:17 <ManateeLazyCat> ehird: Yep, that's better, thanks!
07:25:22 <ehird> :)
07:26:37 * ManateeLazyCat pasted "Better version for `intersectFromEnd` function" at http://paste2.org/get/329902
07:27:08 <ManateeLazyCat> Thanks all for help! :)
07:27:49 <FunctorSalad> uhm, his own (Jan 2008) list has several packages with more than 180 pop-contest downloads
07:28:10 <FunctorSalad> I must be missing some joke
07:29:50 <Cale> FunctorSalad: Is it possible that the joke you're missing is Jon Harrop himself?
07:30:02 <Cale> ;)
07:31:34 <Cale> (Okay, that's a bit mean, but the guy in general seems to have a pretty funny way of going about things.)
07:31:55 <FunctorSalad> I've heard the name but not much mroe
07:31:57 <FunctorSalad> *more
07:32:55 <SamB> Cale: how do you know he doesn't intend to be a joke?
07:33:03 <Cale> SamB: That's true, I don't.
07:33:19 <SamB> I think I should like to be one
07:33:35 <SamB> I would be truly horrible, I hope ;-)
07:34:28 <quicksilver> SamB: well, it's in the way they tell you.
07:34:36 <quicksilver> SamB: well told, you were funny the first couple of times.
07:35:09 <pozic> How can I run a monadic action received as an argument in a function in two different monads?
07:36:07 <lilac> pozic: what's the type of the argument?
07:36:36 <quicksilver> pozic: if you mean it's an action capable of running in different monads
07:36:42 <quicksilver> then that is higher-rank polymorphism
07:36:56 <quicksilver> you need to (a) turn the extension on and (b) give the type of the parameter explicitly.
07:37:29 <pozic> lilac: FooT Bar () is what gets derived if I only use it in one context.
07:38:04 * quicksilver imagines you want (forall m . MonadFoo Bar m => m ()) as the argument, then
07:38:07 <quicksilver> or something similar.
07:38:14 <FunctorSalad> why is "forall r. (A -> r) -> (B -> r) -> r" not a strong sum in haskell? (this paper claims that having fix breaks that encoding of sums)
07:38:24 <FunctorSalad> (sum of A and B)
07:38:42 <Phillemann> I don't really understand the error in: "foldr (flip ($)) value values"; where values is of type '[a -> a]' and value is of type 'a'
07:38:47 <pozic> quicksilver: And if I don't have MonadFoo it is not going to work?
07:38:54 <Phillemann> It says: Occurs check: cannot construct the infinite type: b = a -> b
07:39:04 <quicksilver> pozic: how can you have an action which can run in two different monads?
07:39:24 <quicksilver> pozic: rhetorical question. Answer - by having a type which represents actions which can run in both those monads.
07:39:30 <quicksilver> MonadFoo m => is one way to do that.
07:39:37 <quicksilver> it's not the only way.
07:39:55 <pozic> quicksilver: another way would be a sum-type?
07:40:01 <FunctorSalad> Phillemann: drop the flip?
07:40:03 <Phillemann> Ah, foldl solves this. Hm.
07:40:05 * ManateeLazyCat pasted "Manatee.Utils" at http://paste2.org/get/329913
07:40:05 <ManateeLazyCat> Above is utils function in my project, hope it will help some guy. :)
07:40:06 <quicksilver> yes.
07:40:28 <pozic> quicksilver: well, in some way a type-class is a sum-type, but I assume you got what I meant.
07:40:57 <doserj> > foldr ($) 0 [(+1),(+2)]
07:40:58 <lambdabot>   3
07:40:59 <Saizan> FunctorSalad: strong sum?
07:41:38 <FunctorSalad> Saizan: I think "weak" means "categorical sum but without the uniqueness" here
07:41:41 <ivanm> if I have a record-based data structure, is there a short-hand equivalent to pattern matching?
07:41:49 <lilac> pozic: i'd suggest you run it in the initial monad of that type and then map the result into the two monads where you want it
07:41:58 <quicksilver> ivanm: what do you mean?
07:42:09 <Phillemann> FunctorSalad: Ahhh, okay, I understand what you mean. :)
07:42:16 <ivanm> quicksilver: an equivalent to let [(n, _)] = foo xs
07:42:27 <lilac> pozic: if it's (forall m. Monad m => m a) then run it in Identity, and use two different types of 'return' to get the monadic nature back :)
07:42:36 <quicksilver> ivanm: let Con x _ = foo xs
07:42:37 <ivanm> but for a data structure, where I only want to pull out one or two fields
07:42:44 <quicksilver> ivanm: exactly like with non-record data.
07:42:46 <FunctorSalad> (so "strong" sums would be ordinary sums)
07:42:51 <ivanm> is there a short cut so I can avoid the _'s ?
07:42:51 <quicksilver> oh
07:43:05 <quicksilver> let Con { fieldx = x, fieldy = y} = ...
07:43:21 <ivanm> that's what I wanted, thanks! :D
07:43:45 * quicksilver wonders where ivanm learn about record notation which didn't explain that too ;)
07:44:00 <ivanm> quicksilver: heh, forgot about it ;-)
07:44:02 <quicksilver> the point of record notation is construct + match + update with the same syntax.
07:44:18 <ivanm> well, actually, I've never seen or used deconstruction like that
07:44:41 <ivanm> I normally get the actual thing, and then use the fieldx, etc. functions to deconstruct it
07:45:06 <strathhelp> hey guys was wondering if someone could help real quick, I'm trying to map a value to the snd of an array of tuples,  sort of like             map (:True) [('a', [True]), ('b', [False])]
07:45:15 <strathhelp> any ideas, thanks
07:45:21 <FunctorSalad> let Con{..} =
07:45:28 <FunctorSalad> (RecordWildCards :))
07:46:23 * quicksilver thinks recordwildcards and the punned fields are probably a bad idea as extensions go.
07:46:27 <Cale> strathhelp: map (\(x,y) -> (x,True:y)) ?
07:46:43 <strathhelp> oh, yeah there's a catch, without using lambda abstractions
07:46:47 <strathhelp> sorry :)
07:47:01 <Cale> quicksilver: I think they're great for certain things, especially the case when you have a bunch of fields which are all functions.
07:47:10 <quicksilver> sounds a leetle bit like homework to me ;)
07:47:12 <Cale> strathhelp: then fmap
07:47:20 <quicksilver> Cale: I just think they further the confusion about what a field name "is"
07:47:23 <Cale> or Control.Arrow.second
07:47:38 <quicksilver> Cale: a field name "is" a selector function, so it has type "T -> a"
07:47:44 <EvilTerran> > fmap fmap fmap (True:) [(1,[]), (2,[True]), (3,[False])]
07:47:46 <lambdabot>   [(1,[True]),(2,[True,True]),(3,[True,False])]
07:48:01 <Cale> quicksilver: Well, not when you put something else in scope :)
07:48:06 <quicksilver> Cale: if you can use it again with type "a" then I think that's a potential pedagogical hole for people to stumble in.
07:48:13 <quicksilver> Cale: Yes, sure. I understand how it work and what it does.
07:48:21 <quicksilver> Cale: I'm just explaining why I think it is unwise.
07:48:31 <quicksilver> there is enough confusion about what field names are as it is.
07:48:43 <Cale> One could already write  f (MyRec { foo = foo; bar = bar }) = ...
07:48:48 <quicksilver> yes.
07:48:51 <FunctorSalad> hmm, it's an extension, new users wouldn't run into it accidentally (unless reading someone else's source)
07:48:59 <quicksilver> (a practice which I also advise against)
07:49:20 <quicksilver> FunctorSalad: Right. I think I'm advising against recommending it to new users or having it widely used in libraries. :)
07:49:44 <FunctorSalad> quicksilver: it seems similar to other "scoping" things in principle, like importing a module unqualified
07:49:51 <Cale> I think it's possible that a better option is for field names not to be functions.
07:50:20 <ivanm> gah! no matter what I do, I keep getting "could not deduce (Graph gr1) from the context ())" :@
07:50:33 <quicksilver> Cale: a much better option, yes.
07:50:33 <Cale> ivanm: What are you trying to do?
07:50:43 <quicksilver> Cale: but not one of the options that is currently on the table :)
07:50:48 <pozic> ivanm: it just means that you call a function in the body which is in the Graph class.
07:50:57 <ivanm> Cale: heh, just worked it out I think... I got rid of the type-sig in the where clause and it worked! \o/
07:51:02 <quicksilver> FunctorSalad: yes, but it's worth. The two "foo"s are not unrelated.
07:51:05 <pozic> ivanm: and your type claims it does not.
07:51:10 <ivanm> pozic: I know... but I do have (Graph gr) => ... in the type sig
07:51:20 <FunctorSalad> ivanm: you need ScopedTypeVariables, probably
07:51:21 <quicksilver> FunctorSalad: they are closely related (both relating to a field of a particular type) but one has the type T -> a and one has the type a
07:51:28 <ivanm> FunctorSalad: I had it, just got rid of it
07:51:29 <FunctorSalad> ivanm: and a "forall" in the toplevel sig
07:51:30 <ivanm> the problem was that the original type sig had a forall which I forgot about
07:51:33 <quicksilver> FunctorSalad: I think that's potentially pretty confusing when you're learning about types.
07:51:37 <ivanm> but it seems to work now... >_>
07:52:05 <Cale> FunctorSalad: To be fair, that confusion isn't exactly new
07:52:21 <Cale> FunctorSalad: It already exists in the record update and pattern matching syntax
07:52:40 <quicksilver> true.
07:52:42 <quicksilver> it's a mess.
07:53:01 <FunctorSalad> hmm I don't really have a strong opinion about this :)
07:53:12 <quicksilver> it would be much nicer if they were lenses or something similarly functional.
07:53:13 <Cale> I just like the way that wildcards let you pull the definitions of the fields out into a where clause when they get complicated.
07:53:23 <ivanm> dammit, I've got a parsing error somewhere :(
07:53:49 <Cale> circle radius (ax,ay) (vx,vy) (x,y) = GameObject { .. }
07:53:50 <Cale>   where updateObject gs ks = [circle radius (ax,ay) (vx+ax,vy+ay) (x+vx,y+vy)]
07:53:50 <Cale>         renderGameObject = drawCircle (x,y) radius
07:53:50 <Cale>         hitTest (x',y') = distance (x,y) (x',y') <= radius
07:54:48 <quicksilver> Cale: I can't really see what that's better than deleting the substring " .. }\n  where "
07:55:03 <Cale> quicksilver: Won't work.
07:55:10 <quicksilver> well except you are forced to use lambda notation
07:55:17 <quicksilver> which is admittedly a minor ugliness
07:55:21 <Cale> and no layout
07:55:22 <quicksilver> but one which I have got used to :)
07:55:30 <FunctorSalad> quicksilver: one positive thing I can see is that using the same name for vars as for fields is canonical, so the reader doesn't have to mentally cache your var names
07:55:31 * quicksilver nods
07:55:36 <ivanm> *sigh* any idea how I can track down a parsing error?
07:55:41 <quicksilver> FunctorSalad: agreed.
07:55:55 <quicksilver> Cale: is "no lyaout" a problem in this context though?
07:56:13 <Cale> I think layout is nicer than having to remember the commas
07:56:18 <quicksilver> yes.
07:56:25 <quicksilver> that seems a remarkably trivial reason though :)
07:56:37 <Cale> Well, it's syntax sugar. What do you expect?
07:56:52 <FunctorSalad> ivanm: pull out subexpressions?
07:56:53 * quicksilver shrugs
07:56:58 <quicksilver> power/weight ratio.
07:57:00 <Cale> The whole feature is semantically trivial :)
07:57:06 <ivanm> FunctorSalad: yeah, that's what I'm trying to do
07:57:07 <pozic> lilac, quicksilver: thanks, it type-checks. It is certainly better than adding two extra type parameters throughout the whole code base.
07:57:16 <quicksilver> It's syntax sugar which brings a whole bunch of new names in scope at different types.
07:57:18 <Cale> It just gives you a prettier syntax for things like this
07:57:29 <quicksilver> (although admittedly related types)
07:57:32 <Cale> (or at least, what I consider prettier, anyway)
07:57:57 <quicksilver> I don't consider your example you just gave tilts the power/weight ratio in the right direction :)
08:02:38 <Cale> Well, the weight is pretty small.
08:02:38 <FunctorSalad> I think commas look pretty neat actually if you put them at the beginnings of lines rather than the end
08:03:03 <FunctorSalad> (as visual structuring)
08:03:17 <quicksilver> Cale: I think we'll have to agree to disagree.
08:03:30 <Cale> The implementation of RecordWildCards is (hopefully) trivial
08:03:48 <quicksilver> Cale: A syntax which shadows a whole bunch of names (not locally observable which names) to different types I do not consider low weight.
08:04:00 <Cale> Eh?
08:04:13 <Cale> I'm not sure what you mean by 'weight' then.
08:04:20 <Cale> I figured you meant implementation complexity.
08:04:24 <quicksilver> ah, no.
08:05:09 <quicksilver> I meant the cost to the language; the mental difficult of desugaring and the confusion possibly caused by people who don't know the feature well.
08:07:21 <SamB> so, it's not *quite* as bad as the way C++ lets you refer to instance variables ?
08:07:47 <Saizan> i wonder why the syntax of Foo { <here> } was different from "let <here> in .." in the first place
08:08:26 <Cale> I think it's reasonable in that regard. You just have to learn that Con { .. } means that this scope is going to talk about the contents of Con directly. Better would just be to copy the syntax of let, yes.
08:08:48 <Cale> I wonder if it was considered too tricky to make constructor names into layout keywords?
08:09:27 <quicksilver> SamB: actually I think it's worse, because it's not the case that out of class scope, C++ instance names are selector functions ;)
08:10:26 <quicksilver> I agree with saizan that it would be nice to have layout syntax inside records.
08:10:40 <SamB> quicksilver: yeah, but you can't tell which of those "free variables" refer to instance variables and which are actually globals
08:10:55 <SamB> without looking at the class declaration, I mean ;-)
08:11:13 <quicksilver> yes.
08:11:16 <quicksilver> in that sense it's similar.
08:11:29 <quicksilver> it's just in the haskell case there is *definitely* a global with the same name,
08:11:36 <quicksilver> but it has a different - although related - type.
08:11:39 <SamB> true
08:11:55 <quicksilver> "different but related", I argue, is possibly grounds for confusion.
08:12:13 <quicksilver> if this "foo" the "T -> a" sort of foo or the "a" sort?
08:12:33 <quicksilver> why can't I copy "map foo list_of_things" from this other bit of code and have it work here?
08:12:35 <Cale> To be fair, it's easy enough to tell.
08:12:47 <benmachine> @pl f (x:xs) bf p = bf x p:f xs bf p
08:12:48 <lambdabot> f = fix ((`ap` tail) . (. head) . flip ((.) . ap . (liftM2 (:) .) . flip id))
08:12:57 <benmachine> erm, okay
08:13:22 <benmachine> (p.s. why is your lambdabot's @pl better than mine?)
08:13:29 <EvilTerran> benmachine, looks like you should be able to restructure that as a foldr
08:13:33 <FunctorSalad> I wouldn't call that "good"...
08:13:44 <benmachine> FunctorSalad: umm
08:13:48 <benmachine> FunctorSalad: mine was this:
08:13:52 <benmachine> lambdabot> @pl f (x:xs) bf p = bf x p:f xs bf p
08:13:52 <benmachine> f = id (fix (flip (ap . flip ((.) . flip ((.) . ap . (ap .) . (((:) .) .) . flip id)) head) tail))
08:13:54 <EvilTerran> depending on the base case
08:14:19 <benmachine> EvilTerran: possibly.
08:14:22 <Cale> circle radius (ax,ay) (vx,vy) (x,y) =
08:14:22 <Cale>   GameObject updateObject gs ks = [circle radius (ax,ay) (vx+ax,vy+ay) (x+vx,y+vy)]
08:14:22 <Cale>              renderGameObject = drawCircle (x,y) radius
08:14:22 <Cale>              hitTest (x',y') = distance (x,y) (x',y') <= radius
08:14:26 <FunctorSalad> benmachine: I meant that in the sense that I find a pointful version preferable to such a mess ;)
08:14:26 <Cale> That would be ideal.
08:14:48 <benmachine> FunctorSalad: yeah I wasn't planning on using the pointless version I just thought it might be illustrative
08:15:56 <Cale> however, determining that layout is needed is a bit tricky :)
08:16:46 <Cale> (if you think about it from the parser's perspective)
08:17:44 <benmachine> why can't equations for functions have different numbers of arguments?
08:18:21 <soupdragon> benmachine, no real reason
08:18:31 <benmachine> :(
08:19:26 <Cale> I think the rationale is that it makes seeing how pattern matching proceeds a little trickier.
08:19:53 <Cale> well...
08:20:19 <ekidd> Good morning! I'm trying to remember who said something along the lines of "A monad is simply a monoid in the category of endofunctors" as a smart-aleck reply on #haskell way back when. :-)
08:20:36 <soupdragon> @quote endofunctors
08:20:36 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
08:20:45 <Rembane> ^^
08:20:49 <soupdragon> @quote endofunctors
08:20:49 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
08:21:06 <Cale> ekidd: Well, that is a true statement... I think a lot of people have said something along those lines :)
08:22:00 <ekidd> soupdragon: Ah, thank you! That was the version of the quote I wanted. :-)
08:22:12 <quicksilver> Cale: woudl it be better if we didn't use = ?
08:22:20 <Rembane> It makes my brain melt
08:22:22 <quicksilver> cale: ->, perhaps.
08:22:35 <Cale> quicksilver: hmm
08:22:39 <quicksilver> still lookahead though.
08:22:54 <quicksilver> the haskell grammar is designed to avoid lookahead I think.
08:23:35 <ekidd> Cale: Yeah, but I was looking for a certain penache in the phrasing. :-)
08:33:05 <desp> Can someone tell me why do I get overlapping instances here?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7124
08:33:48 <lilac> desp: because the context isn't taken into account when selecting instances
08:34:00 <desp> Oh my goodness, that error again.
08:34:03 * desp slaps self
08:34:06 <lilac> desp: so you've said, 'for all v, here's a Num and a Fractional instance for v'
08:34:29 <desp> lilac: is there any trick to Do What I Mean here?
08:35:34 <lilac> desp: allow me to put it this way: there's a Vector instance for Double, and Double already has a Num instance
08:35:35 <saml> desp, you want your Vector to be an instance of Fractional?
08:35:37 <lilac> that's going to overlap
08:35:50 <desp> saml: any Vector.
08:36:17 <Saizan> there isn't a Vector instance for Double, but you also can't guarantee there won't be
08:36:33 <lilac> desp: but i don't know What You Mean here, so i don't know if you can Do it :)
08:36:34 <ivanm> &&& from Control.Arrow didn't get changed with base-4, did it?
08:37:19 <lilac> Saizan: i meant 'is' in a more philosophical sense ;)
08:37:22 <desp> I would like to tell the type system "any type belonging to the Vector class belongs also to the Fractional class"
08:37:31 <quicksilver> desp: you cannot. end of.
08:37:44 <jmcarthur_work> well, you can with extensions, but you shouldn't
08:37:49 <quicksilver> (except by making fractional a superclass of vector)
08:38:06 <quicksilver> which doesn't let you write the default instances - it forces your useres to write them.
08:38:27 <quicksilver> it's a fundamental conflict between what typeclasses are, and what you'd like them to be.
08:38:35 * jmcarthur_work likes superclasses, honestly
08:38:43 <quicksilver> since type classes are open, Vector is open, so any type can be a vector...
08:38:46 <jmcarthur_work> although some sort of defaulting mechanism would be sweet
08:38:52 <quicksilver> ...including types which are already Fractional.
08:39:08 <quicksilver> so trying to write another fractional instance for all vector types is broken.
08:39:15 <quicksilver> You can change vector from a class to a type, perhaps.
08:39:26 <quicksilver> pretty major redesign though.
08:39:41 <desp> Don't worry, I've been through at least four, by now.
08:39:42 <desp> :)
08:39:42 <Saizan> http://okmij.org/ftp/Haskell/types.html#poly2 <- if you _really_ want, you can probably code it with techniques from here (just to increase brain explosions)
08:39:48 <SamB> hmm ... I hope there's nothing too wrong with my dog
08:40:07 <SamB> she didn't really manage to eat her supper until breakfast time :-(
08:40:46 <kulakowski> SamB: thought you were talking about the preprocessor, only saw that second line
08:41:01 <SamB> I hope she was just full of shit (literally)
08:41:28 <desp> Saizan: thanks, that looks interesting.
08:42:02 <Rembane> Or maybe it is reversed Ramadan for dogs at the moment
08:42:02 * lilac thinks that the commonness with which people expect contexts to be used when selecting instances implies that typeclasses are not the right solution to the problem for which they're used
08:42:25 <saml> i think you can't say "all instances of class A are instances of class B"
08:42:34 <desp> lilac: is there a FAQ about this?
08:42:47 <desp> I'd really like to fix my obviously wrong intuition about typeclasses.
08:43:05 <martin83> hi there
08:43:08 <saml> but you can say given class A, define class B
08:43:36 <saml> hello martin83 .
08:43:37 <lilac> desp: i'd like to see such an FAQ -- my intuition is wrong too. i know /that/ it's wrong, but i don't understand /why/.
08:43:45 <Cale> saml: You can say that in defining class A
08:44:00 <martin83> whats up there?
08:44:14 <lilac> intuitively it feels like typeclasses are less powerful than what i want, but i suspect that what i want is fundamentally broken somehow (ie too powerful to be correct)
08:44:15 <MarcWeber> nominolo: "mkTopLevEnv: not interpreted main:Main" Do you just happen to know what this means? I get this error when configuring a cabal project using the scion server
08:45:15 <Cale> lilac: Maybe in those cases where people want to select an instance based on the classes to which something belongs
08:45:28 <nominolo> MarcWeber: hm, no.  Maybe somehow HscNothing is set when it shouldn't
08:45:33 <Cale> But I think typeclasses are the right solution to a lot of the problems that they solve
08:46:36 <nominolo> MarcWeber: configuring means loading the Setup.hs and trying to run its main function.  I suspect that for some reason the loading part didn't generate any bytecode
08:46:46 <Cale> The only reason that instances can't be selected based on the classes to which something belongs is that classes are fundamentally open. You can never say for certain that some type won't belong to some class until you're compiling a final executable program and everything is in scope.
08:46:57 <Saizan> typeclasses are designed so that you'll always use the same instance for the same type, and also keep separate compilation possible, so in a sense that means that in any module if there's a way to resolve a context that's the right way to do so.
08:47:21 <quicksilver> I suspect typeclasses are a good solution to overloading but they are not a good general notion of polymorphism
08:47:27 <quicksilver> and people try to use them as one.
08:47:42 <Cale> hmm
08:47:52 <quicksilver> parametric polypmorphism and possibly GADTs are sometimes better solutions.
08:47:56 <Cale> They're one particular type of polymorphism.
08:48:03 <quicksilver> right
08:48:10 <Cale> They're a restricted form of parametric polymorphism, specifically.
08:48:10 <quicksilver> so-called "ad-hoc" polymorphism.
08:48:13 <Cale> no
08:48:33 <Cale> That's a mistake. They have very little in common with what's normally called ad-hoc polymorphism.
08:49:22 <quicksilver> "This paper presents type classes, a new approach to ad-hoc polymorphism" [Wadler89]
08:49:32 <Cale> Yes, but that was a mistake to say that.
08:49:38 * quicksilver nods
08:49:42 <nominolo> why?
08:49:45 <Cale> substitute for, perhaps.
08:49:54 <quicksilver> well you must consider my vocabulary Wadler-ised.
08:50:28 <nominolo> Cale: are you thinking in terms of dynamic vs. static polymorphism resolution?
08:50:43 <soupdragon> Cale is gona make you wish you never said that
08:50:46 <soupdragon> :Z
08:50:49 <Cale> In ad-hoc polymorphism, you normally select the implementation based on the type at a given context, and the result is monomorphic.
08:51:22 <nominolo> Cale: right.  But in Haskell you don't have sub-typing so you always know the type
08:51:27 <Cale> In typeclass polymorphism, you get new typeclass-polymorphic values just by using typeclass-polymorphic values.
08:51:27 <quicksilver> the practice of referring to what typeclasses do as adhoc polymorphism appears to be pretty widespread (quick google sruvey)
08:51:35 <nominolo> well, not quite
08:51:48 <Cale> So, for instance, sort is polymorphic just because it uses (<)
08:51:48 <quicksilver> we've all been wadlerised.
08:51:59 <nominolo> Haskell has the System-F subtyping
08:52:04 <Cale> I think it's a big mistake and I always point it out.
08:52:27 <zachk> was hOpengl dropped from the base install of ghc 6.10.3
08:52:32 <zachk> ?
08:52:48 <Cale> nominolo: Typeclasses introduce ambiguity of course.
08:53:09 <nominolo> quicksilver: so would it be "real" ad-hoc polymorphism if you'd have first-class type classes?
08:53:12 <Cale> zachk: I'm not sure, but if so, you can still  cabal install OpenGL
08:53:16 <nominolo> er, that was @ Cale
08:53:26 <quicksilver> zachk: technically it was never part of what we technically call "base". But yes I think it was dropped from the extra libs aroud then.
08:53:33 <zachk> yea but im on windows so getting cabal working is always lots of fun :-D
08:53:34 <Cale> nominolo: No, real ad-hoc polymorphism is weaker than typeclasses.
08:54:12 <lilac> I think I would prefer to see implicitly-passed dictionaries rather than typeclasses, with the ability for me to choose which dictionary is picked if it's ambiguous, and to choose when (in which scope) the dictionary is resolved
08:54:31 <Saizan> zachk: there's the haskell-platform installer
08:54:34 <Cale> nominolo: You can get it by making all your classes have a single value of an arbitrary type and then wherever you use that value, you give it a type signature which doesn't mention any typeclasses
08:54:34 <saml> zachk, you can try haskell platform. cabal works out of the box on windows and it includes OpenGL
08:54:46 <quicksilver> lilac: then we couldn't use typeclasses for invariants any more (like Binary, or Data.Map)
08:54:53 <lilac> the 'typeclasses are global' restriction has always seemed foreign and weird to me
08:54:56 <Cale> nominolo: and then just write instances for each of the monomorphic types which you want
08:55:01 <lilac> quicksilver: why?
08:55:04 <saml> we need a crossplatform audio library.
08:55:19 <quicksilver> lilac: because if you try to use my Data.Map with a different Ord instance in scope, nasal demons are emitted.
08:55:25 <Cale> nominolo: Note that this makes things like the sort function impossible.
08:55:59 <Cale> nominolo: because when you go to apply (<), you'd have to pick a monomorphic type for it, you couldn't let that polymorphism extend to sort
08:56:08 <Cale> (in ad-hoc polymorphism)
08:56:14 <nominolo> Cale: I see
08:56:25 <Saizan> quicksilver: Binary is tricky, but for Data.Map the Ord instance should be a parameter at the type level
08:56:36 <nominolo> but you can always simulate this via (function) arguments
08:56:53 <nominolo> i.e., manual dictionary passing
08:56:54 <Cale> But of course, you could just define a new class for sort, and then implement it separately for every type of list, which is what you'd have to do.
08:56:54 <quicksilver> cale: which is what wadler means, I think, when his paper abstract had the phrase about making it "less ad-hoc"
08:57:08 <quicksilver> Saizan: there are hundreds of examples.
08:57:10 <Raevel> i want to be able to parse integers using parsec, natural numbers are of course simply many1 digit, but there may be a negation, how do i check for it and include it if it exists in a nice way?
08:57:15 <Cale> quicksilver: right, but it's not really ad-hoc polymorphism anymore, it's something new
08:57:30 <soupdragon> Raevel, hmmmm
08:57:33 <Cale> I like to think of it as restricted parametric polymorphism
08:57:37 <quicksilver> Saizan: non-global Num instances would break all kinds of invariants
08:57:45 <lilac> quicksilver: right, Data.Map would need to store the Ord dictionary rather than have it passed to every single operation. (or perform type system tricks to ensure it's the same somehow)
08:57:49 <quicksilver> Raevel: optional minus >> many1 digit ?
08:58:04 <quicksilver> lilac: yes, but I stress that's only one example.
08:58:04 <hackagebot> time 1.1.4 - A time library (RossPaterson)
08:58:19 <nominolo> Cale: ok, I like that classification.
08:58:26 <quicksilver> lilac: do you want to store the num dictionary next to every number in case a different num instance is in scope next time you add it?
08:58:26 <lilac> quicksilver: and it's a good example since in that case inlining the Ord instance is a complete pain
08:58:53 <quicksilver> do you want to store the Eq instance next to every list in case you later compare items?
08:58:56 <quicksilver> etc.
08:58:57 <lilac> quicksilver: how many data types contain a 'Num n => n'?
08:59:06 <quicksilver> that's not the point.
08:59:10 <quicksilver> the data type just contains a Double
08:59:17 <quicksilver> (mean so far)
08:59:18 <lilac> in which case there's no need to store anything
08:59:20 <tommd> @where pvp
08:59:20 <lambdabot> I know nothing about pvp.
08:59:23 <Raevel> quicksilver: yes, thank you! i tried optional '-' >> many1 digit >:(, i should bother to read error messages
08:59:36 <quicksilver> if you add some numbers to it with one Num instance
08:59:42 <quicksilver> and add more numbers iwth a different Num instance
08:59:45 <quicksilver> now your Double is meaningless
08:59:58 <lilac> why would it be?
09:00:08 <nominolo> Cale: but you mentioned that type-classes don't work well for "real" ad-hoc polymorphism.  I don't quite get your trick of simulating that
09:00:18 <quicksilver> because it's supposed to be a total or a mean, or whatever
09:00:25 <quicksilver> that is on the assumption of a consistent arithmetic
09:00:32 <quicksilver> make arithmetic something which can be scoped + changed
09:00:44 <quicksilver> and you're back in the bad old world of LISPs with dynamically scoped (+) operators
09:00:50 <Cale> nominolo: Ad-hoc polymorphism is a tiny subset of what's doable using typeclasses.
09:00:53 <lilac> do you have a concrete example? multiple Num instances for Double with different semantics sounds unlikely
09:01:01 <quicksilver> yes, it sounds unlikely
09:01:21 <Cale> I don't think I said that typeclasses make real ad-hoc polymorphism hard. It's kind of easy actually.
09:01:27 <quicksilver> how about an Int which I `mappend` to ?
09:01:35 <lilac> quicksilver: let's consider multiple Monoid instances for something
09:01:42 <lilac> ah, i see you're alredy considering that :)
09:01:42 <quicksilver> and sometimes you switch the monoid instance so my mappend means multiple instead of add
09:02:08 <quicksilver> somethign like dictionaries, but lexically replaceable is definitely useful.
09:02:17 <lilac> yes, you'd be able to do that if you wanted. that's not bad in and of itself
09:02:18 <quicksilver> but, I don't believe it is the right solution for Ord or Num or Eq.
09:02:29 <quicksilver> lilac: it is if it's a fingertree
09:02:36 <quicksilver> and the Monoid instance is part of the invariant
09:02:38 <lilac> quicksilver: "in and of itself"
09:02:51 <nominolo> Cale: ah, you said they're being used in place of parametric polymorphism, which is bad, I agree
09:02:55 <lilac> quicksilver: in that specific example, there's an invariant which the data strcuture is failing to enforce
09:02:59 <lilac> that's a bug in the data structure
09:03:05 <quicksilver> :)
09:03:08 <quicksilver> in a sense, yes.
09:03:21 <quicksilver> but the typeclass system lets us enforce that cheaply and easily
09:03:25 <quicksilver> that is one of its virtues
09:03:37 <quicksilver> take that away and it becomes less useful for a whole bunch of things it is currently useful for.
09:03:39 <bgs100> What does ">>" do?
09:03:40 <lilac> indeed. but i think the cost of that virtue is too high
09:04:05 <nominolo> doesn't UHC have local type-class instances?
09:04:12 <nominolo> I'll have to take another look
09:04:27 <benmachine> bgs100: foo >> bar = do { foo; bar }
09:05:06 <pikhq> bgs100: foo >> bar = foo >>= \_ -> bar
09:05:35 <nominolo> ah, I think it's called scoped instances
09:06:26 <nominolo> and it looks like they use constraint handling rules internally (in the type checker)
09:06:29 <nominolo>  they use constraint handling rules internal
09:06:43 <quicksilver> nominolo: yes, I always meant to look at what they do, but I never did.
09:07:12 <samphippen-lapto> how do I filter down a list to contain only even numbered items?
09:07:43 <bgs100> Ok, thanks
09:07:51 <benmachine> samphippen-lapto: you mean, drop every other item?
09:08:00 <samphippen-lapto> yes
09:08:07 <hackagebot> Control-Engine 1.1.0.0 - A parallel producer/consumer engine (thread pool) (ThomasDuBuisson)
09:09:28 <samphippen-lapto> benmachine, ^
09:09:53 <benmachine> just because I clarified your question doesn't mean I know the answer :P
09:10:43 <samphippen-lapto> lol
09:10:44 <samphippen-lapto> fair play
09:10:45 <Ke> well at least you could do x:y:xs = x thisfunction xs
09:10:53 <EvilTerran> > zip (cycle [False, True]) "abracadabra" -- samphippen-lapto, this (or something similar) could help
09:10:55 <lambdabot>   [(False,'a'),(True,'b'),(False,'r'),(True,'a'),(False,'c'),(True,'a'),(Fals...
09:11:02 <benmachine> Ke: yeah I imagine something like that
09:11:11 <benmachine> or that
09:11:21 <samphippen-lapto> ah
09:11:31 <EvilTerran> > [x | (True, x) <- zip (cycle [False, True]) "abracadabra"]
09:11:33 <lambdabot>   "baaar"
09:11:37 <samphippen-lapto> win!
09:11:46 <benmachine> nice
09:12:26 <EvilTerran> > concat . zipWith ($) (cycle [const [], (:[])) $ "abracadabra"
09:12:27 <lambdabot>   <no location info>: parse error on input `)'
09:12:33 <EvilTerran> > concat . zipWith ($) (cycle [const [], (:[])]) $ "abracadabra"
09:12:35 <lambdabot>   "baaar"
09:12:58 <lilac> > snd <$> filter fst (zip (cycle [False,True]) "abracadabra")
09:13:00 <lambdabot>   "baaar"
09:13:46 <quicksilver> > map head . takeWhile (not.null) . iterate (drop 2) $ "abracadabra"
09:13:47 <lambdabot>   "arcdba"
09:13:48 <lilac> > catMaybes . zipWith ($) (cycle [const Nothing,Just]) "abracadabra"
09:13:50 <lambdabot>   Couldn't match expected type `a -> [Data.Maybe.Maybe a1]'
09:13:56 <quicksilver> is probably how I'd do it.
09:13:56 <lilac> > catMaybes $ zipWith ($) (cycle [const Nothing,Just]) "abracadabra"
09:13:58 <lambdabot>   "baaar"
09:14:13 <Cale> nominolo: I only complained that the *name* ad-hoc polymorphism is a bad name for what typeclasses are. Typeclasses are much more closely related to parametric polymorphism than ad-hoc polymorphism is.
09:14:19 <Ke> kolmodin: why is ghc-6.10 still masked?
09:14:22 <lilac> > catMaybes $ zipWith ($) (cycle [fail.(:[]),Just]) "abracadabra"
09:14:25 <lambdabot>   "baaar"
09:14:31 <Ke> kolmodin: testing for how long?
09:14:50 <lilac> > catMaybes $ zipWith id (cycle [fail.(:[]),Just]) "abracadabra"
09:14:52 <lambdabot>   "baaar"
09:14:59 <lilac> ok, i'm golfed out
09:15:23 <EvilTerran> > concat . zipWith id (cycle [mempty,pure]) $ "abracadabra"
09:15:24 <lambdabot>   "baaar"
09:15:28 <EvilTerran> :P
09:15:33 <soupdragon> abracadabra
09:15:47 <hzap> :t [mempty, pure]
09:15:50 <lambdabot> forall a (f :: * -> *). (Monoid (f a), Applicative f) => [a -> f a]
09:15:57 <soupdragon> superabracadabrafragalistic
09:16:06 <lilac> EvilTerran: forgot about the (->) Monoid
09:16:12 <EvilTerran> hzap, it uses Monoid a => Monoid (e -> a)
09:16:35 <hzap> EvilTerran: function instances for things really confuse me sometimes
09:17:06 <benmachine> > return 1 :: t -> a
09:17:08 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
09:17:08 <lambdabot>    arising from the li...
09:17:16 * benmachine confuses self
09:17:26 <benmachine> > return 1 :: (Num a) => t -> a
09:17:28 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
09:17:28 <lambdabot>    arising from a use of `...
09:17:34 <soupdragon> > (return 1 :: a -> Int) ()
09:17:35 <EvilTerran> mempty = const mempty; (f `mappend` g) x = f x `mappend` g x
09:17:36 <lambdabot>   1
09:17:44 <soupdragon> > (return 1 :: a -> Int) "Goo"
09:17:46 <lambdabot>   1
09:17:55 <benmachine> guess that makes sense
09:18:08 <conal> mempty = pure mempty ; mappend = liftA2 mappend
09:18:18 <benmachine> I was expecting it to output "const 1" but that's probably optimistic of me
09:18:22 <soupdragon> :t pure
09:18:24 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
09:18:31 <soupdragon> :t liftA
09:18:33 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
09:18:35 <soupdragon> :t liftA2
09:18:42 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
09:18:45 <lilac> > snd $ foldr (\x (y,z)->(x:z,y)) ([],[]) "abracadabra"
09:18:47 <lambdabot>   "baaar"
09:18:53 <lilac> ^^ i think that's how i'd actually write it
09:19:02 <pikhq> @pl return 1 :: t -> a
09:19:03 <lambdabot> (line 1, column 15):
09:19:03 <lambdabot> unexpected ">" or "-"
09:19:03 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
09:19:15 <pikhq> Heh.
09:19:27 <kolmodin> Ke: we have still not bumped all the packages in portage so that they work with ghc 6.10.3
09:19:45 <Ke> kolmodin: ok, thanks
09:19:49 <kolmodin> Ke: you are very welcome to help, it's not very hard
09:20:14 <kolmodin> Ke: just unmask ghc in portage, along with haddock and parallel. then just compile all haskell packages you find and see what does not work :)
09:20:40 <kolmodin> many packages needs to be bumped either way
09:20:56 <Ke> heh
09:21:11 <kolmodin> Ke: if you want ghc 6.10.3 right now you could use the haskell overlay. we've got plenty of packages there
09:21:21 <kolmodin> and also hc 6.10.3
09:22:34 <Petrosian> > readDec "100e2"
09:22:36 <lambdabot>   [(100,"e2")]
09:22:39 <Ke> kolmodin: is ghc in portage somehow worse?
09:22:43 <Petrosian> > readFloat "100.1e2"
09:22:45 <lambdabot>   [(10010.0,"")]
09:23:26 <Petrosian> Why does readFloat accept `e' notation, and readDec does not?
09:23:36 <Petrosian> Seems inconsistant
09:23:45 <Twey> :t readDec
09:23:46 <lambdabot> forall a. (Num a) => String -> [(a, String)]
09:23:56 * Twey doesn't know
09:24:27 <Petrosian> Nor does readInt ...
09:24:35 <Peaker> it should be readsDec?
09:24:42 <Peaker> > readDec "1234hello"
09:24:44 <lambdabot>   [(1234,"hello")]
09:24:50 <Badger> erk?
09:25:01 <Badger> someone implemented perl in haskell?
09:25:20 <Botje> sounds like a fun idea
09:25:27 <saml> Badger, yes. perl6
09:25:29 <Peaker> @type fmap fst . listToMaybe
09:25:31 <lambdabot> forall a b. [(a, b)] -> Maybe a
09:25:36 <EvilTerran> Badger, you mean pugs? that's aiming to implement perl6 in haskell
09:25:40 <Badger> D:
09:25:43 <Badger> the horror
09:26:36 <Peaker> @let toReadm = fmap fst . listToMaybe
09:26:38 <lambdabot>  Defined.
09:26:49 <Peaker> @type toReadm . readDec
09:26:51 <lambdabot> forall a. (Num a) => String -> Maybe a
09:27:02 <Peaker> that's a nicer type
09:27:09 <Peaker> most of the time
09:27:26 <Peaker> though it is probably better to check the rest-string has nothing in it too
09:27:39 <benmachine> @type listToMaybe
09:27:40 <lambdabot> forall a. [a] -> Maybe a
09:29:09 <EvilTerran> toReadm ps = listToMaybe [x | (x, "") <- ps] -- better?
09:29:43 <kolmodin> Ke: no. but not all packages might work with it yet. that's why it's masked
09:29:51 <kolmodin> Ke: no problems with ghc itself
09:30:25 <Ke> ok, I though you meant to get ghc itself from the overlay
09:31:03 <kolmodin> right
09:32:20 <uzytkownik> Is is possible to catch exceptions outside IO monad or do I have to use Control.Monad.Error?
09:32:56 <quicksilver> you have to use something other than IO exceptions, yes.
09:33:02 <quicksilver> IO exceptions can only be caught in IO.
09:33:16 <quicksilver> Control.Monad.Error is just one example of a pure approach to exception handling.
09:34:03 <quicksilver> Petrosian: by tradition 'e' notation is only valid for floating point (well, fractional) types
09:34:19 <Petrosian> quicksilver: Ye, think I'd just figured that one out
09:34:25 <quicksilver> Petrosian: that's obviously a bit arbitrary, since it can be used to specify integers.
09:34:28 <quicksilver> it's just tradition.
09:34:38 <quicksilver> > 1e6 :: Integer
09:34:39 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
09:34:39 <lambdabot>    aris...
09:34:56 <quicksilver> > (floor 1e6) :: Integer
09:34:56 <lambdabot>   1000000
09:34:58 <Petrosian> quicksilver: I was assuming the literal "232e2" for example was Int, not (Fractional a) => a, when reading it
09:35:06 <quicksilver> > (floor 1e16) :: Integer
09:35:07 <lambdabot>   10000000000000000
09:35:09 <benmachine> quicksilver: well, floating point just means standard form, really, and e is standard form
09:35:15 <Peaker> EvilTerran: yeah
09:35:15 <Peaker> EvilTerran: probably best to partially apply it with (.)
09:35:21 <Peaker> EvilTerran: so you can use toReadm reads
09:35:29 <quicksilver> benmachine: true, but e notation is also convenient for large integers.
09:35:35 <saml> > 0e2343539057329875985723945659872364983746834254726427385697845643876238642057610487230895732057805823705873902763290523
09:35:36 <quicksilver> > (floor 1e260) :: Integer
09:35:38 <lambdabot>   100000000000000006533477610574617307003210399478293629775643192173126922026...
09:35:41 <lambdabot>   mueval-core: Prelude.read: no parse
09:35:41 <lambdabot>  mueval: ExitFailure 1
09:35:47 <benmachine> quicksilver: large floating point numbers *are* integers :P
09:35:52 <quicksilver> ^^ and here we get errors :(
09:36:16 <quicksilver> benmachine: well, traditionally large floating point numbers are viewed as having an implicit error bound, so they're not really integers.
09:36:19 <quicksilver> but I know what you mean.
09:36:28 <burp> even worse than integers :p
09:36:33 <quicksilver> > (floor (1e260::Rational)) :: Integer
09:36:35 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
09:37:12 <Peaker> @type 232e2
09:37:13 <lambdabot> forall t. (Fractional t) => t
09:39:17 <saml> > let (!) = id in (42!)
09:39:18 <lambdabot>   42
09:39:48 <benmachine> let (!) = id in (42!!!!)
09:39:52 <benmachine> er
09:39:54 <Peaker> does Epigram or other DT languages have type-classes? e.g: Not having order be specific to naturals, as the examples always have?
09:39:54 <benmachine> > let (!) = id in (42!!!!)
09:39:55 <lambdabot>   Not in scope: `!!!!'
09:39:57 <benmachine> aw
09:40:01 <benmachine> > let (!) = id in (42! ! ! !)
09:40:03 <lambdabot>   <no location info>: parse error on input `!'
09:40:06 <benmachine> :(
09:40:09 <Peaker> benmachine: /query lambdabot
09:40:13 <benmachine> I suppose that makes sense
09:41:56 <saml> > let e123 = id in (0e123)
09:41:57 <lambdabot>   0.0
09:42:01 <saml> > let e123 = id in (0e123e123)
09:42:03 <lambdabot>   No instance for (GHC.Real.Fractional ((a -> a) -> a1))
09:42:03 <lambdabot>    arising from the ...
09:42:08 <uzytkownik> quicksilver: Thanks. As I understand IO exceptions are Control.Exception - not only IOError.
09:42:39 <Raevel> i have another parsec question, i want to parse a string that is axy (a,x,y substrings), a can contain x's and y's, so i want to parse as much as possible into a and then backtrack when necessary, how do i solve it?
09:44:02 <saml> Raevel, i don't understand
09:44:18 <saml> "axy" ==> ("a", "x", "y")   ?
09:44:32 <soupdragon> Raevel, what if a contains  xy ?
09:44:41 <soupdragon> like axyxy
09:44:58 <Petrosian> quicksilver: So, a literal number in Haskell is either a `Num a' or 'Fractional a'?
09:44:59 <Raevel> soupdragon: then "axy" is the a-part
09:45:00 <saml> (a,x,y,x,y)
09:45:21 <Peaker> @type 3.5
09:45:21 <Raevel> i suppose the regex is ^(.+)xy
09:45:22 <lambdabot> forall t. (Fractional t) => t
09:45:33 <Petrosian> quicksilver: Assuming there's no context coercing it to a specific monomorphic type
09:45:40 <soupdragon> Raevel, that's pretty hard to do
09:45:53 <Raevel> :-/
09:46:38 <Raevel> i'm parsing log files, and the format is not very nice to work with
09:46:53 <Twey> Wha'?  Hard to do?
09:47:01 <soupdragon> Raevel, is it line based?
09:47:07 <Raevel> soupdragon: yep
09:47:17 <Raevel> so atm i parse each line by itself
09:47:22 <soupdragon> Raevel, that makes it much easier
09:47:26 <Twey> Read axy, then read a choice of xy followed by other stuff or end of line
09:47:41 <beutdeuce> @type all
09:47:42 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:48:19 <Raevel> Twey: "read a choice" ?
09:50:52 <Twey> Raevel: <|>
09:51:35 <Raevel> ah
09:51:45 <a_guest> I installed some cabal source packages manually. I want to remove these now. How should I do it?
09:52:04 <Raevel> i may be able to use manyTill
09:53:11 <Twey> There's try, or refactoring
09:54:24 <saml> a_guest, cabal delete?
09:54:49 <saml> a_guest, sorry. there's no such command
09:54:57 <saml> maybe ghc-pkg unregister
09:55:20 <Raevel> yeah, i think you have to do that, and then remove the files from the cabal dir manually
09:55:32 <a_guest> saml: I think that I have to unregister the package, and then manually remove it.
09:55:47 <saml> or write a script to do
09:56:00 <a_guest> but is there something like 'runghc Setup clean"?
09:56:04 <saml> not sure if unregistering checks dependencies
09:58:00 <Saizan> runghc Setup clean removes the temporary build directory, but it's not an uninstall
09:58:28 <a_guest> guys, I think I found the solution: http://haskell.org/cabal/release/cabal-latest/doc/users-guide/builders.html
09:58:36 <tommd>  @quote ARM
09:59:29 <tommd> Humm, lambdabot is case sensitive in quotes.
10:00:01 <Saizan> @quote ARM
10:00:18 <Saizan> @bot
10:00:18 <lunabot>  :)
10:00:40 <Saizan> it seems she's blocked
10:00:48 <lambdabot> olsner says: hmm, so perl basically has all harmful features ever invented?
10:00:48 <lambdabot> :)
10:02:27 <pikhq> All *harmful* features? I think Perl has all features.
10:02:53 <saml> perl has goto?
10:03:05 <kulakowski> yes
10:03:10 <pikhq> saml: Yes.
10:03:13 <kulakowski> http://perldoc.perl.org/functions/goto.html
10:03:26 <saml> then it has all features
10:03:32 <pikhq> It's not even an obscure, little-known feature.
10:06:28 <mauke> saml: perl has computed goto, and the labels have dynamic scope
10:06:38 <mauke> tremble in fear!
10:06:59 * saml thinks function calls are goto
10:07:10 <soupdragon> saml lol
10:07:19 <pikhq> mauke: Dynamically scoped labels?
10:07:23 <pikhq> *shudder*
10:07:47 <soupdragon> thats worse than "cotinuations are gotos'
10:07:58 <pikhq> saml: No, but computed goto and a stack of some sort can do a passable imitation.
10:07:59 <lilac> "[...] Perl [...] isn't necessarily recommended if you're optimizing for maintainability" (from perldoc:goto)
10:08:07 <saml> unconditional transfer of control!
10:08:14 <mauke> also, goto isn't really efficient in perl. it simply scans a list of labels to find the target statement at runtime
10:08:15 <saml> PC register is updated!
10:08:28 <pikhq> (once, in C++, for class, I was asked to do merge sort iteratively. Computed goto and a stack. :D)
10:08:39 <mauke> no one cares enough to "fix" this, because goto is typically not used in perl
10:09:08 <skimpy> mauke: goto is rarely used in any languages
10:09:19 <lilac> pikhq: not using Duff's device? for shame!
10:09:35 <mauke> skimpy: it's semi-common in C
10:09:35 <pikhq> lilac: I was tempted.
10:09:46 <skimpy> mauke: I think i've used it like one time in C over the years
10:10:09 <skimpy> and only when i couldn't come up with a cleaner solution to my problem
10:10:10 <pikhq> It's used mostly as a way to go to a cleanup block before returning in C.
10:10:41 <mauke> goto is relatively often the cleanest solution in C
10:10:45 <pikhq> It also sees use for obfuscating C, of course.
10:11:03 <mauke> you need it for multilevel break or merging cleanup blocks
10:11:03 <skimpy> mauke: Have to disagree with that
10:11:34 <lilac> mauke: 'return' is good for multilevel break (plus refactoring so it breaks the right number of levels)
10:12:08 <mauke> not always applicable
10:12:36 <soupdragon>  <mauke> goto is relatively often the cleanest solution in C
10:12:37 <mauke> especially since C has no closures
10:12:38 <lilac> it's applicable often enough that gotos should be rare :)
10:12:42 <soupdragon> that's true
10:12:44 <skimpy> One usually tries to break down a problem into smaller pieces, if you have deeply nested loops. There is almost always a good way to refactor it
10:12:58 <skimpy> with the use of more functions
10:13:06 <soupdragon> but it's because C doesn't have syntax macros
10:13:16 <saml> and functions are gotos with stack and other bloated stuff
10:13:53 <kynky> messes with encapsulation, better for compiler toodo optiimizations on large pieces of code
10:13:54 <lilac> down with bloat!
10:14:01 <soupdragon> if we had syntax macros we wouldn't use it... how often do you use tagbody in lisp?
10:15:07 <soupdragon> a lot say goto is great you need it", but I think it's because they don't know there's something even better
10:16:54 <kynky> doing c at imperial college on my first lecture, i mentioned goto, my lecturer went nuts
10:18:16 <pikhq> Mention computed goto.
10:18:21 <pikhq> >:D
10:18:24 <hackagebot> toilet 0.0.1 - Manage the toilet queue at the IMO (HenningThielemann)
10:18:34 <ehird> Hello everyone.
10:18:36 <Peaker> skimpy: its often less clean to break up every resource allocation in C into its own function..  so a function ending with    cleanup2: cleanup2(); cleanup1: cleanup1(); exit: return 0; }  is relatively common, and then you goto the right label depending on how much you allocated by then
10:18:47 * pikhq is too fond of the unary &&.
10:18:56 <ehird> Unary &&? What on earð would ðat be?
10:19:04 <Guest24207> http://www.tcs.ifi.lmu.de/~gruberh/data/fun07-final.pdf
10:19:11 <themroc--> haha
10:19:17 <pikhq> ehird: Gets the address of a goto label.
10:19:18 <themroc--> someone wrote a paper about bogosort
10:19:25 <Peaker> skimpy: its often a choice between goto's and a lot of nesting or breaking up into functions just to get "return" to jump where you want, and not because it makes sense, and then its hard to even name such a function..
10:19:29 <themroc--> some ppl have too much sparetime
10:19:39 <ehird> pikhq: Oh, right.
10:19:41 <Badger> ehird: are you lisping? :P
10:19:58 <ehird> Badger: Pφφt, my replacements are merely ðe elegant ſtuφφ oφ... ſtuφφ.
10:20:06 <ehird> I wonder iφ ſtuφφ ſhould have two φis in a row.
10:20:10 <ehird> Pφφt too.
10:20:17 <pikhq> Heh.
10:20:20 <skimpy> Peaker: I didn't say one wouldn't use it for cleanup, but i try to avoid using it whenever i can.
10:20:25 <Rotaerk> ..
10:21:07 <kynky> for every rule there is an exception
10:22:11 <ehird> kynky: Ðere are exceptions to ðat rule.
10:22:26 <mauke> switch is basically computed goto
10:23:27 <pikhq> mauke: Yes, but GNU C has true, honest computed goto.
10:24:07 <saml> ehird, how can you type so cool?
10:24:09 <pikhq> One takes the address of a label with &&, which results in a void *, and one dereferences that with * when you want to go to it.
10:24:17 <kynky> switch is sometimes less verbose than if else, easier to read through, but switch is normally in one confied place, goto can go anywhere
10:24:17 <ehird> ſaml: Magical arcane ſecrets; alſo a patch to my client.
10:24:21 <ehird> %saml, raðer.
10:24:24 <ehird> Hmm.
10:24:27 <ehird> I mißed ðat eſcape; darn.
10:25:34 <mauke> just wrap your whole function in a switch :-)
10:27:07 <Peaker> skimpy: basically, the "rule" is that goto is only allowed to jump forward, and in a nested, not interlaced, fashion. With this rule, you don't lose much over the goto's.  If you have auto-destructors or exceptions you don't need goto's at all
10:28:03 <skimpy> Peaker: Yes of course, but i've seen way to much bloat in somde code overusing goto's. That is why i avoid it like the plaque
10:28:05 <benmachine> I think I once wrote a do {} while(0); loop just so I could break; in the middle
10:28:11 <benmachine> that was not one of my proudest moments
10:28:28 <Peaker> benmachine: do {} while(0) usually wraps macros
10:28:43 <mauke> benmachine: a goto would have been better
10:28:45 <benmachine> yeah I know but that's for different reasons
10:29:13 <benmachine> mauke: rewriting the code so it wasn't rubbish'd have been even better than that :P
10:29:23 <benmachine> (yes it was rubbish, and not solely because of that)
10:30:31 <olsner> goto actually seems cleaner than do/while with break
10:30:56 <benmachine> olsner: it is
10:31:23 <benmachine> I suppose my example meant, you should avoid a style of coding that is often characterised by use of goto
10:31:30 <benmachine> rather than just avoiding using the goto keyword
10:34:26 <pikhq> Which implies that C should be avoided.
10:34:36 <Rotaerk> there's nothing inherently wrong with goto
10:35:04 <Rotaerk> it's just that you should use as specific a mechanism as is available, and in most languages there's always something more specific to use than goto
10:35:12 <Rotaerk> err most decent languages
10:35:23 <nagnatron> i think the only problem is with overuse where you have to scroll around a lot
10:35:31 <nagnatron> to see what is going on
10:35:40 <Rotaerk> it'd be like using manual recursion instead of fold, or fold instead of map
10:36:45 <Phillemann> Can I get ghc to not spam my directory with .hi and .o files?
10:36:55 <olsner> I think the real problem lies in representing computations using control flow - haskell has the nice feature that you usually don't have control flow but rather data flow
10:37:00 <Rotaerk> there's also the fact that there may be some things goto can do that other flow-control mechanisms can't do, but it's questionable whether they *should* be done at all anyway
10:37:00 <Saizan> Phillemann: -odir -hidir
10:37:04 <olsner> in C data flow is only implicit in the control flow
10:37:11 <Phillemann> Saizan: Ahhh, great, thanks.
10:37:36 <Rotaerk> I mean it's not uncommon for a programming mechanism to be more powerful than it should be, allowing for abuse
10:37:55 <Rotaerk> e.g. inheritance usable outside of liskov substitution
10:38:42 <olsner> I have heard that someone proved at some point that there is actually nothing you can do with goto that you can't do with if and while
10:39:17 <benmachine> olsner: as fast, and as simply?
10:39:18 <pikhq> olsner: ... Yes, that's trivial to prove.
10:39:26 <pikhq> I do it all the time in Brainfuck.
10:39:42 <Rotaerk> the only case I've found where there doesn't seem to be an appropriate alternative to goto is when you want to break out of multiple loops at once
10:39:55 <Rotaerk> although it's questionable whether you should do that anyway...
10:40:09 <benmachine> Rotaerk: usually I use return for that
10:40:24 <benmachine> doesn't always cut it but quite often it does
10:40:26 <Rotaerk> yea you can factor things into a function to allow for that
10:40:44 <Rotaerk> factor things such that the loops are all that's in the function, that is
10:41:18 <Saizan> tsk, just use a MaybeT or EitherT layer
10:41:50 <burp> > (4 * atan (1/5) - atan (1/239)) * 4   - pi
10:41:52 <lambdabot>   4.440892098500626e-16
10:42:26 <Rotaerk> burp, i.e. 0
10:42:30 <burp> yup ;)
10:43:16 * benmachine ponders whether or not to draw some triangles in the hope of working this out
10:43:45 <benmachine> I don't see any reason why it should be the case
10:44:45 <soupdragon> draw some triangles
10:44:50 <soupdragon> always draw some triangles
10:45:01 <benmachine> yessir
10:45:02 <burp> > showCReal 100 $ (4 * atan (1/5) - atan (1/239)) * 4   - pi
10:45:04 <lambdabot>   "0.0"
10:45:11 <burp> > showCReal 10000 $ (4 * atan (1/5) - atan (1/239)) * 4   - pi
10:45:17 <lambdabot>   mueval-core: Prelude.read: no parse
10:45:17 <lambdabot>  mueval: ExitFailure 1
10:45:20 <burp> alright ;)
10:45:23 <beutdeuce> Question, I'm trying to recreate the tails function in Haskell for Mathematica, but i'm constantly getting some recursion problems. If anyone knows anything about programming in Mathematica, I will greatly appreciate any help. What I have so far is: Tails[x_] := Append[First[x], Tails[Rest[x]]]
10:46:14 <beutdeuce> or rather, Append[x, Tails[Rest[x]]]
10:46:25 <lilac> beutdeuce: i know nothing about mathematica, but where's your base case?
10:46:37 <lilac> (what happens when the list is empty?)
10:47:09 <beutdeuce> i tried telling it that Tails[] = [], but it didnt want to interpret that
10:47:20 <kulakowski> benmachine: Do you know of the formula pi/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 ...
10:47:48 <EvilTerran> beutdeuce, does mathematica have a function which tells you if a list is empty?
10:47:52 <EvilTerran> (i'm guessing so, but don't know what it'd be)
10:47:59 <beutdeuce> should
10:48:07 <benmachine> kulakowski: yeah
10:48:17 <kulakowski> Do you know how to derive it?
10:48:38 <benmachine> maclaurin series for some inverse trigonometric function?
10:48:51 <benmachine> arccos(0) maybe
10:48:59 <kulakowski> arctan, actually
10:49:04 <benmachine> k
10:49:10 <benmachine> oh, yeah
10:49:22 <benmachine> makes sense
10:50:24 <burp> > showCReal 1000 $ 2 * acos 0 - pi
10:50:30 <lambdabot>   "0.0"
10:50:44 <burp> CReal is so nice
10:51:10 <burp> I wonder how pi is calculated within CReal
10:52:18 <kulakowski> So in that formula above, you had atan(1/5) and atan(1/239), so instead of the series for arctan x, we want arctan 1/x = 1/x - 1/(3x^3) + 1/(5x^5) - 1/(7x^7) ...
10:52:29 <burp> r of decimals
10:52:29 <burp> -> CReal	The real number
10:52:29 <burp> -> String	The resulting string
10:52:29 <burp> The showCReal function co
10:52:34 <burp> oops, sorry
10:52:52 <burp> pi = 16 * atan (fromRational (1 % 5))  - 4 * atan (fromRational (1 % 239)) <- this is just CReal's definition of pi
10:52:52 <olsner> @info showcreal
10:52:53 <lambdabot> showcreal
10:53:04 <olsner> @index showCReal
10:53:04 <lambdabot> bzzt
10:53:11 <olsner> @info showCReal
10:53:11 <lambdabot> showCReal
10:54:08 <Fairweather> how do you call a function which maps a set to itself?
10:54:28 <psault> confusing is how I call it. all this Haskell
10:54:29 <kulakowski> Then you get a bunch of relations pretty easily, like the one above, or pi/4 = 44 arctan 1/57 + 24 arctan 1/1068 + 12 arctan 3/3001 - 5 arctan 1/239...i'm trying to find a decent explanation online if you are curious
10:54:50 <Fairweather> :)
10:54:50 <siki> Hi everyone! What's the best way (if ther is one) to make a variable "global" accross modules or even just in one module. For example: I have a bunch of functions that do queries in a database and I'd like to re-use the same connection without having to pass it around in a variable.
10:54:55 <benmachine> kulakowski: thanks, I'll see if I can work it out
10:55:05 <kulakowski> Fairweather: Do you just mean a function f :: Set -> Set, or one with some property like being one-to-one?
10:55:07 <benmachine> kulakowski: i.e. don't bother looking on my account
10:55:16 <mauke> siki: why don't you use a Reader monad?
10:55:24 <Fairweather> the former
10:55:35 <kulakowski> benmachine: Gregory and Størmer would be names to search for
10:55:43 <Fairweather> it's been bugging me since yesterday
10:55:56 <jmcarthur_work> siki, i would definitely use a reader monad for that
10:56:06 <kulakowski> endofunction?
10:56:48 <siki> Ok I'll look into that.
10:57:13 <Fairweather> kulakowski: thank you!
10:57:38 <kulakowski> Yeah endofunction seems to be at least semi-standard, perhaps less so than words like 'automorphism' or 'endofunctor' though.
11:00:21 <Fairweather> I see
11:00:37 <Fairweather> what is the difference in a nutshell?
11:01:13 <Fairweather> or maybe I should just read it myself :) thanks anyway
11:01:31 <kulakowski> Oh sorry that might have been confusing. I only meant that you'll probably see the word `endofunction' much less used than automorphism or endofunctor, not that they are the same things.
11:02:35 * doserj never saw the word endofunction. only endomorphism
11:02:38 <CalJohn> kulakowski: intersting, I didn't realise that CT terms were so new
11:03:23 <Fairweather> kulakowski: that's not saying a lot since this is the first time I've heard any of them
11:03:49 <kulakowski> CalJohn: I've never actually used or heard endofunction before, just guessed that someone might have used it.
11:03:50 <CalJohn> Fairweather: I'm guessing most people will know what you mean if you say endofunction.
11:05:24 <Fairweather> well, there's a wikipedia entry and that's good enough for me; so you're saying that the word comes from category theory?
11:06:39 <kulakowski> Fairweather: An endomorphism is a morphism from A to A in some category. In the category of sets, morphisms are functions, so an endofunction is a function A->A.
11:06:40 <CalJohn> Fairweather: the WP page defines it more broadly than f :: a -> a though
11:07:48 <CalJohn> *differently, tbh
11:07:51 <kulakowski> CalJohn: and i'm actually curious now how much some of the language (morphism and derived terms) predate 1930 or so, if at all
11:08:37 <CalJohn> kulakowski: tbh, I'm not some kind of expert, but I frequently get the impression that the a lot of the terms are neologisms using stolen greek stems
11:09:20 <Fairweather> "In mathematics, an endofunction is a function whose codomain is a subset of its domain."
11:09:20 <CalJohn> IIRC, the "bananas, lenses and barbed wire" paper talks about etymology
11:09:35 <Fairweather> this sounds right to me
11:10:19 <Phillemann> I've got two threads in my program, one is waiting for both input on a handle and for a takeMVar to return. The other one fills the mvar. However, this doesn't seem to work properly. The call to putMVar blocks until input arrives on the handle in the other thread.
11:10:19 <kulakowski> I found it rather surprising that just the notation -> for functions (morphisms etc.) doesn't really predate category theory, and in some sense that idea, of arrows going from one place to the next, is what categories *are*
11:10:38 <Phillemann> I use Unamb.race to wait for the input and the takeMVar
11:11:34 <CalJohn> kulakowski: you're making me want to read the original paper to see :)
11:13:23 <Saizan> Phillemann: is the MVar initially empty?
11:13:32 <Saizan> Phillemann: putMVar blocks if it's full
11:14:08 <Phillemann> Saizan: It's empty, yes. I call newEmptyMVar to create it.
11:15:08 <Saizan> ?hoogle Unamb
11:15:09 <lambdabot> Distribution.Simple.PackageIndex Unambiguous :: a -> SearchResult a
11:15:31 <kulakowski> CalJohn: I've never personally read any of the stuff mac lane and eilenberg wrote in the 1940s (I have the impression that all of it is very directed towards axiomatizing homology, so maybe isn't too enlightening from a general point of view)
11:16:03 <Berengal> Haha, jhp is quite the entertainer
11:17:41 <CalJohn> kulakowski: yeah, but still, I have a strong interest in CT, would like to look at it for historical reasons
11:20:34 <Phillemann> No matter if I use forkIO or forkOS, -threaded or not threaded, this doesn't work. Hmmmm.
11:21:01 <Berengal> Phillemann: Did you try -more-magic?
11:21:35 <Phillemann> Is that a ghc parameter?
11:21:38 <kulakowski> #
11:21:43 <CalJohn> Phillemann: i think it's a jargon file joke
11:21:51 <Berengal> http://catb.org/esr/jargon/html/magic-story.html
11:22:13 <Phillemann> Hm.
11:23:19 <grahamhutton> <advert> if you haven't done so already, make sure to register for ICFP in Edinburgh, as the early deadlines are fast approaching: http://www.cs.nott.ac.uk/~gmh/icfp09.html lots of great talks, in a great city! </advert>
11:50:38 <kulakowski> Not exactly haskell related, but is `bodge' something like kludge?
11:53:41 <Phillemann> Is there a hWaitForInput which doesn't block all other threads while waiting?
11:59:22 <CalJohn> kulakowski: yes, it's just more english
11:59:59 <kulakowski> thought so
12:10:18 <agapoulitsas> > map (+1) [1..10]
12:10:20 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
12:10:46 <burp> does ghci have an autoload file? I would like to import some stuff on every start
12:11:03 <Vanadium> .ghci should do
12:11:12 <Vanadium> You can put : commands in it
12:11:18 <burp> thanks
12:11:35 <olsner> you can have haskell expressions in it as well
12:12:00 <olsner> looks like it's interpreted exactly like what you would enter at the prompt
12:15:33 <Raevel> so, i have this regex that i want to translate to parsec combinators, ^.+<[^>]+><[^>]+>.+, but i cannot figure out how, any ideas?
12:17:12 <Raevel> ^.+ turns out eager, and gives an unexpected eof when the next combinator is parsing, instead of backtracking
12:18:26 <soupdragon> you should write a regex->parsec compiler
12:20:14 <paolino> Phillemann: http://www.haskell.org/pipermail/glasgow-haskell-users/2004-October/007218.html
12:21:09 <paolino> I think threaded is needed
12:23:54 <heatsink> Can I use unsafeCoerce# instead of mapping a newtype constructor or deconstructor over the elements of a list?
12:25:41 <quicksilver> heatsink: I believe so. normally it doesn't matter though
12:26:29 <heatsink> It compiles to 'map id', when it should just compile to 'id'.
12:26:49 <pikhq> heatsink: Possibly, but you shouldn't.
12:27:02 <pikhq> unsafeCoerce# is t3h ebil.
12:27:04 <pikhq> ;)
12:27:18 <heatsink> I see a call to map in the cmm output, which is silly since it's not doing anything.
12:27:42 <mauke> optimizer bug
12:27:45 <FunctorSalad> :(
12:28:09 <coreyoconnor> anything to do with laziness?
12:28:51 <coreyoconnor> like, perhaps the mapping of id forces some thunks that id otherwise wouldn't
12:29:01 <coreyoconnor> err "mapping of id" => map id
12:29:02 <heatsink> Hmm, I don't think it would change strictness at all.
12:29:15 <coreyoconnor> aye
12:29:26 <FunctorSalad> I thought it had to do with rewriting rules
12:29:30 <coreyoconnor> though if it was a data constructor it would?
12:29:35 <FunctorSalad> is there some way around that problem?
12:29:37 <coreyoconnor> hm
12:29:56 <soupdragon> map id
12:30:21 <soupdragon> head . map id = head . id
12:30:49 <soupdragon> tail . map id = map id . tail
12:31:00 <pikhq> @t map id
12:31:01 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:31:13 <pikhq> :t map id
12:31:15 <lambdabot> forall a. [a] -> [a]
12:31:18 <soupdragon> head . map id = id . head
12:31:53 <pikhq> I guess it stays 'map id' to enforce that it's a list¿
12:31:59 <soupdragon> who?
12:32:07 * pikhq shrugs
12:32:21 <FunctorSalad> <mauke> optimizer bug
12:32:22 <soupdragon> who writes map id?
12:32:37 <soupdragon>  <heatsink> Hmm, I don't think it would change strictness at all.
12:32:39 <FunctorSalad> something about the newtype unfolding at the wrong time ISTR
12:32:47 <soupdragon> I think that is correct
12:32:57 <soupdragon> how can we prove this?
12:36:50 <heatsink> soupdragon: You can probably prove that strictness isn't change by coinduction over the list, regarding _|_ as an inhabitant of both type [α] and type α.
12:37:06 <soupdragon> oh oh
12:37:15 <soupdragon> you got it
12:37:52 <soupdragon> {_|_, [], ():_|_, ():[], ...}
12:38:05 <quicksilver> heatsink: but in a real program, you'd probably do something with the items in the list
12:38:12 <quicksilver> heatsink: and then list fusion would ocollapse it
12:38:17 <soupdragon> we just have to show it's equal for all those right
12:38:18 <soupdragon> ?
12:38:46 <soupdragon> hmm
12:39:03 <soupdragon> thhat doesn't cover infinite lists
12:39:20 <beutdeuce> is there a way to extend the maximum token length from 4000?
12:39:32 * mauke raises an eyebrow
12:39:38 <lilac> map id [] = [] = id []; map id (x:xs) = id x:map id xs = x:map id xs = x:xs (by structural induction) = id (x:xs)
12:39:51 <FunctorSalad> soupdragon: maybe write "map" as "fix", then fixpoint induction or something
12:40:01 <lilac> beutdeuce: try running your identifiers through md5 first
12:40:13 <heatsink> :)
12:40:25 <beutdeuce> ?
12:40:47 <lilac> (i forgot the most important one, map id _|_ = _|_ = id _|_)
12:41:39 <Badger> @index (_|_)
12:41:39 <lambdabot> bzzt
12:41:42 <lilac> beutdeuce: if you have a token longer than 4000 characters, chances are the root cause of your issue doesn't lie in the compiler
12:41:45 <Badger> @hoogle (_|_)
12:41:45 <lambdabot> Parse error:
12:41:45 <lambdabot>   --count=20 (_|_)
12:41:45 <lambdabot>               ^
12:41:54 <lilac> @let (_|_) = (_|_)
12:41:55 <lambdabot>   Parse error in expression: HsEitherRP HsWildCard HsWildCard
12:41:59 <lilac> :(
12:42:09 <Badger> ooh
12:42:19 <Badger> so it is actually _ or _
12:42:27 <beutdeuce> no , its part of a problem?
12:42:32 <Badger> oh.
12:42:47 <beutdeuce> i need to use a token 5000 long
12:42:52 <lilac> > let _|True in 42
12:42:54 <mauke> beutdeuce: why?
12:42:54 <lambdabot>   <no location info>: parse error on input `in'
12:43:02 <lilac> > let _ |True in 42
12:43:03 <lambdabot>   <no location info>: parse error on input `in'
12:43:09 <beutdeuce> mauke: http://projecteuler.net/index.php?section=problems&id=13
12:43:36 <lilac> > let _| True = 1 in 42
12:43:38 <lambdabot>   42
12:43:44 <mauke> beutdeuce: why do you need a 5000 char token for that?
12:43:56 <beutdeuce> i want to map digitToInt
12:44:10 <soupdragon> >>>
12:44:12 <soupdragon> ???
12:44:20 <benmachine> _|_ is a bastardised rendering of the mathematical equivalent of undefined
12:44:27 <mauke> beutdeuce: why?
12:44:42 <mauke> ⊥
12:44:42 <beutdeuce> so then i can take 50 from its tails
12:44:50 <mauke> beutdeuce: what the hell
12:45:10 <lilac> beutdeuce: why not just copy the problem, add + between the numbers and then run it?
12:45:41 <beutdeuce> thats not what its asking fir
12:45:44 <mauke> http://p3rl.org/8563PTVR <- complete solution, doesn't require hax
12:45:49 <lilac> beutdeuce: yes, it really is
12:46:28 <lilac> beutdeuce: i'm assuming you can 'work out the first ten digits' of a given number by hand, though :)
12:46:54 <lilac> mauke: what about l33t hax?
12:47:24 <lilac> or even 75506164965184775180738168837861091527357929701337 hax?
12:48:19 <FunctorSalad> so you can't have numerals with more than 4000 digits in haskell?
12:48:38 <lilac> FunctorSalad: i think the problem is numeric literals in your source code longer than that
12:48:53 <lilac> Integer has no limits other than those imposed by the machine on which it runs :)
13:05:51 <Ke> kolmodin: http://pastebin.com/m2a03aa55 newest x11 fails to build missing module Data.Generics
13:07:44 <kolmodin> Ke: you are very welcome to join #gentoo-haskell
13:11:51 <kulakowski> Is there a nicer way to typeset the brackets for cata/ana/hylo/paramorphisms in latex than by explicity giving the spacing between things?
13:12:05 <FunctorSalad> ski: is that you? :o http://www.cafepress.com/skicalc.6225368#
13:14:36 <heatsink> kulakowski: You can try something like \mathopen{(\mspace{-2mu}|}
13:14:40 <beutdeuce> i'm getting a segfault
13:17:39 <beutdeuce> why am i getting a segfault? => http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7132#a7132
13:18:00 <heatsink> Oh, nicer?  Not that I know of.
13:18:17 <thoughtpolice> beutdeuce: looks like it could be a GHC bug?
13:18:19 <thoughtpolice> @where trac
13:18:20 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
13:19:48 <mauke> Stack space overflow: current size 8388608 bytes.
13:20:09 <mauke> but no segfault
13:20:39 <mauke> also works fine with a 40M stack
13:32:23 <Mr_Awesome> how can i tell if a certain expression has been evaluated?
13:33:13 <mauke> why do you need to know?
13:33:23 <Gracenotes> well, to ensure full evaluation, the NFData typeclass tries to ensure that
13:34:07 <soupdragon>  <Mr_Awesome> how can i tell if a certain expression has been evaluated?
13:34:15 <soupdragon> Mr_Awesome: trace
13:34:24 <mauke> soupdragon: why did you copy his line?
13:34:44 <soupdragon> mauke I did it with yours too :(
13:34:49 <monochrom> Ah! Yes, Debug.Trace.trace
13:34:56 <Beelsebob> soupdragon: isEvaluated x = x `seq` True
13:35:02 <Gracenotes> generally one can know if an expression has been evaluated by just following the code
13:35:04 <benmachine> hah
13:35:04 <soupdragon> lol
13:35:22 <Gracenotes> Beelsebob: well. that just evaluates to the outermost constructor if any :)
13:35:30 <monochrom> But why do you want to know?
13:36:01 <kulakows1i> thanks whoever said the \mathopen thing. it seems like slighty less of a hack than I was trying before, and breaks less badly with different fonts.
13:36:02 <Gracenotes> laziness is very useful; in many cases it makes code more efficient
13:36:15 <Mr_Awesome> i'm looking at someone's trie code and trying to figure out exactly why the key is "hyper-evaluated"
13:36:18 <Beelsebob> Mr_Awesome: as may or may not be clear by now... you probably don't need to know -- what is it you're doing that makes you think you need it?
13:36:34 <Beelsebob> ah, then use trace to print when it gets evaluated
13:36:47 <monochrom> Ah I see. Yes, Debug.Trace.trace is the most convenient way to see what happens when.
13:37:04 <Mr_Awesome> okay then. thanks.
13:37:33 <monochrom> It's OK to go "I need debugging tools" if it's someone else's undocumented code.
13:38:20 <monochrom> For my own code my principle is "I am supposed to know what I'm coding about".
13:38:46 <benmachine> wanting something doesn't make it true :P
13:40:02 <monochrom> I have the ability, too.
13:40:25 <kulakows1i> Having to tell latex to move something 6 units some direction still seems like a hack though.
13:40:26 <monochrom> Frankly, IMO if one doesn't have the ability, one shouldn't bother.
13:40:47 <benmachine> monochrom: perhaps one should acquire the ability?
13:40:53 <monochrom> Yes.
13:40:54 <benmachine> I hope so anyway :(
13:41:17 <monochrom> To acquire this particular ability, you still don't need much debugging tools in the course.
13:41:23 <benmachine> heh
13:41:25 <benmachine> fair enough
13:41:30 <monochrom> You need proving tools, though.
13:43:17 <heatsink> kulakows1i, A lot of stuff does get hard-coded in LaTeX, in practice, even though latex is supposed to be flexible.
13:45:23 <kulakowski> heatsink: I know. Doesn't feel like any less of a hack though, especially since it seems like so much work went into exactly specifying all the glyphs in some of these fonts, I want it to be able to calculate for itself how to move it rather then guessing amounts.
13:45:29 <kulakowski> Anyway thanks
13:45:59 <heatsink> np
13:55:43 <kniu> I was thinking about a crazy type system where there is no distinction between types and values.
13:55:55 <kniu> What happens when a value is its own type?
13:56:02 <heatsink> russel's paradox?
13:56:34 <kniu> oh, dang.
13:57:34 <monochrom> russell's paradox requires a bit more something else. you may still be spared.
13:57:52 <monochrom> (Just don't allow "type/value comprehension" :) )
13:58:01 <heatsink> What is comprehenson?
13:58:17 <monochrom> { x | x not in x }
13:58:27 <heatsink> oh
13:59:04 <kniu> Well, let's see.
13:59:18 <kniu> Say all you have is the ability to abstract and declare constructors.
13:59:37 <lilac> does haskell not flush stdout when i read from stdin?
13:59:53 <monochrom> You have to carefully write down your type system, then you have to look for a model or try to prove contradiction, in order to be sure.
14:00:00 <monochrom> No lilac.
14:00:11 <lilac> eww. that bug was fixed in C /years/ ago :(
14:00:15 <lilac> @type hFlush
14:00:17 <lambdabot> Not in scope: `hFlush'
14:00:39 <mauke> was it?
14:00:45 <mauke> chapter and verse, please!
14:00:48 <monochrom> If you say so.
14:01:00 <benmachine> why would it?
14:01:32 <monochrom> I mean, there are several aspects of that statement I disagree with. For example the "bug" part. And for example the "fixed" part, i.e., I think it is "clutched" not "fixed".
14:02:01 <monochrom> For example C++ introduced this "tied stream" hack.
14:02:21 <lilac> mauke: 7.19.3.3 according to a brief googling
14:02:24 <monochrom> Well maybe "tied stream" is OK because it's rather general.
14:02:38 <benmachine> C introduced this "C++" hack >_>
14:03:15 <lilac> mauke: although that does temper it by saying "support [...] is implementation-defined"
14:03:19 <monochrom> I don't understand why any professional program needs it.
14:04:04 <lilac> monochrom: what disadvantages does it have?
14:04:40 <monochrom> If you use stdin/stdout for piping, you don't need it. If you use stdin/stdoud for user interfacing, you should be ncursing. If you use GUI for interfacing, stdin/stdout is irrelevant.
14:05:31 <monochrom> There is no professional use case for tying stdin/stdout. There are only CS 101 toy program use cases.
14:06:03 <lilac> huh? so programs which do IO using stdin and stdout are not professional now?
14:06:11 <lilac> i guess i better go tell everyone! :)
14:06:16 <monochrom> But CS 101 toy programs use Python or Java these days anyway.
14:06:34 <monochrom> Do you understand what I wrote? I guess you don't.
14:06:43 <lilac> monochrom: i understand, but it's false
14:06:56 <lilac> saying "you should be ncursing" just doesn't fly
14:07:05 <pikhq> ... "You don't need stdin/stdout for piping".
14:07:05 <monochrom> "If you use stdin/stdout for piping" that's IO. It doesn't need tying.
14:07:12 <pikhq> UN-UNIX HEATHEN!
14:07:30 <mauke> pikhq: what?
14:07:43 <monochrom> "If you use stdin/stdoud for user interfacing" that's IO. You should use ncurse for that. Still no need for tying.
14:07:52 <lilac> monochrom: you'll notice that the C standard goes into detail on that point, excluding that case from the stream tying
14:08:07 <lilac> monochrom: and what if one can't or doesn't want to use ncurses?
14:08:13 <monochrom> Tell me a stdin/stdout IO usage that is not one of those two cases.
14:08:20 * SamB wonders what kind of tools there are for access profiling, in general
14:08:28 <monochrom> I don't care about "want". I am saying "should".
14:08:30 <mauke> ncurses shouldn't touch stdin/stdout at all
14:08:41 <lilac> monochrom: how about portable programs, which need to run on platforms where ncurses isn't?
14:08:42 <mauke> it should use the program's tty
14:09:09 <SamB> mauke: is that what you think it should *do*, or what the documentation seems to indicate?
14:09:10 <lilac> monochrom: hwo about programs whihc can't use ncurses because it insists on switching to altscreen?
14:09:26 <mauke> SamB: it's what I think it should do
14:09:35 <pikhq> SamB: That's what curses in general *does*.
14:09:36 <mauke> IIRC it actually uses stdin or something
14:09:42 * SamB thinks maybe it should be able to do either
14:10:01 <SamB> but I'm not sure I agree about what it should default to
14:10:04 <mauke> lilac: disable altscreen in your terminal
14:10:29 <SamB> ncurses can certainly manage without altscreen
14:10:35 <SamB> some terminals don't offer one
14:10:50 <lilac> mauke: umm, I *want* altscreen, but not in this program
14:10:56 <SamB> (I believe screen's terminfo does not advertise it)
14:11:13 <lilac> SamB: screen's altscreen is off by default and quite broken
14:11:15 <SamB> there's probably some way to override it?
14:11:29 <lilac> SamB: I have patches which are hopefully going to be in the next screen release which fix that, though
14:11:35 <lilac> (the latter, not the former)
14:11:40 <SamB> lilac: ah, that would certainly help explain why it's not advertised
14:11:58 <SamB> lilac: though I also think it makes scrollback less useful
14:12:27 <lilac> the key problem with screen's altscreen support is that there's no way to switch back to altscreen without clearing it
14:12:42 <lilac> (it also had some memory management issues iirc)
14:12:52 <SamB> lilac: are you also advocating a new family of terminfo entry that advertise it?
14:13:22 <lilac> no. the changes actually make screen act /more/ like xterm in terms of altscreen support
14:14:07 <SamB> lilac: but screen uses TERMscreen(-*)
14:14:10 <SamB> er.
14:14:12 * pikhq dislikes altscreen
14:14:16 <SamB> TERM=screen(-*)
14:14:34 <lilac> SamB: yes, but altscreen (IIRC) came from xterm, and the termcap is the same for both
14:15:01 <SamB> lilac: oh, termcap? you still use that?
14:15:02 <lilac> (the ti/te sequences)
14:15:05 <SamB> oh.
14:15:07 <uzytkownik_> @hoogle (a -> m b) -> m [a] -> m [b]
14:15:08 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:15:08 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:15:08 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
14:15:21 <SamB> lilac: I was pretty sure screen's entry omitted that
14:15:49 <lilac> i vaguely recall there being multiple terminfos for screen
14:17:25 <SamB> lilac: there are
14:18:01 <SamB> but I think the ones from ncurses are all alike in this respect
14:18:20 <Saizan> what's altscreen?
14:18:28 <SamB> could be wrong, though
14:19:28 <lilac> inside screen my $TERMCAP contains ti=\E[?1049h:te=\E[?1049l
14:20:02 <lilac> Saizan: you know how full-screen terminal applications restore the contents of the terminal (and the scrollback) when they're done?
14:20:39 <lilac> altscreen is a separate terminal buffer which they switch to, to allow that
14:21:35 <Saizan> ah, ok
14:22:34 <trofi> how to hide base-4 from 'ghc' commandline not knowing exact base version?
14:22:59 <monochrom> That seems pretty hard.
14:23:01 <trofi> smth. like -hide >=base-4
14:23:51 <Saizan> i don't think you can
14:24:10 <SamB> stupid!
14:24:12 <Saizan> but you can do that easily via cabal
14:24:20 <SamB> stupid GHC
14:25:14 <trofi> i'd like to patch as less as possible for darcs-2.1.0
14:25:15 <Saizan> ICBW
14:25:24 <trofi> it isn't cabalized :[
14:26:19 <Saizan> i guess you need to query ghc-pkg then
14:26:33 <trofi> i see. ok
14:27:08 <trofi> ghc-pkg list --simple-output base-4\*
14:27:17 <themroc--> hmmm
14:27:21 <themroc--> i have a weird issue:
14:27:25 <themroc--> yo :: Int -> Int
14:27:25 <themroc--> yo x = x+1
14:27:25 <themroc--> test = (mod yo)
14:27:31 <themroc--> that doesnt work
14:27:44 <themroc--> and i dont understand
14:27:51 <uzytkownik> Is it possible to make it nicer: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7133#a7133?
14:28:11 <monochrom> What is "doesn't work"? What do you want it to do?
14:28:21 <themroc--> well
14:28:27 <SamB> hmm, okay, so screen *does* advertise smcup/rmcup (ti/te) sequences :-(
14:28:28 <monochrom> Oh right, (mod yo) is very ill-typed.
14:28:28 <themroc--> we have this function:
14:28:37 <themroc--> geschuetzte_dreiundzwanzig = (schuetze_funktion nichtnull dreiundzwanzig)
14:28:47 <monochrom> Do you know what "mod" does?
14:29:02 <themroc--> schuetze_funktion takes one function and one int as argument
14:29:11 <themroc--> and if True, call dreiundzwanzig
14:29:31 <Saizan> uzytkownik: does that typecheck? it looks like you miss an argument to liftM2
14:29:34 <themroc--> and if i do :t schuetze_funktion it gives me Double -> Double
14:29:42 <themroc--> and not the partial types of the functions
14:30:02 <themroc--> so i assumed i can use this way to just define a shortcut for a function queue
14:30:05 <uzytkownik> Saizan: It's part of code (i.e. in where)
14:30:43 <uzytkownik> Saizan: Ops. Not everything copied
14:31:22 <Saizan> themroc--: no shortcuts :)
14:31:29 <uzytkownik> Saizan: Updated: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7133#a7134
14:31:32 <monochrom> If schuetze_funktion :: Double -> Double, there is no way (schuetze_funktion nichtnull dreiundzwanzig) typechecks successfully.
14:31:37 <themroc--> i thought i can call test 6 4 and it gives me 3
14:32:07 <Saizan> mod yo means apply the function mod to the function yo, as if yo was a number (in this case
14:32:15 <themroc--> ah ic
14:32:16 <themroc--> but ok
14:32:23 <monochrom> (mod yo) is very ill-typed. mod expects yo to be a number, but your yo is not.
14:32:33 <themroc--> (schuetze_funktion nichtnull dreiundzwanzig): schuetze needs a function and a Num
14:32:55 <themroc--> why can it take the parameter from geschuetzte_dreiundzwanzig ?
14:33:02 <themroc--> like if i type geschuetzte_dreiundzwanzig 72
14:33:04 <themroc--> it works
14:33:25 <themroc--> or i mess things up
14:33:39 <themroc--> oh yeah i do
14:34:52 <themroc--> ok sorry for bothering you :(
14:35:32 <monochrom> My own grief is that what you said contains a self-contradiction as far as I can tell.
14:35:49 <themroc--> yeah i realized
14:36:06 <themroc--> but i can define like test = myverylongsuperfunction
14:37:08 <themroc--> i just dont understand why geschuetzte_dreiundzwanzig = (schuetze_funktion nichtnull dreiundzwanzig) does infer only Double -> Double
14:37:31 <mauke> without context: monomorphism restriction
14:37:43 <themroc--> since schuetze_funktion is being called , which calles nichtnull and eventually calles dreiundzwanzig
14:37:51 <themroc--> this should be a lot of -> :p
14:38:28 <monochrom> schuetze_funktion should be a lot of ->, yes.
14:38:46 <themroc--> but its not
14:38:51 <Saizan> themroc--: can you paste the code?
14:38:52 <themroc--> ah yes
14:38:54 <themroc--> ok
14:39:08 <Saizan> it's getting mysterious otherwise :)
14:40:00 <Saizan> uzytkownik: you'd need something like unfoldrM to make that "nicer2
14:40:15 <themroc--> http://pastebin.com/m71f925d
14:40:22 <uzytkownik> @hoogle unfoldrM
14:40:23 <lambdabot> No results found
14:40:31 <themroc--> im discussing with a buddy and we have no clue
14:41:06 <mauke> your function names are awful, btw
14:41:24 <monochrom> They're fine function names. I don't get distracted by them.
14:41:28 <Botje> themroc--: word of advice: use english function names if you're going to ask for help
14:41:28 <themroc--> its defined by university
14:41:29 <mauke> heh
14:41:35 <themroc--> im just trying to understand
14:41:36 <Botje> they're too long, imo :)
14:41:42 <themroc--> yeah of course
14:41:43 <themroc--> haha
14:41:43 <mauke> == True is redundant
14:41:58 <jlaire> the ges... is equal to \x -> if x /= 0 then 23/x else undefined
14:42:01 <themroc--> i didnt write that
14:42:06 <themroc--> i just c/p
14:42:31 <maltem> The smell of the monomorphism restriction is getting stronger
14:42:34 <Botje> themroc--: you should think of it as follows:
14:42:36 <Saizan> themroc--: what are you confused about? Double -> Double instead of Fractional a => a -> a
14:42:39 <Saizan> ?
14:42:42 <themroc--> and the question is: what type does geschuetzte_dreiundzwanzig infer
14:42:45 <Botje> every time you give a function (with type signature a -> b -> c -> ...) an argument
14:42:57 <Botje> that argument should have the first one on the chain (a, in this case)
14:43:04 <themroc--> and i would have guessed its a list of the different function headers
14:43:06 <Botje> and the resulting function has type b -> c -> ...
14:43:10 <themroc--> but no its just Double Double
14:43:48 <monochrom> Yes monomorphism restriction definitely.
14:43:49 <Botje> themroc--: no, the type of a function just states what it "needs" and what it returns
14:44:00 <Saizan> rewrite it as: "geschuetzte_dreiundzwanzig x = schuetze_funktion nichtnull dreiundzwanzig x" and you'll get the polymorphic type
14:44:00 <themroc--> oh
14:44:10 <themroc--> Botje that makes it clear
14:44:33 <Botje> (+) is (for example) Int -> Int -> Int, but (+ 5) is Int -> Int
14:44:55 <Botje> (+) takes two ints and returns one, while (+ 5) already has one Int, so only needs one other Int to produce an Int
14:45:02 <themroc--> yeah
14:45:04 <themroc--> ok thx
14:45:12 <themroc--> i didnt thought of that fact
14:45:21 <themroc--> but it sounds totally clear and reasonable
14:45:28 <Botje> yay! :)
14:45:41 <themroc--> btw what i always wonders
14:46:01 <themroc--> is there any reasonable business application for haskell?
14:46:07 <themroc--> like except school/university
14:46:29 <Botje> have you checked out the "haskell in industry" page on the haskell.org wiki?
14:46:35 <themroc--> no
14:46:38 <themroc--> ok i should
14:46:44 <maltem> Do apps for open-source geeks count as “not school/university”?
14:46:44 <Botje> yeah
14:46:48 <themroc--> but it is being used
14:46:54 <Botje> of course it is ;)
14:47:16 <Botje> and even better: the ideas that Haskell has put forth are now being implemented in mainstream languages
14:47:58 <Botje> for example, C# LINQ is just list comprehensions
14:48:04 <themroc--> yeah
14:48:06 <pikhq> Botje: No, not list comprehensions.
14:48:14 <pikhq> Monad comprehensions.
14:48:25 <Botje> IEnumerable<t> comprehensions? ;)
14:49:07 <pikhq> No. IEnumerable<t> is just one of the monads you can do with LINQ. ;)
14:49:32 <Botje> argh :p
14:49:45 <Botje> STM is also receiving a lot of attention
14:49:55 <Botje> there's even hardware implementations of it, iirc?
14:50:24 <themroc--> i just read about haskell implementions into c#
14:50:29 <themroc--> its quite interesting
14:50:45 <themroc--> i mean of course for an educational purpose, haskell is brilliant
14:51:07 <Botje> themroc--: erik meijer did an interview for the MSDN people about why the work on haskell is significant
14:51:24 <Botje> it had a graph with two axes: safe & practical
14:51:35 <themroc--> http://en.wikipedia.org/wiki/Erik_Meijer_(footballer)? haha
14:51:43 <Botje> c# and friends were practical but not safe, and haskell is safe but not practical
14:51:52 <themroc--> j/k
14:51:55 <Botje> ideally, you want languages that are both practical and safe
14:52:01 <pikhq> Botje: ... Haskell, not practical?
14:52:01 <themroc--> yeah
14:52:03 <Botje> and both sets of languages are moving towards taht point
14:52:13 <Botje> but there's also a lot of cross-fertilization going on
14:52:20 <Botje> pikhq: his words, not mine :)
14:52:32 <pikhq> It's got a dramatic learning curve, but "not practical"?
14:52:38 <themroc--> ok guys thx for all, got to go to bed
14:52:41 <themroc--> tomorrow exam
14:52:52 <themroc--> last exam of my studies :p
14:53:02 <maltem> on saturdays??
14:53:06 <themroc--> the rest will be paper writing
14:53:08 <themroc--> yeah nazi style
14:53:08 <Botje> don't drop haskell after your exam, it's too much fun to pass up :)
14:53:10 <themroc--> 9am!
14:53:23 <themroc--> yeah Botje
14:53:26 <themroc--> i wont
14:53:33 <themroc--> i began to like it too much
14:53:39 <Botje> pikhq: i wouldn't call it a dramatic learning curve.
14:53:41 <Gracenotes> > drop "haskell" -- nooo
14:53:43 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:54:07 <Botje> monads are only hard because everyone KEEPS SAYING THEY ARE!
14:54:26 <benmachine> heh
14:54:29 <pikhq> Botje: Functional programming is hard. :P
14:54:32 <Botje> the other ideas felt quite naturally (but then i'm used to scheme and ruby)
14:54:35 <Botje> s/ly//
14:54:44 <inimino> ..."and ruby"?
14:54:44 <monochrom> Nevermind Saturday exams. I once taught a course at the York University (Toronto, Canada) and its exam was scheduled at like 8:30am Sunday.
14:55:02 <Saizan> i guess "pratical" was more about libraries and tools available then the learning curve
14:55:09 <Botje> inimino: .. and perl. .. and lisp :p
14:55:21 <maltem> So really, people are doing this all over the world.
14:55:31 <monochrom> math is hard because everyone keeps saying it.
14:55:38 <Botje> I think a map or filter feels _MUCH_ more intuitive than "for (i=0; i<10; i++)"
14:55:49 <inimino> Botje: I guess I never thought of Ruby as particularly close to Haskell in language-design-space
14:55:50 <pikhq> Yes, once you get used to it.
14:55:57 <maltem> monochrom, or because people write really bad lecture notes
14:55:57 <Botje> pikhq: not even then
14:56:15 <Botje> you say "i want all pink flamingo's, and i want to paint them green"
14:56:22 <pikhq> Botje: It's the 'lack of state' thing that's hard coming from imperative-land.
14:56:26 <Botje> thats map paintGreen . filter isPink
14:56:30 <Gracenotes> in FP, there is a sort of zen between the data structures and the functions they pass through
14:56:45 <monochrom> Actually math and programming are hard because people are too creative to follow rules.
14:56:46 <pikhq> Of course, you then get used to it and you wonder how you ever lived without.
14:56:46 <Botje> imperative shouldn't be the efault
14:56:55 <pikhq> (or, rather, how you ever livied with. :P)
14:57:04 <Botje> especially now that mainstream languages have "foreach"
14:57:05 <monochrom> But more on that in #haskell-blah in my case.
14:57:21 <Botje> but i'm not on there! :(
14:57:23 <benmachine> Botje: foreach is just for but more annoying
14:57:39 <Botje> benmachine: foreach is the best thing to happen to Java since garbage collection.
14:57:48 <benmachine> 'k
14:57:57 <themroc--> Botje i wish haskell would be implemented into c#
14:57:59 * benmachine doesn't actually habitually use any languages with foreach
14:58:01 <themroc--> completely :p
14:58:12 <Botje> themroc--: c# already has type inference :p
14:58:48 <themroc--> yeah
14:58:59 <themroc--> i learned about that thru haskell :p
14:59:42 <pikhq> C# -- let's take all of the ideas of Java, stir in some Haskell, and make for a crazy and not all that noteworthy language.
14:59:45 <themroc--> but the working with lists is the best
14:59:57 <themroc--> anyway
15:00:01 <themroc--> gn8
15:00:27 <pikhq> But everyone loves it because "OMFG ITS GOT A VM" or "OMFG ITS GOT FIRST-CLASS FUNCTIONS".
15:00:38 <Heffalump> I think the VM is a big deal
15:00:43 <pikhq> Oh, and it has an API saner than the Win32 C API.
15:00:51 <pikhq> Heffalump: And not notable.
15:00:54 <Heffalump> it's a good VM and it makes deployment much better
15:01:02 <Heffalump> how do you define notable?
15:01:08 <pikhq> "We made an evolutionary change".
15:01:10 <pikhq> Yay?
15:01:40 <Botje> pikhq: C# is a big deal for the 80% out there.
15:01:54 <pikhq> Put down the claims that it's the best thing since running water, it's just a minor improvement on what was already out there.
15:02:05 <pikhq> (or, in some cases, just a minor *change*, neither better nor worse)
15:02:17 <thoughtpolice> and it's an improvement that a lot of people can adopt without much hassle, that allows a huge amount of code reuse written in other languages
15:02:21 <thoughtpolice> that is why it is a big deal
15:02:25 <Botje> lambda's are _way_ better than anonymous classes
15:02:32 <Heffalump> it's mainly important because of its market penetration and the amount of resources MS have devoted to doing cool things on top of it
15:02:33 <pikhq> thoughtpolice: ... That's not a huge deal, that's just kinda nice.
15:02:46 <thoughtpolice> pikhq: i'm not saying it's "evolutionary"
15:02:49 <Botje> likewise, properties and events are _way_ more fun than having to write getters and setters for every damn member
15:02:50 <jeffwheeler> I think you guys have said it pretty well. It's a nice language because it's a lot better than those with which it competes (like Java).
15:03:20 <thoughtpolice> pikhq: because no, it's not. but it brings benefits like first class functions and a good vm like .NET to a lot of people. that is why it is important and people like it
15:03:21 <Botje> thoughtpolice: but that's what it is! one small step towards nirvana :)
15:03:48 <thoughtpolice> Botje: I think he meant evolutionary as 'a big jump forward' rather than something slow like the real evolutionary process
15:03:57 <Heffalump> don't forget that .NET has F#, which is also not a revolution, but is still a pretty nice compromise design of proper FP on top of an OO VM
15:03:59 <Botje> that would be revolutionary
15:04:12 <Botje> ;)
15:04:12 <pikhq> thoughtpolice: ... It's a minor change on what was out there, not some huge step forward.
15:04:19 <Botje> and now i'm off to kill some monsters on the wii
15:04:21 <Botje> bye guys!
15:04:23 <Botje> and girls!
15:04:25 <Botje> and lambdabot.
15:04:30 <pikhq> And I just get fed up with people claiming it's the best thing since civilization.
15:04:59 <Heffalump> there's not much point in coming on here and espousing a view most will agree with :-)
15:05:02 <pikhq> </obvious_hyperbole>
15:05:09 <pikhq> Heffalump: True.
15:05:24 <Saizan> @vixen aren't you a girl?
15:05:24 <lambdabot> yup, i'm all woman
15:05:38 <pikhq> Pretty spiffy that it has monads though; I may just learn C# just to make some C# coders hate me. :P
15:05:45 <thoughtpolice> pikhq: i'm not saying it's a huge step forward - I'm saying it's minor changes like you pointed out. it just so happens those minor changes and improvements make a big deal to a lot of people.
15:06:23 <pikhq> thoughtpolice: And I'm saying that it irritates me how very ecstatic they are about that. ;)
15:06:27 <thoughtpolice> even if someone like me or you who's had it for ages would classify it as trivial
15:06:31 <thoughtpolice> :)
15:10:30 <monochrom> Ever since people became atheist, they need replacements for religions. Programming languages fill that hole.
15:11:31 <mauke> preflex: remember <monochrom> Ever since people became atheist, they need replacements for religions. Programming languages fill that hole.
15:11:50 <bremner> monochrom: or editors or operating systems or ...
15:11:58 <monochrom> Some day someone will be saying something against "organized programming language communities" :)
15:20:22 <cyph1e> How do I read 'n' lines (from stdin) into a list of strings in haskell?
15:20:59 <tromp_> :t replicate
15:21:01 <lambdabot> forall a. Int -> a -> [a]
15:21:12 <mauke> :t \n -> replicateM n getLine
15:21:14 <lambdabot> Int -> IO [String]
15:21:32 <bremner> cyph1e: interact is nice for simple filters
15:21:41 <Beelsebob> more than simple filters
15:21:57 <Beelsebob> anything that is a simple stdin -> stdout program
15:22:07 <cyph1e> Okay, so what I want to do is read one integer 'n', and then the n following lines
15:22:36 <mauke> do n <- readLn; replicateM n getLine
15:22:42 <Beelsebob> (flip replicateM) getLine =<< read <$> getLine
15:22:52 <pikhq> Beelsebob: :)
15:22:56 <bremner> Beelsebob: err, yes, for me that is what a filter is
15:23:21 <Beelsebob> bremner: is something that ignores the input and prints "I am a fish" 100 times a filter?
15:23:32 * Beelsebob wouldn't call it one
15:23:42 <bremner> Beelsebob: yes. Maybe it is unix jargon.
15:23:49 * Beelsebob shrugs
15:24:00 <Beelsebob> I would call a filter anything that you know... filters the input
15:24:03 <Beelsebob> removes things from it
15:24:54 <bremner> Beelsebob: ok, well, I won't hate you for using a more FP'ish definition on #haskell
15:25:03 <Beelsebob> >.>
15:25:35 <monochrom> The unix "yes" program is a filter too.
15:25:54 * Beelsebob still thinks that program should be called orgasm
15:26:05 <monochrom> haha
15:26:18 <Beelsebob> and have the flags -y, -n and -r -- to print yes yes yes, no no no, or oh god oh god oh god respectively
15:26:18 <bremner> unix filters are just functions from bytestreams to bytestreams, or something like that.
15:26:47 <monochrom> No, arrows. Can have side effects
15:26:56 <benmachine> Beelsebob: does removing the entire input and substituting your own count as a filter?
15:27:06 <Beelsebob> benmachine: no
15:27:12 <Beelsebob> or at least not in the FP definition
15:27:26 <Beelsebob> substituting being the problematic part
15:27:35 <benmachine> well
15:27:41 <benmachine> removing the entire input then
15:27:42 <monochrom> How do you replace the input?
15:27:55 <benmachine> filter (const False)
15:27:59 <Beelsebob> benmachine: yes, a program that consumed any and all input and output nothing I would consider a filter
15:28:05 <Beelsebob> a boring one though
15:28:07 <monochrom> That doesn't replace anything.
15:28:14 <benmachine> hmm
15:28:14 <Beelsebob> monochrom: indeed
15:28:33 <benmachine> map (const "I am a fish") input
15:28:41 <Beelsebob> benmachine: 'map'
15:29:00 <benmachine> ...k
15:29:13 <komposti> can someone tell my why this doesnt compile: http://pastebin.ca/1498788
15:29:19 * benmachine feels the context of discussion is moving when he isn't looking
15:29:20 <Beelsebob> what bremner meant by filter was any function f :: String -> String
15:29:20 <Beelsebob> what I meant by filter was any function f that can be defind as f = filter g for some g
15:29:24 <monochrom> You can't use a referentially transparent thing to replace anything.
15:29:27 <Zao> Your compiler probably can, komposti.
15:29:30 <MarcWeber> nominolo:        GHC.setContext [m] [env]
15:29:35 <MarcWeber> That's causing it
15:29:47 <Zao> komposti: Your else seems a bit misaligned on :11
15:30:07 <Beelsebob> monochrom: you can in this context... given that there's no replacement occuring, just something not on the input appearing in the output
15:30:10 <Zao> komposti: Also, you're missing a do block on :5
15:30:16 <pikhq> UNIX-style filter: String -> String
15:30:27 <nominolo> MarcWeber: what version of ghc are you using? what's the code? did you change anything?
15:30:52 <MarcWeber> 6.10.3 I only added some debugging lines
15:31:11 <monochrom> I don't like that semantics of "replace".
15:31:14 <Zao> check a = do { putStrLn "omg" ; newGuess <- getLine ... etc
15:31:18 <MarcWeber> Probably I should upgrade and try again @ nominolo
15:32:34 <nominolo> MarcWeber: hm, I'm using 6.10.2
15:32:45 <nominolo> MarcWeber: so this happens consistently?
15:33:05 <MarcWeber> Every time I want to configure the project using emacs, yes
15:33:28 <MarcWeber> I will downgrade and test 6.10.2
15:37:22 <nominolo> I hope nothing is broken in 6.10.3 then, since it would probably be broken in the just-released 6.10.4
15:37:34 <glorf> Someone once wrote a nice blog post (I think) about the relationship between ADTs and, uh, algebra
15:37:48 <glorf> as in, Maybe is (1+x), list is 1/(1-x), etc
15:37:52 <glorf> anyone remember it?
15:39:05 <Saizan> yeah
15:39:14 <glorf> my google-fu fails me today
15:39:25 <Saizan> there's generating functorology on comonad.com
15:39:42 <lilac> glorf: i think the terms to google for are type differentiation and one-hole contexts
15:39:47 <Saizan> it should link the post on dan piponi's blog
15:40:09 <Saizan> ?google generating functorology site:comonad.com
15:40:11 <lambdabot> No Result Found.
15:40:15 <nominolo> lilac: those don't have a - and a /
15:41:33 <nominolo> lilac: ADTs as initial algebra only give raise to + and *, I think
15:42:02 <soupdragon> dude
15:42:09 <soupdragon> - and / are lies
15:42:15 <soupdragon> it's ^ you want
15:42:22 <glorf> nominolo: final coalgebras then or whatever they're called :)
15:42:51 <Saizan> glorf: http://blog.sigfpe.com/2007/11/small-combinatorial-library.html http://comonad.com/reader/2008/generatingfunctorology/
15:42:56 <nominolo> glorf: ah, maybe.  But now we leave the realm of my profound half-knowledge
15:43:33 <Saizan> nominolo: 1/(1-x) is the generating function, if you take the polinomial expansion it looks more like a list
15:43:58 <glorf> saizan: that last links seems to have been the one i was thinking of. thanks
15:44:34 <beutdeuce> anyone here actually use Hoogle? Hayoo?
15:45:12 <lilac> glorf: http://homepage.mac.com/sigfpe/Computing/diff.html
15:45:19 <Zao> beutdeuce: Hoogle, yes.
15:45:56 <nominolo> beutdeuce: I use it from within Emacs all the time
15:46:26 <beutdeuce> nice, just found out about it and seems like a useful resource
15:46:51 <lilac> it feels almost as if there should be some deeper reason why 1/(1-x) is in some sense a list of x
15:47:12 <soupdragon> no
15:47:27 <soupdragon> it's all numberology
15:47:39 <lilac> no? you think it doesn't feel that way to me?
15:48:38 <lilac> i quite like that the naturals come out as 1/0
15:48:39 <soupdragon> I better not say anything else about this incase I upset someone
15:48:41 <glorf> lilac: 1+x+x^2 = 1/(1-x), and data (List x) = Nil | Cons x (List x), so t = 1 + t*x, or t = 1/(1-t)
15:49:00 <glorf> 1+x+x^2... =, of course
15:49:01 <lilac> glorf: yes, i understand where it comes from. but that's just playing wiht algebra
15:49:10 <glorf> what else do you want? :)
15:50:27 <lilac> in the field of types, subtraction and division don't mean anything. what i'd want is for some connection between those operations on a field and the corresponding results in the algebra of types
15:50:30 <soupdragon> cause anyone can make up hocus pocus boogy woogy nonsense as long as it's not "negative"
15:50:53 <lilac> that first "field" wasn't meant in the mathematical sense
15:50:56 <soupdragon> types don't make a field
15:51:27 <nominolo> @seen benl
15:51:28 <lambdabot> I haven't seen benl.
15:51:53 <lilac> it feels to me like there's something beautiful here just out of reach, is all
15:52:03 <glorf> lilac: like the not-not-elimination-is-call-cc thing?
15:52:10 <glorf> i have the same feeling
15:52:32 <nominolo> types are propositions!
15:52:33 <lilac> like all of Curry-Howard
15:52:34 <edwardk1> lilac: actually there is an interpretation of them
15:52:48 <edwardk1> lilac: you need to move to Joyal's Theory of Species though
15:53:07 * lilac warms up the ol' googletubes
15:53:11 <edwardk1> lilac: negative types correspond to imaginary species, you can perform arithmetic on the generating functions involved though
15:53:57 <edwardk1> division works up to the point where you can move from the ordinary generating functions permitted by ADTs to the exponential generating functions permitted by species.
15:54:10 <edwardk1> i wrote a short blog post a year back or so on 'generatingfunctorology'
15:54:17 <edwardk1> you might want to start there
15:54:26 <lilac> thanks
15:54:59 <edwardk> note that only handles finite structures, if you replace mu with nu in that construction you need a different kind of generating function
15:55:10 <edwardk> and things become much much more ugly
15:55:22 <lilac> mu versus nu is bounded versus unbounded recursion, right?
15:55:24 <ehird> things always become much more ugly.
15:55:25 <ehird> what's nu
15:55:25 <edwardk> (to the point where I haven't found nice closed forms for any of the answers)
15:55:34 <soupdragon> no
15:55:37 <beutdeuce> c/lambda
15:55:41 <soupdragon> least vs greatest
15:55:50 <edwardk> http://en.wikipedia.org/wiki/Greatest_fixed_point
15:55:59 <lilac> ok
15:56:09 <edwardk> lilac: yeah
15:58:00 <edwardk> ehird: one way to think about it is haskell recursive data types fold in on themselves with nu (or more correctly mu = nu in haskell) and ml data types fold in on themselves with mu. the least fixed point covers the base case and its extension by induction. the greatest fixpoint permits coinduction without the base case. i.e. length is only defined over finite lists.
15:58:30 <edwardk> so the haskell type is a little too permissive for a total programming language.
15:59:05 <edwardk> er length is only defined over finite lists because you need the base case to occur eventually to every finish calculating the length
15:59:42 <ehird> edwardk: wooooooosh
15:59:54 <edwardk> ehird: basically haskell is lazy right?
16:00:06 <ehird> OK, fine :P
16:00:07 <edwardk> ehird: the thunk sits there waiting for you to need it
16:00:10 <ehird> right.
16:00:17 <ehird> (poor, lonely thunks)
16:00:28 <edwardk> ehird: in ml the value has to be constructed in full before you can refer to it
16:00:33 <edwardk> ehird: because it is strict
16:00:58 <edwardk> so if i have no mutation, i can't build an infinite list and hand it to you. any list i can successfully give you will be finite in size
16:01:31 <Gracenotes> is nu a category theoretical concept?
16:01:34 <edwardk> otoh, in haskell i can hand you one = 1 : ones -- and not bat an eyelash. and you can consume as many layers of 1s as you want.
16:01:51 <monochrom> nu and mu are lattice theory concepts.
16:01:59 <edwardk> it comes from order theory which admits a categorical interpretation iirc
16:02:13 <Gracenotes> ah. I have only seen mu in terms of types
16:02:28 <Gracenotes> and after all a good enough type system could be interpreted in terms of lattice theory :)
16:02:43 * Gracenotes pats _|_
16:03:38 <monochrom> If you apply category theory to a type system, you will be looking at colimits and limits instead of mu and nu.
16:03:58 <edwardk> a preordered class is a thin category (a category with at most one arrow between any two objects) so you can basically take any category, identify all of the arrows that are heading between any two objects, and you get a preorder (technically, again a preordered class, if the class of objects is bigger than a set), so you can use the notion of a fixed point from order/lattice theory
16:05:09 <edwardk> and you can have fixed points in terms of all sorts of things after that =)
16:05:47 <Saizan> e.g. fix = mu on values
16:08:10 <soupdragon> data Mu f = Roll (f (Mu f))
16:08:22 <soupdragon> codata Nu f = Roll (f (Nu f))
16:09:38 <edwardk> another way to see the difference is to define one in terms of a universal and the other in terms of an existential, and work over functors that aren't haskell functors so you can see that you can go one way but not back
16:11:07 <edwardk> i should have a code fragment around here somewhere for that
16:11:52 <edwardk> though, iirc washburn and weirich did something along those lines. they defined a recursive elimination form for Mu along the lines of
16:13:26 <edwardk> newtype Mu f = Mu (forall a. (f a -> a) -> a) -- and showed an existential Nu type for f, which when f wasn't a Functor, but merely an 'exponential functor' (technically a functor over the category of left-invertable haskell functions)
16:14:11 <edwardk> er which when f was an exponential functor you couldn't get back out of Nu. (i think they called their Nu 'Dia' or something like that
16:16:00 <edwardk> s/functor over/endofunctor on/ to be clearer
16:17:28 <beutdeuce> does Haskell have Memoization?
16:17:48 <edwardk> beutdeuce: it has several tools that let ytou roll your own memoization schema
16:17:56 <edwardk> because there isn't really one right way to do it
16:18:08 <beutdeuce> what would be some of these tools?
16:18:19 <edwardk> there was a paper digging it up
16:18:37 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.1948
16:18:52 <edwardk> documents stablenames and stableptrs and the various weak pointer mechanisms provided by ghc
16:19:02 <LeoD> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7140#a7140 is there a way to write the signature for getx without FlexibleContents?
16:19:11 <LeoD> Contexts*
16:19:41 <heatsink> You can memoize by putting your computed values in a variable.
16:19:43 <edwardk> another approach entirely is useable when you are memoizing a function from a value that could have all of its possibilities turned into a tree like structure. that form of memoization is much cleaner and comes for free without any tricks
16:20:31 <edwardk> and of course there is always the small scale 'memo-thunk' stuff that happens behind the scenes whenever you use a let binding
16:22:06 <beutdeuce> thanks
16:22:13 <heatsink> What are you using it for?
16:22:43 <beutdeuce> fibonacci for example
16:22:45 <Saizan> LeoD: no, but FlexibleContexts is almost mandatory if you use multi parameter type classes
16:22:56 <LeoD> ok, thanks
16:23:51 <edwardk> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
16:23:52 <heatsink> Most frequently, the let-binding approach is suitable for that and in dynamic programming.
16:23:53 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:24:03 <edwardk> is 'memoized' by just using thunks
16:24:18 <edwardk> because it has careful knowledge of the demand patterns within the list
16:25:13 <edwardk> otoh if you ask for the 53rd element of that list twice it'll still have to walk down the list to the 53rd element 2 times, so the particular memoization structure there isn't so suitable for random access.
16:25:20 <heatsink> let flubs = 1 : zipWith (+) flubs (tail flubs) in flubs
16:25:29 <heatsink> > let flubs = 1 : zipWith (+) flubs (tail flubs) in flubs
16:25:34 <lambdabot>   mueval-core: Prelude.read: no parse
16:25:35 <lambdabot>  mueval: ExitFailure 1
16:25:36 <edwardk> heh flubs
16:27:29 <edwardk> otoh, you could use the scary stablename stuff mentioned in that article to build one solution, you could use just a Map of integers to answers carried around in a state monad if you want to avoid deep magic and want explicit control over the memo-cache, etc.
16:27:51 <edwardk> yay for having enough rope to hang yourself in creative ways
16:33:00 <lilac> > let lies = 1:1:2:zipWith (+) lies (tail lies) in lies
16:33:02 <lambdabot>   [1,1,2,2,3,4,5,7,9,12,16,21,28,37,49,65,86,114,151,200,265,351,465,616,816,...
16:36:04 * benmachine tries to work this out
16:37:38 <benmachine> so x_n = x_(n-2) + x_(n-3)
16:38:03 <benmachine> I wonder if it still converges on the same thing
16:38:29 <benmachine> > let lies = 1:1:2:zipWith (+) lies (tail lies) in (lies !! 1000) / (lies !! 999)
16:38:30 <lambdabot>   1.324717957244746
16:38:34 <benmachine> oh it doesn't
16:38:47 <benmachine> > let lies = 1:1:zipWith (+) lies (tail lies) in (lies !! 1000) / (lies !! 999)
16:38:49 <lambdabot>   1.6180339887498947
16:43:04 <edwardk> we can go with the lucas numbers. hrmm
16:43:17 <heatsink> The time constant gets longer because there's more delay in the feedback loop.
16:43:33 <edwardk> > let lucas = 2:1:zipWith (+) lucas (tail lucas) in lucas
16:43:34 <lambdabot>   [2,1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,1512...
16:43:53 <edwardk> > 9349 / 5778
16:43:55 <lambdabot>   1.6180339217722395
16:43:57 <heatsink> Oh, is that where "Seven Eleven" comes from.
16:44:35 <edwardk> the store chain?
16:44:41 <edwardk> the store chain comes from that being their old hours =)
16:44:56 <p_l> wasn't that this store chain that once ran from 7am till 11pm?
16:45:58 <heatsink> yeah, somehow I don't think the founders had access to Sloane's.
16:46:28 <edwardk> > let pell = 0 : 1 : zipWith (\x y -> 2 * x + y) pell (tail pell)
16:46:30 <lambdabot>   not an expression: `let pell = 0 : 1 : zipWith (\x y -> 2 * x + y) pell (ta...
16:46:34 <edwardk> woops
16:46:39 <edwardk> > let pell = 0 : 1 : zipWith (\x y -> 2 * x + y) pell (tail pell) in pell
16:46:41 <lambdabot>   [0,1,1,3,5,11,21,43,85,171,341,683,1365,2731,5461,10923,21845,43691,87381,1...
16:46:48 <lilac> @oeis 7 11
16:46:50 <lambdabot>  The prime numbers.
16:46:50 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:46:51 <edwardk> > 87381 / 43691
16:46:53 <lambdabot>   1.999977111991028
16:47:19 <benmachine> > 43691 / 21845
16:47:21 <lambdabot>   2.00004577706569
16:47:58 <edwardk> > let companion = 2 : 2 : zipWith (\x y -> 2 * x + y) companion (tail companion) in companion
16:47:59 <lambdabot>   [2,2,6,10,22,42,86,170,342,682,1366,2730,5462,10922,21846,43690,87382,17476...
16:48:18 <edwardk> ah i got the recurrence backwards
16:48:35 <edwardk> > let pell = 0 : 1 : zipWith (\x y -> x + 2 * y) pell (tail pell) in pell
16:48:37 <lambdabot>   [0,1,2,5,12,29,70,169,408,985,2378,5741,13860,33461,80782,195025,470832,113...
16:48:48 <edwardk> er scarier growth even
16:49:30 <edwardk> oh yeah of course
16:52:47 <lilac> > let foo = 1:2:zipWith (\x y -> min x y - 2 * max x y) foo (tail foo) in foo
16:52:49 <lambdabot>   [1,2,-3,-7,-1,-5,-3,1,-5,-7,3,-13,-19,7,-33,-47,19,-85,-123,47,-217,-311,12...
16:53:25 <lilac> > let foo = 1:2:zipWith (\x y -> min x y - 2 * max x y) foo (tail foo) in filter (>0) foo
16:53:27 <lambdabot>   [1,2,1,3,7,19,47,123,311,803,2047,5259,13447,34483,88271,226203,579287,1484...
16:54:58 <sully> > let lucas = [2,1] ++ zipWith (+) lucas (tail lucas) in lucas
16:54:59 <lambdabot>   [2,1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,1512...
16:55:24 <lilac> > 226203/88271
16:55:26 <lambdabot>   2.5625970024130234
16:55:29 <lilac> > let foo = 1:2:zipWith (\x y -> min x y - 2 * max x y) foo (tail foo) in filter (>0) foo
16:55:31 <lambdabot>   [1,2,1,3,7,19,47,123,311,803,2047,5259,13447,34483,88271,226203,579287,1484...
16:55:38 <lilac> > 579287/226203
16:55:40 <lambdabot>   2.5609165218852095
16:56:30 <pikhq> lilac: Enjoying the corecursion?
16:58:36 <lilac> > let foo = 1:2:zipWith (\x y -> min x y - 2 * max x y) foo (tail foo); bar = filter (>0) foo in zipWith (/) (tail bar) bar
16:58:38 <lambdabot>   [2.0,0.5,3.0,2.3333333333333335,2.7142857142857144,2.473684210526316,2.6170...
16:59:17 <mae_work> hello, any freebsd users want to help me out? I need to run a test suite on freebsd for sendfile
16:59:19 <mae_work> http://groups.google.com/group/HAppS/browse_thread/thread/eb300f2c4356bd9
17:03:31 <edwardk> > let { fib n = fst (lucas n); lucas n = let { (k1,k2) = lucas (div (n-1) 2); (l1,l2) = lucas (div n 2 -1) } in case compare n 2 of LT → (1,1); EQ → (2,1); GT → if odd n then (k1*(k1+k2)+k1*k2, k1*k1+k2*k2) else ((l1+l2)*(l1+l2)+l1*l1, (l1+l2)*l1+l1*l2) } in fib 10
17:03:33 <lambdabot>   89
17:05:41 <pikhq> edwardk: The Unicode → works instead of ->? Nice.
17:07:27 * shapr throws ragdolls at edwardk
17:07:45 <lilac> @shapr
17:07:46 * lambdabot decomposes  into several parts using the Banach-Tarski theorem and reassembles them to get two copies of !
17:08:37 * edwardk throws some back, using fewer than were thrown at him, so he can build up a stockpile.
17:09:34 <edwardk> pikhq: ghc has supported unicode operators for a while now
17:09:41 <pikhq> edwardk: Nice.
17:10:32 <pikhq> So, you could use the actual lambda instead of /? I do believe that I need to fiddle with my compose setup.
17:10:41 <edwardk> yeah
17:11:01 <benmachine> @pl \x -> if f x then putStrLn x else return ()
17:11:01 <lambdabot> flip (liftM2 if' f putStrLn) (return ())
17:11:12 <benmachine> @type if'
17:11:14 <lambdabot> Not in scope: `if''
17:11:18 <benmachine> wat
17:11:19 <edwardk> what i do is use vim settings that map those to the nice pretty symbols on file load, and then saves them back out with the normal mundane symbols so i don't have to deal with people bitching about what i did to their haskell source files ;)
17:11:29 <pikhq> @src if'
17:11:30 <lambdabot> Source not found. I feel much better now.
17:12:28 <benmachine> @hoogle if'
17:12:29 <lambdabot> No results found
17:12:35 <benmachine> mystery function :(
17:13:50 <edwardk> if' True x _ = x; if' False _ y = y
17:14:08 <edwardk> its a Caleskel'ism in lambdabot iirc
17:14:40 <pikhq> Speaking of Caleskel.
17:14:41 <benmachine> oh right
17:14:50 <pikhq> Cale: Bring back (.) = fmap!
17:15:00 <pikhq> ;)
17:15:05 <benmachine> Λ <- is this capital lambda? it doesn't look right to me
17:15:17 <pikhq> benmachine: That's a capital lambda.
17:15:20 <edwardk> yeah
17:15:24 <lpsmith> does GHC ever do lambda lifting?
17:15:29 <Cale> pikhq: I would, but the GHC api can't seem to import modules hiding various values.
17:15:29 <benmachine> oh I am thinking of gamma for some reason
17:15:38 <pikhq> Cale: Aaaaw.
17:15:39 <Cale> pikhq: I'd need to import the Prelude hiding (.)
17:16:01 <copumpkin> zomg an edwardk
17:16:04 <pikhq> Clearly, we need to push for (.) = fmap in the language spec.
17:16:21 <lpsmith> well,  according to Simon,  as of 2005,  GHC did not:
17:16:24 <pikhq> Oh, and rm map. :P
17:16:26 <lpsmith> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg08347.html
17:16:30 <benmachine> > let (.) = fmap in (+1) . Just 3
17:16:31 <lambdabot>   Just 4
17:16:42 <benmachine> that's uhm
17:16:44 <edwardk> copumpkin: heya, did you make it down for the user group? i didn't see ya
17:16:46 <benmachine> a little odd
17:16:55 <copumpkin> edwardk: nope, forgot :P
17:16:56 <copumpkin> dammit
17:16:58 <copumpkin> I suck
17:17:01 <pikhq> Here, lemme unconfuse you.
17:17:04 <pikhq> > (+1) <$> Just 3
17:17:06 <lambdabot>   Just 4
17:17:09 <edwardk> copumpkin: i'll talk at the next one so swing down ;)
17:17:11 <copumpkin> you didn't present any monoids did you? I'd have to kick myself
17:17:31 <copumpkin> ok yay
17:17:34 <benmachine> pikhq: I know what's happening but I'm just a little doubtful about the merits of . as fmap
17:17:34 <copumpkin> when is that?
17:17:36 <edwardk> nah, it was the haskell-on-iphone stuff and alec heller did a shpiel on the general structure of ghc for hacking purposes
17:17:55 <edwardk> it should be somewhere around august 17th or so but i don't believe the day has been fixed exactly
17:18:02 <edwardk> some day during the week around that time
17:18:19 <copumpkin> cool
17:18:34 <pikhq> benmachine: Well, I think we should compose functors in general, not just the subset of them that are functions. ;)
17:19:15 <edwardk> personally i like (.) as compose for an arbitrary category, but i have to admit cale makes a pretty compelling more common usecase argument for it being fmap
17:19:37 <copumpkin> I'd feel really weird doing (+1) . Just 5 though
17:20:02 <benmachine> or toUpper . "flib"
17:20:14 <benmachine> (that one's actually kind of cool)
17:20:17 <copumpkin> which gets even funkier if you have fromString on there
17:20:21 <jmcarthur> yeah i was about to say i like that :P
17:20:24 <edwardk> copumpkin: yeah, it seems slightly understated for its impact
17:20:58 <pikhq> copumpkin: Think of it as <$> instead of . and it makes more sense. :P
17:21:06 <pikhq> And, in fact,
17:21:09 <gwern> @pl filestoreToRss a b = map (revToRss a b)
17:21:10 <lambdabot> filestoreToRss = (map .) . revToRss
17:21:10 <pikhq> @src <$>
17:21:10 <lambdabot> f <$> a = fmap f a
17:21:11 <copumpkin> yeah, but that has a very different feel to it
17:21:18 <copumpkin> yeah, I know what <$> is :P
17:21:31 <benmachine> I think you'd introduce people to map and so forth individually and then tell them that (.) does all of them though
17:21:32 <jmcarthur> . just doesn't feel "lifted" like <$> does
17:21:33 <Cale> Does it really?
17:21:45 <copumpkin> <$> feels like a fancier $
17:21:49 <copumpkin> which is what fmap feels like too
17:21:55 <Cale> You can think of function composition as being a special case of the feel of functor application though.
17:22:13 <pikhq> Which of course it is.
17:22:15 <Cale> f . g is applying f to everything in the image of g
17:22:43 <Cale> I mean, it's not just technically functor application, but you can actually look at it as applying a function to a collection of elements.
17:22:56 <copumpkin> wow, whatever Conor McBride is on, I want some
17:22:57 <Cale> Or of course, to the result of another computation :P
17:23:01 * pikhq is against stupid special cases.
17:23:05 <edwardk> copumpkin: ?
17:23:14 <jmcarthur> you can also just view data structures as functions, too
17:23:23 <beutdeuce> is there a recursion depth limit in Haskell?
17:23:35 <copumpkin> edwardk: you read his blog posts? or his latest email about closing a class (which is cool btw) he closes with "Cures youriously" :P
17:23:37 <benmachine> p.s. where is the Monad instance for ((->) a) because I am getting No instance for...
17:23:37 <jmcarthur> e.g.: [] = (->) Nat
17:23:46 <gwern> function? sometimes it's more like fuction ifyaknowhatimean
17:23:50 <benmachine> is there actually one I am confused
17:24:15 <pikhq> beutdeuce: Sometimes.
17:24:23 <soupdragon> my guess is he's "on" focused hard work and years of study
17:24:34 <benmachine> beutdeuce: presumably you'll eventually run out of memory, but I suspect that not everything you write as a recursive function will compile to something recursive, so I wouldn't worry
17:24:39 <pikhq> @hoogle Monad ((->) a)
17:24:40 <lambdabot> Warning: Unknown type Monad
17:24:40 <lambdabot> Prelude undefined :: a
17:24:40 <lambdabot> Data.Array.Base arrEleBottom :: a
17:24:46 <copumpkin> soupdragon: aha :)
17:24:54 <soupdragon> you don't need anything special to create what you want to, you just have to work
17:25:32 <gwern> work? screw that
17:25:39 <gwern> screw that for a lark!
17:26:02 <benmachine> beutdeuce: tail recursion will probably get optimised into a loop, for example, so you can recurse as many times as you like
17:26:20 <benmachine> > do { x <- id; return x }
17:26:21 <beutdeuce> k
17:26:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:26:22 <lambdabot>    arising from a use of `...
17:26:26 <benmachine> erm
17:26:28 <benmachine> > do { x <- id; return x } 1
17:26:30 <lambdabot>   <no location info>: parse error on input `1'
17:26:52 <gwern> @quote recurse
17:26:53 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
17:26:53 * benmachine gets his own lambdabot out and pokes it a little
17:26:56 <pikhq> > do { x <- id; return x } $ 1
17:26:58 <lambdabot>   1
17:27:07 <benmachine> pikhq: oh right, cool
17:27:54 <gwern> yo dawg i herd you like fuctional programming so i put a microphone in ur computer so u can recurse while you recurse
17:28:15 <benmachine> ghci still doesn't like me do-ing functions though
17:28:19 * benmachine googles
17:28:42 <soupdragon> yo dawg i herd you like fuctional programming
17:28:59 <gwern> man, the documentation for feed is terrible!
17:29:04 <copumpkin> oh no, did you put a function in my function so I can call while I call?
17:29:10 <soupdragon> no
17:29:15 <gwern> @quote good.news
17:29:15 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
17:29:15 <copumpkin> oh good
17:29:19 <gwern> @quote good.news
17:29:19 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
17:29:21 <soupdragon> I just herd that an did nothing
17:29:25 <gwern> @quote futamura
17:29:26 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
17:30:10 <gwern> that's it. when gitit finally gets some rss support, I'll take what I know and write up some bloody haddocks. yeesh
17:30:33 <gwern> siggy may be a good productive programmer, but he either can't or won't write docs worth a shit
17:31:16 <copumpkin> does anyone know of a relational database that has a good interval tree index?
17:31:44 <copumpkin> I guess I could sort of approximate it with mysql's spatial extensions
17:32:37 <pikhq> benmachine: Probably in Control.Monad somewhere.
17:32:47 <pikhq> gwern: Nice quote.
17:34:48 <edwardk> copumpkin: postgresql should have a russian doll tree in its GiST implementation
17:35:06 <copumpkin> :o
17:35:16 <edwardk> copumpkin: that should cover the use case, and if not, its a straight forward implementation of a GiST.
17:35:33 <copumpkin> yeah, I just didn't want to do it myself
17:35:42 <copumpkin> btw, any interval trees in haskell anywhere?
17:35:43 <edwardk> ever implement a GiST?
17:35:47 <copumpkin> nope :)
17:35:48 <edwardk> =)
17:35:53 <edwardk> its like 7 little functions
17:35:56 <copumpkin> I've read about it a bit but haven't used postgres much
17:35:58 <copumpkin> lol
17:35:59 <edwardk> ah
17:36:38 <edwardk> i've borrowed the abstraction a few times for my own work, so its kind of fuzzy what is supported by the abstraction and what is supported directly by postgresql ;)
17:36:48 <edwardk> at least to me
17:37:08 <copumpkin> ah
17:41:48 <edwardk> you know you have been reading reddit too long when you go to upmod a haskell-cafe post for humor
17:42:05 <edwardk> and then get annoyed that you can't ;)
17:43:13 <copumpkin> aw
17:43:38 <soupdragon> +1
17:44:45 <gwern> -1 karma whoring
17:45:13 <gwern> yeesh. rss in haskell is so tedious. sometimes one can be too typeful...
17:46:29 <tavelram> why doesnt ghc include a xml-lib, but includes a xhtml-lib?
17:46:43 <gwern> historic necessity
17:47:18 <gwern> why is rhode island the size of a metropolis? why are there sovereign states like the vatican measured in acres? etc
17:47:27 <tavelram> :)
17:47:45 <tavelram> a bit odd that they didnt create a xml-lib and then a xhtml-lib on top of that?
17:48:34 <Igloo> The xhtml package is based on the html package
17:48:43 --- mode: Igloo set -o Igloo
17:49:12 <tavelram> yeah, but it isnt reusing anything, it's just the equivalent of the html-lib
17:49:29 <tavelram> (being xml instead of sgml)
17:49:29 <Petrosian> > "\353"
17:49:30 <Vanadium> In the vatican, there are on average two popes per square kilometer
17:49:31 <lambdabot>   "\353"
17:49:31 <Vanadium> \o/
17:49:46 <Petrosian> > "\6599853"
17:49:47 <lambdabot>   <no location info>:
17:49:48 <lambdabot>      lexical error in string/character literal at chara...
17:49:58 <Petrosian> What's the upperbound for numerical escapes for characters?
17:50:03 <beutdeuce> Why does tails run in O(n) time, not O(1) ?
17:50:25 <edwardk> beutdeuce: it is constant time... if you don't use any of the tails ;)
17:50:31 <soupdragon> > last ([1..]::String)
17:50:33 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:50:33 <lambdabot>    arising from the literal `1...
17:50:48 <edwardk> if you do, then you ultimately have to pay for that work sometime
17:50:49 <copumpkin> beutdeuce: how would it?
17:50:53 <soupdragon> > maxBound :: Char
17:50:54 <lambdabot>   '\1114111'
17:50:58 <copumpkin> beutdeuce: you get O(n) tails out of tails
17:51:05 <Petrosian> Excellent, cheers soupdragon
17:51:05 <beutdeuce> true
17:51:12 <copumpkin> > tails [1..5]
17:51:13 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
17:51:14 <beutdeuce> but the time it takes to get the tails
17:51:21 <beutdeuce> should be the same
17:51:24 * copumpkin pats lambdabot
17:51:28 <beutdeuce> as it did to get previous tails
17:51:42 <copumpkin> beutdeuce: well, it does run in reasonable space :)
17:51:48 <edwardk> beutdeuce: it has a lot of walking to do
17:51:48 <copumpkin> run vacuum on it
17:52:09 <beutdeuce> > vacuum tails ?
17:52:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:52:20 <edwardk> > vacuum (tails [1..3])
17:52:22 <lambdabot>   Not in scope: `vacuum'
17:52:30 <edwardk> , vacuum (tails [1..3])
17:52:30 <beutdeuce> @type vacuum
17:52:31 <copumpkin> , vacuum (tails [1..3])
17:52:33 <lambdabot> Not in scope: `vacuum'
17:52:37 <copumpkin> zomg
17:52:38 <lunabot>  [(0,[1,2]),(1,[3,4]),(2,[4,9]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(...
17:52:38 <lunabot>  [(0,[1,2]),(1,[3,4]),(2,[4,9]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(...
17:52:58 <copumpkin> it's kinda hard to read its output though
17:53:14 <edwardk> actually tails isn't so bad, its inits that is terrible ;)
17:53:27 <beutdeuce> what is unsafeTail?
17:53:42 <pikhq> @src unsafeTail.
17:53:43 <lambdabot> Source not found. You speak an infinite deal of nothing
17:53:45 <pikhq> @src unsafeTail
17:53:46 <lambdabot> Source not found.
17:53:48 <edwardk> beutdeuce: probably someone's bad idea of a joke name for tail
17:53:58 <edwardk> tail is inherently unsafe in that you might try to apply it to []
17:54:00 <edwardk> > tail []
17:54:01 <lambdabot>   * Exception: Prelude.tail: empty list
17:54:02 <copumpkin> it's acknowledging that it's not a total function
17:54:22 <copumpkin> I was sure mmorrow had an online interface to vacuum
17:54:28 <edwardk> in practice there are a lot of partial functions, naming them all unsafeFoo is silly and obscures the REALLY unsafe stuff like unsafePerformIO
17:54:49 <pikhq> They should just return Maybes.
17:54:50 <pikhq> :P
17:54:57 <pikhq> Actually, that's not a joke.
17:55:00 <beutdeuce> o, cause in the source it is, p : tails (unsafeTaiils p) , but it doesnt define unsafeTails anywhere
17:55:33 <pikhq> Then it doesn't compile, now does it?
17:56:09 <edwardk> pikhq: i'm neutral on the safe head/tail debate, it just pushes people towards making 'error' branches in their code and cluttering stuff up with impossible cases
17:56:33 <edwardk> @src unsafeTails
17:56:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:56:47 <pikhq> edwardk: Error branches?
17:56:55 <pikhq> That's what the Maybe monad is for! :P
17:57:57 <edwardk> pikhq: the problem is this, ok, so you eliminate head and tail and require exhaustive pattern match, what is next? do you tackle GADTs? its a really hard problem to know if a GADT pattern is exhaustive.
17:58:54 <edwardk> i'm all for a safeHead or viewList function or whatever, but i think by now head and tail are pretty firmly enmeshed in the culture.
18:00:31 <pikhq> edwardk: I also want a halting oracle and a pony.
18:00:39 <pikhq> I'm hard to please. ;)
18:02:26 <edwardk> I think I would crush a pony, so if I get one you can have mine.
18:02:47 <pikhq> I would likely crush one, too.
18:13:53 <edwardk> @seen cale
18:13:54 <lambdabot> cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard cale speak 50m 56s ago.
18:14:01 <Cale> hello
18:14:47 <Rotaerk> @seen me
18:14:47 <lambdabot> me has changed nick to ficthe.
18:14:47 <lambdabot> Last time I saw ficthe was when I left ##english, ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #
18:14:47 <lambdabot> ghc, #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #
18:14:47 <lambdabot> haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #
18:14:49 <lambdabot> xmonad and #yi 1m 15d 20h 23m 54s ago.
18:14:53 <Rotaerk> hrm..
18:14:54 <edwardk> Given our previous conversation... obligatory shit code humor: http://hackage.haskell.org/package/toilet-0.0.1
18:14:57 <Cale> I'll take a pony, and about 30 hamburger buns.
18:15:07 <Rotaerk> lambdabot, learn 2 not be so literal!
18:15:16 <edwardk> I wonder if all the data types are named T
18:15:39 <andyL> question :what type of  programs is haskell usually used to make
18:16:04 <edwardk> holy... er.. crap. he actually named a data type something else. ;)
18:17:47 <Cale> Is it just me, or do programmers with an ML background have an unusually high tolerance for nesting?
18:19:14 <Cale> hmm, what do I mean by that... I suppose that they don't seem to mind sticking large multi-line lambdas into things like foldl or map, say.
18:19:23 <Cale> (or fix, amusingly enough)
18:19:35 <edwardk> ok, i've been overly mean spirited. going to go try to do something positive with my day
18:19:38 <vav> andyL: http://hackage.haskell.org/packages/archive/pkg-list.html -- see also Community links on http://haskell.org
18:19:46 <Badger> > (λx → x + 3)
18:19:48 <lambdabot>   Pattern syntax in expression context: λx -> x + 3
18:20:02 <Badger> awesome
18:23:41 <andyL> thanks vav
18:29:09 <benmachine> so guys, I remember reading that you could use λ and → in place of their ascii approximations but having then tested it I've found otherwise
18:29:26 <benmachine> what is the situation with these symbols?
18:29:35 <Badger> well it knows what the arrow is
18:29:42 <benmachine> does it?
18:29:50 <Badger> 03:16:48 < Badger> > (λx → x + 3)
18:29:50 <Badger> 03:16:50 < lambdabot>   Pattern syntax in expression context: λx -> x + 3
18:29:52 <nominolo> benmachine: i think there's a patch pending
18:30:01 <benmachine> Badger: hmm
18:30:09 <Badger> maybe not lambda
18:30:13 <benmachine> ghci just parse errors
18:30:18 <jmcarthur> benmachine: you may be thinking the emacs mode. it can substitute those symbols in for viewing
18:30:25 <benmachine> > (\x → x + 1)
18:30:26 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:30:26 <lambdabot>    arising from a use of `...
18:30:27 <jmcarthur> but the actual source is the ascii
18:30:30 <benmachine> > (\x → x + 1) 3
18:30:32 <lambdabot>   4
18:30:41 <benmachine> lambdabot seems ok with → at least
18:30:43 <nominolo> benmachine: you have to turn on -XUnicodeSyntax
18:30:45 <jmcarthur> i think leksah also does it
18:30:49 <benmachine> nominolo: ah, nice
18:30:56 * benmachine refers to ghc manual
18:31:01 <copumpkin> no lambda in unicode syntax
18:31:03 <copumpkin> lambda is a letter
18:31:03 <pikhq> jmcarthur: It can?
18:31:06 <copumpkin> I'd like to change that :P
18:31:09 <nominolo> benmachine: but AFAIU not everything is supported yet
18:31:10 <Badger> > (λx → x + 3) 3
18:31:12 <lambdabot>   Pattern syntax in expression context: λx -> x + 3
18:31:14 <Badger> oh
18:31:22 <jmcarthur> pikhq: i'm pretty sure
18:31:25 <copumpkin> > isLower 'λ'
18:31:26 <lambdabot>   True
18:31:31 <copumpkin> > isAlpha 'λ'
18:31:33 <lambdabot>   True
18:31:33 <pikhq> jmcarthur: How, might I ask?
18:31:57 <andyL> this functinal programming is fun. it kinda reminds me of mathematics
18:32:05 <andyL> functions
18:32:16 <jmcarthur> i forget
18:32:17 <nominolo> that's kinda the idea
18:32:18 <pikhq> andyL: Reminds you of?
18:32:19 <jmcarthur> :)
18:32:20 <pikhq> It is mathematics!
18:32:38 <pikhq> (specifically, it's a form of typed lambda calculus)
18:32:39 <CalJohn> andyL: yeah, that is the ideal.  agda is normally used with unicode
18:32:52 <andyL> ok
18:33:44 <jmcarthur> pikhq: set font lock mode to unicode
18:33:48 <benmachine> > let λ = 4 in λ
18:33:50 <lambdabot>   4
18:33:54 <benmachine> oh well
18:34:13 <jmcarthur> "Haskell Font Lock Symbols" should be "unicode", that is
18:34:17 <copumpkin> I'd like to get a real lambda in unicode syntax
18:34:33 <benmachine> me too
18:34:41 <CalJohn> trying to find -XUnicodeSyntax in the ghc docs.  failing.
18:34:43 <benmachine> it would make all my source files up to 20% prettoer
18:34:46 <benmachine> prettier
18:34:56 <jmcarthur> pikhq: that's in emacs. i don't know about leksah
18:34:58 <copumpkin> but it's hard
18:35:03 <jmcarthur> pretty sure you can do it there too
18:35:25 <jmcarthur> pikhq: depending on your font or something it might slightly affect spacing and, thus, indentation
18:35:32 * SamB starts to wish x-chat would rotate logfiles every year or so
18:35:53 <jmcarthur> yeah, the unicode -> is only one column wide
18:36:01 <jmcarthur> that's why i stopped using that mode
18:36:13 <pikhq> Aaaw.
18:36:30 <jmcarthur> one may be able to change that, but i have not looked into it
18:36:33 <CalJohn> where should i look for a list of all the language pragmas and their meanings?
18:38:03 <nominolo> CalJohn: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
18:38:17 <nominolo> it's not documented apparently
18:38:28 <CalJohn> many thanks
18:40:36 <nominolo> CalJohn: there's also this ticket: http://hackage.haskell.org/trac/ghc/ticket/2978
18:40:37 <CalJohn> relately, what are the most common/most useful extensions?  I haven't seen a lot of real world code.
18:40:48 <CalJohn> (is there a list?)
18:41:06 <Berengal> jmcarthur: leksah ha a pretty easy way to configure source candy, turning on and off things at will, and supporting entire phrases if you want
18:41:36 <Berengal> CalJohn: NoMonomorphismRestriction gets my vote
18:41:39 <nominolo> CalJohn: in ghci type :set -X then press tab
18:41:53 <nominolo> the haskell prime wiki has some documented
18:42:13 <nominolo> others should be documented on the flag reference above (or linked to)
18:42:36 <Berengal> I don't use ViewPatterns much, but when I do they fit the bill perfectly. Pattern guards are also nice
18:42:43 <CalJohn> nominolo: yeah, that's a list of all of them, but surely they are not all used
18:42:49 <nominolo> I happen to use FlexibleContexts MultiParamTypeClasses ViewPatterns a lot
18:43:13 <nominolo> ah, so I just turn them on whenever I need to
18:43:26 <nominolo> the error message usually tells me to
18:43:31 <Berengal> FlexibleContexts/Instances gets turned on when ghc tells me to. It's not something I actively go looking for
18:43:48 <nominolo> ScopedTypeVariables are for example are needed for the new exceptions
18:44:31 <nominolo> oh, actually I don't use ViewPatters, just PatternGuards
18:46:22 <SamB> I think ScopedTypeVariables are one of the less-controversial extensions? or, should I say, less difficult to formalize?
18:46:41 <SamB> I mean, a commitee could do it
18:47:07 <Berengal> I haven't used them much, actually...
18:47:29 <Berengal> Haven't used the new exceptions much either, or any kind of exception for that matter
18:47:44 * Berengal looks at anything more complicated than Either with scepticism
18:47:58 <benmachine> SamB: I read that with an "even" before the "a"
18:48:08 <pikhq> Berengal: I see you hate IO.
18:48:22 <pikhq> (I don't blame you)
18:48:33 <Berengal> pikhq: Not all of it. interact is nice..
18:48:39 <benmachine> all this pesky input stuff gets in the way of real programming
18:48:56 <Berengal> benmachine: Ziggactly
18:49:04 <CalJohn> new exceptions being "asynchronous exceptions"?
18:49:40 <SamB> benmachine: that's the way I intended it ;-)
18:50:05 <nominolo> SamB: they are actually a pretty bad omission in the original spec since without them you often cannot give type sigs to local declarations
18:50:07 <SamB> didn't think it was necessary to spell out
18:50:11 <SamB> nominolo: yeah
18:50:36 <benmachine> SamB: ah, just checking :P
18:51:01 <SamB> nominolo: all I mean is that there isn't any theoretical difficulty -- it's just a matter of specifying when type variables can be bound, basically
18:51:13 <nominolo> didn't simonmar post a list of extensions that decisions will be made on Real Soon Now (tm)?
18:51:19 <CalJohn> tbh, I am not sure there are any significant benefits to having a yearly standard process
18:51:44 <nominolo> is it actually yearly?
18:51:50 <Berengal> nominolo: He said haskell' would be done next year, basically
18:51:55 <CalJohn> nominolo: that was implied in the mail i saw
18:52:12 <benmachine> I think there are undeniable benefits to a schedule
18:52:19 <nominolo> yep
18:52:27 <SamB> nominolo: no, it wasn't that -- it was a predicted list of extensions that will get in
18:52:36 <SamB> followed by a cry for help
18:52:42 <nominolo> the trick is to keep it focused on only deciding on certain extenions
18:52:59 <nominolo> SamB: right, least controversial
18:53:10 <SamB> nominolo: and/or writing up the ones that are pretty clear
18:53:11 * Berengal wonders what'll come of type families
18:53:22 <SamB> not just deciding, writing up is also important
18:53:25 <SamB> ;-)
18:53:26 <nominolo> Berengal: nothing anytime soon
18:53:37 <SamB> Berengal: they need more papers
18:53:43 <jeffwheeler> Can haddock work incrementally, like ghc --make, and only update files that need updating?
18:53:48 <nominolo> Berengal: they are still figuring out how to type check them properly
18:53:55 <Berengal> nominolo: I just wish people would stop using functional dependencies and start using type families. Clean up my classes...
18:54:23 <SamB> jeffwheeler: hmm. I don't think so.
18:54:29 <nominolo> Berengal: well, Mark Jones had some nice suggestions how to make FDs look more like type classes
18:54:32 <jeffwheeler> SamB: Ah, well, it should
18:54:34 <SamB> jeffwheeler: might not be hard to add though?
18:54:40 <SamB> jeffwheeler: go try ;-P
18:54:46 <hackagebot> memcached 0.1.2 - haskell bindings for memcached (AlsonKemp)
18:54:54 <jeffwheeler> SamB: Hehe; it'd save tons of time on large packages like yi
18:55:06 <jeffwheeler> SamB: even on a fast machine, Haddock takes a good twenty minutes
18:55:41 <nominolo> SamB: ok, ScopedTypeVars was not on the short list
18:56:01 <SamB> nominolo: maybe he thought it would take too long to write up?
18:57:13 <nominolo> SamB: yeah, Hugs and GHC are different, for example
18:57:17 <nominolo> http://hackage.haskell.org/trac/haskell-prime/wiki/ScopedTypeVariables
18:57:26 <SamB> and then there's the bikeshed thing
18:57:50 <SamB> the nice thing about nuclear power plants is that it's not quite so hard to agree on when they are well-designed
18:58:02 <impl> haha.
18:58:08 <SamB> the not-so-nice thing is that it takes too long to figure out the design
18:58:51 <pikhq> And the horrible thing is that a lot of people in the US fight to prevent them from being made.
18:58:52 <ski> FunctorSalad_ : no
18:59:02 <pikhq> (because somehow coal plants make more sense)
18:59:13 <SamB> well, REAL nuclear power plants aren't quite as much fun-and-games as figurative ones ;-)
18:59:42 <pikhq> Still much nicer than coal, assuming no disasters.
18:59:52 <SamB> I mean, they do generate that hard-to-get-rid-of, radioactive waste ...
19:00:13 * pikhq wishes for breeder reactors
19:00:25 <pikhq> Sorry, breeder reactors in use.
19:00:28 <SamB> pikhq: isn't that the kind you use to make weapons?
19:00:43 <pikhq> SamB: That is one of their uses, yes.
19:00:53 <cjb> SamB: bullets, though, right?
19:00:55 <cjb> not nuclear weapons
19:01:13 <pikhq> They can also be fed radioactive waste in order to get more usage out of the radioactive material.
19:01:17 <SamB> cjb: no, I meant the weapon-friendly isotopes
19:01:35 <cjb> SamB: oh, I didn't know about that
19:01:41 <drhodes> scientists in israel just whipped up an injection to prevent radiation sickness.
19:01:54 <SamB> drhodes: consisting of ?
19:02:03 <pikhq> Letting you have less waste, simply because your waste consist of what's left from the breeder reactor, not the power plant.
19:02:03 <SamB> (radiation?)
19:02:11 <drhodes> tops secret, I presume.
19:02:18 <cjb> pikhq: there's also thorium vs. uranium
19:02:26 <pikhq> The treatment is a chemical that temporarily stops apoptosis.
19:02:28 <SamB> thorium?
19:02:54 <Berengal> @go thorium
19:02:56 <lambdabot> http://en.wikipedia.org/wiki/Thorium
19:02:56 <lambdabot> Title: Thorium - Wikipedia, the free encyclopedia
19:03:14 <cjb> SamB: http://www.inference.phy.cam.ac.uk/withouthotair/c24/page_166.shtml
19:03:26 <cjb> (see that whole chapter starting at p161, it's fascinating)
19:03:48 <cjb> and see the leak story on the next page (167) if you think we're good at designing nuclear reactors :-(
19:04:14 <pikhq> I think it's *possible* to create good nuclear reactors.
19:04:25 <pikhq> And that the French seem to have done a decent job.
19:04:59 <cjb> naturally.  rephrase to "if you think that well-developed countries would be unlikely to thoroughly mess up the safety situation at a large nuclear reactor".
19:05:28 <Berengal> Is this all somehow an allegory to Haskell?
19:05:46 <nominolo> and that, ladies and gentlemen, is how you get from Scoped Type Variables to Nuclear Powerplants!
19:06:12 <Berengal> -XNuclearPowerplant
19:06:24 <Zao> atomically { runReactor }
19:06:24 <nominolo> -XUnsafeLaunchRocket
19:06:30 <cjb> Berengal: I'd love to say yes, but, um, no.
19:06:33 <nominolo> er, Missiles
19:06:38 <pikhq> Berengal: You see, imperative languages are like nuclear power plants.
19:06:50 <pikhq> Whereas purely functional languages are like free energy.
19:06:55 <Berengal> -XUnsafeLaunchNuclearPowerplant
19:06:57 <nominolo> yeah, they're all efficient
19:06:58 <pikhq> Except without the violations of any natural laws.
19:07:26 <nominolo> just when something doesn't work as expected you're fucked
19:07:28 <Berengal> The laws of thermodynamics don't apply to mathematics!
19:07:40 <nominolo> but to CPUs
19:07:43 <pikhq> Quite right.
19:07:53 <Rotaerk> purely functional languages are like brains kept alive but unattached to a body
19:08:02 <hydo> Before I go crawling through the docs, does anyone know if there is a standard function that will take [[(a,a)],[(a,a)]] and give  [(a,a)]  Sort of like concat, but not really.
19:08:22 <nominolo> unions?
19:08:29 <nominolo> :t unions
19:08:31 <lambdabot> Not in scope: `unions'
19:08:33 <beutdeuce> is there a way to suppress output in ghci?
19:08:33 <hydo> or, better yet, is there a good way to search for that sort of thing?
19:08:48 <beutdeuce> for functions that return a huge output?
19:08:59 <Berengal> @hoogle (Eq a) => [a] -> [a] -> [a]
19:09:00 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
19:09:00 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
19:09:00 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
19:09:10 <pikhq> beutdeuce: What, like x `seq` ()?
19:09:26 <pikhq> (you don't want that. You really don't.)
19:09:31 <Rotaerk> hydo, you mean for removing duplicates?
19:09:49 <beutdeuce> no, like to find the runtime of a function without seeing the output?
19:10:07 <Rotaerk> hydo, your example isn't too clear on what it does
19:10:15 <Berengal> beutdeuce: seq should work
19:10:41 <beutdeuce> @hoogle seq
19:10:42 <lambdabot> Data.Sequence data Seq a
19:10:42 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
19:10:42 <lambdabot> Control.Parallel.Strategies seqList :: Strategy a -> Strategy [a]
19:10:52 <pikhq> :t seq
19:10:53 <lambdabot> forall a t. a -> t -> t
19:11:05 <hydo> Rotaerk: naw, I'm using Database.SQLite and doing a plain old 'select -column- from -table-"  the result it gives back is [[[("name","value")][("name","value"]]]  and I want to flatten this out.  I thought there might be a standard lib function for it... before I wrote one myself.
19:11:36 <beutdeuce> Berengal: i'm getting a No instance for (Show (t -> t))
19:11:37 <Rotaerk> hydo, okay it takes a set of key-value pairs, and returns what
19:11:56 <Berengal> beutdeuce: You need a second value to return instead
19:12:28 <hydo> Rotaerk:  [(key,value)]
19:12:39 <Rotaerk> hydo, which key and value
19:12:42 <beutdeuce> Berengal: how would i format it?
19:12:50 <pikhq> beutdeuce: seq takes two values of two different types. It evaluates both and returns the result of the second one.
19:13:02 <hydo> Rotaerk: though I'm reading the input as a list of a list of single tuples
19:13:10 <Berengal> > repeat "foo" `seq` () -- beutdeuce, like this
19:13:12 <lambdabot>   ()
19:13:22 <beutdeuce> i want to find out how long does it take to compute: collatz(123^321)
19:13:46 <Rotaerk> hydo, you're still not being specific enough... given [ [(a,b)], [(c, d)] ], what does it return
19:13:47 <Berengal> beutdeuce: collatz (123^321) `seq` ()
19:14:06 <hydo> Rotaerk: [(a,b),(c,d)]
19:14:19 <beutdeuce> lol, 0.00 secs?
19:14:25 <Berengal> hydo: Why doesn't concat work?
19:14:27 <chessguy_> howdy ya'all
19:14:59 <hydo> Berengal: one sec... i'll show ya
19:15:17 <Rotaerk> yea concat should work
19:16:49 <hydo> Berengal: http://snurl.com/ngfdl
19:17:19 <hydo> Berengal: I'm assuming there is a more elegant solution than just chaining calls to concat...
19:17:26 <Rotaerk> hydo, it's because there's another level of list there
19:17:44 <Rotaerk> (concat . fst)
19:17:58 <Berengal> head . head seems to work actually
19:18:25 <Rotaerk> err yea head not fst
19:18:59 <Berengal> Why is it nesting the result set like that anyway?
19:19:20 <Berengal> (Also, head . head won't work, concat . head will)
19:19:31 <Rotaerk> > (concat . head) [[[(1,2)], [(3,4)]]]
19:19:33 <lambdabot>   [(1,2),(3,4)]
19:20:04 <hydo> Yep!  Thanks Berengal and Rotaerk!
19:20:24 <Berengal> hydo: What's the type of the function you're using to call into the db?
19:20:35 <Rotaerk> it seems odd that it's returning such a nested mess though
19:21:45 <Rotaerk> well no... I suppose the list of pairs is a record, and the list of lists is a table... or the results of a query, and the list of lists of lists is the set of tables (if you do multiple queries in one)
19:21:54 <hydo> Berengal: it's pretty big... the interesting part (at least I think what you're asking about) is IO (Either String [[Row String]]
19:22:01 <hydo> err... + )
19:23:25 <beutdeuce> let's say I have a list of lists and I want to find out which list in the main list is the longest list out of all the other lists. Ex: [[1,5,3,4],[3,4]], The first list is longer, so the output would be that list
19:23:34 <Berengal> Ah, yes, so type Table a = [a]; type Row = [(Name, Value)]; fetchRows = [Table Row]
19:23:55 <Berengal> :t maxBy
19:23:57 <lambdabot> Not in scope: `maxBy'
19:24:00 <Berengal> :/
19:24:13 <Berengal> I guess comparing works
19:24:26 <loop_> :t maximumBy
19:24:27 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
19:24:32 <Berengal> Or that one
19:25:34 <mmorrow> @type maximumBy (compare `on` length)
19:25:36 <lambdabot> forall a. [[a]] -> [a]
19:25:44 <Berengal> maximumBy (curry (genericLength *** genericLength))
19:25:57 <copumpkin> Berengal: wow
19:26:00 <copumpkin> that's pretty epic :P
19:26:18 <mmorrow> heh
19:26:19 <copumpkin> :T maximumBy (curry (join (***) genericLength))
19:26:22 <copumpkin> :t maximumBy (curry (join (***) genericLength))
19:26:23 <lambdabot>     Couldn't match expected type `Ordering'
19:26:24 <lambdabot>            against inferred type `(c, c)'
19:26:24 <lambdabot>     In the first argument of `maximumBy', namely
19:26:26 <copumpkin> aw
19:26:36 <mmorrow> @type maximumBy (curry (genericLength *** genericLength))
19:26:38 <Berengal> You probably need to add some type signature to restrict it to Natural
19:26:38 <lambdabot>     Couldn't match expected type `Ordering'
19:26:38 <lambdabot>            against inferred type `(i, i1)'
19:26:38 <lambdabot>     In the first argument of `maximumBy', namely
19:26:55 <mmorrow> wow lag
19:27:00 <Berengal> Also, I'm confused by claims of epicness...
19:27:14 <mmorrow> , maximumBy (compare `on` length) [[1,5,3,4],[3,4]]
19:27:16 <lunabot>  [1,5,3,4]
19:27:57 <mmorrow> , maximumBy (compare `on` sum) [[1,5,3,4],[3,99]]
19:27:59 <lunabot>  [3,99]
19:28:17 <mmorrow> , maximumBy (compare `on` minimum) [[1,5,3,4],[3,99]]
19:28:18 <beutdeuce> thanks
19:28:19 <lunabot>  [3,99]
19:29:00 <pikhq> > maximumBy (comparing minimum) [[1,5,3,4],[3,99]]
19:29:02 <lambdabot>   [3,99]
19:29:51 <beutdeuce> i get undefined variable on
19:29:56 <mmorrow> Data.Function
19:30:16 <mmorrow> um, are you in ghci?
19:30:40 <mmorrow> if not then there probably is no Data.Function
19:30:49 <beutdeuce> no emacs haskell-mode hugs
19:31:14 <mmorrow> i've never used hugs
19:31:33 <beutdeuce> me neither, always used ghci, just haskell-ode comes ith hugs
19:31:54 <beutdeuce> it says cant find Data.Function
19:32:03 <lpsmith> > maximumBy (comparing minimum) [[1,5,3,4],[3,99,1]]
19:32:04 <lambdabot>   [3,99,1]
19:32:50 <lpsmith> You probably want a smarter maximumOn for that
19:33:05 <lpsmith> You don't need a full Schwartzian transform though
19:33:09 <Mr_Awesome> how can i use lambdabot to get the source code of a specific instance of a class function?
19:33:32 <mmorrow> beutdeuce: n'existe pas
19:33:33 <beutdeuce> @let collatz 1 = [1] ; collatz n = if even n then n:collatz(n `div` 2) else n:collatz(3*n+1)
19:33:35 <lambdabot>  Defined.
19:34:10 <beutdeuce> @let list = map collatz [999999,999997..90001]
19:34:12 <lambdabot>  Defined.
19:34:26 <lpsmith> Besides,  I'm not sure how useful maximumOn really is,  I'd prefer a maximalsOn
19:34:39 <beutdeuce> > maximumBy (compare `on` length) list
19:34:45 <lambdabot>   mueval-core: Prelude.read: no parse
19:34:45 <lambdabot>  mueval: ExitFailure 1
19:35:04 <beutdeuce> > collatz 999999
19:35:07 <lambdabot>   [999999,2999998,1499999,4499998,2249999,6749998,3374999,10124998,5062499,15...
19:36:08 <beutdeuce> not in scope maximumBy?
19:36:20 <Berengal> haskell-mode comes with hugs?
19:36:34 <beutdeuce> @let answer = maximumBy (compare `on` length) list
19:36:36 <lambdabot>  Defined.
19:36:53 <beutdeuce> > head answer
19:36:56 <lambdabot>   * Exception: stack overflow
19:37:02 <beutdeuce> thats shouldnt be an overflow
19:37:08 <mmorrow> > list
19:37:10 <lambdabot>   [[999999,2999998,1499999,4499998,2249999,6749998,3374999,10124998,5062499,1...
19:37:17 <mmorrow> > fmap length list
19:37:20 <lambdabot>   [259,114,259,166,166,109,114,114,166,114,259,114,114,114,259,114,140,114,25...
19:37:26 <mmorrow> > length $ fmap length list
19:37:28 <lambdabot>   455000
19:38:08 <Berengal> Yeah... no. This won't work with lambdabot, at least not online...
19:38:11 <mmorrow> probably maximumBy is too lazy maybe
19:38:16 <Berengal> maximumBy is lazy as hell
19:38:27 <Berengal> In the same way foldl is
19:38:32 <mmorrow> yeesh
19:38:34 <beutdeuce> how come my ghci says not in scope maximumBy?
19:38:42 <Berengal> @src maximumBy
19:38:43 <lambdabot> Source not found. You speak an infinite deal of nothing
19:38:45 <mmorrow> beutdeuce: because it's not in scope :)
19:38:49 <Berengal> @src maximum
19:38:50 <lambdabot> maximum [] = undefined
19:38:50 <lambdabot> maximum xs = foldl1 max xs
19:38:54 <beutdeuce> how do i bring it in scope?
19:38:58 <mmorrow> @hoogle maximumBy
19:38:58 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
19:38:59 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
19:39:02 <beutdeuce> oh
19:39:04 <beutdeuce> k
19:39:07 <mmorrow> :)
19:39:11 <beutdeuce> :)
19:40:41 <beutdeuce> yep, found the answer offline. Thanks for the maximumBy, say, how do u come across such useful functions that exist in external libraries?
19:43:19 <beutdeuce> huh, even though i found the answer, project euler isnt taking it
19:44:21 <Berengal> beutdeuce: Which answer did you find?
19:44:29 <beutdeuce> 77031
19:44:44 <Berengal> That's wrong
19:45:08 <beutdeuce> oh, lol, i wasnt using the right amount of numbers
19:45:09 <Berengal> And easy to demonstrate, since 77031*2 < 1 million, and is 1 longer
19:45:13 <beutdeuce> yeah
19:45:14 <beutdeuce> typo
19:45:16 <beutdeuce> h/o
19:46:04 <beutdeuce> 929497
19:46:08 <beutdeuce> 939497
19:46:18 <beutdeuce> no
19:46:19 <beutdeuce> h/o
19:46:44 <beutdeuce> 837799
19:47:30 <beutdeuce> yep, thats it
19:47:36 <beutdeuce> takes 4.5 seconds to calculate
19:47:58 <Berengal> I think I just cheated and used MemoTrie on that one...
19:48:26 <mmorrow_> are we talking about collatz?
19:48:31 <beutdeuce> yes
19:48:56 * mmorrow_ digs up his collatz code
19:49:20 <Cale> http://imgur.com/qy8jN.jpg -- ahahaha
19:49:46 <beutdeuce> :D
19:50:34 <mmorrow_> my collatz http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7143#a7143
19:51:09 <beutdeuce> mmorrow_: runtime?
19:51:36 <mmorrow_> real	0m1.764s
19:51:36 <Mr_Awesome> anyone happen to know where to find the ((->) r) monad instance source?
19:51:45 <dobblego> Control.Monad.Instances
19:52:24 <Berengal> > let loeb x = let a = fmap (\f -> f a) x in loeb (0:1:[(+1).(!!(if even n then div n 2 else n*3+1)) | n <- [2..]])
19:52:26 <lambdabot>   not an expression: `let loeb x = let a = fmap (\f -> f a) x in loeb (0:1:[(...
19:53:06 <Mr_Awesome> ah, thank you.
19:53:15 <Berengal> > let loeb x = let a = fmap (\f -> f a) x in a in loeb (const 0:const 1:[(+1).(!!(if even n then div n 2 else n*3+1)) | n <- [2..]])
19:53:21 <lambdabot>   [0,1,2,8,3,6,9,17,4,20,7,15,10,10,18,18,5,13,21,21,8,8,16,16,11,24,11,112,1...
19:53:42 <Berengal> (Becomes somewhat slow long before 1 million though, I'm afraid)
19:54:11 <beutdeuce> my collatz => http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7144#a7144, runtime - 4.5s
19:55:57 <mmorrow_> the highlight of mine is the recursive let in "len", which inserts the length into the Map before it knows what it is
19:56:24 <beutdeuce> yes, and dramatically improves computation time
19:56:26 <Berengal> mmorrow_: I tried using loeb with Map, but I didn't know Map was strict at the time :(
19:56:50 <Berengal> I could probably use a trie...
19:57:30 <mmorrow_> Berengal: how did you try to use loeb?
19:58:04 <mmorrow_> ahh, where (Map k) is the functor i take it
19:58:06 <Berengal> mmorrow_: Map Int (Map Int Int -> Int)
19:58:38 <Berengal> Should be an extra set of parenthesis at the end
19:58:48 <Berengal> Map Int (Map Int (Int -> Int))
19:58:54 <Berengal> No, it shouldn't
19:58:57 * Berengal makes coffee
19:58:59 <mmorrow_> maybe try adding a ~ pattern somewhere?
19:59:14 <mmorrow_> sometimes that magically fixes fix stuff
19:59:15 <Berengal> Yeah, that could work...
19:59:24 <Berengal> I don't have the code anymore though
19:59:33 <Berengal> But it was only a couple of lines
19:59:53 <beutdeuce> @let list = map digitToInt show(2^1000)
19:59:55 <lambdabot>  <local>:12:0:
19:59:55 <lambdabot>      Multiple declarations of `L.list'
19:59:55 <lambdabot>      Declared at: <loca...
20:00:11 <beutdeuce> @let mylist = map digitToInt show(2^1000)
20:00:13 <lambdabot>  Couldn't match expected type `[Char]'
20:00:21 <beutdeuce> why did i get that?
20:00:39 <Berengal> > map digitToInt (show (2^1000))
20:00:40 <FunctorSalad_> Cale: I don't think I totally agree with the sentiment in that comic... if we only talked about things we have a perfect understanding of, there wouldn't be much conversation :)
20:00:41 <lambdabot>   [1,0,7,1,5,0,8,6,0,7,1,8,6,2,6,7,3,2,0,9,4,8,4,2,5,0,4,9,0,6,0,0,0,1,8,1,0,...
20:00:53 <beutdeuce> ah right
20:00:53 <FunctorSalad_> Cale: of course, the examples there are over the top
20:02:28 <beutdeuce> > print $ sum $ map digitToInt $ show(2^1000)
20:02:31 <lambdabot>   <IO ()>
20:02:42 <beutdeuce> aw, that was the answer to number 16
20:03:08 <beutdeuce> > sum $ map digitToInt $ show(2^1000)
20:03:10 <lambdabot>   1366
20:07:26 <coCocoa|in> Speaking of collatz, I found http://www.cs.uwaterloo.ca/journals/JIS/VOL11/Snapp/snapp.pdf interesting. But then, who ever heard of U Waterloo? ;p
20:08:15 <FunctorSalad_> then it must be wrong...!
20:08:47 <beutdeuce> o.0 how do u approach # 18
20:09:49 <Berengal> Ah, #18 is one of my favorites in haskell
20:09:53 <coCocoa|in> beutdeuce: Chair and whip? ;p
20:09:55 <Berengal> Has a nifty one-liner...
20:20:27 <rovar> hrrm
20:20:42 <rovar> does anyone happen to know where I can find a primer on logic notation?
20:20:59 <rovar> googling for it seems to give me tutorials about making music with software
20:23:45 <rovar> this is close: http://www.maartensz.org/philosophy/Dictionary/L/Logic%20Notation.htm
20:27:39 <rovar> it doesn't cover the squarish backwards E what is that?
20:28:17 <rovar> is Friday night the wrong night to learn type theory?
20:28:28 <copumpkin> that's exists?
20:28:28 <Cale> backwards E means 'there exists'
20:28:46 <beutdeuce> Cale: as in elem ?
20:28:50 <Cale> no
20:29:06 <rovar> what's upside-down A?
20:29:10 <Cale> "for all"
20:29:35 <rovar> and the  horizontal line that bends down on the right?
20:29:51 <kadoban> rovar: that page uses pretty crappy symbols
20:29:57 <Cale> ∀x. ∃y. x + y = 0
20:30:02 <Cale> rovar: 'not'
20:30:03 <rovar> it's the best I could find
20:30:16 <Berengal> ¬_¬
20:30:22 <Gracenotes> oh god. dealing with ALSA after a kernel upgrade is such a bitch
20:30:47 <rovar> Gracenotes:  dealing with ALSA * * * is such a bitch
20:30:49 <Axman6> is there (a need for) a such that symbol?
20:31:01 <kadoban> Axman6: which one?
20:31:08 <rovar> such that
20:31:23 <Cale> Axman6: Depending on context, that might be rendered as a colon or a vertical line
20:31:24 <kadoban> oh, i totally read that wrong
20:31:25 <kadoban> haha
20:31:25 <Gracenotes> true that. it is the most hassle-free way of getting sound simply working on Ubuntu though
20:31:41 * coCocoa|in ,  for some reason, imagined Ms. Cheng in a flak jacket and Kevlar helmet, after seeing the "Army Cats" blurb on Cale's picture
20:31:58 <rovar> Gracenotes:  i do prefer it to that new one.. blanking on the name
20:32:12 <rovar> it's been broken on my fedora 11 since i installed it
20:32:25 <Berengal> Pulseaudio?
20:32:31 <rovar> yes
20:32:52 <rovar> i notice the new version of OSS supports pretty much everything alsa was created for
20:32:52 <Berengal> for some reason, gnome sucks at my sound, KDE rocks at it, and windows is somewhere in the middle
20:33:27 <Axman6> Cale: so... ∀x. ∃y: x + y = 0 or ∀x. ∃y | x + y = 0
20:33:29 <rovar> actually I run KDE. My guess is there isn't as much of a focus on making sound work in KDE on fedora.. not sure.. I haven't cared much.
20:33:45 <rovar> what is the . ?
20:33:46 <Cale> Axman6: oh, no, that's usually just the dot
20:33:53 <Cale> rovar: Just a separator
20:33:55 <Axman6> fair enough
20:33:56 <rovar> kay..
20:34:24 <Cale> You could use a colon instead, too.
20:34:32 <Cale> ∀x: ∃y: x + y = 0
20:34:36 <Gracenotes> speaking of seperators, | is totally superior to : in set builder notation, amirite
20:34:37 <Cale> Or just nothing at all
20:35:08 <Cale> (but that can be a little confusing if you don't bracket the innermost sentence sometimes)
20:35:17 <Cale> ∀x ∃y (x + y = 0)
20:35:22 <rovar> what is the most convenient way to input those special chars?
20:35:23 <FunctorSalad_> or a comma :) flows better
20:35:29 <FunctorSalad_> a dot sounds serious.
20:35:38 <SamB> rovar: a nice IM like the SCIM "LaTeX" table
20:35:43 <Berengal> { x + 2  | x ← N }
20:35:45 <FunctorSalad_> for all. x. there exists. y.
20:35:52 <SamB> rovar: or perhaps just a compose key
20:36:03 <Cale> Gracenotes: I don't know about that, I use colon quite often myself.
20:36:07 * coCocoa|in thinks he's the only one to check out Elgin Lee's Self thesis this millenium
20:36:07 * Berengal needs to map more symbols to his third level
20:36:08 <beutdeuce> I'm trying to do Euler # 21 in Mathematica and i'm stuck at the last part, can someone point me where i am wrong in my logic: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7145#a7145
20:36:12 <kadoban> SamB: wow, i never knew scim had that, nice
20:36:40 <SubStack> mathematica? ghastly!
20:36:58 <SamB> kadoban: it's probably under some "misc" package in your OSes pacakages ...
20:37:20 <kadoban> SamB: ya, i think i see it, installing now
20:37:26 <Gracenotes> Cale: hehe. It may just be that I've used it for as long as I can remember, but I like it better, as though the first part is separated as a little compartment that's applied foreach of the elements satisfying the condition
20:37:29 <Cale> beutdeuce: That's a pointless use of If
20:37:33 <SamB> SubStack: hey, I started one in Mathematica and I think I would have finished it if my class hadn't switched to a computerless room
20:37:39 <FunctorSalad_> am I the only one for whom scim periodically stops working :(
20:37:49 <Gracenotes> はい
20:37:52 <SamB> FunctorSalad_: what sort of period?
20:38:00 <SamB> i.e. does an X restart fix it?
20:38:03 * SubStack did #21 in haskell
20:38:04 <Cale> beutdeuce: Also, you're passing the same value to both parameters of AmicablePairQ
20:38:06 <beutdeuce> Cale: how so?
20:38:08 <FunctorSalad_> the tray icon is still there, but it doesn't do anything (it is still set to latex)
20:38:11 <rovar> ¬∀x. ¬P(x) ⇒ ∃x. P(x)
20:38:16 <Cale> beutdeuce: If[p,True,False] = p
20:38:25 <SamB> FunctorSalad_: do you have the floaty panel?
20:38:29 <rovar> apparently colloquy has a symbol table
20:38:35 <SamB> FunctorSalad_: try hitting "shift"
20:38:38 <SamB> possibly the left one
20:38:40 <Gracenotes> although really, SCIM sometimes just doesn't want to enable for text fields, and you need to switch windows, or something
20:38:43 <FunctorSalad_> SamB: "randomly" would have been more accurate; yes, an X restart fixes it, and I think sometimes it fixes itself
20:38:47 <SamB> it tends to toggle the actual IM on and off
20:39:15 <rovar> ϖ
20:39:22 <FunctorSalad_> SamB: which is floaty? I'm confused by all this "on the spot, over the spot, off the spot" stuff
20:39:28 <Cale> beutdeuce: AmicablePairQ[#,#]&  is shorthand for  Function[x, AmicablePairQ[x,x]]
20:39:34 <FunctorSalad_> to make it worse there are like 5 setup points
20:39:38 <Cale> which I'm pretty sure is not what you mean
20:39:39 <SamB> SamB: well, I have no systray
20:39:47 <FunctorSalad_> qt settings, Xorg settings, tray thingy settings :(
20:39:50 <FunctorSalad_> it's such a mess
20:39:53 <SamB> I have this bar that I keep near the corner of the screen
20:39:55 <Cale> especially since that will always be False
20:40:10 <beutdeuce> no, i tried and it showed True when needed
20:40:25 <FunctorSalad_> SamB: AHHHH it is shift
20:40:28 <beutdeuce> ex: AmicablePairQ[220,284]
20:40:32 <FunctorSalad_> shift toggles it
20:40:33 <beutdeuce> returned True
20:40:34 <FunctorSalad_> ^^
20:40:37 <Cale> beutdeuce: Also, what's this x = Subset[1,10000]
20:40:41 <FunctorSalad_> SamB: thanks
20:40:42 <SamB> it has a 2x2 layout of 'SCIM' as an icon on the left, then a push pin, then the input method, then some menu-y icon, then a ? in a circle ...
20:40:59 <Cale> beutdeuce: You didn't read what I just said properly somehow
20:41:10 <Cale> beutdeuce: You're passing it the same parameter twice
20:41:16 <rovar> hurray, now I can go to page 3 in Type Theory and Functional Programming
20:41:28 <beutdeuce> yes, i know, i dont know how to try eery number less than 10000 as two different values
20:41:36 <Cale> beutdeuce: AmicablePairQ[#,#]& means Function[x,AmicablePairQ[x,x]]
20:41:42 <beutdeuce> yes
20:41:46 <beutdeuce> i know its wrong
20:41:58 <mail> Guys!
20:41:59 <beutdeuce> i dont know how tto make it right
20:42:06 <mail> how do i divide by 0 in haskell
20:42:09 <FunctorSalad_> "I know its wrong so what should I do..."
20:42:33 <SamB> "the input mtehod" consisting of an overall icon + name associated with icon that can be clicked to switch to another from a menu, as well as possibly (a) a character representing what mode the IM is in (for LaTeX this would be on/off) and (b) some other settings (like half/full and such for japanese IMs)
20:42:54 <Berengal> > 1/0
20:42:56 <lambdabot>   Infinity
20:43:15 <FunctorSalad_> why does shift toggle it? I have toggle set to something else
20:43:24 <mail> guys!
20:43:39 <mail> how can i calculate pi to a rational number using haskell
20:43:48 <Berengal> > pi
20:43:50 <lambdabot>   3.141592653589793
20:44:00 <beutdeuce> Cale: how would i use different values as parameter trying every possible combination to find all possible ammicable numbers
20:44:09 <Cale> beutdeuce: Well, one thing that you can't seem to do is make a list of all the possibilities. Mathematica is not lazy, and a 10000 by 10000 list of pairs is a lot of memory.
20:45:20 <mail> Guys!
20:45:30 <mail> how can you solve the Riemann hypothesis using haskell
20:45:37 <Berengal> Cale: "Mathematica is not lazy,", I was somewhat shocked by these words. It seems it's hard for me to imagine non-lazy evaluation anymore
20:45:41 <Cale> mail: What do you mean by that?
20:45:53 <FunctorSalad_> don't feed
20:45:54 <Cale> mail: You want to search for counterexamples?
20:46:31 <Cale> FunctorSalad_: I feed trolls until they explode.
20:46:35 <kadoban> he's off to search alraedy i guess
20:46:41 <rovar> what is ∧  is that xor?
20:46:47 <Cale> rovar: 'and'
20:46:58 <Cale> The upside-down version of it is 'or'
20:47:03 <rovar> right
20:47:12 <kadoban> xor is a cross in a circle i think
20:47:22 <Cale> (from Latin 'vel')
20:47:36 <rovar> so what is the corresponding ⊗ ?
20:48:18 <FunctorSalad_> tensor product
20:48:36 <rovar> this is all starting to make sense
20:48:45 <FunctorSalad_> :)
20:48:46 <rovar> I might make it through the introduction of this book
20:48:50 <kadoban> haha
20:48:53 <impl> Has anyone here ever used Factor [http://www.factorcode.org/] ?
20:49:03 <Cale> impl: I've looked at it briefly.
20:49:04 <FunctorSalad_> to be fair, ⊕ is direct sum in the context where ⊗ would be tensor product
20:49:12 <impl> Cale: Thoughts?
20:49:25 <Berengal> impl: Not yet, but I'm going to once I've got some spare time to waste
20:49:25 <Cale> impl: It's interesting.
20:49:29 <rovar> if it's not Haskell it crap!
20:49:37 <rovar> </scottish accent>
20:49:53 * impl is going to give it a try, he thinks
20:49:58 <FunctorSalad_> rovar: Haskle!
20:50:09 <copumpkin> oh no
20:50:17 <impl> it seems you can redefine syntax and such, which seems pretty neat.
20:50:19 <copumpkin> it's eu_prleu_prpreu or whatever
20:50:28 <FunctorSalad_> :)
20:51:12 <Berengal> I've encountered some factor evangelizers. It's always a good sign when a language has fanatics
20:51:21 <Cale> impl: I think the stack paradigm possibly makes it a bit harder to typecheck than needs be, but it's definitely a fairly expressive language.
20:51:23 <FunctorSalad_> XOR doesn't seem to come up often enough to have a standard symbol, it seems
20:51:43 <pikhq> Factor seems to be mostly a modern take on Forth.
20:51:58 <impl> Cale: aye
20:52:02 <pikhq> Which, in my estimation, is a perfectly good idea for a language.
20:52:14 <Berengal> pikhq: That's the impression I've gotten as well. Saves me the trouble of learning forth ;)
20:52:25 <FunctorSalad_> probably because people prefer λ P Q -> P ⇔ not(Q)   I suppose
20:52:52 <rovar> what's the two sided arrow?
20:53:00 <FunctorSalad_> rovar: equivalence
20:53:04 <rovar> ah
20:53:05 <Cale> rovar: 'if and only if'
20:53:06 <pikhq> FunctorSalad_: Bu, but p ^ q!
20:53:36 <Cale> p <=> q  is the same as  (p => q) and (q => p)  is the same as  (q or not p) and (p or not q)
20:54:00 <rovar> makes sense
20:54:43 <monochrom> p <=> q is the same as (p is the same as q).  <duck>
20:54:58 <rovar> okay.. off to bed, thanks for your help all.
20:55:03 <FunctorSalad_> monochrom: that's an optional axiom in coq
20:55:14 <FunctorSalad_> (p <=> q -> p = q)
20:55:42 <FunctorSalad_> by default "=" is just syntactical equality
20:55:44 <monochrom> The <=> operator is associative. And so...
20:55:46 <pikhq> So, (p <=> q) <=> (p is the same as q)
20:55:52 <jdrake_> hmm, <=> seems rather daft
20:56:04 <Cale> jdrake_: why?
20:56:26 <Cale> jdrake_: In logic, we often want to say that the truth of one statement is equivalent to the truth of another.
20:56:55 <monochrom> (p<=>q is the same as p) is the same as q, too.
20:57:02 <jdrake_> Can't = be the equality?
20:57:22 <Cale> jdrake_: That can be confusing when the statements being discussed are themselves equations
20:57:46 <monochrom> There is an endian war in "should we use =" vs "should we use <=>".
20:57:54 <jdrake_> Actually it sounds like it is talking about graphed areas overlapping
20:58:07 <FunctorSalad_> it depends on whether you have proof irrelevance
20:58:20 <FunctorSalad_> if you care about the proof "<->" is more abstract than "="
20:58:21 <monochrom> > [ x==y | x<-[True,False], y<-[True,False] ]
20:58:23 <lambdabot>   [True,False,False,True]
20:58:40 <jdrake_> @src (<=>)
20:58:41 <lambdabot> Source not found. Are you on drugs?
20:58:41 <monochrom> And so if you like overloading operators, you like using = for booleans.
20:58:53 <jdrake_> lambdabot: yes, but i am not telling which ones.
20:58:55 <monochrom> Some people don't like to overload operators.
20:59:01 <impl> > [ x<=>y | x<-[True,False], y<-[True,False] ]
20:59:02 <coCocoa|in> Heh-heh...
20:59:02 <lambdabot>   Not in scope: `<=>'
20:59:36 <Cale> Some people don't mind overloading operators until you want multiple overloadings in a small amount of space.
20:59:48 <monochrom> I am of course speaking about classical logic. Constructive logics such as Coq can have different stories.
21:00:03 <jdrake_> If I have what is essentially a [Bool], but I want it to be a special type where I can implement show in a certain way ("0101010101"), is this possible to do?
21:00:09 <Cale> With = it can be particularly confusing, since it's traditional to write things like x = y = z
21:00:14 <FunctorSalad_> prop_degeneracy = forall A : Prop, A = True \/ A = False
21:00:14 <pikhq> And some people define operator() to be an array indexing operator.
21:00:31 <pikhq> (hate bad C++ coders so much!)
21:00:50 <Cale> jdrake_: You could newtype Bins = Bins [Bool], and then write an instance of Show for Bins
21:00:51 <jdrake_> People who override operators for classes in C++ are so so evil, because it usually doesn't make sense
21:00:53 <monochrom> They came from BASIC and Fortain. A(i) is array indexing.
21:01:10 <FunctorSalad_> ah, there it is: prop_extensionality = forall A B : Prop, (A <-> B) -> A = B
21:01:37 <pikhq> monochrom: Must kill.
21:02:07 <Gracenotes> kitty
21:02:21 <pikhq> No, not kill kitty.
21:02:24 <jdrake_> How about + for concating strings?
21:02:28 <pikhq> Kitty nice. Kitty is kitty.
21:02:31 <pikhq> jdrake_: No.
21:02:31 <Gracenotes> no! hug kitty!
21:02:51 <Gracenotes> a kitty jumps onto your lap. do you pet kitty (Y/N/A)
21:02:59 <FunctorSalad_> aww
21:03:02 <pikhq> I think the nicest use of operator overloading I've seen is in the GMP C++ bindings.
21:03:07 * jdrake_ puts kitty in his rice cooker and steams a nice kitty al dente.
21:03:09 <kadoban> Gracenotes: don't abort the kitty
21:03:15 <pikhq> Which use +, *, etc. for what's obvious on bignums.
21:03:49 <Cale> beutdeuce: oh, by the way, you might do something like:  pairs = {}; Print[Dynamic[{i, j, pairs}]]; Do[If[AmicablePairQ[i, j], pairs = Prepend[pairs, {i, j}]], {i, 1, 10000}, {j, i, 10000}]
21:04:31 <Cale> beutdeuce: It takes a really long time to calculate though.
21:04:37 <jdrake_> pikhq: How about * for replicate behaviour on strings :p
21:04:44 <Cale> (which is why I included the Dynamic display of progress)
21:04:44 <beutdeuce> Cale, lol, i began to bruteforce with: For[i = 1, i < 10000, i++,  If[Select[x, AmicablePairQ[#, # + i] &] != {},    Print[Select[x, AmicablePairQ[#, # + i] &]] && Print[i]]  ]
21:04:51 <jdrake_> "5"*9 = "555555555"
21:04:55 <Cale> Do is nicer than For
21:05:06 <Cale> (but it's still imperative)
21:05:08 <pikhq> jdrake_: NO NO NO NO.
21:05:21 * jdrake_ overrides pikhq
21:05:37 <jdrake_> 5 `pikhq` 9 = -4
21:05:46 <FunctorSalad_> monochrom: I think the reason why "=" is often not equivalence is simply that in FOL, props aren't terms
21:06:02 <pikhq> I like my operators to follow the law of least surprise, thanks.
21:06:30 <Cale> DivSum[x_] := DivSum[x] = Total[Most[Divisors[x]]] -- this speeds it up a good deal
21:06:32 <FunctorSalad_> so they can't call wget or something?
21:06:34 <FunctorSalad_> ;)
21:06:39 <Cale> (memoising)
21:06:46 <bgs100> Gracenotes: Y
21:07:02 <Twey> Yeah
21:07:06 <beutdeuce> Cale: yeah, learned earlier today :)
21:07:09 <Gracenotes> kitty purrs
21:07:15 <pikhq> FunctorSalad_: If it calls wget, I am actually killing someone.
21:07:31 <monochrom> I ask one level more than that. Why props aren't terms? Or rather, why set things up so props aren't terms? And an answer is still to avoid overloading.
21:07:39 <FunctorSalad_> pikhq: to call google calculator or something, :D
21:07:54 <Twey> Hahaha
21:07:55 <beutdeuce> Cale: yay, got the answer through bruteforcing for 2 minutes, 32626
21:08:03 <beutdeuce> 31626*
21:08:03 <pikhq> FunctorSalad_: And they will taste nice with a fine Cianti.
21:08:07 <jdrake_> If I were in a module called Chromosome and my type was essentially a 'BooleanChromosome', would there be any really short name for this type that made sense?
21:08:19 <Twey> instance Num String where (*) = flip replicate
21:08:32 <Twey> jdrake_: Er, Boolean?
21:08:37 <FunctorSalad_> Twey: won't work
21:08:46 <Twey> Don't worry about conflicting with names outside your module
21:08:52 <Twey> That's up to the importing module to sort out
21:08:59 <pikhq> Twey: I kill you
21:09:08 <Berengal> How about * for lists?
21:09:08 <Twey> FunctorSalad_: Why not?
21:09:11 <jdrake_> Least surprise is for pussies :p
21:09:17 <Twey> Haha
21:09:43 <Berengal> > let (*) = liftM2 (,) in [1,2,3] * [4,5,6]
21:09:45 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
21:09:46 <jdrake_> Would 'binary' and 'boolean' be essentially equal?
21:09:52 <FunctorSalad_> Twey: (*) has type "a -> a -> a"
21:09:54 <mike-burns> Strings are lists.
21:10:06 <Twey> FunctorSalad_: Oh, right
21:10:08 <Twey> Boo :(
21:10:11 <Twey> jdrake_: Probably not
21:10:18 <Twey> FunctorSalad_: Well...
21:10:21 <Gracenotes> jdrake_: well, binary implies digit. boolean is just two-valued in a generic sense
21:10:29 <pikhq> Berengal: REDRUM.
21:10:42 <Gracenotes> oh wait, scratch that.
21:10:44 <Twey> instance Num String where s * n = read n `replicate` s
21:10:53 <Twey> :-P
21:10:54 <jdrake_> What is the proper way to implement a new Show for a type?
21:11:01 <Twey> "Hello" * "5"
21:11:06 <Berengal> jdrake_: deriving (Show)
21:11:21 <jdrake_> Berengal: ok, and how do I change the actual implementation?
21:11:23 <Gracenotes> still, binary is generally used in a numerical bit-combining sense. boolean in just a two-valued scheme. /connotations
21:11:30 <FunctorSalad_> jdrake_: -ddump-deriv
21:11:36 <FunctorSalad_> then c&p
21:11:36 <Twey> jdrake_: instance Show Type where show x = ...
21:11:42 <jdrake_> FunctorSalad_: ??
21:11:45 <Twey> Heh
21:11:55 <FunctorSalad_> jdrake_: it's a ghc flag that will dump the derived Show instance
21:12:11 <jdrake_> Twey: do I use that instead of deriving?
21:12:13 <FunctorSalad_> assuming you only want to make minor modifications
21:12:16 <Twey> Gracenotes: Boolean is specifically for true/false logic values
21:12:17 <Berengal> jdrake_: You could make the instance yourself, but in the case of Show/Read I find I prefer to make a custom printer/parser
21:12:17 <Twey> jdrake_: Yes
21:12:42 <Twey> Gracenotes: I would consider applying it to anything else an abuse
21:12:48 <Gracenotes> no, boolean is specifically for things belonging to George Boole!
21:12:49 <jdrake_> Berengal: I am just going from [Bool] to 01010101 for printing
21:13:08 <Twey> jdrake_: See, that's bad
21:13:17 <Twey> Gracenotes: :-P
21:13:23 <jdrake_> Twey: not sure how
21:13:26 <Berengal> jdrake_: showBoolList = map (\b -> if b then '1' else '0')
21:13:42 <Twey> @let (y ?? n) p = if p then y else n
21:13:43 <lambdabot>  Defined.
21:13:52 <Twey> showBoolList = map ('1' ?? '0')
21:13:52 <Cale> jdrake_: I suppose it's that most people expect the Show of something to be valid Haskell code to reconstruct it.
21:13:57 <pikhq> jdrake_: What you want is an instance of Num called Bit.
21:14:03 <pikhq> :P
21:14:17 <Twey> jdrake_: If you're representing a string of bits using [Bool], that's a minor abuse of Bool
21:14:29 <jdrake_> How is it abuse?
21:14:29 <Twey> Since it doesn't represent true/false values
21:14:48 <Cale> Twey: whaaaaat
21:14:56 <jdrake_> If i can't abuse that one thing in Haskell, then what else can I abuse?
21:15:03 <Cale> How is a string of bits not a string of true/false values? :)
21:15:05 <Twey> Cale: Encoding a number using a list of booleans?
21:15:20 <Twey> Because they're not used as true/false values
21:15:25 <Twey> On/off and true/false are not the same thnig
21:15:27 <Twey> thing**
21:16:03 <Cale> It's an encoding of when you repeatedly divide the number by 2 whether it's true or false that there's an element left over. :)
21:16:37 <Twey> Hmmm.
21:16:37 <conal> Twey: Hm.  is Bool *ever* meaningful on its own, rather than relative to some condition like on-ness?
21:16:50 <monochrom> Each Bool take a lot of memory.
21:16:50 <bd_> conal: Nothing is meaningful on its own.
21:16:51 <Twey> Yeah, fair point, those two combined.
21:17:00 <FunctorSalad_> now how does *this* parse? τ [µα.τ /α]
21:17:08 <jdrake_> Interestingly enough Bits might a good idea
21:17:15 <FunctorSalad_> (context: polymorphic lambda calculus)
21:17:17 <bd_> conal: Int is just an arbitrary set of items with an equally arbitrary ordering and operations built on it :)
21:17:32 <Twey> τ [(µα . τ) / α]
21:17:34 <Twey> Of course
21:17:42 <jdrake_> †
21:17:45 <Twey> At least in Haskell :-P
21:17:57 <conal> bd_: *especially* Int is arbitrary.
21:17:58 <Cale> I think the μ is a binder
21:18:03 <FunctorSalad_> yeah
21:18:13 <Cale> and the . separates the bound variable from an expression
21:18:26 <FunctorSalad_> type-level fix I assume
21:18:33 <Twey> I'd have to guess τ [µα. (τ/α)], then...
21:18:33 <FunctorSalad_> but still :)
21:18:40 <bd_> conal: Functions are arbitrary too, because their domain and range are types meaningless in a void. Without an external frame of reference, all programming concepts are void of meaning :)
21:18:42 <jdrake_> How does tihs evaluate? ƒ = †++
21:18:55 <Twey> jdrake_: With an error
21:18:59 <Cale> However, I'm not sure what the / or brackets mean. It's vaguely reminiscent of the notation for substitution, except that makes absolutely no sense to me with the μ
21:19:09 <FunctorSalad_> bd_: and since life itself doesn't have an external frame of reference, we conclude that...
21:19:10 <FunctorSalad_> :D
21:19:13 <jdrake_> Twey: what error?
21:19:14 <Twey> †++ is an operator, so if you want to use it without both operands, you need brackets around it
21:19:20 <bd_> FunctorSalad_: Yes, we're all clearly insane :)
21:19:43 * Berengal puts on the crazy hat and dances
21:19:48 <Twey> Of course we are
21:19:52 <FunctorSalad_> Cale: that's what I thought
21:20:07 <SamB> bd_: it could be worse
21:20:12 <SamB> bd_: we could be sane!
21:20:15 <FunctorSalad_> substitute τ for α in what?
21:20:17 <Twey> Sane people can't survive in this world :-P
21:20:45 <Cale> FunctorSalad_: in tau?
21:20:50 <jdrake_> Twey: You might translate that as God++, think C :p
21:20:53 <bd_> that said I would argue that our external frame of reference is physics, and entropy. Then we build up concepts that correlate to observations of said phenomena. And apply these then to programs.
21:21:04 <Cale> FunctorSalad_: except... recursively?
21:21:37 <FunctorSalad_> Cale: ahh so the square brackets are subst brackets, not application
21:21:43 <Cale> FunctorSalad_: I have no idea
21:21:50 <Cale> FunctorSalad_: You shouldn't trust me ;)
21:22:00 <dancor> entropy is a tricky one.. the particles in the box will return to their start positions!
21:22:19 <Cale> FunctorSalad_: Is this from a book or a paper?
21:22:22 <FunctorSalad_> must have been a different paper where "p[A]" meant the polymorphic type p, specialised at A
21:23:32 <FunctorSalad_> Cale: a paper http://www.cs.cmu.edu/~rwh/papers/polyrecrelns/gdpfs.pdf
21:24:04 <FunctorSalad_> with [] for substitution it makes more sense
21:24:33 <Twey> > let (†++) = 3; ƒ = (†++) in ƒ
21:24:34 <lambdabot>   <no location info>: lexical error at character '\63743'
21:24:37 <Twey> :(
21:24:44 <Twey> > isSymbol 'ƒ'
21:24:45 <lambdabot>   False
21:24:50 <Twey> Hmn.
21:25:07 <Twey> WFM locally.
21:26:30 <jdrake_> Perhaps I could use some assistance to find the right type for what I am doing - my program requires something representing two values for a chromosome, nominally could be represented as 0101010101 and I am using lengths from 64 bits to 256 bits (but it could be any length really). What I convert it to after doesn't really matter. What matters is I need to create a random pattern of said random length in the middle of the range specified. I 
21:26:51 <jdrake_> Also need to be able to splice sections
21:27:07 <FunctorSalad_> don't use Bool lists if you need any sort of efficiency
21:27:09 <jdrake_> Say take a small section of one and swap it with a small section from another.
21:27:18 <monochrom> τ [µα . τ / α]  may say: in expression τ look for free occurences of α and replace them by µα . τ
21:27:27 <jdrake_> efficiency isn't too important, I will take the best way of doing what I want though.
21:27:29 <FunctorSalad_> monochrom: yep
21:27:39 <monochrom> Generally e[blahblah / x] means substitution.
21:28:15 <monochrom> There are generally 4 versions.  e[blablah / x], e[x / blahblah], e[x \ blahblah], e[blahblah \ x]
21:28:20 <FunctorSalad_> substitution feels so dirty... with these capture issues
21:28:45 <FunctorSalad_> but I guess at some point you must ground abstract functions in syntax
21:30:04 <monochrom> de Brujn is a clearer but more inhuman way.
21:30:30 <monochrom> de Bruijn
21:30:52 <jdrake_> Would it make sense to create an arbitrary bit array type to do what I want?
21:31:14 <monochrom> It seems to be a trend that clearer or cleaner ways are more inhuman ways. Logic and math syntax, programming languages, de Bruijn, ...
21:31:51 <jdrake_> monochrom: think python
21:32:20 <FunctorSalad_> monochrom: "clear way" and "human way" are opposed?
21:32:20 <monochrom> is python clearer? is python cleaner? is python more human?
21:32:25 <FunctorSalad_> that seems odd
21:32:35 <FunctorSalad_> unless you mean 'clear for the computer'
21:32:57 <monochrom> computer is a human invention too. don't forget that.
21:33:36 <monochrom> "clear for the computer" will have to mean "clearer to some people's notion of what clearer means"
21:33:51 <FunctorSalad_> (fwiw, I recently tried coding a language with binders in coq and gave up in frustration about variable name stuff :/)
21:34:34 <FunctorSalad_> the inductive step for lambda expressions always becomes a mess
21:34:41 <monochrom> Anyway I just said "it seems to be a trend". My position is pretty clear. Trend. Seems.
21:35:26 <monochrom> It upsets me when people fail to read what I wrote.
21:36:48 <jdrake_> Applescript is the most human
21:37:01 <jdrake_> Python is second to it
21:37:12 <jdrake_> The most human is the most incomprehensible to human.
21:37:23 <mike-burns> They're all so far away from natural language that it's a moot point.
21:37:25 <FunctorSalad_> I didn't imply that you made a definite statement
21:37:36 <FunctorSalad_> (monochrom left?)
21:37:45 <jdrake_> How does one make use of 'Bits'?
21:38:06 <Berengal> We're talking about bits on a harddrive and (usually tutti-frutti coloured, but sometimes black) text on a computer screen. What does human even mean in that context?
21:38:49 <pikhq> Funny, I felt like the single most human programming language was mathematics.
21:39:02 <FunctorSalad_> Berengal: originally it was about bound variable names though
21:39:08 <lament> jdrake_: "Make it possible for programmers to write in English, and you will find that programmers cannot write in English"
21:39:20 <jdrake_> lament: I agree completely.
21:39:39 <Berengal> pikhq: I usually thought of mathematics as the language easiest to program in...
21:39:47 <Axman6> jdrake_: applescript is such a bitch to use. it feels more like black magic to me than perl
21:40:01 <jdrake_> Axman6: same here
21:40:23 <jdrake_> Berengal: You are a sick mofo if you think that :p   I don't think there is anything that can help you recover from that
21:40:27 <FunctorSalad_> did monochrom just leave out of frustration that I allegedly didn't read correctly?
21:40:33 <pikhq> Berengal: It seems about as human as you can get, and it's not very human just because formal reasoning is not exceptionally human. :P
21:40:36 <Berengal> FunctorSalad_: I'm not in the habit of anthrophomorphising my variables
21:40:48 <jdrake_> λοωε τηυ νειγηβοθρ
21:41:14 <Berengal> pikhq: Haha, I hear that :)
21:42:27 <lament> Axman6: ever tried inform 6?
21:42:37 <lament> er, inform 7
21:44:09 <Axman6> never heard of it
21:44:13 <lament> e.g. http://www.inform-fiction.org/I7/ex257.html#e257
21:44:20 <lament> the stuff in blue is the source code
21:45:18 * Axman6 starts thinking of ideas for a concurrent, natural programming language: could you please compute pi to 10000 decimal places, and if you could compute e to 10000 decimal places too that would be great
21:45:38 <Axman6> 'and if you could' == forkIO  basically :P
21:45:55 <copumpkin> lol
21:45:59 <copumpkin> no, please no!
21:46:12 * copumpkin 's nightmares are in the language of applescript
21:46:22 <Cale> Axman6: Syntax error: Insufficient politeness.
21:46:59 <Axman6> it's a business language, for managers >_>
21:47:20 <lament> Buzzword check: failed
21:47:25 <ray> would you kindly
21:47:31 <Berengal> The only way to get non-programmers to write programs is to teach them how...
21:47:40 <FunctorSalad_> lament: what's the point of writing in english in a language for interactive fiction? the source is not exposed to the user, is it?
21:48:05 <ray> everyone should know how to program computers
21:48:11 <Berengal> ray++
21:48:14 <FunctorSalad_> or do they just think writers won't like more symbolic languages
21:48:15 <lament> FunctorSalad_: people writing the IF, being primarily writers, enjoy working with source code that looks like that.
21:48:34 <ray> right now only serious head cases bother
21:48:57 <lament> ray: everyone should know pottery
21:48:58 <ray> (and people who heard there's money in it, i guess)
21:49:13 <lament> everyone should certainly know how to build houses, etc
21:49:21 <lament> car repair is pretty crucial
21:49:28 <lament> as is legal defense
21:49:30 <ray> everyone should know how to read, too
21:49:46 <Berengal> Computers are almost more ubiquotous than houses and cars these days
21:49:47 <Axman6> or people who like games, and think that qualifies them to be programmers
21:49:51 <lament> certainly everyone should be able to cook, and yet lots of people can't
21:50:02 <FunctorSalad_> aren't computers more general-purpose than houses and stuff?
21:50:17 <Berengal> lament: Most people can feed themselves given some money and a grocery store though
21:50:29 <jdrake_> How do you teach them to safely program?
21:50:34 <lament> FunctorSalad_: they're certainly less important to survival
21:50:54 <lament> FunctorSalad_: if there's a leak in your roof, that's pretty bad, and yet most people won't be able to repair it
21:50:58 <FunctorSalad_> division of labour etc...
21:51:08 <lament> let's say the leak is right over your bed
21:51:18 <mike-burns> Move your bed. Problem solved.
21:51:33 <lament> \o/
21:51:40 <ray> but you're just attacking the notion that there are things that everyone should know
21:51:41 <Berengal> Get out a ladder and hammer some shit on the roof
21:51:45 <jdrake_> If the leak is above your bed by that point you have structural damage I bet
21:52:07 <mike-burns> This isn't about whether people are phsycially or mentally able to do something; this is about whether people want to/have the time.
21:52:15 <FunctorSalad_> I don't think I liver under the roof anyways ._.
21:52:21 <lament> ray: certainly there're some things everyone should know, such as how traffic lights work
21:52:46 <lament> but programming certainly isn't one of these things (being a highly specialized craft that takes years to learn)
21:52:51 <ray> i'm ranking programming with reading and writing
21:53:06 <FunctorSalad_> how specialised it is was the issue under discussion though
21:53:07 <ray> it is reading and writing, just a different kind
21:53:20 <Berengal> Actually, I don't think I want everyone to know how to program anymore. We've got enough bad coders around already, and they have at least 3 years higher education in the stuff...
21:53:53 <Berengal> imagine everyone and their mom running around. Imagine doing tech support for your family if you parents knew vba
21:53:53 <lament> ray: reading and writing are pretty crucial to living in a modern society, and programming just isn't
21:54:19 <mike-burns> ray: How about painting? Is that just as important for everyone to know how to do as programming?
21:54:34 <ray> i don't know
21:54:44 <lament> mike-burns: paiting, calligraphy, music, and Go
21:54:47 <mike-burns> Sign language seems more important to know than programming.
21:54:49 <lament> *painting
21:54:49 <ray> i only asserted one thing, not all these other things
21:55:48 <BMeph> ray: You're welcome! ;p
21:56:00 <ray> tee hee
21:56:04 <FunctorSalad_> I still think we are confusing "how crucial is this" and "is this general-purpose enough that everyone should learn it"
21:56:11 <dancor> i want more ppl to program
21:56:37 <dancor> even if it's bad programming
21:56:52 <ray> if american public schools are an indication, people don't even agree that reading and writing are important anymore
21:56:53 <lament> i want more people to make clay jars
21:57:02 <lament> even if they're bad clay jars
21:57:16 <FunctorSalad_> maybe only head cases can learn programming? (as ray hinted at)
21:57:16 <lament> and even if they have no use for the jars
21:57:20 <mike-burns> I will admit that it's useful when my clients know something about what I do. It makes communication easier.
21:57:23 <dancor> are there still handwriting classes?  that's a lol
21:57:26 <jdrake_> I was looking at Data::Bits and was wondering if class Num a => Bits a where  is defining Bits as a class that operates of Num types, like definining an interface that the various Num types implement.
21:57:40 <ray> i'm not sure why only head cases become programmers
21:57:53 <dancor> ray++
21:57:54 <ray> i have a few theories
21:57:57 <lament> i don't remember any head cases among the programmers i've met
21:58:04 <dancor> haha
21:58:29 <FunctorSalad_> lament: it was a term of endearment here I think
21:58:43 <dancor> it's bc programming is tedious and difficult
21:58:50 <lament> FunctorSalad_: i don't remember any headcases by any definition
21:58:55 <Berengal> dancor: Doesn't have to be tedious
21:58:55 <lament> FunctorSalad_: other than on IRC for some reason
21:59:02 <Berengal> If it's tedious, you're doing it wrong
21:59:08 <lament> dancor: most crafts are tedious and difficult
21:59:22 <dancor> Berengal: are you sure?  what's an example
21:59:29 <lament> dancor: needlework is certainly more tedious
21:59:33 <FunctorSalad_> lament: because insanity leads to social withdrawal?
21:59:35 <jdrake_> Berengal: OR you are working on the space shuttle software
21:59:38 <lament> architecture is probably more difficult
21:59:45 <lament> FunctorSalad_: sounds reasonable
22:00:17 * BMeph tells dancor that he's tired of all his malarkey, now down and give him 20 (KLOC)! >;)
22:00:18 <Berengal> dancor: Example of what? tedious programming being wrong?
22:00:32 <dancor> Berengal: programming that isn't tedious
22:00:58 <lament> anything you do for a living will be tedious
22:01:15 <dancor> i think automated stuff is what helps the most with coding tedium
22:01:17 <pikhq> I'd hesitate to call all programming tedious.
22:01:20 <copumpkin> skydiving
22:01:20 <Berengal> dancor: That depends on what you think is tedious. If you're actively using your brains to solve problems then it's fun, not tedious
22:01:27 <pikhq> Difficult, most definitely, but not tedious.
22:01:30 <lament> pikhq: not all programming, just all programming you get paid for :)
22:01:32 <Berengal> Unless it's still tedious, in case you should've picked another career
22:01:42 <pikhq> lament: Most programming you get paid for.
22:01:47 <ray> programming for a living is a lot like copy writing
22:01:50 <dancor> Berengal: that last comment kind of brings us in a logical loop
22:01:57 <pikhq> ray: THIS.
22:02:00 <jmcarthur> in my opinion, the need for automated stuff in programming is the same as the need for abstraction
22:02:03 <dancor> ..with my assertion that most ppl don't code bc it is difficult and tedious
22:02:17 <copumpkin> Berengal: a lot of programming can be quite tedious because you're forbidden from making it less tedious by the higher-ups who can't see that everyone would be more efficient and happier if you took some time to refactor :P
22:02:27 <pikhq> dancor: But it's not tedious!
22:02:35 <Berengal> copumpkin: you need to shut up. I feel a java-rage coming on :P
22:02:43 <dancor> pikhq: maybe
22:02:52 <mike-burns> Even refactoring is tedious.
22:02:52 <jdrake_> Is there any way to do something like this in my module? instance Show [Bool] where show x = map (\b -> if b then '1' else '0') x     I know this code doesn't work as is, but wondering if there is a way to
22:02:53 <copumpkin> lol, I've actually never had a programming job :P
22:02:56 <jmcarthur> Berengal: i have some C++ rage built up :)
22:03:13 <dancor> i think it's pretty tedious still in general but may be a lot less so in the Future
22:03:18 <ray> the "novelists" of programming are rare and seem to be unpaid
22:03:41 <ray> copumpkin: me either, but i've written copy
22:03:46 <lament> a lot of programming seems to do with converting data between different presentation formats (such as communicating with a server or displaying the data in a UI) and that's usually tedious
22:03:50 <FunctorSalad_> this is all pretty sad
22:03:52 <dancor> haskell is interesting bc a lot of things are less tedious but then other things are
22:04:00 <ray> i can't help but shed a tear
22:04:09 <dancor> build problems with cabal-install and parsec 2-vs-3 --> incredibly tedious
22:04:15 <jmcarthur> lament: so true :(
22:04:17 <Berengal> However, yesterday at work: Me: "We need a project management system thingy. I could look into something called gitit. Also, CVS sucks. Darcs is a nice tool." Boss and coworkers: "Nice idea. Look into it"
22:04:21 <FunctorSalad_> lament: yep, and I wonder why there isn't some GUT of converting in light of that
22:04:34 <lament> FunctorSalad_: there is, it's called XSLT :D
22:04:57 * jmcarthur 's head drops
22:05:00 <jdrake_> git ftw
22:05:15 <dancor> ya i'm more of a git fanboi these days
22:05:17 <BMeph> jdrake: fromEnum - "learn it, love it, live it." ;)
22:05:36 <dancor> darcs is an interesting example of haskell being not-tedious and incredibly-tedious
22:06:24 <FunctorSalad_> lament: seriously, is it worty looking into?
22:06:27 <FunctorSalad_> *worth
22:06:31 <lament> XSLT? no
22:06:38 <jmcarthur> don't bother
22:06:47 <jmcarthur> i did, and wish i could get my time back
22:06:52 <inimino> heh
22:06:55 <FunctorSalad_> jmcarthur: :-(
22:07:20 <jdrake_> Is there a way of putting something like -XFlexibleInstances in a source file instead of as a parameter to ghci?
22:07:24 <FunctorSalad_> isn't category theory a theory of structure-preserving converting? :)
22:07:34 <dancor> jdrake_: {-# LANGUAGE FlexibleInstances #-}
22:07:44 <inimino> XSLT is a kind of functional programming, it's just incredibly awkward
22:07:47 <inimino> and, you know, XML
22:08:17 <ray> it's declarative
22:08:31 <lament> ew declarative programming
22:08:31 <ray> it's proof that declarative is not sufficient for goodness :P
22:08:34 <jmcarthur> it's sad that the most mainstream declarative languages are quite horrible
22:08:38 <uman> god I hate XAML
22:08:41 <ray> yeah, they are
22:08:45 <lament> uman: mwahahaha
22:08:50 <uman> anyone else forced to shoehorn XAML into doing something useful?
22:08:58 <lament> i used to
22:09:06 <jdrake_> Well aren't most declarative languages based on xml these days?
22:09:12 <lament> they are
22:09:31 <FunctorSalad_> xml :D
22:09:35 <jmcarthur> Most declarative languages are based on violence.
22:09:42 <uman> lament: I'm just having to learn it because my boss decided the AJAX solution I spent the last two months fixing is not buzzword enough
22:09:42 * dancor thought that functional implied declarative
22:09:47 <uman> or something
22:09:55 <lament> silverlight? enjoy
22:09:57 <jdrake_> jmcarthur: violance against woman, and thus we must stop using XML
22:10:07 <uman> DUDE WHAT IF WE COULD VIEW THIS IMAGE USING DEEP ZOOM
22:10:09 <uman> HOLY SHIT
22:10:26 <lament> mwaha
22:10:30 <jmcarthur> XZOOM is more buzzwordy
22:10:32 <ray> tv show enhance button
22:10:41 <lament> i was on the team that built deep zoom composer
22:10:52 <uman> lament: to tell you the truth Silverlight seems much less shitty to write than AJAX
22:10:53 <lament> there was a lot of swearing
22:11:01 <uman> lament: were you really?
22:11:06 <dancor> what if you built an enhance button that just made stuff up
22:11:12 <jdrake_> Is there any way of making my instance of Show [Bool] take priority over the default? or hiding any previous definitino
22:11:25 <uman> lament: was that at MS?
22:11:48 <lament> uman: yeah, it's actually pretty nice, except when you stumble upon something silverlight doesn't have that you're used to in .NET, which happens every 5 minutes
22:11:54 <lament> uman: no, it was outsourced
22:11:56 <FunctorSalad_> jdrake_: only by newtyping. but do you really need it to be an instance of Show?
22:11:59 <dancor> jdrake_: i think you can use newtype
22:12:14 <jdrake_> FunctorSalad_: no, probably just ttrying to be masocistic right now
22:12:21 <Berengal> jdrake_: Show isn't the only way to convert something to String
22:12:27 <jdrake_> I know
22:12:50 <uman> lament: my main problem isn't with deep zoom, it's with my boss not knowing he wanted to use it in May
22:14:19 <jimmyjazz14> I'm struggling with a design issue in my Haskell program, I basically want to create a function that access some config from the disk and return value based on a key, but it should reload the config file into memory if the config was updated since the last time it accessed it
22:14:53 <jimmyjazz14> I would like to make the interface simple where the state is basically hidden
22:14:57 <FunctorSalad_> so "in" is essentially applying constructors, and "out" is pattern matching? (in the theory of fixed point types)
22:15:10 <copumpkin> InF and outF?
22:15:22 <copumpkin> does lambdabot have a Mu or a Fix/
22:15:25 <lament> uman: well it's the new thing :)
22:15:30 <copumpkin> :t Mu
22:15:31 <lambdabot> Not in scope: data constructor `Mu'
22:15:34 <copumpkin> :k Mu
22:15:35 <lambdabot> (* -> *) -> *
22:15:36 <sm> jimmyjazz14: I think you have to put it in IO, or use unsafePerformIO
22:15:40 <FunctorSalad_> copumpkin: in category-extras?
22:15:41 <copumpkin> @src Mu
22:15:41 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
22:15:47 <lament> uman: at least you missed most of the feature-breaking version updates
22:15:48 <copumpkin> yeah
22:15:53 <uman> lament: how long has Deep Zoom existed?
22:15:59 <FunctorSalad_> copumpkin: same thing I suppose
22:16:03 <copumpkin> yup
22:16:32 <lament> uman: the technology - a few years i think
22:16:33 <jimmyjazz14> sm: any good resources online about that you know of?
22:16:42 <copumpkin> > undefined ::  Mu ((,) Int)
22:16:43 <lament> uman: it's some seattle company MS bought
22:16:44 <lambdabot>   No instance for (GHC.Show.Show (L.Mu ((,) GHC.Types.Int)))
22:16:44 <lambdabot>    arising from ...
22:16:46 <sm> jimmyjazz14: where to start.. what have you read so far ?
22:16:50 <copumpkin> @type undefined :: Mu ((,) Int)
22:16:52 <lambdabot> Mu ((,) Int)
22:16:54 <FunctorSalad_> "f a" consists of all possible constructor applications with recursive positions having values in "a", hence my interpretation
22:17:00 <lament> uman: DZC - a year
22:17:04 <FunctorSalad_> @type In
22:17:06 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
22:17:08 <copumpkin> FunctorSalad_: to me?
22:17:09 <uman> lament: mmm
22:17:11 <FunctorSalad_> @type out
22:17:12 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
22:17:21 <uman> I hate how fast technology changes. I'll never be able to keep up
22:17:24 <jimmyjazz14> sm: I'm kinda new to Haskell still working my way through Real World Haskell
22:17:41 <FunctorSalad_> uman: yes, what when we are older? :(
22:17:42 <sm> ok.. got to the IO chapter yet ?
22:17:51 <jimmyjazz14> sm: yeah
22:17:52 <lament> uman: of course the 'technology' in deep zoom is the same as for example google maps, except less cool
22:18:18 <uman> lament: Well I mean when I was born there was no such thing as Linux
22:18:20 <uman> and I'm not that old
22:18:25 <sm> your function's return type will be IO something. Each time you call it can read the config file again
22:18:26 <uman> it's not deep zoom particularly, more of a general trend
22:18:45 <sm> and you'll only be able to call it from other IO code, like your main function
22:18:45 <ray> if you're not that old, there was such a thing as unix :P
22:18:49 <lament> yeah, but there's nothing particularly novel about most things
22:18:59 <uman> lament: that's what I hate the most
22:19:01 <lament> e.g. there's nothing novel about silverlight, it's just another API to get familiar with
22:19:17 <FunctorSalad_> uman: agreed
22:19:18 <ray> welcome to software
22:19:19 <uman> just a bunch of shit you have to learn if you want to have a hope of having a nice resume
22:19:42 <jimmyjazz14> sm: how do I store the state last accessed state though?
22:19:44 * jdrake_ learned to program with intercal
22:19:46 <ray> never get a job here, unless it's in research
22:19:53 <uman> ray: "here"?
22:19:56 <ray> in software
22:20:01 <jimmyjazz14> sm: so I can determine whether or not to reload the config?
22:20:05 <uman> ray: I already have one
22:20:06 <mike-burns> I like my non-research job.
22:20:06 <FunctorSalad_> this "same stuff with different name" phenomenon kina justifies learning the abstract nonsense ;)
22:20:20 <ray> and it burns, doesn't it? :)
22:20:23 <uman> MS stole the idea for XAML from Mozilla anyway
22:20:34 <ray> abstract nonsense will save us
22:20:43 <uman> "wouldn't it be cool if we made an application framework where XML was used to define the user interface..."
22:21:08 <pikhq> uman: And I strongly suspect Mozilla has the better implementation.
22:21:11 <sm> you probably want to either check the timestamp of the config file, or just reload it every time
22:21:13 <mike-burns> GTK has been doing it for years with Glade, too.
22:21:24 <uman> mike-burns: ah, I didn't know that
22:21:31 <ray> when we can program in pure abstract nonsense, it'll be over
22:21:35 <uman> I mean I'd heard of glade, didn't know it was xml-based
22:22:15 <uman> pikhq: right, call me when a modern browser is written in WPF
22:22:22 <jimmyjazz14> sm: right if I check the time stamp of the file how do I save that stamp in memory so that the next call to my function knows whether or not to reload the file?
22:22:28 <uman> I'll be waiting a while I'm sure
22:22:46 <pikhq> uman: Hahah.
22:23:00 <sm> first, why not read it every time ? simplest thing first
22:23:26 <uman> pikhq: then again, sometimes when Microsoft steals an idea they make it better, so who knows
22:23:32 <jimmyjazz14> sm: well the idea was to reduce reading an parsing a file often
22:23:35 <uman> I much prefer C# and VB.NET to Java
22:23:41 <sm> aha
22:23:49 <pikhq> uman: That's just because Java's terrible.
22:24:02 <ray> i prefer haskell
22:24:06 <pikhq> Microsoft couldn't think of a way to screw it up, so they had to improve it just to be different. :P
22:24:09 <bgs100> night all
22:24:11 <Axman6> i don't have a problem with java
22:24:13 <ray> i guess you're not allowed to if you have a job, or something
22:24:20 <jimmyjazz14> sm: the parsing is expensive
22:24:21 <sm> jimmyjazz14: perhaps you need the State or Reader monad
22:24:26 <Axman6> though some of the libraries suck, and aren't easy to use
22:24:50 <copumpkin> I'm still looking for a language with a good geometry library
22:24:56 <ray> mathematica?
22:25:02 <copumpkin> haven't tried it :)
22:25:04 * ray can't afford mathematica, so it's just a guess
22:25:14 <Axman6> mathematica is terrible
22:25:19 <jimmyjazz14> sm: yeah that was my first thought but I was hoping to be able to hide the state more
22:25:20 <copumpkin> but I want to be able to do constructive area geometry and various other things that CGAL can do
22:25:22 <sm> jimmyjazz14: or when you iterate, recurse, however you are looping, just pass the old value as a parameter
22:25:23 <Axman6> matlab's not much better
22:25:26 <copumpkin> without the damn c++
22:25:29 <uman> pikhq: imo the silliest idea from Java is trying to shoehorn C into what someone at Sun felt was a proper "pure OOP" language
22:25:41 <pikhq> uman: Absolutely.
22:25:43 <ray> using c++ can't be worth it
22:25:49 <copumpkin> CGAL is great
22:25:51 <uman> "if we forbid global methods so someone has to put all their procedural code in dummy classes, it'll be OOPer"
22:25:56 <copumpkin> I want that reimplemented in haskell, honestly
22:25:57 <uman> OOPer dooper
22:25:57 <mike-burns> Java doesn't have too many C-like things.
22:26:07 <pikhq> Of course, if Sun did a proper "pure OOP" language right, it would look a lot like Smalltalk.
22:26:07 <ray> yeah, someone should
22:26:10 <Axman6> sure it does
22:26:18 <ray> maybe i will if i can score enough drugs :P
22:26:23 <jdrake_> pikhq: Why wouldn't they just use smalltalk then?
22:26:27 <jimmyjazz14> sm: yeah I might have to go that direction, I was wondering if haskell had anything like a generator in python
22:26:34 <pikhq> jdrake_: They almost did.
22:26:51 <pikhq> And the world is much worse because they didn't.
22:26:58 <FunctorSalad_> ray: to make the porting more interesting or what? ;)
22:27:00 <mike-burns> Sun's original plan for Java was ST semantics with C-like syntax.
22:27:04 <jdrake_> Isn't the syntax of smalltalk a little bit funky?
22:27:14 <mike-burns> jdrake_: Nah.
22:27:15 <ray> to fuel the coding efforts
22:27:18 <uman> I also think languages that are nothing like C should be forbidden from using C syntax
22:27:27 <lament> jdrake_: not any funkier than Haskell
22:27:27 <dsturnbull> many people find C-like syntax funky. as in, smelly
22:27:27 <dsturnbull> ;p
22:27:39 <uman> I get confused about why my JS code isn't working all the damn time
22:27:41 <Twey> s/that are nothing like C //
22:27:43 <pikhq> jdrake_: It hardly has any.
22:27:45 <uman> because I expect it to do the same thing as C
22:27:52 <jdrake_> granted
22:27:55 <ray> C syntax is just there for marketing to those damn programmers in INDUSTRY with JOBS and that stupid crap
22:27:58 <sm> I usually do it whatever naive way I can think to make it work first, then as I'm reading the code a day or month later a more elegant refactoring becomes obvious
22:28:01 <ray> or rather, their bosses
22:28:03 <mike-burns> uman: That sounds more like a programmer error than a language error.
22:28:14 <uman> mike-burns: well
22:28:38 <Twey> C syntax is horrendously inflexible and very unpleasant to use and parse
22:28:40 <uman> mike-burns: I would consider making programmer error less likely to be a positive aspect of any programming language, wouldn't you? ;)
22:28:45 <jdrake_> C seems to have two real uses to me: low level systems programming (read: kernel and friends) and microcontroller/PLC programming - where sometimes assembly is better.
22:29:07 <Twey> jdrake_: No, C has one real use: interoperation with other code written in C
22:29:17 <ray> C is great
22:29:28 <jdrake_> Did anyone ever try to make a non-ambiguous C?
22:29:32 <ray> you may be confusing it with all these other languages like C++ and Java
22:29:33 <Twey> For just about every other place where C is used, there's a better alternative, be it Haskell, Python, Forth, assembly, or whatever
22:29:47 <pikhq> Twey: Kernel code.
22:29:50 <Twey> Forth
22:29:54 <jdrake_> Twey: haha
22:30:08 <pikhq> ...
22:30:12 <Twey> Seriously
22:30:15 <Aaiin> I am not programming in the language that this channel is meant for but as all the other ones are dead do you all mind if I ask some questions about OOP
22:30:19 <mike-burns> C has a lot of momentum around it and a great culture for building kernels.
22:30:32 <Twey> OpenFirmware uses it, and they get on just fine
22:30:34 <ray> jdrake_: you mean C++?
22:30:40 <Twey> It's more powerful *and* more low-level than C
22:30:45 <jdrake_> Forth has one problem - it doesn't reflect the most effiicent way to program the system - we have fast registers not fast stacks
22:30:57 <pikhq> Twey: That doesn't make for a over-all better language for it.
22:30:59 <jdrake_> With a kernel it must be fast
22:31:04 <mapreduce> Aaiin: You might get surprising answers, as Haskell is not an OO language.
22:31:08 <pikhq> But I will grant that Forth isn't bad for that.
22:31:12 <p_l> well, Forth was created in a register-starved world
22:31:15 <Twey> jdrake_: Sure, but C never uses the registers explicitly, either
22:31:28 <Twey> jdrake_: Implicit optimisation is good
22:31:43 <jdrake_> Twey: it doesn't have to because the symantics lend themselves to register use
22:32:03 <dsturnbull> i'd happily take a 200-300% performance hit for my kernel written safely
22:32:06 <copumpkin> Aaiin: we often know OOP quite well, but don't always enjoy it :)
22:32:07 <Twey> (it's particularly easy with Forth: you can just use registers for the top few cells on the stack)
22:32:18 <dsturnbull> i mean, my laptop cycles down from 2.1GHz to 800MHz already.
22:32:41 <mike-burns> Aaiin: I enjoy OOP and know it fairly well, but you might want to try #ruby or #java or #smalltalk instead.
22:32:55 <pikhq> Aaiin: Or #haskell-blah :P
22:32:59 <jdrake_> There are also many definitions of OOP
22:33:02 <Twey> OOP is a lie
22:33:07 <mike-burns> Oh no.
22:33:12 <uman> yeah wtf is "OOP"
22:33:13 <copumpkin> we can implement OOP in haskell :P
22:33:15 <Aaiin> I am sorry also this is my first time using these boards if i am seeing text in red is that mean they are talking only to me?
22:33:18 <copumpkin> whatever that means
22:33:21 <sm> Aaiin: beware, you have fallen into a nest of brain-exploders
22:33:22 <mapreduce> OOP is "hello".length
22:33:25 <uman> no one has been able to convincingly explain to me what the purpose of it is
22:33:33 <uman> Aaiin: it means someone said your name in what they wrote
22:33:42 <Twey> http://apocalisp.wordpress.com/2008/12/04/no-such-thing/
22:33:45 <mike-burns> Calm down about OOP guys. Let's go back to arguing about what obscure language an OS should be written in.
22:33:46 <uman> at least, if your IRC client is reasonably sane
22:33:48 <pikhq> uman: It means being able to do typeclasses poorly.
22:33:56 <pikhq> mike-burns: Obscure?
22:34:02 <jdrake_> mapreduce: in Ada length("hello")  might be OOP
22:34:03 <pikhq> Well, then. Brainfuck.
22:34:10 <mike-burns> Hah. Should have expected that.
22:34:13 <Aaiin> sorry to you all didnt mean to hijack the conversation i will try some of the other channels suggested thank you
22:34:26 <Twey> mapreduce: In CLOS (length "hello") might be OOP
22:34:32 <pikhq> Just map the Brainfuck array onto system memory, et viola.
22:34:34 <sm> good luck
22:34:34 <ray> oop and oop WHAT IS OOP
22:34:47 <jdrake_> Obscure Oriented Poaching
22:34:52 * Twey laughs.
22:35:01 * sm looks for #simula
22:35:05 <Twey> Aaiin: Read this, it's very enlightening: http://apocalisp.wordpress.com/2008/12/04/no-such-thing/
22:35:07 <mapreduce> My comment was not entirely serious, but it's the only consistent definition of OOP I've seen.
22:36:17 <mike-burns> A language with an OOP mindset mades it easy to add constructors at the expense of adding methods that operate over those data structures. Sometimes.
22:38:04 <Twey> pikhq: Obscure?  You call that obscure?  I recommend NIL.
22:40:14 <pikhq> Twey: Fine, fine.
22:40:18 <pikhq> Dimensifuck.
22:40:29 <pikhq> (Brainfuck with n-dimensional code)
22:41:10 <Twey> Nice
22:43:25 <uman> god damn
22:43:31 <uman> another paradigm I have to learn
22:43:36 <uman> dimensional programming
22:43:39 <uman> is there no hope
22:44:00 <Twey> Hahaha
22:44:01 <inimino> heh
22:44:11 <Twey> I hope that comes after stack-based and concurrency-oriented :-P
22:45:19 <uman> luckily I don't want to be a professional programmer, as a career.
22:45:21 <pikhq> Eh, dimensional's not hard to get.
22:45:27 <uman> Just doing this internship for the summer
22:45:33 <pikhq> Most imperative programming languages are '1 dimensional'.
22:45:35 <jdrake_> While being completely evil and all, is there a way to provide a (*) :: (Num a) => Bool -> a -> a  sort of function?
22:45:39 <pikhq> Code flows up and down.
22:45:44 <pikhq> Now, move sideways.
22:45:50 <mike-burns> Luckily professional programmers tend not to use dimensional programming.
22:45:51 <sjanssen> wut?
22:46:04 <uman> mike-burns: I'm only being about 10% serious
22:46:10 <mike-burns> Ah.
22:46:22 <mike-burns> The Internet is hard.
22:46:29 <uman> I know :(
22:46:33 <BMeph> pikhq: ZigZag BF? ;)
22:46:40 <pikhq> BMeph: In a way.
22:46:45 <uman> mike-burns: I really don't want a programming career though. I want to become a professor
22:47:29 <mike-burns> uman: There are two types in the computer world; those who understand why you feel that way, and those who can't at all.
22:47:33 <mike-burns> (I'm the second type.)
22:48:04 <jdrake_> mike-burns: I thought there were 10 types
22:48:15 <uman> mike-burns: I think I'd like being a programmer
22:48:25 <uman> I just think I'd like being a professor more
22:49:05 <uman> maybe writing and debugging AJAX all day when 2 months ago I knew zero javascript is part of the problem
22:49:16 <mike-burns> I suspect it is.
22:49:33 <mike-burns> There are some awesome real jobs out there, if you look hard enough.
22:49:37 <uman> but I've wanted to have an academic career for several years
22:49:43 <inimino> ugh, please don't use that term
22:49:52 <uman> inimino: academic career?
22:49:59 <inimino> uman: "AJAX"
22:50:09 <uman> inimino: why not?
22:50:25 <mike-burns> Is the problem the first 'A', or the 'X'?
22:50:29 <mapreduce> > let x * y = y in True * 5 -- for jdrake_
22:50:30 <copumpkin> it's usually the AJAJ
22:50:32 <lambdabot>   5
22:50:46 <BMeph> pikhq: Dang it, now you've got me thinking...I HATE it when that happens! ;)
22:50:58 <uman> inimino: it's Javascript communicating asynchronously with the server using XML
22:51:05 <uman> inimino: "AJAX" seems to be a pretty fitting term
22:51:09 <jdrake_> mapreduce: how does that work/
22:51:39 <mapreduce> > let x = 5 in x + x -- the same as this
22:51:41 <lambdabot>   10
22:51:52 <inimino> uman: I would just call that "JavaScript"
22:51:57 <mapreduce> The first defined (*), the second defined x.
22:52:04 <Axman6> > let (*) = flip const in True * 5
22:52:04 <jdrake_> Thank you
22:52:06 <mike-burns> inimino: It's a pattern.
22:52:06 <lambdabot>   5
22:52:26 <uman> inimino: JavaScript is the tool used to write a certain sort of program
22:52:38 <uman> inimino: it'd be like if you didn't like the term "systems programming" and insisted people call it "C"
22:52:43 <inimino> uman: many people use "AJAX" to mean a variety of other things
22:52:46 <uman> (or FORTH)
22:53:16 <inimino> uman: "systems programming" has a defined meaning
22:53:22 <uman> inimino: so does AJAX
22:53:47 <inimino> uman: but if you're actually using JavaScript and XML and doing it asynchronously, and if precisely that is what you meant then I take it all back :-)
22:54:17 <uman> inimino: AJAX is when JavaScript uses libraries that communicate with a server asynchronously using XML in order to remove the need for a full-page reload in order to update information on the client side
22:54:25 <uman> that's the only definition I'm aware of
22:54:38 <uman> but I share your distate for the incorrect use of terminology :)
22:54:43 <inimino> (and you're rare amongst users of the term if that's the case)
22:55:04 <copumpkin> most people I know use JSON instead of xml
22:55:06 <mike-burns> uman: inimino does have a point in that JSON is typically easier to work with than XML, in JS.
22:55:39 <uman> mike-burns: perhaps, I don't knwo
22:55:56 <BMeph> What about yaml? :)
22:56:01 <uman> I suppose it'd be better if it were called "asynchronously-communicating web scripting" or similar
22:56:14 <mike-burns> ACWS?
22:56:15 <copumpkin> BMeph: the question is how easily you can get the format into your native objects
22:56:16 <uman> since the pattern doesn't logically have to rely on XML or even JavaScript
22:56:34 <copumpkin> BMeph: since JSON is already in your native syntax, it's sufficient (if not always wise) to just eval it :P
22:56:44 <inimino> uman: or just "JavaScript", or "Web applications development"
22:56:52 <uman> mhm
22:56:56 <uman> either way I hate all of it
22:57:00 <mike-burns> Ha.
22:57:04 <uman> I still don't see the need to move applications to the browser
22:57:17 <BMeph> inimino: Shoot your WAD on the web? I think that's already got a name... ;p
22:57:25 <copumpkin> lol
22:57:33 <jdrake_> BMeph: I shoot my IWAD everytime I play doom
22:57:34 <uman> X11 has been able to display applications remotely for several years ;)
22:57:34 <dsturnbull> uman: really? everyone has a browser
22:57:37 <mike-burns> uman: I gotta tell you: I've been a Web developer for 8 years, and for all 8 I've maintained that the browser is a terrible place for applications.
22:57:43 <inimino> why are you doing it then?
22:57:54 <mike-burns> Because I enjoy it.
22:58:28 <uman> dsturnbull: there are ways of making cross-platform applications that do not involve the web browser
22:59:00 <dsturnbull> sure
22:59:07 <inimino> uman: if you're not interested in it, why aren't you working on something else?
22:59:43 <inimino> there are plenty of other worthy projects, surely
22:59:55 <uman> I'll get you my boss's e-mail address and you can tell him about them
23:00:32 <dsturnbull> to be honest, i like html+css+js a lot more than any other frontend stack
23:00:46 <uman> inimino: and I do enjoy it... it's challenging and interesting
23:01:05 <mike-burns> dsturnbull: Huh, that's my least favorite part! The browser incompatibilities are what drive the nail into the coffin.
23:01:25 <uman> inimino: but it's also error-prone and frustrating
23:01:28 <jdrake_> Praise be upon Haskell, Thank you for all the help. At the end of the test there will be cake. Don't miss your party.
23:01:38 <uman> even though I have it much much easier than most people, since I only have to support IE7 and IE8
23:01:41 <copumpkin> THE CAKE IS A LIE
23:01:42 <uman> that's STILL annoying as hell
23:01:44 <inimino> uman: it gets better :-)
23:01:48 <copumpkin> or something like that :)
23:02:01 <dsturnbull> the key is graceful degradation, uman
23:02:14 <inimino> uman: you mean you're not supporting any standards-oriented browsers?
23:02:21 <uman> inimino: correct
23:02:27 <lament> disgraceful degradation - the story of my life
23:02:36 <dsturnbull> i can have a really good ui for the majority of ff/safari/ie8, and the others can have a shittier version
23:02:44 <jdrake_> copumpkin: THANK YOU you have made my day just before sleep. Good night.
23:02:59 <uman> inimino: although IE8 and IE7 make a much better show of standards compliance than IE <=6
23:03:06 <uman> still not nearly there
23:03:14 <inimino> uman: yes but yes
23:03:20 <uman> I don't understand why MS doesn't fix some super easy bugs
23:03:29 <mike-burns> Or switch to webkit.
23:03:33 <copumpkin> :)
23:03:40 <uman> like, it'd probably take one programmer one day to fix IE to pass the damn event argument to the event handler functions
23:03:44 <inimino> compatibility with shitty intranet apps, primarily
23:03:48 <mike-burns> (But, in honesty, I do understand why they don't fix the bugs and why they don't switch.)
23:04:03 <jdrake_> uman: you might assume something is easy without knowing the implementation.
23:04:04 <inimino> uman: that would probably reduce IE's dwindling market share even more
23:04:36 <jdrake_> In some ways it might not matter in a few years.
23:04:47 <uman> jdrake_: very true, but I bet they had to rewrite a shitton of IE from scratch when moving to 7
23:04:54 <uman> why couldn't they have fixed that while they were at it
23:05:12 <inimino> uman: see above.  It's a business decision
23:05:21 <uman> makes sense
23:05:33 <uman> either way, I don't envy the programmers who have to stare at the code that makes up IE all day
23:05:40 <mike-burns> uman: Most companies still run IE6 because the apps they run on it are dependant on the bugs. By being bug-compatible MS is trying to get IE8 into thoes places.
23:05:54 <uman> mike-burns: well isn't that what IE8 compatibility mode is for?
23:06:04 <mike-burns> It's hard to say.
23:06:08 <uman> Why not fix the bugs in IE8 As IE8 and leave them in IE8 As IE7
23:06:36 <uman> heh, my dad's company still keeps NN3 or 4 around
23:06:43 <uman> for timesheetws
23:06:46 <inimino> !
23:06:54 <uman> believe it
23:06:58 <inimino> that's tragic
23:07:14 <uman> lol I can't imagine the timesheet app code
23:07:48 <inimino> think "DHTML" and "layers"
23:07:54 <uman> maybe it relies on the <marquee> element to function properly
23:08:02 <uman> or was <marquee> in IE
23:08:03 <uman> can't remembe
23:08:20 <lament> heh
23:08:36 <lament> the worst application ever that i've used was a timesheet app
23:08:42 <lament> not web-based
23:08:44 <inimino> IE introduced <blink>, as I recall
23:08:44 <uman> my timesheet app is excel
23:08:46 <inimino> <marquee> is still supported :-)
23:09:15 <uman> god damn, I remember the days of "this site is only supported in netscape
23:09:16 <uman> "
23:09:30 <lament> at my last company, the timesheet was web-based so i wrote a script to automatically fill it
23:09:39 <uman> pissed me off when I had the choice of downloading a different browser over worse-than-56k and not seeing a website
23:09:44 <mike-burns> This is why "everyone has a browser" is a weak argument for building Web apps.
23:10:15 <impl> everyone has a JVM too!
23:10:28 <uman> everyone has Windows
23:10:30 <mike-burns> Everyone has a Win32 library!
23:10:59 <uman> actually, someone could just code to the subset of Win32 supported by WINE
23:11:05 <inimino> mike-burns: wait, why is it a weak argument?
23:11:08 <uman> and it'd be pretty portable on modern desktops
23:11:44 <inimino> uman: that's how Google "ported" Picasa or whatever it's called
23:11:52 <uman> inimino: neat
23:12:01 <mike-burns> inimino: Because not everyone has the same browser, so you have to pick n browsers to support and make sure that the CSS/JS works in them. Often times this involves special-casing the code.
23:12:01 <inimino> it was rather a terrible idea
23:12:06 <uman> inimino: why?
23:12:43 <inimino> uman: why is shipping an OS emulator as part of a user-level application a bad thing?
23:12:44 <mike-burns> inimino: At that point it's also easy to build three desktop apps.
23:12:53 <uman> inimino: it's not an OS emulator
23:12:57 <uman> it's a set of libraries
23:13:09 <inimino> uman: semantics
23:13:16 <uman> inimino: er, why?
23:13:29 <uman> the Windows installers for a lot of apps ship with GTK
23:13:31 <uman> how is this different
23:13:43 <inimino> uman: it's an emulation of what most people would call Win32
23:13:45 <mike-burns> That's also a terrible idea.
23:14:43 <inimino> it's not a very good idea, but I'm not a Windows user so I don't have a stake in it ;-)
23:15:56 <inimino> (and Windows application packaging and distribution sucks already, so it's not much worse if you bundle GTK)
23:16:34 <uman> very true
23:16:46 <uman> Windows has only been getting better and better
23:16:56 <uman> who knows, maybe someday it'll catch up with *nix
23:16:59 <uman> but I really doubt it ;)
23:21:57 <uman> http://www.goer.org/htmlhorror/htmlhorror1.html
23:22:43 <mauke> http://frnz.de/
23:31:26 <uman> mauke: you win
23:42:51 <Axman6> G'day ChilliX_
23:44:24 <copumpkin> zomg it's ChilliX
23:54:27 <cads> hey, are there any channels where conversation may happen on subjects ranging from process calculi to formal hardware verification to computability theory?
23:54:38 <ivanm> cads: #gentoo-in-depth ? :p
23:54:53 <cads> I know sometimes you guys hash it up on CAT theory :)
23:54:58 <ivanm> *sigh* I'm sure there was something else I wanted to add to graphviz before I made the release, but I can't remember what :s
23:55:48 <cads> ivanm, I was like "should I ask in the #java channel or should I ask in the #haskell channel" :P
23:55:54 <ivanm> cads: heh
23:56:07 <vav> ivanm: did you mean #haskell-in-depth?
23:56:08 <ivanm> #java: process calculi?  what's that?  integration and stuff?
23:56:08 <ivanm> :p
23:56:12 <jeffwheeler> Y'know, for all the newbie questions #java gets . . . I was impressed at how friendly they were.
23:56:18 <copumpkin> ivanm: mmm generic graphs
23:56:18 <ivanm> vav: ummm.... yes :s
23:56:22 <copumpkin> ;)
23:56:24 <ivanm> copumpkin: yeah, it's coming
23:56:30 * copumpkin salivates
23:56:39 <ivanm> Cale and I need to finish that off first though ;-)
23:56:40 <jeffwheeler> The people I talked to in #java a while back even were happy to here about the cool ideas in Haskell.
23:56:44 <copumpkin> I needz me some graphz
23:57:15 <ivanm> wait, I know what I was going to do: fix the documentation :s
23:57:24 <Axman6> jeffwheeler: i've never found them that friendly
23:57:38 <jeffwheeler> Axman6: hmm, I guess I just got lucky
23:57:57 <jeffwheeler> s/here/hear/g, from above
23:58:16 <ivanm> Axman6: same
23:58:25 <ivanm> I wanted to know if there was a library that did such-and-such
23:58:49 <ivanm> when they kept asking why I wanted to do such a thing, I eventually came out and said that the lecturers had specified it do that
23:59:00 <ivanm> then they said it was a homework topic and refused to speak to me
23:59:06 <ivanm> #java--
23:59:09 <ivanm> @karma #java
23:59:10 <lambdabot> #java has a karma of -1
