00:11:22 * edwardk waves hello,
00:11:43 <edwardk> http://comonad.com/haskell/community.jpg
00:12:58 <edwardk> took that during a presentation last week that was given about Haskell on the iPhone, when Ryan was talking about why he was doing game dev in Haskell and the topic of available labor came up.
00:13:12 <Twey> edwardk: Hahahahahaha
00:13:44 <ivanm> heh
00:14:35 <p_l> edwardk: hahahahaha
00:14:53 <Twey> The humour is only intensified by the extremely slow speeds of the server.  :-P
00:14:58 <edwardk> hahaha
00:15:01 <edwardk> sorry about that
00:15:07 <edwardk> i should really trim the image down
00:15:51 <ivanm> edwardk: so use haskell because there's a large supply of haskellites willing to work for low wages as long as they can actually get some work?
00:15:52 <ivanm> :p
00:15:58 <edwardk> Yeah.
00:16:05 <edwardk> and they know their stuff
00:17:06 <ivanm> supposedly ;-)
00:18:18 <edwardk> I don't know any Haskellers that learned the language and use the language just to work 9-5, before going home to think non-programming thoughts. Compare to, say, Java.
00:18:38 <copumpkin> lol
00:18:46 <copumpkin> that's cause this stuff is a drug
00:18:52 <copumpkin> it should be outlawed
00:19:02 <ray> i hit one out of three on that list
00:19:03 <edwardk> its programmer porn
00:20:17 <edwardk> posted to reddit: http://www.reddit.com/r/haskell/comments/93exh/why_haskell/
00:20:17 <Adamant> edwardk: they should really add a "but employable!" line below the first three
00:20:55 <ray> will work for food
00:21:17 <p_l> ray: or "will work for internet access"? :P
00:21:40 <edwardk> Adamant: The presentation was to the Boston Haskell User Group. Appreciation for the community was implicit. ;)
00:21:42 <ray> bums can get that already
00:21:53 <Adamant> edwardk: ah :P
00:22:14 <Adamant> edwardk: I thought it might be to some other sort of professional group
00:22:24 <ivanm> p_l: nah, you need installation privileges and HDD space as well
00:22:32 <ivanm> (so you can install/upgrade GHC, etc.)
00:22:43 <edwardk> @tell dons The license weirdness from the GHC/iPhone patch has been addressed. The patches are 100% BSD now.
00:22:43 <lambdabot> Consider it noted.
00:23:21 <p_l> ivanm: you can make something out of scrap :P
00:23:29 <ivanm> heh
00:23:54 <ray> copumpkin: programmer LSD, right down to the flashbacks
00:24:49 <Trinithis> lol
00:24:58 <Trinithis> and intense dreams when new to it
00:26:44 <ivanm> p_l: surely we could at least argue our way into  getting a computer as part of the contract... >_>
00:26:50 <ivanm> not just internet access...
00:29:28 <copumpkin> haven't seen much of ryant5000 recently
00:29:56 <edwardk> Anyone here planning to be at Hac Phi?
00:30:13 * edwardk just finalized his travel arrangements, etc.
00:31:35 <Trinithis> Is it just me, or is this BS: http://importantshock.wordpress.com/2009/01/18/jquery-is-a-monad/
00:32:55 <copumpkin> edwardk: I'd like to go but I'm not sure I'll be able to afford it, will see soon (I'll have to decide soon :P)
00:32:58 <ivanm> edwardk: I thought hac phi was over already... >_>
00:33:08 <ivanm> (but I definitely won't be there either which way)
00:33:55 <edwardk> ivanm: 24th-26th
00:34:50 <copumpkin> edwardk: oh wait, of july? or august?
00:34:52 <copumpkin> crap
00:34:54 <copumpkin> this weekend?
00:34:59 <edwardk> yeah
00:35:01 <copumpkin> boo
00:35:18 <edwardk> mid august is the next BHUG
00:35:23 <copumpkin> ah ok
00:35:26 <copumpkin> I'll go there instead
00:35:51 <ray> i strongly considered going
00:35:56 <copumpkin> would've liked to go to hac phi too
00:35:58 <copumpkin> but no money right now
00:36:31 <ray> i could afford it, technically, but it would bankrupt me
00:37:51 <edwardk> ray: where'd you be heading there from?
00:37:55 <ray> connecticut
00:38:51 <ray> boston is a bit closer to me
00:39:20 <cjs> Still cheaper than heading over from Tokyo.
00:39:29 <copumpkin> ray: you should go to the next boston meetup!
00:39:33 <edwardk> Then you should at least come up to the next boston haskell user group thing. I'll take you out for a beer afterwards or something.
00:39:35 <copumpkin> so should I!
00:39:54 <copumpkin> even I can afford 60 bucks for the bus ride :P
00:40:03 <copumpkin> (if only barely)
00:40:03 <cjs> As far as that "JQuery is a monad" thing, well, I don't think I recall that "The first monadic law is that a monad is a wrapper around another type. "
00:40:07 <edwardk> yes, you should. i'm beginning to think you aren't really on this side of the country after all ;)
00:40:18 <copumpkin> lol
00:40:27 <copumpkin> well, I am in the middle of nowhere
00:40:37 <copumpkin> they could move it around the world and I'd never notice
00:40:43 <copumpkin> it's just trees and hills as far as I can see :P
00:41:34 <edwardk> heh
00:41:58 <copumpkin> but I may just be human vaporware
00:42:04 <copumpkin> *vegetable
00:42:50 <ray> human vaporware fits
00:43:45 <copumpkin> that jquery is a monad guy really doesn't understand the monad definition very well
00:43:50 <edwardk> yeah
00:44:06 <copumpkin> but he is right that jquery behaves like one (I'm not sure it actually is one)
00:44:38 <copumpkin> 3) They have an operation called bind that allows to feed the value wrapped inside the monad into another function, as long as the function returns a monad.
00:45:11 <cjs> I'm pretty sure it isn't one. He seems to have the feel of how we use monads for handling state and control flow, to some degree, but I don't think that those combinators are actually using bind and return and the like internally.
00:45:21 <copumpkin> yeah
00:45:27 <copumpkin> I mean, he says "returns a monad"
00:45:49 <copumpkin> clearly his terminology is all wrong, but apart from that he's lost the actual laws
00:46:11 <cjs> So someone should write a blog entry about how he's missing the whole point (if he is), demonstrating this with how one writes a "real" monadic combinator that doesn't have to know about the state or control flow, versus what the internals of a JQuery function look like.
00:46:24 <edwardk> but the thing is it returns a wrapped value, but the wrapping can differ based on the kind of thing you asked for, so i don't buy it
00:46:26 * copumpkin touches his nose
00:46:32 <copumpkin> (I don't have a blog)
00:46:35 * copumpkin stares at edwardk
00:46:51 * edwardk is stared at.
00:46:55 <copumpkin> lol
00:47:04 <ray> i don't have a blog engine!
00:47:06 <copumpkin> Trinithis: where did this come from?
00:47:26 <copumpkin> but maybe this will get people less scared of monads
00:47:36 <copumpkin> it's annoying how much stigma is attached to them
00:47:55 <wmealing_> its because its close to gonads.
00:47:59 <copumpkin> this may be wrong and imprecise but if he can convince people they're not crazy voodoo maybe it's worthit
00:48:07 <wmealing_> should have called them butterflies.
00:48:08 <Trinithis> i googled: javascript monad
00:48:21 <wmealing_> sadly, i'm not kidding
00:48:35 <wmealing_> word association is a dangerous thing.
00:48:36 <cjs> Well, what was the other suggestion, Warm Things that are Fuzzy, or something like that? Hmmm. "WTF." Yeah, that fits, too. :-)
00:49:40 <wmealing_> heh
00:49:48 <ceal> i am reading a line from the user; can i use the input as a list?
00:49:57 <ceal> name <- getline
00:50:03 <ceal> can name be used as a list?
00:50:24 <edwardk> ceal: sure, a string is just a list of chars
00:50:52 <mahogny> :t getLine   useful stuff in ghci
00:50:57 <lambdabot> parse error on input `in'
00:51:01 <ray> monads are so boring, though
00:51:13 <edwardk> clearly comonads are more fun
00:51:16 <ray> how did they get to be a fairy tale monster
00:51:16 <ceal> but i cant do name !! 2; it gives me a compile error
00:51:22 <ray> they clearly are
00:51:35 <edwardk> just because by drawing some arrows the other way you can get completely and utterly blank stares from people
00:51:45 <mahogny> ceal, maybe rather because you are in a monad?
00:51:46 <edwardk> @type (!!)
00:51:48 <lambdabot> forall a. [a] -> Int -> a
00:51:53 <Trinithis> lol
00:51:56 <copumpkin> edwardk: can you petition to add some of the more commonly useful things in category-extras to the prelude in haskell'10?
00:52:32 <ray> how about you add an improved prelude to category-extras
00:52:39 <copumpkin> mmm
00:52:39 <edwardk> > do name <- return "Hello"; let test = name !! 2; return test
00:52:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:52:49 <copumpkin> well he was reimplementing algebra in his monoids lib until he stopped
00:53:11 <edwardk> oh the let binding got greedy on me
00:53:34 <ceal> mahogny:??
00:53:35 <edwardk> well, i didn't entirely stop just got a little distracted
00:54:14 * copumpkin coughs origami
00:54:32 <edwardk> > do name <- return "Hello"; let { test = name !! 2 }; return test :: [Char]
00:54:34 <lambdabot>   "l"
00:54:35 <mahogny> ceal, easier if you paste all the code
00:55:06 <cjs> So I'm setting up some combinators to deal with what are essentially low-level database queries, filtering, doing projections and joins, and so on. I'm thinking a monad might be good, since for a project, it could just tweak some internal state, and for filtering, it can abort the computation. However, the combinators need to be in I/O because they may have to do things such as read and write temporary files. What's a good way to
00:55:06 <cjs>  put all this together?
00:55:14 <edwardk> the outermost [] there is just to have a monad I could be working in, because I can't do IO on lambdabot.
00:55:19 <Phillemann> I'm writing an IRC library in Haskell and I'm not sure how to implement it. I currently have a function createIRC which returns an immutable IRC object. I'm thinking about adding the ability to add handlers to a specific IRC command. But that requires mutable state.
00:55:20 <edwardk> > do name <- return "Hello"; let { test = name !! 2 }; return test :: Maybe Char
00:55:22 <lambdabot>   Just 'l'
00:55:23 <edwardk> works just as well
00:55:53 <copumpkin> Phillemann: the add* functions would just return a new IRC object that had the specified handler set
00:56:03 <copumpkin> you'd chain them up until you had the handlers you want, and then you'd run that
00:56:18 <ceal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3072#a3072
00:56:20 <edwardk> cjs: build a monad for your "DB" monad out of various bits and pieces of the MTL wrapped around IO
00:56:33 <copumpkin> onoes, not IO!
00:56:49 <copumpkin> do not let it pollute thy monad
00:57:09 <cjs> edwardk: That was what I was reckoning. Any good reading on MTL you can recommend, beyond the Jones paper (which I have open in front of me as we speak)?
00:57:10 <Phillemann> copumpkin: Hmmm, and you mean this handler container would be passed on to createIRC?
00:57:38 <cjs> copumpkin: IO is wonderful! Not does it let you have state and anything else you want, but it reduces memory usage! :-)
00:57:38 <copumpkin> Phillemann: it could be that way, or however
00:57:56 <copumpkin> Phillemann: but what would createIRC do? you don't typically need much logic in constructors
00:57:56 <edwardk> cjs: i learned it mostly by reading the source and by reading a monad tutorial by one of the guys who is now over at bluespec.. hrmm lemme see if i can find it
00:58:09 <edwardk> oh yeah
00:58:12 <edwardk> Newbern
00:58:13 <edwardk> http://www.haskell.org/all_about_monads/html/index.html
00:58:23 <Phillemann> copumpkin: I create threads to watch over the IRC connection in the background.
00:58:36 <copumpkin> you sure that's a good name?
00:58:40 <edwardk> that tutorial clicked really well for me
00:58:54 <ray> all about bunnies
00:59:31 <Phillemann> copumpkin: I also though about returning a modified irc object and working with that but wouldn't that essentially be what a monad would do?
00:59:50 <edwardk> createIRC can only be executed once, and only if your name is Jarkko Oikarinen, and only if it is 1988.
01:00:01 <copumpkin> lol
01:00:03 <cjs> Ah, I've read (though perhaps not fully digested) AAM. But good, I can go back to the transformers bit of that, which I remember being good, and reading the source is always a smart thing. Thanks.
01:00:50 <edwardk> clearly there is a linear type involved in its signature somewhere
01:00:55 <cjs> I have to admit, I'm still not quite up to speed on that Continuation monad thing.....
01:01:04 <copumpkin> sounds deep
01:01:09 <vav> ceal: putStrLn $ name !! 2 -- i.e. putStrLn (name !! 2), otherwise parses as `(putStrLn name) !! 2' which doesn't make sense
01:01:15 <copumpkin> cjs: what about it?
01:01:31 <cjs> I didn't find the example to be a model of clarity.
01:01:58 <edwardk> cjs: actually its pretty straight forward. replace the value a with a function that takes any function from (a -> r) and possibly calls it to give you an r.
01:02:12 <edwardk> so you can return into it (just call the function)
01:02:24 <edwardk> or you can just ignore the function and give back an r that you have lying around.
01:03:40 <cjs> Oh.
01:03:42 <cjs> Bing!
01:04:39 <edwardk> the rest of its uses are just variations on that theme but in the end you can either use the function or not, or maybe you can use it multiple times, etc.
01:18:14 <soupdragon> who do you calculate you are?
01:18:45 <Rembane> PI
01:20:33 <Twey> @index pi
01:20:34 <lambdabot> Prelude
01:20:45 <Twey> I would have thought it would have been in Numeric.
01:21:07 <Rembane> It was there before Numeric...
01:21:15 <Twey> Ah
01:27:43 <sioraiocht> LOL srsly?
01:28:30 <Rembane> YA RLY!
01:28:33 <cjs> There's a fair amount of stuff in the Prelude that is not really what we want any more, but is standard.
01:29:20 <sioraiocht> cjs: I wish the list stuff wasn't in it, anymore
01:29:25 <cjs> Some stuff much more wanting fixing than that, too. Such as 'fail' in the Monad class.
01:29:35 <cjs> Yeah, list should really be a typeclass, I've been thinking lately.
01:29:54 <cjs> Or really, we need some collection type stuff for things like lookup.
01:30:12 <Cale> Lists *are* really important though.
01:30:34 <cjs> Basically, we need a massive rewrite of a ton of stuff that would break compatibility left and right.
01:30:53 <sioraiocht> Cale: I know, those functions names are just not only applicable to lists
01:30:53 * soupdragon does't want ANY prelude
01:30:53 <soupdragon> I don't put  import BunchOfIrrelevantCrap   at the start of my file for a reason
01:31:01 <soupdragon> list should really be a typeclass -- nooo
01:31:03 <sioraiocht> maybe it's my fault because I mess around with data structures a lot
01:31:13 <sioraiocht> but I feel ike they monopolise the default namespace =
01:31:16 <ivanm> sioraiocht: what's wrong with the prelude?
01:31:22 <ivanm> or do you just want a slimmed-down one?
01:31:22 <cjs> soupdragon: Why not?
01:31:26 <CalJohn> Lists have the shorthand "[]".  How can I add my own shorthand for one of my own structures.  (Yes, I know it is probably stupid, this is a toy app)
01:31:41 <sioraiocht> ivanm: I just don't like the number of list fnctions in it,
01:32:12 <soupdragon> the internal of the data structure is important
01:32:12 <soupdragon>  <cjs> Basically, we need a massive rewrite of a ton of stuff that would break compatibility left and right.
01:32:12 <soupdragon> yeah -- I'm calling it Haskell' :)
01:32:30 <soupdragon> CalJohn: that's not a shorthand
01:33:03 <Cale> CalJohn: [] is the name of one of the data constructors for the list type.
01:33:43 <Cale> soupdragon: Except that's not what Haskell' intends to be.
01:34:05 <sioraiocht> Cale: [a] for a:[] is the only shorthand
01:34:14 <sioraiocht> err, CalJohn ^^
01:34:31 <sioraiocht> but you can't use your own mixfix notation in haskell
01:34:48 <cjs> soupdragon: I was actually inquiring as to your objection to such a rewrite, though perhaps I misunderstood and you don't have one. But no, that's not what Haskell' will be, I think. I'm not sure something like that could ever happen.
01:35:05 <sioraiocht> Cale: why are you always in #linguistics but never talk =p
01:35:06 <soupdragon> Haskell' is my project
01:35:24 <soupdragon> (and anyone else that gets interested)
01:35:26 <cjs> Though I've been contemplating an automatic translation tool to translate existing code into "new standard library world."
01:36:20 <Cale> sioraiocht: Nobody ever seems to talk about linguistics very much
01:36:39 <CalJohn> sioraiocht: ok, i will have to write a toy parser then for my silly thing :)
01:37:07 <sioraiocht> Cale: join ##linguistics?
01:37:21 <sioraiocht> there's no off-topic chatter there
01:38:05 <Twey> soupdragon: The stuff in the Prelude is useful stuff
01:38:12 <soupdragon> not to me
01:38:15 <Twey> Well, most of it, anyway
01:38:30 <Twey> You're an unusual case :)
01:39:16 <sioraiocht> I awlays underappreciate the Prelude until I am using so many functions that need hiding that I only import it qualified
01:39:27 <sioraiocht> and then realise it breaks half my code
01:39:30 <soupdragon> I don't want  [a] -> a
01:39:48 <Cale> [a] -> Maybe a ?
01:40:20 <cjs> Dependent types!
01:40:31 <Cale> Lists are important because they are effectively our loops.
01:40:44 <sioraiocht> what's maybe the initial algebra of? 1 + A
01:40:46 <sioraiocht> ?
01:41:23 <Cale> Maybe a is 1 + a
01:42:01 <iago> djs, for what
01:42:01 <Cale> I suppose you could describe it as the initial algebra of F X = 1 + A
01:42:54 <Cale> (it's not recursive, so you don't really make use of the initial algebra bit :)
01:43:11 <sioraiocht> ahh
01:43:19 <sioraiocht> okay
01:43:45 * sioraiocht is still pretty dumb about Category Theory, much to his supervisor's dismay.
01:44:37 <cjs> iago: re, soupdragon's not wanting [a] -> a and Cale's suggestion.
01:45:10 <Cale> But really, I wouldn't change the type of head
01:45:20 <sioraiocht> nah, me neither
01:45:20 <soupdragon> I don't actually care about the content of Prelude
01:45:55 <sioraiocht> it's the minimal definition, and has expected behaviour, if you want to add safety logic it desn't take long
01:45:57 <soupdragon> it's just an annoying library I never use -- annoying because it's imported automatically and takes up a lot of good names
01:47:52 <thaldyron> anyone here ever used hinotify?
01:48:34 <CalJohn> thaldyron: yes
01:49:18 <iago> oh
01:49:20 <ivanm> thaldyron: the library?
01:49:25 <iago> the type of head
01:49:25 <iago> :P
01:49:28 <thaldyron> ivanm: yes
01:49:45 <CalJohn> thaldyron: is that all you wanted to know?
01:49:52 <ivanm> well, I've "used" it in the sense that I installed an app that needed it... >_>
01:50:21 <soupdragon> it's short sighted to go: it's better for everyone to start with Prelude
01:53:06 <thaldyron> CalJohn: the problem is that the events that I get, don't contain the filepath of the file I'm watching
01:53:50 <thaldyron> CalJohn: for example:  Modified {isDirectory = False, maybeFilePath = Nothing}
01:54:16 <thaldyron> CalJohn: so I just know that *some* file was modified but not which one...
01:56:55 <CalJohn> thaldyron: i'm guessing you're watching a series of individual files?
01:57:23 <thaldyron> CalJohn: yes
01:57:37 <CalJohn> thaldyron: I vaguely recall running into that issue.  I think i eventually found that you _do_ get the filepath if you are watching the containing directory for Modified
01:58:35 <thaldyron> CalJohn: Ah! Thanks, I'll give that a try.
02:01:38 <CalJohn> Argh, parsec is so hard to understand :(
02:02:35 <iago> CalJohn: there is a tutorial that explains it well
02:03:19 <CalJohn> iago: I know, but i don't seem to understand it
02:04:31 <iago> CalJohn: perhaps you have to understand monads first
02:06:16 <ivanm> I thought the current vogue was to use Applicative for parsec, not monads... >_>
02:07:29 <iago> well, I'm out of date in that case ;P
02:08:05 <iago> CalJohn: perhaps you have to understand applicative functors first
02:11:28 <daz_> where is the best place to get some help with haskell i just started it and I am a struggling to write some functions
02:11:48 <kfish> daz_, right here!
02:12:11 <daz_> do you have any texts? I am having trouble with some really basic stuff
02:12:34 <thaldyron> daz_: http://book.realworldhaskell.org/read
02:13:45 <cjs> CalJohn: You might find it easier and better in the long run just to write your own monadic or applicative parser.
02:14:15 <cjs> Once you've done that, parsec makes more sense. I still don't find it particularly easy to use, though.
02:14:20 <Rembane> daz_: http://learnyouahaskell.com/
02:15:58 <CalJohn> i don't really know what happened, but is just decided to stfu and start work.  it's only a parser for SKI.  i seem to be able to do this.
02:16:06 <CalJohn> s/is/I
02:22:00 <daz_> the error messages i  get when loadingfiles dont really make much sense to me. Obviously i have made a mistake in my syntax somewhere but I cant figure out why.
02:24:19 <iago> compilers don't provide good syntax-error messages
02:24:59 <daz_> yea i usually use a C Compiler, but this is quite new.
02:26:14 <Axman6> daz_: once you get used to them, ghc's errors are pretty helpful
02:26:53 <pao> hi all! is there a way to programmatically get the path of the source file runghc is "interpreting"?
02:26:54 <daz_> i actually only have hugs installed at the mo. U think i should get ghc?
02:27:42 <Axman6> well, ghc will compile your code, and you'll be able to do a lot more (and a lot faster)
02:40:28 <solrize> @hoogle comparison
02:40:29 <lambdabot> No results found
02:40:36 <solrize> @whereis comparison
02:40:36 <mlesniak> I've found an old post at haskell-cafe which mentioned unsafe array read and write operations (unsafeAt, unsafe...) but I can not find them in hoogle. Any hints where they are defined?
02:40:37 <lambdabot> Maybe you meant: where where+
02:41:01 <mlesniak> @hoogle unsafeAt
02:41:02 <lambdabot> Data.Array.Base unsafeAt :: (IArray a e, Ix i) => a i e -> Int -> e
02:41:06 <mlesniak> Gnaaaargh
02:41:25 <mlesniak> Anyone knows why the webinterface does not find this?
02:46:54 <voker57> use hayoo
02:47:02 <voker57> web hoogle has limited base
02:47:21 <mlesniak> voker57: Thanks for the info
02:47:22 <solrize> @seen dolio
02:47:22 <lambdabot> dolio is in #ghc, #haskell-in-depth, #haskell-blah and #haskell. I don't know when dolio last spoke.
02:58:34 <harlekin> @pl (id &&& id)
02:58:34 <lambdabot> id &&& id
02:59:43 <soupdragon> :t (&&&) `ap` flip const ()
02:59:48 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
03:00:11 <harlekin> :t fmap $ id &&& id
03:00:12 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
03:00:25 <harlekin> :t fmap $ id &&& id $ return 'c'
03:00:26 <lambdabot>     Couldn't match expected type `a -> b'
03:00:27 <lambdabot>            against inferred type `(m Char, m Char)'
03:00:27 <lambdabot>     In the second argument of `($)', namely `id &&& id $ return 'c''
03:00:50 <harlekin> :t fmap $ liftM (id &&& id) $ return 'c'
03:00:52 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (Char, Char)
03:01:06 <harlekin> Why's it f a and not f Char? Oo
03:01:21 <harlekin> Ups. Nevermind.
03:02:03 <harlekin> @pl liftM (id &&& id)
03:02:04 <lambdabot> fmap (id &&& id)
03:09:50 <dibblego> id &&& id = join (,)
03:11:09 <harlekin> dibblego, cool. Thanks.
03:12:13 * EvilTerran would call id &&& id clearer
03:12:25 <EvilTerran> (barely)
03:12:49 <EvilTerran> seeing as that join's on the ever-obfuscating (e ->) Monad
03:13:05 <ivanm> yeah, I can never remember what join in cases like this
03:13:14 <ivanm> it just removes a monadic layer, right?
03:13:16 <ivanm> @type join
03:13:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:13:29 <dibblego> (t -> t -> a) -> t -> a
03:14:56 <ray> id &&& id WHAT IS ID
03:14:58 <EvilTerran> > join f x :: Expr
03:15:01 <lambdabot>   f x x
03:15:30 <ivanm> ray: I hope that isn't a serious question...
03:16:00 <ray> have you ever seen a little star trek episode called spock's brain?
03:16:08 <ivanm> no, don't think so
03:16:20 <ray> :(
03:18:04 * quicksilver would call (\x -> (x,x)) clearer :)
03:19:06 <ray> that's so pointy
03:20:54 * osfameron would call:  let dup x = (x,x) clearer again ;-)
03:21:12 <osfameron> (at that point, let dup = join (,) would be fine too of course
03:24:03 <zmyrgel> Any suggestions how can I install yi on windows? When I try to install it with the suggested '-f-vte -fpango' I get error that I need gtk and glib.
03:24:18 <zmyrgel> How should I install those so that I can install yi?
03:24:26 <zmyrgel> I have installed the latest haskell-platform
03:24:32 <ivanm> zmyrgel: you need gtk2hs
03:24:45 <ivanm> which requires a seperate installer (not sure if it comes with HP)
03:24:56 <daz_> glib is a gnome library, not sure how to get it on windows.
03:25:03 <zmyrgel> I know :)
03:25:16 <zmyrgel> ivanm: I'll try to see if I can get that installed
03:25:46 <ivanm> daz_: is it? :o
03:26:17 <ivanm> daz_: it's part of gtk AFAICT, being a C library
03:26:30 <ivanm> GTK /= Gnome
03:26:40 <daz_> my bad
03:26:41 <ivanm> (and I wish more Gnome developers would remember that...)
03:28:22 <daz_> i have never used perl, let alone use perls library when writing C.
03:28:37 <quicksilver> osfameron: I see no virtue in 'dup' over (\x -> (x,x)) except saving a few characters.
03:28:48 <quicksilver> osfameron: (\x -> (x,x)) is about as clear and precise as it gets.
03:28:58 <quicksilver> 'dup' could probably mean one of a few alternative things.
03:29:12 <osfameron> could be
03:29:29 <Twey> Or join (,)
03:30:04 <quicksilver> join (,) is equally precise, of course, but IMO less clear.
03:30:33 <soupdragon> dup ?
03:30:43 <soupdragon> call it duplicate
03:33:16 <quicksilver> In particular, dup might mean (\(x:xs) -> (x:x:xs))
03:34:10 <Deewiant> Or even join (++)!
04:12:37 <Gertm> Does one need to excel in mathematics in order to be successful with Haskell?
04:12:53 <Twey> No
04:13:25 <Gertm> Nice and clear answer! Thanks!
04:13:25 <ivanm> but a knowledge of maths can help
04:13:34 <ivanm> especially with some of the abstract concepts
04:13:42 <Twey> I can't do maths to save my life, but I'm okay with Haskell :)
04:13:47 <ivanm> (by "help", I mean in understanding how or why something works; not in how to use it)
04:14:12 <Twey> Yeah, there are various categories of maths that can help with advanced topics and weird experimental stuff
04:14:19 <Gertm> ivanm: advanced such as?
04:14:26 <Twey> But if you just want to do bog-standard programming, you'll be fine without it
04:14:29 <ivanm> Twey: you have 10 seconds to answer this question before a cruise missile is launched at your house: What is 6*7?
04:14:30 <ivanm> :p
04:14:36 <Twey> 24!
04:14:39 <Twey> :-P
04:14:52 <ivanm> Gertm: I didn't say advanced... ;-)
04:14:59 <ivanm> Twey: it was nice knowing you...
04:15:15 <Gertm> ivanm: sorry it was Twey who mentionned that.
04:15:27 <ivanm> heh
04:15:43 <ivanm> Gertm: OK, what he probably meant was the theoretical underpinnings of things like Functors, etc.
04:15:52 <ivanm> but you can use them with no problem ;-)
04:16:05 * ivanm doesn't really get/know most of the category theory stuff either
04:19:50 <soupdragon> 'mathematics' is too broad
04:20:36 <soupdragon> knowing how to find the theoretically perfect volume of potato wedges wont help you write haskell though
04:21:04 <ray> well
04:21:08 <soupdragon> not being able to concentrate and think logically will stop you from programming
04:21:10 <ray> if you're writing a potato wedge volume calculator
04:21:33 <ivanm> exactly!
04:21:35 <burp> hm, I wonder if volume matters much
04:21:43 <burp> density..
04:22:25 <mbuf> what am I missing here? http://haskell.pastebin.com/d2288d5a1 trying to receive a message from a client, and send it back in the plainHandler function; newbie here;
04:22:27 <ray> density comonad?
04:22:47 <quicksilver> mmm potato wedges
04:22:57 <quicksilver> mbuf: indentation.
04:23:08 <solrize> does 6.10.3 include a cabal client?
04:23:09 <quicksilver> mbuf: the "let" in line 14, and every line after it
04:23:14 <mbuf> quicksilver: i see;
04:23:22 <quicksilver> mbuf: needs to line up with "addrinfos" in line 13
04:23:37 <quicksilver> solrize: no.
04:23:43 <solrize> tx
04:23:44 <Phillemann> Does anybody use forkIO non-threaded (meaning without ghc -threaded)? It seems a little unstable to me. I've got a simple program which spawns three threads (one waiting for a handle, the other one for user input and the third one for the other two) and it just...well, behaves erratically.
04:23:47 <quicksilver> solrize: future GHC releases will contain less, not more.
04:23:55 <quicksilver> solrize: the haskell platform will contain cabal-install, though
04:24:00 <mbuf> quicksilver: thanks!
04:24:02 <quicksilver> solrize: that (kind of thing) is the point of the platform.
04:24:17 <solrize> right, that's what i was asking, whether cabal-install would be included
04:24:24 <quicksilver> Phillemann: works fine for me.
04:24:29 <solrize> does the platform implement signed code?
04:24:32 <quicksilver> no.
04:24:37 <solrize> hmm
04:24:55 <quicksilver> Phillemann: "behaves" erratically isn't very precise.
04:25:03 <quicksilver> Phillemann: are you being caught out by a buffering issue, perhaps?
04:25:11 <quicksilver> (or lazy IO, how we hate it)
04:25:37 <Phillemann> quicksilver: Hmmmm, that could really be the case. It seems like the main thread doesn't "catch up" with the thread which waits for the external input.
04:26:25 <mbuf> quicksilver: also it is HostName;
04:26:45 <Phillemann> quicksilver: Is there any guideline what to look out for?
04:27:11 <quicksilver> Phillemann: don't use hGetContents or getContents
04:27:18 <quicksilver> (to avoid getting confused by lazy IO)
04:27:28 <quicksilver> learn what buffering is (to avoid getting caught out by buffering)
04:27:41 <Phillemann> What about hGetLine?
04:27:47 <quicksilver> that's fine.
04:28:26 <Phillemann> Hmmm. I'm waitingi on a socket (which is set to NoBuffering) with hWaitForInput and then hGetLine a line of input.
04:29:45 <quicksilver> hWaitForInput sounds like a mistake.
04:29:52 <quicksilver> just use hGetLine and block
04:29:56 <quicksilver> that's why you have threads, right?
04:30:49 <Phillemann> quicksilver: True, but don't want to wait indefinitely.
04:30:54 <Phillemann> +I
04:31:13 <Phillemann> Guess I could solve that with yet another thread...
04:31:24 <quicksilver> Yes.
04:31:28 <Snark> hi
04:31:31 <quicksilver> always have one thread which just waits in input
04:31:42 <quicksilver> each socket has two threads dedicated entirely to IO
04:31:45 <quicksilver> a reader and a writer
04:32:05 <quicksilver> I wouldn't be surprised to hear that hWaitForInput blocks the entire app
04:32:10 <quicksilver> not just the current thread.
04:32:38 <quicksilver> in fact, that behaviour is even documented.
04:32:45 <Phillemann> Oh
04:32:45 <Snark> how do I find the "integer part" of a Double ?
04:32:55 <quicksilver> "NOTE for GHC users: unless you use the -threaded flag, hWaitForInput t where t >= 0 will block all other Haskell threads for the duration of the call. It behaves like a safe foreign call in this respect."
04:33:05 <quicksilver> > floor 1.5
04:33:07 <Phillemann> Ohhhhh! Damn...didn't see that.
04:33:11 <lambdabot>   mueval-core: Prelude.read: no parse
04:33:11 <lambdabot>  mueval: ExitFailure 1
04:33:14 <quicksilver> !
04:33:19 <Vanadium> > truncate 1.5
04:33:21 <lambdabot>   1
04:33:22 <quicksilver> > floor 1.5
04:33:23 <Phillemann> quicksilver: Okay, thanks then :)
04:33:23 <lambdabot>   1
04:33:32 <quicksilver> > floor (-1.5)
04:33:34 <lambdabot>   -2
04:33:42 <Vanadium> > truncate (-1.5)
04:33:44 <quicksilver> Snark: the different between floor and truncate only relates to negative numbers.
04:33:44 <lambdabot>   -1
04:34:20 <ivanm> @src truncate
04:34:20 <lambdabot> Source not found. That's something I cannot allow to happen.
04:34:24 <Snark> quicksilver, floor should do the trick perfectly... thanks!
04:49:17 <Snark> sigh... Gtk2Hs gives sizes as "Int"... :-/
04:49:20 <WorkyBob> is it possible to specify more than one library in the same cabal file?
04:49:45 <ivanm> WorkyBob: umm... don't think so
04:49:50 <dcoutts> WorkyBob: no, in future we might have 'private' libs. but never more than one public one.
04:49:59 <WorkyBob> ah, bugger :(
04:50:04 <dcoutts> otherwise there's no way to identify the other public ones
04:50:15 <dcoutts> it must match the name of the package
04:50:22 <WorkyBob> :(
04:50:26 <WorkyBob> bugger
04:50:33 <dcoutts> what is the problem?
04:50:50 <kowey> what would it take to add proxy detection to the HTTP library? could it just be a matter of grafting code from http://darcs.haskell.org/cabal-install/Distribution/Client/HttpUtils.hs onto it?
04:50:56 <WorkyBob> I need to distribute both an interpretter as a library, and the runtime library for the things it interprets, preferably with one easy cabal install
04:51:08 <dcoutts> kowey: that's a reasonable place to start
04:51:27 <dcoutts> kowey: note that proxy detection on windows is a PITA. It requires a javascript interpreter.
04:51:47 <kowey> eww
04:51:53 <ivanm> *shudder*
04:51:55 <dcoutts> blame netscape
04:52:01 <dcoutts> WorkyBob: you can make them separate packages
04:52:07 <ivanm> dcoutts: how do you do it in *nix then?
04:52:26 <dcoutts> ivanm: consult the appropriate env var
04:52:44 <WorkyBob> dcoutts: is it possible to make one install when the other one does?
04:52:54 <ivanm> dcoutts: *nod* figured it'd be something like that...
04:52:56 <dcoutts> WorkyBob: by having one depend on the other, yes.
04:53:01 <ivanm> dcoutts: so why is windows netscape's fault?
04:53:05 <WorkyBob> I got the impression that cabal only looks for its libraries on hackage, not for other cabal files hanging about dcoutts -- is that misguided?
04:53:23 <ivanm> WorkyBob: AFAIK, that's the only way to do it automatically
04:53:29 <WorkyBob> :(
04:53:32 <kowey> dcoutts: so is the code in cabal-install for Windows (seems to grab the equivalent of http_proxy off the registry) just a good-enough approximation, then?
04:53:40 <ivanm> though you can of course download a tarball, unpack it and run "cabal install" in that directory if there's a valid .cabal file there
04:53:45 <kowey> or am I just not reading it closely enough?
04:53:51 <dcoutts> kowey: it's a best effort, it doesn't work in some network setups
04:54:09 <dcoutts> WorkyBob: the point is, separate packages are distributed separately
04:54:26 <WorkyBob> dcoutts: yeh, these two I want distributed together -- and not via hackage
04:54:28 <dcoutts> WorkyBob: if you want them distributed together then make it one lib
04:54:48 <WorkyBob> and they're very much seperate libs -- one will get distributed with the finished product, the other one won't
04:55:04 <dcoutts> so they are distributed separately then
04:55:15 <WorkyBob> yep, but not to our developers
04:55:41 <WorkyBob> if the other developers have to do more than run one command they're gonna bitch about how shit haskell is and how they have to learn to type more than one line of code
04:56:00 <Adamant> edwardk: thanks for the monad tutorial link at PST ~1am-ish
04:56:23 <dcoutts> WorkyBob: I'd be happy to accept a patch to cabal so you can run: cabal install foo-1.0.tar.gz bar-1.0.tar.gz
04:56:37 <dcoutts> WorkyBob: then you get one line of code :-)
04:56:38 <WorkyBob> k
04:56:55 <ivanm> dcoutts: does cabal-install accept tarballs like that?
04:57:05 <dcoutts> ivanm: not yet
04:57:19 <WorkyBob> I'd rather make a patch that searched for cabal files for the dependant package in the current directory, before searching on hackage -- would that also be acceptable dcoutts?
04:57:48 <dcoutts> WorkyBob: you mean allowing multiple .cabal files in a single directory? that's a bigger task
04:58:11 <WorkyBob> it's disallowed atm, I thought it just added a restriction that you had to tell cabal install which to use?
04:58:41 <dcoutts> WorkyBob: the build system currently cannot cope with that, it's a bigger internal restructuring
04:58:46 <WorkyBob> ah :(
04:59:06 <dcoutts> it's also possible to make private hackage collections
04:59:18 <WorkyBob> oh?
04:59:19 <dcoutts> local or remote
04:59:25 <WorkyBob> how does one do that?
05:00:01 <dcoutts> one constructs the thing in the right format and uses --some-flag-I-can't-quite-recall to tell cabal where the repo is (http or local path)
05:00:15 <WorkyBob> hmm, cool
05:00:19 <WorkyBob> that may be the solution
05:00:56 <WorkyBob> is it possible to use more than one hackage at the same time -- i.e. ask it to search our local one first, and then the real one?
05:01:02 <dcoutts> WorkyBob: yes
05:01:11 <WorkyBob> sweet, cheers muchly dcoutts
05:01:27 <dcoutts> WorkyBob: there might be some rough edges, that feature doesn't get used much
05:01:43 * WorkyBob nods
05:02:53 <dcoutts> btw, if your company wants to improve cabal for this kind of task then I'm sure we can find someone who'd be happy to work on it
05:03:42 <dcoutts> and of course if you work on it yourself then we gladly accept patches
05:04:01 <dcoutts> WorkyBob: http://hackage.haskell.org/trac/hackage/ticket/524
05:05:26 <thaldyron> dcoutts: any news on the cabal world-file stuff?
05:06:47 <ivanm> thaldyron: not until you submit a patch
05:06:48 <ivanm> :p
05:07:08 <thaldyron> ivanm: already did a few days ago ;-)
05:07:19 <ivanm> oh.... well, that shuts me up :p
05:07:40 <dcoutts> thaldyron: sorry, not yet, it's on my review list.
05:08:00 <thaldyron> dcoutts: no problem
05:16:46 <mightybyte> Anyone ever seen a situation where ghc will compile something just fine, but if you add "-prof -auto -osuf prof.o" it gives a compile error?
05:17:56 <maxote> hi guys, how can be modified Haskell to use the tracing technology? (it's for x5-x20 speed)
05:18:09 <WorkyBob> maxote: see hat
05:18:30 <WorkyBob> http://haskell.org/hat/
05:19:10 <maxote> i heard that Javascript uses JIT to register the traces, GHC doesn't use JIT
05:19:20 <Botje> I think maxote is talking about tracing JIT
05:19:28 <Botje> maxote: ghc doesn't do JIT, it already compiles to bytecode
05:19:35 <Botje> eh
05:19:36 <Botje> machine code
05:21:13 <Philippa> Botje: JIT can potentially inline things GHC can't, though
05:22:28 <Daimonic> hey guys, I have made a function makeTuple, which takes two lists [a] and [b] and makes a tuple list [(a,b)] this was easy for me, now I am trying to make out of a tuple list [(a,b)] a tuple with lists: ([a],[b]) however I dont get there, has anyone a hint? I tried something like ((a:deTupel xs),(b:deTupel xs))
05:22:39 <Daimonic> but this doesnt work of course, because of the type conflict
05:22:43 <Botje> yeah, of course :)
05:23:28 <Botje> Daimonic: you have to pass along the tuple and alter it along the way
05:24:09 <Botje> one of type ([a],[b]) -> [(a,b)] -> ([a],[b])
05:24:41 <koala_man> Daimonic: you can map fst and snd to get lists of the first and second elements
05:25:20 <Botje> koala_man: where's the fun in that :P
05:25:46 <Daimonic> yeah I know about map, however we didnt had it yet in course :)
05:26:04 <Daimonic> no reason not to use it, I just want to try it the other way, let's see ... :)
05:32:03 <lilac> Daimonic: have you been taught about 'let' or 'where' yet?
05:32:40 <gwern> http://blog.stackoverflow.com/2009/07/stack-overflow-flash-mobs/ <-- this is a nice idea, but I can't think of any haskell questions which are common enough to really merit this treatment
05:33:23 <gwern> all happy haskellers are alike in their happiness; but all erroneous beginners have their own peculiar errors
05:34:21 <lilac> gwern: what is a Functor/Applicative/Monoid/Monad/... are all good questions i think
05:35:21 <gwern> lilac: everyone needs a different answer to those, and there's already an absurd abundance of material
05:37:04 <soupdragon>  
05:49:50 <Phillemann> Is there a shorthand for: a <- f; g a;?
05:50:21 <Phillemann> I mean, there is f >>= g; but can I use that in a do block?
05:50:43 <dino-> Phillemann: Yes, you can use that >>= binding. Also: liftM g f
05:50:59 <Phillemann> Ah, great.
05:51:02 <dino-> Wait
05:51:24 <dino-> Well, no, g a here must be a -> m b
05:51:28 <Twey> fmap f g
05:51:42 <dino-> There you go, less chars.
05:51:52 <Phillemann> Hehe
05:51:57 <Twey> :)
05:52:01 <dino-> ITYM fmap g f
05:52:08 <Twey> That's if f is non-monadic
05:52:14 <Twey> Did I?
05:52:17 <Twey> Oh, yeah, I did
05:52:18 <lilac> gwern: well, all the good/common questions will by their nature have a lot of material already, i think?
05:53:02 <lilac> you can't use fmap (==liftM) here since g returns a value in the monad
05:53:08 <dino-> Phillemann: But yes, you can also do bind operator notation in do blocks.
05:53:53 <lilac> use f >>= g, or g =<< f, or join (fmap g f), or ...
05:53:54 <soupdragon> :t (<=<)
05:53:57 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
05:54:02 <Phillemann> dino-: So f >>= g; and then go on with the normal notation.
05:54:20 <Phillemann> Good that you can mix the two styles.
05:54:39 <dino-> Yeah, sorry about that. I think I may be wrong about that liftM
05:55:52 <dino-> definitely wrong if g :: a -> m b
05:55:59 <Philonous1> Phillemann: g =<< f is just a normal expression. There is no reason you shouldn't be able to use it. I think's it's even preferable
05:55:59 <ManateeLazyCat> Hi all, i will develop stynax-highlight module for various source code (such as Haskell, C, Lisp), so i want suggestion that how to handle syntax-highlight. Thanks!
05:56:06 <dino-> <- giving bad advice
05:56:39 <lilac> ManateeLazyCat: if you can, consider a monoidal parser, so you don't need to start your parse at the start of the file
05:56:41 <dino-> Philonous1: I agree with that, I like reverse bind a lot.
05:56:58 * lilac likes =<< and <=< a lot too
05:57:07 <daed> what does =<< mean?
05:57:13 <Twey> Yeah, the liftM and fmap both are only if the function to apply is pure
05:57:13 <LeoD> flip >>=
05:57:16 <dino-> daed: flip (>>=)
05:57:17 <lilac> (=<<) = flip (>>=)
05:57:19 <ManateeLazyCat> lilac: Talk about `alex` ?
05:57:22 <daed> ah
05:57:27 <Cale> =<< goes well with do-notation
05:57:30 <Twey> :t (<=<)
05:57:32 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
05:57:37 <Twey> :t (=<<)
05:57:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
05:57:47 <Cale> do r <- foo =<< bar; ...
05:58:00 <Philonous1> (=<<) is or arabs and mathematicians who prefer to read from right to left :>
05:58:12 <Philonous1> for*
05:58:14 <Twey> Weird, that
05:58:16 <ManateeLazyCat> lilac: monoidal parser? More details?
05:58:28 <Twey> I've never actually seen <=< used
05:58:39 <Twey> Philonous1: I'm neither, but I prefer to read from right to left :-P
05:58:40 <Cale> <=< is really nice for defining the monad laws
05:58:44 <lilac> ManateeLazyCat: the idea is that you build some notion of a set of possible parse fragments for some fragment of the input text
05:59:03 <lilac> ManateeLazyCat: with the key operation being concatenating two adjacent parse fragments into a larger one (ruling out options as you do so)
05:59:07 <Cale> return <=< f = f,  f <=< return = f, (f <=< g) <=< h = f <=< (g <=< h)
05:59:32 <lilac> @quote lilac Kleisli
05:59:32 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
05:59:33 <lambdabot> read
06:00:13 <Cale> Seen this way, the monad laws are exactly what is needed to make <=< into the composition for a category where return is the identity.
06:00:40 <lilac> Cale: what do you think of (somewhat inaccurately) stating the functor laws as: fmap is a monoidal operator with id as the identity
06:00:56 <Cale> monoidal?
06:01:06 <lilac> associative
06:01:10 <Cale> hmm
06:01:17 <lilac> it's a bit ugly since it's not closed
06:01:18 <ManateeLazyCat> lilac: Now have two method to stynax-highlight , one is regular expression (like Emacs do), another is lexical analysis. Can you talk about lexical analysis? Thanks!
06:01:24 <Cale> It's only really associative when it's (.)
06:01:40 <lilac> it's only associative when the left-hand fmap is (.)
06:01:45 <Cale> right
06:01:53 <lilac> or when it's associated the other way
06:02:00 <Cale> fmap (f . g) x = fmap f (fmap g x)
06:02:11 <Cale> (f . g) . x = f . (g . x)
06:02:26 <ManateeLazyCat> lilac: And regular expression can't handle all situations....
06:02:27 <lilac> in the first line, three of the four fmaps are not necessarily (.)
06:02:45 <ray> `fmap` then, if you want to be a stick in the mud
06:03:30 <lilac> ManateeLazyCat: do you want a 'static' syntax highlighter (ie, give it a file and it gives you a highlighted file) or a 'dynamic' one (as you'd have in a text editor)?
06:03:46 <ManateeLazyCat> lilac: Dynamic.
06:04:06 <ManateeLazyCat> lilac: I'm developing editor sub module.
06:05:01 <lilac> Cale: x `fmap` (y `fmap` z) == (x `fmap` y) `fmap` z iff either side type checks
06:06:33 <Cale> That's true, and it's one of the reasons I advocate (.) = fmap, but I would normally just say that fmap preserves composition.
06:07:00 <lilac> i found it quite interesting that it forms an almost-monoid
06:08:56 <Cale> Well, that's what a category is ;)
06:09:13 <Cale> A category is a monoid where you're not always allowed to compose.
06:10:51 * lilac tries to figure out which category this would be
06:12:38 <Cale> mm... I suppose it's kind of a strange one
06:12:47 <lilac> it's like Hask but with elements in functors represented by arrows, which only compose on the right
06:13:40 <lilac> so Functor f => f a is represented as an arrow a ~> R f
06:13:48 <lilac> where R is some representation of the functor
06:14:45 <lilac> i suppose we may as well represent "f a" as an arrow a ~> X, where X is an object with no arrows out from it
06:15:01 <Cale> yeah
06:15:03 * lilac wonders if that's backwards
06:15:32 <lilac> i think the arrows should be X ~> a, actually.
06:15:37 <Cale> Er, yeah
06:16:09 <Cale> We could just have each functor f be an object, and values of f a be arrows f -> a
06:16:10 <lilac> i suppose that's in some sense representative of it being covariant
06:16:48 <Cale> mhm
06:16:53 <lilac> it's not completely faithful, since we'd need to extend 'id' to operate on these new objects
06:17:08 <Cale> yep
06:18:26 <lilac> this seems quite similar to embedding constants as arrows () -> a
06:18:29 <Cale> But f has no 'values'
06:18:45 <Cale> because there are no arrows coming into f
06:19:16 <lilac> ok, so that's a pretty degenerate case of 'id' then :)
06:19:27 <Cale> (except for the trivial identity arrow)
06:27:14 <CalJohn> how should I import parsec so as to stop it stealing the name "parse"?
06:27:24 <CalJohn> is two import statements a good idea?
06:28:55 <ivanm> CalJohn: either hiding (parse), or qualified
06:30:09 <CalJohn> ivanm: am I allowed to do both?
06:30:38 <ivanm> CalJohn: you mean "import qualified Foo as Bar hiding (blah)" ?
06:30:38 <CalJohn> ivanm: yes, apparently
06:30:48 <ivanm> you really shouldn't hide if you're importing qualified
06:30:52 <ivanm> (as there really isn't much point)
06:31:40 <CalJohn> ivanm: i found a nice way around it :)
06:31:52 <Saizan> importing twice is a common idiom
06:31:54 <ivanm> around what?
06:32:09 <ivanm> Saizan: yeah, especially for the data types
06:32:12 <Saizan> e.g. import qualified Data.Map as M; import Data.Map (Map)
06:34:52 <mbuf> newbie here; in this http://haskell.pastebin.com/d213e2536, the hPutStrLn prints it like 'msg' \r ' OK';
06:35:00 <mbuf> how can I get exact string concatenation here?
06:36:01 <mauke> ++ is string concatenation
06:36:23 <mauke> therefore msg already contains \r
06:36:23 <Axman6> s/string/list
06:36:57 <mbuf> mauke: in the output, I get like: " OKm 127.0.0.1:46585: msg"
06:37:08 <mbuf> mauke: i see;
06:38:50 <chturne> I'm getting type errors that I can't fix :( Haskell output & definition here -> http://codepad.org/nffTaCtk <- Thanks.
06:39:28 <Daimonic> @src group
06:39:28 <lambdabot> group = groupBy (==)
06:39:36 <Daimonic> @src groupBy
06:39:37 <lambdabot> groupBy _  []       =  []
06:39:37 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
06:39:37 <lambdabot>     where (ys,zs) = span (eq x) xs
06:40:06 <mauke> chturne: printPicture doesn't return a string
06:40:26 <mauke> (head pic ++ "\n" ++ ...) requires a string
06:40:31 <Cale> chturne: okay, the simplest type error to see in that is that in one case you're returning a list, [], and in the other, you're returning an action, putStr (...)
06:40:31 <Badger> @src span
06:40:32 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:40:53 <chturne> Oh
06:41:17 <Cale> chturne: You have to decide what you want printPicture to really be. Does it produce a list, or does it put something on the screen?
06:41:44 <chturne> Cale, it produces something on screen. My type signature is right, but I can't get the definition there :(
06:41:48 <mbuf> so how can I remove the '\r' in a msg string?
06:41:49 <Cale> okay
06:42:04 <Cale> chturne: So, printPicture [] = return ()
06:42:27 <Cale> (you shouldn't use == to test if a list is empty, usually)
06:42:46 <mauke> mbuf: well, there's the brute force approach: filter ('\r' /=) msg
06:42:50 <Cale> printPicture (x:xs) = do ...
06:43:08 <mbuf> mauke: ok
06:43:12 <chturne> Grr
06:43:25 <mauke> less do, more (>>)
06:43:47 <mauke> (also, putStr . unlines)
06:44:20 <Cale> Well, yes, this really just amounts to using unlines and then putStrLn
06:44:32 <mauke> why putStrLn?
06:44:32 <mbuf> ok
06:45:00 <Cale> ah, unlines does terminate the last line with \n after all
06:45:32 <Cale> But if you want to do it recursively, it would look like
06:45:51 <Cale> printPicture (x:xs) = do putStrLn x; printPicture xs
06:46:17 <Cale> Or as mauke suggested, we could use >> instead of do-notation.
06:46:22 <Cale> printPicture (x:xs) = putStrLn x >> printPicture xs
06:46:24 <mauke> printPicture (x : xs) = putStr (x ++ "\n") >> printPicture xs  -- closer to original
06:46:27 <chturne> I've seen neither notation before
06:46:48 <Cale> chturne: do-notation is used to glue actions together into larger actions
06:46:50 <mauke> http://mauke.ath.cx/stuff/haskell/how-to-io.html
06:47:16 <chturne> Hm
06:47:43 <chturne> printPicture  pic = [ putStr (x ++ "\n") | x <- pic ]
06:47:43 <Daimonic> @src groupBy
06:47:44 <lambdabot> groupBy _  []       =  []
06:47:44 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
06:47:44 <lambdabot>     where (ys,zs) = span (eq x) xs
06:47:53 <Cale> mauke: "IO implies evaluation order." seems odd...
06:48:14 <Cale> chturne: aha, you now have a list of actions
06:48:33 <Cale> chturne: to turn it into a single action, you could apply sequence or sequence_
06:48:34 <quicksilver> Cale: rest of the paragraph makes it clear, though
06:48:46 <quicksilver> Cale: ""...Therefore IO effects shouldn't be caused by expression evaluation"
06:48:54 <Daimonic> @src span
06:48:55 <lambdabot> Source not found. My mind is going. I can feel it.
06:49:38 <Cale> quicksilver: even so...
06:49:39 <Axman6> chturne: putStr (x ++ "\n") == putStrLn x
06:50:12 <Cale> chturne: sequence :: [IO a] -> IO [a]
06:50:23 <Cale> chturne: (well, it's really more polymorphic than that)
06:50:32 <chturne> I found it on Hoogle :)
06:50:55 <chturne> But.. I think I am very confused about types still
06:51:04 <Cale> chturne: Given a list of IO actions though, it'll turn them into a single action which will produce a list of all the results of those actions when executed.
06:51:23 <chturne> Mm
06:51:40 <Cale> The execution of IO actions is never (leaving low-level hackery aside) triggered by evaluation.
06:52:28 <Cale> In a compiled program, you eventually define an action called main, and the Haskell RTS evaluates it into an action and executes that action.
06:52:58 <Cale> At the ghci commandline, you can give ghci an IO action, and it will carry it out
06:53:09 <Cale> Lambdabot won't though:
06:53:15 <Cale> > print [1,2,3]
06:53:21 <lambdabot>   mueval-core: Prelude.read: no parse
06:53:21 <lambdabot>  mueval: ExitFailure 1
06:53:23 <Cale> er...
06:53:29 <chturne> I see
06:53:32 <Cale> hey, what the
06:53:45 <Cale> That's not an appropriate error. It must have timed out.
06:53:57 <mauke> > print ()
06:54:02 <lambdabot>   <IO ()>
06:54:41 <Cale> @flush
06:54:45 <Cale> @quit
06:54:50 <Axman6> :o
06:55:08 <Cale> oops, something still went wrong, one sec
06:55:32 <chturne> You get non-exhaustive patterns with those solutions
06:56:12 <Cale> chturne: They're all meant to have the same base case
06:56:21 <Cale> chturne: all the recursive ones, that is
06:56:39 <Cale> printPicture [] = return ()
06:56:49 <chturne> Ok
06:56:54 <chturne> Sorry for misunderstanding
06:56:59 <Cale> return v  gives the action which does nothing, and returns v
06:57:04 <therp> hi folks
06:57:05 <chturne> I think I get this now :)
06:57:09 <Cale> This is all that the return function does
06:57:23 <Baughn> (In IO)
06:57:28 <Cale> It doesn't have magical control effects like in most imperative languages.
06:58:13 <ray> return is a bad name
06:58:20 <Cale> I think it's a fine name.
06:58:22 <chturne> abra_return
06:58:26 <ray> it sounds too magical
06:58:26 <FunctorSalad> η
06:58:30 <chturne> :P
06:58:34 <Baughn> No, return is a bad name. pure's a better one
06:58:39 <osfameron> why 'pure' ?
06:58:41 <Cale> return v  does exactly what it says that it does
06:58:43 <mauke> 'yield'
06:58:58 <therp> is there something for github for darcs?
06:59:01 <Baughn> osfameron: Because that's the method name in Applicative. :3
06:59:09 <therp> s/for/like/
06:59:11 <osfameron> but it's no more pure than, um, anything else
06:59:15 <FunctorSalad> maybe "embed"
06:59:26 <p_l> ń
06:59:30 <p_l> damn, wrong key
06:59:31 <Baughn> osfameron: Well, it gives you an applicative functor consisting solely of the value you pass to pure
06:59:36 <FunctorSalad> or "inject"
06:59:39 <Baughn> ..purely of that value, you might say
06:59:55 <Cale> return is a bad name for it in imperative languages, is all ;)
07:00:01 <therp> I should have asked that on #darcs..
07:00:06 <FunctorSalad> or "insert"
07:00:14 <ray> unit
07:00:24 <ray> return does exactly what it says in C!
07:00:28 <Cale> It should be called  call-current-continuation  in C ;)
07:00:38 <Baughn> Cale: Pragmatically, return is a bad name because of associations from other languages
07:00:55 <FunctorSalad> "monadify"? ;p
07:01:10 <Baughn> FunctorSalad: ..applicativify. ;_;
07:01:15 <LeoD> awesomify
07:01:16 <osfameron> Cale: not at all - it returns a value from the subroutine (in imperative languages).
07:01:23 <Baughn> return does most certainly not belong in the Monad class
07:01:26 <ray> it's even worse when you consider how it looks in an IO do block
07:01:45 <Cale> Or something like that :P  Imperative languages behave as if every procedure definition has been wrapped in callCC, and return calls that continuation with the given value.
07:01:55 <ray> it returns control to its caller
07:02:02 <FunctorSalad> *thinks* "why are almost all the return instances injective"
07:02:05 <Cale> return 5 doesn't just return 5, it also has control effects
07:02:16 <Saizan> therp: there's patch-tag fsvo "like github"
07:02:29 <Cale> FunctorSalad: because the only monads for which return isn't injective are trivial.
07:02:32 <ray> if it "just returned 5", it would be written 5, not return 5
07:02:34 <dino-> I think generally people get over this quickly and it doesn't matter what it's called once you're clear on what it's doing in Haskell.
07:02:36 * osfameron has never thought about how procedures are constructed with continuations...
07:03:18 <Cale> ray: indeed
07:03:45 <osfameron> ray: huh?
07:03:50 <Cale> ray: well, almost -- most of those languages *do* have a distinction between procedures and values
07:03:53 <osfameron> wouldn't that just be, *being* 5 ?
07:04:02 <osfameron> returning should surely involve, um, *returning* ?
07:04:08 <soupdragon> osfameron: what do you mean? I don't understand because I though a (reified) continuation is a procedure
07:04:38 <FunctorSalad> Cale: I'm afraid I don't see the reason why this should be :(
07:04:50 <osfameron> soupdragon: nothing really, I don't really get continuations..
07:04:56 <ray> 5; /* this is an expression with the value 5 */ return 5; /* this gives control back to the caller and somehow hands it the value 5 */
07:05:05 <ray> so the first one is "returning" in cale's sense
07:05:21 <Cale> FunctorSalad: because  return v >>= f  =  f v
07:05:21 <SamB> Cale: I thought they just usually kept procedures in a different namespace from variables?
07:05:38 <Cale> SamB: Well, there's also a type difference
07:05:46 <therp> saizan: thanks
07:06:06 <SamB> wait, what am I saying, CL doesn't have continuations ...
07:06:07 <Cale> It would be possible to have return 5 be a procedure which returned 5 when called.
07:06:17 <Cale> (and no control effects)
07:06:41 <Cale> That would be the closest analogue to what we have in Haskell, I suppose.
07:06:58 <soupdragon> > fix (return 5)
07:06:59 <lambdabot>   5
07:07:19 <SamB> Cale: okay, which languages are you talking about?
07:07:20 <mauke> needs more fmap
07:07:29 <mauke> > fmap fix return 5
07:07:30 <lambdabot>   5
07:08:03 <SamB> @type fmap fix return 5
07:08:05 <lambdabot> forall a. (Num a) => a
07:08:25 <Cale> SamB: Imperative languages like C, where return v traditionally has control effects instead of just returning a value.
07:08:43 <SamB> Cale: wait ... C has continuations?
07:08:50 <Baughn> It doesn't.
07:09:01 <Cale> SamB: It behaves like it does, but doesn't give you full access to them.
07:09:04 * SamB didn't think setjmp/longjmp counted
07:09:11 <Baughn> Of course you can simulate C procedure calls with continuations, but that's a rather odd way to look at it
07:09:40 <FunctorSalad> Cale: ok, so "return v = return  w" implies "f v = f w" for all f :: a -> m b
07:09:40 <Cale> SamB: When you write any function in C, it behaves as if the entire function body is wrapped in call/cc and return v acts as a way to call the continuation.
07:09:41 <Baughn> ..it makes the rules needlessly complex for no good reason, since you can't even access the complexity
07:09:57 <Cale> FunctorSalad: yeah
07:10:12 <FunctorSalad> Cale: but these f's may fail to be "seperating" at first glance at least
07:10:12 <chturne> printPicture = putStr . concat . map (++ "\n")
07:10:25 <chturne> I think thats better :)
07:10:27 <FunctorSalad> (in a non-trivial way?)
07:10:31 <LeoD> @type unlines
07:10:33 <lambdabot> [String] -> String
07:11:41 <FunctorSalad> Cale: I think it depends on whether you use some sort of metalevel equality, or "=="
07:12:01 <FunctorSalad> (applicative equality or whatever)
07:12:05 <Cale> FunctorSalad: Well, I think you have to use parametricity in some way
07:14:10 <Cale> Since  return :: a -> m a for any a, it follows that unless return is simply discarding the value of type a, it can't otherwise be modifying it to have return v = return w when v /= w, since it has no idea what type v and w are, so no permissions to inspect them and vary its result based on that.
07:14:44 <FunctorSalad> Cale: maybe it suffices that for a given type A, the constructors of another type either seperate A, or they don't mention A at all
07:14:59 <lilac> FunctorSalad: x >>= return = x. if return v == return w, then return _ = k for some fixed k. therefore either (>>= return) is constant (and hence x is constant) or >>= doesn't use its RHS. both of these imply that the monad has only one value
07:15:24 * lilac thinks that's not actually quite right
07:16:01 <Cale> FunctorSalad: Theoretically, it's not required for return to be injective.
07:16:14 <Cale> FunctorSalad: (at least, I don't think it is)
07:16:54 <Cale> FunctorSalad: But in Haskell, it's forced to be by the fact that plain polymorphic functions can't do different things based on the type they're applied at.
07:16:55 <FunctorSalad> Cale: I was trying to think of a general categorical argument at the beginning ;)
07:17:58 <Cale> Since return is completely polymorphic in its parameter type, return can't pattern match its parameter at all.
07:17:59 <lilac> newtype MonoidMonad m a = MM { unMM :: m }; instance Monoid m => Monad (MonoidMonad m) where return _ = mempty; MM x >>= f = MM $ x `mappend` unMM (f undefined)
07:18:05 <lilac> ^^ is that a monad?
07:18:07 * lilac thinks so
07:18:37 <FunctorSalad> Cale: I think we need to agree on the equality first
07:19:21 <lilac> Cale: i assume you mean, in haskell return is forced to be either injective or constant?
07:19:34 <FunctorSalad> yeah that was our observation
07:19:42 <Cale> lilac: I'm arguing for why this must be.
07:19:54 <Cale> lilac: Just stating it over and over again isn't going to help ;)
07:20:18 <FunctorSalad> maybe the triangle equality helps
07:20:37 <lilac> Cale: sorry, i think i misunderstood "Theoretically it's not required for return to be injective [...] But in Haskell it's forced to be" as excluding the constant case
07:21:13 <Cale> lilac: ah, well, yes, of course.
07:21:26 <Bodo> hi
07:21:48 <Bodo> I have a few questions about using Haskell
07:22:05 <Cale> Bodo: go right ahead
07:22:37 <Bodo> I have moderate programming experience with Visual Basic 6, 2005 and 2008
07:22:45 <Bodo> I want to try something new
07:22:51 <Cale> okay
07:22:52 <lilac> FunctorSalad: think of a function as a (call) graph, where the nodes are either constants or some marker which means 'use the argument here'
07:22:56 <Bodo> but not overly complex
07:23:09 <Bodo> is haskell for me?
07:23:23 <lilac> FunctorSalad: then consider which functions can be applied to an argument of type 'a' (for a unknown)
07:23:26 <Cale> Haskell will be extremely different. The basics are not terribly complicated, but you should try to forget that you already know how to program ;)
07:23:36 <Bodo> what is the scope(limit) of this language?
07:23:37 <FunctorSalad> lilac: *nod*, but like I said it depends on the equality, doesn't it
07:23:45 <Bodo> ic
07:23:48 <Cale> It's a general purpose programming language.
07:23:51 <mux_> Bodo: your own imagination :-)
07:23:57 <Bodo> :)
07:24:00 <lilac> FunctorSalad: it depends on which primitives you have for working with values of type (exists a. a)
07:24:09 <lilac> in Haskell the only nontrivial one is seq
07:24:12 <Bodo> what kind of programs do people generally make with Haskell?
07:24:34 <FunctorSalad> @bot
07:24:34 <lambdabot> :)
07:24:34 <lunabot>  :)
07:24:38 <FunctorSalad> ;)
07:24:40 <dqd> Bodo: Don't think about it, just learn it: http://learnyouahaskell.com/
07:24:40 <mux_> fibonacci series generators
07:24:41 <dqd> :-)
07:24:42 <Cale> Bodo: Well, the community is growing, but still fairly small, so there haven't been too many giant projects yet.
07:24:52 <mux_> and window managers. ;-)
07:25:02 <Ferdirand> and solving Project Euler
07:25:10 <solrize> bodo, you might look at http://hackage.haskell.org/packages/archive/pkg-list.html
07:25:50 <lilac> FunctorSalad: but the point is, the graph either 'holds on to' all of the argument (so is injective) or none of it (so is constant, modulo seq)
07:25:53 <FunctorSalad> lilac: but after the function is done, you still have to ask your notion of equality whether the results are considered the same
07:26:29 <lilac> FunctorSalad: right, if you choose a more permissive form of equality you can say the results are the same, even if the rnf forms of the graph are different
07:26:36 <mux_> Bodo: more seriously, I've written some little script that gets an RSS stream (over HTTP), matches titles against regexps, and when it matches, gets the associated torrent file and queue it in my client (deluge)
07:26:42 <Cale> There are a number of compilers, a version control system (darcs), a window manager (xmonad), a number of financial companies are using it to do various computations, there's a company using it to write software for verifying cryptographic devices.
07:26:45 <mux_> Bodo: as you can see, you can do a lot of stuff in Haskell.
07:26:47 <FunctorSalad> lilac: with the graphs you are right I suppose
07:27:18 * mux_ would have probably used Perl to write such a script in the past
07:27:19 <Cale> Bodo: There are some games, but nothing too major -- mostly just proof-of-concept things.
07:27:52 <Bodo> sorry I got d/c
07:27:57 <Bodo> stupid wireless
07:28:03 <mux_> damn.
07:28:04 <Cale> Bodo: what was the last line you got? I can paste the log to you
07:28:08 <Bodo> anyways
07:28:13 <Bodo> sure
07:28:34 <Bodo> I was asking whether haskell is fully compatible with windows 7 Beta (built 7100)
07:29:21 <sm> morning all
07:29:31 <Cale> Bodo: I doubt anyone's tested GHC there, but I would be surprised if the windows binary didn't run.
07:29:52 <sm> ack.. after spending hours building leksah on mac, I discovered the .dmg!
07:30:25 <sm> if you're doing this, check the manual
07:30:32 <Bodo> how long would it take to learn haskell to a notable degree
07:30:44 <Bodo> by the way, any romanians out here?
07:31:06 <FunctorSalad> I'd say it is very gradual
07:31:34 <FunctorSalad> you still learn new things about the arcana all the time, but I guess any complex subject is like that
07:31:37 <Cale> Bodo: I spent 2 months getting to a point where I felt like I could do stuff with it, and about a year to become comfortable.
07:31:52 <Cale> Bodo: There are better tutorials now than I had when I started though ;)
07:32:08 <FunctorSalad> gentle introduckshun???
07:32:14 <Bodo> ic
07:32:24 <Bodo> ok ill give it a go
07:32:33 <Bodo> I hope windows 7 is fit for it
07:32:44 <Bodo> its windows - I know its not the best OS out there
07:33:13 <Bodo> I tried running backtrack, but this lappy cant seem to run it
07:34:29 <Cale> FunctorSalad: Yeah, that was one of the ones I struggled through. Basically, pieced things together from a number of places and lots of experimenting :)
07:38:55 <vav> Suggestions why local \bot-4.2.2.1 is constantly saying "... too few bytes. Failed reading at byte pos..."? (How to fix it?) This is with 6.10.3 and 6.10.4 on x86_64
07:39:02 <p_l> Bodo: Windows would benefit a lot if they could afford changing certain defaults from emulating win98-like system
07:39:28 <Bodo> true
07:39:36 <p_l> Bodo: except it would benefit only in technical sense, as Vista had shown that you lose "clients" over that
07:39:53 <Bodo> vista was a failure
07:40:09 <Bodo> windows 7 seems to be its perfect twin
07:40:21 <Bodo> windows 7 seems to rival ubuntu in performance
07:40:26 <Bodo> and resource usage
07:40:29 <p_l> IMHO only in resource usage department, and compared to XP SP2+ it didn't look that bad to me
07:41:28 <dino-> Bodo: I don't know if anybody mentioned, but some big projects done with Haskell: xmonad (tiling X window manager), darcs (distributed revision control, probably most similar to Git), and the Glasgow Haskell Compiler. IMO, it's significant when a language is bootstrapping its own compilation.
07:42:31 <Cale> dino-: I mentioned those ones :)
07:42:51 <dino-> Sorry, I should have scrutinized scrollback more carefully.
07:42:52 <Cale> (well, I didn't mention GHC specifically)
07:43:58 <vav> Cale: you wouldn't happen to have suggestion about my \bot (ByteString) troubles would you?
07:44:04 <p_l> Bodo: btw, I had only one problem with Vista when put into "production" on a certain laptop. XP otoh was completely outdated and showed it by that time
07:44:12 <Cale> vav: aha
07:44:22 <Cale> vav: your 'seen' plugin state is mangled
07:44:40 <Cale> vav: What I usually do is copy a backup of the 'seen' file over top of it.
07:44:48 <vav> awesom, been poking around way too long not getting anywhere
07:44:51 <Cale> That plugin is screwy.
07:46:24 <p_l> Bodo: btw, said problems existed in every 64bit windows release before
07:46:50 <Bodo> im running 32 bit
07:48:34 <p_l> Bodo: Well, I have a policy of not running 32bit on 64bit machines :)
07:49:52 <Bodo> I dont see a point for running windows 64bit on a laptop with 3gb ram, 2gz duo
07:50:16 <badsheepy> memory mapped io :o
07:50:20 <p_l> Bodo: extra registers and harder to infect
07:50:38 <p_l> badsheepy: that's why it has only 3G
07:51:15 <badsheepy> i meant more things like memmapping large files
07:51:20 <p_l> that too
07:51:21 <Bodo> well im off
07:51:24 <badsheepy> which you cant do when your address space is minimal
07:51:25 <Bodo> later guys]
07:52:26 <p_l> badsheepy: still, x86-64 is one of the rare cases where a 64bit variant is faster than 32bit variant
07:53:40 <ray> i had one problem with vista myself
07:53:47 <ray> they gave me 32 bit on a 64 bit system :P
08:06:42 <kowey> hmm... whatever is parsing those cabal files seems to be greedy matching <.*> on URLs: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mediawiki
08:06:58 <kowey> <url1> and <url2>
08:07:15 <dcoutts_> kowey: it uses the haddock parser
08:07:20 <dcoutts_> kowey: patches accepted
08:07:46 <dcoutts_> kowey: and we could do with a bug report for that
08:11:40 <kowey> dcoutts_: OK.. I'm filing a bug against haddock (or would it be better against something else?)
08:12:04 <dcoutts_> kowey: against Cabal too
08:12:25 <dcoutts_> kowey: I don't know if the bug is still in haddock, if it is then it needs fixing there too. The hackage code is a copy of the haddock code.
08:22:02 <kowey> dcoutts_: OK, done http://hackage.haskell.org/trac/hackage/ticket/569
08:22:08 <dcoutts_> thanks kowey
08:22:26 <MarcWeber> nominolo: Am I crazy now ? ghc can't find the command? But it is defined ? search for cmdListCabalComponents
08:23:38 <nominolo> MarcWeber: I'll need more details than that
08:24:06 <MarcWeber> nominolo: I'll commit everything
08:25:45 <MarcWeber> nominolo: I've pushed tmp_branch
08:29:11 <Berengal> Primitive abstractions only! Extremely limited, fixed set of control structures! No continuations, not even "with" blocks! Magic dependance on other parts of the code and which sequence things are run in is not only allowed, but omnipresent, and frequently enhanced through impure inversions of control! Requiring new files to be created just to declare a new datastructure! HOW DO PEOPLE GET THINGS WRITTEN IN THIS LANGUAGE?! It's 2009, but we migh
08:29:30 <ray> 2009, but we mig
08:29:38 <Berengal> might just as well be programming in assembly!
08:29:39 <CalJohn> Berengal: java?
08:29:45 <Berengal> CalJohn: Yes :(
08:29:57 <ray> NO TYPE SYSTEM
08:30:04 <CalJohn> ^ well, actually it does have one
08:30:07 <ray> if java had a type system it would be scala
08:30:11 <CalJohn> it's just quite unhelpful
08:30:12 <Berengal> Manifest types basically IGNORED by the compiler!
08:30:20 <ray> this is #haskell, we use "type system" a bit more strongly here
08:30:24 <CalJohn> hehe
08:30:24 <Badger> This is sounding better and better!
08:30:41 <Baughn> Haskell sounds better every day, yes
08:30:59 <CalJohn> Berengal: at least look on the brightside.  the people you are working with have not yet switched to python or ruby.
08:31:03 <ray> the trouble with scala is that people either want java or haskell, not java with types
08:31:04 <Berengal> I've spent the entire day chasing down weird heisenbugs that simply wouldn't have happened in haskell
08:31:28 <ray> i know it's not that simple, but so does everyone else who consciously or unconsciously simplifies it to that :P
08:32:07 <Badger> Berengal: write in haskell instead and disguise it as Java :P
08:32:25 <ray> save your haskell source with a .java extension
08:32:36 <Berengal> CalJohn: python and ruby are at least tolerable to program in up to a certain point. Java is horrible right away
08:32:52 -08:33:13 <Berengal> ray: God, I wish haskell could compile to jvm...
08:33:28 <ray> me too, and .NET
08:33:35 <CalJohn> Berengal: I like python/ruby a _lot_ less
08:34:04 <ray> well, the way it works is: any language is tolerable for one liners
08:34:06 <jmelesky> Berengal: there are some decent non-haskell languages for the jvm
08:34:11 <ray> in java, nothing's a one liner
08:34:17 <EvilTerran> ray, but you can't write one-liners in ja- yeah :P
08:34:18 <ray> in python/ruby, some things are
08:34:18 <jmelesky> yeti springs to mind, though i haven't worked with it
08:34:27 <ray> in haskell, lots of things are!
08:34:41 <Berengal> CalJohn: Get back to me when you have written migration "scripts" in java
08:35:45 <Berengal> Java has no interpreter, takes 2 minutes to compile and, yet every error happens at runtime
08:36:18 <mauke> of course it has an interpreter, it's called jvm
08:36:31 <soupdragon> I'm an interpreter
08:36:49 <ray> if it's such an interpreter, why do you spend forever compiling to it? :P
08:37:39 <Baughn> Because the compiler is written in an interpreted languae?
08:42:09 <Berengal> I think need some beautiful one-liners to set my mind straight
08:42:51 <MarcWeber> Berengal: system("sudo shutdown -h now") ? :-)
08:43:30 <mapreduce> Berengal: Perhaps you'd like CAL.
08:43:52 <LeoD> does anybody know why gtk2hs doesn't work with GHC 6.10.4?
08:44:13 <mapreduce> Someone mentioned Scala.  Sure, it's got a better type system than Java, but isn't useful for enforcing anything like purity or 'accessed on one thread' etc.
08:45:00 <mapreduce> And it has no null defence.
08:45:13 <dcoutts_> LeoD: you mean the pre-built windows installer? if that's the one you mean then it's because compiled library binaries work with a specific ghc version
08:45:35 <LeoD> dcoutts_: oh, i thought it didn't work on linux either
08:46:19 <Berengal> mapreduce: I have made null a personal enemy. I will never be truly happing using a language where values might be null by default
08:46:38 <dcoutts_> LeoD: it should build from source ok afaik
08:46:43 <LeoD> alright :)
08:46:48 <Baughn> Berengal: "foo = unsafePerformIO $ newIORef undefined"
08:46:59 <soupdragon> Berengal, what if you removed null
08:46:59 <mapreduce> Sure.  Though Scala doesn't really have defaults beyond what are necessary for Java interop.
08:47:10 <soupdragon> imagine java without null for example
08:47:42 <mapreduce> soupdragon: Then you'd need to change the rules quite a bit.
08:47:45 <mauke> Nullable<String> ns;
08:47:52 <Berengal> Baughn: undefined isn't really null, but it does indeed invoke some of the same programmer instincts
08:47:57 <mapreduce> E.g., class X { String s; } would become illegal.
08:48:24 <Baughn> Berengal: To my eyes, the main difference is that you can't test for it
08:48:27 <mapreduce> mauke: That's in C#.
08:48:45 <Berengal> Baughn: Also, null isn't an infinite loop, undefined can be
08:49:27 <Baughn> Berengal: I hope not. My use assumes that accesssing it throws an error.
08:50:28 <Berengal> Baughn: It's convenient that it does, but as far as your program semantics go, there's no difference between undefined = error "undefined" and undefined = undefined
08:50:53 <soupdragon> ???
08:50:56 <Baughn> Well, yeah. I'd never /catch/ the error. :P
08:50:58 <soupdragon> yes there is
08:51:07 <Baughn> The difference is when debugging, mostly
08:51:16 <soupdragon> I use  __ = __  btw
08:52:40 <Berengal> Because you can't tell the difference between _|_ the error and _|_ the infinite loop, it's safe to assume that a value returned by a function will never be _|_, or it wouldn't have returned at all
08:53:17 <soupdragon> what
08:53:43 <soupdragon> nothing returns in haskell
08:54:02 <soupdragon> there isn't control flow
08:54:07 <opqdonut> yes there is
08:54:31 <soupdragon> oh? I thought haskell was a pure fp lang :p
08:54:46 <opqdonut> the value of a function application can be called the return value
08:54:53 <soupdragon> no it can't
08:54:59 <opqdonut> watch me
08:55:11 <Berengal> soupdragon: What's the basis of these claims?
08:56:12 <soupdragon> well you can mumble any sequence of words you like, I'm obviously not trying to dispute that
08:56:13 <mapreduce> soupdragon: If you have f g x, then g x must be evaluated before f g x.
08:56:19 <mapreduce> soupdragon: This is control flow.
08:56:34 <soupdragon> mapreduce you're thinking ocaml or something
08:56:42 <mauke> if you have f g x, then g x is never evaluated
08:57:04 <Berengal> mauke: You can't know that without knowing what f is
08:57:04 <ray> i think you mean f (g x)
08:57:20 <Berengal> let f = ($) in f g x
08:57:22 <mauke> Berengal: f is flip id
08:58:05 <ray> of course f might not be strict
08:58:10 <mapreduce> soupdragon: I can only assume you're trolling me.
08:58:21 <soupdragon> mapreduce: watch
08:58:25 <mapreduce> mauke: Whoops.
08:58:29 <soupdragon> @let f = 3
08:58:30 <lambdabot>  Defined.
08:58:32 <mapreduce> I meant f (g x), yes.
08:58:33 <soupdragon> @undef
08:58:34 <soupdragon> @let f x = 3
08:58:35 <lambdabot>  Defined.
08:58:41 <soupdragon> @let g x = undefined
08:58:42 <lambdabot>  Defined.
08:58:50 <mapreduce> Ok, ok.
08:58:53 <soupdragon> try and evaluate  g x   now...
08:59:03 <mauke> > g x
08:59:04 <soupdragon> then try and evaluate  f (g x)
08:59:04 <lambdabot>   Ambiguous occurrence `g'
08:59:04 <lambdabot>  It could refer to either `L.g', defined at <local...
08:59:09 <mauke> @define
08:59:15 <soupdragon> and then tell me Am I trolling you??
08:59:16 <ray> just don't throw around the t-word
08:59:21 <mapreduce> If f evaluates its argument and g evaluates its argument then ..what I said earlier.
08:59:24 <Berengal> > let f x = 3; g x = undefined in (f (g x), g x)
08:59:25 <lambdabot>   (3,* Exception: Prelude.undefined
08:59:34 <soupdragon> or you just are not knowing what you are saying dude
08:59:59 <soupdragon> look I'll make it simple: I'm right
09:00:02 <Berengal> mapreduce: g doesn't have to evaluate it's argument for 'g x' to be completely evaluated
09:00:02 <ray> the fact is, things that get evaluated get evaluated in some order
09:00:07 <soupdragon> any questions?
09:00:18 <soupdragon> ray, that's false
09:00:33 <opqdonut> :D
09:00:49 <EvilTerran> evaluation order is unspecified in the haskell report
09:00:57 <EvilTerran> *semantics* are what's specified
09:01:07 <ray> it doesn't need to be specified, it just needs to happen at some point
09:01:11 <Berengal> evaluation order is unspecified, but there still has to be one
09:01:12 <soupdragon> this is so simple guys really
09:02:37 <EvilTerran> Berengal, sure, if you count such things as a parallel/concurrent evaluation strategy as an evaluation order
09:03:03 <opqdonut> oh and wrt calling the value of an application a return value, even the report does it
09:03:06 <opqdonut> -- length returns the length of a finite list as an Int.
09:03:09 <opqdonut> straight from http://www.haskell.org/onlinereport/standard-prelude.html
09:03:24 <EvilTerran> or some kind of heuristic speculative evaluation that's potentially nondeterministic order
09:03:41 <Berengal> You have a function, you give it an argument, you get a value in return. How is it wrong to call it the return value?
09:03:42 <Samy> Let's talk about Haskell baby, let's talk about you and me, let's talk about all the good things and all the bad things that may be, let's talk about Haskell.
09:03:53 <Berengal> Besides, "return" is overloaded in Haskell. Litterally
09:04:10 <kulakowski> eww, litter
09:04:31 <Berengal> You can never have enough puns
09:04:57 <Rembane> x = puns
09:04:59 <Rembane> x -> infinity
09:12:35 <Baughn> (re: vacuum leaks) ". soon they won't be able to stop them. It will be a hazardous vacuum spill, endangering all the surroundings of the LHC!!"
09:12:57 <kulakowski> really. ban vacuum cleaners!
09:13:23 <Berengal> kulakowski: No! They're the only things able to clean the vacuum!
09:17:11 <ray> no way
09:17:34 <ray> my vacuum cleaner once leaked vacuum all over my floor, and i had to move out for a week while the hazmat crews moved in
09:18:03 <SamB> ray: ;)
09:18:27 <Badger> I would've thought you'd need physicists for a problem like that.
09:18:36 <pikhq> The worst part is the vacuum energy.
09:18:46 <burp> lol
09:18:48 <pikhq> There's a lot of it, and it just gets emitted at random!
09:18:50 <ray> badger: gordon freeman
09:19:00 <Badger> ahha
09:19:09 <Badger> quite so
09:19:11 <Badger> good combination
09:19:33 <Rembane> I had a surge in my vaccum cleaner. It was messy.
09:19:38 <Berengal> ray: They moved in just like that? "Oh, you've got a vacuum spill? Bob, grab the xbox, I'll buy some pizza. We're moving into this guy's house. Anyone up for a party? I wonder what the neighbours are like..."
09:20:03 <ray> more like "evacuate the town, we might have to nuke it from orbit"
09:20:14 <ray> this *is* a vacuum spill we're talking about here
09:20:39 <Rembane> More Xboxes for them
09:20:44 <pikhq> Just a nuke won't be enough.
09:21:01 <pikhq> You need to get the LHC in to make a black hole.
09:21:42 * SamB doesn't see how a Haskell compiler will help, even if it does use Grin
09:21:44 <kulakowski> pikhq: to suck up the vacuum?
09:22:00 <pikhq> Yup.
09:22:10 <kulakowski> and then nuke the black hole?
09:23:37 <ray> yeah, if there's a catastrophic vacuum leak at the LHC, we'll have to start hoping for a black hole
09:29:06 <Philippa> oh FFS
09:29:15 <Philippa> yeah, that pretty much just deserves a 'sez you' and leaving it
09:29:34 <Philippa> oops, w/w
09:31:42 <bremner> oh yeah?
09:34:50 <burp> I wonder how the vacuum cleaner got it's name ;)
09:34:53 <MarcWeber> nominolo: I've fixed all type errors. But when adding this additional command to the list allCommands its still not found. So I'm puzzled
09:35:21 <Saizan> is ghc going to require MultiParamTypeClasses just to use one in a type signature? or should FlexibleContexts be enough?
09:35:23 <Baughn> SamB: Don't be silly, GHC uses black holes like other compilers use cookies
09:35:37 <Baughn> SamB: *Every time* you evaluate a thunk, it creates a new black hole
09:36:16 <Saizan> compilers use cookies?
09:36:49 <Baughn> Oh yes. The Data.Unique kind, though, not the web kind
09:38:19 <Saizan> heh
09:38:37 * gwern ponders Haskell nerdcore: 'I'm all about exact math, yo; I eat CReal for breakfast'
09:40:23 <jkff> I'd 'remember' this quote if only I know how to.
09:40:28 <jkff> *knew
09:40:55 <Baughn> @remember gwern *ponders Haskell nerdcore: 'I'm all about exact math, yo; I eat CReal for breakfast'*
09:40:55 <lambdabot> I will never forget.
09:41:37 <jkff> Oh. Thanks.
09:41:55 <quicksilver> Saizan: logically it shoudl be required to use one in a signature.
09:42:08 <quicksilver> Saizan: but the boundaries of those extensions are sometimes badly defined.
09:43:13 <jkff> I wonder whether anyone is working on making polymorphic datatypes parameterizable with unboxed ones. Or is something close to that reachable with our shiny new type families magic maybe? Would it be possible to implement Prelude for lists of unboxed integers without writing one completely from scratch?
09:43:36 <Axman6> oh man, this game is so addictive: http://www.ninjakiwi.com/Games/Tower-Defense/Play/Bloons-Tower-Defense-3.html
09:43:44 <jkff> Or, at least, writing one from scratch but also making it suitable for lists of unboxed floats.
09:43:53 <Axman6> i think i just played it for three hours straight
09:45:54 <jkff> OMG, Eugenia Cheng is explaining adjunctions in such a merry voice
09:45:55 <gwern> tower defenses appeal to the tweaker in us all
09:46:53 <gwern> 'just one more optimization!'
09:48:11 <Axman6> heh
09:48:19 <Axman6> this one is very addictive
09:50:24 <mauke> http://browsertoolkit.com/fault-tolerance.png
10:00:43 <yrlnry> I have a type constructor, P, of kind *->*.  I want to say that if M x is a MonadPlus, then so is P (M x).  But I don't know how to express this.
10:01:11 <mauke> I don't think that's possible in H98
10:01:12 <Saizan> uhm, kind mismatch
10:01:19 <lilac> yrlnry: you can't.
10:01:19 <mauke> well, that too
10:01:21 <yrlnry> I can't say   MonadPlus (M x) => MonadPlus (P (M x))   because Mx has kind * and MonadPlus declarations need kind * -> *.
10:01:43 <yrlnry> My idea has no kind mismatch.
10:01:49 <Saizan> yrlnry: you need to make P :: (* -> *) -> * -> *
10:02:07 <yrlnry> Okay, thanks.
10:02:12 <Saizan> and so you can do a MonadPlus m => MonadPlus (P m) instances
10:02:20 <lilac> yrlnry: you can say something like: newtype O f g x = O (f (g x)), then say: instance MonadPlus m => MonadPlus (P `O` m)
10:02:55 <yrlnry> lilac: I was wondering if that was a reasonable way to go.  Is that a reasonable way to go?
10:03:09 <lilac> i'd write it as a proper monad transformer myself
10:03:28 <yrlnry> Thanks again.
10:03:50 <lilac> that way you can implement lift etc. on it
10:06:36 <EvilTerran> newtype PT m a = PT { unPT :: P (m a) }; instance MonadTrans PT where ...
10:07:02 <mmorrow> that one haskell-cafe post about performGC "leaking" seems to be a windows deficiency
10:07:09 <EvilTerran> ... or should that be m (P a)?
10:07:30 <EvilTerran> in the case of some monad transformers, it's neither, iirc...
10:07:33 <mmorrow> [m@monire ~]$ ghci +RTS -N2 -RTS
10:07:34 <mmorrow> ghci> forever performGC
10:07:40 <mmorrow> pegs both my cores at 100%
10:07:46 <mmorrow> and runs in constant mem
10:07:46 <EvilTerran> but, from what yrlnry's said, i think P (m a) would be right
10:08:24 <mmorrow> (on linux(
10:08:45 <conal> i've forgotten -- what's the easiest way to set up ghc and common libraries on a new machine (os x) these days?
10:08:58 <copumpkin> THE PLATFORM!
10:09:10 <conal> where is it?
10:09:20 <conal> that's what my brain is hiding from me
10:09:25 <copumpkin> http://hackage.haskell.org/platform/
10:09:25 <Berengal> @where platform
10:09:25 <lambdabot> I know nothing about platform.
10:09:26 <copumpkin> :)
10:09:28 <conal> and what it's called
10:09:29 <conal> thx!
10:09:32 <copumpkin> @where+ platform http://hackage.haskell.org/platform/
10:09:32 <lambdabot> I will never forget.
10:09:36 <copumpkin> you'd better
10:09:57 <lilac> @flush
10:09:57 <lambdabot> Not enough privileges
10:10:09 <mmorrow> @fish
10:10:10 <lambdabot> Maybe you meant: flush list
10:10:21 <Berengal> Anyone tried GHC on sparc/solaris lately?
10:10:26 <conal> copumpkin: oh -- eep.  the osx description says "The MacOS X installer provides GHC 6.10.3 and the full tool and library suite".  i want 6.10.4
10:10:45 <Berengal> The ghc pages lists it as sort-of-working, but I've got no idea how up to date they are on that point
10:10:58 <copumpkin> conal: hmm, I guess they haven't released the latest one yet :/
10:11:00 <lilac> probably the easiest way to build 6.10.4 is to start with 6.10.3 already installed and working :)
10:11:16 <yrlnry> Sorry, I'm at a meeting and have to go idle now.
10:11:25 <conal> lilac: so get The Platform and then install the 6.10.4 pkg?
10:11:39 <Berengal> There's also http://haskell.org/ghc/download_ghc_6_10_4.html#macosxintel
10:12:53 <Berengal> Anyway, I thought the platform was supposed to have updated to 6.10.4 already...
10:12:55 <conal> Berengal: thx
10:13:00 <conal> hm.
10:13:24 <dcoutts_> conal: the next minor release of the platform is scheduled for Monday and it'll include 6.10.4
10:13:53 <conal> dcoutts_: cool.
10:14:06 <Berengal> Anyway, installing 6.10.4 kind of invalidates all the platform packages, doesn't it?
10:14:21 <conal> oh, oops.
10:14:36 <Berengal> Binary incompatability and all that...
10:14:53 <chturne> Does anyone know of a list of purely functional programming languages? I only know of two that people don't argue about, those being Miranda and Haskell. Anyone know any more?
10:14:57 <conal> i just got a new mac (my first) and i'm going to set up ghc & cabal-install & libs today.
10:15:10 <SamB> chturne: clean
10:15:10 <copumpkin> I’d like my matrix representation to be
10:15:10 <copumpkin> Object oriented
10:15:10 <copumpkin> Immutable
10:15:10 <copumpkin> Immutable
10:15:10 <copumpkin> Represent both integers and doubles
10:15:11 <mauke> lambda calculus
10:15:12 <copumpkin> lol
10:15:29 <SamB> chturne: oh, and Coq if you count theorem-provers ...
10:15:40 <Berengal> chturne: The ml family and the lisp family are the two major families of languages
10:15:45 <SamB> oh, and let's not forget DSSSL, per the standard
10:15:53 <dons> http://www.reddit.com/r/programming/comments/93kdv/nqueens_in_a_tweet/  :D
10:16:06 <dcoutts_> Berengal: the osx release of the platform includes ghc-6.10.3, so that'll continue to work, but yes you'll not have the extra libs with your separately-installed 6.10.4
10:16:23 <SamB> Berengal: what about C, and the languages whose names begin with a P (including Ruby, of course)
10:16:26 <Berengal> dcoutts_: Yeah, that's what I meant
10:16:39 <Berengal> SamB: They aren't functional last thing I checked
10:16:42 <nominolo> MarcWeber: yeah, very strange
10:16:51 <SamB> Berengal: you said of languages
10:16:59 <nominolo> MarcWeber: it works on my master branch
10:17:01 <Berengal> SamB: functional implied
10:17:03 <mauke> Berengal: ml and lisp aren't purely functional
10:17:03 <chturne> Thanks for the help :)
10:17:16 <SamB> chturne was asking about purely functional langauges
10:17:28 <copumpkin> http://stellar.mit.edu/S/course/6/fa08/6.197/courseMaterial/topics/topic2/lectureNotes/Intro_and_MxM/Intro_and_MxM.pdf lol, JUST MAKE IT MUTABLE
10:17:37 <Berengal> mauke: Oh, true that
10:18:04 <conal> if i want a 6.10.4 system today, is my best bet install ghc and cabal-install and then individual libraries as needed?
10:18:05 <Berengal> I'm sure there's some purely functional dialects... I consider Haskell to be a member of the ML family anyway, so there's that
10:19:07 <SamB> Berengal: well, given the two families, I'd have to agree that Haskell goes in the ML rather than the Lisp family ;-)
10:19:54 <SamB> why isn't there a haskell-platform package on hackage?
10:20:12 <jmcarthur_work> conal, yes
10:21:08 <MarcWeber> nominolo: So you can compile it ? Maybe I messed up with some dependency libs ? I got some cabal warnings about having different versions of the same lib in deps
10:21:19 <conal> jmcarthur_work: thx
10:21:22 <kulakowski> What benefit is there to manually having 6.10.4 over a packaged 6.10.3?
10:21:23 <nominolo> MarcWeber: hmm. moving it changes the error
10:21:53 <Berengal> kulakowski: Less buggy/newer version of GHC
10:22:18 <nominolo> MarcWeber: great, moving it back fixed the error.  wtf
10:22:29 <nominolo> ah, no
10:22:37 <Baughn> kulakowski: Mind you, the bugs in 10.3 are unlikely to affect you unless you're me or conal
10:22:42 <MarcWeber> nominolo: You're on 995ceba4c6 ?
10:24:10 <kulakowski> Baughn: That's sort of what I seemed to remember looking at the release notes, but wasn't sure...thought that there might be something OS X specific that I would have glossed over.
10:24:33 <Berengal> I haven't yet upgraded. Figured I might just as well wait for the platform to update itself. With 6.10.3, however I upgraded the minute I got the email
10:26:22 <nominolo> MarcWeber: ok, I'm starting to suspect it has something to do with layout parsing
10:27:03 <nominolo> MarcWeber: more precisely, with teh comment above it
10:28:00 <nominolo> fuck, this is soo wrong.  Here's the fix:  add a '\' before the '*' in the FIXME
10:29:29 <MarcWeber> nominolo: Have I found a bug? yeah!
10:30:30 <nominolo> did you add that comment?
10:31:56 <MarcWeber> Yes. But I thought removing comments is one of the most basic things which can't go wrong.
10:32:22 <MarcWeber> nominolo: Have you seen -- currently this just globs for */setup-config
10:32:35 <conal> Baughn: have you tried 6.10.4 and noticed improvements for unamb?
10:32:47 <MarcWeber> nominolo: CPP caused it, didn't it ?
10:40:08 <pchiusano> hello
10:40:10 <nominolo> MarcWeber: hm, maybe, let's check
10:40:48 <nominolo> MarcWeber: ah, yes, /* was treated as a comment
10:40:55 <nominolo> that's bad
10:42:33 <MarcWeber> nominolo: I should have known it. I really must write more haskell. Maybe I trust it again then :)
10:42:51 <pchiusano> i have a question about usage of applicative functors
10:43:52 <pchiusano> suppose I have a number of "labeled" data structures, like labeled trees, labeled lists (maps), functions, etc
10:44:33 <pchiusano> i would like to be able to generically transpose nested structures, so, for instance, convert a map of labeled trees to a labeled tree of maps
10:45:10 <pchiusano> i think that the applicative functor interface will allow me to do this, but I am getting tripped up by the presence of the "label" type
10:45:35 <EvilTerran> pchiusano, sounds like Data.Foldable or Data.Traversable
10:45:45 <EvilTerran> ?hoogle Traversable.sequence
10:45:45 <lambdabot> No results found
10:45:56 <EvilTerran> ?hoogle sequence
10:45:56 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:45:57 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:45:57 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
10:46:05 <pchiusano> suppose I have data LabeledTree k v = Leaf k v | Branch k [LabeledTree k v]
10:46:15 <Baughn> pchiusano: So basically, you want a function inverse :: f (g a) -> g (f a)
10:46:24 <pchiusano> what would applicative instance look like for that type
10:46:46 <EvilTerran> pchiusano, i don't think that'd be Applicative on its own
10:47:00 <Baughn> pchiusano: You can't do it with just applicative, but see Data.Traversable.sequences
10:47:06 <Baughn> *sequence
10:47:09 <EvilTerran> you've got no way of having a v with no k, and no way of getting a k from nowhere
10:47:19 <pchiusano> Baughn: yes, I know you need applicative + traverseable
10:47:32 <chessguy_work> @pl \x y -> x : show y
10:47:32 <lambdabot> (. show) . (:)
10:48:22 <EvilTerran> pchiusano, you could maybe write something like "instance Monoid k => Applicative (LabeledTree k) where pure = Leaf mempty; (whatever ap would be, i believe something should be possible)""
10:48:25 <Baughn> pchiusano: sequenceA is about right, I think
10:48:47 <Baughn> > sequenceA [[1,2],[3,4]]
10:48:48 <lambdabot>   Not in scope: `sequenceA'
10:49:15 <Baughn> ..never mind. No, it ain't.
10:49:17 <Baughn> Right signature, at least
10:49:22 <pchiusano> EvilTerran: what would I need to make LabeledTree applicative
10:51:21 <dons> http://www.reddit.com/r/programming/comments/93kdv/nqueens_in_a_tweet/ up mods plz! its quite a nice story
10:53:09 <pchiusano> EvilTerran: I don't think I should need to constrain the key type of the tree
10:54:34 <pchiusano> data LabeledTree k v = Leaf k v | Branch k v (k -> LabeledTree k v)
10:55:13 <soupdragon>  (k -> LabeledTree k v)
10:55:14 <soupdragon> nice
10:56:05 <pchiusano> i am trying to figure out a way to have pure return an infinite labeled tree
10:57:10 <pchiusano> where no matter what path of labels you choose, the value is always whatever value you passed to pure
10:58:33 <Baughn> pure v = let tree = Branch undefined v (const tree) in tree -- Or thereabouts, unless the undefined is a problem
10:59:36 <pchiusano> Baughn: yes, something like that, I can work with that
10:59:58 <pchiusano> but, now, what do I put for the class declaration for LabeledTree
11:00:17 <Baughn> pchiusano: You couldn't have "data LabeledTree k v = Root (k -> LabeledTree k v) | Branch k v (k -> LabeledTree k v) | Leaf k v" instead?
11:00:43 <pchiusano> Baughn: ya, that is fine
11:01:20 <pchiusano> or data LabeledTree k v = Leaf v | Branch v (k -> LabeledTree k v)
11:01:45 <Baughn> Then pure v = let f = (\k -> Branch k v f) in Root f
11:02:08 <Baughn> Ah, that last one looks best
11:02:21 <pchiusano> Baughn: yeah that is clean
11:02:30 <pchiusano> Baughn: but what do I put for the instance declaration?
11:02:47 <pchiusano> instance Applicative (LabeledTree ??) where ??
11:02:53 <Baughn> pchiusano: "instance Applicative (LabeledTree k) where"
11:02:56 <Baughn> IIRC
11:03:43 <Baughn> Applicative wants a type of kind * -> *, so that looks right
11:04:39 <Berengal> What's ap look like for trees anyway?
11:04:49 <pchiusano> Baughn: yes that does look right
11:05:20 <pchiusano> Baughn: thank you for help :)
11:05:29 <Baughn> Berengal: ap ~ zipWith ($) should be about right
11:05:30 <Taejo> Berengal: I'd imagine something they're something like ZipList (functions get applied to the values in the same position)
11:05:45 <pchiusano> Berengal: it just zips the two trees together and applies ...
11:05:56 <pchiusano> ... what Baughn and Taejo said :)
11:06:06 <Berengal> Can you do multiplication as well?
11:06:14 <Baughn> No
11:06:35 <Baughn> Well, you could define a multiplicative ap, but no pure
11:06:47 <sm> where can I find out more about the Context.hs file cabal generates ? or is it not a cabal thing ?
11:06:58 <Berengal> Baughn: No? I'd imagine pure would be Leaf
11:07:15 <dcoutts_> sm: it's not Cabal, are you hacking on darcs?
11:07:20 <Baughn> Berengal: No, since Leaf has a key attached
11:07:22 <sm> yes indeed I am
11:07:33 <Baughn> Berengal: Anyway, a multiplicative ap would need to have some combining function for the keys
11:07:39 <sm> it must be in out Setup.lhs after all.. I'll look harder
11:07:42 <Berengal> Baughn: Then let's assume it doesn't have keys
11:09:17 <Baughn> "pure id <$> vs = vs" <- Hm, let's see..
11:13:09 <Baughn> Berengal: I am.. unsure. Remember, ap :: f (a -> b) -> f a -> f b
11:13:31 <Baughn> In this instance, that becomes ap :: LabeledTree k (a -> b) -> LabeledTree k a -> LabeledTree k b
11:14:01 <Baughn> It seems to me that, for a multiplicative ap, you'd need k to be (k,k) in the last one
11:14:04 <Berengal> Baughn: Or ap :: UnlabeledTree (a -> b) -> UnlabeledTree a -> UnlabeledTree b
11:14:30 <jmcarthur_work> Berengal, if ap is supposed to be like ZipLists's ap, then pure should be like ZipList's pure
11:14:35 <Baughn> Berengal: A plain tree? Yeah, but that one's /easy/
11:14:52 <Berengal> Baughn: It is?
11:14:56 <jmcarthur_work> > getZipList $ pure 5
11:14:57 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
11:15:02 <Berengal> I don't know anything about the product of trees...
11:15:21 <jmcarthur_work> oh multiplicative
11:15:21 <Berengal> jmcarthur_work: It's supposed to be product, not zip
11:15:24 <jmcarthur_work> i missed some stuff
11:15:29 <Baughn> Berengal: Sure, you just graft the full right-hand tree at every leaf in the left-hand one, applying the function of that leaf to every leaf value in the right-hand one
11:15:47 <Baughn> Berengal: Then pure = Leaf id, and everything's fine
11:16:01 <Baughn> ..though I'm not entirely sure what it's for. Well, someone would think of something.
11:16:20 <Berengal> Heh, it's probably not too useful, or I'd known about it at least
11:16:24 <jmcarthur_work> i think you could make a product for a labelled tree if the label type has a zero
11:16:38 <jmcarthur_work> say, Monoid k, or something
11:16:43 <Berengal> (Monoid k) => LabeledTree k v
11:17:08 <Berengal> Yeah, I thought about that as well
11:17:20 <Baughn> jmcarthur_work: Problem is, with ap a b, with N leaves in a and M in b, you need N*M keys for the result tree..
11:17:21 <kulakowski> googling "tree products" isn't as useful as one would hope. apparently paper is one of them...
11:17:46 <Baughn> jmcarthur_work: Though I suppose the "graft it on as a subtree" variant could work there too
11:17:59 <jmcarthur_work> Baughn, i think that's the point :)
11:18:12 <Berengal> Baughn: Just because it's keyed doesn't mean it has to be uniquely keyed
11:18:50 <Baughn> jmcarthur_work: But don't forget the "pure ap <$> vs = vs" law
11:18:53 <Baughn> Er, pure id
11:19:18 <Baughn> You don't just need a default key value, you need one that goes away entirely when ap'd
11:19:35 <jmcarthur_work> Baughn, the Monoid laws would guarantee that if you are mappending the keys
11:19:40 <Berengal> Baughn: The unlabeled tree, does it have Branch v [Tree v] or Branch [Tree v] ?
11:19:58 <Baughn> Berengal: Not sure. It's your tree. ;)
11:20:28 <Taejo> Hmmm... I'm pretty sure I had this discussion about (Map k) being Applicative for Monoid k just a few weeks ago
11:20:29 <Baughn> jmcarthur_work: Ah, right. Convenient.
11:20:30 <Berengal> Baughn: How would you graft the right-hand-side tree on a Branch v [Tree v]?
11:21:06 <jmcarthur_work> we could say LabelledTree k v ~ Tree (k, v) or something, i think
11:21:11 <Baughn> Berengal: I.. oh, right. Quite so; there are no values stored except in leaves.
11:21:19 <mmorrow> @let zipT (<>) (Node a as) (Node b bs) = Node (a<>b) (zipWith (zipT (<>)) as bs)
11:21:21 <lambdabot>  Defined.
11:21:21 <jmcarthur_work> where we use a reasonable composition of Tree with (,) k
11:21:31 <mmorrow> @type zipT ($)
11:21:32 <lambdabot> forall t1 b. Tree (t1 -> b) -> Tree t1 -> Tree b
11:21:35 <mmorrow> ?
11:21:44 <Saizan> Berengal: that looks like Data.Tree which has a Monad instance
11:22:19 <jmcarthur_work> yeah, and that is the Tree i was referring to
11:22:30 <jmcarthur_work> i believe it has a product Applicative
11:22:40 <soupdragon> why is it  ~  rather than  =  ?
11:23:01 <jmcarthur_work> soupdragon, i'm using ~ to mean semantically similar rather than literally equal
11:23:04 <burp> hm, when I call a function twice with the same argument, is it calculated twice? I remember something that this is not the case
11:23:13 <Botje> yes, it is.
11:23:17 <soupdragon> ~ is an equality constraint
11:23:19 <burp> ok
11:23:23 <Baughn> burp: The function is, the argument isn't
11:23:30 <mmorrow> burp: if you find the call to a variable with "let", it's only computed once
11:23:31 <jmcarthur_work> ~ is whatever i say it is! ;)
11:23:38 <soupdragon> no
11:23:41 <mmorrow> s/find/bind/
11:23:45 <burp> http://paste.railsbox.eu/show/6CiOKr90FNwbykEDTEDO/ <- I think about optimizing my this recursive integration function
11:23:53 <burp> in each recursion there are function calls with the same argument
11:23:59 <soupdragon> I'm asking why they use ~ for equality constraints in GHC
11:24:01 <Berengal> Data.Tree doesn't store values in branches...
11:24:03 <jmcarthur_work> ah!
11:24:06 <jmcarthur_work> no idea
11:24:17 <mmorrow> , src ''Tree
11:24:17 <Berengal> It doesn't seem to me like it's possible to make a multiplicative applicative instance of it
11:24:23 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
11:24:30 <jmcarthur_work> Berengal, yes it does
11:24:31 <mmorrow> , src ''Forest
11:24:33 <lunabot>  type Forest a = [Tree a]
11:24:34 <Baughn> burp: mmorrow is right, then. You should bind the ((a+b)/2)value with a let, otherwise it's computed twice.
11:24:37 <Berengal> hmm, yes, it does
11:24:42 <Berengal> Records confused me
11:24:45 <burp> Baughn, ok
11:25:20 <Baughn> burp: Although, I doubt that matters much compared to the cost of the error calculation. Still.
11:27:00 <burp> hm yes, in this case f is simple
11:30:04 <Berengal> This monad instance of Data.Tree now makes sense to me
11:38:21 <mmorrow> copumpkin: nice pdf
11:38:47 <copumpkin> yeah
11:39:20 <mmorrow> the second to last page is neat
11:40:04 <mmorrow> 296260x faster than OO+immutable+polymorphic
11:40:31 <mmorrow> (BLAS parallel)
11:40:35 <jmcarthur_work> i am rather disappointed that it required loss generality and elegance over time, though
11:40:44 <jmcarthur_work> well, until it got to the libraries
11:41:02 <jmcarthur_work> i found the first C solution to be the most elegant, really
11:41:08 <copumpkin> yeah, me too
11:41:39 <mercury^> What pdf are you talking about?
11:41:52 <copumpkin> http://stellar.mit.edu/S/course/6/fa08/6.197/courseMaterial/topics/topic2/lectureNotes/Intro_and_MxM/Intro_and_MxM.pdf
11:41:52 <Berengal> When will the haskell version perform just as well?
11:42:04 <copumpkin> I hate how immutability was the first thing they dropped
11:42:32 <mercury^> thanks
11:42:42 <mmorrow> copumpkin: well since they're not using graph reduction a single modification to the mat caused the entire thing to be copied
11:42:49 <copumpkin> yeah
11:42:50 <Berengal> copumpkin: Didn't they do the extremely dumb version of it where they copied the entire result matrix for each multiplication?
11:42:56 <copumpkin> yup
11:42:57 <mmorrow> so in that context immutability is pretty silly
11:43:03 <copumpkin> well yeah
11:43:16 <copumpkin> if they hadn't started with something quite so ridiculous they may not have needed to dump it so early
11:43:55 <Berengal> Such a thing doesn't deserve to be called immutability. People might get the wrong idea...
11:44:01 <mmorrow> they'd've (double contraction!) had to implem graph reduction first though..
11:44:45 <Berengal> But in the end they could've ended up with a function of type (Unboxeable a) :: [:a:] -> [:a:] -> [:a:]!
11:45:03 <Berengal> That might perform just as well for doubles as their latest version ;)
11:45:47 * Berengal takes his last statement and modulos typos
11:46:19 <copumpkin> we should see how fast we can get matrix multiplication
11:46:20 <copumpkin> :P
11:46:24 <mmorrow> Berengal: blas code is pretty tight.. when you compile it it even specializes for the particular processor in your machine by running tests or something on it (iirc, haven't compiled it myself for a while) (or maybe this was lapack actually)
11:46:26 <copumpkin> without getting too ugly
11:46:54 <mmorrow> so you'd need to take into account the exact asm being produced and the exact processor in a particular machine (cache, random crap) to get equiv performance
11:47:58 <mmorrow> (although if you don't build it yourself, you don't get the specialization..)
11:48:10 <Berengal> mmorrow: In ten years that'll be a compiler option. "ghc --make Foo.hs -O3 -fBLAS"
11:48:42 <mmorrow> Berengal: you  can do that now, just ffi to the C lib
11:48:45 <mmorrow> (lapack too)
11:48:59 <mmorrow> well, C+FORTRAN+asm
11:49:39 <mmorrow> hmatrix uses lapack+blas..
11:49:40 <Berengal> mmorrow: That requires FFIing. I'm hoping I could just write it using lists and have it compile to übercode
11:49:47 <Berengal> Of course, I'm a very optimistic person...
11:50:13 <mmorrow> asm code is asm code
11:50:48 <Berengal> True, but I don't want to care about such details
11:50:54 <mmorrow> the only reason we have to deal with the ffi overhead is on account of the C calling convention being diff from ghc's
11:51:15 <mmorrow> Berengal: totally, but someone has to
11:51:39 <Berengal> mmorrow: Actually, I do care, but I want to be able not to
11:52:01 <Berengal> (And still get better performance)
11:52:33 <mmorrow> Berengal: sure, i just think there's a fundamental limit to the level you can write something at before "the right way" to optimize it becomes too ambiguous to be able to deduce
11:53:31 <mmorrow> (where here "the right way" := to make it as fast as if you hand coded it in asm taking into account full knowledge of the particular submodel of the particular processor the code might happen to be compiled for)
11:53:34 <Berengal> mmorrow: Depends on the amount of analysis done. I don't think there's such a limit for whole-program optimizers
11:53:57 <mmorrow> as long as they produce their own asm
11:54:44 <SamB> Berengal: sure there is
11:55:34 <SamB> Berengal: they don't know how much RAM will be available, how fast the various layers of the storage stack will be, etc.
11:55:45 <SamB> ... how much load the system will be under at the time!
11:55:59 <Berengal> SamB: But neither does low-level compilers
11:56:22 <Berengal> Nor humans coding asm by hand
11:56:23 <SamB> I'm just talking about "the right way"
11:56:56 <Berengal> SamB: "The right way" being "as fast as possible"?
11:57:20 <SamB> yeah. you can't compile code for that, really.
11:57:22 <Berengal> Because the level mmorrow and I were talking about were the abstraction level of the language the code was written in
11:58:30 <Berengal> Where "the right way" is "as fast as possible", not "impossibly fast"
12:00:31 <SamB> Berengal: so you know God's algorithm for the rubik's cube?
12:01:09 <badsheepy> surely god just makes it solved and doesnt need an algorithm :p
12:01:42 <tavelram> actually its something like godFun = translate $ replicate 6 [1..9]
12:01:47 <mmorrow> yeah, "the right way" here being "as fast as you could possibly achieve by any means"
12:01:49 <dolio> He peels off the stickers and sticks them back on.
12:01:53 <mmorrow> so we're not being entirely practical here, but talking about the extreme case
12:01:57 <SamB> you guys are goofy
12:02:01 <mmorrow> dolio: i knew it!
12:02:06 <tavelram> or not
12:02:19 <tavelram> rep 9 [1..6]
12:02:25 <tavelram> and trans on that
12:02:31 <tavelram> transpose
12:02:44 <tavelram> > transpose $ replicate 9 [1..6]
12:02:46 <lambdabot>   [[1,1,1,1,1,1,1,1,1],[2,2,2,2,2,2,2,2,2],[3,3,3,3,3,3,3,3,3],[4,4,4,4,4,4,4...
12:02:49 <mmorrow> stupid 2D text terminals..
12:02:51 <tavelram> there we go :)
12:03:46 <tavelram> @hoogle translate
12:03:47 <lambdabot> System.Process.Internals translate :: String -> String
12:03:50 <Berengal> SamB: Not the point. I'm saying there's no reason high-level languages should be impossible to optimize as well as low-level languages
12:03:52 <SamB> well, consider if God had to tell you what moves to make, but one or two of the axles in the cube were hard to turn, and he (somehow, yes I know this is not theologically sound okay?) didn't know which ones?
12:03:59 <tavelram> @hoogle matrix
12:03:59 <lambdabot> package matrix-market
12:04:00 <lambdabot> package hmatrix
12:04:04 <SamB> Berengal: oh, sure
12:04:08 <SamB> Berengal: better even!
12:04:24 <SamB> in most cases
12:04:39 <Berengal> SamB: Assuming whole-program compilation of course
12:04:47 <SamB> Berengal: not even, really
12:05:17 <mmorrow> i heard that god wasn't even whole-program-compiled when we built him
12:05:19 <SamB> generally, programming languages hide a good bit of the machine state
12:05:43 <SamB> mmorrow: I'm not talking about that daemon-runner thing
12:05:44 <Berengal> SamB: In some cases you have to. You can't specialize and unbox generic functions that are called with specializeable and unboxable types if the two modules involved were compiled separately
12:05:56 <SamB> mmorrow: I thought it was written in ruby anyway?
12:06:15 <mmorrow> SamB: sounds possible
12:06:25 <SamB> Berengal: depends where you draw the whole-program line ;-)
12:07:12 <mmorrow> i think how we see separate compilation as a black or white thing is holding back progress
12:07:40 <Berengal> SamB: Basically, whole-program = all sources available and compiled into a single binary, versus linking to pre-compiled objects without mangling the executable
12:07:40 <jmcarthur_work> would it be practical at all to use, say, coq to write a compiler and prove that its output is optimal for some vm? i imagine it is probably not easy to prove optimizing algorithms
12:08:00 <mmorrow> jmcarthur_work: optimal wrt what metric(s)?
12:08:22 <lilac> jmcarthur_work: which set of programs do you consider to be appropriate 'optimizations'? isn't that non-computable?
12:08:26 <jmcarthur_work> well, depends on the complexity of the vm
12:08:50 <lilac> assuming a turing-complete vm
12:08:52 <Berengal> I imagine a vm with weighted instructions...
12:09:12 <mmorrow> Berengal: omg that thing probably doubles the weight of your laptop then?
12:09:15 <Berengal> Possibly some hot core-on-core SMP action going on as well...
12:09:18 <pragma_> How do I know that I know what I know?
12:09:30 <Berengal> pragma_: By asking that question
12:09:31 <jmcarthur_work> weighted instructions is just an approximation of hardware, of course. a more realistic vm would have rules regarding pipelining, caching, etc.
12:09:38 <soupdragon> jmcarthur_work: it'll be HARD
12:09:50 <jmcarthur_work> yeah that is what i'm guessing
12:09:52 <soupdragon> jmcarthur_work: no clue really what practical means
12:09:57 <jmcarthur_work> nor do i
12:10:14 <mmorrow> did anyone read about the C-subset-to-ppc-asm someone wrote in Coq?
12:10:15 <SamB> lilac: well, you'd have to define some kind of metric for weighting inputs as well
12:10:16 <lilac> pragma_: one might assume you know, or can rapidly derive, all obvious tautologies. 'i know what i know' is such a tautology
12:10:24 <soupdragon> jmcarthur_work: Possible though! If the proofs work on paper you can get the computer to do it too
12:10:35 <jmcarthur_work> right
12:10:40 <SamB> lilac: but that doesn't get you anywhere
12:10:46 <mmorrow> it was in the most recent asm magazine they send out, dunno if it's available online without at least 4 passwords
12:10:50 <mmorrow> err
12:10:51 <soupdragon> mmorrow: Xaviers CompCert?
12:10:54 <mmorrow> s/asm/acm/
12:10:58 <mmorrow> soupdragon: exact;ly
12:11:06 <mmorrow> (iirc)
12:11:15 <mmorrow> yeah, that's the one
12:11:18 <lilac> SamB: i don't see it. i'd think "is this a correct optimization?" is a discrete question.
12:11:21 <soupdragon> I didn't read about that in a magazine but have heard of it
12:11:29 <SamB> mmorrow: my school's IP addresses seem to work magic on the ACM website
12:11:42 <SamB> lilac: oh, correct is discrete
12:11:44 <lilac> if we're considering the subset of programs which can be proven equivalent with a proof of a certain level of complexity, then maybe...
12:11:46 <SamB> but optimization isn't
12:11:51 <mmorrow> SamB: so does my regularly billed credit card
12:11:59 <mmorrow> :) :| :/
12:12:10 <SamB> mmorrow: hmm, I guess your way is cheaper
12:12:29 <lilac> SamB: sure, but if you want to prove your algorithm maximizes optimization, you need to know what space of possible programs you're working in
12:12:38 <SamB> lilac: sure
12:12:46 <mmorrow> SamB: heh, true
12:13:05 <Berengal> papers should be free :(
12:13:09 <lilac> i would think that for a turing-complete language, that alone would make a provably-optimal optimizer uncomputable
12:13:12 <SamB> lilac: so programs that have a subset of the allowed I/O patterns for the original code
12:13:43 <soupdragon> lilac, I'm sure you are right but it's far too complex to work through the details
12:14:00 <pikhq> Doesn't a provably-optimal optimizer for a TC language involve the halting problem, anyways?
12:14:06 <SamB> probably
12:14:42 <mmorrow> i dunno, that sounds tractable for sure
12:14:49 <lilac> pikhq: i believe so, but i don't think it's completely trivial to prove
12:14:53 <mmorrow> given all the attributes of the processor, ..
12:15:11 <pikhq> lilac: It's one of those things that seems quite likely, but is a royal pain to prove, I'd imagine. ;)
12:15:23 <mmorrow> i'd think it'd be easy to determine optimality (given a metric)
12:15:30 <lilac> mmorrow: a brute-force search would require the ability to know whether two arbitrary programs are equivalent
12:15:41 <mmorrow> where "easy" := not impossible
12:15:46 <mmorrow> ;)
12:15:58 <mmorrow> lilac: but i've been given a metric
12:16:04 <lilac> knwoing whether two arbitrary programs in a TC language are equivalent /is/ impossible
12:16:11 <mmorrow> lilac: wrt what?
12:16:15 <lilac> mmorrow: to which set of programs are you applying this metric?
12:16:19 <mmorrow> you need to say that in order to make that statement
12:16:36 <mmorrow> lilac: two asm programs, input is asm code
12:16:43 <mmorrow> for a given processor
12:16:47 <jmcarthur_work> i'd think it'd be easy to prove a particular optimization to be semantics preserving. the problem is proving that your set of optimization can express every transformation necessary to perfectly optimize the program
12:16:51 <soupdragon> knwoing whether two arbitrary programs in a TC language are equivalent   is different to constructing one program from another along with an equivalencs proof
12:17:03 <pikhq> lilac: Of course, you *could* figure that out for common machines. You see, we don't have Turing-complete machinery. :P
12:17:20 <mmorrow> FPGA's ftw!
12:17:22 <lilac> mmorrow: ok, let's define equivalent in this case to mean, they perform the same observable IO actions
12:17:33 <pikhq> Of course, doing that for common machines is definitely damned difficult.
12:17:51 <pikhq> A minimum of 2^32 possible states? Ick.
12:18:15 <mmorrow> lilac: oh, i'm talking about the actions they trigger the processor to perform
12:18:35 <mmorrow> assume you have the full source code to a processor
12:18:40 <mmorrow> and you have two asm progs
12:18:40 <lilac> mmorrow: if they trigger the same CPU actions, what are we optimizing?
12:18:48 <mmorrow> lilac: time
12:18:59 <Berengal> There might still not be an easy winner without knowing the input ahead of time
12:19:01 <lilac> i'm thoroughly confused now.
12:19:15 <lilac> the same CPU actions will take the same amount of time, right?
12:19:27 <SamB> I think mmorrow is the confused one
12:19:29 <mmorrow> lilac: optimal := as fast as is possible given the problem and the processor
12:19:34 <mmorrow> is what i'm talking about
12:19:52 <mmorrow> this is why the problem depends on the metric :)
12:19:56 <lilac> right, and that requires you to know which set of asm programs solve the problem
12:20:06 <lilac> and /that/ is not in general computable
12:20:13 <SamB> first you have to figure out what the problem is
12:20:24 <jmcarthur_work> lilac, is that proven?
12:20:45 <lilac> jmcarthur_work: suppose the problem says "the program must halt".
12:20:50 <SamB> but I will tell you that higher-level languages usually give the compiler more room to work in
12:20:53 <mmorrow> lilac: i'm assuming i can determine the minimal sequence of processor actions needed to perform the given task, and given that i can construct asm to trigger that sequence
12:21:06 <RayNbow> > filterM (const [False,True]) [1..3]
12:21:06 <jmcarthur_work> lilac, actually, that's not the proof i'm looking for
12:21:07 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
12:21:10 <SamB> mmorrow: halting problem
12:21:13 <RayNbow> > filterM (const [True,False]) [1..3]
12:21:14 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:21:24 <mmorrow> SamB: why?
12:21:26 <lilac> jmcarthur_work: your jedi mind tricks won't work on me!
12:21:31 * RayNbow wonders which version would be preferred as the definition of powerset
12:21:48 <SamB> mmorrow: I can give you a task that doesn't do much except either loop forever or halt
12:21:54 <SamB> you have to figure out which!
12:21:56 <lilac> jmcarthur_work: but seriously, what aspect of it are you questioning? :)
12:22:10 <jmcarthur_work> lilac, if we rephrase this as "can we find a set of transformations on some program which solves the problem to generate all other possible programs that solve the problem?"
12:22:11 <mmorrow> , [$bf|.+[.+]|] "" {- optimal -}
12:22:13 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
12:22:20 <SamB> because surely the most efficient way to halt is to halt immediately?
12:22:40 <mmorrow> sure, there may be problems where you can't determine the optimal solution, but who cares about those
12:23:02 <pikhq> But that's not what you're talking about.
12:23:13 <pikhq> You're talking about a provably optimal optimiser.
12:23:23 <SamB> mmorrow: I'm pretty sure there's no way to just cut out the halting problem but leave everything else!
12:24:03 <mmorrow> ah, i suppose what i'm talking about is (Problem -> Processor -> Maybe OptimalAsm)
12:24:04 <lilac> jmcarthur_work: suppose the set of programs equivalent to a given program were recursively enumerable. then one could write a program which searched through all non-halting programs for a given program, and halt iff that program did not halt
12:24:20 <mmorrow> not (Asm -> Processor -> Maybe OptimalAsm)
12:24:39 <lilac> jmcarthur_work: then one could run that and the program in parallel, and determine whether or not the program halted.
12:25:01 <mmorrow> SamB: surely the problem of adding two numbers is easy, no?
12:25:18 <mmorrow> addq
12:25:27 <mmorrow> similar, multiplication
12:25:28 <mmorrow> etc
12:25:40 <SamB> mmorrow: okay, so you're saying you want to make a provably-optimal-for-some-subset-of-problems compiler?
12:25:42 <lilac> jmcarthur_work: that assumes that "machine does not halt" is a valid problem description :-)
12:25:58 <SamB> lilac: it is
12:26:10 <SamB> it performs a function
12:26:16 <mmorrow> SamB: something like that i guess, but i also realized that i'm talking about a program constructor, not an optimizer/compiler
12:26:40 <mmorrow> because given some source code, you don't even know what the problem is
12:26:45 <lilac> if we restrict what we mean by 'problem description' i think the task is possible, but i think we need to restrict it /a lot/
12:26:47 <SamB> mmorrow: those are the same things
12:26:57 <mmorrow> well, perhaps you could reduce it to some basis
12:27:10 <mmorrow> like (+), (*), etc... which is what generating asm is i guess
12:27:16 <SamB> any "problem description" is going to end up just being a program
12:27:32 <mmorrow> true, so then i am talking exactly ewhat you said
12:27:45 <mmorrow> "a provably-optimal-for-some-subset-of-problems compiler"
12:27:59 <mmorrow> the subset for which i can determine a solution
12:28:27 <Berengal> How do you determine if you can determine a solution or not?
12:28:28 <mmorrow> Code -> Maybe OptimalAsm
12:28:48 <mmorrow> Berengal: consider the program "1 + 1"
12:28:52 <mmorrow> i can do that one
12:28:57 <lilac> a provably-optimal-for-the-set-of-programs-generated-by-a-specific-set-of-transformations compiler might be feasible
12:29:11 <jmcarthur_work> lilac, yes, that is what i'm looking for
12:29:12 <mmorrow> and similarly, i can build from some basis of known/undisputed optimal soutions
12:29:20 <Berengal> mmorrow: But can you decide that you can or cannot do it for any program?
12:29:24 <SamB> Berengal: probably you end up being a bit pessimistic?
12:29:26 <pikhq> Okay, so you are dealing with a certain set of code that can be implemented on a FSA.
12:29:37 <pikhq> Perhaps even a push-down automaton, for the sake of simplicity
12:29:38 <lilac> jmcarthur_work: i think it depends on what the transformations are, and if you can bound the search tree in some way
12:29:45 <mmorrow> Berengal: no, but that's uninteresting because it's surely impossible
12:30:23 <Berengal> Okay, given a program you can optimize the parts of it you understand and echo the rest
12:30:39 <lilac> jmcarthur_work: suppose you have two transformations. one halves the size of an even-sized program, the other increases the size of an odd-sized program to 3*size+1.
12:30:46 <SamB> Berengal: I don't think that's at all clear
12:30:51 <lilac> jmcarthur_work: can you reduce any program to a program of size 1? ;-)
12:31:05 <Berengal> SamB: Pattern-matching on the AST?
12:31:11 <jmcarthur_work> lilac, heh, that's a good one
12:31:17 <mmorrow> sure, that's a solution, but suppose given any sequence of asm instructions and the processor they're for, you can reduce that sequence to an optimal sequence
12:31:26 <mmorrow> i think that's possible (?)
12:31:40 <mmorrow> the problem comes in though
12:31:45 <SamB> Berengal: well, how do you know that there isn't a better way that practically eliminates that part, but can't anymore with your "optimized" version?
12:31:52 <lilac> jmcarthur_work: on the plus side, if you can, i can give you a total algorithm which does :)
12:32:04 <lilac> jmcarthur_work: but the same can be said of solving an NP-complete problem in polynomial time
12:32:05 <Berengal> SamB: instance Monad [] where... ;)
12:32:07 <SamB> mmorrow: what do you mean by a sequence?
12:32:09 <mmorrow> when you can reduce N sequences to minimal sequences, but the combined sequence of minimal sequences no longer is minimal
12:32:26 <mmorrow> [mov,xor,sub,inc,....,ret]
12:32:55 <jmcarthur_work> lilac, but this is assuming those are the only possible transformations. we could choose an easier set of transformations, perhaps
12:33:17 <jmcarthur_work> lilac, although that may not be enough to come up with a perfectly optimal program in the end, depending what transformation we come up with
12:33:25 <jmcarthur_work> *transformations
12:39:12 <mmorrow> <Berengal> mmorrow: But can you decide that you can or cannot do it for any program?
12:39:43 <mmorrow> Berengal: i'm interested in "yes" being not a false positive
12:40:04 <mmorrow> moreso than i am in "no" not being a false negative
12:40:20 <mmorrow> *.. "yes" not being...
12:40:41 <Berengal> mmorrow: That requires something like a timeout I think...
12:40:54 <mmorrow> Berengal: sure, however you want to implement that
12:41:00 <FunctorSalad> <mmorrow> Berengal: consider the program "1 + 1" <--- I'm not sure how relevant this is, but "given a program, does this program compute the constant n function" is uncecidable too (halting prob again)
12:41:07 <mmorrow> trivially, ==> const "no"
12:41:27 <mmorrow> FunctorSalad: the program's code is "1 + 1"
12:41:36 <mmorrow> that is all the info you get
12:41:47 <FunctorSalad> what are you optimising?
12:41:51 <mmorrow> time
12:41:56 <mmorrow> processor time
12:42:18 <Berengal> Without introducing additional resource useage elsewhere?
12:42:22 <mmorrow> (is my particular choice of criterion here)
12:42:47 <mmorrow> Berengal: i'm only considering "processor time" in a bubble, but sure
12:43:12 <mmorrow> i think the point is that it doesn't matter what the metric is, just that you have a unambiguously defined one
12:43:17 <Berengal> Seems the most interesting to me anyway
12:43:29 <mmorrow> mine is "processor time in clock cycles"
12:43:29 <hackagebot> leksah 0.6.1 - Haskell IDE written in Haskell (JuergenNicklischFranken)
12:43:40 <Berengal> Oooh, leksah!
12:44:14 <jmcarthur_work> yeah it version bumped to 0.6.0 yesterday i think
12:44:34 <jmcarthur_work> maybe day before
12:44:38 <Berengal> Yeah, I just tested the 0.6.0_b or something the other day
12:44:49 <mmorrow> how is it?
12:44:51 <Berengal> HEAD anyway
12:44:55 <Berengal> It's pretty decent
12:45:05 <mmorrow> cool
12:45:10 <Berengal> Supports the ghci debugger now
12:46:43 <lilac> mmorrow: do you know the program's input?
12:47:45 * lilac was assuming not
12:48:47 <mmorrow> lilac: in a program that takes input, it'd either be the case that you know that for any input the code you produce is optimal, or that its optimality depends on the input, or that you just don't know. in the second case, you'd need to qualify your statement with "for input such that ... this is optimal", and possibly get an input description from the user. for the 3rd case, you're screwed. for the first case you're happy.
12:48:49 <sm> on mac, the leksah .dmg is excellent
12:49:11 <sm> most stuff works
12:49:28 <lilac> mmorrow: if the size of the input is bounded, then it's certainly computable whether a program is optimal
12:49:46 <mmorrow> lilac: i think the case of generating FFTs is a good one here. usually, you also input the size of the input.
12:50:13 <FunctorSalad> lilac: lookup table?
12:50:19 <mmorrow> lilac: imagine though an FFT program that takes an infinite stream of input, in chunks of 64 elements at a time..
12:50:19 <lilac> mmorrow: if you want branch-free code, then again it's possible
12:50:37 <lilac> FunctorSalad: hehe, yeah. i'm imagining a bound on code size would be called for, though ;-)
12:51:44 <lilac> mmorrow: ok. as FunctorSalad points out, the optimal program for that would probably simply be a table lookup (assuming you can create a table that big)
12:52:11 <lilac> so i think you need to optimize for something more than just speed, or otherwise rule out such "solutions"
12:52:18 <mmorrow> well, by that same logic you can easily exhaustively test programs
12:52:43 <mmorrow> lilac: ah, ok i agree.
12:53:32 <ari> Hi. I'm trying to use hscurses on a new system. It works fine when compiled but ghci doesn't know how to deal with my /usr/lib/libncurses.so, which consists of the text "INPUT (-lncursesw)" - ghci complains of the file being too small. I tried replacing it with a symlink to libncursesw.so but that only causes ghci to segfault. Any ideas how to work this out so I can keep using ghci?
12:53:33 <mmorrow> lilac: "processor time in clock cycles and code size in bytes", where you're given a pair of weights that sum to one telling you how much to favor each one (maybe)
12:53:53 <sm> and since it's not so easy to find: http://leksah.org/Leksah.dmg
12:54:08 <lilac> mmorrow: so long as you can apply dominance to rule out all programs over a given size and all programs over a given runtime, that'd work fine
12:54:12 <FunctorSalad> minimal code size given a specified semantics is undecidable, mmorrow
12:54:23 <mmorrow> lilac: well, i'm not so sure though. because since we're assuming knowledge of the processor, let's assume knowledge of the size of ram as well.
12:54:28 <FunctorSalad> IIRC
12:54:42 <lilac> FunctorSalad: not if the set of inputs is finite and you have a runtime bound for acceptance
12:55:00 <FunctorSalad> lilac: I think even with no inputs
12:55:05 <mmorrow> FunctorSalad: given processor X and N bytes of ram, i want to minimize processor clock cycles.
12:55:27 <mmorrow> FunctorSalad: if your lookup table in < N bytes, it may turn out to be optimal
12:55:27 <FunctorSalad> mmorrow: yes, that was just in response to the "weighting between time and code size"
12:55:29 <lilac> FunctorSalad: if you have a runtime bound, just run each program until it hits the bound. pick the fastest one which did the right thing
12:55:36 <mmorrow> FunctorSalad: yeah, i retract that idea :)
12:56:03 <FunctorSalad> lilac: well ok, with a time bound, yes
12:56:27 <lilac> for that to apply, you also need a finite set of inputs to try
12:56:29 <mmorrow> FunctorSalad: well, i'm not so sure though. i think it depends on how we fill in the ambiguity here. suppose you say that:
12:57:13 <mmorrow> metric pgm1 pg = codeSize pgm 1 / procTime pgm1 ASDFASDF
12:57:21 <mmorrow> point being
12:57:40 <mmorrow> you define some formula to map a programs size+proc_cycles to R
12:58:02 <mmorrow> i bet then you could optimize for both dimensions, given a weight for each
12:58:44 <lilac> > fix (return . fix) 42
12:58:49 <lambdabot>   mueval-core: Prelude.read: no parse
12:58:50 <lambdabot>  mueval: ExitFailure 1
13:01:03 <FunctorSalad> anyway, I have a feeling that this would have horrendous complexity even if it turns out to be computable in some formulation ;)
13:01:38 <FunctorSalad> for practical purposes approximations would be more interesting I suppose
13:13:06 <mmorrow> FunctorSalad: i think the challenge is to find a formulation in which you can do what you need to do
13:14:31 <mmorrow> "what you need to do" and "formulation" being context dependent, but unambiguously defined given a/that context
13:15:42 <hackagebot> HaskellForMaths 0.1.6 -  (DavidAmos)
13:17:45 <ac> oooo, I just installed vital
13:17:49 <ac> anybody played with it?
13:18:02 <ac> it looks pretty slick
13:24:18 <copumpkin> http://www.haskell.org/all_about_monads/html/laws.html#nowayout feels weird
13:24:27 <copumpkin> the way it talks about "one-way monads" and such
13:24:54 <opqdonut> doesn't seem strange to me
13:25:08 <copumpkin> I guess I just wouldn't word it that way
13:25:49 <opqdonut> yeah, "one-way" is a bit clumsy
13:26:14 <opqdonut> but it's pretty self-explanatory and easy to understand for the newbie
13:26:19 <copumpkin> it seems to imply that the one-way-ness is a choice the programmer can make when he "builds a monad", a bit like encapsulation
13:26:34 <copumpkin> rather than an inherent property
13:26:41 <copumpkin> but maybe I'm just reading it strangely
13:28:11 <ray> well, you can pattern match on value constructors sometimes
13:28:22 <copumpkin> yeah, none of it is incorrect
13:28:23 <ray> but if it's, say, IO, no way
13:28:42 <copumpkin> I mean things like ST, Identity allow you to "extract" values from it
13:29:04 <copumpkin> but phrasing it that way just feels wrong somehow :)
13:29:06 * copumpkin shrugs
13:29:41 <ray> yeah, i guess
13:30:04 <ray> if you could always get out, it'd be a comonad
13:31:36 <copumpkin> Copointed! :P
13:31:43 <ray> i want to reread that paper about an OI comonad
13:31:49 <ray> i can't remember anything else about it though
13:32:00 <Heffalump> I remember that it's completely unsafe
13:32:04 <Heffalump> (in Haskell)
13:32:05 <ray> i didn't get comonads at the time
13:32:08 <ray> it went over my head
13:32:15 <FunctorSalad> copumpkin: I think the point is that abstract monads are one-way
13:32:33 <copumpkin> FunctorSalad: yeah, I just think the wording on that page could do with some work
13:32:40 <FunctorSalad> (if you have an arbitrary monad, it could always be the trivial one)
13:34:15 <ray> not many things seem to be both monads and comonads
13:34:42 <copumpkin> Cofree Identity?
13:34:58 <copumpkin> maybe not
13:35:11 <FunctorSalad> @botsnack cofree
13:35:11 <lambdabot> :)
13:35:11 <lunabot>  :)
13:35:12 <dolio> Identity is both.
13:35:15 <copumpkin> yeah
13:35:26 <copumpkin> I guess Cofree Identity wouldn't be though
13:35:28 <FunctorSalad> @botsnack and caeks
13:35:28 <copumpkin> wouldn't be a monad that is
13:35:28 <lunabot>  :)
13:35:31 <lambdabot> :)
13:35:40 <copumpkin> @botsmack
13:35:41 <lambdabot> :)
13:35:41 <lunabot>  :)
13:35:48 <opqdonut> @botstack
13:35:49 <lambdabot> :)
13:35:49 <lunabot>  :)
13:35:53 <ray> @botsack
13:35:53 <lambdabot> :)
13:35:54 <lunabot>  :)
13:35:59 <copumpkin> @potsack
13:36:00 <lambdabot> :)
13:36:06 <opqdonut> hehe
13:36:09 <FunctorSalad> lol
13:36:18 <copumpkin> @hotsnack
13:36:19 <lambdabot> :)
13:36:25 * copumpkin is done
13:36:28 <ac> vital is totally awesome. When was this created?
13:36:32 <FunctorSalad> higher edit distance parameter?
13:36:41 <ac> is it a whole new reimplementation of Haskell in Java?
13:37:12 <opqdonut> ah vital is a mathematica-like ide for haskell
13:37:30 <FunctorSalad> ?? and IDE other than leksah?
13:37:30 <lambdabot> Plugin `compose' failed with: Unknown command: ""
13:37:37 <FunctorSalad> *an
13:37:40 <opqdonut> seems dead, "Updated April 05"
13:37:45 <FunctorSalad> :(
13:37:48 <ac> yeah, it's sweet. The demo in the "pictures and images" section is sick
13:37:59 <dolio> Oh, yeah, that.
13:38:05 <dolio> I always forget the name.
13:39:01 <dolio> Long dead. :)
13:39:07 <LeoD> @pl \f (a,b) -> (f a, f b)
13:39:07 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
13:39:44 <ac> dolio: what's long dead?
13:39:49 <opqdonut> vital
13:39:52 <dolio> Vital, as far as I can tell.
13:39:59 <ac> what's the deal with all these awesome Haskell projects that just get abandoned?
13:40:08 <opqdonut> *shrug*
13:40:28 <copumpkin> is there a generalization of mod to an arbtirary algebraic structure? if so, which one?
13:40:36 <ray> haskell is hard, so the authors go shopping
13:40:43 <copumpkin> I wish I had money to go shopping
13:41:02 <ac> ray: what do you mean, "go shopping"?
13:41:02 <FunctorSalad> copumpkin: mod as in modulo? yes! quotients
13:41:13 <ray> as in "math is hard, let's go shopping"
13:41:17 <copumpkin> quotient ring?
13:41:18 <opqdonut> copumpkin: mod as in modulo? you can divide any algebraic structure by a congruence that respects the operations
13:41:21 <FunctorSalad> (everywhere... in groups, rings, modules, algebras...)
13:41:34 <copumpkin> I guess it only needs division, eh
13:41:44 <copumpkin> hmm,
13:41:47 <opqdonut> not division in that sense
13:41:50 <ray> the bell of the division ring has begun
13:42:05 <opqdonut> divide in the sense of "divide into congruence classes"
13:42:06 <copumpkin> well, it seems like it's defined by a * b + c
13:42:15 <opqdonut> so you can divide a group by it's normal subgroup, a ring by it's ideal etc
13:43:00 <ac> hmm. I think that kind of IDE has a lot of potential
13:43:17 <dolio> I think he means mod the binary operator, more than modular arithmetic.
13:43:25 <FunctorSalad> the common theme is "images under a homomorphism"
13:43:37 <FunctorSalad> (for the quotients. the ideals/normal subgroups are teh kernels)
13:43:45 <opqdonut> indeed
13:43:48 <dhun> I finally implemented my first monad, it does  not do what I want, but it fractalizes IO in a funny way   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7370#a7370
13:44:13 <dolio> Modular arithmetic being what you get when you take a quotient with respect to the binary operator and some element.
13:44:14 <ac> I wonder why they didn't implement Vital with GHC
13:44:47 <FunctorSalad> dolio: hmm, you can make the congruence without the binary operator
13:44:47 <copumpkin> dhun: !
13:45:01 <FunctorSalad> you can just say "the congruence generated by 0 ~ n"
13:45:16 <dhun> compumpkin ?
13:45:25 <FunctorSalad> (= the ideal generated by n)
13:45:25 <ray> hompumpkin
13:45:38 <copumpkin> lol
13:45:41 <copumpkin> homopumpkin?
13:45:47 <ray> no, as in hom functor
13:45:52 <copumpkin> oh
13:46:05 <dolio> Can you take any quotient group and get some binary operator in the original group?
13:46:25 <dolio> I suppose you could, perhaps.
13:46:31 <dolio> Or, a unary operator.
13:46:45 <opqdonut> dhun: interesting, but the code is really obfuscated
13:47:13 <opqdonut> or just in bad style, i guess
13:47:35 <dolio> [a] takes a to the element you'd get by finding the equivalence class, and then injecting back into the original group.
13:47:40 <opqdonut> for example the "MyType { getMy = x }" could just be "MyType x"
13:47:56 <dolio> Then a `mod` b = [a]_modulo-b.
13:47:57 <opqdonut> and what's the purpose of ffmap and triv?
13:48:21 <dhun> I wanted to be sure about types for better error messages
13:48:31 <FunctorSalad> dolio: if there is a homomorphism that goes back from the quotient to the group or whatever, it's called a "split extension"
13:48:50 <FunctorSalad> in that case the original group is a semidirect product of the quotient and the kernel
13:48:51 <opqdonut> dhun: you could just use an inline type declaration
13:48:52 <opqdonut> but ok, i see
13:49:17 <FunctorSalad> (but (`mod` n) doesn't split)
13:49:44 <FunctorSalad> I mean, the map that sends [a] to the representative between 0 and n-1 is not a homo
13:50:04 <opqdonut> and wouldn't "main = getMy (MyType getLine >>= MyType . putStrLn >> MyType (putStrLn "3") )"
13:50:17 <opqdonut> be a better main since it demonstrates parametrized computation too
13:50:17 <FunctorSalad> I guess that's why the quotient is preferred in theory to the binary op
13:50:26 <opqdonut> and not just the applicative structure
13:51:46 <dolio> FunctorSalad: Because for, say, [a]+[a] = 0, inj([a]+[a]) = inj(0) = 0, but inj([a]) + inj([a]) /= 0? And so on?
13:51:54 <dolio> Er, [0].
13:51:59 <dolio> For some of those.
13:52:02 <opqdonut> dhun: i still don't see the point tho
13:52:09 <dhun> mybe you are right, my goal was to run IO operations in reversed order
13:52:10 <FunctorSalad> dolio: exactly
13:52:24 <dhun> and I failed
13:52:46 <dhun> but still the result look so funny to me, that I thought it was worth showing it
13:52:51 <opqdonut> dhun: i suggest starting with the state monad or something :)
13:53:00 <opqdonut> the reverse state monad is cool
13:53:53 <FunctorSalad> what's reverse about it?
13:54:00 <FunctorSalad> it starts with the final state? ;)
13:54:12 <dolio> State changes travel back to earlier expressions.
13:54:13 <opqdonut> yes
13:54:27 <opqdonut> http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
13:54:57 <dolio> 'do s <- get ; put 5 ; return s' returns 5, always.
13:54:58 <opqdonut> the implementation is straightforward knot tying
13:55:01 <opqdonut> but results are cool
13:55:01 <dhun> if seems that ffmap runs this IO action
13:55:07 <dhun> in x
13:57:14 <dhun> can I somehow get the a in IO a without running the IO action?
13:57:32 <Heffalump> dhun: no, because the a might depend on running the action
13:57:35 <Heffalump> e.g. getChar
13:57:48 <jmcarthur_work> dhun, no. IO a represents an action to be run and does not itself contain a value
13:58:28 <dhun> that leaves me with little hope for reversing IO
13:58:54 <jmcarthur_work> dhun, you can cheat by using unsafe functions to perform the action in "pure" code, but it's still performing the action
13:58:55 <Heffalump> well, no. How would you reverse getLine >>= putStrLn ?
13:58:57 <SamB> people have been trying to figure out how to undo IO for years ;-)
13:59:17 <copumpkin> Heffalump: output a bunch of backspace characters :P
13:59:25 <jmcarthur_work> dhun, and yeah, your goal of reversing IO won't work
13:59:37 <sebaseba> can't backspace missile launchers!
13:59:39 <SamB> copumpkin: eh?
13:59:58 <copumpkin> maybe we could have a small subset of IO that is reversible
14:00:06 <dhun> Ok but at least I learned something about monads
14:00:07 <copumpkin> can't think of much right now though
14:00:17 * SamB was thinking more like "help! I accidentally ran mkdosfs on my /home partition!"
14:01:16 <monochrom> Do not "how to take data out of IO". Do "how to insert my algorithm into IO". And the later is trivial:
14:01:32 <jmcarthur_work> fmap, <*>, =<<, etc.
14:01:46 <monochrom> main = do { x <- getInputFromWorld; let y = my_algorithm x; ... }
14:02:07 <monochrom> Then you can write your my_algorithm as a separate pure function elsewhere.
14:02:44 <monochrom> It's all about inversion of control. Don't call us, we'll call you.
14:04:06 <SamB> help!
14:04:14 <SamB> I have an "IO a"
14:04:20 <SamB> I want to get out the computation that's inside!
14:05:05 <pikhq> NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO NO.
14:05:05 <pikhq> Also, NO.
14:05:06 <copumpkin> @hoogle IO a -> a
14:05:06 <lambdabot> Foreign unsafePerformIO :: IO a -> a
14:05:06 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
14:05:06 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
14:05:07 <pikhq> ;)
14:05:07 * copumpkin whistles
14:05:13 <copumpkin> it wasn't me
14:05:16 <copumpkin> it was lambdabot!
14:05:34 <soupdragon> how about a more general  Monad m => m a -> a
14:05:42 * jmcarthur_work hates the phrase "inversion of control"
14:05:43 <soupdragon> @src Monad
14:05:43 <lambdabot> class  Monad m  where
14:05:43 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:05:43 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:05:43 <lambdabot>     return      :: a -> m a
14:05:43 <lambdabot>     fail        :: String -> m a
14:05:51 <soupdragon> there seems to be room in there
14:06:12 <jmcarthur_work> comonad!
14:06:23 <soupdragon> head, unsafePerformIO, fromJust ..?
14:06:25 <copumpkin> class (Functor m, Copointed m) => Monad m? :P
14:06:35 <jmcarthur_work> ugh
14:06:43 <SamB> I said I wanted the computation, not the returned value ;-P
14:06:46 <soupdragon> snd
14:06:56 <jmcarthur_work> i hate it when people define type class instances with partial functions
14:07:17 <copumpkin> @src div
14:07:17 <lambdabot> Source not found. My brain just exploded
14:07:19 <monochrom> jmcarthur_work: Sadly, it's the only phrase beginners understand for this kind of thing.
14:07:23 <copumpkin> :t div
14:07:24 <lambdabot> forall a. (Integral a) => a -> a -> a
14:07:34 <monochrom> Not just understand but also agree to.
14:07:38 <SamB> I forgot what we were inverting from
14:07:47 <SamB> which way did it used to go?
14:08:29 <monochrom> If you just say "you aren't supposed to take data out of IO", they think it's stupid, generally any "you aren't supposed to ___" is stupid. Programmers think they should have freedom.
14:08:31 <soupdragon> @instances Monad
14:08:31 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:08:56 <soupdragon> I guess I did all the interesting ones
14:09:02 <monochrom> But if you say "inversion of control", which is the same thing, suddenly they think it's smart, since that phrase has been marketted as smart.
14:09:03 <soupdragon> maybe  ($ undefined)
14:09:13 <dino-> It's dirty in there. Nobody knows where it's been. We don't want it to escape.
14:09:15 * FunctorSalad first thought soupdragon was being sarcastic and was suggesting adding head, unsafePerformIO and fromJust individually as methods of the monad class ("there is room in here")
14:09:20 <pikhq> monochrom: Beat programmers.
14:09:30 <dino-> And befoul our lovely other code.
14:10:50 <soupdragon> FunctorSalad: I'm going to suggest it for Haskelitor 2010
14:11:08 <hzap> Haskelitor?
14:11:13 <hzap> :D
14:11:17 <FunctorSalad> Haskelletor
14:11:18 <pikhq> :D
14:11:21 <ac> ray: I think the author of vital has actually moved on to another project
14:12:38 <azathoth99> what good about haskell over say ruby?
14:13:01 <soupdragon> azathoth99: is that a real question?
14:13:22 <sm> ac: agreed, vital is cool. Maybe it could be redone with gtk ?
14:13:23 <soupdragon> @keal
14:13:24 <lambdabot> my very first computer was an 80-0840
14:13:37 <hzap> sounds like a @protontorpedo-ism
14:13:37 <SamB> azathoth99: well, we have lambdas available at *all* argument positions
14:13:39 <SamB> and always have
14:13:55 <pikhq> azathoth99: Is pure. Pure is delicious.
14:14:13 <SamB> yeah, that's the main advantage haskell has over ... well, almost everything
14:14:17 <FunctorSalad> freedom from state
14:14:18 <SamB> that, and typeclasses
14:14:26 <pikhq> SamB: And monads.
14:14:28 <pikhq> And arrows.
14:14:30 <jmcarthur_work> azathoth99, pure, fast, parallel, high level, strong guarantees
14:14:38 <SamB> monads and arrows are just fads
14:14:38 <pikhq> (though C# has monads, sorta)
14:14:39 <hzap> @protontorpedo
14:14:39 <lambdabot> cmon Im asking cool questions
14:15:41 <dolio> Haskell isn't more about monads than most other languages could be, except for type classes.
14:15:53 <pikhq> azathoth99: By comparison with Haskell, Ruby is low-level. (in that Ruby kinda-sorta models the functioning of a machine)
14:16:06 <hzap> typeclasses are what makes monads so awesome to use, though.
14:16:17 <SamB> pikhq: a really, really unusual machine ;-)
14:16:19 <jmcarthur_work> pikhq, i was trying to word that! yours is better than what i was thinking of
14:16:23 <ac> sm: I think there's a lot of room for improvement and making it more complex so it can be used for general purpose programming
14:16:24 <pikhq> SamB: Well, yes.
14:16:49 <ac> sm: granted that would be a pretty ambitious project
14:24:11 <sebaseba> any good pointers on using Haskell in embedded systems?
14:24:57 <Elly> "don't"?
14:25:10 <sebaseba> why not?
14:25:15 <soupdragon> lol
14:25:18 <monochrom> There are 1 or 2 compilers for embedded systems.
14:25:20 <Elly> what do you mean by "embedded"?
14:25:54 <sebaseba> say, ARM
14:25:59 <sebaseba> not much memory
14:26:05 <sebaseba> lotsa peripherals
14:26:07 <Elly> are we talking like 16K, or like 16M?
14:26:09 <sebaseba> interrupts
14:26:31 <sebaseba> I know Haskell in 16K systems is impossible, let's say 16M
14:26:39 <sebaseba> or 4M
14:26:56 <Elly> hmm, I am afraid I have to defer to someone else for that
14:27:00 * Elly has never done embedded haskell
14:27:30 <cjb> sebaseba: jhc has more embedded support than ghc
14:27:40 <cjb> (for your ARM example)
14:27:41 <pikhq> Embedded systems are one of the few environments where C is the only choice. ;)
14:28:08 <pikhq> (assuming "embedded" means "PIC")
14:28:17 <Heffalump> sebaseba: one option is to write a DSEL in Haskell that compiles down to something for that system
14:28:28 <cjb> pikhq: that's not usually what it means these days
14:28:28 <azathoth99> so wait
14:28:29 <Heffalump> see e.g. Geoffrey Mainland's paper in ICFP 08
14:28:33 <sebaseba> Heffalump: you mean code generation?
14:28:34 <mike-burns> azathoth99: Haskell vs Ruby is a choice between having threads that work vs having threads that don't work.
14:28:36 <pikhq> cjb: Dumb.
14:28:36 <Heffalump> sebaseba: yes
14:28:37 <cjb> embedded seems to mean "something kinda of slow that isn't x86"
14:28:45 <azathoth99> I want my threads to work.
14:28:52 <mike-burns> azathoth99: Then avoid Ruby.
14:29:01 <azathoth99> what about common lisp vs haskell?
14:29:01 <pikhq> So, embedded means "about on par with my old PII box"? :P
14:29:08 <cjb> pikhq: yup!
14:29:15 <Heffalump> cjb: I've always taken it to mean things with a UI that is more restricted than a "standard" computer.
14:29:16 <cjb> (although that's x86)
14:29:17 <sebaseba> Heffalump: yes, I thought of that, would love to find links to work like that
14:29:22 <Heffalump> s/more restricted/substantially &/
14:29:23 <pikhq> azathoth99: Haskell's much nicer.
14:29:29 <azathoth99> wow really?
14:29:37 <CalJohn> azathoth99: common lisp is pretty outdated now
14:29:39 <pikhq> Though, Lisp offers significantly better metaprogramming support...
14:29:39 <Heffalump> sebaseba: let me know if my ICFP 08 reference isn't enough info. Also, read Lennart Augustsson's blog.
14:29:42 <CalJohn> azathoth99: i learnt CL as my first lang
14:29:43 <cjb> Heffalump: most people would classify an ARM SoC as embedded, and there's good gcc support there.
14:30:02 <hzap> azathoth99: what do you expect from #haskell? :)
14:30:08 <Heffalump> cjb: UI, as in user interface, i.e. something where it's not in a real computer
14:30:11 <mike-burns> Is there a good free-of-charge Common Lisp implementation?
14:30:15 <CalJohn> azathoth99: Schemer is much better, it's just the CL has a bit of a cult around it
14:30:19 <pikhq> CalJohn: sbcl
14:30:20 <CalJohn> mike-burns: yeah, there's about 4
14:30:23 <mike-burns> Okay.
14:30:25 <azathoth99> hm
14:30:40 <azathoth99> I look at happstack site and I can't make sense of thier docs.
14:30:44 <Heffalump> pikhq: I'm not sure I'd agree with that. Type classes give you a lot of metaprogramming power in a much more disciplined way, and TH gives you the undisciplined macro language, albeit in a more clunky way.
14:30:47 <sebaseba> Heffalump: which ICFP reference?
14:30:47 <azathoth99> does that stuff make sense to you gents?
14:30:48 <cjb> Heffalump: oh!  I misread computer as compiler.  right.
14:30:50 <LeoD> hm, i take it i can't put Maybes into MArrays?
14:30:58 <Heffalump> see e.g. Geoffrey Mainland's paper in ICFP 08
14:31:05 <sebaseba> ok, thanks
14:31:20 <jmcarthur_work> azathoth99, happstack is one of the most difficult to understand haskell libraries, i promise
14:31:26 <azathoth99> aw crap
14:31:28 <CalJohn> azathoth99: yeah, the concepts just take some learning.  I'm still doing it now.  it's worth it though
14:31:30 <jmcarthur_work> azathoth99, it's quite nice once you are familiar with the model
14:31:30 <sm> azathoth99: not really. Don't start with happstack, start with learnyouahaskell.org or realworldhaskell.org
14:31:34 <dino-> jmcarthur_work: I was wondering how to gently say that. Good work.
14:31:39 <azathoth99> ok
14:31:42 <pikhq> azathoth99: Haskell has a learning curve like a cliff.
14:31:56 <dino-> And happstack is like they just throw your ass out of the plane.
14:31:59 <jmcarthur_work> but free falling is fun!
14:32:03 <jmcarthur_work> oh wait, you meant climbing :P
14:32:12 <azathoth99> http://learnyouahaskell.com/
14:32:15 <azathoth99> you mean
14:32:29 <sm> yup
14:32:31 <jmcarthur_work> LYAH is reminiscent of _why
14:32:43 <pikhq>  It's not a matter of you slightly improve and eventually you get most everything. It's a matter of you achieving enlightenment, and suddenly everything makes sense. ;)
14:32:45 <hzap> LeoD: should be possible to...
14:32:47 <azathoth99> ok so i should feel discomfort when learning new stuff, hek I dont even know perl or c, just some bash lisp and tcl
14:32:47 <jmcarthur_work> RWH is more complete, maybe a bit harder reading, but barely
14:32:56 <azathoth99> and I mean a tiny bit
14:33:14 <azathoth99> hm
14:33:23 <azathoth99> I need some serious enlightenment.
14:33:33 <jmcarthur_work> that's exactly what haskell is best for :)
14:33:43 <CalJohn> jmcarthur_work: RWH is a _lot_ harder going for a beginner.  i've been there recently.
14:33:46 <mike-burns> azathoth99: Learning programming, for real, the first time is hard, no matter which language you use. I'm going to claim that Haskell is just slightly easier to learn as a first language than anything else.
14:34:02 <jmcarthur_work> CalJohn, are you sure it's RWH or is it just Haskell?
14:34:09 <pikhq> mike-burns: It's probably easiest as a first language, in fact.
14:34:11 <CalJohn> jmcarthur_work: no, it's the style of RWH
14:34:21 <McManiaC> i still dont get happstack =(
14:34:30 <McManiaC> + its eating the ram of my vserver :o
14:34:36 <mike-burns> pikhq: If you mean that it's easiest to learn Haskell without prior knowledge, then I agree.
14:34:37 <sm> azathoth99: also try http://books.google.com/books?id=olp7lAtpRX0C&dq=programming+in+haskell+hutton&printsec=frontcover&source=bn&hl=en&ei=toVnSp_sGYWcswOGwqWLBw&sa=X&oi=book_result&ct=result&resnum=4
14:34:44 <pikhq> mike-burns: That's what I mean.
14:34:45 <blackh> mike-burns: I can't confirm it from experience (since I came from years of imperative programming), but I agree with you.
14:35:02 <CalJohn> jmcarthur_work: long examples, being re-used through chapters (making it hard to skip a chapter you don't understand) and the times when the authors seriously gloss over things
14:35:14 <dino-> LYAH wasn't around when I was starting. One thing that helped me personally a lot was YAHT
14:35:24 <McManiaC> one of the best "first languages" is simple lisp imo
14:35:27 <CalJohn> jmcarthur_work: I am told RWH was supposed to be a second book, and I can somewhat see why
14:35:28 <monochrom> I can confirm because I set up a blank virtual machine in my mind to learn Haskell. Worked great. The gentle introduction made perfect sense.
14:35:49 <LeoD> i'm writing a tilemap editor for 2D rpgs, and i'm unsure which datatype to use to represent the tilemap.. :|
14:35:52 <dino-> And being here, being taught quite a bit by these people.
14:36:19 <dino-> http://en.wikibooks.org/wiki/Haskell/YAHT
14:37:22 <Heffalump> is it deliberate that the nightly GHC bindist snapshots don't have profiling libs?
14:37:36 <dino-> McManiaC: I like it though. The persistent storage stuff is very cool.
14:37:43 <dolio> LYAH isn't really that much like _why's guide to ruby.
14:38:00 <dolio> LYAH is a pretty normal tutorial with some quirky pictures on the page.
14:38:26 <McManiaC> dino-: i never really got into it, so im not the person who could judge :)
14:38:45 <hzap> all ruby tutorials seem to have really funky stuff put in random places
14:39:12 <McManiaC> ^^
14:39:21 <McManiaC> why are you learning ruby when you got haskell :D
14:39:24 <Vanadium> hzap: In a lot of cases, the funky stuff is the ruby code, though
14:39:38 <hzap> McManiaC: that was a while ago
14:39:45 <McManiaC> k
14:39:48 <McManiaC> ^^
14:39:55 <jmcarthur_work> dolio, yeah, LYAH is much easier to read than _why stuff, for sure, because it doesn't have a bunch of quirky jokes everywhere
14:39:58 <hzap> Vanadium: lol
14:40:13 <pikhq> Just a nice drawing of General Specific.
14:40:16 <jmcarthur_work> LYAH is (rightly) faster paced, too
14:40:20 <McManiaC> i did a ruby project a while ago (after i learned haskell) and i wrote the extact same way in ruby as i did in haskell :)
14:40:22 <Vanadium> jmcarthur_work: lyah actually explains concepts instead of using ridiculous analogies :\
14:40:31 <jmcarthur_work> yup
14:40:32 <mike-burns> _why's Ruby tutorial is fun to read even if you know the language, tohugh.
14:40:35 <pikhq> BON
14:40:39 <pikhq> Er.
14:40:53 <Botje> no BONUS in sight. :)
14:40:59 <pikhq> Yup.
14:41:12 <hzap> not just ruby tutorials, but more like anything ruby (even in discussion on metaclasses)
14:41:26 <SamB> hzap: one would sort of expect that
14:41:41 <McManiaC> mike-burns: link?
14:41:43 <SamB> metaclasses tend to have random and weird aspects ;-P
14:41:55 <hzap> SamB: i guess :D
14:42:04 <mike-burns> McManiaC: Off-topic for #haskell, but http://poignantguide.net/ruby/
14:42:31 <hzap> when was LYAH written?
14:43:48 <blackh> hzap: About six months ago. About.
14:44:10 <hzap> ah, so it's quite recent stuff
14:44:23 <LeoD> i can't find any docs about IOArray with boxed values, only with unboxed values :o
14:44:54 <hzap> LeoD: it's just MArray
14:44:59 <SamB> LeoD: the difference is the same as Array vs UArray
14:45:42 <LeoD> so i can put eg Maybe values in an IOArray with boxed values?
14:46:48 <monochrom> Yes!
14:46:50 <hzap> LeoD: IOArrays can contain any type
14:46:55 <LeoD> yay!
14:47:22 <hzap> LeoD: were you trying to use IOUArray in your earlier comment on "can't put Maybe in MArray"?
14:48:28 <LeoD> hzap: well i was reading the docs (for IOUArray), and there it said "only certain elements are supported: see ... for a list of instances"
14:48:51 <LeoD> the whole thing was a bit confusing as there are no docs for IOArray
14:49:07 <SamB> I guess they didn't realize that it wasn't obvious ;-)
14:49:13 <SamB> you want to write some?
14:49:24 <hzap> there isn't much to write
14:49:27 <LeoD> not sure i'm qualified for that ;)
14:49:39 <hzap> the API is in MArray, which does have docs
14:49:41 <SamB> I think you're certainly qualified to write
14:49:50 <SamB> not necessarily to approve
14:49:54 <LeoD> heh, true
14:50:19 <SamB> getting them wrong would at least tell us what you were looking for ;-)
14:50:31 <LeoD> hah
14:51:41 <monochrom> Yeah the doc is in Data.Array.MArray
14:51:55 <hzap> IOArray (IOArray) -- this is the only line in the Data.Array.IO docs for boxed arrays
14:52:06 <hzap> potentially confusing indeed
14:53:55 <LeoD> oh, i didn't even see that line; the "IO arrays with boxed elements" section is empty for me. guess i'm reading outdated docs here
14:54:57 <hzap> maybe it should say something that clearly points out that all the operations are available in MArray
14:56:25 <yrlnry> Am I here?
14:56:36 <yrlnry> @?
14:56:43 <jmelesky> no. you're elsewhere
14:56:57 <yrlnry> Thanks!
14:57:12 <Phillemann> Parsec: How do I parse something zero or one time?
14:58:07 <yrlnry> @djinn a -> a
14:58:07 <lambdabot> f a = a
14:58:24 <yrlnry> @djinn [t -> a] -> t -> [a]
14:58:24 <lambdabot> Error: Undefined type []
14:58:30 <yrlnry> Beh.
14:58:37 <monochrom> @yrlnry
14:58:37 <lambdabot> Unknown command, try @list
14:59:12 <monochrom> Phillemann: something called "option" or "optional".
15:00:02 <Phillemann> monochrom: Ah, I overlooked that in the docs. Thanks.
15:00:51 <azathoth99> haskell
15:00:54 <azathoth99> ok ill learn it
15:00:57 <azathoth99> then do startup
15:00:59 <azathoth99> then get rich
15:01:01 <copumpkin> lol
15:01:01 <azathoth99> then get girl
15:01:05 <azathoth99> girls hat eme now
15:01:07 <azathoth99> me
15:01:10 <azathoth99> I love boobs
15:01:11 <azathoth99> bye
15:01:11 <LeoD> sounds like a plan
15:01:20 <desp> Uh.
15:01:22 <copumpkin> o.O
15:01:30 <copumpkin> we get weird trolls
15:01:58 <pikhq> I'm not sure if that was a troll or the single most stupid person I have seen this year.
15:01:59 <blackh> Speaking of getting the girl, my wife keeps busting me for all my unsafePerformIOs (since I told her what they are).
15:02:10 <desp> :)
15:02:13 <LeoD> haha
15:02:14 <pikhq> blackh: Hahah.
15:04:31 <Vulpyne> Hide "itsNotUnsafePerformIOISwear = unsafePerformIO" somewhere in a module. :)
15:04:45 <pikhq> safePerformIO?
15:04:51 <Vanadium> runIO
15:04:55 <Vanadium> fromIO
15:05:00 <yrlnry> @pf \x -> x
15:05:00 <blackh> thereIsNoCauseForAlarmIO
15:05:00 <lambdabot> Maybe you meant: bf pl
15:05:01 <trofi_> notAnIOAtAll
15:05:07 <yrlnry> @pl \x -> x
15:05:08 <lambdabot> id
15:05:10 <Saizan> pikhq: i like the "this year" part
15:05:18 <yrlnry> @pl \fs x = [ f x | f <- fs ]
15:05:18 <lambdabot> (line 1, column 7):
15:05:18 <lambdabot> unexpected "="
15:05:18 <lambdabot> expecting pattern or "->"
15:05:22 <Vanadium> oldMacDonaldsHadAFarmEIEIO
15:05:23 <pikhq> Saizan: I've seen some very stupid people.
15:05:25 <yrlnry> @pl \fs x -> [ f x | f <- fs ]
15:05:25 <lambdabot> flip flip [] . ((:) .) . flip ((<-) . (| f) . f)
15:05:30 <yrlnry> wowzers.
15:05:36 <pikhq> Some of them, I'm related to.
15:05:38 <yrlnry> Oh, it doesn't understand |.
15:05:42 <yrlnry> Nor <-.  Okay.
15:05:55 <Botje> thisIsNotTheIOYou'reLookingFor
15:06:19 <pikhq> @pl \fs x -> map f fs
15:06:19 <lambdabot> const . map f
15:06:26 <yrlnry> @pl \fs x -> map (\f -> f x) fs
15:06:26 <lambdabot> flip (map . flip id)
15:06:42 <pikhq> Erm. XD
15:08:02 <yrlnry> What parentheses does haskell infer in map . flip id?
15:08:08 <araujo> Happy Pi Approximation Day!
15:08:11 <monochrom> class OlegIterateeInterface e ie m where ... {- e is element type, ie is iteratee type, m is your monad -}
15:08:31 <yrlnry> Oh, it's map . (flip id).
15:08:37 <yrlnry> flip id is bizarre
15:08:44 <monochrom> instance OlegIterateeInterface e ie IO where ... {- and the IO monad works -}
15:09:04 <pikhq> @type flip id
15:09:05 <lambdabot> forall b c. b -> (b -> c) -> c
15:09:12 <aavogt> @type flip ($)
15:09:13 <lambdabot> forall b b1. b -> (b -> b1) -> b1
15:09:43 <pikhq> > flip id $ x (y z)
15:09:44 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
15:10:59 <LeoD> > flip id $ x f
15:11:00 <lambdabot>   Couldn't match expected type `a1 -> a'
15:11:37 <pikhq> @quickcheck (\x -> (flip id $ x) == (flip ($) x))
15:11:38 <lambdabot> Unknown command, try @list
15:11:44 <pikhq> @check (\x -> (flip id $ x) == (flip ($) x))
15:11:45 <lambdabot>   No instance for (GHC.Classes.Eq ((a -> b) -> b))
15:11:46 <lambdabot>    arising from a use of `...
15:11:51 <pikhq> Bah.
15:12:53 <LeoD> > (flip id) x f :: Expr
15:12:55 <lambdabot>   f x
15:13:55 <pikhq> That is very weird.
15:15:14 <aavogt> > 22 / 7
15:15:15 <lambdabot>   3.142857142857143
15:15:30 <monochrom> because "flip id" can become "flip ($)"
15:15:45 <aavogt> @src ($)
15:15:45 <lambdabot> f $ x = f x
15:15:50 <aavogt> @src id
15:15:50 <lambdabot> id x = x
15:15:59 <pikhq> See? Very weird.
15:16:14 <LeoD> seems a bit weird to me how you can apply id to flip, even though flip takes an (a -> b -> c) as the first parameter
15:16:15 <aavogt> @pl \f x -> f $ x
15:16:16 <lambdabot> id
15:16:45 <LeoD> wait hm
15:16:49 <yitz> id can be specialized to (a -> b) -> a -> b
15:17:01 <LeoD> i see now
15:17:09 <aavogt> @type flip
15:17:10 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:17:13 <pikhq> LeoD: id is (a -> b). (a->b) is a valid type.
15:17:13 <pikhq> :)
15:17:17 <LeoD> yeah, got it :)
15:36:09 <Vulpyne> There does not seem to be any Haskell stuff for doing XSD validation of XML documents. This makes me sad.
15:36:47 <QtPlaty[HireMe]> Vulpyne: Do you think you could do it?
15:37:26 <Vulpyne> I probably could, but I don't have sufficient motivation/time. :(
15:37:51 <Vulpyne> Using an XSD would be nicer, but I'll probably just make something for simpler validation.
15:38:40 <QtPlaty[HireMe]> Vulpyne: Make something simpler for simple validation.  Then slowly extend it do something that could be used as a backend for XSD?
15:39:22 <Vulpyne> I think that may be hard. The way I'm currently parsing this document is with TagSoup.Parsec which is very nice for the structural part.
15:39:55 <Vulpyne> XSD is fairly complicated, and probably more complicated than what I'll actually use here.
15:40:26 <Vulpyne> I do have an XSD specification, so it would be nice to keep the two things in sync, but not nice enough to write a project of that size.
15:40:51 * QtPlaty[HireMe] nods
15:40:59 <Vulpyne> And I am very, very lazy. :)
15:41:14 <monochrom> XSD is unrelated to XSLT, right?
15:41:39 <LeoD> is there a list function which replaces a value at a given index of the list?
15:41:40 <lilac> XSD is like a dead smiley with a weird nose
15:42:01 <Vulpyne> I wasn't really familiar with XSLT, but a cursory search makes it seem like something for converting between formats.
15:42:08 <monochrom> @slit lilac
15:42:09 <lambdabot> Maybe you meant: elite let list quit slap
15:42:22 <Vulpyne> And XSD is more for validations. You define the types of things, and the values an enumeration could contain, and stuff can also match with regexps.
15:42:45 <Vulpyne> http://www.w3schools.com/Schema/default.asp - That page has a simple example.
15:42:46 <lilac> LeoD: no, but if you're doing that a lot, perhaps a list isn't the best data structure? :)
15:42:53 * QtPlaty[HireMe] nods
15:43:50 <monochrom> Or perhaps "replacing" isn't the best algorithm structure.
15:43:57 <LeoD> lilac: i'm not sure if it is
15:44:09 <lilac> @type let replaceAt n x = uncurry (++) . second ((x:).tail) . splitAt n in replaceAt
15:44:10 <lambdabot> forall a. Int -> a -> [a] -> [a]
15:44:12 <lilac> LeoD: IntMap?
15:44:32 <lilac> > let replaceAt n x = uncurry (++) . second ((x:).tail) . splitAt n in replaceAt 3 'b' "Hello"
15:44:33 <lambdabot>   "Helbo"
15:44:54 <LeoD> well, IntMap will probably be a better idea
15:45:06 <Vulpyne> ByteString?
15:45:12 <Vulpyne> If it's a string.
15:45:21 <LeoD> it isn't :p
15:47:48 <LeoD> i'm using the list to represent layers in my tilemap editor. there's a fixed number of layers (like background, foreground etc.)
15:48:49 <Vulpyne> If it's a small number, and you know it'll remain fixed, you could always use a tuple.
15:49:05 <LeoD> well i'd like to be able to index it dynamically
15:49:33 <monochrom> tilemap editing is better off as a mutable array.
15:49:44 <LeoD> yes, each layer has its own IOArray
15:49:48 <Vulpyne> You still could, it just might be horrible. :)
15:49:54 <LeoD> heh :p
15:50:30 <LeoD> well now i've gotta decide between tuples, IntMaps and lists
15:50:49 <monochrom> If you list is like just 10 elements long, I guess it's fine talking of "replacing".
15:51:09 <lilac> or if you're replacing near the start most of the time :)
15:51:26 <LeoD> ok, i'll probably only have 4 layers, so i'll go with lists then
15:51:55 <monochrom> I would use an array just because less code needs written. Array of 4 isn't a sin.
15:52:12 <LeoD> hm, what kind of array?
15:52:32 <monochrom> And moreover array of 4 IOArrays is so cool.
15:52:39 <copumpkin> lol
15:52:41 <LeoD> heh :P
15:52:46 <Vulpyne> modTuple tup i v = (case i of { 0 -> (\(_,y,z) -> (v,y,z)); 1 -> (\(x,_,z) -> (x,v,z)); 2 -> (\(x,y,_) -> (x,y,v)) }) t
15:53:11 <LeoD> hehehe
15:53:15 <copumpkin> Vulpyne: that forces all the elements to be the same type
15:53:28 <LeoD> that's fine actually
15:53:33 <Vulpyne> Well, if it was going to be a list or array of layers, that would already be true.
15:53:34 <LeoD> at least in my case
15:53:43 <copumpkin> fair enough :)
15:53:53 <monochrom> For the 4 layers, since 4 is so small, it's up to you to use immutable or mutable array.
15:53:55 <Vulpyne> It is pretty horrible though. The goggles, they do nothing.
15:54:25 <LeoD> i think i'll go with an immutable array then
15:54:26 <copumpkin> data FourLayers = FourLayers ... ... ... ...
15:54:34 <copumpkin> and a record
15:54:47 <Vulpyne> Isn't FourLayers basically just another way to say "tuple"?
15:54:51 <copumpkin> yup
15:55:03 <copumpkin> but you can express most things with tuples and either
15:55:04 <LeoD> copumpkin: i want to avoid having too much work when changing the number of layers
15:55:32 <Vulpyne> A more dynamic data type would be better then.
15:55:51 <LeoD> aye
16:06:40 <maxote> Earthquake at Washington, District of Columbia, this Thursday, soon, after of storms and thunders. Rev 16:18
16:09:11 <copumpkin> o.O
16:09:31 <vav> maxote: all of us here on irc have the mark of the www (vav vav vav / 666) beast
16:10:20 <copumpkin> did someone really just quote the bible as predicting a natural disaster in #haskell? that seems strange on so many levels
16:10:38 <LeoD> @pl \t -> (ix, t)
16:10:38 <lambdabot> (,) ix
16:10:45 <LeoD> .. oh
16:10:50 <copumpkin> (ix,) :P
16:10:54 <copumpkin> if BSP's patch gets in
16:11:00 <vav> copumpkin: sorry, I really tried not to respond, but couldn't help it
16:11:02 <LeoD> that'd be neat
16:11:14 <copumpkin> vav: oh I was responding to his original message anyway :)
16:11:39 <copumpkin> or reacting to it, at least
16:12:25 <aavogt> copumpkin: is BSP's patch going to be enabled by default, or will there be some -XReallyLongDescriptionOfTupleSections that has to be used?
16:12:41 <copumpkin> aavogt: there was talk about putting tuple sections into haskell'10
16:12:44 <aavogt> assuming that it is accepted
16:12:47 <copumpkin> but who knows :)
16:12:48 <vav> copumpkin: at least it's not one of those intersperse "\n" . words trolls
16:12:51 <LeoD> was there any reason not to allow (ix,) to begin with?
16:12:51 <Twey> So how flexible are these tuple sections?
16:12:52 <copumpkin> people seem pretty enthusiastic about it
16:13:02 <copumpkin> Twey: as flexible as you could dream of
16:13:09 <Twey> Can we (foo,,bar) baz ?
16:13:13 <copumpkin> Twey: they work for boxed and unboxed tuples, of any size, and do what you'd expect
16:13:13 <copumpkin> yeah
16:13:17 <Twey> Awesome.
16:13:22 <copumpkin> you can do (,,3,,,,1,5,)
16:13:27 <copumpkin> and have it give you a massive function
16:13:38 <Twey> Excellent :-D
16:14:09 <Twey> We really ought to have a more general way of defining multifix operators
16:14:26 <copumpkin> adopt the agda convention?
16:14:34 <copumpkin> well, not convention, but system
16:14:36 <Twey> What's the Agda convention?
16:14:52 <copumpkin> if_then_else_ :: Bool -> a -> a -> a
16:14:53 <MyCatVerbs> Twey: big room full of programming language geeks, focussed on one in particular.
16:14:58 <MyCatVerbs> Sorry, easy target. :D
16:15:03 <Twey> MyCatVerbs: Hahaha :-P
16:15:14 <Twey> copumpkin: And the definition?
16:15:23 <Twey> if a then b else c = ... ?
16:15:26 <copumpkin> Twey: a function that takes three arguments (as many as there are underscores)
16:15:46 <pikhq> if_then_else a b c = if a then b else c
16:15:54 <Twey> Oh right
16:15:54 <copumpkin> oh right :)
16:16:05 <Twey> That works
16:16:10 <aavogt> which means no more underscores in the rest of the language?!
16:16:11 <Twey> But looks lexically terrifying :-P
16:16:15 <pikhq> Heheh.
16:16:23 <copumpkin> aavogt: yup
16:16:29 <Twey> I guess it would be okay if we limited it to operators
16:16:38 <copumpkin> if_then_else_ : {a : Set} → Bool → a → a → a
16:16:38 <copumpkin> if true  then t else f = t
16:16:38 <copumpkin> if false then t else f = f
16:16:50 <copumpkin> the LHS being a pattern
16:17:10 <Twey> *nod*
16:18:34 <aavogt> Twey: so the terrifying part is when people mix the if_then_else_, and also define if, then, and else independently?
16:19:02 <Twey> aavogt: No, the terrifying part is trying to read a bunch of these interspersed
16:19:19 <Twey> foo bar baz quux quog flob arthur
16:19:29 <Twey> Guess which matches which!
16:19:31 <pikhq> We should just replace it all with case statements.
16:19:38 <Twey> pikhq: Haha
16:19:43 <pikhq> Pattern matching, too.
16:20:25 <aavogt> @faq Can Haskell implement 'do' notation as a library?
16:20:26 <lambdabot> The answer is: Yes! Haskell can do that.
16:20:27 <Twey> I would probably do something like allow only repetition of the operator
16:20:39 <Twey> p ? t ? f
16:20:59 <Twey> And embedded becomes p1 ? (p2 ? t ? f) ? f
16:21:06 <desp> Twey: "arthur"? :)
16:21:22 <Twey> desp: The aardvark
16:21:40 <CalJohn> I'm having trouble getting HsColour working with latex; the error is "Package hyperref Warning: Rerun to get /PageLabels entry." Any clues?
16:21:47 <desp> Ah.  That...explains it.
16:21:56 <Twey> *nod*
16:22:07 <blackh> What about something like... data ThenElse a = ThenElse {then::a, else::a} ; if cond { then = ..., else = ...} ?
16:22:12 <CalJohn> nevermind
16:22:35 <Twey> That of course only applies if I actually liked the if/then/else ordering, which I don't
16:22:52 <Twey> blackh: Nice idea
16:23:03 <copumpkin> wait, how would that work?
16:23:12 <copumpkin> then would take a ThenElse and return an a
16:23:24 <copumpkin> oh I see
16:23:34 <copumpkin> you'd never use the accessors on their own
16:23:40 <blackh> copumpkin: if_ :: Bool -> ThenElse a -> a
16:24:15 <blackh> ...the idea is to make it a bit more readable
16:24:21 <copumpkin> ah
16:25:06 <Twey> You can also do data Then = Then; data Else = Else; then = Then; else = Else; if :: Bool -> Then -> a -> Else -> a -> a; if p Then y Else n | p = y | otherwise = n
16:25:21 <Twey> And it works out as if foo then bar else baz
16:25:27 <MyCatVerbs> data ThenElse a = ThenElse a a; (?) True (ThenElse y n) = y; (?) False (ThenElse y n) = n; (:::) = ThenElse; infixr 0 ?; infixr 1 :::;
16:25:46 <Twey> But I dislike using magic word operators where not strictly necessary
16:25:52 <copumpkin> Twey: it wouldn't make if any more pleasant to use as a function though
16:25:54 <Twey> Makes currying difficult, for a start
16:25:56 <Twey> Right
16:26:15 <Twey> As a function, you don't want if/then/else at all: you want (??)
16:26:54 <blackh> Twey: Or what python does, which is option1 if cond else option2
16:27:14 <SamB> blackh: they did something?
16:27:27 <SamB> I thought guido had tricked them out of it somehow...
16:27:42 <copumpkin> I'm sure it's unpythonic somehow
16:27:42 <Twey> blackh: That's no better for currying, though.
16:28:03 <blackh> SamB: I think Guido said he did it that way so it was as ugly as possible.
16:28:04 <Twey> @let (y ?? n) p = if p then y else n
16:28:05 <lambdabot>  Defined.
16:28:23 <Twey> That's what's actually useful for currying.
16:28:36 <blackh> Twey: True
16:28:42 <SamB> blackh: I only heard about the time before, I think
16:29:18 <copumpkin> :t (??)
16:29:20 <lambdabot> forall t. t -> t -> Bool -> t
16:29:26 <SamB> where he had everyone say what they wanted it to look like and then, after the ensuing long list, said since they couldn't agree they'd get none!
16:29:39 <SamB> more or less
16:30:31 <Twey> SamB: Hahahahaha
16:30:44 <SamB> at least, that's how I remember it
16:30:47 * Twey occasionally thinks that Guido is off his rocker
16:30:49 <copumpkin> guido doesn't get much respect in the FP community :P
16:30:56 <Twey> It sounds like something he'd do
16:31:07 <SamB> at least he doesn't let them just add everything they think of
16:31:29 <Twey> I think I hear a ‘*cough* Wall *cough*’ in there somewhere.
16:31:47 <SamB> I thought of adding something about that after I said it ;-)
16:31:52 <SamB> but that wasn't actually intended
16:31:57 <Twey> Heh
16:32:04 <Twey> Yeah, he's good like that.
16:32:33 <SamB> I was just pointing out the positive aspects of guido's creative excuses
16:34:33 <Peaker> I think Guido is sometimes an idiot, but that Python is surprisingly good, considering the stuff its made of :)
16:35:00 <Twey> The ‘simple is best’ philosophy is a good one
16:35:07 <Peaker> And that Python is a huge step forwards from Perl, or C, or C++ or other older languages, in terms of productivity
16:35:21 <Peaker> Twey: Also the "novel syntax"
16:35:24 <Twey> Guido's just ultra-conservative about it
16:35:32 <Twey> Yeah, I guess
16:36:14 <SamB> Peaker: it doesn't take a genius to make a good BDFL
16:36:23 <SamB> as long as he leans on the conservative side
16:36:32 <SamB> in terms of changes he'll accept
16:36:37 <EvilTerran> BDFL?
16:36:44 <SamB> @vera BDFL
16:36:47 <lambdabot> No match for "BDFL".
16:36:51 <SamB> darn
16:36:58 <SamB> benevolent dictator for life
16:37:01 <EvilTerran> ah
16:38:33 <pikhq> > True ?? 1 $ 2
16:38:34 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
16:38:34 <lambdabot>    arising from the literal `1'...
16:38:42 <pikhq> Curses.
16:39:10 <aavogt> @type (??)
16:39:11 <lambdabot> forall t. t -> t -> Bool -> t
16:39:17 <pikhq> Yuh.
16:39:25 <pikhq> > 1 ?? 2 $ True
16:39:27 <lambdabot>   1
16:39:33 <benmachine> 1 ?? 2 True
16:39:36 <benmachine> er
16:39:38 <benmachine> > 1 ?? 2 True
16:39:39 <lambdabot>   No instance for (GHC.Num.Num (GHC.Bool.Bool -> t))
16:39:39 <lambdabot>    arising from the lite...
16:39:41 <benmachine> aw
16:39:44 <benmachine> > 1 ?? 2 $ True
16:39:46 <lambdabot>   1
16:39:54 <benmachine> oya due to fixity
16:40:03 <pikhq> Nice hack.
16:40:36 * EvilTerran likes "False ?= x = empty; True ?= x = pure x; Just x ?! y = x; Nothing ?! y = y"
16:41:14 <EvilTerran> > let False ?= x = empty; True ?= x = pure x; Just x ?! y = x; Nothing ?! y = y in [even x ?= "even" ?! "odd" | x <- [0..9]]
16:41:15 <lambdabot>   Ambiguous occurrence `empty'
16:41:15 <lambdabot>  It could refer to either `Text.PrettyPrint.Hu...
16:41:17 <EvilTerran> grr
16:41:19 <Peaker> (?!) = flip fromMaybe ?
16:41:26 <EvilTerran> > let False ?= x = Control.Applicative.empty; True ?= x = pure x; Just x ?! y = x; Nothing ?! y = y in [even x ?= "even" ?! "odd" | x <- [0..9]]
16:41:27 <lambdabot>   ["even","odd","even","odd","even","odd","even","odd","even","odd"]
16:41:41 <Peaker> @type Control.Applicative.empty
16:41:42 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
16:41:57 <conal> i'm trying to install codec-image-devil from hackage on os x and getting "missing c library: IL".  anyone know where i can install IL?  i did "sudo port install devil", which succeeded.  i guess either i got the wrong macport package or i don't have some path set up.  i'm just getting started with os x.
16:42:24 <Peaker> conal: hey, did you switch from Ubuntu?
16:42:27 <EvilTerran> ?= is a nice general guard construct for Alternatives in general, too
16:42:27 <lambdabot> Maybe you meant: . ? @ v
16:42:40 <CalJohn> @src maybe
16:42:41 <lambdabot> maybe n _ Nothing  = n
16:42:41 <lambdabot> maybe _ f (Just x) = f x
16:43:06 <copumpkin> would it be impossible to write a "concatenative" set of functions for haskell, that behave a bit like factor?
16:43:19 <conal> Peaker: in the process of switching.
16:43:40 <conal> Peaker: so i can develop for the iphone.  i still love ubuntu.
16:43:46 <Gracenotes> copumpkin: like (.) and =<</ap/join for functions?
16:43:47 <Peaker> conal: ah, was curious :-)
16:43:50 <EvilTerran> copumpkin, oleg could probably do it in the type system
16:43:54 <conal> my first mac.  i'm learning my way around.
16:44:04 <copumpkin> Gracenotes: well, with all that stack behavior
16:44:08 <CalJohn> @src foldl1
16:44:08 <lambdabot> foldl1 f (x:xs) = foldl f x xs
16:44:08 <lambdabot> foldl1 _ []     = undefined
16:44:15 <copumpkin> EvilTerran: I bet
16:44:22 <Gracenotes> copumpkin: they work wonderfully for threading one or two arguments, but it is not on any sort of explicit stack, like it is with factor
16:44:36 <Gracenotes> maybe a stack monad? :)
16:44:36 <copumpkin> yeah
16:44:40 <jmelesky> copumpkin: you could write a stackful DSL
16:44:44 <copumpkin> wouldn't necessarily have to be a monad
16:44:47 <Gracenotes> the only problem is making it heterogenous...
16:44:57 <EvilTerran> i've envisaged a type-safe stack indexed monad
16:45:02 <copumpkin> everything could be a function
16:45:05 <EvilTerran> based around the state indexed monad
16:45:16 <copumpkin> CPS-like
16:45:45 <EvilTerran> you could do some fun things with type families, too
16:45:58 <Gracenotes> ...the aristocrats!
16:46:14 <copumpkin> sounds very rude
16:46:17 <Gracenotes> (really there's a lot of devious type stuff out there! D:)
16:47:51 <EvilTerran> you could also have a Control.Category of stack operations
17:05:24 <pragma_> I find that the less I actually know, the more I think I really know.  And the more that I do know, the less I know that I know what I know.
17:06:08 <monochrom> Yes, that is how it works.
17:06:18 <Vanadium> The only thing I know is that I do not know anything~
17:06:25 <monochrom> This is why the most igonrant people has the most amount of opinion.
17:07:57 <SamB> Vanadium: soon you won't even know that!
17:08:05 <Vanadium> Oh no
17:15:11 <sebaseba_> @quote
17:15:11 <lambdabot> 9/11 says: Never forget.
17:15:24 <Peaker> isn't it weird that values have referential transparency, but types don't?
17:15:42 <sebaseba_> what do you mean?
17:15:55 <bakesz> hi!i have a list,and i want to remove an element,that is exactly once in the list,so i want to stop removing when the function find this element.is there a built-in function for this?thank you
17:16:01 <Peaker> data Maybe2 a = Nothing2 | Just2 a ; is not interchangable with Maybe a
17:16:52 <Peaker> The open list of instances is a good excuse for why 2 types are never identical, though
17:17:00 <sebaseba_> Peaker: oh, I see
17:17:38 <Lemmih> bakesz: delete?
17:17:53 <Peaker> @src delete
17:17:53 <lambdabot> delete = deleteBy (==)
17:17:56 <Peaker> @src deleteBy
17:17:56 <lambdabot> deleteBy eq x []        = []
17:17:56 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
17:18:07 <sebaseba_> > delete 'a' "banana"
17:18:08 <lambdabot>   "bnana"
17:18:12 <MarcWeber> nominolo_: Do you know how to use json.el to translate nil to an empty Array instead of null ?
17:18:22 <dolio> I wouldn't call that referential transparency.
17:18:35 <bakesz> Lemmih: thank you very much
17:18:38 <nominolo_> MarcWeber: no
17:21:55 <Saizan> Peaker: that's usually called structural equality, rather than nominal as we have in haskell
17:23:03 <Saizan> you'd like the pattern calculus, maybe
17:35:39 <MarcWeber> nominolo_: vim neither likes null nor true nor false. How should I cope with it? I'd replace those occurences by "", 1 and 0. How should I do that? I could do apply a makeVimCompatible function before encoding the JSON object (only when the client is vim ?) Then vim can parse everything. I also can replace all occurences of JSBool by 0/1. Then there is the risk that someone adds JSNull again not paying attention to the issue?
17:36:28 <dcoutts_> Peaker: it's a language choice, it's certainly possible to define types such that those with the same structure are equal
17:36:31 <MarcWeber> I still disklike using a python JSON parser because it may slow down all operations a little.
17:36:46 <nominolo_> MarcWeber: sorry, what doesn't vim like about null, true or false?
17:36:54 <dcoutts_> Peaker: eg, use the Church encoding for all data
17:37:26 <MarcWeber> nominolo_ The language doesn't know about them so vim can't parse it
17:40:20 <nominolo_> MarcWeber: so how about transforming them into 1/0 on the fly?
17:40:45 <MarcWeber> That's what I was aksing. I just don't know wether this should be done for vim clients only
17:40:59 <nominolo_> it should be done on the client, really
17:41:05 <MarcWeber> Then I'd adda isVim flag to ScionM and only apply that when its true
17:41:14 <nominolo_> meh
17:41:56 <nominolo_> that'd be an ugly hack.  That's going against the hole reason to use JSON in the first place
17:42:01 <nominolo_> whole(
17:42:04 <nominolo_> *
17:42:13 <MarcWeber> nominolo_: This requires another roundtrip of serialization / desirialization within vim.
17:42:35 <nominolo_> can't you do this on the fly?
17:43:28 <MarcWeber> nominolo_: What do you mean ? substitute null by "" using a regex? No!, this will only work 99% of all cases
17:44:45 <MarcWeber> nominolo_: The only way passing values from pyhton to vim is vim.command('let g:global_var="use vim encoding here"')
17:45:48 <nominolo_> right.  and you want to avoid the python code having to do the parsing
17:45:55 <nominolo_> to avoid depending on json
17:46:01 <nominolo_> which comes by default with 2.6
17:46:13 <MarcWeber> No. Having python do the parsing, having python create vim-language objects, having vim parse that again
17:47:17 <MarcWeber> It looks like this   vimDecode . ( vimEncode . jsonDecode) . jsonEncode     where everything between () is done by python
17:47:36 <MarcWeber> vimDecode is the vim side , jsonEncode on the right is the scion server encoding
17:47:50 <nominolo_> right, so why can't vimEncode print '1' for True and '0' for False?
17:48:12 <nominolo_> where True/False are python values
17:48:32 <MarcWeber> anyway I have to code a vim encoder in python.
17:48:39 <MarcWeber> Then I can use the haskell code. That'll be much faster
17:49:24 <MarcWeber> You can encode true, false, null by using a serialized dummy function such as  function('haskellcomplete#NULL'). But the scion side can't generate it without patching the JSON lib
17:52:43 <MarcWeber> nominolo_: I hope you can live with me adding some additional lines doing this on the fly transformation. I'll also add a client-identify function so that vim can tell scion it is "vim" who connected.
17:53:23 <nominolo_> yeah, I guess.  I'm starting to like Vim less and less
17:53:57 <MarcWeber> nominolo_: Vim is a bottle neck. But it has one of the fastest text editing features.
17:54:05 <MarcWeber> It takes quite a lot of time to realise that.
17:55:42 <MarcWeber> nominolo_: The real problem is that nobody starts working on these issues. If you did you had to test a lot of different configurations (console, different gui frontends etc..)
17:56:48 <nominolo_> well, a first-class integration with Python would be enough, actually
17:57:34 <nominolo_> i.e., instead of having to go through Vimscript do all of the scripting in Python
17:58:11 <nominolo_> and not this retarded mutual string interpretation hack
17:58:15 <MarcWeber> nominolo_: Eg you can't set the errorlist. You could write a buffer and call :cbuffer or such. That can be done in python only.
18:05:07 <nominolo_> yeah, anyway, I'm off to bed
18:05:35 * BMeph really hates that Rationals are not in the Floating class. :\
18:05:56 <aavogt> > sqrt (2%1)
18:05:57 <lambdabot>   No instance for (GHC.Float.Floating (GHC.Real.Ratio t))
18:05:57 <lambdabot>    arising from a u...
18:07:12 <SamB> heck
18:07:27 <SamB> BMeph: pi is a rational now?
18:08:01 <benmachine> heah
18:08:05 <benmachine> er
18:08:06 <benmachine> hah
18:08:46 <BMeph> SamB: Trying to do the HRR formula.
18:36:28 <wahjava> hi all
18:37:07 <wahjava> i'm wondering if anyone can tell if my haskell program can be refactored to look more beautiful: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7374#a7374
18:37:24 <wahjava> the program solves problem given at http://code.google.com/codejam/contest/dashboard?c=agdjb2RlamFtcg4LEghjb250ZXN0cxh5DA#s=p0
18:46:21 <monochrom> wahjava: I think it's OK.
18:47:18 <dolio> I'd use guards in startIterations.
18:47:37 <dolio> Or 'when'.
18:47:52 <gwern> wahjava: I don't really like the IO. the approach I'd take is to use getContents
18:47:54 <wahjava> okay
18:47:58 <gwern> instead of messing with handles
18:48:10 <gwern> (also, [Char] = String)
18:48:18 <wahjava> gwern, okay so most of the code is predictable ?
18:48:25 <wahjava> s/predictable/deterministic/
18:48:44 <gwern> well, each line is a separate task, right?
18:48:48 <wahjava> right.
18:49:00 <gwern> so conceptually you could just do something like 'map converterfunction $ lines $ getContents'
18:49:25 <wahjava> yeah, didn't thought that way.
18:49:29 <dolio> It's also curious that you  have both a where clause and a let in fromBase.
18:49:51 <gwern> since the google specification seems to be thinking in terms of stdin and stdout; I dunno why you're mucking around with withFile etc
18:50:07 <dolio> That's due to reusing the name map, I suppose?
18:50:10 <gwern> going with either interact or getContents should save you 3 or 4 lines
18:50:49 <gwern> (and I'm convinced there's some much clearer way of doing the pure algorithm itself, but I don't feel like figuring it out)
18:51:58 <wahjava> yes, dolio.
18:52:02 <wahjava> thanks dolio, gwern and monochrom .
18:54:12 <gwern> (if you need to handle the 'case #5' stuff, remember that map is [a] -> [a]; so you could do something like 'map (\(x,y) -> putStrln "case # ++ show x ++ " " ++ show y) $ zip [1..] $ map f $ lines $ getContents'
18:57:18 <wahjava> okay
18:59:41 <BMeph> gwern: Heh-heh, you're gonna try it yourself now, aren't you! ;)
19:03:26 <dolio> > let i2d = (!!) ; d2i ds = fromJust . (`elemIndex`ds) ; tens = "0123456789" ; alien = "oF8" ; num b = foldl' (\n d -> n * b + d) 0 ; mun b i | i == 0 = [0] | otherwise = reverse . unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` b, n `div` b)) $ i ; convert i o = map (i2d o) . mun (length o) . num (length i) . map (d2i i) in map (convert tens alien) ["0","1","2","3","4","5","6","7","8","9","10"]
19:03:27 <lambdabot>   ["o","F","8","Fo","FF","F8","8o","8F","88","Foo","FoF"]
19:04:37 <pikhq> I think that may qualify for obfuscated Haskell coding.
19:04:47 <gwern> BMeph: no, I'm not!
19:04:56 <dolio> It'd be better if it were're all on one line.
19:05:05 <dolio> Weren't, even.
19:05:19 * gwern summons cosmic amounts of willpower to prevent irritation from rising that wahjava won't produce a perfect haskell gem
19:05:33 <SamB> gwern: what what?
19:05:49 <monochrom> Use Chinese names to complete the obfuscation.
19:05:57 <dolio> Needs some unfoldr combinators, too.
19:05:59 <SamB> they have capital letters?
19:06:05 <SamB> and lowercase too?
19:06:15 <monochrom> Oh wait, actually 1/4 of the world population can read Chinese just fine.
19:06:29 <SamB> seriously?
19:06:35 <pikhq> Except for my terminal, I could have a decent shot of it.
19:06:41 <pikhq> SamB: China is fucking huge.
19:06:43 <monochrom> 1/4 of the world population is in China.
19:06:50 <SubStack> I doubt literacy is that high in China.
19:06:50 <SamB> oh
19:06:57 <monochrom> Heh
19:06:59 * BMeph looks at wahjava's hpaste...yep, that handle's not just made-up.
19:07:00 <dolio> What fraction of the US population can read English?
19:07:02 <SamB> yeah, that doesn't mean they can all read chinese ;-P
19:07:08 <monochrom> hahaha
19:07:20 <SamB> dolio: probably more than can write it
19:07:20 <SubStack> maybe 1/7
19:07:32 <SamB> I hope!
19:07:36 <SamB> on good days I can do both
19:07:44 <pikhq> SubStack: Except that written Chinese is the lingua franca. There's dozens of spoken languages with the same written language there. ;)
19:08:15 <SamB> but how MUCH of it do they know?
19:08:24 <SubStack> just look at how that turned out for France
19:08:33 <SamB> ... more or less than my terminal can display ?
19:09:09 <SamB> SubStack: they tried to standardize on chinese for written language because they couldn't figure out how to spell things in french?
19:09:13 <pikhq> Less. I presume your terminal can display the entire CJK section of Unicode.
19:09:27 <SamB> pikhq: depends on what's in my fonts!
19:09:43 <monochrom> So, once again I have successfully derailed #haskell. I have to avoid success at all cost next time.
19:09:44 <SamB> and some characters are pretty damn blurry :-(
19:09:57 <SamB> monochrom: quick
19:10:02 <SamB> derail the HP
19:10:16 <monochrom> What is HP?
19:10:26 * BMeph wonders what fraction of the US population can read Chinese...and what's the size of the factor for the reverse
19:10:45 <monochrom> I haven't read the recent HWN yet.
19:10:53 <SamB> monochrom: Haskell Platform
19:12:12 <monochrom> I like the Haskell Platform. I won't derail it.
19:12:39 <sebaseba_> 脱線
19:12:44 <monochrom> How do you like GHC 6.10.4 ?
19:12:59 <SamB> why do they keep doing GHC releases?
19:12:59 <BMeph> That's a funny train whose platforms can get derailed. ;p
19:13:15 <SamB> BMeph: true!
19:13:30 <SamB> those GHC releases tend to mess up my Debian :-(
19:13:32 <BMeph> SamB: 'Cause they're too big to keep! ;p
19:13:46 <dolio> They keep finding bugs. :)
19:14:14 <pikhq> They achieved perfection 2 years ago and have just been reintroducing bugs since.
19:14:14 <pikhq> :P
19:14:18 <SamB> well, couldn't they wait until they find some more before doing another relase?
19:14:36 <FunctorSalad> o_o
19:15:03 <SamB> or, you know, wait until about when they would have to do a release to get it into the next Ubuntu?
19:15:06 <BMeph> Great Googly Moogly, but that code is Javistic as all get-out! :\
19:15:09 <FunctorSalad> you don't have to install the release if you think the bugs are insignificant
19:15:32 <SamB> FunctorSalad: but it prevents Debian's build from fixpointing
19:15:54 <Vanadium> fixpointing?
19:15:59 <SamB> settling down
19:16:06 <SamB> reaching equilibrium
19:16:17 <FunctorSalad> why should it?
19:16:17 <SamB> getting all the libraries built at compatible versions
19:16:33 <FunctorSalad> btw, you can set the package to "hold" on aptitude
19:16:33 <monochrom> SamB: because of http://arcanux.org/lambdacats_3.html#entry9
19:16:59 <SamB> monochrom: that's going to say "fixed in teh head / how about a release", isn't it?
19:17:09 <monochrom> Yes!
19:17:29 <monochrom> People seem to be impatient about bugfixes!
19:18:04 <Zao> Following the cvs-ghc list is scary.
19:18:22 <SamB> well, okay, what I actually wish was that Debian couldn't only handle having one version of a Haskell library package exist in a particular distribution at any one time
19:19:38 <monochrom> I never use .debs for GHC and libs.
19:21:53 <SamB> there's a bit of sense in that
19:21:57 * SamB never had that much
19:54:02 <Berengal> Anyone tried to run haskell on a server?
19:54:20 <SamB> @hackage
19:54:21 <lambdabot> http://hackage.haskell.org
19:54:31 <SamB> Berengal: you mean like that?
19:54:34 <Berengal> By that I mean, lots of non-x86 xpus
19:54:40 <Berengal> cpus*
19:54:55 <SamB> oh, you mean on a *sun*
19:55:26 <Berengal> For example
19:55:28 <SamB> I heard something about haskell.org owning a sun, and possibly a secret project using that sun...
19:56:35 <Berengal> It that turns out to work well, my freedom from Java might be that much closer...
19:56:44 <copumpkin> well benl23 redid the sparc codegen
19:56:47 <copumpkin> and blogged a lot about it
19:57:20 <Berengal> copumpkin: linky?
19:57:26 <jmcarthur> from reading the blog the project went rather well
19:57:31 <Berengal> I don't know where his blog's at
19:57:42 <jmcarthur> it was one of those 8 core with 8 logical threads each things, so 64 threads at once
19:57:46 <vav> Berengal: http://ghcsparc.blogspot.com is one part of the pixur
19:58:10 <Berengal> jmcarthur: We just got one of those at work the other day. We could tell because the sysadmins were drooling ;)
19:58:46 <jmcarthur> ha
19:58:49 <jmcarthur> i want one
19:58:52 <Berengal> (You should've seen their face when I asked it if had blinking lights)
19:58:54 <SamB> what was especially interesting was that they were thinking of handing out logins ...
19:59:00 <jmcarthur> lol
19:59:04 <SamB> Berengal: what did they do?
20:00:09 <Berengal> SamB: It was about the only thing that registered in their euphoric minds. They turned, nodded slowly, said "yes", then continued their hazy haze
20:00:10 <Apocalisp> \w -> foldr (+) 0 . map (\x -> if x then 1 else 0) . liftM2 (==) w
20:00:34 <Apocalisp> is there a better way of saying "count all in x that are elements of y"?
20:01:02 <Berengal> 'course, we developers started salivating a bit as when they told us about how they were planning on setting it up. It's going to be a development server...
20:01:04 <shachaf> Apocalisp: Well, for one, that only works if they are in the same positions (no?)
20:01:15 * SamB drools
20:01:25 * SamB wants a login on haskell.org's ...
20:01:41 <Apocalisp> shachaf, nah liftM2 takes the cartesian
20:01:56 <Apocalisp> ...which is kind of silly I admit
20:02:00 <copumpkin>  o?
20:02:04 <Cale> > intersect "hello there" "aeiou"
20:02:05 <lambdabot>   "eoee"
20:02:09 <SamB> copumpkin: o wut?
20:02:14 <copumpkin> Apocalisp: why is it silly?
20:02:20 <Apocalisp> intersect! naturally.
20:02:25 <SamB> setually
20:02:30 <Apocalisp> Sensually
20:02:39 <copumpkin> but liftM2 as cartesian just follows from the monad definition for lists
20:02:44 <FunctorSalad> what happened?
20:03:18 <Berengal> Wouldn't sets be better than lists for finding the intersection?
20:03:38 * Apocalisp intersects doucement... intersects... very slowly.
20:03:46 <copumpkin> o.O
20:04:01 <FunctorSalad> Berengal: yes. without order it's O(n^2) AFAICT
20:04:03 <Apocalisp> copumpkin: Using it for this purpose was silly. liftM2 is awesome.
20:04:29 <copumpkin> oh :)
20:04:36 * Apocalisp throws a parade for the list monad
20:04:42 <Berengal> cartesian products are nfity
20:07:10 <Baughn> > ((*) . (+)) <$> [1,2] <*> [10,20] <*> [100,200]
20:07:11 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
20:07:11 <lambdabot>    arising from a use of `GHC.Num.*'...
20:07:19 <Baughn> Well, that.. oh. Right.
20:07:30 <copumpkin> > liftM2 (,) "cartesian" "product"
20:07:32 <lambdabot>   [('c','p'),('c','r'),('c','o'),('c','d'),('c','u'),('c','c'),('c','t'),('a'...
20:07:43 <Berengal> > (\w -> length . filter id . liftM2 (==) w) [1,1,1,2,3] [1,1,1]
20:07:44 <lambdabot>   9
20:07:51 <Baughn> > liftA2 (,) "cartesian" "product" -- Use the right one
20:07:52 <lambdabot>   [('c','p'),('c','r'),('c','o'),('c','d'),('c','u'),('c','c'),('c','t'),('a'...
20:07:56 <copumpkin> > unzip $ liftM2 (,) "cartesian" "product"
20:07:57 <lambdabot>   ("cccccccaaaaaaarrrrrrrttttttteeeeeeesssssssiiiiiiiaaaaaaannnnnnn","product...
20:08:00 <Berengal> Apocalisp: Sure the product is what you want here though
20:08:01 <copumpkin> :P
20:08:31 <Baughn> > snd $ unzip $ liftA2 (,) "cartesian" "product"
20:08:32 <lambdabot>   "productproductproductproductproductproductproductproductproduct"
20:08:59 <Berengal> > (snd &&& fst) . unzip $ liftM2 (,) "snake" "mushrom"
20:09:00 <lambdabot>   ("mushrommushrommushrommushrommushrom","sssssssnnnnnnnaaaaaaakkkkkkkeeeeeee")
20:09:18 <Baughn> :D
20:09:22 <monochrom> What is with mushroom and snake? New meme?
20:09:29 <Baughn> OLD meme
20:09:30 <Berengal> Oooold meme
20:09:46 <Berengal> I probably should've gone for badger
20:10:11 <Baughn> monochrom: Do you like mushrooms?
20:10:17 <monochrom> Yes.
20:11:09 <^aristotle> quick newbie question
20:11:14 <^aristotle> this works:
20:11:14 <Apocalisp> Aristoteles!
20:11:16 <^aristotle> take 10 $ iterate (\x -> (fst(x)/2, snd(x)*2)) (10,10)
20:11:34 <^aristotle> this throws a type error:
20:11:34 <^aristotle> take 10 $ iterate (\x -> (truncate(fst(x)/2), snd(x)*2)) (10,10)
20:11:36 <copumpkin> > take 10 $ iterate (\x -> (fst(x)/2, snd(x)*2)) (10,10)
20:11:37 <^aristotle> why?
20:11:38 <lambdabot>   [(10.0,10),(5.0,20),(2.5,40),(1.25,80),(0.625,160),(0.3125,320),(0.15625,64...
20:12:01 <copumpkin> > take 10 $ iterate (\(x, y) -> (x/2, y*2)) (10,10)
20:12:02 <lambdabot>   [(10.0,10),(5.0,20),(2.5,40),(1.25,80),(0.625,160),(0.3125,320),(0.15625,64...
20:12:17 <Ytinasni> :t truncate
20:12:18 <^aristotle> ah, nice
20:12:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:12:21 <copumpkin> > take 10 $ iterate ((/2) *** (*2)) (10,10)
20:12:23 <lambdabot>   [(10.0,10),(5.0,20),(2.5,40),(1.25,80),(0.625,160),(0.3125,320),(0.15625,64...
20:12:43 <^aristotle> whoa whoa whoa slow down :)
20:12:48 <copumpkin> :)
20:13:03 <monochrom> Int / 2  does not make sense. But because of your truncate you have precisely that.
20:13:17 <Ytinasni> truncate changes from floating to integral, and iterate needs the same type in as out.
20:13:29 <monochrom> Just use div or something.
20:13:53 <^aristotle> monochrom: got the same error when I tried div
20:13:56 <monochrom> > (41 :: Int) `div` 2
20:13:57 <lambdabot>   20
20:13:58 <Berengal> or fromIntegral
20:14:03 <Berengal> fromIntegral is magical
20:14:18 <Apocalisp> > take 10 $ iterate ((`div` 2) *** (*2)) (10,10)
20:14:19 <lambdabot>   [(10,10),(5,20),(2,40),(1,80),(0,160),(0,320),(0,640),(0,1280),(0,2560),(0,...
20:14:52 <monochrom> > take 10 $ iterate (\x -> (fst(x) `div` 2, snd(x)*2)) (10,10)
20:14:53 <lambdabot>   [(10,10),(5,20),(2,40),(1,80),(0,160),(0,320),(0,640),(0,1280),(0,2560),(0,...
20:14:56 <monochrom> works.
20:15:03 <Apocalisp> > take 10 $ iterate ((`div` 2) &&& (*2)) 10
20:15:05 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
20:15:06 <monochrom> Give me a reproduce problem.
20:15:17 <monochrom> err, s/reproduce/reproducible/
20:15:23 <^aristotle> worked for me now too
20:16:13 <^aristotle> > (\x -> (div fst(x) 2, snd(x)*2)) (10,10)
20:16:15 <lambdabot>   Couldn't match expected type `(a, b)'
20:16:35 <^aristotle> where's the mistake?
20:16:53 <monochrom> need parentheses properly. div (fst x) 2
20:16:58 <Berengal> > (\x -> (div (fst x) 2, snd(x)*2)) (10,10)
20:16:59 <lambdabot>   (5,20)
20:17:07 <^aristotle> ah
20:17:15 <monochrom> You have been polluted by conventional mathematicians' stupid f(x).
20:17:20 <^aristotle> gotta say the error messages could be more useful
20:17:29 <ray> function application is too important to be left to parentheses
20:17:40 <^aristotle> monochrom: no actually not
20:17:48 <ray> also parentheses are too important to be mangled by being used for function application
20:17:52 <monochrom> No, the error message could not be more useful.
20:17:52 <^aristotle> just don't know my way around precedence in haskell yet
20:18:19 <Berengal> ^aristotle: Putting parenthesis around a single token never helps
20:18:29 <^aristotle> Berengal: OK
20:19:00 <Berengal> And function application binds the strongest
20:19:26 <monochrom> div f(x) 2  is  ((div f) x) 2
20:19:54 <monochrom> And so (div f) is very disturbed.
20:20:03 <Soushokuon> > text "いち"
20:20:04 <lambdabot>   いち
20:20:16 <Soushokuon> hm.. my terminal unicode no likey
20:20:27 <^aristotle> monochrom: FWIW, in my Perl I avoid parentheses wherever possible too...
20:20:28 <gwern> :t text
20:20:29 <lambdabot> String -> Doc
20:20:54 <ray> > text "⑨"
20:20:55 <lambdabot>   ⑨
20:21:06 <monochrom> Oh, I remember that, now that you say it. I used to know Perl 10 years ago.
20:21:17 <^aristotle> (I'm not sure it's a good idea to mention Perl in here but then again I also like XSLT, SQL, C and Javascript, each for their own reasons, so there's no camp I'm going to be accepted in anyway :P )
20:21:43 <monochrom> Darn English without parenthesis. know Perl (10 years ago), not know (Perl 10) years ago.
20:22:04 <ray> english needs parens sometimes
20:22:15 <ray> its grammar is too weak
20:22:19 <Vanadium> I used to know 10 years ago $ Perl
20:22:40 <Soushokuon> do you know lisp-p
20:23:15 <dino-> ^aristotle: I do that too, avoid parens in Perl
20:23:26 <^aristotle> actually english is just fine... in that sentence "10 years ago" is pretty much commutatvie
20:23:32 <^aristotle> *commutative
20:23:34 <dino-> Like args to functions, for instance.
20:23:34 <Berengal> Does GHC still use perl when compiling?
20:23:39 <FunctorSalad> "ten years ago, I knew the language known as perl"
20:23:50 <Soushokuon> Berengal: I do not think we speak of that evil in here
20:23:53 <ray> berengal: iirc, only when it goes via c
20:23:57 <Soushokuon> D:
20:24:15 <FunctorSalad> "back in the day, I knew perl 10" ;)
20:24:34 <ray> i knew perl 10 back when the rest of you were still implementing perl 6
20:24:50 <Berengal> ray: Ah, makes sense, since it's used to mangle gcc asm output...
20:25:16 <ray> gcc asm output and perl, two bad tastes...
20:25:19 <FunctorSalad> nom nom nom
20:25:37 <Ytinasni> two bad tastes that go great together?
20:25:42 <^aristotle> gcc asm output specifically or asm in general?
20:26:17 <ray> stuff that compilers emit is always ugly to read
20:26:34 <monochrom> compiler = desugarer
20:27:12 <ray> = uglifyer
20:27:31 <FunctorSalad> wut? and typechecker, and optimiser, ..
20:27:40 <monochrom> Not sure I can say asm is ugly.
20:27:57 <ray> manmade asm can be okay
20:29:44 <monochrom> beautifulwomanmade asm
20:30:56 <gwern> monochrom: what is it if aujritius tang is writing the asm? :)
20:31:53 <monochrom> Jolly good, I answered before you asked! beautifulwomanmade asm!
20:32:29 <monochrom> Unless I misremember, and aujritius is a beautifulman.
20:32:59 <gnuvince> autrijus tang is audrey tang now.
20:33:14 <gnuvince> http://pugs.blogs.com/audrey/2005/12/runtime_typecas.html
20:33:55 <^aristotle> what's haskell's equivalent to `grep`?
20:34:13 <gwern> gnuvince: I don't know whether to be horrified or amused at the title
20:34:24 <gwern> ^aristotle: filter, probably
20:34:24 <Berengal> \x -> any (isPrefixOf x) . tails
20:34:34 <gnuvince> gwern: I think it's a pretty good one
20:34:42 <monochrom> I guess Audrey is a beautifulman. And he has found Isis, an awesomegoddess.
20:34:45 <^aristotle> gwern: ah, thx
20:34:48 <gwern> obviously there's no strict analogue, unless you go to the regexp libs and roll your own grep
20:34:52 <gwern> @hoogle filter
20:34:52 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
20:34:53 <lambdabot> Data.ByteString filter :: (Word8 -> Bool) -> ByteString -> ByteString
20:34:53 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
20:35:30 <gwern> Berengal: wouldn't that be isInfixOf, anyway? grep matches anywhere in a line, unless you're doing something like ^ or $, iirc
20:35:52 <Berengal> gwern: That's pretty much the definition of isInfixOf, yeah
20:35:56 <Berengal> @src isInfixOf
20:35:57 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
20:36:56 <vav> @hackage only
20:36:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/only
20:37:41 <vav> ^aristotle: that's a command line grep-a-like that might give you some examples to compare to
20:37:52 <ray> i approve of audrey tang, it is so much easier to spell
20:38:01 <FunctorSalad> monochrom: Isis?
20:39:10 <^aristotle> > filter (odd fst) [(2,1),(1,2)]
20:39:11 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
20:39:16 <^aristotle> what's wrong with that now?
20:39:28 <gwern> need a .
20:39:33 <FunctorSalad> > filter (odd . fst) [(2,1),(1,2)]
20:39:34 <Berengal> > filter (odd . fst) [(2,1),(1,2)]
20:39:35 <lambdabot>   [(1,2)]
20:39:36 <lambdabot>   [(1,2)]
20:39:40 <gwern> > filter (odd . fst) [(1,2)]
20:39:41 <^aristotle> why?
20:39:41 <lambdabot>   [(1,2)]
20:39:44 <monochrom> FunctorSalad: like this: http://pugs.blogs.com/audrey/2009/04/my-first-true-l.html
20:39:55 <gwern> ^aristotle: because 'odd' doesn't take a function as an argument
20:40:06 <gwern> @hoogle odd
20:40:07 <lambdabot> Prelude odd :: Integral a => a -> Bool
20:40:07 <lambdabot> package hpodder
20:40:10 <gwern> @hoogle fst
20:40:10 <lambdabot> package fst
20:40:10 <lambdabot> Prelude fst :: (a, b) -> a
20:40:10 <lambdabot> Data.Tuple fst :: (a, b) -> a
20:40:18 <monochrom> Haha I risk turning this into a celebrity gossip tabloid
20:40:31 <gwern> note that ((a,b) -> a) is not an Integral a
20:40:37 <FunctorSalad> monochrom: aw :)
20:43:04 <gwern> monochrom: I too am confused. this isis is a chick? so... audrey was a lesbian trapped in a man's body?
20:43:54 <FunctorSalad> should I be concerned that it makes perfect sense to me? ;) gwern
20:44:26 <QtPlaty[HireMe]> gwern: Gender prefrence is orthignal to Gender Idenity.
20:44:33 <gwern> lies!
20:44:35 <jmcarthur> i was about to say the same thing there
20:44:40 <QtPlaty[HireMe]> And I can't spell orthignal
20:44:47 <jmcarthur> except i would have spelled it "orthogonal"
20:44:50 <jmcarthur> ;)
20:44:53 <FunctorSalad> hehe
20:45:03 <monochrom> You have to be very sensitive to types when working with Haskell. Preferrably type-driven programming.
20:45:09 <jmcarthur> and "preference," too
20:45:10 <gwern> (anyway, enough of this)
20:45:17 <^aristotle> > foldl1 (+) . map (snd) . filter (odd . fst) . takeWhile (\(x,y) -> 0 < x) $ iterate (\(x,y) -> (div x 2, y*2)) (10,10)
20:45:19 <lambdabot>   100
20:45:21 <^aristotle> tada
20:45:32 <^aristotle> ( http://thedailywtf.com/Articles/Programming-Praxis-Russian-Peasant-Multiplication.aspx )
20:45:39 <ray> it's not a celebrity gossip tabloid if people's names aren't in bold, monochrom
20:45:46 <monochrom> I am a Vulcan in the body of Human.
20:46:01 <Rotaerk> _ \\ //
20:46:05 <Rotaerk> live long and prosper
20:46:17 <ray> i'm an AI trapped in a human's body
20:46:34 <Berengal> I'm a human trapped in the body of a human
20:46:48 <Rotaerk> I'm a god trapped in a computer
20:46:50 <FunctorSalad> I'm a lolcat trapped in a trap's body?
20:47:05 * Rotaerk eats some salad.
20:47:36 * ^aristotle . o O ( "yo dawg we herd you like traps"? )
20:50:11 <Axman6> ha, apparently you can use Ada with lego mindstorms
20:50:36 <monochrom> yo dawg we herd you liek monad and fix so we put monad in fix so you can haz MonadFix ?
20:50:59 <monochrom> Oh! There is Ada compiler targetted at Mindstorm?
20:51:13 <Axman6> http://libre.adacore.com/libre/tools/mindstorms/
20:51:38 <SamB> @instances-importing Control.Monad.Fix MonadFix
20:51:39 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:51:50 <ray> yo dawg we herd you like fixpoints so we put a fixpoint in your fixpoint so you can find the fixpoint of "yo dawg we herd you like fixpoints so we put a fixpoint...
20:51:59 <monochrom> I must admit that Ada had a good concurrency story.
20:52:07 <SamB> monochrom: which was ?
20:52:28 <SamB> but it has terrible parametric polymorphism, I think :-(
20:52:55 <Axman6> monochrom: good to know, since i'm using it this semester for my concurrent and distributes systems course :)
20:52:58 <SamB> and no typeclasses
20:53:00 <monochrom> I forgot. Probably monitor.
20:53:32 <monochrom> I think its parametric polymorphism is ok.
20:53:38 <SamB> how am I supposed to use an HDL without decent parametric polymorphism or typeclasses?
20:53:53 <SamB> monochrom: really ?
20:53:56 <monochrom> Any parameteric polymorphism not mixed with sub____ing is ok.
20:55:17 <monochrom> All I remember about Ada concurrency is the keyword "rendezvous" and it was quite nice to use.
20:55:31 <SamB> doesn't that mean "sex"?
20:55:32 <monochrom> I just don't remember how nice and how to use it!
20:57:19 <monochrom> rendezvous doesn't mean sex
20:57:41 <mike-burns> Rendezvous has been renamed to Bonjour.
20:58:28 <SamB> in ada?
20:58:38 <mike-burns> Oh no, in Apple.
20:59:36 <monochrom> ...
21:06:23 * wmealing_ wondered the same thing.
21:07:44 <Soushokuon> > let circle n=maybe n((9263+n)+)$fst<$>(find snd$zip[70,64,0,139]$(($n).inRange)<$>[(65,90),(97,122),(49,57),(48,48)]) in text $ map (chr.circle.ord) "Code golfing circle alphabets, test 1 2 3!"
21:07:45 <lambdabot>   Ⓒⓞⓓⓔ ⓖⓞⓛⓕⓘⓝⓖ ⓒⓘⓡⓒⓛⓔ ⓐⓛⓟⓗⓐⓑⓔ...
21:08:04 <Soushokuon> > let circle n=maybe n((9263+n)+)$fst<$>(find snd$zip[70,64,0,139]$(($n).inRange)<$>[(65,90),(97,122),(49,57),(48,48)]) in text $ map (chr.circle.ord) "AbC0123"
21:08:05 <lambdabot>   ⒶⓑⒸ⓪①②③
21:08:08 * wmealing_ boggles
21:08:12 <copumpkin> lol
21:08:34 <Soushokuon> left infixity of <$>, though..! :X
21:09:35 <Soushokuon> wide latin is much easier; it basically follows ASCII to a Ｔ ;)
21:10:54 <Twey> Haha
21:17:20 <amz> hrm, I was reading Na Xu's technical report on "Static contract checking for Haskell", are there any plans to implement that into GHC?
21:18:30 <edwardk> amz: it looks somewhat stalled
21:18:36 <edwardk> it was some of my favorite research of all time
21:18:48 <edwardk> I spent a good chunk of time integrating the approach into my own toy language projects
21:19:05 <amz> I see... Is there a technical reason for that, or just lack of manpower?
21:19:06 <edwardk> but the ESC/static contract checking stuff she was doing seems to have gone nowhere.
21:19:29 <edwardk> from checking out the version that was in darcs on haskell.org it just looks like it was a performance pig
21:19:36 <edwardk> which is a shame
21:19:40 <edwardk> for my toy examples it worked fine
21:20:06 <edwardk> i wonder if tighter integration with the theorem prover could help with some of the problems it had
21:20:11 <amz> performance pig as in "I guess I'll make some changes and let it compile overnight"?
21:20:31 <edwardk> because there was a lot it couldn't prove because of the limited domain knowledge it had about Num instances, etc.
21:20:56 <edwardk> as in multiply compile times by 25x or so
21:21:01 <amz> Ouch. I see.
21:21:12 <amz> Well, are there any decent alternatives, be them static or dynamic?
21:21:13 <edwardk> the abstract interpreter still had to unroll a few levels
21:21:32 <edwardk> not so much in haskell, one option is of course to use coq and compile down to haskell, but you lose all of the elegance of that approach
21:21:52 <amz> yes... :\
21:22:42 <amz> I wonder if one could somehow use template haskell (keep in mind, I'm not experienced at all on the language and never touched template haskell) to generate a function that binds a function to an input contract and an output contract, returning a function that performs the check
21:22:48 <edwardk> mattieu sozeau (mattam) has a similar notation at least available for coq from his research on russell, but it still requires manual proof
21:23:06 <edwardk> well the point is doing it without the check ;)
21:23:33 <amz> well, yes, but if no static checking is available, dynamic is still better than nothing
21:24:45 <edwardk> in my case i compiled a couple of ways, i tried to get the esc stuff right, and if it proved out ok through abstract interpretation i gave no message, but if it failed you got a counter example or a warning of unprovability. in the latter scenario you could emit the code with hand checks, but those exist at a meta-level and i never came up with clean semantics for what to do when those checks fail other that blame s
21:24:52 <edwardk> er other than
21:25:34 <edwardk> one nice thing about that paper was you can basically transcribe the abstract interpreter and get a nice implementation of it for a decent core language.
21:26:05 <amz> your message got cut at "those checks fail other that blame s"
21:26:06 <edwardk> the only thing missing is the stuff for dealing with numerical proofs
21:26:18 <edwardk> that blame something
21:26:29 <edwardk> er than blame something
21:27:12 <Berengal> Imperathink is hard
21:27:20 <Berengal> It's the new newspeak...
22:10:32 <MarcWeber> nominolo_: There is a new branch with my updates now called nominolo_master ( 6ca8a ). Maybe you have time to review some of those changes? I still have trouble with BackrgoundTypeCheckFile and component = library
22:11:53 <Nafai> That reminds me.  I need to try out Scion
22:14:23 <MarcWeber> Nafai Which client do you want to use?
22:16:10 <Nafai> emacs
22:16:36 <SamB> what is scion a client for?
22:16:45 <Adlai`> Nafai: ^5
22:18:09 <MarcWeber> SamB Scion should give you background compilation syntax and syntax checking. Scion is a server right now. So the "client" is your haskell editor.
22:18:30 <SamB> ah!
22:18:35 <SamB> so flymake
22:18:39 <SamB> for Haskell
22:19:21 <SamB> but whatever text editor you feel like rather than just emacs?
22:20:30 <MarcWeber> SamB I'm keen on vim because tags support and keybindings are extraordinary.
22:20:37 <Berengal> I was just looking at yi+scion...
22:21:39 <Berengal> Man, haskell is just getting more and more awesome tools these days
22:22:16 <MarcWeber> Berengal: They must appear. Because I think you can't spend days grepping code..
22:22:47 <Berengal> MarcWeber: True, but it has worked somewhat decently thus far :P
22:23:00 <SamB> MarcWeber: sure you can!
22:23:26 <SamB> but I guess you'd rather not have to, at least unless you keep finding what you wanted pretty quickly
22:23:26 <Berengal> My current favorite bit is leksah's module browser
22:23:34 <MarcWeber> SamB: *g* You know what I'm talking about.
22:23:55 <SamB> MarcWeber: yeah!
22:24:02 <SamB> it's never really stopped me before
22:24:28 <SamB> I have a tendancy to bring my mother the wrong thing and (attempt to) hide the right one behind my back ;-)
22:25:10 <MarcWeber> SamB: There are two things which bother me: a) library support b) stack traces. b) is very useful. You just don't have them. If you have a log entry "fromJust .." in an application you know nothing about why it happened.
22:25:35 <SamB> MarcWeber: I know!
22:25:51 <Berengal> I considered writing a stack-trace monad...
22:26:06 <SamB> this is why we should figure out how to allow always building with profiling on without giving up performance ;-)
22:26:38 <MarcWeber> Berengal: Can this be done? Anyway you don't want to use this on production systems for performance reasons? Ah you say it.
22:27:08 * SamB goes to bed
22:28:19 <Berengal> MarcWeber: I was just thinking of something like the already existing Either/ErrorT, except it keeps a tree of errors. If it ever catches one successfully (using <|>) it forgets the previous ones, but if it fails, it adds another branch with the error-tree from the failed handler
22:28:53 <MarcWeber> Berengal: So you add kind of evaluation stack trace?
22:29:07 <MarcWeber> Berengal: This would work. Than you know at least where to look..
22:29:14 <Berengal> MarcWeber: Yep, but only for failed computations
22:29:28 <MarcWeber> Berengal: which failures to catch? That's another issue.
22:30:13 <Berengal> MarcWeber: Well, the only way to introduce an error would be 'throw' or a similar monadic action
22:30:30 <Berengal> And I'd have 'catch' and (<|>) be synonymous
22:30:54 <Berengal> Or something like that, I haven't thought it through completely yet
22:31:09 <mxweas> so the function myFunction (c:cs) = escape c ++ myFunction cs is not tail recursive right? Does this mean it isn't optimized?
22:31:26 <Berengal> mxweas: no, and no
22:31:31 <MarcWeber> Berengal: Then you don't even have to use catch. Something like  addTracePath "myfunc" $ do .. would be enough
22:32:22 <mxweas> Real World Haskell claims "Since the recursive application isn't the last thing the function does, myFunction is not tail recursive
22:32:51 <mxweas> Which is why I'm confused :P
22:33:30 <Berengal> MarcWeber: Yeah, but it'd only remember the failed paths. The leaves are 'throw', the branches are 'catch' where the alternative also failed
22:33:39 <Soushokuon> the biggest advantage to that function is laziness..
22:33:43 <Berengal> If it succeeded it'd simply return the result
22:34:26 * MarcWeber takes a nap/ goes to bed.
22:34:37 <mxweas> hmm
22:35:06 <Berengal> mxweas: tail-recursion is not the end-all-be-all of loops in haskell. Frequently, they're actually blowing up our stacks
22:35:40 <Berengal> My usual example is the tail-recursive foldl and the non-tail-recursive map
22:35:48 <Berengal> > foldl (+) 0 [1..1000000]
22:35:50 <lambdabot>   * Exception: stack overflow
22:36:03 <Berengal> > last $ map (+1) [1..1000000]
22:36:04 <lambdabot>   1000001
22:36:09 <mxweas> So, I shouldn't be afraid of using non tail recursive functions?
22:36:14 <Berengal> Both traverse the entire list
22:37:08 <Berengal> It sort-of-depends on a few things. tail-recursion doesn't have to blow up your stack if you're careful about strictness
22:37:32 <Soushokuon> stacks in Haskell are conceptually different from stacks in, well, most other programming languages.
22:38:20 <Berengal> foldl' is also tail-recursive, but doesn't blow up the stack in the same way
22:38:31 <Berengal> > foldl' (+) 0 [1..1000000]
22:38:32 <lambdabot>   500000500000
22:38:49 <Soushokuon> foldl is tail recursive, but the reason why there's a stack overflow above is the pileup of 1 + 2+ 3+ 4 + 5 + ...
22:39:18 <Berengal> This is because it evaluates the accumulator at each step using seq, so there's never a giant buildup of thunks
22:40:31 <Berengal> The evaluation of foldl goes something like:
22:40:33 <Berengal> foldl (+) 0 [1,2,3,4]
22:40:35 <Soushokuon> unevaluated, 1+2 remains in memory as 1, and 2, and a plus operation. foldl' forces the function to be evaluated so that an actual number, 3, results..
22:40:40 <Berengal> foldl (+) (0+1) [2,3,4]
22:40:51 <Berengal> foldl (+) ((0+1)+2) [3,4]
22:41:00 <Berengal> foldl (+) (((0+1)+2)+3) [4]
22:41:07 <Berengal> foldl (+) ((((0+1)+2)+3)+4) []
22:41:18 <Berengal> ((((0+1)+2)+3)+4)
22:42:01 <Berengal> This final value is what's returned, but when the normal value of that is needed, the stack is blown trying to evaluate it
22:42:16 <taruti> Is it possible to make multiple executables in a cabal file share configuration or has everything be copypasted for each one?
22:43:14 <Berengal> This happens because the first reducible expression is also the innermost one, so the evaluation has to recurse using the stack all the way down to it
22:43:49 <mxweas> ah
22:44:03 <Soushokuon> also, the evaluation strategy does become lots more intuitive with use :)
22:44:05 <mxweas> So if I'm writing a function that will blow up the stack when evaluated. How do I make it not lazy?
22:44:12 <Berengal> foldl' forces the evaluation of these expressions as it recurses
22:44:37 <Berengal> @src foldl'
22:44:37 <lambdabot> foldl' f a []     = a
22:44:37 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:44:59 <Berengal> If you want to write one yourself, use bang-patterns or seq to force the accumulator
22:45:30 <mxweas> so seq is what's making it strict?
22:46:16 <Berengal> seq is strict in both arguments, which means they'll be evaluated to whnf
22:46:19 <Soushokuon> @src Int
22:46:20 <lambdabot> data Int = I# Int#
22:46:48 <Soushokuon> the internals of Int in GHC involve a constructor (same with Integer, although slightly more complicated)
22:47:29 <Soushokuon> if you have 1+2, both 1 and 2 have constructors with the true value inside as an Int#, but the whole expression is just a 1, plus, and a 2. not yet evaluated
22:48:04 <Soushokuon> what seq does here is try and find an outermost constructor... basically whnf, right? :)
22:48:34 <Soushokuon> to do that the (+) operation must be completed, and stack space is reduced in the process. if done repeatedly, there isn't going to be any overflow.
22:48:41 <Berengal> Soushokuon: If what you say is true it wouldn't evaluate the expression. whnf only evaluates until the first constructor
22:49:15 <Berengal> Int (and Integer) can be seen as simple enum-types from a programmer perspective
22:49:24 <Berengal> That is, data Int = 1 | 2 | 3 | 4 ...
22:49:51 <Soushokuon> this argument applies mainly because Int# is primitive
22:50:21 <Berengal> Yeah, at the very least strict
22:50:46 <Soushokuon> the, er, magical fact is that getting the constructor is sufficient to evaluate it all ;)
22:56:19 <joeyadams> > [0,1,2,3] ! 2 -- noob question.  Why doesn't the ! operator work in an initial ghci session?
22:56:20 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
22:57:21 <nyingen> > [0,1,2,3] !! 2
22:57:22 <lambdabot>   2
23:00:00 <nyingen> so I'm trying to use 'sendTo' from Network.ByteString to write the result of encode (from Data.Binary) to a socket
23:00:15 <nyingen> but I get this:
23:00:17 <nyingen>     Couldn't match expected type `Data.ByteString.Internal.ByteString'
23:00:17 <nyingen>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
23:00:17 <nyingen>     In the second argument of `sendTo', namely `(encode msg)'
23:00:30 <mxweas> @src `seq`
23:00:30 <lambdabot> Source not found. My brain just exploded
23:00:35 <mxweas> @src seq
23:00:36 <lambdabot> Source not found. Take a stress pill and think things over.
23:01:15 <mxweas> @src (+)
23:01:15 <lambdabot> Source not found.
23:01:21 <mxweas> @src +
23:01:21 <lambdabot> Source not found. My brain just exploded
23:01:26 <mxweas> :|
23:02:39 <nyingen> it seems that the ByteString type used by Network.ByteString is different from that used by Data.Binary?
23:02:44 <nyingen> how should I rectify that?
23:03:01 <taruti> nyingen: Data.Binary returns a _lazy_ bytestring while Network.ByteString excepts a strict one
23:03:41 <nyingen> taruti: yeah, seems that way
23:03:47 <taruti> nyingen: sendTo socket $ B.concat $ L.toChunks (encode foobar)
23:04:49 <nyingen> taruti: aha
23:04:54 <nyingen> totally missed that 'toChunks' function
23:06:45 <nyingen> taruti: woot, that worked. thanks much
23:08:18 <mxweas> Another thing I've noticed in this book is that some prtStrln lines have a $ and others don't
23:08:28 <mxweas> it seems only the lines with ++ in them start with $
23:08:39 <mxweas> what's $ doing?
23:08:48 <Zao> @src ($)
23:08:48 <lambdabot> f $ x = f x
23:08:58 <Zao> $ is function application, but with low precedence.
23:09:08 <Zao> f $ x y z === f (x y z)
23:09:24 <Zao> Tends to save on parens.
23:09:31 <mxweas> wait so
23:09:42 <mxweas> f $ x = f x makes it look useless
23:09:48 <SubStack> if only!
23:10:17 <Twey> mxweas: putStrLn "foo" ++ "bar" is interpreted as (putStrLn "foo") ++ "bar"
23:10:27 <Zao> The trick is in the precedence, which makes it bind even lighter than regular function application.
23:10:27 <mxweas> ah
23:10:41 <Twey> Whereas putStrLn $ "foo" ++ "bar" is interpreted as (putStrLn) ("foo" ++ "bar")
23:10:45 <Twey> Thanks to $'s low precedence
23:10:54 <mxweas> why not just use putStrLn ("foo" ++ "bar")
23:10:56 <leifw> so what's '.', then?
23:11:09 <Twey> Zao: Regular function application doesn't bind lightly at all :)
23:11:10 <leifw> I never figured out the difference between $ and .
23:11:14 <Twey> It's the most tightly-binding operation
23:11:16 <inimino> @src (.)
23:11:16 <lambdabot> (f . g) x = f (g x)
23:11:26 <pikhq> @src ($)
23:11:26 <lambdabot> f $ x = f x
23:11:35 <Twey> leifw: . allows one to compose two existing functions into a new function that passes the input through both of them
23:11:48 <SubStack> > zipWith ($) (cycle [(+1),(+2)]) $ replicate 4 10
23:11:49 <Twey> > ((*2) . (+1)) 3
23:11:50 <lambdabot>   [11,12,11,12]
23:11:50 <lambdabot>   8
23:12:04 <pikhq> > (*2) . (+1) $ 3
23:12:05 <lambdabot>   8
23:12:08 <Twey> Right
23:12:22 <Zao> I had the same sample typed out, scary.
23:12:23 <Twey> Which is the same as saying (3 + 1) * 2
23:12:25 <leifw> ok that seems to make sense, thanks
23:12:28 <Twey> Zao: Haha, really?  Nice.
23:13:17 <nyingen> mxweas: parens are fine for a couple of function applications, but with something like (f (g (h (i x)))) you'd rather see f $ g $ h $ i x
23:13:17 <mxweas> > (*2) . ((+1) 3)
23:13:18 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
23:13:18 <lambdabot>    arising from the literal `1' at <...
23:13:41 <pikhq> nyingen: Actually, I find f . g . h . i $ x to be much clearer. ;)
23:13:44 <mxweas> nyingen: ah, that makes sense
23:13:54 <nyingen> pikhq: heh
23:14:49 <Cale> nyingen: It's nicer to use function composition since for example in that expression g . h is a well-typed expression, but g $ h will be meaningless.
23:15:13 <mxweas> thanks for the help. I gg
23:15:52 <nyingen> Cale: ah, true
23:55:57 <cjs> Note that $ is also useful with map. If you have a list of functions and you want to apply each to the same argument.
23:56:01 <cjs> > map ($3) [succ, pred, (2*)]
23:56:02 <lambdabot>   [4,2,6]
23:57:04 <Twey> Not so much; id does the task as well
23:57:19 <Twey> > map (`id` 3) [succ, pred, (2*)]
23:57:20 <lambdabot>   [4,2,6]
23:57:28 <elvenporn> > sequence [succ, pred, (2*)] 3
23:57:29 <lambdabot>   [4,2,6]
23:57:32 <Twey> Hehe
23:59:33 <cjs> Hm. Hadn't thought of either of those. Though I still think that mine reads the best. :-)
