00:04:27 <Saizan_> edwardk: it looks like you'd appreciate record notation in types :)
00:04:56 * Saizan_ wonders what the fields are
00:05:16 <ski> `s' and `d' possibly stands for `static' and `dynamic' ?
00:05:24 <hackagebot> filestore 0.3.1 - Interface for versioning file stores. (JohnMacFarlane)
00:06:23 <edwardk> yeah
00:07:24 <edwardk> got bored after answering some guy's question on the -cafe about a tagless interpreter problem, so i thought i'd transcribe the finally tagless implementation into haskell and fiddle with it a bit
00:08:27 <Saizan_> ah, now i recall
00:10:23 <lpsmith> edwardk:  sounds like a lot of fun :-)
00:11:45 <edwardk> lpsmith: it was the first time, then i accidentally hit the up arrow one too many times and copied right over two hours of work or so ;)
00:12:36 <edwardk> so far i've slapped together a pretty printer, partial evaluator, and interpreter
00:12:58 <edwardk> i had a variant that used tagless weak hoas as well
00:14:06 <lpsmith> no undo?!! :-(
00:14:38 <lpsmith> oh well
00:14:46 <edwardk> i popped out of vi, and hit up twice, and the command i hit enter on by reflex was cp Foo.hs Bar.hs ;)
00:14:51 <edwardk> oops
00:15:10 <edwardk> made me get serious and throw it in a repository ;)
00:15:16 <lpsmith> heh
00:15:37 <lpsmith> unix text editors leave a lot to be desired, in my opinion
00:15:42 <lpsmith> I haven't played with YI much yet
00:16:16 <lpsmith> See, emacs would probably save me in that case as I don't close emacs,  and if I copy over the file I still have a buffer :-P
00:16:31 <edwardk> hah
00:16:45 <lpsmith> what about gvim?
00:17:39 <edwardk> i never got used to gvim
00:18:01 <lpsmith> fair enough,  I don't use vim that much either way.
00:18:32 <lpsmith> It really is less modal than emacs though.   It annoys me when people lie and say Emacs is a modeless editor :-P
00:18:43 <lpsmith> keystrokes in emacs are extremely modal
00:19:20 <ivanm> how can emacs be modeless? haskell-mode, auctex-mode, etc. ;-)
00:19:36 <lpsmith> I'm not referring to major modes
00:19:56 <ivanm> emacs also has minor modes
00:20:01 <ivanm> inferior-haskell, etc.
00:20:07 <lpsmith> I'm talking about things like C^X
00:20:09 <lpsmith> those modes
00:20:14 <edwardk> honestly i just use vi because i get away with about half as many keystrokes and my pinky doesn't feel like its going to fall off ;)
00:21:42 <inimino> :sus would have saved you
00:21:44 <inimino> (or ^Z)
00:22:15 <ivanm> hlint just had a parse error! :o
00:22:26 <edwardk> i usually just invoke ghci from inside vim, but i left to spend some time in the other room with my wife =)
00:22:28 <hackagebot> highlighting-kate 0.2.5 - Syntax highlighting (JohnMacFarlane)
00:22:53 <Vq^> ivanm: it's not uncommon in my experience
00:23:05 <ivanm> first time I've had it :(
00:23:26 <Vq^> i've had to modify quite a few sourcefiles to get it to check them
00:24:24 <lpsmith> so does anybody here use yi on a regular basis?
00:36:02 <portnov> @hoogle [a->b] -> a -> [b]
00:36:03 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
00:36:03 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
00:36:03 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
00:36:26 <copumpkin> is <**> just <*> inverted?
00:36:32 <copumpkin> @src (<**>)
00:36:32 <lambdabot> (<**>) = liftA2 (flip ($))
00:39:14 <edwardk> yeah
00:41:15 <mjs22> Anyone know of a way to track down the source of an exception like "Prelude.(!!): index too large" other than running the code under ghci with :trace after :set -fbreak-on-error?  The code runs so slowly under tracing it's going to take hours to reach the point where the error occurs...
00:43:06 <EnglishGent> morning :)
00:43:21 <lpsmith> mjs22:  how big is the program?
00:43:42 <Beelsebob> mjs22: 1) stop using (!!) it suggests you need a different data structure.  2) write (!!!) :: [a] -> Int -> String -> a; (!!!) x y s = trace s (x !! y)
00:43:58 <mjs22> lines of code?  just over 900.
00:44:33 <lpsmith> beelsebob's !!! suggestion might work
00:44:43 <lpsmith> but that much io can really slow stuff down
00:44:50 <lpsmith> you can redefine (!!) too
00:44:59 <lpsmith> instead of changing to !!!
00:45:00 <Beelsebob> it can -- but you're only doing it for debugging
00:45:11 <Beelsebob> who cares how slow it is, as long as you're finding the error
00:46:04 <mjs22> true.  although the IO may not slow it down as much as tracing the entire program in the ghci debugger.  I'll try that.
00:46:15 <lpsmith> well,  I frequently use haskell as a glorified calculator,  and sometimes it takes fully compiled code a while to reach the error
00:46:23 <Beelsebob> also -- if you're using (!!) lot, you're doing it wrong
00:46:39 <Beelsebob> so, yeh
00:46:46 <Beelsebob> there shouldn't be much IO
00:47:07 <mjs22> I only use (!!) in a few places where I couldn't think of a better way to achieve what I wanted.  I avoid it as much as possible.
00:47:08 <lpsmith> depends on the size of the list you are dealing with;  if you know the list is always less than a few elements...
00:47:23 <lpsmith> not that much harm in using (!!)
00:47:25 <Beelsebob> mjs22: *nod* -- so adding traces shouldn't be too bad
00:47:45 <mjs22> off to try the (!!!) idea.  thanks!
00:48:46 <lpsmith> alternatively you should be able to use unsafePerformIO to catch the exception inside (!!!) and then re-raise a new exception with a site-dependent error message...
00:50:02 <ski> @type Control.Exception.mapException
00:50:03 <lambdabot> forall e1 e2 a. (GHC.Exception.Exception e1, GHC.Exception.Exception e2) => (e1 -> e2) -> a -> a
00:50:16 <lpsmith> hmm
00:50:21 <lpsmith> even better
00:50:37 <lpsmith> ski++
00:59:01 <mmorrow_> , (text . utf8enc) "\x2200"
00:59:03 <lunabot>  âˆ€
01:08:09 <mjs22> cool -- that (!!!) suggestion helped.  bug tracked and squashed. :-)
01:21:16 <mxc> hi
01:24:17 <mauke> morning
01:40:01 <briml> I would like to group items in a list in this way. Start with the three first item, put them in a triple (or a list). Then take the next three items and put them in a group and so on. How can this be done?
01:42:42 <mauke> > unfoldr (\x -> if null x then Nothing else Just (splitAt 3 x)) "Hello, world!"
01:42:43 <lambdabot>   ["Hel","lo,"," wo","rld","!"]
01:45:15 <briml> mauke: thx. But how can I put this ito code and expect someone else to understand what's going on I wonder...
01:45:18 <mauke> > groupBy (\_ (n, _) -> n /= 0) . zip (cycle [0 .. 2]) $ "Hello, world!"
01:45:19 <lambdabot>   [[(0,'H'),(1,'e'),(2,'l')],[(0,'l'),(1,'o'),(2,',')],[(0,' '),(1,'w'),(2,'o...
01:45:28 <mauke> > map snd . groupBy (\_ (n, _) -> n /= 0) . zip (cycle [0 .. 2]) $ "Hello, world!"
01:45:29 <lambdabot>   Couldn't match expected type `(a, b)'
01:45:41 <mauke> > map (map snd) . groupBy (\_ (n, _) -> n /= 0) . zip (cycle [0 .. 2]) $ "Hello, world!"
01:45:42 <lambdabot>   ["Hel","lo,"," wo","rld","!"]
01:46:01 <mauke> briml: just do it
01:46:11 <briml> yepp.
01:46:38 <mauke> > map (map snd) . groupBy (\_ (n, _) -> n /= 0) . zip (cycle [0 .. 2]) $ ""
01:46:39 <lambdabot>   []
01:50:05 <Philonous1> > let f [] = []; f xs = take 3 xs : (f $ drop 3 xs) in f [1..20]
01:50:06 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
01:51:06 <Philonous1> Sometimes explicit recursion is more comprehensible
01:51:27 <SubStack> > splitEvery 3 [1..20]
01:51:28 <lambdabot>   Not in scope: `splitEvery'
01:51:32 <SubStack> >_<
01:52:33 <SubStack> it's in Data.List.Split anyways
01:52:53 <Philonous1> > Data.List:Split.splitEvery 3 [1..20]
01:52:54 <lambdabot>   Not in scope: data constructor `Data.List'Not in scope: `Split.splitEvery'
01:53:03 <Philonous1> > Data.List.Split.splitEvery 3 [1..20]
01:53:04 <lambdabot>   Not in scope: `Data.List.Split.splitEvery'
01:54:11 <ski> briml : give it a name (possibly with documentation and/or examples)
01:55:28 <briml> ski: yes I will have to do that. I was hoping that there was already such a function in the standard.
01:55:40 <pcc1> is there a '(Typeable t) => t -> [Language.Haskell.TH.]Type' or do I need to write one myself?
01:56:14 <ski> (briml : possibly there is one in later releases, as Philonous1 seemed to hint)
01:56:41 <SubStack> briml: cabal install split
01:57:19 <RayNbow> @let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
01:57:20 <lambdabot>  Defined.
01:57:49 <RayNbow> > unfoldUntil null (splitAt 3) [1..10]
01:57:50 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
01:59:00 <briml> RayNbow: that is too complicated for such a simple task imho.
02:02:36 <RayNbow> briml: is it?
02:02:54 <briml> RayNbow: imho
02:04:51 <RayNbow> that unfoldUntil isn't much different than using explicit recursion:
02:04:53 <RayNbow> splitEvery _ [] = []
02:04:53 <RayNbow> splitEvery n xs = ys : splitEvery n zs where (ys,zs) = splitAt n xs
02:05:28 <briml> RayNbow: you've got >> and return in there as well.
02:07:40 <mauke> so?
02:07:53 <mauke> that's like saying an OO program is too complicated because it has "new" in it
02:07:53 <RayNbow> unfoldUntil p f = unfoldr (\x -> if p x then Nothing else Just (f x))  -- equivalent definition
02:08:23 <Cale> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1..10]
02:08:24 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
02:08:53 <Cale> It's easier if you're willing to split up the splitAt into take and drop.
02:08:53 <RayNbow> Cale: I wish there was a notNull in the Prelude
02:09:03 <RayNbow> (just like there is a notElem)
02:09:09 <Cale> not . null seems readable enough ;)
02:09:26 <Cale> But maybe... it does seem like a common case.
02:09:55 <RayNbow> but using not . null often requires a pair of ()
02:10:08 <Cale> I mostly end up wishing that we had boolean operators on predicates more than that.
02:10:28 <Cale> (that is, liftM2'd versions of && and || etc.
02:10:30 <Cale> )
02:10:56 <ski> > liftM2 (&&) (Just False) Nothing
02:10:58 <lambdabot>   Nothing
02:12:00 <RayNbow> > let infixl 1 Â«, Â»; (Â«) = flip liftM2; (Â») = ($);    in    Just False Â«(||)Â» Just True
02:12:02 <lambdabot>   <no location info>: lexical error at character '\171'
02:12:14 <RayNbow> hmm...
02:12:30 <RayNbow> I thought this expression used to work
02:13:43 <Cale> > let infixl 1 <*, *>; (<*) = flip liftM2; (*>) = ($) in Just False <*(||)*> Just True
02:13:44 <lambdabot>   Just True
02:14:06 <Cale> It does, it just doesn't like your choice of infix operators for some reason.
02:15:07 * RayNbow doesn't have timestamps in his logs... but lambdabot did accept that expression some time ago
02:15:26 <RayNbow> (some time ago = at least several months)
02:15:43 <briml> mauke: I agree. OO programs tend to get complicated. Thats why I prefer haskell :)
02:16:07 <dsturnbull> haha cale
02:16:20 <dsturnbull> <*(||)*> is on par with perl
02:16:37 <Cale> pig operator?
02:16:43 <dsturnbull> haha
02:17:05 <mauke> now build the goatse operator and you're done
02:17:26 <dsturnbull> map ãƒ˜(^_^ãƒ˜) (ãƒŽ^_^)ãƒŽ [1..]
02:19:44 <Philonous1> What's next? Commutative ascii-art diagrams instead of operators?
02:21:07 <dsturnbull> haha
02:21:10 <EnglishGent> Philonous - I'm still waiting for a language that will let me provide category-diagrams as code....
02:21:10 <EnglishGent> :)
02:24:12 <mauke> http://www.xs4all.nl/~weegen/eelis/analogliterals.xhtml
02:25:57 <RayNbow> > let {(|-) = (<>); (-|) = (<>); tie = text "TIE"; fighter = text "Fighter"; o = text " " }   in   tie |-o-| fighter    -- I was bored... :p
02:25:57 <lambdabot>   TIE Fighter
02:27:31 <ivanm> RayNbow: heh
02:42:39 <Matt325> Is there any way to get something like "thenJust" to work? Where
02:42:39 <Matt325> thenJust b x = if b then Just(x) else Nothing
02:42:41 <Matt325> safeDiv x y = (x /= y) `thenJust` (x `div` y)
02:45:30 <FunctorSalad> > (False `guard` (), True `guard ()) :: (Maybe (),Maybe())
02:45:31 <lambdabot>   <no location info>: parse error on input `('
02:45:51 <FunctorSalad> > (False `guard` Just (), True `guard` Just ())
02:45:52 <lambdabot>   No instance for (Control.Monad.MonadPlus
02:45:52 <lambdabot>                     ((->) (Data.Ma...
02:46:06 <FunctorSalad> meh ;)
02:46:09 <FunctorSalad> @ty guard
02:46:10 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
02:46:16 <ski> Matt325 : maybe you meant s/x \/= y/0 \/= y/ ?
02:46:28 <eu-prleu-peupeu> hi
02:46:45 <eu-prleu-peupeu> where can i read about the ghc rts ?
02:46:48 <FunctorSalad> @let safeDiv x y = guard (x/=y) >> return(x/y)
02:46:49 <lambdabot>  Defined.
02:48:37 <Matt325> ski: Oops, yes
02:48:56 <ski> > let b `thenJust` x = if b then Just x else Nothing; x `safeDiv` y = (0 /= y) `thenJust` (x `div` y) in map (12 `safeDiv`) [24,72,0]
02:48:58 <lambdabot>   [Just 0,Just 0,Nothing]
02:49:27 <dibblego> @seen dcoutts
02:49:27 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow, #haskell-soc and #haskell-iphone. I last heard dcoutts speak 11h 14m 42s ago.
02:49:40 * ski probably should have taken divisors instead of multiples of `12' ..
02:50:07 <Matt325> FunctorSalad: still blows up on division by zero for me
02:50:18 <dsturnbull> http://catseye.tc/projects/quylthulg/doc/quylthulg.html
02:52:25 <Matt325> ... oh, because I'm being stupid and getting the /= 0 bit wrong again
03:04:31 <dibblego> is there a guide to publishing a first haddock package?
03:05:39 <ivanm> dibblego: you mean how to add haddock documentation?
03:05:55 <ivanm> I just went and copied the docs from another package (e.g. xmonad) :s
03:06:08 <dibblego> er hackage (sorry just finished haddocking) :)
03:06:21 <ivanm> ahhh
03:06:31 <ivanm> dibblego: get cabal-install
03:06:48 <dibblego> got that
03:07:04 <ivanm> if "cabal check" doesn't complain, run "cabal sdist" and then "cabal upload path/to/tarball"
03:07:16 <ivanm> you need a hackage account first though
03:07:21 <dibblego> got that
03:07:44 <ivanm> or else you can create the tarball, then upload via hackage's web submission page
03:07:50 <dibblego> great thanks -- though I wish there were a guide -- at least I can't find it
03:07:54 <ivanm> which does cabal check (and some more checks you have to pass)
03:08:00 <ivanm> dibblego: I couldn't find anything :s
03:13:46 <dibblego> ivanm, 400 Error in upload -- then?
03:14:09 <ivanm> :o
03:14:13 <ivanm> try the web interface
03:14:29 <dibblego> righto
03:14:35 <ivanm> might be an extra check that hackage now has that cabal-install doesn't
03:14:41 <ivanm> (e.g. checking upper bound for base)
03:25:31 <ManateeLazyCat> Hi all, if i want read file with UTF8 encode, how to write code? readFile in Prelude can't work. Thanks!
03:26:24 <ManateeLazyCat> Example file contain Chinese character.
03:26:36 <Zao> Read it and use utf8-string or Data.Text to decode it?
03:29:22 <ManateeLazyCat> thanks i try.
03:29:44 <maltem> Doesn't Prelude.readFile *truncate*? (Then it wouldn't work)
03:29:53 <Vanadium> It does not seem to.
03:30:11 <ManateeLazyCat> Looks character haven't decode.
03:30:11 <Zao> maltem: It reads bytes and expands them with zero-fill to Char.
03:30:24 <maltem> Oh ok
03:30:29 <Zao> ManateeLazyCat: It just reads individual bytes into Chars. You need to decode it explicitly.
03:30:51 <ManateeLazyCat> Zao: Example code?
03:30:56 <mxc> hi
03:31:02 <mxc> is anyone actually using yi for day to day work?
03:31:15 <mxc> and, are they familiar with using it in vim mode?
03:31:34 <ManateeLazyCat> mxc: #yi ?
03:31:35 <Zao> http://hackage.haskell.org/package/text http://hackage.haskell.org/package/utf8-string
03:32:17 <Zao> ManateeLazyCat: System.IO.UTF8.readFile "foo.txt"
03:32:23 <Zao> ManateeLazyCat: Requires the utf8-string package.
03:32:26 <mxc> manateelazycat - checked there, mcuh slower channel, was trying here.. thanks though
03:33:02 <Zao> Data.Text is convenient when you already have your bytes in a ByteString or want to encode into one.
03:33:52 <Zao> ManateeLazyCat: There is supposedly some Unicode IO in the works for later GHC releases in the future.
03:34:14 <ManateeLazyCat> Zao: Unicode IO?
03:34:23 <ManateeLazyCat> Zao: That's cool
03:34:32 <Zao> http://www.haskell.org/pipermail/cvs-libraries/2009-June/010890.html
03:35:10 <ManateeLazyCat> Zao: Wow, cool, have implement it?
03:36:13 <ManateeLazyCat> Zao: It will including in next GHC release version?
03:36:41 <Zao> I don't know, I believe it will be in 6.12 or so.
03:37:21 <ManateeLazyCat> Zao: So i still decode UTF8 character explicitly now?
03:37:40 <Zao> Yes.
03:38:01 <ManateeLazyCat> Zao: Thanks for your suggestions, i will try those library to decode UTF8 character. :)
03:40:46 <ManateeLazyCat> Zao: System.IO.UTF8.readFile can wor, thanks! :)
03:40:48 <ManateeLazyCat> work
03:44:17 <hackagebot> Lastik 0.1 - A library for compiling programs in a variety of languages (TonyMorris)
03:46:12 <dibblego> ivanm, why after uploading to hackage there is no haddock generated?
03:47:39 <copumpkin> dibblego: it's done periodically
03:47:55 <dibblego> oh right -- do you know the period?
03:48:01 <copumpkin> dibblego: not immediately upon upload (although I'm not sure how often... at least once a day, maybe twice)
03:48:07 <dibblego> ok cheers
03:48:15 <copumpkin> np
04:07:48 <brian6> can Text.PrettyPrint emit the character '\165' without escaping it?
04:32:39 <hackagebot> AC-HalfInteger 1.1.1 - Efficient half-integer type. (AndrewCoppin)
04:35:15 <lilac> Half-Integers? they're not closed under multiplication...
04:36:39 <lilac> i see, the Num instance rounds down :-/
04:36:55 <evident> hello everybody
04:37:43 <evident> I am having a problem: I have a String and I want to split it at each space and write each word into a [String]... can anybody tell me how to do that?
04:38:16 <evident> i tried with "takeWhile" and "dropWhile" but it doesn't work
04:38:51 <evident> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6510#a6510
04:40:42 <Saizan_> > words "foo bar  baz"
04:40:43 <lambdabot>   ["foo","bar","baz"]
04:41:31 <Saizan_>  splitString dropWhile (\x -> x /= ' ') list == ((splitString dropWhile) (\x -> x /= ' ')) list
04:41:42 <Saizan_> you want  splitString (dropWhile (\x -> x /= ' ') list) instead
04:41:54 <Twey> :t splitString
04:41:55 <lambdabot> Not in scope: `splitString'
04:42:10 <Twey> Ah
04:42:49 <evident> ahh right
04:44:52 <Twey> I wish we could pattern-match more nicely on prefixes
04:45:32 <Twey> foo xs | bar `prefixOf` xs = let rest = drop (length bar) xs in ... just doesn't do it for me
04:45:36 <ski> evident : consider using  span (/= ' ')  instead
04:46:01 <evident> ok works now...
04:46:08 <evident> @ski: what does "span" do?
04:46:08 <lambdabot> Unknown command, try @list
04:46:18 <Twey> :t span
04:46:19 <ski> > span (/= ' ') "ab cd"
04:46:19 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:46:20 <lambdabot>   ("ab"," cd")
04:46:43 <Twey> > groupBy (== ' ') "ab cd ef"
04:46:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> GHC.Bool.Bool'
04:46:50 <ski> `span p' does the work of `takeWhile p' and `dropWhile p', in one function
04:46:50 <Twey> :t groupBy
04:46:51 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
04:46:55 <Twey> Oh, right
04:47:16 <Twey> > groupBy (const (== ' ')) "ab cd ef"
04:47:17 <lambdabot>   ["a","b ","c","d ","e","f"]
04:47:22 <Twey> Bah humbug
04:47:52 <Twey> > groupBy (flip const (== ' ')) "ab cd ef"
04:47:53 <lambdabot>   Occurs check: cannot construct the infinite type:
04:47:53 <lambdabot>    a = a -> GHC.Bool.Bool
04:48:12 <Twey> I'm sure there's some way to do this...
04:48:23 <ski> > (takeWhile (/= ' ') "ab cd",dropWhile (/= ' ') "ab cd")
04:48:24 <lambdabot>   ("ab"," cd")
04:48:29 <Twey> Other than \x y -> (x == ' ') == (y == ' ')
04:48:47 <BONUS> it's nice to do it with unfoldr
04:48:57 <Twey> > groupBy (\x y -> (x == ' ') == (y == ' ')) "ab cd ef"
04:48:58 <lambdabot>   ["ab"," ","cd"," ","ef"]
04:49:05 <Twey> > groupBy (\x y -> (x == ' ') == (y == ' ')) "ab  cd   ef"
04:49:06 <lambdabot>   ["ab","  ","cd","   ","ef"]
04:49:28 <ski> > liftM2 (&&&) takeWhile dropWhile (/= ' ') "ab cd"
04:49:29 <lambdabot>   ("ab"," cd")
04:50:29 <Twey> @let odds [] = []; odds [y] = []; odds (x : y : xs) = x : odds xs
04:50:30 <lambdabot>  Defined.
04:50:36 <Twey> > odds $ groupBy (\x y -> (x == ' ') == (y == ' ')) "ab  cd   ef"
04:50:37 <lambdabot>   ["ab","cd"]
04:50:55 <Twey> @pl \x y -> (x == ' ') == (y == ' ')
04:50:55 <lambdabot> (. (' ' ==)) . (==) . (' ' ==)
04:50:58 <Twey> Ew
04:50:58 <BONUS> > unfoldr (\xs -> guard (not $ null xs) >> let (a,b) = span (not . isSpace) xs in Just (a,dropWhile isSpace b)) "hey ha woo  g g   a"
04:51:00 <lambdabot>   ["hey","ha","woo","g","g","a"]
04:51:03 <Twey> But, hey, Kirbies.
04:52:17 <ski> > unfoldr (\xs -> guard (not $ null xs) >> let (a,b) = span (not . isSpace) xs in Just (a,dropWhile isSpace b)) " a"
04:52:18 <lambdabot>   ["","a"]
04:52:19 <evident> ok thanks... next problem... I don't manage to map an '$' to the end of each String of that list
04:52:28 <Twey> ... uh
04:52:39 <Twey> > map (++ "$") $ words "foo bar baz"
04:52:40 <lambdabot>   ["foo$","bar$","baz$"]
04:52:44 <BONUS> hmm ski ah
04:53:25 <evident> stupid me... I put the dollar in single quotes instead of double quotes
04:53:27 <evident> thanks
04:53:40 <evident> besides that I had it exactly like you
04:53:47 <Twey> evident: ++ takes two lists, which means that, for strings, both its arguments must be Strings
04:55:20 <evident> of course... stupid me... :)
04:56:14 <BONUS> > unfoldr (\xs -> guard (not $ null xs) >> let (a,b) = span (not . isSpace) (dropWhile isSpace xs) in Just (a,dropWhile isSpace b)) " a"
04:56:15 <lambdabot>   ["a"]
04:56:19 <BONUS> woot
04:56:30 <ski> > unfoldr (\xs -> guard (not $ null xs) >> let (a,b) = span (not . isSpace) (dropWhile isSpace xs) in Just (a,dropWhile isSpace b)) " "
04:56:31 <lambdabot>   [""]
04:56:43 <BONUS> ha :D
04:57:00 <BONUS> making a words function is harder than it seems at first glance
04:57:07 <BONUS> quite a few edge cases
04:58:52 <Cale> Twey: Heh, I read what you said without realising that there was someone named evident here :)
04:59:14 <Cale> "Yeah, I suppose that is evident."
04:59:25 <evident> :)
05:02:20 <lilac> what's the language most similar to haskell where laziness is not the default?
05:03:11 <lilac> i ask because i think i'm coming to the realization that i'm not smart enough to write programs in a lazy language ;(
05:03:26 <BONUS> > unfoldr (\xs -> let k = dropWhile isSpace xs in guard (not $ null k) >> let (a,b) = span (not . isSpace) k in Just (a,dropWhile isSpace b)) " "
05:03:27 <lambdabot>   []
05:03:32 <Cale> lilac: maybe one of the MLs?
05:03:36 <BONUS> alright, i think this should be airtight, hehe
05:03:39 <Cale> lilac: But what's the trouble you're having?
05:04:08 <lilac> Cale: the specific issue was this: I was yesterday writing an emulator for the 'universal machine' of the icfpc 2006
05:04:25 <Cale> lilac: Mostly, I've found laziness makes it easier to write programs. You usually have to think a bit differently for efficiency though.
05:04:40 <lilac> Cale: i decided to do it with immutable arrays, and got something which seemed like it should work pretty quickly
05:04:55 <lilac> but then I got a stack overflow and it took me several hours to track it down
05:05:14 <Twey> Cale: Haha :-P
05:05:14 <lilac> turns out that somewhere, i was building a huge thunk (too big to evaluate)
05:05:27 <Cale> lilac: Yes, that's what stack overflow means ;)
05:05:29 <lilac> so i made everything i could see strict, and that didn't help
05:05:50 <lilac> i made a profiling build and used -xc and -hc, and that didn't help either
05:06:01 <Cale> Adding strictness randomly never works. You have to figure out what's being accumulated and not looked at.
05:06:21 <lilac> ok, so perhaps its a tools issue, and perhaps it's an issue with my knowledge of the available tools then
05:06:26 <Cale> If you're using immutable arrays, which array type did you choose?
05:06:32 <Twey> Stack overflows are truly evil little buggers
05:06:41 <lilac> I started with Array and moved to UArray in my push to make things strict
05:06:45 <Cale> okay
05:07:00 <Cale> UArray is probably going to be faster for that sort of thing if it will work anyway
05:07:09 <lilac> except that one of my arrays was Array Word32 (UArray ...) and I couldn't change that to UArray
05:07:19 <Cale> well, yes
05:07:19 <Twey> The type system doesn't catch them, they cause unconditional program death, and what's worse is that they don't appear with small data sets, so chances are a particularly cunning one will slip right through your tests and show up in the field
05:07:20 <lilac> that one turned out to be the problem, incidentally
05:07:33 <Cale> Ah, that should be easy to fix then.
05:07:42 * Twey is scared of stack overflows
05:08:03 <lilac> well, i added a 'seq' and now all is well (apart form the terrible performance from the array copying... but that's irrelevant to the discussion i think)
05:08:09 <Cale> Whenever you insert something into the Array of UArrays, make sure that it is evaluated. That's where you want to put the seq
05:08:11 <Cale> yeah
05:08:51 <lilac> i asked here what people do about stack overflows when i had my problem, tried the suggestions i got to no avail
05:09:10 <lilac> ... and it was only by staring at the code until i found somewhere i was building a thunk and strictifying it that i could fix the bug
05:09:15 <Twey> My approach is currently basically the same as yours
05:09:18 <Cale> The problem was probably that you were defining the new UArrays in terms of the old ones without looking at them, and so an expression saying how to get the new UArray from the old one was building up in the Array element.
05:09:21 <Twey> Scream and put $!s everywhere
05:09:30 <lilac> Cale: yes, i completely understand what was going wrong now
05:09:57 <lilac> but it took me hours, and my approach was basically: 1) make everyting possible strict, until it works, 2) take out strictness until it fails again
05:10:09 <lilac> there has to be a better way.
05:10:31 <lilac> so what's the smart solution to this problem?
05:10:50 <Twey> lilac: http://book.realworldhaskell.org/read/profiling-and-optimization.html
05:10:54 <Cale> It's possible sometimes to get some insight from profiling tools, but looking at the code carefully is usually more effective. Stack overflow means that a value is being accumulated without being looked at for too long.
05:11:09 <lilac> i think it's got to be either 1) find out where the big thunk came from, and/or 2) be strict by default and add laziness only when it's clear that it's a win
05:11:42 <Cale> Laziness really is usually the right default. It's only certain types of processes where strictness is definitely what you want.
05:11:47 <lilac> Cale: looking at the code only worked here because the code was small. in a large program i don't see how that's a practical solution...
05:12:04 <Twey> The second section on space profiling
05:12:55 <Cale> Generally, the type of process which demands things be strict is where you're turning something which is "large", as in having many separately evaluable parts into something which is "small" in that it has few.
05:13:01 <lilac> Twey: perhaps i didn't understand what the profile was telling me, but i did profiling runs as that describes and was unable to solv emy issue
05:14:46 <Twey> You got the graphs?
05:15:00 <lilac> one moment
05:15:12 * lilac reintroduces the bug and reruns...
05:16:24 <LeoD> i had a similar problem, one unevaluated thunk was causing huge memory leaks... the graphs didn't help either :(
05:17:13 <lilac> If -xc actually gave a backtrace showing where the thunks had come from i think it'd be easy to track down such problems
05:17:30 <lilac> i'm not sure whether that's feasible, though
05:18:07 <Cale> I wish we could look at the values of things *as expressions* as the program ran.
05:18:27 <lilac> that would be extremely useful :)
05:18:30 <Cale> It would become immediately obvious if you could look at the expression graph.
05:18:51 <LeoD> yeah that would be pretty awesome
05:21:54 <gwern> Cale: surely there must be a way, I mean aren't the vacuum heaphgraph packages doing basically that?
05:23:06 <Cale> To be honest, I haven't had a chance to look very carefully at vacuum, but most of the graphs which I saw didn't really say very clearly what the vertices were.
05:24:24 <lilac> what does vacuum do for unevaluated nodes?
05:24:54 <Cale> Actually, isn't vacuum strict?
05:25:16 <lilac> http://metafoo.co.uk/images/profile.ps
05:25:23 <Cale> I seem to recall it freezing on  let fix f = f (fix f) in fix (1:)
05:25:24 <lilac> Cale: rnf strict or whnf strict?
05:25:47 <Cale> A strange kind of rnf strict, because it can detect cyclic structures.
05:26:00 <lilac> i've certainly seen it produce diagrams of cyclic values such as x = 1:x
05:26:21 <Cale> (but not ones like that, which use infinite memory when fully evaluated)
05:26:48 <Cale> It's fine with  let fix f = x where x = f x in fix (1:)
05:27:02 <lilac> i suspect it works iff you can force all the thunks in the value
05:27:51 <ski> , vacuum (\_ -> undefined)
05:27:53 <lunabot>  [(0,[])]
05:28:26 <Cale> , vacuum (1 : 2 : undefined)
05:28:29 <lunabot>  luna: Prelude.undefined
05:28:48 <lilac> ski: i wouldn't consider that 'undefined' to be in the value
05:29:06 <lilac> , vacuum (let x = 1:x in x)
05:29:08 <lunabot>  [(0,[1,0]),(1,[])]
05:29:11 <ski> yes .. it's up to the precice definition
05:29:24 <Cale> It's a little sad that we can't evaluate under lambdas actually.
05:29:25 <lilac> , vacuum (let x a = 1:x a in x undefined)
05:29:26 <dibblego> is it possible to start ghci, :load a file, then execute a function all at once?
05:29:31 <lunabot>  Killed.
05:29:57 <ski>  , vacuum (let x a = y where y = 1:x in x undefined)
05:29:59 <ski> , vacuum (let x a = y where y = 1:x in x undefined)
05:30:01 <lunabot>  luna: Couldn't match expected type `[t]' against inferred type `t2 -> t1'
05:30:10 <ski> er, right
05:30:13 <ski> , vacuum (let x a = y where y = 1:y in x undefined)
05:30:16 <lunabot>  [(0,[1,0]),(1,[])]
05:31:01 <Cale> dibblego: perhaps you're looking for  ghc foo.hs -e 'something'
05:31:35 <dibblego> Cale, I don't think so, more like ghci Foo.hs, then somehow execute a function
05:31:44 <lilac> although you can't combine -e with --interactive for reasons i don't understand
05:31:59 <Cale> dibblego: You want it to leave you with a prompt after?
05:32:01 <dibblego> oh wait! you can do that!
05:32:01 <lilac> (that sounds like exactly what you want, and gdb does that)
05:32:23 <lilac> ghc: cannot use `-e' with `--interactive'
05:33:32 <dibblego> Cale, thanks
05:49:07 <lilac> Is there a monad like State, but where the state is known to be a list, with something like 'next :: MonadSupply a m => m a' ?
05:51:47 <mm_freak> lilac: you can implement it in terms of State
05:52:17 <mm_freak> newtype Supply s a = Supply (State [s] a)
05:52:32 <mm_freak> well, actually you don't even need a newtype
05:54:02 <Phyx-> obviously wrong channel, but is there an ML channel? #ML is empty
05:54:30 <pejo> Phyx, depending on your question: #ocaml perhaps?
05:55:26 <Phyx-> pejo: well, it's fairly simple, i figured out most of it, i need either a language reference or to find out what "^" means
05:55:58 <hackagebot> AC-Vector 1.1.1 - Efficient geometric vectors. (AndrewCoppin)
05:58:07 <Cale> lilac: Is MonadSupply not on Hackage?
05:58:36 <Cale> hmm...
05:58:49 <Cale> Seems not
05:58:52 <pejo> Phyx, could it be string concatenation?
05:59:20 <Cale> http://haskell.org/haskellwiki/New_monads/MonadSupply
05:59:23 <Cale> in any case
05:59:45 <ivanm> @seen dibblego
05:59:45 <lambdabot> dibblego is in #haskell, #haskell-in-depth, #xmonad, #functionaljava and #scala. I last heard dibblego speak 10m 24s ago.
06:00:03 <ivanm> dibblego: if no-one else answered, they do nightly build runs of haddock docs IIRC (something like that)
06:00:19 <skorpan> someone else answered
06:01:18 <dibblego> the haddock is built :)
06:01:20 <ivanm> OK then
06:01:25 <dibblego> thanks
06:01:32 <Phyx-> pejo: don't think so, it's used in type definitions
06:01:51 * ivanm was afk, in case you couldn't tell ;-)
06:04:57 <gery> hey everyone, I have a simple haskell question (i think). I have defined a Space as : type Space = [Int]. I have a function f :: Space -> Int, how can i use quickCheck to test it?
06:05:12 <ivanm> depends on what it does
06:05:18 <ivanm> and what it is meant to do
06:05:26 <ivanm> e.g. does test = sum? test = head?
06:05:27 <gery> my problem is that i can't get quickCheck to generate a test sample
06:05:27 <ivanm> etc.
06:05:37 <dibblego> gery, what does the function do with its argument?
06:06:26 <gery> it compute some algebraic invariant (something from algebraic topology). I know the property i want to test, but quickcheck refuse it because it can't generate a "space" sample
06:07:17 <ivanm> gery: what kind of sample do you want?
06:07:24 <ivanm> maybe look at the RWH chapter on Quickcheck...
06:07:35 <Saizan_> gery: do you get a compiler error?
06:07:54 <opqdonut> quickcheck should have an Arbitary [Int] instance...
06:08:17 <opqdonut> (or rather, Arbitary Int and Arbitary a => Arbitary [a])
06:08:22 <maltem> gery: What property do you want to test?
06:08:22 <Saizan_> @check \xs -> reverse (reverse xs) == (xs :: [Int])
06:08:23 <lambdabot>   "OK, passed 500 tests."
06:08:25 <ivanm> opqdonut: he might need one of a certain length...
06:08:35 <ivanm> which is probably what he's having problems with
06:09:39 <Phyx-> - val test = Define `EQALL N X = LEADSTO N TT X`;
06:09:39 <maltem> gery: Or better to ask, what interesting properties does the function have? ;)
06:09:39 <Phyx-> <<HOL message: inventing new type variable names: 'a, 'b>>
06:09:44 <Phyx-> oops
06:09:46 <Phyx-> sorry
06:09:50 <Phyx-> my mouse clicked
06:10:13 <gery> f(x) + f(y) <= f(nub x ++ y) is the property
06:10:19 <gery> i get a compiler error
06:10:59 <evident> can anybody tell me an efficient way to find the longest prefix that is equal in two strings? i.e: longestPref "python" "pythagoras"  -> "pyth"
06:11:29 <gery> hmm, sorry i have to go. i'll come back later with a more precise question
06:11:43 <ivanm> evident: \ x1 x2 -> map fst . takeWhile (uncurry (==)) $ zip x1 x2
06:11:53 <Axman6> damn, beat me to it
06:12:06 <ivanm> :D
06:12:13 <dibblego> > takeWhile (uncurry (==)) $ zip "python" "pythagoras"
06:12:13 <maltem> @check \x y -> let f z = 0 in (f x + f y <= f (nub x ++ y))
06:12:14 <lambdabot>   [('p','p'),('y','y'),('t','t'),('h','h')]
06:12:15 <lambdabot>   "OK, passed 500 tests."
06:12:27 <dibblego> > fst <$> takeWhile (uncurry (==)) $ zip "python" "pythagoras"
06:12:28 <lambdabot>   Couldn't match expected type `(a, b)'
06:12:33 <maltem> (yeah, too late)
06:12:40 <dibblego> > fst <$> (takeWhile (uncurry (==)) $ zip "python" "pythagoras")
06:12:41 <lambdabot>   "pyth"
06:12:52 <ivanm> or just map fst
06:12:55 <ivanm> ;-)
06:14:10 * ivanm thinks "map fst $" is more obvious/readable in what it does than "fst <$>"
06:14:41 <Axman6> yeah, i have no idea how fst <$> works
06:14:53 <ski> fst `map`
06:15:02 <Saizan_> <$> = map there
06:15:13 <ivanm> @src <$>
06:15:13 <lambdabot> f <$> a = fmap f a
06:15:18 <ivanm> @src [] fmap
06:15:18 <lambdabot> fmap = map
06:15:31 <Axman6> ah
06:15:41 <Axman6> >_<
06:24:11 <Baughn> @tell conal I could have happily programmed without FRP, but now I'm forced to build a working reactive clone before I can get started on my own programs. You're horrible. ;_;
06:24:11 <lambdabot> Consider it noted.
06:24:41 <ivanm> Baughn: heh
06:25:44 <pejo> Baughn, why can't you use his code?
06:25:54 <Baughn> pejo: It doesn't work.
06:26:21 <pejo> Baughn, ok, why can't you fix his code instead of cloning the effort?
06:26:58 <Baughn> pejo: Because I think his approach to futures/improving values is fundamentally broken, and also it's so complex and intertwined, it's very hard to even find the bugs, much less fix them.
06:27:05 <Baughn> pejo: Very elegant, though.
06:27:40 <ivanm> Baughn: by "broken" you mean that you don't like his implementation method of FRP?
06:27:51 <Baughn> Yes, notably unamb
06:28:12 <Baughn> It /works/, theoretically, but it's been an enormous source of bugs. More problematically, it's almost inherently inefficient.
06:29:07 <pejo> Baughn, there are alternative implementations of FRP around I think, atleast people write papers about it.
06:29:45 <Baughn> pejo: True, but from what I've seen none of them have the purity of conal's approach.
06:29:52 <pejo> Baughn, could you give me a short reminder what unamb does?
06:30:01 <Baughn> Don't get me wrong. I /like/ reactive, and I want to use that particular interface. I just don't like the implementation.
06:30:14 <Baughn> pejo: unamb :: a -> a -> a
06:30:38 <Baughn> pejo: It evaluates both as in parallel, and picks the one that finishes first. Of course they have to have the same value, assuming they're both computable.
06:30:56 <ivanm> Baughn: ummm.... they have to have the same value? :s
06:31:14 <Baughn> ivanm: If they don't, then unamb breaks referential transparency. We can't have that.
06:31:15 <ivanm> then why wouldn't you just use the faster one?
06:31:26 <Baughn> Well, that's what it does
06:31:32 <ivanm> or is it to look up values in multiple indices or something?
06:31:37 <Baughn> Sometimes you don't /know/ which is faster
06:31:44 <ivanm> ahhh
06:31:50 <ivanm> as in algorithmically?
06:32:00 <ivanm> or it's doing a db lookup or something (so a monadic value)?
06:32:00 <Baughn> A typical use for unamb is "unamb x y" where x and y are both interleaved IO actions
06:32:11 <ivanm> right, that makes more sense then
06:32:12 <Baughn> So they depend on external input
06:32:16 <ivanm> than using unamb for non-monadic values
06:32:29 <Baughn> No, the values are pure. Think unsafeInterleaveIO.
06:32:40 <Baughn> Needless to say, it's very easy to get this wrong. :P
06:32:54 <ivanm> heh
06:33:05 <pejo> Baughn, oh, right. That one must be tricky to get right.
06:33:21 <ivanm> pejo: in terms of how to pick the faster one?
06:33:30 <Baughn> No, that's the /easy/ bit
06:33:37 <ivanm> Baughn: how can the values be pure, if they're IO?
06:33:48 <Baughn> It's been a long-standing source of very subtle bugs, and has uncovered three /GHC/ bugs to my knowledge..
06:33:48 <ivanm> Baughn: then what's the harder bit?
06:34:14 <Baughn> ivanm: They're the same value every time you read them. It's just that reading blocks until they're defined.
06:34:41 <ivanm> >_>
06:34:55 <Baughn> ivanm: For example - unamb is defined in terms of unsafePerformIO. That's fine in itself, ghc does a good job at making uPIO sane, but the thing also /forks two threads/
06:35:12 <Baughn> So those threads need to be killed if it catches an exception, to prevent extra work being done
06:35:23 <ivanm> right
06:35:26 <Baughn> And of course, this means nested use of unamb will /always/ involve exceptions
06:35:47 <ivanm> >_>
06:35:55 <Baughn> But if you later explicitly ask for the inner unamb's value, which got killed earlier, then it needs to restart.
06:35:59 <ivanm> so you can't fold unamb over a list?
06:36:02 <Baughn> ..this was very hard to get right.
06:36:05 <Baughn> Sure you can
06:36:18 <Baughn> As I said, it works nicely - now - but it was hard to get right. :P
06:36:22 <ivanm> oh, wait, involving exceptions is OK as long as you catch and kill the threads?
06:36:32 <Baughn> ..and restart them later. That's the hard bit.
06:36:37 <pejo> Baughn, if it works nicely now, what is the remaining problem?
06:36:44 <Baughn> pejo: I don't trust the code.
06:36:53 <Baughn> pejo: Further, unamb is still /slow/, even if it works now.
06:37:02 <Baughn> pejo: Further, the reast of reactive still doesn't work well.
06:37:03 <ivanm> so you have to be careful that the IO values you pass through are ones that are referentially transparent (db lookup, etc.)?
06:37:06 <Baughn> (Or at all, really)
06:37:21 <Baughn> ivanm: Yes, but that's all internal to reactive, the user doesn't need to worry about it
06:37:32 <ivanm> right
06:37:44 <ivanm> well, if you call unamb with two IOs you have to worry about it ;-)
06:38:04 <Baughn> Right, but the user doesn't call unamb at all. reactive does that, and it uses it in a safe manner.
06:38:17 <ivanm> ahhhh
06:38:25 <Baughn> Anyway, the "IO values" in question have typically been gotten from getChanContents.
06:38:29 <pejo> Baughn, is unamb deterministic?
06:38:31 <ivanm> it's not exported then?
06:38:36 <Baughn> pejo: Yes
06:38:52 <pejo> Ok, now I'm starting to remember. Thanks.
06:38:55 <Baughn> ivanm: Not from /reactive/. Unamb is a separate package. If you use it, you'd better beware. :)
06:39:29 <ivanm> ahhh
06:39:30 <Baughn> Now, the main problem with the use of unamb in reactive is,merging two events of maybe four occurences each forks and kills off /four hundred threads/.
06:39:38 <Baughn> Even in ghc, that's a bit expensive
06:39:55 <ivanm> so you can't blame conal for that then ;) (or does he maintain it?)
06:40:05 <Baughn> He wrote it, yes. :P
06:40:10 <Baughn> @quote micro-conals
06:40:11 <lambdabot> No quotes match. The more you drive -- the dumber you get.
06:40:17 <ivanm> @quote conal
06:40:17 <lambdabot> conal says: The C ADT is implemented simply as String (or char *, for you type theorists, using a notation from Kleene)
06:40:20 <Baughn> @quote conals
06:40:20 <lambdabot> gnuvince says: Contributions to Hackage are measured in ÂµConals
06:40:38 <ivanm> I take it he has a _lot_ of packages?
06:40:42 <Baughn> (He wrote most of hackage)
06:40:56 <ivanm> hackage-the-server or the packages on hackage?
06:41:02 <Baughn> The packages. :P
06:41:10 <Baughn> Well, it might be a slight exaggeration, but you do run into his name a lot.
06:41:13 <ivanm> how many of them are related to FRP?
06:41:23 <Baughn> I'm not sure
06:41:46 <Baughn> Not all that many. unamb was invented for frp, yes, but it has taken on a life of its own.
06:41:54 <Baughn> And the unamb expansion.. what was its name?
06:42:21 <Baughn> lub. reactive doesn't use it at all. Really neat, if a mite.. uh... you'd better have a supercomputer.
06:42:33 <ivanm> heh
06:42:40 <Baughn> Also, of course, reactive/unamb only work right on 6.11
06:42:47 <ivanm> it does? :o
06:42:49 <Baughn> (To the degree the former works at all)
06:42:58 <Baughn> ivanm: I did mention GHC bugs. ;)
06:43:10 <ivanm> heh
06:43:18 <ivanm> OK, so not that they don't _compile_ on 6.10...
06:43:55 <Baughn> Right, using 6.10 just adds extra bugs
06:44:06 <Baughn> 6.10.4 should be fine, once that comes out
06:44:35 <Baughn> IIRC, my last patch to unamb made it /mostly/ work on 6.10.3, reducind the ghc bug to a race condition
06:44:47 <ivanm> wow, the lub page is _so_ informative :s
06:45:00 <Baughn> lub = recursive unamb, basically.
06:45:06 <Baughn> Using unamb to merge two data structures
06:45:43 <Baughn> So lub (0,_|_) (_|_,3) = (0,3)
06:45:54 <ivanm> ahhh
06:47:28 <Botje> uh
06:47:44 <ivanm> huh
06:51:35 <Baughn> pejo: So I'm experimenting with various possible FRP implementations, trying to find one that doesn't seem too horrible for words. ;)
06:53:41 <Baughn> What I lack in theoretical rigor, I'll hopefully make up in vigor
06:54:14 <skorpan> vigor mortis?
06:54:25 <ivanm> heh
06:54:50 <Botje> vigor the friendly vim assistant?
06:55:22 <ivanm> heh
06:55:33 <Baughn> ..paperclip
06:56:08 <ivanm> that was userfriendly, wasn't it?
06:56:43 <Baughn> No, that was microsoft.
06:57:10 * Baughn pre-emptively imports Control.Applicative. I know I'm going to need the thing later. I always do.
06:57:20 <ivanm> Baughn: you serious?  I thought that came from a userfriendly comic as a joke... >_>
06:57:24 <dcoutts> @seen TomDB
06:57:25 <lambdabot> I haven't seen TomDB.
06:57:34 <Baughn> ivanm: Oh, it's a joke all right, but not user friendly's.
06:57:50 <Baughn> ivanm: The office assistant really /was/ that obnoxious when introduced.
06:58:07 <ivanm> for vim? :o
06:58:18 <ivanm> (I know about the office one...)
06:58:19 <Baughn> It kept telling me to switch to office. ;_;
06:58:28 <Twey> Hahahaha
06:59:00 <ivanm> never realised there was an actual microsoft release of it
06:59:06 <ivanm> IIRC, someone made one as a joke...
06:59:44 <Baughn> There wasn't. I didn't realize you meant vim.
06:59:57 <Baughn> But if there had been, it would no doubt tell me to switch to office.
06:59:59 <Botje> "it looks like you're writing a complex Haskell program. Do you want me to mail dons?"
07:01:02 <Baughn> Nobody'd be annoyed at a nanoseconds-since-1970 Int64 representation of time, right?
07:01:41 <Baughn> ..and there'll never be more than 10^9 events per second. There had /better/ not be.
07:02:06 <tromp> i guess it's slightly more practical than a 256 bit phemtoseconds since bigbang...
07:02:14 <Axman6> > 1/(10^9
07:02:16 <Baughn> Well, it's a signed integer
07:02:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:02:17 <Axman6> > 1/(10^9)
07:02:18 <lambdabot>   1.0e-9
07:02:25 <Axman6> >_<
07:02:27 <ivanm> http://en.wikipedia.org/wiki/Vigor
07:02:27 <LeoD> haha
07:02:59 <ivanm> there's also a gif animation IIRC
07:03:07 <Baughn> ..oh Beatrice, why have you abandoned me? ;_;
07:08:41 <Axman6> > [1,2,3] *> [4,5]
07:08:42 <lambdabot>   [4,5,4,5,4,5]
07:08:43 <dsouza> ivanm: there is: http://www.aei.mpg.de/~pau/vi_fitxers/vi-assistant.gif
07:09:08 <ivanm> dsouza: yeah, that's the one I was thinking of
07:09:38 <Axman6> > [1,2,3] <* [4,5]
07:09:39 <lambdabot>   [1,1,2,2,3,3]
07:10:09 <Baughn> @type (<*)
07:10:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
07:12:29 <Baughn> @src (<*)
07:12:29 <lambdabot> (<*) = liftA2 const
07:12:33 <dschoepe> I have a Haskell program that outputs a line every second. When run normally, it outputs just fine, but when I try to pipe the output to another program that consumes it line-wise(like dzen2), nothing is shown. How do I fix this?
07:12:51 <Baughn> dschoepe: Set it to line-buffered mode, or explicitly flush after each line
07:13:07 <Baughn> dschoepe: Line-buffering is the default when writing to a terminal, but not for pipes
07:13:09 <Axman6> @hoogle setLifeBuffering
07:13:09 <lambdabot> No results found
07:13:17 <Baughn> @hoogle setBuffering
07:13:17 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
07:13:18 <Axman6> @hoogle buffering
07:13:18 <lambdabot> System.IO BlockBuffering :: Maybe Int -> BufferMode
07:13:18 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
07:13:18 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
07:13:21 <dschoepe> Baughn: Thanks
07:19:30 <Axman6> how interesting, doing a :m +GHC.Conc then running myThreadId a number of times returns increasing values
07:20:56 <lilac> which is preferred these days, mtl or transformers?
07:21:04 <EvilTerran> Axman6, i'd wildly speculate that expressions entered at the ghci prompt are evaluated in their own thread, so they can be killed without the rest of ghci dying
07:21:19 <Axman6> yeah, i was thinking the same thing
07:23:30 * Baughn has "fun" with global variables
07:26:08 <LeoD> @hoogle IO Int
07:26:08 <lambdabot> Did you mean: :: IO Int /count=20
07:26:08 <lambdabot> package interleavableIO
07:26:08 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
07:26:48 <lilac> @hoogle :: IO Int
07:26:48 <lambdabot> Data.Typeable typeRepKey :: TypeRep -> IO Int
07:26:48 <lambdabot> Prelude readLn :: Read a => IO a
07:26:48 <lambdabot> System.IO readLn :: Read a => IO a
07:27:05 <LeoD> ah
07:27:23 <lilac> something specific you're after? we have some nice 'return 42's in stock
07:28:09 <LeoD> i was searching for a way to get some kind of time-value to initialize a random generator, but i just remembered that SDL has getTicks
07:28:33 <lilac> @type randomIO :: IO Int
07:28:35 <lambdabot> IO Int
07:28:36 <dankna> isn't getTicks time since application start?  if so, it's not suitable for that because it will always be a value near zero
07:28:44 <LeoD> oh
07:28:55 <dankna> but I'm not certain it is, I'm going by memory
07:28:57 <Baughn> LeoD: System.Random is automatically initialized, you can use that as-is
07:29:02 <LeoD> ah great :)
07:29:20 <EvilTerran> more "fun with global variables" :P
07:29:34 <LeoD> so i don't even need to find a way to convert Word32 to Int :P
07:29:51 <Baughn> > fromIntegral (32 :: Word32) :: Int
07:29:52 <lambdabot>   32
07:30:12 <Baughn> > fromIntegral (2^60 :: Int) :: Word32
07:30:13 <LeoD> huh, that complained for me... guess i did something wrong there
07:30:13 <lambdabot>   0
07:33:39 <Axman6> hmm, i have a feeling i could write a STM library using my AVar package
07:34:35 <nainaide> I spent much time, but still can  not understand "state monad"
07:35:06 <Axman6> nainaide: it's a bit brain twisty for me too
07:35:12 <Axman6> i think i understand how it works though
07:35:32 <Axman6> nainaide: what's the problem?
07:35:36 <nainaide> In state monad definiton:  (State x) >>= f = State $ \s -> let (v,s') = x s in runState (f v) s' ,  why  (State x) only has one argument ?
07:35:59 <nainaide> and why State $ something?
07:35:59 <Axman6> @src State
07:35:59 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:36:19 <Axman6> :t State
07:36:20 <lambdabot> forall s a. (s -> (a, s)) -> State s a
07:36:20 <nainaide> newtype State s a = State { runState :: (s -> (a,s)) }
07:36:55 <Axman6> State only has one field, a function from a state to a state, contents pair
07:36:58 <nainaide> Axman6, you can find the definition from http://www.haskell.org/all_about_monads/html/statemonad.html
07:37:53 <Axman6> so that's whyt it's State x
07:37:57 <Philonous> nainaide: Every value of type State a is a function that takes an old state and returns a result and a new state. It's just wrapped in a newtype so you can make it a monad instance
07:38:42 <Axman6> @src State return
07:38:42 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:38:56 * Axman6 stabs lambdabot for being unhelpful
07:39:08 <Twey> Â« The definition shown here uses multi-parameter type classes and funDeps, which are not standard Haskell 98. Â»
07:39:20 <Twey> Where does it use fundeps?
07:39:24 <Twey> I see nothing unusual
07:39:25 <nainaide> Twey, yes mult-parameter
07:40:03 <Axman6> nainaide: so do you understand the definition of >>=?
07:40:17 <nainaide> Twey,  (State x)  is State s x ?
07:40:26 <nainaide> Axman6, yes
07:40:39 <Axman6> State x is patern matching
07:40:42 <Axman6> pattern*
07:41:16 <Twey> nainaide: No â€” â€˜State s aâ€™ is referring to the type, while â€˜State xâ€™ is referring to the value
07:41:38 <nainaide> Axman6,  did you mean x in "(state x)" match the s in "instance Monad (State s) where " ?
07:41:46 <Axman6> no
07:42:07 <Axman6> it assigns x to the function inside the State constructor
07:42:36 <nanothief> Is there a way to get cabal to install all the haddock documentation for all installed packages?
07:42:37 <Twey> nainaide: â€˜State sâ€™ is equivalent to â€˜Maybe aâ€™ and â€˜State xâ€™ is equivalent to â€˜Just xâ€™
07:42:47 <Twey> They're completely different things that just happen to have the same name
07:43:36 <nainaide> Twey,  Just only has one paramernt, while data constructor State has two
07:43:48 <Axman6> no it doesn't
07:43:59 <Axman6> the _type_ has two, the constructor doesn't
07:44:00 <Twey> No, it has only one
07:44:01 <Twey> Right.
07:44:07 <Woof> > ln (exp 1)
07:44:10 <lambdabot>   1.0
07:44:12 <Woof> : D
07:44:12 <nainaide> newtype State s a = State { runState :: (s -> (a,s)) }
07:44:14 <Twey> But that's not really relevant to the point I was making.
07:44:16 <Woof> Look Twey, fixed
07:44:30 <nainaide> I had been thought there are two.
07:44:33 <nainaide> :)
07:44:35 <Axman6> nainaide: the State constructor has one element in it, called runState
07:44:36 <Twey> Woof: :)
07:44:38 <Twey> Very good
07:45:01 <Twey> nainaide: The left is the type, the right is the value
07:45:15 <Twey> The type constructor has two type arguments, named s and a
07:45:23 <nainaide> yes, only one runState, but runState has two
07:45:25 <Twey> The value constructor has only one argument, named runState
07:45:35 <Axman6> type Foo = Foo {x :: Int, y :: String}, here, Foo is the type, and also the constructor name, for something that contains an Int called x, and a string called y
07:45:36 <nainaide> I am confusing how to understand runState
07:46:05 <Philonous> nainaide: That's just record syntax. runState just unwraps the contained function from the newtype
07:46:10 <Axman6> nainaide: runState is a function of type s -> (a,s)
07:46:11 <Twey> nainaide: runState takes only one argument, too.
07:46:34 <Twey> The s and a referenced here are the types passed in as the type arguments on the left-hand side
07:46:53 <Axman6> nainaide: the definition of State could be written: newtype State s a = State (s -> (a,s)); runState (State x) = x
07:47:09 <nainaide> yes!!! the type a confuses me
07:47:49 <Axman6> nainaide: do you understand what newtype State s a = State (s -> (a,s)) means?
07:49:00 <nainaide> I think the data constructor State consume one type of s and return a tuple with one type of a and one type s
07:49:36 <nainaide> right?
07:49:39 * EvilTerran grumbles about the confusingness of conventional data declerations
07:49:51 <Axman6> no, the constructor State contains a functiong which consumes an s, and returns a (a,s) pair
07:50:10 <SamB> nainaide: no, but the syntax there *is* rather horrible
07:50:16 <EvilTerran> nainaide, not quite, it means the data constructor State takes something of type "s -> (a,s)" and returns something of type "State s a"
07:50:17 <Axman6> indeed
07:50:37 <SamB> hmm, is there a GADT syntax for record constructors?
07:50:50 * EvilTerran prefers GADT syntax, in which case it'd be "data State s a where State :: (s -> (a,s)) -> State s a"
07:50:54 <nainaide> EvilTerran,  good
07:51:16 <EvilTerran> SamB, i think so; that'd be "data State s a where State { runState :: s -> (a,s) } :: State s a"
07:51:49 <SamB> EvilTerran: that *was* the only syntax I could think of
07:52:00 <Axman6> nainaide: basically, the State constructor is just a wrapper around a function
07:52:09 <SamB> ... but is it implemented ?
07:52:17 <Axman6> data Foo a b = Foo (a -> b)
07:52:34 <EvilTerran> SamB, i think so; not sure...
07:52:49 <nainaide> About the record syntax in newtype State s a = State { runState :: (s -> (a,s)) } ,  how does the State s a constructed?
07:53:24 <nainaide> for example first State construct a function runState, then ?
07:53:40 <Axman6> State s a is a type. you can construct something of type State Int String by using something like return 1
07:53:50 <EvilTerran> nainaide, "newtype Foo ... = Bar { runIt :: ... }" is pretty much equivalent to "newtype Foo ... = Bar (...); runIt (Bar x) = x"
07:54:10 <Axman6> which would return State (\s -> (1,s))
07:54:10 <EvilTerran> nainaide, aside from the fact that using record syntax in the definition lets you use it when using the type, anyway
07:54:34 <EvilTerran> nainaide, so "newtype State s a = State (s -> (a,s))" would give you an equivalent type to the record-syntax version
07:54:53 <EvilTerran> nainaide, in that both give you the constructor "State :: (s -> (a,s)) -> State s a"
07:55:17 * Axman6 dislikes the use of record syntax in a lot of things like State. it just adds confusion when there's only one element in the constructor
07:55:31 <skorpan> indeed
07:56:11 * EvilTerran agrees
07:56:40 <nainaide> Axman6, yes!!!
07:56:40 <Axman6> urgh, i have conflictig definitions of the State monad from different libraries: mtl and monads-fd >_<
07:56:51 <Heffalump> Axman6: this is why we want to introduce the transformers package
07:57:04 <nainaide> EvilTerran, so whenever I define a data has "State s a" type  I have a function, named runState at the same time ?
07:57:11 <Heffalump> oh, though monads-fd+transformers is precisely what we want to replace mtl
07:57:15 <Heffalump> where are you running into it?
07:57:33 <Axman6> trying to :m Control.Monad.State in ghci :\
07:57:43 <Axman6> +*
07:58:25 <Heffalump> ah, so you should just ghc-pkg hide one, then
07:58:33 <Axman6> which one?
07:58:49 <hackagebot> AC-Colour 1.1.1 - Efficient RGB colour types. (AndrewCoppin)
07:58:51 <EvilTerran> nainaide, not sure what you mean. "newtype Foo = Bar { runBar :: Baz }" would give you the constructor, Bar :: Baz -> Foo, and the selector, runBar :: Foo -> Baz
08:00:38 <Heffalump> Axman6: I'd suggest trying to use monads-fd+transformers
08:00:48 <Heffalump> though mtl is still the one in the platform etc
08:00:53 <Heffalump> but hopefully that'll get changed
08:01:16 <Axman6> huh?
08:01:24 <Axman6> i just want to play with state >_<
08:01:34 <Axman6> nainaide: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6516#a6516
08:02:18 <nainaide> Axman6,  thanks, very clear.
08:02:19 <Heffalump> Axman6: hide mtl.
08:03:12 <nainaide> EvilTerran,  what does the selector mean here ? It seems I did not read about it by now.
08:03:24 <Axman6> thanks
08:05:14 <Baughn> @pl map fromJust $ takeWhile isJust
08:05:15 <lambdabot> map fromJust (takeWhile isJust)
08:05:55 <nainaide> Axman6,  why runState (State x) = x ?     I hate record syntax!
08:06:26 <Axman6> nainaide: i was explaining that record syntax is just shorthand for what i wrote
08:06:37 <Axman6> and it makes things confusing, as you're finding out
08:07:01 <Botje> just remember that runState :: State s a -> s -> a
08:07:05 <Botje> that's all you have to know :)
08:07:19 <Axman6> State s a -> s -> (a,s)* ;)
08:07:28 <Botje> err, yes, of course :)
08:07:53 <nainaide> :)
08:08:52 <nainaide> newtype State s a = State (s -> (a,s)) mean newtype State s a = State (\s -> (a,s)) ?
08:09:21 <Axman6> no
08:09:26 <opqdonut> nainaide: State is a constructor that takes in something of type "s -> (a,s)"
08:09:28 <opqdonut> :t State
08:09:29 <lambdabot> forall s a. (s -> (a, s)) -> State s a
08:09:30 <Axman6> you';re confusing types and constructors
08:09:51 <nainaide> yeah
08:10:07 <Axman6> but close, yes
08:12:29 <nainaide> Axman6, I think I am closing to the end. :)
08:12:46 <Axman6> so am i, i'm off to sleep. night all
08:13:02 <nainaide> good night
08:13:22 <nainaide> Axman6, thanks
08:18:23 <dcoutts> nanothief: you can set that haddock docs are generated by default for all packages you subsequently install, just edit the ~/.cabal/config file
08:18:36 <defun> Hi. After four months of using haskell enthusiastically, it has beome quite apparent that haskell is well-suited for DSLs and for creating combinators. My question is this: Has anyone tried making a 'GUI combinator', where widgets are treated as functions, but can be combined into bigger widgets. i.e. (button "open" `nextTo` button "close")
08:19:03 <defun> Or rather six months...
08:19:17 <nanothief> dcoutts, ahh right thanks!
08:20:16 <Saizan_> defun: conal's tangible values is an example of that, iirc
08:21:06 <defun> googling now...
08:21:15 <Philonous> Are data Foo x = Bar x and newtype Foo x = Bar x semantically equivalent?
08:22:09 <Twey> defun: Plenty
08:22:24 <Heffalump> Philonous: no
08:22:35 <Heffalump> data Foo x = Bar !x is closer, but still not quite the same
08:22:55 <Philonous> Newtypes are strict? That's strange
08:23:05 <Twey> Of course they are
08:23:07 <Twey> They're unboxed
08:23:08 <ziman> Heffalump, where's the difference if you make the data strict?
08:23:08 <Heffalump> no, since they have no runtime overhead they have to be strict
08:23:18 <Heffalump> ziman: it's to do with the semantics of pattern-matching
08:23:34 <Twey> Remember that it's only to WHNF, though.
08:23:35 <Philonous> Ah, right, they can't be laszy.
08:23:41 <defun> Twey: where can I find others, aside from Conal's TVs (which looks pretty cool, BTW). Thanks.
08:23:50 <Heffalump> if you match the pattern (Bar _) against _|_, with the newtype the match will succeed, and with the data it will fail
08:24:08 <ziman> oh, i see, thanks
08:24:19 <ziman> interesting
08:24:40 <Twey> defun: http://haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries#High-level
08:25:51 <Heffalump> (by fail I mean diverge, rather than fail)
08:25:57 <Philonous> So newtype is in fact less strict than data with strictness annotation
08:26:31 <Heffalump> not really
08:27:11 <pejo> Heffalump, how can a match succeed if it's something compared with bottom?
08:27:23 <Twey> Because you don't need to compare _
08:27:54 <Philonous> I guess the compilers optimizes away the actual matching because newtype has to match in any case
08:27:55 <pejo> Doh, of course.
08:27:59 <ziman> because pattern matcching on newtypes is NOP :) there's no runtime discrimination of the contructors
08:28:28 <Heffalump> pejo: because it's newtype and has no runtime existence
08:28:31 <lilac> the newtype contains Bar _|_ but not _|_; the strict data contains _|_ but not Bar _|_
08:29:28 <ski> (`Bar _|_' is the same as `_|_', if `Bar' is a `newtype' data constructor)
08:29:29 <ziman> that's a nice way to put it :)
08:30:59 <ski> (defun : there's also the old Fudgets)
08:33:15 <masak> what's happening with Haskell' ?
08:35:46 <CalJohn> Does GHC optimise using the fusion law for catamorphisms?
08:38:43 <Gracenotes> for list catamorphisms (foldr)? yes..
08:39:06 <Gracenotes> hm.. which fusion law
08:40:17 <monochrom> â™¡ Haskell
08:40:48 <byorgey> masak: very little at the moment.  the new plan is to put out incremental updates to the standard, not sure exactly when that will happen though.
08:40:54 <CalJohn> Gracenotes: there is more than one?  I mean the one where folds can be combined (ie: so you might traverse the structure only once?)
08:41:24 <byorgey> masak: the problem (as I see it) is that Haskell isn't quite so new and exciting anymore, no one is too interested in sitting around and hashing out standards documents.
08:41:38 <Twey> Heh
08:41:40 <masak> byorgey: what's the feature, in you opinion, one should look forward to most in Haskell'?
08:41:46 <Gracenotes> CalJohn: well, folds are combined with maps
08:42:02 <Twey> Yes, Haskell' is deliberately not an exciting standard.
08:42:08 <CalJohn> Gracenotes: maps are folds...
08:42:14 <Botje> masak: the bloody nad extremely violent death of n+k patterns!
08:42:14 <masak> sad to hear that.
08:42:23 <Twey> Botje: Noooooo....
08:42:25 <masak> Botje: :)
08:42:26 <Gracenotes> CalJohn: oh! That is true.
08:42:27 <byorgey> masak: well, keep in mind that Haskell' won't introduce anything that doesn't already exist.  It's just standardizing features that have already been implemented.
08:42:37 <masak> I see.
08:42:45 <Botje> Haskell': there will be blood.
08:42:51 <Botje> i'd go watch that movie.
08:43:10 * Twey will root for the poor innocent little n+k patterns.
08:43:16 <Botje> :)
08:43:19 <CalJohn> I suspect industry is more interested in standardising haskell' than academia.  You might find people who turn up to CUFP might decide to to it themselves
08:43:22 <masak> then I'm not so surprised that it's hard to make people enthusiastic about it.
08:43:24 <byorgey> @remember Botje "Haskell': there will be blood."  i'd go watch that movie.
08:43:24 <lambdabot> It is forever etched in my memory.
08:43:31 <masak> if it's only a formalisation of existing things, I mean.
08:43:41 <byorgey> masak: exactly.
08:44:17 <masak> maybe Haskell is already in a kind of sweet spot, feature-wise.
08:44:17 <Heffalump> CalJohn: I doubt it
08:44:21 <Gracenotes> CalJohn: well, GHC does do map fusion and foldr/map fusion, and with the common 'build' function it can incorporate quite a few other list functions too...
08:44:30 * Twey in fact thinks that we should define patterns on some other mathematical functions, too.
08:44:38 <Heffalump> well, Galois was responsible for kicking off the H' process
08:44:39 <Heffalump> but they haven't done all that much since
08:44:59 <Heffalump> I think most other industrial users don't have enough people to spend time on it
08:45:05 <masak> Galois, is that a company?
08:45:06 <balor> I have a RunTests.hs file and a TestA.hs file.  In RunTests.hs I want to call "runTestTT TestA.test1". Do I have to declare TestA as a module and import it into RunTests?
08:45:09 <Gracenotes> like filter, repeat, take,etc.
08:45:09 <Heffalump> masak: yes
08:45:47 <Gracenotes> not to mention the deforesting that's also done...
08:45:58 <Twey> GHC does deforesting?
08:46:01 <Twey> GHC doesn't do deforesting
08:46:03 <Twey> Does it?
08:46:10 <Twey> I thought that was the whole point behind Supero.
08:46:23 <Gracenotes> I thought it did at higher optimization levels. o_O
08:49:21 <Gracenotes> ah well. RULES is pretty good by itself.
08:49:55 <Heffalump> GHC does do foldr/build deforestation
08:50:06 <Heffalump> it doesn't do "proper" deforestation
08:50:10 <Twey> *nod*
08:50:27 <SamB> Heffalump: still stuck with foldr/build, are we?
08:50:35 <Gracenotes> I take it Supero does other kinds of deforestation? like trees?
08:50:36 <SamB> streams are cooler
08:50:58 <Heffalump> SamB: yes, not sure where dons+dcoutts are with getting that into GHC
08:51:02 <Gracenotes> is it correct with seq/rnf?
08:51:03 <Heffalump> Gracenotes: yes, implicitly
08:51:12 <Heffalump> Gracenotes: which, streams or Supero?
08:51:15 <Gracenotes> (can't see the forest for the trees >_>)
08:51:17 <Gracenotes> Supero
08:51:21 <SamB> Gracenotes: supero is just an optimizer
08:51:27 <Heffalump> no idea, but I'd hope so
08:51:50 <SamB> it doesn't involve so much human error as RULES
08:52:08 <SamB> at least, that's the impression I got from ndm ;-)
08:53:21 <Heffalump> it's also not really usable IIUC
08:53:28 * EnglishGent wonders if SamB is having problems with RULES & a buggy AE35 unit....
08:53:29 <EnglishGent> :)
08:53:33 <EnglishGent> hello all :)
08:53:36 <SamB> EnglishGent: nope
08:53:57 <SamB> EnglishGent: I just know that it's easy to transform _|_ into non-_|_ with RULES
08:54:57 <EnglishGent> arguably in some cases that makes sense... (sum (map \n -> 1/n [1..])) -> 2
08:54:58 <EnglishGent> :)
08:55:14 <SamB> EnglishGent: well, you can certainly argue about it
08:55:31 * EnglishGent confesses he isnt sure what RULES is -- but assumes some form of re-writing system
08:55:34 <SamB> but I don't think THAT particular sum is ever likely to be optimized like that
08:55:41 <SamB> EnglishGent: precisely
08:55:53 <SamB> "some sort of" is definately the word
08:56:03 <ski> (EnglishGent : that should diverge ..)
08:56:06 <SamB> well, three words
08:56:27 <SamB> ski: never mind the incorrect syntax ;-P
08:56:32 <SamB> needs a couple of parens
08:56:37 * ski didn't mind it
08:56:48 <EnglishGent> beh.. \n -> 1/n^2
08:56:52 <ski> the harmonic series nevertheless diverges ..
08:57:15 <ski> EnglishGent : itym `\n -> 1 / 2 ^ n' ?
08:57:17 * EnglishGent has just woken up from a snooze & obviously still doesnt have brain in gear :|
08:57:19 <SamB> anyway, that's obviously just because he gave slightly the wrong formula
08:57:37 <SamB> yeah, I think ski has it ;-)
08:58:21 <ski> (and with `[1..]', that then "should" converge to `1', not `2')
08:58:52 <EnglishGent> you sure? becuase 1/1 ^ 2 -> 1
08:59:03 <EnglishGent> and 1/2 + 1/4 + 1/8 + ... -> 1
08:59:20 <SamB> 1/1 ^ 2 = 1, not -> 1 ;-P
08:59:41 <ski> > sum (map (\n -> 1 / 2 ^ n) [1..1000])
08:59:42 <lambdabot>   1.0
08:59:45 <ski> > sum (map (\n -> 1 / 2 ^ n) [0..1000])
08:59:47 <lambdabot>   2.0
08:59:54 <Heffalump> EnglishGent: 1/ (1^2) = 1/2
09:00:01 <Heffalump> IM
09:00:05 <Heffalump> EnglishGent: 1/ (2^1) = 1/2
09:00:10 * Heffalump gives up
09:00:41 * EnglishGent stands corrected
09:00:43 <burp> > sum (map (\n -> 1 / 2 ^ n) [1..54])
09:00:45 <lambdabot>   1.0
09:01:16 <ski> it would be nice if there was a real number type (sortof) where there was other approximations than `_|_' and fully defined values
09:01:29 * ski seems to recall reading a paper about that
09:01:55 <ziman> isn't CReal that kind of thing -- lazy on-demand precision?
09:01:59 <ski> there would be an operation
09:02:13 <ski>   bound :: (Rational,Rational) -> Real -> Real
09:02:39 <ski> where the output is constrained to be between the two rational bounds .. but otherwise is the real input
09:03:29 <ski>   bound (lo,hi) x = toReal lo `max` (toReal hi `min` x)  -- semantically
09:03:39 <Twey> Where is CReal?
09:03:57 <ski> so you could then write interval-halving binary search using this
09:05:19 <balor> Simplifying my question: From file "Foo.hs" how can I call function "baz" in "Bar.hs"? Must I declare "module Bar where ..." in Bar.hs and "import Bar" in Foo.hs?
09:06:15 <Heffalump> balor: yes
09:06:24 <balor> Heffalump: thanks.
09:06:31 <Heffalump> you can also use explicit import and export lists, but what you describe is simplest
09:06:40 <ski>   search f (lo,hi) = bound (lo,hi) (ifB (f mid > 0) (search f (lo,mid)) (search f (mid,hi)))
09:06:43 <ski>     where mid = (lo + hi) / 2
09:12:18 <burp> > sum (map (\n -> 1 / 2 ^ n) [1..100]) :: CReal
09:12:19 <lambdabot>   0.9999999999999999999999999999992111390948
09:12:27 <burp> > sum (map (\n -> 1 / 2 ^ n) [1..200]) :: CReal
09:12:29 <lambdabot>   1.0
09:12:35 <burp> uh o0
09:12:41 <ski> > let x = min 0 (max 0 x) in x :: CReal
09:12:46 <lambdabot>   mueval-core: Prelude.read: no parse
09:12:46 <lambdabot>  mueval: ExitFailure 1
09:12:47 <ski> > min 0 (max 0 undefined) :: CReal
09:12:48 <lambdabot>   * Exception: Prelude.undefined
09:14:04 <ski> > showCReal 70 (sum (map (\n -> 1 / 2 ^ n) [1..200]) :: CReal)  -- burp
09:14:06 <lambdabot>   "0.9999999999999999999999999999999999999999999999999999999999993776984722"
09:14:11 <burp> ah ok
09:14:59 <pejo> Gracenotes, I think Supero supports whatever yhc supports (H98 + some extensions, I'm guessing).
09:16:20 <pejo> SamB, it's really quite tricky to change termination properties in a lazy language with supero-like transformations, it's essentially an evaluator for open terms.
09:19:22 <EnglishGent> beh :|
09:20:08 <SamB> pejo: you sounds as if you think I might *like* to change termination properties with supero
09:20:33 <EnglishGent> hi again
09:20:52 <pejo> SamB, I've heard people argue that non-terminating programs are uninteresting, so we should therefore focus our effort on the terminating ones.
09:20:55 * EnglishGent thinks his computer is still groggy as well :|
09:21:22 <SamB> pejo: not quite true, but _|_ values are rather uninteresting, yes
09:21:45 <SamB> doesn't mean we should randomly transform them to non-_|_ values
09:22:17 <ski> it can be a problem if program compiled with optimizer terminates, but program without optimizer (e.g. another platform or compiler) doesn't
09:24:07 <pejo> SamB, well, you don't really have to convince me. :-)
10:08:24 <hackagebot> liboleg 0.2 - A collection of Oleg Kiselyov's Haskell modules (2009-2008) (DonaldStewart)
10:08:41 <Saizan_> ..liboleg?
10:11:20 <ski> "2009-2008" ?
10:17:23 <ErhardtMundt> Saizan_, :Ã¾
10:19:28 <hackagebot> she 0.0 - A Haskell preprocessor adding miscellaneous features (ConorMcBride)
10:23:56 <monochrom> she-ra? he-man?
10:24:18 <idnar> ski: time travel!
10:27:22 * coCocoa prefers "Conor McBride of the Clan McBride, also called...rhe R*-lander!" ;p
10:28:16 <coCocoa> *the
10:28:51 <byorgey> haha, oh Conor
10:28:56 <byorgey> "The Strathclyde Haskell Enhancement is a somewhat inglorious bodge, equipping ghc with automatic lifting of types to kinds, pattern synonyms, and some kit for higgledy-piggledy literate programming."
10:29:17 <ray> Data.TimeTravel
10:31:56 <pejo> byorgey, is it a pre-processor?
10:32:03 <byorgey> pejo: yeah, looks like it
10:32:32 <hackagebot> AC-EasyRaster-GTK 1.1.1 - GTK+ pixel plotting. (AndrewCoppin)
10:33:36 <roconnor> EasyRaster sounds nice :)
10:35:10 <FunctorSalad> @go "a haskell preprocessor adding miscellaneous features"
10:35:10 <lambdabot> No Result Found.
10:35:23 <FunctorSalad> :o
10:35:29 <FunctorSalad> typo. :p
10:36:21 <FunctorSalad> @where she
10:36:22 <lambdabot> I know nothing about she.
10:37:22 <FunctorSalad> http://hackage.haskell.org/package/she-0.0
10:37:57 <FunctorSalad> You don't have permission to access /~conor/pub/she/ on this server.
10:53:37 <jmcarthur> @hackage she
10:53:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/she
11:06:27 <copumpkin> that she package looks good to me
11:09:01 <Gracenotes> mwahahaha, "Object-oriented design is the roman numerals of computing."
11:09:57 <copumpkin> hah
11:10:24 <Axman6> haha
11:15:43 <byorgey> you know... perhaps instead of trying to optimize my modular exponentiation function, I should try memoizing this function with a fibonacci-like recursion pattern.
11:15:46 * byorgey smacks forehead.
11:15:53 <Gianvacca> Hi, guys, can you help me with this?
11:15:54 <Gianvacca> http://pastebin.com/d5ba6cb8b
11:16:19 <Gianvacca> I know nothing about haskell and don't know how to patch it
11:16:31 <Saizan_> Gianvacca: how are you compiling that?
11:16:47 <dankna> it would be nice to see the code, too
11:16:54 <byorgey> probably due to the new exception stuff in 6.10, I'm guessing?
11:17:00 <Gianvacca> ghc 6.10.3
11:17:14 <Gianvacca> I'm going to show you the code
11:17:47 <Saizan_> Gianvacca: which command, i mean, are you using cabal or just ghc --make
11:18:40 <Gianvacca> ghc --make
11:18:43 <Gianvacca> http://pastebin.com/da412397
11:18:50 <Gianvacca> that is the source
11:19:14 <dankna> .... is this commented in some other language or something?
11:19:38 <Gianvacca> might be russian, I don't see it
11:19:45 <Saizan_> Gianvacca: an easy solution is to change the import Control.Exception line to import Control.OldException
11:20:00 <dankna> I'm just guessing that because of all the &#1113840; things
11:20:08 <monochrom> hahaha
11:20:15 <Gianvacca> I'll try immediately, Saizan_
11:21:03 <monochrom> "supplementary private use area-B" is the unicode block it's in.
11:21:46 <monochrom> IOW someone is paying lip service to unicode, in reality he's just using insider encoding and charset.
11:22:15 <dankna> heh, I see
11:22:28 <dankna> well, it hardly matters
11:23:31 <monochrom> For example real unicode russian Ð‘ is U+0411, &#1041;
11:23:46 <dankna> yeah, that's why I thought it was an Asian language or something - the codepoints were so big
11:24:29 <monochrom> Bulat is Russian.
11:26:44 <greap> Has anyone got gtk2hs working on os x?
11:27:22 <dankna> I got HOC working, which is not a small feat, but no, I haven't messed with gtk2hs.
11:27:38 <dcoutts> greap: I believe people have done so
11:28:40 <greap> There seem to be a bunch of howtos, but I run into problems in all of them :( sadface
11:28:55 <Gianvacca> Saizan_ thanks I got past; now I just need to fix the following ones
11:29:03 <monochrom> In a Chinese martial art novel, there is this story. Someone invented the greatest kickass martial art ever. He wanted to write it down so it is not lost. But he worried about falling into bad hands too, so he didn't want any reader to understand it. (Yes he had a bit of cognitive dissonance there, wanted it not lost and wanted it lost. :) ) This is what he did: He used the Sanskrit language, but he didn't write Sanskrit scri
11:29:03 <monochrom> pt, he wrote Chinese script that when pronounced would give you the correct Sanskrit prose.
11:30:26 <dankna> that's related to how Linear B was deciphered
11:30:42 <dankna> it turned out to be a written form of an ancestor of Greek completely unrelated to later written forms
11:30:48 <dankna> meaning the ability to write was lost and subsequently reinvented
11:31:31 <dankna> there are also interesting things that go on with cross-language stuff in Asian languages
11:32:38 <SamB> monochrom: wow, that would be really hard to read!
11:44:30 <space_commander> hi
11:47:06 <dschoepe> How do I open a pipe that was created via `mkfifo'? openFile complains, that the file does not exist.
11:48:24 <mauke> what's the exact error?
11:48:43 <Heffalump> I think you have to open it in binary mode
11:49:12 <monochrom> I don't get a "file does not exist" error.
11:49:33 <dschoepe> okay, silly me, I had "~" instead of the full path in the filename
11:49:45 <mauke> aww, how pedestrian
11:52:40 <themroc> anyone could have a look at http://pastebin.com/m4329e872 ?
11:53:12 <themroc> how can i put that dependence of resultItemIsFinal into the list comprehension ?
11:53:22 <mauke> ew
11:53:35 <mauke> 'if x then True else False' better written as 'x'
11:53:52 <mauke> 'length v == 0' better written as 'null v'
11:54:06 <mauke> 'x == True' better written as 'x'
11:54:19 <monochrom> You should pass 4 parameters not 1.
11:54:35 <themroc> well x are 4 parameters
11:54:38 <mauke> well, you should remove 3 parameters from resultItemIsFinal
11:54:44 <mauke> themroc: no, x is only one
11:54:47 <themroc> hmm
11:54:51 <mauke> > length [x]
11:54:52 <lambdabot>   1
11:55:15 <themroc> ic
11:55:16 <themroc> ok
11:55:17 <themroc> right
11:55:24 <themroc> i thought its passing x as 4 parameters
11:55:26 <monochrom> Rewrite resultItemIsFinal to take a 4-tuple rather than 4 parameters.
11:55:30 <themroc> yeah
11:55:34 <themroc> thx :p
11:55:37 <themroc> sometimes its too simple hehe
11:55:48 <monochrom> Why are people so insensitive of types?
11:56:13 <monochrom> f (a,b) is not f a b.
11:56:16 <mauke> [ x | x@(_, _, _, []) <- iterate step (start, d, u, v) ]
11:56:55 <myst> monochrom: it's because most people thinks that formalisation is not needed, like computers are smart
11:57:43 <myst> which are obviously not
11:58:14 <monochrom> Indeed computers are smart because they are formal.
11:58:23 <Mion> My computer is rather stupid
11:58:23 <SamB> heck no
11:58:30 <SamB> that's not how smart works
11:58:39 <Mion> it always does what I tell it, and never what I really mean
11:58:45 <Mion> :(
11:59:24 <SamB> some say that shows that they are out to get us
11:59:26 <roconnor> monochrom: there is a canonical way of identifying a -> b -> c with (a,b) -> c
11:59:37 <roconnor> monochrom: I'd like a language that does so transparently
12:00:05 <roconnor> I read a paper on this topic ...
12:00:12 <SamB> roconnor: I don't
12:00:22 <roconnor> SamB, why not?
12:00:50 <myst> roconnor: it's fundamentaly broken, because a -> b and (a, b) are completely different types
12:01:12 <SamB> myst: go back and reparse that type ;-)
12:01:14 <SamB> add parens
12:01:15 <myst> (a, b) - tuple, a -> b - function
12:01:34 <roconnor> myst: identifying (a -> b -> c) with ((a,b) -> c)
12:01:37 <SamB> roconnor: I just don't want it to be transparent
12:01:47 <monochrom> Guessing what you mean is psychic. Smart people and computers find that psychic is bunk and do not care what you mean.
12:01:49 <SamB> I'm not saying I would object to having the language prod me when it can
12:01:59 <SamB> well, implementation, really
12:02:04 <roconnor> SamB: you like pointlessly writing out isomorphisms?
12:02:33 <pejo> roconnor, isn't this the same question as whether one should have fromIntegral?
12:02:36 <SamB> roconnor: well, I'd prefer to have to at least include some indication that I want it to apply the hueristics
12:03:06 <Woof> @bf +.
12:03:06 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
12:03:08 <SamB> roconnor: and such hueristics can't ALWAYS work
12:03:10 <Woof> What : /
12:03:30 <roconnor> pejo: probably not.  I don't think fromIntegral can always be canonically infered, but I *think* this can be done for a medium sized class of "arithmetic" type equivalences
12:03:48 <roconnor> SamB: I think there is a class for which it always works
12:04:03 <SamB> roconnor: if you have enough type signatures, maybe...
12:04:24 <roconnor> right, what I don't know is how it interacts with type inference.
12:04:38 <roconnor> But I'd like it to be done, if it can be done sanely
12:05:19 <SamB> i'd settle for having Coq stop complaining about type errors from arguments that it's supposed to fill in on it's own ...
12:06:21 <roconnor> SamB: just as I'd like to have an extensional dependent type theory, just not at the cost of making type checking undecidable.
12:06:44 <themroc> mauke
12:06:45 <themroc> [ x | x@(_, _, _, []) <- iterate step (start, d, u, v) ]
12:07:01 <themroc> does it mean that x has to be like the (_,...) ?
12:07:08 <mauke> yes
12:07:10 <themroc> nice
12:07:13 <themroc> thx :p
12:07:36 <SamB> roconnor: does that have to make typechecking undecidable?
12:08:02 <SamB> ... can't the typechecker just ask for *help*?
12:08:41 <monochrom> Yes.
12:10:14 <roconnor> SamB: well, we want canonicity, extensional equality, decidable type theory.  Which is what OTT has.
12:10:26 <monochrom> The problem is undecidable. The algorithm can ask for help. No contradiction.
12:10:29 <rocketman> I don't want extensional equality :P
12:11:28 <roconnor> I don't know how asking for help interacts with canonicity.
12:11:45 <SamB> roconnor: what's canonicity?
12:12:25 <rocketman> SamB: n : N either n is O or S _
12:12:38 <rocketman> (it the empty context)
12:13:16 <SamB> rocketman: why don't you want extensional equality?
12:13:44 <roconnor> anyhow, perhaps (a -> b -> c) and ((a,b) -> c) are not isomorphic in haskell. :/
12:13:57 <SamB> roconnor: also true
12:15:05 <monochrom> Please don't call my name in vain.
12:15:30 <monochrom> You had a wish, and your wish is better addressed to the whole channel than to my name.
12:15:53 <SamB> monochrom: who are you talking to?
12:16:06 <monochrom> I don't care that you freenode veterans have this weird tradition of attaching the most-recently-spoken-person's name to everything you say.
12:16:38 <SamB> that's not what *I* do
12:16:50 <monochrom> Yes, but roconnor did a few minutes ago.
12:16:53 <SamB> ah
12:17:15 <monochrom> Lots of freenode veterans do it all the time.
12:17:21 <monochrom> It really annoys me.
12:17:51 * roconnor is confused
12:17:51 <SamB> monochrom: I don't see where you mean
12:17:56 <rocketman> extensional equality doesn't make sense to me unless you think of functions as sets of pairs (input,output)
12:18:23 <monochrom> "monochrom: there is a canonical way of identifying a -> b -> c with (a,b) -> c" "monochrom: I'd like a language that does so transparently"
12:18:47 <rocketman> monochrom: clearly he is hinting you should implement such a language :)
12:18:50 <SamB> rocketman: I don't quite
12:19:08 <SamB> but mathematically, I think of them as nothing but a way to map input to output
12:19:29 <rocketman> Well I think of constructions and there is more than one way to skin a cat
12:20:00 <sjanssen> monochrom: I think that was meant as a response to "13:56  monochrom$ f (a,b) is not f a b."
12:20:13 <sjanssen> monochrom: it's not like you were totally uninvolved in the conversation
12:20:40 <roconnor> sjanssen: I was responding to that comment, and the one immediately before
12:21:45 <monochrom> Then respond to the comment, not the person.
12:22:01 <roconnor> oh, how should I write that?
12:22:13 <SamB> monochrom: well, excuse us for IRC messages not having Message-Id: headers
12:22:16 <Woof> Cale?
12:22:30 <elbar> in reference to your comment @ 12:45 ... ;)
12:22:40 <SamB> elbar: that's not reliable either
12:22:44 <inimino> 19:21:45: Interesting suggestion.
12:22:46 <Zao> elbar: Requires you to determine timezone.
12:22:53 <Zao> Of course, you could use proper ISO time.
12:22:58 <inimino> oh pish-tosh, use UTC
12:23:01 <monochrom> There is such a time proximity that if you just say what you want to say, everyone sees it's relevant. You don't need to add any referencing.
12:23:06 <elbar> inimino: signed ;)
12:23:06 <SamB> we're in many different time zones, some of us with badly-set clocks,
12:23:16 <roconnor> it was 14:55 for me :)
12:23:19 <SamB> there isn't always such time proximity
12:23:30 <dankna> do this the way normal human being would
12:23:36 <dankna> say "In reference to your comment about..."
12:23:36 <SamB> it's like turning towards someone when responding to them
12:23:44 <dankna> *beings
12:23:45 <inimino> real hackers have no trouble doing the UTC conversion to local time in their heads
12:23:46 <Zao> In reference to your comment at 2009-07-04T12:45.00+01:00, I wanted to say: meh
12:23:47 <SamB> dankna: that's so e-mail
12:23:56 <dankna> haha
12:24:12 <monochrom> In case there is no time proxmity, "I wish languages could do ____" is of such general interest that it can stand on its own, no need to attach it to any person or thread.
12:24:39 <SamB> most of us like to be alerted when something we said is responded to like that
12:25:07 <monochrom> Anyway if you disagree with me or even find this pointless, fine. Just don't call my name in vain. That's all I ask. You can call other people's names whichever way you like, not my business I guess.
12:25:08 <inimino> especially when the response seems to contradict what we said
12:25:21 <Twey> inimino: UTC time is for wimps.  Use Internet time.
12:25:40 <roconnor> monochrom: I don't get your problem.  You asked a question: ``Why are people so insensitive of types?'' and I responded to it.  What do you expect?
12:25:42 <SamB> I guarentee that I will forget and call your name
12:25:51 <SamB> I have almost forgotten it already
12:25:59 <SamB> I nearly did it just two comments ago!
12:26:02 <inimino> monochrom: maybe if you don't like the feature you should adjust your IRC client appropriately
12:26:18 <roconnor> monochrom: maybe you shouldn't ask questions on IRC.
12:26:31 <roconnor> if you don't want replies
12:26:33 <SamB> at least, not rhetorical questions
12:26:51 <themroc> how can i convert something to string?
12:26:57 <themroc> like what comes out with show
12:26:58 <roconnor> @type show
12:26:59 <lambdabot> forall a. (Show a) => a -> String
12:27:01 <monochrom> I like the feature. I just don't like your logic. This doesn't just happen when I ask questions.
12:27:04 <themroc> ah
12:27:10 <sjanssen> > show 123 -- like this, themroc
12:27:11 <lambdabot>   "123"
12:27:16 <themroc> nice :p
12:27:16 <roconnor> monochrom: well it did just now.
12:27:28 <elbar> > reverse $ show 123
12:27:29 <lambdabot>   "321"
12:27:31 <FunctorSalad> lol, hwn: Haskell. "Avoid success at all costs." Made with dinosaur technology.
12:27:51 <Zao> > show 123 ++ "like this, sjanssen"
12:27:52 <lambdabot>   "123like this, sjanssen"
12:28:24 <Zao> I still tend to misparse -- as an operator, due to my C++ roots.
12:28:54 <roconnor> SamB: I don't know if mono's question was meant as rhetorical. I think it is an intersting question and has a reasonable answer
12:29:29 <hackagebot> haskeem 0.7.7 - A small scheme interpreter (UweHollerbach)
12:29:43 <Twey> > shows 123 "No, like this, Zao"
12:29:44 <lambdabot>   "123No, like this, Zao"
12:29:49 <monochrom> The case above is admittedly a minor and arguable case. I have seen numerous more clear-cut examples. They go like this:
12:30:30 <monochrom> <newbie> How do I _____ ?  <A> newbie: zip, then map (+) <B> A: or zipWith (+)
12:30:53 <monochrom> For Christ's sake, it is newbie, not A, who need to hear what B says the most.
12:31:02 <inimino> I've been known to do that
12:31:14 <Zao> monochrom: <C> unsafePerformIO
12:31:16 <sjanssen> that is really an example of a larger problem #haskell has
12:31:43 <sjanssen> everybody has to get their two cents in, even (especially?) with the simplest questions
12:31:44 <inimino> usually because A is the one who gave the advice, and if there is a better answer, A probably could benefit from knowing it
12:31:56 <coCocoa> A: Wouldn't that be zip, then uncurry (+)? ;)
12:31:56 <monochrom> At the end of the day, I can't really ask you to change, and I shouldn't whine too much. I just want to say once how ridiculous it is.
12:31:59 <Twey> sjanssen: I don't think that's a bad thing
12:32:05 <Twey> It makes the answers very complete
12:32:08 <inimino> I assume the newbie will be following conversation, while A may have just popped in
12:32:09 <Twey> And often sparks interesting discussions
12:32:19 <Zao> Although, if everyone are targeting the OP with tangential info, they may become rather overwhelmed, trying to follow it all.
12:32:36 <Twey> Well, they can always ask for clarification.
12:32:37 <sjanssen> Zao: yes, I think this happens rather often
12:32:37 <monochrom> What B says there is not tangential.
12:33:18 <monochrom> Tangential remarks should be addressed to A and B, I agree. This one is not tangential. This one is for the very original question.
12:33:35 <monochrom> And a very good answer too. newbie should be the one alerted.
12:34:45 <Zao> monochrom: So target both.
12:35:07 <monochrom> Yes. But that is not what you people do.
12:35:33 <SamB> monochrom: sorry, we can't always follow the threads
12:35:34 <Twey> I target both
12:36:00 <roconnor> Ah found it: http://people.cs.uu.nl/johanj/publications/mpc04.pdf
12:36:02 <SamB> someone should come up with a way to usably thread IRC conversations in real time
12:36:20 <roconnor> Inferring Type Isomorphisms Generically ^^
12:36:28 <dankna> well, I think the IRC protocol is what would have to go in any such system
12:36:41 <dankna> it's really lousy for extending
12:36:54 <roconnor> Google Wave FTW!
12:37:09 <dankna> nah, a regular Jabber conference room would be fine, no need to go to Wave
12:37:44 <dankna> I'm picturing a UI that picks a background color that hasn't been used recently for each thread of conversation and sticks with it
12:37:58 <maltem> monochrom, B answers to A to make clear what B is talking about (to give the context of the "or")
12:38:36 <maltem> not so much because B has to tell something to A
12:38:52 <roconnor> maltem: right
12:39:19 <roconnor> or maybe I should say monochrom: right
12:39:22 <roconnor> :P
12:40:13 <dankna> amusing
12:40:20 <dsouza> question about showsprec. what is that first parameter for? It is like some kind of version used to match a specific version of show/read?
12:40:36 <monochrom> @type showsPrec
12:40:37 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
12:40:46 <monochrom> Precedence level, as a number.
12:40:58 <themroc> hmm if i have this: >route = out . dijkstra . node
12:41:03 <themroc> with one parameter
12:41:05 <monochrom> It helps you decide whether you need to add parentheses or not.
12:41:13 <themroc> it should first call node with the para
12:41:25 <roconnor> > showsPrec 7 (x+y)
12:41:26 <lambdabot>   Overlapping instances for GHC.Show.Show
12:41:26 <lambdabot>                              (GHC.B...
12:41:29 <themroc> call dijkstra with the priveous para
12:41:39 <themroc> and finalle call out with that para, right?
12:41:41 <roconnor> > showsPrec 7 (x+y) ""
12:41:42 <lambdabot>   "(x + y)"
12:41:47 <roconnor> > showsPrec 2 (x+y) ""
12:41:48 <lambdabot>   "x + y"
12:41:56 <Raevel> hmm, i want openFile to create the file if it doesn't exist, any other function that does that?
12:42:50 <dsouza> monochrom, roconnor: got it. thx :-)
12:43:01 <elbar> hihi
12:43:17 <FunctorSalad> ^^^
12:43:44 * dsouza hopes that style of typing is fine
12:43:59 <Raevel> uh, i just scrood up, i think
12:44:29 <Twey> Raevel: It does that already if it's for writing
12:44:52 <Raevel> yeah, just noticed -_-
12:45:05 <Raevel> thanks though!
12:45:11 <monochrom> Does AppendMode create files?
12:45:22 <Twey> I believe so
12:45:32 <Raevel> yes
12:45:34 <Raevel> just tried it
12:45:36 <Twey> The docs seem to imply that it is
12:45:39 <monochrom> WriteMode erases old content.
12:45:53 <Twey> Â« If the file does not exist and it is opened for output, it should be created as a new file. If mode is WriteMode and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an openFile with mode  WriteMode unless it is subsequently written to successfully. The handle is positioned at the end of the file if mode is AppendMode, and otherwise 
12:45:57 <FunctorSalad> dsouza: sure it is fine, the funny part was that one of the persons you listed before the ':' had just said that you shall not use their name in vain :)
12:47:42 <dons> bloxors http://www.youtube.com/watch?v=AJQZg3Po-Ag
12:47:44 <Heffalump> so there are operating systems that make it impossible to make an empty file?
12:47:48 <dons> pretty nice, simple opengl game
12:47:52 <themroc> anyone could look at http://pastebin.com/m1d050006 ?
12:48:12 <themroc> it seems the same to me and i dont understand why the error occurs :(
12:48:20 <dsouza> FunctorSalad: I know but I found that particular answer very useful as well and automatically qualifieed it as a ``not in vain msg''
12:48:34 <SamB> Heffalump: wonder why it doesn't give any examples of such operating system versions ?
12:49:02 <Heffalump> themroc: try mapM_ instead of map pr
12:49:13 <Heffalump> map pr produces [IO ()] as you can see, instead of IO () which is what you want
12:49:14 <dankna> oh!  I've played that game, I had no idea it was written in Haskell.
12:49:24 <Heffalump> IM mapM_ pr instead of map pr
12:49:26 <monochrom> mapM_ pr
12:49:38 <Heffalump> alternatively sequence_ $ map pr ...
12:49:53 <themroc> wow
12:49:54 <themroc> works :p
12:55:18 <kpreid> Is there a way to get the current time ignoring leap seconds?
12:56:17 <kpreid> Rather, a time difference
12:58:40 <monochrom> Data.Time.Clock should be very suitable. "If you don't care about leap seconds, use UTCTime and NominalDiffTime for your clock calculations, and you'll be fine." seems to be exactly what you want. :)
12:59:05 <kpreid> No, it's the opposite: "For instance, 23:00 UTC + 2 hours of NominalDiffTime = 01:00 UTC (+ 1 day), regardless of whether a leap-second intervened."
12:59:34 <kpreid> I want a clock that proceeds at some fixed quantity per real-time second
13:01:23 <elbar> isn't that what the unix time does? counting every second since the '70s?
13:02:47 <dankna> I think you want System.Posix.Time.epochTime
13:05:09 <kpreid> doesn't seem to be known to hoogle or /ghc/docs/latest/
13:05:32 <FunctorSalad> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=epochTime
13:05:54 <dankna> hm?  http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Time.html
13:05:56 <FunctorSalad> lately hayoo seems to pwn hoogle if you don't need to search by type
13:05:58 <dankna> is where I found it
13:06:14 <FunctorSalad> *inclusionist*
13:06:22 <dons> FunctorSalad: well, it is more of a search engine, than a type engine, like hoogle
13:06:25 <dons> so makes sense.
13:06:27 <dons> they should be combined...
13:06:37 <kpreid> anyway I'm pretty sure that unix epoch time steps over leap seconds
13:06:51 <kpreid> i.e. is not 1 second per second :-)
13:07:09 <FunctorSalad> dons: yes, but AFAIK, hoogle also intentionally doesn't include everything?
13:07:28 <dankna> I'm pretty sure that epoch time is unaware leap seconds exist and does nothing special for them
13:09:05 <dankna> for example, I've seen algorithms that compute astronomical times such as Julian dates based on epoch time
13:09:05 <FunctorSalad> I suppose if you told us what you are writing you'd have to kill us all...
13:10:45 <dankna> I wish the authors of HOC were around so I could make them feel my pain.
13:10:57 <dankna> I don't need help... just sympathy :)
13:11:10 <dons> hoc needs a maintainer
13:11:14 <FunctorSalad> HOC?
13:11:21 <dankna> Haskell Something Cocoa
13:11:28 <dankna> a binding to Apple's Objective-C GUI API
13:11:32 <FunctorSalad> ah
13:11:35 <dankna> yes, it badly needs a maintainer
13:11:52 <rocketman> nobody serious will maintain it
13:12:02 <rocketman> the reason is that the FFI doesn't have struct support
13:12:04 <dankna> it's kinda embarrassing that it doesn't work properly.  and the code in its present state is a mess to even build, although I've gotten past that step.
13:12:20 <dankna> rocketman: That's what libffi is for.
13:12:25 <Raevel> i haven't managed to build it :-/
13:12:37 <dons> 13:10  rocketman> the reason is that the FFI doesn't have struct support  <-- is that really the reason?
13:12:48 <dankna> Raevel: see step-by-step instructions at the bottom of Issue 14 in the Google Code bugtracker (not the Sourceforge one)
13:12:50 <dons> it was originally a combined project by two serious mac/haskell people
13:12:59 <Raevel> dankna: okay! thanks
13:13:03 <rocketman> dankna: libffi has struct support? We should be using this for the normal ffi then?
13:13:05 <dankna> sure thing
13:13:21 <dankna> rocketman: yes, I believe that it does, as well as double support (they're also hard to pass)
13:13:24 <dankna> and yes, I think you should
13:13:36 <dankna> it came up here once before and nobody really saw the point of using it when it's such a thin layer
13:13:39 <SamB> wouldn't we need some kind of Haskell syntax for that stuff ?
13:13:58 <dankna> but imo it's important because it's a thin layer that deals with all the portability issues in the ABI and stays out of your way
13:14:27 <dankna> you can still pass structs if you understand the ABI well enough though :)
13:14:40 <dankna> you just have to break out each field as its own parameter and get them in the right order
13:14:48 <dankna> returning structs is a bit harder but I think also possible
13:14:55 <dankna> it's ugly as sin, is the only problem
13:15:03 <rocketman> dankna: as you know... this only works for a single ABI
13:15:09 <dankna> yes, just so
13:15:13 <Heffalump> do the calling conventions on all platforms treat structs as equivalent to separate parameters?
13:15:29 <dankna> Heffalump: As rocketman just chided me for forgetting to mention, no, they don't, it's highly nonportable
13:15:31 <Heffalump> if not, you might not be able to express it that way
13:15:54 <Heffalump> dankna: I don't just mean "is there a mapping of structs to separate parameters that works for all platforms "
13:16:02 <rocketman> I've never seen someone use libffi from haskell to deal with structs but I'm sure it's awkward and tedious
13:16:08 <Heffalump> I also mean "does every platform have *some* mapping to separate parameters"
13:16:15 <rocketman> there's no point working on HOC which the FFI doesn't have good struct support
13:16:28 <dankna> Heffalump: I don't know the answer to that but I wouldn't be surprised to learn that no, there are some platforms which require padding or something like that
13:16:38 * coCocoa pities whoever tries to do an FFI for Haiku
13:16:39 <Heffalump> different padding is the key
13:16:40 <dankna> I don't know that there's "no point"
13:16:41 <Cale> The Haskell FFI has decent support for structures...
13:16:50 <dankna> Mac OS X has two ABIs (one for PPC, one for Intel) and both are quite stable
13:17:12 <dankna> surely it's worthwhile maintaining something that people find useful, for its own sake
13:17:24 <rocketman> I assume there are differences in i386 and i686. ?
13:17:32 <rocketman> don't know really..
13:17:42 <dankna> I assume so too, but since the Mac only supports the latter, it doesn't matter
13:19:10 <dankna> but yeah, I'm saddened that people feel HOC can't be worth investing time into simply because there are some necessary warts in its implementation
13:19:10 <FunctorSalad> C noob here so don't take this seriously but why can't the struct bit layout be abstracted out as a compiler "plugin" (which would have to be supplied for every architecture) and be transparent from the POV of the FFI?
13:19:38 <dankna> Functor: well, that's essentially what libffi does, but it's subtle stuff
13:19:45 <Cale> dankna: btw, the original Bloxorz was in Flash. This is a Haskell remake.
13:20:00 <dankna> Cale: Oh!  Okay.  I thought I remembered playing it in a browser.  Is it by the same author?
13:20:08 <Cale> I'm not sure
13:20:17 <rocketman> I think it's a crap rip off
13:20:22 <rocketman> the haskell version only has 3 levels
13:20:23 <dankna> It's nice to have as an example to people who might want to do 3D games in Haskell, anyhow.
13:20:35 <dankna> Probably because the author couldn't get past the third level then :)
13:21:47 <Cale> The author is different it seems... the original was by Damien Clarke, and the Haskell version is by Viktor Devecseri
13:21:59 <dankna> ah okay.  well, that's interesting.
13:25:19 <dons> rocketman: you're a bit grumpy.
13:26:02 <kpreid> ok, epochTime won't do because it's at 1-second resolution
13:26:06 <dons> anyway, its a student project from an Adv. FP course. A good effort for a Haskell beginner.
13:26:23 <dankna> ah, indeed then
13:26:29 <dankna> kpreid: hm, that's a shame
13:26:52 <dons> the course teacher talks about it here, http://just-bottom.blogspot.com/2009/07/playing-and-learning.html
13:27:30 <dankna> I think you're going to have to FFI to a platform-specific interface, kpreid
13:27:40 <dankna> I'm not aware that there's anything in Posix that's like epoch time but higher-resolution
13:27:59 <dankna> make a nice little portability library out of it :)
13:28:22 <kpreid> well, I don't care what the epoch is actually, time since boot would be fine
13:28:33 <dankna> answer's still the same though
13:28:39 <kpreid> I just want a uniform rate and subsecond resolution
13:29:26 <kpreid> I'll just use UTC time since this is a demo and time measurement issues aren't actually relevant
13:29:29 <kpreid> (with a note)
13:30:02 * dankna nods
13:30:17 <rocketman> dons thanks for telling me. ..
13:30:53 <rocketman> (not sure what that achieves except reinforcement)
13:31:00 <dons> just trying to encourage constructive contributions.
13:31:19 <rocketman> not gonna happen
13:31:43 <dons> you might want to read this then, http://haskell.org/haskellwiki/IRC_channel#Principles
13:31:49 <rocketman> already have
13:32:07 <djsiegel> Hey, I want to create a tool to transform glade interface description files (XML) to Haskell modules to make writing Gtk+ apps a little more bearable. What's a good approach for this? Are there any canonical libraries for writing haskell? Would template haskell be useful?
13:32:10 <FunctorSalad> then maybe en.wikipedia.org/wiki/Golden_Rule
13:32:12 <dons> so you're not interested in being constructive, rocketman ?
13:32:13 <FunctorSalad> ;o
13:32:50 <FunctorSalad> (first meaning)
13:32:53 <dankna> djsiegel: Template Haskell is probably not necessary unless you care about the readability of the generated code.
13:33:13 <rocketman> dons I guess I'm not the only one that's a bit grumpy
13:33:16 <monochrom> IMO "it has only three levels" is fine, even positive. "ripoff" is not.
13:33:21 <dankna> There are many approaches possible, and I can't really do your architecture design for you.
13:33:28 <FunctorSalad> (I wouldn't like to release my first project in a lang I'm a n00b in and be told it's crap)
13:33:31 <rocketman> monochrom: ripoff is factual though? isn't it
13:33:54 <monochrom> No.
13:34:02 <dons> 'crap ripoff' isn't helpful, no.
13:34:06 <djsiegel> dankna: ok, looks like I came in here at a bad time.
13:34:16 <djsiegel> thanks, will try later
13:34:23 <rocketman> I've had a look at it and I think my opinion is justified
13:34:27 <dankna> For example, you could write your code that does the transformation in Haskell using an existing XML-parsing library, or you could write it in some totally different language.
13:34:29 <monochrom> I am not sure who is ripped off of what.
13:34:31 <Philippa> ripoff is judgemental. The game openly admits that it's a clone, and isn't selling for money
13:34:42 <rocketman> Have you played it? or is it just that nothing in the world is crap if it's written in haskell
13:34:55 <dons> ok. try again later.
13:34:57 --- mode: ChanServ set +o dons
13:34:59 --- mode: dons set +b *!*n=f@*.demon.co.uk
13:34:59 --- kick: rocketman was kicked by dons (dons)
13:34:59 <Philippa> I /don't care/
13:35:00 --- mode: ChanServ set -o dons
13:35:07 <Philippa> dons: not sure that was a good time
13:35:25 <dons> shrug.
13:35:27 <djsiegel> dankna: right, the parsing is easy, I just wanted to know if there's a better approach than just creating strings of haskell and writing them to the module file
13:35:43 <djsiegel> dankna: that just feels so unsafe and dirty
13:35:56 <conal> is anyone using Codec.Image.DevIL for loading images into OpenGL textures?
13:35:56 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
13:36:08 <dankna> oh.  well.  if there is, I can't immediately think of one.  it's what Happy and Alex do, for whatever that may be worth.
13:36:23 <dons> conal: hmm. I wonder how you could find that out. what package is it in?
13:36:55 <conal> @hackage Codec-Image-DevIL
13:36:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Codec-Image-DevIL
13:37:19 <dankna> Codec.Image.DevIL looks handy.  Good to know about.
13:37:28 <conal> yeah.  very!
13:37:45 <dons> conal: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/obj
13:37:47 <dons> uses it.
13:37:56 <Heffalump> umm, don't ban *.demon.co.uk
13:37:58 <conal> dons: how'd you find out?
13:38:07 <djsiegel> dankna: ok, cool, I am just generating some simple IO a that access an MRef and return a piece of state, will try strings
13:38:09 <Heffalump> that's basically an entire ISP even if you did limit the @ bit
13:38:12 <dons> conal: looked up the Arch Linux package, which has reverse dependencies.
13:38:28 <Heffalump> you can just ban that precise hostname, it's a static IP
13:38:31 <dankna> djsiegel: Good luck.  And please don't take me for an expert on Haskell; I'm just some guy.
13:38:33 <conal> dons: oh!  thx.  would be a nice hackage feature.
13:38:46 <djsiegel> dankna: ok, me too! :)
13:39:37 * Heffalump wrote a patch to cabal-install to calculate reverse dependencies
13:39:54 <Heffalump> I couldn't agree with dcoutts on how to expose it in a nice way though
13:40:02 <Heffalump> I think the patch is attached to a wiki ticket though
13:40:14 <conal> Heffalump: cool :)
13:40:15 <dcoutts> oh yes
13:40:22 <FunctorSalad> btw is hackage itself written in haskell? is it still updated?
13:40:36 <dcoutts> FunctorSalad: yes
13:40:48 <dcoutts> FunctorSalad: current server is Apache + Haskell CGI
13:40:58 <dcoutts> new server is all Haskell, based on hapstack
13:40:59 <FunctorSalad> so somebody could add some feature and send it in?
13:41:29 <dcoutts> new features should be directed to the new implementation, on code.haskel.org/hackage-server
13:41:40 <FunctorSalad> ah
13:41:55 <Heffalump> except that the new implementation still needs work to make it live, so your new feature won't go live until that happens either.
13:42:13 --- mode: ChanServ set +o dons
13:42:15 --- mode: dons set -b *!*n=f@*.demon.co.uk
13:43:14 --- mode: dons set +b *!*@amcant.demon.co.uk
13:43:16 --- mode: ChanServ set -o dons
13:43:27 <Heffalump> how long are you planning on having that ban for?
13:43:39 <dons> 3-6 hrs?
13:43:50 <Heffalump> ok, that's fine with me
13:44:46 <jauaor> hello
13:45:08 <jauaor> what is haskell?
13:45:11 <jauaor> :D
13:45:41 <kpreid> are there any gotchas with scheduling forkIO-ed threads interacting with MVars? I've got one thread that's continuously computing (in modifyMVar) and I'm readMVar-ing its state, and the readMVar is taking multiple seconds to complete
13:45:55 <dcoutts> jauaor: see http://haskell.org/ :-)
13:46:04 <jauaor> dcoutts!!!
13:46:16 <dcoutts> ohh, araujo
13:46:22 <jauaor> dcoutts: hahaha :D
13:46:32 <dcoutts> ;-)
13:46:40 * jauaor in other box
13:46:43 <jauaor> dcoutts: how it goes?
13:46:49 <dcoutts> good :-)
13:46:53 <Cynner> http://www.lostworlds.lv/go.php?1139730844
13:46:55 <jauaor> great !
13:47:07 * dcoutts is updating ghc user guide on shared libs and foreign import prim
13:47:34 <Zao> Have you lads implemented it on Windows yet?
13:48:04 <jauaor> dcoutts: hacking on cabal-install , the haskell platform? ...
13:48:12 <jauaor> dcoutts: nice :)
13:48:23 <Zao> Shared libs as in "RTS in a DLL", I assume?
13:48:39 * jauaor guesses so ....
13:49:14 <dcoutts> Zao: yep
13:49:18 <dcoutts> works on Linux now
13:49:36 <Twey> Zao: RUNTIMES ARE ONLY FOR CRAPPY PROPRIETARY PROGRAMMING LANGUAGES LIKE VISUAL BASIC!!!11
13:49:42 <Twey> C DOESN'T HAVE A RUNTIME!!!11
13:49:54 * Twey heard this yesterday
13:50:18 <dcoutts> Twey: did you point out that libc is a runtime, of sorts
13:50:23 <Twey> Yes
13:50:25 <Vq^> Twey: interesting argument
13:50:25 <Twey> Twice
13:50:54 <Vq^> whats the definition of a runtime then?
13:50:55 <timonator> lol the cpu is a runtime too so there!
13:50:55 <Twey> Eventually I was told that â€˜RUNTIME IS A PROPRIETARY TERMâ€™ and â€˜IN C WE DON'T HAVE A RUNTIME, WE HAVE A SHARED OBJECTâ€™
13:51:00 <monochrom> Are we trolling ourselves now? :)
13:51:03 <dankna> there's really no point in continuing the discussion when the other person is like that
13:51:09 <Vq^> you can certainly write C programs that don't use the libc
13:51:21 <monochrom> Using runtime to judge things is lame.
13:51:28 * jauaor points out that there are C interpreters 
13:51:29 <Twey> monochrom: I think he actually meant it
13:51:44 <timonator> jauaor: yeah, there's C for parrot, but there's no haskell for parrot. why not?
13:51:45 <Twey> He carried on fairly sanely afterwards
13:52:11 <olsner> sanely as in not all capital letters?
13:52:22 <jauaor> timonator: parrot is intended for dynamic/weak languages mainly
13:52:22 <Vq^> Twey: everything was forgiven then
13:52:39 <timonator> an expert friend said, haskell would be entirely possible atop parrot
13:52:44 <inimino> apart from the "proprietary term" business it sounds pretty sane
13:52:58 <jauaor> timonator: I think it'd be possible , yeah
13:53:11 <dons> parrot has a tail call instruction?
13:53:22 <jauaor> though I am not sure about the kind of performance you could get there
13:53:24 * timonator wanted to go to bed a couple of minutes ago already
13:54:47 <olsner> this is cool: Data.Boolean has instances for (a -> Bool) so that you can write ((0 <=) &&* (<= 9))
13:55:04 * dankna blinks
13:55:06 <dankna> that IS cool
13:55:19 <Raevel> yes!
13:55:21 <olsner> it's like mappend on compare
13:55:27 <idnar> @type (&&*)
13:55:28 <lambdabot> Not in scope: `&&*'
13:55:42 <jauaor> dons: i think there is something like call/cc .. if that might help
13:55:48 <FunctorSalad> ah, like the (->) e monad ;)
13:56:05 <FunctorSalad> (great error messages)
13:56:34 <olsner> idnar: it's && with a different name really, in a type-class for booleans
13:56:54 <olsner> (&&*) :: (Boolean b) => b -> b -> b
13:57:43 <olsner> @ty liftM2 (&&)
13:57:44 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
13:58:04 <olsner> that'd be an implementation of &&* for (a -> Bool) I guess
13:59:09 <ski> (yes, but not for `Maybe Bool')
14:01:02 <olsner> (yes, liftM2 = the specific function-monad definition of liftM2, in this case)
14:01:46 <jeffwheeler> Anybody happen to know what package I need for Ubuntu, to install the OpenGL package on hackage? It needs OpenGL headers that I don't have.
14:01:56 <jeffwheeler> And . . . there are a trillion different OpenGL packages in Ubuntu.
14:02:14 <dankna> I suspect it depends on your video card; you need the one that's compatible with it
14:02:50 <jeffwheeler> There a few nvidia-glx packages, hmmm
14:02:54 <olsner> libgl-dev perhaps, iirc that's a meta-package that should point to the one suitable for whatever gl/glx support you also happen to have installed
14:04:07 <gwern> @quote Raisins
14:04:07 <lambdabot> KF8NH says: all monads are functors, but for Hysterical Raisins not all Monads are Functors
14:04:19 <gwern> @quote lilac
14:04:19 <lambdabot> lilac says: * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
14:04:25 <gwern> @quote lilac
14:04:25 <lambdabot> lilac says: @type let in let wtf (In wft) = In wtf in wtf
14:04:44 <gwern> @type let in let wtf (In wft) = In wtf in wtf
14:04:45 <lambdabot> forall (t :: * -> *). Mu t -> Mu ((->) (Mu t))
14:04:54 <gwern> wtf
14:05:23 <gwern> you can have a let with no declaration?
14:05:35 <gwern> @quote greek.letter
14:05:35 <lambdabot> lilac says: lambda actually is just the greek letter l. it stands for lilac.
14:05:49 <gwern> @quote before.mauke
14:05:49 <lambdabot> lilac says: before mauke we all implemented map witha fold every time we needed it
14:06:01 <gwern> @quote lord.and.savior
14:06:01 <lambdabot> luqui says: I'll just stick to my religion: I have a personal relationship with our lord and savior, the untyped lambda calculus.
14:06:13 <gwern> @quote copumpkin
14:06:13 <lambdabot> No quotes match. Just try something else.
14:06:29 <gwern> @quote used.seq
14:06:29 <lambdabot> No quotes match. Take a stress pill and think things over.
14:06:35 <dankna> @quote dankna
14:06:35 <lambdabot> No quotes match. Sorry.
14:06:36 <gwern> @remember copumpkin I think I was implemented in haskell. I mean, my parents never used seq, ever.
14:06:36 <lambdabot> Good to know.
14:06:37 <dankna> oh well :)
14:06:45 <gwern> @quote dinosaur
14:06:45 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
14:06:59 <gwern> @remember BenjaminRussell Haskell. "Avoid success at all costs." Made with dinosaur technology.
14:06:59 <lambdabot> Done.
14:07:07 <gwern> @flush
14:07:35 <Badger> @quote dinosaur
14:07:35 <lambdabot> BenjaminRussell says: Haskell. "Avoid success at all costs." Made with dinosaur technology.
14:08:41 <monochrom> If you lack -dev packages and try to build Haskell code, you will likely see which files are missing. With the filenames and the search engines at packages.ubuntu.com or packages.debian.org , you can find the relevant debs.
14:09:18 <monochrom> Of course concurrently it doesn't hurt to ask in #haskell :)
14:09:52 <jeffwheeler> monochrom: that's an idea; I'll try it
14:10:13 <monochrom> Wow libgl-dev is a humongous tree of packages!
14:10:40 <monochrom> Err nevermind I read the dependency direction backwards.
14:10:50 <olsner> haha
14:12:29 <monochrom> You can also look at libghc6-opengl-dev and steal its dependency list, even though you don't plan to use libghc6-opengl-dev.
14:12:58 <jeffwheeler> One of the glu packages seemed to work, I think.
14:13:12 <jeffwheeler> Actually, I have no idea which one of the five or so that I installed did it. I should have paid closer attention.
14:13:15 <olsner> the haskell -dev package wouldn't necessarily depend on the C -dev package for opengl though
14:13:34 <jeffwheeler> it was a glu header file that was missing, though
14:13:44 <monochrom> Pick one of the libgl-dev variations that suits your platform. You also need one of libglu-dev .
14:14:09 <jeffwheeler> It seems to be working now; thanks all.
14:14:45 <jeffwheeler> monochrom++
14:21:02 <jeffwheeler> All that for 10 just a moment of entertainment, haha. Not many levels in the new bloxorz package.
14:21:13 <jeffwheeler> Err, minus the random "10"
14:29:13 <RafaelGCPP> does anyone know where I can find the Monad instance of (,)? It is not in Control.Monad.Instances or in Data.Tuple
14:29:26 <kpreid> Is there one?
14:30:39 <RafaelGCPP> well... Lambdabot shown me that ((,) =<< op . (! r2)) returns a tuple with (a,Map Integer Double) whenever op::Double->a
14:30:52 <RafaelGCPP> since (=<<) operates on monads...
14:31:24 <RafaelGCPP> NEVERMIND
14:31:33 <monochrom> Interesting, Control.Monad.Instances makes (,) a functor but not a monad. I think lambdabot has its own additions.
14:31:37 <RafaelGCPP> (,) is (,)::a->b->(a,b)
14:31:41 <kpreid> I think you're getting the reader instance
14:31:45 <RafaelGCPP> yep
14:31:51 <RafaelGCPP> that is right
14:31:52 <ski> Control.Monad.Writer
14:31:56 <RafaelGCPP> I just figured it out
14:32:36 <RafaelGCPP> (,) is not a monad, but (-> (a,b)) is a reader monad
14:33:02 <ski>   instance Monoid w => Monad ((,) w)
14:33:10 <ski>   instance Monad ((->) r)
14:33:52 <copumpkin> @quote copumpkin
14:33:52 <lambdabot> copumpkin says: I think I was implemented in haskell. I mean, my parents never used seq, ever.
14:33:56 <copumpkin> @quote pumpkin
14:33:56 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
14:34:01 <ski> (`(-> (a,b))' is not a monad .. `(->) (a,b)' aka `((a,b) ->)' is)
14:34:03 <copumpkin> damn fragmentation
14:34:53 <Peaker> ski: is it a comonad though?
14:34:58 <ski> no
14:35:09 <Peaker> Its a CoFunctor though :-)
14:35:14 <ski> both monads and comonads must be (covariant) functors
14:35:23 <ski> `(-> (a,b))' is a contravariant functor
14:35:55 * ski really dislikes using the name `CoFunctor' for contravariant functors
14:36:11 <copumpkin> there's ContraFunctor in category-extras
14:36:17 <copumpkin> I've never seen cofunctor
14:36:20 <RafaelGCPP> See.. Just when I thought I had figured monads out, I just discovered I will never hit the bottom.
14:36:27 <ski> (the concept of `contravariant functor' is not dual to the concept of `covariant functor')
14:36:46 <copumpkin> what should covariant functors be called?
14:36:48 <ski> using that name just encourages misunderstandings, imo
14:36:56 <ski> covariant functors
14:37:01 <copumpkin> ah :)
14:37:03 <ski> or simply, functors
14:37:51 <idnar> so what's the dual of covariant functors, then?
14:38:07 <copumpkin> variant functors? :P
14:39:46 <RafaelGCPP> ski, can you help me translate what the type of ((=<<) (,)) means?
14:39:48 <RafaelGCPP> ((=<<) (,) ) :: (Monad ((->) b)) => (b -> a) -> b -> (a, b)
14:41:08 <ski> that the old friend `graph'
14:41:36 <ski> @let graph :: (a -> b) -> (a -> (a,b)); graph f = id &&& f
14:41:37 <lambdabot>  Defined.
14:41:50 <ski> > graph (^2) 5
14:41:51 <lambdabot>   (5,25)
14:42:06 <ski> > ((=<<) (,)) (^2) 5
14:42:07 <lambdabot>   (25,5)
14:42:12 <ski> (well, almost)
14:43:19 <ski> RafaelGCPP : it takes a function as argument, then an input, and returns a pair of the output and the input
14:43:30 <ski> where the output is what you get when you pass the input to the function
14:43:48 <dankna> Is there a way to have my main function be in a package other than Main?  (For example, I want it to be in Mac.Main)
14:43:50 <ski>   graph f a = (a,f a)
14:44:00 <ski>   ((=<<) (,)) f a = (f a,a)
14:44:37 <ski> dankna : istr GHC has some "--main-is" (or similar) flag ..
14:44:49 <RafaelGCPP> Ok, got it. It is just that point-free versions of a function are really cryptic
14:44:49 <dankna> hmm...
14:45:22 <dankna> ski: found it and thanks
14:46:06 <RafaelGCPP> (Like one of the XKCD guys) My hobbies #199: Figuring out how a point-less version of a function works...
14:48:03 <RafaelGCPP> > ((=<<) (,)) (^2) 5
14:48:05 <lambdabot>   (25,5)
14:49:33 <gwern> @remember dhjdhj All new features added to C++ are intended to fix previously new features added to C++
14:49:33 <lambdabot> It is forever etched in my memory.
14:50:19 <gwern> @flush
14:52:31 <Twey> What does @flush do?  To disk?
14:53:36 <RafaelGCPP> @type ((=<<) (,))
14:53:37 <lambdabot> forall a b. (b -> a) -> b -> (a, b)
14:53:54 <RafaelGCPP> Oh, I see... I forgot to import Control.Monad.Instances on GHCI
14:54:00 <RafaelGCPP> thanks ski
14:54:37 <RafaelGCPP> that is why the type checker failed all the time
14:55:02 <kpreid> How do I find out what package provides a module on my system?
14:59:07 <roco> is this working or _
14:59:09 <roco> ?
14:59:16 <roco> where are everybody lol
14:59:16 <kpreid> _|_
14:59:28 <roco> oh hi
14:59:42 <Gracenotes> :!
14:59:44 * RafaelGCPP is playing with his monads!
14:59:53 * RafaelGCPP *blushes*
15:00:15 <Zao> RafaelGCPP: fmap liftM, eh?
15:00:20 <roco> guys i have problem, does anybody know programming ?
15:00:28 <Zao> roco: Most here probably do.
15:00:30 <RafaelGCPP> liftM2
15:00:41 <Zao> T'would be silly to hang out in a programming language channel otherwise.
15:01:01 <roco> yeah , silly me
15:01:15 * RafaelGCPP don't know programming... Forgot what it is a long time ago, after starting managing...
15:01:19 <RafaelGCPP> lol
15:01:32 <roco> Im building some word correction in php/mysql
15:01:48 <dschoepe> then #php is probably a better channel for your problem
15:02:00 <roco> oic
15:02:04 <roco> tnx
15:02:05 <whoppix> ...
15:02:09 <Gracenotes> try '/join #php'
15:02:18 <Zao> It's a "jump to conclusions mat"!
15:02:55 <Gracenotes> some Google search leads here I think
15:08:59 <jeffwheeler> @quote roco: guys i have problem, does anybody know programming ?
15:08:59 <lambdabot> No quotes for this person. Do you think like you type?
15:09:09 <ski> remember
15:09:09 <jeffwheeler> @remember roco: guys i have problem, does anybody know programming ?
15:09:09 <lambdabot> Done.
15:09:40 <kpreid> jeffwheeler: should have no colon
15:09:54 <jeffwheeler> Hmm. Not sure how to edit it, now.
15:10:00 <ski> forget
15:10:07 <jeffwheeler> @help forget
15:10:07 <lambdabot> forget nick quote.  Delete a quote
15:10:18 <jeffwheeler> @forget roco guys
15:10:18 <lambdabot> No match.
15:10:24 <jeffwheeler> @forget roco: guys
15:10:24 <lambdabot> No match.
15:10:28 <ski> whole quote
15:10:28 <jeffwheeler> :(
15:10:28 <Gracenotes> should be verbatim. The quote system is quirky.
15:10:39 <Gracenotes> as is the let/undefine system
15:10:40 <jeffwheeler> @forget roco: guys i have problem, does anybody know programming ?
15:10:40 <lambdabot> Done.
15:10:48 <jeffwheeler> @remember roco guys i have problem, does anybody know programming ?
15:10:48 <lambdabot> Good to know.
15:10:53 <jeffwheeler> @quote roco
15:10:53 <lambdabot> roco says: guys i have problem, does anybody know programming ?
15:10:55 <jeffwheeler> @flush
15:10:55 <lambdabot> Not enough privileges
15:10:57 <ski> @flush
15:10:57 <lambdabot> Not enough privileges
15:10:59 <jeffwheeler> :(
15:11:00 <ski> heh
15:11:18 <Gracenotes> GWERN CONTROLS THE FLUSHING
15:11:23 <Gracenotes> o_O
15:11:37 <jeffwheeler> gwern: @flush please. ;)
15:11:42 <Gracenotes> and the world, by proxy
15:11:51 <gwern> @flush !
15:12:04 <heatsink> @help flush
15:12:04 <lambdabot> flush. flush state to disk
15:13:20 <Rotaerk> hmm I don't like the use of "Just" as the alternative to "Nothing" in Maybe's, since "just" is typically used to distinguish singularity from plurality, not singularity from absence
15:13:43 <jeffwheeler> Rotaerk: I buy that. Any alternative?
15:14:02 <dankna> on the other hand, at least in English, zero is plural
15:14:08 <Rotaerk> something like "Surely" or "Definitely" comes to mind, but I'm still brainstorming
15:14:11 <Gracenotes> hm makes sense to me
15:14:16 <Rotaerk> dankna, that's because english is insane :D
15:14:20 <gwern> 'Something'?
15:14:28 <dankna> Rotaerk: haha, okay, but state that position explicitly :D
15:14:42 <ski> `None',`Some' ?
15:14:46 <osfameron> "FoShizzle"
15:14:49 <dankna> actually, it should be "A"
15:14:59 <dankna> hm
15:15:05 <jeffwheeler> I considered that too, but wouldn't that also be singular?
15:15:08 <dankna> yeah
15:15:11 <Rotaerk> I had thought maybe "Instance" would work, but that clashes with type-class semantics too much apparently
15:15:11 <dankna> just realizing that
15:15:15 <jeffwheeler> Then again, there is just one value.
15:15:27 <Rotaerk> Nothing | Instance a
15:15:29 <Zrs_> How about Maybe t = Nothing | Is t ?
15:15:37 <ski> `Single' ?
15:15:39 <Rotaerk> or Value
15:15:40 <ski> `One' ?
15:15:47 <Rotaerk> but that has numeric connotations
15:16:15 <Gracenotes> Just is pretty good. It is also a good-sized constructor name
15:16:42 <jeffwheeler> I like "A", despite what I said earlier.
15:16:55 <Zrs_> Four letters is a pretty good length. Is and A are way too short.
15:16:57 <Gracenotes> also makes sense reading
15:17:28 <Rotaerk> hmm I agree that 4 letters is good, I just find the semantics of "just" inappropriate, albeit subtlely so
15:17:53 <Rotaerk> subtly*
15:18:38 <Zao> Maybe t = Nothing | Asdf t
15:18:52 <Zao> Or even better, Qwer t
15:19:00 <dankna> then it would get confused with a Lisp package-management program that was also named by the lowest bidder.
15:20:59 <Rotaerk> Zao, :p
15:21:49 <Rotaerk> Nothing | One a
15:23:14 <dankna> surely One has the same problem as Just
15:23:28 <Rotaerk> hmm yea true
15:23:51 <idnar> data Maybe t = Nothing | t
15:23:53 * idnar hides
15:23:55 <Rotaerk> there's gotta be something like "Value" or "Instance" more general; I've heard "Thing" suggested
15:24:30 <Rotaerk> anyway, not that this issue even matters practically..
15:25:46 <RafaelGCPP> cya l8r
15:38:13 <Twey> Zao: Maybe t = Nothing | Uidh t
15:38:34 <dankna> ... what's Uidh?
15:38:48 <Twey> The four letters to the right of t :-P
15:39:01 <heatsink> data Something a = Its a | Nevermind
15:39:02 <dankna> on what keyboard?
15:39:11 <Twey> Dvorak
15:39:13 <dankna> I see
15:39:14 <Twey> heatsink: Hahaha, cute
15:39:18 <heatsink> :)
15:39:24 <dankna> cute indeed
15:39:29 <michie1> even on qwerty, it sort of corresponds to 'just'
15:40:03 <Twey> Or!
15:40:15 <Twey> data Maybe = Something | A t
15:40:22 <Twey> Er, Nothing**
15:40:30 <Zao> Because no-one else in the world would want to use A.
15:40:51 <Twey> Yes, but their usages would probably be *wrong*.
15:40:53 <Zao> Are ' valid in data ctors?
15:40:57 <Twey> Yes
15:41:04 <Zao> A'An then :P
15:41:06 <Twey> It's a | NeverMind
15:41:12 <Twey> Zao: Haha :-P
15:55:00 <FunctorSalad> I think "Just" makes sense. it doesn't signify singularity here, it signifies that "Just" is an embedding that isn't supposed to change the meaning of the value
15:55:09 <FunctorSalad> except distinguishing it from Nothing
15:56:10 <FunctorSalad> "Nothing" being the "Special" value
15:56:21 <FunctorSalad> "Just" = nothing out of the ordinary
15:57:49 <Twey> Yeah
15:57:51 <Twey> I guess so
16:10:56 <dm`> Can someone tell me what the best way to get access to ioctl information is with Haskell?  I need to find out the broadcast addresses of all the networks I'm connected to.  In C, I call ioctl SIOCGIFCONF, then iterate over the interfaces with SIOCGIFFLAGS and (if IFF_BROADCAST is set) SIOCGIFBRDADDR to get the interface's broadcast address.  Haskell's Network.Socket appears to support the SO_BROADCAST socket option, but I can't figure
16:10:56 <dm`> out how to get the broadcast address I should be sending to...
16:11:42 <Zao> dm`: Unless there's already a sysctl interface on Hackage, it's likely easiest to FFI to it yourself.
16:11:51 <Zao> http://hackage.haskell.org/package/bsd-sysctl
16:11:54 <Zao> Oh... ioctl
16:12:19 <Zao> s/sysctl/ioctl/ in the advice then :)
16:12:38 <dm`> except this URL doesn't work... http://hackage.haskell.org/package/bsd-ioctl
16:13:12 <Zao> Links are not advice :P
16:13:23 <dm`> Sorry, I tried searching for ioctl haskell, but couldn't find what I needed.
16:13:30 <dm`> Thanks anyway, though.
16:13:45 <Cale> It would be easy enough to actually call ioctl, but I'm not sure that's the best way
16:13:59 <Zao> The guts of the System.IO module probably has some ioctl stuff, but I doubt it's exposed.
16:14:01 <Cale> I'm just having a quick look through the network libraries
16:14:09 <Zao> The optimal way would be a nice fluffy portable query module.
16:17:03 <Cale> Well, okay, let's try ioctling :)
16:17:45 <dm`> I'm obviously a total newbie (but have read lots of stuff before starting to program in Haskell).  Would you mind pointing me in the right direction for actually calling ioctl?  Unfortunately Hoogle for ioctl turns up nothing.  Other stuff that might use ioctl is termios, but that also doesn't show up on Hoogle.  I'll shut up if my questions are too basic...
16:18:57 <Cale> Well, ioctl is one of those funny variadic functions, so could you say at what types you'd like to call it?
16:19:03 <Cale> foreign import ccall "sys/ioctl.h ioctl" ioctl :: ...
16:19:30 <Cale> It'll look like that, but with a Haskell type following which agrees with the C type at which you'd like to call it.
16:19:53 <monochrom> Normally someone writes a specific-purpose library that calls the necessary ioctl, then you call that library.
16:20:22 <mauke> warning: you can't just import a variadic function with a specific type and expect it to work
16:20:25 <Cale> monochrom: He's trying to get information about the available network interfaces.
16:20:30 <Cale> mauke: Really?
16:20:41 <Cale> mauke: I've done it before with success...
16:20:49 <mauke> C says it's undefined behavior
16:21:04 <mauke> platforms can use different calling conventions for vararg functions
16:21:35 <Cale> mauke: But... this isn't exactly C, this is the Haskell FFI, and I'm not sure exactly what it's generating.
16:22:05 <monochrom> OK, so you should look for a low-level network library on Hackage rather than a general-purpose ioctl binding.
16:22:18 <mauke> { int printf(const char *, int); printf("%d\n", 42); } // not valid C
16:22:39 <mauke> what else would the FFI generate?
16:22:53 <pikhq> mauke: Perfectly valid C. Just not valid *hosted* C. ;)
16:23:05 <Cale> mauke: It might not generate a C type at all.
16:23:05 <mauke> if it's not hosted, printf doesn't exist
16:23:17 <mauke> Cale: it has to generate a call
16:23:22 <Cale> mauke: It might import the header file specified and just generate a call.
16:23:37 <pikhq> Sure it does. You just defined it as an extern int printf(const char *, int);
16:23:44 <Cale> (you do have to say  sys/ioctl.h)
16:23:46 <mauke> pikhq: that's not a definition
16:23:54 <pikhq> Erm. Declared.
16:24:06 <mauke> I can declare things that don't exist
16:24:18 <pikhq> And the linker will hate you for it.
16:24:26 <mauke> Cale: right
16:24:44 <mauke> Cale: IIRC ghc -fvia-C does that, while -fasm doesn't use the headers
16:24:53 <dm`> Note that ioctl is not quite as bad as printf, because ioctl always has the name number of arguments.  It's prototyped as ioctl (int, int, ...) because the type of the last pointer changes depending on the integer.
16:26:24 <mauke> that doesn't save you if the ABI rules say that normal functions pass the first 2 args in registers, but vararg functions pass everything on the stack
16:26:58 <dm`> I see.  Bummer that it's not a void * then.
16:27:39 <Cale> But just try it and see if it works.
16:27:43 <Cale> It probably does anyway.
16:27:59 <Cale> and if it doesn't work, then shout at the GHC maintainers. It's their problem then.
16:28:28 <Cale> You should be able to import vararg C functions at specific *Haskell* types, regardless of what the C standard says.
16:28:59 <Cale> (there would be no way to call them otherwise)
16:29:25 <skalnik> BONUS: I'm learning haskell because of you ;)
16:29:49 <dm`> Okay, will read up on FFI (haven't used it before) and give it a shot.  I suppose a fallback option would be to parse the output of the ifconfig command, but that's less portable--plus I kind of want to do this right because I'm learning haskell.
16:29:56 <heatsink> I think vararg functions use the stdcall calling convention, like int printf();
16:30:23 <heatsink> Not really sure though.
16:30:44 <mauke> "However, because C permits the calling convention to be different for such functions; a Haskell system will, in general, not be able to make use of variable argument functions. Hence, their use is deprecated in portable code. "
16:30:46 <Cthulhon> varargs need _cdecl.
16:30:50 <Cthulhon> *__
16:30:51 <heatsink> I recall being irritated that C couldn't pick a calling convention and stick to it.
16:30:51 <mauke> thus spake the FFI
16:30:59 <Cthulhon> Because the caller has to cleanup.
16:31:27 <Cthulhon> __stdcall is callee-cleanup.
16:31:58 <mauke> Cale: that's right, the FFI doesn't let you call all C functions
16:32:05 <heatsink> hmm.
16:32:11 <pikhq> heatsink: Windows couldn't pick a calling convention and stick to it.
16:32:22 <pikhq> Slight difference. ;)
16:32:35 <Zao> http://blogs.msdn.com/oldnewthing/archive/2004/01/08/48616.aspx
16:32:41 <Zao> Now now, there's just half a dozen or so.
16:32:52 <Cale> mauke: That is pretty cheap if it specifies it that way. But does it actually matter? Does it actually fail in practice?
16:33:07 <Cthulhon> You should be glad you don't have to deal with MSVC code that uses an optimized __fastcall that passes stuff in ebp/edi/esi.
16:33:08 <mauke> "Okay, here we go: The 32-bit x86 calling conventions. "  <- note: not "C calling conventions"
16:33:11 <Zao> pikhq: I blame all the assembler haxxor kiddies.
16:33:34 <mauke> Cale: I don't know, I haven't used a 64 bit processor yet
16:33:42 <heatsink> What does this have to do with windows?  We're talking about varargs?
16:33:45 <mauke> it obviously works on intel x86
16:34:00 <pikhq> Zao: Easy to blame, yes.
16:34:01 <mauke> heatsink: you said "stdcall"
16:34:13 <pikhq> mauke: Obviously calling conventions are processor-dependent.
16:35:15 <Baughn> It's pretty much "N registers, overflow on stack, arguments from right to left" on every cpu. Of course, N varies
16:35:59 <Baughn> C does that much, at least; calling conventions have to fit its assumptions
16:36:06 <pikhq> Baughn: cdecl doesn't "overflow on stack".
16:36:19 <mauke> pikhq: why not?
16:36:25 <pikhq> cdecl pushes all arguments on the stack, and returns in eax or st0.
16:36:30 <mauke> yeah, so N = 0
16:36:57 <pikhq> Ah.
16:37:42 <burp> @hoogle (Num a) => a -> a -> a
16:37:43 <lambdabot> Prelude (*) :: Num a => a -> a -> a
16:37:43 <lambdabot> Prelude (+) :: Num a => a -> a -> a
16:37:43 <lambdabot> Prelude (-) :: Num a => a -> a -> a
16:37:54 <burp> @hoogle (Fractional a) => a -> a -> a
16:37:54 <lambdabot> Prelude (/) :: Fractional a => a -> a -> a
16:37:54 <lambdabot> Prelude asTypeOf :: a -> a -> a
16:37:54 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
16:37:56 <Baughn> The point is, you rarely have to deal with weird things like "number of arguments passed in %r0, pointer to parameter array in %r1"
16:38:13 <Baughn> "..parameters type-tagged"
16:38:14 <mauke> that's tame :-)
16:38:20 <gwern> http://www.reddit.com/r/programming/comments/8y8mb/bloxorz_an_opengl_logic_game_written_in_haskell/c0at78s <-- hahah. I like dons ambiguity there
16:38:23 <mauke> I want per-type argument stacks
16:38:37 <Baughn> What's getting stacked up, then?
16:39:22 <mauke> f("foo", 42, "bar"); ==> "foo", "bar" go on char * stack; 42 goes on int stack
16:39:23 * pikhq wants a stack of heaps
16:39:42 <Baughn> mauke: Oh, sorry, I read that as per-parameter stacks
16:39:50 <Baughn> ..could be fun. One stack per parameter index.
16:43:51 <swolchok1> is Haskell "ready" yet? I started learning a couple years ago, and then quit when even the Haskell advocates on Proggit said it was not production-ready.
16:44:26 <jmcarthur> swolchok1: who said that?!
16:45:02 <monochrom> Haskell is more than ready.
16:46:07 <swolchok1> right then, it is back on the list of possibilities just as soon as I find myself an excuse to learn something new.
16:46:18 <swolchok1> thanks
16:46:19 <dons> what are you waiting for?
16:46:23 <dons> wow.
16:46:31 <monochrom> WAIT_FOR_RDY
16:46:50 <dons> i wonder if he's betting his business on monochrom @ #haskell's one liners.
16:46:56 <inimino> waiting for MSVH++
16:48:20 <monochrom> It's prudent to bet on my one-liners.
16:50:55 <lilac> i won Â£50 two weeks ago that way, but the bookie has wised up now
16:51:03 <dons> Fortune 500 companies rely on monochrom.
16:53:42 <FunctorSalad> "<monochrom> Haskell is more than ready." <<< above link by gwern contains a pretty upvoted reddit posting saying that it's only good for masturbatory purposes :|
16:54:14 <ehird> 00:38 gwern: http://www.reddit.com/r/programming/comments/8y8mb/bloxorz_an_opengl_logic_game_written_in_haskell/c0at78s <-- hahah. I like dons ambiguity there
16:54:15 <ehird> lol, yes
16:54:23 <FunctorSalad> well of course there won't be commercial examples before there are commercial examples
16:54:47 <ehird> dons' constant haskell advocacy is cute :)
16:55:05 <ehird> i'm not sure why we're all so insecure about haskell's popularity.
16:55:07 <ehird> chillax.
16:56:01 <dankna> yes, exactly
16:56:08 <dankna> who cares about the popularity?
16:56:21 <ehird> people who whine about haskell being useless on reddit are never gonna be huge corporate users
16:56:29 <ehird> so telling them it's oh-so-practical just makes everyone think we're desperate
16:56:41 <dons> that's an interesting interpretation.
16:56:42 <dankna> it either serves your need or it doesn't.  if it doesn't catch the whole world's eye, that doesn't mean this is a bad world, just a crowded one where it's hard to pick out the good things.
16:57:11 <dankna> ... but we'd probably be worse off without some people advocating, all the same
16:57:23 <ehird> yeah, I like the advocacy, I just see it as a bit over the top
16:57:35 <dons> ehird: do you have an example?
16:58:34 <ehird> dons: well, it just seems that whenever someone says lame things about haskell being impractical blabla a long thread follows, and it seems that a bunch of articles have only tangentially-related haskell comments; iirc there was a reddit post about haskell being plugged a lot on proggit where people commented about how it was weird
16:58:35 <dons> actually, we hardly ever have stuff outside the haskell reddit  these days
16:58:43 <ehird> yeah I notice it less nowadays
16:59:00 <olsner> why does ghc suggest to enable RankNTypes when you use forall syntax? isn't that existential quantification?
16:59:03 <monochrom> I have learned from the AI debate that there is no need to debate. Just work things out.
16:59:11 <dons> its good not to debate wrong things.
16:59:16 <ehird> olsner: rankntypes is a superset, iirc
16:59:38 <dankna> olsner: funnily enough, I just wondered about that myself.  I think RankNTypes lets you use them in more places, but not sure exactly where.
16:59:38 <dons> ehird: at some point, you have to stand up for your stuff publically. we never used to do that.
17:00:34 <dons> so when people say dumb things, I'm going to hit them. but that's it. we should avoid saying stupid things, and pointless debates
17:00:35 <olsner> I think both enable the syntax, but then enable different sets of other stuff that you can do with it
17:00:35 <ehird> i don't recall ruby people going around saying "actually, ruby is totally practical!" in like 2004-2005
17:00:35 <ehird> people just made cool stuff with rails and everyone else followed
17:00:47 <dons> oh boy, the ruby guys had a /massive/ marketing effort
17:01:04 <dons> they are almost the epitome of heavy advocacy. it was explicit, coordinated, and wildly succesful in the end
17:01:07 <ehird> dons: well, for all the effort it was, it was subtle enough that it didn't appear in-your-face to me :)
17:01:20 <monochrom> Three points. (A) The deniers rely on circular arguments and self-fulfilling prophecy. (B) Work hard to implement what they think impossible to rub it into their faces. (C) Walking out of the debate also means avoiding giving too high expectations. Avoids PR disaster.
17:01:59 <dons> also, its the internet. don't take it too seriously.
17:02:02 <olsner> this seems to be an attempt to sort it (forall syntax vs type system extensions) all out: http://nibrofun.blogspot.com/2009/06/whats-in-forall.html
17:02:43 <olsner> I've already read it though and I don't know the answer to my question, so I guess that guy kind of failed to sort it out :)
17:02:45 <inimino> Ruby marketing was huge but then again... I think most people here would affirm that Haskell stands on its merits in a way that Ruby may not
17:03:01 <chessguy> hi gang
17:03:21 <dons> its a delicate tension. we stood on our meris - only - for 15 years. there has to be some outward facing activities.
17:03:49 <dons> it should consist of interesting, repeatable, relevant information.
17:03:55 <Cale> Don't market Haskell! Haskell is our secret. If it becomes popular, it should only be because there are many people interested in programming in a decent language.
17:04:28 <olsner> Haskell is the Field of Dreams of programming?
17:05:00 <Cale> (and if it doesn't, that's okay with me... there's already way more code written in Haskell than I can read...)
17:05:11 <inimino> if Haskell were to become the next Ruby, in either the marketing or community aspects, I would certainly be disappointed
17:05:17 <olsner> (hmm, strike that, that would mean that only dead mathematicians would use it)
17:05:54 <SamB> ruby has a community?
17:06:16 <skalnik> :o Yes it does
17:06:22 <roconnor> Cale: Don't worry, we can move to Epigram after Haskell becomes popular.
17:06:30 <skalnik> How is a .ghcl file structured?
17:06:58 <skalnik> throwing :set prompt "ghci> " in it doesn't seem to work
17:06:58 <Cale> skalnik: Your .ghci is just a list of commands as you'd type them at the ghci prompt
17:07:07 <SamB> how does one access the ruby community?
17:07:20 <dankna> SamB: it requires IO ()
17:07:27 <impl> skalnik: a retarded community.
17:07:33 <SamB> dankna: it usually does
17:07:35 <Cale> skalnik: .ghci or .ghcl ?
17:07:41 <SamB> that's the way using the internet tends to work ;-P
17:07:46 <skalnik> Cale: ah, I guess I misread, is it .ghci?
17:07:48 <dankna> true enough
17:07:50 <skalnik> impl: hi there :)
17:07:51 <Cale> skalnik: yeah
17:07:58 <impl> (ohai)
17:08:46 <roconnor> Should I try to figure out why my VM is 4x slower in GHC 6.10 vs GHC 6.8?
17:08:52 <skalnik> impl: did you hear the news? Yahovah died
17:08:56 <SamB> roconnor: yes
17:09:03 <roconnor> anyone want to help/
17:09:04 <roconnor> ?
17:09:06 <impl> skalnik: "died"?
17:09:14 <skalnik> apparently
17:09:29 <skalnik> like Michael Jackson died
17:09:45 <SamB> roconnor: well, you could start by profiling it in both environments ... with cachegrind, if nothing else
17:09:46 <impl> ...
17:09:57 <dons> roconnor: probably you should find out.
17:10:03 <dons> roconnor: -fvia-C vs -fasm ?
17:10:09 <olsner> gaah, which combination of magic will allow me to have a list [forall a . Foo a => [a]]?
17:10:10 <roconnor> oops, I rebooted and lost my GHC 6.10 in tmp
17:10:16 <roconnor> dons: just -O2
17:10:27 <SamB> roconnor: default changed, maybe?
17:10:35 <roconnor> perhaps
17:10:47 <roconnor> that's why I need #haskell help :)
17:11:03 <FunctorSalad> olsner: do you really not want an existential there
17:11:10 <impl> skalnik: I demand proof. I see no obit.
17:11:13 <SamB> so, first of all, put your ghc 6.10 build somewhere other than /tmp this time ;-)
17:11:22 <skalnik> impl: Just what I heard
17:11:41 <olsner> FunctorSalad: what I'm trying to do is allow each entry in the outer list to have a different 'a'
17:12:20 <roconnor> SamB, hmm
17:12:56 <SamB> also you might want to have the core code for all library modules saved
17:13:07 <roconnor> oh right, libs
17:13:10 <roconnor> that was a big issue
17:13:32 <skalnik> impl: what was Yahovah's real name?
17:13:38 <impl> Charles Newton
17:13:42 <monochrom> VM? You mean like VMWare and VirtualBox?
17:13:47 <roconnor> SamB, if I send you code, are you willing build under both GHC 6.8 and GHC 6.10 to confirm?
17:13:49 <skalnik> Lies.
17:13:56 <impl> not a lies.
17:14:04 <wli> skalnik: Yamm (Yaw), the Canaanite god of the stormy sea.
17:14:08 <roconnor> monochrom: as in ICFP2009 VM
17:14:08 <SamB> roconnor: uh, I don't have both
17:14:15 <skalnik> wli: The same to you
17:14:16 <roconnor> darn
17:14:17 <monochrom> I see. Nevermind.
17:14:46 <FunctorSalad_> olsner: [forall r. (forall a. Foo a => [a] -> r) -> r]
17:14:58 <SamB> roconnor: would be happy to if I actually had room to install both, though
17:15:16 <FunctorSalad_> (or make an existential datatype data AnyFooList = forall a. Foo a => AnyFooList [a])
17:15:59 <wli> skalnik: He was at one point in competition with Ba'al Hadad for the rulership of heaven or otherwise chief status amongst the Elohim (the children of El, an older chief god).
17:16:26 <olsner> FunctorSalad: why the extra 'r'? a dummy to make the typechecker happy?
17:16:32 <roconnor> SamB: :)
17:16:51 <FunctorSalad_> olsner: to get an existential. currently you have a universally quantified
17:17:04 <FunctorSalad_> "a", the type variable
17:17:32 <FunctorSalad_> that reformulation puts the "forall a" in a negative position, so it becomes existential
17:17:37 <olsner> hmm, ImpredicativeTypes made my current code type-check
17:17:41 <FunctorSalad_> but maybe making that datatype is less confusing
17:17:54 <Woof> @bf .
17:17:54 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
17:17:55 <roconnor> olsner: ooh, you must be doing something interesting
17:18:30 <olsner> roconnor: that is a clear indication that I'm probably doing something kind of wrong :D
17:19:32 <roconnor> olsner: quite possible
17:19:46 <monochrom> IIRC â€œrunST $ do ...â€ already wants impredicative types. Poster boy for that extension.
17:20:32 <monochrom> This is one reason I despise $, BTW.
17:21:10 <olsner> this way will require unsafeCoerce to be able to get the [a] back into the user code's actual type (building a kind of heap structure for storage of arbitrary haskell data)
17:21:36 <monochrom> Indeed runST has a contravariant forall.
17:21:49 <roconnor> monochrom: that varies from GHC version to GHC version
17:22:53 <roconnor> any tips on using cabal install to install packages on a non-standard GHC?
17:26:09 <monochrom> Precisely because GHC 6.4 and before did not have impredicativity, and 6.6 and after do.
17:26:14 <ManateeLazyCat> Hi all. function `readFile` in Data.ByteString.Lazy return `IO ByteString`, and function `toString :: ByteString -> String` is in Data.ByteString.UTF8, and those two `ByteString` is different type, so if i want transform ByteString to String with UTF8 decode, how to do it?
17:26:44 <EvilRanter> ManateeLazyCat, could you use ByteString.UTF8 exclusively?
17:26:59 <monochrom> http://www.haskell.org/ghc/docs/6.6/html/users_guide/release-6-6.html  section 1.4.1, 2nd bullet.
17:27:11 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/44608/match=impredicative
17:27:37 * ManateeLazyCat pasted "my source code" at http://paste2.org/get/303646
17:27:41 <ManateeLazyCat> EvilTerran: See above
17:27:46 <FunctorSalad_> I have to admit this just made me laugh hysterically... http://www.reddit.com/r/programming/comments/7v48v/if_you_post_an_advert_for_a_haskell_developer_you/c07hnd3
17:29:50 <monochrom> heheh
17:31:17 <olsner> meh, x:xs won't work for my existential list - the inferred type is less polymorphic than expected
17:31:24 <FunctorSalad_> I mean, the original mailing list posting is asking for it... "If you post an advert for a Haskell developer you will get 20 applicants."
17:31:47 <FunctorSalad_> olsner, as I said, you have a universal there, not an existential
17:32:13 <ManateeLazyCat> In http://paste2.org/get/303646 , I got error B.ByteString against ByteString in "  let string = U.toString byteString ", how to fix?
17:32:52 <FunctorSalad_> @go haskell-wiki existential
17:32:53 <lambdabot> http://www.haskell.org/haskellwiki/Existential_type
17:32:53 <lambdabot> Title: Existential type - HaskellWiki
17:33:19 <olsner> FunctorSalad_: ah, you did... seems I didn't understand you :P
17:33:34 <SubStack> > head <$> groupBy ((.).(.)) (< 2) subtract) [1,3,4,5,6,9,10,11]
17:33:35 <lambdabot>   <no location info>: parse error on input `)'
17:33:51 <SubStack> > head <$> groupBy (((.).(.)) (< 2) subtract) [1,3,4,5,6,9,10,11]
17:33:52 <lambdabot>   [1,3,5,9,11]
17:33:57 <SubStack> :D
17:34:41 <EvilTerran> ManateeLazyCat, i mean, you could use System.IO.UTF8.readFile from the utf8-string package (if i'm right in thinking that's what you're using) instead of Data.ByteString.Lazy.readFile
17:34:51 <SubStack> pointfree is so beautiful
17:34:52 <olsner> this seems to work though: data Anything = forall a . Anything a
17:35:17 <FunctorSalad_> <FunctorSalad_> (or make an existential datatype data AnyFooList = forall a. Foo a => AnyFooList [a])
17:35:24 <olsner> yeah, I just removed the type-class constraint from before, turns out I don't really need it
17:35:30 <FunctorSalad_> then have [AnyFooList] on the outside
17:35:46 <ManateeLazyCat> EvilTerran: Yep, System.IO.UTF8.readFile can work, but it slow? it return String and not ByteString
17:35:58 <FunctorSalad_> if you have no constraint you won't be able to do anything with the value (except unsafeCoerce)
17:36:52 <olsner> yeah, unsafeCoerce is the only thing I'd have used on the values anyway
17:36:54 <ManateeLazyCat> EvilTerran: Looks ByteString is more efficient than String
17:38:11 <EvilTerran> ManateeLazyCat, bytestrings are sequences of bytes, they're not suitable for representing unicode directly
17:38:46 <olsner> (unless you actually are able to work with the UTF-8 representation directly)
17:39:05 <ManateeLazyCat> EvilTerran: So System.IO.UTF8.readFile is only solution?
17:39:16 <ManateeLazyCat> olsner: Yep, i use UTF-8, i'm Chinese.
17:39:27 <EvilTerran> i dunno, there might be something else useful buried in the docs on http://hackage.haskell.org/package/utf8-string-0.3.5 somewhere
17:39:35 <roconnor> okay, GHC 6.10 is still about 4x slower on my test code.  Now what do I do?
17:39:37 <roconnor> profile it?
17:40:06 <dm`> Quick question.  What does the "|" mean in, say, "class MonadState m s | m -> s where ...".  This syntax doesn't seem to agree with section 4.3 of Haskell report, but I'm probably just misunderstanding the report.
17:40:08 <ManateeLazyCat> EvilTerran: I heard GHC 6.12 will including "Unicode IO"
17:40:50 <ManateeLazyCat> dm`: It like branch
17:41:09 <ManateeLazyCat> dm`: Like `case` brance
17:41:12 <ManateeLazyCat> branch
17:41:27 <ManateeLazyCat> dm`: Sorry, see wrong
17:41:29 <Petrosian> dm`: It's a functional dependency
17:41:45 <Petrosian> dm`: And extension to type classes
17:41:48 <dm`> Meaning m's output has to be of type s?
17:42:00 <dm`> So not in Haskell report?  What's the best place to read about this?
17:42:17 <Petrosian> dm`: Meaning that the type of s depends on that of m
17:42:51 <FunctorSalad_> dm`: GHC user's guide
17:42:52 <dm`> But m and s have different kinds, so?
17:42:59 <dm`> Ok, will check users guide.  Thanks.
17:43:05 <EvilTerran> ?where fundeps
17:43:05 <lambdabot> I know nothing about fundeps.
17:43:07 <EvilTerran> ?where fundep
17:43:07 <lambdabot> I know nothing about fundep.
17:43:21 <FunctorSalad_> http://haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
17:43:27 <ManateeLazyCat> EvilTerran: I got it.
17:43:39 <Petrosian> dm`: Adding multiparameter type classes can cause a lot of ambiguity
17:43:52 <Petrosian> dm`: Fundeps are a way to resolve them
17:43:53 <roconnor> okay, both version run the GC about 33% of the time
17:43:54 <ManateeLazyCat> EvilTerran: Must use `Data.ByteString.Lazy.UTF8` if i use readFile in `Data.ByteString.Lazy`
17:44:19 <ManateeLazyCat> EvilTerran: If i use Data.ByteString i have to use Data.ByteString.UTF8
17:44:20 <roconnor> GHC 6.8: 6,506,103,220 bytes allocated in the heap
17:44:25 <ManateeLazyCat> EvilTerran: Thanks for your help
17:44:30 <roconnor> GHC 6.10: 20,828,215,084 bytes allocated in the heap
17:44:36 <dm`> "There should be more documentation, but there isn't (yet). Yell if you need it. "
17:44:37 <dm`> ha
17:45:24 <roconnor> GHC 6.8: 12412 collections in generation 0 (  5.07s)
17:45:38 <roconnor> GHC 6.10: Generation 0: 39500 collections,     0 parallel, 21.51s, 23.78s elapsed
17:46:06 <roconnor> has GHC 6.10 changed how it handles freezing and thawing STUArrays?
17:46:12 <roconnor> cause I do that a lot
17:46:13 <Petrosian> dm`: http://www.haskell.org/haskellwiki/Functional_dependencies could try that, haven't read it myself mind
17:47:18 <dm`> Excellent.  Thanks guys, you are so helpful!
17:48:01 <roconnor> how do I make profiling libs for cabal installed libraries?
17:48:19 <olsner> install -p iirc
17:48:29 <olsner> a flag to cabal install, anyway
17:49:15 <FunctorSalad_> --enable-library-p
17:49:33 <FunctorSalad_> you want "--enable-library-p --reinstall" probably
17:49:40 <roconnor> hmm
17:49:42 <roconnor> -p seems to work
17:49:55 <FunctorSalad_> rats! so much typing in vain
17:49:59 <olsner> -p is an alias for --enable-library-profiling apparently
17:50:05 <roconnor> whew
17:50:09 <FunctorSalad_> (over all the years)
17:50:30 <FunctorSalad_> I even made a bash alias for it
17:50:34 <olsner> all the years? how long has cabal-install been out anyway? :)
17:50:45 <FunctorSalad_> yes, years was exaggerated ;)
17:51:27 <roconnor> whew, profiling is hard work
17:51:53 <roconnor> I don't know how people do it with 1000000 dependencies
17:52:03 <roconnor> thankfully I only have 3
17:52:05 <roconnor> er
17:52:07 <roconnor> 2
17:52:29 <roconnor> I bet the freeze/thaw functions are the root of the problem
17:55:46 <roconnor>     Could not find module `Complex':
17:55:48 <roconnor>       Perhaps you haven't installed the profiling libraries for package haskell98?
17:55:49 <roconnor> crap!
17:55:56 <roconnor> I installed ghc6-prof!
17:56:00 <roconnor> why do I get this error?
18:02:50 <roconnor> damn
18:04:15 <roconnor> why is it looking in /usr/local/lib/haskell98-1.0.1.0/ghc-6.8.2/Complex.p_hi instead of /usr/lib/haskell98-1.0.1.0/ghc-6.8.2/Complex.p_hi
18:04:17 <roconnor> hmm
18:05:09 <roconnor> well
18:05:17 <roconnor> instead of /usr/lib/ghc-6.8.2/lib/haskell98-1.0.1.0/Complex.p_hi
18:06:47 * roconnor drowns in Debian
18:08:48 <roconnor> why is my haskell98-1.0.1.0 installed in usr/local ?
18:09:22 <heatsink> Does dpkg -s tell you it's part of a package?
18:09:33 <heatsink> dpkg -s <file>
18:10:02 <roconnor> Package `/usr/local/lib/haskell98-1.0.1.0/ghc-6.8.2/complex.hi' is not installed and no info is available.
18:11:08 <heatsink> dpkg understands filenames, so give it the exact filename.
18:11:15 <roconnor> I did
18:11:30 * roconnor tries reinstalling ghc6
18:11:43 <heatsink> It's not part of a package then.
18:12:52 <olsner> eeeeh, does the haskell array libraries really don't support creating empty arrays?
18:12:55 <heatsink> Also, debian usually doesn't put package files in /usr/local
18:13:10 <roconnor> dpkg -s /usr/bin/ghc6
18:13:11 <roconnor> Package `/usr/bin/ghc6' is not installed and no info is available.
18:13:16 <heatsink> olsner, You can create arrays containing undefined, or something similar
18:13:43 <roconnor>  dpkg -s /usr/bin/ghc-6.8.2
18:13:45 <roconnor> Package `/usr/bin/ghc-6.8.2' is not installed and no info is available.
18:13:50 <heatsink> roconnor, that file is actually a symlink, not part of a package
18:13:55 <olsner> yeah, but that's wrong since it looks exactly like an array of one element
18:14:19 <heatsink> Oh, you mean an array with zero elements.  Never tried that before.
18:15:15 <heatsink> > array (0,-1) []
18:15:17 <lambdabot>   array (0,-1) []
18:15:29 <olsner> > array (1,0) []
18:15:30 <lambdabot>   array (1,0) []
18:15:38 <olsner> > array (1,0) [1,2,3]
18:15:39 <lambdabot>   No instance for (GHC.Num.Num (t, e))
18:15:39 <lambdabot>    arising from the literal `1' at <in...
18:15:40 <roconnor> damn
18:15:43 <olsner> > array (1,1) [1,2,3]
18:15:44 <lambdabot>   No instance for (GHC.Num.Num (t, e))
18:15:44 <lambdabot>    arising from the literal `1' at <in...
18:16:17 <olsner> roconnor: -S :)
18:17:12 <heatsink> roconnor, sorry, it's been a while since I used that feature.
18:17:16 <roconnor> $ dpkg -S /usr/lib/ghc-6.8.2/lib/haskell98-1.0.1.0/Complex.hi
18:17:18 <roconnor> ghc6: /usr/lib/ghc-6.8.2/lib/haskell98-1.0.1.0/Complex.hi
18:17:37 <roconnor> ahhhhhhhhh
18:17:43 <roconnor> why is it looking in usr/local?
18:18:09 <roconnor> should I unregister the package?
18:18:12 <heatsink> Is it only looking in /usr/local?  It should look in /usr and /usr/local
18:18:31 <roconnor> only usr/local
18:18:45 <heatsink> olsner, array takes a list of (index, element) pairs
18:18:48 <heatsink> Hmm
18:18:54 <roconnor> $ ghc-pkg describe haskell98
18:19:00 <roconnor> library-dirs: /usr/local/lib/haskell98-1.0.1.0/ghc-6.8.2
18:19:01 <roconnor> etc
18:20:00 <roconnor> or is there some sort of ghc-pkg update command I can use?
18:21:11 <roconnor> what type of argument does ghc-pkg update/register require?
18:21:28 <roconnor> ghc-pkage update /usr/lib/ghc-6.8.2/package.conf  ?
18:23:09 <roconnor> ghc-pkg update /usr/lib/ghc-6.8.2/package.conf.shipped ?
18:25:51 <roconnor> ah fuck it
18:27:23 <heatsink> yeh, I dunno how to use ghc-pkg
18:28:01 <roconnor> ghc must have failed to upgrade properly, and now it is fucked.
18:33:07 <roconnor> I wonder how nix and cabal get along
18:33:42 <roconnor> they probably don't
18:34:25 <hackagebot> bamboo-plugin-highlight 2009.7.5 - A highlight middleware (JinjingWang)
18:34:25 <hackagebot> bamboo-plugin-photo 2009.7.5 - A photo album middleware (JinjingWang)
18:35:01 <Berengal> I don't suppose it's somehow possible to merge two different types into one somehow?
18:35:12 <heatsink> Either?
18:35:29 <roconnor> hmm ghc-6.6.1 seems to be the latest version of GHC in Nix
18:35:31 <Berengal> Not the sum, but making them the same type
18:35:45 <roconnor> Berengal: huh?
18:35:45 <Berengal> Assuming they've got the same name and form already
18:36:12 <roconnor> double huh?
18:36:19 <Berengal> Imagine two modules both declaring data Foo = Foo Int
18:36:27 <roconnor> oh, you can't
18:36:41 <Berengal> Yeah, that's what I figured...
18:36:54 <roconnor> put the definition in one file
18:37:04 <roconnor> one module
18:37:07 <Berengal> Now imagine they're in two different packages...
18:37:14 <dankna> depending on what you're trying to achieve, you probably want to create a third file with the definition in it and make the other two files both use it
18:37:21 <roconnor> put it in a separate package they both depend on
18:38:05 <Berengal> Yeah, a separate package would probably be the best solution...
18:38:27 <Berengal> But then imagine you aren't the maintainer of either package
18:38:38 <Berengal> And one of them hasn't been updated for over a year :/
18:38:46 <Petrosian> What data structure can I use for fast append? Sequence?
18:38:47 <roconnor> oh boy,  Nix is almost 2 years out of date
18:38:57 <dankna> my mind boggles.  I cannot imagine this.  perhaps it's time to get more concrete and tell us the names of the packages. :)
18:39:13 <roconnor> er, at least the stable release ie
18:39:14 <lpsmith> petrosian:  sequence should work pretty well
18:39:14 <roconnor> is
18:39:24 <Petrosian> lpsmith: Thanks.
18:39:33 <heatsink> What is nix?
18:40:04 <roconnor> heatsink: http://nixos.org/index.html
18:40:11 <Berengal> dankna: Unfortunately, my situation proved to be even worse: the packages I want don't even use the same data representation
18:40:14 <roconnor> Nix is a purely functional package manager.
18:40:27 <dankna> oh.  well in that case you've got a problem :)
18:40:53 <roconnor> ah, the unstable branch has ghc 6.10
18:41:15 <Berengal> Yeah. I was promised useful combinators in the package I want, but they're not there, so I went shopping somewhere else...
18:41:25 <Berengal> Looks like I'll have to implement them myself
18:41:54 * dankna nods
18:42:25 <roconnor> Berengal: are the packages OSS?
18:42:44 <Berengal> roconnor: BSD3
18:42:44 <roconnor> Berengal: in which case you need to fix one or both of them
18:42:58 <Berengal> Yup
18:43:26 <dankna> well, I think "need" is a bit subjective there
18:43:37 <dankna> it can be a bit daunting to just tell someone "congratulations, you're the new maintainer!"
18:43:38 <Berengal> It was pretty broken to start with, and I'm still debating wether it'd be fun to fix it or not...
18:43:54 <dankna> but by all means do fix it if you judge it worthwhile
18:44:04 <dankna> what is it, anyway?
18:44:22 <Berengal> On one hand it's probably going to be quite some tedious work, but on the other hand it's probably going to be awesome once I'm starting to get there
18:44:24 <Berengal> HSP
18:44:54 <poh> when I try to install happy with cabal install, I get:  "Could not find module `Distribution.Simple.Program'" what causes this?
18:44:54 <dankna> ah, http://hackage.haskell.org/package/hsp ?  cool.
18:45:02 <Berengal> Yep
18:45:24 <dankna> you might also look in to happstack, which is MUCH more heavyweight, but the same basic goal
18:45:55 <Berengal> Far as I've understood it, happstack is basically a server
18:46:07 <dankna> well, yes, that's my understanding as well - I haven't actually used it
18:46:33 <Berengal> The content-generation uses templates, which are much less heavyweight than hsp
18:46:57 <dankna> heh, okay
18:47:00 <dankna> I like templates, haha
18:47:09 <jmcarthur> happstack is just a collection of libraries which don't have to be used together
18:47:17 <jmcarthur> i use hsp with it
18:47:52 <Berengal> Templates seem okay, but they're just another string library. HSP generates XHTML, which makes the static typing part of me happy
18:48:41 <dankna> order of magnitude speed difference though.  (note: based on past experience with totally different libraries, not on specific knowledge)
18:49:22 * jmcarthur has no idea which is faster
18:50:05 <dankna> the templates
18:51:16 <Berengal> hsp is compiled to binary code...
18:51:43 <Berengal> Although I guess it might be slower to prettyprint the xml, generating it should be fast enough
18:52:00 <dankna> all I can say is, in the past I have found that not to be the case
18:52:26 <dankna> it makes some intuitive sense that if you're doing control logic every few characters, that's slower than if you can blit large chunks
18:52:57 <Berengal> Yeah, I guess that's true
18:53:06 <dankna> depending on your performance needs, you might not even notice, of course
18:53:18 <Berengal> Anyway, speed's not important to me. I'm unlikely to be creating the next facebook...
18:53:22 <dankna> right, just so
18:55:02 <Berengal> and going 'table . map (tr . map td) . map (\p -> [firstName p, lastName p]) $ people' makes me a happy web programmer
18:55:29 <roconnor> ghc-pkg describe '*'  doesn't work for me
18:56:30 <ehird> "You know what they call non-functional programming conferences? Programming conferences."
18:56:35 <ehird> Dumbest thing I've heard all day.
18:57:19 <dankna> yes, there's definitely the ease-of-implementation argument to consider
18:58:31 <pragma_> Meaning that non-functional programming languages are considered actual programming languages, whereas functional languages are esoteric and impractical for real-world implementations?
18:58:50 <Gracenotes> ah, my birthday party is over, guests are going home
18:58:51 <ehird> Clearly!
18:58:51 <roconnor> @slap ghc-pkg
18:58:51 * lambdabot would never hurt ghc-pkg!
18:58:54 <pikhq> ... Functional programming languages are considered impractical?
18:58:55 <roconnor> @slap ghc-pkg!
18:58:55 * lambdabot pulls ghc-pkg! through the Evil Mangler
18:59:04 <pikhq> Sweet, C++ is soon to be considered impractical.
18:59:30 <pikhq> (soon, a subset of functions in C++ will be first class. A subset because C++ is royally fucked up.)
19:01:56 <roconnor> god damn it ghc-pkg, stop looking in the global database!!
19:01:59 <dibblego> ehird, source?
19:02:07 <ehird> dibblego: http://www.reddit.com/r/programming/comments/8y8mb/bloxorz_an_opengl_logic_game_written_in_haskell/c0atae8
19:03:36 <chessguy_> man everyone's so excited about that game
19:04:34 <ehird> Ot
19:04:39 <ehird> It's gonna revolutionize programming, man.
19:05:45 <Gracenotes> could this be Haskell's killer app??
19:05:45 <inimino> Ot?
19:06:32 <gwern> http://personal.cis.strath.ac.uk/~conor/pub/she <-- forbidden for anyone else?
19:06:39 <ehird> inimino: Typo.
19:06:42 <ehird> gwern: Yes.
19:06:46 <gwern> inimino: as in, it's an 'ot of fun
19:06:55 * Gracenotes stares at 'personal' prefix
19:07:45 <inimino> ehird: oh.
19:08:15 <gwern> is conor macbride ever here?
19:08:53 <gwern> ah, I'll just email im
19:09:36 <Petrosian> do
19:09:36 <Petrosian> 			(d,t) <- get
19:09:36 <Petrosian> 			put (d, t |> x)
19:09:36 <Petrosian> 			return ()
19:09:40 <Petrosian> Gah, sorry.
19:12:02 <defun> I'm a tad confused about software licensing. The GPL claims that no proprietary softwarecan link to it. But what if a software under the LGPL or BSD license links to a GPL program, and a proprietary program links to the LGPL or BSD software. So it looks like GPL -> BSDorLGPL -> Proprietary. Is this valid?
19:12:26 <ehird> defun: the gpl claims that no non-gpl can link to it
19:12:29 <ehird> not no proprietary
19:12:48 <roconnor> are STUArrays slower in GHC 6.10?
19:13:01 <defun> ehird: So BSD can't linkt to GPL software? I thought it was compatible?
19:13:07 <ehird> It cannot.
19:13:12 <ehird> It is compatible.
19:13:17 <ehird> You can use BSD code in a GPL project.
19:13:35 <defun> Wow. That sucks, IMHO.
19:13:48 <dankna> well, yes, but it sucks in precisely the way that the GPL was designed to enforce
19:13:48 <ehird> Yes. The GPL sucks.
19:14:16 <defun> Thanks, anyway.
19:15:10 <SamB> really, the issue is when the *only* free, portable implementation of an interface is GPL'd
19:15:31 <mmorrow_> circo: graph is too large for bitmap. Scaling by 0.619086 to fit
19:15:32 <mmorrow_> Segmentation fault
19:15:35 <mmorrow_> awesome!
19:16:03 <gwern> math is hard?
19:16:11 <gwern> let's go segfaulting!
19:16:19 <mmorrow_> hehe
19:16:35 <olsner> mmorrow_: is that something you wrote? in haskell?
19:16:50 <Adamant> a lot of Haskell's success can be attributed to ghc having a simple permissive license.
19:16:55 <mmorrow_> olsner: that's graphviz handling a .dot on stdin
19:17:12 <gwern> Adamant: how do you figure?
19:17:18 <olsner> ah, graphviz
19:17:30 <Adamant> gwern: you can get more people to work on it because they can use it for whatever they want
19:17:39 <mmorrow_> olsner: i love to hate it
19:17:49 <Adamant> as opposed to the situation with Ocaml for instance
19:17:54 <gwern> right, because so many people work on ghc? I didn't realize gcc being gpl had impeded C adoption
19:18:20 <Adamant> gwern: actually, quite a lot more people do work on ghc as opposed to Ocaml's compiler.
19:18:21 <gwern> if the libraries are GPL, that might be an issue; but if it's FLOSS who cares what the heck the compiler is under
19:18:40 <Adamant> gwern: even gcc needs a linking exception
19:19:08 <Adamant> pure GPL is a non-starter for a compiler like that
19:21:40 <mjs22> adamant: ocaml uses the LGPL for libraries by the way, not pure GPL.
19:22:08 <Adamant> mjs22: the compiler itself was under a weird Q License/GPL hybrid
19:22:10 <Adamant> IIRC
19:22:25 <Adamant> AFAIK it still is
19:22:30 <mjs22> yep - QPL.  I never understood why they chose that.
19:25:45 <mcnster> greetings.  how do i convert a map of type Map a [b] (where b's are leaves) into a Tree a?
19:26:25 <mcnster> sorry, that should be Map a [a].  i'm tired. :)
19:27:41 <mcnster> Cale, r u alive?
19:32:23 <Cale> hi
19:32:45 <mcnster> hey Cale :) i have a Map to Tree problem...
19:32:52 <Cale> uh, okay :)
19:33:04 <Cale> So the Map represents a graph?
19:33:21 <brian6> what can i do in the type system to represent numeric values that have to fit in a certain number of bits? right now i use smart constructors.
19:33:47 <mcnster> yup.  Map a [a] where the key would be a node on the tree
19:33:59 <Cale> brian6: Well, there are a number of specifically-sized numeric types in Data.Word and Data.Int
19:34:16 <brian6> Cale: yeah, but like 7.
19:35:10 <Cale> brian6: For that, you'd need to represent numbers at the type level. It's not impossible, but not something I'd usually go to the trouble of doing.
19:35:53 <Cale> mcnster: and the list of results is the list of children?
19:36:08 <mcnster> Cale, yup
19:37:14 <daystrom> hi, just starting with Haskell, going thru a tutorial that imports Text.Regex but ghc 6.8.2 fails to load it :(, seen something about Text.Regex.Posix replacing it but that didn't work either, any suggestions?
19:37:50 <gwern> daystrom: iirc the regex packages are separate from a ghc install
19:37:59 <gwern> and you shouldn't be using such an old ghc anyway
19:38:48 <daystrom> thx gwern, thought i'd try the default ubuntu one but i'll upgrade
19:40:18 <Cale> mcnster: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6530#a6530
19:41:58 <Cale> mcnster: Note that if there are cycles in the graph represented by the map, you will get an infinite tree.
19:42:48 <mcnster> Cale, i will ponder this.  thanks much :)
19:43:01 <Cale> mapToTree (M.fromList [(0,[1]),(1,[0])]) 0
19:43:10 <Cale> Node 0 [Node 1 [Node 0 [Node 1 [Node 0 [Node 1 [Node 0 ...
19:43:28 <mcnster> check
19:46:20 <Cale> http://basicinstructions.net/sightings/s1.jpg
20:18:42 <mmorrow_> mcnster: (you just need to keep a seen (Set a))
20:21:46 <mmorrow_> mcnster: and then you have the choice of building a depth-first or breadth-first tree
20:25:47 <parag> I will appreciate some confusion destroyers! :-)   ap = liftM2 id
20:26:30 <parag> but first arg for liftM2 is (a1 -> a2 -> r) and type of id is (a1 -> a1) so is that not a problem?
20:26:34 <mmorrow_> copying garbage collection is just a breadth-first traversal of a graph, given a (wlog w.r.t. "a single") root. breadth-first, since then you need no stack, because you use the "to space" (which could be a block of raw memory, or an IntMap in the state of your State monad) as your queue
20:26:59 <Axman6> :t ap
20:27:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:27:01 <parag> why doesn't liftM2 complain that function passed to it does not take 2 parameters?
20:27:14 <Axman6> :t liftM2 id
20:27:15 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
20:27:46 <mmorrow_> (this is the (or variations on) the cheney algorithm)
20:28:24 <pikhq> Whoa.
20:28:32 <pikhq> :t liftM2
20:28:33 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:29:00 <mmorrow_> @type [id,(\k -> (\a b c d e -> k a b c d e))]
20:29:01 <lambdabot> forall t t1 t2 t3 t4 t5. [(t1 -> t2 -> t3 -> t4 -> t5 -> t) -> t1 -> t2 -> t3 -> t4 -> t5 -> t]
20:29:02 <Axman6> :t liftM2 ?id
20:29:03 <lambdabot> forall a1 a2 r (m :: * -> *). (?id::a1 -> a2 -> r, Monad m) => m a1 -> m a2 -> m r
20:29:46 <parag> I found that in general it is possible to pass a function with arity m to another function expecting param of function with arity n. where m != n
20:29:59 <Cale> parag: well, in order for (a1 -> (a2 -> r)) to match (t -> t), we must have a1 = t, and a2 -> r = t
20:30:09 <Cale> parag: So a1 = (a2 -> r)
20:30:45 <Cale> :t liftM2
20:30:46 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:30:55 <Cale> So this specialises to:
20:31:17 <Cale> ((a2 -> r) -> (a2 -> r)) -> m (a2 -> r) -> m a2 -> m r
20:31:29 <Cale> and then applying it to id gives:
20:31:39 <Cale> m (a2 -> r) -> m a2 -> m r
20:31:50 <parag> :t (liftM2 id)
20:31:51 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
20:32:57 <parag> Cale: thanks!
20:33:05 <Cale> When a function is polymorphic in its result type, then you can't really say how many parameters it will take
20:33:13 <Cale> Because it might produce a function :)
20:33:34 <Cale> > id (*) 4 5
20:33:36 <lambdabot>   20
20:33:42 <Cale> There's id taking three parameters :)
20:33:46 <parag> wow!
20:34:04 <Axman6> Cale: have you see this? (sec)
20:34:08 <parag> so id can take any number of parameters
20:34:19 <Cale> yeah, pretty much
20:34:23 <Axman6> > id id id id id id id id id id id id id id id id id id id id "id"
20:34:27 <lambdabot>   "id"
20:34:33 <Axman6> > id id id id id id id id id id id id id id id id id id id id id  "id"
20:34:35 <FunctorSalad_> only up to 21 ;)
20:34:38 <lambdabot>   mueval-core: Prelude.read: no parse
20:34:38 <lambdabot>  mueval: ExitFailure 1
20:34:41 <rprije> Hi all. I'm having a profiling problem. I've got a Map.Map (Maybe BString) Int which is maintaining a count of how many times it finds various strings in a file. With big enough files the program runs out of memory. Profiling tells me Int is the data type which is growing the most and this memory usage is lag. My Map.adjust argument is simply (+1). Is this perhaps not being strict enough?
20:34:42 <Cale> oh?
20:34:42 <parag> cool Axman6
20:34:52 <FunctorSalad_> oh, even less apparently
20:34:58 <Cale> That is strange.
20:35:04 <Cale> Oh, I see what's going on
20:35:07 <Cale> It's timing out
20:35:20 <Cale> The types are getting so large that it takes a long time to compute them
20:35:21 <FunctorSalad_> > length "id id id id id id id id id id id id id id id id id id id id id "`div`3
20:35:22 <lambdabot>   21
20:35:33 <FunctorSalad_> cancel that, it's 21 in fact
20:35:57 <FunctorSalad_> Cale: that was my speculation too last night
20:36:17 <FunctorSalad_> (actually, that the "security checker" chokes, since presumably this works in ghci)
20:36:25 <Axman6> : let f :: String -> String; f x = x in f f f f f f f f f f f f f f f f f f f f f f "f"
20:36:29 <Axman6> > let f :: String -> String; f x = x in f f f f f f f f f f f f f f f f f f f f f f "f"
20:36:30 <lambdabot>   Couldn't match expected type `GHC.Base.String'
20:36:35 <mmorrow_> @unpl \k -> fix (\a -> unC (f a) k)
20:36:35 <lambdabot> \ k -> fix (\ a -> unC (f a) k)
20:36:43 <Axman6> uh right
20:36:58 <Cale> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
20:37:00 <lambdabot> forall t. t -> ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((
20:37:00 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((
20:37:00 <lambdabot> t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((
20:37:00 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), (
20:37:00 <FunctorSalad_> no wait, ghci hangs too!
20:37:02 <lambdabot> (t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t))
20:37:05 <lambdabot> , ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), (
20:37:05 <FunctorSalad_> weird
20:37:07 <lunabot>  luna: parse error on input `,'
20:37:08 <lambdabot> (t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
20:37:14 <mmorrow_> err, i'm an idiot
20:37:18 <mmorrow_> @pl \k -> fix (\a -> unC (f a) k)
20:37:18 <lambdabot> fix . flip (unC . f)
20:37:23 <mmorrow_> s/un//
20:37:49 <mmorrow_> (i was about to say... i don't think i've ever seen a lambda @pl couldn't crush)
20:38:18 <mmorrow_> Cale: that would be a good vacuum graph i bet
20:38:22 * mmorrow_ tries it
20:38:41 <mmorrow_> well, it'd be like 4 nodes with 400 edges ;)
20:39:59 <mmorrow_> haha
20:40:15 <mmorrow_> , let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3 in vacuum (f ())
20:40:16 <lunabot>  luna: parse error on input `in'
20:40:43 <mmorrow_> , let a = let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3 () in vacuum a
20:40:47 <lunabot>  [(0,[1,1]),(1,[2,2]),(2,[3,3]),(3,[4,4]),(4,[5,5]),(5,[6,6]),(6,[7,7]),(7...
20:40:54 <mmorrow_> , length (let a = let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3 () in vacuum a)
20:40:57 <lunabot>  9
20:41:07 <kpreid> :t vacuum
20:41:08 <lambdabot> Not in scope: `vacuum'
20:41:23 <mmorrow_> it's an adjacency list of ptrs between heap nodes
20:41:49 <peter_12> Is the value constructor True a thunk?
20:41:53 <mmorrow_> , vacuum (fix (0:))
20:41:55 <lunabot>  [(0,[1,0]),(1,[])]
20:42:19 <mmorrow_> , vacuum True
20:42:22 <lunabot>  [(0,[])]
20:42:26 <Cale> peter_12: It's not usually considered such. Thunks are the in-memory representation of as-yet-unevaluated expressions.
20:42:28 <mmorrow_> (no ptrs)
20:42:59 <peter_12> Cale: But True is a function of zero arguments, yes?
20:43:08 <Cale> True isn't a function, it's a Bool
20:43:11 <mmorrow_> yeah, a thunk is more like a suspended evalutation, which could represent the potential value of anything
20:43:30 <peter_12> Cale: value constructors are not considered functions?
20:43:34 <mmorrow_> peter_12: it's a constructor with zero fields
20:43:47 <Cale> peter_12: I only use 'function' to mean values whose top-level type constructor is ->
20:44:30 <Cale> I suppose you can consider it a nullary function, but what values are *not* functions then?
20:44:39 <mmorrow_> peter_12: well, you can think of constructors with more than 0 fields as functions, but all the fact that they're functions is really just syntactic sugar
20:44:40 <Cale> It seems worthwhile for there to be a distinction :)
20:44:58 <FunctorSalad> meh. trying to run a chain of about 50 "id"s in ghci made my LUNIX go into quasi-infinite swapping
20:44:59 <FunctorSalad> had to restart
20:45:04 <Cale> Data constructors are perfectly good functions when they're functions.
20:45:12 <FunctorSalad> OT: how can I prevent this from happening? :(
20:45:17 <Gracenotes> when you have the expression 3+2, it might remain a thunk with the function (+) and two arguments. But if you have (1:[]), and (:) is a constructor, I don't think GHC bothers to make a thunk of it. it is a constructor with two values, but (1:) is a thunk
20:45:19 <mmorrow_> partial applications of cons get desugared to fully saturated applications of them, possibly via making a new top-level function
20:45:32 <mmorrow_> (the compiler being what's doing this)
20:45:41 <Cale> For example,  (:) :: a -> ([a] -> [a]) is a function, because the top level type constructor in its type is ->
20:46:05 <Cale> (applied to 'a' and to '[a] -> [a]')
20:46:22 <Cale> but [] :: [a] isn't because there's no -> in the type at all
20:46:59 <peter_12> Cale: but value constructors with more than 1 argument do have -> in them when using :type
20:47:11 <Cale> peter_12: right
20:47:20 <Cale> peter_12: So some data constructors are functions :)
20:47:31 <Cale> (all those which take parameters)
20:48:09 <peter_12> Cale: That is an uncomfortable way of thinking about it to me. They should either all be functions or none functions.
20:48:26 <Cale> Why?
20:48:46 <Cale> If we start calling all values functions, why don't we just use the word value?
20:48:55 <peter_12> Because they are all value constructors and all value constructors should be the same kind of thing.
20:49:06 <Cale> We can't classify them any further?
20:49:12 <Cale> They are all values...
20:49:13 <peter_12> constructOR implies function to my brain
20:49:35 <mmorrow_> foo = (: [3])
20:49:42 <mmorrow_> gets translated to
20:49:46 <peter_12> why would we be "calling all values functions"?
20:49:52 <mmorrow_> foo_0 x = x : [3]
20:49:54 <peter_12> is an integer a function in Haskell?
20:50:00 <Cale> peter_12: Well, if you want to call things which have no parameters functions...
20:50:01 <mmorrow_> (if that makes it any easier to think about)
20:50:12 <mmorrow_> err, better example
20:50:25 <Cale> peter_12: Integer values behave just like they are all data constructors of the same type
20:50:51 <mmorrow_> foo = let blah blah in f (case blah (: [3]) of boo -> zoo) ===>
20:50:54 <peter_12> Cale: aren't functions with no parameters just "constant functions"?
20:51:03 <mmorrow_> foo_0 x = x : [3]
20:51:14 <Gracenotes> well... I# :: Int# -> Int
20:51:19 <mmorrow_> foo =  let blah blah in f (case blah foo_0 of boo -> zoo)
20:51:20 <Gracenotes> but that's in GHC
20:51:30 <Cale> peter_12: Constant functions are functions which give the same result no matter which parameter you apply them to.
20:51:57 <Cale> > map (const 5) [1..10]
20:51:58 <lambdabot>   [5,5,5,5,5,5,5,5,5,5]
20:52:00 <peter_12> Cale: right.
20:52:09 <Cale> > map 5 [1..10]
20:52:11 <lambdabot>   Add a type signature
20:52:19 <Cale> > map 5 [1..10] :: [Integer]
20:52:21 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Integer.Internals.Integer))
20:52:21 <lambdabot>    arisi...
20:52:32 <Cale> > map (5 :: Integer) [1..10] :: [Integer]
20:52:33 <lambdabot>   Couldn't match expected type `a -> GHC.Integer.Internals.Integer'
20:52:36 <peter_12> in "Real World Haskell" they keep talking about value constructors that take zero arguments. It sure makes True seem like a function.
20:52:55 <Cale> peter_12: Yeah, but it has no parameters. It's just a value.
20:53:00 <mmorrow_> peter_12: it's really context-dependent what you consider to be a "function"
20:53:22 <mmorrow_> for instance, you can map integers to functions by (n ===> (+n))
20:53:43 <mmorrow_> so you're really talking about the image of some mapping
20:53:48 <Cale> Yeah, there are ways to represent values of any algebraic datatype using functions
20:54:02 <Cale> For example, consider data Bool = False | True
20:54:32 <Cale> We can represent values of this type using functions (\false true -> false) and (\false true -> true)
20:54:56 <Cale> Or lists  data List a = Nil | Cons a (List a)
20:55:15 <peter_12> So what True is is a bit of a grey area?
20:55:20 <Cale> with functions... instead of Cons 1 (Cons 2 (Cons 3 Nil))
20:55:22 <Cale> we can use
20:55:36 <Cale> (\nil cons -> cons 1 (cons 2 (cons 3 nil)))
20:56:19 <Cale> so there, it becomes a function *parameter* if not a function itself
20:56:30 <peter_12> hmm
20:56:32 <Cale> But normally, we reserve the word "function" to mean something which takes (at least) one parameter
20:57:15 <Cale> In fact, with this definition, it's possible to say that all functions in Haskell take *exactly* one parameter, and those which seem to take more are just producing other functions.
20:57:34 <Cale> > (+) 1 2
20:57:35 <lambdabot>   3
20:57:42 <Cale> > let f = (+) 1 in f 2
20:57:43 <lambdabot>   3
20:57:57 <Cale> Right down to the arithmetic operations.
20:58:19 <Cale> > let f = (+) 1 in map f [10,20,30]
20:58:20 <lambdabot>   [11,21,31]
20:58:38 <Cale> > let f = (+) 1; g = map f in g [10,20,30]
20:58:39 <lambdabot>   [11,21,31]
20:58:41 <peter_12> So inside GHC, what is True?
20:59:13 <Cale> Internally at runtime, it's more or less an integer tag
20:59:29 <peter_12> like a symbol?
20:59:51 <Cale> yeah
21:00:12 <Cale> Types are erased by compilation.
21:00:32 <Cale> So you're left with constructors that have integer tags followed by an array of pointers, more or less.
21:00:43 <peter_12> I think "value constructor" is the culprit. They aren't all constructors. Some of them are just values
21:01:07 <Cale> Well... it does construct a value. That value is itself ;)
21:01:12 <bos> tum te tum. so I've written a dropAfter for Data.Text, for symmetry with dropWhile.
21:01:33 <bos> now I'm wondering if a dropAround would also make sense, as the composition of the two with the same predicate.
21:01:36 <peter_12> Cale: It doesn't construct at runtime
21:02:15 <Cale> peter_12: The reason we say that it's a data constructor as opposed to just any kind of value is actually because constructors are the things which you can pattern match against
21:02:23 <idnar> peter_12: it constructs just as much as any other constructor
21:02:42 <Cale> That's really the important thing about constructors -- that you can see how something has been built from them.
21:02:52 <Cale> If I define
21:02:55 <Cale> foo = True
21:02:58 <Cale> bar = True
21:03:07 <Cale> Then I can't tell foo and bar apart anymore
21:03:13 <Cale> and writing a function like:
21:03:16 <Cale> f foo = ...
21:03:18 <Cale> f bar = ...
21:03:36 <Cale> well, actually, the 'foo' there will shadow the other definition, and match anything
21:03:52 <peter_12> ok I'll keep marching on
21:03:55 <peter_12> thanks for the help
21:03:57 <Cale> But:
21:04:04 <Cale> f True = ...
21:04:06 <Cale> f False = ...
21:04:23 <nzeh> Hi folks, I'm wondering whether anybody can give me some pointers with building QuickCheck 2.1.0.1.  Currently it fails when compiling Test/QuickCheck/Exception.hs
21:04:33 <Cale> is a valid thing to do, and f will check and see which of the constructors its parameter evaluates to
21:04:47 <peter_12> right
21:05:18 <peter_12> Cale for a constructor that takes arguments you'd write
21:05:24 <Cale> So maybe the choice of word is confusing, but that's what makes constructors constructors :)
21:05:42 <Cale> nzeh: could you hpaste the error?
21:05:46 <Cale> @where hpaste
21:05:46 <lambdabot> http://hpaste.org/
21:05:51 <peter_12> ah never mind
21:05:54 <peter_12> I'll battle on
21:05:56 <peter_12> thanks again
21:06:13 <Cale> For constructors with parameters, you can either use variables to match those parameters
21:06:26 <Cale> Or you can fill them with other constructors, if you want to be more specific
21:07:00 <Cale> foo :: Either Bool Bool -> Bool
21:07:07 <Cale> foo (Left x) = x
21:07:12 <Cale> foo (Right True) = False
21:07:18 <Cale> foo (Right False) = True
21:07:40 * bos tries to think of a better name than dropAround
21:07:45 <bos> any suggestions?
21:07:53 <peter_12> Cale: in your earlier example could you write
21:08:00 <peter_12> f (True) ...
21:08:03 <Cale> bos: comeByForDrinks ?
21:08:06 <peter_12> f (False) ...
21:08:11 <nzeh> Cale: Did that.  How do I know the URL to send you?
21:08:14 <peter_12> so it is similar looking to
21:08:18 <peter_12> foo (Left x) = x
21:08:23 <Cale> nzeh: It will be in your address bar ;)
21:08:29 <bos> Cale: exactly
21:08:47 <Cale> nzeh: found it
21:08:48 <nzeh> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6534#a6535
21:09:10 <Cale> nzeh: hmm... which GHC version?
21:09:13 <nzeh> I seem to remember that the URL's were cleaner, but maybe I'm just dreaming.
21:09:15 <nzeh> Cale: 6.10.3
21:09:25 <Cale> okay, I'll give it a shot
21:09:32 <nzeh> Thanks
21:09:41 <Cale> peter_12: yeah
21:10:17 <Cale> peter_12: it actually looks at the constructor and tries to match it against each pattern until one succeeds in matching
21:10:58 <Cale> nzeh: hmm... it builds for me...
21:11:12 <Cale> and I have 6.10.3
21:11:27 <peter_12> (I'm not a fan of optional parens so that may be part of my problem also)
21:11:33 <nzeh> That's odd.  I don't think I did anything funny to my installation
21:11:41 <Cale> nzeh: you presumably did   cabal install QuickCheck-2.1.0.1
21:12:12 <nzeh> I downloaded the tar-ball, went inside the unpacked directory and did runhaskell Setup configure, then build.
21:12:13 <Cale> peter_12: Yeah, the parens are only there for grouping
21:12:19 <Cale> nzeh: ah
21:12:30 <nzeh> Let me see whether cabal install works for me.
21:22:30 <nzeh> Cale:  A small odyssey because I didn't even have cabal-install setup.  After doing that, though, cabal install installed QuickCheck flawlessly.  Thanks for your help.
21:23:01 <nzeh> It would be nice to know, though, why the manual path fails.
21:23:59 <Cale> Possibly somehow it managed to use the wrong exception library? Even that seems unlikely. Did it have to download and install anything else?
21:24:38 <nzeh> Nope
21:25:44 <nzeh> In any case, I'll just be happy that it worked and go on and use it ;)
21:30:28 * bos now wonders if it makes sense to have a strip function as a shortcut for "dropAround isSpace"
21:33:39 <FunctorSalad> it's also called "trim"
21:59:56 <mmorrow_> this C program is amusing, if for nothing else than to see what happens
22:00:02 <mmorrow_> main(){while(1){printf("%p\n",mmap(0,64*4096*4096,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANONYMOUS,1,0));}}
22:00:21 <mmorrow_> (#include <sys/mman>\n#include <stdio.h>)
22:00:44 <Cale> "The Strathclyde Haskell Enhancement is a somewhat inglorious bodge, equipping ghc with automatic lifting of types to kinds, pattern synonyms, and some kit for higgledy-piggledy literate programming."
22:01:17 <mmorrow_> (you may want to reduce the size of allocation on each step if you're on x86 instead of x86_64)
22:01:54 <mmorrow_> (err, maybe, i'm not sure actually if that really matters)
22:02:03 <mmorrow_> (off the top of my head)
22:02:27 <mmorrow_> heh, "higgledy-piggledy"
22:02:44 * mmorrow_ tries to imagine what that means
22:03:11 <mmorrow_> oops
22:03:18 <mmorrow_> main(){while(1){printf("%p\n",mmap(0,64*4096*4096,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANONYMOUS,-1,0));}}
22:03:23 <mmorrow_> s/1/-1/
22:03:40 <mmorrow_> (1 works just fine though)
22:04:19 <hackagebot> hack-handler-simpleserver 0.0.1 - A simplistic HTTP server handler for Hack. (MichaelSnoyman)
22:05:53 <FunctorSalad> Cale: can't find any documentation
22:06:00 <FunctorSalad> (link on hackage is dead)
22:06:06 <Cale> FunctorSalad: neither can I
22:22:27 <Rotaerk> hmm... what's wrong with this: http://codepad.org/V6V3KMar
22:23:12 <Rotaerk> I think it's an indentation issue
22:23:19 <Rotaerk> or what I'm trying to do just isn't legal
22:25:49 <Cale> Rotaerk: 'let' is part of an expression
22:26:22 <Cale> Rotaerk: blah = a is a declaration, which is not a type of expression
22:26:28 <Rotaerk> ah
22:26:32 <Rotaerk> k
22:26:34 <Cale> Rotaerk: you are however free to write:
22:26:42 <Cale> aoeu = blah
22:26:47 <Cale>   where a = 5
22:26:51 <Cale>         blah = a
22:27:00 <Rotaerk> ahh cool
22:27:18 <Rotaerk> was just trying to clean up my function with a lot of nested where's
22:28:03 <Rotaerk> http://codepad.org/KgXMfSvS -- for an exercise in this real world haskell book
22:31:55 <Rotaerk> hmm basically just removed the nested where's and made it one where-scope
22:37:38 <Rotaerk> ah.. I could've used "zip" to simplify that implementation
22:39:19 <Micheletti> Happy Independence Day!  I hope it was as Negro-free as mine!
22:39:52 <Rotaerk> ...
22:45:38 <Micheletti> Tired of Niggers and their monkeyshines?  Then join usa chimpout.com!  We are not white supremacists!  That is right!  AtChimpout.com we value diversity of all human races.  Asians, Whites,Semites, non-Negroid Hispanics, Indians, etc are all welcome.  No NiggersAllowed.  Join the Humanistic Alliance against the Feral Negro Beast at chimpout.com.  http://www.chimpout.com/forum
22:54:09 <mmorrow_> @where ops
22:54:09 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
22:54:09 <lambdabot> mauke
22:54:19 --- mode: ChanServ set +o dibblego
22:54:23 --- kick: Micheletti was kicked by dibblego (dibblego)
22:54:27 --- mode: dibblego set -o dibblego
22:56:01 <pragma_> @where meaning of life
22:56:01 <lambdabot> I know nothing about meaning.
23:07:26 <jeffwheeler> @seen sigfpe
23:07:26 <lambdabot> I haven't seen sigfpe.
23:08:01 * inimino loses a little faith in mankind
23:08:42 * jeffwheeler hopes I'm not related
23:09:09 * Elly gains a little faith in mankind in exchange
23:09:17 <Elly> conservation of faith!
23:09:35 <jeffwheeler> :D
23:10:45 <inimino> jeffwheeler: no, not you, just the link that was spammed earlier
23:10:59 <jeffwheeler> inimino: phew
23:11:20 <jeffwheeler> Oh, wow; that is pretty terrible.
23:12:32 <Elly> ugh, it is
23:25:36 <jeffwheeler> Stuff like this is really neat: http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html
23:25:53 <jeffwheeler> Although I don't really understand his explanation of "join" using the image.
23:31:59 <Cale> jeffwheeler: Well... I think that basically everything in the second P has an implicit extra penalty of 1
23:32:17 <Cale> Because it's in the second list in the outer P
23:32:37 <Cale> jeffwheeler: So you shove all the elements down by that amount, and then zip.
23:32:51 <jeffwheeler> I thought everything in the second list had an implicit penalty of its position in the other list?
23:32:54 <Cale> It would be clearer if the example was a bit larger actually
23:34:05 * jeffwheeler keeps playing with it
23:34:19 <Cale> If we have P [[P xss], [P yss]], then the stuff in yss has an extra penalty of 1
23:34:38 <jeffwheeler> Yeah, by being one list down from the previous one.
23:35:02 <jeffwheeler> That is, it has the penalty of the "index delta," lol
23:36:24 <Cale> I really think he should have included at least one more level of penalty in the outer P, then the diagram would be clear :)
23:37:00 <jeffwheeler> I think I'll play with the PLists a bit first, to get more comfortable with the context first.
23:38:02 <jeffwheeler> Cale: (by the way, thanks for the help!)
23:38:24 <Cale> no problem :)
