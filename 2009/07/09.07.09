00:00:06 <paolino> uhm, it's third time I get bitten by that
00:00:48 <paolino> thanks
00:06:08 <paolino> Cale, still I don't understand why I have to specify 3.0.0
00:06:17 <Cale> paolino: I don't either.
00:06:23 <paolino> it's a .cabal specification ?
00:06:39 <Cale> paolino: Maybe it was easier to install 2.1.0.1 and you didn't say which you needed so it installed that.
00:06:49 <paolino> eheh
00:06:55 <Cale> (as in it needed fewer deps)
00:07:24 <paolino> where is transparency ?
00:07:36 <Cale> transparency?
00:07:54 <paolino> it should at least warn me of that choice
00:08:17 <jeffwheeler> @type uncurry
00:08:18 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
00:08:24 * jeffwheeler always gets those two mixed up
00:09:01 * paolino always writes uncurry
00:09:16 <Cale> uncurry is the catamorphism on pairs
00:09:47 <Cale> and well, curry curries ;)
00:09:51 <paolino> @type curry
00:09:52 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
00:10:01 <jeffwheeler> Catamorphism. Right.
00:10:14 <jeffwheeler> I usually use the one that makes the typechecker happy.
00:10:31 <Cale> That is, uncurry is to (,) what foldr is to [], maybe is to Maybe, and either is to Either
00:10:57 <Cale> It takes the constructor(s) and replaces them with other functions.
00:11:28 <paolino> ah, that is a catamorphism ?
00:11:46 <jeffwheeler> Oh, apparently I guessed wrong.
00:11:52 <jeffwheeler> (Typechecker wants me to change it. :) )
00:12:15 <jeffwheeler> Uncurry was the one I needed. I should've known.
00:12:31 <jeffwheeler> I can't stop myself from thinking of the Indian food every time, though. That may be the problem.
00:12:58 <idnar> jeffwheeler: it should just infer the correct one :P
00:13:24 <paolino> uncurry is feeding a pair to something which is not done for it
00:13:26 * jeffwheeler wonders whether Cale could write a magic typecalss to do that
00:13:35 <jeffwheeler> * typeclass
00:13:52 <Cale> paolino: yeah, that's what catamorphisms do :)
00:14:08 <Cale> jeffwheeler: hmm
00:14:09 <kulakowski> Catamorphisms collapse things, their duals anamorphisms build things up (if you took biology in high school or whatever, you might have heard the words catabolism--tearing down molecules to simpler ones and anabolism--building bigger molecules up from simpler ones, the prefixes cata- and ana- are the same)
00:14:30 <Cale> Though I think 'collapse' is a funny way to look at it myself.
00:14:33 <jeffwheeler> That 'browse' function in HTTP is super neat.
00:14:54 <Cale> I prefer to think of it as just replacing the constructor functions with other functions (which might themselves be constructors)
00:15:03 <kulakowski> yeah collapse might not be the best word.
00:15:04 <jeffwheeler> It's one of the most efficient ways to build up complicated requests including cookies and form data I've seen in any language.
00:15:55 <jeffwheeler> (Although I still contend that the sample is broken.)
00:34:11 <paolino> jeffwheeler: how is it the correct example ?
00:36:12 <jeffwheeler> paolino: what?
00:36:34 <jeffwheeler> paolino: the second example here seems to be broken: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
00:36:42 <paolino> the correction ....
00:36:53 <paolino>  Couldn't match expected type `Network.Stream.Result (Response [a])'
00:36:54 <paolino>            against inferred type `(Network.URI.URI, Response String)'
00:37:03 <jeffwheeler> Oh; I'll show you in just a minute, my battery on this other machine is about to die, and I need to find a file on it
00:41:27 <jeffwheeler> paolino: alright, I apologize for that
00:41:52 <jeffwheeler> Instead of binding it to rsp, I bound it to (_, rsp), then used (rspBody rsp) when trying to read from it.
00:42:16 <jeffwheeler> Or, actually, the latter part might not have been necessary with getResponseBody
00:43:14 <jeffwheeler> This is the fairly complicated example, that includes those suggestions: http://haskell.pastebin.com/d43e69c83
00:49:53 <jeffwheeler> (I was certain I had gotten through on FB . . . )
00:52:28 <ivanm> quicksilver: I'm re-writing the attributes section for the graphviz library; so atm you provide functions of types {Node,Edge,Graph,etc.} -> [Attribute] (i.e. an edgeAttrs function, a nodeAttrs function, etc.)
00:53:40 <paolino> jeffwheeler: the example is fully broken eh
00:53:45 <Coontacts> If you are sick and tired of dealing with black people AKA NIGGGGGERS then you will love Chimpout.com!  Chimpout.com is not a White Supremacist website.  We welcome all human races that despise the Feral Negro Beast.  All races are welcome except for NEGROIDS!  Learn amazing facts about the Negro brain and typical behavior.  Don't knock us until you try us!  http://www.chimpout.com/forum  The alliance of all human races against NIGGGGERS! http://www.ch
00:54:00 <jeffwheeler> @where ops
00:54:00 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
00:54:01 <lambdabot> mauke
00:54:07 <ivanm> @slap Coontacts
00:54:07 <lambdabot> go slap Coontacts yourself
00:54:09 <Coontacts> If you are sick and tired of dealing with black people AKA NIGGGGGERS then you will love Chimpout.com!  Chimpout.com is not a White Supremacist website.  We welcome all human races that despise the Feral Negro Beast.  All races are welcome except for NEGROIDS!  Learn amazing facts about the Negro brain and typical behavior.  Don't knock us until you try us!  http://www.chimpout.com/forum  The alliance of all human races against NIGGGGERS! http://www.ch
00:54:17 --- mode: ChanServ set +o dibblego
00:54:21 --- kick: Coontacts was kicked by dibblego (dibblego)
00:54:25 <jeffwheeler> Thank you.
00:54:31 <ivanm> all hail dibblego!
00:55:24 <paolino> jeffwheeler: Sending:
00:55:24 <paolino> prova: %: openFile: does not exist (No such file or directory)
00:55:31 --- mode: dibblego set -o dibblego
00:55:49 <jeffwheeler> (I wonder how dibblego is always the first to respond, but I never see him talk here.)
00:55:55 <ivanm> jeffwheeler: he does talk here
00:55:59 <ivanm> he just idles a lot
00:56:11 <jeffwheeler> ivanm: oh, well, I don't remember ever hearing him speak
00:56:13 <ivanm> and this is the first time I recall seeing him respond to a spammer...
00:56:14 <jeffwheeler> @seen dibblego
00:56:15 <lambdabot> dibblego is in #scala, #functionaljava, #xmonad, #haskell-in-depth, #haskell, #learnanycomputerlanguage and #bfpg. I last heard dibblego speak 4m 41s ago.
00:56:23 <jeffwheeler> I lie.
00:56:46 <Twey> He's active, just not here :)
00:56:46 <jeffwheeler> He responded to the same person last time . . .
00:56:57 * dibblego streaks across the room
00:56:59 <ivanm> hmmm...
00:57:07 * ivanm rings the police to report a streaker
00:57:13 <jeffwheeler> I should've seen that coming, with all our not-so-private discussion of him.
00:57:17 <Pinochet> howdy
00:58:06 <paolino> jeffwheeler: how about the "%" file there ?
00:59:03 * ivanm waves absently in Pinochet's direction
00:59:07 <jeffwheeler> paolino: I think you totally confused me
00:59:34 <paolino> uhm, that's the error I get now with the example there , sorry
00:59:52 <paolino> %: openFile: does not exist (No such file or directory)
00:59:57 <Pinochet> If you are sick and tired of dealing with black people AKA NIGGGGGGERS then you will love Chimpout.com! Chimpout.com is not a White Supremacist website. We welcome all human races that despise the Feral Negro Beast.  All races are welcome except for NEGROIDS!  Learn amazing facts about the Negro brain and typical behavior.  Don't knock us until you try us!  http://www.chimpout.com/forum  The alliance of all human races against NIGGGGERS!
01:00:06 <paolino> eccolo
01:00:08 <jeffwheeler> @where ops
01:00:09 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
01:00:09 <lambdabot> mauke
01:00:41 <jeffwheeler> Can't we block his IP?
01:01:05 <paolino> not if he comes with TOR
01:01:11 <jeffwheeler> Does he?
01:01:17 <paolino> dunno
01:01:27 <ivanm> /whois tells me nothing :s
01:01:40 <ivanm> he didn't before I think...
01:01:47 <ivanm> * Pinochet (i=Pinochet@ip72-207-20-210.sd.sd.cox.net) has joined #haskell
01:02:04 <elbar> try /whowas ;)
01:02:04 <ivanm> then again, the previous one just had an IP...
01:02:33 <ivanm> [Pinochet] (i=Pinochet@ip72-207-20-210.sd.sd.cox.net): Jigaboo Jones
01:02:59 <ivanm> but his other nick didn't say anything like that
01:06:22 * paolino tries jeffwheeler code, before giving up Network.Browse
01:07:03 <jeffwheeler> paolino: mine works; open the /tmp file in your browser after running it (you may have to update to the latest HTTP), and it should ask you to login
01:07:14 <jeffwheeler> paolino: unfortunately, the whole point of it was to circumvent that :)
01:07:43 <jeffwheeler> It works rather beautifully, other than that, though.
01:10:26 <paolino> uh
01:10:48 <paolino> what, it's impossible to avoid writeFile ?
01:12:44 * paolino gives up
01:14:02 --- mode: ChanServ set +o Cale
01:14:13 <Cale> oh, K-lined ;)
01:14:16 --- mode: Cale set -o Cale
01:14:39 * paolino goes transplanting cauliflowers and  broccoli
01:15:29 * Elly reads about typed scheme
01:16:02 <asmips> I'd like to divide (length [1..10]) by 2, but unfortunately (/) returns Fractional and length returns Int. Anyone know how to get accomplish this?
01:17:12 <osfameron> asmips: `div` ?
01:18:04 <jeffwheeler> paolino: sure it is, but I don't know how to pipe the HTML into Google Chromium, so I wrote a file so that I could launch it more easily
01:18:19 <jeffwheeler> You've got it as a string right before you write to the file, and you can do whatever you want with it.
01:18:59 <asmips> osfameron: thanks. That works.
01:19:01 <jeffwheeler> To test the file, I just did "runhaskell FB.hs && chromium-browser /tmp/fbdeactivate.html"
01:19:26 <osfameron> asmips: that throws away the remainder (.5) of course
01:19:35 <osfameron> how would you do it with fromInteger
01:19:44 <osfameron> > (fromInteger ( length  [1..10])) / 2.0
01:19:46 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
01:19:48 <osfameron> meh
01:20:15 <jeffwheeler> > ( length  [1..10]) / 2.0
01:20:17 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
01:20:17 <lambdabot>    arising from the lit...
01:20:25 <asmips> osfameron: I see. Didn't realize there was a seperate function for integer division.
01:20:51 <jeffwheeler> > fromInteger (length  [1..10]) / 2.0
01:20:53 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
01:21:12 <doserj> > fromIntegral (length  [1..10]) / 2.0
01:21:13 <lambdabot>   5.0
01:21:22 <osfameron> ah!
01:21:34 <osfameron> pesky fromInt* functions ;-P
01:21:37 <jeffwheeler> Anyways, g'night all.
01:21:45 <osfameron> g'morning ;-)
01:21:56 <doserj> @quote fromIntegral
01:21:57 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
01:23:50 <Saizan_> fromIntegral is the only one you want
01:24:03 <Saizan_> and realToFrac
01:24:12 <Saizan_> ?type realToFrac
01:24:13 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
01:24:35 <araujo> Elly, link?
01:25:03 <Elly> araujo: it's in the locally installed PLT scheme docs, so a link wouldn't be much use to you :P
01:25:37 <araujo> Elly, aah, thanks for telling me, i got plt installed i think
01:29:21 <asmips> I'm a little bit confused as to what the 'forall ' keyword signifies in type signatures.
01:32:55 <asmips> does 'forall' mean for all types of a type variable?
01:37:03 <Saizan_> asmips: foo :: forall a. T a, means that for any type X you choose to instantiate 'a' foo can be used at type T X
01:37:43 <Jedai> asmips: When you see a type variable without forall, it's just that the forall is implicit
01:38:49 <Jedai> asmips: making it explicit is important for some advanced type extensions (like rank-n polymorphism, or existential types, or scoped type variables)
01:39:42 <asmips> Thanks that cleared it up.
01:47:06 <maartenm> , index digitToInt
01:47:08 <lunabot>  luna: Couldn't match expected type `(a, a)'
01:47:16 <maartenm> ,index digitToInt
01:47:17 <lunabot>  luna: Couldn't match expected type `(a, a)'
01:47:21 <maartenm> @index digitToInt
01:47:22 <lambdabot> Data.Char
02:07:45 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6727#a6727
02:08:10 <maartenm> in 'candidates'
02:08:11 <maartenm> 'cannot construc tthe infinite type a = a -> t
02:08:11 <maartenm> why?
02:08:34 <maartenm> oops
02:08:37 <maartenm> pattern matching I guess
02:09:07 <maartenm> no...
02:10:40 <Saizan_> the problem is (mod nWays)
02:10:59 <Saizan_> nWays is a function, but you're trying to use it as a number
02:11:01 <maartenm> mod . nWays
02:11:03 <maartenm> ok
02:11:10 <maartenm> well, not ok
02:11:12 <maartenm> the whole thing is wrong
02:11:15 <maartenm> ok, thanks
02:11:21 <kulakowski> no
02:11:23 <kulakowski> you just want
02:11:25 <kulakowski> (mod n)
02:11:29 <kulakowski> not (mod nWays)
02:11:37 <kulakowski> err
02:11:57 <maartenm> nWays . (mod n)
02:11:57 <Saizan_> (`mod` n)?
02:11:58 <maartenm> ok
02:27:00 <maartenm> damn that problem is much harder than it looks
02:30:58 <hackagebot> serial 0.2.6 - POSIX serial port wrapper (FrederickRoss)
02:36:45 <paolino> is the structure of an Iteratee that makes error potentially resumable ?
02:37:20 <paolino> the continuation stored in it
02:37:53 <paolino> and , is ParsecT able to resume its eof error ?
02:41:00 <Mark_> Trying to use the first example on the HTTP package hackage page and I get "Exception: 7: openFile: does not exist (No such file or directory)"
02:41:44 <paolino> I got prova3: +: openFile: does not exist (No such file or directory)
02:42:00 <paolino> or prova3: %: openFile: does not exist (No such file or directory)
02:42:12 <paolino> depending on its mood :-/
02:42:26 <Mark_> I am running Vista. You?
02:42:33 <paolino> linux
02:42:41 <Mark_> Good :)
02:42:44 <paolino> yes
02:43:20 <paolino> we have chances to take the 2 butterflies with one net :)
02:44:14 <paolino> this is the haskell channel rest time btw
02:45:14 <Mark_> 2 birds with one stone :)
02:45:18 <Mark_> rest time ?
02:45:25 <Raevel> which example was that?
02:45:28 <maartenm> how do I 'flatten' a list
02:45:30 <maartenm> ?
02:45:41 <Heffalump> @type concat
02:45:43 <lambdabot> forall a. [[a]] -> [a]
02:45:44 <earthy> what do you consider 'flatten' to mean?
02:45:45 <maartenm> ok, sorry
02:45:49 <maartenm> should've known that
02:45:52 * Heffalump pokes lambdabot 
02:45:56 <maartenm> earthy: reducing hierarchical complexity
02:45:58 <paolino> Mark_: yes, very quiet at least
02:46:08 <earthy> one step or arbitrarily?
02:46:14 <maartenm> > concat [[a,b],[c,d]]
02:46:16 <lambdabot>   [a,b,c,d]
02:46:22 <maartenm> one step
02:46:30 <maartenm> there's a built-in for arbitraily?
02:46:39 <earthy> not that I know of :)
02:46:40 <Cale> > concat [[[a,b],[c,d]],[[e,f],[g,h]]]
02:46:41 <maartenm> heh
02:46:42 <lambdabot>   [[a,b],[c,d],[e,f],[g,h]]
02:46:46 <paolino> @bot
02:46:46 <lunabot>  :)
02:46:46 <lambdabot> :)
02:46:53 <Cale> maartenm: It's difficult to assign a type to it
02:46:53 <paolino> @paste
02:46:58 <earthy> other than pushing it through data.tree ;)
02:46:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:47:02 <Cale> (if you want it to do n levels)
02:47:17 <Cale> right, if you want to think of things in that way, you probably really want a tree
02:47:41 <paolino> Raevel: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6728#a6728
02:47:45 <earthy> this is not lisp afterall :)
02:47:53 <Cale> Data.Tree kinda sucks though, so making your own tree will probably be nicer
02:48:29 <maartenm> really?
02:48:33 <maartenm> why does Data.Tree suck?
02:48:39 <maartenm> what kidn of tree is it?
02:48:43 <earthy> I've not found it to suck that badly
02:49:01 <earthy> a rose tree, afair
02:49:02 <Cale> I mostly hate that the Show instance is unreadable
02:49:24 <Cale> (because they used record syntax)
02:49:26 <earthy> that's why you get drawTree
02:49:31 <Mark_> Raevel: and this one http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6729#a6729
02:49:55 <Cale> Yeah, but I don't always want to draw a 2D representation of my tree to read it :)
02:50:30 <Cale> also, it doesn't even have a treeFold (though many unfolds)
02:50:53 <earthy> it has an instance of traversable and foldable...
02:50:55 <Cale> It has an instance of Foldable, but that's not the real fold
02:51:07 <earthy> oh, you want the tree-structured catamorphism
02:51:11 <Cale> right
02:51:14 <earthy> yeah, I've noticed that was lacking as well
02:51:37 <earthy> ya know, maybe we should just write the code and suggest it as patches :)
02:51:47 <Cale> treeFold n = f where f (Node x ts) = n x (map f ts)
02:52:06 <paolino> Cale: do you know if it's doable make an Iteratee with parsec?
02:52:34 <Cale> paolino: I know very little about Iteratee except that it is kind of insane. ;)
02:52:54 <earthy> the cool kind of insane ;)
02:53:21 <rgr> The following line has stopped working following a recent reinstall of latest darcs xmonad:
02:53:23 <rgr>        ,((modMask(myConfig) .|. shiftMask, xK_p), runOrRaise "urxvt -title procman -e htop" (title=?"procman")) -- processes
02:53:34 <hkBst> are there standard fold variants that operate on more than one list?
02:53:37 <rgr> I tried the code in a shell and it wors fine. Any ideas?
02:53:39 <paolino> Cale, it looks easy, or I didn't get it at all :)
02:53:44 <rgr> sorry, wrong group.
02:54:08 <Cale> hkBst: What does it mean for the fold to act on more than one list?
02:54:24 <Cale> hkBst: the composition of a fold with a zip?
02:54:45 <hkBst> Cale: ah, yes, thanks :)
02:55:09 <Cale> Normally I think of foldr f z as doing a structural replacement of each (:) in the list with f and the [] at the end with z
02:55:28 <McManiaC> @pl \a b -> not $ a `f` b
02:55:29 <lambdabot> (not .) . f
02:57:51 <paolino> Cale, the  real question can be if I can make parsec spit out a continuation if it didn't finish parsing when it hits an eof, that way I can feed it another piece of text to continue its job
02:59:10 <Cale> hmm... somehow I doubt it. I don't think parsec is designed to be resumable.
02:59:16 <Cale> paolino: However...
02:59:39 <paolino> ParserT IO ?
02:59:40 <Cale> paolino: It does operate over an arbitrary type of stream which it can uncons from.
03:00:12 <Cale> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html#t%3AStream
03:05:09 <paolino> Cale, can you explain a bit more your idea ?
03:05:11 <paolino> please
03:13:31 --- mode: irc.freenode.net set +o ChanServ
03:17:09 <paolino> @unmtl StateT u (ContT r IO) a
03:17:10 <lambdabot> u -> (a -> u -> IO r) -> IO r
03:18:59 <ejt> does anyone have any advice on writing interactive programs so they don't just degenerate into an imperative mess ?
03:21:06 <Philippa> structure the program as an interpreter for user commands
03:22:11 <ejt> Philippa: y, I was wondering about that, even going to far as to compile to a byte code instruction stream that would then go to a qt GUI
03:23:11 <Philippa> sticking to an AST and working with a gtk2hs one is a little saner :-)
03:23:32 <ejt> ok, will pinder on that for a bit
03:23:38 <ejt> s/pinder/ponder/
03:23:39 <Cale> ejt: Probably your interactive program does something more than just feed the user back their input, so you'll want to think about what the user is using the user-interface to interact with.
03:23:50 <paolino> ejt, write the commands semantic as  a recursive datatype on a continuation and then run an interpreter on them
03:24:36 <ejt> paolino: that sounds a bit like Olegs left fold iteratees ?
03:25:04 <Cale> It's somewhat okay to have a small imperative mess if it's really just doing input and output.
03:25:16 <paolino> ejt, I don't have enough olegs to confirm
03:25:38 <paolino> and I arrived to iteratees after I used that
03:26:34 <Cale> hmm
03:26:59 <Cale> ejt: What does your program do?
03:27:24 <paolino> ejt: http://github.com/paolino/reactivegas/blob/ac52fdae172deb5c42ebe6d0619dcc69ed4200d3/Costruzione.hs
03:27:36 <Cale> It is hard to usefully answer a question like this without more information :)
03:27:43 <ejt> Cale: y
03:27:52 <Cale> "apply functional programming techniques"
03:27:54 <Cale> heh
03:28:12 <ejt> I'm trying to write a level editor for a very simple game
03:28:16 <ejt> as a programming exercise
03:28:32 <ejt> I've written very few interactive programs in the last 20 years
03:28:40 <ejt> and am finding this surprisingly hard
03:28:43 <ejt> in any language
03:29:34 <ejt> Haskell is so much easier for expressing the data structures (eg. BSP tree algorithms)
03:29:47 --- mode: irc.freenode.net set +o ChanServ
03:29:51 <ejt> but C++ is much quicker on the GUI front
03:29:51 <Cale> Okay, so there's an obvious type of value which your UI is manipulating, at least. (The level)
03:29:53 <ejt> so I'm currently unhappy whatever I use
03:30:35 <maartenm> concat is lazy, right?
03:30:39 <Cale> Well, for slapping together a GUI, I think Glade and gtk2hs are probably the simplest thing we have right now in really practical terms.
03:30:42 <Cale> maartenm: yes
03:31:18 <Cale> maartenm: In that if you try to get the first element of concat xs, it will only evaluate as much of xs as needed to find a nonempty list.
03:31:20 <ejt> I've not tried Glade/gtk2hs, only HOpenGL on the haskell side
03:31:27 <paolino> I though the question was another , sorry
03:32:22 <paolino> I thought, you want a metalanguage to express interaction
03:32:33 <paolino> not how to render it
03:32:34 <Cale> For me, it's the reverse, I've not really tried the OpenGL libraries yet, but obviously there's a bit of a difference in terms of the type of program it'd be natural for.
03:32:39 <ejt> hmm, I didn't know about Glade, it looks good
03:33:01 <ejt> I found the HOpenGL program was getting very stateful
03:33:07 <Cale> It's reasonably good, and lets you design things in a way which doesn't break when the window resizes :)
03:33:12 <ejt> eg, which mode am I editing in
03:33:22 <ejt> if the right mouse button is held down then drag etc.
03:34:33 <Beelsebob1> ejt: GUI development unfortunately *is* a bunch of descisions like that
03:34:39 <Beelsebob1> and it's really rather difficult to get right
03:34:47 <maartenm> Cale: ok, makes sense of course.. I was just doubting why my euler problem doesn't complete timely.. but it's not haskell
03:34:56 <Beelsebob1> I think an accurate description of Haskell's state atm re GUIs is "no better than any other language"
03:35:09 <Beelsebob1> i.e. you have to do exactly the same things with Haskell as in any other language
03:35:18 <Beelsebob1> you might gain something from multithreading ease
03:35:56 <Beelsebob1> there's some hope though -- there's various projects looking at how to do reactivity better though
03:36:03 <Beelsebob1> but none are mature
03:36:10 <ejt> Beelsebob1: this had also occured to me, and I was wondering about giving up interactivity altogether and just using a little edsl to specify the levels
03:36:27 <ejt> in fact this is still my favourite option - play to your strengths
03:36:31 <Beelsebob1> ejt: that sounds like an excellent idea
03:36:40 <Cale> ejt: What kind of game is it?
03:37:11 <quicksilver> ejt: comparing (GUI development in C++) to (Haskell GUI developement in HOpenGL) is pretty unfair
03:37:26 <quicksilver> HOpenGL is a rather low-level library aimed at 3D graphics
03:37:29 <quicksilver> not a GUI toolkit ;)
03:37:40 <quicksilver> what toolkit were you using in C++?
03:37:51 <ejt> quicksilver: sure, I just had more background in opengl than gui toolkits
03:37:57 <ejt> qt in C++
03:38:00 * quicksilver nods
03:38:01 <ejt> which I'm impressed by
03:38:16 <quicksilver> well Qt is a fairly advanced gui toolkit with good tool support and pretty good documentaiton.
03:38:37 <maartenm> I think "convention over configuration" motto is easier to execute in imperative languages than in haskell
03:38:48 <ejt> the thing is having invested several years getting proficient in Haskell, running back to C++ seems unpleasant
03:38:51 <quicksilver> Beelsebob1: I think you gain something from better abstraction of common patterns and a better type system.
03:38:59 <maartenm> however, I am several magnitudes away from being a good haskell developer to be entirely sure of that
03:39:10 <quicksilver> Beelsebob1: but I agree that the basic problems of building a GUI are in no way removed by those.
03:39:30 <Beelsebob1> quicksilver: true, okay, perhaps the state is more accurately reflected as "you gain nothing in GUI programming in haskell that you don't already gain by using Haskell"
03:39:33 <ejt> Cale: there was a game called 'thrust' from the 80's, I'd like to write something similar
03:39:39 <quicksilver> Beelsebob1: yes.
03:39:42 <osfameron> ooo, thrust rocked
03:39:54 <quicksilver> thrust was the best.
03:39:54 <osfameron> I played that on the old Acorn Electron (precursor to the BBC Master)
03:40:03 <quicksilver> did you get to the reverse gravity invisible landscape levels?
03:40:05 <quicksilver> that was pretty hard.
03:40:06 <ejt> I played on my BBC B
03:40:25 <osfameron> invisible landscapes?  eeek!
03:40:32 <quicksilver> hmm. Maybe I only got as far as normal gravity invis landscape.
03:40:34 <ejt> ok, so I've now ascertained that we're all of an age
03:40:37 <osfameron> nope, never saw those (I guess I *wouldn't* have seen them, being invisible...)
03:40:48 <quicksilver> Yes. Complete the game once, and you start again at level 1 with gravity reversed.
03:40:52 <osfameron> I didn't have the electron myself (I was a spectrum child)
03:40:59 <quicksilver> Complete it again and the landscape vanishes.
03:41:04 <quicksilver> (but I think gravity went normal again, not sure)
03:41:20 <quicksilver> the landscape briefly appeared when you shielded
03:41:24 <quicksilver> but that didn't make it easy ;)
03:42:08 <ejt> ok, EDSL it is, thanks for the chat - and sorry for the vague questions
03:43:29 <ejt> right next question; is the Cairo library any good (for viewing static diagrams of my compiled levels)
03:44:33 <quicksilver> apparently, yes
03:44:36 <quicksilver> I haven't used it myself.
03:44:52 <osfameron> dammit, now I want a cave flyer game... but the ones I find links to are all for the jesusphone :-(
03:45:07 <Beelsebob1> get a jesus phone then
03:45:11 <Beelsebob1> :)
03:45:11 <osfameron> or for emulators... which I guess I might be able to run under wine
03:45:28 <osfameron> I've been quite resistant to buying a computer just to play games so far ;-)
03:45:48 <maartenm> you can emulate everything on linux too?
03:45:55 <osfameron> (which is why the most complex game I currently own is Frozen Bubble, on both my linux laptop and my nokia phone)
03:46:08 <maartenm> check zophar.net ..  I know no emulators that are windows - only
03:46:23 <kulakowski> Something I've been wondering... a tuple (a,b,c) and (a,(b,c)) are isomorphic as far as being product types, but can they be different because of strictness stuff?
03:46:37 <osfameron> oooo!  Exile!  that rocked too
03:46:44 <osfameron> I only played it a couple of times at a friend's
03:47:00 <osfameron> maartenm: ta
03:47:04 <quicksilver> kulakowski: yes, slightly
03:47:16 <quicksilver> kulakowski: one has more different varieties of _|_ than the other
03:47:23 <quicksilver> kulakowski: it's not a very interesting difference for most purposes.
03:50:05 * mux wonders aloud if he'll be able to code in Agda some day
03:50:25 * ejt was looking at Agda yesterday, looks very nice
03:50:49 <kulakowski> Would that be, you could match (bot,x,bot) against (_,x,_), but not (bot,(x,bot)) against (_,(x,_))?
03:51:16 <hackagebot> darcs-beta 2.2.98.2 - a distributed, interactive, smart revision control system (PetrRockai)
03:51:33 <quicksilver> kulakowski: no, those are both OK.
03:52:02 <quicksilver> kulakowski: it's that you can match (x,bot,bot) against (x,_,_) but not (x,bot) against (x,(_,_))
03:52:11 <kulakowski> ohh
03:52:18 <quicksilver> (although you could match it against (x,_))
03:52:38 <quicksilver> so the point is that, as patterns, (x,_) is less forcing than (x,(_,_))
03:52:43 <kulakowski> because it has to look in the tuple
03:52:45 <kulakowski> yeah
03:52:51 <osfameron> maartenm: hah, no Acorn/BBC emulators for Unix there :-)
03:52:57 <kulakowski> thanks
03:52:59 <quicksilver> whereas in the triple, there isn't anything like (x,_) at all.
03:54:06 <maartenm> ouch, sorry
03:54:20 <maartenm> I didn't realize you had such an acquired taste
03:57:14 <kulakowski> quicksilver: playing around with it now, it makes sense. thanks.
03:57:32 <maartenm> osfameron: http://jemu.winape.net/
03:58:05 <maartenm> osfameron: maybe jemu can run it.. it's an online applet that runs many old models...  there are many other online or just java-based emus
03:58:24 <osfameron> maartenm: great, thanks!  I'll have a look later (I say
03:58:38 <osfameron> "later"... I really want to retrogame now, but I guess I *should* do some work ;-)
03:59:36 <maartenm> euler problem #32 is driving me mad btw
04:01:20 * mux wonders how haskell type-classes would map into Agda
04:05:01 <maartenm> how do you do something like this?   couples n = [(a,b) | a <- [1..n], b <- [a..(n-a)]]   ?
04:05:23 <maartenm> I can't get my head around how to do it
04:06:02 <Cale> > let couples n = [(a,b) | a <- [1..n], b <- [a..(n-a)]] in couples 5
04:06:03 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,2),(2,3)]
04:06:18 <maartenm> huh
04:07:23 <Twey> Heh
04:07:28 <Cale> That was valid code, so I'm not sure what you're asking :)
04:07:44 <Twey> @faq Can Haskell speak your crazy mental language?
04:07:45 <lambdabot> The answer is: Yes! Haskell can do that.
04:07:53 <maartenm> well I got an error, and I was convinced my inaptitude at monads was the reason
04:08:05 <maartenm> but yes, it understands me
04:30:22 <EvilTerran> maartenm, there's no monads involved there, list comprehensions are defined in terms of filter, concat, and map
04:33:55 <maartenm> oh
04:34:11 <maartenm> I thought <- was a monad (I haven't studied monads yet)
04:34:14 <osfameron> EvilTerran: they are?
04:34:21 <osfameron> I thought they were sugar over the list monad
04:34:38 <maartenm> *sits back with some popcorn
04:34:42 <DarkUnicorn_> i thought the same
04:34:55 <osfameron> perhaps they are *conceptually* sugar, but are actually implemented with map/grep ?
04:35:17 <quicksilver> GHC has two different ways of implementing them
04:35:25 <quicksilver> but in principle it doesn't matter what you use :P
04:35:39 <osfameron> so everyone's right?! ;-P
04:35:57 <quicksilver> the report desugars to concatMap
04:35:57 <maartenm> btw, is there a nubBy ?
04:36:00 <quicksilver> and "if"
04:36:02 <quicksilver> and that's all.
04:36:05 <quicksilver> No filter, no map.
04:36:10 <kulakowski> yes maartenm
04:36:19 <maartenm> @index nubBy
04:36:20 <lambdabot> Data.List
04:36:27 <osfameron> ah ok... concatMap is basically all you need to implement either filter or map
04:36:37 <maartenm> my questions are getting really stupid lately
04:36:53 <quicksilver> osfameron: right.
04:37:01 <quicksilver> osfameron: well you also need [].
04:37:06 <osfameron> heh
04:37:07 <quicksilver> technically I should have mentioned that ;)
04:37:41 <EvilTerran> quicksilver, oh right, if, not filter
04:37:48 <jkff> ....Oh yes, the arithmetic mean on floats IS an algebra over the Dist monad! I wonder what are algebras over other monads..
04:37:54 <quicksilver> you can desugar list comps into anythng with >>= and mzero.
04:37:58 * EvilTerran considers "desugars to concatMap" to count as "desugars to concat and map"
04:38:07 <EvilTerran> given one inlining step :P
04:39:41 <Cale> SetAttributes[Comprehend, HoldAll]
04:39:41 <Cale> Comprehend[expr_] := {expr}
04:39:41 <Cale> Comprehend[expr_, {var_, l_}, rest___] := FlatMap[Function[var, Comprehend[expr, rest]], l]
04:39:41 <Cale> Comprehend[expr_, cond_, rest___] := If[cond, Comprehend[expr, rest], {}]
04:39:53 <Cale> ^^ Mathematica implementation of list comprehensions :)
04:40:15 <osfameron> you can write a comprehension as a normal function?
04:40:19 <Cale> yep
04:40:38 <osfameron> how do they manage that?  I mean with the variable bindings etc.
04:40:39 <Cale> I could even have made it use prettier syntax for the generators
04:40:42 <maartenm> hmm, I have a problem
04:40:51 <Cale> That's what the HoldAll business is about
04:40:55 <maartenm> couples n = [(a,b) | a <- [lfirst..rfirst], b <- [lsecond..rsecond]]
04:41:05 <maartenm> when I want to say "where lsecond = a..." it no longer has 'a' in scope
04:41:16 <Cale> It ensures that the parameters to Comprehend are not touched before Comprehend gets to manipulate them.
04:41:16 <maartenm> is "let" the syntax here?
04:41:25 <maartenm> or are they equivalent?
04:41:40 <Cale> maartenm: You can use let inside of a list comprehension
04:42:01 <Cale> The variable a only scopes over the inside of the list comprehension itself
04:42:08 <osfameron> Cale: so the variables are quoted symbolicalla Ã  la Lisp?
04:42:18 <maartenm> ok, so I actually do [ let .. = in ...]
04:42:19 <Cale> couples n = [(a,b) | a <- [lfirst..rfirst], let lsecond = a ... , b <- [lsecond..rsecond]]
04:42:27 <maartenm> oh, like that
04:42:42 <maartenm> amazing that works
04:42:52 <Cale> osfameron: yeah, it just directly places the variables in the inputs into the output
04:43:05 <Cale> osfameron: and then continues reducing from there
04:43:23 <osfameron> interesting
04:44:41 <Cale> It actually also warns you when this happens using syntax highlighting. The occurrence of var on the right hand side of the equation for Comprehend shows up in red, because it's already bound (but that's what we want)
04:45:36 <Cale> that is, it appears red when you use it as the first parameter to Function, because the syntax highlighter understands that Function is meant to bind its first parameter
04:52:52 <quicksilver> Cale: but this is like lisp macros - it means that by a trivial syntactic glance you can't see what is passed by value and what by name.
04:53:01 <quicksilver> Cale: which I find rather annnoying.
04:53:23 <quicksilver> (although you need to do something clever if you want to be able to define new binders)
05:07:33 <kulakowski> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6734#a6734 is there a way to do that pattern matching any more nicely?
05:09:29 <BONUS> what does that function do
05:09:38 <BONUS> why does it take a 7-tuple! gah!
05:10:11 <kulakowski> It's a bijection. And as you can see, it only depends on a bounded depth in the tree to calculate, so it works on infinite trees.
05:10:26 <kulakowski> and 7, because it wouldn't work for another number
05:10:27 <EvilTerran> well, you can write foo@(Branch _ _) as foo@Branch{}
05:11:05 <Twey> Because that's the main problem :-P
05:11:26 <Twey> It looks like you ought to be using a list...
05:11:54 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6735#a6735      (why isn't (1,100000) part of 'couples 6' ?)
05:12:30 <kulakowski> Twey: Why use a list?
05:13:07 <Twey> kulakowski: Because you can iterate over it
05:13:34 <kulakowski> But I don't _want_ to iterate over it.
05:15:09 <EvilTerran> kulakowski, is there some intuitive meaning to that function?
05:15:20 <kulakowski> Or at least, I don't see how you would express that function in terms of traversing a list. Also, it rather explicitly depends on having the product of 7 trees
05:15:34 <doserj> maartenm: b ranges only from lsecond to halfway, so how could it possibly be 100000?
05:15:34 <EvilTerran> i can't discern a pattern in those branches
05:15:50 <BONUS> what does it do, like, intuitively
05:16:06 <maartenm> because lsecond is 100000 when a `elem` [1..9] ?
05:16:10 <kulakowski> http://www.math.lsa.umich.edu/~ablass/cat.html the paper 'Seven trees in one'
05:16:19 <kulakowski> The short version is
05:16:30 <kulakowski> You can view
05:16:32 <kulakowski> data Tree = Null | Branch Tree Tree
05:16:55 <kulakowski> as saying there is an isomorphism from Tree to 1 + Tree * Tree
05:17:14 <kulakowski> ie every tree is either the empty tree, or is two trees side by side
05:17:16 <doserj> > [100000..1] -- maartenm
05:17:18 <lambdabot>   []
05:17:19 <BONUS> yeah
05:17:30 <kulakowski> so that's T = 1 + T^2
05:17:45 <maartenm> doserj: sorry
05:18:03 <maartenm> doserj: only way is reverse?
05:18:19 <doserj> > [100000,99999..1]
05:18:21 <lambdabot>   [100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,9...
05:18:23 <EvilTerran> the use of T^7 seems a little arbitrary, but i guess that's the paper's fault
05:18:23 <kulakowski> if you interpret that over the complex numbers, then some sixth root of unity is a solution, so T^6 =1, or multiplying by T, T^7 = T
05:18:44 <EvilTerran> ... weird.
05:18:52 <byorgey_> EvilTerran: that's the amazing thing, it isn't arbitrary at all! =)
05:18:55 <kulakowski> interpreting it as trees again, we would hope to have a 'nice' bijection between seven-tuples of trees and trees
05:20:07 <byorgey_> EvilTerran: see http://blog.sigfpe.com/2007/09/arboreal-isomorphisms-from-nuclear.html
05:20:31 <maartenm> doserj: damn, this doesn't have the O(n log n) effect I was hoping for...
05:21:16 <maartenm> doserj: I'm basically trying to derive all couples (a,b) for which a*b has n digits
05:22:25 <maartenm> doserj: or at least between (n-1) and (n+1)
05:28:51 * EvilTerran notes that (\a b -> length . show $ a*b) is monotonic in both parameters
05:29:06 <EvilTerran> (for positive a,b)
05:29:51 <BONUS> maartenm: you're doing euler 32?
05:29:57 <maartenm> bonus: yes
05:30:06 * EvilTerran tries to work out if some kind of pseudo binary search would be possible
05:30:08 <maartenm> evilterran: yeah.. I'll try to work with that
05:30:31 <BONUS> i'd suggest just picking a smart range of a and b and then filtering combinations from those ranges appropriately
05:30:47 <maartenm> yeah I'm trying to get a smart range
05:31:01 <maartenm> but I'm sure it has to be possible in O (n log n)
05:31:12 <maartenm> my current list comprehension takes ages
05:31:13 <BONUS> like [ ... | a <- [x..y], b <- [x'..y'], satisfiesPandigitalProduct a b]
05:31:21 <maartenm> really?
05:31:36 <mux> weird, connectTo seems unable to handle ERESTART
05:31:42 <maartenm> ok, maybe some more mathematical analysis is needed
05:32:00 <BONUS> i solved 32 in a rather naive way
05:32:03 <mux> err, EINPROGRESS
05:32:07 <BONUS> and it computes in like 2 seconds
05:32:30 <BONUS> it's all about picking a smart range imo
05:34:49 <maartenm> I made a glaring error in my satisfiesPandigitalProduct
05:34:56 <BONUS> haha really?
05:35:00 <maartenm> containsAllDigits a b = (==9) $ length $ nub $ str     where str = (show a) ++ (show b) ++ (show (a*b))
05:35:05 <maartenm> yeah, stupid
05:35:07 <maartenm> it doesn't consider '0
05:35:11 <maartenm> '0' as a digit
05:35:13 <EvilTerran> doh!
05:35:15 <BONUS> haha
05:36:21 * mux tries to reconcile the ktrace trace he's looking at and the code he sees in Network.Socket
05:36:46 <BONUS> yeah but i dont think you're supposed to take 0 into account
05:36:55 <maartenm> well, that's the problem here
05:37:11 <maartenm> 102345678 will be a string that satisfies the condition
05:37:19 <BONUS> ah
05:37:51 <BONUS> i just did (i suppose this isn't too much of a spoiler since you've already figured this part out): isPandigital = (=="123456789") . sort
05:38:10 <maartenm> yeah that's much more clever
05:38:14 <BONUS> and then satisfies a b = isPandigital $ show a ++ show b ++ show (a*b)
05:39:37 <maartenm> I saw this crazy solution for problem #31, btw, in Haskell
05:40:11 <BONUS> yeah?
05:40:18 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6738#a6738
05:40:24 <maartenm> its mind-bogglign, for ;e at least
05:40:54 <BONUS> oh man neat
05:41:09 <BONUS> i remember having problems with duplicates on this one
05:41:13 <maartenm> well I solved #32 now, although it took about 40s
05:41:34 <maartenm> (using this: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6739#a6739 )
05:41:37 <BONUS> like how to make it so that 1p + 50p + ... and 50p + 1p + ... are not counted twice
05:41:53 <maartenm> I couldn't solve #31, it's the only one yet
05:41:57 <maartenm> at least not in haskell
05:42:09 <maartenm> I'll try it tonight
05:42:14 <BONUS> i just solved 31 in a really naive way
05:42:35 <BONUS> like trying all combinations of coins and then just filtering
05:43:03 <maartenm> yeah, generating the combinations instead of the other way around
05:43:19 <BONUS> here's my solution to 32 http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6739#a6740
05:43:58 <maartenm> ah, I guess those ranges are fine
05:44:14 <BONUS> i don't remember how exactly i got the ranges, i think i did some analysis
05:44:16 <maartenm> I calculated mine.. didn't think about it clearly
05:45:01 <maartenm> I also suppose that there is a better way than (length . show  a) .. but I always refrain from using logarithms
05:45:06 <maartenm> or should one use logarithms there
05:45:16 <BONUS> yeah just usually use length . show
05:45:21 <BONUS> i mean i do
05:47:05 <maartenm> now let's see the J solutions..
05:47:37 <BONUS> #@'!!"&=.#!
05:48:03 <mux> @src throwSocketError
05:48:04 <lambdabot> Source not found. Are you on drugs?
05:48:08 <ErhardtMundt> hey BONUS :D
05:48:42 * mux actually wishes he was on drugs
05:51:15 <mux> ok, this is a platform-specific issue, the same code using connectTo runs fine on another Linux box
05:51:25 <EvilTerran> is that throwing a socket error, or an error when throwing a socket? :P
05:52:13 <BONUS> hey michele :)
05:56:03 <ErhardtMundt> BONUS, how're you?
05:56:17 <saml> i'm good ErhardtMundt
05:56:59 <ErhardtMundt> saml, i'm pleased to hear so :)
05:57:36 <BONUS> hehe good, working on LYAH atm
05:57:44 <BONUS> hoping to have it finished by the end of the summer
05:57:51 <ErhardtMundt> BONUS, i've just seen the new chapters
05:58:08 <ErhardtMundt> i've finished the review on the last part
05:58:17 <BONUS> cool
05:58:34 <ErhardtMundt> now i've got to solve the issue of the text out of the boundaries
05:58:46 <ErhardtMundt> than it would be ready to print :)
05:59:20 <BONUS> ooh awesome, if you make some new versions of the pdf send them my way so that i can put them up on the site
05:59:42 <ErhardtMundt> BONUS, of course
06:03:26 <Baughn> Just to check before I look at it in detail, boyer-moore should be applicable to patterns including simple one-token wildcards (that is, a regex .), right?
06:08:05 <maartenm> I don't understand how Haskell deals with 'map (\(a,b) ->  a / b) fractions where fractions = [(a,b) | a <- [11..98], b <- [a..99]]'
06:08:25 <maartenm> I do not understand why it throws an error on this (no instance for Fractional Int)
06:10:57 <dankna> I'm not sure I understand why it does that either,
06:11:19 <maartenm> > map (\(a,b) ->  a / b) fractions where fractions = [(a,b) | a <- [11..98], b <- [a..99]]
06:11:19 <dankna> but you can of course correct it by doing fromIntegral a / fromIntegral b
06:11:20 <lambdabot>   <no location info>: parse error on input `where'
06:11:57 <Cale> > let fractions = [(a,b) | a <- [11..98], b <- [a..99]] in map (\(a,b) ->  a / b) fractions
06:11:58 <lambdabot>   [1.0,0.9166666666666666,0.8461538461538461,0.7857142857142857,0.73333333333...
06:12:04 <BONUS> magic
06:12:27 <dankna> > [(a,b) | a <- [11..98], b <- [a..99]]
06:12:28 <lambdabot>   [(11,11),(11,12),(11,13),(11,14),(11,15),(11,16),(11,17),(11,18),(11,19),(1...
06:12:32 <Cale> maartenm: However, if somehow it thinks that fractions is a list of (Int,Int) pairs, then that would be a problem
06:12:43 <Cale> maartenm: Because you can't use / on Int values
06:12:48 <dankna> (I hadn't seen that b <- [a bit before and wanted to convince myself it really worked)
06:13:05 <maartenm> ok, I need to explicitly give fractions a type when it's outside of a let/where?
06:13:43 <dankna> are you referring to fractions anywhere else?
06:13:50 <maartenm> yeah it's a seperate function
06:13:51 <dankna> that other reference might be causing type inference to happen
06:17:07 <maartenm> I don't understand what type I should give fractions
06:17:31 <maartenm> fraction :: [(Integer,Integer)]
06:18:11 <Valodim> man installing stuff with cabal is a PITA, getting dependencies to work right really becomes a game of chance after a number of packages
06:19:35 <byorgey> maartenm: you can give it any type you like, but in order to divide numbers with (/) they must be an instance of Fractional.  Int and Integer are not Fractional since you can't divide two integers and get another integer.
06:19:48 <byorgey> maartenm: however, you can use  fromIntegral to convert before you do the division.
06:19:49 <maartenm> ok, but Fractional is a class
06:19:53 <byorgey> maartenm: right.
06:19:59 <maartenm> I have to read up on clases then, haven't worked with them yet
06:20:06 <byorgey> maartenm: Double and Rational are examples of instances of Fractional.
06:20:20 <byorgey> > (3 :: Integer) / (4 :: Integer)   -- error
06:20:21 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
06:20:22 <lambdabot>    aris...
06:20:32 <dankna> > (3 :: Rational) / (4 :: Rational)
06:20:33 <lambdabot>   3 % 4
06:20:34 <byorgey> > (fromIntegral (3 :: Integer)) / (fromIntegral (4 :: Integer))  -- this works fine
06:20:36 <lambdabot>   0.75
06:21:00 <byorgey> maartenm: so in your case you can do   map (\(a,b) -> fromIntegral a / fromIntegral b)
06:21:14 <byorgey> maartenm: alternatively, if you want *integer* division, you can do that with  `div`
06:21:19 <maartenm> > (30 :: Rational) / (40 :: Rational)
06:21:20 <lambdabot>   3 % 4
06:21:22 <dankna> > (3 :: (Fractional a) => a) / (4 :: (Fractional a) => a)
06:21:22 <byorgey> > (7 :: Integer) `div` (3 :: Integer)
06:21:23 <lambdabot>   0.75
06:21:24 <lambdabot>   2
06:21:32 <hackagebot> MazesOfMonad 1.0.5 - Console-based Role Playing Game (JeanPhilippeMoresmau)
06:21:58 <BONUS> haha
06:22:43 <maartenm> I think in my case, I want Rational :)
06:22:45 <byorgey> maartenm: btw, type classes are quite simple at root: each class C lists a number of functions, and any type which is an instance of that class must implement the functions.
06:22:51 <maartenm> (euler #33)
06:22:57 <byorgey> maartenm: it's kind of like Java interfaces if you're familiar with that.
06:23:04 <maartenm> yes I understand
06:23:15 <byorgey> :t (/)
06:23:17 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:23:22 <maartenm> btw are all the methods vritual?
06:23:25 <byorgey> (/) is a method of the Fractional class.
06:23:38 <maartenm> like, I don't *have* to implement the entire interface (think Ruby or Python)
06:23:38 <byorgey> maartenm: what do you mean?
06:23:49 <maartenm> or eh.. am I assuming weak typage here and am I going to be flamed?
06:23:51 <byorgey> maartenm: ah, indeed.  and some can even have default implementations.
06:24:13 <dankna> maartenm: they're not virtual; they all have to be implemented.  but sometimes there are default implementations.
06:24:22 <maartenm> ok
06:24:26 <byorgey> if you don't implement one you will just get a warning.
06:24:31 <dankna> oh, really?
06:24:33 <byorgey> and the program will still work as long as you never call it.
06:24:35 <byorgey> yup
06:24:46 <dankna> well, I don't like code with warnings in it :) but okay, haha
06:24:47 <lilac> maartenm: the problem you were having with fractions was probably the monomorphism restriction
06:24:55 <maartenm> lilac: ?
06:25:06 <byorgey> dankna: me neither, but sometimes it's useful for, say, the Num class, which is braindead
06:25:16 <dankna> heh, yeah, I see that
06:25:26 <lilac> maartenm: fractions should have had type 'Num a => [(a, a)]'
06:25:35 <lilac> @type [(a,b) | a <- [11..98], b <- [a..99]]
06:25:37 <lambdabot> forall t. (Num t, Enum t) => [(t, t)]
06:25:46 <lilac> ^^ well, that
06:26:11 <lilac> maartenm: but the monomorphism restriction forces that down to being a monotype when you put the 'fractions' binding at the top level
06:26:24 <lilac> defaulting chooses [(Integer, Integer)] I think
06:26:49 <quicksilver> lilac: no, defaulting would choose Double
06:26:51 <quicksilver> lilac: because he used /
06:26:58 <lilac> quicksilver: hmm
06:27:17 <quicksilver> so some other part of his program must have pinned the type to int.
06:27:35 <maartenm> well I defined fractions elsewhere
06:27:47 <maartenm> I used "where" in the irc chat to communicate easily
06:28:01 <quicksilver> doesn't matter.
06:28:19 <quicksilver> there's no difference in behaviour between let-bound, where-bound, or top-level-bound in this respect.
06:28:46 <maartenm> am I not tying it to Int because I do a <- [11..98], .. ?
06:29:08 <quicksilver> no.
06:29:13 <quicksilver> :t [11..98]
06:29:15 <lambdabot> forall t. (Num t, Enum t) => [t]
06:31:38 <maartenm> I don't understand then.. but I'll try to figure out
06:31:49 <BONUS> can you just paste your program
06:32:11 <maartenm> ok
06:33:03 <maartenm> if I load this in ghci.. : http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6744#a6744
06:33:24 <maartenm>  map (\(a,b) -> a/b) fractions  in ghci will return aforementioned type error
06:34:00 <roconnor> map (\(a,b) - fromIntegral a / fromIntegral b) ?
06:34:06 * roconnor hasn't looked at the paste
06:34:07 <maartenm> yes, yes
06:34:11 <maartenm> but why
06:34:22 <EvilTerran> maartenm, did uncommenting that type signature work?
06:34:29 <EvilTerran> (fractions :: [(Rational,Rational)])
06:34:29 <maartenm> yeah now it works fine
06:34:41 <EvilTerran> that'll be the dreaded monomorphism restriction, then
06:34:52 <maartenm> but when someone did it here with the bots
06:34:55 <roconnor> gah
06:34:59 <maartenm> in a let-bound
06:35:06 <maartenm> the bot didn't complain
06:35:39 <roconnor> bots probably don't have MR
06:36:10 <roconnor> I think I should add :set -fno-monomorphismrestriction to my .ghci file.
06:36:22 <EvilTerran> roconnor, -XNoMonomorphismRestiction!
06:36:36 <roconnor> to .ghci?
06:37:26 <lilac> quicksilver: presumably your comment doesn't apply because the / was not in the same binding group?
06:37:37 <roconnor> $ cat ~/.ghci
06:37:39 <roconnor> :set -fno-print-bind-result
06:37:40 <roconnor> :set -fno-monomorphism-restriction
06:37:43 <quicksilver> lilac: yes, that wasn't clear to me.
06:37:56 <quicksilver> lilac: in the example he pasted here, it was.
06:37:57 <EvilTerran> maartenm, have you seen http://www.haskell.org/haskellwiki/Monomorphism_restriction ?
06:38:15 <maartenm> ok, I'll read this
06:38:15 <lilac> quicksilver: right. i was checking to clarify my understanding
06:38:45 <maartenm> as a beginner, I think it would be great if ghc had a mode where it gives 'hints' to the errors it throws
06:38:49 <maartenm> such as a link to the wiki or something
06:39:23 <lilac> maartenm: the monomorphism restriction is fairly horrible, and i believe it's being removed in Haskell prime
06:39:34 <maartenm> it's like super-super-strong types?
06:39:48 <lilac> in some cases GHC does spot that the monomorphism restriction caused a problem, but i guess this isn't one of them
06:40:28 <lilac> maartenm: the point of it is: without it, if your 'fractions' took a long time to compute, two parts of your program could use it with different types
06:40:52 <quicksilver> the really surprising thing about hte monomorphism restriction is that its inclusion is justified by appealing to remarks about sharing -- in a standard which does not specify sharing behaviour.
06:40:59 <lilac> maartenm: if that happened, the long computation would need to be performed twice. the monomorphism restriction avoids that by forcing it to be used with only one type
06:41:17 <skorpan> i'm pretty new to threading and concurrency in haskell, so i'd like some pointers if someone's up for it... i'm trying to create two threads: one (X) which waits for input from a handle indefinitely, and another (Y) which pings the same handle every 30 seconds that has gone by without any input.  any ideas on where i should start looking?
06:41:19 <quicksilver> if the report specified clearly that CAFs are shared in general, the MR would make more sense.
06:42:00 <maartenm> the way you put it it sounds a bit like Haskell's Dirty Secret
06:42:02 <skorpan> do i need MVars for this scenario?
06:42:15 <quicksilver> you will need MVars or chans to communicate between them
06:42:18 <lilac> maartenm: the monomorphism restriction /is/ Haskell's Dirty Secret ;-)
06:42:20 <dankna> why do you want Y to poll?
06:42:30 <quicksilver> e.g. you might have an MVar storing the time of the last input
06:42:32 <dankna> Chans sound like a cleaner solution, with no polling required
06:42:35 <quicksilver> which is set by X
06:42:47 <dankna> but without knowing the purpose, I guess I can't really say that
06:42:49 <quicksilver> and Y can inspect it to see if that was more than 30 seconds ago.
06:42:53 <skorpan> dankna: i'm waiting for output from a server in one thread, but if the server will timeout unless i ping it occasionally.
06:43:01 <dankna> hmm
06:43:24 <skorpan> dankna: this is the MPD (music player daemon) protocol, if that helps
06:43:39 <dankna> that gives me a more concrete idea of what you're doing, yes
06:43:45 <skorpan> i'm first telling the server to send me any update information about the state of the music playing, but i need to ping it occasionally to tell it i'm still listening.
06:43:55 <skorpan> this is the new "idle" command in MPD 0.14 or so
06:43:58 <dankna> okay, so what quicksilver said
06:44:03 <skorpan> cool, thanks
06:44:31 <lilac> skorpan: forever (thread Y waits for 30 seconds, then let t = how long ago the handle last got input. if t >= 30, do your thing, else sleep for 30 - t)
06:44:52 <skorpan> yup, something along those lines
06:45:13 <skorpan> *coughthiswouldbesonicetowriteinerlangcough*
06:46:14 <quicksilver> forkIO (forever $ l <- hGetLine h; getCurrentTime >>= writeMVar mv; {- presumably do somethign with l -} )
06:46:17 <lilac> alternatively, you could spawn a "wait 30 seconds" thread when you get input, and kill it next time you get input...
06:47:49 <dankna> I've never seen anything remotely thread-like that isn't heavyweight, hence why new "smaller threads" keep getting invented.  (fibers, sparks, ...)  while a priori guesses about performance are often wrong and one should always measure to be sure, I suspect the MVar way is likely to be faster. :)
06:49:22 <bgs100> > [ c | c <- "This is a tEst, yeS iT is", c `elem` ['A'..'Z']]
06:49:26 <lambdabot>   "TEST"
06:49:58 <dankna> ha, cute
06:50:02 <nominolo|uni> > [ c | c <- "This is a tEst, yeS iT is", inUpper c]
06:50:04 <lambdabot>   Not in scope: `inUpper'
06:50:08 <nominolo|uni> > [ c | c <- "This is a tEst, yeS iT is", isUpper c]
06:50:10 <lambdabot>   "TEST"
06:53:01 <quicksilver> dankna: haskell threads are pretty lightweight in the grand scale of things.
06:53:21 <dankna> oh, I know.  but they still have separate stacks.
06:53:22 <quicksilver> dankna: very little context to switch, pre-empting at memory allocation time.
06:53:38 <quicksilver> true enough.
06:53:48 <dankna> but yeah, it's a nice abstraction
06:53:48 <SamB_XP> dankna: on the heap
06:54:14 <dankna> it's very nice how blocking for IO gets transformed into an appropriate low-level call to select() or whatever
06:54:25 <maartenm> "mod" doesn't work on Rational?
06:54:32 <dankna> use mod'
06:54:38 <SamB_XP> :t mod'
06:54:41 <lambdabot> forall a. (Real a) => a -> a -> a
06:54:44 <mux> dankna: this is the same than what is done for userland threading libraries
06:54:45 <SamB_XP> @hoogle mod'
06:54:46 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
06:54:46 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
06:54:59 <maartenm> @index mod'
06:55:00 <lambdabot> bzzt
06:55:05 <dankna> mux: yes; I'm just impressed that it's done transparently
06:55:08 * SamB_XP never heard of mod' before
07:00:51 <maartenm> @hoogle div'
07:00:52 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
07:01:53 <maartenm> suppose I have a Rational, a
07:02:21 <maartenm> f.i., 35, and I want to divide it by 10 the way you do with Ints...
07:02:31 <maartenm> do I have to use casting there?
07:03:00 <maartenm> 35/10 = 3, instead of 7/2
07:03:06 <maartenm> 7%2
07:03:38 <dankna> :t div'
07:03:39 <lambdabot> forall a b. (Real a, Integral b) => a -> a -> b
07:03:54 <byorgey> maartenm: do you know that the rational has a denominator of 1?
07:03:55 <maartenm> but that gives me an Integral
07:04:00 <tomh-> > 35 `div'` 3
07:04:01 <lambdabot>   11
07:04:07 <tomh-> > 35 `div'` 10
07:04:09 <lambdabot>   3
07:04:34 <tomh-> > fromIntegral $ 35 `div'` 10
07:04:36 <lambdabot>   3
07:04:38 <dankna> > fromIntegral $ 35 `div` 10 :: Rational
07:04:39 <lambdabot>   3 % 1
07:04:40 <maartenm> > div (30::Rational) (17::Rational)
07:04:42 <lambdabot>   No instance for (GHC.Real.Integral GHC.Real.Rational)
07:04:42 <lambdabot>    arising from a use...
07:04:45 <maartenm> > div' (30::Rational) (17::Rational)
07:04:46 <lambdabot>   1
07:04:50 <maartenm> hmm
07:04:51 <bgs100> > 7 `mod` 5
07:04:53 <lambdabot>   2
07:04:58 <maartenm> that didn't work in ghci
07:05:02 <dankna> > fromIntegral $ 35.0 `div` 10.0 :: Rational
07:05:04 <lambdabot>   Add a type signature
07:05:06 <maartenm> ok I'll figure it out
07:05:07 <dankna> > fromIntegral $ 35.0 `div'` 10.0 :: Rational
07:05:08 <lambdabot>   3 % 1
07:05:15 <byorgey> what is div' ?
07:05:21 <byorgey> i've never seen that before
07:05:21 <dankna> it's like div, but not
07:05:53 <byorgey> maartenm: you can use 'fromIntegral' to convert an Integral value back to (say) Rational
07:05:56 <maartenm> > div' (30::Rational) 17
07:05:57 <lambdabot>   1
07:06:05 <maartenm> ok, my code is getting really ugly
07:06:09 <lilac> > 1.73 `div'` 0.924
07:06:11 <lambdabot>   1
07:06:30 <byorgey> maartenm: why do you want to do 'div' on Rationals?
07:06:34 <byorgey> that seems odd
07:06:45 <SamB_XP> maartenm: if I have to use fromIntegral more than once, I often locally abbreviate it as "fI"
07:06:52 <maartenm> well I need the power of Rationals
07:06:53 <maartenm> look:
07:07:13 <SamB_XP> maartenm: might I suggest divMod' ?
07:07:16 <bgs100> > ['A'..'Z']
07:07:18 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
07:07:22 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6746#a6746
07:07:30 <bgs100> > take 25 ['A'..]
07:07:31 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXY"
07:07:32 <maartenm> SamB_XP: ok I think that could save me some code
07:07:38 <bgs100> > take 26 ['A'..]
07:07:40 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
07:07:42 <maartenm> GHCI can't understand the code I pasted
07:07:52 <yaxu> the newest haskeline looks vastly improved over the version that ghci uses
07:07:57 <maartenm>   No instance for (Integral Rational)     arising from a use of `div'' at euler33.hs:16:34-42   Possible fix: add an instance declaration for (Integral Rational)
07:08:00 <yaxu> do I need to rebuilt ghc to use it?
07:08:04 <yaxu> rebuild
07:08:33 <maartenm> oops
07:08:38 <maartenm> forget the fromIntegral there
07:08:47 <SamB_XP> maartenm: good catch ;-)
07:08:58 <maartenm> but anyway, even without that
07:09:01 <maartenm> it gives the same error
07:09:22 <SamB_XP> :t divMod'
07:09:23 <lambdabot> forall a b. (Real a, Integral b) => a -> a -> (b, a)
07:09:47 <SamB_XP> maartenm: well, the "div'" result is an Integral
07:09:53 <maartenm> I really want to keep a and b as rationals
07:10:02 <doserj> why?
07:10:05 <maartenm> since I use their power to quickly check that a/b has not changed by the transform
07:10:22 <SamB_XP> fI it, then
07:10:33 <maartenm> okay.. and I thought this would be a oneliner
07:10:35 <yaxu> I'm a bit confused because the ghc source tarball doesn't seem to have haskeline in it
07:10:46 <SamB_XP> yaxu: that does sound odd
07:11:32 <bgs100> > let nouns = ["pie", "cereal", "cheese"]; adjectives = ["yummy", "bad", "moldy"]; [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
07:11:33 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:15:21 <yaxu> I must have done something stupid
07:15:40 <EvilTerran> maartenm, you should be able to do that one using only integer types, i think
07:15:59 <EvilTerran> although it may need a bit of algebraic manipulation of the problem first
07:16:30 <maartenm> yes, well at least I learned something about haskell this way
07:16:43 <maartenm> I have a feeling the euler problems are good at learning haskell only up to a certain point
07:17:24 <BONUS> they're good for getting the basic feel of it
07:17:38 <BONUS> and thinking in compositions, laziness, etc.
07:18:02 * wli thinks they're not good programming fodder.
07:18:11 <maartenm> my new code still throws a No instance for (Integral Rational)   arising from a use of `div'' at euler33.hs:18:28-36
07:18:21 <maartenm> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=6747#a6747
07:19:26 <lilac> > let nouns = ["pie", "cereal", "cheese"]; adjectives = ["yummy", "bad", "moldy"] in liftM2 (\a n -> a ++ " " ++ n) adjectives nouns
07:19:28 <lambdabot>   ["yummy pie","yummy cereal","yummy cheese","bad pie","bad cereal","bad chee...
07:20:02 <quicksilver> :t div'
07:20:03 <lambdabot> forall a b. (Real a, Integral b) => a -> a -> b
07:20:14 <quicksilver> maartenm: div' always returns an integer.
07:20:23 <maartenm> but I do fI on it
07:20:34 <maartenm> I thought that would convert it back to a Rational
07:22:02 <quicksilver> maartenm: the problem is that mod' does not produce an Integral.
07:22:10 <quicksilver> rather, mod' produces its input type.
07:22:11 <maartenm> :t mod'
07:22:13 <lambdabot> forall a. (Real a) => a -> a -> a
07:22:16 <maartenm> ouch
07:22:17 <maartenm> sorry
07:22:21 <quicksilver> which is obvious if you think about it ;)
07:22:30 <quicksilver> > 4.5 `mod'` 2
07:22:32 <lambdabot>   0.5
07:22:33 <maartenm> yeah it is.. my brain is overheating
07:23:01 <maartenm> ok, works now
07:23:18 <maartenm> now to squeeze this in one line..
07:25:20 <maartenm> goddamn 11/11 case.. :)
07:25:26 <maartenm> is that one considered 'trivial' ?
07:25:47 <maartenm> yeah of course
07:25:48 <maartenm> nevermind
07:27:51 <skorpan> has there ever been any discussion about introducing whenM in Control.Monad?
07:28:07 <skorpan> whenM cond act = do { true <- cond; when true act }
07:29:25 <jkff> :t when
07:29:27 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:29:30 <jkff> Ah
07:29:43 <dankna> the distinction from when being that the condition is in the monad
07:29:48 <jkff> Yep
07:30:17 <quicksilver> skorpan: certainly no more than once a day
07:30:44 <BONUS> whenM has two possible semantics/types though
07:30:54 <BONUS> you can do m Bool -> m () -> m ()
07:31:09 <BONUS> or you can do n Bool -> m () -> n (m ())
07:31:15 <BONUS> where n and m are Monad
07:31:24 <BONUS> although i guess the first one is more popular and useful
07:39:53 <maartenm> @hoogle product'
07:39:54 <lambdabot> No results found
07:46:13 <mux> bah, I just wasted at least a couple of hourse trying to figure out why I could not connect to some port using haskell while telnet succeeded - and it was actually because listenOn listened on IPv6 only..
07:46:32 <maartenm> man, problem #33 is a lot easier if you know about Data.Ratio
07:47:12 <lilac> @type (. flip when) . (>>=)
07:47:13 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
07:50:04 <BONUS> @pl (\a b -> slv upper_limit a (now_at + b))
07:50:04 <lambdabot> (. (now_at +)) . slv upper_limit
07:50:09 <BONUS> ugh
07:56:43 <lyndon> Hi :)
07:56:46 <lyndon> Loading package svgcairo-0.10.1 ... can't load .so/.DLL for: intl (dlopen(libintl.dylib, 9): image not found)
07:56:52 <lyndon> Any ideas?
08:03:48 <maartenm> why is 0! = 1 ?
08:03:56 <maartenm> is that because of the gamma function or something?
08:04:10 <maartenm> (in the euler problems, I mean)
08:04:17 <kulakowski> maartenm: any number of reasons. that is one
08:04:19 <bremner> maartenm: because if it was 0, then k!=0 for all k
08:04:24 <kulakowski> another is that it's an empty product
08:04:47 <maartenm> I only know it made me lose 20 minutes of my life :)
08:04:58 <sm> morning all
08:05:08 <kulakowski> another is that, for all positive n, (n+1)!/(n+1) = n!, so we'd want (0+1)!/(0+1) = 1/1 = 1
08:05:28 <sm> would anyone know why a haskell lib such as happstack would listen with ipv6 on some machines ?
08:05:39 <Zao> Sounds sane.
08:05:41 <sm> by default ?
08:06:31 <Zao> Why not?
08:07:13 <skorpan> because no one uses ipv6 yet
08:07:33 <Zao> I do. All of my uni does.
08:07:42 <Zao> Real Men Â® do. :)
08:07:55 <Zao> I assume it listens on all available interfaces, I hope.
08:08:04 <tomh-> @src zip
08:08:04 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
08:08:05 <lambdabot> zip _      _      = []
08:08:05 <Zao> Listening on just v6 would be a bit silly.
08:08:14 <tomh-> @src concat
08:08:15 <lambdabot> concat = foldr (++) []
08:08:41 <shambler> @src foldr
08:08:42 <lambdabot> foldr f z []     = z
08:08:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:08:44 <shambler> ;(
08:09:09 <idnar> sm: it's more likely to do with the kernel configuration on that machine than happstack per se
08:09:12 <EvilTerran> shambler, hoping for something else?
08:09:15 <FauxFaux> Some machines have a broken /etc/hosts with a localhost of ipv6.
08:09:29 <maartenm> suppose you have zero apples, and you need to find all possible ways of picking one apple from it
08:09:36 * sm reads.. hmm, thanks
08:09:49 <maartenm> hmm, nevermind
08:09:53 <Zao> FauxFaux: If you have v6 enabled in your kernel and configured on interfaces, why not.
08:10:03 <idnar> I believe most systems have net.ipv6.bindv6only = 0 these days
08:10:16 <sm> netstat -l --inet6 --inet -n  shows this: tcp6       0      0 :::5000                 :::*                    LISTEN
08:10:20 <idnar> er wait, that's not the sysctl I want
08:10:22 <Zao> idnar: Sounds horribly tied to a single OS that.
08:10:30 <sm> and the issue is that a regular web browser can't seem to connect to that
08:11:37 <sm> it normally looks like this: tcp        0      0 0.0.0.0:5000            0.0.0.0:*
08:12:01 <Zao> Maybe it's something in your happstack app?
08:12:39 <sm> there might be some configuration that low levels of happstack should do.. I'll pursue
08:13:16 <BONUS> hehe remembered today that my solution to euler 31 ran really slow and was not elegant at all so i rewrote it
08:13:24 <BONUS> 6 lines, 0.2 seconds :]
08:13:47 <idnar> bah, I can't find it
08:14:12 <idnar> there's a configuration knob... somewhere... that controls whether you get dual v4/v6 sockets or v6 only
08:14:36 <maartenm> BONUS: did you go the other waya roundnow, instead of generating all possibilities?
08:15:38 <BONUS> yeah, i went with a recursive solution and figured out how not to count different permutations of the same count of coins
08:16:06 <jkff> That's a canonical example of dynamic programming
08:16:07 <maartenm> I'm at #36 now
08:16:15 <maartenm> it's pretty hard.. although I realize there are some shortcuts
08:16:49 <maartenm> sorry, #35
08:16:59 <skorpan> what's the easiest way in haskell to get a UNIX timestamp of the current time?
08:17:00 <jkff> 36 is rather trivial
08:17:11 <mux> I'm at 118 problems solved, but now it takes me a really long time to solve just one
08:17:35 <jkff> I am at 104, that's more than 100 but much less than 150, so I don't have much motivation :)
08:17:38 <maartenm> jkff: yes I mean 35, 36 looks trivial indeed.. I try to do them in order
08:17:47 <SamB_XP> did anyone solve the monopoly one?
08:17:48 <skorpan> nvm, found it
08:17:57 <SamB_XP> I mean, any of you?
08:17:59 <maartenm> I glanced at one of the final problems yesterday.. (with the reflections).. it looked absurd
08:18:08 <SamB_XP> assuming you're talking about PE?
08:18:08 <BONUS> 35? just look at all primes less than 1 million, rotate them, filter, and count
08:18:21 <mux> SamB_XP: I'm having troubles even thinking how to compute a solution for that one
08:18:41 <SamB_XP> mux: well, I was thinking it involved eigenvalues somehow
08:18:48 <maartenm> bonus: yeah but I try not to brute them .. I realized there couldn't be an even number in the digits
08:19:08 <maartenm> bonus: it's not really hard.. I just made a mess of the rotating
08:19:21 <SamB_XP> I started solving it in Mathematica during my probability and statistics class, but the prof. didn't really like us playing on the computers during class so she moved us to a different room ...
08:19:48 <BONUS> hehe
08:19:52 <SamB_XP> I think she may not have minded *my* playing on the computer as such, though I think the noise might have bothered her
08:20:07 <BONUS> i brute them every time i can hehe
08:20:07 <jkff> well, computing all primes below 1 million does not take too long, and there are not too many of them, and after that the rest looks trivial, doesn't it?
08:20:35 <maartenm> jkff: it is, if you know haskell.. I'm a total newbie and screwed up the rotation
08:20:49 <maartenm> jkff: but I did it better now
08:20:50 <SamB_XP> I had basically come up with all the different states that mattered for the rules as given
08:20:51 <jkff> Honestly, I think I did that problem in Java ;)
08:20:54 <Cale> SamB_XP: Play[RiemannSiegelZ[1000 t], {t, 0, 1}]
08:20:54 * EvilTerran wrote a program for generating primes, satisfied himself that it worked, then downloaded an epic list off primegrid and used that thereafter :P
08:21:07 <SamB_XP> Cale: what's that?
08:21:18 <BONUS> i remember seeing extrapolating that it would take my computer like half an hour to solve some problem, so i just left it running and went to lunch
08:21:24 <BONUS> dirtiest solution ever probably
08:21:27 <Cale> A noise to bother your teacher
08:21:39 <SamB_XP> Cale: I meant the keyboard might have bothered her ;-P
08:21:44 <Cale> It sounds a bit like a UFO :)
08:22:24 <SamB_XP> anyway, I'd basically come up with the states that mattered for the rules
08:24:04 <BONUS> euler 97 (finding the last 10 digits of a really big prime) is funny to do in haskell
08:24:31 <BONUS> cause it's like a one-liner
08:24:31 <SamB_XP> something like (location :: Location, doublesInARowSoFar :: 0..a), iirc
08:25:07 <bgs100> > let factorial n = product [1..n]; factorial 5
08:25:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:25:27 <EvilTerran> > let fact n = product [1..n] in fact 5 -- bgs100
08:25:29 <lambdabot>   120
08:25:29 <maartenm> bonus: I think you won't be able to brute problem #250 :)
08:25:56 <bgs100> Thanks EvilTerran
08:25:59 <EvilTerran> bgs100, you can separate different definitions in a "let" with semicolon or newline, but you have to finish it with "in <expression>"
08:26:05 <EvilTerran> except in ghci or a do-block
08:26:07 <maartenm> although.. you could generate all 16-digit numbers and try them all as answers :)
08:26:09 <bgs100> Ah
08:26:19 <BONUS> haha
08:26:20 <BONUS> oh my
08:26:47 <maartenm> would only take about 15 days at worst since you need 20s between each wrong answers
08:27:10 <maartenm> oops
08:27:21 <maartenm> make that one billion years
08:27:21 <jkff> Euler 188 is very cool. It's a one-liner in Mathematica and not hard to replicate in Haskell; probably some 10 lines
08:28:03 <BONUS> saw an interesting problem the other day (not on euler): calculate 2006^2007^2008^ ... ^2017 `mod` 11
08:28:17 <BONUS> it's fun because you can do it on paper
08:28:42 <soupdragon> how many guesses do I get?
08:28:49 <maartenm> hah
08:28:49 <McManiaC> @pl \x -> zip3 a x b
08:28:50 <lambdabot> flip (zip3 a) b
08:29:20 <tomh-> mm is there some haskell thing i overlook when i have a list function which returns an IO SomeType and i want to apply it to a list and get IO [SomeType] and not [IO SomeType] ?
08:29:35 <McManiaC> @pl \x -> zip3 a x a
08:29:35 <BONUS> yeah, don't map it, but use mapM
08:29:35 <lambdabot> flip (zip3 a) a
08:29:48 <vinicius> @type mapM
08:29:48 <tomh-> mapM thanks
08:29:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:30:24 <vinicius> @type join
08:30:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:30:32 <maartenm> bonus: that's a^(b^c), right?
08:30:49 <maartenm> (I've been learning J today and I'm not sure about naything anymore now)
08:31:22 <Ferdirand> BONUS: is it 5 ?
08:31:35 <vinicius> > join [Just 1, Just 2, Just 3]
08:31:37 <lambdabot>   Couldn't match expected type `[t]'
08:32:00 <EvilTerran> vinicius, all "m"s in the type of join must refer to the same thing
08:32:15 <vinicius> oh, indeed
08:32:26 <vinicius> @type ap
08:32:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:32:33 <EvilTerran> ?type (join :: [[a]] -> [a], join :: Maybe (Maybe a) -> Maybe a)
08:32:35 <lambdabot> forall a a1. ([[a]] -> [a], Maybe (Maybe a1) -> Maybe a1)
08:33:28 <vinicius> @type seqM
08:33:29 <lambdabot> Not in scope: `seqM'
08:33:40 <vinicius> @type sequence
08:33:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:33:51 <vinicius> that
08:34:16 <vinicius> > sequence [Just 1, Just 2, Just 3]
08:34:18 <lambdabot>   Just [1,2,3]
08:34:40 <maartenm> if it's not 5, it's 0
08:34:49 <maartenm> but I'm not sure how you can prove that it's not 0
08:35:21 <BONUS> Ferdirand: yeah i think that was the answer
08:35:25 <BONUS> maartenm: yeah like that
08:35:31 <maartenm> hmm, because the second digit is always 0
08:35:39 <maartenm> and the last one is obviously 6
08:35:50 <BONUS> basically you know 2006^(phi(11)) = 1
08:36:09 <BONUS> and then you calculat 2007^2008... `mod` phi(11)
08:36:24 <BONUS> and then you reach something trivial soon enough and you just go back
08:36:39 <Ferdirand> ah, the ^ was right-associative ?
08:36:48 <quicksilver> > a^b^c
08:36:54 <lambdabot>   mueval-core: Prelude.read: no parse
08:36:54 <lambdabot>  mueval: ExitFailure 1
08:37:01 <quicksilver> oh, that doesn't work? shame.
08:37:01 <BONUS> uh wait no
08:37:08 <BONUS> it's left, sorry
08:37:27 <BONUS> ((2006^2007)^2008)^2009
08:37:29 <BONUS> yeah whoops
08:37:31 <BONUS> like that
08:37:32 <dino-> I have recently switched over to Arch. It's unbelievable how all of hackage is in the AUR. Thank you to those who are responsible for this. What a Haskell-friendly distro.
08:38:09 <EvilTerran> BONUS, isn't that just 2006^product[2007..2017]?
08:38:15 <Ferdirand> ah, I messed up then
08:38:21 <maartenm> eh, yeah
08:38:33 <BONUS> hmm
08:38:43 <quicksilver> dino-: mainly dons, I believe :)
08:39:10 <BONUS> wait no, it's just written upwards
08:39:17 <BONUS> sorry, it's right-associative yeah
08:39:19 <BONUS> sure this time
08:39:34 <tomh-> that mapM worked nicely thanks :)
08:39:34 <EvilTerran> > (2^3^4, (2^3)^4, 2^(3^4))
08:39:36 <lambdabot>   (2417851639229258349412352,4096,2417851639229258349412352)
08:40:07 <BONUS> yeah if it's left associative it's just the product, it's right associative then
08:40:08 <EvilTerran> it's usually right-associative, seeing as making it left-associative would make x^y^z = x^(y*z), and you could just write that
08:40:21 <BONUS> yeah then it would be pretty much stupid
08:40:56 <mercury^> EvilTerran: writing x^(y*z) requires parenthesis, just as typing x^(y^z) would.
08:43:15 <EvilTerran> mercury^, but then there's the one set of parens in x^(y0*y1*...*yN) vs N sets of parens in x^(y0^(y1^(...^yN...)))
08:44:06 <erisco> http://pastebin.ca/1489747 this function was designed to calculate the mean of a list. Does it in fact transverse the list twice, once to find the sum and once to find the length, or does it just transverse it once because of lazy evaluation? how can I tell?
08:45:12 <EvilTerran> erisco, that's the classic example where the list gets traversed twice
08:45:28 <erisco> EvilTerran, how do I know this?
08:45:41 <EvilTerran> you can tell by doing leftmost, outermost reduction by hand (or mentally) on an expression
08:46:18 <erisco> EvilTerran, have any tips on how to preform that?
08:46:26 <EvilTerran> listMean xs  -->  Just (sum xs / fromIntegral (length xs))  -->  Just (<evaluation of sum> / ...)  -->  ...
08:47:01 <erisco> EvilTerran, the division forces evaluation of both sides separately?
08:47:34 <EvilTerran> division forces the LHS before the RHS, yes
08:48:16 * EvilTerran can't think of any good reading material wrt evaluating things stepwise by hand
08:48:18 <erisco> okay, and thinking about how it could possibly work, it could either divide each element by the list length (thus calculating the length first then transversing the list for sum)
08:48:26 <erisco> or calculate the sum and transverse the list again to find the length
08:48:35 <erisco> either way its transversing twice, yeah, hmm
08:48:46 <monochrom> Perhaps one day I should write a tutorial on Haskell evaluation.
08:48:50 <EvilTerran> erisco, basically, when trying to evaluate x/y, it'll evaluate x, then y, then work out the result
08:48:55 <erisco> EvilTerran, so the solution then would be to perhaps do a right fold and accumulate the two values?
08:49:21 <EvilTerran> erisco, that'd be the direct approach, yes. there's varying degrees of cleverness possible.
08:49:25 <erisco> monochrom, I got rid of those slow appends from yesterday by changing it to a right fold
08:49:27 <monochrom> I'm currently doing MonadFix and it's more and more fun.
08:50:25 <EvilTerran> erisco, say we ignore the empty list case for simplicity for now, and take "mean xs = sum xs / genericLength xs"
08:50:29 <EvilTerran> ?src genericLength
08:50:30 <lambdabot> genericLength []    = 0
08:50:30 <lambdabot> genericLength (_:l) = 1 + genericLength l
08:50:47 <EvilTerran> hm. ok.
08:51:10 <EvilTerran> erisco, then you could re-write that as an accumulating fold, yes
08:51:30 <dhun> I spend the last month learning haskell, and got the basic concepts, now I am becomming interested in concurrency and functional programming. I am familiar with concurrency in object oriented programming. I found that scale and especially erlang provide means of concurrency, that might be very different form what I know. Do these things exists in Haskell as well or is it better to study them in Erlang or Scala?
08:51:37 <erisco> EvilTerran, using a tuple to keep track of both the length and sum
08:51:44 <EvilTerran> indeed
08:52:06 <EvilTerran> another trick would be to use `par`, although that involves a fairly in-depth understanding of how evaluation works, and is kinda ghc-specific
08:52:37 <erisco> I have no idea how evaluation works evidently so I'll keep it simple
08:52:48 <EvilTerran> which'd be something like "mean xs = sumXs `par` lengthXs `par` (sumXs / lengthXs) where sumXs = sum xs; lengthXs = genericLength xs"
08:53:07 <erisco> I am clinging to folds for everything all of a sudden because they are one of the first concepts that kind of made sense to me :P
08:53:10 <EvilTerran> which'd make the traversals happen in parallel
08:53:51 <erisco> EvilTerran, so you are transversing twice but in two threads?
08:53:57 <EvilTerran> they wouldn't necessarily be progressing completely together, there's no magic to make that happen, they'd just be happening in different threads, yeah
08:54:16 <EvilTerran> although these are userland threads, so relatively low-overhead
08:54:25 <EvilTerran> dhun, haskell has some great concurrency primatives
08:54:51 <EvilTerran> dhun, haskell's restrictions on side-effects make concurrency a lot easier in many ways
08:57:01 <dhun> the wikipedia article on erlangs say : Process communication is done via a shared-nothing asynchronous message passing system: every process has a âmailboxâ, a queue of messages sent by other processes, that are not yet consumed.
08:57:10 <EvilTerran> dhun, we've got Control.Concurrent and Software Transactional Memory, as well as Control.Parallel and Data Parallel Haskell for parallelism
08:57:20 <kynky> thought session types seemed a good way of dealing with concurrency, like the actor concurrency approach too
08:58:06 <dhun> my question is, is there similar mechanism to the one mentioned in the wikipedia article in haskell
08:58:14 <jmcarthur_work> Chan?
08:58:41 <jmcarthur_work> there are also some actor packages, i think
08:58:43 <kynky> stm seems a well documentated way in haskell, rwh has a chapter on it
08:59:06 <erisco> EvilTerran, a problem I have with the new function is while it should only transverse once, it still suffers from stack overflow when given large lists
08:59:09 <jmcarthur_work> stm is shared-memory, but without the common problems of shared memory
08:59:49 <jmcarthur_work> stm is also not yet very fast
08:59:50 <erisco> EvilTerran, which happens on any foldl or foldr... is there no way to make this not overflow the stack such as how  I would have used a loop in imperative?
09:00:04 <hzap> erisco: use foldl'
09:00:11 <kynky> actor erlang way is in articles on net, and pdfs. but from what i read because of way haskell is, session types seemed better than actor method, because of way of getting right posted messages, session types hae a kind of contract
09:00:13 <EvilTerran> erisco, i think you may need foldl'
09:00:14 <quicksilver> dhun: Chan has the same general semantics as erlang messages
09:00:14 <Cale> dhun: You might have a bit of a hard time ensuring that nothing is shared between a set of threads.
09:00:18 <EvilTerran> which is stricter
09:00:21 <quicksilver> but, it's not shared-nothing.
09:00:25 <Cale> dhun: But certainly we can do mailboxes.
09:00:26 <EvilTerran> but you may need even more than that
09:00:27 <quicksilver> in terms of technical implementation dertails.
09:00:55 <kynky> full sessions is in hackage, and bsd3
09:01:02 <erisco> EvilTerran, sorry, what do you mean by foldl'? this isn't a function I have defined...
09:01:05 <dhun> which looks particularly charming to me is that threads continue when data is available for them
09:01:14 <dhun> so can sleep on a condition
09:01:14 <jmcarthur_work> Cale, why would it be so hard to not share data among threads?
09:01:16 <hzap> @hoogle foldl'
09:01:16 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
09:01:17 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
09:01:17 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
09:01:35 <erisco> @src foldr'
09:01:36 <lambdabot> Source not found. You untyped fool!
09:02:09 <kynky> share data is bad i thought, messaging sounds better, i hate deadlock potential
09:02:17 <jmcarthur_work> i mean, there's sharing in the pure sense, but erlang really does that too. on a semantic level that is not the same as shared mutable data
09:02:35 <Cale> jmcarthur_work: It's hard to *ensure* it, because threads are in IO and can use IORefs.
09:02:53 <erisco> hzap, I don't really know what any of that means :P
09:02:54 <jmcarthur_work> Cale, ah. well, we could have the same problem in erlang then
09:03:05 <quicksilver> kynky: There are no deadlocks in correctly used Chans.
09:03:05 <dhun> is there any text on tutorial on Chan
09:03:12 <kynky> having one thread dealing with writes to db, other threads commuicate wioth that thread, instead of writing to db directly, just more control
09:03:24 <Zao> dhun: How about pathological horrible performance?
09:03:40 <jmcarthur_work> i think concurrency is too often misused
09:03:50 <hzap> ericso: foldl' is like foldl, except it forces the evaluation of the accumulator value while looping, so it doesn't stack overflow
09:03:52 <jmcarthur_work> overused, too
09:04:26 <EvilTerran> erisco, it's in Data.List
09:04:27 <kynky> quicksilver, mean the deadlocks which arise from doing things badly, sometimes it better to have an architecture which inherently has more protection, stm and actor/erlang seem good, session types seem to me , actor but more stricter
09:04:33 <dhun> Zao, so you say concurrency is slow in Haskell?
09:04:38 <jmcarthur_work> parallelism is the way to multicore. concurrency is just a control flow abstraction, which we arguably want to avoid in a declarative language anyway
09:04:42 <EvilTerran> erisco, you can get at it with "import Data.List (foldl')" at the top of a .hs file
09:04:42 <Zao> dhun: I'm saying that STM is no silver bullet.
09:04:49 <erisco> hzap, oh, okay. I'll make note that that is what causes the overflow
09:04:52 <jmcarthur_work> stm *is* slow
09:04:52 <kynky> haskell, imho is best for concurrency, threads are super light weight
09:04:54 <EvilTerran> ?src foldl
09:04:54 <erisco> EvilTerran, thanks
09:04:54 <dhun> what does STM mean
09:04:54 <lambdabot> foldl f z []     = z
09:04:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:04:55 <EvilTerran> ?src foldl'
09:04:56 <lambdabot> foldl' f a []     = a
09:04:56 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:04:57 <jmcarthur_work> mvars are crazy fast though
09:05:10 <Cale> dhun: Software transactional memory
09:05:25 <kynky> j2ee , basically stm
09:05:26 <quicksilver> dhun: No.
09:05:31 <Cale> I don't think that STM is necessarily slow, just that GHC's implementation of it is relatively slow.
09:05:33 <quicksilver> dhun: "Correctly used Chan" *is* an architecture.
09:05:39 <erisco> EvilTerran, I actually want a foldr', that exists too right?
09:05:51 <quicksilver> dhun: and it is inherently deadlock free.
09:05:53 <kynky> just dont have long running transactions, where lots of data change, rollback is bad, but all in design
09:06:05 <jmcarthur_work> dhun, STM is a shared-memory concurrency paradigm in which you modify shared data atomically, so it's always in a consistent state and doesn't suffer from deadlock unless you do something really really horrible
09:06:05 <quicksilver> dhun: it's just as much a deadlock-free design as any other.
09:06:09 <Cale> It's one of those things like garbage collection where the compilers start out doing it worse than the humans, but the abstraction is in place.
09:06:15 <EvilTerran> erisco, er, the added strictness doesn't really make sense for a foldr, for rather complicated reasons
09:06:28 <erisco> EvilTerran, so it does not exist?
09:06:36 <erisco> EvilTerran, how do I fix my stack overflow then?
09:06:40 <EvilTerran> ?hoogle foldr'
09:06:41 <lambdabot> Data.ByteString foldr' :: (Word8 -> a -> a) -> a -> ByteString -> a
09:06:41 <lambdabot> Data.Foldable foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
09:06:41 <lambdabot> Data.ByteString.Char8 foldr' :: (Char -> a -> a) -> a -> ByteString -> a
09:07:01 <EvilTerran> ?type Data.List.foldr'
09:07:01 <kynky> quicksilver, i would say its better at preventing deadlock than other designs, but it can be used badly
09:07:04 <lambdabot> Not in scope: `Data.List.foldr''
09:07:04 <dhun> that seems good, I experienced deadlooks and inconsitent states in other languages
09:07:10 <EvilTerran> erisco, it seems to not exist
09:07:32 <quicksilver> kynky: I don't understand your point.
09:07:35 <EvilTerran> erisco, can you write your accumulating fold as a foldl?
09:07:40 <quicksilver> kynky: deadlocks are impossible. They cannot exist.
09:07:47 <quicksilver> kynky: how is that merely "better at preventing"
09:07:48 <jmcarthur_work> it's possible to make STM deadlock, but i have never run into that in practice. only in proof on concepts
09:07:49 <Cale> erisco: what are you computing?
09:07:54 <quicksilver> kynky: it is the complete absence of deadlocks.
09:07:56 <kynky> <quicksilver> dhun: it's just as much a deadlock-free design as any other.
09:07:58 <erisco> EvilTerran, yes
09:08:08 <EvilTerran> Cale, good ol' (\xs -> sum xs / genericLength xs)
09:08:12 <jmcarthur_work> *proof of concepts
09:08:32 <quicksilver> jmcarthur_work: well that's a bit of a fiddly issue. There was a discussion on one of the mailing lists recently.
09:08:33 <Cale> EvilTerran: ah
09:08:40 <quicksilver> jmcarthur_work: there is a useful sense in which STM is deadlock-free
09:08:42 <kynky> could you not have it so it always is rolling back ?
09:08:45 <jmcarthur_work> quicksilver, agreed
09:09:00 <Cale> erisco: maybe try   foldl' (+) 0 xs / fromIntegral (length xs)
09:09:14 <quicksilver> kynky: one transaction always makes progress
09:09:19 <EvilTerran> Cale, ISTR you do a better job than i at explaining evaluation order, maybe you'd have something to add that might help erisco more than i can
09:09:26 <erisco> EvilTerran, I still stack overflowed
09:09:50 <jmcarthur_work> ugh, i'm not doing work. i should leave irc for now.
09:09:54 <kynky> is that a garentee ?
09:10:04 <EvilTerran> erisco, what, with the foldl' accumulating a pair?
09:10:06 <erisco> Cale, would that not transverse the list twice as well?
09:10:13 <erisco> EvilTerran, well, that is what I have now
09:10:20 <Cale> erisco: Yeah, but that's not a big deal.
09:10:32 <monochrom> http://www.haskell.org/haskellwiki/Stack_overflow
09:10:33 <Cale> erisco: How long is the list?
09:10:38 <erisco> http://pastebin.ca/1489783
09:10:46 <erisco> Cale, 1000000
09:10:52 <Cale> Oh, I suppose we don't want to keep it in memory.
09:11:31 <erisco> I am just not sure what the logical thing is behind Haskell if we actually needed the average of 1..1000000
09:11:34 <Cale> It's possible to write a little accumulator which is strict and computes both sum and length at once
09:11:49 <erisco> Cale, I tried that, I pastebinned it
09:11:59 <Cale> okay, I'll look
09:12:13 <Cale> ah, okay
09:12:15 <dhun> so you can just operate on getChanContents like on a usual list, and you will go to sleep if the queue runs empty and wake up when it becomes full. An the sleep will be handled by the system?
09:12:29 <Cale> your problem is that evaluating a pair doesn't force the evaluation of its parts
09:12:56 <erisco> Cale, is there some syntax I can use to force evaluation?
09:13:00 <Cale> erisco: So you need step to ensure that before it puts sum+x and len+1 in the pair
09:13:05 <Cale> it evaluates each
09:13:15 <Cale> To do that, you use the primitive seq
09:13:19 <Cale> seq :: a -> b -> b
09:13:28 <EvilTerran> erisco, the fundamental problem is that, as the foldl traverses the list, sum and len don't get forced at all
09:13:42 <Cale> What it means is that seq x y will ensure that x is evaluated before the result of y is made available.
09:13:54 <EvilTerran> erisco, so the unevaluated expressions for sum and len get bigger linearly in the length of the list, 'til it overflows
09:14:10 <EvilTerran> erisco, hence all this need for faffing around with `par` and foldl' and whatnot
09:14:26 <Cale> Well, 'til you look at them at the end and have to walk all the way down to the innermost addition -- which is when your stack overflows
09:14:28 <EvilTerran> er, s/par/seq/
09:14:37 <erisco> EvilTerran, Cale, so if I force the evaluation with seq, I still need the strict foldl' yes?
09:14:43 <Cale> erisco: yeah
09:14:55 <Cale> erisco: The foldl' will make sure that step gets evaluated
09:15:05 <Cale> erisco: and then step will ensure that sum and len are evaluated
09:15:05 <EvilTerran> erisco, yeah, you need the foldl' to force the pair, and then `seq` to force the parts of the pair whenever the pair itself gets forced
09:15:25 <Cale> If you turn on the BangPatterns extension, you can just write:
09:15:35 <Cale> step (!sum,!len) x = (sum+x,len+1)
09:15:59 <Cale> That means "make sure that sum and len are evaluated when you match the pattern"
09:16:25 <Cale> To turn that extension on, you can write
09:16:35 <Cale> {-# LANGUAGE BangPatterns #-} at the top of your file
09:16:47 <erisco> Cale, it seems that while lazy evaluation is useful, sometimes you do not want it, yes? would you recommend bang patterns?
09:17:10 <lilac> @quote gwern stricter
09:17:11 <lambdabot> gwern says: the best way to optimize a program is to make it lazier or stricter.
09:17:18 <monochrom> haha
09:17:19 <Cale> Right, these cases where you're collapsing a large data structure, with lots of separate parts down into something small with few parts are where you want to make things strict.
09:17:40 <Cale> and I normally would recommend bang patterns since they're pretty
09:17:45 <Cale> But you can do without:
09:18:01 <Cale> step (sum,len) x = sum `seq` len `seq` (sum+x,len+1)
09:18:11 <Cale> That's the same thing
09:18:21 <lilac> Cale: do you think it's reasonable to say that catamorphisms should usually be strict but anamorphisms should usually be lazy?
09:18:29 <monochrom>  ! pattern is a dual of ~ pattern.
09:18:39 <EvilTerran> or "data StrictPair a b = !a :*: !b", then "step x (sum :*: len) = (sum+x, len+1)"
09:18:49 <Cale> lilac: no, actually :)
09:18:51 <EvilTerran> er, (sum+x :*: len+1)
09:19:04 <monochrom> foldr is a catamorphism and you want foldr (:) lazy.
09:19:06 <Cale> lilac: It depends on the parameters you're passing to the catamorphism
09:19:21 <lilac> step (sum, len) x = (len `seq` sum + x, sum `seq` len + 1)
09:19:23 <Cale> lilac: catamorphisms don't always collapse things :)
09:19:37 <Cale> lilac: fail.
09:19:40 <lilac> Cale: fair point ;-)
09:19:46 <monochrom> Cale's "collapsing large to small" is the necessary and sufficient condition.
09:19:49 <erisco> Cale, it no longer overflows :D
09:19:57 <Cale> erisco: great :)
09:20:01 <lilac> Cale: fail?
09:20:06 <erisco> Cale, mind you, it still takes a while
09:20:18 <monochrom> foldr/foldl, cata/ana, ... those are orthogonal.
09:20:39 <Cale> lilac: That's an interesting choice of place to put the seqs, but... I don't think it actually helps, does it?
09:20:49 <Cale> Maybe...
09:20:58 <lilac> Cale: if + is strict then it should do the job
09:21:06 <lilac> (i think)
09:21:23 <Cale> The problem is that the components of the pair will not be evaluated at all
09:21:39 <Cale> So you're going to get a big deep expression with lots of intermittent seqs in it
09:22:06 <lilac> Cale: wow, i'm wrong twice in 5 minutes :) this is why i love #haskell
09:22:25 <monochrom> It is so complicated that it does not have an obvious problem.
09:23:08 <Cale> monochrom: well, foldr is a catamorphism... maybe it's sitting at the origin? ;)
09:24:33 <monochrom> I mean {foldr/foldl, cata/ana, ...} is orthogonal to eager/lazy. eager/lazy = collapse/explode
09:25:14 <Cale> ah
09:25:45 <lilac> in what cases is a lazy foldl appropriate?
09:25:58 <monochrom> Very rare. I can't think of one.
09:26:13 <monochrom> Perhaps foldl (&&) and foldl (||)
09:26:38 <monochrom> No, not even them.
09:26:52 <Cale> reverse
09:27:08 <Cale> (though that's not a big deal)
09:28:04 <Cale> The cases where you want lazy foldl are ones where you really want a left-associated expression of the elements of your list, but that the function you're passing might not always use its first parameter.
09:28:19 <lilac> it's not clear to me why lazy reverse is  better than a spine-strict reverse
09:28:31 <peaker_> @src foldl
09:28:31 <lambdabot> foldl f z []     = z
09:28:32 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:28:34 <Cale> Maybe you save some time
09:28:49 <sm> does the utf8-light package have any advantages over utf8-string ?
09:28:59 <peaker_> if f doesn't use its first arg -- how does it help?
09:29:01 <lilac> you're either building lists or thunks; it seems pretty even
09:29:10 <sm> and, are both superseded by text ?
09:29:32 <erisco> I have got a really weird problem (from what I know)
09:29:41 <Cale> peaker_: then foldl f z [1,2,3,4,5] might get as far as f (...) 5  and stop.
09:29:59 <Cale> peaker_: (producing a result without evaluating the thing in the (...)
09:30:16 <Cale> It's important if f is somehow expensive
09:30:44 <quicksilver> > foldl (flip (&&)) True [undefined,False]
09:30:45 <lambdabot>   False
09:30:46 <erisco> what is going on here: http://pastebin.ca/1489801
09:30:48 <peaker_> Ah, so you get to avoid actually computing the previous accumulators maybe
09:30:58 <quicksilver> Cale: ^^ there is an example of a lazy foldl in use
09:30:58 <Cale> peaker_: yeah
09:31:01 <quicksilver> pretty contrived.
09:31:05 <lilac> > let f _ 5 = True in foldl f 0 [undefined, undefined, undefined, undefined, 5]
09:31:06 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
09:31:07 <lambdabot>    arising from the literal `0'...
09:31:18 <lilac> > let f _ 5 = 1 in foldl f 0 [undefined, undefined, undefined, undefined, 5]
09:31:20 <lambdabot>   1
09:31:46 <Cale> erisco: ugh, different instances of Enum
09:31:50 <peaker_> (:) is really cheap, so why is reverse foldl and not foldl'?
09:31:55 <peaker_> @src reverse
09:31:56 <lambdabot> reverse = foldl (flip (:)) []
09:32:07 <Cale> erisco: That's a little bug in the specification of Enum for Float/Double
09:32:31 <Cale> > [1,6..89] :: [Double]
09:32:32 <lambdabot>   [1.0,6.0,11.0,16.0,21.0,26.0,31.0,36.0,41.0,46.0,51.0,56.0,61.0,66.0,71.0,7...
09:32:36 <lilac> peaker_: i was wondering that. i guess profiling it might give an answer?
09:32:37 <Cale> > drop 10 [1,6..89] :: [Double]
09:32:38 <lambdabot>   [51.0,56.0,61.0,66.0,71.0,76.0,81.0,86.0,91.0]
09:32:48 <Cale> That 91 is ridiculous
09:33:03 <peaker_> lilac, maybe (:) is cheap, but N calls to (:) are expensive
09:33:13 <peaker_> as opposed to N thunk buildups
09:33:27 <erisco> Cale, that 91 is ridiculous... 43.5 is the correct answer
09:33:42 <erisco> Cale, so the fact that I get 46 is a bug?
09:33:55 <lilac> peaker_: why would building N thunks be cheaper than building N (:)s?
09:34:12 <Cale> erisco: yeah, in the way that [n,m..k] syntax is defined for Float/Double
09:34:20 <peaker_> lilac, Implementation artifacts perhaps
09:34:45 <Cale> erisco: You can avoid the problem though...
09:35:00 <lilac> peaker_: i'd guess there's little in it, and the stricter reverse would be cheaper in the case where you actually want to use the result
09:35:15 <lilac> peaker_: but equally i guess there's some key difference i'm missing
09:35:25 <Cale> erisco: one way is to generalise listMean so that it can take a list of any type of number, and then make sure if gets a list of Integers (or rely on defaulting)
09:35:44 <Cale> erisco: change sum+x to sum+(fromIntegral x)
09:36:04 <Cale> mm...
09:36:34 <erisco> Cale, it seems to give me the right answer now
09:36:41 <Cale> Actually wrong suggestion (but that would work)
09:36:56 <erisco> Cale, what should I do instead?
09:37:58 <Cale> hmm... actually, I suppose that's the easiest thing. You can cut down on the complexity though by applying it to sum at the end (after the addition)
09:38:19 <Cale> That is, make it  Just (fromIntegral sum / len)
09:38:40 <Cale> That way you only convert once, rather than at each number
09:39:00 <sm> no: I think text does not supersede utf8-string/utf8-light/compact-string, because unlike those it does not do I/O
09:39:27 <Cale> erisco: It actually makes things less general that way though
09:39:39 <Cale> erisco: another way: just give an explicit type to the list
09:39:51 <lilac> Cale: wouldn't that give it the rather odd type of '(Integral a, Num b) => [a] -> b'?
09:39:51 <Cale> listMean ([1,6..89] :: [Integer])
09:39:56 <Cale> lilac: yeah
09:40:20 <lilac> I'd have thought you'd want '(Fractional a) => [a] -> a'
09:40:23 <dschoepe> I'm getting this error when trying to cabal-install taglib: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6751#a6751
09:40:27 <erisco> Cale, that resulting type is not desirable?
09:40:32 <Cale> er, but that won't work, since you'd need to convert :)
09:40:52 <lilac> Cale: that seems to be The Haskell Way for numeric stuff AFAICS :-/
09:40:59 <Cale> It's annoying anyway. The right solution is for that bug to get fixed.
09:41:22 <erisco> Cale, if I want to average a list of fractionals, can I do that?
09:41:22 <Cale> Unfortunately, it's a bug in the Haskell 98 specification
09:41:39 <lilac> on the plus side it means you don't need so many type annotations
09:42:09 <Cale> erisco: yeah, that's the problem, adding that fromIntegral was a trick to make sure that your list would be integer-like to begin with
09:42:35 <erisco> Cale, so overall there is no good solution, just a bug that needs to be fixed
09:42:37 <Cale> erisco: so you probably don't really want to do that
09:42:50 <Cale> You probably just want to generate the list you really want
09:43:10 <Cale> listMean (map fromIntegral [1,6..89]) ought to work with the original listMean
09:43:10 <monochrom> @type realToFrac
09:43:12 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
09:43:17 <erisco> Cale, can I force [n,m..k] to evaluate?
09:43:42 <Cale> erisco: The problem isn't with evaluation, it's with the compile-time selection of which function that is based on the inferred type
09:43:44 <lilac> > let listMean xs = fromIntegral (sum xs) / fromIntegral (length xs) in listMean [1..10]
09:43:46 <lambdabot>   5.5
09:44:24 <erisco> > let listMean xs = fromIntegral (sum xs) / fromIntegral (length xs) in listMean [1.5,2.5,3.5]
09:44:26 <lambdabot>   Add a type signature
09:44:39 <Cale> erisco: If you really cared strongly about performance, you'd end up just implementing a correct version of it for Double
09:44:56 <erisco> Cale, there is something I am not doing optimally for Doubles?
09:45:23 <Cale> erisco: But we can get around the problem by starting with a list of Integers (since the syntax works correctly for integers) and converting it to a list of Doubles with map fromIntegral
09:45:23 <lyndon> is there a way to do multi-line numbers in haskell?
09:45:28 <erisco> Cale, or you are saying to get around the bug I would make a separate function?
09:45:34 <Cale> erisco: yeah
09:45:51 <Cale> erisco: that is, if you really cared a whole lot about efficiency
09:45:58 <Cale> erisco: But try the cheesy way first
09:46:06 <quicksilver> mmm cheese.
09:46:09 <Cale> listMean (map fromIntegral xs)
09:46:10 <erisco> Cale, I will just leave it as-is
09:47:05 <erisco> Cale, that trick is sufficient enough :)
09:47:12 <Cale> erisco: the function with the bug is called enumFromThenTo
09:47:33 <Cale> and [1,6..89] desugars into enumFromThenTo 1 6 89
09:47:36 <dschoepe> What can I do against this error when running `cabal install taglib': http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6751#a6751
09:47:42 <Cale> :t enumFromThenTo
09:47:44 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
09:47:57 <Cale> since it's part of the Enum class, it's defined separately for each type a
09:48:11 <Cale> which is why you can write things like
09:48:18 <Cale> > ['a','c'..'z']
09:48:19 <pikhq> let enumFromThenTo = [1] in [2,3..4]
09:48:19 <lambdabot>   "acegikmoqsuwy"
09:48:59 <pikhq> > let enumFromThenTo _ _ _ = [1] in [2,3..4]
09:49:00 <lambdabot>   [2,3,4]
09:49:16 <pikhq> Aaaw. No stupid tricks with that.
09:49:24 <Cale> pikhq: okay, it actually desugars into Prelude.enumFromThenTo ;)
09:49:45 <doserj> dschoepe: did you install the development package for TagLib?
09:49:53 <pikhq> Cale: So I'd need to be a bit more clever to do stupid tricks with that, then.
09:49:59 <pikhq> Too much trouble. ;)
09:50:01 <Zao> Ooh. Happstack builds and runs on Windows nowadays. Neat.
09:50:29 <dschoepe> doserj: no
09:50:47 <doserj> dschoepe: then fix that :)
09:50:48 <Cale> pikhq: I think there's a flag or extension you can turn on to make the syntax refer to the local module.
09:50:57 <Cale> pikhq: For if you want to make your own Prelude.
09:51:15 <dschoepe> doserj: Hmm, taglib-0.1.1 is listed in ghc-pkg list though
09:52:41 <doserj> dschoepe: check if it actually works, first.
09:52:56 <pikhq> Cale: Too much effort for making [2,4..8] show up as [1,3,5,7] or something. ;)
09:53:35 * edwardk waves hello
09:54:13 <dschoepe> doserj: ghci complains about missing files when loading a file with "import Sound.TagLib"
09:54:20 <dschoepe> I'll try the git version now
09:54:30 <thomastc> hmm, an interesting bikeshed discussion on haskell-cafe
09:54:37 <thomastc> but a very important bikeshed it is too
09:55:36 <dschoepe> doserj: I unregistered the package and deleted taglib in .cabal/lib and tried with the git version: Still the same error
09:55:46 <Cale> thomastc: what is it about?
09:55:53 <erisco> @src reverse
09:55:54 <lambdabot> reverse = foldl (flip (:)) []
09:55:55 <thomastc> the haskell.org front page
09:56:15 <Cale> thomastc: Oh, I thought it would be about something like language syntax ;)
09:56:53 <dschoepe> doserj: Hmm, it might have to do with me using the darcs version of cabal-install, I'll try with the released one
09:58:23 <tommd> @quote
09:58:24 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:58:31 <tommd> damn you lambdabot
10:01:25 <erisco> Cale, to me it is not just about writing optimized code, it is trying to write robust and good code... I don't know how well off I'd be without any clue as to how things are being evaluated and what consequences there are
10:01:53 <Cale> erisco: well, if the computations get very large you want to be careful
10:02:17 <Cale> It's possible to get a good feel for the evaluation order and mechanism for when you need it
10:02:29 <dschoepe> doserj: It was indeed the darcs version of cabal-install that caused it. I'll try to track to down why that happens though
10:02:32 <Cale> If you compile with optimisations, it will also often catch a lot of things
10:02:34 <erisco> Cale, I progressed from a function that was O(2n) and suffered from stack overflows to a function that is O(n) and does not
10:02:50 <jeffwheeler> What's it called when there's a type (or data?) definition within a typeclass?
10:02:51 <erisco> Cale, is that not a good thing?
10:03:03 <Cale> erisco: btw, O(2n) is the same class of functions as O(n), just to be annoying ;)
10:03:12 <erisco> Cale, I know
10:03:20 <Cale> But yeah, I know what you mean
10:03:23 <jeffwheeler> I can't seem to remember the syntax for something like this, but I think I remember seeing it: class T a where type d :: a -> String
10:03:29 <jeffwheeler> Err, 'type D'
10:03:48 <Cale> erisco: actually more important is that your final program runs in (roughly) constant space
10:04:09 <erisco> Cale, http://pastebin.ca/1489838 see I even noted for myself why the changes helped
10:04:25 <erisco> Cale, well, functions that suffer from stack overflows surely do not run in constant space
10:04:37 <Cale> erisco: right.
10:04:46 <Cale> erisco: because they build big expressions on the heap
10:04:50 <erisco> Cale, I am not sure if my final function runs in constant space and I am not sure how to tell. can you profile memory usage?
10:04:50 <wli> 2*n + O(1)?
10:05:05 <Cale> erisco: yep
10:05:29 <Cale> erisco: Compile with -prof -auto-all and then run the program with +RTS -hc
10:05:45 <Cale> you'll find that it produces a .hp file with lots of numbers in it
10:05:47 * wli prefers additive asymptotics.
10:05:58 <Cale> you can then use hp2ps to get a nice postscript graph of memory usage
10:06:12 <jmcarthur_work> it's unfortunate that the transformed version is not a composition of sum and length
10:06:14 <erisco> Cale, I will keep that in mind
10:07:01 <wli> Usually space is O(something) too.
10:07:04 <Cale> jmcarthur_work: yeah
10:07:38 <Cale> jmcarthur_work: I saw an interesting approach to that which involved redefining sum and length to be a different sort of thing, but it was nicely composable
10:07:58 <jmcarthur_work> Cale, do recall where it was?
10:08:10 <Cale> I don't remember whose blog.
10:08:17 * jmcarthur_work googles
10:08:42 <Cale> I believe the trick was to define sum and length as the bits which you'd apply a fold to in order to get an actual function
10:08:49 <erisco> jmcarthur_work, Cale, is this composition stuff something I should know by now?
10:08:54 <Cale> and then you can compose those bits
10:09:03 <Cale> erisco: composition of functions?
10:09:26 <Cale> erisco: Well, jmcarthur_work in this context just means that you didn't end up actually using the library functions sum and length
10:09:42 <Cale> erisco: which is unfortunate... there ought to be a way in an ideal world :)
10:09:44 <erisco> Cale, is that saying that originally it was a composition of sum and length by the fact it was sum xs / (length xs) ?
10:09:48 <paggas> in ghc, how can i run an external program (giving its command line) and get its stdin/out/err/etc as handles?
10:09:49 <Cale> yeah
10:10:08 <erisco> Cale, why is this unfortunate?
10:10:09 <jmcarthur_work> erisco, the "haskell way" is to compose functions that do simpler things rather than inlining them
10:10:12 <Cale> erisco: In an ideal world, that would produce efficient code, and you'd have nothing to worry about
10:10:43 <erisco> Cale, the original sum / length? ah
10:11:07 <jmcarthur_work> for the record, sum works great with optimizations. no stack overflow
10:11:23 <jmcarthur_work> no help from its lazy definition, though
10:11:31 <Cale> erisco: the tricky part, more than anything else, is how xs appears twice. In order to make things efficient, you have to do both operations at once so that xs isn't computed and stored in memory waiting for the second part to begin.
10:12:10 <erisco> Cale, which is what I am doing by "inlining" them, then, yes?
10:12:17 <Cale> yeah
10:12:36 <Cale> you're sort of inlining the definitions of sum and length and combining them together
10:12:48 <erisco> maybe someone can write up a new feature for the compiler that spots cases where functions can be inlined
10:12:51 <jmcarthur_work> erisco, we do have rather general ways to compose such things such that the compiler can fuse them into just one loop
10:13:12 <jmcarthur_work> rewrite rules, stream fusion, etc.
10:13:18 <Cale> erisco: There's already quite a lot of transformation and inlining, but it doesn't cover this
10:13:23 <jmcarthur_work> but these only apply for certain cases
10:13:24 <Saizan> jmcarthur_work: they don't work in this particular case
10:13:27 <jmcarthur_work> right
10:13:57 <Saizan> this is a nice example for attribute grammars
10:14:04 <erisco> well I am going for lunch, then I will work through the rest of the exercises I missed in chapter 3
10:14:10 <Saizan> but the overhead to using them is still a bit high
10:14:32 <sm> does anyone know of code which uses utf8-string's UTF8 String type ? I can't figure it out
10:15:23 <sm> this one: http://hackage.haskell.org/packages/archive/utf8-string/0.3.5/doc/html/Data-String-UTF8.html#t%3AUTF8
10:18:05 <Saizan> sm: what are you trying to do with it?
10:18:38 <sm> Saizan: well, eg I tried let s = "a" :: UTF8 String
10:18:49 <sm> I'm trying to see fromString & toString at work
10:19:28 <Saizan> use let s = fromString "a" :: UTF8 String, then
10:19:46 <Saizan> it doesn't look like there's an instance of IsString for it
10:20:53 <sm> that doesn't work. I can get a UTF8 String with  let utf8s = fromRep "a"
10:21:07 <sm> but can't figure out how to do anything with it.
10:21:11 * sm struggles
10:21:59 <lilac> sm: what do you want to do with it?
10:22:26 <Saizan> sm: oh, right
10:22:36 <Saizan> sm: there isn't an instance for [Char]
10:22:41 <Saizan> sm: but one for [Word8]
10:22:55 <sm> I want to understand what Data.String.UTF8 can do for me.. then maybe use it to fix a non-utf8-aware error message in my app
10:23:53 <Saizan> the UTF8 string type is a type of utf8 encoded strings that's parametrized on the underlying container of bytes
10:24:02 <sm> I've fixed most output by using System.IO.UTF8.putStrLn. But now, the output comes via a fail in a parsec parser. Not sure how to handle that one.
10:24:21 <Saizan> you can use UTF8 [Word8], UTF8 L.ByteString, UTF8 B.ByteString
10:24:28 <lilac> sm: try 'let s = fromString "a" :: UTF8 ByteString'
10:24:32 <sm> Saizan: I see
10:24:42 <lilac> @index ByteString
10:24:43 <lambdabot> bzzt
10:25:09 <lilac> import Data.ByteString first, though
10:25:43 <Saizan> you should decode from utf8 right at the start, before feeding your input to parsec, probably
10:26:05 <sm> lilac: thanks, that works too. I get it, the container can't be just a regular String
10:26:34 <sm> Saizan: ah, that seems like a good idea
10:27:48 <bgs100> What exactly is cabal?
10:28:05 <tommd> bgs100: A library for managing Haskell packages and their dependencies.
10:28:15 <Heffalump> well, it's several things, centred around that library
10:28:27 <Saizan> Cabal is that library + a simple build system
10:28:31 <tommd> bgs100: Also, "cabal" is the name of the executable for the program in the "cabal-install" package.
10:28:42 <Heffalump> it's a description language for packages to define their metadata (dependencies, name ,author etc)
10:28:46 <Saizan> cabal-install is a command line tool to fetch and install packages from hackage
10:29:03 <Heffalump> confusingly, cabal-install provides a binary called 'cabal'
10:29:09 <Heffalump> whereas for the library you need the Cabal package
10:29:33 <tommd> bgs100: The cabal-install program can be used to, yeah - what Saizan said.  The really useful thing is it automatically downloads and installs the needed dependencies for your selected package (much like yum or apt-get).
10:29:47 <bgs100> Sort of like the lisp asdf-install package?
10:30:09 <tommd> bgs100: But it will only work for _haskell_ deps.  Any c-libraries you need to download and install via what ever platform-specific mechanisms you have.
10:30:48 <sm> Saizan: I seem to be already doing that though.. I parse data read with System.IO.UTF8.readFile
10:30:56 <tommd> bgs100: I can't comment on that comparison.
10:38:54 <lilac> tommd: how confusingly paradoxical
10:39:05 <tommd> how so?
10:39:15 <lilac> your comment is that you can't comment ;-)
10:39:40 <tommd> Yeah, I was kind of hoping a lisper would jump in after seeing such an empty statement... it was not to be.
10:40:34 <saml> > cabal install *
10:40:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:44:16 <bgs100> I was running bootstrap.sh, and had gotten pretty far, but then:
10:44:27 <bgs100> Configuring HTTP-4000.0.4...
10:44:27 <bgs100> Setup: At least the following dependencies are missing:
10:44:27 <bgs100> mtl -any
10:45:15 <tommd> bgs100: mtl is a common library (but not in base)
10:45:40 <tommd> bgs100: If you installed the debian package then you probably need a "ghc6-lib-mtl" package
10:46:11 <tommd> bgs100: imho, that should be included when you install GHC, but it isn't which leaves people with this issue.
10:47:17 <tommd> bsg100: Sorry if you already know this, but if worse comes to worse you can always install it manually (by downloading it from hackage.haskell.org and going through a couple steps).
10:47:17 <jeffersonheard> hehe.  added a video to my latest post about force-directed layouts showing particles swarming around a attractors laid out along the shape of a lambda...
10:47:27 <bgs100> Okay, thanks. But atptiude search, rather than revealing "ghc6-lib-mtl", shows "libghc6-mtl-dev" (which follows the same naming convention as the parsec and network debian packages)
10:47:39 <tommd> bgs100: Ok, thats it then.
10:47:44 <saml> jeffersonheard, link?
10:51:12 <bgs100> Yay! bootstrap.sh finished without error :D
10:54:14 <mightybyte> Any idea why I get "no package matching `network-2.2.1' was found" even though I actually have network-2.2.1.3 installed?
10:54:29 <mightybyte> ...while building another project that depends on network.
10:55:34 <tommd> mightybyte: Does the package dep say == 2.2.1?  If so, 2.2.1.3 wouldn't match, unfortunately.
10:56:12 <mightybyte> tommd: No, it says "network >= 2.2 && < 3"
10:56:56 <tommd> mightybyte: also, network 2.2.1 is a conflicted version - the one that came with GHC and the official 2.2.1 differ.  Its a terrible thing.
10:57:06 <tommd> Humm, not sure what this issue is in that case.
10:57:42 <bgs100> cabal won't install leksah, although I see it on hackage... :P Also, it says "Warning: No remote package servers have been specified. Usually you would have<newlinehere>one specified in the config file."
10:57:51 <mightybyte> tommd: I just reinstalled network with -p because I'm trying to do some profiling.  Would that have anything to do with it?
10:57:57 <tommd> bgs100: You probably need "cabal update"
10:58:06 <bgs100> tommd, I did
10:58:16 <tommd> bgs100: So it starts installing and fails on something?
10:58:27 <bgs100> No, it says it can't find the package
10:58:47 <tommd> mightybyte: Perhaps if you have some diamond dep going on - not sure.
10:58:52 <Saizan> bgs100: you ran "cabal update" and then "cabal install leksah" ?
10:59:01 <bgs100> Saizan, Yes
10:59:09 <jeffersonheard> http://vis.renci.org/jeff/2009/07/09/an-ugly-force-directed-layout-implementation/
10:59:11 <bgs100> On update, it just gave the warning
10:59:20 <Saizan> bgs100: do you have a ~/.cabal/config file?
10:59:23 <bgs100> On install attempt, it gave the warning, then
10:59:28 <kyagrd> I've also never succeded installing leksah because of some dependency problem.
10:59:29 <bgs100> cabal: There is no package named leksah
10:59:54 <bgs100> Saizan, Yes. I have the bin linked to my ~/bin
10:59:59 <tommd> kyagrd: I've installed leksah via cabal-install so I know it can be done.  Can't recall if I ran into any issues.
11:00:10 <Saizan> bgs100: i'm not talking about bins
11:00:20 <Saizan> bgs100: i'm talking about a textual file
11:00:29 <kyagrd> kyagrd@kyavaio:~/autocert/system/certify/provers/axioms$ cabal install leksah
11:00:29 <kyagrd> Resolving dependencies...
11:00:29 <kyagrd> cabal: dependencies conflict: ghc-6.10.3 requires Cabal ==1.6.0.3 however
11:00:30 <kyagrd> Cabal-1.6.0.3 was excluded because Cabal-1.6.0.1 was selected instead
11:00:30 <kyagrd> Cabal-1.6.0.3 was excluded because leksah-0.4.4.1 requires Cabal ==1.6.0.1
11:00:30 <jeffersonheard> it's not a terribly *good* lambda, but for 10 minutes of coding it's not bad
11:00:30 <kyagrd>  
11:00:32 <bgs100> I know. That's just all there is in my ~/.cabal/config
11:01:08 <kyagrd> kyagrd@kyavaio:~/autocert/system/certify/provers/axioms$ ghc-pkg list|grep Cabal    ALUT-2.1.0.2, Cabal-1.6.0.3, HGL-3.2.0.0, HUnit-1.2.0.3,
11:01:08 <kyagrd>     Cabal-1.6.0.3, HTTP-4000.0.7, ansi-terminal-0.5.0,
11:01:13 <bgs100> Saizan, ^
11:01:21 <Saizan> bgs100: ah, now i see
11:01:35 <Saizan> bgs100: you should move that config file and let cabal create it first
11:01:44 <Saizan> bgs100: and only then insert your customizations
11:02:02 <mightybyte> tommd: Is "cabal install -p --reinstall network" the proper way to rebuild network (or any package) with profiling turned on?
11:02:05 <Saizan> bgs100: "cabal update" will suffice
11:02:13 <sm> jeffersonheard: I think that flv file needs a http content type
11:02:32 <tommd> mightybyte: That sounds right to me, but I don't have it memorized off hand.
11:02:57 <kyagrd> I don't have Cabal-1.6.0.1 installed but cabal is trying to use Cabal-1.6.0.1 when I try to install leksah strange
11:03:00 <jeffersonheard> sm: I think I have to have a flash server installed to have it embed
11:03:12 <jeffersonheard> I figured ppl would just download it
11:03:14 <mightybyte> tommd: --help says "-p --enable-library-profiling     Enable Library profiling", but I just wanted to make sure.
11:03:27 <pcc1> what is the best practice for including haskell bindings for a C library as part of a larger project (i.e. the library itself).  clearly I do not wish to convert the project's whole build system to cabal
11:03:27 <bgs100> Saizan, Ok, Thanks
11:03:33 <jeffersonheard> maybe not, though.  I am not a web-designer
11:03:40 <Saizan> kyagrd: that's because the .cabal file for leksah specifies a fixed dependency on Cabal-1.6.0.1
11:03:55 <kyagrd> So, I should install Cabal-1.6.0.1?
11:03:57 <Saizan> kyagrd: you could try editing it
11:04:03 <lilac> jeffersonheard: i demand a longer video at a higher framerate!
11:04:10 <lilac> (also a shrubbery)
11:04:13 <jmcarthur_work> pcc1, why not cabal?
11:04:19 <Saizan> kyagrd: no, that won't work otherwise cabal-install would have done it
11:04:22 <jmcarthur_work> oh you mean the C project
11:04:28 <kyagrd> hmm ...
11:04:58 <jmcarthur_work> pcc1, i think people typically just rely on the end user having the C library installed already
11:05:20 <jeffersonheard> lilac: how many seconds of watching little blue worms swirling around a lambda do you need?
11:05:22 <kyagrd> It would be best if leksah maintainer updates it to be able to compile with Cabal-1.6.0.x (where x can be 1,2,3)
11:05:22 <tommd> kyagrd: If I recall correctly, I downloaded Leksah package and modified that dep requirement.
11:05:23 <mightybyte> Is there any way to have cabal recursively rebuild dependencies with profiling?
11:05:44 <Saizan> kyagrd: yeah :) you might send them a mail
11:05:48 <tommd> mightybyte: I'd read the man page or just try "cabal update ; cabal upgrade -p"
11:06:28 <bgs100> Saizan, http://pastebin.ubuntu.com/213797/ Didn't go to well on install attempt :P
11:06:30 <Saizan> "cabal upgrade" generally breaks things :) in fact it's disabled in later versions
11:06:50 <bgs100> too*
11:06:58 <mightybyte> Yeah, I just noticed that.
11:07:01 <tommd> I knew it had issues, but didn't realize duncan went so far as to turn it off.
11:07:05 <mightybyte> It won't let me run upgrade
11:07:17 <Saizan> bgs100: it seems your ghc is too old, and you don't have gtk2hs installed
11:07:22 <lilac> jeffersonheard: enough that i can use it as an animated wallpaper?
11:07:29 <pcc1> jmcarthur_work: I see.  but we would really like there to be a --with-haskell compile option for our project which would build the haskell bindings.  does cabal not support building together with its dependencies?
11:07:31 <Saizan> bgs100: i think leksah in its current state builds only with ghc-6.10.1
11:07:45 <jeffersonheard> lol.  be kind of low-res for that, yes?
11:08:00 <tommd> What was wrong with 6.8.3?  Was that still using old-exception?
11:08:26 <Saizan> the ghc-api changed consirably betweend 6.8 and 6.10 iirc
11:08:29 <jmcarthur_work> pcc1, oh you want the haskell bindings in with the original c project! i thought you were building a third party binding to it
11:08:30 <jeffersonheard> but I will do
11:08:46 <jmcarthur_work> pcc1, i don't know of a best practice for that
11:08:53 <sm> how can I get throwError to use System.IO.UTF8 for output ?
11:09:23 <jmcarthur_work> pcc1, you could use make to invoke cabal, or you could build the haskell project with make, or some other combination, but i haven't many projects like this, honestly
11:09:35 <Saizan> sm: encode before throwing the error?
11:10:03 <Saizan> sm: or catch the errors and report them to the user that way
11:10:03 <sm> Saizan: I am passing it a utf8-encoded string
11:10:04 <pcc1> jmcarthur_work: ok, I'll see if I can work something out.  are there any instructions for building a haskell package "directly"?  I wasn't able to find any
11:10:10 <jmcarthur_work> pcc1, cabal can be used to do other stuff too, but i am not very familiar with it
11:11:23 <sm> ah, I see.. throwError just gives me the string back at the point where I runErrorT
11:11:34 <Saizan> yeah
11:12:32 <dons> pcc1: directly?
11:12:37 <dons> i.e. not via cabal?
11:12:50 <dons> essentially, extract (with -v4) the command lines cabal emits
11:12:53 <pcc1> dons: yes
11:14:19 <Saizan> isn't there a way to make cabal dump a makefile?
11:14:44 <dons> there's a way to make GHC dump a makefile
11:14:46 <dons> ghc -M
11:14:59 <sm> success! thanks Saizan
11:15:16 <pcc1> dons: thanks. is the process standardised, or would it change from version to version (of cabal, ghc, ???)?
11:15:53 <Saizan> you need to create an InstalledPackageInfo
11:16:01 <Saizan> and that can change
11:16:37 <Saizan> (i think they are going to change it in the next version to contain an ABI hash, for example=
11:18:18 <Saizan> however you can build a cabal lib even if the C part is not installed, since it'll be linked in later, right?
11:19:19 <Saizan> or try with --extra-lib-dirs --extra-include-dirs
11:19:25 <thoughtpolice> well, you'll need the headers and whatnot for the ffi decls
11:20:06 <Saizan> do you?
11:20:14 <thoughtpolice> i do believe so
11:20:19 <kyagrd> some projects include autoconf kind of scripts. I think that's the typical way to go
11:20:34 <thoughtpolice> yeah, you can hook a ./configure script into cabal without much difficulty
11:20:34 <kyagrd> for portability
11:21:15 <Saizan> this is not for portability, it's for building together with the C lib, without having it installed in the system yet, afaiu
11:21:33 <Zao> thoughtpolice: Except that you make your package unusable on Windows.
11:21:43 <Zao> And others that may not have the relevant bits to run the script.
11:21:57 <pcc1> thoughpolice: what I need is the other way around (calling cabal from an autotools infrastructure)
11:22:07 <kyagrd> What I meant portability is among different systems that has differrent installation paths etc.
11:22:38 <Saizan> yeah, a configure scripts should be avoided as much as possible
11:23:03 <pcc1> pcc1: we actually build on windows via cygwin
11:23:11 <kyagrd> How is readline packaged? It doesn't work on windows? (I rarely use windows so I'm not sure which library works or not)
11:23:35 <thoughtpolice> kyagrd: it binds gnu readline. for full portability you should probably use haskeline if possible
11:23:52 <thoughtpolice> since it works perfectly well on windows
11:24:00 <pcc1> we may need to target only the cygwin ghc (I imagine there is one)
11:24:02 <kyagrd> I don't use haskline. It doesn't support multibyte characters very well yet.
11:24:09 <erisco> what do I use to convert a fractional number to an int?
11:24:24 <Zao> pcc1: The current one uses mingw.
11:24:37 <Zao> No idea if it's possible to build with cygwin nowadays, nor if you ever could.
11:24:38 <kyagrd> readline is the only choice that does multibyte inputs in a sane way among haskline editline and others
11:25:33 <Zao> And coincidentally the only one under an unusable license.
11:25:39 <Saizan> pcc1: last time he tried tuomov couldn't get one that produced cygwin executables
11:25:50 <pcc1> I imagine this would cause linkage problems (the C lib obviously links with cygwin1.dll whihc may cause incompatibilities)
11:26:10 <bgs100> Yay
11:26:24 <bgs100> Finished installing latest stable binary of ghc
11:26:43 <erisco> I've got it, never mind
11:26:56 <Saizan> you won't get leksah cleanly installed there either though :)
11:27:19 <bgs100> Saizan, Ok, what now? :P
11:28:13 <Saizan> bgs100: 1) install http://www.haskell.org/gtk2hs/download/
11:29:29 <Zao> Saizan: 2) Cry as it doesn't include sourceview nor supports 6.10.3 out of the box.
11:29:40 <Zao> Oh look, updated installer.
11:30:23 <pcc1> one last question, does cabal support a separate build directory?
11:30:26 <bgs100> Saizan, Is it possible to install that with cabal?
11:30:35 <Zao> bgs100: No.
11:30:45 <bgs100> :P
11:30:47 <Zao> Author hasn't managed to cabalize it yet.
11:31:25 <jmcarthur_work> gtk2ks is one of the most important packages that *still* isn't on hackage
11:31:27 <Zao> Oh look, it contains sourceview nowadays too.
11:31:42 <jmcarthur_work> imo
11:31:45 <Zao> This is the third 0.10.1 I'm running.
11:31:48 <Zao> All magically different.
11:32:05 <jeffersonheard> lilac: okay, you have 30 seconds of particle systems swirling around attractors laid out as a lambda.
11:32:09 <jeffersonheard> at 30fps
11:32:31 <Saizan> woot i've leksah on ghc-6.10.3
11:32:53 <Saizan> well, 6.10.2 actually
11:33:09 <Saizan> ok, now i can continue to use emacs
11:34:34 <lilac> jeffersonheard: woo
11:35:21 <bgs100> Oh, forget it :P
11:35:39 <deech> Hi all I am having trouble install haskelldb with sqlite3. I have a simple program at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6752#a6752 runs into an HDBC error when I load it into ghci: Loading package HDBC-2.1.0 ... linking ... <interactive>: /home/deech/.cabal/lib/HDBC-2.1.0/ghc-6.10.2/HSHDBC-2.1.0.o: unknown symbol `__stginit_utf8zmstringzm0zi3zi5_DataziByteStringziUTF8_'
11:35:39 <deech> ghc: unable to load package `HDBC-2.1.0'. Has anyone seen this before?
11:35:42 <ryo_hazuki> how can i use sortBy with LT / GT etc? something like this: main = print (sortBy LT [1,5,2,8,4])
11:36:15 <Saizan> bgs100: if you want to install leksah you've to unpack the package and relax the dep on Cabal
11:36:30 <bgs100> ?
11:37:00 <Saizan> bgs100: change Cabal == 1.6.0.1 to Cabal == 1.6.* in leksah.cabal
11:37:16 <bgs100> Oh
11:37:22 <deech> And when I try to upgrade HDBC I get the following error: Data/Convertible/Instances/Time.hs:61:9:
11:37:22 <deech>     Duplicate instance declarations:
11:37:22 <deech>       instance Typeable NominalDiffTime
11:37:23 <deech>         -- Defined at Data/Convertible/Instances/Time.hs:61:9-32
11:37:24 <lilac> jeffersonheard: nice, thanks
11:37:25 <deech>       instance Typeable NominalDiffTime
11:37:30 <deech>         -- Defined in time-1.1.3:Data.Time.Clock.UTC
11:37:33 <deech> Data/Convertible/Instances/Time.hs:64:9:
11:37:37 <deech>     Duplicate instance declarations:
11:37:37 <deech>       instance Typeable UTCTime
11:37:40 <deech>         -- Defined at Data/Convertible/Instances/Time.hs:64:9-24
11:37:43 <Saizan> deech: stop pasting in channel.
11:37:43 <deech>       instance Typeable UTCTime
11:37:46 <deech>         -- Defined in time-1.1.3:Data.Time.Clock.UTC
11:37:49 <deech> cabal: Error: some packages failed to install:
11:37:50 --- mode: ChanServ set +o Saizan
11:37:52 <deech> HDBC-2.1.1 depends on convertible-1.0.1 which failed to install.
11:37:56 <deech> cData/Convertible/Instances/Time.hs:61:9:
11:37:56 --- mode: Saizan set +b *!*n=user@*.dhcp.stls.mo.charter.com
11:38:16 <jeffersonheard> lilac: yw.  Sometimes you just have to code something purely for fun
11:38:22 <Saizan> he should have stopped now :)
11:38:35 --- mode: Saizan set -b *!*n=user@*.dhcp.stls.mo.charter.com
11:38:36 <deech> HDBC-2.1.1 depends on convertible-1.0.1 which failed to install.
11:38:43 <deech> whoops sorry
11:38:53 <deech> my bad, didn't mean to do that.
11:38:57 <Saizan> heh
11:40:16 <Saizan> deech: do you have more than one time package installed?
11:40:54 <deech> Yes apparently I do, don't know how that happened
11:41:18 <Saizan> it's because of "cabal upgrade HDBC" i think
11:41:34 <Saizan> deech: you should probably unregister the latter one
11:41:45 <Saizan> i.e. the one with the higher version
11:42:06 <Saizan> since it seems convertible is not compatible with it
11:42:32 <deech> If I do that how do I upgrade HDBC?
11:42:44 <Saizan> you "cabal install HDBC"
11:42:54 <bgs100> Saizan, Well, I probably won't be using leksah that much anyway. I use emacs as well, and already have haskell mode ;)
11:42:57 <Saizan> so that it won't try to upgrade the dependencies too
11:42:58 <ryo_hazuki> how can i use sortBy in together with LT / GT etc.?
11:43:19 <ryo_hazuki> how can i use sortBy together with LT / GT etc.? ... forget the 'in' ;))
11:43:23 <tommd> :t sortBy
11:43:25 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
11:43:27 <tommd> :t comparing
11:43:29 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
11:44:00 <Saizan> ryo_hazuki: i'm not sure what you're asking
11:44:06 <ryo_hazuki> for example
11:44:18 <tommd> > sortBy (comparing snd) (zip [1..10] [9,4,5,6,1,7,0,2])
11:44:20 <lambdabot>   [(7,0),(5,1),(8,2),(2,4),(3,5),(4,6),(6,7),(1,9)]
11:44:31 <ryo_hazuki> main = print (sortBy LT [1,5,3,7])
11:44:40 <erisco> Cale, look look at what I did now
11:44:41 <ryo_hazuki> thats actually what i like to use
11:44:56 <tommd> ryo_hazuki: That makes no sense.  LT is not a function.
11:44:58 <erisco> Cale, I went back and improved on my palindrome functions!
11:45:01 <erisco> Cale, http://pastebin.ca/1489923
11:45:22 <Saizan> ryo_hazuki: sortBy takes a function to compare the elements
11:45:37 <tommd> ryo_hazuki: Perhaps you really just want "sort"?
11:45:42 <Saizan> ryo_hazuki: so to sort in descending order you can use "flip compare" for example
11:45:45 <deech> saizan: cabal install hdbc wants to download the latest version of time.
11:45:49 <ryo_hazuki> mhhh
11:45:54 <ryo_hazuki> let me try that :)
11:46:40 <ryo_hazuki> :t flip
11:46:42 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:46:48 <ryo_hazuki> :D
11:46:50 <Saizan> deech: add --constraint="time < 1.1.3"
11:46:56 <Saizan> ?src flip
11:46:56 <lambdabot> flip f x y = f y x
11:47:10 <ryo_hazuki> haha cool bot :)))
11:47:23 <Saizan> deech: i'm mostly guessing though :)
11:48:07 <erisco> Cale, interestingly enough, it is faster to make a palindrome than to verify that a list is one (based on my best implementation)
11:48:08 <Saizan> deech: --constraint="time < 1.1.3" should make cabal pick version 1.1.2.4 which should be compatible, given HDBC's cabal file
11:48:24 <erisco> Cale, but they are both linear and neither suffer from stack overflows so all is good
11:48:39 <tommd> Saizan, deech: Isn't time version 1.1.3 the bad version?
11:49:21 <Saizan> tommd: we're trying to avoid it because it defines the same instances as convertible
11:49:28 <tommd> I think it's yet another package screwed over by the ghc packaging method in which they pull packages from the darcs repo without verifying the working state (so many 1.1.3 time packages are actually some dev version)
11:49:51 <tommd> Ok, I thought you were trying to use it.  I get it.
11:51:03 <Saizan> however yeah, core packages are often only tested in ghc's build system, and with the ghc they ship with, which makes them kind of broken if uploaded to hackage
11:51:24 * erisco smiles because he did something intelligent in functional programming for once
11:51:42 <ryo_hazuki> *clap clap
11:51:44 <ryo_hazuki> =)
11:51:55 <erisco> =D
11:53:12 <erisco> does Haskell have a library providing for lists that do keep track of their length?
11:54:19 <erisco> it would make things like appends painful, but
11:54:33 <monochrom> http://www.haskell.org/haskellwiki/MonadFix   Whee!
11:55:00 <monochrom> <3 tying knots
11:56:47 * erisco loves doing isPalindrome "racecar"
11:57:03 <erisco> oh! demetri's poem!
11:57:19 <erisco> I better make sure that is a real palindrome too with my handy-dandy isPalindrome function
11:58:37 <ziman> :t ap (==) reverse
11:58:39 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:00:07 <bsdemon> Hello, I have a question about pattern matching in Haskell: In Erlang I can match expressions with two occurences of one name and they are stated to be identical, so I can match some elements of data for equality, but in Haskell I get an error while trying to compile function with two occurences of one name in pattern matching expression
12:00:48 <iago> x:x:xs isn't valid
12:00:52 <iago> use guards instead
12:00:54 <bsdemon> I know I can do achieve it with guards, but why it is impossible in Haskell?
12:00:57 <iago> x:y:xs | x == y
12:01:05 <erisco> I can now confirm that Demetri Martin's poem "Dammit I'm Mad" is a true palindrome
12:01:08 <erisco> exciting
12:01:18 <jmcarthur_work> bsdemon, in haskell, pattern matching just binds variables
12:01:24 <soupdragon> erisco, doesn't seem hard?  (a,lengthA) ++ (b,lengthB) = (a++b, lengthA+lengthB)
12:01:30 <jmcarthur_work> so you are attempting to bind two things to the same identifier
12:01:48 <jmcarthur_work> i do agree that what you are trying to do would be handy, but guards can suffice
12:01:51 <ryo_hazuki> :t LT
12:01:53 <lambdabot> Ordering
12:02:09 <bsdemon> so there is no some GHC extension to do that?
12:02:10 <iago> I think this is the most common choice
12:02:21 <erisco> soupdragon, what is a and b?
12:02:47 <soupdragon> regular lists
12:02:53 <erisco> soupdragon, I did not say it was hard, I am new and working on chapter 3 exercises in the real world haskell book
12:03:09 <soupdragon>  <erisco> it would make things like appends painful, but
12:03:12 <Ferdirand> not all types are testable for equality
12:03:16 <erisco> soupdragon, but what am I supposed to put in a and b to verify that something is a palindrome?
12:03:33 <Ferdirand> so that vvould tie Eq into the language
12:03:47 <erisco> soupdragon, ohh
12:04:15 <erisco> soupdragon, yes, using a tuple seems like a far better idea than what I was imagining :)
12:04:39 <erisco> soupdragon, thanks for that idea
12:11:52 <bgs100> > let removeNonAlpha xs = [ x | x <- xs, x `elem` ['a'..'z'] ++ ['A'..'Z'] ] in removeNonAlpha "Hello there, Mr.Person!"
12:11:54 <lambdabot>   "HellothereMrPerson"
12:12:43 <jeffwheeler> @hoogle isAlpha
12:12:43 <lambdabot> Data.Char isAlpha :: Char -> Bool
12:12:43 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
12:12:58 <jeffwheeler> > filter isAlpha "Hello there, Mr. Person!"
12:12:59 <lambdabot>   "HellothereMrPerson"
12:13:43 <bgs100> Prelude> isAlpha 'a'
12:13:43 <bgs100> <interactive>:1:0: Not in scope: `isAlpha'
12:13:55 * erisco smacks himself
12:14:03 <jeffwheeler> > isAlpha 'a'
12:14:03 <erisco> just when I thought I did something intelligent!
12:14:04 <ray> it's in Data.Char
12:14:04 <lambdabot>   True
12:14:12 <ray> hence hoogle saying Data.Char there
12:14:13 <erisco> why did I now just do xs == reverse xs??
12:14:24 <erisco> did I not*
12:14:30 <bgs100> erisco, That's kind of what I was wondering :P
12:14:37 <bgs100> But I didn't say anything :P
12:14:40 <ray> because you didn't think of it until now
12:14:58 <erisco> ray, I did not think of it, I was reading over other's solutions in the comments :P
12:15:05 <bgs100> Lol
12:15:07 <bgs100> :P
12:15:15 <erisco> well, my complexity is O(2.5n) and theirs is O(2n), so I am close
12:15:28 <jeffwheeler> erisco: where is the challenge?
12:15:39 <wli> opcounts with additive errors please
12:15:54 <erisco> jeffwheeler, not challenge, just exercise, chapter 3 of real world haskell
12:16:02 <jeffwheeler> Testing the palindromicity of lists?
12:16:06 <jeffwheeler> erisco: oh
12:16:24 <erisco> palindromicity is not a word, but creative :P
12:16:28 <bgs100> > let isPalindrome xs = xs == reverse xs in isPalindrome "bob"
12:16:30 <lambdabot>   True
12:16:35 <jeffwheeler> Google found results for it. :)
12:16:54 <erisco> bgs100, in any case, my original operated in quadratic time lmao
12:16:59 <jeffwheeler> My spell-checker doesn't have internet in it, so I don't trust it very much.
12:17:00 <erisco> bgs100, so at least I improved on that...
12:17:07 <pikhq> bgs100: Project Euler, I take it?
12:17:26 <bgs100> pikhq, Hm?
12:17:40 <pikhq> Guess not.
12:18:14 <jeffwheeler> pikhq: RWH exercise
12:18:16 <bgs100> I've heard of Project Euler, but, haven't really looked into it...
12:18:21 <pikhq> jeffwheeler: Ah.
12:18:49 <monochrom> Project Euler is a major cause of CO2 emission.
12:19:32 <erisco> bgs100, well this solves the weirdness of not being able to check if a list of palindromic with the same complexity of making one
12:20:20 <jeffwheeler> I like exercise 7.
12:20:48 <jeffwheeler> > let f = intersperse in f ' ' "Hello!"
12:20:50 <lambdabot>   "H e l l o !"
12:20:55 <jeffwheeler> That was an easy function to define!
12:22:18 <jeffwheeler> > let f = sortBy length in f [[1, 2, 3], [], [1, 2]]
12:22:19 <lambdabot>   Couldn't match expected type `[a] -> GHC.Ordering.Ordering'
12:22:27 <monochrom> My next Project Haskellwiki is adding longest increasing subsequence to dynamic programming examples.
12:22:36 <jeffwheeler> @type compare
12:22:38 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
12:22:56 <erisco> jeffwheeler, the idea is that you do not use the functions containing direct solutions
12:22:58 <jeffwheeler> > let f = sortBy (compare . length) in f [[1, 2, 3], [], [1, 2]]
12:22:59 <lambdabot>   Couldn't match expected type `[a]'
12:23:10 <jeffwheeler> erisco: I know :)
12:23:27 <jeffwheeler> @type sortBy
12:23:29 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:23:31 <hackagebot> texmath 0.1.0.2 - Conversion of LaTeX math formulas to MathML. (JohnMacFarlane)
12:23:42 <jeffwheeler> > let f = sortBy (compare) in f [[1, 2, 3], [], [1, 2]]
12:23:44 <lambdabot>   [[],[1,2],[1,2,3]]
12:23:56 <jeffwheeler> > let f = sortBy (compare) in f [[1, 2, 3], [], [5, 6]]
12:23:57 <lambdabot>   [[],[1,2,3],[5,6]]
12:24:18 <jeffwheeler> @type compareOn
12:24:19 <lambdabot> Not in scope: `compareOn'
12:24:24 <jeffwheeler> @hoogle cmp
12:24:24 <lambdabot> Data.Array.Base cmpIntUArray :: (IArray UArray e, Ord e) => UArray Int e -> UArray Int e -> Ordering
12:24:25 <lambdabot> Data.Array.Base cmpUArray :: (IArray UArray e, Ix i, Ord e) => UArray i e -> UArray i e -> Ordering
12:24:25 <lambdabot> package funcmp
12:24:28 <jeffwheeler> @hoogle compare
12:24:28 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
12:24:28 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
12:24:28 <lambdabot> Text.ParserCombinators.Parsec.Error messageCompare :: Message -> Message -> Ordering
12:24:29 <pikhq> > let f = sortBy (comparing length) in f [[1,2,3], [], [5,6]]
12:24:31 <lambdabot>   [[],[5,6],[1,2,3]]
12:24:42 <jeffwheeler> @type comparing
12:24:43 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:24:48 <jeffwheeler> Ah . . .
12:25:22 <pikhq> I think part of the point is to do more than just one-liners to get a feel for the language, though.
12:25:30 <bgs100> Yay, the poem palindrome test worked
12:26:02 <pikhq> Say, "f (x : xs) y = x : y : f xs", not just using intersperse.
12:27:04 <monochrom> Lower syntaxfree!
12:27:41 <codebliss> @pl \a b -> a + b + 1
12:27:42 <erisco> bgs100, I am attempting to write an even faster test for palindromes than O(2n)
12:27:42 <lambdabot> flip flip 1 . ((+) .) . (+)
12:27:54 <erisco> bgs100, which is our xs == reverse xs
12:28:03 <erisco> @src reverse
12:28:04 <lambdabot> reverse = foldl (flip (:)) []
12:29:41 <lyndon> Is there a way around single element lists in list comprehensions?
12:31:16 <dons> a way around?
12:33:14 <erisco> actually, does xs == reverse xs transverse the list once or twice?
12:33:57 <erisco> bgs100, the fastest we can get this is surely O(n), but it may already be that if xs == reverse xs only transverses once due to lazy evaluation
12:34:18 <thoughtpolice> well, the whole list will have to be in memory for the comparison
12:34:28 <thoughtpolice> because the GC has to keep the pointer to the original 'xs' around since it's still used
12:34:36 <lyndon> dons: for example [x+y| x <- some_list, y <- [head some_list]]
12:35:14 <erisco> thoughtpolice, you mean it will have to be copied in memory?
12:35:14 <thoughtpolice> lyndon: map (+(head some_list)) some_list
12:36:12 <thoughtpolice> erisco: I mean that the entire contents of the list will have to be in memory in order for the comparison to return - the GC cannot deallocate the list as you traverse it, because you must keep the original copy around
12:36:35 <thoughtpolice> at least AFAICS
12:37:29 <thoughtpolice> lyndon: or, more clearly, 'let y = head some_list in map (y+) some_list'
12:37:37 <erisco> hm, I will leave the palindrome thought for now
12:38:15 <lyndon> thoughtpolice: maybe my exaple wasn't the best
12:38:45 <kiris> #lojban
12:39:14 <lyndon> a better one (?): [x+y|x <- [1..n], y <- [x+1]]
12:39:52 <jeffwheeler> > [x+1|x <- [1..n]] -- How is this any different?
12:39:53 <lambdabot>   * Exception: not a number
12:39:57 <jeffwheeler> err
12:40:10 <jeffwheeler> > [x+1|x <- [1..]] -- How is this any different?
12:40:11 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
12:40:51 <thoughtpolice> actually wouldn't it be 'x+x+1' considering y = x+1?
12:41:02 <jeffwheeler> Err, yeah.
12:41:09 <thoughtpolice> but yeah, in any case,
12:41:28 <lyndon> regardless...
12:41:35 <thoughtpolice> lyndon: in the case of a single-element list in a comprehension, you can probably almost always get something clearer by simplifying the comprehension or just desugaring it
12:41:47 <thoughtpolice> (down to map/filter etc. that is)
12:42:08 <lyndon> thoughtpolice: hmm. ok
12:43:10 <erisco> @src compargin
12:43:11 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:43:13 <erisco> @src comparing
12:43:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:45:55 <bgs100> @src compare
12:45:56 <lambdabot> compare x y | x == y    = EQ
12:45:56 <lambdabot>             | x <= y    = LT
12:45:56 <lambdabot>             | otherwise = GT
12:46:43 <bgs100> <=? Why that instead of <, when there's already a == test... :/
12:48:19 <erisco> where does the comparing function come from?
12:48:33 <erisco> I could define my own, but, evidently it exists already somewhere
12:49:38 <jmcarthur_work> @hoogle comparing
12:49:38 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
12:49:39 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
12:50:49 <erisco> actually I am wrong, I have no idea how to create my own comparing function
12:50:53 <erisco> =\
12:51:01 <erisco> but I can just import it so all is good :)
12:51:08 <jmcarthur_work> @djinn Ord a => (b -> a) -> b -> b -> Ordering
12:51:09 <lambdabot> Error: Undefined type Ordering
12:51:12 <jmcarthur_work> bleh
12:51:36 <jmcarthur_work> :t on compare
12:51:38 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
12:51:39 <erisco> type signatures do not help me :(
12:51:54 <jmcarthur_work> @src on
12:51:55 <lambdabot> (*) `on` f = \x y -> f x * f y
12:52:20 <erisco> how can it be called to take a function and then be used in comparisons?
12:52:24 <erisco> does it return a function?
12:52:26 <erisco> it must
12:53:05 <jmcarthur_work> yup
12:55:09 <erisco> what sort of sort does sortBy use?
12:55:31 <jmcarthur_work> merge sort, i believe
12:55:49 <erisco> which is n log n, good
13:03:13 <erisco> this still makes "sortBy (comparing length) xs" a very inefficient operation... but as how to resolve that I really don't want to get myself into :P
13:03:50 <erisco> actually, just wrapping each list into a tuple and storing its length along with it and writing a custom length function would work
13:03:59 <erisco> or actually just snd would work
13:04:05 <erisco> might try that for kicks
13:04:06 <Berengal> sortBy (comparing (map (const ())))
13:04:36 <erisco> Berengal, sorry, what does this do?
13:04:43 <Berengal> lazy length
13:04:58 <bgs100> I tried to install lambdabot, and http://pastebin.ubuntu.com/213883/ :(
13:05:02 <Berengal> > sortBy (comparing (map (const ()))) [1,2,3,4,5] [1..]
13:05:03 <lambdabot>   Couldn't match expected type `[t1] -> t'
13:05:07 <Berengal> :/
13:05:08 <erisco> you can do a sort with lazy length? how?
13:05:36 <Berengal> > sortBy (comparing (map (const ()))) [[1,2,3,4,5]] (repeat [1,2,3])
13:05:37 <lambdabot>   Couldn't match expected type `[[t1]] -> t'
13:05:46 <Berengal> Argh!
13:05:57 * Berengal needs to test his functions in ghci first
13:06:20 <Berengal> Anyway, the idea is to replace every element with (), and compare the resulting list.
13:06:28 <Berengal> > compare [1,2,3,4] [1..]
13:06:30 <lambdabot>   LT
13:06:35 <Saizan> bgs100: which version of cabal-install do you have?
13:06:39 <pikhq> :t sortBy
13:06:40 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
13:06:47 <bgs100> Saizan, The latest
13:06:53 <pikhq> Berengal: Why are you giving three arguments to sortBy?
13:07:19 <bgs100> Saizan, After all, I just got it today :)
13:07:20 <jmcarthur_work> erisco, yes, your proposed solution to store tuples with lengths is a common way to do it
13:07:22 <Berengal> pikhq: I was forgetting myself...
13:07:33 <jeffersonheard> c2hs question?
13:07:38 <bgs100> Saizan, 0.6.2
13:07:55 <Berengal> > sortBy (comparing (map (const ()))) [[1..], [1,2,3,4,5]]
13:07:57 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,2...
13:08:27 <jmcarthur_work> erisco, some of us wish we had sortOn :: Ord b => (a -> b) -> [a] -> [a], rather than sortBy, which would allow you to say "sortOn length" and be done with it
13:08:59 <Saizan> bgs100: ghc --version? it seems you're still on 6.8.x
13:09:03 <jmcarthur_work> erisco, yeah, and Berengal's version works on infinite lists :D
13:09:14 <bgs100> Saizan, yes
13:09:21 <erisco> works on infinite lists? I don't get it
13:09:24 <erisco> I was to preform a sort
13:09:24 <bgs100> "The Glorious Glasgow Haskell Compilation System, version 6.8.2"
13:09:44 <jmcarthur_work> erisco, what happens if you take the length of an infinite list?
13:09:48 <erisco> sortBy (comparing (map (const ()))) [[1..], [3,2,8,5,1]]
13:09:54 <erisco> > sortBy (comparing (map (const ()))) [[1..], [3,2,8,5,1]]
13:09:55 <Saizan> bgs100: ah, i thought you installed the latest earlier
13:09:56 <lambdabot>   [[3,2,8,5,1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,2...
13:10:04 <erisco> yeah okay I do not get it
13:10:10 <erisco> jmcarthur_work, how do you sort an infinite list?
13:10:19 <jmcarthur_work> erisco, that's not what it does
13:10:26 <bgs100> Saizan, Must I for this as well? :P
13:10:29 <jmcarthur_work> erisco, it sorts a list of potentially infinite lists
13:10:32 <Berengal> erisco: You don't sort an infinite list, you sort a list containing possibly infinite lists as elements
13:11:02 <jmcarthur_work> > length [1,2,3] `compare` length [1..]
13:11:08 <lambdabot>   mueval-core: Prelude.read: no parse
13:11:08 <lambdabot>  mueval: ExitFailure 1
13:11:14 <Saizan> bgs100: no, but you need to give an hint to cabal, --constraint="haskell-src-exts == 0.3.9"
13:11:24 <jmcarthur_work> > genericLength [1,2,3] `compare` (genericLength [1..] :: Nat)
13:11:24 <ehird> jmcarthur_work: there's no way that can work
13:11:25 <lambdabot>   Not in scope: type constructor or class `Nat'
13:11:31 <jmcarthur_work> > genericLength [1,2,3] `compare` (genericLength [1..] :: Natural)
13:11:31 <ehird> oh
13:11:32 <lambdabot>   LT
13:11:36 <ehird> well if you do THAT
13:11:36 <bgs100> Saizan, Do I have to do that for *all* installs?
13:11:43 <ehird> but not the usual strict integer types
13:11:46 <jmcarthur_work> nope
13:11:49 <erisco> Berengal, how is the sort preformed? what does const do?
13:11:53 <Phillemann> I've got a record data structure (like "data Foo = { bar :: Int,baz :: String }"), can I "default initialize" the structure?
13:12:07 <Berengal> @type const
13:12:09 <lambdabot> forall a b. a -> b -> a
13:12:14 <Berengal> > const 5 "foo"
13:12:16 <lambdabot>   5
13:12:16 <Heffalump> Phillemann: write a defaultFoo value
13:12:17 <jmcarthur_work> ehird, i was attempting a comparison
13:12:22 <bgs100> Oh yay
13:12:27 <bgs100> It appears to be working
13:12:28 <Zao> mkFoo = Foo 42 "wtf"
13:12:28 <Heffalump> or even foo
13:12:37 <jmcarthur_work> oh, that was ambiguous
13:12:39 <pikhq> erisco: It's just the K combinator.
13:12:43 <erisco> Berengal, I cannot read type signatures well
13:12:43 <jmcarthur_work> *a comparison between the two approaches
13:12:44 <Saizan> bgs100: all? no, only those that depend on haskell-src-exts-0.3.*, the reason is that the dependency solver of cabal-install is still not very powerful
13:12:52 <Zao> If you want to prevent people from constructing one, don't export the ctor.
13:12:55 <bgs100> Saizan, Ok
13:12:57 <natthew> Hi, does anyone know how to do strict IO with Data.Binary? I'm using the definition of decodeFile that Data.Binary gives, but replacing IO.readFile with Strict.readFile and it's saying that a 'String' is not a 'Data.ByteString.Lazy.Internal.ByteString'
13:12:58 <Berengal> erisco: It's the constant function. It always returns the first argument
13:12:59 <erisco> pikhq, not sure what a K combinator is... can I read on this?
13:13:02 <bgs100> Saizan, Thanks
13:13:11 <jmcarthur_work> erisco, look up SK calculus
13:13:15 <Berengal> @src const
13:13:15 <lambdabot> const x _ = x
13:13:31 <erisco> Berengal, out of two then, yes
13:13:40 <bgs100> Um
13:13:45 <pikhq> http://en.wikipedia.org/wiki/SKI_combinator_calculus
13:14:00 <blsecres> what is ((->) t) called?  I can't for the life of me remember and google is useless
13:14:01 <jmcarthur_work> > map (const ()) [1..]
13:14:02 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
13:14:16 <ehird> :t let s = ap :: (a -> b -> c) -> (a -> b) -> a -> c in s
13:14:17 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
13:14:17 <Berengal> Combinator calculus is a bit heavy if you just want to understand the constant function...
13:14:19 <Heffalump> Bleadof: as a monad, it's often referred to as the Reader monad
13:14:23 <ehird> :t let k = const in k
13:14:24 <lambdabot> forall a b. a -> b -> a
13:14:32 <ehird> erisco: now you know what SK are.
13:14:37 <ehird> (they're turing complete)
13:14:38 <bgs100> Saizan, http://pastebin.ubuntu.com/213893/
13:15:04 <natthew> It's strange, because IO.readFile is the same type as Strict.readFile (filePath -> IO String)
13:16:05 <Saizan> bgs100: weird, can you get the real error from the log? or retry to only install haskell-src or haskell-src-exts-0.3.9 ?
13:16:41 <bgs100> Saizan, log?
13:16:42 <jmcarthur_work> natthew, i don't know, but perhaps the bytestring version has a bytestring filepath?
13:16:57 <pikhq> :t Strict.readFile
13:16:59 <Saizan> bgs100: the scrollback
13:16:59 <lambdabot> Couldn't find qualified module.
13:17:18 <natthew> i'm using strict-0.3.2
13:17:19 <pikhq> @hoogle Strict.readFile
13:17:19 <natthew> http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html
13:17:19 <lambdabot> No results found
13:17:31 <pikhq> *shrug*
13:17:35 <Saizan> natthew: binary is using Data.ByteString.Lazy.readFile
13:17:49 <bgs100> Saizan, The paste was what it said.
13:18:06 <Saizan> bgs100: all of it? nothing earlier?
13:18:09 <bgs100> Oh
13:18:10 <bgs100> No
13:18:25 <erisco> Berengal, so I am still quite unclear... why do you want to replace all elements with unit? what does map return that is useful for comparing?
13:18:41 <erisco> Berengal, is this preventing the length being calculated for every element in the list?
13:18:46 <Berengal> erisco: A list of the same length, but containing the same elements
13:18:47 <jmcarthur_work> > [(), (), ()] `compare` [(), ()]
13:18:48 <lambdabot>   GT
13:18:50 <erisco> Berengal, every time they need to be compared in the merge sort?
13:19:05 <Saizan> bgs100: maybe you're not seeing it, however "cabal install haskell-src" should reproduce the problem
13:19:32 <jmcarthur_work> erisco, it's not calculating the lengths at all
13:19:42 <natthew> Saizan: I know, but it uses readFile in the definition of decodeFile (http://hackage.haskell.org/packages/archive/binary/0.4.2/doc/html/Data-Binary.html), which has the same type as Strict.readFile
13:19:46 <erisco> how does it know how to sort the lists then?
13:19:47 <Berengal> erisco: Not exactly. The point is to stop comparing the length once you've determine that one is longer than the other
13:19:57 <jmcarthur_work> erisco, for each list, it's traversing until it sees which one is shorter
13:20:19 <jmcarthur_work> erisco, it doesn't bother continuing to count the longer list
13:20:25 <jmcarthur_work> since it's not counting at all
13:20:31 <erisco> Berengal, jmcarthur_work, so, it is inefficient when comparing two long lists but efficient when comparing two short or a short and a long
13:20:47 <Saizan> natthew: it doesn't have the same type, since it's using L.readFile :: FilePath -> IO L.ByteString
13:20:50 <erisco> I still have zero idea how this comparison is taking place, but, anyways
13:20:53 <jmcarthur_work> erisco, it's also the only way to compare potentially infinite lists
13:20:53 <pikhq> More efficient than "comparing length".
13:21:03 <Saizan> natthew: where L is Data.ByteString.Lazy
13:21:05 <erisco> jmcarthur_work, what does generalLength do?
13:21:13 <bgs100> Saizan, http://pastebin.ubuntu.com/213903/
13:21:14 <jmcarthur_work> :t genericLength
13:21:15 <lambdabot> forall b i. (Num i) => [b] -> i
13:21:18 <jmcarthur_work> :t length
13:21:20 <lambdabot> forall a. [a] -> Int
13:21:29 <jmcarthur_work> basically it just doesn't restrict the result to Int
13:21:30 <erisco> okay, zillionth time, I do not understand type signatures :P
13:21:44 <jmcarthur_work> erisco, i think you could get them if you just study them a little ;)
13:21:47 <Berengal> > genericLength [1,2,3] :: Double
13:21:49 <lambdabot>   3.0
13:21:55 <Berengal> > genericLength [1,2,3] :: Int
13:21:56 <lambdabot>   3
13:21:57 <natthew> Saizan: Oh, I see. Is there a way to get around that?
13:21:59 <Saizan> bgs100: ah, right, you've to install happy first, you can do it via cabal or via apt-get i guess
13:22:01 <erisco> oh, so it does nothing special when called on an infinite list?
13:22:07 <bgs100> happy?
13:22:09 <jmcarthur_work> erisco, we resort to type signatures so often because they are often the best way to describe a function
13:22:28 <jmcarthur_work> > genericLength [1..] :: Int -- fail
13:22:29 <lambdabot>   * Exception: stack overflow
13:22:35 <jmcarthur_work> > genericLength [1..] :: Natural -- win
13:22:40 <lambdabot>   * Exception: stack overflow
13:22:41 <Saizan> bgs100: it's a preprocessor to generate parsers from grammars in EBNF
13:22:42 <jmcarthur_work> err
13:22:45 <Berengal> hehe
13:22:45 <jmcarthur_work> except for the show
13:22:51 <pikhq> Hah.
13:23:06 <jmcarthur_work> i was expecting something like S (S (S (S (S (S ...
13:23:19 <Berengal> genericLength makes the combination infinite lists and Natural special
13:23:25 <Berengal> > 5 :: Natural
13:23:25 <bgs100> Saizan, I installed happy but still got the same error......
13:23:26 <lambdabot>   5
13:23:29 <Saizan> natthew: you can use Data.ByteString.readFile (the strict version) and then convert the strict ByteString to a lazy one using fromChunks
13:23:34 <Saizan> bgs100: is it on your path?
13:23:38 <jmcarthur_work> erisco, Natural is a lazy Number
13:23:41 <jmcarthur_work> *number
13:23:42 <ehird> Berengal: it doesn't make them special
13:23:43 <ehird> but yeah
13:23:44 <bgs100> No
13:23:47 <ehird> Integer and the like are strict
13:23:49 <bgs100> Saizan, No
13:23:53 <ehird> Natural is lazy so you can compare _|_
13:24:01 <Berengal> ehird: "special" is a definition
13:24:11 <ehird> lol
13:24:13 <Saizan> bgs100: you've to put it on your $PATH for cabal to see it, or you can pass --with-happy=path/to/happy
13:24:24 <jmcarthur_work> erisco, Natural and [()] are isomorphic
13:24:25 <bgs100> *sighs*
13:24:29 <Berengal> ehird: Also, you can't compare _|_, but you can compare values that aren't fully defined
13:24:36 <ehird> well, yes.
13:24:40 <ehird> i was  glossing too :-)
13:24:44 <Berengal> :P
13:24:44 <ehird> s/  / /
13:24:52 * erisco really is not understanding the logic here
13:24:54 <pikhq> jmcarthur_work: So, it's akin to the definition of the naturals in set theory. Good to know.
13:25:31 <Gracenotes> speaking of which, Natural and [()] are not .quite. isomorphic when _|_ exists
13:25:35 <Berengal> erisco: Try to go through some of the comparisons yourself
13:25:52 <Saizan> bgs100: heh, not a very pleasant experience i guess :) but it should be nicer from now on..
13:25:53 <jmcarthur_work> erisco, consider comparing (Succ (Succ (Succ <stuff>))) and (Succ (Succ Zero))... which one is less than the other?
13:26:15 <erisco> okay, so let me get this straight, when comparing does the comparison, as the comparison takes place it evaluates the map as it goes until it hits the end of a list, right?
13:26:48 <jmcarthur_work> erisco, something like that
13:26:59 <erisco> so what happens if you try and compare two infinite lists?
13:27:04 <erisco> will it not be infinite?
13:27:05 <jmcarthur_work> boom
13:27:16 <erisco> sortBy (comparing (map (const ()))) [[1..], [1..]]
13:27:20 <erisco> > sortBy (comparing (map (const ()))) [[1..], [1..]]
13:27:26 <SamB> you better hope they're unequal ;-)
13:27:26 <lambdabot>   mueval-core: Prelude.read: no parse
13:27:26 <lambdabot>  mueval: ExitFailure 1
13:27:31 <jmcarthur_work> erisco, correct, so this only helps if no more than one list is infinite
13:27:42 <bgs100> Saizan, Ok, I edited my PATH...
13:27:49 <blsecres> OK, then what does the instance Functor ((->) t) tell me?  that fmap is defined for a Reader type?
13:27:51 <erisco> jmcarthur_work, there is no way to assert that they are of equal length?
13:27:56 <Gracenotes> you might be able to have a special marker for an infinite list
13:28:05 <jmcarthur_work> erisco, what is equal length?
13:28:05 <Saizan> except that lambdabot is not so nice to work with either..
13:28:09 <Gracenotes> Natural is pretty simple, does not do this
13:28:12 <erisco> jmcarthur_work, the two infinite lists
13:28:18 <Berengal> @type fmap
13:28:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:28:23 <jmcarthur_work> erisco, is infinity equal to infinity?
13:28:29 <bgs100> Saizan, ok, haskell-src installed...
13:28:35 <SamB> jmcarthur_work: let me get back to you on that
13:28:36 <Berengal> blsecres: now replace 'f' with ((->) t) in the definition of fmap
13:28:38 <ehird> jmcarthur_work: mu
13:28:52 <erisco> jmcarthur_work, neither are well-defined, so no, but
13:28:55 <Berengal> blsecres: you get 'fmap :: (a -> b) -> (t -> a) -> (t -> b)
13:28:59 <pikhq> erisco: The only way to do that is have a tuple of list and length. ... Or a datatype with list and length.
13:29:08 <erisco> jmcarthur_work, I do not want my program to blow up if I have two infinite lists in the list I am sorting
13:29:15 <erisco> jmcarthur_work, what if I just want infinite lists to the back?
13:29:28 <Berengal> erisco: the two infinite lists might not be compared...
13:29:37 <jmcarthur_work> erisco, they will be at the back anyway
13:29:42 <erisco> pikhq, but how do I discover which lists are infinite?
13:29:46 <SamB> yes, but in no order
13:29:57 <ehird> erisco: You can't.
13:29:58 <SamB> erisco: you can't
13:29:59 <erisco> Berengal, jmcarthur_work, not if one gets compared to the other, which is bound to happen
13:30:07 <jmcarthur_work> erisco, you would have to carry extra information with them to know that
13:30:10 <ehird> erisco: If you're asking the question of why, you probably should be doing something differently ;-)
13:30:12 <Berengal> erisco: Yes, there's that :P
13:30:13 <erisco> SamB, yes, no particular order, but that would be expected
13:30:19 <jmcarthur_work> erisco, it's not bound to happen every time
13:30:31 <SamB> erisco: I mean, they order would never resolve
13:30:37 <bgs100> Saizan, Am I going to have to go through something like this every time? :P
13:30:38 <SamB> so you wouldn't be able to get them out again
13:30:42 <erisco> jmcarthur_work, I would never write an application dealing with infinite lists and expect it not to
13:30:42 <bgs100> Agh!
13:30:44 <pikhq> erisco: It's impossible to do what you want.
13:30:45 <bgs100> Gah*
13:30:50 <pikhq> Short of a halting oracle.
13:30:51 <jmcarthur_work> > take 2 (sortBy (comparing (map (const ()))) [[1..], [1..], [1..3], [2..4]])
13:30:57 <lambdabot>   mueval-core: Prelude.read: no parse
13:30:57 <lambdabot>  mueval: ExitFailure 1
13:31:02 <jmcarthur_work> oh duh
13:31:10 <SamB> erisco: well, then don't write those ;-P
13:31:14 <Saizan> bgs100: nah, there are some problematic packages, but they should be a minority
13:31:38 <bgs100> Saizan, http://pastebin.ubuntu.com/213919/
13:31:44 <bgs100> *sigh*
13:31:47 <erisco> okay, so back to my first thing here, why bother dealing with infinite lists if it is not guaranteed to be safe anyhow?
13:31:48 <jmcarthur_work> > head (sortBy (comparing (map (const ()))) [[1..], [1..3]])
13:31:49 <lambdabot>   [1,2,3]
13:32:01 <ehird> erisco: "safe"?
13:32:05 <ehird> Infinite lists are "safe".
13:32:06 <jmcarthur_work> erisco, it's safe, just not guaranteed to terminate
13:32:12 <ehird> You just can't do impossible things with them.
13:32:13 <natthew> Saizan: What is the difference between Data.Binary and Data.ByteString.Lazy?
13:32:13 <Saizan> bgs100: using a somewhat old version of ghc doesn't help :)
13:32:15 <pikhq> erisco: Infinite lists occur by consequence of having lazy semantics.
13:32:29 <erisco> whatever, it would not terminate
13:32:31 <bgs100> Saizan, :'(
13:32:32 <ehird> natthew: everything
13:32:37 <ehird> erisco: So don't do that operation.
13:32:42 <erisco> and also my question is why do we have to use () or const at all?
13:32:49 <ehird> bgs100: your ghc came out in like march 08
13:32:57 <ehird> bgs100: don't blame us :)
13:33:01 <pikhq> ... You really don't want operations that would not be guaranteed to terminate?
13:33:01 <jmcarthur_work> erisco, you don't. you could use genericLength and Natural instead
13:33:13 <ehird> pikhq: Hey, Total Functional Programming is a good idea.
13:33:16 <bgs100> Saizan, Will the repos extra packages work with a newer version? Will I need them with a newer version?
13:33:20 <ehird> The only issue is sub-TCness. :)
13:33:29 <Gracenotes> comparing (map (const ())) <=> comparing length
13:33:29 * pikhq replaces erisco's computer with a push-down automaton.
13:33:32 <Saizan> natthew: Data.Binary is a lib for [de]serialization, Data.ByteString.Lazy is just a sequence of bytes (but quite fast)
13:33:36 <Berengal> genericLength and Natural is the same as comparing by map (const ())
13:33:48 <jmcarthur_work> erisco, infinite lists allow us to do a lot of very convenient things
13:34:10 <ehird> pikhq: you can do better than that without halting
13:34:15 <ehird> you can do ackermann for instance
13:34:19 <ehird> *without non-halting
13:34:19 <erisco> Berengal, what operations is comparing doing exactly?
13:34:22 <Berengal> erisco: We have to map (const ()) to make sure we're not sorting them by lexicographical ordering
13:34:25 <pikhq> ehird: True.
13:34:32 <jmcarthur_work> > let fibs = zipWith (+) [0..] (tail fibs) in take 10 fibs
13:34:36 <Saizan> bgs100: repos as in apt-get? no they won't work with a newer version, you'd have to find binary packages for that new version
13:34:38 <lambdabot>   mueval-core: Prelude.read: no parse
13:34:38 <lambdabot>  mueval: ExitFailure 1
13:34:49 <ehird> Saizan: he could just add an apt repo with the latest ghc
13:34:51 <ehird> dunno what tho
13:34:53 <jmcarthur_work> i suck at life
13:35:03 <Saizan> ehird: is there one?
13:35:09 <pikhq> jmcarthur_work: let fibs = 0:1:zipWith (+) fibs (tail fibs)
13:35:11 <ehird> i think so. maybe
13:35:16 <jmcarthur_work> right
13:35:17 <Berengal> @type primes
13:35:19 <lambdabot> Not in scope: `primes'
13:35:20 <erisco> Berengal, clearly comparing takes your function and returns a new function that applies it to both sides of a set of operations on x
13:35:23 <jmcarthur_work> my mind failed to recreate that properly
13:35:23 <bgs100> Saizan, I mean, like the libghc6-<blank>-dev packages? Like network and parsec? Will I need those?
13:35:24 <Berengal> @hoogle primes
13:35:24 <lambdabot> No results found
13:35:34 <erisco> Berengal, so I presume it is the same as compare, testing for EQ, GT, or LT?
13:35:38 <ehird> bgs100: you can just 'cabal install parsec'.
13:35:59 <jmcarthur_work> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in take 10 fibs -- look at what infinite lists can do!
13:36:01 <Saizan> bgs100: if you get the generic linux bindist from haskell.org those will be included
13:36:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
13:36:02 <Berengal> erisco: it's the same as "on compare", where on is another function...
13:36:03 <Berengal> @type on
13:36:05 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:36:12 <pikhq> erisco: Except that it compares based on a function of x, not on straight equality.
13:36:28 <erisco> pikhq, yes, that is what I tried to say
13:36:35 <ehird> pikhq: *of (X,Y)
13:36:49 <Saizan> bgs100: and you can't use libghc6-foo-dev with a ghc that doesn't come from apt-get
13:36:57 <bgs100> :P
13:37:00 <erisco> okay, so here is what it must boil down to then in my confusion
13:37:07 <pikhq> :t comparing
13:37:07 <bgs100> This is getting just a little tedious... :P
13:37:08 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:37:13 <erisco> how are >, <, and == carried about between two lists?
13:37:19 <erisco> and do not give me type signatures please :s
13:37:24 <pikhq> ehird: Function of x. ;)
13:37:30 <ehird> You should learn how to read type signatures, erisco.
13:37:33 <erisco> is it compared by the sum?
13:37:36 <ehird> You'll have to eventually.
13:37:39 <pikhq> > [1,2,3,4] == [3,4,5,6]
13:37:41 <lambdabot>   False
13:37:43 <erisco> ehird, I am not avoiding it
13:37:46 <pikhq> > [1,2,3,4] <= [3,4,5,6]
13:37:47 <lambdabot>   True
13:37:50 <Berengal> erisco: you should look at the 'compare' function instead
13:37:53 <pikhq> > [1,2,3,4] > [3,4,5,6]
13:37:54 <lambdabot>   False
13:37:59 <pikhq> Any questions?
13:38:14 <erisco> yes
13:38:16 <bgs100> > [1,2,3] `compare` [4,5,6]
13:38:17 <tromp> > let fibs x y = x : (fibs y (x + y)) in fibs 0 1
13:38:18 <lambdabot>   LT
13:38:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:38:20 <Berengal> erisco: It returns either LT, EQ or GT.
13:38:29 <erisco> whoa let me elaborate for a second
13:38:36 <Saizan> bgs100: just enjoy lambdabot on irc for now, maybe :)
13:38:44 <Berengal> @src [a] compare
13:38:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:38:47 <Berengal> :(
13:38:56 <pikhq> @src compare :: [a]
13:38:57 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:39:02 <erisco> I just want to know how [1,2] == [3,4] is carried out. is it effectively doing 1 == 3 && 2 == 4?
13:39:03 <ehird> pikhq: no
13:39:05 <pikhq> @src compare
13:39:05 <lambdabot> compare x y | x == y    = EQ
13:39:06 <lambdabot>             | x <= y    = LT
13:39:06 <lambdabot>             | otherwise = GT
13:39:06 <ehird> @src [] compare
13:39:07 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:39:10 <ehird> oh
13:39:16 <ehird> it isn't typeclassed.
13:39:24 <jmcarthur_work> yes it is
13:39:26 <ehird> erisco: yes
13:39:29 <jmcarthur_work> it just has a default
13:39:31 <erisco> and is [1,2] < [3,4] effectively doing 1 < 3 && 2 < 4?
13:39:32 <ehird> jmcarthur_work: ah
13:39:36 <Berengal> compare [] (y:ys) = GT; compare (x:xs) [] = LT; compare (x:xs) (y:ys) | x < y = LT; | x > y = GT; | otherwise = compare xs ys
13:39:51 <Berengal> That's for lists
13:39:55 <Phillemann> Is there a Console.GetOpt library where you can specify required options?
13:40:01 <erisco> okay then, I completely understand how sortBy (comparing (map (const ()))) [[1..], [1,2,3,4,5]] works then
13:40:01 <pikhq> What Berengal said.
13:40:08 <jmcarthur_work> erisco, consider what you would want string comparison to do
13:40:12 <jmcarthur_work> :)
13:40:33 <erisco> it seems far less magical and "wtf-ish" now, hurrah
13:40:38 <bgs100> Saizan, Maybe I should just delete all the stuff I've done today (e.g., remove cabal and that extra I apt-got) and keep reading the tutorial? :P
13:40:41 <pikhq> jmcarthur_work: Alphabetical and not ASCIIbetical comparison? :P
13:40:49 <Berengal> erisco: Wait until you hear about monoids
13:40:57 <bgs100> s/extra/extra stuff
13:40:58 <jmcarthur_work> ha
13:41:15 <erisco> Berengal, thank-you for bringing up that piece of code and helping my understand it
13:41:27 <erisco> jmcarthur_work, pikhq, thanks as well
13:41:30 <Berengal> > sortBy (comparing length `mappend` comparing (take 2) `mappend` flip (comparing (drop 2))) (words "asdf fds sasddf fdssa dfdsa adf d")
13:41:32 <lambdabot>   ["d","adf","fds","asdf","dfdsa","fdssa","sasddf"]
13:42:15 <Philonous> @type comparing
13:42:16 <Berengal> I could probably make a better example list to sort...
13:42:16 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:42:20 <jmcarthur_work> i honestly have no idea what the purpose of that was
13:42:38 <Berengal> > sortBy (comparing length `mappend` comparing (take 2) `mappend` flip (comparing (drop 2))) (words "abcd abc abdc dcba acb")
13:42:40 <lambdabot>   ["abc","acb","abdc","abcd","dcba"]
13:42:48 <pikhq> Berengal: Comparing by the length, then the first two characters, then the last two?
13:43:01 <pikhq> Erm. "flip".
13:43:06 <Saizan> bgs100: you can keep cabal, remove the things from apt-get, and install the generic linux package from haskell.org/ghc, that'll probably give you less problems in the future
13:43:10 <pikhq> Last two with a reversed comparison.
13:43:19 <pikhq> I fail to see how that's useful.
13:43:23 <Berengal> pikhq: Then everything but the first two, but flipped
13:43:35 <Berengal> pikhq: It's more useful with a different comparison really..
13:43:37 <pikhq> Nice bit of code, though.
13:44:15 <jmcarthur_work> @src Ordering mappend
13:44:15 <bgs100> Saizan, Meh, i'll just restart, continue with the tutorial, and try again when I'm (at least mostly) done.
13:44:16 <lambdabot> Source not found.
13:44:20 <jmcarthur_work> @src mappend Ordering
13:44:20 <lambdabot> Source not found. You type like i drive.
13:44:24 <Berengal> > sortBy (flip (comparing length) `mappend` flip compare) (words "this will be sorted by the longest word first and equal length words will be sorted in reverse alphabetical order")
13:44:26 <lambdabot>   ["alphabetical","reverse","longest","sorted","sorted","length","words","ord...
13:44:43 <pikhq> s/alphabetical/ASCIIbetical/
13:44:57 <Berengal> Yeah...
13:45:10 <Berengal> But I said "this string", and it holds for that string
13:45:16 <pikhq> True.
13:45:28 <ehird> no, pikhq
13:45:29 <ehird> Unibetical.
13:45:35 <ehird> Diabetical!
13:45:39 <pikhq> ehird: Ah, yes.
13:45:57 <pikhq> Only ASCIIbetical for a subset of the possible strings.
13:46:01 <Berengal> > ord "Ã¥"
13:46:02 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:46:06 <Berengal> > ord 'Ã¥'
13:46:08 <lambdabot>   229
13:46:12 <pikhq> (just like it's only alphabetical for a subset of the possible strings)
13:46:12 * Berengal is too used to python strings...
13:46:13 <jeffwheeler> It sure would be cool if we had a synonym for alphabetical in which the letters actually were . . .
13:46:27 * pikhq is used to Tcl strings.
13:46:35 <jeffersonheard> Does the haskell-cafe mailing list accept attachments at all?
13:46:53 <Berengal> I guess there's probably some localized unicode compare functions floating around...
13:47:06 <Berengal> Or if not it's not too hard to write, just very tedious
13:47:47 <ehird> 21:46 jeffwheeler: It sure would be cool if we had a synonym for alphabetical in which the letters actually were . . .
13:47:49 <ehird> ...what?
13:48:08 <jeffwheeler> ehird: I mean, they were in alphabetical order
13:48:18 <deech> Hi all, a delayed followup. I was having trouble install haskelldb with sqlite3. I finally got it working only to find out that introspection on Sqlite3 databases is apparently not supported. My db structure is pretty simple, is there a tutorial that shows me how to build my own modules?
13:48:18 <jeffwheeler> ehird: alp, then h is back before l
13:48:29 <ehird> jeffwheeler: excuse me?
13:48:52 <Berengal> deech: http://www.fh-wedel.de/~si/HXmlToolbox/index.html
13:49:00 <Berengal> Although it's not the best of tutorials...
13:49:05 <Berengal> It'll get you started at least
13:49:29 <Berengal> Actually, I guess it's not a tutorial at all, but it has links to some documentation
13:49:30 <jeffwheeler> ehird: the letters were in the same order as they occur in the alphabet; in the hypothetical word, only letters that occurred after the previous letter in the alphabet could occur following that letter
13:49:44 <ehird> i see.
13:49:48 <ehird> jeffwheeler: so like
13:49:52 <jeffwheeler> ehird: say, the hypothetical word "alpry" is in alphabetical order
13:49:53 <ehird> abcz
13:49:55 <ehird> right
13:49:58 <jeffwheeler> yeah
13:50:02 <ehird> jeffwheeler: alphabet-walking
13:50:14 <deech> berengal, where does it talk about  haskelldb?
13:50:32 <ehird> deech: use takusen
13:50:34 <Berengal> deech: doh, wrong link...
13:50:40 <ehird> it's like haskelldb but actually maintained from what i gather
13:50:53 <Berengal> http://haskelldb.sourceforge.net/
13:51:08 <Berengal> I should look into takusen too
13:51:13 <deech> berengal, I looked there. It's pretty old.
13:51:21 <thoughtpolice> takusen is pretty neat
13:51:25 <Berengal> deech: It is, but it's the best you'll get, I'm afraid
13:51:46 <ehird> deech: HaskellDB IS old.
13:51:50 <ehird> It hasn't been touched for years.
13:52:03 <deech> ehird, hackage shows an update in February
13:52:23 <ehird> Perhaps making it compile with recent ghc versions.
13:52:32 <deech> berengal, have you checked this out? http://www.deanberris.com/mental-blabberings/2009/3/17/the-haskell-experiment-haskelldb-http-and-monads.html
13:52:38 <Ycros> I use HDBC
13:52:50 <ehird> deech: i would highly recommend against trying to use haskelldb
13:52:51 <pikhq> Clearly Haskell needs an implementation of the Unicode collation algorithm.
13:53:01 <blsecres> so how would I create something with the type ((->) r)?  There's no simple 'click here for definition' in the documentation for Functor like there is for Maybe, Either, etc
13:53:23 <ehird> blsecres: ((->) r) x) = (r -> x)
13:53:28 <deech> ehird, after blowing most of the trying to get it up and running I think you are right. Shame though, it looked pretty neat.
13:53:36 <ehird> deech: takusen does much the same stuff
13:53:37 <ehird> from what i gather
13:55:36 <deech> ehird, takusen it is. Thanks!
13:55:49 * Berengal installs takusen as well
13:55:54 <ehird> deech: i hold no responsibility for any explosions.
13:56:02 <ehird> seeing as i haven't tried it my self yet.
13:56:04 <ehird> *myself.
13:56:09 <ehird> well, without the '.'
13:56:22 <Berengal> ehird: But with the '.' you have?
13:56:43 <Gracenotes> type (->) a b = [... sekrit native thing ...]
13:56:45 <Berengal> step 1: cabal install takusen, worked flawlessly
13:56:47 <ehird> new sentence update v3 issued today:
13:56:50 <ehird> seeing as i haven't tried it myself yet.
13:57:03 <ehird> blsecres: (->) is just a function
13:57:06 <Gracenotes> constructorless X:
13:57:53 <blsecres> ehird: a function with no argument or return value?
13:57:53 <Gracenotes> Either Int Int is a type. So is (->) Int Int, or as we would notate it, Int -> Int.
13:58:01 <ehird> blsecres: ((->) r) is partially applied
13:58:12 <ehird> blsecres: if you do "instance Monad ((->) r)", that becomes the m in "Monad m"
13:58:16 <ehird> blsecres: then the definition does "m a"
13:58:22 <ehird> giving us (((->) r) a)
13:58:23 <ehird> â
13:58:25 <ehird> r -> a
13:58:51 <ehird> blsecres: if you can do "foo OPERATOR bar", "(OPERATOR) foo bar" also works
13:58:55 <ehird> so (->) r a comes out to r -> a
13:59:03 <Gracenotes> similarly, you could make a Monad (Either r), and m a would be Either r a
13:59:14 <ehird> Gracenotes: I think he thinks (->) is a full type like (r -> a)
13:59:37 <Berengal> @type fmap ?x ?f (5::Int)
13:59:38 <lambdabot> forall a b. (?f::Int -> a, ?x::a -> b) => b
13:59:53 <blsecres> yeah, :type (->) is a parse error in ghci
14:00:00 <Beelsebob> > undefined :: Int `Either` Int -- does this work?
14:00:02 <lambdabot>   * Exception: Prelude.undefined
14:00:06 <Beelsebob> oh, it does
14:00:07 <Beelsebob> shiny
14:00:22 <Gracenotes> blsecres: it is because (->) is not an expression, it is a type
14:00:24 <Beelsebob> now to bind a synonym Or = Either
14:00:40 <erisco> @src intersperse
14:00:41 <lambdabot> intersperse _   []     = []
14:00:41 <lambdabot> intersperse _   [x]    = [x]
14:00:41 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
14:00:44 <Berengal> Beelsebob: (||) = Either, maybe?
14:00:45 <Beelsebob> @kind (->)
14:00:47 <lambdabot> ?? -> ? -> *
14:00:49 <Gracenotes> most values have constructors. For example, Either has the constructors Left and Right. Functions are different; they're more built-in.
14:00:56 <Beelsebob> blsecres: see, works just fine
14:01:00 <Beelsebob> if you use the right operation
14:01:10 <ehird> Beelsebob: i don't think that helps :P
14:01:12 <Beelsebob> Berengal: that would be nice, yes
14:01:20 <Berengal> Functions have a constructor: whitespace
14:01:20 <Gracenotes> by the way you can do ":i (->)"
14:01:27 <Berengal> But you can't pattern match on it
14:01:45 <blsecres> Gracenotes: understood, now how to construct something of that type
14:01:45 <erisco> is there a way I can generate a large list of lists for testing purposes?
14:01:47 <Berengal> Beelsebob: -XTypeOperators ?
14:01:53 <blsecres> Gracenotes: ah, thanks
14:01:57 <Beelsebob> Berengal: *nod*
14:02:21 <Gracenotes> it won't do much with just Prelude though, some of the interesting definitions are in Control.Arrow and Control.Applicative
14:02:31 <ehird> what are those ?x things called btw? in the -Xfoo
14:02:46 <Berengal> Beelsebob: I suddenly got this vision of completely unreadable source...
14:02:47 <Gracenotes> -XImplicitParams
14:02:53 <ehird> 22:01 Berengal: Functions have a constructor: whitespace                       ;; a better constructor would be (\x -> y) :-P
14:02:56 <Beelsebob> Berengal: how so?
14:03:38 <Beelsebob> Berengal: of note btw, I always wanted (a | b) to be a disjunctive tuple, if (a, b) is gonna be a conjunctive one
14:03:44 <Berengal> Beelsebob: I've noticed that when I go back to the sources where I've defined things like (.) = fmap and (++) = mappend, things don't make as much sense as when I wrote it
14:03:53 <Berengal> Beelsebob: Agreed
14:03:54 <erisco> never mind, got it
14:03:58 <MyCatVerbs>  Beelsebob don't you mean if (a * b) is going to be a conjunctive one?
14:04:01 <ehird> the fun thing about implicit parameters
14:04:06 <ehird> is that it makes "a" and "() -> a" distinct
14:04:16 <Gracenotes> wha
14:04:18 <Beelsebob> MyCatVerbs: no, I'd much rather (a * b) were actual pairing
14:04:19 <ehird> "let add :: (?x::a, ?y::a, Num a) => () -> a; add () = ?x + ?y" works
14:04:24 <Beelsebob> but (a, b) *is* tupling
14:04:24 <ehird> "let add :: (?x::a, ?y::a, Num a) => a; add = ?x + ?y" doesn't
14:04:24 <Berengal> The thing about haskell "syntax" is that most of it isn't, it's just builtin functions, and can be rebound to other names
14:04:35 <Beelsebob> and if we're going to put up with that, we might as well get (a | b) as well
14:05:02 <Gracenotes> ehird: ..try turning off monomorphism restriction?
14:05:06 <MyCatVerbs> Beelsebob: You've lost me. What's the distinction? Pairing, conjunctive tuples, disjunctive tuples?
14:05:09 * Gracenotes dunnos
14:05:11 <ehird> Gracenotes: you get "unbound implicit parameters"
14:05:13 <ehird> it's not a bug
14:05:25 <ehird> I'd like implicit parameters a lot more if you could assign them in a call like "add ?x:3 ?y:4 ()"
14:05:26 <ehird> ocaml does that
14:05:29 <Beelsebob> MyCatVerbs: I'd like (a | b) to be equal to the type Either a b
14:05:32 <Berengal> Beelsebob: Wouldn't (a | b) mess with other syntax though?
14:05:41 <Beelsebob> Berengal: it would, but so does (a , b)
14:05:48 <opqdonut> well it's in a type
14:05:50 <MyCatVerbs> Beelsebob: it *sounds* like a conjunctive tuple of A and B is (A*B) in data structure algebra, and a disjunctive tuple of A and B is (A+B).
14:05:50 <opqdonut> so not really
14:05:51 <Beelsebob> it stops us using , nicely in all sorts of places
14:06:08 <Beelsebob> MyCatVerbs: exactly
14:06:09 <Gracenotes> cringe
14:06:28 <Berengal> Beelsebob: (a, b) doesn't, because there's nothing else there at the moment
14:06:38 <MyCatVerbs> Beelsebob: (A*B) is exactly equivalent to (A,B) if data is strict!
14:06:49 <Beelsebob> MyCatVerbs: "if"
14:06:57 <Berengal> Beelsebob: I'm coming at this from a "extend the current language" perspective, not the "create a similar, but new language" one
14:07:03 <Beelsebob> Berengal: my ideal outcome would be to bin the list syntactic sugar that gains us nothing, and use , as a "capital" letter in operators
14:07:13 <Beelsebob> so (,) were valid type operator
14:07:22 <Beelsebob> that happened to do pairing
14:07:24 <opqdonut> wow
14:07:26 <Berengal> ,* ,|?
14:07:27 <lunabot>  luna: parse error on input `,'
14:07:27 <MyCatVerbs> Beelsebob: not an issue. None of Haskell's data structures follow the usual rules of data structure algebra. For one thing, every possible type is inhabited by at least _|_.
14:07:47 <Beelsebob> MyCatVerbs: that's "usual" for some definitions of usual
14:07:54 <Beelsebob> it's not the only choice
14:07:58 <Beelsebob> but it's one possible one
14:08:09 <Beelsebob> and a not uncommon one
14:08:35 <MyCatVerbs> It's a really, really parsimonious choice, though. For one thing, it's a choice in which symbolic differentiation works correctly, and which preserves combinatorial properties.
14:08:37 <blsecres> thanks all for the answers/pointers
14:09:18 <Beelsebob> MyCatVerbs: *nod*
14:09:27 <ManateeLazyCat> I want to use Cairo write some GTK widget with Haskell level, and not C level. But i haven't found any code that do this. Someone know where i can find code that use Cairo (with Haskell) write GTK widget?
14:09:35 <zakwilson> Would someone care to take a quick look at a probably obvious problem for me?
14:09:38 <Beelsebob> MyCatVerbs: my main reason for wishing that Haskell went the other way is actually that fmap on pairs can never be defined nicely in Haskell
14:09:45 <opqdonut> MyCatVerbs: care to elaborate?
14:09:48 <Beelsebob> because if you define it nicely it breaks the functor laws
14:09:48 <zakwilson> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6759#a6759 <-- fails to compile with "The last statement in a 'do' construct must be an expression"
14:09:56 <opqdonut> MyCatVerbs: what combinatorial properties and in which way correctly
14:10:04 <Beelsebob> > fmap (+1) undefined
14:10:05 <conal> ManateeLazyCat: have you already found gtk2hs?
14:10:06 <lambdabot>   No instance for (GHC.Show.Show (f a))
14:10:06 <lambdabot>    arising from a use of `M1943052438...
14:10:16 <ManateeLazyCat> conal: Yep, i use it always.
14:10:17 <Beelsebob> > fmap (+1) undefined :: (Int, Int)
14:10:19 <lambdabot>   * Exception: Prelude.undefined
14:10:27 <Beelsebob> > second (+1) undefined :: (Int, Int)
14:10:29 <lambdabot>   (* Exception: Prelude.undefined
14:10:33 <conal> ManateeLazyCat: oh, okay.  and you're looking how to create a new kind of widget?
14:10:44 <ManateeLazyCat> conal: Yep
14:11:20 <ManateeLazyCat> conal: I found C code that use Cairo implement widget, but i want implement widget with Haskell level
14:11:37 <Berengal> zakwilson: No 'in' after 'let' in a 'do'
14:11:42 <conal> ManateeLazyCat: got it.  if you find out, i'd like to know also!  i'd slso like to use opengl + hlsl to make new gtk widgets in haskell.
14:11:48 <conal> (also)
14:11:52 <Saizan> zakwilson: remove the "in" and align to the left
14:12:11 <ManateeLazyCat> conal: The demo program in gtk2hs not enough detail.
14:12:24 <Saizan> zakwilson: like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6759#a6760
14:12:36 <ManateeLazyCat> conal: Now i think use Cairo binding can implement widget with Haskell.
14:12:49 <ManateeLazyCat> conal: I just want read more code before i write my own.
14:13:03 <ManateeLazyCat> conal: But i haven't find it.
14:13:16 <ManateeLazyCat> conal: You know where i can find those code?
14:13:40 <Beelsebob> zakwilson: also, out = hPutStrLn d . chr
14:13:52 <conal> ManateeLazyCat: i'm just starting with gtk2hs, so no.  you could try gtk2hs-users@lists.sourceforge.net (found on http://www.haskell.org/gtk2hs/documentation/)
14:14:13 <ManateeLazyCat> conal: Yep, i have send mail to gtk2hs-user.
14:15:03 <ManateeLazyCat> zakwilson: Install hlint by cabal, you can use hlint give your code suggestion after you code complete.
14:15:20 <ManateeLazyCat> zakwilson: Of course, you have to find it self if you got a error. :)
14:16:16 <ManateeLazyCat> Another question, i try to transform C to Haskell, how to use c2hs ?
14:16:28 <zakwilson> ManateeLazyCat: thanks
14:17:07 <ehird> ManateeLazyCat: c2hs doesn't do that i think
14:17:12 <ManateeLazyCat> conal: I think it's not a problem, because gtk2hs have finish C bindings, just not enough demo code.
14:17:21 <ehird> it just generates a Haskell binding for a C library
14:17:48 <ManateeLazyCat> ehird: c2hs just generate Haskell `interface`, but it can't transform C code automatically?
14:18:02 <ehird> Uhm, of course...
14:18:11 <ManateeLazyCat> ehird: I see. :)
14:18:18 <ManateeLazyCat> zakwilson: No problem.
14:18:26 <ehird> Such a task would be difficult and rather pointless.
14:19:10 <ManateeLazyCat> zakwilson: If you use Emacs, you can install hlint.el (a interface for hlint in Emacs), then you just hit "C-c l" in buffer, will generate code suggestion, very handy.
14:19:12 <zakwilson> Beelsebob: hPutStrLn is not what I want, but (hPutChr . chr) works.
14:19:32 <zakwilson> ManateeLazyCat: I do use Emacs and I'll be doing that.
14:20:07 <zakwilson> There's so much to learn.
14:20:32 <ManateeLazyCat> zakwilson: Yep, but interested....
14:21:45 <Badger> @src hPutStrLn
14:21:46 <lambdabot> hPutStrLn hndl str = do hPutStr  hndl str; hPutChar hndl '\n'
14:21:52 <Badger> oops
14:21:56 <Badger> @index hPutStrLn
14:21:57 <lambdabot> System.IO
14:22:30 <ManateeLazyCat> conal: I think it's not difficult that write Cairo widget with Haskell level, just analysis C code logic, then use Haskell bindings to implement same function.
14:23:06 <ManateeLazyCat> conal: I think that's be cool if i can write all widget with Haskell level.... and will be wonderful...
14:23:15 <conal> ManateeLazyCat: indeed
14:24:19 <ManateeLazyCat> conal: I have use gtk2hs two month, now i need write widget with Haskell, i don't like write widget with C level, then write Haskell binding again. That's painful...
14:25:25 <ManateeLazyCat> conal: Please concat me if you found any useful code about Cairo widget.
14:26:44 <ehird> please concat me? :D
14:26:55 <ehird> > concat ["Manatee","Lazy","Cat"]
14:26:56 <lambdabot>   "ManateeLazyCat"
14:27:21 <ManateeLazyCat> contact
14:27:56 <ManateeLazyCat> is contact, typo
14:28:06 <bgs100> bbl
14:28:47 <ManateeLazyCat> ehird: I use english helper in Emacs, so i will typo word sometimes.
14:28:51 <ehird> :)
14:30:39 <ManateeLazyCat> Thanks all! Bye ...
14:33:34 <erisco> http://pastebin.ca/1490079 is there a better way to create this function? it is designed to work like Python's join
14:33:59 <erisco> and for those not familiar, join ',' ["foo", "bar"] should give "foo,bar"
14:34:00 <opqdonut> > intercalate ", " ["a","b","c"]
14:34:01 <lambdabot>   "a, b, c"
14:34:10 <kyagrd> Again, hackage saved tons of my work.
14:34:14 <opqdonut> @src intercalate
14:34:15 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
14:34:16 <erisco> @src intercalate
14:34:17 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
14:34:18 <Berengal> join is a different function in haskell...
14:34:22 <opqdonut> @src intersperse
14:34:23 <lambdabot> intersperse _   []     = []
14:34:23 <lambdabot> intersperse _   [x]    = [x]
14:34:23 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
14:34:27 <Berengal> @type join
14:34:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:34:29 <kyagrd> Super many thanks to the logic-TPTP library
14:34:52 <erisco> Berengal, sorry if I conflicted with another name. it is not in prelude and I did not bother beyond that
14:35:18 <Berengal> erisco: Heh, no worries. It's not like you're breaking the internet or anything
14:35:21 <opqdonut> erisco: yeah, that's pretty good
14:35:36 <opqdonut> erisco: foldr (++) is way better than foldl (++) in terms of performance
14:36:00 <ehird> erisco: why not use intercalate?
14:36:39 <Berengal> pythonJoin = (join.) . intersperse
14:36:39 <erisco> ehird, it is an exercise in the "real world haskell" book and even if I did know of the function intercalate I would not have been allowed to use it
14:36:44 <ehird> ah
14:37:00 <erisco> but it is good to know it so thanks for the mentioning opqdonut and ehird
14:37:16 <jeffwheeler> @type (join.) . intersperse
14:37:18 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:37:21 <Berengal> Rewriting most of the Prelude is part of learning haskell...
14:37:39 <Botje> so is writing your own monad tutorial
14:37:39 <erisco> opqdonut, only when the length of each part is small in comparison to the number of parts, really
14:37:52 <opqdonut> erisco: (the short reason for why foldl (++) is bad is that xs++ys has to make a copy of xs. thus we should keep prepending short lists to a longer one and not the other way around)
14:38:46 <opqdonut> (so "foldr (++) lists" will make a linear amount of copies of the cons cells while "foldl (++) lists" will copy quadratically)
14:39:06 <opqdonut> (of course, difference lists are a good idea if you are catenating a lot)
14:39:42 <opqdonut> (difference lists being functions of type [a]->[a] which take a postfix as an argument and return the built list, so (++) turns into (.))
14:42:22 <erisco> opqdonut, but like I said, if each part is long but the number of parts is few, the foldl is better optimized
14:42:43 <erisco> opqdonut, no? I might have that wrong :P
14:42:47 <erisco> and I wrote the function :(
14:43:24 <Berengal> foldr will always win over foldl for catenating lists
14:43:25 <opqdonut> erisco: no, foldr is good
14:43:26 <erisco> opqdonut, ah, yes, foldr would be better... I am just not thinking straight. if each part was long then by the time we append the third part we will be iterating over the length of the two previous parts which is bad
14:43:32 <opqdonut> indeed
14:43:39 <opqdonut> erisco: foldl is nice only with strict operations
14:43:43 <opqdonut> or strictish
14:44:01 <Berengal> If you can't foldl' you probably shouldn't foldl at all
14:44:08 <erisco> opqdonut, which I found out with my listMean function that you guys helped me get the stack overflows out of
14:44:27 <erisco> Berengal, I had used foldl' but never just foldl thus far... then again I have not written that much :P
14:45:15 <Berengal> foldl has few applications. The only one I can think of now is foldl (flip (:)) []
14:45:25 <erisco> which is reverse
14:45:30 <Berengal> Yep
14:45:45 <erisco> yay, I identified something in Haskell :P
14:46:11 <Berengal> Sometimes haskell makes me think SKI makes for a good language...
14:46:38 <pikhq> And Unlambda?
14:46:56 <Berengal> Eh, unlambda is strict
14:47:07 <tromp> LazyK?
14:47:11 <Berengal> There's lazyK
14:47:14 <Berengal> Yeah
14:47:30 <Berengal> Though to be honest I can't do a thing in either of those
14:47:33 <tromp> or binary lambda calculus...
14:47:41 <Berengal> BitXtreme
14:48:20 <erisco> but Haskell is *thee* functional language to learn, am I right?
14:48:41 <Berengal> At least I think it is
14:48:55 <Berengal> The least broken language currently :)
14:49:25 <erisco> good support, documentation, tutorials...
14:49:25 <Berengal> (Recent Java programming has done more to reinforce that impression than a year of pure haskell hacking ever did)
14:50:28 <Berengal> Actually, I'm somewhat disappointed by the documentation and tutorials for some of the libraries, but that doesn't just go for haskell...
14:50:38 <Berengal> I think I've just become accustomed to a certain standard
14:51:47 <inimino> the best of Haskell documentation is also the best documentation I've seen in any language
14:52:23 <Berengal> inimino: Yes, by far
14:53:50 <Berengal> I get the impression the haskell community has a greater ratio of good educators than other languages
14:58:46 <erisco> Berengal, yes
14:59:14 <erisco> Berengal, this may be because Haskell is far from mainstream and you also have to be pretty damn intelligent to grasp any of the concepts :P
14:59:53 * erisco goes away to make supper
15:00:51 <soupdragon> what's funny is how ridiculously SIMPLE haskell is,  you only need to understand what  =  means.. but nobody does
15:02:30 <Jarvellis> Haskell makes my head hurt, and i'm fairly sure that's my fault not its
15:03:01 <Berengal> What's interesting to me is how much smarter you are when programming in other languages
15:03:07 <Botje> head hurting good. that's your brain growing and bashing the inside of your skull
15:03:46 <Jarvellis> Well, to be honest i'm kinda trying to learn programming and keep getting distracted
15:03:48 <inimino> or your skull shrinking
15:03:57 <Jarvellis> By Lisp, Haskell, Brainfuck &c
15:04:25 <Berengal> Today I was demoing an early alpha of the project I'm working on to some other devs. One of them commented about some functionality he'd like added. After a few minutes of discussion the majority vote decided it had to be pushed to a future release, but by then I was already deploying my monoidal sort...
15:04:31 <ziman> no pain - no gain, no brain - no pain, (c) mauke, i guess.
15:04:55 <jmcarthur_work> Berengal, love it when that happens
15:05:40 <jmcarthur_work> i do not find that i am much smarter in other languages. i just feel tempted to use them in ways i probably shouldn't
15:06:01 <Berengal> jmcarthur_work: Smartness comes afterwards, I find...
15:06:06 <Jarvellis> There's nothing wrong with writing lisp in C
15:06:18 <Jarvellis> I assume that holds with writing haskell in <language x>
15:06:30 <opqdonut> except it's not as easy
15:06:37 <opqdonut> as writing lisp in language x :)
15:06:37 <jmcarthur_work> except that i can't write higher order polymorphic functions in c
15:06:40 <Berengal> thunking is hard :(
15:06:44 <opqdonut> yep
15:06:48 <Jarvellis> Sure you can
15:06:49 <Berengal> jmcarthur_work: You can now, with blocks
15:06:57 <Jarvellis> Step one, write haskell interpreter
15:07:05 <soupdragon> Jarvellis, I think it's a terrible thing to do
15:07:19 <jmcarthur_work> Berengal, blocks are in c?
15:07:21 * Jarvellis is often wrong, and will now be quiet
15:07:43 <soupdragon> Jarvellis, interpreter is ok
15:07:45 <Berengal> jmcarthur_work: They will be. I think some compilers have support for it already
15:08:01 <Berengal> jmcarthur_work: But I'm no C programmer, so I haven't paid much attention to it
15:08:19 <Berengal> Just enough to know that Java and C++ are now the only major languages with HOF
15:08:21 <Berengal> without*
15:08:34 <jmcarthur_work> what standard is this?
15:09:16 <hackagebot> httpd-shed 0.4 - A simple web-server with an interact style API (AndyGill)
15:09:16 <jmcarthur_work> i'm looking for a description of c blocks
15:09:40 <Berengal> jmcarthur_work: I'll try to dig out whatever article I got it from...
15:11:12 <Berengal> jmcarthur_work: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1370.pdf
15:11:15 <Berengal> page 3
15:11:22 <Berengal> clang has it
15:11:42 <jmcarthur_work> oh, apple extensions...
15:11:49 <jmcarthur_work> and i assume requiring gc, also
15:11:58 <jmcarthur_work> i'm afraid this is not the c i can use in a kernel
15:12:00 <Berengal> Not neccessarily
15:12:37 <Berengal> They'll be stack-allocated unless they can leave the scope
15:13:10 <Berengal> I assume it's possible to simply turn off the gc and heap-allocation somehow...
15:13:25 <jmcarthur_work> but then you can't just use arbitrary closures and i'm back at square one
15:14:02 <Berengal> Arbitrary closured does require gc, I believe...
15:14:19 <Berengal> bah, my typing sucks tonight...
15:14:35 <soupdragon> Your right
15:14:46 <Berengal> Anyway, yeah, if you want to pass closures around willy-nilly you need gc
15:15:45 <Berengal> But being able to pass them into a function call is still much more nifty than having to rewrite sort for every possible way of comparing data
15:15:46 <MoonPatrol> I like you guys.
15:16:38 <jmcarthur_work> the current C1x draft does not have blocks
15:16:56 <Berengal> jmcarthur_work: Shucks... Guess I've misinformed myself
15:18:14 <jmcarthur_work> so, as i was saying, you can't just write polymorphic higher-order functions in c ;)
15:19:10 <Berengal> I guess the answer is to write in some other language
15:19:22 <jmcarthur_work> like haskell!
15:19:28 <Berengal> Yes!
15:19:37 <jmcarthur_work> of course, no low-level kernel dev there either without writing a runtime
15:19:44 <Badger> @faq can Haskell be THE FUTURE/
15:19:44 <lambdabot> The answer is: Yes! Haskell can do that.
15:19:59 <Badger> Even with a trailing slash rather than a question mark!
15:20:06 <Badger> (bloody keyboard.)
15:20:30 <Berengal> It's 2009! Why do we still use languages without HOF?!
15:20:36 <opqdonut> HOF?
15:20:39 <opqdonut> ah
15:20:43 <opqdonut> higher order functions
15:20:45 <Berengal> higher-order-functions
15:20:53 <opqdonut> well, objects are closures
15:21:13 <Berengal> I still haven't seen a type-safe object-oriented language
15:21:13 <opqdonut> but in explicit, verbose and painful way
15:21:19 <jmcarthur_work> s/objects are closures/objects can be used to implement ugly closures/
15:21:28 <opqdonut> but those attributes are what code slaves tend to prefer
15:21:47 <Berengal> on the other hand, I used closures to simulate objects in python, and it worked flawlessly the first time around
15:21:49 <opqdonut> woops, for got an "an" there
15:22:17 <soupdragon> Berengal:How about Ocaml or Lisp?
15:22:47 <Berengal> soupdragon: lisp is dynamic, so not haskell-level typesafety. Ocaml I haven't tried, so I'm afraid I can't comment
15:23:11 <jadrian> Berengal: I don't know much about OO... why isn't Java typesafe or Eclipse
15:23:29 <soupdragon> It's haskell level..
15:23:45 <Berengal> jadrian: Eclipse is an IDE... Java needs RTTI to ensure you're not doing anything wrong
15:23:50 <jmcarthur_work> jadrian, e.g.:  null.someMethod() == boom
15:23:55 <jadrian> Berengal: sorry meant Eiffel
15:24:22 <Berengal> Which frequently leads to the pointless 'edit -> compile -> run -> exception -> repeat' cycle types are supposed to remove
15:24:35 <Berengal> jadrian: Haven't tried Eiffel either...
15:25:23 <jadrian> jmcarthur_work: isn't that on the same level as a pattern match that fails
15:25:44 <Berengal> Having runtime exceptions blow up in my face is okay in languages like python and ruby, but in Java writing tests take forever in comparison, and even simply compiling/deploying can take several minutes
15:25:59 <opqdonut> jadrian: non-exhaustive pattern matches can be detected compile-time
15:26:12 <opqdonut> and ghc even warns about them
15:26:17 <jadrian> opqdonut: I meant as in, head [ ]
15:26:32 <opqdonut> well yeah, head could be safer
15:26:45 <Berengal> jadrian: it's about the same as "foo (Just someObject) = someMethod someObject"
15:26:45 <opqdonut> but the real problem with java (and many other languages) is that subtyping is hard to get right
15:26:54 <jmcarthur_work> jadrian, arguably that is not type unsafe. it's semantically equiv to _|_. i guess null was a bad example, as that i guess is like _|_ as well
15:26:55 <opqdonut> so people resort to dynamic upcasts etc
15:27:16 <jmcarthur_work> yeah the real problem is definitely decent polymorphism
15:27:19 <Berengal> jmcarthur_work: Having null explicitly in the type increases typesafety
15:27:30 <Berengal> At least by my definition
15:27:34 <Berengal> Catches more bugs
15:27:56 <jmcarthur_work> Berengal, right, but null in java is kind of like _|_ in haskell
15:28:10 <Berengal> jmcarthur_work: Kind of, but not quite
15:28:18 <jadrian> jmcarthur_work: yeap that's what I meany
15:28:22 <soupdragon> not so much you can test it
15:28:22 <jmcarthur_work> Maybe is far nicer, of course
15:28:26 <jmcarthur_work> but even Maybe has _|_
15:28:34 <opqdonut> well we have to have non-total functions
15:28:38 <Berengal> Whenever I see head, or tail, or error, or whatever, I get nervous... In java you have to be nervous all the time
15:28:41 <opqdonut> total progrmaming can be a PITA
15:28:52 <jmcarthur_work> <3 total programming
15:29:00 <jmcarthur_work> i don't think it's so bad
15:29:19 <Berengal> totally total programming can be a PITA, but Haskell can be almost-total and still damned nice
15:29:21 <soupdragon> have you tried it? :p
15:29:33 <jmcarthur_work> i have tried it
15:29:39 <jmcarthur_work> i don't what the big deal is
15:29:41 <jmcarthur_work> *see
15:29:50 <jadrian> jmcarthur_work:  how do you deal with all those patterns that you know that never happen?
15:30:03 <soupdragon> what kig deal?
15:30:21 <jmcarthur_work> jadrian, if there are nonapplicable patterns you passed in the wrong type :P
15:30:37 <jmcarthur_work> but haskell doesn't make TP so easy i guess
15:30:47 <jmcarthur_work> i just mean TP generally
15:30:54 <jadrian> jmcarthur_work: hmmm I see so you'd say, move form lists to non-empty lists?
15:31:00 <jmcarthur_work> some languages don't make you use clearly impossibel patterns
15:31:05 <soupdragon> Writing a total program isn't hard at all
15:31:06 <jmcarthur_work> jadrian, yes
15:31:15 <jmcarthur_work> *impossible
15:31:15 <soupdragon> Writing a total program in a total language IS very hard
15:31:18 <jadrian> jmcarthur_work: but how to you do the "cast"?
15:31:31 <jadrian> jmcarthur_work: certainly you'd have to prove that you do get a non-empty list
15:31:48 <jadrian> jmcarthur_work: so we'd be talking about using something like coq
15:31:57 <jmcarthur_work> either use Maybe or use type-level indexing
15:31:57 <jadrian> jmcarthur_work: not a regular programming language
15:32:19 <jmcarthur_work> what is so nonregular about Coq?
15:32:25 <jmcarthur_work> that it's total?
15:32:31 <jadrian> jmcarthur_work: it has theorem proving capabilities
15:32:36 <jmcarthur_work> so does haskell
15:32:43 <jmcarthur_work> @djinn a -> b -> a
15:32:43 <jadrian> jmcarthur_work: it does??
15:32:44 <lambdabot> f a _ = a
15:32:45 <soupdragon> Haskell does not
15:33:19 <jmcarthur_work> a implies (b implies a)
15:33:19 <mike-burns> Being able to write Coq in Haskell doesn't mean that Haskell has theorem proving capabilities. Maybe.
15:33:41 <jmcarthur_work> it's not very general, of course
15:34:13 <jmcarthur_work> if i can construct a value for a type i have just proven that type
15:34:23 <jmcarthur_work> (besides _|_)
15:34:35 <ziman> @djinn ((a -> b) -> a) -> a
15:34:35 <lambdabot> -- f cannot be realized.
15:34:47 <jadrian> jmcarthur_work: I know free theorems
15:35:20 <jadrian> jmcarthur_work: and I know you can prove things about haskell
15:35:25 <soupdragon> this is nonsense :p
15:35:37 <jadrian> jmcarthur_work: but haskell the language has nothing to do with theorem proving
15:35:41 <jmcarthur_work> Coq doesn't actively prove anything either
15:35:54 <soupdragon> yes it does
15:35:58 <jadrian> jmcarthur_work: you can pass proofs around in coq
15:36:08 <soupdragon> read Barendraight notes about poincare principle etc
15:36:22 <jmcarthur_work> oh, so you're saying that the existence of Prop is what makes it a theorem prover?
15:36:26 <jadrian> jmcarthur_work: and make your programs depend on those proofs
15:36:27 <soupdragon> no
15:37:38 * soupdragon is mostly being pedantic and wishing someone tries to prove me wrong about total fp being so hard
15:38:25 <ehird> total fp is easy
15:38:33 <mike-burns> When it comes to programming, people only say "foo is a PITA" if either a) the languages they've used have a syntax that makes it awkward, or b) they've used it on a real project and it turned out to be a PITA.
15:38:37 <jmcarthur_work> i still don't see why coq being better at it means that haskell doesn't even meet the definition
15:39:07 <jmcarthur_work> i don't see what's so hard about total programming, really
15:39:16 <soupdragon> mike-burns huh... lol
15:40:00 <porpoise> I have a question about using FFI... Is it possible to write a C program that uses a functions written in Haskell, where the Haskell returns its state to the C program, which passes the state back to the Haskell function the next time it invokes it? I'm trying to understand how to maintain state in the Haskell portion of the program.
15:40:05 <Berengal> ehird: Easier than total OOP at least
15:40:13 <ehird> lol
15:40:19 <ehird> Berengal: that's not what total fp means
15:40:29 <ehird> 23:38 mike-burns: When it comes to programming, people only say "foo is a PITA" if either a) the languages they've used have a syntax that makes it awkward, or b) they've used it on a real project and it turned out to be a PITA.
15:40:32 <mike-burns> Total programming goes in the face of You Ain't Gonna Need It programming, so PITA or not I can see how someone could have a negative image of it from real-world use.
15:40:34 <ehird> or (c) they're trolling
15:40:38 * jmcarthur_work imagines what total OOP could mean ;)
15:40:49 <ehird> "You Ain't Gonna Need It" applies to total fp? then we should all be using java.
15:40:52 <mike-burns> Ha, forgot about trolling.
15:40:56 <Berengal> ehird: Shush you
15:41:16 <pikhq> ehird: Only if they throw out everything but the name.
15:41:30 <ehird> you ain't gonna _need_ infinite lists
15:41:31 <pikhq> (I think we can all agree, Java is a pretty good name)
15:41:36 <ehird> you ain't gonna _need_ typechecking
15:41:38 <ehird> pikhq: i preferred oak
15:41:51 <mike-burns> Oak didn't have as many puns.
15:42:02 <jmcarthur_work> pikhq, not as good as FORTRAN
15:42:12 <Berengal> Puns become horrible after a very short while...
15:42:40 <jmcarthur_work> all programming languages should be in all caps and end in TRAN or TRON
15:42:43 <jmcarthur_work> HASKELLTRON
15:42:47 <Berengal> But I must admitt, Java sounds better than when I used to be a create-of-the-night-student-hacker
15:43:05 <Berengal> creature*
15:43:31 <mike-burns> SKITRON
15:43:36 <ehird> i like the sound of RATFOR
15:43:37 <ehird> rat for art thou
15:44:07 <porpoise> JAVATRON
15:44:35 <jmcarthur_work> OCAMLTRAN
15:44:41 <mike-burns> PYTHONTRAN ... nah. PYTRAN!
15:44:52 <pikhq> BRAINTRON.
15:45:09 <ziman> befuntron
15:45:13 <jmcarthur_work> no
15:45:17 <jmcarthur_work> BEFUNTRON
15:45:18 <Rembane> CTRON!
15:45:19 <pikhq> Oh, and COBOL, because it insists on being different.
15:45:24 <porpoise> heh
15:45:28 <porpoise> C++TRON
15:45:30 <ehird> COTRAN
15:45:31 <Rembane> JTRON!
15:45:35 <jmcarthur_work> CTRON++
15:45:39 <ehird> it's not TRON
15:45:40 <ehird> it's TRAN
15:45:48 * Berengal likes fixfoldrflip, full name printcomposefixfoldrflipcomposejoincompose`flipbind`readfile
15:46:11 <pikhq> ADD 1 TO COBOLTRAN GIVING COTRAN.
15:46:17 <Berengal> It's just about every haskell program ever written...
15:46:31 <jmcarthur_work> > map toUpper "printcomposefixfoldrflipcomposejoincomposeflipbindreadfile" ++ "TRAN"
15:46:32 <lambdabot>   "PRINTCOMPOSEFIXFOLDRFLIPCOMPOSEJOINCOMPOSEFLIPBINDREADFILETRAN"
15:46:51 <Rembane> SELECT * FROM COBOL WHERE COBOL = COBOL + 1
15:46:59 <porpoise> SQLTRAN
15:47:03 <pikhq> @let languageNamer x = toUpper x ++ "TRAN"
15:47:05 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
15:47:06 <ziman> CO-COBOL (-TRAN)
15:47:17 <jmcarthur_work> @let languageNamer x = map toUpper x ++ "TRAN"
15:47:18 <pikhq> @let languageNamer x = (toUpper x) ++ "TRAN"
15:47:19 <lambdabot>  Defined.
15:47:20 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
15:47:22 <jmcarthur_work> @let languageNamer x = map toUpper x ++ "TRAN"
15:47:23 <lambdabot>  <local>:4:0:
15:47:23 <lambdabot>      Warning: Pattern match(es) are overlapped
15:47:23 <lambdabot>               In...
15:47:33 * pikhq didn't see the map and didn't see. YAY.
15:47:43 <jmcarthur_work> > languageNamer "ruby"
15:47:45 <lambdabot>   "RUBYTRAN"
15:47:50 <gwern> '
15:47:51 <gwern> The technology director of the Software Freedom Law Centre, Bradley Kuhn, said that he still stood by his statement of June 29, in which he backed Stallman's earlier advice about it being better to avoid a language like C#.
15:47:55 <gwern> "On a technical note, I honestly don't understand why people are even drawn to C#," Kuhn told iTWire. "I admit to only a cursory understanding, but I ask the same question over and over again of people and have yet to hear an adequate reply: why is C# a better choice than Python, Perl, PHP, Haskell, C and/or C++?'
15:48:00 <gwern> http://www.itwire.com/content/view/26166/1090/
15:48:25 <Berengal> gwern: Marketing?
15:48:31 <jmcarthur_work> nice!
15:48:35 <pikhq> There's a very simple reason for that: Windows programmers.
15:48:38 <pikhq> Win32 is awful.
15:48:44 <sjanssen> the advantages of C# over C and C# are obvious
15:48:47 <pikhq> The .Net API is mediocre.
15:48:56 <porpoise> sjanssen: you mean c++?
15:48:57 <sjanssen> I mean the advantages over C and C++
15:49:07 <jmcarthur_work> it has no advantages of haskell, of course ;)
15:49:12 <porpoise> what's the advantage over c++? Garbage collection?
15:49:16 <pikhq> jmcarthur_work: Few things do.
15:49:17 <mike-burns> Lots of people know C#. That's a great reason to hire C# programmers.
15:49:21 <pikhq> porpoise: Yes.
15:49:25 * Rembane shivers
15:49:25 <sjanssen> porpoise: GC, memory safety, more type safety
15:49:29 <Rembane> PHP!
15:49:36 <Vanadium> The advantages of C++ over C# are obvious :|
15:49:45 <porpoise> > languageNamer "PHP"
15:49:47 <lambdabot>   "PHPTRAN"
15:50:03 <Berengal> > languageNamer "C#"
15:50:05 <lambdabot>   "C#TRAN"
15:50:14 <ehird> > languageNamer "Haskell"
15:50:15 <jmcarthur_work> i just think it's nice to see haskell mentioned in the same breath as those more popular languages
15:50:15 <lambdabot>   "HASKELLTRAN"
15:50:16 <sjanssen> and the differences between Python et al and C# are obvious as well.  Overall I'd say that is a pretty dumb statement
15:50:18 <ehird> HASTRAN
15:50:26 <porpoise> Vanadium: I think C++ does have advantages over C#
15:50:28 <m3ga> at work we have a windows group that does nothing but C# and a linux group that does C, C++, Ocaml and Haskell.
15:50:39 <pikhq> Obviously, there needs to be a language called TRON.
15:50:42 <m3ga> there us a world of difference between the two
15:51:04 <sjanssen> now, if the guy said "why is C# a better choice than Java" it would be much more sensible
15:51:33 <Vanadium>  > filter (not . isSuffixOf "TRAN") $ map (languageNamer . show) [1 .. 10]
15:51:34 <mike-burns> A language is only as good as its community.
15:51:34 <Berengal> sjanssen: Perhaps, but the answer is "both suck"
15:52:05 <jmcarthur_work> C# isn't so bad
15:52:06 <Berengal> Perhaps I'm just fed up with that kind of language...
15:52:14 <jmcarthur_work> compared to other imperative languages anyway
15:52:17 <Berengal> C# has LINQ at least
15:52:23 <jmcarthur_work> and real closures
15:52:23 <Berengal> Which looks halfway decent
15:52:29 <Berengal> Yes, and real closures
15:53:06 <pikhq> jmcarthur_work: So does C++0x.
15:53:22 * Berengal hates how sorting objects by date is 8 lines in java
15:53:41 <jmcarthur_work> pikhq, there are plenty of reasons that C++0x is epic fail, though
15:53:42 <Berengal> Or whatever field...
15:53:47 <pikhq> ... sortBy (comparing date) is 8 lines?
15:53:54 <Berengal> in java
15:54:04 <pikhq> Yeah.
15:54:11 <pikhq> That's pretty dumb.
15:54:19 <mike-burns> Is that a common operation?
15:54:33 <Berengal> Collections.sort(someList, new Comparator<MyObject>{public int compare(MyObject o1, MyObject o2 [...]
15:55:07 <sjanssen> mike-burns: sorting by a particular field is very common, eg. an online inventory that you can sort by price, rating, alphabetically, etc.
15:55:12 <Berengal> Also, lack of purity, but that's on a more meta level
15:55:18 <mike-burns> sjanssen: I use SQL for that.
15:55:31 <Rembane> SQL <3
15:55:38 * pikhq notes that doing anonymous functions via anonymous objects that contain functions seems very verbose
15:55:44 <sjanssen> mike-burns: not all data is in a database (and some people don't like to use databases at all)
15:56:10 <Berengal> mike-burns: I'd rather not create new tables and marshall my objects to and from SQL values just to sort them. That'd take more than 8 lines...
15:56:27 <porpoise> Would anybody be able to help me with a general C interfacing question? if I have to use a C API, and the API uses callbacks to convey events, and I want to write a function in Haskell to process those events, and I want to Haskell function to maintain state, can I export the function to C, where the function is something like FN :: State -> Event -> (State,String)  I don't need the C program to do anything with the state, 
15:56:35 <Berengal> pikhq: Not to mention the objects have to be of the right type...
15:57:06 <sjanssen> porpoise: what sort of function does the C callback expect?
15:57:18 <pcc1> I saw that cabal supplies "-x c" to the C compiler when compiling C files.  how do I get it to supply, say, "-x c++"?
15:57:58 <porpoise> sjanssen: The callback is like void tickPrice(float) or something like that
15:58:11 <erisco> @src concat
15:58:12 <lambdabot> concat = foldr (++) []
15:58:40 <sjanssen> porpoise: you'll probably need to use mutable state in that case, IORefs perhaps
15:58:44 <porpoise> I want to feed the data into my Haskell program, and have the Haskell program return some output strings and stuff to the C program
15:59:36 <porpoise> and at the same time keep track of previous data
16:00:19 <porpoise> hmm.... IORef... Well, even though the program has no concurrency, using IORef seems wrong theoretically
16:00:35 <sjanssen> porpoise: you can use an MVar instead
16:00:36 <porpoise> should I be passing state back and forth,
16:02:18 <porpoise> I guess
16:04:45 <porpoise> I remember seeing an example somewhere of a program with a main loop in C and invoking code written in Haskell. I don't remember if the Haskell code maintained any state.
16:06:55 <conal> anyone know how to make a window in gtk2hs have focus / be on top?
16:07:26 <sjanssen> ewww
16:07:59 <sjanssen> conal: personally, I find it annoying when an application steals focus or attempts to manipulate the stacking order
16:08:06 <Berengal> conal: I think there's a simple action for it somewhere...
16:08:11 <conal> sjanssen: me too!
16:08:39 <conal> when i run a gtk2hs program, it makes a window that's behind others.
16:08:48 <conal> or may be in front but doesn't have focus
16:09:09 <sjanssen> interesting.  Under which window manager?
16:09:13 <conal> Berengal: probably so.  i'm scouring the gtk2hs Window doc
16:09:24 <sjanssen> (or window system, if you're not on X)
16:09:33 <Vulpyne> windowSetFocus?
16:09:37 <Berengal> I'm pretty sure I saw it while scouring the docs myself, but I can't help any more than that I'm afraid
16:09:42 <conal> sjanssen: ubuntu with compiz
16:10:00 <conal> i'm finally learning to use gtk2hs
16:10:06 <benmachine> so guys, are Show and Read exclusively for producing valid Haskell expressions?
16:10:37 <Berengal> benmachine: Not exclusively, but it's good form
16:10:37 <QPlaty[HireMe]> benmachine: What do you wish to use it for?
16:10:48 <QPlaty[HireMe]> By convention they are.
16:10:49 <Berengal> At least, read . show == id should be true
16:10:58 <Vulpyne> Reading/showing haskell expressions is usually nice, since they are unambigious.
16:11:23 <benmachine> well, so far I'd been assuming only Berengal's restriction, and just using them to generally convert things to a textual form and back
16:11:29 <benmachine> where this was unambiguous
16:11:48 <benmachine> but then I read something that suggested I was missing the point
16:12:34 <benmachine> I'm now wondering if there's any good reason for me using show rather than just defining my own function
16:12:53 <Berengal> Since you can automatically derive both Read and Show, there's not really any reason to instance those yourself
16:13:08 <benmachine> mm, I did wonder
16:13:16 <conal> benmachine: if you use show, then other code can show values of your type
16:13:28 <Berengal> And if you need custom reading/showing, writing your own functions won't be worse in the vast majority
16:13:36 <conal> benmachine: other *polymorphic* code
16:13:47 <Berengal> [...] of cases
16:14:28 <benmachine> conal: yeah but for my purposes I don't think that's likely to be necessary
16:14:33 <Berengal> conal: not that functions polymorphic in Show are that common
16:14:55 <Berengal> String is usually good enough
16:14:56 <conal> Berengal: comes up a lot for me.
16:15:27 <Berengal> conal: Okay then, I add the "annecdotally" qualifier to my previous statements
16:15:32 <Rembane> And duct tape
16:15:54 <conal> maybe add "Berengal-annecdotally"
16:16:59 <conal> maybe bounded polymorphism is a programming style.
16:18:58 <Berengal> I like to use Show/Read as a poor-mans-serialization...
16:19:17 <conal> me too
16:19:41 <Berengal> Speaking of which, does haskell have anything similar to python's dbm/shelve?
16:20:19 <conal> benmachine: oh -- another reason to use Show is reducing cognitive load.  you don't have to remember what you name particular showers if you name them all "show"
16:20:37 <conal> similarly for all functionality in standard type classes
16:21:11 <Berengal> But if you need to show something in different ways, having one function named just "show" can be confusing...
16:21:23 * Berengal says annecdotally
16:21:35 <benmachine> yeah that's what I'm thinking
16:22:04 <benmachine> if I see show I think function that makes things into strings, but I don't necessarily know what strings
16:22:16 <Berengal> It is however very true for other typeclasses, such as monoid and monad
16:22:18 <benmachine> unless I keep all my show instances derived
16:24:49 <benmachine> ...if I derive all my Read instances, is it actually possible to get an ambiguous parse?
16:25:23 <dons> Berengal: Data.Binary == shelve, iirc.
16:25:37 <dons> thoug hmm, could do with more help.
16:25:38 <QPlaty[HireMe]> benmachine: I don't beleave so.
16:25:46 <dons> you really want lookup on the db.
16:25:52 <dons> while binary is just persistance/serialization
16:26:03 <dons> one of the caches/persistance libs perhaps
16:26:10 <Berengal> dons: Yeah, the lookup part is what I'm missing
16:26:24 <dons> there's a bunch of things on hackage that talk about persistance (e.g. for happs).
16:26:42 <aavogt> do you need implementation support to serialize arbitrary functions?
16:26:51 <Heffalump> yes
16:27:03 <Berengal> I haven't really had time to look into macid yet, but it looks nice from where I'm standing
16:27:41 <dons> yes, e.g. happstack's storage support is just a seprate persistance lib.
16:28:36 <Berengal> I just like to have several options when it comes to persistence. In my experience, there's an inversely proportional relationship between usefulness and user friendlyness
16:29:08 <Berengal> If reading shown strings don't cut it, I'd rather not have to pull out a db right away
16:29:33 <dons> Data.Binary & friends fill that gap
16:30:41 <Berengal> dons: How about the lookup?
16:31:28 <dons> http://hackage.haskell.org/packages/archive/TCache/0.5.5/doc/html/Data-TCache.html  e.g.
16:31:36 <dons> (http://hackage.haskell.org/package/TCache)
16:31:50 <dons> or say, http://hackage.haskell.org/package/persistent-map
16:32:03 <dons> "Provides a thread-safe STM interface for finite map types with optional persistent storage. "   <-- cool
16:35:04 <dschoepe> If I have a where clause that only depends on the first argument of a function, will that always get computed again when I call the partially applied function with different other arguments?
16:35:23 <Berengal> dons: Yup, those look nice
16:36:46 <dons> dschoepe: if there's no data dependency on the second arg, then no.
16:37:07 <dons> you can test with Debug.Trace.trace
16:37:25 <dschoepe> dons: Thanks.
16:37:41 <Heffalump> dschoepe: no, that's not true
16:37:52 <Heffalump> foo x y = ... where wibble = f x
16:38:13 <Heffalump> is that what you're thinking of
16:38:14 <Heffalump> ?
16:38:18 <dschoepe> yes
16:38:26 <dons> Prelude Debug.Trace> let f x y = z + y where z = trace "z" $ 2 * x
16:38:30 <dons> Prelude Debug.Trace> map (f 2) [1..5]
16:38:30 <dons> [z
16:38:30 <dons> 5,z
16:38:30 <dons> 6,z
16:38:30 <dons> 7,z
16:38:32 <dons> 8,z
16:38:35 <dons> 9]
16:39:44 <Heffalump> i.e. it does get recomputed each time
16:40:07 <dons> yes, you'd need to write it differently
16:40:07 <sjanssen> dschoepe: you have to rearrange the lambdas yourself
16:40:07 <dons> e.g.
16:40:08 <dons> Prelude Debug.Trace> let f x =   let g y = z + y in g where z = trace "z" $ 2 * x
16:40:11 <dons> Prelude Debug.Trace> map (f 2) [1..5]
16:40:14 <dons> [z
16:40:17 <dons> 5,6,7,8,9]
16:40:20 <Heffalump> right
16:40:28 <dschoepe> Ah, thanks
16:40:34 <sjanssen> I think GHC will do this transformation by itself sometimes
16:40:41 <dons> I wonder if that's vulnerable to optimization.
16:42:29 <Heffalump> wouldn't the transformation be a space leak?
16:42:32 <Heffalump> (potentially)
16:43:05 <JesusChrist> Hi guys.
16:43:09 <JesusChrist> I'm back.
16:43:23 --- mode: ChanServ set +o dons
16:44:03 <JesusChrist> I just wanted a little favor from the Haskell gang.
16:44:21 <Heffalump> is it the Apocalypse already?
16:44:32 <JesusChrist> Almost, Heffalump.
16:45:08 <JesusChrist> As you all know, I'm a really cool guy most of the time. But something really bothered me the other day.
16:46:09 <JesusChrist> I use GNOME and there is no such thing as icons for haskell (literal) sources
16:46:43 <sjanssen> JesusChrist: this is a good point
16:46:45 <Cale> Yeah, it just uses the same icon as for text files...
16:46:54 <sjanssen> somebody should make icons with the new logo
16:46:58 <JesusChrist> In the old days of GNOME you had icons for both Haskell sources and apps.
16:46:58 <dons> http://www.haskell.org/sitewiki/images/a/a8/Haskell-logo-60.png
16:47:14 <JesusChrist> http://jimmac.musichall.cz/stuff/gnome-application-x-haskell.png ye old icons
16:47:21 <JesusChrist> http://jimmac.musichall.cz/stuff/gnome-application-x-literate-haskell.png
16:47:27 <JesusChrist> olde indeed
16:47:52 <JesusChrist> Back when GNOME was made of plastic.
16:49:57 <Lemmih> I'm using this one: http://mirror.seize.it/hs-icon.png
16:50:00 <iago> looking for how translating haskell to some theorem prover
16:50:17 <JesusChrist> So, if you guys use some sort of Linux/BSD distribution... I would appreciate if you asked for some action on this.
16:50:18 <iago> I mainly (or only) see papers talk about translating haskell to isabelle/hol
16:50:21 <soupdragon> iago what does that mean
16:50:26 * sjanssen boggles
16:50:39 <JesusChrist> Or, directly annoy the GNOME artists.
16:50:42 <iago> some good explanation? very good prover?
16:50:58 <iago> soupdragon, translate haskell programs to the spec language used by a prover
16:51:16 <Berengal> JesusChrist: const "Patches welcome"
16:51:22 <benmachine> I use xfce
16:51:36 <benmachine> I appear to have icons for my haskell programs
16:51:42 <benmachine> well
16:51:46 <dons> iago: look at Haskabelle?
16:51:52 <benmachine> they are pretty rubbish, but icons nonetheless
16:51:53 <Berengal> I use bash, I no icons at all...
16:52:02 <Berengal> I have*
16:52:07 <JesusChrist> Berengal: What am I, God or something?
16:52:13 <benmachine> Berengal: well yeah I had to go and look to remind myself what icons where
16:52:14 <benmachine> *were
16:52:55 <mike-burns> JesusChrist: No programming language has specific icons in GNOME now, right?
16:53:04 <mike-burns> I just made a C file and it was just the text icon.
16:53:11 <iago> dons, no, but lot of thanks for the reference, works well?
16:53:34 <dons> i've not used it, but it is new, and significantly, bundled with Isabelle
16:54:59 <iago> well, I was interested in PVS, although not necessary
16:56:16 <dons> you'll see more haskell support in the type-theory based prover crowd.
16:56:29 <benmachine> http://benmachine.co.uk/text-x-haskell.svg <-- /usr/share/icons/Rodent/scalable/mimetypes/text-x-haskell.svg
16:56:58 <JesusChrist> Urgh.
16:57:18 <JesusChrist> mike-burns: Yes, but it's ridiculous.
16:57:42 <jadrian> Cmike-burns: I wouldn't be surprised if the Gnome crowd ignored C++ but ignoring C is weird :D
16:57:43 <mike-burns> Your idea of ridiculous is quite different from mine.
16:58:07 <JesusChrist> Put it in perspective, mike-burns.
16:58:14 <iago> dons, do you know some URL? google doesn't consider crowd very popular I think
16:58:31 <JesusChrist> The guidelines they have don't allow letters in the icons.
16:58:48 <dons> iago: e.g. Coq, Agda, Isabelle
16:58:51 --- mode: ChanServ set -o dons
16:58:55 <JesusChrist> Thence, putting there names is a no-go: C, C++, JAVA, whatever.
16:59:21 <iago> dons, ok sorry, I understand wrong what do you say, my English..
16:59:22 <benmachine> JesusChrist: what about greek letters?
16:59:30 <Adamant> internationalization = annoying
16:59:43 <JesusChrist> Now, you also don't have a icon for java sources because the crappy coffe/bean metaphore.
16:59:56 <dons> iago: Coq, Agda and Isabelle have better support for Haskell
17:00:03 <iago> dons, I see some work about Haskell->Agda, a lot about Haskell->Isabelle, very few or nothing about Haskell->Coq, and nothing about Haskell->PVS
17:00:15 <benmachine> hmm not only do I have a crappy icon for my haskell files
17:00:17 <dons> http://isabelle.in.tum.de/haskabelle.html
17:00:18 <benmachine> I apparently have twelve copies of it on my filesystem
17:00:20 <JesusChrist> benmachine: In this case you don't have a greek letter, you have a GPLed logo.
17:00:26 <jadrian> ah I just noticed that KDE 4.3 RC2 uses the new haskell logo for hs files :D
17:00:27 <Zao> JesusChrist: now surely those are just squigglies that are associated with the languages
17:00:28 <dons> iago: i think Coq can extract Haskell
17:00:30 <benmachine> JesusChrist: hah
17:00:31 <dons> iago: check with roconnor
17:00:37 <benmachine> JesusChrist: what if I GPL the letter C
17:00:45 <dons> http://www.nijoruj.org/~as/2009/04/20/A-little-fun.html
17:00:49 * JesusChrist facepalms.
17:00:52 <iago> dons, ah, yeah, I know, but I'm interesting in translating from Haskell
17:00:52 <roconnor> in theory Coq can extract Haskell
17:01:09 <iago> dons, to use Coq to extract Haskell is what I'm using now
17:01:14 <iago> but I want to replace this approach
17:01:30 <JesusChrist> http://www.haskell.org/sitewiki/images/a/a8/Haskell-logo-60.png is a bit different than a greek letter.
17:01:41 <dons> oh, interesting. maybe Isabelle/HOLCF, http://www.galois.com/blog/2009/06/23/streamfusion/
17:01:50 <dons> has some of how he translated Haskell to Isabelle.
17:02:26 <JesusChrist> And, unlike Sun Java's logo, it can be implemented/used everywere.
17:02:35 <benmachine> fair enough
17:02:51 <drhodes> silicon graphics had the coolest logo
17:03:01 <benmachine> I was merely trying to illustrate my opinion that a no-letters rule is entirely farcical
17:04:40 <iago> dons, do you use Isabelle?
17:04:51 <dons> others at work do.
17:05:11 <JesusChrist> benmachine: I remember a project or something, where they tried to place cool programming icon files on GNOME... Let me search my archives.
17:05:52 <JesusChrist> benmachine: It was project CodeTango.
17:05:54 <iago> well, I dunno, I was looking for PVS support because it's more automatic than Coq, but I don't know nothing about Isabelle/HOL
17:06:12 <dons> maybe ask on the types@ mailing list?
17:06:22 <JesusChrist> http://vdepizzol.wordpress.com/2007/11/12/codetango-in-gnome-icon-theme-extras/
17:06:33 <dons> or haskell-cafe@
17:07:05 <soupdragon> iago, is there any aspect of it you don't know how to do yet?
17:07:25 <iago> soupdragon, about translation?
17:07:51 <iago> dons, I will ask so, thanks
17:08:16 <soupdragon> iago, what your asking about
17:10:37 <iago> well, I'm looking for references of how translate Haskell "to theorem provers"
17:11:01 <iago> seems to be lot of problems translating lazy semantics
17:11:10 <iago> reasoning about _|_ etc
17:11:11 <iago> :P
17:13:56 <dons> yeah, see the domain theory stuff in isabelle/holcf for doing the stream fusion proofs
17:13:56 <iago> although I'm reading a paper about a "pragmatic translation", not fully rigorous, but they said that it's good for most purposes
17:16:05 <iago> dons, I'm taking a quickly view
17:16:08 <JesusChrist> brb guys. Must kick the Devil into its place.
17:16:09 <iago> but lot of thanks
17:16:17 <iago> I have lot to read these days
17:17:15 <soupdragon> iago: I don't know any problems with it
17:17:31 <iago> soupdragon, with lazy semantics?
17:20:55 <J11> is there a specific name for when you supply more parameters to a function?
17:21:10 <skorpan> yes, but i can't recall what it was now
17:21:37 <J11> for example: id (++) "foo" "bar"
17:21:52 <skorpan> > id (++) "foo" "bar"
17:21:53 <lambdabot>   "foobar"
17:22:13 <J11> I know in another language it's called overloading
17:22:15 <skorpan> oh, i think i misunderstood your question
17:22:17 <Cale> J11: I'm not sure that has a specific name.
17:22:22 <dolio> More parameters than what?
17:22:22 <Cale> J11: It's not overloading here.
17:22:32 <Cale> J11: It's just that id is polymorphic in the type of its result
17:22:47 <skorpan> i thought you meant more parameters than the function actually takes, as in e.g. "(+) 3 4 5"
17:22:57 <Cale> J11: So if you pass it a function, it gives you a function, with just as many parameters as that function had.
17:22:59 <FauxFaux> It's called "an error". *runs*
17:23:35 <Cale> In this case, I suppose you could say that parametric polymorphism is responsible for allowing you to supply 3 parameters to id.
17:24:10 <Cale> Though you should be aware that in Haskell you really only ever supply one parameter.
17:24:13 <skorpan> Cale: isn't it just as simple as (id (++)) "foo" "bar"?
17:24:17 <Cale> yeah
17:24:25 <Cale> f x y z means ((f x) y) z  in all cases
17:24:45 <J11> ok, thx
17:24:45 <skorpan> this has a smarty-pants-name, but i can't remember what it is
17:25:08 <pcc1> I have a package that uses an FFI wrapper written partly in C++.  the package appears to work fine using ghc, however I get a linker error with ghci: "unknown symbol `__dso_handle'".  is anyone aware of how to get c++ modules to work with ghci?
17:25:10 <Cale> Every function has exactly one parameter, and those which appear to take more are just producing other functions.
17:25:45 <skorpan> does this reduction strategy have a name?
17:25:53 <Cale> skorpan: curried application
17:26:02 <skorpan> i see
17:26:18 <Cale> The process of turning a function of many parameters into a function of one parameter which produces another function is called currying.
17:27:06 <skorpan> after having gone on wikipedia, i think what i was thinking of was "applicative order"
17:27:08 <skorpan> gnight
17:27:19 <Cale> Applying a function in general to only some of its parameters in order to get a function of the remainder of the parameters is called partial application.
17:28:02 <Cale> Currying a function makes it easy to partially apply (at least to the initial parameters)
17:28:32 <Cale> pcc1: I wish I knew. C++ is rather strange where FFI is concerned.
17:30:44 <pcc1> are there any packages that link to a C++ library?  perhaps I will find the solution in their source code
17:34:03 <ceninan> aah, good ol' J : "(($:@(<#[) , (=#[) , $:@(>#[)) ({~ ?@#)) ^: (1<#)"
17:35:47 <ceninan> who needs perl anyway?
17:44:03 <EXCLUSIVE> Saizan >> I love you
17:44:05 <EXCLUSIVE> ))
17:45:25 <Laurent`[Wolf]> heigh!
17:45:27 <Laurent`[Wolf]> ))
17:46:19 <bgs100> Hah, this is funny (It's from "Learn a Haskell For Great Good!"):
17:46:21 <bgs100> "If you still don't know what recursion is, read this sentence."
17:46:26 <EXCLUSIVE> Homosexuals!! =)))
17:46:28 <EXCLUSIVE> :D
17:47:10 <Laurent`[Wolf]> :D
17:47:26 <EXCLUSIVE> bgs100 >> The darling =)
17:47:35 <EXCLUSIVE> bgs100 >> kiss =)
17:47:36 <Laurent`[Wolf]> fool
17:47:38 <Laurent`[Wolf]> ))
17:47:57 <EXCLUSIVE> õõ)
17:48:01 <EXCLUSIVE> ùàñ óññóñü)
17:48:09 <EXCLUSIVE> îíè òóïûå êàê ÷óê÷è)
17:48:35 <EXCLUSIVE> Hunner >> ïèçäàëèç =)
17:50:01 <Laurent`[Wolf]> let`s told
17:50:15 <Laurent`[Wolf]> people
17:50:50 <EXCLUSIVE> Homosexuals!! =)))
17:50:58 <EXCLUSIVE> :D
17:50:59 <Laurent`[Wolf]> pedro
17:51:04 <Laurent`[Wolf]> :D
17:51:33 <Laurent`[Wolf]>  EXCLUSIVE >>> ðóí floozy
17:51:39 <Laurent`[Wolf]> hey
17:51:42 <Laurent`[Wolf]> ))
17:51:46 <EXCLUSIVE> Which hour at you?????????????
17:51:54 <EXCLUSIVE> guys
17:52:15 <Cale> Laurent`[Wolf], EXCLUSIVE: This channel is for discussion of the Haskell programming language... please try to stay on topic.
17:52:30 <soupdragon> @localtime
17:52:31 <lambdabot> Local time for soupdragon is Fri Jul 10 01:52:30
17:52:49 <Laurent`[Wolf]>  EXCLUSIVE >>> ý áðàò))
17:52:53 <Laurent`[Wolf]> ýòî íå àìåðèêà
17:52:57 <Laurent`[Wolf]> ýòî àíãëèÿ
17:52:58 <EXCLUSIVE> Laurent`[Wolf] >> à ÷å?)
17:53:01 <EXCLUSIVE> ÑÓÏÅÐ!
17:53:03 <EXCLUSIVE> =)
17:53:09 <EXCLUSIVE> Hooligans!!
17:53:10 <Cale> Whatever text encoding that is, it's not UTF-8.
17:53:10 <EXCLUSIVE> )))
17:53:19 <Laurent`[Wolf]> you from GB?
17:53:20 <erisco> what is the easiest way to, instead of getting NaN, get 0?
17:53:34 <Cale> if isNaN x then 0 else x
17:53:45 <mike-burns> My guess: it was UTF-8 in the original file, but the programming language used for the bots doesn't understand UTF-8.
17:53:49 <Laurent`[Wolf]> velfrb
17:53:53 <Laurent`[Wolf]> ìóäàêè
17:53:55 <EXCLUSIVE> :D
17:53:59 --- mode: ChanServ set +o Cale
17:54:08 <EXCLUSIVE> Laurent`[Wolf] >> ÿ ïîðàæàþñü êàêèå ó íèõ òåìû)
17:54:09 <Laurent`[Wolf]> îïà
17:54:09 --- kick: Laurent`[Wolf] was kicked by Cale (Cale)
17:54:12 <erisco> Cale thanks, now, if I do not bind the expression x to a variable it will be calculated twice yes?
17:54:12 <EvilTerran> Cale++
17:54:12 <EXCLUSIVE> âñ¸
17:54:13 --- kick: EXCLUSIVE was kicked by Cale (Cale)
17:54:22 <EXCLUSIVE> ))
17:54:24 --- mode: Cale set +b *!*@217.118.66.101
17:54:24 --- kick: Laurent`[Wolf] was kicked by Cale (Cale)
17:54:28 --- mode: Cale set +b *!*@178.z2.klimovsk.net
17:54:28 --- kick: EXCLUSIVE was kicked by Cale (Cale)
17:54:33 <EvilTerran> +b++ :P
17:54:51 --- mode: Cale set -o Cale
17:54:51 <EvilTerran> preflex: karma +b
17:54:51 <preflex>  +b: 1
17:55:07 <Cale> preflex: karma /b
17:55:07 <preflex>  /b has no karma
17:55:19 <FunctorSalad> :)
17:58:01 <pcc1> regarding my C++ FFI issue, for the benefit of anyone googling this, I had to link the wrapper code into a separate shared library
18:05:18 <roconnor> @quote Kleisli
18:05:19 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
18:05:19 <lambdabot> read
18:10:15 <erisco> where do I get NaN from?
18:10:31 <enolan> > (1/0) :: Double
18:10:32 <lambdabot>   Infinity
18:10:34 <erisco> or is it not something I make?
18:10:48 <erisco> > 0/0
18:10:49 <lambdabot>   NaN
18:10:57 <erisco> well that works I guess
18:11:03 <byorgey> > NaN == NaN
18:11:05 <lambdabot>   Not in scope: data constructor `NaN'Not in scope: data constructor `NaN'
18:11:12 <byorgey> > 0/0 == 0/0
18:11:14 <lambdabot>   False
18:11:48 <erisco> I will just use 0/0 to produce NaN
18:12:19 <davidL> > sqrt (-1)
18:12:20 <lambdabot>   NaN
18:12:40 <erisco> 0^0
18:12:45 <erisco> > 0^0
18:12:46 <lambdabot>   1
18:12:49 <erisco> I mean...
18:13:05 <erisco> > 0^-1
18:13:07 <lambdabot>   Not in scope: `^-'
18:13:10 <erisco> > 0^(-1)
18:13:12 <lambdabot>   * Exception: Negative exponent
18:13:16 <erisco> oh
18:13:19 <erisco> > 0**(-1)
18:13:20 <lambdabot>   Infinity
18:13:23 <erisco> hm
18:14:28 <byorgey> > 0**0
18:14:30 <lambdabot>   1.0
18:14:34 <byorgey> oh good!
18:22:24 <bgs100> > 5^10
18:22:26 <lambdabot>   9765625
18:22:40 <bgs100> > 9765625^1/10
18:22:41 <lambdabot>   976562.5
18:22:49 <bgs100> > 9765625^(1/10)
18:22:51 <lambdabot>   Add a type signature
18:23:12 <bgs100> > 9765625^(1/10 :: Float)
18:23:14 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Float)
18:23:14 <lambdabot>    arising from a use o...
18:23:44 <bgs100> > 9765625^0.1
18:23:45 <lambdabot>   Add a type signature
18:24:00 <bgs100> > 9765625^0.1 :: Int
18:24:02 <lambdabot>   Add a type signature
18:25:17 <ivanm> @type (^)
18:25:18 <bgs100> > (9765625^0.1 ):: Int
18:25:19 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
18:25:20 <lambdabot>   Add a type signature
18:25:34 <ivanm> > (23.63^43) :: Double
18:25:35 <lambdabot>   1.1453547735400798e59
18:25:51 <bgs100> > (9765625^0.1) :: Double
18:25:53 <ivanm> you sometimes have to add a type sig for the power term as well
18:25:53 <lambdabot>   Add a type signature
18:26:04 <ivanm> bgs100: the power has to be an integer...
18:26:18 <pikhq> > (9765625**0.1)
18:26:19 <lambdabot>   5.000000000000001
18:26:59 <bgs100> > (9765625**(1/10))
18:27:01 <lambdabot>   5.000000000000001
18:27:06 <tromp> > 32^0.2
18:27:08 <lambdabot>   Add a type signature
18:27:12 <tromp> > 32**0.2
18:27:13 <lambdabot>   2.0
18:27:22 <bgs100> > (9765625**(1/10)) :: Int
18:27:24 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
18:27:24 <lambdabot>    arising from a use of...
18:27:25 <dolio> > 9765625**0.1 :: CReal
18:27:27 <lambdabot>   5.0
18:28:07 <erisco> are there any functions that help deal with Maybe types?
18:28:13 <bgs100> > floor 9765625**(1/10)
18:28:15 <lambdabot>   Add a type signature
18:28:20 <pikhq> Monadic operators.
18:28:22 <erisco> like fromJust or something? isNothing perhaps?
18:28:32 <ivanm> > floor $ 9765625**(1/10)
18:28:34 <lambdabot>   5
18:28:38 <mike-burns> :t maybe
18:28:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:28:40 <bgs100> $?
18:28:46 <pikhq> What do you want to *do* with the Maybe types?
18:28:51 <ivanm> bgs100: low level function application
18:28:54 <ivanm> @src ($)
18:28:54 <lambdabot> f $ x = f x
18:28:54 <pikhq> @src $
18:28:55 <lambdabot> f $ x = f x
18:29:05 <ivanm> bgs100: in this case, it's used just to make sure the power happens before the floor
18:29:17 <bgs100> > floor (9765625**(1/10))
18:29:19 <lambdabot>   5
18:29:39 <erisco> pikhq, I want to calculate the cotangent between two points presuming that they mark two vertices in a right-angled triangle
18:30:05 <erisco> pikhq, if the same point is given twice, there is no possible angle
18:30:13 <pikhq> erisco: How much do you know of monads?
18:30:15 <erisco> pikhq, and I need a way to detect that
18:30:18 <erisco> pikhq, nothing
18:30:23 <ivanm> bgs100: so $ lets you avoid bracketing things
18:30:38 <pikhq> Learn monads, and all shall be revealed.
18:30:49 <erisco> pikhq, but that is not until several chapters later in my book...
18:31:09 <erisco> pikhq, without calculating cotangents I cannot implement Graham's scan which is an exercise in chapter 3
18:31:36 <bgs100> > replicate 3 5
18:31:36 <mike-burns> Why are monads introduced so late in Haskell books? Is it because of the IO monad?
18:31:37 <lambdabot>   [5,5,5]
18:31:47 <bgs100> > replicate 3 "test"
18:31:48 <pikhq> mike-burns: Yes.
18:31:48 <lambdabot>   ["test","test","test"]
18:32:22 <mike-burns> The IO monad gives the other monads a bad rep.
18:33:24 <bgs100> :t concat
18:33:26 <lambdabot> forall a. [[a]] -> [a]
18:34:25 <mmmulani> can you use guards within a do?
18:34:41 <bgs100> > concate (replicate 3 "test ")
18:34:43 <lambdabot>   Not in scope: `concate'
18:34:48 <bgs100> > concat (replicate 3 "test ")
18:34:50 <lambdabot>   "test test test "
18:35:10 <pikhq> > do {x <- Nothing; y <- return 2; return $ x+y} :: Maybe Int
18:35:11 <lambdabot>   Nothing
18:35:29 <mike-burns> :t intercalate
18:35:31 <lambdabot> forall a. [a] -> [[a]] -> [a]
18:35:40 <erisco> pikhq, should I just make my own isNothing and fromJust functions then?
18:35:42 <mike-burns> > intercalate " " $ replicate 3 "test"
18:35:43 <lambdabot>   "test test test"
18:36:14 <pikhq> erisco: Boy, you're going to love Maybe as a monad.
18:36:48 <erisco> pikhq, well evidently I cannot do anything about that right now
18:39:40 <pikhq> > let isJust (Just _) = True; isJust _ = False;getJust (Just x) = x;isNothing Nothing = True;isNothing _ = False in isNothing Nothing
18:39:42 <lambdabot>   True
18:39:54 <pikhq> (that feels so dirty)
18:40:09 <erisco> pikhq, that is what I must do
18:41:43 <pikhq> erisco: Well, just be aware that nobody, and I mean nobody, does it that way.
18:41:59 <erisco> pikhq, well if you can give me a hint as to how it is done
18:42:17 <erisco> if monads are really that complex, even for this simple thing, then I will not understand it right now
18:42:42 <pikhq> do x <- somethingThatReturnsMaybe; y <- somethingElseThatReturnsMaybe;foo x y
18:43:11 <erisco> pikhq, what happens if that something returns Nothing?
18:43:21 <pikhq> If one of those evaluates to Nothing, the whole do block evaluates to Nothing.
18:43:41 <pikhq> Otherwise, it does the obvious.
18:43:46 <pikhq> That is the Maybe monad in a nutshell.
18:44:04 <erisco> can I act on the case where the do block evaluates to Nothing?
18:44:13 <pikhq> (but not monads in general. That's just enough to help you maybe understand part of why monads are useful)
18:45:01 <mike-burns> erisco: Have you gotten to a section about importing modules?
18:45:18 <erisco> mike-burns, no, but quite a few tasks have required it
18:45:26 <erisco> mike-burns, I don't know if they ever talk about how to import or not
18:45:41 <erisco> I've been just trying to piece it together up to now
18:45:46 <mike-burns> erisco: If you feel it isn't cheating, have a look at Data.Maybe .
18:46:56 <erisco> mike-burns, there is already is* and from* defined for me?
18:47:03 <mike-burns> Sure is.
18:47:20 <mike-burns> You might even be interested in the `maybe' function.
18:49:25 <erisco> mike-burns, the maybe function does not help me unfortunately
18:49:33 <mike-burns> Ah well.
18:49:57 <ivanm> what type of function do you want then/
18:50:04 <ivanm> s+/+?+
18:50:52 <erisco> mike-burns, if I use a do block, how do I respond if the do block evaluates to nothing because one of the Maybe producing functions evaluated to Nothing?
18:51:18 <erisco> I don't even think a do block is what I want :(
18:51:29 <erisco> I probably just want the is* and from* functions
18:51:32 <mike-burns> (It sounds like `maybe' is what you want ...)
18:51:48 <erisco> it isn't
18:51:50 <mike-burns> Okay.
18:52:10 <mike-burns> I'd advise that you get it running "the long way" then refactor as you learn more.
18:54:10 <erisco> mike-burns, I don't know if there is a shorter way. I need to do something different in all the cases of one evaluation giving Nothing, the other giving Nothing, or neither giving Nothing
18:54:48 <erisco> but, I'm likely wrong :P
18:54:51 <mike-burns> Sure; you might not even be able to refactor after.
18:55:40 <hdevalence> show is not locale-aware, correct? i.e., it will never produce "0,3" ?
18:56:55 <Cale> hdevalence: right
18:57:04 <hdevalence> great, thanks
18:57:24 <Cale> hdevalence: It's also a function, so it would have to take the locale as a parameter if it depended on it.
18:57:31 <hdevalence> aha
18:57:45 <hdevalence> I'm still getting used to that
18:57:49 <hdevalence> it takes a little while
19:00:14 <ray> unless it were some kind of fancyShow :: a -> IO String that did environment-dependent things, but that's just silly
19:00:31 <ray> (it doesn't transmit well over irc, but i really do think it's silly)
19:01:34 <hdevalence> ray: you mean silly to have it in an IO monad rather than just using a parameter?
19:01:56 <ray> silly in a lot of ways, that's one
19:02:04 <aavogt> @hoogle os
19:02:05 <lambdabot> System.Info os :: String
19:02:05 <lambdabot> Distribution.PackageDescription OS :: OS -> ConfVar
19:02:05 <lambdabot> Distribution.System data OS
19:02:14 <aavogt> > os
19:02:15 <lambdabot>   Not in scope: `os'
19:02:24 <aavogt> > System.Info.os
19:02:26 <lambdabot>   Not in scope: `System.Info.os'
19:03:23 <aavogt> ray: the result of System.Info.os is going to change nearly as frequently as your locale
19:04:08 <aavogt> there /are/ some non Referentially Transparent functions in the base library, depending on your definition of RT
19:06:02 <ray> System.Info.os's value is based on some #define stuff, so it's sorta equivalent to just having os = "lunix" or whatever
19:07:09 <jeffwheeler> hdevalence: I've missed the entire discussion (I left), but for 'show' to be locale-aware, it couldn't be referentially transparent
19:07:59 <hdevalence> right
19:08:17 <aavogt> the locale can change during the run of a program, right?
19:08:21 <SamB_XP> nevermind that the syntax of Haskell doesn't change from locale to locale
19:08:23 <SamB_XP> aavogt: yeah
19:08:51 <hdevalence> oh, by the way, does anyone know of a haskell library that will convert HSV into RGB colours?
19:09:15 <aavogt> @hackage colour
19:09:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/colour
19:09:26 <erisco> okay, I am really confused as to the stage when we calculate the cotangents in Graham's scan
19:09:44 <erisco> it says that instead of calculating angles we can just calculate the cotangents that the two points make with the x axis
19:09:47 <SirNick> brb
19:09:54 <SirNick> back
19:10:01 <erisco> well, consider the points (0,0) and (1,1). their cotangent is 1
19:10:06 <SirNick> brb
19:10:07 <SirNick> back
19:10:10 <erisco> the points (0,0) and (1,2), their cotangent is 0.5
19:10:33 <erisco> but the angle that (0,0) and (1,2) make is bigger than what (0,0) and (1,1) make!
19:10:36 <erisco> so HOW can this work?
19:10:50 <aavogt> > tan (2/1)
19:10:52 <lambdabot>   -2.185039863261519
19:11:12 <aavogt> > tan (1/2) -- whoops
19:11:14 <lambdabot>   0.5463024898437905
19:11:23 <aavogt> > tan (1)
19:11:25 <lambdabot>   1.5574077246549023
19:11:27 <erisco> aavogt, I need to shoot myself
19:11:32 <erisco> or my brain, or something
19:11:36 <Cale> Er, cotangent?
19:11:42 <Cale> Or do you mean arctangent?
19:11:47 <erisco> Cale, I mean cotangent
19:12:10 <erisco> aavogt, I never did tan() on them =\
19:12:22 <Cale> cot takes an angle as a parameter though...
19:12:23 * erisco sighs
19:13:02 <erisco> Cale, yeah?
19:13:12 * aavogt should have used arctan, as Cale pointed out
19:13:14 <gwern> @remember fubo I've seen "production" Prolog code and it bends my brain. Also, any language where performance is even less predictable than in Haskell strikes me as an odd choice.
19:13:14 <lambdabot> Done.
19:13:22 <erisco> no no no, it is cotangent, really
19:15:15 <jeffwheeler> GADTs are bending my mind.
19:15:15 <Cale> erisco: Okay, can I see the thing you're reading? I think the main idea behind Graham's scan, though it's been a while since I looked at it, is that you can calculate whether something is a clockwise or counterclockwise turn by computing the sign of the cross product, rather than doing any trigonometry...
19:15:45 <erisco> Cale, you have to order all the points by the angle the make with point P and the x axis
19:15:58 <erisco> Cale, I am just reading wikipedia because that is what the book advises
19:16:46 <erisco> Cale, but it says you do not have to actually calculate the angle, you can instead use cotangent, because it is always decreasing from 0 to 180 degrees, so it is a suitable measure
19:17:53 <Cale> ah, okay, but they don't mean actually applying the cot function
19:18:06 <Cale> They mean obtaining the cotangent of the angle geometrically by another means
19:18:14 <erisco> Cale, you do not have an angle, so no, you are not using the cot function
19:18:20 <erisco> Cale, yes, exactly
19:18:34 <erisco> Cale, which I am doing, but I forgot to call tan, stupid me
19:18:44 <Cale> tan?
19:18:55 <erisco> yes, cot = 1/tanx
19:19:09 <Cale> right, I thought we'd agreed we're not using that?
19:19:19 <erisco> we are, why would we not be?
19:19:31 <erisco> unless I am missing something again
19:19:39 <Cale> Well, read the next couple paragraphs
19:19:44 <TheColonial> Would someone mind taking a look at a comment on a blog post of mine and perhaps offer some more guidance than what I can give? It's a question around using point-free.
19:20:06 <erisco> Cale, I have read the whole thing
19:20:22 <Cale> They give an algebraic expression which tells you, I think something equivalent to the cotangent
19:20:51 <mike-burns> TheColonial: Post the link.
19:21:05 <TheColonial> http://buffered.io/2009/06/27/point-free-style-what-is-it-good-for/comment-page-1/#comment-1388
19:21:08 <erisco> Cale, they give me expression that will tell me what way it turns
19:21:20 <TheColonial> mike-burns: didn't want to just paste it in and annoy people :)
19:21:46 <hdevalence> erm, is there a particular reason why Data.Colour uses British spelling?
19:21:54 <TheColonial> my response i think is valid, but I think more able Haskell coders could come up with a better solution.
19:22:04 <Cale> hdevalence: It's how most of the world spells it.
19:22:16 <hdevalence> Cale: it's how I spell it
19:22:28 <erisco> Cale, but they do say that I can calculate the cotangent using simple arithmetic... I do not understand how that would be possible
19:22:32 <hdevalence> Cale: but I have never seen it before in programming...
19:22:36 <pikhq> hdevalence: It's how I spell it. ... Sometimes.
19:22:52 * pikhq is USAian.
19:23:27 <hdevalence> usually everything is Americanized
19:25:21 <Cale> @let f (x1,y1) (x2,y2) (x3,y3) = (x2 - x1)*(y3 - y1) - (y2 - y1)*(x3 - x1)
19:25:22 <lambdabot>  Defined.
19:25:46 <Cale> @let g = f (0,-1) (0,0)
19:25:47 <lambdabot>  <local>:6:4:
19:25:48 <lambdabot>      Ambiguous occurrence `f'
19:25:48 <lambdabot>      It could refer to either `L....
19:25:51 <Cale> oh, grr
19:25:54 <Cale> @undefine
19:26:02 <Cale> @let cross (x1,y1) (x2,y2) (x3,y3) = (x2 - x1)*(y3 - y1) - (y2 - y1)*(x3 - x1)
19:26:03 <lambdabot>  Defined.
19:26:22 <Cale> @let turn = cross (0,-1) (0,0)
19:26:23 <lambdabot>  Defined.
19:26:29 <Cale> > turn (1,1)
19:26:31 <lambdabot>   -1
19:26:37 <Cale> > 1/tan(pi/2)
19:26:38 <lambdabot>   6.123233995736766e-17
19:26:41 <Cale> > 1/tan(pi/4)
19:26:42 <lambdabot>   1.0000000000000002
19:26:48 <Cale> > turn (0,1)
19:26:50 <lambdabot>   0
19:26:53 <Adamant> Cale: I think more of the world uses the Mandarin version :P
19:27:20 <erisco> Cale, I already have the portion that decides what way three points turn working
19:27:23 <pikhq> Adamant: There's more English speakers than Mandarin speakers; there's simply more *native* Mandarin speakers. ;)
19:27:34 <Cale> Adamant: But that's not English. Using Chinese characters to write English is an interesting idea though.
19:27:46 <erisco> Cale, that does not have anything to do with my current problem
19:27:49 <Cale> è²
19:27:56 <pikhq> Cale: It's been suggested as a spelling reform.
19:28:14 <Adamant> Cale: I'd argue using the French spelling isn't really English either :P
19:28:27 <Cale> erisco: My point is that this 'turn' thing is basically computing the cotangent of a particular angle
19:28:33 <pikhq> Someone did a study with teaching children to read English written in hanzi. ... They picked it up faster, since Chinese is more consistent.
19:28:37 <Adamant> pikhq: there are a LOT of non-native Mandarin speakers
19:28:41 <Cale> (and by extension, so is 'cross')
19:28:42 <erisco> Cale, it is calculating the cross product
19:28:52 <pikhq> Adamant: Yes, most of China, for example.
19:28:59 <Adamant> pikhq: right.
19:29:28 <erisco> Cale, sorry, no its now
19:29:30 <erisco> not*
19:30:06 <erisco> Cale, but the calculation it is doing, all it is giving me is positive, negative, or zero
19:30:25 <erisco> Cale, it does not tell me of any other meaningful information according to the algorithm description
19:31:09 <mike-burns> TheColonial: Why does ghc infer the type to be Integer -> Integer when it's written point-free?
19:31:17 <Cale> It is giving you what is effectively the cotangent of the angle between the two segments.
19:31:46 <Cale> erisco: well, not quite :)
19:32:00 <roconnor> hdevalence: Colour lib is spelled that way because the author of the lib is Canadian.
19:32:02 <TheColonial> mike-burns: To be honest, I'm not too sure. Adding the type sig seems to fix it (well, in the case of what I wrote it does ;))
19:32:12 <erisco> Cale, but you are right, it does say that I can somehow calculate my cotangent with just simple arithmetic
19:32:13 <Cale> erisco: It's cot(pi/2) when the segments are collinear
19:32:28 <erisco> Cale, I wish it was more specific, because I cannot make heads or tails of what it talks about
19:32:35 <mike-burns> :t sum
19:32:37 <lambdabot> forall a. (Num a) => [a] -> a
19:32:37 <Cale> So I suppose it's really giving the cot of pi/2 + the angle between the segments
19:32:44 <TheColonial> mike-burns:
19:32:55 <TheColonial> mike-burns: adding type sig to both options seems to work
19:33:16 <mike-burns> It does indeed.
19:33:26 <erisco> Cale, that expression works with three points. this stage of the algorithm only works with two
19:33:32 <Cale> erisco: So when it is more positive, you know that's more of a turn to the left
19:33:42 <mike-burns> :t replicate
19:33:43 <lambdabot> forall a. Int -> a -> [a]
19:33:48 <erisco> Cale, I know what that other expression does,  I already have it working and programmed
19:33:55 <erisco> Cale, this is a different part of the algorithm
19:34:09 <Cale> erisco: you have three points which you pass to the ccw function.
19:34:32 <erisco> Cale, this is not at that stage... I am in paragraph two sorting my list of points
19:35:07 <erisco> Cale, and that only involves two points, point P and each sequential point in the list
19:35:47 <Cale> Well, you want the cotangent of the angle they make with the positive x-axis, yeah?
19:36:06 <erisco> Cale, it does not specify which side of the x-axis
19:36:14 <erisco> so, I am presuming it means in general
19:36:21 <Cale> Well..
19:36:36 <erisco> since there is no said restriction on having only positive points
19:36:58 <erisco> and the algo doesn't make sense if it is against the positive axis with negative points
19:37:14 <erisco> the idea of the algo is to pick the bottom left point and then wrap around the outside by only turning left
19:38:12 <erisco> but to know what order to try the points in, it has to know the angle between every point and point P, presuming they form a right-angled triangle
19:38:12 <Cale> So in the diagram, you're sorting the points A,B,C,D in that order because the angle which they make with the positive x axis is in increasing order.
19:38:24 <erisco> a right-angled triangle with the right angle on the down-side, not the up-side
19:38:29 <erisco> that is how I understand their algo
19:39:12 <Cale> I'll make a better diagram...
19:39:57 <erisco> Cale, yes, I am trying to put those points into increasing order
19:40:04 <erisco> Cale, my efforts are failing
19:40:19 <erisco> I cannot figure out this magical cotangent thing they speak of
19:40:27 <erisco> as I ran into a problem when P is, for example, the origin
19:40:59 * copumpkin moos furiously
19:41:05 <erisco> and since they do not speak of any restrictions as to what each point can be (ie, none can have a 0 node and must all be in the positive quadrant)
19:41:39 <erisco> my presumption is that any points are valid, and the algo makes sense even if it is not all positive quadrant... it some of the numbers that are not working nicely
19:41:44 <divs> what's the deal with the haskell reddit page, is it down for everyone or just me?
19:42:17 <gwern> works here
19:42:20 <codebliss> Oh haskellers, please forgive me for I have lost my mind
19:42:37 <divs> tells me the service is temporary unavailable.  :(
19:42:47 <soupdragon> I forgive you
19:42:56 <erisco> Cale, and when they say cotangent of the angle, that is just the adjacent over opposite, not the inverse tan, which is why I was originally doing a/o
19:43:15 <codebliss> I just defined this function like this, NATURALLY.  incState = State $ flip (,) 0 . (+1)
19:43:24 <erisco> Cale, but when that failed because of the origin point, I ran into trouble
19:43:31 <codebliss> Why not incState = State $ \x -> (x+1,0)?
19:43:35 <codebliss> I've gone insane.
19:44:33 <erisco> Cale, inverse tan, I mean reciprocal of tan
19:44:34 <Cale> codebliss: Or better yet.  incState = modify (+1)
19:44:42 <Cale> http://cale.yi.org/share/graham1.png
19:44:55 <Cale> erisco: that's the order we want, yeah?
19:45:12 <coCocoa> erisco: You mean the "pallor" function? ;)
19:45:27 <erisco> Cale, actually, yeah, positive x-axis is seeming good
19:45:36 <hdevalence> OK, I'm having trouble installing the Data.Colour module...
19:45:37 <codebliss> Cale: The point is that I actually wrote that.  I know that exists XD
19:45:39 <erisco> Cale, presuming you translate point P to the origin when doing this
19:45:47 <roconnor> hdevalence: what's the trouble?
19:46:10 <bgs100> > zip "Hello" "     "
19:46:12 <lambdabot>   [('H',' '),('e',' '),('l',' '),('l',' '),('o',' ')]
19:46:21 <coCocoa> Cale: modify succ? ;p
19:46:46 <hdevalence> roconnor: well, I tried installing cabal-install, but for some reason it put stuff in /root/.cabal instead of in some system dir, and then I got it to install colour, but ghci can't find it.
19:46:52 <bgs100> > zip [ x,y | x,y <- zip "Hello" "     " ]
19:46:52 <FunctorSalad> > forever fail
19:46:52 <erisco> Cale, but, yeah, I just cannot grasp how the cotangent is supposed to work
19:46:54 <lambdabot>   <no location info>: parse error on input `|'
19:46:54 <lambdabot>   Add a type signature
19:46:59 <erisco> Cale, it works in some cases and fails in others
19:47:08 <bgs100> > zip [ x,y | x,y <- (zip "Hello" "     ") ]
19:47:10 <lambdabot>   <no location info>: parse error on input `|'
19:47:27 <bgs100> > zip [ x:y | x,y <- (zip "Hello" "     ") ]
19:47:28 <roconnor> hdevalence: what does ghc-pkg list colour say?
19:47:29 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
19:47:35 <roconnor> hdevalence: what does "ghc-pkg list colour" say?
19:47:40 <bgs100> > zip [ x:y | (x,y) <- (zip "Hello" "     ") ]
19:47:42 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:48:14 <erisco> Cale, if my points are (0,0), (1,1), (1,2), the algo correctly chooses (0,0) as the bottom-left, but it incorrectly puts (2,1) before (1,1) even though (1,1) has a lesser angle
19:48:36 <erisco> Cale, because 1/1 is larger than 1/2
19:48:48 <roconnor> heh, Andrew Coppin has a Colour library too.
19:48:50 <hdevalence> roconnor: looks like it's not found, I get "/usr/lib64/ghc-6.10.3/./package.conf:" but no lines under that, like I do with, say, "ghc-pkg list random"
19:48:51 <erisco> Cale, so I really do not get what I am to do in this case
19:49:18 <roconnor> hdevalence: sounds like it isn't installed properly
19:49:24 <hdevalence> roconnor: yes
19:49:27 <Cale> http://cale.yi.org/share/graham2.png
19:49:36 <bgs100> > zip [ (x,y) | x,y <- (zip "Hello" "     ") ]
19:49:38 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
19:49:48 <bgs100> er
19:49:52 <bgs100> > [ (x,y) | x,y <- (zip "Hello" "     ") ]
19:49:53 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
19:49:56 <hdevalence> I don't know how to install stuff, this is my first program :(
19:49:58 <Cale> erisco: This shows what it is that the cross function is computing for you
19:50:00 <coCocoa> > unzip [ (x,y) | x,y <- (zip "Hello" "     ") ]
19:50:01 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
19:50:06 <bgs100> > [ (x,y) | (x,y) <- (zip "Hello" "     ") ]
19:50:08 <lambdabot>   [('H',' '),('e',' '),('l',' '),('l',' '),('o',' ')]
19:50:08 <roconnor> hdevalence: do you want cabal to install it as user, or as root?
19:50:10 <bgs100> :P
19:50:14 <Cale> erisco: note that it's signed, and so the displayed value will be negative
19:50:22 <Cale> er, no, positive :)
19:50:26 <hdevalence> roconnor: preferably system-wide, but either is fine
19:50:31 <roconnor> hdevalence: or maybe I should say as user, or as global
19:50:34 <roconnor> ya
19:50:40 * Cale thinks if perhaps he's misplaced 'a'...
19:50:48 <Cale> oh, d'oh, I did :)
19:51:09 <mike-burns> Why would I want cabal to install something as user if it could instead install it as global?
19:51:37 <erisco> Cale, I am not sure what you are trying to say
19:53:38 <dancor> i'm getting a strange error with parsec 2/3 when i compile ConfigFile but only if i compile with profiling
19:54:00 <bgs100> > [ [x,y] | (x,y) <- (zip "Hello" "     ") ]
19:54:00 <lambdabot>   ["H ","e ","l ","l ","o "]
19:54:01 <bgs100> > concat [ [x,y] | (x,y) <- (zip "Hello" "     ") ]
19:54:01 <lambdabot>   "H e l l o "
19:54:01 <roconnor> hdevalence: what does "ghc-pkg list Cabal" say?
19:54:02 <bgs100> There's got to be a better way to do that :P
19:54:02 <Cale> http://cale.yi.org/share/graham2.png -- fixed
19:54:02 <mike-burns> bgs100: `intercalate', perhaps?
19:54:02 <bgs100> :t intercalate
19:54:02 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:54:02 <Cale> erisco: my point is that there's a good choice of A and B in order that you can compute the cotangents using cross
19:54:02 <canvon> > intercalate ' ' "Hello"
19:54:02 <lambdabot>   Couldn't match expected type `[a]'
19:54:02 <canvon> > intercalate " " "Hello"
19:54:02 <aavogt> > concatMap (++" ") "Hello"
19:54:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:54:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:54:03 <aavogt> > concatMap (:" ") "Hello"
19:54:03 <bgs100> > intercalate " " ["Hello"
19:54:03 <lambdabot>   "H e l l o "
19:54:03 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:54:03 <bgs100> > intercalate " " ["Hello"]
19:54:03 <lambdabot>   "Hello"
19:54:03 <Cale> erisco: You just use (P - (0,1)), P, and each Q
19:54:03 <aavogt> > intersperse ' ' "hello"
19:54:03 <lambdabot>   "h e l l o"
19:54:03 <bgs100> Oh :P
19:54:03 <Cale> erisco: and pass those three to cross, and you'll get the cotangent of the angle which the line PQ makes with the x-axis
19:54:03 <mike-burns> :t intersperse
19:54:03 <lambdabot> forall a. a -> [a] -> [a]
19:54:17 <aavogt> :t (concat .) . intersperse
19:54:19 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:54:29 <copumpkin> :t zomg
19:54:31 <lambdabot> Not in scope: `zomg'
19:54:37 <bgs100> > [ [x] | x -> "Test" ]
19:54:38 <lambdabot>   <no location info>: parse error on input `->'
19:54:43 <Cale> erisco: Just imagine that A is any point directly south of P, and that B is P, and then take C to be each of the Q's in the first diagram
19:54:44 <bgs100> > [ [x] | x <- "Test" ]
19:54:46 <lambdabot>   ["T","e","s","t"]
19:54:55 <hdevalence> roconnor: /usr/lib64/ghc-6.10.3/./package.conf: \n Cabal-1.6.0.3
19:55:09 <bgs100> > intercalate " " [ [x] | x <- "Hello" ]
19:55:10 <lambdabot>   "H e l l o"
19:55:18 <hdevalence> sorry, my IRC client went weird there and didn't show any text for a while...
19:55:42 <Cale> Let's try...
19:55:59 <erisco> Cale, O - M - G
19:56:03 <roconnor> hdevalence: that's good
19:56:10 <erisco> Cale, I had my god damned compare backwards
19:56:12 <roconnor> hdevalence: how about we try "cabal install --global colour"
19:56:14 <erisco> Cale, all this time...
19:56:22 <roconnor> --global should be default, but we will try it
19:56:32 <Cale> erisco: aha, so it's working now?
19:56:36 <erisco> Cale, it is DECREASING! and I wrote it as if it was supposed to INCREASE
19:56:43 <roconnor> hdevalence: oh, you might need to sudo that unless you have that configured to go automatically.
19:56:53 <erisco> Cale, yes, as I said, the second part with calculating the turns has nothing to do with the first part
19:57:17 <Cale> erisco: But it does, as I just tried to explain
19:57:28 <Cale> erisco: You can use the same cross function to compute it
19:57:29 <hdevalence> roconnor: aha, now it works...
19:57:35 <erisco> Cale, maybe through some weird way you can get the cotangent out of that expression
19:57:41 <erisco> Cale, but there is a farrrrr easier way to do it
19:57:50 <Cale> Not a particularly strange way...
19:58:21 <Cale> cross (px,py-1) (px,py) (qx,qy) will compute the cotangent you want
19:58:27 <Cale> (I'm pretty sure)
19:59:38 <hdevalence> roconnor: thanks for the help
19:59:42 <Cale> erisco: you can think of it as that you're ordering the points according to how far left a turn they are when you attach a vertical line segment below P
19:59:57 <Cale> erisco: So if you have a function which computes that already :)
20:00:25 <erisco> Cale, all you need to do is calculate the cotangent of the angle between point P and each point in the list
20:00:44 <Cale> Er, sort of :)
20:00:52 <bgs100> > intercalate " - " [ [x] | x <- "OMG" ]
20:00:54 <lambdabot>   "O - M - G"
20:01:02 <erisco> Cale, so given point P and point B, this is just (Px - Bx)/(Py - By)
20:01:04 <Cale> Of course, P is a point and not a ray ;)
20:01:06 <bgs100> <erisco> Cale, O - M - G ^^ :)
20:01:22 <hdevalence> bgs100: finally, a use for haskell :)
20:01:24 <erisco> bgs100, :P
20:01:47 <bgs100> > intersperse " - " "hello"
20:01:49 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:02:08 <erisco> intersperse ' - ' "hello"
20:02:13 <roconnor> I really need to make a colour tutorial on the wiki
20:02:16 <erisco> > intersperse ' - ' "hello"
20:02:18 <lambdabot>   <no location info>:
20:02:18 <lambdabot>      lexical error in string/character literal at chara...
20:02:24 <erisco> *shrug* dunno what I did :P
20:02:27 <bgs100> ErhardtMundt, ' - ' is not a valid character
20:02:28 <hdevalence> hm, if I open ghci and do "import Data.Colour", and then try something like "hsv 1 1 1", it tells me the function isn't in scope. Am I calling the function wrong?
20:02:30 <dancor> a lot of packages have 'parsec < 3' that shouldn't.  so i have to grab them and manually remove the constraint.  i guess i'll hack up my cabal-install to enable it to ignore-certain-constraints..
20:02:31 <bgs100> tabfail :P
20:02:35 <erisco> bgs100, oh of course lol
20:02:47 <erisco> >intercalate " - " "hello"
20:02:51 <erisco> > intercalate " - " "hello"
20:02:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:03:00 <canvon> > intercalate " - " ["hello"]
20:03:01 <lambdabot>   "hello"
20:03:03 <erisco> *shrug*
20:03:14 <canvon> <sigh> ;)
20:03:23 <bgs100> > intercalate " - " [ [x] | x <- "hello" ]
20:03:25 <lambdabot>   "h - e - l - l - o"
20:03:30 <aavogt> roconnor: I think colour is decently documented... not that tutorials aren't a bad thing
20:03:39 <erisco> bgs100, that is more syntax than I know right now :P
20:03:43 <bgs100> But I think there's a better way to do that...
20:03:48 <dancor> > intercalate " - " $ map (:[]) "hello"
20:03:50 <lambdabot>   "h - e - l - l - o"
20:04:19 <bgs100> > [ [x] | x <- "hello" ] -- <--- erisco
20:04:21 <erisco> Cale, now I just need to do the process where I crawl along and backtrack if I hit a right turn
20:04:21 <lambdabot>   ["h","e","l","l","o"]
20:04:30 <erisco> Cale, and I think my mind is too pooched to do it
20:04:41 <bgs100> dancor, How does that work?
20:04:58 <bgs100> > map (:[]) "hello"
20:04:59 <lambdabot>   ["h","e","l","l","o"]
20:05:04 <bgs100> Oh
20:05:10 * erisco even got how that one worked :P
20:05:18 <bgs100> > intercalate " - " map (:[]) "hello"
20:05:20 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
20:05:27 <bgs100> > intercalate " - " (map (:[]) "hello")
20:05:29 <lambdabot>   "h - e - l - l - o"
20:06:00 <erisco> Cale, thanks for the help working on the sorting though
20:06:08 <bgs100> > map (++ []) "test"
20:06:09 <lambdabot>   Couldn't match expected type `[a]'
20:06:28 <bgs100> Oh, wait, nvm
20:06:29 <dancor> @pl \ x -> [x]
20:06:29 <lambdabot> return
20:06:33 <dancor> @pl \ x -> x:[]
20:06:33 <lambdabot> return
20:06:35 <dancor> hah
20:06:53 <dancor> anyway it's also (:[])
20:07:02 <bgs100> I know why ++ didn't work
20:07:07 <bgs100> It expects 2 lists
20:07:10 <aavogt> > foldr (\x -> (x:" - ")++) "" "hello"
20:07:11 <lambdabot>   <no location info>: parse error on input `)'
20:07:17 <mike-burns> > map return "hello"
20:07:19 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
20:07:19 <lambdabot>    arising from a use of...
20:07:30 <bgs100> > map () "test"
20:07:32 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `()'
20:07:33 <aavogt> > foldr (\x -> ((x:" - ")++)) "" "hello"
20:07:34 <lambdabot>   "h - e - l - l - o - "
20:07:36 <dancor> map (return :: a -> [a]) "hello"
20:07:40 <dancor> > map (return :: a -> [a]) "hello"
20:07:42 <lambdabot>   ["h","e","l","l","o"]
20:07:59 <mike-burns> Oh that's a shame. Makes sense, of course.
20:08:25 <dancor> @pl (:[])
20:08:25 <lambdabot> return
20:09:07 <bgs100> > 1:2:3:[] ++ [4,5,6]
20:09:09 <lambdabot>   [1,2,3,4,5,6]
20:09:10 <canvon> > "hello" >>= (:" - ")
20:09:12 <lambdabot>   "h - e - l - l - o - "
20:09:21 <bgs100> O_O
20:09:46 <canvon> list monad. <hide> ... that's what the "return" that @pl speaks about hints at
20:09:54 <dancor> > reverse . drop 1 $ reverse "hellol"
20:09:55 <lambdabot>   "hello"
20:10:08 <roconnor> hdevalence: anything to promote my lib. :)
20:10:43 <hdevalence> roconnor: if you don't mind my asking, whereabouts in Canada are you?
20:11:00 <roconnor> aavogt: oh,  Andrew Coppin seems to find my colour lib intimidating.
20:11:10 <roconnor> hdevalence: Currently living in Kitchener
20:11:18 <hdevalence> ah, cool
20:12:27 <canvon> bgs100: that's just:
20:12:28 <canvon> > concatMap (:" - ") "hello"
20:12:30 <lambdabot>   "h - e - l - l - o - "
20:12:38 <canvon> > concat . map $ (:" - ") "hello"
20:12:40 <lambdabot>   Couldn't match expected type `[[a]]'
20:12:44 <canvon> > concat . map (:" - ") $ "hello"
20:12:45 <lambdabot>   "h - e - l - l - o - "
20:13:14 <hdevalence> also, is it better to use Float or Double?
20:13:27 <roconnor> hdevalence: Double.
20:22:47 <hdevalence> roconnor: what range of values are acceptable for s and v?
20:23:13 <roconnor> what is v?
20:23:14 <roconnor> and s?
20:23:16 <coCocoa> erisco: May I ask something? :)
20:23:30 <hdevalence> roconnor: for converting from HSV to RGB
20:23:38 <roconnor> ah
20:23:40 <hdevalence> h is in degrees, according to the doc
20:23:40 <roconnor> good question
20:23:43 <erisco> coCocoa, you already have, so may as well let you ask something else ;)
20:23:53 <coCocoa> erisco: Or, to be pedantic, may I ask you another question? ;p
20:24:03 <bgs100> erisco, Lol :D
20:24:21 * coCocoa saw it coming...but still ducked too slowly. ;)
20:24:25 <roconnor> hdevalence: ya I sort of copied the formulas kinda blindly from wikipedia
20:24:26 <erisco> heheh
20:24:32 <bgs100> Heh
20:24:54 <copumpkin> what's going on with the ICFP contest? there's no announcement or anything about what happened
20:25:04 <roconnor> hdevalence: they appear to go from 0 to 1
20:25:26 <hdevalence> ah, ok, that's what I expected, but it's good to check
20:25:39 <coCocoa> erisco: I was just wondering the terms under which you had to do that palindrome test, since I don't see why you wouldn't just say "isPalindrome xs = reverse xs == xs". :)
20:25:43 <ivanm> copumpkin: you mean something happened? :o
20:25:49 <ivanm> ;-)
20:25:58 <copumpkin> ivanm: no announcement of winner or anything? only rankings from 4 hours from the end of it?
20:26:00 <Cale> copumpkin: Don't they usually announce the results at the conference?
20:26:08 <roconnor> copumpkin: winners are announced at ICFP
20:26:13 <copumpkin> Cale: ah, I don't know
20:26:17 <erisco> coCocoa, ah, how I was originally splitting it in half and comparing the two halves?
20:26:55 <erisco> coCocoa, yeah, I shortly discovered afterwards that what you just wrote made way more sense.. it still isn't wholly optimal, but its shorter and a tiny bit faster
20:27:04 <erisco> coCocoa, by a whole .5n
20:27:54 <coCocoa> erisco: faster by .5n than what? :)
20:28:06 <dancor> doesn't it do twice as many comparisons as it needs to
20:28:11 <erisco> coCocoa, my method of splitting it in half and comparing the two halves
20:28:21 <erisco> dancor, yes it does
20:28:27 <jcd1> the winners may be quite different to those rankings, if they throw some curveballs in the final test cases
20:29:07 <coCocoa> Okay, that makes sense, when you know beforehand how long it is. If you don't then you burn up an n to find it, though. :)
20:29:11 <erisco> dancor, but without knowing the length, you cannot stop halfway... and to know the length is O(n), which you could piggy back on the O(n) reverse operation
20:29:52 <roconnor> aavogt: I guess the main use of a tutorial would be as a different order of introducing the functions.  Haddock makes a great reference, but not so great introduction.
20:29:57 <Warrigal> Is it possible to set the fixity of an operator such as `mod`?
20:30:17 <mike-burns> ... but, in reality, the `palindrome' function won't be the slowest function in your program.
20:30:20 <copumpkin> jcd1: I'm crossing my fingers :D
20:30:22 <Warrigal> Or only operators that are nominally infix?
20:30:27 <erisco> dancor, but I think the downfall is that then you suffer stack overflows if you try to inline length and reverse
20:30:39 <erisco> dancor, as reverse is optimized to avoid stack
20:30:48 <dancor> mm
20:30:48 <coCocoa> Warrigal: See the FAQ. ;)
20:31:02 <erisco> so my conclusion was that, while doable in imperative, I just cannot see yet how to do it in functional
20:31:20 <jcd1> copumpkin: :)
20:31:34 <Warrigal> !faq Can Haskell have nominally prefix operators with different fixities?
20:31:39 <Warrigal> @faq Can Haskell have nominally prefix operators with different fixities?
20:31:39 <lambdabot> The answer is: Yes! Haskell can do that.
20:31:45 <jcd1> copumpkin: it will all depend on how robust people's solutions are... whether they'll crash or use too much fuel or whatever if there's pathological test cases
20:31:47 <Warrigal> Good!
20:31:48 * roconnor tries to reread what erisco wrote to get that conclusion
20:31:48 <coCocoa> erisco: Look up "worker function" on the 'wiki. I think ajb's example uses reverse. :)
20:32:08 <dancor> erisco: if you have a linked list in an imperative language it's still hard right?
20:32:17 <erisco> dancor, saying it is doable in imperative is really not a fair thing to say though, because obviously the translation is weak. if I used an array, for example, I already know the length because they are fixed size and can do it lightening fast
20:32:22 <erisco> dancor, with O(1)indexing time
20:32:34 <erisco> dancor, yes, it is still hard, as I just tried to say
20:33:00 <dancor> ya i think this has everything to do with List and nothing to with imperative but i'm not sure
20:33:06 <erisco> roconnor, add a dash of "erisco doesn't know what hes doing" into the mix and you'll get there ;)
20:33:35 * roconnor is caught up now
20:33:48 <roconnor> dancor's comments seem spot on.
20:34:20 * dancor wins for once
20:34:50 <coCocoa> erisco: I figure if one sat down to think about it for a bit (maybe eight seconds for Cale, heh-heh), you could do a "tie the knot" version that gives you your ".5n" worst-case. :)
20:35:02 <erisco> I cannot think about it right now... my brainpower is gone
20:35:10 <erisco> too much thinking late at night
20:36:04 <erisco> coCocoa, my version is O(2.5n) while the reverse is O(2n), that is what I mean by I have an extra .5n
20:36:44 <uman> uh
20:36:53 <uman> do computer scientists use the same big-o notation as mathematicians?
20:37:03 <erisco> this is erisco
20:37:03 <uman> Because if so, there is no difference between O(2.5n) and O(2n)
20:37:10 <dancor> uman: ya
20:37:14 <erisco> erisco's complexity theory :P
20:37:17 <mike-burns> uman: Loosely, yes.
20:37:24 <dancor> but there's a difference between 2.5n and 2n ;)
20:37:34 <erisco> uman, class of function? no, they are the same, linear
20:37:42 <bgs100> @faq Can Haskell do *ANYTHING*?
20:37:42 <lambdabot> The answer is: Yes! Haskell can do that.
20:37:45 <bgs100> Lol
20:37:51 <uman> uh what is the difference
20:37:58 <uman> between O(2.5n) and O(2n)
20:38:05 <dancor> uman: there is no difference
20:38:07 <Cale> uman: nothing in reality
20:38:11 <erisco> uman, but when I say O(2n) I mean, in this case, it transverses the input list twice. in O(2.5n) it transverses it two and a half times
20:38:13 <pikhq> O(n).
20:38:26 <pikhq> erisco: That's O(n) and O(n).
20:38:28 <dancor> i would say 2n not O(2n) for that
20:38:34 <Cale> He's just writing the relative constant factors involved there
20:38:34 <erisco> uman, that is the difference, but yes, they are both O(n) in the sense they are both linaer
20:38:38 <erisco> linear*
20:38:51 <dancor> you are not obligated to use big-o when discussing complexity ;)
20:39:11 <erisco> well it looks cool and it indicates that I am talking about complexity :P
20:39:19 <uman> erisco: so you have invented your own notation and confusingly given it the same symbol as the big-O notation?
20:39:25 <pikhq> uman: Yes; computer science is, strictly speaking, a mathematical discipline. So, big-o notation is the same.
20:39:31 <coCocoa> erisco: How do you get that "the reverse is O(2n)" figure? Remember, "Laziness means never having to say, 'I'm sorry (I did all of that unnecessary work)'." ;)
20:39:36 <dancor> a
20:39:47 <dancor> a mathematician would never reuse a variable!
20:40:01 <uman> dancor: how right you are
20:40:05 <erisco> coCocoa, that is what I was asking the other day, if the list would be transversed once or twice
20:40:12 <uman> not
20:40:18 <erisco> coCocoa, but from what I remember the answer was it was transversed twice
20:40:19 <dancor> !
20:40:27 <mike-burns> uman: The CS big-O is the same as the math big-O, but the programming big-O kinda meaninglessly means "it's about this complex".
20:40:48 <uman> erisco: anyway, think about it this way. You have two algorithms. One traverses a list twice, the other only traverses once but spends twice as much time at each node
20:41:00 <erisco> uman, I understand that :P
20:41:14 <uman> erisco: so one is O(n) and one is O(2n)? What's the point of that ;)
20:41:17 <erisco> uman, but analyzing computer algorithms is not really easy anyhow
20:41:21 <dancor> we need a harder problem to discuss
20:41:29 <erisco> dancor, I have one!
20:41:39 <dancor> spill
20:41:55 <Cale> erisco: The real difference isn't the time in the changes you made, it's the memory.
20:41:56 <divs> sure they would dancor.  let e>0.  then there exist e such that for all e<e, limit e->infinity = 0
20:42:04 <Cale> erisco: Your space usage went from O(n) to O(1)
20:42:12 <divs> makes perfect sense IMO
20:42:12 <erisco> okay, I am implementing Graham's scan algorithm. I have everything done up to the point where I actually need to find the hull
20:42:26 <erisco> d'oh ;)
20:42:35 <uman> dancor: find a solution in positive integers for a^n + b^n = c^n, where n is an integer greater than 2
20:42:43 <uman> that should keep you occupied for a while
20:42:45 <uman> actually forever ;)
20:43:04 <dancor> programatizing that proof to check it would take a while..
20:43:20 <erisco> Cale, reverse does not make a duplicate? I have just been looking at computational complexity, not memory consumption as I really don't know when Haskell decides to copy stuff
20:43:22 <divs> i can solve that problem almost instantly uman
20:43:42 <Cale> erisco: reverse?
20:43:48 <uman> divs: since it's an impossible problem, I doubt that
20:43:52 <uman> divs: but go ahead
20:44:00 <Cale> erisco: Maybe I'm not remembering correctly or not talking about the same thing :)
20:44:00 <erisco> Cale, well, yeah, that is what the palindrome function uses
20:44:04 <Cale> erisco: ah
20:44:05 <divs> i was going to say empty set
20:44:16 <dancor> say _|_
20:44:35 <uman> divs: ah, but you'll notice I didn't say "describe the set of solutions"
20:44:41 <uman> divs: but rather "find a solution"
20:44:43 <dancor> _|_ means never having to say
20:44:48 <pikhq> erisco: It does as little as it can get away with. This makes it hard to predict.
20:45:27 <Cale> xs == reverse xs does make a reversed new list, but the reversed list won't stay in memory.
20:45:33 <erisco> pikhq, which can sometimes result in it doing more than it has to as I discovered earlier today
20:45:35 <Cale> But this isn't the algorithm I was thinking of :)
20:45:36 <uman> hm, I came in here hoping to ask if Haskell would be a fun language to learn and if so why
20:45:54 <uman> ended up seeing "but my algorithm is better because it's O(2n) not O(2.5n)
20:45:55 <uman> "
20:46:01 <uman> bad first impression :P
20:46:02 <coCocoa> uman: lambdabot makes every party fun! ;)
20:46:03 <dancor> ya haskell is for noobs
20:46:08 <pikhq> uman: erisco is a tiny bit of a Haskell noob.
20:46:08 <copumpkin> lol
20:46:08 <Cale> uman: There are a number of reasons that Haskell is fun to learn.
20:46:22 <uman> Cale: like what?
20:46:25 <erisco> pikhq, uman, no, I am *the* Haskell noob ;)
20:46:30 <pikhq> > fibs = 0:1:zipWith (+) fibs (tail fibs)
20:46:31 <pstickne> uman:  it's a very, very large n :0
20:46:31 <lambdabot>   <no location info>: parse error on input `='
20:46:39 <pikhq> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
20:46:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:46:42 <uman> pstickne: you're in like every channel
20:46:49 <divs> well what's your favorite language uman?
20:46:50 <uman> :P
20:46:54 <uman> divs: English
20:47:02 <erisco> uman, but seriously, one algorithm is faster than the other and I do not know how else to describe that. how would you do it?
20:47:03 <pikhq> ^ That infinite list answer anything?
20:47:12 <divs> i almost qualified my question with programming language :)
20:47:13 <Cale> uman: Well, mainly all of the ideas about programming that it embodies, which will probably force you to re-examine how you write programs.
20:47:20 <dancor> if you are into English then you want #python ;)
20:47:22 <uman> divs: C#
20:47:27 <dancor> #applescript
20:47:28 <pstickne> dancor:  #appletalk :-)
20:47:31 <uman> dancor: lol VB.NET
20:47:33 <pstickne> oh, doh, I failed.
20:47:46 <dancor> in this case, it's more embarrassing not failing
20:47:49 <uman> divs: or C, but I don't know C very well
20:47:59 <pikhq> erisco: Discuss actual time. Algorithmic complexity only has a loose correlation with speed.
20:48:02 <Cale> uman: For one, Haskell functions are referentially transparent, which means that the results of functions only depend on the values of their parameters, and nothing else.
20:48:03 <uman> divs: as pstickne will attest from his observations of me in ##c
20:48:04 <divs> then learning haskell will make you a better C# programmer, especially with modern aspects of C# like LINQ which borrow heavily from functional programming languages
20:48:13 <Cale> uman: This is just like in mathematics.
20:48:18 <erisco> pikhq, in form of benchmarking?
20:48:24 <pikhq> erisco: Yes.
20:48:34 <coCocoa> erisco: Nope, sorry - you were the "Haskell Noob of the Day" two days ago; now, you're just another Haskell novice. ;)
20:48:36 <erisco> pikhq, I was too lazy for that ;) but yes, I get what you mean
20:48:43 <uman> erisco: you could say it's n% faster
20:48:56 <uman> Cale: Is a corollary of that that functions can't have side effects?
20:48:58 <erisco> uman, okay, thanks, I will do that then
20:49:04 <uman> At least not side effects that are visible to the program
20:49:17 <Cale> uman: Well, they're sort of restatements of one another, yeah.
20:49:28 <erisco> coCocoa, :(
20:49:29 <Cale> uman: depending on what you mean by 'side effects'
20:49:45 <erisco> coCocoa, you've been keeping track though, and that has to count for something
20:49:50 <divs> one thing interesting about Haskell is that there are so many ways to solve the same problem.  people say that about perl but it's even more true in Haskell.
20:49:52 <coCocoa> What, no #tcl? Pikers! ;)
20:49:56 <uman> Cale: in that case it would seem that every Haskell program executes in exactly the same way every time it is run
20:49:58 <Cale> If f x = g x for all x, then you can replace f with g anywhere without changing the meaning of the program.
20:50:09 <Cale> uman: There is a way to handle I/O
20:50:11 <uman> which obviously isn't the case
20:50:17 <divs> you can have 100 functions that are all 1 line long, have the same result, and look completely different
20:50:35 <uman> divs: do they all print "JAHH"?
20:50:58 <divs> i suspect that can be arranged
20:51:01 <Cale> uman: What we do is to construct values which represent effects to be carried out, and these computation-values have results (but not necessarily parameters, so they are not the same thing as functions)
20:51:07 <dancor> divs: in 80cols?
20:51:18 <dancor> ya i bet we could get 100
20:51:28 <uman> Cale: I can't parse what you just said
20:51:28 <Cale> uman: and we stick those descriptions of what to do together, and define 'main' as one of them
20:51:33 <uman> it sounds very interesting though
20:51:34 <Cale> uman: For example...
20:51:41 <Cale> getLine :: IO String
20:51:54 <Cale> is a value which embodies the process of reading a line of text from the user
20:52:03 <Cale> It's inert under evaluation
20:52:23 <dancor> > getLine
20:52:25 <lambdabot>   <IO [Char]>
20:52:38 <erisco> okay, well, before I make any more mistakes, I am going to bed, night all
20:52:44 <uman> so you can pass functions around as objects... this sounds like JavaScript
20:53:04 <mike-burns> You can pass functions around as values.
20:53:12 <Cale> You can pass it around between functions, put it into a datastructure, or anything else, and nothing will actually happen. In order for it to execute, either you need to name it on the ghci commandline (which executes IO actions when you give them) or, make it main or part of main
20:53:15 <pikhq> coCocoa: I'm in #tcl, though.
20:53:19 <divs> if you've used LINQ at all you've seen lots of things like Select, ForEach, Fold, Map, Choose.  all of these things have their roots in functional programming languages, so it will also give you deeper insight into the C# team's design decisions and the direction they're taking it in the future
20:53:22 <uman> I see
20:53:26 <solrize> @remember uman so you can pass functions around as objects... this sounds like JavaScript
20:53:27 <lambdabot> It is stored.
20:53:29 <Cale> But getLine itself isn't really what we'd call a function
20:53:42 <Cale> We call things like getLine actions
20:53:52 <Cale> and they're just plain values, like integers or strings
20:54:13 <uman> damn, if I had known you had a bot that saves the stupid things people say for future humorous enjoyment, I wouldn't have shown off my noobishness :)
20:54:25 <mikezackles> In case it's helpful to anyone..  I was asking about getting lambdabot to compile last night.  I was able to do so by changing all the instances of base to base >= 4 in the cabal file.
20:54:50 <Cale> uman: To be fair, you're right, Javascript does have first class functions and so does Haskell :)
20:55:02 <Cale> uman: (but the similarities don't go too far beyond that)
20:55:10 <uman> I suppose that's part of what being a "functional programming language" entails
20:55:13 <Cale> yeah
20:55:30 <uman> all I know about functional programming is from watching a 60-minute video on F#
20:55:32 <mmorrow_> if you try to program like you would in haskell in javascript though you end up reaching "maximum recursion depth" pretty fast though :(
20:55:33 <Cale> we also have things like:
20:55:33 <uman> so, not all that much
20:55:34 <Rotaerk> I've been reading about the expression problem lately, and I couldn't help but come up with my own solution (although I still have lots of solutions left to read through, so it'd be presumptious to say it's original or better than existing solutions)
20:55:38 <Cale> putStrLn :: String -> IO ()
20:55:39 <divs> passing functions around like objects is kind of analagous to delegates in C#.  but it's more powerful, because you can do things like creating a new function that is the result of fixing some argument of the original function to, say, 5.  and the result is a new function that simply takes 1 less argument
20:55:45 <roconnor> how to I make a Table of Contents for my haskell wiki page?
20:55:54 <uman> divs: you can do that in C#
20:55:55 <Cale> which is a function that takes a string, and constructs an IO action for printing that string on the screen
20:56:04 <Rotaerk> here's a simple approach in OO and FP (in F#): http://codepad.org/zK7VMkrT
20:56:09 <hdevalence> roconnor: I have a type "data Shape = Shape Path RGB" but I get the error that RGB is not applied to enough type arguments. How do I specify them ?
20:56:13 <Cale> So, "Hello, World" in Haskell looks like:
20:56:14 <divs> you can?  lol i haven't used C# since .NET 2.0 or something
20:56:17 <divs> i know you can do it in F#
20:56:20 <Rotaerk> and then here's my theoretical syntax:  http://codepad.org/8tdqkYdU
20:56:20 <Cale> main = putStrLn "Hello, World!"
20:56:30 <uman> divs: oh, well they added anonymous delegates in .NET 3.0 I think
20:56:36 <Cale> uman: We define the main action to be that putStrLn.
20:56:45 <uman> divs: and those make it easy to do what you're saying
20:56:45 <roconnor> hdevalence: (RGB Double) or whatever you are using
20:56:51 <erisco> uman, best of luck learning Haskell. It's true, I'm very new and trying to get help, so don't let me represent the otherwise intelligent Haskell community members ;) I'm off to bed now, g'night
20:56:54 <pikhq> And cat looks like: main = getContents >>= putStr -- but I'm getting ahead of myself.
20:57:01 <mmorrow_> , fmap ($ [1..9]) [sum,product,length]
20:57:03 <lunabot>  [45,362880,9]
20:57:03 <uman> erisco: don't worry, now I will be as much of a haskell newb as you :)
20:57:06 <Cale> uman: Of course, you can't really do much with just single actions, so we need a way to stick them together into larger ones.
20:57:12 <roconnor> hdevalence: although I recommend (Colour Double) instead of using RGB.
20:58:11 <Cale> uman: First of all, there's an infix operator >> so that if x and y are actions, then x >> y is the action which when it gets run will run x (discarding its result) and then y, and its result is the result of y
20:58:41 <divs> ultimately one of the main advantages of haskell (and any functional language for that matter) is the ability to write highly generic code.  .NET's approach to generic code is with .net generics, which are sort of a bastardization of C++ templates but much less powerful.  in most non-functional languages you have to plan ahead to make a function generic, but in haskell it happens automatically.
20:58:44 <divs> so it leads to some interesting paradigms
20:58:46 <Cale> uman: So we can write    main = putStrLn "Hello" >> putStrLn "World"   and it will print those on separate lines.
20:59:08 <Cale> uman: Does that much make sense?
20:59:36 <uman> yes
20:59:45 <divs> Haskell is also hard, so if you like puzzles, math, or intellectual exercises, it's basically just "fun"
21:00:02 <Cale> okay, but often we want to decide what to do next as a function of what the result of the first action was, instead of discarding that result
21:00:21 <Cale> So, for example, maybe we want to get a line of text from the user, and then print it back out again
21:00:28 <uman> divs: I like all of those things
21:00:38 <Cale> So, what we're going to print is a function of what the result of the getLine was
21:01:09 <uman> oh, I just remembered I have ghc installed from when I wanted to compile xmonad
21:01:12 <uman> sweet, I can follow along
21:01:29 <Cale> uman: So there's a more powerful operation called >>= so that x >>= f when run, will run x, apply f to its result and f will produce another action, which it runs.
21:01:47 <Cale> So we can write:  main = getLine >>= putStrLn
21:02:17 <mmorrow_> @type do l <- getLine; return ($ l)
21:02:18 <Cale> and this defines main as an action which, when you run it, will get a line of text from the user, and then apply putStrLn, which gives another action
21:02:19 <lambdabot> forall b. IO ((String -> b) -> b)
21:02:54 <Cale> There is a special syntax called do-notation which is convenient if we have a lot of these actions to chain together
21:03:05 <pikhq> mmorrow_: Did you really want return ($ l)? I... Am not sure why you'd want want that in the IO monad. :P
21:03:11 <Cale> We can also write that as   main = do v <- getLine; putStrLn v
21:03:18 <mmorrow_> pikhq: because i had to getLine
21:03:24 <Cale> and that's automatically translated into the version with >>=
21:03:26 <bgs100> night
21:03:38 <mmorrow_> pikhq: ("just cuz" ;)
21:03:42 <Cale> (actually there's another lambda there, but it doesn't make much difference)
21:03:49 <Cale> @undo do v <- getLine; putStrLn v
21:03:49 <lambdabot> getLine >>= \ v -> putStrLn v
21:04:30 <uman> hmm
21:04:33 <coCocoa> mmorrow_: Surely you meant: "For the 'lulz'" - or is that "4 teh lulz0rz"? ;p
21:04:43 <uman> so conceptually, the >>= is almost like "pipe" in UNIX shells
21:04:45 <Cale> If you want, I can explain the rules it uses to do that translation
21:04:50 <mmorrow_> pikhq: imagine:  do db <- <all this crap to get a DB handle>; return (\k -> k db)
21:04:50 <Cale> Yeah, a little
21:04:58 <uman> Cale: you don't have to
21:05:07 <uman> Cale: I appreciate the personal tutorial :) I am definitely intrigued
21:05:23 <pikhq> uman: In a way, "pipe" is a subset of the capabilities of >>=/
21:05:28 <Cale> uman: You know what the syntax  \v -> putStrLn v  means already, yeah?
21:05:33 <Cale> > (\x -> x^2) 5
21:05:34 <lambdabot>   25
21:05:34 <pikhq> mmorrow_: Ah.
21:05:42 <Cale> > map (\x -> x^2) [1..10]
21:05:43 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
21:05:48 <mmorrow_> coCocoa: yes both :)
21:05:48 <divs> there's a number of good haskell tutorials online?  have you seen any of them?  the best one to get your feet yet is probably learn you a haskell for great good, and then after that probably Yet Another Haskell Tutorial.
21:05:55 <uman> Cale: no, I know nothing
21:05:57 <divs> sorry first sentence should end with a period lol
21:06:41 <uman> divs: "learn you a haskell for great good"?
21:06:46 <uman> Is that really the name of a serious document?
21:06:48 <pikhq> uman: Not even lambda? Your mind will be blown three or four different ways before you even start getting monads. ;)
21:06:50 <divs> yes lol
21:06:57 <Cale> uman: basically, (\{vars} -> {result}) is a function-literal
21:06:59 <mike-burns> uman: http://learnyouahaskell.com/
21:07:17 <Cale> uman: Reasonably serious, not *too* serious :)
21:07:20 <uman> Cale: okay
21:07:26 <mike-burns> It's not a serious document, but it's a wonderful Haskell tutorial.
21:07:27 <ivanm> uman: unfortunately :(
21:07:33 <uman> Haskell programmers seem a humorous lot
21:07:35 <Cale> uman: So if we write  (\x -> x^2 + x + 1)
21:07:38 <uman> naming things things like that
21:07:48 <ivanm> uman: no, that's just BONUS
21:07:49 <Cale> it's like we defined a function f x = x^2 + x + 1, and then used f there
21:07:57 <ivanm> he thinks he's funny
21:08:03 <uman> okay
21:08:06 <Cale> > (\x -> x^2 + x + 1) 5
21:08:07 <lambdabot>   31
21:08:12 <uman> I see
21:08:14 <divs> he's funnier than Larry Wall, i can't even read more than a page or two of that guy's stuff
21:08:26 <uman> it takes a twisted mind to invent perl
21:08:47 <divs> no offense larry wall if you're in this room reading this
21:08:51 <Cale> uman: Because it's a functional language and many functions take other functions as parameters, it would get tedious if we had to name every one of them
21:09:18 <Cale> So >>=, which takes a function as its second parameter, often takes one of these "lambda expressions"
21:09:34 <Cale> (the \ is supposed to be an ascii art Greek letter lambda Î»)
21:09:45 <uman> lol
21:09:50 <ivanm> yay for ascii art! ;-)
21:09:54 <uman> | is an ascii art Latin letter L
21:09:56 <uman> by the same token
21:10:03 <Cale> hehe
21:10:14 <uman> (ignore for a moment the fact that L is also ascii :D)
21:10:30 <Cale> |_()|_
21:10:39 <Cale> anyway
21:10:42 <ivanm> do I dare ask wtf that's meant to say?
21:10:47 <uman> ivanm: LOL
21:10:47 <pikhq> Yes, well, it was chosen back in the early 90s. Space cadet keyboards were going out of style and Unicode hadn't been introduced commonly yet. ;)
21:10:52 <ivanm> ahhhh
21:11:31 <uman> BONUS: nice name ;)
21:11:35 <uman> (for a tutorial)
21:11:37 <Cale> So, I think if all that so far makes sense, I can explain do-notation
21:11:41 <Warrigal> > let Ï = 5 in Ï
21:11:43 <lambdabot>   5
21:11:46 <Warrigal> Not bad.
21:11:56 <ivanm> Warrigal: you missed the "hac" there ;-)
21:12:04 <Cale> do { x } = x  -- when there's only one statement, there's no point in using do. This is a base case :)
21:12:19 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
21:12:27 <Warrigal> ivanm: no entiendo.
21:12:29 <uman> > do { (\x -> x^2 + x + 1) 5 }
21:12:31 <lambdabot>   31
21:12:36 <ivanm> Warrigal: hmmm?
21:12:36 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
21:12:47 <Warrigal> I don't get it.
21:12:58 <Cale> and for completeness' sake:
21:13:08 <ivanm> there was a hackathon called "Hac Ï" a couple of months ago
21:13:13 <Warrigal> Ah.
21:13:19 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
21:13:23 <Warrigal> > let Hac Ï = Hac 5 in Ï
21:13:25 <lambdabot>   Not in scope: data constructor `Hac'Not in scope: data constructor `Hac'
21:13:25 <mike-burns> The next Haskell tutorial should just be "go into #haskell and say that you're not sure whether you're interested in learning Haskell."
21:13:38 <Cale> The braces and semicolons are optional, and usually we let layout determine them
21:13:46 <Cale> So you'll see:
21:13:48 <Cale> do foo
21:13:52 <Cale>    v <- bar
21:14:03 <Cale>    quux v
21:14:24 <Cale> and this is the same as  do { foo ; v <- bar ; quux v }
21:14:31 <Cale> which we can translate to
21:14:39 <Cale> foo >> do { v <- bar ; quux v }
21:14:41 <Cale> and then
21:14:53 <Cale> foo >> bar >>= \v ->  do { quux v }
21:14:58 <Cale> foo >> bar >>= \v -> quux v
21:15:12 <uman> sorry what does "\v -> quux v" mean
21:15:17 <uman> I don't think you've mentioned "->"
21:15:25 <uman> oh
21:15:26 <uman> nevermine
21:15:27 <Cale> It's a function which when it gets a parameter v
21:15:31 <Cale> returns quux v
21:15:38 <Cale> So, it's the same function as quux really
21:15:43 <uman> yes I was thrown off by the lack of parentheses
21:15:44 <uman> :P
21:15:47 <Cale> right
21:15:49 <Cale> sorry about that
21:15:54 <uman> not your fault
21:16:31 <Cale> The rule for lambdas is that they eat as much of the following part of the expression as will parse
21:16:40 <Cale> So you can nest them
21:16:56 <Cale> foo >>= \x -> bar >>= \y -> return (x,y)
21:17:00 <Cale> is the same as
21:17:06 <Cale> foo >>= (\x -> bar >>= (\y -> return (x,y)))
21:17:11 <coCocoa> uman: Haskell was started by escapees from the Lisp Asylum. Thus, there's cultural pressure to avoid parens at all costs, even if it means using other, equally odd-looking characters. :)
21:17:59 <pikhq> This is also why we have infix operators.
21:17:59 <uman> what's "return (x,y)" do?
21:18:02 <uman> what is (x,y)
21:18:04 <Cale> (which is the same as  do x <- foo; y <- bar; return (x,y)
21:18:08 <Cale> ah
21:18:10 <pikhq> (x,y) is a tuple of x and y.
21:18:12 <Cale> (x,y) is just a pair
21:18:15 <uman> okay
21:18:19 <Cale> > ("hello", 5)
21:18:20 <lambdabot>   ("hello",5)
21:18:26 <uman> does (a,b,c,d,e) work similarly
21:18:28 <mike-burns> uman: Also of note is that `return' is not the return from C, C#, etc.
21:18:29 <uman> or is it just for 2-tuples
21:18:31 <Cale> uman: yep :)
21:18:34 <uman> okay
21:18:43 <pikhq> It's for n-tuples.
21:18:53 <Cale> uman: Though, we don't often use larger tuples, because if you have large tuples it's a sign that maybe you should define a new datatype
21:19:03 <uman> define "large"
21:19:06 <divs> chuck norris uses large tuples
21:19:11 <Cale> More than 2 or 3 elements
21:19:29 <pikhq> divs: Chuck norris also programs in combinatorial calculus.
21:19:36 <uman> I've often wished C/C++/VB.NET/C# has support for tuples as a language feature
21:19:45 <Cale> return is an interesting thing though
21:19:56 <uman> I mean yeah, std::pair is cool, but it'd be nicer if they did it like Python, and, apparently Haskell
21:20:11 <Cale> return is a function which takes any value and makes an IO action which does nothing at all, but it has that value as its result
21:20:21 <divs> C++ does.  well kind of, you need boost.  but even then it's a little clunky until compilers start supporting C++0x variadic templates
21:20:38 <divs> but with c++0x variadic templates you get real tuples
21:20:45 <uman> divs: er it does as part of the standard library
21:20:49 <Cale> uman: It's especially useful, because all of the combining operations we defined take the result of the combined action to be the result of the last action in the chain
21:20:59 <divs> it supports pairs in the standard library, but not arbitrary sized tuples
21:21:02 <Cale> uman: So if you want to return something different, you use return.
21:21:08 <uman> divs: you can nest std::pair
21:21:18 <divs> well yea, but that's even more clunky than what boost does
21:21:23 <divs> boost has boost::tuple
21:21:24 <pikhq> uman: That is... Clunky.
21:21:27 <Cale> uman: But return doesn't give you the control effects that it has in C++ or many other imperative languages, it's otherwise a no-op.
21:21:41 <mike-burns> :t return
21:21:43 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:21:44 <pikhq> Not quite as clunky as saying "Screw it, I'll use templates as lambdas", but still.
21:21:46 <ivanm> divs: "boost-able"? :p
21:21:56 <Cale> So, for instance, (do foo; return 5; bar) is exactly the same thing as (do foo; bar)
21:22:18 <dancor> > return 4 >> return 5
21:22:20 <lambdabot>   No instance for (GHC.Show.Show (m t))
21:22:20 <lambdabot>    arising from a use of `M5487037827...
21:22:20 <divs> boost's main limitation is that you can only store a fixed number of items in it's tuple.  that and the code to implement them is insane, as is most C++ template code that's non-trivial.  with variadic templates you can implement a generic tuple class in a few lines
21:22:23 <dilinger> hm
21:22:24 <uman> Cale:
21:22:27 <uman> Cale: okay
21:22:27 <dancor> > (return 4 >> return 5) :: [Int]
21:22:29 <lambdabot>   [5]
21:22:51 <uman> Cale: what do you mean when you say it's an IO action?
21:22:52 <Cale> uman: as others seem to be rushing to point out, these operations >>, >>= and return are actually more general
21:23:06 <Cale> uman: like  getLine  or  putStrLn "hello"
21:23:21 <Cale> uman: One of these inert values which represents something that could be done.
21:23:25 <uman> I understand why those are IO actions... they print to standard output or read from standard input
21:23:27 <divs> i actually often wonder sometimes if C++ is more advanced than Haskell, as crazy as that sounds
21:23:46 <pikhq> > do x <- [1..5];y <- [5,6];x+y :: [Int]
21:23:48 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
21:23:48 <lambdabot>    arising from a use of `GHC...
21:23:49 <uman> "an IO action that does nothing" must be using a definition of "IO" that is not what I'm familiar with
21:23:55 <Cale> uman: right, so return produces a trivial IO action which doesn't actually do any I/O
21:24:03 <uman> Cale: so in what sense is it "an IO action"
21:24:07 <Cale> uman: But IO actions all have results
21:24:11 <pikhq> > do {x <- [1..5];y <- [5,6];x+y} :: [Int]
21:24:11 <Cale> and return v has the result v
21:24:13 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Int])
21:24:13 <lambdabot>    arising from the arithme...
21:24:14 <uman> okay.
21:24:18 <Cale> and that's its main purpose
21:24:53 <Cale> for example...
21:25:04 <uman> so just tack on ">> return foo" to a list of expressions
21:25:04 <Cale> Let's say you want to write an IO action called getTwoLines
21:25:09 <uman> and the whole group will have value "foo"
21:25:19 <Cale> which will read two lines of input from the user and return them as a pair
21:25:24 <Cale> yeah
21:25:28 <uman> okay
21:25:30 <Cale> If you write
21:25:35 <Cale> do getLine; getLine
21:25:48 <Cale> What happens is you read two lines, but the result is just the second line
21:25:53 <Cale> (the last action in the chain)
21:26:21 <Cale> So you need a way to stick another action in there which does nothing, but results in something different
21:26:22 <uman> is there any reason to write "do getLine; getLine" rather than "getLine >> getLine"?
21:26:26 <uman> they mean the same thing, right?
21:26:28 <Cale> no, not really
21:26:32 <Cale> they're the same
21:26:37 <Cale> But I'm about to edit that code :)
21:26:39 <uman> okay, just making sure I understood that bit properly
21:26:42 <uman> of course, go on
21:26:46 <Cale> do x <- getLine; y <- getLine; return (x,y)
21:26:53 <Cale> You could also write that as
21:27:01 <Cale> getLine >>= \x -> getLine >>= \y -> return (x,y)
21:27:13 <Cale> But, maybe that's more mind-bending to try to read :)
21:27:37 <pikhq> You could also write that as
21:27:55 <pikhq> getLine >>= \x -> getLine >>= return (x,) -- I think.
21:28:04 <Cale> hmm...
21:28:05 <pikhq> ... But that's even more mind-bending.
21:28:07 <Cale> no
21:28:14 <Cale> :t (x,)
21:28:16 <lambdabot> parse error on input `)'
21:28:17 <pikhq> Or I may be confused.
21:28:22 <mike-burns> :t (,)
21:28:24 <lambdabot> forall a b. a -> b -> (a, b)
21:28:27 <pikhq> Yes, confused.
21:28:34 <pikhq> mike-burns: Thus my confusion.
21:28:46 <pikhq> uman: I'm a bit new at this myself. ;)
21:28:47 <Cale> You can't write sections of (,)
21:28:51 <mike-burns> You also would have needed (.) .
21:28:58 <uman> so Haskell is so hard even the people in #haskell have trouble understanding it
21:29:04 <uman> sounds extra-fun to me :D
21:29:16 <pikhq> uman: I started learning it a couple weeks ago.
21:29:19 <Cale> uman: Well, it's not really that hard :)
21:29:22 <uman> ah, okay
21:29:29 <Cale> uman: But it is quite different.
21:29:47 <Cale> uman: So, you need to be prepared for things not to work the way you're used to.
21:29:59 <Cale> One common beginner mistake is to write something like:
21:30:03 <Cale> putStrLn getLine
21:30:10 <Cale> Can you imagine why this is wrong?
21:30:16 * pikhq snickers
21:30:19 <uman> don't tell me
21:30:23 <uman> let me think about it
21:31:43 <uman> because "getLine" is a function, and you want to pass the result of getLine to putStrLn, as opposed to the function itself
21:31:50 <uman> ?
21:31:55 <Cale> s/function/action/
21:31:56 <Cale> but yes
21:32:00 <uman> oh
21:32:03 <uman> okay
21:32:27 <mike-burns> :t getLine
21:32:28 <lambdabot> IO String
21:32:30 <mike-burns> :t putStrLn
21:32:32 <lambdabot> String -> IO ()
21:32:34 <Cale> You could make a function and pass getLine to it, and that function would be able to run getLine as many times as it wanted
21:32:52 <Cale> But it would really have to run it if it wanted a String
21:33:22 <uman> so I could write a function called "umanPutStrLn"
21:33:30 <uman> such that umanPutStrLn getLine
21:33:35 <uman> is equivalent to getLine >> putStrLn
21:33:40 <Cale> yeah
21:33:45 <Cale> >>=
21:33:53 <uman> right
21:34:18 <uman> what'd happen if you wrote getLine >> putStrLn?
21:34:26 <uman> fail to compile, because putStrLn expects to be passed a string?
21:34:32 <Cale> yeah
21:34:44 <uman> okay
21:35:04 <Cale> umanPutStrLn x = x >>= putStrLn
21:35:20 <Cale> is how you might define it
21:35:30 <uman> okay
21:36:08 <Cale> This might seem verbose in places compared to C, but it ends up being really convenient too
21:36:23 <Cale> Because it means that it's easy to define functions which act like control structures.
21:36:30 <uman> well that is much less verbose than doing the same thing in C
21:37:03 <Cale> I just mean, the necessity to run actions explicitly to get their results before applying functions
21:37:09 <uman> okay
21:37:30 <Cale> So, Haskell doesn't come with loops
21:37:40 <Cale> But there are things which serve as loops in the libraries
21:37:42 <uman> o.o that's a mind-warper!
21:38:02 <Cale> and if you don't like those, you can always write your own
21:38:06 <uman> what's the idiomatic thing to do in haskell instead of looping?
21:38:30 <Cale> Well, for I/O, there really are loops, I just mean, they're not built into the language.
21:38:37 <uman> mhm
21:38:44 <Cale> For pure code, we usually replace loops with lists
21:38:53 <uman> what do you mean by "pure code"
21:39:04 <Cale> I mean, non-I/O-performing code
21:39:09 <uman> okay
21:39:25 <Cale> and in fact, lists still form the backbone of many of our looping operations even for IO
21:39:43 <Cale> Let's start simpler though, and write a loop which just does something n times.
21:39:44 <uman> Code that is a beautiful functional masterpiece uncorrupted by the dirty outside world?
21:39:47 <uman> :P
21:39:50 <Cale> yeah
21:40:09 <Cale> In fact, you'll usually try to confine your IO actions to just doing real input and output
21:40:20 <uman> as opposed to what
21:40:25 <Cale> and express the main thing that your program is doing as a function from the input to the output
21:40:42 <Cale> Rather than trying to write everything with these IO operations
21:41:12 <uman> I imagine that loops are implemented using recursion somehow?
21:41:21 <uman> Since someone mentioned earlier that haskell is recursion-happy
21:41:34 <Cale> yeah
21:41:52 <uman> 20:54 < mmorrow_> if you try to program like you would in haskell in javascript though you end up reaching "maximum recursion depth" pretty fast though :(
21:42:03 <Cale> yeah
21:42:16 <Cale> Let's define a function  times :: Integer -> IO a -> IO ()
21:42:22 <Cale> Which takes an integer, and an action
21:42:22 <uman> what's "::"
21:42:29 <Cale> "has type"
21:42:51 <Cale> This is a rather funny Haskell tutorial, usually we don't start out teaching IO right off :)
21:43:30 <Cale> But that says that  times  is a function which takes an Integer, and an IO action (with any type a of result) and produces an IO action with an empty-tuple as its result
21:43:42 <Cale> and what it's going to do is just run the action that many times
21:43:48 <Cale> (discarding results)
21:44:03 <Cale> times 0 x = ...
21:44:24 <mike-burns> (I hope this IRC log gets turned into a tutorial with a witty name.)
21:44:24 <Cale> well, running the action 0 times isn't so hard, we just need to make sure to return () as the result
21:44:31 <Cale> times 0 x = return ()
21:44:42 <Cale> and that's a good base case
21:44:43 <coCocoa> uman: You'd be more familiar seeing it as "(IO ()) times( Integer x, (IO a) ioa)", or something like that. ;)
21:44:57 <uman> coCocoa: yeah
21:45:02 <Cale> times n x = x >> times (n-1) x
21:45:06 <uman> Cale: trying this out in ghci
21:45:12 <uman> times :: Integer -> IO a -> IO ()
21:45:15 <uman> <interactive>:1:0: Not in scope: `times'
21:45:24 <Cale> uman: ah, you'll need to put it into a file
21:45:32 <uman> why's that?
21:45:38 <Cale> ghci wants expressions
21:45:42 <Cale> and that's a declaration
21:45:58 <uman> okay
21:46:01 <Cale> You can think of ghci as a sort of testing environment
21:46:13 <Cale> and you'll usually define things inside a file
21:46:19 <uman> mhm
21:46:26 <coCocoa> mike-burns: You could do it, no one's stopping you. ;)
21:46:38 <dancor> is there a simple way to get haddock documentation with hscolour source links thru cabal?
21:46:46 <Cale> You can define small things at the ghci prompt by prefixing the declaration with "let", but it doesn't work for everything, and it requires that you squish the thing onto one line
21:46:46 <mike-burns> coCocoa: I was hoping someone else would ...
21:47:21 <coCocoa> mike-burns: Yeah, most folks "hope" that. I think it's the Laziness talking... ;p
21:47:26 <mike-burns> Ha.
21:48:03 <dancor> there's e.g. http://www.mail-archive.com/cabal-devel@haskell.org/msg00514.html but latest cabal has no --hscolour option in "runghc Setup.hs help haddock"
21:48:12 <ray> it's just that nobody's eager to do it
21:48:32 <Cale> uman: So does that definition of times roughly make sense?
21:48:41 <Cale> uman: the equations try to match in order
21:48:50 <mike-burns> There are a billion tutorials out there, and I'm not in a position to say that this one makes sense to a newb.
21:48:55 <Cale> uman: So if n = 0, then the first equation will match, rather than the second
21:49:17 <uman> mike-burns: it's making sense to me so far :)
21:49:25 <uman> Cale: yeah
21:49:57 <mike-burns> Okay so now I have to think of a name better than "Learn you a Haskell ..."
21:50:09 <Cale> uman: So, that's simple enough. What if we want the list of results of each iteration?
21:50:13 <ivanm> mike-burns: can't be hard...
21:50:16 <uman> so haskell must use some other way of passing arguments to functions
21:50:25 <uman> other than C, that is
21:50:26 <Cale> uman: hm?
21:50:27 <ivanm> let's start with s/you a//
21:50:28 <ivanm> ;-)
21:50:28 <uman> to avoid stack overflow
21:50:33 <Cale> uman: Well... yes
21:50:44 <Cale> uman: The evaluation model is about as different as it could be
21:50:58 <Cale> uman: The first strange thing is that it's outermost-first
21:51:00 <uman> I guess what asm GHC emits isn't really all that important for a rank beginner introduction
21:51:04 <Cale> So if you write f (g x)
21:51:08 <mike-burns> ivanm: I'm actually a big fan of the name LYAHFGG.
21:51:08 <uman> so feel free to only digress if you want to
21:51:30 <mike-burns> ivanm: So maybe someone other than me should think of a name.
21:51:39 <Cale> then in a traditional strict programming language, that will evaluate x, apply g to the result of that, then apply f to the result of that
21:51:45 <Cale> But in Haskell, it's backwards.
21:51:52 <Cale> f is first
21:52:01 <Cale> (g x) is substituted into the body of f
21:52:52 <uman> then x is substituted into the result of that?
21:52:56 <Cale> and actually, there's a little wibble there... if f's parameter occurs more than once in the body of f, then the results of evaluating it (if it's ever evaluated) are shared between the copies
21:53:28 <Cale> So, only if f actually needs the value of g x, that is, if something pattern matches on it, say, will g actually get to evaluate
21:53:36 <ray> ivanm: "Learn  Haskell"?
21:53:49 <ray> is it some subtle commentary on the layout rule?
21:54:09 <ivanm> ray: well, remove the extra space as well
21:54:11 <coCocoa> mike-burns: "Im in ur Haskell, lernin ur dudes" ;p
21:54:12 <uman> never thought I'd meet a sed language lawyer
21:54:12 <ivanm> you get the point...
21:54:22 <mike-burns> coCocoa: old meme
21:54:50 <coCocoa> mike-burns: ...and your point is? ;)
21:54:53 <ray> i still don't get it
21:54:58 <uman> mike-burns: "all your haskell are belong to Cale"
21:55:16 <mike-burns> uman: Old enough meme to be witty again.
21:55:19 <mike-burns> I like it.
21:56:09 <Cale> uman: I'll give my standard example...
21:56:17 <Cale> uman: Suppose we have a function  double x = x + x
21:56:25 <Cale> and we want to evaluate   double (double 5)
21:56:37 <Cale> in strict evaluation, this would go:
21:56:40 <Cale> double (double 5)
21:56:43 <Cale> -> double (5 + 5)
21:56:46 <Cale> -> double 10
21:56:49 <Cale> -> 10 + 10
21:56:51 <Cale> -> 20
21:57:07 <Cale> in plain outermost-first evaluation, it would go like:
21:57:10 <Cale> double (double 5)
21:57:18 <Cale> -> (double 5) + (double 5)
21:57:26 <Cale> -> (5 + 5) + (double 5)
21:57:31 <Cale> -> 10 + (double 5)
21:57:37 <Cale> -> 10 + (5 + 5)
21:57:39 <Cale> -> 10 + 10
21:57:41 <Cale> -> 20
21:57:46 <Cale> But this took more steps!
21:58:15 <Cale> Why? Because the parameter to double occured twice, so we copied the double 5, and evaluated it twice
21:58:23 <uman> ya it's O(6) instead of O(4) my friend
21:58:29 <Cale> haha
21:58:34 <mike-burns> Ha.
21:58:43 <Cale> Or just 6 steps instead of 4, yeah :)
21:58:53 <Cale> So lazy evaluation does something to prevent this
21:59:13 <Cale> If you'll permit me to use let ... in ... to denote this sharing that it does, it looks like:
21:59:16 <Cale> double (double 5)
21:59:23 <Cale> -> let x = double 5 in x + x
21:59:29 <Cale> -> let x = 5 + 5 in x + x
21:59:33 <Cale> -> let x = 10 in x + x
21:59:43 <Cale> -> 10 + 10
21:59:45 <Cale> -> 20
22:00:17 <Cale> and in fact, I could have left that second last step out, since in memory, it's kind of not really there
22:02:03 <blackh> Haskell sucks (the value out of the expression)
22:02:07 <lowlycoder> how do I convert an expression from type IO() to X() ?
22:02:22 <Cale> lowlycoder: Is X the monad from Xmonad?
22:02:26 <Cale> lowlycoder: you can use liftIO
22:02:31 <lowlycoder> Cale: yes
22:02:51 <Cale> Or... it might even have a shorthand for that called  to
22:02:52 <Cale> er
22:02:53 <Cale> io
22:02:55 <lowlycoder> Cale: that worked; thansk
22:03:32 <Cale> uman: follow that bit about evaluation?
22:03:49 <uman> Cale: I used my best guess on how to actually compile this... wanted to compile it to C to see what it'd output (apparently GHC has an option to compile to C)
22:03:54 <uman> My best guess was
22:04:02 <uman> double x = x + x
22:04:03 <uman> main = double (double 5)
22:04:10 <uman> but
22:04:11 <Cale> oh
22:04:16 <uman> that's not right
22:04:17 <Cale> main = print (double (double 5))
22:04:20 <uman> ah
22:04:28 <Cale> :t print
22:04:29 <lambdabot> forall a. (Show a) => a -> IO ()
22:04:45 <Cale> print will print anything for which there is a 'show' function which turns it into a String :)
22:04:53 <uman> okay
22:05:02 <Cale> > show 20
22:05:03 <lambdabot>   "20"
22:05:08 <Cale> > show [1,2,3]
22:05:09 <lambdabot>   "[1,2,3]"
22:05:10 <dmwit> Anybody have a library handy with an (permute :: [a] -> IO [a]) for one-off random permutations?
22:05:27 <uman> oh, fuck, I think I will submit the resulting .hc file to the ioccc
22:05:40 <ray> don't try to read .hc files
22:05:47 <uman> ray: yeah I realize that now :)
22:05:51 <mike-burns> They're optimized for gcc, not for you.
22:06:04 <ray> even if they weren't, reading the .hs would be better
22:06:32 <uman> ray: yes, but for what we were discussing it'd have been interesting to see that algorithm implemented in C
22:06:42 <Cale> uman: Oh you compiled via C and took the intermediate.
22:06:53 <Cale> uman: That code doesn't even work, iirc.
22:06:55 <ray> you mean the evaluation strategy? you wouldn't see that anyway
22:07:06 <uman> okay
22:07:08 <Cale> uman: GHC mangles the output of gcc into something that actually works.
22:07:12 <ray> there's some evaluation strategy library
22:07:24 <ray> i don't know if you'd see anything interesting there
22:07:27 <Cale> it's horrifying, but compiling via C isn't the default anymore
22:07:37 <Cale> (at least)
22:07:42 <uman> ray: well I can't make heads or tails of this code either way
22:07:56 <uman> ray: it includes some file called "Stg.h" and then the rest of the code is a bunch of macros
22:08:05 <uman> likely defined in stg.h
22:08:12 <ray> like cale said, it's manglesome
22:08:13 <uman> so, I will discard that strategy for understanding haskell :D
22:08:33 <ray> does ghc still have that perl mangler?
22:08:53 <Cale> ray: yes, but it's not used unless you -fvia-C which isn't the default
22:09:35 <uman> I wonder if the output of the first C++ compiler looked like this
22:09:41 <uman> its backend emitted C
22:09:47 <uman> this is offtopic though
22:10:16 <Cale> uman: A good place to start if you want to understand the real low-level details is the STG paper... http://citeseer.ist.psu.edu/peytonjones92implementing.html
22:10:37 <Cale> But for normal performance issues, you don't need that much
22:10:46 <uman> I'm betting it's written for an audience of people who already have a grasp of haskell
22:10:51 <uman> so I'll file it away and read it another time
22:10:52 <Cale> You can just think of the runtime as rewriting expression graphs.
22:11:10 <Chile> is there an elegant pure functional way to assign every node in a rooted tree a unique id? ordering doesn't matter. the id field is built into the structure, but I'm stuck in imperative land and want to use a counter reference.
22:11:16 <Cale> and so just doing the substitutions yourself by hand in text is a good approximation to get a feel for the performance of something
22:11:49 <uman> Cale: well this has been very informative. Thanks a ton, you're like the most helpful person I've met on IRC ever
22:11:55 <uman> I need to go to bed now though
22:12:03 <Cale> uman: see you around!
22:12:08 <uman> got to get up in the morning and make minimum wage debugging VB.NET :)
22:12:20 <Cale> Chile: What kind of tree? There's an easy trick if it's binary you might want to use :)
22:12:45 <Cale> Chile: But if you want to label them from 0 up to n-1, then using the State monad is probably a reasonable idea.
22:12:53 <coCocoa> Cale: Cribbing from Okasaki again? ;)
22:12:59 <Cale> Though you can do it my straightforward recursion
22:13:02 <Cale> by*
22:13:07 <Cale> coCocoa: uh, no
22:13:14 <Cale> coCocoa: Well, I don't know :)
22:13:20 <dancor> the answer to my earlier question is --hyperlink-source
22:13:24 <coCocoa> Cale: Oh, pity. I love that paper. :)
22:13:55 <uman> Cale: before I go, if you don't mind me asking, how long have you been using Haskell? And do you do it professionally or just as a hobby?
22:14:29 <Cale> uman: I have done it professionally, but right now it's just a hobby... I've been writing Haskell since around 2001-2002 or so.
22:14:43 <Chile> Cale: it's not binary at this point, unfortunately, but I wouldn't mind knowing the trick anyway. what's the general strategy for just recursion? I can't see doing it without passing around massively ugly tuples.
22:14:44 <uman> okay
22:14:48 <uman> just wondering
22:14:50 <uman> g'night all
22:15:01 <Chile> (and yeah, State monad is looking probable)
22:16:03 <coCocoa> Chile (and Cale): You may get some inspiration from the Okasaki paper I mentioned: http://citeseer.ist.psu.edu/356396.html
22:16:40 <Cale> Chile: Well, you can derive integer labels from the binary path to the tree nodes, more or less :)
22:17:33 <ray> you could do something similar for n-ary trees with a fixed n
22:18:08 <Chile> this is very frustratingly almost-binary, and in a later step it'll become binary, but unfortunately I need the IDs before then
22:18:37 <Cale> Chile: okay, let's use the State Integer monad
22:18:37 <Chile> coCocoa: will read, thanks.
22:19:06 <Chile> yeah, I'm fine doing that, I was just hoping there was some magic trick I didn't know :)
22:19:39 <Cale> Chile: What's the tree type?
22:20:14 <Cale> data Tree a = Node a [Tree a] ?
22:20:53 <Chile> it's a weighted tree, leaves are labeled with strings, internal nodes aren't labeled. I need to dump a table of (id, id, edgeweight) for an existing utility though.
22:22:06 <Chile> data Tree = Node Int Double [Tree] | Leaf Int Double String
22:22:23 <Chile> Int (will be) the ID, Double is weight to parent
22:23:28 <mmorrow_> Chile: do you want to number them wrt depth-first or breadth-first order?
22:23:53 <mmorrow_> (the latter being slightly less straight-forward)
22:24:04 <Chile> mmorrow_: absolutely doesn't matter, just needs to be unique (I'd also like them to be consecutive, though it doesn't actually matter)
22:24:15 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6780#a6780
22:24:24 <Cale> ah, I'll try it with your tree type
22:24:34 <Cale> You want to just forcibly replace the Int labels?
22:25:02 <coCocoa> Chile: Yeah, that paper is right up your alley, then - it's even a breadth-first numbering. :)
22:26:12 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6780#a6781
22:26:31 <mmorrow_> coCocoa: that might be overkill if all he wants to do is number them depth-first and move on though ;)
22:26:46 <Chile> still interesting though :)
22:26:53 <GenericUser5> Hello
22:26:56 <mmorrow_> yeah, that paper is great
22:27:01 <Cale> Chile: does the state monad code that I wrote make sense?
22:27:30 <GenericUser5> I've started picking up Haskell again for the first time in a while, and it occurred to me to ask where the syntax for <- in list comprehensions came from
22:27:31 <Cale> Chile: It's really just a wrapper around what you would accomplish by passing around pairs
22:27:36 <Chile> Cale: yeah, though it's about 10x elegant than I would have written :)
22:27:52 <Cale> GenericUser5: It's sort of mimicking the syntax of set comprehension expressions in mathematics
22:27:52 <mmorrow_> Chile: you might find the code to Data.Tree interesting too (in particular, the unfoldForest* functions, the BF ones taking ideas from that paper)
22:28:07 <GenericUser5> is <- supposed to be an arrow pointing left, or is it an approximation of the set membership symbol?
22:28:22 <mmorrow_> left-pointing arrow
22:28:24 <Chile> Cale: I'm fine with monads, but I still treat them like eggshells at times.
22:28:26 <Cale> GenericUser5: Well, it's really an arrow, but you can think of it as like set membership if you want :)
22:28:47 <Twey> It comes from do-syntax, where <- is an imitation of an assignment operator
22:28:52 <mmorrow_> GenericUser5: (for list comprehensions, that viewpoint makes sense though (set membership))
22:29:06 <Cale> Er, but comprehensions were around well before do-syntax
22:29:15 <inimino> it can be read as 'taken from'
22:29:16 <Chile> mmorrow_: will take a look, thanks. I keep forgetting that haskell has plenty of nice libraries.
22:29:20 <Cale> You could also claim that do-syntax stole <- from comprehensions :)
22:29:50 <GenericUser5> Ok, thanks.
22:30:16 * coCocoa contemplates a "Haskell stole my bike" blog post...
22:30:22 <Cale> GenericUser5: It's worth noting that <- is a little different from set membership, since it counts the occurrences of an element too
22:30:27 <Cale> (and their order)
22:30:43 <copumpkin> :o
22:30:43 <Cale> > [(x,y) | x <- [1,1,2,2,3,3], y <- [4,5]]
22:30:44 <lambdabot>   [(1,4),(1,5),(1,4),(1,5),(2,4),(2,5),(2,4),(2,5),(3,4),(3,5),(3,4),(3,5)]
22:31:10 <Cale> coCocoa: Haskell Breaks Guitars?
22:31:59 <coCocoa> Cale: I don't know; I don't want to disappoint the footy fanboys... ;p
22:32:36 <Cale> (I am making a reference to http://www.youtube.com/watch?v=5YGc4zOqozo in case people haven't seen that yet ;)
22:33:07 <Twey> Cale: Did they use <-?
22:33:24 <Cale> Twey: yeah, I'm pretty sure, I can check :)
22:33:35 * coCocoa imagines legions of frustrated UK soccer fans getting annoyed at all of the "Haskell" blogs that talk about this oddball computer language... :)
22:33:35 <Twey> Oh, okay then :)
22:33:57 <Twey> coCocoa: There are no UK soccer fans :)
22:34:14 <Cale> coCocoa: start writing articles about using Haskell to analyse football games
22:34:20 <coCocoa> Twey: What, rugby? ;p
22:34:49 <Twey> Cale: Oh, that'll really confuse 'em :-D
22:36:48 <Cale> yeah, Haskell 1.0 had list comprehensions with the current syntax, but no do-notation yet.
22:36:55 <Cale> (It didn't even have the IO monad)
22:37:19 <copumpkin> :o
22:37:31 <Twey> Oho.
22:37:35 <copumpkin> how were side effects kept in control?
22:37:40 <coCocoa> Cale: Hmm, maybe "Haskell Fixes Guitars"? ;) ("Haskell MFixes Guitars" for the inevitable monadic version... ;p
22:37:45 <Cale> Continuations
22:37:49 <copumpkin> oh
22:37:50 <mmorrow_> copumpkin: with cps
22:37:51 <copumpkin> neat
22:37:52 <Twey> Could be from set membership, then, no?
22:38:07 <Twey> Oh, you said that.
22:38:10 <Cale> yeah, it's supposed to sort of resemble that, but not too closely :)
22:38:24 <solrize> Haskell FixesM_ Guitars
22:38:25 <Twey> *nod*
22:39:50 <Cale> writeBinFile :: Name -> Bin -> FailCont -> SuccCont -> Dialogue
22:40:07 <Cale> readFile :: Name -> FailCont -> StrCont -> Dialogue
22:40:40 <Twey> Wacky
22:40:45 <Twey> We abandoned this why?
22:40:52 <Cale> print :: (Text a) => a -> Dialogue
22:41:03 <Cale> print x = appendChan stdout (show x) abort done
22:41:16 * Twey gives a cheer for Text a => a
22:41:35 <Cale> It's not very easily extended as it explicitly represents the various possible input and output effects with an ADT.
22:41:39 <dmwit> Twey: But that's just like what we have now, really.
22:41:41 <dmwit> :t print
22:41:43 <lambdabot> forall a. (Show a) => a -> IO ()
22:41:47 <dmwit> Show a => a
22:41:57 <Twey> Oh, yeah.  Text = Show
22:42:01 <Cale> data Request = ReadFile Name | WriteFile Name String | ...
22:42:23 <Cale> data Response = Success | Str String | Bn Bin | Failure IOError
22:42:26 <GenericUser5> what is => in your discussion?
22:42:47 <Twey> Class membership
22:43:46 <Cale> GenericUser5: => is what we use to say that certain type variables in the type to the right must belong to certain classes as described by the part to the left of it
22:43:59 <Cale> :t sort
22:44:00 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:44:13 <Cale> This says that sort will take a list of values of any ordered type
22:44:18 <Cale> and produce a list of the same type
22:44:37 <GenericUser5> Ok.
22:44:50 <Cale> sort can't be just plain [a] -> [a], because in general, < doesn't work for every type
22:45:07 <Cale> (in particular, what should it do for functions?)
22:45:10 <mmorrow_> haha, hpaste2 has a highlighting option for brainfuck
22:45:45 <Twey> Haha
22:45:53 <Twey> âInstructions this colour, everything else that colourâ?
22:45:59 <Cale> Typeclasses are how we say, "well, I don't mean just *any* type, but anything having such and such operations available"
22:47:03 <pikhq> Twey: Perhaps shift the color of instructions when entering an exiting loops.
22:47:06 <pikhq> s/an/and/
22:47:45 <Twey> 's a thought
22:48:33 <mmorrow_> aww, it's pretty boring (and ugly)
22:48:34 <mmorrow_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2961
22:48:40 * SubStack seems to need something like mapAccumL with a predicate inside to stop accumulating
22:48:43 <mmorrow_> all instrs green, everything else grey
22:48:57 <pikhq> That's pretty lame.
22:48:57 <Cale> < and > aren't
22:48:58 <Twey> Yep :-P
22:49:05 <Twey> Oh yes
22:49:06 <SubStack> restructuring code to be comprehensible enough to debug is hard work
22:49:07 <Twey> They're brown
22:49:07 <mmorrow_> oh no, "><" are brownish or something
22:49:09 <Twey> ... for some reason
22:49:42 <mmorrow_> someone needs to make that not sucky
22:50:06 <Cale> Someone needs to write a syntax highlighter for dc
22:51:06 <Cale> dc is probably the most widely distributed esoteric programming language
22:51:33 <pikhq> And a lot of people don't even realise it's programmable.
22:51:38 <Chile> people use dc?
22:51:45 <pikhq> I do.
22:51:48 <Chile> dc is what I swear at when I mistype things
22:51:51 <pikhq> It's a decent calculator.
22:51:52 * coCocoa has never heard of dc, and goes to Goggle it...
22:52:08 <Chile> (specifically when I mistype cd)
22:52:11 <Cale> coCocoa: It's probably installed on your machine if you're on anything unix-like
22:52:16 * pikhq likes RPN for write-only computation.
22:53:48 <pikhq> Ah, Turing-complete calculators.
22:54:11 <Cale> with IO primitives!
22:54:13 <mmorrow_> coCocoa: bc
22:55:08 <GenericUser5> What do the precedence levels of fixity declarations mean? I mean, clearly a 9 is stronger than a 5, but is there some guide as to why an operator should be at a certain level of precedence?
22:55:17 <mmorrow_> hmm, i've got both dc and bc
22:55:22 <Cale> bc actually aims at being reasonably usable though
22:55:36 <Cale> dc is fun because it's line-noise
22:55:43 <Axman6> GenericUser5: well the mathematical operators have different binding strengths in maths for example
22:55:48 <Axman6> BODMAS etc
22:56:00 <pikhq> GenericUser5: "Why"? It's a definition. The only reason is aesthetics.
22:56:09 <Cale> dc is one of the only languages I know which will let you name something newline
22:57:04 <pikhq> 2 + 2 * 5 = (2 + (2*5)) is much nicer than 2 + 2 * 5 = ((2 + 2) * 5) for people who are used to common arithmetic.
22:57:22 <Cale> "Dc provides at least 256 memory registers, each named by a single character.   You can store a number or a string in a register and retrieve it later."
22:57:26 <pikhq> That's the rhyme and reason for operator precedence. ;)
22:57:33 <GenericUser5> I guess what I'm getting at is, how did whoever defined these operators figure out that ++ should be a 5 instead of say, a 6? {At least as I see it here}
22:57:36 <pikhq> Cale: Each register is a stack.
22:57:42 <Cale> pikhq: right
22:57:43 <ray> cale: what does it use above 127?
22:58:07 <Cale> ray: It doesn't care about what encoding you use, as long as it fits in a byte
22:58:21 <Cale> It should really say "each named by a single byte"
22:58:28 <ray> yeah, it should
22:58:32 <ray> i'm interested now
22:58:37 * coCocoa programmed in FORTH for one of his first jobs, so would probably enjoy dc.
22:58:44 <pikhq> There is nothing saying that it needs to be printable.
22:58:50 <Cale> right
22:58:59 <mmorrow_> co
22:58:59 <pikhq> coCocoa: You'll find dc limited.
22:59:02 <ray> "unprintable character" is a world away from "byte"
22:59:03 <Cale> you can use \0 or \n or a space for names
22:59:03 <coCocoa> I know bc, but I never heard of dc. Interesting... :)
22:59:08 <pikhq> FORTH is like the Lisp of concatenative languages. :P
22:59:09 <ray> you still need an encoding
22:59:13 <mmorrow_> coCocoa: haha, doing what?
22:59:38 <mmorrow_> (in forth)
23:00:05 <Twey> Forth is cool \o/
23:00:30 <Cale> The annoying thing in dc is accomplishing things while leaving all the stacks you used unaffected at the end.
23:00:44 <Cale> Keeping things clean takes discipline.
23:01:23 <coCocoa> mmorrow_: It was almost thirty years ago, so the details are fuzzy.
23:01:35 <ray> that's a self-imposed challenge
23:01:57 <ray> you should try pacifist runs of shooting games sometime
23:02:03 <Cale> haha, I just noticed that the code they give as equivalent to P actually uses P
23:02:04 <coCocoa> variables as stacks...sounds almost dataflow-esque, and definitely FORTH-like.
23:02:13 <GenericUser5> ray: Like Iji? :)
23:02:36 <Cale> (in the dc manpage)
23:02:42 <ray> iji is a run and gun
23:02:43 <ivanm> gah, the graphviz documentation is useless in terms of trying to work out if attributes are case-insensitive or not :@
23:03:01 <Cale> KSK0k1/_1Ss [ls*]Sxd0>x [256~Ssd0<x]dsxxsx[q]Sq[Lsd0>qaPlxx] dsxxsx0sqLqsxLxLK+k
23:03:19 <coCocoa> pikhq: I like to think of FORTH as Lisp with just the macros. ;)
23:03:31 <mmorrow_> Cale: did you say that dc /can/ do IO? (because if not, that would be a nice lunabot QQ)
23:03:33 <pikhq> coCocoa: Heheheh.
23:03:38 <Twey> mmorrow_: Yeah, it can
23:03:45 <Twey> Also command execution
23:03:45 <Cale> mmorrow_: It can do user input and output
23:03:48 <mmorrow_> hmm
23:03:53 <Twey> (with !)
23:04:04 <Twey> You could just strip out the IO characters, though
23:04:09 <Cale> ah, right
23:04:13 <GenericUser5> I have to go, thanks for the info. :)
23:04:15 <GenericUser5> bye bye.
23:04:17 <Twey> o/
23:04:34 * coCocoa imagines Moore in a McCarthy class, saying "Lisp - looks interesting, but what if you got rid of those parens..." ;)
23:04:39 <mmorrow_> so a simple grep filter in front of | dc would be safe?
23:04:41 <Cale> er, wait, would that work?
23:05:07 <mmorrow_> (this is probably a one-way ticket to getting lunabot rooted..)
23:05:11 <Cale> You can turn numbers into strings and then execute those strings
23:05:40 <mmorrow_> someone should implem a dc interp in haskell :)
23:05:44 <Cale> So just because a dc script doesn't contain ! doesn't mean that it doesn't at some point use !
23:05:45 <ray> just make a modified copy of dc
23:05:46 <Twey> coCocoa: Hehe
23:05:49 <ray> or what mmorrow_ said
23:06:06 <Twey> mmorrow_: I think so, yes, so long as you don't miss anything
23:06:16 <Twey> Cale: Yes, but you could strip out the string-execution character too
23:06:35 <ray> that would suck
23:06:38 <mmorrow_> Twey: can you think of such a grep -E regex?
23:06:39 <Cale> uh, without x you can't run quotes and it's not Turing complete
23:06:44 <mmorrow_> aww
23:06:45 <Twey> True
23:07:05 <lowlycoder> I have a named Data type; how do I tell it to take the existing one and replace just one elemnt of it?
23:07:17 <Twey> Shame :)
23:07:28 <Cale> lowlycoder: hmm... pattern match?
23:07:29 <mmorrow_> lowlycoder: pattern match
23:07:40 <lowlycoder> Data MyState = { monitorState :: Bool , genesisState :: Bool } ... there is some function that takes a MyState, then replaces just one of them right? the syntax is something involving a #
23:07:42 <Twey> lowlycoder: By ânamed Data typeâ, do you mean a record?
23:07:58 <Twey> someValue { monitorState = true }
23:08:02 <Cale> myStateValue { monitorState = True }
23:08:02 <Twey> Er, True
23:08:06 <mmorrow_> , (\(Just a, x) -> (Just (a*2), x)) (Just 99, [0..])
23:08:08 <lunabot>  (Just 198,[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,...
23:08:18 <Twey> Returns a copy of someValue but with monitorState set to True
23:10:42 <ivanm> is there a way of having functions based solely on which constructor was used without having to always have underscores, e.g.: foo (Foo _) = True; foo (Bar _) = False ?
23:12:57 <Berengal> Foo{}
23:13:09 <mmorrow_> here's the bc source if anyone want to browse (sends .c/.h as text/plain) http://moonpatio.com/repos/MISC/bc-1.06/
23:14:35 <ivanm> Berengal: hmmm.... it's a bit nicer/shorter...
23:14:55 <mmorrow_> heh, so i guess the is the mathlib implem in bc http://moonpatio.com/repos/MISC/bc-1.06/bc/libmath.b
23:15:14 <mmorrow_> and this is the "compiled" form?? http://moonpatio.com/repos/MISC/bc-1.06/bc/libmath.h
23:15:42 <ivanm> gah, now it's complaining about overlapping matches because of the "foo _" case I have at the end :s
23:17:19 <ivanm> oh, wait, that's because so far I have only 3 constructors and for that function they all have a pattern match :s
23:17:45 <mmorrow_> ah, looks like dc is included in bc.. no wonder i couldn't find the code
23:17:47 <mmorrow_> http://moonpatio.com/repos/MISC/bc-1.06/dc/
23:18:58 <roconnor> hmm, I should make my RGB triples an applicative functor.
23:19:17 <mmorrow_> this is of reasonable length given that it's a gnu project (i.e. it's not 30,000 lines) http://moonpatio.com/repos/MISC/bc-1.06/dc/eval.c
23:20:22 <copumpkin> whoa, a c style I can actually agree with
23:20:27 <copumpkin> surely that can't be GNU
23:20:37 <mmorrow_> hmm, so it looks like modifying it to not be able to run system commands woul dbe pretty easy (as per ray's suggestion)
23:21:04 <mmorrow_> just comment out "case DC_SYSTEM:" i guess
23:21:15 <pikhq> copumpkin: It's GNU software, but it's not the GNU coding style.
23:21:26 <ray> :D
23:21:31 <mmorrow_> pikhq: haha, yeah i noticed the highly illegal formatting
23:21:44 <ray> not even gnu stuff uses gnu style these days
23:21:47 <pikhq> Looks most like good K&R C.
23:21:57 <copumpkin> :)
23:22:50 * ivanm wonders if quickly learning TH or some other pre-processor would be worth it as opposed to slavishly writing out all of these graphviz attributes line by line as well as the various Show, etc. instances for them :s
23:23:06 <pikhq> Somewhat surprised it doesn't even do GNU's i18n stuff, though.
23:23:24 <mmorrow_> ivanm: you mean using Show to prettyprint them?
23:23:24 <ray> mmorrow_: or maybe replace dc_system() with a placeholder
23:23:29 <copumpkin> ivanm: oooh, you updating the graphviz package, or making a new one?
23:23:37 <mmorrow_> ray: yeah, that seems like the thing to do
23:23:42 <ivanm> mmorrow_: I am atm (because it already does), but I'll probably switch it to a prettyprinter later on
23:23:43 <copumpkin> oh wait, was there already one out there?
23:23:51 <ivanm> copumpkin: updating (as in re-writing :p )
23:23:56 <copumpkin> ah cool :)
23:24:01 <roconnor> I could make RGB triples a Monad, but I'm hesitant.
23:24:13 * mmorrow_ throws a lightning bolt and a cheezeburger at ivanm
23:24:24 <ivanm> mmorrow_: hmmm?
23:24:39 <ivanm> mmorrow_: matthew-_ wrote it using Show
23:24:41 <copumpkin> lol
23:24:44 <mmorrow_> ivanm: :)
23:24:55 <ivanm> so for now I'm going to leave it as that, and then replace Show with a Print class or something
23:25:03 <copumpkin> ivanm: I think it's his reaction to blasphemy
23:25:11 <ivanm> (haven't thought which one or how yet, but I know it's bad)
23:25:14 <copumpkin> ivanm: after all, http://twitter.com/mmorrow
23:25:20 <mmorrow_> copumpkin: haha
23:25:20 <ivanm> copumpkin: it was the cheezeburger that threw me
23:25:24 <kulakowski> roconnor: i double take when you said that, thinking you meant 'triple' as in monad
23:25:30 <ivanm> especially since it's spelt "cheese", not "cheeze" :p
23:25:39 <copumpkin> ivanm: I can haz cheezburger?
23:25:50 <ray> copumpkin: http://twitter.com/ray :( :( :(
23:25:57 <ivanm> see, that's a different spelling altogether
23:26:02 <Pseudonym> copumpkin: Apparently, meme cat is dead.
23:26:09 * ivanm doesn't have a twitter account and is proud of it
23:26:12 <mmorrow_> <copumpkin> why the cheeseburger?
23:26:12 <mmorrow_> <mmorrow_> copumpkin: i thought you might be hungry after you were smote
23:26:13 <ray> there are no twitter names for me
23:26:27 <copumpkin> Pseudonym: ceiling cat is watching you diss meme cat
23:26:42 <ray> ray is taken, juped is taken, nothorns is taken (!), carefreedrunkard is one character too long
23:26:43 <roconnor> kulakowski: heh
23:26:51 <copumpkin> ivanm: http://twitter.com/ivanm
23:26:55 <ivanm> mmorrow_: ahhh.... when was that?
23:27:02 <jeffwheeler> Twitter?!
23:27:07 <ivanm> copumpkin: not me
23:27:16 <copumpkin> ivanm: prove it!
23:27:18 <mmorrow_> ivanm: a few minutes ago
23:27:20 <copumpkin> same name!
23:27:26 <ivanm> mmorrow_: must of missed it...
23:27:31 <ivanm> copumpkin: I'm also not ivanm on last.fm
23:27:38 <copumpkin> ivanm: proof!
23:27:43 * copumpkin wants 80 proof at least
23:27:46 <ivanm> tbh, the only reason that I'm "ivanm" here is because "ilm" was already taken
23:27:48 <jeffwheeler> I wish I could change my name on flickr and last.fm
23:27:54 <ivanm> copumpkin: how do you prove a non-existent thing?
23:28:02 <copumpkin> I like that twitter allows us to change username
23:28:06 <ivanm> I also couldn't get ivanm on skype
23:28:10 <copumpkin> even though it can be confusing for people using a URL to visit
23:28:23 <jeffwheeler> copumpkin: yeah, I used to be nokrev
23:28:27 <ivanm> copumpkin: did you see the one about the guy taking the spanish name that he apparently used when dancing? :s
23:28:28 <jeffwheeler> a really old handle I used to use
23:28:34 <copumpkin> ivanm: ?
23:28:43 <Pseudonym> Nietsche Cat sez Ceiling Cat is dead
23:28:58 <copumpkin> Pseudonym: await lightning and cheezeburger from mmorrow kthx
23:29:07 <ivanm> copumpkin: right when that first came out, someone took someone else's name as their twitter name, and said it was because that was the name they used when they did spanish dancing :s
23:29:14 <copumpkin> oh yeah
23:29:20 <copumpkin> I vaguely remember something like that
23:29:54 <ray> i wonder if i can register a 16 character twitter name by just submitting a 16 character name to their form manually
23:30:03 <ivanm> _anyway_... manually adding a constructor, then instances/pattern-matches for it is a right royal PITA
23:30:08 <ray> twitter's buggy enough
23:30:12 <ivanm> and I'm only five attributes in :s
23:30:45 <mmorrow_> ivanm: depending on how well you know TH already, it could save time or it could just take longer
23:30:57 <ivanm> I don't know TH at all ;-)
23:31:04 <mmorrow_> ivanm: you could always just use Text.PrettyPrint then to generate the code
23:31:07 <mmorrow_> (or String)
23:31:12 <ivanm> :o
23:31:16 <ivanm> write code to generate code?
23:31:19 <mmorrow_> ivanm: that would probably save some time
23:31:20 <ivanm> ...intriguing...
23:31:26 <jeffwheeler> ray: that's how you submit messages >140 chars :)
23:31:31 <ivanm> mmorrow_: except I'll probably waste more time getting the code generator right ;-)
23:31:32 <mmorrow_> ivanm: it's the new black!
23:31:48 <mmorrow_> ivanm: nah, i think it'll work out
23:31:50 <copumpkin> jeffwheeler: only above 140 utf-16 chars :P
23:31:59 <copumpkin> still only 140 unicode code points
23:31:59 <mmorrow_> ivanm: (and you can always re-use it too..)
23:32:07 <Saizan> oh, i'm still opped
23:32:15 * copumpkin op-begs Saizan
23:32:21 --- mode: Saizan set -o Saizan
23:32:28 <copumpkin> damn
23:32:30 <jeffwheeler> copumpkin: are you sure? I think I know of some messages that were just copied/pasted into the field and submit, because the counter never refreshes if you don't type anything.
23:32:38 <ivanm> mmorrow_: true
23:33:01 <ray> crap, didn't work
23:33:06 <ivanm> and it would probably be easier to re-write the code generator if I change something than doing it by hand
23:33:10 <copumpkin> jeffwheeler: it's enforced on the server side, but the client-side counter is wrong and only counts utf-16 units, so if you leave the BMP you get penalized
23:33:43 <mmorrow_> ivanm: this uses Text.PrettyPrint to generate the .c code http://moonpatio.com/repos/PrintfGen.hs
23:33:47 <ray> looks like i can't use twitter
23:33:53 <mmorrow_> (TH for the .hs though)
23:34:24 <mmorrow_> ivanm: ghc uses this one file that uses String to generate the gobs of .cmm it takes to implement eval/apply for ghc
23:34:28 * jeffwheeler looks for the extended messages I swore I used to see
23:34:36 <jeffwheeler> I remember I asked somebody how they did it
23:34:45 <jeffwheeler> and they responded with that copy/paste trick
23:34:47 <copumpkin> maybe it used to work
23:34:50 <jeffwheeler> it would automatically put in an "..."
23:34:54 <copumpkin> I'm relatively new to twitter :)
23:35:26 <ivanm> mmorrow_: *shudder*
23:35:42 <ivanm> mmorrow_: anyway, thanks, I'll have a look at that later on
23:35:51 <ray> oh wait, haskell-related twitter names
23:36:11 <mmorrow_> ivanm: ooh, here's a better example: this uses Doc to generate C for a massive switch-trie http://moonpatio.com/repos/switchtrie/switchtrie.hs
23:36:16 <copumpkin> http://twitter.com/comonad
23:36:19 * ray grabs comonad
23:36:34 <copumpkin> zygohistomorphic seems free too
23:36:49 * jeffwheeler gives up; you win, copumpkin :)
23:36:54 <copumpkin> aw
23:36:57 <ray> i was actually in the process of grabbing comonad before you pasted that
23:36:58 <copumpkin> maybe it's just a recent thing
23:37:00 <ray> and, 15 character limit
23:37:05 <copumpkin> ray: edwardk won't be happy
23:37:06 <ray> (comonad is also my livejournal name)
23:37:11 <copumpkin> zomg!
23:37:17 <jeffwheeler> The person I know recreated their account because they didn't know how to make it not private . . . and they took their tweets with them :P
23:37:24 <ray> edwardk has a lot of weird names to choose from
23:37:43 <copumpkin> twitter.com/cofreecomonad
23:37:52 <jeffwheeler> I always use the same boring name http://twitter.com/jeffwheeler
23:38:19 <ray> http://twitter.com/yonedalemma
23:38:25 <copumpkin> lol
23:38:32 * mmorrow_ read that as "yoneda dilemma"
23:38:50 * jeffwheeler doesn't get it
23:39:06 <mmorrow_> neither did i
23:39:26 <copumpkin> http://en.wikipedia.org/wiki/Yoneda_lemma
23:39:38 <copumpkin> http://en.wikipedia.org/wiki/Yoneda_dilemma
23:39:58 <mmorrow_> someone needs to fill in Yoneda_dilemma
23:39:59 <jeffwheeler> Oh, I thought it was yone dilemma
23:40:03 <ray> yoneda trilemma
23:40:09 <mmorrow_> oh snaps
23:40:22 <ray> tetralemma
23:41:07 <jeffwheeler> this is one of those articles where I get totally lost after the first sentence
23:41:30 <mmorrow_> @quote shopping
23:41:31 <copumpkin> you can find it in code in category-extras :P
23:41:31 <lambdabot> samc says: monads are hard. let's go shopping!
23:41:34 <jeffwheeler> maybe it's that my highest level of math was high-school calculus
23:41:55 <ray> better than getting lost after the title being restated in bold
23:42:13 <ray> actually, that article's not bad
23:42:45 <jeffwheeler> Oh, Wikimedia Board elections
23:42:50 <jeffwheeler> that guy spelled Daedalus oddly
23:46:32 <aaafff1> I have a AST tree i'm trying to work with, and I defined a class with default handlers that basically pass down to the base nodes and then return an empty list. This way, I define an instance and overrided some key functions and I can reuse the traversal code and handle whatev pattern I need. But since my return type is the only needed generic on all of these functions, I have to do hacky stuff to get it to work. Is there a better way t
23:46:42 <copumpkin> ooh RAS syndrome
23:46:45 <aaafff1> Sorry for the wall of text, btw
23:47:08 <J11> http://en.wikipedia.org/wiki/Yoneda_dilemma
23:47:43 * copumpkin loves them liquid crystal display displays, the personal identification number numbers, the abstract syntax tree trees
23:47:44 <Cale> J11: Is that a real page? Haha
23:48:01 <Cale> aaafff1: I'm not sure that I understand. What's the type of the function which you're writing? What hacky stuff?
23:48:55 <Cale> J11: ah, it's not, too bad
23:49:10 <ray> pity
23:49:43 <aaafff1> Cale: there are 8 functions corresponding to 8 datatypes that make up the AST; all pretty much "parseX :: X -> a"
23:49:49 <Adamant> copumpkin: and you can take that to the automatic teller machine machine
23:50:26 <J11> woops
23:50:45 <Cale> aaafff1: What is the result type polymorphism for? Surely that's not an unconstrained 'a'
23:51:34 <aaafff1> the instance has a as Vars [String]; but since all these functions end in a the variable type, I have to start it off with a silly "fakeParse -> a -> Module -> a" (Module being the root datatype)
23:52:28 <Cale> You could also just add a type signature somewhere to ensure that the right type is selected, no?
23:52:46 <Cale> Or is it because they're called recursively?
23:52:52 <Cale> How many instances do you have?
23:53:06 <J11> I was reading up and trying to copying that link, while in putty right-click pastes it here
23:53:11 <aaafff1> right now just 1, i'll have 4-5 when alls said and done
23:54:07 <aaafff1> the type signature thing didn't work immediatly, but might still be an option. It still feels like a hack though, I just wanted to make sure there wasn't some super elegant solution that I was missing
23:54:50 <Cale> Usually if there are just enough type signatures in your program to disambiguate, it will work out which one you want.
23:55:29 <Cale> Where are you having problems about ambiguity?
23:58:16 <aaafff1> i could be doing something stupid here too: I have "data Vars = SetVars [String]  deriving (Show)" and "instance PyXFormer (Vars [String]) where..."
23:59:03 <aaafff1> er
23:59:23 <aaafff1> i had the type definition wrong... you guys are right
