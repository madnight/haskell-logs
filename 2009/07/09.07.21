00:05:13 <horms> :t signum
00:05:16 <lambdabot> forall a. (Num a) => a -> a
00:07:21 <ray> > map (signum $) [-4444,0,4444]
00:07:24 <lambdabot>   [-1,0,1]
00:07:52 <copumpkin> why (signum $) o.O
00:07:59 <ray> i think it looks cool
00:08:05 <copumpkin> got money on your mind
00:08:09 <ray> who says $ is about removing parens
00:08:35 <ray> extra $ = bling
00:10:05 <copumpkin> lol
00:10:14 <copumpkin> ray: so what/who is drong and why is he not a cat?
00:11:16 <ray> he's this guy i met on the internet who's like a rebellious teenage son to me
00:11:34 <copumpkin> lol
00:11:35 <ray> he likes to claim to be a cat, so i want to get the message out to the whole internet before he meets anyone else
00:12:12 <copumpkin> I see..
00:12:14 <Gracenotes> id signum = .. hm... >_<
00:12:45 <ray> > map (id (signum $)) [-2..2]
00:12:47 <lambdabot>   [-1,-1,0,1,1]
00:12:49 <copumpkin> id should be a right identity too! :P
00:13:06 <copumpkin> let's rearrange the language so it is
00:13:28 <ray> goodbye haskell type system as we know it
00:13:47 <Gracenotes> let's make (:) left-associative!
00:13:54 <copumpkin> lol
00:13:58 <ray> it's easy if you want it to be just a right identity, you just look through a mirror
00:13:59 <copumpkin> we're full of good ideas tonight
00:14:02 <ray> it's harder if you want it to be both
00:14:11 <copumpkin> must go to sleep before moar awesomeness is created
00:14:12 <copumpkin> !
00:14:25 <ray> of course through a mirror it's bi not id
00:14:48 * Gracenotes watches Higurashi No Naku Koro Ni Kai
00:15:11 * copumpkin watches yaoi
00:15:19 <Gracenotes> wtfhax
00:15:49 <ray> that reminds me, DRONGさんは猫でありません
00:15:59 <copumpkin> yamete, oshiri ga itai
00:16:39 <Gracenotes> ray: bad kitty!
00:16:56 <ray> i'm not a cat either
00:17:08 <horms> :t fromInteger
00:17:11 <lambdabot> forall a. (Num a) => Integer -> a
00:17:24 <horms> :t toInteger
00:17:26 <lambdabot> forall a. (Integral a) => a -> Integer
00:17:44 <ray> :t (fromEnum,toEnum)
00:17:46 <lambdabot> forall a a1. (Enum a, Enum a1) => (a -> Int, Int -> a1)
00:17:51 <copumpkin> DRONGさんは魚であるよ
00:18:05 <copumpkin> de are = ftw
00:18:07 <copumpkin> de aru
00:18:15 <jeffwheeler> wtf?
00:18:41 <ray> i am pretty sure he is a human
00:19:10 <copumpkin> oh ok
00:19:11 <jeffwheeler> Based on past interactions, I would have expected so.
00:19:25 <copumpkin> oh you know drong too?
00:19:46 <ray> hmm
00:20:18 <jeffwheeler> It's obviously past copumpkin's bedtime.
00:20:28 <copumpkin> :(
00:21:00 <ray> > fromEnum 2.2 :: Double
00:21:02 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
00:21:29 <ray> > fromEnum (2.2 :: Double)
00:21:31 <lambdabot>   2
00:22:30 <ray> > let hax = (toEnum . fromEnum) :: Double -> Double in hax 2.71828
00:22:32 <lambdabot>   2.0
00:23:24 <Gracenotes> pi is 3
00:23:39 <jeffwheeler> @type floor
00:23:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:23:41 <ray> why did they even make floats instances of Enum :(
00:24:06 <ivanm> ray: so you can do this?
00:24:08 <jeffwheeler> > let hax = floor :: Double -> Double in hax 2.7
00:24:08 <ivanm> > [1.0, 1.1 .. 2.0]
00:24:11 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
00:24:12 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
00:24:12 <lambdabot>    arising from a use ...
00:24:48 <ray> ah yes, so you can do that
00:25:01 <ray> like i said, why
00:25:04 <ray> ;)
00:25:21 <ivanm> heh
00:25:30 <jeffwheeler> > map (/10.0) [10..20]
00:25:32 <lambdabot>   [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0]
00:25:38 <ivanm> ray: because someone thought it made sense? :p
00:25:43 <ivanm> jeffwheeler: heh
00:25:44 <ray> a type error would probably be better for that
00:25:54 <ray> jeffwheeler: that's just Enum Integer!
00:26:13 <jeffwheeler> ray: I know, and that's all that should exist; I agree with y'all
00:27:11 <ivanm> jeffwheeler: no, we shouldn't just have Enum Int ... otherwise what would be the point of having an Enum class? :p
00:27:39 <jeffwheeler> ivanm: err, well, only integral numeric types should have Enum instances ;)
00:27:40 <ray> i should write a blog post or something about how floats are insane
00:27:50 <ivanm> > enumFrom True
00:27:52 <lambdabot>   [True]
00:27:57 <ivanm> gah
00:27:59 <ivanm> > enumFrom False
00:28:01 <lambdabot>   [False,True]
00:28:09 <ivanm> ^^ what's wrong with that?
00:28:12 <ivanm> @instances Enum
00:28:14 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
00:28:17 <ray> those aren't numeric
00:28:21 <ivanm> ray: everyone agrees with you!
00:28:26 <ray> i know!
00:28:30 <ivanm> ray: so? since when did Enum imply numeric?
00:28:32 <ray> but we still have floats
00:28:41 <ray> no, he said "only integral numeric types"
00:28:56 <Gracenotes> I like Enum Bool.
00:29:05 <jeffwheeler> ray: I worded it poorly
00:29:06 <ray> i took it to mean that the numeric types in Enum should all be integral
00:29:07 <ivanm> oh, I thought he meant that integral numeric types should be the only ones that are Enum
00:29:15 <jeffwheeler> ivanm: that's what I meant
00:29:30 <jeffwheeler> wait
00:29:32 <jeffwheeler> ack
00:29:33 <ivanm> hmmm.... isn't Rational an instance of Enum?
00:29:37 <ivanm> jeffwheeler: heh
00:29:50 <ivanm> you mean that out of the numeric types, only integral ones should have Enum instances?
00:29:52 <jeffwheeler> of the Numeric types, only the integral types should be Enum; Char and stuff can be, too :)
00:29:58 <jeffwheeler> exactly
00:30:33 <jeffwheeler> Like copumpkin, it's too late for me to express thoughts coherently.
00:30:38 <jeffwheeler> Or perhaps it's too late to coherently think.
00:30:43 <ray> ratios of integrals are in Enum
00:30:52 <ivanm> ray: right, they make sense
00:30:59 <ivanm> and they're not even Integrals! ;-)
00:31:02 <ray> however, nothing about floats makes sense
00:31:20 <ivanm> ray: you mean floating class, rather than Float I presume?
00:31:31 <ivanm> i.e. Float, Double and Complex don't make sense?
00:31:41 <ivanm> hmmm.... do gaussian integers make sense as Enum? :p
00:31:41 <ray> yeah, floats not Floats
00:32:27 <ray> i forget
00:32:44 <ray> depends on the cardinality
00:33:11 <ray> somehow i doubt it..
00:45:16 <mmorrow> Enum means to me that `a' maps into the integers
00:46:35 <mmorrow> (in a canonical way)
00:46:52 --- mode: ChanServ set +b *!n=gschuett@*
00:46:52 --- kick: butterfly_die was kicked by ChanServ (User is banned from this channel)
00:47:38 <mmorrow> and there are at least two ways that i can think of that Float/Double (not R) could do this
00:48:05 <mmorrow> which is why i don't like the Enum instances for them
00:50:11 <ivanm> mmorrow: what do you mean by not R? as in the actual numbers in Float/Double, not the entire infinite set of all possible real numbers?
00:50:12 <mmorrow> , fromEnum pi
00:50:14 <lunabot>  3
00:50:16 <ivanm> heh
00:50:38 <ivanm> mmorrow: and by the two mappings, you mean round vs [0,1) -> integers or something?
00:51:01 <mmorrow> ivanm: i mean how Flaot/Double have an enumerable number of values, which the real numbers don't
00:51:05 <Beelsebob> ivanm: rounding wouldn't enumerate them
00:51:29 <ivanm> mmorrow: enumerable == finite?
00:51:42 <mmorrow> countably infinite of finite
00:51:46 <Beelsebob> ivanm: no, countable
00:51:46 <mmorrow> s/of/or/
00:51:47 <ivanm> Beelsebob: I said a mapping, not an enumeration ;-)
00:52:07 <mmorrow> an injective mapping
00:52:12 <ivanm> oh? wouldn't the number of values for Float and Double be finite, due to limited number of bits?
00:52:19 <Beelsebob> yes
00:52:19 <mmorrow> yeah
00:53:03 <Beelsebob> the enumeration isn't quite as obvious as unsafeCoerse though, because some values are duplicated
00:53:38 <ivanm> @hoogle unsafeCoerce
00:53:39 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:54:00 <ivanm> hmmm... is that for any two types?
00:54:00 <ivanm> does it just read the memory and try and interpret it as that type of value?
00:54:10 <ivanm> > unsafeCoerce 2 :: Maybe Char
00:54:12 <lambdabot>   Not in scope: `unsafeCoerce'
00:54:20 <ivanm> > Unsafe.Coerce.unsafeCoerce 2 :: Maybe Char
00:54:22 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
00:54:23 <ivanm> :(
00:54:31 <Beelsebob> ivanm: yes
00:58:12 <sioraiocht> are there any haskell bindings for cocoa?
00:58:20 <ivanm> sioraiocht: IIRC, someone started some
00:58:26 <ivanm> haven't heard about them for a while though
00:58:29 <Beelsebob> sioraiocht: HoC
00:58:37 <Beelsebob> they're very difficult to get to compile though
00:58:47 <sioraiocht> Beelsebob: ah, that doesn't sound encouraging =p
00:58:55 <Beelsebob> there was a move a month or two ago to try and get them going again
00:58:59 <Beelsebob> not sure what happened to that
00:59:06 <sioraiocht> I'll just suffer and learn objective c
00:59:23 <Beelsebob> there's not a lot to learn about obj-c
00:59:43 <sioraiocht> Beelsebob: aye, I know
00:59:50 <Beelsebob> it is a shame it's the only sensible cocoa coding language though
00:59:55 <sioraiocht> Beelsebob: unfortunately, there's more to learn about the cocoa API
00:59:57 <Beelsebob> I'd love to see apple at least support something like C#
01:00:00 <sioraiocht> Beelsebob: I know =/
01:00:10 <Beelsebob> sioraiocht: yeh, but at least Cocoa is good... unlike Obj-C
01:00:21 <ivanm> Beelsebob: do you actually mean C#, or just a C#-ish language?
01:00:34 <sioraiocht> Obj-C seems to be a *really* polarising language
01:00:37 <sioraiocht> not unlike haskell
01:00:50 <Beelsebob> ivanm: something more strongly typed than Obj-C
01:01:02 <Beelsebob> or to put it another way, something more strongly typed than a wet paper bag
01:01:26 <Beelsebob> sioraiocht: not really imho -- they seem to be aproaching all sorts of things from a very dated view point
01:01:43 <Beelsebob> like, leaving in support for doing crazy machine level stuff with pointers
01:01:50 <Beelsebob> and hence at the same time crippling their GC support
01:01:52 <sioraiocht> Beelsebob: Well, it's still very C-ish
01:01:55 <mmorrow> is obj-c garbage collected or something?
01:01:58 <sioraiocht> Beelsebob: but it's not C++
01:02:05 <Beelsebob> mmorrow: Obj-C 2 is GC'd
01:02:09 <Beelsebob> or rather, optionally GC'd
01:02:24 <Beelsebob> but the GC sucks, because ultimately, it's C, and it can't keep track of pointers
01:02:27 <mmorrow> :o, and you can do arbitrary pointer arithmetic?
01:02:30 <mmorrow> ah
01:02:32 <Beelsebob> mmorrow: quite
01:02:34 <mmorrow> so it's conservative
01:02:39 <Beelsebob> yep
01:02:40 <mmorrow> like boehm or something?
01:02:48 <Beelsebob> actually, sometimes it's not conservative enough
01:02:53 <Beelsebob> it garbage collects objects
01:03:03 <sioraiocht> It's just a C-based language.  Thus you suffer from the "things are can do are not necessarily things you SHOULD do" game
01:03:04 <Beelsebob> but you can occasionally get at C structures within objects
01:03:09 <ivanm> Beelsebob: but aren't Objects garbage? :p
01:03:10 <Beelsebob> which are not strong references
01:03:26 <Beelsebob> so you can end up with it deallocating an object that you're still using the internals of
01:03:33 <mmorrow> eek
01:03:36 <Beelsebob> yep
01:03:40 <mmorrow> at least the gc is optional
01:03:45 * Beelsebob nods
01:04:32 <Beelsebob> sioraiocht: well no, really what I'm getting at is that while developing cocoa, I could save a *crap load* of time by having the compiler tell me where I got it wrong 6 hours ago, and have since been debugging
01:04:48 <sioraiocht> Beelsebob: fair enough
01:05:07 <Beelsebob> C# gives pretty comparable power to Obj-C, but manages to have the compiler complain better, and also has GC that works
01:05:23 <sioraiocht> anyone here mess with F#?
01:05:28 <Beelsebob> briefly
01:05:40 <sioraiocht> worth messing with?
01:05:47 <Beelsebob> it's... interesting
01:05:52 <Beelsebob> mess is the right word
01:05:57 <Beelsebob> because it's multi-paradigm
01:06:10 <Beelsebob> it's often not obvious what the F#ey way to do something is
01:06:28 <Beelsebob> or how to get something elegant out
01:07:01 <Beelsebob> very cool to do gui programming with a functional language though :)
01:09:58 <sioraiocht> Beelsebob: cool.  have you written any major apps in obj-c before?
01:10:18 <Beelsebob> I've written some not-insignificant things, yes
01:10:23 <sioraiocht> cool
01:10:38 <sioraiocht> I'd like to write an IRC client...mostly for myself
01:10:53 <sioraiocht> because I'm picky
01:10:54 <Beelsebob> wow, competative area
01:11:24 <Beelsebob> with already limechat, adium, colloquy, linkinus out there as cocoa IRC clients that's gonna be fun
01:11:34 <Rembane> irssi <3
01:11:54 <Beelsebob> not cocoa, but yeh, competing against that and XChat too
01:13:26 <sioraiocht> Beelsebob: yeah, i don't really want to do *better* than them, I want it to things the way i like
01:13:37 <sioraiocht> I use limechat right now, but it's slow and crashy
01:13:47 <Beelsebob> fair enough, I'll wait in eager anticipation then
01:13:54 <Beelsebob> adium is still not quite right for me :)
01:26:55 * sioraiocht <3 adium for its localisations
01:36:52 <Oejet> Is there a nice way to avoid the problem of "Could not find module `Control.Monad.Reader': it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2" without specifying -(hide-)package every single time?
01:37:37 <Twey> Remove one package?  :-P
01:37:40 <Lemmih> Oejet: ghc-pkg [--user] hide monads-fd
01:37:48 <Twey> Ooh.
01:38:53 <Oejet> Ooh, indeed. That is a useful command. Thanks, Lemmih!
01:41:06 <DrSyzygy>   
01:41:31 <mle> Well said.
01:41:39 * mle waves to DrSyzygy 
01:41:42 <DrSyzygy> Pssssht.
01:41:48 * DrSyzygy waves back.
02:04:34 <tibbe> dcoutts_: ping
02:08:09 <dcoutts> tibbe: pong
02:08:31 <tibbe> dcoutts: I'm trying to debug a bug in network and while building get:
02:08:57 <tibbe> cabal: Missing dependency on a foreign library:
02:08:57 <tibbe> * Missing header file: HsNet.h
02:09:14 <dcoutts> tibbe: it'll mean that compiling that header fails
02:09:19 <tibbe> dcoutts: now, HsNet.h is not a library and it exists in include/
02:09:24 <dcoutts> I'm assuming it's a local header
02:09:48 <tibbe> dcoutts: yes, I also have include-dirs: include
02:10:05 <dcoutts> tibbe: then it'll be that compiling it fails
02:10:09 <tibbe> dcoutts: so presumably it finds it but it fails to compile?
02:10:11 <tibbe> ah
02:10:42 <tibbe> dcoutts: -v doesn't output compilation errors
02:10:55 <dcoutts> tibbe: patches accepted :-)
02:11:17 <dcoutts> tibbe: -v3 might. But most of the time the error would be long an uninformative.
02:12:04 <dcoutts> tibbe: I think the solution is to run cpp separately from cc, so we can distinguish failing to find includes vs compilation problems
02:12:20 <tibbe> dcoutts: sounds reasonable
02:12:29 <tibbe> dcoutts: should I file a bug to track it?
02:13:14 <dcoutts> tibbe: I think there's one already
02:13:23 <dcoutts> tibbe: but if there isn't then yes, file another one
02:13:45 <tibbe> ok, i'll check it out
02:13:52 <tibbe> dcoutts: found the error btw
02:19:04 <tibbe> dcoutts: http://hackage.haskell.org/trac/hackage/ticket/532 - Title looks like it would be my "problem" but description is confusing
02:20:00 <dcoutts> tibbe: ok, add your instance of the problem to that ticket along with any suggestions
02:20:29 <tibbe> dcoutts: ok
02:27:40 <tibbe> @seen bos
02:27:40 <lambdabot> bos is in #haskell-in-depth, #haskell and #ghc. I don't know when bos last spoke.
02:30:17 <Vanadium> lambdabot could at least give an estimate of how long he knows that bos has not spoken
02:30:41 <soupdragon> preflex: seen bos
02:30:41 <preflex>  bos was last seen on #haskell 13 days, 12 hours, 38 minutes and 6 seconds ago, saying: just a relink will do the trick.
02:30:51 <soupdragon> preflex: seen bos1337
02:30:51 <preflex>  Sorry, I haven't seen bos1337
02:39:10 <mmorrow> i think it's bos31337
02:41:56 <tibbe> dcoutts: do you know how to properly test whether I'm on a windows platform and DWORD is defined?
02:42:17 <tibbe> @seen bos31337
02:42:18 <lambdabot> bos31337 has changed nick to bos.
02:42:18 <lambdabot> bos is in #haskell-in-depth, #haskell and #ghc. I don't know when bos last spoke.
02:42:39 <tibbe> dcoutts: trying to fix the network problems
02:42:42 <dcoutts> tibbe: presumably you mean DWORD as a C typedef from some header file?
02:42:49 <tibbe> dcoutts: yes
02:42:57 <tibbe> dcoutts: presumably I wanna test for "windows"
02:43:09 <tibbe> dcoutts: (the network code is full of different ifdef tests)
02:43:15 <dcoutts> tibbe: what is the context, in a .hs file?
02:43:22 <tibbe> dcoutts: .h
02:43:27 <elvenporn> preflex: seen bos31337
02:43:27 <preflex>  bos31337 was last seen on #haskell 13 days, 4 hours, 55 minutes and 1 second ago, saying: the prelude isn't so bad.
02:43:28 <tibbe> dcoutts: HsNet.h to be presice
02:44:16 <tibbe> dcoutts: bos added a fix for the win breakage that broke non-win platform xD
02:44:25 <dcoutts> tibbe: so the thing that is actually being compiled is a .c file that includes HsNet.h
02:44:33 <tibbe> dcoutts: yes
02:45:07 <tibbe> dcoutts: what I want to check is: Is getnameinfo defined with DWORDs (like it is one windows)
02:49:39 <dcoutts> tibbe: I think ghc will define those platform cpp flags for .c files as well as for .hs files
02:50:15 <tibbe> dcoutts: yes, testing for "# if defined(HAVE_WINSOCK2_H) && !defined(__CYGWIN__)" seems to work
02:55:09 <tibbe> dcoutts: fixes it for now, I'll make a new bugfix release
02:55:44 <dcoutts> tibbe: ok, so this is the one you want for the next HP release, right?
02:55:52 <tibbe> dcoutts: yes
02:56:07 <dcoutts> tibbe: ok, announce that on the platform mailing list
02:56:37 <tibbe> dcoutts: ok
02:56:57 <tibbe> dcoutts: something really needs to be done about the network package. I don't think anyone understands it at the moment
02:57:07 <dcoutts> tibbe: :-)
02:57:39 * tibbe blames windows
02:58:36 <mmorrow> tibbe: always a safe bet
02:58:45 <tibbe> :)
03:01:03 <hackagebot> network 2.2.1.4 - Networking-related facilities (JohanTibell)
03:07:20 <QinGW> >val i:int=2
03:07:22 <QinGW> ;;
03:07:29 <QinGW> >val i:int =2 ;;
03:23:59 <shapr> lambdabot: @botsnack
03:23:59 <lambdabot> :)
03:26:35 <agapoulitsas> map (+1) [1,2,3]
03:26:57 <EvilTerran> [2,3,4]
03:27:20 <soupdragon> factor 6417879
03:28:09 <Beelsebob> Not in scope: `factor'
03:28:14 <EvilTerran> uh
03:28:25 <mmorrow> preflex: cdecl int
03:28:32 <elvenporn> int
03:29:04 <mmorrow> preflex: cdecl void *(*foo [])(void*,void*)
03:29:21 <elvenporn> foo: array of pointer to function(pointer to void, pointer to void) returning pointer to void
03:29:40 <mmorrow> elvenporn: yay, thx
03:30:38 <mmorrow> wait, elvenporn is preflex...
03:30:56 <mmorrow> preflex: 8ball omg will it?
03:30:57 <preflex>  my reply is no
03:31:00 <mmorrow> :o
03:31:24 <mmorrow> elvenporn: are you a bot?
03:31:32 <mmorrow> preflex: are you a bot?
03:31:32 <preflex>  yes.
03:31:37 <elvenporn> hoho
03:31:38 <EvilTerran> @bots
03:31:39 <lunabot>  :)
03:31:39 <lambdabot> :)
03:31:48 <mmorrow> elvenporn: just checking ;)
03:32:35 * elvenporn fails the turing test in %d new and exciting ways
03:33:17 * mmorrow notes that that hard-coded response to that question in preflex is handay
03:33:44 <elvenporn> why?
03:34:13 <agapoulitsas> @bots
03:34:14 <lunabot>  :)
03:34:14 <lambdabot> :)
03:34:14 <mmorrow> elvenporn: because it was a sure-fire way (unless you've read the preflex code) to see if you were actually an instance of preflex
03:34:37 <elvenporn> preflex: version
03:34:37 <preflex>  7.001
03:34:43 <mmorrow> (an instance of preflex that still had cdecl... dunno why mauke got rid of that)
03:34:50 <mmorrow> elvenporn: version
03:35:00 <elvenporn> (still not a bot)
03:35:42 * mmorrow will check again in an hour
03:36:16 <elvenporn> cdecl is an external program and I couldn't be bothered to install it on preflex's new host
03:36:17 <mmorrow> elvenporn: are you mauke?
03:36:20 <mmorrow> heh
03:36:29 <elvenporn> also cdecl has some bugs
03:36:47 <mmorrow> elvenporn: yeah, i've actually got your "explain.c", but it's borked somehow..
03:37:00 <mmorrow> it always says "trailing junk at end of line" or something
03:37:15 <elvenporn> well, that shouldn't happen
03:37:43 <mmorrow> maybe it's how i'm running it
03:37:48 <mmorrow> haven't tried in a while
03:38:45 <mmorrow> elvenporn: that really would have fooled me if you answered "yes." to "are you a bot?"
03:39:10 <elvenporn> next time :-)
03:39:24 <mmorrow> about 57 minutes
03:47:47 <altmattr> are there any important differences between Text.PrettyPrint.Leijen and Text.PrettyPrint.HughesPJ?
03:48:06 <mmorrow> altmattr: yes, they're different
03:48:25 <mmorrow> altmattr: as in two different implems of a similar idea
03:48:25 <ivanm> altmattr: if they weren't different, why bother with the new packages? :p
03:48:32 <altmattr> I guess I should have asked "what is a one line summary of the differences ... :)
03:48:55 <mmorrow> altmattr: iirc there's a paper describing one of them
03:48:59 <altmattr> what I mean is, why choose one over the other, etc?
03:49:04 <ivanm> altmattr: they're based on papers by different people? :p
03:49:15 <altmattr> :P indeed
03:49:43 <ivanm> altmattr: the API looks very different
03:49:46 <mmorrow> altmattr: i haven't used the leijen one, so i use the hughespj one out of habit, nothing else
03:49:53 <ivanm> it's meant to be a "prettier printer"
03:50:07 <ivanm> mmorrow: simple stuff seems to be the same though
03:50:26 <ivanm> looks like it's mainly an extension
03:50:31 <mmorrow> is the leijen one the newer one?
03:50:34 <ivanm> yeah
03:50:35 <mmorrow> ah, ok
03:50:41 <mmorrow> maybe i'll check that out then
03:50:50 <ivanm> mmorrow: IIRC, isn't the hughesPJ one just there out of habit?
03:51:04 <mmorrow> yeah, i think so
03:51:21 <mmorrow> i think it's over 10 years old
03:51:30 <mmorrow> which for haskell is a loooong time
03:52:12 <altmattr> but HughesPJ got into the haskell platform and Leijen did not, so I thought however made taht decision might be lurking around :)
03:52:15 <ivanm> mmorrow: especially nowadays?
03:52:25 <ivanm> altmattr: it's in the HP because it comes with GHC
03:52:30 <ivanm> AFAIK, that's the sole reasoning
03:52:36 <altmattr> ivanm: gotcha
03:52:40 <ivanm> HP-2009.* == GHC + ExtraLibs
03:52:56 <altmattr> See, I have code that uses both and I am wondering which to standardise on
03:53:03 <ivanm> altmattr: I'd say leijen
03:53:18 <altmattr> that's good enough for me!
03:53:19 <ivanm> it requires an extra dep to be installed, but it looks like an extension
03:53:46 <ivanm> AFAICT, for the most part leijin = HughesPJ + goodness
03:53:47 <ivanm> ;-)
03:54:05 <ivanm> though nest is different... use indent for the same functionality
03:55:21 <altmattr> ivanm: well the code I have uses leijen for nesting, and hughespj for simpler stuff, so I think this way is ieasier
03:57:21 <altmattr> for anyone who cares, since I was in here askinga bout hardware that would run ghc quickly - I have ended up with a macbook pro - and it is very, very, very fast compared to my old PPC box (which was supposedly about as quick in general) - intel - how I love thee
03:58:30 <ivanm> altmattr: you like macs, I take it?
03:59:02 <altmattr> that is neither here nor there, right now I like intel!
03:59:14 <altmattr> in fact I like unix and laptops, leaving me with a mac (for now)
04:03:03 <altmattr> another andvantage of being on intel - the latest ghc!!!
04:03:04 <altmattr> Spaces are not allowed in SCCs
04:03:07 <altmattr> thankyou ghc!
04:03:10 * bremner mutters in the corner about 10 years of linux on laptops
04:03:32 <altmattr> bremner: have you got it working yet :)
04:03:56 <bremner> altmattr: yes
04:04:29 <bremner> altmattr: seriously, its just a different set of tradeoffs, and what software you need the most
04:04:52 <altmattr> I know, I don't really care what OS I have, as long as it does what I want
04:04:56 <altmattr> and that is mac or linus for now
04:05:05 <altmattr> and some time in the future it might even be windows
04:05:15 <altmattr> it was in my deep dark past as a graphics programmer
04:05:18 * ivanm didn't know Linus Torvalds had upgraded himself into an OS... :p
04:05:31 <altmattr> he has downgraded my typing skills
04:05:43 <ivanm> heh
04:08:33 <agapoulitsas> tanenbaum rules
04:09:22 <ivanm> agapoulitsas: rules what?
04:10:40 <altmattr> ivanm: rules my typing skills
04:11:27 <altmattr> i killed it!
04:11:34 <altmattr> ghc: panic!
04:11:39 <ivanm> heh
04:13:00 <altmattr> great, maybe PPC was not so bad after all......
04:13:05 <ivanm> heh
04:13:18 <ivanm> altmattr: what code did you have that GHC borked?
04:13:29 <altmattr> MissingH System.Path.WildMatch
04:14:18 * ivanm has never used MissingH
04:14:25 <ivanm> I have all the haitches I need
04:14:27 <ivanm> ;-)
04:14:55 <ray> you're filled with hatred
04:15:05 <ivanm> actually, I'm not
04:18:56 <osfameron> e's filled ith "atred", if e's missing aitces
04:19:03 <osfameron> oops
04:19:05 <osfameron> *wit
04:19:10 <mmorrow> mauke: re: the tco and return foo() in a funtion returning void (i just happened to turn on -pedantic) => ISO C forbids ‘return’ with expression, in function returning void
04:20:12 <soupdragon> im failing
04:20:16 <soupdragon> this sucks
04:21:29 <Vanadium> It does?
04:22:38 <Vanadium> Neat. C++ allows it, though. :)
04:23:23 <mmorrow> mauke: just checked, doing "return foo();" and "foo();\nreturn;" produce identical asm
04:23:50 <mmorrow> Vanadium: -pedantic is really pedantic ;)
04:24:09 <Vanadium> mmorrow: Yeah, I use it by default, but I was used to the C++ behaviour.
04:24:52 <mmorrow> i just realized how heavily i use zero-length arrays in structs and do pointer arithmetic on (void*)
04:24:57 <Axman6> soupdragon: failing at what?
04:25:41 * mmorrow just received a 100 line lecture
04:25:43 <mlesniak> How do I convert a Char to a Word8?
04:25:44 <soupdragon> getting started writing a program
04:26:04 <mmorrow> @type (fromIntegral . ord) :: Char -> Word8
04:26:07 <lambdabot> Char -> Word8
04:26:15 <mmorrow> @type (fromIntegral . ord)
04:26:17 <lambdabot> forall b. (Num b) => Char -> b
04:26:41 <EvilTerran> ?type let betweEnum :: (Enum a, Enum b) => a -> b; betweEnum = toEnum.fromEnum in betweEnum :: Char -> Word8
04:26:43 <lambdabot> Char -> Word8
04:26:58 <mlesniak> mmorrow: Argh, Should have asked hoogle for Char -> Word8 ;)
04:27:20 <mlesniak> Data.ByteString.Internal.c2w ...
04:27:20 <EvilTerran> mlesniak, hoogle probably wouldn't've found anything, seeing as you neeed at least two functions
04:27:22 <mmorrow> it probably would just come back with the ones in ByteString.Internal
04:27:34 <mmorrow> (which have {-# INLINE #-} on them..)
04:27:48 <mmorrow> i like those myself
04:27:49 <Bacta> @fag sex?
04:27:50 <lambdabot> The answer is: Yes! Haskell can do that.
04:27:52 <mlesniak> mmorrow: is INLINE a bad thing? (tm)
04:28:04 <mmorrow> mlesniak: it's a good thing
04:28:12 <mlesniak> mmorrow: thought so ;)
04:28:14 <mlesniak> Thanks!
04:28:20 <mmorrow> @where ops
04:28:20 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
04:28:20 <lambdabot> mauke
04:28:29 * EvilTerran half-suspectedthe .Internal ones to be "c2w :: Char -> Word8; c2w = unsafeCoerce#" :P
04:28:34 <mmorrow> Bacta: oh hai
04:28:41 <Bacta> Hai!
04:28:51 --- mode: ChanServ set +o Cale
04:29:00 <Cale> Bacta: please behave :)
04:29:10 --- mode: Cale set -o Cale
04:29:12 <Bacta> Ok Friend :)
04:29:22 <RayNbow> Cale's power level just went over 9000 for a short moment :p
04:29:39 <Bacta> Over 90000000000000000000000000000000000!!!
04:31:04 <RayNbow> > let (!) n = product [1..n] in (((90000000000000000000000000000000000!)!)!)
04:31:10 <lambdabot>   mueval-core: Prelude.read: no parse
04:31:10 <lambdabot>  mueval: ExitFailure 1
04:33:49 <mmorrow> gcc makes C so much better by doing tco
04:35:13 <Ke> total cost of ownership?
04:35:23 <Cale> tail call optimisation
04:36:08 <Cale> dons: Haha, posting the comparison of C++ concepts and Haskell type classes paper to the programming reddit was a great idea :)
04:36:22 <Cale> I laughed, anyway :)
04:38:27 <RayNbow> Cale: link? :)
04:38:39 <dschoepe> RayNbow: http://www.reddit.com/r/programming/comments/92w0q/timely_comparing_c_concepts_and_haskell_type/
04:38:57 <RayNbow> thx :)
04:39:16 <Cale> (for those who aren't aware, concepts just got dropped from C++0x)
04:40:34 <HugoDaniel> hmm
04:40:45 <HugoDaniel> they have voted the concepts out of the c++0x yesterday
04:41:32 <HugoDaniel> when i read the comparison paper i was like thinking to myself "wow, these c++ is going in the good direction...", then they voted it out...
04:42:02 <HugoDaniel> c++ is a strange world
04:42:20 <dschoepe> the noisy syntax would have made using it very tiresome though
04:43:37 <Vanadium> HugoDaniel: They voted it out because it was getting too irritating, not because they dislike the direction.
04:46:10 * mmorrow facilitiates crossword cheating with grep + /usr/share/dict/words
04:50:11 <mlesniak> mmorrow: Try http://www06.wolframalpha.com/input/?i=_en_t__
04:50:12 <mlesniak> ;)
04:50:59 <mmorrow> haha, a web interface to grep + /usr/share/dict/words :)
04:51:15 * mmorrow passes this on to the crossword-doer next to him
04:51:19 <mlesniak> mmorrow: right, right ar your fingertips
04:51:25 <Vanadium> How is that cheating?
04:51:38 <soupdragon> cheating
04:51:42 <mlesniak> It becomes cheating when you start using OCR and automatic filling ;)
04:51:50 <mlesniak> (Seems like an interesting side project)
04:52:02 <mmorrow> @go OCR
04:52:04 <lambdabot> http://en.wikipedia.org/wiki/Optical_character_recognition
04:52:04 <lambdabot> Title: Optical character recognition - Wikipedia, the free encyclopedia
04:52:07 <mmorrow> haha
04:52:21 <altmattr> where does one find the documentation for the latest haskell libs?  IN particular, I need to update my exception handling code
04:52:45 <mmorrow> altmattr: there's a link on haskell.org hiding somewhere
04:58:52 <madhadron> So if I have a two parameter type class, and I want to define a type synonym for one parameter in terms of the other...
04:59:18 <madhadron> What am I missing that makes 'type RawOf b = a' (for a and b parameters of the class) not work?
05:00:16 <EvilTerran> madhadron, is that meant to be an associated type family?
05:00:35 <madhadron> Basically
05:01:04 <madhadron> The issue is that I have two isomorphic enumerated types, and I'm trying to pair them so I can transfer a Storable instance from one to the other generically
05:01:08 <altmattr> all right, I have looked it over and I have no idea - how do I construct predicates to work with the new catchJust/handleJust and tryJust functions?!?
05:01:10 <BresBo>         Eight inches ... Nine, and still growing.  His erection was now
05:01:13 <BresBo> half as thick as his own wrist as -with a grunt of sexual ecstasy- he
05:01:15 <BresBo> began to spurt enormous quantities of cum into Christa's throat.
05:01:18 <BresBo> Greedily, she slurped and sucked on him as the tingle began to fade.  Drop
05:01:20 <BresBo> by drop, she tried to stem the stream, but enormous quantities spilled out
05:01:23 <BresBo> from around her mouth.  Nearly a minute passed, as Curt reached and
05:01:25 <BresBo> exceeded ten inches.  Still sucking down as much of his cum as she could,
05:01:26 <EvilTerran> ?where ops
05:01:27 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
05:01:27 <lambdabot> mauke
05:01:28 <BresBo> Christa squeezed his balls tightly, as if wringing every drop out of him.
05:01:28 --- mode: ChanServ set +o Igloo
05:01:30 <BresBo> Spurting over her lips, face and hair, Curt's orgasm gradually subsided,
05:01:33 <BresBo> leaving him still shaking with pleasure.
05:01:35 <BresBo>         Gasping for air, Christa wiped her mouth on the back of her hand
05:01:38 <BresBo> and looked at Curt, stunned.  "That's ... that's some experiment!" she
05:01:38 --- mode: Igloo set +b *!*@@c-98-218-95-239.hsd1.dc.comcast.net
05:01:40 <BresBo> gasped.
05:01:42 --- kick: BresBo was kicked by Igloo (Igloo)
05:01:44 <EvilTerran> Igloo++
05:01:53 <madhadron> Well, that was...edifying.
05:01:56 --- mode: Igloo set +b *!*@c-98-218-95-239.hsd1.dc.comcast.net
05:01:59 --- mode: Igloo set -b *!*@@c-98-218-95-239.hsd1.dc.comcast.net
05:03:03 <EvilTerran> madhadron, i'd've thought the way to do that would be with a single-parameter typeclass with an ATS, something like "class HasRaw a where { type RawOf a; ... }"
05:03:24 <madhadron> EvilTerran, And then just use the instance to pair it?
05:03:28 <EvilTerran> indeed
05:03:28 <madhadron> That probably is simpler.
05:03:39 <Cale> madhadron: I doubt there's any interaction between associated types and multiparameter typeclasses at the moment
05:04:06 * EvilTerran boggles at the idea
05:04:06 <BONUS> they go well together though
05:04:08 <madhadron> altmattr, Essentially, decide what kind of Exception you're handling, and right standard code checking each of its cases
05:04:16 <BONUS> in general
05:04:32 <EvilTerran> BONUS, well, surely you should only really need one or the other?
05:04:34 <Cale> They're sort of competing for the same part of the design space.
05:04:37 <EvilTerran> in any given situation
05:04:41 <madhadron> Hey, it seemed like a natural thing to ask for in my brain.
05:04:49 <BONUS> fundeps and ATs, yes
05:04:59 <BONUS> but like with multiparam typeclasses and ATs, you can do stuff like
05:05:05 <Cale> It does seem like a moderately reasonable thing to ask for. :)
05:05:19 <altmattr> madhadron: thanks, but how do I do that
05:05:32 <BONUS> class Cons a b where type ResTy a b; cons :: a -> [b] -> [ResTy a b]
05:05:45 <madhadron> altmattr, Hmm...well, to make example code relevant, which Exception instance are you trying to handle?
05:05:46 <BONUS> then you can like prepend an int to a list of doubles
05:05:57 <BONUS> and fun stuff like that
05:06:07 <altmattr> ioErrors and errorCalls
05:06:11 <madhadron> Actually, they would be nice in my case because I could write type signatures like (Paired b a, Storable a) => Storable b
05:06:30 <BONUS> btw i stole that directly from SPJ's paper "Fun With Type Functions"
05:06:45 <madhadron> BONUS, Yes, it's sitting open on my other desktop at the moment.
05:07:27 <Cale> altmattr: You're having trouble writing the function e -> Maybe b ?
05:07:28 <madhadron> altmattr, Well, the simplest thing is just to write
05:07:35 <madhadron> \_ -> Just ()
05:07:51 <madhadron> Assuming b ~ ()
05:08:19 <Cale> ...
05:08:24 <madhadron> altmattr, Or just use fromException
05:08:33 <altmattr> madhadron: presumably that catches all exceptions?
05:08:42 <madhadron> altmattr, Yes.
05:08:43 <Cale> altmattr: It would, yeah
05:09:14 <altmattr> fromException gives Maybe () no matter what you give it right?
05:09:20 <altmattr> ignore that
05:09:47 <Cale> fromException gives Just x if the exception was of the type you wanted to catch, and Nothing otherwise.
05:10:01 <madhadron> altmattr, Would the existance of the 'ioeGetErrorType' function make you happier?
05:10:25 <altmattr> madhadron: well, I used to use `errorCalls`, so yes
05:10:39 <madhadron> altmattr, Plug it into Hoogle, and you'll get the docs.
05:10:58 <altmattr> Cale: ah- so I need to use :: ExceptionType ???
05:11:06 <madhadron> It returns an IOErrorType, which is a nice ADT (just click on the source link to the right of its definition)
05:11:08 <altmattr> to tell it what one to work with
05:11:23 <Cale> altmattr: possibly
05:11:41 <madhadron> altmattr, Or failing that, you can just have a default which rethrows anything you don't handle.
05:11:42 <Cale> altmattr: Or just pattern match the result, for almost anything but IOException
05:11:47 <altmattr> otherwise how would it know what type I am trying to catch
05:11:54 <Cale> altmattr: Type inference
05:12:07 <altmattr> but this is where I tell it what type to catch
05:12:26 <altmattr> there are many possible exceptions coming from the code running inside the catchJust
05:12:36 <altmattr> the type system only know they are Exceptions
05:12:37 <Cale> altmattr:  catch (evaluate foo) (\ErrorCall x -> ...)
05:12:39 <altmattr> surely
05:13:15 <madhadron> altmattr, Actually, if you use ioeGetErrorType, it will infer IOError
05:13:23 <Cale> If it's *just* an ErrorCall you're trying to catch
05:13:37 <madhadron> The compiler will try to catch the most general class of errors your handler will deal with.
05:13:43 <Cale> altmattr: Hm? If you do something with the exception value, then maybe it knows more
05:13:45 <altmattr> in another part of the code, I am catching IOerrors only in one place
05:14:03 <Cale> altmattr: Specifically, if you pattern match on it, or apply any operation which is specific to that exception type.
05:14:05 <madhadron> Ouch, I just made the type checker very unhappy.
05:14:05 <altmattr> and error calls elsewhere
05:14:14 <Cale> altmattr: Okay, great :)
05:15:27 <altmattr> madhadron: more info
05:15:51 <madhadron> altmattr, It didn't like having type functions in type contexts
05:16:24 <altmattr> i bet
05:16:43 * madhadron soothes his type checker back to contentment.
05:16:45 <Cale> hmm, that is very strange. Why doesn't IOException have any operations?
05:17:01 <Cale> Well, I suppose it has Eq and Show
05:17:16 <madhadron> Cale, You're supposed to use that function I mentioned earlier to get what happened as an ADT
05:17:48 <Cale> ah, it lives in System.IO.Error
05:17:52 <madhadron> Or just match on the fact that it's IOException
05:17:54 <madhadron> and is an ADT itself
05:18:03 <madhadron> with fields like ioe_handle, ioe_type, etc.
05:18:37 <Cale> and for some reason IOError is a type synonym for IOException
05:18:54 <Cale> IOException doesn't appear to export its constructor
05:19:00 <madhadron> And IOException's sole constructor is IOError
05:19:29 <altmattr> Cale: you see why I came here for help :)
05:19:37 <madhadron> Cale, Doesn't it?  It says IOException(..) at the top of the source file
05:19:43 <madhadron> in the export list
05:20:05 <Cale>         IOException,            -- instance Eq, Ord, Show, Typeable, Exception
05:20:15 <Cale> does it?
05:20:27 <Cale> Maybe you're looking at a different Control.Exception than I am.
05:21:00 <altmattr> ls
05:21:02 <madhadron> I'm in the source file GHC.IOBase
05:21:03 <altmattr> oops
05:21:10 <Cale> ah
05:21:24 <Cale> That's GHC internals though, you're not expected to import that normally.
05:21:25 <madhadron> which I reached from the Source link for IOError in System.IO.Error
05:21:30 <Cale> right.
05:21:48 <madhadron> There we find that IOError is a synonym for IOException,
05:21:55 <madhadron> IOException is exported with all its constructors and fields,
05:22:02 <madhadron> and IOException's sole constructor is IOError
05:22:10 <madhadron> which in turn has a few accessor functions
05:22:11 <Cale> altmattr: *anyway* the answer is that you can avoid needing an explicit type signature if you apply any of the functions in System.IO.Error to your exception
05:22:25 <altmattr> Cale: thankyou!
05:24:22 <altmattr> madhadron: thankyou too
05:24:26 <Cale> I suppose another possibility, if a little awkward, would be to write something like:
05:24:44 <Cale> newtype IOE = IOE IOException
05:24:54 <Cale> instance Exception IOE
05:25:14 <Cale> and then you can  catch (...) (\IOE e -> ...)
05:25:53 <madhadron> Cale, Who's going to throw the IOE?
05:26:05 <Cale> mm... right you are, nothing ;)
05:26:20 <Cale> hmm... however...
05:26:29 <madhadron> Gah.  All I want is to be able to write
05:26:32 <Cale> If we implement the Exception class manually
05:26:42 <madhadron> class Storable a => Paired b a | b -> a
05:26:51 <madhadron> class Paired b a => Storable b
05:27:06 <madhadron> Cale, Sure, then just catch away.
05:27:18 <madhadron> And there's no reason you can't throw your own IOError
05:27:26 <madhadron> ...just usually it would probably make more sense to throw something else
05:27:41 <madhadron> After all, if you're throwing it, and you're not Simon Peyton-Jones, it's probably not really an IO error, yes?
05:27:42 <Cale> instance Exception IOE where
05:28:07 <Cale>   fromException e = fmap IOE fromException
05:28:18 <Cale>   fromException e = fmap IOE (fromException e)
05:28:40 <Cale> I think that might work :)
05:29:15 * Cale tries it
05:30:58 <EvilTerran> madhadron, unless you're writing bindings for some IO-heavy library or something, i guess
05:31:19 <madhadron> EvilTerran, Yeah, IIDC1394 camera control
05:31:26 <madhadron> With endless C enumerations
05:32:24 <madhadron> I can handle them by wrapping a newtype around CInt, using hsc2hs's #enum directive, and then writing custom Read/Show instances to only allow reading and writing of the enum equivalent names
05:32:56 <madhadron> But it struck me that it would be much cleaner just to declare the newtype around CInt deriving storable
05:33:16 <madhadron> write out an ADT for the Haskell side
05:33:44 <madhadron> then hard code two lists of the ADT constructors and the enum constructors, and have a generic instance of Storable for the ADT depending on them
05:33:59 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7317#a7317
05:34:57 <Cale> altmattr: ^^ illustration of how that newtype trick works
05:35:11 <madhadron> Cale, Cute
05:35:16 <Cale> altmattr: You could construct a newtype for catching any arbitrary set of exception types
05:36:02 <altmattr> Cale: nice, thanks
05:36:24 <Cale> But you'd have to change the IOException to SomeException, and then use an implementation of fromException with lots of explicit typesignatures strewn about ;)
05:36:57 <Cale> (and some Maybe-combining operations, like mplus
05:36:58 <Cale> )
05:38:13 <Cale> oh, heh, just realised that main isn't very demonstrative in a compiled program, but if you run it at the ghci prompt, you can see the empty string
05:39:22 <Cale> Ideally, IOException would be a newtype around IOError like this.
05:39:36 <Cale> But instead, they're type synonyms.
05:39:52 <Cale> So you can't use the tag in pattern matching to nail down what it is that you're looking for
05:40:11 <madhadron> Cale, You can use IOError
05:40:17 <madhadron> ...with arguments
05:40:28 <Cale> If you're willing to import GHC.IOBase or whatever it was :)
05:40:32 <madhadron> System.IO.Error
05:40:46 <madhadron> IOException is an ADT, as I said.  You can just match on it.
05:40:51 <madhadron> It's just not shown in the Haddock documentation.
05:40:54 <Cale> Oh, does System.IO.Error export the constructors?
05:41:39 <madhadron> Oh, it doesn't.  That's why it's the newtype.
05:41:48 <madhadron> So they can export IOError, but not IOException and its constructors.
05:41:49 <madhadron> Pardon me.
05:42:12 <Cale> right...
05:46:43 * madhadron considers forcing this whole mess with Template Haskell...
05:46:58 <madhadron> Oh, to the devil with it.  I'll just write it by hand.
05:51:47 * EvilTerran wants a continuation-transformed operating system
05:52:14 <EvilTerran> with serializable continuations!
06:01:23 <ray> or more generally, a haskell machine
06:17:12 <anty> How do I take a screenshot of the desktop? I need it for Windows only, but I can't find any documentation :/
06:17:48 <Axman6> use VB >_>
06:18:01 <anty> :) that would be the easy way ;)
06:18:02 <Axman6> i really doubt there'll be a nice way to do it i haskell
06:19:21 <anty> I think it's somehow possible with wxHaskell, but I have no idea how others do it
06:19:25 <Philonous1> @type foldM
06:19:27 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
06:19:34 <anji> can't you just call win32 from haskell?
06:19:43 <CalJohn> anty: you need to find a library function and FFI to it
06:20:16 <anty> @CalJohn I'll try that
06:20:17 <lambdabot> Unknown command, try @list
06:20:31 <twanvl> Graphics.Win32.Window.GetDesktopWindow + CaptureWindow, or something like that
06:22:13 <anty> twanvl: thanks, that looks like a solution!
06:22:56 <onats_> where can i see sample codes of haskell language? anyone?
06:23:24 <Philonous1> mapM should really be something like (Functor t, Foldable t, Monad m) => (a -> mb) -> t a -> m (t a)
06:24:03 <Philonous1> m (t b) even
06:24:19 <blackh> onats_: http://hackage.haskell.org/packages/archive/pkg-list.html
06:24:33 <blackh> In most cases you can view the Haskell code from the browser.
06:24:52 <twanvl> ?type traverse
06:24:53 <lambdabot> Not in scope: `traverse'
06:25:03 <twanvl> ?type Data.Traversable.traverse
06:25:04 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:25:12 <onats_> geez
06:25:15 <onats_> looks alien to me
06:25:19 <onats_> hehe
06:25:37 <blackh> onats_: Haskell is different to other languages in many ways.
06:26:01 <onats_> i see.. i just saw a reference to it and googled it a bit..
06:26:33 <Philonous1> twanvl: Thanks.
06:26:43 <blackh> onats_: Where do I begin. :)
06:27:04 <onats_> how about, any sample apps that have been written purely in haskell?
06:27:37 <Philonous> onats_: http://www.xmonad.org/ http://darcs.net/
06:27:38 <CalJohn> onats_: I doubt you will figure out the language like that, probably better to read a book :)
06:28:25 <onats_> looking...
06:28:39 <onats_> CalJohn, of course, I'd like to understand first what I can achieve by learning this language...
06:28:55 <blackh> onats_: How about this piece of code? http://www.reddit.com/user/blackh
06:28:57 <Cale> onats_: Well, what languages do you already know?
06:29:11 <onats_> Cale, java mostly, groovy, a little bit of C
06:29:26 <blackh> onats_: Compare that with the same polygon clipping algorithm in another language.
06:29:55 <blackh> onats_: It shouldn't be too hard to follow for someone who hasn't seen Haskell before.
06:29:58 <Cale> onats_: Okay, then, quite a lot of interesting things...
06:30:02 <onats_> blackh, so this is more focused on mathematical functions?
06:30:11 <snurble> onats_, look at http://www.realworldhaskell.org/, there's many explained examples there
06:30:12 <onats_> making it easy to write formula?
06:30:21 <blackh> onats_: Haskell is a general purpose language.
06:30:42 <Cale> onats_: Well, all programs are a bit like mathematical functions if you look at them the right way. :)
06:30:50 <Philonous> onats_: Makes it easy to write what you think
06:31:26 <onats_> i bet you guys dont use any IDE?
06:31:57 <Cale> onats_: Not myself. ghci + vim in separate terminal windows is what I mostly use.
06:32:03 <blackh> onats_: You're right - There is no decent IDE for Haskell yet.
06:32:04 <Philonous> Is emacs an IDE?
06:32:23 <Cale> blackh: Have you tried leksah? Is it any good?
06:32:27 <mux_> emacs is an OS that only lacks a decent text editor
06:32:41 <blackh> Cale: I really like Leksah but it needs a bit of work.
06:32:41 <onats_> well thanks for the introduction guys...
06:32:58 <ivanm> Philonous: depends on how you define an IDE
06:33:01 <blackh> onats_: No problem!
06:33:02 <onats_> im not sure i might be able to take full advantage of it yet. will probably need to do more research
06:33:03 <ivanm> and how much elisp you use ;-)
06:33:08 <Cale> onats_: How much have you been exposed to functional programming concepts?
06:33:23 <Cale> onats_: I'm not sure what Groovy is like at all, is it imperative?
06:33:33 <CalJohn> Cale: it is OO
06:33:34 <onats_> Cale, im really bad with programming terms..
06:34:33 <Cale> onats_: Okay, looking at groovy a bit, it looks rather imperative/OO, so you'll be in for a surprise at how different programming can be :)
06:35:01 <blackh> onats_: "Imperative" means that you write your program in terms of what you want it to do.  Most languages are imperative.
06:35:11 <onats_> now thats something i have to be exposed to.. im used to programming being something like java
06:35:25 <onats_> blackh, ok... thanks:D will keep that in mind
06:36:10 <blackh> onats_: Functional programming is more "declarative" which means you are describing your problem directly.
06:36:24 <Cale> onats_: One of the things which makes Haskell a functional programming language is that it encourages you to make use of functions as first-class values: you can pass them to other functions, produce them as the result of a function, store them in datastructures, there is a literal syntax for them, and so on
06:37:04 <Cale> onats_: So, for instance, there is a function called map, which takes as its parameters a function and a list, and it applies the function to each element of the list to give a new list.
06:37:20 <Cale> > map (*2) [1..10]
06:37:24 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
06:37:27 <onats_> nice.. but i think that can be done in java too..
06:37:34 <onats_> or so i think..
06:38:03 <blackh> onats_: This may sound very strange, but Haskell is brilliant because of what it *doesn't* let you do.
06:38:05 <Cale> Yes, though, it generally requires a lot of code to construct objects which turn those functions into values.
06:38:17 <Cale> and so nobody does it as much
06:38:36 <Cale> It's not the main way of thinking, because it's too awkward to do it constantly.
06:38:59 <soupdragon>  <onats_> nice.. but i think that can be done in java too..
06:39:14 <soupdragon> onats_: A lot of stuff can be done in java
06:39:49 <Cale> onats_: In Haskell, to define a function you don't even necessarily have to give it a name
06:40:07 <soupdragon> onats_: if you keep thinking about how to do java things in haskell or vice versa it will just slow you down
06:40:19 <Cale> onats_: The syntax (\x -> x^2 + x + 1) for instance gives you a function which when applied to x, gives the result x^2 + x + 1
06:40:49 <Cale> > map (\x -> x^2 + x + 1) [-5..5]
06:40:50 <lambdabot>   [21,13,7,3,1,1,3,7,13,21,31]
06:41:05 <Zeiris> Write a little bit of Haskell, and you'll find yourself wishing other languages had pattern matching/haskell's type system while writing code in C/Python/whatever.
06:41:40 <onats_> ok ok.. will try it.
06:41:46 <Cale> > map (\x -> (x,x^2+x+1)) [-5..5]
06:41:47 <onats_> any good beginner tutorials you guys have?
06:41:47 <lambdabot>   [(-5,21),(-4,13),(-3,7),(-2,3),(-1,1),(0,1),(1,3),(2,7),(3,13),(4,21),(5,31)]
06:41:53 <onats_> just to appreciate it, i need to try it
06:42:03 <Cale> Maybe try lyah
06:42:06 <Cale> @where lyah
06:42:06 <lambdabot> www.learnyouahaskell.com
06:42:16 <Cale> There's also...
06:42:19 <Cale> @where rwh
06:42:20 <lambdabot> is http://www.realworldhaskell.org/blog/
06:42:23 <Cale> @where wikibook
06:42:24 <lambdabot> http://en.wikibooks.org/wiki/Haskell
06:42:57 <onats_> got it.
06:42:59 <Axman6> > [1..] -- infinite lists aren't too easy in java
06:43:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:43:01 <soupdragon> www.learnyouahaskell.com
06:43:04 <Cale> onats_: And don't be afraid to ask questions :)
06:43:06 <soupdragon> yeah!!
06:43:10 <onats_> thanks. ill be back after I try it
06:43:12 <onats_> heheh
06:43:14 <blackh> onats_: Some of the astounding things about Haskell are apparent early on, but some of them take a while to discover.
06:43:26 <Axman6> onats_: don't go, stick around and ask questions ;)
06:43:27 <onats_> Cale, thanks!:D
06:43:31 <Cale> Haskell's type system is really amazingly good
06:43:50 <onats_> Axman6, I have to try it first. otherwise i wont have questions to ask!
06:43:56 <Philonous> Functional Programming makes (some) design patterns explicit. You can for example map a functionover all structurs that support it via fmap. That in turn allows you to think about data structurs that can be mapped over in general rather than which steps you need to take for a linked list, a tree or whatever.
06:43:57 <Cale> It cut the amount of time I spent debugging to about maybe 1/10 of what it was.
06:44:22 <Cale> Yeah, things like the visitor pattern become library functions ;)
06:45:02 <Cale> As they should be. Design patterns which you can't turn into values in some library indicate deficiencies in the language.
06:45:05 <Axman6> Cale: how's the visitor pattern map to haskell?
06:45:14 * onats_ parking here in #haskell
06:46:26 <Cale> Axman6: well, I lied slightly, it's a few functions depending on what you need, but Data.Traversable gives the main bit :)
06:46:45 <Cale> Obviously if all you need is fmap, you use fmap :)
06:46:55 <Axman6> righto :)
06:46:56 <Cale> (or Foldable)
06:47:05 <blackh> Cale, Axman6: And don't forget the factory pattern, or should I say, partial function application. :)
06:47:31 <Axman6> i haven't encountered the factory pattern actually
06:48:26 * mornfall checks what factory is with c2
06:48:28 <blackh> Well, it's where you have an object that (usually) takes some extra parameters and makes a new object based on its own state and that of the parameters.  It's the same as partial function application, only much more typing.
06:50:23 <mornfall> blackh: Well, sort of. I believe part of the factory point is to make the class selection runtime.
06:50:52 <mornfall> Partial application is a plain structure.
06:51:07 <Cale> Or alternately, the ability to produce a function as the result of another function.
06:51:20 <Cale> (perhaps that's closer to the mark)
06:52:06 <blackh> It depends on what your definition of "is" is.
06:52:24 <mornfall> Factory is a clear manifestation of the Fear of Recompilation. :)
06:53:06 <Cale> mornfall: hmm...
06:53:31 <Cale> mornfall: maybe to some extent, but I don't think that's all
06:53:45 <twanvl> mornfall: I believe factory is also a workaround for the lack of named constructors
06:53:49 <Axman6> blackh: ah i see, interesting idea
06:53:58 <mornfall> twanvl: Could be. Dunno.
06:54:42 <blackh> Axman6: I use factory pattern a lot - even more now that I write my C++ code as much like Haskell as I can.
06:54:59 <Axman6> heh
06:55:15 <mornfall> Interesting.
06:55:24 <Cale> In the nontrivial version of Factory, your factory object takes some parameters and conditionally gives you an object of one of a number of classes, constructed appropriately from your input parameters.
06:57:22 <blackh> Cale: I usually use it for things like the ability to switch between a real serial port or a fake test serial port depending on which subclass of PortFactory I'm using.
06:57:44 <blackh> Enough OO already. :)
07:00:08 <mornfall> Using OO languages is a pita. (Fortunately, C++ is not really an OO language.)
07:01:19 <Phillemann> If I ignore all exceptions in a thread, can you kill this thread then?
07:01:51 <Cale> blackh: Actually, for that case, the sane translation to FP would be to pass a record corresponding to the functions acting on the serial port.
07:06:18 <blackh> Cale: I really love writing code in that style.
07:07:27 <blackh> A record of functions seems to be a very powerful way of doing things for many problems.
07:09:02 <Cale> blackh: In a sense, it's the FP way to do object oriented programming.
07:09:21 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
07:12:36 <Rotaerk> mornfall, there's no such thing as "an OO language"; languages can just provide varying amounts of support for mechanisms that allow for OO.
07:12:57 <Rotaerk> while C++ doesn't provide as much as C#, it does have OO mechanisms...
07:13:08 <Rotaerk> in any case, none of this makes C++ *not* a PITA
07:13:26 <mornfall> Rotaerk: The difference is that C++ supports other things than OO. :)
07:13:41 <Rotaerk> so does C#
07:13:56 <mornfall> To a much lesser extent.
07:14:30 <Rotaerk> the key distinction between C# and a functional language isn't a OO vs FP dichotomy but a procedural and functional dichotomy
07:15:32 <onats_> anyone here part of the haskell originators?
07:15:39 <Rotaerk> (although C# does support FP to an extent)
07:15:48 <blackh> Cale: That's true (FP way to do OOP) - interesting post - thanks.  A record of functions is similar to OO, but I don't see that as being a bad thing.
07:16:26 <Cale> When it's the right idea, it's the right idea. :)
07:17:43 <dino-> I'm wondering, should I be using the time API from Hackage instead of the 1.1.3 that ships with the GHC?
07:18:52 <Rotaerk> OO is better compared to pattern matching and discriminated unions
07:19:03 <Rotaerk> which are both theoretically possible in a procedural, nonfunctional language
07:19:17 <Rotaerk> since it's the "other side" of the expression problem
07:19:35 <mornfall> dino-: What does The Platform come with?
07:19:46 <blackh> onats_: Originators of Haskell are seen on this channel from time to time.
07:20:14 <dino-> mornfall: Not sure. I use Arch and so installed everything through that.
07:21:23 <dino-> mornfall: mm, I see it uses an even older haskell-time than is in the ghc.
07:21:57 <dino-> 1.1.2.4 vs 1.1.3 (that 'ships' in the GHC package)
07:22:49 <Axman6> onats_: it's a pretty old language, if you hadn't picked that up (something like 20 years old)
07:23:23 <dino-> AAUI cabal will pick the latest version of something you have if you're not explicit in the .cabal file. So probably will do me no harm to just install time 1.1.2.4
07:24:11 <dcoutts_> dino-: you probably want to use 1.1.2.4 rather than 1.1.3
07:24:28 <dino-> dcoutts_: But 1.1.3 is in 6.10.3
07:24:41 <dino-> dcoutts_: Are you saying I should change my .cabal files to force 1.1.2.4?
07:25:37 <dcoutts_> dino-: yeah, releasing 1.1.3 was a mistake imho
07:25:49 <dcoutts_> dino-: if it works with time-1.1.3 then there's no problem
07:26:02 <dcoutts_> but it does have some incompatible changes
07:26:18 <dino-> dcoutts_: Huh, what happened? API alterations that break things?
07:26:25 <dino-> Or bugs
07:28:35 <dcoutts_> dino-: API changes, like new class instances
07:28:49 <dcoutts_> also, it was a random dev snapshot, never intended for release
07:29:11 <dino-> dcoutts_: mm, I see. Thanks for helping. I know what to do now.
07:45:33 <Ytinasni> hah!
07:45:56 <Ytinasni> it took me over a year, but i finally figured out how to use `ap`
07:47:06 <copumpkin> nice!
07:50:29 <pastah> Ytinasni: care to spill the beans?
07:52:06 <Ytinasni> using parsec, i have a parser "digit >> continue", and i need to turn the whole thing into a string
07:52:13 <lilac> > [(+1), (*2)] `ap` [1,2,3,4]
07:52:15 <lambdabot>   [2,3,4,5,2,4,6,8]
07:52:24 <Ytinasni> so "fmap (:) digit `ap` continue"
07:52:38 <LeoD> ap is like <*> right? i've never had any use for it, as there's liftM for most numbers of parameters
07:52:46 <Cale> liftM2 (:) digit continue
07:53:01 <lilac> LeoD: <*> = ap for the Applicative you can derive from the Monad
07:53:02 <Ytinasni> @type <*>
07:53:04 <lambdabot> parse error on input `<*>'
07:53:08 <Ytinasni> @type (<*>)
07:53:09 <LeoD> lilac: yea
07:53:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:53:15 <dino-> LeoD: I've had situations where I want to construct a data type with > 3 args to the constructor in a monadic setting..
07:53:20 <pikhq> @src (<*>)
07:53:20 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:53:40 <lilac> pikhq: (<*>) is a class method on Applicative
07:53:46 <pikhq> lilac: Right.
07:53:49 <dino-> So it's helpful instead of writing a liftM8
07:53:53 <LeoD> dino-: hm, yea you need ap then
07:53:58 <LeoD> right
07:54:00 <pikhq> I just got up and am drinking coffee right now.
07:54:27 <Ytinasni> huh... if you have liftM2, why would you use ap?
07:54:27 <pikhq> @src ap
07:54:27 <lambdabot> ap = liftM2 id
07:54:31 <Badger> @src Applicative
07:54:31 <lambdabot> class Functor f => Applicative f where
07:54:32 <lambdabot>     pure  :: a -> f a
07:54:32 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
07:54:38 <Axman6> i just got how the whole f <$> x <*> y thing actually works
07:54:42 <pikhq> Oh, right. The S combinator.
07:54:43 <pikhq> :D
07:54:44 <dino-> Or all that icky <- stuff 8 times and barely-utilized binds
07:55:18 <lilac> pikhq: the S combinator for the (->) a Monad
07:55:41 <pikhq> Well, yes. It's a generalisation of the S combinator to the monads. :P
07:56:32 <pastah> brain-splode
07:56:54 <pastah> isn't there a good paper or something where i can read on how applicative works?
07:57:18 <pastah> i remember some kids in school ranting about it a while back
07:57:30 <doserj> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html has a link at the top
07:58:01 <pastah> doserj: cool, thanks :)
07:58:12 <Nebasuke> I found the typeclassopedia article very good
07:58:31 <Nebasuke> it's in the monad reader 13
07:58:41 <BONUS> shameless self-promotion, but what the heck: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
07:58:57 <pikhq> BONUS: Appropriate, at least.
07:59:12 <Badger> BONUS: !
07:59:29 <Badger> I was just wondering where the devil to start looking at this stuff :P
07:59:37 <BONUS> haha
08:00:53 <Badger> BONUS: er... do you draw all these things?
08:01:29 <BONUS> yup :]
08:01:39 <Badger> heh, jolly good
08:01:41 <pastah> BONUS: you're my hero
08:01:41 <desp> BONUS: this is cool.
08:01:44 <BONUS> hehe
08:02:56 <Badger> @src Functor
08:02:56 <lambdabot> class  Functor f  where
08:02:57 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:02:59 <pastah> BONUS: highlighting and stuff looks really nice on the page, what tool did you use to create it?
08:03:25 <BONUS> the SyntaxHighlighter js library along with some of my own styles for it
08:03:43 <pastah> cool :)
08:03:56 <Ferdirand> ls
08:03:58 <Ferdirand> oops
08:04:12 <Axman6> ..
08:04:28 <BONUS> :r also doesn't work here :]
08:12:38 <SamB> @hoogle unsafePerformIO
08:12:39 <lambdabot> Foreign unsafePerformIO :: IO a -> a
08:12:39 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
08:12:50 <SamB> :l System.IO.Unsafe
08:13:55 <SamB> > unsafePerformIO (readFile "/etc/passwd")
08:13:56 <lambdabot>   Not in scope: `unsafePerformIO'
08:14:28 <Badger> somehow I imagine they thought of that when making lambdabot :P
08:15:15 <Axman6> > System.IO.Unsafe.unsafePerformIO (return ())
08:15:18 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
08:30:32 <Phillemann> I don't understand why ghc complains about the statement "loop `catch` (\_ -> loop)" (Ambiguous type variable `e' in the constraint: `GHC.Exception.Exception e')
08:31:30 <BONUS> just do (\(e :: SomeException) -> loop)
08:31:34 <Badger> @hoogle TVar
08:31:35 <lambdabot> module Control.Concurrent.STM.TVar
08:31:44 <BONUS> or give that lambda an explicit type sig
08:33:16 <Phillemann> BONUS: Well, okay. Thanks
08:34:07 <Ytinasni> it's because `catch` catches only one type of exception, and GHC can't decide which one you meant.
08:34:12 <soupdragon> doesn't  loop `catch` const loop  typecheck?
08:34:23 * lilac just realised that the functor laws can be restated as: fmap and id form a monoid
08:35:17 <Ytinasni> @type loop `catch` const loop
08:35:19 <lambdabot>     Couldn't match expected type `IO a'
08:35:19 <lambdabot>            against inferred type `a1 (b, d) (c, d) -> a1 b c'
08:35:19 <lambdabot>     In the first argument of `catch', namely `loop'
08:35:34 <Ytinasni> @type \loop -> loop `catch` const loop
08:35:36 <lambdabot> forall a. IO a -> IO a
08:36:31 <Ytinasni> @type \loop -> loop `Control.Exception.catch` const loop
08:36:33 <lambdabot>     Ambiguous type variable `e' in the constraint:
08:36:33 <lambdabot>       `GHC.Exception.Exception e'
08:36:33 <lambdabot>         arising from a use of `Control.Exception.Base.catch'
08:36:34 <lilac> fmap (a.b) c == (a `fmap` b) `fmap` c == a `fmap` (b `fmap` c) == fmap a (fmap b) c == fmap a . fmap b $ c
08:36:41 <soupdragon> Control.BrokenException.catch
08:36:44 <BONUS> lilac: pretty cool. much like how >=> and return have to form a monoid for the monad laws to work
08:36:58 <lilac> BONUS: indeed.
08:37:02 <lilac> @quote lilac Kleisli
08:37:03 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
08:37:03 <lambdabot> read
08:37:08 <BONUS> haha
08:37:21 <lilac> i'm trying to come up with a Functor laws haiku
08:37:40 <BONUS> but how do fmap and id form a monoid
08:37:44 <lilac> but i have the wrong number of syllables and it's not flowing right :(
08:37:48 <doserj> lilac: these are different fmaps, though
08:37:59 <lilac> doserj: that's all part of the fun :)
08:38:01 <BONUS> with >=> it's cool because both of its arguments are kleisli functions
08:38:20 <lilac> it's not /really/ a monoid because it's not closed in any meaningful way
08:38:37 <SamB> lilac: say what?
08:38:44 <lilac> but all well-typed expressions follow the monoid laws
08:38:53 <SamB> lilac: I don't see how that makes it not a monoid
08:39:30 <lilac> SamB: given f :: a -> b, x :: [a], f `fmap` x is defined but x `fmap` f is not
08:39:52 <SamB> oh, that Functor one
08:40:15 <lilac> yeah. it's a monoid if you restrict it to functions, but that's nowhere near as interesting
08:40:24 <lilac> (since that's just saying id and (.) form a monoid)
08:40:30 <nominolo> anyone know what the "meaning" of a type is?  I mean, formally.  Typically type systems are described by their instance-relation, but I wonder whether there is something more intuitive.
08:40:46 <BONUS> a type is a set of values imo
08:40:54 <lilac> i believe that's the extensional view
08:41:24 <BONUS> say what
08:41:30 <nominolo> BONUS: Hm, but what is a value in, say, System F?
08:41:41 <nominolo> a lambda-term or a system-F term?
08:41:55 <BONUS> hmm i couldn't say
08:42:11 <Saizan_> a set has probably too much structure
08:43:12 <Vanadium> Why is (return $! x) not the same as (return $! x) >>= return? Do the monad laws not imply that it should be?
08:44:19 <lilac> Saizan_: i'd guess a class has too little structure :)
08:44:26 <Saizan_> m >>= return  ==  m
08:44:33 <conal> nominolo: for me, the meaning of a type is the collection of its elements.  that's why i'm uncomfortable with os :: String
08:44:47 <Saizan_> so yes, but you need to choose what == means there :)
08:44:52 <conal> nominolo: as i was getting at in http://conal.net/blog/posts/notions-of-purity-in-haskell/
08:44:54 <lilac> Vanadium: sounds like a broken Monad instance to me
08:45:07 <jad4> guys I haven't used haskell in a while
08:45:15 <jad4> what is wrong with this type signature??
08:45:17 <jad4> G     :: a -> ((a,a)->a)->a
08:45:29 <conal> though maybe not "set".  i think john reynolds showed that the polymorphic lambda calculus semantics isn't set-theoretic.
08:45:34 <nominolo> conal: right, I'm stuck at what the elements are, though, in the particular system I'm implementing. ;)
08:45:35 <Vanadium> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Aevaluate is confusing me
08:45:44 <Raevel> @djinn a -> ((a,a)->a)->a
08:45:45 <lambdabot> f a b = b (a, a)
08:45:45 <mornfall> jad4: Nothing, really... why?
08:45:47 <dcoutts_> conal: right
08:45:48 <mauke> jad4: G is a constructor
08:45:50 <jad4> oh
08:45:50 <Saizan_> jad4: if G is a function you're defining then it must be lowercase
08:45:51 <jad4> damn
08:45:51 <jad4> yes
08:45:57 <soupdragon> jad4, in isolation nothing
08:46:02 <jad4> the uppercase thing
08:46:05 <jad4> nevermind guys
08:46:06 <mornfall> : - )
08:46:10 <jad4> forgot about that
08:46:11 <jad4> eh
08:46:22 <nominolo> conal: my particular interest is in veryfying a type-checker's soundness via quickcheck
08:46:32 <jad4> that's what happens when you start doing to many functional programming on paper :S
08:46:39 <dcoutts_> conal: there's a bunch of other models, PERs, frame models and CPOs
08:46:51 <soupdragon> nominolo: (that's theoretically impossible?)
08:47:33 <nominolo> soupdragon: well, I'm not trying to verify completeness just (approximate) soundness
08:47:52 <soupdragon> like a unit test?
08:47:55 <lilac> @type let g x f = let r = f (x,r) in r
08:47:57 <lambdabot> on the commandline:
08:47:57 <lambdabot>     Warning: -fno-th is deprecated: use -XNoTemplateHaskell or pragma {-# LANGUAGE NoTemplateHaskell#-} instead
08:47:57 <lambdabot> <no location info>:
08:47:58 <tibbe> anyone have a compact way to write a function that maps over every other element (one pass)?
08:48:01 <nominolo> soupdragon: exactly
08:48:08 <lilac> @type let g x f = let r = f (x,r) in r in g
08:48:10 <lambdabot> forall t t1. t -> ((t, t1) -> t1) -> t1
08:48:37 <nominolo> soupdragon: just to gain some confidence in my implementation
08:49:38 <soupdragon> what have you implemented exactly?
08:50:00 <pikhq> tibbe: map
08:50:13 <nominolo> the system allows a canonical instance derivation, so I can do this, but it's still quite complex.  So there's room for something less accurate, but simpler
08:50:18 <tibbe> pikhq: huh?
08:50:37 <pikhq> > map (+1) [1..]
08:50:39 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
08:50:42 <nominolo> soupdragon: this: http://gallium.inria.fr/~yakobows/research.html#mlfc
08:50:47 <koala_man> pikhq: every other element
08:51:04 <pikhq> Oh, every other.
08:51:06 <dcoutts_> tibbe: your question was not very clear, imho
08:51:15 <tibbe> dcoutts_: oh sorry
08:51:21 <Philonous> What should happen with the rest? Get discarded or stay unmodified?
08:51:22 * dcoutts_ doesn't know what tibbe was getting at
08:51:39 <vegai> hey... what possible reasons could there be for a long-running haskell application to suddendly die?
08:51:51 <tibbe> dcoutts_: I guess what I meant was a combination of filter and map
08:51:51 <dcoutts_> vegai: ctl-C ? :-)
08:51:53 <vegai> I know this is a rather open question... but
08:51:53 <Saizan_> zipWith id (cycle [f,id])?
08:51:56 <vegai> dcoutts_: heh
08:52:06 <tibbe> dcoutts_: so resulting list is smaller than the input
08:52:09 <vegai> dcoutts_: I have handlers for all signals installed
08:52:18 <tibbe> dcoutts_: I went and wrote it from scratch
08:52:29 <nominolo> Saizan_: probably zipWith ($) ..
08:52:52 <Saizan_> nominolo: not that they are different..
08:53:02 <dcoutts_> tibbe: oh, you mean odd/even index elements?
08:53:09 <pikhq> > map (+1) $ filter (\(x,_) -> even x) $ zip [1..] [1..]
08:53:12 <tibbe> dcoutts_: yes
08:53:12 <lambdabot>   No instance for (GHC.Num.Num (t, t1))
08:53:13 <lambdabot>    arising from the literal `1' at <i...
08:53:28 <pikhq> Curses. Un momento.
08:53:33 <tibbe> pikhq: I guess zipping works
08:53:52 <nominolo> > zipWith ($) (cycle [(+1),id]) [1..20]
08:53:55 <lambdabot>   [2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20]
08:54:07 <pikhq> > map (\(_,y) -> y+1) $ filter (\(x,_) -> even x) $ zip [1..] [1..] -- There's a cleaner way, but that at least works
08:54:09 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
08:54:09 <nominolo> > zipWith id (cycle [(+1),id]) [1..20]
08:54:12 <lambdabot>   [2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20]
08:54:24 <dcoutts_> tibbe: I expect a direct recursive implementation will be clearest, even though it's possible as a foldr
08:54:31 <Saizan_> > let f = (+1); xs = [1..20]; in [ f x | (True,x) <- zip (cycle [False,True]) xs]
08:54:33 <lambdabot>   [3,5,7,9,11,13,15,17,19,21]
08:55:54 <pikhq> > let mapOther f [] = [];mapOther f (x:y:xs) = f x:mapOther xs in mapOther (+1) [1..]
08:55:55 <lambdabot>   Couldn't match expected type `[t]' against inferred type `t -> a'
08:56:07 * pikhq can has fail
08:56:09 <Cale> List comprehension + zip
08:56:16 <Cale> would be the way I'd do it.
08:56:23 <pikhq> There's many ways to do it. Anyways.
08:56:48 <Cale> > [x | (n,x) <- [0..] "hello there", even n]
08:56:49 <lambdabot>   Couldn't match expected type `t1 -> [t]'
08:56:56 <Cale> > [x | (n,x) <- zip [0..] "hello there", even n]
08:56:57 <lambdabot>   "hlotee"
08:57:03 <tibbe> dcoutts_: yes
08:57:06 <pikhq> Cale: Much nicer way of writing it.
08:57:10 <tibbe> dcoutts_: here's what I wrote (needed a monadic one)
08:57:28 <tibbe> mapEveryM_ :: Monad m => (a -> m b) -> Int -> [a] -> m ()
08:57:28 <tibbe> mapEveryM_ f n0 = go 0
08:57:28 <tibbe>     where
08:57:28 <tibbe>       go _ []     = return ()
08:57:29 <tibbe>       go 0 (x:xs) = f x >> go (n0 - 1) xs
08:57:29 <tibbe>       go n xs     = go (n - 1) xs
08:57:49 <tibbe> n0 >= 1
08:58:20 <tibbe> Cale's one is beautiful though, together with sequence, I wonder if it's equally efficient
08:58:25 <tibbe> (it's part of a benchmark)
08:58:39 <Saizan_> however, why not have a function that gets you only the nth elements and then compose it with mapM_ ?
08:59:18 <Cale> tibbe: hmm... possibly depends on how you do it too -- do you need the generality of taking every nth one? There are two ways to handle that.
08:59:50 <Gracenotes> I do like the idea of using recursion deconstructing two at a time though..
08:59:51 <tibbe> Cale: I need every second one actually, I have an array of pipes so there are read and write ends and I only want the write ends
09:00:04 <tibbe> Gracenotes: yes
09:00:12 <tibbe> Gracenotes: mine is perhaps too general
09:00:14 <Gracenotes> something not possible with the list combinators in Data.List
09:00:26 <Cale> tibbe: hmm, how did they all end up in the same array?
09:00:36 <Gracenotes> at least without extra info ^_^
09:00:37 <Cale> > [x | (b,x) <- zip (cycle [True,False]) "hello there", b]
09:00:37 <tibbe> Cale: long story ;)
09:00:39 <lambdabot>   "hlotee"
09:00:45 <Cale> is another way to do it
09:01:10 <tibbe> Cale: I put them there intentionally to mimic the C benchmark I'm trying to port
09:01:12 <Cale> It also generalises to more arbitrary patterns and avoids division in favour of following around list structure
09:01:15 <Gracenotes> yes, it removes the extra information
09:01:26 <Gracenotes> although not all...
09:01:45 <Cale> (but I don't know, maybe even compiles to something super-efficient for Ints)
09:01:56 <doserj> > [x | (True,x) <- zip (cycle [True,False]) "hello there"]
09:01:57 <lambdabot>   "hlotee"
09:02:09 <Cale> or indeed, you can do that :)
09:02:36 <desp> @hoogle (Monad m) => Int -> (Int -> m a) -> m ()
09:02:38 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
09:02:38 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
09:02:38 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
09:02:43 <Cale> It would be interesting to know how the variations perform.
09:02:44 * Gracenotes is not sure much can beat a hand-crafted function
09:02:47 <doserj> not really shorter in character count, though :)
09:04:43 <Cale> Yeah, if you were going to hand-code something via direct recursion, I would go with  everyOther [] = []; everyOther [x] = [x]; everyOther (x:y:xs) = x : everyOther xs
09:04:47 <Cale> and then use sequence
09:06:15 <Cale> Of course, you could wire-in the sequence by hand too... I somehow doubt it would be significantly better.
09:06:22 <Cale> (but it's possible)
09:08:08 <rfgpfeiffer> @djinn a -> []
09:08:09 <lambdabot> Cannot parse command
09:08:25 <SamB> Cale: someone on the internet still seems wrong!
09:08:28 <SamB> can you help?
09:08:55 <tibbe> haskell could use a better array library :/
09:08:57 <rfgpfeiffer> @djinn a -> a
09:08:58 <lambdabot> f a = a
09:09:01 <Rotaerk> > drop 5 [1,3,3]
09:09:03 <lambdabot>   []
09:09:19 <SamB> Cale: http://knol.google.com/k/kazuhiko-kotani/an-objection-to-cantors-diagonal/1ibusyvuup78g/2#comment-1ibusyvuup78g.gijszg
09:09:20 <rfgpfeiffer> @djinn []
09:09:20 <lambdabot> Cannot parse command
09:09:30 <SamB> @djinn [a]
09:09:31 <lambdabot> Error: Undefined type []
09:09:39 <SamB> that's better ;-)
09:10:34 <Badger> @djinn a -> b -> c
09:10:34 <lambdabot> -- f cannot be realized.
09:10:48 <pikhq> @djinn a -> [a]
09:10:49 <lambdabot> Error: Undefined type []
09:11:16 <pikhq> @djinn (Monad m) => a -> m a
09:11:16 <lambdabot> f = return
09:11:24 <pikhq> Smrt.
09:11:54 <LeoD> huh, last time i tried djinn didn't know Monad
09:12:28 <SamB> LeoD: yeah, but you could get it to give you monadic stuff
09:12:48 <SamB> if you just fudged and stuck the methods in the type signature directly
09:12:54 <leimy_> > take 0 [1..10]
09:12:56 <lambdabot>   []
09:12:57 <LeoD> ah
09:13:15 <leimy_> > take 1 $ take 0 [1..10]
09:13:17 <lambdabot>   []
09:13:27 <SamB> LeoD: so I guess someone more-or-less automated the fudgery ;-)
09:13:36 <LeoD> nice :)
09:13:48 <Deewiant> ?djinn-add class Functor f where fmap :: (a -> b) -> (f a -> f b) -- This is how it was presumably added
09:13:49 <lambdabot> Cannot parse command
09:13:56 <Deewiant> ?djinn-add class Functor f where fmap :: (a -> b) -> (f a -> f b)
09:14:01 <Deewiant> Now it has Functor, too.
09:14:06 <LeoD> sweet
09:14:07 <SamB> which is indeed very nice
09:14:24 <ManateeLazyCat> Have a exist function equal "foo (a,b) = (b,a)" ?
09:14:29 <Deewiant> Use ?djinn-env in query (not here, it's too long) to see what it knows
09:14:34 <BONUS> @djinn a -> f b -> f a
09:14:35 <lambdabot> -- f cannot be realized.
09:14:42 <SamB> because it saves you a lot of work in (a) sticking all those methods in the typesig and (b) renaming them back to the method names
09:14:44 <BONUS> @djinn Functor f => a -> f b -> f a
09:14:45 <lambdabot> -- f cannot be realized.
09:15:00 <ManateeLazyCat> @hoogle (a,b) -> (b,a)
09:15:01 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
09:15:02 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
09:15:02 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
09:15:12 <Deewiant> ManateeLazyCat: Not in the standard libraries, no.
09:15:12 <SamB> BONUS: odd!
09:15:19 <ManateeLazyCat> @hoogle "(a,b) -> (b,a)"
09:15:20 <lambdabot> Parse error:
09:15:20 <lambdabot>   --count=20 ""(a,b) -> (b,a)""
09:15:20 <lambdabot>              ^
09:15:26 <BONUS> :t fmap . const
09:15:30 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f a1
09:15:31 <ManateeLazyCat> Deewiant: Thanks, i see.
09:15:44 <SamB> BONUS: just what I was thinking ;-)
09:15:50 <SamB> why can't djinn do that?
09:15:52 <BONUS> hehe
09:16:11 <Deewiant> ?djinn Monad m => a -> m b -> m a
09:16:12 <lambdabot> f a _ = return a
09:16:15 <Deewiant> :-P
09:16:15 * SamB has an urge to formalize djinn in Coq
09:16:21 * SamB attempts to resist it
09:16:39 <pikhq> @pl (\(x,y) -> (y,x))
09:16:39 <lambdabot> uncurry (flip (,))
09:16:42 <desp> How do I apply a ReadS?
09:16:49 <pikhq> Thought so.
09:16:51 <SamB> @src ReadS
09:16:52 <lambdabot> Source not found. Just try something else.
09:17:01 <desp> @hoogle readInt
09:17:02 <lambdabot> Numeric readInt :: Num a => a -> Char -> Bool -> Char -> Int -> ReadS a
09:17:02 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
09:17:03 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
09:17:05 <Deewiant> ?hoogle ReadS
09:17:05 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
09:17:07 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
09:17:07 <SamB> @version
09:17:09 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
09:17:11 <lambdabot> lambdabot 4.2.2
09:17:13 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:17:20 <Deewiant> desp: Apply it to a String, appparently.
09:17:30 <LeoD> @djinn [a] -> (a -> [b]) -> [b]
09:17:30 <lambdabot> Error: Undefined type []
09:17:47 <Deewiant> djinn can't do recursive types.
09:18:00 <LeoD> i see
09:18:12 <SamB> Deewiant: do you recall what the issue is?
09:18:34 <Deewiant> No, I'm not sure I even know it. :-)
09:18:54 <Deewiant> I'm not familiar with the internals of djinn
09:20:16 * Baughn wonders when ghc 6.10.4 will hit arch
09:22:05 <kynky> Baughn, modify the 6.10.3 one?
09:22:37 <Baughn> kynky: I'm using extra/ghc, not aur/ghc (assuming the latter exists)
09:22:53 <Baughn> Well, it's no big deal. I know /exactly/ what the bug fixes in 10.4 are for, and they don't affect me right now. :P
09:24:36 <kynky> you can still get the pkgbuild in extra, but as you say you dont need it :)
09:27:37 <LeoD> @djinn (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)
09:27:37 <lambdabot> f a b c =
09:27:38 <lambdabot>     case a c of
09:27:38 <lambdabot>     (d, e) -> b d e
09:28:58 <pastah> LeoD: GO STATE :)
09:29:13 <EvilTerran> f a b c = uncurry b (a c) -- LeoD
09:29:55 <EvilTerran> ?type \a b c -> uncurry b (a c)
09:29:57 <lambdabot> forall t a b c. (t -> (a, b)) -> (a -> b -> c) -> t -> c
09:30:32 <LeoD> oh wow
09:30:34 <EvilTerran> ?type (\a b c -> uncurry b (a c)) :: (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)
09:30:36 <lambdabot> forall s a b. (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s)
09:30:52 <EvilTerran> (just to save having to work out if those types matched in my head :P)
09:34:05 <CalJohn> Is there any way to have ghci chase dependencies like "ghc --make" does?
09:34:21 <Baughn> CalJohn: It does that by default. What's the issue?
09:34:42 <Deewiant> Having :l chase dependencies would be nice
09:34:48 <CalJohn> oh, does it?  the emacs mode's C-l doesn't
09:35:09 <CalJohn> which is basically ":l $CURRENTFILE"
09:35:26 <Berengal> It does on my box...
09:35:34 <Baughn> It does
09:35:48 <Baughn> :l Network/Hermes/UDP.hs just loaded two dependencies for me
09:36:54 <CalJohn> Baughn, Berengal: are you dependenies in the standard libraries or something?  I'm watching ghci to load "./foo.hs"
09:37:26 <Baughn> Seeing the exact error would help
09:37:42 <CalJohn> Could not find module `Primes':
09:38:02 <CalJohn> i'll just paste it to hpaste.org
09:38:57 <Baughn> CalJohn: Is there a Primes.(l)hs in ghci's current working directory?
09:39:46 <Baughn> CalJohn: If you load Foo.hs from Bar/Foo.hs, ghci won't look up Foo's dependencies inside Bar (unless they happen to have Bar.X for a module name)
09:39:50 <CalJohn> Baughn: ah, I think I am assuming ghci's working directory to be somewhere it is not
09:40:52 <Berengal> (setq inferior-haskell-find-project-root nil)
09:40:57 <Berengal> CalJohn: ^^
09:42:02 <Berengal> Put it in .emacs and you can at least :cd inside ghci inside emacs
09:42:20 <Berengal> (Unless they've fixed that in a newer version of haskell-mode
09:48:17 <Vanadium> How does catch figure out whether the exception flying by is one that is handled by its handler parameter?
09:49:02 <Berengal> typeclass magic
09:49:11 <BONUS> it has to do with typeable and existentials and lots of wrappers
09:49:26 <Vanadium> Okay :C
09:49:39 <BONUS> there's a good paper on it though let me fetch it
09:50:45 <Vanadium> I am already intimidated
09:50:54 <Baughn> Vanadium: All exceptions are instances of Exception. Exception requires a Typeable instance. Therefore (logically speaking) it can use typeOf on it to check
09:51:15 <Baughn> ..but I'm not sure that's what it actually does
09:52:04 <hzap> do people usually use try or catch?
09:52:19 <Vanadium> I am just reading through the error handling chapter of real world haskell and rather confused
09:53:27 <Cale> Vanadium: The Typeable class (and by extension, the Exception class), makes information available at runtime about what type the value is.
09:54:11 <axzs> is 'let x = y in z' always the same as '(\x -> z) y'?
09:54:29 <Cale> Vanadium: An existential type called SomeException is used to "forget" the exact type of exception, but that information is preserved by the instance of Exception (and its superclass, Exception)
09:54:30 <Cale> er
09:54:31 <Baughn> hzap: Whatever fits, really
09:54:37 <Vanadium> All right. :3
09:54:38 <Cale> (and its superclass, Typeable)
09:54:41 <iago> axzs: if the let is no recursive I think yes
09:54:57 <Vanadium> I suppose I am still confused by C++ exceptions where you can throw any old value
09:55:17 <axzs> thanks
09:55:17 <Cale> axzs: almost -- the typing rule is a little different.
09:55:23 <Cale> axzs: and yeah, let allows you to make recursive definitions
09:55:36 <axzs> what is the typing rule?
09:55:44 <Baughn> Vanadium: You pretty much can in Haskell as well. Both Typeable and Exception can be derived, though the latter only through an empty instance delcaration
09:56:17 <iago> I though recursiveness is detected and a distinction is made between let and letrec
09:56:30 <Baughn> ..are there any Exception instances that actually redefine the to/fromException methods?
09:57:07 <Cale> axzs: Definitions inside let are allowed to be polymorphic -- any type variables which are still free after the type is inferred get generalised. Lambda-bound variables must be used at just one type in the body of the lambda (even if the lambda as a whole ends up being polymorphic
09:57:08 <Cale> )
09:57:26 <doserj> > let x = id in (x 1, x "a")
09:57:28 <lambdabot>   (1,"a")
09:57:32 <doserj> > \x -> (x 1, x "a") $ id
09:57:32 <Cale> > (\f -> (f [1,2,3], f "hello")) length
09:57:36 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
09:57:37 <lambdabot>    arising from the literal `1...
09:57:37 <lambdabot>   Couldn't match expected type `a -> b'
09:57:46 <Cale> > let f = length in (f [1,2,3], f "hello"))
09:57:48 <lambdabot>   <no location info>: parse error on input `)'
09:57:50 <Cale> > let f = length in (f [1,2,3], f "hello")
09:57:52 <lambdabot>   (3,5)
09:58:06 <Cale> f is allowed to be polymorphic in the version with let
09:58:14 <Vanadium> "deriving Typeable" implies that something magical happens to make my type a Typeable?
09:58:32 <Cale> Vanadium: somewhat magical, not *too* magical
09:58:58 <doserj> > (\x -> (x 1, x "a")) id -- actually...
09:59:00 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
09:59:00 <lambdabot>    arising from the literal ...
09:59:26 <Cale> Vanadium: Basically, the Typeable typeclass has a function called typeOf :: (Typeable a) => a -> TypeRep
09:59:47 <axzs> I understand. Would rank-2-types change the situation?
09:59:48 <Cale> Vanadium: Where TypeRep is a representation of a type
10:00:09 <Cale> axzs: yeah, but you have to give explicit type signatures to use those
10:00:31 <axzs> thanks
10:00:38 <doserj> > (\(x::forall a.a->a) -> (x 1, x "a")) id
10:00:40 <lambdabot>   (1,"a")
10:00:56 <Cale> > ((\f -> (f [1,2,3], f "hello")) :: (forall a. [a] -> Integer) -> (Integer, Integer)) length
10:00:57 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
10:01:12 <Cale> er, oh :)
10:01:17 <Cale> > ((\f -> (f [1,2,3], f "hello")) :: (forall a. [a] -> Int) -> (Int, Int)) length
10:01:19 <lambdabot>   (3,5)
10:01:31 <gio123> Cale: hi
10:01:36 <Cale> gio123: hello
10:01:39 <axzs> Thanks! Very interesting
10:01:47 <gio123> Cale: pm?
10:01:51 <Cale> okay
10:02:41 <Vanadium> > typeOf 42
10:02:43 <lambdabot>   Integer
10:02:48 <deech> Hi all, can one datatype be thrown both by throwError and also by Control.Exception.throw?
10:02:56 <Vanadium> Well that was not very enlightening
10:03:28 <axzs> > typeOf (typeOf 42)
10:03:30 <lambdabot>   TypeRep
10:04:16 <Cale> Vanadium: TypeRep has a Show instance which displays as the name of the type
10:04:23 <Vanadium> I figured!
10:04:33 <Vanadium> I am just wondering how to write typeOf for my own type.
10:04:51 <Cale> Vanadium: Normally you wouldn't. Normally you'd let GHC derive it.
10:05:10 <Cale> deech: yes
10:05:32 <Cale> deech: You could very well use  Either SomeException  as a monad.
10:05:40 <Vanadium> Cale: What if I do not trust ghc to do it right? >:(
10:05:47 <deech> Well I have and Either function that can return a Left Errors or a Right String. Errors is a datatype like: data Errors = NoResponse | Unknown deriving (Eq,Show,Read,Typeable). Errors is also an instance of Exception. However when I try and throw, for example, a 'Left NoResponse' GHC complains that NoResponse is not an Exception but an Errors.
10:06:34 <Cale> Vanadium: Better to not trust yourself to do it right, but okay :)  You would use mkTyCon and the other related functions from Data.Typeable
10:07:04 <Cale> Vanadium: GHC really ought not to allow you to write your own Typeable instances, because by forging them, you can break the type system.
10:07:32 <Berengal> Cale: The entire type system, or just the runtime type system?
10:07:36 <Vanadium> Cale: I suppose so. The whole "deriving" thing just seems deeply magical and strange :C
10:08:08 <Cale> Berengal: The entire type system.
10:08:29 <Vanadium> Also why does the language not just go ahead and make every type an instance of Typeable to begin with?
10:08:34 <Cale> Vanadium: It just uses the structure of your type declaration to write the instance.
10:08:36 <Badger> @src Typeable
10:08:37 <lambdabot> Source not found. You speak an infinite deal of nothing
10:09:09 <Berengal> Cale: How?
10:09:20 <Cale> Vanadium: Well, that's a good question. Typeable wasn't around when things started, and deriving it is a language extension. It would be appropriate for all monomorphic types to be Typeable.
10:09:46 <Vanadium> I am afraid I am not entirely certain what polymorphic types are.
10:09:50 <Vanadium> Or non-monomorphic types. :3
10:12:06 <jad4> how do you put just one page landscape?
10:12:08 <jad4> opss
10:12:35 <jad4> wronge channel :S
10:12:46 <Cale> Berengal: well... for one you can copy the typeRep of some other type, which lets you cast values between your new type and that type successfully
10:13:19 <Cale> Berengal: But you can do much worse if you write an instance of Typeable for a and turn on some extensions like IncoherentInstances
10:13:34 <Berengal> Cale: But that would be using the runtime system...
10:14:41 <Cale> Berengal: Well, if by 'runtime system' you mean 'cast' then yes.
10:15:18 * pikhq senses unsafeCoerce-esque abuse
10:15:19 <Cale> Berengal: that's what we're talking about. Using bad instances of Typeable to allow cast to successfully cast values between two types when it shouldn't.
10:15:39 <Cale> The problems you end up with are similar to those from unsafeCoerce.
10:15:41 <Berengal> Cale: 'cast' uses runtime type information, so yes, I consider that part of the runtime system
10:16:07 <benmachine> @type cast
10:16:09 <Cale> Berengal: Typeable is that runtime type information... so I guess I don't understand what your question is
10:16:10 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
10:16:29 <Cale> Berengal: basically, by forging instances of Typeable, you can break type safety
10:18:38 <dons> ?seen pumpkin
10:18:39 <lambdabot> I saw pumpkin leaving #concatenative, #haskell-iphone, #haskell, #haskell.it, #darcs, #ghc, #haskell-in-depth and #haskell-blah 15h 51m 4s ago, and .
10:18:42 <dons> ?seen dolio
10:18:43 <lambdabot> dolio is in #ghc, #haskell-in-depth, #haskell-blah and #haskell. I last heard dolio speak 31m 10s ago.
10:18:58 <Berengal> Actually, I guess it's Typeable that breaks the entire system. It promises that it can prove some type, but only at runtime. The static checker, naive as it is, trusts it, but then Typeable goes ahead and does a fandango on core
10:19:21 <Berengal> Well, it could, because Typeable trusts humans
10:19:50 <pikhq> Misplaced trust.
10:20:05 <Cale> Berengal: Well, it's some combination of Typeable, cast (which is where the magic is), and the fact that users are allowed to write their own instances of Typeable
10:23:05 <dons> dolio: http://hackage.haskell.org/package/uvector-0.1.0.4
10:23:16 <dons> dolio: I'd like to work out what we need to do to finish this lib up.
10:23:37 <dons> expose the 'direct' ops, and add intro/elim forms for bytstrings. add some scientific routines (like sorting...)
10:23:39 <leimy_> dons: got any more book deals in your future? :-)
10:23:40 <dons> dolio: let me know.
10:23:51 <Cale> newtype W a = W {unW :: a}
10:23:51 <Cale> instance Typeable (W a) where typeOf _ = typeOf ()
10:23:51 <Cale> unsafeCoerce x = unW . fromJust . cast $ W x
10:23:51 <dons> leimy_: nothing yet. trying to get work done :)
10:23:55 <leimy_> dons: I hear ya.
10:24:10 <leimy_> dons: I'm using more and more Haskell at work by the way...
10:24:16 <dons> we need more haskell books though.
10:24:17 <dons> oyh, cool.
10:24:20 <leimy_> Yep!
10:24:26 <Cale> unsafeCoerce :: a1 -> a
10:24:31 <Cale> (the inferred type)
10:24:59 <Cale> and it doesn't even need extensions :)
10:25:15 <leimy_> dons: it helps that my boss was aware of Haskell 20 years ago
10:25:23 <leimy_> and that he knew what it was about then.
10:25:34 <dons> nice
10:25:37 <leimy_> he used to write Fortran compilers for Cray :-)
10:26:23 <Cale> Berengal: Is that broken enough? ;)
10:27:08 <Berengal> Cale: Breaks my heart :(
10:27:08 <Cale> It was oleg who pointed this out first, of course :)
10:27:38 <Cale> The only real fault is that we're allowed to write our own instances of Typeable rather than being forced to derive them.
10:28:10 <Berengal> I'm of the opinion that we shouldn't need Typeable at all though
10:28:32 <Berengal> But how much can actually be done at compile-time I don't know
10:28:52 <Vanadium> I only hear Oleg spoke of as a figure of myth and legend.
10:28:54 <Cale> Well, we need some way to get runtime type information to where it's needed without weighing everything down with it all the time.
10:29:03 <Cale> Vanadium: read the mailing lists
10:29:10 <Cale> Vanadium: He posts all the time
10:29:13 <Vanadium> Oh.
10:29:25 <gio123> Cale: pm
10:29:33 <Cale> gio123: yes, I got it
10:29:59 <gio123> could u pm please title please, since i can not open it
10:30:05 <Berengal> I wish I knew more about what is and what isn't possible in the type system
10:30:05 <anq> Hello. Is it not possible to use type synonyms in monad transformer definitions? Like in (WriterT [String] Parser String).
10:30:32 <Cale> No, it's possible.
10:30:48 <anq> GHC complains that Type synonym `Parser' should have 1 argument, but has been given 0":
10:31:31 <Cale> um, LiberalTypeSynonyms is the appropriate language extension, I think :)
10:31:45 <gio123> could u pm please title please, since i can not open it
10:31:48 <Cale> oh!
10:32:06 <Cale> anq: Parser is what?
10:32:31 <Cale> anq: It had better be an instance of Monad to begin with of course...
10:32:31 <anq> Cale, it's essentially a unary type synonym for the ParsecT transformer monad wrapped around Identity.
10:32:38 <Cale> ah, okay
10:32:53 <Cale> So that ought to work, I think.
10:33:04 <anq> It doesn't, though. Hold on, I'll activate the extension.
10:33:08 <Cale> {-# LANGUAGE LiberalTypeSynonyms #-}  at the top of your file
10:33:32 <Berengal> For example, given 'class List a [...]'; instance (List b) => List (a, b) [...]; instance List () [...]; type family MapTypeAp f list; [instances for (a,b) and ()]; can you write a function ':: (List list) => (forall a. a -> f a) -> list -> MapTypeAp f list'?
10:33:33 <Saizan_> ghc eta-converts for you?
10:34:37 <Cale> Saizan_: I think with the extension, it'll let you use partially applied type synonyms in the simple cases where they can be eta reduced...
10:36:56 <BONUS> im using irssi from my cellphone atm god this is hard to type. hey Vanadium did you find that paper or get an explanation re: exception hierarchy
10:37:42 <Baughn> BONUS: He got an explanation
10:37:55 <Vanadium> Hello BONUS, Cale was very helpful
10:37:55 <Vanadium> Did not find the paper, went to subscribe to mailing lists instead
10:38:03 <BONUS> cool :)
10:38:39 <BONUS> existentials are fun
10:39:43 <burp> foldl (++) "" $ take 50 $ repeat "0123456789 " <- I bet there is a shortcut for this =)
10:40:01 <soupdragon> > foldl (++) "" $ take 50 $ repeat "0123456789
10:40:05 <lambdabot>   <no location info>:
10:40:05 <lambdabot>      lexical error in string/character literal at end o...
10:40:26 <burp> > foldl (++) "" $ take 50 $ repeat "0123456789 "
10:40:29 <soupdragon> my shortcut didn't work
10:40:29 <lambdabot>   "0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 01234567...
10:41:06 <maltem> > replicateM 50 "0123456789 "
10:41:08 <lambdabot>   ["00000000000000000000000000000000000000000000000000","00000000000000000000...
10:41:12 <copumpkin> lol
10:41:13 <Saizan_> burp: use concat
10:41:14 <maltem> hmph
10:41:22 <Cale> That'll be a rather long list
10:41:23 <copumpkin> maltem: that's a long list :P
10:41:25 <hzap_> > take 50 $ cycle "0123456789 "
10:41:27 <lambdabot>   "0123456789 0123456789 0123456789 0123456789 012345"
10:41:31 <maltem> copumpkin, true true
10:41:32 <Cale> > 11^50
10:41:33 <lambdabot>   11739085287969531650666649599035831993898213898723001
10:41:39 <burp> yup, I was looking for cycle ;)
10:41:40 <benmachine> > unwords $ replicate 50 "0123456789"
10:41:41 <lambdabot>   "0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 01234567...
10:42:20 <benmachine> or concat, just as good
10:43:42 <hzap_> > replicateM 5 "abc"
10:43:44 <lambdabot>   ["aaaaa","aaaab","aaaac","aaaba","aaabb","aaabc","aaaca","aaacb","aaacc","a...
10:44:10 <benmachine> it's counting in ternary :o
10:44:22 <benmachine> > replicateM 3 "01"
10:44:24 <lambdabot>   ["000","001","010","011","100","101","110","111"]
10:44:29 <copumpkin> > replicateM 5 "012"
10:44:31 <lambdabot>   ["00000","00001","00002","00010","00011","00012","00020","00021","00022","0...
10:44:41 <erikc> watup #haskell
10:44:47 <copumpkin> zomg it's erikc
10:44:50 <hzap_> > concat (map (\x -> replicateM x "012") [1..])
10:44:52 <lambdabot>   ["0","1","2","00","01","02","10","11","12","20","21","22","000","001","002"...
10:45:12 <Rotaerk> > replicate 200 "0123456789ABCDEFGHI"
10:45:12 <hzap_> that's counting in ternary (almost) :)
10:45:14 <lambdabot>   ["0123456789ABCDEFGHI","0123456789ABCDEFGHI","0123456789ABCDEFGHI","0123456...
10:45:25 <Rotaerk> err whoops
10:45:32 <Rotaerk> > replicateM 200 "0123456789ABCDEFGHI"
10:45:34 <lambdabot>   ["0000000000000000000000000000000000000000000000000000000000000000000000000...
10:45:38 <Rotaerk> d'oh
10:45:44 <copumpkin> Cale: why 11^50 btw?
10:45:49 <benmachine> > filter (not . "0" `isPrefixOf`) $ concat (map (\x -> replicateM x "012") [1..])
10:45:51 <lambdabot>   The operator `Data.List.isPrefixOf' [infixl 9] of a section
10:45:51 <lambdabot>      must have ...
10:46:04 <benmachine> oh, I am silly
10:46:15 <benmachine> > filter (not . isPrefixOf "0") $ concat (map (\x -> replicateM x "012") [1..])
10:46:17 <lambdabot>   ["1","2","10","11","12","20","21","22","100","101","102","110","111","112",...
10:46:32 <copumpkin> o.O
10:46:51 <tavelram> isnt there some functions for radix already?
10:46:53 <maltem> copumpkin, for every character there are 11 possibilities, and there are 50 characters to each string
10:47:02 <copumpkin> showIntAtBase
10:47:11 <hzap_> :t showIntAtBase
10:47:12 <Trafalgard> This may show split and take up multiple lines:
10:47:12 <thaldyron> does anyone know whether encodeFile/decodeFile of package binary are  thread-safe?
10:47:13 <copumpkin> maltem: oh I missed the space
10:47:16 <Trafalgard> ACTION wonders why doesDirectoryExists thinks "..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\.." is a directory in C:\msys\1.0\home\Owner\haskell\Uristmod, but add one more ".." (with a path separator) to the beginning of it and HEY MUST BE END OF DIRECTORIES. (The giant
10:47:16 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
10:47:19 <Trafalgard> ...
10:47:25 <maltem> ah :)
10:47:25 <Cale> > length "0123456789 "
10:47:27 <lambdabot>   11
10:47:29 <Trafalgard> way to spam away what I just said, netsplit
10:47:30 <hzap_> weird type
10:47:34 <copumpkin> yeah, I didn't see that hidden space :P
10:47:44 <copumpkin> it's invisible!
10:48:00 <maltem> I don't see an invisible space.
10:48:20 <copumpkin> that's cause it's invisible!
10:48:27 <Rotaerk> Trafalgard, C:\.. == C:\
10:48:35 <maltem> Riiiight ;)
10:49:16 <Trafalgard> Why does it eventually go "Not a directory!"
10:49:18 <tavelram> @src showIntAtBase
10:49:20 <lambdabot> Source not found.
10:49:28 * erikc is getting to use functional programming for the first time professionally!
10:49:33 <erikc> too bad it's f#
10:50:09 <Rotaerk> I haven't decided whether I prefer strict or lazy by default
10:50:24 <Baughn> For performance-critical crypto code, would you use Crypto, HsOpenSSL, or what?
10:50:50 <Baughn> ..actually, I suppose that's a silly question
10:51:39 <gio123> Cale: pm please
10:54:07 <dolio> dons: As far as uvector-algorithms is concerned, I think the necessary changes (memcpy and zipping mutable arrays) are already covered by uvector-1.1. And pumpkin was working on bytestring stuff for it, I thought.
10:54:46 <dolio> dons: I know the read/write stuff in the current version is fairly broken, unless that was fixed in 1.0.4.
10:55:01 <copumpkin> yeah, there's some bytestring stuff in the repo but there are a few changes I need to make
10:55:10 <copumpkin> it should already be better than nothing though
10:55:41 <copumpkin> I'll probably have some time to do it tomorrow if dons is pushing for a release
10:55:49 * SamB wants something to read amazon wishlists
10:56:03 <copumpkin> @hackage amazon-wishlist-kthx
10:56:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/amazon-wishlist-kthx
10:56:11 <copumpkin> :9
10:56:12 <Vanadium> Read my amazon wishlist and buy me real-world-haskell
11:01:54 <bremner> Vanadium: I give you the website kthxby
11:02:04 <Vanadium> Oooh, thanks
11:13:27 <mikesteele81_> Is there any place where I can find a mapping between LANGUAGE pragmas and what features get enabled for each?  I'm trying to figure out what to use with phantom types, for example.
11:13:32 <thetallguy1> Language.Haskell.Extension?
11:13:37 <copumpkin> phantom types don't need extensions?
11:15:05 <SealedSun> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
11:15:40 <mikesteele81_> thetallguy1: not sure what you mean
11:15:41 <copumpkin> I was sure there was a version of that all on one page
11:15:43 <copumpkin> but I can't find it now
11:16:07 <copumpkin> mikesteele81_: but what are you doing with phantom types that regular haskell can't do?
11:16:07 <copumpkin> maybe you want GADTs?
11:16:09 <thetallguy1> mikesteele81_:    http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html
11:16:19 <mikesteele81_> copumpkin: {-# OPTIONS -fglasgow-exts -#} seems to enable it, but I don't want to turn on other features that I'm not using.
11:16:23 <thetallguy1> That's a list of all of them.
11:17:20 <copumpkin> mikesteele81_: if you show us what you're doing that doesn't work without glasgow-exts, we can tell you what you need
11:17:24 <copumpkin> often the error message will tell you too
11:20:11 <MarcWeber> nominolo_: vim can't cope with JSON because it encode strinsg using '. JSON requires ". Another issue is null. Vim dosen't know about it. But NULL isn't returned anyway, is it ? I'll write a JSON encoder for VIM then.
11:20:41 <mikesteele81_> Well, I've got a type representing names which I would like to make an Ord instance for so I can sort lists of names.
11:20:52 <mikesteele81_> data Name = FirstLast String String
11:21:15 <copumpkin> ****ing hell
11:21:16 <nominolo_> MarcWeber: wouldn't it be easier to use the Python JSON decoder and *generate* Vim types?
11:21:26 <copumpkin> mikesteele81_: so far that's pure h98
11:21:40 <mikesteele81_> I'd like to be able to sort it by first or by last name, but of course there can only be one Ord instance
11:21:59 <mikesteele81_> So I thought I'd use Peano Numbers to get two Ord instances:
11:22:04 <mikesteele81_> data FirstPreferred
11:22:08 <copumpkin> newtype SortByFirst = SortByFirst Name
11:22:11 <mikesteele81_> data LastPreferred
11:22:16 <mikesteele81_> ah!
11:22:16 <copumpkin> newtype SortByLast = SortByLast Name
11:22:21 <copumpkin> and define Ord on both of those
11:22:36 <MarcWeber> nominolo_: No, it adds a dependency. It's less than 15 lines of code
11:22:42 <nominolo_> MarcWeber: unless you can make it a simple 'sanitizing' pass over the input string
11:22:45 <mikesteele81_> Great.  I'll try to run with that idea and see where it gets me.
11:22:46 <copumpkin> mikesteele81_: oh for that you need -XEmptyDataDecls
11:22:58 <copumpkin> mikesteele81_: (for your version, that is)
11:23:08 <copumpkin> which also would work fine
11:23:23 <nominolo_> MarcWeber: ok, but full JSON decoding is more like 200 lines (with all the escaping stuff)
11:23:42 <mikesteele81_> I'll stick with using newtype for now since that's H98
11:24:19 <copumpkin> yeah, otherwise there's nothing saying you can't put a single constructor in your empty datas
11:24:22 <copumpkin> you just won't use it
11:24:51 <mikesteele81_> To get what I want I'd have to use FlexibleInstances though.
11:24:53 <MarcWeber> nominolo_: Let's try. If it doesn't work We can fallback to python encoding and or the vim encoder I wrote earlier
11:25:06 <Baughn> What was the name of that library with greater-than-Word64 words?
11:25:24 <mikesteele81_> instance Show (Name FirstPreferred) where show = blah blah...
11:25:54 <nominolo_> MarcWeber: well, but rolling your own JSON parser is worse than using an external dependency imo
11:28:49 <jeffwheeler> http://www.engineyard.com/blog/2009/programming-contest-win-iphone-3gs-2k-cloud-credit/
11:28:54 * jeffwheeler is reminded of cryptol
11:29:27 * jeffwheeler wonders what the quickest and easiest way to access a supercomputer is
11:29:47 * Baughn notes that the problem is (almost) perfectly parallelizable
11:30:26 <copumpkin> so they just want you to find a near collision for sha1?
11:30:36 <SealedSun> Hi. I'm trying to run an ST action (`:: ST [[Int]]`) that uses arrays internally but I get a "Could not deduce (MArray (STUArray s) Int (ST s)) from the context ()" error message on the call to `runST`. Whats wrong? (Snippet: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7335#a7335)
11:30:44 <jeffwheeler> copumpkin: apparently, yes
11:31:26 <jeffwheeler> I have no idea when you'd want a near-collision, though … when would that be useful?
11:31:30 <copumpkin> lol
11:31:43 <copumpkin> beats me, but I like how they'll give you a macbook pro if you can find a sha1 collision
11:31:59 <jeffwheeler> hehe, yeah
11:32:03 <jmcarthur_work> when you're only visually comparing the hashes then a near-collision could be useful
11:32:09 <MarcWeber> nominolo_: I'm not talking about parsing. I'm only talking about generating the request objects
11:32:12 <copumpkin> true
11:32:22 <jeffwheeler> I don't think I can get access to a university supercomputer on short notice, though ;)
11:32:35 <MarcWeber> nominolo_: http://dpaste.com/69614/ It looks like this.
11:32:48 <copumpkin> whenever I see things about winning an iphone 3GS I wonder if they'll pay for the two-year contract for me too
11:33:01 <nominolo_> MarcWeber: ah, ok.  Generating is fine
11:33:07 <jeffwheeler> copumpkin: usually not; they'll give you the gift certificate that Apple has for it
11:33:43 <copumpkin> "here, we'll pay the subsidized 300 dollars for the device and you can pay $1680 for the rest of the contract"
11:33:58 <copumpkin> sounds like a good deal
11:34:02 <jeffwheeler> copumpkin: on the other hand, most people already pay a good portion of that :)
11:34:04 * ManateeLazyCat pasted "Unique.hs" at http://paste2.org/get/334391
11:34:05 <ManateeLazyCat> Above library (Unique.hs) is a sub-module by my project for unique filename (with different directory suffix), so it can apply editor, file-browser, or any application that load file with tab-bar. Example i input "unique ["/ab/cd/ef", "/ab/cd/cd/ef", "/ab/ef/cd/ef", "/hh/ll", "/hh/ww/ll", "/gg/jj/kk", "/xx/yy/kk"]" , i will got output:
11:34:05 <ManateeLazyCat> "[("ef","/ab/"),("ef","/ab/cd/"),("ef","/ab/ef/"),("ll","/hh/"),("ll","ww/"),("kk","jj/"),("kk","yy/")]", and with type [(FilePath, FilePath)], first FilePath is minimum different directory for unique, second FilePath is filename. Enjoy!
11:34:28 <nominolo_> MarcWeber: params are always dictionaries, never arrays
11:34:46 <copumpkin> MarcWeber: what language is that?
11:34:56 <nominolo_> MarcWeber: i.e., the example is not good
11:35:05 <nominolo_> copumpkin: Vim script
11:35:11 <copumpkin> ah
11:35:35 <nominolo_> copumpkin: you don't want to program in it
11:35:48 <ManateeLazyCat> First FilePath is filename, Second is minimum different directory. Typo :)
11:35:57 <copumpkin> nominolo_: indeed I don't :)
11:36:54 <nominolo_> copumpkin: the funniest part is that communication vim<->python is via mutually recursive string evals
11:37:00 <copumpkin> :o
11:37:03 <copumpkin> what is this all for?
11:37:15 <nominolo_> copumpkin: so we can use Scion from within Vim
11:37:20 <copumpkin> ah cool
11:37:37 <copumpkin> scion makes no assumptions about the editor connecting to it, right?
11:37:52 <nominolo_> copumpkin: well, as few as possible
11:38:05 <copumpkin> I'd like it on textmate too, might look into making that happen
11:38:06 <MarcWeber> nominolo_: It's not just that. I tried adding some locks the last days to make vim more thread safe. I failed doing so for gtk gui.
11:38:17 <nominolo_> copumpkin: one problem is that Vim doesn't even keep a process alive between two calls
11:38:17 <ManateeLazyCat> That's will be nice if someone provide suggestions for my code at http://paste2.org/get/334391
11:39:12 <nominolo_> copumpkin: Does textmate allow sub-processes?
11:39:18 <copumpkin> I think so
11:39:29 <nominolo_> copumpkin: I.e., more than just running a shell-script
11:39:51 <copumpkin> I'm pretty sure another bundle does that but I'll have to look it up
11:40:29 <nominolo_> copumpkin: otherwise you need some stub which can reconnect to a running scion server (and session)
11:41:27 <nominolo_> copumpkin: I haven't figured out a portable mechanism to do this, though.  Then again, Textmate is not portable
11:41:35 <copumpkin> yeah :)
11:41:42 <copumpkin> how do you actually speak to scion? a unix socket?
11:41:43 <nominolo_> So, unix file-sockets would probably do
11:41:47 <copumpkin> ok
11:41:50 <nominolo_> atm, it's a BSD socket
11:41:56 <nominolo_> or stdio
11:41:59 <copumpkin> ah
11:42:28 <nominolo_> but BSD sockets are not quite secure (unless you're the only user on your machine)
11:43:22 <copumpkin> oh you're just listening on a tcp port?
11:44:20 <Baughn> "sha256 = unsafePerformIO $ newIORef undefined" <-- Well, so much for purity
11:44:30 <copumpkin> lol
11:44:54 <copumpkin> that's a very fancy polymorphic IORef you have there
11:45:13 <Baughn> Don't worry, there's also a type signature for sha256 just above. ^^;
11:45:25 <copumpkin> oh
11:46:05 <nominolo_> copumpkin: exactly.  and JSON is used as the serialisation protocol
11:46:20 <copumpkin> aha
11:47:00 * monochrom thinks of a few tie-the-knot tricks to eliminate the undefined.
11:50:09 <Baughn> monochrom: sha256 is a global variable, sorry..
11:50:16 <monochrom> sha256 = unsafePerformIO (mdo { c <- readIORef r; r <- newIORef c; return r })
11:50:38 <monochrom> Baughn: And it is still a global variable now, sorry..
11:51:11 <monochrom> Hmm wrong order.
11:51:28 <monochrom> sha256 = unsafePerformIO (mdo { r <- newIORef c; c <- readIORef r; return r })
11:51:29 <Baughn> Indeed. It's /very important/ that it stays undefined until the appropriate initialization function has been called
11:53:40 <monochrom> Another trick is to use unsafeInterleaveIO to postpone things.
11:54:35 <Baughn> monochrom: Right, I could do that, but.. sorry. I forgot to mention - if the code to initialize this variable runs before the openssl initializer, Bad Things happen. I'd rather have an undefined.
11:55:15 <jeffwheeler> When running `ghc --make Main`, I get Main.hi and Main.o, but how do I generate a linked binary, too?
11:55:16 <monochrom> I'm just doing unsafe golfing.
11:55:46 <LeoD> jeffwheeler: um, it usually does that automatically
11:55:50 <Baughn> jeffwheeler: That should happen automatically, assuming that Main.hs has the module name Main
11:56:12 <jeffwheeler> Hmm, I'm not sure what's wrong, then.
11:56:12 <Baughn> (Which is the default if you don't specify one)
11:56:20 <LeoD> random guess: maybe there's no main function?
11:56:44 * jeffwheeler hpates the file
11:56:54 <monochrom> sha256 = unsafePerformIO (mdo { r <- newIORef c; c <- unsafeInterleaveIO (the_function_who_computes_the_sha256); return r })
11:57:43 <jeffwheeler> Oh, I'm an idiot.
11:57:52 <jeffwheeler> I was looking for an a.out file … it's just called Main.
11:57:59 <LeoD> hah
11:58:12 <jeffwheeler> I don't recognize binaries when they're capitalized. :P
11:58:54 <thaldyron_> does anyone know if encodeFile/decodeFile of package binary are thread-safe?
11:59:00 <Sup3rkiddo> hi, Just started to learn haskell. Now, why am I not able to recursively call a function by passing it say the result of '/' operation, which likely would give me a real number.. Do I have to cast it to Int?
11:59:52 <mux> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7339#a7339 -- rings a bell to anyone? GHC panics on me...
12:00:00 <jmcarthur_work> Sup3rkiddo, i'm not sure i understand what you are trying to do
12:00:00 <BONUS> depends, whats the function?
12:00:01 <mux> it used to be able to build that very file too :-P
12:00:26 <Sup3rkiddo> jmcarthur_work, hmm, right sorry, I will pastebin the snippet.. promise not to laugh
12:00:35 <jmcarthur_work> Sup3rkiddo, heh, kk
12:03:51 <Sup3rkiddo> jmcarthur_work, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3067#a3068
12:04:13 <Sup3rkiddo> the intent being.. a number like 8545 would become [8,5,4,5]
12:04:42 <LeoD> Sup3rkiddo: you probably want to use the div function instead of /, it operates on ints
12:04:53 <Sup3rkiddo> LeoD, oh..
12:05:30 <Jedai> Sup3rkiddo: In fact check the divMod function, it likely do something you would like to use in your instance
12:05:30 <jmcarthur_work> Sup3rkiddo, in addition, i'm looking at "let rounded = rounded(num/10)" a bit suspiciously
12:05:37 <Jedai> :t divMod
12:05:43 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
12:06:00 <Sup3rkiddo> divMod seems to be perfect
12:06:14 <jmcarthur_work> :t let rounded = rounded 4 in rounded
12:06:16 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
12:06:17 <lambdabot>     Probable cause: `rounded' is applied to too many arguments
12:06:17 <lambdabot>     In the expression: rounded 4
12:06:42 <arjanb> mux: seem similar to http://trac.haskell.org/haskell-platform/ticket/71
12:06:46 <mux> heh
12:06:52 <mux> read that and my problem is fixed already
12:06:58 <mux> I was about to tell this here.
12:07:06 <mux> but thanks!
12:07:15 <BONUS> > map digitToInt $ show 5214
12:07:17 <lambdabot>   [5,2,1,4]
12:07:53 <LeoD> bah, converting to String first is lame ;)
12:08:06 * mux can now use his rss feed watcher / torrent downloader again
12:08:06 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 437189432
12:08:08 <lambdabot>   [2,3,4,9,8,1,7,3,4]
12:08:13 <Cale> > reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 437189432
12:08:14 <lambdabot>   [4,3,7,1,8,9,4,3,2]
12:08:26 <BONUS> quick and dirty does the job :)
12:08:41 <copumpkin> needs moar unfoldage
12:09:07 <Sup3rkiddo> thanks guys..fixed this, got another hurdle to cross :D
12:09:28 <Cale> I don't like the standard unfoldr function, somehow it never reads very well, because you have to mess around with Maybe values to express the stopping condition.
12:09:51 <Cale> Well, I shouldn't say that, there are some cases where it does.
12:09:59 <mux> Cale: I find it not bad if you use guards in the Maybe monad
12:10:15 <copumpkin> yeah, that's what I do
12:10:23 <copumpkin> it's still not beautiful, but I'm not sure how else to express stopping
12:10:30 <BONUS> i like to use unfoldr with guard for the stopping condition
12:10:30 <dolio> I die a little inside every time I see 'map g . takeWhile p . iterate f'.
12:10:33 <Cale> Yeah, that's the best you can do.
12:10:40 <Cale> dolio: why?
12:10:42 <BONUS> gah beaten
12:10:56 * copumpkin beats BONUS some more
12:11:07 <BONUS> aaaaa
12:11:12 <dolio> Multiple intermediate lists.
12:11:17 <Cale> I think we ought to have something like  unfoldr' g p f = map g . takeWhile p . iterate f
12:11:38 <Cale> dolio: That's for the compiler to worry about.
12:11:56 <Cale> also, it's lazy anyway, so it's just immediate garbage
12:11:58 <copumpkin> I think stream fusion would get that one nicely wouldn't it?
12:12:00 <dolio> I don't disagree that unfoldr lacks combinators that make it useful with other standard library functions, though.
12:12:11 <Cale> (and GHC is good at dealing with immediate garbage like that)
12:12:16 * mux wonders if stream fusion based lists are going to land into the base package some day
12:12:24 <copumpkin> mux: there's a ticket about it
12:12:33 <copumpkin> I think they're pretty close, but not sure what's missing
12:12:37 <mux> copumpkin: cool, great news
12:12:41 <dolio> That ticket's been around for a while, though. :)
12:12:45 <copumpkin> yeah lol
12:12:50 <mux> heh, woops
12:13:08 <dolio> I think it's the same ticket that was "add stream fusion to 6.6" or something.
12:13:09 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/915
12:13:13 <dolio> Just bumped up several versions.
12:13:17 <copumpkin> version changed from 6.4.2 to 6.6.
12:13:19 <copumpkin> :P
12:13:30 <SamB> dolio: is it not conversified significantly since then as well?
12:14:02 <dolio> I don't really know what the hold-up is. Is concatMap still problematic?
12:14:18 <dolio> That was the original deal breaker. It screws list comprehensions.
12:14:19 <copumpkin> I think that was it, but I didn't think foldr/build did better on that did it?
12:14:53 <Saizan_> wasn't foldr/build invented for list comps?
12:14:59 <copumpkin> oh, maybe :)
12:15:19 <copumpkin> ce ne siamo accorti
12:15:30 <Cale> hmm...
12:15:48 <Cale> I'm assuming that it's the concat rather than the map part which is the issue.
12:16:08 <Cale> but that still seems a bit odd
12:16:13 <copumpkin> why?
12:16:25 <dolio> It may not just be concatMap. It's the sort of nested concatMaps that list comprehensions generate.
12:17:13 <dolio> I'm not totally sure.
12:17:16 <Sup3rkiddo> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3067#a3069 this thing worked :D...
12:17:23 <Saizan_> which was the paper on stream fusion?
12:17:24 <copumpkin> hrm, it doesn't seem fundamentally impossible using the stream fusion technique though
12:17:30 <copumpkin> I dunno though
12:17:51 <LeoD> Sup3rkiddo: btw, you can write (quotient, modulo) = divMod num 10 :)
12:18:01 <LeoD> no need for fst/snd here
12:18:03 <Cale> waaaaiit. The original stream fusion paper deals with concatMap
12:18:28 <Sup3rkiddo> LeoD, oh... yay, python like :D
12:18:35 <LeoD> :)
12:18:40 <copumpkin> Cale: hmm, I wonder what the problem is then
12:19:05 <Saizan_> deal as in explains the problem?
12:19:09 <Cale> and it goes over more detail on list comprehensions
12:19:19 <Cale> as in solves the problem with explicit code
12:20:53 * mux adds self into the cc list for this ticket
12:21:53 <copumpkin> Cale: maybe they never got around to putting that code into the stream-fusion module
12:22:01 <copumpkin> although dons did update that module the other day, so maybe it's in now
12:22:09 <copumpkin> I wish hackage had changelists :P
12:22:20 <Cale> Well, it also involves changing the translation of list comprehensions
12:22:47 <Berengal> Hmm, automatically generated changelists?
12:23:18 <Berengal> Can darcs do that? Can we shoehorn them into cabal?
12:23:35 <mux> I've seen people using the description field of cabal for that; so that if you click on each version number, you get the changes for this version
12:23:42 <dolio> It uses a monad desugaring (essentially) instead.
12:23:51 <mux> I'd say this is better than nothing
12:23:51 <Cale> Their translation removes the use of if, favouring guard, which is provided with a stream definition.
12:24:29 <Berengal> mux: Perhaps, but the description field is for descriptions
12:25:07 <Cale> Berengal: I was thinking about that the other day. It would be really good to have a changes field (section?)
12:25:43 <mux> Berengal: fully agreed
12:26:53 <Berengal> Cale: A section would probably be best. It should include changes in previous versions as well
12:26:59 <dcoutts_> Berengal, mux: there is a ticket open on supporting changelogs in cabal/hackage
12:27:13 <dcoutts_> the main question is what the format of the changelog is
12:27:53 <dcoutts_> it's relatively easy to add a new field in the .cabal file spec "changelog: Changelog"
12:28:32 <dcoutts_> but how does hackage interpret the content of that file so it can do useful things with it like display it on the package page and put the new changes in the rss feed
12:28:57 <Berengal> http://hackage.haskell.org/trac/hackage/ticket/244 ?
12:29:30 <dcoutts_> see also http://hackage.haskell.org/trac/hackage/ticket/299
12:30:07 <dcoutts_> the main question is if we should try to do any better than just preformatted plain text
12:30:31 <dcoutts_> eg so it can be displayed in slightly nicer html markup
12:33:50 <mikesteele81_> copumpkin: Thanks for the help.  writing instances for newtypes was exactly what I needed.
12:35:15 <copumpkin> cool :)
12:35:29 <lysgaard> I want to recieve multiple files over UDP syncronously. What are my main problems?
12:36:10 <Elly> message ordering, guaranteed delivery, data corruption, authentication
12:36:18 <Elly> you know, the problems TCP mostly solves for you :P
12:36:48 <lysgaard> Elly: Yeah, i guess you're right, but tcp is so slow, i want to stream
12:36:54 <copumpkin> o.O
12:36:59 <Elly> what on earth are you streaming that TCP is too slow for?
12:37:05 <copumpkin> it's slow because you want to make sure you actually get the entire file
12:37:14 <copumpkin> or do you not need reliable transfers?
12:37:27 <pikhq> Elly: Probably the thinko that "TCP=slow UDP=fast".
12:37:27 <Elly> receiving files, as opposed to random chunks of files, implies yes
12:37:56 <copumpkin> tcp is pretty fast for what it does
12:38:02 <jeffwheeler> Hmm, Cryptol doesn't install via cabal from Hackage.
12:38:10 <Elly> but you end up reimplementing TCP for almost any application anyway, except badly
12:38:16 <copumpkin> a lot of people reimplement most of it in udp because they feel tcp is slow, and then realize why tcp is slower
12:38:18 <lysgaard> Yeah, you're right.
12:38:30 <pikhq> If you need bits and don't care if the bits are in the right order or if some of the bits get removed from the stream, then use UDP.
12:38:37 <pikhq> Otherwise, USE FECKING TCP.
12:38:43 <copumpkin> lol
12:38:45 <lysgaard> Hehe, kay
12:39:02 <SamB> pikhq: actually, UDP can send a few bytes in a row, at least
12:39:12 <SamB> it's commonly sufficient for DNS
12:39:12 <Elly> SamB: sometimes.
12:39:14 <copumpkin> yeah, but the total order isn't guaranteed :P
12:39:23 <pikhq> SamB: Yes, it guarantees that each packet is correct and valid.
12:39:24 <copumpkin> Elly: for an individual frame the orderi s guaranteed
12:39:25 <Elly> for DNS you just get back one response packet, though
12:39:31 <Elly> copumpkin: yes, that's true
12:39:38 <pikhq> It doesn't do anything more than that.
12:40:12 <SamB> pikhq: you were implying that you could only send 1-bit signals reliably ;-)
12:40:32 <pikhq> SamB: Yeah, wrong statement.
12:40:39 <lysgaard> If i use tcp i don't have to worry about the packet clutter from multiple files sent at the same time either?
12:40:50 * mjrosenb has used udp for two computers that had a cat6 cable running between them
12:40:52 <Elly> "packet clutter"?
12:41:02 <Elly> if you use TCP, what ends up in which packet is not your problem
12:41:06 <Elly> and you are supposed to not worry about it
12:41:08 <mjrosenb> Elly: "three stooges syndrome"
12:41:17 <pikhq> Uh. You seem to be horribly confused about what TCP does.
12:41:17 <Berengal> From a programmer perspective, tcp sockets are simply streams
12:41:18 <SamB> if you use TCP, you basically get a two-way version of a unix pipe
12:41:28 <Elly> yes
12:41:46 <lysgaard> Yeah, i think I've got that
12:41:53 <pikhq> It's a couple of UNIX pipes with the other end on another computer. And that's it from the programmer's perspective.
12:41:55 <SamB> except that the ends can be in different places more easily
12:42:22 <Berengal> Sockets are like wormholes between computers
12:42:25 <mjrosenb> yeah, named pipes + nfs does *not* work the way you want it to
12:42:26 <SamB> now, I think there might be some facilities for OOB communication
12:42:28 <mjrosenb> wait
12:42:33 <mjrosenb> is this #haskell?
12:42:35 <Elly> there are, SamB, but nobody should use them
12:42:44 <lysgaard> But that mean the problem now is that instead of having to worry about what UDP packet belongs to wich file, I have to think about how to implement multiple tcp connections at once. Right?
12:42:48 <Elly> SIGURG and OOB are horrible hacks :P
12:42:59 <Elly> lysgaard: fortunately, this is an easy and well-known pattern
12:43:02 <pikhq> lysgaard: ... No.
12:43:13 <SamB> Elly: there may be a few times when you need such things :-(
12:43:13 <Elly> you open more than one socket, and either use a thread each or use select or poll or kpoll or kqueue or epoll or ...
12:43:20 <Elly> SamB: none come to mind
12:43:31 <pikhq> You've got multiple handles, and if you want to access them asynchronously, you do concurrent programming.
12:43:37 <Berengal> lysgaard: forever $ do {connection <- accept listenSocket; forkIO $ doTheThing connection}
12:43:37 <pikhq> (see: forkIO)
12:43:49 <Elly> ah, the haskell way :)
12:44:04 * SamB wonders how you do flow control in TCP?
12:44:26 <lysgaard> Think i got some of it ;) I'll take a good look in RWH
12:44:30 <Elly> I believe it's up to the kernel?
12:44:31 <lysgaard> Thanks
12:50:44 <maxote> hi guys, is there any efficient bytecode interpreter of Haskell 98 ? GHC generates giant binaries that i wanna it.
12:50:59 <Elly> Oo
12:51:09 <Elly> really? how big are the binaries you're getting?
12:51:31 <maxote> Elly, big as 10 MB for darcs 2.2.0 only
12:51:47 <Daimonic> hey, I am going to make a function, which returns the smallest element of the datatype [a] http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7340#a7340
12:51:58 <Elly> is that a statically-linked darcs?
12:52:12 <Daimonic> however, compiler complains: Occurs check: cannot construct the infinite type: a = [a]
12:52:13 <Elly> my darcs is less than half that size
12:52:33 <dons> copumpkin: can you send me your patches against uvector darcs?
12:52:34 <Saizan_> maxote: tried stripping?
12:52:35 <dons> esp. re. IO.
12:52:52 <Jedai> maxote: try stripping the executable
12:53:03 <dschoepe> Daimonic: You're missing parentheses around (max x y):xs
12:53:22 <Sup3rkiddo> all of a sudden getting this  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3070#a3070 for this piece of code http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3067#a3069 ... In the ghci prompt
12:53:24 <dschoepe> Daimonic: but that function would return the biggest element, since you're using max and not min
12:53:42 <Daimonic> hehe
12:53:46 <Daimonic> didnt noticed, thanks
12:53:48 <Sup3rkiddo> it worked, but suddenly got the above error
12:53:49 <maxote> thanks, i will try to strip the binary
12:53:53 <Daimonic> but it works now, thanks alot mate
12:53:55 <dschoepe> Daimonic: And it crashes when given a single element list
12:54:09 <Elly> you may want to consider fold
12:54:22 <Daimonic> dschoepe: so I have tp pattern match it
12:54:22 <copumpkin> dons: gimme a couple of hours, have a couple of meetings now and then I'll be free and will send you the patches
12:54:58 <dschoepe> Daimonic: Yes. and as Elly said, you can try to write that in terms of fold which is an abstraction for that type of recursive function
12:55:12 <Jedai> Sup3rkiddo: it's saying it doesn't know how to print function from list to list
12:55:14 <dons> copumpkin: thanks
12:55:27 <Daimonic> ah fold how could I forgot about fold
12:55:28 <Jedai> Sup3rkiddo: didn't you forget an argument to your function
12:55:37 <dons> copumpkin: do you recall if you had a patch for replicate?
12:55:54 <dons> i.e. replicate (-1) on streams will try to index outside.
12:56:04 <copumpkin> oh, hmm
12:56:07 <Jedai> Sup3rkiddo: "toList 5" on the GHCi prompt would probably get you that for instance
12:56:14 <dons> doesn't matter if you don't recall
12:56:21 <copumpkin> dons: I don't recall, but my work on it is mostly public on that patch-tag repo
12:56:24 <Sup3rkiddo> Jedai, hmm.. right
12:56:25 <dons> k.
12:56:32 <copumpkin> I thought I'd caught all the out of bounds errors
12:56:41 <copumpkin> but I didn't have testcases for all of them
12:56:49 <Sup3rkiddo> man, I must sleep.. haskell and beer don't mix
12:57:00 <Jedai> Sup3rkiddo: normally, you would make toList local to a function that would only take one parameter (the number to convert)
12:57:56 <Jedai> Sup3rkiddo: Also, the "fst result" and "snd result" are pretty ugly when you can replace those 3 lines with only one with pattern matching
12:58:38 <Jedai> Sup3rkiddo: And I disagree, Haskell and Beer mix very well !! ;)
12:58:46 <Sup3rkiddo> Jedai, yes, ideally thats how I should have written it.. But my haskell experience is a couple of hours old :D
12:59:26 <Sup3rkiddo> (I still have to learn loops)
12:59:30 <Jedai> Sup3rkiddo: Good luck with the language then, if you stick with it you'll have lots of fun time and headaches
12:59:35 <Jedai> ^^
12:59:44 <Sup3rkiddo> hehe.. thanks
13:00:07 <Sup3rkiddo> its been fun so far..
13:00:21 <Jedai> Sup3rkiddo: There's no loops in Haskell, you do everything with recursion (or it may be more correct to say that "loops" are normal higher-order functions)
13:01:05 <dons> all loops are just different recursion forms, so no need for a language to bake in particular magic loops with special syntax
13:01:07 <Jedai> You can write your own "loops" or control structure very easily and elegantly in a lazy language like Haskell :)
13:01:39 <Sup3rkiddo> come on guys.. have mercy... I can't even walk yet.. :P
13:01:43 <Vanadium> You cannot really make it look as magical as if/then/else though
13:02:24 <dschoepe> Vanadium: I guess that's possible too, considering that BASIC can be implemented as a DSL :)
13:02:27 <dons> yeah, i suppose: if e a1 a2 isn't quite right
13:02:36 <Jedai> Vanadium: That's a shame really, too bad that Haskell don't support the same multifix operators as Agda
13:03:03 <dons> someone should patch the parser :)
13:03:26 <dolio> Agda's operators have their own issues, though.
13:03:33 <dons> i can imagine few objections to more theorem-prover like syntactic flexibility
13:03:41 <Berengal> data Then = Then; then = Then; data Else = Else; else = Else; if True Then t else f = t; if False Then t Else f = f
13:04:25 <jmcarthur_work> there is a library that provides bool :: a -> a -> Bool -> a, and that's good enough for me
13:04:30 <jmcarthur_work> similar to the maybe function, of course
13:04:50 <jmcarthur_work> i'm not very big on if-then-else, really
13:05:07 <pikhq> I'm more a fan of ? :
13:05:25 <jmcarthur_work> guards are decent for a lot of things
13:05:29 <mux> you can have ? $ but that's cheating a bit :)
13:05:55 <pikhq> Yuh.
13:06:15 <Berengal> In my hacker file I've got "if' :: Bool -> a -> a -> a; fi :: a -> a -> Bool -> a; (?) = fi"
13:07:29 <mux> are there download statistics somewhere on hackage?
13:08:39 <dons> mux: not on hackage. but google for 'haskell one million downloads' for stats from March
13:09:20 <Daimonic> I am looking for a function which inserts into a sorted list an element so it is still sorted after the insertion, any advices?
13:09:34 <Elly> you could write one :)
13:09:34 <dons> Use a Set?
13:09:40 <dolio> @type insert
13:09:43 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
13:09:54 <copumpkin> what does insert do if the list isn't ordered?
13:09:59 <dons> ?src insert
13:09:59 <lambdabot> insert e ls = insertBy (compare) e ls
13:10:06 <dons> ?src insertBy
13:10:07 <lambdabot> insertBy _   x [] = [x]
13:10:07 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
13:10:07 <lambdabot>                                  GT -> y : insertBy cmp x ys'
13:10:07 <lambdabot>                                  _  -> x : ys
13:10:10 <jeffwheeler> > let a = "abc" in replicate (10 - length a) ' ' ++ a
13:10:12 <lambdabot>   "       abc"
13:10:17 <mux> dons: nice.  any chance you regenerate those statistics somewhere ?
13:10:26 <copumpkin> > insert 4 [1,3,2,5]
13:10:28 <lambdabot>   [1,3,2,4,5]
13:10:28 <dons> i will, yeah.
13:10:38 <mux> great
13:10:51 <jeffwheeler> @hoogle pad
13:10:52 <lambdabot> Text.XHtml.Frameset cellpadding :: Int -> HtmlAttr
13:10:52 <lambdabot> Text.XHtml.Strict cellpadding :: Int -> HtmlAttr
13:10:52 <lambdabot> Text.XHtml.Transitional cellpadding :: Int -> HtmlAttr
13:11:21 <dolio> > insert 4 [1,2,3,4,4,3,3,5]
13:11:24 <lambdabot>   [1,2,3,4,4,4,3,3,5]
13:12:24 <jeffwheeler> > zip (replicate 10 ' ') "abc"
13:12:26 <lambdabot>   [(' ','a'),(' ','b'),(' ','c')]
13:12:56 <bgs100> > zip [0..] "Wheeeee"
13:12:58 <lambdabot>   [(0,'W'),(1,'h'),(2,'e'),(3,'e'),(4,'e'),(5,'e'),(6,'e')]
13:13:06 <mux> > zip (repeat ' ') "abc"
13:13:07 <lambdabot>   [(' ','a'),(' ','b'),(' ','c')]
13:13:09 <jeffwheeler> I'm sure there's some clever way to pad it, so that there are ten characters.
13:13:16 <jeffwheeler> (With spaces in front)
13:13:19 <mux> oh
13:13:27 <mux> > printf "%10s" "abc"
13:13:29 <lambdabot>   Add a type signature
13:13:33 <mux> > printf "%10s" "abc" :: String
13:13:35 <lambdabot>   "       abc"
13:13:46 <jeffwheeler> Hmm, I'm looking for something that'll be as efficient as possible.
13:14:08 <jeffwheeler> And it might not be a string, either.
13:14:08 <mux> printf should be okay, though I don't use much because it isn't type-safe and can introduce runtime errors
13:14:28 <mux> you could achieve the same goal using pretty-printing combinators, but I don't know about their speed
13:14:50 <bgs100> > lines (map (\x -> (show (fst x)) ++ (snd x)) (zip [0..] (lines "This is the first line!\nAnd the second!\nAnd so on!")))
13:14:52 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:14:53 <jmcarthur_work> > reverse . take 10 . (++ repeat ' ') . reverse $ "abc"
13:14:55 <lambdabot>   "       abc"
13:15:08 * jeffwheeler likes that
13:15:17 <bgs100> > unlines (map (\x -> (show (fst x)) ++ (snd x)) (zip [1..] (lines "This is the first line!\nAnd the second!\nAnd so on!")))
13:15:19 <lambdabot>   "1This is the first line!\n2And the second!\n3And so on!\n"
13:15:33 <bgs100> > unlines (map (\x -> (show (fst x)) ++ ". " ++ (snd x)) (zip [1..] (lines "This is the first line!\nAnd the second!\nAnd so on!")))
13:15:35 <lambdabot>   "1. This is the first line!\n2. And the second!\n3. And so on!\n"
13:15:38 <mux> the double reverse version probably isn't going to be fast :)
13:15:59 <jmcarthur_work> nope
13:16:25 <jeffwheeler> But relative to String works?
13:16:27 <jmcarthur_work> > let reversed = (reverse .) . (. reverse) in reversed (take 10 . (++ repeat ' ')) $ "abc"
13:16:29 <lambdabot>   "       abc"
13:23:03 <MarcWeber> nominolo_: What is this id about?
13:23:10 <mmorrow> , (\a xs -> replicate (10 - length xs) a ++ xs) ' ' "abc"
13:23:13 <lunabot>  "       abc"
13:23:39 <mmorrow> , (\a xs -> replicate (10 - length xs) a ++ xs) ' ' "abccccccccccccddddddddddddddd"
13:23:41 <lunabot>  "abccccccccccccddddddddddddddd"
13:23:52 <nominolo_> MarcWeber: it's used as a serial number.  At the moment it doesn't serve any purpose, but once we allow asynchronous requests it will
13:24:13 <nominolo_> MarcWeber: basically, it's completely up to the client, the server will just put the same id in the response
13:25:02 <mmorrow> , (\a xs -> replicate (10 - length (take 10 xs)) a ++ xs) ' ' "abc" {- better -}
13:25:03 <lunabot>  "       abc"
13:25:17 <mmorrow> , (\a xs -> replicate (10 - length (take 10 xs)) a ++ xs) ' ' (repeat 'a')
13:25:19 <lunabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
13:29:15 <periodic> I have a package that wants Base >= 4.0, but I only have 3.0 installed.  What exactly is this package?
13:30:00 <periodic> This stuff would be part of a new GHC compile?  Would cabal recognize that?
13:30:10 <mmorrow> upgrade your ghc
13:30:33 <periodic> I'm guessing 6.10 has the 4.0+ base?
13:30:42 <mmorrow> yes
13:30:47 <periodic> (I am using 6.8 because Debian is slacking)
13:30:52 <periodic> k, thanks.
13:30:54 <mmorrow> slackers!
13:30:55 <mmorrow> :)
13:30:59 <periodic> Figured, but I know GHC is a LONG compile.
13:31:15 <mmorrow> periodic: if you don't want to build it there's always the binary dist
13:31:22 <MarcWeber> nominolo_: I think the server should be able to send information to the client itself ? Eg the server could tell the editor that background compilation has finished?
13:31:32 <periodic> I figure if I'm not using a distribution package I might as well compile it.
13:31:35 <MarcWeber> Anld api, some the new
14:45:46 <dons> and people get the ranges all wrong
14:46:47 <washawish> trying to install profiling version of hmatrix.  I get message Could not find module `Data.Complex': and that I may need to install profiling libraries for package base-3.0.3.0.  Can I do this with cabal locally?
14:47:05 <dcoutts_> dons: it's also because the old regex versions specify wrong constraints
14:47:33 <dcoutts_> dons: they say >= regex-base-0.70 but they do not work with 0.9x versions
14:47:49 <Saizan_> washawish: not really, how did you install your ghc?
14:48:21 <hackagebot> wol 0.1.0 - Send a Wake on LAN Magic Packet (TomLokhorst)
14:48:31 <washawish> I'm using ghc installed system-wide.  Should I install for myself?
14:48:57 <Saizan_> washawish: no, but your distro probably has the profiling libs in a separate package
14:49:18 <washawish> running Fedora Core 10. I'll look
14:51:55 <washawish> I see in /usr/lib64/ghc-6.10.1
14:51:57 <washawish> array-0.2.0.0/            extra-gcc-opts            haskell-src-1.0.1.3/      libHSrts_thr_debug.a      regex-compat-0.71.0.1/
14:51:59 <washawish> base-3.0.3.0/             filepath-1.1.0.1/         hpc-0.5.0.2/              mtl-1.1.0.2/              regex-posix-0.72.0.3/
14:52:01 <washawish> base-4.0.0.0/             ghc                       hsc2hs                    network-2.2.0.1/          runghc
14:52:03 <washawish> bytestring-0.9.1.4/       ghc-6.10.1/               hsc2hs-0.67/              old-locale-1.0.0.1/       stm-2.1.1.2/
14:52:05 <washawish> ...
14:52:49 <Baughn> "either show id . try" <- I'm going to hell for this.
14:53:39 <Baughn> washawish: Certainly looks that way, yes. I'd recommend uninstalling the system ghc and installing your own.
14:53:45 <Baughn> 10.1 had some severe bugs, too
14:54:04 <Saizan_> washawish: you need a file like libHSbase-4.1.0.0_p.a
14:54:08 <Saizan_> note the _p
14:54:26 <washawish> okay. thanks!
14:54:27 <Saizan_> but with a different version
14:54:32 <washawish> right
14:56:57 <copumpkin> it's been almost two weeks since wli last spoke :(
14:58:18 <dons> summer vacation?
14:59:32 <sjanssen> dons: more likely health/other bad situation from the gossip I've read in -blah
14:59:53 <dons> :/
15:06:33 <jmcarthur_work> eek
15:07:50 <copumpkin> I actually contacted his father but he didn't know anything, so we'll just have to wait
15:11:36 * sm thinks gtk2hs will happily configure without gtk installed, and then give the macro error I mentioned above
15:12:35 <dcoutts_> the gtk2hs configure script definately checks for the presense of the gtk libs
15:12:43 <dcoutts_> it calls pkg-config to check
15:18:06 <sm> dcoutts: I was getting "checking for GTK... no " and "following packages will be built:.. * gtk            : no"
15:18:29 <dcoutts_> sm: oh I guess they made even the gtk package optional
15:19:31 <kynky> you enable gnome useflag for gtk2hs ?
15:20:42 * sm thinks without it, the GTK_CHECK_VERSION tests used everywhere fail
15:21:14 <kynky> without it, dont think i was getting gtk stuff
15:21:32 <sm> kynky: oh ? enable it where.. during port install ?
15:22:06 <sm> or gtk2hs configure ? I will keep in mind
15:23:12 <kynky> forget where, did it by hand once, use gentoo ebuild now
15:24:21 <kynky> btw i dont use gnome, just gtk libs
15:25:14 <sm> ok. I don't want to use gnome either
15:26:23 <sm> well, it's much happier now. Strangely I did have a gtk2 port installed, 2.12, but gtk2hs configure didn't see it. After installing latest 2.16, it's seeing it
15:27:03 <kynky> :)
15:28:34 <CalJohn> is it possible that a forkIO will run on a different processor?
15:28:48 <CalJohn> or is that only DPH
15:29:02 <sm> now I see a few "<command line>: unknown package: glib-0.10.1" warnings, and make fails during Cairo
15:29:41 <copumpkin> CalJohn: definitely possible
15:29:47 <copumpkin> if you have more than one capability and more than one processor
15:30:42 <CalJohn> copumpkin: so if I have compiled with -threaded and am "+RTS -N2", and the program is all on one core, the problem is my programming?
15:30:59 <dcoutts_> CalJohn: the available parallelism is determined by the number of capabilities you use when you run the program, that's set by ./prog +RTS -N${n} -RTS
15:31:30 <dcoutts_> CalJohn: yes
15:32:30 <dcoutts_> CalJohn: or possibly in implementation issues in the rts. There have been a number of improvements since ghc-6.10 was released.
15:34:55 <dons> CalJohn: yeah. its an algorithmic/programmer issue
15:35:09 <dons> the rts has two cores fired up, but you're only giving it work for one.
15:35:16 <Saizan_> make sure you force evaluation in the right spots
15:35:41 <dons> two threads, doing work at the same time, will be split onto two cores, with -N2,as a rule.
15:35:48 <dons> via forkIO, or `par`.
15:35:52 <CalJohn> ah, my hunch is that my slow data structure and relatively small pieces of work are chocking the worker threads
15:35:59 <dons> unless you're OS doesn't support the second core
15:36:01 <Saizan_> e.g. if you writeChan or writeMVar without adding strictness you'll end up evaluating the values in the receiving thread
15:36:03 <dons> or is limited (e.g. OpenBSD)
15:36:18 <dons> CalJohn: compiling with +RTS -sstderr will give you stats about thread usage
15:36:22 <dons> with 6.10.3 or later, iirc
15:36:30 <dons> (or is that only the head?)
15:36:38 <Saizan_> running, rather than compiling
15:36:51 <dons> there's a new thread profiler in the head version of ghc too, for debugging these situations
15:36:52 <CalJohn> the OS is linux, so i'm guessing the second core is supported
15:37:34 <dons> should be fine, yep.
15:37:45 <dons> you can test with the hellworld multicore program on haskell.org
15:38:01 <dons> http://haskell.org/haskellwiki/Haskell_in_5_steps#Write_your_first_parallel_Haskell_program
15:38:05 <dons> $ time ./A +RTS -N2
15:38:05 <dons> 1405006117752879898543142606244511569936384005711076
15:38:05 <dons> ./A +RTS -N2  2.14s user 0.02s system 149% cpu 1.449 total
15:38:08 <dons> should be the result :)
15:38:54 <dons> ./A +RTS -N1  1.98s user 0.01s system 96% cpu 2.060 total
15:39:01 <dons> good test to make sure your ghc is fine.
16:06:39 <sm> victory! the gtk2hs release tarball worked better for me
16:08:08 <dons> sm: built agains the platform?
16:08:32 <sm> yes, I guess so.. on a mac with various ports installed
16:08:52 <sm> yes
16:09:07 <dons> yay
16:11:18 <jeffwheeler> @type sortOn
16:11:19 <lambdabot> Not in scope: `sortOn'
16:11:21 <jeffwheeler> @type sortBy
16:11:22 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
16:12:02 <jeffwheeler> > sortBy (comparing fst) [(2, "abc"), (1, "a"), (3, "d")]
16:12:04 <lambdabot>   [(1,"a"),(2,"abc"),(3,"d")]
16:12:55 <jeffwheeler> @hoogle comparing
16:12:56 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
16:12:56 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
16:13:40 <sm> now, leksah...
16:14:12 <sm> is it just me, or is http://tunes.org/~nef/logs/haskell/09.07.21 corrupt ? scrolling up from the bottom, it looks familiar for the first few screens, then shows stuff I don't remember
16:15:19 <Saizan_> 13:31:35 <MarcWeber> Anld api, some the new
16:15:24 <Saizan_> look at the timestamps
16:16:17 <periodic> Is there a name for the style I see in haskell a lot of lining up commas with the opening bracket in lists?  i.e. each element gets its own line, and elements except the first line have a comma in front?
16:16:27 <sm> aha, a hole in the log
16:16:30 <periodic> As opposed to the usual tradition of having the comma after the elements.
16:20:24 <MarcWeber> nominolo_: How do you do compile scion? I mean the error locations don't match because the subdir prefix is missing. So the error locations in vim are useless? Of course I can start changing current dir or such all the time ?
16:20:37 * soupdragon  
16:20:37 <jaredj> - anyone used TagSoup.Parsec a lot? i'm doing it wrong and i can't tell how
16:20:40 <copumpkin> lpsmith: that finite field question on your blog was odd
16:21:05 <copumpkin> oh wait, or was that not your blog
16:21:23 <copumpkin> anyway, you replied on it at least
16:22:20 <nominolo_> MarcWeber: Yes, it's a problem, you can only work on server or library, not on both.  More importantly the library needs to be registered in order to see any changes in the server
16:22:30 <lpsmith> copumpkin:  it was a legit question
16:22:38 <lpsmith> I'm not sure what's odd about it per se
16:23:35 <MarcWeber> nominolo_: So why not keep it as it was? Build both: server and lib using one cabal file?
16:23:59 <nominolo_> because the duplicate recompilation annoys me
16:24:06 <nominolo_> would be the same problem, btw.
16:24:07 <copumpkin> lpsmith: well for it to be a finite field it needs to be possible doesn't it?
16:24:19 <nominolo_> You can only have one component active at a time
16:24:28 <nominolo_> only the registering issue would go away
16:25:00 <MarcWeber> nominolo_: Why? If you import the lib files directly (using hs-source-dirs: lib) everything is up to date. Moreover if you only want to bulid the lib/ server you can use conditional cabal flags
16:25:36 <MarcWeber> It's bothering me all the time: I have to reconfigure my tagging system, the scion_server is not up to date, I have to write custom dummy makefile and whatnot.
16:26:14 <dcoutts_> nominolo_, MarcWeber: note that the next Cabal version lets you have a single cabal package containing a lib and an exe and have the exe depend on the lib
16:26:42 <nominolo_> dcoutts_: when will that come out?
16:26:51 <dcoutts_> nominolo_: before ghc-6.12
16:27:03 <lpsmith> copumpkin:  hmm... haven't thought about this aspect of algebra deeply for a little while now.    A finite field would always have an inverse...  And the technique as described obviously works for Z_p.   I kind of interpreted to be asking about the Galois Fields.
16:27:20 <MarcWeber> dcoutts_: *g* That's fine but.. How does it solve my problem right now? Each compilation step I have to wait some additional seconds..
16:27:51 <dcoutts_> MarcWeber: sure, it doesn't solve your problem right now unless you want to use the dev version of the tools
16:28:04 * kulakowski wonders what an inverse of a finite field is.
16:28:08 <MarcWeber> nominolo_: Why is there a lib at all ?
16:28:20 <kyagrd> Has anyone had a problem recently with yi?
16:28:26 <nominolo_> MarcWeber: because not everyone needs a server
16:28:28 <copumpkin> lpsmith: well it works for Z_p, and the fields of a given size are isomorphic, so it's possible in general, isn't it?
16:28:29 <lpsmith> Galois fields are rings of polynomials over Z_p, for some prime p,  modulo an irreducable polynomial to make it a field.
16:28:32 <nominolo_> MarcWeber: e.g., yi doesn't
16:28:34 <MarcWeber> dcoutts_: I'd like to start using dev tools again when scion works (module completion etc..)
16:28:59 <lpsmith> There is a finite field of cardinality p^k for each prime p and natural number k
16:29:04 <jdrake> As I recall, the Lambda Calculus tries to create an underlying basis for math. Like making a reasoning of the + operation. Likewise, is there a basis for the equal sign, or equality?
16:29:06 <copumpkin> lpsmith: dunno, I guess I don't really understand how his question was any different from the main blog entry besides being phrased differently, but I guess he was asking whether it was possible in the more general case?
16:29:15 <kyagrd> I am using 32 bit machine. and I got ... Binary: Int64 truncated to fit in 32 bit Int \n ghc: panic! (the 'impossible' happend)  :(
16:29:19 <MarcWeber> nominolo_: But even then it might be worth using one because ghc versions may be different
16:29:29 <kulakowski> copumpkin, lpsmith: I'm curious, could you give me a link to the blog post?
16:29:30 <copumpkin> kyagrd: sorry, that's impossible
16:29:38 <copumpkin> kulakowski: http://cdsmith.wordpress.com/2009/07/20/calculating-multiplicative-inverses-in-modular-arithmetic/
16:29:50 <copumpkin> lpsmith: and just to make sure, that isn't your blog, right?
16:29:54 <kyagrd> copumpkin: GHC can do a lot of impossible things
16:29:57 <MarcWeber> nominolo_: Anyway I think its reasonable to have a conditional flag then. So yi is an exception to the concept "one interface for all ?"
16:30:01 <copumpkin> kyagrd: but, but
16:30:03 <lpsmith> but yeah, the gcd algorithm works on polynomials too;  and so does the egcd
16:30:11 <copumpkin> yeah
16:31:14 <kyagrd> I installed the most recent distribution of cabalized Yi and got the impossible Int64 error message hmm
16:31:16 <nominolo_> MarcWeber: huh?  Yi calls scion code directly, that's why it doesn't need the server
16:31:21 <mmorrow> so has anyone written a blogging app in haskell yet?
16:31:34 <copumpkin> zomg blogz
16:31:37 <mmorrow> someone needs to do a quick hackjobber on gitit
16:31:40 <copumpkin> (no I don't think so)
16:31:44 <MarcWeber> nominolo_: Does it already provide scion support?
16:31:50 <MarcWeber> nominolo_: Should I ditch vim and use scion ?
16:31:58 <MarcWeber> s/scion/yi
16:32:00 <mmorrow> i wonder what it would take the morph wiki2blog
16:32:06 <mmorrow> s/the/to/
16:32:06 <lpsmith> I think a few people have written blogging software, though I don't think any of it is on hackage
16:32:12 <nominolo_> it's being worked on now
16:32:30 <copumpkin> http://lukeplant.me.uk/blog.php?id=1107301667
16:32:47 <nominolo_> MarcWeber: would that be better than Vim for you?
16:32:56 <copumpkin> doesn't look like that went very far though
16:32:57 <mmorrow> gitit's got the pandoc markup going on though
16:33:06 * mmorrow looks at link
16:33:18 <Saizan_> is there a script to automatically apply suggestions from hlint?
16:33:25 <conal> mmorrow: that'd be great!
16:33:26 <MarcWeber> nominolo_: At this moment: No because I'm used to many vim features I'll miss.
16:33:42 <nominolo_> MarcWeber: that's what I thought ;)
16:33:44 <copumpkin> I'd kind of enjoy something like jekyll in haskell with pandoc actually
16:33:51 <copumpkin> more than a dynamic blogging platform
16:34:05 <conal> copumpkin: what's jekyll?
16:34:06 <copumpkin> where jekyll = http://github.com/mojombo/jekyll/tree/master
16:34:09 <MarcWeber> nominolo_: At the moment I only want to fix the scion-server-vim stuff.
16:34:10 <conal> oh
16:34:11 <mmorrow> conal: i really like gitit, and i need to setup a blog..
16:34:27 <copumpkin> conal: a static site generator basically
16:34:32 <copumpkin> with markup and styles and so on
16:34:42 <MarcWeber> nominolo_: So when doing make and it tells me "Nothing to be done for `default'" has the lib been registered then?
16:34:52 <nominolo_> MarcWeber: yes
16:34:56 <copumpkin> I prefer that to having dynamic generation of pages. http://mark.reid.name/ uses it too
16:35:03 <lpsmith> gitit doesn't compile on Windows.
16:35:03 <mmorrow> copumpkin: interesting
16:35:16 <nominolo_> MarcWeber: unless the Makefile's dependencies aren't quite accurate.  Happens sometimes.
16:35:16 <mmorrow> lpsmith: windows?
16:35:19 <conal> i write all my blog entries my markdown.  would be happy to leave wordpress behind someday.
16:35:21 <mmorrow> lpsmith: ;)
16:35:33 <MarcWeber> nominolo_: Something is woring, I'm still getting "{\"version\":\"0.1\",\"id\":39,\"result\":[{\"library\":null}]}
16:35:42 <MarcWeber> I replaced the null by "" because vim doesn't like it.
16:35:48 <lpsmith> mmorrow: Honestly I prefer linux myself :-)   But in some situations,  you don't have a lot of choice
16:35:57 <nominolo_> MarcWeber: i.e., the wildcards might not be enough
16:36:12 <nominolo_> MarcWeber: did you add a new file?
16:36:15 <mmorrow> conal, pumpkin: ooh, yeah, actually now that i think about it that would be perfect. markdown->static-blog prog
16:36:25 <MarcWeber> nominolo_: I don't care. I'll create a new dir and will symlink lib and server into that directory. I'll create a stupid simple cabal file within that and try again. Then I'm happy
16:36:28 <mmorrow> kinda like that one perl one
16:36:30 <nominolo_> if so, try adding it to the dependencies explicitly
16:36:33 <MarcWeber> nominolo_: no
16:36:34 <copumpkin> mmorrow: jekyll is already quite nice, but having all the pandoc support would be wonderful
16:36:54 <copumpkin> when I finally get around to making myself a site I'm gonna use jekyll unless someone comes out with something better before
16:36:58 <mmorrow> copumpkin: do you know of any links to an example of it?
16:37:10 <nominolo_> MarcWeber: don't know how well git works with symlinks, but sure do it
16:37:15 <mmorrow> oh n/m found a link
16:37:49 <copumpkin> mmorrow: mark reid has the source of his site on github
16:37:56 <nominolo_> MarcWeber: I was hoping the current brokeness would motivate me to add the necessary features in scion ;)
16:37:58 <MarcWeber> nominolo_: I won't add those symlink to the repo. So git will only see the changed original files
16:38:36 <MarcWeber> nominolo_: Scion doesn't work for me. I can't use emacs because the viper mode breaks stuff such as c-h * commands
16:38:39 <lpsmith> jekyll doesn't support commenting though, does it?
16:38:56 * mmorrow is looking for an i-wonder-wut-i-can-hack-together-in-an-hour-maybe-two-and-havahaskell-blog
16:39:01 <conal> i'd still like to see markdown replace the markup language in haddock
16:39:27 <nominolo_> conal: yeah.  Though I'd even like some more features in markdown
16:40:49 <lpsmith> copumpkin:  Ok, I guess I see why that question is a little strage now.   The extended euclidean algorithm should be able to find inverses in polynomial rings too, when they exist
16:40:55 <conal> nominolo_: what would you like added?
16:41:20 <nominolo_> conal: though adding a dependency to haddock could be difficult since Haddock is now part of the GHC tree
16:41:32 <copumpkin> lpsmith: well, it just seemed to me like the blog post was answering his question (albeit indirectly) before he asked it in a comment, but I may have misinterpreted :)
16:41:41 * sm jumps through more hoops, swallows fire and builds leksah on mac! double victory!
16:41:51 <conal> nominolo_: hm -- that's awkward.
16:42:00 <lpsmith> Well, there are more finite fields than just Z_p  :-)
16:42:08 <nominolo_> conal: I'd like to see custom classes:  E.g., a paragraph stariting with "Note::" could get a class-tag.
16:42:11 <copumpkin> yeah, but the others are just isomoprhic to those
16:42:15 <nominolo_> conal: also, local anchors
16:42:18 <lpsmith> nope
16:42:19 <copumpkin> and egcd works on any commutative ring
16:42:28 <conal> nominolo_: i think local anchors are there.
16:42:28 <lpsmith> You also have the galois fields
16:42:36 <nominolo_> conal: in limited form
16:42:37 <conal> custom classes would be sweet
16:42:39 <conal> oh
16:43:05 <copumpkin> mmorrow, conal: http://github.com/mreid/mark.reid.name/tree/master is mark reid's jekyll site source
16:43:06 <nominolo_> I'd have to re-read the details, though
16:43:43 <copumpkin> lpsmith: hmm?
16:43:54 <copumpkin> (I'm pretty bad at algebra, it isn't a pointed question :P)
16:43:56 <sm> nominolo_: how about restructured text, which is a little more featureful
16:44:26 <lpsmith> There is one field, up to isomorphism,  of cardinality p^k too
16:44:41 <lpsmith> Basically,  start with the finite field Z_p
16:44:44 <MarcWeber> nominolo_: Hmm I just noticed that those keys work in viper insert mode! So it was my fault
16:44:48 <nominolo_> sm: I looked at it, but I couldn't find anything really like that.  Also, ReST is IMO harder to learn than Markdown
16:45:07 <lpsmith> copumpkin:  take the ring of polynomials over that
16:45:29 <sm> but cleaner imho.. it's just not as easy to embed html
16:45:33 <lpsmith> copumpkin:  choose any irreducable polynomial (there is guaranteed to be a few of each degree)
16:45:35 * sm reads above
16:46:10 <lpsmith> and then take the ring of polynomials (over Z_p)  modulo that irreducible polynomial,  and you have a Galios field :-)
16:46:27 <copumpkin> hmm
16:46:59 <copumpkin> lpsmith: I thought there was something saying that all finite fields of a given size were isomorphic
16:47:02 <sm> well, I know you can explicitly set classes in rst
16:47:08 <lpsmith> Of course, there are mutliple irreducible polynomials you could choose, but each possible choice results in an isomorphic field :-)
16:47:10 <lpsmith> Yes
16:47:15 <kulakowski> copumpkin: They are.
16:48:06 <nominolo_> sm: how?  I could use <div class="foo"> </div> in Markdown, but that's ugly
16:48:19 <nominolo_> sm: for Haddock it would need to be independent of HTML
16:49:12 <sm> absolutely. Well there's http://docutils.sourceforge.net/docs/ref/rst/directives.html#class , I don't know what other tricks it has
16:49:40 <sm> but you'd want some custom version that infers classes automatically
16:50:26 <sm> I know the python folks do that kind of thing with sphinx + rst
16:50:34 <lpsmith> copumpkin:   the thing is, the Z_p fields are only a subset of the finite fields,   and the only ones the blog post dealt with.
16:50:42 <copumpkin> true
16:50:47 <copumpkin> alright, I concede :)
16:51:39 <lpsmith> heh :-)
16:52:44 <ray> co-ncede
16:55:09 <lpsmith> Although,  doesn't a commutative ring need some additional assumptions before you can perform the (extended) euclidean algorithm?  I'm forgetting what they'd be...
16:57:52 <kulakowski> You can do the Euclidean algorithm over a Euclidean domain :)
16:58:13 <lpsmith> kulakowski:  ahh yes
16:58:43 <kulakowski> A (commutative) ring is a Euclidean domain if it has a function that generizes degrees of polynomials
16:58:56 <copumpkin> aha
16:59:10 <copumpkin> I really need to take an actual algebra course rather than learning from wikipedia :P
16:59:13 <copumpkin> or at least buy a book
16:59:17 <kulakowski> You can divide polynomials since you can divide them and always get a remainder with smaller degree, and by induction you will eventually get to a degree polynomail
17:01:18 <lpsmith> heh, wikipedia has it's pitfalls. So does MathWorld.   Both are generally pretty good;  but for example the list of results about Quadratic residues has a few mistakes
17:01:46 <lpsmith> Stemming from the fact that authors sometimes use slightly incompatible definitions of what a "quadratic residue" is
17:02:22 <kulakowski> I've seen a problem set that included the following: "There is an error in the wikipedia page for the Cayley-Hamiliton theorem. A) Find it. B*) Fix it."
17:03:52 <kulakowski> lpsmith: What ambiguities could there be in that definition?
17:04:24 <lpsmith> kulakowski:  it's been a few years since I found this;  maybe it's the wrong article.  (I'm referring to mathworld.)
17:05:06 <lpsmith> kulakowski:   basically having to do with an added assumption of whether or not a residue must also be relatively prime
17:05:23 <lpsmith> kulakowski:  IIRC,  as I said, my memory is a little fuzzy.
17:06:14 <kulakowski> Oh that makes sense, I normally only think modulo primes.
17:06:27 <lpsmith> ahah,  yes, it appears the MathWorld page on quadratic residues has been fixed, and now explicitly mentions the differing definitions
17:06:45 <lpsmith> http://mathworld.wolfram.com/QuadraticResidue.html
17:06:53 <lpsmith> It used to be wrong for that reason
17:10:34 <MarcWeber> dcoutts_: does cabal provide a way to load an executable into ghci for debugging purposes?
17:11:19 <mikesteele81_> I've got a data item that includes a type variable in it's definition.  There are only a few types this variable can actually be, so I've written functions to convert between them.  Is there any better way to go about this?  http://pastebin.com/d1e5d936
17:11:48 <dcoutts_> MarcWeber: not yet but there's an open ticket on it with a patch that needs reviewing
17:11:48 <lpsmith> Hmm... the lucky number sieve is a difficult one to do by hand.
17:11:50 <mikesteele81_> I thought about writing a Functor instance for it, but the type variables have class constraints so I can't seem to do that.
17:12:53 <jdrake> Can I change data Gene     = Number Integer  so that Integer is just a Integral?
17:13:25 <jdrake> I believe Integral is a typeclass where Integer is an instance of, might not have terminology right.
17:13:39 <copumpkin> mikesteele81_: a functor for what?
17:13:49 <aavogt> mikesteele81_: you could leave the Ord constraint out of the data declaration, and just leave it on with the functions that operate on it
17:14:03 <copumpkin> you still wouldn't be able to write a meaningful functor instance for it
17:14:09 <copumpkin> unless you used rmonad/functor
17:14:41 <lpsmith> So is anybody here familiar with the reverse state monad?
17:15:03 <copumpkin> I'd imagine luqui is
17:15:17 <SimonAdameit> Hi
17:15:47 <SimonAdameit> Is there a builtin function that will exchange the order of arguments of some function
17:15:56 <aavogt> @type flip
17:15:57 <SimonAdameit> so that I can use currying as i want
17:16:00 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
17:16:01 <SimonAdameit> thanks !
17:16:02 <lpsmith> copumpkin:  is that Luke Palmer?
17:16:06 <copumpkin> yup
17:16:10 <copumpkin> @seen luqui
17:16:11 <lambdabot> I saw luqui leaving #haskell-blah and #haskell 14d 1h 58m 23s ago, and .
17:16:17 <copumpkin> :o
17:16:26 <mikesteele81_> copumpkin: the functor would be for converting from one type to another.  I've got a (ContactInfo Name) and would like to convert it to a (ContactInfo FirstSortedName)
17:16:51 <copumpkin> mikesteele81_: oh, I'm not sure that really counts as a functor :)
17:16:55 <mikesteele81_> copumpkin: It would be nice to say ci01 `fmap` FirstSortedName
17:17:13 <aavogt> mikesteele81_: why can't you just get rid of the '(Ord name) => '
17:17:16 <lpsmith> I'm mostly curious if anybody has ever done something useful with the reverse state monad yet...
17:17:23 <copumpkin> lpsmith: fibonacci!
17:17:24 <mikesteele81_> copumpkin: Yes, I see that functors are more general than that.
17:17:43 <ozy`> the world suffers a dearth of fibonacci implementations in haskell
17:17:45 <mikesteele81_> aavogt: I need the Ord constraint so that I can sort lists of these data object.
17:17:59 <ozy`> as a good citizen you should do all in your power to write more
17:18:00 <aavogt> @type sort
17:18:02 <lambdabot> forall a. (Ord a) => [a] -> [a]
17:18:05 <copumpkin> ozy`: reverse fibonacci implementations!
17:18:12 <lpsmith> we need moar fibonacci implementationz!
17:18:13 <ozy`> GOD'S BLOOD!
17:18:19 <copumpkin> ozy`: what ended up happening to your textmate module for haskell?
17:18:29 <copumpkin> it was yours, right?
17:18:31 <ozy`> copumpkin: people stopped e-mailing me about it
17:18:32 <ozy`> yep
17:18:36 <copumpkin> :o?
17:18:41 <mikesteele81_> aavogt: My Ord instance for this data type relies on the type of one of its components.
17:18:46 <copumpkin> did you merge it back into the main svn/git?
17:18:49 <kyagrd> @type undefined sort
17:18:51 <lambdabot> forall t. t
17:18:53 <ozy`> copumpkin: yeah, it's been up there for ages
17:18:57 <copumpkin> oh ok :)
17:19:03 <ozy`> I'm the maintainer now
17:19:06 <copumpkin> ozy`: have you seen scion? :P
17:19:08 <kyagrd> @type sort undefined
17:19:08 <aavogt> instance Ord a => ContactInfo a where ...
17:19:10 <lambdabot> forall a. (Ord a) => [a]
17:19:12 <copumpkin> ozy`: ah nice
17:19:18 <kyagrd> hmm ...
17:19:19 <ozy`> copumpkin: I haven't been on freenode in a couple months
17:19:25 <aavogt> mikesteele81_: write it like that ^^
17:19:28 <kyagrd> @type (undefined sort)
17:19:30 <lambdabot> forall t. t
17:19:36 <aavogt> whoops
17:19:40 <kyagrd> Why???
17:19:40 <lpsmith> ozy`: fibonacci is a nice, simple example that's quite a bit more interesting than say,  factorial.
17:19:44 <aavogt> instance Ord a => Ord (ContactInfo a) where ...
17:19:54 <copumpkin> ozy`: http://github.com/nominolo/scion/tree/master would be pretty awesome to integrate
17:20:14 <ozy`> copumpkin: whooaa
17:20:16 <ozy`> this is heavy
17:20:18 <aavogt> @type \f -> sortBy (compare `on` f)
17:20:20 <lambdabot> forall b a. (Ord b) => (a -> b) -> [a] -> [a]
17:20:44 <copumpkin> ozy`: I also found a few instances where the grammar behaves strangely in textmate
17:20:52 <Axman6> ozy`: not talking about the TM Haskell bundle are you?
17:20:59 <Axman6> yes...
17:21:05 <ozy`> copumpkin: yes, there are significant issues which can only be fixed with a major rewrite
17:21:08 <ozy`> Axman6: yup
17:21:16 <copumpkin> ozy`: ah :/
17:21:21 <lpsmith> ozy`: because the pattern of recursion appears in other contexts,  and it invites dicussion a lot of generally useful approaches.
17:22:56 <mikesteele81_> aavogt: I've included my Ord instance at http://pastebin.com/d18cb48f4.
17:23:20 <ray> kyagrd: undefined :: forall a. a
17:23:34 <ray> that a can be anything, including a type with ->s in it
17:23:35 <mikesteele81_> aavogt: It sounds like you think there may be a way for me to relax the Ord constraint on Contactinfo.  Am I understanding you right?
17:23:55 <aavogt> mikesteele81_: yeah, just leave it out on the data declaration
17:24:11 <ray> :t undefined 1 2 3 4 5
17:24:11 <ozy`> lpsmith: good point, I'll be sure to quote you on /prog/ if the lurkers here don't beat me to it (you know who you are)
17:24:13 <lambdabot> forall t. t
17:24:14 <Axman6> ozy`: has any progress been make in the last little while?
17:24:28 <ozy`> Axman6: none whatsoever. I've been busy with other stuff
17:24:36 <Axman6> fir enough
17:24:40 <Axman6> fair too
17:24:46 <ray> the type can be anything you want, but the *value* is always _|_
17:24:54 <Saizan> mikesteele81_: btw, that can be written as compare = comparing cPriority `mappend` comparing cName `mappend` comparing cPhone
17:25:52 <mikesteele81_> Saizan: Thanks for the tip.
17:25:52 <aavogt> @type comparing
17:25:54 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
17:26:53 <aavogt> @type comparing fst `mappend` comparing snd
17:26:55 <lambdabot> forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Ordering
17:27:27 <Axman6> :t compare (undefined,undefined)
17:27:29 <lambdabot> forall a a1. (Ord a, Ord a1) => (a, a1) -> Ordering
17:28:21 <aavogt> @type mappend [(+1),(*2)]
17:28:23 <lambdabot> forall a. (Num a) => [a -> a] -> [a -> a]
17:28:42 <aavogt> @type (+1) `mappend (*2)$ 0
17:28:44 <lambdabot> parse error on input `('
17:28:52 <aavogt> @type (+1) `mappend` (*2)$ 0
17:28:54 <lambdabot> forall a. (Num a, Monoid a) => a
17:29:01 <aavogt> (+1) `mappend` (*2)$ 0
17:29:12 <aavogt> > (+1) `mappend` (*2)$ 0
17:29:17 <lambdabot>   Add a type signature
17:29:41 <copumpkin> @type mconcat (map Endo [(+1), (*2)])
17:29:42 <Saizan> no defaulting for Monoid, it seems
17:29:43 <lambdabot> forall a. (Num a) => Endo a
17:30:21 <Saizan> > (+1) `mappend` (*2)$ 0 :: Sum Int
17:30:23 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
17:30:23 <lambdabot>    arising fr...
17:31:39 * Saizan wonders why they didn't derive Num for Sum and Product
17:32:31 <Axman6> copumpkin: hey i don't suppose you've tried installing EclipseFP have you?
17:32:39 <copumpkin> nope, I don't touch Eclipse :P
17:32:55 <Axman6> righto
17:33:16 <Axman6> well, it's a total bitch to get installed. i couldn't follow the instructions
17:33:44 <Axman6> the reason i asked is because it uses Scion
17:36:05 <SimonAdameit> would someone be willing to help me with a little type error I don't know how to fix. I'm still a haskell newbie
17:36:15 <mikesteele81_> aavogt: changing my Ord instance to "instance forall a. (Ord a) => Ord (ContactInfo a) where ..." did allow me to remove the Ord constraint on the ContactInfo definition.  I'm now happily abusing Functors for convenient type conversion!
17:36:19 <jeffwheeler> SimonAdameit: no need to ask; just post it :)
17:37:56 <SimonAdameit> http://paste.lisp.org/display/83967
17:38:12 <SimonAdameit> there it is
17:40:18 <SimonAdameit> jeffwheeler: I dont even know if this would work at all
17:41:20 <sjanssen> SimonAdameit: "divides" only works on integral values, "sqrt" only works on floating values
17:41:28 <mikesteele81_> aavogt: Actually, this made the point of Existentially quantified types finally click.
17:42:37 <sjanssen> SimonAdameit: takeWhile (\p -> p*p <= n) -- will fix it
17:43:35 <athos> @hoogle (%)
17:43:37 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
17:54:43 <Axman6> SimonAdameit: using ps++[n] is not a good idea
17:54:48 <SimonAdameit> sjanssen: thanks
17:55:11 <Axman6> gives your code complexity of something like O(n^2) or O(n^3)
17:55:39 <sjanssen> SimonAdameit: also, this function will never return anything
17:56:15 <SimonAdameit> sjanssen: yeah, i noticed that :)
17:57:20 <Axman6> > let primes = 2:L.filter isPrime [3,5..]
17:57:22 <lambdabot>   not an expression: `let primes = 2:L.filter isPrime [3,5..]'
17:57:56 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = go primes where go (n:ns) = if n*n > x then True else 0 /= rem x n && go ns in primes
17:57:58 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:58:39 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = go primes where go (n:ns) = if n*n > x then True else 0 /= rem x n && go ns in primes !! 1000
17:58:41 <lambdabot>   7927
17:58:46 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = go primes where go (n:ns) = if n*n > x then True else 0 /= rem x n && go ns in primes !! 1000000
17:58:52 <lambdabot>   mueval-core: Prelude.read: no parse
17:58:52 <lambdabot>  mueval: ExitFailure 1
17:58:57 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = go primes where go (n:ns) = if n*n > x then True else 0 /= rem x n && go ns in primes !! 10000
17:59:01 <lambdabot>   104743
17:59:37 <aavogt> mikesteele81_: the forall a. isn't required (its there implicitly if you leave it off)
17:59:51 <copumpkin> > nubBy(((>1) .) . gcd) [2..]
17:59:53 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:00:25 <aavogt> mikesteele81_: as far as I can tell, you aren't using -XExistentialQuantification
18:00:36 <benmachine> copumpkin: impressive
18:00:46 <pikhq> copumpkin: Such a nice way of putting it. :)
18:00:47 <copumpkin> not mine, sadly :) but yeah, definitely impressive
18:01:08 <benmachine> I'd go with 2:[3,5..] personally, but I realise that's not quite as short
18:01:21 <copumpkin> ?
18:01:26 <benmachine> for the list
18:01:30 <aavogt> which would be like writing: data ContactInfo = forall name. Ord name => ContactInfo { ... }
18:01:31 <copumpkin> aw, why?
18:01:33 <pikhq> More efficient.
18:01:38 <benmachine> because you check half as many numbers
18:01:50 <copumpkin> oh but half of infinity is infinity! :P
18:01:55 <benmachine> heh
18:02:04 <copumpkin> :) j/k
18:02:24 <pikhq> Sure, if you calculate the whole thintg.
18:02:24 <lpsmith>  @src nubBy
18:02:34 <lpsmith> @src nubBy
18:02:35 <lambdabot> nubBy eq []             =  []
18:02:35 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:02:37 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = go primes where go (n:ns) = if n*n > x then True else 1 < rem x n && go ns in primes !! 10000
18:02:43 <lambdabot>   mueval-core: Prelude.read: no parse
18:02:43 <lambdabot>  mueval: ExitFailure 1
18:02:45 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = go primes where go (n:ns) = if n*n > x then True else 1 < gcd x n && go ns in primes !! 10000
18:02:51 <lambdabot>   mueval-core: Prelude.read: no parse
18:02:52 <lambdabot>  mueval: ExitFailure 1
18:02:57 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = go primes where go (n:ns) = if n*n > x then True else 1 < gcd x n && go ns in primes
18:03:02 <lambdabot>   mueval-core: Prelude.read: no parse
18:03:03 <lambdabot>  mueval: ExitFailure 1
18:03:08 <Axman6> :S
18:09:39 <athos> @pl \x -> (head x, length x)
18:09:39 <lambdabot> liftM2 (,) head length
18:09:57 <kyagrd> We have a non-English Haskell book now!!! http://www.daerim.net/new_20050605/books/view.asp?ISBN=9788972808183
18:10:17 <athos> @type head &&& length
18:10:17 <copumpkin> nice!
18:10:19 <lambdabot> forall c. [c] -> (c, Int)
18:10:27 <ray> neither english nor romanian!
18:10:33 <kyagrd> Korean translation of "Programming in Haskell" has been published (techically from next week, it will be availble on Korean bookstores)
18:10:47 <ozy`> ah, and it has the new logo and everything
18:10:50 <ozy`> sweet
18:11:17 <kyagrd> I heard that Japanese translation is in preperation.  I hope that goes well.
18:12:34 <daed> what are the best haskell books available?
18:15:35 <ozy`> daed: Real World Haskell is a good book to turn to once you've been baffled by the online Haskell tutorials
18:16:20 <pikhq> athos: Any idea why pl made that into liftM2 (,) head length instead of the much more readable head &&& length?
18:16:24 <pikhq> Seems rather weird to me.
18:17:09 <ozy`> pikhq: pl doesn't necessarily know all the useful synonyms
18:17:53 <daed> ozy; i'm fairly baffled after getting 80% through learnyouahaskell
18:18:12 <ozy`> daed: okay, then RWH is exactly what you need
18:18:28 <daed> nice, thanks
18:20:01 <jaredj> my tagsoup + tagsoup-parsec parser is a fail. :(
18:20:12 <pikhq> ozy`: Mmm.
18:20:59 * jaredj reads parsec source
18:21:19 <athos> @type \x -> (head x, 1 % length x)
18:21:21 <lambdabot> forall a. [a] -> (a, Ratio Int)
18:21:31 <athos> @type head x &&& (1%).length
18:21:33 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
18:21:33 <lambdabot>     In the first argument of `head', namely `x'
18:21:33 <lambdabot>     In the first argument of `(&&&)', namely `head x'
18:21:35 <athos> @type head &&& (1%).length
18:21:36 <lambdabot> forall c. [c] -> (c, Ratio Int)
18:22:20 <aavogt> @type Rational
18:22:22 <lambdabot> Not in scope: data constructor `Rational'
18:22:48 <athos> @kind Ratio
18:22:50 <lambdabot> * -> *
18:23:12 <athos> ,src 'Ratio
18:23:14 <lunabot>  luna: Not in scope: data constructor `Ratio'
18:23:35 <athos> ,src ''Ratio
18:23:37 <lunabot>  luna: Not in scope: type constructor or class `Ratio'
18:23:40 <athos> heh
18:24:00 <aavogt> athos: Ratio Int is probably just as bad as Double
18:24:18 <athos> oh why's that?
18:24:50 <aavogt> > sum $ map (1%) [1..500::Int]
18:24:52 <lambdabot>   78708388057927559 % (-783672953980813568)
18:25:08 <aavogt> overflow
18:25:13 <aavogt> > sum $ map (1%) [1..200::Int]
18:25:15 <lambdabot>   (-522215335737627603) % (-715213031013175168)
18:25:17 <athos> :)
18:25:19 <aavogt> > sum $ map (1%) [1..100::Int]
18:25:21 <lambdabot>   45396765440482621 % 397592878221798464
18:25:47 <athos> you're right, i just realize that i don't need 1%
18:25:56 <athos> negating should work, too
18:25:58 <athos> (:
18:26:10 <aavogt> how so?
18:26:38 <aavogt> @type recip . genericLength
18:26:41 <lambdabot> forall b b1. (Fractional b) => [b1] -> b
18:27:36 <athos> well, i'm abusing the law: if x > y then -x < -y (same holds true for if x > y then 1/x < 1/y)
18:28:37 <athos> i need some priority queue, but because i want to get something done and i don't want to spend too much time on it, i'm using some ugly hack like that (:
18:29:05 <athos> but nvm
18:29:18 <athos> thx for the advice of not using overflowing Ratio Ints :)
18:29:34 <aavogt> @hackage priority-queue
18:29:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/priority-queue
18:29:41 <dolio> There's a priority queue on the wiki in one of my ruby-quiz solutions.
18:29:48 <dolio> There's also a priority search queue on hackage.
18:30:02 <aavogt> maybe in edison?
18:30:10 <athos> dolio: thx :)
18:30:25 <dolio> Yeah, edison has the same priority queue as in my ruby-quiz solution.
18:30:32 <dolio> Since I cribbed it out of Okasaki's book.
18:31:38 <aavogt> why don't we use edison more frequently? Is it because the Sets and Maps in the base library are good enough?
18:31:46 <dolio> Priority search queues are slightly different. They require the things you're storing to be ordered, too (not just the priorities), but it maintains some kind of binary search tree invariant, too.
18:31:47 <athos> what is edison?
18:32:34 <dolio> It's a library of data structures.
18:32:53 <dolio> Written mostly by Chris Okasaki, author of Purely Functional Data Structures.
18:33:44 <athos> i see
18:34:19 <lpsmith> I like edison, but I think that the use of typeclasses to do what it does is less than ideal
18:35:06 <lpsmith> Also the maintainer changed some of the order of the arguments in ways I don't like.   I guess to be more consistent with the standard library.
18:35:12 <lpsmith> Data.Set and whatnot
18:36:09 <defun> The pdf containing the history of haskell is missing from the MS research website. Can any one point  me to another copy? Here is the original link: (http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf)
18:37:01 <dolio> Is the paper gone, or is the site just down?
18:37:05 <dolio> It seems to be down a lot.
18:37:30 <defun> the site is up, and says the page is missing.
18:37:54 <dolio> Maybe the site being down is just me then...
18:39:16 <defun> I will try again later.
18:41:15 <aavogt> defun: google caches a html version of that pdf
18:42:25 <cdsmithus> Suppose I have a function f :: A -> A, implemented in terms of primitives p_1 :: P1Data -> A -> A, ..., p_n :: PnData -> A -> A.  But it turns out that I am more interested in the sequence of primitive transformations used to get from the input to the result than I am in the actual result.  How would I modify the code to do this, without obscuring the form of the calculation too much?
18:45:00 * jdrake loves curry... perform Add = (+)
18:48:01 <cdsmithus> Was my question too abstract, or...?
18:49:06 <Saizan> cdsmithus: a bit
18:49:24 <twanvl_> f = foldr (.) id [p1 p1data,p2 p2data,..,pn pndata]
18:49:25 <aavogt> @type (.)
18:49:27 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:49:41 <cdsmithus> Okay, let me try again...
18:50:24 <Saizan> especially what you being more interested in the primitive transformations imply
18:50:42 <Saizan> that you want to get a list of those out of f?
18:51:22 <cdsmithus> Yes, precisely.  I already know the result of f (from a rather involved theorem).   But what I want is the sequence of primitive transformations applied to the input to get there.
18:51:43 <Saizan> mmh
18:51:54 <Saizan> i think i'd use a Writer monad
18:52:15 <Saizan> using [PrimitiveTransformation] as the monoid
18:52:16 <copumpkin> maybe a custom arrow instance? not sure though
18:52:21 <cdsmithus> Ah, that's what I thought... but it just seemed messy... I'm unsure that a monad is the right abstraction.
18:53:01 <jaredj> uhm - data Foo = Foo { one :: Int, two :: Int } what's that called?
18:53:15 <copumpkin> jaredj: haskell
18:53:25 <Saizan> it'll look like f = p_1 data >=> p_3 data >=> ...
18:53:35 <copumpkin> jaredj: ADT, data declaration, record
18:53:35 <bos> does anyone have erik meijer's email address?
18:53:52 <cdsmithus> In particular, with the Writer Monad, I could end up with something like: f x = do { a <- tryThis x; b <- tryThat x ; if a `betterThan` b then return a else return b }... and the sequence of operations will be wrong.
18:53:59 <Axman6> @hoogle Handle
18:54:00 <lambdabot> System.IO data Handle
18:54:00 <lambdabot> Control.Exception handle :: (Exception -> IO a) -> IO a -> IO a
18:54:00 <lambdabot> Control.Exception handleJust :: (Exception -> Maybe b) -> (b -> IO a) -> IO a -> IO a
18:54:46 <Axman6> jaredj: it's recoed syntax
18:55:00 <petekaz> Anyone recently read RWH ch 6 Using typeclasses?
18:55:02 <Botje> bos: google suggests erik@cs.uu.nl
18:55:16 <bos> Botje: he hasn't been there for years, alas
18:55:20 <twanvl_> cdsmithus: do you want to forget about the b altogether? or do you want to remember that a is better than it?
18:55:21 <Saizan> cdsmithus: ah, right
18:55:28 <Botje> ah
18:56:19 <cdsmithus> teanvl_: in that case, if f x = a, then I want only the sequence of operations that results in a, and none of the operations that gave b.
18:57:33 <cdsmithus> So, I suppose I really want a type like: data WithOps a = ([PrimOp], a), and functions to lift calculations into that type... is there a name for that kind of thing, or do I just do it.
18:58:02 <twanvl_> cdsmithus: lifting sounds right
18:58:03 <jdrake> How can I protect against divide by zero? I would prefer to deal with the exception rather than make sure an invalid one doesn't happen.
18:58:10 <bos> petekaz: what's up?
18:58:33 <Saizan> something like Applicative, but more expressive if you want if/then/else like that
18:58:36 <CalJohn> jdrake: use (/)? :p
18:58:45 <jdrake> :t (/)
18:58:47 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:58:56 <CalJohn> > 1 / 0
18:58:57 <jdrake> Can't use that, only div
18:58:58 <lambdabot>   Infinity
18:59:25 <Axman6> > 1 `div` 0
18:59:27 <lambdabot>   * Exception: divide by zero
18:59:28 <petekaz> bos: trying to understand the motivation of using the JSON typeclass, I fail to see the value of defining it vs just using the JValue type.
18:59:36 <CalJohn> i don't know who decided to make (/) like that, or why, but i like their style.
18:59:48 <twanvl_> you can still use the writer monad for some things, and just lift out the if/then/else:   let a = tryA; b = tryB;  if getThing a `betterThan` getThing b then a else b
18:59:49 <cdsmithus> Saizan: Okay, this is going along with what I had in mind... in particular, I figured it looked like a functor, but I never have bothered to figure out what is and isn't an applicative functor.
18:59:59 <copumpkin> CalJohn: blame the IEEE 754 people
19:00:05 <jdrake> Does 1/0 actually = inf?
19:00:09 <CalJohn> jdrake: yes
19:00:12 <bos> petekaz: so you can convert to and from regular haskell types
19:00:13 <ray> well
19:00:17 <CalJohn> copumpkin: how so?
19:00:18 <ray> it depends on a lot of things
19:00:20 <copumpkin> jdrake: in ieee 754 land they do
19:00:40 <ray> there's no such number as "infinity", but the limit of 1/n as n approaches 0 is infinite
19:00:40 <copumpkin> jdrake: normally you'd say that the limit as the denominator tends to zero is grows unboundedly large though :P
19:00:44 <ray> if you add a point at infinity!
19:00:45 <petekaz> bos: it seemed to imply that it's cumbersome to write something like: JArray [ JString "blah", JString "foo" ] vs JArray [ toJValue "blah", toJValue "foo" ]
19:00:50 <ray> then n/0 is infinity
19:00:52 <jdrake> ray, I am well aware of limit :p
19:00:57 <ray> that is, it's the point at infinity
19:00:58 <CalJohn> copumpkin: oh, i see why
19:01:12 <Saizan> cdsmithus: i'm not actually sure it fits in applicative
19:01:20 <bos> petekaz: the difference is that you can easily make an arbitrarily complicated haskell type an instance of JSON
19:01:23 <ray> also, freakin' ieee 754, man
19:01:33 <bos> petekaz: which would take a lot of manual serialization
19:01:50 <copumpkin> cdsmithus: have you considered Arrow?
19:02:02 <kulakowski> > 1/(-0) -- and there is also negative zero and negative infinity
19:02:04 <lambdabot>   -Infinity
19:02:39 <cdsmithus> copumpkin: no, I'll take a look at that, if you think it might fit.  Another of those abstractions I never got around to understanding.
19:02:52 <ray> that can also work out if you use reals plus 2 points at infinity
19:02:53 <petekaz> bos: That makes sense, thanks!
19:03:08 <kulakowski> > 0/0 -- don't forget these
19:03:08 <daed> forgive the noob question: f . g = \x -> f (g x)
19:03:09 <ray> floats aren't reals though - they're barely even numbers
19:03:10 <lambdabot>   NaN
19:03:14 <copumpkin> cdsmithus: I'm not positive it'll help, but it sort of generalizes a function, and it may be possible for you to make it so that your functions pass around evidence of their having been applied
19:03:16 <daed> what's the point of the backslash in \x
19:03:21 <ray> that is a lambda
19:03:40 <ray> we use a backslash because that's on our keyboards and, usually, lambda isn't
19:03:49 <jaredj> λ
19:03:50 <daed> ahh gotcha :)
19:03:52 <jaredj> :)
19:03:57 <jdrake> λ
19:04:09 <jaredj> aw. i miss half-life 2.
19:04:09 <jdrake> αβψδεφγηιξκλμνοπ;ρστθωςχυζ
19:04:11 <kulakowski> and we don't like typing `lambda' all the time when one character will do
19:04:12 * copumpkin wants that in UnicodeSyntax dammit
19:04:14 <impl> do those Symbolics keyboards from the 80's have lambda keys?
19:04:21 <purplepenguins> lambdas are a nice way of expressing functions without having to name them
19:04:49 <jdrake> It would be nice to be able to use λ for \ :p
19:04:50 <kulakowski> copumpkin: Was the problem that lambda is a letter so it can't know whether you mean a variable or a \ ?
19:04:56 <copumpkin> kulakowski: yeah :/
19:05:07 <copumpkin> I think it'd be worth stealing its letterness :P
19:05:12 <jaredj> i agree
19:05:24 <pikhq> Definitely.
19:05:47 <ray> if only unicode had a lambda -symbol version-
19:06:15 <kulakowski> Would doing so just break the single character λ as a variable name, or would it necessarily break anything that starts with it too?
19:06:40 <impl> http://upload.wikimedia.org/wikipedia/commons/4/47/Space-cadet.jpg
19:06:48 <impl> Keyboard of the gods.
19:06:53 <ray> probably anything that starts with it, because you can do \name -> blah blah blah
19:07:05 <copumpkin> kulakowski: depends how much work you want to spend on fixing up the grammar :P
19:07:24 <Vanadium> \λ ->
19:07:30 <petekaz> bos: great book! taking it on my vacation next week so I can make some real progress!
19:07:32 <kulakowski> copumpkin: That's sort of what I figured.
19:07:43 <bos> petekaz: thanks!
19:08:09 <kulakowski> I guess the best solution is to only make pointless legal.
19:08:36 <jdrake> apple wireless pro is keyboard of the gods
19:09:07 <kulakowski> All keyboards suck. It's nearly 2010, the computer should interface directly with my brain by now, instead of through my fingers and eyes
19:11:04 <jaredj> or at least they should have thousands of keys, like that one in Ghost in the Shell
19:11:30 <mike-burns> I at least want focus-follows-eye.
19:12:21 <CalJohn> impl: yes, they also had capital lambdas (and most other greek letter)
19:12:57 <CalJohn> space cadets had all sorts of shit on them.  there were about 5 modifiers, or so sayeth the jargon file
19:13:17 <jaredj> -> emacs evil
19:13:21 <kulakowski> supposedly 8k characters
19:13:40 * impl wonders how hard it would be to find/buy one
19:13:47 <kulakowski> At that point why not take it to the logical limit. an n key keyboard, with n-1 shift keys
19:14:08 <CalJohn> impossible to buy them now, they are probably museum pieces, and besides, they don't exactly use ps/2
19:15:05 <jaredj> kulakowski: generalized chording would get you closer to there, but be less annoying
19:15:11 <kulakowski> You need only hit the correct combination of shift keys, and then the non-shift key and your program is uniquely determined
19:15:36 <kulakowski> or rather a universe containing
19:15:50 <kulakowski> a computer which already has on it the program you want, if you take sufficiently many keys
19:16:04 <impl> CalJohn: I'm sure you could hack it with a small microprocessor to work
19:16:07 <lpsmith> I'd go for generalized chording.  However that eliminates the possibility of a terminal-based interface
19:16:11 <CalJohn> kulakowski: well, there are probably a lot more permutations on a space cadet than that, but then, if you have a keyboard that can depress any/all buttons at the same time, you have about 100^100 possible characters
19:16:50 * benmachine adds a key to his keyboard and writes "develop sentience" on it in biro
19:16:56 <jaredj> lpsmith: not necessarily. terminals don't produce keycodes, they produce characters, right?
19:17:12 <CalJohn> impl: i'll carry on with "\" :p
19:17:23 <impl> haha
19:17:28 <jaredj> the problem with any cool keyboard is, everyone else's computer doesn't have it
19:17:34 <impl> I surely don't want one with /practical/ value
19:17:39 <impl> s/with/for/
19:17:59 <kulakowski> CalJohn: How n^n and not 2^n? (Not that it makes much of a difference.)
19:18:22 <lpsmith> well,  as far as I know,  they can't do key-up and key-down events.
19:18:38 <jaredj> less than 2^n - depending on how dexterous you are and the number and length of your fingers
19:18:54 <lpsmith> and I think they do characters, not keystrokes, yes
19:19:03 <CalJohn> kulakowski: i was groping for a way to find out all the possible permutations of 100 binary keys
19:19:18 <kulakowski> oh permutations
19:19:24 <CalJohn> kulakowski: meatbag limitations notwithstanding
19:19:51 <lpsmith> to implement general chording you really want key-up and key-down events
19:20:02 <jaredj> well -
19:20:13 <jaredj> and you need some way to deal with typing mistakes...
19:20:43 <jaredj> some of the quickest chords would be adjacent letters - but so would be most of the typos
19:21:00 <CalJohn> "dude, you hit ultra-super-mega-shift a!  you need to hit mega-shift-ultra-super a!"
19:21:10 <CalJohn> imagine the fun mit had
19:21:15 <lpsmith> why not control-a-b-c?
19:21:41 <jaredj> actually it might be cool if you put control keys where f and j are
19:21:42 <lpsmith> not all the multi-chords would need to be entirely based on key modifiers plus one "character" key
19:21:55 <jaredj> Ctrl-Y would suddenly be easy to type one-handed
19:22:47 <allbery_b> control-meta-hyper-cokebottle?
19:23:08 <CalJohn> jaredj: C-p to print is the one that really drives me insane.  it must be the single most common key-chord after C-v
19:23:58 <aavogt> @quote trees
19:23:59 <lambdabot> mauke says: trees are hierarchical
19:24:05 <jaredj> i picked on C-y because it's the sort of combo you can try to type with one Ctrl key, fail, try with the other Ctrl key, and not do much better
19:24:35 <mike-burns> I can do C-y just fine with the right one, on my laptop.
19:24:41 <aavogt> same
19:24:44 <impl> oh German keyboards, the y and z keys are switched
19:24:52 <jaredj> oh right
19:24:52 <benmachine> I can do ctrl-p with left ctrl on my laptop >_>
19:24:59 <jaredj> oy
19:25:05 * benmachine may have large hands
19:25:48 <ozy`> benmachine: I have small hands and I can do ^P on mine
19:26:19 <kulakowski> Anyone else have capslock as control?
19:26:25 <mike-burns> Sure do.
19:26:36 <CalJohn> ^ tried that for a while, got it wrong so many times i gave up
19:26:37 <jaredj> kulakowski: i have it as Mod3 and use it for xmonad hotkeys, w00
19:26:44 <benmachine> no I have capslock as useless vestigial key that is only ever pressed by accident
19:27:09 <mike-burns> I'm trying to figure out what other key can be ESC (I'm a vim user), but I haven't found anything good yet.
19:27:32 <kulakowski> jaredj: I thought about that, but I just use windows/mod4 for that, since I hit control much more than xmonad keys
19:27:54 <kulakowski> mike-burns: maybe one of the right control/alt/super/menu keys?
19:28:09 <mike-burns> Oh, right alt is a good pick.
19:28:22 <CalJohn> mike-burns: the thing is, as far as vim goes, ESC is quite nice
19:28:28 <mike-burns> Huh never noticed that menu key before.
19:28:38 <jaredj> kulakowski: i picked up from an older hacker friend the habit of pressing Ctrl with my left pinky knuckle, which i think is great
19:28:40 <mike-burns> ESC is nice but after 8 hours I just don't want to reach that far.
19:29:12 <jaredj> kulakowski: except on laptops, where Fn is frequently in the corner not Ctrl, or the keyboard bezel is as high as the Ctrl key
19:29:15 * CalJohn gets driven nuts by hitting C-x C-s when he uses vim to edit 1 file and freezing the terminal
19:29:34 <mike-burns> Ha, yeah.
19:30:13 <jaredj> CalJohn: i used to get driven nuts when editing text fields in Firefox, using C-w to delete a word, but closing the window
19:30:24 <kulakowski> jaredj: I might have to try that. Except if I change things again I want to change a lot. Like making numbers need to be shifted and !@#$% etc more logically laid out
19:30:30 <jaredj> oo
19:30:38 <mike-burns> Oh that's nice.
19:30:39 <CalJohn> jaredj: yeah, i get the exact same thing.  why do i have to memorise 3 different keybinding systems?
19:30:44 <jaredj> yeah eh?
19:31:12 <jaredj> i tried using emacs, thinking that with my bash line editing knowledge i'd turn out all right
19:31:24 <jaredj> but i can't use emacs shortcuts on a whole screen, my brain uses vim keys instead :)
19:32:18 <mike-burns> I wish windowing systems had developed such that every text area could be either an emacs or a vi area, and you could configure globally which would appear for you.
19:32:26 <jaredj> that would rock.
19:32:34 <kulakowski> Actually I might switch {} to something unshifted now
19:32:40 <CalJohn> mike-burns: squeak has that...but, yeah.
19:32:42 <jaredj> gvim is embeddable, actually
19:33:16 <jrick> kulakowski: my capslock is a backspace :)
19:33:33 <kulakowski> jrick: ^H, or don't make mistakes :)
19:33:41 <jaredj> e.g. there exists a gvim-evolution binding so the text editor in the evolution compose window is a gvim
19:33:49 <mike-burns> Oh that's awesome.
19:33:50 <jaredj> unfortunately this is not widespread
19:34:12 <mike-burns> There are tricks to get it for FF and evolution and so on, but widespread is my dream.
19:34:27 * CalJohn used to use vim for firefox
19:34:32 <jaredj> (this is the tack that vim takes, in opposition to emacs' tendency to integrate other programs inside itself)
19:34:34 * CalJohn also gave up
19:34:38 <jaredj> mike-burns: hear hear
19:34:55 <CalJohn> jaredj: s/integrate/assimilate
19:35:01 <mike-burns> CalJohn: Did you also try vimperator?
19:35:25 <CalJohn> i vaguely recall doing that, but my mind was very frazzled with all the keybindings
19:35:25 <jrick> uzbl is awesome
19:35:28 <jaredj> ^. there was some little sticking point that killed it for me
19:36:03 <mike-burns> uzbl looks sick; I intend to try it any day now.
19:36:18 <jaredj> ooo
19:36:21 <kulakowski> I didn't have any problem using vimperator, but then I am not the sort of person that has 2^20 tabs open, so I didn't really need to know those keybinds to survive at first
19:36:32 * kulakowski wants uzbl but written in haskell
19:36:53 <mike-burns> Is there a Haskell binding for Webkit already?
19:37:55 * jaredj thinks of a name for that
19:37:57 <ozy`> I seriously doubt it
19:38:05 <kulakowski> mike-burns: I don't believe so, I remember looking when I first found out about uzbl, and couldn't find anything
19:38:06 <Nafai> kulakowski: Yes!  That would rock!
19:38:18 <Nafai> I would actually use it
19:38:19 <jaredj> Hebkit
19:38:24 <mike-burns> Heh.
19:38:30 <jaredj> seems... hebrew
19:39:01 <jaredj> Hwebkit: the binding you spit to pronounce
19:40:02 <CalJohn> (wouldn't actually want to write any GUI code in haskell)
19:40:09 <kulakowski> It seems like it wouldn't be *that* hard to hack something ugly together, but I have no idea how well documented webkit is or anything like that
19:40:21 <Nafai> CalJohn: It's actually not too bad, I like it.  I've done a big with gtk2hs
19:40:29 <mike-burns> I love writing GUI code in Haskell, more than I've enjoyed it in anything else.
19:40:44 <Nafai> kulakowski: It would be nice, you could make an architecture like xmonad so we could write plug-ins and stuff in Haskell :)
19:41:34 <kulakowski> Nafai: that's essentially what I had in mind. An entirely haskell-scriptable browser.
19:42:08 <jrick> mike-burns: just fyi, the freebsd webkit port is too old for uzbl, so you will need to either build a newer version, or there's a patch for 1.1.7 somewhere
19:42:28 <mike-burns> jrick: Ah, I was afraid of that.
19:42:37 <mike-burns> (Thanks for the heads up, too.)
19:43:11 <Nafai> kulakowski: awesome
19:44:20 <mike-burns> If anyone going to HacPhi wants to lead a Web browser-in-Haskell project I'll gladly contribute my n00b knowledge to it.
19:45:11 <kulakowski> Most of the documentation i've seen about webkit has been very safari-oriented though (mostly, how to build a safari with nightly webkit builds)
19:46:08 <mike-burns> I wonder if following the Ephiphany source code is a decent replacement for Webkit docs.
19:46:16 <jrick> mike-burns: http://freebsd.monkey.org/freebsd-ports-bugs/200905/msg01262.html
19:46:19 <jrick> that's what I'm using
19:46:38 <kulakowski> Yeah I was thinking about that, or arora/midori/etc. webkit is cool now so there's like 8 of these projects already
19:46:39 <jrick> it required a bit more manual fixes to make it work
19:46:40 <mike-burns> Word.
19:46:55 <jrick> mike-burns: actually, I can just tar up my webkit port and send that to you if you want
19:47:24 <mike-burns> kulakowski: http://webkitgtk.org/reference/index.html - just stumbled across this. Not sure if this helps.
19:47:45 <mike-burns> jrick: I don't have time to play with Webkit this week, but that'd be awesome.
19:47:47 <hackagebot> stb-truetype 0.1 - A wrapper around Sean Barrett's TrueType rasterizer library. (BalazsKomuves)
19:48:30 <mike-burns> jrick: Send it to mike at mike-burns.com please.
19:48:57 <jrick> mike-burns: ok
19:49:57 <vyom> I am doing these intermediate exercises : http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/ Need help with Ex. 6 Line 34..
19:50:10 <vyom> I cannot figure out how to get type a out of m a
19:51:32 <taruti> What is the correct way to specify an include file shipped with the package in Cabal?
19:51:33 <SamB> vyom: that's normal
19:51:39 <SamB> you can't ;-)
19:51:45 <dibblego> vyom, you should use the banana and unicorn functions to implement it
19:51:51 <jrick> mike-burns: sent
19:52:06 <SamB> dibblego: what paper talks about unicorn functions?
19:52:07 <mike-burns> jrick: Thanks!
19:52:11 <jrick> np
19:52:21 <taruti> It complains on Windows in Setup configure that it is missing the header file that sits in the directory
19:52:25 <ManateeLazyCat> How to transform Integer to Int ? Thanks!
19:52:42 <aavogt> @type fromInteger
19:52:44 <lambdabot> forall a. (Num a) => Integer -> a
19:52:45 <jaredj> SamB: they're part of the class inside which the exercise happens
19:52:52 <ManateeLazyCat> @hoogle "Integer -> Int"
19:52:52 <lambdabot> Parse error:
19:52:53 <lambdabot>   --count=20 ""Integer -> Int""
19:52:53 <lambdabot>              ^
19:53:03 <aavogt> @hoogle Integer -> Int
19:53:04 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
19:53:04 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
19:53:04 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
19:53:05 <ManateeLazyCat> aavogt: Thanks!
19:53:22 <vyom> dibblego:  I figured that much. Still cannot hit upon the solution.. any hints?
19:54:02 <dibblego> vyom, it's a bit hard to give a hint without giving the answer -- consider that signature of banana which is almost the same as furry
19:54:20 <SamB> dibblego: are you sure that "Misty m => (a -> m b) -> m a -> m b" is the correct type banana?
19:54:23 <SamB> +for
19:54:36 <vyom> dibblego: heh.. in that case I will need an answer pretty soon
19:54:44 <dibblego> SamB, yes
19:54:57 * SamB checks the paper
19:55:09 <dibblego> @type (=<<)
19:55:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:55:15 <aavogt> ManateeLazyCat: fromIntegral has a more general type, and seems to be used more commonly (ie. fromIntegral can do a Word8 -> Int8 conversion)
19:57:08 <vyom> dibblego: ok i give up.. can you give me the answer please..
19:57:09 <SamB> In the notation of Bird&Wadler [5] one would write h = foldr b (⊕). We write catamorphisms by wrapping the relevant constituents between so called banana brackets:
19:57:10 <SamB>                                        h = (| jb; j |)                                       (2)
19:57:22 <mike-burns> Wrong bananas.
19:57:26 <SamB> dibblego: so it looks like you've got the wrong type!
19:57:37 <dibblego> SamB, not that banana :)
19:57:43 <benmachine> heh
19:57:47 <SamB> now pick a name that wasn't already taken!
19:58:02 <mike-burns> Hasn't every name been taken?
19:58:10 <dibblego> vyom, consider (a -> m b) -> m a -> m b then consider (a -> b) -> m a -> m b
19:58:23 <SamB> by a Haskelloid function, at least ;-)
19:58:24 <dibblego> vyom, the only difference is where one uses "m b" the other uses "b"
19:58:27 <taruti> hmm, found it
19:58:34 <dibblego> vyom, how to get from "b" to "m b"?
19:58:42 <dibblego> vyom, unicorn :: b -> m b
19:59:05 * SamB has to admit that unicorn is a better name than the usual one for that function
19:59:08 <ray> hehe, unicorns are pure
19:59:13 <ray> nice one
19:59:41 <SamB> dibblego: why didn't you call the class Fuzzy?
19:59:58 <gwern> c@seen shacaf
20:00:00 <gwern> @seen shacaf
20:00:00 <lambdabot> I haven't seen shacaf.
20:00:01 <dibblego> I hate thinking of names
20:00:07 <gwern> @seen shachaf
20:00:07 <lambdabot> shachaf is in #haskell, #concatenative, #xmonad, #haskell-blah, ##logic, #perl6, #scala, #haskell-in-depth and #haskell-iphone. I last heard shachaf speak 21h 51m 26s ago.
20:00:32 <SamB> dibblego: you know, since we ought to have called them "warm fuzzy things" rather than "monads"
20:02:37 <jrick> mike-burns: hm, you may want to rm those .orig files, although I never had any problem building it with them
20:02:52 <mike-burns> Seems to be building just fine with them.
20:04:48 <SamB> dibblego: also, why isn't Fluffy a superclass of Misty?
20:05:03 <benmachine> SamB: isn't it?
20:05:08 <benmachine> well
20:05:11 <benmachine> not explicitly I guess
20:05:18 <dibblego> SamB, so that the student can write fluffy and observe that relationship themselves
20:06:25 <SamB> ... that's a better excuse than SPJ has ...
20:09:38 <taruti> What is the correct way to detect a threaded rts at runtime in GHC?
20:16:54 <vyom> dibblego:  this managed to compile fine : furry' fnAtoB = banana (unicorn . fnAtoB) is that right?
20:17:39 <dibblego> vyom, looks perfect
20:18:20 <vyom> dibblego:  thanks.. the basic concept that I was not able to grasp earlier was that of partial application.. I was trying to two arguments and contruct something
20:18:36 <dibblego> furry' fnAtoB x = banana (unicorn . fnAtoB) x
20:18:43 <dibblego> that also works
20:18:49 <vyom> vyom:  ah ok
20:21:50 <taruti> found it
20:25:26 <aavogt> @index comparing
20:25:27 <lambdabot> bzzt
20:25:50 <aavogt> @hoogle comparing
20:25:50 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:25:51 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:26:23 <CalJohn> is there a way to desugar do?  so that I can see the exact >>='s and return's
20:26:31 <ray> try @undo
20:27:46 <ray> @undo do {x <- [1,2,3]; y <- [4,5,6]; return (x+y)}
20:27:47 <lambdabot> [1, 2, 3] >>= \ x -> [4, 5, 6] >>= \ y -> return (x + y)
20:28:06 <monochrom> taruti: perhaps Control.Concurrent.rtsSupportsBoundThreads is equivalent asking about a threaded rts.
20:29:27 <CalJohn> ray: yes, that is almost exactly the issue i'm trying to figure out
20:29:45 <CalJohn> > [1, 2, 3, 4, 5] >>= \ x -> guard (x * x * x == 125) >> return (x)
20:29:47 <lambdabot>   [5]
20:30:46 <Trinithis> @faq Can lambdabot club baby seals?
20:30:46 <lambdabot> The answer is: Yes! Haskell can do that.
20:30:51 <Trinithis> oops
20:32:14 <inimino> but it chooses not to
20:35:16 <taruti> monochrom: yes, that appears to work.
20:35:32 <monochrom> Neat.
20:36:42 <dolio> @undo [ x + y | x <- [1, 2, 3], y <- [4, 5, 6] ]
20:36:42 <lambdabot> concatMap (\ x -> concatMap (\ y -> [x + y]) [4, 5, 6]) [1, 2, 3]
20:42:40 * CalJohn finally figured out how the list monad works for non-determinism!
20:47:15 <vyom> dibblego: if you are still around.. could you help me with exercise 3.. I have no idea what ((->) t) means
20:47:35 <dibblego> vyom, do you know what (t -> r) means?
20:48:05 <vyom> dibblego:  it is used in case statements while pattern matching.. thats about all i know
20:48:25 <dibblego> no, it's a type -- it means a function from 't' to 'r'
20:49:35 <vyom> dibblego: u mean the -> symbol used in case statements is unrelated to this?
20:49:53 <dibblego> vyom, yes, that's a different use of ->
20:50:01 <vyom> dibblego: ok
20:50:07 <dibblego> vyom, consider the type of furry :: (a -> b) -> m a -> m b
20:51:10 <copumpkin> dibblego: do you know the names of those functions you made up by heart? :P
20:51:26 <dibblego> copumpkin, nope :0
20:55:03 <vyom> dibblego:  so does that mean ((->) t) is a type of function that *returns* a result of type t ?
20:56:03 <copumpkin> it's a "type function" (a type constructor actually) that takes a type and returns a type
20:56:13 <aavogt> @type (,) 1
20:56:16 <lambdabot> forall t b. (Num t) => b -> (t, b)
20:56:33 <aavogt> confusingly, t should be on the right side
20:56:46 * aavogt means left side
20:57:16 <aavogt> so its the type of functions from t, to some other type that isn't applied
20:57:22 <vyom> aavogt: ok got that.. infix notation
21:07:37 <vyom> dibblego:  Could you give me a solution for Ex. 3. I tried http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3071#a3071 but I get a parse error
21:11:10 <vyom> anyone else? I am trying to get through the Haskell exercises http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/ Ex. 3 posted above gives parse error
21:13:23 <copumpkin> ack no :)
21:13:49 <copumpkin> you can't write type functions like that in haskell
21:13:58 <copumpkin> as haskell has a very strict divide between types and values
21:14:25 <copumpkin> what's the signature of furry?
21:14:45 <copumpkin> I'll expand it out for the instance you need to write, which might help
21:14:54 <vyom> copumpkin:  furry :: (a -> b) -> m a -> m b
21:14:57 <copumpkin> aha
21:15:05 <copumpkin> so for ((->) a)
21:15:10 <copumpkin> that's
21:15:42 <copumpkin> (a -> b) -> ((->) c a) -> ((->) c b)
21:15:48 <copumpkin> which is just
21:15:57 <copumpkin> (a -> b) -> (c -> a) -> (c -> b)
21:16:15 <copumpkin> does that remind you of anything?
21:16:38 <Gracenotes> yes! that looks like a functor!
21:16:42 <Gracenotes> :P
21:16:45 <copumpkin> lol
21:16:50 <copumpkin> shush you
21:17:08 <vyom> :)..
21:17:26 <vyom> Err.. I am not sure anymore if I know what a functor is
21:17:36 <copumpkin> don't think of functor
21:17:40 <copumpkin> think of furry
21:17:57 * CalJohn is not even sure what (->) means
21:18:00 <copumpkin> furry needs to be of type (a -> b) -> (c -> a) -> (c -> b) for the instance you're writing
21:18:02 <centrinia> Furry, (.) (.)
21:18:09 <copumpkin> CalJohn: it's the type constructor for functions
21:18:18 * BMeph likes mascots, but furries make him nervous...
21:18:30 <vyom> copumpkin: ah ok
21:18:38 <CalJohn> copumpkin: that makes sense
21:18:52 <vyom> copumpkin:  now i can give that another shot.. thanks
21:18:52 <copumpkin> vyom: so basically furry needs to take one function that takes an a and produces a b, and a function that takes a c and produces an a, and produce a function that takes a c and produces a b
21:18:54 <copumpkin> if that makes sense :)
21:18:56 <Gracenotes> (->) is the name of a type, like Maybe. However, there is no value constructor for this type.
21:18:58 <copumpkin> vyom: it's a very common function :)
21:19:00 <centrinia> vyom: Ask the djinn. ;)
21:19:06 <copumpkin> or the hoogle
21:19:06 * CalJohn did not realise that type constructors could be curried
21:19:07 <Gracenotes> unlike Just and Nothing, for Maybe
21:19:09 <centrinia> copumpkin: Really? (.) (.)
21:19:14 <copumpkin> lol
21:20:11 <centrinia> Ahh, my left eye hurts! (.)
21:21:12 <ceal> how do you add comments inside a haskell program?
21:21:23 <BMeph> @type const
21:21:24 <lambdabot> forall a b. a -> b -> a
21:21:31 <BMeph> @type const a
21:21:33 <lambdabot> forall b. b -> Expr
21:21:42 <dolio> > 5 -- comment
21:21:42 <centrinia> > 2+3 -- This should be 5
21:21:44 <lambdabot>   5
21:21:45 <lambdabot>   5
21:21:50 <dolio> > 5 {- also comment -}
21:21:52 <lambdabot>   5
21:21:55 <ceal> what about multiline?
21:22:03 <BMeph> @type const (a :: a)
21:22:05 <lambdabot>     Couldn't match expected type `a' against inferred type `Expr'
21:22:05 <lambdabot>       `a' is a rigid type variable bound by
21:22:05 <lambdabot>           an expression type signature at <interactive>:1:12
21:22:14 * BMeph sighs
21:22:17 <centrinia> > 5 {- This is a \n multiline comment -}
21:22:18 <lambdabot>   5
21:22:35 <ceal> oh i didn't see that :)
21:22:46 <copumpkin> > flip const "this is my kind of comment" 5
21:22:48 <lambdabot>   5
21:23:07 <copumpkin> > flip const "free inline comments!" 5
21:23:09 <lambdabot>   5
21:23:24 <vyom> copumpkin:   furry fnAtoB typeFuncA = fnAtoB . typeFuncA
21:23:27 <BMeph> > "More free inline comments!!" `seq` 5
21:23:29 <lambdabot>   5
21:23:34 <copumpkin> vyom: yay
21:23:36 <impl> What does const do?
21:23:41 <copumpkin> > const 5 6
21:23:43 <lambdabot>   5
21:23:47 <centrinia> @src const
21:23:48 <copumpkin> > const 5 undefined
21:23:48 <lambdabot> const x _ = x
21:23:50 <lambdabot>   5
21:23:51 <vyom> copumpkin:  seems to compile fine too :).. thanks
21:24:00 <impl> oh. that's simple. :P
21:24:07 <Gracenotes> > text $ "they can be " {- {- {- {- -} -} -} {- {- {- -} -} {- -} -} -} ++ {- {- {- {- {- -} -} {- -} {- -} {- -} -} {- -} -} -} "nested"
21:24:08 <lambdabot>   they can be nested
21:24:09 <copumpkin> vyom: that can be written even more simply as furry = (.) for that instance
21:24:45 <vyom> copumpkin: ya.. makes sense
21:24:51 <copumpkin> :)
21:25:01 <CalJohn> copumpkin: sorry, i am thinking about what you said earlier.  I don't understand how you can have an instance of ((-> t) for a function (a -> b) -> f a -> f b
21:25:13 <CalJohn> copumpkin: could you explain/point me in the right direction?
21:25:19 <copumpkin> CalJohn: what particular bothers you about that?
21:25:29 <BMeph> vyom: Or less simply, but (to some) more understandably, as furry fnAtoB typeFuncA c = fnAtoB (typeFuncA c)
21:25:30 <copumpkin> I just replaced f with ((->) t)
21:25:54 <CalJohn> i think i see now
21:26:03 <CalJohn> i must've had a wrong idea of what types could be
21:26:03 <copumpkin> :)
21:26:26 <copumpkin> there's actually a notion of "type of type" called kind
21:26:26 <BMeph> CalJohn: Just a warning: (-> a) is not the same as ((->) a) :)
21:26:33 <copumpkin> :k Maybe
21:26:36 <lambdabot> * -> *
21:26:41 <copumpkin> that means that Maybe takes a type and returns a type
21:26:49 <copumpkin> any Functor instance needs to be * -> *
21:26:58 <BMeph> Then the "type" of kinds are called sorts....
21:27:12 <Berengal> :k RWST
21:27:14 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
21:27:17 <copumpkin> lol
21:28:02 <Gracenotes> if you have a type, like "Foo a b c", you need to specify what a and b are. Then there's just one type parameter left, and it's (* -> *)
21:28:07 <CalJohn> copumpkin: i am vaguely familar with kinds
21:28:07 <copumpkin> we should have something equivalent to :k for asking about Typeclasses
21:28:23 <ray> :k Functor
21:28:25 <lambdabot> Class `Functor' used as a type
21:28:29 <ray> no luck
21:28:33 <copumpkin> I know :)
21:29:45 <Gracenotes> it is a single-parameter typeclass, but that was it is used with fmap is 'f a', so 'f' must accommodate one type parameter. there's this whole inference scheme... not opaque though :(
21:29:46 <BMeph> :c Functor
21:29:51 * CalJohn wonders how long it takes to learn all this stuff
21:30:05 <Gracenotes> and then you get fundeps involved; even I am not quite familiar with those. they can get hellish.
21:30:35 <Gracenotes> s/that was/the way/, ew.
21:30:38 <copumpkin> CalJohn: I feel pretty comfortable now several months later :)
21:30:44 <copumpkin> CalJohn: but there's still so much to learn
21:30:46 <ray> haskell is easy
21:30:51 <copumpkin> it really depends how deeply you want to dig
21:31:00 <copumpkin> you can get competent quickly, but there's so much depth
21:31:23 <Berengal> I've been doing Haskell for I think exactly a year (± a week), and I keep learning new things
21:31:51 <Gracenotes> kitty!
21:31:54 <Berengal> I think it's mostly because the abstractions never stop
21:31:56 <CalJohn> yes, i am probably borderline "competent", but occasionally people just throw out stuff which i've never even heard of
21:32:29 <CalJohn> like zygohisto-prepromorphisms ;)
21:32:34 <copumpkin> CalJohn: I can throw you the scariest type signature I know of and see if you can figure it out if you want :P
21:32:44 <CalJohn> go on.
21:32:44 <copumpkin> *scariest type signature I know of that doesn't live in category-extras
21:32:48 <copumpkin> :t loop
21:32:50 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
21:33:53 <CalJohn> ah, i don't really understand arrows.  time to look them up
21:34:05 <ray> think of them as a generalization of functions
21:34:06 <Gracenotes> that is an intense typeclass you have there!
21:34:09 <copumpkin> well, (->) is an instance of Arrow
21:34:21 <copumpkin> or you can just replace a with (~>)
21:34:30 <Berengal> (typeList ~ LFuncRet indexerList, indexerList ~ LFuncFrom value typeList, map ~ MultiIndexMap value typeList, List indexerList) => indexerList -> (map, LAp (Indexer map) typeList)
21:34:36 <copumpkin> and get (~>) (b, d) (c, d) -> (~>) b c
21:34:39 <copumpkin> which is
21:34:39 <Berengal> That's from something I've been working on...
21:34:57 <copumpkin> ((b, d) ~> (c, d)) -> (b ~> c)
21:35:01 <vyom> time for me to get back to the exercises because all this scaring the hell out of me! :P
21:35:12 <copumpkin> which I like because even after deciphering the type makes you go "wtf"
21:35:18 <copumpkin> Berengal: nice!
21:35:52 <Berengal> copumpkin: I've got no idea how to implement it yet. I had a smallish epiphany last night, but now I've forgotten the details :(
21:35:58 <copumpkin> aw
21:36:56 <Berengal> I think the solution involves either a) severe abuse of type families and classes (more than I already do), or b) unsafeCoerce
21:38:45 * CalJohn is reading "Generalising monads to arrows" by John Hughes
21:41:21 * lpsmith thinks he understands one way to implement a lucky number sieve efficiently.
21:42:36 <lpsmith> It is ugly though;  I'm almost inclined to write it in an imperative language first.   'cause it would just be a lot of ST-monad action otherwise.
21:43:03 <lpsmith> Either that or a lot of ugly, inefficient, persistent data structures
21:45:39 <BMeph> UArray Bool FTW!
21:46:25 <copumpkin> I'm not sure I agree with packing bits behind my back
21:47:42 <copumpkin> I'd be tempted to say that UArray Bool should work on native words and UArray Bit (where data Bit = O | I or something) should pack the bits
21:48:09 <lpsmith> copumpkin: but that would make your memory requirements go up by a factor of 32 to 64
21:48:22 <copumpkin> yup!
21:48:40 <lpsmith> oh,  just read your second message.  I might be able to agree to that.
21:49:04 <dolio> Why would you want UArray Bool to be extremely inefficient?
21:49:38 <copumpkin> well if I had something really tight in a loop, I'd want to avoid unnecessary masking of bits that's needed to unpack the bits behind my back
21:49:45 <ray> i will pack u
21:49:49 <lpsmith> copumpkin:  you might get signficantly better cache utilization by packing bits
21:49:49 <copumpkin> but I'd still want to be able to turn it on with the Bit instance if I wanted it
21:49:56 <copumpkin> lpsmith: true that
21:50:08 <copumpkin> hrm
21:50:19 <copumpkin> we need JIT!
21:50:52 <lpsmith> I would hypothesize that better cache utilization would more than pay for the extra masking
21:50:59 <copumpkin> yeah, definitely
21:51:16 <copumpkin> masking is comparatively cheap compared to memory, but still, I guess it depends how much I want to micromanage my tight loops
21:51:58 <lpsmith> of course, if your array doesn't fit in the multi-megabyte caches that modern CPUs come with...  You'll get extra memory reads if all you want do to is set a single bit
21:52:33 <lpsmith> so, that'd be a downside
21:52:39 <lpsmith> Why JIT?
21:52:59 <copumpkin> it can make decisions based on runtime behavior
21:53:11 <copumpkin> JIT + heavy compile-time work too :P
22:01:18 <vyom> copumpkin: need help with exercise 12 http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/ should i be using pattern matching here?
22:01:48 <copumpkin> vyom: you should need any pattern matching, nope
22:01:56 <copumpkin> you don't have a specific type
22:02:03 <copumpkin> so you can't match against any data constructors
22:02:09 <dibblego> vyom, you shouldn't and can't use pattern matching
22:02:39 <copumpkin> vyom: you probably will need one of the functions you defined earlier though :)
22:02:46 <vyom> copumpkin:  my initial approach was to pattern match against all types that were previously defined as instances of Misty
22:02:56 <copumpkin> oh, you can't pattern match on types
22:03:07 <copumpkin> only on their data constructors
22:03:16 <copumpkin> on a single type's data constructor, that is
22:03:24 <vyom> copumpkin:  true.. makes sense
22:03:39 <copumpkin> typeclasses are a form of "type case" really, but they're open
22:03:44 <copumpkin> in the sense that you can add more cases later
22:04:37 <copumpkin> ooh I like the order of these exercises
22:04:40 <copumpkin> I hadn't noticed
22:05:21 <vyom> copumpkin: I am confised by what m (m a) is..
22:05:43 <copumpkin> it's a Misty inside a Misty
22:06:12 <vyom> copumpkin: how do I take out the Misty that is inside..
22:07:04 <dibblego> vyom, you will use the banana function
22:08:53 <lpsmith> Mmm... bananas.  Overthrowing latin american countries since 1954
22:10:16 <BMeph> vyom: Or...don't take it out, and "pretend" as if you had. ;)
22:10:48 <vyom> lol..
22:11:15 <vyom> still thinking.. cant figure out how to use the banana function
22:11:54 <dibblego> vyom, call x the argument, then consider the type of banana x
22:12:06 <dibblego> er \f -> banana f x
22:13:13 <lpsmith> banana :: Misty m =>  m a ->  (a -> m b) -> m b
22:13:23 <lpsmith> follow the types!
22:14:13 <lpsmith> banana lets you "take something out",  temporarily,  as long as you use it to produce another Misty value.
22:16:34 <lpsmith> Hmm... reviewing my history,  I daresay bananas have been overthrowing latin american countries since well before 1954.   More like since 1910,  at least.
22:28:33 <copumpkin> vyom: often with problems like these it's worth considering what you start with and what you need to get
22:28:48 <copumpkin> and there's often only a couple of paths through the types that will take you there in a meaningful manner
22:28:59 <copumpkin> it's like I have an a and need a c
22:29:06 <copumpkin> and I have function that takes an a to a c
22:29:08 <copumpkin> zomg!
22:30:16 <vyom> copumpkin:  I am trying exactly that approach.. trying to fit banana in somewhere.. but not really getting it
22:31:27 <seisatsu> boing
22:33:39 <seisatsu> hey, as a beginner, what book should I use to get my feet wet with haskell?
22:34:36 <Twey> RWH
22:35:58 <seisatsu> ah. I was looking at real world haskell.
22:36:08 <seisatsu> I guess I'll use that one.
22:36:19 <bos> that's what twey meant.
22:36:27 <Twey> Yup
22:36:48 <lpsmith> vyom:  think of it like an algebra problem
22:36:55 <BMeph> vyom: Remind me, which one are you working on?
22:37:05 <lpsmith> So we have a (m (m x))
22:37:20 <Twey> m²x!
22:37:34 <lpsmith> hahaha,  bad twey!  ;-)
22:37:39 <vyom> BMeph: No. 12 and yes i am thinking of it like algebra.. manipulating symbols to see if i can get signatures to match somewhere
22:37:47 <dibblego> BMeph, (Misty m) => m (m a) -> m a
22:37:47 <Twey> :-P
22:38:12 <lpsmith> and we have banana :: (m a) -> (a -> m b) -> m b
22:38:19 <BMeph> Which one is #12? Sorry, I've done them before, but I don't have it in front of me (yet). :)
22:38:43 <BMeph> dibblego: Ah, thanks. I should've just gone to the source. :)
22:38:50 <dibblego> lpsmith, (flipped)
22:39:38 <lpsmith> dibblego:  oops :-D
22:39:53 <BMeph> vyom: So, if we just call (m b) <==> a, what does that look like? ;)
22:40:04 <lpsmith> Ok, so we have banana :: Misty m => (a -> m b) -> m a -> m b
22:40:44 <lpsmith> So if you are given a value of type (m (m x)),  there is only one way you can combine that (directly) with banana...
22:41:20 <Berengal> It might be helpful to do some alpha-conversion... jellybean :: (Misty m) => m (m a) -> m a; banana :: (Misty m) =>(m b) -> (b -> m c) -> m c
22:41:34 <lpsmith> I suppose there is one other way you can combine it pretty straightforwardly... but it's less direct
22:42:59 <BMeph> Surely,  banana :: (Misty m) =>(b -> m c) -> (m b) -> m c
22:43:26 <Berengal> Uh, yeah, I copypasted the wrong signature
22:43:42 <Berengal> Still, my point stands
22:43:44 * Berengal waves hand
22:43:50 <Berengal> Maybe...
22:45:35 * BMeph is valiantly resisting the urge to just blurt out an answer...especially since he may be wrong! ;p
22:46:16 <vyom> BMeph: please do ;)
22:48:06 <vyom> ok i give up.. i need to see the answer and reason backwards
22:48:39 <lpsmith> jellybean = banana id
22:48:59 <Nereid_> :P
22:49:57 <Nereid_> if you put (m b) for a in the type of banana, you get (m b -> m b) -> m (m b) -> m b
22:50:05 <Nereid_> thus the id
22:51:37 <lpsmith> what I was trying to get at was that the only place you could (directly) use a type of (m (m x))  was to the second argument of banana
22:51:58 <lpsmith> calling this value, say "m"
22:52:07 <lpsmith> jellybean m = banana ___ m
22:52:42 <lpsmith> then you know that the "a" in banana is equal to (m x)
22:52:56 <lpsmith> and thus you get Nereid_'s type
22:53:33 <vyom> ok.. i sort of get it..
22:54:42 <lpsmith> just follow the types! they behave kind of like expressions in Algebra I, just different
22:55:09 <copumpkin> it's sort of like trig identities!
22:55:14 <copumpkin> you have a bunch of them that they gave you
22:55:32 <copumpkin> and you can compose them in odd ways to get other ones until you reach the form you need
22:56:14 <vyom> ya I guess..
22:57:47 <vyom> so wait.. a -> m b in banana can actually match the type signature id ? my initial assumption was that they were two 'different' types
22:58:22 <vyom> you cant just make them equal ;)
22:59:00 <ray> a can be anything
22:59:18 <ray> this includes "m b" or "a -> b -> c -> d -> e f g"
22:59:29 <vyom> ok
22:59:47 <Nereid_> since id :: a -> a
22:59:52 <Nereid_> when you put banana id
22:59:53 <dibblego> vyom, the 'a' in (a -> m b) must be the same as the (m a) in m (m a)
23:00:02 <Nereid_> well banana :: (a -> m b) -> m a -> m b
23:00:09 <Nereid_> so putting banana id forces a = m b
23:00:41 <vyom> yes yes I get it.. just did not think along those lines while attacking the problem :)
23:00:43 <bjorkintosh> is jaskell used by anyone?
23:00:44 <vyom> thanks ppl
23:02:24 <copumpkin> vyom: it takes a while to get used to dealing with some of the more complicated types :)
23:02:38 <Twey> bjorkintosh: Other than the 566 people in this channel?
23:02:48 <bjorkintosh> sure, why not? :)
23:02:49 <copumpkin> I've never used jaskell
23:03:02 <copumpkin> unless you pronounce it the spanish way
23:03:05 <bjorkintosh> i just found out about it ... i don't know if it's actively developed and used at all.
23:03:06 <Twey> Hahaha
23:03:22 <Twey> Oh, that'll teach me to presume error
23:03:28 <copumpkin> :)
23:03:43 <Twey> Not AFAIK, bjorkintosh.  Scala seems more popular on the Java front.
23:04:06 <bjorkintosh> okay. is it haskell for java or an entirely different language?
23:04:38 <Twey> It looks pretty different to me.
23:04:40 <copumpkin> looks pretty different for me
23:04:44 <copumpkin> *to
23:04:44 <copumpkin> wow
23:04:52 <Twey> Heh
23:04:57 <copumpkin> if I hadn't messed that up I would've repeated what Twey said
23:05:03 <copumpkin> lucky I retained my individuality by messing it up
23:05:07 <Twey> That's happening to me a lot lately
23:05:19 <bjorkintosh> good man. you must be general error reading :)
23:06:22 <bjorkintosh> so it seems jaskell is the only haskell-like language (in my very short search) targetting the jvm
23:06:36 <Nereid_> bjorkintosh: scala is a functional language for jvm
23:06:44 <dolio> CAL is more like Haskell.
23:06:59 <bjorkintosh> Nereid, but i'm especially interested in haskell.
23:07:05 <dolio> From what little I've gleaned of each, that is.
23:07:08 <bjorkintosh> not functional languages in general.
23:08:33 <Nereid_> jaskell looks pretty different
23:09:10 <Twey> That it does.  Pretty different.
23:09:30 <Twey> Nereid_: But Scala is impure and strict.
23:09:54 <vegai> also practical :P
23:10:08 <dibblego> to some extent
23:10:20 <bjorkintosh> scala's all the rage these days. it used to be groovy iirc.
23:10:32 <bjorkintosh> so by tomorrow there'll be a new rage.
23:10:39 <dibblego> bjorkintosh, no, groovy is something else (and far from practical)
23:11:03 <bjorkintosh> as far as rages go, it was it for a few mango seasons.
23:11:20 <bjorkintosh> then came the big famine.
23:13:01 <dolio> Jaskell is impure and lazy (as I recall). That's worse than impure and strict. :)
23:13:26 <bjorkintosh> so is there a haskell for the jvm?
23:13:44 <Nereid_> it seems unlikely
23:13:45 <bjorkintosh> there seems to be a number of available compilers but none for that one.
23:13:52 <dibblego> bjorkintosh, there is CAL
23:14:21 <bjorkintosh> ah i see.
23:14:33 <Nereid_> CAL looks much more like it :)
23:14:33 <bjorkintosh> cal = haskell + java.
23:15:18 <jeffwheeler> Nothing good can come of combining Haskell and Java. :P
23:15:29 <araujo> hah
23:15:30 <lambdabot> araujo: You have 1 new message. '/msg lambdabot @messages' to read it.
23:15:35 <bjorkintosh> jeffwheeler, how else does one talk to the google application engine?
23:15:46 <jeffwheeler> bjorkintosh: doesn't it support Python?
23:16:08 <bjorkintosh> sure. but i don't especially want to use python.
23:16:19 <jeffwheeler> bjorkintosh: Much more good could come of that :D
23:17:25 <Twey> « Latest news: 15 November 2007 - Open Quark Framework 1.7.1_0 Available for Download »
23:17:31 <Twey> Looks dead...
23:17:46 <bjorkintosh> postively moribund.
23:18:08 <bjorkintosh> nothing good could come of java sleeping with haskell.
23:18:34 <araujo> s/haskell/*/
23:19:12 <bjorkintosh> if it had worked, you'd all be using 'enterprise' in every other sentence.
23:19:41 <Twey> Hahaha.
23:25:52 <msteele_> Now that I've had a taste what the 'forall' keyword can do I'm in even greater danger of writing all my Haskell pragrams in Java
23:26:42 <Twey> Pragmas?
23:27:00 <lpsmith> msteele_: why?
23:27:33 <lpsmith> forall is a little specialized, but quite useful
23:27:50 <Berengal> I don't know why, but it makes me somewhat happy that I spent almost my entire work day yesterday tracking down and fixing a bug in java that would've been caught by the compiler in haskell
23:28:01 <Cale> msteele_: Doesn't it just give you a bit more flexibility? It allows you to define functions which require polymorphic parameters.
23:28:05 <msteele_> forall gives me an easy way to make heterogenious collections.  I can see this being overused in my code.
23:28:24 <Cale> msteele_: Eh? They're not really heterogeneous though.
23:28:30 <lpsmith> msteele_:  no it doesn't
23:28:32 <Cale> You mean existential types?
23:28:35 <msteele_> yes.
23:28:38 <Berengal> msteele_: It does not give you an easy way of _using_ heterogenous collections though
23:28:39 <jeffwheeler> When is it necessary to use forall, vs. the implied forall?
23:28:42 <lpsmith> Not unless you use existential types, as cale said
23:28:59 <lpsmith> :t runST
23:29:06 <lambdabot> forall a. (forall s. ST s a) -> a
23:29:11 <msteele_> I did not realize that forall was used for things other than existential types.
23:29:36 <bjorkintosh> existential?
23:29:38 <jeffwheeler> Hmm, so what does that mean that's different from having the s in the initial forall?
23:29:56 <lpsmith> yeah, basically the "forall" is justified in Haskell by the first order equivalency
23:29:56 <Cale> jeffwheeler: It means the parameter *must* be polymorphic in s
23:30:09 <Berengal> It's neccessary in functions like 'foo :: (forall a. [a] -> [a]) -> ([Char], [Int])'; foo f = (f "hello", f [1..10])'
23:30:14 <Cale> jeffwheeler: You can't choose which s to use when you apply runST, it must work for all s.
23:30:44 <jeffwheeler> Berengal: that example makes sense
23:30:46 <lpsmith> forall. (a -> b)   ==  (a -> exists b)
23:31:00 <lpsmith> err forall b. (a -> b)   ==  (a -> exists b. b)
23:31:03 <Cale> jeffwheeler: This is a trick which effectively prevents STRefs from being used from inside different calls to runST.
23:34:26 <msteele_> What else is 'forall' used for besides existential types, then?
23:34:49 <Cale> msteele_: higher-rank polymorphism -- functions which insist on polymorphic arguments.
23:35:59 <Twey> :t \f -> (f "foo", f [1..5])
23:36:01 <lambdabot>     No instance for (Num Char)
23:36:02 <lambdabot>       arising from the literal `1' at <interactive>:1:19
23:36:02 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
23:36:14 <Twey> We don't get that from inference, huh?
23:36:14 <Cale> Normally, if I write a program like  foo f = (f [1,2,3], f "hello"), it won't typecheck, since ordinarily, parameters to functions are not polymorphic in the body of the function
23:36:29 <Cale> Right, and polymorphic types are never inferred for parameters to functions
23:36:51 <Cale> However, we can give an explicit higher-rank type signature to foo to make it work:
23:37:07 <Twey> Aye.
23:37:08 <Cale> foo :: (forall a. [a] -> b) -> (b,b)
23:37:23 <Berengal> Twey: If you had a function \f -> f "hello", would you want it to have type [a] -> [a], or String -> String?
23:37:25 <Cale> > let foo :: (forall a. [a] -> b) -> (b,b); foo f = (f [1,2,3], f "hello") in foo length
23:37:29 <lambdabot>   (3,5)
23:37:40 <bjorkintosh> goodness. programming has a long way to go before we can tell computers to make a sammich.
23:37:47 <bjorkintosh> and there it'll be.
23:37:51 <Twey> Berengal: Fair point.
23:38:40 <Cale> This can be used effectively to prevent misuse of resources, like in the case of the ST monad, where it prevents STRefs from escaping as part of the result of runST.
23:39:05 <Cale> (which, if it were permitted, could be used to break referential transparency)
23:40:47 <Berengal> I like ST. I've never actually used it, but just the fact that it's there is awesome. We can take "impure" code, and wrap it up in a nice, pure, referentially transparent box
23:41:33 * jeffwheeler is totally relieved to have recovered a machine after 26 hours of frustration; yay for backups
23:41:35 <Twey> Yes indeed
23:56:36 <msteele_> > :t Int
23:56:39 <lambdabot>   <no location info>: parse error on input `:'
23:58:34 <ivanm> :t Int
23:58:36 <lambdabot> Not in scope: data constructor `Int'
23:58:39 <ivanm> (which won't make any more sense)
23:58:42 <ivanm> :kind Int
23:58:50 <ivanm> @kind Int
23:58:52 <lambdabot> *
