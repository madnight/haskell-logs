00:00:46 <aaafff1> so... dunce cap for me. In general does this seem like a good/decent solution though?
00:02:02 * Raynes passes aaafff1 a pointed dunce cap.
00:02:30 * aaafff1 wears pointed dunce cap and shuts up
00:02:43 * pragma_ ponders the situation.
00:08:02 <pragma_> I need a fix cuz I'm going down, down to the bits that I left uptown, I need a fix cuz I'm going down.
00:13:33 <Axman6> o.O
00:14:04 <Raynes> O.o
00:14:27 <ivanm> >_>
00:14:27 <Axman6> o.Ø
00:14:42 <ivanm> Axman6: did someone try to punch your lights out?
00:14:55 <Axman6> yes, my girlfriend
00:15:04 <Axman6> she's so cute
00:15:14 <ivanm> spending too much time on your computer again?
00:15:23 <Axman6> not enough time
00:15:41 <ivanm> so your girlfriend is getting sick of you and doesn't want to see you as much?
00:15:43 <Raynes> O.Φ
00:15:48 <Axman6> we've been down the coast for the last 5 days
00:16:02 <Axman6> tired her out >_>
00:44:21 <portnov> @index reject
00:44:22 <lambdabot> bzzt
00:57:15 <ManateeLazyCat> If i want get shell command result, example i input command "ls -al" and get command result as String, how to do it?
00:57:21 <ManateeLazyCat> I mean have shell interface module in Haskell library.
00:57:24 <ManateeLazyCat> ?
00:57:38 <FunctorSalad> meh. generating trees with quickcheck is annoying
00:58:17 <mmorrow_> ManateeLazyCat: there's System.Process.readProcess
00:58:24 <FunctorSalad> apparently, you must shrink the size manually upon recursion or it will almost surely fail to terminate
00:58:31 <ManateeLazyCat> mmorrow_: Thanks!
00:58:50 <FunctorSalad> am I doing it wrong?
00:59:21 <Saizan> there was a tree example in the quickcheck guide
00:59:23 <Twey> ManateeLazyCat: Try the HSH library
00:59:24 <Saizan> you could check there
00:59:27 <Twey> http://software.complete.org/software/wiki/hsh
00:59:32 <mmorrow_> ManateeLazyCat: if you also want stderr (or to use ByteString instead of String), you'll need a custom solution
00:59:46 <doserj> FunctorSalad: either you decreas the probability of having children in deeper nodes, or you simple cut-off after a certain depth.
01:00:38 <ManateeLazyCat> mmorrow_: Now i develop `file browser` module in my project, so i need get files list when i create tab widget.
01:00:51 <mmorrow_> FunctorSalad: i usually generate a random max depth (w/in a given range) at the start, then you can stop at that point if you ever get there along any path
01:01:04 <ManateeLazyCat> Twey: Read it.
01:01:17 <Twey> Read what?
01:01:20 <Saizan> FunctorSalad: http://www.cs.chalmers.se/~rjmh/QuickCheck/manual_body.html#16
01:02:13 <ManateeLazyCat> Twey: http://software.complete.org/software/wiki/hsh
01:02:31 <Twey> Er, I have
01:02:35 <Twey> That link was for you
01:02:39 <mmorrow_> Twey: (i think he means in the past tense)
01:02:43 <Twey> Oh
01:02:47 <FunctorSalad> Saizan: ah, that's why I did, but I forgot catching the 0 case ;)
01:02:57 <Twey> Well, that's a library that does what you want (and some other things)
01:03:33 <ManateeLazyCat> Twey: Looks cool, i will read it deeply.
01:03:56 <FunctorSalad> doserj: yep, and you can keep track of it in the size parameter of the generator... but I thought there might be an easier way ;)
01:05:30 <FunctorSalad> good, with the 0 check it works :)
01:06:05 <ManateeLazyCat> Thanks all for help! :)
01:52:28 <sayyestolife> I might be beating a dead horse here but; I'm scared of functional languages due to (supposedly) performance reasons. Should I be?
01:53:35 <sayyestolife> If I shouldn't, why aren't functional languages more widespread? (They've been around for quite a while).
01:54:18 <opqdonut> ocaml has great performance
01:54:23 <opqdonut> c-like even
01:54:34 <dsturnbull> haskell is pretty fast too
01:54:35 <opqdonut> haskell can have pretty great performance too
01:54:38 * dsturnbull coming form python/ruby
01:54:41 <opqdonut> and the compilers just keep getting better
01:54:49 <opqdonut> er rather, compiler :)
01:55:27 <sayyestolife> I must admit I'm in love with the expressiveness of these languages though :)
01:56:06 <dsturnbull> to be honest, we already had this conversation 40 years ago: asm vs C
01:56:20 <dsturnbull> we need to have it again, and decide whether we go C or <whatever>
01:56:20 <sayyestolife> is that so?
01:56:21 <quicksilver> sayyestolife: because the great majority of programmers are not particularly well-informed or (dare I say) particularly good at their job? ;)
01:56:36 <sayyestolife> quicksilver is it really that simple? :)
01:56:44 <quicksilver> they just use the tools they use, without question.
01:56:47 <Twey> It really is.
01:56:52 <Twey> Worryingly.
01:56:56 <quicksilver> and most businesses value tried and tested solutions
01:56:57 <sayyestolife> awesome for me
01:56:58 <quicksilver> over new-fangled ones.
01:57:02 <Twey> That *should* be a joke
01:57:17 <dsturnbull> that's not that scary. i'd hate to work in a place with 50 different standards to keep up with
01:57:22 <quicksilver> there's more functional programming out there than you probably guess, though.
01:57:28 <Twey> dsturnbull: There's a limit
01:57:34 <quicksilver> especially if you think erlang counts and functional.
01:57:36 <dsturnbull> oh sure, there's a balance
01:57:43 <Twey> And the current situation is way over it
01:57:57 <Twey> They're still working with languages designed twenty years ago over languages designed ten years ago
01:58:09 <Twey> Oh, but if a new language sufficiently resembles the old ones, they'll often adopt it
01:58:16 <Twey> (see: C#, Java)
01:58:24 <Twey> At least, a significant portion of the industry will
01:58:28 <dsturnbull> eh, C# is progressing at least
01:58:33 <Twey> The rest will continue to scorn it for another decade
01:58:37 <Twey> Oh, sure, it is
01:58:49 <Twey> But the point is that it only got adopted because it's practically a superset of C++
01:58:50 <dsturnbull> like, specifically towards functional style
01:58:50 <sayyestolife> feel free to slap me but I really don't like the model where you have to pass the state around in some sort map
01:58:55 <dsturnbull> yep
01:59:32 <dsturnbull> sayyestolife: think of the testing benefits of that
02:00:45 <sayyestolife> (I might again, be out of it but..) I prefer encapsulating as much as possible
02:00:47 <dsturnbull> also i don't know if ghc does it, but it stands to reason that calling f(1) twice would actually result in a single computation?
02:01:33 <dibblego> no, since it doesn't stand to reason :)
02:01:40 <dsturnbull> :((
02:01:59 <mmorrow_> let x = f 1 in (x,x)
02:02:03 <Twey> sayyestolife: Er, I don't think anyone does
02:02:11 <Saizan> no compiler does automatic memoization because it's hard to tell if it's a win
02:02:29 <dsturnbull> ah
02:02:30 <quicksilver> plenty of compilers do CSE though
02:02:39 <sayyestolife> Twey okay
02:02:46 <quicksilver> GCC does quite agressive CSE, but it's hard for GCC to tell if a function is pure.
02:03:00 <quicksilver> (it can sometimes, and you can tell it with __ugly__((syntax)) )
02:03:12 <quicksilver> GHC does very limited CSE because of the possible space leaks.
02:03:25 <mmorrow_> heh, yeah it baffles me why gcc chose such hideous syntax for attributes
02:03:38 <Twey> sayyestolife: That's why we have things like the State monad
02:03:48 <Zao> mmorrow_: Yay for implementation reserved words.
02:03:50 <mmorrow_> i guess that was the least ugly that was already taken by C syn
02:04:00 <dsturnbull> i thought n thunks to compute f(1) being lazily evaluated would result in some cancellation
02:04:04 <dsturnbull> alas
02:04:05 <sayyestolife> Twey ah, that just shows that I have so much more to learn, YAY! :)
02:04:08 <Zao> Although two consecutive underscores ought to do anywhere.
02:04:14 <Zao> Unless C is more insane than C++.
02:04:25 <mmorrow_> , vacuum (let x = 1 + 1 in (x,x))
02:04:29 <lunabot>  [(0,[1,1]),(1,[])]
02:04:38 <mmorrow_> , vacuum (1+1,1+1)
02:04:40 <lunabot>  [(0,[1,2]),(1,[]),(2,[])]
02:05:02 * Twey doesn't quite understand vacuum
02:05:22 <mmorrow_> that's an adjacency list of the graph formed by ptrs and closures
02:05:33 <Twey> Oh, right
02:05:41 <mmorrow_> the (1,[]) is an Integer
02:05:55 * Twey nods.
02:05:56 <mmorrow_> (the "1" there representing its memory location)
02:06:15 <Cale> (which happens to be the expression (1+1), but it can't look inside)
02:06:34 <doserj> , vacuum (1+1,1+1) == vacuum (2,2)
02:06:36 <lunabot>  True
02:06:41 <mmorrow_> yeah, since vacuum forces things, the 1+1 gets evaluated to 2
02:07:11 <mmorrow_> there's actually a vacuumLazy now that works though thanks to int-e
02:07:20 * quicksilver cannot believe people are seriously suggesting a technical library decision be made by a web poll.
02:07:28 <mmorrow_> that reminds me, i've got to update the hackage pkg
02:07:35 <Zao> quicksilver: My bikeshed fell over :(
02:07:35 <quicksilver> voting is not a solution to technical problems.
02:07:42 <opqdonut> quicksilver: hmm, where?
02:07:44 <Twey> quicksilver: What problem is that?
02:07:53 <quicksilver> opqdonut: http://hackage.haskell.org/trac/ghc/ticket/3339#comment:10
02:09:16 <dsturnbull> anyone using yi?
02:09:43 <opqdonut> i dislike the confusing newbies argument
02:09:56 <opqdonut> because by the same reason we shouldn't have (+) in Num
02:09:59 <opqdonut> etc
02:10:41 <mmorrow_> , let a = vacuum (fix (0:)); b = vacuum (repeat 0); c = vacuum (cycle [0]) in and [a==b,b==c]
02:10:43 <lunabot>  True
02:11:26 <mmorrow_> (since the literals aren't included in the adjacency list, this also happens here though:
02:11:31 <mmorrow_> , let a = vacuum (fix (0:)); b = vacuum (repeat 99); c = vacuum (cycle [42]) in and [a==b,b==c]
02:11:34 <lunabot>  True
02:12:13 <mmorrow_> (the literals being the machine words making up the ints/floats/etc
02:12:14 <mmorrow_> )
02:15:47 <mmorrow_> Cale: but yeah, even vacuumLazy wouldn't be able to look inside of (1 + 1) since the ghc primitive unpackClosure# doesn't return info about (partial) applications
02:16:24 <mmorrow_> (when all they are in reality is (Ptr Code, [Args]))
02:16:59 <portnov> :t when
02:17:01 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:17:24 * Cale dislikes the type of when
02:17:42 <Dae> Why?
02:17:42 <Cale> should be Bool -> m a -> m ()
02:17:49 <Dae> ohh
02:18:07 <Cale> Or possibly  Bool -> m a -> m (Maybe a)
02:18:24 <Dae> hmm... why not Bool -> m a -> m a then?
02:18:46 <dibblego> you can't get 'a' if False
02:18:49 <opqdonut> acro-ton dracula
02:18:50 <Cale> Because what would the result be if the Bool is False?
02:19:13 <Dae> details, details
02:19:16 <opqdonut> return undefined of course ;)
02:20:00 <Cale> forkIO also has this stupid problem
02:20:02 <Cale> :t forkIO
02:20:04 <lambdabot> Not in scope: `forkIO'
02:20:11 <Cale> :t Control.Concurrent.forkIO
02:20:13 <lambdabot> IO () -> IO GHC.Conc.ThreadId
02:20:18 <hackagebot> hscamwire 0.2.1 - Haskell bindings to IIDC1394 cameras, via Camwire (FrederickRoss)
02:20:33 <Cale> There is absolutely no reason that it requires it to be IO ()
02:20:53 <Saizan_> Cale: there are actually those who'd like (>>) :: Monad m => m () -> m b -> m b
02:21:04 <Cale> Saizan_: I think that's really silly.
02:21:04 <mmorrow_> it could make a difference for memory use though
02:21:18 <Cale> mmorrow_: Could it really?
02:21:22 <mmorrow_> since a result of m () means that it definitely doesn't need to retain the result
02:21:25 <mmorrow_> Cale: not sure
02:21:38 <Dae> forkIO wouldn't really make sense for ST, would it? :S
02:21:49 <Cale> Dae: I'm not saying the IO should change
02:21:53 <mmorrow_> Dae: you can write a forkST for sure
02:21:57 <Cale> Dae: It should be  IO a -> IO ThreadId
02:22:09 <Dae> ahh
02:22:09 <mmorrow_> Dae: just deploy unsafeCoerce :)
02:22:09 <Cale> The polymorphism tells you that it doesn't use the result.
02:22:30 <mmorrow_> Dae: (and this works too)
02:22:40 <Saizan_> mmorrow_: being able to do it and it making sense are distinct :P
02:22:50 <mmorrow_> Saizan: i never said it makes sense
02:22:52 <Dae> mmorrow_: I think quicksilver promised to fry me over a slowly burning monad if I used that kind of thing...
02:23:02 <mmorrow_> Saizan: also i never said that it doesn't either :)
02:23:24 <mmorrow_> Saizan: semantically it'd be `par` pretty much
02:23:35 <Saizan_> so you're just adding irrelevant facts to the conversation?:)
02:23:44 <mmorrow_> Saizan: me?
02:23:55 <Saizan_> no, par doesn't have to deal with the effects
02:24:25 <mmorrow_> Saizan_: forkST :: ST s () -> ST s ()
02:24:28 <mmorrow_> runST
02:24:41 <mmorrow_> why should you care about effects there?
02:24:55 <mmorrow_> since they'll be localized to ST
02:25:06 <Heffalump> mmorrow_: forkST would be broken
02:25:10 <Cale> mmorrow_: They'll be nondeterministic.
02:25:20 <Cale> mmorrow_: So not referentially transparent
02:25:21 <mmorrow_> Heffalump, Cale: why?
02:25:33 <Heffalump> mmorrow_: because thread interleaving is non-deterministic
02:25:42 <mmorrow_> Cale: no more so that ST is not referentially transparent
02:25:57 <Heffalump> but ST is referentially transparent
02:25:59 <mmorrow_> Heffalump: so is the interleaving that happens with par that you don't see
02:26:04 <mmorrow_> Heffalump: exactly!
02:26:09 <Heffalump> mmorrow_: that interleaving can't have side-effects
02:26:16 <Heffalump> ST has mutable references
02:26:24 <Cale> There's no way to tell that a function has employed runST without looking at its implementation, because from outside the runST, it's referentially transparent.
02:26:26 <Saizan_> mmorrow_: the interleaving of par doesn't change the results, the interleaving of mutating references does
02:26:33 <mmorrow_> i suppose
02:26:56 <Heffalump> Cale: or timing it :-)
02:27:24 <mmorrow_> Saizan_: ok, so then forkST is equivalent to using unsafePerformIO + par
02:27:42 <Heffalump> or indeed unsafeIOToST and forkIO ;-)
02:27:44 <mmorrow_> which could be used to implement interesting things
02:27:59 <Heffalump> unsafePerformIO + par is more powerful than forkST
02:28:11 <Dae> mmorrow_: like the end of the world?
02:28:22 <mmorrow_> Heffalump: oh, and i'm assuming here you're using unsafeCoerce to bring arbitrary IO functions into ST here
02:28:57 <mmorrow_> Heffalump: this module is fun http://moonpatio.com/repos/M.hs
02:28:57 * Saizan_ removes all the unsafe* functions from mmorrow_ 
02:29:13 <mmorrow_> also @Saizan_ & Cale
02:30:02 <mmorrow_> surprisingly, doing stuff in that M monad, then doing runM works for things where using unsafePerformIO directly doesn't.. not sure why
02:30:12 <Cale> http://farm3.static.flickr.com/2532/3700776571_70f1bfc0e9_o.jpg
02:30:13 <mmorrow_> (i can't remember the instance i'm thinking of either though)
02:31:17 * Saizan_ doesn't get the point of that M monad
02:32:03 <mmorrow_> Saizan_: it's an indirect way of doing unsafePerformIO, but it works in cases where just doing unsafePerformIO fails
02:32:06 <Saizan_> ah, it's IO restricted to Refs?
02:32:16 <mmorrow_> Saizan_: essentially
02:32:44 <mmorrow_> (and fork/killThread/delay too there)
02:32:52 <mmorrow_> but i added those as an afterthought
02:33:33 <mmorrow_> the difference though between STRefs+ST and Refs+M is that you can get the Refs out of M with runM
02:34:26 * Heffalump takes away mmorrow_'s Haskell licence for multiple violations of referential transparency
02:34:26 <Cale> yeah, that seems like it just breaks the safety of ST.
02:34:34 <Saizan_> it does
02:34:34 <mmorrow_> Heffalump: hehe
02:34:46 <mmorrow_> Cale: that's exactly the purpose
02:35:22 <Saizan_> if some day ghc removes the unsafe*'s i bet there won't be any mmorrow_'s code compiling anymore :)
02:35:38 <mmorrow_> Saizan_: heh, fair bet
02:37:03 <mmorrow_> yeah, so that M monad's whole thing is to let you break referential transparency in controlled ways, ideally to implement something impossible without this ability, but that has a pure external interface
02:37:35 <mmorrow_> but clearly you could do "bad" things with it
02:38:08 <mmorrow_> it's esssentially the "unsafePerformIO monad"
02:38:21 <Saizan_> given "io :: IO a -> M a" it doesn't seem very much controlled, however it may trick the inliner into doing the right thing with unsafePerformIO, or something like that
02:38:47 <mmorrow_> Saizan_: yeah, you'd have to remove that among other things if you wanted to actually present this as a controlled interface
02:39:02 <mmorrow_> Saizan_: ", however it may trick the inliner into doing the right thing with unsafePerformIO,"
02:39:03 <mmorrow_> exactly
02:39:08 <mmorrow_> i think this is what's happening
02:39:16 <mmorrow_> (or something along those lines)
02:39:22 <Saizan_> i wonder why you go via ST though
02:39:31 <Sarajevo> anyone interested in ##adult channel ? Join and have a nice conversation with adults. thanks
02:39:46 <mmorrow_> Saizan_: because that seems to work where unsafePerformIO doesn't
02:40:07 <mmorrow_> Saizan_: i think the fact that it's going through ST is exactly *why* it works
02:40:41 <Saizan_> so we should reimplement unsafePerformIO with runST + unsafeSTtoIO?
02:40:52 <mmorrow_> Saizan_: heh, that seems to be the moral
02:41:10 <mmorrow_> (but sometimes you /want/ the behavior that unsafePerformIO has..)
02:41:22 <mmorrow_> it's just that here you don't
02:41:24 <Zao> Sometimes you just want self-mutilation.
02:42:21 <Saizan_> mmorrow_: maybe you should look at what they are doing differently :)
02:42:41 <mmorrow_> Saizan_: that'd be interesting to find out, haven't played with that M module in a while
02:44:09 <mmorrow_> ok, so ammending my statement about par and forkST, this would be semantically equiv to par:
02:44:43 <mmorrow_> par :: a -> b -> b; par a b = runST (forkST (return $! a)) `seq` b
02:50:25 <Saizan_> yeah, if you don't use ST at all
02:51:37 <mmorrow_> (which is what i initially meant, but confused myself for a minute there)
03:08:33 <dsturnbull> why would cabal not be able to find the glib and gtk packages?
03:08:39 <dsturnbull> on OSX
03:09:17 <int-e> because gtk2hs has not been cabalized.
03:10:35 <int-e> so it's not on hackage, you'll have to install it manually. http://www.haskell.org/haskellwiki/Gtk2Hs#Mac_OS_X may help, but I'm not a Mac user, so I don't know whether it's up-to-date.
03:11:10 <int-e> (or find a binary package, perhaps. again, I don't know where to start looking for one)
03:11:52 <dsturnbull> thanks. i'm actually inside X11 on my mac, so i'll just use the normal tar
03:22:22 <asmips> I know that the opreator: $! forces arguments to be evaluated strictly, but I thought $ did the same thing. Is there a difference?
03:22:40 <Vanadium> $ does not do that.
03:23:04 <Vanadium> @src $
03:23:05 <lambdabot> f $ x = f x
03:23:21 <Twey> @src $!
03:23:22 <lambdabot> f $! x = x `seq` f x
03:23:56 <asmips> @src seq
03:23:57 <lambdabot> Source not found. That's something I cannot allow to happen.
03:24:05 <asmips> What does seq signify?
03:24:21 <Woof> @src `seq`
03:24:22 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:24:29 <Woof> -_-
03:24:30 <ivanm> asmips: forces the first term to be reduced to WHNF
03:26:15 <maartenm> $index shift
03:26:19 <maartenm> @index shift
03:26:19 <lambdabot> Data.Bits, Foreign, Graphics.UI.GLUT.Callbacks.Window, Graphics.UI.GLUT.Callbacks, Graphics.UI.GLUT
03:26:39 <Vanadium> seq is (id $!) O:-)
03:28:05 <asmips> thanks guys. that cleared it up
03:28:33 <asmips> whnf = weak head normal form.
03:28:52 <ivanm> Vanadium: I thought $! was defined using seq... >_>
03:29:08 <Vanadium> > const "hooray" $! Just [1..]
03:29:10 <lambdabot>   "hooray"
03:29:49 <ivanm> Vanadium: well, WHNF would only do 1 : [2..] IIRC...
03:30:02 <Vanadium> ivanm: I figure it would only do Just _
03:30:14 <ivanm> Vanadium: right, missed the Just there
03:30:20 <ivanm> > const "hooray" $! [1..]
03:30:22 <lambdabot>   "hooray"
03:30:26 <Vanadium> But, yeah, I also... expected that to fail
03:30:31 <Vanadium> So thanks for clearing that up.
03:30:45 <Vanadium> > const "hooray" $! Just undefined
03:30:46 <lambdabot>   "hooray"
03:30:57 <ivanm> > const "hooray" $! undefined
03:30:58 <lambdabot>   "* Exception: Prelude.undefined
03:31:03 <ivanm> > const "hooray" $ Just undefined
03:31:04 <lambdabot>   "hooray"
03:32:10 <Vanadium> Is there a way to fully evaluate an arbitrary value?
03:32:53 <Twey> Woof: seq is magic.
03:33:07 <Axman6> there is... but i can't remember its name right now
03:33:16 <Axman6> something like execute
03:33:25 <Axman6> @hoogle a -> IO a
03:33:26 <lambdabot> Control.Exception evaluate :: a -> IO a
03:33:26 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
03:33:26 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
03:33:33 <Axman6> exaluate, that's the one
03:33:55 <Axman6> v*\
03:34:09 <Twey> Yeah, there's something in Control.Parallel
03:34:19 <Axman6> rnf
03:34:24 <Twey> That's the one
03:34:29 <Twey> :t rnf
03:34:32 <lambdabot> forall a. (NFData a) => a -> Done
03:35:05 <mapreduce> @hoogle Byte
03:35:05 <lambdabot> System.Posix.Types type ByteCount = CSize
03:35:06 <lambdabot> module Data.ByteString
03:35:06 <lambdabot> module Text.Parsec.ByteString
03:35:15 <mapreduce> Is there a Byte type?
03:35:55 <doserj> @index Word8
03:35:56 <lambdabot> Data.Word, Foreign
03:36:22 <quicksilver> Vanadium: No.
03:36:32 <maartenm> how do I easily check if one list is a subset of another list?
03:36:33 <quicksilver> Vanadium: there is only rnf, which doesn't work on arbitrary values.
03:37:29 <quicksilver> > [2,4,5] // [1,2,3,4,5] == []
03:37:31 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
03:37:35 <quicksilver> > [2,4,5] \\ [1,2,3,4,5] == []
03:37:36 <lambdabot>   True
03:37:49 <maartenm> thanks!
03:37:49 <quicksilver> maartenm: like that, is the best way I can think of.
03:37:58 <maartenm> intersect and substract, great
03:38:20 <maartenm> is intersect lazy? (I guess I already know the answer though)
03:38:32 <maartenm> I mean, once it sees the second list appears in the first infinite one
03:41:21 <Twey> @info NFData
03:41:22 <lambdabot> NFData
03:41:29 <Twey> . . .
03:50:04 <maartenm> > read "12345"::Bits
03:50:05 <lambdabot>   Class `Data.Bits.Bits' used as a type
03:53:22 <Twey> > read "12345" :: Bits a => a
03:53:24 <lambdabot>   Could not deduce (GHC.Read.Read a)
03:53:24 <lambdabot>    from the context (Data.Bits.Bits a)
03:53:24 <lambdabot>  ...
03:57:57 <ivanm> mmorrow: got sick of the underscore, did you?
04:00:40 <mmorrow> ivanm: it always sneaks in there when i least expect it
04:04:12 <ivanm> mmorrow: it's been there all day AFAICT ;-)
04:04:35 <mmorrow> it is sly like a fox!
04:05:17 <cizra> Hello all! I'm having difficulties with RWH exercise 4.1.1, safeInit at http://book.realworldhaskell.org/read/functional-programming.html#id591678
04:06:00 <Lemmih> > init "list"
04:06:02 <lambdabot>   "lis"
04:06:04 <Lemmih> > init ""
04:06:06 <lambdabot>   "* Exception: Prelude.init: empty list
04:06:29 <Twey> cizra: What are you having trouble with?
04:06:31 <cizra> My current approach is simple pattern matching for the easy cases: safeInit [] = Nothing, safeInit [a] = Just []
04:06:43 <cizra> The recursive case is tricky..
04:06:56 <Lemmih> cizra: 'safeInit [a]' doesn't do what you think it does.
04:06:59 <cizra> I want to say safeInit (x:xs) = Just (x:SOMETHING)
04:07:03 <Lemmih> Or maybe it does.
04:07:12 <Twey> cizra: Hmm
04:07:12 <cizra> Lemmih: Please elaborate...
04:07:14 <Vanadium> cizra: You could just use regular init for the case in which it does not fail.
04:07:15 <Lemmih> cizra: You don't need the '[a]' case.
04:07:16 <gal_bolle> it does
04:07:16 <Twey> cizra: Do you understand monads yet?
04:07:34 <gal_bolle> i don't thin
04:07:36 <cizra> Twey: Not much..
04:07:44 <gal_bolle> you don't need yet
04:07:45 <Twey> Okay, let's not use that way, then
04:08:47 <cizra> safeInit (x:xs) = Just (x:rest) where rest = -- do something to de-Maybeize the tail
04:08:52 <cizra> Is this a good approach?
04:08:57 <gal_bolle> yup
04:09:14 <Twey> cizra: You want Maybe [a], not Maybe (Maybe (Maybe [a])), so you need to extract the value from the Just before doing something with it
04:09:17 <Twey> Yes
04:09:26 <Twey> You can just pattern-match it out with a let
04:09:46 <Twey> Or alternatively you can use maybe or fromMaybe
04:09:47 <gal_bolle> now you're going to do a recursive call, what's it going to give you, how do you get from that to what you want?
04:09:48 <Twey> :t maybe
04:09:50 <Twey> :t fromMaybe
04:09:50 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:09:51 <lambdabot> forall a. a -> Maybe a -> a
04:10:41 <Lemmih> cizra: Or: safeInit (x:xs) = Just (init' x xs) where init' v [] = []; init' v (x:xs) = v:init' x xs
04:11:04 <doserj> safeInit [] = Nothing; safeInit xs = Just (init xs)
04:11:08 <cizra> gal_bolle: The idea was to accumulate the de-Maybeized x's in the stack and apply Just to them when the recursion ends.
04:11:56 <cizra> doserj: I thought about this. I agree that it'd be a good way to write it, but I wanted to figure out the recursive version as well.
04:12:29 <Saizan_> cizra: safeInit (x:xs) = Just (x: case safeInit xs of Nothing -> []; Just xs' -> Just xs')
04:12:38 <Saizan_> err sorry
04:12:41 <Saizan_> cizra: safeInit (x:xs) = Just (x: case safeInit xs of Nothing -> []; Just xs' -> xs')
04:13:25 <cizra> Saizan_: Riiight. This is what I meant but couldn't write.
04:14:21 <Saizan_> safeInit (x:xs) = Just (x: fromMaybe [] (safeInit xs)) -- equivalent
04:14:25 <Saizan_> ?src fromMaybe
04:14:25 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
04:15:52 <cizra> Coolie cool, thank you all! It clarified matters.
04:16:36 <gal_bolle> cizra: do test Saizan's solution
04:16:45 <gal_bolle> i'm not sure it's not id
04:17:01 <cizra> gal_bolle: Works well. (although I replaced the case expression with a where'd name)
04:17:02 <Twey> No, it's not id :)
04:17:06 <gal_bolle> sorry
04:24:37 <sinelaw> as anyone here used rt-frp?
04:26:46 <gal_bolle> cizra: be aware still that with Saizan_'s code, you do *need* the safeInit [a] case
04:27:20 <gal_bolle> (see why? What happens otherwise?)
04:27:20 <doserj> no he doesn't. safeInit [] = Nothing is sufficient
04:28:13 <doserj> err
04:28:33 <Vanadium> So you guys think solving it in terms of the unsafe functions would have been cheating? :'(
04:28:41 <gal_bolle> nope
04:30:36 <Saizan_> using the [a] case looks like the more declarative way to write init
04:30:41 <Saizan_> ?src init
04:30:41 <lambdabot> init [x]    = []
04:30:41 <lambdabot> init (x:xs) = x : init xs
04:30:41 <lambdabot> init []     = undefined
04:31:39 <EvilTerran> safeInit [] = Nothing; safeInit xs = Just (init xs) :P
04:31:45 <Vanadium> > let safeInit undefined = Nothing, safeInit xs = Just init xs in map safeInit ["foo", ""]
04:31:46 <lambdabot>   <no location info>: parse error on input `,'
04:31:48 <int-e> what's the [x] case for?
04:31:59 <int-e> err
04:32:06 * int-e is stupid.
04:32:24 <Vanadium> welp, cannot match against undefined :C
04:32:35 <EvilTerran> very much so
04:33:09 <Saizan_> and you can't use commas instead of semicolons :)
04:33:20 <Vanadium> Yes, and I need a $ after Just~
04:33:41 * EvilTerran still thinks warnings for redefining "undefined" and "otherwise" may be in order
04:33:55 <Vanadium> I forgot what otherwise even does
04:34:05 <Saizan_> ?src otherwise
04:34:05 <lambdabot> otherwise = True
04:34:15 <Vanadium> Well that is not terribly exciting
04:34:21 <quicksilver> EvilTerran: maybe shadowing in a pattern could be a separate warning from normal shadowing?
04:34:40 <sayyestolife> oh shit, there is some smart people at project euler
04:34:43 <quicksilver> EvilTerran: "normal" shadowing I don't consider worrying enough to warn about, but maybe shadowing in a pattern is more often a mistake.
04:35:31 <Saizan_> quicksilver: what do you mean by "in a pattern"? aren't most variables created in patterns?
04:36:00 <Vanadium> There is also where-bindings, I suppose?
04:36:06 <quicksilver> "let x = bar" isn't considered a 'proper' pattern
04:36:12 <quicksilver> while "let (x) = bar" is, for example.
04:36:18 <quicksilver> this came up a while ago in a mailing list post
04:36:33 <Saizan_> "foo x =" is x a pattern there?
04:36:35 <quicksilver> they are different w.r.t monomorphism, for example.
04:36:47 <opqdonut> wow
04:36:51 <quicksilver> Saizan_: I think so, yes.
04:36:56 <quicksilver> Saizan_: I"m not sure though.
04:37:00 <Vanadium> quicksilver: Hm, can you demonstrate the monomorphism thing?
04:37:07 <quicksilver> I think case is always a pattern
04:37:13 <quicksilver> but let is only a pattern when it looks liek a pattern
04:37:18 <quicksilver> (function definitions are case)
04:37:23 <Saizan_> > let (x) = 1 in (x::Int,x::Integer)
04:37:24 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
04:37:29 <Saizan_> > let x = 1 in (x::Int,x::Integer)
04:37:31 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
04:37:39 <opqdonut> > let x = id; (y) = id in (x 1, x "", y 1, y "")
04:37:41 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
04:37:41 <lambdabot>    arising from the literal ...
04:37:49 <opqdonut> > let x = id; y = id in (x 1, x "", y 1, y "")
04:37:51 <lambdabot>   (1,"",1,"")
04:37:52 <opqdonut> ta-dah
04:37:57 <Vanadium> Thank you
04:38:14 <Saizan_> oh, even worse than the MR?
04:38:37 <Saizan_> well, how i usually think of the MR anyway
04:38:43 <quicksilver> well lambdas bind monomorphically in HM inference
04:38:49 <quicksilver> and patterns are lambdas.
04:38:57 <quicksilver> otherwise you need higher-rank inference.
04:39:14 <Saizan_> i see
04:39:14 <quicksilver> I meant to say 'lambdas are patterns'
04:39:18 <quicksilver> sorry ;)
04:39:37 <quicksilver> I am not familiar with all the ins and outs of this
04:39:42 <Saizan_> it makes more sense with "patterns are lambdas" to me :)
04:39:46 <quicksilver> but I believe there are Reasons For It.
04:43:08 <Saizan_> ah, is this MonoPatBinds?
04:43:11 <quicksilver> yes
04:45:35 <Cale> I think that's a strange step to take. (MonoPatBinds)
04:46:18 <benmachine> ?src listToMaybe
04:46:19 <lambdabot> listToMaybe []        =  Nothing
04:46:19 <lambdabot> listToMaybe (a:_)     =  Just a
04:46:45 <Saizan_> so it's a ghc extension enabled by default
04:46:55 <Cale> In general, I tend to think we should try to default things to being polymorphic, and let people add type signatures if they want them to be monomorphic.
04:49:24 <Saizan_> i can't find somewhere that explains the motivation
04:53:24 <ivanm> mmorrow: you still around?
04:56:16 <bgs100> Okay... partial application has blown me away :D
04:56:44 <bgs100> > let divideByTen = (/10) in divideByTen 20
04:56:46 <lambdabot>   2.0
04:56:57 <nlogax> i used to do that "manually" in JS, then i saw how haskell did it.. i don't think i like JS any more :(
04:57:02 <nlogax> damn you haskell *shakes fist*
04:57:59 <bavardage> you can make a curry function in just though
04:58:07 <bavardage> it's just not as nice...
04:58:10 <bavardage> *in JS
04:58:28 <nlogax> yeah
04:58:54 <Vanadium> Hmm, how?
05:01:09 <FauxFaux> At worst, function(a) { return foo(7, a); } is manual.
05:02:02 <FauxFaux> And a function takes any number of arguments anyway.
05:02:09 <Saizan_> curry = function(f) { return function(a) { return function(b) { return f(a,b); };};} ?
05:02:30 <FauxFaux> Damn you, I have to go try NiHing that now.
05:02:51 <Saizan_> NiHing?
05:03:06 <Vanadium> Yeah, I would try to use the magical all-received-arguments array to generalise it
05:03:34 <Vanadium> But I forgot how it was called and how to call a function with an array as arguments and how to make that currying work with the whole "this" thing.
05:04:03 <FauxFaux> Oh, yeah, that might get bad.
05:04:04 <quicksilver> you use "call"
05:04:06 <nlogax> .apply(thingToBeThisUrgh, arguments)
05:04:15 <quicksilver> or apply if you want a 'this'
05:04:24 <quicksilver> since when is nlogax in this channel anyway
05:04:32 * quicksilver pushes him back to #jquery
05:04:54 <nlogax> .call(thisThing, arg1, arg2, arg3..), apply(thisThing, arrayOfArgs)
05:05:07 <nlogax> quicksilver: noes!
05:05:34 <Vanadium> function curry(f, val) { var that = this; return function() { var args = arguments; args.insert(val, 0); f.apply(that, args); } } then?
05:07:47 <bgs100> > zipWith (++) ["I ","lots ","pie"] ["like","of","!"]
05:07:49 <lambdabot>   ["I like","lots of","pie!"]
05:08:11 <bgs100> > zipWith (:[]) [1,2,3] [4,5,6]
05:08:12 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a]'
05:08:34 <bgs100> Oh, nvm :P
05:09:00 <bgs100> > zipWith (-) [1,2,3] [4,5,6]
05:09:02 <lambdabot>   [-3,-3,-3]
05:09:17 <bgs100> > zipWith (+) [1,2,3] [4,5,6]
05:09:18 <lambdabot>   [5,7,9]
05:09:35 <bgs100> > zipWith (*) [1,2,3] [4,5,6]
05:09:36 <lambdabot>   [4,10,18]
05:15:54 <ivanm> @ask mmorrow what exactly does SwitchTrie do? (so that I have a better idea of what/how your code does)
05:15:55 <lambdabot> Consider it noted.
05:19:10 <bgs100> > let test x y = x:y:[] in zipWith test [1,2,3] [4,5,6]
05:19:11 <lambdabot>   [[1,4],[2,5],[3,6]]
05:21:49 <Axman6> :t (:).(:[])
05:21:51 <lambdabot> forall a. a -> [[a]] -> [[a]]
05:23:23 <int-e> @type (.(:[])).(:)
05:23:25 <lambdabot> forall a. a -> a -> [a]
05:23:47 <Axman6> @pl \a b -> a:b:[]
05:23:47 <lambdabot> (. return) . (:)
05:24:21 <bgs100> > zipWith ((.(:[])).(:)) [1,2,3] [4,5,6]
05:24:23 <lambdabot>   [[1,4],[2,5],[3,6]]
05:24:34 <cizra> gal_bolle: Yes, I understand it. Otherwise there is no last item dropping. It could be fixed with (x:y:xs).
05:24:42 <bgs100> :o
05:25:51 <hackagebot> data-ordlist 0.0 - Set and bag operations on ordered lists (LeonSmith)
05:27:06 <asmips> is there any package for human-readable formatting of arrays? I'd like to print out 2-d matrices in readable format.
05:27:26 <bgs100> > map (replicate 2) "Test"
05:27:28 <lambdabot>   ["TT","ee","ss","tt"]
05:27:38 <bgs100> > concat (map (replicate 2) "Test")
05:27:40 <lambdabot>   "TTeesstt"
05:27:51 <bgs100> > concat (map (replicate 3) "Hello")
05:27:53 <lambdabot>   "HHHeeellllllooo"
05:28:44 <ivanm> asmips: not really, but IIRC I've got some code hanging around that will do that
05:28:53 <ivanm> in the sense it prints a 2D table
05:29:49 <mmorrow> ivanm: it makes a trie, where the trie's structure is made explicit with a switch stmt
05:29:50 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
05:29:58 <mmorrow> ivanm: like http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2962#a2962
05:30:07 <ivanm> mmorrow: what do you meen "explicit"?
05:30:14 <mmorrow> that's for abcdef abce abxy azz z
05:30:14 <quicksilver> asmips: something more than unlines . map (intercalate " ") ?
05:30:34 <mmorrow> ivanm: it essentially hard-codes the trie into the machine code
05:30:41 <ivanm> oh, right, non-Haskell code :s
05:30:50 <ivanm> quicksilver: though that won't align columns
05:31:15 <mmorrow> ivanm: i've actually got code that generates the equivalent haskell code to that, but with case stmts
05:31:22 <quicksilver> yes.
05:31:22 <ivanm> *nod*
05:31:33 <quicksilver> it's not very hard to add that though ;)
05:31:33 <soupdragon> mmorrow http://www.discontinuity.info/~pkhuong/string-case.lisp
05:31:35 <mmorrow> ivanm: that one just takes forever to compile though
05:31:57 <ivanm> as in literally forever?
05:32:07 <mmorrow> soupdragon: oh cool, /me checks that out
05:32:23 <ivanm> hmmm.... hpaste seems rather slow atm...
05:32:30 <mmorrow> ivanm: for large enough number of input words, i killed it after 20minutes
05:32:42 <ivanm> heh
05:32:58 <mmorrow> ivanm: (i tried to compile the resulting .c from /usr/share/dict/words from switchtrie... killed that one after like an hour)
05:33:07 <mmorrow> gcc was 3.4GB resident
05:33:13 <ivanm> mmorrow: :o
05:33:15 * ivanm wants to know who killed hpaste
05:33:19 <mmorrow> uhoh
05:33:32 <mmorrow> ivanm: works for me
05:33:37 <ivanm> :o
05:33:50 <ivanm> mmorrow: real hpaste or your hpaste?
05:34:01 <mmorrow> hpaste.org, right?
05:34:40 <asmips> @src intercalate
05:34:41 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
05:34:51 <ivanm> mmorrow: yeah... weird, opera loaded it fine but not ff...
05:34:58 <mmorrow> hmm, odd
05:35:17 <asmips> ivanm: that would be really useful, if you don't mind.
05:35:19 <ivanm> asmips: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6794#a6794
05:35:31 <ivanm> just strip off all of my Square stuff from there
05:35:41 <asmips> ivanm: awesome! thanks!!
05:35:52 <ivanm> I basically find out how wide each column should be, and pad appropriately
05:36:07 <ivanm> using a schwarzian-transform-style approach to improve efficiency slightly ;-)
05:36:44 <ivanm> asmips: oh, row = fst and col = snd
05:37:08 <LeoD> can anyone help me install hlint? i'm getting these errors: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6795#a6795
05:37:11 <ivanm> and getValue = snd as well
05:37:29 <ivanm> LeoD: install happy first
05:37:34 <LeoD> ok
05:37:35 <ivanm> it isn't available from hackage
05:38:11 <ivanm> mmorrow: so in this case, what advantage is there in using Doc rather than String in generating the code?
05:38:25 <ColeSOAR> noob questions okay?
05:38:28 <mmorrow> soupdragon: (my switchtrie code's at http://moonpatio.com/repos/switchtrie/)
05:38:34 <lpsmith> ColeSOAR:  of course!
05:38:38 <mmorrow> ivanm: only the convenient Doc combinators
05:38:42 <ivanm> *nod*
05:38:53 <ColeSOAR> ok, here's my noob question.  i want to sort a list of tuples, by the second value of course.  what's the ez way?
05:39:02 <ivanm> ColeSOAR: though if they're too annoying we feed you to the dragon
05:39:04 <ivanm> ;-)
05:39:07 <mmorrow> , foldr (.) id (replicate 8 (braces . parens . brackets)) (int 42)
05:39:08 <lunabot>  {([{([{([{([{([{([{([{([42])}])}])}])}])}])}])}])}
05:39:12 <ivanm> ColeSOAR: sortBy (compare `on` snd)
05:39:18 <quicksilver> > sortBy (comparing snd) [(1,2),(3,1)]
05:39:19 <lambdabot>   [(3,1),(1,2)]
05:39:21 <ivanm> where on is from Data.Function
05:39:22 <ColeSOAR> oh my gawd durr.
05:39:28 <ivanm> quicksilver: gah, I always forget about comparing
05:39:29 <quicksilver> comparing = compare `on`
05:39:31 <ivanm> @index comparing
05:39:32 <lambdabot> bzzt
05:39:33 <ColeSOAR> comparing?
05:39:34 <quicksilver> well, compare `on` is better.
05:39:40 <quicksilver> :t comparing
05:39:41 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:39:41 <ivanm> quicksilver: more adaptable
05:39:49 <ivanm> @hoogle comparing
05:39:49 <quicksilver> it's from Data.Ord or Data.List I don't remember.
05:39:50 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:39:50 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
05:39:57 <ivanm> Data.Ord by the looks of things
05:39:59 <mmorrow> there's a Data.Ord??
05:40:04 <lpsmith> I included sortOn functions in my data.ordlist package
05:40:09 <ivanm> mmorrow: sure looks like it... >_>
05:40:12 <mmorrow> weird
05:40:37 <lpsmith> As it's a somewhat common idiom and I find sortBy (compare `on` f) rather cumbersome
05:40:57 <ivanm> mmorrow: looks like Prelude just re-exports it
05:41:01 <ColeSOAR> not in scope `on'?
05:41:05 <ivanm> it just has the Ord class, the Ordering data type and comparing
05:41:08 <quicksilver> on is in Data.Function
05:41:09 <ivanm> ColeSOAR: import Data.Function
05:41:09 <mmorrow> ColeSOAR: Data.Function
05:41:11 <lpsmith> Yeah, and Data.Ord is missing several rather useful features too
05:41:13 <ivanm> heh
05:41:14 <ColeSOAR> wow this channel is cool
05:41:18 <ivanm> lpsmith: such as?
05:41:28 <ivanm> ColeSOAR: dammit, now I have to leave...
05:41:38 * ivanm has vowed to never be part of anything cool
05:41:39 <ivanm> :@
05:41:48 <ivanm> eh, couldn't stay away
05:41:49 <ivanm> ;-)
05:41:52 <burp> > (Just 3) >>= (1+)
05:41:53 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
05:41:53 <lambdabot>    arising from the lite...
05:41:56 <burp> hm, did I get maybe monad wrong?
05:42:09 <burp> shouldn't this return Just 4?
05:42:11 <cizra> Wait, what, Maybe is a monad?
05:42:13 <quicksilver> Data.Ord.computeSmallestOrdinalNotProvableInZFC
05:42:17 <lpsmith> e.g. negate an ordering
05:42:22 <quicksilver> is one obvious one missing.
05:42:26 <ivanm> quicksilver: apparently comparing isn't defined using on...
05:42:29 <lpsmith> and combine two orderings into a lex ordering
05:42:30 <ivanm> quicksilver: heh
05:42:30 <lpsmith> etc
05:42:32 <LeoD> > Just 3 >>= return . (1+)
05:42:33 <lambdabot>   Just 4
05:42:36 <ivanm> lpsmith: so flip compare `on` ?
05:42:37 <burp> oh.. lol
05:42:38 <ColeSOAR> now maybe you can explain monads to me.  nothing i've read on them makes any sense
05:42:40 <burp> forgot the return. sure
05:42:43 <burp> thanks
05:42:59 <ivanm> @seen Cale
05:43:00 <lambdabot> Cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard Cale speak 56m 4s ago.
05:43:05 <ivanm> he generally has the best explanations...
05:43:12 <lpsmith> @def on
05:43:13 <lambdabot> Maybe you meant: bf let
05:43:20 <ivanm> @src on
05:43:21 <lambdabot> (*) `on` f = \x y -> f x * f y
05:43:25 <ivanm> lpsmith: ^^ what you meant?
05:43:29 <quicksilver> ivanm: comparing predated `on`, that's why.
05:43:33 <ivanm> true
05:43:35 <lpsmith> no
05:43:39 <lpsmith> well, yes
05:43:40 <lpsmith> but no
05:43:45 <ivanm> quicksilver: can on be considered the inspiration behind on?
05:43:48 <ivanm> lpsmith: heh
05:44:03 <quicksilver> lpsmith: well, orderings aren't a type per se (although they should be)
05:44:05 <lpsmith> I mean,  something like neg
05:44:12 <quicksilver> lpsmith: if they were, then that is the natural monoid instance on them.
05:44:26 <ivanm> lpsmith: oh, just flip compare?
05:44:38 <ivanm> > sortBy (flip compare) [1..10]
05:44:39 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
05:44:54 <lpsmith> duh
05:45:20 <lpsmith> Why was I thinking that one was needed
05:45:23 <lpsmith> wait
05:45:39 <lpsmith> ok,  maybe not
05:45:42 <ivanm> having a default sortReverse = sortBy (flip compare) might be handy though
05:45:51 <lpsmith> then what about a lexigraphic combinatory
05:46:13 <lpsmith> :t sortBy
05:46:14 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
05:46:18 <ivanm> no idea what you mean by that tbh
05:46:23 <maartenm> :t otherwise
05:46:25 <lambdabot> Bool
05:46:29 <ivanm> lpsmith: realistically, this is a list problem not an Ord one
05:46:34 <ivanm> so it wouldn't belong in Data.Ord anyway
05:46:45 <maartenm> @src otherwise
05:46:45 <lambdabot> otherwise = True
05:46:54 <maartenm> ah, that's how it works
05:47:08 <quicksilver> instance Monoid (a -> a -> Ordering) where mempty = \a b -> EQ; mappend c d = \a b -> (a `c` b) `mappend` (a `d` b)
05:47:18 <quicksilver> is what lpsmith wants I think.
05:48:05 <lpsmith> @let  lex x y = case x of { LT -> LT;  EQ -> y;  GT -> GT }
05:48:07 <lambdabot>  Defined.
05:48:52 <lpsmith> heh,  it's been a minute since I've thought about this quibble...
05:49:11 <quicksilver> lpsmith: yes, that's what you get from my instance
05:49:18 <quicksilver> assuming you have the monoid instance for Ordering in scope.
05:49:26 <quicksilver> > LT `mappend` GT
05:49:27 <lambdabot>   LT
05:49:31 <quicksilver> > LT `mappend` LT
05:49:32 <lambdabot>   LT
05:49:34 <quicksilver> > LT `mappend` EQ
05:49:35 <lambdabot>   LT
05:49:39 <quicksilver> > EQ `mappend` LT
05:49:41 <lambdabot>   LT
05:49:42 <quicksilver> see? ;)
05:50:04 <lpsmith> didn't realize they put ordering in this newfangled monoid thing ;-)
05:50:38 <asmips> @src getLoc
05:50:39 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:53:16 <Advantage> Hello, is it right question to ask newbie questions about haskell?
05:53:30 <quicksilver> yes.
05:55:11 <Advantage> I've been stuck with PHP/javscript for almost 3 years and almost exclusively and 2 days ago I've started to look at Lisp, FP. But now I finally see that Haskell may be a better language to learn
05:55:27 <lpsmith> yes and no
05:55:27 <ceninan> ColeSOAR: on monads - personally I found it helpful to read about monads from a Clojure perspective
05:55:38 <lpsmith> Haskell and Scheme are both well worth learning :-)
05:55:54 <Advantage> The question is, shall I read through HTDP and become familiar with Scheme or jump right into Haskell?
05:55:59 <ceninan> ColeSOAR: as Clojure does allow side-effects, it gets away from the whole "Monads are for side-effects" thing
05:56:23 <ColeSOAR> mm
05:56:23 <quicksilver> Advantage: I don't think learning scheme first is any particular advantage.
05:56:32 <quicksilver> Advantage: although it is surely an interesting thing to learn.
05:56:38 <lpsmith> Advantage:  up to you,  there are advantages to both.
05:57:00 <Advantage> well, Scheme is very interesting and I don't have word to describe how much refreshing is it after PHP
05:57:10 <lpsmith> Advantage:  although I daresay that types and pattern matching are especially nice things for learning functional programming
05:57:30 <ceninan> ColeSOAR: (eg http://onclojure.com/2009/03/05/a-monad-tutorial-for-clojure-programmers-part-1/, http://intensivesystems.net/tutorials/monads_101.html)
05:58:04 <cizra> Advantage: You can write PHP in Scheme (= You can write PHP in Haskell as well, for that matter. It's just more difficult.
05:58:10 <lpsmith> You can do pattern matching in scheme,  but there are several different pattern matching libraries,  and it doesn't quite work the same as Haskell in that respect
05:58:14 <Advantage> is there any good starting point to dig into haskell? (I know google, just want the most recent, not the most popular way)
05:58:44 <cizra> Advantage: The question is, do you want to jump into the philosophy or not. Haskell will make your brain hurt A LOT at first, but it'll eventually teach you better philosophies.
05:58:55 <cizra> Advantage: book.realworldhaskell.com
05:59:10 <asmips> Advantage: I learned scheme skimming through SICP(free book online), before starting on Haskell now. The transition is really easy if you start w/ scheme.
05:59:19 <cizra> Advantage: Google for "real world haskell" and "learn you a haskell for great good"
05:59:21 <Twey> Oh, there's actually a person called Advantage
05:59:24 <Twey> How confusing
05:59:27 <sinelaw> as anyone here worked with/on RT-FRP?
05:59:30 <Advantage> cizra: I want philosophy.
05:59:31 <sinelaw> *has
05:59:49 <Advantage> sorry about confusion :)
05:59:58 <cizra> Advantage: As asmips said, Scheme is really a lot easier (more of your old programming knowledge can carry over).
06:00:05 <lpsmith> I really liked Richard Bird's book, I haven't read any of the more recent tutorial books
06:00:12 <Advantage> Ok, guys, thanks don't mean to waste your time. Just wanted to shoot a couple of questions and 'touch' a community
06:00:33 <Advantage> *guys/girls*
06:00:44 <lpsmith> There's also that Haskell Road,  which is pretty sweet,  and Graham Hutton's book looks pretty nice
06:00:47 <quicksilver> @go haskellwiki books
06:00:49 <lambdabot> http://en.wikibooks.org/wiki/Haskell
06:00:49 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
06:00:55 <quicksilver> hmm that's not what I wanted.
06:01:02 <quicksilver> @go inurl:haskellwiki books
06:01:04 <lambdabot> http://www.haskell.org/haskellwiki/Books
06:01:04 <lambdabot> Title: Books - HaskellWiki
06:01:06 <Twey> Advantage: You can ask all the newbie questions here you want.  :)
06:01:19 <quicksilver> Advantage: if dead trees are your things, there are some good books on that page.
06:01:26 <quicksilver> @where LYAH
06:01:27 <lambdabot> www.learnyouahaskell.com
06:01:27 <Twey> Bah, Haskell Road my eye
06:01:36 <quicksilver> Advantage: if you like alternative online tutorials LYAH is great :)
06:01:41 <quicksilver> it even has a picture of a list monster.
06:01:50 <Twey> I started reading it and got as far as it calling Haskell a Lisp
06:01:59 <Twey> Then I closed it and ranted for a bit
06:02:05 <Advantage> ok, thanks :)
06:02:23 <LeoD> huh, hlint is giving me a Parse error where ghc doesn't
06:02:24 <Twey> Advantage: There's plenty of cool stuff you can do with FP in Javascript, too
06:02:30 <cizra> http://learnyouahaskell.com/listmonster.png
06:02:37 <Advantage> Twey: yes, noticed that
06:02:39 <quicksilver> listmonster++
06:02:49 <maartenm> lyah is great, I am also a newbie
06:03:06 <maartenm> much better than RWH in my opinion
06:03:26 <Twey> There was a good article with a Javascript parser monad
06:03:49 <ivanm> the haddock for sep in PrettyPrint says it' is either hsep or vcat... what does that mean?
06:03:59 <ivanm> since hsep and vcat are two different functions... >_>
06:04:04 <Vanadium> maartenm: I found it useful to read lyah to get a grasp on the language and then go back to reading through RWH to see what to do with it
06:04:11 <ivanm> or does it "intelligently" choose which to use based on line lengths?
06:04:29 <mmorrow> ivanm: i never use sep personally
06:04:36 <ivanm> *nod*
06:04:44 <ivanm> mmorrow: nest is for indentation, right?
06:04:50 <mmorrow> ivanm: yes
06:04:55 <ivanm> and <+> is basically <> space <> ?
06:05:17 <mmorrow> , text "asd" $+$ nest 2 (brackets (text "f"))
06:05:19 <lunabot>  asd
06:05:19 <lunabot>    [f]
06:05:35 <mmorrow> , comma <> semi <+> colon
06:05:37 <lunabot>  ,; :
06:05:57 <Twey> ... but I can't fin dit
06:06:09 <mmorrow> , (parens . hcat . punctuate comma . fmap int) [0..9]
06:06:10 <lunabot>  (0,1,2,3,4,5,6,7,8,9)
06:06:13 <ivanm> > text "asd" $+$ nest 2 (brackets (text "f"))
06:06:14 <lambdabot>   asd
06:06:14 <lambdabot>    [f]
06:06:26 <ivanm> hmmm... lambdabot and lunabot indent the second line differently...
06:06:35 <ivanm> oh, wait, lambdabot indents the first line an extra space
06:06:37 <mmorrow> i think it's the first line that's diff
06:06:37 <dschoepe> Is there a replacement library for System.IO, System.Directory, etc. where the functions are already liftIO'd?
06:06:39 <mmorrow> yeah
06:06:41 <ivanm> presumably to avoid lines starting with >
06:06:56 <Twey> lunabot doesn't?
06:06:59 <mmorrow> ivanm: dunno why it needs two spaces though
06:07:10 <Twey> ] text "> \"Hi!\""
06:07:12 <lunabot>  > "Hi!"
06:07:13 <mmorrow> lunabot: it's impossible to get lunabot to print anything in the first column
06:07:17 <Twey> lunabot does too
06:07:19 <ivanm> Twey: lambdabot seems to give an extra two spaces for the first line and 1 for each subsequent line; lunabot does one space per line
06:07:23 <Twey> Aha.
06:07:30 <mmorrow> oops, i'm talking to lunabot
06:07:31 <LeoD> any idea why hlint is giving me a parse error here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6797#a6797
06:07:33 <Twey> Heh
06:07:57 <Twey> LeoD: Er, all that extraneous indentation before the function
06:08:07 <LeoD> Twey: well the function is in a where block
06:08:34 <Twey> It seems to be saying that rec is a reserved word
06:08:41 <LeoD> Twey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6798#a6798 should i indent where differently?
06:08:43 <mmorrow> ivanm: the subset of HughesPJ that i seem to use is:
06:08:44 <LeoD> ah!
06:08:58 <Twey> I've never heard of it, though
06:09:03 <Twey> And the wiki page doesn't list it
06:09:14 <Twey> Perhaps some sort of extension?
06:09:30 <mmorrow> ivanm: (text,int,integer,double,braces,brackets,parens,comma,semi,colon,hcat,vcat,punctuate,char,(<>),(<+>),($+$),nest)
06:09:37 <mmorrow> and i think that's it
06:09:44 <ivanm> *nod*
06:09:50 <maartenm> :t do
06:09:51 <lambdabot> Empty 'do' construct
06:09:52 <ivanm> no equal ? ;-)
06:09:58 <maartenm> what exactly is "do"?
06:10:01 <mmorrow> , equals
06:10:03 <lunabot>  =
06:10:06 <mmorrow> good to know
06:10:07 <mmorrow> :)
06:10:09 <ivanm> maartenm: do is syntactic sugar for monadic code
06:10:14 <maartenm> ah, ok
06:10:20 <maartenm> oh yeah, I remembe rnow
06:10:22 <LeoD> Twey: yeah, renaming rec helped, thanks
06:10:33 <maartenm> <<= stuff.. I had haskell at uni about ten years ago
06:11:17 <dschoepe> Is there any chance the standard IO-ish functions like putStr will be lifted to arbitrary MonadIOs in the next ghc version?
06:11:33 <ivanm> dschoepe: I doubt it
06:11:43 <ivanm> as that sounds like it will break the report
06:11:50 <Twey> So what does rec mean?
06:11:53 <Twey> Does anyone know?
06:11:54 <ivanm> besides, the next version of ghc will be announced in september ;-)
06:11:57 <ivanm> @hoogle rec
06:11:57 <lambdabot> Language.Haskell.TH RecC :: Name -> [VarStrictType] -> Con
06:11:58 <lambdabot> Language.Haskell.TH.Syntax RecC :: Name -> [VarStrictType] -> Con
06:11:58 <lambdabot> Language.Haskell.TH recC :: Name -> [VarStrictTypeQ] -> ConQ
06:11:59 <Twey> > let rec = 3 in rec
06:12:00 <lambdabot>   3
06:12:16 <sinelaw> I need help understanding this syntax definition:
06:12:26 <Twey> GHCi's okay with it... Hoogle has nothing...
06:12:48 <ivanm> Twey: my ghci doesn't know anything about rec...
06:12:57 <Twey> Nor does mine
06:12:59 <Saizan_> rec is a required keyword if you use Arrows syntax
06:13:00 <sinelaw> e ::= x j c j() j(e1; e2) j e? j?j.x:e je1 e2
06:13:00 <sinelaw> e := x | c | () | (e1, e2) | e_|_ | _|_ | \x.e | e1 e2
06:13:13 <sinelaw> oops, ignore the first one. and then you have:
06:13:17 <dschoepe> ivanm: Hmm, is there any other alternative to calling liftIO all the time? Some replacement libraries perhaps?
06:13:18 <ivanm> mmorrow: if only there was an easy way to scrape the content off the definition page for graphviz attributes... :s
06:13:31 <ivanm> dschoepe: seeing as I have no real idea what liftIO is... ;-)
06:13:32 <ivanm> @hoogle liftIO
06:13:34 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
06:13:35 <sinelaw> v ::= c | () | (v1,v2) | v_|_ | _|_ | \x.e
06:13:37 <ivanm> Saizan_: ahhh
06:13:46 <sinelaw> what does this mean?
06:13:49 <sinelaw> i don't know how to read it
06:13:58 <ivanm> sinelaw: doesn't look like Haskell to me...
06:13:59 <quicksilver> isn't rec also required in mdo syntax?
06:14:04 <ivanm> unless it's library...
06:14:07 <ivanm> @hoogle (::=)
06:14:07 <lambdabot> Warning: Unknown type ::=
06:14:08 <lambdabot> Prelude undefined :: a
06:14:08 <lambdabot> Data.Array.Base arrEleBottom :: a
06:14:20 <ivanm> sinelaw: looks like a definitional thing
06:14:23 <ivanm> where are you reading that?
06:14:42 <sinelaw> ivanm, in a paper
06:14:48 <soupdragon> sinelaw, it doesn't say anything interesting. Is there a purpose you want to read it for?
06:14:50 <sinelaw> http://haskell.cs.yale.edu/yale/papers/icfp01/rt-frp.pdf
06:14:55 <dschoepe> ivanm: My problem is that I have a ReaderT Something IO, and monadic code where I often have to do normal IO. So for each time I have to call liftIO to get that action into my ReaderT
06:14:56 <mmorrow> ivanm: tagsoup!
06:14:58 <ivanm> sinelaw: then they must be defining something there
06:15:03 <sinelaw> section 2.2
06:15:08 <sinelaw> they are defining a syntax
06:15:11 <Saizan_> sinelaw: are you familiar with BNF grammars?
06:15:18 <sinelaw> i have no idea how to read that
06:15:23 <Saizan_> ok
06:15:25 <sinelaw> Saizan_, a little
06:15:31 <sinelaw> not too much i guess :)
06:15:45 <ivanm> mmorrow: so it's not good enough that you're making me procrastinate by learning prettyprint and writing a code generator, but you want me to now investigate tagsoup as well (and then presumably have to do some kind of parsing)?
06:15:46 <ivanm> ;-)
06:15:59 <mmorrow> ivanm: it's really easy
06:16:08 <soupdragon> sinelaw missed my message or just ignoring me because I'm an idiot?
06:16:18 <ivanm> soupdragon: both :p
06:16:37 <sinelaw> soupdragon, i missed you message because i'm ignore it because i'm an idiot
06:16:42 <sinelaw> *your
06:16:47 <sinelaw> *ignoring
06:16:49 <sinelaw> :(
06:16:58 <soupdragon> ok:)
06:17:07 <sinelaw> soupdragon, i'm trying to understand that paper
06:17:14 <quicksilver> dschoepe: that's how it works, yes.
06:17:17 <sinelaw> and i won't be able to read the examples, if i don't know the syntax
06:17:29 <soupdragon> you can just ignore that then
06:17:31 <soupdragon> No
06:17:31 <quicksilver> dschoepe: although you can define pre-liftIO'ed versions of your most common primitives
06:17:47 <quicksilver> dschoepe: myPutStrLn = liftIO . putStrLn, etc.
06:17:52 <soupdragon> That doesn't tell you what the examples mean
06:17:58 <quicksilver> (with the DMR turned off)
06:18:05 <dschoepe> quicksilver: Hmm, I guess I'll have to go with that then. Would be nice if that would be changed some day.
06:18:05 <Saizan_> sinelaw: it's basically the syntax of lambda calculus + pairs
06:18:20 <quicksilver> dschoepe: the way to change it would be to pre-liftIO everything in the standard library
06:18:27 <quicksilver> doesn't work for callbacks though.
06:18:40 <dschoepe> quicksilver: Would there be any problem with that?
06:18:57 <Saizan_> sinelaw: where you use () for the zeroth tuple and (v1,v2) for a pair of v1 and v2
06:19:34 <quicksilver> dschoepe: more confusing error messages, perhaps.
06:19:39 <quicksilver> dschoepe: and the callback problem.
06:19:39 <Saizan_> sinelaw: e stands for expression, v for value, c for constant, _|_ for undefined
06:19:58 <maartenm> I was wondering, since haskell is so well suited for hardware programming
06:20:04 <sinelaw> ah. i love it when they save letters to make science less accesible!
06:20:13 <mmorrow> maartenm: check out Lava
06:20:13 <ivanm> Saizan_: and "?!?" stands for "WTF?" ? :p
06:20:14 <dschoepe> quicksilver: What about lifting only functions with no callbacks?
06:20:29 <maartenm> are there microcontroller compilers for haskell code.. like for the arduino project or anything
06:20:37 <maartenm> mmorrow: groovy
06:20:55 <lpsmith> I hear JHC is used some for embedded work
06:21:06 <ivanm> I know present to you the great mmorrow, who can answer questions before they even appear!
06:21:07 <mmorrow> maartenm: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:hardware
06:21:07 <ivanm> ;-)
06:21:09 <lpsmith> but honestly,  I'm not sure that Haskell is really all that suitable
06:21:19 <Saizan_> sinelaw: heh, though in this case it's a very widespread convention
06:21:43 <ivanm> lpsmith: yeah, manual memory management might actually be a good thing if you're going small enough on the embedded side
06:21:44 <sinelaw> Saizan_, what's v_|_ ? and how is it different than just bottom _|_?
06:21:58 <ivanm> sinelaw: very undefined? :p
06:22:00 <mmorrow> maartenm: the method seems to be to use haskell to describe the code to generate, rather than to translate haskell into some suitable code
06:22:09 <sinelaw> ah, ok it seems they mean Just V and Nothing
06:22:39 <maartenm> hmm, but there are no Haskell machines
06:22:44 <maartenm> they way you have lisp machines?
06:22:50 <mmorrow> @where reduceron2
06:22:51 <lambdabot> I know nothing about reduceron2.
06:22:57 <Saizan_> sinelaw: that's something peculiar to that paper instead, i think
06:23:06 <maartenm> ah, cool
06:23:11 <sinelaw> Saizan_, what does it mean that an expression can be 'x'?
06:23:13 <mmorrow> maartenm: http://www.cs.york.ac.uk/fp/reduceron/
06:23:14 <maartenm> not very popular, or is it?
06:23:24 <Saizan_> sinelaw: a variable
06:23:26 <lpsmith> maartenm:  language-specific language hardware has been pretty much out of vogue since the late 80s, early 90s
06:23:27 <maartenm> oh it's pretty new
06:23:43 <maartenm> lpsmith: yeah for some reason, the older I get, the more interested I become in hardcode
06:23:57 * osfameron wants a Blub machine!
06:24:05 <ivanm> lpsmith: apart from C-specific hardware?
06:24:13 <mmorrow> maartenm: that reduceron is a project to run haskell on an fpga
06:24:17 <ivanm> osfameron: heh... it must be a targetable machine, since Blub is a moving target
06:24:18 <Blub\0> I'm not a machine!
06:24:27 <osfameron> hahahaha
06:24:34 <ivanm> Blub\0: notice the lack of a "\0" on the end of what osfameron said though...
06:24:51 <lpsmith> heh;  existing chips aren't *that* c-specific,  in fact some assembly idioms can't really be expressed in C
06:25:18 <osfameron> if you did /nick 4Blub\0, would you be a "fucked nick" ?
06:25:22 <ivanm> lpsmith: haven't they been getting more C-oriented over time though?
06:25:30 <osfameron> er... \4Blub\0  I guess
06:26:03 <maartenm> I guess GPUs have
06:26:15 <lpsmith> I know somebody who did a scheme machine in hardware, as a FPGA design.   It was slow,  because it was an FPGA,  in part
06:26:45 <mmorrow> you've gotta be massively parallel if you want to crush on an fpga
06:26:47 <soupdragon> you think they should bend over backwards and patronize 99% of readers just so beginners don't have to read a text book
06:27:41 <lpsmith> ivanm:  how has it become more c-specific?   indirect jumps are handled reasonably well these days on intel
06:27:47 <lpsmith> for example
06:27:48 <mmorrow> i wonder if existing languages are so inherently serial that implementing them on an fpga so that it's sufficiently parallel to take advantage of its fpga-ness is impossible
06:28:01 <ivanm> lpsmith: something I've read somewhere once... *shrug*
06:28:07 <lpsmith> mmorrow: I tend to think so
06:28:12 <ivanm> maybe it was just that they were getting more serial/imperative?
06:28:16 <mmorrow> ie you need to come up with a completely new language with a completely new programming paradigm
06:28:26 <sinelaw> RT-FRP!
06:28:28 <soupdragon> It's impossible to win "boo! too much fluff just give me the facts" or "you need a flipping PhD to understand this!!"
06:28:47 <lpsmith> anybody here used bluespec?
06:29:11 <ivanm> you mean the steel? :p
06:29:16 <ivanm> wait, that's bluescope
06:31:58 <sinelaw> I need to choose a senior year project next year
06:32:10 <sinelaw> i mean for next year...and i need to do it in three days.
06:32:20 <Twey> lpsmith: The Reduceron isn't language-specific — it's more functional-specific, the way the x86 is imperative-specific
06:32:43 <sinelaw> so my idea was to propose my own project, something to do with FRP and hardware
06:32:48 <sinelaw> any suggestions?
06:33:26 <soupdragon> do a project on BNF
06:33:55 <soupdragon> senior year of a computing course?
06:34:01 <sinelaw> electrical engineering
06:34:13 <soupdragon> oh
06:34:34 <Baughn> sinelaw: Hardare support for FRP
06:34:37 <soupdragon> well now I can't make fun of you :p
06:34:46 <Baughn> sinelaw: Seriously, it's so hard to get efficient FRP, it cries out for some hardware help
06:35:32 <maartenm> a hardware webserver written in FRP?
06:35:43 <sinelaw> maartenm, don't be evil.
06:35:45 <lpsmith> well,  if you put much into hardware,  you make the hardware less flexible.  For example,  you couldn't make use of most hardware stacks if you use Chez Scheme's model of the stack
06:36:13 <sinelaw> Baughn, that's why i'm reading about RT-FRP
06:36:16 <lpsmith> If you do parts of GC in hardware, that's part of the GC you can't easily modify
06:36:17 <sinelaw> http://haskell.cs.yale.edu/yale/papers/icfp01/rt-frp.pdf
06:36:53 <Baughn> lpsmith: Clearly what we need is cheap automated desktop CPU manufacturing, so we /can/
06:37:57 <maartenm> sinelaw: sorry I thought you said you needed to do it in three years instead of days
06:38:15 <lpsmith> and honestly people have figured out how to implement FP on commodity hardware pretty well,  and commodity hardware has a rather steep price/performance advantage
06:38:39 <sinelaw> lpsmith, who has figured it out, and where can i read about it?
06:38:59 <FunctorSalad> I think he means x86 ;)
06:39:20 <Baughn> lpsmith: See, that's why we need the automated manufacturing. ;)
06:39:20 <binrapt> Is it possible to use inline assembly in Haskell somehow?
06:39:28 <FunctorSalad> and the usual compilers
06:39:34 <Baughn> binrapt: Nope, but you can link to assembler files pretty easily
06:39:50 <sinelaw> oh! You said "FP"
06:39:57 <sinelaw> i'm talking about FRP
06:40:02 <Baughn> binrapt: And the upcoming foreign primops allow what is essentially inline asm
06:40:11 <Baughn> binrapt: ..now, why do you want to?
06:40:20 <FunctorSalad> omg foreign primops? :o
06:40:49 <sinelaw> sounds like something to do with immigration laws
06:40:50 <Baughn> FunctorSalad: The idea is to make things like switching out (or removing) GMP easier
06:41:00 <binrapt> Baughn: I am writing a Diablo II cheat in Haskell and it needs to modify the PEB of the process and such to conceal itself
06:41:21 <Baughn> binrapt: I see no particular reason that would require /inline/ assembly
06:41:27 <maartenm> first tiem I heard of FRP too, but I read the wikipedia article/stub and it sounds like an awesome research field
06:41:34 <binrapt> Baughn well it's more fun that way :/
06:41:55 <Baughn> binrapt: Inline haskell assembly, eg. primops, is not "fun". It requires deep knowledge of GHC internals.
06:41:59 <binrapt> In order to execute functions in ASM files I need a foreign function interface?
06:42:08 <Baughn> binrapt: Use C functions (or assembly pretending to be C) like everyone else
06:42:52 <sinelaw> maartenm that's why i want to do my senior project in that....rather than working on microphone arrays / voice compression etc....
06:43:40 <sinelaw> i think a FRP -> VHDL translator would be cool.
06:44:19 <sinelaw> (as a very short term goal :P )
06:45:08 <lpsmith> that would be pretty cool :-)
06:45:35 <maartenm> a less ambitious project would be some kind of interesting plugin in Yi
06:45:39 <Axman6> binrapt: haskell's not a low level language at all
06:45:41 <lpsmith> I generated VHDL once as part of a hardware project for class
06:45:42 <maartenm> that reacts to the input in an.. FRP way
06:46:28 <maartenm> oh wait, you're an electrical engineer
06:46:31 <lpsmith> sinelaw,  you should take a look at bluespec though.  I wish I had had the opporunity to play with it
06:46:34 <sinelaw> maartenm, i think experience with combining FRP and hardware will give me more
06:46:49 <binrapt> Axman6: So you think I sohuldn't even have the choice to go low when I need to in Haskell? :(
06:47:24 <Axman6> not at all, i'm just saying that assmelby and haskell are extremely far away from each other
06:50:31 <ivanm> mmorrow: what should prove interesting is if I replace the dodgy Show instances with pretty-printing ones... then I'll be using Text.PrettyPrint code to generate Text.PrettyPrint code :s
06:51:03 <sinelaw> lpsmith di you ever use bluespec?
06:53:01 <ivanm> @ask mmorrow do you know if there's a way of automatically having prettyprint escape quotes (or should I just make sure I do that?)
06:53:02 <lambdabot> Consider it noted.
06:53:33 <lpsmith> sinelaw:  unfortunately,  no
06:54:41 <sinelaw> lpsmith do you know someone who did? :)
06:55:33 <bremner> Axman6: Assembly. It starts with ass.
06:56:00 <Axman6> don't be puttin' down the donkeys
06:56:27 <maartenm> :t return
06:56:30 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:57:06 <quicksilver> donkey-abuse is offtopic in this channel!
06:57:38 <lpsmith> no,  but I ran across bluespec a year or two after my hardware course...
06:57:42 <bgs100> > zipWith (\x y ->x:y:[]) [1,2,3] [4,5,6]
06:57:44 <lambdabot>   [[1,4],[2,5],[3,6]]
06:58:18 <soupdragon> > zipWith (curyy (\(x,y)->[x,y])) [1,2,3] [4,5,6]
06:58:20 <lambdabot>   Not in scope: `curyy'
06:58:44 <bgs100> > zipWith (\x y ->[x,y]) [1,2,3] [4,5,6]
06:58:46 <lambdabot>   [[1,4],[2,5],[3,6]]
06:58:46 <soupdragon> > zipWith (curry (squence [fst,snd])) [1,2,3] [4,5,6]
06:58:48 <lambdabot>   Not in scope: `squence'
06:59:11 <Axman6> just isn't your day for spelling is it soupdragon :P
06:59:14 <maartenm> another FRP project: make the bots react to spelling errors
06:59:50 <soupdragon> I've only been using colemak for 3 days and I'm already doing 400 wpm!
07:02:34 <FauxFaux> Colemak.  \o/  Doing it so right.
07:04:21 * quicksilver is quite impressed you can learn a new keyboard layout in 3 days.
07:04:59 <quicksilver> 400 wpm is, of course, rather remarkable.
07:05:18 <ivanm> FauxFaux: it's amazing what having a gun stuck to your head will help you achieve...
07:05:50 <ivanm> bugger, I just realised that my code generation stuff for graphviz attributes has a serious error: it assumes single params for each attribute, whereas some take two :s
07:06:29 <ivanm> oh well, that can be for tomorrow
07:13:40 <sinelaw> ivanm check this out http://www.youtube.com/watch?v=RT87JfTYIvo
07:18:46 <hackagebot> CSPM-Frontend 0.2.8.0 - A CSP-M parser compatible with FDR-2.83 (MarcFontaine)
07:19:32 <ceninan> that's cool :D
07:19:41 <mmorrow> ivanm: i usually use
07:19:41 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:19:44 <ceninan> now if it could handle hypergraphs...
07:19:46 <mmorrow> , (text . show) "asdf"
07:19:48 <lunabot>  "asdf"
07:19:53 <mmorrow> , (text . show) "\"asdf"
07:19:55 <lunabot>  "\"asdf"
07:20:41 <mmorrow> , (text . show . show) "\"asdf"
07:20:42 <lunabot>  "\"\\\"asdf\""
07:22:26 <mmorrow> ivanm: (if you're pprinting non-haskell code though and the escaping conventions are different you have to do it manually though)
07:22:58 <mmorrow> that bit me with switchtrie at first
07:23:02 <mmorrow> with chars
07:23:15 <mmorrow> and unicode
07:23:30 <mmorrow> '\28394' is not a C char!
07:24:03 <mmorrow> err, and also there was another oddity, but i can't remember
07:24:30 <mmorrow> everything was fixed though after i stole that charToC from ghc
07:38:43 <hackagebot> hashed-storage 0.3.5 - Hashed file storage support code. (PetrRockai)
07:39:26 <Axman6> @hackage hashed-storage
07:39:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hashed-storage
07:58:28 <jeffersonheard> Can anyone help me out here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6802#a6802
07:59:19 <conal> @type alloca
07:59:21 <lambdabot> Not in scope: `alloca'
07:59:28 <conal> jeffersonheard: type of alloca ?
07:59:47 <doserj> @type Foreign.alloca
07:59:48 <conal> jeffersonheard: looks like alloca wants a size as first argument.
07:59:49 <lambdabot> forall a b. (Foreign.Storable.Storable a) => (GHC.Ptr.Ptr a -> IO b) -> IO b
07:59:56 <conal> oh, hm.
08:01:03 <jeffersonheard> That's what I thought at first.  but that doesn't seem to be it...
08:02:20 <conal> jeffersonheard: what's that #fun spec at the top?
08:02:24 <jeffersonheard> that's basically the form that's given on Manuel's site for handling out-args, but it doesn't work.  The doc's been spotty in other places as well, so assuming this ever totally works I'm gonig to write this up as a tutorial
08:02:28 <jeffersonheard> conal, that's c2hs
08:02:32 <conal> oh
08:03:04 <doserj> where is getInfo'_ defined?
08:03:19 <jeffersonheard> that's their template language.  I've been looking through the gtk2hs source code for examples, but I can't find a good one
08:03:23 <jeffersonheard> for this case
08:03:49 <hackagebot> darcs-beta 2.2.98.3 - a distributed, interactive, smart revision control system (PetrRockai)
08:03:53 <jeffersonheard> doserj, c2hs defines it as: getInfo'_ :: ((Ptr ()) -> ((Ptr CInt) -> ((Ptr CInt) -> ((Ptr CDouble) -> ((Ptr CDouble) -> (IO ()))))))
08:04:15 <jeffersonheard> doserj as a foreign import ccall safe
08:05:01 * doserj gets lost in parantheses
08:05:57 <jeffersonheard> doserj: it's just fully parentheized notation, I think that would be getInfo'_ :: Ptr () -> Ptr CInt -> Ptr CInt -> Ptr CDouble -> Ptr CDouble -> IO ()
08:06:27 <doserj> seems right.
08:06:28 <jeffersonheard> not sure why c2hs so aggressively parenthesizes, but it seems to work
08:06:56 <jeffersonheard> yeah, it does.  which is why it seems so odd to me that the function in the hpaste doesn't compile with that strange error
08:08:07 <jeffersonheard> the def of allocate4, btw is "allocate4 = allocaArray 4"
08:08:24 <jeffersonheard> the problem with c2hs is that you can't pass args to the marshallers in #fun defs
08:08:35 <jeffersonheard> :t allocaArray
08:08:36 <lambdabot> Not in scope: `allocaArray'
08:08:49 <jeffersonheard> :t Foreign.Marshal.Array.allocaArray
08:08:50 <lambdabot> forall a b. (Foreign.Storable.Storable a) => Int -> (GHC.Ptr.Ptr a -> IO b) -> IO b
08:09:46 <jeffersonheard> tempted to just write that one out by hand, but then "c2hs would have defeated me!"
08:09:54 <doserj> and withIntConv?
08:10:35 <jeffersonheard> :: (Storable b, Integral a, Integral b)  => a -> (Ptr b -> IO c) -> IO c
08:10:42 <jeffersonheard> = with . cIntConv
08:10:51 <doserj> ah!
08:11:01 <dhun> I made my first experiment with concurrency in Haskell using Chan
08:11:06 <jeffersonheard> it's defined in C2HS.hs
08:11:10 <doserj> seems that there is missing an argument
08:11:15 <dhun> I downloaded some webpages from wikipedia concurrently
08:11:24 <vinicius> @type with
08:11:26 <lambdabot> Not in scope: `with'
08:11:27 <jeffersonheard> cIntConv = fromIntegral
08:11:31 <dhun> it seems to work
08:11:52 <dhun> I put the code here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6804#a6804
08:11:53 <jeffersonheard> doserj, where is missing an argument?
08:12:16 <dhun> my question is now, did I do something that might break things later on
08:12:36 <doserj> let { a2'' = withIntConv as'} should probably be sth like let { a2'' = withIntconv n as', for some n (which I do not know...)
08:12:48 <doserj> but that would explain the type error
08:13:00 <Axman6> dhun: i don't understand the question, what do you mean?
08:13:25 * doserj has no clue about Foreign.* stuff, though
08:14:35 <dhun> in other languages I often did things that caused inconsitent states of objects, or semaphor deadlocks
08:16:19 <Axman6> dhun: i've found that's pretty hard when using things like chans
08:17:02 <dhun> so there is nothing I have to special care of for now, and I can just go this way
08:17:53 <Axman6> well, that depends on how you've written the program
08:18:16 <dhun> well it is here it is quite short http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6804#a6804
08:18:55 <jeffersonheard> doserj, that's not it... look @ the definition.  cIntConv takes type a and converts it to type b before marshalling it as a ... oh.  right.  keyword marshalling, not unmarshalling
08:20:16 <dhun> I am just afraid because of my experience with other languages
08:21:03 <dhun> everything worked fine for a while, and then users told me that my programm does very strange things in 5% if the cases, and I never reproduce it
08:21:32 <dhun> then I work on the code a lot, and now it happens in 0.01 % of the cases
08:22:06 <Axman6> oh, you're using STM too
08:22:23 <dhun> and this is why I want to try to make it correct right from the beginning
08:22:30 <Axman6> STM should make things pretty safe
08:22:40 <dhun> I just copied the imports from a wikibook
08:23:00 <dhun> and changed their code to suit my needs
08:23:25 <dhun> the original code is here http://en.wikibooks.org/wiki/Haskell/Concurrency
08:25:24 <Axman6> first thing though, brackets aren't necessary around do blocks
08:26:05 <Axman6> and i think many of your do bocks would be much clearer if you broke them into seperate lines
08:27:13 <dhun> yes I can do that
08:28:55 <doserj> readChannels = mapM (atomically.readTChan), and similar for makechannels
08:29:25 <dhun> ok thanks doserj, that look interesting
08:29:45 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6804#a6806 cleaned it up a bit for you
08:30:25 <doserj> ok, maybe not for makechannels...
08:31:10 <Axman6> dhun: you can avoid the probably unnecessary STM stuff by using Chans instead of TChans btw
08:32:35 <dhun> so if I use chans I can leave out atomic
08:33:05 <Axman6> yes
08:34:22 <dhun> Ok I will modify my code according to these ideas
08:37:06 <paolino> dhun, the code is for downloading some pages concurrently ?
08:37:24 <dhun> yes
08:37:30 <dhun> it seems to work
08:37:55 <dhun> it runs much faster than the non concurrent version
08:39:51 <paolino> and you use Chan for waiting
08:40:15 <dhun> do you know something better
08:40:39 <paolino> no
08:40:57 <paolino> well
08:41:15 <paolino> probably an MVar is enough
08:42:12 <dhun> would it be much more beautiful using MVar?
08:42:23 <paolino> not really
08:42:48 <Axman6> Chans are just linked MVars
08:42:54 <dhun> somehow I do expect to be able to do it more beautifully, doing something with lazyness
08:43:39 <dhun> I got a list of urls, and I want a list of the bodies of the returned requests
08:44:12 <paolino> I think a TChan should be enough
08:44:19 <SamB_XP> are a lot of them on the same server ?
08:44:29 <paolino> one TChan
08:44:48 <damkor> hi
08:44:51 <dhun> I don't thing one in enough
08:44:55 <EvilTerran> lo
08:45:42 <dhun> threads can finish a diffenrent times, and especially in a different order than creation order
08:46:01 <paolino> a TVar [(URL,Body)] should do also
08:46:12 <damkor> I'm using gtk2hs, and I'm trying to attach a menuToolButton to an exiting toolbar, but I cannot get the menu to show up when I click on the little arrow in the button.
08:46:18 * EvilTerran was about to suggest some kind of chan (URL, Body)
08:46:28 <Axman6> this really does not seem like a problem that needs STM at all, and would just it all down
08:46:37 <damkor> does anyone have an example of how to do it? (other menus seem to work fine)
08:46:48 * EvilTerran would probably just use a Control.Concurrent.Chan as a many-to-one channel
08:47:06 <paolino> Axman6: then EvilTerran suggestion is correct
08:47:23 <Axman6> yeah
08:47:38 <dhun> so you mean you fire (URL, BODY) tuples through one channel
08:47:44 <erisco> what is a quick and easy tool to plot points on a graph?
08:47:55 <paolino> dhun, right
08:48:11 <Axman6> just fork off a bunch of threads, all with the same Chan they can put the body in, and fork off another thread that consumes the contents of the chan
08:48:29 <EvilTerran> dhun, i mean, spawn a thread for each URL, and have each thread stick that url and the body of the response in the Chan when it's done
08:48:57 <SamB_XP> preferably, you wouldn't spawn a thread for each URL
08:48:58 <dhun> you can do it like this, and there is nothing wrong with it
08:49:05 <SamB_XP> you would spawn one or two per server
08:49:08 <dsouza> erisco: gnuplot - http://www.gnuplot.info/ is an option
08:49:11 <EvilTerran> alternatively, use a fixed number of worker threads, and have a (Chan URL) to act as a bag-of-tasks
08:49:38 <SamB_XP> and have them use HTTP pipelining to reduce the number of round trips needed
08:49:39 <dsouza> erisco: do you need one with haskell bindings?
08:49:41 <EvilTerran> or, if you're gonna worry about pipelining etc, you may have to get fancy as per SamB_XP's suggestions
08:49:47 <erisco> dsouza, do you know for sure if it does just points?
08:50:05 <erisco> dsouza, I just need to visually represent points easily to debug my program
08:50:06 <EvilTerran> erisco, i've played with gnuplot, you can do 2d and 3d scatters with it just fine, iirc
08:50:35 <dhun> yes gnuplot is cool
08:50:58 <SamB_XP> of course, sometimes the server doesn't support pipelining, but it's still bad form to be pulling a dozen urls at once from one server ...
08:51:02 <erisco> okay I will give gnuplot a try... not too keen on the command line aspect of it
08:51:32 <dhun> there is a cool gnuplot tutorial here http://t16web.lanl.gov/Kawano/gnuplot/index-e.html
08:51:47 <jmcarthur_work> it has a learning curve, but i think ggobi is really cool
08:52:04 <jmcarthur_work> for analyzing higher-dimensional data
08:52:39 <dsturnbull> easy: http://nubyonrails.com/pages/gruff
08:52:44 <jeffersonheard> erisco: if you're not keen on command line then I suspect the easiest thing is excel or oocalc?
08:53:22 <dhun> SamB_XP I never heard about http pipelining but it seems to be a good idea
08:53:26 <jeffersonheard> dsturnbull: ow.  that colour scheme injures my eyes, but it looks cool
08:53:31 <jmcarthur_work> i used the diagrams package to plot some stuff in haskell before
08:53:32 <erisco> its so much overkill... I need a really simple canvas
08:53:36 <jmcarthur_work> it was pretty nice
08:53:36 <erisco> maybe I will just use GIMP
08:53:43 <erisco> but I need axis
08:53:44 <erisco> numbered
08:53:46 <erisco> and a grid
08:54:22 <EvilTerran> erisco, alternatively, ISTR there's metapost bindings on hackage, so you could use those to generate a postscript file
08:54:27 <dsturnbull> jeffersonheard: haha yeah it's a bit retro web 2.0
08:54:28 <paolino> SamB_XP: it can be difficult to know if you ask from one only server, or there are many behind a name/ip
08:54:37 <EvilTerran> but that's probably fiddlier than generating a script for gnuplot or whatever
08:55:07 <SamB_XP> paolino: well, that counts as the same thing
08:55:23 <SamB_XP> paolino: the trickier issue is if you have one server behind many names
08:55:32 <paolino> eh
08:56:13 <SamB_XP> you don't overload the system just because they happen to have enough load to need load balancing
08:57:40 <dsouza> erisco: I have found this: http://www.xplot.org/ might suffice for your needs (haven't tried it though)
08:58:01 <paolino> ok , then 3 Chans, with 2 tasks: resolution and tagging , and download
08:59:59 <dhun> your comments are correct if you got one server
09:00:22 <dhun> but sometimes you can do many IO Operations with many different sources
09:00:46 <dhun> and then you want all of the to happen concurrently
09:00:57 <SamB_XP> dhun: yeah, that's why I was thinking it would be a good idea to split up the list of requests by server name
09:01:15 <paolino> that's what I call tagging
09:01:26 <SamB_XP> and have one or two threads per server name
09:01:28 <bgs100> What exactly does foldl do?
09:01:31 <dhun> thats right, and I will try to do it this way for this case
09:01:58 <paolino> @src foldl
09:01:58 <lambdabot> foldl f z []     = z
09:01:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:02:07 <SamB_XP> it's easier with just one thread per server name, I expect
09:02:23 <dhun> yes I agree with this
09:02:24 <dsouza> erisco: this xplot.org seems nice and easy :-) [echo -e "signed signed\ndot 1 2\ndot 3 4\ndot 4 5" | xplot.org]
09:03:00 <paolino> bgs100 : it's a simple accumulation on a list
09:03:09 <erisco> thanks, but GIMP is working fine :)
09:03:09 <bgs100> > foldl (+) 0 [1,2,3]
09:03:11 <lambdabot>   6
09:03:15 <dsouza> ha, ok!
09:03:30 <SamB_XP> otherwise you'd need to have a safe structure for the threads for a particular server name to pull requests off of... and some way for them to know when there were no more requests to be pulled off
09:03:50 <dhun> yes something like this
09:04:15 <dhun> I read about a soltuion using an event loop
09:04:20 <SamB_XP> unless, of course, you just wanted to let the garbage collector reap them as deadlocked ;-)
09:04:34 <dhun> http://twistedmatrix.com/projects/core/documentation/howto/defer.html
09:05:04 <paolino> or use tagging and never try to get a resource with the tag busy
09:05:16 <bgs100> paolino, Ok, Thanks. I'm looking at some more examples of it in this tutorial...
09:05:50 <dhun> The idea is that you do your IO request and get something back immediately, but you only get a promise for data to come later, then you go on and do the next request
09:07:14 <paolino> twisted is still alive :)
09:07:33 * jeffersonheard is rather a fan of twisted
09:08:01 <dhun> when the data has arrived you are called back, but you can never ask the promise to be fullfilled yourself
09:08:20 <dhun> I think you could do something similar with the lazyness of haskell
09:09:08 * paolino thinks liking twisted is a premonition to become haskell adept
09:09:08 <SamB_XP> dhun: Twisted is not needed in Haskell -- we just use threads and MVars
09:09:12 <dhun> you could even allow to ask for contents of the promise
09:09:29 <dhun> and block until it is fullfilled
09:09:50 <quicksilver> dhun: that's what an MVar is
09:10:01 <quicksilver> dhun: (you ask fo rhte contents of it and it blocks until it's fulfilled)
09:10:12 <dhun> ok
09:13:05 <quicksilver> to *some* extent, twisted is designed to avoid using threads
09:13:14 <quicksilver> (although I do know that it does also interoperate with threads)
09:13:31 <paolino> but you can't deadlock
09:13:35 <quicksilver> whereas the haskell "idiom" for non-blocking IO is "do the IO in a thread and let it block if it wants to)
09:15:07 <quicksilver> paolino: in twisted, you mean?
09:15:11 <paolino> yes
09:15:13 <quicksilver> right.
09:15:26 <quicksilver> on the other hand there are "disciplines" for using MVars in which you don't deadlock.
09:15:33 <quicksilver> Chans are an example
09:15:37 <paolino> or use STM
09:15:41 <quicksilver> (of a construct built from MVars which doesn't deadlock)
09:16:31 <paolino> programming with deferreds is destroying the logic
09:17:14 <paolino> after a while the logic disappears behind
09:17:54 <[[SK|CIO]]> give cc please
09:18:01 <paolino> with STM programs are still readable
09:18:19 <quicksilver> programming with deferred can be compared to unsafeInterleaveIO, can't it?
09:19:03 <SamB_XP> quicksilver: Chans can deadlock
09:19:26 <quicksilver> SamB_XP: not if you only use what the API should have been ;)
09:19:33 <paolino> never used unsafeInterleaveIO as a programming method :)
09:19:34 <SamB_XP> quicksilver: I don't think it's as readable as unsafeInterleaveIO
09:19:36 <quicksilver> SamB_XP: readChan and writeChan are deadlock free.
09:19:46 <quicksilver> isEmptyChan is broken.
09:20:08 <SamB_XP> :t readChan
09:20:10 <lambdabot> Not in scope: `readChan'
09:20:10 <idnar> what about livelock?
09:20:13 <SamB_XP> @hoogle readChan
09:20:14 <lambdabot> Control.Concurrent.Chan readChan :: Chan a -> IO a
09:20:25 <SamB_XP> quicksilver: how is that deadlock free?
09:20:25 <idnar> (although that should be easily detectable)
09:20:51 <SamB_XP> you can avoid deadlock, sure, but you could just as easily not do so
09:21:04 <SamB_XP> (if you tried)
09:21:16 <idnar> SamB_XP: how would you deadlock?
09:21:43 <SamB_XP> idnar: well, you could never put anything else into the Chan ...
09:22:09 <idnar> SamB_XP: okay, that's the dead part; where's the lock part? :P
09:22:24 <SamB_XP> ... or not until you got something back from another Chan that wouldn't give you anything until you wrote to that one ...
09:23:04 <SamB_XP> also, what's a livelock?
09:23:35 <idnar> livelock isn't actually what I meant
09:23:41 <osfameron> livestock?
09:23:49 * osfameron moos
09:24:17 <quicksilver> SamB_XP: blocking isn't deadlock.
09:24:24 <ozzilee> Can anyone help me grok my xmonad config? I'm reading Xmonad.Doc.Extending, but the gnomeConfig I have is throwing me.
09:24:36 <SamB_XP> quicksilver: if you have two threads blocking on eachother's output, is that deadlock?
09:24:40 <quicksilver> yes.
09:24:49 <SamB_XP> you can do that with Chan
09:24:53 <ozzilee> Currently I have: layoutHook = smartBorders $ layoutHook gnomeConfig
09:24:56 <SamB_XP> just like you can do that with unix pipes
09:25:16 <ozzilee> I'd like to add the combineTwo layout, but I'm not sure how things need to come together.
09:25:20 <quicksilver> SamB_XP: hmm, yes, of course you can.
09:25:38 <SamB_XP> though, granted, you're less likely to get messed up by buffering in the case of Chan
09:25:49 <quicksilver> yes, you avoid that problem.
09:25:57 <quicksilver> I'm not longer sure what point I was trying to make about Chan.
09:26:02 * ozzilee should have asked the xmonad channel first, disregard me. Sorry.
09:26:09 <quicksilver> Possibly just that it's easy to reason about so it's easy to be deadlock-free ;)
09:26:10 <idnar> data lock is what I meant
09:26:15 <dhun> but I think this way of deadlocking works with MVars too
09:26:30 <quicksilver> dhun: oh yes, it's definitely possible to deadlock with MVars ;)
09:26:36 <SamB_XP> quicksilver: maybe that it's a lot easier to avoid deadlock when using it than when using more traditional, lower-level synchronization structures?
09:26:38 <quicksilver> but it's possible to observe disciplines which avoid it.
09:27:12 <SamB_XP> dhun: MVars are what Chans are made of, so yes, of coures it's possible
09:27:40 <dhun> I am not perfectly happy with it
09:28:08 <Twey> Isn't a Chan a an MVar (a, Chan)?
09:28:17 <quicksilver> pretty much, yes
09:28:24 <quicksilver> it's a linked list which is Mvars all the way down
09:28:26 <quicksilver> plus a tail pointer
09:28:27 <Twey> Er, Chan a
09:28:31 <Twey> Yeah
09:28:31 <quicksilver> (which is also an MVar)
09:28:56 <quicksilver> considerably more complicated than the obvious way to implement it
09:29:02 <quicksilver> but it is dup-able
09:29:05 <quicksilver> (which is why they did it)
09:29:11 <dhun> I still like the idea of twisted since you can not deadlock
09:29:39 <quicksilver> dhun: in that case, I offer you STM :)
09:29:41 <SamB_XP> it WOULD be nice if GHC's deadlock detection would be more informative about the deadlock ...
09:29:59 <SamB_XP> quicksilver: how does STM prevent deadlocking?
09:30:09 <idnar> dhun: you can get the asynchronous equivalent of deadlock, though
09:30:22 <SamB_XP> idnar: what's that?
09:30:29 <dhun> idnar you are right
09:30:35 <idnar> SamB_XP: pretty much the same as the Chan "deadlock"
09:30:41 <jmcarthur_work> it doesn't. it's just very rare to deadlock with stm because you have to do rather unnatural things, i'd say
09:30:50 <idnar> SamB_XP: you have two or more asynchronous operations waiting on each other to complete
09:31:01 <quicksilver> SamB_XP: concurrent transactions can't deadlock each other.
09:31:08 <quicksilver> in that interesting sense, it's deadlock free.
09:31:14 <SamB_XP> well, sure
09:31:16 <dhun> well in twisted you can not wait
09:31:27 <quicksilver> multiple STM actions never deadlock
09:31:29 <SamB_XP> dhun: sure you can
09:31:34 <quicksilver> so STM, and STM alone, is deadlock free
09:31:36 <SamB_XP> just not by blocking
09:31:39 <quicksilver> but, you can *use* STM to build IO actions
09:31:42 <quicksilver> which deadlock.
09:31:44 <idnar> dhun: okay, but you might just sit in the event loop with your operations never completing
09:31:47 <dhun> thats what I meant
09:31:55 <idnar> dhun: the main thing is that you don't need locks to protect your data structures
09:31:55 <quicksilver> but they're no longer atomic.
09:32:02 <idnar> because you're not accessing your shared state concurrently
09:32:02 <quicksilver> I don't know a concise way to say this.
09:32:12 <SamB_XP> well, your deadlock threads won't block other threads either, usually
09:32:15 <idnar> in Haskell, this isn't a problem, because almost everything is immutable
09:32:25 <SamB_XP> GHC almost always kills them
09:32:33 <idnar> concurrent read-only access can't cause corruption
09:33:04 <idnar> (or, to put it another way, you have shared data, not shared state)
09:33:21 <dhun> I did not understand that
09:33:23 <SamB_XP> idnar: and if you have anything mutable in concurrent Haskell, you just stick it in an MVar
09:33:46 <SamB_XP> or a Tsomething
09:34:00 <idnar> SamB_XP: sure
09:34:10 <idnar> SamB_XP: but the point is that you're starting off with hardly any shared state
09:34:12 <dhun> so the danger of deadlocks is approximatly as high in twisted as in Haskell using mvars
09:34:16 <Saizan> there's probably a tendence to use message-passing, because of immutability
09:34:17 <jmcarthur_work> If your transactions are nonsensical when applied sequentially, they will be nonsensical when applied concurrently, which can cause deadlocks.
09:34:20 <idnar> SamB_XP: as opposed to in other languages, where your whole program is shared state
09:34:22 <SamB_XP> idnar: yeah, that certainly helps a lot ;-)
09:34:49 <SamB_XP> I guess that makes it easier "to just stick it in an MVar"
09:34:52 <jmcarthur_work> not sure how to define "nonsensical" though
09:35:44 <dhun> if you could defined it you could let the compiler catch it
09:35:48 <SamB_XP> well, define it such that forall a:transaction, sensical a \/ nonsensical a
09:36:07 <SamB_XP> hmm.
09:36:08 <paolino> mh, I don't think I can deadlock with STM
09:36:18 <SamB_XP> actually, transaction is the wrong type there
09:36:37 <dpro> hi
09:36:44 <Saizan> you could have transactions that never complete in the current state
09:36:48 <paolino> just livelocks on long transactions
09:36:49 <SamB_XP> yeah
09:37:03 <jmcarthur_work> paolino, think about how you would implement a lock in stm
09:37:04 <Saizan> (i.e. they always call retry)
09:37:04 <SamB_XP> paolino: you remember "retry"?
09:37:11 <jmcarthur_work> then just use locks to deadlock as normal
09:37:15 <SamB_XP> @hoogle retry
09:37:15 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
09:37:15 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry_ :: Num a => String -> IO a -> IO ()
09:37:15 <lambdabot> Foreign.C.Error throwErrnoIfMinus1RetryMayBlock :: Num a => String -> IO a -> IO b -> IO a
09:37:22 <SamB_XP> :t retry
09:37:23 <lambdabot> Not in scope: `retry'
09:37:29 <SamB_XP> @hoogle STM
09:37:29 <lambdabot> module Control.Concurrent.STM
09:37:30 <lambdabot> module Control.Monad.STM
09:37:30 <lambdabot> package stm
09:37:31 <jmcarthur_work> it's using stm "wrong" to implement locks, though
09:37:45 <SamB_XP> @doc Control.Concurrent.STM
09:37:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM.html
09:38:00 <dhun> well maybe you can do it by mistake
09:38:04 <paolino> STM is not a locking frameworj
09:38:18 <paolino> it's a retrying framework
09:38:30 <SamB_XP> okay, so you could deadretry
09:38:31 <SamB_XP> whatever
09:38:33 <SamB_XP> same diff
09:38:48 <jmcarthur_work> TVar (Maybe a) ... if when you read it you get Nothing you retry, you have the equivalent to an MVar
09:38:53 <dpro> I'm a bit new to this and thought learning haskell might be a great waste of my time, moreover I felt like a makeover so I'm in the process of switching to xmonad and was wondering what would be a painless way to get simple completion working in emacs =
09:38:54 <dpro> ?
09:39:24 <SamB_XP> completion of what?
09:39:29 <jmcarthur_work> assuming that is the entire transaction, i mean
09:39:50 <SamB_XP> dpro: you mean in your Xmonad configuration ?
09:39:54 <conal> has anyone used a file chooser button in gtk2hs?  my onFileActivated callback isn't getting invoked.
09:39:54 <idnar> SamB_XP: that would be livelock :P
09:40:15 <paolino> a deadlock is a very different situation, it's a difficult to imagine and prevent situation which involve more threads
09:40:16 <dpro> SamB: no juet autocomplete <meta> <tab>
09:40:18 <SamB_XP> idnar: but it doesn't retry until one of the read STM thingies changes
09:40:20 <jmcarthur_work> retry locks in the sense that the transaction cannot progress until the retry condition changes
09:40:27 <idnar> SamB_XP: oh, hmm
09:40:35 <SamB_XP> idnar: as an optimization
09:40:49 <SamB_XP> no sense throwing cycles at something that can't change!
09:40:49 <jmcarthur_work> even in semantics, i'd call it a lock
09:41:13 <dpro> SamB: just like ghci does it already for me
09:41:43 <paolino> to potentially lock STM you need 2 very synchronized threads
09:41:56 <paolino> but implementation prevents that
09:42:23 <SamB_XP> paolino: you can easily have an sTM action that will never complete
09:42:31 <dpro> SamB: xmonad was just to force me to stick with it for a while ;)
09:42:33 <jmcarthur_work> atomically . takeTMVar
09:42:40 <paolino> that is a livelock
09:42:47 <jmcarthur_work> enough to be like takeMVar
09:42:56 <jmcarthur_work> how is that livelock?
09:43:20 <SamB_XP> nobody has actually defined livelock adequately for me today
09:43:36 <lilac> start with x = 0, y = 0. STM action 1 checks that x = 1 then sets y to 1. STM action 2 checks that y = 1 then sets x to 1. is that a deadlock?
09:43:37 <paolino> a difficult to happen condition
09:44:03 <paolino> no
09:44:12 <lilac> SamB_XP: livelock is when two or more interacting threads aren't blocked waiting for some kind of lock, but can't make progress nonetheless
09:44:17 <paolino> lilac , it will procede
09:44:34 <SamB_XP> lilac: what does any of this have to do with locks?
09:44:39 <lilac> paolino: both actions will always retry.
09:44:51 <paolino> lilac no
09:44:53 <lilac> SamB_XP: you can view 'x' and 'y' as being IO-level locks implemented with STM
09:44:54 * SamB_XP holds that deadlock and livelock have nothing to do with locks
09:45:14 <SamB_XP> @wn deadlock
09:45:17 <lambdabot> *** "deadlock" wn "WordNet (r) 2.0"
09:45:18 <lambdabot> deadlock
09:45:18 <lambdabot>      n : a situation in which no progress can be made or no
09:45:18 <lambdabot>          advancement is possible; "reached an impasse on the
09:45:18 <lambdabot>          negotiations" [syn: {dead end}, {impasse}, {stalemate}, {standstill}]
09:45:31 * paolino reread lilac pseudocode
09:45:49 <SamB_XP> hmm, and apparantly in english both of those situations are called deadlock
09:45:54 <lilac> paolino: the 'check' i'm referring to is, if x /= 1 then retry
09:46:07 <SamB_XP> so lets stop bothering with the silly deadlock/livelock distinction, okay?
09:46:12 <SamB_XP> it's *not* in the dictionary
09:46:27 <lilac> SamB_XP: i think the folklore difference is that deadlock means the threads aren't using CPU but livelock means they are
09:46:30 <paolino> lilac, that code makes any sense?
09:46:39 <lilac> paolino: it's obviously broken code
09:46:43 <jmcarthur_work> does it matter whether cpu is being used or not?
09:46:45 <Phillemann> Is there a function which starts an external program, captures it's output (and return code?) and then returns to the caller?
09:46:47 <SamB_XP> lilac: oh, okay, well, we can use that
09:46:53 <jmcarthur_work> and what does that make spinlocks?
09:47:11 <lilac> SamB_XP: the trouble is, STM semantically doesn't guarantee that retry doesn't retry if the inputs haven't changed
09:47:13 <Twey> Spinlocks?  We put them over there, next to gridlocks.
09:47:15 <SamB_XP> jmcarthur: spinlocks are something they use in the kernel
09:47:36 <paolino> lilac, why you made 2 threads for that?
09:47:41 <jmcarthur_work> yeah, but if things get hung up is it deadlock or livelock?
09:47:49 <SamB_XP> lilac: well, neither does Haskell guarentee that any no-longer-used storage will be reclaimed
09:47:54 <jmcarthur_work> i think the CPU thing is a poor semantic distinction
09:47:59 <SamB_XP> or that tail calls will not take stack
09:48:05 <SamB_XP> so what?
09:48:42 <lilac> jmcarthur_work: absolutely. that's why i first phrased it in terms of threads being blocked
09:48:42 <paolino> jmcarthur_work: a deadlock is no theorically no cpu usage
09:49:02 <SamB_XP> do these things have to be said ?
09:49:13 <paolino> a livelock is running threads, like in STM
09:49:21 <jmcarthur_work> what's the point of the distinction? how have the same net result
09:49:27 <jmcarthur_work> *you have
09:49:29 <lilac> there is a key difference between deadlocks and livelocks, namely that deadlocks are detectable at runtime, whereas livelocks aren't
09:49:44 <paolino> lilac, right
09:49:59 <SamB_XP> jmcarthur_work: except I think GHC finds it easier to notice deadlocks when all the threads are clearly blocked waiting for something
09:50:12 <paolino> and deadlocks cannot happen in STM
09:50:15 <jmcarthur_work> still semantically the same
09:50:20 <SamB_XP> makes it easier for the garbage collector to prove that the thing is never going to happen
09:50:34 <lilac> and that's not just in practice. it is not in general computable whether a given system is livelocked, i think.
09:50:45 <jmcarthur_work> and this is further blurred by GHC's actually implementation of retry
09:50:49 <jmcarthur_work> *actual
09:50:56 <SamB_XP> lilac: well, first you'd have to define progress ;-)
09:51:58 <lilac> /however/, you can construct systems via STM whose nontermination can be detected (where the set of writers for some vars is a subset of the set of STM computations blocked waiting for those vars to change)
09:52:00 <SamB_XP> paolino: what makes you think deadlocks can't happen in STM?
09:52:10 <lilac> and to me that smells an awful lot like deadlock
09:52:32 <SamB_XP> lilac: what does GHC print when that happens to a set of threads including the main thread?
09:52:49 <bgs100> > foldl (flip (:)) [] "Hello"
09:52:51 <lambdabot>   "olleH"
09:52:55 <lilac> SamB_XP: i have no idea. what do you expect it to do?
09:53:08 <SamB_XP> lilac: print something about deadlock
09:53:20 <lilac> SamB_XP: that's pretty much what i'd hope it did too
09:53:39 <SamB_XP> that's what it does in the MVar equivalent situation
09:54:19 <lilac> SamB_XP: i think you're right -- without a definition of 'deadlock', how can we say whether STM can deadlock?
09:54:21 <paolino> SamB_XP: retrying make it impossible to keep steady conditions for another thread to not complete
09:54:43 * jmcarthur_work sighs and codes up a deadlocker
09:55:01 <bgs100> > let reverse' [] = []; reverse' (x:xs) = reverse' xs ++ x in reverse' "Hello"
09:55:03 <lambdabot>   Couldn't match expected type `[a]'
09:55:15 <SamB_XP> certainly if we go with the English-language definition of deadlock (which subsumes livelock as well as the traditional threads meaning of deadlock), STM can
09:55:21 <paolino> bgs100: xs ++ [x]
09:55:24 <dhun> so I basically came to the conclusion to use MVar , that seems to be the best I can do about it
09:55:26 <bgs100> Oh, whoops
09:55:29 <SamB_XP> paolino: hmm?
09:55:35 <bgs100> > let reverse' [] = []; reverse' (x:xs) = reverse' xs ++ [x] in reverse' "Hello"
09:55:37 <lambdabot>   "olleH"
09:56:01 <SamB_XP> paolino: retry means "I didn't like one of the TVars I read in this transaction; wake me if it might be better next time"
09:56:12 <SamB_XP> (then start the transaction from the beginning)
09:56:19 <FunctorSalad_> apropos nontermination, be careful with QuickCheck's `suchThat` ;)
09:56:35 <paolino> SamB_XP: the deadlock is I wait for something to do something else that you are waiting to do the thing I'm waiting
09:57:04 <SamB_XP> paolino: do I need to break out wordnet again?
09:58:42 <paolino> boh, that definition is not implemented in threads
09:58:54 <dhun> can you time out by the way
09:59:10 <lilac> SamB_XP: you'll find the plain english definition of many words doesn't match the computer science one
09:59:13 <dhun> like block for an MVar, but if not here in 10 seconds do something else
09:59:41 <SamB_XP> lilac: well, what is that?
10:00:09 <SamB_XP> dhun: I think System.Timeout could help you there
10:00:22 <SamB_XP> as long as you aren't dealing with non-allocating loops
10:00:49 <SamB_XP> no problem if you're just waiting for data over the net ;-)
10:00:51 <jmcarthur_work> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6809#a6809
10:01:22 <jmcarthur_work> is there some stricter criteria for a deadlock than that?
10:02:14 <lilac> SamB_XP: wikipedia says the difference between deadlock and livelock is that in livelock the state of the actors can change, whereas in deadlock the state is stable and unchanging
10:02:24 * paolino never used a TMVar before
10:02:38 <jmcarthur_work> paolino, newtype TMVar a = TMVar (TVar (Maybe a))
10:02:53 <SamB_XP> lilac: well, in that case, retrying STM transactions count regardless of the implementation of retry
10:03:07 <SamB_XP> as long as they'll never actually succeed
10:03:07 <lilac> SamB_XP: as livelock or deadlock?
10:03:15 <SamB_XP> lilac: as deadlock
10:03:29 <SamB_XP> there is no state change associated with a retry
10:03:39 <SamB_XP> that's the whole point
10:03:41 <lilac> doesn't it depend on whether retry is blocking or not? if retry does an immediate retry then the state of that actor does repeatedly change
10:03:57 <paolino> jmcarthur_work: takeTMVar ?
10:03:58 <SamB_XP> lilac: no, it doesn't, it just spins
10:04:00 <jmcarthur_work> the actor doesn't change state during a transaction though
10:04:22 <jmcarthur_work> paolino, http://www.haskell.org/ghc/dist/current/docs/libraries/stm/src/Control-Concurrent-STM-TMVar.html#takeTMVar
10:04:22 <skyfolly> what is haskell about?
10:04:30 <SamB_XP> at each point in the computation, the state will be the same as before
10:04:43 <lilac> SamB_XP: the state of that thread won't
10:04:45 <SamB_XP> (where "before" means the last time through)
10:04:58 <jmcarthur_work> lilac, the state of the shared variables doesn't change either
10:05:03 <jmcarthur_work> until the transaction is done
10:05:06 <lilac> ok, so what if you insert a third STM thread which /can/ make progress, and can change the control flow of the others
10:05:17 <lilac> jmcarthur_work: the global state is fixed, but the thread-local state changes
10:05:23 <jmcarthur_work> that doesn't sound like dead OR livelock
10:05:35 <jmcarthur_work> lilac, it doesn't semantically
10:05:35 <SamB_XP> lilac: it does not change really
10:05:38 <SamB_XP> it just repeats
10:05:46 <SamB_XP> that's not the same thing as changing
10:06:13 <lilac> jmcarthur_work: depends what semantic model of STM you use
10:06:32 <paolino> jmcarthur_work: I have some problem understanding your idea of dealock
10:06:33 <lilac> jmcarthur_work: one model is that you fork off a computation, then merge it back in if it didn't overlap with the other changes
10:06:53 <lilac> (and otherwise you run it again)
10:06:58 <jmcarthur_work> lilac, that sounds like an implementation
10:07:02 <jmcarthur_work> it shouldn't affect how you use it
10:07:11 <SamB_XP> jmcarthur: it doesn't work here: http://codepad.org/eZKz8rt9
10:07:26 <lilac> jmcarthur_work: sure. all i'm saying is, i don't think it's clear-cut whether STM lockups are livelock or deadlock
10:07:31 <jmcarthur_work> SamB_XP, works on my machine
10:07:49 <jmcarthur_work> lilac, i don't think it makes a difference, so we aren't in strong disagreement
10:08:17 <jmcarthur_work> SamB_XP, perhaps newEmptyTMVarIO is only in newer GHCs
10:08:17 <SamB_XP> jmcarthur: well ... as you can see, codepad isn't able to find newEmptyTMVarIO
10:08:27 <lilac> i'd say they're livelock since lack of progress on the locked threads doesn't imply that the locked threads will follow some fixed pattern
10:08:43 <lilac> (since a third party can affect the flow in the blocked threads without actually unblocking them)
10:09:28 <jmcarthur_work> that still seems to be a rather useless operational distinction
10:10:10 <paolino> jmcarthur_work: what happens there that is a deadlock ?
10:10:27 <Phillemann> @hoogle forkProcess
10:10:27 <jmcarthur_work> paolino, "Main: thread blocked indefinitely"
10:10:28 <lambdabot> No results found
10:10:33 <paolino> both threads lock ?
10:10:38 <lilac> jmcarthur_work: it's not useless. it's the distinction between detectable locks and undetectable locks
10:11:00 <jmcarthur_work> lilac, GHC just detected my deadlock
10:11:18 <paolino> I don't think they both lock. Is it ?
10:11:40 <jmcarthur_work> paolino, both threads attempt to take from an empty TMVar and block
10:11:49 <dhun> SamB_XP do Network.HTTP support pipelining?
10:12:06 <SamB_XP> dhun: hmm, I *think* it does
10:12:16 <SamB_XP> dhun: doesn't it say in the haddocks ?
10:12:25 <lilac> jmcarthur_work: operationally, until you add in the third party, it is a deadlock. add in the extra one and it becomes a livelock
10:13:10 <lilac> i'm not sure you can formulate the difference without reference to the implementation
10:13:20 <paolino> jmcarthur_work: sorry if I ask again, I don't have a compiler here. Both threads lock there ?
10:13:24 <joachifm> identify urgm4tuS.
10:13:44 <lilac> someone needs to change their NickServ password
10:14:17 <jmcarthur_work> paolino, yes
10:14:28 <jmcarthur_work> well, they both attempt to take a lock
10:15:32 <paolino> uhm, I cannot believe they both lock, sorry, I find no reason
10:15:46 * paolino looks for a compiler
10:16:53 <jmcarthur_work> paolino, what do you think each thread does, then?
10:17:08 <jmcarthur_work> neither of them create any progress
10:17:16 <jmcarthur_work> both of them are waiting for something to appear in the TMVar
10:17:41 <paolino> isn't Just () in the TVar ?
10:17:45 <jmcarthur_work> no
10:17:47 <jmcarthur_work> Nothing is
10:17:47 <paolino> at the beginning ?
10:18:03 <jmcarthur_work> newEmptyTMVarIO
10:18:19 <paolino> ah, so why you put 2 threads there ?
10:18:22 <jmcarthur_work> newTMVarIO (Just ()) would have create one with Just ()
10:18:58 <paolino> they are not locking each other
10:19:24 <paolino> then it's not a deadlock
10:19:32 <jmcarthur_work> *sigh*
10:19:38 <jmcarthur_work> okay, i will make one lock the other
10:19:50 <jmcarthur_work> what *is* is then, may i ask?
10:20:14 <paolino> a deadlock is a time related logic bug involving more then one thread
10:20:34 <jmcarthur_work> where did "time related" come from?
10:20:41 <jmcarthur_work> why must it be time related?
10:20:41 * quicksilver disagrees with that definition.
10:20:43 <paolino> concurrency
10:20:50 <quicksilver> a deadlock is where two threads cannot (ever) make progress
10:20:51 <jmcarthur_work> i strongly disagree with that
10:20:54 <quicksilver> because one is waiting for the other
10:20:57 <quicksilver> and vice versa
10:21:09 <quicksilver> (or, actually, more than two, but that's the simplest to explain)
10:21:55 <paolino> quicksilver definition is ok for me
10:22:01 <quicksilver> there is room for debate about what "not ever make progress" means
10:22:09 <Saizan> a deadlock is a cycle in the -wait-for- directed graph :P
10:22:11 <quicksilver> e.g. is "going around in small circles" a kind of not making progress.
10:22:19 <quicksilver> that depends on your level of abstract
10:22:25 <roconnor> if your code isn't reenterent, you can even deadlock with one thread. :D
10:22:40 <jmcarthur_work> paolino, there, they both wait for the other http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6809#a6810
10:22:45 <quicksilver> "going around in small circles" make look like "blocked" if you abstract away for a bit.
10:22:53 <quicksilver> and that is, I think, what some people mean by 'livelock'
10:23:06 <quicksilver> when both threads are obviously "doing something", but they still don't "make progress".
10:23:11 <bgs100> > zipWith ((:[]) . (:)) [1,2,3] [4,5,6]
10:23:13 <lambdabot>   Couldn't match expected type `b -> c'
10:23:37 <paolino> jmcarthur_work: cheating for me, sorry
10:23:52 <paolino> they are not waiting each other
10:23:58 <jmcarthur_work> paolino, even better, here's one where each thread only has one transaction http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6809#a6811
10:24:05 <Phillemann> @hoogle executeFile
10:24:06 <lambdabot> No results found
10:24:09 <Phillemann> Hm.
10:24:09 <jmcarthur_work> paolino, what are they doing then?
10:24:12 <paolino> they are waiting for the impossible
10:24:22 <jmcarthur_work> paolino, sounds like deadlock to me
10:24:56 <paolino> it's not in the STM domain
10:25:08 <jmcarthur_work> paolino, neither is concurrency if you are going to go that far
10:25:14 <jmcarthur_work> where is STM's forkIO?
10:25:55 <roconnor> @free length
10:25:57 <lambdabot> length = length . $map f
10:26:23 <bgs100> > zipWith ((.(:[])) . (:)) [1,2,3] [4,5,6]
10:26:25 <lambdabot>   [[1,4],[2,5],[3,6]]
10:27:52 <paolino> jmcarthur_work: STM resolves some time related bugs, it's not making the impossible happen
10:28:07 <EvilTerran> > zipWith ((++)`on`return) [1,2,3] [4,5,6]
10:28:09 <lambdabot>   [[1,4],[2,5],[3,6]]
10:28:17 <paolino> your code will never run
10:28:25 <EvilTerran> > transpose [[1,2,3], [4,5,6]]
10:28:27 <lambdabot>   [[1,4],[2,5],[3,6]]
10:28:50 <jmcarthur_work> paolino, and that's why we have deadlock
10:29:02 <paolino> you have to write code that sometimes deadlock
10:29:40 <jmcarthur_work> paolino, but you CAN write code that deadlocks
10:29:47 <jmcarthur_work> paolino, STM gives you that ability
10:29:51 <jmcarthur_work> therefore, it can deadlock
10:30:19 <malosh> Hi. What is the haskell equivalent of ocaml's graphics library, i.e. a small cross-platform window that lets you do quick drawings in a simple way (i.e. with lines and points) ?
10:30:26 <jmcarthur_work> paolino, does your definition of deadlock mandate that it be hard to track down or something? i find this conversation a little odd
10:30:37 <paolino> jmcarthur if it always deadlock, it's not time related, it's logically broken
10:30:42 <SamB_XP> jmcarthur: he must be a C programmer
10:30:57 * roconnor wants to know the answer to malosh's question too
10:31:06 <jmcarthur_work> paolino, if you write crap you will get crap. stm doesn't prevent that
10:31:10 <Phillemann> What was the syntax again to export a type, but without any type constructor?
10:31:25 <Plouj-> can someone comment on my dilemma: http://plouj.com/choosing-programming-language-and-opengl-binding
10:31:26 <SamB_XP> Phillemann: you mean data constructor?
10:31:32 <Phillemann> SamB_XP: Ah yes.
10:31:34 <SamB_XP> Phillemann: T()
10:31:39 <Phillemann> Ok, thanks.
10:31:51 <SamB_XP> it's kind of hard to use a type without the type constructor ;-)
10:32:10 <jmcarthur_work> Plouj-, if you want a C-like OpenGL binding for Haskell, use the raw opengl binding (it's on hackage somewhere)
10:32:12 <jeffersonheard> malosh, you might *try* Hieroglyph...  I haven't ever really tried to make it work with GHCI, so I don't know if it will or not.
10:32:47 <jmcarthur_work> Plouj-, i don't think haskell is so hard to debug, nor is the opengl binding so immature, in my experiences
10:32:47 <malosh> jeffersonheard : you mean that would do it with ghc (not i) ?
10:33:36 <jmcarthur_work> Plouj-, the opengl is a rather direct translation from the C headers
10:33:43 <Plouj-> jmcarthur_work: well, what about the problem this guy was having: http://fhtr.blogspot.com/2009/07/tomtegebra-small-haskell-puzzle-game.html ?
10:33:56 <Plouj-> "mysterious run-time crash bugs"
10:34:04 <Plouj-> "Debugging by randomly changing things did conquer in the end"
10:34:06 <SamB_XP> jmcarthur_work: isn't that the problem ?
10:34:18 <Plouj-> and he sounds like he knows Haskell more than me
10:34:24 <Plouj-> so, what chance do I have?
10:34:31 <jmcarthur_work> SamB_XP, yes, but Plouj- wants it to be like the C api, so i'm telling him it is ;)
10:34:33 <SamB_XP> Plouj-: well ... do you know C?
10:34:47 <SamB_XP> jmcarthur_work: what is wrong with him?
10:34:50 <jmcarthur_work> Plouj-, i have written games in haskell without these problems
10:34:51 <bgs100> > ((.(:[])) . (:)) 1 2
10:34:53 <lambdabot>   [1,2]
10:34:56 <SamB_XP> jmcarthur_work: has he used OpenGL before?
10:34:59 <bgs100> How does that work?
10:35:03 <SamB_XP> and *enjoyed* it?
10:35:29 <EvilTerran> bgs100, you can stepwise evaluate it by hand, that's quite illustrative
10:35:43 <Plouj-> SamB_XP: I'm just learning OpenGL
10:35:50 <SamB_XP> Plouj-: ah.
10:36:02 <SamB_XP> I'm not sure you want the Haskell API to be like the C one
10:36:11 <SamB_XP> though I guess, to call it OpenGL, it probably should be
10:36:19 <jmcarthur_work> opengl sucks any way you look at it
10:36:27 <Plouj-> that's a problem, because, if I run into problems (which is inevitable), I won't have many people to ask for help
10:36:52 <bgs100> EvilTerran, Well, doesn't it send it through (:) first? But if I do 1:2 (or (:) 1 2), I get an error because 2 isn't a list
10:36:57 <jmcarthur_work> Plouj-, if the goal is to learn opengl, use c. if the goal is to make a game, use whatever language you wish
10:37:08 <SamB_XP> Plouj-: yeah, it is rather inevitable
10:37:12 <SamB_XP> with OpenGL, anyway
10:37:15 <SamB_XP> so much state!
10:37:33 <SamB_XP> (and I haven't even USED OpenGL yet!)
10:37:41 <jmcarthur_work> and all that state just to internally generate what is essentially a functional program anyway!
10:37:47 <jmcarthur_work> i have used opengl
10:37:59 <jmcarthur_work> not a great api
10:38:01 <jmcarthur_work> :P
10:38:15 <Plouj-> it's the only one for 3D
10:38:22 <Plouj-> (non-proprietary)
10:38:22 <jmcarthur_work> there are higher level apis, too
10:38:29 <SamB_XP> jmcarthur: it hasn't always been essentially a functional program that was to be generated
10:38:31 <Plouj-> heh
10:38:35 <malosh> Plouj- : try with OCaml. If you don't program a lot, then you don't want monads in your opengl code
10:38:37 <Plouj-> jmcarthur_work: none that are usable in Haskell
10:38:38 <jmcarthur_work> Plouj-, that's not true!
10:38:55 <jmcarthur_work> either statement :P
10:38:56 <SamB_XP> there used to be a lot of fairly fixed-function hardware to go with the fixed-function GL APIs ...
10:38:56 <Plouj-> jmcarthur_work: give me a good example :)
10:39:01 <malosh> Plouj- : http://ocamlsdl.sourceforge.net/home.html
10:39:02 <jmcarthur_work> in haskell?
10:39:22 <jmcarthur_work> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphics
10:39:28 <jmcarthur_work> a few decent choices in there
10:39:47 <Plouj-> jmcarthur_work: yeah. I found that since most 3D engines are written in C++, they are not usable in Haskell
10:39:47 <jeffersonheard> malosh, I've tried to make Hieroglyph pretty simple for creating graphics, but the procedure would be code-compile-test, not a REPL, that's all I'm saying
10:40:01 <Plouj-> malosh: heh, it's an "attempt", and SDL is only a small piece of the puzzle
10:40:01 <jmcarthur_work> if you want an *engine* you won't find one, i guess
10:40:05 <jeffersonheard> malosh: if you're interested I can send you the paper that is a tutorial on it.
10:40:22 <jmcarthur_work> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game
10:40:34 <jeffersonheard> Plouj: oh, and Hieroglyph is 2d, not 3d..  I've not written a 3d version yet
10:40:41 <EvilTerran> bgs100, as in:  ((.(:[])) . (:)) 1 2  -->  (.(:[])) ((:) 1) 2  -->  (.(:[])) (1:) 2  -->  ((1:) . (:[])) 2  -->  (1:) ((:[]) 2)  -->  (1:) [2]  -->  [1,2]
10:41:01 <jmcarthur_work> there's also fieldtrip, which i haven't used yet, but i know the author wouldn't make it crap
10:41:01 <dons> you know, there were precisely 4 updates to the ocaml hump package repo in the last month, while there were 403 updates on Hackage.
10:41:06 <malosh> jeffersonheard : perfect, I only need 2d.
10:41:25 <jeffersonheard> malosh: email addy?  I'll send you the tutorial paper.
10:42:20 <jmcarthur_work> anyway, i think low level opengl is slightly *nicer* in haskell than in most other languages
10:42:27 <jeffersonheard> dons: that was always my problem with OCaml.  It just didn't update fast enough.  That and the global lock on the runtime making parallelism via threads impossible
10:43:40 * SamB_XP is for some reason using his launchpad openid to comment on a webcomic ...
10:43:42 <bgs100> EvilTerran, :O Thanks!
10:43:43 * bgs100 was doing it wrong
10:43:46 <bgs100> :P
10:44:40 * SamB_XP thinks it's probably because it's the only openid provider he can remember both the name of and his account name on
10:45:07 <SamB_XP> (and that it is an openid provider)
10:45:36 <jeffersonheard> malosh: sent.  Also check out my blog for a couple more examples: http://vis.renci.org/jeff
10:45:43 <malosh> thanks
10:46:42 <erisco> is there a function to swap the order of a pair?
10:47:06 <erisco> basically, minimum is the function I want except that it weights the first item more than the second item, I need it the other way around
10:48:15 <Petrosian> > snd &&& fst $ (1, 'a')
10:48:17 <lambdabot>   ('a',1)
10:48:23 <Petrosian> erisco: Like that?
10:48:39 <erisco> yeah, thanks Petrosian
10:48:49 <doserj> > uncurry flip (,) $ (1, 'a')
10:48:51 <lambdabot>   Couldn't match expected type `(a -> b -> c, b)'
10:49:02 <doserj> > uncurry (flip (,)) $ (1, 'a')
10:49:04 <lambdabot>   ('a',1)
10:49:15 <erisco> which is best?
10:49:18 <erisco> I want it to be lazy
10:49:30 <Petrosian> Probably doserj's solution
10:49:36 <Petrosian> Doesn't require Control.Arrow at least
10:50:16 <Nafai> Or you could do this:
10:50:27 <Nafai> swap (x,y) = (y,x)
10:50:28 <Nafai> Right?
10:50:37 <jmcarthur_work> not lazy
10:50:50 <jmcarthur_work> not bad, otherwise
10:51:04 <doserj> \~(a,b)->(b,a)
10:51:10 <erisco> its just that, if I am putting it through minimum, I want it to only switch when it needs it
10:51:15 <erisco> rather than make an entire copy
10:51:19 * Nafai nods
10:51:23 <Nafai> Makes sense
10:51:45 <jeffersonheard> You could just rewrite minimum to bias towards the last minimum value
10:51:54 <erisco> @src minimum
10:51:54 <lambdabot> minimum [] = undefined
10:51:55 <lambdabot> minimum xs = foldl1 min xs
10:52:12 <erisco> @src min
10:52:12 <lambdabot> min x y = if x <= y then x else y
10:52:29 <Petrosian> @ty minimumBy
10:52:31 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
10:52:52 <Petrosian> Or use minimumBy
10:53:06 <bgs100> head [ (b, a) | (a, b) <- [(1, 'a')]] -- handles lists of tuples
10:53:10 <bgs100> er
10:53:15 <erisco> how do I call minimumBy? I will look it up
10:53:15 <bgs100> remove "head" :P
10:53:20 <jeffersonheard> so rewrite min to be something like: minbias x y = if x == y then y else (if x <=y then x else y), and then minimumbiased = foldl1' minbias xs
10:53:42 <Petrosian> erisco: The same as minimum, except you also pass it a function that determines the ordering
10:53:57 <jeffersonheard> Petrosian's solution is probably more sensible
10:54:25 <erisco> @src minimumBy
10:54:25 <lambdabot> Source not found. I feel much better now.
10:54:47 <Petrosian> > minimumBy (\(a,b) (c, d) -> compare (b,a) (d,c)) [(1,2), (3,4)]
10:54:48 <lambdabot>   (1,2)
10:55:03 <erisco> that is a bad example
10:55:11 <erisco> > minimumBy (\(a,b) (c, d) -> compare (b,a) (d,c)) [(1,2), (3,1)]
10:55:12 <lambdabot>   (3,1)
10:55:23 <erisco> that is a better example :D
10:55:41 <shepheb> how does one configure \bot regarding networks to connect to and so on? I've got a private one build and want to have it join a channel on another network.
10:57:00 <jeffersonheard> ohhh, I don't know why, but I thought you wanted the last minimum value in a list, not the min based on two sort keys.
10:57:16 <bgs100> > (\(a, b) -> (b, a)) ('a', 1)
10:57:17 <lambdabot>   (1,'a')
10:57:18 <erisco> Petrosian, I do not know what the backslash or little arrow does, but, I guess I will leave that to the rest of the real world haskell book to explain :P
10:57:37 <Petrosian> erisco: Basically just a lambda expression
10:57:42 <Petrosian> Pretty sure RWH covers them
10:57:57 <Petrosian> It's nothing particularly difficult or new
10:57:58 <dschoepe> @pl \f x y -> g (f x y)
10:57:59 <lambdabot> ((g .) .)
10:58:44 <byorgey> erisco: it's an anonymous function.
10:58:49 <byorgey> > (\x -> x + 3)  5
10:58:51 <lambdabot>   8
10:59:07 <Petrosian> erisco: `\x -> y' is just an anonymous function taking one parameter `x', returning the value `y'
10:59:08 <byorgey> \x -> x + 3  is a function which takes one argument and adds 3 to it, for example.
10:59:21 <erisco> Petrosian, ah
10:59:40 <Petrosian> In your case, it takes two parameters, pattern matched pairs
11:00:12 <deech> Hi all, I am trying to understand Haskell's MonadError. To test that I have the following network client code: http://hpaste.org/fastcgi/hpaste.fcgi\
11:00:12 <deech> /view?id=6814#a6814. Since this is an ErrorT ... monad , how do I catch the exception thrown by the connectTo function?
11:00:13 <deech> Hi all, I am trying to understand Haskell's MonadError. To test that I have the following network client code: http://hpaste.org/fastcgi/hpaste.fcgi\
11:00:14 <deech> /view?id=6814#a6814. Since this is an ErrorT ... monad , how do I catch the exception thrown by the connectTo function?
11:00:46 <deech> stupid middle click paste, sorry.
11:00:46 <deech>  
11:02:36 <deech> here's that hpaste address again: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6814#a681
11:10:38 <erisco> I just made a beautiful and lightening fast Graham scan, finally!
11:10:41 <lpsmith> deech:  wrong kind of error handling
11:10:45 <lpsmith> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Acatch
11:10:50 <roconnor> erisco++
11:10:50 <copumpkin> does anyone know if haskell-src-exts is easily extensible?
11:11:41 <erisco> http://pastebin.ca/1490921 the worst looking syntax is the comparison function that has to take into consideration the various circumstances that the cotangent is not defined
11:11:49 <erisco> if anyone can suggest a better way to write it, please let me know
11:12:42 <roconnor> gah
11:12:44 <roconnor> :D
11:13:16 <erisco> roconnor, not as beautiful as I made it sound? =\
11:13:43 <jmcarthur_work> wow
11:13:49 <lpsmith> you could use the | notation instead of nested if-then-else
11:14:07 <erisco> well, considering that there is no "return" statement I needed to nest... and you have to have else's
11:14:19 <erisco> lpsmith, could you pastebin a short example of how the | notation works?
11:16:17 <deech> lpsmith: so I shouldn't be using a MonadError at all? How do I map an exception to my own Errors datatype?
11:16:36 <erisco> jmcarthur_work, isn't she a beaut?
11:17:10 <jmcarthur_work> erisco, if i had more time i would tease it a bit, but i must work
11:17:17 <roconnor> erisco: step1: http://pastebin.ca/1490928
11:17:56 <SimonAdameit> Hi
11:17:58 <erisco> roconnor, ohh, using guards?
11:18:13 <jmcarthur_work> i get the feeling there is some mathematical rational behind this algorithm which would be better expressed directly
11:18:31 <erisco> jmcarthur_work, I am not sure what you mean
11:18:39 <jmcarthur_work> erisco, what's the algorithm here?
11:18:46 <jmcarthur_work> i don't know what this code does
11:18:56 <erisco> roconnor, that is certainly cleaner looking :D I forgot that cot1 and cot2 would not evaluate unless needed too, thanks
11:19:02 <deech> lpsmith: That worked! Thanks!
11:19:04 <SimonAdameit> when wanting to configure llvm bindings on mac, I get an error: Setup:1:0: lexical error (UTF-8 decoding error)
11:19:11 <roconnor> erisco: yes.  Same code really.  I'm still thinking of how to make the algorithm better
11:19:16 <erisco> jmcarthur_work, the Graham scan algorithm computes the convex hull of a set of points
11:19:42 <SimonAdameit> I have ghc etc. installed from macports
11:19:55 <erisco> jmcarthur_work, except since sets are not a natural type in Haskell (afaik) it has to work on a list which does not guarantee unit elements, so it handles duplicate points
11:20:07 <SimonAdameit> any idea, what could be the problem?
11:20:11 <erisco> roconnor, better? its already implemented very well
11:20:15 <jmcarthur_work> erisco, Data.Set?
11:20:31 <erisco> jmcarthur_work, there is not the need
11:20:48 * jmcarthur_work is reading up on the algorithm
11:21:15 <erisco> jmcarthur, identical points are written down as just being on the hull boundary, which is fine
11:22:44 <roconnor> erisco: it seems a bit strange.  Do you have invarients about y1 >= py or any such things?
11:22:46 <erisco> roconnor, I do not see how you would get much more of a direct implementation than that, it does what the algo says verbatim
11:23:06 <jmcarthur_work> i think your implementation is obscure
11:23:25 <SamB_XP> what do you mean "natural data type"?
11:23:25 <erisco> roconnor, that is not needed. all those extra cases are dealing with how to compare undefined cotangents
11:23:30 <jmcarthur_work> if this hasn't been corrected by the end of the day i will have to roll up my sleeve ;)
11:23:35 <jmcarthur_work> *sleeves, even
11:23:37 <SamB_XP> you mean like data Nat = Zero | Succ Nat?
11:23:43 <erisco> SamB_XP, included in prelude I guess, a common data type
11:23:56 <SamB_XP> erisco: not everything common is included in Prelude
11:23:56 <jmcarthur_work> Set is in the standard libs
11:24:22 <erisco> the algo works with lists just as well, its fine
11:24:32 <shepheb> is there a repo of the patches applies to the lambdabot from hackage to get a live one for connecting to an IRC network? all the IRC state is a dummy in this Hackage version.
11:24:37 <SamB_XP> Set is even one of those libraries that's in good enough shape that it could get included in a Haskell standard
11:24:40 <jmcarthur_work> it might work, but it's ugly
11:24:42 <SamB_XP> if we so desired
11:24:54 <roconnor> erisco: but it seems simpler to to just write "compare ((x1-px)*(y2-py)) ((x2-px)*(y1-py))"
11:24:56 <erisco> roconnor, you have an extra backslash in that code you pastebinned... intentional?
11:24:57 <SamB_XP> unlike much of base
11:25:20 <roconnor> erisco: the backslash seems to be an error
11:25:29 <erisco> roconnor, ah, good catch, that is a slight improvement
11:25:45 <roconnor> erisco: what is a slight improvement?
11:25:49 <jmcarthur_work> i'd say even the C-like psuedocode for the algorithm on wikipedia looks nicer
11:25:55 <erisco> roconnor, changing how the compare works
11:26:02 <SamB_XP> shepheb: what do you mean?
11:26:03 <roconnor> I mean writing compCots (x1, y1) (x2, y2) = compare ((x1-px)*(y2-py)) ((x2-px)*(y1-py))
11:26:06 <jmcarthur_work> oh, it leaves things out
11:26:07 <roconnor> period.
11:26:08 <jmcarthur_work> n/m
11:26:09 <SamB_XP> you mean it's all empty?
11:26:13 <SamB_XP> or you mean it won't even load?
11:26:15 <erisco> roconnor, that does not work though
11:26:29 <roconnor> erisco: well it almost works
11:26:30 <roconnor> :)
11:26:30 <erisco> roconnor, it does not consider the cases where the cotangent is not defined
11:26:42 <roconnor> erisco: yes it does
11:27:33 <erisco> roconnor, compare (0/10) (-0.5)
11:27:59 <vyom> (newb alert) I am reading http://book.realworldhaskell.org/read/io.html and I need a clarificaton on the laziness of the hGetContents function. What is happening behind to scenes to actually make the 'laziness' happen. The function signature just returns a string so one would typically assume it would return the entire contents of the file
11:28:01 <erisco> roconnor, it incorrectly returns GT when it should be LT as perpendicular to the x-axis is a smaller angle than over 90 to the x-axis
11:28:04 <shepheb> SamB_XP: well, if you cabal install lambdabot, it's designed to be used on the command line only. reading the code, the IRCRWState is all M.empty and empty lists.
11:28:16 <jmcarthur_work> vyom, it's ugly magic
11:28:18 <erisco> roconnor, so no, it does not
11:28:23 <shepheb> SamB_XP: I want a \bot for a channel on another network, and I'm wondering what changes are necessary
11:28:31 <SamB_XP> @src
11:28:31 <jmcarthur_work> vyom, you could google unsafeInterleaveIO if you want some details :)
11:28:32 <lambdabot> src <id>. Display the implementation of a standard function
11:28:36 <SamB_XP> @version
11:28:37 <lambdabot> lambdabot 4.2.2
11:28:37 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:28:38 <dons> vyom: it returns a suspended computation that yields characters of the string on demand
11:28:41 <erisco> roconnor, and just using compare fails on my test data, so it certainly is wrong
11:28:46 <SamB_XP> shepheb: have you darcs got that?
11:28:53 <shepheb> no
11:28:57 <roconnor> erisco: Oops, I got the order backwards
11:28:58 <SamB_XP> maybe that's a bit closer
11:29:04 * shepheb will check
11:29:05 <SamB_XP> I'm not sure, really
11:29:08 <roconnor> I mean writing compCots (x1, y1) (x2, y2) = compare ((x2-px)*(y1-py)) ((x1-px)*(y2-py))
11:29:47 <erisco> roconnor, I do not see how that helps at all
11:29:49 <SamB_XP> shepheb: if that doesn't help, ask lispy or Cale, I think
11:30:03 <lpsmith> oh the joy of unsafeInterleaveIO
11:30:12 <roconnor> erisco: what parameters to compCots does my function differ?
11:30:19 <shepheb> SamB_XP: thanks.
11:30:26 <SamB_XP> Cale runs lambdabot on lispy's server, iirc, so they should both be able to tell you what's in that file
11:30:35 <erisco> roconnor, give me a second
11:30:39 <roconnor> erisco: (say for px, py both 0 for simplicity?)
11:31:25 <roconnor> erisco: granted I'm worried about negative values for y1 and y2, but I think I can fix that without difficulty.
11:32:17 <vyom> dons: so is it safe to assume at this point that a suspended computation is a language feature that can be exploited by a haskell function to provide laziness, while still maintaining the same type signature
11:32:31 <dons> vyom: yes.
11:32:41 <vyom> dons: thanks
11:32:48 <dons> the evaluation strategy (eager, strict, lazy) is not indicated in the type.
11:33:01 <mmmulani> does haskell have a built-in ormap? (like scheme)
11:33:04 <dons> the ability to suspend computations is a fundamental concept in Haskell.
11:33:13 <dons> mmmulani: what does an ormap do?
11:33:28 <jmcarthur_work> haskore == paul hudak?
11:33:31 <dons> yep
11:33:35 <conal> jmcarthur_work: yeah
11:33:42 <mmmulani> ouu, any is what I want
11:33:49 <haskore> yes
11:34:12 <conal> jmcarthur_work: oh -- sry.   i thought you meant the haskore project.
11:34:15 <dons> that haskore isn't paul hudak.
11:34:35 <jmcarthur_work> ah, that's what i meant to ask
11:35:04 <vyom> dons: ok now I am curious. Where can I read more about the different evaluation strategies (eager, strict, lazy)
11:35:19 <jmcarthur_work> although haskore appears to have claimed it to be true...
11:36:06 <dons> vyom: http://en.wikipedia.org/wiki/Lazy_evaluation ?
11:36:29 <erisco> roconnor, I modified grahamScan to just output the ordered points and this is what happened: http://pastebin.ca/1490952
11:36:38 <jmcarthur_work> does hudak do irc?
11:36:44 <erisco> roconnor, nothing is right
11:36:48 <roconnor> compCots (x1, y1) (x2, y2) = compare ((x2-px)*abs (y1-py)*signum(y2-py)) ((x1-px)*abs (y2-py)*signum(y1-py1))
11:36:48 <vyom> dons: I kinda know what they mean. I meant about how to control functional evaluation in Haskell
11:36:51 <haskore> I'd be surprised if he did :)
11:36:56 <quicksilver> I've never seen him on IRC, but anything's possible ;)
11:37:05 <erisco> roconnor, I will try that one for you
11:37:10 <Saizan> don't link too stronly lazy IO with laziness in general
11:37:14 <quicksilver> hutton does, for example, and he's also a member of the 'haskell authors beginning with Hu' club
11:37:14 <roconnor> erisco: can you try the above?  I think should be identical to yours in all cases.
11:37:15 <jmcarthur_work> just wondering. seeing "haskore" made me think of it
11:37:16 <dons> vyom: oh, via `seq` and Control.Parallel.Strategies
11:37:29 <dons> yes, lazy IO is a somewhat special case.
11:37:32 <haskore> hehe
11:37:50 <roconnor> erisco: ah wait I see
11:37:55 <roconnor> erisco: nevermind, you are right
11:38:03 <roconnor> erisco: it is more complicated due to priorites
11:38:15 <maltem> Calling lazy IO not lazy IO, but interleaved IO, can help make the notional difference.
11:38:23 <erisco> roconnor, if you are interested: http://pastebin.ca/1490955
11:38:25 <dons> that's a good suggestion.
11:38:35 <SamB> maltem: yeah
11:38:44 <SamB> since it actually changes semantics
11:38:51 <jmcarthur_work> my wife recently watched his talk on haskell and the arts, which i think got her a little more interested in our craft (she's an artist)
11:38:57 <maltem> dons, it's not my idea though. Comes from somebody else here
11:39:01 <SamB> not just makes there be more of them like laziness usually does
11:39:03 <erisco> roconnor, in situations where points will never share the same x and y values as point P, the pivotal point for the algo, there is no problem with compare
11:39:15 <quicksilver> maltem: hear hear
11:39:24 <maltem> ah, now I remember :)
11:39:38 <erisco> roconnor, but to be fully correct, the cases where x and y values are shared have to be considered specifically because the cot alone will not distinguish the proper order
11:40:06 <roconnor> erisco: I think this can be done more ellegantly, but it is more difficult than I had figured
11:40:19 <lpsmith> erisco:   may I ask if this is for the latest project euler problem?
11:40:27 <erisco> roconnor, this is another solution but I have not tested it personally http://ox.cx/graham.hs
11:40:34 <erisco> roconnor, and I am not sure how efficient it is
11:40:40 <erisco> lpsmith, nope
11:40:41 <jmcarthur_work> lpsmith, i suspect it's one of the questions in rwh
11:40:47 <lpsmith> ahh
11:40:52 <erisco> jmcarthur_work, guesses correctly
11:41:12 <lpsmith> I've been reading the new PE problems but really haven't worked on them much for the last 6 months
11:41:17 <roconnor> erisco: I think you can at least get rid of the (x1 == px) and (x2 == px) cases
11:41:18 <erisco> roconnor, the fact that he changes the algorithm by introducing distance of points seems bizarre
11:43:05 <erisco> roconnor, good catch again, the compare will handle that one correctly for sure
11:43:06 <roconnor> erisco: because if x1==px then cot1 will be 0 and your if statement is the same as compare cot2 0
11:43:21 <roconnor> (cause we know that the y's are different, so there is no 0/0)
11:43:34 <erisco> roconnor, before I got excited that it was finally working I was going to more closely look at which ones the compare would do correctly
11:43:49 <roconnor> :D
11:44:11 <etpace> > let count c xs = foldl (\acc x -> if c == x then 1 + acc else acc) 0 xs in count 5 [1,2,5,3,5,1,5,6]
11:44:11 <erisco> roconnor, the sort came out identical, so we should be good
11:44:12 <lambdabot>   3
11:44:13 <SimonAdameit> how can I deinstall ghc on mac when I installed it with the standard graphical installer?
11:44:20 <etpace> is there an inbuilt count function?
11:44:42 <roconnor> etpace: length?
11:45:06 <etpace> hmm.. length . filter (\x -> x == c)?
11:45:23 <roconnor> ah
11:45:25 <roconnor> hmm
11:45:28 <SamB> @pl length . filter (\x -> x == c)?
11:45:28 <lambdabot> (line 1, column 31):
11:45:29 <lambdabot> unexpected "?"
11:45:29 <lambdabot> expecting variable, "(", ".", white space, operator or end of input
11:45:29 <lambdabot> ambiguous use of a left associative operator
11:45:38 <SamB> @pl length . filter (\x -> x == c)
11:45:39 <lambdabot> length . filter (c ==)
11:45:41 <roconnor> @hoogle (a -> Bool) -> [a] -> Int
11:45:42 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
11:45:42 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
11:45:42 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:46:02 <quicksilver> SimonAdameit: the graphical installer comes with an uninstall script you can run
11:46:05 <quicksilver> SimonAdameit: IIRC.
11:46:12 <quicksilver> inside the dmg at the top level, is it?
11:46:13 <roconnor> etpace: I think I might write that
11:46:29 <erisco> roconnor, as a formatting thing should I put a empty line between the local functions?
11:46:30 <roconnor> erisco: | y1 == py = LT  -- this seems just wrong. :)
11:46:35 <SimonAdameit> quicksilver: thank you, I found it
11:47:15 <roconnor> erisco: I'd be inclinded to Quickcheck if your function is transitive
11:47:33 <erisco> roconnor, why does that seem wrong?
11:47:46 <etpace> > let unique p xs = if (length $ filter p xs) == 1 then True else False in unique (<3) [1,2,5,4]
11:47:48 <lambdabot>   False
11:47:59 <etpace> is there a way I can declare unique without if?
11:48:15 <roconnor> erisco: I'd expect it to be more like | y == py = compare px p1
11:48:36 <jmcarthur_work> > let unique p xs = (length $ filter p xs) == 1 in unique (<3) [1,2,5,4]
11:48:37 <soupdragon> if b then True else False = b
11:48:38 <lambdabot>   False
11:49:02 <etpace> ah, thanks
11:49:09 <jmcarthur_work> @pl unique p xs = (length $ filter p xs) == 1
11:49:10 <lambdabot> unique = flip flip 1 . (((==) . length) .) . filter
11:49:12 <jmcarthur_work> ick
11:49:47 <soupdragon> (==1) . length . filter p
11:49:53 <jeffwheeler> How does (f .) work?
11:49:54 <soupdragon> (==1) . count p
11:50:03 <soupdragon> one . count p
11:50:04 <jeffwheeler>  @pl suggests it a lot, but I don't understand that
11:50:09 <shahn_> Hi, does anybody know how to set environment vars from haskell in windows?
11:50:29 <soupdragon> jeffwheeler, nobody knows.. :)
11:50:53 <SamB> shahn_: first of all, you realize that ordinarily you can only set environment variables for a given process and/or subprocesses?
11:50:59 <jmcarthur_work> :t ((undefined :: a -> b) . )
11:50:59 <jeffwheeler> soupdragon: haha, I'll wait for Cale to explain it ridiculously extensively, some other time
11:51:01 <lambdabot> forall b b1 a. (a -> b) -> a -> b1
11:51:13 <SamB> though I realize Windows may be a bit different in that respect, like DOS before it
11:51:57 <jmcarthur_work> jeffwheeler, (f .) could be rewritten as fmap f
11:51:58 <shahn_> SamB: no, i didn't. You can only set the vars at the start of some (sub-)process?
11:52:02 <erisco> roconnor, I see what you are saying. up to that point we know that neither p1 or p2 are the point p and that both p1 and p2 do not either have the same x or y value as p
11:52:13 <SamB> shahn_: oh, you can change them in the middle too
11:52:25 <shahn_> yeah, that's what i want.
11:52:34 <jeffwheeler> jmcarthur_work: craziness; I'm going to play with it
11:52:35 <SamB> shahn_: what you can't generally do is set them in the parent process, that's all I'm warning you of ;-)
11:52:35 <roconnor> erisco: I strongly recommend extracting your function to top level, and quickchecking symmetry and transitivity properties.
11:52:39 <erisco> roconnor, so saying that if one of them has the same y value as p and therefore it must be the smallest angle, that does not account for the fact that the other point can in fact form a smaller angle
11:52:51 <erisco> roconnor, how do I do this quickcheck?
11:52:58 <shahn_> SamB: I don't need that.
11:53:09 <SamB> so if you run your program from a terminal, it won't set the shell's env. as long as you expected that ;-)
11:53:27 <shahn_> SamB: No, i didn't. But thx.
11:53:28 <roconnor> erisco: I might start with http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
11:53:34 <SamB> I figured it was a good idea to warn you since you mentioned windows, where that is likely possible
11:53:45 <SamB> anyway, @hogle setEnv
11:53:54 <SamB> @hoogle setEnv
11:53:55 <lambdabot> No results found
11:53:58 <roconnor> erisco: quickcheck is a great testing tool that you should learn.  Now is a perfect opportunity, assuming you have a little bit of time.
11:54:01 <SamB> @hoogle environment
11:54:02 <lambdabot> module System.Environment
11:54:02 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
11:54:02 <lambdabot> System.Process.Internals withCEnvironment :: [(String, String)] -> (Ptr () -> IO a) -> IO a
11:54:24 <maltem> jeffwheeler, ((f.) . g) x y =  (f.) (g x) y =  (f . g x) y = f (g x y)
11:55:14 <roconnor> erisco: people on #haskell can help you with any quickcheck problems.  But your case should be simple.  The only difficult step would be moving the comparison function to the top level in order to test it
11:55:17 <SamB> shahn_: what the ... it looks like you can't set it with System.Environment! http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
11:55:27 <erisco> roconnor, wait wait wait, y1 == py = LT is definitely correct
11:55:37 <maltem> jeffwheeler, that is, it's function composition where the second function is curried over two arguments
11:55:37 <shahn_> SamB: I just found Posix stuff for setting and withArgs
11:55:42 <jmcarthur_work> ((f.) . g)  =  result f . g  =  (result.result) f g
11:55:55 <jeffwheeler> maltem: hmm, funky
11:55:55 <SamB> shahn_: yeah, I was gonna look there next
11:56:10 <roconnor> erisco: i would recommend doing compCots (x1, y1) (x2, y2) = quux (x1-px,y1-py) (x2-px,y2-py) and implementing quux at the top level.
11:56:17 <SamB> it just seems a bit overboard to not have set functions in System.Environment
11:56:37 <SamB> what do they think this is, a Reader Monad?
11:56:50 <roconnor> erisco: it is correct even for cases when x1 < px?
11:56:54 <shahn_> ^^
11:57:10 <erisco> roconnor, I never compare px, just y's
11:58:01 <erisco> roconnor, its y1 == py = LT, asserting that if the point has the same y value then then the line they form is parallel to the x-axis and thus 0 degrees. you cannot get smaller than that
11:58:45 <roconnor> erisco: or it is 180 degrees
11:58:56 <erisco> roconnor, what I do miss is if they are both on the same y value, in which case I need to specify that they are EQ, so I will add that in
11:59:04 <erisco> roconnor, it is impossible for them to be 180 degrees, thankfully
12:00:02 <bgs100> @src intercalate
12:00:03 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
12:00:12 <bgs100> @src intersperse
12:00:13 <lambdabot> intersperse _   []     = []
12:00:13 <lambdabot> intersperse _   [x]    = [x]
12:00:13 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
12:00:44 <roconnor> okay then
12:01:17 <bgs100> What module is intersperse in?
12:01:28 <erisco> roconnor, the first part of the algorithm guarantees that point p is the bottom-most left-most and therefore no points will lie directly to the left of it
12:01:28 <bgs100> @hoogle intersperse
12:01:29 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
12:01:29 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
12:01:29 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
12:01:50 <erisco> roconnor, and none will lie below it too obviously, which is why we can use the cotangent in the first place
12:02:24 <roconnor> erisco: so you do have some guarentee like x1 > px and y1 > py?
12:02:40 <roconnor> >=
12:02:49 <erisco> roconnor, yes, I have the guarantee that they are >=
12:03:01 <roconnor> oooh
12:03:02 <roconnor> well then
12:03:24 <lpsmith> roconner:  ever considered adding CMYK colors to your colour package?
12:03:47 <jmcarthur_work> negative color spaces start a whole new ball game
12:03:54 <erisco> roconnor, thank-you so much in making my comparison function prettier :)
12:04:14 <erisco> roconnor, and spotting that y1 == py && y2 == py = EQ case I was missing
12:05:00 <lpsmith> jmcarthur_work:  I'm not a color guru,  but I do know that automatic RGB -> CMYK conversions sometime don't work that well
12:05:21 <jmcarthur_work> it's not the easiest thing to do correctly
12:05:38 <roconnor> erisco: np.  I'm still troubled that my function didn't work.  But anyhow.
12:06:30 <erisco> roconnor, my ingenious contribution was the last part of the algorithm, which efficiently uses the sorted list to discover the hull
12:06:41 <erisco> roconnor, ingenious for me anyways ;)
12:06:55 <roconnor> :)
12:08:06 <erisco> roconnor, look at the resulting Haskell beauty! http://pastebin.ca/1490997
12:08:30 * jmcarthur_work thinks it could still be nicer
12:08:40 <jmcarthur_work> it doesn't really explain itself very well
12:08:48 <roconnor> erisco: good work.  Now make it half the size :)
12:08:54 <jmcarthur_work> as evidenced by the amount of time it took to get it right
12:08:59 <erisco> roconnor, why does it need to be half the size?
12:09:11 <roconnor> erisco: all haskell code can be halved in size!
12:09:30 <bgs100> @src transpose
12:09:31 <lambdabot> transpose []             = []
12:09:31 <lambdabot> transpose ([]   : xss)   = transpose xss
12:09:31 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
12:09:45 <erisco> jmcarthur_work, well, firstly I am new to Haskell :P should I include comments as to how it works? it works verbatim to the algorithm description
12:10:08 <jmcarthur_work> erisco, i'll give it tackle later ;)
12:10:52 <jmcarthur_work> erisco, comments wouldn't hurt, of course :)
12:10:53 <roconnor> erisco: you can just say where (px, py)  = minimumBy ...
12:11:00 <roconnor> erisco: assuming you don't use p anywhere else
12:11:15 <erisco> roconnor, at one point I did use p, I will check :P
12:11:15 <FunctorSalad_> I'm not sure whether it's applicable here, but generally a PROTIP for writing "compare" instances is to use the Monoid structure
12:11:40 <erisco> roconnor, I made a couple other formatting improvements
12:11:45 <FunctorSalad_> compare (Foo a b c) (Foo a' b' c') = msum [compare a a', compare b b', compare c c']
12:11:46 <lpsmith> roconnor:  all haskell code can be halved in size given a sufficiently obtuse library framework :-P
12:11:54 <roconnor> lpsmith: :)
12:12:24 <jmcarthur_work> yeah, i suspect that the kind of solution i have in mind needs some library support
12:12:24 <FunctorSalad_> err, or mconcat
12:12:28 <FunctorSalad_> keep mixing them up
12:12:35 <FunctorSalad_> @ty msum
12:12:37 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
12:12:39 <FunctorSalad_> @ty mconcat
12:12:40 <lambdabot> forall a. (Monoid a) => [a] -> a
12:13:01 <erisco> roconnor, its getting better: http://pastebin.ca/1491004
12:13:34 <erisco> roconnor, oops, I still have the first where block indented by four
12:13:43 <erisco> roconnor, and the case block
12:13:53 <jmcarthur_work> i just thought of a cool idea
12:14:13 <erisco> there: http://pastebin.ca/1491009
12:14:24 <jmcarthur_work> it would be cool to be able to specify darcs projects in cabal (already suggested), but not only that...
12:14:33 <erisco> I am pretty happy with that. I'll let you guys whittle it down to half the size :P
12:14:39 <FunctorSalad_> jmcarthur_work: you can already
12:14:50 <jmcarthur_work> it would be nice to be able to specify that a project requires particular patches from the darcs project
12:14:50 <FunctorSalad_> the source-repo section
12:14:56 <roconnor> erisco: :)
12:14:57 <jmcarthur_work> FunctorSalad_, i wasn't done ;)
12:15:05 <FunctorSalad_> you mean as deps?
12:15:17 <jmcarthur_work> then instead of being dependent on releases you can just depend on features of those releases
12:15:19 <erisco> roconnor, you have to admit, it is easily the nicest looking solution out of all of the ones posted
12:15:34 <jmcarthur_work> or on patchsets from the repo
12:15:37 <jmcarthur_work> yes, as deps
12:15:41 <roconnor> erisco: True
12:15:44 <jmcarthur_work> i dont' know hwo that could work elegantly
12:15:51 <jmcarthur_work> but it would be awesome at the highest level
12:15:53 <erisco> roconnor, and it is really close to correct, I just need to formally test it, which I will do after getting through more chapters of the book
12:15:53 <roconnor> erisco: but a year from now you will look back and think this is ugly. ;)
12:16:44 <jmcarthur_work> then i could, say, add a type class instance to some package as a darcs patch and specify that some other package depends on that patch. this would be nicer than orphan instances, i think
12:16:47 <jmcarthur_work> and so on
12:16:48 <erisco> roconnor, (out of the ones posted in the book's exercise comments)
12:17:16 <jmcarthur_work> it kind of turns into "packages are in some intangible ether" feeling, though
12:17:44 <roconnor> erisco: oh, do you have a link?
12:21:44 <erisco> roconnor, yes
12:22:05 <bgs100> @src import
12:22:05 <lambdabot> Source not found. You untyped fool!
12:22:19 <erisco> roconnor, http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html at the bottom, ast exercise question, just click on the comments link an they will pop up
12:22:50 <erisco> roconnor, some of them definitely have errors in them, the ones that supposedly work I haven't had the chance to look into
12:24:18 <SamB> amazing
12:24:27 <SamB> arabic doesn't look like utter shit in mozilla
12:24:54 <SamB> compare whatever IRC client you use: أحمد المحمودي
12:25:07 <etpace> nice newline character
12:25:18 <bgs100> Looks good here
12:25:19 <SamB> with http://git.schottelius.org/?p=gpm
12:25:28 <SamB> bgs100: what are you using?
12:25:43 <bgs100> SamB, Right now, XChat
12:25:52 <SamB> bgs100: try selecting it
12:25:53 <erisco> roconnor, http://haskell.pastebin.com/f65fb096 http://ox.cx/graham.hs http://www.refactormycode.com/codes/569-graham-scan all being interesting
12:26:03 <SamB> it always starts to go all crazy on me when I do that
12:26:09 <SamB> x-chat, I mean
12:26:12 <bgs100> Ok, that was weird :P
12:26:34 <bgs100> If you paste it in the text box, everything goes backward
12:26:35 <bgs100> s
12:26:50 <SamB> bgs100: I think it's supposed to do that
12:26:55 <dankna> xchat displays that arabic fine... but yeah, it's a right-to-left language so I wouldn't want to try typing it
12:27:16 <bgs100> SamB, Yeah.
12:27:24 <SamB> well, whenever I partially select arabic text in x-chat it starts to jump around
12:27:45 <Saizan_> nice, i see it reversed from irssi
12:27:56 <Saizan_> (or maybe it's urxvt fault)
12:28:35 <SamB> Saizan: yeah, I see that in urxvt too
12:28:44 <SamB> it's showing the characters in the order they occur
12:28:54 <SamB> I think that's arguably what it should do, as a terminal emulator
12:29:13 <SamB> not sure what it should do when you try to copy/paste them though
12:29:45 <dankna> it's a hard problem
12:29:52 <SamB> indeed
12:29:53 <dankna> well
12:30:32 <dankna> I think probably they're supposed to always be stored in "logical" order
12:30:38 <SamB> figuring out a technically feasible yet not utterly horrible thing to do and getting people to agree on it
12:30:44 <SamB> dankna: stored, yes
12:30:44 <dankna> yes
12:30:46 <dankna> indeed
12:30:48 <SamB> but sent to the terminal?
12:31:01 <dankna> yeah... that's the thing
12:31:13 <dankna> it's really well beyond the scope of what terminals were designed for
12:31:26 <SamB> I guess it's the implementor's choice, really
12:31:30 * dankna nods
12:31:53 <SamB> though it would be best if an agreement could be reached and maybe even ECMA'd
12:32:16 <erisco> roconnor, any of them seem fancier?
12:32:33 <dankna> well
12:32:38 <dankna> we need a new terminal protocol, really
12:32:50 <dankna> one that gets rid of most of the old, no-longer-needed junk
12:32:54 <SamB> dankna: a *totally* new one ?
12:32:58 <dankna> yes, haha
12:33:00 <SamB> which junk is no-longer-needed?
12:33:10 <copumpkin> does anyone know what ended up happening with http://www.haskell.org/haskellwiki/Hac5/Projects#Type_class_aliases ?
12:33:16 <dankna> VT sequences in general are a huge mess of every program supporting different things
12:33:24 <dankna> I realize this may sound like a somewhat bigoted view...
12:33:24 <SamB> true enough
12:33:34 <SamB> so far
12:33:34 <roconnor> erisco: http://www.refactormycode.com/codes/569-graham-scan  seems simple
12:33:46 <roconnor> erisco: I haven't really looked at all the links
12:34:03 <SamB> dankna: was there a bigoted bit about to follow?
12:34:09 <dankna> no, you heard it already
12:34:28 <dankna> I said it first and then apologized for it :)
12:34:34 <SamB> I thought maybe you were about to say something like "screw arabic"
12:34:37 <dankna> no, haha
12:34:43 <dankna> just "screw VT sequences" was it
12:34:44 <SamB> which is kind of how I feel wrt terminals ;-)
12:34:48 <dankna> haha
12:34:56 <dankna> well, there are plenty of important right-to-left languages
12:34:58 <erisco> roconnor, however it is certainly slower and not as direct to the originally simple and nlogn algo. for example, they use trig
12:35:10 <SamB> dankna: yeah
12:35:14 <dankna> Japanese is even harder because it can be written in rows or columns
12:35:45 <SamB> japanese is at the same time not that bad, though, since the japanese seem content to use rows for their terminal protocols
12:35:52 <dankna> that's true, yeah
12:35:57 <roconnor> erisco: ah, atan2
12:36:05 <erisco> roconnor, also, I am not sure how easily it is modified to eliminate or report on points that lie on the boundary. that is supposed to be a trait of the algo
12:36:07 <SamB> which thankfully go from left to right
12:36:11 * dankna nods
12:36:12 <ray> otoh, CJK requires full width characters
12:36:15 <erisco> roconnor, I am making that simple adaption now and making sure it works
12:36:32 <SamB> have japanese rows always gone that way, or did they do that just to make computers happy?
12:36:38 <ray> always
12:36:40 <dankna> they've always gone that way
12:36:45 <SamB> wasn't sure
12:36:50 * dankna nods
12:36:53 <ray> they picked up horizontal writing in general from europeans i think
12:36:57 <SamB> since usually when they write by hand they write vertical
12:37:24 <roconnor> erisco: I guess I have to do my version now :)
12:37:26 <dankna> I think, given that they were behind the original multilingual text support in Emacs, they would have written new terminal programs rather than been forced into left-to-right, haha
12:37:29 <SamB> afaict
12:37:31 <erisco> roconnor, please do
12:37:56 <erisco> roconnor, and since you are experienced with Haskell and know way way more of its abilities, I am sure you will come up with something better
12:38:20 <erisco> roconnor, better looking anyhow ;)
12:38:23 <roconnor> @hoogle extend
12:38:24 <lambdabot> Distribution.Extension ExtendedDefaultRules :: Extension
12:38:24 <lambdabot> Language.Haskell.Extension ExtendedDefaultRules :: Extension
12:38:26 <SamB> the tricky thing about japanese+terminals is how wide each character is, and really they've already tackled that by specifying exactly which characters are 2 cells wide and which are 1 cell wide
12:38:37 <roconnor> erisco: I will use more comonads that everyone else
12:39:21 <dankna> right.
12:40:40 <SamB> which will make me eternally grateful to them for the precisely-aligned punctuation they have granted me
12:43:12 <dankna> indeed so, haha
12:46:22 <erisco> roconnor, more test data and I am getting crashes :P
12:49:06 <erisco> roconnor, I am about to gain a few more lines heheh
12:49:15 <erisco> roconnor, but it is well worth it to achieve the full algorithm
12:49:36 <zakwilson> I'm trying to decide between Haskell and Clojure for a project. I know Clojure better, but Haskell seems like it will make FRP easier and I intend to make fairly heavy use of that.
12:51:14 <Woof> How do I convert a string to an integer
12:51:23 <Berengal> Woof: read
12:51:28 <Woof> Hm
12:51:30 <Woof> > read "45"
12:51:32 <lambdabot>   * Exception: Prelude.read: no parse
12:51:34 <Berengal> > read "123543" :: Integer
12:51:36 <lambdabot>   123543
12:51:38 <Woof> Ahh
12:51:41 <Woof> Ty : D
12:51:48 <Berengal> If defaulting's on, it defaults to ()
12:51:51 <Berengal> > read "()"
12:51:52 <lambdabot>   ()
12:52:06 <jmcarthur_work> worst default ever
12:52:09 <Berengal> If not, it'll complain if it can't deduce the type from the context
12:52:22 <Berengal> jmcarthur_work: agreed. Sucks for quickcheck, among other things
12:52:33 <roconnor> erisco: done mine.  Sadly I didn't use any comonads.  Just a monad.  Now I need to test it
12:52:56 <erisco> roconnor, can you choose to include or exclude boundary points?
12:53:03 <Berengal> ... I was just about to ask about comonads
12:53:05 <jmcarthur_work> i think even Void would make a better default than ()
12:53:26 <maltem> Void should pass most tests :)
12:53:36 <roconnor> erisco: I chose to include them
12:53:43 <roconnor> I could do it the other way if you prefer
12:53:48 <roconnor> 1 char change
12:54:02 <erisco> roconnor, well, I have a toggle on my function
12:54:08 <erisco> just a boolean
12:54:47 <Woof> Ah, I see
12:55:43 <roconnor> erisco: well my code failed spetacularly
12:56:11 <erisco> roconnor, heheh, I know that exact feeling :P
12:57:22 <erisco> roconnor, in my implementation of the buildHull function, it blindly appends the last two or last point to the hull list. this is always fine if boundary points are wanted. if they are not, those last points have to be specially compared
12:57:34 <erisco> roconnor, which leads to a lot of code duplication and I am trying to figure out a better way
13:00:31 <roconnor> :)
13:00:39 <roconnor> was comparing in the wrong order
13:00:42 <roconnor> fixed
13:00:46 <roconnor> now the output seems more reasonable
13:00:58 <roconnor> but I'm not sure if it is right
13:01:21 <roconnor> @hoogle permute
13:01:21 <lambdabot> Text.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
13:01:21 <lambdabot> Text.ParserCombinators.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
13:01:21 <lambdabot> System.Console.GetOpt Permute :: ArgOrder a
13:01:27 <roconnor> @more
13:01:35 <roconnor> @hoogle-more
13:01:36 <lambdabot> Unknown command, try @list
13:01:39 <roconnor> @hoogle++
13:02:36 <bgs100> @help hooge++
13:02:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:02:40 <bgs100> @help hoogle++
13:02:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:03:43 <Cale> jeffwheeler: Hehe, do you understand what (f .) is doing?
13:03:57 <erisco> roconnor, I have some test cases if you want me to try them
13:04:01 <roconnor> ooh ``zip hull (tail (cylce hull))''
13:04:06 <jeffwheeler> Cale: oh, I knew this was coming . . . somewhat, yes
13:04:56 <HugoDaniel> hi
13:05:07 <Cale> jeffwheeler: If you look at it as a one-parameter function, (.) :: (a -> b) -> ((t -> a) -> (t -> b))
13:05:46 <jeffwheeler> Cale: so, when applied to the first function, it creates a function that accepts one more, and evals to another?
13:05:55 <FunctorSalad_> conal defined "range = (.)" or something similar for that reason
13:06:03 <FunctorSalad_> I found that very helpful for understanding
13:06:12 <FunctorSalad_> ("range" analogous to "first" and "second")
13:06:16 <FunctorSalad_> saying what it acts on
13:06:26 <Cale> It takes a function (a -> b) and turns it into a function from functions of type (t -> a) to functions of type (t -> b), yeah
13:06:28 <FunctorSalad_> and "domain = flip (.)"
13:06:56 <conal> i call them 'argument' and 'result'.
13:07:08 <conal> the latter is part of the DeepArrow package.
13:07:08 <FunctorSalad_> ah
13:07:09 <Cale> jeffwheeler: It's a bit like map, but instead of lists, you have functions from type t
13:07:14 <conal> (generalized to deep arrows)
13:07:23 <FunctorSalad_> personally I'd call it "pre" and "post"
13:07:37 <FunctorSalad_> or "precompose"/"postcompse", "preprocess"/"postprocess"
13:07:49 <Cale> jeffwheeler: map takes a function of type (a -> b) and turns it into a function from lists of type [a] to lists of type [b]
13:07:54 <conal> i chose the names & generalization to play nice & general with 'first' and 'second'
13:08:12 <jeffwheeler> Is t in those signatures just another type var, like a and b?
13:08:31 <conal> first.result.second.result.fmap etc
13:08:41 <Cale> jeffwheeler: Sort of, except you probably want to think of it as "more constant" than a and b, but yeah, it's just another type variable
13:08:50 <conal> (though fmap breaks the arrow game)
13:09:50 <jeffwheeler> So, (f .), where f :: (a -> b), is a function (t -> a) -> (t -> b)
13:09:56 <Cale> yeah
13:10:19 <conal> jeffwheeler: yeah.  result (or (.)) promotes functions to work on results
13:10:30 <conal> jeffwheeler: check out semantic editor combinators
13:10:33 <conal> @where SEC
13:10:33 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
13:11:02 <conal> and the DeepArrow generalization used in "tangible functional programming"
13:11:09 <Cale> fmap is a general function which captures both map and (.)
13:11:20 <Cale> > fmap (*10) [1..10]
13:11:22 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
13:11:33 <conal> and result is a generalization in a different direction
13:11:33 <jeffwheeler> SEC looks like something I worked on called Traits, in Python
13:11:38 <jeffwheeler> Er, Eros
13:11:45 <Cale> > fmap (*10) (^2) 5
13:11:46 <erisco> roconnor, yay, my function can now optionally include or exclude boundary points :D
13:11:46 <lambdabot>   250
13:11:53 <erisco> roconnor, and it did not turn out *that* bad
13:12:10 <erisco> roconnor, although I discovered something peculiar that I am having a tough time figuring out
13:12:12 <jeffwheeler> Cale: what do you mean by "captures"?
13:12:39 <jmcarthur_work> erisco, roconnor: are all these implementations being pasted somewhere?
13:12:39 <jeffwheeler> @type ((+5) .) (+1)
13:12:40 <lambdabot> forall a. (Num a) => a -> a
13:12:45 <Cale> jeffwheeler: I mean that it can operate as both map and (.) in the appropriate circumstances
13:12:54 <jeffwheeler> @type (((+5) .) (+1)) 3
13:12:55 <lambdabot> forall a. (Num a) => a
13:12:58 <conal> jeffwheeler: in other words, it generalizes/subsumes both
13:12:59 <erisco> roconnor, as the number of points left runs out, I will eventually be giving only two points to buildHull, and so it must deal with that case specially
13:13:02 <jeffwheeler> > (((+5) .) (+1)) 3
13:13:03 <lambdabot>   9
13:13:11 <jeffwheeler> > ((+5) .) (+1) 3
13:13:12 <lambdabot>   9
13:13:24 <erisco> roconnor, but I am not certain, however, if there will ever be a case where buildHull only gives one point  back to itself
13:13:36 <roconnor> jmcarthur_work: I haven't pasted mine yet
13:13:38 <Vq^> Cale: so... when are they replaced in the prelude? :o)
13:13:41 <erisco> roconnor, I know how that case should be programmed but I don't think it is ever going to occur
13:14:42 <hackagebot> data-ordlist 0.0.1 - Set and bag operations on ordered lists (LeonSmith)
13:14:44 <jeffwheeler> > ((+5) .) (+1) 1 -- That makes a lot of sense, Cale, because the ((+5) .) is (t -> a) -> (t -> b), but in this case, that's all just Num; (+1) is the first value, there, so it's just (t -> b)
13:14:46 <lambdabot>   7
13:14:49 <FunctorSalad_> Vq^: specialised versions are still great for sensible error messages
13:15:15 <bgs100> > group "Hello, there!"
13:15:16 <lambdabot>   ["H","e","ll","o",","," ","t","h","e","r","e","!"]
13:15:29 <malc_> edwardk: http://xkcd.com/114/
13:15:40 <jeffwheeler> Cale: thanks for the explanation
13:16:10 <erisco> Cale was also speaking yesterday, roconnor, about how the cross comparison could be used to effectively determine the cotangent
13:16:29 <Vq^> FunctorSalad_: yeah, but i still long for a more general prelude :/
13:16:33 <erisco> and if it can be used as such, there might be the chance for a much shorter comparison function
13:17:58 <bgs100> > group [ toLower c | c <- "Hello, there!" ]
13:18:00 <lambdabot>   ["h","e","ll","o",","," ","t","h","e","r","e","!"]
13:18:06 <Cale> comparing (cross (px,py-1) (px,py)), where (px,py) is the point with minimum y coordinate :)
13:18:36 <Cale> (and cross takes another parameter :)
13:18:36 <bgs100> > group $ sort [ toLower c | c <- "Hello, there!" ]
13:18:38 <lambdabot>   [" ","!",",","eee","hh","ll","o","r","t"]
13:19:59 <jmcarthur_work> > group . sort . map toLower $ "Hello, there!"
13:20:00 <lambdabot>   [" ","!",",","eee","hh","ll","o","r","t"]
13:21:34 <erisco> roconnor, you messed up my cross compare :P
13:22:16 <erisco> roconnor, "compare ((x2-x1)*(y3-y1)-(y2-y1)*(x3-x1)) 0" is not the same as "compare ((x2-x1)*(y3-y1)) ((y2-y1)*(x3-x1))"
13:22:17 <jeffwheeler> > (group . sort) `fmap` toLower $ "Hello, there!"
13:22:19 <lambdabot>   Couldn't match expected type `[a]'
13:22:34 <jeffwheeler> Wait . . .
13:23:04 <erisco> roconnor, unless I am horribly mistaken, but we can see that with the sample data (0,0) (1,1) (1,2) and (0,0) (1,2) (1,1)
13:23:26 <erisco> roconnor, the compare with 0 causes a change from GT to LT, but the compare between the two parts remains at GT
13:24:17 <erisco> Cale, I believe you are very very correct on the ability to use the cross comparison in place of calculating the cot of their angle
13:25:13 <erisco> Cale, I just did not see it before, but the thing is to use point P as the first argument. then, of course, if there is a right turn the last point makes the smallest angle, while if it turns left the second to last point does
13:25:32 <erisco> Cale, and on a straight line they are of equal angle and thus, well, equal
13:25:37 <erisco> Cale, thank-you
13:25:50 <Cale> erisco: hmm, there are three arguments, yeah?
13:25:59 <erisco> Cale, yes, the first always being point P
13:26:06 <erisco> Cale, the other two being the points you are testing
13:26:20 <Cale> ah, yes, you could do that as well
13:26:26 <erisco> Cale, right now I am doing the calculations perfectly fine with just the two points
13:26:38 <erisco> Cale, but that involves a lot of work because of the cases where the cotangent is not defined
13:26:54 <erisco> Cale, but I can use this same test to determine what I want
13:27:08 <erisco> Cale, by using point P as the first arg
13:27:16 <Cale> and then just test the sign
13:27:19 <Cale> yeah
13:29:36 <roconnor> ah, my idea doesn't work
13:30:41 <erisco> roconnor, I've had several hours of that same fact :P surely you are close though?
13:31:32 <erisco> roconnor, while I had to introduce lines of code to deal with whether I want the boundary points or not, I think I am about to lose that crazy comparison function thanks to Cale's observation I was too stupid to understand yesterday
13:33:06 <jeffwheeler> @type first
13:33:06 <Cale> erisco: To be fair, that way of using it is even more expedient than what I was thinking of yesterday.
13:33:07 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
13:33:09 <jeffwheeler> @type second
13:33:10 <roconnor> @type zipWith3
13:33:11 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
13:33:12 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
13:33:30 <Cale> erisco: You can also just use it to compute the relevant cotangent
13:33:59 <erisco> Cale, yeah, I think that is what you were saying yesterday, but that doesn't mean it didn't result me in taking a second look at it :)
13:34:16 <jeffwheeler> conal: you should get into Planet Haskell
13:36:13 <conal> jeffwheeler: i think i'm still on Planet Haskell.  I've been blog-quieter than usual lately.
13:36:52 <jeffwheeler> conal: oh, I saw "June 12," for some reason thought today was July 12, and mixed the two, and checked my feed reader to see if I saw your latest post
13:36:57 <jeffwheeler> conal: apparently I'm just insane, thoug
13:36:59 <jeffwheeler> * though
13:37:07 <conal> jeffwheeler: heh.  and thanks.  :)
13:42:39 <jeffwheeler> @hoogle result
13:42:40 <lambdabot> Test.QuickCheck data Result
13:42:40 <lambdabot> Test.QuickCheck Result :: Maybe Bool -> [String] -> [String] -> Result
13:42:40 <lambdabot> Data.Typeable funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
13:43:00 <jeffwheeler> Oh, it's defined later.
13:46:13 <ehird> roconnor: the few digits page says that this shouldn't work,
13:46:18 <ehird> > (2::CReal)==2
13:46:19 <lambdabot>   True
13:46:22 <ehird> how come it does?
13:46:35 <ehird> also,
13:46:42 <ehird> > show (33::CReal)
13:46:43 <lambdabot>   "33.0"
13:46:44 <ehird> works too
13:46:45 <ehird> wait hm
13:46:51 <ehird> > (2.3::CReal)==(2.3)
13:46:52 <lambdabot>   True
13:46:55 <ehird> nope
13:47:20 <dsetchell> Hi all -- new to haskell.  Looking through some source docs: what's up with the '@' symbol as in break's definition in GHC.List ?
13:47:25 <roconnor> ehird: CReal isn't FewDigits
13:47:31 <ehird> wait. it isn't?
13:47:43 <roconnor> nope
13:47:43 <ehird> what is it then?
13:47:51 <copumpkin> > showCReal 100 pi
13:47:52 <roconnor> Data.Numbers
13:47:53 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
13:48:11 <roconnor> ehird: it's in the numbers hackage
13:48:15 <ehird> roconnor: hmm
13:48:25 <Heffalump> deavid: it's an 'as' pattern
13:48:33 <ehird> roconnor: what are the pros/cons over few digits? it would seem to be better with the whole "can compare and show" thing
13:48:36 <Heffalump> s/deavid/dsetchell/
13:48:39 <ehird> although I assume this doesn't terminate,
13:48:40 <ehird> > pi == pi
13:48:42 <lambdabot>   True
13:48:42 <erisco> roconnor, I think I am done
13:48:44 <ehird> er
13:48:49 <ehird> > (pi::CReal) == pi
13:48:50 <lambdabot>   True
13:48:54 <copumpkin> :P
13:48:56 <ehird> huh
13:49:02 <Heffalump> dsetchell: foo@(x:xs) means match the argument against a cons cell, bind x to the head, xs to the tail, and foo to the whole list
13:49:03 <ehird> it must use a shaman and an oracle machine
13:49:10 <roconnor> ehird: numbers is faster and lies more
13:49:15 <erisco> roconnor, there is how short it is *without* the ability to exclude boundary points http://pastebin.ca/1491105
13:49:19 <Rotaerk> is that pi actually computed? or just stored at a very high precision
13:49:26 <ehird> Rotaerk: computed
13:49:33 <ehird> roconnor: haha; howso?
13:49:44 <maxote> i request to the world to turn off all the beacons from the streets for reducing global warming and CO2 to the atmosphere
13:49:46 <erisco> roconnor, and this is how long it is with http://pastebin.ca/1491106
13:50:07 * Rotaerk can't see the road and crashes into maxote's house.
13:50:11 <Cale> I'm pretty sure that == for CReal is just comparing to some specific precision.
13:50:15 <ehird> maxote: it's a good thing you proposed that in #haskell, where the world dictators meet
13:50:22 <erisco> roconnor, 8 more lines
13:50:24 <Cale> > 0 == (0 :: CReal)
13:50:26 <lambdabot>   True
13:50:41 <ehird> > (pi :: CReal) == (pi + tiny)
13:50:41 <Cale> > 1/product [1..1000] == (0 :: CReal)
13:50:42 <lambdabot>   Not in scope: `tiny'
13:50:44 <ehird> foiled again!
13:50:47 <lambdabot>   mueval-core: Prelude.read: no parse
13:50:47 <lambdabot>  mueval: ExitFailure 1
13:50:53 <Cale> oh, right, CReal is slow ;)
13:50:55 <dsetchell> Heffalump: ahhh, just read on that, thanks !
13:51:02 <ehird> Cale: few digits moreso :P
13:51:05 <Cale> > 1/(10^100) == (0 :: CReal)
13:51:07 <lambdabot>   True
13:51:13 <ehird> NOOOOOOOOOOOOOOOOOOOOO
13:51:16 <ehird> it be violatin' mah laws
13:51:22 <ehird> > 1/(10^100) :: CReal
13:51:23 <lambdabot>   0.0
13:51:27 <roconnor> erisco: http://pastebin.ca/1491109 -- but mine doesn't work yet. :(
13:51:36 <Cale> The Show instance is similar.
13:51:44 <copumpkin> > showCReal 200 (1/(10^100))
13:51:46 <Cale> (it just cuts it off at an arbitrary point)
13:51:46 <lambdabot>   "0.000000000000000000000000000000000000000000000000000000000000000000000000...
13:51:51 <ehird> roconnor: is the show-erroring fundamental?
13:51:55 <ehird> why couldn't it return an infinite string?
13:51:56 <ehird> (in fewdigits)
13:52:02 <erisco> roconnor, well it looks cool :D
13:52:29 <byorgey> ehird: well, then every time you tried typing in an expression involving infinite precision reals in ghci...
13:52:35 <roconnor> no but (0::CReal) == 0 is just wrong in lambdabot
13:52:48 <ehird> byorgey: you mean just like every time you tried typing in an expression involving infinite lists?
13:52:51 <erisco> roconnor, can you use guards in the case expression?
13:52:59 <roconnor> show not erroring isn't wrong.  It's just arbitrary
13:53:09 <roconnor> erisco: I don't think so
13:53:28 <erisco> roconnor, okay, so I don't think that I can make my toggle any shorter
13:53:33 <ehird> roconnor: wrong
13:53:39 <erisco> roconnor, but its fine. not too bad overall is it?
13:53:40 <ehird> erisco: "case butt of foo | bar -> ..."
13:53:48 <byorgey> ehird: yes, but lists can be finite too.  for infinite-precision reals I'd much rather have the default behavior be to cut off arbitrarily, and be able to get out an infinite String explicitly when I want to, by calling a different function.
13:53:53 <byorgey> maybe it's a matter of taste.
13:53:53 <ehird> "case butt of _ | bar -> ; _ | baz -> ;" is a case
13:53:55 <erisco> ehird, it does?
13:53:56 <roconnor> erisco: not too bad overall
13:54:09 <ehird> byorgey: urrr, "show (0::Foo)" would of course not give an infinite string
13:54:10 <erisco> ehird, I will give it a whirl
13:54:13 <ehird> only things like "show pi"
13:54:17 <ehird> err
13:54:27 <ehird> 21:53 ehird: "case butt of _ | bar -> ; _ | baz -> ;" is a case
13:54:27 <ehird> *ifthenelseetc
13:54:47 <byorgey> ehird: and what about "show (0.3::Foo)"?
13:55:09 <byorgey> I guess it depends partly on how the library is implemented, if it can sometimes tell when to stop printing
13:55:44 <byorgey> I was assuming "show (0::Foo)" would generate an infinite sequence of zeros
13:55:58 <ehird> byorgey: when i started making a computable real library i used continued fractions
13:56:07 <ehird> with a base case instead of infinite nothings
13:56:09 <erisco> ehird, roconnor, hey, having guards in case expressions does work
13:56:12 <byorgey> ah, cool.
13:56:15 <ehird> erisco: like i said :)
13:56:17 <erisco> thanks ehird, very useful :)
13:56:21 <ehird> np
13:57:03 <ehird> byorgey: i'm not sure it would have worked, though; I should pick it up again. In fact I will. Thanks a lot, now I have to do effort.
13:57:24 <byorgey> hehe, happy to help ;)
14:01:01 <erisco> roconnor, my final: http://pastebin.ca/1491124
14:01:29 <erisco> roconnor, 20 lines is pretty damn sharp I think
14:02:29 <erisco> roconnor, actually, wait, would it be better to externalize the "used" variable?
14:02:42 <erisco> roconnor, is buildHull not fully copying it from call to call?
14:03:17 <bgs100> > let phrase = "Hello there, my name is <insertnamehere>" in [ pharse !! x | x <- (findIndices isUpper phrase) ]
14:03:19 <lambdabot>   Not in scope: `pharse'
14:03:27 <bgs100> > let phrase = "Hello there, my name is <insertnamehere>" in [ phrase !! x | x <- (findIndices isUpper phrase) ]
14:03:29 <lambdabot>   "H"
14:04:55 <erisco> roconnor, haha, what am I saying, the used variable changes from call to call, that would be impossible
14:05:07 * erisco tries to bash the imperative thinking from his skull
14:05:10 <bgs100> > let phrase = "Hello There, my name is <insertnamehere>" in [ phrase !! x | x <- (findIndices (`elem` ['e'..''s']) phrase) ]
14:05:12 <lambdabot>   <no location info>:
14:05:12 <lambdabot>      lexical error in string/character literal at chara...
14:05:26 <bgs100> > let phrase = "Hello There, my name is <insertnamehere>" in [ phrase !! x | x <- (findIndices (`elem` ['e'..'s']) phrase) ]
14:05:27 <lambdabot>   "elloheremnmeisinsernmehere"
14:09:49 <mapreduce> dv_: Ah, I see you're *not* going to draw your conclusions about typing from Java. :)
14:10:27 <dv_> shall I ? :P
14:10:39 <erisco> I am *finally* done the exercises in Chapter 3, lmfao
14:10:45 <erisco> time to continue with Chapter 4...
14:10:51 <mapreduce> dv_: If you're stuck on the JVM and want something a bit closer to what you were talking about, #scala's got room.
14:14:44 <bgs100> > partition (== ' ') "Hello there, my name is <insertnamehere>!"
14:14:46 <lambdabot>   ("     ","Hellothere,mynameis<insertnamehere>!")
14:15:06 <bgs100> > words "Hello there, my name is <insertnamehere>!"
14:15:08 <lambdabot>   ["Hello","there,","my","name","is","<insertnamehere>!"]
14:23:51 <erisco> how can sortBy not experience stack overflows if it is an implementation of mergeSort?
14:25:25 <Cale> The only way that a Haskell function can create a stack overflow is by creating a giant expression whose outermost reducible subexpression is really deep. I don't think there's much opportunity for a mergesort to do that.
14:25:56 <Cale> The stack doesn't mean at all the same thing to the Haskell evaluator what it means in, say, C
14:26:18 <shepheb> Cale: are the fortune files used for lambdabot available online somewhere?
14:27:18 <erisco> Cale, hmm, alright
14:27:21 <erisco> Cale, thanks
14:27:43 <Cale> erisco: I suppose to see what's going on, you'd have to try evaluating it a bit by hand
14:28:19 <Cale> shepheb: Doesn't it just rely on the system having a fortune database?
14:30:36 <shepheb> Cale: maybe? I don't know, but it wouldn't have @keal, @protontorpedo and so on.
14:30:51 <Cale> Oh, iirc, those are in the source code
14:31:37 <Cale> See Plugin/Quote/Text.hs
14:32:14 <Cale> ah, and in Config.hs, it defines  fortunePath  as a field of the Config datastructure
14:32:26 <Cale> So you can set it there if it's not finding your fortune files.
14:35:52 <bgs100> > sortBy (compare `on` length) ["Teeesssstttttt","test", "tst", "Teesssttt", "t"]
14:35:54 <lambdabot>   ["t","tst","test","Teesssttt","Teeesssstttttt"]
14:38:22 <byorgey> rgrgrgrh, darn boundary cases!!
14:38:29 <byorgey> sorry, just venting =)
14:39:02 <bgs100> > sort ["Teeesssstttttt","test", "tst", "Teesssttt", "t"]
14:39:04 <lambdabot>   ["Teeesssstttttt","Teesssttt","t","test","tst"]
14:39:53 <bgs100> @scr on
14:39:53 <lambdabot> Maybe you meant: arr rc src
14:39:58 <bgs100> @src on
14:39:59 <lambdabot> (*) `on` f = \x y -> f x * f y
14:41:59 <erisco> ah ha, here is my problem. minimumBy experiences stack overflow, as does minimum
14:44:10 <erisco> roconnor, I had to get rid of the shortened minimumBy because it stack overflows. I replaced it with a 5-liner alternative, so it isn't too bad
14:44:44 <erisco> roconnor, I just processed a million points without any stack troubles, so I'm good
14:45:47 <roconnor> erisco: this graham filtering is tricky
14:46:00 <roconnor> it seems to kinda backtrack
14:46:35 <erisco> roconnor, my original understanding of the algorithm was broken, so when I discovered that I head to reread and figure out what I did not understand right
14:47:10 <erisco> roconnor, so maybe this will help. If you hit a right hand turn, it says the send to last point is not in the hull, so discount it. that part is correct. what it was not clear on is that you have to step back a point
14:47:27 <roconnor> ya I think I get it now
14:47:37 <erisco> so if you have p1 p2 p3 and they made a right-hand turn, you do not do p1 p3 + the next point
14:47:52 <erisco> you have to do "point before p1" + p1 + p3
14:48:25 <erisco> roconnor, and yes, allowing it to backtrack like that was the hardest thing I had to figure out
14:54:23 <erisco> roconnor, oh, dammit, another bug =\
14:54:43 <erisco> roconnor, I am having a tricky time dealing with the start and end of the hull
14:54:58 <erisco> roconnor, when it comes to excluding straights
14:55:23 <erisco> roconnor, my point P is being reported at both the beginning and end of the list :P
14:55:29 <roconnor> I think I finally go something that works
14:55:31 <roconnor> got
14:56:12 <roconnor> > check grahamScanCheck
14:56:13 <lambdabot>   Not in scope: `check'Not in scope: `grahamScanCheck'
14:56:18 <roconnor> Falsifiable, after 63 tests:
14:56:20 <roconnor> crap!
15:01:42 <dankna> @hoogle toLower
15:01:42 <lambdabot> Data.Char toLower :: Char -> Char
15:02:00 <roconnor> erisco: okay, mine seems to work expect when the list has repeated points
15:02:28 <erisco> roconnor, does it just muck it all up with repeated points?
15:02:39 <roconnor> apparently
15:02:43 <erisco> :(
15:02:49 <roconnor> they should be easy to filter out during the filtering process
15:03:32 <erisco> roconnor, I am trying to sort out my duplication bug
15:03:51 <erisco> roconnor, seems when there are an even number of points the first point is duplicated as the last
15:04:11 <erisco> roconnor, typically it is removed. I am still trying to figure out what is appending it
15:04:15 <roconnor> @hoogle sort
15:04:15 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
15:04:16 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
15:04:16 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
15:04:25 <roconnor> I wish I had a sort that removed duplicates
15:04:27 <erisco> or, not appending, but pushing onto the front
15:05:22 <roconnor> maybe I just do (map head . group  $ sort l)
15:06:11 <erisco> roconnor, sounds like you may be introducing some expensive operations though
15:06:53 <roconnor> @paste
15:06:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:07:59 <roconnor> erisco: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6819#a6819
15:08:24 <erisco> roconnor, is that working with duplicate points now?
15:08:25 <roconnor> erisco: actually I only use operations in the Num class
15:08:34 <roconnor> erisco: I believe so
15:08:47 <erisco> roconnor, are you asking me to try it out? :D
15:08:54 <roconnor> map head . group  $ sort l  -- this should remove duplicates efficiently
15:09:07 <roconnor> erisco: no I'm just showing that I don't use expensive operations.
15:09:33 <erisco> roconnor, is not removing duplicates from a list expensive?
15:10:03 <roconnor> erisco: using "nub" to remove duplicates from a sorted list is more expensive than it needs to be
15:12:50 <roconnor> *Graham Test.QuickCheck> check (defaultConfig {configMaxTest = 1000}) grahamScanCheck
15:12:52 <roconnor> OK, passed 1000 tests.
15:17:21 * roconnor is unhappy with his use of reverse
15:19:02 <erisco> roconnor, yeah I would be too :P
15:19:21 <erisco> roconnor, evidently I have more bugs than I bargained for
15:19:36 <erisco> roconnor, I am just trying to make a box and its failing somehow :P
15:25:30 <erisco> roconnor, I think I might know why that guy was talking about distance now
15:26:06 <erisco> roconnor, this does not seemed mentioned on the algorithm page but it does matter that points are listed from nearest to furthest
15:26:32 <erisco> roconnor, when there are ties when the x or y component is the same a point P
15:28:01 <erisco> roconnor, otherwise,obviously, you are invalidating points that should actually be part of the hull
15:31:20 <roconnor> erisco: your first sorting should automatically put the nearest at the closest
15:31:43 <erisco> roconnor, you mean when I was using the cotangent?
15:31:45 <roconnor> erisco: if your second sort is stable, then it should remain sorted
15:32:05 <roconnor> erisco: when selecting the lowest point
15:32:07 <roconnor> hmm
15:32:13 <roconnor> maybe you used minimumby
15:32:17 <roconnor> instead of sorting
15:32:17 <erisco> selecting the lowest point is fine
15:32:39 <roconnor> ya, but when I select the lowest point, I actually sort the whole list
15:32:58 <erisco> ah, see, this is done separately in my algorithm
15:33:11 <roconnor> and then resort that sorted list
15:33:13 <erisco> as defined in Graham's algorithm it is a separate step
15:33:37 <roconnor> > sortBy (const (const EQ)) [1,2]
15:33:39 <lambdabot>   [1,2]
15:33:52 <roconnor> > sortBy (const (const EQ)) [1,2,3,4,5]
15:33:54 <lambdabot>   [1,2,3,4,5]
15:34:22 <roconnor> @check \x -> (sortBy (const (const EQ)) x == (x::[Integer]))
15:34:24 <lambdabot>   "OK, passed 500 tests."
15:34:41 <roconnor> maybe that isn't a very good test of stability
15:35:06 <roconnor> erisco: but ya, you need to do something with points that have the cotangent
15:35:16 <roconnor> erisco: wait do you?
15:35:17 <roconnor>  hmm
15:35:22 <erisco> well since I am not using cotangent anymore...
15:35:26 <roconnor> no, I don't think so
15:35:36 <roconnor> I think it is fine in either order
15:35:56 <erisco> if you are talking about what I am talking about, it isn't
15:36:12 <erisco> if points share the same x or y value as point P they must be sorted from closest to furthest
15:36:13 <roconnor> I think I'm talking about what you are talking about
15:36:33 <roconnor> erisco: I don't think they do
15:36:39 <erisco> they absolutely do
15:36:48 <erisco> I just tested the algorithm on the situation by hand
15:36:58 <roconnor> so did I :)
15:37:04 <roconnor> it worked fine
15:37:06 <erisco> then you made a mistake ;)
15:37:14 <roconnor> I don't think so
15:37:25 <erisco> [(10,0), (10,1),(-10,1),(-10,0),(-7,0)]
15:37:45 <erisco> work with those points. if you do not sort them in order of closest to furthest, you can get this (and I do)
15:37:55 <erisco> [(-10,0),(10,0),(-7,0),(10,1),(-10,1),(-10,0)]
15:38:11 <erisco> which puts the further (10,0) before the closer (-7,0)
15:38:13 <jmcarthur> wow, you guys are still working on this algorithm?
15:38:31 <erisco> so when you run the cross test, it comes out as equal
15:38:39 <roconnor> erisco: oh, you want to preserve all the points on the hull?
15:38:39 <erisco> so you invalidate 10,0!
15:38:53 <erisco> no, I am removing points that lie on the boundary, only keeping vertices
15:39:05 <jmcarthur> wait, are you guys changing the algorithm a bit?
15:39:12 <jmcarthur> what are the requirements. i want to give it a shot
15:40:19 <erisco> jmcarthur, I am trying to not change the algorithm. I made a slight modification to how the list is sorted
15:40:29 <jmcarthur> okay
15:40:42 <erisco> jmcarthur, http://en.wikipedia.org/wiki/Graham_scan
15:40:52 * jmcarthur puts Agda away
15:41:07 <jmcarthur> i would totally try this in Agda, but i would be too tempted to try proving it, too
15:41:16 <jmcarthur> wouldn't even know where to start
15:41:46 <soupdragon> closing agda is a good start :P
15:41:55 <soupdragon> next open coq
15:42:54 <soupdragon> although I don't know how you would show its time complecity
15:42:56 <jmcarthur> that would be less daunting, for sure
15:43:01 <jmcarthur> yeah...
15:43:34 <roconnor> erisco: I see, you appear to be right.
15:44:07 <soupdragon> maybe that's something nobody needs to put in the code
15:44:39 <soupdragon> just algorithmic correctness + is it fast enough in practice
15:44:40 <roconnor> stupid degenerate cases
15:44:48 <erisco> jmcarthur, you could run a lot of tests on it and graph the time it takes and judge based on the curve *shrug*
15:46:41 <timotei> Hi! Can I ask a question :) I am quite a newbie with haskell (and functional programming) so sorry if this is the most common question over the earth, but I couldn't find answer anywhere. or am I interrupting
15:46:53 <timotei> I have implemented random in: type Rnd a = State R.StdGen a. Now when I generate rnd-number can is there any way to turn it to normal integer, or am I forced to use monadic functions like liftM every time I need do calculations with my rnd-numbers. I managed to make Rnd a -> IO a, but can I make Rnd a -> a, somehow
15:46:55 <Badger> there is no such thing as interrupting!
15:47:06 <mike-burns> Badger: Sssh, you're interrupting timotei.
15:47:20 <timotei> :)
15:48:08 <erisco> roconnor, I think I fixed it!
15:48:32 <erisco> roconnor, I kept messing up but I just had to make a two line addition on my sortBy comparator
15:48:50 <lpsmith> timotei:  you can treat it as a pure number... for a while
15:48:53 <Badger> @hoogle IO a -> a
15:48:54 <lambdabot> Foreign unsafePerformIO :: IO a -> a
15:48:54 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
15:48:54 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
15:49:23 <mike-burns> timotei: A function that returns a random number must produce a value inside the IO monad. You can use >>= or `do' notation to deal with such numbers easily, though.
15:49:40 <erisco> roconnor, so does this test suite work by giving it random data?
15:52:29 <Cale> timotei: you can use mkStdGen with a seed to get a constant random number generator
15:52:40 <roconnor> erisco: the test is a function that checks to see that the convex hull is a subset of the original points and checks that every point in the original set is to the left of each directed edge of the convex hull
15:52:43 <Cale> timotei: It will generate the same pseudorandom numbers each time
15:53:08 <roconnor> erisco: this probably isn't a proper specification. :(
15:53:14 <Cale> timotei: Usually the idea is to use newStdGen from IO though, and then write the functions which need to generate random values so that they take a StdGen as a parameter.
15:53:28 <roconnor> erisco: the more I think about it the more inadequate I realize it is
15:53:29 <timotei> mike-burn: so I have to stick with Rnd type until I do IO? I wanted to do thing like: do { u <- randR (1,10); w <- randR (1,u).. but seems it isn't so simple
15:54:13 <erisco> roconnor, my resolution of one bug has led to the introduction of another :P yay
15:54:44 <Cale> timotei: It looks like you're reinventing MonadRandom which you can get from Hackage
15:55:29 <timotei> hmm I'll take look at that
15:55:35 <Cale> timotei: You can see an example of usage at the bottom of http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html
16:05:20 <timotei> hmm that MonadRandom seems just what I wanted, how does the Hackage work, can I just cp the sourcecode from there or is there some package to install :)
16:05:38 <ColeSOAR> i started learning haskell from the "learn you a haskell for great good" tutorial.  but it seems so unfinished
16:09:43 <Cale> ColeSOAR: You might also check out the Real World Haskell book online, and/or the Haskell Wikibook.
16:10:04 <ColeSOAR> i wll
16:10:13 <Cale> timotei: Ah, you use cabal-install to install things.  cabal install MonadRandom  should download and install it
16:10:53 <Cale> timotei: If you don't have cabal-install, it can be obtained from Hackage as a .tar.gz which you unpack and run the bootstrap.sh in there.
16:15:27 <timotei> ok thanks
16:18:31 <erisco> roconnor, ah, more cases on the sort comparator
16:18:43 <erisco> roconnor, three more lines... its not looking much shorter all of a sudden :P
16:23:14 <vinicius_> so boring to factor grammars for parsec :/
16:27:38 <erisco> roconnor, I am proving that some of the posted solutions are incorrect :P
16:27:44 <benmachine> runhaskell Setup.hs configure invariably tells me that the dependencies I put in Build-Depends: are missing
16:27:52 <erisco> roconnor, http://www.refactormycode.com/codes/569-graham-scan while fancy with a GUI, does not work
16:27:56 <benmachine> even though they are quite clearly installed
16:28:08 <benmachine> is there anything I need to do other than put the package name in that field?
16:28:09 <erisco> roconnor, fails on [(10,0), (10,1),(-10,1),(-10,0),(-7,0),(-10,2),(-10,3),(-4,1),(-2,2),(-12,1)]
16:28:14 <benmachine> (the package in question is xml)
16:28:17 <binrapt> Has anybody here ever embedded Haskell in another application? I am considering making a Haskell interface for a Diablo II cheat which offers things like packet manipulation to the developer. I am told that embedding Haskell is very complicated though, is this true?
16:28:33 <binrapt> The application itself is written in C++
16:28:45 <binrapt> Are the foreign function interfaces of Haskell difficult to use? I'd have to write C interfaces for it I suppose?
16:31:33 <jmcarthur> the FFI is a dream compared to most language's FFIs, but yes you would need some C for it instead of C++
16:32:14 <jmcarthur> embedding haskell is pretty easy. you just have to init the runtime and call the haskell main from within C
16:32:31 <binrapt> It would require callbacks to Haskell mainly
16:32:33 <jmcarthur> or whatever haskell function
16:32:36 <binrapt> When new packet events arrive and such
16:32:54 <jmcarthur> i've not done that, but i've not heard any complaints about it
16:33:00 <binrapt> Ok thanks
16:33:08 <jmcarthur> maybe check out the GLUT bindings or something? i know they use callbacks
16:34:49 <binrapt> Alright thanks
16:44:05 <erisco> roconnor, the nice short implementation here is also broken http://ox.cx/graham.hs it fails on the same set
16:44:15 <erisco> even more spectacularly :P
16:46:57 <erisco> roconnor, ah, my bad, it actually succeeded. I miscounted :P
16:47:10 <erisco> the grid I am constructing my tests on is not numbered... its a picture in GIMP heh
16:55:06 <Nafai> dcoutts__: Am I correct in seeing that wnck is not wrapped in gtk2hs?
17:19:24 <drhodes> A rubiks cube, made of 6 faces, 9 squares each.  Rotate an edge slice and 5 faces change.  So, lots of mutation.  Would the state monad work well here to handle the face destructuring and rebuilding?
17:19:50 <soupdragon> no mutation
17:21:25 <drhodes> are you saying program in smaller corner pieces and edge pieces, instead of the 2d approach?
17:22:03 <soupdragon> yes
17:23:39 <drhodes> but still the pieces are shared, so it still a pain.
17:25:00 <drhodes> and the angles need tracked relative to the normal planes or some reference point.
17:26:27 <kpreid> rubik's cube operations are permutations
17:27:23 <aavogt> I believe that genetic algorithms require mutation
17:27:26 <sm> g'day all
17:27:51 <aavogt> eh?
17:27:59 <mike-burns> I get it.
17:28:15 <Tigran> I see what you did there.
17:29:02 <kpreid> you don't need a complicated model of rotating from any direction to represent operations on a rubik's cube
17:29:08 <sm> I'm thinking about packaging a little tool I wrote for testing command-line programs. But I need some naming help. runshelltests or shelltestrunner ?
17:30:05 <kpreid> "rotate cube right" "rotate cube down" "rotate left face" "rotate middle" would be sufficient for example
17:30:27 <sm> also any comments like "there's one already" welcome, it's at http://joyful.com/repos/pandoc/tests/RunShellTests.hs
17:31:28 <aavogt> sm: '#!/usr/bin/env runhaskell' works with non-lhs?
17:31:37 <sm> sure
17:31:47 <drhodes> change the orientation of the cube, then do the rotation.. much better, thanks kpreid .
17:31:48 <mike-burns> sm: How about "chunnel" as a name.
17:32:06 <vinicius> Shouldn't 'many parserA' in parsec not fail in the middle of parserA if it parsed at least one item?
17:32:28 <Berengal> Hysterical raisins are stupid :(
17:34:30 <aavogt> I never knew that a #! would be allowed by a haskell compiler
17:35:01 <Axman6> runhaskell isn't exactly a compiler is it?
17:35:08 <Berengal> aavogt: Can't hurt, probably useful, why not?
17:36:10 <vinicius> > parseTest (string "aa") "aa"
17:36:12 <lambdabot>   Not in scope: `parseTest'Not in scope: `string'
17:37:00 <Axman6> hmm, i need to try making a proxy server in haskell
17:37:03 <vinicius> @import Text.ParserCombinators.Parsec
17:37:03 <lambdabot> Unknown command, try @list
17:37:06 <vinicius> @list
17:37:07 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:37:21 <Axman6> should be a good way to use my TernaryTrees package
17:37:24 <sm> shelltestrunner I guess
17:37:49 <Axman6> and finally make ther StringMap type and out it the release version
17:38:07 <Berengal> sm: shelltron
17:38:13 <mike-burns> +1 shelltron
17:38:14 <Berengal> Or even better, SHELLTROL
17:38:17 <Berengal> TRON*
17:38:43 <Berengal> Wow, I've really been cursed with bad spelling lately...
17:39:01 <Berengal> Anyway, more things need -tron suffixes
17:39:34 <dankna> concur!
17:39:49 <sm> this little script can't yet justify that excellent name :)
17:40:03 <Berengal> shelltronett?
17:40:54 * sm smiles
17:43:19 <gparmer> I'm new and am having a stupid problem:
17:43:23 <gparmer> uniqPerm xs = nub [ x:ps | x <- xs, ps <- uniqPerm $ delete x xs ]
17:43:31 <gparmer> uniqPerm "++---"
17:43:37 <gparmer> results in []
17:44:22 <gparmer> I'm using ghc version 6.8.2... so List.permutations isn't available
17:44:27 <dolio> uniqPerm [] = [], under that definition.
17:44:40 <dolio> Because [ ... | x <- [], ...] = [].
17:45:09 <dolio> And if you note that, then you can also see that '[ ... | ... , ps <- []] = []'
17:45:24 <dolio> Which means that uniqPerm xs = [] forall xs.
17:45:36 <gparmer> first, thank you very much!
17:45:41 <Berengal> Think of cartesian products and let [] = 0
17:45:45 <soupdragon> <gparmer> uniqPerm "++---"
17:46:18 <aavogt> @type delete
17:46:18 <soupdragon> why not, perm ["++","---"] ?
17:46:19 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
17:46:34 <gparmer> but why x <- []?  shouldn't x <- [+, +, -, -, -]?
17:46:47 <soupdragon> (btw use full words)
17:47:04 <EvilTerran> gparmer, your base case is the problem
17:47:20 <dolio> It eventually gets to [] when you follow the recursive case all the way down.
17:48:10 <Berengal> uniqPerm "++---" calls 'uniqPerm $ delete + "++---"' which calls 'uniqPerm $ delete + "+---" etc
17:48:26 <gparmer> yeah, I got the recurrence
17:48:30 <Berengal> Just add uniqPerm [] = [[]]
17:49:01 <gparmer> I was assumming (wrongly), that it would accumulate all the lists it got before it got to the base case (empty)
17:49:35 <gparmer> anyway, the rumors are true, the haskell community is amazingly helpful and friendly!
17:49:39 <gparmer> thanks!
17:49:51 <dankna> awwwww :)
17:50:10 <Zeiris> @src fmap
17:50:11 <lambdabot> Source not found. My mind is going. I can feel it.
17:50:21 <Zeiris> @src fMap
17:50:22 <lambdabot> Source not found. Where did you learn to type?
17:50:30 <aavogt> @src Functor fmap
17:50:31 <lambdabot> Source not found. :(
17:50:35 <Berengal> fmap doesn't have a default implementation
17:50:39 <Berengal> That would be silly
17:51:01 <aavogt> yeah, I guess @type is helpful enough
17:51:09 <benmachine> :t fmap
17:51:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:51:13 <Berengal> @src [] fmap
17:51:13 <lambdabot> fmap = map
17:51:19 <Berengal> @src Maybe fmap'
17:51:20 <lambdabot> Source not found.
17:51:24 <Berengal> @src Maybe fmap
17:51:24 <lambdabot> fmap _ Nothing       = Nothing
17:51:25 <lambdabot> fmap f (Just a)      = Just (f a)
17:52:58 <soupdragon> :t bind
17:53:00 <lambdabot> Not in scope: `bind'
17:53:16 <mike-burns> :t (>>=)
17:53:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:53:32 <vinicius> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6828#a6828
17:53:51 <vinicius> Is it possible to make the inner parsers backtrackable?
17:54:04 <vinicius> as in, many would supposedly work.
17:54:23 <Berengal> try?
17:54:42 <vinicius> Berengal: try only makes sense before a <|> according to rwh
17:55:14 <Berengal> try enables backtracking
17:55:24 <Berengal> It doesn't catch errors in parsing though
17:59:38 <vinicius> Berengal: where would I put the try? As far as I'm concerned it's failing parsing inside a many combination
18:00:43 <Berengal> vinicius: Where exactly is it failing? Which line?
18:01:11 <vinicius> if you try: parseTest mainParser "label1 a:{1,2}; b:{3,4}; label2 c:{1,2};"
18:01:44 <vinicius> it's reading label2 as an identifier and failing inside a many vardeclParser
18:02:17 <erisco> is there a way to obtain the largest Int during runtime in Haskell?
18:02:27 <Axman6> maxBound
18:02:29 <Berengal> > maxBound :: Int
18:02:30 <lambdabot>   9223372036854775807
18:02:34 <erisco> thanks
18:02:55 <Axman6> > (minBound,maxBound) :: (Int,Int)
18:02:57 <lambdabot>   (-9223372036854775808,9223372036854775807)
18:03:26 <dankna> maxBound :: Float
18:03:28 <dankna> > maxBound :: Float
18:03:29 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
18:03:30 <lambdabot>    arising from a use of...
18:03:36 <dankna> heh, just curious
18:03:36 <Axman6> @instances Bounded
18:03:37 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
18:03:51 <dankna> > maxBound Dual Float
18:03:53 <lambdabot>   Not in scope: data constructor `Float'
18:03:53 <mike-burns> > maxBound :: Bool
18:03:55 <lambdabot>   True
18:03:56 <dankna> > maxBound :: Dual Float
18:03:57 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
18:03:57 <lambdabot>    arising from a use of...
18:04:02 <dankna> oh, right
18:04:05 <Axman6> > maxBound :: (Int,Char)
18:04:07 <lambdabot>   (9223372036854775807,'\1114111')
18:04:12 <dankna> > maxBound :: Any
18:04:13 <lambdabot>   Any {getAny = True}
18:04:38 <vinicius> > maxBound :: (Sum Real)
18:04:40 <lambdabot>   Class `GHC.Real.Real' used as a type
18:04:51 <vinicius> > maxBound :: (Sum Double)
18:04:53 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
18:04:53 <lambdabot>    arising from a use o...
18:06:19 <benmachine> wouldn't the maxBound of a double be inf?
18:06:21 <hackagebot> sendfile 0.3.1 - A portable sendfile library (MatthewElder)
18:06:30 <dankna> well, inf isn't really a bound
18:06:32 <benmachine> or even the maximum representable float
18:06:33 <dankna> in that you can never reach it
18:06:42 <dankna> I was surprised that it wasn't the maximum representable float though
18:06:59 <benmachine> it'd probably be awkward having some x for which x > maxBound
18:07:33 <dolio> What? You can reach it.
18:07:51 <Berengal> vinicius: Yeah, you can't fix that with try, you need to specify your grammar betterer
18:07:53 <benmachine> > 1000 ** 1000
18:07:55 <lambdabot>   Infinity
18:07:58 <benmachine> woo
18:08:19 <Axman6> > 2^2048 :: Double
18:08:21 <lambdabot>   Infinity
18:08:28 <Axman6> > 2^1024 :: Double
18:08:28 <dolio> > 8.98846567431158e307 * 2
18:08:31 <lambdabot>   Infinity
18:08:31 <lambdabot>   Infinity
18:08:36 <Axman6> > 2^1023 :: Double
18:08:37 <lambdabot>   8.98846567431158e307
18:08:41 <vinicius> I was afraid of that :/ , thanks anyway.
18:08:46 <erisco> @paste
18:08:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:09:01 <Axman6> that url needs changing
18:09:25 <dolio> Can't get there by (+1), of course.
18:09:32 <CalJohn> In category theory, if I were to use the example of the natural numbers (with 0) as a monoid, would that mean that single object would be 0, and the binary operation would be the succ function?  I am slightly confused about this, and not sure of a better place to ask
18:09:54 <CalJohn> s/single object/unit
18:10:04 <erisco> I am required to make a function that converts a string of digits (minus sign included) into an Int and error if overflow occurs. Did I do this well? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6829#a6829
18:10:11 <Berengal> vinicius: I know what it's like. Debugging parsers can be hard...
18:10:20 <erisco> I have never needed to test for over/under flow before so I am curious if this is safe :P
18:10:31 <vinicius> Berengal: and parsec is less documented than happy =P
18:10:52 <erisco> actually it probably isn't... if the number is large enough it would wrap around once and my test would pass
18:10:55 <erisco> yes?
18:10:58 <benmachine> maxBound + 1 :: Int
18:11:02 * benmachine is curious
18:11:05 <benmachine> er
18:11:05 <Berengal> vinicius: Add <?> to the end of your parsers (outside the 'do')
18:11:08 <bd_> erisco: might be easier too convert it straight into an Integer and check against fromIntegral (maxBound :: Int) etc
18:11:08 <benmachine> > maxBound + 1 :: Int
18:11:10 <lambdabot>   -9223372036854775808
18:11:14 <bd_> to*
18:11:23 <Berengal> like 'fooParser = {do stuff} <?> "foo"
18:11:25 <bd_> erisco: then do a single fromIntegral conversion to get it to be an Int at the end
18:11:58 <erisco> bd_, if I have to do this for every step then I may as well use an Integer in the first place
18:12:00 <benmachine> the way I'd always done it was checking something like if (maxBound - d) / 10 < acc then youreInTrouble else itsFine
18:12:06 <erisco> but, yeah, I just disproved that my test works
18:12:18 <dolio> CalJohn: With categories as monoids, the arrows correspond to elements of the monoid.
18:12:23 <Berengal> > fromInteger (fromIntegral (maxBound :: Int) + 1) :: Int
18:12:25 <lambdabot>   -9223372036854775808
18:12:25 <bd_> erisco: Right, you'd do what I just said only once :)
18:12:38 <erisco> bd_, how is that so?
18:12:58 <roconnor> > minBound :: Int
18:13:00 <lambdabot>   -9223372036854775808
18:13:37 <bd_> erisco: basically, asInt = fromIntegral . checkBound . asInteger where checkBound x | x < toInteger (minBound :: Int) || x > toInteger (maxBount  Int) = error "blah!"; checkBound x = x
18:13:42 <bd_> something like that
18:13:49 <CalJohn> dolio: could you explain that to me?  does that mean that there is a function for each element that simply returns that element?
18:14:27 <bd_> erisco: mind you, a cleverer approach might work better if speed is of the essence.
18:14:33 <Axman6> toInteger? try fromIntegral, more standard
18:14:34 <roconnor> @quote haiku
18:14:34 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid  <lilac> that's my new monad tutorial haiku  <jmcarthur> i think that is the best monad tutorial i have ever
18:14:35 <lambdabot> read
18:14:38 <erisco> bd_, I do not know what the periods do
18:14:43 <CalJohn> dolio: ie, for Nat, there would be a f such that f = 1, and a g such that g = 2, and so on?
18:14:44 <bd_> Axman6: Yes, I was trying to make it explicit :)
18:14:51 <Axman6> righto
18:14:54 <dolio> CalJohn: Arrows in the category all have type M -> M, so you can think of them as being partially applied binary operations.
18:15:06 <bd_> erisco: h = f . g is the same as h arg = f (g arg)
18:15:19 <bd_> erisco: basically it pipes the argument through from right to left
18:15:50 <bd_> @src (.)
18:15:50 <lambdabot> (f . g) x = f (g x)
18:15:53 <Axman6> erisco: they're function composition
18:16:10 <dolio> CalJohn: So the 0 arrow is a 'function' that adds 0 to the input. The 1 arrow adds 1 to the input, etc.
18:17:15 <dolio> Then since 0 corresponds to the identity arrow, you get from 'id . f = f = f . id' that 'n + m + 0 = n + m = n + 0 + m', or something like that.
18:18:22 <dolio> And from associativity in the category, you get associativity of the monoid action.
18:18:38 <CalJohn> dolio: I basically understand, but I had not previously considered arrows in that way
18:20:13 <Berengal> > (+5) . read $ "10"
18:20:14 <lambdabot>   15
18:21:31 <erisco> asInt_fold "27670116110564327423"
18:21:46 <erisco> there is my proof that my method does not work. it wraps right back around and passes my test
18:24:39 <erisco> I call bogus on that exercise question. there is no way to do it at all without converting to an Integer
18:27:27 <sm> http://joyful.com/darcsweb/darcsweb.cgi?r=shelltestrunner ready for testers
18:29:44 <benmachine> erisco: I remember doing overflow-safe functions in C without ever overflowing
18:30:00 <benmachine> (without checking if I did overflow but only if I'm going to)
18:30:46 <benmachine> :t div
18:30:47 <lambdabot> forall a. (Integral a) => a -> a -> a
18:31:25 <Berengal> erisco: comparing strings?
18:31:35 <benmachine> erisco: I think if maxBound - d `div` 10 is less than acc, then it follows that acc * 10 + d > maxBound
18:31:44 <erisco> @src negate
18:31:45 <lambdabot> negate x = 0 - x
18:31:59 <Berengal> > compare "9223372036854775807" "9223372036854775808"
18:32:01 <lambdabot>   LT
18:32:30 <erisco> benmachine, you would have to show me that test working on the number 27670116110564327423
18:32:33 <benmachine> > compare "9223372036854775807" "10000000000000000000"
18:32:35 <lambdabot>   GT
18:33:04 <Axman6> erisco: what's your problem?
18:33:13 <benmachine> erisco: you want me to actually *do* something?
18:33:18 * benmachine uses the 2:30 am excuse
18:33:29 <erisco> Axman6, testing to see if an Int overflowed, but converting to an Integer defeats the purpose
18:33:44 <erisco> benmachine, I fail to see how any test can detect that case is all
18:33:58 <benmachine> okay, give me a second
18:34:09 <Berengal> let doesOverflow ('-':number) = compare "9223372036854775808" number > LT; doesOverflow number = compare "9223372036854775807" number > LT; in (doesOverflow "9223372036854775808", doesOverflow "9223372036854775807", doesOverflow "-9223372036854775808")
18:34:17 <Berengal> > let doesOverflow ('-':number) = compare "9223372036854775808" number > LT; doesOverflow number = compare "9223372036854775807" number > LT; in (doesOverflow "9223372036854775808", doesOverflow "9223372036854775807", doesOverflow "-9223372036854775808")
18:34:19 <lambdabot>   (False,True,True)
18:34:49 <Berengal> doesntOverflow* I guess...
18:34:53 <benmachine> Berengal: if you're going to use string compare to test if a string is larger than another one, check the lengths first
18:34:57 <Berengal> (or flip the return)
18:35:05 <benmachine> (and that's still not the easiest way I think)
18:35:06 <erisco> Berengal, sure, now tell me if 27670116110564327423 is an overflow
18:35:15 <erisco> benmachine, mind you, that number is designed for 64-bit systems
18:35:25 <erisco> lambdabot is evidently on 64-bit
18:35:36 <Berengal> Oh yes, and length. So obvious I forgot...
18:35:42 <Axman6> erisco: do you have a reason to not be using Integer btw?
18:35:58 <erisco> Axman6, yes, the exercise question said to use an Int
18:36:00 <Berengal> erisco: use show m{ax,in}Bound then
18:36:02 <dolio> Are you talking about the literal 27670116110564327423?
18:36:16 <erisco> dolio, no, the string
18:36:32 <Axman6> > 27670116110564327423
18:36:33 <lambdabot>   27670116110564327423
18:36:39 <Axman6> > 27670116110564327423*2
18:36:41 <lambdabot>   55340232221128654846
18:36:43 <benmachine> erisco: is the parser supposed to accept --1 as 1?
18:36:47 <erisco> > 27670116110564327423 :: Int
18:36:49 <lambdabot>   9223372036854775807
18:37:05 <erisco> benmachine, no. someone's code does but that is just stupid
18:37:12 <erisco> benmachine, mine doesn't so we will stick with that :P
18:37:52 <erisco> as you can see, that number is designed to overflow and wrap right back around to maxBound :: Int
18:38:04 <erisco> and I'd like to see something detect that
18:39:18 <erisco> the test is only run on every positional column as that is how the parser works. if no number could wrap around like that in less than x100 the size, it would be detected
18:39:43 <erisco> but, it wraps all the way around right under the nose of the detection
18:39:47 <sm> what markup is available in a .cabal's description field ? can you format a literal block ?
18:44:44 <erisco> in haskell would you do    "non-digit '" ++ [d] ++ "'"    for an error message or is there suppressed string formatting?
18:45:09 <Berengal> There's Text.Printf, but it's hackish
18:45:17 <Berengal> In that it's not typesafe
18:45:25 <Berengal> And also because it's hackish
18:45:43 <dolio> And by hackish, he means awesome.
18:45:51 <Berengal> Indeed I do
18:46:24 <dolio> Also, I'd do:  "non-digit '" ++ d : "'"
18:46:33 <Berengal> There's also template haskell, which has something like $(printf "foo %s bar %d") "hello" 42, but I've never used it
18:46:46 <dolio> Because it saves you a miniscule amount of performance.
18:46:58 <Berengal> dolio: It does?
18:47:02 <benmachine> oh I am a tit
18:47:04 <dolio> Well, conceivably.
18:47:16 <benmachine> my overflow checker failed because I forgot that `div` is more hungry than -
18:47:16 <dolio> GHC might optimize it to be the same, I suppose.
18:47:30 <Berengal> [x] (++) foo = x:foo, at least semantically. I'm not sure what ghc compiles them to
18:47:52 <Berengal> benmachine: You can never have enough parens!
18:48:18 <Berengal> @src (++)
18:48:18 <lambdabot> []     ++ ys = ys
18:48:19 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
18:48:19 <lambdabot> -- OR
18:48:19 <lambdabot> xs ++ ys = foldr (:) ys xs
18:48:54 <benmachine> erisco: I can't fault my overflow checker
18:48:58 <benmachine> one sec
18:49:39 <benmachine> erisco: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6832#a6832
18:50:00 <benmachine> never overflows anything
18:50:14 <benmachine> as an aside, is Int overflow defined behaviour in haskell?
18:50:34 <benmachine> I mean, everyone assuming it wraps isn't the same as the language saying it wraps
18:51:04 <Berengal> I've got no idea, but it's presumably in the report
18:52:30 <benmachine> "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined; an implementation may choose error (_|_, semantically), a truncated value, or a special value such as infinity, indefinite, etc."
18:52:34 <benmachine> how about that
18:53:04 <benmachine> so the lesson is, wrapping is a bug
18:53:09 <benmachine> not a feature
18:53:30 <Berengal> I assume wrapping is a consequence of truncating
18:53:52 <sm> why would cabal sdist give me cabal: shelltestrunner-0.1: getModificationTime: does not exist (No such file or directory) ?
18:54:35 <SamB> benmachine: that probably doesn't apply to the ones from Data.Int and Data.Word ...
18:55:03 <erisco> benmachine, I do not know how your method works but it seems to be working
18:55:12 <benmachine> SamB: a. why not and b. what does then?
18:55:32 <SamB> it just seems like those are *meant* to "wrap", as you call it
18:55:42 <dolio> Nothing covers Data.Int and Data.Word. They were invented after the standard.
18:55:44 <benmachine> just seems like it, huh?
18:55:59 * benmachine remains sceptical :P
18:56:12 <SamB> well, they certainly aren't precisely documented one way or the other
18:56:14 <Berengal> Truncating a 33-bit number by dropping the high-bit can leave you with a number that's negative in signed interpretation
18:56:35 <benmachine> erisco: it checks at every digit if multiplying that digit and adding 10 would go over maxBound, and if so it errors
18:57:14 <erisco> benmachine, ah, I get it now
18:57:20 <SamB> but what's the point of having specific narrower widths of numbers (8 and 16, anyway), especially considering that they use just as much space, if not that?
18:57:38 <benmachine> SamB: why do they use just as much space?
18:57:49 <erisco> benmachine, thanks, that is clever
18:58:02 <SamB> benmachine: because it isn't practical to allocate on byte boundaries
18:58:10 <benmachine> erisco: ooh, my haskell's not been called clever before
18:58:13 * benmachine treasures the moment
18:58:27 <erisco> benmachine, well I am just a haskell noob ;)
18:58:30 <SamB> 99% of Haskell systems have to allocate on 32-bit boundaries at least
18:59:07 <benmachine> SamB: fair enough, I dunno then
18:59:09 <SamB> not, mind you, that the CPUs mandate this, but they tend to go a lot slower if you don't
18:59:38 <SamB> and anyway if you do that then you get two free bits in the pointer that you can use for tagging
19:00:02 <benmachine> all I know is that in C you have undefined behaviour for integer overflow so that i + 10 > i can be optimised to true
19:00:02 <ManateeLazyCat> dcoutts__: If i want a window transparent, how to do it? Thanks!
19:00:25 <SamB> benmachine: oh, that's C you're talking about ?
19:00:33 <SamB> that sounds pretty crazy
19:00:34 <hackagebot> shelltestrunner 0.1 - A handy tool for testing command-line programs. (SimonMichael)
19:00:38 <erisco> benmachine, however you do not do so well by using foldl ;) I am presuming the map is lazy but I am too inexperienced to know
19:00:40 <benmachine> SamB: that's an example of where undefined overflow is useful
19:00:52 <benmachine> erisco: I'm a haskell noob too, so pass
19:01:09 <SamB> evidently, I mostly hate learning new things about C
19:01:22 <SamB> though occasionally I learn things about C that are nicer than I expected
19:01:35 <sm> gaah!
19:01:44 <lpsmith> samb: you can fit two 16 bit integers in a 32 bit block ;-)
19:01:47 <Berengal> C is nicer than I expected in general, but then again I had (and have) pretty low expectations of it...
19:01:49 <erisco> benmachine, I do know that if you can foldl, you almost always want to foldl' instead. the reason is that foldl accumulates a thunk whereas foldl' evaluates the accumulator on each step
19:02:04 <Vanadium> @src foldl'
19:02:05 <lambdabot> foldl' f a []     = a
19:02:05 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:02:05 <erisco> benmachine, so the difference is stack overflow versus not stack overflowing
19:02:21 <ManateeLazyCat> I'm use gtk2hs, i want window transparent, how to do it? Thanks!
19:02:34 <dolio> I'm not sure i + 10 > i being optimized to True for fixed-precision integers is "nice". :)
19:02:37 <SamB> ManateeLazyCat: not necessarily possible
19:02:40 <benmachine> erisco: well, add an apostrophe for me then
19:02:54 <erisco> benmachine, :)
19:03:18 <ManateeLazyCat> SamB: Do you know how to make window transparent?
19:03:26 <benmachine> I'm curious now though
19:03:27 <SamB> ManateeLazyCat: it's probably not possible on anything that doesn't guarentee you a composite manager
19:03:53 <benmachine> you say almost always
19:04:10 <benmachine> do you know of any case where you don't want to use foldl'?
19:04:31 <ManateeLazyCat> SamB: I want create a customize widget with cairo, so i need window parent transparent, then i can draw graphic on window with cairo.
19:04:38 <dolio> There are cases where it doesn't matter much.
19:04:42 <dolio> Like reverse.
19:04:43 <SamB> benmachine: I think I've heard of some?
19:05:10 <Berengal> benmachine: Where the function can lazily return
19:05:13 <lpsmith> benmachine:   laziness isn't always bad for performance,  it can be quite benefitial sometimes
19:05:15 <erisco> benmachine, any place where the lazy evaluation would be beneficial
19:05:29 <SamB> ManateeLazyCat: oh. I'm not sure GTK really gives every widget it's own window anyway, so it might be easier than that
19:05:29 <Berengal> e.g. (:)
19:05:36 <hackagebot> shelltestrunner 0.2 - A handy tool for testing command-line programs. (SimonMichael)
19:05:40 <erisco> benmachine, but for accumulating a single value, that is probably never going to be a foldl
19:05:46 <benmachine> Berengal: yeah that's just what I'm reading about now
19:06:07 <lpsmith> also,  ghc's strictness analyzer often, but not always, removes the need for foldl' versus foldl
19:06:07 <SamB> ManateeLazyCat: besides which it could handle it's own compositing in cases like that. but I still don't know how to do it :-(
19:06:16 <dolio> You can also construct an example where foldl' will result in _|_, but foldl will not. But such examples are pretty contrived in my experience.
19:06:21 <ManateeLazyCat> SamB: Oh, thanks anyway.
19:06:25 <SamB> dolio: when?
19:06:34 <Berengal> benmachine: I think "recursive datatypes" pretty much sum up 99% of the cases where foldl isn't worse than foldl'
19:06:34 <SamB> er. lpsmith: when
19:06:37 <SamB> sorry dolio
19:06:48 * SamB blames it on x-chat's hashes or something
19:07:21 <lpsmith> well, I'm not sure I can think of anything involving foldl per se...
19:07:25 <dolio> SamB: Cases where f ignores one of its arguments, I think. I'd have to think about it, because it never really happens in practice. :)
19:07:43 <lpsmith> but there are certainly instances where lazy evaluation is good for performance reasons :)
19:08:05 <SamB> I was really wondering when the strictness analyzer would actually be any help there
19:08:07 <dolio> > foldl (flip const) undefined [1..10]
19:08:08 <lambdabot>   10
19:08:12 <dolio> > foldl' (flip const) undefined [1..10]
19:08:13 <lpsmith> where?
19:08:14 <SamB> it doesn't seem like HOFs are really it's thing
19:08:14 <lambdabot>   10
19:08:27 <erisco> how would I lazily test to see if every character in a string was a digit?
19:08:32 <lpsmith> I don't think lambdabot runs the strictness analyzer,  you need to compile -O for that?
19:08:37 <SamB> erisco: can't lazily do that
19:08:42 <SamB> that's a strict thing
19:08:47 <erisco> =\
19:08:55 <SamB> well, assuming you wanted one Bool
19:09:03 <lpsmith> samb: I'm going to have to either check the logs or you are going to have to clarify the example
19:09:14 <erisco> SamB, if I map isDigit on the string I cannot lazily go until I find a false?
19:09:17 <lpsmith> 'cause I was disconnected for a bit
19:09:38 <Berengal> erisco: mconcat . map (First . isDigit)
19:09:38 <SamB> just wondering about this: <lpsmith> also,  ghc's strictness analyzer often, but not always, removes the need for foldl' versus foldl
19:09:39 <benmachine> oh you probably can
19:09:49 <SamB> erisco: oh, sure
19:09:49 <benmachine> :t all
19:09:51 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:09:54 <benmachine> :t any
19:09:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:09:57 <Berengal> or just 'all isDigit'
19:10:11 <benmachine> @src all
19:10:11 <SamB> Berengal: what the heck was that before ?
19:10:12 <lambdabot> all p =  and . map p
19:10:21 <benmachine> @src and
19:10:22 <lambdabot> and   =  foldr (&&) True
19:10:23 <SamB> Monoid is ... a bit overboard in this instance
19:10:32 <erisco> "all isDigit string" suffices?
19:10:33 <Berengal> SamB: Messed up monoids.. it should've been And (or All), not First
19:10:36 <SamB> it could be useful to assemble more complicated predicates ;-)
19:10:53 * Berengal has a temporary crush on monoids
19:10:55 <lpsmith> @src sum
19:10:56 <lambdabot> sum = foldl (+) 0
19:11:01 <lpsmith> not fold'
19:11:12 <SamB> though I think the Compare Monoid is maybe usable more often
19:11:16 <Berengal> (+) could conceivably be lazy...
19:11:17 <dolio> > foldl' (flip const) 7 (undefined : [1..10])
19:11:19 <lambdabot>   * Exception: Prelude.undefined
19:11:20 <dolio> > foldl (flip const) 7 (undefined : [1..10])
19:11:22 <lambdabot>   10
19:11:23 <dolio> There.
19:11:25 <erisco> lpsmith, I know, and it stack overflows
19:11:26 <SamB> Berengal: yes, it could
19:11:33 <SamB> Berengal: but that's hardly the expected case
19:11:35 <lpsmith> of course
19:11:44 <erisco> > sum [1..1000000]
19:11:46 <SamB> so we really shouldn't write our library code for that case, I think
19:11:46 <lambdabot>   * Exception: stack overflow
19:11:52 <Berengal> SamB: The expected case is maximum lazyness in the Prelude
19:11:57 <lpsmith> but if you compile sum with the -O option,  it shouldn't overflow
19:12:01 <SamB> Berengal: the Prelude is stupid
19:12:09 <erisco> > foldl' (+) 0 [1..1000000]
19:12:11 <lambdabot>   500000500000
19:12:15 <erisco> all good :)
19:12:15 <SamB> (to expect that regardless, I mean)
19:12:29 <SamB> it should expect that for everything but arithmatic, probably
19:12:37 <Berengal> In most cases, stack overflows aren't due to badly defined Prelude convenience functions like sum
19:13:11 <Berengal> If they are, it's probably because you're in ghci
19:13:28 <erisco> I am. I am guessing that the compiler picks up the case
19:13:31 <SamB> what about hugs?
19:13:45 <Berengal> A weird artifact of lazy evaluation is that about 50% of the stack overflows i get in ghci can be resolved by simply asking for the value once more...
19:13:53 <SamB> anyway, we shouldn't be making the strictness analyzer bail us out of stack overflows
19:13:55 <SamB> it's bad form
19:14:20 <lpsmith> yeah
19:14:21 <erisco> SamB, I'd agree :D
19:14:34 <erisco> I'd like my code to run on the interpreter for testing too
19:14:37 <lpsmith> if you compile that example -O,  no stack overflow,  and I agree, btw
19:14:39 <Berengal> SamB: I agree that there should probably be a sum' and so on, but I'm not sure I want sum to be strict...
19:14:47 <Berengal> It feels... dirty... somehow..
19:14:58 <lpsmith> It would be nice if GHC moved to a segmented stack and completely eliminated stack overflows :-D
19:15:11 <erisco> a gigantic thunk building in memory sounds dirty too
19:15:17 <lpsmith> but also it's a lesson:  don't use the interpreter
19:15:52 <lpsmith> seriously, almost everything I do,  I compile -O2.   GHC 6.10 is pretty snappy these days on modern CPUs :-) :-)
19:16:01 <Berengal> lpsmith: Rather a stack overflow than the crippled execution speed of evaluating a billion-deep nested thunk
19:16:16 <dolio> I don't think GHC's implementation requires it to throw stack overflows. It just does so because it's easy to catch certain bugs that way.
19:16:44 <lpsmith> dolio, I don't think that's correct :)
19:16:45 <dolio> You can tell it to throw heap allocation errors, too.
19:16:46 <Berengal> dolio: Sounds like someone thought the same thing I did
19:17:09 <lpsmith> I'm pretty sure it has a limit to the stack, if it didn't catch the overflow, it'd start overwriting other parts of memory
19:17:42 <lpsmith> Besides,  stack overflows don't help to spot bugs
19:17:54 <Berengal> excessive lazyness is a bug
19:18:11 <dolio> They spot certain infinite loops.
19:18:32 <lpsmith> Erlang,  Chez Scheme,  Ikarus,  all have segmented stacks that won't ever overflow.   Or rather they do,  but a new stack segment is allocated and you don't have to worry about it
19:19:17 <erisco> lpsmith, is the entire stack relocated in memory or is it actually segmented?
19:19:17 <Berengal> > sum [1..1000000000]
19:19:23 <lambdabot>   mueval-core: Prelude.read: no parse
19:19:23 <lambdabot>  mueval: ExitFailure 1
19:19:29 <Berengal> > sum [1..100000000]
19:19:35 <lambdabot>   mueval-core: Prelude.read: no parse
19:19:35 <lambdabot>  mueval: ExitFailure 1
19:19:39 <Berengal> > sum [1..1000000]
19:19:41 <lambdabot>   * Exception: stack overflow
19:19:47 <SamB> dolio: fwiw, my compiler seems to agree with you
19:19:50 <Berengal> > sum [1..100000]
19:19:52 <lambdabot>   5000050000
19:20:01 <Berengal> It's a pretty deep stack...
19:20:10 <SamB> it doesn't think (i + 10 > i) is true either
19:20:10 <erisco> Berengal, indeed. I am not sure when it gives out
19:20:31 <SamB> oh ... but it does in -O2 :-(
19:20:31 <benmachine> SamB: which compiler are we talking about now
19:20:43 <SamB> why does it only do that in -O2, I wonder ...
19:20:58 <benmachine> because it's an optimisation? :P
19:21:08 <SamB> you'd think it'd be a pretty easy one!
19:21:20 <benmachine> are we talking about gcc now?
19:21:21 <SamB> anyway, it's kinda disgusting
19:21:25 <SamB> benmachine: yeah
19:21:37 <benmachine> -O2 enables -fstrict-overflow
19:22:08 <benmachine> which assumes that things don't overflow
19:22:17 <benmachine> and therefore that i + 10 > i
19:22:31 <benmachine> why is it disgusting?
19:22:55 <Berengal> If my compiler ever told me i + 10 > i = True for all i where i is a fixed precission type, I'd probably renounce pacifism and kill the compiler writer who thought it was a good idea
19:23:12 <Berengal> Presumably because I'd just spent several days figuring it out
19:23:26 <Berengal> Unless I knew about it of course, which I now do
19:23:33 <davidL> > foldl' (+) 0 [1..1000000000]
19:23:39 <lambdabot>   mueval-core: Prelude.read: no parse
19:23:39 <lambdabot>  mueval: ExitFailure 1
19:23:44 <benmachine> Berengal: if you'd told that compiler that you were courteous enough to never overflow ints then it'd be right
19:23:57 <erisco> @src all
19:23:58 <lambdabot> all p =  and . map p
19:23:58 <benmachine> Berengal: if you wanted to overflow ints occasionally then you can still do that
19:24:03 <dolio> lpsmith: "-ksize [Default: 1k] Set the initial stack size for new threads. Thread stacks (including the main thread's stack) live on the heap, and grow as required." ...
19:24:06 <benmachine> just use -fno-strict-overflow or -fwrapv
19:24:19 <dolio> lpsmith: "-Ksize [Default: 8M] Set the maximum stack size for an individual thread to size bytes. This option is there purely to stop the program eating up all the available memory in the machine if it gets into an infinite loop."
19:24:42 <Berengal> benmachine: True, but I can see it being a very painfull pit to fall into...
19:25:17 <benmachine> that I won't deny
19:25:19 <vinicius> happy user guide, heh
19:25:41 <benmachine> optimising inappropriately always produces such fun bugs
19:25:51 <benmachine> the best thing about them being they go away when you do a debug build!
19:25:58 <benmachine> what larks.
19:26:19 <SamB> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6833#a6833
19:27:07 <SamB> hmm ... my objdump got a bit confused, I think ;-)
19:28:00 <Berengal> After a few weeks of learning C, I almost considered the interpreted slowness of python/ruby to be a blessing. Things never changed between debug and production, and stuff moved so slow you could almost watch the blinkenlichts
19:28:13 <SamB> why does it even bother with the prologue if it sets eax before the end of the prologue?
19:28:34 <benmachine> so anyway just before I go to bed, can anyone help me with my Build-Depends not being found?
19:28:42 <benmachine> I have Build-Depends: base, xml
19:29:01 <benmachine> and runhaskell Setup.hs configure says xml is missing
19:29:13 <benmachine> but cabal list --installed says it isn't
19:29:29 <benmachine> is it looking in the wrong place?
19:29:44 <dolio> Is it installed in the user section?
19:29:50 <dolio> Or global?
19:29:54 <benmachine> user
19:29:59 <Berengal> runhaskell Setup only looks in the global section, unless you specify --user
19:30:04 <benmachine> ah
19:30:07 <Berengal> cabal installs in user by default....
19:30:08 <benmachine> good to know
19:30:17 <benmachine> can I change that default?
19:30:38 <Berengal> Probably some .conf in .cabal, but I dunno...
19:30:38 <dolio> You can change cabal-install's default.
19:30:42 * benmachine pokes in .cabal/config
19:30:53 <benmachine> user-install: True
19:30:58 <benmachine> reckon that might be it
19:31:15 <benmachine> yess
19:31:21 * Berengal just uses cabal-install for everything
19:32:03 <dolio> Yeah, you can actually go into a cabalized directory and type "cabal install" and it will do all its magic for the stuff in the current directory.
19:32:05 <lpsmith> berengal:  don't you have to specify the default for user installs in cabal?
19:32:14 <lpsmith> I thought the default default was a global install
19:32:22 <Berengal> Nope, user default
19:32:31 <Berengal> Except on windows...
19:32:41 <Berengal> I gather, but don't quote me on it
19:32:47 <lpsmith> I've never gotten cabal install to work quite right on windows :-(
19:33:25 <Berengal> I've never really tried
19:33:28 <lpsmith> I set cabal up to default to user installs,  but I thought the default default was global
19:33:52 <lpsmith> well, user installs that is.  Cabal install works fine if you run it as administrator
19:34:50 <Berengal> Yeah, on windows global is default, I think.
19:38:21 <benmachine> am I allowed to do this:
19:38:21 <benmachine> import qualified Text.XML.Light as XML
19:38:21 <benmachine> import XML.Input
19:38:21 <benmachine> import XML.Types
19:38:56 <benmachine> normally I'd just try it and see
19:39:09 <benmachine> but it's giving an error on the XML.Types import and not the XML.Input import
19:39:12 <benmachine> so I'm not sure
19:39:26 <mike-burns> Try expanding it to see if it works?
19:39:45 <benmachine> I can import Text.XML.Light.Types by the looks of things
19:40:07 <benmachine> oh never mind
19:40:15 <lpsmith> berengal:  do you build cabal-install yourself or use a distro package?
19:40:15 <benmachine> it errors on the first one when I expand the second
19:41:05 <Berengal> lpsmith: Currently I think I've built it myself from the platform sources, but I've used all kinds before, distro, binary, source...
19:41:09 * SamB finally figured out how not to accidentally use sudo & instead of (or in addition to) sudo -b
19:41:29 * SamB figured out that everything works great if he just uses gksudo to start X things
19:41:41 <mike-burns> What X things are you running as root?
19:41:48 <Zeiris> Is it easy to write a Windows DLL in Python?
19:41:52 <SamB> mike-burns: wireshark and emacs
19:42:03 <vyom> (newb alert) what is the best way to go about working with unicode strings in Haskell. I am using the standard String type 6.10.1 and it does not seem to recognise characters like quotes and em-dashes
19:42:18 <mike-burns> I'm not an emacs guy; is there a reason to run it as root?
19:42:29 <SamB> mike-burns: to edit things in /etc
19:42:31 <Berengal> vyom: You mean directly typed into a literal?
19:42:32 <SamB> at the moment
19:42:35 <mike-burns> Ah.
19:42:43 <mike-burns> Okay I get it now.
19:42:46 <SamB> in future, I won't have to run the entire emacs process as root to do that
19:42:53 <SamB> if what I've heard is true
19:43:01 <benmachine> what have you heard?
19:43:11 <mike-burns> I've heard that too.
19:43:16 <benmachine> I haven't :(
19:43:25 <SamB> that emacs 23 can use tramp to edit files as other users?
19:43:30 <SamB> or something like that
19:43:33 <Chile> SamB: you could also just use vi to edit things in /etc :)
19:43:40 <Chile> SamB: or sudo from the emacs shell?
19:43:49 <SamB> Chile: and do what?
19:43:55 <vyom> Berengal:  http://gist.github.com/144886 I am using this code to query a web based API and piping output to a file gives weird characters
19:43:57 <SamB> run vi *there*?
19:44:01 <Chile> sure
19:44:02 <benmachine> yes!
19:44:18 <SamB> that *would* reduce the start-up delay
19:45:37 <Chile> vi is also much better suited to editing config files than emacs, imo. though the only things I use emacs for are R & latex, to be fair.
19:45:55 <SamB> well, the downside there is I would have to learn vi
19:46:04 <SamB> ... and *remember* what I learned
19:46:08 <benmachine> hah
19:46:12 <mike-burns> All you need for /etc is i and :wq
19:46:15 <benmachine> I did the former three or four times
19:46:20 <benmachine> never quite got the hang of the latter
19:46:36 <SamB> I think I got part-way a couple of times
19:46:37 <Zeiris> Hum. Is it possible to write a Windows DLL with Haskell?
19:46:40 <Chile> % is handy for jumping braces. :<line number> for going to a line.
19:46:50 <Chile> but yeah, there's a learning curve
19:47:08 <erisco> @paste
19:47:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:47:09 <mike-burns> Well, I mean, all of vi is useful for editing files, but for just changing something quickly in /etc all you need is i and :wq
19:47:36 <Berengal> vyom: Sorry, can't help you. You sure there's no weird encoding issues going on outside of haskell?
19:47:46 <Berengal> My unicode-fu is weak
19:48:19 <Berengal> (Also, I use yi)
19:48:58 <erisco> writing this function was tricky... and I am not sure if I did it well http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6835#a6835
19:48:59 <roconnor> I wonder if American English really is the language of Computer Science, or whether that is just what American's think
19:49:19 <erisco> it has to report if there is an integer overflow or if a non-digit is reached including what that digit was
19:49:26 <mike-burns> roconnor: Are you implying that Computer Science happens outside of America?!
19:49:38 <vyom> Berengal:   I am using the JSON api from hackage.. which parse the strings from the web API and exposes it to me.. No problem will figure it out
19:49:51 <roconnor> mike-burns: yes.  I'd personally argue stronger, computer science isn't done inside the US. :P
19:50:05 <mike-burns> Ha.
19:50:10 <erisco> to do that efficiently the best thing I could find was transversing the string manually, as opposed to foldl', and causing the transversing to stop once a Left is reached
19:50:10 <roconnor> mike-burns: computer programming on the other hand ...
19:50:29 <mike-burns> As a computer programmer and non-scientist, I don't know if I'd disagree.
19:50:31 <erisco> this resulted in quite a lot of code and I am wondering if I missed something else much simpler
19:50:43 <roconnor> mike-burns: I think Dijkstra had something to say on this subject, but I haven't really found an appropriate quote.
19:52:56 <dsturnbull> regarding running emacs as root... i do this in vim: cmap w!! :!sudo tee > /dev/null %
19:53:16 <benmachine> nice
19:53:17 <mike-burns> Oh, I like it.
19:53:28 * benmachine steals
19:54:28 <dsturnbull> it doesn't reload the buffer after saving, so you have to [L]oad it again
19:54:30 <dsturnbull> but hey
20:01:14 <gwern> 'In keeping with other popular software projects, versions are named by adjectiveFurniture pairs, where successive versions (more properly termed “releases”) begin with pairs of successive letters of the English alphabet. We could not come up with the zeroth or negative first letter of the alphabet, so simply began our release names with AvariciousArmoire and documented the reason why.'
20:01:24 <mike-burns> Ha, that paper was brilliant.
20:02:03 <gwern> @remember JosephFMiklojcikIII In keeping with other popular software projects, versions are named by adjectiveFurniture pairs, where successive versions (more properly termed “releases”) begin with pairs of successive letters of the English alphabet. We could not come up with the zeroth or negative first letter of the alphabet, so simply began our release names with AvariciousArmoire and documented the reason why.
20:02:03 <lambdabot> It is stored.
20:02:09 <gwern> @flush
20:03:36 <roconnor> the first letter is really the zeroth letter
20:03:58 <gwern> 'For example, implementations of Scheme for the JVM either lack call/cc or have a very slow and slightly buggy implementation of it. We call this the Gosling Tarpit.'
20:04:05 <Berengal> > ['a'..'z'] !! 0
20:04:07 <lambdabot>   'a'
20:04:15 <gwern> roconnor: I felt my compromise of 0.5 was rejected without proper consideration
20:04:22 <roconnor> is a Tarpit a kind of furnature
20:04:24 <Berengal> gwern: @src
20:04:45 <gwern> Berengal: ACGTAAGCTAAGGCCACAAC...
20:05:27 <Berengal> gwern: I'm sorry, but I'm not really into pokemon
20:05:31 <Berengal> Nor do I speak DNA...
20:05:36 <mike-burns> Berengal: http://jfm3.org/phosphorous.pdf is the source of the quote.
20:05:39 <copumpkin> so does anyone know what the status is on context aliases that people were working on at the last hackathon?
20:05:52 <Berengal> Thanks
20:06:38 <gwern> 'It would go a lot faster if we had some research grants. I’m looking at you SPJ'
20:06:58 <Berengal> I like this paper already
20:07:40 <erisco> are there already folds define that allow the step function to indicate to abort the list transversing?
20:08:03 <erisco> if not, it is an excellent idea and I am going to redefine foldl, foldr, and foldl' with that functionality
20:08:16 <aavogt> are there algorithms for edit distances of labeled trees?
20:08:31 <Berengal> erisco: By the step function I assume you mean the function argument? If so, foldr does that
20:08:44 <erisco> Berengal, I do mean the step function argument
20:09:09 <Berengal> erisco: There's only one function argument to the folds...
20:09:27 <erisco> Berengal, for example, when parsing the int, if a non-digit occurs then I want to abort the list transversing
20:09:57 <erisco> Berengal, and return the error, and to signal this I figure I will use the Right and Left types
20:10:37 <erisco> Berengal, otherwise, if a non-int is hit, the best I can do is just have my step function do nothing while the fold continues to call it over the rest of the list
20:10:40 <roconnor> is sort stable?
20:10:41 <erisco> Berengal, and that is stupid
20:11:09 <erisco> roconnor, working on the scan?
20:11:19 <roconnor> always
20:11:39 <erisco> roconnor, I checked out the other interesting solutions. two of them need further investigation for stress testing
20:12:01 <erisco> roconnor, one implementation that seemed to work began to choke at 100 points which was pathetic, and it became quickly worse from there
20:12:18 <erisco> roconnor, the other two I cannot easily test because they nub the lists
20:12:34 <erisco> and the obvious quick thing to do is  grahamScan (take 1000000 (cycle [(0,0)]))
20:12:36 <Zeiris> erisco: doesn't foldr stop parsing a list due to laziness if a case which doesn't use the next value triggers?
20:12:40 <roconnor> nub isn't O(n)
20:12:57 <erisco> roconnor, so they finish very quickly while mine sits and works out every single point
20:13:01 <roconnor> erisco: replicate 1000000 (0,0)
20:13:14 <erisco> roconnor, that's shorter, thanks
20:13:24 <erisco> roconnor, anyways, by the time their algo starts their list is reduced to 1 element :P
20:13:29 <Berengal> erisco: take a look at the definition for foldr. It gives control to the function for each step
20:13:37 <roconnor> map head . group . sort -- this will filter out dupiclates
20:13:58 <roconnor> in O(n log n) time
20:14:23 <roconnor> but it will reorder the points :)
20:14:30 <Berengal> Set.toList . Set.fromList -- will filter out duplicates, and sort, more efficiently (but less lazily) than map head . group . sort
20:14:53 <roconnor> oh
20:15:03 <Cale> Berengal: are you sure it's more efficient?
20:15:21 <Cale> I was pretty sure that map head . group . sort was faster.
20:15:23 <Berengal> Cale: Some primitive benchmarking I did a month ago told me so, so yes
20:15:39 <roconnor> Cale: is sort stable?
20:15:46 <Cale> should be
20:15:52 <Berengal> It is
20:16:04 <erisco> Berengal, Zeiris, I do not understand how the step function could prevent further transversing of the list
20:16:28 <Berengal> > foldr (\x acc -> x) 0 [1..10]
20:16:30 <lambdabot>   1
20:16:42 <Cale> erisco: with a foldr, just don't use the second parameter and the fold stops
20:16:51 <Berengal> > foldr (\x acc -> if x == 5 then x else x + acc) 0 [1..10]
20:16:52 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
20:16:53 <lambdabot>   15
20:17:03 <Cale> So foldr immediately passes control to f
20:17:26 <Berengal> foldr is like Cont's little brother, in a way
20:17:28 <Cale> and if f doesn't pattern match on its second parameter, the recursive case is never used
20:17:53 <Cale> foldl f z (x:xs) = foldl f (f z x) xs  though
20:18:00 <jmcarthur> > foldr (\x acc -> if x == 5 then x else x + acc) 0 [1..]
20:18:01 <lambdabot>   15
20:18:08 <Cale> so foldl just passes control to foldl until the list is entirely consumed
20:18:15 <Cale> So foldl will never work on an infinite list
20:18:39 <Cale> > foldr (\x xs -> if x < 10 then x:xs else []) [] [1..]
20:18:40 <erisco> Cale, right, unless it allows for the step function to signal a stop
20:18:40 <lambdabot>   [1,2,3,4,5,6,7,8,9]
20:19:01 <Cale> erisco: Well, foldl has no such way of stopping.
20:19:06 <erisco> Cale, perhaps foldr is fine, but foldl and foldl' could be improved by allowing the step function to tell for it to stop
20:19:18 <erisco> Cale, oh, because of the laziness yes?
20:19:23 <Cale> yes
20:19:24 <erisco> Cale, but foldl' could no?
20:19:47 <Cale> Well, you'd have to change the type.
20:20:09 <erisco> Cale, that is precisely what I am considering
20:20:17 <erisco> Cale, I just ran into a case where I really need to be able to do that
20:20:23 <erisco> Cale, and if I can abstract that generically, why not?
20:20:35 <Cale> You could write a  foldlStop :: (b -> a -> (b, Bool)) -> b -> [a] -> b
20:20:58 <Berengal> Almost looks like unfoldr...
20:21:00 <Berengal> @type unfoldr
20:21:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:21:11 <jmcarthur> yeah, i think some sort of unfold on the result type would be nicer than that
20:21:33 <erisco> Cale, I guess a Bool may be more friendly than the Left and Right I was considering
20:21:57 <jmcarthur> erisco: out of curiosity, what is the result type of this particular case you have in mind?
20:22:01 <gwern> dons: I have no idea what would be a quorum on libraries@ anyway
20:22:05 <Cale> If you can, break things up so that you can use a normal foldl(') after a function which clips the list to the right length.
20:22:12 <erisco> jmcarthur, well, Either
20:22:31 <Cale> erisco: What are you computing?
20:22:37 <jmcarthur> erisco: so you're making a function of type [a] -> Either b c?
20:23:16 <erisco> jmcarthur, [Char] -> Either [Char] Int   to be specific
20:23:43 <erisco> Cale, converting a string of digits to an Int
20:23:49 <Zeiris> Does foldr traverse the list from the left, or the right?
20:23:58 <erisco> Zeiris, the right
20:23:59 <Cale> Zeiris: foldr starts at the beginning
20:24:02 <jmcarthur> Zeiris: it's right associative
20:24:16 <jmcarthur> lazily, it evaluates from the left though, you might say
20:24:44 <jmcarthur> evaluatedStuff `op` <thunk>
20:24:47 <Zeiris> jmcarthur, yes, I think that's what I'm looking for and what's been bugging me like hell lately.
20:24:48 <erisco> > foldr (^) [5,3]
20:24:49 <lambdabot>   No instance for (GHC.Real.Integral [t])
20:24:50 <lambdabot>    arising from a use of `GHC.Real....
20:24:55 <Cale> foldr f z replaces each (:) in the list with f and the [] at the end with z
20:24:56 <erisco> :(
20:25:00 <erisco> > foldr (**) [5,3]
20:25:02 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
20:25:02 <lambdabot>    arising from a us...
20:25:05 <erisco> oh wtf :P
20:25:08 <Cale> erisco: not enough parameters
20:25:13 <jmcarthur> base case
20:25:20 <erisco> Cale of course
20:25:31 <pikhq> > foldr (^) 1 [5,3]
20:25:31 <mike-burns> :t foldr
20:25:33 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:25:34 <lambdabot>   125
20:25:36 <erisco> > foldr (^) 1 [5, 3]
20:25:38 <lambdabot>   125
20:25:41 <erisco> and beat me to it :P
20:25:47 <Zeiris> Because if lists are unidirectionally linked, evaluating from the right seems dumb since you have to traverse the entire list to start evaluation. But if foldr builds a lazy sequence of evaluations that start from the left and progress to the right, lazily, that makes so much more sense.
20:25:49 <Cale> > foldr f z [a,b,c,d]
20:25:51 <lambdabot>   Ambiguous occurrence `f'
20:25:51 <lambdabot>  It could refer to either `L.f', defined at <local...
20:25:59 <Cale> @undefine
20:26:02 <Cale> > foldr f z [a,b,c,d]
20:26:04 <lambdabot>   f a (f b (f c (f d z)))
20:26:11 <Zeiris> In which case the 'r' in 'foldr' refers to the function being applied from the right: but the actual execution occurs from the left, as you'd expect!
20:26:34 <Cale> @src foldr
20:26:35 <lambdabot> foldr f z []     = z
20:26:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:26:42 <jmcarthur> Zeiris: yeah you have the idea
20:26:55 <Zeiris> Only took me a few weeks.
20:27:02 <Cale> As you can see, foldr on a nonempty list immediately applies f to the *first* element of the list (and the foldr of the rest)
20:27:08 <erisco> Cale, I cannot split it into a case that clips the list
20:27:17 <erisco> Cale, that just wouldn't make sense unfortunately
20:27:23 <Cale> So f gets evaluated next
20:27:42 <Cale> erisco: um, why is it that you need a way to stop?
20:27:55 <jmcarthur> parse failure, i assume?
20:27:58 <Berengal> foldr is like for loops, only they go backwards
20:28:03 <erisco> Cale, if there is an Int overflow I need to stop, if I hit a non-digit I need to stop
20:28:10 <roconnor> @src uncurry
20:28:10 <lambdabot> uncurry f p = f (fst p) (snd p)
20:28:13 <roconnor> @src curry
20:28:14 <lambdabot> curry f x y = f (x, y)
20:28:30 <Cale> erisco: oh, also, is there a reason not to use reads?
20:28:42 <Cale> > reads "7218971apple" :: [(Integer, String)]
20:28:44 <lambdabot>   [(7218971,"apple")]
20:28:57 <erisco> Cale, yes, because this is a specific exercise from the book
20:29:00 <Cale> ah, okay :)
20:29:07 <erisco> yeah.. same old excuse :P
20:29:19 <davidL> > reads "7218971apple" :: [(Integer, Char, String)]
20:29:20 <lambdabot>   Couldn't match expected type `(GHC.Integer.Internals.Integer,
20:29:24 <Cale> That's interesting about Int overflow...
20:29:33 <Cale> > read "47389104573819057158190" :: Int
20:29:34 <lambdabot>   -580951540780943314
20:29:39 <erisco> heh
20:29:41 <jmcarthur> Integer ftw!
20:29:57 <Cale> Int is broken anyway, I wish it weren't so common.
20:30:06 <Berengal> I should write a haskell tutorial exercise sheet
20:30:07 <Cale> > read "47389104573819057158190" :: Integer
20:30:09 <erisco> Cale, well, there you go, mine, thanks to benmachine for the technique, reports safely that there was an overflow
20:30:09 <lambdabot>   47389104573819057158190
20:30:10 <jmcarthur> i wish it didn't exist
20:30:15 <jmcarthur> we have Int32 and Int64 anyway
20:30:22 <jmcarthur> at least that is well defined
20:30:29 <uman> how big can "integer" get before overflowing?
20:30:32 <Berengal> "Implement these functions" ++ the Prelude function types
20:30:35 <erisco> Cale, but Int overflow hasn't seemed to of been defined anywhere so whether it wraps or generates an error on all cases I don't know
20:30:44 <uman> on GHC on a 32-bit Linux machine, in case it's implementation dependent
20:31:07 <dolio> Integer doesn't overflow.
20:31:11 <uman> ever?
20:31:15 <Cale> ever.
20:31:16 <Berengal> Integer only overflows your stack/heap
20:31:24 <Cale> It will consume all your memory before overflowing.
20:31:30 <erisco> uman, Integer does not overflow, Int does at maxBound :: Int
20:31:35 <uman> ok
20:31:40 <erisco> this is why Integers are slow
20:31:43 <erisco> :(
20:31:46 <Cale> They're not slow though.
20:31:46 <Berengal> "slow"
20:31:55 <uman> erisco: basically everything on computers is fast
20:31:57 <Stinger> integers overflow at oom
20:31:59 <Cale> Integer uses an Int so long as it's small enough.
20:32:13 <erisco> Cale, get out
20:32:21 <Berengal> @src Integer
20:32:22 <lambdabot> data Integer = S# Int#
20:32:22 <lambdabot>              | J# Int# ByteArray#
20:32:26 <erisco> Cale, well why is Int used at all then
20:32:42 <Cale> It's only a little bit slower for having to do a test for overflow.
20:32:51 <Zeiris> Cale, there's gotta be significant overhead from checking if it's 'big enough', though, ain't it?
20:32:53 <Cale> Int avoids that test.
20:32:56 <Berengal> Int is the basis for Integer
20:32:56 <uman> erisco: I assume there is some overhead because it has to check every time you modify it that it isn't overflowing
20:33:04 <Cale> Zeiris: a little, but not so much that you'd normally care
20:33:07 <Zeiris> Bah beaten. And wouldn't that test be significant when integer operations are generally very fast?
20:33:11 <ColeSOAR> Int is historical and fast?
20:33:13 <uman> erisco: like asking why is std::vector slower than an array in C++
20:33:23 <uman> erisco: when it uses an array internally
20:33:37 <erisco> makes sense
20:33:45 <uman> assuming you know C++
20:33:49 <erisco> I did not think about the overflow check
20:33:59 <Berengal> Well, Int#
20:33:59 <Berengal> Which I assume is pretty much the same
20:34:07 <Cale> Int is so that your programs can make mistakes a bit faster.
20:34:21 <erisco> uman, well I know a bit of C, and I am presuming vector is a variable length array, aka it has to check to see if you are trying to stuff too much into the array and allocate new space if you are
20:34:28 <erisco> uman, but that is my guess
20:34:29 <Zeiris> Someone should specify that in the fold diagrams in the wiki, execution occurs from left to right. Would make them much clearer, imo.
20:34:29 <jmcarthur> how about Int vs. Int32 or Int64?
20:34:32 <jmcarthur> how is performance there?
20:34:36 <uman> erisco: spot on
20:34:47 <Cale> jmcarthur: Int will always be the one which is faster for your machine
20:35:12 <jmcarthur> Cale: but Int is literally just one of Int32 or Int64? (at least for GHC, of course)
20:35:30 <Berengal> Int is at least 29 bits, last I checked...
20:35:30 <Cale> jmcarthur: Yeah, I'm pretty sure.
20:35:34 <Cale> Right.
20:35:39 <Cale> The standard is much more lax.
20:35:41 <jmcarthur> by the spec
20:35:56 <Berengal> I'm just being pendantic...
20:36:08 <dolio> Technically, on 64-bit systems, all the IntN are "data IntN = IN# Int#", same as Int.
20:36:10 <Cale> > maxBound :: Int
20:36:12 <lambdabot>   9223372036854775807
20:36:16 <dolio> The difference is the functions on them.
20:36:19 <uman> this plays feels more like ##C than last time I was in here
20:36:30 <uman> "No, the standard only says that..."
20:36:43 <uman> Berengal: not that that's a bad thing ;)
20:36:51 <dolio> In GHC, that is.
20:36:57 <Berengal> I usually dislike standards...
20:37:01 <Cale> uman: Well, we do have a standard. It's getting kind of old and irrelevant at this point though.
20:37:07 <Berengal> (Haskell ones are good)
20:37:25 <dolio> Same for N up to 32 on 32-bit systems. I'm not sure how it does Int64 there, though.
20:37:26 <uman> Cale: when was it published?
20:37:33 <Cale> 1998-1999
20:37:51 <Berengal> I want a standard standard that mandates a page full of jokes every third page
20:37:51 <uman> eh, the latest C standard was published in 1999
20:38:12 <Berengal> Or otherwise funny stories, koans, poems, what have you
20:38:31 <Cale> uman: Yeah, but almost all of the real Haskell code in existence now uses extensions which Haskell98 doesn't mention.
20:38:43 * Berengal has dredged through JAX-WS and WSDL standards for the last time
20:39:04 <uman> ah, I see
20:40:46 <aavogt> the FFI is slightly newer addition to the specification
20:40:58 <aavogt> @where FFI
20:40:59 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:41:31 <aavogt> from 2002 / 2003
20:47:53 <erisco> Cale, see this is what I mean: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=6840#a6840
20:48:25 <Cale> erisco: right
20:49:02 <erisco> Cale, does that make sense or is it better to do this a different way?
20:49:09 <Cale> That makes sense
20:49:36 <erisco> Cale, thanks. and thanks for the function name :)
21:01:11 <uman> "Learn You a Haskell" strikes me as somewhat condescending
21:01:21 <uman> "If you've ever taken a course in mathematics, you've probably run into set comprehensions"
21:01:35 <uman> as if thirteen years of public school doesn't count as "courses in mathematics"
21:02:07 <IntergalacticOwl> i think "course" is meant to mean "university course"
21:02:21 <IntergalacticOwl> since public school isn't usually organised into "courses"
21:02:27 <uman> hm
21:02:46 <idnar> are they really called "set comprehensions"?
21:02:53 <erisco> IntergalacticOwl, well, high school where I am from is run with courses
21:02:54 <uman> idnar: I've never heard that term
21:03:00 <idnar> uman: yeah, me either :P
21:03:13 <uman> I've heard "set building notation" or something similar
21:03:46 <dolio> I seem to recall seeing set comprehensions in freshman algebra.
21:03:49 <erisco> IntergalacticOwl, and set theory in my data management course did not cover "set comprehensions"
21:04:00 <Cale> uman: I learned about set comprehensions in grade 10 or 11 or something.
21:04:11 <uman> Cale: not in the United States?
21:04:14 <Cale> (poorly, mind you, but the notation was used)
21:04:17 <Cale> Canada
21:04:17 <erisco> Cale, do they go by a different name perhaps?
21:04:31 <erisco> Cale, I am in Canada as well =\
21:04:39 <uman> Cale: well US schools are terrible as you probably know
21:04:48 <dolio> I went to school in the US.
21:04:53 <Cale> {x : x > 4 and x <= 17} -- ever seen anything like that?
21:04:59 <uman> but the point is, even before 10th grade, you had "taken courses in mathematics"
21:05:05 <meanburrito920_> US schools win.
21:05:16 <erisco> Cale, that is what we call the domain
21:05:30 <Cale> erisco: er... that's a bad name for it.
21:05:35 <erisco> Cale, yeah, it must be
21:05:45 <Cale> It *could* be the domain of a function.
21:05:48 <Cale> But it's just a set.
21:05:49 <uman> erisco: the example this tutorial gives is S = {2x | x (epsilon) N, x <= 10 }
21:05:50 <aavogt> same as Cale, I had also seen the notation for describing function domains
21:06:05 <uman> erisco: which would be the set {20, 22, 24, ...}
21:06:27 <uman> erisco: which is not the domain of any function you're likely to have seen in 10th grade"
21:06:43 <uman> oh whoops, I misread what I just wrote
21:06:47 <erisco> uman, heheh, well I understand everything except for what 2x would cause
21:07:02 <erisco> uman, is that saying that the resulting x's on the right of the pipe are doubled?
21:07:13 <uman> it's actually the set {0, 4, 8, 12, 16, 20}
21:07:25 <Cale> {p in the US population | p is a person who has not heard of set comprehensions}
21:07:30 <erisco> uman, 0 is not a Natural number
21:07:31 <uman> if you consider N to include 0
21:07:43 <uman> erisco: some books consider it to include 0, some do not
21:07:46 <uman> erisco: there's no standard
21:07:49 <erisco> uman, that is ridiculous :P
21:07:56 <Cale> erisco: Yes it is.
21:08:49 <erisco> I am not sure how to read that though. is it saying 2, 4, 6 .. 20?
21:08:53 <jmcarthur> afaik, most CS people consider 0 to be in N
21:08:58 <Cale> At least, by most accounts. There are still a few number theorists who prefer to leave 0 out, but it's few enough now that it's considered a bit strange.
21:09:03 <uman> god damn I am bad at math today
21:09:13 <erisco> jmcarthur, but that is what the Whole numbers are for, that set includes 0
21:09:14 <Cale> Of course, there really is no standard.
21:09:17 <jmcarthur> outside of CS could be more controversial maybe
21:09:22 <uman> erisco: third try. It's {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20}
21:09:31 <jmcarthur> erisco: i know, i was taught the same thing in math
21:09:47 <erisco> uman, yeah, that is what I would have figured. mind you I have not seen anything applied to the x on the left before
21:10:05 <erisco> jmcarthur, I wasn't, I was taught the reverse, that Naturals had 0 and Wholes did not :P
21:10:10 <Cale> erisco: The "whole numbers" is as far as I know something that highschools decided to make up rather than a term that actual mathematicians use :)
21:10:10 <uman> erisco: yeah the general form is {f(x) | x (epsilon) some set}
21:10:41 <Cale> If you want to be clear, the terms "positive integer" and "nonnegative integer" are handy.
21:10:56 <Cale> Usually I like natural numbers to correspond to the sizes of finite sets.
21:10:58 <erisco> Cale, well, if you consider Whole = positive integer then yeah
21:11:17 <erisco> Cale, I guess that is the ambiguity then, Whole number was just made up, so whether Natural needs to cover 0 or not is ambiguous
21:11:18 * SamB wishes there were a two-symbol way to write nonnegative integer
21:11:22 <uman> erisco: "positive integer" is understood the same by every mathematician
21:11:45 <SamB> yeah, positive means >0
21:11:47 <erisco> SamB, /-I? (presuming the cross is through the minus) would be my suggestion :P
21:11:56 <uman> erisco: "natural" is not, but writers specify whether 0 is included if it is not obvious from context
21:11:57 <aavogt> what's annoying is that sometimes that it is  { bleh : x (epsilon) xs }
21:12:15 <aavogt> there's no difference between | and :, right?
21:12:21 <Cale> positive integers are {1,2,3,...}, nonnegative integers are {0,1,2,...}, and normally the naturals are the nonnegative integers.
21:12:27 <uman> erisco: "Whole number" is not a mathematical term at all
21:12:30 <erisco> aavogt, not that I know of... I could easily be wrong
21:12:35 <dolio> Sometimes it's { x \in set | predicates }.
21:12:39 <erisco> uman, I know, that is what me and Cale are discussing :)
21:12:45 <uman> erisco: okay
21:12:48 <uman> I'm bad at IRC
21:12:58 <Cale> This became the mostly-standard definition of the naturals sometime around 1890 when everyone realised that set theory was important.
21:13:41 <Cale> Unfortunately, highschools are in some kind of limbo mixture of views from the 1600's and broken nonsense.
21:14:05 <bremner> sounds like sex-ed
21:14:14 <uman> Personally I think the problem stems in large part from students being forced to take mathematics
21:14:29 <SamB> Cale: and apparantly russian topologists are, too
21:14:45 <erisco> uman, I have kind of felt the same... at least with the way they present it over here
21:14:45 <SamB> at least, some of them are
21:14:53 <uman> you just get a chorus of "when are we ever going to use this?", as if mathematics cannot be interesting apart from its usefulness
21:14:53 <Cale> SamB: Oh, that's interesting. They don't like 0 to be a natural number?
21:15:16 <SamB> Cale: well, the one I had for discrete was very adament about it, yes
21:15:21 <erisco> uman, it is hard to treat everyone as an aspiring young mathematician when really the majority are there for compulsory credits or uni/college pre-reqs
21:15:32 <kulakowski> Topologists in general aren't the best at consistently naming things.
21:15:40 <erisco> uman, so overall it just brings disaster to the entire class
21:15:47 <uman> erisco: of course
21:15:57 <uman> erisco: which is why people should not be forced to study mathematics
21:16:02 <inimino> uman: do you disagree with compulsory education in general?
21:16:22 <uman> inimino: no, but I think it should be better tailored to students' personal needs and aspirations
21:16:30 <SamB> ea
21:16:35 <SamB> er
21:16:35 <SamB> y
21:16:41 <uman> I like the French system a lot
21:16:48 <SamB> yea
21:16:53 <erisco> uman, we have a course called "Everyday Mathematics" and I think that'd be a better compulsory with the option of upgrading to a more in-depth math course
21:16:57 <uman> which seems to be very similar to how much of Europe does it
21:17:00 <Cale> I think that what the highschools currently teach as far as mathematics goes is in many ways worse than nothing at all
21:17:00 <inimino> I'm not familiar with it
21:17:00 * SamB i
21:17:06 <uman> although I can't speak for the rest of Europe since I don't know as much
21:17:11 <Cale> It makes people think that they've had exposure to mathematics.
21:17:22 <uman> Cale: yes
21:17:28 <uman> Cale: I feel the same
21:17:35 * jmcarthur agrees as well
21:17:35 * SamB is having issues getting his input in x-chat not be sent prematurely
21:17:43 <erisco> Cale, ugh... tell me about it... anything significant I have understood about mathematics has been taught by myself on my own time
21:17:50 <aavogt> well, isn't it an exposure?
21:17:52 <uman> inimino: in France there is compulsory education until age 16, but not everyone is pushed through the college-prep track. In fact only about a third of students are
21:18:09 * SamB apparantly has to type everything in urxvt instead to avoid this
21:18:15 <inimino> uman: I see
21:18:17 <uman> inimino: after middle school, those who choose to begin vocational education
21:18:19 <erisco> Cale, and I have books that I am trying to read on fundamental mathematics so that I can actually get a grasp of what it is I'm doing... but, see, things like learning Haskell come up and... no time for reading math books :P
21:18:45 <uman> inimino: and even within the general, academic, college-prep track, it's further divided into literary, economic and social sciences, and hard sciences
21:19:06 * SamB also does not want people to be forced to learn math -- mostly because they tend to end up in his class with the result that it is much more boring
21:19:06 <uman> the literature people still have to take math and the science people still have to take philosophy, for example
21:19:25 <uman> but much much less than the people in the other specialty
21:19:28 <uman> if that makes sense
21:19:47 <Cale> aavogt: In a similar way that paint by numbers (where you are graded on how well you stay in the lines) is an exposure to painting.
21:19:48 <inimino> uman: I can see where that would have some benefits but it seems to ask kids to make really important choices much earlier
21:19:49 * SamB however admits that perhaps less of them should be majoring in electrical engineering
21:20:03 <inimino> Cale: haha, yes
21:20:07 <uman> a girl I know in "Terminale L" (last year of education in the Literature/languages track) had 8 hours of philosophy a week I think
21:20:20 <uman> inimino: very true, but if you change your mind usually you've only lost a year
21:20:27 <uman> inimino: and university will take you four years instead of three
21:20:28 <d3z> mtl question: If I want a Reader+State+IO should I build that out of ReaderT and StateT or would RWST be better and not use the writer?
21:20:49 <inimino> uman: ah, that's not so bad then
21:21:22 <Cale> aavogt: Or drawing dots on paper with lines on it is an exposure to music, for people who have never heard it. (and you'd better make sure you draw the stems the right way!)
21:21:36 <SamB> Cale:
21:21:42 <uman> obligatory
21:21:43 <uman> http://www.maa.org/devlin/LockhartsLament.pdf
21:21:43 <SamB> well
21:21:45 <uman> (sorry for PDF)
21:21:48 <inimino> uman: well it sounds good, I think one of the biggest problems (if not the biggest) with US schools is students who would rather be anywhere else
21:21:51 <Cale> uman: yeah, I was about to post that too
21:22:19 <erisco> Cale, I took piano for 6 years before quitting from lack of interest, but when I took music (compulsory) in high school it was a flipping joke...
21:22:20 <uman> inimino: yeah, really it's a waste of time for everyone
21:22:22 * SamB tries turning off input methods in x-chat ... ah, that seems to have worked ...
21:22:29 <aavogt> I believe that I've seen those arguments before too
21:22:34 <Cale> d3z: I would go with ReaderT and StateT separately
21:22:43 <Cale> d3z: RWST's existence is strange.
21:22:45 <erisco> Cale, and when I took gr11 comp sci it was a joke... so, yeah, the analogies are well spelt out for me :P
21:22:54 <SamB> Cale: they had better not put flags on the stems if they don't want to draw 8th/16th/etc. notes
21:22:54 <uman> inimino: no point teaching people who will not go to college academic subjects... usually they don't want or need to learn them and if they have a special interest in something like history or math they can read books in their own time. No sense forcing it on them. So their time is wasted
21:23:09 <d3z> Cale: Thanks.
21:23:21 <uman> inimino: and the college-bound waste their time too since it's all dumbed down to the lowest common denominatort
21:23:34 <Cale> erisco: Fortunately we had really pretty good art and music classes in my highschool.
21:23:38 <uman> hence the popularity of things like AP classes
21:23:48 <inimino> uman: yes, fully agreed on both points
21:23:51 <uman> which are actually less difficult than French "regular" high school classes in the academic track
21:23:59 <SamB> uman: and home-schooling ;-)
21:24:04 <erisco> Cale, cool. Our art/music teacher is really good herself its just the curriculum that takes you nowhere
21:24:16 <SamB> I actually learned real mathematics, I think
21:24:16 <uman> disclaimer, I only went to school in France for one year, tenth grade
21:24:31 <uman> but I've read enough about it and heard enough stories from people who've gone through it to be pretty sure of what I'm saying
21:24:40 <SamB> erisco: why does she use a curriculum?
21:24:48 <inimino> SamB: yes, that's the route I took for most of it :-)
21:24:50 <erisco> SamB, because she has to
21:24:57 <SamB> erisco: that seems kind of wierd
21:25:07 <SamB> why not just ... do ... pieces?
21:25:17 <SamB> and art projects?
21:25:25 <uman> because it's fucking American schools my friend, don't try to understand
21:25:25 <erisco> SamB, there is a curriculum that must be followed. The teacher can present it how they will, but all areas must be completed
21:25:48 <inimino> usually the school board approves the curriculum
21:25:49 <SamB> just, uh, paint on the curriculum
21:25:49 <Cale> I would recommend Michael Spivak's "Calculus" to anyone who wants to learn mathematics properly. I think that if you took the first 100 pages or so, it covers almost everything of importance from highschool in much better clarity.
21:25:49 <uman> the United States is one of the richest countries in the world, and educational performace is in about the 50th percentile of all countries
21:25:50 <inimino> and following it is a condition of your employment
21:25:53 <uman> how does that make sense
21:26:05 <uman> Cale: haven't read it, but I read Apostol's "Calculus", which I also highly recommend
21:26:12 <Cale> uman: Yes, that's also good.
21:26:25 <SamB> paint it too look like it is covered in blood
21:26:27 <uman> changed my mind about what I wanted to major in
21:26:33 <SamB> er. s/too/to/
21:26:38 <uman> from CS to math
21:26:42 <uman> (I'm starting university this fall)
21:26:44 <SamB> uman: good idea
21:26:49 <inimino> uman: I think it's because there is so much pressure and kids that have potential end up losing interest...
21:26:59 <erisco> Cale, I have John Stillwell's Numbers and Geometry. I also heard Michael's Calculus book recommended to me
21:27:00 <SamB> CS is waaay too easy, I think, and EE isn't hard enough either
21:27:07 <inimino> has anyone else read about free schools?
21:27:18 <SamB> inimino: sounds like some buzzword
21:27:21 <uman> SamB: I'm probably going to do a minor in CS. The U. of Arizona requires a minor in any subject for math majors
21:27:25 <uman> for whatever reason
21:27:28 <erisco> inimino, to me, schooling is free, because I am autodidactic :D
21:27:32 <uman> I might do it in Chemistry instead though, because I like that
21:27:43 <bgs100> @src lookup
21:27:44 <lambdabot> lookup _key []          =  Nothing
21:27:44 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
21:27:44 <lambdabot>                         | otherwise = lookup key xys
21:27:48 <inimino> SamB: it's not really a buzzword, kind of a movement
21:27:49 <SamB> uman: what do they require you to take to minor in CS?
21:27:56 <uman> SamB: hold on I'll look
21:28:05 <SamB> inimino: oh, I might have actually liked that then
21:28:43 <Cale> It's unfortunate that more universities don't have a Faculty of Mathematics like Waterloo does :)
21:28:54 <SamB> college would be way more fun without all these pesky classes
21:29:09 <SamB> hardly leaves any time to learn :-(
21:29:17 <inimino> http://en.wikipedia.org/wiki/Free_school
21:29:21 <Cale> Mathematics usually ends up getting lumped in with science or arts, which are almost equally inappropriate.
21:29:24 <uman> SamB:
21:29:27 <uman> sorry
21:29:31 <uman> SamB: http://aprr.web.arizona.edu/data-minors/094/DPUxMINxCOSCxxx.html
21:29:36 <erisco> roconnor, how is the algo coming?
21:29:37 <uman> that's what I'd have to parse to answer your question :(
21:29:59 <roconnor> erisco: haven't touched it.  I'm pretty happy with what I have, even if it isn't perfect
21:30:03 <Cale> Also, it means that you can have CS be part of the mathematics faculty which is nice :)
21:30:11 <uman> lol at first glance it looks like SQL
21:30:28 <mike-burns> Ha.
21:30:42 <Elly> CS and mathematics are the same field anyway
21:30:43 * Elly ducks
21:31:01 <roconnor> CS is math
21:31:02 <Cale> CS is a branch of mathematics :)
21:31:06 <roconnor> math is philosophy
21:31:07 <SamB> uman: that reminds me, I wish colleges would provide their course catalogs in database form
21:31:37 <uman> SamB: I wish everything about UA's online interface weren't completely broken
21:31:53 <SamB> though this looks a lot easier to parse than a PDF
21:32:05 <uman> SamB: evince would disagree
21:32:14 <SamB> or, worse, dead tree form
21:32:27 <uman> SamB: most of the departments have stuff like that on their website
21:32:45 <uman> SamB: CS does not for whatever reason, they just link to that semi-human-readable page in the catalog
21:33:15 <SamB> uman: I meant if you wanted to convert to a form you could apply magic scripts to
21:33:26 <uman> oh
21:33:39 <uman> well I assume that's meant to be machine-readable
21:33:56 <uman> but I personally have no use for my minor requirements being in machine-readable form
21:34:06 <Cale> http://farm3.static.flickr.com/2505/3708756366_c2599e574b_o.jpg -- haha
21:34:08 <SamB> too bad it doesn't come with a script to insert the descriptiosn
21:34:29 <uman> SamB: you'd have to do some major screen scraping to write one
21:34:32 <SamB> uman: oh, well, they should probably add having a use for it to the requirements of the minor
21:34:39 <coCocoa> Greetings, all.
21:35:04 <SamB> uman: not if you could download the whole catalog in .txt format
21:35:16 <uman> SamB: sadly you can't
21:35:22 <SamB> that IS sad :-(
21:35:35 <coCocoa> uman: I wouldn't be surprised if there isn't something already available for processing that link...in Icon, even! ;)
21:37:30 <uman> ugh, my friend just called me to ask me "what are cookies"
21:37:39 <coCocoa> Ooh, Bill Griswold is a prof at UCSD, I should totally ask for an autograph! :)
21:37:49 <SamB> uman: tell him they are delicious and you aren't giving him any
21:37:58 <uman> s/im/er/
21:38:03 <SamB> oh.
21:38:09 <SamB> well, maybe don't, then
21:38:09 <erisco> roconnor, that's fine. If one of the other two implementations I found is correct and is at least as fast as mine, then we will have found the really short version
21:38:16 <SamB> why did she call you to ask you that?
21:38:20 <roconnor> mine is almost correct
21:38:31 <uman> SamB: some site she tried to go to on her phone told her it required cookies
21:38:40 <SamB> uman: oh
21:38:46 <SamB> I thought she was being facetious
21:38:52 <erisco> roconnor, but I cannot test it as of yet... and neither has a toggle to include or exclude the boundary points... so imo they are not as complete
21:38:54 <mike-burns> The iPhone doesn't have a slot for inserting freshly-baked cookies, sadly.
21:38:58 * SamB always thinks of the delicious kind
21:39:02 <uman> it required JS too. I doubt she knows what that is, but she basically just knows it's a magic thing she has to turn on in her phone browser sometimes
21:39:07 <SamB> mike-burns: happily
21:39:14 <SamB> would be a waste of cookies
21:39:14 <uman> basically the same way I am with cars :)
21:39:29 <uman> mike-burns: she's on a blackberry, not iphone. Probably shittier
21:39:38 <erisco> roconnor, so when I learn how to do IO in Haskell I will generate a million unique points and do the scan on it with all three algo's and see if any stack overflow or take forever to complete or whatever
21:39:51 <mike-burns> I hear the BlackBerry has great support for chocolate chip and sugar cookies, but not for oatmeal.
21:39:54 <SamB> uman: why would something with that reputation be shittier?
21:39:57 <bgs100> night
21:40:01 <roconnor> erisco: ok
21:40:25 <uman> SamB: eh, where I come from, iPhone has a much better reputation than Blackberry
21:40:26 <SamB> I mean, blackberry is a proven, well-respected brand
21:40:39 <uman> SamB: yes but its "killer app" is e-mail, not browsing
21:40:46 <erisco> roconnor, night, and thanks for working with me on the scan problem
21:40:52 <SamB> iPhone came from the same logic as iMac
21:40:55 <erisco> good night all
21:41:09 <mike-burns> Where I come from the BB has a better rep.
21:41:12 <uman> SamB: 150% markup on commodity hardware?
21:41:14 <uman> :D
21:41:15 <SamB> uman: true, the blackberry brand is renowned as an email device
21:41:31 <SamB> but it's more established, period
21:41:38 <uman> SamB: you may have never used it, but the blackberry browser is a piece of shit
21:41:51 <SamB> uman: heck, I'd like that
21:41:53 <uman> SamB: C is more established than Haskell ;)
21:41:55 <mike-burns> I tried the iPhone browser and if the BB's is worse then I feel quite sorry for BB users.
21:41:56 <SamB> it'd sure beat my $10 phone
21:42:01 <uman> SamB: probably
21:42:18 <uman> those Google phones probably have the best browsers
21:42:18 <SamB> my $10 phone has text messaging, and that's about it
21:42:27 <SamB> ... oh, it *does* take calls
21:42:32 <uman> I have no evidence for that, but I'm just assuming, because it's Google
21:42:34 <mike-burns> uman: My G1's browser is pretty great.
21:42:53 <SamB> uman: hopefully it's a little slimmer than Chrome
21:42:58 <SamB> not that Chrome isn't slim
21:43:10 <uman> those G1s are really cool
21:43:17 <mike-burns> I highly recommend the G1.
21:43:21 <uman> fact is I got the BB Curve for my birthday, and would not have spent my own money on it
21:43:23 <SamB> just, you know, I don't think Chrome is *that* slim
21:43:30 <uman> I'm simply at a computer most of the time
21:43:46 <uman> and when I'm not, I usually have no occasion to use phone browsing for anything more than looking up a fact
21:43:55 <uman> I don't really need AJAX on my phone or whatever
21:44:10 <mike-burns> When I go away for the weekend I leave my laptop at home and depend entirely on my G1.
21:44:14 <SamB> anyway, about the only thing my phone has to do with the 'net is I can tweet from it
21:44:35 * coCocoa thinks Ajax on a phone sounds pretty clean...unless you mean "that Other Ajax"...
21:44:49 <inimino> Lockhart's Lament is great
21:45:02 <SamB> I can also get weather from google ... and supposedly I can add things to my google calender but I *always* screw up the syntax for that and create wierd events
21:45:21 <coCocoa> inimino: Ain't it, though? I shared it with a friend of mine, who's a HS math teacher.
21:45:25 <SamB> coCocoa: I don't think the cleaning agent is safe on phones
21:45:44 <uman> SamB: well the web technology isn't safe on computers
21:45:47 <coCocoa> SamB: Heh-heh. :)
21:45:50 <inimino> coCocoa: what did they think of it?
21:46:05 <SamB> actually, I bet the cleaning agent isn't safe on computers either
21:46:15 <uman> not from a security standpoint, but just because it's so fucking lame
21:46:31 <SamB> uman: it's not THAT lame
21:46:45 <mike-burns> AJAX is insecure?
21:46:48 <inimino> it's fairly safe :)
21:46:56 <uman> SamB: obviously you've never tried to debug someone else's AJAX
21:47:02 <coCocoa> inimino: Oh, she pretty much agreed with it. She doesn't know what to do to change it, however, since she just picked up a Master's degree, she may be able to do something locally. :)
21:47:06 <uman> mike-burns: I specifically said I did not mean from a security standpoint
21:47:16 <mike-burns> Oh, I misread.
21:47:17 <SamB> uman: oh, well, maybe
21:47:30 <SamB> but mostly I put it down to Firebug sucking
21:47:35 <SamB> though it's mighty cool
21:47:37 <mike-burns> Anyway, I debug other people's AJAX without too many issues.
21:47:48 <inimino> coCocoa: ah, yeah it's hard to know what an individual can do
21:47:56 <uman> SamB: especially when 90% of your time is spent debugging a minified and obfuscated JS file from a buggy but mission-critical third-party library
21:48:00 <SamB> it just doesn't make it nearly easy enough to set breakpoints in some situations
21:48:05 <SamB> uman: ah
21:48:09 <inimino> minification is evil
21:48:16 <SamB> uman: you shouldn't use closed-source libraries like that
21:48:19 <mike-burns> Minification is necessary on the Internet.
21:48:26 <uman> SamB: AND when the only knowledge of JavaScript you have comes from picking it up on your own, on the job, for the past month or so
21:48:29 <uman> SamB: not up to me
21:48:48 <inimino> mike-burns: nonsense, we have gzip
21:48:49 <SamB> the thing is, you're supposed to have minification turned off for debugging
21:48:55 <uman> mike-burns: indeed, but I asked them for an unobfuscated version and they refused, and also warned me I better not be reverse engineering their shit
21:49:04 <uman> which I ignored of course
21:49:05 <mike-burns> uman: Ah, that sucks a lot.
21:49:12 <uman> they shouldn't have made buggy shit if they didn't want me debugging it
21:49:21 <SamB> uman: you should have told them that in that case, you needed them to come and help you debug it
21:49:23 <mike-burns> I'm not allowed to use proprietary JS at my job, for that reason.
21:49:48 <inimino> you shouldn't have been using it :/
21:49:48 <uman> mike-burns: it's the client-class component associated with an ASP.NET control
21:49:55 <uman> the .NET parts are luckily less buggy
21:50:11 <uman> inimino: again, not up to me
21:50:20 <mike-burns> Yeah, I hear that. Harsh.
21:50:22 <SamB> uman: where the heck do you work?
21:50:43 <SamB> you don't work with Dilbert, do you?
21:51:02 <SamB> 'cause that sounds just like his working conditions ;-)
21:51:14 <uman> no my workplace is pi radians from Dilbert's
21:51:47 <uman> there are less than 15 people who work there in all, partners and employees included
21:52:17 <SamB> so ... in a company that size, how the heck did you get stuck with such buggy proprietary shit?
21:52:51 <uman> SamB: the component is a control to view TIF images in an ASP.NET page
21:53:03 <uman> and provides zooming, panning, image processing effects, etc.
21:53:13 <mike-burns> All in JS?
21:53:20 <uman> mike-burns: god no
21:53:21 <uman> thank god
21:53:28 <uman> most of that is in a .net assembly
21:53:46 <uman> the JS file is just the browser-facing side
21:53:56 <mike-burns> Okay that makes more sense.
21:54:38 <uman> SamB: you think in a company that size, the majority of whom are not programmers, they could've rolled their own? ;)
21:55:05 <mike-burns> uman: How many programmers work there?
21:55:09 <uman> the license for the library is like $1000, it'd have cost them more in developer time to reimplement the needed functionality
21:55:49 <uman> mike-burns: one full-time programmer, one partner who spends part of his time managing and part of his time programming, and two interns hired because of nepotism (one of whom was me)
21:56:11 <uman> nepotism is a stupid reason to hire someone, but I think I may flatter myself by saying that in my case they are definitely getting their money's worth
21:56:35 <uman> (since I make $7.50/hr, that's not saying much ;P)
21:56:39 <mike-burns> Heh.
21:57:00 <mike-burns> That's about what I made at my first programming gig.
21:57:16 <uman> mike-burns: your first programming gig was likely not in 2009 though
21:57:25 <uman> eh, can't complain... it was that or McDonald's
21:57:39 <mike-burns> At least you're coding.
21:57:40 <uman> in this I get free coffee, get to sit in a nice chair, and obviously it's better for the resume
21:58:43 <uman> mike-burns: yes, some of the time... one of the things I'm working on though is migrating data from spreadsheets and access to a "real" database
21:58:51 <uman> I guess that involves coding too, but the really boring kind
21:59:00 <uman> and making reports in SQL Server Reporting Services
21:59:48 <inimino> writing one-off Perl scripts isn't boring :-)
21:59:50 <mike-burns> That's kinda tedious and crappy and whatnot, but it's significantly more fun than most people have at work.
21:59:54 <inimino> it's like improvisation
22:00:46 <mike-burns> I used to like one-off Perl scripts, but now I prefer one-off Ruby scripts that look like Perl.
22:01:04 <inimino> real Perl programmers can etc.
22:01:32 <mike-burns> Heh, it's true too.
22:01:34 <uman> mike-burns: yeah for sure
22:01:52 <uman> I don't know perl or any other language that would be suited to the task
22:02:06 <uman> it's not too clunky in modern C# though
22:02:17 <inimino> sounds like you've fallen into the .NET well of despair
22:02:34 <copumpkin> is the opposite of a forgetful a functor a "I make shit up" functor?
22:02:36 <uman> inimino: my boss being a microsoft fanboi doesn't help
22:02:46 <coCocoa> uman: I recommend K <ducks>
22:02:50 <inimino> ah
22:02:58 <uman> inimino: I don't mind C#/VB.NET though
22:03:07 <uman> they're basically Microsoft's implementations of Java
22:03:09 <uman> which isn't bad
22:03:19 <mike-burns> Is there a Haskell lib for interacting with MS Excel?
22:03:35 <uman> mike-burns: I dunno, but I didn't interact with Excel, I exported to csv
22:03:46 <uman> actually, tilde-separated values, because some of the records had commas in the fields
22:03:46 <mike-burns> Oh much better idea.
22:03:48 <idnar> uman: F#!
22:03:49 <coCocoa> copumpkin: An embellisher functor (it sounds more hoity-toity than "make shit up", y'know). ;)
22:03:49 <inimino> opinions vary :/
22:03:51 <inimino> Excel can export CSV
22:03:54 <uman> but same concept
22:04:03 <copumpkin> coCocoa: lol, I prefer my nomenclature
22:04:07 <idnar> man, we had some code that drove Excel via OLE
22:04:09 <uman> mike-burns: besides I don't know haskell yet
22:04:13 <idnar> what a nightmare
22:04:16 <uman> mike-burns: I just started learning it yesterday
22:04:25 <mike-burns> uman: That makes this the perfect reason to try doing this project in Haskell!
22:04:41 <uman> idnar: I looked into the Excel C API for a little bit
22:04:45 <uman> like, a few minutes
22:04:51 <idnar> did you know? Excel pops up a dialog the first time a user runs it
22:04:56 <uman> said "what, the fuck..." and decided to just export to CSV
22:05:04 <coCocoa> uman: Did your eyes sting a little after that look? ;p
22:05:07 <idnar> if you're driving it via OLE, this just looks like Excel has hung, because of course there's no visible Ui
22:05:08 <mike-burns> Most DBs can straight-up import a CSV.
22:05:31 <idnar> also, it's unlikely that anyone has ever run Excel before as IUSR_LOCALSERVICE or whatever that user is called
22:05:33 <mike-burns> (By "most" I mean the three I've tried, none of which are made by MS.)
22:05:33 <uman> mike-burns: not when the fields in the CSV don't correspond to the layout of the database
22:05:41 <uman> like, at all
22:05:48 <mike-burns> Fair enough.
22:05:57 <idnar> cue headscratching and wailing and gnashing of teeth
22:06:16 <uman> reading this one CSV results in the creation of records in like four different tables
22:06:43 <vinicius> debugging happy parser ftw
22:06:44 <idnar> also, you can cause the spreadsheet to become corrupted by putting data into cells that Excel can't handle properly
22:06:52 <inimino> uman: actually I think I wrote some basic text dicing and slicing scripts right away when I started with Haskell
22:07:11 <mike-burns> Is there a maintained CSV lib for Haskell?
22:07:15 <uman> inimino: hmm, well I have already written the C# app
22:07:25 <uman> inimino: but if I need to do something similar in the future I'll try haskell
22:07:49 <inimino> uman: you can write some very simple pure functions to deal with strings and use interact and you don't even need a monad tutorial
22:08:03 <copumpkin> mike-burns: bytestring-csv
22:08:07 <uman> mike-burns: CSV is easy to parse... the bigger question is does Haskell have functions to interact with sql server
22:08:25 <uman> in some sort of library
22:08:37 <mike-burns> uman: It doesn't need to, though; it just needs to take CSV in and spit a cleaned CSV out.
22:08:49 <inimino> you can always write SQL commands to stdout
22:09:07 <uman> yeah very true
22:09:27 <uman> maybe I'm just spoiled by the everything-plus-the-kitchen-sink attitude of .net
22:09:35 <copumpkin> "contravariant representable functors map all colimits to limits" like duh
22:09:39 <idnar> CSV is easy to parse, but there are about a million dialects
22:09:55 <uman> idnar: for a one-off text conversion script, that doesn't matter
22:10:04 <uman> I just have to parse whatever is spit out by Excel
22:10:11 <idnar> uman: sure, it just makes it harder to use a library vs. just writing your own parser
22:10:26 <idnar> although probably any CSV library will handle Excel dialect, at least :P
22:10:33 <Cale> uman: there are proper database libraries for Haskell
22:10:56 <idnar> uman: Haskell doesn't have quite the kitchen sink that .NET and Java do, but there's a lot of stuff on Hackage
22:10:57 <uman> idnar: I'd hope
22:11:03 <uman> ok
22:11:09 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database
22:11:23 <uman> I like .NET a lot. It fills a niche
22:11:24 <idnar> I would even say a surprising amount of stuff, given Haskell relative obscurity
22:11:35 <mike-burns> The DB libs for Haskell work reasonably well, too. They were my test of whether I wanted to pursue more Haskell, and they passed.
22:11:38 <uman> What I don't like is Microsoft's attitude that .NET is the answer to everything always
22:11:39 <idnar> insert "'s" in there somewhere
22:12:08 <idnar> I still want to play around with Takusen and so on... I haven't had much time for Haskell lately :/
22:12:11 <mike-burns> uman: What is .NET bad at? (I don't really know it well.)
22:12:48 <uman> mike-burns: well as an example of misplaced .NET fanboyism
22:12:53 <idnar> oh look, the first package by category is http://hackage.haskell.org/package/hs-dotnet
22:13:01 <uman> Microsoft has undertaken to rewrite large parts of Visual Studio in .NET
22:13:13 <uman> VS2008 runs slow on my 2.0 GHz Core 2 Duo machine with 4GB of ram
22:13:22 <uman> Moving it to a virtual machine is probably not the answer
22:13:54 <mike-burns> But by the time they finish re-writing it, your machine will be upgraded.
22:14:24 <uman> mike-burns: I see requiring users to buy new computers every few years as a bug, not a feature.
22:16:28 <Cale> http://www.cs.chalmers.se/~bringert/publ/haskelldb/haskelldb-db-2005.pdf is some intro-to-HaskellDB slides. HaskellDB is one of the more interesting database libraries. There's also HDBC if you just want to construct queries as strings.
22:16:41 <vyom> (newb alert) Is there something wrong with the code here : http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2963#a2963 I keep getting Couldn't match expected type `IO String' against inferred type `[String]' in line 6 tweetsJSONString <- (readContentsURL url)
22:16:50 <uman> vyom: we don't tolerate newbs here
22:17:09 <vyom> uman:  in that case which forum should I go to?
22:17:18 <uman> vyom: I forgot this was the internet
22:17:25 <uman> and I needed a big </SARCASM> tag or something
22:17:41 <mike-burns> vyom: To be clear, we allow newbs here.
22:17:55 <uman> vyom: since I've been flooding the channel with unadulterated newbishness tonight and last night
22:18:06 <uman> :)
22:18:07 <idnar> we immediately get rid of "newbs" by enlightening them ;)
22:18:17 <vyom> lol
22:18:36 <vyom> in that case somebody please enlighten me
22:21:07 <Cale> vyom: hmm, that's odd...
22:21:42 <vyom> Cale: is there any other context you need..
22:21:51 <vyom> i did not think so
22:22:12 <mike-burns> vyom: Can you also paste readContentsURL ?
22:22:33 <uman> if anyone cares, the relevant section of Learn You as Haskell does not consider 0 to be in |N
22:22:35 <copumpkin> we need a Semigroup class
22:22:40 <Cale> That's really the correct type for readContentsURL?
22:22:44 <idnar> hmm, my cabal seems broken
22:22:48 <copumpkin> then we could define Minimum and Maximum
22:22:55 <Cale> uman: Interesting.
22:23:28 <uman> but BONUS doesn't speak for all mathematicians
22:23:30 <vyom> Cale:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2963#a2964 here u go..
22:23:36 <idnar> "cabal install foo" just... doesn't do anything
22:23:44 <coCocoa> vyom: By making "tweets" the result of one of your outer case statement evals, you're declaring it of type [JSValue]. However, your other branch is a do statement which involves the IO monad.
22:23:56 <Cale> oh of course!
22:23:57 <coCocoa> vyom: Your types don't match, in other words. :)
22:24:07 <copumpkin> someone making a twitter client in haskell?
22:24:08 <Cale> Your type signature for readTwitterStream is wrong
22:24:14 <copumpkin> :op
22:24:30 <Cale> Delete the type signature and see if it works :)
22:24:52 <Cale> readTwitterStream does IO and yet IO does not appear in the type, so the type can't be right
22:25:06 <uman> hey does anyone keep logs of this channel?
22:25:06 <Cale> My guess is that it thought you wanted the list monad.
22:25:08 <coCocoa> I need a semidirect product class; I get dizzy figuring that thing out. ;p
22:25:23 <Cale> http://tunes.org/~nef/logs/haskell/
22:25:28 <uman> Cale: thanks
22:25:35 <Cale> (it's in the topic :)
22:26:01 <uman> Cale: haven't figured out how to get irssi to log by default yet, and I wanted to look back over some of the things you were telling me yesterday while I read LYaH
22:26:07 <uman> Cale: sorry for not reading topic :)
22:26:11 <hamishmack> vyom: also replace "False -> tweets" with "False -> return tweets"
22:27:03 <Cale> coCocoa: I'm trying to work out what you mean by that comment.
22:27:20 <Cale> coCocoa: You need an explanation of semidirect products?
22:27:37 <mmorrow_> this is neat, it's the type dependency graph for Language.Haskell.TH.Exp, first the whole thing, then the transitive reduction, than the dominator tree of the whole thing rooted at Exp  http://moonpatio.com/vacuum/gallery/Exps_all_tred_dom.png
22:27:40 <hamishmack> correct type is probably readTwitterStream_ :: Int -> [JSValue] -> IO [JSValue]
22:28:05 <copumpkin> :o
22:28:12 <mmorrow_> dominators make type depgraphs soooo much nicer
22:28:23 <copumpkin> yeah
22:28:34 <Cale> mmorrow_: Did you see the depgraph for all of hackage?
22:28:36 <mmorrow_> (they don't do much for modules though, since those graphs seem to be mostly wide and shallow)
22:28:46 <mmorrow_> Cale: ooh, good idea
22:29:01 <mmorrow_> Cale: the package level would get interesting again
22:29:12 <vyom> Cale : Ok I get it now.. there is something wrong with the do block. It should not be there. the readTwitterStream_ should not be doing IO.. the IO is done in readContentsURL.. but i need the contents of the IO monad in the readTwitterStream_ function
22:29:14 <Cale> I think it was actually a module dependency graph
22:29:19 <Cale> for all the modules in all the packages
22:29:29 <hamishmack> and you might need to do "someValue <- runGetJSON readJSArray tweetsJSONString"
22:29:36 <coCocoa> Cale: Yeah, I'm reading a paper that uses wreath products, with which I'm unfamiliar. So I WP'd it...and got lost. :)
22:29:43 <mmorrow_> Cale: hmm, iirc it was a package depgraph
22:29:46 <hamishmack> instead of using it in the case
22:29:59 <mmorrow_> Cale: the module graphs are boring, since there can't be any cycles..
22:30:07 <Cale> http://donsbot.wordpress.com/2009/03/16/visualising-the-haskell-universe/
22:30:38 <vyom> hamishmack: I dont want readTwitterStream_ to be doing IO.. the do block should not be there.. I was using it wrongly
22:30:39 <mmorrow_> Cale: oh nice, so it *is* modules
22:31:35 <vyom> hamishmack: now to figure out how I can keep IO in the readContentsURL function and access the string in the readTwitterStream function..
22:31:57 <mmorrow_> Cale: dominators would actually turn out to be really nice for those cluttered module graphs on second though
22:31:59 <Cale> vyom: readTwitterStream should take a string as a parameter then :)
22:32:09 <mmorrow_> (i wasn't thinking big enough...)
22:32:21 <Cale> vyom: (or a list of strings)
22:33:32 <mmorrow_> hmm, well for modules (and probably packages too) postdominators may be the better way to do it
22:33:33 <Cale> vyom: But, given what it's doing, it does look like it's mostly deciding what I/O to do.
22:33:47 <mmorrow_> err, i guess both would be interesting
22:34:09 <uman> hmm, seems like Haskell's if statement is basically the ?: operator from C
22:34:36 <copumpkin> uman: yup, it has to be
22:34:48 <uman> mhm
22:35:01 <copumpkin> it's an if expression really
22:35:12 * copumpkin wouldn't mind removing it)
22:36:15 <mmorrow_> Cale: http://www.galois.com/~dons/tmp/hackage.dot
22:36:31 <mmorrow_> crap, now i've gotta parse the .dot
22:36:38 <coCocoa> vyom: Just for future reference, but you should NEVER (!!!!!) use "length someList > 0", unless someone's threatening to kill someone you don't want dead.
22:36:55 <copumpkin> lol
22:37:07 <copumpkin> how about length someList > (0 :: Natural) ?
22:37:50 <copumpkin> > length [5..] > (0 :: Natural)
22:37:52 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
22:37:57 <coCocoa> vyom: If you must, "not (null someList)" is more direct, and it doesn't threaten to calculate the length of a list, whose actual length you don't give a rip about. That's kind of the point with laziness. :)
22:37:58 <vyom> Cale: my understanding of the do block is that the last expression is the return value.. hence its usage in the readTwitterStream_ function..  my intended return value is actually in the second case statement in the nested do
22:37:58 <copumpkin> > genericLength [5..] > (0 :: Natural)
22:38:00 <lambdabot>   True
22:38:12 <vyom> coCocoa:  thanks.. will keep that in mind
22:39:36 <coCocoa> vyom: It's not my observation, just something that Greater Minds let me glean from the H-Wiki. :)
22:40:30 <mmorrow_> Cale: ohhh, he didn't use the package dependencies for edges, but make an undirected tree of the package namesspace
22:40:40 <mmorrow_> s/make/made/
22:40:54 <copumpkin> he had a dependency one too
22:41:03 <copumpkin> I thought
22:41:05 <copumpkin> hrm
22:42:30 <copumpkin> Cale: does the opposite of a forgetful functor have a name?
22:43:00 <ray> eidetic functor
22:43:12 <copumpkin> you serious?
22:43:22 <ray> never
22:43:25 <copumpkin> :P
22:43:28 <ray> it's what i'd name it
22:43:29 <SamB_XP> elephant functor
22:43:37 <edwardk> @seen shapr
22:43:38 <lambdabot> shapr is in #haskell.se, #haskell-blah, #ghc and #haskell. I last heard shapr speak 1h 50m ago.
22:44:49 <FunctorSalad_> copumpkin: if by "opposite" you mean left adjoint, these are generally free things
22:44:51 <FunctorSalad_> :)
22:45:18 <copumpkin> aw
22:45:20 <FunctorSalad_> e.g. free group -| forgetful f. from group to set
22:45:36 <FunctorSalad_> s/group/nearly any algebraic thingy
22:45:49 <copumpkin> :P
22:45:55 <copumpkin> free magma
22:46:12 <FunctorSalad_> it's opposite in a quite deep way IMHO :)
22:46:22 <copumpkin> :o
22:47:26 <FunctorSalad_> the forgetful functor forgets the structure, the free one make a structure up "in the most generic way"
22:47:35 <copumpkin> ah
22:47:37 <FunctorSalad_> *makes
22:47:48 <copumpkin> so it is the "make shit up" functor I described before
22:48:02 <FunctorSalad_> yeah.
22:48:08 <copumpkin> cool
22:56:10 <gwern> > 365 * 70
22:56:11 <lambdabot>   25550
22:56:25 <gwern> > 32000000 / 25550
22:56:26 <lambdabot>   1252.4461839530334
22:56:34 <gwern> > 1/1252
22:56:35 <lambdabot>   7.987220447284345e-4
22:58:37 <uman> copumpkin: why wouldn't you mind removing it?
22:59:01 <copumpkin> I think it's kinda ugly :)
22:59:09 <ray> because we can do better with just a regular function
22:59:13 <FunctorSalad_> somehow this comes up again and again..
22:59:16 <ray> we call it if' around here
22:59:24 <FunctorSalad_> ..... but you save parentheses ......
22:59:30 <copumpkin> FunctorSalad_: I for one bring it up regularly :P
22:59:33 <ray> there's also my personal favorite, (??)
22:59:36 <copumpkin> FunctorSalad_: I'd also like $ to change associativity
22:59:52 <FunctorSalad_> copumpkin: that one I agree with
22:59:57 <ray> i'd like $ to have the same associativity regular function application has :)
23:00:13 <FunctorSalad_> wouldn't that completely defeat the point
23:00:15 <copumpkin> and using it with the correct associativity would allow an if function to be less parenthesis-ridden
23:01:37 <hzap> @src iterate
23:01:38 <lambdabot> iterate f x =  x : iterate f (f x)
23:04:01 <JN> good evening
23:04:07 <uman> JN: hello
23:06:02 <coCocoa> ray: What's the definition? :)
23:06:10 <ray> of what?
23:06:20 <coCocoa> ray Of "??"
23:06:48 <coCocoa> Hmm, The defn of (??), that is. :)
23:06:59 <ray> (t ?? f) p = if p then t else f
23:07:18 * SamB_XP could not help but think of "ray of light" or "ray of sunshine" or something
23:07:29 <coCocoa> ray: Interesting; my version if the other way. :)
23:07:30 <copumpkin> ray: that's kinda cute
23:07:38 <copumpkin> I like ray's version
23:07:39 <ray> which library is it in
23:07:50 <ray> and yeah, i could have reversed it somehow
23:07:55 <coCocoa> p ?: (t, f) = if p then t else f
23:08:24 <jeffwheeler> That's the most concise ternary definition I've seen for Haskell.
23:08:25 <ray> that's not quite as interesting
23:08:29 <jeffwheeler> Well, the only. But it's concise and I like it.
23:08:32 <coCocoa> ray: It's in my Utility file, Util.Fun, I think. :)
23:08:54 <ray> but it is a pretty accurate ?:
23:09:04 <coCocoa> Then, if' = curry . (?:)
23:09:50 <ray> that (??) is in some library, but hoogle is down :o
23:10:19 <jakeplay_> is the haskell.org site down?
23:10:26 <ray> yes, i suppose
23:10:34 <meder> yep
23:10:46 <jakeplay_> doh
23:11:12 <jakeplay_> got a few hxt questions
23:11:53 <jeffwheeler> Hayoo is up, but it doesn't find (??).
23:12:05 <jeffwheeler> Wait, nevermind.
23:12:11 <jeffwheeler> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=#0:(%3F%3F)
23:12:24 <jakeplay_> is the wiki mirrored anywhere?
23:12:41 <jakeplay_> wow, it just came back
23:12:51 <coCocoa> jakeplay_: We welcome questions. It keeps down the chatter about cookies-as-food versus cookies-as-data
23:12:59 <coCocoa> ;p
23:13:19 <JN> so... can you define any arbitrary symbol (combination of chars) as a function?  what are the restrictions?   and, is it the presence of alpha chars in the function name that make it a prefix function
23:13:24 <jakeplay_> glad to be at service
23:13:53 <SamB_XP> JN: it basically has to be all alphanumeric or all punctuation
23:14:08 <JN> ok. and alpha are prefix, punctuation are infix
23:14:10 <jakeplay_> getXPathTrees gives one [XmlTree], what's a quick way to get the inverse?
23:14:11 <SamB_XP> and yeah, the alphanumeric ones are the ones that are prefix
23:14:16 <JN> thanks
23:14:43 <SamB_XP> there's a *little* more to it than that, but not much
23:15:15 <SamB_XP> I mean, ' (and # with the right extension enabled) may not quite fit that generalization ...
23:15:41 <ray> haskell is baselessly alleged by things like the h98 report to be unicode, too
23:16:29 <SamB_XP> well, GHC allows some of that these days
23:16:38 <SamB_XP> just don't try to write variable names in japanese ;-)
23:17:00 <Rotaerk> american is the only language you should use for programming anyway
23:17:06 <Rotaerk> go america !
23:17:16 <SamB_XP> I only say that because japanese doesn't have upper and lower case
23:17:31 <Rotaerk> hehe
23:17:56 <SamB_XP> so it's hard to distinguish your constructors from your variables
23:17:58 <ray> the problem is that case matters syntactically
23:17:59 <ray> yeah
23:18:00 <uman> SamB_XP: I heard an anecdotal story that many companies found Playstation 2 development to be something of a nightmare because a lot of functions, macros, etc. had japanese names
23:18:18 <ray> poor babies
23:18:19 <SamB_XP> uman: I imagine those were in romaji
23:18:23 <uman> SamB_XP: well yeah
23:18:30 <uman> SamB_XP: but still, not in English
23:18:30 <SamB_XP> I meant in actually kana/kanji
23:18:42 <copumpkin> t(e)isshuupeepaa
23:18:44 <uman> I know it's not the same situation, you just reminded me of that story
23:18:51 <SamB_XP> okay ;-)
23:18:59 <copumpkin> -s
23:19:05 <jakeplay_> uman, should feel thankful at leas the opcodes are not in japanese
23:19:53 <SamB_XP> jakeplay_: opcodes are in binary!
23:19:58 <SamB_XP> how could they be in japanese?
23:20:22 <jakeplay_> isn't everything?
23:20:28 <Rotaerk> replace 1's and 0's with :)'s and :D's
23:20:29 * coCocoa thinks that looks more like Finnish than Japanese... :)
23:20:33 <copumpkin> maybe the opcodes are shift-jis
23:21:45 <SamB_XP> :):D:D:)
23:22:00 <SamB_XP> what kind of japanese is that?
23:22:12 <JN> was gone for a moment.  so, haskell doesn't do unicode?
23:22:18 <copumpkin> JN: "do"?
23:22:19 <copumpkin>  :P
23:22:22 <JN> umm
23:22:47 <JN> rephrase:  what char set must the source file be in?
23:22:48 <copumpkin> JN: even haskell source can have arbitrary code points in names
23:22:51 <copumpkin> utf-8
23:22:57 <SamB_XP> what *I* said is "don't name your variables in japanese characters", basically
23:22:58 <jakeplay_> where can i find some more examples of insert/grafting using hxt? (most examples are for query)
23:23:22 <ray> don't name your variables anything without upper and lower case
23:23:48 <SamB_XP> well, it's okay as long as you can tell which case it is ;-)
23:23:54 <copumpkin> unfortunately they're neither, so haskell doesn't let you
23:24:09 <copumpkin> > isUpper '肛'
23:24:11 <lambdabot>   False
23:24:15 <copumpkin> > isLower '肛'
23:24:16 <lambdabot>   False
23:24:19 <JN> wouldn't a caseless char be interpreted as lower case
23:24:24 <JN> ah. thanks
23:24:25 <copumpkin> nope
23:24:25 <SamB_XP> > isAlpha '肛
23:24:26 <lambdabot>   <no location info>:
23:24:27 <lambdabot>      lexical error in string/character literal at end o...
23:24:28 <ray> no, lower case is a case
23:24:31 <SamB_XP> > isAlpha '肛'
23:24:32 <lambdabot>   True
23:24:46 * copumpkin snickers at SamB_XP
23:25:10 <SamB_XP> > let x肛 = 1 in x肛
23:25:11 <lambdabot>   1
23:25:31 <SamB_XP> well, to clarify, don't use them at the beginning of your variable names
23:25:35 <copumpkin> :P
23:25:44 <copumpkin> xanus
23:25:52 * copumpkin grins
23:26:04 <SamB_XP> copumpkin: is that what that says?
23:26:08 <copumpkin> yeah :P
23:26:27 <ray> really now!
23:26:31 <SamB_XP> > let ur肛 = 1 in ur肛
23:26:32 <lambdabot>   1
23:26:36 * jeffwheeler likes the idea of unicode arrows and the like
23:26:42 <uman> a great entry to the Underhanded C Code Contest would be one that uses Unicode to make it look like two identifiers are actually the same whereas in fact they just have identical glyphs
23:27:01 <Cale> data 石 = 黒 | 白
23:27:05 <SamB_XP> uman: the what now ?
23:27:09 <SamB_XP> Cale: what's that?
23:27:11 <copumpkin> Cale: that works?
23:27:11 <jeffwheeler> uman: I like it
23:27:14 <JN> > let ?????? = 1 in ??????
23:27:16 <lambdabot>   <no location info>: parse error on input `??????'
23:27:20 <Cale> No, I didn't try it
23:27:21 <JN> argh.
23:27:23 <SamB_XP> and no, that wouldn't work
23:27:29 <uman> SamB_XP: contest to write C that does something evil which isn't obvious from a casual inspection of the source code
23:27:41 <copumpkin> data Stone = Black | White
23:28:07 <SamB_XP> > map (isLower &&& isUpper) "石黒白"
23:28:07 <ray> | Yellow
23:28:08 <lambdabot>   [(False,False),(False,False),(False,False)]
23:28:33 <jeffwheeler> @type (a :: Int) → b
23:28:35 <lambdabot> parse error on input `→'
23:28:45 <jeffwheeler> @type Err
23:28:46 <lambdabot> Not in scope: data constructor `Err'
23:28:48 <jeffwheeler> wait, gah
23:29:11 <jeffwheeler> @type ((+1) ·)
23:29:13 <lambdabot> Not in scope: `·'
23:29:16 <jeffwheeler> Oh, that's lame.
23:29:18 <ray> gah = general algebraic haskell
23:29:32 <SamB_XP> > let x → y = x^(y^y) in 5 → 3
23:29:34 <lambdabot>   <no location info>: parse error on input `→'
23:29:36 <JN> ??????
23:29:42 <SamB_XP> aww
23:29:51 <jeffwheeler> I thought GHC could support Unicode like ·?
23:30:08 <ray> it said not in scope
23:30:09 <SamB_XP> jeffwheeler: only if it's in scope
23:30:14 <jeffwheeler> Oh, doh.
23:30:17 <copumpkin> :t xor
23:30:19 <lambdabot> forall a. (Bits a) => a -> a -> a
23:30:24 <JN> 
23:30:27 <SamB_XP> jeffwheeler: at least yours didn't give a syntax error
23:30:27 <ray> :t xorn
23:30:28 <lambdabot> Not in scope: `xorn'
23:30:30 <jeffwheeler> I'm bad at this whole writing code spontaneously in IRC thing.
23:30:37 <JN> > let ʴ = 1 in ʴ
23:30:39 <lambdabot>   <no location info>: parse error on input `���'
23:30:41 <copumpkin> > map (liftM2 (/=) isLower isUpper) "石黒白"
23:30:43 <lambdabot>   [False,False,False]
23:30:51 <SamB_XP> JN: now that's a good error
23:30:54 <ray> liftA2*
23:31:04 <copumpkin> fine fine
23:31:13 <ray> a simple typo
23:31:18 <copumpkin> > length $ map (liftA2 (/=) isLower isUpper) [minBound..maxBound]
23:31:20 <lambdabot>   1114112
23:31:23 <JN> did others see my chars that last time?  unsure of how to configure mirc
23:31:30 <copumpkin> > length . filter id . map (liftA2 (/=) isLower isUpper) $ [minBound..maxBound]
23:31:32 <lambdabot>   3200
23:31:39 <SamB_XP> JN: saw them
23:31:43 <copumpkin> > length . filter not . map (liftA2 (/=) isLower isUpper) $ [minBound..maxBound]
23:31:45 <lambdabot>   1110912
23:31:46 <SamB_XP> but lambdabot's error didn't have any in them
23:31:48 <JN> ok.  just the bot couldn't. :)
23:31:49 <SamB_XP> er. in it
23:32:11 <SamB_XP> so I dunno what she's smoking, but maybe she's been getting it from gwern ;-)
23:32:18 <ray> that's a lot of characters
23:32:25 <copumpkin> > length . filter id . map ((/=) <$> isLower <*> isUpper) $ [minBound..maxBound]
23:32:27 <lambdabot>   3200
23:33:52 <SamB_XP> > filter snd . map (id &&& (/=) <$> isLower <*> isUpper) $ [minBound..maxBound]
23:33:54 <lambdabot>   [('A',True),('B',True),('C',True),('D',True),('E',True),('F',True),('G',Tru...
23:34:05 <SamB_XP> > filter snd . map (id &&& (==) <$> isLower <*> isUpper) $ [minBound..maxBound]
23:34:07 <lambdabot>   [('\NUL',True),('\SOH',True),('\STX',True),('\ETX',True),('\EOT',True),('\E...
23:34:23 <JN> > let aʴ = 1 in aʴ
23:34:24 <lambdabot>   <no location info>: lexical error at character '\692'
23:34:44 <copumpkin> whoa, some things are both upper and lower case?
23:34:47 <SamB_XP> > filter snd . map (id &&& (==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:34:49 <lambdabot>   [('\443',True),('\448',True),('\449',True),('\450',True),('\451',True),('\6...
23:34:53 <copumpkin> > length . filter id . map ((==) <$> isLower <*> isUpper) $ [minBound..maxBound]
23:34:56 <lambdabot>   1110912
23:35:05 <copumpkin> or I guess neither
23:35:08 <copumpkin> :P
23:35:14 <ray> those are presumably mostly neither
23:35:25 <SamB_XP> > map fst . filter snd . map (id &&& (==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:35:27 <lambdabot>   "\443\448\449\450\451\660\688\689\690\691\692\693\694\695\696\697\698\699\7...
23:35:27 <ray> maybe some things are both :P
23:35:39 <SamB_XP> > text $ map fst . filter snd . map (id &&& (==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:35:41 <lambdabot>   ƻǀǁǂǃʔʰʱʲʳʴʵʶʷʸʹʺʻʼʽʾʿˀˁˆˇˈˉˊˋˌˍˎˏːˑˠ...
23:35:52 <copumpkin> > length . filter id . map ((&&) <$> isLower <*> isUpper) $ [minBound..maxBound]
23:35:53 <lambdabot>   0
23:35:54 <ColeSOAR> may i ask a non-haskell question?  u guys may be able to help anyways cos you're so cool?
23:35:58 <copumpkin> damn right
23:36:00 <ray> guess not
23:36:03 <copumpkin> ColeSOAR: depends how far from haskell it is
23:36:07 <JN> I don't know haskell.. so maybe I can help you
23:36:11 <ray> well, there's always titlecase
23:36:44 <SamB_XP> , text $ map fst . filter snd . map (id &&& (==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:36:46 <lunabot>  luna: Not in scope: `&&&'
23:36:54 <copumpkin> aw
23:37:27 <SamB_XP> , text . map fst . filterBy ((==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:37:28 <lunabot>  luna: Not in scope: `filterBy'
23:37:38 <SamB_XP> , text . map fst . filter ((==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:37:40 <lunabot>  luna: Couldn't match expected type `(a, b)'
23:37:48 <SamB_XP> , text . filter ((==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:38:02 <lunabot>  PRIVMSG mvr : 2
23:38:07 <vyom> does ending a function name with underscore have any significane? I have this bizarre error where the program compiles successfully if I have the function ending with underscore but throws an error when it does not have an underscore
23:38:07 <copumpkin> o.O
23:38:12 <SamB_XP> what the heck?
23:38:19 <copumpkin> mmorrow_: zomg bug
23:38:19 <SamB_XP> , filter ((==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:38:21 <lunabot>  "\443\448\449\450\451\660\688\689\690\691\692\693\694\695\696\697\698\699...
23:38:48 <SamB_XP> copumpkin: well, at least lunabot spurred me to golf it down to a nicer shape ;-)
23:38:56 <copumpkin> :P
23:41:36 <edwardk> vyom: are you aliasing it somewhere? does it do anything different if you change the _ into another character? =)
23:41:55 <ray> hmm, there's no titlecase predicate
23:41:56 <vyom> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2965#a2965 here is the code. Works without a hitch. I rename the method readTwitterStream_ to readTwitterStream and it blows up with error " The last statement in a 'do' construct must be an expression line 29:35"
23:42:08 <vyom> edwardk:  check out the entire code
23:42:24 <vyom> edwardk:  just a few lines.. all in one file
23:43:38 <jeffwheeler> vyom: it might help to clean up/tighten the spacing a bit, so it's easier to read
23:44:08 <jeffwheeler> vyom: oh, and by deleting the underscore, the 'case' isn't going to be aligned with the 'let', on line 30
23:44:19 <edwardk> ah
23:44:48 <jeffwheeler> (Plug: Yi would handle this correctly, and automatically unindent the rest of the code.)
23:44:53 <ray> > length $ filter ((== TitlecaseLetter) . generalCategory) [minBound..maxBound]
23:44:55 <lambdabot>   31
23:44:58 <jeffwheeler> (You can thank anders^^ for that.)
23:45:01 <edwardk> try removing the sensitivity of the layout, by moving to let after the do down to the next line
23:45:18 <vyom> jeffwheeler:  aargh!  thanks
23:45:40 <jeffwheeler> Personally, I'd leave the 'do' where it is, and put the 'let' down one line indented with four spaces.
23:47:07 <vyom> jeffwheeler:  yes.. will do that. Having a bit of a hard time getting used to the indentation :)
23:47:31 <jeffwheeler> vyom: I'm totally anal, so I love the spacing stuff :)
23:47:31 <coCocoa> jeffwheeler: "I'll get right on" thanking anders...just as soon as I successfully compile Yi. :\
23:47:33 <mmorrow_> copumpkin: hah
23:47:48 <jeffwheeler> coCocoa: darcs or the release?
23:47:48 <mmorrow_> , text . filter ((==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:48:10 <mmorrow_> did lunabot bite it..
23:48:14 <vyom> jeffwheeler:  any tips on that. I am not sure what is a 'good' indentation practise. And I am using Emacs Haskell mode which is doing most of it
23:49:03 <jeffwheeler> vyom: It's mostly subjective, but I try keeping things tight, but without extending too far to the right, usually helps
23:49:24 <vyom> jeffwheeler:  could you point to any samples online?
23:49:30 <jeffwheeler> hmm
23:49:38 <mmorrow_> ah, i think it was one of those things where it blocks when it gets no input..
23:49:47 <mmorrow_> and then just waits forever
23:50:02 <mmorrow_> (no input (:= response) from the eval prog)
23:50:38 <mmorrow_> , text . filter ((==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:50:47 <mmorrow_> , 9
23:51:04 <jeffwheeler> vyom: I guess just looking at tons of pieces of sample code as you go along learning helps; say, for example, reading through all the examples in RWH
23:51:19 <jeffwheeler> vyom: because the authors of good code usually are pretty experienced in indentation :)
23:51:20 <vyom> jeffwheeler:  thanks
23:55:18 <mmorrow_> , text . utf8enc . filter ((==) <$> isLower <*> isUpper) $ filter isAlpha $ [minBound..maxBound]
23:55:20 <lunabot>  ƻǀǁǂǃʔʰʱʲʳʴʵʶʷʸʹʺʻʼʽʾʿˀˁˆˇˈˉˊˋˌˍˎˏːˑˠˡˢˣˤˬˮʹͺՙאבגדהוזחטיךכלםמןנסעףפץצקרשת...
23:56:53 <jeffwheeler> Woah, there, lunabot.
23:57:53 <performance> is there a haskell binding to imagemagick ?
23:58:03 <mmorrow_> @hackage hsmagick
23:58:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsmagick
23:59:02 <performance> what is GraphicsMagick ?
23:59:31 <performance> dont answer
